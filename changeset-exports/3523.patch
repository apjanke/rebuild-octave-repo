# HG changeset patch
# User jwe
# Date 949487185 0
#      Wed Feb 02 10:26:25 2000 +0000
# Node ID b80bbb43a1a951eb9eb8591a38a36826316227f2
# Parent  bd422cf62f0c92a6004b0cbc13448100c508ed1e
[project @ 2000-02-02 10:25:52 by jwe]

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,12 @@
+2000-02-02  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* All source files: Sprinkle with std:: qualifier as needed.
+
 2000-01-31  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* sighandlers.cc (install_signal_handlers): Add std:: qualifier
 	for set_net_handler.
 
 	* All source files: Include iostream, fstream, strstream,
 	etc. as needed instead of using forward declarations for these
 	classes.
diff --git a/src/DLD-FUNCTIONS/balance.cc b/src/DLD-FUNCTIONS/balance.cc
--- a/src/DLD-FUNCTIONS/balance.cc
+++ b/src/DLD-FUNCTIONS/balance.cc
@@ -111,17 +111,17 @@ Generalized eigenvalue problem balancing
   if (nargin < 1 || nargin > 3 || nargout < 0 || nargout > 4)
     {
       print_usage ("balance");
       return retval;
     }
 
   // determine if it's AEP or GEP
   int AEPcase = nargin == 1 ? 1 : args(1).is_string ();
-  string bal_job;
+  std::string bal_job;
 
   // problem dimension
   int nn = args(0).rows ();
 
   int arg_is_empty = empty_arg ("balance", nn, args(0).columns());
 
   if (arg_is_empty < 0)
     return retval;
diff --git a/src/DLD-FUNCTIONS/colloc.cc b/src/DLD-FUNCTIONS/colloc.cc
--- a/src/DLD-FUNCTIONS/colloc.cc
+++ b/src/DLD-FUNCTIONS/colloc.cc
@@ -86,17 +86,17 @@ Polynomial Approximation}.\n\
       if (args(i).is_defined ())
 	{
 	  if (! args(i).is_string ())
 	    {
 	      error ("colloc: expecting string argument");
 	      return retval;
 	    }
 
-	  string s = args(i).string_value ();
+	  std::string s = args(i).string_value ();
 
 	  if ((s.length () == 1 && (s[0] == 'R' || s[0] == 'r'))
 	      || s == "right")
 	    {
 	      right = 1;
 	    }
 	  else if ((s.length () == 1 && (s[0] == 'L' || s[0] == 'l'))
 		   || s == "left")
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -21,17 +21,17 @@ Software Foundation, 59 Temple Place - S
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <string>
 
-#include <iostream.h>
+#include <iostream>
 
 #include "DASSL.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov-fcn.h"
@@ -295,17 +295,17 @@ static DASSL_OPTIONS dassl_option_table 
 
   { 0,
     { 0, 0, 0, 0, },
     { 0, 0, 0, 0, }, 0,
     0, 0, },
 };
 
 static void
-print_dassl_option_list (ostream& os)
+print_dassl_option_list (std::ostream& os)
 {
   print_usage ("dassl_options", 1);
 
   os << "\n"
      << "Options for dassl include:\n\n"
      << "  keyword                                  value\n"
      << "  -------                                  -----\n\n";
 
@@ -325,17 +325,17 @@ print_dassl_option_list (ostream& os)
       os << "\n";
       list++;
     }
 
   os << "\n";
 }
 
 static void
-set_dassl_option (const string& keyword, double val)
+set_dassl_option (const std::string& keyword, double val)
 {
   DASSL_OPTIONS *list = dassl_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
@@ -345,17 +345,17 @@ set_dassl_option (const string& keyword,
 	}
       list++;
     }
 
   warning ("dassl_options: no match for `%s'", keyword.c_str ());
 }
 
 static octave_value_list
-show_dassl_option (const string& keyword)
+show_dassl_option (const std::string& keyword)
 {
   octave_value retval;
 
   DASSL_OPTIONS *list = dassl_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
@@ -393,17 +393,17 @@ their current values are displayed.\n\
 
   if (nargin == 0)
     {
       print_dassl_option_list (octave_stdout);
       return retval;
     }
   else if (nargin == 1 || nargin == 2)
     {
-      string keyword = args(0).string_value ();
+      std::string keyword = args(0).string_value ();
 
       if (! error_state)
 	{
 	  if (nargin == 1)
 	    return show_dassl_option (keyword);
 	  else
 	    {
 	      double val = args(1).double_value ();
diff --git a/src/DLD-FUNCTIONS/fsolve.cc b/src/DLD-FUNCTIONS/fsolve.cc
--- a/src/DLD-FUNCTIONS/fsolve.cc
+++ b/src/DLD-FUNCTIONS/fsolve.cc
@@ -21,17 +21,17 @@ Software Foundation, 59 Temple Place - S
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <string>
 
-#include <iostream.h>
+#include <iostream>
 
 #include "NLEqn.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 #include "ov-fcn.h"
@@ -235,17 +235,17 @@ static NLEQN_OPTIONS fsolve_option_table
 
   { 0,
     { 0, 0, },
     { 0, 0, }, 0,
     0, 0, },
 };
 
 static void
-print_fsolve_option_list (ostream& os)
+print_fsolve_option_list (std::ostream& os)
 {
   print_usage ("fsolve_options", 1);
 
   os << "\n"
      << "Options for fsolve include:\n\n"
      << "  keyword                                  value\n"
      << "  -------                                  -----\n\n";
 
@@ -265,17 +265,17 @@ print_fsolve_option_list (ostream& os)
       os << "\n";
       list++;
     }
 
   os << "\n";
 }
 
 static void
-set_fsolve_option (const string& keyword, double val)
+set_fsolve_option (const std::string& keyword, double val)
 {
   NLEQN_OPTIONS *list = fsolve_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
@@ -285,17 +285,17 @@ set_fsolve_option (const string& keyword
 	}
       list++;
     }
 
   warning ("fsolve_options: no match for `%s'", keyword.c_str ());
 }
 
 static octave_value_list
-show_fsolve_option (const string& keyword)
+show_fsolve_option (const std::string& keyword)
 {
   octave_value retval;
 
   NLEQN_OPTIONS *list = fsolve_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
@@ -333,17 +333,17 @@ their current values are displayed.\n\
 
   if (nargin == 0)
     {
       print_fsolve_option_list (octave_stdout);
       return retval;
     }
   else if (nargin == 1 || nargin == 2)
     {
-      string keyword = args(0).string_value ();
+      std::string keyword = args(0).string_value ();
 
       if (! error_state)
 	{
 	  if (nargin == 1)
 	    return show_fsolve_option (keyword);
 	  else
 	    {
 	      double val = args(1).double_value ();
diff --git a/src/DLD-FUNCTIONS/getgrent.cc b/src/DLD-FUNCTIONS/getgrent.cc
--- a/src/DLD-FUNCTIONS/getgrent.cc
+++ b/src/DLD-FUNCTIONS/getgrent.cc
@@ -68,24 +68,24 @@ DEFUN_DLD (getgrent, args, ,
  "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{grp_struct} =} getgrent ()\n\
 Return an entry from the group database, opening it if necessary.\n\
 Once the end of the data has been reached, @code{getgrent} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = 0.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
-      string msg;
+      std::string msg;
 
       retval(0) = mk_gr_map (octave_group::getgrent (msg));
       retval(1) = msg;
     }
   else
     print_usage ("getgrent");
 
   return retval;
@@ -96,32 +96,32 @@ DEFUN_DLD (getgrgid, args, ,
 @deftypefn {Loadable Function} {@var{grp_struct} =} getgrgid (@var{gid}).\n\
 Return the first entry from the group database with the group ID\n\
 @var{gid}.  If the group ID does not exist in the database,\n\
 @code{getgrgid} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = 0.0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       double dval = args(0).double_value ();
 
       if (! error_state)
 	{
 	  if (D_NINT (dval) == dval)
 	    {
 	      gid_t gid = static_cast<gid_t> (dval);
 
-	      string msg;
+	      std::string msg;
 
 	      retval(0) = mk_gr_map (octave_group::getgrgid (gid, msg));
 	      retval(1) = msg;
 	    }
 	  else
 	    error ("getgrgid: argument must be an integer");
 	}
     }
@@ -136,28 +136,28 @@ DEFUN_DLD (getgrnam, args, ,
 @deftypefn {Loadable Function} {@var{grp_struct} =} getgrnam (@var{name})\n\
 Return the first entry from the group database with the group name\n\
 @var{name}.  If the group name does not exist in the database,\n\
 @code{getgrname} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = 0.0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      string s = args(0).string_value ();
+      std::string s = args(0).string_value ();
 
       if (! error_state)
 	{
-	  string msg;
+	  std::string msg;
 
 	  retval(0) = mk_gr_map (octave_group::getgrnam (s.c_str (), msg));
 	  retval(1) = msg;
 	}
     }
   else
     print_usage ("getgrnam");
 
@@ -167,24 +167,24 @@ Return the first entry from the group da
 DEFUN_DLD (setgrent, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} setgrent ()\n\
 Return the internal pointer to the beginning of the group database.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
-      string msg;
+      std::string msg;
 
       retval(0) = static_cast<double> (octave_group::setgrent (msg));
       retval(1) = msg;
     }
   else
     print_usage ("setgrent");
 
   return retval;
@@ -193,24 +193,24 @@ Return the internal pointer to the begin
 DEFUN_DLD (endgrent, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} endgrent ()\n\
 Close the group database.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
-      string msg;
+      std::string msg;
 
       retval(0) = static_cast<double> (octave_group::endgrent (msg));
       retval(1) = msg;
     }
   else
     print_usage ("endgrent");
 
   return retval;
diff --git a/src/DLD-FUNCTIONS/getpwent.cc b/src/DLD-FUNCTIONS/getpwent.cc
--- a/src/DLD-FUNCTIONS/getpwent.cc
+++ b/src/DLD-FUNCTIONS/getpwent.cc
@@ -72,24 +72,24 @@ DEFUN_DLD (getpwent, args, ,
 @deftypefn {Loadable Function} {@var{pw_struct} = } getpwent ()\n\
 Return a structure containing an entry from the password database,\n\
 opening it if necessary. Once the end of the data has been reached,\n\
 @code{getpwent} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = 0.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
-      string msg;
+      std::string msg;
 
       retval(0) = mk_pw_map (octave_passwd::getpwent (msg));
       retval(1) = msg;
     }
   else
     print_usage ("getpwent");
 
   return retval;
@@ -100,32 +100,32 @@ DEFUN_DLD (getpwuid, args, ,
 @deftypefn {Loadable Function} {@var{pw_struct} = } getpwuid (@var{uid}).\n\
 Return a structure containing the first entry from the password database\n\
 with the user ID @var{uid}.  If the user ID does not exist in the\n\
 database, @code{getpwuid} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = 0.0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       double dval = args(0).double_value ();
 
       if (! error_state)
 	{
 	  if (D_NINT (dval) == dval)
 	    {
 	      uid_t uid = static_cast<uid_t> (dval);
 
-	      string msg;
+	      std::string msg;
 
 	      retval(0) = mk_pw_map (octave_passwd::getpwuid (uid, msg));
 	      retval(1) = msg;
 	    }
 	  else
 	    error ("getpwuid: argument must be an integer");
 	}
     }
@@ -140,28 +140,28 @@ DEFUN_DLD (getpwnam, args, ,
 @deftypefn {Loadable Function} {@var{pw_struct} = } getpwnam (@var{name})\n\
 Return a structure containing the first entry from the password database\n\
 with the user name @var{name}.  If the user name does not exist in the\n\
 database, @code{getpwname} returns 0.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = 0.0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      string s = args(0).string_value ();
+      std::string s = args(0).string_value ();
 
       if (! error_state)
 	{
-	  string msg;
+	  std::string msg;
 
 	  retval(0) = mk_pw_map (octave_passwd::getpwnam (s.c_str (), msg));
 	  retval(1) = msg;
 	}
     }
   else
     print_usage ("getpwnam");
 
@@ -171,24 +171,24 @@ database, @code{getpwname} returns 0.\n\
 DEFUN_DLD (setpwent, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} setpwent ()\n\
 Return the internal pointer to the beginning of the password database.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
-      string msg;
+      std::string msg;
 
       retval(0) = static_cast<double> (octave_passwd::setpwent (msg));
       retval(1) = msg;
     }
   else
     print_usage ("setpwent");
 
   return retval;
@@ -197,24 +197,24 @@ Return the internal pointer to the begin
 DEFUN_DLD (endpwent, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} endpwent ()\n\
 Close the password database.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
-      string msg;
+      std::string msg;
 
       retval(0) = static_cast<double> (octave_passwd::endpwent (msg));
       retval(1) = msg;
     }
   else
     print_usage ("endpwent");
 
   return retval;
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -21,17 +21,17 @@ Software Foundation, 59 Temple Place - S
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <string>
 
-#include <iostream.h>
+#include <iostream>
 
 #include "LSODE.h"
 #include "lo-mappers.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
@@ -355,17 +355,17 @@ static LSODE_OPTIONS lsode_option_table 
 
   { 0,
     { 0, 0, 0, 0, },
     { 0, 0, 0, 0, }, 0,
     0, 0, 0, 0, },
 };
 
 static void
-print_lsode_option_list (ostream& os)
+print_lsode_option_list (std::ostream& os)
 {
   print_usage ("lsode_options", 1);
 
   os << "\n"
      << "Options for lsode include:\n\n"
      << "  keyword                                  value\n"
      << "  -------                                  -----\n\n";
 
@@ -394,17 +394,17 @@ print_lsode_option_list (ostream& os)
       os << "\n";
       list++;
     }
 
   os << "\n";
 }
 
 static void
-set_lsode_option (const string& keyword, double val)
+set_lsode_option (const std::string& keyword, double val)
 {
   LSODE_OPTIONS *list = lsode_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
@@ -424,17 +424,17 @@ set_lsode_option (const string& keyword,
 	}
       list++;
     }
 
   warning ("lsode_options: no match for `%s'", keyword.c_str ());
 }
 
 static octave_value_list
-show_lsode_option (const string& keyword)
+show_lsode_option (const std::string& keyword)
 {
   octave_value retval;
 
   LSODE_OPTIONS *list = lsode_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
@@ -483,17 +483,17 @@ their current values are displayed.\n\
 
   if (nargin == 0)
     {
       print_lsode_option_list (octave_stdout);
       return retval;
     }
   else if (nargin == 1 || nargin == 2)
     {
-      string keyword = args(0).string_value ();
+      std::string keyword = args(0).string_value ();
 
       if (! error_state)
 	{
 	  if (nargin == 1)
 	    return show_lsode_option (keyword);
 	  else
 	    {
 	      double val = args(1).double_value ();
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -21,17 +21,17 @@ Software Foundation, 59 Temple Place - S
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <string>
 
-#include <iostream.h>
+#include <iostream>
 
 #include "Quad.h"
 #include "lo-mappers.h"
 
 #include "defun-dld.h"
 #include "error.h"
 #include "gripes.h"
 #include "pager.h"
@@ -315,17 +315,17 @@ static QUAD_OPTIONS quad_option_table []
 
   { 0,
     { 0, 0, 0, },
     { 0, 0, 0, }, 0,
     0, 0, },
 };
 
 static void
-print_quad_option_list (ostream& os)
+print_quad_option_list (std::ostream& os)
 {
   print_usage ("quad_options", 1);
 
   os << "\n"
      << "Options for quad include:\n\n"
      << "  keyword                                  value\n"
      << "  -------                                  -----\n\n";
 
@@ -345,17 +345,17 @@ print_quad_option_list (ostream& os)
       os << "\n";
       list++;
     }
 
   os << "\n";
 }
 
 static void
-set_quad_option (const string& keyword, double val)
+set_quad_option (const std::string& keyword, double val)
 {
   QUAD_OPTIONS *list = quad_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
 				list->min_toks_to_match, MAX_TOKENS))
 	{
@@ -365,17 +365,17 @@ set_quad_option (const string& keyword, 
 	}
       list++;
     }
 
   warning ("quad_options: no match for `%s'", keyword.c_str ());
 }
 
 static octave_value_list
-show_quad_option (const string& keyword)
+show_quad_option (const std::string& keyword)
 {
   octave_value retval;
 
   QUAD_OPTIONS *list = quad_option_table;
 
   while (list->keyword != 0)
     {
       if (keyword_almost_match (list->kw_tok, list->min_len, keyword,
@@ -407,17 +407,17 @@ their current values are displayed.\n\
 
   if (nargin == 0)
     {
       print_quad_option_list (octave_stdout);
       return retval;
     }
   else if (nargin == 1 || nargin == 2)
     {
-      string keyword = args(0).string_value ();
+      std::string keyword = args(0).string_value ();
 
       if (! error_state)
 	{
 	  if (nargin == 1)
 	    return show_quad_option (keyword);
 	  else
 	    {
 	      double val = args(1).double_value ();
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -25,17 +25,17 @@ Software Foundation, 59 Temple Place - S
 
 #undef DEBUG
 #undef DEBUG_SORT
 #undef DEBUG_EIG
 
 #include "config.h"
 
 #include <cfloat>
-#include <iostream.h>
+#include <iostream>
 #include <iomanip.h>
 #include <math.h>
 #include <string.h>
 #include <strstream.h>
 
 #include "CmplxQRP.h"
 #include "dbleQR.h"
 #include "defun-dld.h"
@@ -254,17 +254,17 @@ See also: balance, dare, eig, schur\n\
       return retval;
     }
 
 #ifdef DEBUG
   cout << "qz: determine ordering option" << endl;
 #endif
 
   // Determine ordering option
-  string ord_job;
+  std::string ord_job;
   static double safmin;
 
   if (nargin == 2)
     ord_job = "N";
   else if (!args(2).is_string ())
     {
       error ("qz: argument 3 must be a string");
       return retval;
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -160,17 +160,17 @@ do_rand (const octave_value_list& args, 
       goto gen_matrix;
     }
   else if (nargin == 1)
     {
       octave_value tmp = args(0);
 
       if (tmp.is_string ())
 	{
-	  string s_arg = tmp.string_value ();
+	  std::string s_arg = tmp.string_value ();
 
 	  if (s_arg == "dist")
 	    {
 	      retval(0) = curr_rand_dist ();
 	    }
 	  else if (s_arg == "seed")
 	    {
 	      retval(0) = curr_rand_seed ();
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/DLD-FUNCTIONS/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/DLD-FUNCTIONS/schur.cc
@@ -250,17 +250,17 @@ leading eigenvalues of\n\
   if (nargin < 1 || nargin > 2 || nargout > 2)
     {
       print_usage ("schur");
       return retval;
     }
 
   octave_value arg = args(0);
 
-  string ord;
+  std::string ord;
 
   if (nargin == 2)
     {
       ord = args(1).string_value (); 
 
       if (error_state)
 	{
 	  error ("schur: expecting string as second argument");
diff --git a/src/DLD-FUNCTIONS/time.cc b/src/DLD-FUNCTIONS/time.cc
--- a/src/DLD-FUNCTIONS/time.cc
+++ b/src/DLD-FUNCTIONS/time.cc
@@ -364,17 +364,17 @@ Last two digits of year (00-99).\n\
 Year (1970-).\n\
 @end table\n\
 @end deftypefn\n")
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
-      string fmt = args(0).string_value ();
+      std::string fmt = args(0).string_value ();
 
       if (! error_state)
 	{
 	  Octave_map map = args(1).map_value ();
 
 	  if (! error_state)
 	    {
 	      octave_base_tm tm = extract_tm (map);
@@ -402,21 +402,21 @@ DEFUN_DLD (strptime, args, ,
 Convert the string @var{str} to a time structure under the control of\n\
 the format @var{fmt}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 2)
     {
-      string str = args(0).string_value ();
+      std::string str = args(0).string_value ();
 
       if (! error_state)
 	{
-	  string fmt = args(1).string_value ();
+	  std::string fmt = args(1).string_value ();
 
 	  if (! error_state)
 	    {
 	      octave_strptime t (str, fmt);
 
 	      retval(1) = static_cast<double> (t.characters_converted ());
 	      retval(0) = octave_value (mk_tm_map (t));
 	    }
diff --git a/src/Map.cc b/src/Map.cc
--- a/src/Map.cc
+++ b/src/Map.cc
@@ -41,27 +41,27 @@ License as published by the Free Softwar
 #include <config.h>
 #endif
 
 #include <iostream>
 
 #include "Map.h"
 
 static unsigned int
-hash (const string& str)
+hash (const std::string& str)
 {
   unsigned h = 0;
   for (unsigned i = 0; i < str.length (); i++)
     h = h * 33 + str[i];
   return h;
 }
 
 template <class C>
 Pix
-Map<C>::seek (const string& item) const
+Map<C>::seek (const std::string& item) const
 {
   Pix i = 0;
 
   for (i = first (); i != 0 && key (i) != item; next (i))
     ; // Skip items until match found.
 
   return i;
 }
@@ -89,24 +89,24 @@ Map<C>::clear (void)
     {
       del (key (i));
       i = first ();
     }
 }
 
 template <class C>
 int
-Map<C>::contains (const string& item) const
+Map<C>::contains (const std::string& item) const
 {
   return seek (item) != 0;
 }
 
 template <class C>
 void
-Map<C>::error (const string& msg) const
+Map<C>::error (const std::string& msg) const
 {
   cerr << "Map: " << msg << "\n";
 }
 
 // CHMap class.
 
 // The nodes are linked together serially via a version of a trick
 // used in some vtables: odd pointers are actually links to the next
@@ -149,47 +149,47 @@ CHMap<C>::CHMap (const CHMap& a) : Map<C
     tab[i] = static_cast<CHNode<C> *> (index_to_CHptr (i+1));
   count = 0;
   for (Pix p = a.first (); p; a.next (p))
     (*this) [a.key (p)] = a.contents (p);
 }
 
 template <class C>
 Pix
-CHMap<C>::seek (const string& key) const
+CHMap<C>::seek (const std::string& key) const
 {
   unsigned int h = hash (key) % size;
 
   for (CHNode<C> *t = tab[h]; goodCHptr (t); t = t->tl)
     if (key == t->hd)
       return Pix (t);
 
   return 0;
 }
 
 template <class C>
 C&
-CHMap<C>::operator [] (const string& item)
+CHMap<C>::operator [] (const std::string& item)
 {
   unsigned int h = hash (item) % size;
 
   CHNode<C> *t = 0;
   for (t = tab[h]; goodCHptr (t); t = t->tl)
     if (item == t->hd)
       return t->cont;
 
   t = new CHNode<C> (item, def, tab[h]);
   tab[h] = t;
   ++count;
   return t->cont;
 }
 
 template <class C>
 void
-CHMap<C>::del (const string& key)
+CHMap<C>::del (const std::string& key)
 {
   unsigned int h = hash (key) % size;
 
   CHNode<C> *t = tab[h];
   CHNode<C> *trail = t;
   while (goodCHptr (t))
     {
       if (key == t->hd)
diff --git a/src/Map.h b/src/Map.h
--- a/src/Map.h
+++ b/src/Map.h
@@ -54,49 +54,49 @@ protected:
 public:
   Map (const C& dflt) : def (dflt) { count = 0; }
 
   virtual ~Map (void) { }
 
   int length (void) const { return count; }	// current number of items
   int empty (void) const { return count == 0; }
 
-  virtual int contains (const string& key) const;  // is key mapped?
+  virtual int contains (const std::string& key) const;  // is key mapped?
 
   virtual void clear (void);			// delete all items
 	      
-  virtual C& operator [] (const string& key) = 0;  // access contents by key
+  virtual C& operator [] (const std::string& key) = 0;  // access contents by key
 	      
-  virtual void del (const string& key) = 0;	// delete entry
+  virtual void del (const std::string& key) = 0;	// delete entry
 	      
   virtual Pix first (void) const = 0;		// Pix of first item or 0
   virtual void next (Pix& i) const = 0;		// advance to next or 0
-  virtual string key (Pix i) const = 0;		// access key at i
+  virtual std::string key (Pix i) const = 0;		// access key at i
   virtual C& contents (Pix i) const = 0;	// access contents at i
 
   virtual int owns (Pix i) const;		// is i a valid Pix  ?
-  virtual Pix seek (const string& key) const;	// Pix of key
+  virtual Pix seek (const std::string& key) const;	// Pix of key
 
   C& dflt (void) { return def; }		// access default val
 
-  void error (const string& msg) const;
+  void error (const std::string& msg) const;
 
   virtual int OK (void) const = 0;		// rep invariant
 };
 
 template <class C>
 struct CHNode
 {
   CHNode *tl;
-  string hd;
+  std::string hd;
   C cont;
 
   CHNode (void) : tl (0), hd (), cont () { }
 
-  CHNode (const string& h, const C& c, CHNode *t = 0)
+  CHNode (const std::string& h, const C& c, CHNode *t = 0)
     : tl (t), hd (h), cont (c) { }
 
   ~CHNode (void) { }
 };
 
 #ifndef DEFAULT_INITIAL_CAPACITY
 #define DEFAULT_INITIAL_CAPACITY 8
 #endif
@@ -114,42 +114,42 @@ public:
   CHMap (const CHMap& a);
 
   ~CHMap (void)
     {
       clear ();
       delete tab;
     }
 
-  C& operator [] (const string& key);
+  C& operator [] (const std::string& key);
 
-  void del (const string& key);
+  void del (const std::string& key);
 
   Pix first (void) const;
   void next (Pix& i) const;
 
-  string key (Pix p) const
+  std::string key (Pix p) const
     {
       if (p == 0)
 	error ("null Pix");
 
       return ((CHNode<C> *) p)->hd;
     }
 
   C& contents (Pix p) const
     {
       if (p == 0)
 	error ("null Pix");
 
      return ((CHNode<C> *) p)->cont;
    }
 
-  Pix seek (const string& key) const;
+  Pix seek (const std::string& key) const;
 
-  int contains (const string& key) const
+  int contains (const std::string& key) const
     {
       return seek (key) != 0;
     }
 
   void clear (void);
   int  OK (void) const;
 };
 
diff --git a/src/OPERATORS/op-fil-b.cc b/src/OPERATORS/op-fil-b.cc
--- a/src/OPERATORS/op-fil-b.cc
+++ b/src/OPERATORS/op-fil-b.cc
@@ -23,17 +23,17 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <iostream.h>
+#include <iostream>
 
 #include "mach-info.h"
 
 #include "error.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov.h"
 #include "ov-file.h"
@@ -45,21 +45,21 @@ Software Foundation, 59 Temple Place - S
 DEFBINOP (lshift, file, bool)
 {
   CAST_BINOP_ARGS (const octave_file&, const octave_bool&);
 
   octave_stream oct_stream = v1.stream_value ();
 
   if (oct_stream)
     {
-      ostream *osp = oct_stream.output_stream ();
+      std::ostream *osp = oct_stream.output_stream ();
 
       if (osp)
 	{
-	  ostream& os = *osp;
+	  std::ostream& os = *osp;
 
 	  v2.print_raw (os);
 	}
       else
 	error ("invalid file specified for binary operator `<<'");
     }
 
   return octave_value (oct_stream, v1.stream_number ());
diff --git a/src/OPERATORS/op-fil-bm.cc b/src/OPERATORS/op-fil-bm.cc
--- a/src/OPERATORS/op-fil-bm.cc
+++ b/src/OPERATORS/op-fil-bm.cc
@@ -23,17 +23,17 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <iostream.h>
+#include <iostream>
 
 #include "mach-info.h"
 
 #include "error.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov.h"
 #include "ov-file.h"
@@ -45,21 +45,21 @@ Software Foundation, 59 Temple Place - S
 DEFBINOP (lshift, file, bool_matrix)
 {
   CAST_BINOP_ARGS (const octave_file&, const octave_bool_matrix&);
 
   octave_stream oct_stream = v1.stream_value ();
 
   if (oct_stream)
     {
-      ostream *osp = oct_stream.output_stream ();
+      std::ostream *osp = oct_stream.output_stream ();
 
       if (osp)
 	{
-	  ostream& os = *osp;
+	  std::ostream& os = *osp;
 
 	  v2.print_raw (os);
 	}
       else
 	error ("invalid file specified for binary operator `<<'");
     }
 
   return octave_value (oct_stream, v1.stream_number ());
diff --git a/src/OPERATORS/op-fil-cm.cc b/src/OPERATORS/op-fil-cm.cc
--- a/src/OPERATORS/op-fil-cm.cc
+++ b/src/OPERATORS/op-fil-cm.cc
@@ -23,17 +23,17 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <iostream.h>
+#include <iostream>
 
 #include "mach-info.h"
 
 #include "error.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov.h"
 #include "ov-file.h"
@@ -45,21 +45,21 @@ Software Foundation, 59 Temple Place - S
 DEFBINOP (lshift, file, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_file&, const octave_complex_matrix&);
 
   octave_stream oct_stream = v1.stream_value ();
 
   if (oct_stream)
     {
-      ostream *osp = oct_stream.output_stream ();
+      std::ostream *osp = oct_stream.output_stream ();
 
       if (osp)
 	{
-	  ostream& os = *osp;
+	  std::ostream& os = *osp;
 
 	  v2.print_raw (os);
 	}
       else
 	error ("invalid file specified for binary operator `<<'");
     }
 
   return octave_value (oct_stream, v1.stream_number ());
diff --git a/src/OPERATORS/op-fil-cs.cc b/src/OPERATORS/op-fil-cs.cc
--- a/src/OPERATORS/op-fil-cs.cc
+++ b/src/OPERATORS/op-fil-cs.cc
@@ -23,17 +23,17 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <iostream.h>
+#include <iostream>
 
 #include "mach-info.h"
 
 #include "error.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov.h"
 #include "ov-file.h"
@@ -45,21 +45,21 @@ Software Foundation, 59 Temple Place - S
 DEFBINOP (lshift, file, complex)
 {
   CAST_BINOP_ARGS (const octave_file&, const octave_complex&);
 
   octave_stream oct_stream = v1.stream_value ();
 
   if (oct_stream)
     {
-      ostream *osp = oct_stream.output_stream ();
+      std::ostream *osp = oct_stream.output_stream ();
 
       if (osp)
 	{
-	  ostream& os = *osp;
+	  std::ostream& os = *osp;
 
 	  v2.print_raw (os);
 	}
       else
 	error ("invalid file specified for binary operator `<<'");
     }
 
   return octave_value (oct_stream, v1.stream_number ());
diff --git a/src/OPERATORS/op-fil-lis.cc b/src/OPERATORS/op-fil-lis.cc
--- a/src/OPERATORS/op-fil-lis.cc
+++ b/src/OPERATORS/op-fil-lis.cc
@@ -23,17 +23,17 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <iostream.h>
+#include <iostream>
 
 #include "mach-info.h"
 
 #include "error.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov.h"
 #include "ov-file.h"
@@ -45,21 +45,21 @@ Software Foundation, 59 Temple Place - S
 DEFBINOP (lshift, file, list)
 {
   CAST_BINOP_ARGS (const octave_file&, const octave_list&);
 
   octave_stream oct_stream = v1.stream_value ();
 
   if (oct_stream)
     {
-      ostream *osp = oct_stream.output_stream ();
+      std::ostream *osp = oct_stream.output_stream ();
 
       if (osp)
 	{
-	  ostream& os = *osp;
+	  std::ostream& os = *osp;
 
 	  v2.print_raw (os);
 	}
       else
 	error ("invalid file specified for binary operator `<<'");
     }
 
   return octave_value (oct_stream, v1.stream_number ());
diff --git a/src/OPERATORS/op-fil-m.cc b/src/OPERATORS/op-fil-m.cc
--- a/src/OPERATORS/op-fil-m.cc
+++ b/src/OPERATORS/op-fil-m.cc
@@ -23,17 +23,17 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <iostream.h>
+#include <iostream>
 
 #include "mach-info.h"
 
 #include "error.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov.h"
 #include "ov-file.h"
@@ -45,21 +45,21 @@ Software Foundation, 59 Temple Place - S
 DEFBINOP (lshift, file, matrix)
 {
   CAST_BINOP_ARGS (const octave_file&, const octave_matrix&);
 
   octave_stream oct_stream = v1.stream_value ();
 
   if (oct_stream)
     {
-      ostream *osp = oct_stream.output_stream ();
+      std::ostream *osp = oct_stream.output_stream ();
 
       if (osp)
 	{
-	  ostream& os = *osp;
+	  std::ostream& os = *osp;
 
 	  v2.print_raw (os);
 	}
       else
 	error ("invalid file specified for binary operator `<<'");
     }
 
   return octave_value (oct_stream, v1.stream_number ());
diff --git a/src/OPERATORS/op-fil-rec.cc b/src/OPERATORS/op-fil-rec.cc
--- a/src/OPERATORS/op-fil-rec.cc
+++ b/src/OPERATORS/op-fil-rec.cc
@@ -23,17 +23,17 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <iostream.h>
+#include <iostream>
 
 #include "mach-info.h"
 
 #include "error.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov.h"
 #include "ov-file.h"
@@ -45,21 +45,21 @@ Software Foundation, 59 Temple Place - S
 DEFBINOP (lshift, file, struct)
 {
   CAST_BINOP_ARGS (const octave_file&, const octave_struct&);
 
   octave_stream oct_stream = v1.stream_value ();
 
   if (oct_stream)
     {
-      ostream *osp = oct_stream.output_stream ();
+      std::ostream *osp = oct_stream.output_stream ();
 
       if (osp)
 	{
-	  ostream& os = *osp;
+	  std::ostream& os = *osp;
 
 	  v2.print_raw (os);
 	}
       else
 	error ("invalid file specified for binary operator `<<'");
     }
 
   return octave_value (oct_stream, v1.stream_number ());
diff --git a/src/OPERATORS/op-fil-s.cc b/src/OPERATORS/op-fil-s.cc
--- a/src/OPERATORS/op-fil-s.cc
+++ b/src/OPERATORS/op-fil-s.cc
@@ -23,17 +23,17 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <iostream.h>
+#include <iostream>
 
 #include "mach-info.h"
 
 #include "error.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov.h"
 #include "ov-file.h"
@@ -45,21 +45,21 @@ Software Foundation, 59 Temple Place - S
 DEFBINOP (lshift, file, scalar)
 {
   CAST_BINOP_ARGS (const octave_file&, const octave_scalar&);
 
   octave_stream oct_stream = v1.stream_value ();
 
   if (oct_stream)
     {
-      ostream *osp = oct_stream.output_stream ();
+      std::ostream *osp = oct_stream.output_stream ();
 
       if (osp)
 	{
-	  ostream& os = *osp;
+	  std::ostream& os = *osp;
 
 	  v2.print_raw (os);
 	}
       else
 	error ("invalid file specified for binary operator `<<'");
     }
 
   return octave_value (oct_stream, v1.stream_number ());
diff --git a/src/OPERATORS/op-fil-str.cc b/src/OPERATORS/op-fil-str.cc
--- a/src/OPERATORS/op-fil-str.cc
+++ b/src/OPERATORS/op-fil-str.cc
@@ -23,17 +23,17 @@ Software Foundation, 59 Temple Place - S
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
-#include <iostream.h>
+#include <iostream>
 
 #include "mach-info.h"
 
 #include "error.h"
 #include "oct-stream.h"
 #include "ops.h"
 #include "ov.h"
 #include "ov-file.h"
@@ -45,21 +45,21 @@ Software Foundation, 59 Temple Place - S
 DEFBINOP (lshift, file, char_matrix_str)
 {
   CAST_BINOP_ARGS (const octave_file&, const octave_char_matrix_str&);
 
   octave_stream oct_stream = v1.stream_value ();
 
   if (oct_stream)
     {
-      ostream *osp = oct_stream.output_stream ();
+      std::ostream *osp = oct_stream.output_stream ();
 
       if (osp)
 	{
-	  ostream& os = *osp;
+	  std::ostream& os = *osp;
 
 	  v2.print_raw (os);
 	}
       else
 	error ("invalid file specified for binary operator `<<'");
     }
 
   return octave_value (oct_stream, v1.stream_number ());
diff --git a/src/TEMPLATE-INST/SLStack-str.cc b/src/TEMPLATE-INST/SLStack-str.cc
--- a/src/TEMPLATE-INST/SLStack-str.cc
+++ b/src/TEMPLATE-INST/SLStack-str.cc
@@ -32,20 +32,20 @@ Software Foundation, 59 Temple Place - S
 #include "Stack.h"
 #include "Stack.cc"
 
 #include "SLStack.h"
 #include "SLStack.cc"
 
 #include <string>
 
-template class SLNode<string>;
-template class SLList<string>;
+template class SLNode<std:string>;
+template class SLList<std:string>;
 
-template class Stack<string>;
+template class Stack<std:string>;
 
-template class SLStack<string>;
+template class SLStack<std:string>;
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -979,17 +979,17 @@ the second must be a string.\n\
     {
       retval = 0.0;
 
       // XXX FIXME XXX -- should this work for all types that can do
       // structure reference operations?
 
       if (args(0).is_map () && args(1).is_string ())
 	{
-	  string s = args(1).string_value ();
+	  std::string s = args(1).string_value ();
 	  octave_value tmp = args(0).do_struct_elt_index_op (s, true);
 	  retval = static_cast<double> (tmp.is_defined ());
 	}
       else
 	print_usage ("struct_contains");
     }
   else
     print_usage ("struct_contains");
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -46,54 +46,54 @@ Software Foundation, 59 Temple Place - S
 #include "gripes.h"
 #include "help.h"
 #include "oct-obj.h"
 #include "ov.h"
 #include "toplev.h"
 #include "variables.h"
 #include <version.h>
 
-string Voctave_home;
+std::string Voctave_home;
 
-string Vbin_dir;
-string Vinfo_dir;
-string Vdata_dir;
-string Vlibexec_dir;
-string Varch_lib_dir;
-string Vlocal_arch_lib_dir;
-string Vfcn_file_dir;
+std::string Vbin_dir;
+std::string Vinfo_dir;
+std::string Vdata_dir;
+std::string Vlibexec_dir;
+std::string Varch_lib_dir;
+std::string Vlocal_arch_lib_dir;
+std::string Vfcn_file_dir;
 
 // The path that will be searched for programs that we execute.
 // (--exec-path path)
-string Vexec_path;
+std::string Vexec_path;
 
 // Load path specified on command line.
 // (--path path; -p path)
-static string Vload_path;
+static std::string Vload_path;
 
 // The default load path with OCTAVE_HOME appropriately substituted.
-static string Vdefault_load_path;
+static std::string Vdefault_load_path;
 
 // And the cached directory path corresponding to Vload_path.
 dir_path Vload_path_dir_path;
 
 // Name of the editor to be invoked by the edit_history command.
-string Veditor;
+std::string Veditor;
 
-string Vimagepath;
+std::string Vimagepath;
 
-string Vlocal_site_defaults_file;
-string Vsite_defaults_file;
+std::string Vlocal_site_defaults_file;
+std::string Vsite_defaults_file;
 
 static string
-subst_octave_home (const string& s)
+subst_octave_home (const std::string& s)
 {
-  string retval;
+  std::string retval;
 
-  string prefix = OCTAVE_PREFIX;
+  std::string prefix = OCTAVE_PREFIX;
 
   retval = s;
 
   if (Voctave_home != prefix)
     {
       int len = prefix.length ();
       size_t start = 0;
       while ((start = retval.find (prefix, start)) != NPOS)
@@ -104,19 +104,19 @@ subst_octave_home (const string& s)
     }
 
   return retval;
 }
 
 static void
 set_octave_home (void)
 {
-  string oh = octave_env::getenv ("OCTAVE_HOME");
+  std::string oh = octave_env::getenv ("OCTAVE_HOME");
 
-  Voctave_home = oh.empty () ? string (OCTAVE_PREFIX) : oh;
+  Voctave_home = oh.empty () ? std::string (OCTAVE_PREFIX) : oh;
 }
 
 static void
 set_default_info_dir (void)
 {
   Vinfo_dir = subst_octave_home (OCTAVE_INFODIR);
 }
 
@@ -154,71 +154,71 @@ static void
 set_default_bin_dir (void)
 {
   Vbin_dir = subst_octave_home (OCTAVE_BINDIR);
 }
 
 static void
 set_default_exec_path (void)
 {
-  string octave_exec_path = octave_env::getenv ("OCTAVE_EXEC_PATH");
+  std::string octave_exec_path = octave_env::getenv ("OCTAVE_EXEC_PATH");
 
   if (octave_exec_path.empty ())
     {
-      string shell_path = octave_env::getenv ("PATH");
+      std::string shell_path = octave_env::getenv ("PATH");
 
       if (! shell_path.empty ())
 	{
-	  Vexec_path = string (":");
+	  Vexec_path = std::string (":");
 	  Vexec_path.append (shell_path);
 	}
     }
   else
-    Vexec_path = string (octave_exec_path);
+    Vexec_path = std::string (octave_exec_path);
 }
 
 static void
 set_default_path (void)
 {
   Vdefault_load_path = subst_octave_home (OCTAVE_FCNFILEPATH);
 
-  string oct_path = octave_env::getenv ("OCTAVE_PATH");
+  std::string oct_path = octave_env::getenv ("OCTAVE_PATH");
 
-  Vload_path = oct_path.empty () ? string (":") : oct_path;
+  Vload_path = oct_path.empty () ? std::string (":") : oct_path;
 
   Vload_path_dir_path = dir_path (Vload_path, Vdefault_load_path);
 }
 
 static void
 set_default_info_file (void)
 {
-  string std_info_file = subst_octave_home (OCTAVE_INFOFILE);
+  std::string std_info_file = subst_octave_home (OCTAVE_INFOFILE);
 
-  string oct_info_file = octave_env::getenv ("OCTAVE_INFO_FILE");
+  std::string oct_info_file = octave_env::getenv ("OCTAVE_INFO_FILE");
 
   Vinfo_file = oct_info_file.empty () ? std_info_file : oct_info_file;
 }
 
 static void
 set_default_info_prog (void)
 {
-  string oct_info_prog = octave_env::getenv ("OCTAVE_INFO_PROGRAM");
+  std::string oct_info_prog = octave_env::getenv ("OCTAVE_INFO_PROGRAM");
 
   if (oct_info_prog.empty ())
     Vinfo_prog = "info";
   else
-    Vinfo_prog = string (oct_info_prog);
+    Vinfo_prog = std::string (oct_info_prog);
 }
 
 static void
 set_default_editor (void)
 {
   Veditor = "emacs";
 
-  string env_editor = octave_env::getenv ("EDITOR");
+  std::string env_editor = octave_env::getenv ("EDITOR");
 
   if (! env_editor.empty ())
     Veditor = env_editor;
 }
 
 static void
 set_local_site_defaults_file (void)
 {
@@ -229,19 +229,19 @@ set_local_site_defaults_file (void)
 static void
 set_site_defaults_file (void)
 {
   Vsite_defaults_file = subst_octave_home (OCTAVE_STARTUPFILEDIR);
   Vsite_defaults_file.append ("/octaverc");
 }
 
 string
-maybe_add_default_load_path (const string& pathstring)
+maybe_add_default_load_path (const std::string& pathstring)
 {
-  string retval;
+  std::string retval;
 
   if (! pathstring.empty ())
     {
       if (pathstring[0] == SEPCHAR)
 	{
 	  retval = Vdefault_load_path;
 	  retval.append (pathstring);
 	}
@@ -301,17 +301,17 @@ install_defaults (void)
   set_site_defaults_file ();
 }
 
 static int
 editor (void)
 {
   int status = 0;
 
-  string s = builtin_string_variable ("EDITOR");
+  std::string s = builtin_string_variable ("EDITOR");
 
   if (s.empty ())
     {
       gripe_invalid_value_specified ("EDITOR");
       status = -1;
     }
   else
     Veditor = s;
@@ -319,31 +319,31 @@ editor (void)
   return status;
 }
 
 static int
 exec_path (void)
 {
   int status = 0;
 
-  string s = builtin_string_variable ("EXEC_PATH");
+  std::string s = builtin_string_variable ("EXEC_PATH");
 
   if (s.empty ())
     {
       gripe_invalid_value_specified ("EXEC_PATH");
       status = -1;
     }
   else
     {
       Vexec_path = s;
 
-      string std_path = Vlocal_arch_lib_dir + string (SEPCHAR_STR)
-	+ Varch_lib_dir + string (SEPCHAR_STR) + Vbin_dir;
+      std::string std_path = Vlocal_arch_lib_dir + std::string (SEPCHAR_STR)
+	+ Varch_lib_dir + std::string (SEPCHAR_STR) + Vbin_dir;
 
-      string path;
+      std::string path;
 
       int eplen = Vexec_path.length ();
 
       if (eplen > 0)
 	{
 	  bool prepend = (Vexec_path[0] == ':');
 	  bool append = (eplen > 1 && Vexec_path[eplen-1] == ':');
 
@@ -371,17 +371,17 @@ exec_path (void)
   return status;
 }
 
 static int
 imagepath (void)
 {
   int status = 0;
 
-  string s = builtin_string_variable ("IMAGEPATH");
+  std::string s = builtin_string_variable ("IMAGEPATH");
 
   if (s.empty ())
     {
       gripe_invalid_value_specified ("IMAGEPATH");
       status = -1;
     }
   else
     Vimagepath = s;
@@ -389,17 +389,17 @@ imagepath (void)
   return status;
 }
 
 static int
 loadpath (void)
 {
   int status = 0;
 
-  string s = builtin_string_variable ("LOADPATH");
+  std::string s = builtin_string_variable ("LOADPATH");
 
   if (s.empty ())
     {
       gripe_invalid_value_specified ("LOADPATH");
       status = -1;
     }
   else
     {
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -28,52 +28,52 @@ Software Foundation, 59 Temple Place - S
 #include "ov-builtin.h"
 #include "ov-dld-fcn.h"
 #include "ov-mapper.h"
 #include "symtab.h"
 #include "version.h"
 
 class octave_value;
 
-extern void print_usage (const string& nm, bool just_usage = false);
+extern void print_usage (const std::string& nm, bool just_usage = false);
 
-extern void check_version (const string& version, const string& fcn);
+extern void check_version (const std::string& version, const std::string& fcn);
 
 extern void
 install_builtin_mapper (octave_mapper *mf);
 
 extern void
-install_builtin_function (octave_builtin::fcn f, const string& name,
-			  const string& doc, bool is_text_fcn = false);
+install_builtin_function (octave_builtin::fcn f, const std::string& name,
+			  const std::string& doc, bool is_text_fcn = false);
 
 extern void
-install_builtin_variable (const string& n, const octave_value& v,
+install_builtin_variable (const std::string& n, const octave_value& v,
 			  bool p, bool e,
 			  symbol_record::change_function chg_fcn,
-			  const string& h);
+			  const std::string& h);
 
 extern void
-install_builtin_constant (const string& n, const octave_value& v,
-			  bool p, const string& h);
+install_builtin_constant (const std::string& n, const octave_value& v,
+			  bool p, const std::string& h);
 
 extern void
-install_dld_function (octave_dld_function::fcn f, const string& name,
+install_dld_function (octave_dld_function::fcn f, const std::string& name,
 		      const octave_shlib& shl,
-		      const string& doc, bool is_text_fcn = false);
+		      const std::string& doc, bool is_text_fcn = false);
 
 extern void
-alias_builtin (const string& alias, const string& name);
+alias_builtin (const std::string& alias, const std::string& name);
 
 #define DECLARE_FUN(name, args_name, nargout_name) \
   octave_value_list \
   F ## name (const octave_value_list& args_name, int nargout_name)
 
 // Define the code that will be used to insert the new function into
 // the symbol table.  We look for this name instead of the actual
-// function so that we can easily install the doc string too.
+// function so that we can easily install the doc std::string too.
 
 typedef bool (*octave_dld_fcn_installer) (const octave_shlib&);
 
 #define DEFINE_FUN_INSTALLER_FUN(name, doc) \
   bool \
   FS ## name (const octave_shlib& shl) \
   { \
     check_version (OCTAVE_VERSION, #name); \
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -35,23 +35,23 @@ Software Foundation, 59 Temple Place - S
 #include "ov-builtin.h"
 #include "ov-dld-fcn.h"
 #include "ov-mapper.h"
 #include "pager.h"
 #include "symtab.h"
 #include "variables.h"
 
 void
-print_usage (const string& nm, bool just_usage)
+print_usage (const std::string& nm, bool just_usage)
 {
   symbol_record *sym_rec = global_sym_tab->lookup (nm);
 
   if (sym_rec)
     {
-      string h = sym_rec->help ();
+      std::string h = sym_rec->help ();
 
       if (h.length () > 0)
 	{
 	  octave_stdout << "\n*** " << nm << ":\n\n";
 
 	  display_help_text (octave_stdout, h);
 
 	  octave_stdout << "\n";
@@ -60,17 +60,17 @@ print_usage (const string& nm, bool just
 	    additional_help_message (octave_stdout);
 	}
     }
   else
     warning ("no usage message found for `%s'", nm.c_str ());
 }
 
 void
-check_version (const string& version, const string& fcn)
+check_version (const std::string& version, const std::string& fcn)
 {
   if (version != OCTAVE_VERSION)
     warning ("incompatible version %s found in function `%s'",
 	     version.c_str (), fcn.c_str ());
 }
 
 // Install variables and functions in the symbol tables.
 
@@ -85,70 +85,70 @@ install_builtin_mapper (octave_mapper *m
   sym_rec->unprotect ();
   sym_rec->define (mf, t);
   sym_rec->document (mf->doc_string ());
   sym_rec->make_eternal ();
   sym_rec->protect ();
 }
 
 void
-install_builtin_function (octave_builtin::fcn f, const string& name,
-			  const string& doc, bool is_text_fcn)
+install_builtin_function (octave_builtin::fcn f, const std::string& name,
+			  const std::string& doc, bool is_text_fcn)
 {
   symbol_record *sym_rec = global_sym_tab->lookup (name, true);
 
   unsigned int t = symbol_record::BUILTIN_FUNCTION;
 
   if (is_text_fcn)
     t |= symbol_record::TEXT_FUNCTION;
 
   sym_rec->unprotect ();
   sym_rec->define (new octave_builtin (f, name, doc), t);
   sym_rec->document (doc);
   sym_rec->make_eternal ();
   sym_rec->protect ();
 }
 
 void
-install_builtin_constant (const string& name, const octave_value& val,
-			  bool protect, const string& help)
+install_builtin_constant (const std::string& name, const octave_value& val,
+			  bool protect, const std::string& help)
 {
   bind_builtin_constant (name, val, protect, false, help);
 }
 
 void
-install_builtin_variable (const string& name, const octave_value& value,
+install_builtin_variable (const std::string& name, const octave_value& value,
 			  bool protect, bool eternal,
 			  symbol_record::change_function chg_fcn,
-			  const string& doc)
+			  const std::string& doc)
 {
   bind_builtin_variable (name, value, protect, eternal, chg_fcn, doc);
 }
 
 void
-install_dld_function (octave_dld_function::fcn f, const string& name,
+install_dld_function (octave_dld_function::fcn f, const std::string& name,
 		      const octave_shlib& shl,
-		      const string& doc, bool is_text_fcn)
+		      const std::string& doc, bool is_text_fcn)
 {
   symbol_record *sym_rec = global_sym_tab->lookup (name, true);
 
   unsigned int t = symbol_record::DLD_FUNCTION;
 
   if (is_text_fcn)
     t |= symbol_record::TEXT_FUNCTION;
 
   sym_rec->unprotect ();
   sym_rec->define (new octave_dld_function (f, shl, name, doc), t);
   sym_rec->document (doc);
   sym_rec->make_eternal ();
   sym_rec->protect ();
 }
 
 void
-alias_builtin (const string& alias, const string& name)
+alias_builtin (const std::string& alias, const std::string& name)
 {
   symbol_record *sr_name = global_sym_tab->lookup (name);
 
   if (! sr_name)
     panic ("can't alias to undefined name!");
 
   symbol_record *sr_alias = global_sym_tab->lookup (alias, true);
 
diff --git a/src/defun.h b/src/defun.h
--- a/src/defun.h
+++ b/src/defun.h
@@ -55,17 +55,17 @@ Software Foundation, 59 Temple Place - S
 // retain its original value when cleared) and also an alias to it
 // called `__name__' (which may not be redefined).
 
 #define DEFCONST(name, defn, doc) \
   DEFCONST_INTERNAL (name, defn, doc)
 
 // This one can be used when `name' cannot be used directly (if it is
 // already defined as a macro).  In that case, name is already a
-// quoted string, and the name of the structure has to be passed too.
+// quoted std::string, and the name of the structure has to be passed too.
 
 #define DEFCONSTX(name, sname, defn, doc) \
   DEFCONSTX_INTERNAL (name, sname, defn, doc)
 
 // Define a builtin function.
 //
 //   name is the name of the function, unqouted.
 //
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -61,17 +61,17 @@ Software Foundation, 59 Temple Place - S
 #include "utils.h"
 #include "variables.h"
 
 // XXX FIXME XXX -- changing the plotter directory should be handled
 // by registering a function for octave_env::chdir to call so that
 // this function can be eliminated.
 
 static int
-octave_change_to_directory (const string& newdir)
+octave_change_to_directory (const std::string& newdir)
 {
   int cd_ok = octave_env::chdir (newdir);
 
   if (cd_ok)
     do_external_plotter_cd (newdir);
   else
     error ("%s: %s", newdir.c_str (), strerror (errno));
 
@@ -102,27 +102,27 @@ directory is not changed.\n\
 
   string_vector argv = args.make_argv ("cd");
 
   if (error_state)
     return retval;
 
   if (argc > 1)
     {
-      string dirname = file_ops::tilde_expand (argv[1]);
+      std::string dirname = file_ops::tilde_expand (argv[1]);
 
       if (dirname.length () > 0
 	  && ! octave_change_to_directory (dirname))
 	{
 	  return retval;
 	}
     }
   else
     {
-      string home_dir = octave_env::get_home_directory ();
+      std::string home_dir = octave_env::get_home_directory ();
 
       if (home_dir.empty () || ! octave_change_to_directory (home_dir))
 	return retval;
     }
 
   return retval;
 }
 
@@ -158,17 +158,17 @@ from system to system.\n\
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("ls");
 
   if (error_state)
     return retval;
 
-  ostrstream ls_buf;
+  std::ostrstream ls_buf;
 
   ls_buf << "ls -C ";
   for (int i = 1; i < argc; i++)
     ls_buf << file_ops::tilde_expand (argv[i]) << " ";
 
   ls_buf << ends;
   char *ls_command = ls_buf.str ();
 
@@ -215,17 +215,17 @@ DEFALIAS (dir, ls);
 DEFUN (pwd, , nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} pwd ()\n\
 Return the current working directory.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  string directory = octave_env::getcwd ();
+  std::string directory = octave_env::getcwd ();
 
   if (directory.empty ())
     warning ("pwd: can't find working directory!");
   else
     {
       if (nargout == 0)
 	octave_stdout << directory << "\n";
       else
@@ -243,23 +243,23 @@ strings.  If an error occurs, return an 
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(2) = string ();
+  retval(2) = std::string ();
   retval(1) = -1.0;
   retval(0) = Matrix ();
 
   if (args.length () == 1)
     {
-      string dirname = args(0).string_value ();
+      std::string dirname = args(0).string_value ();
 
       if (error_state)
 	gripe_wrong_type_arg ("readdir", args(0));
       else
 	{
 	  dir_entry dir (file_ops::tilde_expand (dirname));
 
 	  if (dir)
@@ -290,28 +290,28 @@ Create a directory named @var{dir}.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = -1.0;
 
   if (args.length () == 1)
     {
-      string dirname = args(0).string_value ();
+      std::string dirname = args(0).string_value ();
 
       if (error_state)
 	gripe_wrong_type_arg ("mkdir", args(0));
       else
 	{
-	  string msg;
+	  std::string msg;
 
 	  int status = file_ops::mkdir (file_ops::tilde_expand (dirname),
 					0777, msg);
 
 	  retval(0) = static_cast<double> (status);
 
 	  if (status < 0)
 	    retval(1) = msg;
@@ -330,28 +330,28 @@ Remove the directory named @var{dir}.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = -1.0;
 
   if (args.length () == 1)
     {
-      string dirname = args(0).string_value ();
+      std::string dirname = args(0).string_value ();
 
       if (error_state)
 	gripe_wrong_type_arg ("rmdir", args(0));
       else
 	{
-	  string msg;
+	  std::string msg;
 
 	  int status = file_ops::rmdir (file_ops::tilde_expand (dirname), msg);
 
 	  retval(0) = static_cast<double> (status);
 
 	  if (status < 0)
 	    retval(1) = msg;
 	}
@@ -369,34 +369,34 @@ Change the name of file @var{old} to @va
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = -1.0;
 
   if (args.length () == 2)
     {
-      string from = args(0).string_value ();
+      std::string from = args(0).string_value ();
 
       if (error_state)
 	gripe_wrong_type_arg ("rename", args(0));
       else
 	{
-	  string to = args(1).string_value ();
+	  std::string to = args(1).string_value ();
 
 	  if (error_state)
 	    gripe_wrong_type_arg ("rename", args(1));
 	  else
 	    {
-	      string msg;
+	      std::string msg;
 
 	      int status = file_ops::rename (from, to, msg);
 
 	      retval(0) = static_cast<double> (status);
 
 	      if (status < 0)
 		retval(1) = msg;
 	    }
diff --git a/src/dirfns.h b/src/dirfns.h
--- a/src/dirfns.h
+++ b/src/dirfns.h
@@ -22,22 +22,22 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_dirfns_h)
 #define octave_dirfns_h 1
 
 #include <ctime>
 
 #include <string>
 
-extern string polite_directory_format (const string&);
-extern string base_pathname (const string&);
-extern string make_absolute (const string&, const string&);
-extern string get_working_directory (const string&);
+extern std::string polite_directory_format (const std::string&);
+extern std::string base_pathname (const std::string&);
+extern std::string make_absolute (const std::string&, const std::string&);
+extern std::string get_working_directory (const std::string&);
 
-extern string Vcurrent_directory;
+extern std::string Vcurrent_directory;
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -49,30 +49,30 @@ class
 octave_shlib_list
 {
 public:
 
   static void append (const octave_shlib& shl);
 
   static void remove (octave_shlib& shl);
 
-  static void *search (const string& fcn_name, octave_shlib& shl,
+  static void *search (const std::string& fcn_name, octave_shlib& shl,
 		       octave_shlib::name_mangler mangler = 0);
 
 private:
 
   octave_shlib_list (void) { }
 
   ~octave_shlib_list (void) { }
 
   void do_append (const octave_shlib& shl);
 
   void do_remove (octave_shlib& shl);
 
-  void *do_search (const string& fcn_name, octave_shlib& shl,
+  void *do_search (const std::string& fcn_name, octave_shlib& shl,
 		   octave_shlib::name_mangler mangler = 0);
 
   static octave_shlib_list *instance;
 
   static bool instance_ok (void);
 
   // List of libraries we have loaded.
   DLList<octave_shlib> lib_list;
@@ -104,17 +104,17 @@ octave_shlib_list::do_remove (octave_shl
 	  lib_list.del (p);
 
 	  break;
 	}
     }
 }
 
 void *
-octave_shlib_list::do_search (const string& fcn_name, octave_shlib& shl,
+octave_shlib_list::do_search (const std::string& fcn_name, octave_shlib& shl,
 			      octave_shlib::name_mangler mangler)
 {
   void *function = 0;
 
   shl = octave_shlib ();
 
   for (Pix p = lib_list.first (); p != 0; lib_list.next (p))
     {
@@ -159,17 +159,17 @@ octave_shlib_list::append (const octave_
 void
 octave_shlib_list::remove (octave_shlib& shl)
 {
   if (instance_ok ())
     instance->do_remove (shl);
 }
 
 void *
-octave_shlib_list::search (const string& fcn_name, octave_shlib& shl,
+octave_shlib_list::search (const std::string& fcn_name, octave_shlib& shl,
 			   octave_shlib::name_mangler mangler)
 {
   return (instance_ok ()) ? instance->do_search (fcn_name, shl, mangler) : 0;
 }
 
 octave_dynamic_loader *octave_dynamic_loader::instance = 0;
 
 bool octave_dynamic_loader::doing_load = false;
@@ -188,31 +188,31 @@ octave_dynamic_loader::instance_ok (void
 
       retval = false;
     }
 
   return retval;
 }
 
 static
-void clear_function (const string& fcn_name)
+void clear_function (const std::string& fcn_name)
 {
   if (Vwarn_reload_forces_clear)
     warning ("  %s", fcn_name.c_str ());
 
   curr_sym_tab->clear (fcn_name);
 
   if (curr_sym_tab != top_level_sym_tab)
     top_level_sym_tab->clear (fcn_name);
 
   global_sym_tab->clear (fcn_name);
 }
 
 bool
-octave_dynamic_loader::do_load (const string& fcn_name)
+octave_dynamic_loader::do_load (const std::string& fcn_name)
 {
   bool retval = false;
 
   octave_shlib oct_file;
 
   unwind_protect::begin_frame ("octave_dynamic_loader::do_load");
 
   unwind_protect_bool (octave_dynamic_loader::doing_load);
@@ -234,17 +234,17 @@ octave_dynamic_loader::do_load (const st
 
 	  oct_file.close (clear_function);
 
 	  function = 0;
 	}
 
       if (! function)
 	{
-	  string oct_file_name = oct_file_in_path (fcn_name);
+	  std::string oct_file_name = oct_file_in_path (fcn_name);
 
 	  if (! oct_file_name.empty ())
 	    {
 	      oct_file.open (oct_file_name, Vwarn_future_time_stamp);
 
 	      if (! error_state)
 		{
 		  if (oct_file)
@@ -273,17 +273,17 @@ octave_dynamic_loader::do_load (const st
     }
 
   unwind_protect::run_frame ("octave_dynamic_loader::do_load");
 
   return retval;
 }
 
 bool
-octave_dynamic_loader::do_remove (const string& fcn_name, octave_shlib& shl)
+octave_dynamic_loader::do_remove (const std::string& fcn_name, octave_shlib& shl)
 {
   bool retval = false;
 
   // We don't need to do anything if this is called because we are in
   // the process of reloading a .oct file that has changed.
 
   if (! doing_load)
     {
@@ -292,34 +292,34 @@ octave_dynamic_loader::do_remove (const 
       if (shl.number_of_functions_loaded () == 0)
 	octave_shlib_list::remove (shl);
     }
 
   return retval;
 }
 
 bool
-octave_dynamic_loader::load (const string& fcn_name)
+octave_dynamic_loader::load (const std::string& fcn_name)
 {
   return (instance_ok ()) ? instance->do_load (fcn_name) : false;
 }
 
 bool
-octave_dynamic_loader::remove (const string& fcn_name, octave_shlib& shl)
+octave_dynamic_loader::remove (const std::string& fcn_name, octave_shlib& shl)
 {
   return (instance_ok ()) ? instance->do_remove (fcn_name, shl) : false;
 }
 
 string
-octave_dynamic_loader::mangle_name (const string& name)
+octave_dynamic_loader::mangle_name (const std::string& name)
 {
 #if defined (CXX_PREPENDS_UNDERSCORE)
-  string retval ("_FS");
+  std::string retval ("_FS");
 #else
-  string retval ("FS");
+  std::string retval ("FS");
 #endif
   retval.append (name);
   retval.append ("__FRC12octave_shlib");
   return retval;
 }
 
 static int
 warn_reload_forces_clear (void)
diff --git a/src/dynamic-ld.h b/src/dynamic-ld.h
--- a/src/dynamic-ld.h
+++ b/src/dynamic-ld.h
@@ -33,41 +33,41 @@ octave_dynamic_loader
 protected:
 
   octave_dynamic_loader (void) { }
 
 public:
 
   virtual ~octave_dynamic_loader (void) { }
 
-  static bool load (const string& fcn_name);
+  static bool load (const std::string& fcn_name);
 
-  static bool remove (const string& fcn_name, octave_shlib& shl);
+  static bool remove (const std::string& fcn_name, octave_shlib& shl);
 
 private:
 
   // No copying!
 
   octave_dynamic_loader (const octave_dynamic_loader&);
 
   octave_dynamic_loader& operator = (const octave_dynamic_loader&);
 
   static octave_dynamic_loader *instance;
 
   static bool instance_ok (void);
 
-  bool do_load (const string& fcn_name);
+  bool do_load (const std::string& fcn_name);
 
-  bool do_remove (const string& fcn_name, octave_shlib& shl);
+  bool do_remove (const std::string& fcn_name, octave_shlib& shl);
 
   static bool doing_load;
 
 protected:
 
-  static string mangle_name (const string& name);
+  static std::string mangle_name (const std::string& name);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -49,27 +49,27 @@ int error_state = 0;
 int warning_state = 0;
 
 // Tell the error handler whether to print messages, or just store
 // them for later.  Used for handling errors in eval() and
 // the `unwind_protect' statement.
 bool buffer_error_messages = false;
 
 // The message buffer
-ostrstream *error_message_buffer = 0;
+std::ostrstream *error_message_buffer = 0;
 
 // Warning messages are never buffered.
 // XXX FIXME XXX -- we should provide another way to turn them off...
 
 static void
 vwarning (const char *name, const char *fmt, va_list args)
 {
   flush_octave_stdout ();
 
-  ostrstream output_buf;
+  std::ostrstream output_buf;
 
   if (name)
     {
       octave_diary << name << ": ";
       cerr << name << ": ";
     }
 
   octave_diary.vform (fmt, args);
@@ -81,17 +81,17 @@ vwarning (const char *name, const char *
 
 static void
 verror (const char *name, const char *fmt, va_list args)
 {
   flush_octave_stdout ();
 
   bool to_beep_or_not_to_beep_p = Vbeep_on_error && ! error_state;
 
-  ostrstream output_buf;
+  std::ostrstream output_buf;
 
   if (to_beep_or_not_to_beep_p)
     output_buf << "\a";
   if (name)
     output_buf << name << ": ";
   output_buf.vform (fmt, args);
   output_buf << endl << ends;
 
@@ -235,17 +235,17 @@ typedef void (*error_fun)(const char *, 
 
 extern octave_value_list Fsprintf (const octave_value_list&, int);
 
 static octave_value_list
 handle_message (error_fun f, const char *msg, const octave_value_list& args)
 {
   octave_value_list retval;
 
-  string tstr;
+  std::string tstr;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
       octave_value arg;
 
       if (nargin > 1)
diff --git a/src/error.h b/src/error.h
--- a/src/error.h
+++ b/src/error.h
@@ -43,17 +43,17 @@ extern int error_state;
 extern int warning_state;
 
 // Tell the error handler whether to print messages, or just store
 // them for later.  Used for handling errors in eval() and
 // the `unwind_protect' statement.
 extern bool buffer_error_messages;
 
 // The message buffer
-extern ostrstream *error_message_buffer;
+extern std::ostrstream *error_message_buffer;
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -90,17 +90,17 @@ initialize_file_io (void)
 
 void
 close_files (void)
 {
   octave_stream_list::clear ();
 }
 
 static int
-fopen_mode_to_ios_mode (const string& mode)
+fopen_mode_to_ios_mode (const std::string& mode)
 {
   int retval = 0;
 
   if (! mode.empty ())
     {
       // Could probably be faster, but does it really matter?
 
       if (mode == "r")
@@ -236,17 +236,17 @@ If there are no more characters to read,
 
       if (! error_state)
 	{
 	  octave_value len_arg = (nargin == 2)
 	    ? args(1) : octave_value (static_cast<double> (INT_MAX));
 
 	  bool err = false;
 
-	  string tmp = os.getl (len_arg, err);
+	  std::string tmp = os.getl (len_arg, err);
 
 	  if (! err)
 	    {
 	      retval(1) = static_cast<double> (tmp.length ());
 	      retval(0) = tmp;
 	    }
 	}
     }
@@ -282,34 +282,34 @@ If there are no more characters to read,
 
       if (! error_state)
 	{
 	  octave_value len_arg = (nargin == 2)
 	    ? args(1) : octave_value (static_cast<double> (INT_MAX));
 
 	  bool err = false;
 
-	  string tmp = os.gets (len_arg, err);
+	  std::string tmp = os.gets (len_arg, err);
 
 	  if (! err)
 	    {
 	      retval(1) = static_cast<double> (tmp.length ());
 	      retval(0) = tmp;
 	    }
 	}
     }
   else
     print_usage ("fgets");
 
   return retval;
 }
 
 static octave_stream
-do_stream_open (const string& name, const string& mode,
-		const string& arch, int& fid)
+do_stream_open (const std::string& name, const std::string& mode,
+		const std::string& arch, int& fid)
 {
   octave_stream retval;
 
   fid = -1;
 
   int md = fopen_mode_to_ios_mode (mode);
 
   if (! error_state)
@@ -327,25 +327,25 @@ do_stream_open (const string& name, cons
 static octave_stream
 do_stream_open (const octave_value& tc_name, const octave_value& tc_mode,
 		const octave_value& tc_arch, const char *fcn, int& fid)
 {
   octave_stream retval;
 
   fid = -1;
 
-  string name = tc_name.string_value ();
+  std::string name = tc_name.string_value ();
 
   if (! error_state)
     {
-      string mode = tc_mode.string_value ();
+      std::string mode = tc_mode.string_value ();
 
       if (! error_state)
 	{
-	  string arch = tc_arch.string_value ();
+	  std::string arch = tc_arch.string_value ();
 
 	  if (! error_state)
 	    retval = do_stream_open (name, mode, arch, fid);
 	  else
 	    ::error ("%s: architecture type must be a string", fcn);
 	}
       else
 	::error ("%s: file mode must be a string", fcn);
@@ -653,17 +653,17 @@ written to the stream @var{fid} instead 
 	  fmt_n = 1;
 	  os = octave_stream_list::lookup (args(0), "fprintf");
 	}
 
       if (! error_state)
 	{
 	  if (args(fmt_n).is_string ())
 	    {
-	      string fmt = args(fmt_n).string_value ();
+	      std::string fmt = args(fmt_n).string_value ();
 
 	      octave_value_list tmp_args;
 
 	      if (nargin > 1 + fmt_n)
 		{
 		  tmp_args.resize (nargin-fmt_n-1, octave_value ());
 
 		  for (int i = fmt_n + 1; i < nargin; i++)
@@ -728,17 +728,17 @@ converted.\n\
       octave_ostrstream *ostr = new octave_ostrstream ();
 
       octave_stream os (ostr);
 
       if (os.is_valid ())
 	{
 	  if (args(0).is_string ())
 	    {
-	      string fmt = args(0).string_value ();
+	      std::string fmt = args(0).string_value ();
 
 	      octave_value_list tmp_args;
 
 	      if (nargin > 1)
 		{
 		  tmp_args.resize (nargin-1, octave_value ());
 
 		  for (int i = 1; i < nargin; i++)
@@ -811,17 +811,17 @@ conversions is returned in @var{count}\n
   if (nargin == 3 && args(2).is_string ())
     {
       octave_stream os = octave_stream_list::lookup (args(0), "fscanf");
 
       if (! error_state)
 	{
 	  if (args(1).is_string ())
 	    {
-	      string fmt = args(1).string_value ();
+	      std::string fmt = args(1).string_value ();
 
 	      retval = os.oscanf (fmt);
 	    }
 	  else
 	    ::error ("fscanf: format must be a string");
 	}
     }
   else
@@ -832,17 +832,17 @@ conversions is returned in @var{count}\n
       if (nargin == 2 || nargin == 3)
 	{
 	  octave_stream os = octave_stream_list::lookup (args(0), "fscanf");
 
 	  if (! error_state)
 	    {
 	      if (args(1).is_string ())
 		{
-		  string fmt = args(1).string_value ();
+		  std::string fmt = args(1).string_value ();
 
 		  int count = 0;
 
 		  Matrix size = (nargin == 3)
 		    ? args(2).matrix_value () : Matrix (1, 1, octave_Inf);
 
 		  if (! error_state)
 		    {
@@ -875,25 +875,25 @@ string is treated as an end-of-file cond
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 3 && args(2).is_string ())
     {
       if (args(0).is_string ())
 	{
-	  string data = args(0).string_value ();
+	  std::string data = args(0).string_value ();
 
 	  octave_stream os = octave_istrstream::create (data);
 
 	  if (os.is_valid ())
 	    {
 	      if (args(1).is_string ())
 		{
-		  string fmt = args(1).string_value ();
+		  std::string fmt = args(1).string_value ();
 
 		  retval = os.oscanf (fmt);
 		}
 	      else
 		::error ("sscanf: format must be a string");
 	    }
 	  else
 	    ::error ("sscanf: unable to create temporary input buffer");
@@ -907,37 +907,37 @@ string is treated as an end-of-file cond
 	{
 	  retval(3) = -1.0;
 	  retval(2) = "unknown error";
 	  retval(1) = 0.0;
 	  retval(0) = Matrix ();
 
 	  if (args(0).is_string ())
 	    {
-	      string data = args(0).string_value ();
+	      std::string data = args(0).string_value ();
 
 	      octave_stream os = octave_istrstream::create (data);
 
 	      if (os.is_valid ())
 		{
 		  if (args(1).is_string ())
 		    {
-		      string fmt = args(1).string_value ();
+		      std::string fmt = args(1).string_value ();
 
 		      int count = 0;
 
 		      Matrix size = (nargin == 3)
 			? args(2).matrix_value () : Matrix (1, 1, octave_Inf);
 
 		      octave_value tmp = os.scanf (fmt, size, count);
 
 		      // XXX FIXME XXX -- is this the right thing to do?
 		      // Extract error message first, because getting
 		      // position will clear it.
-		      string errmsg = os.error ();
+		      std::string errmsg = os.error ();
 
 		      retval(3) = static_cast<double> (os.tell () + 1);
 		      retval(2) = errmsg;
 		      retval(1) = static_cast<double> (count);
 		      retval(0) = tmp;
 		    }
 		  else
 		    ::error ("sscanf: format must be a string");
@@ -984,30 +984,30 @@ do_fread (octave_stream& os, const octav
   octave_value retval;
 
   count = -1;
 
   Matrix size = size_arg.matrix_value ();
 
   if (! error_state)
     {
-      string prec = prec_arg.string_value ();
+      std::string prec = prec_arg.string_value ();
 
       if (! error_state)
 	{
 	  oct_data_conv::data_type dt
 	    = oct_data_conv::string_to_data_type (prec);
 
 	  if (! error_state)
 	    {
 	      int skip = skip_arg.int_value (true);
 
 	      if (! error_state)
 		{
-		  string arch = arch_arg.string_value ();
+		  std::string arch = arch_arg.string_value ();
 
 		  if (! error_state)
 		    {
 		      oct_mach_info::float_format flt_fmt
 			= oct_mach_info::string_to_float_format (arch);
 
 		      if (! error_state)
 			retval = os.read (size, dt, skip, flt_fmt, count);
@@ -1197,30 +1197,30 @@ values read is returned in @code{count}\
 
 static int
 do_fwrite (octave_stream& os, const octave_value& data,
 	   const octave_value& prec_arg, const octave_value& skip_arg,
 	   const octave_value& arch_arg)
 {
   int retval = -1;
 
-  string prec = prec_arg.string_value ();
+  std::string prec = prec_arg.string_value ();
 
   if (! error_state)
     {
       oct_data_conv::data_type dt
 	= oct_data_conv::string_to_data_type (prec);
 
       if (! error_state)
 	{
 	  int skip = skip_arg.int_value (true);
 
 	  if (! error_state)
 	    {
-	      string arch = arch_arg.string_value ();
+	      std::string arch = arch_arg.string_value ();
 
 	      if (! error_state)
 		{
 		  oct_mach_info::float_format flt_fmt
 		    = oct_mach_info::string_to_float_format (arch);
 
 		  if (! error_state)
 		    retval = os.write (data, dt, skip, flt_fmt);
@@ -1333,27 +1333,27 @@ error condition.\n\
       octave_stream os = octave_stream_list::lookup (args(0), "ferror");
 
       if (! error_state)
 	{
 	  bool clear = false;
 
 	  if (nargin == 2)
 	    {
-	      string opt = args(1).string_value ();
+	      std::string opt = args(1).string_value ();
 
 	      if (! error_state)
 		clear = (opt == "clear");
 	      else
 		return retval;
 	    }
 
 	  int error_number = 0;
 
-	  string error_message = os.error (clear, error_number);
+	  std::string error_message = os.error (clear, error_number);
 
 	  retval(1) = static_cast<double> (error_number);
 	  retval(0) = error_message;
 	}
     }
   else
     print_usage ("ferror");
 
@@ -1394,21 +1394,21 @@ endwhile\n\
 @end deftypefn")
 {
   octave_value retval = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
-      string name = args(0).string_value ();
+      std::string name = args(0).string_value ();
 
       if (! error_state)
 	{
-	  string mode = args(1).string_value ();
+	  std::string mode = args(1).string_value ();
 
 	  if (! error_state)
 	    {
 	      if (mode == "r")
 		{
 		  octave_stream ips = octave_iprocstream::create (name);
 
 		  retval = octave_stream_list::insert (ips);
@@ -1465,18 +1465,18 @@ by the time your program attempts to ope
 @end deftypefn")
 {
   octave_value retval;
 
   int len = args.length ();
 
   if (len < 3)
     {
-      string dir = len > 0 ? args(0).string_value () : string ();
-      string pfx = len > 1 ? args(1).string_value () : string ("oct-");
+      std::string dir = len > 0 ? args(0).string_value () : std::string ();
+      std::string pfx = len > 1 ? args(1).string_value () : std::string ("oct-");
 
       if (! error_state)
 	retval = file_ops::tempnam (dir, pfx);
     }
   else
     print_usage ("tmpnam");
 
   return retval;
diff --git a/src/fn-cache.cc b/src/fn-cache.cc
--- a/src/fn-cache.cc
+++ b/src/fn-cache.cc
@@ -39,29 +39,29 @@ Software Foundation, 59 Temple Place - S
 octave_fcn_file_name_cache *octave_fcn_file_name_cache::instance = 0;
 
 // Update the cache.  Returns TRUE if something needed to be updated.
 
 // We just accumulate all directories ever referenced in the cache and
 // we don't delete any old ones.
 
 bool
-octave_fcn_file_name_cache::update (const string& path)
+octave_fcn_file_name_cache::update (const std::string& path)
 {
   bool something_changed = false;
 
   dir_path p = path.empty () ? Vload_path_dir_path : dir_path (path);
 
   string_vector dirs = p.all_directories ();
 
   int len = dirs.length ();
 
   for (int i = 0; i < len; i++)
     {
-      string d = dirs[i];
+      std::string d = dirs[i];
 
       if (cache.contains (d))
 	{
 	  if (cache[d].update (d))
 	    something_changed = true;
 	}
       else
 	{
@@ -69,17 +69,17 @@ octave_fcn_file_name_cache::update (cons
 	  something_changed = true;
 	}
     }
 
   return something_changed;
 }
 
 string_vector
-octave_fcn_file_name_cache::list (const string& path, bool no_suffix)
+octave_fcn_file_name_cache::list (const std::string& path, bool no_suffix)
 {
   string_vector retval;
 
   if (! instance)
     instance = new octave_fcn_file_name_cache ();
 
   if (instance)
     retval = instance->do_list (path, no_suffix);
@@ -88,17 +88,17 @@ octave_fcn_file_name_cache::list (const 
 
   return retval;
 }
 
 // Check to see if any of the elements in the cache need to be
 // updated, then return the list of names in the cache.
 
 string_vector
-octave_fcn_file_name_cache::do_list (const string& path, bool no_suffix)
+octave_fcn_file_name_cache::do_list (const std::string& path, bool no_suffix)
 {
   update (path);
 
   string_vector fcn_file_names;
   string_vector fcn_file_names_no_suffix;
 
   // For now, always generate the list of function files on each
   // call.
@@ -116,29 +116,29 @@ octave_fcn_file_name_cache::do_list (con
   string_vector dirs = p.all_directories ();
 
   int ndirs = dirs.length ();
 
   if (ndirs > 1)
     {
       for (int i = 0; i < ndirs; i++)
 	{
-	  string d = dirs[i];
+	  std::string d = dirs[i];
 
 	  total_len += cache[d].length ();
 	}
 
       fcn_file_names.resize (total_len);
       fcn_file_names_no_suffix.resize (total_len);
 
       int k = 0;
 
       for (int j = 0; j < ndirs; j++)
 	{
-	  string d = dirs[j];
+	  std::string d = dirs[j];
 
 	  file_name_cache_elt elt = cache[d];
 
 	  int len = elt.length ();
 
 	  string_vector ffn = elt.fcn_file_names;
 	  string_vector ffnns = elt.fcn_file_names_no_suffix;
 
@@ -148,32 +148,32 @@ octave_fcn_file_name_cache::do_list (con
 	      fcn_file_names_no_suffix[k] = ffnns[i];
 
 	      k++;
 	    }
 	}
     }
   else if (ndirs == 1)
     {
-      string d = dirs[0];
+      std::string d = dirs[0];
 
       file_name_cache_elt elt = cache[d];
 
       fcn_file_names = elt.fcn_file_names;
       fcn_file_names_no_suffix = elt.fcn_file_names_no_suffix;
     }
 
   return no_suffix ? fcn_file_names_no_suffix : fcn_file_names;
 }
 
 // Create a list of the function names in a given directory.  Returns
 // TRUE if the cache element was out of date.
 
 bool
-file_name_cache_elt::update (const string& dir_name)
+file_name_cache_elt::update (const std::string& dir_name)
 {
   bool retval = false;
 
   file_stat file (dir_name);
 
   // If the directory doesn't exist, delete the names in the cache.
   // If it does exist,read it only if it is out of date.
 
@@ -195,17 +195,17 @@ file_name_cache_elt::update (const strin
 
 	      fcn_file_names.resize (max_len);
 	      fcn_file_names_no_suffix.resize (max_len);
 
 	      int k = 0;
 	      int i;
 	      for (i = 0; i < max_len; i++)
 		{
-		  string entry = tmp[i];
+		  std::string entry = tmp[i];
 
 		  int len = entry.length ();
 
 #if defined (WITH_DYNAMIC_LINKING)
 		  if ((len > 2
 		       && entry[len-2] == '.' && entry[len-1] == 'm')
 		      || (len > 4
 			  && entry[len-4] == '.' && entry[len-3] == 'o'
@@ -213,18 +213,18 @@ file_name_cache_elt::update (const strin
 #else
 		  if (len > 2
 		      && entry[len-2] == '.' && entry[len-1] == 'm')
 #endif
 		    {
 		      fcn_file_names[k] = entry;
 
 		      fcn_file_names_no_suffix[k] = (entry[len-1] == 'm')
-			? string (entry, 0, len-2)
-			: string (entry, 0, len-4);
+			? std::string (entry, 0, len-2)
+			: std::string (entry, 0, len-4);
 
 		      k++;
 		    }
 		}
 
 	      fcn_file_names.resize (k);
 	      fcn_file_names_no_suffix.resize (k);
 	    }
diff --git a/src/fn-cache.h b/src/fn-cache.h
--- a/src/fn-cache.h
+++ b/src/fn-cache.h
@@ -37,19 +37,19 @@ class string_vector;
 class
 file_name_cache_elt
 {
 public:
 
   file_name_cache_elt (void)
     : timestamp (static_cast<time_t> (0)), fcn_file_names (),
       fcn_file_names_no_suffix ()
-  { update (string ()); }
+  { update (std::string ()); }
 
-  file_name_cache_elt (const string& dir_name)
+  file_name_cache_elt (const std::string& dir_name)
     : timestamp (static_cast<time_t> (0)), fcn_file_names (),
       fcn_file_names_no_suffix ()
   { update (dir_name); }
 
   file_name_cache_elt (const file_name_cache_elt& elt)
   {
     timestamp = elt.timestamp;
     fcn_file_names = elt.fcn_file_names;
@@ -66,17 +66,17 @@ public:
       }
     return *this;
   }
 
   ~file_name_cache_elt (void) { }
 
   int length (void) { return fcn_file_names.length (); }
 
-  bool update (const string& dir_name);
+  bool update (const std::string& dir_name);
 
   // The time we last read this directory.
   octave_time timestamp;
 
   // The list of file names in this directory.
   string_vector fcn_file_names;
 
   // The list of file names in this directory without the .m or .oct
@@ -86,44 +86,44 @@ public:
 
 class
 octave_fcn_file_name_cache
 {
 protected:
 
   octave_fcn_file_name_cache (void)
     : cache (file_name_cache_elt ())
-  { update (string ()); }
+  { update (std::string ()); }
 
 public:
 
   ~octave_fcn_file_name_cache (void) { }
 
-  bool update (const string& path);
+  bool update (const std::string& path);
 
   static string_vector list (bool no_suffix = false)
-    { return list (string (), no_suffix); }
+    { return list (std::string (), no_suffix); }
 
-  static string_vector list (const string& path, bool no_suffix = false);
+  static string_vector list (const std::string& path, bool no_suffix = false);
 
   static string_vector list_no_suffix (void)
     { return list (true); }
 
-  static string_vector list_no_suffix (const string& path)
+  static string_vector list_no_suffix (const std::string& path)
     { return list (path, true); }
 
 private:
 
   static octave_fcn_file_name_cache* instance;
 
   // An associative array of all the directory names in the load path
   // and the corresponding cache elements.
   CHMap<file_name_cache_elt> cache;
 
-  string_vector do_list (const string& path, bool no_suffix);
+  string_vector do_list (const std::string& path, bool no_suffix);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/gripes.cc b/src/gripes.cc
--- a/src/gripes.cc
+++ b/src/gripes.cc
@@ -32,17 +32,17 @@ void
 gripe_not_supported (const char *fcn)
 {
   error ("%s: not supported on this system", fcn);
 }
 
 void
 gripe_string_invalid (void)
 {
-  error ("string constant used in invalid context");
+  error ("std::string constant used in invalid context");
 }
 
 void
 gripe_range_invalid (void)
 {
   error ("range constant used in invalid context");
 }
 
@@ -82,17 +82,17 @@ gripe_user_supplied_eval (const char *na
 
 void
 gripe_user_returned_invalid (const char *name)
 {
   error ("%s: user-supplied function returned invalid value", name);
 }
 
 void
-gripe_invalid_conversion (const string& from, const string& to)
+gripe_invalid_conversion (const std::string& from, const std::string& to)
 {
   error ("invalid conversion from %s to %s", from.c_str (), to.c_str ());
 }
 
 void
 gripe_invalid_value_specified (const char *name)
 {
   warning ("invalid value specified for `%s'", name);
@@ -118,47 +118,47 @@ gripe_unrecognized_data_fmt (const char 
 
 void
 gripe_data_conversion (const char *from, const char *to)
 {
   error ("unable to convert from %s to %s format", from, to);
 }
 
 void
-gripe_wrong_type_arg (const char *name, const string& s, bool is_error)
+gripe_wrong_type_arg (const char *name, const std::string& s, bool is_error)
 {
   if (is_error)
     error ("%s: wrong type argument `%s'", name, s.c_str ());
   else
     warning ("%s: wrong type argument `%s'", name, s.c_str ());
 }
 
 void
 gripe_wrong_type_arg (const char *name, const octave_value& tc,
 		      bool is_error)
 {
-  string type = tc.type_name ();
+  std::string type = tc.type_name ();
 
   if (is_error)
     error ("%s: wrong type argument `%s'", name, type.c_str ());
   else
     warning ("%s: wrong type argument `%s'", name, type.c_str ());
 }
 
 void
 gripe_wrong_type_arg_for_unary_op (const octave_value& op)
 {
-  string type = op.type_name ();
+  std::string type = op.type_name ();
   error ("invalid operand `%s' for unary operator", type.c_str ());
 }
 
 void
 gripe_wrong_type_arg_for_binary_op (const octave_value& op)
 {
-  string type = op.type_name ();
+  std::string type = op.type_name ();
   error ("invalid operand `%s' for binary operator", type.c_str ());
 }
 
 void
 gripe_implicit_conversion (const char *from, const char *to)
 {
   warning ("implicit conversion from %s to %s", from, to);
 }
diff --git a/src/gripes.h b/src/gripes.h
--- a/src/gripes.h
+++ b/src/gripes.h
@@ -50,17 +50,17 @@ gripe_square_matrix_required (const char
 
 extern void
 gripe_user_supplied_eval (const char *name);
 
 extern void
 gripe_user_returned_invalid (const char *name);
 
 extern void
-gripe_invalid_conversion (const string& from, const string& to);
+gripe_invalid_conversion (const std::string& from, const std::string& to);
 
 extern void
 gripe_invalid_value_specified (const char *name);
 
 extern void
 gripe_2_or_3_dim_plot (void);
 
 extern void
@@ -68,17 +68,17 @@ gripe_unrecognized_float_fmt (void);
 
 extern void
 gripe_unrecognized_data_fmt (const char *warn_for);
 
 extern void
 gripe_data_conversion (const char *from, const char *to);
 
 extern void
-gripe_wrong_type_arg (const char *name, const string& s,
+gripe_wrong_type_arg (const char *name, const std::string& s,
 		      bool is_error = true);
 
 extern void
 gripe_wrong_type_arg (const char *name, const octave_value& tc,
 		      bool is_error = true);
 
 extern void
 gripe_wrong_type_arg_for_unary_op (const octave_value& op);
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -65,21 +65,21 @@ Software Foundation, 59 Temple Place - S
 #include "toplev.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 #include "version.h"
 
 // Name of the info file specified on command line.
 // (--info-file file)
-string Vinfo_file;
+std::string Vinfo_file;
 
 // Name of the info reader we'd like to use.
 // (--info-program program)
-string Vinfo_prog;
+std::string Vinfo_prog;
 
 // If TRUE, don't print additional help message in help and usage
 // functions.
 static bool Vsuppress_verbose_help_message;
 
 // XXX FIXME XXX -- maybe this should use string instead of char*.
 
 struct help_list
@@ -382,51 +382,51 @@ make_name_list (void)
 
   for (i = 0; i < ffl_len; i++)
     list[j++] = ffl[i];
 
   return list;
 }
 
 void
-additional_help_message (ostream& os)
+additional_help_message (std::ostream& os)
 {
   if (! Vsuppress_verbose_help_message)
     os << "\n\
 Additional help for built-in functions, operators, and variables\n\
 is available in the on-line version of the manual.  Use the command\n\
 `help -i <topic>' to search the manual index.\n\
 \n\
 Help and information about Octave is also available on the WWW\n\
 at http://www.che.wisc.edu/octave/octave.html and via the\n\
 help-octave@bevo.che.wisc.edu mailing list.\n";
 }
 
 // XXX FIXME XXX -- this needs a major overhaul to cope with new
 // symbol table stuff.
 
 static void
-display_names_from_help_list (ostream& os, help_list *list,
+display_names_from_help_list (std::ostream& os, help_list *list,
 			      const char *desc)
 {
   string_vector symbols = names (list);
 
   if (! symbols.empty ())
     {
       os << "\n*** " << desc << ":\n\n";
 
       symbols.qsort ();
 
       symbols.list_in_columns (os);
     }
 }
 
 static void
-display_symtab_names (ostream& os, const string_vector& names,
-		      const string& desc)
+display_symtab_names (std::ostream& os, const string_vector& names,
+		      const std::string& desc)
 {
   if (! names.empty ())
     {
       os << "\n*** " << desc << ":\n\n";
       names.list_in_columns (os);
     }
 }
 
@@ -478,43 +478,43 @@ simple_help (void)
   int len = dirs.length ();
 
   for (int i = 0; i < len; i++)
     {
       string_vector names = octave_fcn_file_name_cache::list (dirs[i]);
 
       if (! names.empty ())
 	{
-	  string dir
+	  std::string dir
 	    = octave_env::make_absolute (dirs[i], octave_env::getcwd ());
 
 	  octave_stdout << "\n*** function files in " << dir << ":\n\n";
 
 	  names.qsort ();
 
 	  names.list_in_columns (octave_stdout);
 	}
     }
 }
 
 static int
-try_info (const string& nm)
+try_info (const std::string& nm)
 {
   int status = 0;
 
   static char *cmd_str = 0;
 
   delete [] cmd_str;
   cmd_str = 0;
 
-  ostrstream cmd_buf;
+  std::ostrstream cmd_buf;
 
   cmd_buf << Vinfo_prog << " --file " << Vinfo_file;
 
-  string directory_name = Vinfo_file;
+  std::string directory_name = Vinfo_file;
   size_t pos = directory_name.rfind ('/');
 
   if (pos != NPOS)
     {
       directory_name.resize (pos + 1);
       cmd_buf << " --directory " << directory_name;
     }
 
@@ -539,17 +539,17 @@ try_info (const string& nm)
 
   return status;
 }
 
 static void
 help_from_info (const string_vector& argv, int idx, int argc)
 {
   if (idx == argc)
-    try_info (string ());
+    try_info (std::string ());
   else
     {
       for (int i = idx; i < argc; i++)
 	{
 	  int status = try_info (argv[i]);
 
 	  if (status)
 	    {
@@ -565,56 +565,56 @@ help_from_info (const string_vector& arg
 			   argv[i].c_str ());
 		}
 	    }
 	}
     }
 }
 
 static bool
-looks_like_texinfo (const string& msg, size_t& p1)
+looks_like_texinfo (const std::string& msg, size_t& p1)
 {
   p1 = msg.find ('\n');
 
-  string t = msg.substr (0, p1);
+  std::string t = msg.substr (0, p1);
 
   if (p1 == NPOS)
     p1 = 0;
 
   size_t p2 = t.find ("-*- texinfo -*-");
 
   return (p2 != NPOS);
 }
 
 void
-display_help_text (ostream& os, const string& msg)
+display_help_text (std::ostream& os, const std::string& msg)
 {
   // Look for "-*- texinfo -*-" in first line of help message.  If it
   // is present, use makeinfo to format the rest of the message before
   // sending it to the output stream.  Otherwise, just print the
   // message.
 
   size_t pos;
 
   if (looks_like_texinfo (msg, pos))
     {
-      string tmp_file_name = file_ops::tempnam ("", "");
+      std::string tmp_file_name = file_ops::tempnam ("", "");
 
       int cols = command_editor::terminal_cols ();
 
       if (cols > 16)
 	cols--;
 
       if (cols > 64)
 	cols -= 7;
 
       if (cols > 80)
 	cols = 72;
 
-      ostrstream buf;
+      std::ostrstream buf;
       buf << "sed -e 's/^[#%]+ *//' -e 's/^ *@/@/' | makeinfo"
 	  << " -D \"VERSION " << OCTAVE_VERSION << "\""
 	  << " -D \"OCTAVEHOME " << OCTAVE_PREFIX << "\""
 	  << " -D \"TARGETHOSTTYPE " << CANONICAL_HOST_TYPE << "\""
 	  << " --fill-column " << cols
 	  << " --no-warn"
 	  << " --no-validate"
 	  << " --no-headers"
@@ -636,17 +636,17 @@ display_help_text (ostream& os, const st
 		 << "@noindent\n"
 		 << "See also: \\args\\.\n"
                  << "@end macro\n";
 
 	  filter << msg.substr (pos+1);
 
 	  filter.close ();
 
-	  ifstream tmp_file (tmp_file_name.c_str ());
+	  std::ifstream tmp_file (tmp_file_name.c_str ());
 
 	  int c;
 	  while ((c = tmp_file.get ()) != EOF)
 	    os << (char) c;
 
 	  tmp_file.close ();
 
 	  file_ops::unlink (tmp_file_name);
@@ -654,18 +654,18 @@ display_help_text (ostream& os, const st
       else
 	os << msg;
     }
   else
     os << msg;
 }
 
 static bool
-help_from_list (ostream& os, const help_list *list,
-		const string& nm, int usage)
+help_from_list (std::ostream& os, const help_list *list,
+		const std::string& nm, int usage)
 {
   const char *name;
 
   while ((name = list->name) != 0)
     {
       if (strcmp (name, nm.c_str ()) == 0)
 	{
 	  if (usage)
@@ -683,47 +683,47 @@ help_from_list (ostream& os, const help_
 	}
       list++;
     }
 
   return false;
 }
 
 static bool
-help_from_symbol_table (ostream& os, const string& nm)
+help_from_symbol_table (std::ostream& os, const std::string& nm)
 {
   bool retval = false;
 
   symbol_record *sym_rec = lookup_by_name (nm, 0);
 
   if (sym_rec && sym_rec->is_defined ())
     {
-      string h = sym_rec->help ();
+      std::string h = sym_rec->help ();
 
       if (h.length () > 0)
 	{
 	  sym_rec->which (os);
 	  os << "\n";
 	  display_help_text (os, h);
 	  os << "\n";
 	  retval = true;
 	}
     }
 
   return retval;
 }
 
 static bool
-help_from_file (ostream& os, const string& nm)
+help_from_file (std::ostream& os, const std::string& nm)
 {
   bool retval = false;
 
-  string path = fcn_file_in_path (nm);
+  std::string path = fcn_file_in_path (nm);
 
-  string h = get_help_from_file (path);
+  std::string h = get_help_from_file (path);
 
   if (! h.empty ())
     {
       os << nm << " is the file: " << path << "\n\n";
       display_help_text (os, h);
       os << "\n";
       retval = true;
     }
@@ -795,30 +795,30 @@ using the command @kbd{C-h}.\n\
       else
 	builtin_help (argc, argv);
     }
 
   return retval;
 }
 
 static void
-do_type (ostream& os, const string& name, bool pr_type_info,
+do_type (std::ostream& os, const std::string& name, bool pr_type_info,
 	 bool quiet, bool pr_orig_txt)
 {
   symbol_record *sym_rec = lookup_by_name (name, 0);
 
   if (sym_rec && sym_rec->is_defined ())
     sym_rec->type (os, pr_type_info, quiet, pr_orig_txt);
   else
     {
-      string ff = fcn_file_in_path (name);
+      std::string ff = fcn_file_in_path (name);
 
       if (! ff.empty ())
 	{
-	  ifstream fs (ff.c_str (), ios::in);
+	  std::ifstream fs (ff.c_str (), ios::in);
 
 	  if (fs)
 	    {
 	      if (pr_type_info && ! quiet)
 		os << name << " is the script file: " << ff << "\n\n";
 
 	      char ch;
 
@@ -877,21 +877,21 @@ representation.  This problem may be fix
 	      else if (argv[idx] == "-t" || argv[idx] == "-transformed")
 		pr_orig_txt = false;
 	      else
 		break;
 	    }
 
 	  if (idx < argc)
 	    {
-	      ostrstream output_buf;
+	      std::ostrstream output_buf;
 
 	      for (int i = idx; i < argc; i++)
 		{
-		  string id = argv[i];
+		  std::string id = argv[i];
 
 		  if (nargout == 0)
 		    do_type (octave_stdout, id, true, quiet, pr_orig_txt);
 		  else
 		    do_type (output_buf, id, false, quiet, pr_orig_txt);
 
 		  if (error_state)
 		    goto abort;
@@ -916,47 +916,47 @@ representation.  This problem may be fix
     }
 
  abort:
 
   return retval;
 }
 
 static string
-do_which (const string& name)
+do_which (const std::string& name)
 {
-  string retval;
+  std::string retval;
 
   symbol_record *sym_rec = lookup_by_name (name, 0);
 
   if (sym_rec && sym_rec->is_defined ())
     retval = sym_rec->which ();
   else
     {
-      string path = fcn_file_in_path (name);
+      std::string path = fcn_file_in_path (name);
 
       if (! path.empty ())
 	retval = path;
       else
 	retval = "undefined";
     }
 
   return retval;
 }
 
 static void
-do_which (ostream& os, const string& name)
+do_which (std::ostream& os, const std::string& name)
 {
   symbol_record *sym_rec = lookup_by_name (name, 0);
 
   if (sym_rec && sym_rec->is_defined ())
     sym_rec->which (os);
   else
     {
-      string path = fcn_file_in_path (name);
+      std::string path = fcn_file_in_path (name);
 
       if (! path.empty ())
 	os << "which: `" << name << "' is the script file\n"
 	   << path << "\n";
       else
 	os << "which: `" << name << "' is undefined\n";
     }
 }
@@ -978,17 +978,17 @@ function file, the full name of the file
 
       if (nargout > 0)
 	retval.resize (argc-1, Matrix ());
 
       if (argc > 1)
 	{
 	  for (int i = 1; i < argc; i++)
 	    {
-	      string id = argv[i];
+	      std::string id = argv[i];
 
 	      if (nargout == 0)
 		do_which (octave_stdout, id);
 	      else
 		retval(i-1) = do_which (id);
 	    }
 	}
       else
@@ -998,17 +998,17 @@ function file, the full name of the file
   return retval;
 }
 
 static int
 info_file (void)
 {
   int status = 0;
 
-  string s = builtin_string_variable ("INFO_FILE");
+  std::string s = builtin_string_variable ("INFO_FILE");
 
   if (s.empty ())
     {
       gripe_invalid_value_specified ("INFO_FILE");
       status = -1;
     }
   else
     Vinfo_file = s;
@@ -1016,17 +1016,17 @@ info_file (void)
   return status;
 }
 
 static int
 info_prog (void)
 {
   int status = 0;
 
-  string s = builtin_string_variable ("INFO_PROGRAM");
+  std::string s = builtin_string_variable ("INFO_PROGRAM");
 
   if (s.empty ())
     {
       gripe_invalid_value_specified ("INFO_PROGRAM");
       status = -1;
     }
   else
     Vinfo_prog = s;
diff --git a/src/help.h b/src/help.h
--- a/src/help.h
+++ b/src/help.h
@@ -25,27 +25,27 @@ Software Foundation, 59 Temple Place - S
 
 #include <iostream>
 #include <string>
 
 class string_vector;
 
 extern string_vector make_name_list (void);
 
-extern void display_help_text (ostream&, const string&);
+extern void display_help_text (std::ostream&, const std::string&);
 
-extern void additional_help_message (ostream&);
+extern void additional_help_message (std::ostream&);
 
 // Name of the info file specified on command line.
 // (--info-file file)
-extern string Vinfo_file;
+extern std::string Vinfo_file;
 
 // Name of the info reader we'd like to use.
 // (--info-program program)
-extern string Vinfo_prog;
+extern std::string Vinfo_prog;
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -63,23 +63,23 @@ Software Foundation, 59 Temple Place - S
 #include "sighandlers.h"
 #include "symtab.h"
 #include "sysdep.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // Primary prompt string.
-static string Vps1;
+static std::string Vps1;
 
 // Secondary prompt string.
-static string Vps2;
+static std::string Vps2;
 
 // String printed before echoed input (enabled by --echo-input).
-string Vps4;
+std::string Vps4;
 
 // Echo commands as they are executed?
 //
 //   1  ==>  echo commands read from script files
 //   2  ==>  echo commands from functions
 //   4  ==>  echo commands read from command line
 //
 // more than one state can be active at once.
@@ -87,29 +87,29 @@ int Vecho_executing_commands;
 
 // The time we last printed a prompt.
 octave_time Vlast_prompt_time;
 
 // Character to append after successful command-line completion attempts.
 static char Vcompletion_append_char;
 
 // Global pointer for eval().
-string current_eval_string;
+std::string current_eval_string;
 
 // TRUE means get input from current_eval_string.
 bool get_input_from_eval_string = false;
 
 // TRUE means we're parsing a function file.
 bool reading_fcn_file = false;
 
 // Simple name of function file we are reading.
-string curr_fcn_file_name;
+std::string curr_fcn_file_name;
 
 // Full name of file we are reading.
-string curr_fcn_file_full_name;
+std::string curr_fcn_file_full_name;
 
 // TRUE means we're parsing a script file.
 bool reading_script_file = false;
 
 // If we are reading from an M-file, this is it.
 FILE *ff_instream = 0;
 
 // TRUE means this is an interactive shell.
@@ -117,23 +117,23 @@ bool interactive = false;
 
 // TRUE means the user forced this shell to be interactive (-i).
 bool forced_interactive = false;
 
 // Should we issue a prompt?
 int promptflag = 1;
 
 // The current line of input, from wherever.
-string current_input_line;
+std::string current_input_line;
 
 // TRUE after a call to completion_matches().
 bool octave_completion_matches_called = false;
 
 static void
-do_input_echo (const string& input_string)
+do_input_echo (const std::string& input_string)
 {
   int do_echo = reading_script_file ?
     (Vecho_executing_commands & ECHO_SCRIPTS)
       : (Vecho_executing_commands & ECHO_CMD_LINE) && ! forced_interactive;
 
   if (do_echo)
     {
       if (forced_interactive)
@@ -152,19 +152,19 @@ do_input_echo (const string& input_strin
 
 	  if (input_string[input_string.length () - 1] != '\n')
 	    octave_stdout << "\n";
 	}
     }
 }
 
 string
-gnu_readline (const string& s, bool force_readline)
+gnu_readline (const std::string& s, bool force_readline)
 {
-  string retval;
+  std::string retval;
 
   if (line_editing || force_readline)
     {
       bool eof;
 
       retval = command_editor::readline (s, eof);
 
       if (! eof && retval.empty ())
@@ -189,26 +189,26 @@ gnu_readline (const string& s, bool forc
     }
 
   return retval;
 }
 
 static string
 octave_gets (void)
 {
-  string retval;
+  std::string retval;
 
   Vlast_prompt_time.stamp ();
 
   if ((interactive || forced_interactive)
       && (! (reading_fcn_file || reading_script_file)))
     {
-      string ps = (promptflag > 0) ? Vps1 : Vps2;
+      std::string ps = (promptflag > 0) ? Vps1 : Vps2;
 
-      string prompt = command_editor::decode_prompt_string (ps);
+      std::string prompt = command_editor::decode_prompt_string (ps);
 
       pipe_handler_error_count = 0;
 
       flush_octave_stdout ();
 
       octave_diary << prompt;
 
       retval = gnu_readline (prompt);
@@ -239,17 +239,17 @@ octave_gets (void)
   return retval;
 }
 
 // Read a line from the input stream.
 
 static string
 get_user_input (void)
 {
-  string retval;
+  std::string retval;
 
   if (get_input_from_eval_string)
     {
       retval = current_eval_string;
 
       size_t len = retval.length ();
 
       if (retval[len-1] != '\n')
@@ -266,17 +266,17 @@ get_user_input (void)
   return retval;
 }
 
 int
 octave_read (char *buf, unsigned max_size)
 {
   // XXX FIXME XXX -- is this a safe way to buffer the input?
 
-  static string input_buf;
+  static std::string input_buf;
   static const char *pos = 0;
   static size_t chars_left = 0;
 
   int status = 0;
 
   if (input_buf.empty ())
     {
       pos = 0;
@@ -333,17 +333,17 @@ octave_read (char *buf, unsigned max_siz
 
   return status;
 }
 
 // Fix things up so that input can come from file `name', printing a
 // warning if the file doesn't exist.
 
 FILE *
-get_input_from_file (const string& name, int warn)
+get_input_from_file (const std::string& name, int warn)
 {
   FILE *instream = 0;
 
   if (name.length () > 0)
     instream = fopen (name.c_str (), "r");
 
   if (! instream && warn)
     warning ("%s: no such file or directory", name.c_str ());
@@ -365,18 +365,18 @@ get_input_from_stdin (void)
 {
   command_editor::set_input_stream (stdin);
   return command_editor::get_input_stream ();
 }
 
 // XXX FIXME XXX -- make this generate file names when appropriate.
 
 static string_vector
-generate_possible_completions (const string& text, string& prefix,
-			       string& hint)
+generate_possible_completions (const std::string& text, std::string& prefix,
+			       std::string& hint)
 {
   string_vector names;
 
   prefix = "";
 
   if (! text.empty () && text != "." && text.rfind ('.') != NPOS)
     names = generate_struct_completions (text, prefix, hint);
   else
@@ -385,22 +385,22 @@ generate_possible_completions (const str
   // Sort and remove duplicates.
 
   names.qsort (true);
 
   return names;
 }
 
 static string
-generate_completion (const string& text, int state)
+generate_completion (const std::string& text, int state)
 {
-  string retval;
+  std::string retval;
 
-  static string prefix;
-  static string hint;
+  static std::string prefix;
+  static std::string hint;
 
   static size_t prefix_len = 0;
   static size_t hint_len = 0;
 
   static int list_index = 0;
   static int name_list_len = 0;
   static string_vector name_list;
 
@@ -428,17 +428,17 @@ generate_completion (const string& text,
 	if (! name_list[i].compare (hint, 0, hint_len))
 	  matches++;
     }
 
   if (name_list_len > 0 && matches > 0)
     {
       while (list_index < name_list_len)
 	{
-	  string name = name_list[list_index];
+	  std::string name = name_list[list_index];
 
 	  list_index++;
 
 	  if (! name.compare (hint, 0, hint_len))
 	    {
 	      if (! prefix.empty ())
 		retval = prefix + "." + name;
 	      else
@@ -467,17 +467,17 @@ initialize_command_input (void)
   command_editor::set_name ("Octave");
 
   command_editor::set_basic_quote_characters ("\"");
 
   command_editor::set_completion_function (generate_completion);
 }
 
 static bool
-match_sans_spaces (const string& standard, const string& test)
+match_sans_spaces (const std::string& standard, const std::string& test)
 {
   size_t beg = test.find_first_not_of (" \t");
 
   if (beg != NPOS)
     {
       size_t end = test.find_last_not_of (" \t");
 
       size_t len = end == NPOS ? NPOS : end - beg + 1;
@@ -497,34 +497,34 @@ get_user_input (const octave_value_list&
 
   int nargin = args.length ();
 
   int read_as_string = 0;
 
   if (nargin == 2)
     read_as_string++;
 
-  string prompt ("debug> ");
+  std::string prompt ("debug> ");
 
   if (nargin > 0)
    {
      prompt = args(0).string_value ();
 
      if (error_state)
        {
 	 error ("input: unrecognized argument");
 	 return retval;
        }
     }
 
  again:
 
   flush_octave_stdout ();
 
-  string input_buf = gnu_readline (prompt.c_str (), true);
+  std::string input_buf = gnu_readline (prompt.c_str (), true);
 
   if (! input_buf.empty ())
     {
       if (! input_from_startup_file)
 	command_history::add (input_buf);
 
       size_t len = input_buf.length ();
 
@@ -732,32 +732,32 @@ state.\n\
 	else
 	  bind_builtin_variable ("echo_executing_commands",
 				 static_cast<double> (ECHO_SCRIPTS));
       }
       break;
 
     case 2:
       {
-	string arg = argv[1];
+	std::string arg = argv[1];
 
 	if (arg == "on")
 	  bind_builtin_variable ("echo_executing_commands",
 				 static_cast<double> (ECHO_SCRIPTS));
 	else if (arg == "off")
 	  bind_builtin_variable ("echo_executing_commands",
 				 static_cast<double> (ECHO_OFF));
 	else
 	  print_usage ("echo");
       }
       break;
 
     case 3:
       {
-	string arg = argv[1];
+	std::string arg = argv[1];
 
 	if (arg == "on" && argv[2] == "all")
 	  {
 	    int tmp = (ECHO_SCRIPTS | ECHO_FUNCTIONS);
 	    bind_builtin_variable ("echo_executing_commands",
 				   static_cast<double> (tmp));
 	  }
 	else if (arg == "off" && argv[2] == "all")
@@ -788,29 +788,29 @@ a feature, not a bug.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      string hint = args(0).string_value ();
+      std::string hint = args(0).string_value ();
 
       if (! error_state)
 	{
 	  int n = 32;
 
 	  string_vector list (n);
 
 	  int k = 0;
 
 	  for (;;)
 	    {
-	      string cmd = generate_completion (hint, k);
+	      std::string cmd = generate_completion (hint, k);
 
 	      if (! cmd.empty ())
 		{
 		  if (k == n)
 		    {
 		      n *= 2;
 		      list.resize (n);
 		    }
@@ -863,28 +863,28 @@ Read the readline library initialiazatio
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     command_editor::read_init_file ();
   else if (nargin == 1)
     {
-      string file = file_ops::tilde_expand (args(0).string_value ());
+      std::string file = file_ops::tilde_expand (args(0).string_value ());
 
       if (! error_state)
 	command_editor::read_init_file (file);
     }
   else
     print_usage ("read_readline_init_file");
 
   return retval;
 }
 
-static string hook_fcn;
+static std::string hook_fcn;
 static octave_value user_data;
 
 static void
 input_event_hook (void)
 {
   if (user_data.is_defined ())
     feval (hook_fcn, user_data, 0);
   else
@@ -912,17 +912,17 @@ and the user data are returned.\n\
   int nargin = args.length ();
 
   if (nargin > 2)
     print_usage ("input_event_hook");
   else
     {
       octave_value tmp_user_data;
 
-      string tmp_hook_fcn;
+      std::string tmp_hook_fcn;
 
       if (nargin > 1)
 	tmp_user_data = args(1);
 
       if (nargin > 0)
 	{
 	  tmp_hook_fcn = args(0).string_value ();
 
@@ -978,17 +978,17 @@ ps4 (void)
   return status;
 }
 
 static int
 completion_append_char (void)
 {
   int status = 0;
 
-  string s = builtin_string_variable ("completion_append_char");
+  std::string s = builtin_string_variable ("completion_append_char");
 
   switch (s.length ())
     {
     case 1:
       Vcompletion_append_char = s[0];
       break;
 
     case 0:
diff --git a/src/input.h b/src/input.h
--- a/src/input.h
+++ b/src/input.h
@@ -27,33 +27,33 @@ Software Foundation, 59 Temple Place - S
 
 #include <cstdio>
 
 #include <string>
 
 #include "oct-time.h"
 
 extern int octave_read (char *buf, unsigned max_size);
-extern FILE *get_input_from_file (const string& name, int warn = 1);
+extern FILE *get_input_from_file (const std::string& name, int warn = 1);
 extern FILE *get_input_from_stdin (void);
 
 // Global pointer for eval().
-extern string current_eval_string;
+extern std::string current_eval_string;
 
 // TRUE means get input from current_eval_string.
 extern bool get_input_from_eval_string;
 
 // TRUE means we're parsing a function file.
 extern bool reading_fcn_file;
 
 // Simple name of function file we are reading.
-extern string curr_fcn_file_name;
+extern std::string curr_fcn_file_name;
 
 // Full name of file we are reading.
-extern string curr_fcn_file_full_name;
+extern std::string curr_fcn_file_full_name;
 
 // TRUE means we're parsing a script file.
 extern bool reading_script_file;
 
 // If we are reading from an M-file, this is it.
 extern FILE *ff_instream;
 
 // TRUE means this is an interactive shell.
@@ -61,26 +61,26 @@ extern bool interactive;
 
 // TRUE means the user forced this shell to be interactive (-i).
 extern bool forced_interactive;
 
 // Should we issue a prompt?
 extern int promptflag;
 
 // A line of input.
-extern string current_input_line;
+extern std::string current_input_line;
 
 // TRUE after a call to completion_matches().
 extern bool octave_completion_matches_called;
 
-extern string gnu_readline (const string& s, bool force_readline = false);
+extern std::string gnu_readline (const std::string& s, bool force_readline = false);
 
 extern void initialize_command_input (void);
 
-extern string Vps4;
+extern std::string Vps4;
 
 enum echo_state
 {
   ECHO_OFF = 0,
   ECHO_SCRIPTS = 1,
   ECHO_FUNCTIONS = 2,
   ECHO_CMD_LINE = 4
 };
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -166,30 +166,30 @@ static bool Vwarn_separator_insert = fal
 
 static bool Vwarn_single_quote_string = false;
 
 // Forward declarations for functions defined at the bottom of this
 // file.
 
 static void fixup_column_count (char *s);
 static void do_comma_insert_check (void);
-static int is_plot_keyword (const string& s);
-static int is_keyword (const string& s);
-static string plot_style_token (const string& s);
-static symbol_record *lookup_identifier (const string& s);
+static int is_plot_keyword (const std::string& s);
+static int is_keyword (const std::string& s);
+static std::string plot_style_token (const std::string& s);
+static symbol_record *lookup_identifier (const std::string& s);
 static void grab_help_text (void);
 static bool match_any (char c, const char *s);
 static bool next_token_is_sep_op (void);
 static bool next_token_is_bin_op (bool spc_prev);
 static bool next_token_is_postfix_unary_op (bool spc_prev);
-static string strip_trailing_whitespace (char *s);
+static std::string strip_trailing_whitespace (char *s);
 static void handle_number (void);
 static int handle_string (char delim, int text_style = 0);
 static int handle_close_bracket (int spc_gobbled);
-static int handle_identifier (const string& tok, int spc_gobbled);
+static int handle_identifier (const std::string& tok, int spc_gobbled);
 static bool have_continuation (bool trailing_comments_ok = true);
 static bool have_ellipsis_continuation (bool trailing_comments_ok = true);
 static yum_yum eat_whitespace (void);
 static yum_yum eat_continuation (void);
 static void maybe_warn_separator_insert (char sep);
 static void gripe_single_quote_string (void);
 
 %}
@@ -245,17 +245,17 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
   }
 
 <TEXT_FCN>[\"\'] {
     current_input_column++;
     return handle_string (yytext[0], true);
   }
 
 <TEXT_FCN>[^ \t\n\;\,\"\'][^ \t\n\;\,]*{S}* {
-    string tok = strip_trailing_whitespace (yytext);
+    std::string tok = strip_trailing_whitespace (yytext);
     TOK_PUSH_AND_RETURN (tok, TEXT);
   }
 
 %{
 // For this and the next two rules, we're looking at ']', and we
 // need to know if the next token is `=' or `=='.
 //
 // It would have been so much easier if the delimiters were simply
@@ -483,17 +483,17 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
   }
 
 %{
 // Identifiers.  Truncate the token at the first space or tab but
 // don't write directly on yytext.
 %}
 
 {IDENT}{S}* {
-    string tok = strip_trailing_whitespace (yytext);
+    std::string tok = strip_trailing_whitespace (yytext);
     int c = yytext[yyleng-1];
     int cont_is_spc = eat_continuation ();
     int spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
     return handle_identifier (tok, spc_gobbled);
   }
 
 %{
 // A new line character.  New line characters inside matrix constants
@@ -846,19 +846,19 @@ delete_input_buffer (void *buf)
 {
   delete_buffer (static_cast<YY_BUFFER_STATE> (buf));
 }
 
 // Check to see if a character string matches any of the possible line
 // styles for plots.
 
 static string
-plot_style_token (const string& s)
+plot_style_token (const std::string& s)
 {
-  string retval;
+  std::string retval;
 
   static const char *plot_styles[] = 
     {
       "boxes",
       "boxerrorbars",
       "boxxyerrorbars",
       "candlesticks",
       "dots",
@@ -892,19 +892,19 @@ plot_style_token (const string& s)
 
   return retval;
 }
 
 // Check to see if a character string matches any of the possible axes
 // tags for plots.
 
 static string
-plot_axes_token (const string& s)
+plot_axes_token (const std::string& s)
 {
-  string retval;
+  std::string retval;
 
   static char *plot_axes[] = 
     {
       "x1y1",
       "x1y2",
       "x2y1",
       "x2y2",
       0,
@@ -926,17 +926,17 @@ plot_axes_token (const string& s)
 }
 
 // Check to see if a character string matches any one of the plot
 // option keywords.  Don't match abbreviations for clear, since that's
 // not a gnuplot keyword (users will probably only expect to be able
 // to abbreviate actual gnuplot keywords).
 
 static int
-is_plot_keyword (const string& s)
+is_plot_keyword (const std::string& s)
 {
   const char *t = s.c_str ();
   if (almost_match ("title", t))
     {
       return TITLE;
     }
   else if (almost_match ("using", t))
     {
@@ -961,35 +961,35 @@ is_plot_keyword (const string& s)
     {
       return 0;
     }
 }
 
 // Handle keywords.
 
 static int
-is_keyword (const string& s)
+is_keyword (const std::string& s)
 {
   if (lexer_flags.plotting)
     {
       if (lexer_flags.in_plot_style)
 	{
-	  string sty = plot_style_token (s);
+	  std::string sty = plot_style_token (s);
 
 	  if (! sty.empty ())
 	    {
 	      lexer_flags.in_plot_style = false;
 	      yylval.tok_val = new token (sty);
 	      token_stack.push (yylval.tok_val);
 	      return STYLE;
 	    }
 	}
       else if (lexer_flags.in_plot_axes)
 	{
-	  string axes = plot_axes_token (s);
+	  std::string axes = plot_axes_token (s);
 
 	  if (! axes.empty ())
 	    {
 	      lexer_flags.in_plot_axes = false;
 	      yylval.tok_val = new token (axes);
 	      token_stack.push (yylval.tok_val);
 	      return AXES_TAG;
 	    }
@@ -1145,31 +1145,31 @@ is_keyword (const string& s)
 
   return 0;
 }
 
 // Try to find an identifier.  All binding to global or builtin
 // variables occurs when expressions are evaluated.
 
 static symbol_record *
-lookup_identifier (const string& name)
+lookup_identifier (const std::string& name)
 {
   return curr_sym_tab->lookup (name, true);
 }
 
 static bool
-is_variable (const string& name)
+is_variable (const std::string& name)
 {
   symbol_record *sr = curr_sym_tab->lookup (name);
 
   return sr && sr->is_variable ();
 }
 
 static void
-force_local_variable (const string& name)
+force_local_variable (const std::string& name)
 {
   symbol_record *sr = curr_sym_tab->lookup (name, true);
 
   if (sr)
     sr->define (octave_value ());
 }
 
 // Grab the help text from an function file.  Always overwrites the
@@ -1442,17 +1442,17 @@ next_token_is_bin_op (bool spc_prev)
   return bin_op;
 }
 
 // Used to delete trailing white space from tokens.
 
 static string
 strip_trailing_whitespace (char *s)
 {
-  string retval = s;
+  std::string retval = s;
 
   size_t pos = retval.find_first_of (" \t");
 
   if (pos != NPOS)
     retval.resize (pos);
 
   return retval;
 }
@@ -1587,17 +1587,17 @@ handle_number (void)
 // Match whitespace only, followed by a comment character or newline.
 // Once a comment character is found, discard all input until newline.
 // If non-whitespace characters are found before comment
 // characters, return 0.  Otherwise, return 1.
 
 static bool
 have_continuation (bool trailing_comments_ok)
 {
-  ostrstream buf;
+  std::ostrstream buf;
 
   bool in_comment = false;
   int c;
   while ((c = yyinput ()) != EOF)
     {
       buf << (char) c;
 
       switch (c)
@@ -1696,17 +1696,17 @@ eat_continuation (void)
     unput (c);
 
   return retval;
 }
 
 static int
 handle_string (char delim, int text_style)
 {
-  ostrstream buf;
+  std::ostrstream buf;
 
   int c;
   int escape_pending = 0;
 
   while ((c = yyinput ()) != EOF)
     {
       current_input_column++;
 
@@ -1748,22 +1748,22 @@ handle_string (char delim, int text_styl
 	      c = yyinput ();
 	      if (c == delim)
 		buf << (char) c;
 	      else
 		{
 		  unput (c);
 		  buf << ends;
 		  char *t = buf.str ();
-		  string s = do_string_escapes (t);
+		  std::string s = do_string_escapes (t);
 		  delete [] t;
 
 		  if (text_style && lexer_flags.doing_set)
 		    {
-		      s = string (1, delim) + s + string (1, delim);
+		      s = std::string (1, delim) + s + std::string (1, delim);
 		    }
 		  else
 		    {
 		      lexer_flags.quote_is_transpose = true;
 		      lexer_flags.cant_be_identifier = true;
 		      lexer_flags.convert_spaces_to_comma = true;
 		    }
 
@@ -1972,17 +1972,17 @@ maybe_unput_comma (int spc_gobbled)
 	}
     }
 }
 
 // Figure out exactly what kind of token to return when we have seen
 // an identifier.  Handles keywords.
 
 static int
-handle_identifier (const string& tok, int spc_gobbled)
+handle_identifier (const std::string& tok, int spc_gobbled)
 {
   // It is almost always an error for an identifier to be followed
   // directly by another identifier.  Special cases are handled
   // below.
 
   lexer_flags.cant_be_identifier = true;
 
   // If we are expecting a structure element, avoid recognizing
@@ -2228,33 +2228,33 @@ lexical_feedback::init (void)
 
   // Quote marks strings intially.
   quote_is_transpose = false;
 }
 
 static void
 maybe_warn_separator_insert (char sep)
 {
-  string nm = curr_fcn_file_full_name;
+  std::string nm = curr_fcn_file_full_name;
 
   if (Vwarn_separator_insert)
     {
       if (nm.empty ())
 	warning ("potential auto-insertion of `%c' near line %d",
 		 sep, input_line_number);
       else
 	warning ("potential auto-insertion of `%c' near line %d of file %s",
 		 sep, input_line_number, nm.c_str ());
     }
 }
 
 static void
 gripe_single_quote_string (void)
 {
-  string nm = curr_fcn_file_full_name;
+  std::string nm = curr_fcn_file_full_name;
 
   if (Vwarn_single_quote_string)
     {
       if (nm.empty ())
 	warning ("single quote delimited string near line %d",
 		 input_line_number);
       else
 	warning ("single quote delimited string near line %d of file %s",
@@ -2278,17 +2278,17 @@ warn_single_quote_string (void)
   return 0;
 }
 
 static int
 whitespace_in_literal_matrix (void)
 {
   int pref = 0;
 
-  string val = builtin_string_variable ("whitespace_in_literal_matrix");
+  std::string val = builtin_string_variable ("whitespace_in_literal_matrix");
 
   if (! val.empty ())
     {
       if (val.compare ("ignore", 0, 6) == 0)
 	pref = 2;
       else if (val.compare ("traditional", 0, 11) == 0)
 	pref = 1;
     }
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -58,17 +58,17 @@ Software Foundation, 59 Temple Place - S
 #include "variables.h"
 #include "version.h"
 
 // The number of decimal digits to use when writing ascii data.
 static bool Vcrash_dumps_octave_core;
 
 // The default output format.  May be one of "binary", "text", or
 // "mat-binary".
-static string Vdefault_save_format;
+static std::string Vdefault_save_format;
 
 // The number of decimal digits to use when writing ascii data.
 static int Vsave_precision;
 
 // Used when converting Inf to something that gnuplot can read.
 
 #ifndef OCT_RBV
 #define OCT_RBV DBL_MAX / 100.0
@@ -94,17 +94,17 @@ valid_identifier (const char *s)
   while (*++s != '\0')
     if (! (isalnum (*s) || *s == '_'))
       return false;
 
   return true;
 }
 
 static bool
-valid_identifier (const string& s)
+valid_identifier (const std::string& s)
 {
   return valid_identifier (s.c_str ());
 }
 
 // XXX FIXME XXX -- shouldn't this be implemented in terms of other
 // functions that are already available?
 
 // Install a variable with name NAME and the value specified TC in the
@@ -243,17 +243,17 @@ install_loaded_variable (int force, char
   return;
 }
 
 // Functions for reading ascii data.
 
 // Skip white space and comments on stream IS.
 
 static void
-skip_comments (istream& is)
+skip_comments (std::istream& is)
 {
   char c = '\0';
   while (is.get (c))
     {
       if (c == ' ' || c == '\t' || c == '\n')
 	; // Skip whitespace on way to beginning of next line.
       else
 	break;
@@ -272,26 +272,26 @@ skip_comments (istream& is)
 // Extract a KEYWORD and its value from stream IS, returning the
 // associated value in a new string.
 //
 // Input should look something like:
 //
 //  #[ \t]*keyword[ \t]*:[ \t]*string-value[ \t]*\n
 
 static char *
-extract_keyword (istream& is, const char *keyword)
+extract_keyword (std::istream& is, const char *keyword)
 {
   char *retval = 0;
 
   char c;
   while (is.get (c))
     {
       if (c == '#')
 	{
-	  ostrstream buf;
+	  std::ostrstream buf;
 	
 	  while (is.get (c) && (c == ' ' || c == '\t' || c == '#'))
 	    ; // Skip whitespace and comment characters.
 
 	  if (isalpha (c))
 	    buf << c;
 
 	  while (is.get (c) && isalpha (c))
@@ -299,17 +299,17 @@ extract_keyword (istream& is, const char
 
 	  buf << ends;
 	  char *tmp = buf.str ();
 	  int match = (strncmp (tmp, keyword, strlen (keyword)) == 0);
 	  delete [] tmp;
 
 	  if (match)
 	    {
-	      ostrstream value;
+	      std::ostrstream value;
 	      while (is.get (c) && (c == ' ' || c == '\t' || c == ':'))
 		; // Skip whitespace and the colon.
 
 	      if (c != '\n')
 		{
 		  value << c;
 		  while (is.get (c) && c != '\n')
 		    value << c;
@@ -339,27 +339,27 @@ extract_keyword (istream& is, const char
 // Match KEYWORD on stream IS, placing the associated value in VALUE,
 // returning TRUE if successful and FALSE otherwise.
 //
 // Input should look something like:
 //
 //  [ \t]*keyword[ \t]*int-value.*\n
 
 static bool
-extract_keyword (istream& is, const char *keyword, int& value)
+extract_keyword (std::istream& is, const char *keyword, int& value)
 {
   bool status = false;
   value = 0;
 
   char c;
   while (is.get (c))
     {
       if (c == '#')
 	{
-	  ostrstream buf;
+	  std::ostrstream buf;
 
 	  while (is.get (c) && (c == ' ' || c == '\t' || c == '#'))
 	    ; // Skip whitespace and comment characters.
 
 	  if (isalpha (c))
 	    buf << c;
 
 	  while (is.get (c) && isalpha (c))
@@ -463,17 +463,17 @@ extract_keyword (istream& is, const char
 //  string
 //  # length: 5
 //  array
 //
 // XXX FIXME XXX -- this format is fairly rigid, and doesn't allow for
 // arbitrary comments, etc.  Someone should fix that.
 
 static char *
-read_ascii_data (istream& is, const string& filename, bool& global,
+read_ascii_data (std::istream& is, const std::string& filename, bool& global,
 		 octave_value& tc, int count)
 {
   // Read name for this entry or break on EOF.
 
   char *name = extract_keyword (is, "name");
 
   if (! name)
     {
@@ -734,19 +734,19 @@ read_ascii_data (istream& is, const stri
 //
 //       for each element:
 //         length         int                 4
 //         data           string         length
 //
 // FILENAME is used for error messages.
 
 static char *
-read_binary_data (istream& is, bool swap,
+read_binary_data (std::istream& is, bool swap,
 		  oct_mach_info::float_format fmt,
-		  const string& filename, bool& global,
+		  const std::string& filename, bool& global,
 		  octave_value& tc, char *&doc)
 {
   char tmp = 0;
 
   FOUR_BYTE_INT name_len = 0;
   FOUR_BYTE_INT doc_len = 0;
   char *name = 0;
 
@@ -941,19 +941,19 @@ read_binary_data (istream& is, bool swap
       name = 0;
       break;
     }
 
   return name;
 }
 
 static string
-get_mat_data_input_line (istream& is)
+get_mat_data_input_line (std::istream& is)
 {
-  string retval;
+  std::string retval;
 
   bool have_data = false;
 
   do
     {
       retval = "";
 
       char c;
@@ -981,28 +981,28 @@ get_mat_data_input_line (istream& is)
 	}
     }
   while (! (have_data || is.eof ()));
 
   return retval;
 }
 
 static void
-get_lines_and_columns (istream& is, const string& filename, int& nr, int& nc)
+get_lines_and_columns (std::istream& is, const std::string& filename, int& nr, int& nc)
 {
   streampos pos = is.tellg ();
 
   int file_line_number = 0;
 
   nr = 0;
   nc = 0;
 
   while (is && ! error_state)
     {
-      string buf = get_mat_data_input_line (is);
+      std::string buf = get_mat_data_input_line (is);
 
       file_line_number++;
 
       size_t beg = buf.find_first_not_of (" \t");
 
       int tmp_nc = 0;
 
       while (beg != NPOS)
@@ -1046,22 +1046,22 @@ get_lines_and_columns (istream& is, cons
 // Reads the file twice.  Once to find the number of rows and columns,
 // and once to extract the matrix.
 //
 // FILENAME is used for error messages.
 //
 // This format provides no way to tag the data as global.
 
 static char *
-read_mat_ascii_data (istream& is, const string& filename,
+read_mat_ascii_data (std::istream& is, const std::string& filename,
 		     octave_value& tc)
 {
   char *name = 0;
 
-  string varname;
+  std::string varname;
 
   size_t pos = filename.rfind ('/');
 
   if (pos != NPOS)
     varname = filename.substr (pos+1);
   else
     varname = filename;
 
@@ -1083,19 +1083,19 @@ read_mat_ascii_data (istream& is, const 
 
 	  if (nr < 1 || nc < 1)
 	    is.clear (ios::badbit);
 	  else
 	    {
 	      double d;
 	      for (int i = 0; i < nr; i++)
 		{
-		  string buf = get_mat_data_input_line (is);
-
-		  istrstream tmp_stream (buf.c_str ());
+		  std::string buf = get_mat_data_input_line (is);
+
+		  std::istrstream tmp_stream (buf.c_str ());
 
 		  for (int j = 0; j < nc; j++)
 		    {
 		      tmp_stream >> d;
 
 		      if (tmp_stream)
 			tmp.elem (i, j) = d;
 		      else
@@ -1133,17 +1133,17 @@ read_mat_ascii_data (istream& is, const 
 
 // Read LEN elements of data from IS in the format specified by
 // PRECISION, placing the result in DATA.  If SWAP is TRUE, swap
 // the bytes of each element before copying to DATA.  FLT_FMT
 // specifies the format of the data if we are reading floating point
 // numbers.
 
 static void
-read_mat_binary_data (istream& is, double *data, int precision,
+read_mat_binary_data (std::istream& is, double *data, int precision,
 		      int len, bool swap,
 		      oct_mach_info::float_format flt_fmt)
 {
   switch (precision)
     {
     case 0:
       read_doubles (is, data, LS_DOUBLE, len, swap, flt_fmt);
       break;
@@ -1169,17 +1169,17 @@ read_mat_binary_data (istream& is, doubl
       break;
 
     default:
       break;
     }
 }
 
 static int
-read_mat_file_header (istream& is, bool& swap, FOUR_BYTE_INT& mopt, 
+read_mat_file_header (std::istream& is, bool& swap, FOUR_BYTE_INT& mopt, 
 		      FOUR_BYTE_INT& nr, FOUR_BYTE_INT& nc,
 		      FOUR_BYTE_INT& imag, FOUR_BYTE_INT& len,
 		      int quiet = 0)
 {
   swap = false;
 
   // We expect to fail here, at the beginning of a record, so not
   // being able to read another mopt value should not result in an
@@ -1318,17 +1318,17 @@ float_format_to_mopt_digit (oct_mach_inf
 // The data is expected to be in Matlab's .mat format, though not all
 // the features of that format are supported.
 //
 // FILENAME is used for error messages.
 //
 // This format provides no way to tag the data as global.
 
 static char *
-read_mat_binary_data (istream& is, const string& filename,
+read_mat_binary_data (std::istream& is, const std::string& filename,
 		      octave_value& tc)
 {
   // These are initialized here instead of closer to where they are
   // first used to avoid errors from gcc about goto crossing
   // initialization of variable.
 
   Matrix re;
   oct_mach_info::float_format flt_fmt = oct_mach_info::unknown;
@@ -1442,30 +1442,30 @@ read_mat_binary_data (istream& is, const
   delete [] name;
   return 0;
 }
 
 // Return TRUE if NAME matches one of the given globbing PATTERNS.
 
 static bool
 matches_patterns (const string_vector& patterns, int pat_idx,
-		  int num_pat, const string& name)
+		  int num_pat, const std::string& name)
 {
   for (int i = pat_idx; i < num_pat; i++)
     {
       glob_match pattern (patterns[i]);
 
       if (pattern.match (name))
 	return true;
     }
   return false;
 }
 
 static int
-read_binary_file_header (istream& is, bool& swap,
+read_binary_file_header (std::istream& is, bool& swap,
 			 oct_mach_info::float_format& flt_fmt,
 			 bool quiet = false)
 {
   int magic_len = 10;
   char magic [magic_len+1];
   is.read (magic, magic_len);
   magic[magic_len] = '\0';
   if (strncmp (magic, "Octave-1-L", magic_len) == 0)
@@ -1490,21 +1490,21 @@ read_binary_file_header (istream& is, bo
         error ("load: unrecognized binary format!");
       return -1;
     }
 
   return 0;
 }
 
 static load_save_format
-get_file_format (const string& fname, const string& orig_fname)
+get_file_format (const std::string& fname, const std::string& orig_fname)
 {
   load_save_format retval = LS_UNKNOWN;
 
-  ifstream file (fname.c_str ());
+  std::ifstream file (fname.c_str ());
 
   if (! file)
     {
       error ("load: couldn't open input file `%s'", orig_fname.c_str ());
       return retval;
     }
 
   oct_mach_info::float_format flt_fmt = oct_mach_info::unknown;
@@ -1555,24 +1555,24 @@ get_file_format (const string& fname, co
   if (retval == LS_UNKNOWN)
     error ("load: unable to determine file format for `%s'",
 	   orig_fname.c_str ());
 
   return retval;
 }
 
 static octave_value_list
-do_load (istream& stream, const string& orig_fname, bool force,
+do_load (std::istream& stream, const std::string& orig_fname, bool force,
 	 load_save_format format, oct_mach_info::float_format flt_fmt,
 	 bool list_only, bool swap, bool verbose, const string_vector& argv,
 	 int argv_idx, int argc, int nargout)
 {
   octave_value_list retval;
 
-  ostrstream output_buf;
+  std::ostrstream output_buf;
   int count = 0;
   for (;;)
     {
       bool global = false;
       octave_value tc;
 
       char *name = 0;
       char *doc = 0;
@@ -1785,17 +1785,17 @@ Force Octave to assume the file is in @s
     }
 
   if (i == argc)
     {
       print_usage ("load");
       return retval;
     }
 
-  string orig_fname = argv[i];
+  std::string orig_fname = argv[i];
 
   oct_mach_info::float_format flt_fmt = oct_mach_info::unknown;
 
   bool swap = false;
 
   if (argv[i] == "-")
     {
       i++;
@@ -1811,30 +1811,30 @@ Force Octave to assume the file is in @s
 			    list_only, swap, verbose, argv, i, argc,
 			    nargout);
 	}
       else
 	error ("load: must specify file format if reading from stdin");
     }
   else
     {
-      string fname = file_ops::tilde_expand (argv[i]);
+      std::string fname = file_ops::tilde_expand (argv[i]);
 
       if (format == LS_UNKNOWN)
 	format = get_file_format (fname, orig_fname);
 
       if (format != LS_UNKNOWN)
 	{
 	  i++;
 
 	  unsigned mode = ios::in;
 	  if (format == LS_BINARY || format == LS_MAT_BINARY)
 	    mode |= ios::bin;
 
-	  ifstream file (fname.c_str (), mode);
+	  std::ifstream file (fname.c_str (), mode);
 
 	  if (file)
 	    {
 	      if (format == LS_BINARY)
 		{
 		  if (read_binary_file_header (file, swap, flt_fmt) < 0)
 		    {
 		      file.close ();
@@ -1855,17 +1855,17 @@ Force Octave to assume the file is in @s
     }
 
   return retval;
 }
 
 // Return TRUE if PATTERN has any special globbing chars in it.
 
 static bool
-glob_pattern_p (const string& pattern)
+glob_pattern_p (const std::string& pattern)
 {
   int open = 0;
 
   int len = pattern.length ();
 
   for (int i = 0; i < len; i++)
     {
       char c = pattern[i];
@@ -1921,18 +1921,18 @@ get_save_type (double max_val, double mi
   return st;
 }
 
 // Save the data from TC along with the corresponding NAME, help
 // string DOC, and global flag MARK_AS_GLOBAL on stream OS in the
 // binary format described above for read_binary_data.
 
 static bool
-save_binary_data (ostream& os, const octave_value& tc,
-		  const string& name, const string& doc,
+save_binary_data (std::ostream& os, const octave_value& tc,
+		  const std::string& name, const std::string& doc,
 		  bool mark_as_global, bool save_as_floats) 
 {
   FOUR_BYTE_INT name_len = name.length ();
 
   os.write (&name_len, 4);
   os << name;
 
   FOUR_BYTE_INT doc_len = doc.length ();
@@ -1951,17 +1951,17 @@ save_binary_data (ostream& os, const oct
       os.write (&tmp, 1);
       FOUR_BYTE_INT nr = tc.rows ();
       os.write (&nr, 4);
       charMatrix chm = tc.char_matrix_value ();
       for (int i = 0; i < nr; i++)
 	{
 	  FOUR_BYTE_INT len = chm.cols ();
 	  os.write (&len, 4);
-	  string tstr = chm.row_as_string (i);
+	  std::string tstr = chm.row_as_string (i);
 	  const char *tmp = tstr.data ();
 	  os.write (tmp, len);
 	}
     }
   else if (tc.is_range ())
     {
       tmp = 6;
       os.write (&tmp, 1);
@@ -2058,18 +2058,18 @@ save_binary_data (ostream& os, const oct
 
   return os;
 }
 
 // Save the data from TC along with the corresponding NAME on stream OS 
 // in the MatLab binary format.
 
 static bool
-save_mat_binary_data (ostream& os, const octave_value& tc,
-		      const string& name) 
+save_mat_binary_data (std::ostream& os, const octave_value& tc,
+		      const std::string& name) 
 {
   FOUR_BYTE_INT mopt = 0;
 
   mopt += tc.is_string () ? 1 : 0;
 
   oct_mach_info::float_format flt_fmt =
     oct_mach_info::native_float_format ();;
 
@@ -2142,17 +2142,17 @@ save_mat_binary_data (ostream& os, const
     }
   else
     gripe_wrong_type_arg ("save", tc, false);
 
   return os;
 }
 
 static void
-ascii_save_type (ostream& os, const char *type, bool mark_as_global)
+ascii_save_type (std::ostream& os, const char *type, bool mark_as_global)
 {
   if (mark_as_global)
     os << "# type: global ";
   else
     os << "# type: ";
 
   os << type << "\n";
 }
@@ -2238,18 +2238,18 @@ strip_infnan (const ComplexMatrix& m)
 //
 // Assumes ranges and strings cannot contain Inf or NaN values.
 //
 // Returns 1 for success and 0 for failure.
 
 // XXX FIXME XXX -- should probably write the help string here too.
 
 bool
-save_ascii_data (ostream& os, const octave_value& tc,
-		 const string& name, bool strip_nan_and_inf,
+save_ascii_data (std::ostream& os, const octave_value& tc,
+		 const std::string& name, bool strip_nan_and_inf,
 		 bool mark_as_global, int precision) 
 {
   bool success = true;
 
   if (! precision)
     precision = Vsave_precision;
 
   if (! name.empty ())
@@ -2263,17 +2263,17 @@ save_ascii_data (ostream& os, const octa
       ascii_save_type (os, "string array", mark_as_global);
       charMatrix chm = tc.char_matrix_value ();
       int elements = chm.rows ();
       os << "# elements: " << elements << "\n";
       for (int i = 0; i < elements; i++)
 	{
 	  int len = chm.cols ();
 	  os << "# length: " << len << "\n";
-	  string tstr = chm.row_as_string (i);
+	  std::string tstr = chm.row_as_string (i);
 	  const char *tmp = tstr.data ();
 	  os.write (tmp, len);
 	  os << "\n";
 	}
     }
   else if (tc.is_range ())
     {
       ascii_save_type (os, "range", mark_as_global);
@@ -2362,27 +2362,27 @@ save_ascii_data (ostream& os, const octa
   os.precision (old_precision);
 
   return (os && success);
 }
 
 // Save the info from sr on stream os in the format specified by fmt.
 
 static void
-do_save (ostream& os, symbol_record *sr, load_save_format fmt,
+do_save (std::ostream& os, symbol_record *sr, load_save_format fmt,
 	 int save_as_floats)
 {
   if (! sr->is_variable ())
     {
       error ("save: can only save variables, not functions");
       return;
     }
 
-  string name = sr->name ();
-  string help = sr->help ();
+  std::string name = sr->name ();
+  std::string help = sr->help ();
   int global = sr->is_linked_to_global ();
 
   octave_value tc = sr->def ();
 
   if (tc.is_undefined ())
     return;
 
   switch (fmt)
@@ -2405,17 +2405,17 @@ do_save (ostream& os, symbol_record *sr,
     }
 }
 
 // Save variables with names matching PATTERN on stream OS in the
 // format specified by FMT.  If SAVE_BUILTINS is TRUE, also save
 // builtin variables with names that match PATTERN.
 
 static int
-save_vars (ostream& os, const string& pattern, bool save_builtins,
+save_vars (std::ostream& os, const std::string& pattern, bool save_builtins,
 	   load_save_format fmt, int save_as_floats)
 {
   Array<symbol_record *> vars = curr_sym_tab->glob
     (pattern, symbol_record::USER_VARIABLE, SYMTAB_ALL_SCOPES);
 
   int saved = vars.length ();
 
   for (int i = 0; i < saved; i++)
@@ -2447,28 +2447,28 @@ save_vars (ostream& os, const string& pa
   return saved;
 }
 
 static load_save_format
 get_default_save_format (void)
 {
   load_save_format retval = LS_ASCII;
 
-  string fmt = Vdefault_save_format;
+  std::string fmt = Vdefault_save_format;
 
   if (fmt == "binary")
     retval = LS_BINARY;
   else if (fmt == "mat-binary" || fmt =="mat_binary")
     retval = LS_MAT_BINARY;
       
   return retval;
 }
 
 static void
-write_header (ostream& os, load_save_format format)
+write_header (std::ostream& os, load_save_format format)
 {
   switch (format)
     {
     case LS_BINARY:
       {
 	os << (oct_mach_info::words_big_endian ()
 	       ? "Octave-1-B" : "Octave-1-L");
 
@@ -2479,17 +2479,17 @@ write_header (ostream& os, load_save_for
 
 	os.write (&tmp, 1);
       }
     break;
 
     case LS_ASCII:
       {
 	octave_gmtime now;
-	string time_string = now.asctime ();
+	std::string time_string = now.asctime ();
 	time_string = time_string.substr (0, time_string.length () - 1);
 
 	os << "# Created by Octave " OCTAVE_VERSION ", "
 	   << time_string
 	   << " <"
 	   << octave_env::get_user_name ()
 	   << "@"
 	   << octave_env::get_host_name ()
@@ -2499,17 +2499,17 @@ write_header (ostream& os, load_save_for
 
     default:
       break;
     }
 }
 
 static void
 save_vars (const string_vector& argv, int argv_idx, int argc,
-	   ostream& os, bool save_builtins, load_save_format fmt,
+	   std::ostream& os, bool save_builtins, load_save_format fmt,
 	   bool save_as_floats, bool write_header_info)
 {
   if (write_header_info)
     write_header (os, fmt);
 
   if (argv_idx == argc)
     {
       save_vars (os, "*", save_builtins, fmt, save_as_floats);
@@ -2538,17 +2538,17 @@ save_user_variables (void)
       message (0, "attempting to save variables to `%s'...", fname);
 
       load_save_format format = get_default_save_format ();
 
       unsigned mode = ios::out|ios::trunc;
       if (format == LS_BINARY || format == LS_MAT_BINARY)
 	mode |= ios::bin;
 
-      ofstream file (fname, mode);
+      std::ofstream file (fname, mode);
 
       if (file)
 	{
 	  save_vars (string_vector (), 0, 0, file, false, format, false, true);
 	  message (0, "save to `%s' complete", fname);
 	}
       else
 	warning ("unable to open `%s' for writing...", fname);
@@ -2697,27 +2697,27 @@ the file @file{data} in Octave's binary 
 
   else if (i == argc - 1 && glob_pattern_p (argv[i]))
     {
       print_usage ("save");
       return retval;
     }
   else
     {
-      string fname = file_ops::tilde_expand (argv[i]);
+      std::string fname = file_ops::tilde_expand (argv[i]);
 
       i++;
 
       unsigned mode = ios::out;
       if (format == LS_BINARY || format == LS_MAT_BINARY)
 	mode |= ios::bin;
 
       mode |= append ? ios::ate : ios::trunc;
 
-      ofstream file (fname.c_str (), mode);
+      std::ofstream file (fname.c_str (), mode);
 
       if (file)
 	{
 	  bool write_header_info
 	    = ((file.rdbuf ())->seekoff (0, ios::cur) == 0);
 
 	  save_vars (argv, i, argc, file, save_builtins, format,
 		     save_as_floats, write_header_info);
@@ -2734,17 +2734,17 @@ the file @file{data} in Octave's binary 
 
 // Maybe this should be a static function in tree-plot.cc?
 
 // If TC is matrix, save it on stream OS in a format useful for
 // making a 3-dimensional plot with gnuplot.  If PARAMETRIC is
 // TRUE, assume a parametric 3-dimensional plot will be generated.
 
 bool
-save_three_d (ostream& os, const octave_value& tc, bool parametric)
+save_three_d (std::ostream& os, const octave_value& tc, bool parametric)
 {
   bool fail = false;
 
   int nr = tc.rows ();
   int nc = tc.columns ();
 
   if (tc.is_real_matrix ())
     {
@@ -2801,17 +2801,17 @@ crash_dumps_octave_core (void)
 }
 
 
 static int
 default_save_format (void)
 {
   int status = 0;
 
-  string s = builtin_string_variable ("default_save_format");
+  std::string s = builtin_string_variable ("default_save_format");
 
   if (s.empty ())
     {
       gripe_invalid_value_specified ("default_save_format");
       status = -1;
     }
   else
     Vdefault_save_format = s;
diff --git a/src/load-save.h b/src/load-save.h
--- a/src/load-save.h
+++ b/src/load-save.h
@@ -24,23 +24,23 @@ Software Foundation, 59 Temple Place - S
 #define octave_load_save_h 1
 
 #include <iostream>
 
 #include <string>
 
 class octave_value;
 
-extern bool save_ascii_data (ostream& os, const octave_value& t,
-			     const string& name = string (),
+extern bool save_ascii_data (std::ostream& os, const octave_value& t,
+			     const std::string& name = std::string (),
 			     bool strip_nan_and_inf = false,
 			     bool mark_as_global = false,
 			     int precision = 0);
 
-extern bool save_three_d (ostream& os, const octave_value& t,
+extern bool save_three_d (std::ostream& os, const octave_value& t,
 			  bool parametric = false);
 
 extern void save_user_variables (void);
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/src/oct-fstrm.cc b/src/oct-fstrm.cc
--- a/src/oct-fstrm.cc
+++ b/src/oct-fstrm.cc
@@ -26,23 +26,23 @@ Software Foundation, 59 Temple Place - S
 
 #include <cerrno>
 #include <cstring>
 
 #include "error.h"
 #include "oct-fstrm.h"
 
 octave_stream
-octave_fstream::create (const string& nm_arg, ios::openmode md,
+octave_fstream::create (const std::string& nm_arg, ios::openmode md,
 			oct_mach_info::float_format flt_fmt)
 {
   return octave_stream (new octave_fstream (nm_arg, md, flt_fmt));
 }
 
-octave_fstream::octave_fstream (const string& nm_arg,
+octave_fstream::octave_fstream (const std::string& nm_arg,
 				ios::openmode md = ios::in|ios::out,
 				oct_mach_info::float_format flt_fmt)
   : octave_base_stream (md, flt_fmt), nm (nm_arg)
 {
   // Override default protection of 0664 so that umask will appear to
   // do the right thing.
 
   fs.open (nm.c_str (), md, 0666);
@@ -93,31 +93,31 @@ octave_fstream::tell (void) const
 // Return non-zero if EOF has been reached on this stream.
 
 bool
 octave_fstream::eof (void) const
 {
   return fs.eof ();
 }
 
-istream *
+std::istream *
 octave_fstream::input_stream (void)
 {
-  istream *retval = 0;
+  std::istream *retval = 0;
 
   if (mode () & ios::in)
     retval = &fs;
 
   return retval;
 }
 
-ostream *
+std::ostream *
 octave_fstream::output_stream (void)
 {
-  ostream *retval = 0;
+  std::ostream *retval = 0;
 
   if (mode () & ios::out)
     retval = &fs;
 
   return retval;
 }
 
 /*
diff --git a/src/oct-fstrm.h b/src/oct-fstrm.h
--- a/src/oct-fstrm.h
+++ b/src/oct-fstrm.h
@@ -27,52 +27,52 @@ Software Foundation, 59 Temple Place - S
 
 #include "oct-stream.h"
 
 class
 octave_fstream : public octave_base_stream
 {
 public:
 
-  octave_fstream (const string& nm_arg,
+  octave_fstream (const std::string& nm_arg,
 		  ios::openmode md = ios::in|ios::out,
 		  oct_mach_info::float_format flt_fmt =
 		  oct_mach_info::native);
 
   static octave_stream
-  create (const string& nm_arg, ios::openmode md = ios::in|ios::out,
+  create (const std::string& nm_arg, ios::openmode md = ios::in|ios::out,
 	  oct_mach_info::float_format flt_fmt = oct_mach_info::native);
 
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (streamoff offset, ios::seek_dir origin);
 
   // Return current stream position.
 
   long tell (void) const;
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
   // The name of the file.
 
-  string name (void) const { return nm; }
+  std::string name (void) const { return nm; }
 
-  istream *input_stream (void);
+  std::istream *input_stream (void);
 
-  ostream *output_stream (void);
+  std::ostream *output_stream (void);
 
 protected:
 
   ~octave_fstream (void) { }
 
 private:
 
-  string nm;
+  std::string nm;
 
   fstream fs;
 
   // No copying!
 
   octave_fstream (const octave_fstream&);
 
   octave_fstream& operator = (const octave_fstream&);
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -71,66 +71,66 @@ Software Foundation, Inc.
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // TRUE means input is coming from temporary history file.
 bool input_from_tmp_history_file = false;
 
 // Where history is saved.
-static string Vhistory_file;
+static std::string Vhistory_file;
 
 // The number of lines to keep in the history file.
 static int Vhistory_size;
 
 // TRUE if we are saving history.
 bool Vsaving_history = true;
 
 // Get some default values, possibly reading them from the
 // environment.
 
 int
 default_history_size (void)
 {
   int size = 1024;
 
-  string env_size = octave_env::getenv ("OCTAVE_HISTSIZE");
+  std::string env_size = octave_env::getenv ("OCTAVE_HISTSIZE");
 
   if (! env_size.empty ())
     {
       int val;
 
       if (sscanf (env_size.c_str (), "%d", &val) == 1)
 	size = val > 0 ? val : 0;
     }
 
   return size;
 }
 
 string
 default_history_file (void)
 {
-  string file;
+  std::string file;
 
-  string env_file = octave_env::getenv ("OCTAVE_HISTFILE");
+  std::string env_file = octave_env::getenv ("OCTAVE_HISTFILE");
 
   if (! env_file.empty ())
     {
       fstream f (env_file.c_str (), (ios::in | ios::out));
 
       if (f)
 	{
 	  file = env_file;
 	  f.close ();
 	}
     }
 
   if (file.empty ())
     {
-      string home_dir = octave_env::get_home_directory ();
+      std::string home_dir = octave_env::get_home_directory ();
 
       if (! home_dir.empty ())
 	{
 	  file = home_dir;
 	  file.append ("/.octave_hist");
 	}
       else
 	file = ".octave_hist";
@@ -148,24 +148,24 @@ default_history_file (void)
 static void
 do_history (int argc, const string_vector& argv)
 {
   int numbered_output = 1;
 
   int i;
   for (i = 1; i < argc; i++)
     {
-      string option = argv[i];
+      std::string option = argv[i];
 
       if (option == "-r" || option == "-w" || option == "-a"
 	  || option == "-n")
 	{
 	  if (i < argc - 1)
 	    {
-	      string file = file_ops::tilde_expand (argv[i+1]);
+	      std::string file = file_ops::tilde_expand (argv[i+1]);
 	      command_history::set_file (file);
 	    }
 
 	  if (option == "-a")
 	    // Append `new' lines to file.
 	    command_history::append ();
 
 	  else if (option == "-w")
@@ -278,68 +278,68 @@ edit_history_readline (fstream& stream)
 
 // Use `command' to replace the last entry in the history list, which,
 // by this time, is `run_history blah...'.  The intent is that the
 // new command becomes the history entry, and that `fc' should never
 // appear in the history list.  This way you can do `run_history' to
 // your heart's content.
 
 static void
-edit_history_repl_hist (const string& command)
+edit_history_repl_hist (const std::string& command)
 {
   if (! command.empty ())
     {
       string_vector hlist = command_history::list ();
 
       int len = hlist.length ();
 
       if (len > 0)
 	{
 	  int i = len - 1;
 
-	  string histent = command_history::get_entry (i);
+	  std::string histent = command_history::get_entry (i);
 
 	  if (! histent.empty ())
 	    {
-	      string cmd = command;
+	      std::string cmd = command;
 
 	      int cmd_len = cmd.length ();
 
 	      if (cmd[cmd_len - 1] == '\n')
 		cmd.resize (cmd_len - 1);
 
 	      if (! cmd.empty ())
 		command_history::replace_entry (i, cmd);
 	    }
 	}
     }
 }
 
 static void
-edit_history_add_hist (const string& line)
+edit_history_add_hist (const std::string& line)
 {
   if (! line.empty ())
     {
-      string tmp = line;
+      std::string tmp = line;
 
       int len = tmp.length ();
 	
       if (len > 0 && tmp[len-1] == '\n')
 	tmp.resize (len - 1);
 
       if (! tmp.empty ())
 	command_history::add (tmp);
     }
 }
 
 static string
 mk_tmp_hist_file (int argc, const string_vector& argv,
 		  int insert_curr, const char *warn_for) 
 {
-  string retval;
+  std::string retval;
 
   string_vector hlist = command_history::list ();
 
   int hist_count = hlist.length ();
 
   // The current command line is already part of the history list by
   // the time we get to this point.  Delete it from the list.
 
@@ -398,17 +398,17 @@ mk_tmp_hist_file (int argc, const string
   if (hist_end < hist_beg)
     {
       int t = hist_end;
       hist_end = hist_beg;
       hist_beg = t;
       reverse = 1;
     }
 
-  string name = file_ops::tempnam ("", "oct-");
+  std::string name = file_ops::tempnam ("", "oct-");
 
   fstream file (name.c_str (), ios::out);
 
   if (! file)
     {
       error ("%s: couldn't open temporary file `%s'", warn_for,
 	     name.c_str ());
       return retval;
@@ -428,24 +428,24 @@ mk_tmp_hist_file (int argc, const string
   file.close ();
 
   return name;
 }
 
 static void
 do_edit_history (int argc, const string_vector& argv)
 {
-  string name = mk_tmp_hist_file (argc, argv, 0, "edit_history");
+  std::string name = mk_tmp_hist_file (argc, argv, 0, "edit_history");
 
   if (name.empty ())
     return;
 
   // Call up our favorite editor on the file of commands.
 
-  string cmd = Veditor;
+  std::string cmd = Veditor;
   cmd.append (" ");
   cmd.append (name);
 
   // Ignore interrupts while we are off editing commands.  Should we
   // maybe avoid using system()?
 
   volatile octave_interrupt_handler old_interrupt_handler
     = octave_ignore_interrupts ();
@@ -501,17 +501,17 @@ do_edit_history (int argc, const string_
   // unwind_protect.
 
   unlink (name.c_str ());
 }
 
 static void
 do_run_history (int argc, const string_vector& argv)
 {
-  string name = mk_tmp_hist_file (argc, argv, 1, "run_history");
+  std::string name = mk_tmp_hist_file (argc, argv, 1, "run_history");
 
   if (name.empty ())
     return;
 
   // Turn on command echo so the output from this will make better
   // sense.
 
   unwind_protect::begin_frame ("do_run_history");
@@ -666,17 +666,17 @@ history_size (void)
   return -1;
 }
 
 static int
 history_file (void)
 {
   int status = 0;
 
-  string s = builtin_string_variable ("history_file");
+  std::string s = builtin_string_variable ("history_file");
 
   if (s.empty ())
     {
       gripe_invalid_value_specified ("history_file");
       status = -1;
     }
   else
     {
diff --git a/src/oct-hist.h b/src/oct-hist.h
--- a/src/oct-hist.h
+++ b/src/oct-hist.h
@@ -23,17 +23,17 @@ Software Foundation, 59 Temple Place - S
 #if !defined (octave_octave_hist_h)
 #define octave_octave_hist_h 1
 
 #include <string>
 
 #include "cmd-hist.h"
 
 extern int default_history_size (void);
-extern string default_history_file (void);
+extern std::string default_history_file (void);
 
 // TRUE means input is coming from temporary history file.
 extern bool input_from_tmp_history_file;
 
 // TRUE if we are saving history.
 extern bool Vsaving_history;
 
 #endif
diff --git a/src/oct-iostrm.cc b/src/oct-iostrm.cc
--- a/src/oct-iostrm.cc
+++ b/src/oct-iostrm.cc
@@ -64,31 +64,31 @@ octave_base_iostream::invalid_operation 
 
 bool
 octave_istream::eof (void) const
 {
   return is && is->eof ();
 }
 
 octave_stream
-octave_istream::create (istream *arg, const string& nm)
+octave_istream::create (std::istream *arg, const std::string& nm)
 {
   return octave_stream (new octave_istream (arg, nm));
 }
 
 // Return non-zero if EOF has been reached on this stream.
 
 bool
 octave_ostream::eof (void) const
 {
   return os && os->eof ();
 }
 
 octave_stream
-octave_ostream::create (ostream *arg, const string& nm)
+octave_ostream::create (std::ostream *arg, const std::string& nm)
 {
   return octave_stream (new octave_ostream (arg, nm));
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/oct-iostrm.h b/src/oct-iostrm.h
--- a/src/oct-iostrm.h
+++ b/src/oct-iostrm.h
@@ -27,17 +27,17 @@ Software Foundation, 59 Temple Place - S
 
 #include "oct-stream.h"
 
 class
 octave_base_iostream : public octave_base_stream
 {
 public:
 
-  octave_base_iostream (const string& n = string (),
+  octave_base_iostream (const std::string& n = std::string (),
 			ios::openmode md = ios::in|ios::out,
 			oct_mach_info::float_format flt_fmt =
 			oct_mach_info::native)
     : octave_base_stream (md, flt_fmt), nm (n) { }
 
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (streamoff offset, ios::seek_dir origin);
@@ -47,101 +47,101 @@ public:
   long tell (void) const;
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
   // The name of the file.
 
-  string name (void) const { return nm; }
+  std::string name (void) const { return nm; }
 
 protected:
 
   ~octave_base_iostream (void) { }
 
   void invalid_operation (void) const;
 
 private:
 
-  string nm;
+  std::string nm;
 
   virtual const char *stream_type (void) const = 0;
 
   // No copying!
 
   octave_base_iostream (const octave_base_iostream&);
 
   octave_base_iostream& operator = (const octave_base_iostream&);
 };
 
 class
 octave_istream : public octave_base_iostream
 {
 public:
 
-  octave_istream (istream *arg = 0, const string& nm = string ())
+  octave_istream (std::istream *arg = 0, const std::string& nm = std::string ())
     : octave_base_iostream (nm, ios::in, oct_mach_info::native),
       is (arg) { }
 
   static octave_stream
-  create (istream *arg = 0, const string& nm = string ());
+  create (std::istream *arg = 0, const std::string& nm = std::string ());
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
-  istream *input_stream (void) { return is; }
+  std::istream *input_stream (void) { return is; }
 
-  ostream *output_stream (void) { return 0; }
+  std::ostream *output_stream (void) { return 0; }
 
 protected:
 
   ~octave_istream (void) { }
 
 private:
 
-  istream *is;
+  std::istream *is;
 
   const char *stream_type (void) const { return "octave_istream"; }
 
   // No copying!
 
   octave_istream (const octave_istream&);
 
   octave_istream& operator = (const octave_istream&);
 };
 
 class
 octave_ostream : public octave_base_iostream
 {
 public:
 
-  octave_ostream (ostream *arg, const string& nm = string ())
+  octave_ostream (std::ostream *arg, const std::string& nm = std::string ())
     : octave_base_iostream (nm, ios::out, oct_mach_info::native),
       os (arg) { }
 
   static octave_stream
-  create (ostream *arg, const string& nm = string ());
+  create (std::ostream *arg, const std::string& nm = std::string ());
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
-  istream *input_stream (void) { return 0; }
+  std::istream *input_stream (void) { return 0; }
 
-  ostream *output_stream (void) { return os; }
+  std::ostream *output_stream (void) { return os; }
 
 protected:
 
   ~octave_ostream (void) { }
 
 private:
 
-  ostream *os;
+  std::ostream *os;
 
   const char *stream_type (void) const { return "octave_ostream"; }
 
   // No copying!
 
   octave_ostream (const octave_ostream&);
 
   octave_ostream& operator = (const octave_ostream&);
diff --git a/src/oct-lvalue.h b/src/oct-lvalue.h
--- a/src/oct-lvalue.h
+++ b/src/oct-lvalue.h
@@ -34,17 +34,17 @@ class octave_value_list;
 class
 octave_lvalue
 {
 public:
 
   octave_lvalue (octave_value *v = 0, symbol_record::change_function f = 0)
     : val (v), idx (), chg_fcn (f), struct_elt_name (), index_set (false) { }
 
-  octave_lvalue (octave_value *v, const string& nm,
+  octave_lvalue (octave_value *v, const std::string& nm,
 		 symbol_record::change_function f = 0)
     : val (v), idx (), chg_fcn (f), struct_elt_name (nm), index_set (false) { }
 
   octave_lvalue (const octave_lvalue& vr)
     : val (vr.val), idx (vr.idx), chg_fcn (vr.chg_fcn),
       struct_elt_name (vr.struct_elt_name), index_set (vr.index_set) { }
 
   octave_lvalue& operator = (const octave_lvalue& vr)
@@ -68,17 +68,17 @@ public:
   bool is_undefined (void) { return val->is_undefined (); }
 
   bool is_map (void) { return val->is_map (); }
 
   void define (const octave_value& v) { *val = v; }
 
   void assign (octave_value::assign_op, const octave_value&);
 
-  octave_lvalue struct_elt_ref (const string& nm)
+  octave_lvalue struct_elt_ref (const std::string& nm)
     {
       val->make_unique ();
       return val->struct_elt_ref (nm);
     }
 
   void set_index (const octave_value_list& i);
 
   void clear_index (void) { idx = octave_value_list (); }
@@ -99,17 +99,17 @@ public:
 private:
 
   octave_value *val;
 
   octave_value_list idx;
 
   symbol_record::change_function chg_fcn;
 
-  string struct_elt_name;
+  std::string struct_elt_name;
 
   bool index_set;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/src/oct-map.h b/src/oct-map.h
--- a/src/oct-map.h
+++ b/src/oct-map.h
@@ -34,17 +34,17 @@ Software Foundation, 59 Temple Place - S
 class string_vector;
 
 class
 Octave_map : public CHMap<octave_value>
 {
  public:
   Octave_map (void) : CHMap<octave_value> (octave_value ()) { }
 
-  Octave_map (const string& key, const octave_value& value)
+  Octave_map (const std::string& key, const octave_value& value)
     : CHMap<octave_value> (octave_value ())
       {
 	CHMap<octave_value>::operator [] (key) = value;
       }
 
   Octave_map (const Octave_map& m) : CHMap<octave_value> (m) { }
 
   ~Octave_map (void) { }
diff --git a/src/oct-obj.cc b/src/oct-obj.cc
--- a/src/oct-obj.cc
+++ b/src/oct-obj.cc
@@ -150,29 +150,29 @@ octave_value_list::all_strings_p (void) 
   for (int i = 0; i < n; i++)
     if (! elem(i).is_string ())
       return 0;
 
   return 1;
 }
 
 string_vector
-octave_value_list::make_argv (const string& fcn_name) const
+octave_value_list::make_argv (const std::string& fcn_name) const
 {
   string_vector argv;
 
   if (all_strings_p ())
     {
       int len = length ();
 
       int total_nr = 0;
 
       for (int i = 0; i < len; i++)
 	{
-	  // An empty string ("") has zero columns and zero rows (a
+	  // An empty std::string ("") has zero columns and zero rows (a
 	  // change that was made for Matlab contemptibility.
 
 	  int n = elem(i).rows ();
 
 	  total_nr += n ? n : 1;
 	}
 
       argv.resize (total_nr+1);
diff --git a/src/oct-obj.h b/src/oct-obj.h
--- a/src/oct-obj.h
+++ b/src/oct-obj.h
@@ -77,17 +77,17 @@ public:
     : data (1, octave_value (v)) { }
 
   octave_value_list (const ComplexColumnVector& v)
     : data (1, octave_value (v)) { }
 
   octave_value_list (const char *s)
     : data (1, octave_value (s)) { }
 
-  octave_value_list (const string& s)
+  octave_value_list (const std::string& s)
     : data (1, octave_value (s)) { }
 
   octave_value_list (const string_vector& s)
     : data (1, octave_value (s)) { }
 
   octave_value_list (double base, double limit, double inc)
     : data (1, octave_value (base, limit, inc)) { }
 
@@ -135,17 +135,17 @@ public:
 
   octave_value_list splice (int offset, int length,
 			    const octave_value_list& lst) const;
 
   octave_value_list index (idx_vector& i) const;
 
   bool all_strings_p (void) const;
 
-  string_vector make_argv (const string&) const;
+  string_vector make_argv (const std::string&) const;
 
   void stash_name_tags (const string_vector& nm) { names = nm; }
 
   string_vector name_tags (void) const { return names; }
 
 private:
 
   static octave_allocator allocator;
diff --git a/src/oct-prcstrm.cc b/src/oct-prcstrm.cc
--- a/src/oct-prcstrm.cc
+++ b/src/oct-prcstrm.cc
@@ -24,63 +24,63 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include <cstdio>
 
 #include "oct-prcstrm.h"
 
 octave_stream
-octave_iprocstream::create (const string& n, ios::openmode arg_md,
+octave_iprocstream::create (const std::string& n, ios::openmode arg_md,
 			    oct_mach_info::float_format flt_fmt)
 {
   return octave_stream (new octave_iprocstream (n, arg_md, flt_fmt));
 }
 
-octave_iprocstream::octave_iprocstream (const string& n,
+octave_iprocstream::octave_iprocstream (const std::string& n,
 					ios::openmode arg_md,
 					oct_mach_info::float_format flt_fmt)
   : octave_istdiostream (n, 0, arg_md, flt_fmt)
 {
   fp = popen (n.c_str (), "r");
 
   if (fp)
     {
       delete is;
-      is = new istdiostream (fp);
+      is = new std::istdiostream (fp);
     }
 }
 
 octave_iprocstream::~octave_iprocstream (void)
 {
   if (fp)
     {
       pclose (fp);
       fp = 0;
     }
 }
 
 octave_stream
-octave_oprocstream::create (const string& n, ios::openmode arg_md,
+octave_oprocstream::create (const std::string& n, ios::openmode arg_md,
 			    oct_mach_info::float_format flt_fmt)
 {
   return octave_stream (new octave_oprocstream (n, arg_md, flt_fmt));
 }
 
-octave_oprocstream::octave_oprocstream (const string& n,
+octave_oprocstream::octave_oprocstream (const std::string& n,
 					ios::openmode arg_md,
 					oct_mach_info::float_format flt_fmt)
   : octave_ostdiostream (n, 0, arg_md, flt_fmt)
 {
   fp = popen (n.c_str (), "w");
 
   if (fp)
     {
       delete os;
-      os = new ostdiostream (fp);
+      os = new std::ostdiostream (fp);
     }
 }
 
 octave_oprocstream::~octave_oprocstream (void)
 {
   if (fp)
     {
       pclose (fp);
diff --git a/src/oct-prcstrm.h b/src/oct-prcstrm.h
--- a/src/oct-prcstrm.h
+++ b/src/oct-prcstrm.h
@@ -25,23 +25,23 @@ Software Foundation, 59 Temple Place - S
 
 #include "oct-stdstrm.h"
 
 class
 octave_iprocstream : public octave_istdiostream
 {
 public:
 
-  octave_iprocstream (const string& n,
+  octave_iprocstream (const std::string& n,
 		      ios::openmode arg_md = ios::in,
 		      oct_mach_info::float_format flt_fmt =
 		      oct_mach_info::native);
 
   static octave_stream
-  create (const string& n, ios::openmode arg_md = ios::in,
+  create (const std::string& n, ios::openmode arg_md = ios::in,
 	  oct_mach_info::float_format flt_fmt = oct_mach_info::native);
 
 protected:
 
   ~octave_iprocstream (void);
 
 private:
 
@@ -52,23 +52,23 @@ private:
   octave_iprocstream& operator = (const octave_iprocstream&);
 };
 
 class
 octave_oprocstream : public octave_ostdiostream
 {
 public:
 
-  octave_oprocstream (const string& n,
+  octave_oprocstream (const std::string& n,
 		      ios::openmode arg_md = ios::out,
 		      oct_mach_info::float_format flt_fmt =
 		      oct_mach_info::native);
 
   static octave_stream
-  create (const string& n, ios::openmode arg_md = ios::out,
+  create (const std::string& n, ios::openmode arg_md = ios::out,
 	  oct_mach_info::float_format flt_fmt = oct_mach_info::native);
 
 protected:
 
   ~octave_oprocstream (void);
 
 private:
 
diff --git a/src/oct-stdstrm.cc b/src/oct-stdstrm.cc
--- a/src/oct-stdstrm.cc
+++ b/src/oct-stdstrm.cc
@@ -79,52 +79,52 @@ octave_base_stdiostream::tell (void) con
 	    retval = -1;
 	}
     }
 
   return retval;
 }
 
 octave_stream
-octave_istdiostream::create (const string& n, FILE *f,
+octave_istdiostream::create (const std::string& n, FILE *f,
 			     ios::openmode arg_md,
 			     oct_mach_info::float_format flt_fmt)
 {
   return octave_stream (new octave_istdiostream (n, f, arg_md, flt_fmt));
 }
 
-octave_istdiostream::octave_istdiostream (const string& n, FILE *f,
+octave_istdiostream::octave_istdiostream (const std::string& n, FILE *f,
 					  ios::openmode arg_md,
 					  oct_mach_info::float_format flt_fmt)
   : octave_base_stdiostream (n, f, arg_md, flt_fmt), is (0)
 {
   if (f)
-    is = new istdiostream (f);
+    is = new std::istdiostream (f);
 }
 
 octave_istdiostream::~octave_istdiostream (void)
 {
   delete is;
 }
 
 octave_stream
-octave_ostdiostream::create (const string& n, FILE *f,
+octave_ostdiostream::create (const std::string& n, FILE *f,
 			     ios::openmode arg_md,
 			     oct_mach_info::float_format flt_fmt)
 {
   return octave_stream (new octave_ostdiostream (n, f, arg_md, flt_fmt));
 }
 
-octave_ostdiostream::octave_ostdiostream (const string& n, FILE *f,
+octave_ostdiostream::octave_ostdiostream (const std::string& n, FILE *f,
 					  ios::openmode arg_md,
 					  oct_mach_info::float_format flt_fmt)
   : octave_base_stdiostream (n, f, arg_md, flt_fmt), os (0)
 {
   if (f)
-    os = new ostdiostream (f);
+    os = new std::ostdiostream (f);
 }
 
 octave_ostdiostream::~octave_ostdiostream (void)
 {
   delete os;
 }
 
 /*
diff --git a/src/oct-stdstrm.h b/src/oct-stdstrm.h
--- a/src/oct-stdstrm.h
+++ b/src/oct-stdstrm.h
@@ -27,43 +27,43 @@ Software Foundation, 59 Temple Place - S
 
 #include "oct-stream.h"
 
 class
 octave_base_stdiostream : public octave_base_stream
 {
 public:
 
-  octave_base_stdiostream (const string& n, FILE *f,
+  octave_base_stdiostream (const std::string& n, FILE *f,
 			   ios::openmode arg_md = ios::in|ios::out,
 			   oct_mach_info::float_format flt_fmt =
 			   oct_mach_info::native)
     : octave_base_stream (arg_md, flt_fmt), nm (n), fp (f) { }
 
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (streamoff offset, ios::seek_dir origin);
 
   // Return current stream position.
 
   long tell (void) const;
 
   // The name of the file.
 
-  string name (void) const { return nm; }
+  std::string name (void) const { return nm; }
 
   virtual stdiobuf *rdbuf (void) const = 0;
 
   virtual bool bad (void) const = 0;
 
   virtual void clear (void) = 0;
 
 protected:
 
-  string nm;
+  std::string nm;
 
   FILE *fp;
 
   ~octave_base_stdiostream (void);
 
   // No copying!
 
   octave_base_stdiostream (const octave_base_stdiostream&);
@@ -71,48 +71,48 @@ protected:
   octave_base_stdiostream& operator = (const octave_base_stdiostream&);
 };
 
 class
 octave_istdiostream : public octave_base_stdiostream
 {
 public:
 
-  octave_istdiostream (const string& n, FILE *f = 0,
+  octave_istdiostream (const std::string& n, FILE *f = 0,
 		       ios::openmode arg_md = ios::in,
 		       oct_mach_info::float_format flt_fmt =
 		       oct_mach_info::native);
 
   static octave_stream
-  create (const string& n, FILE *f = 0, ios::openmode arg_md = ios::in,
+  create (const std::string& n, FILE *f = 0, ios::openmode arg_md = ios::in,
 	  oct_mach_info::float_format flt_fmt = oct_mach_info::native);
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const { return is ? is->eof () : true; }
 
-  istream *input_stream (void) { return is; }
+  std::istream *input_stream (void) { return is; }
 
-  ostream *output_stream (void) { return 0; }
+  std::ostream *output_stream (void) { return 0; }
 
   // XXX FIXME XXX -- should not have to cast away const here.
   stdiobuf *rdbuf (void) const
-    { return is ? (const_cast<istdiostream *> (is))->rdbuf () : 0; }
+    { return is ? (const_cast<std::istdiostream *> (is))->rdbuf () : 0; }
 
   bool bad (void) const { return is ? is->bad () : true; }
 
   void clear (void)
     {
       if (is)
 	is->clear ();
     }
 
 protected:
 
-  istdiostream *is;
+  std::istdiostream *is;
 
   ~octave_istdiostream (void);
 
 private:
 
   // No copying!
 
   octave_istdiostream (const octave_istdiostream&);
@@ -120,48 +120,48 @@ private:
   octave_istdiostream& operator = (const octave_istdiostream&);
 };
 
 class
 octave_ostdiostream : public octave_base_stdiostream
 {
 public:
 
-  octave_ostdiostream (const string& n, FILE *f = 0,
+  octave_ostdiostream (const std::string& n, FILE *f = 0,
 		       ios::openmode arg_md = ios::out,
 		       oct_mach_info::float_format flt_fmt =
 		       oct_mach_info::native);
 
   static octave_stream
-  create (const string& n, FILE *f = 0, ios::openmode arg_md = ios::out,
+  create (const std::string& n, FILE *f = 0, ios::openmode arg_md = ios::out,
 	  oct_mach_info::float_format flt_fmt = oct_mach_info::native);
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const { return os ? os->eof () : true; }
 
-  istream *input_stream (void) { return 0; }
+  std::istream *input_stream (void) { return 0; }
 
-  ostream *output_stream (void) { return os; }
+  std::ostream *output_stream (void) { return os; }
 
   // XXX FIXME XXX -- should not have to cast away const here.
   stdiobuf *rdbuf (void) const
-    { return os ? (const_cast<ostdiostream *> (os))->rdbuf () : 0; }
+    { return os ? (const_cast<std::ostdiostream *> (os))->rdbuf () : 0; }
 
   bool bad (void) const { return os ? os->bad () : true; }
 
   void clear (void)
     {
       if (os)
 	os->clear ();
     }
 
 protected:
 
-  ostdiostream *os;
+  std::ostdiostream *os;
 
   ~octave_ostdiostream (void);
 
 private:
 
   // No copying!
 
   octave_ostdiostream (const octave_ostdiostream&);
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -147,17 +147,17 @@ get_size (const Matrix& size, int& nr, i
     {
       nr = get_size (dnr, warn_for);
 
       if (! error_state && dnc >= 0.0)
 	nc = get_size (dnc, warn_for);
     }
 }
 
-scanf_format_list::scanf_format_list (const string& s)
+scanf_format_list::scanf_format_list (const std::string& s)
   : nconv (0), curr_idx (0), list (16), buf (0)
 {
   int num_elts = 0;
 
   int n = s.length ();
 
   int i = 0;
 
@@ -168,17 +168,17 @@ scanf_format_list::scanf_format_list (co
 
   bool have_more = true;
 
   while (i < n)
     {
       have_more = true;
 
       if (! buf)
-	buf = new ostrstream ();
+	buf = new std::ostrstream ();
 
       if (s[i] == '%')
 	{
 	  // Process percent-escape conversion type.
 
 	  process_conversion (s, i, n, width, discard, type, modifier,
 			      num_elts);
 	  have_more = (buf != 0);
@@ -239,17 +239,17 @@ scanf_format_list::~scanf_format_list (v
       scanf_format_elt *elt = list(i);
       delete elt;
     }	
 }
 
 void
 scanf_format_list::add_elt_to_list (int width, bool discard, char type,
 				    char modifier, int& num_elts,
-				    const string& char_class)
+				    const std::string& char_class)
 {
   if (buf)
     {
       *buf << ends;
 
       char *text = buf->str ();
 
       if (text)
@@ -270,19 +270,19 @@ scanf_format_list::add_elt_to_list (int 
 	}
 
       delete buf;
       buf = 0;
     }
 }
 
 static string
-expand_char_class (const string& s)
+expand_char_class (const std::string& s)
 {
-  string retval;
+  std::string retval;
 
   size_t len = s.length ();
 
   size_t i = 0;
 
   while (i < len)
     {
       unsigned char c = s[i++];
@@ -305,17 +305,17 @@ expand_char_class (const string& s)
 	    retval += c;
 	}
     }
 
   return retval;
 }
 
 void
-scanf_format_list::process_conversion (const string& s, int& i, int n,
+scanf_format_list::process_conversion (const std::string& s, int& i, int n,
 				       int& width, bool& discard, char& type,
 				       char& modifier, int& num_elts)
 {
   width = 0;
   discard = false;
   modifier = '\0';
   type = '\0';
 
@@ -407,23 +407,23 @@ scanf_format_list::process_conversion (c
       if (nconv < 0)
 	break;
     }
 
   nconv = -1;
 }
 
 int
-scanf_format_list::finish_conversion (const string& s, int& i, int n,
+scanf_format_list::finish_conversion (const std::string& s, int& i, int n,
 				      int& width, bool discard, char& type,
 				      char modifier, int& num_elts)
 {
   int retval = 0;
 
-  string char_class;
+  std::string char_class;
 
   if (s[i] == '%')
     *buf << s[i++];
   else
     {
       int beg_idx = -1;
       int end_idx = -1;
 
@@ -567,17 +567,17 @@ scanf_format_list::all_numeric_conversio
       return true;
     }
   else
     return false;
 }
 
 // Ugh again.
 
-printf_format_list::printf_format_list (const string& s)
+printf_format_list::printf_format_list (const std::string& s)
   : nconv (0), curr_idx (0), list (16), buf (0)
 {
   int num_elts = 0;
 
   int n = s.length ();
 
   int i = 0;
 
@@ -587,17 +587,17 @@ printf_format_list::printf_format_list (
 
   bool have_more = true;
 
   while (i < n)
     {
       have_more = true;
 
       if (! buf)
-	buf = new ostrstream ();
+	buf = new std::ostrstream ();
 
       switch (s[i])
 	{
 	case '%':
 	  process_conversion (s, i, n, args, type, modifier, num_elts);
 	  have_more = (buf != 0);
 	  break;
 
@@ -662,17 +662,17 @@ printf_format_list::add_elt_to_list (int
 	}
 
       delete buf;
       buf = 0;
     }
 }
 
 void
-printf_format_list::process_conversion (const string& s, int& i, int n,
+printf_format_list::process_conversion (const std::string& s, int& i, int n,
 					int& args, char& modifier,
 					char& type, int& num_elts)
 {
   args = 0;
   modifier = '\0';
   type = '\0';
 
   *buf << s[i++];
@@ -745,17 +745,17 @@ printf_format_list::process_conversion (
 
   if (i < n)
     finish_conversion (s, i, args, modifier, type, num_elts);
   else
     nconv = -1;
 }
 
 void
-printf_format_list::finish_conversion (const string& s, int& i,
+printf_format_list::finish_conversion (const std::string& s, int& i,
 				       int args, char modifier,
 				       char& type, int& num_elts)
 
 {
   switch (s[i])
     {
     case 'd': case 'i': case 'o': case 'x': case 'X':
     case 'u': case 'c':
@@ -834,18 +834,18 @@ octave_base_stream::file_number (void)
   if (name () == "stdout")
     return 1;
 
   if (name () == "stderr")
     return 2;
 
   int retval = -1;
 
-  istream *is = input_stream ();
-  ostream *os = output_stream ();
+  std::istream *is = input_stream ();
+  std::ostream *os = output_stream ();
 
   int i_fid = is ? ((filebuf *) (is->rdbuf ()))->fd () : -1;
   int o_fid = os ? ((filebuf *) (os->rdbuf ()))->fd () : -1;
 
   if (i_fid >= 0)
     {
       if (o_fid >= 0)
 	retval = (i_fid == o_fid) ? i_fid : -1;
@@ -854,17 +854,17 @@ octave_base_stream::file_number (void)
     }
   else if (o_fid >= 0)
     retval = o_fid;
 
   return retval;
 }
 
 void
-octave_base_stream::error (const string& msg)
+octave_base_stream::error (const std::string& msg)
 {
   fail = true;
   errmsg = msg;
 }
 
 void
 octave_base_stream::clear (void)
 {
@@ -874,29 +874,29 @@ octave_base_stream::clear (void)
 
 // Functions that are defined for all input streams (input streams
 // are those that define is).
 
 string
 octave_base_stream::do_gets (int max_len, bool& err,
 			     bool strip_newline, const char *fcn)
 {
-  string retval;
+  std::string retval;
 
   err = false;
 
-  istream *isp = input_stream ();
+  std::istream *isp = input_stream ();
 
   if (isp)
     {
-      istream& is = *isp;
+      std::istream& is = *isp;
 
       // XXX FIXME XXX -- this should probably be converted to use
       // sstream when that is available.
-      ostrstream buf;
+      std::ostrstream buf;
 
       int c = 0;
       int count = 0;
       int newline_stripped = 0;
 
       while (is && (c = is.get ()) != EOF)
 	{
 	  count++;
@@ -915,24 +915,24 @@ octave_base_stream::do_gets (int max_len
 
 	  if (max_len > 0 && count == max_len)
 	    break;
 	}
 
       if (is.fail ())
 	{
 	  err = true;
-	  string msg = fcn;
+	  std::string msg = fcn;
 	  msg.append (": read error");
 	  error (msg);
 	}
       else if (count == 0 && is.eof ())
 	{
 	  err = true;
-	  string msg = fcn;
+	  std::string msg = fcn;
 	  msg.append (": at end of file");
 	  error (msg);
 	}
       else
 	{
 	  buf << ends;
 	  char *tmp = buf.str ();
 	  retval = tmp;
@@ -964,21 +964,21 @@ octave_value
 octave_base_stream::read (const Matrix& size,
 			  oct_data_conv::data_type dt, int skip,
 			  oct_mach_info::float_format flt_fmt, int& count)
 {
   Matrix retval;
 
   count = 0;
 
-  istream *isp = input_stream ();
+  std::istream *isp = input_stream ();
 
   if (isp)
     {
-      istream& is = *isp;
+      std::istream& is = *isp;
 
       int nr = -1;
       int nc = -1;
 
       bool ignore;
 
       get_size (size, nr, nc, ignore, "fread");
 
@@ -998,17 +998,17 @@ octave_base_stream::read (const Matrix& 
   else
     invalid_operation ("fread", "reading");
 
   return retval;
 }
 
 template <class T>
 void
-do_scanf_conv (istream& is, const char *fmt, T valptr, Matrix& mval,
+do_scanf_conv (std::istream& is, const char *fmt, T valptr, Matrix& mval,
 	       double *data, int& idx, int& conv_count, int nr,
 	       int max_size, bool discard) 
 {
   is.scan (fmt, valptr);
 
   if (is)
     {
       if (idx == max_size && ! discard)
@@ -1027,35 +1027,35 @@ do_scanf_conv (istream& is, const char *
 	{
 	  conv_count++;
 	  data[idx++] = *(valptr);
 	}
     }
 }
 
 template void
-do_scanf_conv (istream&, const char*, int*, Matrix&, double*, int&,
+do_scanf_conv (std::istream&, const char*, int*, Matrix&, double*, int&,
 	       int&, int, int, bool);
 
 template void
-do_scanf_conv (istream&, const char*, long int*, Matrix&, double*, int&,
+do_scanf_conv (std::istream&, const char*, long int*, Matrix&, double*, int&,
 	       int&, int, int, bool);
 
 template void
-do_scanf_conv (istream&, const char*, short int*, Matrix&, double*, int&,
+do_scanf_conv (std::istream&, const char*, short int*, Matrix&, double*, int&,
 	       int&, int, int, bool);
 
 #if 0
 template void
-do_scanf_conv (istream&, const char*, float*, Matrix&, double*, int&,
+do_scanf_conv (std::istream&, const char*, float*, Matrix&, double*, int&,
 	       int&, int, int, bool);
 #endif
 
 template void
-do_scanf_conv (istream&, const char*, double*, Matrix&, double*, int&,
+do_scanf_conv (std::istream&, const char*, double*, Matrix&, double*, int&,
 	       int&, int, int, bool);
 
 #define DO_WHITESPACE_CONVERSION() \
   do \
     { \
       int c = EOF; \
  \
       while (is && (c = is.get ()) != EOF && isspace (c)) \
@@ -1165,17 +1165,17 @@ do_scanf_conv (istream&, const char*, do
 	  is.scan (fmt, tmp); \
  \
 	  tmp[width] = '\0'; \
 	} \
       else \
 	{ \
 	  ostrstream buf; \
  \
-	  string char_class = elt->char_class; \
+	  std::string char_class = elt->char_class; \
  \
 	  int c = EOF; \
  \
 	  if (elt->type == '[') \
 	    { \
 	      while (is && (c = is.get ()) != EOF \
 		     && char_class.find (c) != NPOS) \
 		buf << (char) c; \
@@ -1255,17 +1255,17 @@ octave_base_stream::do_scanf (scanf_form
   if (nr == 0 || nc == 0)
     {
       if (one_elt_size_spec)
 	nc = 0;
 
       return Matrix (nr, nc, 0.0);
     }
 
-  istream *isp = input_stream ();
+  std::istream *isp = input_stream ();
 
   bool all_char_conv = fmt_list.all_character_conversions ();
 
   Matrix mval;
   double *data = 0;
   int max_size = 0;
   int max_conv = 0;
 
@@ -1311,17 +1311,17 @@ octave_base_stream::do_scanf (scanf_form
     {
       mval.resize (32, 1, 0.0);
       data = mval.fortran_vec ();
       max_size = 32;
     }
 
   if (isp)
     {
-      istream& is = *isp;
+      std::istream& is = *isp;
 
       const scanf_format_elt *elt = fmt_list.first ();
 
       ios::fmtflags flags = is.flags ();
 
       for (;;)
 	{
 	  if (elt)
@@ -1549,21 +1549,21 @@ octave_base_stream::do_scanf (scanf_form
 octave_value
 octave_base_stream::scanf (const string& fmt, const Matrix& size,
 			   int& count)
 {
   octave_value retval = Matrix ();
 
   count = 0;
 
-  istream *isp = input_stream ();
+  std::istream *isp = input_stream ();
 
   if (isp)
     {
-      istream& is = *isp;
+      std::istream& is = *isp;
 
       scanf_format_list fmt_list (fmt);
 
       switch (fmt_list.num_conversions ())
 	{
 	case -1:
 	  ::error ("fscanf: invalid format specified");
 	  break;
@@ -1626,21 +1626,21 @@ octave_base_stream::scanf (const string&
 }
 
 bool
 octave_base_stream::do_oscanf (const scanf_format_elt *elt,
 			       octave_value& retval)
 {
   bool quit = false;
 
-  istream *isp = input_stream ();
+  std::istream *isp = input_stream ();
 
   if (isp)
     {
-      istream& is = *isp;
+      std::istream& is = *isp;
 
       ios::fmtflags flags = is.flags ();
 
       if (elt)
 	{
 	  const char *fmt = elt->text;
 
 	  bool discard = elt->discard;
@@ -1761,25 +1761,25 @@ octave_base_stream::do_oscanf (const sca
 	    }
 	}
     }
 
   return quit;
 }
 
 octave_value_list
-octave_base_stream::oscanf (const string& fmt)
+octave_base_stream::oscanf (const std::string& fmt)
 {
   octave_value_list retval;
 
-  istream *isp = input_stream ();
+  std::istream *isp = input_stream ();
 
   if (isp)
     {
-      istream& is = *isp;
+      std::istream& is = *isp;
 
       scanf_format_list fmt_list (fmt);
 
       int nconv = fmt_list.num_conversions ();
 
       switch (nconv)
 	{
 	case -1:
@@ -1873,17 +1873,17 @@ octave_base_stream::oscanf (const string
 // Functions that are defined for all output streams (output streams
 // are those that define os).
 
 int
 octave_base_stream::flush (void)
 {
   int retval = -1;
 
-  ostream *os = output_stream ();
+  std::ostream *os = output_stream ();
 
   if (os)
     {
       os->flush ();
 
       if (os->good ())
 	retval = 0;
     }
@@ -1895,21 +1895,21 @@ octave_base_stream::flush (void)
 
 int
 octave_base_stream::write (const octave_value& data,
 			   oct_data_conv::data_type dt, int skip,
 			   oct_mach_info::float_format flt_fmt)
 {
   int retval = -1;
 
-  ostream *osp = output_stream ();
+  std::ostream *osp = output_stream ();
 
   if (osp)
     {
-      ostream& os = *osp;
+      std::ostream& os = *osp;
 
       Matrix mval = data.matrix_value ();
 
       if (! error_state)
 	{
 	  if (flt_fmt == oct_mach_info::unknown)
 	    flt_fmt = float_format ();
 
@@ -1943,17 +1943,17 @@ public:
 
   // Get the current value as a double and advance the internal pointer.
   double double_value (void);
 
   // Get the current value as an int and advance the internal pointer.
   int int_value (void);
 
   // Get the current value as a string and advance the internal pointer.
-  string string_value (void);
+  std::string string_value (void);
 
   operator bool () const { return (curr_state == ok); }
 
   bool no_more_values (void) { return curr_state == list_exhausted; }
 
   bool looking_at_string (void);
 
 private:
@@ -2067,17 +2067,17 @@ printf_value_cache::int_value (void)
     }
 
   return retval;
 }
 
 string
 printf_value_cache::string_value (void)
 {
-  string retval;
+  std::string retval;
 
   if (looking_at_string ())
     {
       if (elt_idx != 0)
 	{
 	  val_idx++;
 	  elt_idx = 0;
 	  data = 0;
@@ -2090,17 +2090,17 @@ printf_value_cache::string_value (void)
 
   return retval;
 }
 
 // Ugh again and again.
 
 template <class T>
 void
-do_printf_conv (ostream& os, const char *fmt, int nsa, int sa_1,
+do_printf_conv (std::ostream& os, const char *fmt, int nsa, int sa_1,
 		int sa_2, bool have_arg, T arg)
 {
   switch (nsa)
     {
     case 2:
       if (have_arg)
 	os.form (fmt, sa_1, sa_2, arg);
       else
@@ -2123,38 +2123,38 @@ do_printf_conv (ostream& os, const char 
 
     default:
       ::error ("fprintf: internal error handling format");
       break;
     }
 }
 
 template void
-do_printf_conv (ostream&, const char*, int, int, int, bool, int);
+do_printf_conv (std::ostream&, const char*, int, int, int, bool, int);
 
 template void
-do_printf_conv (ostream&, const char*, int, int, int, bool, long);
+do_printf_conv (std::ostream&, const char*, int, int, int, bool, long);
 
 template void
-do_printf_conv (ostream&, const char*, int, int, int, bool, double);
+do_printf_conv (std::ostream&, const char*, int, int, int, bool, double);
 
 template void
-do_printf_conv (ostream&, const char*, int, int, int, bool, const char*);
+do_printf_conv (std::ostream&, const char*, int, int, int, bool, const char*);
 
 int
 octave_base_stream::do_printf (printf_format_list& fmt_list,
 			       const octave_value_list& args)
 {
   int retval = -1;
 
-  ostream *osp = output_stream ();
+  std::ostream *osp = output_stream ();
 
   if (osp)
     {
-      ostream& os = *osp;
+      std::ostream& os = *osp;
 
       const printf_format_elt *elt = fmt_list.first ();
 
       printf_value_cache val_cache (args);
 
       for (;;)
 	{
 	  if (elt)
@@ -2191,17 +2191,17 @@ octave_base_stream::do_printf (printf_fo
 	      const char *fmt = elt->text;
 
 	      if (doing_percent || args == 0)
 		do_printf_conv (os, fmt, nsa, sa_1, sa_2, false, 0.0);
 	      else
 		{
 		  if (elt->type == 's' && val_cache.looking_at_string ())
 		    {
-		      string val = val_cache.string_value ();
+		      std::string val = val_cache.string_value ();
 
 		      if (val_cache)
 			do_printf_conv (os, fmt, nsa, sa_1, sa_2, true,
 					val.c_str ());
 		      else
 			break;
 		    }
 		  else
@@ -2268,25 +2268,25 @@ octave_base_stream::do_printf (printf_fo
 	  elt = fmt_list.next ();
 	}
     }
 
   return retval;
 }
 
 int
-octave_base_stream::printf (const string& fmt, const octave_value_list& args)
+octave_base_stream::printf (const std::string& fmt, const octave_value_list& args)
 {
   int retval = -1;
 
-  ostream *osp = output_stream ();
+  std::ostream *osp = output_stream ();
 
   if (osp)
     {
-      ostream& os = *osp;
+      std::ostream& os = *osp;
 
       printf_format_list fmt_list (fmt);
 
       switch (fmt_list.num_conversions ())
 	{
 	case -1:
 	  ::error ("fprintf: invalid format specified");
 	  break;
@@ -2319,25 +2319,25 @@ octave_base_stream::printf (const string
     }
   else
     invalid_operation ("fprintf", "writing");
 
   return retval;
 }
 
 int
-octave_base_stream::puts (const string& s)
+octave_base_stream::puts (const std::string& s)
 {
   int retval = -1;
 
-  ostream *osp = output_stream ();
+  std::ostream *osp = output_stream ();
 
   if (osp)
     {
-      ostream& os = *osp;
+      std::ostream& os = *osp;
 
       os << s;
 
       if (os)
 	{
 	  // XXX FIXME XXX -- why does this seem to be necessary?
 	  // Without it, output from a loop like
 	  //
@@ -2369,28 +2369,28 @@ octave_base_stream::rewind (void)
 
 // Return current error message for this stream.
 
 string
 octave_base_stream::error (bool clear_err, int& err_num)
 {
   err_num = fail ? -1 : 0;
 
-  string tmp = errmsg;
+  std::string tmp = errmsg;
 
   if (clear_err)
     clear ();
 
   return tmp;
 }
 
 void
 octave_base_stream::invalid_operation (const char *op, const char *rw)
 {
-  string msg = op;
+  std::string msg = op;
   msg.append (": stream not open for ");
   msg.append (rw);
   error (msg);
 }
 
 octave_stream::octave_stream (octave_base_stream *bs = 0)
   : rep (bs)
 {
@@ -2437,28 +2437,28 @@ octave_stream::flush (void)
     retval = rep->flush ();
 
   return retval;
 }
 
 string
 octave_stream::getl (int max_len, bool& err)
 {
-  string retval;
+  std::string retval;
 
   if (stream_ok ("getl"))
     retval = rep->getl (max_len, err);
 
   return retval;
 }
 
 string
 octave_stream::getl (const octave_value& tc_max_len, bool& err)
 {
-  string retval;
+  std::string retval;
 
   err = false;
 
   int conv_err = 0;
 
   int max_len = convert_to_valid_int (tc_max_len, conv_err);
 
   if (conv_err || max_len < 0)
@@ -2470,28 +2470,28 @@ octave_stream::getl (const octave_value&
     retval = getl (max_len, err);
 
   return retval;
 }
 
 string
 octave_stream::gets (int max_len, bool& err)
 {
-  string retval;
+  std::string retval;
 
   if (stream_ok ("fgets"))
     retval = rep->gets (max_len, err);
 
   return retval;
 }
 
 string
 octave_stream::gets (const octave_value& tc_max_len, bool& err)
 {
-  string retval;
+  std::string retval;
 
   err = false;
 
   int conv_err = 0;
 
   int max_len = convert_to_valid_int (tc_max_len, conv_err);
 
   if (conv_err || max_len < 0)
@@ -2527,17 +2527,17 @@ octave_stream::seek (const octave_value&
   int xoffset = convert_to_valid_int (tc_offset, conv_err);
 
   if (! conv_err)
     {
       ios::seek_dir origin = ios::beg;
 
       if (tc_origin.is_string ())
 	{
-	  string xorigin = tc_origin.string_value ();
+	  std::string xorigin = tc_origin.string_value ();
 
 	  if (xorigin == "bof")
 	    origin = ios::beg;
 	  else if (xorigin == "cof")
 	    origin = ios::cur;
 	  else if (xorigin == "eof")
 	    origin = ios::end;
 	  else
@@ -2633,50 +2633,50 @@ octave_stream::write (const octave_value
 
   if (stream_ok ("fwrite"))
     retval = rep->write (data, dt, skip, flt_fmt);
 
   return retval;
 }
 
 octave_value
-octave_stream::scanf (const string& fmt, const Matrix& size, int& count)
+octave_stream::scanf (const std::string& fmt, const Matrix& size, int& count)
 {
   octave_value retval;
 
   if (stream_ok ("fscanf"))
     retval = rep->scanf (fmt, size, count);
 
   return retval;
 }
 
 octave_value_list
-octave_stream::oscanf (const string& fmt)
+octave_stream::oscanf (const std::string& fmt)
 {
   octave_value_list retval;
 
   if (stream_ok ("fscanf"))
     retval = rep->oscanf (fmt);
 
   return retval;
 }
 
 int
-octave_stream::printf (const string& fmt, const octave_value_list& args)
+octave_stream::printf (const std::string& fmt, const octave_value_list& args)
 {
   int retval = -1;
 
   if (stream_ok ("fprintf"))
     retval = rep->printf (fmt, args);
 
   return retval;
 }
 
 int
-octave_stream::puts (const string& s)
+octave_stream::puts (const std::string& s)
 {
   int retval = -1;
 
   if (stream_ok ("fputs"))
     retval = rep->puts (s);
 
   return retval;
 }
@@ -2685,17 +2685,17 @@ octave_stream::puts (const string& s)
 
 int
 octave_stream::puts (const octave_value& tc_s)
 {
   int retval = -1;
 
   if (tc_s.is_string ())
     {
-      string s = tc_s.string_value ();      
+      std::string s = tc_s.string_value ();      
       retval = rep->puts (s);
     }
   else
     error ("fputs: argument must be a string");
 
   return retval;
 }
 
@@ -2708,28 +2708,28 @@ octave_stream::eof (void) const
     retval = rep->eof ();
 
   return retval;
 }
 
 string
 octave_stream::error (bool clear, int& err_num)
 {
-  string retval;
+  std::string retval;
 
   if (stream_ok ("ferror", false))
     retval = rep->error (clear, err_num);
 
   return retval;
 }
 
 string
 octave_stream::name (void) const
 {
-  string retval;
+  std::string retval;
 
   if (stream_ok ("name"))
     retval = rep->name ();
 
   return retval;
 }
 
 int
@@ -2752,17 +2752,17 @@ octave_stream::float_format (void) const
     retval = rep->float_format ();
 
   return retval;
 }
 
 string
 octave_stream::mode_as_string (int mode)
 {
-  string retval = "???";
+  std::string retval = "???";
 
   switch (mode)
     {
     case ios::in:
       retval = "r";
       break;
 
     case ios::out:
@@ -2846,35 +2846,35 @@ octave_stream_list::instance_ok (void)
 
 octave_value
 octave_stream_list::insert (const octave_stream& os)
 {
   return (instance_ok ()) ? instance->do_insert (os) : octave_value (-1.0);
 }
 
 octave_stream
-octave_stream_list::lookup (int fid, const string& who)
+octave_stream_list::lookup (int fid, const std::string& who)
 {
   return (instance_ok ()) ? instance->do_lookup (fid, who) : octave_stream ();
 }
 
 octave_stream
-octave_stream_list::lookup (const octave_value& fid, const string& who)
+octave_stream_list::lookup (const octave_value& fid, const std::string& who)
 {
   return (instance_ok ()) ? instance->do_lookup (fid, who) : octave_stream ();
 }
 
 int
-octave_stream_list::remove (int fid, const string& who)
+octave_stream_list::remove (int fid, const std::string& who)
 {
   return (instance_ok ()) ? instance->do_remove (fid, who) : -1;
 }
 
 int
-octave_stream_list::remove (const octave_value& fid, const string& who)
+octave_stream_list::remove (const octave_value& fid, const std::string& who)
 {
   return (instance_ok ()) ? instance->do_remove (fid, who) : -1;
 }
 
 void
 octave_stream_list::clear (void)
 {
   if (instance)
@@ -2891,17 +2891,17 @@ string_vector
 octave_stream_list::get_info (const octave_value& fid)
 {
   return (instance_ok ()) ? instance->do_get_info (fid) : string_vector ();
 }
 
 string
 octave_stream_list::list_open_files (void)
 {
-  return (instance_ok ()) ? instance->do_list_open_files () : string ();
+  return (instance_ok ()) ? instance->do_list_open_files () : std::string ();
 }
 
 octave_value
 octave_stream_list::open_file_numbers (void)
 {
   return (instance_ok ())
     ? instance->do_open_file_numbers () : octave_value ();
 }
@@ -2945,53 +2945,53 @@ octave_stream_list::do_insert (const oct
       stream_number = curr_len;
       curr_len++;
     }
 
   return octave_value (os, stream_number);
 }
 
 static void
-gripe_invalid_file_id (int fid, const string& who)
+gripe_invalid_file_id (int fid, const std::string& who)
 {
   if (who.empty ())
     ::error ("invalid stream number = %d", fid);
   else
     ::error ("%s: invalid stream number = %d", who.c_str (), fid);
 }
 
 octave_stream
-octave_stream_list::do_lookup (int fid, const string& who) const
+octave_stream_list::do_lookup (int fid, const std::string& who) const
 {
   octave_stream retval;
 
   if (fid >= 0 && fid < curr_len)
     retval = list(fid);
   else
     gripe_invalid_file_id (fid, who);
 
   return retval;
 }
 
 octave_stream
 octave_stream_list::do_lookup (const octave_value& fid,
-			       const string& who) const
+			       const std::string& who) const
 {
   octave_stream retval;
 
   int i = get_file_number (fid);
 
   if (! error_state)
     retval = do_lookup (i, who);
 
   return retval;
 }
 
 int
-octave_stream_list::do_remove (int fid, const string& who)
+octave_stream_list::do_remove (int fid, const std::string& who)
 {
   int retval = -1;
 
   // Can't remove stdin (cin), stdout (cout), or stderr (cerr).
 
   if (fid > 2 && fid < curr_len)
     {
       octave_stream os = list(fid);
@@ -3007,17 +3007,17 @@ octave_stream_list::do_remove (int fid, 
     }
   else
     gripe_invalid_file_id (fid, who);
 
   return retval;
 }
 
 int
-octave_stream_list::do_remove (const octave_value& fid, const string& who)
+octave_stream_list::do_remove (const octave_value& fid, const std::string& who)
 {
   int retval = -1;
 
   int i = get_file_number (fid);
 
   if (! error_state)
     retval = do_remove (i, who);
 
@@ -3074,38 +3074,38 @@ octave_stream_list::do_get_info (const o
     ::error ("file id must be a file object or integer value");
 
   return retval;
 }
 
 string
 octave_stream_list::do_list_open_files (void) const
 {
-  string retval;
+  std::string retval;
 
   // XXX FIXME XXX -- this should probably be converted to use sstream
   // when that is available.
-  ostrstream buf;
+  std::ostrstream buf;
 
   buf << "\n"
       << "  number  mode  arch       name\n"
       << "  ------  ----  ----       ----\n";
 
   for (int i = 0; i < curr_len; i++)
     {
       octave_stream os = list(i);
 
       if (os)
 	{
-	  string mode = octave_stream::mode_as_string (os.mode ());
-
-	  string arch =
+	  std::string mode = octave_stream::mode_as_string (os.mode ());
+
+	  std::string arch =
 	    oct_mach_info::float_format_as_string (os.float_format ());
 
-	  string name = os.name ();
+	  std::string name = os.name ();
 
 	  buf << "  "
 	      << setiosflags (ios::right)
 	      << setw (4) << i << "     "
 	      << setiosflags (ios::left)
 	      << setw (3) << mode.c_str () << "  "
 	      << setw (9) << arch.c_str () << "  "
 	      << name << "\n";
@@ -3145,17 +3145,17 @@ octave_stream_list::do_open_file_numbers
 
 int
 octave_stream_list::do_get_file_number (const octave_value& fid) const
 {
   int retval = -1;
 
   if (fid.is_string ())
     {
-      string nm = fid.string_value ();
+      std::string nm = fid.string_value ();
 
       // stdin (cin), stdout (cout), and stderr (cerr) are unnamed.
 
       for (int i = 3; i < curr_len; i++)
 	{
 	  octave_stream os = list(i);
 
 	  if (os && os.name () == nm)
@@ -3167,17 +3167,17 @@ octave_stream_list::do_get_file_number (
     }
   else
     {
       int conv_err = 0;
 
       int int_fid = convert_to_valid_int (fid, conv_err);
 
       if (conv_err)
-	::error ("file id must be a file object, string, or integer value");
+	::error ("file id must be a file object, std::string, or integer value");
       else
 	retval = int_fid;
     }
 
   return retval;
 }
 
 /*
diff --git a/src/oct-stream.h b/src/oct-stream.h
--- a/src/oct-stream.h
+++ b/src/oct-stream.h
@@ -42,36 +42,36 @@ scanf_format_elt
   enum special_conversion
     {
       whitespace_conversion = 1,
       literal_conversion = 2
     };
 
   scanf_format_elt (const char *txt = 0, int w = 0, bool d = false,
 		    char typ = '\0', char mod = '\0',
-		    const string& ch_class = string ())
+		    const std::string& ch_class = std::string ())
     : text (txt), width (w), discard (d), type (typ), modifier (mod),
       char_class (ch_class) { }
 
   ~scanf_format_elt (void) { delete text; }
 
   const char *text;
   int width;
   bool discard;
   char type;
   char modifier;
-  string char_class;
+  std::string char_class;
 };
 
 class
 scanf_format_list
 {
 public:
 
-  scanf_format_list (const string& fmt = string ());
+  scanf_format_list (const std::string& fmt = std::string ());
 
   ~scanf_format_list (void);
 
   int num_conversions (void) { return nconv; }
 
   // The length can be different than the number of conversions.
   // For example, "x %d y %d z" has 2 conversions but the length of
   // the list is 3 because of the characters that appear after the
@@ -103,37 +103,37 @@ public:
   operator bool () const { return ok (); }
 
   bool all_character_conversions (void);
 
   bool all_numeric_conversions (void);
 
 private:
 
-  // Number of conversions specified by this format string, or -1 if
+  // Number of conversions specified by this format std::string, or -1 if
   // invalid conversions have been found.
   int nconv;
 
   // Index to current element;
   int curr_idx;
 
   // List of format elements.
   Array<scanf_format_elt*> list;
 
   // Temporary buffer.
-  ostrstream *buf;
+  std::ostrstream *buf;
 
   void add_elt_to_list (int width, bool discard, char type, char modifier,
-			int& num_elts, const string& char_class = string ());
+			int& num_elts, const std::string& char_class = std::string ());
 
-  void process_conversion (const string& s, int& i, int n, int& width,
+  void process_conversion (const std::string& s, int& i, int n, int& width,
 			   bool& discard, char& type, char& modifier,
 			   int& num_elts);
 
-  int finish_conversion (const string& s, int& i, int n, int& width,
+  int finish_conversion (const std::string& s, int& i, int n, int& width,
 			 bool discard, char& type, char modifier,
 			 int& num_elts);
   // No copying!
 
   scanf_format_list (const scanf_format_list&);
 
   scanf_format_list& operator = (const scanf_format_list&);
 };
@@ -153,17 +153,17 @@ printf_format_elt
   char modifier;
 };
 
 class
 printf_format_list
 {
 public:
 
-  printf_format_list (const string& fmt = string ());
+  printf_format_list (const std::string& fmt = std::string ());
 
   ~printf_format_list (void);
 
   int num_conversions (void) { return nconv; }
 
   const printf_format_elt *first (void)
     {
       curr_idx = 0;
@@ -184,36 +184,36 @@ public:
   void printme (void) const;
 
   bool ok (void) const { return (nconv >= 0); }
 
   operator bool () const { return ok (); }
 
 private:
 
-  // Number of conversions specified by this format string, or -1 if
+  // Number of conversions specified by this format std::string, or -1 if
   // invalid conversions have been found.
   int nconv;
 
   // Index to current element;
   int curr_idx;
 
   // List of format elements.
   Array<printf_format_elt*> list;
 
   // Temporary buffer.
-  ostrstream *buf;
+  std::ostrstream *buf;
 
   void add_elt_to_list (int args, char type, char modifier,
 			int& num_elts);
 
-  void process_conversion (const string& s, int& i, int n, int& args,
+  void process_conversion (const std::string& s, int& i, int n, int& args,
 			   char& modifier, char& type, int& num_elts);
 
-  void finish_conversion (const string& s, int& i, int args,
+  void finish_conversion (const std::string& s, int& i, int args,
 			  char modifier, char& type, int& num_elts);
 
   // No copying!
 
   printf_format_list (const printf_format_list&);
 
   printf_format_list& operator = (const printf_format_list&);
 };
@@ -246,53 +246,53 @@ public:
   virtual long tell (void) const = 0;
 
   // Return TRUE if EOF has been reached on this stream.
 
   virtual bool eof (void) const = 0;
 
   // The name of the file.
 
-  virtual string name (void) const = 0;
+  virtual std::string name (void) const = 0;
 
   // If the derived class provides this function and it returns a
   // pointer to a valid istream, scanf(), read(), getl(), and gets()
   // will automatically work for this stream.
 
-  virtual istream *input_stream (void) { return 0; }
+  virtual std::istream *input_stream (void) { return 0; }
 
   // If the derived class provides this function and it returns a
   // pointer to a valid ostream, flush(), write(), and printf() will
   // automatically work for this stream.
 
-  virtual ostream *output_stream (void) { return 0; }
+  virtual std::ostream *output_stream (void) { return 0; }
 
   // Return TRUE if this stream is open.
 
   bool is_open (void) const { return open_state; }
 
   void close (void) { open_state = false; }
 
   int file_number (void);
 
   bool ok (void) const { return ! fail; }
 
   // Return current error message for this stream.
 
-  string error (bool clear, int& err_num);
+  std::string error (bool clear, int& err_num);
 
 protected:
 
   int mode (void) const { return md; }
 
   oct_mach_info::float_format float_format (void) const { return flt_fmt; }
 
   // Set current error state and set fail to TRUE.
 
-  void error (const string& msg);
+  void error (const std::string& msg);
 
   // Clear any error message and set fail to FALSE.
 
   void clear (void);
 
 private:
 
   // A reference count.
@@ -307,26 +307,26 @@ private:
 
   // TRUE if an error has occurred.
   bool fail;
 
   // TRUE if this stream is open.
   bool open_state;
 
   // Should contain error message if fail is TRUE.
-  string errmsg;
+  std::string errmsg;
 
   // Functions that are defined for all input streams (input streams
   // are those that define is).
 
-  string do_gets (int max_len, bool& err, bool strip_newline,
+  std::string do_gets (int max_len, bool& err, bool strip_newline,
 		  const char *fcn);
 
-  string getl (int max_len, bool& err);
-  string gets (int max_len, bool& err);
+  std::string getl (int max_len, bool& err);
+  std::string gets (int max_len, bool& err);
 
   octave_value do_read (int nr, int nc, oct_data_conv::data_type dt,
 			int skip, oct_mach_info::float_format flt_fmt,
 			int& count);
 
   octave_value read (const Matrix& size, oct_data_conv::data_type dt,
 		     int skip, oct_mach_info::float_format flt_fmt,
 		     int& count);
@@ -335,38 +335,38 @@ private:
 			      int nr, int nc, int& count);
 
   octave_value do_real_scanf (scanf_format_list& fmt_list,
 			      int nr, int nc, int& count);
 
   octave_value do_scanf (scanf_format_list& fmt_list, int nr, int nc,
 			 bool one_elt_size_spec, int& count);
 
-  octave_value scanf (const string& fmt, const Matrix& size, int& count);
+  octave_value scanf (const std::string& fmt, const Matrix& size, int& count);
 
   bool do_oscanf (const scanf_format_elt *elt, octave_value&);
 
-  octave_value_list oscanf (const string& fmt);
+  octave_value_list oscanf (const std::string& fmt);
 
   // Functions that are defined for all output streams (output streams
   // are those that define os).
 
   int flush (void);
 
   int do_write (const Matrix& m, oct_data_conv::data_type dt, int skip,
 		oct_mach_info::float_format flt_fmt);
 
   int write (const octave_value& data, oct_data_conv::data_type dt,
 	     int skip, oct_mach_info::float_format flt_fmt);
 
   int do_printf (printf_format_list& fmt_list, const octave_value_list& args);
 
-  int printf (const string& fmt, const octave_value_list& args);
+  int printf (const std::string& fmt, const octave_value_list& args);
 
-  int puts (const string& s);
+  int puts (const std::string& s);
 
   // We can always do this in terms of seek(), so the derived class
   // only has to provide that.
 
   int rewind (void);
 
   void invalid_operation (const char *op, const char *rw);
 
@@ -387,21 +387,21 @@ public:
   ~octave_stream (void);
 
   octave_stream (const octave_stream&);
 
   octave_stream& operator = (const octave_stream&);
 
   int flush (void);
 
-  string getl (int max_len, bool& err);
-  string getl (const octave_value& max_len, bool& err);
+  std::string getl (int max_len, bool& err);
+  std::string getl (const octave_value& max_len, bool& err);
 
-  string gets (int max_len, bool& err);
-  string gets (const octave_value& max_len, bool& err);
+  std::string gets (int max_len, bool& err);
+  std::string gets (const octave_value& max_len, bool& err);
 
   int seek (streamoff offset, ios::seek_dir origin);
   int seek (const octave_value& offset, const octave_value& origin);
 
   long tell (void) const;
 
   int rewind (void);
 
@@ -411,54 +411,54 @@ public:
 
   octave_value read (const Matrix& size, oct_data_conv::data_type dt,
 		     int skip, oct_mach_info::float_format flt_fmt,
 		     int& count);
 
   int write (const octave_value& data, oct_data_conv::data_type dt,
 	     int skip, oct_mach_info::float_format flt_fmt);
 
-  octave_value scanf (const string& fmt, const Matrix& size, int& count);
+  octave_value scanf (const std::string& fmt, const Matrix& size, int& count);
 
-  octave_value_list oscanf (const string& fmt);
+  octave_value_list oscanf (const std::string& fmt);
 
-  int printf (const string& fmt, const octave_value_list& args);
+  int printf (const std::string& fmt, const octave_value_list& args);
 
-  int puts (const string& s);
+  int puts (const std::string& s);
   int puts (const octave_value& s);
 
   bool eof (void) const;
 
-  string error (bool clear, int& err_num);
+  std::string error (bool clear, int& err_num);
 
-  string error (bool clear = false)
+  std::string error (bool clear = false)
     {
       int err_num;
       return error (clear, err_num);
     }
 
   int file_number (void) { return rep ? rep->file_number () : -1; }
 
   bool is_valid (void) const { return (rep != 0); }
 
   bool ok (void) const { return rep && rep->ok (); }
 
   operator bool () const { return ok (); }
 
-  string name (void) const;
+  std::string name (void) const;
 
   int mode (void) const;
 
   oct_mach_info::float_format float_format (void) const;
 
-  static string mode_as_string (int mode);
+  static std::string mode_as_string (int mode);
 
-  istream *input_stream (void) { return rep ? rep->input_stream () : 0; }
+  std::istream *input_stream (void) { return rep ? rep->input_stream () : 0; }
 
-  ostream *output_stream (void) { return rep ? rep->output_stream () : 0; }
+  std::ostream *output_stream (void) { return rep ? rep->output_stream () : 0; }
 
 private:
 
   // The actual representation of this stream.
   octave_base_stream *rep;
 
   void invalid_stream_error (const char *op) const;
 
@@ -475,17 +475,17 @@ private:
 	{
 	  retval = false;
 	  invalid_stream_error (op);
 	}
 
       return retval;
     }
 
-  void error (const string& msg)
+  void error (const std::string& msg)
     {
       if (rep)
 	rep->error (msg);
     }
 };
 
 class
 octave_stream_list
@@ -497,58 +497,58 @@ protected:
 public:
 
   ~octave_stream_list (void) { }
 
   static bool instance_ok (void);
 
   static octave_value insert (const octave_stream& os);
 
-  static octave_stream lookup (int fid, const string& who = string ());
+  static octave_stream lookup (int fid, const std::string& who = std::string ());
   static octave_stream lookup (const octave_value& fid,
-			       const string& who = string ());
+			       const std::string& who = std::string ());
 
-  static int remove (int fid, const string& who = string ());
+  static int remove (int fid, const std::string& who = std::string ());
   static int remove (const octave_value& fid,
-		     const string& who = string ());
+		     const std::string& who = std::string ());
 
   static void clear (void);
 
   static string_vector get_info (int fid);
   static string_vector get_info (const octave_value& fid);
 
-  static string list_open_files (void);
+  static std::string list_open_files (void);
 
   static octave_value open_file_numbers (void);
 
   static int get_file_number (const octave_value& fid);
 
 private:
 
   Array<octave_stream> list;
 
   int curr_len;
 
   static octave_stream_list *instance;
 
   octave_value do_insert (const octave_stream& os);
 
-  octave_stream do_lookup (int fid, const string& who = string ()) const;
+  octave_stream do_lookup (int fid, const std::string& who = std::string ()) const;
   octave_stream do_lookup (const octave_value& fid,
-			   const string& who = string ()) const;
+			   const std::string& who = std::string ()) const;
 
-  int do_remove (int fid, const string& who = string ());
-  int do_remove (const octave_value& fid, const string& who = string ());
+  int do_remove (int fid, const std::string& who = std::string ());
+  int do_remove (const octave_value& fid, const std::string& who = std::string ());
 
   void do_clear (void);
 
   string_vector do_get_info (int fid) const;
   string_vector do_get_info (const octave_value& fid) const;
 
-  string do_list_open_files (void) const;
+  std::string do_list_open_files (void) const;
 
   octave_value do_open_file_numbers (void) const;
 
   int do_get_file_number (const octave_value& fid) const;
 };
 
 #endif
 
diff --git a/src/oct-strstrm.cc b/src/oct-strstrm.cc
--- a/src/oct-strstrm.cc
+++ b/src/oct-strstrm.cc
@@ -30,17 +30,17 @@ Software Foundation, 59 Temple Place - S
 
 int
 octave_base_strstream::seek (streamoff offset, ios::seek_dir origin)
 {
   int retval = -1;
 
   if (! bad ())
     {
-      streambuf *sb = rdbuf ();
+      std::streambuf *sb = rdbuf ();
 
       if (sb)
 	{
 	  clear ();
 
 	  sb->seekoff (offset, origin);
 	  retval = bad () ? -1 : 0;
 	}
@@ -55,17 +55,17 @@ long
 octave_base_strstream::tell (void) const
 {
   long retval = -1;
 
   if (! bad ())
     {
       // XXX FIXME XXX -- shouldn't have to do this!
 
-      streambuf *sb = (const_cast<octave_base_strstream *>(this))->rdbuf ();
+      std::streambuf *sb = (const_cast<octave_base_strstream *>(this))->rdbuf ();
 
       if (sb)
 	{
 	  retval = static_cast<long> (sb->seekoff (0, ios::cur));
 
 	  if (bad ())
 	    retval = -1;
 	}
@@ -77,17 +77,17 @@ octave_base_strstream::tell (void) const
 octave_stream
 octave_istrstream::create (const char *data, ios::openmode arg_md,
 			   oct_mach_info::float_format flt_fmt)
 {
   return octave_stream (new octave_istrstream (data, arg_md, flt_fmt));
 }
 
 octave_stream
-octave_istrstream::create (const string& data, ios::openmode arg_md,
+octave_istrstream::create (const std::string& data, ios::openmode arg_md,
 			   oct_mach_info::float_format flt_fmt)
 {
   return octave_stream (new octave_istrstream (data, arg_md, flt_fmt));
 }
 
 octave_stream
 octave_ostrstream::create (ios::openmode arg_md,
 			   oct_mach_info::float_format flt_fmt)
diff --git a/src/oct-strstrm.h b/src/oct-strstrm.h
--- a/src/oct-strstrm.h
+++ b/src/oct-strstrm.h
@@ -43,19 +43,19 @@ public:
   int seek (streamoff offset, ios::seek_dir origin);
 
   // Return current stream position.
 
   long tell (void) const;
 
   // The name of the file.
 
-  string name (void) const { return string (); }
+  std::string name (void) const { return std::string (); }
 
-  virtual streambuf *rdbuf (void) = 0;
+  virtual std::streambuf *rdbuf (void) = 0;
 
   virtual bool bad (void) const = 0;
 
   virtual void clear (void) = 0;
 
 protected:
 
   ~octave_base_strstream (void) { }
@@ -75,51 +75,51 @@ octave_istrstream : public octave_base_s
 public:
 
   octave_istrstream (const char *data,
 		     ios::openmode arg_md = ios::out,
 		     oct_mach_info::float_format flt_fmt =
 		     oct_mach_info::native)
     : octave_base_strstream (arg_md, flt_fmt), is (data) { }
 
-  octave_istrstream (const string& data,
+  octave_istrstream (const std::string& data,
 		     ios::openmode arg_md = ios::out,
 		     oct_mach_info::float_format flt_fmt =
 		     oct_mach_info::native)
     : octave_base_strstream (arg_md, flt_fmt), is (data.c_str ()) { }
 
   static octave_stream
   create (const char *data, ios::openmode arg_md = ios::out,
 	  oct_mach_info::float_format flt_fmt = oct_mach_info::native);
 
   static octave_stream
-  create (const string& data, ios::openmode arg_md = ios::out,
+  create (const std::string& data, ios::openmode arg_md = ios::out,
 	  oct_mach_info::float_format flt_fmt = oct_mach_info::native);
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const { return is.eof (); }
 
-  istream *input_stream (void) { return &is; }
+  std::istream *input_stream (void) { return &is; }
 
-  ostream *output_stream (void) { return 0; }
+  std::ostream *output_stream (void) { return 0; }
 
-  streambuf *rdbuf (void) { return is ? is.rdbuf () : 0; }
+  std::streambuf *rdbuf (void) { return is ? is.rdbuf () : 0; }
 
   bool bad (void) const { return is.bad (); }
 
   void clear (void) { is.clear (); }
 
 protected:
 
   ~octave_istrstream (void) { }
 
 private:
 
-  istrstream is;
+  std::istrstream is;
 
   // No copying!
 
   octave_istrstream (const octave_istrstream&);
 
   octave_istrstream& operator = (const octave_istrstream&);
 };
 
@@ -136,42 +136,42 @@ public:
   static octave_stream
   create (ios::openmode arg_md = ios::out,
 	  oct_mach_info::float_format flt_fmt = oct_mach_info::native);
 
   // Return non-zero if EOF has been reached on this stream.
 
   bool eof (void) const { return os.eof (); }
 
-  istream *input_stream (void) { return 0; }
+  std::istream *input_stream (void) { return 0; }
 
-  ostream *output_stream (void) { return &os; }
+  std::ostream *output_stream (void) { return &os; }
 
-  string str (void)
+  std::string str (void)
     {
       os << ends;
       char *tmp = os.str ();
-      string retval = tmp;
+      std::string retval = tmp;
       delete [] tmp;
       return retval;
     }
 
-  streambuf *rdbuf (void) { return os ? os.rdbuf () : 0; }
+  std::streambuf *rdbuf (void) { return os ? os.rdbuf () : 0; }
 
   bool bad (void) const { return os.bad (); }
 
   void clear (void) { os.clear (); }
 
 protected:
 
   ~octave_ostrstream (void) { }
 
 private:
 
-  ostrstream os;
+  std::ostrstream os;
 
   // No copying!
 
   octave_ostrstream (const octave_ostrstream&);
 
   octave_ostrstream& operator = (const octave_ostrstream&);
 };
 
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -171,25 +171,25 @@ intern_argv (int argc, char **argv)
 }
 
 static void
 initialize_pathsearch (void)
 {
   // This may seem odd, but doing it this way means that we don't have
   // to modify the kpathsea library...
 
-  string odb = octave_env::getenv ("OCTAVE_DB_PATH");
+  std::string odb = octave_env::getenv ("OCTAVE_DB_PATH");
 
   // For backward compatibility.
 
   if (odb.empty ())
     odb = octave_env::getenv ("OCTAVE_DB_DIR");
 
   if (odb.empty ())
-    odb = Vdata_dir + string ("/octave:") + Vlibexec_dir + string ("/octave");
+    odb = Vdata_dir + std::string ("/octave:") + Vlibexec_dir + std::string ("/octave");
 
   octave_env::putenv ("TEXMFDBS", odb);
 }
 
 // Initialize by reading startup files.
 
 static void
 execute_startup_files (void)
@@ -220,25 +220,25 @@ execute_startup_files (void)
   if (read_init_files)
     {
       // Try to execute commands from $HOME/$OCTAVE_INITFILE and
       // $OCTAVE_INITFILE.  If $OCTAVE_INITFILE is not set, .octaverc
       // is assumed.
 
       int home_rc_already_executed = 0;
 
-      string initfile = octave_env::getenv ("OCTAVE_INITFILE");
+      std::string initfile = octave_env::getenv ("OCTAVE_INITFILE");
 
       if (initfile.empty ())
 	initfile = ".octaverc";
 
-      string home_dir = octave_env::get_home_directory ();
+      std::string home_dir = octave_env::get_home_directory ();
 
-      string home_rc = home_dir + "/" + initfile;
-      string local_rc = string ("./") + initfile;
+      std::string home_rc = home_dir + "/" + initfile;
+      std::string local_rc = std::string ("./") + initfile;
 
       if (! home_dir.empty ())
 	{
 	  parse_and_execute (home_rc, verbose);
 
 	  // Names alone are not enough.
 
 	  file_stat fs_home_rc (home_rc);
@@ -526,17 +526,17 @@ main (int argc, char **argv)
 	{
 	  input_from_command_line_file = true;
 
 	  bind_builtin_variable ("program_invocation_name",
 				 curr_fcn_file_name);
 
 	  size_t pos = curr_fcn_file_name.rfind ('/');
 
-	  string tmp = (pos != NPOS)
+	  std::string tmp = (pos != NPOS)
 	    ? curr_fcn_file_name.substr (pos+1) : curr_fcn_file_name;
 
 	  bind_builtin_variable ("program_name", tmp);
 
 	  intern_argv (remaining_args, argv+last_arg_idx);
 
 	  command_editor::blink_matching_paren (false);
 
diff --git a/src/ov-base-mat.cc b/src/ov-base-mat.cc
--- a/src/ov-base-mat.cc
+++ b/src/ov-base-mat.cc
@@ -58,17 +58,17 @@ octave_base_matrix<MT>::do_index_op (con
 	idx_vector i = idx (0).index_vector ();
 
 	retval = MT (matrix.index (i));
       }
       break;
 
     default:
       {
-	string n = type_name ();
+	std::string n = type_name ();
 
 	error ("invalid number of indices (%d) for %s value",
 	       len, n.c_str ());
       }
       break;
     }
 
   return retval;
@@ -106,33 +106,33 @@ octave_base_matrix<MT>::print_as_scalar 
   int nr = rows ();
   int nc = columns ();
 
   return (nr == 1 && nc == 1 || (nr == 0 || nc == 0));
 }
 
 template <class MT>
 void
-octave_base_matrix<MT>::print (ostream& os, bool pr_as_read_syntax) const
+octave_base_matrix<MT>::print (std::ostream& os, bool pr_as_read_syntax) const
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
 template <class MT>
 void
-octave_base_matrix<MT>::print_raw (ostream& os, bool pr_as_read_syntax) const
+octave_base_matrix<MT>::print_raw (std::ostream& os, bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
 			 current_print_indent_level ());
 }
 
 template <class MT>
 bool
-octave_base_matrix<MT>::print_name_tag (ostream& os, const string& name) const
+octave_base_matrix<MT>::print_name_tag (std::ostream& os, const std::string& name) const
 {
   bool retval = false;
 
   indent (os);
 
   if (print_as_scalar ())
     os << name << " = ";
   else
diff --git a/src/ov-base-mat.h b/src/ov-base-mat.h
--- a/src/ov-base-mat.h
+++ b/src/ov-base-mat.h
@@ -88,21 +88,21 @@ public:
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_true (void) const;
 
   virtual bool print_as_scalar (void) const;
 
-  void print (ostream& os, bool pr_as_read_syntax = false) const;
+  void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
+  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  bool print_name_tag (ostream& os, const string& name) const;
+  bool print_name_tag (std::ostream& os, const std::string& name) const;
 
 protected:
 
   MT matrix;
 };
 
 #endif
 
diff --git a/src/ov-base-scalar.cc b/src/ov-base-scalar.cc
--- a/src/ov-base-scalar.cc
+++ b/src/ov-base-scalar.cc
@@ -31,33 +31,33 @@ Software Foundation, 59 Temple Place - S
 #include <iostream>
 
 #include "ov-base.h"
 #include "ov-base-scalar.h"
 #include "pr-output.h"
 
 template <class ST>
 void
-octave_base_scalar<ST>::print (ostream& os, bool pr_as_read_syntax) const
+octave_base_scalar<ST>::print (std::ostream& os, bool pr_as_read_syntax) const
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
 template <class ST>
 void
-octave_base_scalar<ST>::print_raw (ostream& os, bool pr_as_read_syntax) const
+octave_base_scalar<ST>::print_raw (std::ostream& os, bool pr_as_read_syntax) const
 {
   indent (os);
   octave_print_internal (os, scalar, pr_as_read_syntax);
 }
 
 template <class ST>
 bool
-octave_base_scalar<ST>::print_name_tag (ostream& os, const string& name) const
+octave_base_scalar<ST>::print_name_tag (std::ostream& os, const std::string& name) const
 {
   indent (os);
   os << name << " = ";
   return false;    
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/ov-base-scalar.h b/src/ov-base-scalar.h
--- a/src/ov-base-scalar.h
+++ b/src/ov-base-scalar.h
@@ -74,21 +74,21 @@ public:
   octave_value any (void) const { return (scalar != 0.0); }
 
   bool is_scalar_type (void) const { return true; }
 
   bool is_numeric_type (void) const { return true; }
 
   bool is_true (void) const { return (scalar != 0.0); }
 
-  void print (ostream& os, bool pr_as_read_syntax = false) const;
+  void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
+  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  bool print_name_tag (ostream& os, const string& name) const;
+  bool print_name_tag (std::ostream& os, const std::string& name) const;
 
 protected:
 
   // The value of this scalar.
   ST scalar;
 };
 
 #endif
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -50,61 +50,61 @@ Software Foundation, 59 Temple Place - S
 #include "ov-list.h"
 #include "variables.h"
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_base_value, "<unknown type>");
 
 octave_value
 octave_base_value::do_index_op (const octave_value_list&)
 {
-  string nm = type_name ();
+  std::string nm = type_name ();
   error ("can't perform indexing operations for %s type", nm.c_str ());
   return octave_value ();
 }
 
 octave_value_list
 octave_base_value::do_index_op (int, const octave_value_list&)
 {
-  string nm = type_name ();
+  std::string nm = type_name ();
   error ("can't perform indexing operations for %s type", nm.c_str ());
   return octave_value ();
 }
 
 idx_vector
 octave_base_value::index_vector (void) const
 {
-  string nm = type_name ();
+  std::string nm = type_name ();
   error ("%s type invalid as index value", nm.c_str ());
   return idx_vector ();
 }
 
 octave_value
-octave_base_value::do_struct_elt_index_op (const string&,
+octave_base_value::do_struct_elt_index_op (const std::string&,
 					   const octave_value_list&,
 					   bool)
 {
-  string nm = type_name ();
+  std::string nm = type_name ();
   error ("can't perform indexed structure reference operations for %s type",
 	 nm.c_str ());
   return octave_value ();
 }
 
 octave_value
-octave_base_value::do_struct_elt_index_op (const string&, bool)
+octave_base_value::do_struct_elt_index_op (const std::string&, bool)
 {
-  string nm = type_name ();
+  std::string nm = type_name ();
   error ("can't perform structure reference operations for %s type",
 	 nm.c_str ());
   return octave_value ();
 }
 
 octave_lvalue
-octave_base_value::struct_elt_ref (octave_value *, const string&)
+octave_base_value::struct_elt_ref (octave_value *, const std::string&)
 {
-  string nm = type_name ();
+  std::string nm = type_name ();
   error ("can't perform structure reference operations for %s type",
 	 nm.c_str ());
   return octave_lvalue ();
 }
 
 octave_value
 octave_base_value::convert_to_str (void) const
 {
@@ -117,29 +117,29 @@ void
 octave_base_value::convert_to_row_or_column_vector (void)
 {
   gripe_wrong_type_arg
     ("octave_base_value::convert_to_row_or_column_vector ()",
      type_name ());
 }
 
 void
-octave_base_value::print (ostream&, bool) const
+octave_base_value::print (std::ostream&, bool) const
 {
   gripe_wrong_type_arg ("octave_base_value::print ()", type_name ());
 }
 
 void
-octave_base_value::print_raw (ostream&, bool) const
+octave_base_value::print_raw (std::ostream&, bool) const
 {
   gripe_wrong_type_arg ("octave_base_value::print_raw ()", type_name ());
 }
 
 bool
-octave_base_value::print_name_tag (ostream& os, const string& name) const
+octave_base_value::print_name_tag (std::ostream& os, const std::string& name) const
 {
   indent (os);
   os << name << " =";
   newline (os);
   newline (os);
   return true;
 }
 
@@ -245,17 +245,17 @@ octave_base_value::all_strings (void) co
   string_vector retval;
   gripe_wrong_type_arg ("octave_base_value::all_strings()", type_name ());
   return retval;
 }
 
 string
 octave_base_value::string_value (void) const
 {
-  string retval;
+  std::string retval;
   gripe_wrong_type_arg ("octave_base_value::string_value()", type_name ());
   return retval;
 }
 
 Range
 octave_base_value::range_value (void) const
 {
   Range retval;
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -72,22 +72,22 @@ public:
 
   octave_value do_index_op (const octave_value_list& idx);
 
   octave_value_list do_index_op (int nargout, const octave_value_list& idx);
 
   idx_vector index_vector (void) const;
 
   octave_value
-  do_struct_elt_index_op (const string& nm, const octave_value_list& idx,
+  do_struct_elt_index_op (const std::string& nm, const octave_value_list& idx,
 			  bool silent);
 
-  octave_value do_struct_elt_index_op (const string& nm, bool silent);
+  octave_value do_struct_elt_index_op (const std::string& nm, bool silent);
 
-  octave_lvalue struct_elt_ref (octave_value *parent, const string& nm);
+  octave_lvalue struct_elt_ref (octave_value *parent, const std::string& nm);
 
   int rows (void) const { return -1; }
 
   int columns (void) const { return -1; }
 
   int length (void) const { return -1; }
 
   bool is_defined (void) const { return false; }
@@ -172,17 +172,17 @@ public:
   Complex complex_value (bool = false) const;
 
   ComplexMatrix complex_matrix_value (bool = false) const;
 
   charMatrix char_matrix_value (bool = false) const;
 
   string_vector all_strings (void) const;
 
-  string string_value (void) const;
+  std::string string_value (void) const;
 
   Range range_value (void) const;
 
   Octave_map map_value (void) const;
 
   octave_stream stream_value (void) const;
 
   int stream_number (void) const;
@@ -194,21 +194,21 @@ public:
   bool bool_value (void) const;
 
   boolMatrix bool_matrix_value (void) const;
 
   octave_value convert_to_str (void) const;
 
   void convert_to_row_or_column_vector (void);
 
-  void print (ostream& os, bool pr_as_read_syntax = false) const;
+  void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
+  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  bool print_name_tag (ostream& os, const string& name) const;
+  bool print_name_tag (std::ostream& os, const std::string& name) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
diff --git a/src/ov-builtin.h b/src/ov-builtin.h
--- a/src/ov-builtin.h
+++ b/src/ov-builtin.h
@@ -39,18 +39,18 @@ class octave_value_list;
 
 class
 octave_builtin : public octave_function
 {
 public:
 
   typedef octave_value_list (*fcn) (const octave_value_list&, int);
 
-  octave_builtin (fcn ff, const string& nm = string (),
-		  const string& ds = string ())
+  octave_builtin (fcn ff, const std::string& nm = std::string (),
+		  const std::string& ds = std::string ())
     : octave_function (nm, ds), f (ff) { }
 
   ~octave_builtin (void) { }
 
   octave_function *function_value (bool) { return this; }
 
   bool is_builtin_function (void) const { return true; }
 
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -67,17 +67,17 @@ octave_cell::do_index_op (const octave_v
 	idx_vector i = idx (0).index_vector ();
 
 	retval = cell_val.index (i);
       }
       break;
 
     default:
       {
-	string n = type_name ();
+	std::string n = type_name ();
 
 	error ("invalid number of indices (%d) for %s value",
 	       len, n.c_str ());
       }
       break;
     }
 
   return retval;
@@ -104,23 +104,23 @@ octave_cell::assign (const octave_value_
 	error ("list index must be an integer");
     }
   else
     error ("lists may only be indexed by a single scalar");
 #endif
 }
 
 void
-octave_cell::print (ostream& os, bool) const
+octave_cell::print (std::ostream& os, bool) const
 {
   print_raw (os);
 }
 
 void
-octave_cell::print_raw (ostream& os, bool) const
+octave_cell::print_raw (std::ostream& os, bool) const
 {
   unwind_protect::begin_frame ("octave_cell_print");
 
   int nr = cell_val.rows ();
   int nc = cell_val.columns();
 
   if (nr > 0 && nc > 0)
     {
@@ -129,17 +129,17 @@ octave_cell::print_raw (ostream& os, boo
       newline (os);
 
       increment_indent_level ();
 
       for (int j = 0; j < nc; j++)
 	{
 	  for (int i = 0; i < nr; i++)
 	    {
-	      ostrstream buf;
+	      std::ostrstream buf;
 	      buf << "[" << i+1 << "," << j+1 << "]" << ends;
 	      const char *nm = buf.str ();
 
 	      octave_value val = cell_val(i,j);
 
 	      val.print_with_name (os, nm);
 
 	      delete [] nm;
@@ -156,17 +156,17 @@ octave_cell::print_raw (ostream& os, boo
     os << "{}";
 
   newline (os);
 
   unwind_protect::run_frame ("octave_cell_print");
 }
 
 bool
-octave_cell::print_name_tag (ostream& os, const string& name) const
+octave_cell::print_name_tag (std::ostream& os, const std::string& name) const
 {
   indent (os);
   if (is_empty ())
     os << name << " = ";
   else
     {
       os << name << " =";
       newline (os);
diff --git a/src/ov-cell.h b/src/ov-cell.h
--- a/src/ov-cell.h
+++ b/src/ov-cell.h
@@ -69,21 +69,21 @@ public:
   octave_value do_index_op (const octave_value_list& idx);
 
   void assign (const octave_value_list& idx, const octave_value& rhs);
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
-  void print (ostream& os, bool pr_as_read_syntax = false) const;
+  void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
+  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  bool print_name_tag (ostream& os, const string& name) const;
+  bool print_name_tag (std::ostream& os, const std::string& name) const;
 
 private:
 
   Cell cell_val;
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
diff --git a/src/ov-ch-mat.h b/src/ov-ch-mat.h
--- a/src/ov-ch-mat.h
+++ b/src/ov-ch-mat.h
@@ -60,17 +60,17 @@ public:
     : octave_base_matrix<charMatrix> (chm) { }
 
   octave_char_matrix (char c)
     : octave_base_matrix<charMatrix> (c) { }
 
   octave_char_matrix (const char *s)
     : octave_base_matrix<charMatrix> (s) { }
 
-  octave_char_matrix (const string& s)
+  octave_char_matrix (const std::string& s)
     : octave_base_matrix<charMatrix> (s) { }
 
   octave_char_matrix (const string_vector& s)
     : octave_base_matrix<charMatrix> (s) { }
 
   octave_char_matrix (const octave_char_matrix& chm)
     : octave_base_matrix<charMatrix> (chm) { }
 
diff --git a/src/ov-colon.cc b/src/ov-colon.cc
--- a/src/ov-colon.cc
+++ b/src/ov-colon.cc
@@ -32,24 +32,24 @@ Software Foundation, 59 Temple Place - S
 
 #include "error.h"
 #include "pr-output.h"
 #include "ov-colon.h"
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_magic_colon, "magic-colon");
 
 void
-octave_magic_colon::print (ostream& os, bool) const
+octave_magic_colon::print (std::ostream& os, bool) const
 {
   indent (os);
   print_raw (os);
 }
 
 void
-octave_magic_colon::print_raw (ostream& os, bool) const
+octave_magic_colon::print_raw (std::ostream& os, bool) const
 {
   os << ":";
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-colon.h b/src/ov-colon.h
--- a/src/ov-colon.h
+++ b/src/ov-colon.h
@@ -64,19 +64,19 @@ public:
   bool is_constant (void) const { return true; }
 
   bool is_magic_colon (void) const { return true; }
 
   bool valid_as_scalar_index (void) const { return true; }
 
   bool valid_as_zero_index (void) const { return false; }
 
-  void print (ostream& os, bool pr_as_read_syntax = false) const;
+  void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
+  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
diff --git a/src/ov-dld-fcn.cc b/src/ov-dld-fcn.cc
--- a/src/ov-dld-fcn.cc
+++ b/src/ov-dld-fcn.cc
@@ -40,22 +40,22 @@ Software Foundation, 59 Temple Place - S
 DEFINE_OCTAVE_ALLOCATOR (octave_dld_function);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_dld_function,
 				     "dynamically-linked function");
 
 
 octave_dld_function::octave_dld_function
   (octave_builtin::fcn ff, const octave_shlib& shl,
-   const string& nm, const string& ds)
+   const std::string& nm, const std::string& ds)
   : octave_builtin (ff, nm, ds), sh_lib (shl)
 {
   mark_fcn_file_up_to_date (time_parsed ());
 
-  string file_name = fcn_file_name ();
+  std::string file_name = fcn_file_name ();
 
   system_fcn_file
     = (! file_name.empty ()
        && Vfcn_file_dir.compare (file_name, 0, Vfcn_file_dir.length ()) == 0);
 }
 
 octave_dld_function::~octave_dld_function (void)
 {
diff --git a/src/ov-dld-fcn.h b/src/ov-dld-fcn.h
--- a/src/ov-dld-fcn.h
+++ b/src/ov-dld-fcn.h
@@ -43,24 +43,24 @@ class octave_value_list;
 // Dynamically-linked functions.
 
 class
 octave_dld_function : public octave_builtin
 {
 public:
 
   octave_dld_function (octave_builtin::fcn ff, const octave_shlib& shl,
-		       const string& nm = string (),
-		       const string& ds = string ());
+		       const std::string& nm = std::string (),
+		       const std::string& ds = std::string ());
 
   ~octave_dld_function (void);
 
   void mark_fcn_file_up_to_date (const octave_time& t) { t_checked = t; }
 
-  string fcn_file_name (void) const;
+  std::string fcn_file_name (void) const;
 
   octave_time time_parsed (void) const;
 
   octave_time time_checked (void) const { return t_checked; }
 
   bool is_system_fcn_file (void) const { return system_fcn_file; }
 
   bool is_builtin_function (void) const { return false; }
diff --git a/src/ov-fcn.h b/src/ov-fcn.h
--- a/src/ov-fcn.h
+++ b/src/ov-fcn.h
@@ -57,44 +57,44 @@ public:
   bool is_defined (void) const { return true; }
 
   bool is_function (void) const { return true; }
 
   virtual bool is_dynamically_loaded_function (void) const { return false; }
 
   virtual bool is_system_fcn_file (void) { return false; }
 
-  virtual string fcn_file_name (void) const { return string (); }
+  virtual std::string fcn_file_name (void) const { return std::string (); }
 
   virtual void mark_fcn_file_up_to_date (const octave_time&) { }
 
   virtual octave_time time_parsed (void) const
     { return octave_time (static_cast<time_t> (0)); }
 
   virtual octave_time time_checked (void) const
     { return octave_time (static_cast<time_t> (0)); }
 
-  string name (void) const { return my_name; }
+  std::string name (void) const { return my_name; }
 
-  string doc_string (void) const { return doc; }
+  std::string doc_string (void) const { return doc; }
 
   virtual void unload (void) { }
 
   virtual void accept (tree_walker&) { }
 
 protected:
 
-  octave_function (const string& nm, const string& ds)
+  octave_function (const std::string& nm, const std::string& ds)
     : my_name (nm), doc (ds) { }
 
   // The name of this function.
-  string my_name;
+  std::string my_name;
 
   // The help text for this function.
-  string doc;
+  std::string doc;
 
 private:
 
   octave_function (void);
 
   DECLARE_OCTAVE_ALLOCATOR
 };
 
diff --git a/src/ov-file.cc b/src/ov-file.cc
--- a/src/ov-file.cc
+++ b/src/ov-file.cc
@@ -50,51 +50,51 @@ default_numeric_conversion_function (con
 
 type_conv_fcn
 octave_file::numeric_conversion_function (void) const
 {
   return default_numeric_conversion_function;
 }
 
 void
-octave_file::print (ostream& os, bool) const
+octave_file::print (std::ostream& os, bool) const
 {
   print_raw (os);
   newline (os);
 }
 
 void
-octave_file::print_raw (ostream& os, bool) const
+octave_file::print_raw (std::ostream& os, bool) const
 {
   indent (os); os << "{"; newline (os);
 
   if (stream)
     {
       increment_indent_level ();
 
-      string name = stream.name ();
-      string mode = octave_stream::mode_as_string (stream.mode ());
-      string arch
+      std::string name = stream.name ();
+      std::string mode = octave_stream::mode_as_string (stream.mode ());
+      std::string arch
 	= oct_mach_info::float_format_as_string (stream.float_format ());
-      string status = stream.is_open () ? "open" : "closed";
+      std::string status = stream.is_open () ? "open" : "closed";
 
       indent (os); os << "id = " << number; newline (os);
       indent (os); os << "name = " << name; newline (os);
       indent (os); os << "mode = " << mode; newline (os);
       indent (os); os << "arch = " << arch; newline (os);
       indent (os); os << "status = " << status; newline (os);
 
       decrement_indent_level ();
     }
 
   indent (os); os << "}";
 }
 
 bool
-octave_file::print_name_tag (ostream& os, const string& name) const
+octave_file::print_name_tag (std::ostream& os, const std::string& name) const
 {
   indent (os);
   os << name << " =";
   newline (os);
   return false;
 }
 
 /*
diff --git a/src/ov-file.h b/src/ov-file.h
--- a/src/ov-file.h
+++ b/src/ov-file.h
@@ -71,21 +71,21 @@ public:
   octave_stream stream_value (void) const { return stream; }
 
   int stream_number (void) const { return number; }
 
   bool is_defined (void) const { return true; }
 
   bool is_stream (void) const { return true; }
 
-  void print (ostream& os, bool pr_as_read_syntax = false) const;
+  void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
+  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  bool print_name_tag (ostream& os, const string& name) const;
+  bool print_name_tag (std::ostream& os, const std::string& name) const;
 
 private:
 
   // The stream object.
   octave_stream stream;
 
   // The number of the beast.
   int number;
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -78,39 +78,39 @@ octave_list::assign (const octave_value_
       else
 	error ("list index must be an integer");
     }
   else
     error ("lists may only be indexed by a single scalar");
 }
 
 void
-octave_list::print (ostream& os, bool) const
+octave_list::print (std::ostream& os, bool) const
 {
   print_raw (os);
 }
 
 void
-octave_list::print_raw (ostream& os, bool) const
+octave_list::print_raw (std::ostream& os, bool) const
 {
   unwind_protect::begin_frame ("octave_list_print");
 
   int n = lst.length ();
 
   if (n > 0)
     {
       indent (os);
       os << "(";
       newline (os);
 
       increment_indent_level ();
 
       for (int i = 0; i < n; i++)
 	{
-	  ostrstream buf;
+	  std::ostrstream buf;
 	  buf << "[" << i+1 << "]" << ends;
 	  const char *nm = buf.str ();
 
 	  octave_value val = lst(i);
 
 	  val.print_with_name (os, nm);
 
 	  delete [] nm;
@@ -125,17 +125,17 @@ octave_list::print_raw (ostream& os, boo
     os << "()";
 
   newline (os);
 
   unwind_protect::run_frame ("octave_list_print");
 }
 
 bool
-octave_list::print_name_tag (ostream& os, const string& name) const
+octave_list::print_name_tag (std::ostream& os, const std::string& name) const
 {
   indent (os);
   if (lst.length () == 0)
     os << name << " = ";
   else
     {
       os << name << " =";
       newline (os);
diff --git a/src/ov-list.h b/src/ov-list.h
--- a/src/ov-list.h
+++ b/src/ov-list.h
@@ -72,21 +72,21 @@ public:
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_list (void) const { return true; }
 
   octave_value_list list_value (void) const { return lst; }
 
-  void print (ostream& os, bool pr_as_read_syntax = false) const;
+  void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
+  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  bool print_name_tag (ostream& os, const string& name) const;
+  bool print_name_tag (std::ostream& os, const std::string& name) const;
 
 private:
 
   // The list of Octave values.
   octave_value_list lst;
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 
diff --git a/src/ov-mapper.h b/src/ov-mapper.h
--- a/src/ov-mapper.h
+++ b/src/ov-mapper.h
@@ -47,18 +47,18 @@ public:
   typedef bool (*c_b_mapper) (const Complex&);
   typedef double (*d_d_mapper) (double);
   typedef double (*d_c_mapper) (const Complex&);
   typedef Complex (*c_c_mapper) (const Complex&);
 
   octave_mapper (ch_mapper ch, d_b_mapper db, c_b_mapper cb,
 		 d_d_mapper dd, d_c_mapper dc,
 		 c_c_mapper cc, double ll, double ul, int f,
-		 const string& nm = string (),
-		 const string& ds = string ())
+		 const std::string& nm = std::string (),
+		 const std::string& ds = std::string ())
     : octave_function (nm, ds), ch_map_fcn (ch),
       d_b_map_fcn (db), c_b_map_fcn (cb),
       d_d_map_fcn (dd), d_c_map_fcn (dc), c_c_map_fcn (cc),
       lower_limit (ll), upper_limit (ul), flag (f) { }
 
   ~octave_mapper (void) { }
 
   octave_function *function_value (bool) { return this; }
@@ -89,17 +89,17 @@ private:
 
   double lower_limit;
   double upper_limit;
 
   // For ch_map_fcn, flag has the following meanings:
   //
   //   0  =>  this function returns a matrix of ones and zeros
   //   1  =>  this function returns a numeric matrix (any values)
-  //   2  =>  this function returns a string array
+  //   2  =>  this function returns a std::string array
   //
   // For other mappers, nonzero means that this function can return a
   // complex value for some real arguments.
 
   int flag;
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -173,31 +173,31 @@ octave_range::complex_value (bool) const
 octave_value
 octave_range::convert_to_str (void) const
 {
   octave_value tmp (range.matrix_value ());
   return tmp.convert_to_str ();
 }
 
 void
-octave_range::print (ostream& os, bool pr_as_read_syntax) const
+octave_range::print (std::ostream& os, bool pr_as_read_syntax) const
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
 void
-octave_range::print_raw (ostream& os, bool pr_as_read_syntax) const
+octave_range::print_raw (std::ostream& os, bool pr_as_read_syntax) const
 {
   octave_print_internal (os, range, pr_as_read_syntax,
 			 current_print_indent_level ());
 }
 
 bool
-octave_range::print_name_tag (ostream& os, const string& name) const
+octave_range::print_name_tag (std::ostream& os, const std::string& name) const
 {
   bool retval = false;
 
   int n = range.nelem ();
 
   indent (os);
 
   if (n == 0 || n == 1)
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -134,21 +134,21 @@ public:
 
   ComplexMatrix complex_matrix_value (bool = false) const
     { return range.matrix_value (); }
 
   Range range_value (void) const { return range; }
 
   octave_value convert_to_str (void) const;
 
-  void print (ostream& os, bool pr_as_read_syntax = false) const;
+  void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
+  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  bool print_name_tag (ostream& os, const string& name) const;
+  bool print_name_tag (std::ostream& os, const std::string& name) const;
 
 private:
 
   Range range;
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 
   DECLARE_OCTAVE_ALLOCATOR
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -184,17 +184,17 @@ octave_char_matrix_str::all_strings (voi
 
 string
 octave_char_matrix_str::string_value (void) const
 {
   return matrix.row_as_string (0);  // XXX FIXME??? XXX
 }
 
 void
-octave_char_matrix_str::print_raw (ostream& os, bool pr_as_read_syntax) const
+octave_char_matrix_str::print_raw (std::ostream& os, bool pr_as_read_syntax) const
 {
   octave_print_internal (os, matrix, pr_as_read_syntax,
 			 current_print_indent_level (), true);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/ov-str-mat.h b/src/ov-str-mat.h
--- a/src/ov-str-mat.h
+++ b/src/ov-str-mat.h
@@ -60,17 +60,17 @@ public:
     : octave_char_matrix (chm) { }
 
   octave_char_matrix_str (char c)
     : octave_char_matrix (c) { }
 
   octave_char_matrix_str (const char *s)
     : octave_char_matrix (s) { }
 
-  octave_char_matrix_str (const string& s)
+  octave_char_matrix_str (const std::string& s)
     : octave_char_matrix (s) { }
 
   octave_char_matrix_str (const string_vector& s)
     : octave_char_matrix (s) { }
 
   octave_char_matrix_str (const octave_char_matrix& chm)
     : octave_char_matrix (chm) { }
 
@@ -96,21 +96,21 @@ public:
   bool is_numeric_type (void) const { return Vimplicit_str_to_num_ok; }
 
   bool valid_as_scalar_index (void) const;
 
   Matrix matrix_value (bool = false) const;
 
   string_vector all_strings (void) const;
 
-  string string_value (void) const;
+  std::string string_value (void) const;
 
   bool print_as_scalar (void) const { return (rows () <= 1); }
 
-  void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
+  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -36,52 +36,52 @@ Software Foundation, 59 Temple Place - S
 #include "unwind-prot.h"
 #include "variables.h"
 
 DEFINE_OCTAVE_ALLOCATOR(octave_struct);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(octave_struct, "struct");
 
 octave_value
-octave_struct::do_struct_elt_index_op (const string& nm,
+octave_struct::do_struct_elt_index_op (const std::string& nm,
 				       const octave_value_list& idx,
 				       bool silent)
 {
   // XXX DO_ME XXX
 }
 
 octave_value
-octave_struct::do_struct_elt_index_op (const string& nm, bool silent)
+octave_struct::do_struct_elt_index_op (const std::string& nm, bool silent)
 {
   octave_value retval;
 
   Pix idx = map.seek (nm);
 
   if (idx)
     retval = map.contents (idx);
   else if (! silent)
     error ("structure has no member `%s'", nm.c_str ());
 
   return retval;
 }
 
 octave_lvalue
-octave_struct::struct_elt_ref (octave_value *, const string& nm)
+octave_struct::struct_elt_ref (octave_value *, const std::string& nm)
 {
   return octave_lvalue (&map [nm]);
 }
 
 void
-octave_struct::print (ostream& os, bool) const
+octave_struct::print (std::ostream& os, bool) const
 {
   print_raw (os);
 }
 
 void
-octave_struct::print_raw (ostream& os, bool) const
+octave_struct::print_raw (std::ostream& os, bool) const
 {
   // XXX FIXME XXX -- would be nice to print the output in some
   // standard order.  Maybe all substructures first, maybe
   // alphabetize entries, etc.
 
   unwind_protect::begin_frame ("octave_struct_print");
 
   unwind_protect_int (Vstruct_levels_to_print);
@@ -91,17 +91,17 @@ octave_struct::print_raw (ostream& os, b
       indent (os);
       os << "{";
       newline (os);
 
       increment_indent_level ();
 
       for (Pix p = map.first (); p; map.next (p))
 	{
-	  string key = map.key (p);
+	  std::string key = map.key (p);
 	  octave_value val = map.contents (p);
 
 	  val.print_with_name (os, key);
 	}
 
       decrement_indent_level ();
 
       indent (os);
@@ -113,17 +113,17 @@ octave_struct::print_raw (ostream& os, b
       os << " <structure>";
       newline (os);
     }
 
   unwind_protect::run_frame ("octave_struct_print");
 }
 
 bool
-octave_struct::print_name_tag (ostream& os, const string& name) const
+octave_struct::print_name_tag (std::ostream& os, const std::string& name) const
 {
   indent (os);
   os << name << " =";
   newline (os);
   return false;
 }
 
 /*
diff --git a/src/ov-struct.h b/src/ov-struct.h
--- a/src/ov-struct.h
+++ b/src/ov-struct.h
@@ -62,36 +62,36 @@ public:
   octave_struct (const octave_struct& s)
     : octave_base_value (), map (s.map) { }
 
   ~octave_struct (void) { }
 
   octave_value *clone (void) { return new octave_struct (*this); }
 
   octave_value
-  do_struct_elt_index_op (const string& nm, const octave_value_list& idx,
+  do_struct_elt_index_op (const std::string& nm, const octave_value_list& idx,
 			  bool silent);
 
-  octave_value do_struct_elt_index_op (const string& nm, bool silent);
+  octave_value do_struct_elt_index_op (const std::string& nm, bool silent);
 
-  octave_lvalue struct_elt_ref (octave_value *parent, const string& nm);
+  octave_lvalue struct_elt_ref (octave_value *parent, const std::string& nm);
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return false; }
 
   bool is_map (void) const { return true; }
 
   Octave_map map_value (void) const { return map; }
 
-  void print (ostream& os, bool pr_as_read_syntax = false) const;
+  void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
+  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  bool print_name_tag (ostream& os, const string& name) const;
+  bool print_name_tag (std::ostream& os, const std::string& name) const;
 
 private:
 
   // The associative array used to manage the structure data.
   Octave_map map;
 
   DECLARE_OCTAVE_ALLOCATOR
 
diff --git a/src/ov-typeinfo.cc b/src/ov-typeinfo.cc
--- a/src/ov-typeinfo.cc
+++ b/src/ov-typeinfo.cc
@@ -74,17 +74,17 @@ octave_value_typeinfo::instance_ok (void
 
       retval = false;
     }
 
   return retval;
 }
 
 int
-octave_value_typeinfo::register_type (const string& name)
+octave_value_typeinfo::register_type (const std::string& name)
 {
   return (instance_ok ())
     ? instance->do_register_type (name) : -1;
 }
 
 bool
 octave_value_typeinfo::register_unary_op (octave_value::unary_op op,
 					   int t, unary_op_fcn f)
@@ -140,31 +140,31 @@ bool
 octave_value_typeinfo::register_widening_op (int t, int t_result,
 					     type_conv_fcn f)
 {
   return (instance_ok ())
     ? instance->do_register_widening_op (t, t_result, f) : false;
 }
 
 int
-octave_value_typeinfo::do_register_type (const string& name)
+octave_value_typeinfo::do_register_type (const std::string& name)
 {
   int i = 0;
 
   for (i = 0; i < num_types; i++)
     if (name == types (i))
       return i;
 
   int len = types.length ();
 
   if (i == len)
     {
       len *= 2;
 
-      types.resize (len, string ());
+      types.resize (len, std::string ());
 
       unary_ops.resize (static_cast<int> (octave_value::num_unary_ops),
 			len, static_cast<unary_op_fcn> (0));
 
       non_const_unary_ops.resize
 	(static_cast<int> (octave_value::num_unary_ops),
 	 len, static_cast<non_const_unary_op_fcn> (0));
 
diff --git a/src/ov-typeinfo.h b/src/ov-typeinfo.h
--- a/src/ov-typeinfo.h
+++ b/src/ov-typeinfo.h
@@ -39,17 +39,17 @@ class string_vector;
 
 class
 octave_value_typeinfo
 {
 public:
 
   static bool instance_ok (void);
 
-  static int register_type (const string&);
+  static int register_type (const std::string&);
 
   static bool register_unary_op (octave_value::unary_op, int, unary_op_fcn);
 
   static bool register_non_const_unary_op (octave_value::unary_op, int,
 					   non_const_unary_op_fcn);
 
   static bool register_binary_op (octave_value::binary_op, int, int,
 				  binary_op_fcn);
@@ -109,17 +109,17 @@ public:
   static string_vector installed_type_names (void)
   {
     return instance->do_installed_type_names ();
   }
 
 protected:
 
   octave_value_typeinfo (void)
-    : num_types (0), types (init_tab_sz, string ()),
+    : num_types (0), types (init_tab_sz, std::string ()),
       unary_ops (octave_value::num_unary_ops, init_tab_sz,
 		 (unary_op_fcn) 0),
       non_const_unary_ops (octave_value::num_unary_ops, init_tab_sz,
 			   (non_const_unary_op_fcn) 0),
       binary_ops (octave_value::num_binary_ops, init_tab_sz,
 		  init_tab_sz, (binary_op_fcn) 0),
       assign_ops (octave_value::num_assign_ops, init_tab_sz,
 		  init_tab_sz, (assign_op_fcn) 0),
@@ -131,33 +131,33 @@ protected:
 private:
 
   static const int init_tab_sz;
 
   static octave_value_typeinfo *instance;
 
   int num_types;
 
-  Array<string> types;
+  Array<std::string> types;
 
   Array2<unary_op_fcn> unary_ops;
 
   Array2<non_const_unary_op_fcn> non_const_unary_ops;
 
   Array3<binary_op_fcn> binary_ops;
 
   Array3<assign_op_fcn> assign_ops;
 
   Array2<assign_op_fcn> assignany_ops;
 
   Array2<int> pref_assign_conv;
 
   Array2<type_conv_fcn> widening_ops;
 
-  int do_register_type (const string&);
+  int do_register_type (const std::string&);
 
   bool do_register_unary_op (octave_value::unary_op, int, unary_op_fcn);
 
   bool do_register_non_const_unary_op (octave_value::unary_op, int,
 				       non_const_unary_op_fcn);
 
   bool do_register_binary_op (octave_value::binary_op, int, int,
 			      binary_op_fcn);
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -69,17 +69,17 @@ DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (oct
 				     "user-defined function");
 
 // Ugh.  This really needs to be simplified (code/data?
 // extrinsic/intrinsic state?).
 
 octave_user_function::octave_user_function
   (tree_parameter_list *pl, tree_parameter_list *rl,
    tree_statement_list *cl, symbol_table *st)
-  : octave_function (string (), string ()),
+  : octave_function (std::string (), std::string ()),
     param_list (pl), ret_list (rl), cmd_list (cl),
     sym_tab (st), file_name (), fcn_name (),
     t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     system_fcn_file (false), call_depth (0),
     num_named_args (0), args_passed (), num_args_passed (0),
     curr_va_arg_number (0), vr_list (0), symtab_entry (0),
     argn_sr (0), nargin_sr (0), nargout_sr (0)
@@ -131,17 +131,17 @@ octave_user_function::mark_as_system_fcn
       // when we looked it up, to avoid possible race conditions...
       // XXX FIXME XXX
       //
       // We probably also don't need to get the library directory
       // every time, but since this function is only called when the
       // function file is parsed, it probably doesn't matter that
       // much.
 
-      string ff_name = fcn_file_in_path (file_name);
+      std::string ff_name = fcn_file_in_path (file_name);
 
       if (Vfcn_file_dir.compare (ff_name, 0, Vfcn_file_dir.length ()) == 0)
 	system_fcn_file = 1;
     }
   else
     system_fcn_file = 0;
 }
 
@@ -194,17 +194,17 @@ void
 octave_user_function::octave_vr_val (const octave_value& val)
 {
   assert (vr_list);
 
   vr_list->append (val);
 }
 
 void
-octave_user_function::stash_function_name (const string& s)
+octave_user_function::stash_function_name (const std::string& s)
 {
   fcn_name = s;
 }
 
 // For unwind protect.
 
 static void
 pop_symbol_table_context (void *table)
diff --git a/src/ov-usr-fcn.h b/src/ov-usr-fcn.h
--- a/src/ov-usr-fcn.h
+++ b/src/ov-usr-fcn.h
@@ -73,17 +73,17 @@ public:
     {
       t_parsed = t;
       mark_fcn_file_up_to_date (t);
     }
 
   void stash_symtab_ptr (symbol_record *sr)
     { symtab_entry = sr; }
 
-  string fcn_file_name (void) const
+  std::string fcn_file_name (void) const
     { return file_name; }
 
   octave_time time_parsed (void) const
     { return t_parsed; }
 
   octave_time time_checked (void) const
     { return t_checked; }
 
@@ -100,19 +100,19 @@ public:
   octave_value octave_va_arg (void);
 
   octave_value_list octave_all_va_args (void);
 
   bool takes_var_return (void) const;
 
   void octave_vr_val (const octave_value& val);
 
-  void stash_function_name (const string& s);
+  void stash_function_name (const std::string& s);
 
-  string function_name (void)
+  std::string function_name (void)
     { return fcn_name; }
 
   void clear_args_passed (void)
     { args_passed = octave_value_list (); }
 
   octave_value_list do_index_op (int nargout, const octave_value_list& args);
 
   void traceback_error (void);
@@ -140,20 +140,20 @@ private:
 
   // The list of commands that make up the body of this function.
   tree_statement_list *cmd_list;
 
   // The local symbol table for this function.
   symbol_table *sym_tab;
 
   // The name of the file we parsed
-  string file_name;
+  std::string file_name;
 
   // The name of the function.
-  string fcn_name;
+  std::string fcn_name;
 
   // The time the file was parsed.
   octave_time t_parsed;
 
   // The time the file was last checked to see if it needs to be
   // parsed again.
   octave_time t_checked;
 
diff --git a/src/ov-va-args.cc b/src/ov-va-args.cc
--- a/src/ov-va-args.cc
+++ b/src/ov-va-args.cc
@@ -32,24 +32,24 @@ Software Foundation, 59 Temple Place - S
 
 #include "error.h"
 #include "pr-output.h"
 #include "ov-va-args.h"
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_all_va_args, "va-arg");
 
 void
-octave_all_va_args::print (ostream& os, bool) const
+octave_all_va_args::print (std::ostream& os, bool) const
 {
   indent (os);
   print (os);
 }
 
 void
-octave_all_va_args::print_raw (ostream& os, bool) const
+octave_all_va_args::print_raw (std::ostream& os, bool) const
 {
   os << "all_va_args";
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-va-args.h b/src/ov-va-args.h
--- a/src/ov-va-args.h
+++ b/src/ov-va-args.h
@@ -56,19 +56,19 @@ public:
   ~octave_all_va_args (void) { }
 
   octave_value *clone (void) { return new octave_all_va_args (*this); }
 
   bool is_defined (void) const { return true; }
 
   bool is_all_va_args (void) const { return true; }
 
-  void print (ostream& os, bool pr_as_read_syntax = false) const;
+  void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
-  void print_raw (ostream& os, bool pr_as_read_syntax = false) const;
+  void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
 private:
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -119,17 +119,17 @@ bool Vresize_on_range_error;
 
 // XXX FIXME XXX
 
 // Octave's value type.
 
 string
 octave_value::unary_op_as_string (unary_op op)
 {
-  string retval;
+  std::string retval;
 
   switch (op)
     {
     case not:
       retval = "!";
       break;
 
     case uminus:
@@ -157,17 +157,17 @@ octave_value::unary_op_as_string (unary_
     }
 
   return retval;
 }
 
 string
 octave_value::binary_op_as_string (binary_op op)
 {
-  string retval;
+  std::string retval;
 
   switch (op)
     {
     case add:
       retval = "+";
       break;
 
     case sub:
@@ -255,17 +255,17 @@ octave_value::binary_op_as_string (binar
     }
 
   return retval;
 }
 
 string
 octave_value::assign_op_as_string (assign_op op)
 {
-  string retval;
+  std::string retval;
 
   switch (op)
     {
     case asn_eq:
       retval = "=";
       break;
 
     case add_eq:
@@ -427,17 +427,17 @@ octave_value::octave_value (char c)
 
 octave_value::octave_value (const char *s)
   : rep (new octave_char_matrix_str (s))
 {
   rep->count = 1;
   maybe_mutate ();
 }
 
-octave_value::octave_value (const string& s)
+octave_value::octave_value (const std::string& s)
   : rep (new octave_char_matrix_str (s))
 {
   rep->count = 1;
   maybe_mutate ();
 }
 
 octave_value::octave_value (const string_vector& s)
   : rep (new octave_char_matrix_str (s))
@@ -551,32 +551,32 @@ octave_value::maybe_mutate (void)
 
 octave_value_list
 octave_value::do_index_op (int nargout, const octave_value_list& idx)
 {
   return rep->do_index_op (nargout, idx);
 }
 
 static void
-gripe_no_conversion (const string& on, const string& tn1, const string& tn2)
+gripe_no_conversion (const std::string& on, const std::string& tn1, const std::string& tn2)
 {
   error ("operator %s: no conversion for assignment of `%s' to indexed `%s'",
 	 on.c_str (), tn2.c_str (), tn1.c_str ());
 }
 
 static void
-gripe_assign_failed (const string& on, const string& tn1, const string& tn2)
+gripe_assign_failed (const std::string& on, const std::string& tn1, const std::string& tn2)
 {
   error ("assignment failed for `%s %s %s'",
 	 tn1.c_str (), on.c_str (), tn2.c_str ());
 }
 
 static void
-gripe_assign_failed_or_no_method (const string& on, const string& tn1,
-				  const string& tn2)
+gripe_assign_failed_or_no_method (const std::string& on, const std::string& tn1,
+				  const std::string& tn2)
 {
   error ("assignment failed, or no method for `%s %s %s'",
 	 tn1.c_str (), on.c_str (), tn2.c_str ());
 }
 
 void
 octave_value::assign (assign_op op, const octave_value& rhs)
 {
@@ -679,43 +679,43 @@ octave_value::assign (octave_value::assi
   else
     {
       error ("indexed assignment to previously undefined variables");
       error ("is only possible when resize_on_range_error is true");
     }
 }
 
 void
-octave_value::assign_struct_elt (assign_op op, const string& elt_nm,
+octave_value::assign_struct_elt (assign_op op, const std::string& elt_nm,
 				 const octave_value& rhs)
 {
   make_unique ();
 
   rep->assign_struct_elt (op, elt_nm, rhs);
 }
 
 
 void
-octave_value::assign_struct_elt (assign_op op, const string& elt_nm,
+octave_value::assign_struct_elt (assign_op op, const std::string& elt_nm,
 				 const octave_value_list& idx,
 				 const octave_value& rhs)
 {
   make_unique ();
 
   rep->assign_struct_elt (op, elt_nm, idx, rhs);
 }
 
 octave_lvalue
-octave_value::struct_elt_ref (const string& nm)
+octave_value::struct_elt_ref (const std::string& nm)
 {
   return rep->struct_elt_ref (this, nm);
 }
 
 octave_lvalue
-octave_value::struct_elt_ref (octave_value *, const string&)
+octave_value::struct_elt_ref (octave_value *, const std::string&)
 {
   panic_impossible ();
 
   return octave_lvalue ();
 }
 
 Cell
 octave_value::cell_value (void) const
@@ -770,17 +770,17 @@ octave_value::column_vector_value (bool 
   if (nc == 1)
     {
       retval.resize (nr);
       for (int i = 0; i < nr; i++)
 	retval (i) = m (i, 0);
     }
   else
     {
-      string tn = type_name ();
+      std::string tn = type_name ();
       gripe_invalid_conversion (tn.c_str (), "real column vector");
     }
 
   return retval;
 }
 
 ComplexColumnVector
 octave_value::complex_column_vector_value (bool force_string_conv,
@@ -799,17 +799,17 @@ octave_value::complex_column_vector_valu
   if (nc == 1)
     {
       retval.resize (nr);
       for (int i = 0; i < nr; i++)
 	retval (i) = m (i, 0);
     }
   else
     {
-      string tn = type_name ();
+      std::string tn = type_name ();
       gripe_invalid_conversion (tn.c_str (), "complex column vector");
     }
 
   return retval;
 }
 
 RowVector
 octave_value::row_vector_value (bool force_string_conv,
@@ -828,17 +828,17 @@ octave_value::row_vector_value (bool for
   if (nr == 1)
     {
       retval.resize (nc);
       for (int i = 0; i < nc; i++)
 	retval (i) = m (0, i);
     }
   else
     {
-      string tn = type_name ();
+      std::string tn = type_name ();
       gripe_invalid_conversion (tn.c_str (), "real row vector");
     }
 
   return retval;
 }
 
 ComplexRowVector
 octave_value::complex_row_vector_value (bool force_string_conv,
@@ -857,17 +857,17 @@ octave_value::complex_row_vector_value (
   if (nr == 1)
     {
       retval.resize (nc);
       for (int i = 0; i < nc; i++)
 	retval (i) = m (0, i);
     }
   else
     {
-      string tn = type_name ();
+      std::string tn = type_name ();
       gripe_invalid_conversion (tn.c_str (), "complex row vector");
     }
 
   return retval;
 }
 
 // Sloppy...
 
@@ -903,17 +903,17 @@ octave_value::vector_value (bool force_s
       retval.resize (nr * nc);
       int k = 0;
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  retval (k++) = m (i, j);
     }
   else
     {
-      string tn = type_name ();
+      std::string tn = type_name ();
       gripe_invalid_conversion (tn.c_str (), "real vector");
     }
 
   return retval;
 }
 
 Array<Complex>
 octave_value::complex_vector_value (bool force_string_conv,
@@ -947,44 +947,44 @@ octave_value::complex_vector_value (bool
       retval.resize (nr * nc);
       int k = 0;
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  retval (k++) = m (i, j);
     }
   else
     {
-      string tn = type_name ();
+      std::string tn = type_name ();
       gripe_invalid_conversion (tn.c_str (), "complex vector");
     }
 
   return retval;
 }
 
 void
-octave_value::print_with_name (ostream& output_buf, const string& name,
+octave_value::print_with_name (std::ostream& output_buf, const std::string& name,
 			       bool print_padding) const
 {
   bool pad_after = print_name_tag (output_buf, name);
 
   print (output_buf);
 
   if (print_padding && pad_after)
     newline (output_buf);
 }
 
 static void
-gripe_indexed_assignment (const string& tn1, const string& tn2)
+gripe_indexed_assignment (const std::string& tn1, const std::string& tn2)
 {
   error ("assignment of `%s' to indexed `%s' not implemented",
 	 tn2.c_str (), tn1.c_str ());
 }
 
 static void
-gripe_assign_conversion_failed (const string& tn1, const string& tn2)
+gripe_assign_conversion_failed (const std::string& tn1, const std::string& tn2)
 {
   error ("type conversion for assignment of `%s' to indexed `%s' failed",
 	 tn2.c_str (), tn1.c_str ());
 }
 
 bool
 octave_value::convert_and_assign (octave_value::assign_op op,
 				  const octave_value_list& idx,
@@ -1139,24 +1139,24 @@ octave_value::try_assignment (octave_val
 	  retval = (! error_state);
 	}
     }
 
   return retval;
 }
 
 static void
-gripe_binary_op (const string& on, const string& tn1, const string& tn2)
+gripe_binary_op (const std::string& on, const std::string& tn1, const std::string& tn2)
 {
   error ("binary operator `%s' not implemented for `%s' by `%s' operations",
 	 on.c_str (), tn1.c_str (), tn2.c_str ());
 }
 
 static void
-gripe_binary_op_conv (const string& on)
+gripe_binary_op_conv (const std::string& on)
 {
   error ("type conversion failed for binary operator `%s'", on.c_str ());
 }
 
 octave_value
 do_binary_op (octave_value::binary_op op, const octave_value& v1,
 	      const octave_value& v2)
 {
@@ -1228,24 +1228,24 @@ do_binary_op (octave_value::binary_op op
 	gripe_binary_op (octave_value::binary_op_as_string (op),
 			 v1.type_name (), v2.type_name ());
     }
 
   return retval;
 }
 
 static void
-gripe_unary_op (const string& on, const string& tn)
+gripe_unary_op (const std::string& on, const std::string& tn)
 {
   error ("unary operator `%s' not implemented for `%s' operands",
 	 on.c_str (), tn.c_str ());
 }
 
 static void
-gripe_unary_op_conv (const string& on)
+gripe_unary_op_conv (const std::string& on)
 {
   error ("type conversion failed for unary operator `%s'", on.c_str ());
 }
 
 octave_value
 do_unary_op (octave_value::unary_op op, const octave_value& v)
 {
   octave_value retval;
@@ -1285,17 +1285,17 @@ do_unary_op (octave_value::unary_op op, 
 	gripe_unary_op (octave_value::unary_op_as_string (op),
 			v.type_name ());
     }
 
   return retval;
 }
 
 static void
-gripe_unary_op_conversion_failed (const string& op, const string& tn)
+gripe_unary_op_conversion_failed (const std::string& op, const std::string& tn)
 {
   error ("operator %s: type conversion for `%s' failed",
 	 op.c_str (), tn.c_str ());
 }
 
 void
 octave_value::do_non_const_unary_op (octave_value::unary_op op)
 {
@@ -1356,17 +1356,17 @@ octave_value::do_non_const_unary_op (oct
 	      (octave_value::unary_op_as_string (op), type_name ());
 	}
       else
 	gripe_unary_op (octave_value::unary_op_as_string (op), type_name ());
     }
 }
 
 static void
-gripe_unary_op_failed_or_no_method (const string& on, const string& tn)
+gripe_unary_op_failed_or_no_method (const std::string& on, const std::string& tn)
 {
   error ("operator %s: no method, or unable to evaluate for %s operand",
 	 on.c_str (), tn.c_str ());
 }
 
 void
 octave_value::do_non_const_unary_op (octave_value::unary_op op,
 				     const octave_value_list& idx)
@@ -1390,17 +1390,17 @@ int octave_value::curr_print_indent_leve
 // TRUE means we are at the beginning of a line.
 bool octave_value::beginning_of_line = true;
 
 // Each print() function should call this before printing anything.
 //
 // This doesn't need to be fast, but isn't there a better way?
 
 void
-octave_value::indent (ostream& os) const
+octave_value::indent (std::ostream& os) const
 {
   assert (curr_print_indent_level >= 0);
  
   if (beginning_of_line)
     {
       // XXX FIXME XXX -- do we need this?
       // os << prefix;
 
@@ -1409,17 +1409,17 @@ octave_value::indent (ostream& os) const
 
       beginning_of_line = false;
     }
 }
 
 // All print() functions should use this to print new lines.
 
 void
-octave_value::newline (ostream& os) const
+octave_value::newline (std::ostream& os) const
 {
   os << "\n";
 
   beginning_of_line = true;
 }
 
 // For ressetting print state.
 
@@ -1442,17 +1442,17 @@ octave_value::unary_op_to_assign_op (una
       break;
 
     case decr:
       binop = sub_eq;
       break;
 
     default:
       {
-	string on = unary_op_as_string (op);
+	std::string on = unary_op_as_string (op);
 	error ("operator %s: no assign operator found", on.c_str ());
       }
     }
 
   return binop;
 }
 
 octave_value::binary_op 
@@ -1507,17 +1507,17 @@ octave_value::op_eq_to_binary_op (assign
       break;
 
     case el_or_eq:
       binop = el_or;
       break;
 
     default:
       {
-	string on = assign_op_as_string (op);
+	std::string on = assign_op_as_string (op);
 	error ("operator %s: no binary operator found", on.c_str ());
       }
     }
 
   return binop;
 }
 
 void
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -136,21 +136,21 @@ public:
     el_div_eq,
     el_ldiv_eq,
     el_and_eq,
     el_or_eq,
     num_assign_ops,
     unknown_assign_op
   };
 
-  static string unary_op_as_string (unary_op);
+  static std::string unary_op_as_string (unary_op);
 
-  static string binary_op_as_string (binary_op);
+  static std::string binary_op_as_string (binary_op);
 
-  static string assign_op_as_string (assign_op);
+  static std::string assign_op_as_string (assign_op);
 
   enum magic_colon { magic_colon_t };
   enum all_va_args { all_va_args_t };
 
   octave_value (void);
   octave_value (double d);
   octave_value (const Cell& m);
   octave_value (const Matrix& m);
@@ -161,17 +161,17 @@ public:
   octave_value (const ComplexMatrix& m);
   octave_value (const ComplexDiagMatrix& d);
   octave_value (const ComplexRowVector& v);
   octave_value (const ComplexColumnVector& v);
   octave_value (bool b);
   octave_value (const boolMatrix& bm);
   octave_value (char c);
   octave_value (const char *s);
-  octave_value (const string& s);
+  octave_value (const std::string& s);
   octave_value (const string_vector& s);
   octave_value (const charMatrix& chm, bool is_string = false);
   octave_value (double base, double limit, double inc);
   octave_value (const Range& r);
   octave_value (const Octave_map& m);
   octave_value (const octave_stream& s, int n);
   octave_value (octave_function *f);
   octave_value (const octave_value_list& m);
@@ -240,39 +240,39 @@ public:
   do_index_op (int nargout, const octave_value_list& idx);
 
   void assign (assign_op, const octave_value& rhs);
 
   void assign (assign_op, const octave_value_list& idx,
 	       const octave_value& rhs);
 
   virtual void
-  assign_struct_elt (assign_op, const string& elt_nm,
+  assign_struct_elt (assign_op, const std::string& elt_nm,
 		     const octave_value& rhs);
 
   virtual void
-  assign_struct_elt (assign_op, const string& elt_nm,
+  assign_struct_elt (assign_op, const std::string& elt_nm,
 		     const octave_value_list& idx, const octave_value& rhs);
 
   virtual idx_vector index_vector (void) const
     { return rep->index_vector (); }
 
   virtual octave_value
-  do_struct_elt_index_op (const string& nm, bool silent = false)
+  do_struct_elt_index_op (const std::string& nm, bool silent = false)
     { return rep->do_struct_elt_index_op (nm, silent); }
 
   virtual octave_value
-  do_struct_elt_index_op (const string& nm, const octave_value_list& idx,
+  do_struct_elt_index_op (const std::string& nm, const octave_value_list& idx,
 			  bool silent = false)
     { return rep->do_struct_elt_index_op (nm, idx, silent); }
 
-  octave_lvalue struct_elt_ref (const string& nm);
+  octave_lvalue struct_elt_ref (const std::string& nm);
 
   virtual octave_lvalue
-  struct_elt_ref (octave_value *parent, const string& nm);
+  struct_elt_ref (octave_value *parent, const std::string& nm);
 
   // Size.
 
   virtual int rows (void) const
     { return rep->rows (); }
 
   virtual int columns (void) const
     { return rep->columns (); }
@@ -418,17 +418,17 @@ public:
     { return rep->complex_matrix_value (frc_str_conv); }
 
   virtual charMatrix char_matrix_value (bool frc_str_conv = false) const
     { return rep->char_matrix_value (frc_str_conv); }
 
   virtual string_vector all_strings (void) const
     { return rep->all_strings (); }
 
-  virtual string string_value (void) const
+  virtual std::string string_value (void) const
     { return rep->string_value (); }
 
   virtual Range range_value (void) const
     { return rep->range_value (); }
 
   virtual Octave_map map_value (void) const;
 
   virtual octave_stream stream_value (void) const;
@@ -470,31 +470,31 @@ public:
   // it, and we should convert it if possible.
 
   virtual octave_value convert_to_str (void) const
     { return rep->convert_to_str (); }
 
   virtual void convert_to_row_or_column_vector (void)
     { rep->convert_to_row_or_column_vector (); }
 
-  virtual void print (ostream& os, bool pr_as_read_syntax = false) const
+  virtual void print (std::ostream& os, bool pr_as_read_syntax = false) const
     { rep->print (os, pr_as_read_syntax); }
 
-  virtual void print_raw (ostream& os, bool pr_as_read_syntax = false) const
+  virtual void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const
     { rep->print_raw (os, pr_as_read_syntax); }
 
-  virtual bool print_name_tag (ostream& os, const string& name) const
+  virtual bool print_name_tag (std::ostream& os, const std::string& name) const
     { return rep->print_name_tag (os, name); }
 
-  void print_with_name (ostream& os, const string& name,
+  void print_with_name (std::ostream& os, const std::string& name,
 			bool print_padding = true) const;
 
   virtual int type_id (void) const { return rep->type_id (); }
 
-  virtual string type_name (void) const { return rep->type_name (); }
+  virtual std::string type_name (void) const { return rep->type_name (); }
 
   // Unary and binary operations.
 
   friend octave_value do_unary_op (octave_value::unary_op,
 				   const octave_value&);
 
   void do_non_const_unary_op (octave_value::unary_op);
 
@@ -518,19 +518,19 @@ protected:
     { curr_print_indent_level += 2; }
 
   void decrement_indent_level (void) const
     { curr_print_indent_level -= 2; }
 
   int current_print_indent_level (void) const
     { return curr_print_indent_level; }
 
-  void newline (ostream& os) const;
+  void newline (std::ostream& os) const;
 
-  void indent (ostream& os) const;
+  void indent (std::ostream& os) const;
 
   void reset (void) const;
 
 private:
 
   union
     {
       octave_value *rep;      // The real representation.
@@ -633,28 +633,28 @@ OV_BINOP_FN (el_or)
 
 OV_BINOP_FN (struct_ref)
 
 // T_ID is the type id of struct objects, set by register_type().
 // T_NAME is the type name of struct objects.
 #define DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA \
   public: \
     int type_id (void) const { return t_id; } \
-    string type_name (void) const { return t_name; } \
+    std::string type_name (void) const { return t_name; } \
     static volatile int static_type_id (void) { return t_id; } \
     static void register_type (void) \
       { t_id = octave_value_typeinfo::register_type (t_name); } \
  \
   private: \
     static volatile int t_id; \
-    static const string t_name;
+    static const std::string t_name;
 
 #define DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA(t, n) \
   volatile int t::t_id (-1); \
-  const string t::t_name (n)
+  const std::string t::t_name (n)
 
 // If TRUE, allow assignments like
 //
 //   octave> A(1) = 3; A(2) = 5
 //
 // for A already defined and a matrix type.
 extern bool Vdo_fortran_indexing;
 
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -50,23 +50,23 @@ static pid_t octave_pager_pid = -1;
 
 // Our actual connection to the external pager.
 static oprocstream *external_pager = 0;
 
 // TRUE means we write to the diary file.
 static bool write_to_diary_file = false;
 
 // The name of the current diary file.
-static string diary_file;
+static std::string diary_file;
 
 // The diary file.
-static ofstream external_diary_file;
+static std::ofstream external_diary_file;
 
 // The shell command to run as the pager.
-static string Vpager_binary;
+static std::string Vpager_binary;
 
 // TRUE means that if output is going to the pager, it is sent as soon
 // as it is available.  Otherwise, it is buffered and only sent to the
 // pager when it is time to print another prompt.
 static bool Vpage_output_immediately;
 
 // TRUE means all output intended for the screen should be passed
 // through the pager.
@@ -124,17 +124,17 @@ do_sync (const char *msg, int len, bool 
 	{
 	  cout.write (msg, len);
 	  cout.flush ();
 	}
       else
 	{
 	  if (! external_pager)
 	    {
-	      string pgr = Vpager_binary;
+	      std::string pgr = Vpager_binary;
 
 	      if (! pgr.empty ())
 		{
 		  saved_interrupt_handler = octave_ignore_interrupts ();
 		  interrupt_handler_saved = true;
 
 		  external_pager = new oprocstream (pgr.c_str ());
 
@@ -273,17 +273,17 @@ octave_diary_buf::sync (void)
 
   seekoff (0, ios::beg);
 
   return 0;
 }
 
 octave_pager_stream *octave_pager_stream::instance = 0;
 
-octave_pager_stream::octave_pager_stream (void) : ostream (), pb (0)
+octave_pager_stream::octave_pager_stream (void) : std::ostream (), pb (0)
 {
   pb = new octave_pager_buf;
   rdbuf (pb);
   setf (unitbuf);
 }
 
 octave_pager_stream::~octave_pager_stream (void)
 {
@@ -304,17 +304,17 @@ void
 octave_pager_stream::flush_current_contents_to_diary (void)
 {
   if (pb)
     pb->flush_current_contents_to_diary ();
 }
 
 octave_diary_stream *octave_diary_stream::instance = 0;
 
-octave_diary_stream::octave_diary_stream (void) : ostream (), db (0)
+octave_diary_stream::octave_diary_stream (void) : std::ostream (), db (0)
 {
   db = new octave_diary_buf;
   rdbuf (db);
   setf (unitbuf);
 }
 
 octave_diary_stream::~octave_diary_stream (void)
 {
@@ -424,17 +424,17 @@ Without any arguments, @code{diary} togg
     {
     case 1:
       write_to_diary_file = ! write_to_diary_file;
       open_diary_file ();
       break;
 
     case 2:
       {
-	string arg = argv[1];
+	std::string arg = argv[1];
 
 	if (arg == "on")
 	  {
 	    write_to_diary_file = true;
 	    open_diary_file ();
 	  }	
 	else if (arg == "off")
 	  {
@@ -473,17 +473,17 @@ toggles the current state.\n\
 
   string_vector argv = args.make_argv ("more");
 
   if (error_state)
     return retval;
 
   if (argc == 2)
     {
-      string arg = argv[1];
+      std::string arg = argv[1];
 
       if (arg == "on")
 	bind_builtin_variable ("page_screen_output", 1.0);
       else if (arg == "off")
 	bind_builtin_variable ("page_screen_output", 0.0);
       else
 	error ("more: unrecognized argument `%s'", arg.c_str ());
     }
@@ -491,44 +491,44 @@ toggles the current state.\n\
     print_usage ("more");
 
   return retval;
 }
 
 static string
 default_pager (void)
 {
-  string pager_binary = octave_env::getenv ("PAGER");
+  std::string pager_binary = octave_env::getenv ("PAGER");
 
 #ifdef DEFAULT_PAGER
   if (pager_binary.empty ())
     {
-      pager_binary = string (DEFAULT_PAGER);
+      pager_binary = std::string (DEFAULT_PAGER);
 
       if (pager_binary == "less")
 	{
 	  pager_binary.append (" -e");
 
-	  string lessflags = octave_env::getenv ("LESS");
+	  std::string lessflags = octave_env::getenv ("LESS");
 	  if (lessflags.empty ())
 	    pager_binary.append
 	      (" -P'-- less ?pB(%pB\\%):--. (f)orward, (b)ack, (q)uit$'");
 	}
     }
 #endif
 
   return pager_binary;
 }
 
 static int
 pager_binary (void)
 {
   int status = 0;
 
-  string s = builtin_string_variable ("PAGER");
+  std::string s = builtin_string_variable ("PAGER");
 
   if (s.empty ())
     {
       gripe_invalid_value_specified ("PAGER");
       status = -1;
     }
   else
     Vpager_binary = s;
diff --git a/src/pager.h b/src/pager.h
--- a/src/pager.h
+++ b/src/pager.h
@@ -27,21 +27,21 @@ Software Foundation, 59 Temple Place - S
 #include <strstream>
 #include <string>
 
 #ifdef HAVE_SYS_TYPES_H
 #include <sys/types.h>
 #endif
 
 class
-octave_pager_buf : public strstreambuf
+octave_pager_buf : public std::strstreambuf
 {
 public:
 
-  octave_pager_buf (int size = 0) : strstreambuf (size) { }
+  octave_pager_buf (int size = 0) : std::strstreambuf (size) { }
 
   void flush_current_contents_to_diary (void);
 
 protected:
 
   int sync (void);
 };
 
@@ -69,21 +69,21 @@ private:
   // No copying!
 
   octave_pager_stream (const octave_pager_stream&);
 
   octave_pager_stream& operator = (const octave_pager_stream&);
 };
 
 class
-octave_diary_buf : public strstreambuf
+octave_diary_buf : public std::strstreambuf
 {
 public:
 
-  octave_diary_buf (int size = 0) : strstreambuf (size) { }
+  octave_diary_buf (int size = 0) : std::strstreambuf (size) { }
 
 protected:
 
   int sync (void);
 };
 
 class
 octave_diary_stream : public ostream
diff --git a/src/parse.h b/src/parse.h
--- a/src/parse.h
+++ b/src/parse.h
@@ -49,17 +49,17 @@ extern int yydebug;
 
 // The current input line number.
 extern int input_line_number;
 
 // The column of the current token.
 extern int current_input_column;
 
 // Buffer for help text snagged from function files.
-extern string help_buf;
+extern std::string help_buf;
 
 // TRUE means we are using readline.
 extern bool line_editing;
 
 // TRUE means we printed messages about reading startup files.
 extern bool reading_startup_message_printed;
 
 // TRUE means input is coming from startup file.
@@ -76,35 +76,35 @@ extern bool evaluating_function_body;
 
 // TRUE means warn about function files that have time stamps in the future.
 extern bool Vwarn_future_time_stamp;
 
 extern void
 parse_and_execute (FILE *f);
 
 extern void
-parse_and_execute (const string& s, bool verbose = false,
+parse_and_execute (const std::string& s, bool verbose = false,
 		   const char *warn_for = 0);
 
-extern string get_help_from_file (const string& f);
+extern std::string get_help_from_file (const std::string& f);
 
 extern bool
 load_fcn_from_file (symbol_record *sym_rec, bool exec_script);
 
 extern octave_value_list
-feval (const string& name, const octave_value_list& args, int nargout);
+feval (const std::string& name, const octave_value_list& args, int nargout);
 
 extern octave_value_list
 feval (const octave_value_list& args, int nargout);
 
 extern octave_value_list
-eval_string (const string&, bool silent, int& parse_status, int hargout);
+eval_string (const std::string&, bool silent, int& parse_status, int hargout);
 
 extern octave_value
-eval_string (const string&, bool silent, int& parse_status);
+eval_string (const std::string&, bool silent, int& parse_status);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -96,17 +96,17 @@ symbol_table *tmp_local_sym_tab = 0;
 
 // The current input line number.
 int input_line_number = 0;
 
 // The column of the current token.
 int current_input_column = 1;
 
 // Buffer for help text snagged from function files.
-string help_buf;
+std::string help_buf;
 
 // TRUE means we are using readline.
 // (--no-line-editing)
 bool line_editing = true;
 
 // TRUE means we printed messages about reading startup files.
 bool reading_startup_message_printed = false;
 
@@ -261,17 +261,17 @@ static void
 recover_from_parsing_function (void);
 
 // Make an index expression.
 static tree_index_expression *
 make_index_expression (tree_expression *expr, tree_argument_list *args);
 
 // Make an indirect reference expression.
 static tree_indirect_ref *
-make_indirect_ref (tree_expression *expr, const string&);
+make_indirect_ref (tree_expression *expr, const std::string&);
 
 // Make a declaration command.
 static tree_decl_command *
 make_decl_command (int tok, token *tok_val, tree_decl_init_list *lst);
 
 // Finish building a matrix list.
 static tree_expression *
 finish_matrix (tree_matrix *m);
@@ -1400,17 +1400,17 @@ opt_sep		: // empty
 
 // Generic error messages.
 
 static void
 yyerror (const char *s)
 {
   int err_col = current_input_column - 1;
 
-  ostrstream output_buf;
+  std::ostrstream output_buf;
 
   if (reading_fcn_file || reading_script_file)
     output_buf << "parse error near line " << input_line_number
 	       << " of file " << curr_fcn_file_full_name;
   else
     output_buf << "parse error:";
 
   if (s && strcmp (s, "parse error") != 0)
@@ -1621,17 +1621,17 @@ fold (tree_binary_expression *e)
   if (op1->is_constant () && op2->is_constant ())
     {
       octave_value tmp = e->rvalue ();
 
       if (! (error_state || warning_state))
 	{
 	  tree_constant *tc_retval = new tree_constant (tmp);
 
-	  ostrstream buf;
+	  std::ostrstream buf;
 
 	  tree_print_code tpc (buf);
 
 	  e->accept (tpc);
 
 	  buf << ends;
 
 	  char *s = buf.str ();
@@ -1670,17 +1670,17 @@ fold (tree_unary_expression *e)
   if (op->is_constant ())
     {
       octave_value tmp = e->rvalue ();
 
       if (! (error_state || warning_state))
 	{
 	  tree_constant *tc_retval = new tree_constant (tmp);
 
-	  ostrstream buf;
+	  std::ostrstream buf;
 
 	  tree_print_code tpc (buf);
 
 	  e->accept (tpc);
 
 	  buf << ends;
 
 	  char *s = buf.str ();
@@ -1728,17 +1728,17 @@ finish_colon_expression (tree_colon_expr
 	      && (! incr || (incr && incr->is_constant ())))
 	    {
 	      octave_value tmp = e->rvalue ();
 
 	      if (! (error_state || warning_state))
 		{
 		  tree_constant *tc_retval = new tree_constant (tmp);
 
-		  ostrstream buf;
+		  std::ostrstream buf;
 
 		  tree_print_code tpc (buf);
 
 		  e->accept (tpc);
 
 		  buf << ends;
 
 		  char *s = buf.str ();
@@ -2365,17 +2365,17 @@ start_function (tree_parameter_list *par
   return fcn;
 }
 
 // Do most of the work for defining a function.
 
 static octave_user_function *
 frob_function (tree_identifier *id, octave_user_function *fcn)
 {
-  string id_name = id->name ();
+  std::string id_name = id->name ();
 
   // If input is coming from a file, issue a warning if the name of
   // the file does not match the name of the function stated in the
   // file.  Matlab doesn't provide a diagnostic (it ignores the stated
   // name).
 
   fcn->stash_function_name (id_name);
 
@@ -2399,17 +2399,17 @@ frob_function (tree_identifier *id, octa
 
       fcn->stash_function_name (id_name);
       fcn->stash_fcn_file_name ();
       fcn->stash_fcn_file_time (now);
       fcn->mark_as_system_fcn_file ();
 
       if (Vwarn_future_time_stamp)
 	{
-	  string nm = fcn->fcn_file_name ();
+	  std::string nm = fcn->fcn_file_name ();
 
 	  file_stat fs (nm);
 
 	  if (fs && fs.is_newer (now))
 	    warning ("time stamp for `%s' is in the future", nm.c_str ());
 	}
     }
   else if (! (input_from_tmp_history_file || input_from_startup_file)
@@ -2485,17 +2485,17 @@ make_index_expression (tree_expression *
   retval =  new tree_index_expression (expr, args, l, c);
 
   return retval;
 }
 
 // Make an indirect reference expression.
 
 static tree_indirect_ref *
-make_indirect_ref (tree_expression *expr, const string& elt)
+make_indirect_ref (tree_expression *expr, const std::string& elt)
 {
   tree_indirect_ref *retval = 0;
 
   int l = expr->line ();
   int c = expr->column ();
 
   retval = new tree_indirect_ref (expr, elt, l, c);
 
@@ -2560,17 +2560,17 @@ finish_matrix (tree_matrix *m)
   if (m->all_elements_are_constant ())
     {
       octave_value tmp = m->rvalue ();
 
       if (! (error_state || warning_state))
 	{
 	  tree_constant *tc_retval = new tree_constant (tmp);
 
-	  ostrstream buf;
+	  std::ostrstream buf;
 
 	  tree_print_code tpc (buf);
 
 	  m->accept (tpc);
 
 	  buf << ends;
 
 	  char *s = buf.str ();
@@ -2705,17 +2705,17 @@ parse_and_execute (FILE *f)
 static void
 safe_fclose (void *f)
 {
   if (f)
     fclose (static_cast<FILE *> (f));
 }
 
 void
-parse_and_execute (const string& s, bool verbose, const char *warn_for)
+parse_and_execute (const std::string& s, bool verbose, const char *warn_for)
 {
   unwind_protect::begin_frame ("parse_and_execute_2");
 
   unwind_protect_bool (reading_script_file);
   unwind_protect_str (curr_fcn_file_full_name);
 
   reading_script_file = true;
   curr_fcn_file_full_name = s;
@@ -2746,21 +2746,21 @@ parse_and_execute (const string& s, bool
     }
   else if (warn_for)
     error ("%s: unable to open file `%s'", warn_for, s.c_str ());
 
   unwind_protect::run_frame ("parse_and_execute_2");
 }
 
 static bool
-looks_like_octave_copyright (const string& s)
+looks_like_octave_copyright (const std::string& s)
 {
   bool retval = false;
 
-  string t = s.substr (0, 14);
+  std::string t = s.substr (0, 14);
 
   if (t == "Copyright (C) ")
     {
       size_t pos = s.find ('\n');
 
       if (pos != NPOS)
 	{
 	  pos = s.find ('\n', pos + 1);
@@ -2788,17 +2788,17 @@ looks_like_octave_copyright (const strin
 // number information is updated.
 
 // XXX FIXME XXX -- grab_help_text() in lex.l duplicates some of this
 // code!
 
 static string
 gobble_leading_white_space (FILE *ffile, bool in_parts, bool update_pos)
 {
-  string help_txt;
+  std::string help_txt;
 
   bool first_comments_seen = false;
   bool begin_comment = false;
   bool have_help_text = false;
   bool in_comment = false;
   bool discard_space = true;
   int c;
 
@@ -2899,19 +2899,19 @@ gobble_leading_white_space (FILE *ffile,
       if (in_parts && help_txt.empty ())
 	help_txt = gobble_leading_white_space (ffile, in_parts, update_pos);
     }
 
   return help_txt;
 }
 
 string
-get_help_from_file (const string& path)
+get_help_from_file (const std::string& path)
 {
-  string retval;
+  std::string retval;
 
   if (! path.empty ())
     {
       FILE *fptr = fopen (path.c_str (), "r");
 
       if (fptr)
 	{
 	  unwind_protect::add (safe_fclose, (void *) fptr);
@@ -2960,17 +2960,17 @@ restore_input_stream (void *f)
 
 static void
 clear_current_script_file_name (void *)
 {
   bind_builtin_variable ("current_script_file_name", octave_value ());
 }
 
 static bool
-parse_fcn_file (const string& ff, bool exec_script, bool force_script = false)
+parse_fcn_file (const std::string& ff, bool exec_script, bool force_script = false)
 {
   unwind_protect::begin_frame ("parse_fcn_file");
 
   int script_file_executed = false;
 
   // Open function file and parse.
 
   bool old_reading_fcn_file_state = reading_fcn_file;
@@ -3079,25 +3079,25 @@ parse_fcn_file (const string& ff, bool e
   return script_file_executed;
 }
 
 bool
 load_fcn_from_file (symbol_record *sym_rec, bool exec_script)
 {
   bool script_file_executed = false;
 
-  string nm = sym_rec->name ();
+  std::string nm = sym_rec->name ();
 
   if (octave_dynamic_loader::load (nm))
     {
       force_link_to_function (nm);
     }
   else
     {
-      string ff = fcn_file_in_path (nm);
+      std::string ff = fcn_file_in_path (nm);
 
       // These are needed by yyparse.
 
       unwind_protect::begin_frame ("load_fcn_from_file");
 
       unwind_protect_str (curr_fcn_file_name);
       unwind_protect_str (curr_fcn_file_full_name);
 
@@ -3125,21 +3125,21 @@ be named @file{@var{file}.m}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      string file_name = args(0).string_value ();
+      std::string file_name = args(0).string_value ();
 
       if (! error_state)
 	{
-	  string file_full_name = file_ops::tilde_expand (file_name);
+	  std::string file_full_name = file_ops::tilde_expand (file_name);
 
 	  unwind_protect::begin_frame ("Fsource");
 
 	  unwind_protect_str (curr_fcn_file_name);
 	  unwind_protect_str (curr_fcn_file_full_name);
 
 	  curr_fcn_file_name = file_name;
 	  curr_fcn_file_full_name = file_full_name;
@@ -3157,17 +3157,17 @@ be named @file{@var{file}.m}.\n\
     }
   else
     print_usage ("source");
 
   return retval;
 }
 
 octave_value_list
-feval (const string& name, const octave_value_list& args, int nargout)
+feval (const std::string& name, const octave_value_list& args, int nargout)
 {
   octave_value_list retval;
 
   octave_function *fcn = is_valid_function (name, "feval", 1);
 
   if (fcn)
     retval = fcn->do_index_op (nargout, args);
 
@@ -3176,17 +3176,17 @@ feval (const string& name, const octave_
 
 octave_value_list
 feval (const octave_value_list& args, int nargout)
 {
   octave_value_list retval;
 
   if (args.length () > 0)
     {
-      string name = args(0).string_value ();
+      std::string name = args(0).string_value ();
 
       if (! error_state)
 	{
 	  int tmp_nargin = args.length () - 1;
 
 	  octave_value_list tmp_args (tmp_nargin, octave_value ());
 
 	  for (int i = 0; i < tmp_nargin; i++)
@@ -3243,17 +3243,17 @@ by name, and use @code{feval} to call th
     retval = feval (args, nargout);
   else
     print_usage ("feval");
 
   return retval;
 }
 
 octave_value_list
-eval_string (const string& s, bool silent, int& parse_status, int nargout)
+eval_string (const std::string& s, bool silent, int& parse_status, int nargout)
 {
   unwind_protect::begin_frame ("eval_string");
 
   unwind_protect_bool (get_input_from_eval_string);
   unwind_protect_bool (input_from_command_line_file);
   unwind_protect_ptr (global_command);
   unwind_protect_str (current_eval_string);
 
@@ -3290,37 +3290,37 @@ eval_string (const string& s, bool silen
       retval = command->eval (silent, nargout);
       delete command;
     }
 
   return retval;
 }
 
 octave_value
-eval_string (const string& s, bool silent, int& parse_status)
+eval_string (const std::string& s, bool silent, int& parse_status)
 {
   octave_value retval;
 
   octave_value_list tmp = eval_string (s, silent, parse_status, 1);
 
   if (! tmp.empty ())
     retval = tmp(0);
 
   return retval;
 }
 
 static octave_value_list
 eval_string (const octave_value& arg, bool silent, int& parse_status,
 	     int nargout)
 {
-  string s = arg.string_value ();
+  std::string s = arg.string_value ();
 
   if (error_state)
     {
-      error ("eval: expecting string argument");
+      error ("eval: expecting std::string argument");
       return -1.0;
     }
 
   return eval_string (s, silent, parse_status, nargout);
 }
 
 DEFUN (eval, args, nargout,
   "-*- texinfo -*-\n\
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -68,21 +68,21 @@ static int Voutput_precision;
 // TRUE means that the dimensions of empty matrices should be printed
 // like this: x = [](2x0).
 static bool Vprint_empty_dimensions;
 
 // TRUE means that the rows of big matrices should be split into
 // smaller slices that fit on the screen.
 static bool Vsplit_long_rows;
 
-// Current format string for real numbers and the real part of complex
+// Current format std::string for real numbers and the real part of complex
 // numbers.
 static char *curr_real_fmt = 0;
 
-// Current format string for the imaginary part of complex numbers.
+// Current format std::string for the imaginary part of complex numbers.
 static char *curr_imag_fmt = 0;
 
 // TRUE means don't do any fancy formatting.
 static bool free_format = false;
 
 // TRUE means print plus sign for nonzero, blank for zero.
 static bool plus_format = false;
 
@@ -937,17 +937,17 @@ union equiv
       stmp[6] = (ctmp & 0x40) ? '1' : '0'; \
       stmp[7] = (ctmp & 0x80) ? '1' : '0'; \
       stmp[8] = '\0'; \
       os << stmp; \
     } \
   while (0)
 
 static void
-pr_any_float (const char *fmt, ostream& os, double d, int fw = 0)
+pr_any_float (const char *fmt, std::ostream& os, double d, int fw = 0)
 {
 #if defined (SCO)
   // Apparently on some SCO systems NaN == -0.0 is true.  Compiler bug?
   if (d == -0.0 && ! xisnan (d))
     d = 0.0;
 #else
   if (d == -0.0)
     d = 0.0;
@@ -1053,29 +1053,29 @@ pr_any_float (const char *fmt, ostream& 
       else
 	os.form (fmt, d);
     }
   else
     os << d;
 }
 
 static inline void
-pr_float (ostream& os, double d, int fw = 0)
+pr_float (std::ostream& os, double d, int fw = 0)
 {
   pr_any_float (curr_real_fmt, os, d, fw);
 }
 
 static inline void
-pr_imag_float (ostream& os, double d, int fw = 0)
+pr_imag_float (std::ostream& os, double d, int fw = 0)
 {
   pr_any_float (curr_imag_fmt, os, d, fw);
 }
 
 static void
-pr_complex (ostream& os, const Complex& c, int r_fw = 0, int i_fw = 0)
+pr_complex (std::ostream& os, const Complex& c, int r_fw = 0, int i_fw = 0)
 {
   double r = c.real ();
   pr_float (os, r, r_fw);
   if (! bank_format)
     {
       double i = c.imag ();
       if (! (hex_format || bit_format) && i < 0)
 	{
@@ -1092,17 +1092,17 @@ pr_complex (ostream& os, const Complex& 
 
 	  pr_imag_float (os, i, i_fw);
 	}
       os << "i";
     }
 }
 
 static void
-print_empty_matrix (ostream& os, int nr, int nc, bool pr_as_read_syntax)
+print_empty_matrix (std::ostream& os, int nr, int nc, bool pr_as_read_syntax)
 {
   assert (nr == 0 || nc == 0);
 
   if (pr_as_read_syntax)
     {
       if (nr == 0 && nc == 0)
 	os << "[]";
       else
@@ -1112,29 +1112,29 @@ print_empty_matrix (ostream& os, int nr,
     {
       os << "[]";
       if (Vprint_empty_dimensions)
 	os << "(" << nr << "x" << nc << ")";
     }
 }
 
 static void
-pr_scale_header (ostream& os, double scale)
+pr_scale_header (std::ostream& os, double scale)
 {
   if (Vfixed_point_format && scale != 1.0)
     {
       os.form ("  %-8.1e *\n", scale);
 
       if (! compact_format)
 	os << "\n";
     }
 }
 
 static void
-pr_col_num_header (ostream& os, int total_width, int max_width,
+pr_col_num_header (std::ostream& os, int total_width, int max_width,
 		   int lim, int col, int extra_indent)
 {
   if (total_width > max_width && Vsplit_long_rows)
     {
       if (col != 0 && ! compact_format)
 	os << "\n\n";
 
       int num_cols = lim - col;
@@ -1149,45 +1149,45 @@ pr_col_num_header (ostream& os, int tota
 	os << " Columns " << col + 1 << " through " << lim << ":\n";
 
       if (! compact_format)
 	os << "\n";
     }
 }
 
 static inline void
-do_plus_format (ostream& os, double d)
+do_plus_format (std::ostream& os, double d)
 {
   if (d == 0.0)
     os << " ";
   else if (d < 0.0)
     os << "-";
   else
     os << "+";
 }
 
 void
-octave_print_internal (ostream& os, double d, bool pr_as_read_syntax)
+octave_print_internal (std::ostream& os, double d, bool pr_as_read_syntax)
 {
   if (plus_format)
     {
       do_plus_format (os, d);
     }
   else
     {
       set_format (d);
       if (free_format)
 	os << d;
       else
 	pr_float (os, d);
     }
 }
 
 void
-octave_print_internal (ostream& os, const Matrix& m, bool pr_as_read_syntax,
+octave_print_internal (std::ostream& os, const Matrix& m, bool pr_as_read_syntax,
 		       int extra_indent)
 {
   int nr = m.rows ();
   int nc = m.columns ();
 
   if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
@@ -1311,17 +1311,17 @@ octave_print_internal (ostream& os, cons
 		    os << "\n";
 		}
 	    }
 	}
     }
 }
 
 static inline void
-do_plus_format (ostream& os, const Complex& c)
+do_plus_format (std::ostream& os, const Complex& c)
 {
   double rp = c.real ();
   double ip = c.imag ();
 
   if (rp == 0.0)
     {
       if (ip == 0.0)
 	os << " ";
@@ -1330,17 +1330,17 @@ do_plus_format (ostream& os, const Compl
     }
   else if (ip == 0.0)
     do_plus_format (os, rp);
   else
     os << "c";
 }
 
 void
-octave_print_internal (ostream& os, const Complex& c,
+octave_print_internal (std::ostream& os, const Complex& c,
 		       bool pr_as_read_syntax)
 {
   if (plus_format)
     {
       do_plus_format (os, c);
     }
   else
     {
@@ -1348,17 +1348,17 @@ octave_print_internal (ostream& os, cons
       if (free_format)
 	os << c;
       else
 	pr_complex (os, c);
     }
 }
 
 void
-octave_print_internal (ostream& os, const ComplexMatrix& cm,
+octave_print_internal (std::ostream& os, const ComplexMatrix& cm,
 		       bool pr_as_read_syntax, int extra_indent)
 {
   int nr = cm.rows ();
   int nc = cm.columns ();
 
  if (nr == 0 || nc == 0)
     print_empty_matrix (os, nr, nc, pr_as_read_syntax);
   else if (plus_format && ! pr_as_read_syntax)
@@ -1483,17 +1483,17 @@ octave_print_internal (ostream& os, cons
 		    os << "\n";
 		}
 	    }
 	}
     }
 }
 
 void
-octave_print_internal (ostream& os, const Range& r,
+octave_print_internal (std::ostream& os, const Range& r,
 		       bool pr_as_read_syntax, int extra_indent)
 {
   double base = r.base ();
   double increment = r.inc ();
   double limit = r.limit ();
   int num_elem = r.nelem ();
 
   if (plus_format && ! pr_as_read_syntax)
@@ -1589,42 +1589,42 @@ octave_print_internal (ostream& os, cons
 	      if (col < num_elem)
 		os << "\n";
 	    }
 	}
     }
 }
 
 void
-octave_print_internal (ostream& os, const boolMatrix& bm,
+octave_print_internal (std::ostream& os, const boolMatrix& bm,
 		       bool pr_as_read_syntax,
 		       int extra_indent)
 {
   Matrix tmp (bm);
   octave_print_internal (os, tmp, pr_as_read_syntax, extra_indent);
 }
 
 void
-octave_print_internal (ostream& os, const charMatrix& chm,
+octave_print_internal (std::ostream& os, const charMatrix& chm,
 		       bool pr_as_read_syntax,
 		       int /* extra_indent XXX FIXME XXX */,
 		       bool pr_as_string)
 {
   if (pr_as_string)
     {
       int nstr = chm.rows ();
 
       if (pr_as_read_syntax && nstr > 1)
 	os << "[ ";
 
       if (nstr != 0)
 	{
 	  for (int i = 0; i < nstr; i++)
 	    {
-	      string row = chm.row_as_string (i);
+	      std::string row = chm.row_as_string (i);
 
 	      if (pr_as_read_syntax)
 		{
 		  os << "\"" << undo_string_escapes (row) << "\"";
 
 		  if (i < nstr - 1)
 		    os << "; ";
 		}
@@ -1696,17 +1696,17 @@ set_output_prec_and_fw (int prec, int fw
 
 static void
 set_format_style (int argc, const string_vector& argv)
 {
   int idx = 1;
 
   if (--argc > 0)
     {
-      string arg = argv[idx++];
+      std::string arg = argv[idx++];
 
       if (arg == "short")
 	{
 	  if (--argc > 0)
 	    {
 	      arg = argv[idx++];
 
 	      if (arg == "e")
diff --git a/src/pr-output.h b/src/pr-output.h
--- a/src/pr-output.h
+++ b/src/pr-output.h
@@ -29,45 +29,45 @@ Software Foundation, 59 Temple Place - S
 
 class ComplexMatrix;
 class Matrix;
 class Range;
 class boolMatrix;
 class charMatrix;
 
 extern void
-octave_print_internal (ostream& os, double d,
+octave_print_internal (std::ostream& os, double d,
 		       bool pr_as_read_syntax = false);
 
 extern void
-octave_print_internal (ostream& os, const Matrix& m,
+octave_print_internal (std::ostream& os, const Matrix& m,
 		       bool pr_as_read_syntax = false,
 		       int extra_indent = 0);
 
 extern void
-octave_print_internal (ostream& os, const Complex& c,
+octave_print_internal (std::ostream& os, const Complex& c,
 		       bool pr_as_read_syntax = false);
 
 extern void
-octave_print_internal (ostream& os, const ComplexMatrix& cm,
+octave_print_internal (std::ostream& os, const ComplexMatrix& cm,
 		       bool pr_as_read_syntax = false,
 		       int extra_indent = 0);
 
 extern void
-octave_print_internal (ostream& os, const Range& r,
+octave_print_internal (std::ostream& os, const Range& r,
 		       bool pr_as_read_syntax = false,
 		       int extra_indent = 0);
 
 extern void
-octave_print_internal (ostream& os, const boolMatrix& m,
+octave_print_internal (std::ostream& os, const boolMatrix& m,
 		       bool pr_as_read_syntax = false,
 		       int extra_indent = 0);
 
 extern void
-octave_print_internal (ostream& os, const charMatrix& chm,
+octave_print_internal (std::ostream& os, const charMatrix& chm,
 		       bool pr_as_read_syntax = false,
 		       int extra_indent = 0,
 		       bool pr_as_string = false);
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/src/pt-assign.h b/src/pt-assign.h
--- a/src/pt-assign.h
+++ b/src/pt-assign.h
@@ -66,17 +66,17 @@ public:
 
   octave_value_list rvalue (int nargout);
 
   bool is_assignment_expression (void) const
     { return true; }
 
   void eval_error (void);
 
-  string oper (void) const;
+  std::string oper (void) const;
 
   tree_expression *left_hand_side (void) { return lhs; }
 
   tree_expression *right_hand_side (void) { return rhs; }
 
   void accept (tree_walker& tw);
 
 private:
@@ -134,17 +134,17 @@ public:
     { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   void eval_error (void);
 
-  string oper (void) const;
+  std::string oper (void) const;
 
   tree_argument_list *left_hand_side (void) { return lhs; }
 
   tree_expression *right_hand_side (void) { return rhs; }
 
   void accept (tree_walker& tw);
 
 private:
diff --git a/src/pt-binop.cc b/src/pt-binop.cc
--- a/src/pt-binop.cc
+++ b/src/pt-binop.cc
@@ -194,17 +194,17 @@ tree_boolean_expression::rvalue (void)
     eval_error ();
 
   return retval;
 }
 
 string
 tree_boolean_expression::oper (void) const
 {
-  string retval = "<unknown>";
+  std::string retval = "<unknown>";
 
   switch (etype)
     {
     case bool_and:
       retval = "&&";
       break;
 
     case bool_or:
diff --git a/src/pt-binop.h b/src/pt-binop.h
--- a/src/pt-binop.h
+++ b/src/pt-binop.h
@@ -66,17 +66,17 @@ public:
     { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   void eval_error (void);
 
-  string oper (void) const;
+  std::string oper (void) const;
 
   tree_expression *lhs (void) { return op_lhs; }
   tree_expression *rhs (void) { return op_rhs; }
 
   void accept (tree_walker& tw);
 
 protected:
 
@@ -121,17 +121,17 @@ public:
 
   bool rvalue_ok (void) const
     { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
-  string oper (void) const;
+  std::string oper (void) const;
 
 private:
 
   // The type of the expression.
   type etype;
 
   // No copying!
 
diff --git a/src/pt-check.cc b/src/pt-check.cc
--- a/src/pt-check.cc
+++ b/src/pt-check.cc
@@ -617,17 +617,17 @@ tree_checker::visit_while_command (tree_
 
   tree_statement_list *list = cmd.body ();
 
   if (list)
     list->accept (*this);
 }
 
 void
-tree_checker::gripe (const string& msg, int line)
+tree_checker::gripe (const std::string& msg, int line)
 {
   if (curr_fcn_file_name.empty ())
     error ("%s", msg.c_str ());
   else
     error ("%s: %d: %s", curr_fcn_file_name.c_str (), line, msg.c_str ());
 }
 
 /*
diff --git a/src/pt-check.h b/src/pt-check.h
--- a/src/pt-check.h
+++ b/src/pt-check.h
@@ -124,17 +124,17 @@ public:
   void visit_unwind_protect_command (tree_unwind_protect_command&);
 
   void visit_while_command (tree_while_command&);
 
 private:
 
   bool do_lvalue_check;
 
-  void gripe (const string& msg, int line);
+  void gripe (const std::string& msg, int line);
 
   // No copying!
 
   tree_checker (const tree_checker&);
 
   tree_checker& operator = (const tree_checker&);
 };
 
diff --git a/src/pt-cmd.h b/src/pt-cmd.h
--- a/src/pt-cmd.h
+++ b/src/pt-cmd.h
@@ -58,30 +58,30 @@ private:
 
 // No-op.
 
 class
 tree_no_op_command : public tree_command
 {
 public:
 
-  tree_no_op_command (const string& cmd = "no_op", int l = -1, int c = -1)
+  tree_no_op_command (const std::string& cmd = "no_op", int l = -1, int c = -1)
     : tree_command (l, c), orig_cmd (cmd) { }
 
   ~tree_no_op_command (void) { }
 
   void eval (void) { }
 
   void accept (tree_walker& tw);
 
-  string original_command (void) { return orig_cmd; }
+  std::string original_command (void) { return orig_cmd; }
 
 private:
 
-  string orig_cmd;
+  std::string orig_cmd;
 
   // No copying!
 
   tree_no_op_command (const tree_no_op_command&);
 
   tree_no_op_command& operator = (const tree_no_op_command&);
 };
 
diff --git a/src/pt-colon.cc b/src/pt-colon.cc
--- a/src/pt-colon.cc
+++ b/src/pt-colon.cc
@@ -153,17 +153,17 @@ tree_colon_expression::rvalue (void)
 
       return octave_value ();
     }
 
   return retval;
 }
 
 void
-tree_colon_expression::eval_error (const string& s)
+tree_colon_expression::eval_error (const std::string& s)
 {
   if (error_state > 0)
     {
       if (! s.empty ())
 	::error ("%s", s.c_str ());
 
       ::error ("evaluating colon expression near line %d column %d",
 	       line (), column ());
diff --git a/src/pt-colon.h b/src/pt-colon.h
--- a/src/pt-colon.h
+++ b/src/pt-colon.h
@@ -67,17 +67,17 @@ public:
 
   bool rvalue_ok (void) const
     { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
-  void eval_error (const string& s = string ());
+  void eval_error (const std::string& s = std::string ());
 
   tree_expression *base (void) { return op_base; }
 
   tree_expression *limit (void) { return op_limit; }
 
   tree_expression *increment (void) { return op_increment; }
 
   void accept (tree_walker& tw);
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -37,26 +37,26 @@ Software Foundation, 59 Temple Place - S
 #include "pt-walk.h"
 
 // We are likely to have a lot of tree_constant objects to allocate,
 // so make the grow_size large.
 octave_allocator
 tree_constant::allocator (sizeof (tree_constant), 1024);
 
 void
-tree_constant::print (ostream& os, bool pr_as_read_syntax, bool pr_orig_text)
+tree_constant::print (std::ostream& os, bool pr_as_read_syntax, bool pr_orig_text)
 {
   if (pr_orig_text && ! orig_text.empty ())
     os << orig_text;
   else
     val.print (os, pr_as_read_syntax);
 }
 
 void
-tree_constant::print_raw (ostream& os, bool pr_as_read_syntax,
+tree_constant::print_raw (std::ostream& os, bool pr_as_read_syntax,
 			  bool pr_orig_text) 
 {
   if (pr_orig_text && ! orig_text.empty ())
     os << orig_text;
   else
     val.print_raw (os, pr_as_read_syntax);
 }
 
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -62,51 +62,51 @@ public:
   // Type.  It would be nice to eliminate the need for this.
 
   bool is_constant (void) const
     { return true; }
 
   void maybe_mutate (void)
     { val.maybe_mutate (); }
 
-  void print (ostream& os, bool pr_as_read_syntax = false,
+  void print (std::ostream& os, bool pr_as_read_syntax = false,
 	      bool pr_orig_txt = true);
 
-  void print_raw (ostream& os, bool pr_as_read_syntax = false,
+  void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
 		  bool pr_orig_txt = true);
 
   bool rvalue_ok (void) const
     { return true; }
 
   octave_value rvalue (void)
     { return val; }
 
   octave_value_list rvalue (int nargout);
 
   void accept (tree_walker& tw);
 
   // Store the original text corresponding to this constant for later
   // pretty printing.
 
-  void stash_original_text (const string& s)
+  void stash_original_text (const std::string& s)
     { orig_text = s; }
 
-  string original_text (void) const
+  std::string original_text (void) const
     { return orig_text; }
 
 private:
 
   // For custom memory management.
   static octave_allocator allocator;
 
   // The actual value that this constant refers to.
   octave_value val;
 
   // The original text form of this constant.
-  string orig_text;
+  std::string orig_text;
 
   // No copying!
 
   tree_constant (const tree_constant&);
 
   tree_constant& operator = (const tree_constant&);
 };
 
diff --git a/src/pt-decl.h b/src/pt-decl.h
--- a/src/pt-decl.h
+++ b/src/pt-decl.h
@@ -110,35 +110,35 @@ private:
 
 // Base class for declaration commands -- global, static, etc.
 
 class
 tree_decl_command : public tree_command
 {
 public:
 
-  tree_decl_command (const string& n, int l = -1, int c = -1)
+  tree_decl_command (const std::string& n, int l = -1, int c = -1)
     : tree_command (l, c), cmd_name (n), initialized (false), init_list (0) { }
 
-  tree_decl_command (const string& n, tree_decl_init_list *t,
+  tree_decl_command (const std::string& n, tree_decl_init_list *t,
 		     int l = -1, int c = -1)
     : tree_command (l, c), cmd_name (n), initialized (false), init_list (t) { }
 
   ~tree_decl_command (void);
 
   tree_decl_init_list *initializer_list (void) { return init_list; }
 
   void accept (tree_walker& tw);
 
-  string name (void) { return cmd_name; }
+  std::string name (void) { return cmd_name; }
 
 protected:
 
   // The name of this command -- global, static, etc.
-  string cmd_name;
+  std::string cmd_name;
 
   // TRUE if this command has been evaluated.
   bool initialized;
 
   // The list of variables or initializers in this declaration command.
   tree_decl_init_list *init_list;
 
 private:
diff --git a/src/pt-exp.cc b/src/pt-exp.cc
--- a/src/pt-exp.cc
+++ b/src/pt-exp.cc
@@ -80,16 +80,16 @@ tree_expression::lvalue (void)
 {
   ::error ("invalid lvalue function called in expression");
   return octave_lvalue ();
 }
 
 string
 tree_expression::original_text (void) const
 {
-  return string ();
+  return std::string ();
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-exp.h b/src/pt-exp.h
--- a/src/pt-exp.h
+++ b/src/pt-exp.h
@@ -86,23 +86,23 @@ public:
     { return num_parens; }
 
   bool is_postfix_indexed (void) const
     { return postfix_indexed; }
 
   bool print_result (void) const
     { return print_flag; }
 
-  virtual string oper (void) const
+  virtual std::string oper (void) const
     { return "<unknown>"; }
 
-  virtual string name (void) const
+  virtual std::string name (void) const
     { return "<unknown>"; }
 
-  virtual string original_text (void) const;
+  virtual std::string original_text (void) const;
 
   tree_expression *mark_in_parens (void)
     {
       num_parens++;
       return this;
     }
 
   tree_expression *mark_postfix_indexed (void)
diff --git a/src/pt-id.cc b/src/pt-id.cc
--- a/src/pt-id.cc
+++ b/src/pt-id.cc
@@ -39,31 +39,31 @@ Software Foundation, 59 Temple Place - S
 #include "utils.h"
 #include "variables.h"
 
 // Symbols from the symbol table.
 
 string
 tree_identifier::name (void) const
 {
-  string retval;
+  std::string retval;
   if (sym)
     retval = sym->name ();
   return retval;
 }
 
 tree_identifier *
 tree_identifier::define (octave_function *f, unsigned int sym_type)
 {
   int status = sym->define (f, sym_type);
   return status ? this : 0;
 }
 
 void
-tree_identifier::document (const string& s)
+tree_identifier::document (const std::string& s)
 {
   if (sym)
     sym->document (s);
 }
 
 bool
 tree_identifier::is_defined (void)
 {
diff --git a/src/pt-id.h b/src/pt-id.h
--- a/src/pt-id.h
+++ b/src/pt-id.h
@@ -54,21 +54,21 @@ public:
   tree_identifier (symbol_record *s, int l = -1, int c = -1)
     : tree_expression (l, c), sym (s) { }
 
   ~tree_identifier (void) { }
 
   bool is_identifier (void) const
     { return true; }
 
-  string name (void) const;
+  std::string name (void) const;
 
   tree_identifier *define (octave_function *f, unsigned int sym_type);
 
-  void document (const string& s);
+  void document (const std::string& s);
 
   bool is_defined (void);
 
   bool is_function (void);
 
   octave_value
   do_lookup (bool& script_file_executed, bool exec_script = true);
 
diff --git a/src/pt-idx.h b/src/pt-idx.h
--- a/src/pt-idx.h
+++ b/src/pt-idx.h
@@ -49,17 +49,17 @@ public:
   tree_index_expression (tree_expression *e = 0, tree_argument_list *lst = 0,
 			 int l = -1, int c = -1);
 
   ~tree_index_expression (void);
 
   bool is_index_expression (void) const
     { return true; }
 
-  string name (void) const;
+  std::string name (void) const;
 
   tree_expression *expression (void)
     { return expr; }
 
   tree_argument_list *arg_list (void)
     { return list; }
 
   bool lvalue_ok (void) const
diff --git a/src/pt-indir.cc b/src/pt-indir.cc
--- a/src/pt-indir.cc
+++ b/src/pt-indir.cc
@@ -45,17 +45,17 @@ tree_indirect_ref::~tree_indirect_ref (v
 {
   delete expr;
 }
 
 string
 tree_indirect_ref::name (void) const
 {
   // ??? FIXME ???
-  string xname = expr->name ();
+  std::string xname = expr->name ();
 
   return (xname == "<unknown>") ? xname : xname + "." + nm;
 }
 
 octave_value_list
 tree_indirect_ref::rvalue (int nargout)
 {
   octave_value_list retval;
@@ -71,17 +71,17 @@ tree_indirect_ref::rvalue (int nargout)
       else
 	{
 	  octave_value val = tmp(0).do_struct_elt_index_op (nm);
 
 	  if (print_result () && nargout == 0 && val.is_defined ())
 	    {
 	      // ??? FIXME ???
 
-	      string xname = name ();
+	      std::string xname = name ();
 
 	      if (xname == "<unknown>")
 		bind_ans (val, true);
 	      else
 		val.print_with_name (octave_stdout, xname);
 	    }
 
 	  retval = val;
diff --git a/src/pt-indir.h b/src/pt-indir.h
--- a/src/pt-indir.h
+++ b/src/pt-indir.h
@@ -41,51 +41,51 @@ class tree_walker;
 class
 tree_indirect_ref : public tree_expression
 {
 public:
 
   tree_indirect_ref (int l = -1, int c = -1)
     : tree_expression (l, c), expr (0), nm () { }
 
-  tree_indirect_ref (tree_expression *e, const string& n,
+  tree_indirect_ref (tree_expression *e, const std::string& n,
 		     int l = -1, int c = -1)
     : tree_expression (l, c), expr (e), nm (n) { }
 
   ~tree_indirect_ref (void);
 
   bool is_indirect_ref (void) const
     { return true; }
 
-  string name (void) const;
+  std::string name (void) const;
 
   bool lvalue_ok (void) const
     { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   octave_lvalue lvalue (void);
 
   tree_expression *expression (void)
     { return expr; }
 
-  string elt_name (void)
+  std::string elt_name (void)
     { return nm; }
 
   void accept (tree_walker& tw);
 
 private:
 
   // The LHS of this structure reference.
   tree_expression *expr;
 
   // The sub-element name.
-  string nm;
+  std::string nm;
 
   void eval_error (void) const;
 
   // No copying!
 
   tree_indirect_ref (const tree_indirect_ref&);
 
   tree_indirect_ref& operator = (const tree_indirect_ref&);
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -580,17 +580,17 @@ implicit_num_to_str_ok (void)
   return 0;
 }
 
 static int
 string_fill_char (void)
 {
   int status = 0;
 
-  string s = builtin_string_variable ("string_fill_char");
+  std::string s = builtin_string_variable ("string_fill_char");
 
   switch (s.length ())
     {
     case 1:
       Vstring_fill_char = s[0];
       break;
 
     case 0:
diff --git a/src/pt-mat.h b/src/pt-mat.h
--- a/src/pt-mat.h
+++ b/src/pt-mat.h
@@ -22,17 +22,17 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_tree_mat_h)
 #define octave_tree_mat_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
-class ostream;
+#include <iostream>
 
 class octave_value;
 class octave_value_list;
 class tree_argument_list;
 
 class tree_walker;
 
 #include <SLList.h>
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -63,17 +63,17 @@ Software Foundation, 59 Temple Place - S
 #include "utils.h"
 #include "variables.h"
 
 // If TRUE, a replot command is issued automatically each time a plot
 // changes in some way.
 static bool Vautomatic_replot;
 
 // The name of the shell command to execute to start gnuplot.
-static string Vgnuplot_binary;
+static std::string Vgnuplot_binary;
 
 // TRUE if gnuplot appears to support multiple plot windows with X11.
 static bool Vgnuplot_has_frames;
 
 // TRUE if gnuplot appears to support multiplot.
 static bool Vgnuplot_has_multiplot;
 
 // The number of lines we've plotted so far.
@@ -87,33 +87,33 @@ static char *gnuplot_terminal_type = 0;
 
 // Should the graph window be cleared before plotting the next line?
 static bool clear_before_plotting = true;
 
 // List of files to delete when we exit or crash.
 //
 // XXX FIXME XXX -- this should really be static, but that causes
 // problems on some systems.
-SLStack <string> tmp_files;
+SLStack <std::string> tmp_files;
 
 // Pipe to gnuplot.
 static oprocstream *plot_stream = 0;
 
 // ID of the plotter process.
 static pid_t plot_stream_pid = 0;
 
 // Gnuplot command strings that we use.
-static string Vgnuplot_command_plot;
-static string Vgnuplot_command_replot;
-static string Vgnuplot_command_splot;
-static string Vgnuplot_command_using;
-static string Vgnuplot_command_with;
-static string Vgnuplot_command_axes;
-static string Vgnuplot_command_title;
-static string Vgnuplot_command_end;
+static std::string Vgnuplot_command_plot;
+static std::string Vgnuplot_command_replot;
+static std::string Vgnuplot_command_splot;
+static std::string Vgnuplot_command_using;
+static std::string Vgnuplot_command_with;
+static std::string Vgnuplot_command_axes;
+static std::string Vgnuplot_command_title;
+static std::string Vgnuplot_command_end;
 
 static void
 plot_stream_death_handler (pid_t pid, int)
 {
   close_plot_stream ();
 
   warning ("connection to external plotter (pid = %d) lost --", pid);
   warning ("please try your plot command(s) again");
@@ -131,17 +131,17 @@ open_plot_stream (void)
     }
 
   if (! plot_stream)
     {
       initialized = false;
 
       plot_line_count = 0;
 
-      string plot_prog = Vgnuplot_binary;
+      std::string plot_prog = Vgnuplot_binary;
 
       if (plot_prog.empty ())
 	plot_prog = "gnuplot";
 
       // XXX FIXME XXX -- I'm not sure this is the right thing to do,
       // but without it, C-c at the octave prompt will kill gnuplot...
 
 #if defined (HAVE_POSIX_SIGNALS)
@@ -240,17 +240,17 @@ tree_plot_command::~tree_plot_command (v
 void
 tree_plot_command::eval (void)
 {
   if (error_state)
     return;
 
   open_plot_stream ();
 
-  ostrstream plot_buf;
+  std::ostrstream plot_buf;
 
   switch (ndim)
     {
     case 1:
       if (plot_line_count == 0)
 	{
 	  if (plot_list)
 	    plot_buf << Vgnuplot_command_plot;
@@ -341,17 +341,17 @@ tree_plot_command::accept (tree_walker& 
 plot_limits::~plot_limits (void)
 {
   delete x_range;
   delete y_range;
   delete z_range;
 }
 
 void
-plot_limits::print (int ndim, ostrstream& plot_buf)
+plot_limits::print (int ndim, std::ostrstream& plot_buf)
 {
   if (ndim  == 2 || ndim == 3)
     {
       if (x_range)
 	x_range->print (plot_buf);
       else
 	return;
 
@@ -373,17 +373,17 @@ plot_limits::accept (tree_walker& tw)
 
 plot_range::~plot_range (void)
 {
   delete lower;
   delete upper;
 }
 
 void
-plot_range::print (ostrstream& plot_buf)
+plot_range::print (std::ostrstream& plot_buf)
 {
   plot_buf << " [";
 
   if (lower)
     {
       octave_value lower_val = lower->rvalue ();
 
       if (error_state)
@@ -496,17 +496,17 @@ subplot_using::values (int ndim, int n_m
 
   if (status < 0)
     return -1;
 
   return val;
 }
 
 int
-subplot_using::print (int ndim, int n_max, ostrstream& plot_buf)
+subplot_using::print (int ndim, int n_max, std::ostrstream& plot_buf)
 {
   int status = eval (ndim, n_max);
 
   if (status < 0)
     return -1;
 
   for (int i = 0; i < qual_count; i++)
     {
@@ -529,17 +529,17 @@ subplot_using::accept (tree_walker& tw)
 
 subplot_style::~subplot_style (void)
 {
   delete sp_linetype;
   delete sp_pointtype;
 }
 
 int
-subplot_style::print (ostrstream& plot_buf)
+subplot_style::print (std::ostrstream& plot_buf)
 {
   if (! sp_style.empty ())
     {
       plot_buf << " " << Vgnuplot_command_with << " " << sp_style;
 
       if (sp_linetype)
 	{
 	  octave_value tmp = sp_linetype->rvalue ();
@@ -621,17 +621,17 @@ subplot_style::columns_ok (int nc)
 
 void
 subplot_style::accept (tree_walker& tw)
 {
   tw.visit_subplot_style (*this);
 }
 
 int
-subplot_axes::print (ostrstream& plot_buf)
+subplot_axes::print (std::ostrstream& plot_buf)
 {
   if (! sp_axes.empty ())
     plot_buf << " " << Vgnuplot_command_axes << " " << sp_axes;
 
   return 0;
 }
 
 void
@@ -677,37 +677,37 @@ subplot::extract_plot_data (int ndim, oc
 
   if (ndim == 2 && sp_style_clause && ! sp_style_clause->columns_ok (nc))
     return octave_value ();
 
   return retval;
 }
 
 int
-subplot::handle_plot_data (int ndim, ostrstream& plot_buf)
+subplot::handle_plot_data (int ndim, std::ostrstream& plot_buf)
 {
   if (sp_plot_data)
     {
       octave_value data = sp_plot_data->rvalue ();
 
       if (! error_state && data.is_defined ())
 	{
-	  string file;
+	  std::string file;
 
 	  if (data.is_string ())
 	    {
 	      // Should really try to look at data file to determine
 	      // n_max.  Can't do much about other arbitrary gnuplot
 	      // commands though...
 
 	      int n_max = 0;
 
 	      file = file_ops::tilde_expand (data.string_value ());
 
-	      ifstream ftmp (file.c_str ());
+	      std::ifstream ftmp (file.c_str ());
 
 	      if (ftmp)
 		{
 		  plot_buf << " \"" << file << '"';
 		}
 	      else
 		{
 		  file = "";
@@ -764,17 +764,17 @@ subplot::handle_plot_data (int ndim, ost
     }
   else
     return -1;
 
   return 0;
 }
 
 int
-subplot::print (int ndim, ostrstream& plot_buf)
+subplot::print (int ndim, std::ostrstream& plot_buf)
 {
   int status = handle_plot_data (ndim, plot_buf);
 
   if (status < 0)
     return -1;
 
   if (sp_axes_clause)
     {
@@ -822,17 +822,17 @@ subplot_list::~subplot_list (void)
   while (! empty ())
     {
       subplot *t = remove_front ();
       delete t;
     }
 }
 
 int
-subplot_list::print (int ndim, ostrstream& plot_buf)
+subplot_list::print (int ndim, std::ostrstream& plot_buf)
 {
   int status = 0;
 
   for (Pix p = first (); p != 0; next (p))
     {
       subplot *elt = this->operator () (p);
 
       plot_line_count++;
@@ -853,21 +853,21 @@ void
 subplot_list::accept (tree_walker& tw)
 {
   tw.visit_subplot_list (*this);
 }
 
 string
 save_in_tmp_file (octave_value& t, int ndim, bool parametric)
 {
-  string name = file_ops::tempnam ("", "oct-");
+  std::string name = file_ops::tempnam ("", "oct-");
 
   if (! name.empty ())
     {
-      ofstream file (name.c_str ());
+      std::ofstream file (name.c_str ());
 
       if (file)
 	{
 	  switch (ndim)
 	    {
 	    case 2:
 	      save_ascii_data (file, t, name, true);
 	      break;
@@ -887,27 +887,27 @@ save_in_tmp_file (octave_value& t, int n
 	  name.resize (0);
 	}
     }
 
   return name;
 }
 
 void
-mark_for_deletion (const string& file)
+mark_for_deletion (const std::string& file)
 {
   tmp_files.push (file);
 }
 
 void
 cleanup_tmp_files (void)
 {
   while (! tmp_files.empty ())
     {
-      string filename = tmp_files.pop ();
+      std::string filename = tmp_files.pop ();
       unlink (filename.c_str ());
     }
 }
 
 void
 close_plot_stream (void)
 {
   octave_child_list::remove (plot_stream_pid);
@@ -918,21 +918,21 @@ close_plot_stream (void)
       delete plot_stream;
       plot_stream = 0;
     }
 
   plot_line_count = 0;
 }
 
 void
-do_external_plotter_cd (const string& newdir)
+do_external_plotter_cd (const std::string& newdir)
 {
   if (plot_stream && *plot_stream)
     {
-      ostrstream plot_buf;
+      std::ostrstream plot_buf;
       plot_buf << "cd \"" << newdir << "\"" << Vgnuplot_command_end << ends;
       char *message = plot_buf.str ();
       send_to_plot_stream (message);
       delete [] message;
     }
 }
 
 DEFUN (clearplot, , ,
@@ -1069,17 +1069,17 @@ DEFUN (graw, args, ,
 @deftypefn {Built-in Function} {} graw (@var{string})\n\
 Send @var{string} directly to gnuplot subprocess.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1 && args(0).is_string ())
     {
-      string cmd = args(0).string_value ();
+      std::string cmd = args(0).string_value ();
 
       if (! (plot_stream && *plot_stream))
 	open_plot_stream ();
 
       if (! error_state)
 	{
 	  *plot_stream << cmd;
 
@@ -1102,28 +1102,28 @@ Set plotting options for gnuplot\n\
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("set");
 
   if (error_state)
     return retval;
 
-  ostrstream plot_buf;
+  std::ostrstream plot_buf;
 
   if (argc > 1)
     {
       if (almost_match ("parametric", argv[1], 3))
 	parametric_plot = true;
       else if (almost_match ("noparametric", argv[1], 5))
 	parametric_plot = false;
       else if (almost_match ("term", argv[1], 1))
 	{
 	  delete [] gnuplot_terminal_type;
-	  ostrstream buf;
+	  std::ostrstream buf;
 	  int i;
 	  for (i = 2; i < argc-1; i++)
 	    buf << argv[i] << " ";
 	  if (i < argc)
 	    buf << argv[i];
 	  buf << Vgnuplot_command_end << ends;
 	  gnuplot_terminal_type = buf.str ();
 	}
@@ -1164,17 +1164,17 @@ Show plotting options.\n\
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("show");
 
   if (error_state)
     return retval;
 
-  ostrstream plot_buf;
+  std::ostrstream plot_buf;
 
   int i;
   for (i = 0; i < argc-1; i++)
     plot_buf << argv[i] << " ";
   if (i < argc)
     plot_buf << argv[i];
 
   plot_buf << Vgnuplot_command_end << ends;
@@ -1199,21 +1199,21 @@ static int
 automatic_replot (void)
 {
   Vautomatic_replot = check_preference ("automatic_replot");
 
   return 0;
 }
 
 static int
-set_string_var (string& var, const char *nm)
+set_string_var (std::string& var, const char *nm)
 {
   int retval = 0;
 
-  string s = builtin_string_variable (nm);
+  std::string s = builtin_string_variable (nm);
 
   if (s.empty ())
     {
       gripe_invalid_value_specified (nm);
       retval = -1;
     }
   else
     var = s;
diff --git a/src/pt-plot.h b/src/pt-plot.h
--- a/src/pt-plot.h
+++ b/src/pt-plot.h
@@ -97,17 +97,17 @@ plot_limits
 public:
 
   plot_limits (plot_range *xlim = 0, plot_range *ylim = 0,
 	       plot_range *zlim = 0)
     : x_range (xlim), y_range (ylim), z_range (zlim) { }
 
   ~plot_limits (void);
 
-  void print (int ndim, ostrstream& plot_buf);
+  void print (int ndim, std::ostrstream& plot_buf);
 
   plot_range *x_limits (void) { return x_range; }
   plot_range *y_limits (void) { return y_range; }
   plot_range *z_limits (void) { return z_range; }
 
   void accept (tree_walker& tw);
 
 private:
@@ -130,17 +130,17 @@ plot_range
 {
 public:
 
   plot_range (tree_expression *l = 0, tree_expression *u = 0)
     : lower (l), upper (u) { }
 
   ~plot_range (void);
 
-  void print (ostrstream& plot_buf);
+  void print (std::ostrstream& plot_buf);
 
   tree_expression *lower_bound (void) { return lower; }
 
   tree_expression *upper_bound (void) { return upper; }
 
   void accept (tree_walker& tw);
 
 private:
@@ -185,17 +185,17 @@ public:
 
       return this;
     }
 
   int eval (int ndim, int n_max);
 
   ColumnVector values (int ndim, int n_max = 0);
 
-  int print (int ndim, int n_max, ostrstream& plot_buf);
+  int print (int ndim, int n_max, std::ostrstream& plot_buf);
 
   int qualifier_count (void) { return qual_count; }
 
   tree_expression **qualifiers (void) { return x; }
 
   tree_expression *scanf_format (void) { return scanf_fmt; }
 
   void accept (tree_walker& tw);
@@ -224,38 +224,38 @@ private:
   subplot_using& operator = (const subplot_using&);
 };
 
 class
 subplot_style
 {
 public:
 
-  subplot_style (const string& s = string (),
+  subplot_style (const std::string& s = std::string (),
 		 tree_expression *lt = 0, tree_expression *pt = 0)
     : sp_style (s), sp_linetype (lt), sp_pointtype (pt) { }
 
   ~subplot_style (void);
 
-  int print (ostrstream& plot_buf);
+  int print (std::ostrstream& plot_buf);
 
   bool columns_ok (int nc);
 
-  string style (void) { return sp_style; }
+  std::string style (void) { return sp_style; }
 
   tree_expression *linetype (void) { return sp_linetype; }
 
   tree_expression *pointtype (void) { return sp_pointtype; }
 
   void accept (tree_walker& tw);
 
 private:
 
   // The style we are using: `lines', `points', etc.
-  string sp_style;
+  std::string sp_style;
 
   // The number of the line type to use.
   tree_expression *sp_linetype;
 
   // The number of the point type to use.
   tree_expression *sp_pointtype;
 
   // No copying!
@@ -265,31 +265,31 @@ private:
   subplot_style& operator = (const subplot_style&);
 };
 
 class
 subplot_axes
 {
 public:
 
-  subplot_axes (const string& s = string ())
+  subplot_axes (const std::string& s = std::string ())
     : sp_axes (s) { }
 
   ~subplot_axes (void) { }
 
-  int print (ostrstream& plot_buf);
+  int print (std::ostrstream& plot_buf);
 
-  string axes (void) { return sp_axes; }
+  std::string axes (void) { return sp_axes; }
 
   void accept (tree_walker& tw);
 
 private:
 
   // The axes we are using: `x1y1', `x1y2', etc.
-  string sp_axes;
+  std::string sp_axes;
 
   // No copying!
 
   subplot_axes (const subplot_axes&);
 
   subplot_axes& operator = (const subplot_axes&);
 };
 
@@ -351,19 +351,19 @@ public:
 	  return this;
 	}
       else
 	return 0;
     }
 
   octave_value extract_plot_data (int ndim, octave_value& data);
 
-  int handle_plot_data (int ndim, ostrstream& plot_buf);
+  int handle_plot_data (int ndim, std::ostrstream& plot_buf);
 
-  int print (int ndim, ostrstream& plot_buf);
+  int print (int ndim, std::ostrstream& plot_buf);
 
   tree_expression *plot_data (void) { return sp_plot_data; }
 
   subplot_using *using_clause (void) { return sp_using_clause; }
 
   tree_expression *title_clause (void) { return sp_title_clause; }
 
   subplot_style *style_clause (void) { return sp_style_clause; }
@@ -404,39 +404,39 @@ public:
   subplot_list (void)
     : SLList<subplot *> () { }
 
   subplot_list (subplot *t)
     : SLList<subplot *> () { append (t); }
 
   ~subplot_list (void);
 
-  int print (int ndim, ostrstream& plot_buf);
+  int print (int ndim, std::ostrstream& plot_buf);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   subplot_list (const subplot_list&);
 
   subplot_list& operator = (const subplot_list&);
 };
 
-extern string save_in_tmp_file (octave_value& t, int ndim = 2,
+extern std::string save_in_tmp_file (octave_value& t, int ndim = 2,
 				bool parametric = false);
 
-extern void mark_for_deletion (const string&);
+extern void mark_for_deletion (const std::string&);
 
 extern void cleanup_tmp_files (void);
 
 extern void close_plot_stream (void);
 
-extern void do_external_plotter_cd (const string& newdir);
+extern void do_external_plotter_cd (const std::string& newdir);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-pr-code.cc b/src/pt-pr-code.cc
--- a/src/pt-pr-code.cc
+++ b/src/pt-pr-code.cc
@@ -297,19 +297,19 @@ tree_print_code::visit_octave_user_funct
 	}
 
       if (len > 1 || takes_var_return)
 	os << "]";
 
       os << " = ";
     }
 
-  string fcn_name = fcn.function_name ();
+  std::string fcn_name = fcn.function_name ();
 
-  os << (fcn_name.empty () ? string ("(empty)") : fcn_name) << " ";
+  os << (fcn_name.empty () ? std::string ("(empty)") : fcn_name) << " ";
 
   tree_parameter_list *param_list = fcn.parameter_list ();
 
   if (param_list)
     {
       bool takes_varargs = fcn.takes_varargs ();
 
       int len = param_list->length ();
@@ -352,18 +352,18 @@ tree_print_code::visit_octave_user_funct
 
 void
 tree_print_code::visit_identifier (tree_identifier& id)
 {
   indent ();
 
   print_parens (id, "(");
 
-  string nm = id.name ();
-  os << (nm.empty () ? string ("(empty)") : nm);
+  std::string nm = id.name ();
+  os << (nm.empty () ? std::string ("(empty)") : nm);
 
   print_parens (id, ")");
 }
 
 void
 tree_print_code::visit_if_clause (tree_if_clause& cmd)
 {
   tree_expression *expr = cmd.condition ();
diff --git a/src/pt-pr-code.h b/src/pt-pr-code.h
--- a/src/pt-pr-code.h
+++ b/src/pt-pr-code.h
@@ -35,17 +35,17 @@ class tree_expression;
 
 // How to print the code that the parse trees represent.
 
 class
 tree_print_code : public tree_walker
 {
 public:
 
-  tree_print_code (ostream& os_arg, const string& pfx = string (),
+  tree_print_code (std::ostream& os_arg, const std::string& pfx = std::string (),
 		   bool pr_orig_txt = true)
     : os (os_arg), prefix (pfx), print_original_text (pr_orig_txt) { }
 
   ~tree_print_code (void) { }
 
   void visit_argument_list (tree_argument_list&);
 
   void visit_binary_expression (tree_binary_expression&);
@@ -137,19 +137,19 @@ public:
   void visit_unwind_protect_command (tree_unwind_protect_command&);
 
   void visit_while_command (tree_while_command&);
 
   void visit_do_until_command (tree_do_until_command&);
 
 private:
 
-  ostream& os;
+  std::ostream& os;
 
-  string prefix;
+  std::string prefix;
 
   bool print_original_text;
 
   static int curr_print_indent_level;
   static bool beginning_of_line;
 
   void reset_indent_level (void)
     { curr_print_indent_level = 0; }
diff --git a/src/pt-unop.h b/src/pt-unop.h
--- a/src/pt-unop.h
+++ b/src/pt-unop.h
@@ -53,17 +53,17 @@ public:
 			 octave_value::unary_op t
 			   = octave_value::unknown_unary_op)
     : tree_expression (l, c), op (e), etype (t) { }
 
   ~tree_unary_expression (void) { delete op; }
 
   tree_expression *operand (void) { return op; }
 
-  string oper (void) const;
+  std::string oper (void) const;
 
 protected:
 
   // The operand for the expression.
   tree_expression *op;
 
   // The type of the expression.
   octave_value::unary_op etype;
diff --git a/src/pt.cc b/src/pt.cc
--- a/src/pt.cc
+++ b/src/pt.cc
@@ -36,27 +36,27 @@ Software Foundation, 59 Temple Place - S
 #include "pt-pr-code.h"
 
 // Hide the details of the string buffer so that we are less likely to
 // create a memory leak.
 
 string
 tree::str_print_code (void)
 {
-  ostrstream buf;
+  std::ostrstream buf;
 
   tree_print_code tpc (buf);
 
   accept (tpc);
 
   buf << ends;
 
   const char *s = buf.str ();
 
-  string retval = s;
+  std::string retval = s;
 
   delete [] s;
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/pt.h b/src/pt.h
--- a/src/pt.h
+++ b/src/pt.h
@@ -51,17 +51,17 @@ public:
   virtual int line (void) const
     { return line_num; }
 
   virtual int column (void) const
     { return column_num; }
 
   virtual void accept (tree_walker& tw) = 0;
 
-  string str_print_code (void);
+  std::string str_print_code (void);
 
 private:
 
   // The input line and column where we found the text that was
   // eventually converted to this tree node.
   int line_num;
   int column_num;
 
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -56,17 +56,17 @@ static int Vvariables_can_hide_functions
 octave_allocator
 symbol_record::symbol_def::allocator (sizeof (symbol_record::symbol_def));
 
 #define SYMBOL_DEF symbol_record::symbol_def
 
 string
 SYMBOL_DEF::type_as_string (void) const
 {
-  string retval = "<unknown type>";
+  std::string retval = "<unknown type>";
 
   if (is_user_variable ())
     retval = "user-defined variable";
   else if (is_text_function ())
     retval = "built-in text function";
   else if (is_mapper_function ())
     retval = "built-in mapper function";
   else if (is_user_function ())
@@ -79,28 +79,28 @@ SYMBOL_DEF::type_as_string (void) const
     retval = "built-in function";
   else if (is_dld_function ())
     retval = "dynamically-linked function";
 
   return retval;
 }
 
 void
-SYMBOL_DEF::type (ostream& os, const string& name, bool pr_type_info,
+SYMBOL_DEF::type (std::ostream& os, const std::string& name, bool pr_type_info,
 		  bool quiet, bool pr_orig_txt)
 {
   if (is_user_function ())
     {
       octave_function *defn = definition.function_value ();
 
-      string fn = defn ? defn->fcn_file_name () : string ();
+      std::string fn = defn ? defn->fcn_file_name () : std::string ();
 
       if (pr_orig_txt && ! fn.empty ())
 	{
-	  ifstream fs (fn.c_str (), ios::in);
+	  std::ifstream fs (fn.c_str (), ios::in);
 
 	  if (fs)
 	    {
 	      if (pr_type_info && ! quiet)
 		os << name << " is the " << type_as_string ()
 		   << " defined from: " << fn << "\n\n";
 
 	      char ch;
@@ -133,43 +133,43 @@ SYMBOL_DEF::type (ostream& os, const str
       if (pr_type_info)
 	os << "\n";
     }
   else
     os << name << " is a " << type_as_string () << "\n";
 }
 
 string
-SYMBOL_DEF::which (const string& name)
+SYMBOL_DEF::which (const std::string& name)
 {
-  string retval;
+  std::string retval;
 
   if (is_user_function () || is_dld_function ())
     {
       octave_function *defn = definition.function_value ();
 
       if (defn)
 	retval = defn->fcn_file_name ();
     }
   else
     retval = name + " is a " + type_as_string ();
 
   return retval;
 }
 
 void
-SYMBOL_DEF::which (ostream& os, const string& name)
+SYMBOL_DEF::which (std::ostream& os, const std::string& name)
 {
   os << name;
 
   if (is_user_function () || is_dld_function ())
     {
       octave_function *defn = definition.function_value ();
 
-      string fn = defn ? defn->fcn_file_name () : string ();
+      std::string fn = defn ? defn->fcn_file_name () : std::string ();
 
       if (! fn.empty ())
 	{
 	  os << " is the " << type_as_string () << " from the file\n"
 	     << fn << "\n";
 
 	  return;
 	}
@@ -187,17 +187,17 @@ SYMBOL_DEF::dump_symbol_info (void)
 }
 
 // Individual records in a symbol table.
 
 // XXX FIXME XXX -- there are lots of places below where we should
 // probably be temporarily ignoring interrupts.
 
 void
-symbol_record::rename (const string& new_name)
+symbol_record::rename (const std::string& new_name)
 {
   if (! read_only_error ("rename"))
     nm = new_name;
 }
 
 void
 symbol_record::define (const octave_value& v, unsigned int sym_type)
 {
@@ -440,17 +440,17 @@ symbol_record::pop_context (void)
     {
       replace_all_defs (context.pop ());
 
       linked_to_global = global_link_context.pop ();
     }
 }
 
 void
-symbol_record::print_symbol_info_line (ostream& os)
+symbol_record::print_symbol_info_line (std::ostream& os)
 {
   os << (is_read_only () ? " r-" : " rw")
      << (is_eternal () ? "-" : "d")
 #if 0
      << (hides_fcn () ? "f" : (hides_builtin () ? "F" : "-"))
 #endif
      << "  "
      << setiosflags (ios::left) << setw (24) << type_name () . c_str ();
@@ -536,17 +536,17 @@ symbol_record::replace_all_defs (symbol_
     sd = new symbol_def ();
 
   push_def (sd);
 }
 
 // A symbol table.
 
 symbol_record *
-symbol_table::lookup (const string& nm, bool insert, bool warn)
+symbol_table::lookup (const std::string& nm, bool insert, bool warn)
 {
   unsigned int index = hash (nm);
 
   symbol_record *ptr = table[index].next ();
 
   while (ptr)
     {
       if (ptr->name () == nm)
@@ -565,17 +565,17 @@ symbol_table::lookup (const string& nm, 
     }
   else if (warn)
     warning ("lookup: symbol `%s' not found", nm.c_str ());
 
   return 0;
 }
 
 void
-symbol_table::rename (const string& old_name, const string& new_name)
+symbol_table::rename (const std::string& old_name, const std::string& new_name)
 {
   unsigned int index = hash (old_name);
 
   symbol_record *prev = &table[index];
   symbol_record *ptr = prev->next ();
 
   while (ptr)
     {
@@ -622,17 +622,17 @@ symbol_table::clear (bool clear_user_fun
 	    }
 
 	  ptr = ptr->next ();
 	}
     }
 }
 
 bool
-symbol_table::clear (const string& nm, bool clear_user_functions)
+symbol_table::clear (const std::string& nm, bool clear_user_functions)
 {
   unsigned int index = hash (nm);
 
   symbol_record *ptr = table[index].next ();
 
   while (ptr)
     {
       if (ptr->name () == nm
@@ -664,17 +664,17 @@ symbol_table::size (void) const
 	  ptr = ptr->next ();
 	}
     }
 
   return count;
 }
 
 static bool
-matches_patterns (const string& name, const string_vector& pats)
+matches_patterns (const std::string& name, const string_vector& pats)
 {
   int npats = pats.length ();
 
   if (npats == 0)
     return true;
 
   glob_match pattern (pats);
 
@@ -701,17 +701,17 @@ symbol_table::symbol_list (const string_
       while (ptr)
 	{
 	  assert (count < n);
 
 	  unsigned int my_scope = ptr->is_linked_to_global () + 1; // Tricky...
 
 	  unsigned int my_type = ptr->type ();
 
-	  string my_name = ptr->name ();
+	  std::string my_name = ptr->name ();
 
 	  if ((type & my_type) && (scope & my_scope)
 	      && matches_patterns (my_name, pats))
 	    symbols(count++) = ptr;
 
 	  ptr = ptr->next ();
 	}
     }
@@ -746,25 +746,25 @@ symbol_table::name_list (const string_ve
 }
 
 static int
 maybe_list_cmp_fcn (const void *a_arg, const void *b_arg)
 {
   const symbol_record *a = *(X_CAST (const symbol_record **, a_arg));
   const symbol_record *b = *(X_CAST (const symbol_record **, b_arg));
 
-  string a_nm = a->name ();
-  string b_nm = b->name ();
+  std::string a_nm = a->name ();
+  std::string b_nm = b->name ();
 
   return a_nm.compare (b_nm);
 }
 
 int
 symbol_table::maybe_list (const char *header, const string_vector& argv,
-			  ostream& os, bool show_verbose,
+			  std::ostream& os, bool show_verbose,
 			  unsigned type, unsigned scope)
 {
   int status = 0;
 
   if (show_verbose)
     {
       Array<symbol_record *> symbols = symbol_list (argv, type, scope);
 
@@ -797,17 +797,17 @@ symbol_table::maybe_list (const char *he
 	  status = 1;
 	}
     }
 
   return status;
 }
 
 Array<symbol_record *>
-symbol_table::glob (const string& pat, unsigned int type,
+symbol_table::glob (const std::string& pat, unsigned int type,
 		    unsigned int scope) const
 {
   int count = 0;
 
   int n = size ();
 
   Array<symbol_record *> symbols (n);
 
@@ -921,17 +921,17 @@ symbol_table::print_stats (void)
   octave_stdout << "empty chains:     " << empty_chains << "\n";
   octave_stdout << "total chains:     " << table_size << "\n";
   octave_stdout << "total symbols:    " << count << "\n";
 }
 
 // Chris Torek's fave hash function.
 
 unsigned int
-symbol_table::hash (const string& str)
+symbol_table::hash (const std::string& str)
 {
   unsigned int h = 0;
 
   for (unsigned int i = 0; i < str.length (); i++)
     h = h * 33 + str[i];
 
   return h & (table_size - 1);
 }
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -119,59 +119,59 @@ private:
 
     bool is_builtin_function (void) const
       { return (symbol_type & symbol_record::BUILTIN_FUNCTION); }
 
     bool is_dld_function (void) const
       { return (symbol_type & symbol_record::DLD_FUNCTION); }
 
     // XXX FIXME XXX
-    bool is_map_element (const string& /* elts */) const
+    bool is_map_element (const std::string& /* elts */) const
       { return false; }
 
     bool is_defined (void) const
       { return definition.is_defined (); }
 
     bool is_read_only (void) const
       { return read_only; }
 
     bool is_eternal (void) const
       { return eternal; }
 
     int rows (void) const { return definition.rows (); }
     int columns (void) const { return definition.columns (); }
 
-    string type_name (void) const { return definition.type_name (); }
+    std::string type_name (void) const { return definition.type_name (); }
 
-    string type_as_string (void) const;
+    std::string type_as_string (void) const;
 
-    void type (ostream& os, const string& name, bool pr_type_info,
+    void type (std::ostream& os, const std::string& name, bool pr_type_info,
 	       bool quiet, bool pr_orig_txt);
 
-    string which (const string& name);
+    std::string which (const std::string& name);
 
-    void which (ostream& os, const string& name);
+    void which (std::ostream& os, const std::string& name);
 
     void define (const octave_value& val, unsigned int sym_type)
       {
 	definition = val;
 	symbol_type = sym_type;
       }
 
     void protect (void) { read_only = 1; }
 
     void unprotect (void) { read_only = 0; }
 
     void make_eternal (void) { eternal = 1; }
 
     octave_value& def (void) { return definition; }
 
-    string help (void) const { return help_string; }
+    std::string help (void) const { return help_string; }
 
-    void document (const string& h) { help_string = h; }
+    void document (const std::string& h) { help_string = h; }
 
     unsigned int type (void) { return symbol_type; }
 
     void *operator new (size_t size)
       { return allocator.alloc (size); }
 
     void operator delete (void *p, size_t size)
       { allocator.free (p, size); }
@@ -183,17 +183,17 @@ private:
 
     // Nonzero means this variable cannot be cleared.
     unsigned int eternal : 1;
 
     // Nonzero means this variable cannot be given a new value.
     unsigned int read_only : 1;
 
     // The doc string associated with this variable.
-    string help_string;
+    std::string help_string;
 
     // The value of this definition.  See ov.h and related files.
     octave_value definition;
 
     // Pointer to next definition in chain.  This is used so that
     // variables can hide function definitions, and so that the function
     // definitions can reappear if the variable is cleared.
     symbol_def *next_elem;
@@ -214,30 +214,30 @@ public:
 
   typedef int (*change_function) (void);
 
   symbol_record (void)
     : formal_param (0), linked_to_global (0), tagged_static (0),
       nm (), chg_fcn (0), definition (new symbol_def ()),
       next_elem (0) { }
 
-  symbol_record (const string& n, symbol_record *nxt)
+  symbol_record (const std::string& n, symbol_record *nxt)
     : formal_param (0), linked_to_global (0), tagged_static (0),
       nm (n), chg_fcn (0), definition (new symbol_def ()),
       next_elem (nxt) { }
 
   ~symbol_record (void) { }
 
-  string name (void) const { return nm; }
+  std::string name (void) const { return nm; }
 
-  string help (void) const { return definition->help (); }
+  std::string help (void) const { return definition->help (); }
 
   octave_value& def (void) { return definition->def (); }
 
-  void rename (const string& new_name);
+  void rename (const std::string& new_name);
 
   bool is_function (void) const
     { return definition->is_function (); }
 
   bool is_text_function (void) const
     { return definition->is_text_function (); }
 
   bool is_mapper_function (void) const
@@ -262,17 +262,17 @@ public:
     { return definition->is_variable (); }
 
   bool is_user_variable (void) const
     { return definition->is_user_variable (); }
 
   bool is_builtin_variable (void) const
     { return definition->is_builtin_variable (); }
 
-  bool is_map_element (const string& elts) const
+  bool is_map_element (const std::string& elts) const
     { return definition->is_map_element (elts); }
 
   unsigned int type (void) const { return definition->type (); }
 
   bool is_defined (void) const { return definition->is_defined (); }
 
   bool is_read_only (void) const { return definition->is_read_only (); }
 
@@ -289,17 +289,17 @@ public:
   void define (const octave_value& v, unsigned int sym_type = USER_VARIABLE);
 
   void define_builtin_var (const octave_value& v);
 
   bool define_builtin_const (const octave_value& v);
 
   bool define (octave_function *f, unsigned int sym_type);
 
-  void document (const string& h) { definition->document (h); }
+  void document (const std::string& h) { definition->document (h); }
 
   void clear (void);
 
   void alias (symbol_record *s, bool force = false);
 
   void mark_as_formal_parameter (void);
   bool is_formal_parameter (void) const { return formal_param; }
 
@@ -310,50 +310,50 @@ public:
   bool is_static (void) const { return tagged_static; }
 
   bool hides_fcn (void) const;
   bool hides_builtin (void) const;
 
   int rows (void) const { return definition->rows (); }
   int columns (void) const { return definition->columns (); }
 
-  string type_name (void) const { return definition->type_name (); }
+  std::string type_name (void) const { return definition->type_name (); }
 
-  string type_as_string (void) const
+  std::string type_as_string (void) const
     { return definition->type_as_string (); }
 
-  void type (ostream& os, bool pr_type_info, bool quiet, bool pr_orig_txt)
+  void type (std::ostream& os, bool pr_type_info, bool quiet, bool pr_orig_txt)
     { definition->type (os, name (), pr_type_info, quiet, pr_orig_txt); }
 
-  string which (void) { return definition->which (name ()); }
+  std::string which (void) { return definition->which (name ()); }
 
-  void which (ostream& os) { definition->which (os, name ()); }
+  void which (std::ostream& os) { definition->which (os, name ()); }
 
   octave_value& variable_value (void);
   octave_lvalue variable_reference (void);
 
   symbol_record *next (void) const { return next_elem; }
 
   void chain (symbol_record *s) { next_elem = s; }
 
   void push_context (void);
 
   void pop_context (void);
 
-  void print_symbol_info_line (ostream& os);
+  void print_symbol_info_line (std::ostream& os);
 
   void dump_symbol_info (void);
 
 private:
 
   unsigned int formal_param : 1;
   unsigned int linked_to_global : 1;
   unsigned int tagged_static : 1;
 
-  string nm;
+  std::string nm;
   change_function chg_fcn;
   symbol_def *definition;
   symbol_record *next_elem;
 
   // This should maybe be one stack with a structure containing all the
   // items we need to save for recursive calls...
   SLStack <symbol_def *> context;
   SLStack <unsigned int> global_link_context;
@@ -405,59 +405,59 @@ public:
     assert ((tab_size % 2) == 0);
   }
 
   ~symbol_table (void)
   {
     delete [] table;
   }
 
-  symbol_record *lookup (const string& nm, bool insert = false,
+  symbol_record *lookup (const std::string& nm, bool insert = false,
 			 bool warn = false);
 
-  void rename (const string& old_name, const string& new_name);
+  void rename (const std::string& old_name, const std::string& new_name);
 
   void clear (bool clear_user_functions = true);
-  bool clear (const string& nm, bool clear_user_functions = true);
+  bool clear (const std::string& nm, bool clear_user_functions = true);
 
   int size (void) const;
 
   Array<symbol_record *>
   symbol_list (const string_vector& pats = string_vector (),
 	       unsigned int type = SYMTAB_ALL_TYPES,
 	       unsigned int scope = SYMTAB_ALL_SCOPES) const;
 
 
   string_vector
   name_list (const string_vector& pats = string_vector (),
 	     bool sort = false, unsigned int type = SYMTAB_ALL_TYPES,
 	     unsigned int scope = SYMTAB_ALL_SCOPES) const;
 
 
   int maybe_list (const char *header, const string_vector& argv,
-		  ostream& os, bool show_verbose,
+		  std::ostream& os, bool show_verbose,
 		  unsigned type, unsigned scope);
   
-  Array<symbol_record *> glob (const string& pat = string ("*"),
+  Array<symbol_record *> glob (const std::string& pat = std::string ("*"),
 			       unsigned int type = SYMTAB_ALL_TYPES,
 			       unsigned int scope = SYMTAB_ALL_SCOPES) const;
 
   void push_context (void);
 
   void pop_context (void);
 
   void print_stats (void);
 
 private:
 
   unsigned int table_size;
 
   symbol_record *table;
 
-  unsigned int hash (const string& s);
+  unsigned int hash (const std::string& s);
 
   // No copying!
 
   symbol_table (const symbol_table&);
 
   symbol_table& operator = (const symbol_table&);
 };
 
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -96,17 +96,17 @@ Duplicate a file descriptor.\n\
 \n\
 If successful, @var{fid} is greater than zero and contains the new file\n\
 ID.  Otherwise, @var{fid} is negative and @var{msg} contains a\n\
 system-dependent error message.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       octave_stream old_stream
 	= octave_stream_list::lookup (args(0), "dup2");
@@ -118,17 +118,17 @@ system-dependent error message.\n\
 
 	  if (! error_state)
 	    {
 	      int i_old = old_stream.file_number ();
 	      int i_new = new_stream.file_number ();
 
 	      if (i_old >= 0 && i_new >= 0)
 		{
-		  string msg;
+		  std::string msg;
 
 		  int status = octave_syscalls::dup2 (i_old, i_new, msg);
 
 		  retval(0) = static_cast<double> (status);
 		  retval(1) = msg;
 		}
 	    }
 	}
@@ -157,24 +157,24 @@ will run @code{ls} and return you to you
 \n\
 If successful, @code{exec} does not return.  If @code{exec} does return,\n\
 @var{err} will be nonzero, and @var{msg} will contain a system-dependent\n\
 error message.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      string exec_file = args(0).string_value ();
+      std::string exec_file = args(0).string_value ();
 
       if (! error_state)
 	{
 	  string_vector exec_args;
 
 	  if (nargin == 2)
 	    {
 	      string_vector tmp = args(1).all_strings ();
@@ -197,17 +197,17 @@ error message.\n\
 	    {
 	      exec_args.resize (1);
 
 	      exec_args[0] = exec_file;
 	    }
 
 	  if (! error_state)
 	    {
-	      string msg;
+	      std::string msg;
 
 	      int status = octave_syscalls::execvp (exec_file, exec_args, msg);
 
 	      retval(0) = static_cast<double> (status);
 	      retval(1) = msg;
 	    }
 	}
       else
@@ -270,17 +270,17 @@ Set the file status flags for @var{fid} 
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 3)
     {
       int fid = args(0).int_value (true);
       int req = args(1).int_value (true);
@@ -288,17 +288,17 @@ system-dependent error message.\n\
 
       if (! error_state)
 	{
 	  // XXX FIXME XXX -- Need better checking here?
 	  if (fid < 0)
 	    error ("fcntl: invalid file id");
 	  else
 	    {
-	      string msg;
+	      std::string msg;
 
 	      int status = octave_syscalls::fcntl (fid, req, arg, msg);
 
 	      retval(0) = static_cast<double> (status);
 	      retval(1) = msg;
 	    }
 	}
       else
@@ -330,24 +330,24 @@ process.  If that fails, you should prob
 @item < 0\n\
 The call to @code{fork} failed for some reason.  You must take evasive\n\
 action.  A system dependent error message will be waiting in @var{msg}.\n\
 @end table\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
-      string msg;
+      std::string msg;
 
       pid_t pid = octave_syscalls::fork (msg);
 
       retval(0) = static_cast<double> (pid);
       retval(1) = msg;
     }
   else
     print_usage ("fork");
@@ -358,24 +358,24 @@ action.  A system dependent error messag
 DEFUN (getpgrp, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {pgid =} getpgrp ()\n\
 Return the process group id of the current process.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
-      string msg;
+      std::string msg;
 
       retval(0) = static_cast<double> (octave_syscalls::getpgrp (msg));
       retval(1) = msg;
     }
   else
     print_usage ("getpgrp");
 
   return retval;
@@ -494,25 +494,25 @@ DEFUN (lstat, args, ,
 @deftypefn {Built-in Function} {[@var{info}, @var{err}, @var{msg}] =} lstat (@var{file})\n\
 See stat.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
-      string fname = file_ops::tilde_expand (args(0).string_value ());
+      std::string fname = file_ops::tilde_expand (args(0).string_value ());
 
       if (! error_state)
 	{
 	  file_stat fs (fname, false);
 
 	  if (fs)
 	    {
-	      retval(2) = string ();
+	      retval(2) = std::string ();
 	      retval(1) = 0.0;
 	      retval(0) = octave_value (mk_stat_map (fs));
 	    }
 	  else
 	    {
 	      retval(2) = fs.error ();
 	      retval(1) = -1.0;
 	      retval(0) = Matrix ();
@@ -534,32 +534,32 @@ Create a @var{fifo} special file named @
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
       if (args(0).is_string ())
 	{
-	  string name = args(0).string_value ();
+	  std::string name = args(0).string_value ();
 
 	  if (args(1).is_scalar_type ())
 	    {
 	      long mode = static_cast<long> (args(1).double_value ());
 
-	      string msg;
+	      std::string msg;
 
 	      int status = file_ops::mkfifo (name, mode, msg);
 
 	      retval(0) = static_cast<double> (status);
 
 	      if (status < 0)
 		retval(1) = msg;
 	    }
@@ -583,39 +583,39 @@ to the reading and writing ends of the p
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(2) = string ();
+  retval(2) = std::string ();
   retval(1) = -1.0;
   retval(0) = Matrix ();
 
   int nargin = args.length ();
 
   if (nargin == 0)
     {
       int fid[2];
 
-      string msg;
+      std::string msg;
 
       int status = octave_syscalls::pipe (fid, msg);
 
       if (status < 0)
 	retval(2) = msg;
       else
 	{
 	  FILE *ifile = fdopen (fid[0], "r");
 	  FILE *ofile = fdopen (fid[1], "w");
 
-	  octave_stream is = octave_istdiostream::create (string (), ifile);
-	  octave_stream os = octave_ostdiostream::create (string (), ofile);
+	  octave_stream is = octave_istdiostream::create (std::string (), ifile);
+	  octave_stream os = octave_ostdiostream::create (std::string (), ofile);
 
 	  octave_value_list file_ids;
 
 	  file_ids(1) = octave_stream_list::insert (os);
 	  file_ids(0) = octave_stream_list::insert (is);
 
 	  retval(1) = static_cast<double> (status);
           retval(0) = octave_value (file_ids);
@@ -714,25 +714,25 @@ For example,\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 1)
     {
-      string fname = file_ops::tilde_expand (args(0).string_value ());
+      std::string fname = file_ops::tilde_expand (args(0).string_value ());
 
       if (! error_state)
 	{
 	  file_stat fs (fname);
 
 	  if (fs)
 	    {
-	      retval(2) = string ();
+	      retval(2) = std::string ();
 	      retval(1) = 0.0;
 	      retval(0) = octave_value (mk_stat_map (fs));
 	    }
 	  else
 	    {
 	      retval(2) = fs.error ();
 	      retval(1) = -1.0;
 	      retval(0) = Matrix ();
@@ -752,28 +752,28 @@ Delete the file named @var{file}.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a\n\
 system-dependent error message.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       if (args(0).is_string ())
 	{
-	  string name = args(0).string_value ();
+	  std::string name = args(0).string_value ();
 
-	  string msg;
+	  std::string msg;
 
 	  int status = file_ops::unlink (name, msg);
 
 	  retval(0) = static_cast<double> (status);
 	  retval(1) = msg;	    
 	}
       else
 	error ("unlink: file name must be a string");
@@ -822,17 +822,17 @@ Implies both 1 and 2.\n\
 If the returned value of @var{pid} is greater than 0, it is the process\n\
 ID of the child process that exited.  If an error occurs, @var{pid} will\n\
 be less than zero and @var{msg} will contain a system-dependent error\n\
 message.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  retval(1) = string ();
+  retval(1) = std::string ();
   retval(0) = -1.0;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
       pid_t pid = args(0).int_value (true);
   
@@ -850,17 +850,17 @@ message.\n\
 		    error ("waitpid: invalid OPTIONS value specified");
 		}
 	      else
 		error ("waitpid: OPTIONS must be in integer");
 	    }
 
 	  if (! error_state)
 	    {
-	      string msg;
+	      std::string msg;
 
 	      pid_t status = octave_syscalls::waitpid (pid, options, msg);
 
 	      retval(0) = static_cast<double> (status);
 	      retval(1) = msg;
 	    }
 	}
       else
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -346,17 +346,17 @@ returns a string containing the value of
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      string name = args(0).string_value ();
+      std::string name = args(0).string_value ();
 
       if (! error_state)
 	retval = octave_env::getenv (name);
     }
   else
     print_usage ("getenv");
 
   return retval;
@@ -369,21 +369,21 @@ Set the value of the environment variabl
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
-      string var = args(0).string_value (); 
+      std::string var = args(0).string_value (); 
 
       if (! error_state)
 	{
-	  string val = args(1).string_value (); 
+	  std::string val = args(1).string_value (); 
 
 	  if (! error_state)
 	    octave_env::putenv (var, val);
 	  else
 	    error ("putenv: second argument should be a string");
 	}
       else
 	error ("putenv: first argument should be a string");
diff --git a/src/token.cc b/src/token.cc
--- a/src/token.cc
+++ b/src/token.cc
@@ -38,25 +38,25 @@ Software Foundation, 59 Temple Place - S
 
 token::token (int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = generic_token;
 }
 
-token::token (const string& s, int l, int c)
+token::token (const std::string& s, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = string_token;
-  str = new string (s);
+  str = new std::string (s);
 }
 
-token::token (double d, const string& s, int l, int c)
+token::token (double d, const std::string& s, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = double_token;
   num = d;
   orig_text = s;
 }
 
diff --git a/src/token.h b/src/token.h
--- a/src/token.h
+++ b/src/token.h
@@ -60,51 +60,51 @@ public:
   enum plot_tok_type
     {
       replot = 1,
       two_dee = 2,
       three_dee = 3,
     };
 
   token (int l = -1, int c = -1);
-  token (const string& s, int l = -1, int c = -1);
-  token (double d, const string& s = string (), int l = -1, int c = -1);
+  token (const std::string& s, int l = -1, int c = -1);
+  token (double d, const std::string& s = std::string (), int l = -1, int c = -1);
   token (end_tok_type t, int l = -1, int c = -1);
   token (plot_tok_type t, int l = -1, int c = -1);
   token (symbol_record *s, int l = -1, int c = -1);
 
   ~token (void);
 
   int line (void) { return line_num; }
   int column (void) { return column_num; }
 
-  string text (void);
+  std::string text (void);
   double number (void);
   end_tok_type ettype (void);
   plot_tok_type pttype (void);
   symbol_record *sym_rec (void);
 
-  string text_rep (void);
+  std::string text_rep (void);
 
 private:
   token (const token& tok);
   token& operator = (const token& tok);
 
   int line_num;
   int column_num;
   token_type type_tag;
   union
     {
-      string *str;
+      std::string *str;
       double num;
       end_tok_type et;
       plot_tok_type pt;
       symbol_record *sr;
     };
-  string orig_text;
+  std::string orig_text;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -217,17 +217,17 @@ x = computer ()\n\
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 0)
     warning ("computer: ignoring extra arguments");
 
-  string msg;
+  std::string msg;
 
   if (strcmp (CANONICAL_HOST_TYPE, "unknown") == 0)
     msg = "Hi Dave, I'm a HAL-9000";
   else
     msg = CANONICAL_HOST_TYPE;
 
   if (nargout == 0)
     octave_stdout << msg << "\n";
@@ -307,29 +307,29 @@ cleanup_iprocstream (void *p)
   iprocstream *cmd = static_cast<iprocstream *> (p);
 
   octave_child_list::remove (cmd->pid ());
 
   delete cmd;
 }
 
 static octave_value_list
-run_command_and_return_output (const string& cmd_str)
+run_command_and_return_output (const std::string& cmd_str)
 {
   octave_value_list retval;
 
   iprocstream *cmd = new iprocstream (cmd_str.c_str ());
 
   if (cmd)
     {
       unwind_protect::add (cleanup_iprocstream, cmd);
 
       if (*cmd)
 	{
-	  ostrstream output_buf;
+	  std::ostrstream output_buf;
 
 	  // XXX FIXME XXX -- sometimes, the subprocess hasn't written
 	  // anything before we try to read from the procstream.  The
 	  // kluge below (simply waiting and trying again) is ugly,
 	  // but it seems to work, at least most of the time.  It
 	  // could probably still fail if the subprocess hasn't
 	  // started writing after the snooze.  Isn't there a better
 	  // way?  If there is, you should also fix the code for the
@@ -419,43 +419,43 @@ variable @code{status} to the integer @s
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0 && nargin < 4)
     {
       bool return_output = (nargout > 0 || nargin > 1);
 
-      string cmd_str = args(0).string_value ();
+      std::string cmd_str = args(0).string_value ();
 
       enum exec_type { sync, async };
 
       exec_type type = sync;
 
       if (! error_state)
 	{
 	  if (nargin > 2)
 	    {
-	      string type_str = args(2).string_value ();
+	      std::string type_str = args(2).string_value ();
 
 	      if (! error_state)
 		{
 		  if (type_str == "sync")
 		    type = sync;
 		  else if (type_str == "async")
 		    type = async;
 		  else
 		    error ("system: third arg must be \"sync\" or \"async\"");
 		}
 	      else
 		error ("system: third argument must be a string");
 	    }
 	}
       else
-	error ("system: expecting string as first argument");
+	error ("system: expecting std::string as first argument");
 
       if (! error_state)
 	{
 	  if (type == async)
 	    {
 	      pid_t pid = fork ();
 
 	      if (pid < 0) 
@@ -495,17 +495,17 @@ variable @code{status} to the integer @s
 
   return retval;
 }
 
 DEFALIAS (shell_cmd, system);
 
 // XXX FIXME XXX -- this should really be static, but that causes
 // problems on some systems.
-SLStack<string> octave_atexit_functions;
+SLStack<std::string> octave_atexit_functions;
 
 void
 do_octave_atexit (void)
 {
   static bool deja_vu = false;
 
   while (! octave_atexit_functions.empty ())
     {
@@ -561,17 +561,17 @@ will print a message when Octave exits.\
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
 #if defined (HAVE_ATEXIT) || defined (HAVE_ON_EXIT)
-      string arg = args(0).string_value ();
+      std::string arg = args(0).string_value ();
 
       if (! error_state)
 	octave_atexit_functions.push (arg);
       else
 	error ("atexit: argument must be a string");
 #else
       gripe_not_supported ("atexit");
 #endif
@@ -649,17 +649,17 @@ specified option.\n\
   m ["LIBPLPLOT"] = LIBPLPLOT;
   m ["LIBDLFCN"] = LIBDLFCN;
   m ["DEFS"] = DEFS;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      string arg = args(0).string_value ();
+      std::string arg = args(0).string_value ();
 
       if (! error_state)
 	retval = octave_value (m [arg.c_str ()]);
     }
   else if (nargin == 0)
     retval = octave_value (m);
   else
     print_usage ("octave_config_info");
diff --git a/src/unwind-prot.cc b/src/unwind-prot.cc
--- a/src/unwind-prot.cc
+++ b/src/unwind-prot.cc
@@ -57,17 +57,17 @@ public:
   };
 
   saved_variable (void);
 
   saved_variable (bool *p, bool v);
 
   saved_variable (int *p, int v);
 
-  saved_variable (string *p, const string& v);
+  saved_variable (std::string *p, const std::string& v);
 
   saved_variable (void **p, void *v);
 
   ~saved_variable (void);
 
   void restore_value (void);
 
   static void restore (void *s);
@@ -81,17 +81,17 @@ private:
       void *gen_ptr;
       void **ptr_to_gen_ptr;
     };
 
   union
     {
       bool bool_value;
       int int_value;
-      const string *str_value;
+      const std::string *str_value;
       void *gen_ptr_value;
     };
 
   var_type type_tag;
 
   size_t size;
 };
 
@@ -114,21 +114,21 @@ saved_variable::saved_variable (bool *p,
 saved_variable::saved_variable (int *p, int v)
 {
   type_tag = integer;
   ptr_to_int = p;
   int_value = v;
   size = sizeof (int);  // Is this necessary?
 }
 
-saved_variable::saved_variable (string *p, const string& v)
+saved_variable::saved_variable (std::string *p, const std::string& v)
 {
   type_tag = string_type;
   gen_ptr = p;
-  str_value = new string (v);
+  str_value = new std::string (v);
   size = sizeof (string);  // Is this necessary?
 }
 
 saved_variable::saved_variable (void **p, void *v)
 {
   type_tag = generic_ptr;
   ptr_to_gen_ptr = p;
   gen_ptr_value = v;
@@ -162,17 +162,17 @@ saved_variable::restore_value (void)
       *ptr_to_bool = bool_value;
       break;
 
     case integer:
       *ptr_to_int = int_value;
       break;
 
     case string_type:
-      (static_cast<string *> (gen_ptr)) -> assign (*str_value);
+      (static_cast<std::string *> (gen_ptr)) -> assign (*str_value);
       break;
 
     case generic_ptr:
       *ptr_to_gen_ptr = gen_ptr_value;
       break;
 
     case generic:
       memcpy (gen_ptr, gen_ptr_value, size);
@@ -212,41 +212,41 @@ unwind_protect::run (void)
 
 void
 unwind_protect::discard (void)
 {
   list.pop ();
 }
 
 void
-unwind_protect::begin_frame (const string& tag)
+unwind_protect::begin_frame (const std::string& tag)
 {
   unwind_elem elem (tag);
   list.push (elem);
 }
 
 void
-unwind_protect::run_frame (const string& tag)
+unwind_protect::run_frame (const std::string& tag)
 {
   while (! list.empty ())
     {
       unwind_elem el = list.pop ();
 
       unwind_elem::cleanup_func f = el.fptr ();
 
       if (f)
 	f (el.ptr ());
 
       if (tag == el.tag ())
 	break;
     }
 }
 
 void
-unwind_protect::discard_frame (const string& tag)
+unwind_protect::discard_frame (const std::string& tag)
 {
   while (! list.empty ())
     {
       unwind_elem el = list.pop ();
 
       if (tag == el.tag ())
 	break;
     }
@@ -282,17 +282,17 @@ unwind_protect::save_bool (bool *ptr, bo
 void
 unwind_protect::save_int (int *ptr, int value)
 {
   saved_variable *s = new saved_variable (ptr, value);
   add (saved_variable::restore, s);
 }
 
 void
-unwind_protect::save_str (string *ptr, const string& value)
+unwind_protect::save_str (std::string *ptr, const std::string& value)
 {
   saved_variable *s = new saved_variable (ptr, value);
   add (saved_variable::restore, s);
 }
 
 void
 unwind_protect::save_ptr (void **ptr, void *value)
 {
diff --git a/src/unwind-prot.h b/src/unwind-prot.h
--- a/src/unwind-prot.h
+++ b/src/unwind-prot.h
@@ -38,17 +38,17 @@ unwind_elem
 {
 public:
 
   typedef void (*cleanup_func) (void *ptr);
 
   unwind_elem (void)
     : ue_tag (), ue_fptr (0), ue_ptr (0) { }
 
-  unwind_elem (const string &t)
+  unwind_elem (const std::string &t)
     : ue_tag (t), ue_fptr (0), ue_ptr (0) { }
 
   unwind_elem (cleanup_func f, void *p)
     : ue_tag (), ue_fptr (f), ue_ptr (p) { }
 
   unwind_elem (const unwind_elem& el)
     : ue_tag (el.ue_tag), ue_fptr (el.ue_fptr), ue_ptr (el.ue_ptr) { }
 
@@ -58,25 +58,25 @@ public:
     {
       ue_tag = el.ue_tag;
       ue_fptr = el.ue_fptr;
       ue_ptr = el.ue_ptr;
 
       return *this;
     }
 
-  string tag (void) { return ue_tag; }
+  std::string tag (void) { return ue_tag; }
 
   cleanup_func fptr (void) { return ue_fptr; }
 
   void *ptr (void) { return ue_ptr; }
 
 private:
 
-  string ue_tag;
+  std::string ue_tag;
 
   cleanup_func ue_fptr;
 
   void *ue_ptr;
 };
 
 class
 unwind_protect
@@ -84,33 +84,33 @@ unwind_protect
 public:
 
   static void add (unwind_elem::cleanup_func fptr, void *ptr);
 
   static void run (void);
 
   static void discard (void);
 
-  static void begin_frame (const string& tag);
+  static void begin_frame (const std::string& tag);
 
-  static void run_frame (const string& tag);
+  static void run_frame (const std::string& tag);
 
-  static void discard_frame (const string& tag);
+  static void discard_frame (const std::string& tag);
 
   static void run_all (void);
 
   static void discard_all (void);
 
   // Ways to save variables.
 
   static void save_bool (bool *ptr, bool value);
 
   static void save_int (int *ptr, int value);
 
-  static void save_str (string *ptr, const string& value);
+  static void save_str (std::string *ptr, const std::string& value);
 
   static void save_ptr (void **ptr, void *value);
 
   static void save_var (void *ptr, void *value, size_t size);
 
   static SLStack<unwind_elem> list;
 };
 
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -90,33 +90,33 @@ void
 jump_to_top_level (void)
 {
   unwind_protect::run_all ();
 
   longjmp (toplevel, 1);
 }
 
 int
-almost_match (const string& std, const string& s, int min_match_len,
+almost_match (const std::string& std, const std::string& s, int min_match_len,
 	      int case_sens)
 {
   int stdlen = std.length ();
   int slen = s.length ();
 
   return (slen <= stdlen
 	  && slen >= min_match_len
 	  && (case_sens
 	      ? (strncmp (std.c_str (), s.c_str (), slen) == 0)
 	      : (octave_strncasecmp (std.c_str (), s.c_str (), slen) == 0)));
 }
 
 // Ugh.
 
 int
-keyword_almost_match (const char * const *std, int *min_len, const string& s,
+keyword_almost_match (const char * const *std, int *min_len, const std::string& s,
 		      int min_toks_to_match, int max_toks)
 {
   int status = 0;
   int tok_count = 0;
   int toks_matched = 0;
 
   if (s.empty () || max_toks < 1)
     return status;
@@ -224,17 +224,17 @@ empty_arg (const char *name, int nr, int
     }
 
   return is_empty;
 }
 
 // See if the given file is in the path.
 
 string
-search_path_for_file (const string& path, const string& name)
+search_path_for_file (const std::string& path, const std::string& name)
 {
   dir_path p (path);
 
   return octave_env::make_absolute (p.find (name), octave_env::getcwd ());
 }
 
 DEFUN (file_in_loadpath, args, ,
   "-*- texinfo -*-\n\
@@ -285,48 +285,48 @@ file_in_path (LOADPATH, \"nargchk.m\")\n
 
   string_vector argv = args.make_argv ("file_in_path");
 
   if (error_state)
     return retval;
 
   if (argc == 3)
     {
-      string fname = search_path_for_file (argv[1], argv[2]);
+      std::string fname = search_path_for_file (argv[1], argv[2]);
 
       if (fname.empty ())
 	retval = Matrix ();
       else
 	retval = fname;
     }
   else
     print_usage ("file_in_path");
 
   return retval;
 }
 
 string
-file_in_path (const string& name, const string& suffix)
+file_in_path (const std::string& name, const std::string& suffix)
 {
-  string nm = name;
+  std::string nm = name;
 
   if (! suffix.empty ())
     nm.append (suffix);
 
   return octave_env::make_absolute (Vload_path_dir_path.find (nm),
 				    octave_env::getcwd ());
 }
 
 // See if there is an function file in the path.  If so, return the
 // full path to the file.
 
 string
-fcn_file_in_path (const string& name)
+fcn_file_in_path (const std::string& name)
 {
-  string retval;
+  std::string retval;
 
   int len = name.length ();
   
   if (len > 0)
     {
       if (len > 2 && name [len - 2] == '.' && name [len - 1] == 'm')
 	retval = file_in_path (name, "");
       else
@@ -335,19 +335,19 @@ fcn_file_in_path (const string& name)
 
   return retval;
 }
 
 // See if there is an octave file in the path.  If so, return the
 // full path to the file.
 
 string
-oct_file_in_path (const string& name)
+oct_file_in_path (const std::string& name)
 {
-  string retval;
+  std::string retval;
 
   int len = name.length ();
   
   if (len > 0)
     {
       if (len > 2 && name [len - 4] == '.' && name [len - 3] == 'o'
 	  && name [len - 2] == 'c' && name [len - 1] == 't')
 	retval = file_in_path (name, "");
@@ -356,19 +356,19 @@ oct_file_in_path (const string& name)
     }
 
   return retval;
 }
 
 // Replace backslash escapes in a string with the real values.
 
 string
-do_string_escapes (const string& s)
+do_string_escapes (const std::string& s)
 {
-  string retval;
+  std::string retval;
 
   size_t i = 0;
   size_t j = 0;
   size_t len = s.length ();
 
   retval.resize (len);
 
   while (j < len)
@@ -502,19 +502,19 @@ undo_string_escape (char c)
 	retval[0] = c;
 	retval[1] = '\0';
 	return retval;
       }
     }
 }
 
 string
-undo_string_escapes (const string& s)
+undo_string_escapes (const std::string& s)
 {
-  string retval;
+  std::string retval;
 
   for (size_t i = 0; i < s.length (); i++)
     retval.append (undo_string_escape (s[i]));
 
   return retval;
 }
 
 DEFUN (undo_string_escapes, args, ,
@@ -558,36 +558,36 @@ representation.\n\
     }
   else
     print_usage ("undo_string_escapes");
 
   return retval;
 }
 
 static void
-warn_old_style_preference (bool val, const string& sval)
+warn_old_style_preference (bool val, const std::string& sval)
 {
   warning
     ("preference of \"%s\" is obsolete -- use numeric value of %d instead",
      sval.c_str (), (val ? 1 : 0));
 }
 
 // Check the value of a string variable to see if it it's ok to do
 // something.
 //
 //   return of  1 => always ok.
 //   return of  0 => never ok.
 //   return of -1 => ok, but give me warning (default).
 
 int
-check_preference (const string& var)
+check_preference (const std::string& var)
 {
   int pref = -1;
 
-  string val = builtin_string_variable (var);
+  std::string val = builtin_string_variable (var);
 
   if (val.empty ())
     {
       double dval = 0;
       if (builtin_real_scalar_variable (var, dval))
 	pref = NINT (dval);
     }
   else
diff --git a/src/utils.h b/src/utils.h
--- a/src/utils.h
+++ b/src/utils.h
@@ -27,40 +27,40 @@ Software Foundation, 59 Temple Place - S
 #include <string>
 
 #include "lo-utils.h"
 
 class octave_value;
 class octave_value_list;
 class string_vector;
 
-extern string search_path_for_file (const string&, const string&);
-extern string file_in_path (const string&, const string&);
-extern string fcn_file_in_path (const string&);
-extern string oct_file_in_path (const string&);
+extern std::string search_path_for_file (const std::string&, const std::string&);
+extern std::string file_in_path (const std::string&, const std::string&);
+extern std::string fcn_file_in_path (const std::string&);
+extern std::string oct_file_in_path (const std::string&);
 
 extern void jump_to_top_level (void) GCC_ATTR_NORETURN;
 
-extern int almost_match (const string& std, const string& s,
+extern int almost_match (const std::string& std, const std::string& s,
 			 int min_match_len = 1, int case_sens = 1);
 
 extern int
 keyword_almost_match (const char * const *std, int *min_len,
-		      const string& s, int min_toks_to_match,
+		      const std::string& s, int min_toks_to_match,
 		      int max_toks);
 
 extern int empty_arg (const char *name, int nr, int nc);
 
 extern const char *undo_string_escape (char c);
 
-extern string do_string_escapes (const string& s);
+extern std::string do_string_escapes (const std::string& s);
 
-extern string undo_string_escapes (const string& s);
+extern std::string undo_string_escapes (const std::string& s);
 
-extern int check_preference (const string& var);
+extern int check_preference (const std::string& var);
 
 extern void
 get_dimensions (const octave_value& a, const octave_value& b,
 		const char *warn_for, int& nr, int& nc);
 
 extern void
 get_dimensions (const octave_value& a,
 		const char *warn_for, int& nr, int& nc);
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -83,62 +83,62 @@ initialize_symbol_tables (void)
   curr_sym_tab = top_level_sym_tab;
 }
 
 // Attributes of variables and functions.
 
 // Is this variable a builtin?
 
 bool
-is_builtin_variable (const string& name)
+is_builtin_variable (const std::string& name)
 {
   symbol_record *sr = global_sym_tab->lookup (name);
   return (sr && sr->is_builtin_variable ());
 }
 
 // Is this a text-style function?
 
 bool
-is_text_function_name (const string& s)
+is_text_function_name (const std::string& s)
 {
   symbol_record *sr = global_sym_tab->lookup (s);
   return (sr && sr->is_text_function ());
 }
 
 // Is this a built-in function?
 
 bool
-is_builtin_function_name (const string& s)
+is_builtin_function_name (const std::string& s)
 {
   symbol_record *sr = global_sym_tab->lookup (s);
   return (sr && sr->is_builtin_function ());
 }
 
 // Is this a mapper function?
 
 bool
-is_mapper_function_name (const string& s)
+is_mapper_function_name (const std::string& s)
 {
   symbol_record *sr = global_sym_tab->lookup (s);
   return (sr && sr->is_mapper_function ());
 }
 
 // Is this function globally in this scope?
 
 bool
-is_globally_visible (const string& name)
+is_globally_visible (const std::string& name)
 {
   symbol_record *sr = curr_sym_tab->lookup (name);
   return (sr && sr->is_linked_to_global ());
 }
 
 // Is this octave_value a valid function?
 
 octave_function *
-is_valid_function (const string& fcn_name, const string& warn_for, bool warn)
+is_valid_function (const std::string& fcn_name, const std::string& warn_for, bool warn)
 {
   octave_function *ans = 0;
 
   symbol_record *sr = 0;
 
   if (! fcn_name.empty ())
     sr = lookup_by_name (fcn_name);
 
@@ -155,47 +155,47 @@ is_valid_function (const string& fcn_nam
 	       warn_for.c_str (), fcn_name.c_str ());
       ans = 0;
     }
 
   return ans;
 }
 
 octave_function *
-is_valid_function (const octave_value& arg, const string& warn_for, bool warn)
+is_valid_function (const octave_value& arg, const std::string& warn_for, bool warn)
 {
   octave_function *ans = 0;
 
-  string fcn_name;
+  std::string fcn_name;
 
   if (arg.is_string ())
     fcn_name = arg.string_value ();
 
   if (! error_state)
     ans = is_valid_function (fcn_name, warn_for, warn);
   else if (warn)
     error ("%s: expecting function name as argument", warn_for.c_str ());
 
   return ans;
 }
 
 octave_function *
-extract_function (const octave_value& arg, const string& warn_for,
-		  const string& fname, const string& header,
-		  const string& trailer)
+extract_function (const octave_value& arg, const std::string& warn_for,
+		  const std::string& fname, const std::string& header,
+		  const std::string& trailer)
 {
   octave_function *retval = 0;
 
   retval = is_valid_function (arg, warn_for, 0);
 
   if (! retval)
     {
-      string s = arg.string_value ();
+      std::string s = arg.string_value ();
 
-      string cmd = header;
+      std::string cmd = header;
       cmd.append (s);
       cmd.append (trailer);
 
       if (! error_state)
 	{
 	  int parse_status;
 
 	  eval_string (cmd, true, parse_status);
@@ -219,17 +219,17 @@ extract_function (const octave_value& ar
 	error ("%s: expecting first argument to be a string",
 	       warn_for.c_str ());
     }
 
   return retval;
 }
 
 string_vector
-get_struct_elts (const string& text)
+get_struct_elts (const std::string& text)
 {
   int n = 1;
 
   size_t pos = 0;
 
   size_t len = text.length ();
 
   while ((pos = text.find ('.', pos)) != NPOS)
@@ -256,23 +256,23 @@ get_struct_elts (const string& text)
       if (len != NPOS)
 	pos += len + 1;
     }
 
   return retval;
 }
 
 string_vector
-generate_struct_completions (const string& text, string& prefix, string& hint)
+generate_struct_completions (const std::string& text, std::string& prefix, std::string& hint)
 {
   string_vector names;
 
   size_t pos = text.rfind ('.');
 
-  string id;
+  std::string id;
   string_vector elts;
 
   if (pos == NPOS)
     {
       hint = text;
       prefix = text;
       elts.resize (1, text);
     }
@@ -319,23 +319,23 @@ generate_struct_completions (const strin
 	    }
 	}
     }
 
   return names;
 }
 
 bool
-looks_like_struct (const string& text)
+looks_like_struct (const std::string& text)
 {
   bool retval = true;
 
   string_vector elts = get_struct_elts (text);
 
-  string id = elts[0];
+  std::string id = elts[0];
 
   symbol_record *sr = curr_sym_tab->lookup (id);
 
   if (! sr)
     sr = global_sym_tab->lookup (id);
 
   if (sr && sr->is_defined ())
     {
@@ -386,21 +386,21 @@ is_global (\"x\")\n\
   int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ("is_global");
       return retval;
     }
 
-  string name = args(0).string_value ();
+  std::string name = args(0).string_value ();
 
   if (error_state)
     {
-      error ("is_global: expecting string argument");
+      error ("is_global: expecting std::string argument");
       return retval;
     }
 
   symbol_record *sr = curr_sym_tab->lookup (name);
 
   retval = static_cast<double> (sr && sr->is_linked_to_global ());
 
   return retval;
@@ -425,26 +425,26 @@ other types of files, you should use som
   int nargin = args.length ();
 
   if (nargin != 1)
     {
       print_usage ("exist");
       return retval;
     }
 
-  string name = args(0).string_value ();
+  std::string name = args(0).string_value ();
 
   if (error_state)
     {
-      error ("exist: expecting string argument");
+      error ("exist: expecting std::string argument");
       return retval;
     }
 
-  string struct_elts;
-  string symbol_name = name;
+  std::string struct_elts;
+  std::string symbol_name = name;
 
   size_t pos = name.find ('.');
 
   if (pos != NPOS && pos > 0)
     {
       struct_elts = name.substr (pos+1);
       symbol_name = name.substr (0, pos);
     }
@@ -470,33 +470,33 @@ other types of files, you should use som
       retval = 6.0;
     }
   else if (sr && sr->is_user_function ())
     {
       retval = 2.0;
     }
   else
     {
-      string path = fcn_file_in_path (name);
+      std::string path = fcn_file_in_path (name);
 
       if (path.length () > 0)
 	{
 	  retval = 2.0;
 	}
       else
 	{
 	  path = oct_file_in_path (name);
 
 	  if (path.length () > 0)
 	    {
 	      retval = 3.0;
 	    }
 	  else
 	    {
-	      string file_name = file_in_path (name, "");
+	      std::string file_name = file_in_path (name, "");
 
 	      if (! file_name.empty ())
 		{
 		  file_stat fs (file_name);
 
 		  if (fs && fs.is_reg ())
 		    retval = 2.0;
 		}
@@ -518,27 +518,27 @@ symbol_out_of_date (symbol_record *sr)
   if (Vignore_function_time_stamp != 2 && sr)
     {
       octave_value ans = sr->def ();
 
       octave_function *tmp = ans.function_value (true);
 
       if (tmp)
 	{
-	  string ff = tmp->fcn_file_name ();
+	  std::string ff = tmp->fcn_file_name ();
 
 	  if (! (ff.empty ()
 		 || (Vignore_function_time_stamp
 		     && tmp->is_system_fcn_file ())))
 	    {
 	      if (tmp->time_checked () < Vlast_prompt_time)
 		{
 		  time_t tp = tmp->time_parsed ();
 
-		  string fname;
+		  std::string fname;
 
 		  if (tmp->is_dld_function ())
 		    fname = ff;
 		  else
 		    fname = fcn_file_in_path (ff);
 
 		  tmp->mark_fcn_file_up_to_date (octave_time ());
 
@@ -582,27 +582,27 @@ lookup (symbol_record *sym_rec, bool exe
 
 // Get the symbol record for the given name that is visible in the
 // current scope.  Reread any function definitions that appear to be
 // out of date.  If a function is available in a file but is not
 // currently loaded, this will load it and insert the name in the
 // current symbol table.
 
 symbol_record *
-lookup_by_name (const string& nm, bool exec_script)
+lookup_by_name (const std::string& nm, bool exec_script)
 {
   symbol_record *sym_rec = curr_sym_tab->lookup (nm, true);
 
   lookup (sym_rec, exec_script);
 
   return sym_rec;
 }
 
 octave_value
-get_global_value (const string& nm)
+get_global_value (const std::string& nm)
 {
   octave_value retval;
 
   symbol_record *sr = global_sym_tab->lookup (nm);
 
   if (sr)
     {
       octave_value sr_def = sr->def ();
@@ -614,56 +614,56 @@ get_global_value (const string& nm)
     }
   else
     error ("get_global_by_name: unknown symbol `%s'", nm.c_str ());
 
   return retval;
 }
 
 void
-set_global_value (const string& nm, const octave_value& val)
+set_global_value (const std::string& nm, const octave_value& val)
 {
   symbol_record *sr = global_sym_tab->lookup (nm, true);
 
   if (sr)
     sr->define (val);
   else
     panic_impossible ();
 }
 
 // Variable values.
 
 // Look for the given name in the global symbol table.  If it refers
 // to a string, return a new copy.  If not, return 0;
 
-string
-builtin_string_variable (const string& name)
+std::string
+builtin_string_variable (const std::string& name)
 {
   symbol_record *sr = global_sym_tab->lookup (name);
 
   // It is a prorgramming error to look for builtins that aren't.
 
   assert (sr);
 
-  string retval;
+  std::string retval;
 
   octave_value val = sr->def ();
 
   if (! error_state && val.is_string ())
     retval = val.string_value ();
 
   return retval;
 }
 
 // Look for the given name in the global symbol table.  If it refers
 // to a real scalar, place the value in d and return 1.  Otherwise,
 // return 0.
 
 int
-builtin_real_scalar_variable (const string& name, double& d)
+builtin_real_scalar_variable (const std::string& name, double& d)
 {
   int status = 0;
   symbol_record *sr = global_sym_tab->lookup (name);
 
   // It is a prorgramming error to look for builtins that aren't.
 
   assert (sr);
 
@@ -676,17 +676,17 @@ builtin_real_scalar_variable (const stri
     }
 
   return status;
 }
 
 // Look for the given name in the global symbol table.
 
 octave_value
-builtin_any_variable (const string& name)
+builtin_any_variable (const std::string& name)
 {
   symbol_record *sr = global_sym_tab->lookup (name);
 
   // It is a prorgramming error to look for builtins that aren't.
 
   assert (sr);
 
   return sr->def ();
@@ -702,17 +702,17 @@ void
 link_to_global_variable (symbol_record *sr)
 {
   if (! sr->is_linked_to_global ())
     {
       sr->mark_as_linked_to_global ();
 
       if (! error_state)
 	{
-	  string nm = sr->name ();
+	  std::string nm = sr->name ();
 
 	  symbol_record *gsr = global_sym_tab->lookup (nm, true);
 
 	  // There must be a better way to do this.   XXX FIXME XXX
 
 	  if (sr->is_variable ())
 	    gsr->define (sr->def ());
 
@@ -751,17 +751,17 @@ link_to_builtin_or_function (symbol_reco
 // used just after defining a function to avoid different behavior
 // depending on whether or not the function has been evaluated after
 // being defined.
 //
 // Return without doing anything if there isn't a function with the
 // given name defined in the global symbol table.
 
 void
-force_link_to_function (const string& id_name)
+force_link_to_function (const std::string& id_name)
 {
   symbol_record *gsr = global_sym_tab->lookup (id_name, true);
   if (gsr->is_function ())
     {
       curr_sym_tab->clear (id_name);
       symbol_record *csr = curr_sym_tab->lookup (id_name, true);
       csr->alias (gsr);
     }
@@ -774,21 +774,21 @@ Set the documentation string for @var{sy
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
     {
-      string name = args(0).string_value ();
+      std::string name = args(0).string_value ();
 
       if (! error_state)
 	{
-	  string help = args(1).string_value ();
+	  std::string help = args(1).string_value ();
 
 	  if (! error_state)
 	    {
 	      if (is_builtin_variable (name)
 		  || is_text_function_name (name)
 		  || is_mapper_function_name (name)
 		  || is_builtin_function_name (name))
 		error ("document: can't redefine help for built-in variables and functions");
@@ -815,17 +815,17 @@ do_who (int argc, const string_vector& a
 {
   octave_value_list retval;
 
   bool show_builtins = false;
   bool show_functions = false;
   bool show_variables = false;
   bool show_verbose = false;
 
-  string my_name = argv[0];
+  std::string my_name = argv[0];
 
   int i;
   for (i = 1; i < argc; i++)
     {
       if (argv[i] == "-all" || argv[i] == "-a")
 	{
 	  show_builtins = true;
 	  show_functions = true;
@@ -1009,23 +1009,23 @@ bind_ans (const octave_value& val, bool 
 
 // Give a global constant a definition.  This will insert the symbol
 // in the global table if necessary.
 
 // How is this different than install_builtin_constant?  Are both
 // functions needed?
 
 void
-bind_builtin_constant (const string& name, const octave_value& val,
-		       bool protect, bool eternal, const string& help)
+bind_builtin_constant (const std::string& name, const octave_value& val,
+		       bool protect, bool eternal, const std::string& help)
 {
   symbol_record *sym_rec = global_sym_tab->lookup (name, true);
   sym_rec->unprotect ();
 
-  string tmp_help = help.empty () ? sym_rec->help () : help;
+  std::string tmp_help = help.empty () ? sym_rec->help () : help;
 
   sym_rec->define_builtin_const (val);
 
   sym_rec->document (tmp_help);
 
   if (protect)
     sym_rec->protect ();
 
@@ -1035,20 +1035,20 @@ bind_builtin_constant (const string& nam
 
 // Give a global variable a definition.  This will insert the symbol
 // in the global table if necessary.
 
 // How is this different than install_builtin_variable?  Are both
 // functions needed?
 
 void
-bind_builtin_variable (const string& varname, const octave_value& val,
+bind_builtin_variable (const std::string& varname, const octave_value& val,
 		       bool protect, bool eternal,
 		       symbol_record::change_function chg_fcn,
-		       const string& help)
+		       const std::string& help)
 {
   symbol_record *sr = global_sym_tab->lookup (varname, true);
 
   // It is a programming error for a builtin symbol to be missing.
   // Besides, we just inserted it, so it must be there.
 
   assert (sr);
 
@@ -1174,49 +1174,49 @@ This command may not be used within a fu
 	}
 
       // XXX FIXME XXX -- this needs to be optimized to avoid the
       // pattern matching code if the string doesn't contain any
       // globbing patterns.
 
       for (int k = idx; k < argc; k++)
 	{
-	  string patstr = argv[k];
+	  std::string patstr = argv[k];
 
 	  if (! patstr.empty ())
 	    {
 	      glob_match pattern (patstr);
 
 	      int lcount = lvars.length ();
 
 	      for (int i = 0; i < lcount; i++)
 		{
-		  string nm = lvars[i];
+		  std::string nm = lvars[i];
 		  int match = pattern.match (nm);
 		  if ((exclusive && ! match) || (! exclusive && match))
 		    curr_sym_tab->clear (nm);
 		}
 
 	      int gcount = gvars.length ();
 	      for (int i = 0; i < gcount; i++)
 		{
-		  string nm = gvars[i];
+		  std::string nm = gvars[i];
 		  int match = pattern.match (nm);
 		  if ((exclusive && ! match) || (! exclusive && match))
 		    {
 		      int count = curr_sym_tab->clear (nm);
 		      if (count > 0)
 			global_sym_tab->clear (nm, clear_user_functions);
 		    }
 		}
 
 	      int fcount = fcns.length ();
 	      for (int i = 0; i < fcount; i++)
 		{
-		  string nm = fcns[i];
+		  std::string nm = fcns[i];
 		  int match = pattern.match (nm);
 		  if ((exclusive && ! match) || (! exclusive && match))
 		    {
 		      curr_sym_tab->clear (nm);
 		      global_sym_tab->clear (nm, clear_user_functions);
 		    }
 		}
 	    }
@@ -1233,17 +1233,17 @@ Print raw symbol table statistices.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      string arg = args(0).string_value ();
+      std::string arg = args(0).string_value ();
 
       if (arg == "global")
 	global_sym_tab->print_stats ();
       else
 	print_usage ("__dump_symtab_info__");
     }
   else if (nargin == 0)
     curr_sym_tab->print_stats ();
@@ -1260,17 +1260,17 @@ Print symbol table information for the s
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
-      string symbol_name = args(0).string_value ();
+      std::string symbol_name = args(0).string_value ();
 
       if (! error_state)
 	{
 	  symbol_record *sr = curr_sym_tab->lookup (symbol_name);
 
 	  if (sr)
 	    sr->dump_symbol_info ();
 	  else
@@ -1289,17 +1289,17 @@ Print symbol table information for the s
 // XXX FIXME XXX -- some of these should do their own checking to be
 // able to provide more meaningful warning or error messages.
 
 static int
 ignore_function_time_stamp (void)
 {
   int pref = 0;
 
-  string val = builtin_string_variable ("ignore_function_time_stamp");
+  std::string val = builtin_string_variable ("ignore_function_time_stamp");
 
   if (! val.empty ())
     {
       if (val.compare ("all", 0, 3) == 0)
 	pref = 2;
       if (val.compare ("system", 0, 6) == 0)
 	pref = 1;
     }
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -38,79 +38,79 @@ class string_vector;
 #include <string>
 
 #include "ov.h"
 #include "ov-builtin.h"
 #include "symtab.h"
 
 extern void initialize_symbol_tables (void);
 
-extern bool is_builtin_variable (const string&);
-extern bool is_text_function_name (const string&);
-extern bool is_mapper_function_name (const string&);
-extern bool is_builtin_function_name (const string&);
-extern bool is_globally_visible (const string&);
+extern bool is_builtin_variable (const std::string&);
+extern bool is_text_function_name (const std::string&);
+extern bool is_mapper_function_name (const std::string&);
+extern bool is_builtin_function_name (const std::string&);
+extern bool is_globally_visible (const std::string&);
 
 extern octave_function *
-is_valid_function (const octave_value&, const string& = string (),
+is_valid_function (const octave_value&, const std::string& = std::string (),
 		   bool warn = false); 
 
 extern octave_function *
-is_valid_function (const string&, const string& = string (),
+is_valid_function (const std::string&, const std::string& = std::string (),
 		   bool warn = false); 
 
 extern octave_function *
-extract_function (const octave_value& arg, const string& warn_for,
-		  const string& fname, const string& header,
-		  const string& trailer);
+extract_function (const octave_value& arg, const std::string& warn_for,
+		  const std::string& fname, const std::string& header,
+		  const std::string& trailer);
 
 extern string_vector
-get_struct_elts (const string& text);
+get_struct_elts (const std::string& text);
 
 extern string_vector
-generate_struct_completions (const string& text, string& prefix,
-			     string& hint);
+generate_struct_completions (const std::string& text, std::string& prefix,
+			     std::string& hint);
 
 extern bool
-looks_like_struct (const string& text);
+looks_like_struct (const std::string& text);
 
 extern bool lookup (symbol_record *s, bool exec_script = true);
 
 extern symbol_record *
-lookup_by_name (const string& nm, bool exec_script = true);
+lookup_by_name (const std::string& nm, bool exec_script = true);
 
-extern octave_value get_global_value (const string& nm);
+extern octave_value get_global_value (const std::string& nm);
 
-extern void set_global_value (const string& nm, const octave_value& val);
+extern void set_global_value (const std::string& nm, const octave_value& val);
 
-extern string builtin_string_variable (const string&);
-extern int builtin_real_scalar_variable (const string&, double&);
-extern octave_value builtin_any_variable (const string&);
+extern std::string builtin_string_variable (const std::string&);
+extern int builtin_real_scalar_variable (const std::string&, double&);
+extern octave_value builtin_any_variable (const std::string&);
 
 extern void link_to_global_variable (symbol_record *sr);
 extern void link_to_builtin_or_function (symbol_record *sr);
 
-extern void force_link_to_function (const string&);
+extern void force_link_to_function (const std::string&);
 
 extern void bind_ans (const octave_value& val, bool print);
 
 extern void bind_global_error_variable (void);
 
 extern void clear_global_error_variable (void *);
 
 extern void
-bind_builtin_constant (const string&, const octave_value&,
+bind_builtin_constant (const std::string&, const octave_value&,
 		       bool protect = false, bool eternal = false,
-		       const string& help = string ());
+		       const std::string& help = std::string ());
 
 extern void
-bind_builtin_variable (const string&, const octave_value&,
+bind_builtin_variable (const std::string&, const octave_value&,
 		       bool protect = false, bool eternal = false,
 		       symbol_record::change_function f = 0,
-		       const string& help = string ());
+		       const std::string& help = std::string ());
 
 // Symbol table for symbols at the top level.
 extern symbol_table *top_level_sym_tab;
 
 // Symbol table for the current scope.
 extern symbol_table *curr_sym_tab;
 
 // Symbol table for global symbols.
