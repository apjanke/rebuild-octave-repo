# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1248884127 14400
#      Wed Jul 29 12:15:27 2009 -0400
# Node ID c6edba80dfaed85cd1e4db5e6dbdacd7aee0c78a
# Parent  5af462716bff3985df25e3ab11c43d03346800f5
sanity checks for loading sparse matrices

diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -3641,17 +3641,17 @@ operator >> (std::istream& is, ComplexMa
   octave_idx_type nc = a.cols ();
 
   if (nr > 0 && nc > 0)
     {
       Complex tmp;
       for (octave_idx_type i = 0; i < nr; i++)
 	for (octave_idx_type j = 0; j < nc; j++)
 	  {
-	    tmp = octave_read_complex (is);
+	    tmp = octave_read_value<Complex> (is);
 	    if (is)
 	      a.elem (i, j) = tmp;
 	    else
 	      goto done;
 	  }
     }
 
 done:
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -916,17 +916,17 @@ operator >> (std::istream& is, ComplexND
 {
   octave_idx_type nel = a.nelem ();
 
   if (nel > 0)
     {
       Complex tmp;
       for (octave_idx_type i = 0; i < nel; i++)
 	  {
-	    tmp = octave_read_complex (is);
+	    tmp = octave_read_value<Complex> (is);
 	    if (is)
 	      a.elem (i) = tmp;
 	    else
 	      goto done;
 	  }
     }
 
  done:
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -7461,58 +7461,19 @@ operator << (std::ostream& os, const Spa
    }
 
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, SparseComplexMatrix& a)
 {
-  octave_idx_type nr = a.rows ();
-  octave_idx_type nc = a.cols ();
-  octave_idx_type nz = a.nzmax ();
-
-  if (nr > 0 && nc > 0)
-    {
-      octave_idx_type itmp, jtmp, jold = 0;
-      Complex tmp;
-      octave_idx_type ii = 0;
-       
-      a.cidx (0) = 0;
-      for (octave_idx_type i = 0; i < nz; i++)
-	{
-	  is >> itmp;
-	  itmp--;
-	  is >> jtmp;
-	  jtmp--;
-	  tmp = octave_read_complex (is);
-
-	  if (is)
-	    {
-	      if (jold != jtmp)
-		{
-		  for (octave_idx_type j = jold; j < jtmp; j++)
-		    a.cidx(j+1) = ii;
-		  
-		  jold = jtmp;
-		}
-	      a.data (ii) = tmp;
-	      a.ridx (ii++) = itmp;
-	    }
-	  else
-	    goto done;
-	}
-
-      for (octave_idx_type j = jold; j < nc; j++)
-	a.cidx(j+1) = ii;
-    }
-
- done:
-
-  return is;
+  typedef SparseComplexMatrix::element_type elt_type;
+
+  return read_sparse_matrix<elt_type> (is, a, octave_read_value<Complex>);
 }
 
 SparseComplexMatrix
 operator * (const SparseComplexMatrix& m, const SparseMatrix& a)
 {
   SPARSE_SPARSE_MUL (SparseComplexMatrix, Complex, double);
 }
 
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,32 @@
+2009-07-29  John W. Eaton  <jwe@octave.org>
+
+	* fMatrix.cc (operator >>): Use template function to read value.
+	* fNDArray.cc (operator >>): Likeise.
+	* fCMatrix.cc (operator >>): Use template function to read value.
+	* fCNDArray.cc (operator >>): Likeise.
+	* dMatrix.cc (operator >>): Use template function to read value.
+	* dNDArray.cc (operator >>): Likeise.
+	* CMatrix.cc (operator >>): Use template function to read value.
+	* CNDArray.cc (operator >>): Likeise.
+
+	* lo-utils.cc, lo-utils.h (octave_read_value): New template
+	(octave_read_value<double>, octave_read_value<Complex>):
+	Provide specializations.
+	(octave_read_double, octave_read_complex, octave_read_float,
+	octave_rread_float_complex): Define in terms of template functions.
+	* Sparse.h (read_sparse_matrix): New template function.
+	* dSparse.cc (operator >>): Call read_sparse_matrix.
+	* CSparse.cc (operator >>): Likewise.
+	* boolSparse.cc (operator >>): Likewise.
+	* sparse-util.cc, sparse-util.h (sparse_indices_ok): New function.
+	* Sparse.cc (Sparse<T>::indices_ok, Sparse<T>::SparseRep::indices_ok):
+	New member functions.
+
 2009-07-20  John W. Eaton  <jwe@octave.org>
 
 	* lo-ieee.cc (octave_ieee_init) [__NetBSD__]: Call nan to
 	initialize Octave_NaN and nanf, to initialize Octave_Float_NaN.
 
 2009-07-11  John W. Eaton  <jwe@octave.org>
 
 	* file-ops.cc (file_ops::symlink, file_ops::readlink):
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -38,16 +38,17 @@ along with Octave; see the file COPYING.
 #include "Range.h"
 #include "idx-vector.h"
 #include "lo-error.h"
 #include "quit.h"
 #include "oct-locbuf.h"
 
 #include "Sparse.h"
 #include "sparse-sort.h"
+#include "sparse-util.h"
 #include "oct-spparms.h"
 
 template <class T>
 T&
 Sparse<T>::SparseRep::elem (octave_idx_type _r, octave_idx_type _c)
 {
   octave_idx_type i;
 
@@ -194,16 +195,23 @@ Sparse<T>::SparseRep::change_length (oct
 	  if (c[i] > nz)
 	    c[i] = nz;
 
       nzmx = nz;
     }
 }
 
 template <class T>
+bool
+Sparse<T>::SparseRep::indices_ok (void) const
+{
+  return sparse_indices_ok (r, c, nrows, ncols, nnz ());
+}
+
+template <class T>
 template <class U>
 Sparse<T>::Sparse (const Sparse<U>& a)
   : dimensions (a.dimensions), idx (0), idx_count (0)
 {
   if (a.nnz () == 0)
     rep = new typename Sparse<T>::SparseRep (rows (), cols());
   else
     {
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -28,16 +28,17 @@ along with Octave; see the file COPYING.
 #include <cassert>
 #include <cstddef>
 
 #include <iosfwd>
 
 #include "Array.h"
 #include "Array2.h"
 #include "dim-vector.h"
+#include "lo-error.h"
 #include "lo-utils.h"
 
 #include "oct-sort.h"
 
 class idx_vector;
 
 // Two dimensional sparse class.  Handles the reference counting for
 // all the derived classes.
@@ -126,16 +127,18 @@ protected:
     octave_idx_type& cidx (octave_idx_type i) { return c[i]; }
 
     octave_idx_type ccidx (octave_idx_type i) const { return c[i]; }
 
     void maybe_compress (bool remove_zeros);
 
     void change_length (octave_idx_type nz);
 
+    bool indices_ok (void) const;
+
   private:
 
     // No assignment!
 
     SparseRep& operator = (const SparseRep& a);
   };
 
   //--------------------------------------------------------------------
@@ -560,30 +563,124 @@ public:
 	    result.cidx (j+1) = ii;
 	  }
 
 	result.maybe_compress (false);
       }
 
     return result;
   }
+
+  bool indices_ok (void) const { return rep->indices_ok (); }
 };
 
 // NOTE: these functions should be friends of the Sparse<T> class and
 // Sparse<T>::dimensions should be protected, not public, but we can't
 // do that because of bugs in gcc prior to 3.3.
 
 template <class LT, class RT>
 /* friend */ int
 assign (Sparse<LT>& lhs, const Sparse<RT>& rhs);
 
 template <class LT, class RT>
 /* friend */ int
 assign1 (Sparse<LT>& lhs, const Sparse<RT>& rhs);
 
+template<typename T>
+std::istream&
+read_sparse_matrix (std::istream& is, Sparse<T>& a,
+		    T (*read_fcn) (std::istream&))
+{
+  octave_idx_type nr = a.rows ();
+  octave_idx_type nc = a.cols ();
+  octave_idx_type nz = a.nzmax ();
+
+  if (nr > 0 && nc > 0)
+    {
+      octave_idx_type itmp;
+      octave_idx_type jtmp;
+      octave_idx_type iold = 0;
+      octave_idx_type jold = 0;
+      octave_idx_type ii = 0;
+      T tmp;
+       
+      a.cidx (0) = 0;
+      for (octave_idx_type i = 0; i < nz; i++)
+	{
+	  is >> itmp;
+	  itmp--;
+
+	  if (itmp < iold)
+	    {
+	      (*current_liboctave_error_handler)
+		("invalid sparse matrix: row indices must appear in ascending order in each column");
+	      is.setstate (std::ios::failbit);
+	      goto done;
+	    }
+
+	  if (itmp < 0 || itmp >= nr)
+	    {
+	      (*current_liboctave_error_handler)
+		("invalid sparse matrix: row index = %d out of range",
+		 itmp + 1);
+	      is.setstate (std::ios::failbit);
+	      goto done;
+	    }
+
+
+	  iold = itmp;
+
+	  is >> jtmp;
+	  jtmp--;
+
+	  if (jtmp < jold)
+	    {
+	      (*current_liboctave_error_handler)
+		("invalid sparse matrix: column indices must appear in ascending order");
+	      is.setstate (std::ios::failbit);
+	      goto done;
+	    }
+
+	  if (jtmp < 0 || jtmp >= nc)
+	    {
+	      (*current_liboctave_error_handler)
+		("invalid sparse matrix: column index = %d out of range",
+		 jtmp + 1);
+	      is.setstate (std::ios::failbit);
+	      goto done;
+	    }
+
+	  tmp = read_fcn (is);
+	  
+	  if (is)
+	    {
+	      if (jold != jtmp)
+		{
+		  for (octave_idx_type j = jold; j < jtmp; j++)
+		    a.cidx(j+1) = ii;
+		  
+		  jold = jtmp;
+		  iold = 0;
+		}
+	      a.data (ii) = tmp;
+	      a.ridx (ii++) = itmp;
+	    }
+	  else
+	    goto done;
+	}
+
+      for (octave_idx_type j = jold; j < nc; j++)
+	a.cidx(j+1) = ii;
+    }
+  
+ done:
+
+  return is;
+}
+
 #define INSTANTIATE_SPARSE_ASSIGN(LT, RT, API) \
   template API int assign (Sparse<LT>&, const Sparse<RT>&); \
   template API int assign1 (Sparse<LT>&, const Sparse<RT>&);
 
 #define INSTANTIATE_SPARSE(T, API) \
   template class API Sparse<T>;
 
 #define INSTANTIATE_SPARSE_AND_ASSIGN(T, API) \
diff --git a/liboctave/boolSparse.cc b/liboctave/boolSparse.cc
--- a/liboctave/boolSparse.cc
+++ b/liboctave/boolSparse.cc
@@ -175,57 +175,19 @@ operator << (std::ostream& os, const Spa
      }
    
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, SparseBoolMatrix& a)
 {
-  octave_idx_type nr = a.rows ();
-  octave_idx_type nc = a.cols ();
-  octave_idx_type nz = a.nzmax ();
+  typedef SparseBoolMatrix::element_type elt_type;
 
-  if (nr > 0 && nc > 0)
-    {
-      octave_idx_type itmp, jtmp, jold = 0;
-      bool tmp;
-      octave_idx_type ii = 0;
-       
-      a.cidx (0) = 0;
-      for (octave_idx_type i = 0; i < nz; i++)
-	{
-	  is >> itmp;
-	  itmp--;
-	  is >> jtmp;
-	  jtmp--;
-	  is >> tmp;
-	  if (is)
-	    {
-	      if (jold != jtmp)
-		{
-		  for (octave_idx_type j = jold; j < jtmp; j++)
-		    a.cidx(j+1) = ii;
-		  
-		  jold = jtmp;
-		}
-	      a.data (ii) = tmp;
-	      a.ridx (ii++) = itmp;
-	    }
-	  else
-	    goto done;
-	}
-
-      for (octave_idx_type j = jold; j < nc; j++)
-	a.cidx(j+1) = ii;
-    }
-
- done:
-
-  return is;
+  return read_sparse_matrix<elt_type> (is, a, octave_read_value<bool>);
 }
 
 SparseBoolMatrix
 SparseBoolMatrix::squeeze (void) const 
 { 
   return Sparse<bool>::squeeze (); 
 }
 
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -3059,17 +3059,17 @@ operator >> (std::istream& is, Matrix& a
   octave_idx_type nc = a.cols ();
 
   if (nr > 0 && nc > 0)
     {
       double tmp;
       for (octave_idx_type i = 0; i < nr; i++)
 	for (octave_idx_type j = 0; j < nc; j++)
 	  {
-	    tmp = octave_read_double (is);
+	    tmp = octave_read_value<double> (is);
 	    if (is)
 	      a.elem (i, j) = tmp;
 	    else
 	      goto done;
 	  }
     }
 
  done:
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -965,17 +965,17 @@ operator >> (std::istream& is, NDArray& 
 {
   octave_idx_type nel = a.nelem ();
 
   if (nel > 0)
     {
       double tmp;
       for (octave_idx_type i = 0; i < nel; i++)
 	  {
-	    tmp = octave_read_double (is);
+	    tmp = octave_read_value<double> (is);
 	    if (is)
 	      a.elem (i) = tmp;
 	    else
 	      goto done;
 	  }
     }
 
  done:
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -7579,58 +7579,19 @@ operator << (std::ostream& os, const Spa
    }
 
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, SparseMatrix& a)
 {
-  octave_idx_type nr = a.rows ();
-  octave_idx_type nc = a.cols ();
-  octave_idx_type nz = a.nzmax ();
-
-  if (nr > 0 && nc > 0)
-    {
-      octave_idx_type itmp, jtmp, jold = 0;
-      double tmp;
-      octave_idx_type ii = 0;
-       
-      a.cidx (0) = 0;
-      for (octave_idx_type i = 0; i < nz; i++)
-	{
-	  is >> itmp;
-	  itmp--;
-	  is >> jtmp;
-	  jtmp--;
-	  tmp = octave_read_double (is);
-	  
-	  if (is)
-	    {
-	      if (jold != jtmp)
-		{
-		  for (octave_idx_type j = jold; j < jtmp; j++)
-		    a.cidx(j+1) = ii;
-		  
-		  jold = jtmp;
-		}
-	      a.data (ii) = tmp;
-	      a.ridx (ii++) = itmp;
-	    }
-	  else
-	    goto done;
-	}
-
-      for (octave_idx_type j = jold; j < nc; j++)
-	a.cidx(j+1) = ii;
-    }
-  
- done:
-
-  return is;
+  typedef SparseMatrix::element_type elt_type;
+
+  return read_sparse_matrix<elt_type> (is, a, octave_read_value<double>);
 }
 
 SparseMatrix
 SparseMatrix::squeeze (void) const 
 { 
   return MSparse<double>::squeeze (); 
 }
 
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -3634,17 +3634,17 @@ operator >> (std::istream& is, FloatComp
   octave_idx_type nc = a.cols ();
 
   if (nr > 0 && nc > 0)
     {
       FloatComplex tmp;
       for (octave_idx_type i = 0; i < nr; i++)
 	for (octave_idx_type j = 0; j < nc; j++)
 	  {
-	    tmp = octave_read_complex (is);
+	    tmp = octave_read_value<FloatComplex> (is);
 	    if (is)
 	      a.elem (i, j) = tmp;
 	    else
 	      goto done;
 	  }
     }
 
 done:
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -911,17 +911,17 @@ operator >> (std::istream& is, FloatComp
 {
   octave_idx_type nel = a.nelem ();
 
   if (nel > 0)
     {
       FloatComplex tmp;
       for (octave_idx_type i = 0; i < nel; i++)
 	  {
-	    tmp = octave_read_complex (is);
+	    tmp = octave_read_value<FloatComplex> (is);
 	    if (is)
 	      a.elem (i) = tmp;
 	    else
 	      goto done;
 	  }
     }
 
  done:
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -3058,17 +3058,17 @@ operator >> (std::istream& is, FloatMatr
   octave_idx_type nc = a.cols ();
 
   if (nr > 0 && nc > 0)
     {
       float tmp;
       for (octave_idx_type i = 0; i < nr; i++)
 	for (octave_idx_type j = 0; j < nc; j++)
 	  {
-	    tmp = octave_read_float (is);
+	    tmp = octave_read_value<float> (is);
 	    if (is)
 	      a.elem (i, j) = tmp;
 	    else
 	      goto done;
 	  }
     }
 
  done:
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -920,17 +920,17 @@ operator >> (std::istream& is, FloatNDAr
 {
   octave_idx_type nel = a.nelem ();
 
   if (nel > 0)
     {
       float tmp;
       for (octave_idx_type i = 0; i < nel; i++)
 	  {
-	    tmp = octave_read_float (is);
+	    tmp = octave_read_value<float> (is);
 	    if (is)
 	      a.elem (i) = tmp;
 	    else
 	      goto done;
 	  }
     }
 
  done:
diff --git a/liboctave/lo-utils.cc b/liboctave/lo-utils.cc
--- a/liboctave/lo-utils.cc
+++ b/liboctave/lo-utils.cc
@@ -285,18 +285,19 @@ read_inf_nan_na (std::istream& is, char 
 
     default:
       abort ();
     }
 
   return d;
 }
 
+template <>
 double
-octave_read_double (std::istream& is)
+octave_read_value (std::istream& is)
 {
   double d = 0.0;
 
   char c1 = ' ';
 
   while (isspace (c1))
     c1 = is.get ();
 
@@ -340,102 +341,59 @@ octave_read_double (std::istream& is)
     default:
       is.putback (c1);
       is >> d;
     }
 
   return d;
 }
 
+template <>
 Complex
-octave_read_complex (std::istream& is)
+octave_read_value (std::istream& is)
 {
   double re = 0.0, im = 0.0;
 
   Complex cx = 0.0;
 
   char ch = ' ';
 
   while (isspace (ch))
     ch = is.get ();
 
   if (ch == '(')
     {
-      re = octave_read_double (is);
+      re = octave_read_value<double> (is);
       ch = is.get ();
 
       if (ch == ',')
 	{
-	  im = octave_read_double (is);
+	  im = octave_read_value<double> (is);
 	  ch = is.get ();
 
 	  if (ch == ')')
 	    cx = Complex (re, im);
 	  else
 	    is.setstate (std::ios::failbit);
 	}
       else if (ch == ')')
 	cx = re;
       else
 	is.setstate (std::ios::failbit);
     }
   else
     {
       is.putback (ch);
-      cx = octave_read_double (is);
+      cx = octave_read_value<double> (is);
     }
 
   return cx;
 
 }
 
-void
-octave_write_double (std::ostream& os, double d)
-{
-  if (lo_ieee_is_NA (d))
-    os << "NA";
-  else if (lo_ieee_isnan (d))
-    os << "NaN";
-  else if (lo_ieee_isinf (d))
-    os << (d < 0 ? "-Inf" : "Inf");
-  else
-    os << d;
-}
-
-void
-octave_write_complex (std::ostream& os, const Complex& c)
-{
-  os << "(";
-  octave_write_double (os, real (c));
-  os << ",";
-  octave_write_double (os, imag (c));
-  os << ")";
-}
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
 static inline float
 read_float_inf_nan_na (std::istream& is, char c, char sign = '+')
 {
   float d = 0.0;
 
   switch (c)
     {
     case 'i': case 'I':
@@ -475,18 +433,19 @@ read_float_inf_nan_na (std::istream& is,
 
     default:
       abort ();
     }
 
   return d;
 }
 
+template <>
 float
-octave_read_float (std::istream& is)
+octave_read_value (std::istream& is)
 {
   float d = 0.0;
 
   char c1 = ' ';
 
   while (isspace (c1))
     c1 = is.get ();
 
@@ -530,59 +489,83 @@ octave_read_float (std::istream& is)
     default:
       is.putback (c1);
       is >> d;
     }
 
   return d;
 }
 
+template <>
 FloatComplex
-octave_read_float_complex (std::istream& is)
+octave_read_value (std::istream& is)
 {
   float re = 0.0, im = 0.0;
 
   FloatComplex cx = 0.0;
 
   char ch = ' ';
 
   while (isspace (ch))
     ch = is.get ();
 
   if (ch == '(')
     {
-      re = octave_read_float (is);
+      re = octave_read_value<float> (is);
       ch = is.get ();
 
       if (ch == ',')
 	{
-	  im = octave_read_float (is);
+	  im = octave_read_value<float> (is);
 	  ch = is.get ();
 
 	  if (ch == ')')
 	    cx = FloatComplex (re, im);
 	  else
 	    is.setstate (std::ios::failbit);
 	}
       else if (ch == ')')
 	cx = re;
       else
 	is.setstate (std::ios::failbit);
     }
   else
     {
       is.putback (ch);
-      cx = octave_read_float (is);
+      cx = octave_read_value<float> (is);
     }
 
   return cx;
 
 }
 
 void
+octave_write_double (std::ostream& os, double d)
+{
+  if (lo_ieee_is_NA (d))
+    os << "NA";
+  else if (lo_ieee_isnan (d))
+    os << "NaN";
+  else if (lo_ieee_isinf (d))
+    os << (d < 0 ? "-Inf" : "Inf");
+  else
+    os << d;
+}
+
+void
+octave_write_complex (std::ostream& os, const Complex& c)
+{
+  os << "(";
+  octave_write_double (os, real (c));
+  os << ",";
+  octave_write_double (os, imag (c));
+  os << ")";
+}
+
+void
 octave_write_float (std::ostream& os, float d)
 {
   if (lo_ieee_is_NA (d))
     os << "NA";
   else if (lo_ieee_isnan (d))
     os << "NaN";
   else if (lo_ieee_isinf (d))
     os << (d < 0 ? "-Inf" : "Inf");
diff --git a/liboctave/lo-utils.h b/liboctave/lo-utils.h
--- a/liboctave/lo-utils.h
+++ b/liboctave/lo-utils.h
@@ -21,17 +21,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #if !defined (octave_liboctave_utils_h)
 #define octave_liboctave_utils_h 1
 
 #include <cstdio>
 
-#include <iosfwd>
+#include <iostream>
 #include <string>
 
 #include "oct-cmplx.h"
 #include "oct-types.h"
 #include "syswait.h"
 
 extern OCTAVE_API octave_idx_type NINTbig (double x);
 extern OCTAVE_API octave_idx_type NINTbig (float x);
@@ -57,25 +57,58 @@ extern "C" OCTAVE_API void octave_qsort 
 
 extern "C" OCTAVE_API char *oct_strptime (const char *buf, const char *format,
 			       struct tm *tm);
 
 extern "C" OCTINTERP_API int octave_strcasecmp (const char *s1, const char *s2);
 
 extern "C" OCTINTERP_API int octave_strncasecmp (const char *s1, const char *s2, size_t n);
 
-extern OCTAVE_API double octave_read_double (std::istream& is);
-extern OCTAVE_API Complex octave_read_complex (std::istream& is);
+template <typename T>
+T
+octave_read_value (std::istream& is)
+{
+  T retval;
+  is >> retval;
+  return retval;
+}
+
+template <> OCTAVE_API double octave_read_value (std::istream& is);
+template <> OCTAVE_API Complex octave_read_value (std::istream& is);
+template <> OCTAVE_API float octave_read_value (std::istream& is);
+template <> OCTAVE_API FloatComplex octave_read_value (std::istream& is);
+
+// The next four functions are provided for backward compatibility.
+inline double
+octave_read_double (std::istream& is)
+{
+  return octave_read_value<double> (is);
+}
+
+inline Complex
+octave_read_complex (std::istream& is)
+{
+  return octave_read_value<Complex> (is);
+}
+
+inline float
+octave_read_float (std::istream& is)
+{
+  return octave_read_value<float> (is);
+}
+
+inline FloatComplex
+octave_read_float_complex (std::istream& is)
+{
+  return octave_read_value<FloatComplex> (is);
+}
 
 extern OCTAVE_API void octave_write_double (std::ostream& os, double dval);
 extern OCTAVE_API void octave_write_complex (std::ostream& os, const Complex& cval);
 
-extern OCTAVE_API float octave_read_float (std::istream& is);
-extern OCTAVE_API FloatComplex octave_read_float_complex (std::istream& is);
-
 extern OCTAVE_API void octave_write_float (std::ostream& os, float dval);
 extern OCTAVE_API void octave_write_float_complex (std::ostream& os, const FloatComplex& cval);
 
 #ifdef HAVE_LOADLIBRARY_API
 #include <windows.h>
 extern "C" OCTAVE_API void * octave_w32_library_search (HINSTANCE handle, const char *name);
 #undef min
 #undef max
diff --git a/liboctave/sparse-util.cc b/liboctave/sparse-util.cc
--- a/liboctave/sparse-util.cc
+++ b/liboctave/sparse-util.cc
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005, 2007, 2008 David Bateman
+Copyright (C) 2005, 2007, 2008, 2009 David Bateman
 Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -53,13 +53,73 @@ SparseCholPrint (const char *fmt, ...)
   va_start (args, fmt);
   int ret = vfprintf (stderr, fmt, args);
   fflush (stderr);
   va_end (args);
   return ret;
 }
 
 
+bool
+sparse_indices_ok (octave_idx_type *r, octave_idx_type *c,
+		   octave_idx_type nrows, octave_idx_type ncols,
+		   octave_idx_type nnz)
+{
+  if (nnz > 0)
+    {
+      if (c[0] != 0)
+	{
+	  (*current_liboctave_error_handler)
+	    ("invalid sparse matrix: cidx[0] must be zero");
+	  return false;
+	}
+
+      octave_idx_type jold = 0;
+
+      for (octave_idx_type j = 1; j < ncols+1; j++)
+	{
+	  if (c[j] < c[j-1])
+	    {
+	      (*current_liboctave_error_handler)
+		("invalid sparse matrix: cidx elements must appear in ascending order");
+	      return false;
+	    }
+
+	  if (c[j] > nnz)
+	    {
+	      (*current_liboctave_error_handler)
+		("invalid sparse matrix: cidx[%d] = %d exceeds number of nonzero elements", j, c[j]+1);
+	      return false;
+	    }
+
+	  if (c[j] != jold)
+	    {
+	      for (octave_idx_type i = jold+1; i < c[j]; i++)
+		{
+		  if (r[i] < r[i-1])
+		    {
+		      (*current_liboctave_error_handler)
+			("invalid sparse matrix: ridx elements must appear in ascending order for each column");
+		      return false;
+		    }
+
+		  if (r[i] >= nrows)
+		    {
+		      (*current_liboctave_error_handler)
+			("invalid sparse matrix: ridx[%d] = %d out of range",
+			 i, r[i]+1);
+		      return false;
+		    }
+		}
+
+	      jold = c[j];
+	    }
+	}
+    }
+
+  return true;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/sparse-util.h b/liboctave/sparse-util.h
--- a/liboctave/sparse-util.h
+++ b/liboctave/sparse-util.h
@@ -1,11 +1,11 @@
 /*
 
-Copyright (C) 2005, 2007, 2008 David Bateman
+Copyright (C) 2005, 2007, 2008, 2009 David Bateman
 Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005 Andy Adler
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
@@ -26,15 +26,20 @@ along with Octave; see the file COPYING.
 
 // FIXME this overload is here due to API change in SuiteSparse (3.1 -> 3.2)
 extern OCTAVE_API void SparseCholError (int status, char *file, 
                                         int line, char *message);
 extern OCTAVE_API void SparseCholError (int status, const char *file, 
                                         int line, const char *message);
 extern OCTAVE_API int SparseCholPrint (const char *fmt, ...);
 
+extern OCTAVE_API bool
+sparse_indices_ok (octave_idx_type *r, octave_idx_type *c,
+		   octave_idx_type nrows, octave_idx_type ncols,
+		   octave_idx_type nnz);
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,25 @@
+2009-07-29  John W. Eaton  <jwe@octave.org>
+
+	* ov-bool.cc (octave_bool::load_ascii): Call template function to
+	read value.
+	* ov-scalar.cc (octave_scalar::load_ascii): Likewise.
+	* ov-complex.cc (octave_complex::load_ascii): Likewise.
+	* ov-float.cc (octave_float_scalar::load_ascii): Likewise.
+	* ov-flt-complex.cc (octave_float_complex::load_ascii): Likewise.
+	* ls-mat-ascii.cc (read_mat_ascii_data): Likewise.
+
+	* ov-re-sparse.cc (octave_sparse_matrix::load_binary,
+	octave_sparse_matrix::load_hdf5): Perform sanity check on indices.
+	* ov-cx-sparse.cc (octave_sparse_complex_matrix::load_binary,
+	octave_sparse_complex_matrix::load_hdf5): Likewise.
+	* ov-bool-sparse.cc (octave_sparse_bool_matrix::load_binary,
+	octave_sparse_bool_matrix::load_hdf5): Likewise.
+
 2009-07-29  Jaroslav Hajek  <highegg@gmail.com>
 
 	* ov-fcn-handle.cc (octave_fcn_handle::do_multi_index_op):
 	Cache lookups also for classes.
 
 2009-07-28  Jaroslav Hajek  <highegg@gmail.com>
 
 	* DLD-FUNCTIONS/cellfun.cc (Fcellfun): Support auto-expanding scalar
diff --git a/src/ls-mat-ascii.cc b/src/ls-mat-ascii.cc
--- a/src/ls-mat-ascii.cc
+++ b/src/ls-mat-ascii.cc
@@ -251,17 +251,17 @@ read_mat_ascii_data (std::istream& is, c
 		  std::string buf = get_mat_data_input_line (is);
 
 		  std::istringstream tmp_stream (buf);
 
 		  for (octave_idx_type j = 0; j < nc; j++)
 		    {
 		      OCTAVE_QUIT;
 
-		      d = octave_read_double (tmp_stream);
+		      d = octave_read_value<double> (tmp_stream);
 
 		      if (tmp_stream || tmp_stream.eof ())
 			{
 			  tmp.elem (i, j) = d;
 			  total_count++;
 
 			  // Skip whitespace and commas.
 			  char c;
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -78,19 +78,19 @@ octave_sparse_bool_matrix::try_narrowing
       // since it involves a cast to double to avoid issues of overflow
       if (matrix.rows () == 1 && matrix.cols () == 1)
 	{
 	  // Const copy of the matrix, so the right version of () operator used
 	  const SparseBoolMatrix tmp (matrix);
 
 	  retval = new octave_bool (tmp (0));
 	}
-      else if (matrix.cols () > 0 && matrix.rows () > 0 && 
-	       double (matrix.byte_size ()) > double (matrix.rows ()) *
-	       double (matrix.cols ()) * sizeof (bool))
+      else if (matrix.cols () > 0 && matrix.rows () > 0
+	       && (double (matrix.byte_size ()) > double (matrix.rows ())
+		   * double (matrix.cols ()) * sizeof (bool)))
 	retval = new octave_bool_matrix (matrix.matrix_value ());
     }
 
   return retval;
 }
 
 double
 octave_sparse_bool_matrix::double_value (bool) const
@@ -266,17 +266,17 @@ octave_sparse_bool_matrix::load_binary (
   int32_t nz, nc, nr, tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
   if (tmp != -2) {
-    error("load: only 2D sparse matrices are supported");
+    error ("load: only 2D sparse matrices are supported");
     return false;
   }
 
   if (! is.read (reinterpret_cast<char *> (&nr), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nc), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nz), 4))
@@ -319,16 +319,19 @@ octave_sparse_bool_matrix::load_binary (
   OCTAVE_LOCAL_BUFFER (char, htmp, nz);
 
   if (! is.read (htmp, nz))
     return false;
 
   for (int i = 0; i < nz; i++)
     m.data(i) = (htmp[i] ? 1 : 0);
  
+  if (! m.indices_ok ())
+    return false;
+
   matrix = m;
 
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
@@ -600,18 +603,18 @@ octave_sparse_bool_matrix::load_hdf5 (hi
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
   OCTAVE_LOCAL_BUFFER (hsize_t, maxdims, rank);
 
   H5Sget_simple_extent_dims (space_hid, hdims, maxdims);
 
-  if (static_cast<int> (hdims[0]) != nc + 1 || 
-      static_cast<int> (hdims[1]) != 1)
+  if (static_cast<int> (hdims[0]) != nc + 1
+      || static_cast<int> (hdims[1]) != 1)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   octave_idx_type *itmp = m.xcidx ();
@@ -635,27 +638,28 @@ octave_sparse_bool_matrix::load_hdf5 (hi
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sget_simple_extent_dims (space_hid, hdims, maxdims);
 
-  if (static_cast<int> (hdims[0]) != nz || 
-      static_cast<int> (hdims[1]) != 1)
+  if (static_cast<int> (hdims[0]) != nz
+      || static_cast<int> (hdims[1]) != 1)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
-  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL, H5P_DEFAULT, itmp) < 0) 
+  if (H5Dread (data_hid, H5T_NATIVE_IDX, H5S_ALL, H5S_ALL,
+	       H5P_DEFAULT, itmp) < 0) 
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sclose (space_hid);
@@ -670,28 +674,30 @@ octave_sparse_bool_matrix::load_hdf5 (hi
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sget_simple_extent_dims (space_hid, hdims, maxdims);
 
-  if (static_cast<int> (hdims[0]) != nz || 
-      static_cast<int> (hdims[1]) != 1)
+  if (static_cast<int> (hdims[0]) != nz
+      || static_cast<int> (hdims[1]) != 1)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (hbool_t, htmp, nz);
   bool retval = false;
-  if (H5Dread (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL, H5P_DEFAULT, htmp) >= 0) 
+  if (H5Dread (data_hid, H5T_NATIVE_HBOOL, H5S_ALL, H5S_ALL,
+	       H5P_DEFAULT, htmp) >= 0
+      && m.indices_ok ())
     {
       retval = true;
 
       for (int i = 0; i < nz; i++)
 	m.xdata(i) = htmp[i];
 
       matrix = m;
     }
diff --git a/src/ov-bool.cc b/src/ov-bool.cc
--- a/src/ov-bool.cc
+++ b/src/ov-bool.cc
@@ -122,17 +122,17 @@ octave_bool::save_ascii (std::ostream& o
   os << "\n";
 
   return true;
 }
 
 bool 
 octave_bool::load_ascii (std::istream& is)
 {
-  scalar = (octave_read_double (is) != 0.);
+  scalar = (octave_read_value<double> (is) != 0.);
 
   if (!is)
     {
       error ("load: failed to load scalar constant");
       return false;
     }
 
   return true;
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -254,17 +254,17 @@ octave_complex::save_ascii (std::ostream
   os << "\n";
 
   return true;
 }
 
 bool 
 octave_complex::load_ascii (std::istream& is)
 {
-  scalar = octave_read_complex (is);
+  scalar = octave_read_value<Complex> (is);
 
   if (!is) 
     {
       error ("load: failed to load complex scalar constant");
       return false;
     }
 
   return true;
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -76,25 +76,25 @@ octave_sparse_complex_matrix::try_narrow
 	  if (std::imag (c) == 0.0)
 	    retval = new octave_scalar (std::real (c));
 	  else
 	    retval = new octave_complex (c);
 	}
       else if (nr == 0 || nc == 0)
 	retval = new octave_matrix (Matrix (nr, nc));
       else if (matrix.all_elements_are_real ())
-	if (matrix.cols () > 0 && matrix.rows () > 0 && 
-	    double (matrix.byte_size ()) > double (matrix.rows ()) *
-	    double (matrix.cols ()) * sizeof (double))
+	if (matrix.cols () > 0 && matrix.rows () > 0
+	    && (double (matrix.byte_size ()) > double (matrix.rows ())
+		* double (matrix.cols ()) * sizeof (double)))
 	  retval = new octave_matrix (::real (matrix.matrix_value ()));
 	else
 	  retval = new octave_sparse_matrix (::real (matrix));
-      else if (matrix.cols () > 0 && matrix.rows () > 0 && 
-	       double (matrix.byte_size ()) > double (matrix.rows ()) *
-	       double (matrix.cols ()) * sizeof (Complex))
+      else if (matrix.cols () > 0 && matrix.rows () > 0
+	       && (double (matrix.byte_size ()) > double (matrix.rows ())
+		   * double (matrix.cols ()) * sizeof (Complex)))
 	retval = new octave_complex_matrix (matrix.matrix_value ());
     }
   else
     {
       if (matrix.all_elements_are_real ())
 	retval = new octave_sparse_matrix (::real (matrix));
     }
     
@@ -307,17 +307,17 @@ octave_sparse_complex_matrix::load_binar
 
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
   if (tmp != -2) {
-    error("load: only 2D sparse matrices are supported");
+    error ("load: only 2D sparse matrices are supported");
     return false;
   }
 
   if (! is.read (reinterpret_cast<char *> (&nr), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nc), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nz), 4))
@@ -357,16 +357,20 @@ octave_sparse_complex_matrix::load_binar
   if (! is.read (reinterpret_cast<char *> (&ctmp), 1))
     return false;
   
   read_doubles (is, reinterpret_cast<double *> (m.data ()),
 		static_cast<save_type> (ctmp), 2 * nz, swap, fmt);
 
   if (error_state || ! is)
     return false;
+
+  if (! m.indices_ok ())
+    return false;
+
   matrix = m;
 
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
@@ -676,18 +680,18 @@ octave_sparse_complex_matrix::load_hdf5 
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
   OCTAVE_LOCAL_BUFFER (hsize_t, maxdims, rank);
 
   H5Sget_simple_extent_dims (space_hid, hdims, maxdims);
 
-  if (static_cast<int> (hdims[0]) != nc + 1 || 
-      static_cast<int> (hdims[1]) != 1)
+  if (static_cast<int> (hdims[0]) != nc + 1
+      || static_cast<int> (hdims[1]) != 1)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   octave_idx_type *itmp = m.xcidx ();
@@ -711,18 +715,18 @@ octave_sparse_complex_matrix::load_hdf5 
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sget_simple_extent_dims (space_hid, hdims, maxdims);
 
-  if (static_cast<int> (hdims[0]) != nz || 
-      static_cast<int> (hdims[1]) != 1)
+  if (static_cast<int> (hdims[0]) != nz
+      || static_cast<int> (hdims[1]) != 1)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   itmp = m.xridx ();
@@ -758,28 +762,30 @@ octave_sparse_complex_matrix::load_hdf5 
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   H5Sget_simple_extent_dims (space_hid, hdims, maxdims);
 
-  if (static_cast<int> (hdims[0]) != nz || 
-      static_cast<int> (hdims[1]) != 1)
+  if (static_cast<int> (hdims[0]) != nz
+      || static_cast<int> (hdims[1]) != 1)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   Complex *ctmp = m.xdata ();
   bool retval = false;
-  if (H5Dread (data_hid, complex_type, H5S_ALL, H5S_ALL, H5P_DEFAULT, ctmp) >= 0) 
+  if (H5Dread (data_hid, complex_type, H5S_ALL, H5S_ALL,
+	       H5P_DEFAULT, ctmp) >= 0
+      && m.indices_ok ())
     {
       retval = true;
       matrix = m;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_hid);
   H5Dclose (data_hid);
diff --git a/src/ov-float.cc b/src/ov-float.cc
--- a/src/ov-float.cc
+++ b/src/ov-float.cc
@@ -134,17 +134,17 @@ octave_float_scalar::save_ascii (std::os
   os << "\n";
 
   return true;
 }
 
 bool 
 octave_float_scalar::load_ascii (std::istream& is)
 {
-  scalar = octave_read_float (is);
+  scalar = octave_read_value<float> (is);
   if (!is)
     {
       error ("load: failed to load scalar constant");
       return false;
     }
 
   return true;
 }
diff --git a/src/ov-flt-complex.cc b/src/ov-flt-complex.cc
--- a/src/ov-flt-complex.cc
+++ b/src/ov-flt-complex.cc
@@ -239,17 +239,17 @@ octave_float_complex::save_ascii (std::o
   os << "\n";
 
   return true;
 }
 
 bool 
 octave_float_complex::load_ascii (std::istream& is)
 {
-  scalar = octave_read_float_complex (is);
+  scalar = octave_read_value<FloatComplex> (is);
 
   if (!is) 
     {
       error ("load: failed to load complex scalar constant");
       return false;
     }
 
   return true;
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -78,19 +78,19 @@ octave_sparse_matrix::try_narrowing_conv
       // since it involves a cast to double to avoid issues of overflow
       if (matrix.rows () == 1 && matrix.cols () == 1)
 	{
 	  // Const copy of the matrix, so the right version of () operator used
 	  const SparseMatrix tmp (matrix);
 
 	  retval = new octave_scalar (tmp (0));
 	}
-      else if (matrix.cols () > 0 && matrix.rows () > 0 && 
-	       double (matrix.byte_size ()) > double (matrix.rows ()) *
-	       double (matrix.cols ()) * sizeof (double))
+      else if (matrix.cols () > 0 && matrix.rows () > 0
+	       && (double (matrix.byte_size ()) > double (matrix.rows ())
+		   * double (matrix.cols ()) * sizeof (double)))
 	retval = new octave_matrix (matrix.matrix_value ());
     }
 
   return retval;
 }
 
 double
 octave_sparse_matrix::double_value (bool) const
@@ -321,17 +321,17 @@ octave_sparse_matrix::load_binary (std::
 
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
   if (tmp != -2) {
-    error("load: only 2D sparse matrices are supported");
+    error ("load: only 2D sparse matrices are supported");
     return false;
   }
 
   if (! is.read (reinterpret_cast<char *> (&nr), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nc), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nz), 4))
@@ -370,16 +370,20 @@ octave_sparse_matrix::load_binary (std::
 
   if (! is.read (reinterpret_cast<char *> (&ctmp), 1))
     return false;
   
   read_doubles (is, m.xdata (), static_cast<save_type> (ctmp), nz, swap, fmt);
 
   if (error_state || ! is)
     return false;
+
+  if (! m.indices_ok ())
+    return false;
+
   matrix = m;
 
   return true;
 }
 
 #if defined (HAVE_HDF5)
 
 bool
@@ -677,18 +681,18 @@ octave_sparse_matrix::load_hdf5 (hid_t l
       return false;
     }
 
   OCTAVE_LOCAL_BUFFER (hsize_t, hdims, rank);
   OCTAVE_LOCAL_BUFFER (hsize_t, maxdims, rank);
 
   H5Sget_simple_extent_dims (space_hid, hdims, maxdims);
 
-  if (static_cast<int> (hdims[0]) != nc + 1 || 
-      static_cast<int> (hdims[1]) != 1)
+  if (static_cast<int> (hdims[0]) != nc + 1
+      || static_cast<int> (hdims[1]) != 1)
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   octave_idx_type *itmp = m.xcidx ();
@@ -757,32 +761,30 @@ octave_sparse_matrix::load_hdf5 (hid_t l
     {
       H5Sclose (space_hid);
       H5Dclose (data_hid);
       H5Gclose (group_hid);
       return false;
     }
 
   double *dtmp = m.xdata ();
+  bool retval = false;
   if (H5Dread (data_hid, H5T_NATIVE_DOUBLE, H5S_ALL, H5S_ALL, 
-	       H5P_DEFAULT, dtmp) < 0) 
+	       H5P_DEFAULT, dtmp) >= 0
+      && m.indices_ok ())
     {
-      H5Sclose (space_hid);
-      H5Dclose (data_hid);
-      H5Gclose (group_hid);
-      return false;
+      retval = true;
+      matrix = m;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
   H5Gclose (group_hid);
 
-  matrix = m;
-
-  return true;
+  return retval;
 }
 
 #endif
 
 mxArray *
 octave_sparse_matrix::as_mxArray (void) const
 {
   mwSize nz = nzmax();
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -149,17 +149,17 @@ octave_scalar::save_ascii (std::ostream&
   os << "\n";
 
   return true;
 }
 
 bool 
 octave_scalar::load_ascii (std::istream& is)
 {
-  scalar = octave_read_double (is);
+  scalar = octave_read_value<double> (is);
   if (!is)
     {
       error ("load: failed to load scalar constant");
       return false;
     }
 
   return true;
 }
