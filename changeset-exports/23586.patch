# HG changeset patch
# User Rik <rik@octave.org>
# Date 1497374455 25200
#      Tue Jun 13 10:20:55 2017 -0700
# Node ID f6c5db0a02e732ddee2b554f980ed4abad7478b8
# Parent  570170b6eb098b3fa9c69d356965990189b1e0a7
maint: Deprecate is_numeric_type and replace with isnumeric.

* ov.h (is_numeric_type): Use OCTAVE_DEPRECATED macro around function.
* ov.h (isnumeric): New function.

* make_int.cc, besselj.cc, cellfun.cc, data.cc, dot.cc, file-io.cc,
graphics.cc, load-path.cc, lookup.cc, lu.cc, mex.cc, mgorth.cc, oct-hist.cc,
pr-output.cc, schur.cc, sparse.cc, sqrtm.cc, sub2ind.cc, typecast.cc, utils.cc,
chol.cc, qr.cc, ov-base-diag.h, ov-base-mat.h, ov-base-scalar.h,
ov-base-sparse.h, ov-base.cc, ov-base.h, ov-bool-mat.cc, ov-bool-mat.h,
ov-bool-sparse.h, ov-bool.h, ov-cell.h, ov-class.cc, ov-fcn-inline.cc,
ov-lazy-idx.h, ov-perm.h, ov-range.h, ov-str-mat.h, ov-usr-fcn.cc, bp-table.cc:
Replace instances of is_numeric_type with isnumeric.

diff --git a/examples/code/make_int.cc b/examples/code/make_int.cc
--- a/examples/code/make_int.cc
+++ b/examples/code/make_int.cc
@@ -64,17 +64,17 @@ public:
   bool is_defined (void) const { return true; }
   bool is_real_scalar (void) const { return true; }
 
   octave_value all (void) const { return (double) (scalar != 0); }
   octave_value any (void) const { return (double) (scalar != 0); }
 
   bool is_real_type (void) const { return true; }
   bool is_scalar_type (void) const { return true; }
-  bool is_numeric_type (void) const { return true; }
+  bool isnumeric (void) const { return true; }
 
   bool valid_as_scalar_index (void) const
   { return scalar == 1; }
 
   bool valid_as_zero_index (void) const
   { return scalar == 0; }
 
   bool is_true (void) const { return (scalar != 0); }
diff --git a/libinterp/corefcn/besselj.cc b/libinterp/corefcn/besselj.cc
--- a/libinterp/corefcn/besselj.cc
+++ b/libinterp/corefcn/besselj.cc
@@ -91,17 +91,17 @@ do_bessel (enum bessel_type type, const 
   bool scaled = false;
   if (nargin == 3)
     {
       octave_value opt_arg = args(2);
       bool rpt_error = false;
 
       if (! opt_arg.is_scalar_type ())
         rpt_error = true;
-      else if (opt_arg.is_numeric_type ())
+      else if (opt_arg.isnumeric ())
         {
           double opt_val = opt_arg.double_value ();
           if (opt_val != 0.0 && opt_val != 1.0)
             rpt_error = true;
           scaled = (opt_val == 1.0);
         }
       else if (opt_arg.islogical ())
         scaled = opt_arg.bool_value ();
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -143,17 +143,17 @@ try_cellfun_internal_ops (const octave_v
       for (octave_idx_type count= 0; count < k; count++)
         result(count) = f_args.elem (count).islogical ();
       retval(0) = result;
     }
   else if (name == "isnumeric")
     {
       BNDA result (f_args.dims ());
       for (octave_idx_type count= 0; count < k; count++)
-        result(count) = f_args.elem (count).is_numeric_type ();
+        result(count) = f_args.elem (count).isnumeric ();
       retval(0) = result;
     }
   else if (name == "isreal")
     {
       BNDA result (f_args.dims ());
       for (octave_idx_type count= 0; count < k; count++)
         result(count) = f_args.elem (count).isreal ();
       retval(0) = result;
@@ -1781,17 +1781,17 @@ num2cell ([1,2;3,4],1)
   Array<int> dimv;
   if (nargin > 1)
     dimv = args(1).int_vector_value (true);
 
   if (array.islogical ())
     retval = do_num2cell (array.bool_array_value (), dimv);
   else if (array.is_char_matrix ())
     retval = do_num2cell (array.char_array_value (), dimv);
-  else if (array.is_numeric_type ())
+  else if (array.isnumeric ())
     {
       if (array.isinteger ())
         {
           if (array.is_int8_type ())
             retval = do_num2cell (array.int8_array_value (), dimv);
           else if (array.is_int16_type ())
             retval = do_num2cell (array.int16_array_value (), dimv);
           else if (array.is_int32_type ())
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -215,20 +215,20 @@ This function is equivalent to @code{arg
 @seealso{tan, tand, tanh, atanh}
 @end deftypefn */)
 {
   if (args.length () != 2)
     print_usage ();
 
   octave_value retval;
 
-  if (! args(0).is_numeric_type ())
+  if (! args(0).isnumeric ())
     err_wrong_type_arg ("atan2", args(0));
 
-  if (! args(1).is_numeric_type ())
+  if (! args(1).isnumeric ())
     err_wrong_type_arg ("atan2", args(1));
 
   if (args(0).iscomplex () || args(1).iscomplex ())
     error ("atan2: not defined for complex numbers");
 
   if (args(0).is_single_type () || args(1).is_single_type ())
     {
       if (args(0).is_scalar_type () && args(1).is_scalar_type ())
@@ -324,19 +324,19 @@ This function is equivalent to @code{arg
 
 static octave_value
 do_hypot (const octave_value& x, const octave_value& y)
 {
   octave_value retval;
 
   octave_value arg0 = x;
   octave_value arg1 = y;
-  if (! arg0.is_numeric_type ())
+  if (! arg0.isnumeric ())
     err_wrong_type_arg ("hypot", arg0);
-  if (! arg1.is_numeric_type ())
+  if (! arg1.isnumeric ())
     err_wrong_type_arg ("hypot", arg1);
 
   if (arg0.iscomplex ())
     arg0 = arg0.abs ();
   if (arg1.iscomplex ())
     arg1 = arg1.abs ();
 
   if (arg0.is_single_type () || arg1.is_single_type ())
@@ -597,20 +597,20 @@ periodic, @code{mod} is a better choice.
 @seealso{mod}
 @end deftypefn */)
 {
   if (args.length () != 2)
     print_usage ();
 
   octave_value retval;
 
-  if (! args(0).is_numeric_type ())
+  if (! args(0).isnumeric ())
     err_wrong_type_arg ("rem", args(0));
 
-  if (! args(1).is_numeric_type ())
+  if (! args(1).isnumeric ())
     err_wrong_type_arg ("rem", args(1));
 
   if (args(0).iscomplex () || args(1).iscomplex ())
     error ("rem: not defined for complex numbers");
 
   if (args(0).isinteger () || args(1).isinteger ())
     {
       builtin_type_t btyp0 = args(0).builtin_type ();
@@ -776,20 +776,20 @@ negative numbers or when the values are 
 @seealso{rem}
 @end deftypefn */)
 {
   if (args.length () != 2)
     print_usage ();
 
   octave_value retval;
 
-  if (! args(0).is_numeric_type ())
+  if (! args(0).isnumeric ())
     err_wrong_type_arg ("mod", args(0));
 
-  if (! args(1).is_numeric_type ())
+  if (! args(1).isnumeric ())
     err_wrong_type_arg ("mod", args(1));
 
   if (args(0).iscomplex () || args(1).iscomplex ())
     error ("mod: not defined for complex numbers");
 
   if (args(0).isinteger () || args(1).isinteger ())
     {
       builtin_type_t btyp0 = args(0).builtin_type ();
@@ -3566,17 +3566,17 @@ complex array.
 
 Logical and character arrays are not considered to be numeric.
 @seealso{isinteger, isfloat, isreal, iscomplex, islogical, ischar, iscell, isstruct, isa}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
-  return ovl (args(0).is_numeric_type ());
+  return ovl (args(0).isnumeric ());
 }
 
 /*
 %!assert (isnumeric (1), true)
 %!assert (isnumeric (1i), true)
 %!assert (isnumeric ([1,1]), true)
 %!assert (isnumeric (single (1)), true)
 %!assert (isnumeric (single (1i)), true)
@@ -5104,17 +5104,17 @@ if fewer than two values are requested.
 
   octave_idx_type npoints = 100;
   if (nargin == 3)
     {
       // Apparently undocumented Matlab.  If the third arg is an empty
       // numeric value, the number of points defaults to 1.
       octave_value arg_3 = args(2);
 
-      if (arg_3.is_numeric_type () && arg_3.isempty ())
+      if (arg_3.isnumeric () && arg_3.isempty ())
         npoints = 1;
       else if (! arg_3.is_scalar_type ())
         error ("linspace: N must be a scalar");
       else
         // Even if third arg is not an integer, it must be cast to int
         npoints = arg_3.idx_type_value ();
     }
 
@@ -6959,17 +6959,17 @@ DEFUN (__accumarray_sum__, args, ,
 Undocumented internal function.
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
-  if (! args(0).is_numeric_type ())
+  if (! args(0).isnumeric ())
     error ("__accumarray_sum__: first argument must be numeric");
 
   octave_value retval;
 
   try
     {
       idx_vector idx = args(0).index_vector ();
       octave_idx_type n = -1;
@@ -6989,17 +6989,17 @@ Undocumented internal function.
         {
           if (vals.iscomplex ())
             retval = do_accumarray_sum (idx,
                                         vals.float_complex_array_value (),
                                         n);
           else
             retval = do_accumarray_sum (idx, vals.float_array_value (), n);
         }
-      else if (vals.is_numeric_type () || vals.islogical ())
+      else if (vals.isnumeric () || vals.islogical ())
         {
           if (vals.iscomplex ())
             retval = do_accumarray_sum (idx,
                                         vals.complex_array_value (),
                                         n);
           else
             retval = do_accumarray_sum (idx, vals.array_value (), n);
         }
@@ -7048,17 +7048,17 @@ static octave_value_list
 do_accumarray_minmax_fun (const octave_value_list& args,
                           bool ismin)
 {
   int nargin = args.length ();
 
   if (nargin < 3 || nargin > 4)
     print_usage ();
 
-  if (! args(0).is_numeric_type ())
+  if (! args(0).isnumeric ())
     error ("accumarray: first argument must be numeric");
 
   octave_value retval;
 
   try
     {
       idx_vector idx = args(0).index_vector ();
       octave_idx_type n = -1;
@@ -7182,17 +7182,17 @@ DEFUN (__accumdim_sum__, args, ,
 Undocumented internal function.
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 4)
     print_usage ();
 
-  if (! args(0).is_numeric_type ())
+  if (! args(0).isnumeric ())
     error ("__accumdim_sum__: first argument must be numeric");
 
   octave_value retval;
 
   try
     {
       idx_vector idx = args(0).index_vector ();
       int dim = -1;
@@ -7210,17 +7210,17 @@ Undocumented internal function.
           if (vals.iscomplex ())
             retval = do_accumdim_sum (idx,
                                       vals.float_complex_array_value (),
                                       dim, n);
           else
             retval = do_accumdim_sum (idx, vals.float_array_value (),
                                       dim, n);
         }
-      else if (vals.is_numeric_type () || vals.islogical ())
+      else if (vals.isnumeric () || vals.islogical ())
         {
           if (vals.iscomplex ())
             retval = do_accumdim_sum (idx, vals.complex_array_value (),
                                       dim, n);
           else
             retval = do_accumdim_sum (idx, vals.array_value (), dim, n);
         }
       else
@@ -7326,17 +7326,17 @@ result(! mask) = fval(! mask);
 @var{mask} can also be arbitrary numeric type, in which case it is first
 converted to logical.
 @seealso{logical, diff}
 @end deftypefn */)
 {
   if (args.length () != 3)
     print_usage ();
 
-  if (! (args(0).islogical () || args(0).is_numeric_type ()))
+  if (! (args(0).islogical () || args(0).isnumeric ()))
     error ("merge: first argument must be logical or numeric");
 
   octave_value retval;
 
   octave_value mask_val = args(0);
 
   if (mask_val.is_scalar_type ())
     retval = (mask_val.is_true () ? args(1) : args(2));
@@ -7562,17 +7562,17 @@ an empty matrix is returned.
 @seealso{sort, merge}
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
     print_usage ();
 
-  if (! (args(0).is_numeric_type () || args(0).islogical ()))
+  if (! (args(0).isnumeric () || args(0).islogical ()))
     error ("diff: X must be numeric or logical");
 
   int dim = -1;
   octave_idx_type order = 1;
   if (nargin > 1)
     {
       if (args(1).is_scalar_type ())
         order = args(1).idx_type_value (true, false);
@@ -7730,17 +7730,17 @@ Encode a double matrix or array @var{x} 
 @var{s}.
 
 @seealso{base64_decode}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
-  if (! args(0).is_numeric_type ())
+  if (! args(0).isnumeric ())
     error ("base64_encode: encoding is supported only for numeric arrays");
 
   if (args(0).iscomplex () || args(0).issparse ())
     error ("base64_encode: encoding complex or sparse data is not supported");
 
   octave_value_list retval;
 
   if (args(0).isinteger ())
diff --git a/libinterp/corefcn/dot.cc b/libinterp/corefcn/dot.cc
--- a/libinterp/corefcn/dot.cc
+++ b/libinterp/corefcn/dot.cc
@@ -87,17 +87,17 @@ but avoids forming a temporary array and
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
   octave_value retval;
   octave_value argx = args(0);
   octave_value argy = args(1);
 
-  if (! argx.is_numeric_type () || ! argy.is_numeric_type ())
+  if (! argx.isnumeric () || ! argy.isnumeric ())
     error ("dot: X and Y must be numeric");
 
   dim_vector dimx = argx.dims ();
   dim_vector dimy = argy.dims ();
   bool match = dimx == dimy;
   if (! match && nargin == 2 && dimx.is_vector () && dimy.is_vector ())
     {
       // Change to column vectors.
@@ -249,17 +249,17 @@ endfor
   if (args.length () != 2)
     print_usage ();
 
   octave_value retval;
 
   octave_value argx = args(0);
   octave_value argy = args(1);
 
-  if (! argx.is_numeric_type () || ! argy.is_numeric_type ())
+  if (! argx.isnumeric () || ! argy.isnumeric ())
     error ("blkmm: A and B must be numeric");
 
   const dim_vector dimx = argx.dims ();
   const dim_vector dimy = argy.dims ();
   int nd = dimx.ndims ();
   F77_INT m = octave::to_f77_int (dimx(0));
   F77_INT k = octave::to_f77_int (dimx(1));
   F77_INT n = octave::to_f77_int (dimy(1));
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -1212,17 +1212,17 @@ textscan_internal (const std::string& wh
     }
   else
     error ("%s: FORMAT must be a string", who.c_str ());
 
   octave_idx_type ntimes = -1;
 
   if (args.length () > 2)
     {
-      if (args(2).is_numeric_type ())
+      if (args(2).isnumeric ())
         {
           ntimes = args(2).idx_type_value ();
 
           if (ntimes < args(2).double_value ())
             error ("%s: REPEAT = %g is too large",
                    who.c_str (), args(2).double_value ());
 
           nskip++;
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1333,17 +1333,17 @@ color_property::do_set (const octave_val
             }
           catch (octave::execution_exception& e)
             {
               error (e, "invalid value for color property \"%s\" (value = %s)",
                      get_name ().c_str (), s.c_str ());
             }
         }
     }
-  else if (val.is_numeric_type ())
+  else if (val.isnumeric ())
     {
       Matrix m = val.matrix_value ();
 
       if (m.numel () != 3)
         error ("invalid value for color property \"%s\"",
                get_name ().c_str ());
 
       color_values col (m(0), m(1), m(2));
@@ -1417,17 +1417,17 @@ array_property::validate (const octave_v
 
       // check if complex is allowed (it's also of class "double", so
       // checking that alone is not enough to ensure real type)
       if (type_constraints.find ("real") != type_constraints.end ()
           && v.iscomplex ())
         xok = false;
     }
   else
-    xok = v.is_numeric_type () || v.is_bool_scalar ();
+    xok = v.isnumeric () || v.is_bool_scalar ();
 
   if (xok)
     {
       if (size_constraints.size () == 0)
         return true;
 
       dim_vector vdims = v.dims ();
       int vlen = vdims.ndims ();
@@ -2868,17 +2868,17 @@ is_handle (double val)
 
 static octave_value
 is_handle (const octave_value& val)
 {
   octave_value retval = false;
 
   if (val.is_real_scalar () && is_handle (val.double_value ()))
     retval = true;
-  else if (val.is_numeric_type () && val.isreal ())
+  else if (val.isnumeric () && val.isreal ())
     {
       const NDArray handles = val.array_value ();
 
       boolNDArray result (handles.dims ());
 
       for (octave_idx_type i = 0; i < handles.numel (); i++)
         result.xelem (i) = is_handle (handles(i));
 
@@ -6609,17 +6609,17 @@ convert_ticklabel_string (const octave_v
     {
       // Always return a column vector for Matlab compatibility
       if (val.columns () > 1)
         retval = val.reshape (dim_vector (val.numel (), 1));
     }
   else
     {
       string_vector sv;
-      if (val.is_numeric_type ())
+      if (val.isnumeric ())
         {
           NDArray data = val.array_value ();
           std::ostringstream oss;
           oss.precision (5);
           for (octave_idx_type i = 0; i < val.numel (); i++)
             {
               oss.str ("");
               oss << data(i);
@@ -10164,17 +10164,17 @@ is_handle_visible (double val)
 
 static octave_value
 is_handle_visible (const octave_value& val)
 {
   octave_value retval = false;
 
   if (val.is_real_scalar () && is_handle_visible (val.double_value ()))
     retval = true;
-  else if (val.is_numeric_type () && val.isreal ())
+  else if (val.isnumeric () && val.isreal ())
     {
       const NDArray handles = val.array_value ();
 
       boolNDArray result (handles.dims ());
 
       for (octave_idx_type i = 0; i < handles.numel (); i++)
         result.xelem (i) = is_handle_visible (handles(i));
 
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -2375,17 +2375,17 @@ For each directory that is added, and th
       if (option == "-end")
         {
           append = true;
           nargin--;
         }
       else if (option == "-begin")
         nargin--;
     }
-  else if (option_arg.is_numeric_type ())
+  else if (option_arg.isnumeric ())
     {
       int val = option_arg.xint_value ("addpath: OPTION must be '-begin'/0 or '-end'/1");
 
       if (val == 0)
         nargin--;
       else if (val == 1)
         {
           append = true;
diff --git a/libinterp/corefcn/lookup.cc b/libinterp/corefcn/lookup.cc
--- a/libinterp/corefcn/lookup.cc
+++ b/libinterp/corefcn/lookup.cc
@@ -245,17 +245,17 @@ at most n-1).
 
   octave_value table = args(0);
   octave_value y = args(1);
   if (table.ndims () > 2 || (table.columns () > 1 && table.rows () > 1))
     warning ("lookup: table is not a vector");
 
   octave_value retval;
 
-  bool num_case = ((table.is_numeric_type () && y.is_numeric_type ())
+  bool num_case = ((table.isnumeric () && y.isnumeric ())
                    || (table.is_char_matrix () && y.is_char_matrix ()));
   bool str_case = table.iscellstr () && (y.is_string () || y.iscellstr ());
   bool left_inf = false;
   bool right_inf = false;
   bool match_idx = false;
   bool match_bool = false;
 
   if (nargin == 3)
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -613,18 +613,18 @@ factorization from scratch.
   bool pivoted = (nargin == 5);
 
   octave_value argl = args(0);
   octave_value argu = args(1);
   octave_value argp = (pivoted ? args(2) : octave_value ());
   octave_value argx = args(2 + pivoted);
   octave_value argy = args(3 + pivoted);
 
-  if (! (argl.is_numeric_type () && argu.is_numeric_type ()
-         && argx.is_numeric_type () && argy.is_numeric_type ()
+  if (! (argl.isnumeric () && argu.isnumeric ()
+         && argx.isnumeric () && argy.isnumeric ()
          && (! pivoted || argp.is_perm_matrix ())))
     error ("luupdate: L, U, X, and Y must be numeric");
 
   if (! check_lu_dims (argl, argu, argp))
     error ("luupdate: dimension mismatch");
 
   PermMatrix P = (pivoted
                   ? argp.perm_matrix_value ()
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -229,17 +229,17 @@ public:
   int is_int32 (void) const { return val.is_int32_type (); }
 
   int is_int64 (void) const { return val.is_int64_type (); }
 
   int is_int8 (void) const { return val.is_int8_type (); }
 
   int is_logical (void) const { return val.islogical (); }
 
-  int is_numeric (void) const { return val.is_numeric_type (); }
+  int is_numeric (void) const { return val.isnumeric (); }
 
   int is_single (void) const { return val.is_single_type (); }
 
   int is_sparse (void) const { return val.issparse (); }
 
   int is_struct (void) const { return val.isstruct (); }
 
   int is_uint16 (void) const { return val.is_uint16_type (); }
diff --git a/libinterp/corefcn/mgorth.cc b/libinterp/corefcn/mgorth.cc
--- a/libinterp/corefcn/mgorth.cc
+++ b/libinterp/corefcn/mgorth.cc
@@ -73,17 +73,17 @@ On exit, @var{y} is a unit vector such t
   octave_value arg_x = args(0);
   octave_value arg_v = args(1);
 
   if (arg_v.ndims () != 2 || arg_x.ndims () != 2 || arg_x.columns () != 1
       || arg_v.rows () != arg_x.rows ())
     error ("mgorth: V should be a matrix, and X a column vector with"
            " the same number of rows as V.");
 
-  if (! arg_x.is_numeric_type () && ! arg_v.is_numeric_type ())
+  if (! arg_x.isnumeric () && ! arg_v.isnumeric ())
     error ("mgorth: X and V must be numeric");
 
   octave_value_list retval;
 
   bool iscomplex = (arg_x.iscomplex () || arg_v.iscomplex ());
   if (arg_x.is_single_type () || arg_v.is_single_type ())
     {
       if (iscomplex)
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -146,17 +146,17 @@ do_history (const octave_value_list& arg
   for (octave_idx_type i = 0; i < nargin; i++)
     {
       octave_value arg = args(i);
 
       std::string option;
 
       if (arg.is_string ())
         option = arg.string_value ();
-      else if (arg.is_numeric_type ())
+      else if (arg.isnumeric ())
         {
           limit = arg.int_value ();
           if (limit < 0)
             limit = -limit;
           continue;
         }
       else
         err_wrong_type_arg ("history", arg);
@@ -329,17 +329,17 @@ get_int_arg (const octave_value& arg, in
   bool ok = true;
 
   if (arg.is_string ())
     {
       std::string tmp = arg.string_value ();
 
       ok = sscanf (tmp.c_str (), "%d", &val) == 1;
     }
-  else if (arg.is_numeric_type ())
+  else if (arg.isnumeric ())
     val = arg.int_value ();
   else
     ok = false;
 
   return ok;
 }
 
 static std::string
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -3409,17 +3409,17 @@ If the length of the smallest possible r
 {
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   octave_value arg = args(0);
 
-  if (! arg.is_numeric_type ())
+  if (! arg.isnumeric ())
     error ("rats: X must be numeric");
 
   octave::unwind_protect frame;
 
   frame.protect_var (rat_string_len);
 
   rat_string_len = 9;
   if (nargin == 2)
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -161,17 +161,17 @@ in control (see @code{are} and @code{dar
     }
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (nr != nc)
     err_square_matrix_required ("schur", "A");
 
-  if (! arg.is_numeric_type ())
+  if (! arg.isnumeric ())
     err_wrong_type_arg ("schur", arg);
 
   octave_value_list retval;
 
   if (arg.is_single_type ())
     {
       if (! force_complex && arg.isreal ())
         {
@@ -284,19 +284,19 @@ Note that the following relations hold:
 
 Note also that @var{U} and @var{T} are not unique.
 @seealso{schur}
 @end deftypefn */)
 {
   if (args.length () != 2 || nargout > 2)
     print_usage ();
 
-  if (! args(0).is_numeric_type ())
+  if (! args(0).isnumeric ())
     err_wrong_type_arg ("rsf2csf", args(0));
-  if (! args(1).is_numeric_type ())
+  if (! args(1).isnumeric ())
     err_wrong_type_arg ("rsf2csf", args(1));
   if (args(0).iscomplex () || args(1).iscomplex ())
     error ("rsf2csf: UR and TR must be real matrices");
 
   if (args(0).is_single_type () || args(1).is_single_type ())
     {
       FloatMatrix u = args(0).float_matrix_value ();
       FloatMatrix t = args(1).float_matrix_value ();
diff --git a/libinterp/corefcn/sparse.cc b/libinterp/corefcn/sparse.cc
--- a/libinterp/corefcn/sparse.cc
+++ b/libinterp/corefcn/sparse.cc
@@ -136,17 +136,17 @@ Compressed Column Sparse (rows = 3, cols
 
   if (nargin == 1)
     {
       octave_value arg = args(0);
       if (arg.islogical ())
         retval = arg.sparse_bool_matrix_value ();
       else if (arg.iscomplex ())
         retval = arg.sparse_complex_matrix_value ();
-      else if (arg.is_numeric_type ())
+      else if (arg.isnumeric ())
         retval = arg.sparse_matrix_value ();
       else
         err_wrong_type_arg ("sparse", arg);
     }
   else if (nargin == 2)
     {
       octave_idx_type m = 0;
       octave_idx_type n = 0;
@@ -198,17 +198,17 @@ Compressed Column Sparse (rows = 3, cols
           idx_vector j = args(1).index_vector ();
 
           if (args(2).islogical ())
             retval = SparseBoolMatrix (args(2).bool_array_value (), i,j,
                                        m, n, summation, nzmax);
           else if (args(2).iscomplex ())
             retval = SparseComplexMatrix (args(2).complex_array_value(),
                                           i, j, m, n, summation, nzmax);
-          else if (args(2).is_numeric_type ())
+          else if (args(2).isnumeric ())
             retval = SparseMatrix (args(2).array_value (), i, j,
                                    m, n, summation, nzmax);
           else
             err_wrong_type_arg ("sparse", args(2));
         }
       catch (octave::index_exception& e)
         {
           // Rethrow to allow more info to be reported later.
diff --git a/libinterp/corefcn/sqrtm.cc b/libinterp/corefcn/sqrtm.cc
--- a/libinterp/corefcn/sqrtm.cc
+++ b/libinterp/corefcn/sqrtm.cc
@@ -230,17 +230,17 @@ Mathematics, Manchester, England, Januar
     }
 
   if (arg.is_diag_matrix ())
     // sqrtm of a diagonal matrix is just sqrt.
     retval(0) = arg.sqrt ();
   else if (arg.is_single_type ())
     retval(0) = do_sqrtm<FloatMatrix, FloatComplexMatrix,
                          octave::math::schur<FloatComplexMatrix>> (arg);
-  else if (arg.is_numeric_type ())
+  else if (arg.isnumeric ())
     retval(0) = do_sqrtm<Matrix, ComplexMatrix,
                          octave::math::schur<ComplexMatrix>> (arg);
 
   if (nargout > 1)
     {
       // This corresponds to generic code
       //
       //   norm (s*s - x, "fro") / norm (x, "fro");
diff --git a/libinterp/corefcn/sub2ind.cc b/libinterp/corefcn/sub2ind.cc
--- a/libinterp/corefcn/sub2ind.cc
+++ b/libinterp/corefcn/sub2ind.cc
@@ -111,17 +111,17 @@ ind = sub2ind ([3, 3], s1, s2)
   if (nargin < 2)
     print_usage ();
 
   dim_vector dv = get_dim_vector (args(0), "sub2ind").redim (nargin - 1);
   Array<idx_vector> idxa (dim_vector (nargin-1, 1));
 
   for (int j = 0; j < nargin - 1; j++)
     {
-      if (! args(j+1).is_numeric_type ())
+      if (! args(j+1).isnumeric ())
         error ("sub2ind: subscripts must be numeric");
 
       try
         {
           idxa(j) = args(j+1).index_vector ();
 
           if (j > 0 && args(j+1).dims () != args(1).dims ())
             error ("sub2ind: all subscripts must be of the same size");
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -483,17 +483,17 @@ Return a logical array @var{y} correspon
 The result is a row vector if @var{x} is a row vector; otherwise, it is a
 column vector.
 @seealso{bitpack, typecast}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
-  if (! (args(0).is_numeric_type () || args(0).is_string ()))
+  if (! (args(0).isnumeric () || args(0).is_string ()))
     error ("bitunpack: argument must be a number or a string");
 
   octave_value retval;
 
   octave_value array = args(0);
 
   if (array.is_string ())
     retval = do_bitunpack (array.char_array_value ());
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -1220,17 +1220,17 @@ dims_to_numel (const dim_vector& dims, c
     {
       const dim_vector dv = dims.redim (len);
       retval = 1;
       for (octave_idx_type i = 0; i < len; i++)
         {
           octave_value idxi = idx_arg(i);
           if (idxi.is_magic_colon ())
             retval *= dv(i);
-          else if (idxi.is_numeric_type ())
+          else if (idxi.isnumeric ())
             retval *= idxi.numel ();
           else
             {
               try
                 {
                   idx_vector jdx = idxi.index_vector ();
 
                   retval *= jdx.length (dv(i));
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -624,17 +624,17 @@ If @var{info} is not present, an error m
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
   octave_value argr = args(0);
   octave_value argu = args(1);
 
-  if (! argr.is_numeric_type () || ! argu.is_numeric_type ()
+  if (! argr.isnumeric () || ! argu.isnumeric ()
       || (nargin > 2 && ! args(2).is_string ()))
     print_usage ();
 
   octave_value_list retval (nargout == 2 ? 2 : 1);
 
   octave_idx_type n = argr.rows ();
 
   std::string op = (nargin < 3) ? "+" : args(2).string_value ();
@@ -818,17 +818,17 @@ If @var{info} is not present, an error m
 {
   if (args.length () != 3)
     print_usage ();
 
   octave_value argr = args(0);
   octave_value argj = args(1);
   octave_value argu = args(2);
 
-  if (! argr.is_numeric_type () || ! argu.is_numeric_type ()
+  if (! argr.isnumeric () || ! argu.isnumeric ()
       || ! argj.is_real_scalar ())
     print_usage ();
 
   octave_idx_type n = argr.rows ();
   octave_idx_type j = argj.scalar_value ();
 
   if (argr.columns () != n || argu.rows () != n+1 || argu.columns () != 1)
     error ("cholinsert: dimension mismatch between R and U");
@@ -1056,17 +1056,17 @@ triangular, return the Cholesky@tie{}fac
 @end deftypefn */)
 {
   if (args.length () != 2)
     print_usage ();
 
   octave_value argr = args(0);
   octave_value argj = args(1);
 
-  if (! argr.is_numeric_type () || ! argj.is_real_scalar ())
+  if (! argr.isnumeric () || ! argj.is_real_scalar ())
     print_usage ();
 
   octave_idx_type n = argr.rows ();
   octave_idx_type j = argj.scalar_value ();
 
   if (argr.columns () != n)
     err_square_matrix_required ("choldelete", "R");
 
@@ -1183,17 +1183,17 @@ triangular, return the Cholesky@tie{}fac
 {
   if (args.length () != 3)
     print_usage ();
 
   octave_value argr = args(0);
   octave_value argi = args(1);
   octave_value argj = args(2);
 
-  if (! argr.is_numeric_type () || ! argi.is_real_scalar ()
+  if (! argr.isnumeric () || ! argi.is_real_scalar ()
       || ! argj.is_real_scalar ())
     print_usage ();
 
   octave_idx_type n = argr.rows ();
   octave_idx_type i = argi.scalar_value ();
   octave_idx_type j = argj.scalar_value ();
 
   if (argr.columns () != n)
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -903,18 +903,18 @@ economized (R is square).
   if (args.length () != 4)
     print_usage ();
 
   octave_value argq = args(0);
   octave_value argr = args(1);
   octave_value argu = args(2);
   octave_value argv = args(3);
 
-  if (! argq.is_numeric_type () || ! argr.is_numeric_type ()
-      || ! argu.is_numeric_type () || ! argv.is_numeric_type ())
+  if (! argq.isnumeric () || ! argr.isnumeric ()
+      || ! argu.isnumeric () || ! argv.isnumeric ())
     print_usage ();
 
   if (! check_qr_dims (argq, argr, true))
     error ("qrupdate: Q and R dimensions don't match");
 
   if (argq.isreal () && argr.isreal () && argu.isreal ()
       && argv.isreal ())
     {
@@ -1073,18 +1073,18 @@ If @var{orient} is @qcode{"row"}, full f
   if (nargin < 4 || nargin > 5)
     print_usage ();
 
   octave_value argq = args(0);
   octave_value argr = args(1);
   octave_value argj = args(2);
   octave_value argx = args(3);
 
-  if (! argq.is_numeric_type () || ! argr.is_numeric_type ()
-      || ! argx.is_numeric_type ()
+  if (! argq.isnumeric () || ! argr.isnumeric ()
+      || ! argx.isnumeric ()
       || (nargin > 4 && ! args(4).is_string ()))
     print_usage ();
 
   std::string orient = (nargin < 5) ? "col" : args(4).string_value ();
   bool col = (orient == "col");
 
   if (! col && orient != "row")
     error ("qrinsert: ORIENT must be \"col\" or \"row\"");
@@ -1268,17 +1268,17 @@ If @var{orient} is @qcode{"row"}, full f
 
   if (nargin < 3 || nargin > 4)
     print_usage ();
 
   octave_value argq = args(0);
   octave_value argr = args(1);
   octave_value argj = args(2);
 
-  if (! argq.is_numeric_type () || ! argr.is_numeric_type ()
+  if (! argq.isnumeric () || ! argr.isnumeric ()
       || (nargin > 3 && ! args(3).is_string ()))
     print_usage ();
 
   std::string orient = (nargin < 4) ? "col" : args(3).string_value ();
   bool col = orient == "col";
 
   if (! col && orient != "row")
     error ("qrdelete: ORIENT must be \"col\" or \"row\"");
@@ -1500,17 +1500,17 @@ of @w{@var{A}(:,p)}, where @w{p} is the 
   if (args.length () != 4)
     print_usage ();
 
   octave_value argq = args(0);
   octave_value argr = args(1);
   octave_value argi = args(2);
   octave_value argj = args(3);
 
-  if (! argq.is_numeric_type () || ! argr.is_numeric_type ())
+  if (! argq.isnumeric () || ! argr.isnumeric ())
     print_usage ();
 
   if (! check_qr_dims (argq, argr, true))
     error ("qrshift: dimensions mismatch");
 
   octave_idx_type i = argi.idx_type_value ();
   octave_idx_type j = argj.idx_type_value ();
 
diff --git a/libinterp/octave-value/ov-base-diag.h b/libinterp/octave-value/ov-base-diag.h
--- a/libinterp/octave-value/ov-base-diag.h
+++ b/libinterp/octave-value/ov-base-diag.h
@@ -118,17 +118,17 @@ public:
   Array<octave_idx_type> sort_rows_idx (sortmode mode = ASCENDING) const
   { return to_dense ().sort_rows_idx (mode); }
 
   sortmode is_sorted_rows (sortmode mode = UNSORTED) const
   { return to_dense ().is_sorted_rows (mode); }
 
   bool is_matrix_type (void) const { return true; }
 
-  bool is_numeric_type (void) const { return true; }
+  bool isnumeric (void) const { return true; }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_true (void) const;
 
   bool is_diag_matrix (void) const { return true; }
diff --git a/libinterp/octave-value/ov-base-mat.h b/libinterp/octave-value/ov-base-mat.h
--- a/libinterp/octave-value/ov-base-mat.h
+++ b/libinterp/octave-value/ov-base-mat.h
@@ -142,17 +142,17 @@ public:
   Array<octave_idx_type> sort_rows_idx (sortmode mode = ASCENDING) const
   { return matrix.sort_rows_idx (mode); }
 
   sortmode is_sorted_rows (sortmode mode = UNSORTED) const
   { return matrix.is_sorted_rows (mode); }
 
   bool is_matrix_type (void) const { return true; }
 
-  bool is_numeric_type (void) const { return true; }
+  bool isnumeric (void) const { return true; }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_true (void) const;
 
   bool print_as_scalar (void) const;
diff --git a/libinterp/octave-value/ov-base-scalar.h b/libinterp/octave-value/ov-base-scalar.h
--- a/libinterp/octave-value/ov-base-scalar.h
+++ b/libinterp/octave-value/ov-base-scalar.h
@@ -121,17 +121,17 @@ public:
   { return mode ? mode : ASCENDING; }
 
   MatrixType matrix_type (void) const { return MatrixType::Diagonal; }
   MatrixType matrix_type (const MatrixType&) const
   { return matrix_type (); }
 
   bool is_scalar_type (void) const { return true; }
 
-  bool is_numeric_type (void) const { return true; }
+  bool isnumeric (void) const { return true; }
 
   bool is_true (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false);
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool print_name_tag (std::ostream& os, const std::string& name) const;
diff --git a/libinterp/octave-value/ov-base-sparse.h b/libinterp/octave-value/ov-base-sparse.h
--- a/libinterp/octave-value/ov-base-sparse.h
+++ b/libinterp/octave-value/ov-base-sparse.h
@@ -135,17 +135,17 @@ public:
   { return full_value ().is_sorted (mode); }
 
   MatrixType matrix_type (void) const { return typ; }
   MatrixType matrix_type (const MatrixType& _typ) const
   { MatrixType ret = typ; typ = _typ; return ret; }
 
   bool is_matrix_type (void) const { return true; }
 
-  bool is_numeric_type (void) const { return true; }
+  bool isnumeric (void) const { return true; }
 
   bool issparse (void) const { return true; }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_true (void) const;
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -257,17 +257,17 @@ octave_value
 octave_base_value::subsasgn (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              const octave_value& rhs)
 {
   octave_value retval;
 
   if (is_defined ())
     {
-      if (! is_numeric_type ())
+      if (! isnumeric ())
         {
           std::string nm = type_name ();
           error ("can't perform indexed assignment for %s type", nm.c_str ());
         }
 
       switch (type[0])
         {
         case '(':
@@ -390,17 +390,17 @@ octave_base_value::any (int) const
   return 0.0;
 }
 
 octave_value
 octave_base_value::convert_to_str (bool pad, bool force, char type) const
 {
   octave_value retval = convert_to_str_internal (pad, force, type);
 
-  if (! force && is_numeric_type ())
+  if (! force && isnumeric ())
     warn_implicit_conversion ("Octave:num-to-str",
                               type_name (), retval.type_name ());
 
   return retval;
 }
 
 octave_value
 octave_base_value::convert_to_str_internal (bool, bool, char) const
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -418,17 +418,17 @@ public:
   virtual bool iscomplex (void) const { return false; }
 
   // Would be nice to get rid of the next four functions:
 
   virtual bool is_scalar_type (void) const { return false; }
 
   virtual bool is_matrix_type (void) const { return false; }
 
-  virtual bool is_numeric_type (void) const { return false; }
+  virtual bool isnumeric (void) const { return false; }
 
   virtual bool issparse (void) const { return false; }
 
   virtual bool is_true (void) const { return false; }
 
   virtual bool is_null_value (void) const { return false; }
 
   virtual bool is_constant (void) const { return false; }
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -597,17 +597,17 @@ Compatibility Note: Octave accepts compl
     print_usage ();
 
   octave_value retval;
 
   octave_value arg = args(0);
 
   if (arg.islogical ())
     retval = arg;
-  else if (arg.is_numeric_type ())
+  else if (arg.isnumeric ())
     {
       if (arg.issparse ())
         retval = arg.sparse_bool_matrix_value ();
       else if (arg.is_scalar_type ())
         retval = arg.bool_value ();
       else
         retval = arg.bool_array_value ();
     }
diff --git a/libinterp/octave-value/ov-bool-mat.h b/libinterp/octave-value/ov-bool-mat.h
--- a/libinterp/octave-value/ov-bool-mat.h
+++ b/libinterp/octave-value/ov-bool-mat.h
@@ -95,17 +95,17 @@ public:
   builtin_type_t builtin_type (void) const { return btyp_bool; }
 
   bool is_bool_matrix (void) const { return true; }
 
   bool islogical (void) const { return true; }
 
   bool isreal (void) const { return true; }
 
-  bool is_numeric_type (void) const { return false; }
+  bool isnumeric (void) const { return false; }
 
   int8NDArray
   int8_array_value (void) const { return int8NDArray (matrix); }
 
   int16NDArray
   int16_array_value (void) const { return int16NDArray (matrix); }
 
   int32NDArray
diff --git a/libinterp/octave-value/ov-bool-sparse.h b/libinterp/octave-value/ov-bool-sparse.h
--- a/libinterp/octave-value/ov-bool-sparse.h
+++ b/libinterp/octave-value/ov-bool-sparse.h
@@ -93,17 +93,17 @@ public:
   builtin_type_t builtin_type (void) const { return btyp_bool; }
 
   bool is_bool_matrix (void) const { return true; }
 
   bool islogical (void) const { return true; }
 
   bool isreal (void) const { return true; }
 
-  bool is_numeric_type (void) const { return false; }
+  bool isnumeric (void) const { return false; }
 
   double double_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
   { return double_value (frc_str_conv); }
 
   Matrix matrix_value (bool = false) const;
 
diff --git a/libinterp/octave-value/ov-bool.h b/libinterp/octave-value/ov-bool.h
--- a/libinterp/octave-value/ov-bool.h
+++ b/libinterp/octave-value/ov-bool.h
@@ -78,17 +78,17 @@ public:
   bool is_real_scalar (void) const { return true; }
 
   bool is_bool_scalar (void) const { return true; }
 
   bool islogical (void) const { return true; }
 
   bool isreal (void) const { return true; }
 
-  bool is_numeric_type (void) const { return false; }
+  bool isnumeric (void) const { return false; }
 
   bool is_true (void) const { return scalar; }
 
   int8NDArray
   int8_array_value (void) const
   { return int8NDArray (dim_vector (1, 1), scalar); }
 
   int16NDArray
diff --git a/libinterp/octave-value/ov-cell.h b/libinterp/octave-value/ov-cell.h
--- a/libinterp/octave-value/ov-cell.h
+++ b/libinterp/octave-value/ov-cell.h
@@ -106,17 +106,17 @@ public:
   sortmode is_sorted (sortmode mode = UNSORTED) const;
 
   Array<octave_idx_type> sort_rows_idx (sortmode mode = ASCENDING) const;
 
   sortmode is_sorted_rows (sortmode mode = UNSORTED) const;
 
   bool is_matrix_type (void) const { return false; }
 
-  bool is_numeric_type (void) const { return false; }
+  bool isnumeric (void) const { return false; }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool iscell (void) const { return true; }
 
   builtin_type_t builtin_type (void) const { return btyp_cell; }
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1806,17 +1806,17 @@ belongs to.
   boolNDArray matches (clsnames.dims (), false);
 
   for (octave_idx_type idx = 0; idx < clsnames.numel (); idx++)
     {
       std::string cls = clsnames(idx);
       if (obj_cls == cls
           || (cls == "float"   && obj.isfloat   ())
           || (cls == "integer" && obj.isinteger ())
-          || (cls == "numeric" && obj.is_numeric_type ())
+          || (cls == "numeric" && obj.isnumeric ())
           || obj.is_instance_of (cls))
         matches(idx) = true;
     }
 
   return ovl (matches);
 }
 
 /*
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -787,17 +787,17 @@ functions from strings is through the us
 
       // Sort the arguments into ascii order.
       fargs.sort ();
 
       if (fargs.isempty ())
         fargs.append (std::string ("x"));
 
     }
-  else if (nargin == 2 && args(1).is_numeric_type ())
+  else if (nargin == 2 && args(1).isnumeric ())
     {
       if (! args(1).is_scalar_type ())
         error ("inline: N must be an integer");
 
       int n = args(1).int_value ("inline: N must be an integer");
 
       if (n < 0)
         error ("inline: N must be a positive integer or zero");
diff --git a/libinterp/octave-value/ov-lazy-idx.h b/libinterp/octave-value/ov-lazy-idx.h
--- a/libinterp/octave-value/ov-lazy-idx.h
+++ b/libinterp/octave-value/ov-lazy-idx.h
@@ -115,17 +115,17 @@ public:
   sortmode is_sorted (sortmode mode = UNSORTED) const;
 
   Array<octave_idx_type> sort_rows_idx (sortmode mode = ASCENDING) const;
 
   sortmode is_sorted_rows (sortmode mode = UNSORTED) const;
 
   bool is_matrix_type (void) const { return true; }
 
-  bool is_numeric_type (void) const { return true; }
+  bool isnumeric (void) const { return true; }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_true (void) const
   { return make_value ().is_true (); }
 
diff --git a/libinterp/octave-value/ov-perm.h b/libinterp/octave-value/ov-perm.h
--- a/libinterp/octave-value/ov-perm.h
+++ b/libinterp/octave-value/ov-perm.h
@@ -105,17 +105,17 @@ public:
   { return to_dense ().is_sorted_rows (mode); }
 
   builtin_type_t builtin_type (void) const { return btyp_double; }
 
   bool is_perm_matrix (void) const { return true; }
 
   bool is_matrix_type (void) const { return true; }
 
-  bool is_numeric_type (void) const { return true; }
+  bool isnumeric (void) const { return true; }
 
   bool is_defined (void) const { return true; }
 
   bool is_constant (void) const { return true; }
 
   bool is_real_matrix (void) const { return true; }
 
   bool isreal (void) const { return true; }
diff --git a/libinterp/octave-value/ov-range.h b/libinterp/octave-value/ov-range.h
--- a/libinterp/octave-value/ov-range.h
+++ b/libinterp/octave-value/ov-range.h
@@ -158,17 +158,17 @@ public:
   builtin_type_t builtin_type (void) const { return btyp_double; }
 
   bool isreal (void) const { return true; }
 
   bool is_double_type (void) const { return true; }
 
   bool isfloat (void) const { return true; }
 
-  bool is_numeric_type (void) const { return true; }
+  bool isnumeric (void) const { return true; }
 
   bool is_true (void) const;
 
   double double_value (bool = false) const;
 
   float float_value (bool = false) const;
 
   double scalar_value (bool frc_str_conv = false) const
diff --git a/libinterp/octave-value/ov-str-mat.h b/libinterp/octave-value/ov-str-mat.h
--- a/libinterp/octave-value/ov-str-mat.h
+++ b/libinterp/octave-value/ov-str-mat.h
@@ -106,17 +106,17 @@ public:
 
   octave_value resize (const dim_vector& dv, bool fill = false) const;
 
   octave_value diag (octave_idx_type k = 0) const
   { return octave_value (matrix.diag (k)); }
 
   bool is_string (void) const { return true; }
 
-  bool is_numeric_type (void) const { return false; }
+  bool isnumeric (void) const { return false; }
 
   double double_value (bool = false) const;
 
   Matrix matrix_value (bool = false) const;
 
   NDArray array_value (bool = false) const;
 
   Complex complex_value (bool = false) const;
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -992,17 +992,17 @@ element-by-element and a logical array i
     ignored = tmp.matrix_value ();
 
   if (args(0).is_scalar_type ())
     {
       double k = args(0).double_value ();
 
       return ovl (isargout1 (nargout1, ignored, k));
     }
-  else if (args(0).is_numeric_type ())
+  else if (args(0).isnumeric ())
     {
       const NDArray ka = args(0).array_value ();
 
       boolNDArray r (ka.dims ());
       for (octave_idx_type i = 0; i < ka.numel (); i++)
         r(i) = isargout1 (nargout1, ignored, ka(i));
 
       return ovl (r);
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -661,32 +661,32 @@ public:
   { return rep->is_uint16_type (); }
 
   bool is_uint32_type (void) const
   { return rep->is_uint32_type (); }
 
   bool is_uint64_type (void) const
   { return rep->is_uint64_type (); }
 
+  bool isinteger (void) const
+  { return rep->isinteger (); }
+
+  OCTAVE_DEPRECATED ("use 'isinteger' instead")
+  bool is_integer_type (void) const
+  { return rep->isinteger (); }
+
   // Other type stuff.
 
   bool islogical (void) const
   { return rep->islogical (); }
 
   OCTAVE_DEPRECATED ("use 'islogical' instead")
   bool is_bool_type (void) const
   { return rep->islogical (); }
 
-  bool isinteger (void) const
-  { return rep->isinteger (); }
-
-  OCTAVE_DEPRECATED ("use 'isinteger' instead")
-  bool is_integer_type (void) const
-  { return rep->isinteger (); }
-
   bool isreal (void) const
   { return rep->isreal (); }
 
   OCTAVE_DEPRECATED ("use 'isreal' instead")
   bool is_real_type (void) const
   { return rep->isreal (); }
 
   bool iscomplex (void) const
@@ -697,18 +697,22 @@ public:
   { return rep->iscomplex (); }
 
   bool is_scalar_type (void) const
   { return rep->is_scalar_type (); }
 
   bool is_matrix_type (void) const
   { return rep->is_matrix_type (); }
 
+  bool isnumeric (void) const
+  { return rep->isnumeric (); }
+
+  OCTAVE_DEPRECATED ("use 'isnumeric' instead")
   bool is_numeric_type (void) const
-  { return rep->is_numeric_type (); }
+  { return rep->isnumeric (); }
 
   bool issparse (void) const
   { return rep->issparse (); }
 
   OCTAVE_DEPRECATED ("use 'issparse' instead")
   bool is_sparse_type (void) const
   { return rep->issparse (); }
 
diff --git a/libinterp/parse-tree/bp-table.cc b/libinterp/parse-tree/bp-table.cc
--- a/libinterp/parse-tree/bp-table.cc
+++ b/libinterp/parse-tree/bp-table.cc
@@ -512,17 +512,17 @@ bp_table::parse_dbfunction_params (const
                 {
                   int line = atoi (args(pos).string_value ().c_str ());
 
                   if (line > 0)
                     lines[list_idx++] = line;
                   else
                     break;        // may be "if"
                 }
-              else if (args(pos).is_numeric_type ())
+              else if (args(pos).isnumeric ())
                 {
                   const NDArray arg = args(pos).array_value ();
 
                   for (octave_idx_type j = 0; j < arg.numel (); j++)
                     lines[list_idx++] = static_cast<int> (arg.elem (j));
                 }
               else
                 error ("%s: Invalid argument type %s",
