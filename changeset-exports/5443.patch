# HG changeset patch
# User jwe
# Date 1126143658 0
#      Thu Sep 08 01:40:58 2005 +0000
# Node ID ec8c33dcd1bfc5eb8df1538ff3e4867e84695f85
# Parent  636886245488686be365298244469e9ce80bac33
[project @ 2005-09-08 01:40:57 by jwe]

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,52 @@
+2005-09-07  Bill Denney  <denney@seas.upenn.edu>
+
+	* audio/playaudio.m, control/base/__bodquist__.m,
+	control/base/lqg.m, control/obsolete/dezero.m,
+	control/system/__syschnamesl__.m, control/system/__sysconcat__.m,
+	control/system/c2d.m, control/system/cellidx.m,
+	control/system/d2c.m, control/system/dmr2d.m,
+	control/system/is_signal_list.m, control/system/listidx.m,
+	control/system/ss.m, control/system/sysappend.m,
+	control/system/sysconnect.m, control/system/sysdup.m,
+	control/system/sysgetsignals.m, control/system/sysidx.m,
+	control/system/sysprune.m, control/system/syssetsignals.m,
+	control/system/tfout.m, control/system/zpout.m,
+	control/util/prompt.m, control/util/sortcom.m,
+	control/util/strappend.m, finance/fv.m, finance/nper.m,
+	finance/pmt.m, finance/pv.m, finance/rate.m, general/diff.m,
+	general/num2str.m, general/repmat.m, general/sortrows.m,
+	general/strerror.m, image/colormap.m, image/imshow.m,
+	image/loadimage.m, image/saveimage.m, linear-algebra/norm.m,
+	miscellaneous/fileparts.m, miscellaneous/popen2.m,
+	plot/__axis_label__.m, plot/__errcomm__.m, plot/__plt1__.m,
+	plot/__plt2__.m, plot/__plt__.m, plot/__pltopt1__.m,
+	plot/__pltopt__.m, plot/axis.m, plot/bottom_title.m, plot/close.m,
+	plot/grid.m, plot/hist.m, plot/plot_border.m, plot/polar.m,
+	plot/print.m, plot/title.m, plot/top_title.m,
+	polynomial/polyout.m, set/unique.m, signal/freqz.m, signal/stft.m,
+	statistics/base/mean.m, statistics/base/moment.m,
+	statistics/tests/cor_test.m,
+	statistics/tests/kolmogorov_smirnov_test.m,
+	statistics/tests/kolmogorov_smirnov_test_2.m,
+	statistics/tests/prop_test_2.m, statistics/tests/sign_test.m,
+	statistics/tests/t_test.m, statistics/tests/t_test_2.m,
+	statistics/tests/t_test_regression.m, statistics/tests/u_test.m,
+	statistics/tests/var_test.m, statistics/tests/welch_test.m,
+	statistics/tests/wilcoxon_test.m, statistics/tests/z_test.m,
+	statistics/tests/z_test_2.m, strings/base2dec.m, strings/blanks.m,
+	strings/deblank.m, strings/dec2base.m, strings/index.m,
+	strings/rindex.m, strings/split.m, strings/str2mat.m,
+	strings/str2num.m, strings/strcat.m, strings/strcmpi.m,
+	strings/strncmp.m, strings/strrep.m, strings/substr.m:
+	Avoid deprecated functions.  Use ischar instead of isstr.  Use
+	isvector instead of is_vector.  Use isstruct instead of
+	is_struct.  Use char instead of setstr.
+
 2005-08-31  Daniel  <durbano@shbano.com>
 
 	* special-matrix/invhilb.m, statistics/base/iqr.m,
 	control/system/is_controllable.m, set/ismember.m: Doc fixes.
 	From Jorge Barros de Abreu <ficmatin01@solar.com.br>.
 
 2005-08-29  Bill Denney <denney@seas.upenn.edu>
 
diff --git a/scripts/audio/playaudio.m b/scripts/audio/playaudio.m
--- a/scripts/audio/playaudio.m
+++ b/scripts/audio/playaudio.m
@@ -29,17 +29,17 @@
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 11 April 1994
 ## Adapted-By: jwe
 
 function playaudio (name, ext)
 
   usage_msg = "playaudio (name, ext)  or  playaudio (X)";
 
-  if (nargin == 1 && isvector (name) && ! isstr (name))
+  if (nargin == 1 && isvector (name) && ! ischar (name))
     ## play a vector
     [nr, nc] = size (name);
     if (nc != 1)
       if (nr == 1)
         name = name';
         nr = nc;
       else
         error ("playaudio: X must be a vector");
@@ -50,17 +50,17 @@ function playaudio (name, ext)
       file = tmpnam ();
       num = fopen (file, "wb");
       c = fwrite (num, X, "uchar");
       fclose (num);
       system (sprintf ("cat \"%s\" > /dev/dsp", file));
     unwind_protect_cleanup
       unlink (file);
     end_unwind_protect
-  elseif (nargin >= 1 && isstr (name))
+  elseif (nargin >= 1 && ischar (name))
     ## play a file
     if (nargin == 1)
       name = [name, ".lin"];
     elseif (nargin == 2)
       name = [name, ".", ext];
     else
       usage (usage_msg);
     endif
diff --git a/scripts/control/base/__bodquist__.m b/scripts/control/base/__bodquist__.m
--- a/scripts/control/base/__bodquist__.m
+++ b/scripts/control/base/__bodquist__.m
@@ -69,20 +69,20 @@ function [f, w, rsys] = __bodquist__ (sy
   ## get initial dimensions (revised below if sysprune is called)
   [nn,nz,mm,pp ] = sysdimensions(sys);
 
   ## check for an output vector and to see whether it`s correct
   if (!isempty(outputs))
     if (isempty(inputs))
       inputs = 1:mm;                    # use all inputs
       warning([rname,": outputs specified but not inputs"]);
-    elseif(is_signal_list(inputs) | isstr(inputs))
+    elseif(is_signal_list(inputs) | ischar(inputs))
       inputs = sysidx(sys,"in",inputs);
     endif
-    if(is_signal_list(outputs) | isstr(outputs))
+    if(is_signal_list(outputs) | ischar(outputs))
       outputs = sysidx(sys,"out",outputs);
     end
     sys = sysprune(sys,outputs,inputs);
     [nn,nz,mm,pp ] = sysdimensions(sys);
   endif
 
   ## for speed in computation, convert local copy of
   ## SISO state space systems to zero-pole  form
diff --git a/scripts/control/base/lqg.m b/scripts/control/base/lqg.m
--- a/scripts/control/base/lqg.m
+++ b/scripts/control/base/lqg.m
@@ -94,17 +94,17 @@ function [K, Q1, P1, Ee, Er] = lqg (sys,
           num2str(columns(Sigw)),", dim(u)=",num2str(columns(R))])
 
   elseif(nout != columns(Sigv))
     error(["lqg: sys has ",num2str(nout)," outputs, dim(Sigv)=", ...
           num2str(columns(Sigv)),")"])
   endif
 
   ## check for names of signals
-  if(is_signal_list(input_list) | isstr(input_list))
+  if(is_signal_list(input_list) | ischar(input_list))
     input_list = sysidx(sys,"in",input_list);
   endif
 
   if(length(input_list) != columns(R))
     error(["lqg: length(input_list)=",num2str(length(input_list)), ...
           ", columns(R)=", num2str(columns(R))]);
   endif
 
diff --git a/scripts/control/obsolete/dezero.m b/scripts/control/obsolete/dezero.m
--- a/scripts/control/obsolete/dezero.m
+++ b/scripts/control/obsolete/dezero.m
@@ -31,29 +31,29 @@
 
 function t = dezero (s)
 
   ## delete the next line if you're stubbornly going to use dezero.
   error("dezero is no longer supported.");
 
   if (nargin != 1)
     usage ("dezero (s)");
-  elseif (isstr (s))
+  elseif (ischar (s))
 
     [nr, nc] = size (s);
     len = nr * nc;
 
     if (len == 0)
       t = s;
     else
 
       s = reshape (s, 1, len);
 
       ## need to remove zeros first, then call deblank
       s = toascii (s);
-      t = deblank(setstr(s(find(s != 0) )));
+      t = deblank(char(s(find(s != 0) )));
     endif
 
   else
     error ("dezero: expecting string argument");
   endif
 
 endfunction
diff --git a/scripts/control/system/__syschnamesl__.m b/scripts/control/system/__syschnamesl__.m
--- a/scripts/control/system/__syschnamesl__.m
+++ b/scripts/control/system/__syschnamesl__.m
@@ -101,17 +101,17 @@ function old_names = __syschnamesl__ (ol
     endfor
 
     ## disp("__syschnamesl__: old_names fixed zeros ")
     ## old_names
     ## disp("/__syschnamesl__");
   endif
 
   ## just in case it's not a string anymore
-  if( !isstr(old_names) )
-    old_names = setstr(old_names);
+  if( !ischar(old_names) )
+    old_names = char(old_names);
   endif
 
   ## disp("__syschnamesl__: exit, old_names=")
   ## old_names
   ## disp("/__syschnamesl__: exiting")
 
 endfunction
diff --git a/scripts/control/system/__sysconcat__.m b/scripts/control/system/__sysconcat__.m
--- a/scripts/control/system/__sysconcat__.m
+++ b/scripts/control/system/__sysconcat__.m
@@ -1,16 +1,16 @@
 function c = __sysconcat__(a,b)
   # c = __sysconcat__(a,b)
   # cell array replacement for append, used by control systems toolbox
 
-  if(isstr(a))
+  if(ischar(a))
     a = {a};
   endif
-  if(isstr(b))
+  if(ischar(b))
     b = {b};
   endif
 
   if ( ! ( is_signal_list(a)  && is_signal_list(b) ) )
     error("need cell arrays of strings");
   endif
 
   c = a;
diff --git a/scripts/control/system/c2d.m b/scripts/control/system/c2d.m
--- a/scripts/control/system/c2d.m
+++ b/scripts/control/system/c2d.m
@@ -102,22 +102,22 @@
 function dsys = c2d (sys, opt, T)
   ## parse input arguments
   if(nargin < 1 | nargin > 3)
     usage("dsys=c2d(sys[,T])");
   elseif (!isstruct(sys))
     error("sys must be a system data structure");
   elseif (nargin == 1)
     opt = "ex";
-  elseif (nargin == 2 & !isstr(opt) )
+  elseif (nargin == 2 & !ischar(opt) )
     T = opt;
     opt = "ex";
   endif
 
-  if (! isstr (opt))
+  if (! ischar (opt))
     error ("expecting option as a string");
   endif
 
   ## check if sampling period T was passed.
   Ts = sysgettsam(sys);
   if(!exist("T"))
     T = Ts;
     if(T == 0)
diff --git a/scripts/control/system/cellidx.m b/scripts/control/system/cellidx.m
--- a/scripts/control/system/cellidx.m
+++ b/scripts/control/system/cellidx.m
@@ -35,25 +35,25 @@
 ## @end deftypefn
 
 function [idxvec,errmsg]  = cellidx(listvar,strlist)
 
 if(nargin != 2)
   usage("idxvec = cellidx(listvar,strlist)");
 endif
 
-if(isstr(strlist))
+if(ischar(strlist))
   tmp = strlist;
   strlist = {};
   for kk=1:rows(tmp)
     strlist{kk} = deblank(tmp(kk,:));
   endfor
 endif
 
-if(isstr(listvar))
+if(ischar(listvar))
   tmp = listvar;
   listvar = {};
   for kk=1:rows(tmp)
     listvar{kk} = deblank(tmp(kk,:));
   endfor
 endif
 
 ## initialize size of idxvec (for premature return)
diff --git a/scripts/control/system/d2c.m b/scripts/control/system/d2c.m
--- a/scripts/control/system/d2c.m
+++ b/scripts/control/system/d2c.m
@@ -68,17 +68,17 @@ function csys = d2c (sys, opt)
 
   if( (nargin != 1) & (nargin != 2) )
     usage("csys = d2c(sys[,tol]), csys = d2c(sys,opt)");
   elseif (!isstruct(sys))
     error("sys must be in system data structure");
   elseif(nargin == 1)
     opt = "log";
     tol = 1e-12;
-  elseif(isstr(opt))   # all remaining cases are for nargin == 2
+  elseif(ischar(opt))   # all remaining cases are for nargin == 2
     tol = 1e-12;
     if( !(strcmp(opt,"log") | strcmp(opt,"bi") ) )
       error(["d2c: invalid opt passed=",opt]);
     endif
   elseif(!is_sample(opt))
     error("tol must be a postive scalar")
   elseif(opt > 1e-2)
     warning(["d2c: ridiculous error tolerance passed=",num2str(opt); ...
diff --git a/scripts/control/system/dmr2d.m b/scripts/control/system/dmr2d.m
--- a/scripts/control/system/dmr2d.m
+++ b/scripts/control/system/dmr2d.m
@@ -82,17 +82,17 @@ function [dsys, fidx] = dmr2d (sys, idx,
   elseif (!isstruct(sys))
     error("sys must be in system data structure form");
 
   elseif(!is_digital(sys))
     error("sys must be discrete-time; continuous time passed");
   
   endif
 
-  if(is_signal_list(idx) | isstr(idx))
+  if(is_signal_list(idx) | ischar(idx))
     idx = sysidx(sys,"st",idx);
 
   elseif (!(isvector(idx) | isempty(idx)))
     error(["idx(",num2str(rows(idx)),"x",num2str(columns(idx)), ...
       ") must be a vector"]);
 
   elseif (any(idx <= 0))
     idv = find(idx <= 0);
diff --git a/scripts/control/system/is_signal_list.m b/scripts/control/system/is_signal_list.m
--- a/scripts/control/system/is_signal_list.m
+++ b/scripts/control/system/is_signal_list.m
@@ -24,15 +24,15 @@
 function flg = is_signal_list (mylist)
 
   flg = iscell (mylist);
   if(flg)
     flg = (rows(mylist) == 1 | columns(mylist) == 1);
   end
   if (flg)
     for ii = 1:length (mylist)
-      if (! (isstr (mylist{ii}) && rows (mylist{ii}) == 1))
+      if (! (ischar (mylist{ii}) && rows (mylist{ii}) == 1))
 	flg = 0;
       endif
     endfor
   endif
 
 endfunction
diff --git a/scripts/control/system/listidx.m b/scripts/control/system/listidx.m
--- a/scripts/control/system/listidx.m
+++ b/scripts/control/system/listidx.m
@@ -36,25 +36,25 @@
 
 function [idxvec,errmsg]  = listidx(listvar,strlist)
   error("listidx: don't use this anymore, ok?\n");
 
 if(nargin != 2)
   usage("idxvec = listidx(listvar,strlist)");
 endif
 
-if(isstr(strlist))
+if(ischar(strlist))
   tmp = strlist;
   strlist = list();
   for kk=1:rows(tmp)
     strlist(kk) = deblank(tmp(kk,:));
   endfor
 endif
 
-if(isstr(listvar))
+if(ischar(listvar))
   tmp = listvar;
   listvar = list();
   for kk=1:rows(tmp)
     listvar(kk) = deblank(tmp(kk,:));
   endfor
 endif
 
 ## initialize size of idxvec (for premature return)
diff --git a/scripts/control/system/ss.m b/scripts/control/system/ss.m
--- a/scripts/control/system/ss.m
+++ b/scripts/control/system/ss.m
@@ -213,28 +213,28 @@ function retsys = ss (a, b, c, d, tsam, 
   if(nargin < 5) tsam = 0;
   elseif( !( is_sample(tsam) | (tsam == 0) ) )
     error("tsam must be a nonnegative real scalar");
   endif
 
   ## check for continuous states
   if( (nargin < 6) & (tsam == 0) )               n = na;
   elseif(nargin < 6)                             n = 0;
-  elseif((!ismatrix(n)) | isstr(n))
+  elseif((!ismatrix(n)) | ischar(n))
     error("Parameter n is not a numerical value.");
   elseif( (!isscalar(n)) | (n < 0 ) | (n != round(n)) )
     if(isscalar(n))     error("invalid value of n=%d,%e",n,n);
     else                 error("invalid value of n=(%dx%d)", ...
                            rows(n), columns(n));                endif
   endif
 
   ## check for num discrete states
   if( (nargin < 7) & (tsam == 0))               nz = 0;
   elseif(nargin < 7)                            nz = na - n;
-  elseif((!ismatrix(nz)) | isstr(nz))
+  elseif((!ismatrix(nz)) | ischar(nz))
     error("Parameter nz is not a numerical value.");
   elseif( (!isscalar(nz)) | (nz < 0 ) | (nz != round(nz)) )
     if(isscalar(nz))
       error(["invalid value of nz=",num2str(nz)]);
     else
       error(["invalid value of nz=(",num2str(rows(nz)),"x", ...
         num2str(columns(nz)),")"]);
     endif
diff --git a/scripts/control/system/sysappend.m b/scripts/control/system/sysappend.m
--- a/scripts/control/system/sysappend.m
+++ b/scripts/control/system/sysappend.m
@@ -106,17 +106,17 @@ function retsys = sysappend (sys, b, c, 
     else               make_d = 0;                             endif
     if(make_d)         d = zeros(rows(c)+Ap,columns(b) + Am);  endif
 
     ## Append new input(s) if any
     Bm = max(columns(d),columns(b)+Am);
     if(Bm != Am)
       ## construct new signal names
       if(nargin >= 6)   # new names were passed
-	if(!isstr(inname))
+	if(!ischar(inname))
 	  error("inname must be a string");
 	elseif(rows(inname) != (Bm - Am))
 	  error(sprintf("%d new inputs requested; inname(%dx%d)", ...
 	    (Bm-Am),rows(inname),columns(inname)));
 	endif
       else
 	inname = __sysdefioname__(Bm,"u",(Am+1));
       endif
@@ -139,17 +139,17 @@ function retsys = sysappend (sys, b, c, 
     endif
 
     ## Append new output(s) if any
     Bp = max(rows(d),rows(c)+Ap);
     if(Bp != Ap)
 
       ## construct new signal names, output classification
       if(nargin >= 5)  # new names were passed
-	if(!isstr(outname))
+	if(!ischar(outname))
 	  error("outname must be a string");
 	elseif(rows(outname) != (Bp - Ap))
 	  error(sprintf("%d new outputs requested; outname(%dx%d)", ...
 	    (Bp-Ap),rows(outname),columns(outname)));
 	endif
       else
 	outname = __sysdefioname__(Bp,"y",(Ap+1));
       endif
diff --git a/scripts/control/system/sysconnect.m b/scripts/control/system/sysconnect.m
--- a/scripts/control/system/sysconnect.m
+++ b/scripts/control/system/sysconnect.m
@@ -91,20 +91,20 @@ function sys = sysconnect (sys, output_l
   elseif( !is_sample(tol) )
     error("sysconnect: tol must be a positive scalar");
   elseif(tol > 1e2*sqrt(eps))
     warning(["sysconnect: tol set to large value=",num2str(tol), ...
         ", eps=",num2str(eps)])
   endif
 
   ## convert signal names to indices
-  if(is_signal_list(input_list) | isstr(input_list))
+  if(is_signal_list(input_list) | ischar(input_list))
     input_list = sysidx(sys,"in",input_list);
   endif
-  if(is_signal_list(output_list) | isstr(output_list))
+  if(is_signal_list(output_list) | ischar(output_list))
     output_list = sysidx(sys,"out",output_list);
   endif
 
   ## verify sizes,format of input, output lists
   if( min(size(output_list))*min(size(input_list)) != 1)
     error("output_list and input_list must be vectors");
   else
     lo = length(output_list);
diff --git a/scripts/control/system/sysdup.m b/scripts/control/system/sysdup.m
--- a/scripts/control/system/sysdup.m
+++ b/scripts/control/system/sysdup.m
@@ -69,20 +69,20 @@ function retsys = sysdup (Asys, output_l
     error("Asys must be a system data structure (see ss, tf, or zp)")
   endif
 
   Asys = sysupdate(Asys,"ss");
   [nn,nz,mm,pp] = sysdimensions(Asys);
   [aa,bb,cc,dd] = sys2ss(Asys);
 
   ## check for signal names
-  if(is_signal_list(input_list) | isstr(input_list))
+  if(is_signal_list(input_list) | ischar(input_list))
     input_list = sysidx(Asys,"in",input_list);
   endif
-  if(is_signal_list(output_list) | isstr(output_list))
+  if(is_signal_list(output_list) | ischar(output_list))
     output_list = sysidx(Asys,"out",output_list);
   endif
 
   ## first duplicate inputs
   if(isvector(input_list))
     for ii=1:length(input_list);
       bb(:,mm+ii) = bb(:,input_list(ii));
       dd(:,mm+ii) = dd(:,input_list(ii));
diff --git a/scripts/control/system/sysgetsignals.m b/scripts/control/system/sysgetsignals.m
--- a/scripts/control/system/sysgetsignals.m
+++ b/scripts/control/system/sysgetsignals.m
@@ -155,29 +155,29 @@ function [stname, inname, outname, yd] =
   endif
   if(nargin < 4)  strflg = 0; endif
   if(nargin == 1)
     sys = sysupdate(sys,"ss");          #make sure ss is up to date
     stname = sysgetsignals(sys,"st");
     inname = sysgetsignals(sys,"in");
     outname = sysgetsignals(sys,"out");
     yd = sysgetsignals(sys,"yd");
-  elseif(!(isstr(sigid) & min(size(sigid)) == 1))
+  elseif(!(ischar(sigid) & min(size(sigid)) == 1))
     error(sprintf("sigid(%dx%d) must be a string)",rows(sigid),columns(sigid)));
   else
     if(strcmp("st",sigid))         stname = sys.stname;
     elseif(strcmp("in",sigid))     stname = sys.inname;
     elseif(strcmp("out",sigid))    stname = sys.outname;
     elseif(strcmp("yd",sigid))     stname = vec(sys.yd)';
     else
       error(sprintf("sigid=%s must be \"st\", \"in\", \"out\", or \"yd\"", ...
         sigid));
     endif
     if(nargin >= 3)
-      if( is_signal_list(signum) | isstr(signum) )
+      if( is_signal_list(signum) | ischar(signum) )
         signum = cellidx(stname,signum);
       end
       if(max(signum) > length(stname))
         error(sprintf("sysgetsignals(sys,\"%s\",%d):only %d entries.\n", ...
           sigid,signum, rows(stname)));
       else
         if(!isscalar(strflg))
           error("strflg must be a scalar");
diff --git a/scripts/control/system/sysidx.m b/scripts/control/system/sysidx.m
--- a/scripts/control/system/sysidx.m
+++ b/scripts/control/system/sysidx.m
@@ -26,17 +26,17 @@
 ## @end deftypefn
 
 function idxvec = sysidx (sys, sigtype, signamelist)
 
   if (nargin != 3)
     usage ("idxvec = sysidx (sys, sigtype, signamelist)");
   elseif (! isstruct (sys))
     error ("sys must be a system data structure");
-  elseif (! isstr (sigtype))
+  elseif (! ischar (sigtype))
     error ("sigtype must be a string");
   elseif (rows (sigtype) != 1)
     [nr, nc] = size (sigtype);
     error ("sigtype (%d x %d) must be a single string", nr, nc);
   endif
 
   ## extract correct set of signal names values
   [idxvec, msg] = cellidx ({"in", "out", "st", "yd"}, sigtype);
diff --git a/scripts/control/system/sysprune.m b/scripts/control/system/sysprune.m
--- a/scripts/control/system/sysprune.m
+++ b/scripts/control/system/sysprune.m
@@ -68,20 +68,20 @@ function sys = sysprune (sys, output_idx
 
   ## default: no action
   [nn,nz,mm,pp] = sysdimensions(sys);
   if(isempty(output_idx)) output_idx = 1:pp; endif
   if(isempty(input_idx)) input_idx = 1:mm; endif
   if(isempty(state_idx)) state_idx = 1:(nn+nz); endif
 
   ## check for signal names
-  if(is_signal_list(output_idx) | isstr(output_idx))
+  if(is_signal_list(output_idx) | ischar(output_idx))
     output_idx = sysidx(sys,"out",output_idx);
   endif
-  if(is_signal_list(input_idx) | isstr(input_idx))
+  if(is_signal_list(input_idx) | ischar(input_idx))
     input_idx = sysidx(sys,"in",input_idx);
   endif
 
   ## check dimensions
   if( !(isvector(output_idx) | isempty(output_idx) )  )
     if(!ismatrix(output_idx))
       error("sysprune: bad argument passed for output_idx");
     else
diff --git a/scripts/control/system/syssetsignals.m b/scripts/control/system/syssetsignals.m
--- a/scripts/control/system/syssetsignals.m
+++ b/scripts/control/system/syssetsignals.m
@@ -96,23 +96,23 @@
 function retsys = syssetsignals (sys, opt, names, sig_idx)
 
   if (nargin < 3 | nargin > 4)
     usage("retsys=syssetsignals(sys,opt,names{,sig_idx})");
   elseif (!isstruct(sys))
     error("sys must be a system data structure");
   elseif (isempty(opt))
     opt = "out";
-  elseif( ! isstr(opt)  )
+  elseif( ! ischar(opt)  )
     error("opt must be a string");
   elseif( ! (strcmp(opt,"out") + strcmp(opt,"yd") + ...
     strcmp(opt,"in") + strcmp(opt,"st") ) )
     error("opt must be one of [], ""out"", ""yd"", ""in"", or ""st""");
   elseif(nargin == 4)
-    if(is_signal_list(sig_idx) | isstr(sig_idx))
+    if(is_signal_list(sig_idx) | ischar(sig_idx))
       ## convert to vector of indices
       if(opt == "yd")
         sig_idx = sysidx(sys,"out",sig_idx);
       else
         sig_idx = sysidx(sys,opt,sig_idx);
       endif
     endif
 
@@ -132,17 +132,17 @@ function retsys = syssetsignals (sys, op
   endif
 
   if(strcmp(opt,"yd") == 0)
     ## it's a signal name list we're changing
     if(!iscell(names))
       names = {names};
     endif
     if( (!is_signal_list(names)) & (!isempty(names)) )
-      if(isstr(names{1}))
+      if(ischar(names{1}))
         warning("syssetsignals(opt=%s): converting string matrix \"names\" to a cell array of strings",opt);
         tmpstr = names{1};
         for ii=1:rows(tmpstr)
           names{ii} = deblank(tmpstr(ii,:));
         endfor
       else
         names
         error("parameter \"names\" must be a cell array of strings");
diff --git a/scripts/control/system/tfout.m b/scripts/control/system/tfout.m
--- a/scripts/control/system/tfout.m
+++ b/scripts/control/system/tfout.m
@@ -40,17 +40,17 @@ function tfout (num, denom, x)
     endif
 
     if ( (!isvector(num)) | (!isvector(denom)) )
       error("tfout: first two argument must be vectors");
     endif
 
     if (nargin == 2)
       x = "s";
-    elseif( ! isstr(x) )
+    elseif( ! ischar(x) )
       error("tfout: third argument must be a string");
     endif
 
     numstring = polyout(num,x);
     denomstring = polyout(denom,x);
     len = max(length(numstring),length(denomstring));
     if(len > 0)
       y = strrep(blanks(len)," ","-");
diff --git a/scripts/control/system/zpout.m b/scripts/control/system/zpout.m
--- a/scripts/control/system/zpout.m
+++ b/scripts/control/system/zpout.m
@@ -44,17 +44,17 @@ function zpout (zer, pol, k, x)
     endif
 
     if(!isscalar(k))
       error("zpout: argument k must be a scalar.")
     endif
 
     if (nargin == 3)
       x = "s";
-    elseif( ! isstr(x) )
+    elseif( ! ischar(x) )
       error("zpout: third argument must be a string");
     endif
 
     numstring = num2str(k);
 
     if(length(zer))
       ## find roots at z,s = 0
       nzr = sum(zer == 0);
diff --git a/scripts/control/util/prompt.m b/scripts/control/util/prompt.m
--- a/scripts/control/util/prompt.m
+++ b/scripts/control/util/prompt.m
@@ -36,17 +36,17 @@
 ## Modified A. S. Hodel June 1995
 
 function prompt (str)
 
   if (nargin > 1)
     usage ("prompt ([str])");
   elseif (nargin == 0)
     str = "\n ---- Press a key to continue ---";
-  elseif (! isstr (str) )
+  elseif (! ischar (str) )
     error ("prompt: input must be a string");
   endif
 
   disp (str);
   fflush (stdout);
   kbhit ();
 
 endfunction
diff --git a/scripts/control/util/sortcom.m b/scripts/control/util/sortcom.m
--- a/scripts/control/util/sortcom.m
+++ b/scripts/control/util/sortcom.m
@@ -56,17 +56,17 @@ function [yy, idx] = sortcom (xx, opt)
   if( nargin < 1 | nargin > 2 )
      usage("yy = sortcom(xx[,opt]");
   elseif( !(isvector(xx) | isempty(xx) ))
     error("sortcom: first argument must be a vector");
   endif
 
   if(nargin == 1)         opt = "re";
   else
-    if (!isstr(opt))
+    if (!ischar(opt))
       error("sortcom: second argument must be a string");
     endif
   endif
 
   if(isempty(xx))
     yy = idx = [];
   else
     if(strcmp(opt,"re"))        datavec = real(xx);
diff --git a/scripts/control/util/strappend.m b/scripts/control/util/strappend.m
--- a/scripts/control/util/strappend.m
+++ b/scripts/control/util/strappend.m
@@ -23,17 +23,17 @@
 ## @end deftypefn
 
 function retval = strappend (strlist, suffix);
 
   if (nargin != 2 || nargout > 1)
     usage ("retval = strappend (strlist, suffix)");
   elseif (! is_signal_list (strlist))
     error ("strlist must be a list of strings (see is_signal_list)");
-  elseif (! (isstr (suffix) && rows (suffix) == 1))
+  elseif (! (ischar (suffix) && rows (suffix) == 1))
     error ("suffix must be a single string");
   endif
 
   retval = {};
 
   for ii = 1:length (strlist)
     retval{ii} = sprintf ("%s%s", strlist{ii}, suffix);
   endfor
diff --git a/scripts/finance/fv.m b/scripts/finance/fv.m
--- a/scripts/finance/fv.m
+++ b/scripts/finance/fv.m
@@ -54,20 +54,20 @@ function v = fv (r, n, p, l, m)
   if (r != 0)
     v = p * ((1 + r)^n - 1) / r;
   else
     v = p * n;
   endif
 
   if (nargin > 3)
     if (nargin == 5)
-      if (! isstr (m))
+      if (! ischar (m))
         error ("fv: `method' must be a string");
       endif
-    elseif isstr (l)
+    elseif ischar (l)
       m = l;
       l = 0;
     else
       m = "e";
     endif
     if strcmp (m, "b")
       v = v * (1 + r);
     endif
diff --git a/scripts/finance/nper.m b/scripts/finance/nper.m
--- a/scripts/finance/nper.m
+++ b/scripts/finance/nper.m
@@ -48,21 +48,21 @@ function n = nper (r, p, a, l, m)
     error ("nper: r must be a scalar > -1");
   elseif (! isscalar (p))
     error ("nper: p must be a scalar");
   elseif (! isscalar (a))
     error ("nper: a must be a scalar");
   endif
 
   if (nargin == 5)
-    if (! isstr (m))
+    if (! ischar (m))
       error ("nper: `method' must be a string");
     endif
   elseif (nargin == 4)
-    if (isstr (l))
+    if (ischar (l))
       m = l;
       l = 0;
     else
       m = "e";
     endif
   else
     m = "e";
     l = 0;
diff --git a/scripts/finance/pmt.m b/scripts/finance/pmt.m
--- a/scripts/finance/pmt.m
+++ b/scripts/finance/pmt.m
@@ -45,21 +45,21 @@ function p = pmt (r, n, a, l, m)
     error ("pmt: rate must be a scalar > -1");
   elseif (! (isscalar (n) && n > 0))
     error ("pmt: n must be a positive scalar");
   elseif (! (isscalar (a) && a > 0))
     error ("pmt: a must be a positive scalar");
   endif
 
   if (nargin == 5)
-    if (! isstr (m))
+    if (! ischar (m))
       error ("pmt: `method' must be a string");
     endif
   elseif (nargin == 4)
-    if (isstr (l))
+    if (ischar (l))
       m = l;
       l = 0;
     else
       m = "e";
     endif
   else
     l = 0;
     m = "e";
diff --git a/scripts/finance/pv.m b/scripts/finance/pv.m
--- a/scripts/finance/pv.m
+++ b/scripts/finance/pv.m
@@ -55,20 +55,20 @@ function v = pv (r, n, p, l, m)
   if (r != 0)
     v = p * (1 - (1 + r)^(-n)) / r;
   else
     v = p * n;
   endif
 
   if (nargin > 3)
     if (nargin == 5)
-      if (! isstr (m))
+      if (! ischar (m))
         error ("pv: `method' must be a string");
       endif
-    elseif (isstr (l))
+    elseif (ischar (l))
       m = l;
       l = 0;
     else
       m = "e";
     endif
     if (strcmp (m, "b"))
       v = v * (1 + r);
     endif
diff --git a/scripts/finance/rate.m b/scripts/finance/rate.m
--- a/scripts/finance/rate.m
+++ b/scripts/finance/rate.m
@@ -45,21 +45,21 @@ function r = rate (n, p, v, l, m)
     error ("rate: n must be a positive scalar");
   elseif (! isscalar (p))
     error ("rate: p must be a scalar");
   elseif (! isscalar (v))
     error ("rate: p must be a scalar");
   endif
 
   if (nargin == 5)
-    if (! isstr (m))
+    if (! ischar (m))
       error ("rate: `method' must be a string");
     endif
   elseif (nargin == 4)
-    if (isstr (l))
+    if (ischar (l))
       m = l;
       l = 0;
     else
       m = "e";
     endif
   else
     l = 0;
     m = "e";
diff --git a/scripts/general/diff.m b/scripts/general/diff.m
--- a/scripts/general/diff.m
+++ b/scripts/general/diff.m
@@ -80,17 +80,17 @@ function x = diff (x, k, dim)
     endif
   else
     if (! (isscalar (dim) && dim == round (dim)) && dim > 0 && 
 	dim < (nd + 1))
       error ("diff: dim must be an integer and valid dimension");
     endif
   endif
 
-  if (isstr (x))
+  if (ischar (x))
     error ("diff: symbolic differentiation not (yet) supported");
   endif
 
 
   if (nargin == 3)
     if (sz (dim) <= k)
       sz(dim) = 0;
       x = zeros (sz);
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -31,24 +31,24 @@
 ## Author: jwe
 
 function retval = num2str (x, arg)
 
   if (nargin != 1 && nargin != 2)
     usage ("num2str (x) or num2str (x, precision) or num2str (x, fmt)");
   endif
 
-  if (isstr (x))
+  if (ischar (x))
     retval = x;
     return;
   endif
 
   if (iscomplex (x))
     if (nargin == 2)
-      if (isstr (arg))
+      if (ischar (arg))
 	fmt = strcat (arg, "%-+", arg(2:end), "i");
       else
 	if (isnumeric (x) && round (x) == x && abs (x) < (10 .^ arg))
 	  fmt = sprintf ("%%%dd%%-+%ddi  ", arg, arg);
 	else
 	  fmt = sprintf ("%%%d.%dg%%-+%d.%dgi", arg+7, arg, arg+7, arg);
 	endif
       endif
@@ -101,17 +101,17 @@ function retval = num2str (x, arg)
 	tmp = tmp2;
       endif
     endwhile
 
     tmp(length (tmp)) = "";
     retval = split (tmp, "\n");
   else
     if (nargin == 2)
-      if (isstr (arg))
+      if (ischar (arg))
 	fmt = arg;
       else
 	if (isnumeric (x) && round (x) == x && abs (x) < (10 .^ arg))
 	  fmt = sprintf ("%%%dd  ", arg);
 	else
 	  fmt = sprintf ("%%%d.%dg", arg+7, arg);
 	endif
       endif
diff --git a/scripts/general/repmat.m b/scripts/general/repmat.m
--- a/scripts/general/repmat.m
+++ b/scripts/general/repmat.m
@@ -47,33 +47,33 @@ function x = repmat (a, m, n)
       # Ensure that we have a row vector
       idx = m(:).';
     else
       error ("repmat: invalid dimensional argument");
     endif
   endif
 
   if (numel (a) == 1)
-    if (isstr (a))
-      x = setstr (toascii (a) * ones (idx));
+    if (ischar (a))
+      x = char (toascii (a) * ones (idx));
     else
       if (strcmp (class (a), "double"))
 	## This is faster with octave for double/Complex
 	x = a * ones(idx, class(a));
       else
 	cidx = cell (1, length (idx));
 	for i=1:length(idx)
 	  cidx{i} = ones (1,idx(i));
 	endfor
 	x = a (cidx{:});
       endif
     endif
   elseif (ndims (a) == 2 && length (idx) < 3)
-    if (isstr (a))
-      x = setstr (kron (ones (idx), toascii (a)));
+    if (ischar (a))
+      x = char (kron (ones (idx), toascii (a)));
     elseif (strcmp (class(a), "double")) 
       x = kron (ones (idx), a);
     else
       aidx = size(a);
       x = a (kron (ones (1, idx(1)), 1:aidx(1)),  
 	     kron (ones (1, idx(2)), 1:aidx(2)));
     endif
   else
diff --git a/scripts/general/sortrows.m b/scripts/general/sortrows.m
--- a/scripts/general/sortrows.m
+++ b/scripts/general/sortrows.m
@@ -30,17 +30,17 @@
 function [s, i] = sortrows (m, c)
   
   if (nargin < 2)
     indices = [1:size(m,2)]';
   else
     indices = c(:);
   endif
 
-  if (isstr (m))
+  if (ischar (m))
     s = toascii (m);
   else
     s = m;
   endif
 
   ## Since sort is 'stable' the order of identical elements will be
   ## preserved, so by traversing the sort indices in reverse order we
   ## will make sure that identical elements in index i are subsorted by
@@ -48,13 +48,13 @@ function [s, i] = sortrows (m, c)
   indices = flipud (indices);
   i = [1:size(m,1)]';
   for ii = 1:length (indices);
     [trash, idx] = sort (s(:,indices(ii)));
     s = s(idx,:);
     i = i(idx);
   endfor
 
-  if (isstr (m))
-    s = setstr (s);
+  if (ischar (m))
+    s = char (s);
   endif
 
 endfunction
diff --git a/scripts/general/strerror.m b/scripts/general/strerror.m
--- a/scripts/general/strerror.m
+++ b/scripts/general/strerror.m
@@ -28,17 +28,17 @@
 ## Author: jwe
 
 function msg = strerror (name, err)
 
   if (nargin != 2)
     usage ("strerror (name, err)");
   endif
 
-  if (! isstr (name))
+  if (! ischar (name))
     error ("strerror: first argument must be a string");
   endif
 
   if (! isscalar (err))
     error ("strerror: second argument must be a scalar");
   endif
 
   if (strcmp (name, "fsolve"))
diff --git a/scripts/image/colormap.m b/scripts/image/colormap.m
--- a/scripts/image/colormap.m
+++ b/scripts/image/colormap.m
@@ -42,17 +42,17 @@ function cmap = colormap (map)
   global __current_color_map__ = gray ();
 
   if (nargin > 1)
     usage ("colormap (map)");
   endif
 
   if (nargin == 1)
 
-    if (isstr (map))
+    if (ischar (map))
       if (strcmp (map, "default"))
         map = gray ();
       else
         map = eval (map);
       endif
     endif
 
     if (! isempty (map))
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -148,17 +148,17 @@ function imshow (varargin)
   else
     I = I+1; ## index into colourmap
     M = gray (2^imdepth);
   endif
   
   ## Check for "truesize".
   zoom = [];
   for i = mvars+1:nargin
-    if (isstr (varargin{i}) && strcmp (varargin{i}, "truesize"))
+    if (ischar (varargin{i}) && strcmp (varargin{i}, "truesize"))
       zoom = 1;
     endif
   endfor
 
   colormap (M);
   image (I, zoom);
 
 endfunction
diff --git a/scripts/image/loadimage.m b/scripts/image/loadimage.m
--- a/scripts/image/loadimage.m
+++ b/scripts/image/loadimage.m
@@ -28,17 +28,17 @@
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [img_retval, map_retval] = loadimage (filename)
 
   if (nargin != 1)
     usage ("[img, map] = loadimage (filename)");
-  elseif (! isstr (filename))
+  elseif (! ischar (filename))
     error ("loadimage: expecting filename as a string");
   endif
 
   file = file_in_path (IMAGEPATH, filename);
 
   if (isempty (file))
     error ("loadimage: unable to find image file");
   endif
diff --git a/scripts/image/saveimage.m b/scripts/image/saveimage.m
--- a/scripts/image/saveimage.m
+++ b/scripts/image/saveimage.m
@@ -88,29 +88,29 @@ function saveimage (filename, img, img_f
   [map_nr, map_nc] = size (map);
 
   if (map_nc != 3)
     error ("colormap should be an N x 3 matrix");
   endif
 
   if (nargin < 3)
     img_form = "img";
-  elseif (! isstr (img_form))
+  elseif (! ischar (img_form))
     error ("image format specification must be a string");
   elseif (! (strcmp (img_form, "img")
              || strcmp (img_form, "ppm")
              || strcmp (img_form, "ps")))
     error ("unsupported image format specification");
   endif
 
   if (! ismatrix (img))
     warning ("image variable is not a matrix");
   endif
 
-  if (! isstr (filename))
+  if (! ischar (filename))
     error ("file name must be a string");
   endif
 
   ## If we just want Octave image format, save and return.
 
   if (strcmp (img_form, "img"))
     eval (strcat ("save -ascii ", filename, " map img"));
     return;
diff --git a/scripts/linear-algebra/norm.m b/scripts/linear-algebra/norm.m
--- a/scripts/linear-algebra/norm.m
+++ b/scripts/linear-algebra/norm.m
@@ -73,17 +73,17 @@ function retval = norm (x, p)
     error ("norm: Only valid on 2-D objects")
   endif
 
   ## Do we have a vector or matrix as the first argument?
 
   if (rows (x) == 1 || columns (x) == 1)
 
     if (nargin == 2)
-      if (isstr (p))
+      if (ischar (p))
         if (strcmp (p, "fro"))
 	  retval = sqrt (sum (abs (x) .^ 2));
         elseif (strcmp (p, "inf"))
           retval = max (abs (x));
         else
           error ("norm: unrecognized norm");
         endif
       else
@@ -97,17 +97,17 @@ function retval = norm (x, p)
       endif
     elseif (nargin == 1)
       retval = sqrt (sum (abs (x) .^ 2));
     endif
 
   else
 
     if (nargin == 2)
-      if (isstr (p))
+      if (ischar (p))
         if (strcmp (p, "fro"))
 	  retval = sqrt (sum (sum (abs (x) .^ 2)));
         elseif (strcmp (p, "inf"))
           retval = max (sum (abs (x')));
         else
           error ("norm: unrecognized norm");
         endif
       else
diff --git a/scripts/miscellaneous/fileparts.m b/scripts/miscellaneous/fileparts.m
--- a/scripts/miscellaneous/fileparts.m
+++ b/scripts/miscellaneous/fileparts.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {[@var{dir}, @var{name}, @var{ext}, @var{ver}] =} fileparts (@var{filename})
 ## Return the directory, name, extension, and version components of
 ## @var{filename}.
 ## @end deftypefn
 
 function [directory, name, extension, version] = fileparts (filename)
 
   if (nargin == 1)
-    if (isstr (filename))
+    if (ischar (filename))
       ds = rindex (filename, filesep);
       es = rindex (filename, ".");
       ## These can be the same if they are both 0 (no dir or ext).
       if (es <= ds)
 	es = length(filename)+1;
       endif
       directory = filename(1:ds-1);
       name = filename(ds+1:es-1);
diff --git a/scripts/miscellaneous/popen2.m b/scripts/miscellaneous/popen2.m
--- a/scripts/miscellaneous/popen2.m
+++ b/scripts/miscellaneous/popen2.m
@@ -29,17 +29,17 @@
 ##
 ## For example,
 ##
 ## @example
 ## @group
 ## [in, out, pid] = popen2 ("sort", "-nr");
 ## fputs (in, "these\nare\nsome\nstrings\n");
 ## fclose (in);
-## while (isstr (s = fgets (out)))
+## while (ischar (s = fgets (out)))
 ##   fputs (stdout, s);
 ## endwhile
 ## fclose (out);
 ##      @print{} are
 ##      @print{} some
 ##      @print{} strings
 ##      @print{} these
 ## @end group
@@ -55,17 +55,17 @@ function [in, out, pid] = popen2 (comman
   pid = -1;
 
   if (nargin == 1 || nargin == 2)
 
     if (nargin == 1)
       args = "";
     endif
 
-    if (isstr (command))
+    if (ischar (command))
 
       [stdin_pipe, stdin_status] = pipe ();
       [stdout_pipe, stdout_status] = pipe ();
 
       if (stdin_status == 0 && stdout_status == 0)
 
         pid = fork ();
 
diff --git a/scripts/plot/__axis_label__.m b/scripts/plot/__axis_label__.m
--- a/scripts/plot/__axis_label__.m
+++ b/scripts/plot/__axis_label__.m
@@ -24,17 +24,17 @@
 
 ## Author: jwe
 
 function h = __axis_label__ (caller, text)
 
   if (nargin == 0)
     usage ("__axis_label__ (caller, text)");
   elseif (nargin == 2)
-    if (isstr (text))
+    if (ischar (text))
       __gnuplot_raw__ (sprintf ("set %s \"%s\";\n", caller,
 				undo_string_escapes (text)));
       if (automatic_replot)
 	## No semicolon (see replot.m).
 	__gnuplot_replot__
       endif
     else
       error ("%s: text must be a string", caller);
diff --git a/scripts/plot/__errcomm__.m b/scripts/plot/__errcomm__.m
--- a/scripts/plot/__errcomm__.m
+++ b/scripts/plot/__errcomm__.m
@@ -54,17 +54,17 @@ function __errcomm__ (caller, varargin)
       else
         usage ("%s (...)", caller);
       endif
       sz = size (a);
       ndata = 1;
       data{ndata} = a;
       while (k <= nargs)
 	a = varargin{k++};
-	if (isstr (a))
+	if (ischar (a))
 	  __errplot__ (a, data{1:ndata});
 	  break;
 	elseif (isvector (a))
 	  a = a(:);
 	elseif (ismatrix (a))
 	  ;
 	else
 	  error ("wrong argument types");
@@ -74,17 +74,17 @@ function __errcomm__ (caller, varargin)
 	endif
 	data{++ndata} = a;
 	if (ndata > 6)
 	  error ("too many arguments to a plot");
 	endif
       endwhile
     endwhile
 
-    if (! isstr (a))
+    if (! ischar (a))
       __errplot__ ("~", data{1:ndata});
     endif
   unwind_protect_cleanup
     if (! save_hold)
       hold off;
     endif
   end_unwind_protect
 
diff --git a/scripts/plot/__plt1__.m b/scripts/plot/__plt1__.m
--- a/scripts/plot/__plt1__.m
+++ b/scripts/plot/__plt1__.m
@@ -28,17 +28,17 @@ function [data, fmtstr] = __plt1__ (x1, 
   if (nargin < 1 || nargin > 2 || nargout != 2)
     usage ("[data, fmtstr] = __plt1__ (x1, fmt)");
   endif
 
   if (nargin == 1)
     fmt = "";
   endif
 
-  if (! isstr (fmt))
+  if (! ischar (fmt))
     error ("__plt1__: fmt must be a string");
   endif
 
   [nr, nc] = size (x1);
   if (nr == 1)
     x1 = x1.';
     tmp = nr;
     nr = nc;
diff --git a/scripts/plot/__plt2__.m b/scripts/plot/__plt2__.m
--- a/scripts/plot/__plt2__.m
+++ b/scripts/plot/__plt2__.m
@@ -28,17 +28,17 @@ function [data, fmtstr] = __plt2__ (x1, 
   if (nargin < 2 || nargin > 3 || nargout != 2)
     usage ("[data, fmtstr] = __plt2__ (x1, x2, fmt)");
   endif
 
   if (nargin == 2)
     fmt = "";
   endif
 
-  if (! isstr (fmt))
+  if (! ischar (fmt))
     error ("__plt2__: fmt must be a string");
   endif
 
   if (any (any (imag (x1))))
     x1 = real (x1);
   endif
 
   if (any (any (imag (x2))))
diff --git a/scripts/plot/__plt__.m b/scripts/plot/__plt__.m
--- a/scripts/plot/__plt__.m
+++ b/scripts/plot/__plt__.m
@@ -45,17 +45,17 @@ function __plt__ (caller, varargin)
 	## Force the last plot when input variables run out.
 	next_arg = "";
       else
 	next_arg = varargin{k++};
       endif
 
       have_data = false;
 
-      if (isstr (next_arg))
+      if (ischar (next_arg))
 	if (x_set)
 	  fmt = __pltopt__ (caller, next_arg);
 	  if (y_set)
 	    [__plot_data__{__current_figure__}{j}, fmtstr] = __plt2__ (x, y, fmt);
 	  else
 	    [__plot_data__{__current_figure__}{j}, fmtstr] = __plt1__ (x, fmt);
 	  endif
 	  have_data = true;
diff --git a/scripts/plot/__pltopt1__.m b/scripts/plot/__pltopt1__.m
--- a/scripts/plot/__pltopt1__.m
+++ b/scripts/plot/__pltopt1__.m
@@ -60,17 +60,17 @@ function fmt = __pltopt1__ (caller, opt)
   XERRORBARS = "xerr";
   XYERRORBARS = "xyerr";
   TITLE = "title";
 
   if (nargin != 2)
     usage ("__pltopt1__ (caller, opt)");
   endif
 
-  if (! isstr (opt))
+  if (! ischar (opt))
     error ("__pltopt1__: argument must be a string");
   endif
 
   while (more_opts)
 
     ## First get next char.
 
     if (max (size (opt)) > 1)
diff --git a/scripts/plot/__pltopt__.m b/scripts/plot/__pltopt__.m
--- a/scripts/plot/__pltopt__.m
+++ b/scripts/plot/__pltopt__.m
@@ -106,17 +106,17 @@
 ## @end deftypefn
 ##
 ## @seealso{__pltopt1__}
 
 ## Author: jwe
 
 function fmt = __pltopt__ (caller, opt)
 
-  if (! isstr (opt))
+  if (! ischar (opt))
     usage ("__pltopt__ (caller, opt)");
   endif
 
   nr = rows (opt);
   fmt = "";
   for i = 1:nr
     t = __pltopt1__ (caller, deblank (opt(i,:)));
     fmt(i,1:length(t)) = t;
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -129,17 +129,17 @@ function curr_axis = axis (ax, varargin)
 
   if (nargin == 0)
     if (nargout == 0)
       __gnuplot_raw__ ("set autoscale;\n");
     else
       curr_axis = __current_axis__;
     endif
 
-  elseif (isstr (ax))
+  elseif (ischar (ax))
     ax = tolower (ax);
     len = length (ax);
 
     ## 'matrix mode' to reverse the y-axis
     if (strcmp (ax, "ij"))
       __gnuplot_raw__ ("set yrange [] reverse;\n"); 
     elseif (strcmp (ax, "xy"))
       __gnuplot_raw__ ("set yrange [] noreverse;\n");
diff --git a/scripts/plot/bottom_title.m b/scripts/plot/bottom_title.m
--- a/scripts/plot/bottom_title.m
+++ b/scripts/plot/bottom_title.m
@@ -26,17 +26,17 @@
 ## Adapted-By: jwe
 
 function bottom_title (text)
 
   if (nargin != 1)
     usage ("bottom_title (text)");
   endif
 
-  if (isstr (text))
+  if (ischar (text))
     __gnuplot_raw__ ("set top_title;\n");
     __gnuplot_raw__ ("set title;\n");
     __gnuplot_raw__ (sprintf ("set bottom_title \"%s\";\n",
 			      undo_string_escapes (text)));
   else
     error ("bottom_title: text must be a string");
   endif
 
diff --git a/scripts/plot/close.m b/scripts/plot/close.m
--- a/scripts/plot/close.m
+++ b/scripts/plot/close.m
@@ -35,34 +35,34 @@ function retval = close (arg1, arg2)
 
   if (nargin == 0)
     if (! warned_all)
       warned_all = true;
       warning ("close: unable to close only current plot window");
     endif
     closeplot;
   elseif (nargin == 1)
-    if (isstr (arg1))
+    if (ischar (arg1))
       if (strcmp (arg1, "all"))
 	closeplot;
       else
 	if (! warned_name)
 	  warned_name = true;
 	  warning ("close: unable to close plot windows by name");
 	endif
       endif
     else
       if (! warned_handle)
 	warned_handle = true;
 	warning ("close: unable to close plot windows by handle");
       endif
     endif
   elseif (nargin == 2
-	  && isstr (arg1) && strcmp (arg1, "all")
-	  && isstr (arg2) && strcmp (arg2, "hidden"))
+	  && ischar (arg1) && strcmp (arg1, "all")
+	  && ischar (arg2) && strcmp (arg2, "hidden"))
     closeplot;
   else
     usage ("close [all]");
   endif
 
   if (nargout > 0)
     retval = 1;
   endif
diff --git a/scripts/plot/grid.m b/scripts/plot/grid.m
--- a/scripts/plot/grid.m
+++ b/scripts/plot/grid.m
@@ -36,17 +36,17 @@ function grid (x)
   usage_msg = "grid (\"on\" | \"off\")";
 
   do_replot = false;
 
   if (nargin == 0)
     __gnuplot_raw__ ("set grid;\n");
     do_replot = true;
   elseif (nargin == 1)
-    if (isstr (x))
+    if (ischar (x))
       if (strcmp ("off", x))
         __gnuplot_raw__ ("set nogrid;\n");
 	do_replot = true;
       elseif (strcmp ("on", x))
         __gnuplot_raw__ ("set grid");
 	do_replot = true;
       else
 	usage (usage_msg);
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -45,17 +45,17 @@
 ## Author: jwe
 
 function [nn, xx] = hist (y, x, norm)
 
   if (nargin < 1 || nargin > 3)
     usage ("[nn, xx] = hist (y, x, norm)");
   endif
 
-  arg_is_vector = is_vector (y);
+  arg_is_vector = isvector (y);
 
   if (rows (y) == 1)
     y = y(:);
   endif
 
   if (isreal (y))
     max_val = max (y);
     min_val = min (y);
diff --git a/scripts/plot/plot_border.m b/scripts/plot/plot_border.m
--- a/scripts/plot/plot_border.m
+++ b/scripts/plot/plot_border.m
@@ -63,17 +63,17 @@ function plot_border (varargin)
   k = 1;
 
   nargs = nargin ();
 
   while (nargs--)
 
     arg = varargin{k++};
 
-    if (! isstr (arg))
+    if (! ischar (arg))
       error ("plot_border: input not a string");
     endif
 
     ## The effect of the arguments in cumulative.  If something is found
     ## after "b", do that and ignore "b".
 
     if (strcmp (arg, "blank") || strcmp (arg, "BLANK")
         || strcmp (arg, "b") || strcmp (arg, "B"))
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -35,22 +35,22 @@ function polar (x1, x2, fmt)
   ## XXX FIXME XXX -- these plot states should really just be set
   ## temporarily, probably inside an unwind_protect block, but there is
   ## no way to determine their current values.
 
   __gnuplot_raw__ ("set nologscale;\n");
   __gnuplot_raw__ ("set nopolar;\n");
 
   if (nargin == 3)
-    if (! isstr (fmt))
+    if (! ischar (fmt))
       error ("polar: third argument must be a string");
     endif
     __plr2__ (x1, x2, fmt);
   elseif (nargin == 2)
-    if (isstr (x2))
+    if (ischar (x2))
       __plr1__ (x1, x2);
     else
       fmt = "";
       __plr2__ (x1, x2, fmt);
     endif
   elseif (nargin == 1)
     fmt = "";
     __plr1__ (x1, fmt);
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -105,17 +105,17 @@ function print (varargin)
   fontsize = "";
   font = "";
   name = "";
   devopt = "";
   printer = "";
 
   for i = 1:nargin
     arg = varargin{i};
-    if (isstr (arg))
+    if (ischar (arg))
       if (strcmp (arg, "-color"))
 	use_color = 1;
       elseif (strcmp (arg, "-mono"))
 	use_color = -1;
       elseif (strcmp (arg, "-solid"))
         force_solid = 1;
       elseif (strcmp (arg, "-dashed"))
         force_solid = -1;
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -28,17 +28,17 @@
 ## Author: jwe
 
 function h = title (text)
 
   if (nargin != 1)
     usage ("title (text)");
   endif
 
-  if (isstr (text))
+  if (ischar (text))
     __gnuplot_raw__ (sprintf ("set title \"%s\";\n",
 			      undo_string_escapes (text)));
     if (automatic_replot)
       ## No semicolon (see replot.m).
       __gnuplot_replot__
     endif
   else
     error ("title: text must be a string");
diff --git a/scripts/plot/top_title.m b/scripts/plot/top_title.m
--- a/scripts/plot/top_title.m
+++ b/scripts/plot/top_title.m
@@ -28,17 +28,17 @@
 ## Adapted-By: jwe
 
 function top_title (text)
 
   if (nargin != 1)
     usage ("top_title (text)");
   endif
 
-  if (isstr (text))
+  if (ischar (text))
     __gnuplot_raw__ ("set bottom_title;\n")
     __gnuplot_raw__ ("set title;\n")
     __gnuplot_raw__ (sprintf ("set top_title \"%s\";\n",
 			      undo_string_escapes (text)));
     if (automatic_replot)
       ## No semicolon (see replot.m).
       __gnuplot_replot__
     endif
diff --git a/scripts/polynomial/polyout.m b/scripts/polynomial/polyout.m
--- a/scripts/polynomial/polyout.m
+++ b/scripts/polynomial/polyout.m
@@ -49,17 +49,17 @@ function y = polyout (c, x)
   endif
 
   if (! isvector (c))
     error("polyout: first argument must be a vector");
   endif
 
   if (nargin == 1)
     x = "s";
-  elseif (! isstr(x))
+  elseif (! ischar(x))
     error("polyout: second argument must be a string");
   endif
 
   n = length(c);
   if(n > 0)
     n1 = n+1;
 
 
diff --git a/scripts/set/unique.m b/scripts/set/unique.m
--- a/scripts/set/unique.m
+++ b/scripts/set/unique.m
@@ -50,17 +50,17 @@ function [y, i, j] = unique (x, r)
   if (n < 1)
     i = j = [];
     return;
   elseif (n < 2)
     i = j = 1;
     return;
   endif
 
-  if (isstr (x))
+  if (ischar (x))
     y = toascii (y);
   endif
 
   if (nargin == 2)
     [y, i] = sortrows (y);
     if (iscell (y))
       match = cellfun ("size", y(1:n-1,:), 1) == cellfun ("size", y(2:n,:), 1);
       idx = find (match);
@@ -90,18 +90,18 @@ function [y, i, j] = unique (x, r)
   ## I don't know why anyone would need reverse indices, but it
   ## was an interesting challenge.  I welcome cleaner solutions.
   if (nargout >= 3)
     j = i;
     j(i) = cumsum (prepad (! match, n, 1));
   endif
   i(idx) = [];
 
-  if (isstr (x))
-    y = setstr (y);
+  if (ischar (x))
+    y = char (y);
   endif
 
 endfunction
 
 %!assert(unique([1 1 2; 1 2 1; 1 1 2]),[1;2])
 %!assert(unique([1 1 2; 1 0 1; 1 1 2],'rows'),[1 0 1; 1 1 2])
 %!assert(unique([]),[])
 %!assert(unique([1]),[1])
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -79,17 +79,17 @@ function [h_r, f_r] = freqz (b, a, n, re
     a = n = region = Fs = [];
   elseif (nargin == 2)
     ## Response of an IIR filter
     n = region = Fs = [];
   elseif (nargin == 3)
     region = Fs = [];
   elseif (nargin == 4)
     Fs = [];
-    if (! isstr (region) && ! isempty (region))
+    if (! ischar (region) && ! isempty (region))
       Fs = region; 
       region = [];
     endif
   endif
 
   if (isempty (b))
     b = 1;
   endif
diff --git a/scripts/signal/stft.m b/scripts/signal/stft.m
--- a/scripts/signal/stft.m
+++ b/scripts/signal/stft.m
@@ -64,17 +64,17 @@ function [Y, c] = stft(X, win, inc, coef
       if (nargin < 3)
         inc = 24;
         if (nargin < 2)
           win = 80;
         endif
       endif
     endif
   elseif (nargin == 5)
-    if (isstr (w_type))
+    if (ischar (w_type))
       if (strcmp (w_type, "hanning"))
         w_type = 1;
       elseif (strcmp (w_type, "hamming"))
         w_type = 2;
       elseif (strcmp (w_type, "rectangle"))
         w_type = 3;
       else
         error ("stft: unknown window type `%s'", w_type);
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/base/mean.m
--- a/scripts/statistics/base/mean.m
+++ b/scripts/statistics/base/mean.m
@@ -61,28 +61,28 @@
 function y = mean (x, opt1, opt2)
 
   need_dim = 0;
 
   if (nargin == 1)
     opt = "a";
     need_dim = 1;
   elseif (nargin == 2)
-    if (isstr (opt1))
+    if (ischar (opt1))
       opt = opt1;
       need_dim = 1;
     else
       dim = opt1;
       opt = "a";
     endif
   elseif (nargin == 3)
-    if (isstr (opt1))
+    if (ischar (opt1))
       opt = opt1;
       dim = opt2;
-    elseif (isstr (opt2))
+    elseif (ischar (opt2))
       opt = opt2;
       dim = opt1;
     else
       usage ("mean: expecting opt to be a string");
     endif
   else
     usage ("mean (x, dim, opt) or mean (x, dim, opt)");
   endif
diff --git a/scripts/statistics/base/moment.m b/scripts/statistics/base/moment.m
--- a/scripts/statistics/base/moment.m
+++ b/scripts/statistics/base/moment.m
@@ -52,28 +52,28 @@ function m = moment (x, p, opt1, opt2)
   endif
 
   need_dim = 0;
 
   if (nargin == 2)
     opt = "";
     need_dim = 1;
   elseif (nargin == 3)
-    if (isstr (opt1))
+    if (ischar (opt1))
       opt = opt1;
       need_dim = 1;
     else
       dim = opt1;
       opt = "";
     endif
   elseif (nargin == 4)
-    if (isstr (opt1))
+    if (ischar (opt1))
       opt = opt1;
       dim = opt2;
-    elseif (isstr (opt2))
+    elseif (ischar (opt2))
       opt = opt2;
       dim = opt1;
     else
       usage ("moment: expecting opt to be a string");
     endif
   else
     usage ("moment (x, p, dim, opt) or moment (x, p, dim, opt)");
   endif
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
--- a/scripts/statistics/tests/cor_test.m
+++ b/scripts/statistics/tests/cor_test.m
@@ -68,23 +68,23 @@ function t = cor_test (X, Y, ALTERNATIVE
   endif
 
   if (!isvector (X) || !isvector (Y) || length (X) != length (Y))
     error ("cor_test: X and Y must be vectors of the same length")
   endif
 
   if (nargin < 3)
     ALTERNATIVE = "!=";
-  elseif (! isstr (ALTERNATIVE))
+  elseif (! ischar (ALTERNATIVE))
     error ("cor_test: ALTERNATIVE must be a string");
   endif
 
   if (nargin < 4)
     METHOD = "pearson";
-  elseif (! isstr (METHOD))
+  elseif (! ischar (METHOD))
     error ("cor_test: METHOD must be a string");
   endif
 
   n = length (X);
   m = METHOD (1);
 
   if (m == "p")
     r = cor (X, Y);
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test.m b/scripts/statistics/tests/kolmogorov_smirnov_test.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test.m
@@ -67,17 +67,17 @@ function [pval, ks] = kolmogorov_smirnov
   alt  = "!=";
 
   if (nargin == 2)
     z = reshape (feval (f, s), 1, n);
   else
     args = "";
     for k = 1 : (nargin-2);
       tmp  = varargin{k};
-      if isstr (tmp)
+      if ischar (tmp)
         alt = tmp;
       else
         args = sprintf ("%s, %g", args, tmp);
       endif
     endfor
     z = reshape (eval (sprintf ("%s(s%s);", func2str (f), args)), 1, n);
   endif
 
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
@@ -54,17 +54,17 @@ function [pval, ks, d] = kolmogorov_smir
 
   if (! (isvector (x) && isvector (y)))
     error ("kolmogorov_smirnov_test_2: both x and y must be vectors");
   endif
 
   if (nargin == 2)
     alt = "!=";
   else
-    if (! isstr (alt))
+    if (! ischar (alt))
       error ("kolmogorov_smirnov_test_2: alt must be a string");
     endif
   endif
 
   n_x = length (x);
   n_y = length (y);
   n   = n_x * n_y / (n_x + n_y);
   x   = reshape (x, n_x, 1);
diff --git a/scripts/statistics/tests/prop_test_2.m b/scripts/statistics/tests/prop_test_2.m
--- a/scripts/statistics/tests/prop_test_2.m
+++ b/scripts/statistics/tests/prop_test_2.m
@@ -56,17 +56,17 @@ function [pval, z] = prop_test_2 (x1, n1
   z   = (p1 - p2) / sqrt (pc * (1 - pc) * (1/n1 + 1/n2));
 
   cdf = stdnormal_cdf (z);
 
   if (nargin == 4)
     alt  = "!=";
   endif
 
-  if (! isstr (alt))
+  if (! ischar (alt))
     error ("prop_test_2: alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif strcmp (alt, ">")
     pval = 1 - cdf;
   elseif strcmp (alt, "<")
     pval = cdf;
diff --git a/scripts/statistics/tests/sign_test.m b/scripts/statistics/tests/sign_test.m
--- a/scripts/statistics/tests/sign_test.m
+++ b/scripts/statistics/tests/sign_test.m
@@ -59,17 +59,17 @@ function [pval, b, n] = sign_test (x, y,
   n   = sum (x != y);
   b   = sum (x > y);
   cdf = binomial_cdf (b, n, 1/2);
 
   if (nargin == 2)
     alt  = "!=";
   endif
 
-  if (! isstr (alt))
+  if (! ischar (alt))
     error ("sign_test: alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif strcmp (alt, ">")
     pval = 1 - cdf;
   elseif strcmp (alt, "<")
     pval = cdf;
diff --git a/scripts/statistics/tests/t_test.m b/scripts/statistics/tests/t_test.m
--- a/scripts/statistics/tests/t_test.m
+++ b/scripts/statistics/tests/t_test.m
@@ -59,17 +59,17 @@ function [pval, t, df] = t_test (x, m, a
   df  = n - 1;
   t   = sqrt (n) * (sum (x) / n - m) / std (x);
   cdf = t_cdf (t, df);
 
   if (nargin == 2)
     alt  = "!=";
   endif
 
-  if (! isstr (alt))
+  if (! ischar (alt))
     error ("t_test: alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif strcmp (alt, ">")
     pval = 1 - cdf;
   elseif strcmp (alt, "<")
     pval = cdf;
diff --git a/scripts/statistics/tests/t_test_2.m b/scripts/statistics/tests/t_test_2.m
--- a/scripts/statistics/tests/t_test_2.m
+++ b/scripts/statistics/tests/t_test_2.m
@@ -60,17 +60,17 @@ function [pval, t, df] = t_test_2 (x, y,
   v    = sumsq (x - mu_x) + sumsq (y - mu_y);
   t    = (mu_x - mu_y) * sqrt ((n_x * n_y * df) / (v * (n_x + n_y)));
   cdf  = t_cdf (t, df);
 
   if (nargin == 2)
     alt = "!=";
   endif
 
-  if (! isstr (alt))
+  if (! ischar (alt))
     error ("t_test_2: alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif strcmp (alt, ">")
     pval = 1 - cdf;
   elseif strcmp (alt, "<")
     pval = cdf;
diff --git a/scripts/statistics/tests/t_test_regression.m b/scripts/statistics/tests/t_test_regression.m
--- a/scripts/statistics/tests/t_test_regression.m
+++ b/scripts/statistics/tests/t_test_regression.m
@@ -43,29 +43,29 @@
 ## Description: Test one linear hypothesis in linear regression model
 
 function [pval, t, df] = t_test_regression (y, X, R, r, alt)
 
   if (nargin == 3)
     r   = 0;
     alt = "!=";
   elseif (nargin == 4)
-    if (isstr (r))
+    if (ischar (r))
       alt = r;
       r   = 0;
     else
       alt = "!=";
     endif
   elseif (! (nargin == 5))
     usage ("[pval, t, df] = t_test_regression (y, X, R, r, alt)");
   endif
 
   if (! isscalar (r))
     error ("t_test_regression: r must be a scalar");
-  elseif (! isstr (alt))
+  elseif (! ischar (alt))
     error ("t_test_regression: alt must be a string");
   endif
 
   [T, k] = size (X);
   if (! (isvector (y) && (length (y) == T)))
     error ("t_test_regression: y must be a vector of length rows (X)");
   endif
   s      = size (R);
diff --git a/scripts/statistics/tests/u_test.m b/scripts/statistics/tests/u_test.m
--- a/scripts/statistics/tests/u_test.m
+++ b/scripts/statistics/tests/u_test.m
@@ -61,17 +61,17 @@ function [pval, z] = u_test (x, y, alt)
            / sqrt (n_x * n_y * (n_x + n_y + 1) / 12);
 
   cdf  = stdnormal_cdf (z);
 
   if (nargin == 2)
     alt  = "!=";
   endif
 
-  if (! isstr (alt))
+  if (! ischar (alt))
     error("u_test: alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = cdf;
   elseif (strcmp (alt, "<"))
     pval = 1 - cdf;
diff --git a/scripts/statistics/tests/var_test.m b/scripts/statistics/tests/var_test.m
--- a/scripts/statistics/tests/var_test.m
+++ b/scripts/statistics/tests/var_test.m
@@ -55,17 +55,17 @@ function [pval, f, df_num, df_den] = var
   df_den = length (y) - 1;
   f      = var (x) / var (y);
   cdf    = f_cdf (f, df_num, df_den);
 
   if (nargin == 2)
     alt  = "!=";
   endif
 
-  if (! isstr (alt))
+  if (! ischar (alt))
     error ("var_test: alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
diff --git a/scripts/statistics/tests/welch_test.m b/scripts/statistics/tests/welch_test.m
--- a/scripts/statistics/tests/welch_test.m
+++ b/scripts/statistics/tests/welch_test.m
@@ -61,17 +61,17 @@ function [pval, t, df] = welch_test (x, 
   df   = 1 / (c^2 / (n_x - 1) + (1 - c)^2 / (n_y - 1));
   t    = (mu_x - mu_y) / sqrt (v_x + v_y);
   cdf  = t_cdf (t, df);
 
   if (nargin == 2)
     alt  = "!=";
   endif
 
-  if (! isstr (alt))
+  if (! ischar (alt))
     error ("welch_test: alt must be a string");
   endif
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
diff --git a/scripts/statistics/tests/wilcoxon_test.m b/scripts/statistics/tests/wilcoxon_test.m
--- a/scripts/statistics/tests/wilcoxon_test.m
+++ b/scripts/statistics/tests/wilcoxon_test.m
@@ -65,17 +65,17 @@ function [pval, z] = wilcoxon_test (x, y
   endif
 
   cdf = stdnormal_cdf (z);
 
   if (nargin == 2)
     alt = "!=";
   endif
 
-  if (! isstr (alt))
+  if (! ischar (alt))
     error("wilcoxon_test: alt must be a string");
   elseif (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
diff --git a/scripts/statistics/tests/z_test.m b/scripts/statistics/tests/z_test.m
--- a/scripts/statistics/tests/z_test.m
+++ b/scripts/statistics/tests/z_test.m
@@ -61,17 +61,17 @@ function [pval, z] = z_test (x, m, v, al
   n = length (x);
   z = sqrt (n/v) * (sum (x) / n - m);
   cdf = stdnormal_cdf (z);
 
   if (nargin == 3)
     alt = "!=";
   endif
 
-  if (! isstr (alt))
+  if (! ischar (alt))
     error ("z_test: alt must be a string");
   elseif (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
diff --git a/scripts/statistics/tests/z_test_2.m b/scripts/statistics/tests/z_test_2.m
--- a/scripts/statistics/tests/z_test_2.m
+++ b/scripts/statistics/tests/z_test_2.m
@@ -61,17 +61,17 @@ function [pval, z] = z_test_2 (x, y, v_x
   mu_y = sum (y) / n_y;
   z    = (mu_x - mu_y) / sqrt (v_x / n_x + v_y / n_y);
   cdf  = stdnormal_cdf (z);
 
   if (nargin == 4)
     alt = "!=";
   endif
 
-  if (! isstr (alt))
+  if (! ischar (alt))
     error ("z_test_2: alt must be a string");
   elseif (strcmp (alt, "!=") || strcmp (alt, "<>"))
     pval = 2 * min (cdf, 1 - cdf);
   elseif (strcmp (alt, ">"))
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
diff --git a/scripts/strings/base2dec.m b/scripts/strings/base2dec.m
--- a/scripts/strings/base2dec.m
+++ b/scripts/strings/base2dec.m
@@ -50,17 +50,17 @@
 
 function out = base2dec (d, base)
 
   if (nargin != 2)
     usage ("n = base2dec('d', base)");
   endif
 
   symbols = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
-  if (isstr (base))
+  if (ischar (base))
     symbols = base;
     base = length (symbols);
     if (any (diff (sort (toascii (symbols))) == 0))
       error ("base2dec: symbols representing digits must be unique.");
     endif
   elseif (! isscalar (base))
     error ("base2dec: cannot convert from several bases at once.");
   elseif (base < 2 || base > length (symbols))
diff --git a/scripts/strings/blanks.m b/scripts/strings/blanks.m
--- a/scripts/strings/blanks.m
+++ b/scripts/strings/blanks.m
@@ -27,14 +27,14 @@
 
 function s = blanks (n)
 
   if (nargin != 1)
     usage ("blanks (n)");
   endif
 
   if (isscalar (n) && n == round (n))
-    s = setstr (ones (1, n) * toascii (" "));
+    s = char (ones (1, n) * toascii (" "));
   else
     error ("blanks: n must be a non-negative integer");
   endif
 
 endfunction
diff --git a/scripts/strings/deblank.m b/scripts/strings/deblank.m
--- a/scripts/strings/deblank.m
+++ b/scripts/strings/deblank.m
@@ -28,17 +28,17 @@
 ## Adapted-By: jwe
 
 function t = deblank (s)
 
   if (nargin != 1)
     usage ("deblank (s)");
   endif
 
-  if (isstr (s))
+  if (ischar (s))
 
     k = find (! isspace (s) & s != "\0");
     if (isempty (s) || isempty (k))
       t = "";
     else
       t = s(:,1:ceil (max (k) / rows (s)));
     endif
 
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -56,17 +56,17 @@ function retval = dec2base (n, base, len
 
   if (prod (size (n)) != length (n))
     n = n(:);
   elseif (any (n < 0 | n != fix (n)))
     error ("dec2base: can only convert non-negative integers")
   endif
 
   symbols = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
-  if (isstr (base))
+  if (ischar (base))
     symbols = base;
     base = length (symbols);
     if any (diff (sort (toascii (symbols))) == 0)
       error ("dec2base: symbols representing digits must be unique");
     endif
   elseif (! isscalar (base))
     error ("dec2base: cannot convert from several bases at once");
   elseif (base < 2 || base > length (symbols))
diff --git a/scripts/strings/index.m b/scripts/strings/index.m
--- a/scripts/strings/index.m
+++ b/scripts/strings/index.m
@@ -36,17 +36,17 @@
 function n = index (s, t)
 
   ## This is patterned after the AWK function of the same name.
 
   if (nargin != 2)
     usage ("index (s, t)");
   endif
   
-  if (!isstr (s) || !isstr (t) || all (size (s) > 1) || all (size (t) > 1) )
+  if (!ischar (s) || !ischar (t) || all (size (s) > 1) || all (size (t) > 1) )
     error ("index: expecting string arguments");
   endif
 
   l_s = length (s);
   l_t = length (t);
   
   if ( l_s == 0 || l_s < l_t )
     ## zero length source, or target longer than source
diff --git a/scripts/strings/rindex.m b/scripts/strings/rindex.m
--- a/scripts/strings/rindex.m
+++ b/scripts/strings/rindex.m
@@ -36,17 +36,17 @@
 function n = rindex (s, t)
 
   ## This is patterned after the AWK function of the same name.
 
   if (nargin != 2)
     usage ("rindex (s, t)");
   endif
 
-  if (!isstr (s) || !isstr (t) || all (size (s) > 1) || all (size (t) > 1) )
+  if (!ischar (s) || !ischar (t) || all (size (s) > 1) || all (size (t) > 1) )
     error ("rindex: expecting string arguments");
   endif
 
   l_s = length (s);
   l_t = length (t);
 
   if ( l_s == 0 || l_s < l_t )
     ## zero length source, or target longer than source
diff --git a/scripts/strings/split.m b/scripts/strings/split.m
--- a/scripts/strings/split.m
+++ b/scripts/strings/split.m
@@ -32,17 +32,17 @@
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Adapted-By: jwe
 
 function m = split (s, t)
 
   if (nargin == 2)
-    if (isstr (s) && isstr (t))
+    if (ischar (s) && ischar (t))
 
       l_s = length (s);
       l_t = length (t);
 
       if (l_s == 0)
 	m = "";
 	return;
       elseif (l_t == 0)
diff --git a/scripts/strings/str2mat.m b/scripts/strings/str2mat.m
--- a/scripts/strings/str2mat.m
+++ b/scripts/strings/str2mat.m
@@ -39,38 +39,38 @@ function retval = str2mat (varargin)
 
   nc = 0;
   nr = 0;
 
   nr = zeros (nargin, 1);
   nc = zeros (nargin, 1);
   for k = 1 : nargin
     s = varargin{k};
-    if (! isstr (s))
-      s = setstr (s);
+    if (! ischar (s))
+      s = char (s);
     endif
     [nr(k), nc(k)] = size (s);
   endfor
 
   tmp = find (nr == 0);
 
   if (! isempty (tmp))
     nr(tmp) = 1;
   endif
 
   retval_nr = sum (nr);
   retval_nc = max (nc);
 
-  retval = setstr (ones (retval_nr, retval_nc) * toascii (" "));
+  retval = char (ones (retval_nr, retval_nc) * toascii (" "));
 
   row_offset = 0;
   for k = 1 : nargin
     s = varargin{k};
-    if (! isstr (s))
-      s = setstr (s);
+    if (! ischar (s))
+      s = char (s);
     endif
     if (nc(k) > 0)
       retval ((row_offset + 1) : (row_offset + nr(k)), 1:nc(k)) = s;
     endif
     row_offset = row_offset + nr(k);
   endfor
 
 endfunction
diff --git a/scripts/strings/str2num.m b/scripts/strings/str2num.m
--- a/scripts/strings/str2num.m
+++ b/scripts/strings/str2num.m
@@ -21,22 +21,22 @@
 ## @deftypefn {Function File} {} str2num (@var{s})
 ## Convert the string @var{s} to a number.
 ## @end deftypefn
 
 ## Author: jwe
 
 function m = str2num (s)
 
-  if (nargin == 1 && isstr (s))
+  if (nargin == 1 && ischar (s))
     [nr, nc] = size (s);
     sep = ";";
     sep = sep (ones (nr, 1), 1);
     s = sprintf ("m = [%s];", reshape ([s, sep]', 1, nr * (nc + 1)));
     eval (s, "m = [];");
-    if (isstr (m))
+    if (ischar (m))
       m = [];
     endif
   else
     usage ("str2num (s)");
   endif
 
 endfunction
diff --git a/scripts/strings/strcat.m b/scripts/strings/strcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/strcat.m
@@ -34,26 +34,26 @@
 ## Author: jwe
 
 function st = strcat (s, varargin)
 
   if (nargin > 0)
     save_warn_empty_list_elements = warn_empty_list_elements;
     unwind_protect
       warn_empty_list_elements = 0;
-      if (isstr (s))
+      if (ischar (s))
         tmpst = s;
       else
         error ("strcat: all arguments must be strings");
       endif
       n = nargin - 1;
       k = 1;
       while (n--)
         tmp = varargin{k++};
-        if (isstr (tmp))
+        if (ischar (tmp))
           tmpst = [tmpst, tmp];
         else
           error ("strcat: all arguments must be strings");
         endif
       endwhile
     unwind_protect_cleanup
       warn_empty_list_elements = save_warn_empty_list_elements;
     end_unwind_protect
diff --git a/scripts/strings/strcmpi.m b/scripts/strings/strcmpi.m
--- a/scripts/strings/strcmpi.m
+++ b/scripts/strings/strcmpi.m
@@ -28,15 +28,15 @@
 ## @end deftypefn
 
 ## Author: Bill Lash <lash@tellabs.com>
 ## Adapted-by: jwe
 
 function status = strcmpi(s1, s2)
 
   if (nargin == 2)
-    status = (isstr (s1) && isstr(s2) && strcmp (upper (s1), upper (s2)));
+    status = (ischar (s1) && ischar(s2) && strcmp (upper (s1), upper (s2)));
   else
     usage ("strcmpi (s, t)");
   endif
 
 endfunction
 
diff --git a/scripts/strings/strncmp.m b/scripts/strings/strncmp.m
--- a/scripts/strings/strncmp.m
+++ b/scripts/strings/strncmp.m
@@ -34,19 +34,19 @@
 function retval = strncmp (s1, s2, n)
 
   if (nargin != 3)
     usage ("strncmp (s, t, n)");
   endif
 
   retval = false;
 
-  if (isstr (s1))
+  if (ischar (s1))
     [r1, c1] = size (s1);
-    if (isstr (s2))
+    if (ischar (s2))
       [r2, c2] = size (s2);
       if (r1 == r2 && c1 == c2)
 	if (c1 == 0)
 	  retval = true;
 	else
 	  if (c1 > n)
 	    t1 = s1(:, 1:n);
 	    t2 = s2(:, 1:n);
@@ -97,17 +97,17 @@ function retval = strncmp (s1, s2, n)
 	  else
 	    error ("strncmp: nonconformant arrays");
 	  endif
 	endif
       endif
     endif
   elseif (iscellstr (s1))
     [r1, c1] = size (s1);
-    if (isstr (s2))
+    if (ischar (s2))
       retval = strncmp (s2, s1, n, "logical");
     elseif (iscellstr (s2))
       [r2, c2] = size (s2);
       if (r1 == 1 && c1 == 1)
 	t1 = s1{:};
 	t2 = s2(:);
 	m = length (t2);
 	retval = zeros (m, 1);
diff --git a/scripts/strings/strrep.m b/scripts/strings/strrep.m
--- a/scripts/strings/strrep.m
+++ b/scripts/strings/strrep.m
@@ -33,17 +33,17 @@
 ## Adapted-By: jwe
 
 function t = strrep (s, x, y)
 
   if (nargin != 3)
     usage ("strrep (s, x, y)");
   endif
 
-  if (! (isstr (s) && isstr (x) && isstr (y)))
+  if (! (ischar (s) && ischar (x) && ischar (y)))
     error ("strrep: all arguments must be strings");
   endif
 
   if (length (x) > length (s) || isempty (x))
     t = s;
     return;
   endif
 
@@ -79,12 +79,12 @@ function t = strrep (s, x, y)
     t(dest) = y(repeat);
   else                        # deletion
     ## Build an index vector of all locations where the target was found
     ## in the search string, and zap them. 
     t = toascii (s);
     repeat = [1:length(x)]' * ones (1, length (ind));
     delete = ones (length (x), 1) * ind + repeat - 1;
     t(delete) = [];
-    t = setstr (t);
+    t = char (t);
   endif
 
 endfunction
diff --git a/scripts/strings/substr.m b/scripts/strings/substr.m
--- a/scripts/strings/substr.m
+++ b/scripts/strings/substr.m
@@ -43,17 +43,17 @@
 ## Adapted-By: jwe
 
 function t = substr (s, offset, len)
 
   if (nargin < 2 || nargin > 3)
     usage ("substr (s, offset, len)");
   endif
 
-  if (isstr (s))
+  if (ischar (s))
     nc = columns (s);
     if (abs (offset) > 0 && abs (offset) <= nc)
       if (offset > 0)
         beg = offset;
       else
         beg = nc + offset + 1;
       endif
       if (nargin == 2)
