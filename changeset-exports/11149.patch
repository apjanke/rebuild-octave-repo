# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1287817231 14400
#      Sat Oct 23 03:00:31 2010 -0400
# Node ID fe3c3dfc07ebe643ee7b5059d8a4c46e6ff3d202
# Parent  c9ec943ebe65dbf1a583e9bd34591408463532b5
style fix: break lines before && and ||, not after

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,35 @@
+2010-10-23  John W. Eaton  <jwe@octave.org>
+
+	* statistics/distributions/nbinrnd.m: Use | instead of || in
+	argument to find.
+
+	* deprecated/intwarning.m, general/bicubic.m, general/postpad.m,
+	general/prepad.m, general/private/__splinen__.m,
+	general/shift.m, miscellaneous/swapbytes.m, pkg/pkg.m,
+	plot/clabel.m, plot/colorbar.m, plot/fill.m, plot/legend.m,
+	plot/plotmatrix.m, plot/plotyy.m, plot/private/__clabel__.m,
+	plot/private/__ezplot__.m, plot/private/__quiver__.m,
+	plot/subplot.m, signal/unwrap.m, statistics/base/histc.m,
+	statistics/base/iqr.m, statistics/base/kurtosis.m,
+	statistics/base/mode.m, statistics/base/ranks.m,
+	statistics/base/run_count.m, statistics/base/skewness.m,
+	statistics/base/statistics.m, statistics/base/studentize.m,
+	statistics/distributions/exprnd.m,
+	statistics/distributions/frnd.m,
+	statistics/distributions/geornd.m,
+	statistics/distributions/lognrnd.m,
+	statistics/distributions/nbinrnd.m,
+	statistics/distributions/poissrnd.m,
+	statistics/distributions/trnd.m,
+	statistics/distributions/wblrnd.m, strings/strcat.m,
+	time/datestr.m, time/datetick.m: Break lines before && and ||,
+	not before.
+
 2010-10-23  John W. Eaton  <jwe@octave.org>
 
 	* io/strread.m: Docstring fixes.
 
 2010-10-23  John W. Eaton  <jwe@octave.org>
 
 	* io/is_valid_file_id.m: Ensure that FID is a scalar before
 	calling fopen to get info.  New tests.
diff --git a/scripts/deprecated/intwarning.m b/scripts/deprecated/intwarning.m
--- a/scripts/deprecated/intwarning.m
+++ b/scripts/deprecated/intwarning.m
@@ -103,20 +103,20 @@ function y = intwarning (x)
         warning ("off", "Octave:int-convert-non-int-val");
         warning ("off", "Octave:int-convert-overflow");    
         warning ("off", "Octave:int-math-overflow");    
       else
         error ("intwarning: unrecognized argument");
       endif
     elseif (isstruct(x))
       for fld = fieldnames (x)
-        if (strcmp ("Octave:int-convert-nan") || 
-            strcmp ("Octave:int-convert-non-int-val") || 
-            strcmp ("Octave:int-convert-overflow") ||
-            strcmp ("Octave:int-cmath-overflow"))
+        if (strcmp ("Octave:int-convert-nan")
+            || strcmp ("Octave:int-convert-non-int-val")
+            || strcmp ("Octave:int-convert-overflow")
+            || strcmp ("Octave:int-cmath-overflow"))
           s = getfield (x, fld);
           if (! ischar (s) || !(strcmpi("s","on") || strcmpi("s","off")))
             error ("intwarning: unexpected warning state");
           endif
           warning (s, fld);
         else
           error ("intwarning: unrecognized integer warning %s", fld);
         endif
diff --git a/scripts/general/bicubic.m b/scripts/general/bicubic.m
--- a/scripts/general/bicubic.m
+++ b/scripts/general/bicubic.m
@@ -43,18 +43,18 @@ function F = bicubic (X, Y, Z, XI, YI, e
   else
     a = 0.5;
   endif
 
   if (nargin < 6)
     extrapval = NaN;
   endif
 
-  if (isa (X, "single") || isa (Y, "single") || isa (Z, "single") || 
-      isa (XI, "single") || isa (YI, "single"))
+  if (isa (X, "single") || isa (Y, "single") || isa (Z, "single")
+      || isa (XI, "single") || isa (YI, "single"))
     myeps = eps("single");
   else
     myeps = eps;
   endif
 
   if (nargin <= 2)
     ## bicubic (Z) or bicubic (Z, 2)
     if (nargin == 1) 
diff --git a/scripts/general/postpad.m b/scripts/general/postpad.m
--- a/scripts/general/postpad.m
+++ b/scripts/general/postpad.m
@@ -44,18 +44,18 @@ function y = postpad (x, l, c, dim)
   sz = size (x);
   if (nargin < 4)
     ## Find the first non-singleton dimension
     dim = find (sz > 1, 1);
     if (isempty (dim))
       dim = 1;
     endif
   else
-    if (!(isscalar (dim) && dim == fix (dim)) || 
-        !(1 <= dim && dim <= nd))
+    if (!(isscalar (dim) && dim == fix (dim))
+        || !(1 <= dim && dim <= nd))
       error ("postpad: DIM must be an integer and a valid dimension");
     endif
   endif
 
   if (! isscalar (l) || l < 0)
     error ("postpad: second argument must be a positive scaler");
   endif
 
diff --git a/scripts/general/prepad.m b/scripts/general/prepad.m
--- a/scripts/general/prepad.m
+++ b/scripts/general/prepad.m
@@ -55,18 +55,18 @@ function y = prepad (x, l, c, dim)
   sz = size (x);
   if (nargin < 4)
     ## Find the first non-singleton dimension
     dim = find (sz > 1, 1);
     if (isempty (dim))
       dim = 1;
     endif
   else
-    if (!(isscalar (dim) && dim == fix (dim)) ||
-        !(1 <= dim && dim <= nd))
+    if (!(isscalar (dim) && dim == fix (dim))
+        || !(1 <= dim && dim <= nd))
       error ("prepad: DIM must be an integer and a valid dimension");
     endif
   endif
 
   if (! isscalar (l) || l < 0)
     error ("prepad: second argument must be a positive scaler");
   endif
 
diff --git a/scripts/general/private/__splinen__.m b/scripts/general/private/__splinen__.m
--- a/scripts/general/private/__splinen__.m
+++ b/scripts/general/private/__splinen__.m
@@ -26,18 +26,18 @@
 ## FIXME: Allow arbitrary grids..
 
 function yi = __splinen__ (x, y, xi, extrapval, f)
   if (nargin != 5)
     error ("__splinen__: Incorrect number of arguments");
   endif
   ## ND isvector function.
   isvec = @(x) numel (x) == length (x);
-  if (!iscell (x) || length(x) < ndims(y) || any (! cellfun (isvec, x)) ||
-      !iscell (xi) || length(xi) < ndims(y) || any (! cellfun (isvec, xi)))
+  if (!iscell (x) || length(x) < ndims(y) || any (! cellfun (isvec, x))
+      || !iscell (xi) || length(xi) < ndims(y) || any (! cellfun (isvec, xi)))
     error ("__splinen__: %s: non gridded data or dimensions inconsistent", f);
   endif
   yi = y;
   for i = length(x):-1:1
     yi = permute (spline (x{i}, yi, xi{i}(:)), [length(x),1:length(x)-1]);
   endfor
 
   [xi{:}] = ndgrid (cellfun (@(x) x(:), xi, "UniformOutput", false){:});
diff --git a/scripts/general/shift.m b/scripts/general/shift.m
--- a/scripts/general/shift.m
+++ b/scripts/general/shift.m
@@ -41,18 +41,18 @@ function y = shift (x, b, dim)
   if (! (isscalar (b) && b == round (b)))
     error ("shift: B must be an integer");
   endif
 
   nd = ndims (x);
   sz = size (x);
 
   if (nargin == 3)
-    if (!(isscalar (dim) && dim == round (dim)) || 
-        !(1 <= dim && dim <= nd))
+    if (!(isscalar (dim) && dim == round (dim))
+        || !(1 <= dim && dim <= nd))
       error ("shift: DIM must be an integer and a valid dimension");
     endif
   else
     ## Find the first non-singleton dimension.
     dim = find (sz > 1, 1);
     if (isempty (dim))
       dim = 1;
     endif
diff --git a/scripts/miscellaneous/swapbytes.m b/scripts/miscellaneous/swapbytes.m
--- a/scripts/miscellaneous/swapbytes.m
+++ b/scripts/miscellaneous/swapbytes.m
@@ -39,18 +39,18 @@ function y = swapbytes (x)
   clx = class (x);
   if (strcmp (clx, "int8") || strcmp (clx, "uint8") || isempty (x))
     y = x;
   else
     if (strcmp (clx, "int16") || strcmp (clx, "uint16"))
       nb = 2;
     elseif (strcmp (clx, "int32") || strcmp (clx, "uint32"))
       nb = 4;
-    elseif (strcmp (clx, "int64") || strcmp (clx, "uint64") ||
-            strcmp (clx, "double"))
+    elseif (strcmp (clx, "int64") || strcmp (clx, "uint64")
+            || strcmp (clx, "double"))
       nb = 8;
     else
       error ("swapbytes: invalid class of object");
     endif
     y = reshape (typecast (reshape (typecast (x(:), "uint8"), nb, numel (x))
                            ([nb : -1 : 1], :) (:), clx), size(x));
   endif
 endfunction
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -823,18 +823,18 @@ function install (files, handle_deps, au
       rm_rf (getarchdir (descriptions{i}));
     endfor
     rethrow (lasterror ());
   end_try_catch
 
   ## Check if the installed directory is empty. If it is remove it
   ## from the list.
   for i = length (descriptions):-1:1
-    if (dirempty (descriptions{i}.dir, {"packinfo", "doc"}) &&
-        dirempty (getarchdir (descriptions{i})))
+    if (dirempty (descriptions{i}.dir, {"packinfo", "doc"})
+        && dirempty (getarchdir (descriptions{i})))
       warning ("package %s is empty\n", descriptions{i}.name);
       rm_rf (descriptions{i}.dir);
       rm_rf (getarchdir (descriptions{i}));
       descriptions(i) = [];
     endif
   endfor
 
   ## If the package requested that it is autoloaded, or the installer
@@ -1507,18 +1507,18 @@ function copy_files (desc, packdir, glob
   ## Copy the files from "inst" to installdir.
   instdir = fullfile (packdir, "inst");
   if (! dirempty (instdir))
     [status, output] = copyfile (fullfile (instdir, "*"), desc.dir);
     if (status != 1)
       rm_rf (desc.dir);
       error ("couldn't copy files to the installation directory");
     endif
-    if (exist (fullfile (desc.dir, getarch ()), "dir") &&
-        ! strcmp (fullfile (desc.dir, getarch ()), octfiledir))
+    if (exist (fullfile (desc.dir, getarch ()), "dir")
+        && ! strcmp (fullfile (desc.dir, getarch ()), octfiledir))
       if (! exist (octfiledir, "dir"))
         ## Can be required to create upto three levels of dirs.
         octm1 = fileparts (octfiledir);
         if (! exist (octm1, "dir"))
           octm2 = fileparts (octm1);
           if (! exist (octm2, "dir"))
             octm3 = fileparts (octm2);
             if (! exist (octm3, "dir"))
@@ -2249,18 +2249,18 @@ function [status, output] = shell (cmd)
     [status, output] = system (cmd);
   endif
 endfunction
 
 function newdesc = save_order (desc)
   newdesc = {};
   for i = 1 : length(desc)
     deps = desc{i}.depends;
-    if (isempty (deps) || (length (deps) == 1 && 
-                          strcmp(deps{1}.package, "octave")))
+    if (isempty (deps)
+        || (length (deps) == 1 && strcmp(deps{1}.package, "octave")))
       newdesc {end + 1} = desc{i};
     else
       tmpdesc = {};
       for k = 1 : length (deps)
         for j = 1 : length (desc)
           if (strcmp (desc{j}.name, deps{k}.package))
             tmpdesc{end+1} = desc{j};
             break;
@@ -2314,24 +2314,24 @@ function load_packages_and_dependencies 
   ## Add the binaries to exec_path.
   if (! strcmp (EXEC_PATH, execpath))
     EXEC_PATH (execpath);
   endif
 endfunction
 
 function idx = load_package_dirs (lidx, idx, handle_deps, installed_pkgs_lst)
   for i = lidx
-    if (isfield (installed_pkgs_lst{i}, "loaded") &&
-        installed_pkgs_lst{i}.loaded)
+    if (isfield (installed_pkgs_lst{i}, "loaded")
+        && installed_pkgs_lst{i}.loaded)
       continue;
     else
       if (handle_deps)
         deps = installed_pkgs_lst{i}.depends;
-        if ((length (deps) > 1) || (length (deps) == 1 && 
-                          ! strcmp(deps{1}.package, "octave")))
+        if ((length (deps) > 1)
+            || (length (deps) == 1 && ! strcmp(deps{1}.package, "octave")))
           tmplidx = [];
           for k = 1 : length (deps)
             for j = 1 : length (installed_pkgs_lst)
               if (strcmp (installed_pkgs_lst{j}.name, deps{k}.package))
                 tmplidx (end + 1) = j;
                 break;
               endif
             endfor
diff --git a/scripts/plot/clabel.m b/scripts/plot/clabel.m
--- a/scripts/plot/clabel.m
+++ b/scripts/plot/clabel.m
@@ -61,18 +61,18 @@ function retval = clabel (c, varargin)
   have_labelspacing = false;
 
   if (nargin < 1)
     print_usage()
   elseif (nargin == 1)
     hparent = gca ();
   else
     arg = varargin{1};
-    if (isscalar (arg) && ishandle(arg) && 
-        strcmp (get (arg, "type"), "hggroup"))
+    if (isscalar (arg) && ishandle(arg)
+        && strcmp (get (arg, "type"), "hggroup"))
       obj = get (arg);
       if (! isfield (obj, "contourmatrix"))
         error ("clabel: expecting the handle to be a contour group");
       endif
       hg = arg;
       have_hg = true;
       varargin(1) = [];
     else
diff --git a/scripts/plot/colorbar.m b/scripts/plot/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/colorbar.m
@@ -173,43 +173,43 @@ function h = colorbar (varargin)
   if (nargout > 0)
     h = cax;
   endif
 endfunction
 
 function deletecolorbar (h, d, hc, orig_props)
   ## Don't delete the colorbar and reset the axis size if the
   ## parent figure is being deleted.
-  if (ishandle (hc) && strcmp (get (hc, "type"), "axes") && 
-      (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")))
+  if (ishandle (hc) && strcmp (get (hc, "type"), "axes")
+      && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")))
     if (strcmp (get (hc, "beingdeleted"), "off"))
       delete (hc);
     endif
-    if (!isempty (ancestor (h, "axes")) &&
-        strcmp (get (ancestor (h, "axes"), "beingdeleted"), "off"))
+    if (!isempty (ancestor (h, "axes"))
+        && strcmp (get (ancestor (h, "axes"), "beingdeleted"), "off"))
       set (ancestor (h, "axes"), "position", orig_props.position, ...
                             "outerposition", orig_props.outerposition, ...
                     "activepositionproperty", orig_props.activepositionproperty);
     endif
   endif
 endfunction
 
 function resetaxis (h, d, orig_props)
-  if (ishandle (h) && strcmp (get (h, "type"), "axes") && 
-      (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")) &&
-      ishandle (get (h, "axes")))
+  if (ishandle (h) && strcmp (get (h, "type"), "axes")
+      && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off"))
+      && ishandle (get (h, "axes")))
      set (get (h, "axes"), "position", orig_props.position, ...
                            "outerposition", orig_props.outerposition, ...
                    "activepositionproperty", orig_props.activepositionproperty);
   endif
 endfunction
 
 function update_colorbar_clim (h, d, hi, vert)
-  if (ishandle (h) && strcmp (get (h, "type"), "image") && 
-      (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")))
+  if (ishandle (h) && strcmp (get (h, "type"), "image")
+      && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")))
     clen = rows (get (get (h, "parent"), "colormap"));
     cext = get (h, "clim");
     cdiff = (cext(2) - cext(1)) / clen / 2;
     cmin = cext(1) + cdiff;
     cmax = cext(2) - cdiff;
 
     if (vert)
       set (hi, "ydata", [cmin, cmax]);
@@ -218,18 +218,18 @@ function update_colorbar_clim (h, d, hi,
       set (hi, "xdata", [cmin, cmax]);
       set (get (hi, "parent"), "xlim", cext);
     endif
   endif
 endfunction
 
 function update_colorbar_axis (h, d, cax, orig_props)
 
-  if (ishandle (cax) && strcmp (get (cax, "type"), "axes") && 
-      (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")))
+  if (ishandle (cax) && strcmp (get (cax, "type"), "axes")
+      && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")))
     loc = get (cax, "location");
     obj = get (h);
     obj.__my_handle__ = h;
     obj.position = orig_props.position;
     obj.outerposition = orig_props.outerposition;
     [pos, cpos, vertical, mirror] =  ...
         __position_colorbox__ (loc, obj, ancestor (h, "figure"));
 
diff --git a/scripts/plot/fill.m b/scripts/plot/fill.m
--- a/scripts/plot/fill.m
+++ b/scripts/plot/fill.m
@@ -69,19 +69,19 @@ function iargs = __find_patches__ (varar
             || strcmpi (varargin{i}, "vertices")))
       i += 4;
     elseif (isnumeric (varargin{i}))
       i += 2;
     endif
 
     if (i <= nargin)
       while (true);
-        if (ischar (varargin{i}) && 
-            (strcmpi (varargin{i}, "faces")
-             || strcmpi (varargin{i}, "vertices")))
+        if (ischar (varargin{i})
+            && (strcmpi (varargin{i}, "faces")
+                || strcmpi (varargin{i}, "vertices")))
           break;
         elseif (isnumeric (varargin{i}))
           ## Assume its the colorspec
           i++;
           break;
         elseif (ischar (varargin{i}))
           colspec = tolower (varargin{i});
           collen = length (colspec);
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -761,47 +761,47 @@ function hideshowlegend (h, d, ca, pos1,
       if (! strcmp (get (kids(i), "visible"), "off"))
         isvisible = true;
         break;
       endif
     endfor
   endif
 
   for i = 1 : numel (ca)
-    if (ishandle (ca(i)) && strcmp (get (ca(i), "type"), "axes") && 
-      (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")) &&
-        strcmp (get (ca(i), "beingdeleted"), "off"))
+    if (ishandle (ca(i)) && strcmp (get (ca(i), "type"), "axes")
+        && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off"))
+        && strcmp (get (ca(i), "beingdeleted"), "off"))
       units = get (ca(i), "units");
       unwind_protect
         set (ca(i), "units", "points");
         if (isvisible)
           set (ca(i), "position", pos2, "outerposition", outpos2);
         else
           set (ca(i), "position", pos1, "outerposition", outpos1);
         endif
       unwind_protect_cleanup
         set (ca(i), "units", units);
       end_unwind_protect
     endif
   endfor
 endfunction
 
 function deletelegend1 (h, d, ca)
-  if (ishandle (ca) && strcmp (get (ca, "type"), "axes") && 
-      (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")) &&
-      strcmp (get (ca, "beingdeleted"), "off"))
+  if (ishandle (ca) && strcmp (get (ca, "type"), "axes")
+      && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off"))
+      && strcmp (get (ca, "beingdeleted"), "off"))
     delete (ca);
   endif
 endfunction
 
 function deletelegend2 (h, d, ca, pos, outpos, t1)
   for i = 1 : numel (ca)
-    if (ishandle (ca(i)) && strcmp (get (ca(i), "type"), "axes") && 
-      (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")) &&
-        strcmp (get (ca(i), "beingdeleted"), "off"))
+    if (ishandle (ca(i)) && strcmp (get (ca(i), "type"), "axes")
+        && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off"))
+        && strcmp (get (ca(i), "beingdeleted"), "off"))
       if (!isempty (pos) && !isempty(outpos))
         units = get (ca(i), "units");
         unwind_protect
           set (ca(i), "units", "points");
           set (ca(i), "position", pos, "outerposition", outpos, "deletefcn", "");
         unwind_protect_cleanup
           set (ca(i), "units", units);
         end_unwind_protect
diff --git a/scripts/plot/plotmatrix.m b/scripts/plot/plotmatrix.m
--- a/scripts/plot/plotmatrix.m
+++ b/scripts/plot/plotmatrix.m
@@ -96,18 +96,18 @@ function [h, ax, bigax, p, pax] = plotma
 endfunction
 
 %!demo
 %! plotmatrix (randn (100, 3), 'g+')
 
 function plotmatrixdelete (h, d, ax)
   for i = 1 : numel (ax)
     hc = ax(i);
-    if (ishandle (hc) && strcmp (get (hc, "type"), "axes") && 
-        strcmpi (get (hc, "beingdeleted"), "off"))
+    if (ishandle (hc) && strcmp (get (hc, "type"), "axes")
+        && strcmpi (get (hc, "beingdeleted"), "off"))
       parent = get (hc, "parent");
       ## If the parent is invalid or being deleted, then do nothing
       if (ishandle (parent) && strcmpi (get (parent, "beingdeleted"), "off"))
         delete (hc);
       endif
     endif
   endfor
 endfunction
diff --git a/scripts/plot/plotyy.m b/scripts/plot/plotyy.m
--- a/scripts/plot/plotyy.m
+++ b/scripts/plot/plotyy.m
@@ -52,18 +52,18 @@
 ## @end group
 ## @end example
 ## @end deftypefn
 
 function [Ax, H1, H2] = plotyy (varargin)
 
   ## Don't use __plt_get_axis_arg__ here as ax is a two vector for plotyy
   if (nargin > 1 && length (varargin{1}) == 2 && ishandle(varargin{1}(1)) 
-      &&  ishandle(varargin{1}(2)) && 
-      all (floor (varargin{1}) != varargin{1}))
+      && ishandle(varargin{1}(2))
+      && all (floor (varargin{1}) != varargin{1}))
     obj1 = get (varargin{1}(1));
     obj2 = get (varargin{1}(2));
     if (strcmp (obj1.type, "axes") || strcmp (obj2.type, "axes"))
       ax = [obj1, obj2];
       varargin(1) = [];
       if (isempty (varargin))
         varargin = {};
       endif
@@ -232,19 +232,19 @@ endfunction
 %! surf (peaks (25))
 %! subplot (2, 2, 3)
 %! contour (peaks (25))
 %! subplot (2, 2, 4)
 %! plotyy (x, 10*sin(2*pi*x), x, cos(2*pi*x))
 %! axis square
 
 function deleteplotyy (h, d, ax2, t2)
-  if (ishandle (ax2) && strcmp (get (ax2, "type"), "axes") && 
-      (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off")) &&
-      strcmp (get (ax2, "beingdeleted"), "off"))
+  if (ishandle (ax2) && strcmp (get (ax2, "type"), "axes")
+      && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off"))
+      && strcmp (get (ax2, "beingdeleted"), "off"))
     set (t2, "deletefcn", []);
     delete (ax2);
   endif
 endfunction
 
 function update_position (h, d, ax2)
   persistent recursion = false;
 
diff --git a/scripts/plot/private/__clabel__.m b/scripts/plot/private/__clabel__.m
--- a/scripts/plot/private/__clabel__.m
+++ b/scripts/plot/private/__clabel__.m
@@ -23,18 +23,18 @@
 
 function h = __clabel__ (c, v, hparent, label_spacing, z, varargin)
   ## FIXME
   ## Assume that the plot size is 4 by 3 inches.
   lims = axis ();
   xspacing = 72 * 4 / abs(lims(1) - lims(2));
   yspacing = 72 * 3 / abs(lims(3) - lims(4));
 
-  if (isscalar (hparent) && ishandle(hparent) && 
-        strcmp (get (hparent, "type"), "hggroup"))
+  if (isscalar (hparent) && ishandle(hparent)
+      && strcmp (get (hparent, "type"), "hggroup"))
     x = get (hparent, "xdata");
     xmin = min (x(:));
     xmax = max (x(:));
     y = get (hparent, "ydata");
     ymin = min (y(:));
     ymax = max (y(:));
   else
     i1 = 1;
@@ -84,18 +84,18 @@ function h = __clabel__ (c, v, hparent, 
     for i = 1 : ntag
       tagpos = pos(i);
       
       while (j1 < clen && cumd(j1) < tagpos)
         j1++;
       endwhile
       tpos = sum(c(:,i1+j1-1:i1+j1), 2) ./ 2;
 
-      if (tpos(1) != xmin &&  tpos(1) != xmax && 
-          tpos(2) != ymin &&  tpos(2) != ymax)
+      if (tpos(1) != xmin &&  tpos(1) != xmax
+          && tpos(2) != ymin &&  tpos(2) != ymax)
         trot = 180 / pi * atan2 (diff (c(2,i1+j1-1:i1+j1)),
                                  diff (c(1,i1+j1-1:i1+j1)));
 
         if (ischar (z))
           ht = text (tpos(1), tpos(2), clev, tlabel, "rotation", trot, 
                      "parent", hparent, "horizontalalignment", "center",
                      "userdata", clev, varargin{:});
         elseif (!isempty (z))
diff --git a/scripts/plot/private/__ezplot__.m b/scripts/plot/private/__ezplot__.m
--- a/scripts/plot/private/__ezplot__.m
+++ b/scripts/plot/private/__ezplot__.m
@@ -192,18 +192,18 @@ function [h, needusage] = __ezplot__ (pf
       yarg = "y";
       if (nargs == 2)
         error ("%s: can not define a parametric function in this manner");
       endif
     endif
 
     if (!isplot && parametric)
       funz = varargin {3};
-      if (ischar (funz) && ! strcmp (funz, "circ") && 
-          ! strcmp (funz, "animate"))
+      if (ischar (funz) && ! strcmp (funz, "circ")
+          && ! strcmp (funz, "animate"))
         if (exist (funz, "file") || exist (funz, "builtin"))
           funz = vectorize (inline (cstrcat (funz, "(t)")));
         else
           funz = vectorize (inline (funz));
         endif
         if (length (argnames (funz)) != nargs)
           error ("%s: excepting a function of %d arguments", func, nargs);
         endif
@@ -345,18 +345,18 @@ function [h, needusage] = __ezplot__ (pf
     if (isplot3)
       needusage = true;
       return;
     endif
 
     fstr = regexprep (regexprep (regexprep (fstr,'\s*\.?\^\s*','^'), '\./', '/'), 
                       '\.?\*', '');
     if (isplot && nargs == 2)
-      if (strcmp (typeinfo (fun), "inline function") && 
-          !isempty (strfind (formula (fun) , "=")))
+      if (strcmp (typeinfo (fun), "inline function")
+          && !isempty (strfind (formula (fun) , "=")))
         fun = inline (cstrcat (strrep (formula (fun), "=", "- ("), ")"));
       else
         fstr = cstrcat (fstr, " = 0");
       endif
 
       Z = feval (fun, X, Y);
 
       ## Matlab returns line objects for this case and so can't call 
diff --git a/scripts/plot/private/__quiver__.m b/scripts/plot/private/__quiver__.m
--- a/scripts/plot/private/__quiver__.m
+++ b/scripts/plot/private/__quiver__.m
@@ -206,18 +206,18 @@ function hg = __quiver__ (varargin)
     xarrw2 = xtmp - (y - yend) * arrowsize / 3;
     yarrw1 = ytmp - (x - xend) * arrowsize / 3;
     yarrw2 = ytmp + (x - xend) * arrowsize / 3;
     if (is3d)
       zarrw1 = zarrw2 = zend - ww(:) * arrowsize;
     endif
 
     if (have_line_spec)
-      if (isfield (linespec, "marker") && 
-        ! strncmp (linespec.marker, "none", 4))
+      if (isfield (linespec, "marker")
+          && ! strncmp (linespec.marker, "none", 4))
         if (is3d)
           h2 = plot3 ([xarrw1.'; xend.'; xarrw2.'; NaN(1, length (x))](:),
                       [yarrw1.'; yend.'; yarrw2.'; NaN(1, length (y))](:),
                       [zarrw1.'; zend.'; zarrw2.'; NaN(1, length (z))](:),
                       "linestyle", "none", "parent", hg);
         else
           h2 = plot ([xarrw1.'; xend.'; xarrw2.'; NaN(1, length (x))](:),
                      [yarrw1.'; yend.'; yarrw2.'; NaN(1, length (y))](:),
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -113,18 +113,18 @@ function h = subplot (rows, columns, ind
       ## case anymore due to the deletion of previous children (due to
       ## "deletefcn" callback or for legends/colorbars that are deleted
       ## with their corresponding axes).
       if (! ishandle (child))
         continue;
       endif
       if (strcmp (get (child, "type"), "axes"))
         ## Skip legend and colorbar objects.
-        if (strcmp (get (child, "tag"), "legend") || 
-            strcmp (get (child, "tag"), "colorbar"))
+        if (strcmp (get (child, "tag"), "legend")
+            || strcmp (get (child, "tag"), "colorbar"))
           continue;
         endif
         objpos = get (child, "position");
         if (all (objpos == pos))
           ## If the new axes are in exactly the same position as an
           ## existing axes object, use the existing axes.
           found = true;
           tmp = child;
diff --git a/scripts/signal/unwrap.m b/scripts/signal/unwrap.m
--- a/scripts/signal/unwrap.m
+++ b/scripts/signal/unwrap.m
@@ -45,18 +45,18 @@ function retval = unwrap (a, tol, dim)
   endif
 
   ## Don't let anyone use a negative value for TOL.
   tol = abs (tol);
 
   nd = ndims (a);
   sz = size (a);
   if (nargin == 3)
-    if (!(isscalar (dim) && dim == fix (dim)) || 
-        !(1 <= dim && dim <= nd))
+    if (!(isscalar (dim) && dim == fix (dim))
+        || !(1 <= dim && dim <= nd))
       error ("unwrap: DIM must be an integer and a valid dimension");
     endif
   else
     ## Find the first non-singleton dimension
     dim = find (sz > 1, 1);
     if (isempty (dim))
       dim = 1;
     endif
diff --git a/scripts/statistics/base/histc.m b/scripts/statistics/base/histc.m
--- a/scripts/statistics/base/histc.m
+++ b/scripts/statistics/base/histc.m
@@ -73,18 +73,18 @@ function [n, idx] = histc (data, edges, 
   sz = size (data);
   if (nargin < 3)
     ## Find the first non-singleton dimension.
     dim = find (sz > 1, 1);
     if (isempty (dim))
       dim = 1;
     endif
   else
-    if (!(isscalar (dim) && dim == round (dim)) || 
-        !(1 <= dim && dim <= nd))
+    if (!(isscalar (dim) && dim == round (dim))
+        || !(1 <= dim && dim <= nd))
       error ("histc: DIM must be an integer and a valid dimension");
     endif
   endif
 
   nsz = sz;
   nsz (dim) = num_edges;
   
   ## the splitting point is 3 bins
diff --git a/scripts/statistics/base/iqr.m b/scripts/statistics/base/iqr.m
--- a/scripts/statistics/base/iqr.m
+++ b/scripts/statistics/base/iqr.m
@@ -45,18 +45,18 @@ function y = iqr (x, dim)
   nel = numel (x);
   if (nargin != 2)
     ## Find the first non-singleton dimension.
     dim = find (sz > 1, 1);
     if (isempty (dim))
       dim = 1;
     endif
   else
-    if (!(isscalar (dim) && dim == round (dim)) || 
-        !(1 <= dim && dim <= nd))
+    if (!(isscalar (dim) && dim == round (dim))
+        || !(1 <= dim && dim <= nd))
       error ("iqr: DIM must be an integer and a valid dimension");
     endif
   endif
 
   ## This code is a bit heavy, but is needed until empirical_inv 
   ## takes other than vector arguments.
   c = sz(dim);
   sz(dim) = 1;
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/base/kurtosis.m
--- a/scripts/statistics/base/kurtosis.m
+++ b/scripts/statistics/base/kurtosis.m
@@ -57,18 +57,18 @@ function retval = kurtosis (x, dim)
   sz = size (x);
   if (nargin != 2)
     ## Find the first non-singleton dimension.
     dim = find (sz > 1, 1);
     if (isempty (dim))
       dim = 1;
     endif
   else
-    if (!(isscalar (dim) && dim == round (dim)) || 
-        !(1 <= dim && dim <= nd))
+    if (!(isscalar (dim) && dim == round (dim))
+        || !(1 <= dim && dim <= nd))
       error ("kurtosis: DIM must be an integer and a valid dimension");
     endif
   endif
   
   c = sz(dim);
   sz(dim) = 1;
   idx = ones (1, nd);
   idx(dim) = c;
diff --git a/scripts/statistics/base/mode.m b/scripts/statistics/base/mode.m
--- a/scripts/statistics/base/mode.m
+++ b/scripts/statistics/base/mode.m
@@ -48,18 +48,18 @@ function [m, f, c] = mode (x, dim)
   sz = size (x);
   if (nargin != 2)
     ## Find the first non-singleton dimension.
     dim = find (sz > 1, 1);
     if (isempty (dim))
       dim = 1;
     endif
   else
-    if (!(isscalar (dim) && dim == round (dim)) || 
-        !(1 <= dim && dim <= nd))
+    if (!(isscalar (dim) && dim == round (dim))
+        || !(1 <= dim && dim <= nd))
       error ("mode: DIM must be an integer and a valid dimension");
     endif
   endif
 
   sz2 = sz;
   sz2 (dim) = 1;
   sz3 = ones (1, nd);
   sz3 (dim) = sz (dim);
diff --git a/scripts/statistics/base/ranks.m b/scripts/statistics/base/ranks.m
--- a/scripts/statistics/base/ranks.m
+++ b/scripts/statistics/base/ranks.m
@@ -45,18 +45,18 @@ function y = ranks (x, dim)
   sz = size (x);
   if (nargin != 2)
     ## Find the first non-singleton dimension.
     dim = find (sz > 1, 1);
     if (isempty (dim))
       dim = 1;
     endif
   else
-    if (!(isscalar (dim) && dim == round (dim)) || 
-        !(1 <= dim && dim <= nd))
+    if (!(isscalar (dim) && dim == round (dim))
+        || !(1 <= dim && dim <= nd))
       error ("ranks: DIM must be an integer and a valid dimension");
     endif
   endif
 
   if (sz(dim) == 1)
     y = ones(sz);
   else
     ## The algorithm works only on dim = 1, so permute if necesary.
diff --git a/scripts/statistics/base/run_count.m b/scripts/statistics/base/run_count.m
--- a/scripts/statistics/base/run_count.m
+++ b/scripts/statistics/base/run_count.m
@@ -46,18 +46,18 @@ function retval = run_count (x, n, dim)
   sz = size (x);
   if (nargin != 3)
     ## Find the first non-singleton dimension.
     dim = find (sz > 1, 1);
     if (isempty (dim))
       dim = 1;
     endif
   else
-    if (!(isscalar (dim) && dim == round (dim)) || 
-        !(1 <= dim && dim <= nd))
+    if (!(isscalar (dim) && dim == round (dim))
+        || !(1 <= dim && dim <= nd))
       error ("run_count: DIM must be an integer and a valid dimension");
     endif
   endif
 
   if (dim != 1)
     perm = [1 : nd];
     perm(1) = dim;
     perm(dim) = 1;
diff --git a/scripts/statistics/base/skewness.m b/scripts/statistics/base/skewness.m
--- a/scripts/statistics/base/skewness.m
+++ b/scripts/statistics/base/skewness.m
@@ -58,18 +58,18 @@ function retval = skewness (x, dim)
   sz = size (x);
   if (nargin != 2)
     ## Find the first non-singleton dimension.
     dim = find (sz > 1, 1);
     if (isempty (dim))
       dim = 1;
     endif
   else
-    if (!(isscalar (dim) && dim == round (dim)) || 
-        !(1 <= dim && dim <= nd))
+    if (!(isscalar (dim) && dim == round (dim))
+        || !(1 <= dim && dim <= nd))
       error ("skewness: DIM must be an integer and a valid dimension");
     endif
   endif
 
   c = sz(dim);
   idx = ones (1, nd);
   idx (dim) = c;
   x = x - repmat (mean (x, dim), idx);
diff --git a/scripts/statistics/base/statistics.m b/scripts/statistics/base/statistics.m
--- a/scripts/statistics/base/statistics.m
+++ b/scripts/statistics/base/statistics.m
@@ -46,18 +46,18 @@ function S = statistics (X, dim)
   sz = size (X);
   if (nargin != 2)
     ## Find the first non-singleton dimension.
     dim = find (sz > 1, 1);
     if (isempty (dim))
       dim = 1;
     endif
   else
-    if (!(isscalar (dim) && dim == round (dim)) || 
-        !(1 <= dim && dim <= nd))
+    if (!(isscalar (dim) && dim == round (dim))
+        || !(1 <= dim && dim <= nd))
       error ("statistics: DIM must be an integer and a valid dimension");
     endif
   endif
   
   if (sz(dim) < 2)
     error ("statistics: dimension of X is too small (<2)");
   endif    
 
diff --git a/scripts/statistics/base/studentize.m b/scripts/statistics/base/studentize.m
--- a/scripts/statistics/base/studentize.m
+++ b/scripts/statistics/base/studentize.m
@@ -44,18 +44,18 @@ function t = studentize (x, dim)
   sz = size (x);
   if (nargin != 2)
     ## Find the first non-singleton dimension.
     dim = find (sz > 1, 1);
     if (isempty (dim))
       dim = 1;
     endif
   else
-    if (!(isscalar (dim) && dim == round (dim)) || 
-        !(1 <= dim && dim <= nd))
+    if (!(isscalar (dim) && dim == round (dim))
+        || !(1 <= dim && dim <= nd))
       error ("studentize: DIM must be an integer and a valid dimension");
     endif
   endif
 
   c = sz(dim);
   idx = ones (1, nd);
   idx(dim) = c;
   t = x - repmat (mean (x, dim), idx);
diff --git a/scripts/statistics/distributions/exprnd.m b/scripts/statistics/distributions/exprnd.m
--- a/scripts/statistics/distributions/exprnd.m
+++ b/scripts/statistics/distributions/exprnd.m
@@ -37,31 +37,31 @@ function rnd = exprnd (l, r, c)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("exprnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("exprnd: c must be a positive integer");
     endif
     sz = [r, c];
 
-    if (any (size (l) != 1) && 
-        (length (size (l)) != length (sz) || any (size (l) != sz)))
+    if (any (size (l) != 1)
+        && (length (size (l)) != length (sz) || any (size (l) != sz)))
       error ("exprnd: lambda must be scalar or of size [r, c]");
     endif
   elseif (nargin == 2)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("exprnd: r must be a positive integer or vector");
     endif
 
-    if (any (size (l) != 1) && 
-        ((length (size (l)) != length (sz)) || any (size (l) != sz)))
+    if (any (size (l) != 1)
+        && ((length (size (l)) != length (sz)) || any (size (l) != sz)))
       error ("exprnd: lambda must be scalar or of size sz");
     endif
   elseif (nargin == 1)
     sz = size (l);
   else
     print_usage ();
   endif
 
diff --git a/scripts/statistics/distributions/frnd.m b/scripts/statistics/distributions/frnd.m
--- a/scripts/statistics/distributions/frnd.m
+++ b/scripts/statistics/distributions/frnd.m
@@ -48,31 +48,31 @@ function rnd = frnd (m, n, r, c)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("frnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("frnd: c must be a positive integer");
     endif
     sz = [r, c];
 
-    if (any (size (m) != 1) && 
-        ((length (size (m)) != length (sz)) || any (size (m) != sz)))
+    if (any (size (m) != 1)
+        && ((length (size (m)) != length (sz)) || any (size (m) != sz)))
       error ("frnd: m and n must be scalar or of size [r,c]");
     endif
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("frnd: r must be a positive integer or vector");
     endif
 
-    if (any (size (m) != 1) && 
-        ((length (size (m)) != length (sz)) || any (size (m) != sz)))
+    if (any (size (m) != 1)
+        && ((length (size (m)) != length (sz)) || any (size (m) != sz)))
       error ("frnd: m and n must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(a);
   else
     print_usage ();
   endif
 
diff --git a/scripts/statistics/distributions/geornd.m b/scripts/statistics/distributions/geornd.m
--- a/scripts/statistics/distributions/geornd.m
+++ b/scripts/statistics/distributions/geornd.m
@@ -37,31 +37,31 @@ function rnd = geornd (p, r, c)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("geornd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("geornd: c must be a positive integer");
     endif
     sz = [r, c];
 
-    if (any (size (p) != 1) && ((length (size (p)) != length (sz)) ||
-                                any (size (p) != sz)))
+    if (any (size (p) != 1)
+        && ((length (size (p)) != length (sz)) || any (size (p) != sz)))
       error ("geornd: p must be scalar or of size [r, c]");
     endif
   elseif (nargin == 2)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("geornd: r must be a positive integer or vector");
     endif
 
-    if (any (size (p) != 1) && ((length (size (p)) != length (sz)) ||
-                                any (size (p) != sz)))
+    if (any (size (p) != 1)
+        && ((length (size (p)) != length (sz)) || any (size (p) != sz)))
       error ("geornd: n must be scalar or of size sz");
     endif
   elseif (nargin == 1)
     sz = size(n);
   elseif (nargin != 1)
     print_usage ();
   endif
 
diff --git a/scripts/statistics/distributions/lognrnd.m b/scripts/statistics/distributions/lognrnd.m
--- a/scripts/statistics/distributions/lognrnd.m
+++ b/scripts/statistics/distributions/lognrnd.m
@@ -46,32 +46,32 @@ function rnd = lognrnd (mu, sigma, r, c)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("lognrnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("lognrnd: c must be a positive integer");
     endif
     sz = [r, c];
 
-    if (any (size (mu) != 1) && 
-        ((length (size (mu)) != length (sz)) || any (size (mu) != sz)))
+    if (any (size (mu) != 1)
+        && ((length (size (mu)) != length (sz)) || any (size (mu) != sz)))
       error ("lognrnd: mu and sigma must be scalar or of size [r, c]");
     endif
 
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("lognrnd: r must be a positive integer or vector");
     endif
 
-    if (any (size (mu) != 1) && 
-        ((length (size (mu)) != length (sz)) || any (size (mu) != sz)))
+    if (any (size (mu) != 1)
+        && ((length (size (mu)) != length (sz)) || any (size (mu) != sz)))
       error ("lognrnd: mu and sigma must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(mu);
   else
     print_usage ();
   endif
 
diff --git a/scripts/statistics/distributions/nbinrnd.m b/scripts/statistics/distributions/nbinrnd.m
--- a/scripts/statistics/distributions/nbinrnd.m
+++ b/scripts/statistics/distributions/nbinrnd.m
@@ -46,54 +46,53 @@ function rnd = nbinrnd (n, p, r, c)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("nbinrnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("nbinrnd: c must be a positive integer");
     endif
     sz = [r, c];
 
-    if (any (size (n) != 1) && 
-        ((length (size (n)) != length (sz)) || any (size (n) != sz)))
+    if (any (size (n) != 1)
+        && ((length (size (n)) != length (sz)) || any (size (n) != sz)))
       error ("nbinrnd: n and p must be scalar or of size [r, c]");
     endif
 
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("nbinrnd: r must be a positive integer or vector");
     endif
 
-    if (any (size (n) != 1) && 
-        ((length (size (n)) != length (sz)) || any (size (n) != sz)))
+    if (any (size (n) != 1)
+        && ((length (size (n)) != length (sz)) || any (size (n) != sz)))
       error ("nbinrnd: n and p must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(n);
   else
     print_usage ();
   endif
 
   if (isscalar (n) && isscalar (p))
     if ((n < 1) || (n == Inf) || (n != round (n)) || (p <= 0) || (p > 1));
       rnd = NaN (sz);
-    elseif ((n > 0) && (n < Inf) && (n == round (n)) && 
-            (p > 0) && (p <= 1))
+    elseif ((n > 0) && (n < Inf) && (n == round (n))
+            && (p > 0) && (p <= 1))
       rnd = randp ((1 - p) ./ p .* randg (n, sz));
     else
       rnd = zeros (sz);
     endif
   else
     rnd = zeros (sz);
 
-    k = find ((n < 1) || (n == Inf) || (n != round (n)) || 
-              (p <= 0) || (p > 1));
+    k = find ((n < 1) | (n == Inf) | (n != round (n)) | (p <= 0) | (p > 1));
     if (any (k))
       rnd(k) = NaN;
     endif
 
     k = find ((n > 0) & (n < Inf) & (n == round (n)) & (p > 0) & (p <= 1));
     if (any (k))
       rnd(k) = randp ((1 - p(k)) ./ p(k) .* randg (n(k), size(k)));
     endif
diff --git a/scripts/statistics/distributions/poissrnd.m b/scripts/statistics/distributions/poissrnd.m
--- a/scripts/statistics/distributions/poissrnd.m
+++ b/scripts/statistics/distributions/poissrnd.m
@@ -35,31 +35,31 @@ function rnd = poissrnd (l, r, c)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("poissrnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("poissrnd: c must be a positive integer");
     endif
     sz = [r, c];
 
-    if (any (size (l) != 1) && 
-        ((length (size (l)) != length (sz)) || any (size (l) != sz)))
+    if (any (size (l) != 1)
+        && ((length (size (l)) != length (sz)) || any (size (l) != sz)))
       error ("poissrnd: lambda must be scalar or of size [r, c]");
     endif
   elseif (nargin == 2)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("poissrnd: r must be a positive integer or vector");
     endif
 
-    if (any (size (l) != 1) && 
-        ((length (size (l)) != length (sz)) || any (size (l) != sz)))
+    if (any (size (l) != 1)
+        && ((length (size (l)) != length (sz)) || any (size (l) != sz)))
       error ("poissrnd: lambda must be scalar or of size sz");
     endif
   elseif (nargin == 1)
     sz = size (l);
   else
     print_usage ();
   endif
 
diff --git a/scripts/statistics/distributions/trnd.m b/scripts/statistics/distributions/trnd.m
--- a/scripts/statistics/distributions/trnd.m
+++ b/scripts/statistics/distributions/trnd.m
@@ -37,31 +37,31 @@ function rnd = trnd (n, r, c)
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("trnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("trnd: c must be a positive integer");
     endif
     sz = [r, c];
 
-    if (any (size (n) != 1) && 
-        ((length (size (n)) != length (sz)) || any (size (n) != sz)))
+    if (any (size (n) != 1)
+        && ((length (size (n)) != length (sz)) || any (size (n) != sz)))
       error ("trnd: n must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("trnd: r must be a positive integer or vector");
     endif
 
-    if (any (size (n) != 1) && 
-        ((length (size (n)) != length (sz)) || any (size (n) != sz)))
+    if (any (size (n) != 1)
+        && ((length (size (n)) != length (sz)) || any (size (n) != sz)))
       error ("trnd: n must be scalar or of size sz");
     endif
   elseif (nargin == 1)
     sz = size (n);
   else
     print_usage ();
   endif
 
diff --git a/scripts/statistics/distributions/wblrnd.m b/scripts/statistics/distributions/wblrnd.m
--- a/scripts/statistics/distributions/wblrnd.m
+++ b/scripts/statistics/distributions/wblrnd.m
@@ -46,33 +46,33 @@ function rnd = wblrnd (scale, shape, r, 
     if (! (isscalar (r) && (r > 0) && (r == round (r))))
       error ("wblrnd: r must be a positive integer");
     endif
     if (! (isscalar (c) && (c > 0) && (c == round (c))))
       error ("wblrnd: c must be a positive integer");
     endif
     sz = [r, c];
 
-    if (any (size (scale) != 1) && 
-        ((length (size (scale)) != length (sz))
-         || any (size (scale) != sz)))
+    if (any (size (scale) != 1)
+        && ((length (size (scale)) != length (sz))
+            || any (size (scale) != sz)))
       error ("wblrnd: scale and shape must be scalar or of size [r, c]");
     endif
   elseif (nargin == 3)
     if (isscalar (r) && (r > 0))
       sz = [r, r];
     elseif (isvector(r) && all (r > 0))
       sz = r(:)';
     else
       error ("wblrnd: r must be a positive integer or vector");
     endif
 
-    if (any (size (scale) != 1) && 
-        ((length (size (scale)) != length (sz))
-         || any (size (scale) != sz)))
+    if (any (size (scale) != 1)
+        && ((length (size (scale)) != length (sz))
+            || any (size (scale) != sz)))
       error ("wblrnd: scale and shape must be scalar or of size sz");
     endif
   elseif (nargin == 2)
     sz = size(scale);
   else
     print_usage ();
   endif
 
diff --git a/scripts/strings/strcat.m b/scripts/strings/strcat.m
--- a/scripts/strings/strcat.m
+++ b/scripts/strings/strcat.m
@@ -102,18 +102,18 @@ endfunction
 %!assert(strcat("ab ", {"ab "}), {"abab "})
 %!assert(strcat({"ab "}, {"ab "}), {"ab ab "})
 %!assert(strcat("", "ab"), "ab")
 %!assert(strcat("", {"ab"}, {""}), {"ab"})
 ## 2d
 %!assert(strcat(["ab ";"cde"], ["ab ";"cde"]), ["abab  ";"cdecde"])
 
 ## test for deblanking implied trailing spaces of character input
-%!assert((strcmp (strcat ("foo", "bar"), "foobar") &&
-%!        strcmp (strcat (["a"; "bb"], ["foo"; "bar"]), ["afoo "; "bbbar"])));
+%!assert((strcmp (strcat ("foo", "bar"), "foobar")
+%!        && strcmp (strcat (["a"; "bb"], ["foo"; "bar"]), ["afoo "; "bbbar"])));
 
 ## test for mixing character and cell inputs
 %!assert(all (strcmp (strcat ("a", {"bc", "de"}, "f"), {"abcf", "adef"})))
 
 ## test for scalar strings with vector strings
 %!assert(all (strcmp (strcat (["a"; "b"], "c"), ["ac"; "bc"])))
 
 ## test with cells with strings of differing lengths
diff --git a/scripts/time/datestr.m b/scripts/time/datestr.m
--- a/scripts/time/datestr.m
+++ b/scripts/time/datestr.m
@@ -192,18 +192,18 @@ function retval = datestr (date, f, p)
   if (iscell (date) || columns (date) != 6)
     v = datevec (date, p);
   else
     v = [];
     if (columns (date) == 6)
       ## Make sure that the input really is a datevec.
       maxdatevec = [Inf, 12, 31, 23, 59, 60];
       for i = 1:numel (maxdatevec)
-        if (any (date(:,i) > maxdatevec(i)) || 
-            (i != 6 && any (floor (date(:, i)) != date (:, i))))
+        if (any (date(:,i) > maxdatevec(i))
+            || (i != 6 && any (floor (date(:,i)) != date(:,i))))
           v = datevec (date, p);
           break;
         endif
       endfor
     endif
     if (isempty (v))
       v = date;
     endif
diff --git a/scripts/time/datetick.m b/scripts/time/datetick.m
--- a/scripts/time/datetick.m
+++ b/scripts/time/datetick.m
@@ -87,18 +87,18 @@ function __datetick__ (varargin)
 
   varargin(idx) = [];
   nargin = length (varargin);
   form = [];
   ax = "x";
 
   if (nargin != 0)
     arg = varargin{1};
-    if (ischar(arg) && (strcmp (arg, "x") || strcmp (arg, "y") || 
-      strcmp (arg, "z")))
+    if (ischar (arg) && (strcmp (arg, "x") || strcmp (arg, "y")
+                         || strcmp (arg, "z")))
       ax = arg;
       if (nargin > 1)
         form = varargin{2};
         varargin(1:2) = [];
       else
         varargin(1) = [];
       endif
     else
