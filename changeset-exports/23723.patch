# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1498870794 14400
#      Fri Jun 30 20:59:54 2017 -0400
# Node ID ab8831d346c1a5cfbf0d0c6f4044947444af8ae0
# Parent  ab9e51f41a29db47e76badfb13436880e293a170
revamp echo command and move related variables inside tree_evaluator class

* pt-stmt.h, pt-stmt.cc (tree_statement::echo_code): New argument,
prefix.  Pass prefix to tree_print_code constructor instead of VPS4.

* basics.txi: Delete documentation for echo_executing_commands.

* interpreter.h, interpreter.cc (interpreter::maximum_braindamage):
Now a member function.
(interpreter::interpreter): Call tree_evaluator::echo directly instead
of using Fecho_executing_commands.  Don't force input to be echoed if
forced_interactive is etst.

* input.h, input.cc (Fecho_executing_commands): Delete.
(Vecho_executing_commands): Delete variable and all uses.
(VPS4): Delete.
(set_default_prompts): Don't set global value for PS4 here.
(base_reader::do_input_echo): Delete.
(gnu_readline): Don't call do_input_echo.

* pt-eval.h, pt-eval.cc (Fecho_executing_commands): Delete.
(FPS4): Move here from input.cc.
(Fecho): Move here from input.cc  Rewrite.  Handle "echo function
on|off" syntax.
(echo_state): Move enum declaration to tree_evaluator class from input.h.

* ov-usr-fcn.cc (octave_user_script::call, octave_user_function::call):
Push echo state before executing commands.  Don't print function
header or trailer here.
(octave_user_function::print_code_function_header,
octave_user_function::print_code_function_trailer): New arg, prefix.
Pass prefix to tree_print_code constructor instead of VPS4.

* pt-eval.h, pt-eval.cc (tree_evaluator::m_PS4,
tree_evaluator::m_echo, tree_evaluator::m_echo_state,
tree_evaluator::m_echo_file_name, tree_evaluator::m_echo_file_pos,
tree_evaluator::m_echo_files): New member variables.

(tree_evaluator::echo_state, tree_evaluator::PS4,
tree_evaluator::echo, tree_evaluator::push_echo_state,
tree_evaluator::set_echo_state, tree_evaluator::set_echo_file_name,
tree_evaluator::set_echo_file_pos, tree_evaluator::echo_this_file,
tree_evaluator::echo_code): New member functions.

(tree_evaluator::visit_break_command,
tree_evaluator::visit_continue_command,
tree_evaluator::visit_decl_command,
tree_evaluator::visit_simple_for_command,
tree_evaluator::visit_complex_for_command,
tree_evaluator::visit_if_command,
tree_evaluator::visit_no_op_command,
tree_evaluator::visit_return_command,
tree_evaluator::visit_switch_command,
tree_evaluator::visit_try_catch_command,
tree_evaluator::visit_unwind_protect_command,
tree_evaluator::visit_while_command,
tree_evaluator::visit_do_until_command):
Manage echo_file_pos and echo code here.

diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -841,18 +841,16 @@ Octave produces in a separate file.
 @DOCSTRING(diary)
 
 Sometimes it is useful to see the commands in a function or script as
 they are being evaluated.  This can be especially helpful for debugging
 some kinds of problems.
 
 @DOCSTRING(echo)
 
-@DOCSTRING(echo_executing_commands)
-
 @node Errors
 @section How Octave Reports Errors
 @cindex error messages
 @cindex messages, error
 
 Octave reports two kinds of errors for invalid programs.
 
 A @dfn{parse error} occurs if Octave cannot understand something you
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -76,28 +76,16 @@ along with Octave; see the file COPYING.
 #include "variables.h"
 
 // Primary prompt string.
 static std::string VPS1;
 
 // Secondary prompt string.
 static std::string VPS2;
 
-// String printed before echoed input (enabled by --echo-input).
-std::string VPS4 = "+ ";
-
-// Echo commands as they are executed?
-//
-//   1  ==>  echo commands read from script files
-//   2  ==>  echo commands from functions
-//   4  ==>  echo commands read from command line
-//
-// more than one state can be active at once.
-int Vecho_executing_commands = ECHO_OFF;
-
 // The time we last printed a prompt.
 octave::sys::time Vlast_prompt_time = 0.0;
 
 // Character to append after successful command-line completion attempts.
 static char Vcompletion_append_char = ' ';
 
 // TRUE after a call to completion_matches.
 bool octave_completion_matches_called = false;
@@ -136,55 +124,21 @@ remove_input_event_hook_functions (void)
 void
 set_default_prompts (void)
 {
   // Use literal "octave" instead of "\\s" to avoid setting the prompt
   // to "octave.exe" or "octave-gui", etc.
 
   VPS1 = "octave:\\#> ";
   VPS2 = "> ";
-  VPS4 = "+ ";
+  std::string VPS4 = "+ ";
 
   octave_link::set_default_prompts (VPS1, VPS2, VPS4);
 }
 
-namespace octave
-{
-  void
-  base_reader::do_input_echo (const std::string& input_string) const
-  {
-    bool forced_interactive = application::forced_interactive ();
-
-    int do_echo = reading_script_file ()
-      ? (Vecho_executing_commands & ECHO_SCRIPTS)
-      : ((Vecho_executing_commands & ECHO_CMD_LINE) && ! forced_interactive);
-
-    if (do_echo)
-      {
-        if (forced_interactive)
-          {
-            if (pflag > 0)
-              octave_stdout << command_editor::decode_prompt_string (VPS1);
-            else
-              octave_stdout << command_editor::decode_prompt_string (VPS2);
-          }
-        else
-          octave_stdout << command_editor::decode_prompt_string (VPS4);
-
-        if (! input_string.empty ())
-          {
-            octave_stdout << input_string;
-
-            if (input_string[input_string.length () - 1] != '\n')
-              octave_stdout << "\n";
-          }
-      }
-  }
-}
-
 static std::string
 gnu_readline (const std::string& s, bool& eof)
 {
   octave_quit ();
 
   eof = false;
 
   std::string retval = octave::command_editor::readline (s, eof);
@@ -303,18 +257,16 @@ namespace octave
             if (command_history::add (retval))
               octave_link::append_history (retval);
           }
 
         octave_diary << retval;
 
         if (retval[retval.length () - 1] != '\n')
           octave_diary << "\n";
-
-        do_input_echo (retval);
       }
     else
       octave_diary << "\n";
 
     // Process post input event hook function after the internal history
     // list has been updated.
 
     if (application::interactive ())
@@ -1020,147 +972,16 @@ If @code{keyboard} is invoked without ar
 
   octave::tree_evaluator::current_frame = cs.current_frame ();
 
   do_keyboard (args);
 
   return ovl ();
 }
 
-DEFUN (echo, args, ,
-       doc: /* -*- texinfo -*-
-@deftypefn  {} {} echo
-@deftypefnx {} {} echo on
-@deftypefnx {} {} echo off
-@deftypefnx {} {} echo on all
-@deftypefnx {} {} echo off all
-Control whether commands are displayed as they are executed.
-
-Valid options are:
-
-@table @code
-@item on
-Enable echoing of commands as they are executed in script files.
-
-@item off
-Disable echoing of commands as they are executed in script files.
-
-@item on all
-Enable echoing of commands as they are executed in script files and
-functions.
-
-@item off all
-Disable echoing of commands as they are executed in script files and
-functions.
-@end table
-
-@noindent
-With no arguments, @code{echo} toggles the current echo state.
-
-@seealso{echo_executing_commands}
-@end deftypefn */)
-{
-  string_vector argv = args.make_argv ();
-
-  switch (args.length ())
-    {
-    case 0:
-      {
-        if ((Vecho_executing_commands & ECHO_SCRIPTS)
-            || (Vecho_executing_commands & ECHO_FUNCTIONS))
-          Vecho_executing_commands = ECHO_OFF;
-        else
-          Vecho_executing_commands = ECHO_SCRIPTS;
-      }
-      break;
-
-    case 1:
-      {
-        std::string arg = argv[0];
-
-        if (arg == "on")
-          Vecho_executing_commands = ECHO_SCRIPTS;
-        else if (arg == "off")
-          Vecho_executing_commands = ECHO_OFF;
-        else
-          print_usage ();
-      }
-      break;
-
-    case 2:
-      {
-        std::string arg = argv[0];
-
-        if (arg == "on" && argv[1] == "all")
-          {
-            int tmp = (ECHO_SCRIPTS | ECHO_FUNCTIONS);
-            Vecho_executing_commands = tmp;
-          }
-        else if (arg == "off" && argv[1] == "all")
-          Vecho_executing_commands = ECHO_OFF;
-        else
-          print_usage ();
-      }
-      break;
-
-    default:
-      print_usage ();
-      break;
-    }
-
-  return ovl ();
-}
-
-/*
-%!test
-%! state = echo_executing_commands ();
-%! unwind_protect
-%!   echo ();
-%!   s1 = echo_executing_commands ();
-%!   assert (s1 != state);
-%!   echo ();
-%!   s2 = echo_executing_commands ();
-%!   assert (s2 != s1);
-%! unwind_protect_cleanup
-%!   echo_executing_commands (state);
-%! end_unwind_protect
-
-%!test
-%! state = echo_executing_commands ();
-%! unwind_protect
-%!   echo ("off");
-%!   assert (echo_executing_commands () == 0);
-%!   echo ("on");
-%!   assert (echo_executing_commands () != 0);
-%!   echo ("off");
-%!   assert (echo_executing_commands () == 0);
-%! unwind_protect_cleanup
-%!   echo_executing_commands (state);
-%! end_unwind_protect
-
-%!#test  # FIXME: This passes, but produces a lot of onscreen output
-%! state = echo_executing_commands ();
-%! unwind_protect
-%!   echo ("on", "all");
-%!   assert (echo_executing_commands () != 0);
-%!   echo ("off", "all");
-%!   assert (echo_executing_commands () == 0);
-%! unwind_protect_cleanup
-%!   echo_executing_commands (state);
-%! end_unwind_protect
-
-%!error echo ([])
-%!error echo (0)
-%!error echo ("")
-%!error echo ("Octave")
-%!error echo ("off", "invalid")
-%!error echo ("on", "invalid")
-%!error echo ("on", "all", "all")
-*/
-
 DEFUN (completion_matches, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} completion_matches (@var{hint})
 Generate possible completions given @var{hint}.
 
 This function is provided for the benefit of programs like Emacs which
 might be controlling Octave and handling user input.  The current
 command number is not incremented when this function is called.  This is
@@ -1432,36 +1253,16 @@ When called from inside a function with 
 variable is changed locally for the function and any subroutines it calls.
 The original variable value is restored when exiting the function.
 @seealso{PS1, PS4}
 @end deftypefn */)
 {
   return SET_INTERNAL_VARIABLE (PS2);
 }
 
-DEFUN (PS4, args, nargout,
-       doc: /* -*- texinfo -*-
-@deftypefn  {} {@var{val} =} PS4 ()
-@deftypefnx {} {@var{old_val} =} PS4 (@var{new_val})
-@deftypefnx {} {} PS4 (@var{new_val}, "local")
-Query or set the character string used to prefix output produced
-when echoing commands is enabled.
-
-The default value is @qcode{"+ "}.
-@xref{Diary and Echo Commands}, for a description of echoing commands.
-
-When called from inside a function with the @qcode{"local"} option, the
-variable is changed locally for the function and any subroutines it calls.
-The original variable value is restored when exiting the function.
-@seealso{echo, echo_executing_commands, PS1, PS2}
-@end deftypefn */)
-{
-  return SET_INTERNAL_VARIABLE (PS4);
-}
-
 DEFUN (completion_append_char, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{val} =} completion_append_char ()
 @deftypefnx {} {@var{old_val} =} completion_append_char (@var{new_val})
 @deftypefnx {} {} completion_append_char (@var{new_val}, "local")
 Query or set the internal character variable that is appended to
 successful command-line completion attempts.
 
@@ -1470,52 +1271,16 @@ The default value is @qcode{" "} (a sing
 When called from inside a function with the @qcode{"local"} option, the
 variable is changed locally for the function and any subroutines it calls.
 The original variable value is restored when exiting the function.
 @end deftypefn */)
 {
   return SET_INTERNAL_VARIABLE (completion_append_char);
 }
 
-DEFUN (echo_executing_commands, args, nargout,
-       doc: /* -*- texinfo -*-
-@deftypefn  {} {@var{val} =} echo_executing_commands ()
-@deftypefnx {} {@var{old_val} =} echo_executing_commands (@var{new_val})
-@deftypefnx {} {} echo_executing_commands (@var{new_val}, "local")
-Query or set the internal variable that controls the echo state.
-
-It may be the sum of the following values:
-
-@table @asis
-@item 1
-Echo commands read from script files.
-
-@item 2
-Echo commands from functions.
-
-@item 4
-Echo commands read from command line.
-@end table
-
-More than one state can be active at once.  For example, a value of 3 is
-equivalent to the command @kbd{echo on all}.
-
-The value of @code{echo_executing_commands} may be set by the @kbd{echo}
-command or the command line option @option{--echo-commands}.
-
-When called from inside a function with the @qcode{"local"} option, the
-variable is changed locally for the function and any subroutines it calls.
-The original variable value is restored when exiting the function.
-
-@seealso{echo}
-@end deftypefn */)
-{
-  return SET_INTERNAL_VARIABLE (echo_executing_commands);
-}
-
 DEFUN (__request_drawnow__, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} __request_drawnow__ ()
 @deftypefnx {} {} __request_drawnow__ (@var{flag})
 Undocumented internal function.
 @end deftypefn */)
 {
   int nargin = args.length ();
diff --git a/libinterp/corefcn/input.h b/libinterp/corefcn/input.h
--- a/libinterp/corefcn/input.h
+++ b/libinterp/corefcn/input.h
@@ -65,30 +65,18 @@ extern bool octave_yes_or_no (const std:
 
 extern octave_value do_keyboard (const octave_value_list& args
                                  = octave_value_list ());
 
 extern void remove_input_event_hook_functions (void);
 
 extern void set_default_prompts (void);
 
-extern std::string VPS4;
-
 extern char Vfilemarker;
 
-enum echo_state
-{
-  ECHO_OFF = 0,
-  ECHO_SCRIPTS = 1,
-  ECHO_FUNCTIONS = 2,
-  ECHO_CMD_LINE = 4
-};
-
-extern int Vecho_executing_commands;
-
 extern octave::sys::time Vlast_prompt_time;
 
 namespace octave
 {
   class
   base_reader
   {
   public:
@@ -141,18 +129,16 @@ namespace octave
   private:
 
     refcount<int> count;
 
     int pflag;
 
     base_lexer *lexer;
 
-    void do_input_echo (const std::string&) const;
-
     static const std::string in_src;
   };
 
   class
   terminal_reader : public base_reader
   {
   public:
 
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -168,43 +168,16 @@ static void
 initialize_error_handlers ()
 {
   set_liboctave_error_handler (lo_error_handler);
   set_liboctave_error_with_id_handler (lo_error_with_id_handler);
   set_liboctave_warning_handler (warning);
   set_liboctave_warning_with_id_handler (warning_with_id);
 }
 
-// What internal options get configured by --traditional.
-
-static void
-maximum_braindamage (void)
-{
-  FPS1 (octave_value (">> "));
-  FPS2 (octave_value (""));
-  FPS4 (octave_value (""));
-  Fbeep_on_error (octave_value (true));
-  Fconfirm_recursive_rmdir (octave_value (false));
-  Fcrash_dumps_octave_core (octave_value (false));
-  Fdisable_diagonal_matrix (octave_value (true));
-  Fdisable_permutation_matrix (octave_value (true));
-  Fdisable_range (octave_value (true));
-  Ffixed_point_format (octave_value (true));
-  Fhistory_timestamp_format_string (octave_value ("%%-- %D %I:%M %p --%%"));
-  Fpage_screen_output (octave_value (false));
-  Fprint_empty_dimensions (octave_value (false));
-  Fsave_default_options (octave_value ("-mat-binary"));
-  Fstruct_levels_to_print (octave_value (0));
-
-  disable_warning ("Octave:abbreviated-property-match");
-  disable_warning ("Octave:data-file-in-path");
-  disable_warning ("Octave:function-name-clash");
-  disable_warning ("Octave:possible-matlab-short-circuit-operator");
-}
-
 DEFUN (quit, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} exit
 @deftypefnx {} {} exit (@var{status})
 @deftypefnx {} {} quit
 @deftypefnx {} {} quit (@var{status})
 Exit the current Octave session.
 
@@ -500,20 +473,18 @@ namespace octave
           line_editing = false;
 
         traditional = options.traditional ();
 
         // FIXME: if possible, perform the following actions directly
         // instead of using the interpreter-level functions.
 
         if (options.echo_commands ())
-          {
-            int val = ECHO_SCRIPTS | ECHO_FUNCTIONS | ECHO_CMD_LINE;
-            Fecho_executing_commands (octave_value (val));
-          }
+          m_evaluator.echo
+            (tree_evaluator::ECHO_SCRIPTS | tree_evaluator::ECHO_FUNCTIONS);
 
         std::string docstrings_file = options.docstrings_file ();
         if (! docstrings_file.empty ())
           Fbuilt_in_docstrings_file (*this, octave_value (docstrings_file));
 
         std::string doc_cache_file = options.doc_cache_file ();
         if (! doc_cache_file.empty ())
           Fdoc_cache_file (*this, octave_value (doc_cache_file));
@@ -695,26 +666,18 @@ namespace octave
 
             if (status)
               exit_status = status;
 
             if (! options.persist ())
               return exit_status;
           }
 
-        // Force input to be echoed if not really interactive,
-        // but the user has forced interactive behavior.
-
         if (options.forced_interactive ())
-          {
-            command_editor::blink_matching_paren (false);
-
-            // FIXME: is this the right thing to do?
-            Fecho_executing_commands (octave_value (ECHO_CMD_LINE));
-          }
+          command_editor::blink_matching_paren (false);
       }
 
     // Avoid counting commands executed from startup or script files.
 
     command_editor::reset_current_command_number (1);
 
     m_initialized = true;
 
@@ -1305,9 +1268,37 @@ namespace octave
             atexit_functions.erase (it);
             found = true;
             break;
           }
       }
 
     return found;
   }
+
+  // What internal options get configured by --traditional.
+
+  void interpreter::maximum_braindamage (void)
+  {
+    FPS1 (octave_value (">> "));
+    FPS2 (octave_value (""));
+
+    m_evaluator.PS4 ("");
+
+    Fbeep_on_error (octave_value (true));
+    Fconfirm_recursive_rmdir (octave_value (false));
+    Fcrash_dumps_octave_core (octave_value (false));
+    Fdisable_diagonal_matrix (octave_value (true));
+    Fdisable_permutation_matrix (octave_value (true));
+    Fdisable_range (octave_value (true));
+    Ffixed_point_format (octave_value (true));
+    Fhistory_timestamp_format_string (octave_value ("%%-- %D %I:%M %p --%%"));
+    Fpage_screen_output (octave_value (false));
+    Fprint_empty_dimensions (octave_value (false));
+    Fsave_default_options (octave_value ("-mat-binary"));
+    Fstruct_levels_to_print (octave_value (0));
+
+    disable_warning ("Octave:abbreviated-property-match");
+    disable_warning ("Octave:data-file-in-path");
+    disable_warning ("Octave:function-name-clash");
+    disable_warning ("Octave:possible-matlab-short-circuit-operator");
+  }
 }
diff --git a/libinterp/corefcn/interpreter.h b/libinterp/corefcn/interpreter.h
--- a/libinterp/corefcn/interpreter.h
+++ b/libinterp/corefcn/interpreter.h
@@ -237,16 +237,18 @@ namespace octave
 
     bool m_inhibit_startup_message;
 
     bool m_load_path_initialized;
 
     bool m_history_initialized;
 
     bool m_initialized;
+
+    void maximum_braindamage (void);
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::interpreter::recover_from_exception' instead")
 static inline void
 recover_from_exception (void)
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -487,50 +487,49 @@ do_edit_history (octave::interpreter& in
 
       edit_history_add_hist (line);
 
       delete [] line;
     }
 
   file.close ();
 
-  // Turn on command echo, so the output from this will make better
-  // sense.
-
   octave::unwind_protect frame;
 
   frame.add_fcn (unlink_cleanup, name.c_str ());
-  frame.protect_var (Vecho_executing_commands);
   frame.protect_var (input_from_tmp_history_file);
 
-  Vecho_executing_commands = ECHO_CMD_LINE;
   input_from_tmp_history_file = true;
 
+  // FIXME: instead of sourcing a file, we should just iterate through
+  // the list of commands, parsing and executing them one at a time as
+  // if they were entered interactively.
+
   octave::source_file (name);
 }
 
 static void
 do_run_history (const octave_value_list& args)
 {
   std::string name = mk_tmp_hist_file (args, false, "run_history");
 
   if (name.empty ())
     return;
 
-  // Turn on command echo so the output from this will make better sense.
-
   octave::unwind_protect frame;
 
   frame.add_fcn (unlink_cleanup, name.c_str ());
-  frame.protect_var (Vecho_executing_commands);
   frame.protect_var (input_from_tmp_history_file);
 
-  Vecho_executing_commands = ECHO_CMD_LINE;
   input_from_tmp_history_file = true;
 
+  // FIXME: instead of sourcing a file, we should just iterate through
+  // the list of commands, parsing and executing them one at a time as
+  // if they were entered interactively.
+
   octave::source_file (name);
 }
 
 void
 initialize_history (bool read_history_file)
 {
   octave::command_history::initialize (read_history_file,
                                        default_history_file (),
@@ -582,16 +581,18 @@ edit_history -1
 @end example
 
 When using ranges, specifying a larger number for the first command than the
 last command reverses the list of commands before they are placed in the
 buffer to be edited.
 @seealso{run_history, history}
 @end deftypefn */)
 {
+  // FIXME: should this be limited to the top-level context?
+
   if (args.length () > 2)
     print_usage ();
 
   do_edit_history (interp, args);
 
   return ovl ();
 }
 
@@ -632,16 +633,18 @@ For example, to display the five most re
 typed without displaying line numbers, use the command
 @kbd{history -q 5}.
 
 If invoked with a single output argument, the history will be saved to that
 argument as a cell string and will not be output to screen.
 @seealso{edit_history, run_history}
 @end deftypefn */)
 {
+  // FIXME: should this be limited to the top-level context?
+
   // Call do_history even if nargout is zero to display history list.
 
   string_vector hlist = do_history (args, nargout);
 
   return nargout > 0 ? ovl (Cell (hlist)) : ovl ();
 }
 
 DEFUN (run_history, args, ,
@@ -691,16 +694,18 @@ run_history -1 -2
  2
  1
 @end group
 @end example
 
 @seealso{edit_history, history}
 @end deftypefn */)
 {
+  // FIXME: should this be limited to the top-level context?
+
   if (args.length () > 2)
     print_usage ();
 
   do_run_history (args);
 
   return ovl ();
 }
 
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -140,16 +140,20 @@ octave_user_script::call (octave::tree_e
       Vtrack_line_num = true;
 
       frame.protect_var (octave::tree_evaluator::statement_context);
       octave::tree_evaluator::statement_context = octave::tree_evaluator::script;
 
       profile_data_accumulator::enter<octave_user_script>
         block (profiler, *this);
 
+      if (tw.echo ())
+        tw.push_echo_state (frame, octave::tree_evaluator::ECHO_SCRIPTS,
+                            file_name);
+
       cmd_list->accept (tw);
 
       if (octave::tree_return_command::returning)
         octave::tree_return_command::returning = 0;
 
       if (octave::tree_break_command::breaking)
         octave::tree_break_command::breaking--;
     }
@@ -543,30 +547,29 @@ octave_user_function::call (octave::tree
       frame.add_method (m_scope, &octave::symbol_table::scope::clear_variables);
     }
 
   bind_automatic_vars (tw, arg_names, args.length (), nargout,
                        all_va_args (args));
 
   frame.add_method (this, &octave_user_function::restore_warning_states);
 
-  bool echo_commands = (Vecho_executing_commands & ECHO_FUNCTIONS);
-
-  if (echo_commands)
-    print_code_function_header ();
-
   // Evaluate the commands that make up the function.
 
   frame.protect_var (octave::tree_evaluator::statement_context);
   octave::tree_evaluator::statement_context = octave::tree_evaluator::function;
 
   {
     profile_data_accumulator::enter<octave_user_function>
       block (profiler, *this);
 
+    if (tw.echo ())
+      tw.push_echo_state (frame, octave::tree_evaluator::ECHO_FUNCTIONS,
+                          file_name);
+
     if (is_special_expr ())
       {
         assert (cmd_list->length () == 1);
 
         octave::tree_statement *stmt = cmd_list->front ();
 
         octave::tree_expression *expr = stmt->expression ();
 
@@ -576,19 +579,16 @@ octave_user_function::call (octave::tree
 
             retval = tw.evaluate_n (expr, nargout);
           }
       }
     else
       cmd_list->accept (tw);
   }
 
-  if (echo_commands)
-    print_code_function_trailer ();
-
   if (octave::tree_return_command::returning)
     octave::tree_return_command::returning = 0;
 
   if (octave::tree_break_command::breaking)
     octave::tree_break_command::breaking--;
 
   // Copy return values out.
 
@@ -696,27 +696,27 @@ octave_user_function::dump (void) const
        { "class_method", class_method },
        { "parent_scope", parent_scope ? parent_scope->name () : "0x0" },
        { "scope_info", m_scope ? m_scope->dump () : "0x0" }};
 
   return octave_value (m);
 }
 
 void
-octave_user_function::print_code_function_header (void)
+octave_user_function::print_code_function_header (const std::string& prefix)
 {
-  octave::tree_print_code tpc (octave_stdout, VPS4);
+  octave::tree_print_code tpc (octave_stdout, prefix);
 
   tpc.visit_octave_user_function_header (*this);
 }
 
 void
-octave_user_function::print_code_function_trailer (void)
+octave_user_function::print_code_function_trailer (const std::string& prefix)
 {
-  octave::tree_print_code tpc (octave_stdout, VPS4);
+  octave::tree_print_code tpc (octave_stdout, prefix);
 
   tpc.visit_octave_user_function_trailer (*this);
 }
 
 void
 octave_user_function::bind_automatic_vars
   (octave::tree_evaluator& tw, const string_vector& arg_names,
    int nargin, int nargout, const octave_value_list& va_args)
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -468,19 +468,19 @@ private:
   octave::unwind_protect *curr_unwind_protect_frame;
 
 #if defined (HAVE_LLVM)
   jit_function_info *jit_info;
 #endif
 
   void maybe_relocate_end_internal (void);
 
-  void print_code_function_header (void);
+  void print_code_function_header (const std::string& prefix);
 
-  void print_code_function_trailer (void);
+  void print_code_function_trailer (const std::string& prefix);
 
   void bind_automatic_vars (octave::tree_evaluator& tw,
                             const string_vector& arg_names,
                             int nargin, int nargout,
                             const octave_value_list& va_args);
 
   void restore_warning_states (void);
 
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -26,16 +26,19 @@ along with Octave; see the file COPYING.
 
 #include <cctype>
 
 #include <iostream>
 
 #include <fstream>
 #include <typeinfo>
 
+#include "cmd-edit.h"
+#include "oct-env.h"
+
 #include "bp-table.h"
 #include "call-stack.h"
 #include "defun.h"
 #include "error.h"
 #include "errwarn.h"
 #include "input.h"
 #include "interpreter-private.h"
 #include "interpreter.h"
@@ -44,16 +47,17 @@ along with Octave; see the file COPYING.
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 #include "profiler.h"
 #include "pt-all.h"
 #include "pt-eval.h"
 #include "pt-tm-const.h"
 #include "symtab.h"
 #include "unwind-prot.h"
+#include "utils.h"
 #include "variables.h"
 
 //FIXME: This should be part of tree_evaluator
 #include "pt-jit.h"
 
 namespace octave
 {
   int tree_evaluator::dbstep_flag = 0;
@@ -314,16 +318,23 @@ namespace octave
       }
 
     m_value_stack.push (ovl (val));
   }
 
   void
   tree_evaluator::visit_break_command (tree_break_command& cmd)
   {
+    if (m_echo_state)
+      {
+        size_t line = cmd.line ();
+        echo_code (line);
+        m_echo_file_pos = line + 1;
+      }
+
     if (debug_mode)
       do_breakpoint (cmd.is_breakpoint (true));
 
     if (in_loop_command)
       tree_break_command::breaking = 1;
     else
       error ("break must appear in a loop in the same file as loop command");
   }
@@ -389,16 +400,23 @@ namespace octave
       }
 
     m_value_stack.push (ovl (val));
   }
 
   void
   tree_evaluator::visit_continue_command (tree_continue_command& cmd)
   {
+    if (m_echo_state)
+      {
+        size_t line = cmd.line ();
+        echo_code (line);
+        m_echo_file_pos = line + 1;
+      }
+
     if (debug_mode)
       do_breakpoint (cmd.is_breakpoint (true));
 
     if (in_loop_command)
       tree_continue_command::continuing = 1;
   }
 
   bool
@@ -656,16 +674,23 @@ namespace octave
       }
 
     return false;
   }
 
   void
   tree_evaluator::visit_decl_command (tree_decl_command& cmd)
   {
+    if (m_echo_state)
+      {
+        size_t line = cmd.line ();
+        echo_code (line);
+        m_echo_file_pos = line + 1;
+      }
+
     if (debug_mode)
       do_breakpoint (cmd.is_breakpoint (true));
 
     tree_decl_init_list *init_list = cmd.initializer_list ();
 
     if (init_list)
       init_list->accept (*this);
   }
@@ -731,16 +756,24 @@ quit_loop_now (void)
   return quit;
 }
 
 namespace octave
 {
   void
   tree_evaluator::visit_simple_for_command (tree_simple_for_command& cmd)
   {
+    size_t line = cmd.line ();
+
+    if (m_echo_state)
+      {
+        echo_code (line);
+        line++;
+      }
+
     if (debug_mode)
       do_breakpoint (cmd.is_breakpoint (true));
 
     // FIXME: need to handle PARFOR loops here using cmd.in_parallel ()
     // and cmd.maxproc_expr ();
 
     unwind_protect frame;
 
@@ -769,29 +802,35 @@ namespace octave
     if (rhs.is_range ())
       {
         Range rng = rhs.range_value ();
 
         octave_idx_type steps = rng.numel ();
 
         for (octave_idx_type i = 0; i < steps; i++)
           {
+            if (m_echo_state)
+              m_echo_file_pos = line;
+
             octave_value val (rng.elem (i));
 
             ult.assign (octave_value::op_asn_eq, val);
 
             if (loop_body)
               loop_body->accept (*this);
 
             if (quit_loop_now ())
               break;
           }
       }
     else if (rhs.is_scalar_type ())
       {
+        if (m_echo_state)
+          m_echo_file_pos = line;
+
         ult.assign (octave_value::op_asn_eq, rhs);
 
         if (loop_body)
           loop_body->accept (*this);
 
         // Maybe decrement break and continue states.
         quit_loop_now ();
       }
@@ -825,16 +864,19 @@ namespace octave
               {
                 idx.resize (2);
                 idx(0) = octave_value::magic_colon_t;
                 iidx = 1;
               }
 
             for (octave_idx_type i = 1; i <= steps; i++)
               {
+                if (m_echo_state)
+                  m_echo_file_pos = line;
+
                 // do_index_op expects one-based indices.
                 idx(iidx) = i;
                 octave_value val = arg.do_index_op (idx);
 
                 ult.assign (octave_value::op_asn_eq, val);
 
                 if (loop_body)
                   loop_body->accept (*this);
@@ -852,16 +894,24 @@ namespace octave
     else
       error ("invalid type in for loop expression near line %d, column %d",
              cmd.line (), cmd.column ());
   }
 
   void
   tree_evaluator::visit_complex_for_command (tree_complex_for_command& cmd)
   {
+    size_t line = cmd.line ();
+
+    if (m_echo_state)
+      {
+        echo_code (line);
+        line++;
+      }
+
     if (debug_mode)
       do_breakpoint (cmd.is_breakpoint (true));
 
     unwind_protect frame;
 
     frame.protect_var (in_loop_command);
 
     in_loop_command = true;
@@ -897,16 +947,19 @@ namespace octave
     tree_statement_list *loop_body = cmd.body ();
 
     string_vector keys = tmp_val.keys ();
 
     octave_idx_type nel = keys.numel ();
 
     for (octave_idx_type i = 0; i < nel; i++)
       {
+        if (m_echo_state)
+          m_echo_file_pos = line;
+
         std::string key = keys[i];
 
         const Cell val_lst = tmp_val.contents (key);
 
         octave_idx_type n = val_lst.numel ();
 
         octave_value val = (n == 1) ? val_lst(0) : octave_value (val_lst);
 
@@ -1031,16 +1084,23 @@ namespace octave
   tree_evaluator::visit_if_clause (tree_if_clause&)
   {
     panic_impossible ();
   }
 
   void
   tree_evaluator::visit_if_command (tree_if_command& cmd)
   {
+    if (m_echo_state)
+      {
+        size_t line = cmd.line ();
+        echo_code (line);
+        m_echo_file_pos = line + 1;
+      }
+
     tree_if_command_list *lst = cmd.cmd_list ();
 
     if (lst)
       lst->accept (*this);
   }
 
   void
   tree_evaluator::visit_if_command_list (tree_if_command_list& lst)
@@ -1817,16 +1877,23 @@ namespace octave
       }
 
     m_value_stack.push (val);
   }
 
   void
   tree_evaluator::visit_no_op_command (tree_no_op_command& cmd)
   {
+    if (m_echo_state)
+      {
+        size_t line = cmd.line ();
+        echo_code (line);
+        m_echo_file_pos = line + 1;
+      }
+
     if (debug_mode && cmd.is_end_of_fcn_or_script ())
       do_breakpoint (cmd.is_breakpoint (true), true);
   }
 
   void
   tree_evaluator::visit_constant (tree_constant& expr)
   {
     int nargout = m_nargout_stack.top ();
@@ -1966,16 +2033,23 @@ namespace octave
       }
 
     m_value_stack.push (ovl (val));
   }
 
   void
   tree_evaluator::visit_return_command (tree_return_command& cmd)
   {
+    if (m_echo_state)
+      {
+        size_t line = cmd.line ();
+        echo_code (line);
+        m_echo_file_pos = line + 1;
+      }
+
     if (debug_mode)
       do_breakpoint (cmd.is_breakpoint (true));
 
     // Act like dbcont.
 
     if (Vdebugging && m_call_stack.current_frame () == current_frame)
       {
         Vdebugging = false;
@@ -2083,32 +2157,31 @@ namespace octave
       {
         if (statement_context == function || statement_context == script)
           {
             // Skip commands issued at a debug> prompt to avoid disturbing
             // the state of the program we are debugging.
 
             if (Vtrack_line_num)
               m_call_stack.set_location (stmt.line (), stmt.column ());
-
-            if ((statement_context == script
-                 && ((Vecho_executing_commands & ECHO_SCRIPTS
-                      && m_call_stack.all_scripts ())
-                     || Vecho_executing_commands & ECHO_FUNCTIONS))
-                || (statement_context == function
-                    && Vecho_executing_commands & ECHO_FUNCTIONS))
-              stmt.echo_code ();
           }
 
         try
           {
             if (cmd)
               cmd->accept (*this);
             else
               {
+                if (m_echo_state)
+                  {
+                    size_t line = stmt.line ();
+                    echo_code (line);
+                    m_echo_file_pos = line + 1;
+                  }
+
                 if (debug_mode)
                   do_breakpoint (expr->is_breakpoint (true));
 
                 // FIXME: maybe all of this should be packaged in
                 // one virtual function that returns a flag saying whether
                 // or not the expression will take care of binding ans and
                 // printing the result.
 
@@ -2211,16 +2284,23 @@ namespace octave
   tree_evaluator::visit_switch_case_list (tree_switch_case_list&)
   {
     panic_impossible ();
   }
 
   void
   tree_evaluator::visit_switch_command (tree_switch_command& cmd)
   {
+    if (m_echo_state)
+      {
+        size_t line = cmd.line ();
+        echo_code (line);
+        m_echo_file_pos = line + 1;
+      }
+
     if (debug_mode)
       do_breakpoint (cmd.is_breakpoint (true));
 
     tree_expression *expr = cmd.switch_value ();
 
     if (! expr)
       error ("missing value in switch command near line %d, column %d",
              cmd.line (), cmd.column ());
@@ -2244,16 +2324,23 @@ namespace octave
               }
           }
       }
   }
 
   void
   tree_evaluator::visit_try_catch_command (tree_try_catch_command& cmd)
   {
+    if (m_echo_state)
+      {
+        size_t line = cmd.line ();
+        echo_code (line);
+        m_echo_file_pos = line + 1;
+      }
+
     bool execution_error = false;
 
     {
       // unwind frame before catch block
       unwind_protect frame;
 
       frame.protect_var (buffer_error_messages);
       frame.protect_var (Vdebug_on_error);
@@ -2394,16 +2481,23 @@ namespace octave
       frame.discard (2);
     else
       frame.run (2);
   }
 
   void
   tree_evaluator::visit_unwind_protect_command (tree_unwind_protect_command& cmd)
   {
+    if (m_echo_state)
+      {
+        size_t line = cmd.line ();
+        echo_code (line);
+        m_echo_file_pos = line + 1;
+      }
+
     tree_statement_list *cleanup_code = cmd.cleanup ();
 
     tree_statement_list *unwind_protect_code = cmd.body ();
 
     if (unwind_protect_code)
       {
         try
           {
@@ -2437,16 +2531,24 @@ namespace octave
         // unwind_protect block runs without error.
         do_unwind_protect_cleanup_code (cleanup_code);
       }
   }
 
   void
   tree_evaluator::visit_while_command (tree_while_command& cmd)
   {
+    size_t line = cmd.line ();
+
+    if (m_echo_state)
+      {
+        echo_code (line);
+        line++;
+      }
+
 #if defined (HAVE_LLVM)
     if (tree_jit::execute (cmd))
       return;
 #endif
 
     unwind_protect frame;
 
     frame.protect_var (in_loop_command);
@@ -2455,16 +2557,19 @@ namespace octave
 
     tree_expression *expr = cmd.condition ();
 
     if (! expr)
       panic_impossible ();
 
     for (;;)
       {
+        if (m_echo_state)
+          m_echo_file_pos = line;
+
         if (debug_mode)
           do_breakpoint (cmd.is_breakpoint (true));
 
         if (is_logically_true (expr, "while"))
           {
             tree_statement_list *loop_body = cmd.body ();
 
             if (loop_body)
@@ -2476,16 +2581,24 @@ namespace octave
         else
           break;
       }
   }
 
   void
   tree_evaluator::visit_do_until_command (tree_do_until_command& cmd)
   {
+    size_t line = cmd.line ();
+
+    if (m_echo_state)
+      {
+        echo_code (line);
+        line++;
+      }
+
 #if defined (HAVE_LLVM)
     if (tree_jit::execute (cmd))
       return;
 #endif
 
     unwind_protect frame;
 
     frame.protect_var (in_loop_command);
@@ -2496,16 +2609,19 @@ namespace octave
     int until_line = cmd.line ();
     int until_column = cmd.column ();
 
     if (! expr)
       panic_impossible ();
 
     for (;;)
       {
+        if (m_echo_state)
+          m_echo_file_pos = line;
+
         tree_statement_list *loop_body = cmd.body ();
 
         if (loop_body)
           loop_body->accept (*this);
 
         if (quit_loop_now ())
           break;
 
@@ -2722,22 +2838,211 @@ namespace octave
 
   octave_value
   tree_evaluator::silent_functions (const octave_value_list& args, int nargout)
   {
     return set_internal_variable (m_silent_functions, args, nargout,
                                   "silent_functions");
   }
 
+  void
+  tree_evaluator::push_echo_state (unwind_protect& frame, int type,
+                                   const std::string& file_name)
+  {
+    frame.add_method (*this, &tree_evaluator::set_echo_state,
+                      m_echo_state);
+
+    frame.add_method (*this, &tree_evaluator::set_echo_file_name,
+                      m_echo_file_name);
+
+    frame.add_method (*this, &tree_evaluator::set_echo_file_pos,
+                      m_echo_file_pos);
+
+    m_echo_state = echo_this_file (file_name, type);
+    m_echo_file_name = file_name;
+    m_echo_file_pos = 1;
+  }
+
   octave_value
   tree_evaluator::string_fill_char (const octave_value_list& args, int nargout)
   {
     return set_internal_variable (m_string_fill_char, args, nargout,
                                   "string_fill_char");
   }
+
+  octave_value
+  tree_evaluator::echo (const octave_value_list& args, int)
+  {
+    string_vector argv = args.make_argv ();
+
+    switch (args.length ())
+      {
+      case 0:
+        if ((m_echo & ECHO_SCRIPTS) || (m_echo & ECHO_FUNCTIONS))
+          {
+            m_echo = ECHO_OFF;
+            m_echo_files.clear ();
+          }
+        else
+          m_echo = ECHO_SCRIPTS;
+        break;
+
+      case 1:
+        {
+          std::string arg0 = argv[0];
+
+          if (arg0 == "on")
+            m_echo = ECHO_SCRIPTS;
+          else if (arg0 == "off")
+            m_echo = ECHO_OFF;
+          else
+            {
+              std::string file = fcn_file_in_path (arg0);
+              file = sys::env::make_absolute (file);
+
+              if (file.empty ())
+                error ("echo: no such file %s", arg0.c_str ());
+
+              if (m_echo & ECHO_ALL)
+                {
+                  // Echo is enabled for all functions, so turn it off
+                  // for this one.
+
+                  m_echo_files[file] = false;
+                }
+              else
+                {
+                  // Echo may be enabled for specific functions.
+
+                  auto p = m_echo_files.find (file);
+
+                  if (p == m_echo_files.end ())
+                    {
+                      // Not this one, so enable it.
+
+                      m_echo |= ECHO_FUNCTIONS;
+                      m_echo_files[file] = true;
+                    }
+                  else
+                    {
+                      // This one is already in the list.  Flip the
+                      // status for it.
+
+                      p->second = ! p->second;
+                    }
+                }
+            }
+        }
+        break;
+
+      case 2:
+        {
+          std::string arg0 = argv[0];
+          std::string arg1 = argv[1];
+
+          if (arg1 == "on" || arg1 == "off")
+            std::swap (arg0, arg1);
+
+          if (arg0 == "on")
+            {
+              if (arg1 == "all")
+                {
+                  m_echo = (ECHO_SCRIPTS | ECHO_FUNCTIONS | ECHO_ALL);
+                  m_echo_files.clear ();
+                }
+              else
+                {
+                  std::string file = fcn_file_in_path (arg1);
+                  file = sys::env::make_absolute (file);
+
+                  if (file.empty ())
+                    error ("echo: no such file %s", arg1.c_str ());
+
+                  m_echo |= ECHO_FUNCTIONS;
+                  m_echo_files[file] = true;
+                }
+            }
+          else if (arg0 == "off")
+            {
+              if (arg1 == "all")
+                {
+                  m_echo = ECHO_OFF;
+                  m_echo_files.clear ();
+                }
+              else
+                {
+                  std::string file = fcn_file_in_path (arg1);
+                  file = sys::env::make_absolute (file);
+
+                  if (file.empty ())
+                    error ("echo: no such file %s", arg1.c_str ());
+
+                  m_echo_files[file] = false;
+                }
+            }
+          else
+            print_usage ();
+        }
+        break;
+
+      default:
+        print_usage ();
+        break;
+      }
+
+    return ovl ();
+  }
+
+  octave_value
+  tree_evaluator::PS4 (const octave_value_list& args, int nargout)
+  {
+    return set_internal_variable (m_PS4, args, nargout, "PS4");
+  }
+
+  bool tree_evaluator::echo_this_file (const std::string& file, int type) const
+  {
+    if ((type & m_echo) == ECHO_SCRIPTS)
+      {
+        // Asking about scripts and echo is enabled for them.
+        return true;
+      }
+
+    if ((type & m_echo) == ECHO_FUNCTIONS)
+      {
+        // Asking about functions and echo is enabled for functions.
+        // Now, which ones?
+
+        auto p = m_echo_files.find (file);
+
+        if (m_echo & ECHO_ALL)
+          {
+            // Return true ulness echo was turned off for a specific
+            // file.
+
+            return (p == m_echo_files.end () || p->second);
+          }
+        else
+          {
+            // Return true if echo is specifically enabled for this file.
+
+            return p != m_echo_files.end () && p->second;
+          }
+      }
+
+    return false;
+  }
+
+  void tree_evaluator::echo_code (size_t line)
+  {
+    std::string prefix = command_editor::decode_prompt_string (m_PS4);
+
+    for (size_t i = m_echo_file_pos; i <= line; i++)
+      octave_stdout << prefix << get_file_line (m_echo_file_name, i)
+                    << std::endl;
+  }
 }
 
 DEFMETHOD (max_recursion_depth, interp, args, nargout,
            doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{val} =} max_recursion_depth ()
 @deftypefnx {} {@var{old_val} =} max_recursion_depth (@var{new_val})
 @deftypefnx {} {} max_recursion_depth (@var{new_val}, "local")
 Query or set the internal limit on the number of times a function may
@@ -2845,8 +3150,86 @@ The original variable value is restored 
 %! assert (["these"; "are"; "strings"], ["theseXX"; "areXXXX"; "strings"]);
 %! string_fill_char (orig_val);
 %! assert (string_fill_char (), orig_val);
 
 %!assert ( [ [], {1} ], {1} )
 
 %!error (string_fill_char (1, 2))
 */
+
+DEFMETHOD (PS4, interp, args, nargout,
+           doc: /* -*- texinfo -*-
+@deftypefn  {} {@var{val} =} PS4 ()
+@deftypefnx {} {@var{old_val} =} PS4 (@var{new_val})
+@deftypefnx {} {} PS4 (@var{new_val}, "local")
+Query or set the character string used to prefix output produced
+when echoing commands is enabled.
+
+The default value is @qcode{"+ "}.
+@xref{Diary and Echo Commands}, for a description of echoing commands.
+
+When called from inside a function with the @qcode{"local"} option, the
+variable is changed locally for the function and any subroutines it calls.
+The original variable value is restored when exiting the function.
+@seealso{echo, PS1, PS2}
+@end deftypefn */)
+{
+  octave::tree_evaluator& tw = interp.get_evaluator ();
+
+  return tw.PS4 (args, nargout);
+}
+
+DEFMETHOD (echo, interp, args, nargout,
+           doc: /* -*- texinfo -*-
+@deftypefn  {} {} echo
+@deftypefnx {} {} echo on
+@deftypefnx {} {} echo off
+@deftypefnx {} {} echo on all
+@deftypefnx {} {} echo off all
+@deftypefnx {} {} echo @var{function} on
+@deftypefnx {} {} echo @var{function} off
+Control whether commands are displayed as they are executed.
+
+Valid options are:
+
+@table @code
+@item on
+Enable echoing of commands as they are executed in script files.
+
+@item off
+Disable echoing of commands as they are executed in script files.
+
+@item on all
+Enable echoing of commands as they are executed in script files and
+functions.
+
+@item off all
+Disable echoing of commands as they are executed in script files and
+functions.
+
+@item @var{function} on
+Enable echoing of commands as they are executed in the named function.
+
+@item @var{function} off
+Disable echoing of commands as they are executed in the named function.
+@end table
+
+@noindent
+With no arguments, @code{echo} toggles the current echo state.
+
+@seealso{PS4}
+@end deftypefn */)
+{
+  octave::tree_evaluator& tw = interp.get_evaluator ();
+
+  return tw.echo (args, nargout);
+}
+
+/*
+%!error echo ([])
+%!error echo (0)
+%!error echo ("")
+%!error echo ("Octave")
+%!error echo ("off", "invalid")
+%!error echo ("on", "invalid")
+%!error echo ("on", "all", "all")
+*/
diff --git a/libinterp/parse-tree/pt-eval.h b/libinterp/parse-tree/pt-eval.h
--- a/libinterp/parse-tree/pt-eval.h
+++ b/libinterp/parse-tree/pt-eval.h
@@ -21,38 +21,48 @@ along with Octave; see the file COPYING.
 */
 
 #if ! defined (octave_pt_eval_h)
 #define octave_pt_eval_h 1
 
 #include "octave-config.h"
 
 #include <list>
+#include <set>
 #include <stack>
 #include <string>
 
 #include "call-stack.h"
 #include "comment-list.h"
 #include "ovl.h"
 #include "pt-exp.h"
 #include "pt-walk.h"
 
 namespace octave
 {
   class tree_decl_elt;
   class tree_expression;
 
   class interpreter;
+  class unwind_protect;
 
   // How to evaluate the code that the parse trees represent.
 
   class OCTINTERP_API tree_evaluator : public tree_walker
   {
   public:
 
+    enum echo_state
+    {
+      ECHO_OFF = 0,
+      ECHO_SCRIPTS = 1,
+      ECHO_FUNCTIONS = 2,
+      ECHO_ALL = 4
+    };
+
     template <typename T>
     class value_stack
     {
     public:
 
       value_stack (void) = default;
 
       value_stack (const value_stack&) = default;
@@ -102,17 +112,19 @@ namespace octave
     };
 
     typedef void (*decl_elt_init_fcn) (tree_decl_elt&);
 
     tree_evaluator (interpreter& interp)
       : m_interpreter (interp), m_value_stack (), m_lvalue_list_stack (),
         m_nargout_stack (), m_call_stack (interp),
         m_max_recursion_depth (256), m_silent_functions (false),
-        m_string_fill_char (' ')
+        m_string_fill_char (' '), m_PS4 ("+ "), m_echo (ECHO_OFF),
+        m_echo_state (false), m_echo_file_name (), m_echo_file_pos (1),
+        m_echo_files ()
     { }
 
     // No copying!
 
     tree_evaluator (const tree_evaluator&) = delete;
 
     tree_evaluator& operator = (const tree_evaluator&) = delete;
 
@@ -326,16 +338,41 @@ namespace octave
 
     char string_fill_char (char c)
     {
       int val = m_string_fill_char;
       m_string_fill_char = c;
       return val;
     }
 
+    octave_value PS4 (const octave_value_list& args, int nargout);
+
+    std::string PS4 (void) const { return m_PS4; }
+
+    std::string PS4 (const std::string& s)
+    {
+      std::string val = m_PS4;
+      m_PS4 = s;
+      return val;
+    }
+
+    octave_value echo (const octave_value_list& args, int nargout);
+
+    int echo (void) const { return m_echo; }
+
+    int echo (int val)
+    {
+      int old_val = m_echo;
+      m_echo = val;
+      return old_val;
+    }
+
+    void push_echo_state (unwind_protect& frame, int type,
+                          const std::string& file_name);
+
     octave_value
     string_fill_char (const octave_value_list& args, int nargout);
 
   private:
 
     void do_breakpoint (tree_statement& stmt) const;
 
     void do_breakpoint (bool is_breakpoint,
@@ -348,16 +385,35 @@ namespace octave
 
     octave_value_list
     make_value_list (tree_argument_list *args,
                      const string_vector& arg_nm,
                      const octave_value *object, bool rvalue = true);
 
     std::list<octave_lvalue> make_lvalue_list (tree_argument_list *);
 
+    // For unwind-protect.
+    void set_echo_state (bool val) { m_echo_state = val; }
+
+    // For unwind-protect.
+    void set_echo_file_name (const std::string& file_name)
+    {
+      m_echo_file_name = file_name;
+    }
+
+    // For unwind-protect.
+    void set_echo_file_pos (const size_t& file_pos)
+    {
+      m_echo_file_pos = file_pos;
+    }
+
+    bool echo_this_file (const std::string& file, int type) const;
+
+    void echo_code (size_t line);
+
     interpreter& m_interpreter;
 
     value_stack<octave_value_list> m_value_stack;
 
     value_stack<const std::list<octave_lvalue>*> m_lvalue_list_stack;
 
     value_stack<int> m_nargout_stack;
 
@@ -368,16 +424,36 @@ namespace octave
     int m_max_recursion_depth;
 
     // If TRUE, turn off printing of results in functions (as if a
     // semicolon has been appended to each statement).
     bool m_silent_functions;
 
     // The character to fill with when creating string arrays.
     char m_string_fill_char;
+
+    // String printed before echoed commands (enabled by --echo-commands).
+    std::string m_PS4;
+
+    // Echo commands as they are executed?
+    //
+    //   1  ==>  echo commands read from script files
+    //   2  ==>  echo commands from functions
+    //
+    // more than one state can be active at once.
+    int m_echo;
+
+    // Are we currently echoing commands?  This state is set by the
+    // functions that execute fucntions and scripts.
+    bool m_echo_state;
+
+    std::string m_echo_file_name;
+    size_t m_echo_file_pos;
+
+    std::map<std::string, bool> m_echo_files;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::tree_evaluator' instead")
 typedef octave::tree_evaluator tree_evaluator;
 
diff --git a/libinterp/parse-tree/pt-stmt.cc b/libinterp/parse-tree/pt-stmt.cc
--- a/libinterp/parse-tree/pt-stmt.cc
+++ b/libinterp/parse-tree/pt-stmt.cc
@@ -117,19 +117,19 @@ namespace octave
   {
     if (cmd)
       cmd->set_location (l, c);
     else if (expr)
       expr->set_location (l, c);
   }
 
   void
-  tree_statement::echo_code (void)
+  tree_statement::echo_code (const std::string& prefix)
   {
-    tree_print_code tpc (octave_stdout, VPS4);
+    tree_print_code tpc (octave_stdout, prefix);
 
     accept (tpc);
   }
 
   bool
   tree_statement::is_end_of_fcn_or_script (void) const
   {
     bool retval = false;
diff --git a/libinterp/parse-tree/pt-stmt.h b/libinterp/parse-tree/pt-stmt.h
--- a/libinterp/parse-tree/pt-stmt.h
+++ b/libinterp/parse-tree/pt-stmt.h
@@ -80,17 +80,17 @@ namespace octave
     bool is_breakpoint (bool check_valid = false) const;
     std::string bp_cond () const;
 
     int line (void) const;
     int column (void) const;
 
     void set_location (int l, int c);
 
-    void echo_code (void);
+    void echo_code (const std::string& prefix);
 
     tree_command * command (void) { return cmd; }
 
     tree_expression * expression (void) { return expr; }
 
     octave_comment_list * comment_text (void) { return comm; }
 
     bool is_null_statement (void) const { return ! (cmd || expr || comm); }
