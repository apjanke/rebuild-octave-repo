# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1482857910 18000
#      Tue Dec 27 11:58:30 2016 -0500
# Node ID 0d1422cb7e936ddeef09f72781e9f0c72a1116c2
# Parent  12e4534d68b1fbd7950259f961def1d05e95ddce
use F77_INT instead of octave_idx_type for liboctave ODE and DAE classes

* DASPK.cc, DASRT.cc, DASSL.cc, LSODE.cc: Use F77_INT instead of
octave_idx_type for integer data passed to Fortran subroutines.
* DASPK.h, DASRT.h, DASSL.h, LSODE.h: Use octave_f77_int_type as
needed in public interface files.

diff --git a/liboctave/numeric/DASPK.cc b/liboctave/numeric/DASPK.cc
--- a/liboctave/numeric/DASPK.cc
+++ b/liboctave/numeric/DASPK.cc
@@ -29,126 +29,122 @@ along with Octave; see the file COPYING.
 #include <sstream>
 
 #include "DASPK.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-math.h"
 #include "quit.h"
 
-typedef octave_idx_type (*daspk_fcn_ptr) (const double&, const double*,
-                                          const double*, const double&,
-                                          double*, octave_idx_type&,
-                                          double*, octave_idx_type*);
+typedef F77_INT (*daspk_fcn_ptr) (const double&, const double*, const double*,
+                                  const double&, double*, F77_INT&, double*,
+                                  F77_INT*);
+
+typedef F77_INT (*daspk_jac_ptr) (const double&, const double*, const double*,
+                                  double*, const double&, double*, F77_INT*);
 
-typedef octave_idx_type (*daspk_jac_ptr) (const double&, const double*,
-                                          const double*, double*,
-                                          const double&, double*,
-                                          octave_idx_type*);
-
-typedef octave_idx_type (*daspk_psol_ptr) (const octave_idx_type&,
-                                           const double&, const double*,
-                                           const double*, const double*,
-                                           const double&, const double*,
-                                           double*, octave_idx_type*,
-                                           double*, const double&,
-                                           octave_idx_type&, double*,
-                                           octave_idx_type*);
+typedef F77_INT (*daspk_psol_ptr) (const F77_INT&, const double&,
+                                   const double*, const double*,
+                                   const double*, const double&,
+                                   const double*, double*, F77_INT*,
+                                   double*, const double&, F77_INT&,
+                                   double*, F77_INT*);
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (ddaspk, DDASPK) (daspk_fcn_ptr, const F77_INT&,
-                             F77_DBLE&, F77_DBLE*, F77_DBLE*, F77_DBLE&,
-                             const F77_INT*, const F77_DBLE*,
-                             const F77_DBLE*, F77_INT&,
-                             F77_DBLE*, const F77_INT&,
-                             F77_INT*, const F77_INT&,
-                             const F77_DBLE*, const F77_INT*,
+  F77_FUNC (ddaspk, DDASPK) (daspk_fcn_ptr, const F77_INT&, F77_DBLE&,
+                             F77_DBLE*, F77_DBLE*, F77_DBLE&, const F77_INT*,
+                             const F77_DBLE*, const F77_DBLE*, F77_INT&,
+                             F77_DBLE*, const F77_INT&, F77_INT*,
+                             const F77_INT&, const F77_DBLE*, const F77_INT*,
                              daspk_jac_ptr, daspk_psol_ptr);
 }
 
 static DAEFunc::DAERHSFunc user_fun;
 static DAEFunc::DAEJacFunc user_jac;
-static octave_idx_type nn;
+static F77_INT nn;
 
-static octave_idx_type
+static F77_INT
 ddaspk_f (const double& time, const double *state, const double *deriv,
-          const double&, double *delta, octave_idx_type& ires, double *,
-          octave_idx_type *)
+          const double&, double *delta, F77_INT& ires, double *, F77_INT *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   ColumnVector tmp_deriv (nn);
   ColumnVector tmp_state (nn);
   ColumnVector tmp_delta (nn);
 
-  for (octave_idx_type i = 0; i < nn; i++)
+  for (F77_INT i = 0; i < nn; i++)
     {
       tmp_deriv.elem (i) = deriv[i];
       tmp_state.elem (i) = state[i];
     }
 
-  tmp_delta = user_fun (tmp_state, tmp_deriv, time, ires);
+  octave_idx_type tmp_ires = ires;
+
+  tmp_delta = user_fun (tmp_state, tmp_deriv, time, tmp_ires);
+
+  ires = to_f77_int (tmp_ires);
 
   if (ires >= 0)
     {
       if (tmp_delta.is_empty ())
         ires = -2;
       else
         {
-          for (octave_idx_type i = 0; i < nn; i++)
+          for (F77_INT i = 0; i < nn; i++)
             delta[i] = tmp_delta.elem (i);
         }
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 //NEQ, T, Y, YPRIME, SAVR, WK, CJ, WGHT,
 //C                          WP, IWP, B, EPLIN, IER, RPAR, IPAR)
 
-static octave_idx_type
-ddaspk_psol (const octave_idx_type&, const double&, const double *,
+static F77_INT
+ddaspk_psol (const F77_INT&, const double&, const double *,
              const double *, const double *, const double&,
-             const double *, double *, octave_idx_type *, double *,
-             const double&, octave_idx_type&, double *, octave_idx_type*)
+             const double *, double *, F77_INT *, double *,
+             const double&, F77_INT&, double *, F77_INT*)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   abort ();
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
-static octave_idx_type
+static F77_INT
 ddaspk_j (const double& time, const double *state, const double *deriv,
-          double *pd, const double& cj, double *, octave_idx_type *)
+          double *pd, const double& cj, double *, F77_INT *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   // FIXME: would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
-  for (octave_idx_type i = 0; i < nn; i++)
+  for (F77_INT i = 0; i < nn; i++)
     {
       tmp_deriv.elem (i) = deriv[i];
       tmp_state.elem (i) = state[i];
     }
 
   Matrix tmp_pd = user_jac (tmp_state, tmp_deriv, time, cj);
 
-  for (octave_idx_type j = 0; j < nn; j++)
-    for (octave_idx_type i = 0; i < nn; i++)
+  for (F77_INT j = 0; j < nn; j++)
+    for (F77_INT i = 0; i < nn; i++)
       pd[nn * j + i] = tmp_pd.elem (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 ColumnVector
@@ -162,20 +158,20 @@ DASPK::do_integrate (double tout)
   if (! initialized || restart || DAEFunc::reset || DASPK_options::reset)
     {
       integration_error = false;
 
       initialized = true;
 
       info.resize (dim_vector (20, 1));
 
-      for (octave_idx_type i = 0; i < 20; i++)
+      for (F77_INT i = 0; i < 20; i++)
         info(i) = 0;
 
-      octave_idx_type n = size ();
+      F77_INT n = to_f77_int (size ());
 
       nn = n;
 
       info(0) = 0;
 
       if (stop_time_set)
         {
           rwork(0) = stop_time;
@@ -236,18 +232,18 @@ DASPK::do_integrate (double tout)
       iwork.resize (dim_vector (liw, 1));
       rwork.resize (dim_vector (lrw, 1));
 
       // DASPK_options
 
       abs_tol = absolute_tolerance ();
       rel_tol = relative_tolerance ();
 
-      octave_idx_type abs_tol_len = abs_tol.numel ();
-      octave_idx_type rel_tol_len = rel_tol.numel ();
+      F77_INT abs_tol_len = to_f77_int (abs_tol.numel ());
+      F77_INT rel_tol_len = to_f77_int (rel_tol.numel ());
 
       if (abs_tol_len == 1 && rel_tol_len == 1)
         {
           info(1) = 0;
         }
       else if (abs_tol_len == n && rel_tol_len == n)
         {
           info(1) = 1;
@@ -282,17 +278,17 @@ DASPK::do_integrate (double tout)
         info(7) = 0;
 
       octave_idx_type maxord = maximum_order ();
       if (maxord >= 0)
         {
           if (maxord > 0 && maxord < 6)
             {
               info(8) = 1;
-              iwork(2) = maxord;
+              iwork(2) = to_f77_int (maxord);
             }
           else
             {
               // FIXME: Should this be a warning?
               (*current_liboctave_error_handler)
                 ("daspk: invalid value for maximum order");
               integration_error = true;
               return retval;
@@ -301,21 +297,23 @@ DASPK::do_integrate (double tout)
 
       switch (eiq)
         {
         case 1:
         case 3:
           {
             Array<octave_idx_type> ict = inequality_constraint_types ();
 
-            if (ict.numel () == n)
+            F77_INT ict_nel = to_f77_int (ict.numel ());
+
+            if (ict_nel == n)
               {
-                for (octave_idx_type i = 0; i < n; i++)
+                for (F77_INT i = 0; i < n; i++)
                   {
-                    octave_idx_type val = ict(i);
+                    F77_INT val = to_f77_int (ict(i));
                     if (val < -2 || val > 2)
                       {
                         // FIXME: Should this be a warning?
                         (*current_liboctave_error_handler)
                           ("daspk: invalid value for inequality constraint type");
                         integration_error = true;
                         return retval;
                       }
@@ -330,17 +328,17 @@ DASPK::do_integrate (double tout)
                 integration_error = true;
                 return retval;
               }
           }
         // Fall through...
 
         case 0:
         case 2:
-          info(9) = eiq;
+          info(9) = to_f77_int (eiq);
           break;
 
         default:
           // FIXME: Should this be a warning?
           (*current_liboctave_error_handler)
             ("daspk: invalid value for enforce inequality constraints option");
           integration_error = true;
           return retval;
@@ -349,27 +347,29 @@ DASPK::do_integrate (double tout)
       if (ccic)
         {
           if (ccic == 1)
             {
               // FIXME: this code is duplicated below.
 
               Array<octave_idx_type> av = algebraic_variables ();
 
-              if (av.numel () == n)
+              F77_INT av_nel = to_f77_int (av.numel ());
+
+              if (av_nel == n)
                 {
-                  octave_idx_type lid;
+                  F77_INT lid;
                   if (eiq == 0 || eiq == 2)
                     lid = 40;
                   else if (eiq == 1 || eiq == 3)
                     lid = 40 + n;
                   else
                     abort ();
 
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     iwork(lid+i) = av(i) ? -1 : 1;
                 }
               else
                 {
                   // FIXME: Should this be a warning?
                   (*current_liboctave_error_handler)
                     ("daspk: algebraic variables size mismatch");
                   integration_error = true;
@@ -380,52 +380,54 @@ DASPK::do_integrate (double tout)
             {
               // FIXME: Should this be a warning?
               (*current_liboctave_error_handler)
                 ("daspk: invalid value for compute consistent initial condition option");
               integration_error = true;
               return retval;
             }
 
-          info(10) = ccic;
+          info(10) = to_f77_int (ccic);
         }
 
       if (eavfet)
         {
           info(15) = 1;
 
           // FIXME: this code is duplicated above.
 
           Array<octave_idx_type> av = algebraic_variables ();
 
-          if (av.numel () == n)
+          F77_INT av_nel = to_f77_int (av.numel ());
+
+          if (av_nel == n)
             {
-              octave_idx_type lid;
+              F77_INT lid;
               if (eiq == 0 || eiq == 2)
                 lid = 40;
               else if (eiq == 1 || eiq == 3)
                 lid = 40 + n;
               else
                 abort ();
 
-              for (octave_idx_type i = 0; i < n; i++)
+              for (F77_INT i = 0; i < n; i++)
                 iwork(lid+i) = av(i) ? -1 : 1;
             }
         }
 
       if (use_initial_condition_heuristics ())
         {
           Array<double> ich = initial_condition_heuristics ();
 
           if (ich.numel () == 6)
             {
-              iwork(31) = octave::math::nint_big (ich(0));
-              iwork(32) = octave::math::nint_big (ich(1));
-              iwork(33) = octave::math::nint_big (ich(2));
-              iwork(34) = octave::math::nint_big (ich(3));
+              iwork(31) = to_f77_int (octave::math::nint_big (ich(0)));
+              iwork(32) = to_f77_int (octave::math::nint_big (ich(1)));
+              iwork(33) = to_f77_int (octave::math::nint_big (ich(2)));
+              iwork(34) = to_f77_int (octave::math::nint_big (ich(3)));
 
               rwork(13) = ich(4);
               rwork(14) = ich(5);
             }
           else
             {
               // FIXME: Should this be a warning?
               (*current_liboctave_error_handler)
@@ -438,17 +440,17 @@ DASPK::do_integrate (double tout)
         }
 
       octave_idx_type pici = print_initial_condition_info ();
       switch (pici)
         {
         case 0:
         case 1:
         case 2:
-          info(17) = pici;
+          info(17) = to_f77_int (pici);
           break;
 
         default:
           // FIXME: Should this be a warning?
           (*current_liboctave_error_handler)
             ("daspk: invalid value for print initial condition info option");
           integration_error = true;
           return retval;
@@ -458,32 +460,36 @@ DASPK::do_integrate (double tout)
       DASPK_options::reset = false;
 
       restart = false;
     }
 
   double *px = x.fortran_vec ();
   double *pxdot = xdot.fortran_vec ();
 
-  octave_idx_type *pinfo = info.fortran_vec ();
+  F77_INT *pinfo = info.fortran_vec ();
 
   double *prel_tol = rel_tol.fortran_vec ();
   double *pabs_tol = abs_tol.fortran_vec ();
 
   double *prwork = rwork.fortran_vec ();
-  octave_idx_type *piwork = iwork.fortran_vec ();
+  F77_INT *piwork = iwork.fortran_vec ();
 
   double *dummy = 0;
-  octave_idx_type *idummy = 0;
+  F77_INT *idummy = 0;
+
+  F77_INT tmp_istate = to_f77_int (istate);
 
   F77_XFCN (ddaspk, DDASPK, (ddaspk_f, nn, t, px, pxdot, tout, pinfo,
-                             prel_tol, pabs_tol, istate, prwork, lrw,
+                             prel_tol, pabs_tol, tmp_istate, prwork, lrw,
                              piwork, liw, dummy, idummy, ddaspk_j,
                              ddaspk_psol));
 
+  istate = tmp_istate;
+
   switch (istate)
     {
     case 1: // A step was successfully taken in intermediate-output
             // mode.  The code has not yet reached TOUT.
     case 2: // The integration to TSTOP was successfully completed
             // (T=TSTOP) by stepping exactly to TSTOP.
     case 3: // The integration to TOUT was successfully completed
             // (T=TOUT) by stepping past TOUT.  Y(*) is obtained by
@@ -544,37 +550,37 @@ DASPK::do_integrate (const ColumnVector&
 }
 
 Matrix
 DASPK::integrate (const ColumnVector& tout, Matrix& xdot_out)
 {
   Matrix retval;
 
   octave_idx_type n_out = tout.numel ();
-  octave_idx_type n = size ();
+  F77_INT n = to_f77_int (size ());
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
-      for (octave_idx_type i = 0; i < n; i++)
+      for (F77_INT i = 0; i < n; i++)
         {
           retval.elem (0, i) = x.elem (i);
           xdot_out.elem (0, i) = xdot.elem (i);
         }
 
       for (octave_idx_type j = 1; j < n_out; j++)
         {
           ColumnVector x_next = do_integrate (tout.elem (j));
 
           if (integration_error)
             return retval;
 
-          for (octave_idx_type i = 0; i < n; i++)
+          for (F77_INT i = 0; i < n; i++)
             {
               retval.elem (j, i) = x_next.elem (i);
               xdot_out.elem (j, i) = xdot.elem (i);
             }
         }
     }
 
   return retval;
@@ -589,24 +595,24 @@ DASPK::do_integrate (const ColumnVector&
 
 Matrix
 DASPK::integrate (const ColumnVector& tout, Matrix& xdot_out,
                   const ColumnVector& tcrit)
 {
   Matrix retval;
 
   octave_idx_type n_out = tout.numel ();
-  octave_idx_type n = size ();
+  F77_INT n = to_f77_int (size ());
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
-      for (octave_idx_type i = 0; i < n; i++)
+      for (F77_INT i = 0; i < n; i++)
         {
           retval.elem (0, i) = x.elem (i);
           xdot_out.elem (0, i) = xdot.elem (i);
         }
 
       octave_idx_type n_crit = tcrit.numel ();
 
       if (n_crit > 0)
@@ -663,17 +669,17 @@ DASPK::integrate (const ColumnVector& to
 
               ColumnVector x_next = do_integrate (t_out);
 
               if (integration_error)
                 return retval;
 
               if (save_output)
                 {
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     {
                       retval.elem (i_out-1, i) = x_next.elem (i);
                       xdot_out.elem (i_out-1, i) = xdot.elem (i);
                     }
                 }
 
               if (do_restart)
                 force_restart ();
diff --git a/liboctave/numeric/DASPK.h b/liboctave/numeric/DASPK.h
--- a/liboctave/numeric/DASPK.h
+++ b/liboctave/numeric/DASPK.h
@@ -63,21 +63,21 @@ public:
                     const ColumnVector& tcrit);
 
   std::string error_message (void) const;
 
 private:
 
   bool initialized;
 
-  octave_idx_type liw;
-  octave_idx_type lrw;
+  octave_f77_int_type liw;
+  octave_f77_int_type lrw;
 
-  Array<octave_idx_type> info;
-  Array<octave_idx_type> iwork;
+  Array<octave_f77_int_type> info;
+  Array<octave_f77_int_type> iwork;
 
   Array<double> rwork;
 
   Array<double> abs_tol;
   Array<double> rel_tol;
 };
 
 #endif
diff --git a/liboctave/numeric/DASRT.cc b/liboctave/numeric/DASRT.cc
--- a/liboctave/numeric/DASRT.cc
+++ b/liboctave/numeric/DASRT.cc
@@ -29,125 +29,121 @@ along with Octave; see the file COPYING.
 #include <sstream>
 
 #include "DASRT.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-math.h"
 #include "quit.h"
 
-typedef octave_idx_type (*dasrt_fcn_ptr) (const double&, const double*,
-                                          const double*, double*,
-                                          octave_idx_type&, double*,
-                                          octave_idx_type*);
+typedef F77_INT (*dasrt_fcn_ptr) (const double&, const double*, const double*,
+                                  double*, F77_INT&, double*, F77_INT*);
 
-typedef octave_idx_type (*dasrt_jac_ptr) (const double&, const double*,
-                                          const double*, double*,
-                                          const double&, double*,
-                                          octave_idx_type*);
+typedef F77_INT (*dasrt_jac_ptr) (const double&, const double*, const double*,
+                                  double*, const double&, double*, F77_INT*);
 
-typedef octave_idx_type (*dasrt_constr_ptr) (const octave_idx_type&,
-                                             const double&, const double*,
-                                             const octave_idx_type&,
-                                             double*, double*,
-                                             octave_idx_type*);
+typedef F77_INT (*dasrt_constr_ptr) (const F77_INT&, const double&,
+                                     const double*, const F77_INT&,
+                                     double*, double*, F77_INT*);
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (ddasrt, DDASRT) (dasrt_fcn_ptr, const F77_INT&,
-                             F77_DBLE&, F77_DBLE*, F77_DBLE*, const F77_DBLE&,
-                             F77_INT*, const F77_DBLE*,
-                             const F77_DBLE*, F77_INT&, F77_DBLE*,
-                             const F77_INT&, F77_INT*,
-                             const F77_INT&, F77_DBLE*,
-                             F77_INT*, dasrt_jac_ptr,
-                             dasrt_constr_ptr, const F77_INT&,
+  F77_FUNC (ddasrt, DDASRT) (dasrt_fcn_ptr, const F77_INT&, F77_DBLE&,
+                             F77_DBLE*, F77_DBLE*, const F77_DBLE&, F77_INT*,
+                             const F77_DBLE*, const F77_DBLE*, F77_INT&,
+                             F77_DBLE*, const F77_INT&, F77_INT*,
+                             const F77_INT&, F77_DBLE*, F77_INT*,
+                             dasrt_jac_ptr, dasrt_constr_ptr, const F77_INT&,
                              F77_INT*);
 }
 
 static DAEFunc::DAERHSFunc user_fsub;
 static DAEFunc::DAEJacFunc user_jsub;
 static DAERTFunc::DAERTConstrFunc user_csub;
 
-static octave_idx_type nn;
+static F77_INT nn;
 
-static octave_idx_type
+static F77_INT
 ddasrt_f (const double& t, const double *state, const double *deriv,
-          double *delta, octave_idx_type& ires, double *, octave_idx_type *)
+          double *delta, F77_INT& ires, double *, F77_INT *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
-  for (octave_idx_type i = 0; i < nn; i++)
+  for (F77_INT i = 0; i < nn; i++)
     {
       tmp_state(i) = state[i];
       tmp_deriv(i) = deriv[i];
     }
 
-  ColumnVector tmp_fval = (*user_fsub) (tmp_state, tmp_deriv, t, ires);
+  octave_idx_type tmp_ires = ires;
+
+  ColumnVector tmp_fval = (*user_fsub) (tmp_state, tmp_deriv, t, tmp_ires);
+
+  ires = to_f77_int (tmp_ires);
 
   if (tmp_fval.is_empty ())
     ires = -2;
   else
     {
-      for (octave_idx_type i = 0; i < nn; i++)
+      for (F77_INT i = 0; i < nn; i++)
         delta[i] = tmp_fval(i);
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
-octave_idx_type
+F77_INT
 ddasrt_j (const double& time, const double *state, const double *deriv,
-          double *pd, const double& cj, double *, octave_idx_type *)
+          double *pd, const double& cj, double *, F77_INT *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   // FIXME: would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
-  for (octave_idx_type i = 0; i < nn; i++)
+  for (F77_INT i = 0; i < nn; i++)
     {
       tmp_deriv.elem (i) = deriv[i];
       tmp_state.elem (i) = state[i];
     }
 
   Matrix tmp_pd = (*user_jsub) (tmp_state, tmp_deriv, time, cj);
 
-  for (octave_idx_type j = 0; j < nn; j++)
-    for (octave_idx_type i = 0; i < nn; i++)
+  for (F77_INT j = 0; j < nn; j++)
+    for (F77_INT i = 0; i < nn; i++)
       pd[nn * j + i] = tmp_pd.elem (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
-static octave_idx_type
-ddasrt_g (const octave_idx_type& neq, const double& t, const double *state,
-          const octave_idx_type& ng, double *gout, double *, octave_idx_type *)
+static F77_INT
+ddasrt_g (const F77_INT& neq, const double& t, const double *state,
+          const F77_INT& ng, double *gout, double *, F77_INT *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
-  octave_idx_type n = neq;
+  F77_INT n = neq;
 
   ColumnVector tmp_state (n);
-  for (octave_idx_type i = 0; i < n; i++)
+  for (F77_INT i = 0; i < n; i++)
     tmp_state(i) = state[i];
 
   ColumnVector tmp_fval = (*user_csub) (tmp_state, t);
 
-  for (octave_idx_type i = 0; i < ng; i++)
+  for (F77_INT i = 0; i < ng; i++)
     gout[i] = tmp_fval(i);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 void
@@ -161,36 +157,36 @@ DASRT::integrate (double tout)
       || DAEFunc::reset || DAERTFunc::reset || DASRT_options::reset)
     {
       integration_error = false;
 
       initialized = true;
 
       info.resize (dim_vector (15, 1));
 
-      for (octave_idx_type i = 0; i < 15; i++)
+      for (F77_INT i = 0; i < 15; i++)
         info(i) = 0;
 
-      octave_idx_type n = size ();
+      F77_INT n = to_f77_int (size ());
 
       nn = n;
 
       // DAERTFunc
 
       user_csub = DAERTFunc::constraint_function ();
 
       if (user_csub)
         {
           ColumnVector tmp = (*user_csub) (x, t);
-          ng = tmp.numel ();
+          ng = to_f77_int (tmp.numel ());
         }
       else
         ng = 0;
 
-      octave_idx_type maxord = maximum_order ();
+      F77_INT maxord = to_f77_int (maximum_order ());
       if (maxord >= 0)
         {
           if (maxord > 0 && maxord < 6)
             {
               info(8) = 1;
               iwork(2) = maxord;
             }
           else
@@ -272,29 +268,30 @@ DASRT::integrate (double tout)
       if (iss >= 0.0)
         {
           rwork(2) = iss;
           info(7) = 1;
         }
       else
         info(7) = 0;
 
-      if (step_limit () >= 0)
+      F77_INT sl = to_f77_int (step_limit ());
+      if (sl >= 0)
         {
           info(11) = 1;
-          iwork(20) = step_limit ();
+          iwork(20) = sl;
         }
       else
         info(11) = 0;
 
       abs_tol = absolute_tolerance ();
       rel_tol = relative_tolerance ();
 
-      octave_idx_type abs_tol_len = abs_tol.numel ();
-      octave_idx_type rel_tol_len = rel_tol.numel ();
+      F77_INT abs_tol_len = to_f77_int (abs_tol.numel ());
+      F77_INT rel_tol_len = to_f77_int (rel_tol.numel ());
 
       if (abs_tol_len == 1 && rel_tol_len == 1)
         {
           info.elem (1) = 0;
         }
       else if (abs_tol_len == n && rel_tol_len == n)
         {
           info.elem (1) = 1;
@@ -309,34 +306,38 @@ DASRT::integrate (double tout)
         }
 
       DASRT_options::reset = false;
     }
 
   double *px = x.fortran_vec ();
   double *pxdot = xdot.fortran_vec ();
 
-  octave_idx_type *pinfo = info.fortran_vec ();
+  F77_INT *pinfo = info.fortran_vec ();
 
   double *prel_tol = rel_tol.fortran_vec ();
   double *pabs_tol = abs_tol.fortran_vec ();
 
   double *prwork = rwork.fortran_vec ();
-  octave_idx_type *piwork = iwork.fortran_vec ();
+  F77_INT *piwork = iwork.fortran_vec ();
 
-  octave_idx_type *pjroot = jroot.fortran_vec ();
+  F77_INT *pjroot = jroot.fortran_vec ();
 
   double *dummy = 0;
-  octave_idx_type *idummy = 0;
+  F77_INT *idummy = 0;
+
+  F77_INT tmp_istate = to_f77_int (istate);
 
   F77_XFCN (ddasrt, DDASRT, (ddasrt_f, nn, t, px, pxdot, tout, pinfo,
-                             prel_tol, pabs_tol, istate, prwork, lrw,
+                             prel_tol, pabs_tol, tmp_istate, prwork, lrw,
                              piwork, liw, dummy, idummy, ddasrt_j,
                              ddasrt_g, ng, pjroot));
 
+  istate = tmp_istate;
+
   switch (istate)
     {
     case 1: // A step was successfully taken in intermediate-output
             // mode.  The code has not yet reached TOUT.
     case 2: // The integration to TOUT was successfully completed
             // (T=TOUT) by stepping exactly to TOUT.
     case 3: // The integration to TOUT was successfully completed
             // (T=TOUT) by stepping past TOUT.  Y(*) is obtained by
@@ -387,24 +388,24 @@ DASRT::integrate (const ColumnVector& to
 {
   DASRT_result retval;
 
   Matrix x_out;
   Matrix xdot_out;
   ColumnVector t_out = tout;
 
   octave_idx_type n_out = tout.numel ();
-  octave_idx_type n = size ();
+  F77_INT n = to_f77_int (size ());
 
   if (n_out > 0 && n > 0)
     {
       x_out.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
-      for (octave_idx_type i = 0; i < n; i++)
+      for (F77_INT i = 0; i < n; i++)
         {
           x_out(0,i) = x(i);
           xdot_out(0,i) = xdot(i);
         }
 
       for (octave_idx_type j = 1; j < n_out; j++)
         {
           integrate (tout(j));
@@ -415,17 +416,17 @@ DASRT::integrate (const ColumnVector& to
               return retval;
             }
 
           if (istate == 4)
             t_out(j) = t;
           else
             t_out(j) = tout(j);
 
-          for (octave_idx_type i = 0; i < n; i++)
+          for (F77_INT i = 0; i < n; i++)
             {
               x_out(j,i) = x(i);
               xdot_out(j,i) = xdot(i);
             }
 
           if (istate == 4)
             {
               x_out.resize (j+1, n);
@@ -446,17 +447,17 @@ DASRT::integrate (const ColumnVector& to
 {
   DASRT_result retval;
 
   Matrix x_out;
   Matrix xdot_out;
   ColumnVector t_outs = tout;
 
   octave_idx_type n_out = tout.numel ();
-  octave_idx_type n = size ();
+  F77_INT n = to_f77_int (size ());
 
   if (n_out > 0 && n > 0)
     {
       x_out.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
       octave_idx_type n_crit = tcrit.numel ();
 
@@ -469,68 +470,68 @@ DASRT::integrate (const ColumnVector& to
           while (i_out < n_out)
             {
               bool do_restart = false;
 
               next_out = tout(i_out);
               if (i_crit < n_crit)
                 next_crit = tcrit(i_crit);
 
-              octave_idx_type save_output;
+              bool save_output = false;
               double t_out;
 
               if (next_crit == next_out)
                 {
                   set_stop_time (next_crit);
                   t_out = next_out;
-                  save_output = 1;
+                  save_output = true;
                   i_out++;
                   i_crit++;
                   do_restart = true;
                 }
               else if (next_crit < next_out)
                 {
                   if (i_crit < n_crit)
                     {
                       set_stop_time (next_crit);
                       t_out = next_crit;
-                      save_output = 0;
+                      save_output = false;
                       i_crit++;
                       do_restart = true;
                     }
                   else
                     {
                       clear_stop_time ();
                       t_out = next_out;
-                      save_output = 1;
+                      save_output = true;
                       i_out++;
                     }
                 }
               else
                 {
                   set_stop_time (next_crit);
                   t_out = next_out;
-                  save_output = 1;
+                  save_output = true;
                   i_out++;
                 }
 
               integrate (t_out);
 
               if (integration_error)
                 {
                   retval = DASRT_result (x_out, xdot_out, t_outs);
                   return retval;
                 }
 
               if (istate == 4)
                 t_out = t;
 
               if (save_output)
                 {
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     {
                       x_out(i_out-1,i) = x(i);
                       xdot_out(i_out-1,i) = xdot(i);
                     }
 
                   t_outs(i_out-1) = t_out;
 
                   if (istate == 4)
diff --git a/liboctave/numeric/DASRT.h b/liboctave/numeric/DASRT.h
--- a/liboctave/numeric/DASRT.h
+++ b/liboctave/numeric/DASRT.h
@@ -100,24 +100,24 @@ public:
                           const ColumnVector& tcrit);
 
   std::string error_message (void) const;
 
 private:
 
   bool initialized;
 
-  octave_idx_type liw;
-  octave_idx_type lrw;
+  octave_f77_int_type liw;
+  octave_f77_int_type lrw;
 
-  octave_idx_type ng;
+  octave_f77_int_type ng;
 
-  Array<octave_idx_type> info;
-  Array<octave_idx_type> iwork;
-  Array<octave_idx_type> jroot;
+  Array<octave_f77_int_type> info;
+  Array<octave_f77_int_type> iwork;
+  Array<octave_f77_int_type> jroot;
 
   Array<double> rwork;
 
   Array<double> abs_tol;
   Array<double> rel_tol;
 
   void integrate (double t);
 };
diff --git a/liboctave/numeric/DASSL.cc b/liboctave/numeric/DASSL.cc
--- a/liboctave/numeric/DASSL.cc
+++ b/liboctave/numeric/DASSL.cc
@@ -29,101 +29,101 @@ along with Octave; see the file COPYING.
 #include <sstream>
 
 #include "DASSL.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-math.h"
 #include "quit.h"
 
-typedef octave_idx_type (*dassl_fcn_ptr) (const double&, const double*,
-                                          const double*, double*,
-                                          octave_idx_type&, double*,
-                                          octave_idx_type*);
+typedef F77_INT (*dassl_fcn_ptr) (const double&, const double*,
+                                  const double*, double*, F77_INT&,
+                                  double*, F77_INT*);
 
-typedef octave_idx_type (*dassl_jac_ptr) (const double&, const double*,
-                                          const double*, double*,
-                                          const double&, double*,
-                                          octave_idx_type*);
+typedef F77_INT (*dassl_jac_ptr) (const double&, const double*,
+                                  const double*, double*, const double&,
+                                  double*, F77_INT*);
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (ddassl, DDASSL) (dassl_fcn_ptr, const F77_INT&,
-                             F77_DBLE&, F77_DBLE*, F77_DBLE*, F77_DBLE&,
-                             const F77_INT*, const F77_DBLE*,
-                             const F77_DBLE*, F77_INT&,
-                             F77_DBLE*, const F77_INT&,
-                             F77_INT*, const F77_INT&,
-                             const F77_DBLE*, const F77_INT*,
+  F77_FUNC (ddassl, DDASSL) (dassl_fcn_ptr, const F77_INT&, F77_DBLE&,
+                             F77_DBLE*, F77_DBLE*, F77_DBLE&, const F77_INT*,
+                             const F77_DBLE*, const F77_DBLE*, F77_INT&,
+                             F77_DBLE*, const F77_INT&, F77_INT*,
+                             const F77_INT&, const F77_DBLE*, const F77_INT*,
                              dassl_jac_ptr);
 }
 
 static DAEFunc::DAERHSFunc user_fun;
 static DAEFunc::DAEJacFunc user_jac;
 
-static octave_idx_type nn;
+static F77_INT nn;
 
-static octave_idx_type
+static F77_INT
 ddassl_f (const double& time, const double *state, const double *deriv,
-          double *delta, octave_idx_type& ires, double *, octave_idx_type *)
+          double *delta, F77_INT& ires, double *, F77_INT *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   // FIXME: would be nice to avoid copying the data.
 
   ColumnVector tmp_deriv (nn);
   ColumnVector tmp_state (nn);
   ColumnVector tmp_delta (nn);
 
-  for (octave_idx_type i = 0; i < nn; i++)
+  for (F77_INT i = 0; i < nn; i++)
     {
       tmp_deriv.elem (i) = deriv[i];
       tmp_state.elem (i) = state[i];
     }
 
-  tmp_delta = user_fun (tmp_state, tmp_deriv, time, ires);
+  octave_idx_type tmp_ires = ires;
+
+  tmp_delta = user_fun (tmp_state, tmp_deriv, time, tmp_ires);
+
+  ires = to_f77_int (tmp_ires);
 
   if (ires >= 0)
     {
       if (tmp_delta.is_empty ())
         ires = -2;
       else
         {
-          for (octave_idx_type i = 0; i < nn; i++)
+          for (F77_INT i = 0; i < nn; i++)
             delta[i] = tmp_delta.elem (i);
         }
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
-static octave_idx_type
+static F77_INT
 ddassl_j (const double& time, const double *state, const double *deriv,
-          double *pd, const double& cj, double *, octave_idx_type *)
+          double *pd, const double& cj, double *, F77_INT *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   // FIXME: would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
-  for (octave_idx_type i = 0; i < nn; i++)
+  for (F77_INT i = 0; i < nn; i++)
     {
       tmp_deriv.elem (i) = deriv[i];
       tmp_state.elem (i) = state[i];
     }
 
   Matrix tmp_pd = user_jac (tmp_state, tmp_deriv, time, cj);
 
-  for (octave_idx_type j = 0; j < nn; j++)
-    for (octave_idx_type i = 0; i < nn; i++)
+  for (F77_INT j = 0; j < nn; j++)
+    for (F77_INT i = 0; i < nn; i++)
       pd[nn * j + i] = tmp_pd.elem (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 ColumnVector
@@ -134,20 +134,20 @@ DASSL::do_integrate (double tout)
   if (! initialized || restart || DAEFunc::reset || DASSL_options::reset)
     {
       integration_error = false;
 
       initialized = true;
 
       info.resize (dim_vector (15, 1));
 
-      for (octave_idx_type i = 0; i < 15; i++)
+      for (F77_INT i = 0; i < 15; i++)
         info(i) = 0;
 
-      octave_idx_type n = size ();
+      F77_INT n = to_f77_int (size ());
 
       liw = 21 + n;
       lrw = 40 + 9*n + n*n;
 
       nn = n;
 
       iwork.resize (dim_vector (liw, 1));
       rwork.resize (dim_vector (lrw, 1));
@@ -212,52 +212,54 @@ DASSL::do_integrate (double tout)
       if (h0 >= 0.0)
         {
           rwork(2) = h0;
           info(7) = 1;
         }
       else
         info(7) = 0;
 
-      if (step_limit () >= 0)
+      F77_INT sl = to_f77_int (step_limit ());
+
+      if (sl >= 0)
         {
           info(11) = 1;
-          iwork(20) = step_limit ();
+          iwork(20) = sl;
         }
       else
         info(11) = 0;
 
-      octave_idx_type maxord = maximum_order ();
+      F77_INT maxord = to_f77_int (maximum_order ());
       if (maxord >= 0)
         {
           if (maxord > 0 && maxord < 6)
             {
               info(8) = 1;
               iwork(2) = maxord;
             }
           else
             {
               (*current_liboctave_error_handler)
                 ("dassl: invalid value for maximum order: %d", maxord);
               integration_error = true;
               return retval;
             }
         }
 
-      octave_idx_type enc = enforce_nonnegativity_constraints ();
+      F77_INT enc = to_f77_int (enforce_nonnegativity_constraints ());
       info(9) = enc ? 1 : 0;
 
-      octave_idx_type ccic = compute_consistent_initial_condition ();
+      F77_INT ccic = to_f77_int (compute_consistent_initial_condition ());
       info(10) = ccic ? 1 : 0;
 
       abs_tol = absolute_tolerance ();
       rel_tol = relative_tolerance ();
 
-      octave_idx_type abs_tol_len = abs_tol.numel ();
-      octave_idx_type rel_tol_len = rel_tol.numel ();
+      F77_INT abs_tol_len = to_f77_int (abs_tol.numel ());
+      F77_INT rel_tol_len = to_f77_int (rel_tol.numel ());
 
       if (abs_tol_len == 1 && rel_tol_len == 1)
         {
           info(1) = 0;
         }
       else if (abs_tol_len == n && rel_tol_len == n)
         {
           info(1) = 1;
@@ -272,31 +274,35 @@ DASSL::do_integrate (double tout)
         }
 
       DASSL_options::reset = false;
     }
 
   double *px = x.fortran_vec ();
   double *pxdot = xdot.fortran_vec ();
 
-  octave_idx_type *pinfo = info.fortran_vec ();
+  F77_INT *pinfo = info.fortran_vec ();
 
   double *prel_tol = rel_tol.fortran_vec ();
   double *pabs_tol = abs_tol.fortran_vec ();
 
   double *prwork = rwork.fortran_vec ();
-  octave_idx_type *piwork = iwork.fortran_vec ();
+  F77_INT *piwork = iwork.fortran_vec ();
 
   double *dummy = 0;
-  octave_idx_type *idummy = 0;
+  F77_INT *idummy = 0;
+
+  F77_INT tmp_istate = to_f77_int (istate);
 
   F77_XFCN (ddassl, DDASSL, (ddassl_f, nn, t, px, pxdot, tout, pinfo,
-                             prel_tol, pabs_tol, istate, prwork, lrw,
+                             prel_tol, pabs_tol, tmp_istate, prwork, lrw,
                              piwork, liw, dummy, idummy, ddassl_j));
 
+  istate = tmp_istate;
+
   switch (istate)
     {
     case 1: // A step was successfully taken in intermediate-output
             // mode.  The code has not yet reached TOUT.
     case 2: // The integration to TSTOP was successfully completed
             // (T=TSTOP) by stepping exactly to TSTOP.
     case 3: // The integration to TOUT was successfully completed
             // (T=TOUT) by stepping past TOUT.  Y(*) is obtained by
@@ -349,37 +355,37 @@ DASSL::do_integrate (const ColumnVector&
 }
 
 Matrix
 DASSL::integrate (const ColumnVector& tout, Matrix& xdot_out)
 {
   Matrix retval;
 
   octave_idx_type n_out = tout.numel ();
-  octave_idx_type n = size ();
+  F77_INT n = to_f77_int (size ());
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
-      for (octave_idx_type i = 0; i < n; i++)
+      for (F77_INT i = 0; i < n; i++)
         {
           retval.elem (0, i) = x.elem (i);
           xdot_out.elem (0, i) = xdot.elem (i);
         }
 
       for (octave_idx_type j = 1; j < n_out; j++)
         {
           ColumnVector x_next = do_integrate (tout.elem (j));
 
           if (integration_error)
             return retval;
 
-          for (octave_idx_type i = 0; i < n; i++)
+          for (F77_INT i = 0; i < n; i++)
             {
               retval.elem (j, i) = x_next.elem (i);
               xdot_out.elem (j, i) = xdot.elem (i);
             }
         }
     }
 
   return retval;
@@ -394,24 +400,24 @@ DASSL::do_integrate (const ColumnVector&
 
 Matrix
 DASSL::integrate (const ColumnVector& tout, Matrix& xdot_out,
                   const ColumnVector& tcrit)
 {
   Matrix retval;
 
   octave_idx_type n_out = tout.numel ();
-  octave_idx_type n = size ();
+  F77_INT n = to_f77_int (size ());
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
       xdot_out.resize (n_out, n);
 
-      for (octave_idx_type i = 0; i < n; i++)
+      for (F77_INT i = 0; i < n; i++)
         {
           retval.elem (0, i) = x.elem (i);
           xdot_out.elem (0, i) = xdot.elem (i);
         }
 
       octave_idx_type n_crit = tcrit.numel ();
 
       if (n_crit > 0)
@@ -468,17 +474,17 @@ DASSL::integrate (const ColumnVector& to
 
               ColumnVector x_next = do_integrate (t_out);
 
               if (integration_error)
                 return retval;
 
               if (save_output)
                 {
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     {
                       retval.elem (i_out-1, i) = x_next.elem (i);
                       xdot_out.elem (i_out-1, i) = xdot.elem (i);
                     }
                 }
 
               if (do_restart)
                 force_restart ();
diff --git a/liboctave/numeric/DASSL.h b/liboctave/numeric/DASSL.h
--- a/liboctave/numeric/DASSL.h
+++ b/liboctave/numeric/DASSL.h
@@ -63,21 +63,21 @@ public:
                     const ColumnVector& tcrit);
 
   std::string error_message (void) const;
 
 private:
 
   bool initialized;
 
-  octave_idx_type liw;
-  octave_idx_type lrw;
+  octave_f77_int_type liw;
+  octave_f77_int_type lrw;
 
-  Array<octave_idx_type> info;
-  Array<octave_idx_type> iwork;
+  Array<octave_f77_int_type> info;
+  Array<octave_f77_int_type> iwork;
 
   Array<double> rwork;
 
   Array<double> abs_tol;
   Array<double> rel_tol;
 };
 
 #endif
diff --git a/liboctave/numeric/LSODE.cc b/liboctave/numeric/LSODE.cc
--- a/liboctave/numeric/LSODE.cc
+++ b/liboctave/numeric/LSODE.cc
@@ -29,109 +29,103 @@ along with Octave; see the file COPYING.
 #include <sstream>
 
 #include "LSODE.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-math.h"
 #include "quit.h"
 
-typedef octave_idx_type (*lsode_fcn_ptr) (const octave_idx_type&,
-                                          const double&, double*,
-                                          double*, octave_idx_type&);
+typedef F77_INT (*lsode_fcn_ptr) (const F77_INT&, const double&, double*,
+                                  double*, F77_INT&);
 
-typedef octave_idx_type (*lsode_jac_ptr) (const octave_idx_type&,
-                                          const double&, double*,
-                                          const octave_idx_type&,
-                                          const octave_idx_type&,
-                                          double*, const octave_idx_type&);
+typedef F77_INT (*lsode_jac_ptr) (const F77_INT&, const double&, double*,
+                                  const F77_INT&, const F77_INT&, double*,
+                                  const F77_INT&);
 
 extern "C"
 {
   F77_RET_T
-  F77_FUNC (dlsode, DLSODE) (lsode_fcn_ptr, F77_INT&, F77_DBLE*,
-                             F77_DBLE&, F77_DBLE&, F77_INT&, F77_DBLE&,
-                             const F77_DBLE*, F77_INT&,
-                             F77_INT&, F77_INT&,
-                             F77_DBLE*, F77_INT&, F77_INT*,
-                             F77_INT&, lsode_jac_ptr,
+  F77_FUNC (dlsode, DLSODE) (lsode_fcn_ptr, F77_INT&, F77_DBLE*, F77_DBLE&,
+                             F77_DBLE&, F77_INT&, F77_DBLE&, const F77_DBLE*,
+                             F77_INT&, F77_INT&, F77_INT&, F77_DBLE*,
+                             F77_INT&, F77_INT*, F77_INT&, lsode_jac_ptr,
                              F77_INT&);
 }
 
 static ODEFunc::ODERHSFunc user_fun;
 static ODEFunc::ODEJacFunc user_jac;
 static ColumnVector *tmp_x;
 
-static octave_idx_type
-lsode_f (const octave_idx_type& neq, const double& time, double *,
-         double *deriv, octave_idx_type& ierr)
+static F77_INT
+lsode_f (const F77_INT& neq, const double& time, double *, double *deriv,
+         F77_INT& ierr)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   ColumnVector tmp_deriv;
 
   // NOTE: this won't work if LSODE passes copies of the state vector.
   //       In that case we have to create a temporary vector object
   //       and copy.
 
   tmp_deriv = (*user_fun) (*tmp_x, time);
 
   if (tmp_deriv.is_empty ())
     ierr = -1;
   else
     {
-      for (octave_idx_type i = 0; i < neq; i++)
+      for (F77_INT i = 0; i < neq; i++)
         deriv[i] = tmp_deriv.elem (i);
     }
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
-static octave_idx_type
-lsode_j (const octave_idx_type& neq, const double& time, double *,
-         const octave_idx_type&, const octave_idx_type&, double *pd,
-         const octave_idx_type& nrowpd)
+static F77_INT
+lsode_j (const F77_INT& neq, const double& time, double *, const F77_INT&,
+         const F77_INT&, double *pd, const F77_INT& nrowpd)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   Matrix tmp_jac (neq, neq);
 
   // NOTE: this won't work if LSODE passes copies of the state vector.
   //       In that case we have to create a temporary vector object
   //       and copy.
 
   tmp_jac = (*user_jac) (*tmp_x, time);
 
-  for (octave_idx_type j = 0; j < neq; j++)
-    for (octave_idx_type i = 0; i < neq; i++)
+  for (F77_INT j = 0; j < neq; j++)
+    for (F77_INT i = 0; i < neq; i++)
       pd[nrowpd * j + i] = tmp_jac (i, j);
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 ColumnVector
 LSODE::do_integrate (double tout)
 {
   ColumnVector retval;
 
-  static octave_idx_type nn = 0;
+  static F77_INT nn = 0;
 
   if (! initialized || restart || ODEFunc::reset || LSODE_options::reset)
     {
       integration_error = false;
 
       initialized = true;
 
       istate = 1;
 
-      octave_idx_type n = size ();
+      F77_INT n = to_f77_int (size ());
 
       nn = n;
 
       octave_idx_type max_maxord = 0;
 
       if (integration_method () == "stiff")
         {
           max_maxord = 5;
@@ -149,33 +143,33 @@ LSODE::do_integrate (double tout)
           max_maxord = 12;
 
           method_flag = 10;
 
           liw = 20;
           lrw = 22 + 16 * n;
         }
 
-      maxord = maximum_order ();
-
       iwork.resize (dim_vector (liw, 1));
 
-      for (octave_idx_type i = 4; i < 9; i++)
+      for (F77_INT i = 4; i < 9; i++)
         iwork(i) = 0;
 
       rwork.resize (dim_vector (lrw, 1));
 
-      for (octave_idx_type i = 4; i < 9; i++)
+      for (F77_INT i = 4; i < 9; i++)
         rwork(i) = 0;
 
+      octave_idx_type maxord = maximum_order ();
+
       if (maxord >= 0)
         {
           if (maxord > 0 && maxord <= max_maxord)
             {
-              iwork(4) = maxord;
+              iwork(4) = to_f77_int (maxord);
               iopt = 1;
             }
           else
             {
               // FIXME: Should this be a warning?
               (*current_liboctave_error_handler)
                 ("lsode: invalid value for maximum order");
               integration_error = true;
@@ -221,17 +215,17 @@ LSODE::do_integrate (double tout)
 
       ODEFunc::reset = false;
 
       // LSODE_options
 
       rel_tol = relative_tolerance ();
       abs_tol = absolute_tolerance ();
 
-      octave_idx_type abs_tol_len = abs_tol.numel ();
+      F77_INT abs_tol_len = to_f77_int (abs_tol.numel ());
 
       if (abs_tol_len == 1)
         itol = 1;
       else if (abs_tol_len == n)
         itol = 2;
       else
         {
           // FIXME: Should this be a warning?
@@ -258,37 +252,41 @@ LSODE::do_integrate (double tout)
 
       double minss = minimum_step_size ();
       if (minss >= 0.0)
         {
           rwork(6) = minss;
           iopt = 1;
         }
 
-      octave_idx_type sl = step_limit ();
+      F77_INT sl = to_f77_int (step_limit ());
       if (sl > 0)
         {
           iwork(5) = sl;
           iopt = 1;
         }
 
       LSODE_options::reset = false;
     }
 
   double *px = x.fortran_vec ();
 
   double *pabs_tol = abs_tol.fortran_vec ();
 
-  octave_idx_type *piwork = iwork.fortran_vec ();
+  F77_INT *piwork = iwork.fortran_vec ();
   double *prwork = rwork.fortran_vec ();
 
+  F77_INT tmp_istate = to_f77_int (istate);
+
   F77_XFCN (dlsode, DLSODE, (lsode_f, nn, px, t, tout, itol, rel_tol,
-                             pabs_tol, itask, istate, iopt, prwork, lrw,
+                             pabs_tol, itask, tmp_istate, iopt, prwork, lrw,
                              piwork, liw, lsode_j, method_flag));
 
+  istate = tmp_istate;
+
   switch (istate)
     {
     case 1:  // prior to initial integration step.
     case 2:  // lsode was successful.
       retval = x;
       t = tout;
       break;
 
@@ -381,53 +379,53 @@ LSODE::error_message (void) const
 }
 
 Matrix
 LSODE::do_integrate (const ColumnVector& tout)
 {
   Matrix retval;
 
   octave_idx_type n_out = tout.numel ();
-  octave_idx_type n = size ();
+  F77_INT n = to_f77_int (size ());
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
 
-      for (octave_idx_type i = 0; i < n; i++)
+      for (F77_INT i = 0; i < n; i++)
         retval.elem (0, i) = x.elem (i);
 
       for (octave_idx_type j = 1; j < n_out; j++)
         {
           ColumnVector x_next = do_integrate (tout.elem (j));
 
           if (integration_error)
             return retval;
 
-          for (octave_idx_type i = 0; i < n; i++)
+          for (F77_INT i = 0; i < n; i++)
             retval.elem (j, i) = x_next.elem (i);
         }
     }
 
   return retval;
 }
 
 Matrix
 LSODE::do_integrate (const ColumnVector& tout, const ColumnVector& tcrit)
 {
   Matrix retval;
 
   octave_idx_type n_out = tout.numel ();
-  octave_idx_type n = size ();
+  F77_INT n = to_f77_int (size ());
 
   if (n_out > 0 && n > 0)
     {
       retval.resize (n_out, n);
 
-      for (octave_idx_type i = 0; i < n; i++)
+      for (F77_INT i = 0; i < n; i++)
         retval.elem (0, i) = x.elem (i);
 
       octave_idx_type n_crit = tcrit.numel ();
 
       if (n_crit > 0)
         {
           octave_idx_type i_crit = 0;
           octave_idx_type i_out = 1;
@@ -436,62 +434,62 @@ LSODE::do_integrate (const ColumnVector&
           while (i_out < n_out)
             {
               bool do_restart = false;
 
               next_out = tout.elem (i_out);
               if (i_crit < n_crit)
                 next_crit = tcrit.elem (i_crit);
 
-              octave_idx_type save_output;
+              bool save_output = false;
               double t_out;
 
               if (next_crit == next_out)
                 {
                   set_stop_time (next_crit);
                   t_out = next_out;
-                  save_output = 1;
+                  save_output = true;
                   i_out++;
                   i_crit++;
                   do_restart = true;
                 }
               else if (next_crit < next_out)
                 {
                   if (i_crit < n_crit)
                     {
                       set_stop_time (next_crit);
                       t_out = next_crit;
-                      save_output = 0;
+                      save_output = false;
                       i_crit++;
                       do_restart = true;
                     }
                   else
                     {
                       clear_stop_time ();
                       t_out = next_out;
-                      save_output = 1;
+                      save_output = true;
                       i_out++;
                     }
                 }
               else
                 {
                   set_stop_time (next_crit);
                   t_out = next_out;
-                  save_output = 1;
+                  save_output = true;
                   i_out++;
                 }
 
               ColumnVector x_next = do_integrate (t_out);
 
               if (integration_error)
                 return retval;
 
               if (save_output)
                 {
-                  for (octave_idx_type i = 0; i < n; i++)
+                  for (F77_INT i = 0; i < n; i++)
                     retval.elem (i_out-1, i) = x_next.elem (i);
                 }
 
               if (do_restart)
                 force_restart ();
             }
         }
       else
diff --git a/liboctave/numeric/LSODE.h b/liboctave/numeric/LSODE.h
--- a/liboctave/numeric/LSODE.h
+++ b/liboctave/numeric/LSODE.h
@@ -32,48 +32,47 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 LSODE : public ODE, public LSODE_options
 {
 public:
 
   LSODE (void)
     : ODE (), LSODE_options (), initialized (false), method_flag (0),
-      maxord (0), itask (0), iopt (0), itol (0), liw (0), lrw (0),
+      itask (0), iopt (0), itol (0), liw (0), lrw (0),
       iwork (), rwork (), rel_tol (0.0), abs_tol () { }
 
   LSODE (const ColumnVector& s, double tm, const ODEFunc& f)
     : ODE (s, tm, f), LSODE_options (), initialized (false), method_flag (0),
-      maxord (0), itask (0), iopt (0), itol (0), liw (0), lrw (0),
+      itask (0), iopt (0), itol (0), liw (0), lrw (0),
       iwork (), rwork (), rel_tol (0.0), abs_tol () { }
 
   ~LSODE (void) = default;
 
   ColumnVector do_integrate (double t);
 
   Matrix do_integrate (const ColumnVector& tout);
 
   Matrix do_integrate (const ColumnVector& tout, const ColumnVector& tcrit);
 
   std::string error_message (void) const;
 
 private:
 
   bool initialized;
 
-  octave_idx_type method_flag;
-  octave_idx_type maxord;
-  octave_idx_type itask;
-  octave_idx_type iopt;
-  octave_idx_type itol;
+  octave_f77_int_type method_flag;
+  octave_f77_int_type itask;
+  octave_f77_int_type iopt;
+  octave_f77_int_type itol;
 
-  octave_idx_type liw;
-  octave_idx_type lrw;
+  octave_f77_int_type liw;
+  octave_f77_int_type lrw;
 
-  Array<octave_idx_type> iwork;
+  Array<octave_f77_int_type> iwork;
   Array<double> rwork;
 
   double rel_tol;
 
   Array<double> abs_tol;
 };
 
 #endif
