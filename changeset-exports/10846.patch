# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1280719337 25200
#      Sun Aug 01 20:22:17 2010 -0700
# Node ID a4f482e66b652f10385b99781bb52a32b1018530
# Parent  c0ffe159ba1a8f285a2fe0bb522fcbe7ad96e514
Grammarcheck more of the documentation.

Use @noindent macro appropriately.
Limit line length to 80 characters.

diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,8 +1,19 @@
+2010-08-01  Rik <octave@nomad.inbox5.com>
+
+	* interpreter/basics.txi, interpreter/contrib.txi,
+	interpreter/diagperm.txi, interpreter/dynamic.txi, interpreter/eos.txi,
+	interpreter/expr.txi, interpreter/geometry.txi,
+	interpreter/install.txi, interpreter/matrix.txi,
+	interpreter/numbers.txi, interpreter/oop.txi, interpreter/plot.txi,
+	interpreter/sparse.txi, interpreter/stats.txi, interpreter/testfun.txi,
+	interpreter/tips.txi: Grammarcheck documentation.  Add @noindent lines
+	and ensure line length is less than 80.
+
 2010-07-28  Rik <octave@nomad.inbox5.com>
 
 	* interpreter/arith.txi, interpreter/audio.txi, interpreter/basics.txi,
 	interpreter/container.txi, interpreter/contrib.txi,
 	interpreter/debug.txi, interpreter/diagperm.txi,
 	interpreter/diffeq.txi, interpreter/dynamic.txi, interpreter/emacs.txi,
 	interpreter/errors.txi, interpreter/eval.txi, interpreter/expr.txi,
 	interpreter/func.txi, interpreter/image.txi, interpreter/install.txi,
diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -1059,16 +1059,17 @@ function xdot = f (x, t)
 # differential equations.
 
   r = 0.25;
   @dots{}
 endfunction
 @end group
 @end example
 
+@noindent
 the command @kbd{help f} produces the output
 
 @example
 @group
  usage: f (x, t)
 
  This function defines the right-hand
  side functions for a set of nonlinear
diff --git a/doc/interpreter/contrib.txi b/doc/interpreter/contrib.txi
--- a/doc/interpreter/contrib.txi
+++ b/doc/interpreter/contrib.txi
@@ -239,18 +239,18 @@ matches_patterns (const string_vector& p
 @noindent
 The function name should start in column 1, and multi-line argument lists should
 be aligned on the first char after the open parenthesis.  You should put a space
 after the left open parenthesis and after commas, for both function definitions
 and function calls.
 
 Recommended indent is 2 spaces.  When indenting, indent the statement after
 control structures (like @code{if}, @code{while}, etc.). If there is a compound
-statement, indent @i{both} the curly braces and the body of the statement (so
-that the body gets indented by @i{two} indents).  Example:
+statement, indent @emph{both} the curly braces and the body of the statement (so
+that the body gets indented by @emph{two} indents).  Example:
 
 @example
 @group
 if (have_args)
   @{
     idx.push_back (first_args);
     have_args = false;
   @}
diff --git a/doc/interpreter/diagperm.txi b/doc/interpreter/diagperm.txi
--- a/doc/interpreter/diagperm.txi
+++ b/doc/interpreter/diagperm.txi
@@ -112,22 +112,24 @@ For creating permutation matrices, Octav
 rather overrides an existing syntax: permutation matrices can be conveniently
 created by indexing an identity matrix by permutation vectors.
 That is, if @var{q} is a permutation vector of length @var{n}, the expression
 
 @example
   P = eye (n) (:, q);
 @end example
 
+@noindent
 will create a permutation matrix - a special matrix object.
 
 @example
 eye (n) (q, :) 
 @end example
 
+@noindent
 will also work (and create a row permutation matrix), as well as 
 
 @example
 eye (n) (q1, q2).
 @end example
 
 For example:
 
@@ -241,23 +243,25 @@ Similarly, @code{M*D} will do a column s
 
 The matrix @var{D} may also be rectangular, m-by-n where @code{m != n}.
 If @code{m < n}, then the expression @code{D*M} is equivalent to
 
 @example
 D(:,1:m) * M(1:m,:),
 @end example
 
+@noindent
 i.e., trailing @code{n-m} rows of @var{M} are ignored.  If @code{m > n}, 
 then @code{D*M} is equivalent to 
 
 @example
 [D(1:n,n) * M; zeros(m-n, columns (M))],
 @end example
 
+@noindent
 i.e., null rows are appended to the result.
 The situation for right-multiplication @code{M*D} is analogous.
 
 The expressions @code{D \ M} and @code{M / D} perform inverse scaling.
 They are equivalent to solving a diagonal (or rectangular diagonal)
 in a least-squares minimum-norm sense.  In exact arithmetic, this is
 equivalent to multiplying by a pseudoinverse.  The pseudoinverse of
 a rectangular diagonal matrix is again a rectangular diagonal matrix
@@ -284,16 +288,17 @@ If @var{D1} and @var{D2} are both diagon
 D1 + D2
 D1 - D2 
 D1 * D2 
 D1 / D2 
 D1 \ D2
 @end group
 @end example
 
+@noindent
 again produce diagonal matrices, provided that normal
 dimension matching rules are obeyed.  The relations used are same as described
 above.
 
 Also, a diagonal matrix @var{D} can be multiplied or divided by a scalar, or
 raised to a scalar power if it is square, producing diagonal matrix result in
 all cases. 
 
@@ -304,16 +309,17 @@ will implicitly convert to full matrix.
 
 Adding a diagonal matrix to a full matrix only operates on the diagonal
 elements.  Thus,
 
 @example
 A = A + eps * eye (n)
 @end example
 
+@noindent
 is an efficient method of augmenting the diagonal of a matrix.  Subtraction
 works analogically.
 
 When involved in expressions with other element-by-element operators, @code{.*},
 @code{./}, @code{.\} or @code{.^}, an implicit conversion to full matrix will
 take place.  This is not always strictly necessary but chosen to facilitate
 better consistency with @sc{matlab}.
 
diff --git a/doc/interpreter/dynamic.txi b/doc/interpreter/dynamic.txi
--- a/doc/interpreter/dynamic.txi
+++ b/doc/interpreter/dynamic.txi
@@ -479,16 +479,17 @@ a particular field in a more concise man
 As can be seen the @code{contents} method of the @code{Octave_map} class
 returns a @code{Cell} which allows structure arrays to be represented.
 Therefore, to obtain the underlying @code{octave_value} we write
 
 @example
 octave_value tmp = arg0.contents (p1) (0);
 @end example
 
+@noindent
 where the trailing (0) is the () operator on the @code{Cell} object.  We
 can equally iterate of the elements of the Cell array to address the
 elements of the structure array.
 
 @node Sparse Matrices in Oct-Files
 @subsection Sparse Matrices in Oct-Files
 
 There are three classes of sparse objects that are of interest to the
@@ -536,16 +537,17 @@ of non-zero elements rather than the pro
 @example
 @group
 SparseMatrix sm;
 @dots{}
 int nel = sm.nelem ();
 @end group
 @end example
 
+@noindent
 returns the number of non-zero elements.  If the user really requires the
 number of elements in the matrix, including the non-zero elements, they
 should use @code{numel} rather than @code{nelem}.  Note that for very
 large matrices, where the product of the two dimensions is larger than
 the representation of an unsigned int, then @code{numel} can overflow.
 An example is @code{speye(1e6)} which will create a matrix with a million
 rows and columns, but only a million non-zero elements.  Therefore the
 number of rows by the number of columns in this case is more than two
@@ -566,16 +568,17 @@ SparseMatrix sm;
 @dots{}
 for (int j = 0; j < nc; j++)
   for (int i = 0; i < nr; i++)
     std::cerr << " (" << i << "," << j << "): " << sm(i,j)
               << std::endl;
 @end group
 @end example
 
+@noindent
 is a great way of turning the sparse matrix into a dense one, and a
 very slow way at that since it reallocates the sparse object at each
 zero element in the matrix.
 
 An easy way of preventing the above from happening is to create a temporary
 constant version of the sparse matrix.  Note that only the container for
 the sparse matrix will be copied, while the actual representation of the
 data will be shared between the two versions of the sparse matrix.  So this
@@ -1017,16 +1020,17 @@ new/delete operators can be used.  Howev
 taken to avoid memory leaks.  The preferred manner in which to allocate
 memory for use locally is to use the @w{@code{OCTAVE_LOCAL_BUFFER}} macro.
 An example of its use is
 
 @example
 OCTAVE_LOCAL_BUFFER (double, tmp, len)
 @end example
 
+@noindent
 that returns a pointer @code{tmp} of type @code{double *} of length
 @code{len}.
 
 @node Input Parameter Checking in Oct-Files
 @subsection Input Parameter Checking in Oct-Files
 
 As oct-files are compiled functions they have the possibility of causing
 Octave to abort abnormally.  It is therefore important that
diff --git a/doc/interpreter/eos.txi b/doc/interpreter/eos.txi
--- a/doc/interpreter/eos.txi
+++ b/doc/interpreter/eos.txi
@@ -36,17 +36,17 @@ useful in particular for debugging Octav
 
 Finally, you can convince Octave to use the Emacs info reader for
 @kbd{help -i}.
 
 All functionality is provided by the Emacs Lisp package EOS (for ``Emacs
 Octave Support'').  This chapter describes how to set up and use this
 package.
 
-Please contact <Kurt.Hornik@@wu-wien.ac.at> if you have any questions
+Please contact @email{Kurt.Hornik@@wu-wien.ac.at} if you have any questions
 or suggestions on using EOS.
 
 @menu
 * Installing EOS::              
 * Using Octave Mode::           
 * Running Octave From Within Emacs::  
 * Using the Emacs Info Reader for Octave::  
 @end menu
@@ -140,23 +140,23 @@ Break line at point and insert continuat
 Perform completion on Octave symbol preceding point, comparing that
 symbol against Octave's reserved words and built-in variables
 (@code{octave-complete-symbol}). 
 
 @item M-C-a
 Move backward to the beginning of a function
 (@code{octave-beginning-of-defun}).
 With prefix argument @var{N}, do it that many times if @var{N} is
-positive;  otherwise, move forward to the @var{N}-th following beginning
+positive; otherwise, move forward to the @var{N}-th following beginning
 of a function.
 
 @item M-C-e
 Move forward to the end of a function (@code{octave-end-of-defun}).
 With prefix argument @var{N}, do it that many times if @var{N} is
-positive;  otherwise, move back to the @var{N}-th preceding end of a
+positive; otherwise, move back to the @var{N}-th preceding end of a
 function.
 
 @item M-C-h
 Puts point at beginning and mark at the end of the current Octave
 function, i.e., the one containing point or following point
 (@code{octave-mark-defun}).
 
 @item M-C-q
@@ -189,19 +189,19 @@ negative).
 @item C-c C-n
 Move one line of Octave code forward, skipping empty and comment lines
 (@code{octave-next-code-line}).  With numeric prefix argument @var{N},
 move that many code lines forward (backward if @var{N} is negative).
 
 @item C-c C-a
 Move to the `real' beginning of the current line
 (@code{octave-beginning-of-line}).  If point is in an empty or comment
-line, simply go to its beginning;  otherwise, move backwards to the
+line, simply go to its beginning; otherwise, move backwards to the
 beginning of the first code line which is not inside a continuation
-statement,  i.e., which does not follow a code line ending in @samp{...}
+statement, i.e., which does not follow a code line ending in @samp{...}
 or @samp{\}, or is inside an open parenthesis list.
 
 @item C-c C-e
 Move to the `real' end of the current line (@code{octave-end-of-line}).
 If point is in a code line, move forward to the end of the first Octave
 code line which does not end in @samp{...} or @samp{\} or is inside an
 open parenthesis list.  Otherwise, simply go to the end of the current
 line.
@@ -216,17 +216,17 @@ negative).
 Move back across one balanced begin-end block of Octave code
 (@code{octave-backward-block}).  With numeric prefix argument @var{N},
 move backward across @var{N} such blocks (forward if @var{N} is
 negative).
 
 @item C-c M-C-d
 Move forward down one begin-end block level of Octave code
 (@code{octave-down-block}).  With numeric prefix argument, do it that
-many times;  a negative argument means move backward, but still go down
+many times; a negative argument means move backward, but still go down
 one level.
 
 @item C-c M-C-u
 Move backward out of one begin-end block level of Octave code
 (@code{octave-backward-up-block}).  With numeric prefix argument, do it
 that many times; a negative argument means move forward, but still to a
 less deep spot.
 
@@ -263,17 +263,17 @@ in one of your Emacs startup files.
 
 @end table
 
 A common problem is that the @key{RET} key does @emph{not} indent the
 line to where the new text should go after inserting the newline.  This
 is because the standard Emacs convention is that @key{RET} (aka
 @kbd{C-m}) just adds a newline, whereas @key{LFD} (aka @kbd{C-j}) adds a
 newline and indents it.  This is particularly inconvenient for users with
-keyboards which do not have a special @key{LFD} key at all;  in such
+keyboards which do not have a special @key{LFD} key at all; in such
 cases, it is typically more convenient to use @key{RET} as the @key{LFD}
 key (rather than typing @kbd{C-j}).  
 
 You can make @key{RET} do this by adding
 @lisp
 (define-key octave-mode-map "\C-m"
   'octave-reindent-then-newline-and-indent)
 @end lisp
@@ -285,17 +285,17 @@ solution is
   (let ((x (key-binding "\C-j")))
     (local-set-key "\C-m" x)))
 (add-hook 'octave-mode-hook 'RET-behaves-as-LFD)
 @end lisp
 @noindent
 (this works for all modes by adding to the startup hooks, without having
 to know the particular binding of @key{RET} in that mode!).  Similar
 considerations apply for using @key{M-RET} as @key{M-LFD}.  As Barry
-A. Warsaw <bwarsaw@@cnri.reston.va.us> says in the documentation for his
+A. Warsaw @email{bwarsaw@@cnri.reston.va.us} says in the documentation for his
 @code{cc-mode}, ``This is a very common question.  @code{:-)} If you want
 this to be the default behavior, don't lobby me, lobby RMS!''
 
 The following variables can be used to customize Octave mode.
 
 @table @code
 @item octave-auto-indent
 Non-@code{nil} means auto-indent the current line after a semicolon or
@@ -328,25 +328,29 @@ If @code{t} (default), a startup message
 is called.
 
 @end table
 
 If Font Lock mode is enabled, Octave mode will display
 @itemize @bullet
 @item
 strings in @code{font-lock-string-face}
+
 @item
 comments in @code{font-lock-comment-face}
+
 @item
 the Octave reserved words (such as all block keywords) and the text
 functions (such as @samp{cd} or @samp{who}) which are also reserved
 using @code{font-lock-keyword-face}
+
 @item
 the built-in operators (@samp{&&}, @samp{==}, @dots{}) using
 @code{font-lock-reference-face}
+
 @item
 and the function names in function declarations in
 @code{font-lock-function-name-face}.
 @end itemize
 
 There is also rudimentary support for Imenu (currently, function names
 can be indexed).
 
@@ -393,31 +397,37 @@ following commands.
 
 @table @kbd
 @item C-c i l
 Send the current line to the inferior Octave process
 (@code{octave-send-line}).
 With positive prefix argument @var{N}, send that many lines.
 If @code{octave-send-line-auto-forward} is non-@code{nil}, go to the
 next unsent code line.
+
 @item C-c i b
 Send the current block to the inferior Octave process
 (@code{octave-send-block}).
+
 @item C-c i f
 Send the current function to the inferior Octave process
 (@code{octave-send-defun}).
+
 @item C-c i r
 Send the region to the inferior Octave process
 (@code{octave-send-region}).
+
 @item C-c i s
 Make sure that `inferior-octave-buffer' is displayed
 (@code{octave-show-process-buffer}).
+
 @item C-c i h
 Delete all windows that display the inferior Octave buffer
 (@code{octave-hide-process-buffer}).
+
 @item C-c i k
 Kill the inferior Octave process and its buffer
 (@code{octave-kill-process}).
 @end table
 
 The effect of the commands which send code to the Octave process can be
 customized by the following variables.
 @table @code
@@ -435,17 +445,17 @@ If you send code and there is no inferio
 started automatically.
 
 The startup of the inferior Octave process is highly customizable.
 The variable @code{inferior-octave-startup-args} can be used for
 specifying command lines arguments to be passed to Octave on startup
 as a list of strings.  For example, to suppress the startup message and
 use `traditional' mode, set this to @code{'("-q" "--traditional")}.
 You can also specify a startup file of Octave commands to be loaded on
-startup;  note that these commands will not produce any visible output
+startup; note that these commands will not produce any visible output
 in the process buffer.  Which file to use is controlled by the variable
 @code{inferior-octave-startup-file}.  If this is @code{nil}, the file
 @file{~/.emacs-octave} is used if it exists.
 
 And finally, @code{inferior-octave-mode-hook} is run after starting the
 process and putting its buffer into Inferior Octave mode.  Hence, if you
 like the up and down arrow keys to behave in the interaction buffer as
 in the shell, and you want this buffer to use nice colors, add
@@ -490,17 +500,17 @@ If @file{gnuserv} is installed, add the 
 (require 'gnuserv)
 (gnuserv-start)
 @end lisp
 @noindent
 to your @file{.emacs} file.
 
 You can use either `plain' Emacs Info or the function @code{octave-help}
 as your Octave info reader (for @samp{help -i}).  In the former case,
-set the Octave variable @w{@code{INFO_PROGRAM}} to @code{"info-emacs-info"}.
+set the Octave variable @w{@env{INFO_PROGRAM}} to @code{"info-emacs-info"}.
 The latter is perhaps more attractive because it allows to look up keys
 in the indices of @emph{several} info files related to Octave (provided
 that the Emacs variable @code{octave-help-files} is set correctly).  In
-this case, set @w{@code{INFO_PROGRAM}} to @code{"info-emacs-octave-help"}.
+this case, set @w{@env{INFO_PROGRAM}} to @code{"info-emacs-octave-help"}.
 
 If you use Octave from within Emacs, these settings are best done in the
 @file{~/.emacs-octave} startup file (or the file pointed to by the Emacs
 variable @code{inferior-octave-startup-file}).
diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -150,16 +150,17 @@ row vector, the expressions
 @example
   r(ones (1, n), :)
 @end example
 
 @example
   r(ones (n, 1), :)
 @end example
 
+@noindent
 will produce identical results, but the first one will be significantly
 faster, at least for @samp{r} and @samp{n} large enough.  The reason is that
 in the first case the index is kept in a compressed form, which allows Octave
 to choose a more efficient algorithm to handle the expression.
 
 In general, for an user unaware of these subtleties, it is best to use
 the function @dfn{repmat} for spreading arrays into bigger ones.
 
diff --git a/doc/interpreter/geometry.txi b/doc/interpreter/geometry.txi
--- a/doc/interpreter/geometry.txi
+++ b/doc/interpreter/geometry.txi
@@ -111,16 +111,17 @@ An example of the use of the @code{tripl
 rand ("state", 2)
 x = rand (20, 1);
 y = rand (20, 1);
 tri = delaunay (x, y);
 triplot (tri, x, y);
 @end group
 @end example
 
+@noindent
 that plot the Delaunay triangulation of a set of random points in
 2-dimensions.
 @ifnotinfo
 The output of the above can be seen in @ref{fig:triplot}.
 
 @float Figure,fig:triplot
 @center @image{triplot,4in}
 @caption{Delaunay triangulation of a random set of points}
diff --git a/doc/interpreter/install.txi b/doc/interpreter/install.txi
--- a/doc/interpreter/install.txi
+++ b/doc/interpreter/install.txi
@@ -70,17 +70,17 @@ Octave with this option has a negative i
 recommended for general use.
 
 @item --enable-64
 This is an @strong{experimental} option to enable Octave to use 64-bit
 integers for array dimensions and indexing on 64-bit platforms.  You
 probably don't want to use this option unless you know what you are
 doing.
 
-If you use @code{--enable-64}, you must ensure that your Fortran
+If you use @option{--enable-64}, you must ensure that your Fortran
 compiler generates code with 8 byte signed @code{INTEGER} values, and
 that your @sc{blas} and @sc{lapack} libraries are compiled to use 8 byte
 signed integers for array dimensions and indexing.
 
 @item --enable-shared
 Create shared libraries (this is the default).  If you are planning to
 use the dynamic loading features, you will probably want to use this
 option.  It will make your @file{.oct} files much smaller and on some
diff --git a/doc/interpreter/matrix.txi b/doc/interpreter/matrix.txi
--- a/doc/interpreter/matrix.txi
+++ b/doc/interpreter/matrix.txi
@@ -43,17 +43,17 @@ The @code{find} function is also useful 
 a matrix meet a specified condition.
 
 @DOCSTRING(any)
 
 @DOCSTRING(all)
 
 Since the comparison operators (@pxref{Comparison Ops}) return matrices
 of ones and zeros, it is easy to test a matrix for many things, not just
-whether the elements are nonzero.  For example, 
+whether the elements are nonzero.  For example,
 
 @example
 @group
 all (all (rand (5) < 0.9))
      @result{} 0
 @end group
 @end example
 
diff --git a/doc/interpreter/numbers.txi b/doc/interpreter/numbers.txi
--- a/doc/interpreter/numbers.txi
+++ b/doc/interpreter/numbers.txi
@@ -405,16 +405,17 @@ When adding a scalar to a range, subtrac
 range from a scalar) and multiplying by scalar, Octave will attempt to avoid
 unpacking the range and keep the result as a range, too, if it can determine
 that it is safe to do so.  For instance, doing
 
 @example
 a = 2*(1:1e7) - 1;
 @end example
 
+@noindent
 will produce the same result as @samp{1:2:2e7-1}, but without ever forming a
 vector with ten million elements.
 
 Using zero as an increment in the colon notation, as @samp{1:0:1} is not
 allowed, because a division by zero would occur in determining the number of
 range elements.  However, ranges with zero increment (i.e., all elements equal)
 are useful, especially in indexing, and Octave allows them to be constructed
 using the built-in function @dfn{ones}.  Note that because a range must be a row
@@ -573,16 +574,17 @@ arguments must have the same shape, and 
 to each of the elements of the argument individually.  If at least one
 argument is a scalar and one an array, then the scalar argument is
 duplicated.  Therefore
 
 @example
 bitget (100, 8:-1:1)
 @end example
 
+@noindent
 is the same as
 
 @example
 bitget (100 * ones (1, 8), 8:-1:1)
 @end example
 
 It should be noted that all values passed to the bit manipulation
 functions of Octave are treated as integers.  Therefore, even though the
diff --git a/doc/interpreter/oop.txi b/doc/interpreter/oop.txi
--- a/doc/interpreter/oop.txi
+++ b/doc/interpreter/oop.txi
@@ -119,17 +119,17 @@ getting help for the overloaded methods 
 The same is true for other Octave functions that take a function name
 as an argument.  For example @code{type @@polynomial/display} will
 print the code of the display method of the polynomial class to the
 screen, and @code{dbstop @@polynomial/display} will set a breakpoint
 at the first executable line of the display method of the polynomial
 class.
 
 To check where a variable is a user class, the @code{isobject} and
-@code{isa} functions can be used. for example
+@code{isa} functions can be used. for example:
 
 @example
 @group
 p = polynomial ([1, 0, 1]);
 isobject (p)
 @result{} 1
 isa (p, "polynomial")
 @result{} 1
@@ -146,17 +146,17 @@ The available methods of a class can be 
 
 @noindent
 To inquire whether a particular method is available to a user class, the
 @code{ismethod} function can be used.
 
 @DOCSTRING(ismethod)
 
 @noindent
-For example
+For example:
 
 @example
 @group
 p = polynomial ([1, 0, 1]);
 ismethod (p, "roots")
 @result{} 1
 @end group
 @end example
@@ -187,17 +187,17 @@ Note that in the display method, it make
 with the line @code{fprintf("%s =", inputname(1))} to be consistent
 with the rest of Octave and print the variable name to be displayed
 when displaying the class. 
 
 To be consistent with the Octave graphic handle classes, a class
 should also define the @code{get} and @code{set} methods.  The
 @code{get} method should accept one or two arguments, and given one
 argument of the appropriate class it should return a structure with
-all of the properties of the class.  For example
+all of the properties of the class.  For example:
 
 @example
 @group
 @EXAMPLEFILE(@polynomial/get.m)
 @end group
 @end example
 
 @noindent
@@ -221,17 +221,17 @@ p = set (p, "a", [1, 0, 0, 0, 1]);
 
 @noindent
 Also the @code{set} method makes use of the @code{subsasgn} method of
 the class, and this method must be defined.  The @code{subsasgn} method
 is discussed in the next section.
 
 Finally, user classes can be considered as a special type of a
 structure, and so they can be saved to a file in the same manner as a
-structure.  For example
+structure.  For example:
 
 @example
 @group
 p = polynomial ([1, 0, 1]);
 save userclass.mat p
 clear p
 load userclass.mat
 @end group
@@ -272,18 +272,19 @@ to decide what this indexing actually me
 class @code{@var{p} (@var{n})} might mean either the coefficient of the 
 @var{n}-th power of the polynomial, or it might be the evaluation of the 
 polynomial at @var{n}.  The meaning of this subscripted referencing is 
 determined by the @code{subsref} method.
 
 @DOCSTRING(subsref)
 
 For example we might decide that indexing with "()" evaluates the
-polynomial and indexing with "@{@}" returns the @var{n}-th coefficient (of @var{n}-th power).
-In this case the @code{subsref} method of our polynomial class might look like
+polynomial and indexing with "@{@}" returns the @var{n}-th coefficient (of
+@var{n}-th power).  In this case the @code{subsref} method of our polynomial
+class might look like
 
 @example
 @group
 @EXAMPLEFILE(@polynomial/subsref.m)
 @end group
 @end example
 
 The equivalent functionality for subscripted assignments uses the 
@@ -342,16 +343,17 @@ a call to subsasgn:
 
 @example
 @group
   ss = substruct ("()",@{1@});
   x = subsasgn (x, ss, 1);
 @end group
 @end example
 
+@noindent
 and the corresponding method looking like this:
 
 @example
 @group
   function x = subsasgn (x, ss, val)
     @dots{}
     x.myfield(ss.subs@{1@}) = val;
   endfunction
@@ -382,28 +384,27 @@ call as shown above), i.e.
 @b{AND} if the subsasgn method is declared with identical input and output argument,
 like in the example above, then Octave will ignore the copy of @code{x} inside
 the caller's scope; therefore, any changes made to @code{x} during the method
 execution will directly affect the caller's copy as well.
 This allows, for instance, defining a polynomial class where modifying a single
 element takes constant time.
 
 It is important to understand the implications that this optimization brings.
-Since no extra copy of @code{x} in the caller's scope will exist, it is @i{solely}
-the callee's responsibility to not leave @code{x} in an invalid state if an error
-occurs throughout the execution.  Also, if the method partially changes @code{x}
-and then errors out, the changes @i{will} affect @code{x} in the caller's scope.
-Deleting or completely replacing @code{x} inside subsasgn will not do anything,
-however, only indexed assignments matter.
+Since no extra copy of @code{x} in the caller's scope will exist, it is
+@emph{solely} the callee's responsibility to not leave @code{x} in an invalid
+state if an error occurs throughout the execution.  Also, if the method
+partially changes @code{x} and then errors out, the changes @emph{will} affect
+@code{x} in the caller's scope.  Deleting or completely replacing @code{x}
+inside subsasgn will not do anything, however, only indexed assignments matter.
 
-Since this optimization may change the way code works (especially if badly written),
-a built-in variable @code{optimize_subsasgn_calls} is provided to control it.
-It is on by default.
-Another option to avoid the effect is to declare subsasgn methods with different
-output and input arguments, like this:
+Since this optimization may change the way code works (especially if badly
+written), a built-in variable @code{optimize_subsasgn_calls} is provided to
+control it.  It is on by default.  Another option to avoid the effect is to
+declare subsasgn methods with different output and input arguments, like this:
 
 @example
 @group
   function y = subsasgn (x, ss, val)
     @dots{}
   endfunction
 @end group
 @end example
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -577,16 +577,17 @@ with the codes
 
 These are be used in conjunction with the @{ and @} characters to limit
 the change in the font to part of the string.  For example,
 
 @example
 xlabel ('@{\bf H@} = a @{\bf V@}')
 @end example
 
+@noindent
 where the character 'a' will not appear in a bold font.  Note that to
 avoid having Octave interpret the backslash characters in the strings,
 the strings should be in single quotes.
 
 It is also possible to change the fontname and size within the text
 
 @multitable @columnfractions .1 .4 .6 .1
 @item @tab \fontname@{@var{fontname}@} @tab Specify the font to use @tab
@@ -846,38 +847,35 @@ at the Octave prompt should display a th
 * Managing Default Properties::  
 @end menu
 
 @node Introduction to Graphics Structures
 @subsection Introduction to Graphics Structures
 @cindex introduction to graphics structures
 @anchor{doc-graphics structures}
 
-The graphics functions use pointers, which are of class graphics_handle,
-in order to address the data structures which control
-graphical displays.
-A graphics handle may point any one of a number of different object types.
-The objects are the graphics data structures.  The types of objects
-are: @code{figure}, @code{axes},
-@code{line}, @code{text}, @code{patch},
+The graphics functions use pointers, which are of class graphics_handle, in
+order to address the data structures which control graphical displays.  A
+graphics handle may point any one of a number of different object types.  The
+objects are the graphics data structures.  The types of objects are:
+@code{figure}, @code{axes}, @code{line}, @code{text}, @code{patch},
 @code{surface}, @code{text} and @code{image}.
 
-Each of these objects has a function by the
-same name. and, each of these functions returns a graphics handle pointing
-to an object of corresponding type.  In addition there are several functions
-which operate on properties of the graphics objects and which return handles:
-the functions @code{ plot} and @code{plot3} return a handle pointing to an
-object of type line, the function @code{subplot} returns a handle pointing to an
-object of type axes, the function @code{fill} returns a handle pointing to an
-object of type patch, the functions @code{area}, @code{bar},
-@code{barh}, @code{contour}, @code{contourf}, @code{contour3}, @code{surf}, @code{mesh},
-@code{surfc}, @code{meshc},
-@code{errorbar}, @code{quiver}, @code{quiver3}, @code{scatter}, @code{scatter3},
-@code{stair}, @code{stem}, @code{stem3} each return a handle as documented
-in @ref{doc-datasources,, Data Sources}.
+Each of these objects has a function by the same name. and, each of these
+functions returns a graphics handle pointing to an object of corresponding
+type.  In addition there are several functions which operate on properties of
+the graphics objects and which return handles: the functions @code{ plot} and
+@code{plot3} return a handle pointing to an object of type line, the function
+@code{subplot} returns a handle pointing to an object of type axes, the
+function @code{fill} returns a handle pointing to an object of type patch, the
+functions @code{area}, @code{bar}, @code{barh}, @code{contour},
+@code{contourf}, @code{contour3}, @code{surf}, @code{mesh}, @code{surfc},
+@code{meshc}, @code{errorbar}, @code{quiver}, @code{quiver3}, @code{scatter},
+@code{scatter3}, @code{stair}, @code{stem}, @code{stem3} each return a handle
+as documented in @ref{doc-datasources,, Data Sources}.
 
 
 The graphics objects are arranged in a hierarchy:
 
 1. The root is at 0.  i.e., @code{get(0)} returns the properties of the root
    object.
 
 2. Below the root are @code{figure} objects.
@@ -1006,16 +1004,17 @@ The uses of @code{get()} and @code{set()
 The hierarchy of graphics objects was explained above.  (See 
 @ref{Introduction to Graphics Structures}.  Here the
 specific objects are described, and the properties contained in
 these objects are discussed.  Keep in mind that
 graphics objects are always referenced by @dfn{handle}.
 
 @table @asis
 @c @group
+
 @item root figure
 @cindex root figure graphics object
 @cindex graphics object, root figure
 the top level of the hierarchy and the parent of all figure objects.
 The @code{handle} index of the root figure is 0.
 
 @item figure
 @cindex figure graphics object
@@ -2561,16 +2560,17 @@ is
 @example
 @group
 function mycallback (src, data)
 @dots{}
 endfunction
 @end group
 @end example
 
+@noindent
 where @code{src} gives a handle to the source of the callback, and
 @code{code} gives some event specific data.  This can then be associated
 with an object either at the objects creation or later with the
 @code{set} function.  For example,
 
 @example
 plot (x, "DeleteFcn", @@(s, e) disp("Window Deleted"))
 @end example
diff --git a/doc/interpreter/sparse.txi b/doc/interpreter/sparse.txi
--- a/doc/interpreter/sparse.txi
+++ b/doc/interpreter/sparse.txi
@@ -210,16 +210,17 @@ Other functions of interest that directl
 @dfn{diag} or its generalization @dfn{spdiags}, that can take the
 definition of the diagonals of the matrix and create the sparse matrix 
 that corresponds to this.  For example,
 
 @example
 s = diag (sparse(randn(1,n)), -1);
 @end example
 
+@noindent
 creates a sparse (@var{n}+1)-by-(@var{n}+1) sparse matrix with a single
 diagonal defined.
 
 
 @DOCSTRING(spdiags)
 
 @DOCSTRING(speye)
 
@@ -248,16 +249,17 @@ vector of the same size containing the d
     ri = [ri; randperm(r)(1:n)'];
     ci = [ci; j*ones(n,1)];
     d = [d; rand(n,1)];
   endfor
   s = sparse (ri, ci, d, r, c);
 @end group
 @end example
 
+@noindent
 creates an @var{r}-by-@var{c} sparse matrix with a random distribution
 of @var{n} (<@var{r}) elements per column.  The elements of the vectors
 do not need to be sorted in any particular order as Octave will sort
 them prior to storing the data.  However, pre-sorting the data will
 make the creation of the sparse matrix faster.
 
 The function @dfn{spconvert} takes a three or four column real matrix.
 The first two columns represent the row and column index respectively and
@@ -355,16 +357,17 @@ to use of the div or ldiv operators.  Fo
 @group
 a = tril (sprandn(1024, 1024, 0.02), -1) ...
     + speye(1024); 
 matrix_type (a);
 ans = Lower
 @end group
 @end example
 
+@noindent
 shows that Octave correctly determines the matrix type for lower
 triangular matrices.  @dfn{matrix_type} can also be used to force
 the type of a matrix to be a particular type.  For example:
 
 @example
 @group
 a = matrix_type (tril (sprandn (1024, ...
    1024, 0.02), -1) + speye(1024), 'Lower');
@@ -404,16 +407,17 @@ As a trivial example of the use of @dfn{
 @group
 A = sparse([2,6,1,3,2,4,3,5,4,6,1,5],
     [1,1,2,2,3,3,4,4,5,5,6,6],1,6,6);
 xy = [0,4,8,6,4,2;5,0,5,7,5,7]';
 gplot(A,xy)
 @end group
 @end example
 
+@noindent
 which creates an adjacency matrix @code{A} where node 1 is connected
 to nodes 2 and 6, node 2 with nodes 1 and 3, etc.  The coordinates of
 the nodes are given in the n-by-2 matrix @code{xy}.
 @ifset htmltex 
 @xref{fig:gplot}.
 
 @float Figure,fig:gplot
 @center @image{gplot,4in}
@@ -529,16 +533,17 @@ make it a full matrix, and so the exampl
 @group
 speye(3) + 0
 @result{}   1  0  0
   0  1  0
   0  0  1
 @end group
 @end example
 
+@noindent
 returns a full matrix as can be seen. 
 
 
 Additionally, if @code{sparse_auto_mutate} is true, all sparse functions
 test the amount of memory occupied by the sparse matrix to see if the
 amount of storage used is larger than the amount used by the full
 equivalent.  Therefore @code{speye (2) * 1} will return a full matrix as
 the memory used is smaller for the full version than the sparse version.
@@ -556,16 +561,17 @@ There is however one known case where th
 sparse matrices will cause a problem.  That is in the handling of the
 @dfn{diag} function.  Whether @dfn{diag} returns a sparse or full matrix
 depending on the type of its input arguments.  So 
 
 @example
  a = diag (sparse([1,2,3]), -1);
 @end example
 
+@noindent
 should return a sparse matrix.  To ensure this actually happens, the
 @dfn{sparse} function, and other functions based on it like @dfn{speye}, 
 always returns a sparse matrix, even if the memory used will be larger 
 than its full representation.
 
 @DOCSTRING(sparse_auto_mutate)
 
 Note that the @code{sparse_auto_mutate} option is incompatible with
@@ -588,16 +594,17 @@ the examples
   a2 = s .^ s;
   a3 = s .^ -2;
   a4 = s ./ 2;
   a5 = 2 ./ s;
   a6 = s ./ s;
 @end group
 @end example
 
+@noindent
 will give.  The first example of @var{s} raised to the power of 2 causes
 no problems.  However @var{s} raised element-wise to itself involves a
 large number of terms @code{0 .^ 0} which is 1. There @code{@var{s} .^
 @var{s}} is a full matrix. 
 
 Likewise @code{@var{s} .^ -2} involves terms like @code{0 .^ -2} which
 is infinity, and so @code{@var{s} .^ -2} is equally a full matrix.
 
diff --git a/doc/interpreter/stats.txi b/doc/interpreter/stats.txi
--- a/doc/interpreter/stats.txi
+++ b/doc/interpreter/stats.txi
@@ -19,17 +19,17 @@
 
 @node Statistics
 @chapter Statistics
 
 Octave has support for various statistical methods.  This includes
 basic descriptive statistics, statistical tests, random number generation,
 and much more.
 
-The functions that analyze data all assume that multidimensional data
+The functions that analyze data all assume that multi-dimensional data
 is arranged in a matrix where each row is an observation, and each
 column is a variable.  So, the matrix defined by
 
 @example
 @group
 a = [ 0.9, 0.7;
       0.1, 0.1;
       0.5, 0.4 ];
diff --git a/doc/interpreter/testfun.txi b/doc/interpreter/testfun.txi
--- a/doc/interpreter/testfun.txi
+++ b/doc/interpreter/testfun.txi
@@ -112,16 +112,17 @@ generate the error:
 
 Because @code{assert} is so frequently used alone in a test block, there
 is a shorthand form:
 
 @example
    %!assert (@dots{})
 @end example
 
+@noindent
 which is equivalent to:
 
 @example
    %!test assert (@dots{})
 @end example
 
 Sometimes during development there is a test that should work but is
 known to fail.  You still want to leave the test in because when the
@@ -179,22 +180,23 @@ Error and warning blocks are like test b
 if the code generates an error.  You can check the text of the error
 is correct using an optional regular expression @code{<pattern>}.  
 For example:
 
 @example
    %!error <passes!> error('this test passes!');
 @end example
 
-If the code doesn't generate an error, the test fails.  For example,
+If the code doesn't generate an error, the test fails.  For example:
 
 @example
    %!error "this is an error because it succeeds.";
 @end example
 
+@noindent
 produces
 
 @example
 @group
    ***** error "this is an error because it succeeds.";
    !!!!! test failed: no error
 @end group
 @end example
@@ -209,16 +211,17 @@ it is executed.  For example,
 @group
    %!demo
    %! @var{t}=[0:0.01:2*pi]; @var{x}=sin(@var{t});
    %! plot(@var{t},@var{x});
    %! you should now see a sine wave in your figure window
 @end group
 @end example
 
+@noindent
 produces
 
 @example
 @group
    > @var{t}=[0:0.01:2*pi]; @var{x}=sin(@var{t});
    > plot(@var{t},@var{x});
    > you should now see a sine wave in your figure window
    Press <enter> to continue: 
@@ -277,26 +280,28 @@ can even embed tests directly in your C+
 @example
 @group
    #if 0
    %!test disp('this is a test')
    #endif
 @end group
 @end example
 
+@noindent
 or
 
 @example
 @group
    /*
    %!test disp('this is a test')
    */
 @end group
 @end example
 
+@noindent
 but then the code will have to be on the load path and the user 
 will have to remember to type test('name.cc').  Conversely, you
 can separate the tests from normal Octave script files by putting
 them in plain files with no extension rather than in script files.
 @c DO I WANT TO INCLUDE THE EDITOR SPECIFIC STATEMENT BELOW???
 @c Don't forget to tell emacs that the plain text file you are using
 @c is actually octave code, using something like:
 @c   -*-octave-*-
diff --git a/doc/interpreter/tips.txi b/doc/interpreter/tips.txi
--- a/doc/interpreter/tips.txi
+++ b/doc/interpreter/tips.txi
@@ -90,16 +90,17 @@ Vectorize loops.  For instance, rather t
 @example
 @group
 for i = 1:n-1
   a(i) = b(i+1) - b(i);
 endfor
 @end group
 @end example
 
+@noindent
 write
 
 @example
 a = b(2:n) - b(1:n-1);
 @end example
 
 This is especially important for loops with "cheap" bodies.  Often it suffices
 to vectorize just the innermost loop to get acceptable performance.  A general
@@ -112,16 +113,17 @@ are very fast.  Even with a m-file libra
 already optimized, or will be optimized more in a future release.
 
 For instance, even better than
 
 @example
 a = b(2:n) - b(1:n-1);
 @end example
 
+@noindent
 is
 
 @example
 a = diff (b);
 @end example
 
 
 @item
@@ -621,16 +623,17 @@ strings is the @code{@@example} environm
 @@group
 @@code@{2 * 2@}
 @@result@{@} 4
 @@end group
 @@end example
 @end group
 @end example
 
+@noindent
 which produces
 
 @example
 @group
 @code{2 * 2}
 @result{} 4
 @end group
 @end example
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,23 @@
+2010-08-01  Rik <octave@nomad.inbox5.com>
+
+	* deprecated/intwarning.m, general/arrayfun.m, general/cplxpair.m,
+	general/interp1.m, general/interpn.m, general/quadgk.m,
+	general/structfun.m, image/image_viewer.m, io/strread.m,
+	miscellaneous/warning_ids.m, optimization/lsqnonneg.m, pkg/pkg.m,
+	plot/__marching_cube__.m, plot/bar.m, plot/contourc.m, plot/errorbar.m,
+	plot/ezplot.m, plot/isocolors.m, plot/isonormals.m, plot/isosurface.m,
+	plot/stem.m, plot/stem3.m, polynomial/compan.m, polynomial/ppval.m,
+	signal/arch_rnd.m, sparse/pcg.m, sparse/svds.m,
+	special-matrix/invhilb.m, statistics/distributions/wblcdf.m,
+	testfun/assert.m, testfun/demo.m, testfun/speed.m: 
+	Grammarcheck documentation.  Add @noindent lines and ensure line 
+	length is less than 80.
+
 2010-08-01  Martin Helm <martin@mhelm.de>
 
 	* plot/isosurface.m: Swap rows and columns of matrix in call to
 	meshgrid.
 
 2010-08-01  Rik <octave@nomad.inbox5.com>
 
 	* plot/print.m: Update documentation string.  Change to active voice.
diff --git a/scripts/deprecated/intwarning.m b/scripts/deprecated/intwarning.m
--- a/scripts/deprecated/intwarning.m
+++ b/scripts/deprecated/intwarning.m
@@ -23,18 +23,18 @@
 ## Control the state of the warning for integer conversions and math
 ## operations.
 ##
 ## @table @asis
 ## @item "query"
 ## With an output argument, return the current state of the integer
 ## conversion and math warnings.  With no output arguments, print the
 ## current state.
+## @c Set example in small font to prevent overfull line
 ##
-## @c Set example in small font to prevent overfull line
 ## @smallexample
 ## @group
 ## intwarning ("query")
 ## The state of warning "Octave:int-convert-nan" is "off"
 ## The state of warning "Octave:int-convert-non-int-val" is "off"
 ## The state of warning "Octave:int-convert-overflow" is "off"
 ## The state of warning "Octave:int-math-overflow" is "off"
 ## @end group
diff --git a/scripts/general/arrayfun.m b/scripts/general/arrayfun.m
--- a/scripts/general/arrayfun.m
+++ b/scripts/general/arrayfun.m
@@ -99,16 +99,17 @@
 ## function or an anonymous function, then @var{errfunc} defines a
 ## function to call in the case that @var{func} generates an error.
 ## The definition of the function must be of the form
 ##
 ## @example
 ## function [@dots{}] = errfunc (@var{s}, @dots{})
 ## @end example
 ##
+## @noindent
 ## where there is an additional input argument to @var{errfunc}
 ## relative to @var{func}, given by @var{s}.  This is a structure with
 ## the elements "identifier", "message" and "index", giving
 ## respectively the error identifier, the error message and the index of
 ## the array elements that caused the error.  The size of the output
 ## argument of @var{errfunc} must have the same size as the output
 ## argument of @var{func}, otherwise a real error is thrown.  For
 ## example:
diff --git a/scripts/general/cplxpair.m b/scripts/general/cplxpair.m
--- a/scripts/general/cplxpair.m
+++ b/scripts/general/cplxpair.m
@@ -31,18 +31,18 @@
 ## By default the complex pairs are sorted along the first non-singleton
 ## dimension of @var{z}.  If @var{dim} is specified, then the complex
 ## pairs are sorted along this dimension.
 ##
 ## Signal an error if some complex numbers could not be paired.  Signal an
 ## error if all complex numbers are not exact conjugates (to within
 ## @var{tol}).  Note that there is no defined order for pairs with identical
 ## real parts but differing imaginary parts.
+## @c Set example in small font to prevent overfull line
 ##
-## @c Set example in small font to prevent overfull line
 ## @smallexample
 ## cplxpair (exp(2i*pi*[0:4]'/5)) == exp(2i*pi*[3; 2; 4; 1; 0]/5)
 ## @end smallexample
 ## @end deftypefn
 
 ## FIXME: subsort returned pairs by imaginary magnitude
 ## FIXME: Why doesn't exp(2i*pi*[0:4]'/5) produce exact conjugates. Does
 ## FIXME:    it in Matlab?  The reason is that complex pairs are supposed
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -13,39 +13,39 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{yi} =} interp1 (@var{x}, @var{y}, @var{xi})
+## @deftypefn  {Function File} {@var{yi} =} interp1 (@var{x}, @var{y}, @var{xi})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@var{y}, @var{xi})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@dots{}, @var{extrap})
 ## @deftypefnx {Function File} {@var{pp} =} interp1 (@dots{}, 'pp')
 ##
 ## One-dimensional interpolation.  Interpolate @var{y}, defined at the
 ## points @var{x}, at the points @var{xi}.  The sample points @var{x} 
-## must be monotonic. If not specified, @var{x} is taken to be the
-## indices of @var{y}. If @var{y} is an array, treat the columns
+## must be monotonic.  If not specified, @var{x} is taken to be the
+## indices of @var{y}.  If @var{y} is an array, treat the columns
 ## of @var{y} separately.
 ##
 ## Method is one of:
 ##
 ## @table @asis
 ## @item 'nearest'
 ## Return the nearest neighbor.
 ##
 ## @item 'linear'
 ## Linear interpolation from nearest neighbors
 ##
 ## @item 'pchip'
-## Piece-wise cubic hermite interpolating polynomial
+## Piece-wise cubic Hermite interpolating polynomial
 ##
 ## @item 'cubic'
 ## Cubic interpolation from four nearest neighbors
 ##
 ## @item 'spline'
 ## Cubic spline interpolation--smooth first and second derivatives
 ## throughout the curve
 ## @end table
diff --git a/scripts/general/interpn.m b/scripts/general/interpn.m
--- a/scripts/general/interpn.m
+++ b/scripts/general/interpn.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{vi} =} interpn (@var{x1}, @var{x2}, @dots{}, @var{v}, @var{y1}, @var{y2}, @dots{})
+## @deftypefn  {Function File} {@var{vi} =} interpn (@var{x1}, @var{x2}, @dots{}, @var{v}, @var{y1}, @var{y2}, @dots{})
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@var{v}, @var{y1}, @var{y2}, @dots{})
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@var{v}, @var{m})
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@var{v})
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@dots{}, @var{method}, @var{extrapval})
 ##
 ## Perform @var{n}-dimensional interpolation, where @var{n} is at least two. 
 ## Each element of the @var{n}-dimensional array @var{v} represents a value 
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -73,34 +73,34 @@
 ## number of sub-intervals that can exist before exiting.
 ##
 ## @item WayPoints
 ## If there exists discontinuities in the first derivative of the
 ## function to integrate, then these can be flagged with the
 ## @code{"WayPoints"} property.  This forces the ends of a sub-interval
 ## to fall on the breakpoints of the function and can result in
 ## significantly improved estimation of the error in the integral, faster
-## computation or both.  For example:
+## computation or both.  For example,
 ##
 ## @example
 ## quadgk (@@(x) abs (1 - x .^ 2), 0, 2, 'Waypoints', 1)
 ## @end example
 ##
 ## @noindent
 ## signals the breakpoint in the integrand at @code{@var{x} = 1}.
 ##
 ## @item Trace
 ## If logically true, then @code{quadgk} prints information on the
 ## convergence of the quadrature at each iteration.
 ##@end table
 ##
 ## If any of @var{a}, @var{b} or @var{waypoints} is complex, then the
 ## quadrature is treated as a contour integral along a piecewise
 ## continuous path defined by the above.  In this case the integral is
-## assumed to have no edge singularities.  For example
+## assumed to have no edge singularities.  For example,
 ##
 ## @example
 ## @group
 ## quadgk (@@(z) log (z), 1+1i, 1+1i, "WayPoints",
 ##         [1-1i, -1,-1i, -1+1i])
 ## @end group
 ## @end example
 ##
@@ -443,9 +443,9 @@ endfunction
 
 %!assert (quadgk(@sin,-pi,0), -2, 1e-6)
 %!assert (quadgk(@sin,0,pi), 2, 1e-6)
 %!assert (quadgk(@(x) 1./sqrt(x), 0, 1), 2, 1e-6)
 %!assert (quadgk (@(x) abs (1 - x.^2), 0, 2, 'Waypoints', 1), 2, 1e-6)
 %!assert (quadgk(@(x) 1./(sqrt(x).*(x+1)), 0, Inf), pi, 1e-6)
 %!assert (quadgk (@(z) log (z), 1+1i, 1+1i, 'WayPoints', [1-1i, -1,-1i, -1+1i]), -pi * 1i, 1e-6)
 
-%!assert (quadgk (@(x) exp(-x .^ 2), -Inf, Inf), sqrt(pi), 1e-6)
\ No newline at end of file
+%!assert (quadgk (@(x) exp(-x .^ 2), -Inf, Inf), sqrt(pi), 1e-6)
diff --git a/scripts/general/structfun.m b/scripts/general/structfun.m
--- a/scripts/general/structfun.m
+++ b/scripts/general/structfun.m
@@ -57,16 +57,17 @@
 ## 
 ## Given the parameter "ErrorHandler", @var{errfunc} defines a function to
 ## call in case @var{func} generates an error.  The form of the function is
 ## 
 ## @example
 ## function [@dots{}] = errfunc (@var{se}, @dots{})
 ## @end example
 ## 
+## @noindent
 ## where there is an additional input argument to @var{errfunc} relative to
 ## @var{func}, given by @var{se}.  This is a structure with the elements
 ## "identifier", "message" and "index", giving respectively the error
 ## identifier, the error message, and the index into the input arguments
 ## of the element that caused the error.  For an example on how to use
 ## an error handler, @pxref{doc-cellfun, @code{cellfun}}. 
 ##
 ## @seealso{cellfun, arrayfun, spfun}
diff --git a/scripts/image/image_viewer.m b/scripts/image/image_viewer.m
--- a/scripts/image/image_viewer.m
+++ b/scripts/image/image_viewer.m
@@ -35,32 +35,35 @@
 ## the filename of the image, and the @code{%f} will (if present) be
 ## replaced by the zoom factor given to the @code{image} function.
 ## For example,
 ##
 ## @example
 ## image_viewer ("eog %s");
 ## @end example
 ##
+## @noindent
 ## changes the image viewer to the @code{eog} program.
 ##
 ## With two input arguments, images will be displayed by calling
 ## the function @var{function_handle}.  For example,
 ##
 ## @example
 ## image_viewer (data, @@my_image_viewer);
 ## @end example
 ##
+## @noindent
 ## sets the image viewer function to @code{my_image_viewer}.  The image
 ## viewer function is called with
 ##
 ## @example
 ## my_image_viewer (@var{x}, @var{y}, @var{im}, @var{zoom}, @var{data})
 ## @end example
 ##
+## @noindent
 ## where @var{x} and @var{y} are the axis of the image, @var{im} is the image
 ## variable, and @var{data} is extra user-supplied data to be passed to
 ## the viewer function.
 ##
 ## With three input arguments it is possible to change the zooming.
 ## Some programs (like @code{xloadimage}) require the zoom factor to be
 ## between 0 and 100, and not 0 and 1 like Octave assumes.  This is
 ## solved by setting the third argument to 100.
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -55,16 +55,17 @@
 ## @group
 ## @var{str} = "\
 ## Bunny Bugs   5.5\n\
 ## Duck Daffy  -7.5e-5\n\
 ## Penguin Tux   6"
 ## @end group
 ## @end example
 ##
+## @noindent
 ## can be read using
 ##
 ## @example
 ## [@var{a}, @var{b}, @var{c}] = strread (@var{str}, "%s %s %f");
 ## @end example
 ##
 ## The behaviour of @code{strread} can be changed via properties @var{prop}
 ## @itemize @code
diff --git a/scripts/miscellaneous/warning_ids.m b/scripts/miscellaneous/warning_ids.m
--- a/scripts/miscellaneous/warning_ids.m
+++ b/scripts/miscellaneous/warning_ids.m
@@ -179,16 +179,17 @@
 ## 
 ## @example
 ## @group
 ## [ "f", 111, 111 ]
 ##      @result{} "foo"
 ## @end group
 ## @end example
 ##
+## @noindent
 ## elicits a warning if the @code{Octave:num-to-str} warning is
 ## enabled.  By default, the @code{Octave:num-to-str} warning is enabled.
 ## 
 ## @item Octave:precedence-change
 ## If the @code{Octave:precedence-change} warning is enabled, Octave
 ## will warn about possible changes in the meaning of some code due to
 ## changes in precedence for some operators.  Precedence changes have
 ## typically been made for @sc{matlab} compatibility.  By default, the
@@ -223,16 +224,17 @@
 ##
 ## @example
 ## @group
 ## "abc" + 0
 ##      @result{} 97 98 99
 ## @end group
 ## @end example
 ##
+## @noindent
 ## elicits a warning if the @code{Octave:str-to-num} warning is enabled.
 ## By default, the @code{Octave:str-to-num} warning is disabled.
 ## 
 ## @item Octave:string-concat
 ## If the @code{Octave:string-concat} warning is enabled, print a
 ## warning when concatenating a mixture of double and single quoted strings.
 ## By default, the @code{Octave:string-concat} warning is disabled.
 ## 
diff --git a/scripts/optimization/lsqnonneg.m b/scripts/optimization/lsqnonneg.m
--- a/scripts/optimization/lsqnonneg.m
+++ b/scripts/optimization/lsqnonneg.m
@@ -21,19 +21,19 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{x} =} lsqnonneg (@var{c}, @var{d})
 ## @deftypefnx {Function File} {@var{x} =} lsqnonneg (@var{c}, @var{d}, @var{x0})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}, @var{output}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}, @var{output}, @var{lambda}] =} lsqnonneg (@dots{})
-## Minimize @code{norm (@var{c}*@var{x}-d)} subject to @code{@var{x} >=
-## 0}.  @var{c} and @var{d} must be real.  @var{x0} is an optional
-## initial guess for @var{x}.
+## Minimize @code{norm (@var{c}*@var{x} - d)} subject to 
+## @code{@var{x} >= 0}.  @var{c} and @var{d} must be real.  @var{x0} is an
+## optional initial guess for @var{x}.
 ##
 ## Outputs:
 ## @itemize @bullet
 ## @item resnorm
 ##
 ## The squared 2-norm of the residual: norm(@var{c}*@var{x}-@var{d})^2
 ##
 ## @item residual
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -208,16 +208,17 @@
 ## be used in cases where for some reason the package database is corrupted.
 ## It can also take the @option{-auto} and @option{-noauto} options to allow the
 ## autoloading state of a package to be changed.  For example,
 ##
 ## @example
 ## pkg rebuild -noauto image
 ## @end example
 ##
+## @noindent
 ## will remove the autoloading status of the image package.
 ##
 ## @item build
 ## Builds a binary form of a package or packages.  The binary file produced
 ## will itself be an Octave package that can be installed normally with
 ## @code{pkg}.  The form of the command to build a binary package is
 ##
 ## @example
diff --git a/scripts/plot/__marching_cube__.m b/scripts/plot/__marching_cube__.m
--- a/scripts/plot/__marching_cube__.m
+++ b/scripts/plot/__marching_cube__.m
@@ -37,16 +37,17 @@
 ##
 ## The marching cube algorithm is well known and described, for example, at
 ## Wikipedia.  The triangulation lookup table and the edge table used
 ## here are based on Cory Gene Bloyd's implementation and can be found
 ## beyond other surface and geometry stuff at Paul Bourke's website
 ## @uref{http://local.wasp.uwa.edu.au/~pbourke/geometry/polygonise}.
 ##
 ## For example:
+##
 ## @example
 ## @group
 ## N = 20;
 ## lin = linspace(0, 2, N);
 ## [x, y, z] = meshgrid (lin, lin, lin);
 ##
 ## c = (x-.5).^2 + (y-.5).^2 + (z-.5).^2;
 ## [t, p] = __marching_cube__ (x, y, z, c, .5);
diff --git a/scripts/plot/bar.m b/scripts/plot/bar.m
--- a/scripts/plot/bar.m
+++ b/scripts/plot/bar.m
@@ -36,17 +36,17 @@
 ## are plotted side-by-side.  This behavior can be changed by the @var{style}
 ## argument, which can take the values @code{"grouped"} (the default),
 ## or @code{"stacked"}.
 ##
 ## The optional return value @var{h} provides a handle to the "bar series"
 ## object with one handle per column of the variable @var{y}.  This
 ## series allows common elements of the group of bar series objects to
 ## be changed in a single bar series and the same properties are changed
-## in the other "bar series".  For example
+## in the other "bar series".  For example,
 ##
 ## @example
 ## @group
 ## h = bar (rand (5, 10));
 ## set (h(1), "basevalue", 0.5);
 ## @end group
 ## @end example
 ##
@@ -61,16 +61,17 @@
 ##
 ## @example
 ## @group
 ## bar (rand(10,3))
 ## colormap (summer ())
 ## @end group
 ## @end example
 ##
+## @noindent
 ## will change the colors used for the bars.  If you wish to force the bars to
 ## particular colors, this can be achieved like
 ##
 ## @example
 ## @group
 ## h = bar (rand(10,3))
 ## set (h(1), "facecolor", "r")
 ## set (h(2), "facecolor", "g")
diff --git a/scripts/plot/contourc.m b/scripts/plot/contourc.m
--- a/scripts/plot/contourc.m
+++ b/scripts/plot/contourc.m
@@ -38,16 +38,17 @@
 ## 
 ## If @var{x} and @var{y} are omitted they are taken as the row/column 
 ## index of @var{z}.  @var{vn} is either a scalar denoting the number of lines 
 ## to compute or a vector containing the values of the lines.  If only one 
 ## value is wanted, set @code{@var{vn} = [val, val]};
 ## If @var{vn} is omitted it defaults to 10.
 ##
 ## For example:
+##
 ## @example
 ## @group
 ## x = 0:2;
 ## y = x;
 ## z = x' * y;
 ## contourc (x, y, z, 2:3)
 ##      @result{}   2.0000   2.0000   1.0000   3.0000   1.5000   2.0000
 ##      2.0000   1.0000   2.0000   2.0000   2.0000   1.5000
diff --git a/scripts/plot/errorbar.m b/scripts/plot/errorbar.m
--- a/scripts/plot/errorbar.m
+++ b/scripts/plot/errorbar.m
@@ -76,38 +76,41 @@
 ## @end table
 ##
 ## Examples:
 ##
 ## @example
 ## errorbar (@var{x}, @var{y}, @var{ex}, ">")
 ## @end example
 ##
+## @noindent
 ## produces an xerrorbar plot of @var{y} versus @var{x} with @var{x}
 ## errorbars drawn from @var{x}-@var{ex} to @var{x}+@var{ex}.
 ##
 ## @example
 ## @group
 ## errorbar (@var{x}, @var{y1}, @var{ey}, "~",
 ##           @var{x}, @var{y2}, @var{ly}, @var{uy})
 ## @end group
 ## @end example
 ##
+## @noindent
 ## produces yerrorbar plots with @var{y1} and @var{y2} versus @var{x}.
 ## Errorbars for @var{y1} are drawn from @var{y1}-@var{ey} to
 ## @var{y1}+@var{ey}, errorbars for @var{y2} from @var{y2}-@var{ly} to
 ## @var{y2}+@var{uy}.
 ##
 ## @example
 ## @group
 ## errorbar (@var{x}, @var{y}, @var{lx}, @var{ux},
 ##           @var{ly}, @var{uy}, "~>")
 ## @end group
 ## @end example
 ##
+## @noindent
 ## produces an xyerrorbar plot of @var{y} versus @var{x} in which
 ## @var{x} errorbars are drawn from @var{x}-@var{lx} to @var{x}+@var{ux}
 ## and @var{y} errorbars from @var{y}-@var{ly} to @var{y}+@var{uy}.
 ## @seealso{semilogxerr, semilogyerr, loglogerr}
 ## @end deftypefn
 
 ## Created: 18.7.2000
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
diff --git a/scripts/plot/ezplot.m b/scripts/plot/ezplot.m
--- a/scripts/plot/ezplot.m
+++ b/scripts/plot/ezplot.m
@@ -43,16 +43,17 @@
 ##
 ## @example
 ## @group
 ## @var{x} = @var{fx} (@var{t})
 ## @var{y} = @var{fy} (@var{t})
 ## @end group
 ## @end example
 ##
+## @noindent
 ## is plotted over the domain @code{-2*pi < @var{t} < 2*pi} with 500
 ## points. 
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of @var{x}, @var{y} and @var{t}.  If it is a four element
 ## vector, then the minimum and maximum values of @var{x} and @var{t}
 ## are determined by the first two elements and the minimum and maximum
 ## of @var{y} by the second pair of elements.
diff --git a/scripts/plot/isocolors.m b/scripts/plot/isocolors.m
--- a/scripts/plot/isocolors.m
+++ b/scripts/plot/isocolors.m
@@ -39,16 +39,17 @@
 ##
 ## Optionally, the patch handle @var{p} can be given as the last input
 ## argument to all variations of function calls instead of the vertices
 ## data @var{v}.  Finally, if no output argument is given then directly
 ## change the colors of a patch that is given by the patch handle
 ## @var{p}.
 ##
 ## For example:
+##
 ## @example
 ## function [] = isofinish (p)
 ##   set (gca, "PlotBoxAspectRatioMode", "manual", \
 ##        "PlotBoxAspectRatio", [1 1 1]);
 ##   set (p, "FaceColor", "interp");
 ##   ## set (p, "FaceLighting", "flat");
 ##   ## light ("Position", [1 1 5]); ## Available with JHandles
 ## endfunction
diff --git a/scripts/plot/isonormals.m b/scripts/plot/isonormals.m
--- a/scripts/plot/isonormals.m
+++ b/scripts/plot/isonormals.m
@@ -37,16 +37,17 @@
 ##
 ## If given the string input argument "negate" as last input argument
 ## then compute the reverse vector normals of an isosurface geometry.
 ##
 ## If no output argument is given then directly redraw the patch that is
 ## given by the patch handle @var{p}.
 ##
 ## For example:
+##
 ## @example
 ## function [] = isofinish (p)
 ##   set (gca, "PlotBoxAspectRatioMode","manual","PlotBoxAspectRatio",[1 1 1]);
 ##   set (p, "VertexNormals", -get(p,"VertexNormals")); ## Revert normals
 ##   set (p, "FaceColor", "interp");
 ##   ## set (p, "FaceLighting", "phong");
 ##   ## light ("Position", [1 1 5]); ## Available with JHandles
 ## endfunction
diff --git a/scripts/plot/isosurface.m b/scripts/plot/isosurface.m
--- a/scripts/plot/isosurface.m
+++ b/scripts/plot/isosurface.m
@@ -48,26 +48,27 @@
 ##
 ## If called with two or three output arguments then return the
 ## information about the faces @var{f}, vertices @var{v} and color data
 ## @var{c} as seperate arrays instead of a single structure array.
 ##
 ## If called with no output argument then directly process the
 ## isosurface geometry with the @command{patch} command.
 ##
-## For example
+## For example,
 ##
 ## @example
 ## @group
 ## [x, y, z] = meshgrid (1:5, 1:5, 1:5);
 ## val = rand (5, 5, 5);
 ## isosurface (x, y, z, val, .5);
 ## @end group
 ## @end example
 ##
+## @noindent
 ## will directly draw a random isosurface geometry in a graphics window.
 ## Another example for an isosurface geometry with different additional
 ## coloring
 ##
 ## @example
 ## N = 15;    ## Increase number of vertices in each direction
 ## iso = .4;  ## Change isovalue to .1 to display a sphere
 ## lin = linspace (0, 2, N);
diff --git a/scripts/plot/stem.m b/scripts/plot/stem.m
--- a/scripts/plot/stem.m
+++ b/scripts/plot/stem.m
@@ -29,34 +29,34 @@
 ## If @var{y} is a matrix, then each column of the matrix is plotted as
 ## a separate stem graph.  In this case @var{x} can either be a vector,
 ## the same length as the number of rows in @var{y}, or it can be a
 ## matrix of the same size as @var{y}.
 ##
 ## The default color is @code{"b"} (blue).  The default line style is
 ## @code{"-"} and the default marker is @code{"o"}.  The line style can
 ## be altered by the @code{linespec} argument in the same manner as the
-## @code{plot} command.  For example
+## @code{plot} command.  For example,
 ##
 ## @example
 ## @group
 ## x = 1:10;
 ## y = ones (1, length (x))*2.*x;
 ## stem (x, y, "r");
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## plots 10 stems with heights from 2 to 20 in red;
 ## 
 ## The return value of @code{stem} is a vector of "stem series" graphics
 ## handles, with one handle per column of the variable @var{y}.  This
 ## handle regroups the elements of the stem graph together as the
 ## children of the "stem series" handle, allowing them to be altered
-## together.  For example
+## together.  For example,
 ##
 ## @example
 ## @group
 ## x = [0 : 10]';
 ## y = [sin(x), cos(x)]
 ## h = stem (x, y);
 ## set (h(2), "color", "g");
 ## set (h(1), "basevalue", -1)
diff --git a/scripts/plot/stem3.m b/scripts/plot/stem3.m
--- a/scripts/plot/stem3.m
+++ b/scripts/plot/stem3.m
@@ -19,16 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{h} =} stem3 (@var{x}, @var{y}, @var{z}, @var{linespec})
 ## Plot a three-dimensional stem graph and return the handles of the line
 ## and marker objects used to draw the stems as "stem series" object.
 ## The default color is @code{"r"} (red).  The default line style is
 ## @code{"-"} and the default marker is @code{"o"}.
 ##
 ## For example,
+##
 ## @example
 ## @group
 ## theta = 0:0.2:6; 
 ## stem3 (cos (theta), sin (theta), theta) 
 ## @end group
 ## @end example
 ##
 ## @noindent
diff --git a/scripts/polynomial/compan.m b/scripts/polynomial/compan.m
--- a/scripts/polynomial/compan.m
+++ b/scripts/polynomial/compan.m
@@ -30,16 +30,17 @@
 ##      1    &     0    & \cdots &     0    &         0   \cr
 ##      0    &     1    & \cdots &     0    &         0   \cr
 ##   \vdots  &   \vdots & \ddots &  \vdots  &      \vdots \cr
 ##      0    &     0    & \cdots &     1    &         0}\right].
 ## $$
 ## @end tex
 ## @ifnottex
 ## @c Set example in small font to prevent overfull line
+##
 ## @smallexample
 ## @group
 ##      _                                                        _
 ##     |  -c(2)/c(1)   -c(3)/c(1)  @dots{}  -c(N)/c(1)  -c(N+1)/c(1)  |
 ##     |       1            0      @dots{}       0             0      |
 ##     |       0            1      @dots{}       0             0      |
 ## A = |       .            .      .         .             .      |
 ##     |       .            .       .        .             .      |
diff --git a/scripts/polynomial/ppval.m b/scripts/polynomial/ppval.m
--- a/scripts/polynomial/ppval.m
+++ b/scripts/polynomial/ppval.m
@@ -17,19 +17,21 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{yi} =} ppval (@var{pp}, @var{xi})
 ## Evaluate piece-wise polynomial @var{pp} at the points @var{xi}.  
 ## If @var{pp} is scalar-valued, the result is an array of the same shape as
 ## @var{xi}.
 ## Otherwise, the size of the result is @code{[pp.d, length(@var{xi})]} if
-## @var{xi} is a vector, or @code{[pp.d, size(@var{xi})]} if it is a multi-dimensional
-## array.  If pp.orient is 1, the dimensions are permuted as in interp1, to
-## @code{[pp.d, length(@var{xi})]} and @code{[pp.d, size(@var{xi})]} respectively.
+## @var{xi} is a vector, or @code{[pp.d, size(@var{xi})]} if it is a
+## multi-dimensional array.  If pp.orient is 1, the dimensions are permuted as
+## in interp1, to
+## @code{[pp.d, length(@var{xi})]} and @code{[pp.d, size(@var{xi})]}
+## respectively.
 ## @seealso{mkpp, unmkpp, spline}
 ## @end deftypefn 
 
 function yi = ppval (pp, xi)
 
   if (nargin != 2)
     print_usage ();
   endif
diff --git a/scripts/signal/arch_rnd.m b/scripts/signal/arch_rnd.m
--- a/scripts/signal/arch_rnd.m
+++ b/scripts/signal/arch_rnd.m
@@ -17,27 +17,27 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} arch_rnd (@var{a}, @var{b}, @var{t})
 ## Simulate an ARCH sequence of length @var{t} with AR
 ## coefficients @var{b} and CH coefficients @var{a}.  I.e., the result
 ## @math{y(t)} follows the model
+## @c Set example in small font to prevent overfull line
 ##
-## @c Set example in small font to prevent overfull line
 ## @smallexample
 ## y(t) = b(1) + b(2) * y(t-1) + @dots{} + b(lb) * y(t-lb+1) + e(t),
 ## @end smallexample
 ##
 ## @noindent
 ## where @math{e(t)}, given @var{y} up to time @math{t-1}, is
 ## @math{N(0, h(t))}, with
+## @c Set example in small font to prevent overfull line
 ##
-## @c Set example in small font to prevent overfull line
 ## @smallexample
 ## h(t) = a(1) + a(2) * e(t-1)^2 + @dots{} + a(la) * e(t-la+1)^2
 ## @end smallexample
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Simulate an ARCH process
 
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -44,18 +44,19 @@
 ## @code{@var{tol} = 1e-6} by default.
 ## 
 ## @item
 ## @var{maxit} is the maximum allowable number of iterations; if
 ## @code{[]} is supplied for @code{maxit}, or @code{pcg} has less
 ## arguments, a default value equal to 20 is used.
 ## 
 ## @item
-## @var{m} = @var{m1} * @var{m2} is the (left) preconditioning matrix, so that the iteration is
-## (theoretically) equivalent to solving by @code{pcg} @code{@var{P} *
+## @var{m} = @var{m1} * @var{m2} is the (left) preconditioning matrix, so that
+## the iteration is (theoretically) equivalent to solving by @code{pcg}
+## @code{@var{P} *
 ## @var{x} = @var{m} \ @var{b}}, with @code{@var{P} = @var{m} \ @var{a}}.
 ## Note that a proper choice of the preconditioner may dramatically
 ## improve the overall performance of the method.  Instead of matrices
 ## @var{m1} and @var{m2}, the user may pass two functions which return 
 ## the results of applying the inverse of @var{m1} and @var{m2} to 
 ## a vector (usually this is the preferred way of using the preconditioner). 
 ## If @code{[]} is supplied for @var{m1}, or @var{m1} is omitted, no 
 ## preconditioning is applied.  If @var{m2} is omitted, @var{m} = @var{m1}
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -64,29 +64,31 @@
 ##
 ## If more than one output is requested then @code{svds} will return an
 ## approximation of the singular value decomposition of @var{a}
 ##
 ## @example
 ## @var{a}_approx = @var{u}*@var{s}*@var{v}'
 ## @end example
 ##
+## @noindent
 ## where @var{a}_approx is a matrix of size @var{a} but only rank @var{k}.
 ## 
 ## @var{flag} returns 0 if the algorithm has succesfully converged, and 1 
 ## otherwise.  The test for convergence is
 ##
 ## @example
 ## @group
 ## norm (@var{a}*@var{v} - @var{u}*@var{s}, 1) <= @var{tol} * norm (@var{a}, 1)
 ## @end group
 ## @end example
 ##
-## @code{svds} is best for finding only a few singular values from a large sparse
-## matrix.  Otherwise, @code{svd (full(@var{a}))} will likely be more efficient.
+## @code{svds} is best for finding only a few singular values from a large
+## sparse matrix.  Otherwise, @code{svd (full(@var{a}))} will likely be more
+## efficient.
 ## @end deftypefn
 ## @seealso{svd, eigs}
 
 function [u, s, v, flag] = svds (a, k, sigma, opts)
 
   persistent root2 = sqrt (2);
 
   if (nargin < 1 || nargin > 4)
diff --git a/scripts/special-matrix/invhilb.m b/scripts/special-matrix/invhilb.m
--- a/scripts/special-matrix/invhilb.m
+++ b/scripts/special-matrix/invhilb.m
@@ -44,16 +44,17 @@
 ##  A(i,j) = -1      (i+j-1)(       )(       ) (       )
 ##                           \ n-j /  \ n-i /   \ i-2 /
 ##
 ##         = p(i) p(j) / (i+j-1)
 ##
 ## @end group
 ## @end example
 ##
+## @noindent
 ## where
 ##
 ## @example
 ## @group
 ##              k  /k+n-1\   /n\
 ##     p(k) = -1  (       ) (   )
 ##                 \ k-1 /   \k/
 ## @end group
diff --git a/scripts/statistics/distributions/wblcdf.m b/scripts/statistics/distributions/wblcdf.m
--- a/scripts/statistics/distributions/wblcdf.m
+++ b/scripts/statistics/distributions/wblcdf.m
@@ -26,16 +26,17 @@
 ## for $x\geq 0$.
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## 1 - exp(-(x/shape)^scale)
 ## @end example
 ##
+## @noindent
 ## for @var{x} @geq{} 0.
 ## @end ifnottex
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the Weibull distribution
 
 function cdf = wblcdf (x, scale, shape)
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -42,19 +42,19 @@
 ##
 ## @item assert(@var{observed}, @var{expected}, @var{tol})
 ## Accept a tolerance when comparing numbers. 
 ## If @var{tol} is positive use it as an absolute tolerance, will produce an
 ## error if
 ## @code{abs(@var{observed} - @var{expected}) > abs(@var{tol})}.
 ## If @var{tol} is negative use it as a relative tolerance, will produce an
 ## error if
-## @code{abs(@var{observed} - @var{expected}) > abs(@var{tol} * @var{expected})}.
-## If @var{expected} is zero @var{tol} will always be used as an absolute
-## tolerance.
+## @code{abs(@var{observed} - @var{expected}) > abs(@var{tol} *
+## @var{expected})}.  If @var{expected} is zero @var{tol} will always be used as
+## an absolute tolerance.
 ## @end table
 ## @seealso{test}
 ## @end deftypefn
 
 ## FIXME: Output throttling: don't print out the entire 100x100 matrix,
 ## but instead give a summary; don't print out the whole list, just
 ## say what the first different element is, etc.  To do this, make
 ## the message generation type specific.
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -45,16 +45,17 @@
 ## variables.  This means that all demos in your function must use
 ## separate initialization code.  Alternatively, you can combine your
 ## demos into one huge demo, with the code:
 ##
 ## @example
 ##    %! input("Press <enter> to continue: ","s");
 ## @end example
 ##
+## @noindent
 ## between the sections, but this is discouraged.  Other techniques
 ## include using multiple plots by saying figure between each, or
 ## using subplot to put multiple plots in the same window.
 ##
 ## Also, since demo evaluates inside a function context, you cannot
 ## define new functions inside a demo.  Instead you will have to
 ## use @code{eval(example('function',n))} to see them.  Because eval only
 ## evaluates one line, or one statement if the statement crosses
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -85,16 +85,17 @@
 ## time through the loop rather than pre-allocating one which is 
 ## big enough.  For example, in the current version of Octave,
 ## the following is not the expected @code{O(n)}:
 ##
 ## @example
 ## speed ("for i = 1:n, y@{i@} = x(i); end", "", [1000,10000])
 ## @end example
 ##
+## @noindent
 ## but it is if you preallocate the cell array @code{y}:
 ##
 ## @example
 ## @group
 ## speed ("for i = 1:n, y@{i@} = x(i); end", ...
 ##        "x = rand (n, 1); y = cell (size (x));", [1000, 10000])
 ## @end group
 ## @end example
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,25 @@
+2010-08-01  Rik <octave@nomad.inbox5.com>
+
+	* DLD-FUNCTIONS/amd.cc, DLD-FUNCTIONS/balance.cc, 
+	DLD-FUNCTIONS/besselj.cc, DLD-FUNCTIONS/betainc.cc,
+	DLD-FUNCTIONS/ccolamd.cc, DLD-FUNCTIONS/cellfun.cc,
+	DLD-FUNCTIONS/chol.cc, DLD-FUNCTIONS/colamd.cc, DLD-FUNCTIONS/daspk.cc,
+	DLD-FUNCTIONS/dasrt.cc, DLD-FUNCTIONS/dot.cc, DLD-FUNCTIONS/eigs.cc,
+	DLD-FUNCTIONS/fftw.cc, DLD-FUNCTIONS/filter.cc,
+	DLD-FUNCTIONS/lookup.cc, DLD-FUNCTIONS/lsode.cc, DLD-FUNCTIONS/lu.cc,
+	DLD-FUNCTIONS/matrix_type.cc, DLD-FUNCTIONS/onCleanup.cc,
+	DLD-FUNCTIONS/qr.cc, DLD-FUNCTIONS/rand.cc, DLD-FUNCTIONS/regexp.cc,
+	DLD-FUNCTIONS/sparse.cc, DLD-FUNCTIONS/str2double.cc,
+	DLD-FUNCTIONS/tril.cc, DLD-FUNCTIONS/typecast.cc, data.cc, graphics.cc,
+	load-save.cc, ov-null-mat.cc, ov-struct.cc, ov-usr-fcn.cc,
+	pr-output.cc, strfns.cc, variables.cc: Grammarcheck documentation.  
+	Add @noindent lines and ensure line length is less than 80.
+
 2010-07-31  Rik <octave@nomad.inbox5.com>
 
 	* DLD-FUNCTIONS/__magick_read__.cc, DLD-FUNCTIONS/__voronoi__.cc,
 	DLD-FUNCTIONS/amd.cc, DLD-FUNCTIONS/balance.cc,
 	DLD-FUNCTIONS/besselj.cc, DLD-FUNCTIONS/betainc.cc,
 	DLD-FUNCTIONS/ccolamd.cc, DLD-FUNCTIONS/cellfun.cc,
 	DLD-FUNCTIONS/chol.cc, DLD-FUNCTIONS/colamd.cc, DLD-FUNCTIONS/conv2.cc,
 	DLD-FUNCTIONS/convhulln.cc, DLD-FUNCTIONS/daspk.cc,
diff --git a/src/DLD-FUNCTIONS/amd.cc b/src/DLD-FUNCTIONS/amd.cc
--- a/src/DLD-FUNCTIONS/amd.cc
+++ b/src/DLD-FUNCTIONS/amd.cc
@@ -72,18 +72,19 @@ sqrt (@var{n})} entries, where @var{n} i
 are ignored by @code{amd} during the calculation of the permutation\n\
 The value of dense must be a positive scalar and its default value is 10.0\n\
 \n\
 @item opts.aggressive\n\
 If this value is a non zero scalar, then @code{amd} performs aggressive\n\
 absorption.  The default is not to perform aggressive absorption.\n\
 @end table\n\
 \n\
-The author of the code itself is Timothy A. Davis @email{davis@@cise.ufl.edu},\n\
-University of Florida (see @url{http://www.cise.ufl.edu/research/sparse/amd}).\n\
+The author of the code itself is Timothy A. Davis\n\
+@email{davis@@cise.ufl.edu}, University of Florida (see\n\
+@url{http://www.cise.ufl.edu/research/sparse/amd}).\n\
 @seealso{symamd, colamd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_AMD
   int nargin = args.length ();
 
diff --git a/src/DLD-FUNCTIONS/balance.cc b/src/DLD-FUNCTIONS/balance.cc
--- a/src/DLD-FUNCTIONS/balance.cc
+++ b/src/DLD-FUNCTIONS/balance.cc
@@ -58,18 +58,18 @@ Compute @code{aa = dd \\ a * dd} in whic
 row and column norms are roughly equal in magnitude, and\n\
 @code{dd} = @code{p * d}, in which @code{p} is a permutation\n\
 matrix and @code{d} is a diagonal matrix of powers of two.  This allows\n\
 the equilibration to be computed without round-off.  Results of\n\
 eigenvalue calculation are typically improved by balancing first.\n\
 \n\
 If two output values are requested, @code{balance} returns \n\
 the diagonal @code{d} and the permutation @code{p} separately as vectors.  \n\
-In this case, @code{dd = eye(n)(:,p) * diag (d)}, where @code{n} is the matrix\n\
-size.  \n\
+In this case, @code{dd = eye(n)(:,p) * diag (d)}, where @code{n} is the\n\
+matrix size.  \n\
 \n\
 If four output values are requested, compute @code{aa = cc*a*dd} and\n\
 @code{bb = cc*b*dd)}, in which @code{aa} and @code{bb} have non-zero\n\
 elements of approximately the same magnitude and @code{cc} and @code{dd}\n\
 are permuted diagonal matrices as in @code{dd} for the algebraic\n\
 eigenvalue problem.\n\
 \n\
 The eigenvalue balancing option @code{opt} may be one of:\n\
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -402,18 +402,18 @@ supplied, the result is multiplied by @c
 \n\
 @item besselk\n\
 \n\
 Modified Bessel functions of the second kind.  If the argument @var{opt} is\n\
 supplied, the result is multiplied by @code{exp(x)}.\n\
 \n\
 @item besselh\n\
 Compute Hankel functions of the first (@var{k} = 1) or second (@var{k}\n\
-= 2) kind.  If the argument @var{opt} is supplied, the result is multiplied by\n\
-@code{exp (-I*@var{x})} for @var{k} = 1 or @code{exp (I*@var{x})} for\n\
+= 2) kind.  If the argument @var{opt} is supplied, the result is multiplied\n\
+by @code{exp (-I*@var{x})} for @var{k} = 1 or @code{exp (I*@var{x})} for\n\
 @var{k} = 2.\n\
 @end table\n\
 \n\
 If @var{alpha} is a scalar, the result is the same size as @var{x}.\n\
 If @var{x} is a scalar, the result is the same size as @var{alpha}.\n\
 If @var{alpha} is a row vector and @var{x} is a column vector, the\n\
 result is a matrix with @code{length (@var{x})} rows and\n\
 @code{length (@var{alpha})} columns.  Otherwise, @var{alpha} and\n\
diff --git a/src/DLD-FUNCTIONS/betainc.cc b/src/DLD-FUNCTIONS/betainc.cc
--- a/src/DLD-FUNCTIONS/betainc.cc
+++ b/src/DLD-FUNCTIONS/betainc.cc
@@ -38,18 +38,18 @@ DEFUN_DLD (betainc, args, ,
 @deftypefn {Mapping Function} {} betainc (@var{x}, @var{a}, @var{b})\n\
 Return the incomplete Beta function,\n\
 @tex\n\
 $$\n\
  \\beta (x, a, b) = B (a, b)^{-1} \\int_0^x t^{(a-z)} (1-t)^{(b-1)} dt.\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
+@c Set example in small font to prevent overfull line\n\
 \n\
-@c Set example in small font to prevent overfull line\n\
 @smallexample\n\
 @group\n\
                                       x\n\
                                      /\n\
 betainc (x, a, b) = beta (a, b)^(-1) | t^(a-1) (1-t)^(b-1) dt.\n\
                                      /\n\
                                   t=0\n\
 @end group\n\
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -54,18 +54,19 @@ along with Octave; see the file COPYING.
 DEFUN_DLD (ccolamd, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} ccolamd (@var{s})\n\
 @deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{s}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{s}, @var{knobs}, @var{cmember})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} ccolamd (@dots{})\n\
 \n\
 Constrained column approximate minimum degree permutation.\n\
-@code{@var{p} = ccolamd (@var{s})} returns the column approximate minimum degree\n\
-permutation vector for the sparse matrix @var{s}.  For a non-symmetric matrix\n\
+@code{@var{p} = ccolamd (@var{s})} returns the column approximate minimum\n\
+degree permutation vector for the sparse matrix @var{s}.  For a non-symmetric\n\
+matrix\n\
 @var{s},\n\
 @code{@var{s} (:, @var{p})} tends to have sparser LU factors than @var{s}.\n\
 @code{chol (@var{s} (:, @var{p})' * @var{s} (:, @var{p}))} also tends to be\n\
 sparser than @code{chol (@var{s}' * @var{s})}.\n\
 @code{@var{p} = ccolamd\n\
 (@var{s}, 1)} optimizes the ordering for @code{lu (@var{s} (:, @var{p}))}.\n\
 The ordering is followed by a column elimination tree post-ordering.\n\
 \n\
@@ -100,21 +101,21 @@ if nonzero, statistics and knobs are pri
 on the column ordering.  If @code{@var{cmember} (j) = @var{c}}, then column\n\
 @var{j} is in constraint set @var{c} (@var{c} must be in the range 1 to\n\
 @var{n}).  In the output permutation @var{p}, all columns in set 1 appear\n\
 first, followed by all columns in set 2, and so on.  @code{@var{cmember} =\n\
 ones(1,n)} if not present or empty.\n\
 @code{ccolamd (@var{s}, [], 1 : @var{n})} returns @code{1 : @var{n}}\n\
 \n\
 @code{@var{p} = ccolamd (@var{s})} is about the same as\n\
-@code{@var{p} = colamd (@var{s})}.  @var{knobs} and its default values differ.  \n\
-@code{colamd} always does aggressive absorption, and it finds an ordering\n\
-suitable for both @code{lu (@var{s} (:, @var{p}))} and @code{chol (@var{S} (:,\n\
-@var{p})' * @var{s} (:, @var{p}))}; it cannot optimize its ordering for\n\
-@code{lu (@var{s} (:, @var{p}))} to the extent that\n\
+@code{@var{p} = colamd (@var{s})}.  @var{knobs} and its default values\n\
+differ.  @code{colamd} always does aggressive absorption, and it finds an\n\
+ordering suitable for both @code{lu (@var{s} (:, @var{p}))} and @code{chol\n\
+(@var{S} (:, @var{p})' * @var{s} (:, @var{p}))}; it cannot optimize its\n\
+ordering for @code{lu (@var{s} (:, @var{p}))} to the extent that\n\
 @code{ccolamd (@var{s}, 1)} can.\n\
 \n\
 @var{stats} is an optional 20-element output vector that provides data\n\
 about the ordering and the validity of the input matrix @var{s}.  Ordering\n\
 statistics are in @code{@var{stats} (1 : 3)}.  @code{@var{stats} (1)} and\n\
 @code{@var{stats} (2)} are the number of dense or empty rows and columns\n\
 ignored by @sc{ccolamd} and @code{@var{stats} (3)} is the number of garbage\n\
 collections performed on the internal data structure used by @sc{ccolamd}\n\
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -143,58 +143,59 @@ function can return one or more output a
 @example\n\
 @group\n\
 cellfun (@@atan2, @{1, 0@}, @{0, 1@})\n\
      @result{}ans = [1.57080   0.00000]\n\
 @end group\n\
 @end example\n\
 \n\
 The number of output arguments of @code{cellfun} matches the number of output\n\
-arguments of the function.  The outputs of the function will be collected into\n\
-the output arguments of @code{cellfun} like this:\n\
+arguments of the function.  The outputs of the function will be collected\n\
+into the output arguments of @code{cellfun} like this:\n\
 \n\
 @example\n\
 @group\n\
 function [a, b] = twoouts (x)\n\
   a = x;\n\
   b = x*x;\n\
 endfunction\n\
 [aa, bb] = cellfun(@@twoouts, @{1, 2, 3@})\n\
      @result{}\n\
         aa = \n\
            1 2 3\n\
         bb =\n\
            1 4 9\n\
 @end group\n\
 @end example\n\
 \n\
-Note that per default the output argument(s) are arrays of the same size as the\n\
-input arguments.  Input arguments that are singleton (1x1) cells will be\n\
+Note that per default the output argument(s) are arrays of the same size as\n\
+the input arguments.  Input arguments that are singleton (1x1) cells will be\n\
 automatically expanded to the size of the other arguments.\n\
 \n\
-If the parameter 'UniformOutput' is set to true (the default), then the function\n\
-must return scalars which will be concatenated into the return array(s).  If\n\
-'UniformOutput' is false, the outputs are concatenated into a cell array (or\n\
-cell arrays).  For example\n\
+If the parameter 'UniformOutput' is set to true (the default), then the\n\
+function must return scalars which will be concatenated into the return\n\
+array(s).  If 'UniformOutput' is false, the outputs are concatenated into a\n\
+cell array (or cell arrays).  For example:\n\
 \n\
 @example\n\
 @group\n\
 cellfun (\"tolower(x)\", @{\"Foo\", \"Bar\", \"FooBar\"@},\n\
          \"UniformOutput\",false)\n\
 @result{} ans = @{\"foo\", \"bar\", \"foobar\"@}\n\
 @end group\n\
 @end example\n\
 \n\
 Given the parameter 'ErrorHandler', then @var{errfunc} defines a function to\n\
 call in case @var{func} generates an error.  The form of the function is\n\
 \n\
 @example\n\
 function [@dots{}] = errfunc (@var{s}, @dots{})\n\
 @end example\n\
 \n\
+@noindent\n\
 where there is an additional input argument to @var{errfunc} relative to\n\
 @var{func}, given by @var{s}.  This is a structure with the elements\n\
 'identifier', 'message' and 'index', giving respectively the error\n\
 identifier, the error message, and the index into the input arguments\n\
 of the element that caused the error.  For example:\n\
 \n\
 @example\n\
 @group\n\
@@ -1455,32 +1456,33 @@ do_cellslices_nda (const NDA& array,
     }
 
   return retval;
 }
 
 DEFUN_DLD (cellslices, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{sl} =} cellslices (@var{x}, @var{lb}, @var{ub}, @var{dim})\n\
-Given an array @var{x}, this function produces a cell array of slices from the\n\
-array determined by the index vectors @var{lb}, @var{ub}, for lower and upper\n\
-bounds, respectively.  In other words, it is equivalent to the following code:\n\
+Given an array @var{x}, this function produces a cell array of slices from\n\
+the array determined by the index vectors @var{lb}, @var{ub}, for lower and\n\
+upper bounds, respectively.  In other words, it is equivalent to the\n\
+following code:\n\
 \n\
 @example\n\
 @group\n\
 n = length (lb);\n\
 sl = cell (1, n);\n\
 for i = 1:length (lb)\n\
   sl@{i@} = x(:,@dots{},lb(i):ub(i),@dots{},:);\n\
 endfor\n\
 @end group\n\
 @end example\n\
 \n\
-The position of the index is determined by @var{dim}.  If not specified, slicing\n\
-is done along the first non-singleton dimension.\n\
+The position of the index is determined by @var{dim}.  If not specified,\n\
+slicing is done along the first non-singleton dimension.\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
   if (nargin == 3 || nargin == 4)
     {
       octave_value x = args(0);
       Array<octave_idx_type> lb = args(1).octave_idx_type_vector_value ();
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -998,18 +998,18 @@ If @var{info} is not present, an error m
 %! 
 */
 
 DEFUN_DLD (choldelete, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{R1} =} choldelete (@var{R}, @var{j})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
-triangular, return the Cholesky@tie{}factorization of @w{A(p,p)}, where @w{p =\n\
-[1:j-1,j+1:n+1]}.\n\
+triangular, return the Cholesky@tie{}factorization of @w{A(p,p)}, where\n\
+@w{p = [1:j-1,j+1:n+1]}.\n\
 @seealso{chol, cholupdate, cholinsert}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
 
   octave_value_list retval;
 
   if (nargin != 2)
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -211,33 +211,33 @@ coletree (const octave_idx_type *ridx, c
 DEFUN_DLD (colamd, args, nargout,
     "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} colamd (@var{s})\n\
 @deftypefnx {Loadable Function} {@var{p} =} colamd (@var{s}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} colamd (@var{s})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} colamd (@var{s}, @var{knobs})\n\
 \n\
 Column approximate minimum degree permutation.\n\
-@code{@var{p} = colamd (@var{s})} returns the column approximate minimum degree\n\
-permutation vector for the sparse matrix @var{s}.  For a non-symmetric matrix\n\
-@var{s},\n\
-@code{@var{s} (:,@var{p})} tends to have sparser LU factors than @var{s}.\n\
-The Cholesky factorization of @code{@var{s} (:,@var{p})' * @var{s}\n\
-(:,@var{p})} also tends to be sparser than that of @code{@var{s}' *\n\
-@var{s}}.\n\
+@code{@var{p} = colamd (@var{s})} returns the column approximate minimum\n\
+degree permutation vector for the sparse matrix @var{s}.  For a\n\
+non-symmetric matrix @var{s}, @code{@var{s} (:,@var{p})} tends to have\n\
+sparser LU factors than @var{s}.  The Cholesky factorization of\n\
+@code{@var{s}(:,@var{p})' * @var{s} (:,@var{p})} also tends to be sparser\n\
+than that of @code{@var{s}' * @var{s}}.\n\
 \n\
 @var{knobs} is an optional one- to three-element input vector.  If @var{s} is\n\
-m-by-n, then rows with more than @code{max(16,@var{knobs}(1)*sqrt(n))} entries\n\
-are ignored.  Columns with more than @code{max(16,knobs(2)*sqrt(min(m,n)))}\n\
-entries are removed prior to ordering, and ordered last in the output\n\
-permutation @var{p}.  Only completely dense rows or columns are removed\n\
-if @code{@var{knobs} (1)} and @code{@var{knobs} (2)} are < 0, respectively.\n\
-If @code{@var{knobs} (3)} is nonzero, @var{stats} and @var{knobs} are\n\
-printed.  The default is @code{@var{knobs} = [10 10 0]}.  Note that\n\
-@var{knobs} differs from earlier versions of colamd\n\
+m-by-n, then rows with more than @code{max(16,@var{knobs}(1)*sqrt(n))}\n\
+entries are ignored.  Columns with more than\n\
+@code{max(16,knobs(2)*sqrt(min(m,n)))} entries are removed prior to\n\
+ordering, and ordered last in the output permutation @var{p}.  Only\n\
+completely dense rows or columns are removed if @code{@var{knobs} (1)} and\n\
+@code{@var{knobs} (2)} are < 0, respectively.  If @code{@var{knobs} (3)} is\n\
+nonzero, @var{stats} and @var{knobs} are printed.  The default is\n\
+@code{@var{knobs} = [10 10 0]}.  Note that @var{knobs} differs from earlier\n\
+versions of colamd\n\
 \n\
 @var{stats} is an optional 20-element output vector that provides data\n\
 about the ordering and the validity of the input matrix @var{s}.  Ordering\n\
 statistics are in @code{@var{stats} (1:3)}.  @code{@var{stats} (1)} and\n\
 @code{@var{stats} (2)} are the number of dense or empty rows and columns\n\
 ignored by @sc{colamd} and @code{@var{stats} (3)} is the number of garbage\n\
 collections performed on the internal data structure used by @sc{colamd}\n\
 (roughly of size @code{2.2 * nnz(@var{s}) + 4 * @var{m} + 7 * @var{n}}\n\
@@ -247,18 +247,18 @@ Octave built-in functions are intended t
 with no duplicate entries, with ascending row indices of the nonzeros\n\
 in each column, with a non-negative number of entries in each column (!)\n\
 and so on.  If a matrix is invalid, then @sc{colamd} may or may not be able\n\
 to continue.  If there are duplicate entries (a row index appears two or\n\
 more times in the same column) or if the row indices in a column are out\n\
 of order, then @sc{colamd} can correct these errors by ignoring the duplicate\n\
 entries and sorting each column of its internal copy of the matrix\n\
 @var{s} (the input matrix @var{s} is not repaired, however).  If a matrix\n\
-is invalid in other ways then @sc{colamd} cannot continue, an error message is\n\
-printed, and no output arguments (@var{p} or @var{stats}) are returned.\n\
+is invalid in other ways then @sc{colamd} cannot continue, an error message\n\
+is printed, and no output arguments (@var{p} or @var{stats}) are returned.\n\
 @sc{colamd} is thus a simple way to check a sparse matrix to see if it's\n\
 valid.\n\
 \n\
 @code{@var{stats} (4:7)} provide information if COLAMD was able to\n\
 continue.  The matrix is OK if @code{@var{stats} (4)} is zero, or 1 if\n\
 invalid.  @code{@var{stats} (5)} is the rightmost column index that is\n\
 unsorted or contains duplicate entries, or zero if no such column exists.\n\
 @code{@var{stats} (6)} is the last seen duplicate or out-of-order row\n\
diff --git a/src/DLD-FUNCTIONS/daspk.cc b/src/DLD-FUNCTIONS/daspk.cc
--- a/src/DLD-FUNCTIONS/daspk.cc
+++ b/src/DLD-FUNCTIONS/daspk.cc
@@ -181,16 +181,17 @@ with\n\
 $$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 0 = f (x, xdot, t)\n\
 @end example\n\
 \n\
+@noindent\n\
 with\n\
 \n\
 @example\n\
 x(t_0) = x_0, xdot(t_0) = xdot_0\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 The solution is returned in the matrices @var{x} and @var{xdot},\n\
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/DLD-FUNCTIONS/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/DLD-FUNCTIONS/dasrt.cc
@@ -216,16 +216,17 @@ with\n\
 $$ x(t_0) = x_0, \\dot{x}(t_0) = \\dot{x}_0 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 0 = f (x, xdot, t)\n\
 @end example\n\
 \n\
+@noindent\n\
 with\n\
 \n\
 @example\n\
 x(t_0) = x_0, xdot(t_0) = xdot_0\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 with functional stopping criteria (root solving).\n\
@@ -292,16 +293,17 @@ The modified Jacobian function must have
 The optional second argument names a function that defines the\n\
 constraint functions whose roots are desired during the integration.\n\
 This function must have the form\n\
 \n\
 @example\n\
 @var{g_out} = g (@var{x}, @var{t})\n\
 @end example\n\
 \n\
+@noindent\n\
 and return a vector of the constraint function values.\n\
 If the value of any of the constraint functions changes sign, @sc{dasrt}\n\
 will attempt to stop the integration at the point of the sign change.\n\
 \n\
 If the name of the constraint function is omitted, @code{dasrt} solves\n\
 the same problem as @code{daspk} or @code{dassl}.\n\
 \n\
 Note that because of numerical errors in the constraint functions\n\
diff --git a/src/DLD-FUNCTIONS/dot.cc b/src/DLD-FUNCTIONS/dot.cc
--- a/src/DLD-FUNCTIONS/dot.cc
+++ b/src/DLD-FUNCTIONS/dot.cc
@@ -105,19 +105,20 @@ get_red_dims (const dim_vector& x, const
 DEFUN_DLD (dot, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} dot (@var{x}, @var{y}, @var{dim})\n\
 Computes the dot product of two vectors.  If @var{x} and @var{y}\n\
 are matrices, calculate the dot products along the first \n\
 non-singleton dimension.  If the optional argument @var{dim} is\n\
 given, calculate the dot products along this dimension.\n\
 \n\
-This is equivalent to doing @code{sum (conj (@var{X}) .* @var{Y}, @var{dim})},\n\
-but avoids forming a temporary array and is faster.  When @var{X} and @var{Y}\n\
-are column vectors, the result is equivalent to\n\
+This is equivalent to doing\n\
+@code{sum (conj (@var{X}) .* @var{Y}, @var{dim})},\n\
+but avoids forming a temporary array and is faster.  When @var{X} and\n\
+@var{Y} are column vectors, the result is equivalent to\n\
 @code{ @var{X}'*@var{Y} }.\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     {
diff --git a/src/DLD-FUNCTIONS/eigs.cc b/src/DLD-FUNCTIONS/eigs.cc
--- a/src/DLD-FUNCTIONS/eigs.cc
+++ b/src/DLD-FUNCTIONS/eigs.cc
@@ -174,19 +174,19 @@ is the corresponding eigenvector.  If gi
 @tex\n\
 $A \\nu = \\lambda B \\nu$.\n\
 @end tex\n\
 @ifinfo\n\
 @code{A * v = lambda * B * v}.\n\
 @end ifinfo\n\
 \n\
 The argument @var{sigma} determines which eigenvalues are returned.\n\
-@var{sigma} can be either a scalar or a string.  When @var{sigma} is a scalar,\n\
-the @var{k} eigenvalues closest to @var{sigma} are returned.  If @var{sigma}\n\
-is a string, it must have one of the following values.\n\
+@var{sigma} can be either a scalar or a string.  When @var{sigma} is a\n\
+scalar, the @var{k} eigenvalues closest to @var{sigma} are returned.  If\n\
+@var{sigma} is a string, it must have one of the following values.\n\
 \n\
 @table @asis\n\
 @item 'lm'\n\
 Largest Magnitude (default).\n\
 \n\
 @item 'sm'\n\
 Smallest Magnitude.\n\
 \n\
@@ -280,20 +280,20 @@ for the standard eigenvalue problem, whe
 the same size as @var{A}.\n\
 \n\
 @item (A - sigma * B) \\ x\n\
 for the general eigenvalue problem.\n\
 @end table\n\
 \n\
 The return arguments of @code{eigs} depend on the number of return arguments\n\
 requested.  With a single return argument, a vector @var{d} of length @var{k}\n\
-is returned containing the @var{k} eigenvalues that have been found.  With two\n\
-return arguments, @var{v} is a @var{n}-by-@var{k} matrix whose columns are the\n\
-@var{k} eigenvectors corresponding to the returned eigenvalues.  The eigenvalues\n\
-themselves are returned in @var{d} in the form of a\n\
+is returned containing the @var{k} eigenvalues that have been found.  With\n\
+two return arguments, @var{v} is a @var{n}-by-@var{k} matrix whose columns\n\
+are the @var{k} eigenvectors corresponding to the returned eigenvalues.  The\n\
+eigenvalues themselves are returned in @var{d} in the form of a\n\
 @var{n}-by-@var{k} matrix, where the elements on the diagonal are the\n\
 eigenvalues.\n\
 \n\
 Given a third return argument @var{flag}, @code{eigs} returns the status\n\
 of the convergence.  If @var{flag} is 0 then all eigenvalues have converged.\n\
 Any other value indicates a failure to converge.\n\
 \n\
 This function is based on the @sc{arpack} package, written by R. Lehoucq,\n\
diff --git a/src/DLD-FUNCTIONS/fftw.cc b/src/DLD-FUNCTIONS/fftw.cc
--- a/src/DLD-FUNCTIONS/fftw.cc
+++ b/src/DLD-FUNCTIONS/fftw.cc
@@ -38,27 +38,28 @@ DEFUN_DLD (fftw, args, ,
 @deftypefnx {Loadable Function} {} fftw ('planner', @var{method})\n\
 @deftypefnx {Loadable Function} {@var{wisdom} =} fftw ('dwisdom')\n\
 @deftypefnx {Loadable Function} {@var{wisdom} =} fftw ('dwisdom', @var{wisdom})\n\
 \n\
 Manage @sc{fftw} wisdom data.  Wisdom data can be used to significantly\n\
 accelerate the calculation of the FFTs but implies an initial cost\n\
 in its calculation.  When the @sc{fftw} libraries are initialized, they read\n\
 a system wide wisdom file (typically in @file{/etc/fftw/wisdom}), allowing\n\
-wisdom to be shared between applications other than Octave.  Alternatively, the\n\
-@code{fftw} function can be used to import wisdom.  For example\n\
+wisdom to be shared between applications other than Octave.  Alternatively,\n\
+the @code{fftw} function can be used to import wisdom.  For example,\n\
 \n\
 @example\n\
 @var{wisdom} = fftw ('dwisdom')\n\
 @end example\n\
 \n\
+@noindent\n\
 will save the existing wisdom used by Octave to the string @var{wisdom}.\n\
 This string can then be saved to a file and restored using the @code{save}\n\
-and @code{load} commands respectively.  This existing wisdom can be reimported\n\
-as follows\n\
+and @code{load} commands respectively.  This existing wisdom can be\n\
+reimported as follows\n\
 \n\
 @example\n\
 fftw ('dwisdom', @var{wisdom})\n\
 @end example \n\
 \n\
 If @var{wisdom} is an empty matrix, then the wisdom used is cleared.\n\
 \n\
 During the calculation of Fourier transforms further wisdom is generated.\n\
@@ -93,16 +94,17 @@ and beyond that the 'estimate' method is
 \n\
 The default method is 'estimate', and the method currently being used can\n\
 be probed with\n\
 \n\
 @example\n\
 @var{method} = fftw ('planner')\n\
 @end example\n\
 \n\
+@noindent\n\
 and the method used can be set using\n\
 \n\
 @example\n\
 fftw ('planner', @var{method})\n\
 @end example\n\
 \n\
 Note that calculated wisdom will be lost when restarting Octave.  However,\n\
 the wisdom data can be reloaded if it is saved to a file as described\n\
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -291,18 +291,18 @@ Return the solution to the following lin
 equation:\n\
 @tex\n\
 $$\n\
 \\sum_{k=0}^N a_{k+1} y_{n-k} = \\sum_{k=0}^M b_{k+1} x_{n-k}, \\qquad\n\
  1 \\le n \\le P\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
+@c Set example in small font to prevent overfull line\n\
 \n\
-@c Set example in small font to prevent overfull line\n\
 @smallexample\n\
 @group\n\
    N                   M\n\
   SUM a(k+1) y(n-k) = SUM b(k+1) x(n-k)      for 1<=n<=length(x)\n\
   k=0                 k=0\n\
 @end group\n\
 @end smallexample\n\
 \n\
@@ -320,18 +320,18 @@ over the first non-singleton dimension o
 supplied.  An equivalent form of this equation is:\n\
 @tex\n\
 $$\n\
 y_n = -\\sum_{k=1}^N c_{k+1} y_{n-k} + \\sum_{k=0}^M d_{k+1} x_{n-k}, \\qquad\n\
  1 \\le n \\le P\n\
 $$\n\
 @end tex\n\
 @ifnottex\n\
+@c Set example in small font to prevent overfull line\n\
 \n\
-@c Set example in small font to prevent overfull line\n\
 @smallexample\n\
 @group\n\
             N                   M\n\
   y(n) = - SUM c(k+1) y(n-k) + SUM d(k+1) x(n-k)  for 1<=n<=length(x)\n\
            k=1                 k=0\n\
 @end group\n\
 @end smallexample\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/DLD-FUNCTIONS/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/DLD-FUNCTIONS/lookup.cc
@@ -198,19 +198,19 @@ within the table.  If @code{y(i) < table
 @code{idx(i)} is 0. If @code{y(i) >= table(end)} or @code{isnan (y(i))} then\n\
 @code{idx(i)} is @code{n}.\n\
 \n\
 If the table is decreasing, then the tests are reversed.\n\
 For non-strictly monotonic tables, empty intervals are always skipped.\n\
 The result is undefined if @var{table} is not monotonic, or if\n\
 @var{table} contains a NaN.\n\
 \n\
-The complexity of the lookup is O(M*log(N)) where N is the size of @var{table}\n\
-and M is the size of @var{y}.  In the special case when @var{y} is also sorted,\n\
-the complexity is O(min(M*log(N),M+N)).\n\
+The complexity of the lookup is O(M*log(N)) where N is the size of\n\
+@var{table} and M is the size of @var{y}.  In the special case when @var{y}\n\
+is also sorted, the complexity is O(min(M*log(N),M+N)).\n\
 \n\
 @var{table} and @var{y} can also be cell arrays of strings\n\
 (or @var{y} can be a single string).  In this case, string lookup\n\
 is performed using lexicographical comparison.\n\
 \n\
 If @var{opts} is specified, it shall be a string with letters indicating\n\
 additional options.\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -171,16 +171,17 @@ with\n\
 @example\n\
 @group\n\
 dx\n\
 -- = f(x, t)\n\
 dt\n\
 @end group\n\
 @end example\n\
 \n\
+@noindent\n\
 with\n\
 \n\
 @example\n\
 x(t_0) = x_0\n\
 @end example\n\
 \n\
 @end ifnottex\n\
 The solution is returned in the matrix @var{x}, with each row\n\
@@ -205,16 +206,17 @@ of strings, inline functions, or functio
 the function @math{f} described above, and the second element names a\n\
 function to compute the Jacobian of @math{f}.  The Jacobian function\n\
 must have the form\n\
 \n\
 @example\n\
 @var{jac} = j (@var{x}, @var{t})\n\
 @end example\n\
 \n\
+@noindent\n\
 in which @var{jac} is the matrix of partial derivatives\n\
 @tex\n\
 $$ J = {\\partial f_i \\over \\partial x_j} = \\left[\\matrix{\n\
 {\\partial f_1 \\over \\partial x_1}\n\
   & {\\partial f_1 \\over \\partial x_2}\n\
   & \\cdots\n\
   & {\\partial f_1 \\over \\partial x_N} \\cr\n\
 {\\partial f_2 \\over \\partial x_1}\n\
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -108,17 +108,18 @@ The matrix is not required to be square.
 Called with two or three output arguments and a spare input matrix,\n\
 then @dfn{lu} does not attempt to perform sparsity preserving column\n\
 permutations.  Called with a fourth output argument, the sparsity\n\
 preserving column transformation @var{Q} is returned, such that\n\
 @code{@var{p} * @var{a} * @var{q} = @var{l} * @var{u}}.\n\
 \n\
 Called with a fifth output argument and a sparse input matrix, then\n\
 @dfn{lu} attempts to use a scaling factor @var{r} on the input matrix\n\
-such that @code{@var{p} * (@var{r} \\ @var{a}) * @var{q} = @var{l} * @var{u}}.\n\
+such that\n\
+@code{@var{p} * (@var{r} \\ @var{a}) * @var{q} = @var{l} * @var{u}}.\n\
 This typically leads to a sparser and more stable factorization.\n\
 \n\
 An additional input argument @var{thres}, that defines the pivoting\n\
 threshold can be given.  @var{thres} can be a scalar, in which case\n\
 it defines @sc{umfpack} pivoting tolerance for both symmetric and unsymmetric\n\
 cases.  If @var{thres} is a two element vector, then the first element\n\
 defines the pivoting tolerance for the unsymmetric @sc{umfpack} pivoting\n\
 strategy and the second the symmetric strategy.  By default, the values\n\
@@ -609,23 +610,25 @@ a row permutation (pivoting) matrix @var
 in that case, an updated permutation matrix is returned.\n\
 Note that if @var{L}, @var{U}, @var{P} is a pivoted LU@tie{}factorization\n\
 as obtained by @code{lu}:\n\
 \n\
 @example\n\
   [@var{L}, @var{U}, @var{P}] = lu (@var{A});\n\
 @end example\n\
 \n\
+@noindent\n\
 then a factorization of @code{@var{a}+@var{x}*@var{y}.'} can be obtained either\n\
 as\n\
 \n\
 @example\n\
   [@var{L1}, @var{U1}] = lu (@var{L}, @var{U}, @var{P}*@var{x}, @var{y})\n\
 @end example\n\
 \n\
+@noindent\n\
 or\n\
 \n\
 @example\n\
   [@var{L1}, @var{U1}, @var{P1}] = lu (@var{L}, @var{U}, @var{P}, @var{x}, @var{y})\n\
 @end example\n\
 \n\
 The first form uses the unpivoted algorithm, which is faster, but less stable.\n\
 The second form uses a slower pivoted algorithm, which is more stable.\n\
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -41,22 +41,22 @@ DEFUN_DLD (matrix_type, args, ,
 @deftypefn  {Loadable Function} {@var{type} =} matrix_type (@var{a})\n\
 @deftypefnx {Loadable Function} {@var{type} =} matrix_type (@var{a}, 'nocompute')\n\
 @deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, @var{type})\n\
 @deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, 'upper', @var{perm})\n\
 @deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, 'lower', @var{perm})\n\
 @deftypefnx {Loadable Function} {@var{a} =} matrix_type (@var{a}, 'banded', @var{nl}, @var{nu})\n\
 Identify the matrix type or mark a matrix as a particular type.  This allows\n\
 rapid for solutions of linear equations involving @var{a} to be performed.  \n\
-Called with a single argument, @code{matrix_type} returns the type of the matrix\n\
-and caches it for future use.  Called with more than one argument,\n\
+Called with a single argument, @code{matrix_type} returns the type of the\n\
+matrix and caches it for future use.  Called with more than one argument,\n\
 @code{matrix_type} allows the type of the matrix to be defined.\n\
 \n\
-If the option 'nocompute' is given, the function will not attempt to guess the\n\
-type if it is still unknown.  This is useful for debugging purposes.\n\
+If the option 'nocompute' is given, the function will not attempt to guess\n\
+the type if it is still unknown.  This is useful for debugging purposes.\n\
 \n\
 The possible matrix types depend on whether the matrix is full or sparse, and\n\
 can be one of the following\n\
 \n\
 @table @asis\n\
 @item 'unknown'\n\
 Remove any previously cached matrix type, and mark type as unknown\n\
 \n\
@@ -83,39 +83,39 @@ defined by the vector @var{perm}.\n\
 Lower triangular.  If the optional third argument @var{perm} is given, the\n\
 matrix is assumed to be a permuted lower triangular with the permutations\n\
 defined by the vector @var{perm}.\n\
 \n\
 @item 'banded'\n\
 @itemx 'banded positive definite'\n\
 Banded matrix with the band size of @var{nl} below the diagonal and @var{nu}\n\
 above it.  If @var{nl} and @var{nu} are 1, then the matrix is tridiagonal and\n\
-treated with specialized code.  In addition the matrix can be marked as probably\n\
-a positive definite (Sparse matrices only)\n\
+treated with specialized code.  In addition the matrix can be marked as\n\
+probably a positive definite (Sparse matrices only)\n\
 \n\
 @item 'singular'\n\
 The matrix is assumed to be singular and will be treated with a minimum norm\n\
 solution\n\
 \n\
 @end table\n\
 \n\
-Note that the matrix type will be discovered automatically on the first attempt\n\
-to solve a linear equation involving @var{a}.  Therefore @code{matrix_type} is\n\
-only useful to give Octave hints of the matrix type.  Incorrectly defining the\n\
-matrix type will result in incorrect results from solutions of linear equations,\n\
-and so it is entirely the responsibility of the user to correctly identify the\n\
-matrix type.\n\
+Note that the matrix type will be discovered automatically on the first\n\
+attempt to solve a linear equation involving @var{a}.  Therefore\n\
+@code{matrix_type} is only useful to give Octave hints of the matrix type.  \n\
+Incorrectly defining the matrix type will result in incorrect results from\n\
+solutions of linear equations, and so it is entirely the responsibility of\n\
+the user to correctly identify the matrix type.\n\
 \n\
 Also the test for positive definiteness is a low-cost test for a Hermitian\n\
-matrix with a real positive diagonal.  This does not guarantee that the matrix\n\
-is positive definite, but only that it is a probable candidate.  When such a\n\
-matrix is factorized, a Cholesky factorization is first attempted, and if that\n\
-fails the matrix is then treated with an LU factorization.  Once the matrix has\n\
-been factorized, @code{matrix_type} will return the correct classification of\n\
-the matrix.\n\
+matrix with a real positive diagonal.  This does not guarantee that the\n\
+matrix is positive definite, but only that it is a probable candidate.  When\n\
+such a matrix is factorized, a Cholesky factorization is first attempted,\n\
+and if that fails the matrix is then treated with an LU factorization.  Once\n\
+the matrix has been factorized, @code{matrix_type} will return the correct\n\
+classification of the matrix.\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin == 0)
     print_usage ();
   else if (nargin > 4)
diff --git a/src/DLD-FUNCTIONS/onCleanup.cc b/src/DLD-FUNCTIONS/onCleanup.cc
--- a/src/DLD-FUNCTIONS/onCleanup.cc
+++ b/src/DLD-FUNCTIONS/onCleanup.cc
@@ -248,20 +248,20 @@ octave_oncleanup::print_raw (std::ostrea
     fcn.print_raw (os, pr_as_read_syntax);
   os << ")";
 }
 
 DEFUN_DLD (onCleanup, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{c} =} onCleanup (@var{action})\n\
 Creates a special object that executes a given function upon destruction.\n\
-If the object is copied to multiple variables (or cell or struct array elements)\n\
-or returned from a function, @var{action} will be executed after clearing the\n\
-last copy of the object.  Note that if multiple local onCleanup variables are\n\
-created, the order in which they are called is unspecified.\n\
+If the object is copied to multiple variables (or cell or struct array\n\
+elements) or returned from a function, @var{action} will be executed after\n\
+clearing the last copy of the object.  Note that if multiple local onCleanup\n\
+variables are created, the order in which they are called is unspecified.\n\
 @seealso{unwind_protect}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       if (octave_oncleanup::static_type_id () < 0)
diff --git a/src/DLD-FUNCTIONS/qr.cc b/src/DLD-FUNCTIONS/qr.cc
--- a/src/DLD-FUNCTIONS/qr.cc
+++ b/src/DLD-FUNCTIONS/qr.cc
@@ -768,18 +768,18 @@ DEFUN_DLD (qrupdate, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrupdate (@var{Q}, @var{R}, @var{u}, @var{v})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization\n\
 of @w{@var{A} + @var{u}*@var{v}'}, where @var{u} and @var{v} are\n\
 column vectors (rank-1 update) or matrices with equal number of columns\n\
 (rank-k update).  Notice that the latter case is done as a sequence of rank-1\n\
-updates; thus, for k large enough, it will be both faster and more accurate to\n\
-recompute the factorization from scratch.\n\
+updates; thus, for k large enough, it will be both faster and more accurate\n\
+to recompute the factorization from scratch.\n\
 \n\
 The QR factorization supplied may be either full\n\
 (Q is square) or economized (R is square).\n\
 \n\
 @seealso{qr, qrinsert, qrdelete}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
@@ -956,18 +956,18 @@ is a row vector to be inserted into @var
 @code{\"row\"}).\n\
 \n\
 The default value of @var{orient} is @code{\"col\"}.\n\
 If @var{orient} is @code{\"col\"},\n\
 @var{u} may be a matrix and @var{j} an index vector\n\
 resulting in the QR@tie{}factorization of a matrix @var{B} such that\n\
 @w{B(:,@var{j})} gives @var{u} and @w{B(:,@var{j}) = []} gives @var{A}.\n\
 Notice that the latter case is done as a sequence of k insertions;\n\
-thus, for k large enough, it will be both faster and more accurate to recompute\n\
-the factorization from scratch.\n\
+thus, for k large enough, it will be both faster and more accurate to\n\
+recompute the factorization from scratch.\n\
 \n\
 If @var{orient} is @code{\"col\"},\n\
 the QR factorization supplied may be either full\n\
 (Q is square) or economized (R is square).\n\
 \n\
 If @var{orient} is @code{\"row\"}, full factorization is needed.\n\
 @seealso{qr, qrupdate, qrdelete}\n\
 @end deftypefn")
@@ -1175,18 +1175,18 @@ Given a QR@tie{}factorization of a real 
 \n\
 The default value of @var{orient} is \"col\".\n\
 \n\
 If @var{orient} is @code{\"col\"},\n\
 @var{j} may be an index vector\n\
 resulting in the QR@tie{}factorization of a matrix @var{B} such that\n\
 @w{A(:,@var{j}) = []} gives @var{B}.\n\
 Notice that the latter case is done as a sequence of k deletions;\n\
-thus, for k large enough, it will be both faster and more accurate to recompute\n\
-the factorization from scratch.\n\
+thus, for k large enough, it will be both faster and more accurate to\n\
+recompute the factorization from scratch.\n\
 \n\
 If @var{orient} is @code{\"col\"},\n\
 the QR factorization supplied may be either full\n\
 (Q is square) or economized (R is square).\n\
 \n\
 If @var{orient} is @code{\"row\"}, full factorization is needed.\n\
 @seealso{qr, qrinsert, qrupdate}\n\
 @end deftypefn")
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -357,17 +357,18 @@ You may also initialize the state vector
 length @leq{} 625 for @var{v}.  This new state will be a hash based on the\n\
 value of @var{v}, not @var{v} itself.\n\
 \n\
 By default, the generator is initialized from @code{/dev/urandom} if it is\n\
 available, otherwise from CPU time, wall clock time and the current\n\
 fraction of a second.\n\
 \n\
 To compute the pseudo-random sequence, @code{rand} uses the Mersenne\n\
-Twister with a period of @math{2^{19937}-1} (See M. Matsumoto and T. Nishimura,\n\
+Twister with a period of @math{2^{19937}-1} (See M. Matsumoto and\n\
+T. Nishimura,\n\
 @cite{Mersenne Twister: A 623-dimensionally equidistributed uniform \n\
 pseudorandom number generator}, ACM Trans. on\n\
 Modeling and Computer Simulation Vol. 8, No. 1, pp. 3-30, January 1998,\n\
 @url{http://www.math.sci.hiroshima-u.ac.jp/~m-mat/MT/emt.html}).\n\
 Do @strong{not} use for cryptography without securely hashing\n\
 several returned values together, otherwise the generator state\n\
 can be learned after reading 624 consecutive values.\n\
 \n\
@@ -379,16 +380,17 @@ some circumstances it might be desirable
 sequences as used by the old generators.  To do this the keyword\n\
 \"seed\" is used to specify that the old generators should be use,\n\
 as in\n\
 \n\
 @example\n\
 rand (\"seed\", val)\n\
 @end example\n\
 \n\
+@noindent\n\
 which sets the seed of the generator to @var{val}.  The seed of the\n\
 generator can be queried with\n\
 \n\
 @example\n\
 s = rand (\"seed\")\n\
 @end example\n\
 \n\
 However, it should be noted that querying the seed will not cause\n\
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -902,24 +902,25 @@ Match zero or more times\n\
 \n\
 @item +\n\
 Match one or more times\n\
 \n\
 @item ?\n\
 Match zero or one times\n\
 \n\
 @item @{@}\n\
-Match range operator, which is of the form @code{@{@var{n}@}} to match exactly\n\
-@var{n} times, @code{@{@var{m},@}} to match @var{m} or more times,\n\
+Match range operator, which is of the form @code{@{@var{n}@}} to match\n\
+exactly @var{n} times, @code{@{@var{m},@}} to match @var{m} or more times,\n\
 @code{@{@var{m},@var{n}@}} to match between @var{m} and @var{n} times.\n\
 @end table\n\
 \n\
 @item [@dots{}] [^@dots{}]\n\
 \n\
-List operators, where for example @code{[ab]c} matches @code{ac} and @code{bc}\n\
+List operators, where for example @code{[ab]c} matches @code{ac} and\n\
+@code{bc}\n\
 \n\
 @item ()\n\
 Grouping operator\n\
 \n\
 @item |\n\
 Alternation operator.  Match one of a choice of regular expressions.  The\n\
 alternatives must be delimited by the grouping operator @code{()} above\n\
 \n\
@@ -1584,16 +1585,17 @@ for the ith set of parentheses in the ma
 @example\n\
 @group\n\
 \n\
    regexprep(\"Bill Dunn\",'(\\w+) (\\w+)','$2, $1')\n\
 \n\
 @end group\n\
 @end example\n\
 \n\
+@noindent\n\
 returns \"Dunn, Bill\"\n\
 \n\
 @var{options} may be zero or more of\n\
 @table @samp\n\
 \n\
 @item once\n\
 Replace only the first occurrence of @var{pat} in the result.\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/sparse.cc b/src/DLD-FUNCTIONS/sparse.cc
--- a/src/DLD-FUNCTIONS/sparse.cc
+++ b/src/DLD-FUNCTIONS/sparse.cc
@@ -65,19 +65,20 @@ DEFUN_DLD (sparse, args, ,
 @deftypefnx {Loadable Function} {@var{s} =} sparse (@var{m}, @var{n})\n\
 Create a sparse matrix from the full matrix or row, column, value triplets.\n\
 If @var{a} is a full matrix, convert it to a sparse matrix representation,\n\
 removing all zero values in the process.\n\
 \n\
 Given the integer index vectors @var{i} and @var{j}, a 1-by-@code{nnz} vector\n\
 of real of complex values @var{sv}, overall dimensions @var{m} and @var{n}\n\
 of the sparse matrix.  The argument @code{nzmax} is ignored but accepted for\n\
-compatibility with @sc{matlab}.  If @var{m} or @var{n} are not specified their\n\
-values are derived from the maximum index in the vectors @var{i} and @var{j} as\n\
-given by @code{@var{m} = max (@var{i})}, @code{@var{n} = max (@var{j})}.\n\
+compatibility with @sc{matlab}.  If @var{m} or @var{n} are not specified\n\
+their values are derived from the maximum index in the vectors @var{i} and\n\
+@var{j} as given by @code{@var{m} = max (@var{i})},\n\
+@code{@var{n} = max (@var{j})}.\n\
 \n\
 @strong{Note}: if multiple values are specified with the same\n\
 @var{i}, @var{j} indices, the corresponding values in @var{s} will\n\
 be added.\n\
 \n\
 The following are all equivalent:\n\
 \n\
 @example\n\
@@ -202,20 +203,21 @@ to have a common size.\n\
      }
 
    return retval;
 }
 
 DEFUN_DLD (spalloc, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{s} =} spalloc (@var{m}, @var{n}, @var{nz})\n\
-Creates a @var{m}-by-@var{n} sparse matrix with pre-allocated space for at most\n\
-@var{nz} nonzero elements.  This is useful for building the matrix incrementally\n\
-by a sequence of indexed assignments.  Subsequent indexed assignments will reuse\n\
-the pre-allocated memory, provided they are of one of the simple forms\n\
+Creates a @var{m}-by-@var{n} sparse matrix with pre-allocated space for at\n\
+most @var{nz} nonzero elements.  This is useful for building the matrix\n\
+incrementally by a sequence of indexed assignments.  Subsequent indexed\n\
+assignments will reuse the pre-allocated memory, provided they are of one of\n\
+the simple forms\n\
 \n\
 @itemize\n\
 @item @code{@var{s}(I:J) = @var{x}}\n\
 \n\
 @item @code{@var{s}(:,I:J) = @var{x}}\n\
 \n\
 @item @code{@var{s}(K:L,I:J) = @var{x}}\n\
 @end itemize\n\
@@ -225,24 +227,23 @@ the pre-allocated memory, provided they 
 @itemize\n\
 @item the assignment does not decrease nnz(@var{S}).\n\
 \n\
 @item after the assignment, nnz(@var{S}) does not exceed @var{nz}.\n\
 \n\
 @item no index is out of bounds.\n\
 @end itemize\n\
 \n\
-Partial movement of data may still occur, but in general the assignment will be\n\
-more memory and time-efficient under these circumstances.  In particular, it is\n\
-possible to efficiently build a pre-allocated sparse matrix from contiguous\n\
-block of columns.\n\
+Partial movement of data may still occur, but in general the assignment will\n\
+be more memory and time-efficient under these circumstances.  In particular,\n\
+it is possible to efficiently build a pre-allocated sparse matrix from\n\
+contiguous block of columns.\n\
 \n\
-The amount of pre-allocated memory for a given matrix may be queried using the\n\
-function\n\
-@code{nzmax}.\n\
+The amount of pre-allocated memory for a given matrix may be queried using\n\
+the function @code{nzmax}.\n\
 @seealso{nzmax, sparse}\n\
 @end deftypefn")
 {
    octave_value retval;
    int nargin = args.length ();
 
    if (nargin == 2 || nargin == 3)
      {
diff --git a/src/DLD-FUNCTIONS/str2double.cc b/src/DLD-FUNCTIONS/str2double.cc
--- a/src/DLD-FUNCTIONS/str2double.cc
+++ b/src/DLD-FUNCTIONS/str2double.cc
@@ -214,19 +214,19 @@ A complex number should be in one of the
 \n\
 @item i*b + a\n\
 @end itemize\n\
 \n\
 It is also possible to use @code{j} instead of @code{i}, or write just\n\
 @code{i} instead of @code{1*i}.\n\
 @code{a} and @code{b} should be real numbers\n\
 in a standard format.\n\
-@var{s} can also be a character matrix, in which case the conversion is repeated\n\
-for each row, or a cell array of strings, in which case each element is\n\
-converted and an array of the same dimensions is returned.\n\
+@var{s} can also be a character matrix, in which case the conversion is\n\
+repeated for each row, or a cell array of strings, in which case each element\n\
+is converted and an array of the same dimensions is returned.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       if (args(0).is_string ())
         {
diff --git a/src/DLD-FUNCTIONS/tril.cc b/src/DLD-FUNCTIONS/tril.cc
--- a/src/DLD-FUNCTIONS/tril.cc
+++ b/src/DLD-FUNCTIONS/tril.cc
@@ -381,17 +381,18 @@ and\n\
 tril (ones (3), 1)\n\
      @result{}  1  1  0\n\
          1  1  1\n\
          1  1  1\n\
 @end group\n\
 @end example\n\
 \n\
 If the option \"pack\" is given as third argument, the extracted elements\n\
-are not inserted into a matrix, but rather stacked column-wise one above other.\n\
+are not inserted into a matrix, but rather stacked column-wise one above\n\
+other.\n\
 @seealso{triu, diag}\n\
 @end deftypefn")
 {
   return do_trilu ("tril", args);
 }
 
 DEFUN_DLD (triu, args, ,
   "-*- texinfo -*-\n\
diff --git a/src/DLD-FUNCTIONS/typecast.cc b/src/DLD-FUNCTIONS/typecast.cc
--- a/src/DLD-FUNCTIONS/typecast.cc
+++ b/src/DLD-FUNCTIONS/typecast.cc
@@ -107,26 +107,27 @@ of @var{x} and @var{class} must be one o
   \"uint64\"\n\
   \"double\"\n\
   \"single\"\n\
   \"double complex\"\n\
   \"single complex\"\n\
 @end group\n\
 @end example\n\
 \n\
-the last two are reserved for @var{class}; they indicate that a complex-valued\n\
-result is requested.  Complex arrays are stored in memory as consecutive pairs\n\
-of real numbers.  The sizes of integer types are given by their bit counts.  \n\
-Both logical and char are typically one byte wide; however, this is not\n\
-guaranteed by C++.  If your system is IEEE conformant, single and double should\n\
-be 4 bytes and 8 bytes wide, respectively.  \"logical\" is not allowed for\n\
-@var{class}.  If the input is a row vector, the return value is a row vector,\n\
-otherwise it is a column vector.  If the bit length of @var{x} is not divisible\n\
-by that of\n\
-@var{class}, an error occurs.\n\
+@noindent\n\
+the last two are reserved for @var{class}; they indicate that a\n\
+complex-valued result is requested.  Complex arrays are stored in memory as\n\
+consecutive pairs of real numbers.  The sizes of integer types are given by\n\
+their bit counts.  Both logical and char are typically one byte wide;\n\
+however, this is not guaranteed by C++.  If your system is IEEE conformant,\n\
+single and double should be 4 bytes and 8 bytes wide, respectively.  \n\
+\"logical\" is not allowed for @var{class}.  If the input is a row vector,\n\
+the return value is a row vector, otherwise it is a column vector.  If the\n\
+bit length of @var{x} is not divisible by that of @var{class}, an error\n\
+occurs.\n\
 \n\
 An example of the use of typecast on a little-endian machine is\n\
 \n\
 @example\n\
 @group\n\
 @var{x} = uint16 ([1, 65535]);\n\
 typecast (@var{x}, 'uint8')\n\
 @result{} [   0,   1, 255, 255]\n\
@@ -268,19 +269,19 @@ do_bitpack (const boolNDArray& bitp)
       error ("bitpack: incorrect number of bits to make up output value");
       return ArrayType ();
     }
 }
 
 DEFUN_DLD (bitpack, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{y} =} bitpack (@var{x}, @var{class})\n\
-Returns a new array @var{y} resulting from interpreting a logical array @var{x}\n\
-as raw bit pattern for data of the numeric class @var{class}.  @var{class} must\n\
-be one of the built-in numeric classes:\n\
+Returns a new array @var{y} resulting from interpreting a logical array\n\
+@var{x} as raw bit pattern for data of the numeric class @var{class}.  \n\
+@var{class} must be one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
   \"char\"\n\
   \"int8\"\n\
   \"int16\"\n\
   \"int32\"\n\
   \"int64\"\n\
@@ -289,21 +290,20 @@ be one of the built-in numeric classes:\
   \"uint32\"\n\
   \"uint64\"\n\
   \"double\"\n\
   \"single\"\n\
 @end group\n\
 @end example\n\
 \n\
 The number of elements of @var{x} should be divisible by the bit length of\n\
-@var{class}.  If it is not, excess bits are discarded.  Bits come in increasing\n\
-order of significance, i.e.\n\
-@code{x(1)} is bit 0, @code{x(2)} is bit 1, etc.\n\
-The result is a row vector if @var{x} is a row vector, otherwise it is a column\n\
-vector.\n\
+@var{class}.  If it is not, excess bits are discarded.  Bits come in\n\
+increasing order of significance, i.e. @code{x(1)} is bit 0, @code{x(2)} is\n\
+bit 1, etc.  The result is a row vector if @var{x} is a row vector, otherwise\n\
+it is a column vector.\n\
 @seealso{bitunpack,typecast,bitget,bitset}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 2 && args(0).is_bool_type ())
     {
       boolNDArray bitp = args(0).bool_array_value ();
@@ -378,18 +378,18 @@ do_bitunpack (const ArrayType& array)
     }
 
   return retval;
 }
 
 DEFUN_DLD (bitunpack, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{y} =} bitpack (@var{x})\n\
-Returns a logical array @var{y} corresponding to the raw bit pattern of @var{x}.\n\
-@var{x} must belong to one of the built-in numeric classes:\n\
+Returns a logical array @var{y} corresponding to the raw bit pattern of\n\
+@var{x}.  @var{x} must belong to one of the built-in numeric classes:\n\
 \n\
 @example\n\
 @group\n\
   \"char\"\n\
   \"int8\"\n\
   \"int16\"\n\
   \"int32\"\n\
   \"int64\"\n\
@@ -397,18 +397,18 @@ Returns a logical array @var{y} correspo
   \"uint16\"\n\
   \"uint32\"\n\
   \"uint64\"\n\
   \"double\"\n\
   \"single\"\n\
 @end group\n\
 @end example\n\
 \n\
-The result is a row vector if @var{x} is a row vector, otherwise it is a column\n\
-vector.\n\
+The result is a row vector if @var{x} is a row vector, otherwise it is a\n\
+column vector.\n\
 @seealso{bitpack,typecast,bitget,bitset}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1 && (args(0).is_numeric_type () || args(0).is_string ()))
     {
       octave_value array = args(0);
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -631,16 +631,17 @@ DEFUN (mod, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} mod (@var{x}, @var{y})\n\
 Compute the modulo of @var{x} and @var{y}.  Conceptually this is given by\n\
 \n\
 @example\n\
 x - y .* floor (x ./ y)\n\
 @end example\n\
 \n\
+@noindent\n\
 and is written such that the correct modulus is returned for\n\
 integer types.  This function handles negative values correctly.  That\n\
 is, @code{mod (-1, 3)} is 2, not -1, as @code{rem (-1, 3)} returns.\n\
 @code{mod (@var{x}, 0)} returns @var{x}.\n\
 \n\
 An error results if the dimensions of the arguments do not agree, or if\n\
 either of the arguments is complex.\n\
 @seealso{rem}\n\
@@ -1935,16 +1936,17 @@ DEFUN (ipermute, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} ipermute (@var{a}, @var{iperm})\n\
 The inverse of the @code{permute} function.  The expression\n\
 \n\
 @example\n\
 ipermute (permute (a, perm), perm)\n\
 @end example\n\
 \n\
+@noindent\n\
 returns the original array @var{a}.\n\
 @seealso{permute}\n\
 @end deftypefn")
 {
   return do_permute (args, true);
 }
 
 DEFUN (length, args, ,
@@ -2240,18 +2242,18 @@ double type.  For example:\n\
 sum ([true, true])\n\
   @result{} 2\n\
 sum ([true, true], 'native')\n\
   @result{} true\n\
 @end group\n\
 @end example\n\
 \n\
   \n\
-On the contrary, if 'double' is given, the sum is performed in double precision\n\
-even for single precision inputs.\n\
+On the contrary, if 'double' is given, the sum is performed in double\n\
+precision even for single precision inputs.\n\
 \n\
 For double precision inputs, 'extra' indicates that a more accurate algorithm\n\
 than straightforward summation is to be used.  For single precision inputs,\n\
 'extra' is the same as 'double'.  Otherwise, 'extra' has no effect.\n\
 @seealso{cumsum, sumsq, prod}\n\
 @end deftypefn")
 {
   octave_value retval;
@@ -2447,16 +2449,17 @@ Sum of squares of elements along dimensi
 is omitted, it defaults to the first non-singleton dimension.\n\
 \n\
 This function is conceptually equivalent to computing\n\
 \n\
 @example\n\
 sum (x .* conj (x), dim)\n\
 @end example\n\
 \n\
+@noindent\n\
 but it uses less memory and avoids calling @code{conj} if @var{x} is real.\n\
 @seealso{sum}\n\
 @end deftypefn")
 {
   DATA_REDUCTION (sumsq);
 }
 
 /*
@@ -2888,18 +2891,19 @@ the number of columns, or both are zero)
     print_usage ();
 
   return retval;
 }
 
 DEFUN (isnumeric, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isnumeric (@var{x})\n\
-Return nonzero if @var{x} is a numeric object, i.e., an integer, real or complex\n\
-array.  Logical and character arrays are not considered to be numeric.\n\
+Return nonzero if @var{x} is a numeric object, i.e., an integer, real or\n\
+complex array.  Logical and character arrays are not considered to be\n\
+numeric.\n\
 @seealso{ischar, islogical, isinteger}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_numeric_type ();
   else
@@ -4567,18 +4571,18 @@ a minimum of two dimensions and row vect
     print_usage ();    
 
   return retval;
 }
 
 DEFUN (full, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{FM} =} full (@var{SM})\n\
- returns a full storage matrix from a sparse, diagonal, permutation matrix or a\n\
-range.\n\
+ returns a full storage matrix from a sparse, diagonal, permutation matrix\n\
+or a range.\n\
 @seealso{sparse}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).full_value ();
   else
@@ -5800,22 +5804,23 @@ DEFUN (nth_element, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} nth_element (@var{x}, @var{n})\n\
 @deftypefnx {Built-in Function} {} nth_element (@var{x}, @var{n}, @var{dim})\n\
 Select the n-th smallest element of a vector, using the ordering defined by\n\
 @code{sort}.  In other words, the result is equivalent to\n\
 @code{sort(@var{x})(@var{n})}.\n\
 @var{n} can also be a contiguous range, either ascending @code{l:u}\n\
 or descending @code{u:-1:l}, in which case a range of elements is returned.\n\
-If @var{x} is an array, @code{nth_element} operates along the dimension defined\n\
-by @var{dim}, or the first non-singleton dimension if @var{dim} is not given.\n\
+If @var{x} is an array, @code{nth_element} operates along the dimension\n\
+defined by @var{dim}, or the first non-singleton dimension if @var{dim} is\n\
+not given.\n\
 \n\
 nth_element encapsulates the C++ standard library algorithms nth_element and\n\
-partial_sort.  On average, the complexity of the operation is O(M*log(K)), where\n\
-@code{M = size(@var{x}, @var{dim})} and @code{K = length (@var{n})}.\n\
+partial_sort.  On average, the complexity of the operation is O(M*log(K)),\n\
+where @code{M = size(@var{x}, @var{dim})} and @code{K = length (@var{n})}.\n\
 This function is intended for cases where the ratio K/M is small; otherwise,\n\
 it may be better to use @code{sort}.\n\
 @seealso{sort, min, max}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
@@ -6198,27 +6203,26 @@ do_merge (const Array<bool>& mask,
                          tval.INTX ## _array_value (), \
                          fval.INTX ## _array_value ()); \
     }
 
 DEFUN (merge, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} merge (@var{mask}, @var{tval}, @var{fval})\n\
 @deftypefnx {Built-in Function} {} ifelse (@var{mask}, @var{tval}, @var{fval})\n\
-Merges elements of @var{true_val} and @var{false_val}, depending on the value of\n\
-@var{mask}.  If @var{mask} is a logical scalar, the other two arguments can be\n\
-arbitrary values.  Otherwise, @var{mask} must be a logical array, and\n\
-@var{tval},\n\
-@var{fval} should be arrays of matching class, or cell arrays.\n\
-In the scalar mask case, @var{tval} is returned if @var{mask} is true, otherwise\n\
-@var{fval} is returned.\n\
+Merges elements of @var{true_val} and @var{false_val}, depending on the\n\
+value of @var{mask}.  If @var{mask} is a logical scalar, the other two\n\
+arguments can be arbitrary values.  Otherwise, @var{mask} must be a logical\n\
+array, and @var{tval}, @var{fval} should be arrays of matching class, or\n\
+cell arrays.  In the scalar mask case, @var{tval} is returned if @var{mask}\n\
+is true, otherwise @var{fval} is returned.\n\
 \n\
-In the array mask case, both @var{tval} and @var{fval} must be either scalars or\n\
-arrays with dimensions equal to @var{mask}.  The result is constructed as\n\
-follows: \n\
+In the array mask case, both @var{tval} and @var{fval} must be either\n\
+scalars or arrays with dimensions equal to @var{mask}.  The result is\n\
+constructed as follows: \n\
 \n\
 @example\n\
 @group\n\
 result(mask) = tval(mask);\n\
 result(! mask) = fval(! mask);\n\
 @end group\n\
 @end example\n\
 \n\
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -5118,23 +5118,22 @@ There are three ways how to give the pro
 \n\
 Here, each @var{property} is a string containing the property name, each\n\
 @var{value} is a value of the appropriate type for the property.\n\
 \n\
 @item as a cell array of strings @var{properties} containing property names\n\
 and a cell array @var{values} containing property values.\n\
 \n\
 In this case, the number of columns of @var{values} must match the number of\n\
-elements in @var{properties}.  The first column of @var{values} contains values\n\
-for the first entry in @var{properties}, etc.  The number of rows of\n\
-@var{values} must be 1 or match the number of elements of @var{h}.  In the first\n\
-case, each handle in @var{h} will be assigned the same values.  In the latter\n\
-case, the first handle in @var{h} will be assigned the values from the first row\n\
-of\n\
-@var{values} and so on.\n\
+elements in @var{properties}.  The first column of @var{values} contains\n\
+values for the first entry in @var{properties}, etc.  The number of rows of\n\
+@var{values} must be 1 or match the number of elements of @var{h}.  In the\n\
+first case, each handle in @var{h} will be assigned the same values.  In the\n\
+latter case, the first handle in @var{h} will be assigned the values from\n\
+the first row of @var{values} and so on.\n\
 \n\
 @item as a structure array @var{pv}\n\
 \n\
 Here, the field names of @var{pv} represent the property names, and the field\n\
 values give the property values.  In contrast to the previous case, all\n\
 elements of @var{pv} will be set in all handles in @var{h} independent of\n\
 the dimensions of @var{pv}.\n\
 @end itemize\n\
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -1524,19 +1524,19 @@ Save the data in @sc{matlab}'s v6 binary
 @itemx -mat4-binary\n\
 Save the data in the binary format written by @sc{matlab} version 4.\n\
 \n\
 @item -text\n\
 Save the data in Octave's text data format.  (default).\n\
 \n\
 @item -zip\n\
 @itemx -z\n\
-Use the gzip algorithm to compress the file.  This works equally on files that\n\
-are compressed with gzip outside of octave, and gzip can equally be used to\n\
-convert the files for backward compatibility.\n"
+Use the gzip algorithm to compress the file.  This works equally on files\n\
+that are compressed with gzip outside of octave, and gzip can equally be\n\
+used to convert the files for backward compatibility.\n"
 
 HAVE_ZLIB_HELP_STRING
 
 "@end table\n\
 \n\
 The list of variables to save may use wildcard patterns containing\n\
 the following special characters:\n\
 @table @code\n\
@@ -1831,18 +1831,18 @@ DEFUN (save_header_format_string, args, 
 Query or set the internal variable that specifies the format\n\
 string used for the comment line written at the beginning of\n\
 text-format data files saved by Octave.  The format string is\n\
 passed to @code{strftime} and should begin with the character\n\
 @samp{#} and contain no newline characters.  If the value of\n\
 @code{save_header_format_string} is the empty string,\n\
 the header comment is omitted from text-format data files.  The\n\
 default value is\n\
+@c Set example in small font to prevent overfull line\n\
 \n\
-@c Set example in small font to prevent overfull line\n\
 @smallexample\n\
 \"# Created by Octave VERSION, %a %b %d %H:%M:%S %Y %Z <USER@@HOST>\"\n\
 @end smallexample\n\
 @seealso{strftime, save}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (save_header_format_string);
 }
diff --git a/src/ov-null-mat.cc b/src/ov-null-mat.cc
--- a/src/ov-null-mat.cc
+++ b/src/ov-null-mat.cc
@@ -88,18 +88,19 @@ octave_null_sq_str::numeric_conversion_f
                                             octave_char_matrix_sq_str::static_type_id ());
 }
 
 DEFUN (isnull, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isnull (@var{x})\n\
 Return 1 if @var{x} is a special null matrix, string or single quoted string.\n\
 Indexed assignment with such a value as right-hand side should delete array\n\
-elements.  This function should be used when overloading indexed assignment for\n\
-user-defined classes instead of @code{isempty}, to distinguish the cases:\n\
+elements.  This function should be used when overloading indexed assignment\n\
+for user-defined classes instead of @code{isempty}, to distinguish the\n\
+cases:\n\
 @table @asis\n\
 @item @code{A(I) = []}\n\
 This should delete elements if @code{I} is nonempty.\n\
 \n\
 @item @code{X = []; A(I) = X}\n\
 This should give an error if @code{I} is nonempty.\n\
 @end table\n\
 @end deftypefn")
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -2135,19 +2135,19 @@ A(1)\n\
 
 
 // So we can call Fcellstr directly.
 extern octave_value_list Fcellstr (const octave_value_list& args, int);
 
 DEFUN (rmfield, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} rmfield (@var{s}, @var{f})\n\
-Return a copy of the structure (array) @var{s} with the field @var{f} removed.\n\
-If @var{f} is a cell array of strings or a character array, remove the named\n\
-fields.\n\
+Return a copy of the structure (array) @var{s} with the field @var{f}\n\
+removed.  If @var{f} is a cell array of strings or a character array, remove\n\
+the named fields.\n\
 @seealso{cellstr, iscellstr, setfield}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 2)
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -736,20 +736,20 @@ static bool val_in_table (const Matrix& 
   octave_idx_type i = table.lookup (val, ASCENDING);
   return (i > 0 && table(i-1) == val);
 }
 
 DEFUN (is_ignored_output, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_ignored_output (@var{k})\n\
 Within a function, given an index @var{k} within the range @code{1:nargout},\n\
-return a logical value indicating whether the argument will be ignored on output\n\
-using the tilde (~) special output argument.  If @var{k} is outside the range,\n\
-the function yields false.  @var{k} can also be an array, in which case the\n\
-function works element-wise and a logical array is returned.\n\
+return a logical value indicating whether the argument will be ignored on\n\
+output using the tilde (~) special output argument.  If @var{k} is outside\n\
+the range, the function yields false.  @var{k} can also be an array, in\n\
+which case the function works element-wise and a logical array is returned.\n\
 \n\
 At the top level, @code{is_ignored_output} returns an error.\n\
 @seealso{nargout, nargin, varargin, varargout}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -3851,17 +3851,18 @@ ans =\n\
 @item bank\n\
 Print in a fixed format with two digits to the right of the decimal\n\
 point.\n\
 \n\
 @item native-hex\n\
 Print the hexadecimal representation of numbers as they are stored in\n\
 memory.  For example, on a workstation which stores 8 byte real values\n\
 in IEEE format with the least significant byte first, the value of\n\
-@code{pi} when printed in @code{native-hex} format is @code{400921fb54442d18}.\n\
+@code{pi} when printed in @code{native-hex} format is\n\
+@code{400921fb54442d18}.\n\
 \n\
 @item hex\n\
 The same as @code{native-hex}, but always print the most significant\n\
 byte first.\n\
 \n\
 @item native-bit\n\
 Print the bit representation of numbers as stored in memory.\n\
 For example, the value of @code{pi} is\n\
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -52,20 +52,20 @@ matrices, or cell arrays.  Arguments are
 The returned values are padded with blanks as needed to make each row\n\
 of the string array have the same length.  Empty input strings are\n\
 significant and will concatenated in the output.\n\
 \n\
 For numerical input, each element is converted\n\
 to the corresponding ASCII character.  A range error results if an input\n\
 is outside the ASCII range (0-255).\n\
 \n\
-For cell arrays, each element is concatenated separately.  Cell arrays converted\n\
-through\n\
+For cell arrays, each element is concatenated separately.  Cell arrays\n\
+converted through\n\
 @code{char} can mostly be converted back with @code{cellstr}.\n\
-For example,\n\
+For example:\n\
 \n\
 @example\n\
 @group\n\
 char ([97, 98, 99], \"\", @{\"98\", \"99\", 100@}, \"str1\", [\"ha\", \"lf\"])\n\
      @result{} [\"abc    \"\n\
          \"       \"\n\
          \"98     \"\n\
          \"99     \"\n\
@@ -176,20 +176,20 @@ matrices, or cell arrays.  Arguments are
 The returned values are padded with blanks as needed to make each row\n\
 of the string array have the same length.  Unlike @code{char}, empty\n\
 strings are removed and will not appear in the output.\n\
 \n\
 For numerical input, each element is converted\n\
 to the corresponding ASCII character.  A range error results if an input\n\
 is outside the ASCII range (0-255).\n\
 \n\
-For cell arrays, each element is concatenated separately.  Cell arrays converted\n\
-through\n\
+For cell arrays, each element is concatenated separately.  Cell arrays\n\
+converted through\n\
 @code{strvcat} can mostly be converted back with @code{cellstr}.\n\
-For example,\n\
+For example:\n\
 \n\
 @example\n\
 @group\n\
 strvcat ([97, 98, 99], \"\", @{\"98\", \"99\", 100@}, \"str1\", [\"ha\", \"lf\"])\n\
      @result{} [\"abc    \"\n\
          \"98     \"\n\
          \"99     \"\n\
          \"d      \"\n\
@@ -786,18 +786,18 @@ strncmpi_str_op (const std::string& s1, 
   return (n > 0 && n <= l1 && n <= l2 
           && std::equal (s1.data (), s1.data () + n, s2.data (),
                          icmp_char_eq ()));
 }
 
 DEFUNX ("strncmpi", Fstrncmpi, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} strncmpi (@var{s1}, @var{s2}, @var{n})\n\
-Returns 1 if the first @var{n} character of @var{s1} and @var{s2} are the same,\n\
-disregarding case of alphabetic characters, and 0 otherwise.\n\
+Returns 1 if the first @var{n} character of @var{s1} and @var{s2} are the\n\
+same, disregarding case of alphabetic characters, and 0 otherwise.\n\
 \n\
 If either @var{s1} or @var{s2} is a cell array of strings, then an array\n\
 of the same size is returned, containing the values described above for\n\
 every member of the cell array.  The other argument may also be a cell\n\
 array of strings (of the same size or with only one element), char matrix\n\
 or character string.\n\
 \n\
 @strong{Caution:} For compatibility with @sc{matlab}, Octave's strncmpi\n\
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -2446,18 +2446,18 @@ without the dash as well.\n\
 
 DEFUN (whos_line_format, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} whos_line_format ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} whos_line_format (@var{new_val})\n\
 Query or set the format string used by the command @code{whos}.\n\
 \n\
 A full format string is:\n\
+@c Set example in small font to prevent overfull line\n\
 \n\
-@c Set example in small font to prevent overfull line\n\
 @smallexample\n\
 %[modifier]<command>[:width[:left-min[:balance]]];\n\
 @end smallexample\n\
 \n\
 The following command sequences are available:\n\
 \n\
 @table @code\n\
 @item %a\n\
