# HG changeset patch
# User Rik <rik@octave.org>
# Date 1453398470 28800
#      Thu Jan 21 09:47:50 2016 -0800
# Node ID df789122470905908f1f549fda31dff450755146
# Parent  ba0a4b4f021da2e85c1da6049ddabc819c340383
maint: Use "return ovl (...)" in DEFUN macros.
* cellfun.cc, data.cc, debug.cc, defaults.cc, det.cc, dirfns.cc, dlmread.cc,
error.cc, file-io.cc, getrusage.cc, graphics.cc, help.cc, input.cc, inv.cc,
kron.cc, load-path.cc, pager.cc, pinv.cc, rand.cc, strfns.cc, urlwrite.cc,
chol.cc, ov-classdef.cc, ov-struct.cc: Use "return ovl (...)" in DEFUN macros,
rather than "return octave_value (...)".

diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -2338,17 +2338,17 @@ slicing is done along the first non-sing
       octave_value_list idx (ndims, octave_value::magic_colon_t);
       for (octave_idx_type i = 0; i < n; i++)
         {
           idx(dim) = Range (lb(i), ub(i));
           retcell(i) = x.do_index_op (idx);
         }
     }
 
-  return octave_value (retcell);
+  return ovl (retcell);
 }
 
 /*
 %!test
 %! m = [1, 2, 3, 4; 5, 6, 7, 8; 9, 10, 11, 12];
 %! c = cellslices (m, [1, 2], [2, 3], 2);
 %! assert (c, {[1, 2; 5, 6; 9, 10], [2, 3; 6, 7; 10, 11]});
 */
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -2418,17 +2418,17 @@ cat (4, ones (2, 2), zeros (2, 2))\n\
   if (args.length () == 0)
     print_usage ();
 
   int dim = args(0).xint_value ("cat: DIM must be an integer") - 1;
 
   if (dim < 0)
     error ("cat: DIM must be a valid dimension");
 
-  return octave_value (do_cat (args.slice (1, args.length () - 1), dim, "cat"));
+  return ovl (do_cat (args.slice (1, args.length () - 1), dim, "cat"));
 }
 
 /*
 %!function ret = __testcat (t1, t2, tr, cmplx)
 %!  assert (cat (1, cast ([], t1), cast ([], t2)), cast ([], tr));
 %!
 %!  assert (cat (1, cast (1, t1), cast (2, t2)), cast ([1; 2], tr));
 %!  assert (cat (1, cast (1, t1), cast ([2; 3], t2)), cast ([1; 2; 3], tr));
@@ -2648,17 +2648,17 @@ for vectors.  For matrix or N-dimensiona
 of elements along the largest dimension\n\
 (equivalent to @w{@code{max (size (@var{a}))}}).\n\
 @seealso{numel, size}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).length ());
+  return ovl (args(0).length ());
 }
 
 DEFUN (ndims, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} ndims (@var{a})\n\
 Return the number of dimensions of @var{a}.\n\
 \n\
 For any array, the result will always be greater than or equal to 2.\n\
@@ -2671,17 +2671,17 @@ ndims (ones (4, 1, 2, 1))\n\
 @end group\n\
 @end example\n\
 @seealso{size}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).ndims ());
+  return ovl (args(0).ndims ());
 }
 
 DEFUN (numel, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} numel (@var{a})\n\
 @deftypefnx {} {} numel (@var{a}, @var{idx1}, @var{idx2}, @dots{})\n\
 Return the number of elements in the object @var{a}.\n\
 \n\
@@ -2858,47 +2858,47 @@ DEFUN (nnz, args, ,
 @deftypefn {} {@var{n} =} nnz (@var{a})\n\
 Return the number of nonzero elements in @var{a}.\n\
 @seealso{nzmax, nonzeros, find}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).nnz ());
+  return ovl (args(0).nnz ());
 }
 
 DEFUN (nzmax, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{n} =} nzmax (@var{SM})\n\
 Return the amount of storage allocated to the sparse matrix @var{SM}.\n\
 \n\
 Note that Octave tends to crop unused memory at the first opportunity\n\
 for sparse objects.  Thus, in general the value of @code{nzmax} will be the\n\
 same as @code{nnz} except for some cases of user-created sparse objects.\n\
 @seealso{nnz, spalloc, sparse}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).nzmax ());
+  return ovl (args(0).nzmax ());
 }
 
 DEFUN (rows, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} rows (@var{a})\n\
 Return the number of rows of @var{a}.\n\
 @seealso{columns, size, length, numel, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).rows ());
+  return ovl (args(0).rows ());
 }
 
 /*
 %!assert (rows (ones (2,5)), 2)
 %!assert (rows (ones (5,2)), 5)
 %!assert (rows (ones (5,4,3,2)), 5)
 %!assert (rows (ones (3,4,5,2)), 3)
 
@@ -2928,17 +2928,17 @@ DEFUN (columns, args, ,
 @deftypefn {} {} columns (@var{a})\n\
 Return the number of columns of @var{a}.\n\
 @seealso{rows, size, length, numel, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).columns ());
+  return ovl (args(0).columns ());
 }
 
 DEFUN (sum, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} sum (@var{x})\n\
 @deftypefnx {} {} sum (@var{x}, @var{dim})\n\
 @deftypefnx {} {} sum (@dots{}, \"native\")\n\
 @deftypefnx {} {} sum (@dots{}, \"double\")\n\
@@ -3210,17 +3210,17 @@ DEFUN (islogical, args, ,
 @deftypefnx {} {} isbool (@var{x})\n\
 Return true if @var{x} is a logical object.\n\
 @seealso{isfloat, isinteger, ischar, isnumeric, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).is_bool_type ());
+  return ovl (args(0).is_bool_type ());
 }
 
 DEFALIAS (isbool, islogical);
 
 /*
 %!assert (islogical (true), true)
 %!assert (islogical (false), true)
 %!assert (islogical ([true, false]), true)
@@ -3242,45 +3242,45 @@ Return true if @var{x} is an integer obj
 Note that @w{@code{isinteger (14)}} is false because numeric constants in\n\
 Octave are double precision floating point values.\n\
 @seealso{isfloat, ischar, islogical, isnumeric, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).is_integer_type ());
+  return ovl (args(0).is_integer_type ());
 }
 
 DEFUN (iscomplex, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} iscomplex (@var{x})\n\
 Return true if @var{x} is a complex-valued numeric object.\n\
 @seealso{isreal, isnumeric, islogical, ischar, isfloat, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).is_complex_type ());
+  return ovl (args(0).is_complex_type ());
 }
 
 DEFUN (isfloat, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} isfloat (@var{x})\n\
 Return true if @var{x} is a floating-point numeric object.\n\
 \n\
 Objects of class double or single are floating-point objects.\n\
 @seealso{isinteger, ischar, islogical, isnumeric, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).is_float_type ());
+  return ovl (args(0).is_float_type ());
 }
 
 // FIXME: perhaps this should be implemented with an
 // octave_value member function?
 
 DEFUN (complex, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} complex (@var{x})\n\
@@ -3553,31 +3553,31 @@ Return true if @var{x} is a non-complex 
 For compatibility with @sc{matlab}, this includes logical and character\n\
 matrices.\n\
 @seealso{iscomplex, isnumeric, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).is_real_type ());
+  return ovl (args(0).is_real_type ());
 }
 
 DEFUN (isempty, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} isempty (@var{a})\n\
 Return true if @var{a} is an empty matrix (any one of its dimensions is\n\
 zero).\n\
 @seealso{isnull, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).is_empty ());
+  return ovl (args(0).is_empty ());
 }
 
 /*
 %% Debian bug #706376
 %!assert (isempty (speye(2^16)), false)
 */
 
 DEFUN (isnumeric, args, ,
@@ -3588,17 +3588,17 @@ complex array.\n\
 \n\
 Logical and character arrays are not considered to be numeric.\n\
 @seealso{isinteger, isfloat, isreal, iscomplex, islogical, ischar, iscell, isstruct, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).is_numeric_type ());
+  return ovl (args(0).is_numeric_type ());
 }
 
 /*
 %!assert (isnumeric (1), true)
 %!assert (isnumeric (1i), true)
 %!assert (isnumeric ([1,1]), true)
 %!assert (isnumeric (single (1)), true)
 %!assert (isnumeric (single (1i)), true)
@@ -3617,17 +3617,17 @@ DEFUN (isscalar, args, ,
 @deftypefn {} {} isscalar (@var{x})\n\
 Return true if @var{x} is a scalar.\n\
 @seealso{isvector, ismatrix}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).numel () == 1);
+  return ovl (args(0).numel () == 1);
 }
 
 /*
 %!assert (isscalar (1))
 %!assert (isscalar ([1, 2]), false)
 %!assert (isscalar ([]), false)
 %!assert (isscalar ([1, 2; 3, 4]), false)
 
@@ -3654,17 +3654,17 @@ consequence a 1x1 array, or scalar, is a
 @seealso{isscalar, ismatrix, size, rows, columns, length}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   dim_vector sz = args(0).dims ();
 
-  return octave_value (sz.length () == 2 && (sz(0) == 1 || sz(1) == 1));
+  return ovl (sz.length () == 2 && (sz(0) == 1 || sz(1) == 1));
 }
 
 /*
 %!assert (isvector (1), true)
 %!assert (isvector ([1; 2; 3]), true)
 %!assert (isvector ([1, 2, 3]), true)
 %!assert (isvector ([]), false)
 %!assert (isvector ([1, 2; 3, 4]), false)
@@ -3689,17 +3689,17 @@ Return true if @var{x} is a row vector 1
 @seealso{iscolumn, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   dim_vector sz = args(0).dims ();
 
-  return octave_value (sz.length () == 2 && sz(0) == 1);
+  return ovl (sz.length () == 2 && sz(0) == 1);
 }
 
 /*
 %!assert (isrow ([1, 2, 3]))
 %!assert (isrow ([1; 2; 3]), false)
 %!assert (isrow (1))
 %!assert (isrow ([]), false)
 %!assert (isrow ([1, 2; 3, 4]), false)
@@ -3734,17 +3734,17 @@ Return true if @var{x} is a column vecto
 @seealso{isrow, isscalar, isvector, ismatrix}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   dim_vector sz = args(0).dims ();
 
-  return octave_value (sz.length () == 2 && sz(1) == 1);
+  return ovl (sz.length () == 2 && sz(1) == 1);
 }
 
 /*
 %!assert (iscolumn ([1, 2, 3]), false)
 %!assert (iscolumn ([1; 2; 3]), true)
 %!assert (iscolumn (1), true)
 %!assert (iscolumn ([]), false)
 %!assert (iscolumn ([1, 2; 3, 4]), false)
@@ -3778,17 +3778,17 @@ Return true if @var{a} is a 2-D array.\n
 @seealso{isscalar, isvector, iscell, isstruct, issparse, isa}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   dim_vector sz = args(0).dims ();
 
-  return octave_value (sz.length () == 2 && sz(0) >= 0 && sz(1) >= 0);
+  return ovl (sz.length () == 2 && sz(0) >= 0 && sz(1) >= 0);
 }
 
 /*
 %!assert (ismatrix ([]), true)
 %!assert (ismatrix (1), true)
 %!assert (ismatrix ([1, 2, 3]), true)
 %!assert (ismatrix ([1, 2; 3, 4]), true)
 
@@ -3821,17 +3821,17 @@ Return true if @var{x} is a square matri
 @seealso{isscalar, isvector, ismatrix, size}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   dim_vector sz = args(0).dims ();
 
-  return octave_value (sz.length () == 2 && sz(0) == sz(1));
+  return ovl (sz.length () == 2 && sz(0) == sz(1));
 }
 
 /*
 %!assert (issquare ([]))
 %!assert (issquare (1))
 %!assert (! issquare ([1, 2]))
 %!assert (issquare ([1, 2; 3, 4]))
 %!assert (! issquare ([1, 2; 3, 4; 5, 6]))
@@ -5505,31 +5505,31 @@ Remove singleton dimensions from @var{x}
 Note that for compatibility with @sc{matlab}, all objects have\n\
 a minimum of two dimensions and row vectors are left unchanged.\n\
 @seealso{reshape}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).squeeze ());
+  return ovl (args(0).squeeze ());
 }
 
 DEFUN (full, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{FM} =} full (@var{SM})\n\
 Return a full storage matrix from a sparse, diagonal, or permutation matrix,\n\
 or a range.\n\
 @seealso{sparse, issparse}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (args(0).full_value ());
+  return ovl (args(0).full_value ());
 }
 
 // Compute various norms of the vector X.
 
 DEFUN (norm, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} norm (@var{A})\n\
 @deftypefnx {} {} norm (@var{A}, @var{p})\n\
@@ -6704,16 +6704,17 @@ Undocumented internal function.\n\
   if (arg.is_sparse_type ())
     error ("__sort_rows_idx__: sparse matrices not yet supported");
 
   if (arg.ndims () != 2)
     error ("__sort_rows_idx__: needs a 2-D object");
 
   Array<octave_idx_type> idx = arg.sort_rows_idx (smode);
 
+  // This cannot be ovl(), relies on special overloaded octave_value call.
   return octave_value (idx, true, true);
 }
 
 static sortmode
 get_sort_mode_option (const octave_value& arg)
 {
   // FIXME: we initialize to UNSORTED here to avoid a GCC warning
   //        about possibly using sortmode uninitialized.
@@ -7854,17 +7855,17 @@ dimensions of the decoded array.\n\
 
       dims = dim_vector::alloc (size.numel ());
       for (octave_idx_type i = 0; i < size.numel (); i++)
         dims(i) = size(i);
 
       retval = retval.reshape (dims);
     }
 
-  return octave_value (retval);
+  return ovl (retval);
 }
 
 /*
 %!assert (base64_decode (base64_encode (pi)), pi)
 %!
 %!test
 %! in   = randn (10);
 %! outv = base64_decode (base64_encode (in));
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -1427,17 +1427,17 @@ DEFUN (isdebugmode, args, ,
 @deftypefn {} {} isdebugmode ()\n\
 Return true if in debugging mode, otherwise false.\n\
 @seealso{dbwhere, dbstack, dbstatus}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
-  return octave_value (Vdebugging);
+  return ovl (Vdebugging);
 }
 
 DEFUN (__db_next_breakpoint_quiet__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} __db_next_breakpoint_quiet__ ()\n\
 @deftypefnx {} {} __db_next_breakpoint_quiet__ (@var{flag})\n\
 Disable line info printing at the next breakpoint.\n\
 \n\
diff --git a/libinterp/corefcn/defaults.cc b/libinterp/corefcn/defaults.cc
--- a/libinterp/corefcn/defaults.cc
+++ b/libinterp/corefcn/defaults.cc
@@ -582,17 +582,17 @@ DEFUN (OCTAVE_HOME, args, ,
 @deftypefn {} {} OCTAVE_HOME ()\n\
 Return the name of the top-level Octave installation directory.\n\
 @seealso{EXEC_PATH, IMAGE_PATH}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
-  return octave_value (Voctave_home);
+  return ovl (Voctave_home);
 }
 
 /*
 %!assert (ischar (OCTAVE_HOME ()))
 %!error OCTAVE_HOME (1)
 */
 
 DEFUNX ("OCTAVE_VERSION", FOCTAVE_VERSION, args, ,
@@ -600,15 +600,15 @@ DEFUNX ("OCTAVE_VERSION", FOCTAVE_VERSIO
 @deftypefn {} {} OCTAVE_VERSION ()\n\
 Return the version number of Octave as a string.\n\
 @seealso{ver, version}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
-  return octave_value (OCTAVE_VERSION);
+  return ovl (OCTAVE_VERSION);
 }
 
 /*
 %!assert (ischar (OCTAVE_VERSION ()))
 %!error OCTAVE_VERSION (1)
 */
diff --git a/libinterp/corefcn/det.cc b/libinterp/corefcn/det.cc
--- a/libinterp/corefcn/det.cc
+++ b/libinterp/corefcn/det.cc
@@ -68,23 +68,23 @@ For that, use any of the condition numbe
     print_usage ();
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (nr == 0 && nc == 0)
-    return octave_value (1.0);
+    return ovl (1.0);
 
   int arg_is_empty = empty_arg ("det", nr, nc);
   if (arg_is_empty < 0)
     return ovl ();
   if (arg_is_empty > 0)
-    return octave_value (1.0);
+    return ovl (1.0);
 
   if (nr != nc)
     err_square_matrix_required ("det", "A");
 
   octave_value_list retval (2);
 
   bool isfloat = arg.is_single_type ();
 
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -153,17 +153,17 @@ DEFALIAS (chdir, cd);
 DEFUN (pwd, , ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} pwd ()\n\
 @deftypefnx {} {@var{dir} =} pwd ()\n\
 Return the current working directory.\n\
 @seealso{cd, dir, ls, mkdir, rmdir}\n\
 @end deftypefn")
 {
-  return octave_value (octave_env::get_current_directory ());
+  return ovl (octave_env::get_current_directory ());
 }
 
 DEFUN (readdir, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{files} =} readdir (@var{dir})\n\
 @deftypefnx {} {[@var{files}, @var{err}, @var{msg}] =} readdir (@var{dir})\n\
 Return the names of files in the directory @var{dir} as a cell array of\n\
 strings.\n\
@@ -478,17 +478,17 @@ glob (\"file[12]\")\n\
 {
   if (args.length () != 1)
     print_usage ();
 
   string_vector pat = args(0).xstring_vector_value ("glob: PATTERN must be a string");
 
   glob_match pattern (file_ops::tilde_expand (pat));
 
-  return octave_value (Cell (pattern.glob ()));
+  return ovl (Cell (pattern.glob ()));
 }
 
 /*
 %!test
 %! tmpdir = tempname;
 %! filename = {"file1", "file2", "file3", "myfile1", "myfile1b"};
 %! if (mkdir (tmpdir))
 %!   cwd = pwd;
diff --git a/libinterp/corefcn/dlmread.cc b/libinterp/corefcn/dlmread.cc
--- a/libinterp/corefcn/dlmread.cc
+++ b/libinterp/corefcn/dlmread.cc
@@ -453,19 +453,19 @@ fill empty fields.  The default is zero.
     {
       if (iscmplx)
         cdata = cdata.extract (0, c0, r1, c1);
       else
         rdata = rdata.extract (0, c0, r1, c1);
     }
 
   if (iscmplx)
-    return octave_value (cdata);
+    return ovl (cdata);
   else
-    return octave_value (rdata);
+    return ovl (rdata);
 }
 
 /*
 %!shared file
 %! file = tempname ();
 %! fid = fopen (file, "wt");
 %! fwrite (fid, "1, 2, 3\n4, 5, 6\n7, 8, 9\n10, 11, 12");
 %! fclose (fid);
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -1925,17 +1925,17 @@ fields are set to their default values.\
               Vlast_error_stack
                 = octave_call_stack::backtrace (0, curr_frame);
             }
         }
       else
         error ("lasterror: argument must be a structure or a string");
     }
 
-  return octave_value (err);
+  return ovl (err);
 }
 
 DEFUN (lasterr, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {[@var{msg}, @var{msgid}] =} lasterr ()\n\
 @deftypefnx {} {} lasterr (@var{msg})\n\
 @deftypefnx {} {} lasterr (@var{msg}, @var{msgid})\n\
 Query or set the last error message.\n\
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -243,17 +243,17 @@ second form of the @code{fclose} call cl
 @code{stdin}, @code{stdout}, @code{stderr}, and any FIDs associated\n\
 with gnuplot.\n\
 @seealso{fopen, fflush, freport}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (octave_stream_list::remove (args(0), "fclose"));
+  return ovl (octave_stream_list::remove (args(0), "fclose"));
 }
 
 DEFUN (fclear, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} fclear (@var{fid})\n\
 Clear the stream state for the file specified by the file descriptor\n\
 @var{fid}.\n\
 @seealso{ferror, fopen}\n\
@@ -736,33 +736,33 @@ be positive, negative, or zero but not a
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
   octave_stream os = octave_stream_list::lookup (args(0), "fseek");
 
   octave_value origin_arg = (nargin == 3) ? args(2) : octave_value (-1.0);
 
-  return octave_value (os.seek (args(1), origin_arg));
+  return ovl (os.seek (args(1), origin_arg));
 }
 
 DEFUN (ftell, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{pos} =} ftell (@var{fid})\n\
 Return the position of the file pointer as the number of characters from the\n\
 beginning of the file specified by file descriptor @var{fid}.\n\
 @seealso{fseek, frewind, feof, fopen}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   octave_stream os = octave_stream_list::lookup (args(0), "ftell");
 
-  return octave_value (os.tell ());
+  return ovl (os.tell ());
 }
 
 DEFUN (fprintf, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} fprintf (@var{fid}, @var{template}, @dots{})\n\
 @deftypefnx {} {} fprintf (@var{template}, @dots{})\n\
 @deftypefnx {} {@var{numbytes} =} fprintf (@dots{})\n\
 This function is equivalent to @code{printf}, except that the output is\n\
@@ -810,17 +810,17 @@ expanded even when the template string i
 
       for (int i = fmt_n + 1; i < nargin; i++)
         tmp_args(i-fmt_n-1) = args(i);
     }
 
   result = os.printf (args(fmt_n), tmp_args, who);
 
   if (nargout > 0)
-    return octave_value (result);
+    return ovl (result);
   else
     return ovl ();
 }
 
 DEFUN (printf, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {} {} printf (@var{template}, @dots{})\n\
 Print optional arguments under the control of the template string\n\
@@ -884,17 +884,17 @@ Return a non-negative number on success 
 {
   static std::string who = "fputs";
 
   if (args.length () != 2)
     print_usage ();
 
   octave_stream os = octave_stream_list::lookup (args(0), who);
 
-  return octave_value (os.puts (args(1), who));
+  return ovl (os.puts (args(1), who));
 }
 
 DEFUN (puts, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} puts (@var{string})\n\
 @deftypefnx {} {@var{status} =} puts (@var{string})\n\
 Write a string to the standard output with no formatting.\n\
 \n\
@@ -905,17 +905,17 @@ Return a non-negative number on success 
 @seealso{fputs, disp}\n\
 @end deftypefn")
 {
   static std::string who = "puts";
 
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (stdout_stream.puts (args(0), who));
+  return ovl (stdout_stream.puts (args(0), who));
 }
 
 DEFUN (sprintf, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} sprintf (@var{template}, @dots{})\n\
 This is like @code{printf}, except that the output is returned as a\n\
 string.\n\
 \n\
@@ -1504,17 +1504,17 @@ are too large to fit in the specified pr
   if (nargin > idx)
     arch = args(idx++);
   else if (skip.is_string ())
     {
       arch = skip;
       skip = 0;
     }
 
-  return octave_value (do_fwrite (os, data, prec, skip, arch));
+  return ovl (do_fwrite (os, data, prec, skip, arch));
 }
 
 DEFUNX ("feof", Ffeof, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {} {@var{status} =} feof (@var{fid})\n\
 Return 1 if an end-of-file condition has been encountered for the file\n\
 specified by file descriptor @var{fid} and 0 otherwise.\n\
 \n\
@@ -1524,17 +1524,17 @@ end-of-file condition.\n\
 @seealso{fread, frewind, fseek, fclear, fopen}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
   octave_stream os = octave_stream_list::lookup (args(0), "feof");
 
-  return octave_value (os.eof () ? 1.0 : 0.0);
+  return ovl (os.eof () ? 1.0 : 0.0);
 }
 
 DEFUNX ("ferror", Fferror, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {} {@var{msg} =} ferror (@var{fid})\n\
 @deftypefnx {} {[@var{msg}, @var{err}] =} ferror (@var{fid})\n\
 @deftypefnx {} {[@var{dots}] =} ferror (@var{fid}, \"clear\")\n\
 Query the error status of the stream specified by file descriptor @var{fid}\n\
@@ -1647,17 +1647,17 @@ Close a file identifier that was opened 
 \n\
 The function @code{fclose} may also be used for the same purpose.\n\
 @seealso{fclose, popen}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  return octave_value (octave_stream_list::remove (args(0), "pclose"));
+  return ovl (octave_stream_list::remove (args(0), "pclose"));
 }
 
 DEFUN (tempname, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{fname} =} tempname ()\n\
 @deftypefnx {} {@var{fname} =} tempname (@var{dir})\n\
 @deftypefnx {} {@var{fname} =} tempname (@var{dir}, @var{prefix})\n\
 Return a unique temporary filename as a string.\n\
@@ -1685,17 +1685,17 @@ see @code{tmpfile}.\n\
   if (nargin > 0)
     dir = args(0).xstring_value ("tempname: DIR must be a string");
 
   std::string pfx ("oct-");
 
   if (nargin > 1)
     pfx = args(1).xstring_value ("tempname: PREFIX must be a string");
 
-  return octave_value (octave_tempnam (dir, pfx));
+  return ovl (octave_tempnam (dir, pfx));
 }
 
 /*
 %!test
 %! if (ispc ())
 %!   envname = "TMP";
 %! else
 %!   envname = "TMPDIR";
@@ -1943,17 +1943,17 @@ default location.  This value may not ag
 @code{tempdir} if the user has overridden the default with the @env{TMPDIR}\n\
 environment variable.\n\
 @seealso{tempdir, tempname, mkstemp, tmpfile}\n\
 @end deftypefn")
 {
   if (args.length () != 0)
     print_usage ();
 
-  return octave_value (get_P_tmpdir ());
+  return ovl (get_P_tmpdir ());
 }
 
 // NOTE: the values of SEEK_SET, SEEK_CUR, and SEEK_END have to be
 // this way for Matlab compatibility.
 
 DEFUNX ("SEEK_SET", FSEEK_SET, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {} {} SEEK_SET ()\n\
diff --git a/libinterp/corefcn/getrusage.cc b/libinterp/corefcn/getrusage.cc
--- a/libinterp/corefcn/getrusage.cc
+++ b/libinterp/corefcn/getrusage.cc
@@ -197,17 +197,17 @@ elements @code{sec} (seconds) @code{usec
   m.assign ("msgsnd", tmp);
   m.assign ("msgrcv", tmp);
   m.assign ("nsignals", tmp);
   m.assign ("nvcsw", tmp);
   m.assign ("nivcsw", tmp);
 
 #endif
 
-  return octave_value (m);
+  return ovl (m);
 }
 
 /*
 %!test
 %! r = getrusage ();
 %! assert (isstruct (r));
 %! assert (isfield (r, "idrss"))
 %! assert (isfield (r, "inblock"))
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -10057,19 +10057,19 @@ Undocumented internal function.\n\
         error ("get: invalid handle (= %g)", hcv(n));
 
       vals(n) = go.get (true);
     }
 
   octave_idx_type vals_len = vals.numel ();
 
   if (vals_len > 1)
-    return octave_value (vals);
+    return ovl (vals);
   else if (vals_len == 1)
-    return octave_value (vals(0));
+    return ovl (vals(0));
   else
     return ovl ();
 }
 
 static octave_value
 make_graphics_object (const std::string& go_name,
                       bool integer_figure_handle,
                       const octave_value_list& args)
@@ -10270,17 +10270,17 @@ Determine the number of dimensions in a 
 {
   gh_manager::auto_lock guard;
 
   if (args.length () != 1)
     print_usage ();
 
   double h = args(0).xdouble_value ("__calc_dimensions__: first argument must be a graphics handle");
 
-  return octave_value (calc_dimensions (gh_manager::get_object (h)));
+  return ovl (calc_dimensions (gh_manager::get_object (h)));
 }
 
 DEFUN (__go_axes__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __go_axes__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
@@ -10479,33 +10479,33 @@ Undocumented internal function.\n\
 {
   gh_manager::auto_lock guard;
 
   bool show_hidden = false;
 
   if (args.length () > 0)
     show_hidden = args(0).bool_value ();
 
-  return octave_value (gh_manager::handle_list (show_hidden));
+  return ovl (gh_manager::handle_list (show_hidden));
 }
 
 DEFUN (__go_figure_handles__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __go_figure_handles__ (@var{show_hidden})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   bool show_hidden = false;
 
   if (args.length () > 0)
     show_hidden = args(0).bool_value ();
 
-  return octave_value (gh_manager::figure_handle_list (show_hidden));
+  return ovl (gh_manager::figure_handle_list (show_hidden));
 }
 
 DEFUN (__go_execute_callback__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} __go_execute_callback__ (@var{h}, @var{name})\n\
 @deftypefnx {} {} __go_execute_callback__ (@var{h}, @var{name}, @var{param})\n\
 Undocumented internal function.\n\
 @end deftypefn")
@@ -10646,17 +10646,17 @@ DEFUN (available_graphics_toolkits, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} available_graphics_toolkits ()\n\
 Return a cell array of registered graphics toolkits.\n\
 @seealso{graphics_toolkit, register_graphics_toolkit}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
-  return octave_value (gtk_manager::available_toolkits_list ());
+  return ovl (gtk_manager::available_toolkits_list ());
 }
 
 DEFUN (register_graphics_toolkit, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} register_graphics_toolkit (@var{toolkit})\n\
 List @var{toolkit} as an available graphics toolkit.\n\
 @seealso{available_graphics_toolkits}\n\
 @end deftypefn")
@@ -10677,17 +10677,17 @@ DEFUN (loaded_graphics_toolkits, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} loaded_graphics_toolkits ()\n\
 Return a cell array of the currently loaded graphics toolkits.\n\
 @seealso{available_graphics_toolkits}\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
-  return octave_value (gtk_manager::loaded_toolkits_list ());
+  return ovl (gtk_manager::loaded_toolkits_list ());
 }
 
 DEFUN (drawnow, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} drawnow ()\n\
 @deftypefnx {} {} drawnow (\"expose\")\n\
 @deftypefnx {} {} drawnow (@var{term}, @var{file}, @var{mono}, @var{debug_file})\n\
 Update figure windows and their children.\n\
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -1162,43 +1162,43 @@ The format is a string which is one of @
 // operators.
 
 DEFUN (__operators__, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __operators__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  return octave_value (Cell (names (operators_map)));
+  return ovl (Cell (names (operators_map)));
 }
 
 // Return a cell array of strings containing the names of all
 // keywords.
 
 DEFUN (__keywords__, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __keywords__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  return octave_value (Cell (names (keywords_map)));
+  return ovl (Cell (names (keywords_map)));
 }
 
 // Return a cell array of strings containing the names of all builtin
 // functions.
 
 DEFUN (__builtins__, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __builtins__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   const string_vector bif = symbol_table::built_in_function_names ();
 
-  return octave_value (Cell (bif));
+  return ovl (Cell (bif));
 }
 
 static std::string
 do_which (const std::string& name, std::string& type)
 {
   std::string file;
 
   type = "";
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -847,17 +847,17 @@ string @samp{(yes or no) } to it.  The u
   if (nargin > 1)
     print_usage ();
 
   std::string prompt;
 
   if (nargin == 1)
     prompt = args(0).xstring_value ("yes_or_no: PROMPT must be a string");
 
-  return octave_value (octave_yes_or_no (prompt));
+  return ovl (octave_yes_or_no (prompt));
 }
 
 octave_value
 do_keyboard (const octave_value_list& args)
 {
   octave_value retval;
 
   int nargin = args.length ();
@@ -1245,17 +1245,17 @@ list of input hook functions.\n\
 
   hook_function hook_fcn (args(0), user_data);
 
   if (input_event_hook_functions.empty ())
     command_editor::add_event_hook (internal_input_event_hook_fcn);
 
   input_event_hook_functions.insert (hook_fcn.id (), hook_fcn);
 
-  return octave_value (hook_fcn.id ());
+  return ovl (hook_fcn.id ());
 }
 
 DEFUN (remove_input_event_hook, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} remove_input_event_hook (@var{name})\n\
 @deftypefnx {} {} remove_input_event_hook (@var{fcn_id})\n\
 Remove the named function or function handle with the given identifier\n\
 from the list of functions to call periodically when Octave is waiting\n\
diff --git a/libinterp/corefcn/inv.cc b/libinterp/corefcn/inv.cc
--- a/libinterp/corefcn/inv.cc
+++ b/libinterp/corefcn/inv.cc
@@ -66,17 +66,17 @@ sparse matrix if possible.\n\
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("inverse", nr, nc);
 
   if (arg_is_empty < 0)
     return ovl ();
   else if (arg_is_empty > 0)
-    return octave_value (Matrix ());
+    return ovl (Matrix ());
 
   if (nr != nc)
     err_square_matrix_required ("inverse", "A");
 
   octave_value result;
   octave_idx_type info;
   double rcond = 0.0;
   float frcond = 0.0;
diff --git a/libinterp/corefcn/kron.cc b/libinterp/corefcn/kron.cc
--- a/libinterp/corefcn/kron.cc
+++ b/libinterp/corefcn/kron.cc
@@ -151,16 +151,17 @@ kron (const PermMatrix& a, const PermMat
 }
 
 template <class MTA, class MTB>
 octave_value
 do_kron (const octave_value& a, const octave_value& b)
 {
   MTA am = octave_value_extract<MTA> (a);
   MTB bm = octave_value_extract<MTB> (b);
+
   return octave_value (kron (am, bm));
 }
 
 octave_value
 dispatch_kron (const octave_value& a, const octave_value& b)
 {
   octave_value retval;
   if (a.is_perm_matrix () && b.is_perm_matrix ())
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -2295,44 +2295,44 @@ Reinitialize Octave's load path director
 DEFUN (command_line_path, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} command_line_path (@dots{})\n\
 Return the command line path variable.\n\
 \n\
 @seealso{path, addpath, rmpath, genpath, pathdef, savepath, pathsep}\n\
 @end deftypefn")
 {
-  return octave_value (load_path::get_command_line_path ());
+  return ovl (load_path::get_command_line_path ());
 }
 
 DEFUN (restoredefaultpath, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} restoredefaultpath (@dots{})\n\
 Restore Octave's path to its initial state at startup.\n\
 \n\
 @seealso{path, addpath, rmpath, genpath, pathdef, savepath, pathsep}\n\
 @end deftypefn")
 {
   load_path::initialize (true);
 
-  return octave_value (load_path::system_path ());
+  return ovl (load_path::system_path ());
 }
 
 // Return Octave's original default list of directories in which to
 // search for function files.  This corresponds to the path that
 // exists prior to running the system's octaverc file or the user's
 // ~/.octaverc file
 
 DEFUN (__pathorig__, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {@var{val} =} __pathorig__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  return octave_value (load_path::system_path ());
+  return ovl (load_path::system_path ());
 }
 
 DEFUN (path, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {} path ()\n\
 @deftypefnx {} {@var{str} =} path ()\n\
 @deftypefnx {} {@var{str} =} path (@var{path1}, @dots{})\n\
 Modify or display Octave's load path.\n\
@@ -2363,17 +2363,17 @@ No checks are made for duplicate element
         path += dir_path::path_sep_str () + argv[i];
 
       load_path::set (path, true);
 
       rehash_internal ();
     }
 
   if (nargout > 0)
-    return octave_value (load_path::path ());
+    return ovl (load_path::path ());
   else if (nargin == 0 && nargout == 0)
     {
       octave_stdout <<
         "\nOctave's search path contains the following directories:\n\n";
 
       string_vector dirs = load_path::dirs ();
 
       dirs.list_in_columns (octave_stdout);
diff --git a/libinterp/corefcn/pager.cc b/libinterp/corefcn/pager.cc
--- a/libinterp/corefcn/pager.cc
+++ b/libinterp/corefcn/pager.cc
@@ -630,17 +630,17 @@ window in characters (rows and columns).
 @seealso{list_in_columns}\n\
 @end deftypefn")
 {
   RowVector size (2, 0.0);
 
   size(0) = command_editor::terminal_rows ();
   size(1) = command_editor::terminal_cols ();
 
-  return octave_value (size);
+  return ovl (size);
 }
 
 DEFUN (page_output_immediately, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} page_output_immediately ()\n\
 @deftypefnx {} {@var{old_val} =} page_output_immediately (@var{new_val})\n\
 @deftypefnx {} {} page_output_immediately (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave sends\n\
diff --git a/libinterp/corefcn/pinv.cc b/libinterp/corefcn/pinv.cc
--- a/libinterp/corefcn/pinv.cc
+++ b/libinterp/corefcn/pinv.cc
@@ -61,17 +61,17 @@ where @code{sigma_max (@var{x})} is the 
 
   octave_value arg = args(0);
 
   int arg_is_empty = empty_arg ("pinv", arg.rows (), arg.columns ());
 
   if (arg_is_empty < 0)
     return ovl ();
   else if (arg_is_empty > 0)
-    return octave_value (Matrix ());
+    return ovl (Matrix ());
 
   octave_value retval;
 
   bool isfloat = arg.is_single_type ();
 
   if (arg.is_diag_matrix ())
     {
       if (isfloat)
diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -1168,17 +1168,17 @@ using std::unordered_map;
   // Convert to doubles, reusing r.
   for (octave_idx_type i = 0; i < m; i++)
     rvec[i] = ivec[i] + 1;
 
   if (m < n)
     idx.resize (dim_vector (1, m));
 
   // Now create an array object with a cached idx_vector.
-  return octave_value (new octave_matrix (r, idx_vector (idx)));
+  return ovl (new octave_matrix (r, idx_vector (idx)));
 }
 
 /*
 %!assert (sort (randperm (20)), 1:20)
 %!assert (length (randperm (20,10)), 10)
 
 ## Test biggish N (bug #39378)
 %!assert (length (randperm (30000^2, 100000)), 100000)
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -254,16 +254,17 @@ strvcat ([97, 98, 99], \"\", @{\"98\", \
                     t += std::string (max_len - t_len, ' ');
 
                   result[k++] = t;
                 }
             }
         }
     }
 
+  // Cannot use ovl.  Relies on overloaded octave_value call.
   return octave_value (result, '\'');
 }
 
 /*
 %!assert (strvcat (""), "");
 %!assert (strvcat (100) == "d");
 %!assert (strvcat (100,100), ["d";"d"])
 %!assert (strvcat ({100,100}), ["d";"d"])
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -510,17 +510,17 @@ Undocumented internal function\n\
 
   std::string passwd = (nargin > 2)
     ? args(2).xstring_value ("__ftp__: PASSWD must be a string")
     : "";
 
   curl_handle ch
     = ch_manager::make_curl_handle (host, user, passwd, octave_stdout);
 
-  return octave_value (ch.value ());
+  return ovl (ch.value ());
 }
 
 DEFUN (__ftp_pwd__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __ftp_pwd__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -177,17 +177,17 @@ sparse matrices.\n\
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("chol", nr, nc);
 
   if (arg_is_empty < 0)
     return ovl ();
   if (arg_is_empty > 0)
-    return octave_value (Matrix ());
+    return ovl (Matrix ());
 
   if (arg.is_sparse_type ())
     {
       octave_idx_type info;
       bool natural = (nargout != 3);
       bool force = nargout > 1;
 
       if (arg.is_real_type ())
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -3725,17 +3725,17 @@ DEFUN (__meta_get_package__, args, , "")
 }
 
 DEFUN (__superclass_reference__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __superclass_reference__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  return octave_value (new octave_classdef_superclass_ref (args));
+  return ovl (new octave_classdef_superclass_ref (args));
 }
 
 DEFUN (__meta_class_query__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __meta_class_query__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -1666,51 +1666,43 @@ a cell array containing a single entry, 
 that single entry as the value of the field.  That single entry happens\n\
 to be an empty cell array.\n\
 \n\
 Finally, if the value is a non-scalar cell array, then @code{struct}\n\
 produces a struct @strong{array}.\n\
 @seealso{cell2struct, fieldnames, getfield, setfield, rmfield, isfield, orderfields, isstruct, structfun}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
   // struct ([]) returns an empty struct.
 
   // struct (empty_matrix) returns an empty struct with the same
   // dimensions as the empty matrix.
 
   // Note that struct () creates a 1x1 struct with no fields for
   // compatibility with Matlab.
 
   if (nargin == 1 && args(0).is_map ())
-    return args(0);
+    return ovl (args(0));
 
   if (nargin == 1 && args(0).is_object ())
-    {
-      retval = args(0).map_value ();
-
-      return retval;
-    }
+    return ovl (args(0).map_value ());
 
   if ((nargin == 1 || nargin == 2)
       && args(0).is_empty () && args(0).is_real_matrix ())
     {
       if (nargin == 2)
         {
           Array<std::string> cstr = args(1).xcellstr_value ("struct: second argument should be a cell array of field names");
 
-          retval = octave_map (args(0).dims (), cstr);
+          return ovl (octave_map (args(0).dims (), cstr));
         }
       else
-        retval = octave_map (args(0).dims ());
-
-      return retval;
+        return ovl (octave_map (args(0).dims ()));
     }
 
   // Check for "field", VALUE pairs.
 
   for (int i = 0; i < nargin; i += 2)
     {
       if (! args(i).is_string () || i + 1 >= nargin)
         error ("struct: additional arguments must occur as \"field\", VALUE pairs");
@@ -1732,19 +1724,19 @@ produces a struct @strong{array}.\n\
             {
               if (! first_dimensioned_value)
                 {
                   dims = argdims;
                   first_dimensioned_value = i + 1;
                 }
               else if (dims != argdims)
                 {
-                  error ("struct: dimensions of parameter %d do not match those of parameter %d",
+                  error ("struct: dimensions of parameter %d "
+                         "do not match those of parameter %d",
                          first_dimensioned_value, i+1);
-                  return retval;
                 }
             }
         }
     }
 
   // Create the return value.
 
   octave_map map (dims);
@@ -1771,17 +1763,17 @@ produces a struct @strong{array}.\n\
             map.setfield (key, Cell (dims, c(0)));
           else
             map.setfield (key, c);
         }
       else
         map.setfield (key, Cell (dims, args(i+1)));
     }
 
-  return octave_value (map);
+  return ovl (map);
 }
 
 /*
 %!shared x
 %! x(1).a=1;  x(2).a=2;  x(1).b=3;  x(2).b=3;
 %!assert (struct ("a",1, "b",3), x(1))
 %!assert (isempty (x([])))
 %!assert (isempty (struct ("a",{}, "b",{})))
