# HG changeset patch
# User Rik <rik@octave.org>
# Date 1532647932 25200
#      Thu Jul 26 16:32:12 2018 -0700
# Node ID b2917b7858ba02c08c880f3dae679fc51d535632
# Parent  b6f3e8ce681567d988d089e566593a67c67d3615
maint: Use Octave convention for spacing of C++ cast statements.

* PopupMenuControl.cc, __dsearchn__.cc, __magick_read__.cc, cellfun.cc,
gl-render.cc, ls-mat5.cc, mex.cc, tsearch.cc, ccolamd.cc, dmperm.cc,
ov-bool-mat.h, ov-bool-sparse.cc, ov-cx-mat.cc, ov-cx-sparse.cc,
ov-fcn-handle.cc, ov-flt-cx-mat.cc, ov-flt-re-mat.cc, ov-range.cc,
ov-re-mat.cc, ov-re-sparse.cc, jit-typeinfo.cc, jit-typeinfo.h, CDiagMatrix.cc,
CSparse.cc, MatrixType.h, chNDArray.cc, dDiagMatrix.cc, dNDArray.cc,
dSparse.cc, fCDiagMatrix.cc, fDiagMatrix.cc, fNDArray.cc, eigs-base.cc,
oct-fftw.cc, sparse-chol.cc, url-transfer.cc: Change cast statements
to use no space between cast and '<...>' and one space before the opening '('.

diff --git a/libgui/graphics/PopupMenuControl.cc b/libgui/graphics/PopupMenuControl.cc
--- a/libgui/graphics/PopupMenuControl.cc
+++ b/libgui/graphics/PopupMenuControl.cc
@@ -99,17 +99,17 @@ namespace QtHandles
 
       case uicontrol::properties::ID_VALUE:
         m_blockUpdate = true;
         {
           Matrix value = up.get_value ().matrix_value ();
 
           if (value.numel () > 0)
             {
-              if (value(0) != static_cast<int>(value(0)))
+              if (value(0) != static_cast<int> (value(0)))
                 warning ("popupmenu value should be integer");
               else
                 {
                   int newIndex = int (value(0)) - 1;
 
                   if (newIndex >= 0 && newIndex < box->count ())
                     {
                       if (newIndex != box->currentIndex ())
diff --git a/libinterp/corefcn/__dsearchn__.cc b/libinterp/corefcn/__dsearchn__.cc
--- a/libinterp/corefcn/__dsearchn__.cc
+++ b/libinterp/corefcn/__dsearchn__.cc
@@ -75,17 +75,17 @@ Undocumented internal function.
       for (octave_idx_type j = 1; j < nx; j++)
         {
           px += n;
           double d;
           DIST (d, px, pxi, n);
           if (d < d0)
             {
               d0 = d;
-              *pidx = static_cast<double>(j + 1);
+              *pidx = static_cast<double> (j + 1);
             }
           octave_quit ();
         }
 
       *pdist++ = d0;
       pidx++;
       pxi += n;
     }
diff --git a/libinterp/corefcn/__magick_read__.cc b/libinterp/corefcn/__magick_read__.cc
--- a/libinterp/corefcn/__magick_read__.cc
+++ b/libinterp/corefcn/__magick_read__.cc
@@ -1156,17 +1156,17 @@ encode_uint_image (std::vector<Magick::I
 
   // We will be passing the values as integers with depth as specified
   // by QuantumDepth (maximum value specified by MaxRGB).  This is independent
   // of the actual depth of the image.  GM will then convert the values but
   // while in memory, it always keeps the values as specified by QuantumDepth.
   // From GM documentation:
   //  Color arguments are must be scaled to fit the Quantum size according to
   //  the range of MaxRGB
-  const double divisor = static_cast<double>((uint64_t (1) << bitdepth) - 1)
+  const double divisor = static_cast<double> ((uint64_t (1) << bitdepth) - 1)
                          / MaxRGB;
 
   const P *img_fvec = img.fortran_vec ();
   const P *a_fvec   = alpha.fortran_vec ();
   switch (type)
     {
     case Magick::GrayscaleType:
       {
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -94,17 +94,17 @@ get_output_list (octave_idx_type count, 
     {
       if (error_handler.is_defined ())
         {
           octave_scalar_map msg;
           msg.assign ("identifier", last_error_id ());
           msg.assign ("message", last_error_message ());
           msg.assign ("index",
                       static_cast<double> (count
-                                           + static_cast<octave_idx_type>(1)));
+                                           + static_cast<octave_idx_type> (1)));
 
           octave_value_list errlist = inputlist;
           errlist.prepend (msg);
 
           buffer_error_messages--;
 
           tmp = octave::feval (error_handler, errlist, nargout);
         }
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -4337,17 +4337,17 @@ namespace octave
       case '.':
         {
           // The dot marker is special and is drawn at 1/3rd the specified size
 
           // Ensure that something is drawn even at very small markersizes
           if (sz > 0 && sz < 3)
             sz = 3;
 
-          int div = static_cast <int> (M_PI * sz / 12);
+          int div = static_cast<int> (M_PI * sz / 12);
           if (! (div % 2))
             div += 1;               // ensure odd number for left/right symmetry
           div = std::max (div, 3);  // ensure at least a few vertices are drawn
           double ang_step = M_PI / div;
 
           glBegin (GL_POLYGON);
           for (double ang = 0; ang < 2*M_PI; ang += ang_step)
             glVertex2d (sz/6*cos (ang), sz/6*sin (ang));
@@ -4359,17 +4359,17 @@ namespace octave
         glVertex2d (-sz/2, -sz/2);
         glVertex2d (-sz/2, sz/2);
         glVertex2d (sz/2, sz/2);
         glVertex2d (sz/2, -sz/2);
         glEnd ();
         break;
       case 'o':
         {
-          int div = static_cast <int> (M_PI * sz / 4);
+          int div = static_cast<int> (M_PI * sz / 4);
           if (! (div % 2))
             div += 1;               // ensure odd number for left/right symmetry
           div = std::max (div, 5);  // ensure at least a few vertices are drawn
           double ang_step = M_PI / div;
 
           glBegin (filled ? GL_POLYGON : GL_LINE_LOOP);
           for (double ang = 0; ang < 2*M_PI; ang += ang_step)
             glVertex2d (sz/2*cos (ang), sz/2*sin (ang));
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -957,17 +957,17 @@ read_mat5_binary_element (std::istream& 
             goto skip_ahead;
           }
         else if (ftype == "anonymous")
           {
             octave_scalar_map m2
               = m1.contents ("workspace").scalar_map_value ();
             uint32NDArray MCOS = m2.contents ("MCOS").uint32_array_value ();
             octave_idx_type off
-              = static_cast<octave_idx_type>(MCOS(4).double_value ());
+              = static_cast<octave_idx_type> (MCOS(4).double_value ());
             m2 = subsys_ov.scalar_map_value ();
             m2 = m2.contents ("MCOS").scalar_map_value ();
             tc2 = m2.contents ("MCOS").cell_value ()(1 + off).cell_value ()(1);
             m2 = tc2.scalar_map_value ();
 
             octave::unwind_protect_safe frame;
 
             // Set up temporary scope to use for evaluating the text
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -1158,17 +1158,17 @@ public:
       {
         const char *ptr = str[j];
 
         size_t tmp_len = strlen (ptr);
 
         for (size_t i = 0; i < tmp_len; i++)
           cpr[m*i+j] = static_cast<mxChar> (ptr[i]);
 
-        for (size_t i = tmp_len; i < static_cast<size_t>(nc); i++)
+        for (size_t i = tmp_len; i < static_cast<size_t> (nc); i++)
           cpr[m*i+j] = static_cast<mxChar> (' ');
       }
   }
 
 protected:
 
   mxArray_number (const mxArray_number& val)
     : mxArray_matlab (val),
diff --git a/libinterp/corefcn/tsearch.cc b/libinterp/corefcn/tsearch.cc
--- a/libinterp/corefcn/tsearch.cc
+++ b/libinterp/corefcn/tsearch.cc
@@ -45,17 +45,17 @@ inline double max (double a, double b, d
 inline double min (double a, double b, double c)
 {
   if (a > b)
     return (b > c ? c : b);
   else
     return (a > c ? c : a);
 }
 
-#define REF(x,k,i) x(static_cast<octave_idx_type>(elem((k), (i))) - 1)
+#define REF(x,k,i) x(static_cast<octave_idx_type> (elem((k), (i))) - 1)
 
 // for large data set the algorithm is very slow
 // one should presort (how?) either the elements of the points of evaluation
 // to cut down the time needed to decide which triangle contains the
 // given point
 
 // e.g., build up a neighbouring triangle structure and use a simplex-like
 // method to traverse it
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -504,17 +504,17 @@ colamd, csymamd, amd, colamd, symamd, an
 
   if (nargin > 2)
     {
       NDArray in_cmember = args(2).array_value ();
       octave_idx_type cslen = in_cmember.numel ();
       OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, cmember, cslen);
       for (octave_idx_type i = 0; i < cslen; i++)
         // convert cmember from 1-based to 0-based
-        cmember[i] = static_cast<octave_idx_type>(in_cmember(i) - 1);
+        cmember[i] = static_cast<octave_idx_type> (in_cmember(i) - 1);
 
       if (cslen != n_col)
         error ("csymamd: CMEMBER must be of length equal to #cols of A");
 
       if (! CSYMAMD_NAME () (n_col,
                              octave::to_suitesparse_intptr (ridx),
                              octave::to_suitesparse_intptr (cidx),
                              perm, knobs, stats, &calloc, &free, cmember, -1))
diff --git a/libinterp/dldfcn/dmperm.cc b/libinterp/dldfcn/dmperm.cc
--- a/libinterp/dldfcn/dmperm.cc
+++ b/libinterp/dldfcn/dmperm.cc
@@ -86,17 +86,17 @@ dmperm_internal (bool rank, const octave
     {
       octave::suitesparse_integer *jmatch = CXSPARSE_NAME (_maxtrans) (&csm, 0);
       if (rank)
         {
           octave_idx_type r = 0;
           for (octave_idx_type i = 0; i < nc; i++)
             if (jmatch[nr+i] >= 0)
               r++;
-          retval(0) = static_cast<double>(r);
+          retval(0) = static_cast<double> (r);
         }
       else
         retval(0) = put_int (jmatch + nr, nc);
       CXSPARSE_NAME (_free) (jmatch);
     }
   else
     {
       CXSPARSE_NAME (d) *dm = CXSPARSE_NAME(_dmperm) (&csm, 0);
diff --git a/libinterp/octave-value/ov-bool-mat.h b/libinterp/octave-value/ov-bool-mat.h
--- a/libinterp/octave-value/ov-bool-mat.h
+++ b/libinterp/octave-value/ov-bool-mat.h
@@ -164,17 +164,17 @@ public:
   charNDArray
   char_array_value (bool = false) const
   {
     charNDArray retval (dims ());
 
     octave_idx_type nel = numel ();
 
     for (octave_idx_type i = 0; i < nel; i++)
-      retval(i) = static_cast<char>(matrix(i));
+      retval(i) = static_cast<char> (matrix(i));
 
     return retval;
   }
 
   boolMatrix bool_matrix_value (bool = false) const
   { return boolMatrix (matrix); }
 
   boolNDArray bool_array_value (bool = false) const
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -161,17 +161,17 @@ charNDArray
 octave_sparse_bool_matrix::char_array_value (bool) const
 {
   charNDArray retval (dims (), 0);
   octave_idx_type nc = matrix.cols ();
   octave_idx_type nr = matrix.rows ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = matrix.cidx (j); i < matrix.cidx (j+1); i++)
-      retval(matrix.ridx (i) + nr * j) = static_cast<char>(matrix.data (i));
+      retval(matrix.ridx (i) + nr * j) = static_cast<char> (matrix.data (i));
 
   return retval;
 }
 
 boolMatrix
 octave_sparse_bool_matrix::bool_matrix_value (bool) const
 {
   return matrix.matrix_value ();
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -240,17 +240,17 @@ octave_complex_matrix::char_array_value 
     warn_implicit_conversion ("Octave:num-to-str",
                               "complex matrix", "string");
   else
     {
       retval = charNDArray (dims ());
       octave_idx_type nel = numel ();
 
       for (octave_idx_type i = 0; i < nel; i++)
-        retval.elem (i) = static_cast<char>(std::real (matrix.elem (i)));
+        retval.elem (i) = static_cast<char> (std::real (matrix.elem (i)));
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 octave_complex_matrix::float_complex_array_value (bool) const
 {
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -173,17 +173,17 @@ octave_sparse_complex_matrix::char_array
     {
       retval = charNDArray (dims (), 0);
       octave_idx_type nc = matrix.cols ();
       octave_idx_type nr = matrix.rows ();
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = matrix.cidx (j); i < matrix.cidx (j+1); i++)
           retval(matrix.ridx (i) + nr * j) =
-            static_cast<char>(std::real (matrix.data (i)));
+            static_cast<char> (std::real (matrix.data (i)));
     }
 
   return retval;
 }
 
 SparseMatrix
 octave_sparse_complex_matrix::sparse_matrix_value (bool force_conversion) const
 {
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -1167,17 +1167,17 @@ octave_fcn_handle::load_hdf5 (octave_hdf
 #if defined (HAVE_HDF5_18)
           data_hid = H5Gopen (group_hid, "symbol table", octave_H5P_DEFAULT);
 #else
           data_hid = H5Gopen (group_hid, "symbol table");
 #endif
           H5Gget_num_objs (data_hid, &num_obj);
           H5Gclose (data_hid);
 
-          if (num_obj != static_cast<hsize_t>(len))
+          if (num_obj != static_cast<hsize_t> (len))
             error ("load: failed to load anonymous function handle");
 
           hdf5_callback_data dsub;
           int current_item = 0;
           for (octave_idx_type i = 0; i < len; i++)
             {
               if (hdf5_h5g_iterate (group_hid, "symbol table", &current_item,
                                     &dsub) <= 0)
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -214,17 +214,17 @@ octave_float_complex_matrix::char_array_
     warn_implicit_conversion ("Octave:num-to-str",
                               "complex matrix", "string");
   else
     {
       retval = charNDArray (dims ());
       octave_idx_type nel = numel ();
 
       for (octave_idx_type i = 0; i < nel; i++)
-        retval.elem (i) = static_cast<char>(std::real (matrix.elem (i)));
+        retval.elem (i) = static_cast<char> (std::real (matrix.elem (i)));
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 octave_float_complex_matrix::float_complex_array_value (bool) const
 {
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -211,17 +211,17 @@ octave_float_matrix::bool_array_value (b
 charNDArray
 octave_float_matrix::char_array_value (bool) const
 {
   charNDArray retval (dims ());
 
   octave_idx_type nel = numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
-    retval.elem (i) = static_cast<char>(matrix.elem (i));
+    retval.elem (i) = static_cast<char> (matrix.elem (i));
 
   return retval;
 }
 
 SparseMatrix
 octave_float_matrix::sparse_matrix_value (bool) const
 {
   return SparseMatrix (matrix_value ());
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -217,17 +217,17 @@ charNDArray
 octave_range::char_array_value (bool) const
 {
   const Matrix matrix = range.matrix_value ();
   charNDArray retval (dims ());
 
   octave_idx_type nel = numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
-    retval.elem (i) = static_cast<char>(matrix.elem (i));
+    retval.elem (i) = static_cast<char> (matrix.elem (i));
 
   return retval;
 }
 
 octave_value
 octave_range::all (int dim) const
 {
   // FIXME: this is a potential waste of memory.
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -221,17 +221,17 @@ octave_matrix::bool_array_value (bool wa
 charNDArray
 octave_matrix::char_array_value (bool) const
 {
   charNDArray retval (dims ());
 
   octave_idx_type nel = numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
-    retval.elem (i) = static_cast<char>(matrix.elem (i));
+    retval.elem (i) = static_cast<char> (matrix.elem (i));
 
   return retval;
 }
 
 SparseMatrix
 octave_matrix::sparse_matrix_value (bool) const
 {
   return SparseMatrix (Matrix (matrix));
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -143,17 +143,17 @@ charNDArray
 octave_sparse_matrix::char_array_value (bool) const
 {
   charNDArray retval (dims (), 0);
   octave_idx_type nc = matrix.cols ();
   octave_idx_type nr = matrix.rows ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = matrix.cidx (j); i < matrix.cidx (j+1); i++)
-      retval(matrix.ridx (i) + nr * j) = static_cast<char>(matrix.data (i));
+      retval(matrix.ridx (i) + nr * j) = static_cast<char> (matrix.data (i));
 
   return retval;
 }
 
 ComplexMatrix
 octave_sparse_matrix::complex_matrix_value (bool) const
 {
   return ComplexMatrix (matrix.matrix_value ());
diff --git a/libinterp/parse-tree/jit-typeinfo.cc b/libinterp/parse-tree/jit-typeinfo.cc
--- a/libinterp/parse-tree/jit-typeinfo.cc
+++ b/libinterp/parse-tree/jit-typeinfo.cc
@@ -871,17 +871,17 @@ namespace octave
 
     return ret;
   }
 
   Array<octave_idx_type>
   jit_operation::to_idx (const std::vector<jit_type*>& types) const
   {
     octave_idx_type numel = types.size ();
-    numel = std::max (numel, static_cast<octave_idx_type>(2));
+    numel = std::max (numel, static_cast<octave_idx_type> (2));
 
     Array<octave_idx_type> idx (dim_vector (1, numel));
     for (octave_idx_type i = 0;
          i < static_cast<octave_idx_type> (types.size ());
          ++i)
       idx(i) = types[i]->type_id ();
 
     if (types.size () == 0)
diff --git a/libinterp/parse-tree/jit-typeinfo.h b/libinterp/parse-tree/jit-typeinfo.h
--- a/libinterp/parse-tree/jit-typeinfo.h
+++ b/libinterp/parse-tree/jit-typeinfo.h
@@ -749,17 +749,17 @@ namespace octave
                                         llvm::Value *result);
 
   private:
 
     jit_type * do_type_of (const octave_value& ov) const;
 
     const jit_operation& do_binary_op (int op) const
     {
-      assert (static_cast<size_t>(op) < m_binary_ops.size ());
+      assert (static_cast<size_t> (op) < m_binary_ops.size ());
       return m_binary_ops[op];
     }
 
     const jit_operation& do_unary_op (int op) const
     {
       assert (static_cast<size_t> (op) < m_unary_ops.size ());
       return m_unary_ops[op];
     }
diff --git a/liboctave/array/CDiagMatrix.cc b/liboctave/array/CDiagMatrix.cc
--- a/liboctave/array/CDiagMatrix.cc
+++ b/liboctave/array/CDiagMatrix.cc
@@ -256,17 +256,17 @@ ComplexDiagMatrix::row (octave_idx_type 
 ComplexRowVector
 ComplexDiagMatrix::row (char *s) const
 {
   if (! s)
     (*current_liboctave_error_handler) ("invalid row selection");
 
   char c = *s;
   if (c == 'f' || c == 'F')
-    return row (static_cast<octave_idx_type>(0));
+    return row (static_cast<octave_idx_type> (0));
   else if (c == 'l' || c == 'L')
     return row (rows () - 1);
   else
     (*current_liboctave_error_handler) ("invalid row selection");
 }
 
 ComplexColumnVector
 ComplexDiagMatrix::column (octave_idx_type i) const
@@ -286,17 +286,17 @@ ComplexDiagMatrix::column (octave_idx_ty
 ComplexColumnVector
 ComplexDiagMatrix::column (char *s) const
 {
   if (! s)
     (*current_liboctave_error_handler) ("invalid column selection");
 
   char c = *s;
   if (c == 'f' || c == 'F')
-    return column (static_cast<octave_idx_type>(0));
+    return column (static_cast<octave_idx_type> (0));
   else if (c == 'l' || c == 'L')
     return column (cols () - 1);
   else
     (*current_liboctave_error_handler) ("invalid column selection");
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::inverse (void) const
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -6041,24 +6041,24 @@ SparseComplexMatrix::fsolve (MatrixType&
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval = SparseComplexMatrix
-                       (static_cast<octave_idx_type>(X->nrow),
-                        static_cast<octave_idx_type>(X->ncol),
-                        static_cast<octave_idx_type>(X->nzmax));
+                       (static_cast<octave_idx_type> (X->nrow),
+                        static_cast<octave_idx_type> (X->ncol),
+                        static_cast<octave_idx_type> (X->nzmax));
               for (octave_idx_type j = 0;
-                   j <= static_cast<octave_idx_type>(X->ncol); j++)
+                   j <= static_cast<octave_idx_type> (X->ncol); j++)
                 retval.xcidx (j) = static_cast<octave_idx_type *>(X->p)[j];
               for (octave_idx_type j = 0;
-                   j < static_cast<octave_idx_type>(X->nzmax); j++)
+                   j < static_cast<octave_idx_type> (X->nzmax); j++)
                 {
                   retval.xridx (j) = static_cast<octave_idx_type *>(X->i)[j];
                   retval.xdata (j) = static_cast<Complex *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
@@ -6575,24 +6575,24 @@ SparseComplexMatrix::fsolve (MatrixType&
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval = SparseComplexMatrix
-                       (static_cast<octave_idx_type>(X->nrow),
-                        static_cast<octave_idx_type>(X->ncol),
-                        static_cast<octave_idx_type>(X->nzmax));
+                       (static_cast<octave_idx_type> (X->nrow),
+                        static_cast<octave_idx_type> (X->ncol),
+                        static_cast<octave_idx_type> (X->nzmax));
               for (octave_idx_type j = 0;
-                   j <= static_cast<octave_idx_type>(X->ncol); j++)
+                   j <= static_cast<octave_idx_type> (X->ncol); j++)
                 retval.xcidx (j) = static_cast<octave_idx_type *>(X->p)[j];
               for (octave_idx_type j = 0;
-                   j < static_cast<octave_idx_type>(X->nzmax); j++)
+                   j < static_cast<octave_idx_type> (X->nzmax); j++)
                 {
                   retval.xridx (j) = static_cast<octave_idx_type *>(X->i)[j];
                   retval.xdata (j) = static_cast<Complex *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
diff --git a/liboctave/array/MatrixType.h b/liboctave/array/MatrixType.h
--- a/liboctave/array/MatrixType.h
+++ b/liboctave/array/MatrixType.h
@@ -187,17 +187,17 @@ public:
 
   void mark_as_permuted (const octave_idx_type np, const octave_idx_type *p);
 
   void mark_as_unpermuted (void);
 
   MatrixType transpose (void) const;
 
 private:
-  void type (int new_typ) { typ = static_cast<matrix_type>(new_typ); }
+  void type (int new_typ) { typ = static_cast<matrix_type> (new_typ); }
 
   matrix_type typ;
   double sp_bandden;
   double bandden;
   octave_idx_type upper_band;
   octave_idx_type lower_band;
   bool dense;
   bool full;
diff --git a/liboctave/array/chNDArray.cc b/liboctave/array/chNDArray.cc
--- a/liboctave/array/chNDArray.cc
+++ b/liboctave/array/chNDArray.cc
@@ -123,17 +123,17 @@ charNDArray::concat (const NDArray& rb, 
           ("invalid conversion from NaN to character");
 
       octave_idx_type ival = octave::math::nint_big (d);
 
       if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
         // FIXME: is there something better to do? Should we warn the user?
         ival = 0;
 
-      tmp.elem (i) = static_cast<char>(ival);
+      tmp.elem (i) = static_cast<char> (ival);
     }
 
   insert (tmp, ra_idx);
   return *this;
 }
 
 charNDArray
 charNDArray::max (int dim) const
diff --git a/liboctave/array/dDiagMatrix.cc b/liboctave/array/dDiagMatrix.cc
--- a/liboctave/array/dDiagMatrix.cc
+++ b/liboctave/array/dDiagMatrix.cc
@@ -179,17 +179,17 @@ DiagMatrix::row (octave_idx_type i) cons
 RowVector
 DiagMatrix::row (char *s) const
 {
   if (! s)
     (*current_liboctave_error_handler) ("invalid row selection");
 
   char c = *s;
   if (c == 'f' || c == 'F')
-    return row (static_cast<octave_idx_type>(0));
+    return row (static_cast<octave_idx_type> (0));
   else if (c == 'l' || c == 'L')
     return row (rows () - 1);
   else
     (*current_liboctave_error_handler) ("invalid row selection");
 }
 
 ColumnVector
 DiagMatrix::column (octave_idx_type i) const
@@ -209,17 +209,17 @@ DiagMatrix::column (octave_idx_type i) c
 ColumnVector
 DiagMatrix::column (char *s) const
 {
   if (! s)
     (*current_liboctave_error_handler) ("invalid column selection");
 
   char c = *s;
   if (c == 'f' || c == 'F')
-    return column (static_cast<octave_idx_type>(0));
+    return column (static_cast<octave_idx_type> (0));
   else if (c == 'l' || c == 'L')
     return column (cols () - 1);
   else
     (*current_liboctave_error_handler) ("invalid column selection");
 }
 
 DiagMatrix
 DiagMatrix::inverse (void) const
diff --git a/liboctave/array/dNDArray.cc b/liboctave/array/dNDArray.cc
--- a/liboctave/array/dNDArray.cc
+++ b/liboctave/array/dNDArray.cc
@@ -520,17 +520,17 @@ NDArray::concat (const charNDArray& rb, 
           ("invalid conversion from NaN to character");
 
       octave_idx_type ival = octave::math::nint_big (d);
 
       if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
         // FIXME: is there something better to do? Should we warn the user?
         ival = 0;
 
-      retval.elem (i) = static_cast<char>(ival);
+      retval.elem (i) = static_cast<char> (ival);
     }
 
   if (rb.isempty ())
     return retval;
 
   retval.insert (rb, ra_idx);
   return retval;
 }
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -6054,24 +6054,24 @@ SparseMatrix::fsolve (MatrixType& mattyp
                   return retval;
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
-              retval = SparseMatrix (static_cast<octave_idx_type>(X->nrow),
-                                     static_cast<octave_idx_type>(X->ncol),
-                                     static_cast<octave_idx_type>(X->nzmax));
+              retval = SparseMatrix (static_cast<octave_idx_type> (X->nrow),
+                                     static_cast<octave_idx_type> (X->ncol),
+                                     static_cast<octave_idx_type> (X->nzmax));
               for (octave_idx_type j = 0;
-                   j <= static_cast<octave_idx_type>(X->ncol); j++)
+                   j <= static_cast<octave_idx_type> (X->ncol); j++)
                 retval.xcidx (j) = static_cast<octave_idx_type *>(X->p)[j];
               for (octave_idx_type j = 0;
-                   j < static_cast<octave_idx_type>(X->nzmax); j++)
+                   j < static_cast<octave_idx_type> (X->nzmax); j++)
                 {
                   retval.xridx (j) = static_cast<octave_idx_type *>(X->i)[j];
                   retval.xdata (j) = static_cast<double *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
@@ -6573,24 +6573,24 @@ SparseMatrix::fsolve (MatrixType& mattyp
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval = SparseComplexMatrix
-                       (static_cast<octave_idx_type>(X->nrow),
-                        static_cast<octave_idx_type>(X->ncol),
-                        static_cast<octave_idx_type>(X->nzmax));
+                       (static_cast<octave_idx_type> (X->nrow),
+                        static_cast<octave_idx_type> (X->ncol),
+                        static_cast<octave_idx_type> (X->nzmax));
               for (octave_idx_type j = 0;
-                   j <= static_cast<octave_idx_type>(X->ncol); j++)
+                   j <= static_cast<octave_idx_type> (X->ncol); j++)
                 retval.xcidx (j) = static_cast<octave_idx_type *>(X->p)[j];
               for (octave_idx_type j = 0;
-                   j < static_cast<octave_idx_type>(X->nzmax); j++)
+                   j < static_cast<octave_idx_type> (X->nzmax); j++)
                 {
                   retval.xridx (j) = static_cast<octave_idx_type *>(X->i)[j];
                   retval.xdata (j) = static_cast<Complex *>(X->x)[j];
                 }
 
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(free_sparse) (&X, cm);
               CHOLMOD_NAME(free_factor) (&L, cm);
diff --git a/liboctave/array/fCDiagMatrix.cc b/liboctave/array/fCDiagMatrix.cc
--- a/liboctave/array/fCDiagMatrix.cc
+++ b/liboctave/array/fCDiagMatrix.cc
@@ -260,17 +260,17 @@ FloatComplexDiagMatrix::row (octave_idx_
 FloatComplexRowVector
 FloatComplexDiagMatrix::row (char *s) const
 {
   if (! s)
     (*current_liboctave_error_handler) ("invalid row selection");
 
   char c = *s;
   if (c == 'f' || c == 'F')
-    return row (static_cast<octave_idx_type>(0));
+    return row (static_cast<octave_idx_type> (0));
   else if (c == 'l' || c == 'L')
     return row (rows () - 1);
   else
     (*current_liboctave_error_handler) ("invalid row selection");
 }
 
 FloatComplexColumnVector
 FloatComplexDiagMatrix::column (octave_idx_type i) const
@@ -290,17 +290,17 @@ FloatComplexDiagMatrix::column (octave_i
 FloatComplexColumnVector
 FloatComplexDiagMatrix::column (char *s) const
 {
   if (! s)
     (*current_liboctave_error_handler) ("invalid column selection");
 
   char c = *s;
   if (c == 'f' || c == 'F')
-    return column (static_cast<octave_idx_type>(0));
+    return column (static_cast<octave_idx_type> (0));
   else if (c == 'l' || c == 'L')
     return column (cols () - 1);
   else
     (*current_liboctave_error_handler) ("invalid column selection");
 }
 
 FloatComplexDiagMatrix
 FloatComplexDiagMatrix::inverse (void) const
diff --git a/liboctave/array/fDiagMatrix.cc b/liboctave/array/fDiagMatrix.cc
--- a/liboctave/array/fDiagMatrix.cc
+++ b/liboctave/array/fDiagMatrix.cc
@@ -179,17 +179,17 @@ FloatDiagMatrix::row (octave_idx_type i)
 FloatRowVector
 FloatDiagMatrix::row (char *s) const
 {
   if (! s)
     (*current_liboctave_error_handler) ("invalid row selection");
 
   char c = *s;
   if (c == 'f' || c == 'F')
-    return row (static_cast<octave_idx_type>(0));
+    return row (static_cast<octave_idx_type> (0));
   else if (c == 'l' || c == 'L')
     return row (rows () - 1);
   else
     (*current_liboctave_error_handler) ("invalid row selection");
 }
 
 FloatColumnVector
 FloatDiagMatrix::column (octave_idx_type i) const
@@ -209,17 +209,17 @@ FloatDiagMatrix::column (octave_idx_type
 FloatColumnVector
 FloatDiagMatrix::column (char *s) const
 {
   if (! s)
     (*current_liboctave_error_handler) ("invalid column selection");
 
   char c = *s;
   if (c == 'f' || c == 'F')
-    return column (static_cast<octave_idx_type>(0));
+    return column (static_cast<octave_idx_type> (0));
   else if (c == 'l' || c == 'L')
     return column (cols () - 1);
   else
     (*current_liboctave_error_handler) ("invalid column selection");
 }
 
 FloatDiagMatrix
 FloatDiagMatrix::inverse (void) const
diff --git a/liboctave/array/fNDArray.cc b/liboctave/array/fNDArray.cc
--- a/liboctave/array/fNDArray.cc
+++ b/liboctave/array/fNDArray.cc
@@ -486,17 +486,17 @@ FloatNDArray::concat (const charNDArray&
           ("invalid conversion from NaN to character");
 
       octave_idx_type ival = octave::math::nint_big (d);
 
       if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
         // FIXME: is there something better to do?  Should we warn the user?
         ival = 0;
 
-      retval.elem (i) = static_cast<char>(ival);
+      retval.elem (i) = static_cast<char> (ival);
     }
 
   if (rb.isempty ())
     return retval;
 
   retval.insert (rb, ra_idx);
   return retval;
 }
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -86,17 +86,17 @@ ltsolve (const SM& L, const ColumnVector
   octave_idx_type err = 0;
   double rcond;
   MatrixType ltyp (MatrixType::Lower);
   M retval (n, b_nc);
   const double *qv = Q.fortran_vec ();
   for (octave_idx_type j = 0; j < b_nc; j++)
     {
       for (octave_idx_type i = 0; i < n; i++)
-        retval.elem (i,j) = m.elem (static_cast<octave_idx_type>(qv[i]), j);
+        retval.elem (i,j) = m.elem (static_cast<octave_idx_type> (qv[i]), j);
     }
   return L.solve (ltyp, retval, err, rcond, nullptr);
 }
 
 template <typename SM, typename M>
 static M
 utsolve (const SM& U, const ColumnVector& Q, const M& m)
 {
@@ -111,17 +111,17 @@ utsolve (const SM& U, const ColumnVector
   const double *qv = Q.fortran_vec ();
 
   if (! err)
     {
       retval.resize (n, b_nc);
       for (octave_idx_type j = 0; j < b_nc; j++)
         {
           for (octave_idx_type i = 0; i < n; i++)
-            retval.elem (static_cast<octave_idx_type>(qv[i]), j) =
+            retval.elem (static_cast<octave_idx_type> (qv[i]), j) =
               tmp.elem (i,j);
         }
     }
 
   return retval;
 }
 
 static bool
@@ -279,17 +279,17 @@ LuAminusSigmaB (const SparseMatrix& m, c
         {
           if (permB.numel ())
             {
               SparseMatrix tmp (n,n,n);
               for (octave_idx_type i = 0; i < n; i++)
                 {
                   tmp.xcidx (i) = i;
                   tmp.xridx (i) =
-                    static_cast<octave_idx_type>(permB(i));
+                    static_cast<octave_idx_type> (permB(i));
                   tmp.xdata (i) = 1;
                 }
               tmp.xcidx (n) = n;
 
               AminusSigmaB -= sigma * tmp *
                               b.transpose () * b * tmp.transpose ();
             }
           else
@@ -379,18 +379,18 @@ LuAminusSigmaB (const Matrix& m, const M
           double *p = AminusSigmaB.fortran_vec ();
 
           if (permB.numel ())
             {
               for (octave_idx_type j = 0;
                    j < b.cols (); j++)
                 for (octave_idx_type i = 0;
                      i < b.rows (); i++)
-                  *p++ -= tmp.xelem (static_cast<octave_idx_type>(pB[i]),
-                                     static_cast<octave_idx_type>(pB[j]));
+                  *p++ -= tmp.xelem (static_cast<octave_idx_type> (pB[i]),
+                                     static_cast<octave_idx_type> (pB[j]));
             }
           else
             AminusSigmaB -= tmp;
         }
       else
         AminusSigmaB -= sigma * b;
     }
   else
@@ -455,17 +455,17 @@ LuAminusSigmaB (const SparseComplexMatri
         {
           if (permB.numel ())
             {
               SparseMatrix tmp (n,n,n);
               for (octave_idx_type i = 0; i < n; i++)
                 {
                   tmp.xcidx (i) = i;
                   tmp.xridx (i) =
-                    static_cast<octave_idx_type>(permB(i));
+                    static_cast<octave_idx_type> (permB(i));
                   tmp.xdata (i) = 1;
                 }
               tmp.xcidx (n) = n;
 
               AminusSigmaB -= tmp * b.hermitian () * b *
                               tmp.transpose () * sigma;
             }
           else
@@ -556,18 +556,18 @@ LuAminusSigmaB (const ComplexMatrix& m, 
           Complex *p = AminusSigmaB.fortran_vec ();
 
           if (permB.numel ())
             {
               for (octave_idx_type j = 0;
                    j < b.cols (); j++)
                 for (octave_idx_type i = 0;
                      i < b.rows (); i++)
-                  *p++ -= tmp.xelem (static_cast<octave_idx_type>(pB[i]),
-                                     static_cast<octave_idx_type>(pB[j]));
+                  *p++ -= tmp.xelem (static_cast<octave_idx_type> (pB[i]),
+                                     static_cast<octave_idx_type> (pB[j]));
             }
           else
             AminusSigmaB -= tmp;
         }
       else
         AminusSigmaB -= sigma * b;
     }
   else
diff --git a/liboctave/numeric/oct-fftw.cc b/liboctave/numeric/oct-fftw.cc
--- a/liboctave/numeric/oct-fftw.cc
+++ b/liboctave/numeric/oct-fftw.cc
@@ -237,17 +237,17 @@ namespace octave
         if (*cur_plan_p)
           fftw_destroy_plan (*cur_plan_p);
 
         if (plan_destroys_in)
           {
             // Create matrix with the same size and 16-byte alignment as input
             OCTAVE_LOCAL_BUFFER (Complex, itmp, nn * howmany + 32);
             itmp = reinterpret_cast<Complex *>
-              (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
+              (((reinterpret_cast<ptrdiff_t> (itmp) + 15) & ~ 0xF) +
                ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
             *cur_plan_p =
               fftw_plan_many_dft (rank, tmp, howmany,
                                   reinterpret_cast<fftw_complex *> (itmp),
                                   nullptr, stride, dist,
                                   reinterpret_cast<fftw_complex *> (out),
                                   nullptr, stride, dist, dir, plan_flags);
@@ -356,17 +356,17 @@ namespace octave
         if (*cur_plan_p)
           fftw_destroy_plan (*cur_plan_p);
 
         if (plan_destroys_in)
           {
             // Create matrix with the same size and 16-byte alignment as input
             OCTAVE_LOCAL_BUFFER (double, itmp, nn + 32);
             itmp = reinterpret_cast<double *>
-              (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
+              (((reinterpret_cast<ptrdiff_t> (itmp) + 15) & ~ 0xF) +
                ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
             *cur_plan_p =
               fftw_plan_many_dft_r2c (rank, tmp, howmany, itmp,
                                       nullptr, stride, dist,
                                       reinterpret_cast<fftw_complex *> (out),
                                       nullptr, stride, dist, plan_flags);
           }
@@ -593,17 +593,17 @@ namespace octave
         if (*cur_plan_p)
           fftwf_destroy_plan (*cur_plan_p);
 
         if (plan_destroys_in)
           {
             // Create matrix with the same size and 16-byte alignment as input
             OCTAVE_LOCAL_BUFFER (FloatComplex, itmp, nn * howmany + 32);
             itmp = reinterpret_cast<FloatComplex *>
-              (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
+              (((reinterpret_cast<ptrdiff_t> (itmp) + 15) & ~ 0xF) +
                ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
             *cur_plan_p =
               fftwf_plan_many_dft (rank, tmp, howmany,
                                    reinterpret_cast<fftwf_complex *> (itmp),
                                    nullptr, stride, dist,
                                    reinterpret_cast<fftwf_complex *> (out),
                                    nullptr, stride, dist, dir, plan_flags);
@@ -712,17 +712,17 @@ namespace octave
         if (*cur_plan_p)
           fftwf_destroy_plan (*cur_plan_p);
 
         if (plan_destroys_in)
           {
             // Create matrix with the same size and 16-byte alignment as input
             OCTAVE_LOCAL_BUFFER (float, itmp, nn + 32);
             itmp = reinterpret_cast<float *>
-              (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
+              (((reinterpret_cast<ptrdiff_t> (itmp) + 15) & ~ 0xF) +
                ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
             *cur_plan_p =
               fftwf_plan_many_dft_r2c (rank, tmp, howmany, itmp,
                                        nullptr, stride, dist,
                                        reinterpret_cast<fftwf_complex *> (out),
                                        nullptr, stride, dist, plan_flags);
           }
diff --git a/liboctave/numeric/sparse-chol.cc b/liboctave/numeric/sparse-chol.cc
--- a/liboctave/numeric/sparse-chol.cc
+++ b/liboctave/numeric/sparse-chol.cc
@@ -97,17 +97,17 @@ namespace octave
       {
         return Lsparse;
       }
 #endif
 
       octave_idx_type P (void) const
       {
 #if defined (HAVE_CHOLMOD)
-        return (minor_p == static_cast<octave_idx_type>(Lsparse->ncol) ?
+        return (minor_p == static_cast<octave_idx_type> (Lsparse->ncol) ?
                 0 : minor_p + 1);
 #else
         return 0;
 #endif
       }
 
       RowVector perm (void) const { return perms + 1; }
 
@@ -369,17 +369,17 @@ namespace octave
 #if defined (HAVE_CHOLMOD)
 
       octave_idx_type n = Lsparse->nrow;
       SparseMatrix p (n, n, n);
 
       for (octave_idx_type i = 0; i < n; i++)
         {
           p.xcidx (i) = i;
-          p.xridx (i) = static_cast<octave_idx_type>(perms (i));
+          p.xridx (i) = static_cast<octave_idx_type> (perms (i));
           p.xdata (i) = 1;
         }
 
       p.xcidx (n) = n;
 
       return p;
 
 #else
diff --git a/liboctave/util/url-transfer.cc b/liboctave/util/url-transfer.cc
--- a/liboctave/util/url-transfer.cc
+++ b/liboctave/util/url-transfer.cc
@@ -256,17 +256,17 @@ namespace octave
       return stream.gcount ();
     else
       return (stream.fail () ? 0 : size * nmemb);
   }
 
   static size_t
   throw_away (void *, size_t size, size_t nmemb, void *)
   {
-    return static_cast<size_t>(size * nmemb);
+    return static_cast<size_t> (size * nmemb);
   }
 
   // I'd love to rewrite this as a private method of the url_transfer
   // class, but you can't pass the va_list from the wrapper SETOPT to
   // the curl_easy_setopt function.
 #define SETOPT(option, parameter)                                       \
   do                                                                    \
     {                                                                   \
