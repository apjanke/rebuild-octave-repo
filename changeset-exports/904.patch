# HG changeset patch
# User jwe
# Date 784416135 0
#      Wed Nov 09 21:22:15 1994 +0000
# Node ID 3470f1e25a79b8de983df850aeec7cf90baef78d
# Parent  b3692d63cca33adb6bcd8e0f6c6a37f0fcc2ec77
[project @ 1994-11-09 21:22:15 by jwe]

diff --git a/scripts/control/abcddim.m b/scripts/control/abcddim.m
--- a/scripts/control/abcddim.m
+++ b/scripts/control/abcddim.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -27,47 +27,42 @@ function [n, m, p] = abcddim (a, b, c, d
 #         m = number of system inputs,
 #         p = number of system outputs.
 #
 # Returns n = m = p = -1 if the system is not compatible.
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 
   if (nargin != 4)
-    error ("abcddim: illegal number of arguments.  need four.")
+    error ("abcddim: invalid number of arguments.  need four.")
   endif
 
   n = m = p = -1;
 
   [an, am] = size(a);
   if (an != am)
-    fprintf (stderr, "abcddim: a is not square");
-    return;
+    error ("abcddim: a is not square");
   endif
 
   [bn, bm] = size(b);
   if (bn != am)
-    fprintf (stderr, "abcddim: a and b are not compatible");
-    return;
+    error ("abcddim: a and b are not compatible");
   endif
 
   [cn, cm] = size(c);
   if (cm != an)
-    fprintf (stderr, "abcddim: a and c are not compatible");
-    return;
+    error ("abcddim: a and c are not compatible");
   endif
 
   [dn, dm] = size(d);
   if (cn != dn)
-    fprintf (stderr, "abcddim: c and d are not compatible");
-    return;
+    error ("abcddim: c and d are not compatible");
   endif
 
   if (bm != dm)
-    fprintf (stderr, "abcddim: b and d are not compatible");
-    return;
+    error ("abcddim: b and d are not compatible");
   endif
 
   n = an;
   m = bm;
   p = cn;
 
 endfunction
diff --git a/scripts/control/are.m b/scripts/control/are.m
--- a/scripts/control/are.m
+++ b/scripts/control/are.m
@@ -37,35 +37,35 @@ function x = are (a, b, c, opt)
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 
   if (nargin == 3 || nargin == 4)
     if (nargin == 4)
       if (! (strcmp (opt, "N") || strcmp (opt, "P") ...
 	     || strcmp (opt, "S") || strcmp (opt, "B") ...
 	     || strcmp (opt, "n") || strcmp (opt, "p") ...
 	     || strcmp (opt, "s") || strcmp (opt, "b")))
-	printf ("warning: are: opt has an illegal value; setting to B");
+	warning ("are: opt has an invalid value; setting to B");
 	opt = "B";
       endif
     else
       opt = "B";
     endif
     if ((n = is_square(a)) == 0)
       error ("are: a is not square");
     endif
 
     if (is_controllable(a,b) == 0)
-      printf("warning: are: a, b are not controllable");
+      warning ("are: a, b are not controllable");
     endif
     if ((m = is_square (b)) == 0)
       b = b * b';
       m = rows (b);
     endif
     if (is_observable (a, c) == 0)
-      printf ("warning: are: a,c are not observable");
+      warning ("are: a,c are not observable");
     endif
     if ((p = is_square (c)) == 0)
       c = c' * c;
       p = rows (c);
     endif
     if (n != m || n != p)
       error ("are: a, b, c not conformably dimensioned.");
     endif
@@ -78,12 +78,12 @@ function x = are (a, b, c, opt)
 
     [d, h] = balance ([a, -b; -c, -a'], opt);
     [u, s] = schur (h, "A");
     u = d * u;
     n1 = n + 1;
     n2 = 2 * n;
     x = u (n1:n2, 1:n) / u (1:n, 1:n);
   else
-    error("usage: x = are (a, b, c)")
+    usage ("x = are (a, b, c)")
   endif
 
 endfunction
diff --git a/scripts/control/c2d.m b/scripts/control/c2d.m
--- a/scripts/control/c2d.m
+++ b/scripts/control/c2d.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -30,17 +30,17 @@ function [Ad, Bd] = c2d (Ac, Bc, T)
 #
 # assuming a zero-order hold on the input and sample time T.
 
 # Written by R.B. Tenison (btenison@eng.auburn.edu)
 # October 1993
 
 # check args
   if (nargin != 3)
-    error ("usage: c2d (Ac, Bc, T)");
+    usage ("c2d (Ac, Bc, T)");
   endif
 
   [ma, na] = size (Ac);
   [mb, nb] = size (Bc);
 
   if (ma != na)
     error ("c2d: Ac must be square");
   endif
diff --git a/scripts/control/dare.m b/scripts/control/dare.m
--- a/scripts/control/dare.m
+++ b/scripts/control/dare.m
@@ -45,68 +45,68 @@ function x = dare (a, b, c, r, opt)
 #
 # See also: balance, are
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 
   if (nargin == 4 || nargin == 5)
     if (nargin == 5)
       if (opt != "N" || opt != "P" || opt != "S" || opt != "B")
-	fprintf (stderr, "dare: opt has an illegal value -- setting to B");
+	warning ("dare: opt has an invalid value -- setting to B");
 	opt = "B";
       endif
     else
       opt = "B";
     endif
 
 # Check a matrix dimensions
     if ((n = is_square (a)) == 0)
       error ("dare: a is not square");
     endif
 
 # Check a,b compatibility.
 
     [n1, m] = size (b);
 
     if (n1 != n)
-      fprintf (stderr, "warning: dare: a,b are not conformable");
+      warning ("dare: a,b are not conformable");
     endif
 
     if (is_controllable (a, b) == 0)
-      fprintf (stderr, "warning: dare: a,b are not controllable");
+      warning ("dare: a,b are not controllable");
     endif
 
 # Check a,c compatibility.
 
     if (is_observable (a, c) == 0)
-      fprintf (stderr, "warning: dare: a,c are not observable");
+      warning ("dare: a,c are not observable");
     endif
 
     if ((p = is_square (c)) == 0)
       c = c'*c;
       p = rows (c);
     endif
 
     if (n != p)
       error ("dare: a,c are not conformable");
     endif
 
 # Check r dimensions.
 
     if ((m1 = is_square (r)) == 0)
-      fprintf(stderr, "warning: dare: r is not square");
+      warning ("dare: r is not square");
     elseif (m1 != m)
-      fprintf(stderr, "warning: b,r are not conformable");
+      warning ("b,r are not conformable");
     endif
 
     brb = (b/r)*b';
     atc = a'\c;
     [d, sy] = balance ([a + brb*atc, -brb/(a'); -atc, inv (a')], opt);
     [u, s] = schur(sy,'D');
     u = d*u;
     n1 = n+1;
     n2 = 2*n;
     x = u (n1:n2, 1:n)/u(1:n, 1:n);
   else
-    error ("usage: x = dare (a, b, c, r {,opt})");
+    usage ("x = dare (a, b, c, r {,opt})");
   endif
 
 endfunction
diff --git a/scripts/control/dlqe.m b/scripts/control/dlqe.m
--- a/scripts/control/dlqe.m
+++ b/scripts/control/dlqe.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -41,17 +41,17 @@ function [l, m, p, e] = dlqe (a, g, c, s
 #   p = the estimate error covariance after the measurement update
 #   e = closed loop poles of (A - A L C)
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
 # Modified for discrete time by R. Bruce Tenison (btenison@eng.auburn.edu)
 # October, 1993
 
   if (nargin != 5 && nargin != 6)
-    error ("dlqe: illegal number of arguments");
+    error ("dlqe: invalid number of arguments");
   endif
 
 # The problem is dual to the regulator design, so transform to lqr
 # call.
 
   if (nargin == 5)
     [k, p, e] = dlqr (a', c', g*sigw*g', sigv);
     m = p';
diff --git a/scripts/control/dlqr.m b/scripts/control/dlqr.m
--- a/scripts/control/dlqr.m
+++ b/scripts/control/dlqr.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -38,17 +38,17 @@ function [k, p, e] = dlqr (a, b, q, r, z
 #   p = solution of algebraic Riccati equation
 #   e = closed loop poles of (A - B K)
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 # Converted to discrete time by R. B. Tenison
 # (btenison@eng.auburn.edu) October 1993
 
   if (nargin != 4 && nargin != 5)
-    error ("dlqr: illegal number of arguments");
+    error ("dlqr: invalid number of arguments");
   endif
 
 # Check a.
   if ((n = is_square (a)) == 0)
     error ("dlqr: requires 1st parameter(a) to be square");
   endif
 
 # Check b.
diff --git a/scripts/control/dlyap.m b/scripts/control/dlyap.m
--- a/scripts/control/dlyap.m
+++ b/scripts/control/dlyap.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -31,32 +31,32 @@ function x = dlyap (a, b)
 #  a' x a - x + b' b = 0
 #
 # whichever is appropriate.  Uses Schur decomposition as in Kitagawa
 # (1977).
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 
   if ((n = is_square (a)) == 0)
-    fprintf (stderr, "warning: dlyap: a must be square");
+    warning ("dlyap: a must be square");
   endif
 
   if ((m = is_square (b)) == 0)
     [n1, m] = size (b);
     if (n1 == n)
       b = b*b';
       m = n1;
     else
       b = b'*b;
       a = a';
     endif
   endif
 
   if (n != m)
-    fprintf (stderr, "warning: dlyap: a,b not conformably dimensioned");
+    warning ("dlyap: a,b not conformably dimensioned");
   endif
 
   # Solve the equation column by column.
 
   [u, s] = schur (a);
   b = u'*b*u;
 
   j = n;
diff --git a/scripts/control/is_controllable.m b/scripts/control/is_controllable.m
--- a/scripts/control/is_controllable.m
+++ b/scripts/control/is_controllable.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -62,12 +62,12 @@ function retval = is_controllable (a, b,
         else
           error ("is_controllable: tol must be a scalar");
         endif
       else
         retval = (rank (m) == n);
       endif
     endif
   else
-    error ("usage: is_controllable (a, b)");
+    usage ("is_controllable (a, b)");
   endif
 
 endfunction
diff --git a/scripts/control/is_observable.m b/scripts/control/is_observable.m
--- a/scripts/control/is_observable.m
+++ b/scripts/control/is_observable.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -26,12 +26,12 @@ function retval = is_observable (a,c,tol
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 
   if (nargin == 2)
     retval = is_controllable (a', c');
   elseif (nargin == 3)
     retval = is_controllable (a', c', tol);
   else
-    error ("usage: is_observable (a, c {,tol})");
+    usage ("is_observable (a, c {,tol})");
   endif
 
 endfunction
diff --git a/scripts/control/lqe.m b/scripts/control/lqe.m
--- a/scripts/control/lqe.m
+++ b/scripts/control/lqe.m
@@ -37,17 +37,17 @@ function [k, p, e] = lqe (a, g, c, sigw,
 #
 #   k = observer gain, (A - K C) is stable
 #   p = solution of algebraic Riccati equation
 #   e = closed loop poles of (A - K C)
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August, 1993.
 
   if (nargin != 5 && nargin != 6)
-    error ("lqe: illegal number of arguments");
+    error ("lqe: invalid number of arguments");
   endif
 
 # The problem is dual to the regulator design, so transform to lqr
 # call.
 
   if (nargin == 5)
     [k, p, e] = lqr (a', c', g*sigw*g', sigv);
   else
diff --git a/scripts/control/lqr.m b/scripts/control/lqr.m
--- a/scripts/control/lqr.m
+++ b/scripts/control/lqr.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -36,17 +36,17 @@ function [k, p, e] = lqr (a, b, q, r, zz
 #
 #   k = state feedback gain, (A - B K) is stable
 #   p = solution of algebraic Riccati equation
 #   e = closed loop poles of (A - B K)
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 
   if (nargin != 4 && nargin != 5)
-    error ("lqr: illegal number of arguments");
+    error ("lqr: invalid number of arguments");
   endif
 
 # Check a.
   if ((n = is_square (a)) == 0)
     error ("lqr: requires 1st parameter(a) to be square");
   endif
 
 # Check b.
diff --git a/scripts/control/lyap.m b/scripts/control/lyap.m
--- a/scripts/control/lyap.m
+++ b/scripts/control/lyap.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -41,17 +41,17 @@ function x = lyap (a, b, c)
 # whichever is appropriate.
 #
 # Solves by using the Bartels-Stewart algorithm (1972).
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
   
 
   if (nargin != 3 && nargin != 2)
-    error ("usage: lyap (a, b {,c})");
+    usage ("lyap (a, b {,c})");
   endif
 
   if ((n = is_square(a)) == 0)
     error ("lyap: a is not square");
   endif
 
   if (nargin == 2)
 
diff --git a/scripts/control/tzero.m b/scripts/control/tzero.m
--- a/scripts/control/tzero.m
+++ b/scripts/control/tzero.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -26,38 +26,38 @@ function zr = tzero (a, b, c, d, bal)
 #
 # Needs to incorporate mvzero algorithm to isolate finite zeros.
 
 # Written by A. S. Hodel (scotte@eng.auburn.edu) August 1993.
 
   if (nargin == 4)
     bal = "B";
   elseif (nargin != 5)
-    error ("tzero: illegal number of arguments");
+    error ("tzero: invalid number of arguments");
   endif
 
   [n, m, p] = abcddim (a, b, c, d);
 
   if (n > 0 && m > 0 && p > 0)
     if (m != p)
-      fprintf (stderr, "tzero: number of inputs,outputs differ.  squaring up");
+      warning ("tzero: number of inputs,outputs differ.  squaring up");
       if (p > m)
-	fprintf (stderr, "       by padding b and d with zeros.");
+	warning ("       by padding b and d with zeros.");
 	b = [b, zeros (n, p-m)];
 	d = [d, zeros (p, p-m)];
 	m = p;
       else
-	fprintf (stderr, "       by padding c and d with zeros.");
+	warning ("       by padding c and d with zeros.");
 	c = [c; zeros (m-p, n)];
 	d = [d; zeros (m-p, m)];
 	p = m;
       endif
-      fprintf (stderr, "This is a kludge.  Try again with SISO system.");
+      warning ("This is a kludge.  Try again with SISO system.");
     endif
     ab = [-a, -b; c, d];
     bb = [eye (n), zeros (n, m); zeros (p, n), zeros (p, m)];
     [ab,bb] = balance (ab, bb);
     zr = -qzval (ab, bb);
   else
-    error ("tzero: a, b, c, d not compatible.  exiting");
+    error ("tzero: a, b, c, d not compatible");
   endif
 
 endfunction
diff --git a/scripts/elfun/acot.m b/scripts/elfun/acot.m
--- a/scripts/elfun/acot.m
+++ b/scripts/elfun/acot.m
@@ -1,11 +1,11 @@
 function w = acot (z)
 
 # acot (z):  compute the inverse cotangent for each element of z.
 
   if (nargin != 1)
-    error ("usage: acot (z)");
+    usage ("acot (z)");
   endif
 
   w = atan (1 ./ z);
 
 endfunction
\ No newline at end of file
diff --git a/scripts/elfun/acoth.m b/scripts/elfun/acoth.m
--- a/scripts/elfun/acoth.m
+++ b/scripts/elfun/acoth.m
@@ -1,11 +1,11 @@
 function w = acoth (z)
 
 # acoth (z):  compute the inverse hyperbolic cotangent for each element of z. 
 
   if (nargin != 1)
-    error ("usage: acoth (z)");
+    usage ("acoth (z)");
   endif
 
   w = atanh (1 ./ z);
 
 endfunction
\ No newline at end of file
diff --git a/scripts/elfun/acsc.m b/scripts/elfun/acsc.m
--- a/scripts/elfun/acsc.m
+++ b/scripts/elfun/acsc.m
@@ -1,11 +1,11 @@
 function w = acsc (z)
   
 # acsc (z):  compute the inverse cosecant for each element of z.
   
   if (nargin != 1)
-    error ("usage: acsc (z)");
+    usage ("acsc (z)");
   endif
 
   w = asin (1 ./ z);
   
 endfunction
\ No newline at end of file
diff --git a/scripts/elfun/acsch.m b/scripts/elfun/acsch.m
--- a/scripts/elfun/acsch.m
+++ b/scripts/elfun/acsch.m
@@ -1,11 +1,11 @@
 function w = acsch (z)
   
 # acsch (z):  compute the inverse hyperbolic cosecant for each element of z.
   
   if (nargin != 1)
-    error ("usage: acsch (z)");
+    usage ("acsch (z)");
   endif
 
   w = asinh (1 ./ z);
   
 endfunction
\ No newline at end of file
diff --git a/scripts/elfun/asec.m b/scripts/elfun/asec.m
--- a/scripts/elfun/asec.m
+++ b/scripts/elfun/asec.m
@@ -1,11 +1,11 @@
 function w = asec (z)
   
 # asec (z):  compute the inverse secant for each element of z.
   
   if (nargin != 1)
-    error ("usage: asec (z)");
+    usage ("asec (z)");
   endif
 
   w = acos (1 ./ z);
   
 endfunction
\ No newline at end of file
diff --git a/scripts/elfun/asech.m b/scripts/elfun/asech.m
--- a/scripts/elfun/asech.m
+++ b/scripts/elfun/asech.m
@@ -1,11 +1,11 @@
 function w = asech (z)
   
 # asech (z):  compute the inverse hyperbolic secant for each element of z.
   
   if (nargin != 1)
-    error ("usage: acosh (z)");
+    usage ("acosh (z)");
   endif
 
   w = acosh (1 ./ z);
   
 endfunction
diff --git a/scripts/elfun/cot.m b/scripts/elfun/cot.m
--- a/scripts/elfun/cot.m
+++ b/scripts/elfun/cot.m
@@ -1,11 +1,11 @@
 function w = cot (z)
   
 # cot (z):  compute the cotangent for each element of z.
   
   if (nargin != 1)
-    error ("usage: cot (z)");
+    usage ("cot (z)");
   endif
 
   w = 1 ./ tan(z);
   
 endfunction
\ No newline at end of file
diff --git a/scripts/elfun/coth.m b/scripts/elfun/coth.m
--- a/scripts/elfun/coth.m
+++ b/scripts/elfun/coth.m
@@ -1,11 +1,11 @@
 function w = coth (z)
   
 # coth (z):  compute the hyperbolic cotangent for each element of z.
   
   if (nargin != 1)
-    error ("usage: coth (z)");
+    usage ("coth (z)");
   endif
 
   w = 1 ./ tanh(z);
   
 endfunction
\ No newline at end of file
diff --git a/scripts/elfun/csc.m b/scripts/elfun/csc.m
--- a/scripts/elfun/csc.m
+++ b/scripts/elfun/csc.m
@@ -1,11 +1,11 @@
 function w = csc (z)
   
 # csc (z):  compute the cosecant for each element of z.
   
   if (nargin != 1)
-    error ("usage: csc (z)");
+    usage ("csc (z)");
   endif
 
   w = 1 ./ sin(z);
   
 endfunction
diff --git a/scripts/elfun/csch.m b/scripts/elfun/csch.m
--- a/scripts/elfun/csch.m
+++ b/scripts/elfun/csch.m
@@ -1,11 +1,11 @@
 function w = csch (z)
   
 # csch (z):  compute the hyperbolic cosecant for each element of z.
   
   if (nargin != 1)
-    error ("usage: csch (z)");
+    usage ("csch (z)");
   endif
 
   w = 1 ./ sinh(z);
   
 endfunction
diff --git a/scripts/elfun/gcd.m b/scripts/elfun/gcd.m
--- a/scripts/elfun/gcd.m
+++ b/scripts/elfun/gcd.m
@@ -1,38 +1,38 @@
 function [g, v] = gcd (a, ...)
   
-  # [g [, v]] = gcd (a) returns the greatest common divisor g of the
-  # entries of the integer vector a, and an integer vector v such that
-  # g = v(1) * a(k) + ... + v(k) * a(k).
-  #
-  # [g [, v]] = gcd (a1, ..., ak) is the same with a = [a1, ..., ak].
+# [g [, v]] = gcd (a) returns the greatest common divisor g of the
+# entries of the integer vector a, and an integer vector v such that
+# g = v(1) * a(k) + ... + v(k) * a(k).
+#
+# [g [, v]] = gcd (a1, ..., ak) is the same with a = [a1, ..., ak].
   
-  # Written by KH (Kurt.Hornik@ci.tuwien.ac.at) on Sep 16, 1994
-  # Copyright Dept of Statistics and Probability Theory TU Wien
+# Written by KH (Kurt.Hornik@ci.tuwien.ac.at) on Sep 16, 1994
+# Copyright Dept of Statistics and Probability Theory TU Wien
 
   if (nargin > 1)
     va_start;
-    for k=2:nargin;
-      a = [a, va_arg()];
+    for k = 2:nargin;
+      a = [a, va_arg ()];
     endfor
   endif
   
-  if (round(a) != a)
-    error("gcd:  all arguments must be integer");
+  if (round (a) != a)
+    error ("gcd:  all arguments must be integer");
   endif
   
-  g = abs(a(1));
-  v = sign(a(1));
-  for k=1:(length(a)-1)
+  g = abs (a(1));
+  v = sign (a(1));
+  for k = 1:(length (a) - 1)
     x = [g, 1, 0];
-    y = [abs(a(k+1)), 0, 1];
+    y = [abs (a(k+1)), 0, 1];
     while (y(1) > 0)
-      r = x - y * floor(x(1) / y(1));
+      r = x - y * floor (x(1) / y(1));
       x = y;
       y = r;
     endwhile
     g = x(1);
-    v = [x(2) * v, x(3) * sign(a(k+1))];
+    v = [x(2) * v, x(3) * sign (a(k+1))];
   endfor
     
 endfunction
     
\ No newline at end of file
diff --git a/scripts/elfun/lcm.m b/scripts/elfun/lcm.m
--- a/scripts/elfun/lcm.m
+++ b/scripts/elfun/lcm.m
@@ -1,32 +1,32 @@
 function l = lcm (a, ...)
+
+# lcm (a) returns the least common multiple of the entries of the
+# integer vector a.
+# lcm (a1, ..., ak) is the same as lcm([a1, ..., ak]).
   
-  # lcm (a) returns the least common multiple of the entries of the
-  # integer vector a.
-  # lcm (a1, ..., ak) is the same as lcm([a1, ..., ak]).
-  
-  # Written by KH (Kurt.Hornik@ci.tuwien.ac.at) on Sep 16, 1994
-  # Copyright Dept of Statistics and Probability Theory TU Wien
+# Written by KH (Kurt.Hornik@ci.tuwien.ac.at) on Sep 16, 1994
+# Copyright Dept of Statistics and Probability Theory TU Wien
 
   if (nargin > 1)
     va_start;
-    for k=2:nargin;
-      a = [a, va_arg()];
+    for k = 2:nargin;
+      a = [a, va_arg ()];
     endfor
   endif
   
-  if (round(a) != a)
-    error("lcm:  all arguments must be integer");
+  if (round (a) != a)
+    error ("lcm:  all arguments must be integer");
   endif
   
-  if (any(a) == 0)
+  if (any (a) == 0)
     l = 0;
   else
-    a = abs(a);
-    l = a(1);
-    for k=1:(length(a)-1)
+    a = abs (a);
+    l = a (1);
+    for k = 1:(length (a) - 1)
       l = l * a(k+1) / gcd(l, a(k+1));
     endfor
   endif
     
 endfunction
     
\ No newline at end of file
diff --git a/scripts/elfun/log2.m b/scripts/elfun/log2.m
--- a/scripts/elfun/log2.m
+++ b/scripts/elfun/log2.m
@@ -1,11 +1,11 @@
 function w = log2 (z)
   
 # log2 (z):  compute the logarithm base 2 for each element of z.
   
   if (nargin != 1)
-    error ("usage: log2 (z)");
+    usage ("log2 (z)");
   endif
 
   w = log(z) / log(2);
   
 endfunction
\ No newline at end of file
diff --git a/scripts/elfun/sec.m b/scripts/elfun/sec.m
--- a/scripts/elfun/sec.m
+++ b/scripts/elfun/sec.m
@@ -1,11 +1,11 @@
 function w = sec (z)
   
 # sec (z): compute the secant for each element of z.
 
   if (nargin != 1)
-    error ("usage: sec (z)");
+    usage ("sec (z)");
   endif
   
   y = 1 ./ cos(z);
   
 endfunction
\ No newline at end of file
diff --git a/scripts/elfun/sech.m b/scripts/elfun/sech.m
--- a/scripts/elfun/sech.m
+++ b/scripts/elfun/sech.m
@@ -1,11 +1,11 @@
 function w = sech (z)
   
 # sech (z):  compute the hyperbolic secant for each element of z.
   
   if (nargin != 1)
-    error ("usage: sech (z)");
+    usage ("sech (z)");
   endif
 
   y = 1 ./ cosh(z);
   
 endfunction
\ No newline at end of file
diff --git a/scripts/general/columns.m b/scripts/general/columns.m
--- a/scripts/general/columns.m
+++ b/scripts/general/columns.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -20,14 +20,14 @@ function nc = columns (x)
 
 # usage: columns (x)
 #
 # Return the the number of columns in x.
 #
 # See also: size, rows, length, is_scalar, is_vector, is_matrix
 
   if (nargin != 1)
-    error ("usage: columns (x)");
+    usage ("columns (x)");
   endif
 
   [nr, nc] = size (x);
 
 endfunction
diff --git a/scripts/general/fliplr.m b/scripts/general/fliplr.m
--- a/scripts/general/fliplr.m
+++ b/scripts/general/fliplr.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -20,16 +20,16 @@ function y = fliplr (x)
 
 # usage: fliplr (x)
 #
 # Return x with the columns swapped.
 #
 # See also: flipu, rot90
 
   if (nargin != 1)
-    error ("usage: fliplr (x)");
+    usage ("fliplr (x)");
   endif
 
   y = x;
   nc = columns (x);
   y = x (:, nc:-1:1);
 
 endfunction
diff --git a/scripts/general/flipud.m b/scripts/general/flipud.m
--- a/scripts/general/flipud.m
+++ b/scripts/general/flipud.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -20,16 +20,16 @@ function y = flipud (x)
 
 # usage: flipud (x)
 #
 # Return x with the rows swapped.
 #
 # See also: fliplr, rot90
 
   if (nargin != 1)
-    error ("usage: flipud (x)");
+    usage ("flipud (x)");
   endif
 
   y = x;
   nr = rows (x);
   y = x (nr:-1:1, :);
 
 endfunction
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -28,12 +28,12 @@ function retval = int2str (x)
 
   if (nargin == 1)
     if (rows (x) == 1 && columns (x) == 1)
       retval = sprintf ("%d", round (x));
     else
       error ("int2str: expecting scalar argument");
     endif
   else
-    error ("usage: int2str (x)");
+    usage ("int2str (x)");
   endif
 
 endfunction
diff --git a/scripts/general/is_matrix.m b/scripts/general/is_matrix.m
--- a/scripts/general/is_matrix.m
+++ b/scripts/general/is_matrix.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -24,12 +24,12 @@ function retval = is_matrix (x)
 # than 1.
 #
 # See also: size, rows, columns, length, is_scalar, is_vector
 
   if (nargin == 1)
     [nr, nc] = size (x);
     retval = (nr > 1 && nc > 1);
   else
-    error ("usage: is_matrix (x)");
+    usage ("is_matrix (x)");
   endif
 
 endfunction
diff --git a/scripts/general/is_scalar.m b/scripts/general/is_scalar.m
--- a/scripts/general/is_scalar.m
+++ b/scripts/general/is_scalar.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -23,12 +23,12 @@ function retval = is_scalar (x)
 # Return 1 if the number of rows and columns of x are both equal to 1.
 #
 # See also: size, rows, columns, length, is_scalar, is_matrix
 
   if (nargin == 1)
     [nr, nc] = size (x);
     retval = (nr == 1 && nc == 1);
   else
-    error ("usage: is_scalar (x)");
+    usage ("is_scalar (x)");
   endif
 
 endfunction
diff --git a/scripts/general/is_square.m b/scripts/general/is_square.m
--- a/scripts/general/is_square.m
+++ b/scripts/general/is_square.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -30,12 +30,12 @@ function retval = is_square (x)
   if (nargin == 1)
     [nr, nc] = size (x);
     if (nr == nc) 
       retval = nr;
     else
       retval = 0;
     endif
   else
-    error ("usage: is_square (x)");
+    usage ("is_square (x)");
   endif
 
 endfunction
diff --git a/scripts/general/is_symmetric.m b/scripts/general/is_symmetric.m
--- a/scripts/general/is_symmetric.m
+++ b/scripts/general/is_symmetric.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -32,12 +32,12 @@ function retval = is_symmetric (x,tol)
       if (nargin == 1)
 	tol = eps;
       endif
       if (norm (x - x') / norm(x) > tol)
         retval = 0;
       endif
     endif
   else
-    error ("usage: is_symmetric (x {,tol})");
+    usage ("is_symmetric (x {,tol})");
   endif
 
 endfunction
diff --git a/scripts/general/is_vector.m b/scripts/general/is_vector.m
--- a/scripts/general/is_vector.m
+++ b/scripts/general/is_vector.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -24,12 +24,12 @@ function retval = is_vector (x)
 # the number of columns (rows) is greater than one.  Otherwise, return 0. 
 #
 # See also: size, rows, columns, length, is_scalar, is_matrix
 
   if (nargin == 1)
     [nr, nc] = size (x);
     retval = ((nr == 1 && nc > 1) || (nc == 1 && nr > 1));
   else
-    error ("usage: is_vector (x)");
+    usage ("is_vector (x)");
   endif
 
 endfunction
diff --git a/scripts/general/isempty.m b/scripts/general/isempty.m
--- a/scripts/general/isempty.m
+++ b/scripts/general/isempty.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -18,14 +18,14 @@
 
 function retval = isempty (var)
 
 # usage: isempty (x)
 #
 # Return 1 if the argument is an empty matrix.  Otherwise, return 0.
 
   if (nargin != 1)
-    error ("usage: isempty (var)");
+    usage ("isempty (var)");
   endif
 
   retval = (rows (var) == 0 || columns (var) == 0);
 
 endfunction
diff --git a/scripts/general/length.m b/scripts/general/length.m
--- a/scripts/general/length.m
+++ b/scripts/general/length.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -20,14 +20,14 @@ function len = length (x)
 
 # usage: length (x)
 #
 # Return the number of rows or columns, whichever is greater.
 #
 # See also: size, rows, columns, is_scalar, is_vector, is_matrix
 
   if (nargin != 1)
-    error ("usage: length (x)");
+    usage ("length (x)");
   endif
 
   len = max (size (x));
 
 endfunction
diff --git a/scripts/general/linspace.m b/scripts/general/linspace.m
--- a/scripts/general/linspace.m
+++ b/scripts/general/linspace.m
@@ -33,17 +33,17 @@ function retval = linspace (x1, x2, n)
     npoints = 100;
   elseif (nargin == 3)
     if (length (n) == 1)
       npoints = fix (n);
     else
       error ("linspace: arguments must be scalars");
     endif
   else
-    error ("usage: linspace (x1, x2 [, n])");
+    usage ("linspace (x1, x2 [, n])");
   endif
 
   if (npoints < 2)
     error ("linspace: npoints must be greater than 2");
   endif
 
   if (length (x1) == 1 && length (x2) == 1)
     delta = (x2 - x1) / (npoints - 1);
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -40,17 +40,17 @@ function retval = logspace (x1, x2, n)
     npoints = 50;
   elseif (nargin == 3)
     if (length (n) == 1)
       npoints = fix (n);
     else
       error ("logspace: arguments must be scalars");
     endif  
   else
-    error ("usage: logspace (x1, x2 [, n])");
+    usage ("logspace (x1, x2 [, n])");
   endif
 
   if (npoints < 2)
     error ("logspace: npoints must be greater than 2");
   endif
 
   if (length (x1) == 1 && length (x2) == 1)
     x2_tmp = x2;
diff --git a/scripts/general/nargchk.m b/scripts/general/nargchk.m
--- a/scripts/general/nargchk.m
+++ b/scripts/general/nargchk.m
@@ -20,17 +20,17 @@ function retval = nargchk (nargin_min, n
 
 # usage: nargchk (nargin_min, nargin_max, n)
 #
 # If N is in the range NARGIN_MIN to NARGIN_MAX, return the empty
 # matrix.  Otherwise, return a message indicating whether N is too
 # large or too small.
 
   if (nargin != 3)
-    error  ("usage: nargchk (nargin_min, nargin_max, n)");
+    usage ("nargchk (nargin_min, nargin_max, n)");
   endif
 
   if (nargin_min > nargin_max)
     error  ("nargchk: nargin_min > nargin_max");
   endif
 
   if (n < nargin_min)
     retval = "nargchk: N is less than nargin_min";
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -26,12 +26,12 @@ function retval = num2str (x)
 
   if (nargin == 1)
     if (rows (x) == 1 && columns (x) == 1)
       retval = sprintf ("%g", x);
     else
       error ("num2str: expecting scalar argument");
     endif
   else
-    error ("usage: num2str (x)");
+    usage ("num2str (x)");
   endif
 
 endfunction
diff --git a/scripts/general/perror.m b/scripts/general/perror.m
--- a/scripts/general/perror.m
+++ b/scripts/general/perror.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -23,17 +23,17 @@ function perror (name, err)
 # Print an error message for error number `err' from function "name".
 #
 # Messages correspond to the following subroutine versions:
 #
 #   npsol : 4.0
 #   qpsol : 3.2
 
   if (nargin != 2)
-    error ("usage: perror (name, err)");
+    usage ("perror (name, err)");
   endif
 
   if (! isstr (name))
     error ("perror: first argument must be a string");
   endif
 
   if (! is_scalar (err))
     error ("perror: second argument must be a scalar");
diff --git a/scripts/general/postpad.m b/scripts/general/postpad.m
--- a/scripts/general/postpad.m
+++ b/scripts/general/postpad.m
@@ -1,25 +1,26 @@
 function y = postpad(x,l,c)
-#postpad(x,l)
-#Appends zeros to the vector x until it is of length l.
-#postpad(x,l,c) appends the constant c instead of zero.
+
+# postpad(x,l)
+# Appends zeros to the vector x until it is of length l.
+# postpad(x,l,c) appends the constant c instead of zero.
 #
-#If length(x) > l, elements from the end of x are removed
-#until a vector of length l is obtained.
+# If length(x) > l, elements from the end of x are removed
+# until a vector of length l is obtained.
 
 # Author:
 #  Tony Richardson
 #  amr@mpl.ucsd.edu
 #  June 1994
 
   if(nargin == 2)
     c = 0;
   elseif(nargin<2 || nargin>3)
-    error("usage: postpad(x,l) or postpad(x,l,c)");
+    usage ("postpad(x,l) or postpad(x,l,c)");
   endif
 
   if(is_matrix(x))
     error("first argument must be a vector");
   elseif(!is_scalar(l))
     error("second argument must be a scaler");
   endif
 
diff --git a/scripts/general/prepad.m b/scripts/general/prepad.m
--- a/scripts/general/prepad.m
+++ b/scripts/general/prepad.m
@@ -10,17 +10,17 @@ function y = prepad(x,l,c)
 #  Tony Richardson
 #  amr@mpl.ucsd.edu
 #  June 1994
 
 
   if(nargin == 2)
     c = 0;
   elseif(nargin<2 || nargin>3)
-    error("usage: prepad(x,l) or prepad(x,l,c)");
+    usage ("prepad(x,l) or prepad(x,l,c)");
   endif
 
   if(is_matrix(x))
     error("first argument must be a vector");
   elseif(!is_scalar(l))
     error("second argument must be a scaler");
   endif
 
diff --git a/scripts/general/rem.m b/scripts/general/rem.m
--- a/scripts/general/rem.m
+++ b/scripts/general/rem.m
@@ -18,17 +18,17 @@
 
 function retval = rem (x, y)
 
 # usage: rem (x, y)
 #
 # Return remainder (x, y).
 
   if (nargin != 2)
-    error ("usage: rem (x, y)");
+    usage ("rem (x, y)");
   endif
 
   if (any (size (x) != size (y)) && ! (is_scalar (x) || is_scalar (y)))
     error ("rem: argument sizes must agree");
   endif
 
 # Matlab allows complex arguments, but as far as I can tell, that's a
 # bunch of hooey.
diff --git a/scripts/general/reshape.m b/scripts/general/reshape.m
--- a/scripts/general/reshape.m
+++ b/scripts/general/reshape.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -21,17 +21,17 @@ function retval = reshape (a, m, n)
 # usage: reshape (a, m, n)
 #
 # Form an m x n matrix from the elements of a (taken in Fortran's
 # column major ordering).
 #
 # See also: `:', do_fortran_indexing
 
   if (nargin != 3)
-    error ("usage: reshape (a, m, n)");
+    usage ("reshape (a, m, n)");
   else
     [nr, nc] = size (a);
     if (nr * nc == m * n)
       tmp = do_fortran_indexing;
       do_fortran_indexing = "true";
       retval = zeros (m, n);
       retval (:) = a;
       do_fortran_indexing = tmp;
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -46,12 +46,12 @@ function y = rot90 (x, k)
     elseif (k == 2)
       y = flipud (fliplr (x));
     elseif (k == 3)
       y = (flipud (x))';
     else
       error ("rot90: internal error!");
     endif
   else
-    error ("usage: rot90 (x [, k])");
+    usage ("rot90 (x [, k])");
   endif
 
 endfunction
diff --git a/scripts/general/rows.m b/scripts/general/rows.m
--- a/scripts/general/rows.m
+++ b/scripts/general/rows.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -20,14 +20,14 @@ function nr = rows (x)
 
 # usage: rows (x)
 #
 # Return the the number of rows in x.
 #
 # See also: size, columns, length, is_scalar, is_vector, is_matrix
 
   if (nargin != 1)
-    error ("usage: rows (x)");
+    usage ("rows (x)");
   endif
 
   [nr, nc] = size (x);
 
 endfunction
diff --git a/scripts/general/tril.m b/scripts/general/tril.m
--- a/scripts/general/tril.m
+++ b/scripts/general/tril.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -33,17 +33,17 @@ function retval = tril (x, k)
   if (nargin == 1)
     k = 0;
   elseif (nargin == 2)
     max_nr_nc = max (nr, nc);
     if ((k > 0 && k > nr - 1) || (k < 0 && k < 1 - nc))
       error ("tril: requested diagonal out of range")
     endif
   else
-    error ("usage: tril (x [, k])");
+    usage ("tril (x [, k])");
   endif
 
   for i = 1:nr
     for j = i+1-k:nc
       retval (i, j) = 0.0;
     endfor
   endfor
 
diff --git a/scripts/general/triu.m b/scripts/general/triu.m
--- a/scripts/general/triu.m
+++ b/scripts/general/triu.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -33,17 +33,17 @@ function retval = triu (x, k)
   if (nargin == 1)
     k = 0;
   elseif (nargin == 2)
     max_nr_nc = max (nr, nc);
     if ((k > 0 && k > nc - 1) || (k < 0 && k < 1 - nr))
       error ("triu: requested diagonal out of range")
     endif
   else
-    error ("usage: triu (x [, k])");
+    usage ("triu (x [, k])");
   endif
 
   for j = 1:nc
     for i = j+1-k:nr
       retval (i, j) = 0.0;
     endfor
   endfor
 
diff --git a/scripts/image/colormap.m b/scripts/image/colormap.m
--- a/scripts/image/colormap.m
+++ b/scripts/image/colormap.m
@@ -1,25 +1,26 @@
 function cmap = colormap(map)
-#Set the current colormap.
-#
-#colormap(map) sets the current colormap to map.  map should be an n row
-#by 3 column matrix. The columns contain red, green, and blue intensities
-#respectively.  All entries should be between 0 and 1 inclusive. The new
-#colormap is returned.
-#
-#colormap("default") restores the default colormap (a gray scale colormap
-#with 64 entries). The default colormap is returned.
-#
-#colormap with no arguments returns the current colormap.
 
-#Author:
-# Tony Richardson
-# amr@mpl.ucsd.edu
-# July 1994
+# Set the current colormap.
+# 
+# colormap(map) sets the current colormap to map.  map should be an n row
+# by 3 column matrix. The columns contain red, green, and blue intensities
+# respectively.  All entries should be between 0 and 1 inclusive. The new
+# colormap is returned.
+# 
+# colormap("default") restores the default colormap (a gray scale colormap
+# with 64 entries). The default colormap is returned.
+# 
+# colormap with no arguments returns the current colormap.
+
+# Author:
+#  Tony Richardson
+#  amr@mpl.ucsd.edu
+#  July 1994
 
   global CURRENT_COLOR_MAP
 
   cmap_name = "CURRENT_COLOR_MAP";
 
   if(nargin == 1)
     if(isstr(map))
       if(strcmp(map,"default"))
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -1,38 +1,33 @@
 function image(x, zoom)
-#Display an octave image matrix.
-#
-#image(x) displays a matrix as a color image. The elements of x are indices
-#into the current colormap and should have values between 1 and the length
-#of the colormap.
-#
-#image(x,zoom) changes the zoom factor.  The default value is 4.
-#
-#SEE ALSO: imshow, imagesc, colormap.
 
-#Author:
-# Tony Richardson
-# amr@mpl.ucsd.edu
-# July 1994
+# Display an octave image matrix.
+#
+# image(x) displays a matrix as a color image. The elements of x are indices
+# into the current colormap and should have values between 1 and the length
+# of the colormap.
 #
-#Modified:
-# Tony Richardson
-# amr@mpl.ucsd.edu
-# July 1994
-# (Modifications based on suggestions from John Eaton.)
+# image(x,zoom) changes the zoom factor.  The default value is 4.
+#
+# SEE ALSO: imshow, imagesc, colormap.
+
+# Author:
+#  Tony Richardson
+#  amr@mpl.ucsd.edu
+#  July 1994
 
   if (nargin == 0)
     # Load Bobbie Jo Richardson (Born 3/16/94)
     x = loadimage("default.img");
     zoom = 2;
   elseif(nargin == 1)
     zoom = 4;
   elseif(nargin > 2)
-    error("usage: image (matrix, [zoom])");
+    usage ("image (matrix, [zoom])");
   endif
 
   # Generate random file name
   rnd_str = num2str(fix(rand*10000));
   ppm_name = ["image.", rnd_str, ".ppm" ];
 
   saveimage(ppm_name,x,"ppm");
 
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -1,32 +1,27 @@
 function x = imagesc(x, zoom)
-#Scale and display a matrix as an image.
-#
-#imagesc(x) displays a scaled version of the matrix x.  The matrix is
-#scaled so that its entries are indices into the current colormap.
-#The scaled matrix is returned.
-#
-#imagesc(x,zoom) sets the magnification, the default value is 4.
-#
-#SEE ALSO: image, imshow
 
-#Author:
-# Tony Richardson
-# amr@mpl.ucsd.edu
-# July 1994
+# Scale and display a matrix as an image.
+#
+# imagesc(x) displays a scaled version of the matrix x.  The matrix is
+# scaled so that its entries are indices into the current colormap.
+# The scaled matrix is returned.
 #
-#Modified:
-# Tony Richardson
-# amr@mpl.ucsd.edu
-# July 1994
-# (Modifications based on suggestions from John Eaton.)
+# imagesc(x,zoom) sets the magnification, the default value is 4.
+#
+# SEE ALSO: image, imshow
+
+# Author:
+#  Tony Richardson
+#  amr@mpl.ucsd.edu
+#  July 1994
 
   if (nargin < 1 || nargin > 2)
-    error("usage: image (matrix, [zoom])");
+    usage ("image (matrix, [zoom])");
   endif
 
   if (nargin == 1)
     zoom = 4;
   endif
 
   [ high, wide ] = size(x);
 
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -1,28 +1,29 @@
 function imshow(a1,a2,a3)
-#Display images.
+
+# Display images.
 #
-#imshow(X) displays an indexed image using the current colormap.
+# imshow(X) displays an indexed image using the current colormap.
 #
-#imshow(X,map) displays an indexed image using the specified colormap.
-#
-#imshow(I,n) displays a gray scale intensity image.
+# imshow(X,map) displays an indexed image using the specified colormap.
 #
-#imshow(R,G,B) displays an RGB image.
+# imshow(I,n) displays a gray scale intensity image.
 #
-#SEE ALSO: image, imagesc, colormap, gray2ind, rgb2ind.
+# imshow(R,G,B) displays an RGB image.
+#
+# SEE ALSO: image, imagesc, colormap, gray2ind, rgb2ind.
 
-#Author:
-# Tony Richardson
-# amr@mpl.ucsd.edu
-# July 1994
+# Author:
+#  Tony Richardson
+#  amr@mpl.ucsd.edu
+#  July 1994
 
   if (nargin == 0)
-    error("usage: imshow requires at least one argument.");
+    usage ("imshow requires at least one argument.");
   elseif(nargin == 2)
     if(length(a2)==1)
       [a1 a2] = gray2ind(a1,a2);
     endif
     colormap(a2);
   elseif(nargin == 3)
     [a1 a2] = rgb2ind(a1,a2,a3);
     colormap(a2);
diff --git a/scripts/image/ind2gray.m b/scripts/image/ind2gray.m
--- a/scripts/image/ind2gray.m
+++ b/scripts/image/ind2gray.m
@@ -1,19 +1,20 @@
 function Y = ind2gray(X,map)
-#Convert an octave indexed image to a gray scale intensity image.
+
+# Convert an octave indexed image to a gray scale intensity image.
 #
-#Y = ind2gray(X) converts an indexed image to a gray scale intensity
-#image.  The current colormap is used to determine the intensities.
-#The intensity values lie between 0 and 1 inclusive.
+# Y = ind2gray(X) converts an indexed image to a gray scale intensity
+# image.  The current colormap is used to determine the intensities.
+# The intensity values lie between 0 and 1 inclusive.
 #
-#Y = ind2gray(X,map) uses the specified colormap instead of the current
-#one in the conversion process.
+# Y = ind2gray(X,map) uses the specified colormap instead of the current
+# one in the conversion process.
 #
-#SEE ALSO: gray2ind, rgb2ntsc, image, colormap
+# SEE ALSO: gray2ind, rgb2ntsc, image, colormap
 
   if (nargin == 1)
     map = colormap;
   endif
 
   # Convert colormap to intensity values.
   yiq = rgb2ntsc(map);
   y = yiq(:,1);
diff --git a/scripts/image/ind2rgb.m b/scripts/image/ind2rgb.m
--- a/scripts/image/ind2rgb.m
+++ b/scripts/image/ind2rgb.m
@@ -1,16 +1,17 @@
 function [R G B] = ind2rgb(X,map)
-#Convert an indexed image to red, green, and blue color components.
+
+# Convert an indexed image to red, green, and blue color components.
 #
-#[R G B] = ind2rgb(X) uses the current colormap for the conversion.
+# [R G B] = ind2rgb(X) uses the current colormap for the conversion.
 #
-#[R G B] = ind2rgb(X,map) uses the specified colormap.
+# [R G B] = ind2rgb(X,map) uses the specified colormap.
 #
-#SEE ALSO: rgb2ind, image, imshow, ind2gray, gray2ind.
+# SEE ALSO: rgb2ind, image, imshow, ind2gray, gray2ind.
 
   if(nargin == 1)
     map = colormap;
   endif
 
   [hi wi] = size(X);
 
   pref = do_fortran_indexing;
diff --git a/scripts/image/loadimage.m b/scripts/image/loadimage.m
--- a/scripts/image/loadimage.m
+++ b/scripts/image/loadimage.m
@@ -1,19 +1,20 @@
 function [X, map] = loadimage(filename)
-#Load an image file.
+
+# Load an image file.
 #
-#[X, map] = loadimage(img_file) loads an image and it's associated color
-#map from file img_file.  The image must be in stored in octave's image
-#format.
+# [X, map] = loadimage(img_file) loads an image and it's associated color
+# map from file img_file.  The image must be in stored in octave's image
+# format.
 #
-#SEE ALSO: saveimage, load, save
+# SEE ALSO: saveimage, load, save
 
   if (nargin == 0)
-    error ("usage: loadimage (filename)");
+    usage ("loadimage (filename)");
   endif
 
   file = file_in_path (IMAGEPATH, filename);
 
   if (isempty (file))
     error ("loadimage: unable to find image file");
   endif
 
diff --git a/scripts/image/ocean.m b/scripts/image/ocean.m
--- a/scripts/image/ocean.m
+++ b/scripts/image/ocean.m
@@ -1,16 +1,15 @@
 function map = ocean(number)
 
   if(nargin == 0)
     number = 64;
   endif
 
   cutin = fix(number/3);
-
   
   dr = (number-1)/(cutin);
   r = prepad([0:dr:(number-1)],number)';
   dg = (number-1)/(2*cutin);
   g = prepad([0:dg:(number-1)],number)';
   b = [0:(number-1)]';
 
   map = [ r g b ]/(number-1);
diff --git a/scripts/image/rgb2ind.m b/scripts/image/rgb2ind.m
--- a/scripts/image/rgb2ind.m
+++ b/scripts/image/rgb2ind.m
@@ -1,19 +1,20 @@
 function [X map] = rgb2ind(R,G,B)
-#Convert and RGB image to an octave indexed image.
+
+# Convert and RGB image to an octave indexed image.
 #
-#[X map] = rgb2ind(R,G,B)
+# [X map] = rgb2ind(R,G,B)
 #
-#SEE ALSO: ind2rgb, rgb2ntsc.
+# SEE ALSO: ind2rgb, rgb2ntsc.
 #
-#Bugs: The color map may have duplicate entries.
+# Bugs: The color map may have duplicate entries.
 
   if(nargin != 3)
-    error("usage: [X, map] = rgb2ind(R,G,B)");
+    usage ("[X, map] = rgb2ind(R,G,B)");
   endif
 
   [hi wi] = size(R);
 
   X = zeros(hi,wi);
 
   map = zeros(hi*wi,3);
 
diff --git a/scripts/image/saveimage.m b/scripts/image/saveimage.m
--- a/scripts/image/saveimage.m
+++ b/scripts/image/saveimage.m
@@ -1,34 +1,35 @@
 function saveimage(filename,X,img_form,map)
-#Save a matrix to disk in image format.
-#
-#saveimage(filename,x) saves matrix x to file filename in octave's image
-#format.  The current colormap is saved in the file also.
-#
-#saveimage(filename,x,"img") saves the image in the default format and
-#is the same as saveimage(filename,x).
-#
-#saveimage(filename,x,"ppm") saves the image in ppm format instead of
-#the default octave image format.
-#
-#saveimage(filename,x,"ps") saves the image in PostScript format instead
-#of the default octave image format. (Note: images saved in PostScript format
-#can not be read back into octave with loadimage.)
-#
-#saveimage(filename,x,format,map) saves the image along with the specified
-#colormap in the specified format.
-#
-#Note: If the colormap contains only two entries and these entries are black
-#and white, the bitmap ppm and PostScript formats are used.  If the image is
-#a gray scale image (the entries within each row of the colormap are equal)
-#the gray scale ppm and PostScript image formats are used, otherwise the full
-#color formats are used.
-#
-#SEE ALSO: loadimage, save, load, colormap
+
+# Save a matrix to disk in image format.
+# 
+# saveimage(filename,x) saves matrix x to file filename in octave's image
+# format.  The current colormap is saved in the file also.
+# 
+# saveimage(filename,x,"img") saves the image in the default format and
+# is the same as saveimage(filename,x).
+# 
+# saveimage(filename,x,"ppm") saves the image in ppm format instead of
+# the default octave image format.
+# 
+# saveimage(filename,x,"ps") saves the image in PostScript format instead
+# of the default octave image format. (Note: images saved in PostScript format
+# can not be read back into octave with loadimage.)
+# 
+# saveimage(filename,x,format,map) saves the image along with the specified
+# colormap in the specified format.
+# 
+# Note: If the colormap contains only two entries and these entries are black
+# and white, the bitmap ppm and PostScript formats are used.  If the image is
+# a gray scale image (the entries within each row of the colormap are equal)
+# the gray scale ppm and PostScript image formats are used, otherwise the full
+# color formats are used.
+# 
+# SEE ALSO: loadimage, save, load, colormap
 
   if(nargin < 2)
     error("usage: saveimage(filename,matrix,[format, [colormap]])");
   elseif(nargin == 2)
     if(!isstr(filename))
       error("File name must be a string.");
     endif
     map = colormap;
diff --git a/scripts/linear-algebra/cond.m b/scripts/linear-algebra/cond.m
--- a/scripts/linear-algebra/cond.m
+++ b/scripts/linear-algebra/cond.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -27,19 +27,19 @@ function retval = cond (a)
 
   if (nargin == 1)
     [nr, nc] = size (a);
     if (nr == 0 && nc == 0)
       if (strcmp (propagate_empty_matrices, "false"))
         error ("cond: empty matrix is invalid as argument");
       endif
       if (strcmp (propagate_empty_matrices, "warn"))
-        printf ("warning: cond: argument is empty matrix\n");
+        warning ("cond: argument is empty matrix\n");
       endif
       retval = 0.0;
     endif
     sigma = svd (a);
     retval = sigma (1) / sigma (length (sigma));
   else
-    error ("usage: cond (a)");
+    usage ("cond (a)");
   endif
 
 endfunction
diff --git a/scripts/linear-algebra/kron.m b/scripts/linear-algebra/kron.m
--- a/scripts/linear-algebra/kron.m
+++ b/scripts/linear-algebra/kron.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -45,12 +45,12 @@ function x = kron (a, b)
       tmp = a (1, jj)*b;
       for ii = 2:ma
 	tmp = [tmp; a (ii, jj)*b];
       endfor
       x = [x, tmp];
     endfor
 
   else
-    error ("usage: kron (a, b)");
+    usage ("kron (a, b)");
   endif
 
 endfunction
diff --git a/scripts/linear-algebra/null.m b/scripts/linear-algebra/null.m
--- a/scripts/linear-algebra/null.m
+++ b/scripts/linear-algebra/null.m
@@ -17,17 +17,17 @@ function retval = null (A, tol)
 
   [rows, cols] = size (A);
 
   s = diag (S);
 
   if (nargin == 1)
     tol = max (size (A)) * s (1) * eps;
   else (nargin != 2)
-    error("usage: null(A [, tol])"); 
+    usage ("null(A [, tol])"); 
   endif
 
   rank = sum (s > tol);
 
   if (rank < cols)
     retval = V (:, rank+1:cols);
   else
     retval = zeros (cols, 0);
diff --git a/scripts/linear-algebra/orth.m b/scripts/linear-algebra/orth.m
--- a/scripts/linear-algebra/orth.m
+++ b/scripts/linear-algebra/orth.m
@@ -17,17 +17,17 @@ function retval = orth (A, tol)
 
   [rows, cols] = size (A);
 
   s = diag (S);
 
   if (nargin == 1)
     tol = max (size (A)) * s (1) * eps;
   else if (nargin != 2)
-    error ("usage: orth (A [, tol])"); 
+    usage ("orth (A [, tol])"); 
   endif
 
   rank = sum (s > tol);
 
   if (rank > 0)
     retval = -U (:, 1:rank);
   else
     retval = zeros (rows, 0);
diff --git a/scripts/linear-algebra/rank.m b/scripts/linear-algebra/rank.m
--- a/scripts/linear-algebra/rank.m
+++ b/scripts/linear-algebra/rank.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -32,13 +32,13 @@ function retval = rank (A, tol)
 
   if (nargin == 1)
     sigma = svd (A);
     tolerance = max (size (A)) * sigma (1) * eps;
   elseif (nargin == 2)
     sigma = svd (A);
     tolerance = tol;
   else
-    error ("usage: rank (A)");
+    usage ("rank (A)");
   endif
   retval = sum (sigma > tolerance);
 
 endfunction
diff --git a/scripts/linear-algebra/trace.m b/scripts/linear-algebra/trace.m
--- a/scripts/linear-algebra/trace.m
+++ b/scripts/linear-algebra/trace.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -18,14 +18,14 @@
 
 function y = trace (x)
 
 # usage: trace (x)
 #
 # Returns the trace (the sum of the diagonal elements) of x.
 
   if (nargin != 1)
-    error ("usage: trace (x)");
+    usage ("trace (x)");
   endif
 
   y = sum (diag (x));
 
 endfunction
diff --git a/scripts/miscellaneous/bug_report.m b/scripts/miscellaneous/bug_report.m
--- a/scripts/miscellaneous/bug_report.m
+++ b/scripts/miscellaneous/bug_report.m
@@ -20,17 +20,17 @@ function bug_report ()
 
 # usage: bug_report
 #
 # Have Octave create a bug report template file, invoke your favorite
 # editor, and submit the report to the bug-octave mailing list when
 # you are finished editing.
 
   if (nargin != 0)
-    disp ("bug_report: ignoring extra arguments");
+    warning ("bug_report: ignoring extra arguments");
   endif
 
   printf ("Please enter a one-line description of your bug report.\n\n");
   fflush (stdout);
 
   subject = "";
   subject = input ("Subject: ", "s");
 
diff --git a/scripts/miscellaneous/dump_1_pref.m b/scripts/miscellaneous/dump_1_pref.m
--- a/scripts/miscellaneous/dump_1_pref.m
+++ b/scripts/miscellaneous/dump_1_pref.m
@@ -14,17 +14,17 @@
 # 
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, write to the Free
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 function dump_1_pref (file, var)
 
   if (nargin != 2)
-    error ("usage: dump_1_pref (file, var)");
+    usage ("dump_1_pref (file, var)");
   endif
 
   eval (sprintf ("tmp = %s;", var));
 
   if (isstr (tmp))
     fprintf (file, "  %s = \"%s\"\n", var, undo_string_escapes (tmp));
   elseif (is_scalar (tmp))
     fprintf (file, "  %s = %g\n", var, tmp);
diff --git a/scripts/miscellaneous/menu.m b/scripts/miscellaneous/menu.m
--- a/scripts/miscellaneous/menu.m
+++ b/scripts/miscellaneous/menu.m
@@ -18,17 +18,17 @@
 
 function num = menu (t, ...)
 
 # usage: menu (title, opt1, ...)
 #
 # See also: disp, printf, input
 
   if (nargin < 2)
-    error ("usage: menu (title, opt1, ...)");
+    usage ("menu (title, opt1, ...)");
   endif
 
 # Force pending output to appear before the menu.
 
   fflush (stdout);
 
 # Don't send the menu through the pager since doing that can cause
 # major confusion.
diff --git a/scripts/miscellaneous/texas_lotto.m b/scripts/miscellaneous/texas_lotto.m
--- a/scripts/miscellaneous/texas_lotto.m
+++ b/scripts/miscellaneous/texas_lotto.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -21,17 +21,17 @@ function picks = texas_lotto ()
 # usage: texas_lotto
 #
 # Pick 6 unique numbers between 1 and 50 that are guaranteed to win
 # the Texas Lotto.
 #
 # See also: rand
 
   if (nargin != 0)
-    disp ("win_texas_lotto: ignoring extra arguments");
+    warning ("win_texas_lotto: ignoring extra arguments");
   endif
 
   picks = zeros (1,6);
   picks (1) = round (50-49*(1-rand));
   n = 2;
   while (n < 7)
     tmp = round (50-49*(1-rand));
     equal = 0;
diff --git a/scripts/miscellaneous/version.m b/scripts/miscellaneous/version.m
--- a/scripts/miscellaneous/version.m
+++ b/scripts/miscellaneous/version.m
@@ -20,14 +20,14 @@ function vs = version ()
 
 # usage: version
 #
 # Return the Octave version number as a string.
 #
 # See also: OCTAVE_VERSION
 
   if (nargin != 0)
-    disp ("version: ignoring extra arguments");
+    warning ("version: ignoring extra arguments");
   endif
 
   vs = OCTAVE_VERSION;
 
 endfunction
diff --git a/scripts/plot/__plr__.m b/scripts/plot/__plr__.m
--- a/scripts/plot/__plr__.m
+++ b/scripts/plot/__plr__.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -47,17 +47,17 @@ function polar_int (theta, rho)
       if (is_scalar (rho))
         x = rho * cos (theta);
         y = rho * sin (theta);
         plot_2_s_s (x, y);
       endif
     elseif (is_vector (theta))
       if (is_vector (rho))
         if (length (theta) != length (rho))
-          error ("error: polar: vector lengths must match");
+          error ("polar: vector lengths must match");
         endif
         if (rows (rho) == 1)
           rho = rho';
         endif
         if (rows (theta) == 1)
           theta = theta';
         endif
         x = rho .* cos (theta);
@@ -74,17 +74,17 @@ function polar_int (theta, rho)
         [r_nr, r_nc] = size (rho);
         if (t_nr != r_nr)
           rho = rho'
           tmp = r_nr;
           r_nr = r_nc;
           r_nc = tmp;
         endif
         if (t_nr != r_nr)
-          error ("error: polar: vector and matrix sizes must match");
+          error ("polar: vector and matrix sizes must match");
         endif
         x = diag (cos (theta)) * rho;
         y = diag (sin (theta)) * rho;
         plot_2_v_m (x, y);
       endif
     elseif (is_matrix (theta))
       if (is_vector (rho))
         [r_nr, r_nc] = size (rho);
@@ -97,30 +97,28 @@ function polar_int (theta, rho)
         [t_nr, t_nc] = size (theta);
         if (r_nr != t_nr)
           theta = rho'
           tmp = t_nr;
           t_nr = t_nc;
           t_nc = tmp;
         endif
         if (r_nr != t_nr)
-          error ("error: polar: vector and matrix sizes must match");
+          error ("polar: vector and matrix sizes must match");
         endif
         diag_r = diag (r);
         x = diag_r * cos (theta);
         y = diag_r * sin (theta);
         plot_2_m_v (x, y);
       elseif (is_matrix (rho))
         if (size (rho) != size (theta))
-          error ("error: polar: matrix dimensions must match");
+          error ("polar: matrix dimensions must match");
         endif
         x = rho .* cos (theta);
         y = rho .* sin (theta);
         plot_2_m_m (x, y);
       endif
     endif
   else
-    usage = sprintf ("usage: polar_int (x)\n");
-    usage = sprintf ("%s       polar_int (x, y)", usage);
-    error (usage);
+    usage ("polar_int (x [, y])");
   endif
 
 endfunction
diff --git a/scripts/plot/__plt2mm__.m b/scripts/plot/__plt2mm__.m
--- a/scripts/plot/__plt2mm__.m
+++ b/scripts/plot/__plt2mm__.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -14,17 +14,17 @@
 # 
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, write to the Free
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 function plot_2_m_m (x, y)
 
   if (nargin != 2)
-    error ("usage: plot_2_m_m (x, y)");
+    usage ("plot_2_m_m (x, y)");
   endif
 
   [x_nr, x_nc] = size (x);
   [y_nr, y_nc] = size (y);
 
   if (x_nr == y_nr && x_nc == y_nc)
     if (x_nc > 0)
       tmp = [x, y];
diff --git a/scripts/plot/__plt2mv__.m b/scripts/plot/__plt2mv__.m
--- a/scripts/plot/__plt2mv__.m
+++ b/scripts/plot/__plt2mv__.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -14,17 +14,17 @@
 # 
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, write to the Free
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 function plot_2_m_v (x, y)
 
   if (nargin != 2)
-    error ("usage: plot_2_m_v (x, y)");
+    usage ("plot_2_m_v (x, y)");
   endif
 
   [x_nr, x_nc] = size (x);
   [y_nr, y_nc] = size (y);
 
   if (y_nr == 1)
     y = y';
     tmp = y_nr;
diff --git a/scripts/plot/__plt2ss__.m b/scripts/plot/__plt2ss__.m
--- a/scripts/plot/__plt2ss__.m
+++ b/scripts/plot/__plt2ss__.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -14,17 +14,17 @@
 # 
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, write to the Free
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 function plot_2_s_s (x, y)
 
   if (nargin != 2)
-    error ("usage: plot_2_s_s (x, y)");
+    usage ("plot_2_s_s (x, y)");
   endif
 
   [x_nr, x_nc] = size (x);
   [y_nr, y_nc] = size (y);
 
   if (x_nr == 1 && x_nr == y_nr && x_nc == 1 && x_nc == y_nc)
     tmp = [x, y];
     command = sprintf ("gplot tmp");
diff --git a/scripts/plot/__plt2vm__.m b/scripts/plot/__plt2vm__.m
--- a/scripts/plot/__plt2vm__.m
+++ b/scripts/plot/__plt2vm__.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -14,17 +14,17 @@
 # 
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, write to the Free
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 function plot_2_v_m (x, y)
 
   if (nargin != 2)
-    error ("usage: plot_2_v_m (x, y)");
+    usage ("plot_2_v_m (x, y)");
   endif
 
   [x_nr, x_nc] = size (x);
   [y_nr, y_nc] = size (y);
 
   if (x_nr == 1)
     x = x';
     tmp = x_nr;
diff --git a/scripts/plot/__plt2vv__.m b/scripts/plot/__plt2vv__.m
--- a/scripts/plot/__plt2vv__.m
+++ b/scripts/plot/__plt2vv__.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -14,17 +14,17 @@
 # 
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, write to the Free
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 function plot_2_v_v (x, y)
 
   if (nargin != 2)
-    error ("usage: plot_2_m_m (x, y)");
+    usage ("plot_2_m_m (x, y)");
   endif
 
   [x_nr, x_nc] = size (x);
   [y_nr, y_nc] = size (y);
 
   if (x_nr == 1)
     x = x';
     tmp = x_nr;
diff --git a/scripts/plot/__plt__.m b/scripts/plot/__plt__.m
--- a/scripts/plot/__plt__.m
+++ b/scripts/plot/__plt__.m
@@ -56,14 +56,12 @@ function plot_int (x1, x2)
     elseif (is_matrix (x1))
       if (is_vector (x2))
         plot_2_m_v (x1, x2);
       elseif (is_matrix (x2))
         plot_2_m_m (x1, x2);
       endif
     endif
   else
-    usage = sprintf ("usage: plot_int (x)\n");
-    usage = sprintf ("%s       plot_int (x, y)", usage);
-    error (usage);
+    usage ("plot_int (x [, y])");
   endif
 
 endfunction
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -26,17 +26,17 @@ function axis (ax)
 # Sets the axis limits.
 #
 # With no arguments, turns autoscaling on.
 #
 # If your plot is already drawn, then you need to REPLOT before 
 # the new axis limits will take effect.
 
   if (nargin > 1)
-    error ("usage: axis ([xmin, xmax, ymin, ymax, zmin, zmax])");
+    usage ("axis ([xmin, xmax, ymin, ymax, zmin, zmax])");
   endif
 
   if (nargin == 0)
     set autoscale;
   elseif (is_vector (ax))
 
     len = length (ax);
 
diff --git a/scripts/plot/bar.m b/scripts/plot/bar.m
--- a/scripts/plot/bar.m
+++ b/scripts/plot/bar.m
@@ -87,17 +87,17 @@ function [xb, yb] = bar (x, y)
 	endfor
       else
         error ("bar: arguments must be the same length");
       endif
     else
       error ("bar: arguments must be vectors");
     endif
   else
-    error ("usage: [xb, yb] = bar (x, y)");
+    usage ("[xb, yb] = bar (x, y)");
   endif
 
   if (nargout == 0)
     plot (tmp_xb, tmp_yb);
   else
     xb = tmp_xb;
     yb = tmp_yb;
   endif
diff --git a/scripts/plot/contour.m b/scripts/plot/contour.m
--- a/scripts/plot/contour.m
+++ b/scripts/plot/contour.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -62,19 +62,20 @@ function contour (z, n, x, y)
         set contour
         set cntrparam bspline
         command = sprintf ("set cntrparam levels %d", n);
         eval (command);
 	set parametric;
         set view 0, 0, 1.9, 1
 	gsplot zz w l 1;
       else
-        disp ("mesh: rows (z) must be the same as length (x)");
-        error ("      and columns (z) must be the same as length (y)");
+        msg = "mesh: rows (z) must be the same as length (x) and";
+        msg = sprintf ("%s\ncolumns (z) must be the same as length (y)", msg);
+        error (msg);
       endif
     else
       error ("mesh: x and y must be vectors and z must be a matrix");
     endif    
   else
-    error ("usage: mesh (z, levels, x, y)");
+    usage ("mesh (z, levels, x, y)");
   endif
 
 endfunction
diff --git a/scripts/plot/grid.m b/scripts/plot/grid.m
--- a/scripts/plot/grid.m
+++ b/scripts/plot/grid.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -31,18 +31,18 @@ function grid (x)
     set grid;
   elseif (nargin == 1)
     if (isstr (x))
       if (strcmp ("off", x))
         set nogrid;
       elseif (strcmp ("on", x))
         set grid;
       else
-        error ("usage: grid (\"on\" | \"off\")");
+    usage ("grid (\"on\" | \"off\")");
       endif
     else
-      error ("error: grid: argument must be a string");
+      error ("grid: argument must be a string");
     endif
   else
     error ("usage: grid (\"on\" | \"off\")");
   endif
 
 endfunction
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -35,17 +35,17 @@ function [nn, xx] = hist (y, x)
 # Extreme values are lumped in the first and last bins.
 #
 # With two output arguments, produce the values NN and XX such that
 # bar (XX, NN) will plot the histogram.
 #
 # See also: bar
 
   if (nargin < 1 || nargin > 2)
-    error ("usage: [nn, xx] = hist (y, x)");
+    usage ("[nn, xx] = hist (y, x)");
   endif
     
   if (is_vector (y))
     max_val = max (y);
     min_val = min (y);
   else
     error ("hist: first argument must be a vector");
   endif
@@ -62,17 +62,17 @@ function [nn, xx] = hist (y, x)
         error ("hist: number of bins must be positive");
       endif
       delta = (max_val - min_val) / n / 2;
       x = linspace (min_val+delta, max_val-delta, n);
       cutoff = x + delta;
     elseif (is_vector (x))
       tmp = sort (x);
       if (any (tmp != x))
-        fprintf (stderr, "warning: hist: bin values not sorted on input\n");
+        warning ("hist: bin values not sorted on input");
         x = tmp;
       endif
       n = length (x);
       cutoff = zeros (1, n-1);
       for i = 1:n-1
         cutoff (i) = (x (i) + x (i+1)) / 2;
       endfor
     else
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -33,14 +33,12 @@ function loglog (x1, x2)
   set logscale y;
   set nopolar;
 
   if (nargin == 1)
     plot_int (x1);
   elseif (nargin == 2)
     plot_int (x1, x2);
   else
-    usage = sprintf ("usage: loglog (x)\n");
-    usage = sprintf ("%s       loglog (x, y)", usage);
-    error (usage);
+    usage ("loglog (x [, y])");
   endif
 
 endfunction
diff --git a/scripts/plot/mesh.m b/scripts/plot/mesh.m
--- a/scripts/plot/mesh.m
+++ b/scripts/plot/mesh.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -56,19 +56,20 @@ function mesh (x, y, z)
 	set hidden3d;
 	set data style lines;
         set surface;
         set nocontour;
 	set parametric;
         set view 60, 30, 1, 1
 	gsplot (zz);
       else
-        disp ("mesh: rows (z) must be the same as length (x)");
-        error ("      and columns (z) must be the same as length (y)");
+        msg = "mesh: rows (z) must be the same as length (x) and";
+        msg = sprintf ("%s\ncolumns (z) must be the same as length (y)", msg);
+        error (msg);
       endif
     else
       error ("mesh: x and y must be vectors and z must be a matrix");
     endif    
   else
-    error ("usage: mesh (z)");
+    usage ("mesh (z)");
   endif
 
 endfunction
diff --git a/scripts/plot/meshdom.m b/scripts/plot/meshdom.m
--- a/scripts/plot/meshdom.m
+++ b/scripts/plot/meshdom.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -46,12 +46,12 @@ function [xx, yy] = meshdom (x, y)
       endfor
       for i = 1:xlen
         yy(:,i) = y;
       endfor
     else
       error ("meshdom: arguments must be vectors");
     endif
   else
-    error ("usage: [xx, yy] = meshdom (x, y)");
+    usage ("[xx, yy] = meshdom (x, y)");
   endif
 
 endfunction
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -48,14 +48,12 @@ function plot (x1, x2)
   set nologscale;
   set nopolar;
 
   if (nargin == 1)
     plot_int (x1);
   elseif (nargin == 2)
     plot_int (x1, x2);
   else
-    usage = sprintf ("usage: plot (x)\n");
-    usage = sprintf ("%s       plot (x, y)", usage);
-    error (usage);
+    usage ("plot (x [, y])");
   endif
 
 endfunction
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -28,14 +28,12 @@ function polar (x1, x2)
   set nologscale;
   set nopolar;
 
   if (nargin == 1)
     polar_int (x1);
   elseif (nargin == 2)
     polar_int (x1, x2);
   else
-    usage = sprintf ("usage: polar (x)\n");
-    usage = sprintf ("%s       polar (x, y)", usage);
-    error (usage);
+    usage ("polar (x [, y])");
   endif
 
 endfunction
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -32,14 +32,12 @@ function semilogx (x1, x2)
   set nologscale y;
   set nopolar;
 
   if (nargin == 1)
     plot_int (x1);
   elseif (nargin == 2)
     plot_int (x1, x2);
   else
-    usage = sprintf ("usage: semilogx (x)\n");
-    usage = sprintf ("%s       semilogx (x, y)", usage);
-    error (usage);
+    usage ("semilogx (x [, y])");
   endif
 
 endfunction
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -32,14 +32,12 @@ function semilogy (x1, x2)
   set logscale y;
   set nopolar;
 
   if (nargin == 1)
     plot_int (x1);
   elseif (nargin == 2)
     plot_int (x1, x2);
   else
-    usage = sprintf ("usage: semilogy (x)\n");
-    usage = sprintf ("%s       semilogy (x, y)", usage);
-    error (usage);
+    usage ("semilogy (x [, y])");
   endif
 
 endfunction
diff --git a/scripts/plot/sombrero.m b/scripts/plot/sombrero.m
--- a/scripts/plot/sombrero.m
+++ b/scripts/plot/sombrero.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -21,17 +21,17 @@ function sombrero (n)
 # usage: sombrero (n)
 #
 # Draw a `sombrero' in three dimensions using n grid lines.  The
 # function plotted is
 #
 #   z = sin (x^2 + y^2) / (x^2 + y^2);
 
   if (nargin != 1)
-    error ("usage: sombrero (n)");
+    usage ("sombrero (n)");
   endif
 
   x = y = linspace (-8, 8, n)';
   [xx, yy] = meshdom (x, y);
   r = sqrt (xx .^ 2 + yy .^ 2) + eps;
   z = sin (r) ./ r;
 
   mesh (x, y, z);
diff --git a/scripts/plot/stairs.m b/scripts/plot/stairs.m
--- a/scripts/plot/stairs.m
+++ b/scripts/plot/stairs.m
@@ -81,17 +81,17 @@ function [xs, ys] = stairs (x, y)
         tmp_ys(len) = y(ylen);
       else
         error ("stairs: arguments must be the same length");
       endif
     else
       error ("stairs: arguments must be vectors");
     endif
   else
-    error ("usage: [xs, ys] = stairs (x, y)");
+    usage ("[xs, ys] = stairs (x, y)");
   endif
 
   if (nargout == 0)
     plot (tmp_xs, tmp_ys);
   else
     xs = tmp_xs;
     ys = tmp_ys;
   endif
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -22,19 +22,19 @@ function title (text)
 #
 # Defines a title for a plot.  The title will appear the next time a
 # plot is displayed. 
 #
 # See also: plot, semilogx, semilogy, loglog, polar, mesh, contour,
 #           bar, stairs, gplot, gsplot, replot, xlabel, ylabel
 
   if (nargin != 1)
-    error ("usage: title (text)");
+    usage ("title (text)");
   endif
 
   if (isstr (text))
     command = sprintf ("set title \"%s\"", text);
     eval (command);
   else
-    error ("error: title: text must be a string");
+    error ("title: text must be a string");
   endif
 
 endfunction
diff --git a/scripts/plot/xlabel.m b/scripts/plot/xlabel.m
--- a/scripts/plot/xlabel.m
+++ b/scripts/plot/xlabel.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -22,19 +22,19 @@ function xlabel (text)
 #
 # Defines a label for the x-axis of a plot.  The label will appear the
 # next time a plot is displayed.
 #
 # See also: plot, semilogx, semilogy, loglog, polar, mesh, contour,
 #           bar, stairs, gplot, gsplot, replot, ylabel, title
 
   if (nargin != 1)
-    error ("usage: xlabel (text)");
+    usage ("xlabel (text)");
   endif
 
   if (isstr (text))
     command = sprintf ("set xlabel \"%s\"", text);
     eval (command);
   else
-    error ("error: xlabel: text must be a string");
+    error ("xlabel: text must be a string");
   endif
 
 endfunction
diff --git a/scripts/plot/ylabel.m b/scripts/plot/ylabel.m
--- a/scripts/plot/ylabel.m
+++ b/scripts/plot/ylabel.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -22,19 +22,19 @@ function ylabel (text)
 #
 # Defines a label for the y-axis of a plot.  The label will appear the
 # next time a plot is displayed.
 #
 # See also: plot, semilogx, semilogy, loglog, polar, mesh, contour,
 #           bar, stairs, gplot, gsplot, replot, xlabel, title
 
   if (nargin != 1)
-    error ("usage: ylabel (text)");
+    usage ("ylabel (text)");
   endif
 
   if (isstr (text))
     command = sprintf ("set ylabel \"%s\"", text);
     eval (command);
   else
-    error ("error: ylabel: text must be a string");
+    error ("ylabel: text must be a string");
   endif
 
 endfunction
diff --git a/scripts/polynomial/compan.m b/scripts/polynomial/compan.m
--- a/scripts/polynomial/compan.m
+++ b/scripts/polynomial/compan.m
@@ -1,40 +1,41 @@
 function A = compan(c)
-#compan (c)
-#Compute the companion matrix corresponding to polynomial vector c.
+
+# compan (c)
+# Compute the companion matrix corresponding to polynomial vector c.
 #
-#In octave a polynomial is represented by it's coefficients (arranged
-#in descending order). For example a vector c of length n+1 corresponds
-#to the following nth order polynomial
+# In octave a polynomial is represented by it's coefficients (arranged
+# in descending order). For example a vector c of length n+1 corresponds
+# to the following nth order polynomial
 #
-#  p(x) = c(1) x^n + ... + c(n) x + c(n+1).
+#   p(x) = c(1) x^n + ... + c(n) x + c(n+1).
 #
-#The corresponding companion matrix is
-#        _                                                        _
-#       |  -c(2)/c(1)   -c(3)/c(1)  ...  -c(n)/c(1)  -c(n+1)/c(1)  |
-#       |       1            0      ...       0             0      |
-#       |       0            1      ...       0             0      |
-#   A = |       .            .   .            .             .      |
-#       |       .            .       .        .             .      |
-#       |       .            .           .    .             .      |
-#       |_      0            0      ...       1             0     _|
+# The corresponding companion matrix is
+#         _                                                        _
+#        |  -c(2)/c(1)   -c(3)/c(1)  ...  -c(n)/c(1)  -c(n+1)/c(1)  |
+#        |       1            0      ...       0             0      |
+#        |       0            1      ...       0             0      |
+#    A = |       .            .   .            .             .      |
+#        |       .            .       .        .             .      |
+#        |       .            .           .    .             .      |
+#        |_      0            0      ...       1             0     _|
 #
-#The eigenvalues of the companion matrix are equal to the roots of the
-#polynomial.
+# The eigenvalues of the companion matrix are equal to the roots of the
+# polynomial.
 #
-#SEE ALSO: poly, roots, residue, conv, deconv, polyval, polyderiv, polyinteg
+# SEE ALSO: poly, roots, residue, conv, deconv, polyval, polyderiv, polyinteg
 
 # Author:
 #  Tony Richardson
 #  amr@mpl.ucsd.edu
 #  June 1994
 
   if(nargin != 1)
-    error("usage: compan(vector)");
+    usage ("compan(vector)");
   endif
 
   if(!is_vector(c))
     error("compan: expecting a vector argument.");
   endif
 
   # Ensure that c is a row vector.
   if(rows(c) > 1)
diff --git a/scripts/polynomial/conv.m b/scripts/polynomial/conv.m
--- a/scripts/polynomial/conv.m
+++ b/scripts/polynomial/conv.m
@@ -1,26 +1,25 @@
 function y = conv (a, b)
   
-  # Convolve two vectors.
-  # y = conv (a, b) returns a vector of length equal to length (a) +
-  # length (b) -1.
-  # If a and b are polynomial coefficient vectors, conv returns the
-  # coefficients of the product polynomial.
-  #
-  # SEE ALSO: deconv, poly, roots, residue, polyval, polyderiv,
-  # polyinteg 
+# Convolve two vectors.
+# y = conv (a, b) returns a vector of length equal to length (a) +
+# length (b) -1.
+# If a and b are polynomial coefficient vectors, conv returns the
+# coefficients of the product polynomial.
+#
+# SEE ALSO: deconv, poly, roots, residue, polyval, polyderiv, polyinteg 
 
-  # Author:
-  #  Tony Richardson
-  #  amr@mpl.ucsd.edu
-  #  June 1994
+# Author:
+#  Tony Richardson
+#  amr@mpl.ucsd.edu
+#  June 1994
 
   if (nargin != 2)
-    error ("usage:  conv(a,b)");
+    usage (" conv(a,b)");
   endif
 
   if (is_matrix(a) || is_matrix(b))
     error("conv: both arguments must be vectors");
   endif
 
   la = length (a);
   lb = length (b);
diff --git a/scripts/polynomial/deconv.m b/scripts/polynomial/deconv.m
--- a/scripts/polynomial/deconv.m
+++ b/scripts/polynomial/deconv.m
@@ -1,29 +1,29 @@
 function [b, r] = deconv (y, a)
 
-  # Deconvolve two vectors.
-  #
-  # [b, r] = deconv (y, a) solves for b and r such that 
-  #    y = conv(a,b) + r
-  #
-  # If y and a are polynomial coefficient vectors, b will contain the
-  # coefficients of the polynomial quotient and r will be a remander
-  # polynomial of lowest order.
-  #
-  # SEE ALSO: conv, poly, roots, residue, polyval, polyderiv,
-  # polyinteg 
+# Deconvolve two vectors.
+#
+# [b, r] = deconv (y, a) solves for b and r such that 
+#    y = conv(a,b) + r
+#
+# If y and a are polynomial coefficient vectors, b will contain the
+# coefficients of the polynomial quotient and r will be a remander
+# polynomial of lowest order.
+#
+# SEE ALSO: conv, poly, roots, residue, polyval, polyderiv,
+# polyinteg 
 
-  # Author:
-  #  Tony Richardson
-  #  amr@mpl.ucsd.edu
-  #  June 1994
+# Author:
+#  Tony Richardson
+#  amr@mpl.ucsd.edu
+#  June 1994
 
   if (nargin != 2)
-    error ("usage:  deconv (y,a)");
+    usage (" deconv (y,a)");
   endif
 
   if (is_matrix (y) || is_matrix (a))
     error("conv: both arguments must be vectors");
   endif
 
   la = length (a);
   ly = length (y);
diff --git a/scripts/polynomial/poly.m b/scripts/polynomial/poly.m
--- a/scripts/polynomial/poly.m
+++ b/scripts/polynomial/poly.m
@@ -1,29 +1,29 @@
 function y = poly (x)
-  #
-  # If A is a square n-by-n matrix, poly (A) is the row vector of 
-  # the coefficients of det (z * eye(n) - A), the characteristic
-  # polynomial of A.
-  # If x is a vector, poly (x) is a vector of coefficients of the
-  # polynomial whose roots are the elements of x.
 
-  # Written by KH (Kurt.Hornik@neuro.tuwien.ac.at) on Dec 24, 1993 
-  # Copyright Dept of Probability Theory and Statistics TU Wien
+# If A is a square n-by-n matrix, poly (A) is the row vector of 
+# the coefficients of det (z * eye(n) - A), the characteristic
+# polynomial of A.
+# If x is a vector, poly (x) is a vector of coefficients of the
+# polynomial whose roots are the elements of x.
+
+# Written by KH (Kurt.Hornik@neuro.tuwien.ac.at) on Dec 24, 1993 
+# Copyright Dept of Probability Theory and Statistics TU Wien
 
   m = min (size (x));
   n = max (size (x));
   if (m == 0)
     y = 1;
   elseif (m == 1)
     v = x;
   elseif (m == n)
     v = eig (x);
   else
-    error ("usage:  poly(x), where x is a vector or a square matrix");
+    usage ("poly(x), where x is a vector or a square matrix");
   endif
   
   y = [1, zeros (1, n)];
   for j = 1:n;
     y(2:(j+1)) = y(2:(j+1)) - v(j) .* y(1:j);
   endfor
   
   if (all (all (imag (x) == 0)))
diff --git a/scripts/polynomial/polyderiv.m b/scripts/polynomial/polyderiv.m
--- a/scripts/polynomial/polyderiv.m
+++ b/scripts/polynomial/polyderiv.m
@@ -1,23 +1,24 @@
 function p = polyderiv(p)
-#polyderiv(c)
-#Returns the coefficients of the derivative of the polynomial whose
-#coefficients are given by vector c.
+
+# polyderiv(c)
+# Returns the coefficients of the derivative of the polynomial whose
+# coefficients are given by vector c.
 #
-#SEE ALSO: poly, polyinteg, polyreduce, roots, conv, deconv, residue,
-#          filter, polyval, polyvalm
+# SEE ALSO: poly, polyinteg, polyreduce, roots, conv, deconv, residue,
+#           filter, polyval, polyvalm
 
 # Author:
 #  Tony Richardson
 #  amr@mpl.ucsd.edu
 #  June 1994
 
   if(nargin != 1)
-    error("usage: polyderiv(vector)");
+    usage ("polyderiv(vector)");
   endif
 
   if(is_matrix(p))
     error("argument must be a vector");
   endif
 
   lp = length(p);
   if(lp == 1)
diff --git a/scripts/polynomial/polyinteg.m b/scripts/polynomial/polyinteg.m
--- a/scripts/polynomial/polyinteg.m
+++ b/scripts/polynomial/polyinteg.m
@@ -1,25 +1,26 @@
 function p = polyinteg(p)
-#polyinteg(c)
-#Returns the coefficients of the integral the polynomial whose coefficients
-#are represented by the vector c.
+
+# polyinteg(c)
+# Returns the coefficients of the integral the polynomial whose coefficients
+# are represented by the vector c.
 #
-#The constant of integration is zero.
+# The constant of integration is zero.
 #
-#SEE ALSO: poly, polyderiv, polyreduce, roots, conv, deconv, residue,
-#          filter, polyval, polyvalm
+# SEE ALSO: poly, polyderiv, polyreduce, roots, conv, deconv, residue,
+#           filter, polyval, polyvalm
 
 # Author:
 #  Tony Richardson
 #  amr@mpl.ucsd.edu
 #  June 1994
 
   if(nargin != 1)
-    error("usage: polyinteg(vector)");
+    usage ("polyinteg(vector)");
   endif
 
   if(is_matrix(p))
     error("argument must be a vector");
   endif
 
   lp = length(p);
 
diff --git a/scripts/polynomial/polyreduce.m b/scripts/polynomial/polyreduce.m
--- a/scripts/polynomial/polyreduce.m
+++ b/scripts/polynomial/polyreduce.m
@@ -1,15 +1,16 @@
 function p = polyreduce(p)
-#polyreduce(c)
-#Reduces a polynomial coefficient vector to a minimum number of terms,
-#i.e. it strips off any leading zeros.
+
+# polyreduce(c)
+# Reduces a polynomial coefficient vector to a minimum number of terms,
+# i.e. it strips off any leading zeros.
 #
-#SEE ALSO: poly, roots, conv, deconv, residue, filter, polyval, polyvalm,
-#          polyderiv, polyinteg
+# SEE ALSO: poly, roots, conv, deconv, residue, filter, polyval, polyvalm,
+#           polyderiv, polyinteg
 
 # Author:
 #  Tony Richardson
 #  amr@mpl.ucsd.edu
 #  June 1994
 
   index = find(p==0);
 
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -1,32 +1,33 @@
 function y = polyval(c,x)
-#Evaluate a polynomial.
-#
-#In octave, a polynomial is represented by it's coefficients (arranged
-#in descending order). For example a vector c of length n+1 corresponds
-#to the following nth order polynomial
-#
-#  p(x) = c(1) x^n + ... + c(n) x + c(n+1).
-#
-#polyval(c,x) will evaluate the polynomial at the specified value of x.
-#
-#If x is a vector or matrix, the polynomial is evaluated at each of the
-#elements of x.
-#
-#SEE ALSO: polyvalm, poly, roots, conv, deconv, residue, filter,
-#          polyderiv, polyinteg
+
+# Evaluate a polynomial.
+# 
+# In octave, a polynomial is represented by it's coefficients (arranged
+# in descending order). For example a vector c of length n+1 corresponds
+# to the following nth order polynomial
+# 
+#   p(x) = c(1) x^n + ... + c(n) x + c(n+1).
+# 
+# polyval(c,x) will evaluate the polynomial at the specified value of x.
+# 
+# If x is a vector or matrix, the polynomial is evaluated at each of the
+# elements of x.
+# 
+# SEE ALSO: polyvalm, poly, roots, conv, deconv, residue, filter,
+#           polyderiv, polyinteg
 
 # Author:
 #  Tony Richardson
 #  amr@mpl.ucsd.edu
 #  June 1994
 
   if(nargin != 2)
-    error("usage: polyval(c,x)");
+    usage ("polyval(c,x)");
   endif
 
   if(is_matrix(c))
     error("poly: first argument must be a vector.");
   endif
 
   if(length(c) == 0)
     y = c;
diff --git a/scripts/polynomial/polyvalm.m b/scripts/polynomial/polyvalm.m
--- a/scripts/polynomial/polyvalm.m
+++ b/scripts/polynomial/polyvalm.m
@@ -1,33 +1,34 @@
 function y = polyvalm(c,x)
-#Evaluate a polynomial in the matrix sense.
+
+# Evaluate a polynomial in the matrix sense.
 #
-#In octave, a polynomial is represented by it's coefficients (arranged
-#in descending order). For example a vector c of length n+1 corresponds
-#to the following nth order polynomial
-#
-#  p(x) = c(1) x^n + ... + c(n) x + c(n+1).
+# In octave, a polynomial is represented by it's coefficients (arranged
+# in descending order). For example a vector c of length n+1 corresponds
+# to the following nth order polynomial
 #
-#polyvalm(c,X) will evaluate the polynomial in the matrix sense, i.e. matrix
-#multiplication is used instead of element by element multiplication as is
-#used in polyval.
+#   p(x) = c(1) x^n + ... + c(n) x + c(n+1).
 #
-#X must be a square matrix.
+# polyvalm(c,X) will evaluate the polynomial in the matrix sense, i.e. matrix
+# multiplication is used instead of element by element multiplication as is
+# used in polyval.
 #
-#SEE ALSO: polyval, poly, roots, conv, deconv, residue, filter,
-#          polyderiv, polyinteg
+# X must be a square matrix.
+#
+# SEE ALSO: polyval, poly, roots, conv, deconv, residue, filter,
+#           polyderiv, polyinteg
 
 # Author:
 #  Tony Richardson
 #  amr@mpl.ucsd.edu
 #  June 1994
 
   if(nargin != 2)
-    error("usage: polyvalm(c,x)");
+    usage ("polyvalm(c,x)");
   endif
 
   if(is_matrix(c))
     error("poly: first argument must be a vector.");
   endif
 
   if(!is_square(x))
     error("poly: second argument must be a square matrix.");
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -1,61 +1,62 @@
 function [r, p, k, e] = residue(b,a,toler)
-#[r p k e] = residue(b,a)
-#If b and a are vectors of polynomial coefficients, then residue
-#calculates the partial fraction expansion corresponding to the
-#ratio of the two polynomials. The vector r contains the residue
-#terms, p contains the pole values, k contains the coefficients of
-#a direct polynomial term (if it exists) and e is a vector containing
-#the powers of the denominators in the partial fraction terms.
-#Assuming b and a represent polynomials P(s) and Q(s) we have:
+
+# [r p k e] = residue(b,a)
+# If b and a are vectors of polynomial coefficients, then residue
+# calculates the partial fraction expansion corresponding to the
+# ratio of the two polynomials. The vector r contains the residue
+# terms, p contains the pole values, k contains the coefficients of
+# a direct polynomial term (if it exists) and e is a vector containing
+# the powers of the denominators in the partial fraction terms.
+# Assuming b and a represent polynomials P(s) and Q(s) we have:
 #
-# P(s)    M       r(m)         N
-# ---- =  #  -------------  +  # k(n)*s^(N-n)
-# Q(s)   m=1 (s-p(m))^e(m)    n=1
+#  P(s)    M       r(m)         N
+#  ---- =  #  -------------  +  # k(n)*s^(N-n)
+#  Q(s)   m=1 (s-p(m))^e(m)    n=1
 #
-#(# represents summation) where M is the number of poles (the length of
-#the r, p, and e vectors) and N is the length of the k vector.
+# (# represents summation) where M is the number of poles (the length of
+# the r, p, and e vectors) and N is the length of the k vector.
 #
-#[r p k e] = residue(b,a,tol)
-#This form of the function call may be used to set a tolerance value.
-#The default value is 0.001. The tolerance value is used to determine
-#whether poles with small imaginary components are declared real. It is
-#also used to determine if two poles are distinct. If the ratio of the
-#imaginary part of a pole to the real part is less than tol, the imaginary
-#part is discarded. If two poles are farther apart than tol they are
-#distinct.
+# [r p k e] = residue(b,a,tol)
+# This form of the function call may be used to set a tolerance value.
+# The default value is 0.001. The tolerance value is used to determine
+# whether poles with small imaginary components are declared real. It is
+# also used to determine if two poles are distinct. If the ratio of the
+# imaginary part of a pole to the real part is less than tol, the imaginary
+# part is discarded. If two poles are farther apart than tol they are
+# distinct.
 #
-#Example:
-# b = [1 1 1];
-# a = [1  -5   8  -4];
+# Example:
+#  b = [1 1 1];
+#  a = [1  -5   8  -4];
 #
-# [r p k e] = residue(b,a)
+#  [r p k e] = residue(b,a)
 #
-# returns
+#  returns
 #
-# r = [-2 7 3]; p = [2 2 1]; k = []; e = [1 2 1];
+#  r = [-2 7 3]; p = [2 2 1]; k = []; e = [1 2 1];
 #
-# which implies the following partial fraction expansion
+#  which implies the following partial fraction expansion
 #
-#       s^2 + s + 1         -2       7        3
-#   ------------------- = ----- + ------- + -----
-#   s^3 - 5s^2 + 8s - 4   (s-2)   (s-2)^2   (s-1)
+#        s^2 + s + 1         -2       7        3
+#    ------------------- = ----- + ------- + -----
+#    s^3 - 5s^2 + 8s - 4   (s-2)   (s-2)^2   (s-1)
 #
-#SEE ALSO: poly, roots, conv, deconv, polyval, polyderiv, polyinteg
+# SEE ALSO: poly, roots, conv, deconv, polyval, polyderiv, polyinteg
 
 # Author:
 #  Tony Richardson
 #  amr@mpl.ucsd.edu
 #  June 1994
 
 # Here's the method used to find the residues.
 # The partial fraction expansion can be written as:
 #
-#          
+#
 #   P(s)    D   M(k)      A(k,m)
 #   ---- =  #    #    -------------
 #   Q(s)   k=1  m=1   (s - pr(k))^m
 #
 # (# is used to represent a summation) where D is the number of
 # distinct roots, pr(k) is the kth distinct root, M(k) is the
 # multiplicity of the root, and A(k,m) is the residue cooresponding
 # to the kth distinct root with multiplicity m.  For example,
@@ -104,17 +105,17 @@ function [r, p, k, e] = residue(b,a,tole
 #
 # | 4|   | 1 0 0 |   | r(1) |
 # | 1| = | 0 0 1 | * | r(2) |
 # |-2|   | 0 1 1 |   | r(3) |
 #
 # We then solve for the residues using matrix division.
 
   if(nargin < 2 || nargin > 3)
-    error("usage: residue(b,a[,toler])");
+    usage ("residue(b,a[,toler])");
   endif
 
   if (nargin == 2)
     # Set the default tolerance level
     toler = .001;
   endif
 
   # Make sure both polynomials are in reduced form.
diff --git a/scripts/polynomial/roots.m b/scripts/polynomial/roots.m
--- a/scripts/polynomial/roots.m
+++ b/scripts/polynomial/roots.m
@@ -1,38 +1,39 @@
 function r = roots (v)
-  #
-  # For a vector v with n components, return the roots of the
-  # polynomial v(1) * z^(n-1) + ... + v(n-1) * z + v(n).
+
+# For a vector v with n components, return the roots of the
+# polynomial v(1) * z^(n-1) + ... + v(n-1) * z + v(n).
   
-  # Written by KH (Kurt.Hornik@neuro.tuwien.ac.at) on Dec 24, 1993
-  # Copyright Dept of Probability Theory and Statistics TU Wien
+# Written by KH (Kurt.Hornik@neuro.tuwien.ac.at) on Dec 24, 1993
+# Copyright Dept of Probability Theory and Statistics TU Wien
   
   [nr, nc] = size(v);
   if !((nr == 1 && nc > 1) || (nc == 1 && nr > 1))
-    error ("usage:  roots (v), where v is a nonzero vector");
+    usage ("roots (v), where v is a nonzero vector");
   endif
 
   n = nr + nc - 1;
   v = reshape (v, 1, n);
 
-  # If v = [ 0 ... 0 v(k+1) ... v(k+l) 0 ... 0 ], we can remove the
-  # leading k zeros and n - k - l roots of the polynomial are zero.  
+# If v = [ 0 ... 0 v(k+1) ... v(k+l) 0 ... 0 ], we can remove the
+# leading k zeros and n - k - l roots of the polynomial are zero.  
+
   f = find (v);
   m = max (size (f));
   if (m > 0)
     v = v(f(1):f(m));
     l = max (size (v));
     if (l > 1)
       A = diag (ones (1, l-2), -1);
       A(1,:) = -v(2:l) ./ v(1);
       r = eig (A);    
       if (f(m) < n)
 	r = [r; zeros (n - f(m), 1)];
       endif
     else
       r = zeros (n - f(m), 1);
     endif
   else
-    error ("usage:  roots(v), where v is a nonzero vector");
+    usage ("roots (v), where v is a nonzero vector");
   endif
   
 endfunction
diff --git a/scripts/set/complement.m b/scripts/set/complement.m
--- a/scripts/set/complement.m
+++ b/scripts/set/complement.m
@@ -1,31 +1,31 @@
-function y = complement(a,b)
+function y = complement (a, b)
 
-# usage: complement(a,b)
+# usage: complement (a, b)
 #
 # Returns the elements of set b that are not in set a.
 #
 # See - create_set, union, intersection
 
-  if(nargin != 2)
-    error("usage: complement(a,b)");
+  if (nargin != 2)
+    usage ("complement(a,b)");
   endif
 
-  if(isempty(a))
+  if (isempty (a))
     y = create_set(b);
-  elseif(isempty(b))
+  elseif (isempty (b))
     y = [];
   else
-    a = create_set(a);
-    b = create_set(b);
+    a = create_set (a);
+    b = create_set (b);
     yindex = 1;
-    y = zeros(1,length(b));
-    for index = 1:length(b)
-      if(all(a != b(index)))
+    y = zeros (1, length (b));
+    for index = 1:length (b)
+      if (all (a != b (index)))
         y(yindex++) = b(index);
       endif
     endfor
     y = y(1:(yindex-1));
   endif
 
 endfunction
 
diff --git a/scripts/set/create_set.m b/scripts/set/create_set.m
--- a/scripts/set/create_set.m
+++ b/scripts/set/create_set.m
@@ -2,17 +2,17 @@ function y = create_set(x)
 
 # usage: create_set(x)
 #
 # Returns the unique elements of x, sorted in ascending order.
 #
 # See - union, intersection, complement
 
   if ( nargin != 1)
-    error("usage: create_set(x)");
+    usage ("create_set(x)");
   endif
 
   if(isempty(x))
     y = [];
   else
     [nrx, ncx] = size(x);
     nelx = nrx*ncx;
     x = reshape(x,1,nelx);
diff --git a/scripts/set/intersection.m b/scripts/set/intersection.m
--- a/scripts/set/intersection.m
+++ b/scripts/set/intersection.m
@@ -2,17 +2,17 @@ function y = intersection(a,b)
 
 # usage: intersection(a,b)
 #
 # Returns the intersection of sets a and b.
 #
 # See - create_set, union, complement
 
   if (nargin != 2)
-    error("usage: intersection(a,b)");
+    usage ("intersection(a,b)");
   endif
 
   if(isempty(a) || isempty(b))
     y = [];
     return;
   endif
 
   a = create_set(a);
diff --git a/scripts/set/union.m b/scripts/set/union.m
--- a/scripts/set/union.m
+++ b/scripts/set/union.m
@@ -2,17 +2,17 @@ function y = union(a,b)
 
 # usage: union(a,b)
 #
 # Returns the union of sets a and b.
 #
 # See - create_set, intersection, complement
 
   if (nargin != 2)
-    error("usage: union(a,b)");
+    usage ("union(a,b)");
   endif
 
   if(isempty(a))
     y = create_set(b);
   elseif(isempty(b))
     y = create_set(a);
   else
     [nra, nca] = size(a);
diff --git a/scripts/signal/fftconv.m b/scripts/signal/fftconv.m
--- a/scripts/signal/fftconv.m
+++ b/scripts/signal/fftconv.m
@@ -1,25 +1,25 @@
 function c = fftconv (a, b, N)
 
-  # usage:  fftconv (a, b [, N])
-  #
-  # c = fftconv (a, b) returns the convolution of the vectors a and b,
-  # a vector with length equal to length (a) + length (b) - 1.  
-  # If a and b are the coefficient vectors of two polynomials, c is
-  # the coefficient vector of the product polynomial.
-  #
-  # The computation uses the FFT by calling fftfilt.  If the optional
-  # argument N is specified, an N-point FFT is used.
+# usage:  fftconv (a, b [, N])
+#
+# c = fftconv (a, b) returns the convolution of the vectors a and b,
+# a vector with length equal to length (a) + length (b) - 1.  
+# If a and b are the coefficient vectors of two polynomials, c is
+# the coefficient vector of the product polynomial.
+#
+# The computation uses the FFT by calling fftfilt.  If the optional
+# argument N is specified, an N-point FFT is used.
 
-  # Written by KH (Kurt.Hornik@ci.tuwien.ac.at) on Sep 3, 1994
-  # Copyright Dept of Statistics and Probability Theory TU Wien
+# Written by KH (Kurt.Hornik@ci.tuwien.ac.at) on Sep 3, 1994
+# Copyright Dept of Statistics and Probability Theory TU Wien
   
   if (nargin < 2 || nargin > 3)
-    error ("usage:  fftconv (b, x [, N])");
+    usage (" fftconv (b, x [, N])");
   endif
   
   if (is_matrix (a) || is_matrix (b))
     error ("fftconv:  both a and b should be vectors");
   endif
   la = length (a);
   lb = length (b);
   if ((la == 1) || (lb == 1))
diff --git a/scripts/signal/fftfilt.m b/scripts/signal/fftfilt.m
--- a/scripts/signal/fftfilt.m
+++ b/scripts/signal/fftfilt.m
@@ -1,30 +1,30 @@
 function y = fftfilt (b, x, N)
 
-  # usage:  fftfilt (b, x [, N])
-  #
-  # y = fftfilt (b, x) filters x with the FIR filter b using the FFT.
-  # y = fftfilt (b, x, N) uses the overlap-add method to filter x with
-  # b using an N-point FFT.
+# usage:  fftfilt (b, x [, N])
+#
+# y = fftfilt (b, x) filters x with the FIR filter b using the FFT.
+# y = fftfilt (b, x, N) uses the overlap-add method to filter x with
+# b using an N-point FFT.
 
-  # Written by KH (Kurt.Hornik@ci.tuwien.ac.at) on Sep 3, 1994
-  # Copyright Dept of Statistics and Probability Theory TU Wien
+# Written by KH (Kurt.Hornik@ci.tuwien.ac.at) on Sep 3, 1994
+# Copyright Dept of Statistics and Probability Theory TU Wien
 
-  # Reference:  Oppenheim & Schafer (1989).  Discrete-time Signal
-  # Processing (Chapter 8).  Prentice-Hall.
-  
-  # If N is not specified explicitly, we do not use the overlap-add 
-  # method at all because loops are really slow.  Otherwise, we only
-  # ensure that the number of points in the FFT is the smallest power
-  # of two larger than N and length(b).  This could result in length
-  # one blocks, but if the user knows better ...
+# Reference:  Oppenheim & Schafer (1989).  Discrete-time Signal
+# Processing (Chapter 8).  Prentice-Hall.
+
+# If N is not specified explicitly, we do not use the overlap-add 
+# method at all because loops are really slow.  Otherwise, we only
+# ensure that the number of points in the FFT is the smallest power
+# of two larger than N and length(b).  This could result in length
+# one blocks, but if the user knows better ...
   
   if (nargin < 2 || nargin > 3)
-    error ("usage:  fftfilt (b, x [, N])");
+    usage (" fftfilt (b, x [, N])");
   endif
   
   [r_x, c_x] = size (x);
   [r_b, c_b] = size (b);
   if !( (min ([r_x c_x]) == 1) || (min ([r_b c_b]) == 1) )
     error ("fftfilt:  both x and b should be vectors.");
   endif
   l_x  = r_x * c_x;
diff --git a/scripts/signal/filter.m b/scripts/signal/filter.m
--- a/scripts/signal/filter.m
+++ b/scripts/signal/filter.m
@@ -1,53 +1,51 @@
 function [y, w] = filter(b,a,x,w)
-#Filter a vector.
-#y = filter(b,a,x) returns the solution to the following linear,
-#time-invariant difference equation:
-#
-#   N                   M
-#  sum a(k+1) y(n-k) + sum b(k+1) x(n-k) = 0  for 1<=n<=length(x)
-#  k=0                 k=0
-#
-#where N=length(a)-1 and M=length(b)-1. An equivalent form of this
-#equation is:
-#
-#          N                   M
-#  y(n) = sum c(k+1) y(n-k) + sum d(k+1) x(n-k)  for 1<=n<=length(x)
-#         k=1                 k=0
-#
-#where c = a/a(1) and d = b/a(1).
-#
-#In terms of the z-transform, y is the result of passing the discrete-
-#time signal x through a system characterized by the following rational
-#system function:
-#
-#             M
-#            sum d(k+1) z^(-k)
-#            k=0
-#  H(z) = ----------------------
-#               N
-#          1 + sum c(k+1) z(-k)
-#              k=1
-#
-#[y, sf] = filter(b,a,x,si) sets the initial state of the system, si,
-#and returns the final state, sf.  The state vector is a column vector
-#whose length is equal to the length of the longest coefficient vector
-#minus one.  If si is not set, the initial state vector is set to all
-#zeros.
-#
-#The particular algorithm employed is known as a transposed Direct
-#Form II implementation.
-#
-#SEE ALSO: poly, roots, conv, deconv, residue, polyval, polyderiv, polyinteg
 
-# Author:
-#  Tony Richardson
-#  amr@mpl.ucsd.edu
-#  June 1994
+# Filter a vector.
+# y = filter(b,a,x) returns the solution to the following linear,
+# time-invariant difference equation:
+# 
+#    N                   M
+#   sum a(k+1) y(n-k) + sum b(k+1) x(n-k) = 0  for 1<=n<=length(x)
+#   k=0                 k=0
+# 
+# where N=length(a)-1 and M=length(b)-1. An equivalent form of this
+# equation is:
+# 
+#           N                   M
+#   y(n) = sum c(k+1) y(n-k) + sum d(k+1) x(n-k)  for 1<=n<=length(x)
+#          k=1                 k=0				     
+# 				  
+# where c = a/a(1) and d = b/a(1).
+# 
+# In terms of the z-transform, y is the result of passing the discrete-
+# time signal x through a system characterized by the following rational
+# system function:							
+# 									
+#              M
+#             sum d(k+1) z^(-k)
+#             k=0	       
+#   H(z) = ----------------------
+#                N
+#           1 + sum c(k+1) z(-k)
+#               k=1
+# 
+# [y, sf] = filter(b,a,x,si) sets the initial state of the system, si,
+# and returns the final state, sf.  The state vector is a column vector
+# whose length is equal to the length of the longest coefficient vector
+# minus one.  If si is not set, the initial state vector is set to all
+# zeros.
+# 
+# The particular algorithm employed is known as a transposed Direct
+# Form II implementation.
+# 
+# SEE ALSO: poly, roots, conv, deconv, residue, polyval, polyderiv, polyinteg
+
+# Written by Tony Richardson <amr@mpl.ucsd.edu> June 1994.
 
 # Bug fix by FL (Friedrich.Leisch@ci.tuwien.ac.at) on Oct 12, 1994
 
   if(nargin < 3 || nargin > 4)
     error("usage: [y, sf] = filter(b,a,x[,si])");
   endif
 
   if(is_matrix(a) || is_matrix(b) || is_matrix(x))
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -1,26 +1,27 @@
 function [h, w] = freqz(b,...)
-#Compute the frequency response of a filter.
+
+# Compute the frequency response of a filter.
 #
-#[h,w] = resp(b)
-#  returns the complex frequency response h of the FIR filter with
-#  coefficients b. The response is evaluated at 512 angular frequencies
-#  between 0 and pi.  w is a vector containing the 512 frequencies.
+# [h,w] = resp(b)
+#   returns the complex frequency response h of the FIR filter with
+#   coefficients b. The response is evaluated at 512 angular frequencies
+#   between 0 and pi.  w is a vector containing the 512 frequencies.
 #
-#[h,w] = resp(b,a)
-#  returns the complex frequency response of the rational IIR filter
-#  whose numerator has coefficients b and denominator coefficients a.
+# [h,w] = resp(b,a)
+#   returns the complex frequency response of the rational IIR filter
+#   whose numerator has coefficients b and denominator coefficients a.
 #
-#[h,w] = resp(b,a,n)
-#  returns the response evaluated at n angular frequencies.  For fastest
-#  computation n should factor into a small number of small primes.
+# [h,w] = resp(b,a,n)
+#   returns the response evaluated at n angular frequencies.  For fastest
+#   computation n should factor into a small number of small primes.
 #
-#[h,w] = freqz(b,a,n,"whole")
-#  evaluates the response at n frequencies between 0 and 2*pi.
+# [h,w] = freqz(b,a,n,"whole")
+#   evaluates the response at n frequencies between 0 and 2*pi.
 
   if (nargin == 1)
     # Response of an FIR filter.
     a = 1;
     n = 512;
     region = "half";
   elseif (nargin == 2)
     # Response of an IIR filter
diff --git a/scripts/signal/sinc.m b/scripts/signal/sinc.m
--- a/scripts/signal/sinc.m
+++ b/scripts/signal/sinc.m
@@ -1,30 +1,29 @@
-function result = sinc(x)
+function result = sinc (x)
 
 # usage: sinc(x)
 #
 #        Returns sin(pi*x)/(pi*x).
-#
 
 # We either need to set the do_fortran_indexing variable to "true"
 # or use reshape to convert the input matrix to a vector, so that
 # we can use find to determine the elements of x that equal zero.
 # I prefer reshaping.
 
   [nr, nc] = size(x);
 
   nels = nr*nc;
 
   x = reshape(x,nels,1);
 
-  # Set result to all ones initially.
+# Set result to all ones initially.
   result = ones(nels,1);
 
-  # Find non-zero elements in the input matrix.
+# Find non-zero elements in the input matrix.
   i = find(x);
 
   if (!isempty(i))
     result(i) = sin(pi*x(i))./(pi*x(i));
   endif
 
   result = reshape(result,nr,nc);
 
diff --git a/scripts/specfun/beta.m b/scripts/specfun/beta.m
--- a/scripts/specfun/beta.m
+++ b/scripts/specfun/beta.m
@@ -1,15 +1,15 @@
 function retval = beta(a, b)
   
-  # usage:  beta(a, b)
-  #
-  # Returns the beta function beta(a,b) = gamma(a) * gamma(b) / gamma(a+b)
-  # of a and b.
+# usage:  beta(a, b)
+#
+# Returns the beta function beta(a,b) = gamma(a) * gamma(b) / gamma(a+b)
+# of a and b.
 
-  # Written by KH (Kurt.Hornik@ci.tuwien.ac.at) on Jun 13, 1993
-  # Updated by KH (Kurt.Hornik@ci.tuwien.ac.at) on Aug 13, 1994
-  # Copyright Dept of Probability Theory and Statistics TU Wien
+# Written by KH (Kurt.Hornik@ci.tuwien.ac.at) on Jun 13, 1993
+# Updated by KH (Kurt.Hornik@ci.tuwien.ac.at) on Aug 13, 1994
+# Copyright Dept of Probability Theory and Statistics TU Wien
 
   retval = exp(lgamma(a) + lgamma(b) - lgamma(a+b));
 
 endfunction
 
diff --git a/scripts/specfun/betai.m b/scripts/specfun/betai.m
--- a/scripts/specfun/betai.m
+++ b/scripts/specfun/betai.m
@@ -1,39 +1,39 @@
 function y = betai(a, b, x)
   
-  # usage:  betai(a, b, x)
-  #
-  # Returns the incomplete beta function
-  #   betai (a, b, x) = BETA(a,b)^(-1) INT_0^x t^(a-1) (1-t)^(b-1) dt.
-  # If x has more than one component, both a and b must be scalars.
-  # If x is a scalar, a and b must be of compatible dimensions.
+# usage:  betai(a, b, x)
+#
+# Returns the incomplete beta function
+#   betai (a, b, x) = BETA(a,b)^(-1) INT_0^x t^(a-1) (1-t)^(b-1) dt.
+# If x has more than one component, both a and b must be scalars.
+# If x is a scalar, a and b must be of compatible dimensions.
   
-  # Written by KH (Kurt.Hornik@ci.tuwien.ac.at) on Aug 2, 1994.
-  # Copyright Dept of Probability Theory and Statistics TU Wien.
+# Written by KH (Kurt.Hornik@ci.tuwien.ac.at) on Aug 2, 1994.
+# Copyright Dept of Probability Theory and Statistics TU Wien.
 
-  # Computation is based on the series expansion
-  #   betai(a, b, x) 
-  #     = \frac{1}{B(a, b)} x^a 
-  #         \sum_{k=0}^\infty \frac{(1-b)\cdots(k-b)}{a+k} \frac{x^k}{k!}
-  # for x <= 1/2.  For x > 1/2, betai(a, b, x) = 1 - betai(b, a, 1-x).
+# Computation is based on the series expansion
+#   betai(a, b, x) 
+#     = \frac{1}{B(a, b)} x^a 
+#         \sum_{k=0}^\infty \frac{(1-b)\cdots(k-b)}{a+k} \frac{x^k}{k!}
+# for x <= 1/2.  For x > 1/2, betai(a, b, x) = 1 - betai(b, a, 1-x).
 
   if (nargin <> 3)
-    error("usage:  betai (a, b, x)");
+    usage (" betai (a, b, x)");
   endif
 
   if !((a > 0) && (b > 0))
     error("betai:  a and b must both be positive.");
   endif
   [nr, nc] = size(x);
   if (min([nr nc]) == 0)
-    error("betai:  x must not be empty.");
+    error ("betai:  x must not be empty.");
   endif
   if (any(x < 0) || any(x > 1))
-    error("betai:  all entries of x must be in [0,1].");
+    error ("betai:  all entries of x must be in [0,1].");
   endif
 
   if ((nr > 1) || (nc > 1))
     
     if !(is_scalar(a) && is_scalar(b))
       error("betai:  if x is not a scalar, a and b must be scalars.");
     endif
 
diff --git a/scripts/specfun/gammai.m b/scripts/specfun/gammai.m
--- a/scripts/specfun/gammai.m
+++ b/scripts/specfun/gammai.m
@@ -1,25 +1,25 @@
 function y = gammai(a, x)
   
-  # usage:  gammai(a, x)
-  #
-  # Computes the incomplete gamma function
-  #    gammai(a, x) 
-  #      = (integral from 0 to x of exp(-t) t^(a-1) dt) / gamma(a).
-  # If a is scalar, then gammai(a, x) is returned for each element of x
-  # and vice versa.
-  # If neither a nor x is scalar, the sizes of a and x must agree, and
-  # gammai is applied pointwise.
+# usage:  gammai(a, x)
+#
+# Computes the incomplete gamma function
+#    gammai(a, x) 
+#      = (integral from 0 to x of exp(-t) t^(a-1) dt) / gamma(a).
+# If a is scalar, then gammai(a, x) is returned for each element of x
+# and vice versa.
+# If neither a nor x is scalar, the sizes of a and x must agree, and
+# gammai is applied pointwise.
   
-  # Written by KH (Kurt.Hornik@ci.tuwien.ac.at) on Aug 13, 1994
-  # Copyright Dept of Probability Theory and Statistics TU Wien
+# Written by KH (Kurt.Hornik@ci.tuwien.ac.at) on Aug 13, 1994
+# Copyright Dept of Probability Theory and Statistics TU Wien
 
   if (nargin != 2)
-    error("usage:  gammai(a, x)");
+    usage (" gammai(a, x)");
   endif
   
   [r_a, c_a] = size(a);
   [r_x, c_x] = size(x);
   e_a = r_a * c_a;
   e_x = r_x * c_x;
   
   # The following code is rather ugly.  We want the function to work
@@ -48,40 +48,42 @@ function y = gammai(a, x)
     r_y = r_a;
     c_y = c_a;
   else
     error("gammai:  a and x must have the same size if neither is scalar"); 
   endif
 
   # Now we can do sanity checking ...
   
-  if (any(a <= 0) || any(a == Inf))
-    error("gammai:  all entries of a must be positive anf finite");
+  if (any (a <= 0) || any (a == Inf))
+    error ("gammai:  all entries of a must be positive anf finite");
   endif
-  if any(x < 0)
-    error("gammai:  all entries of x must be nonnegative");
+  if (any (x < 0))
+    error ("gammai:  all entries of x must be nonnegative");
   endif
   
   y = zeros(1, n);
 
-  # For x < a + 1, use summation.  The below choice of k should ensure
-  # that the overall error is less than eps ... 
+# For x < a + 1, use summation.  The below choice of k should ensure
+# that the overall error is less than eps ... 
+
   S = find((x > 0) & (x < a + 1));
   s = length(S);
   if (s > 0)
     k   = ceil(- max([a(S), x(S)]) * log(eps));
     K   = (1:k)';
     M   = ones(k, 1);
     A   = cumprod((M * x(S)) ./ (M * a(S) + K * ones(1, s)));
     y(S) = exp(-x(S) + a(S) .* log(x(S))) .* (1 + sum(A)) ./ gamma(a(S)+1);
   endif
 
-  # For x >= a + 1, use the continued fraction.
-  # Note, however, that this converges MUCH slower than the series
-  # expansion for small a and x not too large!
+# For x >= a + 1, use the continued fraction.
+# Note, however, that this converges MUCH slower than the series
+# expansion for small a and x not too large!
+
   S = find((x >= a + 1) & (x < Inf));
   s = length(S);
   if (s > 0)
     u   = [zeros(1, s); ones(1, s)];
     v   = [ones(1, s); x(S)];
     c_old = 0;
     c_new = v(1,:) ./ v(2,:);
     n   = 1;
diff --git a/scripts/special-matrix/hadamard.m b/scripts/special-matrix/hadamard.m
--- a/scripts/special-matrix/hadamard.m
+++ b/scripts/special-matrix/hadamard.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -20,17 +20,17 @@ function retval = hadamard (k)
 
 # usage: hadamard (k)
 #
 # Return the Hadamard matrix of order n = 2^k.
 #
 # See also: hankel, vander, hilb, invhilb, toeplitz
 
   if (nargin != 1)
-    error ("usage: hadamard (n)");
+    usage ("hadamard (n)");
   endif
 
   if (k < 1)
     retval = 1;
   else
     tmp = hadamard (k-1);
     retval = [tmp, tmp; tmp, -tmp];
   endif
diff --git a/scripts/special-matrix/hankel.m b/scripts/special-matrix/hankel.m
--- a/scripts/special-matrix/hankel.m
+++ b/scripts/special-matrix/hankel.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -27,17 +27,17 @@ function retval = hankel (c, r)
 # same as the first column.  If the last element of c is not the same
 # as the first element of r, the last element of c is used.
 #
 # See also: vander, hadamard, hilb, invhilb, toeplitz
 
   if (nargin == 1)
     r = c;
   elseif (nargin != 2)
-    error ("usage: hankel (c, r)");
+    usage ("hankel (c, r)");
   endif
 
   [c_nr, c_nc] = size (c);
   [r_nr, r_nc] = size (r);
 
   if ((c_nr != 1 && c_nc != 1) || (r_nr != 1 && r_nc != 1))
     error ("hankel: expecting vector arguments")
   endif
@@ -46,17 +46,17 @@ function retval = hankel (c, r)
     c = c';
   endif
 
   if (r_nr != 1)
     r = r';
   endif
 
   if (r (1) != c (1))
-    disp ("Column wins anti-diagonal conflict");
+    warning ("hankel: column wins anti-diagonal conflict");
   endif
 
 # This should probably be done with the colon operator...
 
   nc = length (r);
   nr = length (c);
 
   retval = zeros (nr, nc);
diff --git a/scripts/special-matrix/hilb.m b/scripts/special-matrix/hilb.m
--- a/scripts/special-matrix/hilb.m
+++ b/scripts/special-matrix/hilb.m
@@ -24,17 +24,17 @@ function retval = hilb (n)
 # matrix is defined as
 #
 #  H (i, j) = 1 / (i + j - 1);
 #
 # See also: hankel, vander, hadamard, invhilb, toeplitz
 
 
   if (nargin != 1)
-    error ("usage: hilb (n)");
+    usage ("hilb (n)");
   endif
 
   nmax = length (n);
   if (nmax == 1)
     retval = zeros (n);
     tmp = 1:n;
     for i = 1:n
       retval (i, :) = 1.0 ./ (tmp + (i - 1));
diff --git a/scripts/special-matrix/invhilb.m b/scripts/special-matrix/invhilb.m
--- a/scripts/special-matrix/invhilb.m
+++ b/scripts/special-matrix/invhilb.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -21,17 +21,17 @@ function retval = invhilb (n)
 # usage: invhilb (n)
 #
 # Return the inverse of a Hilbert matrix of order n.  This is slow but
 # exact.  Compare with inv (hilb (n)).
 #
 # See also: hankel, vander, hadamard, hilb, toeplitz
 
   if (nargin != 1)
-    error ("usage: invhilb (n)");
+    usage ("invhilb (n)");
   endif
 
   nmax = length (n);
   if (nmax == 1)
     retval = zeros (n);
     for l = 1:n
       for k = l:n
         tmp = 1;
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -27,17 +27,17 @@ function retval = toeplitz (c, r)
 # same as the first column.  If the first element of c is not the same
 # as the first element of r, the first element of c is used.
 #
 # See also: hankel, vander, hadamard, hilb, invhib
 
   if (nargin == 1)
     r = c;
   elseif (nargin != 2)
-    error ("usage: toeplitz (c, r)");
+    usage ("toeplitz (c, r)");
   endif
 
   [c_nr, c_nc] = size (c);
   [r_nr, r_nc] = size (r);
 
   if ((c_nr != 1 && c_nc != 1) || (r_nr != 1 && r_nc != 1))
     error ("toeplitz: expecting vector arguments")
   endif
@@ -46,17 +46,17 @@ function retval = toeplitz (c, r)
     c = c';
   endif
 
   if (r_nr != 1)
     r = r';
   endif
 
   if (r (1) != c (1))
-    disp ("Column wins diagonal conflict");
+    warning ("toeplitz: column wins diagonal conflict");
   endif
 
 # This should probably be done with the colon operator...
 
   nc = length (r);
   nr = length (c);
 
   retval = zeros (nr, nc);
diff --git a/scripts/special-matrix/vander.m b/scripts/special-matrix/vander.m
--- a/scripts/special-matrix/vander.m
+++ b/scripts/special-matrix/vander.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -20,17 +20,17 @@ function retval = vander (c)
 
 # usage: vander (c)
 #
 # Return the Vandermonde matrix whose next to last column is c.
 #
 # See also: hankel, hadamard, hilb, invhilb, toeplitz
 
   if (nargin != 1)
-    error ("usage: vander (c)");
+    usage ("vander (c)");
   endif
 
   nr = rows (c);
   nc = columns (c);
   if (nr == 1 && nc == 1)
     retval = 1;
   elseif (nr == 1 || nc == 1)
     n = length (c);
diff --git a/scripts/statistics/corrcoef.m b/scripts/statistics/corrcoef.m
--- a/scripts/statistics/corrcoef.m
+++ b/scripts/statistics/corrcoef.m
@@ -24,17 +24,17 @@ function retval = corrcoef (X, Y)
 # the (i,j)-th entry of corrcoef(X, Y) is the correlation between the
 # i-th variable in X and the j-th variable in Y.
 # corrcoef(X) is corrcoef(X, X).
 
 # Written by Kurt Hornik (hornik@ci.tuwien.ac.at) March 1993.
 # Dept of Probability Theory and Statistics TU Wien, Austria.
 
   if (nargin < 1 || nargin > 2)
-    error ("usage: corrcoef (X [, Y])");
+    usage ("corrcoef (X [, Y])");
   endif
 
   if (nargin == 2)
     C = cov (X, Y);
     S = std (X)' * std (Y);
     retval = C ./ S;
   elseif (nargin == 1)
     C = cov (X);
diff --git a/scripts/statistics/cov.m b/scripts/statistics/cov.m
--- a/scripts/statistics/cov.m
+++ b/scripts/statistics/cov.m
@@ -24,17 +24,17 @@ function retval = cov (X, Y)
 # variable, the (i,j)-th entry of cov(X, Y) is the covariance
 # between the i-th variable in X and the j-th variable in Y.
 # cov(X) is cov(X, X).
 
 # Written by Kurt Hornik (hornik@ci.tuwien.ac.at) March 1993.
 # Dept of Probability Theory and Statistics TU Wien, Austria.
 
   if (nargin < 1 || nargin > 2)
-    error ("usage: cov (X [, Y])");
+    usage ("cov (X [, Y])");
   endif
 
   [Tx, kx] = size (X);
   if (nargin == 2)
     [Ty, ky] = size (Y);
     if (Tx != Ty)
       error ("cov: X and Y must have the same number of rows.");
     endif
diff --git a/scripts/statistics/gls.m b/scripts/statistics/gls.m
--- a/scripts/statistics/gls.m
+++ b/scripts/statistics/gls.m
@@ -33,17 +33,17 @@ function [BETA, v, R] = gls (Y, X, O)
 # BETA is the GLS estimator for B.
 # v is the GLS estimator for s^2.
 # R = Y - X*BETA is the matrix of GLS residuals.
 
 # Written by Teresa Twaroch (twaroch@ci.tuwien.ac.at) May 1993.
 # Dept of Probability Theory and Statistics TU Wien, Austria.
 
   if (nargin != 3)
-    error ("usage: [BETA, v [, R]] = gls (Y, X, O)");
+    usage ("[BETA, v [, R]] = gls (Y, X, O)");
   endif
 
   [rx, cx] = size (X);
   [ry, cy] = size (Y);
   if (rx != ry)
     error ("gls: incorrect matrix dimensions");  
   endif
 
diff --git a/scripts/statistics/kurtosis.m b/scripts/statistics/kurtosis.m
--- a/scripts/statistics/kurtosis.m
+++ b/scripts/statistics/kurtosis.m
@@ -28,17 +28,17 @@ function retval = kurtosis (x)
 #
 # If x is a matrix, return a row vector containing the kurtosis for each
 # column.
 
 # Written by KH (Kurt.Hornik@ci.tuwien.ac.at) on Jul 29, 1994.
 # Copyright Dept of Probability Theory and Statistics TU Wien, Austria.
 
   if (nargin != 1)
-    error ("usage: kurtosis (x)");
+    usage ("kurtosis (x)");
   endif
 
   if (is_vector (x))
     x = x - mean (x);
     if (! any (x))
       retval = 0;
     else
       retval = sum (x .^ 4) / (length (x) * std (x) ^ 4) - 3;
diff --git a/scripts/statistics/mahalanobis.m b/scripts/statistics/mahalanobis.m
--- a/scripts/statistics/mahalanobis.m
+++ b/scripts/statistics/mahalanobis.m
@@ -23,17 +23,17 @@ function retval = mahalanobis (X, Y)
 # Returns Mahalanobis' D-square distance between the multivariate
 # samples X and Y, which must have the same number of components
 # (columns), but may have a different number of observations (rows).
 
 # Written by Friedrich Leisch (leisch@ci.tuwien.ac.at) July 1993.
 # Dept of Probability Theory and Statistics TU Wien, Austria.
 
   if (nargin != 2)
-    error ("usage: mahalanobis (X, Y)");
+    usage ("mahalanobis (X, Y)");
   endif
 
   [xr, xc] = size (X);
   [yr, yc] = size (Y);
 
   if (xc != yc)
     error ("mahalanobis: X and Y must have the same number of columns.");
   endif
diff --git a/scripts/statistics/mean.m b/scripts/statistics/mean.m
--- a/scripts/statistics/mean.m
+++ b/scripts/statistics/mean.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -23,17 +23,17 @@ function retval = mean (a)
 # For vector arguments, return the mean the values.
 #
 # For matrix arguments, return a row vector containing the mean for
 # each column.
 #
 # See also: median, std
 
   if (nargin != 1)
-    error ("usage: mean (a)");
+    usage ("mean (a)");
   endif
 
   [nr, nc] = size (a);
   if (nr == 1 || nc == 1)
     retval = sum (a) / length (a);
   elseif (nr > 0 && nc > 0)
     retval = sum (a) / nr;
   else
diff --git a/scripts/statistics/median.m b/scripts/statistics/median.m
--- a/scripts/statistics/median.m
+++ b/scripts/statistics/median.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -23,17 +23,17 @@ function retval = median (a)
 # For vector arguments, return the median of the values.
 #
 # For matrix arguments, return a row vector containing the median for
 # each column.
 #
 # See also: std, mean
 
   if (nargin != 1)
-    error ("usage: medain (a)");
+    usage ("medain (a)");
   endif
 
   [nr, nc] = size (a);
   s = sort (a);
   if (nr == 1 && nc > 0)
     if (rem (nc, 2) == 0)
       i = nc/2;
       retval = (s (i) + s (i+1)) / 2;
diff --git a/scripts/statistics/skewness.m b/scripts/statistics/skewness.m
--- a/scripts/statistics/skewness.m
+++ b/scripts/statistics/skewness.m
@@ -28,17 +28,17 @@ function retval = skewness (x)
 #
 # If x is a matrix, return a row vector containing the skewness for each
 # column.
 
 # Written by KH (Kurt.Hornik@ci.tuwien.ac.at) on Jul 29, 1994.
 # Copyright Dept of Probability Theory and Statistics TU Wien, Austria.
 
   if (nargin != 1)
-    error ("usage: skewness (x)");
+    usage ("skewness (x)");
   endif
 
   if (is_vector (x))
     x = x - mean (x);
     if (! any (x))
       retval = 0;
     else
       retval = sum (x .^ 3) / (length (x) * std (x) ^ 3);
diff --git a/scripts/statistics/std.m b/scripts/statistics/std.m
--- a/scripts/statistics/std.m
+++ b/scripts/statistics/std.m
@@ -1,9 +1,9 @@
-# Copyright (C) 1993 John W. Eaton
+# Copyright (C) 1993, 1994 John W. Eaton
 # 
 # This file is part of Octave.
 # 
 # Octave is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by the
 # Free Software Foundation; either version 2, or (at your option) any
 # later version.
 # 
@@ -22,17 +22,17 @@ function retval = std (a)
 #
 # For vector arguments, std returns the standard deviation of the
 # values.  For matrix arguments, std returns a row vector containing
 # the standard deviation for each column.
 #
 # See also: mean, median
 
   if (nargin != 1)
-    error ("usage: std (a)");
+    usage ("std (a)");
   endif
 
   nr = rows (a);
   nc = columns (a);
   if (nc == 1 && nr == 1)
     retval = 0;
   elseif (nc == 1 || nr == 1)
     tmp = sum (a);
diff --git a/scripts/strings/strcmp.m b/scripts/strings/strcmp.m
--- a/scripts/strings/strcmp.m
+++ b/scripts/strings/strcmp.m
@@ -22,17 +22,17 @@ function status = strcmp (s1, s2)
 #
 # Compare two strings.
 #
 # WARNING:  Unlike the C function of the same name, this function
 # returns 1 for equal and zero for not equal.  Why?  To be compatible
 # with Matlab, of course. 
 
   if (nargin != 2)
-    error ("usage: strcmp (s, t)");
+    usage ("strcmp (s, t)");
   endif
 
   status = 0;
   if (isstr (s1) && isstr(s2))
     len_s1 = columns (s1);
     len_s2 = columns (s2);
     if (len_s1 == len_s2)
       if (len_s1 == 0)
