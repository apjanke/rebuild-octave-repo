# HG changeset patch
# User Rik <rik@octave.org>
# Date 1447890507 28800
#      Wed Nov 18 15:48:27 2015 -0800
# Node ID 2469d78a1d8b76cf56bfa36ec2528bef7ccd7d89
# Parent  4a25c398ffa2d745c901d50202adf83c2bdc446c
Consistently use 'filename' rather than 'file name' throughout code base.

* bootstrap, configure.ac, basics.txi, gui.txi, io.txi, mkoctfile.1,
__init_qt__.cc, dialog.cc, files-dock-widget.cc, find-files-dialog.cc,
file-editor-tab.cc, file-editor-tab.h, file-editor.cc, shortcut-manager.cc,
debug.cc, dirfns.cc, dlmread.cc, file-io.cc, input.cc, load-path.h,
load-save.cc, symtab.h, sysdep.cc, utils.cc, variables.cc, zfstream.h,
oct-parse.in.yy, dir-ops.cc, file-ops.h, cmd-hist.cc, cmd-hist.h,
octave_tmp_file_name.m, uigetfile.m, uiputfile.m, imshow.m, imageIO.m,
dlmwrite.m, importdata.m, copyfile.m, edit.m, mkoctfile.m, movefile.m, open.m,
perl.m, python.m, run.m, tmpnam.m, unpack.m, fminsearch.m, configure_make.m,
print.m, __print_parse_opts__.m, test.m, main.in.cc, mkoctfile.in.cc, module.mk:
Consistently use 'filename' rather than 'file name' throughout code base.

diff --git a/bootstrap b/bootstrap
--- a/bootstrap
+++ b/bootstrap
@@ -27,17 +27,17 @@ scriptversion=2014-12-08.12; # UTC
 # file also maintained in your version control; gnulib comes with a
 # template build-aux/bootstrap.conf to get you started.
 
 # Please report bugs or propose patches to bug-gnulib@gnu.org.
 
 nl='
 '
 
-# Ensure file names are sorted consistently across platforms.
+# Ensure filenames are sorted consistently across platforms.
 LC_ALL=C
 export LC_ALL
 
 # Ensure that CDPATH is not set.  Otherwise, the output from cd
 # would cause trouble in at least one use below.
 (unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
 local_gl_dir=gl
diff --git a/configure.ac b/configure.ac
--- a/configure.ac
+++ b/configure.ac
@@ -2688,17 +2688,17 @@ do
         LDFLAGS="$LDFLAGS -Wl,--export-all-symbols"
       fi
       AC_DEFINE(HAVE_JAVA, 1,
         [Define to 1 if Java is available and is at least version 1.5])
       break
     ;;
   esac
 
-  ## Determine which library file name to search for.
+  ## Determine which library filename to search for.
   case $host_os in
     darwin*)
       jvmlib=libjvm.dylib
     ;;
     *)
       jvmlib=libjvm.so
     ;;
   esac
diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -979,17 +979,17 @@ typed:
 @example
 octave hello
 @end example
 
 The line beginning with @samp{#!} lists the full path and filename of an
 interpreter to be run, and an optional initial command line argument to
 pass to that interpreter.  The operating system then runs the
 interpreter with the given argument and the full argument list of the
-executed program.  The first argument in the list is the full file name
+executed program.  The first argument in the list is the full filename
 of the Octave executable.  The rest of the argument list will either be
 options to Octave, or data files, or both.  The @samp{-qf} options are
 usually specified in stand-alone Octave programs to prevent them from
 printing the normal startup message, and to keep them from behaving
 differently depending on the contents of a particular user's
 @file{~/.octaverc} file.  @xref{Invoking Octave from the Command Line}.
 
 Note that some operating systems may place a limit on the number of
diff --git a/doc/interpreter/gui.txi b/doc/interpreter/gui.txi
--- a/doc/interpreter/gui.txi
+++ b/doc/interpreter/gui.txi
@@ -45,17 +45,17 @@ preferences.
 * User-Defined Preferences::
 @end menu
 
 @node I/O Dialogs
 @section I/O Dialogs
 
 Simple dialog menus are available for choosing directories or files.  They
 return a string variable which can then be used with any command requiring
-a file name.
+a filename.
 
 @DOCSTRING(uigetdir)
 
 @DOCSTRING(uigetfile)
 
 @DOCSTRING(uiputfile)
 
 @node Progress Bar
diff --git a/doc/interpreter/io.txi b/doc/interpreter/io.txi
--- a/doc/interpreter/io.txi
+++ b/doc/interpreter/io.txi
@@ -264,17 +264,17 @@ functions.
 @node C-Style I/O Functions
 @section C-Style I/O Functions
 
 Octave's C-style input and output functions provide most of the
 functionality of the C programming language's standard I/O library.  The
 argument lists for some of the input functions are slightly different,
 however, because Octave has no way of passing arguments by reference.
 
-In the following, @var{file} refers to a file name and @code{fid} refers
+In the following, @var{file} refers to a filename and @code{fid} refers
 to an integer file number, as returned by @code{fopen}.
 
 There are three files that are always available.  Although these files
 can be accessed using their corresponding numeric file ids, you should
 always use the symbolic names given in the table below, since it will
 make your programs easier to understand.
 
 @DOCSTRING(stdin)
diff --git a/doc/interpreter/mkoctfile.1 b/doc/interpreter/mkoctfile.1
--- a/doc/interpreter/mkoctfile.1
+++ b/doc/interpreter/mkoctfile.1
@@ -83,17 +83,17 @@ Link a stand-alone executable file.
 .TP
 .B \-s\fR,\fB --strip
 Strip the output file.
 .TP
 .B \-\-mex
 Create a MEX file.  Set the default output extension to \fB.mex\fP.
 .TP
 .B \-o \fIfile\fP\fR,\fB \-\-output \fIfile\fP
-Output file name.  Default extension is \fB.oct\fP (or \fB.mex\fP if \-\-mex is
+Output filename.  Default extension is \fB.oct\fP (or \fB.mex\fP if \-\-mex is
 specified) unless linking a stand-alone executable.
 .TP
 .B \-p \fIVAR\fP\fR,\fB \-\-print \fIVAR\fP
 Print configuration variable \fIVAR\fP.  Recognized variables are:
 .RS
 .Vb
     ALL_CFLAGS                FFTW3F_LDFLAGS
     ALL_CXXFLAGS              FFTW3F_LIBS
diff --git a/libgui/graphics/__init_qt__.cc b/libgui/graphics/__init_qt__.cc
--- a/libgui/graphics/__init_qt__.cc
+++ b/libgui/graphics/__init_qt__.cc
@@ -185,17 +185,17 @@ appendDirSep (const QString& d)
 
 DEFUN (__uigetfile_qt__, args, , "")
 {
   using namespace QtHandles::Utils;
 
   // Expected arguments:
   //   args(0) : File filter as a cell array {ext1, name1; ext2, name2; ...}
   //   args(1) : Dialog title
-  //   args(2) : Default file name
+  //   args(2) : Default filename
   //   args(3) : Dialog position [ignored]
   //   args(4) : Multiselection "on"/"off"
   //   args(5) : Default directory
 
   octave_value_list retval (3);
 
   QString caption = fromStdString (args(1).string_value ());
   QString defaultDirectory = fromStdString (args(5).string_value ());
@@ -267,17 +267,17 @@ DEFUN (__uigetfile_qt__, args, , "")
 
 DEFUN (__uiputfile_qt__, args, , "")
 {
   using namespace QtHandles::Utils;
 
   // Expected arguments:
   //   args(0) : File filter as a cell array {ext1, name1; ext2, name2; ...}
   //   args(1) : Dialog title
-  //   args(2) : Default file name
+  //   args(2) : Default filename
   //   args(3) : Dialog position [ignored]
   //   args(4) : Tag [ignored]
   //   args(5) : Default directory
 
   octave_value_list retval (3);
 
   QString caption = fromStdString (args(1).string_value ());
   QString defaultDirectory = fromStdString (args(5).string_value ());
diff --git a/libgui/src/dialog.cc b/libgui/src/dialog.cc
--- a/libgui/src/dialog.cc
+++ b/libgui/src/dialog.cc
@@ -517,17 +517,17 @@ void FileDialog::acceptSelection (void)
     {
       path = string_result[0];
     }
   else
     {
       path = directory ().absolutePath ();
     }
 
-  // Matlab expects just the file name, whereas the file dialog gave us
+  // Matlab expects just the filename, whereas the file dialog gave us
   // full path names, so fix it.
 
   for (int i = 0; i < string_result.size (); i++)
     string_result[i] = QFileInfo (string_result[i]).fileName ();
 
   // if not showing only dirs, add end slash for the path component
   if (testOption (QFileDialog::ShowDirsOnly)  == false)
     path += "/";
diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -788,17 +788,17 @@ files_dock_widget::notice_settings (cons
 
   if (icon_size_settings == 1)
     icon_size = st->pixelMetric (QStyle::PM_LargeIconSize);
   else if (icon_size_settings == -1)
     icon_size = st->pixelMetric (QStyle::PM_SmallIconSize);
 
   _navigation_tool_bar->setIconSize (QSize (icon_size,icon_size));
 
-  // file names are always shown, other columns can be hidden by settings
+  // filenames are always shown, other columns can be hidden by settings
   for (int i = 0; i < 3; i++)
      _file_tree_view->setColumnHidden (i + 1, ! settings->value (
                                   _columns_shown_keys.at (i),false).toBool ());
 
   if (settings->value (_columns_shown_keys.at (3),false).toBool ())
       _file_system_model->setFilter (QDir::NoDotAndDotDot | QDir::AllEntries
                                      | QDir::Hidden);
   else
diff --git a/libgui/src/find-files-dialog.cc b/libgui/src/find-files-dialog.cc
--- a/libgui/src/find-files-dialog.cc
+++ b/libgui/src/find-files-dialog.cc
@@ -154,17 +154,17 @@ find_files_dialog::find_files_dialog (QW
   button_box->addButton (_stop_button, QDialogButtonBox::ActionRole);
 
   // add dialog close button
   _close_button = button_box->addButton (QDialogButtonBox::Close);
   connect (button_box,    SIGNAL (rejected ()),
            this,          SLOT (close ()));
 
   // name options
-  QGroupBox * name_group = new QGroupBox (tr ("File name/location"));
+  QGroupBox * name_group = new QGroupBox (tr ("Filename/location"));
   QGridLayout * name_layout = new QGridLayout;
   name_group->setLayout (name_layout);
 
   name_layout->addWidget (file_name_label,1,1, 1,1);
   name_layout->addWidget (_file_name_edit,1,2, 1,-1);
 
   name_layout->addWidget (start_dir_label,2,1);
   name_layout->addWidget (_start_dir_edit,2,2,1,3);
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -714,17 +714,17 @@ file_editor_tab::run_file (const QWidget
 {
   if (ID != this)
     return;
 
   if (_edit_area->isModified () | ! valid_file_name ())
     {
       save_file (_file_name);  // save file dialog
       if (! valid_file_name ())
-        return;   // still invalid file name: "save as" was cancelled
+        return;   // still invalid filename: "save as" was cancelled
     }
 
   QFileInfo info (_file_name);
   emit run_file_signal (info);
 }
 
 void
 file_editor_tab::context_run (const QWidget *ID)
@@ -1516,20 +1516,20 @@ file_editor_tab::save_file (const QStrin
   QApplication::restoreOverrideCursor ();
   file.flush ();
   file.close ();
 
   // file exists now
   file_info = QFileInfo (file);
   file_to_save = file_info.canonicalFilePath ();
 
-  // save file name after closing file as set_file_name starts watching again
+  // save filename after closing file as set_file_name starts watching again
   set_file_name (file_to_save);   // make absolute
 
-  // set the window title to actual file name (not modified)
+  // set the window title to actual filename (not modified)
   update_window_title (false);
 
   // files is save -> not modified
   _edit_area->setModified (false);
 
   if (remove_on_success)
     {
       emit tab_remove_request ();
@@ -1673,17 +1673,17 @@ file_editor_tab::check_valid_identifier 
   QString base_name = file.baseName ();
 
   if ((file.suffix () == "m")
       && (! valid_identifier (base_name.toStdString ())))
     {
       int ans = QMessageBox::question (0, tr ("Octave Editor"),
          tr ("\"%1\"\n"
              "is not a valid identifier.\n\n"
-             "If you keep this file name, you will not be able to\n"
+             "If you keep this filename, you will not be able to\n"
              "call your script using its name as an Octave command.\n\n"
              "Do you want to choose another name?").arg (base_name),
           QMessageBox::Yes | QMessageBox::No, QMessageBox::Yes);
 
       if (ans == QMessageBox::Yes)
         return true;
     }
 
@@ -1717,17 +1717,17 @@ file_editor_tab::handle_save_file_as_ans
   if (_save_as_desired_eol != _edit_area->eolMode ())
     {
       _edit_area->setReadOnly (false);  // was set to read-only in save_file_as
       convert_eol (this,_save_as_desired_eol);
       _edit_area->setReadOnly (true);   // restore read-only mode
     }
 
   // saveFileName == _file_name can not happen, because we only can get here
-  // when we close a tab and _file_name is not a valid file name yet
+  // when we close a tab and _file_name is not a valid filename yet
 
   // Have editor check for conflict, delete tab after save.
   if (check_valid_identifier (saveFileName))
     save_file_as (true);
   else
     emit editor_check_conflict_save (saveFileName, true);
 }
 
diff --git a/libgui/src/m-editor/file-editor-tab.h b/libgui/src/m-editor/file-editor-tab.h
--- a/libgui/src/m-editor/file-editor-tab.h
+++ b/libgui/src/m-editor/file-editor-tab.h
@@ -65,17 +65,17 @@ public slots:
                               Qt::KeyboardModifiers state);
 
   // Tells the editor tab to react on changed settings.
   void notice_settings (const QSettings *settings, bool init = false);
 
   // Change to a different editor tab by identifier tag.
   void change_editor_state (const QWidget *ID);
 
-  // Simply transmit file name.
+  // Simply transmit filename.
   void file_name_query (const QWidget *ID);
 
   void set_focus (const QWidget *ID);
   void set_current_directory (const QString& dir);
   void context_help (const QWidget *ID, bool);
   void context_edit (const QWidget *ID);
   void check_modified_file (void);
   void save_file (const QWidget *ID);
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -68,21 +68,21 @@ file_editor::~file_editor (void)
 }
 
 bool
 file_editor::check_closing (void)
 {
   // Save open files for restoring in next session; this only is possible
   QSettings *settings = resource_manager::get_settings ();
 
-  // Have all file editor tabs signal what their file names are.
+  // Have all file editor tabs signal what their filenames are.
   editor_tab_map.clear ();
   emit fetab_file_name_query (0);
 
-  // save file names (even if last session will not be restored next time)
+  // save filenames (even if last session will not be restored next time)
   QStringList fetFileNames;
   for (editor_tab_map_const_iterator p = editor_tab_map.begin ();
        p != editor_tab_map.end (); p++)
     {
       QString file_name = p->first;
       if (!file_name.isEmpty ())
         fetFileNames.append (p->first);  // do not append unnamed files
     }
@@ -339,17 +339,17 @@ file_editor::request_open_file (const QS
   if (openFileName.isEmpty ())
     {
       // This happens if edit is calles without an argument
       // Open eitor with empty edit area instead (as new file would do)
       request_new_file ("");
     }
   else
     {
-      // Have all file editor tabs signal what their file names are.
+      // Have all file editor tabs signal what their filenames are.
       editor_tab_map.clear ();
       emit fetab_file_name_query (0);
 
       // Check whether this file is already open in the editor.
       QWidget *tab = find_tab_widget (openFileName);
 
       if (tab)
         {
@@ -493,17 +493,17 @@ file_editor::request_mru_open_file (QAct
     }
 }
 
 
 void
 file_editor::check_conflict_save (const QString& saveFileName,
                                   bool remove_on_success)
 {
-  // Have all file editor tabs signal what their file names are.
+  // Have all file editor tabs signal what their filenames are.
   editor_tab_map.clear ();
   emit fetab_file_name_query (0);
 
   // Check whether this file is already open in the editor.
   QWidget *tab = find_tab_widget (saveFileName);
 
   if (tab)
     {
@@ -567,17 +567,17 @@ file_editor::handle_insert_debugger_poin
 }
 
 void
 file_editor::handle_delete_debugger_pointer_request (const QString& file,
                                                      int line)
 {
   if (! file.isEmpty ())
     {
-      // Have all file editor tabs signal what their file names are.
+      // Have all file editor tabs signal what their filenames are.
       editor_tab_map.clear ();
       emit fetab_file_name_query (0);
 
       // Check whether this file is already open in the editor.
       QWidget *tab = find_tab_widget (file);
 
       if (tab)
         {
@@ -883,17 +883,17 @@ file_editor::request_completion (bool)
 {
   emit fetab_completion (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::handle_mru_add_file (const QString& file_name)
 {
   if (_mru_files.count () && _mru_files.at (0) == file_name)
-    return;  // the first entry is already the actual file name
+    return;  // the first entry is already the actual filename
 
   _mru_files.removeAll (file_name);
   _mru_files.prepend (file_name);
 
   mru_menu_update ();
 }
 
 void
diff --git a/libgui/src/shortcut-manager.cc b/libgui/src/shortcut-manager.cc
--- a/libgui/src/shortcut-manager.cc
+++ b/libgui/src/shortcut-manager.cc
@@ -668,17 +668,17 @@ shortcut_manager::do_import_export (int 
 {
   // ask to save the current shortcuts, maybe abort import
   if (action == OSC_DEFAULT || action == OSC_IMPORT)
     {
       if (! overwrite_all_shortcuts ())
         return false;
     }
 
-  // get the file name to read or write the shortcuts,
+  // get the filename to read or write the shortcuts,
   // the default extension is .osc (octave shortcuts)
   if (action != OSC_DEFAULT)
     {
       QString file;
 
       if (action == OSC_IMPORT)
         file  = QFileDialog::getOpenFileName (this,
                     tr ("Import shortcuts from file ..."), QString (),
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -1257,17 +1257,17 @@ DEFUN (dbstack, args, nargout,
 @deftypefnx {Command} {} dbstack @var{n}\n\
 @deftypefnx {Command} {} dbstack @var{-completenames}\n\
 @deftypefnx {Built-in Function} {[@var{stack}, @var{idx}] =} dbstack (@dots{})\n\
 Display or return current debugging function stack information.\n\
 \n\
 With optional argument @var{n}, omit the @var{n} innermost stack frames.\n\
 \n\
 Although accepted, the argument @var{-completenames} is silently ignored.\n\
-Octave always returns absolute file names.\n\
+Octave always returns absolute filenames.\n\
 \n\
 The arguments @var{n} and @var{-completenames} can be both specified in any\n\
 order.\n\
 \n\
 The optional return argument @var{stack} is a struct array with the\n\
 following fields:\n\
 \n\
 @table @asis\n\
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -506,17 +506,17 @@ error message.\n\
 
   return retval;
 }
 
 DEFUN (glob, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} glob (@var{pattern})\n\
 Given an array of pattern strings (as a char array or a cell array) in\n\
-@var{pattern}, return a cell array of file names that match any of\n\
+@var{pattern}, return a cell array of filenames that match any of\n\
 them, or an empty cell array if no patterns match.\n\
 \n\
 The pattern strings are interpreted as filename globbing patterns (as they\n\
 are used by Unix shells).\n\
 \n\
 Within a pattern\n\
 \n\
 @table @code\n\
@@ -526,17 +526,17 @@ matches any string, including the null s
 @item ?\n\
 matches any single character, and\n\
 \n\
 @item [@dots{}]\n\
 matches any of the enclosed characters.\n\
 @end table\n\
 \n\
 Tilde expansion is performed on each of the patterns before looking for\n\
-matching file names.  For example:\n\
+matching filenames.  For example:\n\
 \n\
 @example\n\
 ls\n\
    @result{}\n\
       file1  file2  file3  myfile1 myfile1b\n\
 glob (\"*file1\")\n\
    @result{}\n\
       @{\n\
diff --git a/libinterp/corefcn/dlmread.cc b/libinterp/corefcn/dlmread.cc
--- a/libinterp/corefcn/dlmread.cc
+++ b/libinterp/corefcn/dlmread.cc
@@ -175,17 +175,17 @@ such that the first row corresponds to a
 \n\
 The @var{range} parameter may be a 4-element vector containing the upper\n\
 left and lower right corner @code{[@var{R0},@var{C0},@var{R1},@var{C1}]}\n\
 where the lowest index value is zero.  Alternatively, a spreadsheet style\n\
 range such as @qcode{\"A2..Q15\"} or @qcode{\"T1:AA5\"} can be used.  The\n\
 lowest alphabetical index @qcode{'A'} refers to the first column.  The\n\
 lowest row index is 1.\n\
 \n\
-@var{file} should be a file name or file id given by @code{fopen}.  In the\n\
+@var{file} should be a filename or file id given by @code{fopen}.  In the\n\
 latter case, the file is read until end of file is reached.\n\
 \n\
 The @qcode{\"emptyvalue\"} option may be used to specify the value used to\n\
 fill empty fields.  The default is zero.\n\
 @seealso{csvread, textscan, textread, dlmwrite}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -208,17 +208,17 @@ fill empty fields.  The default is zero.
       return retval;
     }
 
   std::istream *input = 0;
   std::ifstream input_file;
 
   if (args(0).is_string ())
     {
-      // File name.
+      // Filename.
       std::string fname (args(0).string_value ());
 
       std::string tname = file_ops::tilde_expand (fname);
 
       input_file.open (tname.c_str (), std::ios::in);
 
       if (! input_file)
         {
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -533,17 +533,17 @@ do_stream_open (const std::string& name,
 static octave_stream
 do_stream_open (const octave_value& tc_name, const octave_value& tc_mode,
                 const octave_value& tc_arch, const char *fcn, int& fid)
 {
   octave_stream retval;
 
   fid = -1;
 
-  std::string name = tc_name.xstring_value ("%s: file name must be a string", fcn);
+  std::string name = tc_name.xstring_value ("%s: filename must be a string", fcn);
   std::string mode = tc_mode.xstring_value ("%s: file mode must be a string", fcn);
   std::string arch = tc_arch.xstring_value ("%s: architecture type must be a string", fcn);
 
   retval = do_stream_open (name, mode, arch, fid);
 
   return retval;
 }
 
@@ -1841,17 +1841,17 @@ The function @code{fclose} may also be u
   return retval;
 }
 
 DEFUN (tempname, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{fname} =} tempname ()\n\
 @deftypefnx {Built-in Function} {@var{fname} =} tempname (@var{dir})\n\
 @deftypefnx {Built-in Function} {@var{fname} =} tempname (@var{dir}, @var{prefix})\n\
-Return a unique temporary file name as a string.\n\
+Return a unique temporary filename as a string.\n\
 \n\
 If @var{prefix} is omitted, a value of @qcode{\"oct-\"} is used.\n\
 \n\
 If @var{dir} is also omitted, the default directory for temporary files\n\
 (@code{P_tmpdir}) is used.  If @var{dir} is provided, it must exist,\n\
 otherwise the default directory for temporary files is used.\n\
 \n\
 Programming Note: Because the named file is not opened by @code{tempname},\n\
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -323,17 +323,17 @@ octave_base_reader::reading_script_file 
 
 FILE *
 get_input_from_stdin (void)
 {
   command_editor::set_input_stream (stdin);
   return command_editor::get_input_stream ();
 }
 
-// FIXME: make this generate file names when appropriate.
+// FIXME: make this generate filenames when appropriate.
 
 static string_vector
 generate_possible_completions (const std::string& text, std::string& prefix,
                                std::string& hint)
 {
   string_vector names;
 
   prefix = "";
diff --git a/libinterp/corefcn/load-path.h b/libinterp/corefcn/load-path.h
--- a/libinterp/corefcn/load-path.h
+++ b/libinterp/corefcn/load-path.h
@@ -441,20 +441,20 @@ private:
   };
 
   // We maintain two ways of looking at the same information.
   //
   // First, a list of directories and the set of "public" files and
   // private files (those found in the special "private" subdirectory)
   // in each directory.
   //
-  // Second, a map from file names (the union of all "public" files for all
+  // Second, a map from filenames (the union of all "public" files for all
   // directories, but without filename extensions) to a list of
   // corresponding information (directory name and file types).  This
-  // way, we can quickly find shadowed file names and look up all
+  // way, we can quickly find shadowed filenames and look up all
   // overloaded functions (in the "@" directories used to implement
   // classes).
 
   typedef std::list<dir_info> dir_info_list_type;
 
   typedef dir_info_list_type::const_iterator const_dir_info_list_iterator;
   typedef dir_info_list_type::iterator dir_info_list_iterator;
 
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -1370,17 +1370,17 @@ dump_octave_core (std::ostream& os, cons
   message (0, "save to '%s' complete", fname);
 }
 
 void
 dump_octave_core (void)
 {
   if (Vcrash_dumps_octave_core)
     {
-      // FIXME: should choose better file name?
+      // FIXME: should choose better filename?
 
       const char *fname = Voctave_core_file_name.c_str ();
 
       message (0, "attempting to save variables to '%s'...", fname);
 
       load_save_format format = LS_BINARY;
 
       bool save_as_floats = false;
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -2340,18 +2340,18 @@ private:
   typedef std::map<std::string, fcn_info>::const_iterator
     fcn_table_const_iterator;
   typedef std::map<std::string, fcn_info>::iterator
     fcn_table_iterator;
 
   // The scope of this symbol table.
   scope_id my_scope;
 
-  // Name for this table (usually the file name of the function
-  // corresponding to the scope);
+  // Name for this table
+  // (usually the filename of the function corresponding to the scope);
   std::string table_name;
 
   // Map from symbol names to symbol info.
   std::map<std::string, symbol_record> table;
 
   // Child nested functions.
   std::vector<symbol_table*> nest_children;
 
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -190,17 +190,17 @@ DEFUN (__open_with_system_app__, args, ,
 @deftypefn {Loadable Function} {} __open_with_system_app__ (@var{file})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
-      std::string file = args(0).xstring_value ("__open_with_system_app__: argument must be a file name");
+      std::string file = args(0).xstring_value ("__open_with_system_app__: argument must be a filename");
 
 #if defined (__WIN32__) && ! defined (_POSIX_VERSION)
       HINSTANCE status = ShellExecute (0, 0, file.c_str (), 0, 0,
                                        SW_SHOWNORMAL);
 
       // ShellExecute returns a value greater than 32 if successful.
       retval = (reinterpret_cast<ptrdiff_t> (status) > 32);
 #else
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -990,17 +990,17 @@ system.\n\
 No check is done for the existence of @var{file}.\n\
 @seealso{canonicalize_file_name, is_absolute_filename, is_rooted_relative_filename, isdir}\n\
 @end deftypefn")
 {
   octave_value retval = std::string ();
 
   if (args.length () == 1)
     {
-      std::string nm = args(0).xstring_value ("make_absolute_filename: FILE argument must be a file name");
+      std::string nm = args(0).xstring_value ("make_absolute_filename: FILE argument must be a filename");
 
       retval = octave_env::make_absolute (nm);
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -525,17 +525,17 @@ directory, or class.\n\
 \n\
 The return code @var{c} is one of\n\
 \n\
 @table @asis\n\
 @item 1\n\
 @var{name} is a variable.\n\
 \n\
 @item 2\n\
-@var{name} is an absolute file name, an ordinary file in Octave's\n\
+@var{name} is an absolute filename, an ordinary file in Octave's\n\
 @code{path}, or (after appending @samp{.m}) a function file in Octave's\n\
 @code{path}.\n\
 \n\
 @item 3\n\
 @var{name} is a @samp{.oct} or @samp{.mex} file in Octave's @code{path}.\n\
 \n\
 @item 5\n\
 @var{name} is a built-in function.\n\
@@ -632,23 +632,23 @@ not on the search path you should use so
 %!   assert (exist ("/dev/null", "dir"), 0);
 %! endif
 
 %!assert (exist ("print_usage"), 2)
 %!assert (exist ("print_usage.m"), 2)
 %!assert (exist ("print_usage", "file"), 2)
 %!assert (exist ("print_usage", "dir"), 0)
 
-## Don't search path for rooted relative file names
+## Don't search path for rooted relative filenames
 %!assert (exist ("plot.m", "file"), 2);
 %!assert (exist ("./plot.m", "file"), 0);
 %!assert (exist ("./%nonexistentfile%", "file"), 0);
 %!assert (exist ("%nonexistentfile%", "file"), 0);
 
-## Don't search path for absolute file names
+## Don't search path for absolute filenames
 %!test
 %! tname = tempname (pwd ());
 %! unwind_protect
 %!   ## open/close file to create it, equivalent of touch
 %!   fid = fopen (tname, "w");
 %!   fclose (fid);
 %!   [~, fname] = fileparts (tname);
 %!   assert (exist (fullfile (pwd (), fname), "file"), 2);
@@ -1624,17 +1624,17 @@ do_who (int argc, const string_vector& a
         {
           // FIXME: This is an inefficient manner to implement this as the
           // variables are loaded in to a temporary context and then treated.
           // It would be better to refecat symbol_info_list to not store the
           // symbol records and then use it in load-save.cc (do_load) to
           // implement this option there so that the variables are never
           // stored at all.
           if (i == argc - 1)
-            error ("whos: -file argument must be followed by a file name");
+            error ("whos: -file argument must be followed by a filename");
           else
             {
               std::string nm = argv[i + 1];
 
               unwind_protect frame;
 
               // Set up temporary scope.
 
diff --git a/libinterp/corefcn/zfstream.h b/libinterp/corefcn/zfstream.h
--- a/libinterp/corefcn/zfstream.h
+++ b/libinterp/corefcn/zfstream.h
@@ -78,17 +78,17 @@ public:
    *  @brief  Check if file is open.
    *  @return  True if file is open.
   */
   bool
   is_open () const { return (file != 0); }
 
   /**
    *  @brief  Open gzipped file.
-   *  @param  name  File name.
+   *  @param  name  Filename.
    *  @param  mode  Open mode flags.
    *  @return  @c this on success, NULL on failure.
   */
   gzfilebuf*
   open (const char* name,
         std::ios_base::openmode mode);
 
   /**
@@ -281,17 +281,17 @@ private:
 class gzifstream : public std::istream
 {
 public:
   //  Default constructor
   gzifstream ();
 
   /**
    *  @brief  Construct stream on gzipped file to be opened.
-   *  @param  name  File name.
+   *  @param  name  Filename.
    *  @param  mode  Open mode flags (forced to contain ios::in).
   */
   explicit
   gzifstream (const char* name,
               std::ios_base::openmode mode = std::ios_base::in);
 
   /**
    *  @brief  Construct stream on already open gzipped file.
@@ -313,17 +313,17 @@ public:
    *  @brief  Check if file is open.
    *  @return  True if file is open.
   */
   bool
   is_open () { return sb.is_open (); }
 
   /**
    *  @brief  Open gzipped file.
-   *  @param  name  File name.
+   *  @param  name  Filename.
    *  @param  mode  Open mode flags (forced to contain ios::in).
    *
    *  Stream will be in state good() if file opens successfully;
    *  otherwise in state fail(). This differs from the behavior of
    *  ifstream, which never sets the state to good() and therefore
    *  won't allow you to reuse the stream for a second file unless
    *  you manually clear() the state. The choice is a matter of
    *  convenience.
@@ -370,17 +370,17 @@ private:
 class gzofstream : public std::ostream
 {
 public:
   //  Default constructor
   gzofstream ();
 
   /**
    *  @brief  Construct stream on gzipped file to be opened.
-   *  @param  name  File name.
+   *  @param  name  Filename.
    *  @param  mode  Open mode flags (forced to contain ios::out).
   */
   explicit
   gzofstream (const char* name,
               std::ios_base::openmode mode = std::ios_base::out);
 
   /**
    *  @brief  Construct stream on already open gzipped file.
@@ -402,17 +402,17 @@ public:
    *  @brief  Check if file is open.
    *  @return  True if file is open.
   */
   bool
   is_open () { return sb.is_open (); }
 
   /**
    *  @brief  Open gzipped file.
-   *  @param  name  File name.
+   *  @param  name  Filename.
    *  @param  mode  Open mode flags (forced to contain ios::out).
    *
    *  Stream will be in state good() if file opens successfully;
    *  otherwise in state fail(). This differs from the behavior of
    *  ofstream, which never sets the state to good() and therefore
    *  won't allow you to reuse the stream for a second file unless
    *  you manually clear() the state. The choice is a matter of
    *  convenience.
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -3124,30 +3124,30 @@ octave_base_parser::frob_function (const
   // the file does not match the name of the function stated in the
   // file.  Matlab doesn't provide a diagnostic (it ignores the stated
   // name).
   if (! autoloading && lexer.reading_fcn_file
       && curr_fcn_depth == 1 && ! parsing_subfunctions)
   {
     // FIXME -- should lexer.fcn_file_name already be
     // preprocessed when we get here?  It seems to only be a
-    // problem with relative file names.
+    // problem with relative filenames.
 
     std::string nm = lexer.fcn_file_name;
 
     size_t pos = nm.find_last_of (file_ops::dir_sep_chars ());
 
     if (pos != std::string::npos)
       nm = lexer.fcn_file_name.substr (pos+1);
 
     if (nm != id_name)
       {
         warning_with_id
           ("Octave:function-name-clash",
-           "function name '%s' does not agree with function file name '%s'",
+           "function name '%s' does not agree with function filename '%s'",
            id_name.c_str (), lexer.fcn_file_full_name.c_str ());
 
         id_name = nm;
       }
   }
 
   if (lexer.reading_fcn_file || lexer.reading_classdef_file || autoloading)
     {
@@ -3350,17 +3350,17 @@ octave_base_parser::make_classdef (token
   std::string nm = lexer.fcn_file_name;
 
   size_t pos = nm.find_last_of (file_ops::dir_sep_chars ());
 
   if (pos != std::string::npos)
     nm = lexer.fcn_file_name.substr (pos+1);
 
   if (nm != cls_name)
-    bison_error ("invalid classdef definition, the class name must match the file name");
+    bison_error ("invalid classdef definition, the class name must match the filename");
   else if (end_token_ok (end_tok, token::classdef_end))
     {
       octave_comment_list *tc = lexer.comment_buf.get_comment ();
 
       int l = tok_val->line ();
       int c = tok_val->column ();
 
       if (! body)
@@ -4299,17 +4299,17 @@ load_fcn_from_file (const std::string& f
 
 DEFUN (autoload, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{autoload_map} =} autoload ()\n\
 @deftypefnx {Built-in Function} {} autoload (@var{function}, @var{file})\n\
 @deftypefnx {Built-in Function} {} autoload (@dots{}, \"remove\")\n\
 Define @var{function} to autoload from @var{file}.\n\
 \n\
-The second argument, @var{file}, should be an absolute file name or a file\n\
+The second argument, @var{file}, should be an absolute filename or a file\n\
 name in the same directory as the function or script from which the autoload\n\
 command was run.  @var{file} @emph{should not} depend on the Octave load\n\
 path.\n\
 \n\
 Normally, calls to @code{autoload} appear in PKG_ADD script files that are\n\
 evaluated when a directory is added to Octave's load path.  To avoid having\n\
 to hardcode directory names in @var{file}, if @var{file} is in the same\n\
 directory as the PKG_ADD script then\n\
@@ -4390,17 +4390,17 @@ not loaded anymore during the current Oc
                     {
                       nm = fname + nm;
                       found = true;
                     }
                 }
             }
           if (! found)
             warning_with_id ("Octave:autoload-relative-file-name",
-                             "autoload: '%s' is not an absolute file name",
+                             "autoload: '%s' is not an absolute filename",
                              nm.c_str ());
         }
       if (nargin == 2)
         autoload_map[argv[1]] = nm;
       else if (nargin == 3)
         {
           if (argv[3].compare ("remove") != 0)
             error_with_id ("Octave:invalid-input-arg",
@@ -4524,20 +4524,20 @@ DEFUN (mfilename, args, ,
 @deftypefn  {Built-in Function} {} mfilename ()\n\
 @deftypefnx {Built-in Function} {} mfilename (\"fullpath\")\n\
 @deftypefnx {Built-in Function} {} mfilename (\"fullpathext\")\n\
 Return the name of the currently executing file.\n\
 \n\
 When called from outside an m-file return the empty string.\n\
 \n\
 Given the argument @qcode{\"fullpath\"}, include the directory part of the\n\
-file name, but not the extension.\n\
+filename, but not the extension.\n\
 \n\
 Given the argument @qcode{\"fullpathext\"}, include the directory part of\n\
-the file name and the extension.\n\
+the filename and the extension.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 1)
     {
@@ -4594,17 +4594,17 @@ requiring the file to be named @file{@va
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      std::string file_name = args(0).xstring_value ("source: expecting file name as argument");
+      std::string file_name = args(0).xstring_value ("source: expecting filename as argument");
 
       std::string context;
 
       if (nargin == 2)
         context = args(1).xstring_value ("source: expecting context to be character string");
 
       source_file (file_name, context);
     }
@@ -5187,17 +5187,17 @@ Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1 || nargin == 2)
     {
-      std::string file = args(0).xstring_value ("__parse_file__: expecting file name as argument");
+      std::string file = args(0).xstring_value ("__parse_file__: expecting filename as argument");
 
       std::string full_file = octave_env::make_absolute (file);
 
       size_t file_len = file.length ();
 
       if ((file_len > 4 && file.substr (file_len-4) == ".oct")
           || (file_len > 4 && file.substr (file_len-4) == ".mex")
           || (file_len > 2 && file.substr (file_len-2) == ".m"))
diff --git a/liboctave/system/dir-ops.cc b/liboctave/system/dir-ops.cc
--- a/liboctave/system/dir-ops.cc
+++ b/liboctave/system/dir-ops.cc
@@ -56,17 +56,17 @@ dir_entry::open (const std::string& n)
       dir = static_cast<void *> (gnulib::opendir (fullname.c_str ()));
 
       if (dir)
         fail = false;
       else
         errmsg = gnulib::strerror (errno);
     }
   else
-    errmsg = "dir_entry::open: empty file name";
+    errmsg = "dir_entry::open: empty filename";
 
   return ! fail;
 }
 
 string_vector
 dir_entry::read (void)
 {
   string_vector retval;
diff --git a/liboctave/system/file-ops.h b/liboctave/system/file-ops.h
--- a/liboctave/system/file-ops.h
+++ b/liboctave/system/file-ops.h
@@ -77,17 +77,17 @@ public:
   }
 
   static std::string tilde_expand (const std::string&);
 
   static string_vector tilde_expand (const string_vector&);
 
   static std::string concat (const std::string&, const std::string&);
 
-  // Return the tail member of a file name.
+  // Return the tail member of a filename.
   static std::string tail (const std::string& path)
   {
     size_t ipos = path.find_last_of (dir_sep_chars ());
 
     if (ipos != std::string::npos)
       ipos++;
     else
       ipos = 0;
diff --git a/liboctave/util/cmd-hist.cc b/liboctave/util/cmd-hist.cc
--- a/liboctave/util/cmd-hist.cc
+++ b/liboctave/util/cmd-hist.cc
@@ -312,17 +312,17 @@ gnu_history::do_read (const std::string&
       else
         {
           lines_in_file = do_where ();
 
           ::octave_using_history ();
         }
     }
   else
-    error ("gnu_history::read: missing file name");
+    error ("gnu_history::read: missing filename");
 }
 
 void
 gnu_history::do_read_range (const std::string& f, int from, int to,
                             bool must_exist)
 {
   if (from < 0)
     from = lines_in_file;
@@ -342,17 +342,17 @@ gnu_history::do_read_range (const std::s
       else
         {
           lines_in_file = do_where ();
 
           ::octave_using_history ();
         }
     }
   else
-    error ("gnu_history::read_range: missing file name");
+    error ("gnu_history::read_range: missing filename");
 }
 
 void
 gnu_history::do_write (const std::string& f_arg) const
 {
   if (initialized)
     {
       std::string f = f_arg;
@@ -367,17 +367,17 @@ gnu_history::do_write (const std::string
           if (status != 0)
             {
               std::string msg = "writing file '" + f + "'";
 
               error (status, msg);
             }
         }
       else
-        error ("gnu_history::write: missing file name");
+        error ("gnu_history::write: missing filename");
     }
 }
 
 void
 gnu_history::do_append (const std::string& f_arg)
 {
   if (initialized)
     {
@@ -414,17 +414,17 @@ gnu_history::do_append (const std::strin
                       error (status, msg);
                     }
                   else
                     lines_in_file += lines_this_session;
 
                   lines_this_session = 0;
                 }
               else
-                error ("gnu_history::append: missing file name");
+                error ("gnu_history::append: missing filename");
             }
         }
     }
 }
 
 void
 gnu_history::do_truncate_file (const std::string& f_arg, int n) const
 {
@@ -433,17 +433,17 @@ gnu_history::do_truncate_file (const std
       std::string f = f_arg;
 
       if (f.empty ())
         f = xfile;
 
       if (! f.empty ())
         ::octave_history_truncate_file (f.c_str (), n);
       else
-        error ("gnu_history::truncate_file: missing file name");
+        error ("gnu_history::truncate_file: missing filename");
     }
 }
 
 string_vector
 gnu_history::do_list (int limit, bool number_lines) const
 {
   string_vector retval;
 
@@ -487,17 +487,17 @@ gnu_history::do_clean_up_and_save (const
           if (n < 0)
             n = xsize;
 
           stifle (n);
 
           do_write (f.c_str ());
         }
       else
-        error ("gnu_history::clean_up_and_save: missing file name");
+        error ("gnu_history::clean_up_and_save: missing filename");
     }
 }
 
 #endif
 
 bool
 command_history::instance_ok (void)
 {
@@ -915,38 +915,38 @@ command_history::do_goto_mark (void)
 {
   return 0;
 }
 
 void
 command_history::do_read (const std::string& f, bool)
 {
   if (f.empty ())
-    error ("command_history::read: missing file name");
+    error ("command_history::read: missing filename");
 }
 
 void
 command_history::do_read_range (const std::string& f, int, int, bool)
 {
   if (f.empty ())
-    error ("command_history::read_range: missing file name");
+    error ("command_history::read_range: missing filename");
 }
 
 void
 command_history::do_write (const std::string& f_arg) const
 {
   if (initialized)
     {
       std::string f = f_arg;
 
       if (f.empty ())
         f = xfile;
 
       if (f.empty ())
-        error ("command_history::write: missing file name");
+        error ("command_history::write: missing filename");
     }
 }
 
 void
 command_history::do_append (const std::string& f_arg)
 {
   if (initialized)
     {
@@ -957,34 +957,34 @@ command_history::do_append (const std::s
               // Create file if it doesn't already exist.
 
               std::string f = f_arg;
 
               if (f.empty ())
                 f = xfile;
 
               if (f.empty ())
-                error ("command_history::append: missing file name");
+                error ("command_history::append: missing filename");
             }
         }
     }
 }
 
 void
 command_history::do_truncate_file (const std::string& f_arg, int) const
 {
   if (initialized)
     {
       std::string f = f_arg;
 
       if (f.empty ())
         f = xfile;
 
       if (f.empty ())
-        error ("command_history::truncate_file: missing file name");
+        error ("command_history::truncate_file: missing filename");
     }
 }
 
 string_vector
 command_history::do_list (int, bool) const
 {
   return string_vector ();
 }
@@ -1006,17 +1006,17 @@ command_history::do_clean_up_and_save (c
   if (initialized)
     {
       std::string f = f_arg;
 
       if (f.empty ())
         f = xfile;
 
       if (f.empty ())
-        error ("command_history::clean_up_and_save: missing file name");
+        error ("command_history::clean_up_and_save: missing filename");
     }
 }
 
 void
 command_history::error (int err_num, const std::string& msg) const
 {
   if (msg.empty ())
     (*current_liboctave_error_handler) ("%s", gnulib::strerror (err_num));
diff --git a/liboctave/util/cmd-hist.h b/liboctave/util/cmd-hist.h
--- a/liboctave/util/cmd-hist.h
+++ b/liboctave/util/cmd-hist.h
@@ -200,17 +200,17 @@ protected:
   virtual void do_replace_entry (int, const std::string&);
 
   virtual void do_clean_up_and_save (const std::string&, int);
 
   void error (int, const std::string& msg = "") const;
 
   void error (const std::string&) const;
 
-  // TRUE means we have initialized the history file name and number of
+  // TRUE means we have initialized the history filename and number of
   // lines to save.
   bool initialized;
 
   // TRUE means we are ignoring new additions.
   bool ignoring_additions;
 
   // Bitmask for history control options.  See oct-rl-hist.h.
   int history_control;
diff --git a/scripts/deprecated/octave_tmp_file_name.m b/scripts/deprecated/octave_tmp_file_name.m
--- a/scripts/deprecated/octave_tmp_file_name.m
+++ b/scripts/deprecated/octave_tmp_file_name.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Built-in Function} {@var{fname} =} octave_tmp_file_name ()
 ## @deftypefnx {Built-in Function} {@var{fname} =} octave_tmp_file_name (@var{dir})
 ## @deftypefnx {Built-in Function} {@var{fname} =} octave_tmp_file_name (@var{dir}, @var{prefix})
 ##
 ## @code{octave_tmp_file_name} is deprecated and will be removed in Octave
 ## version 4.4.  Use @code{tempname} for equivalent functionality.
 ##
-## Return a unique temporary file name as a string.
+## Return a unique temporary filename as a string.
 ##
 ## If @var{prefix} is omitted, a value of @qcode{"oct-"} is used.
 ## If @var{dir} is also omitted, the default directory for temporary files
 ## (@code{P_tmpdir} is used.  If @var{dir} is provided, it must exist,
 ## otherwise the default directory for temporary files is used.
 ## @seealso{tempname, tmpnam, mkstemp, tempdir, P_tmpdir, tmpfile}
 ## @end deftypefn
 
diff --git a/scripts/gui/uigetfile.m b/scripts/gui/uigetfile.m
--- a/scripts/gui/uigetfile.m
+++ b/scripts/gui/uigetfile.m
@@ -70,17 +70,17 @@ function [retfile, retpath, retindex] = 
 
   if (nargin > 7)
     error ("uigetfile: number of input arguments must be less than eight");
   endif
 
   ## Preset default values
   outargs = {cell(0, 2),         # File Filter
              "Open File",        # Dialog Title
-             "",                 # Default file name
+             "",                 # Default filename
              [240, 120],         # Dialog Position (pixel x/y)
              "off",              # MultiSelect on/off
              pwd};               # Default directory
 
   idx1 = idx2 = [];
   if (length (varargin) > 0)
     for i = 1 : length (varargin)
       val = varargin{i};
diff --git a/scripts/gui/uiputfile.m b/scripts/gui/uiputfile.m
--- a/scripts/gui/uiputfile.m
+++ b/scripts/gui/uiputfile.m
@@ -60,17 +60,17 @@ function [retfile, retpath, retindex] = 
 
   if (nargin > 3)
     print_usage ();
   endif
 
   ## Preset default values
   outargs = {cell(0, 2),     # File Filter
              "Save File",    # Dialog Title
-             "",             # Default file name
+             "",             # Default filename
              [240, 120],     # Dialog Position (pixel x/y)
              "create",
              pwd};           # Default directory
 
   if (nargin > 0)
     file_filter = varargin{1};
     [outargs{1}, outargs{3}, defdir] = __file_filter__ (file_filter);
     if (length (defdir) > 0)
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -30,17 +30,17 @@
 ## If @var{limits} is a 2-element vector @code{[@var{low}, @var{high}]}, the
 ## image is shown using a display range between @var{low} and @var{high}.  If
 ## an empty matrix is passed for @var{limits}, the display range is computed
 ## as the range between the minimal and the maximal value in the image.
 ##
 ## If @var{map} is a valid color map, the image will be shown as an indexed
 ## image using the supplied color map.
 ##
-## If a file name is given instead of an image, the file will be read and shown.
+## If a filename is given instead of an image, the file will be read and shown.
 ##
 ## If given, the parameter @var{string_param1} has value @var{value1}.
 ## @var{string_param1} can be any of the following:
 ##
 ## @table @asis
 ## @item @qcode{"displayrange"}
 ## @var{value1} is the display range as described above.
 ##
diff --git a/scripts/image/private/imageIO.m b/scripts/image/private/imageIO.m
--- a/scripts/image/private/imageIO.m
+++ b/scripts/image/private/imageIO.m
@@ -91,17 +91,17 @@ function varargout = imageIO (func, core
     if (! isempty (varargin) && ischar (varargin{1}))
       fmt = imformats (varargin{1});
       if (numfields (fmt) > 0)
         foo = fmt.(fieldname);
         varargin(1) = []; # remove format name from arguments
       endif
     endif
 
-    ## try extension from file name
+    ## try extension from filename
     if (isempty (foo))
       [~, ~, ext] = fileparts (fn);
       if (! isempty (ext))
         ## remove dot from extension
         ext = ext(2:end);
       endif
       fmt = imformats (ext);
       if (numfields (fmt) > 0)
diff --git a/scripts/io/dlmwrite.m b/scripts/io/dlmwrite.m
--- a/scripts/io/dlmwrite.m
+++ b/scripts/io/dlmwrite.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} dlmwrite (@var{file}, @var{M})
 ## @deftypefnx {Function File} {} dlmwrite (@var{file}, @var{M}, @var{delim}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} dlmwrite (@var{file}, @var{M}, @var{key}, @var{val} @dots{})
 ## @deftypefnx {Function File} {} dlmwrite (@var{file}, @var{M}, "-append", @dots{})
 ## @deftypefnx {Function File} {} dlmwrite (@var{fid}, @dots{})
 ## Write the matrix @var{M} to the named file using delimiters.
 ##
-## @var{file} should be a file name or writable file ID given by @code{fopen}.
+## @var{file} should be a filename or writable file ID given by @code{fopen}.
 ##
 ## The parameter @var{delim} specifies the delimiter to use to separate values
 ## on a row.
 ##
 ## The value of @var{r} specifies the number of delimiter-only lines to add to
 ## the start of the file.
 ##
 ## The value of @var{c} specifies the number of delimiters to prepend to each
diff --git a/scripts/io/importdata.m b/scripts/io/importdata.m
--- a/scripts/io/importdata.m
+++ b/scripts/io/importdata.m
@@ -87,17 +87,17 @@ function [output, delimiter, header_rows
   if (nargin > 2)
     if (! isnumeric (header_rows) || header_rows < 0
         || header_rows != fix (header_rows))
       error ("importdata: HEADER_ROWS must be an integer >= 0");
     endif
   endif
 
   ## Check file format
-  ## Get the extension from the file name.
+  ## Get the extension from the filename.
   [~, ~, ext, ~] = fileparts (fname);
   ext = lower (ext);
 
   switch (ext)
     case {".au", ".snd", ".flac", ".ogg"}
       error ("importdata: not implemented for file format %s", ext);
     case {".avi", ".mj2", ".mpg", ".asf", ".asx", ".wmv", ".mp4", ".m4v", ...
           ".mov"}
diff --git a/scripts/miscellaneous/copyfile.m b/scripts/miscellaneous/copyfile.m
--- a/scripts/miscellaneous/copyfile.m
+++ b/scripts/miscellaneous/copyfile.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{status}, @var{msg}, @var{msgid}] =} copyfile (@var{f1}, @var{f2})
 ## @deftypefnx {Function File} {[@var{status}, @var{msg}, @var{msgid}] =} copyfile (@var{f1}, @var{f2}, 'f')
 ## Copy the source files or directories @var{f1} to the destination @var{f2}.
 ##
 ## The name @var{f1} may contain globbing patterns.  If @var{f1} expands to
-## multiple file names, @var{f2} must be a directory.
+## multiple filenames, @var{f2} must be a directory.
 ##
 ## When the force flag @qcode{'f'} is given any existing files will be
 ## overwritten without prompting.
 ##
 ## If successful, @var{status} is 1, and @var{msg}, @var{msgid} are empty
 ## character strings ("").  Otherwise, @var{status} is 0, @var{msg} contains a
 ## system-dependent error message, and @var{msgid} contains a unique message
 ## identifier.  Note that the status code is exactly opposite that of the
@@ -74,17 +74,17 @@ function [status, msg, msgid] = copyfile
   endif
 
   ## If f1 has more than 1 element then f2 must be a directory
   isdir = (exist (f2, "dir") != 0);
   if (numel (f1) > 1 && ! isdir)
     error ("copyfile: when copying multiple files, F2 must be a directory");
   endif
 
-  ## Protect the file name(s).
+  ## Protect the filename(s).
   f1 = glob (f1);
   if (isempty (f1))
     error ("copyfile: no files to move");
   endif
   p1 = sprintf ('"%s" ', f1{:});
   p2 = tilde_expand (f2);
 
   if (isdir && length (p1) > max_cmd_line)
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -134,31 +134,31 @@ function ret = edit (varargin)
                                 "EDITINPLACE", false);
   ## Make sure the stateval variables survive "clear functions".
   mlock;
 
   ## Get default editor every time in case the user has changed it
   FUNCTION.EDITOR = [EDITOR() " %s"];
 
   if (nargin == 1)
-    ## User has supplied one arg, this can be a single file name
+    ## User has supplied one arg, this can be a single filename
     ## or a cell array of strings containing multiple files to be opened
     if (iscellstr (varargin{1}))
       ## If first arg is a cell array of strings,
       ## it becomes the list of files to be edited
       editfilelist = varargin{1};
     elseif (ischar (varargin{1}))
       ## If first arg is a string, create a cell array of strings
       ## of length 1 (by copying the input cell array)
       editfilelist = varargin(1);
     else
       error ("edit: file NAME must be a string or cell array of strings");
     endif
   elseif (nargin == 2)
-    ## User has supplied two arguments, these could be two file names,
+    ## User has supplied two arguments, these could be two filenames,
     ## or a combination of editor state name and new value for that state,
     ## so first check for the various states
     statevar = varargin{1};
     stateval = varargin{2};
     switch (toupper (statevar))
       case "EDITOR"
         error ("Octave:deprecated-function",
                "The EDITOR option of edit has been removed.  Use EDITOR() directly.")
@@ -201,17 +201,17 @@ function ret = edit (varargin)
         if (isfield (FUNCTION, toupper (stateval)))
           ret = FUNCTION.(toupper (stateval));
         else
           ret = FUNCTION;
         endif
         return;
       otherwise
         ## If none of the states match, assume both inputs are actually
-        ## file names to be opened.
+        ## filenames to be opened.
         editfilelist = varargin;
     endswitch
   elseif (nargin > 2)
     if (iscellstr (varargin))
       editfilelist = varargin;
     else
       error ("edit: if supplying more than one input all inputs must be strings containing field names to open.");
     endif
@@ -237,17 +237,17 @@ function ret = edit (varargin)
 
     ## Call edit on each of the files in the list if there are more than 1
     for i = 1:numel (editfilelist)
       edit (editfilelist{i});
     endfor
 
   else
 
-    ## Only one file name was supplied, get it from the cell array
+    ## Only one filename was supplied, get it from the cell array
     file = tilde_expand (editfilelist{1});
 
     ## Check whether the user is trying to edit a builtin or compiled function.
     switch (exist (file))
       case {3, 5}
         error ("edit: unable to edit a built-in or compiled function");
     endswitch
 
@@ -264,17 +264,17 @@ function ret = edit (varargin)
     ##
     ## This functionality is needed for other functions as well (at least
     ## help and type; there may be more).  So the place to fix that is in
     ## file_in_loadpath, possibly with some help from the load_path class.
 
     ## The code below includes a portion that serves as a place-holder for
     ## the changes suggested above.
 
-    ## Create list of explicit and implicit file names.
+    ## Create list of explicit and implicit filenames.
     filelist = {file};
     ## If file has no extension, add file.m and file.cc to the list.
     idx = rindex (file, ".");
     if (idx == 0)
       if (isempty (regexp (file, '\.m$')))
         ## No ".m" at the end of the file, add to the list.
         filelist(end+1) = [file ".m"];
       endif
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -26,17 +26,17 @@
 ## application.
 ##
 ## @code{mkoctfile} can be called from the shell prompt or from the Octave
 ## prompt.  Calling it from the Octave prompt simply delegates the call to
 ## the shell prompt.  The output is stored in the @var{output} variable and
 ## the exit status in the @var{status} variable.
 ##
 ## @code{mkoctfile} accepts the following options, all of which are optional
-## except for the file name of the code you wish to compile:
+## except for the filename of the code you wish to compile:
 ##
 ## @table @samp
 ## @item -I DIR
 ## Add the include directory DIR to compile commands.
 ##
 ## @item -D DEF
 ## Add the definition DEF to the compiler call.
 ##
@@ -64,17 +64,17 @@
 ## @item -c
 ## Compile but do not link.
 ##
 ## @item -g
 ## Enable debugging options for compilers.
 ##
 ## @item  -o FILE
 ## @itemx --output FILE
-## Output file name.  Default extension is .oct (or .mex if @samp{--mex} is
+## Output filename.  Default extension is .oct (or .mex if @samp{--mex} is
 ## specified) unless linking a stand-alone executable.
 ##
 ## @item  -p VAR
 ## @itemx --print VAR
 ## Print the configuration variable VAR@.  Recognized variables are:
 ##
 ## @example
 ##    ALL_CFLAGS                  INCFLAGS
diff --git a/scripts/miscellaneous/movefile.m b/scripts/miscellaneous/movefile.m
--- a/scripts/miscellaneous/movefile.m
+++ b/scripts/miscellaneous/movefile.m
@@ -19,19 +19,19 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} movefile (@var{f1})
 ## @deftypefnx {Function File} {} movefile (@var{f1}, @var{f2})
 ## @deftypefnx {Function File} {} movefile (@var{f1}, @var{f2}, 'f')
 ## @deftypefnx {Function File} {[@var{status}, @var{msg}, @var{msgid}] =} movefile (@dots{})
 ## Move the source files or directories @var{f1} to the destination @var{f2}.
 ##
 ## The name @var{f1} may contain globbing patterns.  If @var{f1} expands to
-## multiple file names, @var{f2} must be a directory.  If no destination
+## multiple filenames, @var{f2} must be a directory.  If no destination
 ## @var{f2} is specified then the destination is the present working directory.
-## If @var{f2} is a file name then @var{f1} is renamed to @var{f2}.
+## If @var{f2} is a filename then @var{f1} is renamed to @var{f2}.
 ##
 ## When the force flag @qcode{'f'} is given any existing files will be
 ## overwritten without prompting.
 ##
 ## If successful, @var{status} is 1, and @var{msg}, @var{msgid} are empty
 ## character strings ("").  Otherwise, @var{status} is 0, @var{msg} contains a
 ## system-dependent error message, and @var{msgid} contains a unique message
 ## identifier.  Note that the status code is exactly opposite that of the
@@ -81,17 +81,17 @@ function [status, msg, msgid] = movefile
   endif
 
   ## If f1 has more than 1 element f2 must be a directory
   isdir = (exist (f2, "dir") != 0);
   if (numel (f1) > 1 && ! isdir)
     error ("movefile: when moving multiple files, F2 must be a directory");
   endif
 
-  ## Protect the file name(s).
+  ## Protect the filename(s).
   f1 = glob (f1);
   if (isempty (f1))
     error ("movefile: no files to move");
   endif
   p1 = sprintf ('"%s" ', f1{:});
   p2 = tilde_expand (f2);
 
   if (isdir && length (p1) > max_cmd_line)
diff --git a/scripts/miscellaneous/open.m b/scripts/miscellaneous/open.m
--- a/scripts/miscellaneous/open.m
+++ b/scripts/miscellaneous/open.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{output} =} open @var{file}
 ## @deftypefnx {Function File} {@var{output} =} open (@var{file})
 ## Open the file @var{file} in Octave or in an external application based on
-## the file type as determined by the file name extension.
+## the file type as determined by the filename extension.
 ##
 ## Recognized file types are
 ##
 ## @table @code
 ## @item .m
 ## Open file in the editor.
 ##
 ## @item .mat
diff --git a/scripts/miscellaneous/perl.m b/scripts/miscellaneous/perl.m
--- a/scripts/miscellaneous/perl.m
+++ b/scripts/miscellaneous/perl.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{output} =} perl (@var{scriptfile})
 ## @deftypefnx {Function File} {@var{output} =} perl (@var{scriptfile}, @var{argument1}, @var{argument2}, @dots{})
 ## @deftypefnx {Function File} {[@var{output}, @var{status}] =} perl (@dots{})
 ## Invoke Perl script @var{scriptfile}, possibly with a list of command line
 ## arguments.
 ##
 ## Return output in @var{output} and optional status in @var{status}.  If
-## @var{scriptfile} is not an absolute file name it is searched for in the
+## @var{scriptfile} is not an absolute filename it is searched for in the
 ## current directory and then in the Octave loadpath.
 ## @seealso{system, python}
 ## @end deftypefn
 
 function [output, status] = perl (scriptfile = "-e ''", varargin)
 
   ## VARARGIN is intialized to {}(1x0) if no additional arguments are
   ## supplied, so there is no need to check for it, or provide an
diff --git a/scripts/miscellaneous/python.m b/scripts/miscellaneous/python.m
--- a/scripts/miscellaneous/python.m
+++ b/scripts/miscellaneous/python.m
@@ -20,17 +20,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{output} =} python (@var{scriptfile})
 ## @deftypefnx {Function File} {@var{output} =} python (@var{scriptfile}, @var{argument1}, @var{argument2}, @dots{})
 ## @deftypefnx {Function File} {[@var{output}, @var{status}] =} python (@dots{})
 ## Invoke Python script @var{scriptfile}, possibly with a list of command line
 ## arguments.
 ##
 ## Return output in @var{output} and optional status in @var{status}.  If
-## @var{scriptfile} is not an absolute file name it is searched for in the
+## @var{scriptfile} is not an absolute filename it is searched for in the
 ## current directory and then in the Octave loadpath.
 ## @seealso{system, perl}
 ## @end deftypefn
 
 ## Author: Carn Draug <carandraug+dev@gmail.com>
 
 function [output, status] = python (scriptfile = "-c ''", varargin)
 
diff --git a/scripts/miscellaneous/run.m b/scripts/miscellaneous/run.m
--- a/scripts/miscellaneous/run.m
+++ b/scripts/miscellaneous/run.m
@@ -20,17 +20,17 @@
 ## @deftypefn  {Command} {} run @var{script}
 ## @deftypefnx {Function File} {} run ("@var{script}")
 ## Run @var{script} in the current workspace.
 ##
 ## Scripts which reside in directories specified in Octave's load path, and
 ## which end with the extension @file{".m"}, can be run simply by typing
 ## their name.  For scripts not located on the load path, use @code{run}.
 ##
-## The file name @var{script} can be a bare, fully qualified, or relative
+## The filename @var{script} can be a bare, fully qualified, or relative
 ## filename and with or without a file extension.  If no extension is specified,
 ## Octave will first search for a script with the @file{".m"} extension before
 ## falling back to the script name without an extension.
 ##
 ## Implementation Note: If @var{script} includes a path component, then
 ## @code{run} first changes the working directory to the directory where
 ## @var{script} is found.  Next, the script is executed.  Finally, @code{run}
 ## returns to the original working directory unless @code{script} has
diff --git a/scripts/miscellaneous/tmpnam.m b/scripts/miscellaneous/tmpnam.m
--- a/scripts/miscellaneous/tmpnam.m
+++ b/scripts/miscellaneous/tmpnam.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{fname} =} tmpnam ()
 ## @deftypefnx {Function File} {@var{fname} =} tmpnam (@var{dir})
 ## @deftypefnx {Function File} {@var{fname} =} tmpnam (@var{dir}, @var{prefix})
-## Return a unique temporary file name as a string.
+## Return a unique temporary filename as a string.
 ##
 ## If @var{prefix} is omitted, a value of @qcode{"oct-"} is used.
 ##
 ## If @var{dir} is also omitted, the default directory for temporary files
 ## (@code{P_tmpdir} is used.  If @var{dir} is provided, it must exist,
 ## otherwise the default directory for temporary files is used.
 ##
 ## Programming Note: Because the named file is not opened by @code{tmpnam},
diff --git a/scripts/miscellaneous/unpack.m b/scripts/miscellaneous/unpack.m
--- a/scripts/miscellaneous/unpack.m
+++ b/scripts/miscellaneous/unpack.m
@@ -291,17 +291,17 @@ function files = __parse_gzip__ (output)
 
   files = regexprep (output, '^.+ with (.*)$', '$1');
 endfunction
 
 function files = __parse_bzip2__ (output)
   ## Parse the output from bzip2 and bunzip2 returning the files
   ## commpressed (or decompressed).
 
-  ## Strip leading blanks and .bz2 extension from file name
+  ## Strip leading blanks and .bz2 extension from filename
   files = regexprep (output, '^\s+(.*)\.bz2: .*', '$1');
 endfunction
 
 
 %!test
 %! ## Create temporary directory and file for packing and unpacking
 %! dirname = tempname ();
 %! assert (mkdir (dirname));
diff --git a/scripts/optimization/fminsearch.m b/scripts/optimization/fminsearch.m
--- a/scripts/optimization/fminsearch.m
+++ b/scripts/optimization/fminsearch.m
@@ -145,17 +145,17 @@ function [stopit, savit, dirn, trace, to
   else
     stopit(5) = 0;
   endif
   trace = stopit(5);
 
   ## Use function to minimize, not maximize
   stopit(6) = dirn = -1;
 
-  ## File name for snapshots.
+  ## Filename for snapshots.
   savit = [];  # FIXME: expose this parameter to the outside
 
 endfunction
 
 function [x, fmax, nf] = nmsmax (fun, x, options, savit, varargin)
 
   [stopit, savit, dirn, trace, tol, maxiter] = parse_options (options, x);
 
diff --git a/scripts/pkg/private/configure_make.m b/scripts/pkg/private/configure_make.m
--- a/scripts/pkg/private/configure_make.m
+++ b/scripts/pkg/private/configure_make.m
@@ -98,17 +98,17 @@ function configure_make (desc, packdir, 
     endif
 
     ## Copy files to "inst" and "inst/arch" (this is instead of 'make
     ## install').
     files = fullfile (src, "FILES");
     instdir = fullfile (packdir, "inst");
     archdir = fullfile (packdir, "inst", getarch ());
 
-    ## Get file names.
+    ## Get filenames.
     if (exist (files, "file"))
       [fid, msg] = fopen (files, "r");
       if (fid < 0)
         error ("couldn't open %s: %s", files, msg);
       endif
       filenames = char (fread (fid))';
       fclose (fid);
       if (filenames(end) == "\n")
diff --git a/scripts/plot/util/print.m b/scripts/plot/util/print.m
--- a/scripts/plot/util/print.m
+++ b/scripts/plot/util/print.m
@@ -21,19 +21,19 @@
 ## @deftypefnx {Function File} {} print (@var{options})
 ## @deftypefnx {Function File} {} print (@var{filename}, @var{options})
 ## @deftypefnx {Function File} {} print (@var{h}, @var{filename}, @var{options})
 ## Print a plot, or save it to a file.
 ##
 ## Both output formatted for printing (PDF and PostScript), and many bitmapped
 ## and vector image formats are supported.
 ##
-## @var{filename} defines the name of the output file.  If the file name has
+## @var{filename} defines the name of the output file.  If the filename has
 ## no suffix, one is inferred from the specified device and appended to the
-## file name.  If no filename is specified, the output is sent to the
+## filename.  If no filename is specified, the output is sent to the
 ## printer.
 ##
 ## @var{h} specifies the handle of the figure to print.  If no handle is
 ## specified the current figure is used.
 ##
 ## For output to a printer, PostScript file, or PDF file, the paper size is
 ## specified by the figure's @code{papersize} property.  The location and
 ## size of the image on the page are specified by the figure's
diff --git a/scripts/plot/util/private/__print_parse_opts__.m b/scripts/plot/util/private/__print_parse_opts__.m
--- a/scripts/plot/util/private/__print_parse_opts__.m
+++ b/scripts/plot/util/private/__print_parse_opts__.m
@@ -324,24 +324,24 @@ function arg_st = __print_parse_opts__ (
     arg_st.ghostscript.epscrop = ! arg_st.loose;
   endif
 
   if (arg_st.send_to_printer)
     if (isempty (arg_st.name))
       ## Pipe the ghostscript output
       arg_st.name = "-";
     else
-      error ("print: a file name may not specified when spooling to a printer")
+      error ("print: a filename may not specified when spooling to a printer")
     endif
     if (! any (strcmp (arg_st.devopt, gs_device_list)))
       ## Only supported ghostscript devices
       error ("print: format must be a valid Ghostscript format for spooling to a printer")
     endif
   elseif (isempty (arg_st.name))
-    error ("print: an output file name must be specified")
+    error ("print: an output filename must be specified")
   endif
 
   if (isempty (arg_st.canvas_size))
     if (isfigure (arg_st.figure))
       [arg_st.ghostscript.papersize, paperposition] = ...
                            gs_papersize (arg_st.figure, arg_st.orientation);
     else
       ## allows tests to be run
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -184,17 +184,17 @@ function [__n, __nmax, __nxfail, __nskip
     __demo_idx = [];
   elseif (strcmp (__flag, "explain"))
     fprintf (__fid, "# %s new test file\n", __signal_file);
     fprintf (__fid, "# %s no tests in file\n", __signal_empty);
     fprintf (__fid, "# %s test had an unexpected result\n", __signal_fail);
     fprintf (__fid, "# %s test was skipped\n", __signal_skip);
     fprintf (__fid, "# %s code for the test\n\n", __signal_block);
     fprintf (__fid, "# Search for the unexpected results in the file\n");
-    fprintf (__fid, "# then page back to find the file name which caused it.\n");
+    fprintf (__fid, "# then page back to find the filename which caused it.\n");
     fprintf (__fid, "# The result may be an unexpected failure (in which\n");
     fprintf (__fid, "# case an error will be reported) or an unexpected\n");
     fprintf (__fid, "# success (in which case no error will be reported).\n");
     fflush (__fid);
     if (__close_fid)
       fclose (__fid);
     endif
     return;
diff --git a/src/main.in.cc b/src/main.in.cc
--- a/src/main.in.cc
+++ b/src/main.in.cc
@@ -431,17 +431,17 @@ main (int argc, char **argv)
   bool gui_libs = true;
 
   std::string octave_bindir = get_octave_bindir ();
   std::string octave_archlibdir = get_octave_archlibdir ();
 
 #if defined (HAVE_OCTAVE_GUI)
   // The Octave version number is already embedded in the
   // octave_archlibdir directory name so we don't need to append it to
-  // the octave-gui file name.
+  // the octave-gui filename.
 
   std::string file = octave_archlibdir + dir_sep_char + "octave-gui";
 #else
   std::string file
     = octave_bindir + dir_sep_char + "octave-cli-" OCTAVE_VERSION;
 #endif
 
   char **new_argv = new char * [argc + 1];
diff --git a/src/mkoctfile.in.cc b/src/mkoctfile.in.cc
--- a/src/mkoctfile.in.cc
+++ b/src/mkoctfile.in.cc
@@ -251,17 +251,17 @@ static std::string help_msg =
 "  -RDIR                   Add -RDIR to link command.\n"
 "\n"
 "  -Wl,...                 Pass flags though the linker like -Wl,-rpath=...\n"
 "\n"
 "  -W...                   Pass flags though the compiler like -Wa,OPTION.\n"
 "\n"
 "  -c, --compile           Compile, but do not link.\n"
 "\n"
-"  -o FILE, --output FILE  Output file name.  Default extension is .oct\n"
+"  -o FILE, --output FILE  Output filename.  Default extension is .oct\n"
 "                          (or .mex if --mex is specified) unless linking\n"
 "                          a stand-alone executable.\n"
 "\n"
 "  -g                      Enable debugging options for compilers.\n"
 "\n"
 "  -p VAR, --print VAR     Print configuration variable VAR.  Recognized\n"
 "                          variables are:\n"
 "\n"
@@ -498,17 +498,17 @@ main (int argc, char **argv)
       else if (arg == "-o" || arg == "-output" || arg == "--output")
         {
           if (i < argc-1)
             {
               arg = argv[++i];
               outputfile = arg;
             }
           else
-            std::cerr << "mkoctfile: output file name missing" << std::endl;
+            std::cerr << "mkoctfile: output filename missing" << std::endl;
         }
       else if (arg == "-p" || arg == "-print" || arg == "--print")
         {
           if (i < argc-1)
             {
               arg = argv[++i];
               std::cout << vars[arg] << std::endl;
               return 0;
diff --git a/src/module.mk b/src/module.mk
--- a/src/module.mk
+++ b/src/module.mk
@@ -218,17 +218,17 @@ make-version-links:
 
 remove-version-links:
 	for f in $(notdir $(basename $(bin_PROGRAMS))); do \
 	  rm -f $(DESTDIR)$(bindir)/$$f-$(version)$(EXEEXT); \
 	done
 
 .PHONY: make-version-links remove-version-links
 
-## We need these file names in the build tree because the wrapper
+## We need these filenames in the build tree because the wrapper
 ## program (main.cc) will try to invoke the versioned binaries.
 
 src/octave-cli-$(version)$(EXEEXT): src/octave-cli$(EXEEXT)
 	$(AM_V_GEN)rm -f $@ && \
 	cd $(@D) && $(LN_S) $(<F) $(@F)
 
 src/octave-gui-$(version)$(EXEEXT): src/octave-gui$(EXEEXT)
 	$(AM_V_GEN)rm -f $@ && \
