# HG changeset patch
# User Michael Goffioul <michael.goffioul@gmail.com>
# Date 1357087337 18000
#      Tue Jan 01 19:42:17 2013 -0500
# Branch classdef
# Node ID 5e5705b3e505c4f87dfeb72012132e9d7732be03
# Parent  622f3f794162db52ee56487e50c90b6ae8358e04
Implement some embryonic handle-classdef semantic.

* libinterp/octave-value/ov-classdef.h (cdef_object_rep::subsasgn,
handle_cdef_object::subsasgn, octave_classdef::subsasgn): New method
declarations.
(handle_cdef_object::~handle_cdef_object): New destructor declaration.
(cdef_class::cdef_class_rep::handle_class): New boolean field.
(cdef_class::cdef_class_rep::cdef_class_rep): Initialize it.
(cdef_class::cdef_class_rep::mark_as_handle_class,
cdef_class::cdef_class_rep::is_handle_class, cdef_class::mark_as_handle_class,
cdef_class::is_handle_class): Manipulate it.
(cdef_class::cdef_class_rep::get_name): New method.
(cdef_class::get_name): Use it.
(cdef_class::cdef_class_rep::initialize_object,
cdef_class::cdef_class_rep::subsref_meta,
cdef_class::cdef_class_rep::run_constructor,
cdef_class::cdef_class_rep::construct, cdef_class:initialize_object,
cdef_class::subsref_meta, cdef_class::run_constructor, cdef_class::construct):
New methods.
(cdef_class::cdef_class_rep::find_method, cdef_class::find_method):
Add "local" argument.
(cdef_class::cdef_class_rep::find_names, cdef_class::find_names): Change
signature to use std::set and a boolean flag.
(cdef_class::cdef_class_rep::find_methods, cdef_class::find_methods): Change
signature to use a boolean flag as second argument.
(cdef_class::make_meta_class): New static method.
(cdef_class::get_method_function, cdef_class::get_constructor_function): New
methods.
(cdef_property::cdef_property_rep::set_value, cdef_property::set_value):
Make cdef_object argument non const.
(cdef_property::cder_property_rep::is_relative_set): New method.
(cdef_property::get_get_access, cdef_property::get_set_access): Delete methods.
(cdef_property::check_get_access, cdef_property::check_set_access):
Remove string argument.
(cdef_method::get_access): Delete method.
(cdef_method::check_access): Remove string argument.

* libinterp/octave-value/ov-classdef.cc (gripe_method_access,
gripe_property_access): Support access specified as cell array of classes.
(make_function_of_class): New static function(s).
(check_access (std::string, std::string), superclass_access): Remove static
functions.
(lookup_class): Use symbol_table when class hasn't been loaded yet.
(lookup_classes): Returns std::list<cdef_class> instead of Cell.
(class_get_superclasses, class_get_inferiorclasses): Use it.
(to_ov (const std::list<cdef_class>&)): New static function.
(get_class_context, check_access (const cdef_class&, const octave_value&)):
Likewise.
(handle_cdef_object::subsref): Use new signature of access check methods.
(property_get_defaultvalue): New built-in property accessor.
(make_class): Change signature to support multiple inheritance. Set "Sealed" to
false by default. Determine value for HandleCompatible property and handle-class
representation.
(make_property): Take cdef_class as first argument. Add DefaultValue and
HasDefault properties. Call make_function_of_class for property accessors.
(make_attribute): Take cdef_class as first argument.
(make_method): Likewise. Call make_function_of_class.
(make_method (octave_builtin::fcn)): Do no construct a function handle object.
(octave_classdef::subsasgn, handle_cdef_object::subsasgn): New method.
(class octave_classdef_proxy): New class.
(cdef_class::get_method_function): Use it, new method.
(handle_cdef_object::~handle_cdef_object): New destructor.
(cdef_class_rep::find_method): New boolean "local" argument. When true, only
look into the current class, not in superclasses.
(cdef_class_rep::find_methods): New signature.
(cdef_class_rep::get_methods): Use it.
(cdef_class_rep::find_properties): New signature.
(cdef_class_rep::get_properties): Use it.
(cdef_class_rep::find_names): New signature.
(cdef_class_rep::get_names): Use it.
(cdef_class_rep::subsref_meta, cdef_class_rep::initialize_object,
cdef_class_rep::run_constructor, cdef_class_rep::construct): New methods.
(compute_attribute_value, attribute_to_string): New static functions.
(cdef_class::make_meta_class): Change signature, non const argument.
Implement it.
(cdef_property_rep::get_value): Do not check access here.
(cdef_property_rep::set_value, cdef_property_rep::is_recursive_set): New method.
(cdef_property_rep::check_get_access, cdef_property_rep::check_set_access,
cdef_method_rep::check_access): Use static check_access utility function.
(install_classdef): Adapt to change of signature of make_class. Mark meta
classes as sealed. Add HandleCompatible property to meta.class. Add
DefaultValue and HasDefault properties to meta.property.

* libinterp/parse-tree/pt-classdef.h (tree_classdef::make_meta_class):
Change return type to (octave_function *).

* libinterp/parse-tree/pt-classdef.cc (tree_classdef::make_meta_class):
Likewise. Call cdef_class::get_constructor_function.

* libinterp/parse-tree/oct-parse.yy (parse_fcn_file): Adapt to new
signature of tree_classdef::make_meta_class.

* libinterp/octave-value/ov-fcn.h (octave_function::is_classdef_constructor):
New virtual method.

* libinterp/octave-value/ov-usr-fcn.h
(octave_user_function::class_ctor_type): New private enum.
(octave_user_function::mark_as_class_constructor,
octave_user_function::is_class_constructor): Use it.
(octave_user_function::mark_as_classdef_constructor,
octave_user_function::is_classdef_constructor): New methods.
(octave_user_function::class_constructor): Turn into class_ctor_type.

* libinterp/octave-value/of-usr-fcn.cc
(octave_user_function::octave_user_function): Initialize class_constructor.
(octave_user_function::do_multi_index_op): When function is a classdef
constructor, extract the first argument and use it to populate the first
output argument.

diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -27,40 +27,98 @@ along with Octave; see the file COPYING.
 #include <map>
 
 #include "defun.h"
 #include "ov-builtin.h"
 #include "ov-classdef.h"
 #include "ov-fcn-handle.h"
 #include "ov-typeinfo.h"
 #include "pt-classdef.h"
+#include "pt-walk.h"
+#include "symtab.h"
+#include "toplev.h"
 
 static std::map<std::string, cdef_class> all_classes;
 static std::map<std::string, cdef_package> all_packages;
 
 static void
 gripe_method_access (const std::string& from, const cdef_method& meth)
 {
+  octave_value acc = meth.get ("Access");
+  std::string acc_s;
+
+  if (acc.is_string ())
+    acc_s = acc.string_value ();
+  else
+    acc_s = "class-restricted";
+
   error ("%s: method `%s' has %s access and cannot be run in this context",
-	 from.c_str (), meth.get_name ().c_str (),
-	 meth.get_access ().c_str ());
+	 from.c_str (), meth.get_name ().c_str (), acc_s.c_str ());
 }
 
 static void
 gripe_property_access (const std::string& from, const cdef_property& prop,
 		       bool is_set = false)
 {
+  octave_value acc = prop.get (is_set ? "SetAccess" : "GetAccess");
+  std::string acc_s;
+
+  if (acc.is_string ())
+    acc_s = acc.string_value ();
+  else
+    acc_s = "class-restricted";
+
   if (is_set)
     error ("%s: property `%s' has %s access and cannot be set in this context",
-	   from.c_str (), prop.get_name ().c_str (),
-	   prop.get_set_access ().c_str ());
+	   from.c_str (), prop.get_name ().c_str (), acc_s.c_str ());
   else
     error ("%s: property `%s' has %s access and cannot be obtained in this context",
-	   from.c_str (), prop.get_name ().c_str (),
-	   prop.get_get_access ().c_str ());
+	   from.c_str (), prop.get_name ().c_str (), acc_s.c_str ());
+}
+
+static std::string
+get_base_name (const std::string& nm)
+{
+  std::string::size_type pos = nm.find_last_of ('.');
+
+  if (pos != std::string::npos)
+    return nm.substr (pos + 1);
+
+  return nm;
+}
+
+static void
+make_function_of_class (const std::string& class_name,
+                        const octave_value& fcn)
+{
+  octave_function *of = fcn.function_value ();
+
+  if (! error_state)
+    {
+      of->stash_dispatch_class (class_name);
+
+      octave_user_function *uf = of->user_function_value (true);
+
+      if (! error_state && uf)
+        {
+          if (get_base_name (class_name) == uf->name ())
+            {
+              uf->mark_as_class_constructor ();
+              uf->mark_as_classdef_constructor ();
+            }
+          else
+            uf->mark_as_class_method ();
+        }
+    }
+}
+
+static void
+make_function_of_class (const cdef_class& cls, const octave_value& fcn)
+{
+  make_function_of_class (cls.get_name (), fcn);
 }
 
 static octave_value
 make_fcn_handle (octave_builtin::fcn ff, const std::string& nm)
 {
   octave_value fcn (new octave_builtin (ff, nm));
 
   octave_value fcn_handle (new octave_fcn_handle (fcn, nm));
@@ -73,55 +131,33 @@ execute_ov (octave_value val, const octa
 {
   std::list<octave_value_list> idx (1, args);
 
   std::string type ("(");
 
   return val.subsref (type, idx, nargout);
 }
 
-static bool
-check_access (const std::string& req, const std::string& acc)
-{
-  if (req == "private")
-    return true;
-  else if (req == "protected")
-    return (acc != "private");
-  else
-    return (acc == "public");
-}
-
-static std::string
-get_base_name (const std::string& nm)
-{
-  std::string::size_type pos = nm.find_last_of ('.');
-
-  if (pos != std::string::npos)
-    return nm.substr (pos + 1);
-
-  return nm;
-}
-
-static std::string
-superclass_access (const std::string& acc)
-{
-  if (acc == "public")
-    return acc;
-  else
-    return "protected";
-}
-
 static cdef_class
 lookup_class (const std::string& name, bool error_if_not_found = true)
 {
   std::map<std::string, cdef_class>::iterator it = all_classes.find (name);
 
   if (it == all_classes.end ())
     {
-      // FIXME: should look into load-path
+      // FIXME: implement this properly
+
+      octave_value ov_cls = symbol_table::find (name);
+
+      if (ov_cls.is_defined ())
+        it = all_classes.find (name);
+    }
+
+  if (it == all_classes.end ())
+    {
       if (error_if_not_found)
 	error ("class not found: %s", name.c_str ());
     }
   else
     {
       cdef_class& cls = it->second;
 
       if (! cls.is_builtin ())
@@ -133,32 +169,48 @@ lookup_class (const std::string& name, b
 	return cls;
       else
 	all_classes.erase (it);
     }
 
   return cdef_class ();
 }
 
-static Cell
+static std::list<cdef_class>
 lookup_classes (const Cell& cls_names)
 {
-  Cell cls (cls_names.numel (), 1);
+  std::list<cdef_class> retval;
 
   for (int i = 0; i < cls_names.numel (); i++)
     {
       cdef_class c = lookup_class (cls_names(i).string_value ());
 
       if (! error_state)
-	cls(i) = to_ov (c);
+        retval.push_back (c);
       else
-	return Cell ();
+        {
+          retval.clear ();
+          break;
+        }
     }
 
-  return cls;
+  return retval;
+}
+
+static octave_value
+to_ov (const std::list<cdef_class>& class_list)
+{
+  Cell cls (class_list.size (), 1);
+  int i = 0;
+
+  for (std::list<cdef_class>::const_iterator it = class_list.begin ();
+       it != class_list.end (); ++it, ++i)
+    cls(i) = to_ov (*it);
+
+  return octave_value (cls);
 }
 
 static bool
 is_superclass (const cdef_class& clsa, const cdef_class& clsb,
 	       bool allow_equal = true)
 {
   if (allow_equal && clsa == clsb)
     return true;
@@ -194,16 +246,82 @@ class_get_properties (const octave_value
       cdef_class cls (to_cdef (args(0)));
 
       retval(0) = cls.get_properties ();
     }
 
   return retval;
 }
 
+static cdef_class
+get_class_context (void)
+{
+  cdef_class cls;
+
+  octave_function* fcn = octave_call_stack::current ();
+
+  if (fcn &&
+      (fcn->is_class_method ()
+       || fcn->is_class_constructor ()
+       || fcn->is_anonymous_function_of_class ()
+       || (fcn->is_private_function ()
+           && ! fcn->dispatch_class ().empty ())))
+    cls = lookup_class (fcn->dispatch_class ());
+
+  return cls;
+}
+
+static bool
+check_access (const cdef_class& cls, const octave_value& acc)
+{
+  if (acc.is_string ())
+    {
+      std::string acc_s = acc.string_value ();
+
+      if (acc_s == "public")
+        return true;
+
+      cdef_class ctx = get_class_context ();
+
+      if (acc_s == "private")
+        return (ctx == cls);
+      else if (acc_s == "protected")
+        return is_superclass (cls, ctx);
+      else
+        panic_impossible ();
+    }
+  else if (acc.is_cell ())
+    {
+      Cell acc_c = acc.cell_value ();
+
+      cdef_class ctx = get_class_context ();
+
+      if (ctx == cls)
+        return true;
+
+      for (int i = 0; ! error_state && i < acc.numel (); i++)
+        {
+          cdef_class acc_cls (to_cdef (acc_c(i)));
+
+          if (! error_state)
+            {
+              if (is_superclass (acc_cls, ctx))
+                return true;
+            }
+        }
+
+      return false;
+    }
+  else
+    error ("invalid property/method access in class `%s'",
+           cls.get_name ().c_str ());
+  
+  return false;
+}
+
 static octave_value_list
 class_get_methods (const octave_value_list& args, int /* nargout */)
 {
   octave_value_list retval;
 
   if (args.length () == 1 && args(0).type_name () == "object")
     {
       cdef_class cls (to_cdef (args(0)));
@@ -221,17 +339,17 @@ class_get_superclasses (const octave_val
 
   if (args.length () == 1 && args(0).type_name () == "object"
       && args(0).class_name () == "meta.class")
     {
       cdef_class cls (to_cdef (args(0)));
 
       Cell classes = cls.get ("SuperClasses").cell_value ();
 
-      retval(0) = lookup_classes (classes);
+      retval(0) = to_ov (lookup_classes (classes));
     }
 
   return retval;
 }
 
 static octave_value_list
 class_get_inferiorclasses (const octave_value_list& args, int /* nargout */)
 {
@@ -239,17 +357,17 @@ class_get_inferiorclasses (const octave_
 
   if (args.length () == 1 && args(0).type_name () == "object"
       && args(0).class_name () == "meta.class")
     {
       cdef_class cls (to_cdef (args(0)));
 
       Cell classes = cls.get ("InferiorClasses").cell_value ();
 
-      retval(0) = lookup_classes (classes);
+      retval(0) = to_ov (lookup_classes (classes));
     }
 
   return retval;
 }
 
 static octave_value_list
 class_fromName (const octave_value_list& args, int /* nargout */)
 {
@@ -284,18 +402,17 @@ class_fevalStatic (const octave_value_li
 	  std::string meth_name = args(1).string_value ();
 
 	  if (! error_state)
 	    {
 	      cdef_method meth = cls.find_method (meth_name);
 
 	      if (meth.ok ())
 		{
-		  // FIXME: can the context be something else?
-		  if (meth.check_access ("public"))
+		  if (meth.check_access ())
 		    {
 		      if (meth.is_static ())
 			retval = meth.execute (args.splice (0, 2), nargout);
 		      else
 			error ("fevalStatic: method `%s' is not static",
 			       meth_name.c_str ());
 		    }
 		  else
@@ -331,18 +448,17 @@ class_getConstant (const octave_value_li
 	  std::string prop_name = args(1).string_value ();
 
 	  if (! error_state)
 	    {
 	      cdef_property prop = cls.find_property (prop_name);
 
 	      if (prop.ok ())
 		{
-		  // FIXME: can the context be something else?
-		  if (prop.check_get_access ("public"))
+		  if (prop.check_get_access ())
 		    {
 		      if (prop.is_constant ())
 			retval(0) = prop.get_value ();
 		      else
 			error ("getConstant: property `%s' is not constant",
 			       prop_name.c_str ());
 		    }
 		  else
@@ -391,53 +507,125 @@ class_ ## OP (const octave_value_list& a
 
 META_CLASS_CMP (lt, clsb, clsa, is_strict_superclass)
 META_CLASS_CMP (le, clsb, clsa, is_superclass)
 META_CLASS_CMP (gt, clsa, clsb, is_strict_superclass)
 META_CLASS_CMP (ge, clsa, clsb, is_superclass)
 META_CLASS_CMP (eq, clsa, clsb, operator==)
 META_CLASS_CMP (ne, clsa, clsb, operator!=)
 
+octave_value_list
+property_get_defaultvalue (const octave_value_list& args, int /* nargout */)
+{
+  octave_value_list retval;
+
+  if (args.length () == 1 && args(0).type_name () == "object")
+    {
+      cdef_property prop (to_cdef (args(0)));
+
+      retval(0) = prop.get ("DefaultValue");
+
+      if (! retval(0).is_defined ())
+        error_with_id ("Octave:class:NotDefaultDefined",
+                       "no default value for property `%s'",
+                       prop.get_name ().c_str ());
+    }
+
+  return retval;
+}
+
 static octave_value_list
 handle_delete (const octave_value_list& /* args */, int /* nargout */)
 {
   octave_value_list retval;
 
   // FIXME: implement this
 
   return retval;
 }
 
 static cdef_class
-make_class (const std::string& name, const std::string& super = std::string())
+make_class (const std::string& name,
+            const std::list<cdef_class>& super_list = std::list<cdef_class> (),
+            const std::list<std::string>& super_name_list = std::list<std::string> ())
 {
   cdef_class cls ("meta.class");
 
-  all_classes[name] = cls;
   cls.put ("ConstructOnLoad", false);
   cls.put ("ContainingPackage", Matrix ());
   cls.put ("Description", std::string ());
   cls.put ("DetailedDescription", std::string ());
   cls.put ("Events", Cell ());
   cls.put ("Hidden", false);
   cls.put ("InferiorClasses", Cell ());
   cls.put ("Methods", Cell ());
   cls.put ("Name", name);
   cls.put ("Properties", Cell ());
-  cls.put ("Sealed", true);
-  if (super.empty ())
-    cls.put ("SuperClasses", Cell ());
+  cls.put ("Sealed", false);
+  if (super_name_list.size () == super_list.size ())
+    cls.put ("SuperClasses", Cell (super_name_list));
+  else
+    {
+      std::list<std::string> snamelist;
+
+      for (std::list<cdef_class>::const_iterator it = super_list.begin ();
+           it != super_list.end (); ++it)
+        snamelist.push_back (it->get_name ());
+
+      cls.put ("SuperClasses", Cell (snamelist));
+    }
+
+  if (name == "handle")
+    {
+      cls.put ("HandleCompatible", true);
+      cls.mark_as_handle_class ();
+    }
+  else if (super_list.empty ())
+    {
+      cls.put ("HandleCompatible", false);
+    }
   else
-    cls.put ("SuperClasses", Cell (octave_value (super)));
+    {
+      bool all_handle_compatible = true;
+      bool has_handle_class = false;
+
+      for (std::list<cdef_class>::const_iterator it = super_list.begin ();
+           it != super_list.end (); ++it)
+        {
+          all_handle_compatible = all_handle_compatible && it->get ("HandleCompatible").bool_value ();
+          has_handle_class = has_handle_class || it->is_handle_class ();
+        }
+
+      if (has_handle_class && ! all_handle_compatible)
+        ::error ("%s: cannot mix handle and non-HandleCompatible classes",
+                 name.c_str ());
+      else
+        {
+          cls.put ("HandleCompatible", all_handle_compatible);
+          if (has_handle_class)
+            cls.mark_as_handle_class ();
+        }
+    }
+
+  if (error_state)
+    return cdef_class ();
+
+  all_classes[name] = cls;
 
   return cls;
 }
 
+static cdef_class
+make_class (const std::string& name, const cdef_class& super)
+{
+  return make_class (name, std::list<cdef_class> (1, super));
+}
+
 static cdef_property
-make_property (const cdef_object& cls, const std::string& name,
+make_property (const cdef_class& cls, const std::string& name,
 	       const octave_value& get_method = Matrix (),
 	       const std::string& get_access = "public",
 	       const octave_value& set_method = Matrix (),
 	       const std::string& set_access = "public")
 {
   // FIXME: what about default value?
 
   cdef_property prop ("meta.property");
@@ -452,84 +640,163 @@ make_property (const cdef_object& cls, c
   prop.put ("Dependent", false);
   prop.put ("Transient", false);
   prop.put ("Hidden", false);
   prop.put ("GetObservable", false);
   prop.put ("SetObservable", false);
   prop.put ("GetMethod", get_method);
   prop.put ("SetMethod", set_method);
   prop.put ("DefiningClass", to_ov (cls));
+  prop.put ("DefaultValue", octave_value ());
+  prop.put ("HasDefault", false);
+
+  std::string class_name = cls.get_name ();
+
+  if (! get_method.is_empty ())
+    make_function_of_class (class_name, get_method);
+  if (! set_method.is_empty ())
+    make_function_of_class (class_name, set_method);
 
   return prop;
 }
 
 inline cdef_property
-make_attribute (const cdef_object& cls, const std::string& name)
+make_attribute (const cdef_class& cls, const std::string& name)
 {
   return make_property (cls, name, Matrix (), "public", Matrix (), "private");
 }
 
 static cdef_method
-make_method (const cdef_object& cls, const std::string& name, const octave_value& fcn,
-	     const std::string& m_access = "public", bool is_static = false)
+make_method (const cdef_class& cls, const std::string& name,
+             const octave_value& fcn,const std::string& m_access = "public",
+             bool is_static = false)
 {
   cdef_method meth ("meta.method");
 
   meth.put ("Abstract", false);
   meth.put ("Access", m_access);
   meth.put ("DefiningClass", to_ov (cls));
   meth.put ("Description", std::string ());
   meth.put ("DetailedDescription", std::string ());
   meth.put ("Hidden", false);
   meth.put ("Name", name);
   meth.put ("Sealed", true);
   meth.put ("Static", is_static);
 
+  make_function_of_class (cls, fcn);
+
   meth.set_function (fcn);
 
   return meth;
 }
 
 inline cdef_method
-make_method (const cdef_object& cls, const std::string& name, octave_builtin::fcn ff,
-	     const std::string& m_access = "public", bool is_static = false)
+make_method (const cdef_class& cls, const std::string& name,
+             octave_builtin::fcn ff, const std::string& m_access = "public",
+             bool is_static = false)
 {
   octave_value fcn (new octave_builtin (ff, name));
 
-  octave_value fcn_handle (new octave_fcn_handle (fcn, name));
-
-  return make_method (cls, name, fcn_handle, m_access, is_static);
+  return make_method (cls, name, fcn, m_access, is_static);
 }
 
 static cdef_package
 make_package (const std::string& nm,
               const std::string& parent = std::string ())
 {
   cdef_package pack ("meta.package");
 
   all_packages[nm] = pack;
   pack.put ("Name", nm);
   pack.put ("ContainingPackage", to_ov (all_packages[parent]));
 
   return pack;
 }
 
+//----------------------------------------------------------------------------
+
 DEFINE_OCTAVE_ALLOCATOR (octave_classdef);
 
 int octave_classdef::t_id (-1);
 
 const std::string octave_classdef::t_name ("object");
 
 void
 octave_classdef::register_type (void)
 {
   t_id = octave_value_typeinfo::register_type
     (octave_classdef::t_name, "<unknown>", octave_value (new octave_classdef ()));
 }
 
+octave_value_list
+octave_classdef::subsref (const std::string& type,
+                          const std::list<octave_value_list>& idx,
+                          int nargout)
+{
+  int skip = 0;
+  octave_value_list retval;
+
+  // FIXME: should check "subsref" method first
+
+  retval = object.subsref (type, idx, nargout, skip);
+
+  if (! error_state)
+    {
+      if (type.length () > skip && idx.size () > skip)
+	retval = retval(0).next_subsref (nargout, type, idx, skip);
+    }
+
+  return retval;
+}
+
+octave_value
+octave_classdef::subsasgn (const std::string& type,
+                           const std::list<octave_value_list>& idx,
+                           const octave_value& rhs)
+{
+  return object.subsasgn (type, idx, rhs);
+}
+
+//----------------------------------------------------------------------------
+
+class octave_classdef_proxy : public octave_function
+{
+public:
+  octave_classdef_proxy (const cdef_class& _klass)
+    : klass (_klass) { }
+
+  ~octave_classdef_proxy (void) { }
+
+  octave_value_list
+  subsref (const std::string& type,
+           const std::list<octave_value_list>& idx,
+           int nargout)
+    { return klass.subsref_meta (type, idx, nargout); }
+
+  octave_value
+  subsref (const std::string& type,
+           const std::list<octave_value_list>& idx)
+    {
+      octave_value_list retval;
+
+      retval = subsref (type, idx, 1);
+
+      return (retval.length () > 0 ? retval(0) : octave_value ());
+    }
+
+  octave_value_list
+  do_multi_index_op (int /* nargout */, const octave_value_list& /* idx */)
+    { return to_ov (klass); }
+
+private:
+  cdef_class klass;
+};
+
+//----------------------------------------------------------------------------
+
 cdef_class
 cdef_object_rep::get_class (void) const
 {
   cdef_class cls = lookup_class (class_name ());
 
   return cls;
 }
 
@@ -539,16 +806,21 @@ cdef_object_rep::map_keys (void) const
   cdef_class cls = get_class ();
 
   if (cls.ok ())
     return cls.get_names ();
   
   return string_vector ();
 }
 
+handle_cdef_object::~handle_cdef_object (void)
+{
+  printf ("deleting %s object (handle)\n", cname.c_str ());
+}
+
 octave_value_list
 handle_cdef_object::subsref (const std::string& type,
 			     const std::list<octave_value_list>& idx,
 			     int nargout, int& skip)
 {
   skip = 0;
 
   cdef_class cls = get_class ();
@@ -559,27 +831,21 @@ handle_cdef_object::subsref (const std::
     return retval;
 
   switch (type[0])
     {
     case '.':
 	{
 	  std::string name = (idx.front ())(0).string_value ();
 
-	  // FIXME: get the right context; context should also
-	  // be linked to the current executing class (if any)
-	  // such that protected/private methods found in inherited
-	  // classes are correctly resolved.
-	  std::string context = "public";
-
 	  cdef_method meth = cls.find_method (name);
 
 	  if (meth.ok ())
 	    {
-	      if (meth.check_access (context))
+	      if (meth.check_access ())
 		{
 		  int _nargout = (type.length () > 2 ? 1 : nargout);
 
 		  octave_value_list args;
 
 		  skip = 1;
 
 		  if (type.length () > 1 && type[1] == '(')
@@ -604,17 +870,17 @@ handle_cdef_object::subsref (const std::
 	    }
 
 	  if (skip == 0 && ! error_state)
 	    {
 	      cdef_property prop = cls.find_property (name);
 
 	      if (prop.ok ())
 		{
-		  if (prop.check_get_access (context))
+		  if (prop.check_get_access ())
 		    {
 		      refcount++;
 		      retval(0) = prop.get_value (cdef_object (this));
 
 		      skip = 1;
 		    }
 		  else
 		    gripe_property_access ("subsref", prop);
@@ -627,18 +893,77 @@ handle_cdef_object::subsref (const std::
     default:
       error ("object cannot be indexed with `%c'", type[0]);
       break;
     }
 
   return retval;
 }
 
+octave_value
+handle_cdef_object::subsasgn (const std::string& type,
+                              const std::list<octave_value_list>& idx,
+                              const octave_value& rhs)
+{
+  octave_value retval;
+
+  cdef_class cls = get_class ();
+
+  switch (type[0])
+    {
+    case '.':
+        {
+          std::string name = (idx.front ())(0).string_value ();
+
+          if (! error_state)
+            {
+              cdef_property prop = cls.find_property (name);
+
+              if (prop.ok ())
+                {
+                  if (type.length () == 1)
+                    {
+                      if (prop.check_set_access ())
+                        {
+                          refcount++;
+
+                          cdef_object obj (this);
+
+                          prop.set_value (obj, rhs);
+
+                          if (! error_state)
+                            retval = to_ov (obj);
+                        }
+                      else
+                        gripe_property_access ("subsasgn", prop, true);
+                    }
+                  else
+                    {
+                    }
+
+                  if (! error_state)
+                    {
+                    }
+                }
+              else
+                error ("subsasgn: unknown property: %s", name.c_str ());
+            }
+        }
+      break;
+
+    default:
+      panic_impossible ();
+      break;
+    }
+
+  return retval;
+}
+
 cdef_method
-cdef_class::cdef_class_rep::find_method (const std::string& nm)
+cdef_class::cdef_class_rep::find_method (const std::string& nm, bool local)
 {
   method_iterator it = method_map.find (nm);
 
   if (it == method_map.end ())
     {
       // FIXME: look into class directory
     }
   else
@@ -646,31 +971,34 @@ cdef_class::cdef_class_rep::find_method 
       cdef_method& meth = it->second;
 
       // FIXME: check if method reload needed
 
       if (meth.ok ())
 	return meth;
     }
 
-  // Look into superclasses
-
-  Cell super_classes = get ("SuperClasses").cell_value ();
+  if (! local)
+    {
+      // Look into superclasses
 
-  for (int i = 0; i < super_classes.numel (); i++)
-    {
-      cdef_class cls = lookup_class (super_classes(i).string_value ());
+      Cell super_classes = get ("SuperClasses").cell_value ();
 
-      if (! error_state)
-	{
-	  cdef_method meth = cls.find_method (nm);
+      for (int i = 0; i < super_classes.numel (); i++)
+        {
+          cdef_class cls = lookup_class (super_classes(i).string_value ());
 
-	  if (meth.ok ())
-	    return meth;
-	}
+          if (! error_state)
+            {
+              cdef_method meth = cls.find_method (nm);
+
+              if (meth.ok ())
+                return meth;
+            }
+        }
     }
 
   return cdef_method ();
 }
 
 void
 cdef_class::cdef_class_rep::install_method (const cdef_method& meth)
 {
@@ -683,70 +1011,76 @@ cdef_class::cdef_class_rep::load_all_met
   // FIXME: re-scan class directory
 }
 
 Cell
 cdef_class::cdef_class_rep::get_methods (void)
 {
   std::map<std::string,cdef_method> meths;
 
-  std::map<std::string,int> count;
-
-  count["public"] = count["protected"] = count["private"] = 0;
-
-  find_methods (meths, count);
+  find_methods (meths, false);
 
   if (! error_state)
     {
-      Cell c (count["public"] + count["protected"], 1);
+      Cell c (meths.size (), 1);
 
       int idx = 0;
 
       for (std::map<std::string,cdef_method>::const_iterator it = meths.begin ();
-	   it != meths.end (); ++it)
-	if (::check_access ("protected", it->second.get_access ()))
-	  c (idx++, 0) = to_ov (it->second);
+	   it != meths.end (); ++it, ++idx)
+        c (idx, 0) = to_ov (it->second);
 
       return c;
     }
 
   return Cell ();
 }
 
 void
-cdef_class::cdef_class_rep::find_methods (std::map<std::string,cdef_method>& meths,
-					  std::map<std::string,int>& count)
+cdef_class::cdef_class_rep::find_methods (std::map<std::string, cdef_method>& meths,
+                                          bool only_inherited)
 {
   load_all_methods ();
 
   method_const_iterator it;
 
+  std::string cls_name = get_base_name (get_name ());
+
   for (it = method_map.begin (); it != method_map.end (); ++it)
     {
       std::string nm = it->second.get_name ();
 
-      if (meths.find (nm) == meths.end ())
-	{
-	  std::string acc = it->second.get_access ();
+      if (nm != cls_name)
+        {
+          if (meths.find (nm) == meths.end ())
+            {
+              if (only_inherited)
+                {
+                  octave_value acc = it->second.get ("Access");
 
-	  meths[nm] = it->second;
-	  count[acc]++;
-	}
+                  if (! acc.is_string ()
+                      || acc.string_value () == "private")
+                    continue;
+                }
+
+              meths[nm] = it->second;
+            }
+        }
     }
 
   // Look into superclasses
 
   Cell super_classes = get ("SuperClasses").cell_value ();
 
   for (int i = 0; i < super_classes.numel (); i++)
     {
       cdef_class cls = lookup_class (super_classes(i).string_value ());
 
       if (! error_state)
-	cls.get_rep ()->find_methods (meths, count);
+	cls.get_rep ()->find_methods (meths, true);
       else
 	break;
     }
 }
 
 cdef_property
 cdef_class::cdef_class_rep::find_property (const std::string& nm)
 {
@@ -786,144 +1120,150 @@ cdef_class::cdef_class_rep::install_prop
   property_map[prop.get_name ()] = prop;
 }
 
 Cell
 cdef_class::cdef_class_rep::get_properties (void)
 {
   std::map<std::string,cdef_property> props;
 
-  std::map<std::string,int> count;
-
-  count["public"] = count["protected"] = count["private"] = 0;
-
-  find_properties (props, count);
+  find_properties (props, false);
 
   if (! error_state)
     {
-      Cell c (count["public"] + count["protected"], 1);
+      Cell c (props.size (), 1);
 
       int idx = 0;
 
       for (std::map<std::string,cdef_property>::const_iterator it = props.begin ();
-	   it != props.end (); ++it)
-	if (::check_access ("protected", it->second.get_get_access ()))
-	  c (idx++, 0) = to_ov (it->second);
+	   it != props.end (); ++it, ++idx)
+        c (idx, 0) = to_ov (it->second);
 
       return c;
     }
 
   return Cell ();
 }
 
 void
 cdef_class::cdef_class_rep::find_properties (std::map<std::string,cdef_property>& props,
-					     std::map<std::string,int>& count)
+                                             bool only_inherited)
 {
   property_const_iterator it;
 
-  for (it = property_map.begin (); it != property_map.end (); ++it)
+  for (it = property_map.begin (); ! error_state && it != property_map.end ();
+       ++it)
     {
       std::string nm = it->second.get_name ();
 
       if (props.find (nm) == props.end ())
 	{
-	  std::string acc = it->second.get_get_access ();
+          if (only_inherited)
+            {
+              octave_value acc = it->second.get ("GetAccess");
+
+              if (! acc.is_string ()
+                  || acc.string_value () == "private")
+                continue;
+            }
 
 	  props[nm] = it->second;
-	  count[acc]++;
 	}
     }
 
   // Look into superclasses
 
   Cell super_classes = get ("SuperClasses").cell_value ();
 
-  for (int i = 0; i < super_classes.numel (); i++)
+  for (int i = 0; ! error_state && i < super_classes.numel (); i++)
     {
       cdef_class cls = lookup_class (super_classes(i).string_value ());
 
       if (! error_state)
-	cls.get_rep ()->find_properties (props, count);
+	cls.get_rep ()->find_properties (props, true);
       else
 	break;
     }
 }
 
 void
-cdef_class::cdef_class_rep::find_names (std::map<std::string,std::string>& names,
-					std::map<std::string,int>& count)
+cdef_class::cdef_class_rep::find_names (std::set<std::string>& names,
+                                        bool all)
 {
   load_all_methods ();
 
+  std::string cls_name = get_base_name (get_name ());
+
   for (method_const_iterator it = method_map.begin ();
-       it != method_map.end(); ++it)
+       ! error_state && it != method_map.end(); ++it)
     {
       std::string nm = it->second.get_name ();
 
-      if (names.find (nm) == names.end ())
-	{
-	  std::string acc = it->second.get_access ();
+      if (nm != cls_name)
+        {
+          if (! all)
+            {
+              octave_value acc = it->second.get ("Access");
 
-	  names[nm] = acc;
-	  count[acc]++;
-	}
+              if (! acc.is_string()
+                  || acc.string_value () != "public")
+                continue;
+            }
+
+          names.insert (nm);
+        }
     }
 
   for (property_const_iterator it = property_map.begin ();
-       it != property_map.end (); ++it)
+       ! error_state && it != property_map.end (); ++it)
     {
       std::string nm = it->second.get_name ();
 
-      if (names.find (nm) == names.end ())
-	{
-	  std::string acc = it->second.get_get_access ();
+      if (! all)
+        {
+          octave_value acc = it->second.get ("GetAccess");
 
-	  names[nm] = acc;
-	  count[acc]++;
-	}
+          if (! acc.is_string()
+              || acc.string_value () != "public")
+            continue;
+        }
+
+      names.insert (nm);
     }
 
   // Look into superclasses
 
   Cell super_classes = get ("SuperClasses").cell_value ();
 
-  for (int i = 0; i < super_classes.numel (); i++)
+  for (int i = 0; ! error_state && i < super_classes.numel (); i++)
     {
       cdef_class cls = lookup_class (super_classes(i).string_value ());
 
       if (! error_state)
-	cls.get_rep ()->find_names (names, count);
+	cls.get_rep ()->find_names (names, all);
       else
 	break;
     }
 }
 
 string_vector
 cdef_class::cdef_class_rep::get_names (void)
 {
-  std::map<std::string,std::string> names;
-
-  std::map<std::string,int> count;
+  std::set<std::string> names;
 
-  count["public"] = count["protected"] = count["private"] = 0;
-
-  find_names (names, count);
+  find_names (names, false);
 
   if (! error_state)
     {
-      string_vector v (count["public"]);
+      string_vector v (names.size ());
 
       int idx = 0;
-      for (std::map<std::string,std::string>::const_iterator it = names.begin ();
-	   it != names.end (); ++it)
-	{
-	  if (it->second == "public")
-	      v[idx++] = it->first;
-	}
+      for (std::set<std::string>::const_iterator it = names.begin ();
+	   it != names.end (); ++it, ++idx)
+        v[idx] = *it;
 
       return v.sort (true);
     }
 
   return string_vector ();
 }
 
 void
@@ -952,40 +1292,371 @@ cdef_class::cdef_class_rep::delete_objec
     {
       cdef_class cls = lookup_class (super_classes(i).string_value ());
 
       if (!error_state)
 	cls.delete_object (obj);
     }
 }
 
+octave_value_list
+cdef_class::cdef_class_rep::subsref_meta (const std::string& type,
+                                          const std::list<octave_value_list>& idx,
+                                          int nargout)
+{
+  octave_value_list retval;
+
+  switch (type[0])
+    {
+    case '(':
+      // Constructor call
+      printf ("constructor\n");
+      retval(0) = construct (idx.front ());
+      break;
+    case '.':
+      // Static method, constant (or property?)
+      printf ("static method\n");
+      break;
+    }
+
+  if (! error_state)
+    {
+      if (type.length () > 1 && idx.size () > 1 && ! retval.empty ())
+	retval = retval(0).next_subsref (nargout, type, idx);
+    }
+
+  return retval;
+}
+
+void
+cdef_class::cdef_class_rep::initialize_object (cdef_object& obj)
+{
+  // Populate the object with default property values
+
+  std::list<cdef_class> super_classes = lookup_classes (get ("SuperClasses").cell_value ());
+
+  if (! error_state)
+    {
+      for (std::list<cdef_class>::iterator it = super_classes.begin ();
+           ! error_state && it != super_classes.end (); ++it)
+        it->initialize_object (obj);
+
+      if (! error_state)
+        {
+          for (property_const_iterator it = property_map.begin ();
+               ! error_state && it != property_map.end (); ++it)
+            {
+              if (! it->second.get ("Dependent").bool_value ())
+                {
+                  octave_value pvalue = it->second.get ("DefaultValue");
+
+                  if (pvalue.is_defined ())
+                    obj.put (it->first, pvalue);
+                  else
+                    obj.put (it->first, octave_value (Matrix ()));
+                }
+            }
+        }
+    }
+}
+
+void
+cdef_class::cdef_class_rep::run_constructor (cdef_object& obj,
+                                             const octave_value_list& args)
+{
+  // FIXME: Run constructors from superclasses if needed.
+  //        One must analyze the class constructor to detect
+  //        whether it explicitly calls them or not.
+
+  std::string ctor_name = get_base_name (get_name ());
+  cdef_method ctor = find_method (ctor_name);
+
+  if (ctor.ok ())
+    {
+      octave_value_list ctor_args (args);
+      octave_value_list ctor_retval;
+
+      ctor_args.prepend (to_ov (obj));
+      ctor_retval = ctor.execute (ctor_args, 1);
+
+      if (ctor_retval.length () == 1)
+        obj = to_cdef (ctor_retval(0));
+      else
+        ::error ("%s: invalid number of output arguments for classdef constructor",
+                 ctor_name.c_str ());
+    }
+}
+
+octave_value
+cdef_class::cdef_class_rep::construct (const octave_value_list& args)
+{
+  // FIXME: determine whether to use value or handle rep object
+  cdef_object obj (new handle_cdef_object (get ("Name").string_value ()));
+
+  initialize_object (obj);
+
+  if (! error_state)
+    {
+      run_constructor (obj, args);
+
+      if (! error_state)
+        return to_ov (obj);
+    }
+
+  return octave_value();
+}
+
+static octave_value
+compute_attribute_value (tree_classdef_attribute* t)
+{
+  if (t->expression ())
+    {
+      if (t->expression ()->is_identifier ())
+        {
+          std::string s = t->expression ()->name ();
+
+          if (s == "public")
+            return std::string ("public");
+          else if (s == "protected")
+            return std::string ("protected");
+          else if (s == "private")
+            return std::string ("private");
+        }
+
+      return t->expression ()->rvalue1 ();
+    }
+  else
+    return octave_value (true);
+}
+
+template<class T>
+static std::string
+attribute_value_to_string (T* t, octave_value v)
+{
+  if (v.is_string ())
+    return v.string_value ();
+  else if (t->expression ())
+    return t->expression ()->original_text ();
+  else
+    return std::string ("true");
+}
+
 cdef_class
-cdef_class::make_meta_class (const tree_classdef* t)
+cdef_class::make_meta_class (tree_classdef* t)
 {
   cdef_class retval;
+  std::string class_name;
+
+  // Class creation
+
+  class_name = t->ident ()->name ();
+  printf ("class: %s\n", class_name.c_str ());
+
+  std::list<std::string> snamelist;
+  std::list<cdef_class> slist;
+
+  if (t->superclass_list ())
+    {
+      for (tree_classdef_superclass_list::iterator it = t->superclass_list ()->begin ();
+           ! error_state && it != t->superclass_list ()->end (); ++it)
+        {
+          std::string sclass_name =
+            ((*it)->package () ? (*it)->package ()->name () + "." : std::string ())
+            + (*it)->ident ()->name ();
+
+          printf ("superclass: %s\n", sclass_name.c_str ());
+
+          cdef_class sclass = lookup_class (sclass_name);
+
+          if (! error_state)
+            {
+              if (! sclass.get ("Sealed").bool_value ())
+                {
+                  slist.push_back (sclass);
+                  snamelist.push_back (sclass_name);
+                }
+              else
+                {
+                  ::error ("`%s' cannot inherit from `%s', because it is sealed",
+                           class_name.c_str (), sclass_name.c_str ());
+                  return retval;
+                }
+            }
+          else
+            return retval;
+
+        }
+    }
+
+  retval = ::make_class (class_name, slist);
+
+  if (error_state)
+    return cdef_class ();
+
+  // FIXME: remove this...
+  if (! retval.is_handle_class ())
+    {
+      ::error ("%s: value classes not supported yet",
+               class_name.c_str ());
+      return cdef_class ();
+    }
+
+  // Class attributes
+
+  if (t->attribute_list ())
+    {
+      for (tree_classdef_attribute_list::iterator it = t->attribute_list ()->begin ();
+           it != t->attribute_list ()->end (); ++it)
+        {
+          std::string aname = (*it)->ident ()->name ();
+          octave_value avalue = compute_attribute_value (*it);
+
+          printf ("class attribute: %s = %s\n", aname.c_str (),
+                  attribute_value_to_string (*it, avalue).c_str ());
+          retval.put (aname, avalue);
+        }
+    }
+
+  tree_classdef_body* b = t->body ();
+
+  if (b)
+    {
+      // Method blocks
+
+      std::list<tree_classdef_methods_block *> mb_list = b->methods_list ();
+
+      for (tree_classdef_body::methods_list_iterator it = mb_list.begin ();
+           it != mb_list.end (); ++it)
+        {
+          std::map<std::string, octave_value> amap;
+          printf ("method block\n");
+
+          // Method attributes
+
+          if ((*it)->attribute_list ())
+            {
+              for (tree_classdef_attribute_list::iterator ait = (*it)->attribute_list ()->begin ();
+                   ait != (*it)->attribute_list ()->end (); ++ait)
+                {
+                  std::string aname = (*ait)->ident ()->name ();
+                  octave_value avalue = compute_attribute_value (*ait);
+
+                  printf ("method attribute: %s = %s\n", aname.c_str (),
+                          attribute_value_to_string (*ait, avalue).c_str ());
+                  amap[aname] = avalue;
+                }
+            }
+
+          // Methods
+
+          if ((*it)->element_list ())
+            {
+              for (tree_classdef_methods_list::iterator mit = (*it)->element_list ()->begin ();
+                   mit != (*it)->element_list ()->end (); ++mit)
+                {
+                  std::string mname = mit->function_value ()->name ();
+                  cdef_method meth = make_method (retval, mname, *mit);
+
+                  printf ("%s: %s\n", (mname == class_name ? "constructor" : "method"),
+                          mname.c_str ());
+                  for (std::map<std::string, octave_value>::iterator ait = amap.begin ();
+                       ait != amap.end (); ++ait)
+                    meth.put (ait->first, ait->second);
+
+                  retval.install_method (meth);
+                }
+            }
+        }
+
+      // Property blocks
+
+      // FIXME: default property expression should be able to call static
+      //        methods of the class being constructed. A restricted CLASSNAME
+      //        symbol should be added to the scope before evaluating default
+      //        value expressions.
+
+      std::list<tree_classdef_properties_block *> pb_list = b->properties_list ();
+
+      for (tree_classdef_body::properties_list_iterator it = pb_list.begin ();
+           it != pb_list.end (); ++it)
+        {
+          std::map<std::string, octave_value> amap;
+          printf ("property block\n");
+
+          // Property attributes
+
+          if ((*it)->attribute_list ())
+            {
+              for (tree_classdef_attribute_list::iterator ait = (*it)->attribute_list ()->begin ();
+                   ait != (*it)->attribute_list ()->end (); ++ait)
+                {
+                  std::string aname = (*ait)->ident ()->name ();
+                  octave_value avalue = compute_attribute_value (*ait);
+
+                  printf ("property attribute: %s = %s\n", aname.c_str (),
+                          attribute_value_to_string (*ait, avalue).c_str ());
+                  if (aname == "Access")
+                    {
+                      amap["GetAccess"] = avalue;
+                      amap["SetAccess"] = avalue;
+                    }
+                  else
+                    amap[aname] = avalue;
+                }
+            }
+
+          // Properties
+
+          if ((*it)->element_list ())
+            {
+              for (tree_classdef_property_list::iterator pit = (*it)->element_list ()->begin ();
+                   pit != (*it)->element_list ()->end (); ++pit)
+                {
+                  cdef_property prop = ::make_property (retval, (*pit)->ident ()->name ());
+
+                  printf ("property: %s\n", (*pit)->ident ()->name ().c_str ());
+                  if ((*pit)->expression ())
+                    {
+                      octave_value pvalue = (*pit)->expression ()->rvalue1 ();
+
+                      printf ("property default: %s\n",
+                              attribute_value_to_string (*pit, pvalue).c_str ());
+                      prop.put ("DefaultValue", pvalue);
+                    }
+
+                  for (std::map<std::string, octave_value>::iterator ait = amap.begin ();
+                       ait != amap.end (); ++ait)
+                    prop.put (ait->first, ait->second);
+
+                  retval.install_property (prop);
+                }
+            }
+        }
+    }
 
   return retval;
 }
 
+octave_function*
+cdef_class::get_method_function (const std::string& /* nm */)
+{
+  octave_classdef_proxy* p = new octave_classdef_proxy (*this);
+
+  return p;
+}
+
 octave_value
 cdef_property::cdef_property_rep::get_value (const cdef_object& obj)
 {
   // FIXME: should check whether we're already in get accessor method
 
   octave_value retval;
  
   octave_value get_fcn = get ("GetMethod");
 
-  std::string get_access = get ("GetAccess").string_value ();
-
-  if (get_access != "public")
-    {
-      // FIXME: should check the current call stack
-    }
-
   if (get_fcn.is_empty ())
     retval = obj.get (get ("Name").string_value ());
   else
     {
       octave_value_list args;
 
       args(0) = to_ov (obj);
       
@@ -994,25 +1665,74 @@ cdef_property::cdef_property_rep::get_va
       if (! error_state)
 	retval = args(0);
     }
 
   return retval;
 }
 
 bool
-cdef_property::check_get_access (const std::string& req) const
+cdef_property::cdef_property_rep::is_recursive_set (const cdef_object& /* obj */) const
+{
+  // FIXME: implement
+  return false;
+}
+
+void
+cdef_property::cdef_property_rep::set_value (cdef_object& obj,
+                                             const octave_value& val)
 {
-  return ::check_access (req, get_get_access ());
+  octave_value set_fcn = get ("SetMethod");
+
+  if (set_fcn.is_empty () || is_recursive_set (obj))
+    {
+      obj.put (get ("Name").string_value (), val);
+    }
+  else
+    {
+      octave_value_list args;
+
+      args(0) = to_ov (obj);
+      args(1) = val;
+
+      args = execute_ov (set_fcn, args, 1);
+
+      if (! error_state)
+        {
+          if (args.length() > 0)
+            {
+              cdef_object new_obj = to_cdef (args(0));
+
+              if (! error_state)
+                obj = new_obj;
+            }
+        }
+    }
 }
 
 bool
-cdef_property::check_set_access (const std::string& req) const
+cdef_property::check_get_access (void) const
 {
-  return ::check_access (req, get_set_access ());
+  cdef_class cls (to_cdef (get ("DefiningClass")));
+
+  if (! error_state)
+    return ::check_access (cls, get ("GetAccess"));
+
+  return false;
+}
+
+bool
+cdef_property::check_set_access (void) const
+{
+  cdef_class cls (to_cdef (get ("DefiningClass")));
+
+  if (! error_state)
+    return ::check_access (cls, get ("SetAccess"));
+
+  return false;
 }
 
 void
 cdef_method::cdef_method_rep::check_method (void)
 {
   // FIXME: check whether re-load is needed
 }
 
@@ -1065,19 +1785,24 @@ cdef_method::cdef_method_rep::execute (c
   else
     error ("%s: cannot execute abstract method",
 	   get ("Name").string_value ().c_str ());
 
   return retval;
 }
 
 bool
-cdef_method::check_access (const std::string& req) const
+cdef_method::check_access (void) const
 {
-  return ::check_access (req, get_access ());
+  cdef_class cls (to_cdef (get ("DefiningClass")));
+
+  if (! error_state)
+    return ::check_access (cls, get ("Access"));
+
+  return false;
 }
 
 static cdef_package
 lookup_package (const std::string& name)
 {
   std::map<std::string, cdef_package>::const_iterator it = all_packages.find (name);
 
   if (it != all_packages.end ())
@@ -1215,57 +1940,45 @@ cdef_package::cdef_package_rep::get_clas
 Cell
 cdef_package::cdef_package_rep::get_functions (void) const
 { return map2Cell (function_map); }
 
 Cell
 cdef_package::cdef_package_rep::get_packages (void) const
 { return map2Cell (package_map); }
 
-octave_value_list
-octave_classdef::subsref (const std::string& type,
-			const std::list<octave_value_list>& idx,
-			int nargout)
-{
-  int skip = 0;
-  octave_value_list retval;
-
-  // FIXME: should check "subsref" method first
-
-  retval = object.subsref (type, idx, nargout, skip);
-
-  if (! error_state)
-    {
-      if (type.length () > skip && idx.size () > skip)
-	retval = retval(0).next_subsref (nargout, type, idx, skip);
-    }
-
-  return retval;
-}
-
 void
 install_classdef (void)
 {
   octave_classdef::register_type ();
 
   /* meta classes */
   cdef_class handle = make_class ("handle");
-  cdef_class meta_class = make_class ("meta.class", "handle");
-  cdef_class meta_property = make_class ("meta.property", "handle");
-  cdef_class meta_method = make_class ("meta.method", "handle");
-  cdef_class meta_event = make_class ("meta.event", "handle");
-  cdef_class meta_package = make_class ("meta.package", "handle");
-  cdef_class meta_dynproperty = make_class ("meta.dynamicproperty", "handle");
+  cdef_class meta_class = make_class ("meta.class", handle);
+  cdef_class meta_property = make_class ("meta.property", handle);
+  cdef_class meta_method = make_class ("meta.method", handle);
+  cdef_class meta_event = make_class ("meta.event", handle);
+  cdef_class meta_package = make_class ("meta.package", handle);
+  cdef_class meta_dynproperty = make_class ("meta.dynamicproperty", handle);
+
+  /* meta classes are all sealed */
+  meta_class.put ("Sealed", true);
+  meta_property.put ("Sealed", true);
+  meta_method.put ("Sealed", true);
+  meta_event.put ("Sealed", true);
+  meta_package.put ("Sealed", true);
+  meta_dynproperty.put ("Sealed", true);
 
   /* meta.class properties */
   meta_class.install_property (make_attribute (meta_class, "ConstructOnLoad"));
   meta_class.install_property (make_property  (meta_class, "ContainingPackage"));
   meta_class.install_property (make_property  (meta_class, "Description"));
   meta_class.install_property (make_property  (meta_class, "DetailedDescription"));
   meta_class.install_property (make_property  (meta_class, "Events"));
+  meta_class.install_property (make_attribute (meta_class, "HandleCompatible"));
   meta_class.install_property (make_attribute (meta_class, "Hidden"));
   meta_class.install_property
       (make_property (meta_class, "InferiorClasses",
 		      make_fcn_handle (class_get_inferiorclasses, "meta.class>get.InferiorClasses"),
 		      "public", Matrix (), "private"));
   meta_class.install_property
       (make_property  (meta_class, "Methods",
 		       make_fcn_handle (class_get_methods, "meta.class>get.Methods"),
@@ -1328,16 +2041,21 @@ install_classdef (void)
   meta_property.install_property (make_attribute (meta_property, "Dependent"));
   meta_property.install_property (make_attribute (meta_property, "Transient"));
   meta_property.install_property (make_attribute (meta_property, "Hidden"));
   meta_property.install_property (make_attribute (meta_property, "GetObservable"));
   meta_property.install_property (make_attribute (meta_property, "SetObservable"));
   meta_property.install_property (make_attribute (meta_property, "GetMethod"));
   meta_property.install_property (make_attribute (meta_property, "SetMethod"));
   meta_property.install_property (make_attribute (meta_property, "DefiningClass"));
+  meta_property.install_property
+      (make_property (meta_property, "DefaultValue",
+		      make_fcn_handle (property_get_defaultvalue, "meta.property>get.DefaultValue"),
+		      "public", Matrix (), "private"));
+  meta_property.install_property (make_attribute (meta_property, "HasDefault"));
   /* meta.property events */
   // FIXME: add events
 
   /* handle methods */
   handle.install_method (make_method (handle, "delete", handle_delete));
 
   /* meta.package properties */
   meta_package.install_property (make_attribute (meta_package, "Name"));
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -18,16 +18,17 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_classdef_h)
 #define octave_classdef_h 1
 
+#include <set>
 #include <string>
 
 #include "oct-map.h"
 #include "oct-refcount.h"
 #include "ov-base.h"
 
 class cdef_object;
 class cdef_class;
@@ -75,16 +76,24 @@ public:
   virtual octave_value_list subsref (const std::string&,
 				     const std::list<octave_value_list>&,
 				     int, int&)
     {
       error ("subsref: invalid object");
       return octave_value_list ();
     }
 
+  virtual octave_value subsasgn (const std::string&,
+                                 const std::list<octave_value_list>&,
+                                 const octave_value&)
+    {
+      error ("subsasgn: invalid object");
+      return octave_value ();
+    }
+
   virtual string_vector map_keys(void) const;
 
   virtual bool is_valid (void) const { return false; }
 
   std::string class_name (void) const { return cname; }
 
   void set_class_name (const std::string& nm)
     { cname = nm; }
@@ -151,16 +160,21 @@ public:
   octave_value get (const std::string& pname) const
     { return rep->get (pname); }
 
   octave_value_list subsref (const std::string& type,
 			     const std::list<octave_value_list>& idx,
 			     int nargout, int& skip)
     { return rep->subsref (type, idx, nargout, skip); }
 
+  octave_value subsasgn (const std::string& type,
+                         const std::list<octave_value_list>& idx,
+                         const octave_value& rhs)
+    { return rep->subsasgn (type, idx, rhs); }
+
   string_vector map_keys (void) const { return rep->map_keys (); }
 
   const cdef_object_rep* get_rep (void) const { return rep; }
 
   bool ok (void) const { return rep->is_valid (); }
 
 protected:
   cdef_object_rep* get_rep (void) { return rep; }
@@ -174,16 +188,18 @@ handle_cdef_object : public cdef_object_
 {
 public:
   handle_cdef_object (void)
       : cdef_object_rep () { }
 
   handle_cdef_object (const std::string& nm)
       : cdef_object_rep (nm) { }
 
+  ~handle_cdef_object (void);
+
   cdef_object_rep* clone (void) const
     {
       handle_cdef_object *obj = const_cast<handle_cdef_object *> (this);
       obj->refcount++;
       return obj;
     }
 
   void put (const std::string& pname, const octave_value& val)
@@ -201,35 +217,42 @@ public:
 	  return octave_value ();
 	}
     }
 
   octave_value_list subsref (const std::string& type,
 			     const std::list<octave_value_list>& idx,
 			     int nargout, int& skip);
 
+  octave_value subsasgn (const std::string& type,
+                         const std::list<octave_value_list>& idx,
+                         const octave_value& rhs);
+
   bool is_valid (void) const { return true; }
 
 protected:
   Octave_map map;
 };
 
 class
 cdef_class : public cdef_object
 {
 private:
 
   class
   cdef_class_rep : public handle_cdef_object
   {
   public:
     cdef_class_rep (const std::string& nm)
-	: handle_cdef_object (nm) { }
+	: handle_cdef_object (nm), handle_class (false) { }
 
-    cdef_method find_method (const std::string& nm);
+    std::string get_name (void) const
+      { return get ("Name").string_value (); }
+
+    cdef_method find_method (const std::string& nm, bool local = false);
 
     void install_method (const cdef_method& meth);
 
     Cell get_methods (void);
 
     cdef_property find_property (const std::string& nm);
 
     void install_property (const cdef_property& prop);
@@ -239,35 +262,57 @@ private:
     string_vector get_names (void);
 
     void set_directory (const std::string& dir) { directory = dir; }
 
     std::string get_directory (void) const { return directory; }
 
     void delete_object (cdef_object obj);
 
+    octave_value_list subsref_meta (const std::string& type,
+                                    const std::list<octave_value_list>& idx,
+                                    int nargout);
+
+    octave_value construct (const octave_value_list& args);
+
+    void initialize_object (cdef_object& obj);
+
+    void run_constructor (cdef_object& obj, const octave_value_list& args);
+
+    void mark_as_handle_class (void) { handle_class = true; }
+
+    bool is_handle_class (void) const { return handle_class; }
+
   private:
     void load_all_methods (void);
 
-    void find_names (std::map<std::string,std::string>& names,
-		     std::map<std::string,int>& count);
+    void find_names (std::set<std::string>& names, bool all);
     
     void find_properties (std::map<std::string,cdef_property>& props,
-			  std::map<std::string,int>& count);
-    
-    void find_methods (std::map<std::string,cdef_method>& meths,
-		       std::map<std::string,int>& count);
+                          bool only_inherited);
+
+    void find_methods (std::map<std::string, cdef_method>& meths,
+                       bool only_inherited);
 
   private:
+    // The @-directory were this class is loaded from.
+    // (not used yet)
     std::string directory;
 
+    // The methods defined by this class.
     std::map<std::string,cdef_method> method_map;
 
+    // The properties defined by this class.
     std::map<std::string,cdef_property> property_map;
 
+    // TRUE if this class is a handle class. A class is a handle
+    // class when the abstract "handle" class is one of its superclasses.
+    bool handle_class;
+
+    // Utility iterator typedef's.
     typedef std::map<std::string,cdef_method>::iterator method_iterator;
     typedef std::map<std::string,cdef_method>::const_iterator method_const_iterator;
     typedef std::map<std::string,cdef_property>::iterator property_iterator;
     typedef std::map<std::string,cdef_property>::const_iterator property_const_iterator;
   };
 
 public:
   // Create and invalid class object
@@ -302,17 +347,17 @@ public:
 	cdef_object::operator= (obj);
       else
 	error ("internal error: invalid assignment from %s to meta.class object",
 	       class_name ().c_str ());
 
       return *this;
     }
 
-  cdef_method find_method (const std::string& nm);
+  cdef_method find_method (const std::string& nm, bool local = false);
 
   void install_method (const cdef_method& meth)
     { get_rep ()->install_method (meth); }
 
   Cell get_methods (void) { return get_rep ()->get_methods (); }
 
   cdef_property find_property (const std::string& nm);
   
@@ -325,25 +370,50 @@ public:
 
   void set_directory (const std::string& dir)
     { get_rep ()->set_directory (dir); }
 
   std::string get_directory (void) const
     { return get_rep ()->get_directory (); }
 
   std::string get_name (void) const
-    { return get ("Name").string_value (); }
+    { return get_rep ()->get_name (); }
 
   bool is_builtin (void) const
     { return get_directory ().empty (); }
 
   void delete_object (cdef_object obj)
     { get_rep ()->delete_object (obj); }
 
-  static cdef_class make_meta_class (const tree_classdef* t);
+  octave_value_list subsref_meta (const std::string& type,
+                                  const std::list<octave_value_list>& idx,
+                                  int nargout)
+    { return get_rep ()->subsref_meta (type, idx, nargout); }
+
+  static cdef_class make_meta_class (tree_classdef* t);
+
+  octave_function* get_method_function (const std::string& nm);
+
+  octave_function* get_constructor_function (void)
+    { return get_method_function (get_name ()); }
+
+  octave_value construct (const octave_value_list& args)
+    { return get_rep ()->construct (args); }
+
+  void initialize_object (cdef_object& obj)
+    { get_rep ()->initialize_object (obj); }
+
+  void run_constructor (cdef_object& obj, const octave_value_list& args)
+    { get_rep ()->run_constructor (obj, args); }
+
+  void mark_as_handle_class (void)
+    { get_rep ()->mark_as_handle_class (); }
+
+  bool is_handle_class (void) const
+    { return get_rep ()->is_handle_class (); }
 
 private:
   cdef_class_rep* get_rep (void)
     { return dynamic_cast<cdef_class_rep *> (cdef_object::get_rep ()); }
   
   const cdef_class_rep* get_rep (void) const
     { return dynamic_cast<const cdef_class_rep *> (cdef_object::get_rep ()); }
 
@@ -373,17 +443,20 @@ private:
 	: handle_cdef_object (nm) { }
 
     octave_value get_value (void) const { return default_value; }
 
     octave_value get_value (const cdef_object& obj);
 
     void set_value (const octave_value& val) { default_value = val; }
 
-    void set_value (const cdef_object& obj, const octave_value& val);
+    void set_value (cdef_object& obj, const octave_value& val);
+
+  private:
+    bool is_recursive_set (const cdef_object& obj) const;
 
   private:
     octave_value default_value;
   };
 
 public:
   cdef_property (void) : cdef_object () { }
 
@@ -409,30 +482,24 @@ public:
       return *this;
     }
 
   octave_value get_value (const cdef_object& obj)
     { return get_rep ()->get_value (obj); }
 
   octave_value get_value (void) { return get_rep ()->get_value (); }
 
-  void set_value (const cdef_object& obj, const octave_value& val)
+  void set_value (cdef_object& obj, const octave_value& val)
     { get_rep ()->set_value (obj, val); }
 
   void set_value (const octave_value& val) { get_rep ()->set_value (val); }
  
-  std::string get_get_access (void) const
-    { return get ("GetAccess").string_value (); }
+  bool check_get_access (void) const;
   
-  std::string get_set_access (void) const
-    { return get ("SetAccess").string_value (); }
-
-  bool check_get_access (const std::string& acc) const;
-  
-  bool check_set_access (const std::string& acc) const;
+  bool check_set_access (void) const;
 
   std::string get_name (void) const
     { return get ("Name").string_value (); }
 
   bool is_constant (void) const
     { return get ("Constant").bool_value (); }
 
 private:
@@ -501,20 +568,17 @@ public:
   octave_value_list execute (const octave_value_list& args, int nargout)
     { return get_rep ()->execute (args, nargout); }
 
   /* dot-invokation: object is pushed as 1st argument */
   octave_value_list execute (const cdef_object& obj,
 			     const octave_value_list& args, int nargout)
     { return get_rep ()->execute (obj, args, nargout); }
 
-  std::string get_access (void) const
-    { return get ("Access").string_value (); }
-
-  bool check_access (const std::string& req) const;
+  bool check_access (void) const;
   
   std::string get_name (void) const
     { return get ("Name").string_value (); }
 
   bool is_static (void) const
     { return get ("Static").bool_value (); }
 
   void set_function (const octave_value& fcn)
@@ -528,18 +592,18 @@ private:
     { return dynamic_cast<const cdef_method_rep *> (cdef_object::get_rep ()); }
 };
 
 inline cdef_class
 cdef_object::get_class (void) const
 { return rep->get_class (); }
 
 inline cdef_method
-cdef_class::find_method (const std::string& nm)
-{ return get_rep ()->find_method (nm); }
+cdef_class::find_method (const std::string& nm, bool local)
+{ return get_rep ()->find_method (nm, local); }
 
 inline cdef_property
 cdef_class::find_property (const std::string& nm)
 { return get_rep ()->find_property (nm); }
 
 class
 cdef_package : public cdef_object
 {
@@ -674,16 +738,20 @@ public:
 
   octave_value subsref (const std::string& type,
 			const std::list<octave_value_list>& idx)
     {
       octave_value_list retval = subsref (type, idx, 1);
       return (retval.length () > 0 ? retval(0) : octave_value ());
     }
 
+  octave_value subsasgn (const std::string& type,
+                         const std::list<octave_value_list>& idx,
+                         const octave_value& rhs);
+
   string_vector map_keys (void) const { return object.map_keys (); }
 
   dim_vector dims (void) const { return dim_vector (1, 1); }
 
 private:
   cdef_object object;
 
 private:
diff --git a/libinterp/octave-value/ov-fcn.h b/libinterp/octave-value/ov-fcn.h
--- a/libinterp/octave-value/ov-fcn.h
+++ b/libinterp/octave-value/ov-fcn.h
@@ -80,16 +80,20 @@ public:
   virtual octave_time time_checked (void) const
     { return octave_time (static_cast<time_t> (0)); }
 
   virtual bool is_subfunction (void) const { return false; }
 
   virtual bool is_class_constructor (const std::string& = std::string ()) const
     { return false; }
 
+  virtual bool
+  is_classdef_constructor (const std::string& = std::string ()) const
+    { return false; }
+
   virtual bool is_class_method (const std::string& = std::string ()) const
     { return false; }
 
   virtual bool takes_varargs (void) const { return false; }
 
   virtual bool takes_var_return (void) const { return false; }
 
   void stash_dispatch_class (const std::string& nm) { xdispatch_class = nm; }
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -186,17 +186,17 @@ octave_user_function::octave_user_functi
     lead_comm (), trail_comm (), file_name (),
     location_line (0), location_column (0),
     parent_name (), t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     system_fcn_file (false), call_depth (-1),
     num_named_args (param_list ? param_list->length () : 0),
     subfunction (false), inline_function (false),
     anonymous_function (false), nested_function (false),
-    class_constructor (false), class_method (false),
+    class_constructor (none), class_method (false),
     parent_scope (-1), local_scope (sid),
     curr_unwind_protect_frame (0)
 #ifdef HAVE_LLVM
     , jit_info (0)
 #endif
 {
   if (cmd_list)
     cmd_list->mark_as_function_body ();
@@ -365,27 +365,44 @@ octave_value_list
 octave_user_function::do_multi_index_op (int nargout,
                                          const octave_value_list& args)
 {
   return do_multi_index_op (nargout, args, 0);
 }
 
 octave_value_list
 octave_user_function::do_multi_index_op (int nargout,
-                                         const octave_value_list& args,
+                                         const octave_value_list& _args,
                                          const std::list<octave_lvalue>* lvalue_list)
 {
   octave_value_list retval;
 
   if (error_state)
     return retval;
 
   if (! cmd_list)
     return retval;
 
+  // If this function is a classdef constructor, extract the first input
+  // argument, which must be the partially constructed object instance.
+
+  octave_value_list args (_args);
+  octave_value_list ret_args;
+
+  if (is_classdef_constructor ())
+    {
+      if (args.length () > 0)
+        {
+          ret_args = args.slice (0, 1, true);
+          args = args.slice (1, args.length () - 1, true);
+        }
+      else
+        panic_impossible ();
+    }
+
 #ifdef HAVE_LLVM
   if (is_special_expr ()
       && tree_jit::execute (*this, args, retval))
     return retval;
 #endif
 
   int nargin = args.length ();
 
@@ -419,16 +436,35 @@ octave_user_function::do_multi_index_op 
 
   if (param_list && ! param_list->varargs_only ())
     {
       param_list->define_from_arg_vector (args);
       if (error_state)
         return retval;
     }
 
+  // For classdef constructor, pre-populate the output arguments
+  // with the pre-initialized object instance, extracted above.
+
+  if (is_classdef_constructor ())
+    {
+      if (ret_list)
+        {
+          ret_list->define_from_arg_vector (ret_args);
+          if (error_state)
+            return retval;
+        }
+      else
+        {
+          ::error ("%s: invalid classdef constructor, no output argument defined",
+                   dispatch_class ().c_str ());
+          return retval;
+        }
+    }
+
   // Force parameter list to be undefined when this function exits.
   // Doing so decrements the reference counts on the values of local
   // variables that are also named function parameters.
 
   if (param_list)
     frame.add_method (param_list, &tree_parameter_list::undefine);
 
   // Force return list to be undefined when this function exits.
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -295,21 +295,29 @@ public:
   {
     return is_inline_function () || is_anonymous_function ();
   }
 
   bool is_nested_function (void) const { return nested_function; }
 
   void mark_as_nested_function (void) { nested_function = true; }
 
-  void mark_as_class_constructor (void) { class_constructor = true; }
+  void mark_as_class_constructor (void) { class_constructor = legacy; }
+
+  void mark_as_classdef_constructor (void) { class_constructor = classdef; }
 
   bool is_class_constructor (const std::string& cname = std::string ()) const
     {
-      return class_constructor
+      return class_constructor == legacy
+        ? (cname.empty () ? true : cname == dispatch_class ()) : false;
+    }
+
+  bool is_classdef_constructor (const std::string& cname = std::string ()) const
+    {
+      return class_constructor == classdef
         ? (cname.empty () ? true : cname == dispatch_class ()) : false;
     }
 
   void mark_as_class_method (void) { class_method = true; }
 
   bool is_class_method (const std::string& cname = std::string ()) const
     {
       return class_method
@@ -375,16 +383,23 @@ public:
 #endif
 
 #if 0
   void print_symtab_info (std::ostream& os) const;
 #endif
 
 private:
 
+  enum class_ctor_type
+    {
+      none,
+      legacy,
+      classdef
+    };
+
   // List of arguments for this function.  These are local variables.
   tree_parameter_list *param_list;
 
   // List of parameters we return.  These are also local variables in
   // this function.
   tree_parameter_list *ret_list;
 
   // The list of commands that make up the body of this function.
@@ -431,18 +446,18 @@ private:
   bool inline_function;
 
   // TRUE means this is an anonymous function.
   bool anonymous_function;
 
   // TRUE means this is a nested function. (either a child or parent)
   bool nested_function;
 
-  // TRUE means this function is the constructor for class object.
-  bool class_constructor;
+  // Enum describing whether this function is the constructor for class object.
+  class_ctor_type class_constructor;
 
   // TRUE means this function is a method for a class.
   bool class_method;
 
   // The scope of the parent function, if any.
   symbol_table::scope_id parent_scope;
 
   symbol_table::scope_id local_scope;
diff --git a/libinterp/parse-tree/oct-parse.yy b/libinterp/parse-tree/oct-parse.yy
--- a/libinterp/parse-tree/oct-parse.yy
+++ b/libinterp/parse-tree/oct-parse.yy
@@ -3888,18 +3888,21 @@ parse_fcn_file (const std::string& ff, c
 
           if (status == 0)
             {
               if (reading_classdef_file && classdef_object)
                 {
                   // Convert parse tree for classdef object to
                   // meta.class info (and stash it in the symbol
                   // table?).  Return pointer to constructor?
-                  
-                  octave_value meta_class = classdef_object->make_meta_class ();
+
+                  if (fcn_ptr)
+                    panic_impossible ();
+
+                  fcn_ptr = classdef_object->make_meta_class ();
                 }
             }
           else
             {
               error ("parse error while reading %s file %s",
                      file_type.c_str(), ff.c_str ());
             }
         }
diff --git a/libinterp/parse-tree/pt-classdef.cc b/libinterp/parse-tree/pt-classdef.cc
--- a/libinterp/parse-tree/pt-classdef.cc
+++ b/libinterp/parse-tree/pt-classdef.cc
@@ -227,34 +227,33 @@ tree_classdef_body::~tree_classdef_body 
       enum_list_iterator p = enum_lst.begin ();
       delete *p;
       enum_lst.erase (p);
     }
 }
 
 // Classdef
 
-octave_value
-tree_classdef::make_meta_class (void) const
+octave_function*
+tree_classdef::make_meta_class (void)
 {
   octave_value retval;
   cdef_class cls = cdef_class::make_meta_class (this);
 
   if (cls.ok ())
-    retval = to_ov (cls);
+    return cls.get_constructor_function ();
 
-  return retval;
+  return 0;
 }
 
 tree_classdef *
 tree_classdef::dup (symbol_table::scope_id,
                     symbol_table::context_id) const
 {
   // FIXME
   return 0;
 }
 
 void
 tree_classdef::accept (tree_walker& tw)
 {
-  std::cerr << "I am super accepting" << std::endl;
-  // tw.visit_classdef (*this);
+  tw.visit_classdef (*this);
 }
diff --git a/libinterp/parse-tree/pt-classdef.h b/libinterp/parse-tree/pt-classdef.h
--- a/libinterp/parse-tree/pt-classdef.h
+++ b/libinterp/parse-tree/pt-classdef.h
@@ -618,17 +618,17 @@ public:
 
   tree_classdef_superclass_list *superclass_list (void) { return supclass_list; }
 
   tree_classdef_body *body (void) { return element_list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  octave_value make_meta_class (void) const;
+  octave_function* make_meta_class (void);
 
   tree_classdef *dup (symbol_table::scope_id scope,
                       symbol_table::context_id context) const;
 
   void accept (tree_walker& tw);
 
 private:
 
