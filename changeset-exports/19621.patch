# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1422048286 18000
#      Fri Jan 23 16:24:46 2015 -0500
# Branch gui-release
# Node ID af0399a5aae0bb815419d3bc2ac62abcea5e084d
# Parent  a1d172bfcb2f9b9047bf1c95fb30d07e7eda2662
untabify QtHandles source files

diff --git a/libgui/graphics/Backend.cc b/libgui/graphics/Backend.cc
--- a/libgui/graphics/Backend.cc
+++ b/libgui/graphics/Backend.cc
@@ -48,37 +48,37 @@ along with Octave; see the file COPYING.
 namespace QtHandles
 {
 
 static std::string toolkitObjectProperty (const graphics_object& go)
 {
   if (go.isa ("figure"))
     return std::string ("__plot_stream__");
   else if (go.isa ("uicontrol")
-	   || go.isa ("uipanel")
-	   || go.isa ("uimenu")
-	   || go.isa ("uicontextmenu")
-	   || go.isa ("uitoolbar")
-	   || go.isa ("uipushtool")
-	   || go.isa ("uitoggletool"))
+           || go.isa ("uipanel")
+           || go.isa ("uimenu")
+           || go.isa ("uicontextmenu")
+           || go.isa ("uitoolbar")
+           || go.isa ("uipushtool")
+           || go.isa ("uitoggletool"))
     return std::string ("__object__");
   else
     qCritical ("QtHandles::Backend: no __object__ property known for object "
-	       "of type %s", go.type ().c_str ());
+               "of type %s", go.type ().c_str ());
 
   return std::string ();
 }
 
 Backend::Backend (void)
   : QObject (), base_graphics_toolkit ("qt")
 {
   ObjectFactory* factory = ObjectFactory::instance ();
 
   connect (this, SIGNAL (createObject (double)),
-	   factory, SLOT (createObject (double)));
+           factory, SLOT (createObject (double)));
 }
 
 Backend::~Backend (void)
 {
 }
 
 bool Backend::initialize (const graphics_object& go)
 {
@@ -87,23 +87,23 @@ bool Backend::initialize (const graphics
       || go.isa ("uipanel")
       || go.isa ("uimenu")
       || go.isa ("uicontextmenu")
       || go.isa ("uitoolbar")
       || go.isa ("uipushtool")
       || go.isa ("uitoggletool"))
     {
       Logger::debug ("Backend::initialize %s from thread %08x",
-		     go.type ().c_str (), QThread::currentThreadId ());
+                     go.type ().c_str (), QThread::currentThreadId ());
 
       ObjectProxy* proxy = new ObjectProxy ();
       graphics_object gObj (go);
 
       gObj.get_properties ().set(toolkitObjectProperty (go),
-				 OCTAVE_PTR_TYPE (reinterpret_cast <OCTAVE_INTPTR_TYPE> (proxy)));
+                                 OCTAVE_PTR_TYPE (reinterpret_cast <OCTAVE_INTPTR_TYPE> (proxy)));
 
       emit createObject (go.get_handle ().value ());
 
       return true;
     }
 
   return false;
 }
@@ -118,40 +118,40 @@ void Backend::update (const graphics_obj
       || pId == uicontextmenu::properties::ID___OBJECT__
       || pId == uitoolbar::properties::ID___OBJECT__
       || pId == uipushtool::properties::ID___OBJECT__
       || pId == uitoggletool::properties::ID___OBJECT__
       || pId == base_properties::ID___MODIFIED__)
     return;
 
   Logger::debug ("Backend::update %s(%d) from thread %08x",
-		 go.type ().c_str (), pId, QThread::currentThreadId ());
+                 go.type ().c_str (), pId, QThread::currentThreadId ());
 
   ObjectProxy* proxy = toolkitObjectProxy (go);
 
   if (proxy)
     {
       if (go.isa ("uicontrol")
-	  && pId == uicontrol::properties::ID_STYLE)
-	{
-	  // Special case: we need to recreate the control widget
-	  // associated with the octave graphics_object
+          && pId == uicontrol::properties::ID_STYLE)
+        {
+          // Special case: we need to recreate the control widget
+          // associated with the octave graphics_object
 
-	  finalize (go);
-	  initialize (go);
-	}
+          finalize (go);
+          initialize (go);
+        }
       else
-	proxy->update (pId);
+        proxy->update (pId);
     }
 }
 
 void Backend::finalize (const graphics_object& go)
 {
   Logger::debug ("Backend::finalize %s from thread %08x",
-		 go.type ().c_str (), QThread::currentThreadId ());
+                 go.type ().c_str (), QThread::currentThreadId ());
 
   ObjectProxy* proxy = toolkitObjectProxy (go);
 
   if (proxy)
     {
       proxy->finalize ();
       delete proxy;
 
@@ -163,17 +163,17 @@ void Backend::finalize (const graphics_o
 
 void Backend::redraw_figure (const graphics_object& go) const
 {
   if (go.get_properties ().is_visible ())
     {
       ObjectProxy* proxy = toolkitObjectProxy (go);
 
       if (proxy)
-	proxy->redraw ();
+        proxy->redraw ();
     }
 }
 
 Object* Backend::toolkitObject (const graphics_object& go)
 {
   ObjectProxy* proxy = toolkitObjectProxy (go);
 
   if (proxy)
@@ -184,20 +184,20 @@ Object* Backend::toolkitObject (const gr
 
 ObjectProxy* Backend::toolkitObjectProxy (const graphics_object& go)
 {
   if (go)
     {
       octave_value ov = go.get (toolkitObjectProperty (go));
 
       if (ov.is_defined () && ! ov.is_empty ())
-	{
-	  OCTAVE_INTPTR_TYPE ptr = ov.OCTAVE_PTR_SCALAR ().value ();
+        {
+          OCTAVE_INTPTR_TYPE ptr = ov.OCTAVE_PTR_SCALAR ().value ();
 
-	  if (! error_state)
-	    return reinterpret_cast<ObjectProxy*> (ptr);
-	}
+          if (! error_state)
+            return reinterpret_cast<ObjectProxy*> (ptr);
+        }
     }
 
   return 0;
 }
 
 };
diff --git a/libgui/graphics/BaseControl.cc b/libgui/graphics/BaseControl.cc
--- a/libgui/graphics/BaseControl.cc
+++ b/libgui/graphics/BaseControl.cc
@@ -40,34 +40,34 @@ static void updatePalette (const uicontr
 {
   QPalette p = w->palette ();
 
   if (props.style_is ("edit")
       || props.style_is ("listbox")
       || props.style_is ("popupmenu"))
     {
       p.setColor (QPalette::Base,
-		  Utils::fromRgb (props.get_backgroundcolor_rgb ()));
+                  Utils::fromRgb (props.get_backgroundcolor_rgb ()));
       p.setColor (QPalette::Text,
-		  Utils::fromRgb (props.get_foregroundcolor_rgb ()));
+                  Utils::fromRgb (props.get_foregroundcolor_rgb ()));
     }
   else if (props.style_is ("pushbutton")
-	   || props.style_is ("togglebutton"))
+           || props.style_is ("togglebutton"))
     {
       p.setColor (QPalette::Button,
-		  Utils::fromRgb (props.get_backgroundcolor_rgb ()));
+                  Utils::fromRgb (props.get_backgroundcolor_rgb ()));
       p.setColor (QPalette::ButtonText,
-		  Utils::fromRgb (props.get_foregroundcolor_rgb ()));
+                  Utils::fromRgb (props.get_foregroundcolor_rgb ()));
     }
   else
     {
       p.setColor (QPalette::Window,
-		  Utils::fromRgb (props.get_backgroundcolor_rgb ()));
+                  Utils::fromRgb (props.get_backgroundcolor_rgb ()));
       p.setColor (QPalette::WindowText,
-		  Utils::fromRgb (props.get_foregroundcolor_rgb ()));
+                  Utils::fromRgb (props.get_foregroundcolor_rgb ()));
     }
 
   w->setPalette (p);
 }
 
 BaseControl::BaseControl (const graphics_object& go, QWidget* w)
   : Object (go, w), m_normalizedFont (false), m_keyPressHandlerDefined (false)
 {
@@ -78,17 +78,17 @@ void BaseControl::init (QWidget* w, bool
 {
   if (callBase)
     Object::init (w, callBase);
 
   uicontrol::properties& up = properties<uicontrol> ();
 
   Matrix bb = up.get_boundingbox (false);
   w->setGeometry (xround (bb(0)), xround (bb(1)),
-		  xround (bb(2)), xround (bb(3)));
+                  xround (bb(2)), xround (bb(3)));
   w->setFont (Utils::computeFont<uicontrol> (up, bb(3)));
   updatePalette (up, w);
   w->setEnabled (up.enable_is ("on"));
   w->setToolTip (Utils::fromStdString (up.get_tooltipstring ()));
   w->setVisible (up.is_visible ());
   m_keyPressHandlerDefined = ! up.get_keypressfcn ().is_empty ();
 
   w->installEventFilter (this);
@@ -103,21 +103,21 @@ BaseControl::~BaseControl (void)
 void BaseControl::update (int pId)
 {
   uicontrol::properties& up = properties<uicontrol> ();
   QWidget* w = qWidget<QWidget> ();
 
    switch (pId)
     {
     case uicontrol::properties::ID_POSITION:
-	{
-	  Matrix bb = up.get_boundingbox (false);
-	  w->setGeometry (xround (bb(0)), xround (bb(1)),
-			  xround (bb(2)), xround (bb(3)));
-	}
+        {
+          Matrix bb = up.get_boundingbox (false);
+          w->setGeometry (xround (bb(0)), xround (bb(1)),
+                          xround (bb(2)), xround (bb(3)));
+        }
       break;
     case uicontrol::properties::ID_FONTNAME:
     case uicontrol::properties::ID_FONTSIZE:
     case uicontrol::properties::ID_FONTWEIGHT:
     case uicontrol::properties::ID_FONTANGLE:
       w->setFont (Utils::computeFont<uicontrol> (up));
       break;
     case uicontrol::properties::ID_FONTUNITS:
@@ -148,66 +148,66 @@ void BaseControl::update (int pId)
 }
 
 bool BaseControl::eventFilter (QObject* watched, QEvent* ev)
 {
   switch (ev->type ())
     {
     case QEvent::Resize:
       if (m_normalizedFont)
-	{
-	  gh_manager::auto_lock lock;
+        {
+          gh_manager::auto_lock lock;
 
-	  qWidget<QWidget> ()->setFont (Utils::computeFont<uicontrol>
-					(properties<uicontrol> ()));
-	}
+          qWidget<QWidget> ()->setFont (Utils::computeFont<uicontrol>
+                                        (properties<uicontrol> ()));
+        }
       break;
     case QEvent::MouseButtonPress:
-	{
-	  gh_manager::auto_lock lock;
+        {
+          gh_manager::auto_lock lock;
 
-	  QMouseEvent* m = dynamic_cast<QMouseEvent*> (ev);
-	  graphics_object go = object ();
-	  uicontrol::properties& up = Utils::properties<uicontrol> (go);
-	  graphics_object fig = go.get_ancestor ("figure");
+          QMouseEvent* m = dynamic_cast<QMouseEvent*> (ev);
+          graphics_object go = object ();
+          uicontrol::properties& up = Utils::properties<uicontrol> (go);
+          graphics_object fig = go.get_ancestor ("figure");
 
-	  if (m->button () != Qt::LeftButton
-	      || ! up.enable_is ("on"))
-	    {
-	      gh_manager::post_set (fig.get_handle (), "selectiontype",
-				    Utils::figureSelectionType (m), false);
-	      gh_manager::post_set (fig.get_handle (), "currentpoint",
-				    Utils::figureCurrentPoint (fig, m),
-				    false);
-	      gh_manager::post_callback (fig.get_handle (),
-					 "windowbuttondownfcn");
-	      gh_manager::post_callback (m_handle, "buttondownfcn");
+          if (m->button () != Qt::LeftButton
+              || ! up.enable_is ("on"))
+            {
+              gh_manager::post_set (fig.get_handle (), "selectiontype",
+                                    Utils::figureSelectionType (m), false);
+              gh_manager::post_set (fig.get_handle (), "currentpoint",
+                                    Utils::figureCurrentPoint (fig, m),
+                                    false);
+              gh_manager::post_callback (fig.get_handle (),
+                                         "windowbuttondownfcn");
+              gh_manager::post_callback (m_handle, "buttondownfcn");
 
-	      if (m->button () == Qt::RightButton)
-		ContextMenu::executeAt (up, m->globalPos ());
-	    }
-	  else
-	    {
-	      if (up.style_is ("listbox"))
-		gh_manager::post_set (fig.get_handle (), "selectiontype",
-				      Utils::figureSelectionType (m), false);
-	      else
-		gh_manager::post_set (fig.get_handle (), "selectiontype",
-				      octave_value ("normal"), false);
-	    }
-	}
+              if (m->button () == Qt::RightButton)
+                ContextMenu::executeAt (up, m->globalPos ());
+            }
+          else
+            {
+              if (up.style_is ("listbox"))
+                gh_manager::post_set (fig.get_handle (), "selectiontype",
+                                      Utils::figureSelectionType (m), false);
+              else
+                gh_manager::post_set (fig.get_handle (), "selectiontype",
+                                      octave_value ("normal"), false);
+            }
+        }
       break;
     case QEvent::MouseMove:
       if (qWidget<QWidget> ()->hasMouseTracking ())
         {
-	  gh_manager::auto_lock lock;
+          gh_manager::auto_lock lock;
 
-	  QMouseEvent* m = dynamic_cast<QMouseEvent*> (ev);
-	  graphics_object go = object ();
-	  graphics_object fig = go.get_ancestor ("figure");
+          QMouseEvent* m = dynamic_cast<QMouseEvent*> (ev);
+          graphics_object go = object ();
+          graphics_object fig = go.get_ancestor ("figure");
 
           gh_manager::post_set (fig.get_handle (), "currentpoint",
                                 Utils::figureCurrentPoint (fig, m), false);
           gh_manager::post_callback (fig.get_handle (), "windowbuttonmotionfcn");
         }
       break;
     case QEvent::KeyPress:
       if (m_keyPressHandlerDefined)
diff --git a/libgui/graphics/ButtonControl.cc b/libgui/graphics/ButtonControl.cc
--- a/libgui/graphics/ButtonControl.cc
+++ b/libgui/graphics/ButtonControl.cc
@@ -41,17 +41,17 @@ ButtonControl::ButtonControl (const grap
   btn->setText (Utils::fromStdString (up.get_string_string ()));
   if (btn->isCheckable () || up.style_is ("togglebutton"))
     {
       btn->setCheckable (true);
 
       Matrix value = up.get_value ().matrix_value ();
 
       if (value.numel () > 0 && value(0) == up.get_max ())
-	btn->setChecked (true);
+        btn->setChecked (true);
     }
 
   connect (btn, SIGNAL (clicked (void)), SLOT (clicked (void)));
   connect (btn, SIGNAL (toggled (bool)), SLOT (toggled (bool)));
 }
 
 ButtonControl::~ButtonControl (void)
 {
@@ -65,29 +65,29 @@ void ButtonControl::update (int pId)
   switch (pId)
     {
     case uicontrol::properties::ID_STRING:
       btn->setText (Utils::fromStdString (up.get_string_string ()));
       break;
     case uicontrol::properties::ID_VALUE:
       m_blockCallback = true;
       if (btn->isCheckable ())
-	{
-	  Matrix value = up.get_value ().matrix_value ();
+        {
+          Matrix value = up.get_value ().matrix_value ();
 
-	  if (value.numel () > 0)
-	    {
-	      double dValue = value(0);
+          if (value.numel () > 0)
+            {
+              double dValue = value(0);
 
-	      if (dValue == up.get_min () && btn->isChecked ())
-		btn->setChecked (false);
-	      else if (dValue == up.get_max () && ! btn->isChecked ())
-		btn->setChecked (true);
-	    }
-	}
+              if (dValue == up.get_min () && btn->isChecked ())
+                btn->setChecked (false);
+              else if (dValue == up.get_max () && ! btn->isChecked ())
+                btn->setChecked (true);
+            }
+        }
       m_blockCallback = false;
       break;
     default:
       BaseControl::update (pId);
       break;
     }
 }
 
@@ -100,18 +100,18 @@ void ButtonControl::toggled (bool checke
       gh_manager::auto_lock lock;
 
       uicontrol::properties& up = properties<uicontrol> ();
 
       Matrix oldValue = up.get_value ().matrix_value ();
       double newValue = (checked ? up.get_max () : up.get_min ());
 
       if (oldValue.numel() != 1
-	  || (newValue != oldValue(0)))
-	gh_manager::post_set (m_handle, "value", newValue, false);
+          || (newValue != oldValue(0)))
+        gh_manager::post_set (m_handle, "value", newValue, false);
       gh_manager::post_callback (m_handle, "callback");
     }
 }
 
 void ButtonControl::clicked (void)
 {
   QAbstractButton* btn = qWidget<QAbstractButton> ();
 
diff --git a/libgui/graphics/Canvas.cc b/libgui/graphics/Canvas.cc
--- a/libgui/graphics/Canvas.cc
+++ b/libgui/graphics/Canvas.cc
@@ -90,101 +90,101 @@ void Canvas::canvasPaintEvent (void)
 {
   if (! m_redrawBlocked)
     {
       gh_manager::auto_lock lock;
 
       draw (m_handle);
 
       if (m_mouseMode == ZoomMode && m_mouseAxes.ok ())
-	drawZoomBox (m_mouseAnchor, m_mouseCurrent);
+        drawZoomBox (m_mouseAnchor, m_mouseCurrent);
     }
 }
 
 void Canvas::canvasMouseMoveEvent (QMouseEvent* event)
 {
   gh_manager::auto_lock lock;
   graphics_object ax = gh_manager::get_object (m_mouseAxes);
 
   if (m_mouseMode != NoMode && ax.valid_object ())
     {
       axes::properties& ap = Utils::properties<axes> (ax);
 
       switch (m_mouseMode)
-	{
-	case RotateMode:
-	    {
-	      Matrix bb = ap.get_boundingbox (true);
-	      Matrix view = ap.get_view ().matrix_value ();
+        {
+        case RotateMode:
+            {
+              Matrix bb = ap.get_boundingbox (true);
+              Matrix view = ap.get_view ().matrix_value ();
 
-	      // Compute new view angles
-	      view(0) += ((m_mouseCurrent.x () - event->x ())
-			  * (180.0 / bb(2)));
-	      view(1) += ((event->y () - m_mouseCurrent.y ())
-			  * (180.0 / bb(3)));
+              // Compute new view angles
+              view(0) += ((m_mouseCurrent.x () - event->x ())
+                          * (180.0 / bb(2)));
+              view(1) += ((event->y () - m_mouseCurrent.y ())
+                          * (180.0 / bb(3)));
 
-	      // Clipping
-	      view(1) = std::min (view(1), 90.0);
-	      view(1) = std::max (view(1), -90.0);
-	      if (view(0) > 180.0)
-		view(0) -= 360.0;
-	      else if (view(0) < -180.0)
-		view(0) += 360.0;
+              // Clipping
+              view(1) = std::min (view(1), 90.0);
+              view(1) = std::max (view(1), -90.0);
+              if (view(0) > 180.0)
+                view(0) -= 360.0;
+              else if (view(0) < -180.0)
+                view(0) += 360.0;
 
-	      // Snapping
-	      double snapMargin = 1.0;
-	      for (int a = -90; a <= 90; a += 90)
-		if ((a - snapMargin) < view(1)
-		    && view(1) < (a + snapMargin))
-		  {
-		    view(1) = a;
-		    break;
-		  }
-	      for (int a = -180; a <= 180; a += 180)
-		if ((a - snapMargin) < view(0)
-		    && view(0) < (a + snapMargin))
-		  {
-		    if (a == 180)
-		      view(0) = -180;
-		    else
-		      view(0) = a;
-		    break;
-		  }
+              // Snapping
+              double snapMargin = 1.0;
+              for (int a = -90; a <= 90; a += 90)
+                if ((a - snapMargin) < view(1)
+                    && view(1) < (a + snapMargin))
+                  {
+                    view(1) = a;
+                    break;
+                  }
+              for (int a = -180; a <= 180; a += 180)
+                if ((a - snapMargin) < view(0)
+                    && view(0) < (a + snapMargin))
+                  {
+                    if (a == 180)
+                      view(0) = -180;
+                    else
+                      view(0) = a;
+                    break;
+                  }
 
-	      // Update axes properties
-	      ap.set_view (view);
+              // Update axes properties
+              ap.set_view (view);
 
-	      // Update current mouse position
-	      m_mouseCurrent = event->pos ();
+              // Update current mouse position
+              m_mouseCurrent = event->pos ();
 
-	      // Force immediate redraw
-	      redraw (true);
-	    }
-	  break;
-	case ZoomMode:
-	  m_mouseCurrent = event->pos();
-	  redraw (true);
-	  break;
-	case PanMode:
-	  break;
-	default:
-	  break;
-	}
+              // Force immediate redraw
+              redraw (true);
+            }
+          break;
+        case ZoomMode:
+          m_mouseCurrent = event->pos();
+          redraw (true);
+          break;
+        case PanMode:
+          break;
+        default:
+          break;
+        }
     }
   else if (m_mouseMode == NoMode)
     {
       graphics_object obj = gh_manager::get_object (m_handle);
 
       if (obj.valid_object ())
         {
           graphics_object figObj (obj.get_ancestor ("figure"));
 
           updateCurrentPoint (figObj, obj, event);
-	  gh_manager::post_callback (figObj.get_handle (),
-				     "windowbuttonmotionfcn");
+          gh_manager::post_callback (figObj.get_handle (),
+                                     "windowbuttonmotionfcn");
         }
     }
 }
 
 void Canvas::canvasMousePressEvent (QMouseEvent* event)
 {
   gh_manager::auto_lock lock;
   graphics_object obj = gh_manager::get_object (m_handle);
@@ -194,34 +194,34 @@ void Canvas::canvasMousePressEvent (QMou
       graphics_object figObj (obj.get_ancestor ("figure"));
       graphics_object currentObj, axesObj;
       QList<graphics_object> axesList;
 
       Matrix children = obj.get_properties ().get_children ();
       octave_idx_type num_children = children.numel ();
 
       for (int i = 0; i < num_children; i++)
-	{
-	  graphics_object childObj (gh_manager::get_object (children(i)));
+        {
+          graphics_object childObj (gh_manager::get_object (children(i)));
 
           if (childObj.isa ("axes"))
             axesList.append (childObj);
-	  else if (childObj.isa ("uicontrol") || childObj.isa ("uipanel"))
-	    {
-	      Matrix bb = childObj.get_properties ().get_boundingbox (false);
-	      QRectF r (bb(0), bb(1), bb(2), bb(3));
+          else if (childObj.isa ("uicontrol") || childObj.isa ("uipanel"))
+            {
+              Matrix bb = childObj.get_properties ().get_boundingbox (false);
+              QRectF r (bb(0), bb(1), bb(2), bb(3));
 
-	      r.adjust (-5, -5, 5, 5);
-	      if (r.contains (event->posF ()))
-		{
-		  currentObj = childObj;
-		  break;
-		}
-	    }
-	}
+              r.adjust (-5, -5, 5, 5);
+              if (r.contains (event->posF ()))
+                {
+                  currentObj = childObj;
+                  break;
+                }
+            }
+        }
 
       if (! currentObj)
         {
           for (QList<graphics_object>::ConstIterator it = axesList.begin ();
                it != axesList.end (); ++it)
             {
               graphics_object go = selectFromAxes (*it, event->pos ());
 
@@ -264,104 +264,104 @@ void Canvas::canvasMousePressEvent (QMou
       else
         Utils::properties<figure> (figObj).set_currentobject (octave_NaN);
 
       Figure* fig = dynamic_cast<Figure*> (Backend::toolkitObject (figObj));
 
       MouseMode newMouseMode = NoMode;
 
       if (fig)
-	newMouseMode = fig->mouseMode ();
+        newMouseMode = fig->mouseMode ();
 
       switch (newMouseMode)
-	{
-	case NoMode:
-	  gh_manager::post_set (figObj.get_handle (), "selectiontype",
-				Utils::figureSelectionType (event), false);
+        {
+        case NoMode:
+          gh_manager::post_set (figObj.get_handle (), "selectiontype",
+                                Utils::figureSelectionType (event), false);
           updateCurrentPoint (figObj, obj, event);
-	  gh_manager::post_callback (figObj.get_handle (),
-				     "windowbuttondownfcn");
+          gh_manager::post_callback (figObj.get_handle (),
+                                     "windowbuttondownfcn");
           gh_manager::post_callback (currentObj.get_handle (),
                                      "buttondownfcn");
-	  if (event->button () == Qt::RightButton)
-	    ContextMenu::executeAt (currentObj.get_properties (),
-				    event->globalPos ());
-	  break;
-	case RotateMode:
-	case ZoomMode:
-	case PanMode:
-	  if (axesObj)
-	    {
-	      if (event->buttons () == Qt::LeftButton
-		  && event->modifiers () == Qt::NoModifier)
-		{
-		  m_mouseAnchor = m_mouseCurrent = event->pos ();
-		  m_mouseAxes = axesObj.get_handle ();
-		  m_mouseMode = newMouseMode;
-		}
-	      else if (newMouseMode == ZoomMode
-		       && event->modifiers () == Qt::NoModifier)
-		{
-		  switch (event->buttons ())
-		    {
-		    case Qt::RightButton:
-		      Utils::properties<axes> (axesObj).unzoom ();
-		      break;
-		    case Qt::MidButton:
-			{
-			  axes::properties& ap =
-			    Utils::properties<axes> (axesObj);
+          if (event->button () == Qt::RightButton)
+            ContextMenu::executeAt (currentObj.get_properties (),
+                                    event->globalPos ());
+          break;
+        case RotateMode:
+        case ZoomMode:
+        case PanMode:
+          if (axesObj)
+            {
+              if (event->buttons () == Qt::LeftButton
+                  && event->modifiers () == Qt::NoModifier)
+                {
+                  m_mouseAnchor = m_mouseCurrent = event->pos ();
+                  m_mouseAxes = axesObj.get_handle ();
+                  m_mouseMode = newMouseMode;
+                }
+              else if (newMouseMode == ZoomMode
+                       && event->modifiers () == Qt::NoModifier)
+                {
+                  switch (event->buttons ())
+                    {
+                    case Qt::RightButton:
+                      Utils::properties<axes> (axesObj).unzoom ();
+                      break;
+                    case Qt::MidButton:
+                        {
+                          axes::properties& ap =
+                            Utils::properties<axes> (axesObj);
 
-			  ap.clear_zoom_stack ();
-			  ap.set_xlimmode ("auto");
-			  ap.set_ylimmode ("auto");
-			  ap.set_zlimmode ("auto");
-			}
-		      break;
-		    }
-		  redraw (false);
-		}
-	    }
-	  break;
-	default:
-	  break;
-	}
+                          ap.clear_zoom_stack ();
+                          ap.set_xlimmode ("auto");
+                          ap.set_ylimmode ("auto");
+                          ap.set_zlimmode ("auto");
+                        }
+                      break;
+                    }
+                  redraw (false);
+                }
+            }
+          break;
+        default:
+          break;
+        }
     }
 }
 
 void Canvas::canvasMouseReleaseEvent (QMouseEvent* event)
 {
   if (m_mouseMode == ZoomMode
       && m_mouseAxes.ok ()
       && m_mouseAnchor != event->pos ())
     {
       gh_manager::auto_lock lock;
       graphics_object ax = gh_manager::get_object (m_mouseAxes);
 
       if (ax.valid_object ())
-	{
-	  axes::properties& ap = Utils::properties<axes> (ax);
+        {
+          axes::properties& ap = Utils::properties<axes> (ax);
 
-	  ColumnVector p0 = ap.pixel2coord (m_mouseAnchor.x (),
-					    m_mouseAnchor.y ());
-	  ColumnVector p1 = ap.pixel2coord (event->x (),
-					    event->y ());
+          ColumnVector p0 = ap.pixel2coord (m_mouseAnchor.x (),
+                                            m_mouseAnchor.y ());
+          ColumnVector p1 = ap.pixel2coord (event->x (),
+                                            event->y ());
 
-	  Matrix xl (1, 2, 0.0);
-	  Matrix yl (1, 2, 0.0);
+          Matrix xl (1, 2, 0.0);
+          Matrix yl (1, 2, 0.0);
 
-	  xl(0) = std::min (p0(0), p1(0));
-	  xl(1) = std::max (p0(0), p1(0));
-	  yl(0) = std::min (p0(1), p1(1));
-	  yl(1) = std::max (p0(1), p1(1));
+          xl(0) = std::min (p0(0), p1(0));
+          xl(1) = std::max (p0(0), p1(0));
+          yl(0) = std::min (p0(1), p1(1));
+          yl(1) = std::max (p0(1), p1(1));
 
-	  ap.zoom (xl, yl);
+          ap.zoom (xl, yl);
 
-	  redraw (false);
-	}
+          redraw (false);
+        }
     }
   else if (m_mouseMode == NoMode)
     {
       gh_manager::auto_lock lock;
       graphics_object obj = gh_manager::get_object (m_handle);
 
       if (obj.valid_object ())
         {
@@ -402,15 +402,15 @@ bool Canvas::canvasKeyReleaseEvent (QKey
 
       return true;
     }
 
   return false;
 }
 
 Canvas* Canvas::create (const std::string& /* name */, QWidget* parent,
-			const graphics_handle& handle)
+                        const graphics_handle& handle)
 {
   // Only OpenGL
   return new GLCanvas (parent, handle);
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/Canvas.h b/libgui/graphics/Canvas.h
--- a/libgui/graphics/Canvas.h
+++ b/libgui/graphics/Canvas.h
@@ -53,17 +53,17 @@ public:
 
   void addEventMask (int m) { m_eventMask |= m; }
   void clearEventMask (int m) { m_eventMask &= (~m); }
   void setEventMask (int m) { m_eventMask = m; }
 
   virtual QWidget* qWidget (void) = 0;
 
   static Canvas* create (const std::string& name, QWidget* parent,
-			 const graphics_handle& handle);
+                         const graphics_handle& handle);
 
 protected:
   virtual void draw (const graphics_handle& handle) = 0;
   virtual void drawZoomBox (const QPoint& p1, const QPoint& p2) = 0;
   virtual void resize (int x, int y, int width, int height) = 0;
   virtual graphics_object selectFromAxes (const graphics_object& ax,
                                           const QPoint& pt) = 0;
 
diff --git a/libgui/graphics/CheckBoxControl.cc b/libgui/graphics/CheckBoxControl.cc
--- a/libgui/graphics/CheckBoxControl.cc
+++ b/libgui/graphics/CheckBoxControl.cc
@@ -36,17 +36,17 @@ CheckBoxControl* CheckBoxControl::create
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	return new CheckBoxControl (go, new QCheckBox (container));
+        return new CheckBoxControl (go, new QCheckBox (container));
     }
 
   return 0;
 }
 
 CheckBoxControl::CheckBoxControl (const graphics_object& go, QCheckBox* box)
     : ButtonControl (go, box)
 {
diff --git a/libgui/graphics/Container.cc b/libgui/graphics/Container.cc
--- a/libgui/graphics/Container.cc
+++ b/libgui/graphics/Container.cc
@@ -49,55 +49,55 @@ Container::~Container (void)
 
 Canvas* Container::canvas (const graphics_handle& gh, bool xcreate)
 {
   if (! m_canvas && xcreate)
     {
       graphics_object go = gh_manager::get_object (gh);
 
       if (go)
-	{
-	  graphics_object fig = go.get_ancestor ("figure");
+        {
+          graphics_object fig = go.get_ancestor ("figure");
 
-	  m_canvas = Canvas::create (fig.get("renderer").string_value (),
-				     this, gh);
+          m_canvas = Canvas::create (fig.get("renderer").string_value (),
+                                     this, gh);
 
-	  QWidget* canvasWidget = m_canvas->qWidget ();
+          QWidget* canvasWidget = m_canvas->qWidget ();
 
-	  canvasWidget->lower ();
-	  canvasWidget->show ();
-	  canvasWidget->setGeometry (0, 0, width (), height ());
-	}
+          canvasWidget->lower ();
+          canvasWidget->show ();
+          canvasWidget->setGeometry (0, 0, width (), height ());
+        }
     }
 
   return m_canvas;
 }
 
 void Container::resizeEvent (QResizeEvent* /* event */)
 {
   if (m_canvas)
     m_canvas->qWidget ()->setGeometry (0, 0, width (), height ());
 
   gh_manager::auto_lock lock;
 
   foreach (QObject* qObj, children ())
     {
       if (qObj->isWidgetType ())
-	{
-	  Object* obj = Object::fromQObject (qObj);
+        {
+          Object* obj = Object::fromQObject (qObj);
 
-	  if (obj)
-	    {
-	      Matrix bb = obj->properties ().get_boundingbox (false);
+          if (obj)
+            {
+              Matrix bb = obj->properties ().get_boundingbox (false);
 
-	      obj->qWidget<QWidget> ()
-		->setGeometry (xround (bb(0)), xround (bb(1)),
-			       xround (bb(2)), xround (bb(3)));
-	    }
-	}
+              obj->qWidget<QWidget> ()
+                ->setGeometry (xround (bb(0)), xround (bb(1)),
+                               xround (bb(2)), xround (bb(3)));
+            }
+        }
     }
 }
 
 void Container::childEvent (QChildEvent* ev)
 {
   if (ev->child ()->isWidgetType ())
     {
       qobject_cast<QWidget*> (ev->child ())->setMouseTracking (hasMouseTracking ());
diff --git a/libgui/graphics/ContextMenu.cc b/libgui/graphics/ContextMenu.cc
--- a/libgui/graphics/ContextMenu.cc
+++ b/libgui/graphics/ContextMenu.cc
@@ -64,29 +64,29 @@ void ContextMenu::update (int pId)
 {
   uicontextmenu::properties& up = properties<uicontextmenu> ();
   QMenu* xmenu = qWidget<QMenu> ();
 
   switch (pId)
     {
     case base_properties::ID_VISIBLE:
       if (up.is_visible ())
-	{
-	  Matrix pos = up.get_position ().matrix_value ();
-	  QWidget* parentW = xmenu->parentWidget ();
-	  QPoint pt;
+        {
+          Matrix pos = up.get_position ().matrix_value ();
+          QWidget* parentW = xmenu->parentWidget ();
+          QPoint pt;
 
-	  pt.rx () = xround (pos(0));
-	  pt.ry () = parentW->height () - xround (pos(1));
-	  pt = parentW->mapToGlobal (pt);
+          pt.rx () = xround (pos(0));
+          pt.ry () = parentW->height () - xround (pos(1));
+          pt = parentW->mapToGlobal (pt);
 
-	  xmenu->popup (pt);
-	}
+          xmenu->popup (pt);
+        }
       else
-	xmenu->hide ();
+        xmenu->hide ();
       break;
     default:
       Object::update (pId);
       break;
     }
 }
 
 void ContextMenu::aboutToShow (void)
@@ -109,24 +109,24 @@ void ContextMenu::executeAt (const base_
 {
   graphics_handle h = props.get_uicontextmenu ();
 
   if (h.ok ())
     {
       graphics_object go = gh_manager::get_object (h);
 
       if (go.valid_object ())
-	{
-	  ContextMenu* cMenu =
-	    dynamic_cast<ContextMenu*> (Backend::toolkitObject (go));
+        {
+          ContextMenu* cMenu =
+            dynamic_cast<ContextMenu*> (Backend::toolkitObject (go));
 
-	  if (cMenu)
-	    {
-	      QMenu* menu = cMenu->qWidget<QMenu> ();
+          if (cMenu)
+            {
+              QMenu* menu = cMenu->qWidget<QMenu> ();
 
-	      if (menu)
-		menu->popup (pt);
-	    }
-	}
+              if (menu)
+                menu->popup (pt);
+            }
+        }
     }
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/EditControl.cc b/libgui/graphics/EditControl.cc
--- a/libgui/graphics/EditControl.cc
+++ b/libgui/graphics/EditControl.cc
@@ -38,24 +38,24 @@ EditControl* EditControl::create (const 
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	{
-	  uicontrol::properties& up = Utils::properties<uicontrol> (go);
+        {
+          uicontrol::properties& up = Utils::properties<uicontrol> (go);
 
-	  if ((up.get_max () - up.get_min ()) > 1)
-	    return new EditControl (go, new TextEdit (container));
-	  else
-	    return new EditControl (go, new QLineEdit (container));
-	}
+          if ((up.get_max () - up.get_min ()) > 1)
+            return new EditControl (go, new TextEdit (container));
+          else
+            return new EditControl (go, new QLineEdit (container));
+        }
     }
 
   return 0;
 }
 
 EditControl::EditControl (const graphics_object& go, QLineEdit* edit)
      : BaseControl (go, edit), m_multiLine (false), m_textChanged (false)
 {
@@ -69,22 +69,22 @@ void EditControl::init (QLineEdit* edit,
 
   m_multiLine = false;
   initCommon (edit);
 
   uicontrol::properties& up = properties<uicontrol> ();
 
   edit->setText (Utils::fromStdString (up.get_string_string ()));
   edit->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
-					  up.get_verticalalignment ()));
+                                          up.get_verticalalignment ()));
 
   connect (edit, SIGNAL (textEdited (const QString&)),
-	   SLOT (textChanged (void)));
+           SLOT (textChanged (void)));
   connect (edit, SIGNAL (editingFinished (void)),
-	   SLOT (editingFinished (void)));
+           SLOT (editingFinished (void)));
 }
 
 EditControl::EditControl (const graphics_object& go, TextEdit* edit)
      : BaseControl (go, edit), m_multiLine (true), m_textChanged (false)
 {
   init (edit);
 }
 
@@ -98,19 +98,19 @@ void EditControl::init (TextEdit* edit, 
 
   uicontrol::properties& up = properties<uicontrol> ();
 
   edit->setAcceptRichText (false);
   // FIXME: support string_vector
   edit->setPlainText (Utils::fromStdString (up.get_string_string ()));
 
   connect (edit, SIGNAL (textChanged (void)),
-	   SLOT (textChanged (void)));
+           SLOT (textChanged (void)));
   connect (edit, SIGNAL (editingFinished (void)),
-	   SLOT (editingFinished (void)));
+           SLOT (editingFinished (void)));
 }
 
 EditControl::~EditControl (void)
 {
 }
 
 void EditControl::initCommon (QWidget*)
 {
@@ -124,48 +124,48 @@ void EditControl::update (int pId)
   if (m_multiLine)
     handled = updateMultiLine (pId);
   else
     handled = updateSingleLine (pId);
 
   if (! handled)
     {
       switch (pId)
-	{
-	default:
-	  BaseControl::update (pId);
-	  break;
-	}
+        {
+        default:
+          BaseControl::update (pId);
+          break;
+        }
     }
 }
 
 bool EditControl::updateSingleLine (int pId)
 {
   uicontrol::properties& up = properties<uicontrol> ();
   QLineEdit* edit = qWidget<QLineEdit> ();
 
   switch (pId)
     {
     case uicontrol::properties::ID_STRING:
       edit->setText (Utils::fromStdString (up.get_string_string ()));
       return true;
     case uicontrol::properties::ID_HORIZONTALALIGNMENT:
     case uicontrol::properties::ID_VERTICALALIGNMENT:
       edit->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
-					      up.get_verticalalignment ()));
+                                              up.get_verticalalignment ()));
       return true;
     case uicontrol::properties::ID_MIN:
     case uicontrol::properties::ID_MAX:
       if ((up.get_max () - up.get_min ()) > 1)
-	{
-	  QWidget* container = edit->parentWidget ();
+        {
+          QWidget* container = edit->parentWidget ();
 
-	  delete edit;
-	  init (new TextEdit (container), true);
-	}
+          delete edit;
+          init (new TextEdit (container), true);
+        }
       return true;
     default:
       break;
     }
 
   return false;
 }
 
@@ -177,22 +177,22 @@ bool EditControl::updateMultiLine (int p
   switch (pId)
     {
     case uicontrol::properties::ID_STRING:
       edit->setPlainText (Utils::fromStdString (up.get_string_string ()));
       return true;
     case uicontrol::properties::ID_MIN:
     case uicontrol::properties::ID_MAX:
       if ((up.get_max () - up.get_min ()) <= 1)
-	{
-	  QWidget* container = edit->parentWidget ();
+        {
+          QWidget* container = edit->parentWidget ();
 
-	  delete edit;
-	  init (new QLineEdit (container), true);
-	}
+          delete edit;
+          init (new QLineEdit (container), true);
+        }
       return true;
     default:
       break;
     }
 
   return false;
 }
 
@@ -201,18 +201,18 @@ void EditControl::textChanged (void)
   m_textChanged = true;
 }
 
 void EditControl::editingFinished (void)
 {
   if (m_textChanged)
     {
       QString txt = (m_multiLine
-		     ? qWidget<TextEdit> ()->toPlainText ()
-		     : qWidget<QLineEdit> ()->text ());
+                     ? qWidget<TextEdit> ()->toPlainText ()
+                     : qWidget<QLineEdit> ()->text ());
 
       gh_manager::post_set (m_handle, "string", Utils::toStdString (txt), false);
       gh_manager::post_callback (m_handle, "callback");
 
       m_textChanged = false;
     }
 }
 
diff --git a/libgui/graphics/Figure.cc b/libgui/graphics/Figure.cc
--- a/libgui/graphics/Figure.cc
+++ b/libgui/graphics/Figure.cc
@@ -56,33 +56,33 @@ static bool hasUiControlChildren (const 
 {
   Matrix kids = fp.get_all_children ();
 
   for (int i = 0; i < kids.numel (); i++)
     {
       graphics_object go (gh_manager::get_object (kids(i)));
 
       if (go && (go.isa ("uicontrol") || go.isa ("uipanel")
-		 || go.isa ("uibuttongroup")))
-	return true;
+                 || go.isa ("uibuttongroup")))
+        return true;
     }
 
   return false;
 }
 
 static bool hasUiMenuChildren (const figure::properties& fp)
 {
   Matrix kids = fp.get_all_children ();
 
   for (int i = 0; i < kids.numel (); i++)
     {
       graphics_object go (gh_manager::get_object (kids(i)));
 
       if (go && go.isa ("uimenu"))
-	return true;
+        return true;
     }
 
   return false;
 }
 
 static QRect boundingBoxToRect (const Matrix& bb)
 {
   QRect r;
@@ -168,48 +168,48 @@ void Figure::createFigureToolBarAndMenuB
   QMainWindow* win = qWidget<QMainWindow> ();
 
   m_figureToolBar = win->addToolBar (tr ("Figure ToolBar"));
   m_figureToolBar->setMovable (false);
   m_figureToolBar->setFloatable (false);
 
   MouseModeActionGroup* mouseModeGroup = new MouseModeActionGroup (win);
   connect (mouseModeGroup, SIGNAL (modeChanged (MouseMode)),
-	   SLOT (setMouseMode (MouseMode)));
+           SLOT (setMouseMode (MouseMode)));
   m_figureToolBar->addActions (mouseModeGroup->actions ());
 
   m_menuBar = new MenuBar (win);
   win->setMenuBar (m_menuBar);
 
   QMenu* fileMenu = m_menuBar->addMenu (tr ("&File"));
   fileMenu->menuAction ()->setObjectName ("builtinMenu");
   fileMenu->addAction (tr ("&New Figure"), this, SLOT (fileNewFigure (void)));
   fileMenu->addAction (tr ("&Open..."))->setEnabled (false);
   fileMenu->addSeparator ();
   fileMenu->addAction (tr ("&Save"))->setEnabled (false);
   fileMenu->addAction (tr ("Save &As"))->setEnabled (false);
   fileMenu->addSeparator ();
   fileMenu->addAction (tr ("&Close Figure"), this,
-		       SLOT (fileCloseFigure (void)), Qt::CTRL|Qt::Key_W);
+                       SLOT (fileCloseFigure (void)), Qt::CTRL|Qt::Key_W);
 
   QMenu* editMenu = m_menuBar->addMenu (tr ("&Edit"));
   editMenu->menuAction ()->setObjectName ("builtinMenu");
   editMenu->addAction (tr ("Cop&y"), this, SLOT (editCopy (void)),
-		       Qt::CTRL|Qt::Key_C)->setEnabled (false);
+                       Qt::CTRL|Qt::Key_C)->setEnabled (false);
   editMenu->addAction (tr ("Cu&t"), this, SLOT (editCut (void)),
-		       Qt::CTRL|Qt::Key_X)->setEnabled (false);
+                       Qt::CTRL|Qt::Key_X)->setEnabled (false);
   editMenu->addAction (tr ("&Paste"), this, SLOT (editPaste(void)),
-		       Qt::CTRL|Qt::Key_V)->setEnabled (false);
+                       Qt::CTRL|Qt::Key_V)->setEnabled (false);
   editMenu->addSeparator ();
   editMenu->addActions (mouseModeGroup->actions ());
 
   QMenu* helpMenu = m_menuBar->addMenu (tr ("&Help"));
   helpMenu->menuAction ()->setObjectName ("builtinMenu");
   helpMenu->addAction (tr ("&About QtHandles"), this,
-		       SLOT (helpAboutQtHandles (void)));
+                       SLOT (helpAboutQtHandles (void)));
   helpMenu->addAction (tr ("About &Qt"), qApp, SLOT (aboutQt (void)));
 
   m_menuBar->addReceiver (this);
 }
 
 Container* Figure::innerContainer (void)
 {
   return m_container;
@@ -221,22 +221,22 @@ void Figure::redraw (void)
 
   if (canvas)
     {
     canvas->redraw ();
     //canvas->setMouseMode (RotateMode);
     }
 
   foreach (QFrame* frame,
-	   qWidget<QWidget> ()->findChildren<QFrame*> ("UIPanel"))
+           qWidget<QWidget> ()->findChildren<QFrame*> ("UIPanel"))
     {
       Object* obj = Object::fromQObject (frame);
 
       if (obj)
-	obj->slotRedraw ();
+        obj->slotRedraw ();
     }
 }
 
 void Figure::beingDeleted (void)
 {
   Canvas* canvas = m_container->canvas (m_handle.value (), false);
 
   if (canvas)
@@ -255,48 +255,48 @@ void Figure::update (int pId)
   figure::properties& fp = properties<figure> ();
   QMainWindow* win = qWidget<QMainWindow> ();
 
   m_blockUpdates = true;
 
   switch (pId)
     {
     case figure::properties::ID_POSITION:
-	{
+        {
           m_innerRect = boundingBoxToRect (fp.get_boundingbox (true));
           //qDebug () << "Figure::update(position):" << m_innerRect;
-	  int offset = 0;
+          int offset = 0;
 
           foreach (QToolBar* tb, win->findChildren<QToolBar*> ())
             if (! tb->isHidden ())
               offset += tb->sizeHint ().height ();
-	  if (! m_menuBar->isHidden ())
-	    offset += m_menuBar->sizeHint ().height () + 1;
+          if (! m_menuBar->isHidden ())
+            offset += m_menuBar->sizeHint ().height () + 1;
           //qDebug () << "Figure::update(position)(adjusted):" << m_innerRect.adjusted (0, -offset, 0, 0);
-	  win->setGeometry (m_innerRect.adjusted (0, -offset, 0, 0));
+          win->setGeometry (m_innerRect.adjusted (0, -offset, 0, 0));
           //qDebug () << "Figure::update(position): done";
-	}
+        }
       break;
     case figure::properties::ID_NAME:
     case figure::properties::ID_NUMBERTITLE:
       win->setWindowTitle (Utils::fromStdString (fp.get_title ()));
       break;
     case figure::properties::ID_VISIBLE:
       if (fp.is_visible ())
-	QTimer::singleShot (0, win, SLOT (show ()));
+        QTimer::singleShot (0, win, SLOT (show ()));
       else
-	win->hide ();
+        win->hide ();
       break;
     case figure::properties::ID_TOOLBAR:
       if (fp.toolbar_is ("none"))
-	showFigureToolBar (false);
+        showFigureToolBar (false);
       else if (fp.toolbar_is ("figure"))
-	showFigureToolBar (true);
+        showFigureToolBar (true);
       else // "auto"
-	showFigureToolBar (! hasUiControlChildren (fp));
+        showFigureToolBar (! hasUiControlChildren (fp));
       break;
     case figure::properties::ID_MENUBAR:
       showMenuBar (fp.menubar_is ("figure"));
       break;
     case figure::properties::ID_KEYPRESSFCN:
       if (fp.get_keypressfcn ().is_empty ())
         m_container->canvas (m_handle)->clearEventMask (Canvas::KeyPress);
       else
@@ -327,34 +327,34 @@ void Figure::update (int pId)
 void Figure::showFigureToolBar (bool visible)
 {
   if ((! m_figureToolBar->isHidden ()) != visible)
     {
       int dy = m_figureToolBar->sizeHint ().height ();
       QRect r = qWidget<QWidget> ()->geometry ();
 
       if (! visible)
-	r.adjust (0, dy, 0, 0);
+        r.adjust (0, dy, 0, 0);
       else
-	r.adjust (0, -dy, 0, 0);
+        r.adjust (0, -dy, 0, 0);
 
       m_blockUpdates = true;
       qWidget<QWidget> ()->setGeometry (r);
       m_figureToolBar->setVisible (visible);
       m_blockUpdates = false;
 
       updateBoundingBox (false);
 
       if (visible)
-	m_mouseMode = m_lastMouseMode;
+        m_mouseMode = m_lastMouseMode;
       else
-	{
-	  m_lastMouseMode = m_mouseMode;
-	  m_mouseMode = NoMode;
-	}
+        {
+          m_lastMouseMode = m_mouseMode;
+          m_mouseMode = NoMode;
+        }
     }
 }
 
 void Figure::showMenuBar (bool visible)
 {
   int h1 = m_menuBar->sizeHint ().height ();
 
   foreach (QAction* a, m_menuBar->actions ())
@@ -368,19 +368,19 @@ void Figure::showMenuBar (bool visible)
 
   if ((! m_menuBar->isHidden ()) != visible)
     {
       int dy = qMax (h1, h2) + 1;
       QRect r = qWidget<QWidget> ()->geometry ();
 
       //qDebug () << "Figure::showMenuBar:" << r;
       if (! visible)
-	r.adjust (0, dy, 0, 0);
+        r.adjust (0, dy, 0, 0);
       else
-	r.adjust (0, -dy, 0, 0);
+        r.adjust (0, -dy, 0, 0);
       //qDebug () << "Figure::showMenuBar(adjusted):" << r;
 
       m_blockUpdates = true;
       qWidget<QWidget> ()->setGeometry (r);
       m_menuBar->setVisible (visible);
       m_blockUpdates = false;
 
       updateBoundingBox (false);
@@ -493,116 +493,116 @@ void Figure::updateBoundingBox (bool int
   gh_manager::post_function (Figure::updateBoundingBoxHelper, d);
 }
 
 bool Figure::eventNotifyBefore (QObject* obj, QEvent* ev)
 {
   if (! m_blockUpdates)
     {
       if (obj == m_container)
-	{
+        {
           // Do nothing...
-	}
+        }
       else if (obj == m_menuBar)
-	{
-	  switch (ev->type ())
-	    {
-	    case QEvent::ActionRemoved:
-		{
-		  QAction* a = dynamic_cast<QActionEvent*> (ev)->action ();
+        {
+          switch (ev->type ())
+            {
+            case QEvent::ActionRemoved:
+                {
+                  QAction* a = dynamic_cast<QActionEvent*> (ev)->action ();
 
-		  if (! a->isSeparator ()
-		      && a->objectName () != "builtinMenu")
+                  if (! a->isSeparator ()
+                      && a->objectName () != "builtinMenu")
                     updateMenuBar ();
-		}
-	      break;
-	    default:
-	      break;
-	    }
-	}
+                }
+              break;
+            default:
+              break;
+            }
+        }
       else
-	{
-	  switch (ev->type ())
-	    {
-	    case QEvent::Close:
-	      ev->ignore ();
-	      gh_manager::post_callback (m_handle, "closerequestfcn");
-	      return true;
-	    default:
-	      break;
-	    }
-	}
+        {
+          switch (ev->type ())
+            {
+            case QEvent::Close:
+              ev->ignore ();
+              gh_manager::post_callback (m_handle, "closerequestfcn");
+              return true;
+            default:
+              break;
+            }
+        }
     }
 
   return false;
 }
 
 void Figure::eventNotifyAfter (QObject* watched, QEvent* ev)
 {
   if (! m_blockUpdates)
     {
       if (watched == m_container)
         {
-	  switch (ev->type ())
-	    {
-	    case QEvent::Resize:
-	      updateBoundingBox (true, UpdateBoundingBoxSize);
-	      break;
-	    case QEvent::ChildAdded:
-	      if (dynamic_cast<QChildEvent*> (ev)->child
-		  ()->isWidgetType())
-		{
-		  gh_manager::auto_lock lock;
-		  const figure::properties& fp = properties<figure> ();
+          switch (ev->type ())
+            {
+            case QEvent::Resize:
+              updateBoundingBox (true, UpdateBoundingBoxSize);
+              break;
+            case QEvent::ChildAdded:
+              if (dynamic_cast<QChildEvent*> (ev)->child
+                  ()->isWidgetType())
+                {
+                  gh_manager::auto_lock lock;
+                  const figure::properties& fp = properties<figure> ();
 
-		  showFigureToolBar (! hasUiControlChildren (fp));
-		}
-	    default:
-	      break;
-	    }
+                  showFigureToolBar (! hasUiControlChildren (fp));
+                }
+            default:
+              break;
+            }
         }
       else if (watched == m_menuBar)
         {
-	  switch (ev->type ())
-	    {
-	    case QEvent::ActionAdded:
-		{
-		  QAction* a = dynamic_cast<QActionEvent*> (ev)->action ();
+          switch (ev->type ())
+            {
+            case QEvent::ActionAdded:
+                {
+                  QAction* a = dynamic_cast<QActionEvent*> (ev)->action ();
 
-		  if (! a->isSeparator ()
+                  if (! a->isSeparator ()
                       && a->objectName () != "builtinMenu")
                     updateMenuBar ();
-		}
-	      break;
-	    default:
-	      break;
-	    }
+                }
+              break;
+            default:
+              break;
+            }
         }
       else
         {
-	  switch (ev->type ())
-	    {
-	    case QEvent::Move:
-	      updateBoundingBox (false, UpdateBoundingBoxPosition);
-	      updateBoundingBox (true, UpdateBoundingBoxPosition);
-	      break;
-	    case QEvent::Resize:
-	      updateBoundingBox (false, UpdateBoundingBoxSize);
-	      break;
-	    default:
-	      break;
-	    }
+          switch (ev->type ())
+            {
+            case QEvent::Move:
+              updateBoundingBox (false, UpdateBoundingBoxPosition);
+              updateBoundingBox (true, UpdateBoundingBoxPosition);
+              break;
+            case QEvent::Resize:
+              updateBoundingBox (false, UpdateBoundingBoxSize);
+              break;
+            default:
+              break;
+            }
         }
     }
 }
 
 void Figure::helpAboutQtHandles (void)
 {
   QMessageBox::about (qWidget<QMainWindow> (), tr ("About QtHandles"),
-		      ABOUT_TEXT);
+                      ABOUT_TEXT);
 }
 
 void Figure::fileNewFigure (void)
 {
 }
 
 void Figure::fileCloseFigure (void)
 {
@@ -651,19 +651,19 @@ void Figure::showCustomToolBar (QToolBar
   QMainWindow* win = qWidget<QMainWindow> ();
 
   if ((! bar->isHidden ()) != visible)
     {
       QSize sz = bar->sizeHint ();
       QRect r = win->geometry ();
 
       if (visible)
-	r.adjust (0, -sz.height (), 0, 0);
+        r.adjust (0, -sz.height (), 0, 0);
       else
-	r.adjust (0, sz.height (), 0, 0);
+        r.adjust (0, sz.height (), 0, 0);
 
       m_blockUpdates = true;
       win->setGeometry (r);
       bar->setVisible (visible);
       m_blockUpdates = false;
 
       updateBoundingBox (false);
     }
diff --git a/libgui/graphics/Figure.h b/libgui/graphics/Figure.h
--- a/libgui/graphics/Figure.h
+++ b/libgui/graphics/Figure.h
@@ -32,21 +32,21 @@ along with Octave; see the file COPYING.
 class QMainWindow;
 class QToolBar;
 
 namespace QtHandles
 {
 
 enum MouseMode
 {
-  NoMode	= 0,
-  RotateMode	= 1,
-  ZoomMode	= 2,
-  PanMode	= 3,
-  SelectMode	= 4
+  NoMode        = 0,
+  RotateMode    = 1,
+  ZoomMode      = 2,
+  PanMode       = 3,
+  SelectMode    = 4
 };
 
 class Container;
 class FigureWindow;
 class MenuBar;
 class ToolBar;
 
 class Figure :
diff --git a/libgui/graphics/GLCanvas.h b/libgui/graphics/GLCanvas.h
--- a/libgui/graphics/GLCanvas.h
+++ b/libgui/graphics/GLCanvas.h
@@ -34,17 +34,17 @@ class GLCanvas : public QGLWidget, publi
 {
 public:
   GLCanvas (QWidget* parent, const graphics_handle& handle);
   ~GLCanvas (void);
 
   void draw (const graphics_handle& handle);
   void drawZoomBox (const QPoint& p1, const QPoint& p2);
   void resize (int /* x */, int /* y */,
-	       int /* width */, int /* height */) { }
+               int /* width */, int /* height */) { }
   graphics_object selectFromAxes (const graphics_object& ax,
                                   const QPoint& pt);
   QWidget* qWidget (void) { return this; }
 
 protected:
   void paintGL (void);
   void mouseMoveEvent (QMouseEvent* event);
   void mousePressEvent (QMouseEvent* event);
diff --git a/libgui/graphics/ListBoxControl.cc b/libgui/graphics/ListBoxControl.cc
--- a/libgui/graphics/ListBoxControl.cc
+++ b/libgui/graphics/ListBoxControl.cc
@@ -64,17 +64,17 @@ ListBoxControl* ListBoxControl::create (
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	return new ListBoxControl (go, new QListWidget (container));
+        return new ListBoxControl (go, new QListWidget (container));
     }
 
   return 0;
 }
 
 ListBoxControl::ListBoxControl (const graphics_object& go, QListWidget* list)
      : BaseControl (go, list), m_blockCallback (false)
 {
@@ -87,35 +87,35 @@ ListBoxControl::ListBoxControl (const gr
     list->setSelectionMode (QAbstractItemView::SingleSelection);
   Matrix value = up.get_value ().matrix_value ();
   if (value.numel () > 0)
     {
       octave_idx_type n = value.numel ();
       int lc = list->count ();
 
       for (octave_idx_type i = 0; i < n; i++)
-	{
-	  int idx = xround (value(i));
+        {
+          int idx = xround (value(i));
 
-	  if (1 <= idx && idx <= lc)
-	    {
-	      list->item (idx-1)->setSelected (true);
-	      if (i == 0
-		  && list->selectionMode () ==
-		  	QAbstractItemView::SingleSelection)
-		break;
-	    }
-	}
+          if (1 <= idx && idx <= lc)
+            {
+              list->item (idx-1)->setSelected (true);
+              if (i == 0
+                  && list->selectionMode () ==
+                        QAbstractItemView::SingleSelection)
+                break;
+            }
+        }
     }
 
   list->removeEventFilter (this);
   list->viewport ()->installEventFilter (this);
 
   connect (list, SIGNAL (itemSelectionChanged (void)),
-	   SLOT (itemSelectionChanged (void)));
+           SLOT (itemSelectionChanged (void)));
 }
 
 ListBoxControl::~ListBoxControl (void)
 {
 }
 
 void ListBoxControl::update (int pId)
 {
@@ -129,19 +129,19 @@ void ListBoxControl::update (int pId)
       list->clear ();
       list->addItems (Utils::fromStringVector (up.get_string_vector ()));
       updateSelection (list, up.get_value ().matrix_value ());
       m_blockCallback = false;
       break;
     case uicontrol::properties::ID_MIN:
     case uicontrol::properties::ID_MAX:
       if ((up.get_max () - up.get_min ()) > 1)
-	list->setSelectionMode (QAbstractItemView::ExtendedSelection);
+        list->setSelectionMode (QAbstractItemView::ExtendedSelection);
       else
-	list->setSelectionMode (QAbstractItemView::SingleSelection);
+        list->setSelectionMode (QAbstractItemView::SingleSelection);
       break;
     case uicontrol::properties::ID_VALUE:
       m_blockCallback = true;
       updateSelection (list, up.get_value ().matrix_value ());
       m_blockCallback = false;
       break;
     default:
       BaseControl::update (pId);
diff --git a/libgui/graphics/Menu.cc b/libgui/graphics/Menu.cc
--- a/libgui/graphics/Menu.cc
+++ b/libgui/graphics/Menu.cc
@@ -41,36 +41,36 @@ static QKeySequence accelSequence (const
   std::string s (up.get_accelerator ());
 
   if (! s.empty ())
     {
       char c = s[0];
       int keyMod = Qt::CTRL;
 
       if (c >= 'A' && c <= 'Z')
-	keyMod |= Qt::SHIFT;
+        keyMod |= Qt::SHIFT;
       if (c >= 'a' && c <= 'z')
-	c -= ('a' - 'A');
+        c -= ('a' - 'A');
       if (c >= 'A' && c <= 'Z')
-	return QKeySequence (keyMod | static_cast<int> (c));
+        return QKeySequence (keyMod | static_cast<int> (c));
     }
 
   return QKeySequence ();
 }
 
 Menu* Menu::create (const graphics_object& go)
 {
   Object* parent_obj = Object::parentObject (go);
 
   if (parent_obj)
     {
       QObject* qObj = parent_obj->qObject ();
 
       if (qObj)
-	return new Menu (go, new QAction (qObj), parent_obj);
+        return new Menu (go, new QAction (qObj), parent_obj);
     }
 
   return 0;
 }
 
 Menu::Menu (const graphics_object& go, QAction* action, Object* xparent)
     : Object (go, action), m_parent (0), m_separator (0)
 {
@@ -97,56 +97,56 @@ Menu::Menu (const graphics_object& go, Q
   if (menuContainer)
     m_parent = menuContainer->menu ();
 
   if (m_parent)
     {
       int pos = static_cast<int> (up.get_position ());
 
       if (pos <= 0)
-	{
-	  if (m_separator)
-	    m_parent->insertAction (0, m_separator);
-	  m_parent->insertAction (0, action);
+        {
+          if (m_separator)
+            m_parent->insertAction (0, m_separator);
+          m_parent->insertAction (0, action);
 
-	  int count = 0;
+          int count = 0;
 
-	  foreach (QAction* a, m_parent->actions ())
-	    if (! a->isSeparator () && a->objectName () != "builtinMenu")
-	      count++;
-	  up.get_property ("position").set
-	    (octave_value (static_cast<double> (count)), true, false);
-	}
+          foreach (QAction* a, m_parent->actions ())
+            if (! a->isSeparator () && a->objectName () != "builtinMenu")
+              count++;
+          up.get_property ("position").set
+            (octave_value (static_cast<double> (count)), true, false);
+        }
       else
-	{
+        {
 
-	  int count = 0;
-	  QAction* before = 0;
+          int count = 0;
+          QAction* before = 0;
 
-	  foreach (QAction* a, m_parent->actions ())
-	    if (! a->isSeparator () && a->objectName () != "builtinMenu")
-	      {
-		count++;
-		if (pos <= count)
-		  {
-		    before = a;
-		    break;
-		  }
-	      }
+          foreach (QAction* a, m_parent->actions ())
+            if (! a->isSeparator () && a->objectName () != "builtinMenu")
+              {
+                count++;
+                if (pos <= count)
+                  {
+                    before = a;
+                    break;
+                  }
+              }
 
-	  if (m_separator)
-	    m_parent->insertAction (before, m_separator);
-	  m_parent->insertAction (before, action);
+          if (m_separator)
+            m_parent->insertAction (before, m_separator);
+          m_parent->insertAction (before, action);
 
-	  if (before)
-	    updateSiblingPositions ();
-	  else
-	    up.get_property ("position").set
-	      (octave_value (static_cast<double> (count+1)), true, false);
-	}
+          if (before)
+            updateSiblingPositions ();
+          else
+            up.get_property ("position").set
+              (octave_value (static_cast<double> (count+1)), true, false);
+        }
     }
 
   connect (action, SIGNAL (triggered (bool)), SLOT (actionTriggered (void)));
 }
 
 Menu::~Menu (void)
 {
 }
@@ -158,86 +158,86 @@ void Menu::update (int pId)
 
   switch (pId)
     {
     case uimenu::properties::ID_LABEL:
       action->setText (Utils::fromStdString (up.get_label ()));
       break;
     case uimenu::properties::ID_CHECKED:
       if (up.is_checked ())
-	{
-	  action->setCheckable (true);
-	  action->setChecked (up.is_checked ());
-	}
+        {
+          action->setCheckable (true);
+          action->setChecked (up.is_checked ());
+        }
       else
-	{
-	  action->setChecked (false);
-	  action->setCheckable (false);
-	}
+        {
+          action->setChecked (false);
+          action->setCheckable (false);
+        }
       break;
     case uimenu::properties::ID_ENABLE:
       action->setEnabled (up.is_enable ());
       break;
     case uimenu::properties::ID_ACCELERATOR:
       if (! action->menu ())
-	action->setShortcut (accelSequence (up));
+        action->setShortcut (accelSequence (up));
       break;
     case uimenu::properties::ID_SEPARATOR:
       if (up.is_separator ())
-	{
-	  if (! m_separator)
-	    {
-	      m_separator = new QAction (action);
-	      m_separator->setSeparator (true);
-	      m_separator->setVisible (up.is_visible ());
-	      if (m_parent)
-		m_parent->insertAction (action, m_separator);
-	    }
-	}
+        {
+          if (! m_separator)
+            {
+              m_separator = new QAction (action);
+              m_separator->setSeparator (true);
+              m_separator->setVisible (up.is_visible ());
+              if (m_parent)
+                m_parent->insertAction (action, m_separator);
+            }
+        }
       else
-	{
-	  if (m_separator)
-	    delete m_separator;
-	  m_separator = 0;
-	}
+        {
+          if (m_separator)
+            delete m_separator;
+          m_separator = 0;
+        }
       break;
     case uimenu::properties::ID_VISIBLE:
       action->setVisible (up.is_visible ());
       if (m_separator)
-	m_separator->setVisible (up.is_visible ());
+        m_separator->setVisible (up.is_visible ());
       break;
     case uimenu::properties::ID_POSITION:
       if (m_separator)
-	m_parent->removeAction (m_separator);
+        m_parent->removeAction (m_separator);
       m_parent->removeAction (action);
-	{
-	  int pos = static_cast<int> (up.get_position ());
-	  QAction* before = 0;
+        {
+          int pos = static_cast<int> (up.get_position ());
+          QAction* before = 0;
 
-	  if (pos > 0)
-	    {
-	      int count = 0;
+          if (pos > 0)
+            {
+              int count = 0;
 
-	      foreach (QAction* a, m_parent->actions ())
-		if (! a->isSeparator () && a->objectName () != "builtinMenu")
-		  {
-		    count++;
-		    if (pos <= count)
-		      {
-			before = a;
-			break;
-		      }
-		  }
-	    }
+              foreach (QAction* a, m_parent->actions ())
+                if (! a->isSeparator () && a->objectName () != "builtinMenu")
+                  {
+                    count++;
+                    if (pos <= count)
+                      {
+                        before = a;
+                        break;
+                      }
+                  }
+            }
 
-	  if (m_separator)
-	    m_parent->insertAction (before, m_separator);
-	  m_parent->insertAction (before, action);
-	  updateSiblingPositions ();
-	}
+          if (m_separator)
+            m_parent->insertAction (before, m_separator);
+          m_parent->insertAction (before, action);
+          updateSiblingPositions ();
+        }
       break;
     default:
       Object::update (pId);
       break;
     }
 }
 
 QWidget* Menu::menu (void)
@@ -246,17 +246,17 @@ QWidget* Menu::menu (void)
   QMenu* _menu = action->menu ();
 
   if (! _menu)
     {
       _menu = new QMenu (action->parentWidget ());
       action->setMenu (_menu);
       action->setShortcut (QKeySequence ());
       connect (_menu, SIGNAL (aboutToShow (void)),
-	       this, SLOT (actionHovered (void)));
+               this, SLOT (actionHovered (void)));
     }
 
   return _menu;
 }
 
 void Menu::actionTriggered (void)
 {
   QAction* action = qWidget<QAction> ();
@@ -273,35 +273,35 @@ void Menu::actionHovered (void)
 
 void Menu::updateSiblingPositions (void)
 {
   if (m_parent)
     {
       double count = 1.0;
 
       foreach (QAction* a, m_parent->actions ())
-	{
-	  if (! a->isSeparator () && a->objectName () != "builtinMenu")
-	    {
-	      Object* aObj = Object::fromQObject (a);
+        {
+          if (! a->isSeparator () && a->objectName () != "builtinMenu")
+            {
+              Object* aObj = Object::fromQObject (a);
 
-	      if (aObj)
-		{
-		  graphics_object go = aObj->object ();
+              if (aObj)
+                {
+                  graphics_object go = aObj->object ();
 
-		  // Probably overkill as a uimenu child can only be another
-		  // uimenu object.
-		  if (go.isa ("uimenu"))
-		    {
-		      uimenu::properties& up = Utils::properties<uimenu> (go);
+                  // Probably overkill as a uimenu child can only be another
+                  // uimenu object.
+                  if (go.isa ("uimenu"))
+                    {
+                      uimenu::properties& up = Utils::properties<uimenu> (go);
 
-		      up.get_property ("position").set
-			(octave_value (count), true, false);
-		    }
-		}
+                      up.get_property ("position").set
+                        (octave_value (count), true, false);
+                    }
+                }
 
-	      count++;
-	    }
-	}
+              count++;
+            }
+        }
     }
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/MouseModeActionGroup.cc b/libgui/graphics/MouseModeActionGroup.cc
--- a/libgui/graphics/MouseModeActionGroup.cc
+++ b/libgui/graphics/MouseModeActionGroup.cc
@@ -32,23 +32,23 @@ along with Octave; see the file COPYING.
 
 namespace QtHandles
 {
 
 MouseModeActionGroup::MouseModeActionGroup (QObject* xparent)
   : QObject (xparent), m_current (0)
 {
   m_actions.append (new QAction (QIcon (":/images/rotate.png"),
-				 tr ("Rotate"), this));
+                                 tr ("Rotate"), this));
   m_actions.append (new QAction (QIcon (":/images/zoom.png"),
-				 tr ("Zoom"), this));
+                                 tr ("Zoom"), this));
   m_actions.append (new QAction (QIcon (":/images/pan.png"),
-				 tr ("Pan"), this));
+                                 tr ("Pan"), this));
   m_actions.append (new QAction (QIcon (":/images/select.png"),
-				 tr ("Select"), this));
+                                 tr ("Select"), this));
   m_actions[2]->setEnabled (false);
   m_actions[3]->setEnabled (false);
 
   foreach (QAction* a, m_actions)
     {
       a->setCheckable (true);
       connect (a, SIGNAL (toggled (bool)), this, SLOT (actionToggled (bool)));
     }
@@ -58,33 +58,33 @@ MouseModeActionGroup::~MouseModeActionGr
 {
 }
 
 void MouseModeActionGroup::actionToggled (bool checked)
 {
   if (! checked)
     {
       if (sender () == m_current)
-	{
-	  m_current = 0;
-	  emit modeChanged (NoMode);
-	}
+        {
+          m_current = 0;
+          emit modeChanged (NoMode);
+        }
     }
   else
     {
       int i = m_actions.indexOf (qobject_cast<QAction*> (sender ()));
 
       if (i >= 0)
-	{
-	  m_current = m_actions[i];
-	  for (int j = 0; j < m_actions.size (); j++)
-	    if (j != i)
-	      m_actions[j]->setChecked (false);
-	  emit modeChanged (static_cast<MouseMode> (i+1));
-	}
+        {
+          m_current = m_actions[i];
+          for (int j = 0; j < m_actions.size (); j++)
+            if (j != i)
+              m_actions[j]->setChecked (false);
+          emit modeChanged (static_cast<MouseMode> (i+1));
+        }
     }
 }
 
 MouseMode MouseModeActionGroup::mouseMode (void) const
 {
   int i = (m_current ? -1 : m_actions.indexOf (m_current));
 
   return static_cast<MouseMode> (i+1);
diff --git a/libgui/graphics/Object.cc b/libgui/graphics/Object.cc
--- a/libgui/graphics/Object.cc
+++ b/libgui/graphics/Object.cc
@@ -35,51 +35,51 @@ namespace QtHandles
 
 Object::Object (const graphics_object& go, QObject* obj)
   : QObject (), m_handle (go.get_handle ()), m_qobject (0)
 {
   gh_manager::auto_lock lock (false);
 
   if (! lock)
     qCritical ("QtHandles::Object::Object: "
-	       "creating Object (h=%g) without a valid lock!!!",
-	       m_handle.value ());
+               "creating Object (h=%g) without a valid lock!!!",
+               m_handle.value ());
 
   init (obj);
 }
 
 void Object::init (QObject* obj, bool)
 {
   if (m_qobject)
     qCritical ("QtHandles::Object::init: "
-	       "resetting QObject while in invalid state");
+               "resetting QObject while in invalid state");
 
   m_qobject = obj;
 
   if (m_qobject)
     {
       m_qobject->setProperty ("QtHandles::Object",
-			      qVariantFromValue<void*> (this));
+                              qVariantFromValue<void*> (this));
       connect (m_qobject, SIGNAL (destroyed (QObject*)),
-	       SLOT (objectDestroyed (QObject*)));
+               SLOT (objectDestroyed (QObject*)));
     }
 }
 
 Object::~Object (void)
 {
 }
 
 graphics_object Object::object (void) const
 {
   gh_manager::auto_lock lock (false);
 
   if (! lock)
     qCritical ("QtHandles::Object::object: "
-	       "accessing graphics object (h=%g) without a valid lock!!!",
-	       m_handle.value ());
+               "accessing graphics object (h=%g) without a valid lock!!!",
+               m_handle.value ());
 
   return gh_manager::get_object (m_handle);
 }
 
 void Object::slotUpdate (int pId)
 {
   gh_manager::auto_lock lock;
 
@@ -88,17 +88,17 @@ void Object::slotUpdate (int pId)
     // Special case for objects being deleted, as it's very likely
     // that the graphics_object already has been destroyed when this
     // is executed (because of the async behavior).
     case base_properties::ID_BEINGDELETED:
       beingDeleted ();
       break;
     default:
       if (object ().valid_object ())
-	update (pId);
+        update (pId);
       break;
     }
 }
 
 void Object::slotFinalize (void)
 {
   gh_manager::auto_lock lock;
 
diff --git a/libgui/graphics/Object.h b/libgui/graphics/Object.h
--- a/libgui/graphics/Object.h
+++ b/libgui/graphics/Object.h
@@ -50,24 +50,24 @@ public:
 
   const base_properties& properties (void) const
     { return object ().get_properties (); }
 
   template <class T>
   typename T::properties& properties (void)
     {
       return dynamic_cast<typename T::properties&>
-	(object ().get_properties ());
+        (object ().get_properties ());
     }
 
   template <class T>
   const typename T::properties& properties (void) const
     {
       return dynamic_cast<const typename T::properties&>
-	(object ().get_properties ());
+        (object ().get_properties ());
     }
 
   graphics_object object (void) const;
 
   virtual QObject* qObject (void) { return m_qobject; }
 
   template <class T>
   T* qWidget (void) { return qobject_cast<T*>(qObject ()); }
diff --git a/libgui/graphics/ObjectFactory.cc b/libgui/graphics/ObjectFactory.cc
--- a/libgui/graphics/ObjectFactory.cc
+++ b/libgui/graphics/ObjectFactory.cc
@@ -57,93 +57,93 @@ namespace QtHandles
 ObjectFactory* ObjectFactory::instance (void)
 {
   static ObjectFactory s_instance;
   static bool s_instanceCreated = false;
 
   if (! s_instanceCreated)
     {
       if (QThread::currentThread () != QApplication::instance ()->thread ())
-	s_instance.moveToThread (QApplication::instance ()->thread ());
+        s_instance.moveToThread (QApplication::instance ()->thread ());
       s_instanceCreated = true;
     }
 
   return &s_instance;
 }
 
 void ObjectFactory::createObject (double handle)
 {
   gh_manager::auto_lock lock;
 
   graphics_object go (gh_manager::get_object (graphics_handle (handle)));
 
   if (go.valid_object ())
     {
       if (go.get_properties ().is_beingdeleted ())
-	qWarning ("ObjectFactory::createObject: object is being deleted");
+        qWarning ("ObjectFactory::createObject: object is being deleted");
       else
-	{
-	  ObjectProxy* proxy = Backend::toolkitObjectProxy (go);
+        {
+          ObjectProxy* proxy = Backend::toolkitObjectProxy (go);
 
-	  if (proxy)
-	    {
-	      Logger::debug ("ObjectFactory::createObject: "
-			     "create %s from thread %08x",
-			     go.type ().c_str (), QThread::currentThreadId ());
+          if (proxy)
+            {
+              Logger::debug ("ObjectFactory::createObject: "
+                             "create %s from thread %08x",
+                             go.type ().c_str (), QThread::currentThreadId ());
 
-	      Object* obj = 0;
+              Object* obj = 0;
 
-	      if (go.isa ("figure"))
-		obj = Figure::create (go);
-	      else if (go.isa ("uicontrol"))
-		{
-		  uicontrol::properties& up =
-		   Utils::properties<uicontrol> (go);
+              if (go.isa ("figure"))
+                obj = Figure::create (go);
+              else if (go.isa ("uicontrol"))
+                {
+                  uicontrol::properties& up =
+                   Utils::properties<uicontrol> (go);
 
-		  if (up.style_is ("pushbutton"))
-		    obj = PushButtonControl::create (go);
-		  else if (up.style_is ("edit"))
-		    obj = EditControl::create (go);
-		  else if (up.style_is ("checkbox"))
-		    obj = CheckBoxControl::create (go);
-		  else if (up.style_is ("radiobutton"))
-		    obj = RadioButtonControl::create (go);
-		  else if (up.style_is ("togglebutton"))
-		    obj = ToggleButtonControl::create (go);
-		  else if (up.style_is ("text"))
-		    obj = TextControl::create (go);
-		  else if (up.style_is ("popupmenu"))
-		    obj = PopupMenuControl::create (go);
-		  else if (up.style_is ("slider"))
-		    obj = SliderControl::create (go);
-		  else if (up.style_is ("listbox"))
-		    obj = ListBoxControl::create (go);
-		}
-	      else if (go.isa ("uipanel"))
-		obj = Panel::create (go);
-	      else if (go.isa ("uimenu"))
-		obj = Menu::create (go);
-	      else if (go.isa ("uicontextmenu"))
-		obj = ContextMenu::create (go);
-	      else if (go.isa ("uitoolbar"))
-		obj = ToolBar::create (go);
-	      else if (go.isa ("uipushtool"))
-		obj = PushTool::create (go);
-	      else if (go.isa ("uitoggletool"))
-		obj = ToggleTool::create (go);
-	      else
-		qWarning ("ObjectFactory::createObject: unsupported type `%s'",
-			  go.type ().c_str ());
+                  if (up.style_is ("pushbutton"))
+                    obj = PushButtonControl::create (go);
+                  else if (up.style_is ("edit"))
+                    obj = EditControl::create (go);
+                  else if (up.style_is ("checkbox"))
+                    obj = CheckBoxControl::create (go);
+                  else if (up.style_is ("radiobutton"))
+                    obj = RadioButtonControl::create (go);
+                  else if (up.style_is ("togglebutton"))
+                    obj = ToggleButtonControl::create (go);
+                  else if (up.style_is ("text"))
+                    obj = TextControl::create (go);
+                  else if (up.style_is ("popupmenu"))
+                    obj = PopupMenuControl::create (go);
+                  else if (up.style_is ("slider"))
+                    obj = SliderControl::create (go);
+                  else if (up.style_is ("listbox"))
+                    obj = ListBoxControl::create (go);
+                }
+              else if (go.isa ("uipanel"))
+                obj = Panel::create (go);
+              else if (go.isa ("uimenu"))
+                obj = Menu::create (go);
+              else if (go.isa ("uicontextmenu"))
+                obj = ContextMenu::create (go);
+              else if (go.isa ("uitoolbar"))
+                obj = ToolBar::create (go);
+              else if (go.isa ("uipushtool"))
+                obj = PushTool::create (go);
+              else if (go.isa ("uitoggletool"))
+                obj = ToggleTool::create (go);
+              else
+                qWarning ("ObjectFactory::createObject: unsupported type `%s'",
+                          go.type ().c_str ());
 
-	      if (obj)
-		proxy->setObject (obj);
-	    }
-	  else
-	    qWarning ("ObjectFactory::createObject: no proxy for handle %g",
-		      handle);
-	}
+              if (obj)
+                proxy->setObject (obj);
+            }
+          else
+            qWarning ("ObjectFactory::createObject: no proxy for handle %g",
+                      handle);
+        }
     }
   else
     qWarning ("ObjectFactory::createObject: invalid object for handle %g",
-	      handle);
+              handle);
 }
 
 };
diff --git a/libgui/graphics/ObjectProxy.cc b/libgui/graphics/ObjectProxy.cc
--- a/libgui/graphics/ObjectProxy.cc
+++ b/libgui/graphics/ObjectProxy.cc
@@ -38,36 +38,36 @@ ObjectProxy::ObjectProxy (Object* obj)
   init (obj);
 }
 
 void ObjectProxy::init (Object* obj)
 {
   if (obj != m_object)
     {
       if (m_object)
-	{
-	  disconnect (this, SIGNAL (sendUpdate (int)),
-		      m_object, SLOT (slotUpdate (int)));
-	  disconnect (this, SIGNAL (sendFinalize (void)),
-		      m_object, SLOT (slotFinalize (void)));
-	  disconnect (this, SIGNAL (sendRedraw (void)),
-		      m_object, SLOT (slotRedraw (void)));
-	}
+        {
+          disconnect (this, SIGNAL (sendUpdate (int)),
+                      m_object, SLOT (slotUpdate (int)));
+          disconnect (this, SIGNAL (sendFinalize (void)),
+                      m_object, SLOT (slotFinalize (void)));
+          disconnect (this, SIGNAL (sendRedraw (void)),
+                      m_object, SLOT (slotRedraw (void)));
+        }
 
       m_object = obj;
 
       if (m_object)
-	{
-	  connect (this, SIGNAL (sendUpdate (int)),
-		   m_object, SLOT (slotUpdate (int)));
-	  connect (this, SIGNAL (sendFinalize (void)),
-		   m_object, SLOT (slotFinalize (void)));
-	  connect (this, SIGNAL (sendRedraw (void)),
-		   m_object, SLOT (slotRedraw (void)));
-	}
+        {
+          connect (this, SIGNAL (sendUpdate (int)),
+                   m_object, SLOT (slotUpdate (int)));
+          connect (this, SIGNAL (sendFinalize (void)),
+                   m_object, SLOT (slotFinalize (void)));
+          connect (this, SIGNAL (sendRedraw (void)),
+                   m_object, SLOT (slotRedraw (void)));
+        }
     }
 }
 
 void ObjectProxy::setObject (Object* obj)
 {
   emit sendFinalize ();
   init (obj);
 }
diff --git a/libgui/graphics/Panel.cc b/libgui/graphics/Panel.cc
--- a/libgui/graphics/Panel.cc
+++ b/libgui/graphics/Panel.cc
@@ -53,64 +53,64 @@ static int frameStyleFromProperties (con
     return (QFrame::Panel | QFrame::Raised);
   else
     return (QFrame::Panel | QFrame::Plain);
 }
 
 static void setupPalette (const uipanel::properties& pp, QPalette& p)
 {
   p.setColor (QPalette::Window,
-	      Utils::fromRgb (pp.get_backgroundcolor_rgb ()));
+              Utils::fromRgb (pp.get_backgroundcolor_rgb ()));
   p.setColor (QPalette::WindowText,
-	      Utils::fromRgb (pp.get_foregroundcolor_rgb ()));
+              Utils::fromRgb (pp.get_foregroundcolor_rgb ()));
   p.setColor (QPalette::Light,
-	      Utils::fromRgb (pp.get_highlightcolor_rgb ()));
+              Utils::fromRgb (pp.get_highlightcolor_rgb ()));
   p.setColor (QPalette::Dark,
-	      Utils::fromRgb (pp.get_shadowcolor_rgb ()));
+              Utils::fromRgb (pp.get_shadowcolor_rgb ()));
 }
 
 static int borderWidthFromProperties (const uipanel::properties& pp)
 {
   int bw = 0;
 
   if (! pp.bordertype_is ("none"))
     {
       bw = xround (pp.get_borderwidth ());
       if (pp.bordertype_is ("etchedin") || pp.bordertype_is ("etchedout"))
-	bw *= 2;
+        bw *= 2;
     }
 
   return bw;
 }
 
 Panel* Panel::create (const graphics_object& go)
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	return new Panel (go, new QFrame (container));
+        return new Panel (go, new QFrame (container));
     }
 
   return 0;
 }
 
 Panel::Panel (const graphics_object& go, QFrame* frame)
     : Object (go, frame), m_container (0), m_title (0), m_blockUpdates (false)
 {
   uipanel::properties& pp = properties<uipanel> ();
 
   frame->setObjectName ("UIPanel");
   frame->setAutoFillBackground (true);
   Matrix bb = pp.get_boundingbox (false);
   frame->setGeometry (xround (bb(0)), xround (bb(1)),
-		      xround (bb(2)), xround (bb(3)));
+                      xround (bb(2)), xround (bb(3)));
   frame->setFrameStyle (frameStyleFromProperties (pp));
   frame->setLineWidth (xround (pp.get_borderwidth ()));
   QPalette pal = frame->palette ();
   setupPalette (pp, pal);
   frame->setPalette (pal);
 
   m_container = new Container (frame);
   m_container->canvas (m_handle);
@@ -144,164 +144,164 @@ Panel::~Panel (void)
 {
 }
 
 bool Panel::eventFilter (QObject* watched, QEvent* ev)
 {
   if (! m_blockUpdates)
     {
       if (watched == qObject ())
-	{
-	  switch (ev->type ())
-	    {
-	    case QEvent::Resize:
-		{
-		  gh_manager::auto_lock lock;
-		  graphics_object go = object ();
+        {
+          switch (ev->type ())
+            {
+            case QEvent::Resize:
+                {
+                  gh_manager::auto_lock lock;
+                  graphics_object go = object ();
 
-		  if (go.valid_object ())
-		    {
-		      if (m_title)
-			{
-			  const uipanel::properties& pp =
-			    Utils::properties<uipanel> (go);
+                  if (go.valid_object ())
+                    {
+                      if (m_title)
+                        {
+                          const uipanel::properties& pp =
+                            Utils::properties<uipanel> (go);
 
-			  if (pp.fontunits_is ("normalized"))
-			    {
-			      QFrame* frame = qWidget<QFrame> ();
+                          if (pp.fontunits_is ("normalized"))
+                            {
+                              QFrame* frame = qWidget<QFrame> ();
 
-			      m_title->setFont (Utils::computeFont<uipanel>
-						(pp, frame->height ()));
-			      m_title->resize (m_title->sizeHint ());
-			    }
-			}
-		      updateLayout ();
-		    }
-		}
-	      break;
-	    case QEvent::MouseButtonPress:
-		{
-		  QMouseEvent* m = dynamic_cast<QMouseEvent*> (ev);
+                              m_title->setFont (Utils::computeFont<uipanel>
+                                                (pp, frame->height ()));
+                              m_title->resize (m_title->sizeHint ());
+                            }
+                        }
+                      updateLayout ();
+                    }
+                }
+              break;
+            case QEvent::MouseButtonPress:
+                {
+                  QMouseEvent* m = dynamic_cast<QMouseEvent*> (ev);
 
-		  if (m->button () == Qt::RightButton)
-		    {
-		      gh_manager::auto_lock lock;
+                  if (m->button () == Qt::RightButton)
+                    {
+                      gh_manager::auto_lock lock;
 
-		      ContextMenu::executeAt (properties (), m->globalPos ());
-		    }
-		}
-	      break;
-	    default:
-	      break;
-	    }
-	}
+                      ContextMenu::executeAt (properties (), m->globalPos ());
+                    }
+                }
+              break;
+            default:
+              break;
+            }
+        }
       else if (watched == m_container)
-	{
-	  switch (ev->type ())
-	    {
-	    case QEvent::Resize:
-	      if (qWidget<QWidget> ()->isVisible ())
-		{
-		  gh_manager::auto_lock lock;
+        {
+          switch (ev->type ())
+            {
+            case QEvent::Resize:
+              if (qWidget<QWidget> ()->isVisible ())
+                {
+                  gh_manager::auto_lock lock;
 
-		  properties ().update_boundingbox ();
-		}
-	      break;
-	    default:
-	      break;
-	    }
-	}
+                  properties ().update_boundingbox ();
+                }
+              break;
+            default:
+              break;
+            }
+        }
     }
 
   return false;
 }
 
 void Panel::update (int pId)
 {
   uipanel::properties& pp = properties<uipanel> ();
   QFrame* frame = qWidget<QFrame> ();
 
   m_blockUpdates = true;
 
   switch (pId)
     {
     case uipanel::properties::ID_POSITION:
-	{
-	  Matrix bb = pp.get_boundingbox (false);
+        {
+          Matrix bb = pp.get_boundingbox (false);
 
-	  frame->setGeometry (xround (bb(0)), xround (bb(1)),
-			      xround (bb(2)), xround (bb(3)));
-	  updateLayout ();
-	}
+          frame->setGeometry (xround (bb(0)), xround (bb(1)),
+                              xround (bb(2)), xround (bb(3)));
+          updateLayout ();
+        }
       break;
     case uipanel::properties::ID_BORDERWIDTH:
       frame->setLineWidth (xround (pp.get_borderwidth ()));
       updateLayout ();
       break;
     case uipanel::properties::ID_BACKGROUNDCOLOR:
     case uipanel::properties::ID_FOREGROUNDCOLOR:
     case uipanel::properties::ID_HIGHLIGHTCOLOR:
     case uipanel::properties::ID_SHADOWCOLOR:
-	{
-	  QPalette pal = frame->palette ();
+        {
+          QPalette pal = frame->palette ();
 
-	  setupPalette (pp, pal);
-	  frame->setPalette (pal);
-	  if (m_title)
-	    m_title->setPalette (pal);
-	}
+          setupPalette (pp, pal);
+          frame->setPalette (pal);
+          if (m_title)
+            m_title->setPalette (pal);
+        }
       break;
     case uipanel::properties::ID_TITLE:
-	{
-	  QString title = Utils::fromStdString (pp.get_title ());
+        {
+          QString title = Utils::fromStdString (pp.get_title ());
 
-	  if (title.isEmpty ())
-	    {
-	      if (m_title)
-		delete m_title;
-	      m_title = 0;
-	    }
-	  else
-	    {
-	      if (! m_title)
-		{
-		  QPalette pal = frame->palette ();
+          if (title.isEmpty ())
+            {
+              if (m_title)
+                delete m_title;
+              m_title = 0;
+            }
+          else
+            {
+              if (! m_title)
+                {
+                  QPalette pal = frame->palette ();
 
-		  m_title = new QLabel (title, frame);
-		  m_title->setAutoFillBackground (true);
-		  m_title->setContentsMargins (4, 0, 4, 0);
-		  m_title->setPalette (pal);
-		  m_title->setFont (Utils::computeFont<uipanel> (pp));
-		  m_title->show ();
-		}
-	      else
-		{
-		  m_title->setText (title);
-		  m_title->resize (m_title->sizeHint ());
-		}
-	    }
-	  updateLayout ();
-	}
+                  m_title = new QLabel (title, frame);
+                  m_title->setAutoFillBackground (true);
+                  m_title->setContentsMargins (4, 0, 4, 0);
+                  m_title->setPalette (pal);
+                  m_title->setFont (Utils::computeFont<uipanel> (pp));
+                  m_title->show ();
+                }
+              else
+                {
+                  m_title->setText (title);
+                  m_title->resize (m_title->sizeHint ());
+                }
+            }
+          updateLayout ();
+        }
     case uipanel::properties::ID_TITLEPOSITION:
       updateLayout ();
       break;
     case uipanel::properties::ID_BORDERTYPE:
       frame->setFrameStyle (frameStyleFromProperties (pp));
       updateLayout ();
       break;
     case uipanel::properties::ID_FONTNAME:
     case uipanel::properties::ID_FONTSIZE:
     case uipanel::properties::ID_FONTWEIGHT:
     case uipanel::properties::ID_FONTANGLE:
       if (m_title)
-	{
-	  m_title->setFont (Utils::computeFont<uipanel> (pp));
-	  m_title->resize (m_title->sizeHint ());
-	  updateLayout ();
-	}
+        {
+          m_title->setFont (Utils::computeFont<uipanel> (pp));
+          m_title->resize (m_title->sizeHint ());
+          updateLayout ();
+        }
       break;
     case uipanel::properties::ID_VISIBLE:
       frame->setVisible (pp.is_visible ());
       updateLayout ();
       break;
     default:
       break;
     }
@@ -321,38 +321,38 @@ void Panel::updateLayout (void)
 {
   uipanel::properties& pp = properties<uipanel> ();
   QFrame* frame = qWidget<QFrame> ();
 
   Matrix bb = pp.get_boundingbox (true);
   int bw = borderWidthFromProperties (pp);
 
   frame->setFrameRect (QRect (xround (bb(0)) - bw, xround (bb(1)) - bw,
-			      xround (bb(2)) + 2*bw, xround (bb(3)) + 2*bw));
+                              xround (bb(2)) + 2*bw, xround (bb(3)) + 2*bw));
   m_container->setGeometry (xround (bb(0)), xround (bb(1)),
-			    xround (bb(2)), xround (bb(3)));
+                            xround (bb(2)), xround (bb(3)));
 
   if (m_blockUpdates)
     pp.update_boundingbox ();
 
   if (m_title)
     {
       QSize sz = m_title->sizeHint ();
       int offset = 5;
 
       if (pp.titleposition_is ("lefttop"))
-	m_title->move (bw+offset, 0);
+        m_title->move (bw+offset, 0);
       else if (pp.titleposition_is ("righttop"))
-	m_title->move (frame->width () - bw - offset - sz.width (), 0);
+        m_title->move (frame->width () - bw - offset - sz.width (), 0);
       else if (pp.titleposition_is ("leftbottom"))
-	m_title->move (bw+offset, frame->height () - sz.height ());
+        m_title->move (bw+offset, frame->height () - sz.height ());
       else if (pp.titleposition_is ("rightbottom"))
-	m_title->move (frame->width () - bw - offset - sz.width (),
-		       frame->height () - sz.height ());
+        m_title->move (frame->width () - bw - offset - sz.width (),
+                       frame->height () - sz.height ());
       else if (pp.titleposition_is ("centertop"))
-	m_title->move (frame->width () / 2 - sz.width () / 2, 0);
+        m_title->move (frame->width () / 2 - sz.width () / 2, 0);
       else if (pp.titleposition_is ("centerbottom"))
-	m_title->move (frame->width () / 2 - sz.width () / 2,
-		       frame->height () - sz.height ());
+        m_title->move (frame->width () / 2 - sz.width () / 2,
+                       frame->height () - sz.height ());
     }
 }
 
 };
diff --git a/libgui/graphics/PopupMenuControl.cc b/libgui/graphics/PopupMenuControl.cc
--- a/libgui/graphics/PopupMenuControl.cc
+++ b/libgui/graphics/PopupMenuControl.cc
@@ -37,94 +37,94 @@ PopupMenuControl* PopupMenuControl::crea
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	return new PopupMenuControl (go, new QComboBox (container));
+        return new PopupMenuControl (go, new QComboBox (container));
     }
 
   return 0;
 }
 
 PopupMenuControl::PopupMenuControl (const graphics_object& go, QComboBox *box)
      : BaseControl (go, box), m_blockUpdate (false)
 {
   uicontrol::properties& up = properties<uicontrol> ();
 
   box->addItems (Utils::fromStdString (up.get_string_string ()).split ('|'));
 
   connect (box, SIGNAL (currentIndexChanged (int)),
-	   SLOT (currentIndexChanged (int)));
+           SLOT (currentIndexChanged (int)));
 }
 
 PopupMenuControl::~PopupMenuControl (void)
 {
 }
 
 void PopupMenuControl::update (int pId)
 {
   uicontrol::properties& up = properties<uicontrol> ();
   QComboBox* box = qWidget<QComboBox> ();
 
   switch (pId)
     {
     case uicontrol::properties::ID_STRING:
       m_blockUpdate = true;
-	{
-	  int oldCurrent = box->currentIndex ();
+        {
+          int oldCurrent = box->currentIndex ();
 
-	  box->clear ();
-	  box->addItems (Utils::fromStdString
-			 (up.get_string_string ()).split ('|'));
-	  if (box->count() > 0
-	      && oldCurrent >= 0
-	      && oldCurrent < box->count ())
-	    {
-	      box->setCurrentIndex (oldCurrent);
-	    }
-	  else
-	    {
-	      gh_manager::post_set (m_handle, "value",
-				    octave_value (box->count () > 0
-						  ? 1.0 : 0.0),
-				    false);
-	    }
-	}
+          box->clear ();
+          box->addItems (Utils::fromStdString
+                         (up.get_string_string ()).split ('|'));
+          if (box->count() > 0
+              && oldCurrent >= 0
+              && oldCurrent < box->count ())
+            {
+              box->setCurrentIndex (oldCurrent);
+            }
+          else
+            {
+              gh_manager::post_set (m_handle, "value",
+                                    octave_value (box->count () > 0
+                                                  ? 1.0 : 0.0),
+                                    false);
+            }
+        }
       m_blockUpdate = false;
       break;
     case uicontrol::properties::ID_VALUE:
-	{
-	  Matrix value = up.get_value ().matrix_value ();
+        {
+          Matrix value = up.get_value ().matrix_value ();
 
-	  if (value.numel () > 0)
-	    {
-	      int newIndex = int (value(0)) - 1;
+          if (value.numel () > 0)
+            {
+              int newIndex = int (value(0)) - 1;
 
-	      if (newIndex >= 0 && newIndex < box->count ()
-		  && newIndex != box->currentIndex ())
-		{
-		  box->setCurrentIndex (newIndex);
-		}
-	    }
-	}
+              if (newIndex >= 0 && newIndex < box->count ()
+                  && newIndex != box->currentIndex ())
+                {
+                  box->setCurrentIndex (newIndex);
+                }
+            }
+        }
       break;
     default:
       BaseControl::update (pId);
       break;
     }
 }
 
 void PopupMenuControl::currentIndexChanged (int index)
 {
   if (! m_blockUpdate)
     {
       gh_manager::post_set (m_handle, "value",
-			    octave_value (double (index + 1)),
-			    false);
+                            octave_value (double (index + 1)),
+                            false);
       gh_manager::post_callback (m_handle, "callback");
     }
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/PushButtonControl.cc b/libgui/graphics/PushButtonControl.cc
--- a/libgui/graphics/PushButtonControl.cc
+++ b/libgui/graphics/PushButtonControl.cc
@@ -38,17 +38,17 @@ PushButtonControl* PushButtonControl::cr
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	return new PushButtonControl (go, new QPushButton (container));
+        return new PushButtonControl (go, new QPushButton (container));
     }
 
   return 0;
 }
 
 PushButtonControl::PushButtonControl (const graphics_object& go, QPushButton* btn)
   : ButtonControl (go, btn)
 {
diff --git a/libgui/graphics/PushTool.cc b/libgui/graphics/PushTool.cc
--- a/libgui/graphics/PushTool.cc
+++ b/libgui/graphics/PushTool.cc
@@ -35,17 +35,17 @@ PushTool* PushTool::create (const graphi
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       QWidget* parentWidget = parent->qWidget<QWidget> ();
 
       if (parentWidget)
-	return new PushTool (go, new QAction (parentWidget));
+        return new PushTool (go, new QAction (parentWidget));
     }
 
   return 0;
 }
 
 PushTool::PushTool (const graphics_object& go, QAction* action)
     : ToolBarButton<uipushtool> (go, action)
 {
diff --git a/libgui/graphics/QtHandlesUtils.cc b/libgui/graphics/QtHandlesUtils.cc
--- a/libgui/graphics/QtHandlesUtils.cc
+++ b/libgui/graphics/QtHandlesUtils.cc
@@ -103,19 +103,19 @@ QFont computeFont (const typename T::pro
   f.setPointSizeF (props.get_fontsize_points (height));
   f.setWeight (weightMap[props.get_fontweight ()]);
   f.setStyle (angleMap[props.get_fontangle ()]);
 
   return f;
 }
 
 template QFont computeFont<uicontrol> (const uicontrol::properties& props,
-				       int height);
+                                       int height);
 template QFont computeFont<uipanel> (const uipanel::properties& props,
-				     int height);
+                                     int height);
 
 QColor fromRgb (const Matrix& rgb)
 {
   QColor c;
 
   if (rgb.numel () == 3)
     c.setRgbF (rgb(0), rgb(1), rgb(2));
 
@@ -137,64 +137,64 @@ std::string figureSelectionType (QMouseE
   if (isDoubleClick)
     return std::string ("open");
   else
     {
       Qt::MouseButtons buttons = event->buttons ();
       Qt::KeyboardModifiers mods = event->modifiers ();
 
       if (mods == Qt::NoModifier)
-	{
-	  if (buttons == Qt::LeftButton)
-	    return std::string ("normal");
-	  else if (buttons == Qt::RightButton)
-	    return std::string ("alt");
+        {
+          if (buttons == Qt::LeftButton)
+            return std::string ("normal");
+          else if (buttons == Qt::RightButton)
+            return std::string ("alt");
 #if defined (Q_WS_WIN)
-	  else if (buttons == (Qt::LeftButton|Qt::RightButton))
-	    return std::string ("extend");
+          else if (buttons == (Qt::LeftButton|Qt::RightButton))
+            return std::string ("extend");
 #elif defined (Q_WS_X11)
-	  else if (buttons == Qt::MidButton)
-	    return std::string ("extend");
+          else if (buttons == Qt::MidButton)
+            return std::string ("extend");
 #endif
-	}
+        }
       else if (buttons == Qt::LeftButton)
-	{
-	  if (mods == Qt::ShiftModifier)
-	    return std::string ("extend");
-	  else if (mods == Qt::ControlModifier)
-	    return std::string ("alt");
-	}
+        {
+          if (mods == Qt::ShiftModifier)
+            return std::string ("extend");
+          else if (mods == Qt::ControlModifier)
+            return std::string ("alt");
+        }
     }
 
   return std::string ("normal");
 }
 
 Matrix figureCurrentPoint (const graphics_object& fig, QMouseEvent* event)
 {
   Object* tkFig = Backend::toolkitObject (fig);
 
   if (tkFig)
     {
       Container* c = tkFig->innerContainer ();
 
       if (c)
-	{
-	  QPoint qp = c->mapFromGlobal (event->globalPos ());
+        {
+          QPoint qp = c->mapFromGlobal (event->globalPos ());
 
-	  return
-	    tkFig->properties<figure> ().map_from_boundingbox (qp.x (),
-							       qp.y ());
-	}
+          return
+            tkFig->properties<figure> ().map_from_boundingbox (qp.x (),
+                                                               qp.y ());
+        }
     }
 
   return Matrix (1, 2, 0.0);
 }
 
 Qt::Alignment fromHVAlign (const caseless_str& halign,
-			   const caseless_str& valign)
+                           const caseless_str& valign)
 {
   Qt::Alignment flags;
 
   if (halign.compare ("left"))
     flags |= Qt::AlignLeft;
   else if (halign.compare ("center"))
     flags |= Qt::AlignHCenter;
   else if (halign.compare ("right"))
@@ -225,68 +225,68 @@ QImage makeImageFromCData (const octave_
 
       int x_off = (w < width ? (width - w) / 2 : 0);
       int y_off = (h < height ? (height - h) / 2 : 0);
 
       QImage img (width, height, QImage::Format_ARGB32);
       img.fill (qRgba (0, 0, 0, 0));
 
       if (v.is_uint8_type ())
-	{
-	  uint8NDArray d = v.uint8_array_value ();
+        {
+          uint8NDArray d = v.uint8_array_value ();
 
-	  for (int i = 0; i < w; i++)
-	    for (int j = 0; j < h; j++)
-	      {
-		int r = d(j, i, 0);
-		int g = d(j, i, 1);
-		int b = d(j, i, 2);
-		int a = 255;
+          for (int i = 0; i < w; i++)
+            for (int j = 0; j < h; j++)
+              {
+                int r = d(j, i, 0);
+                int g = d(j, i, 1);
+                int b = d(j, i, 2);
+                int a = 255;
 
-		img.setPixel (x_off + i, y_off + j, qRgba (r, g, b, a));
-	      }
-	}
+                img.setPixel (x_off + i, y_off + j, qRgba (r, g, b, a));
+              }
+        }
       else if (v.is_single_type ())
-	{
-	  FloatNDArray f = v.float_array_value ();
+        {
+          FloatNDArray f = v.float_array_value ();
 
-	  for (int i = 0; i < w; i++)
-	    for (int j = 0; j < h; j++)
-	      {
-		float r = f(j, i, 0);
-		float g = f(j, i, 1);
-		float b = f(j, i, 2);
-		int a = (xisnan (r) || xisnan (g) || xisnan (b) ? 0 : 255);
+          for (int i = 0; i < w; i++)
+            for (int j = 0; j < h; j++)
+              {
+                float r = f(j, i, 0);
+                float g = f(j, i, 1);
+                float b = f(j, i, 2);
+                int a = (xisnan (r) || xisnan (g) || xisnan (b) ? 0 : 255);
 
-		img.setPixel (x_off + i, y_off + j,
-			      qRgba (xround (r * 255),
-				     xround (g * 255),
-				     xround (b * 255),
-				     a));
-	      }
-	}
+                img.setPixel (x_off + i, y_off + j,
+                              qRgba (xround (r * 255),
+                                     xround (g * 255),
+                                     xround (b * 255),
+                                     a));
+              }
+        }
       else if (v.is_real_type ())
-	{
-	  NDArray d = v.array_value ();
+        {
+          NDArray d = v.array_value ();
 
-	  for (int i = 0; i < w; i++)
-	    for (int j = 0; j < h; j++)
-	      {
-		double r = d(j, i, 0);
-		double g = d(j, i, 1);
-		double b = d(j, i, 2);
-		int a = (xisnan (r) || xisnan (g) || xisnan (b) ? 0 : 255);
+          for (int i = 0; i < w; i++)
+            for (int j = 0; j < h; j++)
+              {
+                double r = d(j, i, 0);
+                double g = d(j, i, 1);
+                double b = d(j, i, 2);
+                int a = (xisnan (r) || xisnan (g) || xisnan (b) ? 0 : 255);
 
-		img.setPixel (x_off + i, y_off + j,
-			      qRgba (xround (r * 255),
-				     xround (g * 255),
-				     xround (b * 255),
-				     a));
-	      }
-	}
+                img.setPixel (x_off + i, y_off + j,
+                              qRgba (xround (r * 255),
+                                     xround (g * 255),
+                                     xround (b * 255),
+                                     a));
+              }
+        }
 
       return img;
     }
 
   return QImage ();
 }
 
 octave_scalar_map makeKeyEventStruct (QKeyEvent* event)
diff --git a/libgui/graphics/QtHandlesUtils.h b/libgui/graphics/QtHandlesUtils.h
--- a/libgui/graphics/QtHandlesUtils.h
+++ b/libgui/graphics/QtHandlesUtils.h
@@ -49,34 +49,34 @@ namespace Utils
 
   template <class T>
   QFont computeFont (const typename T::properties& props, int height = -1);
 
   QColor fromRgb (const Matrix& rgb);
   Matrix toRgb (const QColor& c);
 
   Qt::Alignment fromHVAlign (const caseless_str& halign,
-			     const caseless_str& valign);
+                             const caseless_str& valign);
 
   std::string figureSelectionType (QMouseEvent* event,
-				   bool isDoubleClick = false);
+                                   bool isDoubleClick = false);
 
   Matrix figureCurrentPoint (const graphics_object& fig, QMouseEvent* event);
 
   template <class T>
   inline typename T::properties&
   properties (graphics_object obj)
     { return dynamic_cast<typename T::properties&> (obj.get_properties ()); }
 
   template <class T>
   inline typename T::properties&
   properties (const graphics_handle& h)
     { return Utils::properties<T> (gh_manager::get_object (h)); }
 
   QImage makeImageFromCData (const octave_value& v, int width = -1,
-			     int height = -1);
+                             int height = -1);
 
   octave_scalar_map makeKeyEventStruct (QKeyEvent* event);
 };
 
 }; // namespace QtHandles
 
 #endif
diff --git a/libgui/graphics/RadioButtonControl.cc b/libgui/graphics/RadioButtonControl.cc
--- a/libgui/graphics/RadioButtonControl.cc
+++ b/libgui/graphics/RadioButtonControl.cc
@@ -37,24 +37,24 @@ RadioButtonControl* RadioButtonControl::
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	return new RadioButtonControl (go, new QRadioButton (container));
+        return new RadioButtonControl (go, new QRadioButton (container));
     }
 
   return 0;
 }
 
 RadioButtonControl::RadioButtonControl (const graphics_object& go,
-					QRadioButton* radio)
+                                        QRadioButton* radio)
     : ButtonControl (go, radio)
 {
   radio->setAutoFillBackground (true);
   radio->setAutoExclusive (false);
 }
 
 RadioButtonControl::~RadioButtonControl (void)
 {
diff --git a/libgui/graphics/SliderControl.cc b/libgui/graphics/SliderControl.cc
--- a/libgui/graphics/SliderControl.cc
+++ b/libgui/graphics/SliderControl.cc
@@ -39,24 +39,24 @@ SliderControl* SliderControl::create (co
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	return new SliderControl (go, new QScrollBar (container));
+        return new SliderControl (go, new QScrollBar (container));
     }
 
   return 0;
 }
 
 SliderControl::SliderControl (const graphics_object& go,
-			      QAbstractSlider* slider)
+                              QAbstractSlider* slider)
     : BaseControl (go, slider), m_blockUpdates (false)
 {
   uicontrol::properties& up = properties<uicontrol> ();
 
   slider->setTracking (false);
   Matrix bb = up.get_boundingbox ();
   slider->setOrientation (bb(2) > bb(3) ? Qt::Horizontal : Qt::Vertical);
   Matrix steps = up.get_sliderstep ().matrix_value ();
@@ -65,17 +65,17 @@ SliderControl::SliderControl (const grap
   slider->setSingleStep (xround (steps(0) * RANGE_INT_MAX));
   slider->setPageStep (xround (steps(1) * RANGE_INT_MAX));
   Matrix value = up.get_value ().matrix_value ();
   if (value.numel () > 0)
     {
       double dmin = up.get_min (), dmax = up.get_max ();
 
       slider->setValue (xround (((value(0) - dmin) / (dmax - dmin))
-				* RANGE_INT_MAX));
+                                * RANGE_INT_MAX));
     }
 
   connect (slider, SIGNAL (valueChanged (int)), SLOT (valueChanged (int)));
 }
 
 SliderControl::~SliderControl (void)
 {
 }
@@ -83,68 +83,68 @@ SliderControl::~SliderControl (void)
 void SliderControl::update (int pId)
 {
   uicontrol::properties& up = properties<uicontrol> ();
   QScrollBar* slider = qWidget<QScrollBar> ();
 
   switch (pId)
     {
     case uicontrol::properties::ID_SLIDERSTEP:
-	{
-	  Matrix steps = up.get_sliderstep ().matrix_value ();
+        {
+          Matrix steps = up.get_sliderstep ().matrix_value ();
 
-	  slider->setSingleStep (xround (steps(0) * RANGE_INT_MAX));
-	  slider->setPageStep (xround (steps(1) * RANGE_INT_MAX));
-	}
+          slider->setSingleStep (xround (steps(0) * RANGE_INT_MAX));
+          slider->setPageStep (xround (steps(1) * RANGE_INT_MAX));
+        }
       break;
     case uicontrol::properties::ID_VALUE:
-	{
-	  Matrix value = up.get_value ().matrix_value ();
-	  double dmax = up.get_max (), dmin = up.get_min ();
+        {
+          Matrix value = up.get_value ().matrix_value ();
+          double dmax = up.get_max (), dmin = up.get_min ();
 
-	  if (value.numel () > 0)
-	    {
-	      int ival = xround (((value(0) - dmin) / (dmax - dmin))
-				 * RANGE_INT_MAX);
+          if (value.numel () > 0)
+            {
+              int ival = xround (((value(0) - dmin) / (dmax - dmin))
+                                 * RANGE_INT_MAX);
 
-	      m_blockUpdates = true;
-	      slider->setValue (ival);
-	      m_blockUpdates = false;
-	    }
-	}
+              m_blockUpdates = true;
+              slider->setValue (ival);
+              m_blockUpdates = false;
+            }
+        }
       break;
     default:
       BaseControl::update (pId);
       break;
     }
 }
 
 void SliderControl::valueChanged (int ival)
 {
   if (! m_blockUpdates)
     {
       gh_manager::auto_lock lock;
       graphics_object go = object ();
 
       if (go.valid_object ())
-	{
-	  uicontrol::properties& up = Utils::properties<uicontrol> (go);
+        {
+          uicontrol::properties& up = Utils::properties<uicontrol> (go);
 
-	  Matrix value = up.get_value ().matrix_value ();
-	  double dmin = up.get_min (), dmax = up.get_max ();
+          Matrix value = up.get_value ().matrix_value ();
+          double dmin = up.get_min (), dmax = up.get_max ();
 
-	  int ival_tmp = (value.numel () > 0 ?
-			  xround (((value(0) - dmin) / (dmax - dmin))
-				  * RANGE_INT_MAX) :
-			  0);
+          int ival_tmp = (value.numel () > 0 ?
+                          xround (((value(0) - dmin) / (dmax - dmin))
+                                  * RANGE_INT_MAX) :
+                          0);
 
-	  if (ival != ival_tmp || value.numel () > 0)
-	    {
-	      double dval = dmin + (ival * (dmax - dmin) / RANGE_INT_MAX);
+          if (ival != ival_tmp || value.numel () > 0)
+            {
+              double dval = dmin + (ival * (dmax - dmin) / RANGE_INT_MAX);
 
-	      gh_manager::post_set (m_handle, "value", octave_value (dval));
-	      gh_manager::post_callback (m_handle, "callback");
-	    }
-	}
+              gh_manager::post_set (m_handle, "value", octave_value (dval));
+              gh_manager::post_callback (m_handle, "callback");
+            }
+        }
     }
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/TextControl.cc b/libgui/graphics/TextControl.cc
--- a/libgui/graphics/TextControl.cc
+++ b/libgui/graphics/TextControl.cc
@@ -37,32 +37,32 @@ TextControl* TextControl::create (const 
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	return new TextControl (go, new QLabel (container));
+        return new TextControl (go, new QLabel (container));
     }
 
   return 0;
 }
 
 TextControl::TextControl (const graphics_object& go, QLabel* label)
      : BaseControl (go, label)
 {
   uicontrol::properties& up = properties<uicontrol> ();
 
   label->setAutoFillBackground (true);
   label->setTextFormat (Qt::PlainText);
   label->setWordWrap (false);
   label->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
-					   up.get_verticalalignment ()));
+                                           up.get_verticalalignment ()));
   // FIXME: support string_vector
   label->setText (Utils::fromStdString (up.get_string_string ()));
 }
 
 TextControl::~TextControl (void)
 {
 }
 
@@ -75,17 +75,17 @@ void TextControl::update (int pId)
     {
     case uicontrol::properties::ID_STRING:
       // FIXME: support string_vector
       label->setText (Utils::fromStdString (up.get_string_string ()));
       break;
     case uicontrol::properties::ID_HORIZONTALALIGNMENT:
     case uicontrol::properties::ID_VERTICALALIGNMENT:
       label->setAlignment (Utils::fromHVAlign (up.get_horizontalalignment (),
-					       up.get_verticalalignment ()));
+                                               up.get_verticalalignment ()));
       break;
     default:
       BaseControl::update (pId);
       break;
     }
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/ToggleButtonControl.cc b/libgui/graphics/ToggleButtonControl.cc
--- a/libgui/graphics/ToggleButtonControl.cc
+++ b/libgui/graphics/ToggleButtonControl.cc
@@ -37,24 +37,24 @@ ToggleButtonControl* ToggleButtonControl
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       Container* container = parent->innerContainer ();
 
       if (container)
-	return new ToggleButtonControl (go, new QPushButton (container));
+        return new ToggleButtonControl (go, new QPushButton (container));
     }
 
   return 0;
 }
 
 ToggleButtonControl::ToggleButtonControl (const graphics_object& go,
-					  QPushButton* btn)
+                                          QPushButton* btn)
     : ButtonControl (go, btn)
 {
   btn->setCheckable (true);
   btn->setAutoFillBackground (true);
 }
 
 ToggleButtonControl::~ToggleButtonControl (void)
 {
diff --git a/libgui/graphics/ToggleTool.cc b/libgui/graphics/ToggleTool.cc
--- a/libgui/graphics/ToggleTool.cc
+++ b/libgui/graphics/ToggleTool.cc
@@ -35,32 +35,32 @@ ToggleTool* ToggleTool::create (const gr
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       QWidget* parentWidget = parent->qWidget<QWidget> ();
 
       if (parentWidget)
-	return new ToggleTool (go, new QAction (parentWidget));
+        return new ToggleTool (go, new QAction (parentWidget));
     }
 
   return 0;
 }
 
 ToggleTool::ToggleTool (const graphics_object& go, QAction* action)
     : ToolBarButton<uitoggletool> (go, action)
 {
   uitoggletool::properties& tp = properties<uitoggletool> ();
 
   action->setCheckable (true);
   action->setChecked (tp.is_state ());
 
   connect (action, SIGNAL (toggled (bool)),
-	   this, SLOT (triggered (bool)));
+           this, SLOT (triggered (bool)));
 }
 
 ToggleTool::~ToggleTool (void)
 {
 }
 
 void ToggleTool::update (int pId)
 {
@@ -77,15 +77,15 @@ void ToggleTool::update (int pId)
       break;
     }
 }
 
 void ToggleTool::triggered (bool checked)
 {
   gh_manager::post_set (m_handle, "state", checked, false);
   gh_manager::post_callback (m_handle,
-			     checked
-			     ? "oncallback"
-			     : "offcallback");
+                             checked
+                             ? "oncallback"
+                             : "offcallback");
   gh_manager::post_callback (m_handle, "clickedcallback");
 }
 
 };
diff --git a/libgui/graphics/ToolBar.cc b/libgui/graphics/ToolBar.cc
--- a/libgui/graphics/ToolBar.cc
+++ b/libgui/graphics/ToolBar.cc
@@ -66,17 +66,17 @@ ToolBar* ToolBar::create (const graphics
 {
   Object* parent = Object::parentObject (go);
 
   if (parent)
     {
       QWidget* parentWidget = parent->qWidget<QWidget> ();
 
       if (parentWidget)
-	return new ToolBar (go, new QToolBar (parentWidget));
+        return new ToolBar (go, new QToolBar (parentWidget));
     }
 
   return 0;
 }
 
 ToolBar::ToolBar (const graphics_object& go, QToolBar* bar)
      : Object (go, bar), m_empty (0), m_figure (0)
 {
@@ -105,54 +105,54 @@ void ToolBar::update (int pId)
 {
   uitoolbar::properties& tp = properties<uitoolbar> ();
   QToolBar* bar = qWidget<QToolBar> ();
 
   switch (pId)
     {
     case base_properties::ID_VISIBLE:
       if (m_figure)
-	m_figure->showCustomToolBar (bar, tp.is_visible ());
+        m_figure->showCustomToolBar (bar, tp.is_visible ());
       break;
     default:
       Object::update (pId);
       break;
     }
 }
 
 bool ToolBar::eventFilter (QObject* watched, QEvent* ev)
 {
   if (watched == qObject ())
     {
       switch (ev->type ())
-	{
-	case QEvent::ActionAdded:
-	case QEvent::ActionRemoved:
-	    {
-	      QActionEvent* ae = dynamic_cast<QActionEvent*> (ev);
-	      QToolBar* bar = qWidget<QToolBar> ();
+        {
+        case QEvent::ActionAdded:
+        case QEvent::ActionRemoved:
+            {
+              QActionEvent* ae = dynamic_cast<QActionEvent*> (ev);
+              QToolBar* bar = qWidget<QToolBar> ();
 
-	      if (ae->action () != m_empty)
-		{
-		  if (ev->type () == QEvent::ActionAdded)
-		    {
-		      if (bar->actions ().size () == 2)
-			QTimer::singleShot (0, this, SLOT (hideEmpty (void)));
-		    }
-		  else
-		    {
-		      if (bar->actions ().size () == 1)
-			m_empty->setVisible (true);
-		    }
-		}
-	    }
-	  break;
-	default:
-	  break;
-	}
+              if (ae->action () != m_empty)
+                {
+                  if (ev->type () == QEvent::ActionAdded)
+                    {
+                      if (bar->actions ().size () == 2)
+                        QTimer::singleShot (0, this, SLOT (hideEmpty (void)));
+                    }
+                  else
+                    {
+                      if (bar->actions ().size () == 1)
+                        m_empty->setVisible (true);
+                    }
+                }
+            }
+          break;
+        default:
+          break;
+        }
     }
 
   return false;
 }
 
 void ToolBar::hideEmpty (void)
 {
   m_empty->setVisible (false);
@@ -160,13 +160,13 @@ void ToolBar::hideEmpty (void)
 
 void ToolBar::beingDeleted (void)
 {
   if (m_figure)
     {
       QToolBar* bar = qWidget<QToolBar> ();
 
       if (bar)
-	m_figure->showCustomToolBar (bar, false);
+        m_figure->showCustomToolBar (bar, false);
     }
 }
 
 }; // namespace QtHandles
diff --git a/libgui/graphics/ToolBarButton.cc b/libgui/graphics/ToolBarButton.cc
--- a/libgui/graphics/ToolBarButton.cc
+++ b/libgui/graphics/ToolBarButton.cc
@@ -69,48 +69,48 @@ void ToolBarButton<T>::update (int pId)
   typename T::properties& tp = properties<T> ();
   QAction* action = qWidget<QAction> ();
 
   switch (pId)
     {
     case base_properties::ID_VISIBLE:
       action->setVisible (tp.is_visible ());
       if (m_separator)
-	m_separator->setVisible (tp.is_visible ());
+        m_separator->setVisible (tp.is_visible ());
       break;
     case T::properties::ID_TOOLTIPSTRING:
       action->setToolTip (Utils::fromStdString (tp.get_tooltipstring ()));
       break;
     case T::properties::ID_CDATA:
-	{
-	  QImage img = Utils::makeImageFromCData (tp.get_cdata (), 16, 16);
+        {
+          QImage img = Utils::makeImageFromCData (tp.get_cdata (), 16, 16);
 
-	  action->setIcon (QIcon (QPixmap::fromImage (img)));
-	}
+          action->setIcon (QIcon (QPixmap::fromImage (img)));
+        }
       break;
     case T::properties::ID_SEPARATOR:
       if (tp.is_separator ())
-	{
-	  if (! m_separator)
-	    {
-	      m_separator = new QAction (action);
-	      m_separator->setSeparator (true);
-	      m_separator->setVisible (tp.is_visible ());
+        {
+          if (! m_separator)
+            {
+              m_separator = new QAction (action);
+              m_separator->setSeparator (true);
+              m_separator->setVisible (tp.is_visible ());
 
-	      QWidget* w = qobject_cast<QWidget*> (action->parent ());
+              QWidget* w = qobject_cast<QWidget*> (action->parent ());
 
-	      w->insertAction (action, m_separator);
-	    }
-	}
+              w->insertAction (action, m_separator);
+            }
+        }
       else
-	{
-	  if (m_separator)
-	    delete m_separator;
-	  m_separator = 0;
-	}
+        {
+          if (m_separator)
+            delete m_separator;
+          m_separator = 0;
+        }
       break;
     case T::properties::ID_ENABLE:
       action->setEnabled (tp.is_enable ());
       break;
     default:
       Object::update (pId);
       break;
     }
diff --git a/libgui/graphics/__init_qt__.cc b/libgui/graphics/__init_qt__.cc
--- a/libgui/graphics/__init_qt__.cc
+++ b/libgui/graphics/__init_qt__.cc
@@ -43,55 +43,55 @@ namespace QtHandles
 
 static bool qtHandlesInitialized = false;
 
 bool __init__ (void)
 {
   if (! qtHandlesInitialized)
     {
       if (qApp)
-	{
-	  qRegisterMetaType<graphics_object> ("graphics_object");
+        {
+          qRegisterMetaType<graphics_object> ("graphics_object");
 
-	  gh_manager::enable_event_processing (true);
+          gh_manager::enable_event_processing (true);
 
-	  graphics_toolkit tk (new Backend ());
+          graphics_toolkit tk (new Backend ());
           gtk_manager::load_toolkit (tk);
 
-	  octave_add_atexit_function ("__shutdown_qt__");
+          octave_add_atexit_function ("__shutdown_qt__");
 
-	  // Change some default settings to use Qt default colors
-	  QPalette p;
-	  graphics_object root = gh_manager::get_object (0);
+          // Change some default settings to use Qt default colors
+          QPalette p;
+          graphics_object root = gh_manager::get_object (0);
 
-	  /*
-	  root.set ("defaultfigurecolor",
-		    octave_value (Utils::toRgb (p.color (QPalette::Window))));
-	  */
-	  root.set ("defaultuicontrolbackgroundcolor",
-		    octave_value (Utils::toRgb (p.color (QPalette::Window))));
-	  root.set ("defaultuicontrolforegroundcolor",
-		    octave_value (Utils::toRgb
-				  (p.color (QPalette::WindowText))));
-	  root.set ("defaultuipanelbackgroundcolor",
-		    octave_value (Utils::toRgb (p.color (QPalette::Window))));
-	  root.set ("defaultuipanelforegroundcolor",
-		    octave_value (Utils::toRgb
-				  (p.color (QPalette::WindowText))));
-	  root.set ("defaultuipanelhighlightcolor",
-		    octave_value (Utils::toRgb (p.color (QPalette::Light))));
-	  root.set ("defaultuipanelshadowcolor",
-		    octave_value (Utils::toRgb (p.color (QPalette::Dark))));
+          /*
+          root.set ("defaultfigurecolor",
+                    octave_value (Utils::toRgb (p.color (QPalette::Window))));
+          */
+          root.set ("defaultuicontrolbackgroundcolor",
+                    octave_value (Utils::toRgb (p.color (QPalette::Window))));
+          root.set ("defaultuicontrolforegroundcolor",
+                    octave_value (Utils::toRgb
+                                  (p.color (QPalette::WindowText))));
+          root.set ("defaultuipanelbackgroundcolor",
+                    octave_value (Utils::toRgb (p.color (QPalette::Window))));
+          root.set ("defaultuipanelforegroundcolor",
+                    octave_value (Utils::toRgb
+                                  (p.color (QPalette::WindowText))));
+          root.set ("defaultuipanelhighlightcolor",
+                    octave_value (Utils::toRgb (p.color (QPalette::Light))));
+          root.set ("defaultuipanelshadowcolor",
+                    octave_value (Utils::toRgb (p.color (QPalette::Dark))));
 
-	  qtHandlesInitialized = true;
+          qtHandlesInitialized = true;
 
-	  return true;
-	}
+          return true;
+        }
       else
-	error ("__init_qt__: QApplication object must exist.");
+        error ("__init_qt__: QApplication object must exist.");
     }
 
   return false;
 }
 
 bool __shutdown__ (void)
 {
   if (qtHandlesInitialized)
@@ -208,55 +208,55 @@ DEFUN (__uigetfile_qt__, args, , "")
 
   QStringList filterSpecs = makeFilterSpecs (args(0).cell_value ());
 
   if (isMultiSelect)
     {
       QString filter;
       QStringList files =
         QFileDialog::getOpenFileNames (0, caption, defaultFileName,
-				       filterSpecs.join (";;"), &filter, 0);
+                                       filterSpecs.join (";;"), &filter, 0);
 
       if (! files.isEmpty ())
-	{
-	  Cell cFiles (1, files.length ());
-	  QString dirName;
-	  int i = 0;
+        {
+          Cell cFiles (1, files.length ());
+          QString dirName;
+          int i = 0;
 
-	  foreach (const QString& s, files)
-	    {
-	      QFileInfo fi (s);
+          foreach (const QString& s, files)
+            {
+              QFileInfo fi (s);
 
-	      if (dirName.isEmpty ())
-		dirName = appendDirSep (fi.canonicalPath ());
-	      cFiles(i++) = toStdString (fi.fileName ());
-	    }
+              if (dirName.isEmpty ())
+                dirName = appendDirSep (fi.canonicalPath ());
+              cFiles(i++) = toStdString (fi.fileName ());
+            }
 
-	  retval(0) = cFiles;
-	  retval(1) = toStdString (dirName);
-	  if (! filter.isEmpty ())
-	    retval(2) = static_cast<double> (filterSpecs.indexOf (filter) + 1);
-	}
+          retval(0) = cFiles;
+          retval(1) = toStdString (dirName);
+          if (! filter.isEmpty ())
+            retval(2) = static_cast<double> (filterSpecs.indexOf (filter) + 1);
+        }
     }
   else
     {
       QString filter;
       QString fileName =
         QFileDialog::getOpenFileName (0, caption, defaultFileName,
-				      filterSpecs.join (";;"), &filter, 0);
+                                      filterSpecs.join (";;"), &filter, 0);
 
       if (! fileName.isNull ())
-	{
-	  QFileInfo fi (fileName);
+        {
+          QFileInfo fi (fileName);
 
-	  retval(0) = toStdString (fi.fileName ());
-	  retval(1) = toStdString (appendDirSep (fi.canonicalPath ()));
-	  if (! filter.isEmpty ())
-	    retval(2) = static_cast<double> (filterSpecs.indexOf (filter) + 1);
-	}
+          retval(0) = toStdString (fi.fileName ());
+          retval(1) = toStdString (appendDirSep (fi.canonicalPath ()));
+          if (! filter.isEmpty ())
+            retval(2) = static_cast<double> (filterSpecs.indexOf (filter) + 1);
+        }
     }
 
   return retval;
 }
 
 DEFUN (__uiputfile_qt__, args, , "")
 {
   using namespace QtHandles::Utils;
@@ -284,29 +284,29 @@ DEFUN (__uiputfile_qt__, args, , "")
   else
     defaultFileName = defaultDirectory + "/" + defaultFileName;
 
   QStringList filterSpecs = makeFilterSpecs (args(0).cell_value ());
 
   QString filter;
   QString fileName =
     QFileDialog::getSaveFileName (0, caption, defaultFileName,
-				  filterSpecs.join (";;"), &filter, 0);
+                                  filterSpecs.join (";;"), &filter, 0);
 
   if (! fileName.isNull ())
     {
       QFileInfo fi (fileName);
 
       retval(0) = toStdString (fi.fileName ());
       if (fi.exists ())
-	retval(1) = toStdString (appendDirSep (fi.canonicalPath ()));
+        retval(1) = toStdString (appendDirSep (fi.canonicalPath ()));
       else
-	retval(1) = toStdString (appendDirSep (fi.absolutePath ()));
+        retval(1) = toStdString (appendDirSep (fi.absolutePath ()));
       if (! filter.isEmpty ())
-	retval(2) = static_cast<double> (filterSpecs.indexOf (filter) + 1);
+        retval(2) = static_cast<double> (filterSpecs.indexOf (filter) + 1);
     }
 
   return retval;
 }
 
 DEFUN (__uigetdir_qt__, args, , "")
 {
   using namespace QtHandles::Utils;
@@ -316,17 +316,17 @@ DEFUN (__uigetdir_qt__, args, , "")
   //   args(1) : Dialog title
 
   octave_value retval ("");
 
   QString caption = fromStdString (args(1).string_value ());
   QString defaultDirectory = fromStdString (args(0).string_value ());
 
   QString dirName = QFileDialog::getExistingDirectory (0, caption,
-						       defaultDirectory);
+                                                       defaultDirectory);
 
   if (! dirName.isNull ())
     retval = toStdString (dirName);
 
   return retval;
 }
 
 #endif
