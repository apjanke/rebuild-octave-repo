# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1518267505 18000
#      Sat Feb 10 07:58:25 2018 -0500
# Node ID af6c1ed605816818ccae234f16b28cb5293316f7
# Parent  f26c5320e858ae17f15ae3560951607c56a80779
avoid splitting namespace blocks unnecessarily

* fcn-info.cc, ft-text-renderer.cc, gl-render.cc, gl2ps-print.cc,
oct-stream.cc, symtab.cc, pt-cbinop.cc, pt-eval.cc, pt-idx.cc:
Don't split namespace blocks unnecessarily.  Omitting static functions
from namespace blocks was done because of a misunderstanding.

diff --git a/libinterp/corefcn/fcn-info.cc b/libinterp/corefcn/fcn-info.cc
--- a/libinterp/corefcn/fcn-info.cc
+++ b/libinterp/corefcn/fcn-info.cc
@@ -229,49 +229,46 @@ namespace octave
                       }
                   }
               }
           }
       }
 
     return retval;
   }
-}
 
-// :-) JWE, can you parse this? Returns a 2D array with second dimension equal
-// to btyp_num_types (static constant).  Only the leftmost dimension can be
-// variable in C/C++.  Typedefs are boring.
+  // :-) JWE, can you parse this? Returns a 2D array with second dimension equal
+  // to btyp_num_types (static constant).  Only the leftmost dimension can be
+  // variable in C/C++.  Typedefs are boring.
 
-static builtin_type_t (*build_sup_table (void))[btyp_num_types]
-{
-  static builtin_type_t sup_table[btyp_num_types][btyp_num_types];
-  for (int i = 0; i < btyp_num_types; i++)
-    for (int j = 0; j < btyp_num_types; j++)
-      {
-        builtin_type_t ityp = static_cast<builtin_type_t> (i);
-        builtin_type_t jtyp = static_cast<builtin_type_t> (j);
-        // FIXME: Is this really right?
-        bool use_j =
-          (jtyp == btyp_func_handle || ityp == btyp_bool
-           || (btyp_isarray (ityp)
-               && (! btyp_isarray (jtyp)
-                   || (btyp_isinteger (jtyp) && ! btyp_isinteger (ityp))
-                   || ((ityp == btyp_double || ityp == btyp_complex
-                        || ityp == btyp_char)
-                       && (jtyp == btyp_float
-                           || jtyp == btyp_float_complex)))));
+  static builtin_type_t (*build_sup_table (void))[btyp_num_types]
+  {
+    static builtin_type_t sup_table[btyp_num_types][btyp_num_types];
+    for (int i = 0; i < btyp_num_types; i++)
+      for (int j = 0; j < btyp_num_types; j++)
+        {
+          builtin_type_t ityp = static_cast<builtin_type_t> (i);
+          builtin_type_t jtyp = static_cast<builtin_type_t> (j);
+          // FIXME: Is this really right?
+          bool use_j =
+            (jtyp == btyp_func_handle || ityp == btyp_bool
+             || (btyp_isarray (ityp)
+                 && (! btyp_isarray (jtyp)
+                     || (btyp_isinteger (jtyp) && ! btyp_isinteger (ityp))
+                     || ((ityp == btyp_double || ityp == btyp_complex
+                          || ityp == btyp_char)
+                         && (jtyp == btyp_float
+                             || jtyp == btyp_float_complex)))));
 
-        sup_table[i][j] = (use_j ? jtyp : ityp);
-      }
+          sup_table[i][j] = (use_j ? jtyp : ityp);
+        }
 
-  return sup_table;
-}
+    return sup_table;
+  }
 
-namespace octave
-{
   std::string
   get_dispatch_type (const octave_value_list& args,
                      builtin_type_t& builtin_type)
   {
     static builtin_type_t (*sup_table)[btyp_num_types] = build_sup_table ();
     std::string dispatch_type;
 
     int n = args.length ();
diff --git a/libinterp/corefcn/ft-text-renderer.cc b/libinterp/corefcn/ft-text-renderer.cc
--- a/libinterp/corefcn/ft-text-renderer.cc
+++ b/libinterp/corefcn/ft-text-renderer.cc
@@ -56,48 +56,48 @@ along with Octave; see the file COPYING.
 
 #include "defaults.h"
 #include "error.h"
 #include "file-ops.h"
 #include "oct-env.h"
 #include "pr-output.h"
 #include "text-renderer.h"
 
-// FIXME: maybe issue at most one warning per glyph/font/size/weight
-//        combination.
-
-static void
-warn_missing_glyph (FT_ULong c)
+namespace octave
 {
-  warning_with_id ("Octave:missing-glyph",
-                   "text_renderer: skipping missing glyph for character '%x'", c);
-}
+  // FIXME: maybe issue at most one warning per glyph/font/size/weight
+  //        combination.
 
-static void
-warn_glyph_render (FT_ULong c)
-{
-  warning_with_id ("Octave:glyph-render",
-                   "text_renderer: unable to render glyph for character '%x'", c);
-}
+  static void
+  warn_missing_glyph (FT_ULong c)
+  {
+    warning_with_id ("Octave:missing-glyph",
+                     "text_renderer: skipping missing glyph for character '%x'", c);
+  }
+
+  static void
+  warn_glyph_render (FT_ULong c)
+  {
+    warning_with_id ("Octave:glyph-render",
+                     "text_renderer: unable to render glyph for character '%x'", c);
+  }
 
 #if defined (_MSC_VER)
-// FIXME: is this really needed?
-//
-// This is just a trick to avoid multiple symbol definitions.
-// PermMatrix.h contains a dllexport'ed Array<octave_idx_type>
-// that will cause MSVC not to generate a new instantiation and
-// use the imported one instead.
+  // FIXME: is this really needed?
+  //
+  // This is just a trick to avoid multiple symbol definitions.
+  // PermMatrix.h contains a dllexport'ed Array<octave_idx_type>
+  // that will cause MSVC not to generate a new instantiation and
+  // use the imported one instead.
 #  include "PermMatrix.h"
 #endif
 
-// Forward declaration
-static void ft_face_destroyed (void *object);
+  // Forward declaration
+  static void ft_face_destroyed (void *object);
 
-namespace octave
-{
   class
   ft_manager
   {
   private:
 
     ft_manager (void)
       : library (), freetype_initialized (false), fontconfig_initialized (false)
     {
@@ -336,26 +336,22 @@ namespace octave
   private:
     FT_Library library;
     bool freetype_initialized;
     bool fontconfig_initialized;
   };
 
   ft_manager *ft_manager::instance = nullptr;
 
-}
+  static void
+  ft_face_destroyed (void *object)
+  {
+    octave::ft_manager::font_destroyed (reinterpret_cast<FT_Face> (object));
+  }
 
-static void
-ft_face_destroyed (void *object)
-{
-  octave::ft_manager::font_destroyed (reinterpret_cast<FT_Face> (object));
-}
-
-namespace octave
-{
   class
   OCTINTERP_API
   ft_text_renderer : public base_text_renderer
   {
   public:
 
     enum
     {
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -37,32 +37,28 @@ along with Octave; see the file COPYING.
 
 #include "errwarn.h"
 #include "gl-render.h"
 #include "oct-opengl.h"
 #include "text-renderer.h"
 
 #if defined (HAVE_OPENGL)
 
-static int
-next_power_of_2 (int n)
-{
-  int m = 1;
-
-  while (m < n && m < std::numeric_limits<int>::max ())
-    m <<= 1;
-
-  return m;
-}
-
-#endif
-
 namespace octave
 {
-#if defined (HAVE_OPENGL)
+  static int
+  next_power_of_2 (int n)
+  {
+    int m = 1;
+
+    while (m < n && m < std::numeric_limits<int>::max ())
+      m <<= 1;
+
+    return m;
+  }
 
 #define LIGHT_MODE GL_FRONT_AND_BACK
 
   // Use symbolic names for axes
   enum
   {
     X_AXIS,
     Y_AXIS,
@@ -588,45 +584,39 @@ namespace octave
   class
   opengl_renderer::patch_tesselator
   {
     // Dummy class.
   };
 
 #endif
 
-}
-
 #if defined (HAVE_OPENGL)
 
-static int
-get_maxlights (void)
-{
-
-  static int max_lights = 0;
-
-  // Check actual maximum number of lights possible
-  if (max_lights == 0)
-    {
-      for (max_lights = 0; max_lights < GL_MAX_LIGHTS; max_lights++)
-        {
-          glDisable (GL_LIGHT0 + max_lights);
-          if (glGetError ())
-            break;
-        }
-    }
-
-  return max_lights;
-
-}
+  static int
+  get_maxlights (void)
+  {
+    static int max_lights = 0;
+
+    // Check actual maximum number of lights possible
+    if (max_lights == 0)
+      {
+        for (max_lights = 0; max_lights < GL_MAX_LIGHTS; max_lights++)
+          {
+            glDisable (GL_LIGHT0 + max_lights);
+            if (glGetError ())
+              break;
+          }
+      }
+
+    return max_lights;
+  }
 
 #endif
 
-namespace octave
-{
   opengl_renderer::opengl_renderer (void)
     : toolkit (), xform (), xmin (), xmax (), ymin (), ymax (),
       zmin (), zmax (), xZ1 (), xZ2 (), marker_id (), filled_marker_id (),
       camera_pos (), camera_dir (), interpreter ("none"), txt_renderer (),
       selecting (false)
   {
     // This constructor will fail if we don't have OpenGL or if the data
     // types we assumed in our public interface aren't compatible with the
diff --git a/libinterp/corefcn/gl2ps-print.cc b/libinterp/corefcn/gl2ps-print.cc
--- a/libinterp/corefcn/gl2ps-print.cc
+++ b/libinterp/corefcn/gl2ps-print.cc
@@ -43,32 +43,32 @@ along with Octave; see the file COPYING.
 #include "unwind-prot.h"
 
 #include "gl-render.h"
 #include "oct-opengl.h"
 #include "sighandlers.h"
 #include "sysdep.h"
 #include "text-renderer.h"
 
-static void
-safe_pclose (FILE *f)
-{
-  if (f)
-    octave_pclose (f);
-}
-
-static void
-safe_fclose (FILE *f)
-{
-  if (f)
-    std::fclose (f);
-}
-
 namespace octave
 {
+  static void
+  safe_pclose (FILE *f)
+  {
+    if (f)
+      octave_pclose (f);
+  }
+
+  static void
+  safe_fclose (FILE *f)
+  {
+    if (f)
+      std::fclose (f);
+  }
+
   class
   OCTINTERP_API
   gl2ps_renderer : public opengl_renderer
   {
   public:
 
     gl2ps_renderer (FILE *_fp, const std::string& _term)
       : opengl_renderer () , fp (_fp), term (_term), fontsize (),
@@ -542,230 +542,227 @@ namespace octave
         GLint vp[4];
         glGetIntegerv (GL_VIEWPORT, vp);
 
         txtobj.set_x (coord_pix(0));
         txtobj.set_y (vp[3] - coord_pix(1));
         txtobj.set_z (coord_pix(2));
       }
   }
-}
 
-static std::string
-code_to_symbol (uint32_t code)
-{
-  std::string retval;
+  static std::string
+  code_to_symbol (uint32_t code)
+  {
+    std::string retval;
 
-  uint32_t idx = code - 945;
-  if (idx < 25)
-    {
-      std::string characters ("abgdezhqiklmnxoprVstufcyw");
-      retval = characters[idx];
-      return retval;
-    }
+    uint32_t idx = code - 945;
+    if (idx < 25)
+      {
+        std::string characters ("abgdezhqiklmnxoprVstufcyw");
+        retval = characters[idx];
+        return retval;
+      }
 
-  idx = code - 913;
-  if (idx < 25)
-    {
-      std::string characters ("ABGDEZHQIKLMNXOPRVSTUFCYW");
-      retval = characters[idx];
-    }
-  else if (code == 978)
-    retval = "U";
-  else if (code == 215)
-    retval = "\xb4";
-  else if (code == 177)
-    retval = "\xb1";
-  else if (code == 8501)
-    retval = "\xc0";
-  else if (code == 8465)
-    retval = "\xc1";
-  else if (code == 8242)
-    retval = "\xa2";
-  else if (code == 8736)
-    retval = "\xd0";
-  else if (code == 172)
-    retval = "\xd8";
-  else if (code == 9829)
-    retval = "\xa9";
-  else if (code == 8472)
-    retval = "\xc3";
-  else if (code == 8706)
-    retval = "\xb6";
-  else if (code == 8704)
-    retval = "\x22";
-  else if (code == 9827)
-    retval = "\xa7";
-  else if (code == 9824)
-    retval = "\xaa";
-  else if (code == 8476)
-    retval = "\xc2";
-  else if (code == 8734)
-    retval = "\xa5";
-  else if (code == 8730)
-    retval = "\xd6";
-  else if (code == 8707)
-    retval = "\x24";
-  else if (code == 9830)
-    retval = "\xa8";
-  else if (code == 8747)
-    retval = "\xf2";
-  else if (code == 8727)
-    retval = "\x2a";
-  else if (code == 8744)
-    retval = "\xda";
-  else if (code == 8855)
-    retval = "\xc4";
-  else if (code == 8901)
-    retval = "\xd7";
-  else if (code == 8728)
-    retval = "\xb0";
-  else if (code == 8745)
-    retval = "\xc7";
-  else if (code == 8743)
-    retval = "\xd9";
-  else if (code == 8856)
-    retval = "\xc6";
-  else if (code == 8729)
-    retval = "\xb7";
-  else if (code == 8746)
-    retval = "\xc8";
-  else if (code == 8853)
-    retval = "\xc5";
-  else if (code == 8804)
-    retval = "\xa3";
-  else if (code == 8712)
-    retval = "\xce";
-  else if (code == 8839)
-    retval = "\xca";
-  else if (code == 8801)
-    retval = "\xba";
-  else if (code == 8773)
-    retval = "\x40";
-  else if (code == 8834)
-    retval = "\xcc";
-  else if (code == 8805)
-    retval = "\xb3";
-  else if (code == 8715)
-    retval = "\x27";
-  else if (code == 8764)
-    retval = "\x7e";
-  else if (code == 8733)
-    retval = "\xb5";
-  else if (code == 8838)
-    retval = "\xcd";
-  else if (code == 8835)
-    retval = "\xc9";
-  else if (code == 8739)
-    retval = "\xbd";
-  else if (code == 8776)
-    retval = "\xbb";
-  else if (code == 8869)
-    retval = "\x5e";
-  else if (code == 8656)
-    retval = "\xdc";
-  else if (code == 8592)
-    retval = "\xac";
-  else if (code == 8658)
-    retval = "\xde";
-  else if (code == 8594)
-    retval = "\xae";
-  else if (code == 8596)
-    retval = "\xab";
-  else if (code == 8593)
-    retval = "\xad";
-  else if (code == 8595)
-    retval = "\xaf";
-  else if (code == 8970)
-    retval = "\xeb";
-  else if (code == 8971)
-    retval = "\xfb";
-  else if (code == 10216)
-    retval = "\xe1";
-  else if (code == 10217)
-    retval = "\xf1";
-  else if (code == 8968)
-    retval = "\xe9";
-  else if (code == 8969)
-    retval = "\xf9";
-  else if (code == 8800)
-    retval = "\xb9";
-  else if (code == 8230)
-    retval = "\xbc";
-  else if (code == 176)
-    retval = "\xb0";
-  else if (code == 8709)
-    retval = "\xc6";
-  else if (code == 169)
-    retval = "\xd3";
+    idx = code - 913;
+    if (idx < 25)
+      {
+        std::string characters ("ABGDEZHQIKLMNXOPRVSTUFCYW");
+        retval = characters[idx];
+      }
+    else if (code == 978)
+      retval = "U";
+    else if (code == 215)
+      retval = "\xb4";
+    else if (code == 177)
+      retval = "\xb1";
+    else if (code == 8501)
+      retval = "\xc0";
+    else if (code == 8465)
+      retval = "\xc1";
+    else if (code == 8242)
+      retval = "\xa2";
+    else if (code == 8736)
+      retval = "\xd0";
+    else if (code == 172)
+      retval = "\xd8";
+    else if (code == 9829)
+      retval = "\xa9";
+    else if (code == 8472)
+      retval = "\xc3";
+    else if (code == 8706)
+      retval = "\xb6";
+    else if (code == 8704)
+      retval = "\x22";
+    else if (code == 9827)
+      retval = "\xa7";
+    else if (code == 9824)
+      retval = "\xaa";
+    else if (code == 8476)
+      retval = "\xc2";
+    else if (code == 8734)
+      retval = "\xa5";
+    else if (code == 8730)
+      retval = "\xd6";
+    else if (code == 8707)
+      retval = "\x24";
+    else if (code == 9830)
+      retval = "\xa8";
+    else if (code == 8747)
+      retval = "\xf2";
+    else if (code == 8727)
+      retval = "\x2a";
+    else if (code == 8744)
+      retval = "\xda";
+    else if (code == 8855)
+      retval = "\xc4";
+    else if (code == 8901)
+      retval = "\xd7";
+    else if (code == 8728)
+      retval = "\xb0";
+    else if (code == 8745)
+      retval = "\xc7";
+    else if (code == 8743)
+      retval = "\xd9";
+    else if (code == 8856)
+      retval = "\xc6";
+    else if (code == 8729)
+      retval = "\xb7";
+    else if (code == 8746)
+      retval = "\xc8";
+    else if (code == 8853)
+      retval = "\xc5";
+    else if (code == 8804)
+      retval = "\xa3";
+    else if (code == 8712)
+      retval = "\xce";
+    else if (code == 8839)
+      retval = "\xca";
+    else if (code == 8801)
+      retval = "\xba";
+    else if (code == 8773)
+      retval = "\x40";
+    else if (code == 8834)
+      retval = "\xcc";
+    else if (code == 8805)
+      retval = "\xb3";
+    else if (code == 8715)
+      retval = "\x27";
+    else if (code == 8764)
+      retval = "\x7e";
+    else if (code == 8733)
+      retval = "\xb5";
+    else if (code == 8838)
+      retval = "\xcd";
+    else if (code == 8835)
+      retval = "\xc9";
+    else if (code == 8739)
+      retval = "\xbd";
+    else if (code == 8776)
+      retval = "\xbb";
+    else if (code == 8869)
+      retval = "\x5e";
+    else if (code == 8656)
+      retval = "\xdc";
+    else if (code == 8592)
+      retval = "\xac";
+    else if (code == 8658)
+      retval = "\xde";
+    else if (code == 8594)
+      retval = "\xae";
+    else if (code == 8596)
+      retval = "\xab";
+    else if (code == 8593)
+      retval = "\xad";
+    else if (code == 8595)
+      retval = "\xaf";
+    else if (code == 8970)
+      retval = "\xeb";
+    else if (code == 8971)
+      retval = "\xfb";
+    else if (code == 10216)
+      retval = "\xe1";
+    else if (code == 10217)
+      retval = "\xf1";
+    else if (code == 8968)
+      retval = "\xe9";
+    else if (code == 8969)
+      retval = "\xf9";
+    else if (code == 8800)
+      retval = "\xb9";
+    else if (code == 8230)
+      retval = "\xbc";
+    else if (code == 176)
+      retval = "\xb0";
+    else if (code == 8709)
+      retval = "\xc6";
+    else if (code == 169)
+      retval = "\xd3";
 
-  if (retval.empty ())
-    warning ("print: unhandled symbol %d", code);
+    if (retval.empty ())
+      warning ("print: unhandled symbol %d", code);
 
-  return retval;
-}
+    return retval;
+  }
 
-static std::string
-select_font (caseless_str fn, bool isbold, bool isitalic)
-{
-  std::transform (fn.begin (), fn.end (), fn.begin (), ::tolower);
-  std::string fontname;
-  if (fn == "times" || fn == "times-roman")
-    {
-      if (isitalic && isbold)
-        fontname = "Times-BoldItalic";
-      else if (isitalic)
-        fontname = "Times-Italic";
-      else if (isbold)
-        fontname = "Times-Bold";
-      else
-        fontname = "Times-Roman";
-    }
-  else if (fn == "courier")
-    {
-      if (isitalic && isbold)
-        fontname = "Courier-BoldOblique";
-      else if (isitalic)
-        fontname = "Courier-Oblique";
-      else if (isbold)
-        fontname = "Courier-Bold";
-      else
-        fontname = "Courier";
-    }
-  else if (fn == "symbol")
-    fontname = "Symbol";
-  else if (fn == "zapfdingbats")
-    fontname = "ZapfDingbats";
-  else
-    {
-      if (isitalic && isbold)
-        fontname = "Helvetica-BoldOblique";
-      else if (isitalic)
-        fontname = "Helvetica-Oblique";
-      else if (isbold)
-        fontname = "Helvetica-Bold";
-      else
-        fontname = "Helvetica";
-    }
-  return fontname;
-}
+  static std::string
+  select_font (caseless_str fn, bool isbold, bool isitalic)
+  {
+    std::transform (fn.begin (), fn.end (), fn.begin (), ::tolower);
+    std::string fontname;
+    if (fn == "times" || fn == "times-roman")
+      {
+        if (isitalic && isbold)
+          fontname = "Times-BoldItalic";
+        else if (isitalic)
+          fontname = "Times-Italic";
+        else if (isbold)
+          fontname = "Times-Bold";
+        else
+          fontname = "Times-Roman";
+      }
+    else if (fn == "courier")
+      {
+        if (isitalic && isbold)
+          fontname = "Courier-BoldOblique";
+        else if (isitalic)
+          fontname = "Courier-Oblique";
+        else if (isbold)
+          fontname = "Courier-Bold";
+        else
+          fontname = "Courier";
+      }
+    else if (fn == "symbol")
+      fontname = "Symbol";
+    else if (fn == "zapfdingbats")
+      fontname = "ZapfDingbats";
+    else
+      {
+        if (isitalic && isbold)
+          fontname = "Helvetica-BoldOblique";
+        else if (isitalic)
+          fontname = "Helvetica-Oblique";
+        else if (isbold)
+          fontname = "Helvetica-Bold";
+        else
+          fontname = "Helvetica";
+      }
+    return fontname;
+  }
 
-static void
-escape_character (const std::string chr, std::string& str)
-{
-  std::size_t idx = str.find (chr);
-  while (idx != std::string::npos)
-    {
-      str.insert (idx, 1, '\\');
-      idx = str.find (chr, idx + 2);
-    }
-}
+  static void
+  escape_character (const std::string chr, std::string& str)
+  {
+    std::size_t idx = str.find (chr);
+    while (idx != std::string::npos)
+      {
+        str.insert (idx, 1, '\\');
+        idx = str.find (chr, idx + 2);
+      }
+  }
 
-namespace octave
-{
   std::string
   gl2ps_renderer::strlist_to_svg (double x, double y, double z,
                                   Matrix box, double rotation,
                                   std::list<octave::text_renderer::string>& lst)
   {
     if (lst.empty ())
       return "";
 
@@ -1053,24 +1050,22 @@ namespace octave
     // Matrix bbox;
 
     const Matrix pos = get_transform ().scale (props.get_data_position ());
     std::string str = props.get_string ().string_vector_value ().join ("\n");
 
     render_text (str, pos(0), pos(1), pos.numel () > 2 ? pos(2) : 0.0,
                  halign, valign, props.get_rotation ());
   }
-
 }
 
 #endif
 
 namespace octave
 {
-
   // If the name of the stream begins with '|', open a pipe to the command
   // named by the rest of the string.  Otherwise, write to the named file.
 
   void
   gl2ps_print (const graphics_object& fig, const std::string& stream,
                const std::string& term)
   {
 #if defined (HAVE_GL2PS_H) && defined (HAVE_OPENGL)
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -56,175 +56,175 @@ along with Octave; see the file COPYING.
 #include "oct-iostrm.h"
 #include "oct-stdstrm.h"
 #include "oct-stream.h"
 #include "ov.h"
 #include "ovl.h"
 #include "pager.h"
 #include "utils.h"
 
-// Programming Note: There are two very different error functions used
-// in the stream code.  When invoked with "error (...)" the member
-// function from octave::stream or octave::base_stream is called.  This
-// function sets the error state on the stream AND returns control to
-// the caller.  The caller must then return a value at the end of the
-// function.  When invoked with "::error (...)" the exception-based
-// error function from error.h is used.  This function will throw an
-// exception and not return control to the caller.  BE CAREFUL and
-// invoke the correct error function!
-
-// Possible values for conv_err:
-//
-//   1 : not a real scalar
-//   2 : value is NaN
-//   3 : value is not an integer
-
-static int
-convert_to_valid_int (const octave_value& tc, int& conv_err)
-{
-  conv_err = 0;
-
-  int retval = 0;
-
-  double dval = 0.0;
-
-  try
-    {
-      dval = tc.double_value ();
-    }
-  catch (const octave::execution_exception&)
-    {
-      octave::interpreter::recover_from_exception ();
-
-      conv_err = 1;
-    }
-
-  if (! conv_err)
-    {
-      if (! lo_ieee_isnan (dval))
-        {
-          int ival = octave::math::nint (dval);
-
-          if (ival == dval)
-            retval = ival;
-          else
-            conv_err = 3;
-        }
-      else
-        conv_err = 2;
-    }
-
-  return retval;
-}
-
-static octave_idx_type
-get_size (double d, const std::string& who)
-{
-  octave_idx_type retval = -1;
-
-  if (lo_ieee_isnan (d))
-    ::error ("%s: NaN is invalid as size specification", who.c_str ());
-
-  if (octave::math::isinf (d))
-    retval = -1;
-  else
-    {
-      if (d < 0.0)
-        ::error ("%s: negative value invalid as size specification",
-                 who.c_str ());
-
-      if (d > std::numeric_limits<octave_idx_type>::max ())
-        ::error ("%s: dimension too large for Octave's index type",
-                 who.c_str ());
-
-      retval = octave::math::nint_big (d);
-    }
-
-  return retval;
-}
-
-static void
-get_size (const Array<double>& size, octave_idx_type& nr, octave_idx_type& nc,
-          bool& one_elt_size_spec, const std::string& who)
-{
-  nr = -1;
-  nc = -1;
-
-  one_elt_size_spec = false;
-
-  double dnr = -1.0;
-  double dnc = -1.0;
-
-  octave_idx_type sz_len = size.numel ();
-
-  if (sz_len == 1)
-    {
-      one_elt_size_spec = true;
-
-      dnr = size(0);
-
-      dnc = (dnr == 0.0) ? 0.0 : 1.0;
-    }
-  else if (sz_len == 2)
-    {
-      dnr = size(0);
-
-      if (octave::math::isinf (dnr))
-        ::error ("%s: invalid size specification", who.c_str ());
-
-      dnc = size(1);
-    }
-  else
-    ::error ("%s: invalid size specification", who.c_str ());
-
-  nr = get_size (dnr, who);
-
-  if (dnc >= 0.0)
-    nc = get_size (dnc, who);
-}
-
-
-static std::string
-expand_char_class (const std::string& s)
-{
-  std::string retval;
-
-  size_t len = s.length ();
-
-  size_t i = 0;
-
-  while (i < len)
-    {
-      unsigned char c = s[i++];
-
-      if (c == '-' && i > 1 && i < len
-          && (   static_cast<unsigned char> (s[i-2])
-              <= static_cast<unsigned char> (s[i])))
-        {
-          // Add all characters from the range except the first (we
-          // already added it below).
-
-          for (c = s[i-2]+1; c < s[i]; c++)
-            retval += c;
-        }
-      else
-        {
-          // Add the character to the class.  Only add '-' if it is
-          // the last character in the class.
-
-          if (c != '-' || i == len)
-            retval += c;
-        }
-    }
-
-  return retval;
-}
-
 namespace octave
 {
+  // Programming Note: There are two very different error functions used
+  // in the stream code.  When invoked with "error (...)" the member
+  // function from octave::stream or octave::base_stream is called.  This
+  // function sets the error state on the stream AND returns control to
+  // the caller.  The caller must then return a value at the end of the
+  // function.  When invoked with "::error (...)" the exception-based
+  // error function from error.h is used.  This function will throw an
+  // exception and not return control to the caller.  BE CAREFUL and
+  // invoke the correct error function!
+
+  // Possible values for conv_err:
+  //
+  //   1 : not a real scalar
+  //   2 : value is NaN
+  //   3 : value is not an integer
+
+  static int
+  convert_to_valid_int (const octave_value& tc, int& conv_err)
+  {
+    conv_err = 0;
+
+    int retval = 0;
+
+    double dval = 0.0;
+
+    try
+      {
+        dval = tc.double_value ();
+      }
+    catch (const octave::execution_exception&)
+      {
+        octave::interpreter::recover_from_exception ();
+
+        conv_err = 1;
+      }
+
+    if (! conv_err)
+      {
+        if (! lo_ieee_isnan (dval))
+          {
+            int ival = octave::math::nint (dval);
+
+            if (ival == dval)
+              retval = ival;
+            else
+              conv_err = 3;
+          }
+        else
+          conv_err = 2;
+      }
+
+    return retval;
+  }
+
+  static octave_idx_type
+  get_size (double d, const std::string& who)
+  {
+    octave_idx_type retval = -1;
+
+    if (lo_ieee_isnan (d))
+      ::error ("%s: NaN is invalid as size specification", who.c_str ());
+
+    if (octave::math::isinf (d))
+      retval = -1;
+    else
+      {
+        if (d < 0.0)
+          ::error ("%s: negative value invalid as size specification",
+                   who.c_str ());
+
+        if (d > std::numeric_limits<octave_idx_type>::max ())
+          ::error ("%s: dimension too large for Octave's index type",
+                   who.c_str ());
+
+        retval = octave::math::nint_big (d);
+      }
+
+    return retval;
+  }
+
+  static void
+  get_size (const Array<double>& size,
+            octave_idx_type& nr, octave_idx_type& nc,
+            bool& one_elt_size_spec, const std::string& who)
+  {
+    nr = -1;
+    nc = -1;
+
+    one_elt_size_spec = false;
+
+    double dnr = -1.0;
+    double dnc = -1.0;
+
+    octave_idx_type sz_len = size.numel ();
+
+    if (sz_len == 1)
+      {
+        one_elt_size_spec = true;
+
+        dnr = size(0);
+
+        dnc = (dnr == 0.0) ? 0.0 : 1.0;
+      }
+    else if (sz_len == 2)
+      {
+        dnr = size(0);
+
+        if (octave::math::isinf (dnr))
+          ::error ("%s: invalid size specification", who.c_str ());
+
+        dnc = size(1);
+      }
+    else
+      ::error ("%s: invalid size specification", who.c_str ());
+
+    nr = get_size (dnr, who);
+
+    if (dnc >= 0.0)
+      nc = get_size (dnc, who);
+  }
+
+  static std::string
+  expand_char_class (const std::string& s)
+  {
+    std::string retval;
+
+    size_t len = s.length ();
+
+    size_t i = 0;
+
+    while (i < len)
+      {
+        unsigned char c = s[i++];
+
+        if (c == '-' && i > 1 && i < len
+            && (   static_cast<unsigned char> (s[i-2])
+                   <= static_cast<unsigned char> (s[i])))
+          {
+            // Add all characters from the range except the first (we
+            // already added it below).
+
+            for (c = s[i-2]+1; c < s[i]; c++)
+              retval += c;
+          }
+        else
+          {
+            // Add the character to the class.  Only add '-' if it is
+            // the last character in the class.
+
+            if (c != '-' || i == len)
+              retval += c;
+          }
+      }
+
+    return retval;
+  }
+
   class
   scanf_format_elt
   {
   public:
 
     enum special_conversion
       {
         whitespace_conversion = 1,
@@ -1175,49 +1175,46 @@ namespace octave
           << "flags:    '" << elt->flags << "'\n"
           << "width:    " << elt->fw << "\n"
           << "prec:     " << elt->prec << "\n"
           << "type:     '" << elt->type << "'\n"
           << "modifier: '" << elt->modifier << "'\n"
           << "text:     '" << undo_string_escapes (elt->text) << "'\n\n";
       }
   }
-}
-
-// Calculate x^n.  Used for ...e+nn so that, for example, 1e2 is
-// exactly 100 and 5e-1 is 1/2
-
-static double
-pown (double x, unsigned int n)
-{
-  double retval = 1;
-
-  for (unsigned int d = n; d; d >>= 1)
-    {
-      if (d & 1)
-        retval *= x;
-      x *= x;
-    }
-
-  return retval;
-}
-
-static Cell
-init_inf_nan (void)
-{
-  Cell retval (dim_vector (1, 2));
-
-  retval(0) = Cell (octave_value ("inf"));
-  retval(1) = Cell (octave_value ("nan"));
-
-  return retval;
-}
-
-namespace octave
-{
+
+  // Calculate x^n.  Used for ...e+nn so that, for example, 1e2 is
+  // exactly 100 and 5e-1 is 1/2
+
+  static double
+  pown (double x, unsigned int n)
+  {
+    double retval = 1;
+
+    for (unsigned int d = n; d; d >>= 1)
+      {
+        if (d & 1)
+          retval *= x;
+        x *= x;
+      }
+
+    return retval;
+  }
+
+  static Cell
+  init_inf_nan (void)
+  {
+    Cell retval (dim_vector (1, 2));
+
+    retval(0) = Cell (octave_value ("inf"));
+    retval(1) = Cell (octave_value ("nan"));
+
+    return retval;
+  }
+
   // Delimited stream, optimized to read strings of characters separated
   // by single-character delimiters.
   //
   // The reason behind this class is that octstream doesn't provide
   // seek/tell, but the opportunity has been taken to optimise for the
   // textscan workload.
   //
   // The function reads chunks into a 4kiB buffer, and marks where the
@@ -5582,120 +5579,117 @@ namespace octave
 
       default:
         ::error ("%s: internal error handling format", who.c_str ());
         break;
       }
 
     return retval;
   }
-}
-
-static size_t
-do_printf_string (std::ostream& os, const octave::printf_format_elt *elt,
-                  int nsa, int sa_1, int sa_2, const std::string& arg,
-                  const std::string& who)
-{
-  if (nsa > 2)
-    ::error ("%s: internal error handling format", who.c_str ());
-
-  std::string flags = elt->flags;
-
-  bool left = flags.find ('-') != std::string::npos;
-
-  size_t len = arg.length ();
-
-  size_t fw = (nsa > 0 ? sa_1 : (elt->fw == -1 ? len : elt->fw));
-  size_t prec = (nsa > 1 ? sa_2 : (elt->prec == -1 ? len : elt->prec));
-
-  os << std::setw (fw)
-     << (left ? std::left : std::right)
-     << (prec < len ? arg.substr (0, prec) : arg);
-
-  return len > fw ? len : fw;
-}
-
-static bool
-is_nan_or_inf (const octave_value& val)
-{
-  octave_value ov_isnan = val.isnan ();
-  octave_value ov_isinf = val.isinf ();
-
-  return (ov_isnan.is_true () || ov_isinf.is_true ());
-}
-
-static bool
-ok_for_signed_int_conv (const octave_value& val)
-{
-  uint64_t limit = std::numeric_limits<int64_t>::max ();
-
-  if (val.is_string ())
-    return true;
-  else if (val.isinteger ())
-    {
-      if (val.is_uint64_type ())
-        {
-          octave_uint64 ival = val.uint64_scalar_value ();
-
-          if (ival.value () <= limit)
-            return true;
-        }
-      else
-        return true;
-    }
-  else
-    {
-      double dval = val.double_value (true);
-
-      if (dval == octave::math::round (dval) && dval <= limit)
-        return true;
-    }
-
-  return false;
-}
-
-static bool
-ok_for_unsigned_int_conv (const octave_value& val)
-{
-  if (val.is_string ())
-    return true;
-  else if (val.isinteger ())
-    {
-      // Easier than dispatching here...
-
-      octave_value ov_is_ge_zero
-        = do_binary_op (octave_value::op_ge, val, octave_value (0.0));
-
-      return ov_is_ge_zero.is_true ();
-    }
-  else
-    {
-      double dval = val.double_value (true);
-
-      uint64_t limit = std::numeric_limits<uint64_t>::max ();
-
-      if (dval == octave::math::round (dval) && dval >= 0 && dval <= limit)
-        return true;
-    }
-
-  return false;
-}
-
-static std::string
-switch_to_g_format (const octave::printf_format_elt *elt)
-{
-  std::string tfmt = elt->text;
-
-  tfmt.replace (tfmt.rfind (elt->type), 1, "g");
-
-  return tfmt;
-}
-
-namespace octave
-{
+
+  static size_t
+  do_printf_string (std::ostream& os, const octave::printf_format_elt *elt,
+                    int nsa, int sa_1, int sa_2, const std::string& arg,
+                    const std::string& who)
+  {
+    if (nsa > 2)
+      ::error ("%s: internal error handling format", who.c_str ());
+
+    std::string flags = elt->flags;
+
+    bool left = flags.find ('-') != std::string::npos;
+
+    size_t len = arg.length ();
+
+    size_t fw = (nsa > 0 ? sa_1 : (elt->fw == -1 ? len : elt->fw));
+    size_t prec = (nsa > 1 ? sa_2 : (elt->prec == -1 ? len : elt->prec));
+
+    os << std::setw (fw)
+       << (left ? std::left : std::right)
+       << (prec < len ? arg.substr (0, prec) : arg);
+
+    return len > fw ? len : fw;
+  }
+
+  static bool
+  is_nan_or_inf (const octave_value& val)
+  {
+    octave_value ov_isnan = val.isnan ();
+    octave_value ov_isinf = val.isinf ();
+
+    return (ov_isnan.is_true () || ov_isinf.is_true ());
+  }
+
+  static bool
+  ok_for_signed_int_conv (const octave_value& val)
+  {
+    uint64_t limit = std::numeric_limits<int64_t>::max ();
+
+    if (val.is_string ())
+      return true;
+    else if (val.isinteger ())
+      {
+        if (val.is_uint64_type ())
+          {
+            octave_uint64 ival = val.uint64_scalar_value ();
+
+            if (ival.value () <= limit)
+              return true;
+          }
+        else
+          return true;
+      }
+    else
+      {
+        double dval = val.double_value (true);
+
+        if (dval == octave::math::round (dval) && dval <= limit)
+          return true;
+      }
+
+    return false;
+  }
+
+  static bool
+  ok_for_unsigned_int_conv (const octave_value& val)
+  {
+    if (val.is_string ())
+      return true;
+    else if (val.isinteger ())
+      {
+        // Easier than dispatching here...
+
+        octave_value ov_is_ge_zero
+          = do_binary_op (octave_value::op_ge, val, octave_value (0.0));
+
+        return ov_is_ge_zero.is_true ();
+      }
+    else
+      {
+        double dval = val.double_value (true);
+
+        uint64_t limit = std::numeric_limits<uint64_t>::max ();
+
+        if (dval == octave::math::round (dval) && dval >= 0 && dval <= limit)
+          return true;
+      }
+
+    return false;
+  }
+
+  static std::string
+  switch_to_g_format (const octave::printf_format_elt *elt)
+  {
+    std::string tfmt = elt->text;
+
+    tfmt.replace (tfmt.rfind (elt->type), 1, "g");
+
+    return tfmt;
+  }
+
   int
   base_stream::do_numeric_printf_conv (std::ostream& os,
                                        const printf_format_elt *elt,
                                        int nsa, int sa_1, int sa_2,
                                        const octave_value& val,
                                        const std::string& who)
   {
     int retval = 0;
@@ -6301,147 +6295,146 @@ namespace octave
   }
 
   void
   stream::close (void)
   {
     if (stream_ok ())
       rep->close ();
   }
-}
-
-// FIXME: maybe these should be defined in lo-ieee.h?
-
-template <typename T>
-static inline bool
-is_old_NA (T)
-{
-  return false;
-}
-
-template <>
-inline bool
-is_old_NA<double> (double val)
-{
-  return __lo_ieee_is_old_NA (val);
-}
-
-template <typename T>
-static inline T
-replace_old_NA (T val)
-{
-  return val;
-}
-
-template <>
-inline double
-replace_old_NA<double> (double val)
-{
-  return __lo_ieee_replace_old_NA (val);
-}
-
-template <typename SRC_T, typename DST_T>
-static octave_value
-convert_and_copy (std::list<void *>& input_buf_list,
-                  octave_idx_type input_buf_elts,
-                  octave_idx_type elts_read,
-                  octave_idx_type nr, octave_idx_type nc, bool swap,
-                  bool do_float_fmt_conv, bool do_NA_conv,
-                  octave::mach_info::float_format from_flt_fmt)
-{
-  typedef typename DST_T::element_type dst_elt_type;
-
-  DST_T conv (dim_vector (nr, nc));
-
-  dst_elt_type *conv_data = conv.fortran_vec ();
-
-  octave_idx_type j = 0;
-
-  for (std::list<void *>::const_iterator it = input_buf_list.begin ();
-       it != input_buf_list.end (); it++)
-    {
-      SRC_T *data = static_cast<SRC_T *> (*it);
-
-      if (swap || do_float_fmt_conv)
-        {
-          if (do_NA_conv)
-            {
-              for (octave_idx_type i = 0; i < input_buf_elts && j < elts_read;
-                   i++, j++)
-                {
-                  if (swap)
-                    swap_bytes<sizeof (SRC_T)> (&data[i]);
-                  else if (do_float_fmt_conv)
-                    do_float_format_conversion (&data[i], sizeof (SRC_T),
-                                                1, from_flt_fmt,
-                                                octave::mach_info::native_float_format ());
-
-                  dst_elt_type tmp (data[i]);
-
-                  if (is_old_NA (tmp))
-                    tmp = replace_old_NA (tmp);
-
-                  conv_data[j] = tmp;
-                }
-            }
-          else
-            {
-              for (octave_idx_type i = 0; i < input_buf_elts && j < elts_read;
-                   i++, j++)
-                {
-                  if (swap)
-                    swap_bytes<sizeof (SRC_T)> (&data[i]);
-                  else if (do_float_fmt_conv)
-                    do_float_format_conversion (&data[i], sizeof (SRC_T),
-                                                1, from_flt_fmt,
-                                                octave::mach_info::native_float_format ());
-
+
+  // FIXME: maybe these should be defined in lo-ieee.h?
+
+  template <typename T>
+  static inline bool
+  is_old_NA (T)
+  {
+    return false;
+  }
+
+  template <>
+  inline bool
+  is_old_NA<double> (double val)
+  {
+    return __lo_ieee_is_old_NA (val);
+  }
+
+  template <typename T>
+  static inline T
+  replace_old_NA (T val)
+  {
+    return val;
+  }
+
+  template <>
+  inline double
+  replace_old_NA<double> (double val)
+  {
+    return __lo_ieee_replace_old_NA (val);
+  }
+
+  template <typename SRC_T, typename DST_T>
+  static octave_value
+  convert_and_copy (std::list<void *>& input_buf_list,
+                    octave_idx_type input_buf_elts,
+                    octave_idx_type elts_read,
+                    octave_idx_type nr, octave_idx_type nc, bool swap,
+                    bool do_float_fmt_conv, bool do_NA_conv,
+                    octave::mach_info::float_format from_flt_fmt)
+  {
+    typedef typename DST_T::element_type dst_elt_type;
+
+    DST_T conv (dim_vector (nr, nc));
+
+    dst_elt_type *conv_data = conv.fortran_vec ();
+
+    octave_idx_type j = 0;
+
+    for (std::list<void *>::const_iterator it = input_buf_list.begin ();
+         it != input_buf_list.end (); it++)
+      {
+        SRC_T *data = static_cast<SRC_T *> (*it);
+
+        if (swap || do_float_fmt_conv)
+          {
+            if (do_NA_conv)
+              {
+                for (octave_idx_type i = 0; i < input_buf_elts && j < elts_read;
+                     i++, j++)
+                  {
+                    if (swap)
+                      swap_bytes<sizeof (SRC_T)> (&data[i]);
+                    else if (do_float_fmt_conv)
+                      do_float_format_conversion (&data[i], sizeof (SRC_T),
+                                                  1, from_flt_fmt,
+                                                  octave::mach_info::native_float_format ());
+
+                    dst_elt_type tmp (data[i]);
+
+                    if (is_old_NA (tmp))
+                      tmp = replace_old_NA (tmp);
+
+                    conv_data[j] = tmp;
+                  }
+              }
+            else
+              {
+                for (octave_idx_type i = 0; i < input_buf_elts && j < elts_read;
+                     i++, j++)
+                  {
+                    if (swap)
+                      swap_bytes<sizeof (SRC_T)> (&data[i]);
+                    else if (do_float_fmt_conv)
+                      do_float_format_conversion (&data[i], sizeof (SRC_T),
+                                                  1, from_flt_fmt,
+                                                  octave::mach_info::native_float_format ());
+
+                    conv_data[j] = data[i];
+                  }
+              }
+          }
+        else
+          {
+            if (do_NA_conv)
+              {
+                for (octave_idx_type i = 0; i < input_buf_elts && j < elts_read;
+                     i++, j++)
+                  {
+                    dst_elt_type tmp (data[i]);
+
+                    if (is_old_NA (tmp))
+                      tmp = replace_old_NA (tmp);
+
+                    conv_data[j] = tmp;
+                  }
+              }
+            else
+              {
+                for (octave_idx_type i = 0; i < input_buf_elts && j < elts_read;
+                     i++, j++)
                   conv_data[j] = data[i];
-                }
-            }
-        }
-      else
-        {
-          if (do_NA_conv)
-            {
-              for (octave_idx_type i = 0; i < input_buf_elts && j < elts_read;
-                   i++, j++)
-                {
-                  dst_elt_type tmp (data[i]);
-
-                  if (is_old_NA (tmp))
-                    tmp = replace_old_NA (tmp);
-
-                  conv_data[j] = tmp;
-                }
-            }
-          else
-            {
-              for (octave_idx_type i = 0; i < input_buf_elts && j < elts_read;
-                   i++, j++)
-                conv_data[j] = data[i];
-            }
-        }
-
-      delete [] data;
-    }
-
-  input_buf_list.clear ();
-
-  for (octave_idx_type i = elts_read; i < nr * nc; i++)
-    conv_data[i] = dst_elt_type (0);
-
-  return conv;
-}
-
-typedef octave_value (*conv_fptr)
-  (std::list<void *>& input_buf_list, octave_idx_type input_buf_elts,
-   octave_idx_type elts_read, octave_idx_type nr, octave_idx_type nc,
-   bool swap, bool do_float_fmt_conv, bool do_NA_conv,
-   octave::mach_info::float_format from_flt_fmt);
+              }
+          }
+
+        delete [] data;
+      }
+
+    input_buf_list.clear ();
+
+    for (octave_idx_type i = elts_read; i < nr * nc; i++)
+      conv_data[i] = dst_elt_type (0);
+
+    return conv;
+  }
+
+  typedef octave_value (*conv_fptr)
+    (std::list<void *>& input_buf_list, octave_idx_type input_buf_elts,
+     octave_idx_type elts_read, octave_idx_type nr, octave_idx_type nc,
+     bool swap, bool do_float_fmt_conv, bool do_NA_conv,
+     octave::mach_info::float_format from_flt_fmt);
 
 #define TABLE_ELT(T, U, V, W)                                           \
   conv_fptr_table[oct_data_conv::T][oct_data_conv::U] = convert_and_copy<V, W>
 
 #define FILL_TABLE_ROW(T, V)                    \
   TABLE_ELT (T, dt_int8, V, int8NDArray);       \
   TABLE_ELT (T, dt_uint8, V, uint8NDArray);     \
   TABLE_ELT (T, dt_int16, V, int16NDArray);     \
@@ -6452,18 +6445,16 @@ typedef octave_value (*conv_fptr)
   TABLE_ELT (T, dt_uint64, V, uint64NDArray);   \
   TABLE_ELT (T, dt_single, V, FloatNDArray);    \
   TABLE_ELT (T, dt_double, V, NDArray);         \
   TABLE_ELT (T, dt_char, V, charNDArray);       \
   TABLE_ELT (T, dt_schar, V, charNDArray);      \
   TABLE_ELT (T, dt_uchar, V, charNDArray);      \
   TABLE_ELT (T, dt_logical, V, boolNDArray);
 
-namespace octave
-{
   octave_value
   stream::finalize_read (std::list<void *>& input_buf_list,
                          octave_idx_type input_buf_elts,
                          octave_idx_type elts_read,
                          octave_idx_type nr, octave_idx_type nc,
                          oct_data_conv::data_type input_type,
                          oct_data_conv::data_type output_type,
                          mach_info::float_format ffmt)
@@ -6764,167 +6755,164 @@ namespace octave
         if (status < 0)
           error ("fwrite: write error");
         else
           retval = status;
       }
 
     return retval;
   }
-}
-
-template <typename T, typename V>
-static void
-convert_chars (const void *data, void *conv_data, octave_idx_type n_elts)
-{
-  const T *tt_data = static_cast<const T *> (data);
-
-  V *vt_data = static_cast<V *> (conv_data);
-
-  for (octave_idx_type i = 0; i < n_elts; i++)
-    vt_data[i] = tt_data[i];
-}
-
-template <typename T, typename V>
-static void
-convert_ints (const T *data, void *conv_data, octave_idx_type n_elts,
-              bool swap)
-{
-  typedef typename V::val_type val_type;
-
-  val_type *vt_data = static_cast<val_type *> (conv_data);
-
-  for (octave_idx_type i = 0; i < n_elts; i++)
-    {
-      // Yes, we want saturation semantics when converting to an integer type.
-      V val (data[i]);
-
-      vt_data[i] = val.value ();
-
-      if (swap)
-        swap_bytes<sizeof (val_type)> (&vt_data[i]);
-    }
-}
-
-template <typename T>
-class ultimate_element_type
-{
-public:
-  typedef T type;
-};
-
-template <typename T>
-class ultimate_element_type<octave_int<T>>
-{
-public:
-  typedef T type;
-};
-
-template <typename T>
-static bool
-convert_data (const T *data, void *conv_data, octave_idx_type n_elts,
-              oct_data_conv::data_type output_type,
-              octave::mach_info::float_format flt_fmt)
-{
-  bool retval = true;
-
-  bool swap = false;
-
-  if (octave::mach_info::words_big_endian ())
-    swap = (flt_fmt == octave::mach_info::flt_fmt_ieee_little_endian);
-  else
-    swap = (flt_fmt == octave::mach_info::flt_fmt_ieee_big_endian);
-
-  bool do_float_conversion = flt_fmt != octave::mach_info::float_format ();
-
-  typedef typename ultimate_element_type<T>::type ult_elt_type;
-
-  switch (output_type)
-    {
-    case oct_data_conv::dt_char:
-      convert_chars<ult_elt_type, char> (data, conv_data, n_elts);
-      break;
-
-    case oct_data_conv::dt_schar:
-      convert_chars<ult_elt_type, signed char> (data, conv_data, n_elts);
-      break;
-
-    case oct_data_conv::dt_uchar:
-      convert_chars<ult_elt_type, unsigned char> (data, conv_data, n_elts);
-      break;
-
-    case oct_data_conv::dt_int8:
-      convert_ints<T, octave_int8> (data, conv_data, n_elts, swap);
-      break;
-
-    case oct_data_conv::dt_uint8:
-      convert_ints<T, octave_uint8> (data, conv_data, n_elts, swap);
-      break;
-
-    case oct_data_conv::dt_int16:
-      convert_ints<T, octave_int16> (data, conv_data, n_elts, swap);
-      break;
-
-    case oct_data_conv::dt_uint16:
-      convert_ints<T, octave_uint16> (data, conv_data, n_elts, swap);
-      break;
-
-    case oct_data_conv::dt_int32:
-      convert_ints<T, octave_int32> (data, conv_data, n_elts, swap);
-      break;
-
-    case oct_data_conv::dt_uint32:
-      convert_ints<T, octave_uint32> (data, conv_data, n_elts, swap);
-      break;
-
-    case oct_data_conv::dt_int64:
-      convert_ints<T, octave_int64> (data, conv_data, n_elts, swap);
-      break;
-
-    case oct_data_conv::dt_uint64:
-      convert_ints<T, octave_uint64> (data, conv_data, n_elts, swap);
-      break;
-
-    case oct_data_conv::dt_single:
-      {
-        float *vt_data = static_cast<float *> (conv_data);
-
-        for (octave_idx_type i = 0; i < n_elts; i++)
-          {
-            vt_data[i] = data[i];
-
-            if (do_float_conversion)
-              do_float_format_conversion (&vt_data[i], 1, flt_fmt);
-          }
-      }
-      break;
-
-    case oct_data_conv::dt_double:
-      {
-        double *vt_data = static_cast<double *> (conv_data);
-
-        for (octave_idx_type i = 0; i < n_elts; i++)
-          {
-            vt_data[i] = data[i];
-
-            if (do_float_conversion)
-              do_double_format_conversion (&vt_data[i], 1, flt_fmt);
-          }
-      }
-      break;
-
-    default:
-      ::error ("write: invalid type specification");
-    }
-
-  return retval;
-}
-
-namespace octave
-{
+
+  template <typename T, typename V>
+  static void
+  convert_chars (const void *data, void *conv_data, octave_idx_type n_elts)
+  {
+    const T *tt_data = static_cast<const T *> (data);
+
+    V *vt_data = static_cast<V *> (conv_data);
+
+    for (octave_idx_type i = 0; i < n_elts; i++)
+      vt_data[i] = tt_data[i];
+  }
+
+  template <typename T, typename V>
+  static void
+  convert_ints (const T *data, void *conv_data, octave_idx_type n_elts,
+                bool swap)
+  {
+    typedef typename V::val_type val_type;
+
+    val_type *vt_data = static_cast<val_type *> (conv_data);
+
+    for (octave_idx_type i = 0; i < n_elts; i++)
+      {
+        // Yes, we want saturation semantics when converting to an integer type.
+        V val (data[i]);
+
+        vt_data[i] = val.value ();
+
+        if (swap)
+          swap_bytes<sizeof (val_type)> (&vt_data[i]);
+      }
+  }
+
+  template <typename T>
+  class ultimate_element_type
+  {
+  public:
+    typedef T type;
+  };
+
+  template <typename T>
+  class ultimate_element_type<octave_int<T>>
+  {
+  public:
+    typedef T type;
+  };
+
+  template <typename T>
+  static bool
+  convert_data (const T *data, void *conv_data, octave_idx_type n_elts,
+                oct_data_conv::data_type output_type,
+                octave::mach_info::float_format flt_fmt)
+  {
+    bool retval = true;
+
+    bool swap = false;
+
+    if (octave::mach_info::words_big_endian ())
+      swap = (flt_fmt == octave::mach_info::flt_fmt_ieee_little_endian);
+    else
+      swap = (flt_fmt == octave::mach_info::flt_fmt_ieee_big_endian);
+
+    bool do_float_conversion = flt_fmt != octave::mach_info::float_format ();
+
+    typedef typename ultimate_element_type<T>::type ult_elt_type;
+
+    switch (output_type)
+      {
+      case oct_data_conv::dt_char:
+        convert_chars<ult_elt_type, char> (data, conv_data, n_elts);
+        break;
+
+      case oct_data_conv::dt_schar:
+        convert_chars<ult_elt_type, signed char> (data, conv_data, n_elts);
+        break;
+
+      case oct_data_conv::dt_uchar:
+        convert_chars<ult_elt_type, unsigned char> (data, conv_data, n_elts);
+        break;
+
+      case oct_data_conv::dt_int8:
+        convert_ints<T, octave_int8> (data, conv_data, n_elts, swap);
+        break;
+
+      case oct_data_conv::dt_uint8:
+        convert_ints<T, octave_uint8> (data, conv_data, n_elts, swap);
+        break;
+
+      case oct_data_conv::dt_int16:
+        convert_ints<T, octave_int16> (data, conv_data, n_elts, swap);
+        break;
+
+      case oct_data_conv::dt_uint16:
+        convert_ints<T, octave_uint16> (data, conv_data, n_elts, swap);
+        break;
+
+      case oct_data_conv::dt_int32:
+        convert_ints<T, octave_int32> (data, conv_data, n_elts, swap);
+        break;
+
+      case oct_data_conv::dt_uint32:
+        convert_ints<T, octave_uint32> (data, conv_data, n_elts, swap);
+        break;
+
+      case oct_data_conv::dt_int64:
+        convert_ints<T, octave_int64> (data, conv_data, n_elts, swap);
+        break;
+
+      case oct_data_conv::dt_uint64:
+        convert_ints<T, octave_uint64> (data, conv_data, n_elts, swap);
+        break;
+
+      case oct_data_conv::dt_single:
+        {
+          float *vt_data = static_cast<float *> (conv_data);
+
+          for (octave_idx_type i = 0; i < n_elts; i++)
+            {
+              vt_data[i] = data[i];
+
+              if (do_float_conversion)
+                do_float_format_conversion (&vt_data[i], 1, flt_fmt);
+            }
+        }
+        break;
+
+      case oct_data_conv::dt_double:
+        {
+          double *vt_data = static_cast<double *> (conv_data);
+
+          for (octave_idx_type i = 0; i < n_elts; i++)
+            {
+              vt_data[i] = data[i];
+
+              if (do_float_conversion)
+                do_double_format_conversion (&vt_data[i], 1, flt_fmt);
+            }
+        }
+        break;
+
+      default:
+        ::error ("write: invalid type specification");
+      }
+
+    return retval;
+  }
+
   bool
   stream::write_bytes (const void *data, size_t nbytes)
   {
     bool status = false;
 
     std::ostream *osp = output_stream ();
 
     if (osp)
@@ -7379,30 +7367,27 @@ namespace octave
 
     if (list.size () >= list.max_size ())
       ::error ("could not create file id");
 
     list[stream_number] = os;
 
     return stream_number;
   }
-}
-
-OCTAVE_NORETURN static
-void
-err_invalid_file_id (int fid, const std::string& who)
-{
-  if (who.empty ())
-    ::error ("invalid stream number = %d", fid);
-  else
-    ::error ("%s: invalid stream number = %d", who.c_str (), fid);
-}
-
-namespace octave
-{
+
+  OCTAVE_NORETURN static
+  void
+  err_invalid_file_id (int fid, const std::string& who)
+  {
+    if (who.empty ())
+      ::error ("invalid stream number = %d", fid);
+    else
+      ::error ("%s: invalid stream number = %d", who.c_str (), fid);
+  }
+
   stream stream_list::lookup (int fid, const std::string& who) const
   {
     stream retval;
 
     if (fid < 0)
       err_invalid_file_id (fid, who);
 
     if (lookup_cache != list.end () && lookup_cache->first == fid)
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -50,73 +50,73 @@ along with Octave; see the file COPYING.
 #include "symtab.h"
 #include "unwind-prot.h"
 #include "utils.h"
 
 // Should Octave always check to see if function files have changed
 // since they were last compiled?
 static int Vignore_function_time_stamp = 1;
 
-static void
-split_name_with_package (const std::string& name, std::string& fname,
-                         std::string& pname)
-{
-  size_t pos = name.rfind ('.');
-
-  fname.clear ();
-  pname.clear ();
-
-  if (pos != std::string::npos)
-    {
-      fname = name.substr (pos + 1);
-      pname = name.substr (0, pos);
-    }
-  else
-    fname = name;
-}
-
-// Check the load path to see if file that defined this is still
-// visible.  If the file is no longer visible, then erase the
-// definition and move on.  If the file is visible, then we also
-// need to check to see whether the file has changed since the
-// function was loaded/parsed.  However, this check should only
-// happen once per prompt (for files found from relative path
-// elements, we also check if the working directory has changed
-// since the last time the function was loaded/parsed).
-//
-// FIXME: perhaps this should be done for all loaded functions when
-// the prompt is printed or the directory has changed, and then we
-// would not check for it when finding symbol definitions.
-
-static inline bool
-load_out_of_date_fcn (const std::string& ff, const std::string& dir_name,
-                      octave_value& function,
-                      const std::string& dispatch_type = "",
-                      const std::string& package_name = "")
-{
-  bool retval = false;
-
-  octave_value ov_fcn
-    = octave::load_fcn_from_file (ff, dir_name, dispatch_type,
-                                  package_name);
-
-  if (ov_fcn.is_defined ())
-    {
-      retval = true;
-
-      function = ov_fcn;
-    }
-  else
-    function = octave_value ();
-
-  return retval;
-}
-
 namespace octave
 {
+  static void
+  split_name_with_package (const std::string& name, std::string& fname,
+                           std::string& pname)
+  {
+    size_t pos = name.rfind ('.');
+
+    fname.clear ();
+    pname.clear ();
+
+    if (pos != std::string::npos)
+      {
+        fname = name.substr (pos + 1);
+        pname = name.substr (0, pos);
+      }
+    else
+      fname = name;
+  }
+
+  // Check the load path to see if file that defined this is still
+  // visible.  If the file is no longer visible, then erase the
+  // definition and move on.  If the file is visible, then we also
+  // need to check to see whether the file has changed since the
+  // function was loaded/parsed.  However, this check should only
+  // happen once per prompt (for files found from relative path
+  // elements, we also check if the working directory has changed
+  // since the last time the function was loaded/parsed).
+  //
+  // FIXME: perhaps this should be done for all loaded functions when
+  // the prompt is printed or the directory has changed, and then we
+  // would not check for it when finding symbol definitions.
+
+  static inline bool
+  load_out_of_date_fcn (const std::string& ff, const std::string& dir_name,
+                        octave_value& function,
+                        const std::string& dispatch_type = "",
+                        const std::string& package_name = "")
+  {
+    bool retval = false;
+
+    octave_value ov_fcn
+      = octave::load_fcn_from_file (ff, dir_name, dispatch_type,
+                                    package_name);
+
+    if (ov_fcn.is_defined ())
+      {
+        retval = true;
+
+        function = ov_fcn;
+      }
+    else
+      function = octave_value ();
+
+    return retval;
+  }
+
   bool
   out_of_date_check (octave_value& function,
                      const std::string& dispatch_type,
                      bool check_relative)
   {
     bool retval = false;
 
     octave_function *fcn = function.function_value (true);
@@ -488,40 +488,37 @@ namespace octave
               }
           }
 
         m_current_scope = stored_scope;
       }
 
     return fcn;
   }
-}
 
-template <template <typename, typename...> class C, typename V,
-          typename... A>
-static octave_value
-dump_container_map (const std::map<std::string, C<V, A...>>& container_map)
-{
-  if (container_map.empty ())
-    return octave_value (Matrix ());
+  template <template <typename, typename...> class C, typename V,
+            typename... A>
+  static octave_value
+  dump_container_map (const std::map<std::string, C<V, A...>>& container_map)
+  {
+    if (container_map.empty ())
+      return octave_value (Matrix ());
 
-  std::map<std::string, octave_value> info_map;
+    std::map<std::string, octave_value> info_map;
 
-  for (const auto& nm_container : container_map)
-    {
-      std::string nm = nm_container.first;
-      const C<V, A...>& container = nm_container.second;
-      info_map[nm] = Cell (container);
-    }
+    for (const auto& nm_container : container_map)
+      {
+        std::string nm = nm_container.first;
+        const C<V, A...>& container = nm_container.second;
+        info_map[nm] = Cell (container);
+      }
 
-  return octave_value (info_map);
-}
+    return octave_value (info_map);
+  }
 
-namespace octave
-{
   octave_value
   symbol_table::dump (void) const
   {
     std::map<std::string, octave_value> m
       = {{ "function_info", dump_fcn_table_map () },
          { "precedence_table", dump_container_map (m_class_precedence_table) },
          { "parent_classes", dump_container_map (m_parent_map) }};
 
diff --git a/libinterp/parse-tree/pt-cbinop.cc b/libinterp/parse-tree/pt-cbinop.cc
--- a/libinterp/parse-tree/pt-cbinop.cc
+++ b/libinterp/parse-tree/pt-cbinop.cc
@@ -26,149 +26,146 @@ along with Octave; see the file COPYING.
 
 #include "ov.h"
 #include "pt-cbinop.h"
 #include "pt-unop.h"
 
 namespace octave
 {
   typedef tree_expression* tree_expression_ptr_t;
-}
 
-// If a tree expression is a transpose or hermitian transpose, return
-// the argument and corresponding operator.
+  // If a tree expression is a transpose or hermitian transpose, return
+  // the argument and corresponding operator.
 
-static octave_value::unary_op
-strip_trans_herm (octave::tree_expression_ptr_t& exp)
-{
-  if (exp->is_unary_expression ())
-    {
-      octave::tree_unary_expression *uexp =
-        dynamic_cast<octave::tree_unary_expression *> (exp);
+  static octave_value::unary_op
+  strip_trans_herm (octave::tree_expression_ptr_t& exp)
+  {
+    if (exp->is_unary_expression ())
+      {
+        octave::tree_unary_expression *uexp =
+          dynamic_cast<octave::tree_unary_expression *> (exp);
 
-      octave_value::unary_op op = uexp->op_type ();
+        octave_value::unary_op op = uexp->op_type ();
 
-      if (op == octave_value::op_transpose
-          || op == octave_value::op_hermitian)
-        exp = uexp->operand ();
-      else
-        op = octave_value::unknown_unary_op;
+        if (op == octave_value::op_transpose
+            || op == octave_value::op_hermitian)
+          exp = uexp->operand ();
+        else
+          op = octave_value::unknown_unary_op;
 
-      return op;
-    }
-  else
-    return octave_value::unknown_unary_op;
-}
+        return op;
+      }
+    else
+      return octave_value::unknown_unary_op;
+  }
 
-static octave_value::unary_op
-strip_not (octave::tree_expression_ptr_t& exp)
-{
-  if (exp->is_unary_expression ())
-    {
-      octave::tree_unary_expression *uexp =
-        dynamic_cast<octave::tree_unary_expression *> (exp);
+  static octave_value::unary_op
+  strip_not (octave::tree_expression_ptr_t& exp)
+  {
+    if (exp->is_unary_expression ())
+      {
+        octave::tree_unary_expression *uexp =
+          dynamic_cast<octave::tree_unary_expression *> (exp);
 
-      octave_value::unary_op op = uexp->op_type ();
+        octave_value::unary_op op = uexp->op_type ();
 
-      if (op == octave_value::op_not)
-        exp = uexp->operand ();
-      else
-        op = octave_value::unknown_unary_op;
+        if (op == octave_value::op_not)
+          exp = uexp->operand ();
+        else
+          op = octave_value::unknown_unary_op;
 
-      return op;
-    }
-  else
-    return octave_value::unknown_unary_op;
-}
+        return op;
+      }
+    else
+      return octave_value::unknown_unary_op;
+  }
 
-// Possibly convert multiplication to trans_mul, mul_trans, herm_mul,
-// or mul_herm.
+  // Possibly convert multiplication to trans_mul, mul_trans, herm_mul,
+  // or mul_herm.
 
-static octave_value::compound_binary_op
-simplify_mul_op (octave::tree_expression_ptr_t& a,
-                 octave::tree_expression_ptr_t& b)
-{
-  octave_value::compound_binary_op retop
-    = octave_value::unknown_compound_binary_op;
+  static octave_value::compound_binary_op
+  simplify_mul_op (octave::tree_expression_ptr_t& a,
+                   octave::tree_expression_ptr_t& b)
+  {
+    octave_value::compound_binary_op retop
+      = octave_value::unknown_compound_binary_op;
 
-  octave_value::unary_op opa = strip_trans_herm (a);
+    octave_value::unary_op opa = strip_trans_herm (a);
 
-  if (opa == octave_value::op_hermitian)
-    retop = octave_value::op_herm_mul;
-  else if (opa == octave_value::op_transpose)
-    retop = octave_value::op_trans_mul;
-  else
-    {
-      octave_value::unary_op opb = strip_trans_herm (b);
+    if (opa == octave_value::op_hermitian)
+      retop = octave_value::op_herm_mul;
+    else if (opa == octave_value::op_transpose)
+      retop = octave_value::op_trans_mul;
+    else
+      {
+        octave_value::unary_op opb = strip_trans_herm (b);
 
-      if (opb == octave_value::op_hermitian)
-        retop = octave_value::op_mul_herm;
-      else if (opb == octave_value::op_transpose)
-        retop = octave_value::op_mul_trans;
-    }
+        if (opb == octave_value::op_hermitian)
+          retop = octave_value::op_mul_herm;
+        else if (opb == octave_value::op_transpose)
+          retop = octave_value::op_mul_trans;
+      }
 
-  return retop;
-}
+    return retop;
+  }
 
-// Possibly convert left division to trans_ldiv or herm_ldiv.
+  // Possibly convert left division to trans_ldiv or herm_ldiv.
 
-static octave_value::compound_binary_op
-simplify_ldiv_op (octave::tree_expression_ptr_t& a,
-                  octave::tree_expression_ptr_t&)
-{
-  octave_value::compound_binary_op retop
-    = octave_value::unknown_compound_binary_op;
+  static octave_value::compound_binary_op
+  simplify_ldiv_op (octave::tree_expression_ptr_t& a,
+                    octave::tree_expression_ptr_t&)
+  {
+    octave_value::compound_binary_op retop
+      = octave_value::unknown_compound_binary_op;
 
-  octave_value::unary_op opa = strip_trans_herm (a);
+    octave_value::unary_op opa = strip_trans_herm (a);
 
-  if (opa == octave_value::op_hermitian)
-    retop = octave_value::op_herm_ldiv;
-  else if (opa == octave_value::op_transpose)
-    retop = octave_value::op_trans_ldiv;
+    if (opa == octave_value::op_hermitian)
+      retop = octave_value::op_herm_ldiv;
+    else if (opa == octave_value::op_transpose)
+      retop = octave_value::op_trans_ldiv;
 
-  return retop;
-}
+    return retop;
+  }
 
-// Possibly contract and/or with negation.
+  // Possibly contract and/or with negation.
 
-static octave_value::compound_binary_op
-simplify_and_or_op (octave::tree_expression_ptr_t& a,
-                    octave::tree_expression_ptr_t& b,
-                    octave_value::binary_op op)
-{
-  octave_value::compound_binary_op retop
-    = octave_value::unknown_compound_binary_op;
+  static octave_value::compound_binary_op
+  simplify_and_or_op (octave::tree_expression_ptr_t& a,
+                      octave::tree_expression_ptr_t& b,
+                      octave_value::binary_op op)
+  {
+    octave_value::compound_binary_op retop
+      = octave_value::unknown_compound_binary_op;
 
-  octave_value::unary_op opa = strip_not (a);
+    octave_value::unary_op opa = strip_not (a);
 
-  if (opa == octave_value::op_not)
-    {
-      if (op == octave_value::op_el_and)
-        retop = octave_value::op_el_not_and;
-      else if (op == octave_value::op_el_or)
-        retop = octave_value::op_el_not_or;
-    }
-  else
-    {
-      octave_value::unary_op opb = strip_not (b);
+    if (opa == octave_value::op_not)
+      {
+        if (op == octave_value::op_el_and)
+          retop = octave_value::op_el_not_and;
+        else if (op == octave_value::op_el_or)
+          retop = octave_value::op_el_not_or;
+      }
+    else
+      {
+        octave_value::unary_op opb = strip_not (b);
 
-      if (opb == octave_value::op_not)
-        {
-          if (op == octave_value::op_el_and)
-            retop = octave_value::op_el_and_not;
-          else if (op == octave_value::op_el_or)
-            retop = octave_value::op_el_or_not;
-        }
-    }
+        if (opb == octave_value::op_not)
+          {
+            if (op == octave_value::op_el_and)
+              retop = octave_value::op_el_and_not;
+            else if (op == octave_value::op_el_or)
+              retop = octave_value::op_el_or_not;
+          }
+      }
 
-  return retop;
-}
+    return retop;
+  }
 
-namespace octave
-{
   tree_binary_expression *
   maybe_compound_binary_expression (tree_expression *a, tree_expression *b,
                                     int l, int c, octave_value::binary_op t)
   {
     tree_expression *ca = a;
     tree_expression *cb = b;
     octave_value::compound_binary_op ct;
 
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -748,41 +748,38 @@ namespace octave
               init_val = evaluate (expr);
             else
               init_val = Matrix ();
 
             ult.assign (octave_value::op_asn_eq, init_val);
           }
       }
   }
-}
-
-// Decide if it's time to quit a for or while loop.
-static inline bool
-quit_loop_now (void)
-{
-  octave_quit ();
-
-  // Maybe handle 'continue N' someday...
-
-  if (octave::tree_continue_command::continuing)
-    octave::tree_continue_command::continuing--;
-
-  bool quit = (octave::tree_return_command::returning
-               || octave::tree_break_command::breaking
-               || octave::tree_continue_command::continuing);
-
-  if (octave::tree_break_command::breaking)
-    octave::tree_break_command::breaking--;
-
-  return quit;
-}
-
-namespace octave
-{
+
+  // Decide if it's time to quit a for or while loop.
+  static inline bool
+  quit_loop_now (void)
+  {
+    octave_quit ();
+
+    // Maybe handle 'continue N' someday...
+
+    if (octave::tree_continue_command::continuing)
+      octave::tree_continue_command::continuing--;
+
+    bool quit = (octave::tree_return_command::returning
+                 || octave::tree_break_command::breaking
+                 || octave::tree_continue_command::continuing);
+
+    if (octave::tree_break_command::breaking)
+      octave::tree_break_command::breaking--;
+
+    return quit;
+  }
+
   void
   tree_evaluator::visit_simple_for_command (tree_simple_for_command& cmd)
   {
     size_t line = cmd.line ();
 
     if (m_echo_state)
       {
         echo_code (line);
@@ -1146,63 +1143,60 @@ namespace octave
 
             if (stmt_lst)
               stmt_lst->accept (*this);
 
             break;
           }
       }
   }
-}
-
-// Final step of processing an indexing error.  Add the name of the
-// variable being indexed, if any, then issue an error.  (Will this also
-// be needed by pt-lvalue, which calls subsref?)
-
-static void
-final_index_error (octave::index_exception& e,
-                   const octave::tree_expression *expr)
-{
-  std::string extra_message;
-
-  // FIXME: make this a member function for direct access to symbol
-  // table and scope?
-
-  octave::symbol_scope scope
-    = octave::__require_current_scope__ ("final_index_error");
-
-  octave::symbol_record::context_id context = scope.current_context ();
-
-  if (expr->is_identifier ()
-      && dynamic_cast<const octave::tree_identifier *> (expr)->is_variable (context))
-    {
-      std::string var = expr->name ();
-
-      e.set_var (var);
-
-      octave::symbol_table& symtab = octave::__get_symbol_table__ ("final_index_error");
-
-      octave_value fcn = symtab.find_function (var);
-
-      if (fcn.is_function ())
-        {
-          octave_function *fp = fcn.function_value ();
-
-          if (fp && fp->name () == var)
-            extra_message = " (note: variable '" + var + "' shadows function)";
-        }
-    }
-
-  std::string msg = e.message () + extra_message;
-
-  error_with_id (e.err_id (), msg.c_str ());
-}
-
-namespace octave
-{
+
+  // Final step of processing an indexing error.  Add the name of the
+  // variable being indexed, if any, then issue an error.  (Will this also
+  // be needed by pt-lvalue, which calls subsref?)
+
+  static void
+  final_index_error (octave::index_exception& e,
+                     const octave::tree_expression *expr)
+  {
+    std::string extra_message;
+
+    // FIXME: make this a member function for direct access to symbol
+    // table and scope?
+
+    octave::symbol_scope scope
+      = octave::__require_current_scope__ ("final_index_error");
+
+    octave::symbol_record::context_id context = scope.current_context ();
+
+    if (expr->is_identifier ()
+        && dynamic_cast<const octave::tree_identifier *> (expr)->is_variable (context))
+      {
+        std::string var = expr->name ();
+
+        e.set_var (var);
+
+        octave::symbol_table& symtab = octave::__get_symbol_table__ ("final_index_error");
+
+        octave_value fcn = symtab.find_function (var);
+
+        if (fcn.is_function ())
+          {
+            octave_function *fp = fcn.function_value ();
+
+            if (fp && fp->name () == var)
+              extra_message = " (note: variable '" + var + "' shadows function)";
+          }
+      }
+
+    std::string msg = e.message () + extra_message;
+
+    error_with_id (e.err_id (), msg.c_str ());
+  }
+
   // Unlike Matlab, which does not allow the result of a function call
   // or array indexing expression to be further indexed, Octave attempts
   // to handle arbitrary index expressions.  For example, Octave allows
   // expressions like
   //
   //   svd (rand (10))(1:5)
   //
   // Although octave_value objects may contain function objects, no
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -138,43 +138,42 @@ namespace octave
   // This is useful for printing the name of the variable in an indexed
   // assignment.
 
   std::string
   tree_index_expression::name (void) const
   {
     return expr->name ();
   }
-}
 
-static inline octave_value_list
-make_value_list (octave::tree_evaluator *tw, octave::tree_argument_list *args,
-                 const string_vector& arg_nm, const octave_value *object,
-                 bool rvalue = true)
-{
-  octave_value_list retval;
-
-  if (args)
-    {
-      if (rvalue && object && args->has_magic_end () && object->is_undefined ())
-        err_invalid_inquiry_subscript ();
+  static inline octave_value_list
+  make_value_list (octave::tree_evaluator *tw,
+                   octave::tree_argument_list *args,
+                   const string_vector& arg_nm, const octave_value *object,
+                   bool rvalue = true)
+  {
+    octave_value_list retval;
 
-      retval = args->convert_to_const_vector (tw, object);
-    }
+    if (args)
+      {
+        if (rvalue && object && args->has_magic_end ()
+            && object->is_undefined ())
+          err_invalid_inquiry_subscript ();
 
-  octave_idx_type n = retval.length ();
+        retval = args->convert_to_const_vector (tw, object);
+      }
 
-  if (n > 0)
-    retval.stash_name_tags (arg_nm);
+    octave_idx_type n = retval.length ();
 
-  return retval;
-}
+    if (n > 0)
+      retval.stash_name_tags (arg_nm);
 
-namespace octave
-{
+    return retval;
+  }
+
   std::string
   tree_index_expression::get_struct_index
   (tree_evaluator *tw,
    std::list<string_vector>::const_iterator p_arg_nm,
    std::list<tree_expression *>::const_iterator p_dyn_field) const
   {
     std::string fn = (*p_arg_nm)(0);
 
@@ -189,57 +188,55 @@ namespace octave
             fn = t.xstring_value ("dynamic structure field names must be strings");
           }
         else
           panic_impossible ();
       }
 
     return fn;
   }
-}
 
-// Final step of processing an indexing error.  Add the name of the
-// variable being indexed, if any, then issue an error.  (Will this also
-// be needed by pt-lvalue, which calls subsref?)
+  // Final step of processing an indexing error.  Add the name of the
+  // variable being indexed, if any, then issue an error.  (Will this also
+  // be needed by pt-lvalue, which calls subsref?)
 
-static void
-final_index_error (octave::index_exception& e,
-                   const octave::tree_expression *expr)
-{
-  std::string extra_message;
+  static void
+  final_index_error (octave::index_exception& e,
+                     const octave::tree_expression *expr)
+  {
+    std::string extra_message;
 
-  octave::symbol_table& symtab = octave::__get_symbol_table__ ("final_index_error");
-
-  octave::symbol_record::context_id context = symtab.current_context ();
+    octave::symbol_table& symtab
+      = octave::__get_symbol_table__ ("final_index_error");
 
-  if (expr->is_identifier ()
-      && dynamic_cast<const octave::tree_identifier *> (expr)->is_variable (context))
-    {
-      std::string var = expr->name ();
+    octave::symbol_record::context_id context = symtab.current_context ();
 
-      e.set_var (var);
-
-      octave_value fcn = symtab.find_function (var);
+    if (expr->is_identifier ()
+        && dynamic_cast<const octave::tree_identifier *> (expr)->is_variable (context))
+      {
+        std::string var = expr->name ();
 
-      if (fcn.is_function ())
-        {
-          octave_function *fp = fcn.function_value ();
+        e.set_var (var);
+
+        octave_value fcn = symtab.find_function (var);
 
-          if (fp && fp->name () == var)
-            extra_message = " (note: variable '" + var + "' shadows function)";
-        }
-    }
+        if (fcn.is_function ())
+          {
+            octave_function *fp = fcn.function_value ();
 
-  std::string msg = e.message () + extra_message;
+            if (fp && fp->name () == var)
+              extra_message = " (note: variable '" + var + "' shadows function)";
+          }
+      }
 
-  error_with_id (e.err_id (), msg.c_str ());
-}
+    std::string msg = e.message () + extra_message;
 
-namespace octave
-{
+    error_with_id (e.err_id (), msg.c_str ());
+  }
+
   octave_lvalue
   tree_index_expression::lvalue (tree_evaluator *tw)
   {
     octave_lvalue retval;
 
     std::list<octave_value_list> idx;
     std::string tmp_type;
 
