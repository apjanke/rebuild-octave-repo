# HG changeset patch
# User Rik <rik@octave.org>
# Date 1382839025 25200
#      Sat Oct 26 18:57:05 2013 -0700
# Node ID 49a5a4be04a1c8a27201b034abc1d6e4443b3bbb
# Parent  271c0cce0f6459e1f5ab1aa7111e5e296da566ee
maint: Use GNU style coding conventions for code in liboctave/


* liboctave/array/Array-C.cc, liboctave/array/Array-b.cc,
liboctave/array/Array-ch.cc, liboctave/array/Array-d.cc,
liboctave/array/Array-f.cc, liboctave/array/Array-fC.cc,
liboctave/array/Array-util.cc, liboctave/array/Array-util.h,
liboctave/array/Array.cc, liboctave/array/Array.h, liboctave/array/Array3.h,
liboctave/array/CColVector.cc, liboctave/array/CColVector.h,
liboctave/array/CDiagMatrix.cc, liboctave/array/CDiagMatrix.h,
liboctave/array/CMatrix.cc, liboctave/array/CMatrix.h,
liboctave/array/CNDArray.cc, liboctave/array/CNDArray.h,
liboctave/array/CRowVector.cc, liboctave/array/CRowVector.h,
liboctave/array/CSparse.cc, liboctave/array/CSparse.h,
liboctave/array/DiagArray2.h, liboctave/array/MArray.cc,
liboctave/array/MArray.h, liboctave/array/MDiagArray2.cc,
liboctave/array/MDiagArray2.h, liboctave/array/MSparse.cc,
liboctave/array/MSparse.h, liboctave/array/MatrixType.cc,
liboctave/array/MatrixType.h, liboctave/array/PermMatrix.h,
liboctave/array/Range.cc, liboctave/array/Range.h, liboctave/array/Sparse.cc,
liboctave/array/Sparse.h, liboctave/array/boolMatrix.cc,
liboctave/array/boolMatrix.h, liboctave/array/boolNDArray.cc,
liboctave/array/boolNDArray.h, liboctave/array/boolSparse.cc,
liboctave/array/boolSparse.h, liboctave/array/chMatrix.cc,
liboctave/array/chMatrix.h, liboctave/array/chNDArray.cc,
liboctave/array/chNDArray.h, liboctave/array/dColVector.h,
liboctave/array/dDiagMatrix.cc, liboctave/array/dDiagMatrix.h,
liboctave/array/dMatrix.cc, liboctave/array/dMatrix.h,
liboctave/array/dNDArray.cc, liboctave/array/dNDArray.h,
liboctave/array/dRowVector.h, liboctave/array/dSparse.cc,
liboctave/array/dSparse.h, liboctave/array/dim-vector.cc,
liboctave/array/dim-vector.h, liboctave/array/fCColVector.cc,
liboctave/array/fCColVector.h, liboctave/array/fCDiagMatrix.cc,
liboctave/array/fCDiagMatrix.h, liboctave/array/fCMatrix.cc,
liboctave/array/fCMatrix.h, liboctave/array/fCNDArray.cc,
liboctave/array/fCNDArray.h, liboctave/array/fCRowVector.cc,
liboctave/array/fCRowVector.h, liboctave/array/fColVector.h,
liboctave/array/fDiagMatrix.cc, liboctave/array/fDiagMatrix.h,
liboctave/array/fMatrix.cc, liboctave/array/fMatrix.h,
liboctave/array/fNDArray.cc, liboctave/array/fNDArray.h,
liboctave/array/fRowVector.h, liboctave/array/idx-vector.cc,
liboctave/array/idx-vector.h, liboctave/array/intNDArray.cc,
liboctave/array/intNDArray.h, liboctave/cruft/misc/blaswrap.c,
liboctave/cruft/misc/quit.cc, liboctave/numeric/CmplxCHOL.cc,
liboctave/numeric/CmplxCHOL.h, liboctave/numeric/CmplxGEPBAL.cc,
liboctave/numeric/CmplxGEPBAL.h, liboctave/numeric/CmplxHESS.h,
liboctave/numeric/CmplxLU.cc, liboctave/numeric/CmplxLU.h,
liboctave/numeric/CmplxQR.cc, liboctave/numeric/CmplxQRP.cc,
liboctave/numeric/CmplxQRP.h, liboctave/numeric/CmplxSCHUR.h,
liboctave/numeric/CmplxSVD.cc, liboctave/numeric/CmplxSVD.h,
liboctave/numeric/CollocWt.h, liboctave/numeric/DAE.h,
liboctave/numeric/DAEFunc.h, liboctave/numeric/DAERT.h,
liboctave/numeric/DAERTFunc.h, liboctave/numeric/DASPK.cc,
liboctave/numeric/DASRT.cc, liboctave/numeric/DASRT.h,
liboctave/numeric/DASSL.cc, liboctave/numeric/DET.h, liboctave/numeric/EIG.cc,
liboctave/numeric/EIG.h, liboctave/numeric/LSODE.cc, liboctave/numeric/ODE.h,
liboctave/numeric/ODEFunc.h, liboctave/numeric/ODES.h,
liboctave/numeric/ODESFunc.h, liboctave/numeric/Quad.cc,
liboctave/numeric/Quad.h, liboctave/numeric/SparseCmplxCHOL.h,
liboctave/numeric/SparseCmplxLU.cc, liboctave/numeric/SparseCmplxLU.h,
liboctave/numeric/SparseCmplxQR.cc, liboctave/numeric/SparseCmplxQR.h,
liboctave/numeric/SparseQR.cc, liboctave/numeric/SparseQR.h,
liboctave/numeric/SparsedbleCHOL.h, liboctave/numeric/SparsedbleLU.cc,
liboctave/numeric/SparsedbleLU.h, liboctave/numeric/base-aepbal.h,
liboctave/numeric/base-dae.h, liboctave/numeric/base-de.h,
liboctave/numeric/base-lu.cc, liboctave/numeric/base-lu.h,
liboctave/numeric/base-min.h, liboctave/numeric/base-qr.h,
liboctave/numeric/bsxfun.h, liboctave/numeric/dbleCHOL.cc,
liboctave/numeric/dbleCHOL.h, liboctave/numeric/dbleGEPBAL.h,
liboctave/numeric/dbleHESS.h, liboctave/numeric/dbleLU.cc,
liboctave/numeric/dbleLU.h, liboctave/numeric/dbleQR.cc,
liboctave/numeric/dbleQRP.cc, liboctave/numeric/dbleQRP.h,
liboctave/numeric/dbleSCHUR.cc, liboctave/numeric/dbleSCHUR.h,
liboctave/numeric/dbleSVD.cc, liboctave/numeric/dbleSVD.h,
liboctave/numeric/eigs-base.cc, liboctave/numeric/fCmplxAEPBAL.cc,
liboctave/numeric/fCmplxAEPBAL.h, liboctave/numeric/fCmplxCHOL.cc,
liboctave/numeric/fCmplxCHOL.h, liboctave/numeric/fCmplxGEPBAL.cc,
liboctave/numeric/fCmplxGEPBAL.h, liboctave/numeric/fCmplxHESS.h,
liboctave/numeric/fCmplxLU.cc, liboctave/numeric/fCmplxLU.h,
liboctave/numeric/fCmplxQR.cc, liboctave/numeric/fCmplxQR.h,
liboctave/numeric/fCmplxQRP.cc, liboctave/numeric/fCmplxQRP.h,
liboctave/numeric/fCmplxSCHUR.cc, liboctave/numeric/fCmplxSCHUR.h,
liboctave/numeric/fCmplxSVD.h, liboctave/numeric/fEIG.cc,
liboctave/numeric/fEIG.h, liboctave/numeric/floatCHOL.cc,
liboctave/numeric/floatCHOL.h, liboctave/numeric/floatGEPBAL.cc,
liboctave/numeric/floatGEPBAL.h, liboctave/numeric/floatHESS.h,
liboctave/numeric/floatLU.cc, liboctave/numeric/floatLU.h,
liboctave/numeric/floatQR.cc, liboctave/numeric/floatQRP.cc,
liboctave/numeric/floatQRP.h, liboctave/numeric/floatSCHUR.cc,
liboctave/numeric/floatSCHUR.h, liboctave/numeric/floatSVD.cc,
liboctave/numeric/floatSVD.h, liboctave/numeric/lo-mappers.cc,
liboctave/numeric/lo-mappers.h, liboctave/numeric/lo-specfun.cc,
liboctave/numeric/lo-specfun.h, liboctave/numeric/oct-convn.cc,
liboctave/numeric/oct-fftw.cc, liboctave/numeric/oct-fftw.h,
liboctave/numeric/oct-norm.cc, liboctave/numeric/oct-rand.cc,
liboctave/numeric/oct-rand.h, liboctave/numeric/randgamma.c,
liboctave/numeric/randgamma.h, liboctave/numeric/randmtzig.c,
liboctave/numeric/randpoisson.c, liboctave/numeric/randpoisson.h,
liboctave/numeric/sparse-base-chol.h, liboctave/numeric/sparse-base-lu.h,
liboctave/numeric/sparse-dmsolve.cc, liboctave/operators/Sparse-diag-op-defs.h,
liboctave/operators/Sparse-op-defs.h, liboctave/operators/mx-inlines.cc,
liboctave/system/dir-ops.h, liboctave/system/file-ops.cc,
liboctave/system/file-stat.cc, liboctave/system/file-stat.h,
liboctave/system/lo-sysdep.cc, liboctave/system/lo-sysdep.h,
liboctave/system/mach-info.cc, liboctave/system/mach-info.h,
liboctave/system/oct-env.cc, liboctave/system/oct-group.cc,
liboctave/system/oct-syscalls.cc, liboctave/system/oct-syscalls.h,
liboctave/system/oct-time.h, liboctave/system/tempname.c,
liboctave/util/action-container.h, liboctave/util/base-list.h,
liboctave/util/cmd-edit.cc, liboctave/util/cmd-edit.h,
liboctave/util/cmd-hist.cc, liboctave/util/cmd-hist.h,
liboctave/util/data-conv.cc, liboctave/util/data-conv.h,
liboctave/util/kpse.cc, liboctave/util/lo-array-gripes.cc,
liboctave/util/lo-cieee.c, liboctave/util/lo-regexp.cc,
liboctave/util/lo-utils.cc, liboctave/util/oct-alloc.cc,
liboctave/util/oct-base64.cc, liboctave/util/oct-binmap.h,
liboctave/util/oct-cmplx.h, liboctave/util/oct-glob.cc,
liboctave/util/oct-inttypes.cc, liboctave/util/oct-inttypes.h,
liboctave/util/oct-locbuf.cc, liboctave/util/oct-locbuf.h,
liboctave/util/oct-mem.h, liboctave/util/oct-mutex.cc,
liboctave/util/oct-refcount.h, liboctave/util/oct-shlib.cc,
liboctave/util/oct-shlib.h, liboctave/util/oct-sort.cc,
liboctave/util/oct-sort.h, liboctave/util/pathsearch.cc,
liboctave/util/pathsearch.h, liboctave/util/sparse-util.cc,
liboctave/util/str-vec.cc, liboctave/util/str-vec.h,
liboctave/util/unwind-prot.h, liboctave/util/url-transfer.cc,
liboctave/util/url-transfer.h: Use GNU style coding conventions.

diff --git a/liboctave/array/Array-C.cc b/liboctave/array/Array-C.cc
--- a/liboctave/array/Array-C.cc
+++ b/liboctave/array/Array-C.cc
@@ -87,14 +87,15 @@ safe_comparator (sortmode mode, const Ar
 
   return result;
 }
 
 INSTANTIATE_ARRAY_SORT (Complex);
 
 INSTANTIATE_ARRAY (Complex, OCTAVE_API);
 
-template OCTAVE_API std::ostream& operator << (std::ostream&, const Array<Complex>&);
+template OCTAVE_API std::ostream& operator << (std::ostream&,
+                                               const Array<Complex>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class OCTAVE_API DiagArray2<Complex>;
diff --git a/liboctave/array/Array-b.cc b/liboctave/array/Array-b.cc
--- a/liboctave/array/Array-b.cc
+++ b/liboctave/array/Array-b.cc
@@ -102,14 +102,15 @@ octave_sort<bool>::sort (bool *data, oct
 {
   do_bool_partition<true> (data, idx, nel);
 }
 
 INSTANTIATE_ARRAY_SORT (bool);
 
 INSTANTIATE_ARRAY (bool, OCTAVE_API);
 
-template OCTAVE_API std::ostream& operator << (std::ostream&, const Array<bool>&);
+template OCTAVE_API std::ostream& operator << (std::ostream&,
+                                               const Array<bool>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class OCTAVE_API DiagArray2<bool>;
diff --git a/liboctave/array/Array-ch.cc b/liboctave/array/Array-ch.cc
--- a/liboctave/array/Array-ch.cc
+++ b/liboctave/array/Array-ch.cc
@@ -31,14 +31,15 @@ along with Octave; see the file COPYING.
 #define INLINE_ASCENDING_SORT
 #define INLINE_DESCENDING_SORT
 #include "oct-sort.cc"
 
 INSTANTIATE_ARRAY_SORT (char);
 
 INSTANTIATE_ARRAY (char, OCTAVE_API);
 
-template OCTAVE_API std::ostream& operator << (std::ostream&, const Array<char>&);
+template OCTAVE_API std::ostream& operator << (std::ostream&,
+                                               const Array<char>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class OCTAVE_API DiagArray2<char>;
diff --git a/liboctave/array/Array-d.cc b/liboctave/array/Array-d.cc
--- a/liboctave/array/Array-d.cc
+++ b/liboctave/array/Array-d.cc
@@ -154,14 +154,15 @@ Array<double>::is_sorted (sortmode mode)
 
   return mode;
 }
 
 INSTANTIATE_ARRAY_SORT (double);
 
 INSTANTIATE_ARRAY (double, OCTAVE_API);
 
-template OCTAVE_API std::ostream& operator << (std::ostream&, const Array<double>&);
+template OCTAVE_API std::ostream& operator << (std::ostream&,
+                                               const Array<double>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class OCTAVE_API DiagArray2<double>;
diff --git a/liboctave/array/Array-f.cc b/liboctave/array/Array-f.cc
--- a/liboctave/array/Array-f.cc
+++ b/liboctave/array/Array-f.cc
@@ -154,14 +154,15 @@ Array<float>::is_sorted (sortmode mode) 
 
   return mode;
 }
 
 INSTANTIATE_ARRAY_SORT (float);
 
 INSTANTIATE_ARRAY (float, OCTAVE_API);
 
-template OCTAVE_API std::ostream& operator << (std::ostream&, const Array<float>&);
+template OCTAVE_API std::ostream& operator << (std::ostream&,
+                                               const Array<float>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class OCTAVE_API DiagArray2<float>;
diff --git a/liboctave/array/Array-fC.cc b/liboctave/array/Array-fC.cc
--- a/liboctave/array/Array-fC.cc
+++ b/liboctave/array/Array-fC.cc
@@ -55,18 +55,17 @@ nan_descending_compare (const FloatCompl
 {
   return (xisnan (x)
           ? ! xisnan (y)
           : ((std::abs (x) > std::abs (x))
              || ((std::abs (x) == std::abs (x)) && (arg (x) > arg (x)))));
 }
 
 Array<FloatComplex>::compare_fcn_type
-safe_comparator (sortmode mode, const Array<FloatComplex>& a,
-                     bool allow_chk)
+safe_comparator (sortmode mode, const Array<FloatComplex>& a, bool allow_chk)
 {
   Array<FloatComplex>::compare_fcn_type result = 0;
 
   if (allow_chk)
     {
       octave_idx_type k = 0;
       for (; k < a.numel () && ! xisnan (a(k)); k++) ;
       if (k == a.numel ())
@@ -88,14 +87,15 @@ safe_comparator (sortmode mode, const Ar
 
   return result;
 }
 
 INSTANTIATE_ARRAY_SORT (FloatComplex);
 
 INSTANTIATE_ARRAY (FloatComplex, OCTAVE_API);
 
-template OCTAVE_API std::ostream& operator << (std::ostream&, const Array<FloatComplex>&);
+template OCTAVE_API std::ostream& operator << (std::ostream&,
+                                               const Array<FloatComplex>&);
 
 #include "DiagArray2.h"
 #include "DiagArray2.cc"
 
 template class OCTAVE_API DiagArray2<FloatComplex>;
diff --git a/liboctave/array/Array-util.cc b/liboctave/array/Array-util.cc
--- a/liboctave/array/Array-util.cc
+++ b/liboctave/array/Array-util.cc
@@ -242,17 +242,17 @@ conv_to_int_array (const Array<idx_vecto
 }
 
 Array<idx_vector>
 conv_to_array (const idx_vector *tmp, const octave_idx_type len)
 {
   Array<idx_vector> retval (dim_vector (len, 1));
 
   for (octave_idx_type i = 0; i < len; i++)
-      retval(i) = tmp[i];
+    retval(i) = tmp[i];
 
   return retval;
 }
 
 dim_vector
 freeze (Array<idx_vector>& ra_idx, const dim_vector& dimensions, int resize_ok)
 {
   dim_vector retval;
@@ -398,18 +398,17 @@ get_ra_idx (octave_idx_type idx, const d
   for (int i = 0; i < n_dims; i++)
     retval(i) = 0;
 
   assert (idx > 0 || idx < dims.numel ());
 
   for (octave_idx_type i = 0; i < idx; i++)
     increment_index (retval, dims);
 
-  // FIXME -- the solution using increment_index is not
-  // efficient.
+  // FIXME: the solution using increment_index is not efficient.
 
 #if 0
   octave_idx_type var = 1;
   for (int i = 0; i < n_dims; i++)
     {
       std::cout << "idx: " << idx << ", var: " << var
                 << ", dims(" << i << "): " << dims(i) <<"\n";
       retval(i) = ((int)floor(((idx) / (double)var))) % dims(i);
@@ -427,17 +426,17 @@ zero_dims_inquire (const Array<idx_vecto
   int ial = ia.length (), rhdvl = rhdv.length ();
   dim_vector rdv = dim_vector::alloc (ial);
   bool *scalar = new bool [ial], *colon = new bool [ial];
   // Mark scalars and colons, count non-scalar indices.
   int nonsc = 0;
   bool all_colons = true;
   for (int i = 0; i < ial; i++)
     {
-      // FIXME -- should we check for length() instead?
+      // FIXME: should we check for length() instead?
       scalar[i] = ia(i).is_scalar ();
       colon[i] = ia(i).is_colon ();
       if (! scalar[i]) nonsc++;
       if (! colon[i]) rdv(i) = ia(i).extent (0);
       all_colons = all_colons && colon[i];
     }
 
   // If the number of nonscalar indices matches the dimensionality of
diff --git a/liboctave/array/Array-util.h b/liboctave/array/Array-util.h
--- a/liboctave/array/Array-util.h
+++ b/liboctave/array/Array-util.h
@@ -24,25 +24,27 @@ along with Octave; see the file COPYING.
 #define octave_Array_util_h 1
 
 #include "Array.h"
 #include "dim-vector.h"
 #include "idx-vector.h"
 #include "lo-array-gripes.h"
 
 extern OCTAVE_API bool index_in_bounds (const Array<octave_idx_type>& ra_idx,
-                             const dim_vector& dimensions);
+                                        const dim_vector& dimensions);
 
 extern OCTAVE_API void increment_index (Array<octave_idx_type>& ra_idx,
-                             const dim_vector& dimensions,
-                             int start_dimension = 0);
+                                        const dim_vector& dimensions,
+                                        int start_dimension = 0);
 
-extern OCTAVE_API octave_idx_type get_scalar_idx (Array<octave_idx_type>& idx, dim_vector& dims);
+extern OCTAVE_API octave_idx_type get_scalar_idx (Array<octave_idx_type>& idx,
+                                                  dim_vector& dims);
 
-extern OCTAVE_API octave_idx_type num_ones (const Array<octave_idx_type>& ra_idx);
+extern OCTAVE_API octave_idx_type num_ones (const Array<octave_idx_type>&
+                                            ra_idx);
 
 extern OCTAVE_API bool is_scalar (const dim_vector& dim);
 
 extern OCTAVE_API bool is_vector (const dim_vector& dim);
 
 extern OCTAVE_API bool any_ones (const Array<octave_idx_type>& arr);
 
 // These four compute a linear index for given dimensions, throwing
@@ -55,48 +57,56 @@ compute_index (octave_idx_type i, octave
 
 extern OCTAVE_API octave_idx_type
 compute_index (octave_idx_type i, octave_idx_type j, octave_idx_type k,
                const dim_vector& dims);
 
 extern OCTAVE_API octave_idx_type
 compute_index (const Array<octave_idx_type>& ra_idx, const dim_vector& dims);
 
-extern OCTAVE_API Array<octave_idx_type> conv_to_int_array (const Array<idx_vector>& a);
+extern OCTAVE_API Array<octave_idx_type>
+conv_to_int_array (const Array<idx_vector>& a);
 
-extern OCTAVE_API Array<idx_vector> conv_to_array (const idx_vector *tmp, const octave_idx_type len);
+extern OCTAVE_API Array<idx_vector> conv_to_array (const idx_vector *tmp,
+                                                   const octave_idx_type len);
 
 extern OCTAVE_API dim_vector freeze (Array<idx_vector>& ra_idx,
-                          const dim_vector& dimensions, int resize_ok);
+                                     const dim_vector& dimensions,
+                                     int resize_ok);
 
 extern OCTAVE_API bool vector_equivalent (const dim_vector& dv);
 
 extern OCTAVE_API bool all_ok (const Array<idx_vector>& ra_idx);
 
 extern OCTAVE_API bool any_orig_empty (const Array<idx_vector>& ra_idx);
 
 extern OCTAVE_API bool all_colon_equiv (const Array<idx_vector>& ra_idx,
-                             const dim_vector& frozen_lengths);
+                                        const dim_vector& frozen_lengths);
 
 extern OCTAVE_API bool all_ones (const Array<octave_idx_type>& arr);
 
-extern OCTAVE_API Array<octave_idx_type> get_elt_idx (const Array<idx_vector>& ra_idx,
-                               const Array<octave_idx_type>& result_idx);
+extern OCTAVE_API Array<octave_idx_type>
+get_elt_idx (const Array<idx_vector>& ra_idx,
+             const Array<octave_idx_type>& result_idx);
 
-extern OCTAVE_API Array<octave_idx_type> get_ra_idx (octave_idx_type idx, const dim_vector& dims);
+extern OCTAVE_API Array<octave_idx_type> get_ra_idx (octave_idx_type idx,
+                                                     const dim_vector& dims);
 
 extern OCTAVE_API dim_vector zero_dims_inquire (const Array<idx_vector>& ia,
                                                 const dim_vector& rhdv);
 
-extern OCTAVE_API dim_vector zero_dims_inquire (const idx_vector& i, const idx_vector& j,
+extern OCTAVE_API dim_vector zero_dims_inquire (const idx_vector& i,
+                                                const idx_vector& j,
                                                 const dim_vector& rhdv);
 
-extern OCTAVE_API idx_vector sub2ind (const dim_vector& dv, const Array<idx_vector>& idxa);
+extern OCTAVE_API idx_vector sub2ind (const dim_vector& dv,
+                                      const Array<idx_vector>& idxa);
 
-extern OCTAVE_API Array<idx_vector> ind2sub (const dim_vector& dv, const idx_vector& idx);
+extern OCTAVE_API Array<idx_vector> ind2sub (const dim_vector& dv,
+                                             const idx_vector& idx);
 
 struct
 permute_vector
 {
   octave_idx_type pidx;
   octave_idx_type iidx;
 };
 
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -166,17 +166,18 @@ template <class T>
 octave_idx_type
 Array<T>::compute_index (octave_idx_type i, octave_idx_type j) const
 {
   return ::compute_index (i, j, dimensions);
 }
 
 template <class T>
 octave_idx_type
-Array<T>::compute_index (octave_idx_type i, octave_idx_type j, octave_idx_type k) const
+Array<T>::compute_index (octave_idx_type i, octave_idx_type j,
+                         octave_idx_type k) const
 {
   return ::compute_index (i, j, k, dimensions);
 }
 
 template <class T>
 octave_idx_type
 Array<T>::compute_index (const Array<octave_idx_type>& ra_idx) const
 {
@@ -234,17 +235,18 @@ template <class T>
 typename Array<T>::crefT
 Array<T>::checkelem (octave_idx_type i, octave_idx_type j) const
 {
   return elem (compute_index (i, j));
 }
 
 template <class T>
 typename Array<T>::crefT
-Array<T>::checkelem (octave_idx_type i, octave_idx_type j, octave_idx_type k) const
+Array<T>::checkelem (octave_idx_type i, octave_idx_type j,
+                     octave_idx_type k) const
 {
   return elem (compute_index (i, j, k));
 }
 
 template <class T>
 typename Array<T>::crefT
 Array<T>::checkelem (const Array<octave_idx_type>& ra_idx) const
 {
@@ -303,124 +305,124 @@ class rec_permute_helper
   octave_idx_type *stride;
   bool use_blk;
 
 public:
   rec_permute_helper (const dim_vector& dv, const Array<octave_idx_type>& perm)
 
     : n (dv.length ()), top (0), dim (new octave_idx_type [2*n]),
       stride (dim + n), use_blk (false)
-    {
-      assert (n == perm.length ());
-
-      // Get cumulative dimensions.
-      OCTAVE_LOCAL_BUFFER (octave_idx_type, cdim, n+1);
-      cdim[0] = 1;
-      for (int i = 1; i < n+1; i++) cdim[i] = cdim[i-1] * dv(i-1);
-
-      // Setup the permuted strides.
-      for (int k = 0; k < n; k++)
-        {
-          int kk = perm(k);
-          dim[k] = dv(kk);
-          stride[k] = cdim[kk];
-        }
-
-      // Reduce contiguous runs.
-      for (int k = 1; k < n; k++)
-        {
-          if (stride[k] == stride[top]*dim[top])
-            dim[top] *= dim[k];
-          else
-            {
-              top++;
-              dim[top] = dim[k];
-              stride[top] = stride[k];
-            }
-        }
-
-      // Determine whether we can use block transposes.
-      use_blk = top >= 1 && stride[1] == 1 && stride[0] == dim[1];
-
-    }
+  {
+    assert (n == perm.length ());
+
+    // Get cumulative dimensions.
+    OCTAVE_LOCAL_BUFFER (octave_idx_type, cdim, n+1);
+    cdim[0] = 1;
+    for (int i = 1; i < n+1; i++) cdim[i] = cdim[i-1] * dv(i-1);
+
+    // Setup the permuted strides.
+    for (int k = 0; k < n; k++)
+      {
+        int kk = perm(k);
+        dim[k] = dv(kk);
+        stride[k] = cdim[kk];
+      }
+
+    // Reduce contiguous runs.
+    for (int k = 1; k < n; k++)
+      {
+        if (stride[k] == stride[top]*dim[top])
+          dim[top] *= dim[k];
+        else
+          {
+            top++;
+            dim[top] = dim[k];
+            stride[top] = stride[k];
+          }
+      }
+
+    // Determine whether we can use block transposes.
+    use_blk = top >= 1 && stride[1] == 1 && stride[0] == dim[1];
+
+  }
 
   ~rec_permute_helper (void) { delete [] dim; }
 
   // Helper method for fast blocked transpose.
   template <class T>
   static T *
   blk_trans (const T *src, T *dest, octave_idx_type nr, octave_idx_type nc)
-    {
-      static const octave_idx_type m = 8;
-      OCTAVE_LOCAL_BUFFER (T, blk, m*m);
-      for (octave_idx_type kr = 0; kr < nr; kr += m)
-        for (octave_idx_type kc = 0; kc < nc; kc += m)
-          {
-            octave_idx_type lr = std::min (m, nr - kr);
-            octave_idx_type lc = std::min (m, nc - kc);
-            if (lr == m && lc == m)
-              {
-                const T *ss = src + kc * nr + kr;
-                for (octave_idx_type j = 0; j < m; j++)
-                  for (octave_idx_type i = 0; i < m; i++)
-                    blk[j*m+i] = ss[j*nr + i];
-                T *dd = dest + kr * nc + kc;
-                for (octave_idx_type j = 0; j < m; j++)
-                  for (octave_idx_type i = 0; i < m; i++)
-                    dd[j*nc+i] = blk[i*m+j];
-              }
-            else
-              {
-                const T *ss = src + kc * nr + kr;
-                for (octave_idx_type j = 0; j < lc; j++)
-                  for (octave_idx_type i = 0; i < lr; i++)
-                    blk[j*m+i] = ss[j*nr + i];
-                T *dd = dest + kr * nc + kc;
-                for (octave_idx_type j = 0; j < lr; j++)
-                  for (octave_idx_type i = 0; i < lc; i++)
-                    dd[j*nc+i] = blk[i*m+j];
-              }
-          }
-
-      return dest + nr*nc;
-    }
+  {
+    static const octave_idx_type m = 8;
+    OCTAVE_LOCAL_BUFFER (T, blk, m*m);
+    for (octave_idx_type kr = 0; kr < nr; kr += m)
+      for (octave_idx_type kc = 0; kc < nc; kc += m)
+        {
+          octave_idx_type lr = std::min (m, nr - kr);
+          octave_idx_type lc = std::min (m, nc - kc);
+          if (lr == m && lc == m)
+            {
+              const T *ss = src + kc * nr + kr;
+              for (octave_idx_type j = 0; j < m; j++)
+                for (octave_idx_type i = 0; i < m; i++)
+                  blk[j*m+i] = ss[j*nr + i];
+              T *dd = dest + kr * nc + kc;
+              for (octave_idx_type j = 0; j < m; j++)
+                for (octave_idx_type i = 0; i < m; i++)
+                  dd[j*nc+i] = blk[i*m+j];
+            }
+          else
+            {
+              const T *ss = src + kc * nr + kr;
+              for (octave_idx_type j = 0; j < lc; j++)
+                for (octave_idx_type i = 0; i < lr; i++)
+                  blk[j*m+i] = ss[j*nr + i];
+              T *dd = dest + kr * nc + kc;
+              for (octave_idx_type j = 0; j < lr; j++)
+                for (octave_idx_type i = 0; i < lc; i++)
+                  dd[j*nc+i] = blk[i*m+j];
+            }
+        }
+
+    return dest + nr*nc;
+  }
 
 private:
 
   // Recursive N-d generalized transpose
   template <class T>
   T *do_permute (const T *src, T *dest, int lev) const
-    {
-      if (lev == 0)
-        {
-          octave_idx_type step = stride[0], len = dim[0];
-          if (step == 1)
-            {
-              copy_or_memcpy (len, src, dest);
-              dest += len;
-            }
-          else
-            {
-              for (octave_idx_type i = 0, j = 0; i < len; i++, j += step)
-                dest[i] = src[j];
-
-              dest += len;
-            }
-        }
-      else if (use_blk && lev == 1)
-        dest = blk_trans (src, dest, dim[1], dim[0]);
-      else
-        {
-          octave_idx_type step = stride[lev], len = dim[lev];
-          for (octave_idx_type i = 0, j = 0; i < len; i++, j+= step)
-           dest = do_permute (src + i * step, dest, lev-1);
-        }
-
-      return dest;
-    }
+  {
+    if (lev == 0)
+      {
+        octave_idx_type step = stride[0], len = dim[0];
+        if (step == 1)
+          {
+            copy_or_memcpy (len, src, dest);
+            dest += len;
+          }
+        else
+          {
+            for (octave_idx_type i = 0, j = 0; i < len; i++, j += step)
+              dest[i] = src[j];
+
+            dest += len;
+          }
+      }
+    else if (use_blk && lev == 1)
+      dest = blk_trans (src, dest, dim[1], dim[0]);
+    else
+      {
+        octave_idx_type step = stride[lev], len = dim[lev];
+        for (octave_idx_type i = 0, j = 0; i < len; i++, j+= step)
+          dest = do_permute (src + i * step, dest, lev-1);
+      }
+
+    return dest;
+  }
 
   // No copying!
 
   rec_permute_helper (const rec_permute_helper&);
 
   rec_permute_helper& operator = (const rec_permute_helper&);
 
 public:
@@ -523,91 +525,91 @@ class rec_index_helper
   octave_idx_type *dim;
   octave_idx_type *cdim;
   idx_vector *idx;
 
 public:
   rec_index_helper (const dim_vector& dv, const Array<idx_vector>& ia)
     : n (ia.length ()), top (0), dim (new octave_idx_type [2*n]),
       cdim (dim + n), idx (new idx_vector [n])
-    {
-      assert (n > 0 && (dv.length () == std::max (n, 2)));
-
-      dim[0] = dv(0);
-      cdim[0] = 1;
-      idx[0] = ia(0);
-
-      for (int i = 1; i < n; i++)
-        {
-          // Try reduction...
-          if (idx[top].maybe_reduce (dim[top], ia(i), dv(i)))
-            {
-              // Reduction successful, fold dimensions.
-              dim[top] *= dv(i);
-            }
-          else
-            {
-              // Unsuccessful, store index & cumulative dim.
-              top++;
-              idx[top] = ia(i);
-              dim[top] = dv(i);
-              cdim[top] = cdim[top-1] * dim[top-1];
-            }
-        }
-    }
+  {
+    assert (n > 0 && (dv.length () == std::max (n, 2)));
+
+    dim[0] = dv(0);
+    cdim[0] = 1;
+    idx[0] = ia(0);
+
+    for (int i = 1; i < n; i++)
+      {
+        // Try reduction...
+        if (idx[top].maybe_reduce (dim[top], ia(i), dv(i)))
+          {
+            // Reduction successful, fold dimensions.
+            dim[top] *= dv(i);
+          }
+        else
+          {
+            // Unsuccessful, store index & cumulative dim.
+            top++;
+            idx[top] = ia(i);
+            dim[top] = dv(i);
+            cdim[top] = cdim[top-1] * dim[top-1];
+          }
+      }
+  }
 
   ~rec_index_helper (void) { delete [] idx; delete [] dim; }
 
 private:
 
   // Recursive N-d indexing
   template <class T>
   T *do_index (const T *src, T *dest, int lev) const
-    {
-      if (lev == 0)
-        dest += idx[0].index (src, dim[0], dest);
-      else
-        {
-          octave_idx_type nn = idx[lev].length (dim[lev]), d = cdim[lev];
-          for (octave_idx_type i = 0; i < nn; i++)
-            dest = do_index (src + d*idx[lev].xelem (i), dest, lev-1);
-        }
-
-      return dest;
-    }
+  {
+    if (lev == 0)
+      dest += idx[0].index (src, dim[0], dest);
+    else
+      {
+        octave_idx_type nn = idx[lev].length (dim[lev]), d = cdim[lev];
+        for (octave_idx_type i = 0; i < nn; i++)
+          dest = do_index (src + d*idx[lev].xelem (i), dest, lev-1);
+      }
+
+    return dest;
+  }
 
   // Recursive N-d indexed assignment
   template <class T>
   const T *do_assign (const T *src, T *dest, int lev) const
-    {
-      if (lev == 0)
-        src += idx[0].assign (src, dim[0], dest);
-      else
-        {
-          octave_idx_type nn = idx[lev].length (dim[lev]), d = cdim[lev];
-          for (octave_idx_type i = 0; i < nn; i++)
-            src = do_assign (src, dest + d*idx[lev].xelem (i), lev-1);
-        }
-
-      return src;
-    }
+  {
+    if (lev == 0)
+      src += idx[0].assign (src, dim[0], dest);
+    else
+      {
+        octave_idx_type nn = idx[lev].length (dim[lev]), d = cdim[lev];
+        for (octave_idx_type i = 0; i < nn; i++)
+          src = do_assign (src, dest + d*idx[lev].xelem (i), lev-1);
+      }
+
+    return src;
+  }
 
   // Recursive N-d indexed assignment
   template <class T>
   void do_fill (const T& val, T *dest, int lev) const
-    {
-      if (lev == 0)
-        idx[0].fill (val, dim[0], dest);
-      else
-        {
-          octave_idx_type nn = idx[lev].length (dim[lev]), d = cdim[lev];
-          for (octave_idx_type i = 0; i < nn; i++)
-            do_fill (val, dest + d*idx[lev].xelem (i), lev-1);
-        }
-    }
+  {
+    if (lev == 0)
+      idx[0].fill (val, dim[0], dest);
+    else
+      {
+        octave_idx_type nn = idx[lev].length (dim[lev]), d = cdim[lev];
+        for (octave_idx_type i = 0; i < nn; i++)
+          do_fill (val, dest + d*idx[lev].xelem (i), lev-1);
+      }
+  }
 
   // No copying!
 
   rec_index_helper (const rec_index_helper&);
 
   rec_index_helper& operator = (const rec_index_helper&);
 
 public:
@@ -617,91 +619,91 @@ public:
 
   template <class T>
   void assign (const T *src, T *dest) const { do_assign (src, dest, top); }
 
   template <class T>
   void fill (const T& val, T *dest) const { do_fill (val, dest, top); }
 
   bool is_cont_range (octave_idx_type& l,
-                            octave_idx_type& u) const
-    {
-      return top == 0 && idx[0].is_cont_range (dim[0], l, u);
-    }
+                      octave_idx_type& u) const
+  {
+    return top == 0 && idx[0].is_cont_range (dim[0], l, u);
+  }
 };
 
 // Helper class for multi-d recursive resizing
 // This handles resize () in an efficient manner, touching memory only
 // once (apart from reinitialization)
 class rec_resize_helper
 {
   octave_idx_type *cext;
   octave_idx_type *sext;
   octave_idx_type *dext;
   int n;
 
 public:
   rec_resize_helper (const dim_vector& ndv, const dim_vector& odv)
     : cext (0), sext (0), dext (0), n (0)
-    {
-      int l = ndv.length ();
-      assert (odv.length () == l);
-      octave_idx_type ld = 1;
-      int i = 0;
-      for (; i < l-1 && ndv(i) == odv(i); i++) ld *= ndv(i);
-      n = l - i;
-      cext = new octave_idx_type [3*n];
-      // Trick to avoid three allocations
-      sext = cext + n;
-      dext = sext + n;
-
-      octave_idx_type sld = ld, dld = ld;
-      for (int j = 0; j < n; j++)
-        {
-          cext[j] = std::min (ndv(i+j), odv(i+j));
-          sext[j] = sld *= odv(i+j);
-          dext[j] = dld *= ndv(i+j);
-        }
-      cext[0] *= ld;
-    }
+  {
+    int l = ndv.length ();
+    assert (odv.length () == l);
+    octave_idx_type ld = 1;
+    int i = 0;
+    for (; i < l-1 && ndv(i) == odv(i); i++) ld *= ndv(i);
+    n = l - i;
+    cext = new octave_idx_type [3*n];
+    // Trick to avoid three allocations
+    sext = cext + n;
+    dext = sext + n;
+
+    octave_idx_type sld = ld, dld = ld;
+    for (int j = 0; j < n; j++)
+      {
+        cext[j] = std::min (ndv(i+j), odv(i+j));
+        sext[j] = sld *= odv(i+j);
+        dext[j] = dld *= ndv(i+j);
+      }
+    cext[0] *= ld;
+  }
 
   ~rec_resize_helper (void) { delete [] cext; }
 
 private:
 
   // recursive resizing
   template <class T>
   void do_resize_fill (const T* src, T *dest, const T& rfv, int lev) const
-    {
-      if (lev == 0)
-        {
-          copy_or_memcpy (cext[0], src, dest);
-          fill_or_memset (dext[0] - cext[0], rfv, dest + cext[0]);
-        }
-      else
-        {
-          octave_idx_type sd = sext[lev-1], dd = dext[lev-1], k;
-          for (k = 0; k < cext[lev]; k++)
-            do_resize_fill (src + k * sd, dest + k * dd, rfv, lev - 1);
-
-          fill_or_memset (dext[lev] - k * dd, rfv, dest + k * dd);
-        }
-    }
+  {
+    if (lev == 0)
+      {
+        copy_or_memcpy (cext[0], src, dest);
+        fill_or_memset (dext[0] - cext[0], rfv, dest + cext[0]);
+      }
+    else
+      {
+        octave_idx_type sd = sext[lev-1], dd = dext[lev-1], k;
+        for (k = 0; k < cext[lev]; k++)
+          do_resize_fill (src + k * sd, dest + k * dd, rfv, lev - 1);
+
+        fill_or_memset (dext[lev] - k * dd, rfv, dest + k * dd);
+      }
+  }
 
   // No copying!
 
   rec_resize_helper (const rec_resize_helper&);
 
   rec_resize_helper& operator = (const rec_resize_helper&);
 
 public:
 
   template <class T>
   void resize_fill (const T* src, T *dest, const T& rfv) const
-    { do_resize_fill (src, dest, rfv, n-1); }
+  { do_resize_fill (src, dest, rfv, n-1); }
 };
 
 template <class T>
 Array<T>
 Array<T>::index (const idx_vector& i) const
 {
   octave_idx_type n = numel ();
   Array<T> retval;
@@ -711,21 +713,21 @@ Array<T>::index (const idx_vector& i) co
       // A(:) produces a shallow copy as a column vector.
       retval = Array<T> (*this, dim_vector (n, 1));
     }
   else
     {
       if (i.extent (n) != n)
         gripe_index_out_of_range (1, 1, i.extent (n), n); // throws
 
-      // FIXME -- this is the only place where orig_dimensions are used.
+      // FIXME: this is the only place where orig_dimensions are used.
       dim_vector rd = i.orig_dimensions ();
       octave_idx_type il = i.length (n);
 
-      // FIXME -- this is for Matlab compatibility.  Matlab 2007 given
+      // FIXME: this is for Matlab compatibility.  Matlab 2007 given
       //
       //   b = ones (3,1)
       //
       // yields the following:
       //
       //   b(zeros (0,0)) gives []
       //   b(zeros (1,0)) gives zeros (0,1)
       //   b(zeros (0,1)) gives zeros (0,1)
@@ -791,25 +793,25 @@ Array<T>::index (const idx_vector& i, co
       if (ii.maybe_reduce (r, j, c))
         {
           octave_idx_type l, u;
           if (ii.length () > 0 && ii.is_cont_range (n, l, u))
             // If suitable, produce a shallow slice.
             retval = Array<T> (*this, dim_vector (il, jl), l, u);
           else
             {
-              // Don't use resize here to avoid useless initialization for POD types.
+              // Don't use resize to avoid useless initialization for POD types.
               retval = Array<T> (dim_vector (il, jl));
 
               ii.index (data (), n, retval.fortran_vec ());
             }
         }
       else
         {
-          // Don't use resize here to avoid useless initialization for POD types.
+          // Don't use resize to avoid useless initialization for POD types.
           retval = Array<T> (dim_vector (il, jl));
 
           const T* src = data ();
           T *dest = retval.fortran_vec ();
 
           for (octave_idx_type k = 0; k < jl; k++)
             dest += i.index (src + r * j.xelem (k), r, dest);
         }
@@ -863,17 +865,17 @@ Array<T>::index (const Array<idx_vector>
           rec_index_helper rh (dv, ia);
 
           octave_idx_type l, u;
           if (rh.is_cont_range (l, u))
             // If suitable, produce a shallow slice.
             retval = Array<T> (*this, rdv, l, u);
           else
             {
-              // Don't use resize here to avoid useless initialization for POD types.
+              // Don't use resize to avoid useless initialization for POD types.
               retval = Array<T> (rdv);
 
               // Do it.
               rh.index (data (), retval.fortran_vec ());
             }
         }
     }
 
@@ -908,17 +910,17 @@ Array<T>::resize1 (octave_idx_type n, co
       // much more sense (given the way trailing singleton dims are
       // treated).
       bool invalid = false;
       if (rows () == 0 || rows () == 1)
         dv = dim_vector (1, n);
       else if (columns () == 1)
         dv = dim_vector (n, 1);
       else
-         invalid = true;
+        invalid = true;
 
       if (invalid)
         gripe_invalid_resize ();
       else
         {
           octave_idx_type nx = numel ();
           if (n == nx - 1 && n > 0)
             {
@@ -926,17 +928,18 @@ Array<T>::resize1 (octave_idx_type n, co
               if (rep->count == 1)
                 slice_data[slice_len-1] = T ();
               slice_len--;
               dimensions = dv;
             }
           else if (n == nx + 1 && nx > 0)
             {
               // Stack "push" operation.
-              if (rep->count == 1 && slice_data + slice_len < rep->data + rep->len)
+              if (rep->count == 1
+                  && slice_data + slice_len < rep->data + rep->len)
                 {
                   slice_data[slice_len++] = rfv;
                   dimensions = dv;
                 }
               else
                 {
                   static const octave_idx_type max_stack_chunk = 1024;
                   octave_idx_type nn = n + std::min (nx, max_stack_chunk);
@@ -2157,17 +2160,18 @@ Array<T>::lookup (const Array<T>& values
       if (n > 1 && lsort.descending_compare (elem (0), elem (n-1)))
         mode = DESCENDING;
       else
         mode = ASCENDING;
     }
 
   lsort.set_compare (mode);
 
-  // This determines the split ratio between the O(M*log2(N)) and O(M+N) algorithms.
+  // This determines the split ratio between the O(M*log2(N)) and O(M+N)
+  // algorithms.
   static const double ratio = 1.0;
   sortmode vmode = UNSORTED;
 
   // Attempt the O(M+N) algorithm if M is large enough.
   if (nval > ratio * n / xlog2 (n + 1.0))
     {
       vmode = values.is_sorted ();
       // The table must not contain a NaN.
@@ -2227,34 +2231,34 @@ Array<T>::find (octave_idx_type n, bool 
       // needed.
       retval.clear (n, 1);
       if (backward)
         {
           // Do the search as a series of successive single-element searches.
           octave_idx_type k = 0, l = nel - 1;
           for (; k < n; k++)
             {
-              for (;l >= 0 && src[l] == zero; l--) ;
+              for (; l >= 0 && src[l] == zero; l--) ;
               if (l >= 0)
                 retval(k) = l--;
               else
                 break;
             }
           if (k < n)
             retval.resize2 (k, 1);
           octave_idx_type *rdata = retval.fortran_vec ();
           std::reverse (rdata, rdata + k);
         }
       else
         {
           // Do the search as a series of successive single-element searches.
           octave_idx_type k = 0, l = 0;
           for (; k < n; k++)
             {
-              for (;l != nel && src[l] == zero; l++) ;
+              for (; l != nel && src[l] == zero; l++) ;
               if (l != nel)
                 retval(k) = l++;
               else
                 break;
             }
           if (k < n)
             retval.resize2 (k, 1);
         }
@@ -2396,17 +2400,17 @@ Array<T>::nth_element (const idx_vector&
                 buf[kl++] = tmp;
             }
 
           if (offset == stride-1)
             ov += ns*stride;
         }
 
       if (ku == ns)
-          lsort.nth_element (buf, ns, lo, up);
+        lsort.nth_element (buf, ns, lo, up);
       else if (mode == ASCENDING)
         lsort.nth_element (buf, ku, lo, std::min (ku, up));
       else
         {
           octave_idx_type nnan = ns - ku;
           octave_idx_type zero = 0;
           lsort.nth_element (buf, ku, std::max (lo - nnan, zero),
                              std::max (up - nnan, zero));
@@ -2472,17 +2476,17 @@ template <> octave_idx_type \
 Array<T>::nnz (void) const\
 { return 0; } \
 template <> Array<octave_idx_type> \
 Array<T>::find (octave_idx_type, bool) const\
 { return Array<octave_idx_type> (); } \
  \
 template <> Array<T>  \
 Array<T>::nth_element (const idx_vector&, int) const { return Array<T> (); } \
-
+ 
 
 template <class T>
 Array<T>
 Array<T>::diag (octave_idx_type k) const
 {
   dim_vector dv = dims ();
   octave_idx_type nd = dv.length ();
   Array<T> d;
diff --git a/liboctave/array/Array.h b/liboctave/array/Array.h
--- a/liboctave/array/Array.h
+++ b/liboctave/array/Array.h
@@ -59,42 +59,43 @@ protected:
   public:
 
     T *data;
     octave_idx_type len;
     octave_refcount<int> count;
 
     ArrayRep (T *d, octave_idx_type l)
       : data (no_ctor_new<T> (l)), len (l), count (1)
-        {
-          copy_or_memcpy (l, d, data);
-        }
+    {
+      copy_or_memcpy (l, d, data);
+    }
 
     template <class U>
     ArrayRep (U *d, octave_idx_type l)
       : data (no_ctor_new<T> (l)), len (l), count (1)
-        {
-          std::copy (d, d+l, data);
-        }
+    {
+      std::copy (d, d+l, data);
+    }
 
     ArrayRep (void) : data (0), len (0), count (1) { }
 
-    explicit ArrayRep (octave_idx_type n) : data (no_ctor_new<T> (n)), len (n), count (1) { }
+    explicit ArrayRep (octave_idx_type n)
+      : data (no_ctor_new<T> (n)), len (n), count (1) { }
 
     explicit ArrayRep (octave_idx_type n, const T& val)
       : data (no_ctor_new<T> (n)), len (n), count (1)
-      {
-        fill_or_memset (n, val, data);
-      }
+    {
+      fill_or_memset (n, val, data);
+    }
 
     ArrayRep (const ArrayRep& a)
       : data (no_ctor_new<T> (a.len)), len (a.len), count (1)
-      {
-        copy_or_memcpy (a.len, a.data, data);
-      }
+    {
+      copy_or_memcpy (a.len, a.data, data);
+    }
 
     ~ArrayRep (void) { no_ctor_delete<T> (data); }
 
     octave_idx_type length (void) const { return len; }
 
   private:
 
     // No assignment!
@@ -102,28 +103,28 @@ protected:
     ArrayRep& operator = (const ArrayRep& a);
   };
 
   //--------------------------------------------------------------------
 
 public:
 
   void make_unique (void)
-    {
-      if (rep->count > 1)
-        {
-          ArrayRep *r = new ArrayRep (slice_data, slice_len);
+  {
+    if (rep->count > 1)
+      {
+        ArrayRep *r = new ArrayRep (slice_data, slice_len);
 
-          if (--rep->count == 0)
-            delete rep;
-          
-          rep = r;
-          slice_data = rep->data;
-        }
-    }
+        if (--rep->count == 0)
+          delete rep;
+
+        rep = r;
+        slice_data = rep->data;
+      }
+  }
 
   typedef T element_type;
 
   typedef typename ref_param<T>::type crefT;
 
   typedef bool (*compare_fcn_type) (typename ref_param<T>::type,
                                     typename ref_param<T>::type);
 
@@ -142,299 +143,320 @@ protected:
 
   T* slice_data;
   octave_idx_type slice_len;
 
   // slice constructor
   Array (const Array<T>& a, const dim_vector& dv,
          octave_idx_type l, octave_idx_type u)
     : dimensions (dv), rep(a.rep), slice_data (a.slice_data+l), slice_len (u-l)
-    {
-      rep->count++;
-      dimensions.chop_trailing_singletons ();
-    }
+  {
+    rep->count++;
+    dimensions.chop_trailing_singletons ();
+  }
 
 private:
 
   typename Array<T>::ArrayRep *nil_rep (void) const
-    {
-      // NR was originally allocated with new, but that does not seem
-      // to be necessary since it will never be deleted.  So just use
-      // a static object instead.
+  {
+    // NR was originally allocated with new, but that does not seem
+    // to be necessary since it will never be deleted.  So just use
+    // a static object instead.
 
-      static typename Array<T>::ArrayRep nr;
-      return &nr;
-    }
+    static typename Array<T>::ArrayRep nr;
+    return &nr;
+  }
 
 protected:
 
   // For jit support
   Array (T *sdata, octave_idx_type slen, octave_idx_type *adims, void *arep)
     : dimensions (adims),
       rep (reinterpret_cast<typename Array<T>::ArrayRep *> (arep)),
-      slice_data (sdata), slice_len (slen) {}
+      slice_data (sdata), slice_len (slen) { }
 
 public:
 
   // Empty ctor (0x0).
 
   Array (void)
     : dimensions (), rep (nil_rep ()), slice_data (rep->data),
       slice_len (rep->len)
-    {
-      rep->count++;
-    }
+  {
+    rep->count++;
+  }
 
   // Obsolete 1D ctor (there are no 1D arrays).
   explicit Array (octave_idx_type n) GCC_ATTR_DEPRECATED
     : dimensions (n, 1), rep (new typename Array<T>::ArrayRep (n)),
       slice_data (rep->data), slice_len (rep->len)
-    { }
+  { }
 
   // Obsolete initialized 1D ctor (there are no 1D arrays).
   explicit Array (octave_idx_type n, const T& val) GCC_ATTR_DEPRECATED
     : dimensions (n, 1), rep (new typename Array<T>::ArrayRep (n)),
       slice_data (rep->data), slice_len (rep->len)
-    {
-      fill (val);
-    }
+  {
+    fill (val);
+  }
 
   // nD uninitialized ctor.
   explicit Array (const dim_vector& dv)
     : dimensions (dv),
       rep (new typename Array<T>::ArrayRep (dv.safe_numel ())),
       slice_data (rep->data), slice_len (rep->len)
-    {
-      dimensions.chop_trailing_singletons ();
-    }
+  {
+    dimensions.chop_trailing_singletons ();
+  }
 
   // nD initialized ctor.
   explicit Array (const dim_vector& dv, const T& val)
     : dimensions (dv),
       rep (new typename Array<T>::ArrayRep (dv.safe_numel ())),
       slice_data (rep->data), slice_len (rep->len)
-    {
-      fill (val);
-      dimensions.chop_trailing_singletons ();
-    }
+  {
+    fill (val);
+    dimensions.chop_trailing_singletons ();
+  }
 
   // Reshape constructor.
   Array (const Array<T>& a, const dim_vector& dv);
 
   // Type conversion case.
   template <class U>
   Array (const Array<U>& a)
     : dimensions (a.dims ()),
       rep (new typename Array<T>::ArrayRep (a.data (), a.length ())),
       slice_data (rep->data), slice_len (rep->len)
-    { }
+  { }
 
   // No type conversion case.
   Array (const Array<T>& a)
     : dimensions (a.dimensions), rep (a.rep), slice_data (a.slice_data),
       slice_len (a.slice_len)
-    {
-      rep->count++;
-    }
+  {
+    rep->count++;
+  }
 
 public:
 
   virtual ~Array (void)
-    {
-      if (--rep->count == 0)
-        delete rep;
-    }
+  {
+    if (--rep->count == 0)
+      delete rep;
+  }
 
   Array<T>& operator = (const Array<T>& a)
-    {
-      if (this != &a)
-        {
-          if (--rep->count == 0)
-            delete rep;
+  {
+    if (this != &a)
+      {
+        if (--rep->count == 0)
+          delete rep;
 
-          rep = a.rep;
-          rep->count++;
+        rep = a.rep;
+        rep->count++;
 
-          dimensions = a.dimensions;
-          slice_data = a.slice_data;
-          slice_len = a.slice_len;
-        }
+        dimensions = a.dimensions;
+        slice_data = a.slice_data;
+        slice_len = a.slice_len;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   void fill (const T& val);
 
   void clear (void);
   void clear (const dim_vector& dv);
 
   void clear (octave_idx_type r, octave_idx_type c)
-    { clear (dim_vector (r, c)); }
+  { clear (dim_vector (r, c)); }
 
   octave_idx_type capacity (void) const { return slice_len; }
   octave_idx_type length (void) const { return capacity (); }
   octave_idx_type nelem (void) const { return capacity (); }
   octave_idx_type numel (void) const { return nelem (); }
 
   octave_idx_type dim1 (void) const { return dimensions(0); }
   octave_idx_type dim2 (void) const { return dimensions(1); }
   octave_idx_type dim3 (void) const { return dimensions(2); }
 
   // Return the array as a column vector.
   Array<T> as_column (void) const
-    {
-      Array<T> retval (*this);
-      if (dimensions.length () != 2 || dimensions(1) != 1)
-        retval.dimensions = dim_vector (numel (), 1);
+  {
+    Array<T> retval (*this);
+    if (dimensions.length () != 2 || dimensions(1) != 1)
+      retval.dimensions = dim_vector (numel (), 1);
 
-      return retval;
-    }
+    return retval;
+  }
 
   // Return the array as a row vector.
   Array<T> as_row (void) const
-    {
-      Array<T> retval (*this);
-      if (dimensions.length () != 2 || dimensions(0) != 1)
-        retval.dimensions = dim_vector (1, numel ());
+  {
+    Array<T> retval (*this);
+    if (dimensions.length () != 2 || dimensions(0) != 1)
+      retval.dimensions = dim_vector (1, numel ());
 
-      return retval;
-    }
+    return retval;
+  }
 
   // Return the array as a matrix.
   Array<T> as_matrix (void) const
-    {
-      Array<T> retval (*this);
-      if (dimensions.length () != 2)
-        retval.dimensions = dimensions.redim (2);
+  {
+    Array<T> retval (*this);
+    if (dimensions.length () != 2)
+      retval.dimensions = dimensions.redim (2);
 
-      return retval;
-    }
+    return retval;
+  }
 
   octave_idx_type rows (void) const { return dim1 (); }
   octave_idx_type cols (void) const { return dim2 (); }
   octave_idx_type columns (void) const { return dim2 (); }
   octave_idx_type pages (void) const { return dim3 (); }
 
-  size_t byte_size (void) const { return static_cast<size_t> (numel ()) * sizeof (T); }
+  size_t byte_size (void) const
+  { return static_cast<size_t> (numel ()) * sizeof (T); }
 
   // Return a const-reference so that dims ()(i) works efficiently.
   const dim_vector& dims (void) const { return dimensions; }
 
   Array<T> squeeze (void) const;
 
   void chop_trailing_singletons (void) GCC_ATTR_DEPRECATED
   { dimensions.chop_trailing_singletons (); }
 
   octave_idx_type compute_index (octave_idx_type i, octave_idx_type j) const;
-  octave_idx_type compute_index (octave_idx_type i, octave_idx_type j, octave_idx_type k) const;
+  octave_idx_type compute_index (octave_idx_type i, octave_idx_type j,
+                                 octave_idx_type k) const;
   octave_idx_type compute_index (const Array<octave_idx_type>& ra_idx) const;
 
-  octave_idx_type compute_index_unchecked (const Array<octave_idx_type>& ra_idx) const
-    { return dimensions.compute_index (ra_idx.data (), ra_idx.length ()); }
+  octave_idx_type compute_index_unchecked (const Array<octave_idx_type>& ra_idx)
+  const
+  { return dimensions.compute_index (ra_idx.data (), ra_idx.length ()); }
 
   // No checking, even for multiple references, ever.
 
   T& xelem (octave_idx_type n) { return slice_data[n]; }
   crefT xelem (octave_idx_type n) const { return slice_data[n]; }
 
-  T& xelem (octave_idx_type i, octave_idx_type j) { return xelem (dim1 ()*j+i); }
-  crefT xelem (octave_idx_type i, octave_idx_type j) const { return xelem (dim1 ()*j+i); }
+  T& xelem (octave_idx_type i, octave_idx_type j)
+  { return xelem (dim1 ()*j+i); }
+  crefT xelem (octave_idx_type i, octave_idx_type j) const
+  { return xelem (dim1 ()*j+i); }
 
   T& xelem (octave_idx_type i, octave_idx_type j, octave_idx_type k)
-    { return xelem (i, dim2 ()*k+j); }
+  { return xelem (i, dim2 ()*k+j); }
   crefT xelem (octave_idx_type i, octave_idx_type j, octave_idx_type k) const
-    { return xelem (i, dim2 ()*k+j); }
+  { return xelem (i, dim2 ()*k+j); }
 
   T& xelem (const Array<octave_idx_type>& ra_idx)
-    { return xelem (compute_index_unchecked (ra_idx)); }
+  { return xelem (compute_index_unchecked (ra_idx)); }
 
   crefT xelem (const Array<octave_idx_type>& ra_idx) const
-    { return xelem (compute_index_unchecked (ra_idx)); }
+  { return xelem (compute_index_unchecked (ra_idx)); }
 
-  // FIXME -- would be nice to fix this so that we don't
-  // unnecessarily force a copy, but that is not so easy, and I see no
-  // clean way to do it.
+  // FIXME: would be nice to fix this so that we don't unnecessarily force
+  //        a copy, but that is not so easy, and I see no clean way to do it.
 
   T& checkelem (octave_idx_type n);
   T& checkelem (octave_idx_type i, octave_idx_type j);
   T& checkelem (octave_idx_type i, octave_idx_type j, octave_idx_type k);
   T& checkelem (const Array<octave_idx_type>& ra_idx);
 
   T& elem (octave_idx_type n)
-    {
-      make_unique ();
-      return xelem (n);
-    }
+  {
+    make_unique ();
+    return xelem (n);
+  }
 
   T& elem (octave_idx_type i, octave_idx_type j) { return elem (dim1 ()*j+i); }
 
-  T& elem (octave_idx_type i, octave_idx_type j, octave_idx_type k) { return elem (i, dim2 ()*k+j); }
+  T& elem (octave_idx_type i, octave_idx_type j, octave_idx_type k)
+  { return elem (i, dim2 ()*k+j); }
 
   T& elem (const Array<octave_idx_type>& ra_idx)
-    { return Array<T>::elem (compute_index_unchecked (ra_idx)); }
+  { return Array<T>::elem (compute_index_unchecked (ra_idx)); }
 
 #if defined (BOUNDS_CHECKING)
   T& operator () (octave_idx_type n) { return checkelem (n); }
-  T& operator () (octave_idx_type i, octave_idx_type j) { return checkelem (i, j); }
-  T& operator () (octave_idx_type i, octave_idx_type j, octave_idx_type k) { return checkelem (i, j, k); }
-  T& operator () (const Array<octave_idx_type>& ra_idx) { return checkelem (ra_idx); }
+  T& operator () (octave_idx_type i, octave_idx_type j)
+  { return checkelem (i, j); }
+  T& operator () (octave_idx_type i, octave_idx_type j, octave_idx_type k)
+  { return checkelem (i, j, k); }
+  T& operator () (const Array<octave_idx_type>& ra_idx)
+  { return checkelem (ra_idx); }
 #else
   T& operator () (octave_idx_type n) { return elem (n); }
   T& operator () (octave_idx_type i, octave_idx_type j) { return elem (i, j); }
-  T& operator () (octave_idx_type i, octave_idx_type j, octave_idx_type k) { return elem (i, j, k); }
-  T& operator () (const Array<octave_idx_type>& ra_idx) { return elem (ra_idx); }
+  T& operator () (octave_idx_type i, octave_idx_type j, octave_idx_type k)
+  { return elem (i, j, k); }
+  T& operator () (const Array<octave_idx_type>& ra_idx)
+  { return elem (ra_idx); }
 #endif
 
   crefT checkelem (octave_idx_type n) const;
   crefT checkelem (octave_idx_type i, octave_idx_type j) const;
-  crefT checkelem (octave_idx_type i, octave_idx_type j, octave_idx_type k) const;
+  crefT checkelem (octave_idx_type i, octave_idx_type j,
+                   octave_idx_type k) const;
   crefT checkelem (const Array<octave_idx_type>& ra_idx) const;
 
   crefT elem (octave_idx_type n) const { return xelem (n); }
 
-  crefT elem (octave_idx_type i, octave_idx_type j) const { return xelem (i, j); }
+  crefT elem (octave_idx_type i, octave_idx_type j) const
+  { return xelem (i, j); }
 
-  crefT elem (octave_idx_type i, octave_idx_type j, octave_idx_type k) const { return xelem (i, j, k); }
+  crefT elem (octave_idx_type i, octave_idx_type j, octave_idx_type k) const
+  { return xelem (i, j, k); }
 
   crefT elem (const Array<octave_idx_type>& ra_idx) const
-    { return Array<T>::xelem (compute_index_unchecked (ra_idx)); }
+  { return Array<T>::xelem (compute_index_unchecked (ra_idx)); }
 
 #if defined (BOUNDS_CHECKING)
   crefT operator () (octave_idx_type n) const { return checkelem (n); }
-  crefT operator () (octave_idx_type i, octave_idx_type j) const { return checkelem (i, j); }
-  crefT operator () (octave_idx_type i, octave_idx_type j, octave_idx_type k) const { return checkelem (i, j, k); }
-  crefT operator () (const Array<octave_idx_type>& ra_idx) const { return checkelem (ra_idx); }
+  crefT operator () (octave_idx_type i, octave_idx_type j) const
+  { return checkelem (i, j); }
+  crefT operator () (octave_idx_type i, octave_idx_type j,
+                     octave_idx_type k) const
+  { return checkelem (i, j, k); }
+  crefT operator () (const Array<octave_idx_type>& ra_idx) const
+  { return checkelem (ra_idx); }
 #else
   crefT operator () (octave_idx_type n) const { return elem (n); }
-  crefT operator () (octave_idx_type i, octave_idx_type j) const { return elem (i, j); }
-  crefT operator () (octave_idx_type i, octave_idx_type j, octave_idx_type k) const { return elem (i, j, k); }
-  crefT operator () (const Array<octave_idx_type>& ra_idx) const { return elem (ra_idx); }
+  crefT operator () (octave_idx_type i, octave_idx_type j) const
+  { return elem (i, j); }
+  crefT operator () (octave_idx_type i, octave_idx_type j,
+                     octave_idx_type k) const
+  { return elem (i, j, k); }
+  crefT operator () (const Array<octave_idx_type>& ra_idx) const
+  { return elem (ra_idx); }
 #endif
 
   // Fast extractors. All of these produce shallow copies.
   // Warning: none of these do check bounds, unless BOUNDS_CHECKING is on!
 
   // Extract column: A(:,k+1).
   Array<T> column (octave_idx_type k) const;
   // Extract page: A(:,:,k+1).
   Array<T> page (octave_idx_type k) const;
 
   // Extract a slice from this array as a column vector: A(:)(lo+1:up).
   // Must be 0 <= lo && up <= numel. May be up < lo.
   Array<T> linear_slice (octave_idx_type lo, octave_idx_type up) const;
 
   Array<T> reshape (octave_idx_type nr, octave_idx_type nc) const
-    { return Array<T> (*this, dim_vector (nr, nc)); }
+  { return Array<T> (*this, dim_vector (nr, nc)); }
 
   Array<T> reshape (const dim_vector& new_dims) const
-    { return Array<T> (*this, new_dims); }
+  { return Array<T> (*this, new_dims); }
 
   Array<T> permute (const Array<octave_idx_type>& vec, bool inv = false) const;
   Array<T> ipermute (const Array<octave_idx_type>& vec) const
-    { return permute (vec, true); }
+  { return permute (vec, true); }
 
   bool is_square (void) const { return (dim1 () == dim2 ()); }
 
   bool is_empty (void) const { return numel () == 0; }
 
   bool is_vector (void) const { return dimensions.is_vector (); }
 
   Array<T> transpose (void) const;
@@ -462,60 +484,65 @@ public:
 
   // Resizing (with fill).
 
   void resize1 (octave_idx_type n, const T& rfv);
   void resize1 (octave_idx_type n) { resize1 (n, resize_fill_value ()); }
 
   void resize (octave_idx_type n) GCC_ATTR_DEPRECATED { resize1 (n); }
 
-  void resize (octave_idx_type nr, octave_idx_type nc, const T& rfv) GCC_ATTR_DEPRECATED
+  void resize (octave_idx_type nr, octave_idx_type nc,
+               const T& rfv) GCC_ATTR_DEPRECATED
   {
     resize2 (nr, nc, rfv);
   }
 
   void resize (octave_idx_type nr, octave_idx_type nc) GCC_ATTR_DEPRECATED
   {
     resize2 (nr, nc, resize_fill_value ());
   }
 
   void resize (const dim_vector& dv, const T& rfv);
   void resize (const dim_vector& dv) { resize (dv, resize_fill_value ()); }
 
   // Indexing with possible resizing and fill
-  // FIXME -- this is really a corner case, that should better be
+  // FIXME: this is really a corner case, that should better be
   // handled directly in liboctinterp.
 
   Array<T> index (const idx_vector& i, bool resize_ok, const T& rfv) const;
   Array<T> index (const idx_vector& i, bool resize_ok) const
   {
     return index (i, resize_ok, resize_fill_value ());
   }
 
-  Array<T> index (const idx_vector& i, const idx_vector& j, bool resize_ok, const T& rfv) const;
-  Array<T> index (const idx_vector& i, const idx_vector& j, bool resize_ok) const
+  Array<T> index (const idx_vector& i, const idx_vector& j, bool resize_ok,
+                  const T& rfv) const;
+  Array<T> index (const idx_vector& i, const idx_vector& j,
+                  bool resize_ok) const
   {
     return index (i, j, resize_ok, resize_fill_value ());
   }
 
-  Array<T> index (const Array<idx_vector>& ia, bool resize_ok, const T& rfv) const;
+  Array<T> index (const Array<idx_vector>& ia, bool resize_ok,
+                  const T& rfv) const;
   Array<T> index (const Array<idx_vector>& ia, bool resize_ok) const
   {
     return index (ia, resize_ok, resize_fill_value ());
   }
 
   // Indexed assignment (always with resize & fill).
 
   void assign (const idx_vector& i, const Array<T>& rhs, const T& rfv);
   void assign (const idx_vector& i, const Array<T>& rhs)
   {
     assign (i, rhs, resize_fill_value ());
   }
 
-  void assign (const idx_vector& i, const idx_vector& j, const Array<T>& rhs, const T& rfv);
+  void assign (const idx_vector& i, const idx_vector& j, const Array<T>& rhs,
+               const T& rfv);
   void assign (const idx_vector& i, const idx_vector& j, const Array<T>& rhs)
   {
     assign (i, j, rhs, resize_fill_value ());
   }
 
   void assign (const Array<idx_vector>& ia, const Array<T>& rhs, const T& rfv);
   void assign (const Array<idx_vector>& ia, const Array<T>& rhs)
   {
@@ -538,25 +565,25 @@ public:
   // this method is equivalent to
   // x(i1:i1+d1-1, i2:i2+d2-1, ... , iN:iN+dN-1) = a.
   Array<T>& insert (const Array<T>& a, const Array<octave_idx_type>& idx);
 
   // This is just a special case for idx = [r c 0 ...]
   Array<T>& insert (const Array<T>& a, octave_idx_type r, octave_idx_type c);
 
   void maybe_economize (void)
-    {
-      if (rep->count == 1 && slice_len != rep->len)
-        {
-          ArrayRep *new_rep = new ArrayRep (slice_data, slice_len);
-          delete rep;
-          rep = new_rep;
-          slice_data = rep->data;
-        }
-    }
+  {
+    if (rep->count == 1 && slice_len != rep->len)
+      {
+        ArrayRep *new_rep = new ArrayRep (slice_data, slice_len);
+        delete rep;
+        rep = new_rep;
+        slice_data = rep->data;
+      }
+  }
 
   void print_info (std::ostream& os, const std::string& prefix) const;
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return const_cast<T *> (data ()); }
 
   Array<T> sort (int dim = 0, sortmode mode = ASCENDING) const;
@@ -573,24 +600,26 @@ public:
   sortmode is_sorted_rows (sortmode mode = UNSORTED) const;
 
   // Do a binary lookup in a sorted array. Must not contain NaNs.
   // Mode can be specified or is auto-detected by comparing 1st and last element.
   octave_idx_type lookup (const T& value, sortmode mode = UNSORTED) const;
 
   // Ditto, but for an array of values, specializing on the case when values
   // are sorted. NaNs get the value N.
-  Array<octave_idx_type> lookup (const Array<T>& values, sortmode mode = UNSORTED) const;
+  Array<octave_idx_type> lookup (const Array<T>& values,
+                                 sortmode mode = UNSORTED) const;
 
   // Count nonzero elements.
   octave_idx_type nnz (void) const;
 
   // Find indices of (at most n) nonzero elements. If n is specified, backward
   // specifies search from backward.
-  Array<octave_idx_type> find (octave_idx_type n = -1, bool backward = false) const;
+  Array<octave_idx_type> find (octave_idx_type n = -1,
+                               bool backward = false) const;
 
   // Returns the n-th element in increasing order, using the same ordering as
   // used for sort. n can either be a scalar index or a contiguous range.
   Array<T> nth_element (const idx_vector& n, int dim = 0) const;
 
   Array<T> diag (octave_idx_type k = 0) const;
 
   Array<T> diag (octave_idx_type m, octave_idx_type n) const;
@@ -686,17 +715,17 @@ public:
 
   octave_idx_type *jit_dimensions (void) const { return dimensions.to_jit (); }
 
   void *jit_array_rep (void) const { return rep; }
 
 private:
 
   void resize2 (octave_idx_type nr, octave_idx_type nc, const T& rfv);
-  void resize2 (octave_idx_type nr, octave_idx_type nc)                
+  void resize2 (octave_idx_type nr, octave_idx_type nc)
   {
     resize2 (nr, nc, resize_fill_value ());
   }
 
   static void instantiation_guard ();
 };
 
 // This is a simple wrapper template that will subclass an Array<T> type or any
@@ -718,22 +747,22 @@ public:
 
   template <class X, class Y>
     explicit NoAlias (X x, Y y) : ArrayClass (x, y) { }
 
   template <class X, class Y, class Z>
     explicit NoAlias (X x, Y y, Z z) : ArrayClass (x, y, z) { }
 
   T& operator () (octave_idx_type n)
-    { return ArrayClass::xelem (n); }
+  { return ArrayClass::xelem (n); }
   T& operator () (octave_idx_type i, octave_idx_type j)
-    { return ArrayClass::xelem (i, j); }
+  { return ArrayClass::xelem (i, j); }
   T& operator () (octave_idx_type i, octave_idx_type j, octave_idx_type k)
-    { return ArrayClass::xelem (i, j, k); }
+  { return ArrayClass::xelem (i, j, k); }
   T& operator () (const Array<octave_idx_type>& ra_idx)
-    { return ArrayClass::xelem (ra_idx); }
+  { return ArrayClass::xelem (ra_idx); }
 };
 
 template <class T>
 std::ostream&
 operator << (std::ostream& os, const Array<T>& a);
 
 #endif
diff --git a/liboctave/array/Array3.h b/liboctave/array/Array3.h
--- a/liboctave/array/Array3.h
+++ b/liboctave/array/Array3.h
@@ -37,55 +37,58 @@ class idx_vector;
 template <class T>
 class
 Array3 : public Array<T>
 {
 public:
 
   Array3 (void) : Array<T> (dim_vector (0, 0, 0)) { }
 
-  Array3 (octave_idx_type r, octave_idx_type c, octave_idx_type p) : Array<T> (dim_vector (r, c, p)) { }
+  Array3 (octave_idx_type r, octave_idx_type c,
+          octave_idx_type p) : Array<T> (dim_vector (r, c, p)) { }
 
   Array3 (octave_idx_type r, octave_idx_type c, octave_idx_type p, const T& val)
     : Array<T> (dim_vector (r, c, p), val) { }
 
   Array3 (const Array3<T>& a)
     : Array<T> (a, a.dims ()) { }
 
-  Array3 (const Array<T>& a, octave_idx_type r, octave_idx_type c, octave_idx_type p)
+  Array3 (const Array<T>& a, octave_idx_type r, octave_idx_type c,
+          octave_idx_type p)
     : Array<T> (a, dim_vector (r, c, p)) { }
 
   ~Array3 (void) { }
 
   Array3<T>& operator = (const Array3<T>& a)
-    {
-      if (this != &a)
-        Array<T>::operator = (a);
+  {
+    if (this != &a)
+      Array<T>::operator = (a);
 
-      return *this;
-    }
+    return *this;
+  }
 
   void resize (octave_idx_type r, octave_idx_type c, octave_idx_type p)
-    { Array<T>::resize (dim_vector (r, c, p)); }
+  { Array<T>::resize (dim_vector (r, c, p)); }
 
-  void resize (octave_idx_type r, octave_idx_type c, octave_idx_type p, const T& val)
-    { Array<T>::resize (dim_vector (r, c, p), val); }
+  void resize (octave_idx_type r, octave_idx_type c, octave_idx_type p,
+               const T& val)
+  { Array<T>::resize (dim_vector (r, c, p), val); }
 
   Array3<T> sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
-    {
-      Array<T> tmp = Array<T>::sort (dim, mode);
-      return Array3<T> (tmp, tmp.rows (), tmp.columns (), tmp.pages ());
-    }
+  {
+    Array<T> tmp = Array<T>::sort (dim, mode);
+    return Array3<T> (tmp, tmp.rows (), tmp.columns (), tmp.pages ());
+  }
 
   Array3<T> sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
-                 sortmode mode = ASCENDING) const
-    {
-      Array<T> tmp = Array<T>::sort (sidx, dim, mode);
-      return Array3<T> (tmp, tmp.rows (), tmp.columns (), tmp.pages ());
-    }
+                  sortmode mode = ASCENDING) const
+  {
+    Array<T> tmp = Array<T>::sort (sidx, dim, mode);
+    return Array3<T> (tmp, tmp.rows (), tmp.columns (), tmp.pages ());
+  }
 };
 
 // If we're with GNU C++, issue a warning.
 #ifdef __GNUC__
 #warning Using Array3<T> is deprecated. Use Array<T> directly.
 #endif
 
 #endif
diff --git a/liboctave/array/CColVector.cc b/liboctave/array/CColVector.cc
--- a/liboctave/array/CColVector.cc
+++ b/liboctave/array/CColVector.cc
@@ -48,17 +48,17 @@ extern "C"
                            const octave_idx_type&, const Complex&,
                            Complex*, const octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL);
 }
 
 // Complex Column Vector class
 
 ComplexColumnVector::ComplexColumnVector (const ColumnVector& a)
-   : MArray<Complex> (a)
+  : MArray<Complex> (a)
 {
 }
 
 bool
 ComplexColumnVector::operator == (const ComplexColumnVector& a) const
 {
   octave_idx_type len = length ();
   if (len != a.length ())
@@ -171,17 +171,18 @@ ComplexColumnVector::fill (double val, o
       for (octave_idx_type i = r1; i <= r2; i++)
         xelem (i) = val;
     }
 
   return *this;
 }
 
 ComplexColumnVector&
-ComplexColumnVector::fill (const Complex& val, octave_idx_type r1, octave_idx_type r2)
+ComplexColumnVector::fill (const Complex& val,
+                           octave_idx_type r1, octave_idx_type r2)
 {
   octave_idx_type len = length ();
 
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
diff --git a/liboctave/array/CColVector.h b/liboctave/array/CColVector.h
--- a/liboctave/array/CColVector.h
+++ b/liboctave/array/CColVector.h
@@ -27,18 +27,18 @@ along with Octave; see the file COPYING.
 #include "MArray.h"
 
 #include "mx-defs.h"
 
 class
 OCTAVE_API
 ComplexColumnVector : public MArray<Complex>
 {
-friend class ComplexMatrix;
-friend class ComplexRowVector;
+  friend class ComplexMatrix;
+  friend class ComplexRowVector;
 
 public:
 
   ComplexColumnVector (void) : MArray<Complex> (dim_vector (0, 1)) { }
 
   explicit ComplexColumnVector (octave_idx_type n)
     : MArray<Complex> (dim_vector (n, 1)) { }
 
@@ -54,33 +54,35 @@ public:
     : MArray<Complex> (a.as_column ()) { }
 
   ComplexColumnVector (const Array<Complex>& a)
     : MArray<Complex> (a.as_column ()) { }
 
   explicit ComplexColumnVector (const ColumnVector& a);
 
   ComplexColumnVector& operator = (const ComplexColumnVector& a)
-    {
-      MArray<Complex>::operator = (a);
-      return *this;
-    }
+  {
+    MArray<Complex>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const ComplexColumnVector& a) const;
   bool operator != (const ComplexColumnVector& a) const;
 
   // destructive insert/delete/reorder operations
 
   ComplexColumnVector& insert (const ColumnVector& a, octave_idx_type r);
   ComplexColumnVector& insert (const ComplexColumnVector& a, octave_idx_type r);
 
   ComplexColumnVector& fill (double val);
   ComplexColumnVector& fill (const Complex& val);
-  ComplexColumnVector& fill (double val, octave_idx_type r1, octave_idx_type r2);
-  ComplexColumnVector& fill (const Complex& val, octave_idx_type r1, octave_idx_type r2);
+  ComplexColumnVector& fill (double val,
+                             octave_idx_type r1, octave_idx_type r2);
+  ComplexColumnVector& fill (const Complex& val,
+                             octave_idx_type r1, octave_idx_type r2);
 
   ComplexColumnVector stack (const ColumnVector& a) const;
   ComplexColumnVector stack (const ComplexColumnVector& a) const;
 
   ComplexRowVector hermitian (void) const;
   ComplexRowVector transpose (void) const;
 
   friend OCTAVE_API ComplexColumnVector conj (const ComplexColumnVector& a);
@@ -94,54 +96,56 @@ public:
   // column vector by column vector -> column vector operations
 
   ComplexColumnVector& operator += (const ColumnVector& a);
   ComplexColumnVector& operator -= (const ColumnVector& a);
 
   // matrix by column vector -> column vector operations
 
   friend OCTAVE_API ComplexColumnVector operator * (const ComplexMatrix& a,
-                                         const ColumnVector& b);
+                                                    const ColumnVector& b);
 
   friend OCTAVE_API ComplexColumnVector operator * (const ComplexMatrix& a,
-                                         const ComplexColumnVector& b);
+                                                    const ComplexColumnVector& b);
 
   // matrix by column vector -> column vector operations
 
   friend OCTAVE_API ComplexColumnVector operator * (const Matrix& a,
-                                         const ComplexColumnVector& b);
+                                                    const ComplexColumnVector& b);
 
   // diagonal matrix by column vector -> column vector operations
 
   friend OCTAVE_API ComplexColumnVector operator * (const DiagMatrix& a,
-                                         const ComplexColumnVector& b);
+                                                    const ComplexColumnVector& b);
 
   friend OCTAVE_API ComplexColumnVector operator * (const ComplexDiagMatrix& a,
-                                         const ColumnVector& b);
+                                                    const ColumnVector& b);
 
   friend OCTAVE_API ComplexColumnVector operator * (const ComplexDiagMatrix& a,
-                                         const ComplexColumnVector& b);
+                                                    const ComplexColumnVector& b);
 
   // other operations
 
   Complex min (void) const;
   Complex max (void) const;
 
   ColumnVector abs (void) const;
 
   // i/o
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ComplexColumnVector& a);
-  friend OCTAVE_API std::istream& operator >> (std::istream& is, ComplexColumnVector& a);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const ComplexColumnVector& a);
+  friend OCTAVE_API std::istream& operator >> (std::istream& is,
+                                               ComplexColumnVector& a);
 
   void resize (octave_idx_type n, const Complex& rfv = Complex (0))
   {
     Array<Complex>::resize (dim_vector (n, 1), rfv);
   }
 
   void clear (octave_idx_type n)
-    { Array<Complex>::clear (n, 1); }
+  { Array<Complex>::clear (n, 1); }
 
 };
 
 MARRAY_FORWARD_DEFS (MArray, ComplexColumnVector, Complex)
 
 #endif
diff --git a/liboctave/array/CDiagMatrix.cc b/liboctave/array/CDiagMatrix.cc
--- a/liboctave/array/CDiagMatrix.cc
+++ b/liboctave/array/CDiagMatrix.cc
@@ -86,17 +86,18 @@ ComplexDiagMatrix::fill (double val, oct
 
   for (octave_idx_type i = beg; i <= end; i++)
     elem (i, i) = val;
 
   return *this;
 }
 
 ComplexDiagMatrix&
-ComplexDiagMatrix::fill (const Complex& val, octave_idx_type beg, octave_idx_type end)
+ComplexDiagMatrix::fill (const Complex& val,
+                         octave_idx_type beg, octave_idx_type end)
 {
   if (beg < 0 || end >= length () || end < beg)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = beg; i <= end; i++)
@@ -243,17 +244,18 @@ ComplexDiagMatrix
 conj (const ComplexDiagMatrix& a)
 {
   return ComplexDiagMatrix (conj (a.extract_diag ()), a.rows (), a.columns ());
 }
 
 // resize is the destructive analog for this one
 
 ComplexMatrix
-ComplexDiagMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
+ComplexDiagMatrix::extract (octave_idx_type r1, octave_idx_type c1,
+                            octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { std::swap (r1, r2); }
   if (c1 > c2) { std::swap (c1, c2); }
 
   octave_idx_type new_r = r2 - r1 + 1;
   octave_idx_type new_c = c2 - c1 + 1;
 
   ComplexMatrix result (new_r, new_c);
diff --git a/liboctave/array/CDiagMatrix.h b/liboctave/array/CDiagMatrix.h
--- a/liboctave/array/CDiagMatrix.h
+++ b/liboctave/array/CDiagMatrix.h
@@ -36,73 +36,80 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 ComplexDiagMatrix : public MDiagArray2<Complex>
 {
 public:
 
   ComplexDiagMatrix (void) : MDiagArray2<Complex> () { }
 
-  ComplexDiagMatrix (octave_idx_type r, octave_idx_type c) : MDiagArray2<Complex> (r, c) { }
+  ComplexDiagMatrix (octave_idx_type r, octave_idx_type c)
+    : MDiagArray2<Complex> (r, c) { }
 
   ComplexDiagMatrix (octave_idx_type r, octave_idx_type c, const Complex& val)
     : MDiagArray2<Complex> (r, c, val) { }
 
   explicit ComplexDiagMatrix (const Array<Complex>& a)
     : MDiagArray2<Complex> (a) { }
 
   explicit ComplexDiagMatrix (const Array<double>& a)
     : MDiagArray2<Complex> (Array<Complex> (a)) { }
 
-  ComplexDiagMatrix (const Array<Complex>& a, octave_idx_type r, octave_idx_type c)
+  ComplexDiagMatrix (const Array<Complex>& a, octave_idx_type r,
+                     octave_idx_type c)
     : MDiagArray2<Complex> (a, r, c) { }
 
   explicit ComplexDiagMatrix (const DiagMatrix& a);
 
   ComplexDiagMatrix (const MDiagArray2<Complex>& a)
     : MDiagArray2<Complex> (a) { }
 
   ComplexDiagMatrix (const ComplexDiagMatrix& a)
     : MDiagArray2<Complex> (a) { }
 
   template <class U>
   ComplexDiagMatrix (const DiagArray2<U>& a)
     : MDiagArray2<Complex> (a) { }
 
   ComplexDiagMatrix& operator = (const ComplexDiagMatrix& a)
-    {
-      MDiagArray2<Complex>::operator = (a);
-      return *this;
-    }
+  {
+    MDiagArray2<Complex>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const ComplexDiagMatrix& a) const;
   bool operator != (const ComplexDiagMatrix& a) const;
 
   ComplexDiagMatrix& fill (double val);
   ComplexDiagMatrix& fill (const Complex& val);
-  ComplexDiagMatrix& fill (double val, octave_idx_type beg, octave_idx_type end);
-  ComplexDiagMatrix& fill (const Complex& val, octave_idx_type beg, octave_idx_type end);
+  ComplexDiagMatrix& fill (double val,
+                           octave_idx_type beg, octave_idx_type end);
+  ComplexDiagMatrix& fill (const Complex& val,
+                           octave_idx_type beg, octave_idx_type end);
   ComplexDiagMatrix& fill (const ColumnVector& a);
   ComplexDiagMatrix& fill (const ComplexColumnVector& a);
   ComplexDiagMatrix& fill (const RowVector& a);
   ComplexDiagMatrix& fill (const ComplexRowVector& a);
   ComplexDiagMatrix& fill (const ColumnVector& a, octave_idx_type beg);
   ComplexDiagMatrix& fill (const ComplexColumnVector& a, octave_idx_type beg);
   ComplexDiagMatrix& fill (const RowVector& a, octave_idx_type beg);
   ComplexDiagMatrix& fill (const ComplexRowVector& a, octave_idx_type beg);
 
-  ComplexDiagMatrix hermitian (void) const { return MDiagArray2<Complex>::hermitian (std::conj); }
-  ComplexDiagMatrix transpose (void) const { return MDiagArray2<Complex>::transpose (); }
+  ComplexDiagMatrix hermitian (void) const
+  { return MDiagArray2<Complex>::hermitian (std::conj); }
+  ComplexDiagMatrix transpose (void) const
+  { return MDiagArray2<Complex>::transpose (); }
   DiagMatrix abs (void) const;
 
   friend OCTAVE_API ComplexDiagMatrix conj (const ComplexDiagMatrix& a);
 
   // resize is the destructive analog for this one
 
-  ComplexMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
+  ComplexMatrix extract (octave_idx_type r1, octave_idx_type c1,
+                         octave_idx_type r2, octave_idx_type c2) const;
 
   // extract row or column i
 
   ComplexRowVector row (octave_idx_type i) const;
   ComplexRowVector row (char *s) const;
 
   ComplexColumnVector column (octave_idx_type i) const;
   ComplexColumnVector column (char *s) const;
@@ -116,24 +123,25 @@ public:
   // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
   ComplexDiagMatrix& operator += (const DiagMatrix& a);
   ComplexDiagMatrix& operator -= (const DiagMatrix& a);
 
   // other operations
 
   ComplexColumnVector extract_diag (octave_idx_type k = 0) const
-    { return MDiagArray2<Complex>::extract_diag (k); }
+  { return MDiagArray2<Complex>::extract_diag (k); }
 
   ComplexDET determinant (void) const;
   double rcond (void) const;
 
   // i/o
 
-  friend std::ostream& operator << (std::ostream& os, const ComplexDiagMatrix& a);
+  friend std::ostream& operator << (std::ostream& os,
+                                    const ComplexDiagMatrix& a);
 
 };
 
 OCTAVE_API ComplexDiagMatrix conj (const ComplexDiagMatrix& a);
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 OCTAVE_API ComplexDiagMatrix
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -295,18 +295,17 @@ ComplexMatrix::ComplexMatrix (const Comp
 
 ComplexMatrix::ComplexMatrix (const ComplexDiagMatrix& a)
   : MArray<Complex> (a.dims (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
-// FIXME -- could we use a templated mixed-type copy function
-// here?
+// FIXME: could we use a templated mixed-type copy function here?
 
 ComplexMatrix::ComplexMatrix (const boolMatrix& a)
   : MArray<Complex> (a)
 {
 }
 
 ComplexMatrix::ComplexMatrix (const charMatrix& a)
   : MArray<Complex> (a.dims (), 0.0)
@@ -405,17 +404,18 @@ ComplexMatrix::insert (const RowVector& 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r, c+i) = a.elem (i);
     }
 
   return *this;
 }
 
 ComplexMatrix&
-ComplexMatrix::insert (const ColumnVector& a, octave_idx_type r, octave_idx_type c)
+ComplexMatrix::insert (const ColumnVector& a,
+                       octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.length ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
@@ -427,17 +427,18 @@ ComplexMatrix::insert (const ColumnVecto
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i, c) = a.elem (i);
     }
 
   return *this;
 }
 
 ComplexMatrix&
-ComplexMatrix::insert (const DiagMatrix& a, octave_idx_type r, octave_idx_type c)
+ComplexMatrix::insert (const DiagMatrix& a,
+                       octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r < 0 || r + a_nr > rows () || c < 0 || c + a_nc > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
@@ -454,40 +455,43 @@ ComplexMatrix::insert (const DiagMatrix&
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i, c+i) = a.elem (i, i);
     }
 
   return *this;
 }
 
 ComplexMatrix&
-ComplexMatrix::insert (const ComplexMatrix& a, octave_idx_type r, octave_idx_type c)
+ComplexMatrix::insert (const ComplexMatrix& a,
+                       octave_idx_type r, octave_idx_type c)
 {
   Array<Complex>::insert (a, r, c);
   return *this;
 }
 
 ComplexMatrix&
-ComplexMatrix::insert (const ComplexRowVector& a, octave_idx_type r, octave_idx_type c)
+ComplexMatrix::insert (const ComplexRowVector& a,
+                       octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.length ();
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (r, c+i) = a.elem (i);
 
   return *this;
 }
 
 ComplexMatrix&
-ComplexMatrix::insert (const ComplexColumnVector& a, octave_idx_type r, octave_idx_type c)
+ComplexMatrix::insert (const ComplexColumnVector& a,
+                       octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.length ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
@@ -499,17 +503,18 @@ ComplexMatrix::insert (const ComplexColu
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i, c) = a.elem (i);
     }
 
   return *this;
 }
 
 ComplexMatrix&
-ComplexMatrix::insert (const ComplexDiagMatrix& a, octave_idx_type r, octave_idx_type c)
+ComplexMatrix::insert (const ComplexDiagMatrix& a,
+                       octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r < 0 || r + a_nr > rows () || c < 0 || c + a_nc > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
@@ -562,17 +567,18 @@ ComplexMatrix::fill (const Complex& val)
         for (octave_idx_type i = 0; i < nr; i++)
           xelem (i, j) = val;
     }
 
   return *this;
 }
 
 ComplexMatrix&
-ComplexMatrix::fill (double val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2)
+ComplexMatrix::fill (double val, octave_idx_type r1, octave_idx_type c1,
+                     octave_idx_type r2, octave_idx_type c2)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
     {
       (*current_liboctave_error_handler) ("range error for fill");
@@ -590,17 +596,18 @@ ComplexMatrix::fill (double val, octave_
         for (octave_idx_type i = r1; i <= r2; i++)
           xelem (i, j) = val;
     }
 
   return *this;
 }
 
 ComplexMatrix&
-ComplexMatrix::fill (const Complex& val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2)
+ComplexMatrix::fill (const Complex& val, octave_idx_type r1, octave_idx_type c1,
+                     octave_idx_type r2, octave_idx_type c2)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
     {
       (*current_liboctave_error_handler) ("range error for fill");
@@ -922,26 +929,28 @@ ComplexMatrix
 conj (const ComplexMatrix& a)
 {
   return do_mx_unary_map<Complex, Complex, std::conj<double> > (a);
 }
 
 // resize is the destructive equivalent for this one
 
 ComplexMatrix
-ComplexMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
+ComplexMatrix::extract (octave_idx_type r1, octave_idx_type c1,
+                        octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { std::swap (r1, r2); }
   if (c1 > c2) { std::swap (c1, c2); }
 
   return index (idx_vector (r1, r2+1), idx_vector (c1, c2+1));
 }
 
 ComplexMatrix
-ComplexMatrix::extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const
+ComplexMatrix::extract_n (octave_idx_type r1, octave_idx_type c1,
+                          octave_idx_type nr, octave_idx_type nc) const
 {
   return index (idx_vector (r1, r1 + nr), idx_vector (c1, c1 + nc));
 }
 
 // extract row or column i.
 
 ComplexRowVector
 ComplexMatrix::row (octave_idx_type i) const
@@ -1084,17 +1093,18 @@ ComplexMatrix::finverse (MatrixType &mat
       z.resize (dim_vector (lwork, 1));
       Complex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm;
       if (calc_cond)
-        anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
+        anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0))
+                .max ();
 
       F77_XFCN (zgetrf, ZGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -1553,17 +1563,18 @@ ComplexMatrix::determinant (void) const
 ComplexDET
 ComplexMatrix::determinant (octave_idx_type& info) const
 {
   double rcon;
   return determinant (info, rcon, 0);
 }
 
 ComplexDET
-ComplexMatrix::determinant (octave_idx_type& info, double& rcon, int calc_cond) const
+ComplexMatrix::determinant (octave_idx_type& info, double& rcon,
+                            int calc_cond) const
 {
   MatrixType mattype (*this);
   return determinant (mattype, info, rcon, calc_cond);
 }
 
 ComplexDET
 ComplexMatrix::determinant (MatrixType& mattype,
                             octave_idx_type& info, double& rcon,
@@ -1791,17 +1802,17 @@ ComplexMatrix::rcond (MatrixType &mattyp
             {
               octave_idx_type info = 0;
               char job = 'L';
 
               ComplexMatrix atmp = *this;
               Complex *tmp_data = atmp.fortran_vec ();
 
               anorm = atmp.abs().sum().
-                row(static_cast<octave_idx_type>(0)).max();
+                      row(static_cast<octave_idx_type>(0)).max();
 
               F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
@@ -1834,17 +1845,17 @@ ComplexMatrix::rcond (MatrixType &mattyp
               ComplexMatrix atmp = *this;
               Complex *tmp_data = atmp.fortran_vec ();
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
-                  row(static_cast<octave_idx_type>(0)).max ();
+                        row(static_cast<octave_idx_type>(0)).max ();
 
               Array<Complex> z (dim_vector (2 * nc, 1));
               Complex *pz = z.fortran_vec ();
               Array<double> rz (dim_vector (2 * nc, 1));
               double *prz = rz.fortran_vec ();
 
               F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -2091,17 +2102,17 @@ ComplexMatrix::fsolve (MatrixType &matty
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || b.cols () == 0)
     retval = ComplexMatrix (nc, b.cols (), Complex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
-     // Calculate the norm of the matrix, for later use.
+      // Calculate the norm of the matrix, for later use.
       double anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
 
           ComplexMatrix atmp = *this;
@@ -2186,17 +2197,18 @@ ComplexMatrix::fsolve (MatrixType &matty
 
           Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (2 * nc, 1));
           double *prz = rz.fortran_vec ();
 
           // Calculate the norm of the matrix, for later use.
           if (anorm < 0.)
-            anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
+            anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0))
+                    .max ();
 
           F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
@@ -2329,19 +2341,21 @@ ComplexMatrix::solve (MatrixType &mattyp
     typ = mattype.type (*this);
 
   // Only calculate the condition number for LU/Cholesky
   if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, info, rcon, sing_handler, false, transt);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, info, rcon, sing_handler, false, transt);
   else if (transt == blas_trans)
-    return transpose ().solve (mattype, b, info, rcon, sing_handler, singular_fallback);
+    return transpose ().solve (mattype, b, info, rcon, sing_handler,
+                               singular_fallback);
   else if (transt == blas_conj_trans)
-    retval = hermitian ().solve (mattype, b, info, rcon, sing_handler, singular_fallback);
+    retval = hermitian ().solve (mattype, b, info, rcon, sing_handler,
+                                 singular_fallback);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, info, rcon, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
 
@@ -2376,17 +2390,18 @@ ComplexMatrix::solve (MatrixType &typ, c
                       octave_idx_type& info, double& rcon) const
 {
   return solve (typ, ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b,
                       octave_idx_type& info, double& rcon,
-                      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                      solve_singularity_handler sing_handler,
+                      blas_trans_type transt) const
 {
   return solve (typ, ComplexColumnVector (b), info, rcon, sing_handler, transt);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b) const
 {
   octave_idx_type info;
@@ -2407,17 +2422,18 @@ ComplexMatrix::solve (MatrixType &typ, c
                       octave_idx_type& info, double& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b,
                       octave_idx_type& info, double& rcon,
-                      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                      solve_singularity_handler sing_handler,
+                      blas_trans_type transt) const
 {
 
   ComplexMatrix tmp (b);
   tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
   return tmp.column (static_cast<octave_idx_type> (0));
 }
 
 ComplexMatrix
@@ -2431,24 +2447,26 @@ ComplexMatrix::solve (const Matrix& b) c
 ComplexMatrix
 ComplexMatrix::solve (const Matrix& b, octave_idx_type& info) const
 {
   double rcon;
   return solve (b, info, rcon, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (const Matrix& b, octave_idx_type& info, double& rcon) const
+ComplexMatrix::solve (const Matrix& b, octave_idx_type& info,
+                      double& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const Matrix& b, octave_idx_type& info, double& rcon,
-                      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                      solve_singularity_handler sing_handler,
+                      blas_trans_type transt) const
 {
   ComplexMatrix tmp (b);
   return solve (tmp, info, rcon, sing_handler, transt);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const ComplexMatrix& b) const
 {
@@ -2460,24 +2478,27 @@ ComplexMatrix::solve (const ComplexMatri
 ComplexMatrix
 ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info) const
 {
   double rcon;
   return solve (b, info, rcon, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon) const
+ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info,
+                      double& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 ComplexMatrix
-ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon,
-                      solve_singularity_handler sing_handler, blas_trans_type transt) const
+ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info,
+                      double& rcon,
+                      solve_singularity_handler sing_handler,
+                      blas_trans_type transt) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, info, rcon, sing_handler, true, transt);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b) const
 {
@@ -2498,17 +2519,18 @@ ComplexMatrix::solve (const ColumnVector
                       double& rcon) const
 {
   return solve (ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info,
                       double& rcon,
-                      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                      solve_singularity_handler sing_handler,
+                      blas_trans_type transt) const
 {
   return solve (ComplexColumnVector (b), info, rcon, sing_handler, transt);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b) const
 {
   octave_idx_type info;
@@ -2528,17 +2550,18 @@ ComplexMatrix::solve (const ComplexColum
                       double& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
                       double& rcon,
-                      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                      solve_singularity_handler sing_handler,
+                      blas_trans_type transt) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, info, rcon, sing_handler, transt);
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const Matrix& b) const
 {
@@ -2665,18 +2688,19 @@ ComplexMatrix::lssolve (const ComplexMat
 #else
       double tmp = log (dminmn / dsmlsizp1) / log (2.0);
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
-        + 3*smlsiz*nrhs + std::max ((smlsiz+1)*(smlsiz+1),
-                                    n*(1+nrhs) + 2*nrhs);
+                               + 3*smlsiz*nrhs
+                               + std::max ((smlsiz+1)*(smlsiz+1),
+                                           n*(1+nrhs) + 2*nrhs);
       if (lrwork < 1)
         lrwork = 1;
       Array<double> rwork (dim_vector (lrwork, 1));
       double *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
@@ -2773,17 +2797,18 @@ ComplexMatrix::lssolve (const ComplexCol
 {
   octave_idx_type info;
   octave_idx_type rank;
   double rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 ComplexColumnVector
-ComplexMatrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info) const
+ComplexMatrix::lssolve (const ComplexColumnVector& b,
+                        octave_idx_type& info) const
 {
   octave_idx_type rank;
   double rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 ComplexColumnVector
 ComplexMatrix::lssolve (const ComplexColumnVector& b, octave_idx_type& info,
@@ -2855,17 +2880,17 @@ ComplexMatrix::lssolve (const ComplexCol
 #else
       double tmp = log (dminmn / dsmlsizp1) / log (2.0);
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
-        + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
+                               + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
         lrwork = 1;
       Array<double> rwork (dim_vector (lrwork, 1));
       double *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
@@ -3167,18 +3192,17 @@ ComplexMatrix::all_integers (double& max
 }
 
 bool
 ComplexMatrix::too_large_for_float (void) const
 {
   return test_any (xtoo_large_for_float);
 }
 
-// FIXME Do these really belong here?  Maybe they should be
-// in a base class?
+// FIXME: Do these really belong here?  Maybe they should be in a base class?
 
 boolMatrix
 ComplexMatrix::all (int dim) const
 {
   return do_mx_red_op<bool, Complex> (*this, dim, mx_inline_all);
 }
 
 boolMatrix
@@ -3314,17 +3338,18 @@ ComplexMatrix::row_min (Array<octave_idx
           double abs_min = octave_NaN;
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_min = elem (i, idx_j);
 
               if (! xisnan (tmp_min))
                 {
-                  abs_min = real_only ? std::real (tmp_min) : std::abs (tmp_min);
+                  abs_min = real_only ? std::real (tmp_min)
+                                      : std::abs (tmp_min);
                   break;
                 }
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               Complex tmp = elem (i, j);
 
@@ -3388,17 +3413,18 @@ ComplexMatrix::row_max (Array<octave_idx
           double abs_max = octave_NaN;
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_max = elem (i, idx_j);
 
               if (! xisnan (tmp_max))
                 {
-                  abs_max = real_only ? std::real (tmp_max) : std::abs (tmp_max);
+                  abs_max = real_only ? std::real (tmp_max)
+                                      : std::abs (tmp_max);
                   break;
                 }
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               Complex tmp = elem (i, j);
 
@@ -3462,17 +3488,18 @@ ComplexMatrix::column_min (Array<octave_
           double abs_min = octave_NaN;
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_min = elem (idx_i, j);
 
               if (! xisnan (tmp_min))
                 {
-                  abs_min = real_only ? std::real (tmp_min) : std::abs (tmp_min);
+                  abs_min = real_only ? std::real (tmp_min)
+                                      : std::abs (tmp_min);
                   break;
                 }
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               Complex tmp = elem (i, j);
 
@@ -3536,17 +3563,18 @@ ComplexMatrix::column_max (Array<octave_
           double abs_max = octave_NaN;
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_max = elem (idx_i, j);
 
               if (! xisnan (tmp_max))
                 {
-                  abs_max = real_only ? std::real (tmp_max) : std::abs (tmp_max);
+                  abs_max = real_only ? std::real (tmp_max)
+                                      : std::abs (tmp_max);
                   break;
                 }
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               Complex tmp = elem (i, j);
 
@@ -3640,36 +3668,34 @@ Givens (const Complex& x, const Complex&
 }
 
 ComplexMatrix
 Sylvester (const ComplexMatrix& a, const ComplexMatrix& b,
            const ComplexMatrix& c)
 {
   ComplexMatrix retval;
 
-  // FIXME -- need to check that a, b, and c are all the same
-  // size.
+  // FIXME: need to check that a, b, and c are all the same size.
 
   // Compute Schur decompositions
 
   ComplexSCHUR as (a, "U");
   ComplexSCHUR bs (b, "U");
 
   // Transform c to new coordinates.
 
   ComplexMatrix ua = as.unitary_matrix ();
   ComplexMatrix sch_a = as.schur_matrix ();
 
   ComplexMatrix ub = bs.unitary_matrix ();
   ComplexMatrix sch_b = bs.schur_matrix ();
 
   ComplexMatrix cx = ua.hermitian () * c * ub;
 
-  // Solve the sylvester equation, back-transform, and return the
-  // solution.
+  // Solve the sylvester equation, back-transform, and return the solution.
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type b_nr = b.rows ();
 
   double scale;
   octave_idx_type info;
 
   Complex *pa = sch_a.fortran_vec ();
@@ -3678,17 +3704,17 @@ Sylvester (const ComplexMatrix& a, const
 
   F77_XFCN (ztrsyl, ZTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              1, a_nr, b_nr, pa, a_nr, pb,
                              b_nr, px, a_nr, scale, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
-  // FIXME -- check info?
+  // FIXME: check info?
 
   retval = -ua * cx * ub.hermitian ();
 
   return retval;
 }
 
 ComplexMatrix
 operator * (const ComplexMatrix& m, const Matrix& a)
@@ -3759,17 +3785,17 @@ xgemm (const ComplexMatrix& a, const Com
   else
     {
       if (a_nr == 0 || a_nc == 0 || b_nc == 0)
         retval = ComplexMatrix (a_nr, b_nc, 0.0);
       else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
         {
           octave_idx_type lda = a.rows ();
 
-          // FIXME -- looking at the reference BLAS, it appears that it
+          // FIXME: looking at the reference BLAS, it appears that it
           // should not be necessary to initialize the output matrix if
           // BETA is 0 in the call to ZHERK, but ATLAS appears to
           // use the result matrix before zeroing the elements.
 
           retval = ComplexMatrix (a_nr, b_nc, 0.0);
           Complex *c = retval.fortran_vec ();
 
           const char ctra = get_blas_trans_arg (tra, cja);
@@ -3807,23 +3833,26 @@ xgemm (const ComplexMatrix& a, const Com
 
           retval = ComplexMatrix (a_nr, b_nc, 0.0);
           Complex *c = retval.fortran_vec ();
 
           if (b_nc == 1 && a_nr == 1)
             {
               if (cja == cjb)
                 {
-                  F77_FUNC (xzdotu, XZDOTU) (a_nc, a.data (), 1, b.data (), 1, *c);
+                  F77_FUNC (xzdotu, XZDOTU) (a_nc, a.data (), 1, b.data (), 1,
+                                             *c);
                   if (cja) *c = std::conj (*c);
                 }
               else if (cja)
-                  F77_FUNC (xzdotc, XZDOTC) (a_nc, a.data (), 1, b.data (), 1, *c);
+                F77_FUNC (xzdotc, XZDOTC) (a_nc, a.data (), 1, b.data (), 1,
+                                           *c);
               else
-                  F77_FUNC (xzdotc, XZDOTC) (a_nc, b.data (), 1, a.data (), 1, *c);
+                F77_FUNC (xzdotc, XZDOTC) (a_nc, b.data (), 1, a.data (), 1,
+                                           *c);
             }
           else if (b_nc == 1 && ! cjb)
             {
               const char ctra = get_blas_trans_arg (tra, cja);
               F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 (&ctra, 1),
                                        lda, tda, 1.0,  a.data (), lda,
                                        b.data (), 1, 0.0, c, 1
                                        F77_CHAR_ARG_LEN (1)));
@@ -3854,18 +3883,17 @@ xgemm (const ComplexMatrix& a, const Com
 }
 
 ComplexMatrix
 operator * (const ComplexMatrix& a, const ComplexMatrix& b)
 {
   return xgemm (a, b);
 }
 
-// FIXME -- it would be nice to share code among the min/max
-// functions below.
+// FIXME: it would be nice to share code among the min/max functions below.
 
 #define EMPTY_RETURN_CHECK(T) \
   if (nr == 0 || nc == 0) \
     return T (nr, nc);
 
 ComplexMatrix
 min (const Complex& c, const ComplexMatrix& m)
 {
@@ -4050,17 +4078,18 @@ ComplexMatrix linspace (const ComplexCol
                         octave_idx_type n)
 
 {
   if (n < 1) n = 1;
 
   octave_idx_type m = x1.length ();
 
   if (x2.length () != m)
-    (*current_liboctave_error_handler) ("linspace: vectors must be of equal length");
+    (*current_liboctave_error_handler)
+      ("linspace: vectors must be of equal length");
 
   NoAlias<ComplexMatrix> retval;
 
   retval.clear (m, n);
   for (octave_idx_type i = 0; i < m; i++)
     retval(i, 0) = x1(i);
 
   // The last column is not needed while using delta.
diff --git a/liboctave/array/CMatrix.h b/liboctave/array/CMatrix.h
--- a/liboctave/array/CMatrix.h
+++ b/liboctave/array/CMatrix.h
@@ -80,42 +80,53 @@ public:
 
   explicit ComplexMatrix (const ComplexDiagMatrix& a);
 
   explicit ComplexMatrix (const boolMatrix& a);
 
   explicit ComplexMatrix (const charMatrix& a);
 
   ComplexMatrix& operator = (const ComplexMatrix& a)
-    {
-      MArray<Complex>::operator = (a);
-      return *this;
-    }
+  {
+    MArray<Complex>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const ComplexMatrix& a) const;
   bool operator != (const ComplexMatrix& a) const;
 
   bool is_hermitian (void) const;
 
   // destructive insert/delete/reorder operations
 
   ComplexMatrix& insert (const Matrix& a, octave_idx_type r, octave_idx_type c);
-  ComplexMatrix& insert (const RowVector& a, octave_idx_type r, octave_idx_type c);
-  ComplexMatrix& insert (const ColumnVector& a, octave_idx_type r, octave_idx_type c);
-  ComplexMatrix& insert (const DiagMatrix& a, octave_idx_type r, octave_idx_type c);
+  ComplexMatrix& insert (const RowVector& a,
+                         octave_idx_type r, octave_idx_type c);
+  ComplexMatrix& insert (const ColumnVector& a,
+                         octave_idx_type r, octave_idx_type c);
+  ComplexMatrix& insert (const DiagMatrix& a,
+                         octave_idx_type r, octave_idx_type c);
 
-  ComplexMatrix& insert (const ComplexMatrix& a, octave_idx_type r, octave_idx_type c);
-  ComplexMatrix& insert (const ComplexRowVector& a, octave_idx_type r, octave_idx_type c);
-  ComplexMatrix& insert (const ComplexColumnVector& a, octave_idx_type r, octave_idx_type c);
-  ComplexMatrix& insert (const ComplexDiagMatrix& a, octave_idx_type r, octave_idx_type c);
+  ComplexMatrix& insert (const ComplexMatrix& a,
+                         octave_idx_type r, octave_idx_type c);
+  ComplexMatrix& insert (const ComplexRowVector& a,
+                         octave_idx_type r, octave_idx_type c);
+  ComplexMatrix& insert (const ComplexColumnVector& a,
+                         octave_idx_type r, octave_idx_type c);
+  ComplexMatrix& insert (const ComplexDiagMatrix& a,
+                         octave_idx_type r, octave_idx_type c);
 
   ComplexMatrix& fill (double val);
   ComplexMatrix& fill (const Complex& val);
-  ComplexMatrix& fill (double val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2);
-  ComplexMatrix& fill (const Complex& val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2);
+  ComplexMatrix& fill (double val,
+                       octave_idx_type r1, octave_idx_type c1,
+                       octave_idx_type r2, octave_idx_type c2);
+  ComplexMatrix& fill (const Complex& val,
+                       octave_idx_type r1, octave_idx_type c1,
+                       octave_idx_type r2, octave_idx_type c2);
 
   ComplexMatrix append (const Matrix& a) const;
   ComplexMatrix append (const RowVector& a) const;
   ComplexMatrix append (const ColumnVector& a) const;
   ComplexMatrix append (const DiagMatrix& a) const;
 
   ComplexMatrix append (const ComplexMatrix& a) const;
   ComplexMatrix append (const ComplexRowVector& a) const;
@@ -128,27 +139,29 @@ public:
   ComplexMatrix stack (const DiagMatrix& a) const;
 
   ComplexMatrix stack (const ComplexMatrix& a) const;
   ComplexMatrix stack (const ComplexRowVector& a) const;
   ComplexMatrix stack (const ComplexColumnVector& a) const;
   ComplexMatrix stack (const ComplexDiagMatrix& a) const;
 
   ComplexMatrix hermitian (void) const
-    { return MArray<Complex>::hermitian (std::conj); }
+  { return MArray<Complex>::hermitian (std::conj); }
   ComplexMatrix transpose (void) const
-    { return MArray<Complex>::transpose (); }
+  { return MArray<Complex>::transpose (); }
 
   friend OCTAVE_API ComplexMatrix conj (const ComplexMatrix& a);
 
   // resize is the destructive equivalent for this one
 
-  ComplexMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
+  ComplexMatrix extract (octave_idx_type r1, octave_idx_type c1,
+                         octave_idx_type r2, octave_idx_type c2) const;
 
-  ComplexMatrix extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const;
+  ComplexMatrix extract_n (octave_idx_type r1, octave_idx_type c1,
+                           octave_idx_type nr, octave_idx_type nc) const;
 
   // extract row or column i.
 
   ComplexRowVector row (octave_idx_type i) const;
 
   ComplexColumnVector column (octave_idx_type i) const;
 
   void resize (octave_idx_type nr, octave_idx_type nc,
@@ -181,42 +194,44 @@ public:
   ComplexMatrix fourier (void) const;
   ComplexMatrix ifourier (void) const;
 
   ComplexMatrix fourier2d (void) const;
   ComplexMatrix ifourier2d (void) const;
 
   ComplexDET determinant (void) const;
   ComplexDET determinant (octave_idx_type& info) const;
-  ComplexDET determinant (octave_idx_type& info, double& rcon, int calc_cond = 1) const;
+  ComplexDET determinant (octave_idx_type& info, double& rcon,
+                          int calc_cond = 1) const;
   ComplexDET determinant (MatrixType &mattype, octave_idx_type& info,
                           double& rcon, int calc_cond = 1) const;
 
   double rcond (void) const;
   double rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
   ComplexMatrix utsolve (MatrixType &typ, const ComplexMatrix& b,
-                  octave_idx_type& info, double& rcon,
-                  solve_singularity_handler sing_handler,
-                  bool calc_cond = false,
-                  blas_trans_type transt = blas_no_trans) const;
+                         octave_idx_type& info, double& rcon,
+                         solve_singularity_handler sing_handler,
+                         bool calc_cond = false,
+                         blas_trans_type transt = blas_no_trans) const;
 
   // Lower triangular matrix solvers
   ComplexMatrix ltsolve (MatrixType &typ, const ComplexMatrix& b,
-                  octave_idx_type& info, double& rcon,
-                  solve_singularity_handler sing_handler,
-                  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
+                         octave_idx_type& info, double& rcon,
+                         solve_singularity_handler sing_handler,
+                         bool calc_cond = false,
+                         blas_trans_type transt = blas_no_trans) const;
 
   // Full matrix solvers (umfpack/cholesky)
   ComplexMatrix fsolve (MatrixType &typ, const ComplexMatrix& b,
-                 octave_idx_type& info, double& rcon,
-                 solve_singularity_handler sing_handler,
-                 bool calc_cond = false) const;
+                        octave_idx_type& info, double& rcon,
+                        solve_singularity_handler sing_handler,
+                        bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   ComplexMatrix solve (MatrixType &typ, const Matrix& b) const;
   ComplexMatrix solve (MatrixType &typ, const Matrix& b,
                        octave_idx_type& info) const;
   ComplexMatrix solve (MatrixType &typ, const Matrix& b,
                        octave_idx_type& info, double& rcon) const;
@@ -255,42 +270,50 @@ public:
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b,
                              octave_idx_type& info, double& rcon,
                              solve_singularity_handler sing_handler,
                              blas_trans_type transt = blas_no_trans) const;
 
   // Generic interface to solver with probing of type
   ComplexMatrix solve (const Matrix& b) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info) const;
-  ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcon) const;
+  ComplexMatrix solve (const Matrix& b, octave_idx_type& info,
+                       double& rcon) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcon,
                        solve_singularity_handler sing_handler,
                        blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
-  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon) const;
-  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon,
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info,
+                       double& rcon) const;
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info,
+                       double& rcon,
                        solve_singularity_handler sing_handler,
                        blas_trans_type transt = blas_no_trans) const;
 
   ComplexColumnVector solve (const ColumnVector& b) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info,
                              double& rcon) const;
-  ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcon,
+  ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info,
+                             double& rcon,
                              solve_singularity_handler sing_handler,
                              blas_trans_type transt = blas_no_trans) const;
 
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
+  ComplexColumnVector solve (const ComplexColumnVector& b,
+                             octave_idx_type& info) const;
+  ComplexColumnVector solve (const ComplexColumnVector& b,
+                             octave_idx_type& info,
                              double& rcon) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-                             double& rcon, solve_singularity_handler sing_handler,
+  ComplexColumnVector solve (const ComplexColumnVector& b,
+                             octave_idx_type& info,
+                             double& rcon,
+                             solve_singularity_handler sing_handler,
                              blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix lssolve (const Matrix& b) const;
   ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info) const;
   ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info,
                          octave_idx_type& rank) const;
   ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info,
                          octave_idx_type& rank, double& rcon) const;
@@ -371,18 +394,20 @@ public:
   ComplexRowVector column_min (void) const;
   ComplexRowVector column_max (void) const;
 
   ComplexRowVector column_min (Array<octave_idx_type>& index) const;
   ComplexRowVector column_max (Array<octave_idx_type>& index) const;
 
   // i/o
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ComplexMatrix& a);
-  friend OCTAVE_API std::istream& operator >> (std::istream& is, ComplexMatrix& a);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const ComplexMatrix& a);
+  friend OCTAVE_API std::istream& operator >> (std::istream& is,
+                                               ComplexMatrix& a);
 };
 
 extern OCTAVE_API ComplexMatrix conj (const ComplexMatrix& a);
 
 // column vector by row vector -> matrix operations
 
 extern OCTAVE_API ComplexMatrix
 operator * (const ColumnVector& a, const ComplexRowVector& b);
@@ -399,27 +424,32 @@ Givens (const Complex&, const Complex&);
 extern OCTAVE_API ComplexMatrix
 Sylvester (const ComplexMatrix&, const ComplexMatrix&, const ComplexMatrix&);
 
 extern OCTAVE_API ComplexMatrix
 xgemm (const ComplexMatrix& a, const ComplexMatrix& b,
        blas_trans_type transa = blas_no_trans,
        blas_trans_type transb = blas_no_trans);
 
-extern OCTAVE_API ComplexMatrix operator * (const Matrix&,        const ComplexMatrix&);
-extern OCTAVE_API ComplexMatrix operator * (const ComplexMatrix&, const Matrix&);
-extern OCTAVE_API ComplexMatrix operator * (const ComplexMatrix&, const ComplexMatrix&);
+extern OCTAVE_API ComplexMatrix operator * (const Matrix&,
+                                            const ComplexMatrix&);
+extern OCTAVE_API ComplexMatrix operator * (const ComplexMatrix&,
+                                            const Matrix&);
+extern OCTAVE_API ComplexMatrix operator * (const ComplexMatrix&,
+                                            const ComplexMatrix&);
 
 extern OCTAVE_API ComplexMatrix min (const Complex& c, const ComplexMatrix& m);
 extern OCTAVE_API ComplexMatrix min (const ComplexMatrix& m, const Complex& c);
-extern OCTAVE_API ComplexMatrix min (const ComplexMatrix& a, const ComplexMatrix& b);
+extern OCTAVE_API ComplexMatrix min (const ComplexMatrix& a,
+                                     const ComplexMatrix& b);
 
 extern OCTAVE_API ComplexMatrix max (const Complex& c, const ComplexMatrix& m);
 extern OCTAVE_API ComplexMatrix max (const ComplexMatrix& m, const Complex& c);
-extern OCTAVE_API ComplexMatrix max (const ComplexMatrix& a, const ComplexMatrix& b);
+extern OCTAVE_API ComplexMatrix max (const ComplexMatrix& a,
+                                     const ComplexMatrix& b);
 
 extern OCTAVE_API ComplexMatrix linspace (const ComplexColumnVector& x1,
                                           const ComplexColumnVector& x2,
                                           octave_idx_type n);
 
 
 MS_CMP_OP_DECLS (ComplexMatrix, Complex, OCTAVE_API)
 MS_BOOL_OP_DECLS (ComplexMatrix, Complex, OCTAVE_API)
diff --git a/liboctave/array/CNDArray.cc b/liboctave/array/CNDArray.cc
--- a/liboctave/array/CNDArray.cc
+++ b/liboctave/array/CNDArray.cc
@@ -106,17 +106,17 @@ ComplexNDArray::ifourier (int dim) const
 
   const Complex *in (fortran_vec ());
   ComplexNDArray retval (dv);
   Complex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
     octave_fftw::ifft (in + k * stride * n, out + k * stride * n,
-                      n, howmany, stride, dist);
+                       n, howmany, stride, dist);
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::fourier2d (void) const
 {
   dim_vector dv = dims ();
@@ -288,17 +288,17 @@ ComplexNDArray::ifourier (int dim) const
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (zfftb, ZFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i] /
-              static_cast<double> (npts);
+                                                   static_cast<double> (npts);
         }
     }
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::fourier2d (void) const
@@ -381,18 +381,18 @@ ComplexNDArray::ifourier2d (void) const
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
                 prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) = prow[l] /
-                  static_cast<double> (npts);
+                retval((l + k*npts)*stride + j*dist) =
+                  prow[l] / static_cast<double> (npts);
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
@@ -476,18 +476,18 @@ ComplexNDArray::ifourierNd (void) const
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
                 prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) = prow[l] /
-                  static_cast<double> (npts);
+                retval((l + k*npts)*stride + j*dist) =
+                  prow[l] / static_cast<double> (npts);
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
 }
@@ -500,17 +500,17 @@ boolNDArray
 ComplexNDArray::operator ! (void) const
 {
   if (any_element_is_nan ())
     gripe_nan_to_logical_conversion ();
 
   return do_mx_unary_op<bool, Complex> (*this, mx_inline_not);
 }
 
-// FIXME -- this is not quite the right thing.
+// FIXME: this is not quite the right thing.
 
 bool
 ComplexNDArray::any_element_is_nan (void) const
 {
   return do_mx_check<Complex> (*this, mx_inline_any_nan);
 }
 
 bool
@@ -637,17 +637,18 @@ ComplexNDArray::sumsq (int dim) const
 
 ComplexNDArray
 ComplexNDArray::diff (octave_idx_type order, int dim) const
 {
   return do_mx_diff_op<Complex> (*this, dim, order, mx_inline_diff);
 }
 
 ComplexNDArray
-ComplexNDArray::concat (const ComplexNDArray& rb, const Array<octave_idx_type>& ra_idx)
+ComplexNDArray::concat (const ComplexNDArray& rb,
+                        const Array<octave_idx_type>& ra_idx)
 {
   if (rb.numel () > 0)
     insert (rb, ra_idx);
   return *this;
 }
 
 ComplexNDArray
 ComplexNDArray::concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx)
@@ -793,36 +794,38 @@ ComplexNDArray::insert (const NDArray& a
   else
     (*current_liboctave_error_handler)
       ("Array<T>::insert: invalid indexing operation");
 
   return *this;
 }
 
 ComplexNDArray&
-ComplexNDArray::insert (const ComplexNDArray& a, octave_idx_type r, octave_idx_type c)
+ComplexNDArray::insert (const ComplexNDArray& a,
+                        octave_idx_type r, octave_idx_type c)
 {
   Array<Complex>::insert (a, r, c);
   return *this;
 }
 
 ComplexNDArray&
-ComplexNDArray::insert (const ComplexNDArray& a, const Array<octave_idx_type>& ra_idx)
+ComplexNDArray::insert (const ComplexNDArray& a,
+                        const Array<octave_idx_type>& ra_idx)
 {
   Array<Complex>::insert (a, ra_idx);
   return *this;
 }
 
 ComplexMatrix
 ComplexNDArray::matrix_value (void) const
 {
   ComplexMatrix retval;
 
   if (ndims () == 2)
-      retval = ComplexMatrix (Array<Complex> (*this));
+    retval = ComplexMatrix (Array<Complex> (*this));
   else
     (*current_liboctave_error_handler)
       ("invalid conversion of ComplexNDArray to ComplexMatrix");
 
   return retval;
 }
 
 void
@@ -871,26 +874,26 @@ std::istream&
 operator >> (std::istream& is, ComplexNDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
   if (nel > 0)
     {
       Complex tmp;
       for (octave_idx_type i = 0; i < nel; i++)
-          {
-            tmp = octave_read_value<Complex> (is);
-            if (is)
-              a.elem (i) = tmp;
-            else
-              goto done;
-          }
+        {
+          tmp = octave_read_value<Complex> (is);
+          if (is)
+            a.elem (i) = tmp;
+          else
+            goto done;
+        }
     }
 
- done:
+done:
 
   return is;
 }
 
 MINMAX_FCNS (ComplexNDArray, Complex)
 
 NDS_CMP_OPS (ComplexNDArray, Complex)
 NDS_BOOL_OPS (ComplexNDArray, Complex)
diff --git a/liboctave/array/CNDArray.h b/liboctave/array/CNDArray.h
--- a/liboctave/array/CNDArray.h
+++ b/liboctave/array/CNDArray.h
@@ -53,60 +53,65 @@ public:
   ComplexNDArray (const MArray<U>& a) : MArray<Complex> (a) { }
 
   template <class U>
   ComplexNDArray (const Array<U>& a) : MArray<Complex> (a) { }
 
   ComplexNDArray (const charNDArray&);
 
   ComplexNDArray& operator = (const ComplexNDArray& a)
-    {
-      MArray<Complex>::operator = (a);
-      return *this;
-    }
+  {
+    MArray<Complex>::operator = (a);
+    return *this;
+  }
 
   // unary operations
 
   boolNDArray operator ! (void) const;
 
-  // FIXME -- this is not quite the right thing.
+  // FIXME: this is not quite the right thing.
 
   bool any_element_is_nan (void) const;
   bool any_element_is_inf_or_nan (void) const;
   bool all_elements_are_real (void) const;
   bool all_integers (double& max_val, double& min_val) const;
   bool too_large_for_float (void) const;
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
   ComplexNDArray cumprod (int dim = -1) const;
   ComplexNDArray cumsum (int dim = -1) const;
   ComplexNDArray prod (int dim = -1) const;
   ComplexNDArray sum (int dim = -1) const;
   ComplexNDArray xsum (int dim = -1) const;
   ComplexNDArray sumsq (int dim = -1) const;
-  ComplexNDArray concat (const ComplexNDArray& rb, const Array<octave_idx_type>& ra_idx);
-  ComplexNDArray concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx);
+  ComplexNDArray concat (const ComplexNDArray& rb,
+                         const Array<octave_idx_type>& ra_idx);
+  ComplexNDArray concat (const NDArray& rb,
+                         const Array<octave_idx_type>& ra_idx);
 
   ComplexNDArray max (int dim = -1) const;
   ComplexNDArray max (Array<octave_idx_type>& index, int dim = -1) const;
   ComplexNDArray min (int dim = -1) const;
   ComplexNDArray min (Array<octave_idx_type>& index, int dim = -1) const;
 
   ComplexNDArray cummax (int dim = -1) const;
   ComplexNDArray cummax (Array<octave_idx_type>& index, int dim = -1) const;
   ComplexNDArray cummin (int dim = -1) const;
   ComplexNDArray cummin (Array<octave_idx_type>& index, int dim = -1) const;
 
   ComplexNDArray diff (octave_idx_type order = 1, int dim = -1) const;
 
-  ComplexNDArray& insert (const NDArray& a, octave_idx_type r, octave_idx_type c);
-  ComplexNDArray& insert (const ComplexNDArray& a, octave_idx_type r, octave_idx_type c);
-  ComplexNDArray& insert (const ComplexNDArray& a, const Array<octave_idx_type>& ra_idx);
+  ComplexNDArray& insert (const NDArray& a,
+                          octave_idx_type r, octave_idx_type c);
+  ComplexNDArray& insert (const ComplexNDArray& a,
+                          octave_idx_type r, octave_idx_type c);
+  ComplexNDArray& insert (const ComplexNDArray& a,
+                          const Array<octave_idx_type>& ra_idx);
 
   NDArray abs (void) const;
   boolNDArray isnan (void) const;
   boolNDArray isinf (void) const;
   boolNDArray isfinite (void) const;
 
   friend OCTAVE_API ComplexNDArray conj (const ComplexNDArray& a);
 
@@ -123,35 +128,37 @@ public:
 
   ComplexNDArray squeeze (void) const { return MArray<Complex>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
-                            const dim_vector& dimensions);
+                                        const dim_vector& dimensions);
 
   // i/o
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ComplexNDArray& a);
-  friend OCTAVE_API std::istream& operator >> (std::istream& is, ComplexNDArray& a);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const ComplexNDArray& a);
+  friend OCTAVE_API std::istream& operator >> (std::istream& is,
+                                               ComplexNDArray& a);
 
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (double& max_val, double& min_val) const;
 
   ComplexNDArray diag (octave_idx_type k = 0) const;
 
   ComplexNDArray diag (octave_idx_type m, octave_idx_type n) const;
 
   ComplexNDArray& changesign (void)
-    {
-      MArray<Complex>::changesign ();
-      return *this;
-    }
+  {
+    MArray<Complex>::changesign ();
+    return *this;
+  }
 
 };
 
 extern OCTAVE_API ComplexNDArray conj (const ComplexNDArray& a);
 
 MINMAX_DECLS (ComplexNDArray, Complex, OCTAVE_API)
 
 NDS_CMP_OP_DECLS (ComplexNDArray, Complex, OCTAVE_API)
diff --git a/liboctave/array/CRowVector.cc b/liboctave/array/CRowVector.cc
--- a/liboctave/array/CRowVector.cc
+++ b/liboctave/array/CRowVector.cc
@@ -169,17 +169,18 @@ ComplexRowVector::fill (double val, octa
       for (octave_idx_type i = c1; i <= c2; i++)
         xelem (i) = val;
     }
 
   return *this;
 }
 
 ComplexRowVector&
-ComplexRowVector::fill (const Complex& val, octave_idx_type c1, octave_idx_type c2)
+ComplexRowVector::fill (const Complex& val,
+                        octave_idx_type c1, octave_idx_type c2)
 {
   octave_idx_type len = length ();
 
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
diff --git a/liboctave/array/CRowVector.h b/liboctave/array/CRowVector.h
--- a/liboctave/array/CRowVector.h
+++ b/liboctave/array/CRowVector.h
@@ -27,21 +27,21 @@ along with Octave; see the file COPYING.
 #include "dRowVector.h"
 
 #include "mx-defs.h"
 
 class
 OCTAVE_API
 ComplexRowVector : public MArray<Complex>
 {
-friend class ComplexColumnVector;
+  friend class ComplexColumnVector;
 
 public:
 
- ComplexRowVector (void) : MArray<Complex> (dim_vector (1, 0)) { }
+  ComplexRowVector (void) : MArray<Complex> (dim_vector (1, 0)) { }
 
   explicit ComplexRowVector (octave_idx_type n)
     : MArray<Complex> (dim_vector (1, n)) { }
 
   explicit ComplexRowVector (const dim_vector& dv) : MArray<Complex> (dv) { }
 
   ComplexRowVector (octave_idx_type n, const Complex& val)
     : MArray<Complex> (dim_vector (1, n), val) { }
@@ -52,33 +52,34 @@ public:
     : MArray<Complex> (a.as_row ()) { }
 
   ComplexRowVector (const Array<Complex>& a)
     : MArray<Complex> (a.as_row ()) { }
 
   explicit ComplexRowVector (const RowVector& a) : MArray<Complex> (a) { }
 
   ComplexRowVector& operator = (const ComplexRowVector& a)
-    {
-      MArray<Complex>::operator = (a);
-      return *this;
-    }
+  {
+    MArray<Complex>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const ComplexRowVector& a) const;
   bool operator != (const ComplexRowVector& a) const;
 
   // destructive insert/delete/reorder operations
 
   ComplexRowVector& insert (const RowVector& a, octave_idx_type c);
   ComplexRowVector& insert (const ComplexRowVector& a, octave_idx_type c);
 
   ComplexRowVector& fill (double val);
   ComplexRowVector& fill (const Complex& val);
   ComplexRowVector& fill (double val, octave_idx_type c1, octave_idx_type c2);
-  ComplexRowVector& fill (const Complex& val, octave_idx_type c1, octave_idx_type c2);
+  ComplexRowVector& fill (const Complex& val,
+                          octave_idx_type c1, octave_idx_type c2);
 
   ComplexRowVector append (const RowVector& a) const;
   ComplexRowVector append (const ComplexRowVector& a) const;
 
   ComplexColumnVector hermitian (void) const;
   ComplexColumnVector transpose (void) const;
 
   friend ComplexRowVector conj (const ComplexRowVector& a);
@@ -104,34 +105,38 @@ public:
 
   // other operations
 
   Complex min (void) const;
   Complex max (void) const;
 
   // i/o
 
-  friend std::ostream& operator << (std::ostream& os, const ComplexRowVector& a);
+  friend std::ostream& operator << (std::ostream& os,
+                                    const ComplexRowVector& a);
   friend std::istream& operator >> (std::istream& is, ComplexRowVector& a);
 
   void resize (octave_idx_type n, const Complex& rfv = Complex (0))
   {
     Array<Complex>::resize (dim_vector (1, n), rfv);
   }
 
   void clear (octave_idx_type n)
-    { Array<Complex>::clear (1, n); }
+  { Array<Complex>::clear (1, n); }
 
 };
 
 // row vector by column vector -> scalar
 
-Complex OCTAVE_API operator * (const ComplexRowVector& a, const ColumnVector& b);
+Complex OCTAVE_API operator * (const ComplexRowVector& a,
+                               const ColumnVector& b);
 
-Complex OCTAVE_API operator * (const ComplexRowVector& a, const ComplexColumnVector& b);
+Complex OCTAVE_API operator * (const ComplexRowVector& a,
+                               const ComplexColumnVector& b);
 
 // other operations
 
-OCTAVE_API ComplexRowVector linspace (const Complex& x1, const Complex& x2, octave_idx_type n);
+OCTAVE_API ComplexRowVector linspace (const Complex& x1, const Complex& x2,
+                                      octave_idx_type n);
 
 MARRAY_FORWARD_DEFS (MArray, ComplexRowVector, Complex)
 
 #endif
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -184,17 +184,17 @@ SparseComplexMatrix::operator == (const 
   octave_idx_type nc_a = a.cols ();
   octave_idx_type nz_a = a.nnz ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     if (cidx (i) != a.cidx (i))
-        return false;
+      return false;
 
   for (octave_idx_type i = 0; i < nz; i++)
     if (data (i) != a.data (i) || ridx (i) != a.ridx (i))
       return false;
 
   return true;
 }
 
@@ -346,17 +346,17 @@ SparseComplexMatrix::max (Array<octave_i
 
       for (octave_idx_type i = 0; i < nr; i++)
         found [i] = 0;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
           if (found [ridx (i)] == -j)
             found [ridx (i)] = -j - 1;
-      
+
       for (octave_idx_type i = 0; i < nr; i++)
         if (found [i] > -nc && found [i] < 0)
           idx_arg.elem (i) = -found [i];
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
@@ -503,17 +503,17 @@ SparseComplexMatrix::min (Array<octave_i
 
       for (octave_idx_type i = 0; i < nr; i++)
         found [i] = 0;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
           if (found [ridx (i)] == -j)
             found [ridx (i)] = -j - 1;
-      
+
       for (octave_idx_type i = 0; i < nr; i++)
         if (found [i] > -nc && found [i] < 0)
           idx_arg.elem (i) = -found [i];
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
@@ -558,26 +558,26 @@ SparseComplexMatrix::min (Array<octave_i
         }
     }
 
   return result;
 }
 
 /*
 
-%!assert (max (max (speye (65536) * 1i)), sparse (1i)) 
-%!assert (min (min (speye (65536) * 1i)), sparse (0)) 
-%!assert (size (max (sparse (8, 0), [], 1)), [1, 0]) 
-%!assert (size (max (sparse (8, 0), [], 2)), [8, 0]) 
-%!assert (size (max (sparse (0, 8), [], 1)), [0, 8]) 
-%!assert (size (max (sparse (0, 8), [], 2)), [0, 1]) 
-%!assert (size (min (sparse (8, 0), [], 1)), [1, 0]) 
-%!assert (size (min (sparse (8, 0), [], 2)), [8, 0]) 
-%!assert (size (min (sparse (0, 8), [], 1)), [0, 8]) 
-%!assert (size (min (sparse (0, 8), [], 2)), [0, 1]) 
+%!assert (max (max (speye (65536) * 1i)), sparse (1i))
+%!assert (min (min (speye (65536) * 1i)), sparse (0))
+%!assert (size (max (sparse (8, 0), [], 1)), [1, 0])
+%!assert (size (max (sparse (8, 0), [], 2)), [8, 0])
+%!assert (size (max (sparse (0, 8), [], 1)), [0, 8])
+%!assert (size (max (sparse (0, 8), [], 2)), [0, 1])
+%!assert (size (min (sparse (8, 0), [], 1)), [1, 0])
+%!assert (size (min (sparse (8, 0), [], 2)), [8, 0])
+%!assert (size (min (sparse (0, 8), [], 1)), [0, 8])
+%!assert (size (min (sparse (0, 8), [], 2)), [0, 1])
 
 */
 
 ComplexRowVector
 SparseComplexMatrix::row (octave_idx_type i) const
 {
   octave_idx_type nc = columns ();
   ComplexRowVector retval (nc, 0);
@@ -605,55 +605,60 @@ SparseComplexMatrix::column (octave_idx_
     retval(ridx (k)) = data (k);
 
   return retval;
 }
 
 // destructive insert/delete/reorder operations
 
 SparseComplexMatrix&
-SparseComplexMatrix::insert (const SparseMatrix& a, octave_idx_type r, octave_idx_type c)
+SparseComplexMatrix::insert (const SparseMatrix& a,
+                             octave_idx_type r, octave_idx_type c)
 {
   SparseComplexMatrix tmp (a);
   return insert (tmp /*a*/, r, c);
 }
 
 SparseComplexMatrix&
-SparseComplexMatrix::insert (const SparseComplexMatrix& a, octave_idx_type r, octave_idx_type c)
+SparseComplexMatrix::insert (const SparseComplexMatrix& a,
+                             octave_idx_type r, octave_idx_type c)
 {
   MSparse<Complex>::insert (a, r, c);
   return *this;
 }
 
 SparseComplexMatrix&
-SparseComplexMatrix::insert (const SparseMatrix& a, const Array<octave_idx_type>& indx)
+SparseComplexMatrix::insert (const SparseMatrix& a,
+                             const Array<octave_idx_type>& indx)
 {
   SparseComplexMatrix tmp (a);
   return insert (tmp /*a*/, indx);
 }
 
 SparseComplexMatrix&
-SparseComplexMatrix::insert (const SparseComplexMatrix& a, const Array<octave_idx_type>& indx)
+SparseComplexMatrix::insert (const SparseComplexMatrix& a,
+                             const Array<octave_idx_type>& indx)
 {
   MSparse<Complex>::insert (a, indx);
   return *this;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::concat (const SparseComplexMatrix& rb,
                              const Array<octave_idx_type>& ra_idx)
 {
   // Don't use numel to avoid all possiblity of an overflow
   if (rb.rows () > 0 && rb.cols () > 0)
     insert (rb, ra_idx(0), ra_idx(1));
   return *this;
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::concat (const SparseMatrix& rb, const Array<octave_idx_type>& ra_idx)
+SparseComplexMatrix::concat (const SparseMatrix& rb,
+                             const Array<octave_idx_type>& ra_idx)
 {
   SparseComplexMatrix tmp (rb);
   if (rb.rows () > 0 && rb.cols () > 0)
     insert (tmp, ra_idx(0), ra_idx(1));
   return *this;
 }
 
 ComplexMatrix
@@ -737,18 +742,18 @@ SparseComplexMatrix
 SparseComplexMatrix::inverse (MatrixType& mattype, octave_idx_type& info) const
 {
   double rcond;
   return inverse (mattype, info, rcond, 0, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::dinverse (MatrixType &mattyp, octave_idx_type& info,
-                        double& rcond, const bool,
-                        const bool calccond) const
+                               double& rcond, const bool,
+                               const bool calccond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   info = 0;
 
   if (nr == 0 || nc == 0 || nr != nc)
@@ -1063,17 +1068,17 @@ SparseComplexMatrix::tinverse (MatrixTyp
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 
- inverse_singular:
+inverse_singular:
   return SparseComplexMatrix ();
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::inverse (MatrixType& mattype, octave_idx_type& info,
                               double& rcond, int, int calc_cond) const
 {
   int typ = mattype.type (false);
@@ -1098,17 +1103,18 @@ SparseComplexMatrix::inverse (MatrixType
           MatrixType tmp_typ (MatrixType::Upper);
           SparseComplexCHOL fact (*this, info, false);
           rcond = fact.rcond ();
           if (info == 0)
             {
               double rcond2;
               SparseMatrix Q = fact.Q ();
               SparseComplexMatrix InvL = fact.L ().transpose ().
-                tinverse (tmp_typ, info, rcond2, true, false);
+                                         tinverse (tmp_typ, info, rcond2,
+                                                   true, false);
               ret = Q * InvL.hermitian () * InvL * Q.transpose ();
             }
           else
             {
               // Matrix is either singular or not positive definite
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
@@ -1121,19 +1127,21 @@ SparseComplexMatrix::inverse (MatrixType
           for (octave_idx_type i = 0; i < n; i++)
             Qinit(i) = i;
 
           MatrixType tmp_typ (MatrixType::Upper);
           SparseComplexLU fact (*this, Qinit, Matrix (), false, false);
           rcond = fact.rcond ();
           double rcond2;
           SparseComplexMatrix InvL = fact.L ().transpose ().
-            tinverse (tmp_typ, info, rcond2, true, false);
+                                     tinverse (tmp_typ, info, rcond2,
+                                               true, false);
           SparseComplexMatrix InvU = fact.U ().
-            tinverse (tmp_typ, info, rcond2, true, false).transpose ();
+                                     tinverse (tmp_typ, info, rcond2,
+                                               true, false).transpose ();
           ret = fact.Pc ().transpose () * InvU * InvL * fact.Pr ();
         }
     }
 
   return ret;
 }
 
 ComplexDET
@@ -1147,17 +1155,18 @@ SparseComplexMatrix::determinant (void) 
 ComplexDET
 SparseComplexMatrix::determinant (octave_idx_type& info) const
 {
   double rcond;
   return determinant (info, rcond, 0);
 }
 
 ComplexDET
-SparseComplexMatrix::determinant (octave_idx_type& err, double& rcond, int) const
+SparseComplexMatrix::determinant (octave_idx_type& err, double& rcond,
+                                  int) const
 {
   ComplexDET retval;
 #ifdef HAVE_UMFPACK
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
@@ -1201,39 +1210,39 @@ SparseComplexMatrix::determinant (octave
       UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai,
                                      reinterpret_cast<const double *> (Ax),
                                      0, 1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status = UMFPACK_ZNAME (qsymbolic)
-        (nr, nc, Ap, Ai, reinterpret_cast<const double *> (Ax), 0,
-         0, &Symbolic, control, info);
+                   (nr, nc, Ap, Ai, reinterpret_cast<const double *> (Ax), 0,
+                    0, &Symbolic, control, info);
 
       if (status < 0)
         {
           (*current_liboctave_error_handler)
             ("SparseComplexMatrix::determinant symbolic factorization failed");
 
           UMFPACK_ZNAME (report_status) (control, status);
           UMFPACK_ZNAME (report_info) (control, info);
 
-          UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
+          UMFPACK_ZNAME (free_symbolic) (&Symbolic);
         }
       else
         {
           UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
           void *Numeric;
           status
             = UMFPACK_ZNAME (numeric) (Ap, Ai,
                                        reinterpret_cast<const double *> (Ax),
-                                       0, Symbolic, &Numeric, control, info) ;
-          UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
+                                       0, Symbolic, &Numeric, control, info);
+          UMFPACK_ZNAME (free_symbolic) (&Symbolic);
 
           rcond = Info (UMFPACK_RCOND);
 
           if (status < 0)
             {
               (*current_liboctave_error_handler)
                 ("SparseComplexMatrix::determinant numeric factorization failed");
 
@@ -1297,18 +1306,18 @@ SparseComplexMatrix::dsolve (MatrixType 
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
           retval.resize (nc, b.cols (), Complex (0.,0.));
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
-                for (octave_idx_type i = 0; i < nm; i++)
-                  retval(i,j) = b(i,j) / data (i);
+              for (octave_idx_type i = 0; i < nm; i++)
+                retval(i,j) = b(i,j) / data (i);
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type k = 0; k < nc; k++)
                 for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
                   retval(k,j) = b(ridx (i),j) / data (i);
 
           if (calc_cond)
             {
@@ -3894,17 +3903,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
 
             }
           else
             rcond = 1.;
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
-               (*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::trisolve (MatrixType &mattype, const SparseMatrix& b,
                                octave_idx_type& err, double& rcond,
@@ -4434,20 +4443,20 @@ SparseComplexMatrix::bsolve (MatrixType 
               if (calc_cond)
                 {
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON,
-                    (F77_CONST_CHAR_ARG2 (&job, 1),
-                     nr, n_lower, tmp_data, ldm,
-                     anorm, rcond, pz, piz, err
-                     F77_CHAR_ARG_LEN (1)));
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, n_lower, tmp_data, ldm,
+                             anorm, rcond, pz, piz, err
+                             F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
@@ -4555,22 +4564,22 @@ SparseComplexMatrix::bsolve (MatrixType 
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zgbcon, ZGBCON,
-                    (F77_CONST_CHAR_ARG2 (&job, 1),
-                     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-                     anorm, rcond, pz, piz, err
-                     F77_CHAR_ARG_LEN (1)));
-
-                   if (err != 0)
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+                             anorm, rcond, pz, piz, err
+                             F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -4681,20 +4690,20 @@ SparseComplexMatrix::bsolve (MatrixType 
               if (calc_cond)
                 {
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON,
-                    (F77_CONST_CHAR_ARG2 (&job, 1),
-                     nr, n_lower, tmp_data, ldm,
-                     anorm, rcond, pz, piz, err
-                     F77_CHAR_ARG_LEN (1)));
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, n_lower, tmp_data, ldm,
+                             anorm, rcond, pz, piz, err
+                             F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
@@ -4750,17 +4759,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                         {
                           Complex tmp = Bx[i];
                           if (tmp != 0.0)
                             {
                               if (ii == x_nz)
                                 {
                                   // Resize the sparse matrix
                                   octave_idx_type sz = x_nz *
-                                    (b_nc - j) / b_nc;
+                                                       (b_nc - j) / b_nc;
                                   sz = (sz > 10 ? sz : 10) + x_nz;
                                   retval.change_capacity (sz);
                                   x_nz = sz;
                                 }
                               retval.xdata (ii) = tmp;
                               retval.xridx (ii++) = i;
                             }
                         }
@@ -4817,18 +4826,18 @@ SparseComplexMatrix::bsolve (MatrixType 
 
           if (err != 0)
             {
               rcond = 0.0;
               err = -2;
 
               if (sing_handler)
                 {
-                sing_handler (rcond);
-                mattype.mark_as_rectangular ();
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
                 }
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
 
             }
           else
             {
@@ -4836,22 +4845,22 @@ SparseComplexMatrix::bsolve (MatrixType 
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zgbcon, ZGBCON,
-                    (F77_CONST_CHAR_ARG2 (&job, 1),
-                     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-                     anorm, rcond, pz, piz, err
-                     F77_CHAR_ARG_LEN (1)));
-
-                   if (err != 0)
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+                             anorm, rcond, pz, piz, err
+                             F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -5001,20 +5010,20 @@ SparseComplexMatrix::bsolve (MatrixType 
               if (calc_cond)
                 {
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON,
-                    (F77_CONST_CHAR_ARG2 (&job, 1),
-                     nr, n_lower, tmp_data, ldm,
-                     anorm, rcond, pz, piz, err
-                     F77_CHAR_ARG_LEN (1)));
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, n_lower, tmp_data, ldm,
+                             anorm, rcond, pz, piz, err
+                             F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
@@ -5120,22 +5129,22 @@ SparseComplexMatrix::bsolve (MatrixType 
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zgbcon, ZGBCON,
-                    (F77_CONST_CHAR_ARG2 (&job, 1),
-                     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-                     anorm, rcond, pz, piz, err
-                     F77_CHAR_ARG_LEN (1)));
-
-                   if (err != 0)
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+                             anorm, rcond, pz, piz, err
+                             F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -5248,20 +5257,20 @@ SparseComplexMatrix::bsolve (MatrixType 
               if (calc_cond)
                 {
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON,
-                    (F77_CONST_CHAR_ARG2 (&job, 1),
-                     nr, n_lower, tmp_data, ldm,
-                     anorm, rcond, pz, piz, err
-                     F77_CHAR_ARG_LEN (1)));
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, n_lower, tmp_data, ldm,
+                             anorm, rcond, pz, piz, err
+                             F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
@@ -5408,22 +5417,22 @@ SparseComplexMatrix::bsolve (MatrixType 
                 {
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zgbcon, ZGBCON,
-                    (F77_CONST_CHAR_ARG2 (&job, 1),
-                     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-                     anorm, rcond, pz, piz, err
-                     F77_CHAR_ARG_LEN (1)));
-
-                   if (err != 0)
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+                             anorm, rcond, pz, piz, err
+                             F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -5544,38 +5553,38 @@ SparseComplexMatrix::factorize (octave_i
   UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai,
                                  reinterpret_cast<const double *> (Ax),
                                  0, 1, control);
 
   void *Symbolic;
   Info = Matrix (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai,
-                                     reinterpret_cast<const double *> (Ax),
-                                     0, 0, &Symbolic, control, info);
+                                          reinterpret_cast<const double *> (Ax),
+                                          0, 0, &Symbolic, control, info);
 
   if (status < 0)
     {
       (*current_liboctave_error_handler)
         ("SparseComplexMatrix::solve symbolic factorization failed");
       err = -1;
 
       UMFPACK_ZNAME (report_status) (control, status);
       UMFPACK_ZNAME (report_info) (control, info);
 
-      UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
+      UMFPACK_ZNAME (free_symbolic) (&Symbolic);
     }
   else
     {
       UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
       status = UMFPACK_ZNAME (numeric) (Ap, Ai,
-                                   reinterpret_cast<const double *> (Ax), 0,
-                                   Symbolic, &Numeric, control, info) ;
-      UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
+                                        reinterpret_cast<const double *> (Ax),
+                                        0, Symbolic, &Numeric, control, info);
+      UMFPACK_ZNAME (free_symbolic) (&Symbolic);
 
       if (calc_cond)
         rcond = Info (UMFPACK_RCOND);
       else
         rcond = 1.;
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (status == UMFPACK_WARNING_singular_matrix ||
@@ -5589,29 +5598,29 @@ SparseComplexMatrix::factorize (octave_i
             sing_handler (rcond);
           else
             (*current_liboctave_error_handler)
               ("SparseComplexMatrix::solve matrix singular to machine precision, rcond = %g",
                rcond);
 
         }
       else if (status < 0)
-          {
-            (*current_liboctave_error_handler)
-              ("SparseComplexMatrix::solve numeric factorization failed");
-
-            UMFPACK_ZNAME (report_status) (control, status);
-            UMFPACK_ZNAME (report_info) (control, info);
-
-            err = -1;
-          }
-        else
-          {
-            UMFPACK_ZNAME (report_numeric) (Numeric, control);
-          }
+        {
+          (*current_liboctave_error_handler)
+            ("SparseComplexMatrix::solve numeric factorization failed");
+
+          UMFPACK_ZNAME (report_status) (control, status);
+          UMFPACK_ZNAME (report_info) (control, info);
+
+          err = -1;
+        }
+      else
+        {
+          UMFPACK_ZNAME (report_numeric) (Numeric, control);
+        }
     }
 
   if (err != 0)
     UMFPACK_ZNAME (free_numeric) (&Numeric);
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
@@ -5803,36 +5812,36 @@ SparseComplexMatrix::fsolve (MatrixType 
 #endif
               retval.resize (b_nr, b_nc);
               Complex *Xx = retval.fortran_vec ();
 
               for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
                 {
 #ifdef UMFPACK_SEPARATE_SPLIT
                   status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
-                                             Ai,
-                                             reinterpret_cast<const double *> (Ax),
-                                             0,
-                                             reinterpret_cast<double *> (&Xx[iidx]),
-                                             0,
-                                             &Bx[iidx], Bz, Numeric,
-                                             control, info);
+                                                  Ai,
+                                                  reinterpret_cast<const double *> (Ax),
+                                                  0,
+                                                  reinterpret_cast<double *> (&Xx[iidx]),
+                                                  0,
+                                                  &Bx[iidx], Bz, Numeric,
+                                                  control, info);
 #else
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bz[i] = b.elem (i, j);
 
                   status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
-                                             Ai,
-                                             reinterpret_cast<const double *> (Ax),
-                                             0,
-                                             reinterpret_cast<double *> (&Xx[iidx]),
-                                             0,
-                                             reinterpret_cast<const double *> (Bz),
-                                             0, Numeric,
-                                             control, info);
+                                                  Ai,
+                                                  reinterpret_cast<const double *> (Ax),
+                                                  0,
+                                                  reinterpret_cast<double *> (&Xx[iidx]),
+                                                  0,
+                                                  reinterpret_cast<const double *> (Bz),
+                                                  0, Numeric,
+                                                  control, info);
 #endif
 
                   if (status < 0)
                     {
                       (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
 
                       UMFPACK_ZNAME (report_status) (control, status);
@@ -6000,19 +6009,19 @@ SparseComplexMatrix::fsolve (MatrixType 
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval = SparseComplexMatrix
-                (static_cast<octave_idx_type>(X->nrow),
-                 static_cast<octave_idx_type>(X->ncol),
-                 static_cast<octave_idx_type>(X->nzmax));
+                       (static_cast<octave_idx_type>(X->nrow),
+                        static_cast<octave_idx_type>(X->ncol),
+                        static_cast<octave_idx_type>(X->nzmax));
               for (octave_idx_type j = 0;
                    j <= static_cast<octave_idx_type>(X->ncol); j++)
                 retval.xcidx (j) = static_cast<octave_idx_type *>(X->p)[j];
               for (octave_idx_type j = 0;
                    j < static_cast<octave_idx_type>(X->nzmax); j++)
                 {
                   retval.xridx (j) = static_cast<octave_idx_type *>(X->i)[j];
                   retval.xdata (j) = static_cast<Complex *>(X->x)[j];
@@ -6074,36 +6083,36 @@ SparseComplexMatrix::fsolve (MatrixType 
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
 
 #ifdef UMFPACK_SEPARATE_SPLIT
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b.elem (i, j);
 
                   status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
-                                             Ai,
-                                             reinterpret_cast<const double *> (Ax),
-                                             0,
-                                             reinterpret_cast<double *> (Xx),
-                                             0,
-                                             Bx, Bz, Numeric, control,
-                                             info);
+                                                  Ai,
+                                                  reinterpret_cast<const double *> (Ax),
+                                                  0,
+                                                  reinterpret_cast<double *> (Xx),
+                                                  0,
+                                                  Bx, Bz, Numeric, control,
+                                                  info);
 #else
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bz[i] = b.elem (i, j);
 
                   status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap, Ai,
-                                             reinterpret_cast<const double *> (Ax),
-                                             0,
-                                             reinterpret_cast<double *> (Xx),
-                                             0,
-                                             reinterpret_cast<double *> (Bz),
-                                             0,
-                                             Numeric, control,
-                                             info);
+                                                  reinterpret_cast<const double *> (Ax),
+                                                  0,
+                                                  reinterpret_cast<double *> (Xx),
+                                                  0,
+                                                  reinterpret_cast<double *> (Bz),
+                                                  0,
+                                                  Numeric, control,
+                                                  info);
 #endif
                   if (status < 0)
                     {
                       (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
 
                       UMFPACK_ZNAME (report_status) (control, status);
 
@@ -6331,22 +6340,22 @@ SparseComplexMatrix::fsolve (MatrixType 
 
               retval.resize (b_nr, b_nc);
               Complex *Xx = retval.fortran_vec ();
 
               for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
                 {
                   status =
                     UMFPACK_ZNAME (solve) (UMFPACK_A, Ap, Ai,
-                                      reinterpret_cast<const double *> (Ax),
-                                      0,
-                                      reinterpret_cast<double *> (&Xx[iidx]),
-                                      0,
-                                      reinterpret_cast<const double *> (&Bx[iidx]),
-                                      0, Numeric, control, info);
+                                           reinterpret_cast<const double *> (Ax),
+                                           0,
+                                           reinterpret_cast<double *> (&Xx[iidx]),
+                                           0,
+                                           reinterpret_cast<const double *> (&Bx[iidx]),
+                                           0, Numeric, control, info);
 
                   if (status < 0)
                     {
                       (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
 
                       UMFPACK_ZNAME (report_status) (control, status);
 
@@ -6513,19 +6522,19 @@ SparseComplexMatrix::fsolve (MatrixType 
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval = SparseComplexMatrix
-                (static_cast<octave_idx_type>(X->nrow),
-                 static_cast<octave_idx_type>(X->ncol),
-                 static_cast<octave_idx_type>(X->nzmax));
+                       (static_cast<octave_idx_type>(X->nrow),
+                        static_cast<octave_idx_type>(X->ncol),
+                        static_cast<octave_idx_type>(X->nzmax));
               for (octave_idx_type j = 0;
                    j <= static_cast<octave_idx_type>(X->ncol); j++)
                 retval.xcidx (j) = static_cast<octave_idx_type *>(X->p)[j];
               for (octave_idx_type j = 0;
                    j < static_cast<octave_idx_type>(X->nzmax); j++)
                 {
                   retval.xridx (j) = static_cast<octave_idx_type *>(X->i)[j];
                   retval.xdata (j) = static_cast<Complex *>(X->x)[j];
@@ -6578,23 +6587,23 @@ SparseComplexMatrix::fsolve (MatrixType 
 
               retval.xcidx (0) = 0;
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b (i,j);
 
                   status = UMFPACK_ZNAME (solve) (UMFPACK_A, Ap,
-                                             Ai,
-                                             reinterpret_cast<const double *> (Ax),
-                                             0,
-                                             reinterpret_cast<double *> (Xx),
-                                             0,
-                                             reinterpret_cast<double *> (Bx),
-                                             0, Numeric, control, info);
+                                                  Ai,
+                                                  reinterpret_cast<const double *> (Ax),
+                                                  0,
+                                                  reinterpret_cast<double *> (Xx),
+                                                  0,
+                                                  reinterpret_cast<double *> (Bx),
+                                                  0, Numeric, control, info);
 
                   if (status < 0)
                     {
                       (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
 
                       UMFPACK_ZNAME (report_status) (control, status);
 
@@ -6715,43 +6724,43 @@ SparseComplexMatrix::solve (MatrixType &
     }
 
   if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
-      retval = dmsolve<ComplexMatrix, SparseComplexMatrix,
-        Matrix> (*this, b, err);
+      retval = dmsolve<ComplexMatrix, SparseComplexMatrix, Matrix>
+               (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b,
-                     octave_idx_type& info) const
+                            octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b,
-                     octave_idx_type& info, double& rcond) const
+                            octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const SparseMatrix& b,
                             octave_idx_type& err, double& rcond,
                             solve_singularity_handler sing_handler,
@@ -6783,18 +6792,18 @@ SparseComplexMatrix::solve (MatrixType &
     }
 
   if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
-      retval = dmsolve<SparseComplexMatrix, SparseComplexMatrix,
-        SparseMatrix> (*this, b, err);
+      retval = dmsolve<SparseComplexMatrix, SparseComplexMatrix, SparseMatrix>
+               (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b) const
@@ -6851,18 +6860,18 @@ SparseComplexMatrix::solve (MatrixType &
     }
 
   if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
-      retval = dmsolve<ComplexMatrix, SparseComplexMatrix,
-        ComplexMatrix> (*this, b, err);
+      retval = dmsolve<ComplexMatrix, SparseComplexMatrix, ComplexMatrix>
+               (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (MatrixType &mattype,
@@ -6921,17 +6930,17 @@ SparseComplexMatrix::solve (MatrixType &
 
   if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
       retval = dmsolve<SparseComplexMatrix, SparseComplexMatrix,
-        SparseComplexMatrix> (*this, b, err);
+                       SparseComplexMatrix> (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b) const
@@ -6956,17 +6965,18 @@ SparseComplexMatrix::solve (MatrixType &
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType &mattype, const ColumnVector& b,
                             octave_idx_type& info, double& rcond,
                             solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
-  return solve (mattype, tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
+  return solve (mattype, tmp, info, rcond,
+                sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType &mattype,
                             const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcond;
@@ -6989,17 +6999,18 @@ SparseComplexMatrix::solve (MatrixType &
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b,
                             octave_idx_type& info, double& rcond,
                             solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
-  return solve (mattype, tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
+  return solve (mattype, tmp, info, rcond,
+                sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const Matrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
@@ -7009,17 +7020,17 @@ ComplexMatrix
 SparseComplexMatrix::solve (const Matrix& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const Matrix& b, octave_idx_type& info,
-                     double& rcond) const
+                            double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const Matrix& b, octave_idx_type& err,
                             double& rcond,
                             solve_singularity_handler sing_handler) const
@@ -7033,89 +7044,89 @@ SparseComplexMatrix::solve (const Sparse
 {
   octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseMatrix& b,
-                     octave_idx_type& info) const
+                            octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseMatrix& b,
-                     octave_idx_type& info, double& rcond) const
+                            octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseMatrix& b,
-                     octave_idx_type& err, double& rcond,
-                     solve_singularity_handler sing_handler) const
+                            octave_idx_type& err, double& rcond,
+                            solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const ComplexMatrix& b,
                             octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const ComplexMatrix& b,
-                     octave_idx_type& info, double& rcond) const
+                            octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseComplexMatrix::solve (const ComplexMatrix& b,
-                     octave_idx_type& err, double& rcond,
-                     solve_singularity_handler sing_handler) const
+                            octave_idx_type& err, double& rcond,
+                            solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b,
-                     octave_idx_type& info) const
+                            octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b,
-                     octave_idx_type& info, double& rcond) const
+                            octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::solve (const SparseComplexMatrix& b,
-                     octave_idx_type& err, double& rcond,
-                     solve_singularity_handler sing_handler) const
+                            octave_idx_type& err, double& rcond,
+                            solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ColumnVector& b) const
 {
@@ -7133,52 +7144,56 @@ SparseComplexMatrix::solve (const Column
 ComplexColumnVector
 SparseComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info,
                             double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
+SparseComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info,
+                            double& rcond,
                             solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
-  return solve (tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
+  return solve (tmp, info, rcond,
+                sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info) const
+SparseComplexMatrix::solve (const ComplexColumnVector& b,
+                            octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
-                     double& rcond) const
+                            double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
 SparseComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
                             double& rcond,
                             solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
-  return solve (tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
+  return solve (tmp, info, rcond,
+                sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 // unary operations
 SparseBoolMatrix
 SparseComplexMatrix::operator ! (void) const
 {
   if (any_element_is_nan ())
     gripe_nan_to_logical_conversion ();
@@ -7287,48 +7302,47 @@ SparseComplexMatrix::all_integers (doubl
   if (nel == 0)
     return false;
 
   max_val = std::real (data (0));
   min_val = std::real (data (0));
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
-        Complex val = data (i);
-
-        double r_val = std::real (val);
-        double i_val = std::imag (val);
-
-        if (r_val > max_val)
-          max_val = r_val;
-
-        if (i_val > max_val)
-          max_val = i_val;
-
-        if (r_val < min_val)
-          min_val = r_val;
-
-        if (i_val < min_val)
-          min_val = i_val;
-
-        if (D_NINT (r_val) != r_val || D_NINT (i_val) != i_val)
-          return false;
+      Complex val = data (i);
+
+      double r_val = std::real (val);
+      double i_val = std::imag (val);
+
+      if (r_val > max_val)
+        max_val = r_val;
+
+      if (i_val > max_val)
+        max_val = i_val;
+
+      if (r_val < min_val)
+        min_val = r_val;
+
+      if (i_val < min_val)
+        min_val = i_val;
+
+      if (D_NINT (r_val) != r_val || D_NINT (i_val) != i_val)
+        return false;
     }
 
   return true;
 }
 
 bool
 SparseComplexMatrix::too_large_for_float (void) const
 {
   return test_any (xtoo_large_for_float);
 }
 
-// FIXME Do these really belong here?  Maybe they should be
-// in a base class?
+// FIXME: Do these really belong here?  Maybe they should be in a base class?
 
 SparseBoolMatrix
 SparseComplexMatrix::all (int dim) const
 {
   SPARSE_ALL_OP (dim);
 }
 
 SparseBoolMatrix
@@ -7410,28 +7424,28 @@ SparseComplexMatrix::diag (octave_idx_ty
   return MSparse<Complex>::diag (k);
 }
 
 std::ostream&
 operator << (std::ostream& os, const SparseComplexMatrix& a)
 {
   octave_idx_type nc = a.cols ();
 
-   // add one to the printed indices to go from
-   //  zero-based to one-based arrays
-   for (octave_idx_type j = 0; j < nc; j++)
-     {
-       octave_quit ();
-       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
-         {
-           os << a.ridx (i) + 1 << " "  << j + 1 << " ";
-           octave_write_complex (os, a.data (i));
-           os << "\n";
-         }
-     }
+  // add one to the printed indices to go from
+  //  zero-based to one-based arrays
+  for (octave_idx_type j = 0; j < nc; j++)
+    {
+      octave_quit ();
+      for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
+        {
+          os << a.ridx (i) + 1 << " "  << j + 1 << " ";
+          octave_write_complex (os, a.data (i));
+          os << "\n";
+        }
+    }
 
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, SparseComplexMatrix& a)
 {
   typedef SparseComplexMatrix::element_type elt_type;
@@ -7622,18 +7636,17 @@ operator * (const PermMatrix& p, const S
 }
 
 SparseComplexMatrix
 operator * (const SparseComplexMatrix& a, const PermMatrix& p)
 {
   return octinternal_do_mul_sm_pm (a, p);
 }
 
-// FIXME -- it would be nice to share code among the min/max
-// functions below.
+// FIXME: it would be nice to share code among the min/max functions below.
 
 #define EMPTY_RETURN_CHECK(T) \
   if (nr == 0 || nc == 0) \
     return T (nr, nc);
 
 SparseComplexMatrix
 min (const Complex& c, const SparseComplexMatrix& m)
 {
@@ -7874,18 +7887,18 @@ max (const SparseComplexMatrix& a, const
     }
   else
     (*current_liboctave_error_handler) ("matrix size mismatch");
 
   return r;
 }
 
 SPARSE_SMS_CMP_OPS (SparseComplexMatrix, 0.0, real, Complex,
-                   0.0, real)
+                    0.0, real)
 SPARSE_SMS_BOOL_OPS (SparseComplexMatrix, Complex, 0.0)
 
 SPARSE_SSM_CMP_OPS (Complex, 0.0, real, SparseComplexMatrix,
-                   0.0, real)
+                    0.0, real)
 SPARSE_SSM_BOOL_OPS (Complex, SparseComplexMatrix, 0.0)
 
 SPARSE_SMSM_CMP_OPS (SparseComplexMatrix, 0.0, real, SparseComplexMatrix,
                      0.0, real)
 SPARSE_SMSM_BOOL_OPS (SparseComplexMatrix, SparseComplexMatrix, 0.0)
diff --git a/liboctave/array/CSparse.h b/liboctave/array/CSparse.h
--- a/liboctave/array/CSparse.h
+++ b/liboctave/array/CSparse.h
@@ -48,22 +48,24 @@ OCTAVE_API
 SparseComplexMatrix : public MSparse<Complex>
 {
 public:
 
   typedef void (*solve_singularity_handler) (double rcond);
 
   SparseComplexMatrix (void) : MSparse<Complex> () { }
 
-  SparseComplexMatrix (octave_idx_type r, octave_idx_type c) : MSparse<Complex> (r, c) { }
+  SparseComplexMatrix (octave_idx_type r,
+                       octave_idx_type c) : MSparse<Complex> (r, c) { }
 
-  SparseComplexMatrix (const dim_vector& dv, octave_idx_type nz = 0) :
-    MSparse<Complex> (dv, nz) { }
+  SparseComplexMatrix (const dim_vector& dv, octave_idx_type nz = 0)
+    : MSparse<Complex> (dv, nz) { }
 
-  explicit SparseComplexMatrix (octave_idx_type r, octave_idx_type c, Complex val)
+  explicit SparseComplexMatrix (octave_idx_type r, octave_idx_type c,
+                                Complex val)
     : MSparse<Complex> (r, c, val) { }
 
   SparseComplexMatrix (octave_idx_type r, octave_idx_type c, double val)
     : MSparse<Complex> (r, c, Complex (val)) { }
 
   SparseComplexMatrix (const SparseComplexMatrix& a)
     : MSparse<Complex> (a) { }
 
@@ -87,50 +89,55 @@ public:
     : MSparse<Complex> (a, r, c, nr, nc, sum_terms, nzm) { }
 
   explicit SparseComplexMatrix (const SparseMatrix& a);
 
   explicit SparseComplexMatrix (const SparseBoolMatrix& a);
 
   explicit SparseComplexMatrix (const ComplexDiagMatrix& a);
 
-  SparseComplexMatrix (octave_idx_type r, octave_idx_type c, octave_idx_type num_nz)
+  SparseComplexMatrix (octave_idx_type r, octave_idx_type c,
+                       octave_idx_type num_nz)
     : MSparse<Complex> (r, c, num_nz) { }
 
   SparseComplexMatrix& operator = (const SparseComplexMatrix& a)
-    {
-      MSparse<Complex>::operator = (a);
-      return *this;
-    }
+  {
+    MSparse<Complex>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const SparseComplexMatrix& a) const;
   bool operator != (const SparseComplexMatrix& a) const;
 
   bool is_hermitian (void) const;
 
   SparseComplexMatrix max (int dim = -1) const;
   SparseComplexMatrix max (Array<octave_idx_type>& index, int dim = -1) const;
   SparseComplexMatrix min (int dim = -1) const;
   SparseComplexMatrix min (Array<octave_idx_type>& index, int dim = -1) const;
 
-  SparseComplexMatrix& insert (const SparseComplexMatrix& a, octave_idx_type r, octave_idx_type c);
-  SparseComplexMatrix& insert (const SparseMatrix& a, octave_idx_type r, octave_idx_type c);
-  SparseComplexMatrix& insert (const SparseComplexMatrix& a, const Array<octave_idx_type>& indx);
-  SparseComplexMatrix& insert (const SparseMatrix& a, const Array<octave_idx_type>& indx);
+  SparseComplexMatrix& insert (const SparseComplexMatrix& a,
+                               octave_idx_type r, octave_idx_type c);
+  SparseComplexMatrix& insert (const SparseMatrix& a,
+                               octave_idx_type r, octave_idx_type c);
+  SparseComplexMatrix& insert (const SparseComplexMatrix& a,
+                               const Array<octave_idx_type>& indx);
+  SparseComplexMatrix& insert (const SparseMatrix& a,
+                               const Array<octave_idx_type>& indx);
 
   SparseComplexMatrix concat (const SparseComplexMatrix& rb,
                               const Array<octave_idx_type>& ra_idx);
   SparseComplexMatrix concat (const SparseMatrix& rb,
                               const Array<octave_idx_type>& ra_idx);
 
   ComplexMatrix matrix_value (void) const;
 
   SparseComplexMatrix hermitian (void) const;  // complex conjugate transpose
   SparseComplexMatrix transpose (void) const
-    { return MSparse<Complex>::transpose (); }
+  { return MSparse<Complex>::transpose (); }
 
   friend SparseComplexMatrix conj (const SparseComplexMatrix& a);
 
   // extract row or column i.
 
   ComplexRowVector row (octave_idx_type i) const;
 
   ComplexColumnVector column (octave_idx_type i) const;
@@ -151,144 +158,147 @@ public:
                                octave_idx_type& info) const;
   SparseComplexMatrix inverse (MatrixType& mattype, octave_idx_type& info,
                                double& rcond, int force = 0,
                                int calc_cond = 1) const;
 
   ComplexDET determinant (void) const;
   ComplexDET determinant (octave_idx_type& info) const;
   ComplexDET determinant (octave_idx_type& info, double& rcond,
-                                int calc_cond = 1) const;
+                          int calc_cond = 1) const;
 
 private:
   // Diagonal matrix solvers
   ComplexMatrix dsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-                double& rcond, solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                        double& rcond, solve_singularity_handler sing_handler,
+                        bool calc_cond = false) const;
 
   ComplexMatrix dsolve (MatrixType &typ, const ComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                        octave_idx_type& info, double& rcond,
+                        solve_singularity_handler sing_handler,
+                        bool calc_cond = false) const;
 
   SparseComplexMatrix dsolve (MatrixType &typ, const SparseMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                              octave_idx_type& info, double& rcond,
+                              solve_singularity_handler sing_handler,
+                              bool calc_cond = false) const;
 
   SparseComplexMatrix dsolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                              octave_idx_type& info, double& rcond,
+                              solve_singularity_handler sing_handler,
+                              bool calc_cond = false) const;
 
   // Upper triangular matrix solvers
-  ComplexMatrix utsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-                double& rcond, solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+  ComplexMatrix utsolve (MatrixType &typ, const Matrix& b,
+                         octave_idx_type& info, double& rcond,
+                         solve_singularity_handler sing_handler,
+                         bool calc_cond = false) const;
 
   ComplexMatrix utsolve (MatrixType &typ, const ComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                         octave_idx_type& info, double& rcond,
+                         solve_singularity_handler sing_handler,
+                         bool calc_cond = false) const;
 
   SparseComplexMatrix utsolve (MatrixType &typ, const SparseMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                               octave_idx_type& info, double& rcond,
+                               solve_singularity_handler sing_handler,
+                               bool calc_cond = false) const;
 
   SparseComplexMatrix utsolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                               octave_idx_type& info, double& rcond,
+                               solve_singularity_handler sing_handler,
+                               bool calc_cond = false) const;
 
   // Lower triangular matrix solvers
   ComplexMatrix ltsolve (MatrixType &typ, const Matrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                         octave_idx_type& info, double& rcond,
+                         solve_singularity_handler sing_handler,
+                         bool calc_cond = false) const;
 
   ComplexMatrix ltsolve (MatrixType &typ, const ComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                         octave_idx_type& info, double& rcond,
+                         solve_singularity_handler sing_handler,
+                         bool calc_cond = false) const;
 
   SparseComplexMatrix ltsolve (MatrixType &typ, const SparseMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                               octave_idx_type& info, double& rcond,
+                               solve_singularity_handler sing_handler,
+                               bool calc_cond = false) const;
 
   SparseComplexMatrix ltsolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                               octave_idx_type& info, double& rcond,
+                               solve_singularity_handler sing_handler,
+                               bool calc_cond = false) const;
 
   // Tridiagonal matrix solvers
   ComplexMatrix trisolve (MatrixType &typ, const Matrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                          octave_idx_type& info, double& rcond,
+                          solve_singularity_handler sing_handler,
+                          bool calc_cond = false) const;
 
   ComplexMatrix trisolve (MatrixType &typ, const ComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                          octave_idx_type& info, double& rcond,
+                          solve_singularity_handler sing_handler,
+                          bool calc_cond = false) const;
 
   SparseComplexMatrix trisolve (MatrixType &typ, const SparseMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                                octave_idx_type& info, double& rcond,
+                                solve_singularity_handler sing_handler,
+                                bool calc_cond = false) const;
 
   SparseComplexMatrix trisolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                                octave_idx_type& info, double& rcond,
+                                solve_singularity_handler sing_handler,
+                                bool calc_cond = false) const;
 
   // Banded matrix solvers (umfpack/cholesky)
-  ComplexMatrix bsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-                double& rcond, solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+  ComplexMatrix bsolve (MatrixType &typ, const Matrix& b,
+                        octave_idx_type& info, double& rcond,
+                        solve_singularity_handler sing_handler,
+                        bool calc_cond = false) const;
 
   ComplexMatrix bsolve (MatrixType &typ, const ComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                        octave_idx_type& info, double& rcond,
+                        solve_singularity_handler sing_handler,
+                        bool calc_cond = false) const;
 
   SparseComplexMatrix bsolve (MatrixType &typ, const SparseMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                              octave_idx_type& info, double& rcond,
+                              solve_singularity_handler sing_handler,
+                              bool calc_cond = false) const;
 
   SparseComplexMatrix bsolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                              octave_idx_type& info, double& rcond,
+                              solve_singularity_handler sing_handler,
+                              bool calc_cond = false) const;
 
   // Full matrix solvers (umfpack/cholesky)
   void * factorize (octave_idx_type& err, double &rcond, Matrix &Control,
-                Matrix &Info, solve_singularity_handler sing_handler,
-                bool calc_cond) const;
+                    Matrix &Info, solve_singularity_handler sing_handler,
+                    bool calc_cond) const;
 
-  ComplexMatrix fsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-                double& rcond, solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+  ComplexMatrix fsolve (MatrixType &typ, const Matrix& b,
+                        octave_idx_type& info, double& rcond,
+                        solve_singularity_handler sing_handler,
+                        bool calc_cond = false) const;
 
   ComplexMatrix fsolve (MatrixType &typ, const ComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                        octave_idx_type& info, double& rcond,
+                        solve_singularity_handler sing_handler,
+                        bool calc_cond = false) const;
 
   SparseComplexMatrix fsolve (MatrixType &typ, const SparseMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                              octave_idx_type& info, double& rcond,
+                              solve_singularity_handler sing_handler,
+                              bool calc_cond = false) const;
 
   SparseComplexMatrix fsolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                              octave_idx_type& info, double& rcond,
+                              solve_singularity_handler sing_handler,
+                              bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   ComplexMatrix solve (MatrixType &typ, const Matrix& b) const;
   ComplexMatrix solve (MatrixType &typ, const Matrix& b,
                        octave_idx_type& info) const;
   ComplexMatrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                        double& rcond) const;
@@ -354,50 +364,53 @@ public:
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcond,
                        solve_singularity_handler sing_handler) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info,
                        double& rcond) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info,
-                       double& rcond, solve_singularity_handler sing_handler) const;
+                       double& rcond,
+                       solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix solve (const SparseMatrix& b) const;
-  SparseComplexMatrix solve (const SparseMatrix& b, octave_idx_type& info) const;
+  SparseComplexMatrix solve (const SparseMatrix& b,
+                             octave_idx_type& info) const;
   SparseComplexMatrix solve (const SparseMatrix& b, octave_idx_type& info,
                              double& rcond) const;
   SparseComplexMatrix solve (const SparseMatrix& b, octave_idx_type& info,
                              double& rcond,
                              solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix solve (const SparseComplexMatrix& b) const;
   SparseComplexMatrix solve (const SparseComplexMatrix& b,
                              octave_idx_type& info) const;
   SparseComplexMatrix solve (const SparseComplexMatrix& b,
                              octave_idx_type& info, double& rcond) const;
   SparseComplexMatrix solve (const SparseComplexMatrix& b,
                              octave_idx_type& info, double& rcond,
                              solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (const ColumnVector& b) const;
-  ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
+  ComplexColumnVector solve (const ColumnVector& b,
+                             octave_idx_type& info) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info,
                              double& rcond) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info,
                              double& rcond,
                              solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
   ComplexColumnVector solve (const ComplexColumnVector& b,
                              octave_idx_type& info) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-                             double& rcond) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-                             double& rcond,
+  ComplexColumnVector solve (const ComplexColumnVector& b,
+                             octave_idx_type& info, double& rcond) const;
+  ComplexColumnVector solve (const ComplexColumnVector& b,
+                             octave_idx_type& info, double& rcond,
                              solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix squeeze (void) const;
 
   SparseComplexMatrix reshape (const dim_vector& new_dims) const;
 
   SparseComplexMatrix permute (const Array<octave_idx_type>& vec,
                                bool inv = false) const;
@@ -421,91 +434,109 @@ public:
   SparseComplexMatrix sum (int dim = -1) const;
   SparseComplexMatrix sumsq (int dim = -1) const;
   SparseMatrix abs (void) const;
 
   SparseComplexMatrix diag (octave_idx_type k = 0) const;
 
   // i/o
   friend OCTAVE_API std::ostream& operator << (std::ostream& os,
-                                    const SparseComplexMatrix& a);
+                                               const SparseComplexMatrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is,
-                                    SparseComplexMatrix& a);
+                                               SparseComplexMatrix& a);
 };
 
 extern OCTAVE_API SparseComplexMatrix operator * (const SparseMatrix&,
-                                       const SparseComplexMatrix&);
+                                                  const SparseComplexMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&,
-                                       const SparseMatrix&);
+                                                  const SparseMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&,
-                                       const SparseComplexMatrix&);
+                                                  const SparseComplexMatrix&);
 
 extern OCTAVE_API ComplexMatrix operator * (const Matrix&,
-                                       const SparseComplexMatrix&);
+                                            const SparseComplexMatrix&);
 extern OCTAVE_API ComplexMatrix operator * (const ComplexMatrix&,
-                                       const SparseMatrix&);
+                                            const SparseMatrix&);
 extern OCTAVE_API ComplexMatrix operator * (const ComplexMatrix&,
-                                       const SparseComplexMatrix&);
+                                            const SparseComplexMatrix&);
 extern OCTAVE_API ComplexMatrix mul_trans (const ComplexMatrix&,
-                                       const SparseComplexMatrix&);
+                                           const SparseComplexMatrix&);
 extern OCTAVE_API ComplexMatrix mul_herm (const ComplexMatrix&,
-                                       const SparseComplexMatrix&);
+                                          const SparseComplexMatrix&);
 
 extern OCTAVE_API ComplexMatrix operator * (const SparseMatrix&,
-                                       const ComplexMatrix&);
+                                            const ComplexMatrix&);
 extern OCTAVE_API ComplexMatrix operator * (const SparseComplexMatrix&,
-                                       const Matrix&);
+                                            const Matrix&);
 extern OCTAVE_API ComplexMatrix operator * (const SparseComplexMatrix&,
-                                       const ComplexMatrix&);
+                                            const ComplexMatrix&);
 extern OCTAVE_API ComplexMatrix trans_mul (const SparseComplexMatrix&,
-                                       const ComplexMatrix&);
+                                           const ComplexMatrix&);
 extern OCTAVE_API ComplexMatrix herm_mul (const SparseComplexMatrix&,
-                                       const ComplexMatrix&);
+                                          const ComplexMatrix&);
+
+extern OCTAVE_API SparseComplexMatrix operator * (const DiagMatrix&,
+                                                  const SparseComplexMatrix&);
+extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&,
+                                                  const DiagMatrix&);
 
-extern OCTAVE_API SparseComplexMatrix operator * (const DiagMatrix&, const SparseComplexMatrix&);
-extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&, const DiagMatrix&);
+extern OCTAVE_API SparseComplexMatrix operator * (const ComplexDiagMatrix&,
+                                                  const SparseMatrix&);
+extern OCTAVE_API SparseComplexMatrix operator * (const SparseMatrix&,
+                                                  const ComplexDiagMatrix&);
 
-extern OCTAVE_API SparseComplexMatrix operator * (const ComplexDiagMatrix&, const SparseMatrix&);
-extern OCTAVE_API SparseComplexMatrix operator * (const SparseMatrix&, const ComplexDiagMatrix&);
+extern OCTAVE_API SparseComplexMatrix operator * (const ComplexDiagMatrix&,
+                                                  const SparseComplexMatrix&);
+extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&,
+                                                  const ComplexDiagMatrix&);
 
-extern OCTAVE_API SparseComplexMatrix operator * (const ComplexDiagMatrix&, const SparseComplexMatrix&);
-extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&, const ComplexDiagMatrix&);
+extern OCTAVE_API SparseComplexMatrix operator + (const ComplexDiagMatrix&,
+                                                  const SparseMatrix&);
+extern OCTAVE_API SparseComplexMatrix operator + (const DiagMatrix&,
+                                                  const SparseComplexMatrix&);
+extern OCTAVE_API SparseComplexMatrix operator + (const ComplexDiagMatrix&,
+                                                  const SparseComplexMatrix&);
+extern OCTAVE_API SparseComplexMatrix operator + (const SparseMatrix&,
+                                                  const ComplexDiagMatrix&);
+extern OCTAVE_API SparseComplexMatrix operator + (const SparseComplexMatrix&,
+                                                  const DiagMatrix&);
+extern OCTAVE_API SparseComplexMatrix operator + (const SparseComplexMatrix&,
+                                                  const ComplexDiagMatrix&);
 
-extern OCTAVE_API SparseComplexMatrix operator + (const ComplexDiagMatrix&, const SparseMatrix&);
-extern OCTAVE_API SparseComplexMatrix operator + (const DiagMatrix&, const SparseComplexMatrix&);
-extern OCTAVE_API SparseComplexMatrix operator + (const ComplexDiagMatrix&, const SparseComplexMatrix&);
-extern OCTAVE_API SparseComplexMatrix operator + (const SparseMatrix&, const ComplexDiagMatrix&);
-extern OCTAVE_API SparseComplexMatrix operator + (const SparseComplexMatrix&, const DiagMatrix&);
-extern OCTAVE_API SparseComplexMatrix operator + (const SparseComplexMatrix&, const ComplexDiagMatrix&);
-
-extern OCTAVE_API SparseComplexMatrix operator - (const ComplexDiagMatrix&, const SparseMatrix&);
-extern OCTAVE_API SparseComplexMatrix operator - (const DiagMatrix&, const SparseComplexMatrix&);
-extern OCTAVE_API SparseComplexMatrix operator - (const ComplexDiagMatrix&, const SparseComplexMatrix&);
-extern OCTAVE_API SparseComplexMatrix operator - (const SparseMatrix&, const ComplexDiagMatrix&);
-extern OCTAVE_API SparseComplexMatrix operator - (const SparseComplexMatrix&, const DiagMatrix&);
-extern OCTAVE_API SparseComplexMatrix operator - (const SparseComplexMatrix&, const ComplexDiagMatrix&);
+extern OCTAVE_API SparseComplexMatrix operator - (const ComplexDiagMatrix&,
+                                                  const SparseMatrix&);
+extern OCTAVE_API SparseComplexMatrix operator - (const DiagMatrix&,
+                                                  const SparseComplexMatrix&);
+extern OCTAVE_API SparseComplexMatrix operator - (const ComplexDiagMatrix&,
+                                                  const SparseComplexMatrix&);
+extern OCTAVE_API SparseComplexMatrix operator - (const SparseMatrix&,
+                                                  const ComplexDiagMatrix&);
+extern OCTAVE_API SparseComplexMatrix operator - (const SparseComplexMatrix&,
+                                                  const DiagMatrix&);
+extern OCTAVE_API SparseComplexMatrix operator - (const SparseComplexMatrix&,
+                                                  const ComplexDiagMatrix&);
 
 extern OCTAVE_API SparseComplexMatrix operator * (const PermMatrix&,
                                                   const SparseComplexMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&,
                                                   const PermMatrix&);
 
 extern OCTAVE_API SparseComplexMatrix min (const Complex& c,
-                                const SparseComplexMatrix& m);
+                                           const SparseComplexMatrix& m);
 extern OCTAVE_API SparseComplexMatrix min (const SparseComplexMatrix& m,
-                                const Complex& c);
+                                           const Complex& c);
 extern OCTAVE_API SparseComplexMatrix min (const SparseComplexMatrix& a,
-                                const SparseComplexMatrix& b);
+                                           const SparseComplexMatrix& b);
 
 extern OCTAVE_API SparseComplexMatrix max (const Complex& c,
-                                const SparseComplexMatrix& m);
+                                           const SparseComplexMatrix& m);
 extern OCTAVE_API SparseComplexMatrix max (const SparseComplexMatrix& m,
-                                const Complex& c);
+                                           const Complex& c);
 extern OCTAVE_API SparseComplexMatrix max (const SparseComplexMatrix& a,
-                                const SparseComplexMatrix& b);
+                                           const SparseComplexMatrix& b);
 
 SPARSE_SMS_CMP_OP_DECLS (SparseComplexMatrix, Complex, OCTAVE_API)
 SPARSE_SMS_BOOL_OP_DECLS (SparseComplexMatrix, Complex, OCTAVE_API)
 
 SPARSE_SSM_CMP_OP_DECLS (Complex, SparseComplexMatrix, OCTAVE_API)
 SPARSE_SSM_BOOL_OP_DECLS (Complex, SparseComplexMatrix, OCTAVE_API)
 
 SPARSE_SMSM_CMP_OP_DECLS (SparseComplexMatrix, SparseComplexMatrix, OCTAVE_API)
diff --git a/liboctave/array/DiagArray2.h b/liboctave/array/DiagArray2.h
--- a/liboctave/array/DiagArray2.h
+++ b/liboctave/array/DiagArray2.h
@@ -64,26 +64,26 @@ public:
 
   template <class U>
   DiagArray2 (const DiagArray2<U>& a)
     : Array<T> (a.extract_diag ()), d1 (a.dim1 ()), d2 (a.dim2 ()) { }
 
   ~DiagArray2 (void) { }
 
   DiagArray2<T>& operator = (const DiagArray2<T>& a)
-    {
-      if (this != &a)
-        {
-          Array<T>::operator = (a);
-          d1 = a.d1;
-          d2 = a.d2;
-        }
+  {
+    if (this != &a)
+      {
+        Array<T>::operator = (a);
+        d1 = a.d1;
+        d2 = a.d2;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   octave_idx_type dim1 (void) const { return d1; }
   octave_idx_type dim2 (void) const { return d2; }
 
   octave_idx_type rows (void) const { return dim1 (); }
   octave_idx_type cols (void) const { return dim2 (); }
   octave_idx_type columns (void) const { return dim2 (); }
 
@@ -103,73 +103,73 @@ public:
   {
     return DiagArray2<T> (array_value ());
   }
 
   // Warning: the non-const two-index versions will silently ignore assignments
   // to off-diagonal elements.
 
   T elem (octave_idx_type r, octave_idx_type c) const
-    {
-      return (r == c) ? Array<T>::elem (r) : T (0);
-    }
+  {
+    return (r == c) ? Array<T>::elem (r) : T (0);
+  }
 
   T& elem (octave_idx_type r, octave_idx_type c)
-    {
-      static T zero (0);
-      return (r == c) ? Array<T>::elem (r) : zero;
-    }
+  {
+    static T zero (0);
+    return (r == c) ? Array<T>::elem (r) : zero;
+  }
 
   T dgelem (octave_idx_type i) const
-    { return Array<T>::elem (i); }
+  { return Array<T>::elem (i); }
 
   T& dgelem (octave_idx_type i)
-    { return Array<T>::elem (i); }
+  { return Array<T>::elem (i); }
 
   T checkelem (octave_idx_type r, octave_idx_type c) const
-    {
-      return check_idx (r, c) ? elem (r, c) : T (0);
-    }
+  {
+    return check_idx (r, c) ? elem (r, c) : T (0);
+  }
 
   T operator () (octave_idx_type r, octave_idx_type c) const
-    {
+  {
 #if defined (BOUNDS_CHECKING)
-      return checkelem (r, c);
+    return checkelem (r, c);
 #else
-      return elem (r, c);
+    return elem (r, c);
 #endif
-    }
+  }
 
   T& checkelem (octave_idx_type r, octave_idx_type c)
-    {
-      static T zero (0);
-      return check_idx (r, c) ? elem (r, c) : zero;
-    }
+  {
+    static T zero (0);
+    return check_idx (r, c) ? elem (r, c) : zero;
+  }
 
   T& operator () (octave_idx_type r, octave_idx_type c)
-    {
+  {
 #if defined (BOUNDS_CHECKING)
-      return checkelem (r, c);
+    return checkelem (r, c);
 #else
-      return elem (r, c);
+    return elem (r, c);
 #endif
-    }
+  }
 
   // No checking.
 
   T xelem (octave_idx_type r, octave_idx_type c) const
-    {
-      return (r == c) ? Array<T>::xelem (r) : T (0);
-    }
+  {
+    return (r == c) ? Array<T>::xelem (r) : T (0);
+  }
 
   T& dgxelem (octave_idx_type i)
-    { return Array<T>::xelem (i); }
+  { return Array<T>::xelem (i); }
 
   T dgxelem (octave_idx_type i) const
-    { return Array<T>::xelem (i); }
+  { return Array<T>::xelem (i); }
 
   void resize (octave_idx_type n, octave_idx_type m, const T& rfv);
   void resize (octave_idx_type n, octave_idx_type m)
   {
     resize (n, m, Array<T>::resize_fill_value ());
   }
 
   DiagArray2<T> transpose (void) const;
@@ -179,16 +179,16 @@ public:
 
   const T *data (void) const { return Array<T>::data (); }
 
   const T *fortran_vec (void) const { return Array<T>::fortran_vec (); }
 
   T *fortran_vec (void) { return Array<T>::fortran_vec (); }
 
   void print_info (std::ostream& os, const std::string& prefix) const
-    { Array<T>::print_info (os, prefix); }
+  { Array<T>::print_info (os, prefix); }
 
 private:
 
   bool check_idx (octave_idx_type r, octave_idx_type c) const;
 };
 
 #endif
diff --git a/liboctave/array/MArray.cc b/liboctave/array/MArray.cc
--- a/liboctave/array/MArray.cc
+++ b/liboctave/array/MArray.cc
@@ -34,27 +34,27 @@ along with Octave; see the file COPYING.
 
 template <class T>
 struct _idxadds_helper
 {
   T *array;
   T val;
   _idxadds_helper (T *a, T v) : array (a), val (v) { }
   void operator () (octave_idx_type i)
-    { array[i] += val; }
+  { array[i] += val; }
 };
 
 template <class T>
 struct _idxadda_helper
 {
   T *array;
   const T *vals;
   _idxadda_helper (T *a, const T *v) : array (a), vals (v) { }
   void operator () (octave_idx_type i)
-    { array[i] += *vals++; }
+  { array[i] += *vals++; }
 };
 
 template <class T>
 void
 MArray<T>::idx_add (const idx_vector& idx, T val)
 {
   octave_idx_type n = this->length ();
   octave_idx_type ext = idx.extent (n);
@@ -83,24 +83,25 @@ MArray<T>::idx_add (const idx_vector& id
     }
 
   octave_quit ();
 
   octave_idx_type len = std::min (idx.length (n), vals.length ());
   idx.loop (len, _idxadda_helper<T> (this->fortran_vec (), vals.data ()));
 }
 
-template <class T, T op (typename ref_param<T>::type, typename ref_param<T>::type)>
+template <class T, T op (typename ref_param<T>::type,
+                         typename ref_param<T>::type)>
 struct _idxbinop_helper
 {
   T *array;
   const T *vals;
   _idxbinop_helper (T *a, const T *v) : array (a), vals (v) { }
   void operator () (octave_idx_type i)
-    { array[i] = op (array[i], *vals++); }
+  { array[i] = op (array[i], *vals++); }
 };
 
 template <class T>
 void
 MArray<T>::idx_min (const idx_vector& idx, const MArray<T>& vals)
 {
   octave_idx_type n = this->length ();
   octave_idx_type ext = idx.extent (n);
@@ -108,17 +109,18 @@ MArray<T>::idx_min (const idx_vector& id
     {
       this->resize1 (ext);
       n = ext;
     }
 
   octave_quit ();
 
   octave_idx_type len = std::min (idx.length (n), vals.length ());
-  idx.loop (len, _idxbinop_helper<T, xmin> (this->fortran_vec (), vals.data ()));
+  idx.loop (len, _idxbinop_helper<T, xmin> (this->fortran_vec (),
+                                            vals.data ()));
 }
 
 template <class T>
 void
 MArray<T>::idx_max (const idx_vector& idx, const MArray<T>& vals)
 {
   octave_idx_type n = this->length ();
   octave_idx_type ext = idx.extent (n);
@@ -126,23 +128,25 @@ MArray<T>::idx_max (const idx_vector& id
     {
       this->resize1 (ext);
       n = ext;
     }
 
   octave_quit ();
 
   octave_idx_type len = std::min (idx.length (n), vals.length ());
-  idx.loop (len, _idxbinop_helper<T, xmax> (this->fortran_vec (), vals.data ()));
+  idx.loop (len, _idxbinop_helper<T, xmax> (this->fortran_vec (),
+                                            vals.data ()));
 }
 
 #include <iostream>
 
 template <class T>
-void MArray<T>::idx_add_nd (const idx_vector& idx, const MArray<T>& vals, int dim)
+void MArray<T>::idx_add_nd (const idx_vector& idx, const MArray<T>& vals,
+                            int dim)
 {
   int nd = std::max (this->ndims (), vals.ndims ());
   if (dim < 0)
     dim = vals.dims ().first_non_singleton ();
   else if (dim > nd)
     nd = dim;
 
   // Check dimensions.
diff --git a/liboctave/array/MArray.h b/liboctave/array/MArray.h
--- a/liboctave/array/MArray.h
+++ b/liboctave/array/MArray.h
@@ -42,17 +42,17 @@ MArray : public Array<T>
 protected:
 
   // For jit support
   MArray (T *sdata, octave_idx_type slen, octave_idx_type *adims, void *arep)
     : Array<T> (sdata, slen, adims, arep) { }
 
 public:
 
-  MArray (void) : Array<T> () {}
+  MArray (void) : Array<T> () { }
 
   explicit MArray (octave_idx_type n) GCC_ATTR_DEPRECATED
     : Array<T> (dim_vector (n, 1)) { }
 
   MArray (octave_idx_type n, const T& val) GCC_ATTR_DEPRECATED
     : Array<T> (dim_vector (n, 1), val) { }
 
   explicit MArray (const dim_vector& dv)
@@ -64,38 +64,38 @@ public:
   MArray (const MArray<T>& a) : Array<T> (a) { }
 
   template <class U>
   MArray (const Array<U>& a) : Array<T> (a) { }
 
   ~MArray (void) { }
 
   MArray<T>& operator = (const MArray<T>& a)
-    {
-      Array<T>::operator = (a);
-      return *this;
-    }
+  {
+    Array<T>::operator = (a);
+    return *this;
+  }
 
   MArray<T> reshape (const dim_vector& new_dims) const
-    { return Array<T>::reshape (new_dims); }
+  { return Array<T>::reshape (new_dims); }
 
   MArray<T> permute (const Array<octave_idx_type>& vec,
-                      bool inv = false) const
-    { return Array<T>::permute (vec, inv); }
+                     bool inv = false) const
+  { return Array<T>::permute (vec, inv); }
 
   MArray<T> ipermute (const Array<octave_idx_type>& vec) const
-    { return Array<T>::ipermute (vec); }
+  { return Array<T>::ipermute (vec); }
 
   MArray squeeze (void) const { return Array<T>::squeeze (); }
 
   MArray<T> transpose (void) const
-    { return Array<T>::transpose (); }
+  { return Array<T>::transpose (); }
 
   MArray<T> hermitian (T (*fcn) (const T&) = 0) const
-    { return Array<T>::hermitian (fcn); }
+  { return Array<T>::hermitian (fcn); }
 
   // Performs indexed accumulative addition.
 
   void idx_add (const idx_vector& idx, T val);
 
   void idx_add (const idx_vector& idx, const MArray<T>& vals);
 
   void idx_min (const idx_vector& idx, const MArray<T>& vals);
diff --git a/liboctave/array/MDiagArray2.cc b/liboctave/array/MDiagArray2.cc
--- a/liboctave/array/MDiagArray2.cc
+++ b/liboctave/array/MDiagArray2.cc
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 template <class T>
 bool
 MDiagArray2<T>::is_multiple_of_identity (T val) const
 {
   bool retval = this->rows () == this->cols ();
   if (retval)
     {
       octave_idx_type len = this->length (), i = 0;
-      for (;i < len; i++)
+      for (; i < len; i++)
         if (DiagArray2<T>::elem (i, i) != val) break;
       retval = i == len;
     }
 
   return retval;
 }
 
 // Two dimensional diagonal array with math ops.
@@ -65,17 +65,18 @@ MARRAY_DAS_OP (*, mx_inline_mul)
 MARRAY_DAS_OP (/, mx_inline_div)
 
 // Element by element scalar by MDiagArray2 ops.
 
 template <class T>
 MDiagArray2<T>
 operator * (const T& s, const MDiagArray2<T>& a)
 {
-  return MDiagArray2<T> (do_sm_binary_op<T, T, T> (s, a, mx_inline_mul), a.d1, a.d2);
+  return MDiagArray2<T> (do_sm_binary_op<T, T, T> (s, a, mx_inline_mul),
+                                                   a.d1, a.d2);
 }
 
 // Element by element MDiagArray2 by MDiagArray2 ops.
 
 #define MARRAY_DADA_OP(FCN, OP, FN) \
   template <class T> \
   MDiagArray2<T> \
   FCN (const MDiagArray2<T>& a, const MDiagArray2<T>& b) \
@@ -97,10 +98,11 @@ operator + (const MDiagArray2<T>& a)
 {
   return a;
 }
 
 template <class T>
 MDiagArray2<T>
 operator - (const MDiagArray2<T>& a)
 {
-  return MDiagArray2<T> (do_mx_unary_op<T, T> (a, mx_inline_uminus), a.d1, a.d2);
+  return MDiagArray2<T> (do_mx_unary_op<T, T> (a, mx_inline_uminus),
+                         a.d1, a.d2);
 }
diff --git a/liboctave/array/MDiagArray2.h b/liboctave/array/MDiagArray2.h
--- a/liboctave/array/MDiagArray2.h
+++ b/liboctave/array/MDiagArray2.h
@@ -41,65 +41,67 @@ class
 MDiagArray2 : public DiagArray2<T>
 {
 public:
 
   MDiagArray2 (void) : DiagArray2<T> () { }
 
   MDiagArray2 (octave_idx_type r, octave_idx_type c) : DiagArray2<T> (r, c) { }
 
-  MDiagArray2 (octave_idx_type r, octave_idx_type c, const T& val) : DiagArray2<T> (r, c, val) { }
+  MDiagArray2 (octave_idx_type r, octave_idx_type c, const T& val)
+    : DiagArray2<T> (r, c, val) { }
 
   MDiagArray2 (const MDiagArray2<T>& a) : DiagArray2<T> (a) { }
 
   MDiagArray2 (const DiagArray2<T>& a) : DiagArray2<T> (a) { }
 
   template <class U>
   MDiagArray2 (const DiagArray2<U>& a) : DiagArray2<T> (a) { }
 
   explicit MDiagArray2 (const Array<T>& a) : DiagArray2<T> (a) { }
 
   MDiagArray2 (const Array<T>& a, octave_idx_type r, octave_idx_type c)
     : DiagArray2<T> (a, r, c) { }
 
   ~MDiagArray2 (void) { }
 
   MDiagArray2<T>& operator = (const MDiagArray2<T>& a)
-    {
-      DiagArray2<T>::operator = (a);
-      return *this;
-    }
+  {
+    DiagArray2<T>::operator = (a);
+    return *this;
+  }
 
   MArray<T> array_value () const
-    {
-      return DiagArray2<T>::array_value ();
-    }
+  {
+    return DiagArray2<T>::array_value ();
+  }
 
   octave_idx_type nnz (void) const
-    {
-      octave_idx_type retval = 0;
+  {
+    octave_idx_type retval = 0;
 
-      const T *d = this->data ();
+    const T *d = this->data ();
 
-      octave_idx_type nel = this->length ();
+    octave_idx_type nel = this->length ();
 
-      for (octave_idx_type i = 0; i < nel; i++)
-        {
-          if (d[i] != T ())
-            retval++;
-        }
+    for (octave_idx_type i = 0; i < nel; i++)
+      {
+        if (d[i] != T ())
+          retval++;
+      }
 
-      return retval;
-    }
+    return retval;
+  }
 
   MArray<T> diag (octave_idx_type k = 0) const
-    { return DiagArray2<T>::extract_diag (k); }
+  { return DiagArray2<T>::extract_diag (k); }
 
   MDiagArray2<T> transpose (void) const { return DiagArray2<T>::transpose (); }
-  MDiagArray2<T> hermitian (T (*fcn) (const T&) = 0) const { return DiagArray2<T>::hermitian (fcn); }
+  MDiagArray2<T> hermitian (T (*fcn) (const T&) = 0) const
+  { return DiagArray2<T>::hermitian (fcn); }
 
   bool is_multiple_of_identity (T val) const;
 
   // Currently, the OPS functions don't need to be friends, but that
   // may change.
 
   MDIAGARRAY2_OPS_FRIEND_DECLS (MDiagArray2, )
 
diff --git a/liboctave/array/MSparse.cc b/liboctave/array/MSparse.cc
--- a/liboctave/array/MSparse.cc
+++ b/liboctave/array/MSparse.cc
@@ -38,83 +38,83 @@ along with Octave; see the file COPYING.
 // sparse array with math ops.
 
 // Element by element MSparse by MSparse ops.
 
 template <class T, class OP>
 MSparse<T>&
 plus_or_minus (MSparse<T>& a, const MSparse<T>& b, OP op, const char* op_name)
 {
-    MSparse<T> r;
+  MSparse<T> r;
 
-    octave_idx_type a_nr = a.rows ();
-    octave_idx_type a_nc = a.cols ();
+  octave_idx_type a_nr = a.rows ();
+  octave_idx_type a_nc = a.cols ();
 
-    octave_idx_type b_nr = b.rows ();
-    octave_idx_type b_nc = b.cols ();
+  octave_idx_type b_nr = b.rows ();
+  octave_idx_type b_nc = b.cols ();
 
-    if (a_nr != b_nr || a_nc != b_nc)
-      gripe_nonconformant (op_name , a_nr, a_nc, b_nr, b_nc);
-    else
-      {
-        r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
+  if (a_nr != b_nr || a_nc != b_nc)
+    gripe_nonconformant (op_name , a_nr, a_nc, b_nr, b_nc);
+  else
+    {
+      r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ()));
 
-        octave_idx_type jx = 0;
-        for (octave_idx_type i = 0 ; i < a_nc ; i++)
-          {
-            octave_idx_type  ja = a.cidx (i);
-            octave_idx_type  ja_max = a.cidx (i+1);
-            bool ja_lt_max= ja < ja_max;
+      octave_idx_type jx = 0;
+      for (octave_idx_type i = 0 ; i < a_nc ; i++)
+        {
+          octave_idx_type  ja = a.cidx (i);
+          octave_idx_type  ja_max = a.cidx (i+1);
+          bool ja_lt_max= ja < ja_max;
 
-            octave_idx_type  jb = b.cidx (i);
-            octave_idx_type  jb_max = b.cidx (i+1);
-            bool jb_lt_max = jb < jb_max;
+          octave_idx_type  jb = b.cidx (i);
+          octave_idx_type  jb_max = b.cidx (i+1);
+          bool jb_lt_max = jb < jb_max;
 
-            while (ja_lt_max || jb_lt_max )
-              {
-                octave_quit ();
-                if ((! jb_lt_max) ||
-                      (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
-                  {
-                    r.ridx (jx) = a.ridx (ja);
-                    r.data (jx) = op (a.data (ja), 0.);
-                    jx++;
-                    ja++;
-                    ja_lt_max= ja < ja_max;
-                  }
-                else if (( !ja_lt_max ) ||
-                     (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
-                  {
-                    r.ridx (jx) = b.ridx (jb);
-                    r.data (jx) = op (0., b.data (jb));
-                    jx++;
-                    jb++;
-                    jb_lt_max= jb < jb_max;
-                  }
-                else
-                  {
-                     if (op (a.data (ja), b.data (jb)) != 0.)
-                       {
-                          r.data (jx) = op (a.data (ja), b.data (jb));
-                          r.ridx (jx) = a.ridx (ja);
-                          jx++;
-                       }
-                     ja++;
-                     ja_lt_max= ja < ja_max;
-                     jb++;
-                     jb_lt_max= jb < jb_max;
-                  }
-              }
-            r.cidx (i+1) = jx;
-          }
+          while (ja_lt_max || jb_lt_max )
+            {
+              octave_quit ();
+              if ((! jb_lt_max) ||
+                  (ja_lt_max && (a.ridx (ja) < b.ridx (jb))))
+                {
+                  r.ridx (jx) = a.ridx (ja);
+                  r.data (jx) = op (a.data (ja), 0.);
+                  jx++;
+                  ja++;
+                  ja_lt_max= ja < ja_max;
+                }
+              else if (( !ja_lt_max ) ||
+                       (jb_lt_max && (b.ridx (jb) < a.ridx (ja)) ) )
+                {
+                  r.ridx (jx) = b.ridx (jb);
+                  r.data (jx) = op (0., b.data (jb));
+                  jx++;
+                  jb++;
+                  jb_lt_max= jb < jb_max;
+                }
+              else
+                {
+                  if (op (a.data (ja), b.data (jb)) != 0.)
+                    {
+                      r.data (jx) = op (a.data (ja), b.data (jb));
+                      r.ridx (jx) = a.ridx (ja);
+                      jx++;
+                    }
+                  ja++;
+                  ja_lt_max= ja < ja_max;
+                  jb++;
+                  jb_lt_max= jb < jb_max;
+                }
+            }
+          r.cidx (i+1) = jx;
+        }
 
-        a = r.maybe_compress ();
-      }
+      a = r.maybe_compress ();
+    }
 
-    return a;
+  return a;
 }
 
 template <typename T>
 MSparse<T>&
 operator += (MSparse<T>& a, const MSparse<T>& b)
 {
   return plus_or_minus (a, b, std::plus<T> (), "operator +=");
 }
diff --git a/liboctave/array/MSparse.h b/liboctave/array/MSparse.h
--- a/liboctave/array/MSparse.h
+++ b/liboctave/array/MSparse.h
@@ -41,46 +41,48 @@ class
 MSparse : public Sparse<T>
 {
 public:
 
   MSparse (void) : Sparse<T> () { }
 
   MSparse (octave_idx_type n, octave_idx_type m) : Sparse<T> (n, m) { }
 
-  MSparse (const dim_vector& dv, octave_idx_type nz = 0) :
-    Sparse<T> (dv, nz) { }
+  MSparse (const dim_vector& dv, octave_idx_type nz = 0)
+    : Sparse<T> (dv, nz) { }
 
   MSparse (const MSparse<T>& a) : Sparse<T> (a) { }
 
   MSparse (const MSparse<T>& a, const dim_vector& dv) : Sparse<T> (a, dv) { }
 
   MSparse (const Sparse<T>& a) : Sparse<T> (a) { }
 
   template <class U>
   MSparse (const Sparse<U>& a) : Sparse<T> (a) { }
 
   MSparse (const Array<T>& a, const idx_vector& r, const idx_vector& c,
            octave_idx_type nr = -1, octave_idx_type nc = -1,
            bool sum_terms = true, octave_idx_type nzm = -1)
     : Sparse<T> (a, r, c, nr, nc, sum_terms, nzm) { }
 
-  explicit MSparse (octave_idx_type r, octave_idx_type c, T val) : Sparse<T> (r, c, val) { }
+  explicit MSparse (octave_idx_type r, octave_idx_type c, T val)
+    : Sparse<T> (r, c, val) { }
 
   explicit MSparse (const PermMatrix& a) : Sparse<T>(a) { }
 
-  MSparse (octave_idx_type r, octave_idx_type c, octave_idx_type num_nz) : Sparse<T> (r, c, num_nz) { }
+  MSparse (octave_idx_type r, octave_idx_type c, octave_idx_type num_nz)
+    : Sparse<T> (r, c, num_nz) { }
 
   ~MSparse (void) { }
 
   MSparse<T>& operator = (const MSparse<T>& a)
-    {
-      Sparse<T>::operator = (a);
-      return *this;
-    }
+  {
+    Sparse<T>::operator = (a);
+    return *this;
+  }
 
   MSparse<T>& insert (const Sparse<T>& a, octave_idx_type r, octave_idx_type c)
   {
     Sparse<T>::insert (a, r, c);
     return *this;
   }
 
   MSparse<T>& insert (const Sparse<T>& a, const Array<octave_idx_type>& indx)
@@ -89,24 +91,23 @@ public:
     return *this;
   }
 
   MSparse<T> transpose (void) const { return Sparse<T>::transpose (); }
 
   MSparse<T> squeeze (void) const { return Sparse<T>::squeeze (); }
 
   MSparse<T> reshape (const dim_vector& new_dims) const
-    { return Sparse<T>::reshape (new_dims); }
+  { return Sparse<T>::reshape (new_dims); }
 
   MSparse<T> permute (const Array<octave_idx_type>& vec, bool inv = false) const
-    { return Sparse<T>::permute (vec, inv); }
+  { return Sparse<T>::permute (vec, inv); }
 
   MSparse<T> ipermute (const Array<octave_idx_type>& vec) const
-    { return Sparse<T>::ipermute (vec); }
-
+  { return Sparse<T>::ipermute (vec); }
 
   MSparse<T> diag (octave_idx_type k = 0) const
   {
     return Sparse<T>::diag (k);
   }
 
   // FIXME: should go away.
   template <class U>
diff --git a/liboctave/array/MatrixType.cc b/liboctave/array/MatrixType.cc
--- a/liboctave/array/MatrixType.cc
+++ b/liboctave/array/MatrixType.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include "MatrixType.h"
 #include "dMatrix.h"
 #include "CMatrix.h"
 #include "dSparse.h"
 #include "CSparse.h"
 #include "oct-spparms.h"
 #include "oct-locbuf.h"
 
-// FIXME There is a large code duplication here
+// FIXME: There is a large code duplication here
 
 MatrixType::MatrixType (void)
   : typ (MatrixType::Unknown),
     sp_bandden (octave_sparse_params::get_bandden ()),
     bandden (0), upper_band (0),
     lower_band (0), dense (false), full (false), nperm (0), perm (0) { }
 
 MatrixType::MatrixType (const MatrixType &a)
@@ -303,20 +303,20 @@ MatrixType::MatrixType (const SparseMatr
               if (rl - j > lower_band)
                 lower_band = rl - j;
             }
         }
 
       if (!singular)
         {
           bandden = double (nnz) /
-            (double (ncols) * (double (lower_band) +
-                               double (upper_band)) -
-             0.5 * double (upper_band + 1) * double (upper_band) -
-             0.5 * double (lower_band + 1) * double (lower_band));
+                    (double (ncols) * (double (lower_band) +
+                                       double (upper_band)) -
+                     0.5 * double (upper_band + 1) * double (upper_band) -
+                     0.5 * double (lower_band + 1) * double (lower_band));
 
           if (nrows == ncols && sp_bandden != 1. && bandden > sp_bandden)
             {
               if (upper_band == 1 && lower_band == 1)
                 typ = MatrixType::Tridiagonal;
               else
                 typ = MatrixType::Banded;
 
@@ -338,18 +338,17 @@ MatrixType::MatrixType (const SparseMatr
             maybe_hermitian = true;
         }
 
       if (typ == MatrixType::Full)
         {
           // Search for a permuted triangular matrix, and test if
           // permutation is singular
 
-          // FIXME
-          // Perhaps this should be based on a dmperm algorithm
+          // FIXME: Perhaps this should be based on a dmperm algorithm?
           bool found = false;
 
           nperm = ncols;
           perm = new octave_idx_type [ncols];
 
           for (octave_idx_type i = 0; i < ncols; i++)
             perm[i] = -1;
 
@@ -393,17 +392,17 @@ MatrixType::MatrixType (const SparseMatr
               for (octave_idx_type i = 0; i < nrows; i++)
                 {
                   perm[i] = -1;
                   tmp[i] = -1;
                 }
 
               for (octave_idx_type j = 0; j < ncols; j++)
                 for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
-                    perm[a.ridx (i)] = j;
+                  perm[a.ridx (i)] = j;
 
               found = true;
               for (octave_idx_type i = 0; i < nm; i++)
                 if (perm[i] == -1)
                   {
                     found = false;
                     break;
                   }
@@ -442,20 +441,19 @@ MatrixType::MatrixType (const SparseMatr
             }
           else
             {
               delete [] perm;
               nperm = 0;
             }
         }
 
-      // FIXME
-      // Disable lower under-determined and upper over-determined problems
-      // as being detected, and force to treat as singular. As this seems
-      // to cause issues
+      // FIXME: Disable lower under-determined and upper over-determined
+      //        problems as being detected, and force to treat as singular
+      //        as this seems to cause issues.
       if (((typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
            && nrows > ncols) ||
           ((typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
            && nrows < ncols))
         {
           if (typ == MatrixType::Permuted_Upper ||
               typ == MatrixType::Permuted_Lower)
             delete [] perm;
@@ -624,20 +622,20 @@ MatrixType::MatrixType (const SparseComp
               if (rl - j > lower_band)
                 lower_band = rl - j;
             }
         }
 
       if (!singular)
         {
           bandden = double (nnz) /
-            (double (ncols) * (double (lower_band) +
-                               double (upper_band)) -
-             0.5 * double (upper_band + 1) * double (upper_band) -
-             0.5 * double (lower_band + 1) * double (lower_band));
+                    (double (ncols) * (double (lower_band) +
+                                       double (upper_band)) -
+                     0.5 * double (upper_band + 1) * double (upper_band) -
+                     0.5 * double (lower_band + 1) * double (lower_band));
 
           if (nrows == ncols && sp_bandden != 1. && bandden > sp_bandden)
             {
               if (upper_band == 1 && lower_band == 1)
                 typ = MatrixType::Tridiagonal;
               else
                 typ = MatrixType::Banded;
 
@@ -659,18 +657,17 @@ MatrixType::MatrixType (const SparseComp
             maybe_hermitian = true;
         }
 
       if (typ == MatrixType::Full)
         {
           // Search for a permuted triangular matrix, and test if
           // permutation is singular
 
-          // FIXME
-          // Perhaps this should be based on a dmperm algorithm
+          // FIXME: Perhaps this should be based on a dmperm algorithm?
           bool found = false;
 
           nperm = ncols;
           perm = new octave_idx_type [ncols];
 
           for (octave_idx_type i = 0; i < ncols; i++)
             perm[i] = -1;
 
@@ -714,17 +711,17 @@ MatrixType::MatrixType (const SparseComp
               for (octave_idx_type i = 0; i < nrows; i++)
                 {
                   perm[i] = -1;
                   tmp[i] = -1;
                 }
 
               for (octave_idx_type j = 0; j < ncols; j++)
                 for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
-                    perm[a.ridx (i)] = j;
+                  perm[a.ridx (i)] = j;
 
               found = true;
               for (octave_idx_type i = 0; i < nm; i++)
                 if (perm[i] == -1)
                   {
                     found = false;
                     break;
                   }
@@ -763,20 +760,19 @@ MatrixType::MatrixType (const SparseComp
             }
           else
             {
               delete [] perm;
               nperm = 0;
             }
         }
 
-      // FIXME
-      // Disable lower under-determined and upper over-determined problems
-      // as being detected, and force to treat as singular. As this seems
-      // to cause issues
+      // FIXME: Disable lower under-determined and upper over-determined
+      //        problems as being detected, and force to treat as singular
+      //        as this seems to cause issues.
       if (((typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
            && nrows > ncols) ||
           ((typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
            && nrows < ncols))
         {
           if (typ == MatrixType::Permuted_Upper ||
               typ == MatrixType::Permuted_Lower)
             delete [] perm;
@@ -938,18 +934,18 @@ MatrixType::operator = (const MatrixType
     }
 
   return *this;
 }
 
 int
 MatrixType::type (bool quiet)
 {
-  if (typ != MatrixType::Unknown && (full ||
-      sp_bandden == octave_sparse_params::get_bandden ()))
+  if (typ != MatrixType::Unknown
+      && (full || sp_bandden == octave_sparse_params::get_bandden ()))
     {
       if (!quiet &&
           octave_sparse_params::get_key ("spumoni") != 0.)
         (*current_liboctave_warning_handler)
           ("Using Cached Matrix Type");
 
       return typ;
     }
@@ -962,18 +958,18 @@ MatrixType::type (bool quiet)
   typ = MatrixType::Unknown;
 
   return typ;
 }
 
 int
 MatrixType::type (const SparseMatrix &a)
 {
-  if (typ != MatrixType::Unknown && (full ||
-      sp_bandden == octave_sparse_params::get_bandden ()))
+  if (typ != MatrixType::Unknown
+      && (full || sp_bandden == octave_sparse_params::get_bandden ()))
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
         (*current_liboctave_warning_handler)
           ("Using Cached Matrix Type");
 
       return typ;
     }
 
@@ -995,18 +991,18 @@ MatrixType::type (const SparseMatrix &a)
     }
 
   return typ;
 }
 
 int
 MatrixType::type (const SparseComplexMatrix &a)
 {
-  if (typ != MatrixType::Unknown && (full ||
-      sp_bandden == octave_sparse_params::get_bandden ()))
+  if (typ != MatrixType::Unknown
+      && (full || sp_bandden == octave_sparse_params::get_bandden ()))
     {
       if (octave_sparse_params::get_key ("spumoni") != 0.)
         (*current_liboctave_warning_handler)
           ("Using Cached Matrix Type");
 
       return typ;
     }
 
@@ -1217,17 +1213,18 @@ MatrixType::mark_as_unsymmetric (void)
            typ == MatrixType::Banded_Hermitian)
     typ = MatrixType::Banded;
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian ||
            typ == MatrixType::Unknown)
     typ = MatrixType::Full;
 }
 
 void
-MatrixType::mark_as_permuted (const octave_idx_type np, const octave_idx_type *p)
+MatrixType::mark_as_permuted (const octave_idx_type np,
+                              const octave_idx_type *p)
 {
   nperm = np;
   perm = new octave_idx_type [nperm];
   for (octave_idx_type i = 0; i < nperm; i++)
     perm[i] = p[i];
 
   if (typ == MatrixType::Diagonal || typ == MatrixType::Permuted_Diagonal)
     typ = MatrixType::Permuted_Diagonal;
diff --git a/liboctave/array/MatrixType.h b/liboctave/array/MatrixType.h
--- a/liboctave/array/MatrixType.h
+++ b/liboctave/array/MatrixType.h
@@ -31,17 +31,18 @@ class FloatComplexMatrix;
 class SparseMatrix;
 class SparseComplexMatrix;
 
 class
 OCTAVE_API
 MatrixType
 {
 public:
-  enum matrix_type {
+  enum matrix_type
+  {
     Unknown = 0,
     Full,
     Diagonal,
     Permuted_Diagonal,
     Upper,
     Lower,
     Permuted_Upper,
     Permuted_Lower,
@@ -99,33 +100,35 @@ public:
 
   int nupper (void) const { return upper_band; }
 
   int nlower (void) const { return lower_band; }
 
   bool is_dense (void) const { return dense; }
 
   bool is_diagonal (void) const
-    { return (typ == Diagonal || typ == Permuted_Diagonal); }
+  { return (typ == Diagonal || typ == Permuted_Diagonal); }
 
   bool is_upper_triangular (void) const
-    { return (typ == Upper || typ == Permuted_Upper); }
+  { return (typ == Upper || typ == Permuted_Upper); }
 
   bool is_lower_triangular (void) const
-    { return (typ == Lower || typ == Permuted_Lower); }
+  { return (typ == Lower || typ == Permuted_Lower); }
 
-   bool is_banded (void)
-    { return (typ == Banded || typ == Banded_Hermitian); }
+  bool is_banded (void)
+  { return (typ == Banded || typ == Banded_Hermitian); }
 
   bool is_tridiagonal (void) const
-    { return (typ == Tridiagonal || typ == Tridiagonal_Hermitian); }
+  { return (typ == Tridiagonal || typ == Tridiagonal_Hermitian); }
 
   bool is_hermitian (void) const
-    { return (typ == Banded_Hermitian || typ == Tridiagonal_Hermitian ||
-              typ == Hermitian); }
+  {
+    return (typ == Banded_Hermitian || typ == Tridiagonal_Hermitian ||
+            typ == Hermitian);
+  }
 
   bool is_rectangular (void) const { return (typ == Rectangular); }
 
   bool is_known (void) const { return (typ != Unknown); }
 
   bool is_unknown (void) const { return (typ == Unknown); }
 
   void info (void) const;
@@ -140,17 +143,17 @@ public:
 
   void mark_as_upper_triangular (void) { typ = Upper; }
 
   void mark_as_lower_triangular (void) { typ = Lower; }
 
   void mark_as_tridiagonal (void) {typ = Tridiagonal; }
 
   void mark_as_banded (const octave_idx_type ku, const octave_idx_type kl)
-    { typ = Banded; upper_band = ku; lower_band = kl; }
+  { typ = Banded; upper_band = ku; lower_band = kl; }
 
   void mark_as_full (void) { typ = Full; }
 
   void mark_as_rectangular (void) { typ = Rectangular; }
 
   void mark_as_dense (void) { dense = true; }
 
   void mark_as_not_dense (void) { dense = false; }
diff --git a/liboctave/array/PermMatrix.h b/liboctave/array/PermMatrix.h
--- a/liboctave/array/PermMatrix.h
+++ b/liboctave/array/PermMatrix.h
@@ -42,87 +42,88 @@ public:
               bool check = true);
 
   PermMatrix (const PermMatrix& m)
     : Array<octave_idx_type> (m), _colp(m._colp) { }
 
   PermMatrix (const idx_vector& idx, bool colp = false, octave_idx_type n = 0);
 
   octave_idx_type dim1 (void) const
-    { return Array<octave_idx_type>::length (); }
+  { return Array<octave_idx_type>::length (); }
   octave_idx_type dim2 (void) const
-    { return Array<octave_idx_type>::length (); }
+  { return Array<octave_idx_type>::length (); }
 
   octave_idx_type rows (void) const { return dim1 (); }
   octave_idx_type cols (void) const { return dim2 (); }
   octave_idx_type columns (void) const { return dim2 (); }
 
   octave_idx_type perm_length (void) const
-    { return Array<octave_idx_type>::length (); }
+  { return Array<octave_idx_type>::length (); }
   // FIXME: a dangerous ambiguity?
   octave_idx_type length (void) const
-    { return perm_length (); }
+  { return perm_length (); }
   octave_idx_type nelem (void) const { return dim1 () * dim2 (); }
   octave_idx_type numel (void) const { return nelem (); }
 
   size_t byte_size (void) const
-    { return Array<octave_idx_type>::byte_size (); }
+  { return Array<octave_idx_type>::byte_size (); }
 
   dim_vector dims (void) const { return dim_vector (dim1 (), dim2 ()); }
 
   Array<octave_idx_type> pvec (void) const
-    { return *this; }
+  { return *this; }
 
   octave_idx_type
   elem (octave_idx_type i, octave_idx_type j) const
-    {
-      return (_colp
-              ? ((Array<octave_idx_type>::elem (j) == i) ? 1 : 0)
+  {
+    return (_colp
+            ? ((Array<octave_idx_type>::elem (j) == i) ? 1 : 0)
               : ((Array<octave_idx_type>::elem (i) == j) ? 1 : 0));
-    }
+  }
 
   octave_idx_type
   checkelem (octave_idx_type i, octave_idx_type j) const;
 
   octave_idx_type
   operator () (octave_idx_type i, octave_idx_type j) const
-    {
+  {
 #if defined (BOUNDS_CHECKING)
-      return checkelem (i, j);
+    return checkelem (i, j);
 #else
-      return elem (i, j);
+    return elem (i, j);
 #endif
-    }
+  }
 
   // These are, in fact, super-fast.
   PermMatrix transpose (void) const;
   PermMatrix inverse (void) const;
 
   // Determinant, i.e. the sign of permutation.
   octave_idx_type determinant (void) const;
 
   // Efficient integer power of a permutation.
   PermMatrix power (octave_idx_type n) const;
 
   bool is_col_perm (void) const { return _colp; }
   bool is_row_perm (void) const { return !_colp; }
 
-  friend OCTAVE_API PermMatrix operator *(const PermMatrix& a, const PermMatrix& b);
+  friend OCTAVE_API PermMatrix operator *(const PermMatrix& a,
+                                          const PermMatrix& b);
 
   const octave_idx_type *data (void) const
-    { return Array<octave_idx_type>::data (); }
+  { return Array<octave_idx_type>::data (); }
 
   const octave_idx_type *fortran_vec (void) const
-    { return Array<octave_idx_type>::fortran_vec (); }
+  { return Array<octave_idx_type>::fortran_vec (); }
 
   octave_idx_type *fortran_vec (void)
-    { return Array<octave_idx_type>::fortran_vec (); }
+  { return Array<octave_idx_type>::fortran_vec (); }
 
   void print_info (std::ostream& os, const std::string& prefix) const
-    { Array<octave_idx_type>::print_info (os, prefix); }
+  { Array<octave_idx_type>::print_info (os, prefix); }
 
   static PermMatrix eye (octave_idx_type n);
 
 private:
   bool _colp;
 };
 
 // Multiplying permutations together.
diff --git a/liboctave/array/Range.cc b/liboctave/array/Range.cc
--- a/liboctave/array/Range.cc
+++ b/liboctave/array/Range.cc
@@ -55,17 +55,17 @@ Range::matrix_value (void) const
     {
       cache.resize (1, rng_nelem);
       double b = rng_base;
       double increment = rng_inc;
       if (rng_nelem > 0)
         {
           // The first element must always be *exactly* the base.
           // E.g, -0 would otherwise become +0 in the loop (-0 + 0*increment).
-          cache(0) = b; 
+          cache(0) = b;
           for (octave_idx_type i = 1; i < rng_nelem; i++)
             cache(i) = b + i * increment;
         }
 
       // On some machines (x86 with extended precision floating point
       // arithmetic, for example) it is possible that we can overshoot
       // the limit by approximately the machine precision even though
       // we were very careful in our calculation of the number of
@@ -83,17 +83,17 @@ Range::matrix_value (void) const
 double
 Range::checkelem (octave_idx_type i) const
 {
   if (i < 0 || i >= rng_nelem)
     gripe_index_out_of_range (1, 1, i+1, rng_nelem);
 
   if (i == 0)
     return rng_base;
-  else if (i < rng_nelem - 1) 
+  else if (i < rng_nelem - 1)
     return rng_base + i * rng_inc;
   else
     {
       double end = rng_base + i * rng_inc;
       if ((rng_inc > 0 && end >= rng_limit)
           || (rng_inc < 0 && end <= rng_limit))
         return rng_limit;
       else
@@ -104,54 +104,54 @@ Range::checkelem (octave_idx_type i) con
 double
 Range::elem (octave_idx_type i) const
 {
 #if defined (BOUNDS_CHECKING)
   return checkelem (i);
 #else
   if (i == 0)
     return rng_base;
-  else if (i < rng_nelem - 1) 
+  else if (i < rng_nelem - 1)
     return rng_base + i * rng_inc;
   else
     {
       double end = rng_base + i * rng_inc;
       if ((rng_inc > 0 && end >= rng_limit)
           || (rng_inc < 0 && end <= rng_limit))
         return rng_limit;
       else
         return end;
     }
 #endif
 }
 
 // Helper class used solely for idx_vector.loop () function call
 class __rangeidx_helper
 {
- public:
+public:
   __rangeidx_helper (double *a, double b, double i, double l, octave_idx_type n)
     : array (a), base (b), inc (i), limit (l), nmax (n-1) { }
 
   void operator () (octave_idx_type i)
-    {
-      if (i == 0)
-        *array++ = base;
-      else if (i < nmax) 
-        *array++ = base + i * inc;
-      else
-        {
-          double end = base + i * inc;
-          if ((inc > 0 && end >= limit) || (inc < 0 && end <= limit))
-            *array++ = limit;
-          else
-            *array++ = end;
-        }
-    }
+  {
+    if (i == 0)
+      *array++ = base;
+    else if (i < nmax)
+      *array++ = base + i * inc;
+    else
+      {
+        double end = base + i * inc;
+        if ((inc > 0 && end >= limit) || (inc < 0 && end <= limit))
+          *array++ = limit;
+        else
+          *array++ = end;
+      }
+  }
 
- private:
+private:
 
   double *array, base, inc, limit;
   octave_idx_type nmax;
 
 };
 
 Array<double>
 Range::index (const idx_vector& i) const
@@ -509,17 +509,18 @@ tfloor (double x, double ct)
 
 static inline double
 tceil (double x, double ct)
 {
   return -tfloor (-x, ct);
 }
 
 static inline bool
-teq (double u, double v, double ct = 3.0 * std::numeric_limits<double>::epsilon ())
+teq (double u, double v,
+     double ct = 3.0 * std::numeric_limits<double>::epsilon ())
 {
   double tu = fabs (u);
   double tv = fabs (v);
 
   return fabs (u - v) < ((tu > tv ? tu : tv) * ct);
 }
 
 octave_idx_type
@@ -534,17 +535,18 @@ Range::nelem_internal (void) const
       retval = 0;
     }
   else
     {
       double ct = 3.0 * std::numeric_limits<double>::epsilon ();
 
       double tmp = tfloor ((rng_limit - rng_base + rng_inc) / rng_inc, ct);
 
-      octave_idx_type n_elt = (tmp > 0.0 ? static_cast<octave_idx_type> (tmp) : 0);
+      octave_idx_type n_elt = (tmp > 0.0 ? static_cast<octave_idx_type> (tmp)
+                                         : 0);
 
       // If the final element that we would compute for the range is
       // equal to the limit of the range, or is an adjacent floating
       // point number, accept it.  Otherwise, try a range with one
       // fewer element.  If that fails, try again with one more
       // element.
       //
       // I'm not sure this is very good, but it seems to work better than
@@ -555,13 +557,14 @@ Range::nelem_internal (void) const
       if (! teq (rng_base + (n_elt - 1) * rng_inc, rng_limit))
         {
           if (teq (rng_base + (n_elt - 2) * rng_inc, rng_limit))
             n_elt--;
           else if (teq (rng_base + n_elt * rng_inc, rng_limit))
             n_elt++;
         }
 
-      retval = (n_elt < std::numeric_limits<octave_idx_type>::max () - 1) ? n_elt : -1;
+      retval = (n_elt < std::numeric_limits<octave_idx_type>::max () - 1)
+               ? n_elt : -1;
     }
 
   return retval;
 }
diff --git a/liboctave/array/Range.h b/liboctave/array/Range.h
--- a/liboctave/array/Range.h
+++ b/liboctave/array/Range.h
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 
 #include "dMatrix.h"
 #include "oct-sort.h"
 
 class
 OCTAVE_API
 Range
 {
- public:
+public:
 
   Range (void)
     : rng_base (0), rng_limit (0), rng_inc (0), rng_nelem (0), cache (1, 0) { }
 
   Range (const Range& r)
     : rng_base (r.rng_base), rng_limit (r.rng_limit), rng_inc (r.rng_inc),
       rng_nelem (r.rng_nelem), cache (r.cache) { }
 
@@ -48,20 +48,20 @@ Range
   Range (double b, double l, double i)
     : rng_base (b), rng_limit (l), rng_inc (i),
       rng_nelem (nelem_internal ()), cache () { }
 
   // For operators' usage (to preserve element count).
   Range (double b, double i, octave_idx_type n)
     : rng_base (b), rng_limit (b + (n-1) * i), rng_inc (i),
       rng_nelem (n), cache ()
-    {
-      if (! xfinite (b) || ! xfinite (i))
-        rng_nelem = -2;
-    }
+  {
+    if (! xfinite (b) || ! xfinite (i))
+      rng_nelem = -2;
+  }
 
   double base (void) const { return rng_base; }
   double limit (void) const { return rng_limit; }
   double inc (void) const { return rng_inc; }
   octave_idx_type nelem (void) const { return rng_nelem; }
 
   bool all_elements_are_ints (void) const;
 
@@ -112,30 +112,31 @@ Range
   {
     if (rng_inc != i)
       {
         rng_inc = i;
         clear_cache ();
       }
   }
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const Range& r);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const Range& r);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, Range& r);
 
   friend OCTAVE_API Range operator - (const Range& r);
   friend OCTAVE_API Range operator + (double x, const Range& r);
   friend OCTAVE_API Range operator + (const Range& r, double x);
   friend OCTAVE_API Range operator - (double x, const Range& r);
   friend OCTAVE_API Range operator - (const Range& r, double x);
   friend OCTAVE_API Range operator * (double x, const Range& r);
   friend OCTAVE_API Range operator * (const Range& r, double x);
 
   void print_range (void);
 
- private:
+private:
 
   double rng_base;
   double rng_limit;
   double rng_inc;
 
   octave_idx_type rng_nelem;
 
   mutable Matrix cache;
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -240,19 +240,19 @@ Sparse<T>::Sparse (const dim_vector& dv)
 
 template <class T>
 Sparse<T>::Sparse (const Sparse<T>& a, const dim_vector& dv)
   : rep (0), dimensions (dv)
 {
 
   // Work in unsigned long long to avoid overflow issues with numel
   unsigned long long a_nel = static_cast<unsigned long long>(a.rows ()) *
-    static_cast<unsigned long long>(a.cols ());
+                             static_cast<unsigned long long>(a.cols ());
   unsigned long long dv_nel = static_cast<unsigned long long>(dv (0)) *
-    static_cast<unsigned long long>(dv (1));
+                              static_cast<unsigned long long>(dv (1));
 
   if (a_nel != dv_nel)
     (*current_liboctave_error_handler)
       ("Sparse::Sparse (const Sparse&, const dim_vector&): dimension mismatch");
   else
     {
       dim_vector old_dims = a.dims ();
       octave_idx_type new_nzmx = a.nnz ();
@@ -732,17 +732,18 @@ Sparse<T>::range_error (const char *fcn,
 {
   (*current_liboctave_error_handler) ("%s (%d): range error", fcn, n);
   static T foo;
   return foo;
 }
 
 template <class T>
 T
-Sparse<T>::range_error (const char *fcn, octave_idx_type i, octave_idx_type j) const
+Sparse<T>::range_error (const char *fcn, octave_idx_type i,
+                        octave_idx_type j) const
 {
   (*current_liboctave_error_handler)
     ("%s (%d, %d): range error", fcn, i, j);
   return T ();
 }
 
 template <class T>
 T&
@@ -751,17 +752,18 @@ Sparse<T>::range_error (const char *fcn,
   (*current_liboctave_error_handler)
     ("%s (%d, %d): range error", fcn, i, j);
   static T foo;
   return foo;
 }
 
 template <class T>
 T
-Sparse<T>::range_error (const char *fcn, const Array<octave_idx_type>& ra_idx) const
+Sparse<T>::range_error (const char *fcn,
+                        const Array<octave_idx_type>& ra_idx) const
 {
   std::ostringstream buf;
 
   buf << fcn << " (";
 
   octave_idx_type n = ra_idx.length ();
 
   if (n > 0)
@@ -967,17 +969,18 @@ Sparse<T>::resize (octave_idx_type r, oc
   if (c != rep->ncols)
     {
       octave_idx_type *new_cidx = new octave_idx_type [c+1];
       copy_or_memcpy (std::min (c, rep->ncols)+1, rep->c, new_cidx);
       delete [] rep->c;
       rep->c = new_cidx;
 
       if (c > rep->ncols)
-        fill_or_memset (c - rep->ncols, rep->c[rep->ncols], rep->c + rep->ncols + 1);
+        fill_or_memset (c - rep->ncols, rep->c[rep->ncols],
+                        rep->c + rep->ncols + 1);
     }
 
   rep->ncols = dimensions(1) = c;
 
   rep->change_length (rep->nnz ());
 }
 
 template <class T>
@@ -1179,17 +1182,17 @@ Sparse<T>::delete_elements (const idx_ve
           OCTAVE_LOCAL_BUFFER (octave_idx_type, ridx_new, nz);
           OCTAVE_LOCAL_BUFFER (T, data_new, nz);
           idx_vector sidx = idx.sorted (true);
           const octave_idx_type *sj = sidx.raw ();
           octave_idx_type sl = sidx.length (nel), nz_new = 0, j = 0;
           for (octave_idx_type i = 0; i < nz; i++)
             {
               octave_idx_type r = tmp.ridx (i);
-              for (;j < sl && sj[j] < r; j++) ;
+              for (; j < sl && sj[j] < r; j++) ;
               if (j == sl || sj[j] > r)
                 {
                   data_new[nz_new] = tmp.data (i);
                   ridx_new[nz_new++] = r - j;
                 }
             }
 
           *this = Sparse<T> (nr - sl, 1, nz_new);
@@ -1200,23 +1203,26 @@ Sparse<T>::delete_elements (const idx_ve
     }
   else if (nr == 1)
     {
       // Sparse row vector.
       octave_idx_type lb, ub;
       if (idx.is_cont_range (nc, lb, ub))
         {
           const Sparse<T> tmp = *this;
-          octave_idx_type lbi = tmp.cidx (lb), ubi = tmp.cidx (ub), new_nz = nz - (ubi - lbi);
+          octave_idx_type lbi = tmp.cidx (lb);
+          octave_idx_type ubi = tmp.cidx (ub);
+          octave_idx_type new_nz = nz - (ubi - lbi);
           *this = Sparse<T> (1, nc - (ub - lb), new_nz);
           copy_or_memcpy (lbi, tmp.data (), data ());
           copy_or_memcpy (nz - ubi, tmp.data () + ubi, xdata () + lbi);
           fill_or_memset (new_nz, static_cast<octave_idx_type> (0), ridx ());
           copy_or_memcpy (lb, tmp.cidx () + 1, cidx () + 1);
-          mx_inline_sub (nc - ub, xcidx () + 1, tmp.cidx () + ub + 1, ubi - lbi);
+          mx_inline_sub (nc - ub, xcidx () + 1, tmp.cidx () + ub + 1,
+                         ubi - lbi);
         }
       else
         *this = index (idx.complement (nc));
     }
   else if (idx.length (nel) != 0)
     {
       if (idx.is_colon_equiv (nel))
         *this = Sparse<T> ();
@@ -1255,18 +1261,19 @@ Sparse<T>::delete_elements (const idx_ve
           else if (nz == 0)
             {
               // No elements to preserve; adjust dimensions.
               *this = Sparse<T> (nr, nc - (ub - lb));
             }
           else
             {
               const Sparse<T> tmp = *this;
-              octave_idx_type lbi = tmp.cidx(lb), ubi = tmp.cidx(ub),
-                new_nz = nz - (ubi - lbi);
+              octave_idx_type lbi = tmp.cidx(lb);
+              octave_idx_type ubi = tmp.cidx(ub);
+              octave_idx_type new_nz = nz - (ubi - lbi);
 
               *this = Sparse<T> (nr, nc - (ub - lb), new_nz);
               copy_or_memcpy (lbi, tmp.data (), data ());
               copy_or_memcpy (lbi, tmp.ridx (), ridx ());
               copy_or_memcpy (nz - ubi, tmp.data () + ubi, xdata () + lbi);
               copy_or_memcpy (nz - ubi, tmp.ridx () + ubi, xridx () + lbi);
               copy_or_memcpy (lb, tmp.cidx () + 1, cidx () + 1);
               mx_inline_sub (nc - ub, xcidx () + lb + 1,
@@ -1527,49 +1534,52 @@ Sparse<T>::index (const idx_vector& idx,
       if (idx.is_scalar ())
         retval = Sparse<T> (1, 1, elem (0, idx(0)));
       else if (idx.is_cont_range (nel, lb, ub))
         {
           // Special-case a contiguous range.
           octave_idx_type lbi = cidx (lb), ubi = cidx (ub), new_nz = ubi - lbi;
           retval = Sparse<T> (1, ub - lb, new_nz);
           copy_or_memcpy (new_nz, data () + lbi, retval.data ());
-          fill_or_memset (new_nz, static_cast<octave_idx_type> (0), retval.ridx ());
+          fill_or_memset (new_nz, static_cast<octave_idx_type> (0),
+                          retval.ridx ());
           mx_inline_sub (ub - lb + 1, retval.cidx (), cidx () + lb, lbi);
         }
       else
         {
           // Sparse row vectors occupy O(nr) storage anyway, so let's just
           // convert the matrix to full, index, and sparsify the result.
           retval = Sparse<T> (array_value ().index (idx));
         }
     }
   else
     {
       if (nr != 0 && idx.is_scalar ())
         retval = Sparse<T> (1, 1, elem (idx(0) % nr, idx(0) / nr));
       else
         {
           // Indexing a non-vector sparse matrix by linear indexing.
-          // I suppose this is rare (and it may easily overflow), so let's take the easy way,
-          // and reshape first to column vector, which is already handled above.
+          // I suppose this is rare (and it may easily overflow), so let's take
+          // the easy way, and reshape first to column vector, which is already
+          // handled above.
           retval = index (idx_vector::colon).index (idx);
-          // In this case we're supposed to always inherit the shape, but column(row) doesn't do
-          // it, so we'll do it instead.
+          // In this case we're supposed to always inherit the shape, but
+          // column(row) doesn't do it, so we'll do it instead.
           if (idx_dims(0) == 1 && idx_dims(1) != 1)
             retval = retval.transpose ();
         }
     }
 
   return retval;
 }
 
 template <class T>
 Sparse<T>
-Sparse<T>::index (const idx_vector& idx_i, const idx_vector& idx_j, bool resize_ok) const
+Sparse<T>::index (const idx_vector& idx_i, const idx_vector& idx_j,
+                  bool resize_ok) const
 {
   Sparse<T> retval;
 
   assert (ndims () == 2);
 
   octave_idx_type nr = dim1 ();
   octave_idx_type nc = dim2 ();
 
@@ -1591,18 +1601,18 @@ Sparse<T>::index (const idx_vector& idx_
         }
       else if (idx_i.extent (nr) > nr)
         gripe_index_out_of_range (2, 1, idx_i.extent (nr), nr);
       else
         gripe_index_out_of_range (2, 2, idx_j.extent (nc), nc);
     }
   else if (nr == 1 && nc == 1)
     {
-      // Scalars stored as sparse matrices occupy more memory than 
-      // a scalar, so let's just convert the matrix to full, index, 
+      // Scalars stored as sparse matrices occupy more memory than
+      // a scalar, so let's just convert the matrix to full, index,
       // and sparsify the result.
 
       retval = Sparse<T> (array_value ().index (idx_i, idx_j));
     }
   else if (idx_i.is_colon ())
     {
       // Great, we're just manipulating columns. This is going to be quite
       // efficient, because the columns can stay compressed as they are.
@@ -1628,17 +1638,19 @@ Sparse<T>::index (const idx_vector& idx_
             }
 
           retval.change_capacity (retval.xcidx (m));
 
           // Copy data & indices.
           for (octave_idx_type j = 0; j < m; j++)
             {
               octave_idx_type ljj = cidx (idx_j(j));
-              octave_idx_type lj = retval.xcidx (j), nzj = retval.xcidx (j+1) - lj;
+              octave_idx_type lj = retval.xcidx (j);
+              octave_idx_type nzj = retval.xcidx (j+1) - lj;
+
               copy_or_memcpy (nzj, data () + ljj, retval.data () + lj);
               copy_or_memcpy (nzj, ridx () + ljj, retval.ridx () + lj);
             }
         }
     }
   else if (nc == 1 && idx_j.is_colon_equiv (nc) && idx_i.is_vector ())
     {
       // It's actually vector indexing. The 1D index is specialized for that.
@@ -1651,17 +1663,20 @@ Sparse<T>::index (const idx_vector& idx_
   else if (idx_i.is_scalar ())
     {
       octave_idx_type ii = idx_i(0);
       retval = Sparse<T> (1, m);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, ij, m);
       for (octave_idx_type j = 0; j < m; j++)
         {
           octave_quit ();
-          octave_idx_type jj = idx_j(j), lj = cidx (jj), nzj = cidx (jj+1) - cidx (jj);
+          octave_idx_type jj = idx_j(j);
+          octave_idx_type lj = cidx (jj);
+          octave_idx_type nzj = cidx (jj+1) - cidx (jj);
+
           // Scalar index - just a binary lookup.
           octave_idx_type i = lblookup (ridx () + lj, nzj, ii);
           if (i < nzj && ridx (i+lj) == ii)
             {
               ij[j] = i + lj;
               retval.xcidx (j+1) = retval.xcidx (j) + 1;
             }
           else
@@ -1684,18 +1699,21 @@ Sparse<T>::index (const idx_vector& idx_
   else if (idx_i.is_cont_range (nr, lb, ub))
     {
       retval = Sparse<T> (n, m);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, li, m);
       OCTAVE_LOCAL_BUFFER (octave_idx_type, ui, m);
       for (octave_idx_type j = 0; j < m; j++)
         {
           octave_quit ();
-          octave_idx_type jj = idx_j(j), lj = cidx (jj), nzj = cidx (jj+1) - cidx (jj);
+          octave_idx_type jj = idx_j(j);
+          octave_idx_type lj = cidx (jj);
+          octave_idx_type nzj = cidx (jj+1) - cidx (jj);
           octave_idx_type lij, uij;
+
           // Lookup indices.
           li[j] = lij = lblookup (ridx () + lj, nzj, lb) + lj;
           ui[j] = uij = lblookup (ridx () + lj, nzj, ub) + lj;
           retval.xcidx (j+1) = retval.xcidx (j) + ui[j] - li[j];
         }
 
       retval.change_capacity (retval.xcidx (m));
 
@@ -1707,17 +1725,17 @@ Sparse<T>::index (const idx_vector& idx_
             {
               retval.xdata (k) = data (i);
               retval.xridx (k++) = ridx (i) - lb;
             }
         }
     }
   else if (idx_i.is_permutation (nr))
     {
-      // The columns preserve their length, we just need to renumber and sort them.
+      // The columns preserve their length, just need to renumber and sort them.
       // Count new nonzero elements.
       retval = Sparse<T> (nr, m);
       for (octave_idx_type j = 0; j < m; j++)
         {
           octave_idx_type jj = idx_j(j);
           retval.xcidx (j+1) = retval.xcidx (j) + (cidx (jj+1) - cidx (jj));
         }
 
@@ -1726,17 +1744,19 @@ Sparse<T>::index (const idx_vector& idx_
       octave_quit ();
 
       if (idx_i.is_range () && idx_i.increment () == -1)
         {
           // It's nr:-1:1. Just flip all columns.
           for (octave_idx_type j = 0; j < m; j++)
             {
               octave_quit ();
-              octave_idx_type jj = idx_j(j), lj = cidx (jj), nzj = cidx (jj+1) - cidx (jj);
+              octave_idx_type jj = idx_j(j);
+              octave_idx_type lj = cidx (jj);
+              octave_idx_type nzj = cidx (jj+1) - cidx (jj);
               octave_idx_type li = retval.xcidx (j), uj = lj + nzj - 1;
               for (octave_idx_type i = 0; i < nzj; i++)
                 {
                   retval.xdata (li + i) = data (uj - i); // Copy in reverse order.
                   retval.xridx (li + i) = nr - 1 - ridx (uj - i); // Ditto with transform.
                 }
             }
         }
@@ -1748,17 +1768,19 @@ Sparse<T>::index (const idx_vector& idx_
 
           // Scatter buffer.
           OCTAVE_LOCAL_BUFFER (T, scb, nr);
           octave_idx_type *rri = retval.ridx ();
 
           for (octave_idx_type j = 0; j < m; j++)
             {
               octave_quit ();
-              octave_idx_type jj = idx_j(j), lj = cidx (jj), nzj = cidx (jj+1) - cidx (jj);
+              octave_idx_type jj = idx_j(j);
+              octave_idx_type lj = cidx (jj);
+              octave_idx_type nzj = cidx (jj+1) - cidx (jj);
               octave_idx_type li = retval.xcidx (j);
               // Scatter the column, transform indices.
               for (octave_idx_type i = 0; i < nzj; i++)
                 scb[rri[li + i] = iinv[ridx (lj + i)]] = data (lj + i);
 
               octave_quit ();
 
               // Sort them.
@@ -1841,18 +1863,20 @@ Sparse<T>::assign (const idx_vector& idx
 
               if (new_nz >= nz && new_nz <= capacity ())
                 {
                   // Adding/overwriting elements, enough capacity allocated.
 
                   if (new_nz > nz)
                     {
                       // Make room first.
-                      std::copy_backward (data () + ui, data () + nz, data () + nz + rnz);
-                      std::copy_backward (ridx () + ui, ridx () + nz, ridx () + nz + rnz);
+                      std::copy_backward (data () + ui, data () + nz,
+                                          data () + nz + rnz);
+                      std::copy_backward (ridx () + ui, ridx () + nz,
+                                          ridx () + nz + rnz);
                     }
 
                   // Copy data and adjust indices from rhs.
                   copy_or_memcpy (rnz, rhs.data (), data () + li);
                   mx_inline_add (rnz, ridx () + li, rhs.ridx (), lb);
                 }
               else
                 {
@@ -1865,18 +1889,20 @@ Sparse<T>::assign (const idx_vector& idx
                   copy_or_memcpy (li, tmp.data (), data ());
                   copy_or_memcpy (li, tmp.ridx (), ridx ());
 
                   // new stuff ...
                   copy_or_memcpy (rnz, rhs.data (), data () + li);
                   mx_inline_add (rnz, ridx () + li, rhs.ridx (), lb);
 
                   // ...tail
-                  copy_or_memcpy (nz - ui, tmp.data () + ui, data () + li + rnz);
-                  copy_or_memcpy (nz - ui, tmp.ridx () + ui, ridx () + li + rnz);
+                  copy_or_memcpy (nz - ui, tmp.data () + ui,
+                                  data () + li + rnz);
+                  copy_or_memcpy (nz - ui, tmp.ridx () + ui,
+                                  ridx () + li + rnz);
                 }
 
               cidx (1) = new_nz;
             }
           else if (idx.is_range () && idx.increment () == -1)
             {
               // It's s(u:-1:l) = r. Reverse the assignment.
               assign (idx.sorted (), rhs.index (idx_vector (rhl - 1, 0, -1)));
@@ -1948,17 +1974,17 @@ Sparse<T>::assign (const idx_vector& idx
 
   octave_idx_type nr = dim1 ();
   octave_idx_type nc = dim2 ();
   octave_idx_type nz = nnz ();
 
   octave_idx_type n = rhs.rows ();
   octave_idx_type m = rhs.columns ();
 
-  // FIXME -- this should probably be written more like the
+  // FIXME: this should probably be written more like the
   // Array<T>::assign function...
 
   bool orig_zero_by_zero = (nr == 0 && nc == 0);
 
   if (orig_zero_by_zero || (idx_i.length (nr) == n && idx_j.length (nc) == m))
     {
       octave_idx_type nrx;
       octave_idx_type ncx;
@@ -2028,17 +2054,18 @@ Sparse<T>::assign (const idx_vector& idx
                       std::copy (ridx () + ui, ridx () + nz,
                                  ridx () + li + rnz);
                       mx_inline_add2 (nc - ub, cidx () + ub + 1, new_nz - nz);
                     }
 
                   // Copy data and indices from rhs.
                   copy_or_memcpy (rnz, rhs.data (), data () + li);
                   copy_or_memcpy (rnz, rhs.ridx (), ridx () + li);
-                  mx_inline_add (ub - lb, cidx () + lb + 1, rhs.cidx () + 1, li);
+                  mx_inline_add (ub - lb, cidx () + lb + 1, rhs.cidx () + 1,
+                                 li);
 
                   assert (nnz () == new_nz);
                 }
               else
                 {
                   // Clearing elements or exceeding capacity, allocate afresh
                   // and paste pieces.
                   const Sparse<T> tmp = *this;
@@ -2047,30 +2074,35 @@ Sparse<T>::assign (const idx_vector& idx
                   // Head...
                   copy_or_memcpy (li, tmp.data (), data ());
                   copy_or_memcpy (li, tmp.ridx (), ridx ());
                   copy_or_memcpy (lb, tmp.cidx () + 1, cidx () + 1);
 
                   // new stuff...
                   copy_or_memcpy (rnz, rhs.data (), data () + li);
                   copy_or_memcpy (rnz, rhs.ridx (), ridx () + li);
-                  mx_inline_add (ub - lb, cidx () + lb + 1, rhs.cidx () + 1, li);
+                  mx_inline_add (ub - lb, cidx () + lb + 1, rhs.cidx () + 1,
+                                 li);
 
                   // ...tail.
-                  copy_or_memcpy (nz - ui, tmp.data () + ui, data () + li + rnz);
-                  copy_or_memcpy (nz - ui, tmp.ridx () + ui, ridx () + li + rnz);
-                  mx_inline_add (nc - ub, cidx () + ub + 1, tmp.cidx () + ub + 1, new_nz - nz);
+                  copy_or_memcpy (nz - ui, tmp.data () + ui,
+                                  data () + li + rnz);
+                  copy_or_memcpy (nz - ui, tmp.ridx () + ui,
+                                  ridx () + li + rnz);
+                  mx_inline_add (nc - ub, cidx () + ub + 1,
+                                 tmp.cidx () + ub + 1, new_nz - nz);
 
                   assert (nnz () == new_nz);
                 }
             }
           else if (idx_j.is_range () && idx_j.increment () == -1)
             {
               // It's s(:,u:-1:l) = r. Reverse the assignment.
-              assign (idx_i, idx_j.sorted (), rhs.index (idx_i, idx_vector (m - 1, 0, -1)));
+              assign (idx_i, idx_j.sorted (),
+                      rhs.index (idx_i, idx_vector (m - 1, 0, -1)));
             }
           else if (idx_j.is_permutation (nc))
             {
               *this = rhs.index (idx_i, idx_j.inverse_permutation (nc));
             }
           else
             {
               const Sparse<T> tmp = *this;
@@ -2113,17 +2145,17 @@ Sparse<T>::assign (const idx_vector& idx
                       copy_or_memcpy (u - l, tmp.ridx () + k, xridx () + l);
                     }
                 }
 
             }
         }
       else if (nc == 1 && idx_j.is_colon_equiv (nc) && idx_i.is_vector ())
         {
-          // It's actually vector indexing. The 1D assign is specialized for that.
+          // It's just vector indexing.  The 1D assign is specialized for that.
           assign (idx_i, rhs);
         }
       else if (idx_j.is_colon ())
         {
           if (idx_i.is_permutation (nr))
             {
               *this = rhs.index (idx_i.inverse_permutation (nr), idx_j);
             }
@@ -2232,17 +2264,17 @@ Sparse<T>::sort (octave_idx_type dim, so
       for (octave_idx_type k = i; k < ns; k++)
         mridx[k] = k - ns + nr;
 
       v += ns;
       mridx += ns;
     }
 
   if (dim > 0)
-      m = m.transpose ();
+    m = m.transpose ();
 
   return m;
 }
 
 template <class T>
 Sparse<T>
 Sparse<T>::sort (Array<octave_idx_type> &sidx, octave_idx_type dim,
                  sortmode mode) const
@@ -2553,18 +2585,18 @@ Sparse<T>::cat (int dim, octave_idx_type
 
   if (retval.is_empty ())
     return retval;
 
   switch (dim)
     {
     case 0:
       {
-        // sparse vertcat. This is not efficiently handled by assignment, so
-        // we'll do it directly.
+        // sparse vertcat.  This is not efficiently handled by assignment,
+        // so we'll do it directly.
         octave_idx_type l = 0;
         for (octave_idx_type j = 0; j < dv(1); j++)
           {
             octave_quit ();
 
             octave_idx_type rcum = 0;
             for (octave_idx_type i = 0; i < n; i++)
               {
@@ -2595,17 +2627,18 @@ Sparse<T>::cat (int dim, octave_idx_type
           {
             octave_quit ();
 
             // Skipping empty matrices. See the comment in Array.cc.
             if (sparse_list[i].is_empty ())
               continue;
 
             octave_idx_type u = l + sparse_list[i].columns ();
-            retval.assign (idx_vector::colon, idx_vector (l, u), sparse_list[i]);
+            retval.assign (idx_vector::colon, idx_vector (l, u),
+                           sparse_list[i]);
             l = u;
           }
 
         break;
       }
     default:
       assert (false);
     }
diff --git a/liboctave/array/Sparse.h b/liboctave/array/Sparse.h
--- a/liboctave/array/Sparse.h
+++ b/liboctave/array/Sparse.h
@@ -68,49 +68,49 @@ protected:
     octave_idx_type *c;
     octave_idx_type nzmx;
     octave_idx_type nrows;
     octave_idx_type ncols;
     octave_refcount<int> count;
 
     SparseRep (void)
       : d (0), r (0), c (new octave_idx_type [1]), nzmx (0), nrows (0),
-      ncols (0), count (1)
-      {
-        c[0] = 0;
-      }
+        ncols (0), count (1)
+    {
+      c[0] = 0;
+    }
 
     SparseRep (octave_idx_type n)
       : d (0), r (0), c (new octave_idx_type [n+1]), nzmx (0), nrows (n),
-      ncols (n), count (1)
-      {
-        for (octave_idx_type i = 0; i < n + 1; i++)
-          c[i] = 0;
-      }
+        ncols (n), count (1)
+    {
+      for (octave_idx_type i = 0; i < n + 1; i++)
+        c[i] = 0;
+    }
 
     SparseRep (octave_idx_type nr, octave_idx_type nc, octave_idx_type nz = 0)
       : d (nz > 0 ? new T [nz] : 0),
-      r (nz > 0 ? new octave_idx_type [nz] : 0),
-      c (new octave_idx_type [nc+1]), nzmx (nz), nrows (nr),
-      ncols (nc), count (1)
-      {
-        for (octave_idx_type i = 0; i < nc + 1; i++)
-          c[i] = 0;
-      }
+        r (nz > 0 ? new octave_idx_type [nz] : 0),
+        c (new octave_idx_type [nc+1]), nzmx (nz), nrows (nr),
+        ncols (nc), count (1)
+    {
+      for (octave_idx_type i = 0; i < nc + 1; i++)
+        c[i] = 0;
+    }
 
     SparseRep (const SparseRep& a)
       : d (new T [a.nzmx]), r (new octave_idx_type [a.nzmx]),
-      c (new octave_idx_type [a.ncols + 1]),
-      nzmx (a.nzmx), nrows (a.nrows), ncols (a.ncols), count (1)
-      {
-        octave_idx_type nz = a.nnz ();
-        copy_or_memcpy (nz, a.d, d);
-        copy_or_memcpy (nz, a.r, r);
-        copy_or_memcpy (ncols + 1, a.c, c);
-      }
+        c (new octave_idx_type [a.ncols + 1]),
+        nzmx (a.nzmx), nrows (a.nrows), ncols (a.ncols), count (1)
+    {
+      octave_idx_type nz = a.nnz ();
+      copy_or_memcpy (nz, a.d, d);
+      copy_or_memcpy (nz, a.r, r);
+      copy_or_memcpy (ncols + 1, a.c, c);
+    }
 
     ~SparseRep (void) { delete [] d; delete [] r; delete [] c; }
 
     octave_idx_type length (void) const { return nzmx; }
 
     octave_idx_type nnz (void) const { return c[ncols]; }
 
     T& elem (octave_idx_type _r, octave_idx_type _c);
@@ -202,18 +202,19 @@ public:
 
   // Both SparseMatrix and SparseBoolMatrix need this ctor, and this
   // is their only common ancestor.
   explicit Sparse (const PermMatrix& a);
 
   // Type conversion case. Preserves capacity ().
   template <class U>
   Sparse (const Sparse<U>& a)
-    : rep (new typename Sparse<T>::SparseRep (a.rep->nrows, a.rep->ncols, a.rep->nzmx)),
-      dimensions (a.dimensions)
+    : rep (new typename Sparse<T>::SparseRep (a.rep->nrows, a.rep->ncols,
+           a.rep->nzmx)),
+    dimensions (a.dimensions)
   {
     octave_idx_type nz = a.nnz ();
     std::copy (a.rep->d, a.rep->d + nz, rep->d);
     copy_or_memcpy (nz, a.rep->r, rep->r);
     copy_or_memcpy (rep->ncols + 1, a.rep->c, rep->c);
   }
 
   // No type conversion case.
@@ -316,17 +317,17 @@ public:
   }
 
   T& xelem (const Array<octave_idx_type>& ra_idx)
   { return xelem (compute_index (ra_idx)); }
 
   T xelem (const Array<octave_idx_type>& ra_idx) const
   { return xelem (compute_index (ra_idx)); }
 
-  // FIXME -- would be nice to fix this so that we don't
+  // FIXME: would be nice to fix this so that we don't
   // unnecessarily force a copy, but that is not so easy, and I see no
   // clean way to do it.
 
   T& checkelem (octave_idx_type n)
   {
     if (n < 0 || n >= numel ())
       return range_error ("T& Sparse<T>::checkelem", n);
     else
@@ -505,43 +506,43 @@ public:
   Sparse<T> transpose (void) const;
 
   T* data (void) { make_unique (); return rep->d; }
   T& data (octave_idx_type i) { make_unique (); return rep->data (i); }
   T* xdata (void) { return rep->d; }
   T& xdata (octave_idx_type i) { return rep->data (i); }
 
   T data (octave_idx_type i) const { return rep->data (i); }
-  // FIXME -- shouldn't this be returning const T*?
+  // FIXME: shouldn't this be returning const T*?
   T* data (void) const { return rep->d; }
 
   octave_idx_type* ridx (void) { make_unique (); return rep->r; }
   octave_idx_type& ridx (octave_idx_type i)
   {
     make_unique (); return rep->ridx (i);
   }
 
   octave_idx_type* xridx (void) { return rep->r; }
   octave_idx_type& xridx (octave_idx_type i) { return rep->ridx (i); }
 
   octave_idx_type ridx (octave_idx_type i) const { return rep->cridx (i); }
-  // FIXME -- shouldn't this be returning const octave_idx_type*?
+  // FIXME: shouldn't this be returning const octave_idx_type*?
   octave_idx_type* ridx (void) const { return rep->r; }
 
   octave_idx_type* cidx (void) { make_unique (); return rep->c; }
   octave_idx_type& cidx (octave_idx_type i)
   {
     make_unique (); return rep->cidx (i);
   }
 
   octave_idx_type* xcidx (void) { return rep->c; }
   octave_idx_type& xcidx (octave_idx_type i) { return rep->cidx (i); }
 
   octave_idx_type cidx (octave_idx_type i) const { return rep->ccidx (i); }
-  // FIXME -- shouldn't this be returning const octave_idx_type*?
+  // FIXME: shouldn't this be returning const octave_idx_type*?
   octave_idx_type* cidx (void) const { return rep->c; }
 
   octave_idx_type ndims (void) const { return dimensions.length (); }
 
   void delete_elements (const idx_vector& i);
 
   void delete_elements (int dim, const idx_vector& i);
 
@@ -626,17 +627,17 @@ public:
         octave_idx_type nc = cols ();
 
         result = Sparse<U> (nr, nc, f_zero);
 
         for (octave_idx_type j = 0; j < nc; j++)
           for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
               octave_quit ();
-              /* Use data instead of elem for better performance.  */
+              /* Use data instead of elem for better performance. */
               result.data (ridx (i) + j * nr) = fcn (data (i));
             }
 
         result.maybe_compress (true);
       }
     else
       {
         octave_idx_type nz = nnz ();
@@ -761,14 +762,14 @@ read_sparse_matrix (std::istream& is, Sp
           else
             goto done;
         }
 
       for (octave_idx_type j = jold; j < nc; j++)
         a.cidx (j+1) = ii;
     }
 
- done:
+done:
 
   return is;
 }
 
 #endif
diff --git a/liboctave/array/boolMatrix.cc b/liboctave/array/boolMatrix.cc
--- a/liboctave/array/boolMatrix.cc
+++ b/liboctave/array/boolMatrix.cc
@@ -79,18 +79,17 @@ boolMatrix::operator ! (void) const
 // other operations
 
 boolMatrix
 boolMatrix::diag (octave_idx_type k) const
 {
   return Array<bool>::diag (k);
 }
 
-// FIXME Do these really belong here?  Maybe they should be
-// in a base class?
+// FIXME: Do these really belong here?  Maybe they should be in a base class?
 
 boolMatrix
 boolMatrix::all (int dim) const
 {
   return do_mx_red_op<bool, bool> (*this, dim, mx_inline_all);
 }
 
 boolMatrix
diff --git a/liboctave/array/boolMatrix.h b/liboctave/array/boolMatrix.h
--- a/liboctave/array/boolMatrix.h
+++ b/liboctave/array/boolMatrix.h
@@ -47,29 +47,30 @@ public:
 
   boolMatrix (const dim_vector& dv, bool val) : Array<bool> (dv, val) { }
 
   boolMatrix (const Array<bool>& a) : Array<bool> (a.as_matrix ()) { }
 
   boolMatrix (const boolMatrix& a) : Array<bool> (a) { }
 
   boolMatrix& operator = (const boolMatrix& a)
-    {
-      Array<bool>::operator = (a);
-      return *this;
-    }
+  {
+    Array<bool>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const boolMatrix& a) const;
   bool operator != (const boolMatrix& a) const;
 
   boolMatrix transpose (void) const { return Array<bool>::transpose (); }
 
   // destructive insert/delete/reorder operations
 
-  boolMatrix& insert (const boolMatrix& a, octave_idx_type r, octave_idx_type c);
+  boolMatrix& insert (const boolMatrix& a,
+                      octave_idx_type r, octave_idx_type c);
 
   // unary operations
 
   boolMatrix operator ! (void) const;
 
   // other operations
 
   boolMatrix diag (octave_idx_type k = 0) const;
diff --git a/liboctave/array/boolNDArray.cc b/liboctave/array/boolNDArray.cc
--- a/liboctave/array/boolNDArray.cc
+++ b/liboctave/array/boolNDArray.cc
@@ -49,17 +49,17 @@ boolNDArray::invert (void)
   if (is_shared ())
     *this = ! *this;
   else
     do_mx_inplace_op<bool> (*this, mx_inline_not2);
 
   return *this;
 }
 
-// FIXME -- this is not quite the right thing.
+// FIXME: this is not quite the right thing.
 
 boolNDArray
 boolNDArray::all (int dim) const
 {
   return do_mx_red_op<bool, bool> (*this, dim, mx_inline_all);
 }
 
 boolNDArray
@@ -79,17 +79,18 @@ boolNDArray::sum (int dim) const
 NDArray
 boolNDArray::cumsum (int dim) const
 {
   // In this case, it's better to sum directly to doubles.
   return do_mx_cum_op<double , bool> (*this, dim, mx_inline_cumcount);
 }
 
 boolNDArray
-boolNDArray::concat (const boolNDArray& rb, const Array<octave_idx_type>& ra_idx)
+boolNDArray::concat (const boolNDArray& rb,
+                     const Array<octave_idx_type>& ra_idx)
 {
   if (rb.numel () > 0)
     insert (rb, ra_idx);
   return *this;
 }
 
 boolNDArray&
 boolNDArray::insert (const boolNDArray& a, octave_idx_type r, octave_idx_type c)
diff --git a/liboctave/array/boolNDArray.h b/liboctave/array/boolNDArray.h
--- a/liboctave/array/boolNDArray.h
+++ b/liboctave/array/boolNDArray.h
@@ -49,52 +49,55 @@ public:
 
   boolNDArray (const boolNDArray& a) : Array<bool> (a) { }
 
   boolNDArray (const boolMatrix& a) : Array<bool> (a) { }
 
   boolNDArray (const Array<bool>& a) : Array<bool> (a) { }
 
   boolNDArray& operator = (const boolNDArray& a)
-    {
-      Array<bool>::operator = (a);
-      return *this;
-    }
+  {
+    Array<bool>::operator = (a);
+    return *this;
+  }
 
   // unary operations
 
   boolNDArray operator ! (void) const;
 
   boolNDArray& invert (void);
 
   bool any_element_is_nan (void) const { return false; }
 
-  // FIXME -- this is not quite the right thing.
+  // FIXME: this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
   NDArray sum (int dim = -1) const;
   NDArray cumsum (int dim = -1) const;
 
-  boolNDArray concat (const boolNDArray& rb, const Array<octave_idx_type>& ra_idx);
+  boolNDArray concat (const boolNDArray& rb,
+                      const Array<octave_idx_type>& ra_idx);
 
-  boolNDArray& insert (const boolNDArray& a, octave_idx_type r, octave_idx_type c);
-  boolNDArray& insert (const boolNDArray& a, const Array<octave_idx_type>& ra_idx);
+  boolNDArray& insert (const boolNDArray& a, octave_idx_type r,
+                       octave_idx_type c);
+  boolNDArray& insert (const boolNDArray& a,
+                       const Array<octave_idx_type>& ra_idx);
 
   boolMatrix matrix_value (void) const;
 
   boolNDArray squeeze (void) const { return Array<bool>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
-                            const dim_vector& dimensions);
+                                        const dim_vector& dimensions);
 
   // i/o
 
   // friend std::ostream& operator << (std::ostream& os, const NDArray& a);
   // friend std::istream& operator >> (std::istream& is, NDArray& a);
 
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (double& max_val, double& min_val) const;
diff --git a/liboctave/array/boolSparse.cc b/liboctave/array/boolSparse.cc
--- a/liboctave/array/boolSparse.cc
+++ b/liboctave/array/boolSparse.cc
@@ -50,47 +50,50 @@ SparseBoolMatrix::operator == (const Spa
   octave_idx_type nc_a = a.cols ();
   octave_idx_type nz_a = a.nnz ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     if (cidx (i) != a.cidx (i))
-        return false;
+      return false;
 
   for (octave_idx_type i = 0; i < nz; i++)
     if (data (i) != a.data (i) || ridx (i) != a.ridx (i))
       return false;
 
   return true;
 }
 
 bool
 SparseBoolMatrix::operator != (const SparseBoolMatrix& a) const
 {
   return !(*this == a);
 }
 
 SparseBoolMatrix&
-SparseBoolMatrix::insert (const SparseBoolMatrix& a, octave_idx_type r, octave_idx_type c)
+SparseBoolMatrix::insert (const SparseBoolMatrix& a,
+                          octave_idx_type r, octave_idx_type c)
 {
   Sparse<bool>::insert (a, r, c);
   return *this;
 }
 
 SparseBoolMatrix&
-SparseBoolMatrix::insert (const SparseBoolMatrix& a, const Array<octave_idx_type>& indx)
+SparseBoolMatrix::insert (const SparseBoolMatrix& a,
+                          const Array<octave_idx_type>& indx)
 {
   Sparse<bool>::insert (a, indx);
   return *this;
 }
 
 SparseBoolMatrix
-SparseBoolMatrix::concat (const SparseBoolMatrix& rb, const Array<octave_idx_type>& ra_idx)
+SparseBoolMatrix::concat (const SparseBoolMatrix& rb,
+                          const Array<octave_idx_type>& ra_idx)
 {
   // Don't use numel to avoid all possiblity of an overflow
   if (rb.rows () > 0 && rb.cols () > 0)
     insert (rb, ra_idx(0), ra_idx(1));
   return *this;
 }
 
 // unary operations
@@ -123,18 +126,17 @@ SparseBoolMatrix::operator ! (void) cons
       r.cidx (i+1) = ii;
     }
 
   return r;
 }
 
 // other operations
 
-// FIXME Do these really belong here?  Maybe they should be
-// in a base class?
+// FIXME: Do these really belong here?  Maybe they should be in a base class?
 
 SparseBoolMatrix
 SparseBoolMatrix::all (int dim) const
 {
   SPARSE_ALL_OP (dim);
 }
 
 SparseBoolMatrix
@@ -251,24 +253,24 @@ SparseBoolMatrix::matrix_value (void) co
   return retval;
 }
 
 std::ostream&
 operator << (std::ostream& os, const SparseBoolMatrix& a)
 {
   octave_idx_type nc = a.cols ();
 
-   // add one to the printed indices to go from
-   //  zero-based to one-based arrays
-   for (octave_idx_type j = 0; j < nc; j++)
-     {
-       octave_quit ();
-       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
-         os << a.ridx (i) + 1 << " "  << j + 1 << " " << a.data (i) << "\n";
-     }
+  // add one to the printed indices to go from
+  //  zero-based to one-based arrays
+  for (octave_idx_type j = 0; j < nc; j++)
+    {
+      octave_quit ();
+      for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
+        os << a.ridx (i) + 1 << " "  << j + 1 << " " << a.data (i) << "\n";
+    }
 
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, SparseBoolMatrix& a)
 {
   typedef SparseBoolMatrix::element_type elt_type;
@@ -284,17 +286,18 @@ SparseBoolMatrix::squeeze (void) const
 
 SparseBoolMatrix
 SparseBoolMatrix::index (const idx_vector& i, bool resize_ok) const
 {
   return Sparse<bool>::index (i, resize_ok);
 }
 
 SparseBoolMatrix
-SparseBoolMatrix::index (const idx_vector& i, const idx_vector& j, bool resize_ok) const
+SparseBoolMatrix::index (const idx_vector& i, const idx_vector& j,
+                         bool resize_ok) const
 {
   return Sparse<bool>::index (i, j, resize_ok);
 }
 
 SparseBoolMatrix
 SparseBoolMatrix::reshape (const dim_vector& new_dims) const
 {
   return Sparse<bool>::reshape (new_dims);
diff --git a/liboctave/array/boolSparse.h b/liboctave/array/boolSparse.h
--- a/liboctave/array/boolSparse.h
+++ b/liboctave/array/boolSparse.h
@@ -33,23 +33,24 @@ class SparseMatrix;
 class
 OCTAVE_API
 SparseBoolMatrix : public Sparse<bool>
 {
 public:
 
   SparseBoolMatrix (void) : Sparse<bool> () { }
 
-  SparseBoolMatrix (octave_idx_type r, octave_idx_type c) : Sparse<bool> (r, c) { }
+  SparseBoolMatrix (octave_idx_type r, octave_idx_type c)
+    : Sparse<bool> (r, c) { }
 
   explicit SparseBoolMatrix (octave_idx_type r, octave_idx_type c, bool val)
     : Sparse<bool> (r, c, val) { }
 
-  SparseBoolMatrix (const dim_vector& dv, octave_idx_type nz = 0) :
-    Sparse<bool> (dv, nz) { }
+  SparseBoolMatrix (const dim_vector& dv, octave_idx_type nz = 0)
+    : Sparse<bool> (dv, nz) { }
 
   SparseBoolMatrix (const Sparse<bool>& a) : Sparse<bool> (a) { }
 
   SparseBoolMatrix (const SparseBoolMatrix& a) : Sparse<bool> (a) { }
 
   SparseBoolMatrix (const SparseBoolMatrix& a, const dim_vector& dv)
     : Sparse<bool> (a, dv) { }
 
@@ -60,69 +61,76 @@ public:
   explicit SparseBoolMatrix (const PermMatrix& a) : Sparse<bool> (a) { };
 
   SparseBoolMatrix (const Array<bool>& a, const idx_vector& r,
                     const idx_vector& c, octave_idx_type nr = -1,
                     octave_idx_type nc = -1, bool sum_terms = true,
                     octave_idx_type nzm = -1)
     : Sparse<bool> (a, r, c, nr, nc, sum_terms, nzm) { }
 
-  SparseBoolMatrix (octave_idx_type r, octave_idx_type c, octave_idx_type num_nz) : Sparse<bool> (r, c, num_nz) { }
+  SparseBoolMatrix (octave_idx_type r, octave_idx_type c,
+                    octave_idx_type num_nz) : Sparse<bool> (r, c, num_nz) { }
 
   SparseBoolMatrix& operator = (const SparseBoolMatrix& a)
-    {
-      Sparse<bool>::operator = (a);
-      return *this;
-    }
+  {
+    Sparse<bool>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const SparseBoolMatrix& a) const;
   bool operator != (const SparseBoolMatrix& a) const;
 
   SparseBoolMatrix transpose (void) const
-    { return Sparse<bool>::transpose (); }
+  { return Sparse<bool>::transpose (); }
 
   // destructive insert/delete/reorder operations
 
-  SparseBoolMatrix& insert (const SparseBoolMatrix& a, octave_idx_type r, octave_idx_type c);
+  SparseBoolMatrix& insert (const SparseBoolMatrix& a,
+                            octave_idx_type r, octave_idx_type c);
 
-  SparseBoolMatrix& insert (const SparseBoolMatrix& a, const Array<octave_idx_type>& indx);
+  SparseBoolMatrix& insert (const SparseBoolMatrix& a,
+                            const Array<octave_idx_type>& indx);
 
   SparseBoolMatrix concat (const SparseBoolMatrix& rb,
                            const Array<octave_idx_type>& ra_idx);
 
   SparseBoolMatrix diag (octave_idx_type k = 0) const;
 
   boolMatrix matrix_value (void) const;
 
   SparseBoolMatrix squeeze (void) const;
 
   SparseBoolMatrix index (const idx_vector& i, bool resize_ok) const;
 
-  SparseBoolMatrix index (const idx_vector& i, const idx_vector& j, bool resize_ok) const;
+  SparseBoolMatrix index (const idx_vector& i, const idx_vector& j,
+                          bool resize_ok) const;
 
   SparseBoolMatrix reshape (const dim_vector& new_dims) const;
 
-  SparseBoolMatrix permute (const Array<octave_idx_type>& vec, bool inv = false) const;
+  SparseBoolMatrix permute (const Array<octave_idx_type>& vec,
+                            bool inv = false) const;
 
   SparseBoolMatrix ipermute (const Array<octave_idx_type>& vec) const;
 
   // unary operations
 
   SparseBoolMatrix operator ! (void) const;
 
   // other operations
 
   SparseBoolMatrix all (int dim = -1) const;
   SparseBoolMatrix any (int dim = -1) const;
   SparseMatrix sum (int dim = -1) const;
 
   // i/o
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const SparseBoolMatrix& a);
-  friend OCTAVE_API std::istream& operator >> (std::istream& is, SparseBoolMatrix& a);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const SparseBoolMatrix& a);
+  friend OCTAVE_API std::istream& operator >> (std::istream& is,
+                                               SparseBoolMatrix& a);
 };
 
 SPARSE_SMS_EQNE_OP_DECLS (SparseBoolMatrix, bool, OCTAVE_API)
 SPARSE_SMS_BOOL_OP_DECLS (SparseBoolMatrix, bool, OCTAVE_API)
 
 SPARSE_SSM_EQNE_OP_DECLS (bool, SparseBoolMatrix, OCTAVE_API)
 SPARSE_SSM_BOOL_OP_DECLS (bool, SparseBoolMatrix, OCTAVE_API)
 
diff --git a/liboctave/array/chMatrix.cc b/liboctave/array/chMatrix.cc
--- a/liboctave/array/chMatrix.cc
+++ b/liboctave/array/chMatrix.cc
@@ -162,17 +162,18 @@ charMatrix::row_as_string (octave_idx_ty
 
       retval.resize (nc+1);
     }
 
   return retval;
 }
 
 charMatrix
-charMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
+charMatrix::extract (octave_idx_type r1, octave_idx_type c1,
+                     octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { std::swap (r1, r2); }
   if (c1 > c2) { std::swap (c1, c2); }
 
   octave_idx_type new_r = r2 - r1 + 1;
   octave_idx_type new_c = c2 - c1 + 1;
 
   charMatrix result (new_r, new_c);
@@ -185,18 +186,17 @@ charMatrix::extract (octave_idx_type r1,
 }
 
 charMatrix
 charMatrix::diag (octave_idx_type k) const
 {
   return Array<char>::diag (k);
 }
 
-// FIXME Do these really belong here?  Maybe they should be
-// in a base class?
+// FIXME: Do these really belong here?  Maybe they should be in a base class?
 
 boolMatrix
 charMatrix::all (int dim) const
 {
   return do_mx_red_op<bool, char> (*this, dim, mx_inline_all);
 }
 
 boolMatrix
diff --git a/liboctave/array/chMatrix.h b/liboctave/array/chMatrix.h
--- a/liboctave/array/chMatrix.h
+++ b/liboctave/array/chMatrix.h
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include "mx-defs.h"
 #include "mx-op-decl.h"
 #include "str-vec.h"
 
 class
 OCTAVE_API
 charMatrix : public Array<char>
 {
-friend class ComplexMatrix;
+  friend class ComplexMatrix;
 
 public:
 
   charMatrix (void) : Array<char> () { }
 
   charMatrix (octave_idx_type r, octave_idx_type c)
     : Array<char> (dim_vector (r, c)) { }
 
@@ -60,36 +60,38 @@ public:
 
   charMatrix (const char *s);
 
   charMatrix (const std::string& s);
 
   charMatrix (const string_vector& s, char fill_value = '\0');
 
   charMatrix& operator = (const charMatrix& a)
-    {
-      Array<char>::operator = (a);
-      return *this;
-    }
+  {
+    Array<char>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const charMatrix& a) const;
   bool operator != (const charMatrix& a) const;
 
   charMatrix transpose (void) const { return Array<char>::transpose (); }
 
   // destructive insert/delete/reorder operations
 
   charMatrix& insert (const char *s, octave_idx_type r, octave_idx_type c);
-  charMatrix& insert (const charMatrix& a, octave_idx_type r, octave_idx_type c);
+  charMatrix& insert (const charMatrix& a,
+                      octave_idx_type r, octave_idx_type c);
 
   std::string row_as_string (octave_idx_type, bool strip_ws = false) const;
 
   // resize is the destructive equivalent for this one
 
-  charMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
+  charMatrix extract (octave_idx_type r1, octave_idx_type c1,
+                      octave_idx_type r2, octave_idx_type c2) const;
 
   void resize (octave_idx_type nr, octave_idx_type nc, char rfv = 0)
   {
     Array<char>::resize (dim_vector (nr, nc), rfv);
   }
 
   charMatrix diag (octave_idx_type k = 0) const;
 
diff --git a/liboctave/array/chNDArray.cc b/liboctave/array/chNDArray.cc
--- a/liboctave/array/chNDArray.cc
+++ b/liboctave/array/chNDArray.cc
@@ -29,32 +29,33 @@ along with Octave; see the file COPYING.
 #include "chNDArray.h"
 #include "mx-base.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "mx-op-defs.h"
 
 #include "bsxfun-defs.cc"
 
-// FIXME -- this is not quite the right thing.
+// FIXME: this is not quite the right thing.
 
 boolNDArray
 charNDArray::all (int dim) const
 {
   return do_mx_red_op<bool, char> (*this, dim, mx_inline_all);
 }
 
 boolNDArray
 charNDArray::any (int dim) const
 {
   return do_mx_red_op<bool, char> (*this, dim, mx_inline_any);
 }
 
 charNDArray
-charNDArray::concat (const charNDArray& rb, const Array<octave_idx_type>& ra_idx)
+charNDArray::concat (const charNDArray& rb,
+                     const Array<octave_idx_type>& ra_idx)
 {
   if (rb.numel () > 0)
     insert (rb, ra_idx);
   return *this;
 }
 
 charNDArray
 charNDArray::concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx)
@@ -75,18 +76,17 @@ charNDArray::concat (const NDArray& rb, 
             ("invalid conversion from NaN to character");
           return *this;
         }
       else
         {
           octave_idx_type ival = NINTbig (d);
 
           if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
-            // FIXME -- is there something
-            // better we could do? Should we warn the user?
+            // FIXME: is there something better to do? Should we warn the user?
             ival = 0;
 
           tmp.elem (i) = static_cast<char>(ival);
         }
     }
 
   insert (tmp, ra_idx);
   return *this;
@@ -161,53 +161,57 @@ charNDArray
 charNDArray::diag (octave_idx_type m, octave_idx_type n) const
 {
   return Array<char>::diag (m, n);
 }
 
 charNDArray
 min (char d, const charNDArray& m)
 {
-  return do_sm_binary_op<charNDArray::element_type, char, charNDArray::element_type>
-           (d, m, mx_inline_xmin);
+  return do_sm_binary_op<charNDArray::element_type, char,
+                         charNDArray::element_type> (d, m, mx_inline_xmin);
 }
 
 charNDArray
 min (const charNDArray& m, char d)
 {
-  return do_ms_binary_op<charNDArray::element_type, charNDArray::element_type, char>
-           (m, d, mx_inline_xmin);
+  return do_ms_binary_op<charNDArray::element_type, charNDArray::element_type,
+                         char> (m, d, mx_inline_xmin);
 }
 
 charNDArray
 min (const charNDArray& a, const charNDArray& b)
 {
-  return do_mm_binary_op<charNDArray::element_type, charNDArray::element_type, charNDArray::element_type>
-           (a, b, mx_inline_xmin, mx_inline_xmin, mx_inline_xmin, "min");
+  return do_mm_binary_op<charNDArray::element_type, charNDArray::element_type,
+                         charNDArray::element_type> (a, b, mx_inline_xmin,
+                                                     mx_inline_xmin,
+                                                     mx_inline_xmin, "min");
 }
 
 charNDArray
 max (char d, const charNDArray& m)
 {
-  return do_sm_binary_op<charNDArray::element_type, char, charNDArray::element_type>
-           (d, m, mx_inline_xmax);
+  return do_sm_binary_op<charNDArray::element_type, char,
+                         charNDArray::element_type> (d, m, mx_inline_xmax);
 }
 
 charNDArray
 max (const charNDArray& m, char d)
 {
-  return do_ms_binary_op<charNDArray::element_type, charNDArray::element_type, char>
-           (m, d, mx_inline_xmax);
+  return do_ms_binary_op<charNDArray::element_type, charNDArray::element_type,
+                         char> (m, d, mx_inline_xmax);
 }
 
 charNDArray
 max (const charNDArray& a, const charNDArray& b)
 {
-  return do_mm_binary_op<charNDArray::element_type, charNDArray::element_type, charNDArray::element_type>
-           (a, b, mx_inline_xmax, mx_inline_xmax, mx_inline_xmax, "max");
+  return do_mm_binary_op<charNDArray::element_type, charNDArray::element_type,
+                         charNDArray::element_type> (a, b, mx_inline_xmax,
+                                                     mx_inline_xmax,
+                                                     mx_inline_xmax, "max");
 }
 
 NDS_CMP_OPS (charNDArray, char)
 NDS_BOOL_OPS (charNDArray, char)
 
 SND_CMP_OPS (char, charNDArray)
 SND_BOOL_OPS (char, charNDArray)
 
diff --git a/liboctave/array/chNDArray.h b/liboctave/array/chNDArray.h
--- a/liboctave/array/chNDArray.h
+++ b/liboctave/array/chNDArray.h
@@ -54,48 +54,51 @@ public:
 
   charNDArray (const std::string& s) : Array<char> (charMatrix (s)) { }
 
   charNDArray (const string_vector& s) : Array<char> (charMatrix (s)) { }
 
   charNDArray (const Array<char>& a) : Array<char> (a) { }
 
   charNDArray& operator = (const charNDArray& a)
-    {
-      Array<char>::operator = (a);
-      return *this;
-    }
+  {
+    Array<char>::operator = (a);
+    return *this;
+  }
 
   bool any_element_is_nan (void) const { return false; }
 
-  // FIXME -- this is not quite the right thing.
+  // FIXME: this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
-  charNDArray concat (const charNDArray& rb, const Array<octave_idx_type>& ra_idx);
+  charNDArray concat (const charNDArray& rb,
+                      const Array<octave_idx_type>& ra_idx);
   charNDArray concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx);
 
   charNDArray max (int dim = -1) const;
   charNDArray max (Array<octave_idx_type>& index, int dim = -1) const;
   charNDArray min (int dim = -1) const;
   charNDArray min (Array<octave_idx_type>& index, int dim = -1) const;
 
-  charNDArray& insert (const charNDArray& a, octave_idx_type r, octave_idx_type c);
-  charNDArray& insert (const charNDArray& a, const Array<octave_idx_type>& ra_idx);
+  charNDArray& insert (const charNDArray& a,
+                       octave_idx_type r, octave_idx_type c);
+  charNDArray& insert (const charNDArray& a,
+                       const Array<octave_idx_type>& ra_idx);
 
   charMatrix matrix_value (void) const;
 
   charNDArray squeeze (void) const { return Array<char>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
-                            const dim_vector& dimensions);
+                                        const dim_vector& dimensions);
 
   // i/o
 
   // friend std::ostream& operator << (std::ostream& os, const charNDArray& a);
   // friend std::istream& operator >> (std::istream& is, charNDArray& a);
 
   charNDArray diag (octave_idx_type k = 0) const;
 
diff --git a/liboctave/array/dColVector.h b/liboctave/array/dColVector.h
--- a/liboctave/array/dColVector.h
+++ b/liboctave/array/dColVector.h
@@ -46,20 +46,20 @@ public:
     : MArray<double> (dim_vector (n, 1), val) { }
 
   ColumnVector (const ColumnVector& a) : MArray<double> (a) { }
 
   ColumnVector (const MArray<double>& a) : MArray<double> (a.as_column ()) { }
   ColumnVector (const Array<double>& a) : MArray<double> (a.as_column ()) { }
 
   ColumnVector& operator = (const ColumnVector& a)
-    {
-      MArray<double>::operator = (a);
-      return *this;
-    }
+  {
+    MArray<double>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const ColumnVector& a) const;
   bool operator != (const ColumnVector& a) const;
 
   // destructive insert/delete/reorder operations
 
   ColumnVector& insert (const ColumnVector& a, octave_idx_type r);
 
@@ -76,41 +76,45 @@ public:
   // resize is the destructive equivalent for this one
 
   ColumnVector extract (octave_idx_type r1, octave_idx_type r2) const;
 
   ColumnVector extract_n (octave_idx_type r1, octave_idx_type n) const;
 
   // matrix by column vector -> column vector operations
 
-  friend OCTAVE_API ColumnVector operator * (const Matrix& a, const ColumnVector& b);
+  friend OCTAVE_API ColumnVector operator * (const Matrix& a,
+                                             const ColumnVector& b);
 
   // diagonal matrix by column vector -> column vector operations
 
-  friend OCTAVE_API ColumnVector operator * (const DiagMatrix& a, const ColumnVector& b);
+  friend OCTAVE_API ColumnVector operator * (const DiagMatrix& a,
+                                             const ColumnVector& b);
 
   // other operations
 
   double min (void) const;
   double max (void) const;
 
   ColumnVector abs (void) const;
 
   // i/o
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ColumnVector& a);
-  friend OCTAVE_API std::istream& operator >> (std::istream& is, ColumnVector& a);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const ColumnVector& a);
+  friend OCTAVE_API std::istream& operator >> (std::istream& is,
+                                               ColumnVector& a);
 
   void resize (octave_idx_type n, const double& rfv = 0)
   {
     Array<double>::resize (dim_vector (n, 1), rfv);
   }
 
   void clear (octave_idx_type n)
-    { Array<double>::clear (n, 1); }
+  { Array<double>::clear (n, 1); }
 
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API ColumnVector real (const ComplexColumnVector& a);
 extern OCTAVE_API ColumnVector imag (const ComplexColumnVector& a);
 
diff --git a/liboctave/array/dDiagMatrix.cc b/liboctave/array/dDiagMatrix.cc
--- a/liboctave/array/dDiagMatrix.cc
+++ b/liboctave/array/dDiagMatrix.cc
@@ -152,17 +152,18 @@ real (const ComplexDiagMatrix& a)
 
 DiagMatrix
 imag (const ComplexDiagMatrix& a)
 {
   return DiagMatrix (imag (a.extract_diag ()), a.rows (), a.cols ());
 }
 
 Matrix
-DiagMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
+DiagMatrix::extract (octave_idx_type r1, octave_idx_type c1,
+                     octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { std::swap (r1, r2); }
   if (c1 > c2) { std::swap (c1, c2); }
 
   octave_idx_type new_r = r2 - r1 + 1;
   octave_idx_type new_c = c2 - c1 + 1;
 
   Matrix result (new_r, new_c);
diff --git a/liboctave/array/dDiagMatrix.h b/liboctave/array/dDiagMatrix.h
--- a/liboctave/array/dDiagMatrix.h
+++ b/liboctave/array/dDiagMatrix.h
@@ -30,88 +30,93 @@ along with Octave; see the file COPYING.
 #include "DET.h"
 
 #include "mx-defs.h"
 
 class
 OCTAVE_API
 DiagMatrix : public MDiagArray2<double>
 {
-friend class SVD;
-friend class ComplexSVD;
+  friend class SVD;
+  friend class ComplexSVD;
 
 public:
 
   DiagMatrix (void) : MDiagArray2<double> () { }
 
-  DiagMatrix (octave_idx_type r, octave_idx_type c) : MDiagArray2<double> (r, c) { }
+  DiagMatrix (octave_idx_type r, octave_idx_type c)
+    : MDiagArray2<double> (r, c) { }
 
-  DiagMatrix (octave_idx_type r, octave_idx_type c, double val) : MDiagArray2<double> (r, c, val) { }
+  DiagMatrix (octave_idx_type r, octave_idx_type c, double val)
+    : MDiagArray2<double> (r, c, val) { }
 
   DiagMatrix (const DiagMatrix& a) : MDiagArray2<double> (a) { }
 
   DiagMatrix (const MDiagArray2<double>& a) : MDiagArray2<double> (a) { }
 
   template <class U>
   DiagMatrix (const DiagArray2<U>& a) : MDiagArray2<double> (a) { }
 
   explicit DiagMatrix (const Array<double>& a) : MDiagArray2<double> (a) { }
 
   DiagMatrix (const Array<double>& a, octave_idx_type r, octave_idx_type c)
     : MDiagArray2<double> (a, r, c) { }
 
   DiagMatrix& operator = (const DiagMatrix& a)
-    {
-      MDiagArray2<double>::operator = (a);
-      return *this;
-    }
+  {
+    MDiagArray2<double>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const DiagMatrix& a) const;
   bool operator != (const DiagMatrix& a) const;
 
   DiagMatrix& fill (double val);
   DiagMatrix& fill (double val, octave_idx_type beg, octave_idx_type end);
   DiagMatrix& fill (const ColumnVector& a);
   DiagMatrix& fill (const RowVector& a);
   DiagMatrix& fill (const ColumnVector& a, octave_idx_type beg);
   DiagMatrix& fill (const RowVector& a, octave_idx_type beg);
 
-  DiagMatrix transpose (void) const { return MDiagArray2<double>::transpose (); }
+  DiagMatrix transpose (void) const
+  { return MDiagArray2<double>::transpose (); }
   DiagMatrix abs (void) const;
 
   friend OCTAVE_API DiagMatrix real (const ComplexDiagMatrix& a);
   friend OCTAVE_API DiagMatrix imag (const ComplexDiagMatrix& a);
 
   // resize is the destructive analog for this one
 
-  Matrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
+  Matrix extract (octave_idx_type r1, octave_idx_type c1,
+                  octave_idx_type r2, octave_idx_type c2) const;
 
   // extract row or column i.
 
   RowVector row (octave_idx_type i) const;
   RowVector row (char *s) const;
 
   ColumnVector column (octave_idx_type i) const;
   ColumnVector column (char *s) const;
 
   DiagMatrix inverse (void) const;
   DiagMatrix inverse (octave_idx_type& info) const;
   DiagMatrix pseudo_inverse (void) const;
 
   // other operations
 
   ColumnVector extract_diag (octave_idx_type k = 0) const
-    { return MDiagArray2<double>::extract_diag (k); }
+  { return MDiagArray2<double>::extract_diag (k); }
 
   DET determinant (void) const;
   double rcond (void) const;
 
   // i/o
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const DiagMatrix& a);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const DiagMatrix& a);
 
 };
 
 OCTAVE_API DiagMatrix real (const ComplexDiagMatrix& a);
 OCTAVE_API DiagMatrix imag (const ComplexDiagMatrix& a);
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -264,18 +264,17 @@ Matrix::Matrix (const PermMatrix& a)
   if (a.is_col_perm ())
     for (octave_idx_type i = 0; i < len; i++)
       elem (ia(i), i) = 1.0;
   else
     for (octave_idx_type i = 0; i < len; i++)
       elem (i, ia(i)) = 1.0;
 }
 
-// FIXME -- could we use a templated mixed-type copy function
-// here?
+// FIXME: could we use a templated mixed-type copy function here?
 
 Matrix::Matrix (const boolMatrix& a)
   : MArray<double> (a)
 {
 }
 
 Matrix::Matrix (const charMatrix& a)
   : MArray<double> (a.dims ())
@@ -408,17 +407,18 @@ Matrix::fill (double val)
         for (octave_idx_type i = 0; i < nr; i++)
           xelem (i, j) = val;
     }
 
   return *this;
 }
 
 Matrix&
-Matrix::fill (double val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2)
+Matrix::fill (double val, octave_idx_type r1, octave_idx_type c1,
+              octave_idx_type r2, octave_idx_type c2)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
     {
       (*current_liboctave_error_handler) ("range error for fill");
@@ -596,26 +596,28 @@ real (const ComplexMatrix& a)
 
 Matrix
 imag (const ComplexMatrix& a)
 {
   return do_mx_unary_op<double, Complex> (a, mx_inline_imag);
 }
 
 Matrix
-Matrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
+Matrix::extract (octave_idx_type r1, octave_idx_type c1,
+                 octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { std::swap (r1, r2); }
   if (c1 > c2) { std::swap (c1, c2); }
 
   return index (idx_vector (r1, r2+1), idx_vector (c1, c2+1));
 }
 
 Matrix
-Matrix::extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const
+Matrix::extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr,
+                   octave_idx_type nc) const
 {
   return index (idx_vector (r1, r1 + nr), idx_vector (c1, c1 + nc));
 }
 
 // extract row or column i.
 
 RowVector
 Matrix::row (octave_idx_type i) const
@@ -758,17 +760,18 @@ Matrix::finverse (MatrixType &mattype, o
       z.resize (dim_vector (lwork, 1));
       double *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm = 0;
       if (calc_cond)
-        anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
+        anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0))
+                .max ();
 
       F77_XFCN (dgetrf, DGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -1459,17 +1462,17 @@ Matrix::rcond (MatrixType &mattype) cons
             {
               octave_idx_type info = 0;
               char job = 'L';
 
               Matrix atmp = *this;
               double *tmp_data = atmp.fortran_vec ();
 
               anorm = atmp.abs().sum().
-                row(static_cast<octave_idx_type>(0)).max();
+                      row(static_cast<octave_idx_type>(0)).max();
 
               F77_XFCN (dpotrf, DPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
@@ -1500,17 +1503,17 @@ Matrix::rcond (MatrixType &mattype) cons
               Matrix atmp = *this;
               double *tmp_data = atmp.fortran_vec ();
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
-                  row(static_cast<octave_idx_type>(0)).max ();
+                        row(static_cast<octave_idx_type>(0)).max ();
 
               Array<double> z (dim_vector (4 * nc, 1));
               double *pz = z.fortran_vec ();
               Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
               F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -1536,18 +1539,18 @@ Matrix::rcond (MatrixType &mattype) cons
         rcon = 0.0;
     }
 
   return rcon;
 }
 
 Matrix
 Matrix::utsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
-                double& rcon, solve_singularity_handler sing_handler,
-                bool calc_cond, blas_trans_type transt) const
+                 double& rcon, solve_singularity_handler sing_handler,
+                 bool calc_cond, blas_trans_type transt) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
@@ -1636,18 +1639,18 @@ Matrix::utsolve (MatrixType &mattype, co
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 Matrix
 Matrix::ltsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
-                double& rcon, solve_singularity_handler sing_handler,
-                bool calc_cond, blas_trans_type transt) const
+                 double& rcon, solve_singularity_handler sing_handler,
+                 bool calc_cond, blas_trans_type transt) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
@@ -1753,17 +1756,17 @@ Matrix::fsolve (MatrixType &mattype, con
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || b.cols () == 0)
     retval = Matrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
-     // Calculate the norm of the matrix, for later use.
+      // Calculate the norm of the matrix, for later use.
       double anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
 
           Matrix atmp = *this;
@@ -1841,17 +1844,17 @@ Matrix::fsolve (MatrixType &mattype, con
           info = 0;
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           Matrix atmp = *this;
           double *tmp_data = atmp.fortran_vec ();
 
-          if(anorm < 0.)
+          if (anorm < 0.)
             anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
           Array<double> z (dim_vector (4 * nc, 1));
           double *pz = z.fortran_vec ();
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (dgetrf, DGETRF, (nr, nr, tmp_data, nr, pipvt, info));
@@ -1958,17 +1961,18 @@ Matrix::solve (MatrixType &mattype, cons
     typ = mattype.type (*this);
 
   // Only calculate the condition number for LU/Cholesky
   if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, info, rcon, sing_handler, false, transt);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, info, rcon, sing_handler, false, transt);
   else if (transt == blas_trans || transt == blas_conj_trans)
-    return transpose ().solve (mattype, b, info, rcon, sing_handler, singular_fallback);
+    return transpose ().solve (mattype, b, info, rcon, sing_handler,
+                               singular_fallback);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, info, rcon, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return Matrix ();
     }
 
@@ -1987,17 +1991,17 @@ Matrix::solve (MatrixType &typ, const Co
 {
   octave_idx_type info;
   double rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
 Matrix::solve (MatrixType &typ, const ComplexMatrix& b,
-  octave_idx_type& info) const
+               octave_idx_type& info) const
 {
   double rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
 Matrix::solve (MatrixType &typ, const ComplexMatrix& b, octave_idx_type& info,
                double& rcon) const
@@ -2061,17 +2065,18 @@ ColumnVector
 Matrix::solve (MatrixType &typ, const ColumnVector& b, octave_idx_type& info,
                double& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 ColumnVector
 Matrix::solve (MatrixType &typ, const ColumnVector& b, octave_idx_type& info,
-               double& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
+               double& rcon, solve_singularity_handler sing_handler,
+               blas_trans_type transt) const
 {
   Matrix tmp (b);
   tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
   return tmp.column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 Matrix::solve (MatrixType &typ, const ComplexColumnVector& b) const
@@ -2094,17 +2099,18 @@ Matrix::solve (MatrixType &typ, const Co
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info, rcon);
 }
 
 ComplexColumnVector
 Matrix::solve (MatrixType &typ, const ComplexColumnVector& b,
                octave_idx_type& info, double& rcon,
-               solve_singularity_handler sing_handler, blas_trans_type transt) const
+               solve_singularity_handler sing_handler,
+               blas_trans_type transt) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info, rcon, sing_handler, transt);
 }
 
 Matrix
 Matrix::solve (const Matrix& b) const
 {
@@ -2123,17 +2129,18 @@ Matrix::solve (const Matrix& b, octave_i
 Matrix
 Matrix::solve (const Matrix& b, octave_idx_type& info, double& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 Matrix
 Matrix::solve (const Matrix& b, octave_idx_type& info,
-               double& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
+               double& rcon, solve_singularity_handler sing_handler,
+               blas_trans_type transt) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, info, rcon, sing_handler, true, transt);
 }
 
 ComplexMatrix
 Matrix::solve (const ComplexMatrix& b) const
 {
@@ -2144,25 +2151,27 @@ Matrix::solve (const ComplexMatrix& b) c
 ComplexMatrix
 Matrix::solve (const ComplexMatrix& b, octave_idx_type& info) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info);
 }
 
 ComplexMatrix
-Matrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon) const
+Matrix::solve (const ComplexMatrix& b, octave_idx_type& info,
+               double& rcon) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon);
 }
 
 ComplexMatrix
 Matrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon,
-               solve_singularity_handler sing_handler, blas_trans_type transt) const
+               solve_singularity_handler sing_handler,
+               blas_trans_type transt) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon, sing_handler, transt);
 }
 
 ColumnVector
 Matrix::solve (const ColumnVector& b) const
 {
@@ -2180,17 +2189,18 @@ Matrix::solve (const ColumnVector& b, oc
 ColumnVector
 Matrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 ColumnVector
 Matrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcon,
-               solve_singularity_handler sing_handler, blas_trans_type transt) const
+               solve_singularity_handler sing_handler,
+               blas_trans_type transt) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, info, rcon, sing_handler, transt);
 }
 
 ComplexColumnVector
 Matrix::solve (const ComplexColumnVector& b) const
 {
@@ -2201,25 +2211,28 @@ Matrix::solve (const ComplexColumnVector
 ComplexColumnVector
 Matrix::solve (const ComplexColumnVector& b, octave_idx_type& info) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info);
 }
 
 ComplexColumnVector
-Matrix::solve (const ComplexColumnVector& b, octave_idx_type& info, double& rcon) const
+Matrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
+               double& rcon) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon);
 }
 
 ComplexColumnVector
-Matrix::solve (const ComplexColumnVector& b, octave_idx_type& info, double& rcon,
-               solve_singularity_handler sing_handler, blas_trans_type transt) const
+Matrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
+               double& rcon,
+               solve_singularity_handler sing_handler,
+               blas_trans_type transt) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon, sing_handler, transt);
 }
 
 Matrix
 Matrix::lssolve (const Matrix& b) const
 {
@@ -2729,18 +2742,17 @@ Matrix::all_integers (double& max_val, d
 }
 
 bool
 Matrix::too_large_for_float (void) const
 {
   return test_any (xtoo_large_for_float);
 }
 
-// FIXME Do these really belong here?  Maybe they should be
-// in a base class?
+// FIXME: Do these really belong here?  Maybe they should be in a base class?
 
 boolMatrix
 Matrix::all (int dim) const
 {
   return do_mx_red_op<bool, double> (*this, dim, mx_inline_all);
 }
 
 boolMatrix
@@ -3058,17 +3070,17 @@ operator >> (std::istream& is, Matrix& a
             tmp = octave_read_value<double> (is);
             if (is)
               a.elem (i, j) = tmp;
             else
               goto done;
           }
     }
 
- done:
+done:
 
   return is;
 }
 
 Matrix
 Givens (double x, double y)
 {
   double cc, s, temp_r;
@@ -3085,36 +3097,34 @@ Givens (double x, double y)
   return g;
 }
 
 Matrix
 Sylvester (const Matrix& a, const Matrix& b, const Matrix& c)
 {
   Matrix retval;
 
-  // FIXME -- need to check that a, b, and c are all the same
-  // size.
+  // FIXME: need to check that a, b, and c are all the same size.
 
   // Compute Schur decompositions.
 
   SCHUR as (a, "U");
   SCHUR bs (b, "U");
 
   // Transform c to new coordinates.
 
   Matrix ua = as.unitary_matrix ();
   Matrix sch_a = as.schur_matrix ();
 
   Matrix ub = bs.unitary_matrix ();
   Matrix sch_b = bs.schur_matrix ();
 
   Matrix cx = ua.transpose () * c * ub;
 
-  // Solve the sylvester equation, back-transform, and return the
-  // solution.
+  // Solve the sylvester equation, back-transform, and return the solution.
 
   octave_idx_type a_nr = a.rows ();
   octave_idx_type b_nr = b.rows ();
 
   double scale;
   octave_idx_type info;
 
   double *pa = sch_a.fortran_vec ();
@@ -3124,17 +3134,17 @@ Sylvester (const Matrix& a, const Matrix
   F77_XFCN (dtrsyl, DTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              1, a_nr, b_nr, pa, a_nr, pb,
                              b_nr, px, a_nr, scale, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
 
-  // FIXME -- check info?
+  // FIXME: check info?
 
   retval = -ua*cx*ub.transpose ();
 
   return retval;
 }
 
 // matrix by matrix -> matrix operations
 
@@ -3256,18 +3266,17 @@ xgemm (const Matrix& a, const Matrix& b,
 }
 
 Matrix
 operator * (const Matrix& a, const Matrix& b)
 {
   return xgemm (a, b);
 }
 
-// FIXME -- it would be nice to share code among the min/max
-// functions below.
+// FIXME: it would be nice to share code among the min/max functions below.
 
 #define EMPTY_RETURN_CHECK(T) \
   if (nr == 0 || nc == 0) \
     return T (nr, nc);
 
 Matrix
 min (double d, const Matrix& m)
 {
@@ -3407,17 +3416,18 @@ Matrix linspace (const ColumnVector& x1,
                  octave_idx_type n)
 
 {
   if (n < 1) n = 1;
 
   octave_idx_type m = x1.length ();
 
   if (x2.length () != m)
-    (*current_liboctave_error_handler) ("linspace: vectors must be of equal length");
+    (*current_liboctave_error_handler)
+      ("linspace: vectors must be of equal length");
 
   NoAlias<Matrix> retval;
 
   retval.clear (m, n);
   for (octave_idx_type i = 0; i < m; i++)
     retval(i, 0) = x1(i);
 
   // The last column is not needed while using delta.
diff --git a/liboctave/array/dMatrix.h b/liboctave/array/dMatrix.h
--- a/liboctave/array/dMatrix.h
+++ b/liboctave/array/dMatrix.h
@@ -71,35 +71,36 @@ public:
 
   explicit Matrix (const PermMatrix& a);
 
   explicit Matrix (const boolMatrix& a);
 
   explicit Matrix (const charMatrix& a);
 
   Matrix& operator = (const Matrix& a)
-    {
-      MArray<double>::operator = (a);
-      return *this;
-    }
+  {
+    MArray<double>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const Matrix& a) const;
   bool operator != (const Matrix& a) const;
 
   bool is_symmetric (void) const;
 
   // destructive insert/delete/reorder operations
 
   Matrix& insert (const Matrix& a, octave_idx_type r, octave_idx_type c);
   Matrix& insert (const RowVector& a, octave_idx_type r, octave_idx_type c);
   Matrix& insert (const ColumnVector& a, octave_idx_type r, octave_idx_type c);
   Matrix& insert (const DiagMatrix& a, octave_idx_type r, octave_idx_type c);
 
   Matrix& fill (double val);
-  Matrix& fill (double val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2);
+  Matrix& fill (double val, octave_idx_type r1, octave_idx_type c1,
+                octave_idx_type r2, octave_idx_type c2);
 
   Matrix append (const Matrix& a) const;
   Matrix append (const RowVector& a) const;
   Matrix append (const ColumnVector& a) const;
   Matrix append (const DiagMatrix& a) const;
 
   Matrix stack (const Matrix& a) const;
   Matrix stack (const RowVector& a) const;
@@ -110,19 +111,21 @@ public:
   friend OCTAVE_API Matrix imag (const ComplexMatrix& a);
 
   friend class ComplexMatrix;
 
   Matrix transpose (void) const { return MArray<double>::transpose (); }
 
   // resize is the destructive equivalent for this one
 
-  Matrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
+  Matrix extract (octave_idx_type r1, octave_idx_type c1,
+                  octave_idx_type r2, octave_idx_type c2) const;
 
-  Matrix extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const;
+  Matrix extract_n (octave_idx_type r1, octave_idx_type c1,
+                    octave_idx_type nr, octave_idx_type nc) const;
 
   // extract row or column i.
 
   RowVector row (octave_idx_type i) const;
 
   ColumnVector column (octave_idx_type i) const;
 
   void resize (octave_idx_type nr, octave_idx_type nc, double rfv = 0)
@@ -153,48 +156,52 @@ public:
   ComplexMatrix fourier (void) const;
   ComplexMatrix ifourier (void) const;
 
   ComplexMatrix fourier2d (void) const;
   ComplexMatrix ifourier2d (void) const;
 
   DET determinant (void) const;
   DET determinant (octave_idx_type& info) const;
-  DET determinant (octave_idx_type& info, double& rcon, int calc_cond = 1) const;
+  DET determinant (octave_idx_type& info, double& rcon,
+                   int calc_cond = 1) const;
   DET determinant (MatrixType &mattype, octave_idx_type& info,
                    double& rcon, int calc_cond = 1) const;
 
   double rcond (void) const;
   double rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
   Matrix utsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                   double& rcon, solve_singularity_handler sing_handler,
-                  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
+                  bool calc_cond = false,
+                  blas_trans_type transt = blas_no_trans) const;
 
   // Lower triangular matrix solvers
   Matrix ltsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                   double& rcon, solve_singularity_handler sing_handler,
-                  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
+                  bool calc_cond = false,
+                  blas_trans_type transt = blas_no_trans) const;
 
   // Full matrix solvers (lu/cholesky)
   Matrix fsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                  double& rcon, solve_singularity_handler sing_handler,
                  bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   Matrix solve (MatrixType &typ, const Matrix& b) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                 double& rcon) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                 double& rcon, solve_singularity_handler sing_handler,
-                bool singular_fallback = true, blas_trans_type transt = blas_no_trans) const;
+                bool singular_fallback = true,
+                blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
                        octave_idx_type& info) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b,
                        octave_idx_type& info, double& rcon,
@@ -228,34 +235,40 @@ public:
   Matrix solve (const Matrix& b, octave_idx_type& info) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcon) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcon,
                 solve_singularity_handler sing_handler,
                 blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
-  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon) const;
-  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon,
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info,
+                       double& rcon) const;
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info,
+                       double& rcon,
                        solve_singularity_handler sing_handler,
                        blas_trans_type transt = blas_no_trans) const;
 
   ColumnVector solve (const ColumnVector& b) const;
   ColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
-  ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcon) const;
-  ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcon,
+  ColumnVector solve (const ColumnVector& b, octave_idx_type& info,
+                      double& rcon) const;
+  ColumnVector solve (const ColumnVector& b, octave_idx_type& info,
+                      double& rcon,
                       solve_singularity_handler sing_handler,
                       blas_trans_type transt = blas_no_trans) const;
 
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-                             double& rcon) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-                             double& rcon, solve_singularity_handler sing_handler,
+  ComplexColumnVector solve (const ComplexColumnVector& b,
+                             octave_idx_type& info) const;
+  ComplexColumnVector solve (const ComplexColumnVector& b,
+                             octave_idx_type& info, double& rcon) const;
+  ComplexColumnVector solve (const ComplexColumnVector& b,
+                             octave_idx_type& info, double& rcon,
+                             solve_singularity_handler sing_handler,
                              blas_trans_type transt = blas_no_trans) const;
 
   // Singular solvers
   Matrix lssolve (const Matrix& b) const;
   Matrix lssolve (const Matrix& b, octave_idx_type& info) const;
   Matrix lssolve (const Matrix& b, octave_idx_type& info,
                   octave_idx_type& rank) const;
   Matrix lssolve (const Matrix& b, octave_idx_type& info,
@@ -326,34 +339,37 @@ public:
   RowVector column_min (void) const;
   RowVector column_max (void) const;
 
   RowVector column_min (Array<octave_idx_type>& index) const;
   RowVector column_max (Array<octave_idx_type>& index) const;
 
   // i/o
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const Matrix& a);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const Matrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, Matrix& a);
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API Matrix real (const ComplexMatrix& a);
 extern OCTAVE_API Matrix imag (const ComplexMatrix& a);
 
 // column vector by row vector -> matrix operations
 
-extern OCTAVE_API Matrix operator * (const ColumnVector& a, const RowVector& b);
+extern OCTAVE_API Matrix operator * (const ColumnVector& a,
+                                     const RowVector& b);
 
 // Other functions.
 
 extern OCTAVE_API Matrix Givens (double, double);
 
-extern OCTAVE_API Matrix Sylvester (const Matrix&, const Matrix&, const Matrix&);
+extern OCTAVE_API Matrix Sylvester (const Matrix&, const Matrix&,
+                                    const Matrix&);
 
 extern OCTAVE_API Matrix xgemm (const Matrix& a, const Matrix& b,
                                 blas_trans_type transa = blas_no_trans,
                                 blas_trans_type transb = blas_no_trans);
 
 extern OCTAVE_API Matrix operator * (const Matrix& a, const Matrix& b);
 
 extern OCTAVE_API Matrix min (double d, const Matrix& m);
diff --git a/liboctave/array/dNDArray.cc b/liboctave/array/dNDArray.cc
--- a/liboctave/array/dNDArray.cc
+++ b/liboctave/array/dNDArray.cc
@@ -53,17 +53,17 @@ NDArray::NDArray (const Array<octave_idx
   if (negative_to_nan)
     {
       double nan_val = lo_ieee_nan_value ();
 
       if (zero_based)
         for (octave_idx_type i = 0; i < a.numel (); i++)
           {
             double val = static_cast<double>
-              (pa[i] + static_cast<octave_idx_type> (1));
+                         (pa[i] + static_cast<octave_idx_type> (1));
             if (val <= 0)
               ptmp[i] = nan_val;
             else
               ptmp[i] = val;
           }
       else
         for (octave_idx_type i = 0; i < a.numel (); i++)
           {
@@ -74,17 +74,17 @@ NDArray::NDArray (const Array<octave_idx
               ptmp[i] = val;
           }
     }
   else
     {
       if (zero_based)
         for (octave_idx_type i = 0; i < a.numel (); i++)
           ptmp[i] = static_cast<double>
-            (pa[i] + static_cast<octave_idx_type> (1));
+                    (pa[i] + static_cast<octave_idx_type> (1));
       else
         for (octave_idx_type i = 0; i < a.numel (); i++)
           ptmp[i] = static_cast<double> (pa[i]);
     }
 }
 
 NDArray::NDArray (const charNDArray& a)
   : MArray<double> (a.dims ())
@@ -147,17 +147,17 @@ NDArray::ifourier (int dim) const
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   ComplexNDArray retval (*this);
   Complex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
     octave_fftw::ifft (out + k * stride * n, out + k * stride * n,
-                      n, howmany, stride, dist);
+                       n, howmany, stride, dist);
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::fourier2d (void) const
 {
   dim_vector dv = dims ();
@@ -329,17 +329,17 @@ NDArray::ifourier (int dim) const
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (zfftb, ZFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i] /
-              static_cast<double> (npts);
+                                                   static_cast<double> (npts);
         }
     }
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::fourier2d (void) const
@@ -422,18 +422,18 @@ NDArray::ifourier2d (void) const
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
                 prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) = prow[l] /
-                  static_cast<double> (npts);
+                retval((l + k*npts)*stride + j*dist) =
+                  prow[l] / static_cast<double> (npts);
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
@@ -517,18 +517,18 @@ NDArray::ifourierNd (void) const
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
                 prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) = prow[l] /
-                  static_cast<double> (npts);
+                retval((l + k*npts)*stride + j*dist) =
+                  prow[l] / static_cast<double> (npts);
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
 }
@@ -630,17 +630,17 @@ NDArray::all_integers (void) const
 }
 
 bool
 NDArray::too_large_for_float (void) const
 {
   return test_any (xtoo_large_for_float);
 }
 
-// FIXME -- this is not quite the right thing.
+// FIXME: this is not quite the right thing.
 
 boolNDArray
 NDArray::all (int dim) const
 {
   return do_mx_red_op<bool, double> (*this, dim, mx_inline_all);
 }
 
 boolNDArray
@@ -772,18 +772,17 @@ NDArray::concat (const charNDArray& rb, 
             ("invalid conversion from NaN to character");
           return retval;
         }
       else
         {
           octave_idx_type ival = NINTbig (d);
 
           if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
-            // FIXME -- is there something
-            // better we could do? Should we warn the user?
+            // FIXME: is there something better to do? Should we warn the user?
             ival = 0;
 
           retval.elem (i) = static_cast<char>(ival);
         }
     }
 
   if (rb.numel () == 0)
     return retval;
@@ -843,17 +842,17 @@ NDArray::isfinite (void) const
 }
 
 Matrix
 NDArray::matrix_value (void) const
 {
   Matrix retval;
 
   if (ndims () == 2)
-      retval = Matrix (Array<double> (*this));
+    retval = Matrix (Array<double> (*this));
   else
     (*current_liboctave_error_handler)
       ("invalid conversion of NDArray to Matrix");
 
   return retval;
 }
 
 void
@@ -902,26 +901,26 @@ std::istream&
 operator >> (std::istream& is, NDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
   if (nel > 0)
     {
       double tmp;
       for (octave_idx_type i = 0; i < nel; i++)
-          {
-            tmp = octave_read_value<double> (is);
-            if (is)
-              a.elem (i) = tmp;
-            else
-              goto done;
-          }
+        {
+          tmp = octave_read_value<double> (is);
+          if (is)
+            a.elem (i) = tmp;
+          else
+            goto done;
+        }
     }
 
- done:
+done:
 
   return is;
 }
 
 MINMAX_FCNS (NDArray, double)
 
 NDS_CMP_OPS (NDArray, double)
 NDS_BOOL_OPS (NDArray, double)
diff --git a/liboctave/array/dNDArray.h b/liboctave/array/dNDArray.h
--- a/liboctave/array/dNDArray.h
+++ b/liboctave/array/dNDArray.h
@@ -60,54 +60,57 @@ public:
   NDArray (const Array<U>& a) : MArray<double> (a) { }
 
   template <class U>
   explicit NDArray (const intNDArray<U>& a) : MArray<double> (a) { }
 
   NDArray (const charNDArray&);
 
   // For jit support only
-  NDArray (double *sdata, octave_idx_type slen, octave_idx_type *adims, void *arep)
+  NDArray (double *sdata, octave_idx_type slen, octave_idx_type *adims,
+           void *arep)
     : MArray<double> (sdata, slen, adims, arep) { }
 
   NDArray& operator = (const NDArray& a)
-    {
-      MArray<double>::operator = (a);
-      return *this;
-    }
+  {
+    MArray<double>::operator = (a);
+    return *this;
+  }
 
   // unary operations
 
   boolNDArray operator ! (void) const;
 
   bool any_element_is_negative (bool = false) const;
   bool any_element_is_positive (bool = false) const;
   bool any_element_is_nan (void) const;
   bool any_element_is_inf_or_nan (void) const;
   bool any_element_not_one_or_zero (void) const;
   bool all_elements_are_zero (void) const;
   bool all_elements_are_int_or_inf_or_nan (void) const;
   bool all_integers (double& max_val, double& min_val) const;
   bool all_integers (void) const;
   bool too_large_for_float (void) const;
 
-  // FIXME -- this is not quite the right thing.
+  // FIXME: this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
   NDArray cumprod (int dim = -1) const;
   NDArray cumsum (int dim = -1) const;
   NDArray prod (int dim = -1) const;
   NDArray sum (int dim = -1) const;
   NDArray xsum (int dim = -1) const;
   NDArray sumsq (int dim = -1) const;
   NDArray concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx);
-  ComplexNDArray concat (const ComplexNDArray& rb, const Array<octave_idx_type>& ra_idx);
-  charNDArray concat (const charNDArray& rb, const Array<octave_idx_type>& ra_idx);
+  ComplexNDArray concat (const ComplexNDArray& rb,
+                         const Array<octave_idx_type>& ra_idx);
+  charNDArray concat (const charNDArray& rb,
+                      const Array<octave_idx_type>& ra_idx);
 
   NDArray max (int dim = -1) const;
   NDArray max (Array<octave_idx_type>& index, int dim = -1) const;
   NDArray min (int dim = -1) const;
   NDArray min (Array<octave_idx_type>& index, int dim = -1) const;
 
   NDArray cummax (int dim = -1) const;
   NDArray cummax (Array<octave_idx_type>& index, int dim = -1) const;
@@ -142,32 +145,33 @@ public:
 
   NDArray squeeze (void) const { return MArray<double>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
-                            const dim_vector& dimensions);
+                                        const dim_vector& dimensions);
 
   // i/o
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const NDArray& a);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const NDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, NDArray& a);
 
   NDArray diag (octave_idx_type k = 0) const;
 
   NDArray diag (octave_idx_type m, octave_idx_type n) const;
 
   NDArray& changesign (void)
-    {
-      MArray<double>::changesign ();
-      return *this;
-    }
+  {
+    MArray<double>::changesign ();
+    return *this;
+  }
 
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API NDArray real (const ComplexNDArray& a);
 extern OCTAVE_API NDArray imag (const ComplexNDArray& a);
 
diff --git a/liboctave/array/dRowVector.h b/liboctave/array/dRowVector.h
--- a/liboctave/array/dRowVector.h
+++ b/liboctave/array/dRowVector.h
@@ -45,20 +45,20 @@ public:
 
   RowVector (const RowVector& a) : MArray<double> (a) { }
 
   RowVector (const MArray<double>& a) : MArray<double> (a.as_row ()) { }
 
   RowVector (const Array<double>& a) : MArray<double> (a.as_row ()) { }
 
   RowVector& operator = (const RowVector& a)
-    {
-      MArray<double>::operator = (a);
-      return *this;
-    }
+  {
+    MArray<double>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const RowVector& a) const;
   bool operator != (const RowVector& a) const;
 
   // destructive insert/delete/reorder operations
 
   RowVector& insert (const RowVector& a, octave_idx_type c);
 
@@ -84,34 +84,36 @@ public:
 
   // other operations
 
   double min (void) const;
   double max (void) const;
 
   // i/o
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const RowVector& a);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const RowVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, RowVector& a);
 
   void resize (octave_idx_type n, const double& rfv = 0)
   {
     Array<double>::resize (dim_vector (1, n), rfv);
   }
 
   void clear (octave_idx_type n)
-    { Array<double>::clear (1, n); }
+  { Array<double>::clear (1, n); }
 
 };
 
 // row vector by column vector -> scalar
 
 double OCTAVE_API operator * (const RowVector& a, const ColumnVector& b);
 
-Complex OCTAVE_API operator * (const RowVector& a, const ComplexColumnVector& b);
+Complex OCTAVE_API operator * (const RowVector& a,
+                               const ComplexColumnVector& b);
 
 // other operations
 
 OCTAVE_API RowVector linspace (double x1, double x2, octave_idx_type n);
 
 MARRAY_FORWARD_DEFS (MArray, RowVector, double)
 
 #endif
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -190,17 +190,17 @@ SparseMatrix::operator == (const SparseM
   octave_idx_type nc_a = a.cols ();
   octave_idx_type nz_a = a.nnz ();
 
   if (nr != nr_a || nc != nc_a || nz != nz_a)
     return false;
 
   for (octave_idx_type i = 0; i < nc + 1; i++)
     if (cidx (i) != a.cidx (i))
-        return false;
+      return false;
 
   for (octave_idx_type i = 0; i < nz; i++)
     if (data (i) != a.data (i) || ridx (i) != a.ridx (i))
       return false;
 
   return true;
 }
 
@@ -246,17 +246,18 @@ SparseMatrix::is_symmetric (void) const
 
       return true;
     }
 
   return false;
 }
 
 SparseMatrix&
-SparseMatrix::insert (const SparseMatrix& a, octave_idx_type r, octave_idx_type c)
+SparseMatrix::insert (const SparseMatrix& a,
+                      octave_idx_type r, octave_idx_type c)
 {
   MSparse<double>::insert (a, r, c);
   return *this;
 }
 
 SparseMatrix&
 SparseMatrix::insert (const SparseMatrix& a, const Array<octave_idx_type>& indx)
 {
@@ -357,17 +358,17 @@ SparseMatrix::max (Array<octave_idx_type
 
       for (octave_idx_type i = 0; i < nr; i++)
         found [i] = 0;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
           if (found [ridx (i)] == -j)
             found [ridx (i)] = -j - 1;
-      
+
       for (octave_idx_type i = 0; i < nr; i++)
         if (found [i] > -nc && found [i] < 0)
           idx_arg.elem (i) = -found [i];
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
@@ -508,17 +509,17 @@ SparseMatrix::min (Array<octave_idx_type
 
       for (octave_idx_type i = 0; i < nr; i++)
         found [i] = 0;
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
           if (found [ridx (i)] == -j)
             found [ridx (i)] = -j - 1;
-      
+
       for (octave_idx_type i = 0; i < nr; i++)
         if (found [i] > -nc && found [i] < 0)
           idx_arg.elem (i) = -found [i];
 
       for (octave_idx_type j = 0; j < nc; j++)
         {
           for (octave_idx_type i = cidx (j); i < cidx (j+1); i++)
             {
@@ -563,26 +564,26 @@ SparseMatrix::min (Array<octave_idx_type
         }
     }
 
   return result;
 }
 
 /*
 
-%!assert (max (max (speye (65536))), sparse (1)) 
-%!assert (min (min (speye (65536))), sparse (0)) 
-%!assert (size (max (sparse (8, 0), [], 1)), [1, 0]) 
-%!assert (size (max (sparse (8, 0), [], 2)), [8, 0]) 
-%!assert (size (max (sparse (0, 8), [], 1)), [0, 8]) 
-%!assert (size (max (sparse (0, 8), [], 2)), [0, 1]) 
-%!assert (size (min (sparse (8, 0), [], 1)), [1, 0]) 
-%!assert (size (min (sparse (8, 0), [], 2)), [8, 0]) 
-%!assert (size (min (sparse (0, 8), [], 1)), [0, 8]) 
-%!assert (size (min (sparse (0, 8), [], 2)), [0, 1]) 
+%!assert (max (max (speye (65536))), sparse (1))
+%!assert (min (min (speye (65536))), sparse (0))
+%!assert (size (max (sparse (8, 0), [], 1)), [1, 0])
+%!assert (size (max (sparse (8, 0), [], 2)), [8, 0])
+%!assert (size (max (sparse (0, 8), [], 1)), [0, 8])
+%!assert (size (max (sparse (0, 8), [], 2)), [0, 1])
+%!assert (size (min (sparse (8, 0), [], 1)), [1, 0])
+%!assert (size (min (sparse (8, 0), [], 2)), [8, 0])
+%!assert (size (min (sparse (0, 8), [], 1)), [0, 8])
+%!assert (size (min (sparse (0, 8), [], 2)), [0, 1])
 
 */
 
 RowVector
 SparseMatrix::row (octave_idx_type i) const
 {
   octave_idx_type nc = columns ();
   RowVector retval (nc, 0);
@@ -608,26 +609,28 @@ SparseMatrix::column (octave_idx_type i)
 
   for (octave_idx_type k = cidx (i); k < cidx (i+1); k++)
     retval(ridx (k)) = data (k);
 
   return retval;
 }
 
 SparseMatrix
-SparseMatrix::concat (const SparseMatrix& rb, const Array<octave_idx_type>& ra_idx)
+SparseMatrix::concat (const SparseMatrix& rb,
+                      const Array<octave_idx_type>& ra_idx)
 {
   // Don't use numel to avoid all possiblity of an overflow
   if (rb.rows () > 0 && rb.cols () > 0)
     insert (rb, ra_idx(0), ra_idx(1));
   return *this;
 }
 
 SparseComplexMatrix
-SparseMatrix::concat (const SparseComplexMatrix& rb, const Array<octave_idx_type>& ra_idx)
+SparseMatrix::concat (const SparseComplexMatrix& rb,
+                      const Array<octave_idx_type>& ra_idx)
 {
   SparseComplexMatrix retval (*this);
   if (rb.rows () > 0 && rb.cols () > 0)
     retval.insert (rb, ra_idx(0), ra_idx(1));
   return retval;
 }
 
 SparseMatrix
@@ -1164,17 +1167,17 @@ SparseMatrix::tinverse (MatrixType &matt
             }
         }
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 
- inverse_singular:
+inverse_singular:
   return SparseMatrix ();
 }
 
 SparseMatrix
 SparseMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
                        double& rcond, int, int calc_cond) const
 {
   int typ = mattype.type (false);
@@ -1199,17 +1202,17 @@ SparseMatrix::inverse (MatrixType &matty
           MatrixType tmp_typ (MatrixType::Upper);
           SparseCHOL fact (*this, info, false);
           rcond = fact.rcond ();
           if (info == 0)
             {
               double rcond2;
               SparseMatrix Q = fact.Q ();
               SparseMatrix InvL = fact.L ().transpose ().tinverse (tmp_typ,
-                                           info, rcond2, true, false);
+                                  info, rcond2, true, false);
               ret = Q * InvL.transpose () * InvL * Q.transpose ();
             }
           else
             {
               // Matrix is either singular or not positive definite
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Full;
             }
@@ -1222,19 +1225,19 @@ SparseMatrix::inverse (MatrixType &matty
           for (octave_idx_type i = 0; i < n; i++)
             Qinit(i) = i;
 
           MatrixType tmp_typ (MatrixType::Upper);
           SparseLU fact (*this, Qinit, Matrix (), false, false);
           rcond = fact.rcond ();
           double rcond2;
           SparseMatrix InvL = fact.L ().transpose ().tinverse (tmp_typ,
-                                           info, rcond2, true, false);
+                              info, rcond2, true, false);
           SparseMatrix InvU = fact.U ().tinverse (tmp_typ, info, rcond2,
-                                           true, false).transpose ();
+                                                  true, false).transpose ();
           ret = fact.Pc ().transpose () * InvU * InvL * fact.Pr ();
         }
     }
 
   return ret;
 }
 
 DET
@@ -1300,36 +1303,36 @@ SparseMatrix::determinant (octave_idx_ty
       const double *Ax = data ();
 
       UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai,
-                                         Ax, 0, &Symbolic, control, info);
+                                              Ax, 0, &Symbolic, control, info);
 
       if (status < 0)
         {
           (*current_liboctave_error_handler)
             ("SparseMatrix::determinant symbolic factorization failed");
 
           UMFPACK_DNAME (report_status) (control, status);
           UMFPACK_DNAME (report_info) (control, info);
 
-          UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
+          UMFPACK_DNAME (free_symbolic) (&Symbolic);
         }
       else
         {
           UMFPACK_DNAME (report_symbolic) (Symbolic, control);
 
           void *Numeric;
           status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
-                                       &Numeric, control, info) ;
-          UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
+                                            &Numeric, control, info);
+          UMFPACK_DNAME (free_symbolic) (&Symbolic);
 
           rcond = Info (UMFPACK_RCOND);
 
           if (status < 0)
             {
               (*current_liboctave_error_handler)
                 ("SparseMatrix::determinant numeric factorization failed");
 
@@ -1339,17 +1342,18 @@ SparseMatrix::determinant (octave_idx_ty
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
           else
             {
               UMFPACK_DNAME (report_numeric) (Numeric, control);
 
               double c10, e10;
 
-              status = UMFPACK_DNAME (get_determinant) (&c10, &e10, Numeric, info);
+              status = UMFPACK_DNAME (get_determinant) (&c10, &e10, Numeric,
+                                                        info);
 
               if (status < 0)
                 {
                   (*current_liboctave_error_handler)
                     ("SparseMatrix::determinant error calculating determinant");
 
                   UMFPACK_DNAME (report_status) (control, status);
                   UMFPACK_DNAME (report_info) (control, info);
@@ -1364,17 +1368,18 @@ SparseMatrix::determinant (octave_idx_ty
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
 
   return retval;
 }
 
 Matrix
-SparseMatrix::dsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& err,
+SparseMatrix::dsolve (MatrixType &mattype, const Matrix& b,
+                      octave_idx_type& err,
                       double& rcond, solve_singularity_handler,
                       bool calc_cond) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
@@ -1542,18 +1547,18 @@ SparseMatrix::dsolve (MatrixType &mattyp
       mattype.info ();
 
       if (typ == MatrixType::Diagonal ||
           typ == MatrixType::Permuted_Diagonal)
         {
           retval.resize (nc, b.cols (), 0);
           if (typ == MatrixType::Diagonal)
             for (octave_idx_type j = 0; j < b.cols (); j++)
-                for (octave_idx_type i = 0; i < nm; i++)
-                  retval(i,j) = b(i,j) / data (i);
+              for (octave_idx_type i = 0; i < nm; i++)
+                retval(i,j) = b(i,j) / data (i);
           else
             for (octave_idx_type j = 0; j < b.cols (); j++)
               for (octave_idx_type k = 0; k < nc; k++)
                 for (octave_idx_type i = cidx (k); i < cidx (k+1); i++)
                   retval(k,j) = b(ridx (i),j) / data (i);
 
           if (calc_cond)
             {
@@ -1575,18 +1580,18 @@ SparseMatrix::dsolve (MatrixType &mattyp
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::dsolve (MatrixType &mattype, const SparseComplexMatrix& b,
-                     octave_idx_type& err, double& rcond,
-                     solve_singularity_handler, bool calc_cond) const
+                      octave_idx_type& err, double& rcond,
+                      solve_singularity_handler, bool calc_cond) const
 {
   SparseComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
   octave_idx_type nm = (nc < nr ? nc : nr);
   err = 0;
 
@@ -3995,17 +4000,17 @@ SparseMatrix::trisolve (MatrixType &matt
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
 
             }
           else
             rcond = 1.;
         }
       else if (typ != MatrixType::Tridiagonal_Hermitian)
-               (*current_liboctave_error_handler) ("incorrect matrix type");
+        (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 SparseMatrix
 SparseMatrix::trisolve (MatrixType &mattype, const SparseMatrix& b,
                         octave_idx_type& err, double& rcond,
@@ -4555,20 +4560,20 @@ SparseMatrix::bsolve (MatrixType &mattyp
               if (calc_cond)
                 {
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpbcon, DPBCON,
-                    (F77_CONST_CHAR_ARG2 (&job, 1),
-                     nr, n_lower, tmp_data, ldm,
-                     anorm, rcond, pz, piz, err
-                     F77_CHAR_ARG_LEN (1)));
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, n_lower, tmp_data, ldm,
+                             anorm, rcond, pz, piz, err
+                             F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
@@ -4677,22 +4682,22 @@ SparseMatrix::bsolve (MatrixType &mattyp
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dgbcon, DGBCON,
-                    (F77_CONST_CHAR_ARG2 (&job, 1),
-                     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-                     anorm, rcond, pz, piz, err
-                     F77_CHAR_ARG_LEN (1)));
-
-                   if (err != 0)
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+                             anorm, rcond, pz, piz, err
+                             F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -4803,20 +4808,20 @@ SparseMatrix::bsolve (MatrixType &mattyp
               if (calc_cond)
                 {
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpbcon, DPBCON,
-                    (F77_CONST_CHAR_ARG2 (&job, 1),
-                     nr, n_lower, tmp_data, ldm,
-                     anorm, rcond, pz, piz, err
-                     F77_CHAR_ARG_LEN (1)));
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, n_lower, tmp_data, ldm,
+                             anorm, rcond, pz, piz, err
+                             F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
@@ -4872,17 +4877,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                         {
                           double tmp = Bx[i];
                           if (tmp != 0.0)
                             {
                               if (ii == x_nz)
                                 {
                                   // Resize the sparse matrix
                                   octave_idx_type sz = x_nz *
-                                    (b_nc - j) / b_nc;
+                                                       (b_nc - j) / b_nc;
                                   sz = (sz > 10 ? sz : 10) + x_nz;
                                   retval.change_capacity (sz);
                                   x_nz = sz;
                                 }
                               retval.xdata (ii) = tmp;
                               retval.xridx (ii++) = i;
                             }
                         }
@@ -4958,22 +4963,22 @@ SparseMatrix::bsolve (MatrixType &mattyp
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dgbcon, DGBCON,
-                    (F77_CONST_CHAR_ARG2 (&job, 1),
-                     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-                     anorm, rcond, pz, piz, err
-                     F77_CHAR_ARG_LEN (1)));
-
-                   if (err != 0)
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+                             anorm, rcond, pz, piz, err
+                             F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -5123,20 +5128,20 @@ SparseMatrix::bsolve (MatrixType &mattyp
               if (calc_cond)
                 {
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpbcon, DPBCON,
-                    (F77_CONST_CHAR_ARG2 (&job, 1),
-                     nr, n_lower, tmp_data, ldm,
-                     anorm, rcond, pz, piz, err
-                     F77_CHAR_ARG_LEN (1)));
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, n_lower, tmp_data, ldm,
+                             anorm, rcond, pz, piz, err
+                             F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
@@ -5255,18 +5260,18 @@ SparseMatrix::bsolve (MatrixType &mattyp
 
           if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
                 {
-                sing_handler (rcond);
-                mattype.mark_as_rectangular ();
+                  sing_handler (rcond);
+                  mattype.mark_as_rectangular ();
                 }
               else
                 (*current_liboctave_error_handler)
                   ("matrix singular to machine precision");
 
             }
           else
             {
@@ -5274,34 +5279,34 @@ SparseMatrix::bsolve (MatrixType &mattyp
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpbcon, DPBCON,
-                    (F77_CONST_CHAR_ARG2 (&job, 1),
-                     nr, n_lower, tmp_data, ldm,
-                     anorm, rcond, pz, piz, err
-                     F77_CHAR_ARG_LEN (1)));
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, n_lower, tmp_data, ldm,
+                             anorm, rcond, pz, piz, err
+                             F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
                       if (sing_handler)
                         {
-                        sing_handler (rcond);
-                        mattype.mark_as_rectangular ();
+                          sing_handler (rcond);
+                          mattype.mark_as_rectangular ();
                         }
                       else
                         (*current_liboctave_error_handler)
                           ("matrix singular to machine precision, rcond = %g",
                            rcond);
                     }
                 }
               else
@@ -5423,20 +5428,20 @@ SparseMatrix::bsolve (MatrixType &mattyp
               if (calc_cond)
                 {
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dpbcon, DPBCON,
-                    (F77_CONST_CHAR_ARG2 (&job, 1),
-                     nr, n_lower, tmp_data, ldm,
-                     anorm, rcond, pz, piz, err
-                     F77_CHAR_ARG_LEN (1)));
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nr, n_lower, tmp_data, ldm,
+                             anorm, rcond, pz, piz, err
+                             F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
@@ -5604,22 +5609,22 @@ SparseMatrix::bsolve (MatrixType &mattyp
                 {
                   char job = '1';
                   Array<double> z (dim_vector (3 * nr, 1));
                   double *pz = z.fortran_vec ();
                   Array<octave_idx_type> iz (dim_vector (nr, 1));
                   octave_idx_type *piz = iz.fortran_vec ();
 
                   F77_XFCN (dgbcon, DGBCON,
-                    (F77_CONST_CHAR_ARG2 (&job, 1),
-                     nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-                     anorm, rcond, pz, piz, err
-                     F77_CHAR_ARG_LEN (1)));
-
-                   if (err != 0)
+                            (F77_CONST_CHAR_ARG2 (&job, 1),
+                             nc, n_lower, n_upper, tmp_data, ldm, pipvt,
+                             anorm, rcond, pz, piz, err
+                             F77_CHAR_ARG_LEN (1)));
+
+                  if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || xisnan (rcond))
                     {
                       err = -2;
 
@@ -5751,36 +5756,36 @@ SparseMatrix::factorize (octave_idx_type
   octave_idx_type nc = cols ();
 
   UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1, control);
 
   void *Symbolic;
   Info = Matrix (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax, 0,
-                                     &Symbolic, control, info);
+                                          &Symbolic, control, info);
 
   if (status < 0)
     {
       (*current_liboctave_error_handler)
         ("SparseMatrix::solve symbolic factorization failed");
       err = -1;
 
       UMFPACK_DNAME (report_status) (control, status);
       UMFPACK_DNAME (report_info) (control, info);
 
-      UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
+      UMFPACK_DNAME (free_symbolic) (&Symbolic);
     }
   else
     {
       UMFPACK_DNAME (report_symbolic) (Symbolic, control);
 
       status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
-                                   &Numeric, control, info) ;
-      UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
+                                        &Numeric, control, info);
+      UMFPACK_DNAME (free_symbolic) (&Symbolic);
 
       if (calc_cond)
         rcond = Info (UMFPACK_RCOND);
       else
         rcond = 1.;
       volatile double rcond_plus_one = rcond + 1.0;
 
       if (status == UMFPACK_WARNING_singular_matrix ||
@@ -5794,29 +5799,29 @@ SparseMatrix::factorize (octave_idx_type
             sing_handler (rcond);
           else
             (*current_liboctave_error_handler)
               ("SparseMatrix::solve matrix singular to machine precision, rcond = %g",
                rcond);
 
         }
       else if (status < 0)
-          {
-            (*current_liboctave_error_handler)
-              ("SparseMatrix::solve numeric factorization failed");
-
-            UMFPACK_DNAME (report_status) (control, status);
-            UMFPACK_DNAME (report_info) (control, info);
-
-            err = -1;
-          }
-        else
-          {
-            UMFPACK_DNAME (report_numeric) (Numeric, control);
-          }
+        {
+          (*current_liboctave_error_handler)
+            ("SparseMatrix::solve numeric factorization failed");
+
+          UMFPACK_DNAME (report_status) (control, status);
+          UMFPACK_DNAME (report_info) (control, info);
+
+          err = -1;
+        }
+      else
+        {
+          UMFPACK_DNAME (report_numeric) (Numeric, control);
+        }
     }
 
   if (err != 0)
     UMFPACK_DNAME (free_numeric) (&Numeric);
 
 #else
   (*current_liboctave_error_handler) ("UMFPACK not installed");
 #endif
@@ -6002,18 +6007,19 @@ SparseMatrix::fsolve (MatrixType &mattyp
               double *info = Info.fortran_vec ();
               const octave_idx_type *Ap = cidx ();
               const octave_idx_type *Ai = ridx ();
               const double *Ax = data ();
 
               for (octave_idx_type j = 0, iidx = 0; j < b_nc; j++, iidx += b_nr)
                 {
                   status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
-                                             Ai, Ax, &result[iidx], &Bx[iidx],
-                                             Numeric, control, info);
+                                                  Ai, Ax, &result[iidx],
+                                                  &Bx[iidx], Numeric, control,
+                                                  info);
                   if (status < 0)
                     {
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
                       UMFPACK_DNAME (report_status) (control, status);
 
                       err = -1;
@@ -6243,18 +6249,18 @@ SparseMatrix::fsolve (MatrixType &mattyp
               retval.xcidx (0) = 0;
               for (octave_idx_type j = 0; j < b_nc; j++)
                 {
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b.elem (i, j);
 
                   status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
-                                             Ai, Ax, Xx, Bx, Numeric, control,
-                                             info);
+                                                  Ai, Ax, Xx, Bx, Numeric,
+                                                  control, info);
                   if (status < 0)
                     {
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
                       UMFPACK_DNAME (report_status) (control, status);
 
                       err = -1;
@@ -6491,21 +6497,21 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex c = b (i,j);
                       Bx[i] = std::real (c);
                       Bz[i] = std::imag (c);
                     }
 
                   status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
-                                             Ai, Ax, Xx, Bx, Numeric, control,
-                                             info);
+                                                  Ai, Ax, Xx, Bx, Numeric,
+                                                  control, info);
                   int status2 = UMFPACK_DNAME (solve) (UMFPACK_A,
-                                                  Ap, Ai, Ax, Xz, Bz, Numeric,
-                                                  control, info) ;
+                                                       Ap, Ai, Ax, Xz, Bz,
+                                                       Numeric, control, info);
 
                   if (status < 0 || status2 < 0)
                     {
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
                       UMFPACK_DNAME (report_status) (control, status);
 
@@ -6675,19 +6681,19 @@ SparseMatrix::fsolve (MatrixType &mattyp
                 }
 
               cholmod_sparse *X;
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               X = CHOLMOD_NAME(spsolve) (CHOLMOD_A, L, B, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               retval = SparseComplexMatrix
-                (static_cast<octave_idx_type>(X->nrow),
-                 static_cast<octave_idx_type>(X->ncol),
-                 static_cast<octave_idx_type>(X->nzmax));
+                       (static_cast<octave_idx_type>(X->nrow),
+                        static_cast<octave_idx_type>(X->ncol),
+                        static_cast<octave_idx_type>(X->nzmax));
               for (octave_idx_type j = 0;
                    j <= static_cast<octave_idx_type>(X->ncol); j++)
                 retval.xcidx (j) = static_cast<octave_idx_type *>(X->p)[j];
               for (octave_idx_type j = 0;
                    j < static_cast<octave_idx_type>(X->nzmax); j++)
                 {
                   retval.xridx (j) = static_cast<octave_idx_type *>(X->i)[j];
                   retval.xdata (j) = static_cast<Complex *>(X->x)[j];
@@ -6746,21 +6752,21 @@ SparseMatrix::fsolve (MatrixType &mattyp
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     {
                       Complex c = b (i,j);
                       Bx[i] = std::real (c);
                       Bz[i] = std::imag (c);
                     }
 
                   status = UMFPACK_DNAME (solve) (UMFPACK_A, Ap,
-                                             Ai, Ax, Xx, Bx, Numeric, control,
-                                             info);
+                                                  Ai, Ax, Xx, Bx, Numeric,
+                                                  control, info);
                   int status2 = UMFPACK_DNAME (solve) (UMFPACK_A,
-                                                  Ap, Ai, Ax, Xz, Bz, Numeric,
-                                                  control, info) ;
+                                                       Ap, Ai, Ax, Xz, Bz,
+                                                       Numeric, control, info);
 
                   if (status < 0 || status2 < 0)
                     {
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
 
                       UMFPACK_DNAME (report_status) (control, status);
 
@@ -6820,18 +6826,18 @@ Matrix
 SparseMatrix::solve (MatrixType &mattype, const Matrix& b,
                      octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 Matrix
-SparseMatrix::solve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
-                     double& rcond) const
+SparseMatrix::solve (MatrixType &mattype, const Matrix& b,
+                     octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 Matrix
 SparseMatrix::solve (MatrixType &mattype, const Matrix& b, octave_idx_type& err,
                      double& rcond, solve_singularity_handler sing_handler,
                      bool singular_fallback) const
@@ -6931,35 +6937,35 @@ SparseMatrix::solve (MatrixType &mattype
     }
 
   if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
-      retval = dmsolve<SparseMatrix, SparseMatrix,
-        SparseMatrix> (*this, b, err);
+      retval = dmsolve<SparseMatrix, SparseMatrix, SparseMatrix>
+               (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 ComplexMatrix
 SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b,
-                            octave_idx_type& info) const
+                     octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexMatrix
 SparseMatrix::solve (MatrixType &mattype, const ComplexMatrix& b,
                      octave_idx_type& info, double& rcond) const
@@ -6999,18 +7005,18 @@ SparseMatrix::solve (MatrixType &mattype
     }
 
   if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
-      retval = dmsolve<ComplexMatrix, SparseMatrix,
-        ComplexMatrix> (*this, b, err);
+      retval = dmsolve<ComplexMatrix, SparseMatrix, ComplexMatrix>
+               (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (MatrixType &mattype, const SparseComplexMatrix& b) const
@@ -7067,80 +7073,88 @@ SparseMatrix::solve (MatrixType &mattype
     }
 
   if (singular_fallback && mattype.type (false) == MatrixType::Rectangular)
     {
       rcond = 1.;
 #ifdef USE_QRSOLVE
       retval = qrsolve (*this, b, err);
 #else
-      retval = dmsolve<SparseComplexMatrix, SparseMatrix,
-        SparseComplexMatrix> (*this, b, err);
+      retval = dmsolve<SparseComplexMatrix, SparseMatrix, SparseComplexMatrix>
+               (*this, b, err);
 #endif
     }
 
   return retval;
 }
 
 ColumnVector
 SparseMatrix::solve (MatrixType &mattype, const ColumnVector& b) const
 {
   octave_idx_type info; double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ColumnVector
-SparseMatrix::solve (MatrixType &mattype, const ColumnVector& b, octave_idx_type& info) const
+SparseMatrix::solve (MatrixType &mattype, const ColumnVector& b,
+                     octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond);
 }
 
 ColumnVector
-SparseMatrix::solve (MatrixType &mattype, const ColumnVector& b, octave_idx_type& info, double& rcond) const
+SparseMatrix::solve (MatrixType &mattype, const ColumnVector& b,
+                     octave_idx_type& info, double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ColumnVector
-SparseMatrix::solve (MatrixType &mattype, const ColumnVector& b, octave_idx_type& info, double& rcond,
-               solve_singularity_handler sing_handler) const
+SparseMatrix::solve (MatrixType &mattype, const ColumnVector& b,
+                     octave_idx_type& info, double& rcond,
+                     solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
-  return solve (mattype, tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
+  return solve (mattype, tmp, info, rcond,
+                sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b, octave_idx_type& info) const
+SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b,
+                     octave_idx_type& info) const
 {
   double rcond;
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b, octave_idx_type& info,
+SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b,
+                     octave_idx_type& info,
                      double& rcond) const
 {
   return solve (mattype, b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b, octave_idx_type& info, double& rcond,
-               solve_singularity_handler sing_handler) const
+SparseMatrix::solve (MatrixType &mattype, const ComplexColumnVector& b,
+                     octave_idx_type& info, double& rcond,
+                     solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
-  return solve (mattype, tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
+  return solve (mattype, tmp, info, rcond,
+                sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 Matrix
 SparseMatrix::solve (const Matrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
@@ -7156,18 +7170,17 @@ SparseMatrix::solve (const Matrix& b, oc
 Matrix
 SparseMatrix::solve (const Matrix& b, octave_idx_type& info,
                      double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 Matrix
-SparseMatrix::solve (const Matrix& b, octave_idx_type& err,
-                     double& rcond,
+SparseMatrix::solve (const Matrix& b, octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseMatrix
 SparseMatrix::solve (const SparseMatrix& b) const
@@ -7188,67 +7201,64 @@ SparseMatrix::solve (const SparseMatrix&
 SparseMatrix
 SparseMatrix::solve (const SparseMatrix& b,
                      octave_idx_type& info, double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 SparseMatrix
-SparseMatrix::solve (const SparseMatrix& b,
-                     octave_idx_type& err, double& rcond,
+SparseMatrix::solve (const SparseMatrix& b, octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 ComplexMatrix
-SparseMatrix::solve (const ComplexMatrix& b,
-                            octave_idx_type& info) const
+SparseMatrix::solve (const ComplexMatrix& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseMatrix::solve (const ComplexMatrix& b,
-                     octave_idx_type& info, double& rcond) const
+SparseMatrix::solve (const ComplexMatrix& b, octave_idx_type& info,
+                     double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexMatrix
-SparseMatrix::solve (const ComplexMatrix& b,
-                     octave_idx_type& err, double& rcond,
+SparseMatrix::solve (const ComplexMatrix& b, octave_idx_type& err,
+                     double& rcond,
                      solve_singularity_handler sing_handler) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, err, rcond, sing_handler);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (const SparseComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseMatrix::solve (const SparseComplexMatrix& b,
-                     octave_idx_type& info) const
+SparseMatrix::solve (const SparseComplexMatrix& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
-SparseMatrix::solve (const SparseComplexMatrix& b,
-                     octave_idx_type& info, double& rcond) const
+SparseMatrix::solve (const SparseComplexMatrix& b, octave_idx_type& info,
+                     double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 SparseComplexMatrix
 SparseMatrix::solve (const SparseComplexMatrix& b,
                      octave_idx_type& err, double& rcond,
                      solve_singularity_handler sing_handler) const
@@ -7267,27 +7277,30 @@ SparseMatrix::solve (const ColumnVector&
 ColumnVector
 SparseMatrix::solve (const ColumnVector& b, octave_idx_type& info) const
 {
   double rcond;
   return solve (b, info, rcond);
 }
 
 ColumnVector
-SparseMatrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcond) const
+SparseMatrix::solve (const ColumnVector& b, octave_idx_type& info,
+                     double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ColumnVector
-SparseMatrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
-               solve_singularity_handler sing_handler) const
+SparseMatrix::solve (const ColumnVector& b, octave_idx_type& info,
+                     double& rcond,
+                     solve_singularity_handler sing_handler) const
 {
   Matrix tmp (b);
-  return solve (tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
+  return solve (tmp, info, rcond,
+                sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 SparseMatrix::solve (const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcond;
   return solve (b, info, rcond, 0);
@@ -7303,18 +7316,19 @@ SparseMatrix::solve (const ComplexColumn
 ComplexColumnVector
 SparseMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
                      double& rcond) const
 {
   return solve (b, info, rcond, 0);
 }
 
 ComplexColumnVector
-SparseMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info, double& rcond,
-               solve_singularity_handler sing_handler) const
+SparseMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
+                     double& rcond,
+                     solve_singularity_handler sing_handler) const
 {
   ComplexMatrix tmp (b);
   return solve (tmp, info, rcond, sing_handler).column (static_cast<octave_idx_type> (0));
 }
 
 // other operations.
 
 bool
@@ -7478,18 +7492,17 @@ SparseMatrix::operator ! (void) const
             }
         }
       r.cidx (i+1) = ii;
     }
 
   return r;
 }
 
-// FIXME Do these really belong here?  Maybe they should be
-// in a base class?
+// FIXME: Do these really belong here?  Maybe they should be in a base class?
 
 SparseBoolMatrix
 SparseMatrix::all (int dim) const
 {
   SPARSE_ALL_OP (dim);
 }
 
 SparseBoolMatrix
@@ -7571,28 +7584,28 @@ SparseMatrix::matrix_value (void) const
   return Sparse<double>::array_value ();
 }
 
 std::ostream&
 operator << (std::ostream& os, const SparseMatrix& a)
 {
   octave_idx_type nc = a.cols ();
 
-   // add one to the printed indices to go from
-   //  zero-based to one-based arrays
-   for (octave_idx_type j = 0; j < nc; j++)
-     {
-       octave_quit ();
-       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
-         {
-           os << a.ridx (i) + 1 << " "  << j + 1 << " ";
-           octave_write_double (os, a.data (i));
-           os << "\n";
-         }
-     }
+  // add one to the printed indices to go from
+  //  zero-based to one-based arrays
+  for (octave_idx_type j = 0; j < nc; j++)
+    {
+      octave_quit ();
+      for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
+        {
+          os << a.ridx (i) + 1 << " "  << j + 1 << " ";
+          octave_write_double (os, a.data (i));
+          os << "\n";
+        }
+    }
 
   return os;
 }
 
 std::istream&
 operator >> (std::istream& is, SparseMatrix& a)
 {
   typedef SparseMatrix::element_type elt_type;
@@ -7703,18 +7716,17 @@ operator * (const PermMatrix& p, const S
 }
 
 SparseMatrix
 operator * (const SparseMatrix& a, const PermMatrix& p)
 {
   return octinternal_do_mul_sm_pm (a, p);
 }
 
-// FIXME -- it would be nice to share code among the min/max
-// functions below.
+// FIXME: it would be nice to share code among the min/max functions below.
 
 #define EMPTY_RETURN_CHECK(T) \
   if (nr == 0 || nc == 0) \
     return T (nr, nc);
 
 SparseMatrix
 min (double d, const SparseMatrix& m)
 {
diff --git a/liboctave/array/dSparse.h b/liboctave/array/dSparse.h
--- a/liboctave/array/dSparse.h
+++ b/liboctave/array/dSparse.h
@@ -40,23 +40,24 @@ class PermMatrix;
 class DiagMatrix;
 class SparseComplexMatrix;
 class SparseBoolMatrix;
 
 class
 OCTAVE_API
 SparseMatrix : public MSparse<double>
 {
- public:
+public:
 
   typedef void (*solve_singularity_handler) (double rcond);
 
   SparseMatrix (void) : MSparse<double> () { }
 
-  SparseMatrix (octave_idx_type r, octave_idx_type c) : MSparse<double> (r, c) { }
+  SparseMatrix (octave_idx_type r, octave_idx_type c)
+    : MSparse<double> (r, c) { }
 
   SparseMatrix (const dim_vector& dv, octave_idx_type nz = 0) :
     MSparse<double> (dv, nz) { }
 
   explicit SparseMatrix (octave_idx_type r, octave_idx_type c, double val)
     : MSparse<double> (r, c, val) { }
 
   SparseMatrix (const SparseMatrix& a) : MSparse<double> (a) { }
@@ -79,55 +80,60 @@ SparseMatrix : public MSparse<double>
                 octave_idx_type nc = -1, bool sum_terms = true,
                 octave_idx_type nzm = -1)
     : MSparse<double> (a, r, c, nr, nc, sum_terms, nzm) { }
 
   explicit SparseMatrix (const DiagMatrix& a);
 
   explicit SparseMatrix (const PermMatrix& a) : MSparse<double>(a) { }
 
-  SparseMatrix (octave_idx_type r, octave_idx_type c, octave_idx_type num_nz) : MSparse<double> (r, c, num_nz) { }
+  SparseMatrix (octave_idx_type r, octave_idx_type c,
+                octave_idx_type num_nz) : MSparse<double> (r, c, num_nz) { }
 
   SparseMatrix& operator = (const SparseMatrix& a)
-    {
-      MSparse<double>::operator = (a);
-      return *this;
-    }
+  {
+    MSparse<double>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const SparseMatrix& a) const;
   bool operator != (const SparseMatrix& a) const;
 
   bool is_symmetric (void) const;
 
   SparseMatrix max (int dim = -1) const;
   SparseMatrix max (Array<octave_idx_type>& index, int dim = -1) const;
   SparseMatrix min (int dim = -1) const;
   SparseMatrix min (Array<octave_idx_type>& index, int dim = -1) const;
 
   // destructive insert/delete/reorder operations
 
-  SparseMatrix& insert (const SparseMatrix& a, octave_idx_type r, octave_idx_type c);
+  SparseMatrix& insert (const SparseMatrix& a, octave_idx_type r,
+                        octave_idx_type c);
 
-  SparseMatrix& insert (const SparseMatrix& a, const Array<octave_idx_type>& indx);
+  SparseMatrix& insert (const SparseMatrix& a,
+                        const Array<octave_idx_type>& indx);
 
-  SparseMatrix concat (const SparseMatrix& rb, const Array<octave_idx_type>& ra_idx);
+  SparseMatrix concat (const SparseMatrix& rb,
+                       const Array<octave_idx_type>& ra_idx);
   SparseComplexMatrix concat (const SparseComplexMatrix& rb,
                               const Array<octave_idx_type>& ra_idx);
 
   friend OCTAVE_API SparseMatrix real (const SparseComplexMatrix& a);
   friend OCTAVE_API SparseMatrix imag (const SparseComplexMatrix& a);
 
   friend OCTAVE_API SparseMatrix atan2 (const double& x, const SparseMatrix& y);
   friend OCTAVE_API SparseMatrix atan2 (const SparseMatrix& x, const double& y);
-  friend OCTAVE_API SparseMatrix atan2 (const SparseMatrix& x, const SparseMatrix& y);
+  friend OCTAVE_API SparseMatrix atan2 (const SparseMatrix& x,
+                                        const SparseMatrix& y);
 
   SparseMatrix transpose (void) const
-    {
-      return MSparse<double>::transpose ();
-    }
+  {
+    return MSparse<double>::transpose ();
+  }
   SparseMatrix hermitian (void) const { return transpose (); }
 
   // extract row or column i.
 
   RowVector row (octave_idx_type i) const;
 
   ColumnVector column (octave_idx_type i) const;
 
@@ -144,142 +150,143 @@ public:
   SparseMatrix inverse (void) const;
   SparseMatrix inverse (MatrixType& mattype) const;
   SparseMatrix inverse (MatrixType& mattype, octave_idx_type& info) const;
   SparseMatrix inverse (MatrixType& mattype, octave_idx_type& info,
                         double& rcond, int force = 0, int calc_cond = 1) const;
 
   DET determinant (void) const;
   DET determinant (octave_idx_type& info) const;
-  DET determinant (octave_idx_type& info, double& rcond, int calc_cond = 1) const;
+  DET determinant (octave_idx_type& info, double& rcond,
+                   int calc_cond = 1) const;
 
 private:
   // Diagonal matrix solvers
   Matrix dsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-                double& rcond, solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                 double& rcond, solve_singularity_handler sing_handler,
+                 bool calc_cond = false) const;
 
   ComplexMatrix dsolve (MatrixType &typ, const ComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                        octave_idx_type& info, double& rcond,
+                        solve_singularity_handler sing_handler,
+                        bool calc_cond = false) const;
 
   SparseMatrix dsolve (MatrixType &typ, const SparseMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                       octave_idx_type& info, double& rcond,
+                       solve_singularity_handler sing_handler,
+                       bool calc_cond = false) const;
 
   SparseComplexMatrix dsolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                              octave_idx_type& info, double& rcond,
+                              solve_singularity_handler sing_handler,
+                              bool calc_cond = false) const;
 
   // Upper triangular matrix solvers
   Matrix utsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-                double& rcond, solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                  double& rcond, solve_singularity_handler sing_handler,
+                  bool calc_cond = false) const;
 
   ComplexMatrix utsolve (MatrixType &typ, const ComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                         octave_idx_type& info, double& rcond,
+                         solve_singularity_handler sing_handler,
+                         bool calc_cond = false) const;
 
   SparseMatrix utsolve (MatrixType &typ, const SparseMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                        octave_idx_type& info, double& rcond,
+                        solve_singularity_handler sing_handler,
+                        bool calc_cond = false) const;
 
   SparseComplexMatrix utsolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                               octave_idx_type& info, double& rcond,
+                               solve_singularity_handler sing_handler,
+                               bool calc_cond = false) const;
 
   // Lower triangular matrix solvers
   Matrix ltsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-                double& rcond, solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                  double& rcond, solve_singularity_handler sing_handler,
+                  bool calc_cond = false) const;
 
   ComplexMatrix ltsolve (MatrixType &typ, const ComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                         octave_idx_type& info, double& rcond,
+                         solve_singularity_handler sing_handler,
+                         bool calc_cond = false) const;
 
   SparseMatrix ltsolve (MatrixType &typ, const SparseMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                        octave_idx_type& info, double& rcond,
+                        solve_singularity_handler sing_handler,
+                        bool calc_cond = false) const;
 
   SparseComplexMatrix ltsolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                               octave_idx_type& info, double& rcond,
+                               solve_singularity_handler sing_handler,
+                               bool calc_cond = false) const;
 
   // Tridiagonal matrix solvers
   Matrix trisolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-                double& rcond, solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                   double& rcond, solve_singularity_handler sing_handler,
+                   bool calc_cond = false) const;
 
   ComplexMatrix trisolve (MatrixType &typ, const ComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                          octave_idx_type& info, double& rcond,
+                          solve_singularity_handler sing_handler,
+                          bool calc_cond = false) const;
 
   SparseMatrix trisolve (MatrixType &typ, const SparseMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                         octave_idx_type& info, double& rcond,
+                         solve_singularity_handler sing_handler,
+                         bool calc_cond = false) const;
 
   SparseComplexMatrix trisolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                                octave_idx_type& info, double& rcond,
+                                solve_singularity_handler sing_handler,
+                                bool calc_cond = false) const;
 
   // Banded matrix solvers (umfpack/cholesky)
   Matrix bsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-                double& rcond, solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                 double& rcond, solve_singularity_handler sing_handler,
+                 bool calc_cond = false) const;
 
   ComplexMatrix bsolve (MatrixType &typ, const ComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                        octave_idx_type& info, double& rcond,
+                        solve_singularity_handler sing_handler,
+                        bool calc_cond = false) const;
 
   SparseMatrix bsolve (MatrixType &typ, const SparseMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                       octave_idx_type& info, double& rcond,
+                       solve_singularity_handler sing_handler,
+                       bool calc_cond = false) const;
 
   SparseComplexMatrix bsolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                              octave_idx_type& info, double& rcond,
+                              solve_singularity_handler sing_handler,
+                              bool calc_cond = false) const;
 
   // Full matrix solvers (umfpack/cholesky)
   void * factorize (octave_idx_type& err, double &rcond, Matrix &Control,
                     Matrix &Info, solve_singularity_handler sing_handler,
                     bool calc_cond = false) const;
 
   Matrix fsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
-                double& rcond, solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                 double& rcond, solve_singularity_handler sing_handler,
+                 bool calc_cond = false) const;
 
   ComplexMatrix fsolve (MatrixType &typ, const ComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                        octave_idx_type& info, double& rcond,
+                        solve_singularity_handler sing_handler,
+                        bool calc_cond = false) const;
 
   SparseMatrix fsolve (MatrixType &typ, const SparseMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                       octave_idx_type& info, double& rcond,
+                       solve_singularity_handler sing_handler,
+                       bool calc_cond = false) const;
 
   SparseComplexMatrix fsolve (MatrixType &typ, const SparseComplexMatrix& b,
-                octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler,
-                bool calc_cond = false) const;
+                              octave_idx_type& info, double& rcond,
+                              solve_singularity_handler sing_handler,
+                              bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   Matrix solve (MatrixType &typ, const Matrix& b) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
                 double& rcond) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
@@ -342,46 +349,52 @@ public:
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcond) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcond,
                 solve_singularity_handler sing_handler) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info,
                        double& rcond) const;
-  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcond,
+  ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info,
+                       double& rcond,
                        solve_singularity_handler sing_handler) const;
 
   SparseMatrix solve (const SparseMatrix& b) const;
   SparseMatrix solve (const SparseMatrix& b, octave_idx_type& info) const;
   SparseMatrix solve (const SparseMatrix& b, octave_idx_type& info,
                       double& rcond) const;
-  SparseMatrix solve (const SparseMatrix& b, octave_idx_type& info, double& rcond,
-                solve_singularity_handler sing_handler) const;
+  SparseMatrix solve (const SparseMatrix& b, octave_idx_type& info,
+                      double& rcond,
+                      solve_singularity_handler sing_handler) const;
 
   SparseComplexMatrix solve (const SparseComplexMatrix& b) const;
-  SparseComplexMatrix solve (const SparseComplexMatrix& b, octave_idx_type& info) const;
-  SparseComplexMatrix solve (const SparseComplexMatrix& b, octave_idx_type& info,
-                             double& rcond) const;
-  SparseComplexMatrix solve (const SparseComplexMatrix& b, octave_idx_type& info,
-                             double& rcond,
+  SparseComplexMatrix solve (const SparseComplexMatrix& b,
+                             octave_idx_type& info) const;
+  SparseComplexMatrix solve (const SparseComplexMatrix& b,
+                             octave_idx_type& info, double& rcond) const;
+  SparseComplexMatrix solve (const SparseComplexMatrix& b,
+                             octave_idx_type& info, double& rcond,
                              solve_singularity_handler sing_handler) const;
 
   ColumnVector solve (const ColumnVector& b) const;
   ColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
-  ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcond) const;
-  ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcond,
+  ColumnVector solve (const ColumnVector& b, octave_idx_type& info,
+                      double& rcond) const;
+  ColumnVector solve (const ColumnVector& b, octave_idx_type& info,
+                      double& rcond,
                       solve_singularity_handler sing_handler) const;
 
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-                             double& rcond) const;
-  ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-                             double& rcond,
+  ComplexColumnVector solve (const ComplexColumnVector& b,
+                             octave_idx_type& info) const;
+  ComplexColumnVector solve (const ComplexColumnVector& b,
+                             octave_idx_type& info, double& rcond) const;
+  ComplexColumnVector solve (const ComplexColumnVector& b,
+                             octave_idx_type& info, double& rcond,
                              solve_singularity_handler sing_handler) const;
 
   // other operations
 
   bool any_element_is_negative (bool = false) const;
   bool any_element_is_nan (void) const;
   bool any_element_is_inf_or_nan (void) const;
   bool any_element_not_one_or_zero (void) const;
@@ -405,63 +418,76 @@ public:
   SparseMatrix diag (octave_idx_type k = 0) const;
 
   Matrix matrix_value (void) const;
 
   SparseMatrix squeeze (void) const;
 
   SparseMatrix reshape (const dim_vector& new_dims) const;
 
-  SparseMatrix permute (const Array<octave_idx_type>& vec, bool inv = false) const;
+  SparseMatrix permute (const Array<octave_idx_type>& vec,
+                        bool inv = false) const;
 
   SparseMatrix ipermute (const Array<octave_idx_type>& vec) const;
 
   // i/o
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const SparseMatrix& a);
-  friend OCTAVE_API std::istream& operator >> (std::istream& is, SparseMatrix& a);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const SparseMatrix& a);
+  friend OCTAVE_API std::istream& operator >> (std::istream& is,
+                                               SparseMatrix& a);
 
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API SparseMatrix real (const SparseComplexMatrix& a);
 extern OCTAVE_API SparseMatrix imag (const SparseComplexMatrix& a);
 
 // Other operators.
 
 extern OCTAVE_API SparseMatrix operator * (const SparseMatrix& a,
-                                const SparseMatrix& b);
+                                           const SparseMatrix& b);
 extern OCTAVE_API Matrix operator * (const Matrix& a,
-                                const SparseMatrix& b);
+                                     const SparseMatrix& b);
 extern OCTAVE_API Matrix mul_trans (const Matrix& a,
-                                const SparseMatrix& b);
+                                    const SparseMatrix& b);
 extern OCTAVE_API Matrix operator * (const SparseMatrix& a,
-                                const Matrix& b);
+                                     const Matrix& b);
 extern OCTAVE_API Matrix trans_mul (const SparseMatrix& a,
-                                const Matrix& b);
+                                    const Matrix& b);
 
-extern OCTAVE_API SparseMatrix operator * (const DiagMatrix&, const SparseMatrix&);
-extern OCTAVE_API SparseMatrix operator * (const SparseMatrix&, const DiagMatrix&);
+extern OCTAVE_API SparseMatrix operator * (const DiagMatrix&,
+                                           const SparseMatrix&);
+extern OCTAVE_API SparseMatrix operator * (const SparseMatrix&,
+                                           const DiagMatrix&);
 
-extern OCTAVE_API SparseMatrix operator + (const DiagMatrix&, const SparseMatrix&);
-extern OCTAVE_API SparseMatrix operator + (const SparseMatrix&, const DiagMatrix&);
-extern OCTAVE_API SparseMatrix operator - (const DiagMatrix&, const SparseMatrix&);
-extern OCTAVE_API SparseMatrix operator - (const SparseMatrix&, const DiagMatrix&);
+extern OCTAVE_API SparseMatrix operator + (const DiagMatrix&,
+                                           const SparseMatrix&);
+extern OCTAVE_API SparseMatrix operator + (const SparseMatrix&,
+                                           const DiagMatrix&);
+extern OCTAVE_API SparseMatrix operator - (const DiagMatrix&,
+                                           const SparseMatrix&);
+extern OCTAVE_API SparseMatrix operator - (const SparseMatrix&,
+                                           const DiagMatrix&);
 
-extern OCTAVE_API SparseMatrix operator * (const PermMatrix&, const SparseMatrix&);
-extern OCTAVE_API SparseMatrix operator * (const SparseMatrix&, const PermMatrix&);
+extern OCTAVE_API SparseMatrix operator * (const PermMatrix&,
+                                           const SparseMatrix&);
+extern OCTAVE_API SparseMatrix operator * (const SparseMatrix&,
+                                           const PermMatrix&);
 
 extern OCTAVE_API SparseMatrix min (double d, const SparseMatrix& m);
 extern OCTAVE_API SparseMatrix min (const SparseMatrix& m, double d);
-extern OCTAVE_API SparseMatrix min (const SparseMatrix& a, const SparseMatrix& b);
+extern OCTAVE_API SparseMatrix min (const SparseMatrix& a,
+                                    const SparseMatrix& b);
 
 extern OCTAVE_API SparseMatrix max (double d, const SparseMatrix& m);
 extern OCTAVE_API SparseMatrix max (const SparseMatrix& m, double d);
-extern OCTAVE_API SparseMatrix max (const SparseMatrix& a, const SparseMatrix& b);
+extern OCTAVE_API SparseMatrix max (const SparseMatrix& a,
+                                    const SparseMatrix& b);
 
 SPARSE_SMS_CMP_OP_DECLS (SparseMatrix, double, OCTAVE_API)
 SPARSE_SMS_BOOL_OP_DECLS (SparseMatrix, double, OCTAVE_API)
 
 SPARSE_SSM_CMP_OP_DECLS (double, SparseMatrix, OCTAVE_API)
 SPARSE_SSM_BOOL_OP_DECLS (double, SparseMatrix, OCTAVE_API)
 
 SPARSE_SMSM_CMP_OP_DECLS (SparseMatrix, SparseMatrix, OCTAVE_API)
diff --git a/liboctave/array/dim-vector.cc b/liboctave/array/dim-vector.cc
--- a/liboctave/array/dim-vector.cc
+++ b/liboctave/array/dim-vector.cc
@@ -24,20 +24,20 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream>
 
 #include "dim-vector.h"
 
-// The maximum allowed value for a dimension extent. This will normally be a tiny bit
-// off the maximum value of octave_idx_type.
-// Currently 1 is subtracted to allow safe conversion of any 2D Array into Sparse,
-// but this offset may change in the future.
+// The maximum allowed value for a dimension extent. This will normally be a
+// tiny bit off the maximum value of octave_idx_type.
+// Currently 1 is subtracted to allow safe conversion of any 2D Array into
+// Sparse, but this offset may change in the future.
 octave_idx_type
 dim_vector::dim_max (void)
 {
   return std::numeric_limits<octave_idx_type>::max () - 1;
 }
 
 void
 dim_vector::chop_all_singletons (void)
diff --git a/liboctave/array/dim-vector.h b/liboctave/array/dim-vector.h
--- a/liboctave/array/dim-vector.h
+++ b/liboctave/array/dim-vector.h
@@ -216,34 +216,33 @@ public:
   octave_idx_type *to_jit (void) const
   {
     return rep;
   }
 
 private:
 
   static octave_idx_type *nil_rep (void)
-    {
-      static dim_vector zv (0, 0);
-      return zv.rep;
-    }
+  {
+    static dim_vector zv (0, 0);
+    return zv.rep;
+  }
 
 public:
 
   static octave_idx_type dim_max (void);
 
   explicit dim_vector (void) : rep (nil_rep ())
   { OCTREFCOUNT_ATOMIC_INCREMENT (&(count())); }
 
   dim_vector (const dim_vector& dv) : rep (dv.rep)
   { OCTREFCOUNT_ATOMIC_INCREMENT (&(count())); }
 
   // FIXME: Should be private, but required by array constructor for jit
-  explicit dim_vector (octave_idx_type *r)
-    : rep (r) { }
+  explicit dim_vector (octave_idx_type *r) : rep (r) { }
 
   static dim_vector alloc (int n)
   {
     return dim_vector (newrep (n < 2 ? 2 : n));
   }
 
   dim_vector& operator = (const dim_vector& dv)
   {
@@ -388,112 +387,112 @@ public:
   // Force certain dimensionality, preserving numel ().  Missing
   // dimensions are set to 1, redundant are folded into the trailing
   // one.  If n = 1, the result is 2d and the second dim is 1
   // (dim_vectors are always at least 2D).
 
   dim_vector redim (int n) const;
 
   dim_vector as_column (void) const
-    {
-      if (length () == 2 && elem (1) == 1)
-        return *this;
-      else
-        return dim_vector (numel (), 1);
-    }
+  {
+    if (length () == 2 && elem (1) == 1)
+      return *this;
+    else
+      return dim_vector (numel (), 1);
+  }
 
   dim_vector as_row (void) const
-    {
-      if (length () == 2 && elem (0) == 1)
-        return *this;
-      else
-        return dim_vector (1, numel ());
-    }
+  {
+    if (length () == 2 && elem (0) == 1)
+      return *this;
+    else
+      return dim_vector (1, numel ());
+  }
 
   bool is_vector (void) const
-    {
-      return (length () == 2 && (elem (0) == 1 || elem (1) == 1));
-    }
+  {
+    return (length () == 2 && (elem (0) == 1 || elem (1) == 1));
+  }
 
   int first_non_singleton (int def = 0) const
-    {
-      for (int i = 0; i < length (); i++)
-        {
-          if (elem (i) != 1)
-            return i;
-        }
+  {
+    for (int i = 0; i < length (); i++)
+      {
+        if (elem (i) != 1)
+          return i;
+      }
 
-      return def;
-    }
+    return def;
+  }
 
   // Compute a linear index from an index tuple.
 
   octave_idx_type compute_index (const octave_idx_type *idx) const
-    {
-      octave_idx_type k = 0;
-      for (int i = length () - 1; i >= 0; i--)
-        k = k * rep[i] + idx[i];
+  {
+    octave_idx_type k = 0;
+    for (int i = length () - 1; i >= 0; i--)
+      k = k * rep[i] + idx[i];
 
-      return k;
-    }
+    return k;
+  }
 
   // Ditto, but the tuple may be incomplete (nidx < length ()).
 
   octave_idx_type compute_index (const octave_idx_type *idx, int nidx) const
-    {
-      octave_idx_type k = 0;
-      for (int i = nidx - 1; i >= 0; i--)
-        k = k * rep[i] + idx[i];
+  {
+    octave_idx_type k = 0;
+    for (int i = nidx - 1; i >= 0; i--)
+      k = k * rep[i] + idx[i];
 
-      return k;
-    }
+    return k;
+  }
 
   // Increment a multi-dimensional index tuple, optionally starting
   // from an offset position and return the index of the last index
   // position that was changed, or length () if just cycled over.
 
   int increment_index (octave_idx_type *idx, int start = 0) const
-    {
-      int i;
-      for (i = start; i < length (); i++)
-        {
-          if (++(*idx) == rep[i])
-            *idx++ = 0;
-          else
-            break;
-        }
-      return i;
-    }
+  {
+    int i;
+    for (i = start; i < length (); i++)
+      {
+        if (++(*idx) == rep[i])
+          *idx++ = 0;
+        else
+          break;
+      }
+    return i;
+  }
 
   // Return cumulative dimensions.
 
   dim_vector cumulative (void) const
-    {
-      int nd = length ();
-      dim_vector retval = alloc (nd);
+  {
+    int nd = length ();
+    dim_vector retval = alloc (nd);
 
-      octave_idx_type k = 1;
-      for (int i = 0; i < nd; i++)
-        retval.rep[i] = k *= rep[i];
+    octave_idx_type k = 1;
+    for (int i = 0; i < nd; i++)
+      retval.rep[i] = k *= rep[i];
 
-      return retval;
-    }
+    return retval;
+  }
 
   // Compute a linear index from an index tuple.  Dimensions are
   // required to be cumulative.
 
   octave_idx_type cum_compute_index (const octave_idx_type *idx) const
-    {
-      octave_idx_type k = idx[0];
+  {
+    octave_idx_type k = idx[0];
 
-      for (int i = 1; i < length (); i++)
-        k += rep[i-1] * idx[i];
+    for (int i = 1; i < length (); i++)
+      k += rep[i-1] * idx[i];
 
-      return k;
-    }
+    return k;
+  }
 
 
   friend bool operator == (const dim_vector& a, const dim_vector& b);
 };
 
 inline bool
 operator == (const dim_vector& a, const dim_vector& b)
 {
diff --git a/liboctave/array/fCColVector.cc b/liboctave/array/fCColVector.cc
--- a/liboctave/array/fCColVector.cc
+++ b/liboctave/array/fCColVector.cc
@@ -48,17 +48,17 @@ extern "C"
                            const octave_idx_type&, const FloatComplex&,
                            FloatComplex*, const octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL);
 }
 
 // FloatComplex Column Vector class
 
 FloatComplexColumnVector::FloatComplexColumnVector (const FloatColumnVector& a)
-   : MArray<FloatComplex> (a)
+  : MArray<FloatComplex> (a)
 {
 }
 
 bool
 FloatComplexColumnVector::operator == (const FloatComplexColumnVector& a) const
 {
   octave_idx_type len = length ();
   if (len != a.length ())
@@ -92,17 +92,18 @@ FloatComplexColumnVector::insert (const 
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i) = a.elem (i);
     }
 
   return *this;
 }
 
 FloatComplexColumnVector&
-FloatComplexColumnVector::insert (const FloatComplexColumnVector& a, octave_idx_type r)
+FloatComplexColumnVector::insert (const FloatComplexColumnVector& a,
+                                  octave_idx_type r)
 {
   octave_idx_type a_len = a.length ();
 
   if (r < 0 || r + a_len > length ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
@@ -147,17 +148,18 @@ FloatComplexColumnVector::fill (const Fl
         xelem (i) = val;
     }
 
 
   return *this;
 }
 
 FloatComplexColumnVector&
-FloatComplexColumnVector::fill (float val, octave_idx_type r1, octave_idx_type r2)
+FloatComplexColumnVector::fill (float val,
+                                octave_idx_type r1, octave_idx_type r2)
 {
   octave_idx_type len = length ();
 
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
@@ -171,17 +173,18 @@ FloatComplexColumnVector::fill (float va
       for (octave_idx_type i = r1; i <= r2; i++)
         xelem (i) = val;
     }
 
   return *this;
 }
 
 FloatComplexColumnVector&
-FloatComplexColumnVector::fill (const FloatComplex& val, octave_idx_type r1, octave_idx_type r2)
+FloatComplexColumnVector::fill (const FloatComplex& val,
+                                octave_idx_type r1, octave_idx_type r2)
 {
   octave_idx_type len = length ();
 
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
@@ -258,17 +261,18 @@ FloatComplexColumnVector::extract (octav
 
   for (octave_idx_type i = 0; i < new_r; i++)
     result.elem (i) = elem (r1+i);
 
   return result;
 }
 
 FloatComplexColumnVector
-FloatComplexColumnVector::extract_n (octave_idx_type r1, octave_idx_type n) const
+FloatComplexColumnVector::extract_n (octave_idx_type r1,
+                                     octave_idx_type n) const
 {
   FloatComplexColumnVector result (n);
 
   for (octave_idx_type i = 0; i < n; i++)
     result.elem (i) = elem (r1+i);
 
   return result;
 }
@@ -286,17 +290,17 @@ FloatComplexColumnVector::operator += (c
     {
       gripe_nonconformant ("operator +=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
-  FloatComplex *d = fortran_vec (); // Ensures only one reference to my privates!
+  FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_add2 (len, d, a.data ());
   return *this;
 }
 
 FloatComplexColumnVector&
 FloatComplexColumnVector::operator -= (const FloatColumnVector& a)
 {
@@ -308,17 +312,17 @@ FloatComplexColumnVector::operator -= (c
     {
       gripe_nonconformant ("operator -=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
-  FloatComplex *d = fortran_vec (); // Ensures only one reference to my privates!
+  FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_sub2 (len, d, a.data ());
   return *this;
 }
 
 // matrix by column vector -> column vector operations
 
 FloatComplexColumnVector
diff --git a/liboctave/array/fCColVector.h b/liboctave/array/fCColVector.h
--- a/liboctave/array/fCColVector.h
+++ b/liboctave/array/fCColVector.h
@@ -27,23 +27,23 @@ along with Octave; see the file COPYING.
 #include "MArray.h"
 
 #include "mx-defs.h"
 
 class
 OCTAVE_API
 FloatComplexColumnVector : public MArray<FloatComplex>
 {
-friend class FloatComplexMatrix;
-friend class FloatComplexRowVector;
+  friend class FloatComplexMatrix;
+  friend class FloatComplexRowVector;
 
 public:
 
- FloatComplexColumnVector (void)
-   : MArray<FloatComplex> (dim_vector (0, 1)) { }
+  FloatComplexColumnVector (void)
+    : MArray<FloatComplex> (dim_vector (0, 1)) { }
 
   explicit FloatComplexColumnVector (octave_idx_type n)
     : MArray<FloatComplex> (dim_vector (n, 1)) { }
 
   explicit FloatComplexColumnVector (const dim_vector& dv)
     : MArray<FloatComplex> (dv.as_column ()) { }
 
   FloatComplexColumnVector (octave_idx_type n, const FloatComplex& val)
@@ -56,94 +56,103 @@ public:
     : MArray<FloatComplex> (a.as_column ()) { }
 
   FloatComplexColumnVector (const Array<FloatComplex>& a)
     : MArray<FloatComplex> (a.as_column ()) { }
 
   explicit FloatComplexColumnVector (const FloatColumnVector& a);
 
   FloatComplexColumnVector& operator = (const FloatComplexColumnVector& a)
-    {
-      MArray<FloatComplex>::operator = (a);
-      return *this;
-    }
+  {
+    MArray<FloatComplex>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const FloatComplexColumnVector& a) const;
   bool operator != (const FloatComplexColumnVector& a) const;
 
   // destructive insert/delete/reorder operations
 
-  FloatComplexColumnVector& insert (const FloatColumnVector& a, octave_idx_type r);
-  FloatComplexColumnVector& insert (const FloatComplexColumnVector& a, octave_idx_type r);
+  FloatComplexColumnVector& insert (const FloatColumnVector& a,
+                                    octave_idx_type r);
+  FloatComplexColumnVector& insert (const FloatComplexColumnVector& a,
+                                    octave_idx_type r);
 
   FloatComplexColumnVector& fill (float val);
   FloatComplexColumnVector& fill (const FloatComplex& val);
-  FloatComplexColumnVector& fill (float val, octave_idx_type r1, octave_idx_type r2);
-  FloatComplexColumnVector& fill (const FloatComplex& val, octave_idx_type r1, octave_idx_type r2);
+  FloatComplexColumnVector& fill (float val,
+                                  octave_idx_type r1, octave_idx_type r2);
+  FloatComplexColumnVector& fill (const FloatComplex& val,
+                                  octave_idx_type r1, octave_idx_type r2);
 
   FloatComplexColumnVector stack (const FloatColumnVector& a) const;
   FloatComplexColumnVector stack (const FloatComplexColumnVector& a) const;
 
   FloatComplexRowVector hermitian (void) const;
   FloatComplexRowVector transpose (void) const;
 
-  friend OCTAVE_API FloatComplexColumnVector conj (const FloatComplexColumnVector& a);
+  friend OCTAVE_API FloatComplexColumnVector
+  conj (const FloatComplexColumnVector& a);
 
   // resize is the destructive equivalent for this one
 
-  FloatComplexColumnVector extract (octave_idx_type r1, octave_idx_type r2) const;
+  FloatComplexColumnVector extract (octave_idx_type r1,
+                                    octave_idx_type r2) const;
 
-  FloatComplexColumnVector extract_n (octave_idx_type r1, octave_idx_type n) const;
+  FloatComplexColumnVector extract_n (octave_idx_type r1,
+                                      octave_idx_type n) const;
 
   // column vector by column vector -> column vector operations
 
   FloatComplexColumnVector& operator += (const FloatColumnVector& a);
   FloatComplexColumnVector& operator -= (const FloatColumnVector& a);
 
   // matrix by column vector -> column vector operations
 
-  friend OCTAVE_API FloatComplexColumnVector operator * (const FloatComplexMatrix& a,
-                                         const FloatColumnVector& b);
+  friend OCTAVE_API FloatComplexColumnVector
+  operator * (const FloatComplexMatrix& a, const FloatColumnVector& b);
 
-  friend OCTAVE_API FloatComplexColumnVector operator * (const FloatComplexMatrix& a,
-                                         const FloatComplexColumnVector& b);
+  friend OCTAVE_API FloatComplexColumnVector
+  operator * (const FloatComplexMatrix& a, const FloatComplexColumnVector& b);
 
   // matrix by column vector -> column vector operations
 
-  friend OCTAVE_API FloatComplexColumnVector operator * (const FloatMatrix& a,
-                                         const FloatComplexColumnVector& b);
+  friend OCTAVE_API FloatComplexColumnVector
+  operator * (const FloatMatrix& a, const FloatComplexColumnVector& b);
 
   // diagonal matrix by column vector -> column vector operations
 
-  friend OCTAVE_API FloatComplexColumnVector operator * (const FloatDiagMatrix& a,
-                                         const FloatComplexColumnVector& b);
+  friend OCTAVE_API FloatComplexColumnVector
+  operator * (const FloatDiagMatrix& a, const FloatComplexColumnVector& b);
 
-  friend OCTAVE_API FloatComplexColumnVector operator * (const FloatComplexDiagMatrix& a,
-                                         const ColumnVector& b);
+  friend OCTAVE_API FloatComplexColumnVector
+  operator * (const FloatComplexDiagMatrix& a, const ColumnVector& b);
 
-  friend OCTAVE_API FloatComplexColumnVector operator * (const FloatComplexDiagMatrix& a,
-                                         const FloatComplexColumnVector& b);
+  friend OCTAVE_API FloatComplexColumnVector
+  operator * (const FloatComplexDiagMatrix& a, const FloatComplexColumnVector& b);
 
   // other operations
 
   FloatComplex min (void) const;
   FloatComplex max (void) const;
 
   FloatColumnVector abs (void) const;
 
   // i/o
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatComplexColumnVector& a);
-  friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatComplexColumnVector& a);
+  friend OCTAVE_API std::ostream&
+  operator << (std::ostream& os, const FloatComplexColumnVector& a);
+  friend OCTAVE_API std::istream& operator >> (std::istream& is,
+                                               FloatComplexColumnVector& a);
 
   void resize (octave_idx_type n, const FloatComplex& rfv = FloatComplex (0))
   {
     Array<FloatComplex>::resize (dim_vector (n, 1), rfv);
   }
 
   void clear (octave_idx_type n)
-    { Array<FloatComplex>::clear (n, 1); }
+  { Array<FloatComplex>::clear (n, 1); }
 
 };
 
 MARRAY_FORWARD_DEFS (MArray, FloatComplexColumnVector, FloatComplex)
 
 #endif
diff --git a/liboctave/array/fCDiagMatrix.cc b/liboctave/array/fCDiagMatrix.cc
--- a/liboctave/array/fCDiagMatrix.cc
+++ b/liboctave/array/fCDiagMatrix.cc
@@ -71,32 +71,34 @@ FloatComplexDiagMatrix&
 FloatComplexDiagMatrix::fill (const FloatComplex& val)
 {
   for (octave_idx_type i = 0; i < length (); i++)
     elem (i, i) = val;
   return *this;
 }
 
 FloatComplexDiagMatrix&
-FloatComplexDiagMatrix::fill (float val, octave_idx_type beg, octave_idx_type end)
+FloatComplexDiagMatrix::fill (float val,
+                              octave_idx_type beg, octave_idx_type end)
 {
   if (beg < 0 || end >= length () || end < beg)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = beg; i <= end; i++)
     elem (i, i) = val;
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
-FloatComplexDiagMatrix::fill (const FloatComplex& val, octave_idx_type beg, octave_idx_type end)
+FloatComplexDiagMatrix::fill (const FloatComplex& val,
+                              octave_idx_type beg, octave_idx_type end)
 {
   if (beg < 0 || end >= length () || end < beg)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
   for (octave_idx_type i = beg; i <= end; i++)
@@ -181,17 +183,18 @@ FloatComplexDiagMatrix::fill (const Floa
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
-FloatComplexDiagMatrix::fill (const FloatComplexColumnVector& a, octave_idx_type beg)
+FloatComplexDiagMatrix::fill (const FloatComplexColumnVector& a,
+                              octave_idx_type beg)
 {
   octave_idx_type a_len = a.length ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
@@ -213,17 +216,18 @@ FloatComplexDiagMatrix::fill (const Floa
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 FloatComplexDiagMatrix&
-FloatComplexDiagMatrix::fill (const FloatComplexRowVector& a, octave_idx_type beg)
+FloatComplexDiagMatrix::fill (const FloatComplexRowVector& a,
+                              octave_idx_type beg)
 {
   octave_idx_type a_len = a.length ();
   if (beg < 0 || beg + a_len >= length ())
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
 
@@ -237,23 +241,25 @@ FloatDiagMatrix
 FloatComplexDiagMatrix::abs (void) const
 {
   return FloatDiagMatrix (extract_diag ().abs (), rows (), columns ());
 }
 
 FloatComplexDiagMatrix
 conj (const FloatComplexDiagMatrix& a)
 {
-  return FloatComplexDiagMatrix (conj (a.extract_diag ()), a.rows (), a.columns ());
+  return FloatComplexDiagMatrix (conj (a.extract_diag ()), a.rows (),
+                                 a.columns ());
 }
 
 // resize is the destructive analog for this one
 
 FloatComplexMatrix
-FloatComplexDiagMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
+FloatComplexDiagMatrix::extract (octave_idx_type r1, octave_idx_type c1,
+                                 octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { std::swap (r1, r2); }
   if (c1 > c2) { std::swap (c1, c2); }
 
   octave_idx_type new_r = r2 - r1 + 1;
   octave_idx_type new_c = c2 - c1 + 1;
 
   FloatComplexMatrix result (new_r, new_c);
@@ -421,17 +427,17 @@ FloatComplexDiagMatrix::operator += (con
     {
       gripe_nonconformant ("operator +=", r, c, a_nr, a_nc);
       return *this;
     }
 
   if (r == 0 || c == 0)
     return *this;
 
-  FloatComplex *d = fortran_vec (); // Ensures only one reference to my privates!
+  FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_add2 (length (), d, a.data ());
   return *this;
 }
 
 FloatComplexDiagMatrix
 operator * (const FloatComplexDiagMatrix& a, const FloatDiagMatrix& b)
 {
diff --git a/liboctave/array/fCDiagMatrix.h b/liboctave/array/fCDiagMatrix.h
--- a/liboctave/array/fCDiagMatrix.h
+++ b/liboctave/array/fCDiagMatrix.h
@@ -36,25 +36,29 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 FloatComplexDiagMatrix : public MDiagArray2<FloatComplex>
 {
 public:
 
   FloatComplexDiagMatrix (void) : MDiagArray2<FloatComplex> () { }
 
-  FloatComplexDiagMatrix (octave_idx_type r, octave_idx_type c) : MDiagArray2<FloatComplex> (r, c) { }
+  FloatComplexDiagMatrix (octave_idx_type r,
+                          octave_idx_type c)
+    : MDiagArray2<FloatComplex> (r, c) { }
 
-  FloatComplexDiagMatrix (octave_idx_type r, octave_idx_type c, const FloatComplex& val)
+  FloatComplexDiagMatrix (octave_idx_type r, octave_idx_type c,
+                          const FloatComplex& val)
     : MDiagArray2<FloatComplex> (r, c, val) { }
 
   explicit FloatComplexDiagMatrix (const Array<FloatComplex>& a)
     : MDiagArray2<FloatComplex> (a) { }
 
-  FloatComplexDiagMatrix (const Array<FloatComplex>& a, octave_idx_type r, octave_idx_type c)
+  FloatComplexDiagMatrix (const Array<FloatComplex>& a, octave_idx_type r,
+                          octave_idx_type c)
     : MDiagArray2<FloatComplex> (a, r, c) { }
 
   explicit FloatComplexDiagMatrix (const Array<float>& a)
     : MDiagArray2<FloatComplex> (Array<FloatComplex> (a)) { }
 
   explicit FloatComplexDiagMatrix (const FloatDiagMatrix& a);
 
   FloatComplexDiagMatrix (const MDiagArray2<FloatComplex>& a)
@@ -63,46 +67,55 @@ public:
   FloatComplexDiagMatrix (const FloatComplexDiagMatrix& a)
     : MDiagArray2<FloatComplex> (a) { }
 
   template <class U>
   FloatComplexDiagMatrix (const DiagArray2<U>& a)
     : MDiagArray2<FloatComplex> (a) { }
 
   FloatComplexDiagMatrix& operator = (const FloatComplexDiagMatrix& a)
-    {
-      MDiagArray2<FloatComplex>::operator = (a);
-      return *this;
-    }
+  {
+    MDiagArray2<FloatComplex>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const FloatComplexDiagMatrix& a) const;
   bool operator != (const FloatComplexDiagMatrix& a) const;
 
   FloatComplexDiagMatrix& fill (float val);
   FloatComplexDiagMatrix& fill (const FloatComplex& val);
-  FloatComplexDiagMatrix& fill (float val, octave_idx_type beg, octave_idx_type end);
-  FloatComplexDiagMatrix& fill (const FloatComplex& val, octave_idx_type beg, octave_idx_type end);
+  FloatComplexDiagMatrix& fill (float val,
+                                octave_idx_type beg, octave_idx_type end);
+  FloatComplexDiagMatrix& fill (const FloatComplex& val,
+                                octave_idx_type beg, octave_idx_type end);
   FloatComplexDiagMatrix& fill (const FloatColumnVector& a);
   FloatComplexDiagMatrix& fill (const FloatComplexColumnVector& a);
   FloatComplexDiagMatrix& fill (const FloatRowVector& a);
   FloatComplexDiagMatrix& fill (const FloatComplexRowVector& a);
-  FloatComplexDiagMatrix& fill (const FloatColumnVector& a, octave_idx_type beg);
-  FloatComplexDiagMatrix& fill (const FloatComplexColumnVector& a, octave_idx_type beg);
+  FloatComplexDiagMatrix& fill (const FloatColumnVector& a,
+                                octave_idx_type beg);
+  FloatComplexDiagMatrix& fill (const FloatComplexColumnVector& a,
+                                octave_idx_type beg);
   FloatComplexDiagMatrix& fill (const FloatRowVector& a, octave_idx_type beg);
-  FloatComplexDiagMatrix& fill (const FloatComplexRowVector& a, octave_idx_type beg);
+  FloatComplexDiagMatrix& fill (const FloatComplexRowVector& a,
+                                octave_idx_type beg);
 
-  FloatComplexDiagMatrix hermitian (void) const { return MDiagArray2<FloatComplex>::hermitian (std::conj); }
-  FloatComplexDiagMatrix transpose (void) const { return MDiagArray2<FloatComplex>::transpose (); }
+  FloatComplexDiagMatrix hermitian (void) const
+  { return MDiagArray2<FloatComplex>::hermitian (std::conj); }
+  FloatComplexDiagMatrix transpose (void) const
+  { return MDiagArray2<FloatComplex>::transpose (); }
   FloatDiagMatrix abs (void) const;
 
-  friend OCTAVE_API FloatComplexDiagMatrix conj (const FloatComplexDiagMatrix& a);
+  friend OCTAVE_API FloatComplexDiagMatrix
+  conj (const FloatComplexDiagMatrix& a);
 
   // resize is the destructive analog for this one
 
-  FloatComplexMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
+  FloatComplexMatrix extract (octave_idx_type r1, octave_idx_type c1,
+                              octave_idx_type r2, octave_idx_type c2) const;
 
   // extract row or column i
 
   FloatComplexRowVector row (octave_idx_type i) const;
   FloatComplexRowVector row (char *s) const;
 
   FloatComplexColumnVector column (octave_idx_type i) const;
   FloatComplexColumnVector column (char *s) const;
@@ -116,24 +129,25 @@ public:
   // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
   FloatComplexDiagMatrix& operator += (const FloatDiagMatrix& a);
   FloatComplexDiagMatrix& operator -= (const FloatDiagMatrix& a);
 
   // other operations
 
   FloatComplexColumnVector extract_diag (octave_idx_type k = 0) const
-    { return MDiagArray2<FloatComplex>::extract_diag (k); }
+  { return MDiagArray2<FloatComplex>::extract_diag (k); }
 
   FloatComplexDET determinant (void) const;
   float rcond (void) const;
 
   // i/o
 
-  friend std::ostream& operator << (std::ostream& os, const FloatComplexDiagMatrix& a);
+  friend std::ostream& operator << (std::ostream& os,
+                                    const FloatComplexDiagMatrix& a);
 
 };
 
 OCTAVE_API FloatComplexDiagMatrix conj (const FloatComplexDiagMatrix& a);
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 OCTAVE_API FloatComplexDiagMatrix
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -253,17 +253,18 @@ extern "C"
   F77_RET_T
   F77_FUNC (xclange, XCLANGE) (F77_CONST_CHAR_ARG_DECL,
                                const octave_idx_type&, const octave_idx_type&,
                                const FloatComplex*, const octave_idx_type&,
                                float*, float&
                                F77_CHAR_ARG_LEN_DECL);
 }
 
-static const FloatComplex FloatComplex_NaN_result (octave_Float_NaN, octave_Float_NaN);
+static const FloatComplex FloatComplex_NaN_result (octave_Float_NaN,
+                                                   octave_Float_NaN);
 
 // FloatComplex Matrix class
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatMatrix& a)
   : MArray<FloatComplex> (a)
 {
 }
 
@@ -296,17 +297,17 @@ FloatComplexMatrix::FloatComplexMatrix (
 
 FloatComplexMatrix::FloatComplexMatrix (const FloatComplexDiagMatrix& a)
   : MArray<FloatComplex> (a.dims (), 0.0)
 {
   for (octave_idx_type i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
-// FIXME -- could we use a templated mixed-type copy function
+// FIXME: could we use a templated mixed-type copy function
 // here?
 
 FloatComplexMatrix::FloatComplexMatrix (const boolMatrix& a)
   : MArray<FloatComplex> (a)
 {
 }
 
 FloatComplexMatrix::FloatComplexMatrix (const charMatrix& a)
@@ -361,17 +362,18 @@ FloatComplexMatrix::is_hermitian (void) 
     }
 
   return false;
 }
 
 // destructive insert/delete/reorder operations
 
 FloatComplexMatrix&
-FloatComplexMatrix::insert (const FloatMatrix& a, octave_idx_type r, octave_idx_type c)
+FloatComplexMatrix::insert (const FloatMatrix& a,
+                            octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r < 0 || r + a_nr > rows () || c < 0 || c + a_nc > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
@@ -385,17 +387,18 @@ FloatComplexMatrix::insert (const FloatM
         for (octave_idx_type i = 0; i < a_nr; i++)
           xelem (r+i, c+j) = a.elem (i, j);
     }
 
   return *this;
 }
 
 FloatComplexMatrix&
-FloatComplexMatrix::insert (const FloatRowVector& a, octave_idx_type r, octave_idx_type c)
+FloatComplexMatrix::insert (const FloatRowVector& a,
+                            octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.length ();
 
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
@@ -407,17 +410,18 @@ FloatComplexMatrix::insert (const FloatR
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r, c+i) = a.elem (i);
     }
 
   return *this;
 }
 
 FloatComplexMatrix&
-FloatComplexMatrix::insert (const FloatColumnVector& a, octave_idx_type r, octave_idx_type c)
+FloatComplexMatrix::insert (const FloatColumnVector& a,
+                            octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.length ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
@@ -429,17 +433,18 @@ FloatComplexMatrix::insert (const FloatC
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i, c) = a.elem (i);
     }
 
   return *this;
 }
 
 FloatComplexMatrix&
-FloatComplexMatrix::insert (const FloatDiagMatrix& a, octave_idx_type r, octave_idx_type c)
+FloatComplexMatrix::insert (const FloatDiagMatrix& a,
+                            octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r < 0 || r + a_nr > rows () || c < 0 || c + a_nc > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
@@ -456,40 +461,43 @@ FloatComplexMatrix::insert (const FloatD
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i, c+i) = a.elem (i, i);
     }
 
   return *this;
 }
 
 FloatComplexMatrix&
-FloatComplexMatrix::insert (const FloatComplexMatrix& a, octave_idx_type r, octave_idx_type c)
+FloatComplexMatrix::insert (const FloatComplexMatrix& a,
+                            octave_idx_type r, octave_idx_type c)
 {
   Array<FloatComplex>::insert (a, r, c);
   return *this;
 }
 
 FloatComplexMatrix&
-FloatComplexMatrix::insert (const FloatComplexRowVector& a, octave_idx_type r, octave_idx_type c)
+FloatComplexMatrix::insert (const FloatComplexRowVector& a,
+                            octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.length ();
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
 
   for (octave_idx_type i = 0; i < a_len; i++)
     elem (r, c+i) = a.elem (i);
 
   return *this;
 }
 
 FloatComplexMatrix&
-FloatComplexMatrix::insert (const FloatComplexColumnVector& a, octave_idx_type r, octave_idx_type c)
+FloatComplexMatrix::insert (const FloatComplexColumnVector& a,
+                            octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.length ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
@@ -501,17 +509,18 @@ FloatComplexMatrix::insert (const FloatC
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i, c) = a.elem (i);
     }
 
   return *this;
 }
 
 FloatComplexMatrix&
-FloatComplexMatrix::insert (const FloatComplexDiagMatrix& a, octave_idx_type r, octave_idx_type c)
+FloatComplexMatrix::insert (const FloatComplexDiagMatrix& a,
+                            octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r < 0 || r + a_nr > rows () || c < 0 || c + a_nc > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
@@ -564,17 +573,18 @@ FloatComplexMatrix::fill (const FloatCom
         for (octave_idx_type i = 0; i < nr; i++)
           xelem (i, j) = val;
     }
 
   return *this;
 }
 
 FloatComplexMatrix&
-FloatComplexMatrix::fill (float val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2)
+FloatComplexMatrix::fill (float val, octave_idx_type r1, octave_idx_type c1,
+                          octave_idx_type r2, octave_idx_type c2)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
     {
       (*current_liboctave_error_handler) ("range error for fill");
@@ -592,17 +602,19 @@ FloatComplexMatrix::fill (float val, oct
         for (octave_idx_type i = r1; i <= r2; i++)
           xelem (i, j) = val;
     }
 
   return *this;
 }
 
 FloatComplexMatrix&
-FloatComplexMatrix::fill (const FloatComplex& val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2)
+FloatComplexMatrix::fill (const FloatComplex& val,
+                          octave_idx_type r1, octave_idx_type c1,
+                          octave_idx_type r2, octave_idx_type c2)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
     {
       (*current_liboctave_error_handler) ("range error for fill");
@@ -924,26 +936,28 @@ FloatComplexMatrix
 conj (const FloatComplexMatrix& a)
 {
   return do_mx_unary_map<FloatComplex, FloatComplex, std::conj<float> > (a);
 }
 
 // resize is the destructive equivalent for this one
 
 FloatComplexMatrix
-FloatComplexMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
+FloatComplexMatrix::extract (octave_idx_type r1, octave_idx_type c1,
+                             octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { std::swap (r1, r2); }
   if (c1 > c2) { std::swap (c1, c2); }
 
   return index (idx_vector (r1, r2+1), idx_vector (c1, c2+1));
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const
+FloatComplexMatrix::extract_n (octave_idx_type r1, octave_idx_type c1,
+                               octave_idx_type nr, octave_idx_type nc) const
 {
   return index (idx_vector (r1, r1 + nr), idx_vector (c1, c1 + nc));
 }
 
 // extract row or column i.
 
 FloatComplexRowVector
 FloatComplexMatrix::row (octave_idx_type i) const
@@ -971,17 +985,17 @@ FloatComplexMatrix::inverse (octave_idx_
 {
   float rcon;
   MatrixType mattype (*this);
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::inverse (octave_idx_type& info, float& rcon, int force,
-                        int calc_cond) const
+                             int calc_cond) const
 {
   MatrixType mattype (*this);
   return inverse (mattype, info, rcon, force, calc_cond);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::inverse (MatrixType &mattype) const
 {
@@ -994,17 +1008,17 @@ FloatComplexMatrix
 FloatComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info) const
 {
   float rcon;
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::tinverse (MatrixType &mattype, octave_idx_type& info,
-                         float& rcon, int force, int calc_cond) const
+                              float& rcon, int force, int calc_cond) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
@@ -1051,17 +1065,17 @@ FloatComplexMatrix::tinverse (MatrixType
         retval = *this; // Restore matrix contents.
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::finverse (MatrixType &mattype, octave_idx_type& info,
-                         float& rcon, int force, int calc_cond) const
+                              float& rcon, int force, int calc_cond) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
@@ -1086,17 +1100,18 @@ FloatComplexMatrix::finverse (MatrixType
       z.resize (dim_vector (lwork, 1));
       FloatComplex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       float anorm;
       if (calc_cond)
-        anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
+        anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0))
+                .max ();
 
       F77_XFCN (cgetrf, CGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -1132,17 +1147,17 @@ FloatComplexMatrix::finverse (MatrixType
         mattype.mark_as_rectangular ();
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::inverse (MatrixType &mattype, octave_idx_type& info,
-                        float& rcon, int force, int calc_cond) const
+                             float& rcon, int force, int calc_cond) const
 {
   int typ = mattype.type (false);
   FloatComplexMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Upper || typ == MatrixType::Lower)
@@ -1163,17 +1178,18 @@ FloatComplexMatrix::inverse (MatrixType 
           else
             mattype.mark_as_unsymmetric ();
         }
 
       if (!mattype.is_hermitian ())
         ret = finverse (mattype, info, rcon, force, calc_cond);
 
       if ((mattype.is_hermitian () || calc_cond) && rcon == 0.)
-        ret = FloatComplexMatrix (rows (), columns (), FloatComplex (octave_Float_Inf, 0.));
+        ret = FloatComplexMatrix (rows (), columns (),
+                                  FloatComplex (octave_Float_Inf, 0.));
     }
 
   return ret;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::pseudo_inverse (float tol) const
 {
@@ -1306,20 +1322,22 @@ FloatComplexMatrix::ifourier2d (void) co
 #else
 
 extern "C"
 {
   F77_RET_T
   F77_FUNC (cffti, CFFTI) (const octave_idx_type&, FloatComplex*);
 
   F77_RET_T
-  F77_FUNC (cfftf, CFFTF) (const octave_idx_type&, FloatComplex*, FloatComplex*);
+  F77_FUNC (cfftf, CFFTF) (const octave_idx_type&, FloatComplex*,
+                           FloatComplex*);
 
   F77_RET_T
-  F77_FUNC (cfftb, CFFTB) (const octave_idx_type&, FloatComplex*, FloatComplex*);
+  F77_FUNC (cfftb, CFFTB) (const octave_idx_type&, FloatComplex*,
+                           FloatComplex*);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::fourier (void) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
@@ -1550,25 +1568,27 @@ FloatComplexMatrix::determinant (void) c
 FloatComplexDET
 FloatComplexMatrix::determinant (octave_idx_type& info) const
 {
   float rcon;
   return determinant (info, rcon, 0);
 }
 
 FloatComplexDET
-FloatComplexMatrix::determinant (octave_idx_type& info, float& rcon, int calc_cond) const
+FloatComplexMatrix::determinant (octave_idx_type& info, float& rcon,
+                                 int calc_cond) const
 {
   MatrixType mattype (*this);
   return determinant (mattype, info, rcon, calc_cond);
 }
 
 FloatComplexDET
 FloatComplexMatrix::determinant (MatrixType& mattype,
-                                 octave_idx_type& info, float& rcon, int calc_cond) const
+                                 octave_idx_type& info, float& rcon,
+                                 int calc_cond) const
 {
   FloatComplexDET retval (1.0);
 
   info = 0;
   rcon = 0.0;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -1787,17 +1807,17 @@ FloatComplexMatrix::rcond (MatrixType &m
             {
               octave_idx_type info = 0;
               char job = 'L';
 
               FloatComplexMatrix atmp = *this;
               FloatComplex *tmp_data = atmp.fortran_vec ();
 
               anorm = atmp.abs().sum().
-                row(static_cast<octave_idx_type>(0)).max();
+                      row(static_cast<octave_idx_type>(0)).max();
 
               F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
@@ -1830,17 +1850,17 @@ FloatComplexMatrix::rcond (MatrixType &m
               FloatComplexMatrix atmp = *this;
               FloatComplex *tmp_data = atmp.fortran_vec ();
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
-                  row(static_cast<octave_idx_type>(0)).max ();
+                        row(static_cast<octave_idx_type>(0)).max ();
 
               Array<FloatComplex> z (dim_vector (2 * nc, 1));
               FloatComplex *pz = z.fortran_vec ();
               Array<float> rz (dim_vector (2 * nc, 1));
               float *prz = rz.fortran_vec ();
 
               F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -1866,19 +1886,19 @@ FloatComplexMatrix::rcond (MatrixType &m
         rcon = 0.0;
     }
 
   return rcon;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::utsolve (MatrixType &mattype, const FloatComplexMatrix& b,
-                        octave_idx_type& info, float& rcon,
-                        solve_singularity_handler sing_handler,
-                        bool calc_cond, blas_trans_type transt) const
+                             octave_idx_type& info, float& rcon,
+                             solve_singularity_handler sing_handler,
+                             bool calc_cond, blas_trans_type transt) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
@@ -1967,19 +1987,19 @@ FloatComplexMatrix::utsolve (MatrixType 
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::ltsolve (MatrixType &mattype, const FloatComplexMatrix& b,
-                        octave_idx_type& info, float& rcon,
-                        solve_singularity_handler sing_handler,
-                        bool calc_cond, blas_trans_type transt) const
+                             octave_idx_type& info, float& rcon,
+                             solve_singularity_handler sing_handler,
+                             bool calc_cond, blas_trans_type transt) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
@@ -2068,36 +2088,36 @@ FloatComplexMatrix::ltsolve (MatrixType 
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::fsolve (MatrixType &mattype, const FloatComplexMatrix& b,
-                       octave_idx_type& info, float& rcon,
-                       solve_singularity_handler sing_handler,
-                       bool calc_cond) const
+                            octave_idx_type& info, float& rcon,
+                            solve_singularity_handler sing_handler,
+                            bool calc_cond) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || b.cols () == 0)
     retval = FloatComplexMatrix (nc, b.cols (), FloatComplex (0.0, 0.0));
   else
     {
       volatile int typ = mattype.type ();
 
-     // Calculate the norm of the matrix, for later use.
+      // Calculate the norm of the matrix, for later use.
       float anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
 
           FloatComplexMatrix atmp = *this;
@@ -2182,17 +2202,18 @@ FloatComplexMatrix::fsolve (MatrixType &
 
           Array<FloatComplex> z (dim_vector (2 * nc, 1));
           FloatComplex *pz = z.fortran_vec ();
           Array<float> rz (dim_vector (2 * nc, 1));
           float *prz = rz.fortran_vec ();
 
           // Calculate the norm of the matrix, for later use.
           if (anorm < 0.)
-            anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
+            anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0))
+                    .max ();
 
           F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
@@ -2262,82 +2283,86 @@ FloatComplexMatrix::solve (MatrixType &t
 {
   octave_idx_type info;
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b,
-                      octave_idx_type& info) const
+                           octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-                      float& rcon) const
+FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b,
+                           octave_idx_type& info,
+                           float& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-                      float& rcon, solve_singularity_handler sing_handler,
-                      bool singular_fallback, blas_trans_type transt) const
+FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b,
+                           octave_idx_type& info,
+                           float& rcon, solve_singularity_handler sing_handler,
+                           bool singular_fallback, blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (b);
   return solve (typ, tmp, info, rcon, sing_handler, singular_fallback, transt);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b,
-                      octave_idx_type& info) const
+                           octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b,
-                      octave_idx_type& info, float& rcon) const
+                           octave_idx_type& info, float& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &mattype, const FloatComplexMatrix& b,
-                      octave_idx_type& info, float& rcon,
-                      solve_singularity_handler sing_handler,
-                      bool singular_fallback, blas_trans_type transt) const
+                           octave_idx_type& info, float& rcon,
+                           solve_singularity_handler sing_handler,
+                           bool singular_fallback, blas_trans_type transt) const
 {
   FloatComplexMatrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   // Only calculate the condition number for LU/Cholesky
   if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, info, rcon, sing_handler, false, transt);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, info, rcon, sing_handler, false, transt);
   else if (transt == blas_trans)
-    return transpose ().solve (mattype, b, info, rcon, sing_handler, singular_fallback);
+    return transpose ().solve (mattype, b, info, rcon, sing_handler,
+                               singular_fallback);
   else if (transt == blas_conj_trans)
-    retval = hermitian ().solve (mattype, b, info, rcon, sing_handler, singular_fallback);
+    retval = hermitian ().solve (mattype, b, info, rcon, sing_handler,
+                                 singular_fallback);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, info, rcon, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return FloatComplexMatrix ();
     }
 
@@ -2356,64 +2381,68 @@ FloatComplexMatrix::solve (MatrixType &t
 {
   octave_idx_type info;
   float rcon;
   return solve (typ, FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b,
-                      octave_idx_type& info) const
+                           octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b,
-                      octave_idx_type& info, float& rcon) const
+                           octave_idx_type& info, float& rcon) const
 {
   return solve (typ, FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b,
-                      octave_idx_type& info, float& rcon,
-                      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                           octave_idx_type& info, float& rcon,
+                           solve_singularity_handler sing_handler,
+                           blas_trans_type transt) const
 {
-  return solve (typ, FloatComplexColumnVector (b), info, rcon, sing_handler, transt);
+  return solve (typ, FloatComplexColumnVector (b), info, rcon, sing_handler,
+                transt);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b) const
+FloatComplexMatrix::solve (MatrixType &typ,
+                           const FloatComplexColumnVector& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
-                      octave_idx_type& info) const
+                           octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
-                      octave_idx_type& info, float& rcon) const
+                           octave_idx_type& info, float& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
-                      octave_idx_type& info, float& rcon,
-                      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                           octave_idx_type& info, float& rcon,
+                           solve_singularity_handler sing_handler,
+                           blas_trans_type transt) const
 {
 
   FloatComplexMatrix tmp (b);
   tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
   return tmp.column (static_cast<octave_idx_type> (0));
 }
 
 FloatComplexMatrix
@@ -2427,114 +2456,127 @@ FloatComplexMatrix::solve (const FloatMa
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatMatrix& b, octave_idx_type& info) const
 {
   float rcon;
   return solve (b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (const FloatMatrix& b, octave_idx_type& info, float& rcon) const
+FloatComplexMatrix::solve (const FloatMatrix& b, octave_idx_type& info,
+                           float& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (const FloatMatrix& b, octave_idx_type& info, float& rcon,
-                      solve_singularity_handler sing_handler, blas_trans_type transt) const
+FloatComplexMatrix::solve (const FloatMatrix& b, octave_idx_type& info,
+                           float& rcon,
+                           solve_singularity_handler sing_handler,
+                           blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (b);
   return solve (tmp, info, rcon, sing_handler, transt);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatComplexMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info) const
+FloatComplexMatrix::solve (const FloatComplexMatrix& b,
+                           octave_idx_type& info) const
 {
   float rcon;
   return solve (b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon) const
+FloatComplexMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info,
+                           float& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon,
-                      solve_singularity_handler sing_handler, blas_trans_type transt) const
+FloatComplexMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info,
+                           float& rcon,
+                           solve_singularity_handler sing_handler,
+                           blas_trans_type transt) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, info, rcon, sing_handler, true, transt);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatColumnVector& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::solve (const FloatColumnVector& b, octave_idx_type& info) const
+FloatComplexMatrix::solve (const FloatColumnVector& b,
+                           octave_idx_type& info) const
 {
   float rcon;
   return solve (FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatColumnVector& b, octave_idx_type& info,
-                      float& rcon) const
+                           float& rcon) const
 {
   return solve (FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatColumnVector& b, octave_idx_type& info,
-                      float& rcon,
-                      solve_singularity_handler sing_handler, blas_trans_type transt) const
+                           float& rcon,
+                           solve_singularity_handler sing_handler,
+                           blas_trans_type transt) const
 {
   return solve (FloatComplexColumnVector (b), info, rcon, sing_handler, transt);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatComplexColumnVector& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info) const
+FloatComplexMatrix::solve (const FloatComplexColumnVector& b,
+                           octave_idx_type& info) const
 {
   float rcon;
   return solve (b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info,
-                      float& rcon) const
+FloatComplexMatrix::solve (const FloatComplexColumnVector& b,
+                           octave_idx_type& info,
+                           float& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info,
-                      float& rcon,
-                      solve_singularity_handler sing_handler, blas_trans_type transt) const
+FloatComplexMatrix::solve (const FloatComplexColumnVector& b,
+                           octave_idx_type& info,
+                           float& rcon,
+                           solve_singularity_handler sing_handler,
+                           blas_trans_type transt) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, info, rcon, sing_handler, transt);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatMatrix& b) const
 {
@@ -2549,57 +2591,58 @@ FloatComplexMatrix::lssolve (const Float
 {
   octave_idx_type rank;
   float rcon;
   return lssolve (FloatComplexMatrix (b), info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatMatrix& b, octave_idx_type& info,
-                        octave_idx_type& rank) const
+                             octave_idx_type& rank) const
 {
   float rcon;
   return lssolve (FloatComplexMatrix (b), info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatMatrix& b, octave_idx_type& info,
-                        octave_idx_type& rank, float& rcon) const
+                             octave_idx_type& rank, float& rcon) const
 {
   return lssolve (FloatComplexMatrix (b), info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatComplexMatrix& b) const
 {
   octave_idx_type info;
   octave_idx_type rank;
   float rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 FloatComplexMatrix
-FloatComplexMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info) const
+FloatComplexMatrix::lssolve (const FloatComplexMatrix& b,
+                             octave_idx_type& info) const
 {
   octave_idx_type rank;
   float rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
-                        octave_idx_type& rank) const
+                             octave_idx_type& rank) const
 {
   float rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
-                        octave_idx_type& rank, float& rcon) const
+                             octave_idx_type& rank, float& rcon) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nrhs = b.cols ();
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2661,18 +2704,19 @@ FloatComplexMatrix::lssolve (const Float
 #else
       float tmp = log (dminmn / dsmlsizp1) / log (2.0);
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
-        + 3*smlsiz*nrhs + std::max ((smlsiz+1)*(smlsiz+1),
-                                    n*(1+nrhs) + 2*nrhs);
+                               + 3*smlsiz*nrhs
+                               + std::max ((smlsiz+1)*(smlsiz+1),
+                                           n*(1+nrhs) + 2*nrhs);
       if (lrwork < 1)
         lrwork = 1;
       Array<float> rwork (dim_vector (lrwork, 1));
       float *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
@@ -2737,67 +2781,71 @@ FloatComplexMatrix::lssolve (const Float
 {
   octave_idx_type info;
   octave_idx_type rank;
   float rcon;
   return lssolve (FloatComplexColumnVector (b), info, rank, rcon);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info) const
+FloatComplexMatrix::lssolve (const FloatColumnVector& b,
+                             octave_idx_type& info) const
 {
   octave_idx_type rank;
   float rcon;
   return lssolve (FloatComplexColumnVector (b), info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info,
-                        octave_idx_type& rank) const
+                             octave_idx_type& rank) const
 {
   float rcon;
   return lssolve (FloatComplexColumnVector (b), info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info,
-                        octave_idx_type& rank, float& rcon) const
+                             octave_idx_type& rank, float& rcon) const
 {
   return lssolve (FloatComplexColumnVector (b), info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::lssolve (const FloatComplexColumnVector& b) const
 {
   octave_idx_type info;
   octave_idx_type rank;
   float rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info) const
+FloatComplexMatrix::lssolve (const FloatComplexColumnVector& b,
+                             octave_idx_type& info) const
 {
   octave_idx_type rank;
   float rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info,
-                        octave_idx_type& rank) const
+FloatComplexMatrix::lssolve (const FloatComplexColumnVector& b,
+                             octave_idx_type& info,
+                             octave_idx_type& rank) const
 {
   float rcon;
   return lssolve (b, info, rank, rcon);
 
 }
 
 FloatComplexColumnVector
-FloatComplexMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info,
-                        octave_idx_type& rank, float& rcon) const
+FloatComplexMatrix::lssolve (const FloatComplexColumnVector& b,
+                             octave_idx_type& info,
+                             octave_idx_type& rank, float& rcon) const
 {
   FloatComplexColumnVector retval;
 
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2851,17 +2899,17 @@ FloatComplexMatrix::lssolve (const Float
 #else
       float tmp = log (dminmn / dsmlsizp1) / log (2.0);
 #endif
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
-        + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
+                               + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
         lrwork = 1;
       Array<float> rwork (dim_vector (lrwork, 1));
       float *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
@@ -3038,17 +3086,17 @@ FloatComplexMatrix::operator += (const F
     {
       gripe_nonconformant ("operator +=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   if (nr == 0 || nc == 0)
     return *this;
 
-  FloatComplex *d = fortran_vec (); // Ensures only one reference to my privates!
+  FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_add2 (length (), d, a.data ());
   return *this;
 }
 
 FloatComplexMatrix&
 FloatComplexMatrix::operator -= (const FloatMatrix& a)
 {
@@ -3062,17 +3110,17 @@ FloatComplexMatrix::operator -= (const F
     {
       gripe_nonconformant ("operator -=", nr, nc, a_nr, a_nc);
       return *this;
     }
 
   if (nr == 0 || nc == 0)
     return *this;
 
-  FloatComplex *d = fortran_vec (); // Ensures only one reference to my privates!
+  FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_sub2 (length (), d, a.data ());
   return *this;
 }
 
 // unary operations
 
 boolMatrix
@@ -3163,17 +3211,17 @@ FloatComplexMatrix::all_integers (float&
 }
 
 bool
 FloatComplexMatrix::too_large_for_float (void) const
 {
   return false;
 }
 
-// FIXME Do these really belong here?  Maybe they should be
+// FIXME: Do these really belong here?  Maybe they should be
 // in a base class?
 
 boolMatrix
 FloatComplexMatrix::all (int dim) const
 {
   return do_mx_red_op<bool, FloatComplex> (*this, dim, mx_inline_all);
 }
 
@@ -3181,23 +3229,25 @@ boolMatrix
 FloatComplexMatrix::any (int dim) const
 {
   return do_mx_red_op<bool, FloatComplex> (*this, dim, mx_inline_any);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::cumprod (int dim) const
 {
-  return do_mx_cum_op<FloatComplex, FloatComplex> (*this, dim, mx_inline_cumprod);
+  return do_mx_cum_op<FloatComplex, FloatComplex> (*this, dim,
+                                                   mx_inline_cumprod);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::cumsum (int dim) const
 {
-  return do_mx_cum_op<FloatComplex, FloatComplex> (*this, dim, mx_inline_cumsum);
+  return do_mx_cum_op<FloatComplex, FloatComplex> (*this, dim,
+                                                   mx_inline_cumsum);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::prod (int dim) const
 {
   return do_mx_red_op<FloatComplex, FloatComplex> (*this, dim, mx_inline_prod);
 }
 
@@ -3310,17 +3360,18 @@ FloatComplexMatrix::row_min (Array<octav
           float abs_min = octave_Float_NaN;
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_min = elem (i, idx_j);
 
               if (! xisnan (tmp_min))
                 {
-                  abs_min = real_only ? std::real (tmp_min) : std::abs (tmp_min);
+                  abs_min = real_only ? std::real (tmp_min)
+                                      : std::abs (tmp_min);
                   break;
                 }
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               FloatComplex tmp = elem (i, j);
 
@@ -3384,17 +3435,18 @@ FloatComplexMatrix::row_max (Array<octav
           float abs_max = octave_Float_NaN;
 
           for (idx_j = 0; idx_j < nc; idx_j++)
             {
               tmp_max = elem (i, idx_j);
 
               if (! xisnan (tmp_max))
                 {
-                  abs_max = real_only ? std::real (tmp_max) : std::abs (tmp_max);
+                  abs_max = real_only ? std::real (tmp_max)
+                                      : std::abs (tmp_max);
                   break;
                 }
             }
 
           for (octave_idx_type j = idx_j+1; j < nc; j++)
             {
               FloatComplex tmp = elem (i, j);
 
@@ -3458,17 +3510,18 @@ FloatComplexMatrix::column_min (Array<oc
           float abs_min = octave_Float_NaN;
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_min = elem (idx_i, j);
 
               if (! xisnan (tmp_min))
                 {
-                  abs_min = real_only ? std::real (tmp_min) : std::abs (tmp_min);
+                  abs_min = real_only ? std::real (tmp_min)
+                                      : std::abs (tmp_min);
                   break;
                 }
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               FloatComplex tmp = elem (i, j);
 
@@ -3532,17 +3585,18 @@ FloatComplexMatrix::column_max (Array<oc
           float abs_max = octave_Float_NaN;
 
           for (idx_i = 0; idx_i < nr; idx_i++)
             {
               tmp_max = elem (idx_i, j);
 
               if (! xisnan (tmp_max))
                 {
-                  abs_max = real_only ? std::real (tmp_max) : std::abs (tmp_max);
+                  abs_max = real_only ? std::real (tmp_max)
+                                      : std::abs (tmp_max);
                   break;
                 }
             }
 
           for (octave_idx_type i = idx_i+1; i < nr; i++)
             {
               FloatComplex tmp = elem (i, j);
 
@@ -3636,17 +3690,17 @@ Givens (const FloatComplex& x, const Flo
 }
 
 FloatComplexMatrix
 Sylvester (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
            const FloatComplexMatrix& c)
 {
   FloatComplexMatrix retval;
 
-  // FIXME -- need to check that a, b, and c are all the same
+  // FIXME: need to check that a, b, and c are all the same
   // size.
 
   // Compute Schur decompositions
 
   FloatComplexSCHUR as (a, "U");
   FloatComplexSCHUR bs (b, "U");
 
   // Transform c to new coordinates.
@@ -3674,17 +3728,17 @@ Sylvester (const FloatComplexMatrix& a, 
 
   F77_XFCN (ctrsyl, CTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              1, a_nr, b_nr, pa, a_nr, pb,
                              b_nr, px, a_nr, scale, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
-  // FIXME -- check info?
+  // FIXME: check info?
 
   retval = -ua * cx * ub.hermitian ();
 
   return retval;
 }
 
 FloatComplexMatrix
 operator * (const FloatComplexMatrix& m, const FloatMatrix& a)
@@ -3755,17 +3809,17 @@ xgemm (const FloatComplexMatrix& a, cons
   else
     {
       if (a_nr == 0 || a_nc == 0 || b_nc == 0)
         retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
       else if (a.data () == b.data () && a_nr == b_nc && tra != trb)
         {
           octave_idx_type lda = a.rows ();
 
-          // FIXME -- looking at the reference BLAS, it appears that it
+          // FIXME: looking at the reference BLAS, it appears that it
           // should not be necessary to initialize the output matrix if
           // BETA is 0 in the call to CHERK, but ATLAS appears to
           // use the result matrix before zeroing the elements.
 
           retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
           FloatComplex *c = retval.fortran_vec ();
 
           const char ctra = get_blas_trans_arg (tra, cja);
@@ -3803,23 +3857,26 @@ xgemm (const FloatComplexMatrix& a, cons
 
           retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
           FloatComplex *c = retval.fortran_vec ();
 
           if (b_nc == 1 && a_nr == 1)
             {
               if (cja == cjb)
                 {
-                  F77_FUNC (xcdotu, XCDOTU) (a_nc, a.data (), 1, b.data (), 1, *c);
+                  F77_FUNC (xcdotu, XCDOTU) (a_nc, a.data (), 1, b.data (), 1,
+                                             *c);
                   if (cja) *c = std::conj (*c);
                 }
               else if (cja)
-                  F77_FUNC (xcdotc, XCDOTC) (a_nc, a.data (), 1, b.data (), 1, *c);
+                F77_FUNC (xcdotc, XCDOTC) (a_nc, a.data (), 1, b.data (), 1,
+                                           *c);
               else
-                  F77_FUNC (xcdotc, XCDOTC) (a_nc, b.data (), 1, a.data (), 1, *c);
+                F77_FUNC (xcdotc, XCDOTC) (a_nc, b.data (), 1, a.data (), 1,
+                                           *c);
             }
           else if (b_nc == 1 && ! cjb)
             {
               const char ctra = get_blas_trans_arg (tra, cja);
               F77_XFCN (cgemv, CGEMV, (F77_CONST_CHAR_ARG2 (&ctra, 1),
                                        lda, tda, 1.0,  a.data (), lda,
                                        b.data (), 1, 0.0, c, 1
                                        F77_CHAR_ARG_LEN (1)));
@@ -3850,17 +3907,17 @@ xgemm (const FloatComplexMatrix& a, cons
 }
 
 FloatComplexMatrix
 operator * (const FloatComplexMatrix& a, const FloatComplexMatrix& b)
 {
   return xgemm (a, b);
 }
 
-// FIXME -- it would be nice to share code among the min/max
+// FIXME: it would be nice to share code among the min/max
 // functions below.
 
 #define EMPTY_RETURN_CHECK(T) \
   if (nr == 0 || nc == 0) \
     return T (nr, nc);
 
 FloatComplexMatrix
 min (const FloatComplex& c, const FloatComplexMatrix& m)
@@ -4046,17 +4103,18 @@ FloatComplexMatrix linspace (const Float
                              octave_idx_type n)
 
 {
   if (n < 1) n = 1;
 
   octave_idx_type m = x1.length ();
 
   if (x2.length () != m)
-    (*current_liboctave_error_handler) ("linspace: vectors must be of equal length");
+    (*current_liboctave_error_handler)
+      ("linspace: vectors must be of equal length");
 
   NoAlias<FloatComplexMatrix> retval;
 
   retval.clear (m, n);
   for (octave_idx_type i = 0; i < m; i++)
     retval(i, 0) = x1(i);
 
   // The last column is not needed while using delta.
diff --git a/liboctave/array/fCMatrix.h b/liboctave/array/fCMatrix.h
--- a/liboctave/array/fCMatrix.h
+++ b/liboctave/array/fCMatrix.h
@@ -85,42 +85,53 @@ public:
 
   explicit FloatComplexMatrix (const boolMatrix& a);
 
   explicit FloatComplexMatrix (const charMatrix& a);
 
   FloatComplexMatrix (const FloatMatrix& re, const FloatMatrix& im);
 
   FloatComplexMatrix& operator = (const FloatComplexMatrix& a)
-    {
-      MArray<FloatComplex>::operator = (a);
-      return *this;
-    }
+  {
+    MArray<FloatComplex>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const FloatComplexMatrix& a) const;
   bool operator != (const FloatComplexMatrix& a) const;
 
   bool is_hermitian (void) const;
 
   // destructive insert/delete/reorder operations
 
-  FloatComplexMatrix& insert (const FloatMatrix& a, octave_idx_type r, octave_idx_type c);
-  FloatComplexMatrix& insert (const FloatRowVector& a, octave_idx_type r, octave_idx_type c);
-  FloatComplexMatrix& insert (const FloatColumnVector& a, octave_idx_type r, octave_idx_type c);
-  FloatComplexMatrix& insert (const FloatDiagMatrix& a, octave_idx_type r, octave_idx_type c);
+  FloatComplexMatrix& insert (const FloatMatrix& a,
+                              octave_idx_type r, octave_idx_type c);
+  FloatComplexMatrix& insert (const FloatRowVector& a,
+                              octave_idx_type r, octave_idx_type c);
+  FloatComplexMatrix& insert (const FloatColumnVector& a,
+                              octave_idx_type r, octave_idx_type c);
+  FloatComplexMatrix& insert (const FloatDiagMatrix& a,
+                              octave_idx_type r, octave_idx_type c);
 
-  FloatComplexMatrix& insert (const FloatComplexMatrix& a, octave_idx_type r, octave_idx_type c);
-  FloatComplexMatrix& insert (const FloatComplexRowVector& a, octave_idx_type r, octave_idx_type c);
-  FloatComplexMatrix& insert (const FloatComplexColumnVector& a, octave_idx_type r, octave_idx_type c);
-  FloatComplexMatrix& insert (const FloatComplexDiagMatrix& a, octave_idx_type r, octave_idx_type c);
+  FloatComplexMatrix& insert (const FloatComplexMatrix& a,
+                              octave_idx_type r, octave_idx_type c);
+  FloatComplexMatrix& insert (const FloatComplexRowVector& a,
+                              octave_idx_type r, octave_idx_type c);
+  FloatComplexMatrix& insert (const FloatComplexColumnVector& a,
+                              octave_idx_type r, octave_idx_type c);
+  FloatComplexMatrix& insert (const FloatComplexDiagMatrix& a,
+                              octave_idx_type r, octave_idx_type c);
 
   FloatComplexMatrix& fill (float val);
   FloatComplexMatrix& fill (const FloatComplex& val);
-  FloatComplexMatrix& fill (float val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2);
-  FloatComplexMatrix& fill (const FloatComplex& val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2);
+  FloatComplexMatrix& fill (float val, octave_idx_type r1, octave_idx_type c1,
+                            octave_idx_type r2, octave_idx_type c2);
+  FloatComplexMatrix& fill (const FloatComplex& val,
+                            octave_idx_type r1, octave_idx_type c1,
+                            octave_idx_type r2, octave_idx_type c2);
 
   FloatComplexMatrix append (const FloatMatrix& a) const;
   FloatComplexMatrix append (const FloatRowVector& a) const;
   FloatComplexMatrix append (const FloatColumnVector& a) const;
   FloatComplexMatrix append (const FloatDiagMatrix& a) const;
 
   FloatComplexMatrix append (const FloatComplexMatrix& a) const;
   FloatComplexMatrix append (const FloatComplexRowVector& a) const;
@@ -133,202 +144,227 @@ public:
   FloatComplexMatrix stack (const FloatDiagMatrix& a) const;
 
   FloatComplexMatrix stack (const FloatComplexMatrix& a) const;
   FloatComplexMatrix stack (const FloatComplexRowVector& a) const;
   FloatComplexMatrix stack (const FloatComplexColumnVector& a) const;
   FloatComplexMatrix stack (const FloatComplexDiagMatrix& a) const;
 
   FloatComplexMatrix hermitian (void) const
-    { return MArray<FloatComplex>::hermitian (std::conj); }
+  { return MArray<FloatComplex>::hermitian (std::conj); }
   FloatComplexMatrix transpose (void) const
-    { return MArray<FloatComplex>::transpose (); }
+  { return MArray<FloatComplex>::transpose (); }
 
   friend OCTAVE_API FloatComplexMatrix conj (const FloatComplexMatrix& a);
 
   // resize is the destructive equivalent for this one
 
-  FloatComplexMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
+  FloatComplexMatrix extract (octave_idx_type r1, octave_idx_type c1,
+                              octave_idx_type r2, octave_idx_type c2) const;
 
-  FloatComplexMatrix extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const;
+  FloatComplexMatrix extract_n (octave_idx_type r1, octave_idx_type c1,
+                                octave_idx_type nr, octave_idx_type nc) const;
 
   // extract row or column i.
 
   FloatComplexRowVector row (octave_idx_type i) const;
 
   FloatComplexColumnVector column (octave_idx_type i) const;
 
   void resize (octave_idx_type nr, octave_idx_type nc,
                const FloatComplex& rfv = FloatComplex (0))
   {
     MArray<FloatComplex>::resize (dim_vector (nr, nc), rfv);
   }
 
 private:
   FloatComplexMatrix tinverse (MatrixType &mattype, octave_idx_type& info,
-                          float& rcon, int force, int calc_cond) const;
+                               float& rcon, int force, int calc_cond) const;
 
   FloatComplexMatrix finverse (MatrixType &mattype, octave_idx_type& info,
-                          float& rcon, int force, int calc_cond) const;
+                               float& rcon, int force, int calc_cond) const;
 
 public:
   FloatComplexMatrix inverse (void) const;
   FloatComplexMatrix inverse (octave_idx_type& info) const;
-  FloatComplexMatrix inverse (octave_idx_type& info, float& rcon, int force = 0,
-                         int calc_cond = 1) const;
+  FloatComplexMatrix inverse (octave_idx_type& info, float& rcon,
+                              int force = 0, int calc_cond = 1) const;
 
   FloatComplexMatrix inverse (MatrixType &mattype) const;
   FloatComplexMatrix inverse (MatrixType &mattype, octave_idx_type& info) const;
   FloatComplexMatrix inverse (MatrixType &mattype, octave_idx_type& info,
-                         float& rcon, int force = 0,
-                         int calc_cond = 1) const;
+                              float& rcon, int force = 0,
+                              int calc_cond = 1) const;
 
   FloatComplexMatrix pseudo_inverse (float tol = 0.0) const;
 
   FloatComplexMatrix fourier (void) const;
   FloatComplexMatrix ifourier (void) const;
 
   FloatComplexMatrix fourier2d (void) const;
   FloatComplexMatrix ifourier2d (void) const;
 
   FloatComplexDET determinant (void) const;
   FloatComplexDET determinant (octave_idx_type& info) const;
-  FloatComplexDET determinant (octave_idx_type& info, float& rcon, int calc_cond = 1) const;
+  FloatComplexDET determinant (octave_idx_type& info, float& rcon,
+                               int calc_cond = 1) const;
   FloatComplexDET determinant (MatrixType &mattype, octave_idx_type& info,
                                float& rcon, int calc_cond = 1) const;
 
   float rcond (void) const;
   float rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
   FloatComplexMatrix utsolve (MatrixType &typ, const FloatComplexMatrix& b,
-                  octave_idx_type& info, float& rcon,
-                  solve_singularity_handler sing_handler,
-                  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
+                              octave_idx_type& info, float& rcon,
+                              solve_singularity_handler sing_handler,
+                              bool calc_cond = false,
+                              blas_trans_type transt = blas_no_trans) const;
 
   // Lower triangular matrix solvers
   FloatComplexMatrix ltsolve (MatrixType &typ, const FloatComplexMatrix& b,
-                  octave_idx_type& info, float& rcon,
-                  solve_singularity_handler sing_handler,
-                  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
+                              octave_idx_type& info, float& rcon,
+                              solve_singularity_handler sing_handler,
+                              bool calc_cond = false,
+                              blas_trans_type transt = blas_no_trans) const;
 
   // Full matrix solvers (umfpack/cholesky)
   FloatComplexMatrix fsolve (MatrixType &typ, const FloatComplexMatrix& b,
-                 octave_idx_type& info, float& rcon,
-                 solve_singularity_handler sing_handler,
-                 bool calc_cond = false) const;
+                             octave_idx_type& info, float& rcon,
+                             solve_singularity_handler sing_handler,
+                             bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b,
-                       octave_idx_type& info) const;
+                            octave_idx_type& info) const;
+  FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b,
+                            octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b,
-                       octave_idx_type& info, float& rcon) const;
-  FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-                       float& rcon, solve_singularity_handler sing_handler,
-                       bool singular_fallback = true,
-                       blas_trans_type transt = blas_no_trans) const;
+                            octave_idx_type& info,
+                            float& rcon, solve_singularity_handler sing_handler,
+                            bool singular_fallback = true,
+                            blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b,
-                       octave_idx_type& info) const;
+                            octave_idx_type& info) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b,
-                       octave_idx_type& info, float& rcon) const;
+                            octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b,
-                       octave_idx_type& info, float& rcon,
-                       solve_singularity_handler sing_handler,
-                       bool singular_fallback = true,
-                       blas_trans_type transt = blas_no_trans) const;
-
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
-                             octave_idx_type& info) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
-                             octave_idx_type& info, float& rcon) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
-                             octave_idx_type& info, float& rcon,
-                             solve_singularity_handler sing_handler,
-                             blas_trans_type transt = blas_no_trans) const;
+                            octave_idx_type& info, float& rcon,
+                            solve_singularity_handler sing_handler,
+                            bool singular_fallback = true,
+                            blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (MatrixType &typ,
-                             const FloatComplexColumnVector& b) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b,
-                             octave_idx_type& info) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b,
-                             octave_idx_type& info, float& rcon) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b,
-                             octave_idx_type& info, float& rcon,
-                             solve_singularity_handler sing_handler,
-                             blas_trans_type transt = blas_no_trans) const;
+                                  const FloatColumnVector& b) const;
+  FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
+                                  octave_idx_type& info) const;
+  FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
+                                  octave_idx_type& info, float& rcon) const;
+  FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
+                                  octave_idx_type& info, float& rcon,
+                                  solve_singularity_handler sing_handler,
+                                  blas_trans_type transt = blas_no_trans) const;
+
+  FloatComplexColumnVector solve (MatrixType &typ,
+                                  const FloatComplexColumnVector& b) const;
+  FloatComplexColumnVector solve (MatrixType &typ,
+                                  const FloatComplexColumnVector& b,
+                                  octave_idx_type& info) const;
+  FloatComplexColumnVector solve (MatrixType &typ,
+                                  const FloatComplexColumnVector& b,
+                                  octave_idx_type& info, float& rcon) const;
+  FloatComplexColumnVector solve (MatrixType &typ,
+                                  const FloatComplexColumnVector& b,
+                                  octave_idx_type& info, float& rcon,
+                                  solve_singularity_handler sing_handler,
+                                  blas_trans_type transt = blas_no_trans) const;
 
   // Generic interface to solver with probing of type
   FloatComplexMatrix solve (const FloatMatrix& b) const;
   FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info) const;
-  FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon) const;
-  FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon,
-                       solve_singularity_handler sing_handler,
-                       blas_trans_type transt = blas_no_trans) const;
+  FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info,
+                            float& rcon) const;
+  FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info,
+                            float& rcon,
+                            solve_singularity_handler sing_handler,
+                            blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexMatrix solve (const FloatComplexMatrix& b) const;
-  FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info) const;
-  FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon) const;
-  FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon,
-                       solve_singularity_handler sing_handler,
-                       blas_trans_type transt = blas_no_trans) const;
+  FloatComplexMatrix solve (const FloatComplexMatrix& b,
+                            octave_idx_type& info) const;
+  FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info,
+                            float& rcon) const;
+  FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info,
+                            float& rcon,
+                            solve_singularity_handler sing_handler,
+                            blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (const FloatColumnVector& b) const;
-  FloatComplexColumnVector solve (const FloatColumnVector& b, octave_idx_type& info) const;
-  FloatComplexColumnVector solve (const FloatColumnVector& b, octave_idx_type& info,
-                             float& rcon) const;
-  FloatComplexColumnVector solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon,
-                             solve_singularity_handler sing_handler,
-                             blas_trans_type transt = blas_no_trans) const;
+  FloatComplexColumnVector solve (const FloatColumnVector& b,
+                                  octave_idx_type& info) const;
+  FloatComplexColumnVector solve (const FloatColumnVector& b,
+                                  octave_idx_type& info,
+                                  float& rcon) const;
+  FloatComplexColumnVector solve (const FloatColumnVector& b,
+                                  octave_idx_type& info, float& rcon,
+                                  solve_singularity_handler sing_handler,
+                                  blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b) const;
-  FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info) const;
-  FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info,
-                             float& rcon) const;
-  FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info,
-                             float& rcon,
-                             solve_singularity_handler sing_handler,
-                             blas_trans_type transt = blas_no_trans) const;
+  FloatComplexColumnVector solve (const FloatComplexColumnVector& b,
+                                  octave_idx_type& info) const;
+  FloatComplexColumnVector solve (const FloatComplexColumnVector& b,
+                                  octave_idx_type& info,
+                                  float& rcon) const;
+  FloatComplexColumnVector solve (const FloatComplexColumnVector& b,
+                                  octave_idx_type& info,
+                                  float& rcon,
+                                  solve_singularity_handler sing_handler,
+                                  blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexMatrix lssolve (const FloatMatrix& b) const;
-  FloatComplexMatrix lssolve (const FloatMatrix& b, octave_idx_type& info) const;
+  FloatComplexMatrix lssolve (const FloatMatrix& b,
+                              octave_idx_type& info) const;
   FloatComplexMatrix lssolve (const FloatMatrix& b, octave_idx_type& info,
-                         octave_idx_type& rank) const;
+                              octave_idx_type& rank) const;
   FloatComplexMatrix lssolve (const FloatMatrix& b, octave_idx_type& info,
-                         octave_idx_type& rank, float& rcon) const;
+                              octave_idx_type& rank, float& rcon) const;
 
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b) const;
-  FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info) const;
-  FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
-                         octave_idx_type& rank) const;
-  FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
-                         octave_idx_type& rank, float& rcon) const;
+  FloatComplexMatrix lssolve (const FloatComplexMatrix& b,
+                              octave_idx_type& info) const;
+  FloatComplexMatrix lssolve (const FloatComplexMatrix& b,
+                              octave_idx_type& info, octave_idx_type& rank) const;
+  FloatComplexMatrix lssolve (const FloatComplexMatrix& b,
+                              octave_idx_type& info, octave_idx_type& rank, float& rcon) const;
 
   FloatComplexColumnVector lssolve (const FloatColumnVector& b) const;
   FloatComplexColumnVector lssolve (const FloatColumnVector& b,
-                               octave_idx_type& info) const;
-  FloatComplexColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info,
-                               octave_idx_type& rank) const;
-  FloatComplexColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info,
-                               octave_idx_type& rank, float& rcon) const;
+                                    octave_idx_type& info) const;
+  FloatComplexColumnVector lssolve (const FloatColumnVector& b,
+                                    octave_idx_type& info,
+                                    octave_idx_type& rank) const;
+  FloatComplexColumnVector lssolve (const FloatColumnVector& b,
+                                    octave_idx_type& info,
+                                    octave_idx_type& rank, float& rcon) const;
 
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b) const;
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b,
-                               octave_idx_type& info) const;
+                                    octave_idx_type& info) const;
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b,
-                               octave_idx_type& info,
-                               octave_idx_type& rank) const;
+                                    octave_idx_type& info,
+                                    octave_idx_type& rank) const;
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b,
-                               octave_idx_type& info,
-                               octave_idx_type& rank, float& rcon) const;
+                                    octave_idx_type& info,
+                                    octave_idx_type& rank, float& rcon) const;
 
   // matrix by diagonal matrix -> matrix operations
 
   FloatComplexMatrix& operator += (const FloatDiagMatrix& a);
   FloatComplexMatrix& operator -= (const FloatDiagMatrix& a);
 
   FloatComplexMatrix& operator += (const FloatComplexDiagMatrix& a);
   FloatComplexMatrix& operator -= (const FloatComplexDiagMatrix& a);
@@ -376,18 +412,20 @@ public:
   FloatComplexRowVector column_min (void) const;
   FloatComplexRowVector column_max (void) const;
 
   FloatComplexRowVector column_min (Array<octave_idx_type>& index) const;
   FloatComplexRowVector column_max (Array<octave_idx_type>& index) const;
 
   // i/o
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatComplexMatrix& a);
-  friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatComplexMatrix& a);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const FloatComplexMatrix& a);
+  friend OCTAVE_API std::istream& operator >> (std::istream& is,
+                                               FloatComplexMatrix& a);
 };
 
 extern OCTAVE_API FloatComplexMatrix conj (const FloatComplexMatrix& a);
 
 // column vector by row vector -> matrix operations
 
 extern OCTAVE_API FloatComplexMatrix
 operator * (const FloatColumnVector& a, const FloatComplexRowVector& b);
@@ -397,38 +435,49 @@ operator * (const FloatComplexColumnVect
 
 extern OCTAVE_API FloatComplexMatrix
 operator * (const FloatComplexColumnVector& a, const FloatComplexRowVector& b);
 
 extern OCTAVE_API FloatComplexMatrix
 Givens (const FloatComplex&, const FloatComplex&);
 
 extern OCTAVE_API FloatComplexMatrix
-Sylvester (const FloatComplexMatrix&, const FloatComplexMatrix&, const FloatComplexMatrix&);
+Sylvester (const FloatComplexMatrix&, const FloatComplexMatrix&,
+           const FloatComplexMatrix&);
 
 extern OCTAVE_API FloatComplexMatrix
 xgemm (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
        blas_trans_type transa = blas_no_trans,
        blas_trans_type transb = blas_no_trans);
 
-extern OCTAVE_API FloatComplexMatrix operator * (const FloatMatrix&,        const FloatComplexMatrix&);
-extern OCTAVE_API FloatComplexMatrix operator * (const FloatComplexMatrix&, const FloatMatrix&);
-extern OCTAVE_API FloatComplexMatrix operator * (const FloatComplexMatrix&, const FloatComplexMatrix&);
-
-extern OCTAVE_API FloatComplexMatrix min (const FloatComplex& c, const FloatComplexMatrix& m);
-extern OCTAVE_API FloatComplexMatrix min (const FloatComplexMatrix& m, const FloatComplex& c);
-extern OCTAVE_API FloatComplexMatrix min (const FloatComplexMatrix& a, const FloatComplexMatrix& b);
+extern OCTAVE_API FloatComplexMatrix operator * (const FloatMatrix&,
+                                                 const FloatComplexMatrix&);
+extern OCTAVE_API FloatComplexMatrix operator * (const FloatComplexMatrix&,
+                                                 const FloatMatrix&);
+extern OCTAVE_API FloatComplexMatrix operator * (const FloatComplexMatrix&,
+                                                 const FloatComplexMatrix&);
 
-extern OCTAVE_API FloatComplexMatrix max (const FloatComplex& c, const FloatComplexMatrix& m);
-extern OCTAVE_API FloatComplexMatrix max (const FloatComplexMatrix& m, const FloatComplex& c);
-extern OCTAVE_API FloatComplexMatrix max (const FloatComplexMatrix& a, const FloatComplexMatrix& b);
+extern OCTAVE_API FloatComplexMatrix min (const FloatComplex& c,
+                                          const FloatComplexMatrix& m);
+extern OCTAVE_API FloatComplexMatrix min (const FloatComplexMatrix& m,
+                                          const FloatComplex& c);
+extern OCTAVE_API FloatComplexMatrix min (const FloatComplexMatrix& a,
+                                          const FloatComplexMatrix& b);
 
-extern OCTAVE_API FloatComplexMatrix linspace (const FloatComplexColumnVector& x1,
-                                               const FloatComplexColumnVector& x2,
-                                               octave_idx_type n);
+extern OCTAVE_API FloatComplexMatrix max (const FloatComplex& c,
+                                          const FloatComplexMatrix& m);
+extern OCTAVE_API FloatComplexMatrix max (const FloatComplexMatrix& m,
+                                          const FloatComplex& c);
+extern OCTAVE_API FloatComplexMatrix max (const FloatComplexMatrix& a,
+                                          const FloatComplexMatrix& b);
+
+extern OCTAVE_API FloatComplexMatrix
+linspace (const FloatComplexColumnVector& x1,
+          const FloatComplexColumnVector& x2,
+          octave_idx_type n);
 
 MS_CMP_OP_DECLS (FloatComplexMatrix, FloatComplex, OCTAVE_API)
 MS_BOOL_OP_DECLS (FloatComplexMatrix, FloatComplex, OCTAVE_API)
 
 SM_CMP_OP_DECLS (FloatComplex, FloatComplexMatrix, OCTAVE_API)
 SM_BOOL_OP_DECLS (FloatComplex, FloatComplexMatrix, OCTAVE_API)
 
 MM_CMP_OP_DECLS (FloatComplexMatrix, FloatComplexMatrix, OCTAVE_API)
diff --git a/liboctave/array/fCNDArray.cc b/liboctave/array/fCNDArray.cc
--- a/liboctave/array/fCNDArray.cc
+++ b/liboctave/array/fCNDArray.cc
@@ -106,17 +106,17 @@ FloatComplexNDArray::ifourier (int dim) 
 
   const FloatComplex *in (fortran_vec ());
   FloatComplexNDArray retval (dv);
   FloatComplex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
     octave_fftw::ifft (in + k * stride * n, out + k * stride * n,
-                      n, howmany, stride, dist);
+                       n, howmany, stride, dist);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::fourier2d (void) const
 {
   dim_vector dv = dims ();
@@ -285,17 +285,17 @@ FloatComplexNDArray::ifourier (int dim) 
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (cfftb, CFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i] /
-              static_cast<float> (npts);
+                                                   static_cast<float> (npts);
         }
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::fourier2d (void) const
@@ -378,18 +378,18 @@ FloatComplexNDArray::ifourier2d (void) c
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
                 prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) = prow[l] /
-                  static_cast<float> (npts);
+                retval((l + k*npts)*stride + j*dist) =
+                  prow[l] / static_cast<float> (npts);
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
@@ -473,18 +473,18 @@ FloatComplexNDArray::ifourierNd (void) c
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
                 prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) = prow[l] /
-                  static_cast<float> (npts);
+                retval((l + k*npts)*stride + j*dist) =
+                  prow[l] / static_cast<float> (npts);
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
 }
@@ -497,17 +497,17 @@ boolNDArray
 FloatComplexNDArray::operator ! (void) const
 {
   if (any_element_is_nan ())
     gripe_nan_to_logical_conversion ();
 
   return do_mx_unary_op<bool, FloatComplex> (*this, mx_inline_not);
 }
 
-// FIXME -- this is not quite the right thing.
+// FIXME: this is not quite the right thing.
 
 bool
 FloatComplexNDArray::any_element_is_nan (void) const
 {
   return do_mx_check<FloatComplex> (*this, mx_inline_any_nan);
 }
 
 bool
@@ -594,23 +594,25 @@ boolNDArray
 FloatComplexNDArray::any (int dim) const
 {
   return do_mx_red_op<bool, FloatComplex> (*this, dim, mx_inline_any);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::cumprod (int dim) const
 {
-  return do_mx_cum_op<FloatComplex, FloatComplex> (*this, dim, mx_inline_cumprod);
+  return do_mx_cum_op<FloatComplex, FloatComplex> (*this, dim,
+                                                   mx_inline_cumprod);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::cumsum (int dim) const
 {
-  return do_mx_cum_op<FloatComplex, FloatComplex> (*this, dim, mx_inline_cumsum);
+  return do_mx_cum_op<FloatComplex, FloatComplex> (*this, dim,
+                                                   mx_inline_cumsum);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::prod (int dim) const
 {
   return do_mx_red_op<FloatComplex, FloatComplex> (*this, dim, mx_inline_prod);
 }
 
@@ -634,42 +636,46 @@ FloatComplexNDArray::sumsq (int dim) con
 
 FloatComplexNDArray
 FloatComplexNDArray::diff (octave_idx_type order, int dim) const
 {
   return do_mx_diff_op<FloatComplex> (*this, dim, order, mx_inline_diff);
 }
 
 FloatComplexNDArray
-FloatComplexNDArray::concat (const FloatComplexNDArray& rb, const Array<octave_idx_type>& ra_idx)
+FloatComplexNDArray::concat (const FloatComplexNDArray& rb,
+                             const Array<octave_idx_type>& ra_idx)
 {
   if (rb.numel () > 0)
     insert (rb, ra_idx);
   return *this;
 }
 
 FloatComplexNDArray
-FloatComplexNDArray::concat (const FloatNDArray& rb, const Array<octave_idx_type>& ra_idx)
+FloatComplexNDArray::concat (const FloatNDArray& rb,
+                             const Array<octave_idx_type>& ra_idx)
 {
   FloatComplexNDArray tmp (rb);
   if (rb.numel () > 0)
     insert (tmp, ra_idx);
   return *this;
 }
 
 FloatComplexNDArray
-concat (NDArray& ra, FloatComplexNDArray& rb, const Array<octave_idx_type>& ra_idx)
+concat (NDArray& ra, FloatComplexNDArray& rb,
+        const Array<octave_idx_type>& ra_idx)
 {
   FloatComplexNDArray retval (ra);
   if (rb.numel () > 0)
     retval.insert (rb, ra_idx);
   return retval;
 }
 
-static const FloatComplex FloatComplex_NaN_result (octave_Float_NaN, octave_Float_NaN);
+static const FloatComplex FloatComplex_NaN_result (octave_Float_NaN,
+                                                   octave_Float_NaN);
 
 FloatComplexNDArray
 FloatComplexNDArray::max (int dim) const
 {
   return do_mx_minmax_op<FloatComplex> (*this, dim, mx_inline_max);
 }
 
 FloatComplexNDArray
@@ -694,29 +700,31 @@ FloatComplexNDArray
 FloatComplexNDArray::cummax (int dim) const
 {
   return do_mx_cumminmax_op<FloatComplex> (*this, dim, mx_inline_cummax);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::cummax (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_cumminmax_op<FloatComplex> (*this, idx_arg, dim, mx_inline_cummax);
+  return do_mx_cumminmax_op<FloatComplex> (*this, idx_arg, dim,
+                                           mx_inline_cummax);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::cummin (int dim) const
 {
   return do_mx_cumminmax_op<FloatComplex> (*this, dim, mx_inline_cummin);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::cummin (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_cumminmax_op<FloatComplex> (*this, idx_arg, dim, mx_inline_cummin);
+  return do_mx_cumminmax_op<FloatComplex> (*this, idx_arg, dim,
+                                           mx_inline_cummin);
 }
 
 FloatNDArray
 FloatComplexNDArray::abs (void) const
 {
   return do_mx_unary_map<float, FloatComplex, std::abs> (*this);
 }
 
@@ -740,17 +748,18 @@ FloatComplexNDArray::isfinite (void) con
 
 FloatComplexNDArray
 conj (const FloatComplexNDArray& a)
 {
   return do_mx_unary_map<FloatComplex, FloatComplex, std::conj<float> > (a);
 }
 
 FloatComplexNDArray&
-FloatComplexNDArray::insert (const NDArray& a, octave_idx_type r, octave_idx_type c)
+FloatComplexNDArray::insert (const NDArray& a,
+                             octave_idx_type r, octave_idx_type c)
 {
   dim_vector a_dv = a.dims ();
 
   int n = a_dv.length ();
 
   if (n == dimensions.length ())
     {
       Array<octave_idx_type> a_ra_idx (dim_vector (a_dv.length (), 1), 0);
@@ -790,54 +799,56 @@ FloatComplexNDArray::insert (const NDArr
   else
     (*current_liboctave_error_handler)
       ("Array<T>::insert: invalid indexing operation");
 
   return *this;
 }
 
 FloatComplexNDArray&
-FloatComplexNDArray::insert (const FloatComplexNDArray& a, octave_idx_type r, octave_idx_type c)
+FloatComplexNDArray::insert (const FloatComplexNDArray& a,
+                             octave_idx_type r, octave_idx_type c)
 {
   Array<FloatComplex>::insert (a, r, c);
   return *this;
 }
 
 FloatComplexNDArray&
-FloatComplexNDArray::insert (const FloatComplexNDArray& a, const Array<octave_idx_type>& ra_idx)
+FloatComplexNDArray::insert (const FloatComplexNDArray& a,
+                             const Array<octave_idx_type>& ra_idx)
 {
   Array<FloatComplex>::insert (a, ra_idx);
   return *this;
 }
 
 FloatComplexMatrix
 FloatComplexNDArray::matrix_value (void) const
 {
   FloatComplexMatrix retval;
 
   if (ndims () == 2)
-      retval = FloatComplexMatrix (Array<FloatComplex> (*this));
+    retval = FloatComplexMatrix (Array<FloatComplex> (*this));
   else
     (*current_liboctave_error_handler)
       ("invalid conversion of FloatComplexNDArray to FloatComplexMatrix");
 
   return retval;
 }
 
 void
 FloatComplexNDArray::increment_index (Array<octave_idx_type>& ra_idx,
-                                 const dim_vector& dimensions,
-                                 int start_dimension)
+                                      const dim_vector& dimensions,
+                                      int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
 octave_idx_type
 FloatComplexNDArray::compute_index (Array<octave_idx_type>& ra_idx,
-                               const dim_vector& dimensions)
+                                    const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::diag (octave_idx_type k) const
 {
   return MArray<FloatComplex>::diag (k);
@@ -868,26 +879,26 @@ std::istream&
 operator >> (std::istream& is, FloatComplexNDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
   if (nel > 0)
     {
       FloatComplex tmp;
       for (octave_idx_type i = 0; i < nel; i++)
-          {
-            tmp = octave_read_value<FloatComplex> (is);
-            if (is)
-              a.elem (i) = tmp;
-            else
-              goto done;
-          }
+        {
+          tmp = octave_read_value<FloatComplex> (is);
+          if (is)
+            a.elem (i) = tmp;
+          else
+            goto done;
+        }
     }
 
- done:
+done:
 
   return is;
 }
 
 MINMAX_FCNS (FloatComplexNDArray, FloatComplex)
 
 NDS_CMP_OPS (FloatComplexNDArray, FloatComplex)
 NDS_BOOL_OPS (FloatComplexNDArray, FloatComplex)
diff --git a/liboctave/array/fCNDArray.h b/liboctave/array/fCNDArray.h
--- a/liboctave/array/fCNDArray.h
+++ b/liboctave/array/fCNDArray.h
@@ -40,73 +40,82 @@ public:
 
   FloatComplexNDArray (void) : MArray<FloatComplex> () { }
 
   FloatComplexNDArray (const dim_vector& dv) : MArray<FloatComplex> (dv) { }
 
   FloatComplexNDArray (const dim_vector& dv, const FloatComplex& val)
     : MArray<FloatComplex> (dv, val) { }
 
-  FloatComplexNDArray (const FloatComplexNDArray& a) : MArray<FloatComplex> (a) { }
+  FloatComplexNDArray (const FloatComplexNDArray& a)
+    : MArray<FloatComplex> (a) { }
 
-  FloatComplexNDArray (const FloatComplexMatrix& a) : MArray<FloatComplex> (a) { }
+  FloatComplexNDArray (const FloatComplexMatrix& a)
+    : MArray<FloatComplex> (a) { }
 
   template <class U>
   FloatComplexNDArray (const MArray<U>& a) : MArray<FloatComplex> (a) { }
 
   template <class U>
   FloatComplexNDArray (const Array<U>& a) : MArray<FloatComplex> (a) { }
 
   FloatComplexNDArray (const charNDArray&);
 
   FloatComplexNDArray& operator = (const FloatComplexNDArray& a)
-    {
-      MArray<FloatComplex>::operator = (a);
-      return *this;
-    }
+  {
+    MArray<FloatComplex>::operator = (a);
+    return *this;
+  }
 
   // unary operations
 
   boolNDArray operator ! (void) const;
 
-  // FIXME -- this is not quite the right thing.
+  // FIXME: this is not quite the right thing.
 
   bool any_element_is_nan (void) const;
   bool any_element_is_inf_or_nan (void) const;
   bool all_elements_are_real (void) const;
   bool all_integers (float& max_val, float& min_val) const;
   bool too_large_for_float (void) const;
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
   FloatComplexNDArray cumprod (int dim = -1) const;
   FloatComplexNDArray cumsum (int dim = -1) const;
   FloatComplexNDArray prod (int dim = -1) const;
   FloatComplexNDArray sum (int dim = -1) const;
-       ComplexNDArray dsum (int dim = -1) const;
+  ComplexNDArray dsum (int dim = -1) const;
   FloatComplexNDArray sumsq (int dim = -1) const;
-  FloatComplexNDArray concat (const FloatComplexNDArray& rb, const Array<octave_idx_type>& ra_idx);
-  FloatComplexNDArray concat (const FloatNDArray& rb, const Array<octave_idx_type>& ra_idx);
+  FloatComplexNDArray concat (const FloatComplexNDArray& rb,
+                              const Array<octave_idx_type>& ra_idx);
+  FloatComplexNDArray concat (const FloatNDArray& rb,
+                              const Array<octave_idx_type>& ra_idx);
 
   FloatComplexNDArray max (int dim = -1) const;
   FloatComplexNDArray max (Array<octave_idx_type>& index, int dim = -1) const;
   FloatComplexNDArray min (int dim = -1) const;
   FloatComplexNDArray min (Array<octave_idx_type>& index, int dim = -1) const;
 
   FloatComplexNDArray cummax (int dim = -1) const;
-  FloatComplexNDArray cummax (Array<octave_idx_type>& index, int dim = -1) const;
+  FloatComplexNDArray cummax (Array<octave_idx_type>& index,
+                              int dim = -1) const;
   FloatComplexNDArray cummin (int dim = -1) const;
-  FloatComplexNDArray cummin (Array<octave_idx_type>& index, int dim = -1) const;
+  FloatComplexNDArray cummin (Array<octave_idx_type>& index,
+                              int dim = -1) const;
 
   FloatComplexNDArray diff (octave_idx_type order = 1, int dim = -1) const;
 
-  FloatComplexNDArray& insert (const NDArray& a, octave_idx_type r, octave_idx_type c);
-  FloatComplexNDArray& insert (const FloatComplexNDArray& a, octave_idx_type r, octave_idx_type c);
-  FloatComplexNDArray& insert (const FloatComplexNDArray& a, const Array<octave_idx_type>& ra_idx);
+  FloatComplexNDArray& insert (const NDArray& a,
+                               octave_idx_type r, octave_idx_type c);
+  FloatComplexNDArray& insert (const FloatComplexNDArray& a,
+                               octave_idx_type r, octave_idx_type c);
+  FloatComplexNDArray& insert (const FloatComplexNDArray& a,
+                               const Array<octave_idx_type>& ra_idx);
 
   FloatNDArray abs (void) const;
   boolNDArray isnan (void) const;
   boolNDArray isinf (void) const;
   boolNDArray isfinite (void) const;
 
   friend OCTAVE_API FloatComplexNDArray conj (const FloatComplexNDArray& a);
 
@@ -116,42 +125,45 @@ public:
   FloatComplexNDArray fourier2d (void) const;
   FloatComplexNDArray ifourier2d (void) const;
 
   FloatComplexNDArray fourierNd (void) const;
   FloatComplexNDArray ifourierNd (void) const;
 
   FloatComplexMatrix matrix_value (void) const;
 
-  FloatComplexNDArray squeeze (void) const { return MArray<FloatComplex>::squeeze (); }
+  FloatComplexNDArray squeeze (void) const
+  { return MArray<FloatComplex>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
-                            const dim_vector& dimensions);
+                                        const dim_vector& dimensions);
 
   // i/o
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatComplexNDArray& a);
-  friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatComplexNDArray& a);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const FloatComplexNDArray& a);
+  friend OCTAVE_API std::istream& operator >> (std::istream& is,
+                                               FloatComplexNDArray& a);
 
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (float& max_val, float& min_val) const;
 
   FloatComplexNDArray diag (octave_idx_type k = 0) const;
 
   FloatComplexNDArray diag (octave_idx_type m, octave_idx_type n) const;
 
   FloatComplexNDArray& changesign (void)
-    {
-      MArray<FloatComplex>::changesign ();
-      return *this;
-    }
+  {
+    MArray<FloatComplex>::changesign ();
+    return *this;
+  }
 
 };
 
 extern OCTAVE_API FloatComplexNDArray conj (const FloatComplexNDArray& a);
 
 MINMAX_DECLS (FloatComplexNDArray, FloatComplex, OCTAVE_API)
 
 NDS_CMP_OP_DECLS (FloatComplexNDArray, FloatComplex, OCTAVE_API)
@@ -160,17 +172,19 @@ NDS_BOOL_OP_DECLS (FloatComplexNDArray, 
 SND_CMP_OP_DECLS (FloatComplex, FloatComplexNDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (FloatComplex, FloatComplexNDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (FloatComplexNDArray, FloatComplexNDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (FloatComplexNDArray, FloatComplexNDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArray, FloatComplexNDArray, FloatComplex)
 
-extern OCTAVE_API FloatComplexNDArray& operator *= (FloatComplexNDArray& a, float s);
-extern OCTAVE_API FloatComplexNDArray& operator /= (FloatComplexNDArray& a, float s);
+extern OCTAVE_API FloatComplexNDArray& operator *= (FloatComplexNDArray& a,
+                                                    float s);
+extern OCTAVE_API FloatComplexNDArray& operator /= (FloatComplexNDArray& a,
+                                                    float s);
 
 BSXFUN_STDOP_DECLS (FloatComplexNDArray, OCTAVE_API)
 BSXFUN_STDREL_DECLS (FloatComplexNDArray, OCTAVE_API)
 
 BSXFUN_OP_DECL (pow, FloatComplexNDArray, OCTAVE_API)
 
 #endif
diff --git a/liboctave/array/fCRowVector.cc b/liboctave/array/fCRowVector.cc
--- a/liboctave/array/fCRowVector.cc
+++ b/liboctave/array/fCRowVector.cc
@@ -91,17 +91,18 @@ FloatComplexRowVector::insert (const Flo
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (c+i) = a.elem (i);
     }
 
   return *this;
 }
 
 FloatComplexRowVector&
-FloatComplexRowVector::insert (const FloatComplexRowVector& a, octave_idx_type c)
+FloatComplexRowVector::insert (const FloatComplexRowVector& a,
+                               octave_idx_type c)
 {
   octave_idx_type a_len = a.length ();
 
   if (c < 0 || c + a_len > length ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
@@ -169,17 +170,18 @@ FloatComplexRowVector::fill (float val, 
       for (octave_idx_type i = c1; i <= c2; i++)
         xelem (i) = val;
     }
 
   return *this;
 }
 
 FloatComplexRowVector&
-FloatComplexRowVector::fill (const FloatComplex& val, octave_idx_type c1, octave_idx_type c2)
+FloatComplexRowVector::fill (const FloatComplex& val,
+                             octave_idx_type c1, octave_idx_type c2)
 {
   octave_idx_type len = length ();
 
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
     {
       (*current_liboctave_error_handler) ("range error for fill");
       return *this;
     }
@@ -278,17 +280,17 @@ FloatComplexRowVector::operator += (cons
     {
       gripe_nonconformant ("operator +=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
-  FloatComplex *d = fortran_vec (); // Ensures only one reference to my privates!
+  FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_add2 (len, d, a.data ());
   return *this;
 }
 
 FloatComplexRowVector&
 FloatComplexRowVector::operator -= (const FloatRowVector& a)
 {
@@ -300,17 +302,17 @@ FloatComplexRowVector::operator -= (cons
     {
       gripe_nonconformant ("operator -=", len, a_len);
       return *this;
     }
 
   if (len == 0)
     return *this;
 
-  FloatComplex *d = fortran_vec (); // Ensures only one reference to my privates!
+  FloatComplex *d = fortran_vec (); // Ensures only 1 reference to my privates!
 
   mx_inline_sub2 (len, d, a.data ());
   return *this;
 }
 
 // row vector by matrix -> row vector
 
 FloatComplexRowVector
diff --git a/liboctave/array/fCRowVector.h b/liboctave/array/fCRowVector.h
--- a/liboctave/array/fCRowVector.h
+++ b/liboctave/array/fCRowVector.h
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include "fRowVector.h"
 
 #include "mx-defs.h"
 
 class
 OCTAVE_API
 FloatComplexRowVector : public MArray<FloatComplex>
 {
-friend class FloatComplexColumnVector;
+  friend class FloatComplexColumnVector;
 
 public:
 
   FloatComplexRowVector (void)
     : MArray<FloatComplex> (dim_vector (1, 0)) { }
 
   explicit FloatComplexRowVector (octave_idx_type n)
     : MArray<FloatComplex> (dim_vector (1, n)) { }
@@ -56,33 +56,36 @@ public:
 
   FloatComplexRowVector (const Array<FloatComplex>& a)
     : MArray<FloatComplex> (a.as_row ()) { }
 
   explicit FloatComplexRowVector (const FloatRowVector& a)
     : MArray<FloatComplex> (a) { }
 
   FloatComplexRowVector& operator = (const FloatComplexRowVector& a)
-    {
-      MArray<FloatComplex>::operator = (a);
-      return *this;
-    }
+  {
+    MArray<FloatComplex>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const FloatComplexRowVector& a) const;
   bool operator != (const FloatComplexRowVector& a) const;
 
   // destructive insert/delete/reorder operations
 
   FloatComplexRowVector& insert (const FloatRowVector& a, octave_idx_type c);
-  FloatComplexRowVector& insert (const FloatComplexRowVector& a, octave_idx_type c);
+  FloatComplexRowVector& insert (const FloatComplexRowVector& a,
+                                 octave_idx_type c);
 
   FloatComplexRowVector& fill (float val);
   FloatComplexRowVector& fill (const FloatComplex& val);
-  FloatComplexRowVector& fill (float val, octave_idx_type c1, octave_idx_type c2);
-  FloatComplexRowVector& fill (const FloatComplex& val, octave_idx_type c1, octave_idx_type c2);
+  FloatComplexRowVector& fill (float val,
+                               octave_idx_type c1, octave_idx_type c2);
+  FloatComplexRowVector& fill (const FloatComplex& val,
+                               octave_idx_type c1, octave_idx_type c2);
 
   FloatComplexRowVector append (const FloatRowVector& a) const;
   FloatComplexRowVector append (const FloatComplexRowVector& a) const;
 
   FloatComplexColumnVector hermitian (void) const;
   FloatComplexColumnVector transpose (void) const;
 
   friend FloatComplexRowVector conj (const FloatComplexRowVector& a);
@@ -96,46 +99,51 @@ public:
   // row vector by row vector -> row vector operations
 
   FloatComplexRowVector& operator += (const FloatRowVector& a);
   FloatComplexRowVector& operator -= (const FloatRowVector& a);
 
   // row vector by matrix -> row vector
 
   friend FloatComplexRowVector operator * (const FloatComplexRowVector& a,
-                                      const FloatComplexMatrix& b);
+      const FloatComplexMatrix& b);
 
   friend FloatComplexRowVector operator * (const FloatRowVector& a,
-                                      const FloatComplexMatrix& b);
+      const FloatComplexMatrix& b);
 
   // other operations
 
   FloatComplex min (void) const;
   FloatComplex max (void) const;
 
   // i/o
 
-  friend std::ostream& operator << (std::ostream& os, const FloatComplexRowVector& a);
-  friend std::istream& operator >> (std::istream& is, FloatComplexRowVector& a);
+  friend std::ostream& operator << (std::ostream& os,
+                                    const FloatComplexRowVector& a);
+  friend std::istream& operator >> (std::istream& is,
+                                    FloatComplexRowVector& a);
 
   void resize (octave_idx_type n, const FloatComplex& rfv = FloatComplex (0))
   {
     Array<FloatComplex>::resize (dim_vector (1, n), rfv);
   }
 
   void clear (octave_idx_type n)
-    { Array<FloatComplex>::clear (1, n); }
+  { Array<FloatComplex>::clear (1, n); }
 
 };
 
 // row vector by column vector -> scalar
 
-FloatComplex OCTAVE_API operator * (const FloatComplexRowVector& a, const ColumnVector& b);
+FloatComplex OCTAVE_API operator * (const FloatComplexRowVector& a,
+                                    const ColumnVector& b);
 
-FloatComplex OCTAVE_API operator * (const FloatComplexRowVector& a, const FloatComplexColumnVector& b);
+FloatComplex OCTAVE_API operator * (const FloatComplexRowVector& a,
+                                    const FloatComplexColumnVector& b);
 
 // other operations
 
-OCTAVE_API FloatComplexRowVector linspace (const FloatComplex& x1, const FloatComplex& x2, octave_idx_type n);
+OCTAVE_API FloatComplexRowVector linspace (const FloatComplex& x1,
+    const FloatComplex& x2, octave_idx_type n);
 
 MARRAY_FORWARD_DEFS (MArray, FloatComplexRowVector, FloatComplex)
 
 #endif
diff --git a/liboctave/array/fColVector.h b/liboctave/array/fColVector.h
--- a/liboctave/array/fColVector.h
+++ b/liboctave/array/fColVector.h
@@ -49,20 +49,20 @@ public:
 
   FloatColumnVector (const MArray<float>& a)
     : MArray<float> (a.as_column ()) { }
 
   FloatColumnVector (const Array<float>& a)
     : MArray<float> (a.as_column ()) { }
 
   FloatColumnVector& operator = (const FloatColumnVector& a)
-    {
-      MArray<float>::operator = (a);
-      return *this;
-    }
+  {
+    MArray<float>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const FloatColumnVector& a) const;
   bool operator != (const FloatColumnVector& a) const;
 
   // destructive insert/delete/reorder operations
 
   FloatColumnVector& insert (const FloatColumnVector& a, octave_idx_type r);
 
@@ -79,41 +79,45 @@ public:
   // resize is the destructive equivalent for this one
 
   FloatColumnVector extract (octave_idx_type r1, octave_idx_type r2) const;
 
   FloatColumnVector extract_n (octave_idx_type r1, octave_idx_type n) const;
 
   // matrix by column vector -> column vector operations
 
-  friend OCTAVE_API FloatColumnVector operator * (const FloatMatrix& a, const FloatColumnVector& b);
+  friend OCTAVE_API FloatColumnVector operator * (const FloatMatrix& a,
+                                                  const FloatColumnVector& b);
 
   // diagonal matrix by column vector -> column vector operations
 
-  friend OCTAVE_API FloatColumnVector operator * (const FloatDiagMatrix& a, const FloatColumnVector& b);
+  friend OCTAVE_API FloatColumnVector operator * (const FloatDiagMatrix& a,
+                                                  const FloatColumnVector& b);
 
   // other operations
 
   float min (void) const;
   float max (void) const;
 
   FloatColumnVector abs (void) const;
 
   // i/o
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatColumnVector& a);
-  friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatColumnVector& a);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const FloatColumnVector& a);
+  friend OCTAVE_API std::istream& operator >> (std::istream& is,
+                                               FloatColumnVector& a);
 
   void resize (octave_idx_type n, const float& rfv = 0)
   {
     Array<float>::resize (dim_vector (n, 1), rfv);
   }
 
   void clear (octave_idx_type n)
-    { Array<float>::clear (n, 1); }
+  { Array<float>::clear (n, 1); }
 
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API FloatColumnVector real (const FloatComplexColumnVector& a);
 extern OCTAVE_API FloatColumnVector imag (const FloatComplexColumnVector& a);
 
diff --git a/liboctave/array/fDiagMatrix.cc b/liboctave/array/fDiagMatrix.cc
--- a/liboctave/array/fDiagMatrix.cc
+++ b/liboctave/array/fDiagMatrix.cc
@@ -152,17 +152,18 @@ real (const FloatComplexDiagMatrix& a)
 
 FloatDiagMatrix
 imag (const FloatComplexDiagMatrix& a)
 {
   return FloatDiagMatrix (imag (a.extract_diag ()), a.rows (), a.columns ());
 }
 
 FloatMatrix
-FloatDiagMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
+FloatDiagMatrix::extract (octave_idx_type r1, octave_idx_type c1,
+                          octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { std::swap (r1, r2); }
   if (c1 > c2) { std::swap (c1, c2); }
 
   octave_idx_type new_r = r2 - r1 + 1;
   octave_idx_type new_c = c2 - c1 + 1;
 
   FloatMatrix result (new_r, new_c);
diff --git a/liboctave/array/fDiagMatrix.h b/liboctave/array/fDiagMatrix.h
--- a/liboctave/array/fDiagMatrix.h
+++ b/liboctave/array/fDiagMatrix.h
@@ -30,94 +30,100 @@ along with Octave; see the file COPYING.
 #include "DET.h"
 
 #include "mx-defs.h"
 
 class
 OCTAVE_API
 FloatDiagMatrix : public MDiagArray2<float>
 {
-friend class FloatSVD;
-friend class FloatComplexSVD;
+  friend class FloatSVD;
+  friend class FloatComplexSVD;
 
 public:
 
   FloatDiagMatrix (void) : MDiagArray2<float> () { }
 
-  FloatDiagMatrix (octave_idx_type r, octave_idx_type c) : MDiagArray2<float> (r, c) { }
+  FloatDiagMatrix (octave_idx_type r, octave_idx_type c)
+    : MDiagArray2<float> (r, c) { }
 
-  FloatDiagMatrix (octave_idx_type r, octave_idx_type c, float val) : MDiagArray2<float> (r, c, val) { }
+  FloatDiagMatrix (octave_idx_type r, octave_idx_type c, float val)
+    : MDiagArray2<float> (r, c, val) { }
 
   FloatDiagMatrix (const FloatDiagMatrix& a) : MDiagArray2<float> (a) { }
 
   FloatDiagMatrix (const MDiagArray2<float>& a) : MDiagArray2<float> (a) { }
 
   template <class U>
   FloatDiagMatrix (const DiagArray2<U>& a) : MDiagArray2<float> (a) { }
 
   explicit FloatDiagMatrix (const Array<double>& a) : MDiagArray2<float> (a) { }
 
   FloatDiagMatrix (const Array<float>& a, octave_idx_type r, octave_idx_type c)
     : MDiagArray2<float> (a, r, c) { }
 
   FloatDiagMatrix& operator = (const FloatDiagMatrix& a)
-    {
-      MDiagArray2<float>::operator = (a);
-      return *this;
-    }
+  {
+    MDiagArray2<float>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const FloatDiagMatrix& a) const;
   bool operator != (const FloatDiagMatrix& a) const;
 
   FloatDiagMatrix& fill (float val);
   FloatDiagMatrix& fill (float val, octave_idx_type beg, octave_idx_type end);
   FloatDiagMatrix& fill (const FloatColumnVector& a);
   FloatDiagMatrix& fill (const FloatRowVector& a);
   FloatDiagMatrix& fill (const FloatColumnVector& a, octave_idx_type beg);
   FloatDiagMatrix& fill (const FloatRowVector& a, octave_idx_type beg);
 
-  FloatDiagMatrix transpose (void) const { return MDiagArray2<float>::transpose (); }
+  FloatDiagMatrix transpose (void) const
+  { return MDiagArray2<float>::transpose (); }
+
   FloatDiagMatrix abs (void) const;
 
   friend OCTAVE_API FloatDiagMatrix real (const FloatComplexDiagMatrix& a);
   friend OCTAVE_API FloatDiagMatrix imag (const FloatComplexDiagMatrix& a);
 
   // resize is the destructive analog for this one
 
-  FloatMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
+  FloatMatrix extract (octave_idx_type r1, octave_idx_type c1,
+                       octave_idx_type r2, octave_idx_type c2) const;
 
   // extract row or column i.
 
   FloatRowVector row (octave_idx_type i) const;
   FloatRowVector row (char *s) const;
 
   FloatColumnVector column (octave_idx_type i) const;
   FloatColumnVector column (char *s) const;
 
   FloatDiagMatrix inverse (void) const;
   FloatDiagMatrix inverse (octave_idx_type& info) const;
   FloatDiagMatrix pseudo_inverse (void) const;
 
   // other operations
 
   FloatColumnVector extract_diag (octave_idx_type k = 0) const
-    { return MDiagArray2<float>::extract_diag (k); }
+  { return MDiagArray2<float>::extract_diag (k); }
 
   FloatDET determinant (void) const;
   float rcond (void) const;
 
   // i/o
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatDiagMatrix& a);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const FloatDiagMatrix& a);
 
 };
 
 OCTAVE_API FloatDiagMatrix real (const FloatComplexDiagMatrix& a);
 OCTAVE_API FloatDiagMatrix imag (const FloatComplexDiagMatrix& a);
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
-OCTAVE_API FloatDiagMatrix
-operator * (const FloatDiagMatrix& a, const FloatDiagMatrix& b);
+OCTAVE_API FloatDiagMatrix operator * (const FloatDiagMatrix& a,
+                                       const FloatDiagMatrix& b);
 
 MDIAGARRAY2_FORWARD_DEFS (MDiagArray2, FloatDiagMatrix, float)
 
 #endif
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -264,18 +264,17 @@ FloatMatrix::FloatMatrix (const PermMatr
   if (a.is_col_perm ())
     for (octave_idx_type i = 0; i < len; i++)
       elem (ia(i), i) = 1.0;
   else
     for (octave_idx_type i = 0; i < len; i++)
       elem (i, ia(i)) = 1.0;
 }
 
-// FIXME -- could we use a templated mixed-type copy function
-// here?
+// FIXME: could we use a templated mixed-type copy function here?
 
 FloatMatrix::FloatMatrix (const boolMatrix& a)
   : MArray<float> (a)
 {
 }
 
 FloatMatrix::FloatMatrix (const charMatrix& a)
   : MArray<float> (a.dims ())
@@ -312,24 +311,26 @@ FloatMatrix::is_symmetric (void) const
 
       return true;
     }
 
   return false;
 }
 
 FloatMatrix&
-FloatMatrix::insert (const FloatMatrix& a, octave_idx_type r, octave_idx_type c)
+FloatMatrix::insert (const FloatMatrix& a,
+                     octave_idx_type r, octave_idx_type c)
 {
   Array<float>::insert (a, r, c);
   return *this;
 }
 
 FloatMatrix&
-FloatMatrix::insert (const FloatRowVector& a, octave_idx_type r, octave_idx_type c)
+FloatMatrix::insert (const FloatRowVector& a,
+                     octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.length ();
 
   if (r < 0 || r >= rows () || c < 0 || c + a_len > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
@@ -341,17 +342,18 @@ FloatMatrix::insert (const FloatRowVecto
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r, c+i) = a.elem (i);
     }
 
   return *this;
 }
 
 FloatMatrix&
-FloatMatrix::insert (const FloatColumnVector& a, octave_idx_type r, octave_idx_type c)
+FloatMatrix::insert (const FloatColumnVector& a,
+                     octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_len = a.length ();
 
   if (r < 0 || r + a_len > rows () || c < 0 || c >= cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
     }
@@ -363,17 +365,18 @@ FloatMatrix::insert (const FloatColumnVe
       for (octave_idx_type i = 0; i < a_len; i++)
         xelem (r+i, c) = a.elem (i);
     }
 
   return *this;
 }
 
 FloatMatrix&
-FloatMatrix::insert (const FloatDiagMatrix& a, octave_idx_type r, octave_idx_type c)
+FloatMatrix::insert (const FloatDiagMatrix& a,
+                     octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (r < 0 || r + a_nr > rows () || c < 0 || c + a_nc > cols ())
     {
       (*current_liboctave_error_handler) ("range error for insert");
       return *this;
@@ -408,17 +411,18 @@ FloatMatrix::fill (float val)
         for (octave_idx_type i = 0; i < nr; i++)
           xelem (i, j) = val;
     }
 
   return *this;
 }
 
 FloatMatrix&
-FloatMatrix::fill (float val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2)
+FloatMatrix::fill (float val, octave_idx_type r1, octave_idx_type c1,
+                   octave_idx_type r2, octave_idx_type c2)
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
     {
       (*current_liboctave_error_handler) ("range error for fill");
@@ -596,26 +600,28 @@ real (const FloatComplexMatrix& a)
 
 FloatMatrix
 imag (const FloatComplexMatrix& a)
 {
   return do_mx_unary_op<float, FloatComplex> (a, mx_inline_imag);
 }
 
 FloatMatrix
-FloatMatrix::extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const
+FloatMatrix::extract (octave_idx_type r1, octave_idx_type c1,
+                      octave_idx_type r2, octave_idx_type c2) const
 {
   if (r1 > r2) { std::swap (r1, r2); }
   if (c1 > c2) { std::swap (c1, c2); }
 
   return index (idx_vector (r1, r2+1), idx_vector (c1, c2+1));
 }
 
 FloatMatrix
-FloatMatrix::extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const
+FloatMatrix::extract_n (octave_idx_type r1, octave_idx_type c1,
+                        octave_idx_type nr, octave_idx_type nc) const
 {
   return index (idx_vector (r1, r1 + nr), idx_vector (c1, c1 + nc));
 }
 
 // extract row or column i.
 
 FloatRowVector
 FloatMatrix::row (octave_idx_type i) const
@@ -643,17 +649,17 @@ FloatMatrix::inverse (octave_idx_type& i
 {
   float rcon;
   MatrixType mattype (*this);
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatMatrix
 FloatMatrix::inverse (octave_idx_type& info, float& rcon, int force,
-                 int calc_cond) const
+                      int calc_cond) const
 {
   MatrixType mattype (*this);
   return inverse (mattype, info, rcon, force, calc_cond);
 }
 
 FloatMatrix
 FloatMatrix::inverse (MatrixType& mattype) const
 {
@@ -666,17 +672,17 @@ FloatMatrix
 FloatMatrix::inverse (MatrixType &mattype, octave_idx_type& info) const
 {
   float rcon;
   return inverse (mattype, info, rcon, 0, 0);
 }
 
 FloatMatrix
 FloatMatrix::tinverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
-                  int force, int calc_cond) const
+                       int force, int calc_cond) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
@@ -724,17 +730,17 @@ FloatMatrix::tinverse (MatrixType &matty
     }
 
   return retval;
 }
 
 
 FloatMatrix
 FloatMatrix::finverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
-                  int force, int calc_cond) const
+                       int force, int calc_cond) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr == 0 || nc == 0)
     (*current_liboctave_error_handler) ("inverse requires square matrix");
@@ -758,17 +764,18 @@ FloatMatrix::finverse (MatrixType &matty
       z.resize (dim_vector (lwork, 1));
       float *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       float anorm = 0;
       if (calc_cond)
-        anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
+        anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0))
+                .max ();
 
       F77_XFCN (sgetrf, SGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         info = -1;
       else if (calc_cond)
@@ -805,17 +812,17 @@ FloatMatrix::finverse (MatrixType &matty
         mattype.mark_as_rectangular ();
     }
 
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::inverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
-                 int force, int calc_cond) const
+                      int force, int calc_cond) const
 {
   int typ = mattype.type (false);
   FloatMatrix ret;
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   if (typ == MatrixType::Upper || typ == MatrixType::Lower)
@@ -978,20 +985,22 @@ extern "C"
   // float complex arguments.  They have been modified by adding an
   // implicit float precision (a-h,o-z) statement at the beginning of
   // each subroutine.
 
   F77_RET_T
   F77_FUNC (cffti, CFFTI) (const octave_idx_type&, FloatComplex*);
 
   F77_RET_T
-  F77_FUNC (cfftf, CFFTF) (const octave_idx_type&, FloatComplex*, FloatComplex*);
+  F77_FUNC (cfftf, CFFTF) (const octave_idx_type&, FloatComplex*,
+                           FloatComplex*);
 
   F77_RET_T
-  F77_FUNC (cfftb, CFFTB) (const octave_idx_type&, FloatComplex*, FloatComplex*);
+  F77_FUNC (cfftb, CFFTB) (const octave_idx_type&, FloatComplex*,
+                           FloatComplex*);
 }
 
 FloatComplexMatrix
 FloatMatrix::fourier (void) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
@@ -1222,25 +1231,27 @@ FloatMatrix::determinant (void) const
 FloatDET
 FloatMatrix::determinant (octave_idx_type& info) const
 {
   float rcon;
   return determinant (info, rcon, 0);
 }
 
 FloatDET
-FloatMatrix::determinant (octave_idx_type& info, float& rcon, int calc_cond) const
+FloatMatrix::determinant (octave_idx_type& info, float& rcon,
+                          int calc_cond) const
 {
   MatrixType mattype (*this);
   return determinant (mattype, info, rcon, calc_cond);
 }
 
 FloatDET
 FloatMatrix::determinant (MatrixType& mattype,
-                          octave_idx_type& info, float& rcon, int calc_cond) const
+                          octave_idx_type& info, float& rcon,
+                          int calc_cond) const
 {
   FloatDET retval (1.0);
 
   info = 0;
   rcon = 0.0;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
@@ -1459,17 +1470,17 @@ FloatMatrix::rcond (MatrixType &mattype)
             {
               octave_idx_type info = 0;
               char job = 'L';
 
               FloatMatrix atmp = *this;
               float *tmp_data = atmp.fortran_vec ();
 
               anorm = atmp.abs().sum().
-                row(static_cast<octave_idx_type>(0)).max();
+                      row(static_cast<octave_idx_type>(0)).max();
 
               F77_XFCN (spotrf, SPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
                                          tmp_data, nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
@@ -1500,17 +1511,17 @@ FloatMatrix::rcond (MatrixType &mattype)
               FloatMatrix atmp = *this;
               float *tmp_data = atmp.fortran_vec ();
 
               Array<octave_idx_type> ipvt (dim_vector (nr, 1));
               octave_idx_type *pipvt = ipvt.fortran_vec ();
 
               if (anorm < 0.)
                 anorm = atmp.abs ().sum ().
-                  row(static_cast<octave_idx_type>(0)).max ();
+                        row(static_cast<octave_idx_type>(0)).max ();
 
               Array<float> z (dim_vector (4 * nc, 1));
               float *pz = z.fortran_vec ();
               Array<octave_idx_type> iz (dim_vector (nc, 1));
               octave_idx_type *piz = iz.fortran_vec ();
 
               F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
@@ -1535,19 +1546,20 @@ FloatMatrix::rcond (MatrixType &mattype)
       else
         rcon = 0.0;
     }
 
   return rcon;
 }
 
 FloatMatrix
-FloatMatrix::utsolve (MatrixType &mattype, const FloatMatrix& b, octave_idx_type& info,
-                float& rcon, solve_singularity_handler sing_handler,
-                bool calc_cond, blas_trans_type transt) const
+FloatMatrix::utsolve (MatrixType &mattype, const FloatMatrix& b,
+                      octave_idx_type& info,
+                      float& rcon, solve_singularity_handler sing_handler,
+                      bool calc_cond, blas_trans_type transt) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
@@ -1635,19 +1647,20 @@ FloatMatrix::utsolve (MatrixType &mattyp
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatMatrix
-FloatMatrix::ltsolve (MatrixType &mattype, const FloatMatrix& b, octave_idx_type& info,
-                float& rcon, solve_singularity_handler sing_handler,
-                bool calc_cond, blas_trans_type transt) const
+FloatMatrix::ltsolve (MatrixType &mattype, const FloatMatrix& b,
+                      octave_idx_type& info,
+                      float& rcon, solve_singularity_handler sing_handler,
+                      bool calc_cond, blas_trans_type transt) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
@@ -1735,35 +1748,36 @@ FloatMatrix::ltsolve (MatrixType &mattyp
       else
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
   return retval;
 }
 
 FloatMatrix
-FloatMatrix::fsolve (MatrixType &mattype, const FloatMatrix& b, octave_idx_type& info,
-                float& rcon, solve_singularity_handler sing_handler,
-                bool calc_cond) const
+FloatMatrix::fsolve (MatrixType &mattype, const FloatMatrix& b,
+                     octave_idx_type& info,
+                     float& rcon, solve_singularity_handler sing_handler,
+                     bool calc_cond) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != nc || nr != b.rows ())
     (*current_liboctave_error_handler)
       ("matrix dimension mismatch solution of linear equations");
   else if (nr == 0 || b.cols () == 0)
     retval = FloatMatrix (nc, b.cols (), 0.0);
   else
     {
       volatile int typ = mattype.type ();
 
-     // Calculate the norm of the matrix, for later use.
+      // Calculate the norm of the matrix, for later use.
       float anorm = -1.;
 
       if (typ == MatrixType::Hermitian)
         {
           info = 0;
           char job = 'L';
 
           FloatMatrix atmp = *this;
@@ -1841,17 +1855,17 @@ FloatMatrix::fsolve (MatrixType &mattype
           info = 0;
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
           FloatMatrix atmp = *this;
           float *tmp_data = atmp.fortran_vec ();
 
-          if(anorm < 0.)
+          if (anorm < 0.)
             anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
           Array<float> z (dim_vector (4 * nc, 1));
           float *pz = z.fortran_vec ();
           Array<octave_idx_type> iz (dim_vector (nc, 1));
           octave_idx_type *piz = iz.fortran_vec ();
 
           F77_XFCN (sgetrf, SGETRF, (nr, nr, tmp_data, nr, pipvt, info));
@@ -1928,47 +1942,50 @@ FloatMatrix
 FloatMatrix::solve (MatrixType &typ, const FloatMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatMatrix
-FloatMatrix::solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info) const
+FloatMatrix::solve (MatrixType &typ, const FloatMatrix& b,
+                    octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatMatrix
-FloatMatrix::solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-               float& rcon) const
+FloatMatrix::solve (MatrixType &typ, const FloatMatrix& b,
+                    octave_idx_type& info, float& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatMatrix
-FloatMatrix::solve (MatrixType &mattype, const FloatMatrix& b, octave_idx_type& info,
-               float& rcon, solve_singularity_handler sing_handler,
-               bool singular_fallback, blas_trans_type transt) const
+FloatMatrix::solve (MatrixType &mattype, const FloatMatrix& b,
+                    octave_idx_type& info,
+                    float& rcon, solve_singularity_handler sing_handler,
+                    bool singular_fallback, blas_trans_type transt) const
 {
   FloatMatrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   // Only calculate the condition number for LU/Cholesky
   if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
     retval = utsolve (mattype, b, info, rcon, sing_handler, false, transt);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
     retval = ltsolve (mattype, b, info, rcon, sing_handler, false, transt);
   else if (transt == blas_trans || transt == blas_conj_trans)
-    return transpose ().solve (mattype, b, info, rcon, sing_handler, singular_fallback);
+    return transpose ().solve (mattype, b, info, rcon, sing_handler,
+                               singular_fallback);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, info, rcon, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return FloatMatrix ();
     }
 
@@ -1987,25 +2004,26 @@ FloatMatrix::solve (MatrixType &typ, con
 {
   octave_idx_type info;
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b,
-  octave_idx_type& info) const
+                    octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
-FloatMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b, octave_idx_type& info,
-               float& rcon) const
+FloatMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b,
+                    octave_idx_type& info,
+                    float& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 static FloatMatrix
 stack_complex_matrix (const FloatComplexMatrix& cm)
 {
   octave_idx_type m = cm.rows (), n = cm.cols (), nel = m*n;
@@ -2028,83 +2046,88 @@ unstack_complex_matrix (const FloatMatri
   const float *smd = sm.data ();
   FloatComplex *rd = retval.fortran_vec ();
   for (octave_idx_type i = 0; i < nel; i++)
     rd[i] = FloatComplex (smd[i], smd[nel+i]);
   return retval;
 }
 
 FloatComplexMatrix
-FloatMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b, octave_idx_type& info,
-               float& rcon, solve_singularity_handler sing_handler,
-               bool singular_fallback, blas_trans_type transt) const
+FloatMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b,
+                    octave_idx_type& info,
+                    float& rcon, solve_singularity_handler sing_handler,
+                    bool singular_fallback, blas_trans_type transt) const
 {
   FloatMatrix tmp = stack_complex_matrix (b);
   tmp = solve (typ, tmp, info, rcon, sing_handler, singular_fallback, transt);
   return unstack_complex_matrix (tmp);
 }
 
 FloatColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b) const
 {
   octave_idx_type info; float rcon;
   return solve (typ, b, info, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b,
-               octave_idx_type& info) const
+                    octave_idx_type& info) const
 {
   float rcon;
   return solve (typ, b, info, rcon);
 }
 
 FloatColumnVector
-FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b, octave_idx_type& info,
-               float& rcon) const
+FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b,
+                    octave_idx_type& info,
+                    float& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatColumnVector
-FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b, octave_idx_type& info,
-               float& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
+FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b,
+                    octave_idx_type& info,
+                    float& rcon, solve_singularity_handler sing_handler,
+                    blas_trans_type transt) const
 {
   FloatMatrix tmp (b);
   tmp = solve (typ, tmp, info, rcon, sing_handler, true, transt);
   return tmp.column (static_cast<octave_idx_type> (0));
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (typ, b);
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
-               octave_idx_type& info) const
+                    octave_idx_type& info) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info);
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
-               octave_idx_type& info, float& rcon) const
+                    octave_idx_type& info, float& rcon) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info, rcon);
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
-               octave_idx_type& info, float& rcon,
-               solve_singularity_handler sing_handler, blas_trans_type transt) const
+                    octave_idx_type& info, float& rcon,
+                    solve_singularity_handler sing_handler,
+                    blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info, rcon, sing_handler, transt);
 }
 
 FloatMatrix
 FloatMatrix::solve (const FloatMatrix& b) const
 {
@@ -2116,24 +2139,26 @@ FloatMatrix::solve (const FloatMatrix& b
 FloatMatrix
 FloatMatrix::solve (const FloatMatrix& b, octave_idx_type& info) const
 {
   float rcon;
   return solve (b, info, rcon, 0);
 }
 
 FloatMatrix
-FloatMatrix::solve (const FloatMatrix& b, octave_idx_type& info, float& rcon) const
+FloatMatrix::solve (const FloatMatrix& b, octave_idx_type& info,
+                    float& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 FloatMatrix
 FloatMatrix::solve (const FloatMatrix& b, octave_idx_type& info,
-               float& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
+                    float& rcon, solve_singularity_handler sing_handler,
+                    blas_trans_type transt) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, info, rcon, sing_handler, true, transt);
 }
 
 FloatComplexMatrix
 FloatMatrix::solve (const FloatComplexMatrix& b) const
 {
@@ -2144,25 +2169,28 @@ FloatMatrix::solve (const FloatComplexMa
 FloatComplexMatrix
 FloatMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (b, info);
 }
 
 FloatComplexMatrix
-FloatMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon) const
+FloatMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info,
+                    float& rcon) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon);
 }
 
 FloatComplexMatrix
-FloatMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon,
-               solve_singularity_handler sing_handler, blas_trans_type transt) const
+FloatMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info,
+                    float& rcon,
+                    solve_singularity_handler sing_handler,
+                    blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon, sing_handler, transt);
 }
 
 FloatColumnVector
 FloatMatrix::solve (const FloatColumnVector& b) const
 {
@@ -2173,53 +2201,58 @@ FloatMatrix::solve (const FloatColumnVec
 FloatColumnVector
 FloatMatrix::solve (const FloatColumnVector& b, octave_idx_type& info) const
 {
   float rcon;
   return solve (b, info, rcon);
 }
 
 FloatColumnVector
-FloatMatrix::solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon) const
+FloatMatrix::solve (const FloatColumnVector& b, octave_idx_type& info,
+                    float& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 FloatColumnVector
-FloatMatrix::solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon,
-               solve_singularity_handler sing_handler, blas_trans_type transt) const
+FloatMatrix::solve (const FloatColumnVector& b, octave_idx_type& info,
+                    float& rcon, solve_singularity_handler sing_handler,
+                    blas_trans_type transt) const
 {
   MatrixType mattype (*this);
   return solve (mattype, b, info, rcon, sing_handler, transt);
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (const FloatComplexColumnVector& b) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (b);
 }
 
 FloatComplexColumnVector
-FloatMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info) const
+FloatMatrix::solve (const FloatComplexColumnVector& b,
+                    octave_idx_type& info) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (b, info);
 }
 
 FloatComplexColumnVector
-FloatMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info, float& rcon) const
+FloatMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info,
+                    float& rcon) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon);
 }
 
 FloatComplexColumnVector
-FloatMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info, float& rcon,
-               solve_singularity_handler sing_handler, blas_trans_type transt) const
+FloatMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info,
+                    float& rcon, solve_singularity_handler sing_handler,
+                    blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon, sing_handler, transt);
 }
 
 FloatMatrix
 FloatMatrix::lssolve (const FloatMatrix& b) const
 {
@@ -2234,25 +2267,25 @@ FloatMatrix::lssolve (const FloatMatrix&
 {
   octave_idx_type rank;
   float rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 FloatMatrix
 FloatMatrix::lssolve (const FloatMatrix& b, octave_idx_type& info,
-                 octave_idx_type& rank) const
+                      octave_idx_type& rank) const
 {
   float rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 FloatMatrix
 FloatMatrix::lssolve (const FloatMatrix& b, octave_idx_type& info,
-                 octave_idx_type& rank, float &rcon) const
+                      octave_idx_type& rank, float &rcon) const
 {
   FloatMatrix retval;
 
   octave_idx_type nrhs = b.cols ();
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2398,26 +2431,26 @@ FloatMatrix::lssolve (const FloatComplex
   FloatComplexMatrix tmp (*this);
   octave_idx_type rank;
   float rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
-                 octave_idx_type& rank) const
+                      octave_idx_type& rank) const
 {
   FloatComplexMatrix tmp (*this);
   float rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexMatrix
 FloatMatrix::lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
-                 octave_idx_type& rank, float& rcon) const
+                      octave_idx_type& rank, float& rcon) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::lssolve (const FloatColumnVector& b) const
 {
@@ -2432,25 +2465,25 @@ FloatMatrix::lssolve (const FloatColumnV
 {
   octave_idx_type rank;
   float rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info,
-                 octave_idx_type& rank) const
+                      octave_idx_type& rank) const
 {
   float rcon;
   return lssolve (b, info, rank, rcon);
 }
 
 FloatColumnVector
 FloatMatrix::lssolve (const FloatColumnVector& b, octave_idx_type& info,
-                 octave_idx_type& rank, float &rcon) const
+                      octave_idx_type& rank, float &rcon) const
 {
   FloatColumnVector retval;
 
   octave_idx_type nrhs = 1;
 
   octave_idx_type m = rows ();
   octave_idx_type n = cols ();
 
@@ -2545,36 +2578,37 @@ FloatMatrix::lssolve (const FloatComplex
   FloatComplexMatrix tmp (*this);
   octave_idx_type info;
   octave_idx_type rank;
   float rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexColumnVector
-FloatMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info) const
+FloatMatrix::lssolve (const FloatComplexColumnVector& b,
+                      octave_idx_type& info) const
 {
   FloatComplexMatrix tmp (*this);
   octave_idx_type rank;
   float rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info,
-                 octave_idx_type& rank) const
+                      octave_idx_type& rank) const
 {
   FloatComplexMatrix tmp (*this);
   float rcon;
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatComplexColumnVector
 FloatMatrix::lssolve (const FloatComplexColumnVector& b, octave_idx_type& info,
-                 octave_idx_type& rank, float &rcon) const
+                      octave_idx_type& rank, float &rcon) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.lssolve (b, info, rank, rcon);
 }
 
 FloatMatrix&
 FloatMatrix::operator += (const FloatDiagMatrix& a)
 {
@@ -2729,18 +2763,17 @@ FloatMatrix::all_integers (float& max_va
 }
 
 bool
 FloatMatrix::too_large_for_float (void) const
 {
   return false;
 }
 
-// FIXME Do these really belong here?  Maybe they should be
-// in a base class?
+// FIXME: Do these really belong here?  Maybe they should be in a base class?
 
 boolMatrix
 FloatMatrix::all (int dim) const
 {
   return do_mx_red_op<bool, float> (*this, dim, mx_inline_all);
 }
 
 boolMatrix
@@ -3058,17 +3091,17 @@ operator >> (std::istream& is, FloatMatr
             tmp = octave_read_value<float> (is);
             if (is)
               a.elem (i, j) = tmp;
             else
               goto done;
           }
     }
 
- done:
+done:
 
   return is;
 }
 
 FloatMatrix
 Givens (float x, float y)
 {
   float cc, s, temp_r;
@@ -3085,18 +3118,17 @@ Givens (float x, float y)
   return g;
 }
 
 FloatMatrix
 Sylvester (const FloatMatrix& a, const FloatMatrix& b, const FloatMatrix& c)
 {
   FloatMatrix retval;
 
-  // FIXME -- need to check that a, b, and c are all the same
-  // size.
+  // FIXME: need to check that a, b, and c are all the same size.
 
   // Compute Schur decompositions.
 
   FloatSCHUR as (a, "U");
   FloatSCHUR bs (b, "U");
 
   // Transform c to new coordinates.
 
@@ -3124,17 +3156,17 @@ Sylvester (const FloatMatrix& a, const F
   F77_XFCN (strsyl, STRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              1, a_nr, b_nr, pa, a_nr, pb,
                              b_nr, px, a_nr, scale, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
 
-  // FIXME -- check info?
+  // FIXME: check info?
 
   retval = -ua*cx*ub.transpose ();
 
   return retval;
 }
 
 // matrix by matrix -> matrix operations
 
@@ -3251,18 +3283,17 @@ xgemm (const FloatMatrix& a, const Float
 }
 
 FloatMatrix
 operator * (const FloatMatrix& a, const FloatMatrix& b)
 {
   return xgemm (a, b);
 }
 
-// FIXME -- it would be nice to share code among the min/max
-// functions below.
+// FIXME: it would be nice to share code among the min/max functions below.
 
 #define EMPTY_RETURN_CHECK(T) \
   if (nr == 0 || nc == 0) \
     return T (nr, nc);
 
 FloatMatrix
 min (float d, const FloatMatrix& m)
 {
@@ -3402,17 +3433,18 @@ FloatMatrix linspace (const FloatColumnV
                       octave_idx_type n)
 
 {
   if (n < 1) n = 1;
 
   octave_idx_type m = x1.length ();
 
   if (x2.length () != m)
-    (*current_liboctave_error_handler) ("linspace: vectors must be of equal length");
+    (*current_liboctave_error_handler)
+      ("linspace: vectors must be of equal length");
 
   NoAlias<FloatMatrix> retval;
 
   retval.clear (m, n);
   for (octave_idx_type i = 0; i < m; i++)
     retval(i, 0) = x1(i);
 
   // The last column is not needed while using delta.
diff --git a/liboctave/array/fMatrix.h b/liboctave/array/fMatrix.h
--- a/liboctave/array/fMatrix.h
+++ b/liboctave/array/fMatrix.h
@@ -72,35 +72,40 @@ public:
   explicit FloatMatrix (const PermMatrix& a);
 
   explicit FloatMatrix (const boolMatrix& a);
 
   explicit FloatMatrix (const charMatrix& a);
 
 
   FloatMatrix& operator = (const FloatMatrix& a)
-    {
-      MArray<float>::operator = (a);
-      return *this;
-    }
+  {
+    MArray<float>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const FloatMatrix& a) const;
   bool operator != (const FloatMatrix& a) const;
 
   bool is_symmetric (void) const;
 
   // destructive insert/delete/reorder operations
 
-  FloatMatrix& insert (const FloatMatrix& a, octave_idx_type r, octave_idx_type c);
-  FloatMatrix& insert (const FloatRowVector& a, octave_idx_type r, octave_idx_type c);
-  FloatMatrix& insert (const FloatColumnVector& a, octave_idx_type r, octave_idx_type c);
-  FloatMatrix& insert (const FloatDiagMatrix& a, octave_idx_type r, octave_idx_type c);
+  FloatMatrix& insert (const FloatMatrix& a,
+                       octave_idx_type r, octave_idx_type c);
+  FloatMatrix& insert (const FloatRowVector& a,
+                       octave_idx_type r, octave_idx_type c);
+  FloatMatrix& insert (const FloatColumnVector& a,
+                       octave_idx_type r, octave_idx_type c);
+  FloatMatrix& insert (const FloatDiagMatrix& a,
+                       octave_idx_type r, octave_idx_type c);
 
   FloatMatrix& fill (float val);
-  FloatMatrix& fill (float val, octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2);
+  FloatMatrix& fill (float val, octave_idx_type r1, octave_idx_type c1,
+                     octave_idx_type r2, octave_idx_type c2);
 
   FloatMatrix append (const FloatMatrix& a) const;
   FloatMatrix append (const FloatRowVector& a) const;
   FloatMatrix append (const FloatColumnVector& a) const;
   FloatMatrix append (const FloatDiagMatrix& a) const;
 
   FloatMatrix stack (const FloatMatrix& a) const;
   FloatMatrix stack (const FloatRowVector& a) const;
@@ -111,184 +116,214 @@ public:
   friend OCTAVE_API FloatMatrix imag (const FloatComplexMatrix& a);
 
   friend class FloatComplexMatrix;
 
   FloatMatrix transpose (void) const { return MArray<float>::transpose (); }
 
   // resize is the destructive equivalent for this one
 
-  FloatMatrix extract (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2) const;
+  FloatMatrix extract (octave_idx_type r1, octave_idx_type c1,
+                       octave_idx_type r2, octave_idx_type c2) const;
 
-  FloatMatrix extract_n (octave_idx_type r1, octave_idx_type c1, octave_idx_type nr, octave_idx_type nc) const;
+  FloatMatrix extract_n (octave_idx_type r1, octave_idx_type c1,
+                         octave_idx_type nr, octave_idx_type nc) const;
 
   // extract row or column i.
 
   FloatRowVector row (octave_idx_type i) const;
 
   FloatColumnVector column (octave_idx_type i) const;
 
   void resize (octave_idx_type nr, octave_idx_type nc, float rfv = 0)
   {
     MArray<float>::resize (dim_vector (nr, nc), rfv);
   }
 
 private:
-  FloatMatrix tinverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
-                   int force, int calc_cond) const;
+  FloatMatrix tinverse (MatrixType &mattype, octave_idx_type& info,
+                        float& rcon, int force, int calc_cond) const;
 
-  FloatMatrix finverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
-                   int force, int calc_cond) const;
+  FloatMatrix finverse (MatrixType &mattype, octave_idx_type& info,
+                        float& rcon, int force, int calc_cond) const;
 
 public:
   FloatMatrix inverse (void) const;
   FloatMatrix inverse (octave_idx_type& info) const;
   FloatMatrix inverse (octave_idx_type& info, float& rcon, int force = 0,
-                  int calc_cond = 1) const;
+                       int calc_cond = 1) const;
 
   FloatMatrix inverse (MatrixType &mattype) const;
   FloatMatrix inverse (MatrixType &mattype, octave_idx_type& info) const;
   FloatMatrix inverse (MatrixType &mattype, octave_idx_type& info, float& rcon,
-                  int force = 0, int calc_cond = 1) const;
+                       int force = 0, int calc_cond = 1) const;
 
   FloatMatrix pseudo_inverse (float tol = 0.0) const;
 
   FloatComplexMatrix fourier (void) const;
   FloatComplexMatrix ifourier (void) const;
 
   FloatComplexMatrix fourier2d (void) const;
   FloatComplexMatrix ifourier2d (void) const;
 
   FloatDET determinant (void) const;
   FloatDET determinant (octave_idx_type& info) const;
-  FloatDET determinant (octave_idx_type& info, float& rcon, int calc_cond = 1) const;
+  FloatDET determinant (octave_idx_type& info, float& rcon,
+                        int calc_cond = 1) const;
   FloatDET determinant (MatrixType &mattype, octave_idx_type& info,
                         float& rcon, int calc_cond = 1) const;
 
   float rcond (void) const;
   float rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
-  FloatMatrix utsolve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-                  float& rcon, solve_singularity_handler sing_handler,
-                  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
+  FloatMatrix utsolve (MatrixType &typ, const FloatMatrix& b,
+                       octave_idx_type& info,
+                       float& rcon, solve_singularity_handler sing_handler,
+                       bool calc_cond = false,
+                       blas_trans_type transt = blas_no_trans) const;
 
   // Lower triangular matrix solvers
-  FloatMatrix ltsolve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-                  float& rcon, solve_singularity_handler sing_handler,
-                  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
+  FloatMatrix ltsolve (MatrixType &typ, const FloatMatrix& b,
+                       octave_idx_type& info,
+                       float& rcon, solve_singularity_handler sing_handler,
+                       bool calc_cond = false,
+                       blas_trans_type transt = blas_no_trans) const;
 
   // Full matrix solvers (lu/cholesky)
-  FloatMatrix fsolve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-                 float& rcon, solve_singularity_handler sing_handler,
-                 bool calc_cond = false) const;
+  FloatMatrix fsolve (MatrixType &typ, const FloatMatrix& b,
+                      octave_idx_type& info,
+                      float& rcon, solve_singularity_handler sing_handler,
+                      bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   FloatMatrix solve (MatrixType &typ, const FloatMatrix& b) const;
-  FloatMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info) const;
-  FloatMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-                float& rcon) const;
-  FloatMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
-                float& rcon, solve_singularity_handler sing_handler,
-                bool singular_fallback = true, blas_trans_type transt = blas_no_trans) const;
+  FloatMatrix solve (MatrixType &typ, const FloatMatrix& b,
+                     octave_idx_type& info) const;
+  FloatMatrix solve (MatrixType &typ, const FloatMatrix& b,
+                     octave_idx_type& info, float& rcon) const;
+  FloatMatrix solve (MatrixType &typ, const FloatMatrix& b,
+                     octave_idx_type& info, float& rcon,
+                     solve_singularity_handler sing_handler,
+                     bool singular_fallback = true,
+                     blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b,
-                       octave_idx_type& info) const;
+                            octave_idx_type& info) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b,
-                       octave_idx_type& info, float& rcon) const;
+                            octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b,
-                       octave_idx_type& info, float& rcon,
-                       solve_singularity_handler sing_handler,
-                       bool singular_fallback = true,
-                       blas_trans_type transt = blas_no_trans) const;
+                            octave_idx_type& info, float& rcon,
+                            solve_singularity_handler sing_handler,
+                            bool singular_fallback = true,
+                            blas_trans_type transt = blas_no_trans) const;
 
   FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b) const;
   FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
-                      octave_idx_type& info) const;
+                           octave_idx_type& info) const;
   FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
-                      octave_idx_type& info, float& rcon) const;
+                           octave_idx_type& info, float& rcon) const;
   FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b,
-                      octave_idx_type& info, float& rcon,
-                      solve_singularity_handler sing_handler,
-                      blas_trans_type transt = blas_no_trans) const;
+                           octave_idx_type& info, float& rcon,
+                           solve_singularity_handler sing_handler,
+                           blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (MatrixType &typ,
-                             const FloatComplexColumnVector& b) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b,
-                             octave_idx_type& info) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b,
-                             octave_idx_type& info, float& rcon) const;
-  FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b,
-                             octave_idx_type& info, float& rcon,
-                             solve_singularity_handler sing_handler, blas_trans_type transt = blas_no_trans) const;
+                                  const FloatComplexColumnVector& b) const;
+  FloatComplexColumnVector solve (MatrixType &typ,
+                                  const FloatComplexColumnVector& b,
+                                  octave_idx_type& info) const;
+  FloatComplexColumnVector solve (MatrixType &typ,
+                                  const FloatComplexColumnVector& b,
+                                  octave_idx_type& info, float& rcon) const;
+  FloatComplexColumnVector solve (MatrixType &typ,
+                                  const FloatComplexColumnVector& b,
+                                  octave_idx_type& info, float& rcon,
+                                  solve_singularity_handler sing_handler,
+                                  blas_trans_type transt = blas_no_trans) const;
 
   // Generic interface to solver with probing of type
   FloatMatrix solve (const FloatMatrix& b) const;
   FloatMatrix solve (const FloatMatrix& b, octave_idx_type& info) const;
-  FloatMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon) const;
+  FloatMatrix solve (const FloatMatrix& b, octave_idx_type& info,
+                     float& rcon) const;
   FloatMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon,
                      solve_singularity_handler sing_handler,
                      blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexMatrix solve (const FloatComplexMatrix& b) const;
-  FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info) const;
-  FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon) const;
-  FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon,
+  FloatComplexMatrix solve (const FloatComplexMatrix& b,
+                            octave_idx_type& info) const;
+  FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info,
+                            float& rcon) const;
+  FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info,
+                            float& rcon,
                             solve_singularity_handler sing_handler,
                             blas_trans_type transt = blas_no_trans) const;
 
   FloatColumnVector solve (const FloatColumnVector& b) const;
-  FloatColumnVector solve (const FloatColumnVector& b, octave_idx_type& info) const;
-  FloatColumnVector solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon) const;
-  FloatColumnVector solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon,
+  FloatColumnVector solve (const FloatColumnVector& b,
+                           octave_idx_type& info) const;
+  FloatColumnVector solve (const FloatColumnVector& b, octave_idx_type& info,
+                           float& rcon) const;
+  FloatColumnVector solve (const FloatColumnVector& b, octave_idx_type& info,
+                           float& rcon,
                            solve_singularity_handler sing_handler,
                            blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b) const;
-  FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info) const;
-  FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info,
+  FloatComplexColumnVector solve (const FloatComplexColumnVector& b,
+                                  octave_idx_type& info) const;
+  FloatComplexColumnVector solve (const FloatComplexColumnVector& b,
+                                  octave_idx_type& info,
                                   float& rcon) const;
-  FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info,
-                                  float& rcon, solve_singularity_handler sing_handler,
+  FloatComplexColumnVector solve (const FloatComplexColumnVector& b,
+                                  octave_idx_type& info,
+                                  float& rcon,
+                                  solve_singularity_handler sing_handler,
                                   blas_trans_type transt = blas_no_trans) const;
 
   // Singular solvers
   FloatMatrix lssolve (const FloatMatrix& b) const;
   FloatMatrix lssolve (const FloatMatrix& b, octave_idx_type& info) const;
   FloatMatrix lssolve (const FloatMatrix& b, octave_idx_type& info,
-                  octave_idx_type& rank) const;
+                       octave_idx_type& rank) const;
   FloatMatrix lssolve (const FloatMatrix& b, octave_idx_type& info,
-                  octave_idx_type& rank, float& rcon) const;
+                       octave_idx_type& rank, float& rcon) const;
 
   FloatComplexMatrix lssolve (const FloatComplexMatrix& b) const;
-  FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info) const;
-  FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
-                         octave_idx_type& rank) const;
-  FloatComplexMatrix lssolve (const FloatComplexMatrix& b, octave_idx_type& info,
-                         octave_idx_type& rank, float &rcon) const;
+  FloatComplexMatrix lssolve (const FloatComplexMatrix& b,
+                              octave_idx_type& info) const;
+  FloatComplexMatrix lssolve (const FloatComplexMatrix& b,
+                              octave_idx_type& info,
+                              octave_idx_type& rank) const;
+  FloatComplexMatrix lssolve (const FloatComplexMatrix& b,
+                              octave_idx_type& info, octave_idx_type& rank,
+                              float &rcon) const;
 
   FloatColumnVector lssolve (const FloatColumnVector& b) const;
-  FloatColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info) const;
+  FloatColumnVector lssolve (const FloatColumnVector& b,
+                             octave_idx_type& info) const;
   FloatColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info,
-                        octave_idx_type& rank) const;
+                             octave_idx_type& rank) const;
   FloatColumnVector lssolve (const FloatColumnVector& b, octave_idx_type& info,
-                        octave_idx_type& rank, float& rcon) const;
+                             octave_idx_type& rank, float& rcon) const;
 
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b) const;
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b,
-                               octave_idx_type& info) const;
+                                    octave_idx_type& info) const;
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b,
-                               octave_idx_type& info,
-                               octave_idx_type& rank) const;
+                                    octave_idx_type& info,
+                                    octave_idx_type& rank) const;
   FloatComplexColumnVector lssolve (const FloatComplexColumnVector& b,
-                               octave_idx_type& info,
-                               octave_idx_type& rank, float& rcon) const;
+                                    octave_idx_type& info,
+                                    octave_idx_type& rank, float& rcon) const;
 
   FloatMatrix& operator += (const FloatDiagMatrix& a);
   FloatMatrix& operator -= (const FloatDiagMatrix& a);
 
   // unary operations
 
   boolMatrix operator ! (void) const;
 
@@ -326,40 +361,45 @@ public:
   FloatRowVector column_min (void) const;
   FloatRowVector column_max (void) const;
 
   FloatRowVector column_min (Array<octave_idx_type>& index) const;
   FloatRowVector column_max (Array<octave_idx_type>& index) const;
 
   // i/o
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatMatrix& a);
-  friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatMatrix& a);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const FloatMatrix& a);
+  friend OCTAVE_API std::istream& operator >> (std::istream& is,
+                                               FloatMatrix& a);
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API FloatMatrix real (const FloatComplexMatrix& a);
 extern OCTAVE_API FloatMatrix imag (const FloatComplexMatrix& a);
 
 // column vector by row vector -> matrix operations
 
-extern OCTAVE_API FloatMatrix operator * (const FloatColumnVector& a, const FloatRowVector& b);
+extern OCTAVE_API FloatMatrix operator * (const FloatColumnVector& a,
+                                          const FloatRowVector& b);
 
 // Other functions.
 
 extern OCTAVE_API FloatMatrix Givens (float, float);
 
-extern OCTAVE_API FloatMatrix Sylvester (const FloatMatrix&, const FloatMatrix&, const FloatMatrix&);
+extern OCTAVE_API FloatMatrix Sylvester (const FloatMatrix&, const FloatMatrix&,
+                                         const FloatMatrix&);
 
 extern OCTAVE_API FloatMatrix xgemm (const FloatMatrix& a, const FloatMatrix& b,
                                      blas_trans_type transa = blas_no_trans,
                                      blas_trans_type transb = blas_no_trans);
 
-extern OCTAVE_API FloatMatrix operator * (const FloatMatrix& a, const FloatMatrix& b);
+extern OCTAVE_API FloatMatrix operator * (const FloatMatrix& a,
+                                          const FloatMatrix& b);
 
 extern OCTAVE_API FloatMatrix min (float d, const FloatMatrix& m);
 extern OCTAVE_API FloatMatrix min (const FloatMatrix& m, float d);
 extern OCTAVE_API FloatMatrix min (const FloatMatrix& a, const FloatMatrix& b);
 
 extern OCTAVE_API FloatMatrix max (float d, const FloatMatrix& m);
 extern OCTAVE_API FloatMatrix max (const FloatMatrix& m, float d);
 extern OCTAVE_API FloatMatrix max (const FloatMatrix& a, const FloatMatrix& b);
diff --git a/liboctave/array/fNDArray.cc b/liboctave/array/fNDArray.cc
--- a/liboctave/array/fNDArray.cc
+++ b/liboctave/array/fNDArray.cc
@@ -105,17 +105,17 @@ FloatNDArray::ifourier (int dim) const
   octave_idx_type dist = (stride == 1 ? n : 1);
 
   FloatComplexNDArray retval (*this);
   FloatComplex *out (retval.fortran_vec ());
 
   // Need to be careful here about the distance between fft's
   for (octave_idx_type k = 0; k < nloop; k++)
     octave_fftw::ifft (out + k * stride * n, out + k * stride * n,
-                      n, howmany, stride, dist);
+                       n, howmany, stride, dist);
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::fourier2d (void) const
 {
   dim_vector dv = dims ();
@@ -289,17 +289,17 @@ FloatNDArray::ifourier (int dim) const
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem ((i + k*npts)*stride + j*dist);
 
           F77_FUNC (cfftb, CFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
             retval((i + k*npts)*stride + j*dist) = tmp[i] /
-              static_cast<float> (npts);
+                                                   static_cast<float> (npts);
         }
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::fourier2d (void) const
@@ -382,18 +382,18 @@ FloatNDArray::ifourier2d (void) const
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
                 prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) = prow[l] /
-                  static_cast<float> (npts);
+                retval((l + k*npts)*stride + j*dist) =
+                  prow[l] / static_cast<float> (npts);
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
@@ -477,18 +477,18 @@ FloatNDArray::ifourierNd (void) const
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
                 prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval((l + k*npts)*stride + j*dist) = prow[l] /
-                  static_cast<float> (npts);
+                retval((l + k*npts)*stride + j*dist) =
+                  prow[l] / static_cast<float> (npts);
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
 }
@@ -590,17 +590,17 @@ FloatNDArray::all_integers (void) const
 }
 
 bool
 FloatNDArray::too_large_for_float (void) const
 {
   return false;
 }
 
-// FIXME -- this is not quite the right thing.
+// FIXME: this is not quite the right thing.
 
 boolNDArray
 FloatNDArray::all (int dim) const
 {
   return do_mx_red_op<bool, float> (*this, dim, mx_inline_all);
 }
 
 boolNDArray
@@ -695,34 +695,37 @@ FloatNDArray::cummin (Array<octave_idx_t
 
 FloatNDArray
 FloatNDArray::diff (octave_idx_type order, int dim) const
 {
   return do_mx_diff_op<float> (*this, dim, order, mx_inline_diff);
 }
 
 FloatNDArray
-FloatNDArray::concat (const FloatNDArray& rb, const Array<octave_idx_type>& ra_idx)
+FloatNDArray::concat (const FloatNDArray& rb,
+                      const Array<octave_idx_type>& ra_idx)
 {
   if (rb.numel () > 0)
     insert (rb, ra_idx);
   return *this;
 }
 
 FloatComplexNDArray
-FloatNDArray::concat (const FloatComplexNDArray& rb, const Array<octave_idx_type>& ra_idx)
+FloatNDArray::concat (const FloatComplexNDArray& rb,
+                      const Array<octave_idx_type>& ra_idx)
 {
   FloatComplexNDArray retval (*this);
   if (rb.numel () > 0)
     retval.insert (rb, ra_idx);
   return retval;
 }
 
 charNDArray
-FloatNDArray::concat (const charNDArray& rb, const Array<octave_idx_type>& ra_idx)
+FloatNDArray::concat (const charNDArray& rb,
+                      const Array<octave_idx_type>& ra_idx)
 {
   charNDArray retval (dims ());
   octave_idx_type nel = numel ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       float d = elem (i);
 
@@ -732,18 +735,17 @@ FloatNDArray::concat (const charNDArray&
             ("invalid conversion from NaN to character");
           return retval;
         }
       else
         {
           octave_idx_type ival = NINTbig (d);
 
           if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
-            // FIXME -- is there something
-            // better we could do? Should we warn the user?
+            // FIXME: is there something better to do?  Should we warn the user?
             ival = 0;
 
           retval.elem (i) = static_cast<char>(ival);
         }
     }
 
   if (rb.numel () == 0)
     return retval;
@@ -760,24 +762,26 @@ real (const FloatComplexNDArray& a)
 
 FloatNDArray
 imag (const FloatComplexNDArray& a)
 {
   return do_mx_unary_op<float, FloatComplex> (a, mx_inline_imag);
 }
 
 FloatNDArray&
-FloatNDArray::insert (const FloatNDArray& a, octave_idx_type r, octave_idx_type c)
+FloatNDArray::insert (const FloatNDArray& a,
+                      octave_idx_type r, octave_idx_type c)
 {
   Array<float>::insert (a, r, c);
   return *this;
 }
 
 FloatNDArray&
-FloatNDArray::insert (const FloatNDArray& a, const Array<octave_idx_type>& ra_idx)
+FloatNDArray::insert (const FloatNDArray& a,
+                      const Array<octave_idx_type>& ra_idx)
 {
   Array<float>::insert (a, ra_idx);
   return *this;
 }
 
 FloatNDArray
 FloatNDArray::abs (void) const
 {
@@ -803,35 +807,35 @@ FloatNDArray::isfinite (void) const
 }
 
 FloatMatrix
 FloatNDArray::matrix_value (void) const
 {
   FloatMatrix retval;
 
   if (ndims () == 2)
-      retval = FloatMatrix (Array<float> (*this));
+    retval = FloatMatrix (Array<float> (*this));
   else
     (*current_liboctave_error_handler)
       ("invalid conversion of FloatNDArray to FloatMatrix");
 
   return retval;
 }
 
 void
 FloatNDArray::increment_index (Array<octave_idx_type>& ra_idx,
-                          const dim_vector& dimensions,
-                          int start_dimension)
+                               const dim_vector& dimensions,
+                               int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
 octave_idx_type
 FloatNDArray::compute_index (Array<octave_idx_type>& ra_idx,
-                        const dim_vector& dimensions)
+                             const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 FloatNDArray
 FloatNDArray::diag (octave_idx_type k) const
 {
   return MArray<float>::diag (k);
@@ -862,26 +866,26 @@ std::istream&
 operator >> (std::istream& is, FloatNDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
   if (nel > 0)
     {
       float tmp;
       for (octave_idx_type i = 0; i < nel; i++)
-          {
-            tmp = octave_read_value<float> (is);
-            if (is)
-              a.elem (i) = tmp;
-            else
-              goto done;
-          }
+        {
+          tmp = octave_read_value<float> (is);
+          if (is)
+            a.elem (i) = tmp;
+          else
+            goto done;
+        }
     }
 
- done:
+done:
 
   return is;
 }
 
 MINMAX_FCNS (FloatNDArray, float)
 
 NDS_CMP_OPS (FloatNDArray, float)
 NDS_BOOL_OPS (FloatNDArray, float)
diff --git a/liboctave/array/fNDArray.h b/liboctave/array/fNDArray.h
--- a/liboctave/array/fNDArray.h
+++ b/liboctave/array/fNDArray.h
@@ -57,65 +57,70 @@ public:
   FloatNDArray (const Array<U>& a) : MArray<float> (a) { }
 
   template <class U>
   explicit FloatNDArray (const intNDArray<U>& a) : MArray<float> (a) { }
 
   FloatNDArray (const charNDArray&);
 
   FloatNDArray& operator = (const FloatNDArray& a)
-    {
-      MArray<float>::operator = (a);
-      return *this;
-    }
+  {
+    MArray<float>::operator = (a);
+    return *this;
+  }
 
   // unary operations
 
   boolNDArray operator ! (void) const;
 
   bool any_element_is_negative (bool = false) const;
   bool any_element_is_positive (bool = false) const;
   bool any_element_is_nan (void) const;
   bool any_element_is_inf_or_nan (void) const;
   bool any_element_not_one_or_zero (void) const;
   bool all_elements_are_zero (void) const;
   bool all_elements_are_int_or_inf_or_nan (void) const;
   bool all_integers (float& max_val, float& min_val) const;
   bool all_integers (void) const;
   bool too_large_for_float (void) const;
 
-  // FIXME -- this is not quite the right thing.
+  // FIXME: this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
   FloatNDArray cumprod (int dim = -1) const;
   FloatNDArray cumsum (int dim = -1) const;
   FloatNDArray prod (int dim = -1) const;
   FloatNDArray sum (int dim = -1) const;
-       NDArray dsum (int dim = -1) const;
+  NDArray dsum (int dim = -1) const;
   FloatNDArray sumsq (int dim = -1) const;
-  FloatNDArray concat (const FloatNDArray& rb, const Array<octave_idx_type>& ra_idx);
-  FloatComplexNDArray concat (const FloatComplexNDArray& rb, const Array<octave_idx_type>& ra_idx);
-  charNDArray concat (const charNDArray& rb, const Array<octave_idx_type>& ra_idx);
+  FloatNDArray concat (const FloatNDArray& rb,
+                       const Array<octave_idx_type>& ra_idx);
+  FloatComplexNDArray concat (const FloatComplexNDArray& rb,
+                              const Array<octave_idx_type>& ra_idx);
+  charNDArray concat (const charNDArray& rb,
+                      const Array<octave_idx_type>& ra_idx);
 
   FloatNDArray max (int dim = -1) const;
   FloatNDArray max (Array<octave_idx_type>& index, int dim = -1) const;
   FloatNDArray min (int dim = -1) const;
   FloatNDArray min (Array<octave_idx_type>& index, int dim = -1) const;
 
   FloatNDArray cummax (int dim = -1) const;
   FloatNDArray cummax (Array<octave_idx_type>& index, int dim = -1) const;
   FloatNDArray cummin (int dim = -1) const;
   FloatNDArray cummin (Array<octave_idx_type>& index, int dim = -1) const;
 
   FloatNDArray diff (octave_idx_type order = 1, int dim = -1) const;
 
-  FloatNDArray& insert (const FloatNDArray& a, octave_idx_type r, octave_idx_type c);
-  FloatNDArray& insert (const FloatNDArray& a, const Array<octave_idx_type>& ra_idx);
+  FloatNDArray& insert (const FloatNDArray& a,
+                        octave_idx_type r, octave_idx_type c);
+  FloatNDArray& insert (const FloatNDArray& a,
+                        const Array<octave_idx_type>& ra_idx);
 
   FloatNDArray abs (void) const;
   boolNDArray isnan (void) const;
   boolNDArray isinf (void) const;
   boolNDArray isfinite (void) const;
 
   FloatComplexNDArray fourier (int dim = 1) const;
   FloatComplexNDArray ifourier (int dim = 1) const;
@@ -135,32 +140,33 @@ public:
 
   FloatNDArray squeeze (void) const { return MArray<float>::squeeze (); }
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
-                            const dim_vector& dimensions);
+                                        const dim_vector& dimensions);
 
   // i/o
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatNDArray& a);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const FloatNDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatNDArray& a);
 
   FloatNDArray diag (octave_idx_type k = 0) const;
 
   FloatNDArray diag (octave_idx_type m, octave_idx_type n) const;
 
   FloatNDArray& changesign (void)
-    {
-      MArray<float>::changesign ();
-      return *this;
-    }
+  {
+    MArray<float>::changesign ();
+    return *this;
+  }
 
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API FloatNDArray real (const FloatComplexNDArray& a);
 extern OCTAVE_API FloatNDArray imag (const FloatComplexNDArray& a);
 
diff --git a/liboctave/array/fRowVector.h b/liboctave/array/fRowVector.h
--- a/liboctave/array/fRowVector.h
+++ b/liboctave/array/fRowVector.h
@@ -46,20 +46,20 @@ public:
 
   FloatRowVector (const FloatRowVector& a) : MArray<float> (a) { }
 
   FloatRowVector (const MArray<float>& a) : MArray<float> (a.as_row ()) { }
 
   FloatRowVector (const Array<float>& a) : MArray<float> (a.as_row ()) { }
 
   FloatRowVector& operator = (const FloatRowVector& a)
-    {
-      MArray<float>::operator = (a);
-      return *this;
-    }
+  {
+    MArray<float>::operator = (a);
+    return *this;
+  }
 
   bool operator == (const FloatRowVector& a) const;
   bool operator != (const FloatRowVector& a) const;
 
   // destructive insert/delete/reorder operations
 
   FloatRowVector& insert (const FloatRowVector& a, octave_idx_type c);
 
@@ -76,43 +76,48 @@ public:
   // resize is the destructive equivalent for this one
 
   FloatRowVector extract (octave_idx_type c1, octave_idx_type c2) const;
 
   FloatRowVector extract_n (octave_idx_type c1, octave_idx_type n) const;
 
   // row vector by matrix -> row vector
 
-  friend OCTAVE_API FloatRowVector operator * (const FloatRowVector& a, const FloatMatrix& b);
+  friend OCTAVE_API FloatRowVector operator * (const FloatRowVector& a,
+                                               const FloatMatrix& b);
 
   // other operations
 
   float min (void) const;
   float max (void) const;
 
   // i/o
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatRowVector& a);
-  friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatRowVector& a);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const FloatRowVector& a);
+  friend OCTAVE_API std::istream& operator >> (std::istream& is,
+                                               FloatRowVector& a);
 
   void resize (octave_idx_type n, const float& rfv = 0)
   {
     Array<float>::resize (dim_vector (1, n), rfv);
   }
 
   void clear (octave_idx_type n)
-    { Array<float>::clear (1, n); }
+  { Array<float>::clear (1, n); }
 
 };
 
 // row vector by column vector -> scalar
 
-float OCTAVE_API operator * (const FloatRowVector& a, const FloatColumnVector& b);
+float OCTAVE_API operator * (const FloatRowVector& a,
+                             const FloatColumnVector& b);
 
-Complex OCTAVE_API operator * (const FloatRowVector& a, const ComplexColumnVector& b);
+Complex OCTAVE_API operator * (const FloatRowVector& a,
+                               const ComplexColumnVector& b);
 
 // other operations
 
 OCTAVE_API FloatRowVector linspace (float x1, float x2, octave_idx_type n);
 
 MARRAY_FORWARD_DEFS (MArray, FloatRowVector, float)
 
 #endif
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -326,20 +326,20 @@ idx_vector::idx_vector_rep::idx_vector_r
   if (len != 0)
     {
       octave_idx_type *d = new octave_idx_type [len];
       for (octave_idx_type i = 0; i < len; i++)
         d[i] = convert_index (nda.xelem (i), err, ext);
       data = d;
 
       if (err)
-      {
-        delete [] data;
-        gripe_invalid_index ();
-      }
+        {
+          delete [] data;
+          gripe_invalid_index ();
+        }
     }
 }
 
 // Note that this makes a shallow copy of the index array.
 
 idx_vector::idx_vector_rep::idx_vector_rep (const Array<octave_idx_type>& inda)
   : data (inda.data ()), len (inda.numel ()), ext (0),
     aowner (new Array<octave_idx_type> (inda)), orig_dims (inda.dims ())
@@ -438,17 +438,17 @@ idx_vector::idx_vector_rep::idx_vector_r
       octave_idx_type k = 0;
       octave_idx_type nc = bnda.cols ();
       octave_idx_type nr = bnda.rows ();
 
       for (octave_idx_type j = 0; j < nc; j++)
         for (octave_idx_type i = bnda.cidx(j); i < bnda.cidx(j+1); i++)
           if (bnda.data (i))
             d[k++] = j * nr + bnda.ridx (i);
- 
+
       data = d;
 
       ext = d[k-1] + 1;
     }
 }
 
 idx_vector::idx_vector_rep::~idx_vector_rep (void)
 {
@@ -491,17 +491,18 @@ idx_vector::idx_vector_rep::sort_uniq_cl
 
       std::copy (data, data + len, new_data);
       octave_sort<octave_idx_type> lsort;
       lsort.set_compare (ASCENDING);
       lsort.sort (new_data, len);
 
       if (uniq)
         {
-          octave_idx_type new_len = std::unique (new_data, new_data + len) - new_data;
+          octave_idx_type new_len = std::unique (new_data, new_data + len)
+                                    - new_data;
           new_rep->len = new_len;
           if (new_rep->orig_dims.length () == 2 && new_rep->orig_dims(0) == 1)
             new_rep->orig_dims = dim_vector (1, new_len);
           else
             new_rep->orig_dims = dim_vector (new_len, 1);
         }
     }
   else if (uniq)
@@ -1091,17 +1092,17 @@ idx_vector::copy_data (octave_idx_type *
       {
         idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
         const bool *mask = r->get_data ();
         octave_idx_type ext = r->extent (0);
         for (octave_idx_type i = 0, j = 0; i < ext; i++)
           if (mask[i])
             data[j++] = i;
       }
-    break;
+      break;
 
     default:
       assert (false);
       break;
     }
 }
 
 idx_vector
@@ -1147,17 +1148,17 @@ idx_vector::is_permutation (octave_idx_t
       OCTAVE_LOCAL_BUFFER_INIT (bool, left, n, true);
 
       retval = true;
 
       for (octave_idx_type i = 0, len = length (); i < len; i++)
         {
           octave_idx_type k = xelem (i);
           if (left[k])
-              left[k] = false;
+            left[k] = false;
           else
             {
               retval = false;
               break;
             }
         }
     }
 
diff --git a/liboctave/array/idx-vector.h b/liboctave/array/idx-vector.h
--- a/liboctave/array/idx-vector.h
+++ b/liboctave/array/idx-vector.h
@@ -50,24 +50,24 @@ class Range;
 
 class
 OCTAVE_API
 idx_vector
 {
 public:
 
   enum idx_class_type
-    {
-      class_invalid = -1,
-      class_colon = 0,
-      class_range,
-      class_scalar,
-      class_vector,
-      class_mask
-    };
+  {
+    class_invalid = -1,
+    class_colon = 0,
+    class_range,
+    class_scalar,
+    class_vector,
+    class_mask
+  };
 
   template<class T> friend class std::auto_ptr;
 
 private:
 
   class OCTAVE_API idx_base_rep
   {
   public:
@@ -93,17 +93,17 @@ private:
     // Sorts, maybe uniqifies, and returns a clone object pointer.
     virtual idx_base_rep *sort_uniq_clone (bool uniq = false) = 0;
     // Sorts, and returns a sorting permutation (aka Array::sort).
     virtual idx_base_rep *sort_idx (Array<octave_idx_type>&) = 0;
 
     // Checks whether the index is colon or a range equivalent to colon.
     virtual bool is_colon_equiv (octave_idx_type) const { return false; }
 
-    // The original dimensions of this object (used when subscribing by matrices).
+    // The original dimensions of object (used when subscribing by matrices).
     virtual dim_vector orig_dimensions (void) const { return dim_vector (); }
 
     // i/o
     virtual std::ostream& print (std::ostream& os) const = 0;
 
     virtual Array<octave_idx_type> as_array (void);
 
     octave_refcount<int> count;
@@ -131,17 +131,17 @@ private:
 
     octave_idx_type length (octave_idx_type n) const { return n; }
 
     octave_idx_type extent (octave_idx_type n) const { return n; }
 
     idx_class_type idx_class (void) const { return class_colon; }
 
     idx_base_rep *sort_uniq_clone (bool = false)
-      { count++; return this; }
+    { count++; return this; }
 
     idx_base_rep *sort_idx (Array<octave_idx_type>&);
 
     bool is_colon_equiv (octave_idx_type) const { return true; }
 
     std::ostream& print (std::ostream& os) const;
 
   private:
@@ -169,36 +169,37 @@ private:
 
     // Zero-based constructor.
     idx_range_rep (octave_idx_type _start, octave_idx_type _limit,
                    octave_idx_type _step);
 
     idx_range_rep (const Range&);
 
     octave_idx_type xelem (octave_idx_type i) const
-      { return start + i * step; }
+    { return start + i * step; }
 
     octave_idx_type checkelem (octave_idx_type i) const;
 
     octave_idx_type length (octave_idx_type) const { return len; }
 
     octave_idx_type extent (octave_idx_type n) const
-      { return len ? std::max (n, (start + 1 + (step < 0 ? 0 : step * (len - 1)))) : n; }
+    { return len ? std::max (n, (start + 1 + (step < 0 ? 0 : step * (len - 1))))
+                 : n; }
 
     idx_class_type idx_class (void) const { return class_range; }
 
     idx_base_rep *sort_uniq_clone (bool uniq = false);
 
     idx_base_rep *sort_idx (Array<octave_idx_type>&);
 
     bool is_colon_equiv (octave_idx_type n) const
-      { return start == 0 && step == 1 && len == n; }
+    { return start == 0 && step == 1 && len == n; }
 
     dim_vector orig_dimensions (void) const
-      { return dim_vector (1, len); }
+    { return dim_vector (1, len); }
 
     octave_idx_type get_start (void) const { return start; }
 
     octave_idx_type get_step (void) const { return step; }
 
     std::ostream& print (std::ostream& os) const;
 
     Range unconvert (void) const;
@@ -235,27 +236,27 @@ private:
 
     octave_idx_type xelem (octave_idx_type) const { return data; }
 
     octave_idx_type checkelem (octave_idx_type i) const;
 
     octave_idx_type length (octave_idx_type) const { return 1; }
 
     octave_idx_type extent (octave_idx_type n) const
-      { return std::max (n, data + 1); }
+    { return std::max (n, data + 1); }
 
     idx_class_type idx_class (void) const { return class_scalar; }
 
     idx_base_rep *sort_uniq_clone (bool = false)
-      { count++; return this; }
+    { count++; return this; }
 
     idx_base_rep *sort_idx (Array<octave_idx_type>&);
 
     bool is_colon_equiv (octave_idx_type n) const
-      { return n == 1 && data == 0; }
+    { return n == 1 && data == 0; }
 
     dim_vector orig_dimensions (void) const { return dim_vector (1, 1); }
 
     octave_idx_type get_data (void) const { return data; }
 
     std::ostream& print (std::ostream& os) const;
 
     double unconvert (void) const;
@@ -280,17 +281,17 @@ private:
   public:
     // Direct constructor.
     idx_vector_rep (octave_idx_type *_data, octave_idx_type _len,
                     octave_idx_type _ext, const dim_vector& od, direct)
       : data (_data), len (_len), ext (_ext), aowner (0), orig_dims (od) { }
 
     idx_vector_rep (void)
       : data (0), len (0), ext (0), aowner (0), orig_dims ()
-      { }
+    { }
 
     // Zero-based constructor.
     idx_vector_rep (const Array<octave_idx_type>& inda);
 
     idx_vector_rep (const Array<octave_idx_type>& inda,
                     octave_idx_type _ext, direct);
 
     template <class T>
@@ -306,17 +307,17 @@ private:
 
     octave_idx_type xelem (octave_idx_type i) const { return data[i]; }
 
     octave_idx_type checkelem (octave_idx_type i) const;
 
     octave_idx_type length (octave_idx_type) const { return len; }
 
     octave_idx_type extent (octave_idx_type n) const
-      { return std::max (n, ext); }
+    { return std::max (n, ext); }
 
     idx_class_type idx_class (void) const { return class_vector; }
 
     idx_base_rep *sort_uniq_clone (bool uniq = false);
 
     idx_base_rep *sort_idx (Array<octave_idx_type>&);
 
     dim_vector orig_dimensions (void) const { return orig_dims; }
@@ -361,44 +362,44 @@ private:
     idx_mask_rep (bool *_data, octave_idx_type _len,
                   octave_idx_type _ext, const dim_vector& od, direct)
       : data (_data), len (_len), ext (_ext), lsti (-1), lste (-1),
         aowner (0), orig_dims (od) { }
 
     idx_mask_rep (void)
       : data (0), len (0), ext (0), lsti (-1), lste (-1), aowner (0),
         orig_dims ()
-      { }
+    { }
 
     idx_mask_rep (bool);
 
     idx_mask_rep (const Array<bool>&, octave_idx_type = -1);
 
     ~idx_mask_rep (void);
 
     octave_idx_type xelem (octave_idx_type i) const;
 
     octave_idx_type checkelem (octave_idx_type i) const;
 
     octave_idx_type length (octave_idx_type) const { return len; }
 
     octave_idx_type extent (octave_idx_type n) const
-      { return std::max (n, ext); }
+    { return std::max (n, ext); }
 
     idx_class_type idx_class (void) const { return class_mask; }
 
     idx_base_rep *sort_uniq_clone (bool = false)
-      { count++; return this; }
+    { count++; return this; }
 
     idx_base_rep *sort_idx (Array<octave_idx_type>&);
 
     dim_vector orig_dimensions (void) const { return orig_dims; }
 
     bool is_colon_equiv (octave_idx_type n) const
-      { return len == n && ext == n; }
+    { return len == n && ext == n; }
 
     const bool *get_data (void) const { return data; }
 
     std::ostream& print (std::ostream& os) const;
 
     Array<bool> unconvert (void) const;
 
     Array<octave_idx_type> as_array (void);
@@ -432,71 +433,71 @@ private:
     dim_vector orig_dims;
   };
 
   idx_vector (idx_base_rep *r) : rep (r) { }
 
   // The shared empty vector representation (for fast default
   // constructor).
   static idx_vector_rep *nil_rep (void)
-    {
-      static idx_vector_rep ivr;
-      return &ivr;
-    }
+  {
+    static idx_vector_rep ivr;
+    return &ivr;
+  }
 
   // The shared empty vector representation with the error flag set.
   static idx_vector_rep *err_rep (void)
-    {
-      static idx_vector_rep ivr;
-      ivr.err = true;
-      return &ivr;
-    }
+  {
+    static idx_vector_rep ivr;
+    ivr.err = true;
+    return &ivr;
+  }
 
   // If there was an error in constructing the rep, replace it with
   // empty vector for safety.
   void chkerr (void)
-    {
-      if (rep->err)
-        {
-          if (--rep->count == 0)
-            delete rep;
-          rep = err_rep ();
-          rep->count++;
-        }
-    }
+  {
+    if (rep->err)
+      {
+        if (--rep->count == 0)
+          delete rep;
+        rep = err_rep ();
+        rep->count++;
+      }
+  }
 
 public:
 
   // Fast empty constructor.
   idx_vector (void) : rep (nil_rep ()) { rep->count++; }
 
   // Zero-based constructors (for use from C++).
   idx_vector (octave_idx_type i) : rep (new idx_scalar_rep (i))
-    { chkerr (); }
+  { chkerr (); }
 
   idx_vector (octave_idx_type start, octave_idx_type limit,
               octave_idx_type step = 1)
     : rep (new idx_range_rep (start, limit, step))
-    { chkerr (); }
+  { chkerr (); }
 
   static idx_vector
-    make_range (octave_idx_type start, octave_idx_type step,
-                octave_idx_type len)
-    {
-      return idx_vector (new idx_range_rep (start, len, step, DIRECT));
-    }
+  make_range (octave_idx_type start, octave_idx_type step,
+              octave_idx_type len)
+  {
+    return idx_vector (new idx_range_rep (start, len, step, DIRECT));
+  }
 
   idx_vector (const Array<octave_idx_type>& inda)
     : rep (new idx_vector_rep (inda))
-    { chkerr (); }
+  { chkerr (); }
 
   // Directly pass extent, no checking.
   idx_vector (const Array<octave_idx_type>& inda, octave_idx_type ext)
     : rep (new idx_vector_rep (inda, ext, DIRECT))
-    { }
+  { }
 
   // Colon is best constructed by simply copying (or referencing) this member.
   static const idx_vector colon;
 
   // or passing ':' here
   idx_vector (char c) : rep (new idx_colon_rep (c)) { chkerr (); }
 
   // Conversion constructors (used by interpreter).
@@ -508,479 +509,479 @@ public:
 
   idx_vector (float x) : rep (new idx_scalar_rep (x)) { chkerr (); }
 
   // A scalar bool does not necessarily map to scalar index.
   idx_vector (bool x) : rep (new idx_mask_rep (x)) { chkerr (); }
 
   template <class T>
   idx_vector (const Array<octave_int<T> >& nda) : rep (new idx_vector_rep (nda))
-    { chkerr (); }
+  { chkerr (); }
 
   idx_vector (const Array<double>& nda) : rep (new idx_vector_rep (nda))
-    { chkerr (); }
+  { chkerr (); }
 
   idx_vector (const Array<float>& nda) : rep (new idx_vector_rep (nda))
-    { chkerr (); }
+  { chkerr (); }
 
   idx_vector (const Array<bool>& nda);
 
   idx_vector (const Range& r)
     : rep (new idx_range_rep (r))
-    { chkerr (); }
+  { chkerr (); }
 
   idx_vector (const Sparse<bool>& nda) : rep (new idx_vector_rep (nda))
-    { chkerr (); }
+  { chkerr (); }
 
   idx_vector (const idx_vector& a) : rep (a.rep) { rep->count++; }
 
   ~idx_vector (void)
-    {
-      if (--rep->count == 0)
-        delete rep;
-    }
+  {
+    if (--rep->count == 0)
+      delete rep;
+  }
 
   idx_vector& operator = (const idx_vector& a)
-    {
-      if (this != &a)
-        {
-          if (--rep->count == 0)
-            delete rep;
+  {
+    if (this != &a)
+      {
+        if (--rep->count == 0)
+          delete rep;
 
-          rep = a.rep;
-          rep->count++;
-        }
-      return *this;
-    }
+        rep = a.rep;
+        rep->count++;
+      }
+    return *this;
+  }
 
   idx_class_type idx_class (void) const { return rep->idx_class (); }
 
   octave_idx_type length (octave_idx_type n = 0) const
-    { return rep->length (n); }
+  { return rep->length (n); }
 
   octave_idx_type extent (octave_idx_type n) const
-    { return rep->extent (n); }
+  { return rep->extent (n); }
 
   octave_idx_type xelem (octave_idx_type n) const
-    { return rep->xelem (n); }
+  { return rep->xelem (n); }
 
   octave_idx_type checkelem (octave_idx_type n) const
-    { return rep->checkelem (n); }
+  { return rep->checkelem (n); }
 
   octave_idx_type operator () (octave_idx_type n) const
-    {
+  {
 #if defined (BOUNDS_CHECKING)
-      return rep->checkelem (n);
+    return rep->checkelem (n);
 #else
-      return rep->xelem (n);
+    return rep->xelem (n);
 #endif
-    }
+  }
 
   operator bool (void) const
-    { return ! rep->err; }
+  { return ! rep->err; }
 
   bool is_colon (void) const
-    { return rep->idx_class () == class_colon; }
+  { return rep->idx_class () == class_colon; }
 
   bool is_scalar (void) const
-    { return rep->idx_class () == class_scalar; }
+  { return rep->idx_class () == class_scalar; }
 
   bool is_range (void) const
-    { return rep->idx_class () == class_range; }
+  { return rep->idx_class () == class_range; }
 
   bool is_colon_equiv (octave_idx_type n) const
-    { return rep->is_colon_equiv (n); }
+  { return rep->is_colon_equiv (n); }
 
   idx_vector sorted (bool uniq = false) const
-    { return idx_vector (rep->sort_uniq_clone (uniq)); }
+  { return idx_vector (rep->sort_uniq_clone (uniq)); }
 
   idx_vector sorted (Array<octave_idx_type>& sidx) const
-    { return idx_vector (rep->sort_idx (sidx)); }
+  { return idx_vector (rep->sort_idx (sidx)); }
 
   dim_vector orig_dimensions (void) const { return rep->orig_dimensions (); }
 
   octave_idx_type orig_rows (void) const
-    { return orig_dimensions () (0); }
+  { return orig_dimensions () (0); }
 
   octave_idx_type orig_columns (void) const
-    { return orig_dimensions () (1); }
+  { return orig_dimensions () (1); }
 
   int orig_empty (void) const
-    { return (! is_colon () && orig_dimensions ().any_zero ()); }
+  { return (! is_colon () && orig_dimensions ().any_zero ()); }
 
   // i/o
 
   std::ostream& print (std::ostream& os) const { return rep->print (os); }
 
   friend std::ostream& operator << (std::ostream& os, const idx_vector& a)
-    { return a.print (os); }
+  { return a.print (os); }
 
   // Slice with specializations. No checking of bounds!
   //
   // This is equivalent to the following loop (but much faster):
   //
   // for (octave_idx_type i = 0; i < idx->length (n); i++)
   //   dest[i] = src[idx(i)];
   // return i;
   //
   template <class T>
   octave_idx_type
   index (const T *src, octave_idx_type n, T *dest) const
-    {
-      octave_idx_type len = rep->length (n);
+  {
+    octave_idx_type len = rep->length (n);
 
-      switch (rep->idx_class ())
-        {
-        case class_colon:
-          copy_or_memcpy (len, src, dest);
-          break;
+    switch (rep->idx_class ())
+      {
+      case class_colon:
+        copy_or_memcpy (len, src, dest);
+        break;
 
-        case class_range:
-          {
-            idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
-            octave_idx_type start = r->get_start (), step = r->get_step ();
-            const T *ssrc = src + start;
-            if (step == 1)
-              copy_or_memcpy (len, ssrc, dest);
-            else if (step == -1)
-              std::reverse_copy (ssrc - len + 1, ssrc + 1, dest);
-            else if (step == 0)
-              std::fill_n (dest, len, *ssrc);
-            else
-              {
-                for (octave_idx_type i = 0, j = 0; i < len; i++, j += step)
-                  dest[i] = ssrc[j];
-              }
-          }
-          break;
+      case class_range:
+        {
+          idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
+          octave_idx_type start = r->get_start (), step = r->get_step ();
+          const T *ssrc = src + start;
+          if (step == 1)
+            copy_or_memcpy (len, ssrc, dest);
+          else if (step == -1)
+            std::reverse_copy (ssrc - len + 1, ssrc + 1, dest);
+          else if (step == 0)
+            std::fill_n (dest, len, *ssrc);
+          else
+            {
+              for (octave_idx_type i = 0, j = 0; i < len; i++, j += step)
+                dest[i] = ssrc[j];
+            }
+        }
+        break;
 
-        case class_scalar:
-          {
-            idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
-            dest[0] = src[r->get_data ()];
-          }
-          break;
+      case class_scalar:
+        {
+          idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
+          dest[0] = src[r->get_data ()];
+        }
+        break;
 
-        case class_vector:
-          {
-            idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
-            const octave_idx_type *data = r->get_data ();
-            for (octave_idx_type i = 0; i < len; i++)
-              dest[i] = src[data[i]];
-          }
-          break;
+      case class_vector:
+        {
+          idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
+          const octave_idx_type *data = r->get_data ();
+          for (octave_idx_type i = 0; i < len; i++)
+            dest[i] = src[data[i]];
+        }
+        break;
 
-        case class_mask:
-          {
-            idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
-            const bool *data = r->get_data ();
-            octave_idx_type ext = r->extent (0);
-            for (octave_idx_type i = 0; i < ext; i++)
-              if (data[i]) *dest++ = src[i];
-          }
-          break;
+      case class_mask:
+        {
+          idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
+          const bool *data = r->get_data ();
+          octave_idx_type ext = r->extent (0);
+          for (octave_idx_type i = 0; i < ext; i++)
+            if (data[i]) *dest++ = src[i];
+        }
+        break;
 
-        default:
-          assert (false);
-          break;
-        }
+      default:
+        assert (false);
+        break;
+      }
 
-      return len;
-    }
+    return len;
+  }
 
   // Slice assignment with specializations. No checking of bounds!
   //
   // This is equivalent to the following loop (but much faster):
   //
   // for (octave_idx_type i = 0; i < idx->length (n); i++)
   //   dest[idx(i)] = src[i];
   // return i;
   //
   template <class T>
   octave_idx_type
   assign (const T *src, octave_idx_type n, T *dest) const
-    {
-      octave_idx_type len = rep->length (n);
+  {
+    octave_idx_type len = rep->length (n);
 
-      switch (rep->idx_class ())
-        {
-        case class_colon:
-          copy_or_memcpy (len, src, dest);
-          break;
+    switch (rep->idx_class ())
+      {
+      case class_colon:
+        copy_or_memcpy (len, src, dest);
+        break;
 
-        case class_range:
-          {
-            idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
-            octave_idx_type start = r->get_start (), step = r->get_step ();
-            T *sdest = dest + start;
-            if (step == 1)
-              copy_or_memcpy (len, src, sdest);
-            else if (step == -1)
-              std::reverse_copy (src, src + len, sdest - len + 1);
-            else
-              {
-                for (octave_idx_type i = 0, j = 0; i < len; i++, j += step)
-                  sdest[j] = src[i];
-              }
-          }
-          break;
+      case class_range:
+        {
+          idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
+          octave_idx_type start = r->get_start (), step = r->get_step ();
+          T *sdest = dest + start;
+          if (step == 1)
+            copy_or_memcpy (len, src, sdest);
+          else if (step == -1)
+            std::reverse_copy (src, src + len, sdest - len + 1);
+          else
+            {
+              for (octave_idx_type i = 0, j = 0; i < len; i++, j += step)
+                sdest[j] = src[i];
+            }
+        }
+        break;
 
-        case class_scalar:
-          {
-            idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
-            dest[r->get_data ()] = src[0];
-          }
-          break;
+      case class_scalar:
+        {
+          idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
+          dest[r->get_data ()] = src[0];
+        }
+        break;
 
-        case class_vector:
-          {
-            idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
-            const octave_idx_type *data = r->get_data ();
-            for (octave_idx_type i = 0; i < len; i++)
-              dest[data[i]] = src[i];
-          }
-          break;
+      case class_vector:
+        {
+          idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
+          const octave_idx_type *data = r->get_data ();
+          for (octave_idx_type i = 0; i < len; i++)
+            dest[data[i]] = src[i];
+        }
+        break;
 
-        case class_mask:
-          {
-            idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
-            const bool *data = r->get_data ();
-            octave_idx_type ext = r->extent (0);
-            for (octave_idx_type i = 0; i < ext; i++)
-              if (data[i]) dest[i] = *src++;
-          }
-          break;
+      case class_mask:
+        {
+          idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
+          const bool *data = r->get_data ();
+          octave_idx_type ext = r->extent (0);
+          for (octave_idx_type i = 0; i < ext; i++)
+            if (data[i]) dest[i] = *src++;
+        }
+        break;
 
-        default:
-          assert (false);
-          break;
-        }
+      default:
+        assert (false);
+        break;
+      }
 
-      return len;
-    }
+    return len;
+  }
 
   // Slice fill with specializations. No checking of bounds!
   //
   // This is equivalent to the following loop (but much faster):
   //
   // for (octave_idx_type i = 0; i < idx->length (n); i++)
   //   dest[idx(i)] = val;
   // return i;
   //
   template <class T>
   octave_idx_type
   fill (const T& val, octave_idx_type n, T *dest) const
-    {
-      octave_idx_type len = rep->length (n);
+  {
+    octave_idx_type len = rep->length (n);
 
-      switch (rep->idx_class ())
-        {
-        case class_colon:
-          std::fill (dest, dest + len, val);
-          break;
+    switch (rep->idx_class ())
+      {
+      case class_colon:
+        std::fill (dest, dest + len, val);
+        break;
 
-        case class_range:
-          {
-            idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
-            octave_idx_type start = r->get_start (), step = r->get_step ();
-            T *sdest = dest + start;
-            if (step == 1)
-              std::fill (sdest, sdest + len, val);
-            else if (step == -1)
-              std::fill (sdest - len + 1, sdest + 1, val);
-            else
-              {
-                for (octave_idx_type i = 0, j = 0; i < len; i++, j += step)
-                  sdest[j] = val;
-              }
-          }
-          break;
+      case class_range:
+        {
+          idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
+          octave_idx_type start = r->get_start (), step = r->get_step ();
+          T *sdest = dest + start;
+          if (step == 1)
+            std::fill (sdest, sdest + len, val);
+          else if (step == -1)
+            std::fill (sdest - len + 1, sdest + 1, val);
+          else
+            {
+              for (octave_idx_type i = 0, j = 0; i < len; i++, j += step)
+                sdest[j] = val;
+            }
+        }
+        break;
 
-        case class_scalar:
-          {
-            idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
-            dest[r->get_data ()] = val;
-          }
-          break;
+      case class_scalar:
+        {
+          idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
+          dest[r->get_data ()] = val;
+        }
+        break;
 
-        case class_vector:
-          {
-            idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
-            const octave_idx_type *data = r->get_data ();
-            for (octave_idx_type i = 0; i < len; i++)
-              dest[data[i]] = val;
-          }
-          break;
+      case class_vector:
+        {
+          idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
+          const octave_idx_type *data = r->get_data ();
+          for (octave_idx_type i = 0; i < len; i++)
+            dest[data[i]] = val;
+        }
+        break;
 
-        case class_mask:
-          {
-            idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
-            const bool *data = r->get_data ();
-            octave_idx_type ext = r->extent (0);
-            for (octave_idx_type i = 0; i < ext; i++)
-              if (data[i]) dest[i] = val;
-          }
-          break;
+      case class_mask:
+        {
+          idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
+          const bool *data = r->get_data ();
+          octave_idx_type ext = r->extent (0);
+          for (octave_idx_type i = 0; i < ext; i++)
+            if (data[i]) dest[i] = val;
+        }
+        break;
 
-        default:
-          assert (false);
-          break;
-        }
+      default:
+        assert (false);
+        break;
+      }
 
-      return len;
-    }
+    return len;
+  }
 
   // Generic non-breakable indexed loop. The loop body should be
   // encapsulated in a single functor body.  This is equivalent to the
   // following loop (but faster, at least for simple inlined bodies):
   //
   // for (octave_idx_type i = 0; i < idx->length (n); i++) body (idx(i));
 
   template <class Functor>
   void
   loop (octave_idx_type n, Functor body) const
-    {
-      octave_idx_type len = rep->length (n);
+  {
+    octave_idx_type len = rep->length (n);
 
-      switch (rep->idx_class ())
-        {
-        case class_colon:
-          for (octave_idx_type i = 0; i < len; i++) body (i);
-          break;
+    switch (rep->idx_class ())
+      {
+      case class_colon:
+        for (octave_idx_type i = 0; i < len; i++) body (i);
+        break;
 
-        case class_range:
-          {
-            idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
-            octave_idx_type start = r->get_start (), step = r->get_step ();
-            octave_idx_type i, j;
-            if (step == 1)
-              for (i = start, j = start + len; i < j; i++) body (i);
-            else if (step == -1)
-              for (i = start, j = start - len; i > j; i--) body (i);
-            else
-              for (i = 0, j = start; i < len; i++, j += step) body (j);
-          }
-          break;
+      case class_range:
+        {
+          idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
+          octave_idx_type start = r->get_start (), step = r->get_step ();
+          octave_idx_type i, j;
+          if (step == 1)
+            for (i = start, j = start + len; i < j; i++) body (i);
+          else if (step == -1)
+            for (i = start, j = start - len; i > j; i--) body (i);
+          else
+            for (i = 0, j = start; i < len; i++, j += step) body (j);
+        }
+        break;
 
-        case class_scalar:
-          {
-            idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
-            body (r->get_data ());
-          }
-          break;
+      case class_scalar:
+        {
+          idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
+          body (r->get_data ());
+        }
+        break;
 
-        case class_vector:
-          {
-            idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
-            const octave_idx_type *data = r->get_data ();
-            for (octave_idx_type i = 0; i < len; i++) body (data[i]);
-          }
-          break;
+      case class_vector:
+        {
+          idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
+          const octave_idx_type *data = r->get_data ();
+          for (octave_idx_type i = 0; i < len; i++) body (data[i]);
+        }
+        break;
 
-        case class_mask:
-          {
-            idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
-            const bool *data = r->get_data ();
-            octave_idx_type ext = r->extent (0);
-            for (octave_idx_type i = 0; i < ext; i++)
-              if (data[i]) body (i);
-          }
-          break;
+      case class_mask:
+        {
+          idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
+          const bool *data = r->get_data ();
+          octave_idx_type ext = r->extent (0);
+          for (octave_idx_type i = 0; i < ext; i++)
+            if (data[i]) body (i);
+        }
+        break;
 
-        default:
-          assert (false);
-          break;
-        }
+      default:
+        assert (false);
+        break;
+      }
 
-    }
+  }
 
   // Generic breakable indexed loop. The loop body should be
   // encapsulated in a single functor body.  This is equivalent to the
   // following loop (but faster, at least for simple inlined bodies):
   //
   // for (octave_idx_type i = 0; i < idx->length (n); i++)
   //   if (body (idx(i))) break;
   // return i;
   //
 
   template <class Functor>
   octave_idx_type
   bloop (octave_idx_type n, Functor body) const
-    {
-      octave_idx_type len = rep->length (n), ret;
+  {
+    octave_idx_type len = rep->length (n), ret;
 
-      switch (rep->idx_class ())
+    switch (rep->idx_class ())
+      {
+      case class_colon:
         {
-        case class_colon:
-          {
-            octave_idx_type i;
-            for (i = 0; i < len && body (i); i++) ;
-            ret = i;
-          }
-          break;
+          octave_idx_type i;
+          for (i = 0; i < len && body (i); i++) ;
+          ret = i;
+        }
+        break;
 
-        case class_range:
-          {
-            idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
-            octave_idx_type start = r->get_start (), step = r->get_step ();
-            octave_idx_type i, j;
-            if (step == 1)
-              for (i = start, j = start + len; i < j && body (i); i++) ;
-            else if (step == -1)
-              for (i = start, j = start - len; i > j && body (i); i--) ;
-            else
-              for (i = 0, j = start; i < len && body (j); i++, j += step) ;
-            ret = i;
-          }
-          break;
+      case class_range:
+        {
+          idx_range_rep * r = dynamic_cast<idx_range_rep *> (rep);
+          octave_idx_type start = r->get_start (), step = r->get_step ();
+          octave_idx_type i, j;
+          if (step == 1)
+            for (i = start, j = start + len; i < j && body (i); i++) ;
+          else if (step == -1)
+            for (i = start, j = start - len; i > j && body (i); i--) ;
+          else
+            for (i = 0, j = start; i < len && body (j); i++, j += step) ;
+          ret = i;
+        }
+        break;
 
-        case class_scalar:
-          {
-            idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
-            ret = body (r->get_data ()) ? 1 : 0;
-          }
-          break;
+      case class_scalar:
+        {
+          idx_scalar_rep * r = dynamic_cast<idx_scalar_rep *> (rep);
+          ret = body (r->get_data ()) ? 1 : 0;
+        }
+        break;
 
-        case class_vector:
-          {
-            idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
-            const octave_idx_type *data = r->get_data ();
-            octave_idx_type i;
-            for (i = 0; i < len && body (data[i]); i++) ;
-            ret = i;
-          }
-          break;
+      case class_vector:
+        {
+          idx_vector_rep * r = dynamic_cast<idx_vector_rep *> (rep);
+          const octave_idx_type *data = r->get_data ();
+          octave_idx_type i;
+          for (i = 0; i < len && body (data[i]); i++) ;
+          ret = i;
+        }
+        break;
 
-        case class_mask:
-          {
-            idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
-            const bool *data = r->get_data ();
-            octave_idx_type ext = r->extent (0), j = 0;
-            for (octave_idx_type i = 0; i < ext; i++)
-              {
-                if (data[i])
-                  {
-                    if (body (i))
-                      break;
-                    else
-                      j++;
-                  }
-              }
+      case class_mask:
+        {
+          idx_mask_rep * r = dynamic_cast<idx_mask_rep *> (rep);
+          const bool *data = r->get_data ();
+          octave_idx_type ext = r->extent (0), j = 0;
+          for (octave_idx_type i = 0; i < ext; i++)
+            {
+              if (data[i])
+                {
+                  if (body (i))
+                    break;
+                  else
+                    j++;
+                }
+            }
 
-            ret = j;
-          }
-          break;
+          ret = j;
+        }
+        break;
 
-        default:
-          assert (false);
-          break;
-        }
+      default:
+        assert (false);
+        break;
+      }
 
-      return ret;
-    }
+    return ret;
+  }
 
   // Rationale:
   // This method is the key to "smart indexing". When indexing cartesian
   // arrays, sometimes consecutive index vectors can be reduced into a
   // single index.  If rows (A) = k and i.maybe_reduce (j) gives k, then
   // A(i,j)(:) is equal to A(k)(:).
 
   // If the next index can be reduced, returns true and updates this.
@@ -1017,30 +1018,30 @@ public:
   Array<octave_idx_type> as_array (void) const;
 
   // Raw pointer to index array.  This is non-const because it may be
   // necessary to mutate the index.
   const octave_idx_type *raw (void);
 
   bool is_vector (void) const;
 
-  // FIXME -- these are here for compatibility.  They should be removed
+  // FIXME: these are here for compatibility.  They should be removed
   // when no longer in use.
 
   octave_idx_type elem (octave_idx_type n) const
-    { return (*this) (n); }
+  { return (*this) (n); }
 
   bool is_colon_equiv (octave_idx_type n, int) const
-    { return is_colon_equiv (n); }
+  { return is_colon_equiv (n); }
 
   octave_idx_type
   freeze (octave_idx_type z_len, const char *tag, bool resize_ok = false);
 
   void sort (bool uniq = false)
-    { *this = sorted (uniq); }
+  { *this = sorted (uniq); }
 
   octave_idx_type ones_count (void) const;
 
   octave_idx_type max (void) const { return extent (1) - 1; }
 
 private:
 
   idx_base_rep *rep;
diff --git a/liboctave/array/intNDArray.cc b/liboctave/array/intNDArray.cc
--- a/liboctave/array/intNDArray.cc
+++ b/liboctave/array/intNDArray.cc
@@ -71,17 +71,17 @@ intNDArray<T>::diag (octave_idx_type k) 
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::diag (octave_idx_type m, octave_idx_type n) const
 {
   return MArray<T>::diag (m, n);
 }
 
-// FIXME -- this is not quite the right thing.
+// FIXME: this is not quite the right thing.
 
 template <class T>
 boolNDArray
 intNDArray<T>::all (int dim) const
 {
   return do_mx_red_op<bool, T > (*this, dim, mx_inline_all);
 }
 
@@ -90,50 +90,53 @@ boolNDArray
 intNDArray<T>::any (int dim) const
 {
   return do_mx_red_op<bool, T > (*this, dim, mx_inline_any);
 }
 
 template <class T>
 void
 intNDArray<T>::increment_index (Array<octave_idx_type>& ra_idx,
-                               const dim_vector& dimensions,
-                               int start_dimension)
+                                const dim_vector& dimensions,
+                                int start_dimension)
 {
   ::increment_index (ra_idx, dimensions, start_dimension);
 }
 
 template <class T>
 octave_idx_type
 intNDArray<T>::compute_index (Array<octave_idx_type>& ra_idx,
                               const dim_vector& dimensions)
 {
   return ::compute_index (ra_idx, dimensions);
 }
 
 template <class T>
 intNDArray<T>
-intNDArray<T>::concat (const intNDArray<T>& rb, const Array<octave_idx_type>& ra_idx)
+intNDArray<T>::concat (const intNDArray<T>& rb,
+                       const Array<octave_idx_type>& ra_idx)
 {
   if (rb.numel () > 0)
     insert (rb, ra_idx);
   return *this;
 }
 
 template <class T>
 intNDArray<T>&
-intNDArray<T>::insert (const intNDArray<T>& a, octave_idx_type r, octave_idx_type c)
+intNDArray<T>::insert (const intNDArray<T>& a, octave_idx_type r,
+                       octave_idx_type c)
 {
   Array<T>::insert (a, r, c);
   return *this;
 }
 
 template <class T>
 intNDArray<T>&
-intNDArray<T>::insert (const intNDArray<T>& a, const Array<octave_idx_type>& ra_idx)
+intNDArray<T>::insert (const intNDArray<T>& a,
+                       const Array<octave_idx_type>& ra_idx)
 {
   Array<T>::insert (a, ra_idx);
   return *this;
 }
 
 // This contains no information on the array structure !!!
 
 template <class T>
@@ -164,22 +167,22 @@ operator >> (std::istream& is, intNDArra
 
           if (is)
             a.elem (i) = tmp;
           else
             goto done;
         }
     }
 
- done:
+done:
 
   return is;
 }
 
-// FIXME -- should abs and signum just be mapper functions?
+// FIXME: should abs and signum just be mapper functions?
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::abs (void) const
 {
   octave_idx_type nel = this->nelem ();
   intNDArray<T> ret (this->dims ());
 
diff --git a/liboctave/array/intNDArray.h b/liboctave/array/intNDArray.h
--- a/liboctave/array/intNDArray.h
+++ b/liboctave/array/intNDArray.h
@@ -49,37 +49,37 @@ public:
 
   template <class U>
   intNDArray (const MArray<U>& a) : MArray<T> (a) { }
 
   template <class U>
   intNDArray (const intNDArray<U>& a) : MArray<T> (a) { }
 
   intNDArray& operator = (const intNDArray<T>& a)
-    {
-      MArray<T>::operator = (a);
-      return *this;
-    }
+  {
+    MArray<T>::operator = (a);
+    return *this;
+  }
 
   boolNDArray operator ! (void) const;
 
   bool any_element_is_nan (void) const { return false; }
   bool any_element_not_one_or_zero (void) const;
 
   intNDArray diag (octave_idx_type k = 0) const;
 
   intNDArray diag (octave_idx_type m, octave_idx_type n) const;
 
   intNDArray& changesign (void)
-    {
-      MArray<T>::changesign ();
-      return *this;
-    }
+  {
+    MArray<T>::changesign ();
+    return *this;
+  }
 
-  // FIXME -- this is not quite the right thing.
+  // FIXME: this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
   intNDArray max (int dim = -1) const;
   intNDArray max (Array<octave_idx_type>& index, int dim = -1) const;
   intNDArray min (int dim = -1) const;
   intNDArray min (Array<octave_idx_type>& index, int dim = -1) const;
@@ -94,32 +94,35 @@ public:
   intNDArray cumsum (int dim) const;
 
   intNDArray diff (octave_idx_type order = 1, int dim = -1) const;
 
   intNDArray abs (void) const;
   intNDArray signum (void) const;
 
   intNDArray squeeze (void) const
-    { return intNDArray<T> (MArray<T>::squeeze ()); }
+  { return intNDArray<T> (MArray<T>::squeeze ()); }
 
   intNDArray transpose (void) const
-    { return intNDArray<T> (MArray<T>::transpose ()); }
+  { return intNDArray<T> (MArray<T>::transpose ()); }
+
+  intNDArray concat (const intNDArray<T>& rb,
+                     const Array<octave_idx_type>& ra_idx);
 
-  intNDArray concat (const intNDArray<T>& rb, const Array<octave_idx_type>& ra_idx);
-
-  intNDArray& insert (const intNDArray<T>& a, octave_idx_type r, octave_idx_type c);
-  intNDArray& insert (const intNDArray<T>& a, const Array<octave_idx_type>& ra_idx);
+  intNDArray& insert (const intNDArray<T>& a,
+                      octave_idx_type r, octave_idx_type c);
+  intNDArray& insert (const intNDArray<T>& a,
+                      const Array<octave_idx_type>& ra_idx);
 
   static void increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension = 0);
 
   static octave_idx_type compute_index (Array<octave_idx_type>& ra_idx,
-                            const dim_vector& dimensions);
+                                        const dim_vector& dimensions);
 };
 
 // i/o
 
 template <class T>
 std::ostream& operator << (std::ostream& os, const intNDArray<T>& a);
 
 template <class T>
diff --git a/liboctave/cruft/misc/blaswrap.c b/liboctave/cruft/misc/blaswrap.c
--- a/liboctave/cruft/misc/blaswrap.c
+++ b/liboctave/cruft/misc/blaswrap.c
@@ -30,66 +30,70 @@ in libBLAS.dylib are not conforming to F
 they should.  This breaks them in 64-bit builds on the x86_64
 architecture.
 
 Newer gfortran compoilers no longer default to the F2C calling
 convention.  These wrappers map the F2C conformant functions in
 libBLAS and libLAPACK to the native gfortran calling convention, so
 that the libraries can be used with software built for x86_64
 architecture.
- 
- */
+
+*/
 
 #ifdef HAVE_CONFIG_H
 #include <config.h> /* USE_BLASWRAP ? */
 #endif
 
 #ifdef USE_BLASWRAP
 
 /*
  * vecLib is an Apple framework (collection of libraries) containing
  * libBLAS and libLAPACK.  The fortran stubs in these libraries are
  * (mostly, but not completely) in the F2C calling convention.
- * We access the libraries via the vecLib framework to make sure we 
+ * We access the libraries via the vecLib framework to make sure we
  * get the Apple versions, rather than some other blas/lapack with the
  * same name.
  */
 #ifndef VECLIB_FILE
 #define VECLIB_FILE "/System/Library/Frameworks/vecLib.framework/Versions/A/vecLib"
 #endif
 
 /*
- * Since this is a wrapper for fortran functions, we do not have prototypes for them.
+ * Since this is a wrapper for fortran functions,
+ * we do not have prototypes for them.
  */
 #pragma GCC diagnostic ignored "-Wmissing-prototypes"
 
 #include <dlfcn.h>
 #include <stdlib.h>
 
 /*
  * Apple LAPACK follows F2C calling convention,
  * Convert to normal gfortran calling convention
  */
 
-static void (*f2c_blas_func[])(void); /* forward declaration for the wrapper */
-static void (*f2c_lapack_func[])(void); /* forward declaration for the wrapper */
+static void (*f2c_blas_func[]) (void);   /* forward declaration for wrapper */
+static void (*f2c_lapack_func[]) (void); /* forward declaration for wrapper */
 
 /*
  * LAPACK Wrappers, only need to convert the return value from double to float
  */
 
-typedef double (*F2C_CALL_0)(void);
-typedef double (*F2C_CALL_1)(void *a1);
-typedef double (*F2C_CALL_2)(void *a1, void *a2);
-typedef double (*F2C_CALL_3)(void *a1, void *a2, void *a3);
-typedef double (*F2C_CALL_4)(void *a1, void *a2, void *a3, void *a4);
-typedef double (*F2C_CALL_5)(void *a1, void *a2, void *a3, void *a4, void *a5);
-typedef double (*F2C_CALL_6)(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6);
-typedef double (*F2C_CALL_7)(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7);
-typedef double (*F2C_CALL_8)(void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8);
+typedef double (*F2C_CALL_0) (void);
+typedef double (*F2C_CALL_1) (void *a1);
+typedef double (*F2C_CALL_2) (void *a1, void *a2);
+typedef double (*F2C_CALL_3) (void *a1, void *a2, void *a3);
+typedef double (*F2C_CALL_4) (void *a1, void *a2, void *a3, void *a4);
+typedef double (*F2C_CALL_5) (void *a1, void *a2, void *a3, void *a4, void *a5);
+typedef double (*F2C_CALL_6) (void *a1, void *a2, void *a3, void *a4, void *a5,
+                              void *a6);
+typedef double (*F2C_CALL_7) (void *a1, void *a2, void *a3, void *a4, void *a5,
+                              void *a6, void *a7);
+typedef double (*F2C_CALL_8) (void *a1, void *a2, void *a3, void *a4, void *a5,
+                              void *a6, void *a7, void *a8);
 
 #define F2C_LAPACK_CALL_8(name) \
   float name (void *a1, void *a2, void *a3, void *a4, void *a5, void *a6, void *a7, void *a8) \
   {                                                                     \
     return ((F2C_CALL_8)f2c_lapack_func[f2c_ ## name]) (a1, a2, a3, a4, a5, a6, a7, a8); \
   }
 
 #define F2C_LAPACK_CALL_7(name) \
@@ -229,17 +233,18 @@ DEFINE_LAPACK_ENUM(lapack, LAPACK_LIST)
 
 /*
  * BLAS wrappers, F2C convention passes retuned complex as an extra first
  * argument
  */
 typedef struct { float r, i; } complex;
 typedef struct { double r, i; } doublecomplex;
 
-typedef void (*F2C_BLAS_CALL_6)(void *c, void *a1, void *a2, void *a3, void *a4, void *a5);
+typedef void (*F2C_BLAS_CALL_6) (void *c, void *a1, void *a2, void *a3,
+                                 void *a4, void *a5);
 
 #define F2C_BLAS_CALL(type, name) \
 type name (void *a1, void *a2, void *a3, void *a4, void *a5) \
 { \
   type cplx; \
   ((F2C_BLAS_CALL_6)f2c_blas_func[f2c_ ## name]) (&cplx, a1, a2, a3, a4, a5); \
   return cplx; \
 }
@@ -248,18 +253,18 @@ F2C_BLAS_CALL(complex, cdotu_)
 F2C_BLAS_CALL(doublecomplex, zdotu_)
 F2C_BLAS_CALL(complex, cdotc_)
 F2C_BLAS_CALL(doublecomplex, zdotc_)
 
 
 /*
  * Function pointer arrays, indexed by the enums
  */
-static void (*f2c_blas_func[f2c_BLAS_COUNT])(void) = { 0 };
-static void (*f2c_lapack_func[f2c_LAPACK_COUNT])(void) = { 0 };
+static void (*f2c_blas_func[f2c_BLAS_COUNT]) (void) = { 0 };
+static void (*f2c_lapack_func[f2c_LAPACK_COUNT]) (void) = { 0 };
 
 /*
  * Initialization: This is called before main ().
  * Get the function pointers to the wrapped functions in Apple vecLib
  */
 
 static void * apple_vecLib = 0;
 
@@ -267,21 +272,21 @@ static void * apple_vecLib = 0;
 static void initVecLibWrappers (void)
 {
   apple_vecLib = dlopen (VECLIB_FILE, RTLD_LOCAL | RTLD_NOLOAD | RTLD_FIRST);
   if (0 == apple_vecLib)
     abort ();
 
   int i;
   for (i = 0; i < f2c_LAPACK_COUNT; i++)
-    if (0 == (f2c_lapack_func[i] = dlsym(apple_vecLib, f2c_lapack_name(i))))
-      abort ();  
+    if (0 == (f2c_lapack_func[i] = dlsym (apple_vecLib, f2c_lapack_name(i))))
+      abort ();
   for (i = 0; i < f2c_BLAS_COUNT; i++)
-    if (0 == (f2c_blas_func[i] = dlsym(apple_vecLib, f2c_blas_name(i))))
-      abort ();  
+    if (0 == (f2c_blas_func[i] = dlsym (apple_vecLib, f2c_blas_name(i))))
+      abort ();
 }
 
 __attribute__((destructor))
 static void finiVecLibWrappers (void)
 {
   if (apple_vecLib)
     dlclose (apple_vecLib);
   apple_vecLib = 0;
diff --git a/liboctave/cruft/misc/quit.cc b/liboctave/cruft/misc/quit.cc
--- a/liboctave/cruft/misc/quit.cc
+++ b/liboctave/cruft/misc/quit.cc
@@ -55,17 +55,17 @@ octave_throw_interrupt_exception (void)
     octave_interrupt_hook ();
 
   throw octave_interrupt_exception ();
 }
 
 void
 octave_throw_execution_exception (void)
 {
-  // FIXME -- would a hook function be useful here?
+  // FIXME: would a hook function be useful here?
 
   octave_exception_state = octave_exec_exception;
 
   throw octave_execution_exception ();
 }
 
 void
 octave_throw_bad_alloc (void)
diff --git a/liboctave/numeric/CmplxCHOL.cc b/liboctave/numeric/CmplxCHOL.cc
--- a/liboctave/numeric/CmplxCHOL.cc
+++ b/liboctave/numeric/CmplxCHOL.cc
@@ -333,17 +333,18 @@ ComplexCHOL::downdate (const ComplexColu
 
   if (u.length () == n)
     {
       if (singular (chol_mat))
         info = 2;
       else
         {
           info = init (chol_mat.hermitian () * chol_mat
-                       - ComplexMatrix (u) * ComplexMatrix (u).hermitian (), false);
+                       - ComplexMatrix (u) * ComplexMatrix (u).hermitian (),
+                       false);
           if (info) info = 1;
         }
     }
   else
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
   return info;
 }
diff --git a/liboctave/numeric/CmplxCHOL.h b/liboctave/numeric/CmplxCHOL.h
--- a/liboctave/numeric/CmplxCHOL.h
+++ b/liboctave/numeric/CmplxCHOL.h
@@ -34,40 +34,40 @@ OCTAVE_API
 ComplexCHOL
 {
 public:
 
   ComplexCHOL (void) : chol_mat (), xrcond (0) { }
 
   ComplexCHOL (const ComplexMatrix& a, bool calc_cond = false)
     : chol_mat (), xrcond (0)
-    {
-      init (a, calc_cond);
-    }
+  {
+    init (a, calc_cond);
+  }
 
   ComplexCHOL (const ComplexMatrix& a, octave_idx_type& info,
                bool calc_cond = false)
     : chol_mat (), xrcond (0)
-    {
-      info = init (a, calc_cond);
-    }
+  {
+    info = init (a, calc_cond);
+  }
 
   ComplexCHOL (const ComplexCHOL& a)
     : chol_mat (a.chol_mat), xrcond (a.xrcond) { }
 
   ComplexCHOL& operator = (const ComplexCHOL& a)
-    {
-      if (this != &a)
-        {
-          chol_mat = a.chol_mat;
-          xrcond = a.xrcond;
-        }
+  {
+    if (this != &a)
+      {
+        chol_mat = a.chol_mat;
+        xrcond = a.xrcond;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   ComplexMatrix chol_matrix (void) const { return chol_mat; }
 
   double rcond (void) const { return xrcond; }
 
   ComplexMatrix inverse (void) const;
 
   void set (const ComplexMatrix& R);
@@ -77,17 +77,18 @@ public:
   octave_idx_type downdate (const ComplexColumnVector& u);
 
   octave_idx_type insert_sym (const ComplexColumnVector& u, octave_idx_type j);
 
   void delete_sym (octave_idx_type j);
 
   void shift_sym (octave_idx_type i, octave_idx_type j);
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ComplexCHOL& a);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const ComplexCHOL& a);
 
 private:
 
   ComplexMatrix chol_mat;
 
   double xrcond;
 
   octave_idx_type init (const ComplexMatrix& a, bool calc_cond);
diff --git a/liboctave/numeric/CmplxGEPBAL.cc b/liboctave/numeric/CmplxGEPBAL.cc
--- a/liboctave/numeric/CmplxGEPBAL.cc
+++ b/liboctave/numeric/CmplxGEPBAL.cc
@@ -55,23 +55,24 @@ extern "C"
                              const octave_idx_type& LDV, octave_idx_type& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
 }
 
 octave_idx_type
 ComplexGEPBALANCE::init (const ComplexMatrix& a, const ComplexMatrix& b,
-                  const std::string& balance_job)
+                         const std::string& balance_job)
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
-      (*current_liboctave_error_handler) ("ComplexGEPBALANCE requires square matrix");
+      (*current_liboctave_error_handler)
+        ("ComplexGEPBALANCE requires square matrix");
       return -1;
     }
 
   if (a.dims () != b.dims ())
     {
       gripe_nonconformant ("ComplexGEPBALANCE", n, n, b.rows(), b.cols());
       return -1;
     }
diff --git a/liboctave/numeric/CmplxGEPBAL.h b/liboctave/numeric/CmplxGEPBAL.h
--- a/liboctave/numeric/CmplxGEPBAL.h
+++ b/liboctave/numeric/CmplxGEPBAL.h
@@ -32,52 +32,53 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 ComplexGEPBALANCE
 {
 public:
 
   ComplexGEPBALANCE (void)
     : balanced_mat (), balanced_mat2 (), balancing_mat (), balancing_mat2 ()
-    { }
+  { }
 
   ComplexGEPBALANCE (const ComplexMatrix& a, const ComplexMatrix& b,
                      const std::string& balance_job)
     : balanced_mat (), balanced_mat2 (), balancing_mat (), balancing_mat2 ()
-    {
-      init (a, b, balance_job);
-    }
+  {
+    init (a, b, balance_job);
+  }
 
   ComplexGEPBALANCE (const ComplexGEPBALANCE& a)
     : balanced_mat (a.balanced_mat), balanced_mat2 (a.balanced_mat2),
       balancing_mat (a.balancing_mat), balancing_mat2 (a.balancing_mat2) { }
 
   ComplexGEPBALANCE& operator = (const ComplexGEPBALANCE& a)
-    {
-      if (this != &a)
-        {
-          balanced_mat = a.balanced_mat;
-          balanced_mat2 = a.balanced_mat2;
-          balancing_mat = a.balancing_mat;
-          balancing_mat2 = a.balancing_mat2;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        balanced_mat = a.balanced_mat;
+        balanced_mat2 = a.balanced_mat2;
+        balancing_mat = a.balancing_mat;
+        balancing_mat2 = a.balancing_mat2;
+      }
+    return *this;
+  }
 
   ~ComplexGEPBALANCE (void) { }
 
   ComplexMatrix balanced_matrix (void) const { return balanced_mat; }
 
   ComplexMatrix balanced_matrix2 (void) const { return balanced_mat2; }
 
   Matrix balancing_matrix (void) const { return balancing_mat; }
 
   Matrix balancing_matrix2 (void) const { return balancing_mat2; }
 
-  friend std::ostream& operator << (std::ostream& os, const ComplexGEPBALANCE& a);
+  friend std::ostream& operator << (std::ostream& os,
+                                    const ComplexGEPBALANCE& a);
 
 private:
 
   ComplexMatrix balanced_mat;
   ComplexMatrix balanced_mat2;
   Matrix balancing_mat;
   Matrix balancing_mat2;
 
diff --git a/liboctave/numeric/CmplxHESS.h b/liboctave/numeric/CmplxHESS.h
--- a/liboctave/numeric/CmplxHESS.h
+++ b/liboctave/numeric/CmplxHESS.h
@@ -32,47 +32,47 @@ OCTAVE_API
 ComplexHESS
 {
 public:
 
   ComplexHESS (void) : hess_mat (), unitary_hess_mat () { }
 
   ComplexHESS (const ComplexMatrix& a)
     : hess_mat (), unitary_hess_mat ()
-    {
-      init (a);
-    }
+  {
+    init (a);
+  }
 
   ComplexHESS (const ComplexMatrix& a, octave_idx_type& info)
     : hess_mat (), unitary_hess_mat ()
-    {
-      info = init (a);
-    }
+  {
+    info = init (a);
+  }
 
   ComplexHESS (const ComplexHESS& a)
     : hess_mat (a.hess_mat), unitary_hess_mat (a.unitary_hess_mat) { }
 
   ComplexHESS& operator = (const ComplexHESS& a)
-    {
-      if (this != &a)
-        {
-          hess_mat = a.hess_mat;
-          unitary_hess_mat = a.unitary_hess_mat;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        hess_mat = a.hess_mat;
+        unitary_hess_mat = a.unitary_hess_mat;
+      }
+    return *this;
+  }
 
   ~ComplexHESS (void) { }
 
   ComplexMatrix hess_matrix (void) const { return hess_mat; }
 
   ComplexMatrix unitary_hess_matrix (void) const
-    {
-      return unitary_hess_mat;
-    }
+  {
+    return unitary_hess_mat;
+  }
 
   friend std::ostream& operator << (std::ostream& os, const ComplexHESS& a);
 
 private:
 
   ComplexMatrix hess_mat;
   ComplexMatrix unitary_hess_mat;
 
diff --git a/liboctave/numeric/CmplxLU.cc b/liboctave/numeric/CmplxLU.cc
--- a/liboctave/numeric/CmplxLU.cc
+++ b/liboctave/numeric/CmplxLU.cc
@@ -80,17 +80,18 @@ ComplexLU::ComplexLU (const ComplexMatri
   F77_XFCN (zgetrf, ZGETRF, (a_nr, a_nc, tmp_data, a_nr, pipvt, info));
 
   for (octave_idx_type i = 0; i < mn; i++)
     pipvt[i] -= 1;
 }
 
 #ifdef HAVE_QRUPDATE_LUU
 
-void ComplexLU::update (const ComplexColumnVector& u, const ComplexColumnVector& v)
+void ComplexLU::update (const ComplexColumnVector& u,
+                        const ComplexColumnVector& v)
 {
   if (packed ())
     unpack ();
 
   ComplexMatrix& l = l_fact;
   ComplexMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
@@ -119,43 +120,47 @@ void ComplexLU::update (const ComplexMat
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
       for (volatile octave_idx_type i = 0; i < u.cols (); i++)
         {
           ComplexColumnVector utmp = u.column (i), vtmp = v.column (i);
-          F77_XFCN (zlu1up, ZLU1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
+          F77_XFCN (zlu1up, ZLU1UP, (m, n, l.fortran_vec (),
+                                     m, r.fortran_vec (), k,
                                      utmp.fortran_vec (), vtmp.fortran_vec ()));
         }
     }
   else
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 }
 
-void ComplexLU::update_piv (const ComplexColumnVector& u, const ComplexColumnVector& v)
+void ComplexLU::update_piv (const ComplexColumnVector& u,
+                            const ComplexColumnVector& v)
 {
   if (packed ())
     unpack ();
 
   ComplexMatrix& l = l_fact;
   ComplexMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
   if (u.length () == m && v.length () == n)
     {
       ComplexColumnVector utmp = u, vtmp = v;
       OCTAVE_LOCAL_BUFFER (Complex, w, m);
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
-      F77_XFCN (zlup1up, ZLUP1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
-                                   ipvt.fortran_vec (), utmp.data (), vtmp.data (), w));
+      F77_XFCN (zlup1up, ZLUP1UP, (m, n, l.fortran_vec (),
+                                   m, r.fortran_vec (), k,
+                                   ipvt.fortran_vec (),
+                                   utmp.data (), vtmp.data (), w));
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
   else
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 }
 
 void ComplexLU::update_piv (const ComplexMatrix& u, const ComplexMatrix& v)
 {
@@ -171,40 +176,47 @@ void ComplexLU::update_piv (const Comple
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
       OCTAVE_LOCAL_BUFFER (Complex, w, m);
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
       for (volatile octave_idx_type i = 0; i < u.cols (); i++)
         {
           ComplexColumnVector utmp = u.column (i), vtmp = v.column (i);
-          F77_XFCN (zlup1up, ZLUP1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
-                                       ipvt.fortran_vec (), utmp.data (), vtmp.data (), w));
+          F77_XFCN (zlup1up, ZLUP1UP, (m, n, l.fortran_vec (),
+                                       m, r.fortran_vec (), k,
+                                       ipvt.fortran_vec (),
+                                       utmp.data (), vtmp.data (), w));
         }
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
   else
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 }
 
 #else
 
 void ComplexLU::update (const ComplexColumnVector&, const ComplexColumnVector&)
 {
-  (*current_liboctave_error_handler) ("luupdate: not available in this version");
+  (*current_liboctave_error_handler)
+    ("luupdate: not available in this version");
 }
 
 void ComplexLU::update (const ComplexMatrix&, const ComplexMatrix&)
 {
-  (*current_liboctave_error_handler) ("luupdate: not available in this version");
+  (*current_liboctave_error_handler)
+    ("luupdate: not available in this version");
 }
 
-void ComplexLU::update_piv (const ComplexColumnVector&, const ComplexColumnVector&)
+void ComplexLU::update_piv (const ComplexColumnVector&,
+                            const ComplexColumnVector&)
 {
-  (*current_liboctave_error_handler) ("luupdate: not available in this version");
+  (*current_liboctave_error_handler)
+    ("luupdate: not available in this version");
 }
 
 void ComplexLU::update_piv (const ComplexMatrix&, const ComplexMatrix&)
 {
-  (*current_liboctave_error_handler) ("luupdate: not available in this version");
+  (*current_liboctave_error_handler)
+    ("luupdate: not available in this version");
 }
 
 #endif
diff --git a/liboctave/numeric/CmplxLU.h b/liboctave/numeric/CmplxLU.h
--- a/liboctave/numeric/CmplxLU.h
+++ b/liboctave/numeric/CmplxLU.h
@@ -41,22 +41,22 @@ public:
   ComplexLU (const ComplexLU& a)
     : base_lu <ComplexMatrix> (a) { }
 
   ComplexLU (const ComplexMatrix& l, const ComplexMatrix& u,
              const PermMatrix& p)
     : base_lu <ComplexMatrix> (l, u, p) { }
 
   ComplexLU& operator = (const ComplexLU& a)
-    {
-      if (this != &a)
-        base_lu <ComplexMatrix> :: operator = (a);
+  {
+    if (this != &a)
+      base_lu <ComplexMatrix> :: operator = (a);
 
-      return *this;
-    }
+    return *this;
+  }
 
   ~ComplexLU (void) { }
 
   void update (const ComplexColumnVector& u, const ComplexColumnVector& v);
 
   void update (const ComplexMatrix& u, const ComplexMatrix& v);
 
   void update_piv (const ComplexColumnVector& u, const ComplexColumnVector& v);
diff --git a/liboctave/numeric/CmplxQR.cc b/liboctave/numeric/CmplxQR.cc
--- a/liboctave/numeric/CmplxQR.cc
+++ b/liboctave/numeric/CmplxQR.cc
@@ -115,23 +115,25 @@ ComplexQR::init (const ComplexMatrix& a,
   ComplexMatrix afact = a;
   if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
   if (m > 0)
     {
       // workspace query.
       Complex clwork;
-      F77_XFCN (zgeqrf, ZGEQRF, (m, n, afact.fortran_vec (), m, tau, &clwork, -1, info));
+      F77_XFCN (zgeqrf, ZGEQRF, (m, n, afact.fortran_vec (), m, tau,
+                                 &clwork, -1, info));
 
       // allocate buffer and do the job.
       octave_idx_type lwork = clwork.real ();
       lwork = std::max (lwork, static_cast<octave_idx_type> (1));
       OCTAVE_LOCAL_BUFFER (Complex, work, lwork);
-      F77_XFCN (zgeqrf, ZGEQRF, (m, n, afact.fortran_vec (), m, tau, work, lwork, info));
+      F77_XFCN (zgeqrf, ZGEQRF, (m, n, afact.fortran_vec (), m, tau,
+                                 work, lwork, info));
     }
 
   form (n, afact, tau, qr_type);
 }
 
 void ComplexQR::form (octave_idx_type n, ComplexMatrix& afact,
                       Complex *tau, qr_type_t qr_type)
 {
@@ -158,17 +160,17 @@ void ComplexQR::form (octave_idx_type n,
           q = afact;
           octave_idx_type k = qr_type == qr_type_economy ? n : m;
           r = ComplexMatrix (k, n);
           for (octave_idx_type j = 0; j < n; j++)
             {
               octave_idx_type i = 0;
               for (; i <= j; i++)
                 r.xelem (i, j) = afact.xelem (i, j);
-              for (;i < k; i++)
+              for (; i < k; i++)
                 r.xelem (i, j) = 0;
             }
           afact = ComplexMatrix (); // optimize memory
         }
       else
         {
           // afact will become r.
           q = ComplexMatrix (m, m);
@@ -209,18 +211,20 @@ ComplexQR::update (const ComplexColumnVe
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   if (u.length () == m && v.length () == n)
     {
       ComplexColumnVector utmp = u, vtmp = v;
       OCTAVE_LOCAL_BUFFER (Complex, w, k);
       OCTAVE_LOCAL_BUFFER (double, rw, k);
-      F77_XFCN (zqr1up, ZQR1UP, (m, n, k, q.fortran_vec (), m, r.fortran_vec (), k,
-                                 utmp.fortran_vec (), vtmp.fortran_vec (), w, rw));
+      F77_XFCN (zqr1up, ZQR1UP, (m, n, k, q.fortran_vec (),
+                                 m, r.fortran_vec (), k,
+                                 utmp.fortran_vec (), vtmp.fortran_vec (),
+                                 w, rw));
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
 ComplexQR::update (const ComplexMatrix& u, const ComplexMatrix& v)
 {
@@ -230,18 +234,20 @@ ComplexQR::update (const ComplexMatrix& 
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
       OCTAVE_LOCAL_BUFFER (Complex, w, k);
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       for (volatile octave_idx_type i = 0; i < u.cols (); i++)
         {
           ComplexColumnVector utmp = u.column (i), vtmp = v.column (i);
-          F77_XFCN (zqr1up, ZQR1UP, (m, n, k, q.fortran_vec (), m, r.fortran_vec (), k,
-                                     utmp.fortran_vec (), vtmp.fortran_vec (), w, rw));
+          F77_XFCN (zqr1up, ZQR1UP, (m, n, k, q.fortran_vec (),
+                                     m, r.fortran_vec (), k,
+                                     utmp.fortran_vec (), vtmp.fortran_vec (),
+                                     w, rw));
         }
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
 ComplexQR::insert_col (const ComplexColumnVector& u, octave_idx_type j)
@@ -368,17 +374,18 @@ ComplexQR::delete_col (const Array<octav
   else if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
           octave_idx_type ii = i;
           F77_XFCN (zqrdec, ZQRDEC, (m, n - ii, k == m ? k : k - ii,
                                      q.fortran_vec (), q.rows (),
-                                     r.fortran_vec (), r.rows (), js(ii) + 1, rw));
+                                     r.fortran_vec (), r.rows (),
+                                     js(ii) + 1, rw));
         }
       if (k < m)
         {
           q.resize (m, k - nj);
           r.resize (k - nj, n - nj);
         }
       else
         {
@@ -464,17 +471,18 @@ ComplexQR::update (const ComplexColumnVe
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.length () == m && v.length () == n)
     {
-      init (q*r + ComplexMatrix (u) * ComplexMatrix (v).hermitian (), get_type ());
+      init (q*r + ComplexMatrix (u) * ComplexMatrix (v).hermitian (),
+            get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
 ComplexQR::update (const ComplexMatrix& u, const ComplexMatrix& v)
 {
diff --git a/liboctave/numeric/CmplxQRP.cc b/liboctave/numeric/CmplxQRP.cc
--- a/liboctave/numeric/CmplxQRP.cc
+++ b/liboctave/numeric/CmplxQRP.cc
@@ -70,25 +70,27 @@ ComplexQRP::init (const ComplexMatrix& a
   MArray<octave_idx_type> jpvt (dim_vector (n, 1), 0);
 
   if (m > 0)
     {
       OCTAVE_LOCAL_BUFFER (double, rwork, 2*n);
 
       // workspace query.
       Complex clwork;
-      F77_XFCN (zgeqp3, ZGEQP3, (m, n, afact.fortran_vec (), m, jpvt.fortran_vec (),
-                                 tau, &clwork, -1, rwork, info));
+      F77_XFCN (zgeqp3, ZGEQP3, (m, n, afact.fortran_vec (),
+                                 m, jpvt.fortran_vec (), tau,
+                                 &clwork, -1, rwork, info));
 
       // allocate buffer and do the job.
       octave_idx_type lwork = clwork.real ();
       lwork = std::max (lwork, static_cast<octave_idx_type> (1));
       OCTAVE_LOCAL_BUFFER (Complex, work, lwork);
-      F77_XFCN (zgeqp3, ZGEQP3, (m, n, afact.fortran_vec (), m, jpvt.fortran_vec (),
-                                 tau, work, lwork, rwork, info));
+      F77_XFCN (zgeqp3, ZGEQP3, (m, n, afact.fortran_vec (),
+                                 m, jpvt.fortran_vec (), tau,
+                                 work, lwork, rwork, info));
     }
   else
     for (octave_idx_type i = 0; i < n; i++) jpvt(i) = i+1;
 
   // Form Permutation matrix (if economy is requested, return the
   // indices only!)
 
   jpvt -= static_cast<octave_idx_type> (1);
diff --git a/liboctave/numeric/CmplxQRP.h b/liboctave/numeric/CmplxQRP.h
--- a/liboctave/numeric/CmplxQRP.h
+++ b/liboctave/numeric/CmplxQRP.h
@@ -37,24 +37,24 @@ public:
 
   ComplexQRP (void) : ComplexQR (), p () { }
 
   ComplexQRP (const ComplexMatrix&, qr_type_t = qr_type_std);
 
   ComplexQRP (const ComplexQRP& a) : ComplexQR (a), p (a.p) { }
 
   ComplexQRP& operator = (const ComplexQRP& a)
-    {
-      if (this != &a)
-        {
-          ComplexQR::operator = (a);
-          p = a.p;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        ComplexQR::operator = (a);
+        p = a.p;
+      }
+    return *this;
+  }
 
   ~ComplexQRP (void) { }
 
   void init (const ComplexMatrix&, qr_type_t = qr_type_std);
 
   PermMatrix P (void) const { return p; }
 
   RowVector Pvec (void) const;
diff --git a/liboctave/numeric/CmplxSCHUR.h b/liboctave/numeric/CmplxSCHUR.h
--- a/liboctave/numeric/CmplxSCHUR.h
+++ b/liboctave/numeric/CmplxSCHUR.h
@@ -35,45 +35,45 @@ ComplexSCHUR
 {
 public:
 
   ComplexSCHUR (void) : schur_mat (), unitary_mat (), selector (0) { }
 
   ComplexSCHUR (const ComplexMatrix& a, const std::string& ord,
                 bool calc_unitary = true)
     : schur_mat (), unitary_mat (), selector (0)
-    {
-      init (a, ord, calc_unitary);
-    }
+  {
+    init (a, ord, calc_unitary);
+  }
 
   ComplexSCHUR (const ComplexMatrix& a, const std::string& ord,
                 octave_idx_type& info,
                 bool calc_unitary = true)
     : schur_mat (), unitary_mat (), selector (0)
-    {
-      info = init (a, ord, calc_unitary);
-    }
+  {
+    info = init (a, ord, calc_unitary);
+  }
 
   ComplexSCHUR (const ComplexSCHUR& a)
     : schur_mat (a.schur_mat), unitary_mat (a.unitary_mat), selector (0)
-    { }
+  { }
 
   ComplexSCHUR (const ComplexMatrix& s, const ComplexMatrix& u);
 
   ComplexSCHUR (const SCHUR& s);
 
   ComplexSCHUR& operator = (const ComplexSCHUR& a)
-    {
-      if (this != &a)
-        {
-          schur_mat = a.schur_mat;
-          unitary_mat = a.unitary_mat;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        schur_mat = a.schur_mat;
+        unitary_mat = a.unitary_mat;
+      }
+    return *this;
+  }
 
   ~ComplexSCHUR (void) { }
 
   ComplexMatrix schur_matrix (void) const { return schur_mat; }
 
   ComplexMatrix unitary_matrix (void) const { return unitary_mat; }
 
   friend std::ostream& operator << (std::ostream& os, const ComplexSCHUR& a);
@@ -82,12 +82,13 @@ public:
 
 private:
 
   ComplexMatrix schur_mat;
   ComplexMatrix unitary_mat;
 
   select_function selector;
 
-  octave_idx_type init (const ComplexMatrix& a, const std::string& ord, bool calc_unitary);
+  octave_idx_type init (const ComplexMatrix& a, const std::string& ord,
+                        bool calc_unitary);
 };
 
 #endif
diff --git a/liboctave/numeric/CmplxSVD.cc b/liboctave/numeric/CmplxSVD.cc
--- a/liboctave/numeric/CmplxSVD.cc
+++ b/liboctave/numeric/CmplxSVD.cc
@@ -75,17 +75,18 @@ ComplexSVD::right_singular_matrix (void)
         ("ComplexSVD: V not computed because type == SVD::sigma_only");
       return ComplexMatrix ();
     }
   else
     return right_sm;
 }
 
 octave_idx_type
-ComplexSVD::init (const ComplexMatrix& a, SVD::type svd_type, SVD::driver svd_driver)
+ComplexSVD::init (const ComplexMatrix& a, SVD::type svd_type,
+                  SVD::driver svd_driver)
 {
   octave_idx_type info;
 
   octave_idx_type m = a.rows ();
   octave_idx_type n = a.cols ();
 
   ComplexMatrix atmp = a;
   Complex *tmp_data = atmp.fortran_vec ();
diff --git a/liboctave/numeric/CmplxSVD.h b/liboctave/numeric/CmplxSVD.h
--- a/liboctave/numeric/CmplxSVD.h
+++ b/liboctave/numeric/CmplxSVD.h
@@ -32,49 +32,49 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 ComplexSVD
 {
 public:
 
   ComplexSVD (void)
     : type_computed (), sigma (), left_sm (), right_sm ()
-    { }
+  { }
 
   ComplexSVD (const ComplexMatrix& a, SVD::type svd_type = SVD::std,
               SVD::driver svd_driver = SVD::GESVD)
     : type_computed (), sigma (), left_sm (), right_sm ()
-    {
-      init (a, svd_type, svd_driver);
-    }
+  {
+    init (a, svd_type, svd_driver);
+  }
 
   ComplexSVD (const ComplexMatrix& a, octave_idx_type& info,
               SVD::type svd_type = SVD::std,
               SVD::driver svd_driver = SVD::GESVD)
     : type_computed (), sigma (), left_sm (), right_sm ()
-    {
-      info = init (a, svd_type, svd_driver);
-    }
+  {
+    info = init (a, svd_type, svd_driver);
+  }
 
   ComplexSVD (const ComplexSVD& a)
     : type_computed (a.type_computed), sigma (a.sigma),
       left_sm (a.left_sm), right_sm (a.right_sm)
-    { }
+  { }
 
   ComplexSVD& operator = (const ComplexSVD& a)
-    {
-      if (this != &a)
-        {
-          type_computed = a.type_computed;
-          sigma = a.sigma;
-          left_sm = a.left_sm;
-          right_sm = a.right_sm;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        type_computed = a.type_computed;
+        sigma = a.sigma;
+        left_sm = a.left_sm;
+        right_sm = a.right_sm;
+      }
+    return *this;
+  }
 
   ~ComplexSVD (void) { }
 
   DiagMatrix singular_values (void) const { return sigma; }
 
   ComplexMatrix left_singular_matrix (void) const;
 
   ComplexMatrix right_singular_matrix (void) const;
diff --git a/liboctave/numeric/CollocWt.h b/liboctave/numeric/CollocWt.h
--- a/liboctave/numeric/CollocWt.h
+++ b/liboctave/numeric/CollocWt.h
@@ -49,98 +49,98 @@ public:
 
   CollocWt (octave_idx_type nc, double a, double b, octave_idx_type il,
             octave_idx_type ir)
     : n (nc), inc_left (il), inc_right (ir), lb (0.0), rb (1.0),
       Alpha (a), Beta (b), r (), q (), A (), B (), initialized (false) { }
 
   CollocWt (octave_idx_type nc, double a, double b, octave_idx_type il,
             octave_idx_type ir,
-                      double ll, double rr)
+            double ll, double rr)
     : n (nc), inc_left (il), inc_right (ir), lb (ll), rb (rr),
       Alpha (a), Beta (b), r (), q (), A (), B (), initialized (false) { }
 
   CollocWt (const CollocWt& a)
     : n (a.n), inc_left (a.inc_left), inc_right (a.inc_right),
       lb (a.lb), rb (a.rb), Alpha (a.Alpha), Beta (a.Beta),
       r (a.r), q (a.q), A (a.A), B (a.B),
       initialized (a.initialized) { }
 
   CollocWt& operator = (const CollocWt& a)
-    {
-      if (this != &a)
-        {
-          n = a.n;
-          inc_left = a.inc_left;
-          inc_right = a.inc_right;
-          lb = a.lb;
-          rb = a.rb;
-          r = a.r;
-          q = a.q;
-          A = a.A;
-          B = a.B;
-          initialized = a.initialized;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        n = a.n;
+        inc_left = a.inc_left;
+        inc_right = a.inc_right;
+        lb = a.lb;
+        rb = a.rb;
+        r = a.r;
+        q = a.q;
+        A = a.A;
+        B = a.B;
+        initialized = a.initialized;
+      }
+    return *this;
+  }
 
   ~CollocWt (void) { }
 
   CollocWt& resize (octave_idx_type nc)
-    {
-      n = nc;
-      initialized = false;
-      return *this;
-    }
+  {
+    n = nc;
+    initialized = false;
+    return *this;
+  }
 
   CollocWt& add_left (void)
-    {
-      inc_left = 1;
-      initialized = false;
-      return *this;
-    }
+  {
+    inc_left = 1;
+    initialized = false;
+    return *this;
+  }
 
   CollocWt& delete_left (void)
-    {
-      inc_left = 0;
-      initialized = false;
-      return *this;
-    }
+  {
+    inc_left = 0;
+    initialized = false;
+    return *this;
+  }
 
   CollocWt& set_left (double val);
 
   CollocWt& add_right (void)
-    {
-      inc_right = 1;
-      initialized = false;
-      return *this;
-    }
+  {
+    inc_right = 1;
+    initialized = false;
+    return *this;
+  }
 
   CollocWt& delete_right (void)
-    {
-      inc_right = 0;
-      initialized = false;
-      return *this;
-    }
+  {
+    inc_right = 0;
+    initialized = false;
+    return *this;
+  }
 
   CollocWt& set_right (double val);
 
   CollocWt& set_alpha (double val)
-    {
-      Alpha = val;
-      initialized = false;
-      return *this;
-    }
+  {
+    Alpha = val;
+    initialized = false;
+    return *this;
+  }
 
   CollocWt& set_beta (double val)
-    {
-      Beta = val;
-      initialized = false;
-      return *this;
-    }
+  {
+    Beta = val;
+    initialized = false;
+    return *this;
+  }
 
   octave_idx_type ncol (void) const { return n; }
 
   octave_idx_type left_included (void) const { return inc_left; }
   octave_idx_type right_included (void) const { return inc_right; }
 
   double left (void) const { return lb; }
   double right (void) const { return rb; }
diff --git a/liboctave/numeric/DAE.h b/liboctave/numeric/DAE.h
--- a/liboctave/numeric/DAE.h
+++ b/liboctave/numeric/DAE.h
@@ -38,24 +38,24 @@ public:
   DAE (const ColumnVector& xx, double tt, DAEFunc& f)
     : base_diff_alg_eqn (xx, tt), DAEFunc (f) { }
 
   DAE (const ColumnVector& xx, const ColumnVector& xxdot,
        double tt, DAEFunc& f)
     : base_diff_alg_eqn (xx, xxdot, tt), DAEFunc (f) { }
 
   DAE (const DAE& a)
-    : base_diff_alg_eqn (a), DAEFunc (a){ }
+    : base_diff_alg_eqn (a), DAEFunc (a) { }
 
   DAE& operator = (const DAE& a)
-    {
-      if (this != &a)
-        {
-          base_diff_alg_eqn::operator = (a);
-          DAEFunc::operator = (a);
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        base_diff_alg_eqn::operator = (a);
+        DAEFunc::operator = (a);
+      }
+    return *this;
+  }
 
   virtual ~DAE (void) { }
 };
 
 #endif
diff --git a/liboctave/numeric/DAEFunc.h b/liboctave/numeric/DAEFunc.h
--- a/liboctave/numeric/DAEFunc.h
+++ b/liboctave/numeric/DAEFunc.h
@@ -51,45 +51,45 @@ public:
 
   DAEFunc (DAERHSFunc f, DAEJacFunc j)
     : fun (f), jac (j), reset (true) { }
 
   DAEFunc (const DAEFunc& a)
     : fun (a.fun), jac (a.jac), reset (a.reset) { }
 
   DAEFunc& operator = (const DAEFunc& a)
-    {
-      if (this != &a)
-        {
-          fun = a.fun;
-          jac = a.jac;
-          reset = a.reset;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        fun = a.fun;
+        jac = a.jac;
+        reset = a.reset;
+      }
+    return *this;
+  }
 
   virtual ~DAEFunc (void) { }
 
   DAERHSFunc function (void) const { return fun; }
 
   DAEFunc& set_function (DAERHSFunc f)
-    {
-      fun = f;
-      reset = true;
-      return *this;
-    }
+  {
+    fun = f;
+    reset = true;
+    return *this;
+  }
 
   DAEJacFunc jacobian_function (void) const { return jac; }
 
   DAEFunc& set_jacobian_function (DAEJacFunc j)
-    {
-      jac = j;
-      reset = true;
-      return *this;
-    }
+  {
+    jac = j;
+    reset = true;
+    return *this;
+  }
 
 protected:
 
   DAERHSFunc fun;
   DAEJacFunc jac;
 
   // This variable is TRUE when this object is constructed, and also
   // after any internal data has changed.  Derived classes may use
diff --git a/liboctave/numeric/DAERT.h b/liboctave/numeric/DAERT.h
--- a/liboctave/numeric/DAERT.h
+++ b/liboctave/numeric/DAERT.h
@@ -34,35 +34,35 @@ public:
 
   DAERT (void)
     : base_diff_alg_eqn (), DAERTFunc () { }
 
   DAERT (const ColumnVector& xx, double tt, DAERTFunc& f)
     : base_diff_alg_eqn (xx, tt), DAERTFunc (f) { }
 
   DAERT (const ColumnVector& xx, const ColumnVector& xxdot, double tt,
-        DAERTFunc& f)
+         DAERTFunc& f)
     : base_diff_alg_eqn (xx, xxdot, tt), DAERTFunc (f) { }
 
   DAERT (const DAERT& a)
     : base_diff_alg_eqn (a), DAERTFunc (a) { }
 
   DAERT& operator = (const DAERT& a)
-    {
-      if (this != &a)
-        {
-          base_diff_alg_eqn::operator = (a);
-          DAERTFunc::operator = (a);
+  {
+    if (this != &a)
+      {
+        base_diff_alg_eqn::operator = (a);
+        DAERTFunc::operator = (a);
 
-        }
-      return *this;
-    }
+      }
+    return *this;
+  }
 
   virtual ~DAERT (void) { }
 
   void initialize (const ColumnVector& xx, const ColumnVector& xxdot,
                    double tt)
-    {
-      base_diff_alg_eqn::initialize (xx, xxdot, tt);
-    }
+  {
+    base_diff_alg_eqn::initialize (xx, xxdot, tt);
+  }
 };
 
 #endif
diff --git a/liboctave/numeric/DAERTFunc.h b/liboctave/numeric/DAERTFunc.h
--- a/liboctave/numeric/DAERTFunc.h
+++ b/liboctave/numeric/DAERTFunc.h
@@ -46,36 +46,36 @@ public:
 
   DAERTFunc (DAERHSFunc f, DAERTConstrFunc cf, DAEJacFunc j)
     : DAEFunc (f, j), constr (cf), reset (true) { }
 
   DAERTFunc (const DAERTFunc& a)
     : DAEFunc (a), constr (a.constr), reset (a.reset) { }
 
   DAERTFunc& operator = (const DAERTFunc& a)
-    {
-      if (this != &a)
-        {
-          DAEFunc::operator = (a);
-          constr = a.constr;
-          reset = a.reset;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        DAEFunc::operator = (a);
+        constr = a.constr;
+        reset = a.reset;
+      }
+    return *this;
+  }
 
   virtual ~DAERTFunc (void) { }
 
   DAERTConstrFunc constraint_function (void) const { return constr; }
 
   DAERTFunc& set_constraint_function (DAERTConstrFunc cf)
-    {
-      constr = cf;
-      reset = true;
-      return *this;
-    }
+  {
+    constr = cf;
+    reset = true;
+    return *this;
+  }
 
 protected:
 
   DAERTConstrFunc constr;
 
   // This variable is TRUE when this object is constructed, and also
   // after any internal data has changed.  Derived classes may use
   // this information (and change it) to know when to (re)initialize
diff --git a/liboctave/numeric/DASPK.cc b/liboctave/numeric/DASPK.cc
--- a/liboctave/numeric/DASPK.cc
+++ b/liboctave/numeric/DASPK.cc
@@ -125,17 +125,17 @@ ddaspk_psol (const octave_idx_type&, con
 
 
 static octave_idx_type
 ddaspk_j (const double& time, const double *state, const double *deriv,
           double *pd, const double& cj, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
-  // FIXME -- would be nice to avoid copying the data.
+  // FIXME: would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
     {
       tmp_deriv.elem (i) = deriv[i];
       tmp_state.elem (i) = state[i];
@@ -150,17 +150,17 @@ ddaspk_j (const double& time, const doub
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 ColumnVector
 DASPK::do_integrate (double tout)
 {
-  // FIXME -- should handle all this option stuff just once
+  // FIXME: should handle all this option stuff just once
   // for each new problem.
 
   ColumnVector retval;
 
   if (! initialized || restart || DAEFunc::reset|| DASPK_options::reset)
     {
       integration_error = false;
 
@@ -338,17 +338,17 @@ DASPK::do_integrate (double tout)
           integration_error = true;
           return retval;
         }
 
       if (ccic)
         {
           if (ccic == 1)
             {
-              // FIXME -- this code is duplicated below.
+              // FIXME: this code is duplicated below.
 
               Array<octave_idx_type> av = algebraic_variables ();
 
               if (av.length () == n)
                 {
                   octave_idx_type lid;
                   if (eiq == 0 || eiq == 2)
                     lid = 40;
@@ -378,17 +378,17 @@ DASPK::do_integrate (double tout)
 
           info(10) = ccic;
         }
 
       if (eavfet)
         {
           info(15) = 1;
 
-          // FIXME -- this code is duplicated above.
+          // FIXME: this code is duplicated above.
 
           Array<octave_idx_type> av = algebraic_variables ();
 
           if (av.length () == n)
             {
               octave_idx_type lid;
               if (eiq == 0 || eiq == 2)
                 lid = 40;
@@ -705,71 +705,71 @@ DASPK::error_message (void) const
       break;
 
     case 4:
       retval = "initial condition calculation completed successfully";
       break;
 
     case -1:
       retval = std::string ("a large amount of work has been expended (t =")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -2:
       retval = "the error tolerances are too stringent";
       break;
 
     case -3:
       retval = std::string ("error weight became zero during problem. (t = ")
-        + t_curr
-        + "; solution component i vanished, and atol or atol(i) == 0)";
+               + t_curr
+               + "; solution component i vanished, and atol or atol(i) == 0)";
       break;
 
     case -6:
       retval = std::string ("repeated error test failures on the last attempted step (t = ")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -7:
       retval = std::string ("the corrector could not converge (t = ")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -8:
       retval = std::string ("the matrix of partial derivatives is singular (t = ")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -9:
       retval = std::string ("the corrector could not converge (t = ")
-        + t_curr + "; repeated test failures)";
+               + t_curr + "; repeated test failures)";
       break;
 
     case -10:
       retval = std::string ("corrector could not converge because IRES was -1 (t = ")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -11:
       retval = std::string ("return requested in user-supplied function (t = ")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -12:
       retval = "failed to compute consistent initial conditions";
       break;
 
     case -13:
       retval = std::string ("unrecoverable error encountered inside user's PSOL function (t = ")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -14:
       retval = std::string ("the Krylov linear system solver failed to converge (t = ")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -33:
       retval = "unrecoverable error (see printed message)";
       break;
 
     default:
       retval = "unknown error state";
diff --git a/liboctave/numeric/DASRT.cc b/liboctave/numeric/DASRT.cc
--- a/liboctave/numeric/DASRT.cc
+++ b/liboctave/numeric/DASRT.cc
@@ -101,17 +101,17 @@ ddasrt_f (const double& t, const double 
 }
 
 octave_idx_type
 ddasrt_j (const double& time, const double *state, const double *deriv,
           double *pd, const double& cj, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
-  // FIXME -- would be nice to avoid copying the data.
+  // FIXME: would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
     {
       tmp_deriv.elem (i) = deriv[i];
       tmp_state.elem (i) = state[i];
@@ -586,57 +586,57 @@ DASRT::error_message (void) const
       break;
 
     case 4:
       retval = "integration completed by finding one or more roots of G at T";
       break;
 
     case -1:
       retval = std::string ("a large amount of work has been expended (t =")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -2:
       retval = "the error tolerances are too stringent";
       break;
 
     case -3:
       retval = std::string ("error weight became zero during problem. (t = ")
-        + t_curr
-        + "; solution component i vanished, and atol or atol(i) == 0)";
+               + t_curr
+               + "; solution component i vanished, and atol or atol(i) == 0)";
       break;
 
     case -6:
       retval = std::string ("repeated error test failures on the last attempted step (t = ")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -7:
       retval = std::string ("the corrector could not converge (t = ")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -8:
       retval = std::string ("the matrix of partial derivatives is singular (t = ")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -9:
       retval = std::string ("the corrector could not converge (t = ")
-        + t_curr + "; repeated test failures)";
+               + t_curr + "; repeated test failures)";
       break;
 
     case -10:
       retval = std::string ("corrector could not converge because IRES was -1 (t = ")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -11:
       retval = std::string ("return requested in user-supplied function (t = ")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -12:
       retval = "failed to compute consistent initial conditions";
       break;
 
     case -33:
       retval = "unrecoverable error (see printed message)";
diff --git a/liboctave/numeric/DASRT.h b/liboctave/numeric/DASRT.h
--- a/liboctave/numeric/DASRT.h
+++ b/liboctave/numeric/DASRT.h
@@ -38,25 +38,25 @@ public:
 
   DASRT_result (const Matrix& xx, const Matrix& xxdot, const ColumnVector& tt)
     : x (xx), xdot (xxdot), t (tt) { }
 
   DASRT_result (const DASRT_result& r)
     : x (r.x), xdot (r.xdot), t (r.t) { }
 
   DASRT_result& operator = (const DASRT_result& r)
-    {
-      if (this != &r)
-        {
-          x = r.x;
-          xdot = r.xdot;
-          t = r.t;
-        }
-      return *this;
-    }
+  {
+    if (this != &r)
+      {
+        x = r.x;
+        xdot = r.xdot;
+        t = r.t;
+      }
+    return *this;
+  }
 
   ~DASRT_result (void) { }
 
   Matrix state (void) const { return x; }
   Matrix deriv (void) const { return xdot; }
   ColumnVector times (void) const { return t; }
 
 private:
@@ -71,30 +71,30 @@ OCTAVE_API
 DASRT : public DAERT, public DASRT_options
 {
 public:
 
   DASRT (void)
     : DAERT (), DASRT_options (), initialized (false),
       liw (0), lrw (0), ng (0), info (), iwork (), jroot (), rwork (),
       abs_tol (), rel_tol ()
-    { }
+  { }
 
   DASRT (const ColumnVector& s, double tm, DAERTFunc& f)
     : DAERT (s, tm, f), DASRT_options (), initialized (false),
       liw (0), lrw (0), ng (0), info (), iwork (), jroot (), rwork (),
       abs_tol (), rel_tol ()
-    { }
+  { }
 
   DASRT (const ColumnVector& s, const ColumnVector& deriv,
          double tm, DAERTFunc& f)
     : DAERT (s, deriv, tm, f), DASRT_options (), initialized (false),
       liw (0), lrw (0), ng (0), info (), iwork (), jroot (), rwork (),
       abs_tol (), rel_tol ()
-    { }
+  { }
 
   ~DASRT (void) { }
 
   DASRT_result integrate (const ColumnVector& tout);
 
   DASRT_result integrate (const ColumnVector& tout,
                           const ColumnVector& tcrit);
 
diff --git a/liboctave/numeric/DASSL.cc b/liboctave/numeric/DASSL.cc
--- a/liboctave/numeric/DASSL.cc
+++ b/liboctave/numeric/DASSL.cc
@@ -63,17 +63,17 @@ static DAEFunc::DAEJacFunc user_jac;
 static octave_idx_type nn;
 
 static octave_idx_type
 ddassl_f (const double& time, const double *state, const double *deriv,
           double *delta, octave_idx_type& ires, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
-  // FIXME -- would be nice to avoid copying the data.
+  // FIXME: would be nice to avoid copying the data.
 
   ColumnVector tmp_deriv (nn);
   ColumnVector tmp_state (nn);
   ColumnVector tmp_delta (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
     {
       tmp_deriv.elem (i) = deriv[i];
@@ -99,17 +99,17 @@ ddassl_f (const double& time, const doub
 }
 
 static octave_idx_type
 ddassl_j (const double& time, const double *state, const double *deriv,
           double *pd, const double& cj, double *, octave_idx_type *)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
-  // FIXME -- would be nice to avoid copying the data.
+  // FIXME: would be nice to avoid copying the data.
 
   ColumnVector tmp_state (nn);
   ColumnVector tmp_deriv (nn);
 
   for (octave_idx_type i = 0; i < nn; i++)
     {
       tmp_deriv.elem (i) = deriv[i];
       tmp_state.elem (i) = state[i];
@@ -516,57 +516,57 @@ DASSL::error_message (void) const
       break;
 
     case 3:
       retval = "integration to tout completed by stepping past TOUT";
       break;
 
     case -1:
       retval = std::string ("a large amount of work has been expended (t =")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -2:
       retval = "the error tolerances are too stringent";
       break;
 
     case -3:
       retval = std::string ("error weight became zero during problem. (t = ")
-        + t_curr
-        + "; solution component i vanished, and atol or atol(i) == 0)";
+               + t_curr
+               + "; solution component i vanished, and atol or atol(i) == 0)";
       break;
 
     case -6:
       retval = std::string ("repeated error test failures on the last attempted step (t = ")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -7:
       retval = std::string ("the corrector could not converge (t = ")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -8:
       retval = std::string ("the matrix of partial derivatives is singular (t = ")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -9:
       retval = std::string ("the corrector could not converge (t = ")
-        + t_curr + "; repeated test failures)";
+               + t_curr + "; repeated test failures)";
       break;
 
     case -10:
       retval = std::string ("corrector could not converge because IRES was -1 (t = ")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -11:
       retval = std::string ("return requested in user-supplied function (t = ")
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     case -12:
       retval = "failed to compute consistent initial conditions";
       break;
 
     case -33:
       retval = "unrecoverable error (see printed message)";
diff --git a/liboctave/numeric/DET.h b/liboctave/numeric/DET.h
--- a/liboctave/numeric/DET.h
+++ b/liboctave/numeric/DET.h
@@ -30,55 +30,55 @@ along with Octave; see the file COPYING.
 template <class T>
 class
 base_det
 {
 public:
 
   base_det (T c = 1, int e = 0)
     : c2 (), e2 ()
-    {
-      c2 = xlog2 (c, e2);
-      e2 += e;
-    }
+  {
+    c2 = xlog2 (c, e2);
+    e2 += e;
+  }
 
   base_det (T c, double e, double b)
     : c2 (), e2 ()
-    {
-      e *= xlog2 (b);
-      e2 = e;
-      c *= xexp2 (e - e2);
-      int f;
-      c2 = xlog2 (c, f);
-      e2 += f;
-    }
+  {
+    e *= xlog2 (b);
+    e2 = e;
+    c *= xexp2 (e - e2);
+    int f;
+    c2 = xlog2 (c, f);
+    e2 += f;
+  }
 
   base_det (const base_det& a) : c2 (a.c2), e2 (a.e2) { }
 
   base_det& operator = (const base_det& a)
-    {
-      c2 = a.c2;
-      e2 = a.e2;
-      return *this;
-    }
+  {
+    c2 = a.c2;
+    e2 = a.e2;
+    return *this;
+  }
 
   T coef (void) const { return c2; }
   int exp (void) const { return e2; }
 
   T value () const { return c2 * static_cast<T> (std::ldexp (1.0, e2)); }
   operator T () const { return value (); }
 
   base_det square () const { return base_det (c2*c2, e2+e2); }
 
   void operator *= (T t)
-    {
-      int e;
-      c2 *= xlog2 (t, e);
-      e2 += e;
-    }
+  {
+    int e;
+    c2 *= xlog2 (t, e);
+    e2 += e;
+  }
 
 private:
 
   T c2;
   int e2;
 };
 
 // Provide the old types by typedefs.
diff --git a/liboctave/numeric/EIG.cc b/liboctave/numeric/EIG.cc
--- a/liboctave/numeric/EIG.cc
+++ b/liboctave/numeric/EIG.cc
@@ -786,17 +786,18 @@ EIG::init (const ComplexMatrix& a, const
     }
   else
     (*current_liboctave_error_handler) ("zggev workspace query failed");
 
   return info;
 }
 
 octave_idx_type
-EIG::hermitian_init (const ComplexMatrix& a, const ComplexMatrix& b, bool calc_ev)
+EIG::hermitian_init (const ComplexMatrix& a, const ComplexMatrix& b,
+                     bool calc_ev)
 {
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols ())
     {
       (*current_liboctave_error_handler) ("EIG requires square matrix");
       return -1;
diff --git a/liboctave/numeric/EIG.h b/liboctave/numeric/EIG.h
--- a/liboctave/numeric/EIG.h
+++ b/liboctave/numeric/EIG.h
@@ -28,18 +28,18 @@ along with Octave; see the file COPYING.
 #include "dMatrix.h"
 #include "CMatrix.h"
 #include "CColVector.h"
 
 class
 OCTAVE_API
 EIG
 {
-friend class Matrix;
-friend class ComplexMatrix;
+  friend class Matrix;
+  friend class ComplexMatrix;
 
 public:
 
   EIG (void) : lambda (), v () { }
 
   EIG (const Matrix& a, bool calc_eigenvectors = true)
     : lambda (), v ()
   {
@@ -91,24 +91,24 @@ public:
   {
     info = init (a, b, calc_eigenvectors);
   }
 
   EIG (const EIG& a)
     : lambda (a.lambda), v (a.v) { }
 
   EIG& operator = (const EIG& a)
-    {
-      if (this != &a)
-        {
-          lambda = a.lambda;
-          v = a.v;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        lambda = a.lambda;
+        v = a.v;
+      }
+    return *this;
+  }
 
   ~EIG (void) { }
 
   ComplexColumnVector eigenvalues (void) const { return lambda; }
 
   ComplexMatrix eigenvectors (void) const { return v; }
 
   friend std::ostream&  operator << (std::ostream& os, const EIG& a);
diff --git a/liboctave/numeric/LSODE.cc b/liboctave/numeric/LSODE.cc
--- a/liboctave/numeric/LSODE.cc
+++ b/liboctave/numeric/LSODE.cc
@@ -84,17 +84,18 @@ lsode_f (const octave_idx_type& neq, con
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 static octave_idx_type
 lsode_j (const octave_idx_type& neq, const double& time, double *,
-         const octave_idx_type&, const octave_idx_type&, double *pd, const octave_idx_type& nrowpd)
+         const octave_idx_type&, const octave_idx_type&, double *pd,
+         const octave_idx_type& nrowpd)
 {
   BEGIN_INTERRUPT_WITH_EXCEPTIONS;
 
   Matrix tmp_jac (neq, neq);
 
   // NOTE: this won't work if LSODE passes copies of the state vector.
   //       In that case we have to create a temporary vector object
   //       and copy.
@@ -331,47 +332,47 @@ LSODE::error_message (void) const
       break;
 
     case 3:
       retval = "prior to continuation call with modified parameters";
       break;
 
     case -1:
       retval = std::string ("excess work on this call (t = ")
-        + t_curr + "; perhaps wrong integration method)";
+               + t_curr + "; perhaps wrong integration method)";
       break;
 
     case -2:
       retval = "excess accuracy requested (tolerances too small)";
       break;
 
     case -3:
       retval = "invalid input detected (see printed message)";
       break;
 
     case -4:
       retval = std::string ("repeated error test failures (t = ")
-        + t_curr + "; check all inputs)";
+               + t_curr + "; check all inputs)";
       break;
 
     case -5:
       retval = std::string ("repeated convergence failures (t = ")
-        + t_curr
-        + "; perhaps bad Jacobian supplied or wrong choice of integration method or tolerances)";
+               + t_curr
+               + "; perhaps bad Jacobian supplied or wrong choice of integration method or tolerances)";
       break;
 
     case -6:
       retval = std::string ("error weight became zero during problem. (t = ")
-        + t_curr
-        + "; solution component i vanished, and atol or atol(i) == 0)";
+               + t_curr
+               + "; solution component i vanished, and atol or atol(i) == 0)";
       break;
 
     case -13:
       retval = "return requested in user-supplied function (t = "
-        + t_curr + ")";
+               + t_curr + ")";
       break;
 
     default:
       retval = "unknown error state";
       break;
     }
 
   return retval;
diff --git a/liboctave/numeric/ODE.h b/liboctave/numeric/ODE.h
--- a/liboctave/numeric/ODE.h
+++ b/liboctave/numeric/ODE.h
@@ -36,24 +36,24 @@ public:
 
   ODE (const ColumnVector& s, double tm, const ODEFunc& f)
     : base_diff_eqn (s, tm), ODEFunc (f) { }
 
   ODE (const ODE& a)
     : base_diff_eqn (a), ODEFunc (a) { }
 
   ODE& operator = (const ODE& a)
-    {
-      if (this != &a)
-        {
-          base_diff_eqn::operator = (a);
-          ODEFunc::operator = (a);
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        base_diff_eqn::operator = (a);
+        ODEFunc::operator = (a);
+      }
+    return *this;
+  }
 
   virtual ~ODE (void) { }
 
   // Derived classes must provide functions to actually do the
   // integration.
 
   // Return the vector of states at output time t.
   virtual ColumnVector do_integrate (double tt) = 0;
@@ -66,49 +66,49 @@ public:
   virtual Matrix do_integrate (const ColumnVector& tt,
                                const ColumnVector& ttcrit) = 0;
 
   // Lots of ways to call the single function and optionally set and
   // get additional information.
 
   // Integrate to t from current point.
   virtual ColumnVector integrate (double tt)
-    { return do_integrate (tt); }
+  { return do_integrate (tt); }
 
   // Set new x0, t0 and integrate to t.
   virtual ColumnVector integrate (const ColumnVector& x0, double t0, double tt)
-    {
-      initialize (x0, t0);
-      return do_integrate (tt);
-    }
+  {
+    initialize (x0, t0);
+    return do_integrate (tt);
+  }
 
   // Integrate from current point and return output at all points
   // specified by t.
   virtual Matrix integrate (const ColumnVector& tt)
-    { return do_integrate (tt); }
+  { return do_integrate (tt); }
 
   // Set new x0, t0 and integrate to return output at all points
   // specified by t.
   virtual Matrix integrate (const ColumnVector& x0, double t0,
                             const ColumnVector& tt)
-    {
-      initialize (x0, t0);
-      return do_integrate (tt);
-    }
+  {
+    initialize (x0, t0);
+    return do_integrate (tt);
+  }
 
   // Integrate from current point and return output at all points
   // specified by t.
   virtual Matrix integrate (const ColumnVector& tt,
                             const ColumnVector& ttcrit)
-    { return do_integrate (tt, ttcrit); }
+  { return do_integrate (tt, ttcrit); }
 
   // Set new x0, t0 and integrate to return output at all points
   // specified by t.
   virtual Matrix integrate (const ColumnVector& x0, double t0,
                             const ColumnVector& tt,
                             const ColumnVector& ttcrit)
-    {
-      initialize (x0, t0);
-      return do_integrate (tt, ttcrit);
-    }
+  {
+    initialize (x0, t0);
+    return do_integrate (tt, ttcrit);
+  }
 };
 
 #endif
diff --git a/liboctave/numeric/ODEFunc.h b/liboctave/numeric/ODEFunc.h
--- a/liboctave/numeric/ODEFunc.h
+++ b/liboctave/numeric/ODEFunc.h
@@ -42,45 +42,45 @@ public:
 
   ODEFunc (ODERHSFunc f, ODEJacFunc j)
     : fun (f), jac (j), reset (true) { }
 
   ODEFunc (const ODEFunc& a)
     : fun (a.fun), jac (a.jac), reset (true) { }
 
   ODEFunc& operator = (const ODEFunc& a)
-    {
-      if (this != &a)
-        {
-          fun = a.fun;
-          jac = a.jac;
-          reset = a.reset;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        fun = a.fun;
+        jac = a.jac;
+        reset = a.reset;
+      }
+    return *this;
+  }
 
   virtual ~ODEFunc (void) { }
 
   ODERHSFunc function (void) const { return fun; }
 
   ODEFunc& set_function (ODERHSFunc f)
-    {
-      fun = f;
-      reset = true;
-      return *this;
-    }
+  {
+    fun = f;
+    reset = true;
+    return *this;
+  }
 
   ODEJacFunc jacobian_function (void) const { return jac; }
 
   ODEFunc& set_jacobian_function (ODEJacFunc j)
-    {
-      jac = j;
-      reset = true;
-      return *this;
-    }
+  {
+    jac = j;
+    reset = true;
+    return *this;
+  }
 
 protected:
 
   ODERHSFunc fun;
   ODEJacFunc jac;
 
   // This variable is TRUE when this object is constructed, and also
   // after any internal data has changed.  Derived classes may use
diff --git a/liboctave/numeric/ODES.h b/liboctave/numeric/ODES.h
--- a/liboctave/numeric/ODES.h
+++ b/liboctave/numeric/ODES.h
@@ -41,27 +41,27 @@ public:
         ODESFunc& f)
     : base_diff_eqn (s, tm), ODESFunc (f), xdot (s.length (), 0.0),
       theta (xtheta) { }
 
   ODES (const ODES& a)
     : base_diff_eqn (a), ODESFunc (a), xdot (a.xdot), theta (a.theta) { }
 
   ODES& operator = (const ODES& a)
-    {
-      if (this != &a)
-        {
-          base_diff_eqn::operator = (a);
-          ODESFunc::operator = (a);
+  {
+    if (this != &a)
+      {
+        base_diff_eqn::operator = (a);
+        ODESFunc::operator = (a);
 
-          xdot = a.xdot;
-          theta = a.theta;
-        }
-      return *this;
-    }
+        xdot = a.xdot;
+        theta = a.theta;
+      }
+    return *this;
+  }
 
   ~ODES (void) { }
 
   ColumnVector parameter_vector (void) { return theta; }
 
   void initialize (const ColumnVector& x, double t);
 
   void initialize (const ColumnVector& x, double t,
diff --git a/liboctave/numeric/ODESFunc.h b/liboctave/numeric/ODESFunc.h
--- a/liboctave/numeric/ODESFunc.h
+++ b/liboctave/numeric/ODESFunc.h
@@ -26,20 +26,20 @@ along with Octave; see the file COPYING.
 #include "dMatrix.h"
 
 class
 ODESFunc
 {
 public:
 
   struct DAEJac
-    {
-      Matrix *dfdxdot;
-      Matrix *dfdx;
-    };
+  {
+    Matrix *dfdxdot;
+    Matrix *dfdx;
+  };
 
   typedef ColumnVector (*ODES_fsub) (const ColumnVector& x, double,
                                      const ColumnVector& theta);
 
   typedef ColumnVector (*ODES_bsub) (const ColumnVector& x, double,
                                      const ColumnVector& theta, int column);
 
   typedef Matrix (*ODES_jsub) (const ColumnVector& x, double,
@@ -56,51 +56,51 @@ public:
 
   ODESFunc (ODES_fsub f, ODES_bsub b, ODES_jsub j)
     : fsub (f), bsub (b), jsub (j) { }
 
   ODESFunc (const ODESFunc& a)
     : fsub (a.fsub), bsub (a.bsub), jsub (a.jsub) { }
 
   ODESFunc& operator = (const ODESFunc& a)
-    {
-      if (this != &a)
-        {
-          fsub = a.fsub;
-          bsub = a.bsub;
-          jsub = a.jsub;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        fsub = a.fsub;
+        bsub = a.bsub;
+        jsub = a.jsub;
+      }
+    return *this;
+  }
 
   virtual ~ODESFunc (void) { }
 
   ODES_fsub fsub_function (void) const { return fsub; }
 
   ODESFunc& set_fsub_function (ODES_fsub f)
-    {
-      fsub = f;
-      return *this;
-    }
+  {
+    fsub = f;
+    return *this;
+  }
 
   ODES_bsub bsub_function (void) const { return bsub; }
 
   ODESFunc& set_bsub_function (ODES_bsub b)
-    {
-      bsub = b;
-      return *this;
-    }
+  {
+    bsub = b;
+    return *this;
+  }
 
   ODES_jsub jsub_function (void) const { return jsub; }
 
   ODESFunc& set_jsub_function (ODES_jsub j)
-    {
-      jsub = j;
-      return *this;
-    }
+  {
+    jsub = j;
+    return *this;
+  }
 
 protected:
 
   ODES_fsub fsub;
   ODES_bsub bsub;
   ODES_jsub jsub;
 };
 
diff --git a/liboctave/numeric/Quad.cc b/liboctave/numeric/Quad.cc
--- a/liboctave/numeric/Quad.cc
+++ b/liboctave/numeric/Quad.cc
@@ -28,18 +28,17 @@ along with Octave; see the file COPYING.
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "quit.h"
 #include "sun-utils.h"
 
 static integrand_fcn user_fcn;
 static float_integrand_fcn float_user_fcn;
 
-// FIXME -- would be nice to not have to have this global
-// variable.
+// FIXME: would be nice to not have to have this global variable.
 // Nonzero means an error occurred in the calculation of the integrand
 // function, and the user wants us to quit.
 int quad_integration_error = 0;
 
 typedef octave_idx_type (*quad_fcn_ptr) (double*, int&, double*);
 typedef octave_idx_type (*quad_float_fcn_ptr) (float*, int&, float*);
 
 extern "C"
@@ -119,17 +118,18 @@ float_user_function (float *x, int& ierr
     ierr = -1;
 
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 double
-DefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr)
+DefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval,
+                       double& abserr)
 {
   octave_idx_type npts = singularities.capacity () + 2;
   double *points = singularities.fortran_vec ();
   double result = 0.0;
 
   octave_idx_type leniw = 183*npts - 122;
   Array<octave_idx_type> iwork (dim_vector (leniw, 1));
   octave_idx_type *piwork = iwork.fortran_vec ();
@@ -155,17 +155,18 @@ DefQuad::do_integrate (octave_idx_type& 
 float
 DefQuad::do_integrate (octave_idx_type&, octave_idx_type&, float&)
 {
   (*current_liboctave_error_handler) ("incorrect integration function called");
   return 0.0;
 }
 
 double
-IndefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr)
+IndefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval,
+                         double& abserr)
 {
   double result = 0.0;
 
   octave_idx_type leniw = 128;
   Array<octave_idx_type> iwork (dim_vector (leniw, 1));
   octave_idx_type *piwork = iwork.fortran_vec ();
 
   octave_idx_type lenw = 8*leniw;
@@ -215,17 +216,18 @@ IndefQuad::do_integrate (octave_idx_type
 double
 FloatDefQuad::do_integrate (octave_idx_type&, octave_idx_type&, double&)
 {
   (*current_liboctave_error_handler) ("incorrect integration function called");
   return 0.0;
 }
 
 float
-FloatDefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, float& abserr)
+FloatDefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval,
+                            float& abserr)
 {
   octave_idx_type npts = singularities.capacity () + 2;
   float *points = singularities.fortran_vec ();
   float result = 0.0;
 
   octave_idx_type leniw = 183*npts - 122;
   Array<octave_idx_type> iwork (dim_vector (leniw, 1));
   octave_idx_type *piwork = iwork.fortran_vec ();
@@ -251,17 +253,18 @@ FloatDefQuad::do_integrate (octave_idx_t
 double
 FloatIndefQuad::do_integrate (octave_idx_type&, octave_idx_type&, double&)
 {
   (*current_liboctave_error_handler) ("incorrect integration function called");
   return 0.0;
 }
 
 float
-FloatIndefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval, float& abserr)
+FloatIndefQuad::do_integrate (octave_idx_type& ier, octave_idx_type& neval,
+                              float& abserr)
 {
   float result = 0.0;
 
   octave_idx_type leniw = 128;
   Array<octave_idx_type> iwork (dim_vector (leniw, 1));
   octave_idx_type *piwork = iwork.fortran_vec ();
 
   octave_idx_type lenw = 8*leniw;
diff --git a/liboctave/numeric/Quad.h b/liboctave/numeric/Quad.h
--- a/liboctave/numeric/Quad.h
+++ b/liboctave/numeric/Quad.h
@@ -32,103 +32,106 @@ along with Octave; see the file COPYING.
 #if !defined (octave_Quad_typedefs)
 #define octave_Quad_typedefs 1
 
 typedef double (*integrand_fcn) (double x);
 typedef float (*float_integrand_fcn) (float x);
 
 #endif
 
-// FIXME -- would be nice to not have to have this global
-// variable.
+// FIXME: would be nice to not have to have this global variable.
 // Nonzero means an error occurred in the calculation of the integrand
 // function, and the user wants us to quit.
 extern OCTAVE_API int quad_integration_error;
 
 #include "Quad-opts.h"
 
 class
 OCTAVE_API
 Quad : public Quad_options
 {
- public:
+public:
 
   Quad (integrand_fcn fcn)
     : Quad_options (), f (fcn), ff () { }
 
   Quad (float_integrand_fcn fcn)
     : Quad_options (), f (), ff (fcn) { }
 
   virtual ~Quad (void) { }
 
   virtual double integrate (void)
-    {
-      octave_idx_type ier, neval;
-      double abserr;
-      return do_integrate (ier, neval, abserr);
-    }
+  {
+    octave_idx_type ier, neval;
+    double abserr;
+    return do_integrate (ier, neval, abserr);
+  }
 
   virtual float float_integrate (void)
-    {
-      octave_idx_type ier, neval;
-      float abserr;
-      return do_integrate (ier, neval, abserr);
-    }
+  {
+    octave_idx_type ier, neval;
+    float abserr;
+    return do_integrate (ier, neval, abserr);
+  }
 
   virtual double integrate (octave_idx_type& ier)
-    {
-      octave_idx_type neval;
-      double abserr;
-      return do_integrate (ier, neval, abserr);
-    }
+  {
+    octave_idx_type neval;
+    double abserr;
+    return do_integrate (ier, neval, abserr);
+  }
 
   virtual float float_integrate (octave_idx_type& ier)
-    {
-      octave_idx_type neval;
-      float abserr;
-      return do_integrate (ier, neval, abserr);
-    }
+  {
+    octave_idx_type neval;
+    float abserr;
+    return do_integrate (ier, neval, abserr);
+  }
 
   virtual double integrate (octave_idx_type& ier, octave_idx_type& neval)
-    {
-      double abserr;
-      return do_integrate (ier, neval, abserr);
-    }
+  {
+    double abserr;
+    return do_integrate (ier, neval, abserr);
+  }
 
   virtual float float_integrate (octave_idx_type& ier, octave_idx_type& neval)
-    {
-      float abserr;
-      return do_integrate (ier, neval, abserr);
-    }
+  {
+    float abserr;
+    return do_integrate (ier, neval, abserr);
+  }
 
-  virtual double integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr)
-    {
-      return do_integrate (ier, neval, abserr);
-    }
+  virtual double integrate (octave_idx_type& ier, octave_idx_type& neval,
+                            double& abserr)
+  {
+    return do_integrate (ier, neval, abserr);
+  }
 
-  virtual float float_integrate (octave_idx_type& ier, octave_idx_type& neval, float& abserr)
-    {
-      return do_integrate (ier, neval, abserr);
-    }
+  virtual float float_integrate (octave_idx_type& ier, octave_idx_type& neval,
+                                 float& abserr)
+  {
+    return do_integrate (ier, neval, abserr);
+  }
 
-  virtual double do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr) = 0;
+  virtual double do_integrate (octave_idx_type& ier, octave_idx_type& neval,
+                               double& abserr) = 0;
 
-  virtual float do_integrate (octave_idx_type& ier, octave_idx_type& neval, float& abserr) = 0;
+  virtual float do_integrate (octave_idx_type& ier, octave_idx_type& neval,
+                              float& abserr) = 0;
 
- protected:
+protected:
 
   integrand_fcn f;
   float_integrand_fcn ff;
 };
 
 class
 OCTAVE_API
 DefQuad : public Quad
 {
- public:
+public:
 
   DefQuad (integrand_fcn fcn)
     : Quad (fcn), lower_limit (0.0), upper_limit (1.0), singularities () { }
 
   DefQuad (integrand_fcn fcn, double ll, double ul)
     : Quad (fcn), lower_limit (ll), upper_limit (ul), singularities () { }
 
   DefQuad (integrand_fcn fcn, double ll, double ul,
@@ -137,110 +140,118 @@ DefQuad : public Quad
       singularities (sing) { }
 
   DefQuad (integrand_fcn fcn, const ColumnVector& sing)
     : Quad (fcn), lower_limit (0.0), upper_limit (1.0),
       singularities (sing) { }
 
   ~DefQuad (void) { }
 
-  double do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr);
+  double do_integrate (octave_idx_type& ier, octave_idx_type& neval,
+                       double& abserr);
 
-  float do_integrate (octave_idx_type& ier, octave_idx_type& neval, float& abserr);
+  float do_integrate (octave_idx_type& ier, octave_idx_type& neval,
+                      float& abserr);
 
- private:
+private:
 
   double lower_limit;
   double upper_limit;
 
   ColumnVector singularities;
 };
 
 class
 OCTAVE_API
 IndefQuad : public Quad
 {
- public:
+public:
 
   enum IntegralType { bound_to_inf, neg_inf_to_bound, doubly_infinite };
 
   IndefQuad (integrand_fcn fcn)
     : Quad (fcn), bound (0.0), type (bound_to_inf), integration_error (0) { }
 
   IndefQuad (integrand_fcn fcn, double b, IntegralType t)
     : Quad (fcn), bound (b), type (t), integration_error (0) { }
 
   ~IndefQuad (void) { }
 
-  double do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr);
+  double do_integrate (octave_idx_type& ier, octave_idx_type& neval,
+                       double& abserr);
 
-  float do_integrate (octave_idx_type& ier, octave_idx_type& neval, float& abserr);
+  float do_integrate (octave_idx_type& ier, octave_idx_type& neval,
+                      float& abserr);
 
- private:
+private:
 
   double bound;
   IntegralType type;
   int integration_error;
 };
 
 class
 OCTAVE_API
 FloatDefQuad : public Quad
 {
- public:
+public:
 
   FloatDefQuad (float_integrand_fcn fcn)
     : Quad (fcn), lower_limit (0.0), upper_limit (1.0), singularities () { }
 
   FloatDefQuad (float_integrand_fcn fcn, float ll, float ul)
     : Quad (fcn), lower_limit (ll), upper_limit (ul), singularities () { }
 
   FloatDefQuad (float_integrand_fcn fcn, float ll, float ul,
-           const FloatColumnVector& sing)
+                const FloatColumnVector& sing)
     : Quad (fcn), lower_limit (ll), upper_limit (ul),
       singularities (sing) { }
 
   FloatDefQuad (float_integrand_fcn fcn, const FloatColumnVector& sing)
     : Quad (fcn), lower_limit (0.0), upper_limit (1.0),
       singularities (sing) { }
 
   ~FloatDefQuad (void) { }
 
-  double do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr);
+  double do_integrate (octave_idx_type& ier, octave_idx_type& neval,
+                       double& abserr);
 
-  float do_integrate (octave_idx_type& ier, octave_idx_type& neval, float& abserr);
+  float do_integrate (octave_idx_type& ier, octave_idx_type& neval,
+                      float& abserr);
 
- private:
+private:
 
   float lower_limit;
   float upper_limit;
 
   FloatColumnVector singularities;
 };
 
 class
 OCTAVE_API
 FloatIndefQuad : public Quad
 {
- public:
+public:
 
   enum IntegralType { bound_to_inf, neg_inf_to_bound, doubly_infinite };
 
   FloatIndefQuad (float_integrand_fcn fcn)
     : Quad (fcn), bound (0.0), type (bound_to_inf), integration_error (0) { }
 
   FloatIndefQuad (float_integrand_fcn fcn, double b, IntegralType t)
     : Quad (fcn), bound (b), type (t), integration_error (0) { }
 
   ~FloatIndefQuad (void) { }
 
-  double do_integrate (octave_idx_type& ier, octave_idx_type& neval, double& abserr);
+  double do_integrate (octave_idx_type& ier, octave_idx_type& neval,
+                       double& abserr);
 
-  float do_integrate (octave_idx_type& ier, octave_idx_type& neval, float& abserr);
+  float do_integrate (octave_idx_type& ier, octave_idx_type& neval,
+                      float& abserr);
 
- private:
+private:
 
   float bound;
   IntegralType type;
   int integration_error;
 };
 
 #endif
diff --git a/liboctave/numeric/SparseCmplxCHOL.h b/liboctave/numeric/SparseCmplxCHOL.h
--- a/liboctave/numeric/SparseCmplxCHOL.h
+++ b/liboctave/numeric/SparseCmplxCHOL.h
@@ -25,73 +25,85 @@ along with Octave; see the file COPYING.
 #define octave_sparse_complex_CHOL_h 1
 
 #include "sparse-base-chol.h"
 #include "dSparse.h"
 #include "CSparse.h"
 
 class
 OCTAVE_API
-SparseComplexCHOL :
-  public sparse_base_chol <SparseComplexMatrix, Complex, SparseMatrix>
+SparseComplexCHOL
+  : public sparse_base_chol <SparseComplexMatrix, Complex, SparseMatrix>
 {
 public:
 
-  SparseComplexCHOL (void) :
-    sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> () { }
+  SparseComplexCHOL (void)
+    : sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> () { }
 
   SparseComplexCHOL (const SparseComplexMatrix& a, bool natural = true,
-                     bool force = false) :
-    sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> (a, natural, force) { }
+                     bool force = false)
+    : sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix>
+       (a, natural, force) { }
 
   SparseComplexCHOL (const SparseComplexMatrix& a, octave_idx_type& info,
-                     bool natural = true, bool force = false) :
-    sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> (a, info, natural, force) { }
+                     bool natural = true, bool force = false)
+    : sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix>
+       (a, info, natural, force) { }
 
-  SparseComplexCHOL (const SparseComplexCHOL& a) :
-    sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> (a) { }
+  SparseComplexCHOL (const SparseComplexCHOL& a)
+    : sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix> (a) { }
 
   ~SparseComplexCHOL (void) { }
 
   SparseComplexCHOL& operator = (const SparseComplexCHOL& a)
-    {
-      if (this != &a)
-        sparse_base_chol <SparseComplexMatrix, Complex, SparseMatrix> ::
-          operator = (a);
+  {
+    if (this != &a)
+      sparse_base_chol <SparseComplexMatrix, Complex, SparseMatrix> ::
+      operator = (a);
 
-      return *this;
-    }
+    return *this;
+  }
 
   SparseComplexMatrix chol_matrix (void) const { return R (); }
 
   SparseComplexMatrix L (void) const
-    { return sparse_base_chol<SparseComplexMatrix, Complex,
-        SparseMatrix>:: L (); }
+  {
+    return sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix>:: L ();
+  }
 
   SparseComplexMatrix R (void) const
-    { return sparse_base_chol<SparseComplexMatrix, Complex,
-        SparseMatrix>:: R (); }
+  {
+    return sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix>:: R ();
+  }
 
   octave_idx_type P (void) const
-   { return sparse_base_chol<SparseComplexMatrix, Complex,
-        SparseMatrix>:: P (); }
+  {
+    return sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix>:: P ();
+  }
 
   ColumnVector perm (void) const
-    { return sparse_base_chol<SparseComplexMatrix, Complex,
-        SparseMatrix>:: perm (); }
+  {
+    return sparse_base_chol<SparseComplexMatrix, Complex,
+                            SparseMatrix>:: perm ();
+  }
 
   SparseMatrix Q (void) const
-    { return sparse_base_chol<SparseComplexMatrix, Complex,
-        SparseMatrix>:: Q (); }
+  {
+    return sparse_base_chol<SparseComplexMatrix, Complex, SparseMatrix>:: Q ();
+  }
 
   double rcond (void) const
-    { return sparse_base_chol<SparseComplexMatrix, Complex,
-        SparseMatrix>:: rcond (); }
+  {
+    return sparse_base_chol<SparseComplexMatrix, Complex,
+                            SparseMatrix>:: rcond ();
+  }
 
   // Compute the inverse of a matrix using the Cholesky factorization.
   SparseComplexMatrix inverse (void) const
-    { return sparse_base_chol<SparseComplexMatrix, Complex,
-        SparseMatrix>:: inverse (); }
+  {
+    return sparse_base_chol<SparseComplexMatrix, Complex,
+                            SparseMatrix>:: inverse ();
+  }
 };
 
 SparseComplexMatrix OCTAVE_API chol2inv (const SparseComplexMatrix& r);
 
 #endif
diff --git a/liboctave/numeric/SparseCmplxLU.cc b/liboctave/numeric/SparseCmplxLU.cc
--- a/liboctave/numeric/SparseCmplxLU.cc
+++ b/liboctave/numeric/SparseCmplxLU.cc
@@ -33,17 +33,18 @@ along with Octave; see the file COPYING.
 #include "SparseCmplxLU.h"
 #include "oct-spparms.h"
 
 // Instantiate the base LU class for the types we need.
 
 #include "sparse-base-lu.h"
 #include "sparse-base-lu.cc"
 
-template class sparse_base_lu <SparseComplexMatrix, Complex, SparseMatrix, double>;
+template class sparse_base_lu <SparseComplexMatrix, Complex,
+                               SparseMatrix, double>;
 
 #include "oct-sparse.h"
 
 SparseComplexLU::SparseComplexLU (const SparseComplexMatrix& a,
                                   const Matrix& piv_thres, bool scale)
 {
 #ifdef HAVE_UMFPACK
   octave_idx_type nr = a.rows ();
@@ -69,17 +70,17 @@ SparseComplexLU::SparseComplexLU (const 
   else
     {
       tmp = octave_sparse_params::get_key ("piv_tol");
       if (!xisnan (tmp))
         Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
 
       tmp = octave_sparse_params::get_key ("sym_tol");
       if (!xisnan (tmp))
-          Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
+        Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
 
   // Set whether we are allowed to modify Q or not
   tmp = octave_sparse_params::get_key ("autoamd");
   if (!xisnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
   // Turn-off UMFPACK scaling for LU
@@ -104,33 +105,33 @@ SparseComplexLU::SparseComplexLU (const 
   int status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai,
                                           reinterpret_cast<const double *> (Ax),
                                           0, 0,
                                           &Symbolic, control, info);
 
   if (status < 0)
     {
       (*current_liboctave_error_handler)
-            ("SparseComplexLU::SparseComplexLU symbolic factorization failed");
+        ("SparseComplexLU::SparseComplexLU symbolic factorization failed");
 
       UMFPACK_ZNAME (report_status) (control, status);
       UMFPACK_ZNAME (report_info) (control, info);
 
-      UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
+      UMFPACK_ZNAME (free_symbolic) (&Symbolic);
     }
   else
     {
       UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
       void *Numeric;
       status = UMFPACK_ZNAME (numeric) (Ap, Ai,
                                         reinterpret_cast<const double *> (Ax),
                                         0, Symbolic, &Numeric, control,
                                         info);
-      UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
+      UMFPACK_ZNAME (free_symbolic) (&Symbolic);
 
       cond = Info (UMFPACK_RCOND);
 
       if (status < 0)
         {
           (*current_liboctave_error_handler)
             ("SparseComplexLU::SparseComplexLU numeric factorization failed");
 
@@ -140,17 +141,17 @@ SparseComplexLU::SparseComplexLU (const 
           UMFPACK_ZNAME (free_numeric) (&Numeric);
         }
       else
         {
           UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
           octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
           status = UMFPACK_ZNAME (get_lunz) (&lnz, &unz, &ignore1,
-                                        &ignore2, &ignore3, Numeric) ;
+                                             &ignore2, &ignore3, Numeric);
 
           if (status < 0)
             {
               (*current_liboctave_error_handler)
                 ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
 
               UMFPACK_ZNAME (report_status) (control, status);
               UMFPACK_ZNAME (report_info) (control, info);
@@ -199,17 +200,17 @@ SparseComplexLU::SparseComplexLU (const 
               octave_idx_type do_recip;
               status = UMFPACK_ZNAME (get_numeric) (Ltp, Ltj,
                                                     reinterpret_cast<double *> (Ltx),
                                                     0, Up, Uj,
                                                     reinterpret_cast <double *> (Ux),
                                                     0, p, q, 0, 0,
                                                     &do_recip, Rx, Numeric);
 
-              UMFPACK_ZNAME (free_numeric) (&Numeric) ;
+              UMFPACK_ZNAME (free_numeric) (&Numeric);
 
               if (status < 0)
                 {
                   (*current_liboctave_error_handler)
                     ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
 
                   UMFPACK_ZNAME (report_status) (control, status);
                 }
@@ -217,24 +218,24 @@ SparseComplexLU::SparseComplexLU (const 
                 {
                   Lfact = Lfact.transpose ();
 
                   if (do_recip)
                     for (octave_idx_type i = 0; i < nr; i++)
                       Rx[i] = 1.0 / Rx[i];
 
                   UMFPACK_ZNAME (report_matrix) (nr, n_inner,
-                                            Lfact.cidx (), Lfact.ridx (),
-                                            reinterpret_cast<double *> (Lfact.data ()),
-                                            0, 1, control);
+                                                 Lfact.cidx (), Lfact.ridx (),
+                                                 reinterpret_cast<double *> (Lfact.data ()),
+                                                 0, 1, control);
 
                   UMFPACK_ZNAME (report_matrix) (n_inner, nc,
-                                            Ufact.cidx (), Ufact.ridx (),
-                                            reinterpret_cast<double *> (Ufact.data ()),
-                                            0, 1, control);
+                                                 Ufact.cidx (), Ufact.ridx (),
+                                                 reinterpret_cast<double *> (Ufact.data ()),
+                                                 0, 1, control);
                   UMFPACK_ZNAME (report_perm) (nr, p, control);
                   UMFPACK_ZNAME (report_perm) (nc, q, control);
                 }
 
               UMFPACK_ZNAME (report_info) (control, info);
             }
         }
     }
@@ -307,57 +308,59 @@ SparseComplexLU::SparseComplexLU (const 
 
       UMFPACK_ZNAME (report_control) (control);
 
       const octave_idx_type *Ap = a.cidx ();
       const octave_idx_type *Ai = a.ridx ();
       const Complex *Ax = a.data ();
 
       UMFPACK_ZNAME (report_matrix) (nr, nc, Ap, Ai,
-                                reinterpret_cast<const double *> (Ax), 0,
-                                1, control);
+                                     reinterpret_cast<const double *> (Ax), 0,
+                                     1, control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status;
 
       // Null loop so that qinit is imediately deallocated when not
       // needed
-      do {
-        OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
+      do
+        {
+          OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
 
-        for (octave_idx_type i = 0; i < nc; i++)
-          qinit[i] = static_cast<octave_idx_type> (Qinit (i));
+          for (octave_idx_type i = 0; i < nc; i++)
+            qinit[i] = static_cast<octave_idx_type> (Qinit (i));
 
-        status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai,
-                                       reinterpret_cast<const double *> (Ax),
-                                       0, qinit, &Symbolic, control,
-                                       info);
-      } while (0);
+          status = UMFPACK_ZNAME (qsymbolic) (nr, nc, Ap, Ai,
+                                              reinterpret_cast<const double *> (Ax),
+                                              0, qinit, &Symbolic, control,
+                                              info);
+        }
+      while (0);
 
       if (status < 0)
         {
           (*current_liboctave_error_handler)
             ("SparseComplexLU::SparseComplexLU symbolic factorization failed");
 
           UMFPACK_ZNAME (report_status) (control, status);
           UMFPACK_ZNAME (report_info) (control, info);
 
-          UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
+          UMFPACK_ZNAME (free_symbolic) (&Symbolic);
         }
       else
         {
           UMFPACK_ZNAME (report_symbolic) (Symbolic, control);
 
           void *Numeric;
           status = UMFPACK_ZNAME (numeric) (Ap, Ai,
-                                       reinterpret_cast<const double *> (Ax), 0,
-                                       Symbolic, &Numeric, control, info) ;
-          UMFPACK_ZNAME (free_symbolic) (&Symbolic) ;
+                                            reinterpret_cast<const double *> (Ax), 0,
+                                            Symbolic, &Numeric, control, info);
+          UMFPACK_ZNAME (free_symbolic) (&Symbolic);
 
           cond = Info (UMFPACK_RCOND);
 
           if (status < 0)
             {
               (*current_liboctave_error_handler)
                 ("SparseComplexLU::SparseComplexLU numeric factorization failed");
 
@@ -367,17 +370,18 @@ SparseComplexLU::SparseComplexLU (const 
               UMFPACK_ZNAME (free_numeric) (&Numeric);
             }
           else
             {
               UMFPACK_ZNAME (report_numeric) (Numeric, control);
 
               octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
               status = UMFPACK_ZNAME (get_lunz) (&lnz, &unz,
-                                            &ignore1, &ignore2, &ignore3, Numeric);
+                                                 &ignore1, &ignore2, &ignore3,
+                                                 Numeric);
 
               if (status < 0)
                 {
                   (*current_liboctave_error_handler)
                     ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
 
                   UMFPACK_ZNAME (report_status) (control, status);
                   UMFPACK_ZNAME (report_info) (control, info);
@@ -385,27 +389,27 @@ SparseComplexLU::SparseComplexLU (const 
                   UMFPACK_ZNAME (free_numeric) (&Numeric);
                 }
               else
                 {
                   octave_idx_type n_inner = (nr < nc ? nr : nc);
 
                   if (lnz < 1)
                     Lfact = SparseComplexMatrix (n_inner, nr,
-                       static_cast<octave_idx_type> (1));
+                                                 static_cast<octave_idx_type> (1));
                   else
                     Lfact = SparseComplexMatrix (n_inner, nr, lnz);
 
                   octave_idx_type *Ltp = Lfact.cidx ();
                   octave_idx_type *Ltj = Lfact.ridx ();
                   Complex *Ltx = Lfact.data ();
 
                   if (unz < 1)
                     Ufact = SparseComplexMatrix (n_inner, nc,
-                       static_cast<octave_idx_type> (1));
+                                                 static_cast<octave_idx_type> (1));
                   else
                     Ufact = SparseComplexMatrix  (n_inner, nc, unz);
 
                   octave_idx_type *Up = Ufact.cidx ();
                   octave_idx_type *Uj = Ufact.ridx ();
                   Complex *Ux = Ufact.data ();
 
                   Rfact = SparseMatrix (nr, nr, nr);
@@ -421,23 +425,23 @@ SparseComplexLU::SparseComplexLU (const 
                   octave_idx_type *p = P.fortran_vec ();
 
                   Q.resize (dim_vector (nc, 1));
                   octave_idx_type *q = Q.fortran_vec ();
 
                   octave_idx_type do_recip;
                   status =
                     UMFPACK_ZNAME (get_numeric) (Ltp, Ltj,
-                                            reinterpret_cast<double *> (Ltx),
-                                            0, Up, Uj,
-                                            reinterpret_cast<double *> (Ux),
-                                            0, p, q, 0, 0,
-                                            &do_recip, Rx, Numeric) ;
+                                                 reinterpret_cast<double *> (Ltx),
+                                                 0, Up, Uj,
+                                                 reinterpret_cast<double *> (Ux),
+                                                 0, p, q, 0, 0,
+                                                 &do_recip, Rx, Numeric);
 
-                  UMFPACK_ZNAME (free_numeric) (&Numeric) ;
+                  UMFPACK_ZNAME (free_numeric) (&Numeric);
 
                   if (status < 0)
                     {
                       (*current_liboctave_error_handler)
                         ("SparseComplexLU::SparseComplexLU extracting LU factors failed");
 
                       UMFPACK_ZNAME (report_status) (control, status);
                     }
@@ -445,26 +449,26 @@ SparseComplexLU::SparseComplexLU (const 
                     {
                       Lfact = Lfact.transpose ();
 
                       if (do_recip)
                         for (octave_idx_type i = 0; i < nr; i++)
                           Rx[i] = 1.0 / Rx[i];
 
                       UMFPACK_ZNAME (report_matrix) (nr, n_inner,
-                                                Lfact.cidx (),
-                                                Lfact.ridx (),
-                                                reinterpret_cast<double *> (Lfact.data ()),
-                                                0, 1, control);
+                                                     Lfact.cidx (),
+                                                     Lfact.ridx (),
+                                                     reinterpret_cast<double *> (Lfact.data ()),
+                                                     0, 1, control);
 
                       UMFPACK_ZNAME (report_matrix) (n_inner, nc,
-                                                Ufact.cidx (),
-                                                Ufact.ridx (),
-                                                reinterpret_cast<double *> (Ufact.data ()),
-                                                0, 1, control);
+                                                     Ufact.cidx (),
+                                                     Ufact.ridx (),
+                                                     reinterpret_cast<double *> (Ufact.data ()),
+                                                     0, 1, control);
                       UMFPACK_ZNAME (report_perm) (nr, p, control);
                       UMFPACK_ZNAME (report_perm) (nc, q, control);
                     }
 
                   UMFPACK_ZNAME (report_info) (control, info);
                 }
             }
         }
diff --git a/liboctave/numeric/SparseCmplxLU.h b/liboctave/numeric/SparseCmplxLU.h
--- a/liboctave/numeric/SparseCmplxLU.h
+++ b/liboctave/numeric/SparseCmplxLU.h
@@ -44,23 +44,24 @@ public:
 
   SparseComplexLU (const SparseComplexMatrix& a, const ColumnVector& Qinit,
                    const Matrix& piv_thres = Matrix (),
                    bool scale = false, bool FixedQ = false,
                    double droptol = -1., bool milu = false,
                    bool udiag = false);
 
   SparseComplexLU (const SparseComplexLU& a)
-    : sparse_base_lu <SparseComplexMatrix, Complex, SparseMatrix, double> (a) { }
+    : sparse_base_lu <SparseComplexMatrix, Complex, SparseMatrix, double> (a)
+  { }
 
   SparseComplexLU& operator = (const SparseComplexLU& a)
-    {
-      if (this != &a)
-        sparse_base_lu <SparseComplexMatrix, Complex, SparseMatrix, double>
-          :: operator = (a);
+  {
+    if (this != &a)
+      sparse_base_lu <SparseComplexMatrix, Complex, SparseMatrix, double>
+                     :: operator = (a);
 
-      return *this;
-    }
+    return *this;
+  }
 
   ~SparseComplexLU (void) { }
 };
 
 #endif
diff --git a/liboctave/numeric/SparseCmplxQR.cc b/liboctave/numeric/SparseCmplxQR.cc
--- a/liboctave/numeric/SparseCmplxQR.cc
+++ b/liboctave/numeric/SparseCmplxQR.cc
@@ -61,17 +61,17 @@ SparseComplexQR::SparseComplexQR_rep::Sp
   A.m = a.rows ();
   A.n = a.cols ();
   nrows = A.m;
   // Cast away const on A, with full knowledge that CSparse won't touch it
   // Prevents the methods below making a copy of the data.
   A.p = const_cast<octave_idx_type *>(a.cidx ());
   A.i = const_cast<octave_idx_type *>(a.ridx ());
   A.x = const_cast<cs_complex_t *>(reinterpret_cast<const cs_complex_t *>
-                                      (a.data ()));
+                                   (a.data ()));
   A.nz = -1;
   BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 #if defined (CS_VER) && (CS_VER >= 2)
   S = CXSPARSE_ZNAME (_sqr) (order, &A, 1);
 #else
   S = CXSPARSE_ZNAME (_sqr) (&A, order - 1, 1);
 #endif
   N = CXSPARSE_ZNAME (_qr) (&A, S);
@@ -306,18 +306,17 @@ qrsolve (const SparseComplexMatrix&a, co
   else if (nr == 0 || nc == 0 || b_nc == 0)
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
         return ComplexMatrix ();
       x.resize (nc, b_nc);
-      cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
-        (x.fortran_vec ());
+      cs_complex_t *vec = reinterpret_cast<cs_complex_t *> (x.fortran_vec ());
       OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
       for (volatile octave_idx_type i = 0, idx = 0; i < b_nc; i++, idx+=nc)
         {
           octave_quit ();
           for (octave_idx_type j = 0; j < b_nr; j++)
             Xx[j] = b.xelem (j,i);
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
@@ -351,18 +350,17 @@ qrsolve (const SparseComplexMatrix&a, co
     }
   else
     {
       SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
         return ComplexMatrix ();
       x.resize (nc, b_nc);
-      cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
-        (x.fortran_vec ());
+      cs_complex_t *vec = reinterpret_cast<cs_complex_t *> (x.fortran_vec ());
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_C99_COMPLEX (buf, nbuf);
       OCTAVE_LOCAL_BUFFER (Complex, Xx, b_nr);
 #if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
         B[i] = q.N ()->B[i];
 #else
@@ -413,17 +411,18 @@ qrsolve (const SparseComplexMatrix&a, co
 
   return x;
 #else
   return ComplexMatrix ();
 #endif
 }
 
 SparseComplexMatrix
-qrsolve (const SparseComplexMatrix&a, const SparseMatrix &b, octave_idx_type &info)
+qrsolve (const SparseComplexMatrix&a, const SparseMatrix &b,
+         octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   SparseComplexMatrix x;
@@ -587,17 +586,18 @@ qrsolve (const SparseComplexMatrix&a, co
   x.maybe_compress ();
   return x;
 #else
   return SparseComplexMatrix ();
 #endif
 }
 
 ComplexMatrix
-qrsolve (const SparseComplexMatrix&a, const ComplexMatrix &b, octave_idx_type &info)
+qrsolve (const SparseComplexMatrix&a, const ComplexMatrix &b,
+         octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   const cs_complex_t *bvec =
@@ -611,17 +611,17 @@ qrsolve (const SparseComplexMatrix&a, co
     x = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
   else if (nr >= nc)
     {
       SparseComplexQR q (a, 2);
       if (! q.ok ())
         return ComplexMatrix ();
       x.resize (nc, b_nc);
       cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
-        (x.fortran_vec ());
+                          (x.fortran_vec ());
       OCTAVE_C99_COMPLEX (buf, q.S ()->m2);
       for (volatile octave_idx_type i = 0, idx = 0, bidx = 0; i < b_nc;
            i++, idx+=nc, bidx+=b_nr)
         {
           octave_quit ();
           for (octave_idx_type j = nr; j < q.S ()->m2; j++)
             buf[j] = OCTAVE_C99_ZERO;
           BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
@@ -651,18 +651,17 @@ qrsolve (const SparseComplexMatrix&a, co
     }
   else
     {
       SparseComplexMatrix at = a.hermitian ();
       SparseComplexQR q (at, 2);
       if (! q.ok ())
         return ComplexMatrix ();
       x.resize (nc, b_nc);
-      cs_complex_t *vec = reinterpret_cast<cs_complex_t *>
-        (x.fortran_vec ());
+      cs_complex_t *vec = reinterpret_cast<cs_complex_t *> (x.fortran_vec ());
       volatile octave_idx_type nbuf = (nc > q.S ()->m2 ? nc : q.S ()->m2);
       OCTAVE_C99_COMPLEX (buf, nbuf);
 #if defined (CS_VER) && (((CS_VER == 2) && (CS_SUBVER >= 2)) || (CS_VER > 2))
       OCTAVE_LOCAL_BUFFER (double, B, nr);
       for (octave_idx_type i = 0; i < nr; i++)
         B[i] = q.N ()->B[i];
 #else
       OCTAVE_LOCAL_BUFFER (Complex, B, nr);
@@ -708,17 +707,18 @@ qrsolve (const SparseComplexMatrix&a, co
 
   return x;
 #else
   return ComplexMatrix ();
 #endif
 }
 
 SparseComplexMatrix
-qrsolve (const SparseComplexMatrix&a, const SparseComplexMatrix &b, octave_idx_type &info)
+qrsolve (const SparseComplexMatrix&a, const SparseComplexMatrix &b,
+         octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nc = b.cols ();
   octave_idx_type b_nr = b.rows ();
   SparseComplexMatrix x;
diff --git a/liboctave/numeric/SparseCmplxQR.h b/liboctave/numeric/SparseCmplxQR.h
--- a/liboctave/numeric/SparseCmplxQR.h
+++ b/liboctave/numeric/SparseCmplxQR.h
@@ -90,44 +90,44 @@ public:
     rep (new SparseComplexQR_rep (SparseComplexMatrix (), 0)) { }
 
   SparseComplexQR (const SparseComplexMatrix& a, int order = 0) :
     rep (new SparseComplexQR_rep (a, order)) { }
 
   SparseComplexQR (const SparseComplexQR& a) : rep (a.rep) { rep->count++; }
 
   ~SparseComplexQR (void)
-    {
-      if (--rep->count == 0)
-        delete rep;
-    }
+  {
+    if (--rep->count == 0)
+      delete rep;
+  }
 
   SparseComplexQR& operator = (const SparseComplexQR& a)
-    {
-      if (this != &a)
-        {
-          if (--rep->count == 0)
-            delete rep;
+  {
+    if (this != &a)
+      {
+        if (--rep->count == 0)
+          delete rep;
 
-          rep = a.rep;
-          rep->count++;
-        }
-      return *this;
-    }
+        rep = a.rep;
+        rep->count++;
+      }
+    return *this;
+  }
 
   bool ok (void) const { return rep->ok (); }
 
   SparseComplexMatrix V (void) const { return rep->V (); }
 
   ColumnVector Pinv (void) const { return rep->P (); }
 
   ColumnVector P (void) const { return rep->P (); }
 
   SparseComplexMatrix R (const bool econ = false) const
-    { return rep->R(econ); }
+  { return rep->R(econ); }
 
   ComplexMatrix C (const ComplexMatrix &b) const { return rep->C(b); }
 
   ComplexMatrix Q (void) const { return rep->Q (); }
 
   friend ComplexMatrix qrsolve (const SparseComplexMatrix &a, const Matrix &b,
                                 octave_idx_type &info);
 
diff --git a/liboctave/numeric/SparseQR.cc b/liboctave/numeric/SparseQR.cc
--- a/liboctave/numeric/SparseQR.cc
+++ b/liboctave/numeric/SparseQR.cc
@@ -688,17 +688,18 @@ qrsolve (const SparseMatrix&a, const Com
 
   return x;
 #else
   return ComplexMatrix ();
 #endif
 }
 
 SparseComplexMatrix
-qrsolve (const SparseMatrix&a, const SparseComplexMatrix &b, octave_idx_type &info)
+qrsolve (const SparseMatrix&a, const SparseComplexMatrix &b,
+         octave_idx_type &info)
 {
   info = -1;
 #ifdef HAVE_CXSPARSE
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
   SparseComplexMatrix x;
diff --git a/liboctave/numeric/SparseQR.h b/liboctave/numeric/SparseQR.h
--- a/liboctave/numeric/SparseQR.h
+++ b/liboctave/numeric/SparseQR.h
@@ -92,33 +92,33 @@ public:
   SparseQR (void) : rep (new SparseQR_rep (SparseMatrix (), 0)) { }
 
   SparseQR (const SparseMatrix& a, int order = 0) :
     rep (new SparseQR_rep (a, order)) { }
 
   SparseQR (const SparseQR& a) : rep (a.rep) { rep->count++; }
 
   ~SparseQR (void)
-    {
-      if (--rep->count == 0)
-        delete rep;
-    }
+  {
+    if (--rep->count == 0)
+      delete rep;
+  }
 
   SparseQR& operator = (const SparseQR& a)
-    {
-      if (this != &a)
-        {
-          if (--rep->count == 0)
-            delete rep;
+  {
+    if (this != &a)
+      {
+        if (--rep->count == 0)
+          delete rep;
 
-          rep = a.rep;
-          rep->count++;
-        }
-      return *this;
-    }
+        rep = a.rep;
+        rep->count++;
+      }
+    return *this;
+  }
 
   bool ok (void) const { return rep->ok (); }
 
   SparseMatrix V (void) const { return rep->V (); }
 
   ColumnVector Pinv (void) const { return rep->P (); }
 
   ColumnVector P (void) const { return rep->P (); }
@@ -128,17 +128,17 @@ public:
   Matrix C (const Matrix &b) const { return rep->C(b); }
 
   Matrix Q (void) const { return rep->Q (); }
 
   friend Matrix qrsolve (const SparseMatrix &a, const Matrix &b,
                          octave_idx_type &info);
 
   friend SparseMatrix qrsolve (const SparseMatrix &a, const SparseMatrix &b,
-                         octave_idx_type &info);
+                               octave_idx_type &info);
 
   friend ComplexMatrix qrsolve (const SparseMatrix &a, const ComplexMatrix &b,
                                 octave_idx_type &info);
 
   friend SparseComplexMatrix qrsolve (const SparseMatrix &a,
                                       const SparseComplexMatrix &b,
                                       octave_idx_type &info);
 
diff --git a/liboctave/numeric/SparsedbleCHOL.h b/liboctave/numeric/SparsedbleCHOL.h
--- a/liboctave/numeric/SparsedbleCHOL.h
+++ b/liboctave/numeric/SparsedbleCHOL.h
@@ -28,59 +28,64 @@ along with Octave; see the file COPYING.
 #include "dSparse.h"
 
 class
 OCTAVE_API
 SparseCHOL : public sparse_base_chol <SparseMatrix, double, SparseMatrix>
 {
 public:
 
-  SparseCHOL (void) : sparse_base_chol<SparseMatrix, double, SparseMatrix> () { }
+  SparseCHOL (void) : sparse_base_chol<SparseMatrix, double, SparseMatrix> ()
+  { }
 
-  SparseCHOL (const SparseMatrix& a, bool natural = true, bool force = false) :
-    sparse_base_chol<SparseMatrix, double, SparseMatrix> (a, natural, force) { }
+  SparseCHOL (const SparseMatrix& a, bool natural = true, bool force = false)
+    : sparse_base_chol<SparseMatrix, double, SparseMatrix> (a, natural, force)
+  { }
 
   SparseCHOL (const SparseMatrix& a, octave_idx_type& info,
-              bool natural = false, bool force = false) :
-    sparse_base_chol<SparseMatrix, double, SparseMatrix> (a, info, natural, force) { }
+              bool natural = false, bool force = false)
+    : sparse_base_chol<SparseMatrix, double, SparseMatrix> (a, info, natural,
+                                                            force)
+  { }
 
   SparseCHOL (const SparseCHOL& a) :
     sparse_base_chol<SparseMatrix, double, SparseMatrix> (a) { }
 
   ~SparseCHOL (void) { }
 
   SparseCHOL& operator = (const SparseCHOL& a)
-    {
-      if (this != &a)
-        sparse_base_chol <SparseMatrix, double, SparseMatrix> :: operator = (a);
+  {
+    if (this != &a)
+      sparse_base_chol <SparseMatrix, double, SparseMatrix> :: operator = (a);
 
-      return *this;
-    }
+    return *this;
+  }
 
   SparseMatrix chol_matrix (void) const { return R (); }
 
   SparseMatrix L (void) const
   { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: L (); }
 
   SparseMatrix R (void) const
-    { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: R (); }
+  { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: R (); }
 
   octave_idx_type P (void) const
-    { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: P (); }
+  { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: P (); }
 
   ColumnVector perm (void) const
-    { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: perm (); }
+  { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: perm (); }
 
   SparseMatrix Q (void) const
-    { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: Q (); }
+  { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: Q (); }
 
   double rcond (void) const
-    { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: rcond (); }
+  { return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: rcond (); }
 
   // Compute the inverse of a matrix using the Cholesky factorization.
   SparseMatrix inverse (void) const
-   { return sparse_base_chol<SparseMatrix, double, SparseMatrix>::
-       inverse (); }
+  {
+    return sparse_base_chol<SparseMatrix, double, SparseMatrix>:: inverse ();
+  }
 };
 
 SparseMatrix OCTAVE_API chol2inv (const SparseMatrix& r);
 
 #endif
diff --git a/liboctave/numeric/SparsedbleLU.cc b/liboctave/numeric/SparsedbleLU.cc
--- a/liboctave/numeric/SparsedbleLU.cc
+++ b/liboctave/numeric/SparsedbleLU.cc
@@ -69,17 +69,17 @@ SparseLU::SparseLU (const SparseMatrix& 
   else
     {
       tmp = octave_sparse_params::get_key ("piv_tol");
       if (!xisnan (tmp))
         Control (UMFPACK_PIVOT_TOLERANCE) = tmp;
 
       tmp = octave_sparse_params::get_key ("sym_tol");
       if (!xisnan (tmp))
-          Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
+        Control (UMFPACK_SYM_PIVOT_TOLERANCE) = tmp;
     }
 
   // Set whether we are allowed to modify Q or not
   tmp = octave_sparse_params::get_key ("autoamd");
   if (!xisnan (tmp))
     Control (UMFPACK_FIXQ) = tmp;
 
   if (scale)
@@ -94,35 +94,35 @@ SparseLU::SparseLU (const SparseMatrix& 
   const double *Ax = a.data ();
 
   UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1, control);
 
   void *Symbolic;
   Matrix Info (1, UMFPACK_INFO);
   double *info = Info.fortran_vec ();
   int status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax, 0,
-                                     &Symbolic, control, info);
+                                          &Symbolic, control, info);
 
   if (status < 0)
     {
       (*current_liboctave_error_handler)
-            ("SparseLU::SparseLU symbolic factorization failed");
+        ("SparseLU::SparseLU symbolic factorization failed");
 
       UMFPACK_DNAME (report_status) (control, status);
       UMFPACK_DNAME (report_info) (control, info);
 
       UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
     }
   else
     {
       UMFPACK_DNAME (report_symbolic) (Symbolic, control);
 
       void *Numeric;
       status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
-                                   &Numeric, control, info) ;
+                                        &Numeric, control, info) ;
       UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
 
       cond = Info (UMFPACK_RCOND);
 
       if (status < 0)
         {
           (*current_liboctave_error_handler)
             ("SparseLU::SparseLU numeric factorization failed");
@@ -133,17 +133,17 @@ SparseLU::SparseLU (const SparseMatrix& 
           UMFPACK_DNAME (free_numeric) (&Numeric);
         }
       else
         {
           UMFPACK_DNAME (report_numeric) (Numeric, control);
 
           octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
           status = UMFPACK_DNAME (get_lunz) (&lnz, &unz, &ignore1,
-                                        &ignore2, &ignore3, Numeric) ;
+                                             &ignore2, &ignore3, Numeric) ;
 
           if (status < 0)
             {
               (*current_liboctave_error_handler)
                 ("SparseLU::SparseLU extracting LU factors failed");
 
               UMFPACK_DNAME (report_status) (control, status);
               UMFPACK_DNAME (report_info) (control, info);
@@ -186,19 +186,19 @@ SparseLU::SparseLU (const SparseMatrix& 
               P.resize (dim_vector (nr, 1));
               octave_idx_type *p = P.fortran_vec ();
 
               Q.resize (dim_vector (nc, 1));
               octave_idx_type *q = Q.fortran_vec ();
 
               octave_idx_type do_recip;
               status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj, Ltx,
-                                               Up, Uj, Ux, p, q, 0,
-                                               &do_recip, Rx,
-                                               Numeric) ;
+                                                    Up, Uj, Ux, p, q, 0,
+                                                    &do_recip, Rx,
+                                                    Numeric) ;
 
               UMFPACK_DNAME (free_numeric) (&Numeric) ;
 
               if (status < 0)
                 {
                   (*current_liboctave_error_handler)
                     ("SparseLU::SparseLU extracting LU factors failed");
 
@@ -208,21 +208,21 @@ SparseLU::SparseLU (const SparseMatrix& 
                 {
                   Lfact = Lfact.transpose ();
 
                   if (do_recip)
                     for (octave_idx_type i = 0; i < nr; i++)
                       Rx[i] = 1.0 / Rx[i];
 
                   UMFPACK_DNAME (report_matrix) (nr, n_inner,
-                                            Lfact.cidx (), Lfact.ridx (),
-                                            Lfact.data (), 1, control);
+                                                 Lfact.cidx (), Lfact.ridx (),
+                                                 Lfact.data (), 1, control);
                   UMFPACK_DNAME (report_matrix) (n_inner, nc,
-                                            Ufact.cidx (), Ufact.ridx (),
-                                            Ufact.data (), 1, control);
+                                                 Ufact.cidx (), Ufact.ridx (),
+                                                 Ufact.data (), 1, control);
                   UMFPACK_DNAME (report_perm) (nr, p, control);
                   UMFPACK_DNAME (report_perm) (nc, q, control);
                 }
 
               UMFPACK_DNAME (report_info) (control, info);
             }
         }
     }
@@ -294,33 +294,35 @@ SparseLU::SparseLU (const SparseMatrix& 
 
       UMFPACK_DNAME (report_control) (control);
 
       const octave_idx_type *Ap = a.cidx ();
       const octave_idx_type *Ai = a.ridx ();
       const double *Ax = a.data ();
 
       UMFPACK_DNAME (report_matrix) (nr, nc, Ap, Ai, Ax, 1,
-                                                     control);
+                                     control);
 
       void *Symbolic;
       Matrix Info (1, UMFPACK_INFO);
       double *info = Info.fortran_vec ();
       int status;
 
       // Null loop so that qinit is imediately deallocated when not needed
-      do {
-        OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
+      do
+        {
+          OCTAVE_LOCAL_BUFFER (octave_idx_type, qinit, nc);
 
-        for (octave_idx_type i = 0; i < nc; i++)
-          qinit[i] = static_cast<octave_idx_type> (Qinit (i));
+          for (octave_idx_type i = 0; i < nc; i++)
+            qinit[i] = static_cast<octave_idx_type> (Qinit (i));
 
-        status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax,
-                                       qinit, &Symbolic, control, info);
-      } while (0);
+          status = UMFPACK_DNAME (qsymbolic) (nr, nc, Ap, Ai, Ax,
+                                              qinit, &Symbolic, control, info);
+        }
+      while (0);
 
       if (status < 0)
         {
           (*current_liboctave_error_handler)
             ("SparseLU::SparseLU symbolic factorization failed");
 
           UMFPACK_DNAME (report_status) (control, status);
           UMFPACK_DNAME (report_info) (control, info);
@@ -328,17 +330,17 @@ SparseLU::SparseLU (const SparseMatrix& 
           UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
         }
       else
         {
           UMFPACK_DNAME (report_symbolic) (Symbolic, control);
 
           void *Numeric;
           status = UMFPACK_DNAME (numeric) (Ap, Ai, Ax, Symbolic,
-                                       &Numeric, control, info) ;
+                                            &Numeric, control, info) ;
           UMFPACK_DNAME (free_symbolic) (&Symbolic) ;
 
           cond = Info (UMFPACK_RCOND);
 
           if (status < 0)
             {
               (*current_liboctave_error_handler)
                 ("SparseLU::SparseLU numeric factorization failed");
@@ -348,18 +350,19 @@ SparseLU::SparseLU (const SparseMatrix& 
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
           else
             {
               UMFPACK_DNAME (report_numeric) (Numeric, control);
 
               octave_idx_type lnz, unz, ignore1, ignore2, ignore3;
-              status = UMFPACK_DNAME (get_lunz) (&lnz, &unz, &ignore1, &ignore2,
-                                                 &ignore3, Numeric) ;
+              status = UMFPACK_DNAME (get_lunz) (&lnz, &unz,
+                                                 &ignore1, &ignore2, &ignore3,
+                                                 Numeric) ;
 
               if (status < 0)
                 {
                   (*current_liboctave_error_handler)
                     ("SparseLU::SparseLU extracting LU factors failed");
 
                   UMFPACK_DNAME (report_status) (control, status);
                   UMFPACK_DNAME (report_info) (control, info);
@@ -402,19 +405,19 @@ SparseLU::SparseLU (const SparseMatrix& 
                   P.resize (dim_vector (nr, 1));
                   octave_idx_type *p = P.fortran_vec ();
 
                   Q.resize (dim_vector (nc, 1));
                   octave_idx_type *q = Q.fortran_vec ();
 
                   octave_idx_type do_recip;
                   status = UMFPACK_DNAME (get_numeric) (Ltp, Ltj,
-                                                   Ltx, Up, Uj, Ux, p, q,
-                                                   0, &do_recip,
-                                                   Rx, Numeric) ;
+                                                        Ltx, Up, Uj, Ux, p, q,
+                                                        0, &do_recip,
+                                                        Rx, Numeric) ;
 
                   UMFPACK_DNAME (free_numeric) (&Numeric) ;
 
                   if (status < 0)
                     {
                       (*current_liboctave_error_handler)
                         ("SparseLU::SparseLU extracting LU factors failed");
 
@@ -424,25 +427,25 @@ SparseLU::SparseLU (const SparseMatrix& 
                     {
                       Lfact = Lfact.transpose ();
 
                       if (do_recip)
                         for (octave_idx_type i = 0; i < nr; i++)
                           Rx[i] = 1.0 / Rx[i];
 
                       UMFPACK_DNAME (report_matrix) (nr, n_inner,
-                                                Lfact.cidx (),
-                                                Lfact.ridx (),
-                                                Lfact.data (),
-                                                1, control);
+                                                     Lfact.cidx (),
+                                                     Lfact.ridx (),
+                                                     Lfact.data (),
+                                                     1, control);
                       UMFPACK_DNAME (report_matrix) (n_inner, nc,
-                                                Ufact.cidx (),
-                                                Ufact.ridx (),
-                                                Ufact.data (),
-                                                1, control);
+                                                     Ufact.cidx (),
+                                                     Ufact.ridx (),
+                                                     Ufact.data (),
+                                                     1, control);
                       UMFPACK_DNAME (report_perm) (nr, p, control);
                       UMFPACK_DNAME (report_perm) (nc, q, control);
                     }
 
                   UMFPACK_DNAME (report_info) (control, info);
                 }
             }
         }
diff --git a/liboctave/numeric/SparsedbleLU.h b/liboctave/numeric/SparsedbleLU.h
--- a/liboctave/numeric/SparsedbleLU.h
+++ b/liboctave/numeric/SparsedbleLU.h
@@ -43,20 +43,20 @@ public:
             const Matrix& piv_thres = Matrix (), bool scale = false,
             bool FixedQ = false, double droptol = -1.,
             bool milu = false, bool udiag = false);
 
   SparseLU (const SparseLU& a)
     : sparse_base_lu <SparseMatrix, double, SparseMatrix, double> (a) { }
 
   SparseLU& operator = (const SparseLU& a)
-    {
-      if (this != &a)
-        sparse_base_lu <SparseMatrix, double, SparseMatrix, double>
-          :: operator = (a);
+  {
+    if (this != &a)
+      sparse_base_lu <SparseMatrix, double, SparseMatrix, double>
+      :: operator = (a);
 
-      return *this;
-    }
+    return *this;
+  }
 
   ~SparseLU (void) { }
 };
 
 #endif
diff --git a/liboctave/numeric/base-aepbal.h b/liboctave/numeric/base-aepbal.h
--- a/liboctave/numeric/base-aepbal.h
+++ b/liboctave/numeric/base-aepbal.h
@@ -38,57 +38,57 @@ public:
 
   base_aepbal (const base_aepbal& a)
     : balanced_mat (a.balanced_mat), scale (a.scale),
       ilo(a.ilo), ihi(a.ihi), job(a.job)
   {
   }
 
   base_aepbal& operator = (const base_aepbal& a)
-    {
-      balanced_mat = a.balanced_mat;
-      scale = a.scale;
-      ilo = a.ilo;
-      ihi = a.ihi;
-      job = a.job;
-      return *this;
-    }
+  {
+    balanced_mat = a.balanced_mat;
+    scale = a.scale;
+    ilo = a.ilo;
+    ihi = a.ihi;
+    job = a.job;
+    return *this;
+  }
 
   virtual ~base_aepbal (void) { }
 
   MatrixT balanced_matrix (void) const { return balanced_mat; }
 
   VectorT permuting_vector (void) const
-    {
-      octave_idx_type n = balanced_mat.rows ();
-      VectorT pv (n);
-      for (octave_idx_type i = 0; i < n; i++)
-        pv(i) = i+1;
-      for (octave_idx_type i = n-1; i >= ihi; i--)
-        {
-          octave_idx_type j = scale(i) - 1;
-          std::swap (pv(i), pv(j));
-        }
-      for (octave_idx_type i = 0; i < ilo-1; i++)
-        {
-          octave_idx_type j = scale(i) - 1;
-          std::swap (pv(i), pv(j));
-        }
+  {
+    octave_idx_type n = balanced_mat.rows ();
+    VectorT pv (n);
+    for (octave_idx_type i = 0; i < n; i++)
+      pv(i) = i+1;
+    for (octave_idx_type i = n-1; i >= ihi; i--)
+      {
+        octave_idx_type j = scale(i) - 1;
+        std::swap (pv(i), pv(j));
+      }
+    for (octave_idx_type i = 0; i < ilo-1; i++)
+      {
+        octave_idx_type j = scale(i) - 1;
+        std::swap (pv(i), pv(j));
+      }
 
-      return pv;
-    }
+    return pv;
+  }
 
   VectorT scaling_vector (void) const
-    {
-      octave_idx_type n = balanced_mat.rows ();
-      VectorT scv (n);
-      for (octave_idx_type i = 0; i < ilo-1; i++)
-        scv(i) = 1;
-      for (octave_idx_type i = ilo-1; i < ihi; i++)
-        scv(i) = scale(i);
-      for (octave_idx_type i = ihi; i < n; i++)
-        scv(i) = 1;
+  {
+    octave_idx_type n = balanced_mat.rows ();
+    VectorT scv (n);
+    for (octave_idx_type i = 0; i < ilo-1; i++)
+      scv(i) = 1;
+    for (octave_idx_type i = ilo-1; i < ihi; i++)
+      scv(i) = scale(i);
+    for (octave_idx_type i = ihi; i < n; i++)
+      scv(i) = 1;
 
-      return scv;
-    }
+    return scv;
+  }
 };
 
 #endif
diff --git a/liboctave/numeric/base-dae.h b/liboctave/numeric/base-dae.h
--- a/liboctave/numeric/base-dae.h
+++ b/liboctave/numeric/base-dae.h
@@ -41,37 +41,37 @@ public:
     : base_diff_eqn (xx, tt), xdot (xxdot) { }
 
   base_diff_alg_eqn (const base_diff_alg_eqn& a)
     : base_diff_eqn (a), xdot (a.xdot) { }
 
   virtual ~base_diff_alg_eqn (void) { }
 
   base_diff_alg_eqn& operator = (const base_diff_alg_eqn& a)
-    {
-      if (this != &a)
-        {
-          base_diff_eqn::operator = (a);
-          xdot = a.xdot;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        base_diff_eqn::operator = (a);
+        xdot = a.xdot;
+      }
+    return *this;
+  }
 
   void initialize (const ColumnVector& x0, double t0)
-    {
-      base_diff_eqn::initialize (x0, t0);
-      xdot = ColumnVector (x0.length (), 0.0);
-    }
+  {
+    base_diff_eqn::initialize (x0, t0);
+    xdot = ColumnVector (x0.length (), 0.0);
+  }
 
   void initialize (const ColumnVector& x0, const ColumnVector& xdot0,
                    double t0)
-    {
-      base_diff_eqn::initialize (x0, t0);
-      xdot = xdot0;
-    }
+  {
+    base_diff_eqn::initialize (x0, t0);
+    xdot = xdot0;
+  }
 
   ColumnVector state_derivative (void) { return xdot; }
 
 protected:
 
   ColumnVector xdot;
 };
 
diff --git a/liboctave/numeric/base-de.h b/liboctave/numeric/base-de.h
--- a/liboctave/numeric/base-de.h
+++ b/liboctave/numeric/base-de.h
@@ -43,58 +43,58 @@ public:
 
   base_diff_eqn (const base_diff_eqn& a)
     : x (a.x), t (a.t), stop_time (0.0), stop_time_set (false),
       restart (true), integration_error (false), istate (0) { }
 
   virtual ~base_diff_eqn (void) { }
 
   base_diff_eqn& operator = (const base_diff_eqn& a)
-    {
-      if (this != &a)
-        {
-          x = a.x;
-          t = a.t;
-          stop_time = a.stop_time;
-          stop_time_set = a.stop_time_set;
-          restart = a.restart;
-          integration_error = a.integration_error;
-          istate = a.istate;
-        }
+  {
+    if (this != &a)
+      {
+        x = a.x;
+        t = a.t;
+        stop_time = a.stop_time;
+        stop_time_set = a.stop_time_set;
+        restart = a.restart;
+        integration_error = a.integration_error;
+        istate = a.istate;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   void initialize (const ColumnVector& x0, double t0)
-    {
-      x = x0;
-      t = t0;
-      integration_error = false;
-      istate = 0;
-      force_restart ();
-    }
+  {
+    x = x0;
+    t = t0;
+    integration_error = false;
+    istate = 0;
+    force_restart ();
+  }
 
   octave_idx_type size (void) const { return x.capacity (); }
 
   ColumnVector state (void) const { return x; }
 
   double time (void) const { return t; }
 
   void set_stop_time (double tt)
-    {
-      stop_time_set = true;
-      stop_time = tt;
-      force_restart ();
-    }
+  {
+    stop_time_set = true;
+    stop_time = tt;
+    force_restart ();
+  }
 
   void clear_stop_time (void)
-    {
-      stop_time_set = false;
-      force_restart ();
-    }
+  {
+    stop_time_set = false;
+    force_restart ();
+  }
 
   virtual void force_restart (void) { restart = true; }
 
   bool integration_ok (void) const { return ! integration_error; }
 
   octave_idx_type integration_state (void) const { return istate; }
 
   virtual std::string error_message (void) const = 0;
diff --git a/liboctave/numeric/base-lu.cc b/liboctave/numeric/base-lu.cc
--- a/liboctave/numeric/base-lu.cc
+++ b/liboctave/numeric/base-lu.cc
@@ -106,17 +106,18 @@ base_lu <lu_type> :: U (void) const
     return a_fact;
 }
 
 template <class lu_type>
 lu_type
 base_lu <lu_type> :: Y (void) const
 {
   if (! packed ())
-    (*current_liboctave_error_handler) ("lu: Y () not implemented for unpacked form");
+    (*current_liboctave_error_handler)
+      ("lu: Y () not implemented for unpacked form");
   return a_fact;
 }
 
 template <class lu_type>
 Array<octave_idx_type>
 base_lu <lu_type> :: getp (void) const
 {
   if (packed ())
diff --git a/liboctave/numeric/base-lu.h b/liboctave/numeric/base-lu.h
--- a/liboctave/numeric/base-lu.h
+++ b/liboctave/numeric/base-lu.h
@@ -41,25 +41,25 @@ public:
 
   base_lu (const base_lu& a)
     : a_fact (a.a_fact), l_fact (a.l_fact), ipvt (a.ipvt) { }
 
   base_lu (const lu_type& l, const lu_type& u,
            const PermMatrix& p);
 
   base_lu& operator = (const base_lu& a)
-    {
-      if (this != &a)
-        {
-          a_fact = a.a_fact;
-          l_fact = a.l_fact;
-          ipvt = a.ipvt;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        a_fact = a.a_fact;
+        l_fact = a.l_fact;
+        ipvt = a.ipvt;
+      }
+    return *this;
+  }
 
   virtual ~base_lu (void) { }
 
   bool packed (void) const;
 
   void unpack (void);
 
   lu_type L (void) const;
diff --git a/liboctave/numeric/base-min.h b/liboctave/numeric/base-min.h
--- a/liboctave/numeric/base-min.h
+++ b/liboctave/numeric/base-min.h
@@ -34,90 +34,90 @@ public:
 
   base_minimizer (const ColumnVector& xx) : x (xx) { }
 
   base_minimizer (const base_minimizer& a) : x (a.x) { }
 
   virtual ~base_minimizer (void) { }
 
   base_minimizer& operator = (const base_minimizer& a)
-    {
-      if (this != &a)
-        x = a.x;
+  {
+    if (this != &a)
+      x = a.x;
 
-      return *this;
-    }
+    return *this;
+  }
 
   // Derived classes must provide a function to actually do the
   // minimization.
 
   virtual ColumnVector do_minimize (double& objf, octave_idx_type& inform,
                                     ColumnVector& lambda) = 0;
 
   // Lots of ways to call the single function and optionally set and
   // get additional information.
 
   virtual ColumnVector minimize (void)
-    {
-      double objf;
-      octave_idx_type inform;
-      ColumnVector lambda;
-      return do_minimize (objf, inform, lambda);
-    }
+  {
+    double objf;
+    octave_idx_type inform;
+    ColumnVector lambda;
+    return do_minimize (objf, inform, lambda);
+  }
 
   virtual ColumnVector minimize (double& objf)
-    {
-      octave_idx_type inform;
-      ColumnVector lambda;
-      return do_minimize (objf, inform, lambda);
-    }
+  {
+    octave_idx_type inform;
+    ColumnVector lambda;
+    return do_minimize (objf, inform, lambda);
+  }
 
   virtual ColumnVector minimize (double& objf, octave_idx_type& inform)
-    {
-      ColumnVector lambda;
-      return do_minimize (objf, inform, lambda);
-    }
+  {
+    ColumnVector lambda;
+    return do_minimize (objf, inform, lambda);
+  }
 
   virtual ColumnVector minimize (double& objf, octave_idx_type& inform,
                                  ColumnVector& lambda)
-    {
-      return do_minimize (objf, inform, lambda);
-    }
+  {
+    return do_minimize (objf, inform, lambda);
+  }
 
   virtual ColumnVector minimize (const ColumnVector& x0)
-    {
-      x = x0;
-      double objf;
-      octave_idx_type inform;
-      ColumnVector lambda;
-      return do_minimize (objf, inform, lambda);
-    }
+  {
+    x = x0;
+    double objf;
+    octave_idx_type inform;
+    ColumnVector lambda;
+    return do_minimize (objf, inform, lambda);
+  }
 
   virtual ColumnVector minimize (const ColumnVector& x0, double& objf)
-    {
-      x = x0;
-      octave_idx_type inform;
-      ColumnVector lambda;
-      return do_minimize (objf, inform, lambda);
-    }
+  {
+    x = x0;
+    octave_idx_type inform;
+    ColumnVector lambda;
+    return do_minimize (objf, inform, lambda);
+  }
 
   virtual ColumnVector minimize (const ColumnVector& x0, double& objf,
                                  octave_idx_type& inform)
-    {
-      x = x0;
-      ColumnVector lambda;
-      return do_minimize (objf, inform, lambda);
-    }
+  {
+    x = x0;
+    ColumnVector lambda;
+    return do_minimize (objf, inform, lambda);
+  }
 
   virtual ColumnVector minimize (const ColumnVector& x0, double& objf,
                                  octave_idx_type& inform, ColumnVector& lambda)
-    {
-      x = x0;
-      return do_minimize (objf, inform, lambda);
-    }
+  {
+    x = x0;
+    return do_minimize (objf, inform, lambda);
+  }
 
   octave_idx_type size (void) const { return x.capacity (); }
 
 protected:
 
   ColumnVector x;
 };
 
diff --git a/liboctave/numeric/base-qr.h b/liboctave/numeric/base-qr.h
--- a/liboctave/numeric/base-qr.h
+++ b/liboctave/numeric/base-qr.h
@@ -44,24 +44,24 @@ public:
 
   base_qr (void) : q (), r () { }
 
   base_qr (const qr_type& q, const qr_type& r);
 
   base_qr (const base_qr& a) : q (a.q), r (a.r) { }
 
   base_qr& operator = (const base_qr& a)
-    {
-      if (this != &a)
-        {
-          q = a.q;
-          r = a.r;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        q = a.q;
+        r = a.r;
+      }
+    return *this;
+  }
 
   virtual ~base_qr (void) { }
 
   qr_type Q (void) const { return q; }
 
   qr_type R (void) const { return r; }
 
   qr_type_t get_type (void) const;
diff --git a/liboctave/numeric/bsxfun.h b/liboctave/numeric/bsxfun.h
--- a/liboctave/numeric/bsxfun.h
+++ b/liboctave/numeric/bsxfun.h
@@ -40,17 +40,18 @@ is_valid_bsxfun (const std::string& name
     {
       octave_idx_type xk = dx(i), yk = dy(i);
       // Check the three conditions for valid bsxfun dims
       if (! ( (xk == yk) || (xk == 1 && yk > 1) || (xk > 1 && yk == 1)))
         return false;
     }
 
   (*current_liboctave_warning_with_id_handler)
-    ("Octave:broadcast", "%s: automatic broadcasting operation applied", name.c_str ());
+    ("Octave:broadcast", "%s: automatic broadcasting operation applied",
+     name.c_str ());
 
   return true;
 }
 
 // since we can't change the size of the assigned-to matrix, we cannot
 // apply singleton expansion to it, so the conditions to check are
 // different here.
 inline
@@ -67,16 +68,17 @@ is_valid_inplace_bsxfun (const std::stri
       octave_idx_type rk = dr(i), xk = dx(i);
 
       // Only two valid canditions to check; can't stretch rk
       if (! ( (rk == xk) || (rk > 1 && xk == 1)))
         return false;
     }
 
   (*current_liboctave_warning_with_id_handler)
-    ("Octave:broadcast", "%s: automatic broadcasting operation applied", name.c_str ());
+    ("Octave:broadcast", "%s: automatic broadcasting operation applied",
+     name.c_str ());
 
   return true;
 }
 
 #include "bsxfun-defs.cc"
 
 #endif
diff --git a/liboctave/numeric/dbleCHOL.cc b/liboctave/numeric/dbleCHOL.cc
--- a/liboctave/numeric/dbleCHOL.cc
+++ b/liboctave/numeric/dbleCHOL.cc
@@ -337,17 +337,17 @@ CHOL::downdate (const ColumnVector& u)
 
   if (u.length () == n)
     {
       if (singular (chol_mat))
         info = 2;
       else
         {
           info = init (chol_mat.transpose () * chol_mat
-                - Matrix (u) * Matrix (u).transpose (), false);
+                       - Matrix (u) * Matrix (u).transpose (), false);
           if (info) info = 1;
         }
     }
   else
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
   return info;
 }
diff --git a/liboctave/numeric/dbleCHOL.h b/liboctave/numeric/dbleCHOL.h
--- a/liboctave/numeric/dbleCHOL.h
+++ b/liboctave/numeric/dbleCHOL.h
@@ -34,37 +34,37 @@ OCTAVE_API
 CHOL
 {
 public:
 
   CHOL (void) : chol_mat (), xrcond (0) { }
 
   CHOL (const Matrix& a, bool calc_cond = false)
     : chol_mat (), xrcond (0)
-    {
-      init (a, calc_cond);
-    }
+  {
+    init (a, calc_cond);
+  }
 
   CHOL (const Matrix& a, octave_idx_type& info, bool calc_cond = false)
     : chol_mat (), xrcond (0)
-    {
-      info = init (a, calc_cond);
-    }
+  {
+    info = init (a, calc_cond);
+  }
 
   CHOL (const CHOL& a) : chol_mat (a.chol_mat), xrcond (a.xrcond) { }
 
   CHOL& operator = (const CHOL& a)
-    {
-      if (this != &a)
-        {
-          chol_mat = a.chol_mat;
-          xrcond = a.xrcond;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        chol_mat = a.chol_mat;
+        xrcond = a.xrcond;
+      }
+    return *this;
+  }
 
   Matrix chol_matrix (void) const { return chol_mat; }
 
   double rcond (void) const { return xrcond; }
 
   // Compute the inverse of a matrix using the Cholesky factorization.
   Matrix inverse (void) const;
 
diff --git a/liboctave/numeric/dbleGEPBAL.h b/liboctave/numeric/dbleGEPBAL.h
--- a/liboctave/numeric/dbleGEPBAL.h
+++ b/liboctave/numeric/dbleGEPBAL.h
@@ -31,40 +31,40 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 GEPBALANCE
 {
 public:
 
   GEPBALANCE (void)
     : balanced_mat (), balanced_mat2 (), balancing_mat (), balancing_mat2 ()
-    { }
+  { }
 
   GEPBALANCE (const Matrix& a, const Matrix& b, const std::string& balance_job)
     : balanced_mat (), balanced_mat2 (), balancing_mat (), balancing_mat2 ()
-    {
-      init (a, b, balance_job);
-    }
+  {
+    init (a, b, balance_job);
+  }
 
   GEPBALANCE (const GEPBALANCE& a)
     : balanced_mat (a.balanced_mat), balanced_mat2 (a.balanced_mat2),
       balancing_mat (a.balancing_mat), balancing_mat2 (a.balancing_mat2)
-    { }
+  { }
 
   GEPBALANCE& operator = (const GEPBALANCE& a)
-    {
-      if (this != &a)
-        {
-          balanced_mat = a.balanced_mat;
-          balanced_mat2 = a.balanced_mat2;
-          balancing_mat = a.balancing_mat;
-          balancing_mat2 = a.balancing_mat2;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        balanced_mat = a.balanced_mat;
+        balanced_mat2 = a.balanced_mat2;
+        balancing_mat = a.balancing_mat;
+        balancing_mat2 = a.balancing_mat2;
+      }
+    return *this;
+  }
 
   ~GEPBALANCE (void) { }
 
   Matrix balanced_matrix (void) const { return balanced_mat; }
 
   Matrix balanced_matrix2 (void) const { return balanced_mat2; }
 
   Matrix balancing_matrix (void) const { return balancing_mat; }
diff --git a/liboctave/numeric/dbleHESS.h b/liboctave/numeric/dbleHESS.h
--- a/liboctave/numeric/dbleHESS.h
+++ b/liboctave/numeric/dbleHESS.h
@@ -34,32 +34,32 @@ HESS
 public:
 
   HESS (void) : hess_mat (), unitary_hess_mat () { }
 
   HESS (const Matrix& a) : hess_mat (), unitary_hess_mat () { init (a); }
 
   HESS (const Matrix& a, octave_idx_type& info)
     : hess_mat (), unitary_hess_mat ()
-    {
-      info = init (a);
-    }
+  {
+    info = init (a);
+  }
 
   HESS (const HESS& a)
     : hess_mat (a.hess_mat), unitary_hess_mat (a.unitary_hess_mat) { }
 
   HESS& operator = (const HESS& a)
-    {
-      if (this != &a)
-        {
-          hess_mat = a.hess_mat;
-          unitary_hess_mat = a.unitary_hess_mat;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        hess_mat = a.hess_mat;
+        unitary_hess_mat = a.unitary_hess_mat;
+      }
+    return *this;
+  }
 
   ~HESS (void) { }
 
   Matrix hess_matrix (void) const { return hess_mat; }
 
   Matrix unitary_hess_matrix (void) const { return unitary_hess_mat; }
 
   friend std::ostream& operator << (std::ostream& os, const HESS& a);
diff --git a/liboctave/numeric/dbleLU.cc b/liboctave/numeric/dbleLU.cc
--- a/liboctave/numeric/dbleLU.cc
+++ b/liboctave/numeric/dbleLU.cc
@@ -119,17 +119,18 @@ void LU::update (const Matrix& u, const 
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
       for (volatile octave_idx_type i = 0; i < u.cols (); i++)
         {
           ColumnVector utmp = u.column (i), vtmp = v.column (i);
-          F77_XFCN (dlu1up, DLU1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
+          F77_XFCN (dlu1up, DLU1UP, (m, n, l.fortran_vec (),
+                                     m, r.fortran_vec (), k,
                                      utmp.fortran_vec (), vtmp.fortran_vec ()));
         }
     }
   else
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 }
 
 void LU::update_piv (const ColumnVector& u, const ColumnVector& v)
@@ -144,18 +145,20 @@ void LU::update_piv (const ColumnVector&
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
   if (u.length () == m && v.length () == n)
     {
       ColumnVector utmp = u, vtmp = v;
       OCTAVE_LOCAL_BUFFER (double, w, m);
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
-      F77_XFCN (dlup1up, DLUP1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
-                                   ipvt.fortran_vec (), utmp.data (), vtmp.data (), w));
+      F77_XFCN (dlup1up, DLUP1UP, (m, n, l.fortran_vec (),
+                                   m, r.fortran_vec (), k,
+                                   ipvt.fortran_vec (),
+                                   utmp.data (), vtmp.data (), w));
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
   else
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 }
 
 void LU::update_piv (const Matrix& u, const Matrix& v)
 {
@@ -171,40 +174,46 @@ void LU::update_piv (const Matrix& u, co
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
       OCTAVE_LOCAL_BUFFER (double, w, m);
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
       for (volatile octave_idx_type i = 0; i < u.cols (); i++)
         {
           ColumnVector utmp = u.column (i), vtmp = v.column (i);
-          F77_XFCN (dlup1up, DLUP1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
-                                       ipvt.fortran_vec (), utmp.data (), vtmp.data (), w));
+          F77_XFCN (dlup1up, DLUP1UP, (m, n, l.fortran_vec (),
+                                       m, r.fortran_vec (), k,
+                                       ipvt.fortran_vec (),
+                                       utmp.data (), vtmp.data (), w));
         }
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
   else
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 }
 
 #else
 
 void LU::update (const ColumnVector&, const ColumnVector&)
 {
-  (*current_liboctave_error_handler) ("luupdate: not available in this version");
+  (*current_liboctave_error_handler)
+    ("luupdate: not available in this version");
 }
 
 void LU::update (const Matrix&, const Matrix&)
 {
-  (*current_liboctave_error_handler) ("luupdate: not available in this version");
+  (*current_liboctave_error_handler)
+    ("luupdate: not available in this version");
 }
 
 void LU::update_piv (const ColumnVector&, const ColumnVector&)
 {
-  (*current_liboctave_error_handler) ("luupdate: not available in this version");
+  (*current_liboctave_error_handler)
+    ("luupdate: not available in this version");
 }
 
 void LU::update_piv (const Matrix&, const Matrix&)
 {
-  (*current_liboctave_error_handler) ("luupdate: not available in this version");
+  (*current_liboctave_error_handler)
+    ("luupdate: not available in this version");
 }
 
 #endif
diff --git a/liboctave/numeric/dbleLU.h b/liboctave/numeric/dbleLU.h
--- a/liboctave/numeric/dbleLU.h
+++ b/liboctave/numeric/dbleLU.h
@@ -37,22 +37,22 @@ public:
   LU (const Matrix& a);
 
   LU (const LU& a) : base_lu <Matrix> (a) { }
 
   LU (const Matrix& l, const Matrix& u, const PermMatrix& p)
     : base_lu <Matrix> (l, u, p) { }
 
   LU& operator = (const LU& a)
-    {
-      if (this != &a)
-        base_lu <Matrix> :: operator = (a);
+  {
+    if (this != &a)
+      base_lu <Matrix> :: operator = (a);
 
-      return *this;
-    }
+    return *this;
+  }
 
   ~LU (void) { }
 
   void update (const ColumnVector& u, const ColumnVector& v);
 
   void update (const Matrix& u, const Matrix& v);
 
   void update_piv (const ColumnVector& u, const ColumnVector& v);
diff --git a/liboctave/numeric/dbleQR.cc b/liboctave/numeric/dbleQR.cc
--- a/liboctave/numeric/dbleQR.cc
+++ b/liboctave/numeric/dbleQR.cc
@@ -116,23 +116,25 @@ QR::init (const Matrix& a, qr_type_t qr_
   Matrix afact = a;
   if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
   if (m > 0)
     {
       // workspace query.
       double rlwork;
-      F77_XFCN (dgeqrf, DGEQRF, (m, n, afact.fortran_vec (), m, tau, &rlwork, -1, info));
+      F77_XFCN (dgeqrf, DGEQRF, (m, n, afact.fortran_vec (), m, tau,
+                                 &rlwork, -1, info));
 
       // allocate buffer and do the job.
       octave_idx_type lwork = rlwork;
       lwork = std::max (lwork, static_cast<octave_idx_type> (1));
       OCTAVE_LOCAL_BUFFER (double, work, lwork);
-      F77_XFCN (dgeqrf, DGEQRF, (m, n, afact.fortran_vec (), m, tau, work, lwork, info));
+      F77_XFCN (dgeqrf, DGEQRF, (m, n, afact.fortran_vec (), m, tau,
+                                 work, lwork, info));
     }
 
   form (n, afact, tau, qr_type);
 }
 
 void QR::form (octave_idx_type n, Matrix& afact,
                double *tau, qr_type_t qr_type)
 {
@@ -159,17 +161,17 @@ void QR::form (octave_idx_type n, Matrix
           q = afact;
           octave_idx_type k = qr_type == qr_type_economy ? n : m;
           r = Matrix (k, n);
           for (octave_idx_type j = 0; j < n; j++)
             {
               octave_idx_type i = 0;
               for (; i <= j; i++)
                 r.xelem (i, j) = afact.xelem (i, j);
-              for (;i < k; i++)
+              for (; i < k; i++)
                 r.xelem (i, j) = 0;
             }
           afact = Matrix (); // optimize memory
         }
       else
         {
           // afact will become r.
           q = Matrix (m, m);
@@ -209,17 +211,18 @@ QR::update (const ColumnVector& u, const
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   if (u.length () == m && v.length () == n)
     {
       ColumnVector utmp = u, vtmp = v;
       OCTAVE_LOCAL_BUFFER (double, w, 2*k);
-      F77_XFCN (dqr1up, DQR1UP, (m, n, k, q.fortran_vec (), m, r.fortran_vec (), k,
+      F77_XFCN (dqr1up, DQR1UP, (m, n, k, q.fortran_vec (),
+                                 m, r.fortran_vec (), k,
                                  utmp.fortran_vec (), vtmp.fortran_vec (), w));
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
 QR::update (const Matrix& u, const Matrix& v)
@@ -229,18 +232,20 @@ QR::update (const Matrix& u, const Matri
   octave_idx_type k = q.columns ();
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
       OCTAVE_LOCAL_BUFFER (double, w, 2*k);
       for (volatile octave_idx_type i = 0; i < u.cols (); i++)
         {
           ColumnVector utmp = u.column (i), vtmp = v.column (i);
-          F77_XFCN (dqr1up, DQR1UP, (m, n, k, q.fortran_vec (), m, r.fortran_vec (), k,
-                                     utmp.fortran_vec (), vtmp.fortran_vec (), w));
+          F77_XFCN (dqr1up, DQR1UP, (m, n, k, q.fortran_vec (),
+                                     m, r.fortran_vec (), k,
+                                     utmp.fortran_vec (), vtmp.fortran_vec (),
+                                     w));
         }
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
 QR::insert_col (const ColumnVector& u, octave_idx_type j)
@@ -367,17 +372,18 @@ QR::delete_col (const Array<octave_idx_t
   else if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (double, w, k);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
           octave_idx_type ii = i;
           F77_XFCN (dqrdec, DQRDEC, (m, n - ii, k == m ? k : k - ii,
                                      q.fortran_vec (), q.rows (),
-                                     r.fortran_vec (), r.rows (), js(ii) + 1, w));
+                                     r.fortran_vec (), r.rows (),
+                                     js(ii) + 1, w));
         }
       if (k < m)
         {
           q.resize (m, k - nj);
           r.resize (k - nj, n - nj);
         }
       else
         {
@@ -485,30 +491,30 @@ QR::update (const Matrix& u, const Matri
       init (q*r + u * v.transpose (), get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 static
 Matrix insert_col (const Matrix& a, octave_idx_type i,
-                        const ColumnVector& x)
+                   const ColumnVector& x)
 {
   Matrix retval (a.rows (), a.columns () + 1);
   retval.assign (idx_vector::colon, idx_vector (0, i),
                  a.index (idx_vector::colon, idx_vector (0, i)));
   retval.assign (idx_vector::colon, idx_vector (i), x);
   retval.assign (idx_vector::colon, idx_vector (i+1, retval.columns ()),
                  a.index (idx_vector::colon, idx_vector (i, a.columns ())));
   return retval;
 }
 
 static
 Matrix insert_row (const Matrix& a, octave_idx_type i,
-                        const RowVector& x)
+                   const RowVector& x)
 {
   Matrix retval (a.rows () + 1, a.columns ());
   retval.assign (idx_vector (0, i), idx_vector::colon,
                  a.index (idx_vector (0, i), idx_vector::colon));
   retval.assign (idx_vector (i), idx_vector::colon, x);
   retval.assign (idx_vector (i+1, retval.rows ()), idx_vector::colon,
                  a.index (idx_vector (i, a.rows ()), idx_vector::colon));
   return retval;
@@ -527,17 +533,17 @@ Matrix delete_row (const Matrix& a, octa
 {
   Matrix retval = a;
   retval.delete_elements (0, idx_vector (i));
   return retval;
 }
 
 static
 Matrix shift_cols (const Matrix& a,
-                        octave_idx_type i, octave_idx_type j)
+                   octave_idx_type i, octave_idx_type j)
 {
   octave_idx_type n = a.columns ();
   Array<octave_idx_type> p (n);
   for (octave_idx_type k = 0; k < n; k++) p(k) = k;
   if (i < j)
     {
       for (octave_idx_type k = i; k < j; k++) p(k) = k+1;
       p(j) = i;
diff --git a/liboctave/numeric/dbleQRP.cc b/liboctave/numeric/dbleQRP.cc
--- a/liboctave/numeric/dbleQRP.cc
+++ b/liboctave/numeric/dbleQRP.cc
@@ -67,25 +67,27 @@ QRP::init (const Matrix& a, qr_type_t qr
     afact.resize (m, m);
 
   MArray<octave_idx_type> jpvt (dim_vector (n, 1), 0);
 
   if (m > 0)
     {
       // workspace query.
       double rlwork;
-      F77_XFCN (dgeqp3, DGEQP3, (m, n, afact.fortran_vec (), m, jpvt.fortran_vec (),
-                                 tau, &rlwork, -1, info));
+      F77_XFCN (dgeqp3, DGEQP3, (m, n, afact.fortran_vec (),
+                                 m, jpvt.fortran_vec (), tau,
+                                 &rlwork, -1, info));
 
       // allocate buffer and do the job.
       octave_idx_type lwork = rlwork;
       lwork = std::max (lwork, static_cast<octave_idx_type> (1));
       OCTAVE_LOCAL_BUFFER (double, work, lwork);
-      F77_XFCN (dgeqp3, DGEQP3, (m, n, afact.fortran_vec (), m, jpvt.fortran_vec (),
-                                 tau, work, lwork, info));
+      F77_XFCN (dgeqp3, DGEQP3, (m, n, afact.fortran_vec (),
+                                 m, jpvt.fortran_vec (), tau,
+                                 work, lwork, info));
     }
   else
     for (octave_idx_type i = 0; i < n; i++) jpvt(i) = i+1;
 
   // Form Permutation matrix (if economy is requested, return the
   // indices only!)
 
   jpvt -= static_cast<octave_idx_type> (1);
diff --git a/liboctave/numeric/dbleQRP.h b/liboctave/numeric/dbleQRP.h
--- a/liboctave/numeric/dbleQRP.h
+++ b/liboctave/numeric/dbleQRP.h
@@ -37,25 +37,25 @@ public:
 
   QRP (void) : QR (), p () { }
 
   QRP (const Matrix&, qr_type_t = qr_type_std);
 
   QRP (const QRP& a) : QR (a), p (a.p) { }
 
   QRP& operator = (const QRP& a)
-    {
-      if (this != &a)
-        {
-          QR::operator = (a);
-          p = a.p;
-        }
+  {
+    if (this != &a)
+      {
+        QR::operator = (a);
+        p = a.p;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   ~QRP (void) { }
 
   void init (const Matrix&, qr_type_t = qr_type_std);
 
   PermMatrix P (void) const { return p; }
 
   RowVector Pvec (void) const;
diff --git a/liboctave/numeric/dbleSCHUR.cc b/liboctave/numeric/dbleSCHUR.cc
--- a/liboctave/numeric/dbleSCHUR.cc
+++ b/liboctave/numeric/dbleSCHUR.cc
@@ -46,17 +46,17 @@ extern "C"
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 }
 
 static octave_idx_type
 select_ana (const double& a, const double&)
 {
-   return (a < 0.0);
+  return (a < 0.0);
 }
 
 static octave_idx_type
 select_dig (const double& a, const double& b)
 {
   return (hypot (a, b) < 1.0);
 }
 
diff --git a/liboctave/numeric/dbleSCHUR.h b/liboctave/numeric/dbleSCHUR.h
--- a/liboctave/numeric/dbleSCHUR.h
+++ b/liboctave/numeric/dbleSCHUR.h
@@ -33,42 +33,42 @@ OCTAVE_API
 SCHUR
 {
 public:
 
   SCHUR (void) : schur_mat (), unitary_mat (), selector (0) { }
 
   SCHUR (const Matrix& a, const std::string& ord, bool calc_unitary = true)
     : schur_mat (), unitary_mat (), selector (0)
-    {
-      init (a, ord, calc_unitary);
-    }
+  {
+    init (a, ord, calc_unitary);
+  }
 
   SCHUR (const Matrix& a, const std::string& ord, int& info,
          bool calc_unitary = true)
     : schur_mat (), unitary_mat (), selector (0)
-    {
-      info = init (a, ord, calc_unitary);
-    }
+  {
+    info = init (a, ord, calc_unitary);
+  }
 
   SCHUR (const SCHUR& a)
     : schur_mat (a.schur_mat), unitary_mat (a.unitary_mat), selector (0)
-    { }
+  { }
 
   SCHUR (const Matrix& s, const Matrix& u);
 
   SCHUR& operator = (const SCHUR& a)
-    {
-      if (this != &a)
-        {
-          schur_mat = a.schur_mat;
-          unitary_mat = a.unitary_mat;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        schur_mat = a.schur_mat;
+        unitary_mat = a.unitary_mat;
+      }
+    return *this;
+  }
 
   ~SCHUR (void) { }
 
   Matrix schur_matrix (void) const { return schur_mat; }
 
   Matrix unitary_matrix (void) const { return unitary_mat; }
 
   friend std::ostream& operator << (std::ostream& os, const SCHUR& a);
@@ -77,12 +77,13 @@ public:
 
 private:
 
   Matrix schur_mat;
   Matrix unitary_mat;
 
   select_function selector;
 
-  octave_idx_type init (const Matrix& a, const std::string& ord, bool calc_unitary);
+  octave_idx_type init (const Matrix& a, const std::string& ord,
+                        bool calc_unitary);
 };
 
 #endif
diff --git a/liboctave/numeric/dbleSVD.cc b/liboctave/numeric/dbleSVD.cc
--- a/liboctave/numeric/dbleSVD.cc
+++ b/liboctave/numeric/dbleSVD.cc
@@ -173,26 +173,26 @@ SVD::init (const Matrix& a, SVD::type sv
     }
   else if (svd_driver == SVD::GESDD)
     {
       assert (jobu == jobv);
       char jobz = jobu;
       OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, 8*min_mn);
 
       F77_XFCN (dgesdd, DGESDD, (F77_CONST_CHAR_ARG2 (&jobz, 1),
-                                 m, n, tmp_data, m1, s_vec, u, m1, vt,
-                                 nrow_vt1, work.fortran_vec (), lwork, iwork, info
+                                 m, n, tmp_data, m1, s_vec, u, m1, vt, nrow_vt1,
+                                 work.fortran_vec (), lwork, iwork, info
                                  F77_CHAR_ARG_LEN (1)));
 
       lwork = static_cast<octave_idx_type> (work(0));
       work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (dgesdd, DGESDD, (F77_CONST_CHAR_ARG2 (&jobz, 1),
-                                 m, n, tmp_data, m1, s_vec, u, m1, vt,
-                                 nrow_vt1, work.fortran_vec (), lwork, iwork, info
+                                 m, n, tmp_data, m1, s_vec, u, m1, vt, nrow_vt1,
+                                 work.fortran_vec (), lwork, iwork, info
                                  F77_CHAR_ARG_LEN (1)));
 
     }
   else
     assert (0); // impossible
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm = right_sm.transpose ();
diff --git a/liboctave/numeric/dbleSVD.h b/liboctave/numeric/dbleSVD.h
--- a/liboctave/numeric/dbleSVD.h
+++ b/liboctave/numeric/dbleSVD.h
@@ -30,61 +30,61 @@ along with Octave; see the file COPYING.
 
 class
 OCTAVE_API
 SVD
 {
 public:
 
   enum type
-    {
-      std,
-      economy,
-      sigma_only
-    };
+  {
+    std,
+    economy,
+    sigma_only
+  };
 
   enum driver
-    {
-      GESVD,
-      GESDD
-    };
+  {
+    GESVD,
+    GESDD
+  };
 
   SVD (void) : type_computed (), sigma (), left_sm (), right_sm () { }
 
   SVD (const Matrix& a,
        type svd_type = SVD::std, driver svd_driver = SVD::GESVD)
     : type_computed (), sigma (), left_sm (), right_sm ()
-    {
-      init (a, svd_type, svd_driver);
-    }
+  {
+    init (a, svd_type, svd_driver);
+  }
 
   SVD (const Matrix& a, octave_idx_type& info,
        type svd_type = SVD::std, driver svd_driver = SVD::GESVD)
     : type_computed (), sigma (), left_sm (), right_sm ()
-    {
-      info = init (a, svd_type, svd_driver);
-    }
+  {
+    info = init (a, svd_type, svd_driver);
+  }
 
   SVD (const SVD& a)
     : type_computed (a.type_computed), sigma (a.sigma),
       left_sm (a.left_sm), right_sm (a.right_sm)
-    { }
+  { }
 
   SVD& operator = (const SVD& a)
-    {
-      if (this != &a)
-        {
-          type_computed = a.type_computed;
-          sigma = a.sigma;
-          left_sm = a.left_sm;
-          right_sm = a.right_sm;
-        }
+  {
+    if (this != &a)
+      {
+        type_computed = a.type_computed;
+        sigma = a.sigma;
+        left_sm = a.left_sm;
+        right_sm = a.right_sm;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   ~SVD (void) { }
 
   DiagMatrix singular_values (void) const { return sigma; }
 
   Matrix left_singular_matrix (void) const;
 
   Matrix right_singular_matrix (void) const;
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -150,19 +150,21 @@ extern "C"
                            const octave_idx_type&, const double*,
                            const octave_idx_type&, const double&, double*,
                            const octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL);
 
 
   F77_RET_T
   F77_FUNC (zgemv, ZGEMV) (F77_CONST_CHAR_ARG_DECL,
-                           const octave_idx_type&, const octave_idx_type&, const Complex&,
-                           const Complex*, const octave_idx_type&, const Complex*,
-                           const octave_idx_type&, const Complex&, Complex*, const octave_idx_type&
+                           const octave_idx_type&, const octave_idx_type&,
+                           const Complex&, const Complex*,
+                           const octave_idx_type&, const Complex*,
+                           const octave_idx_type&, const Complex&, Complex*,
+                           const octave_idx_type&
                            F77_CHAR_ARG_LEN_DECL);
 
 }
 
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static octave_idx_type
 lusolve (const SparseMatrix&, const SparseMatrix&, Matrix&);
@@ -174,17 +176,17 @@ lusolve (const SparseComplexMatrix&, con
 static octave_idx_type
 lusolve (const Matrix&, const Matrix&, Matrix&);
 
 static octave_idx_type
 lusolve (const ComplexMatrix&, const ComplexMatrix&, ComplexMatrix&);
 
 static ComplexMatrix
 ltsolve (const SparseComplexMatrix&, const ColumnVector&,
-                const ComplexMatrix&);
+         const ComplexMatrix&);
 
 static Matrix
 ltsolve (const SparseMatrix&, const ColumnVector&, const Matrix&,);
 
 static ComplexMatrix
 ltsolve (const ComplexMatrix&, const ColumnVector&, const ComplexMatrix&);
 
 static Matrix
@@ -302,17 +304,17 @@ vector_product (const Matrix& m, const d
       return false;
     }
   else
     return true;
 }
 
 static bool
 vector_product (const SparseComplexMatrix& m, const Complex* x,
-                        Complex* y)
+                Complex* y)
 {
   octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     y[j] = 0.;
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
@@ -441,41 +443,41 @@ LuAminusSigmaB (const SparseMatrix &m, c
                   tmp.xcidx (i) = i;
                   tmp.xridx (i) =
                     static_cast<octave_idx_type>(permB(i));
                   tmp.xdata (i) = 1;
                 }
               tmp.xcidx (n) = n;
 
               AminusSigmaB = AminusSigmaB - sigma * tmp *
-                b.transpose () * b * tmp.transpose ();
+                             b.transpose () * b * tmp.transpose ();
             }
           else
             AminusSigmaB = AminusSigmaB - sigma *
-              b.transpose () * b;
+                           b.transpose () * b;
         }
       else
         AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
     {
       SparseMatrix sigmat (n, n, n);
 
-          // Create sigma * speye (n,n)
-          sigmat.xcidx (0) = 0;
-          for (octave_idx_type i = 0; i < n; i++)
-            {
-              sigmat.xdata (i) = sigma;
-              sigmat.xridx (i) = i;
-              sigmat.xcidx (i+1) = i + 1;
-            }
-
-          AminusSigmaB = AminusSigmaB - sigmat;
+      // Create sigma * speye (n,n)
+      sigmat.xcidx (0) = 0;
+      for (octave_idx_type i = 0; i < n; i++)
+        {
+          sigmat.xdata (i) = sigma;
+          sigmat.xridx (i) = i;
+          sigmat.xcidx (i+1) = i + 1;
         }
 
+      AminusSigmaB = AminusSigmaB - sigmat;
+    }
+
   SparseLU fact (AminusSigmaB);
 
   L = fact.L ();
   U = fact.U ();
   const octave_idx_type *P2 = fact.row_perm ();
   const octave_idx_type *Q2 = fact.col_perm ();
 
   for (octave_idx_type j = 0; j < n; j++)
@@ -616,17 +618,17 @@ LuAminusSigmaB (const SparseComplexMatri
                   tmp.xcidx (i) = i;
                   tmp.xridx (i) =
                     static_cast<octave_idx_type>(permB(i));
                   tmp.xdata (i) = 1;
                 }
               tmp.xcidx (n) = n;
 
               AminusSigmaB = AminusSigmaB - tmp * b.hermitian () * b *
-                tmp.transpose () * sigma;
+                             tmp.transpose () * sigma;
             }
           else
             AminusSigmaB = AminusSigmaB - sigma * b.hermitian () * b;
         }
       else
         AminusSigmaB = AminusSigmaB - sigma * b;
     }
   else
@@ -951,18 +953,18 @@ EigsRealSymmetricMatrix (const M& m, con
           return -1;
         }
 
       if (disp > 0 && !xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
-                ": a few Ritz values of the " << p << "-by-" <<
-                p << " matrix\n";
+                 ": a few Ritz values of the " << p << "-by-" <<
+                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
@@ -1135,17 +1137,17 @@ EigsRealSymmetricMatrixShift (const M& m
         ("eigs: n must be at least 3");
       return -1;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1-1).\n"
-             "      Use 'eig (full (A))' instead");
+         "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p < 0)
     {
       p = k * 2;
 
       if (p < 20)
@@ -1244,18 +1246,18 @@ EigsRealSymmetricMatrixShift (const M& m
           return -1;
         }
 
       if (disp > 0 && !xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
-                ": a few Ritz values of the " << p << "-by-" <<
-                p << " matrix\n";
+                 ": a few Ritz values of the " << p << "-by-" <<
+                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
@@ -1455,17 +1457,17 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-             "      Use 'eig (full (A))' instead");
+         "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -1545,18 +1547,18 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
           return -1;
         }
 
       if (disp > 0 && !xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
-                ": a few Ritz values of the " << p << "-by-" <<
-                p << " matrix\n";
+                 ": a few Ritz values of the " << p << "-by-" <<
+                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
@@ -1865,18 +1867,18 @@ EigsRealNonSymmetricMatrix (const M& m, 
           return -1;
         }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
-                ": a few Ritz values of the " << p << "-by-" <<
-                p << " matrix\n";
+                 ": a few Ritz values of the " << p << "-by-" <<
+                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
@@ -1922,17 +1924,17 @@ EigsRealNonSymmetricMatrix (const M& m, 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
   // per bool, though this might be system dependent. As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
-  // FIXME -- initialize eig_vec2 to zero; apparently dneupd can skip
+  // FIXME: initialize eig_vec2 to zero; apparently dneupd can skip
   // the assignment to elements of Z that represent imaginary parts.
   // Found with valgrind and
   //
   //   A = [1,0,0,-1;0,1,0,0;0,0,1,0;0,0,2,1];
   //   [vecs, vals, f] = eigs (A, 1)
 
   Matrix eig_vec2 (n, k + 1, 0.0);
   double *z = eig_vec2.fortran_vec ();
@@ -2109,17 +2111,17 @@ EigsRealNonSymmetricMatrixShift (const M
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-             "      Use 'eig (full (A))' instead");
+         "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -2207,18 +2209,18 @@ EigsRealNonSymmetricMatrixShift (const M
           return -1;
         }
 
       if (disp > 0 && !xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
-                ": a few Ritz values of the " << p << "-by-" <<
-                p << " matrix\n";
+                 ": a few Ritz values of the " << p << "-by-" <<
+                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
@@ -2308,17 +2310,17 @@ EigsRealNonSymmetricMatrixShift (const M
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
   // per bool, though this might be system dependent. As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
-  // FIXME -- initialize eig_vec2 to zero; apparently dneupd can skip
+  // FIXME: initialize eig_vec2 to zero; apparently dneupd can skip
   // the assignment to elements of Z that represent imaginary parts.
   // Found with valgrind and
   //
   //   A = [1,0,0,-1;0,1,0,0;0,0,1,0;0,0,2,1];
   //   [vecs, vals, f] = eigs (A, 1)
 
   Matrix eig_vec2 (n, k + 1, 0.0);
   double *z = eig_vec2.fortran_vec ();
@@ -2472,17 +2474,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-             "      Use 'eig (full (A))' instead");
+         "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -2563,18 +2565,18 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
           return -1;
         }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
-                ": a few Ritz values of the " << p << "-by-" <<
-                p << " matrix\n";
+                 ": a few Ritz values of the " << p << "-by-" <<
+                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
@@ -2620,17 +2622,17 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
   // that fortran uses 4- or 8-bytes per logical and C++ 1-byte
   // per bool, though this might be system dependent. As
   // long as the HOWMNY arg is not "S", the logical array
   // is just workspace for ARPACK, so use int type to
   // avoid problems.
   Array<octave_idx_type> s (dim_vector (p, 1));
   octave_idx_type *sel = s.fortran_vec ();
 
-  // FIXME -- initialize eig_vec2 to zero; apparently dneupd can skip
+  // FIXME: initialize eig_vec2 to zero; apparently dneupd can skip
   // the assignment to elements of Z that represent imaginary parts.
   // Found with valgrind and
   //
   //   A = [1,0,0,-1;0,1,0,0;0,0,1,0;0,0,2,1];
   //   [vecs, vals, f] = eigs (A, 1)
 
   Matrix eig_vec2 (n, k + 1, 0.0);
   double *z = eig_vec2.fortran_vec ();
@@ -2934,18 +2936,18 @@ EigsComplexNonSymmetricMatrix (const M& 
           return -1;
         }
 
       if (disp > 0 && !xisnan (workl[iptr (5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
-                ": a few Ritz values of the " << p << "-by-" <<
-                p << " matrix\n";
+                 ": a few Ritz values of the " << p << "-by-" <<
+                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
@@ -3129,17 +3131,17 @@ EigsComplexNonSymmetricMatrixShift (cons
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-             "      Use 'eig (full (A))' instead");
+         "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -3228,18 +3230,18 @@ EigsComplexNonSymmetricMatrixShift (cons
           return -1;
         }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
-                ": a few Ritz values of the " << p << "-by-" <<
-                p << " matrix\n";
+                 ": a few Ritz values of the " << p << "-by-" <<
+                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
@@ -3446,17 +3448,17 @@ EigsComplexNonSymmetricFunc (EigsComplex
       if (p > n - 1)
         p = n - 1 ;
     }
 
   if (k <= 0 || k >= n - 1)
     {
       (*current_liboctave_error_handler)
         ("eigs: Invalid number of eigenvalues to extract (must be 0 < k < n-1).\n"
-             "      Use 'eig (full (A))' instead");
+         "      Use 'eig (full (A))' instead");
       return -1;
     }
 
   if (p <= k || p >= n)
     {
       (*current_liboctave_error_handler)
         ("eigs: opts.p must be greater than k and less than n");
       return -1;
@@ -3537,18 +3539,18 @@ EigsComplexNonSymmetricFunc (EigsComplex
           return -1;
         }
 
       if (disp > 0 && !xisnan(workl[iptr(5)-1]))
         {
           if (iter++)
             {
               os << "Iteration " << iter - 1 <<
-                ": a few Ritz values of the " << p << "-by-" <<
-                p << " matrix\n";
+                 ": a few Ritz values of the " << p << "-by-" <<
+                 p << " matrix\n";
               for (int i = 0 ; i < k; i++)
                 os << "    " << workl[iptr(5)+i-1] << "\n";
             }
 
           // This is a kludge, as ARPACK doesn't give its
           // iteration pointer. But as workl[iptr(5)-1] is
           // an output value updated at each iteration, setting
           // a value in this array to NaN and testing for it
diff --git a/liboctave/numeric/fCmplxAEPBAL.cc b/liboctave/numeric/fCmplxAEPBAL.cc
--- a/liboctave/numeric/fCmplxAEPBAL.cc
+++ b/liboctave/numeric/fCmplxAEPBAL.cc
@@ -48,17 +48,17 @@ extern "C"
                              const octave_idx_type&, FloatComplex*,
                              const octave_idx_type&, octave_idx_type&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 }
 
 FloatComplexAEPBALANCE::FloatComplexAEPBALANCE (const FloatComplexMatrix& a,
                                                 bool noperm, bool noscal)
- : base_aepbal<FloatComplexMatrix, FloatColumnVector> ()
+  : base_aepbal<FloatComplexMatrix, FloatColumnVector> ()
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
       (*current_liboctave_error_handler) ("AEPBALANCE requires square matrix");
       return;
     }
diff --git a/liboctave/numeric/fCmplxAEPBAL.h b/liboctave/numeric/fCmplxAEPBAL.h
--- a/liboctave/numeric/fCmplxAEPBAL.h
+++ b/liboctave/numeric/fCmplxAEPBAL.h
@@ -28,21 +28,23 @@ along with Octave; see the file COPYING.
 #include <string>
 
 #include "base-aepbal.h"
 #include "fCMatrix.h"
 #include "fColVector.h"
 
 class
 OCTAVE_API
-FloatComplexAEPBALANCE : public base_aepbal<FloatComplexMatrix, FloatColumnVector>
+FloatComplexAEPBALANCE
+  : public base_aepbal<FloatComplexMatrix, FloatColumnVector>
 {
 public:
 
-  FloatComplexAEPBALANCE (void) : base_aepbal<FloatComplexMatrix, FloatColumnVector> () { }
+  FloatComplexAEPBALANCE (void)
+    : base_aepbal<FloatComplexMatrix, FloatColumnVector> () { }
 
   FloatComplexAEPBALANCE (const FloatComplexMatrix& a, bool noperm = false,
                           bool noscal = false);
 
   FloatComplexAEPBALANCE (const FloatComplexAEPBALANCE& a)
     : base_aepbal<FloatComplexMatrix, FloatColumnVector> (a) { }
 
   FloatComplexMatrix balancing_matrix (void) const;
diff --git a/liboctave/numeric/fCmplxCHOL.cc b/liboctave/numeric/fCmplxCHOL.cc
--- a/liboctave/numeric/fCmplxCHOL.cc
+++ b/liboctave/numeric/fCmplxCHOL.cc
@@ -231,17 +231,18 @@ FloatComplexCHOL::downdate (const FloatC
     }
   else
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
   return info;
 }
 
 octave_idx_type
-FloatComplexCHOL::insert_sym (const FloatComplexColumnVector& u, octave_idx_type j)
+FloatComplexCHOL::insert_sym (const FloatComplexColumnVector& u,
+                              octave_idx_type j)
 {
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
   if (u.length () != n + 1)
     (*current_liboctave_error_handler) ("cholinsert: dimension mismatch");
   else if (j < 0 || j > n)
@@ -303,17 +304,18 @@ FloatComplexCHOL::update (const FloatCom
 {
   warn_qrupdate_once ();
 
   octave_idx_type n = chol_mat.rows ();
 
   if (u.length () == n)
     {
       init (chol_mat.hermitian () * chol_mat
-            + FloatComplexMatrix (u) * FloatComplexMatrix (u).hermitian (), false);
+            + FloatComplexMatrix (u) * FloatComplexMatrix (u).hermitian (),
+            false);
     }
   else
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 }
 
 static bool
 singular (const FloatComplexMatrix& a)
 {
@@ -333,28 +335,31 @@ FloatComplexCHOL::downdate (const FloatC
 
   if (u.length () == n)
     {
       if (singular (chol_mat))
         info = 2;
       else
         {
           info = init (chol_mat.hermitian () * chol_mat
-                       - FloatComplexMatrix (u) * FloatComplexMatrix (u).hermitian (), false);
+                       - FloatComplexMatrix (u)
+                       * FloatComplexMatrix (u).hermitian (),
+                       false);
           if (info) info = 1;
         }
     }
   else
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
   return info;
 }
 
 octave_idx_type
-FloatComplexCHOL::insert_sym (const FloatComplexColumnVector& u, octave_idx_type j)
+FloatComplexCHOL::insert_sym (const FloatComplexColumnVector& u,
+                              octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type info = -1;
 
   octave_idx_type n = chol_mat.rows ();
 
   if (u.length () != n + 1)
diff --git a/liboctave/numeric/fCmplxCHOL.h b/liboctave/numeric/fCmplxCHOL.h
--- a/liboctave/numeric/fCmplxCHOL.h
+++ b/liboctave/numeric/fCmplxCHOL.h
@@ -34,40 +34,40 @@ OCTAVE_API
 FloatComplexCHOL
 {
 public:
 
   FloatComplexCHOL (void) : chol_mat (), xrcond (0) { }
 
   FloatComplexCHOL (const FloatComplexMatrix& a, bool calc_cond = false)
     : chol_mat (), xrcond (0)
-    {
-      init (a, calc_cond);
-    }
+  {
+    init (a, calc_cond);
+  }
 
   FloatComplexCHOL (const FloatComplexMatrix& a, octave_idx_type& info,
                     bool calc_cond = false)
     : chol_mat (), xrcond (0)
-    {
-      info = init (a, calc_cond);
-    }
+  {
+    info = init (a, calc_cond);
+  }
 
   FloatComplexCHOL (const FloatComplexCHOL& a)
     : chol_mat (a.chol_mat), xrcond (a.xrcond) { }
 
   FloatComplexCHOL& operator = (const FloatComplexCHOL& a)
-    {
-      if (this != &a)
-        {
-          chol_mat = a.chol_mat;
-          xrcond = a.xrcond;
-        }
+  {
+    if (this != &a)
+      {
+        chol_mat = a.chol_mat;
+        xrcond = a.xrcond;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   FloatComplexMatrix chol_matrix (void) const { return chol_mat; }
 
   float rcond (void) const { return xrcond; }
 
   FloatComplexMatrix inverse (void) const;
 
   void set (const FloatComplexMatrix& R);
diff --git a/liboctave/numeric/fCmplxGEPBAL.cc b/liboctave/numeric/fCmplxGEPBAL.cc
--- a/liboctave/numeric/fCmplxGEPBAL.cc
+++ b/liboctave/numeric/fCmplxGEPBAL.cc
@@ -53,24 +53,26 @@ extern "C"
                              const float* RSCALE, octave_idx_type& M, float* V,
                              const octave_idx_type& LDV, octave_idx_type& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
 }
 
 octave_idx_type
-FloatComplexGEPBALANCE::init (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
-                  const std::string& balance_job)
+FloatComplexGEPBALANCE::init (const FloatComplexMatrix& a,
+                              const FloatComplexMatrix& b,
+                              const std::string& balance_job)
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
-      (*current_liboctave_error_handler) ("FloatComplexGEPBALANCE requires square matrix");
+      (*current_liboctave_error_handler)
+        ("FloatComplexGEPBALANCE requires square matrix");
       return -1;
     }
 
   if (a.dims () != b.dims ())
     {
       gripe_nonconformant ("FloatComplexGEPBALANCE", n, n, b.rows(), b.cols());
       return -1;
     }
diff --git a/liboctave/numeric/fCmplxGEPBAL.h b/liboctave/numeric/fCmplxGEPBAL.h
--- a/liboctave/numeric/fCmplxGEPBAL.h
+++ b/liboctave/numeric/fCmplxGEPBAL.h
@@ -32,59 +32,61 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 FloatComplexGEPBALANCE
 {
 public:
 
   FloatComplexGEPBALANCE (void)
     : balanced_mat (), balanced_mat2 (), balancing_mat (), balancing_mat2 ()
-    { }
+  { }
 
   FloatComplexGEPBALANCE (const FloatComplexMatrix& a,
                           const FloatComplexMatrix& b,
                           const std::string& balance_job)
     : balanced_mat (), balanced_mat2 (), balancing_mat (), balancing_mat2 ()
-    {
-      init (a, b, balance_job);
-    }
+  {
+    init (a, b, balance_job);
+  }
 
   FloatComplexGEPBALANCE (const FloatComplexGEPBALANCE& a)
     : balanced_mat (a.balanced_mat), balanced_mat2 (a.balanced_mat2),
       balancing_mat (a.balancing_mat), balancing_mat2 (a.balancing_mat2)
-    { }
+  { }
 
   FloatComplexGEPBALANCE& operator = (const FloatComplexGEPBALANCE& a)
-    {
-      if (this != &a)
-        {
-          balanced_mat = a.balanced_mat;
-          balanced_mat2 = a.balanced_mat2;
-          balancing_mat = a.balancing_mat;
-          balancing_mat2 = a.balancing_mat2;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        balanced_mat = a.balanced_mat;
+        balanced_mat2 = a.balanced_mat2;
+        balancing_mat = a.balancing_mat;
+        balancing_mat2 = a.balancing_mat2;
+      }
+    return *this;
+  }
 
   ~FloatComplexGEPBALANCE (void) { }
 
   FloatComplexMatrix balanced_matrix (void) const { return balanced_mat; }
 
   FloatComplexMatrix balanced_matrix2 (void) const { return balanced_mat2; }
 
   FloatMatrix balancing_matrix (void) const { return balancing_mat; }
 
   FloatMatrix balancing_matrix2 (void) const { return balancing_mat2; }
 
-  friend std::ostream& operator << (std::ostream& os, const FloatComplexGEPBALANCE& a);
+  friend std::ostream& operator << (std::ostream& os,
+                                    const FloatComplexGEPBALANCE& a);
 
 private:
 
   FloatComplexMatrix balanced_mat;
   FloatComplexMatrix balanced_mat2;
   FloatMatrix balancing_mat;
   FloatMatrix balancing_mat2;
 
-  octave_idx_type init (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
+  octave_idx_type init (const FloatComplexMatrix& a,
+                        const FloatComplexMatrix& b,
                         const std::string& balance_job);
 };
 
 #endif
diff --git a/liboctave/numeric/fCmplxHESS.h b/liboctave/numeric/fCmplxHESS.h
--- a/liboctave/numeric/fCmplxHESS.h
+++ b/liboctave/numeric/fCmplxHESS.h
@@ -32,49 +32,50 @@ OCTAVE_API
 FloatComplexHESS
 {
 public:
 
   FloatComplexHESS (void) : hess_mat (), unitary_hess_mat () { }
 
   FloatComplexHESS (const FloatComplexMatrix& a)
     : hess_mat (), unitary_hess_mat ()
-    {
-      init (a);
-    }
+  {
+    init (a);
+  }
 
   FloatComplexHESS (const FloatComplexMatrix& a, octave_idx_type& info)
     : hess_mat (), unitary_hess_mat ()
-    {
-      info = init (a);
-    }
+  {
+    info = init (a);
+  }
 
   FloatComplexHESS (const FloatComplexHESS& a)
     : hess_mat (a.hess_mat), unitary_hess_mat (a.unitary_hess_mat) { }
 
   FloatComplexHESS& operator = (const FloatComplexHESS& a)
-    {
-      if (this != &a)
-        {
-          hess_mat = a.hess_mat;
-          unitary_hess_mat = a.unitary_hess_mat;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        hess_mat = a.hess_mat;
+        unitary_hess_mat = a.unitary_hess_mat;
+      }
+    return *this;
+  }
 
   ~FloatComplexHESS (void) { }
 
   FloatComplexMatrix hess_matrix (void) const { return hess_mat; }
 
   FloatComplexMatrix unitary_hess_matrix (void) const
-    {
-      return unitary_hess_mat;
-    }
+  {
+    return unitary_hess_mat;
+  }
 
-  friend std::ostream& operator << (std::ostream& os, const FloatComplexHESS& a);
+  friend std::ostream& operator << (std::ostream& os,
+                                    const FloatComplexHESS& a);
 
 private:
 
   FloatComplexMatrix hess_mat;
   FloatComplexMatrix unitary_hess_mat;
 
   octave_idx_type init (const FloatComplexMatrix& a);
 };
diff --git a/liboctave/numeric/fCmplxLU.cc b/liboctave/numeric/fCmplxLU.cc
--- a/liboctave/numeric/fCmplxLU.cc
+++ b/liboctave/numeric/fCmplxLU.cc
@@ -80,17 +80,18 @@ FloatComplexLU::FloatComplexLU (const Fl
   F77_XFCN (cgetrf, CGETRF, (a_nr, a_nc, tmp_data, a_nr, pipvt, info));
 
   for (octave_idx_type i = 0; i < mn; i++)
     pipvt[i] -= 1;
 }
 
 #ifdef HAVE_QRUPDATE_LUU
 
-void FloatComplexLU::update (const FloatComplexColumnVector& u, const FloatComplexColumnVector& v)
+void FloatComplexLU::update (const FloatComplexColumnVector& u,
+                             const FloatComplexColumnVector& v)
 {
   if (packed ())
     unpack ();
 
   FloatComplexMatrix& l = l_fact;
   FloatComplexMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
@@ -102,67 +103,73 @@ void FloatComplexLU::update (const Float
       FloatComplexColumnVector utmp = u, vtmp = v;
       F77_XFCN (clu1up, CLU1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
                                  utmp.fortran_vec (), vtmp.fortran_vec ()));
     }
   else
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 }
 
-void FloatComplexLU::update (const FloatComplexMatrix& u, const FloatComplexMatrix& v)
+void FloatComplexLU::update (const FloatComplexMatrix& u,
+                             const FloatComplexMatrix& v)
 {
   if (packed ())
     unpack ();
 
   FloatComplexMatrix& l = l_fact;
   FloatComplexMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
       for (volatile octave_idx_type i = 0; i < u.cols (); i++)
         {
           FloatComplexColumnVector utmp = u.column (i), vtmp = v.column (i);
-          F77_XFCN (clu1up, CLU1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
+          F77_XFCN (clu1up, CLU1UP, (m, n, l.fortran_vec (),
+                                     m, r.fortran_vec (), k,
                                      utmp.fortran_vec (), vtmp.fortran_vec ()));
         }
     }
   else
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 }
 
-void FloatComplexLU::update_piv (const FloatComplexColumnVector& u, const FloatComplexColumnVector& v)
+void FloatComplexLU::update_piv (const FloatComplexColumnVector& u,
+                                 const FloatComplexColumnVector& v)
 {
   if (packed ())
     unpack ();
 
   FloatComplexMatrix& l = l_fact;
   FloatComplexMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
   if (u.length () == m && v.length () == n)
     {
       FloatComplexColumnVector utmp = u, vtmp = v;
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
-      F77_XFCN (clup1up, CLUP1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
-                                   ipvt.fortran_vec (), utmp.data (), vtmp.data (), w));
+      F77_XFCN (clup1up, CLUP1UP, (m, n, l.fortran_vec (),
+                                   m, r.fortran_vec (), k,
+                                   ipvt.fortran_vec (),
+                                   utmp.data (), vtmp.data (), w));
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
   else
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 }
 
-void FloatComplexLU::update_piv (const FloatComplexMatrix& u, const FloatComplexMatrix& v)
+void FloatComplexLU::update_piv (const FloatComplexMatrix& u,
+                                 const FloatComplexMatrix& v)
 {
   if (packed ())
     unpack ();
 
   FloatComplexMatrix& l = l_fact;
   FloatComplexMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
@@ -171,40 +178,50 @@ void FloatComplexLU::update_piv (const F
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
       for (volatile octave_idx_type i = 0; i < u.cols (); i++)
         {
           FloatComplexColumnVector utmp = u.column (i), vtmp = v.column (i);
-          F77_XFCN (clup1up, CLUP1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
-                                       ipvt.fortran_vec (), utmp.data (), vtmp.data (), w));
+          F77_XFCN (clup1up, CLUP1UP, (m, n, l.fortran_vec (),
+                                       m, r.fortran_vec (), k,
+                                       ipvt.fortran_vec (),
+                                       utmp.data (), vtmp.data (), w));
         }
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
   else
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 }
 
 #else
 
-void FloatComplexLU::update (const FloatComplexColumnVector&, const FloatComplexColumnVector&)
+void FloatComplexLU::update (const FloatComplexColumnVector&,
+                             const FloatComplexColumnVector&)
 {
-  (*current_liboctave_error_handler) ("luupdate: not available in this version");
+  (*current_liboctave_error_handler)
+    ("luupdate: not available in this version");
 }
 
-void FloatComplexLU::update (const FloatComplexMatrix&, const FloatComplexMatrix&)
+void FloatComplexLU::update (const FloatComplexMatrix&,
+                             const FloatComplexMatrix&)
 {
-  (*current_liboctave_error_handler) ("luupdate: not available in this version");
+  (*current_liboctave_error_handler)
+    ("luupdate: not available in this version");
 }
 
-void FloatComplexLU::update_piv (const FloatComplexColumnVector&, const FloatComplexColumnVector&)
+void FloatComplexLU::update_piv (const FloatComplexColumnVector&,
+                                 const FloatComplexColumnVector&)
 {
-  (*current_liboctave_error_handler) ("luupdate: not available in this version");
+  (*current_liboctave_error_handler)
+    ("luupdate: not available in this version");
 }
 
-void FloatComplexLU::update_piv (const FloatComplexMatrix&, const FloatComplexMatrix&)
+void FloatComplexLU::update_piv (const FloatComplexMatrix&,
+                                 const FloatComplexMatrix&)
 {
-  (*current_liboctave_error_handler) ("luupdate: not available in this version");
+  (*current_liboctave_error_handler)
+    ("luupdate: not available in this version");
 }
 
 #endif
diff --git a/liboctave/numeric/fCmplxLU.h b/liboctave/numeric/fCmplxLU.h
--- a/liboctave/numeric/fCmplxLU.h
+++ b/liboctave/numeric/fCmplxLU.h
@@ -41,27 +41,29 @@ public:
   FloatComplexLU (const FloatComplexLU& a)
     : base_lu <FloatComplexMatrix> (a) { }
 
   FloatComplexLU (const FloatComplexMatrix& l, const FloatComplexMatrix& u,
                   const PermMatrix& p)
     : base_lu <FloatComplexMatrix> (l, u, p) { }
 
   FloatComplexLU& operator = (const FloatComplexLU& a)
-    {
-      if (this != &a)
-        base_lu <FloatComplexMatrix> :: operator = (a);
+  {
+    if (this != &a)
+      base_lu <FloatComplexMatrix> :: operator = (a);
 
-      return *this;
-    }
+    return *this;
+  }
 
   ~FloatComplexLU (void) { }
 
-  void update (const FloatComplexColumnVector& u, const FloatComplexColumnVector& v);
+  void update (const FloatComplexColumnVector& u,
+               const FloatComplexColumnVector& v);
 
   void update (const FloatComplexMatrix& u, const FloatComplexMatrix& v);
 
-  void update_piv (const FloatComplexColumnVector& u, const FloatComplexColumnVector& v);
+  void update_piv (const FloatComplexColumnVector& u,
+                   const FloatComplexColumnVector& v);
 
   void update_piv (const FloatComplexMatrix& u, const FloatComplexMatrix& v);
 };
 
 #endif
diff --git a/liboctave/numeric/fCmplxQR.cc b/liboctave/numeric/fCmplxQR.cc
--- a/liboctave/numeric/fCmplxQR.cc
+++ b/liboctave/numeric/fCmplxQR.cc
@@ -118,23 +118,25 @@ FloatComplexQR::init (const FloatComplex
   FloatComplexMatrix afact = a;
   if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
   if (m > 0)
     {
       // workspace query.
       FloatComplex clwork;
-      F77_XFCN (cgeqrf, CGEQRF, (m, n, afact.fortran_vec (), m, tau, &clwork, -1, info));
+      F77_XFCN (cgeqrf, CGEQRF, (m, n, afact.fortran_vec (), m, tau,
+                                 &clwork, -1, info));
 
       // allocate buffer and do the job.
       octave_idx_type lwork = clwork.real ();
       lwork = std::max (lwork, static_cast<octave_idx_type> (1));
       OCTAVE_LOCAL_BUFFER (FloatComplex, work, lwork);
-      F77_XFCN (cgeqrf, CGEQRF, (m, n, afact.fortran_vec (), m, tau, work, lwork, info));
+      F77_XFCN (cgeqrf, CGEQRF, (m, n, afact.fortran_vec (), m, tau,
+                                 work, lwork, info));
     }
 
   form (n, afact, tau, qr_type);
 }
 
 void FloatComplexQR::form (octave_idx_type n, FloatComplexMatrix& afact,
                            FloatComplex *tau, qr_type_t qr_type)
 {
@@ -161,17 +163,17 @@ void FloatComplexQR::form (octave_idx_ty
           q = afact;
           octave_idx_type k = qr_type == qr_type_economy ? n : m;
           r = FloatComplexMatrix (k, n);
           for (octave_idx_type j = 0; j < n; j++)
             {
               octave_idx_type i = 0;
               for (; i <= j; i++)
                 r.xelem (i, j) = afact.xelem (i, j);
-              for (;i < k; i++)
+              for (; i < k; i++)
                 r.xelem (i, j) = 0;
             }
           afact = FloatComplexMatrix (); // optimize memory
         }
       else
         {
           // afact will become r.
           q = FloatComplexMatrix (m, m);
@@ -201,58 +203,65 @@ void FloatComplexQR::form (octave_idx_ty
                                      work, lwork, info));
         }
     }
 }
 
 #ifdef HAVE_QRUPDATE
 
 void
-FloatComplexQR::update (const FloatComplexColumnVector& u, const FloatComplexColumnVector& v)
+FloatComplexQR::update (const FloatComplexColumnVector& u,
+                        const FloatComplexColumnVector& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   if (u.length () == m && v.length () == n)
     {
       FloatComplexColumnVector utmp = u, vtmp = v;
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, k);
       OCTAVE_LOCAL_BUFFER (float, rw, k);
-      F77_XFCN (cqr1up, CQR1UP, (m, n, k, q.fortran_vec (), m, r.fortran_vec (), k,
-                                 utmp.fortran_vec (), vtmp.fortran_vec (), w, rw));
+      F77_XFCN (cqr1up, CQR1UP, (m, n, k, q.fortran_vec (),
+                                 m, r.fortran_vec (), k,
+                                 utmp.fortran_vec (), vtmp.fortran_vec (),
+                                 w, rw));
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
-FloatComplexQR::update (const FloatComplexMatrix& u, const FloatComplexMatrix& v)
+FloatComplexQR::update (const FloatComplexMatrix& u,
+                        const FloatComplexMatrix& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, k);
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       for (volatile octave_idx_type i = 0; i < u.cols (); i++)
         {
           FloatComplexColumnVector utmp = u.column (i), vtmp = v.column (i);
-          F77_XFCN (cqr1up, CQR1UP, (m, n, k, q.fortran_vec (), m, r.fortran_vec (), k,
-                                     utmp.fortran_vec (), vtmp.fortran_vec (), w, rw));
+          F77_XFCN (cqr1up, CQR1UP, (m, n, k, q.fortran_vec (),
+                                     m, r.fortran_vec (), k,
+                                     utmp.fortran_vec (), vtmp.fortran_vec (),
+                                     w, rw));
         }
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
-FloatComplexQR::insert_col (const FloatComplexColumnVector& u, octave_idx_type j)
+FloatComplexQR::insert_col (const FloatComplexColumnVector& u,
+                            octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   if (u.length () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   else if (j < 0 || j > n)
@@ -273,17 +282,18 @@ FloatComplexQR::insert_col (const FloatC
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       F77_XFCN (cqrinc, CQRINC, (m, n, k, q.fortran_vec (), q.rows (),
                                  r.fortran_vec (), r.rows (), j + 1,
                                  utmp.data (), rw));
     }
 }
 
 void
-FloatComplexQR::insert_col (const FloatComplexMatrix& u, const Array<octave_idx_type>& j)
+FloatComplexQR::insert_col (const FloatComplexMatrix& u,
+                            const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   Array<octave_idx_type> jsi;
   Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
   octave_idx_type nj = js.length ();
@@ -370,17 +380,18 @@ FloatComplexQR::delete_col (const Array<
   else if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
           octave_idx_type ii = i;
           F77_XFCN (cqrdec, CQRDEC, (m, n - ii, k == m ? k : k - ii,
                                      q.fortran_vec (), q.rows (),
-                                     r.fortran_vec (), r.rows (), js(ii) + 1, rw));
+                                     r.fortran_vec (), r.rows (),
+                                     js(ii) + 1, rw));
         }
       if (k < m)
         {
           q.resize (m, k - nj);
           r.resize (k - nj, n - nj);
         }
       else
         {
@@ -457,33 +468,36 @@ FloatComplexQR::shift_cols (octave_idx_t
     }
 }
 
 #else
 
 // Replacement update methods.
 
 void
-FloatComplexQR::update (const FloatComplexColumnVector& u, const FloatComplexColumnVector& v)
+FloatComplexQR::update (const FloatComplexColumnVector& u,
+                        const FloatComplexColumnVector& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.length () == m && v.length () == n)
     {
-      init (q*r + FloatComplexMatrix (u) * FloatComplexMatrix (v).hermitian (), get_type ());
+      init (q*r + FloatComplexMatrix (u) * FloatComplexMatrix (v).hermitian (),
+            get_type ());
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
-FloatComplexQR::update (const FloatComplexMatrix& u, const FloatComplexMatrix& v)
+FloatComplexQR::update (const FloatComplexMatrix& u,
+                        const FloatComplexMatrix& v)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
@@ -552,17 +566,18 @@ FloatComplexMatrix shift_cols (const Flo
       p(j) = i;
       for (octave_idx_type k = j+1; k < i+1; k++) p(k) = k-1;
     }
 
   return a.index (idx_vector::colon, idx_vector (p));
 }
 
 void
-FloatComplexQR::insert_col (const FloatComplexColumnVector& u, octave_idx_type j)
+FloatComplexQR::insert_col (const FloatComplexColumnVector& u,
+                            octave_idx_type j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   if (u.length () != m)
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
@@ -570,17 +585,18 @@ FloatComplexQR::insert_col (const FloatC
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
   else
     {
       init (::insert_col (q*r, j, u), get_type ());
     }
 }
 
 void
-FloatComplexQR::insert_col (const FloatComplexMatrix& u, const Array<octave_idx_type>& j)
+FloatComplexQR::insert_col (const FloatComplexMatrix& u,
+                            const Array<octave_idx_type>& j)
 {
   warn_qrupdate_once ();
 
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
 
   Array<octave_idx_type> jsi;
   Array<octave_idx_type> js = j.sort (jsi, 0, ASCENDING);
diff --git a/liboctave/numeric/fCmplxQR.h b/liboctave/numeric/fCmplxQR.h
--- a/liboctave/numeric/fCmplxQR.h
+++ b/liboctave/numeric/fCmplxQR.h
@@ -45,23 +45,25 @@ public:
 
   FloatComplexQR (const FloatComplexMatrix& qx, const FloatComplexMatrix& rx)
     : base_qr<FloatComplexMatrix> (qx, rx) { }
 
   FloatComplexQR (const FloatComplexQR& a) : base_qr<FloatComplexMatrix> (a) { }
 
   void init (const FloatComplexMatrix&, qr_type_t = qr_type_std);
 
-  void update (const FloatComplexColumnVector& u, const FloatComplexColumnVector& v);
+  void update (const FloatComplexColumnVector& u,
+               const FloatComplexColumnVector& v);
 
   void update (const FloatComplexMatrix& u, const FloatComplexMatrix& v);
 
   void insert_col (const FloatComplexColumnVector& u, octave_idx_type j);
 
-  void insert_col (const FloatComplexMatrix& u, const Array<octave_idx_type>& j);
+  void insert_col (const FloatComplexMatrix& u,
+                   const Array<octave_idx_type>& j);
 
   void delete_col (octave_idx_type j);
 
   void delete_col (const Array<octave_idx_type>& j);
 
   void insert_row (const FloatComplexRowVector& u, octave_idx_type j);
 
   void delete_row (octave_idx_type j);
diff --git a/liboctave/numeric/fCmplxQRP.cc b/liboctave/numeric/fCmplxQRP.cc
--- a/liboctave/numeric/fCmplxQRP.cc
+++ b/liboctave/numeric/fCmplxQRP.cc
@@ -38,17 +38,18 @@ extern "C"
   F77_FUNC (cgeqp3, CGEQP3) (const octave_idx_type&, const octave_idx_type&,
                              FloatComplex*, const octave_idx_type&,
                              octave_idx_type*, FloatComplex*, FloatComplex*,
                              const octave_idx_type&, float*, octave_idx_type&);
 }
 
 // It would be best to share some of this code with FloatComplexQR class...
 
-FloatComplexQRP::FloatComplexQRP (const FloatComplexMatrix& a, qr_type_t qr_type)
+FloatComplexQRP::FloatComplexQRP (const FloatComplexMatrix& a,
+                                  qr_type_t qr_type)
   : FloatComplexQR (), p ()
 {
   init (a, qr_type);
 }
 
 void
 FloatComplexQRP::init (const FloatComplexMatrix& a, qr_type_t qr_type)
 {
@@ -69,25 +70,27 @@ FloatComplexQRP::init (const FloatComple
   MArray<octave_idx_type> jpvt (dim_vector (n, 1), 0);
 
   if (m > 0)
     {
       OCTAVE_LOCAL_BUFFER (float, rwork, 2*n);
 
       // workspace query.
       FloatComplex clwork;
-      F77_XFCN (cgeqp3, CGEQP3, (m, n, afact.fortran_vec (), m, jpvt.fortran_vec (),
-                                 tau, &clwork, -1, rwork, info));
+      F77_XFCN (cgeqp3, CGEQP3, (m, n, afact.fortran_vec (),
+                                 m, jpvt.fortran_vec (), tau,
+                                 &clwork, -1, rwork, info));
 
       // allocate buffer and do the job.
       octave_idx_type lwork = clwork.real ();
       lwork = std::max (lwork, static_cast<octave_idx_type> (1));
       OCTAVE_LOCAL_BUFFER (FloatComplex, work, lwork);
-      F77_XFCN (cgeqp3, CGEQP3, (m, n, afact.fortran_vec (), m, jpvt.fortran_vec (),
-                                 tau, work, lwork, rwork, info));
+      F77_XFCN (cgeqp3, CGEQP3, (m, n, afact.fortran_vec (),
+                                 m, jpvt.fortran_vec (), tau,
+                                 work, lwork, rwork, info));
     }
   else
     for (octave_idx_type i = 0; i < n; i++) jpvt(i) = i+1;
 
   // Form Permutation matrix (if economy is requested, return the
   // indices only!)
 
   jpvt -= static_cast<octave_idx_type> (1);
diff --git a/liboctave/numeric/fCmplxQRP.h b/liboctave/numeric/fCmplxQRP.h
--- a/liboctave/numeric/fCmplxQRP.h
+++ b/liboctave/numeric/fCmplxQRP.h
@@ -37,24 +37,24 @@ public:
 
   FloatComplexQRP (void) : FloatComplexQR (), p () { }
 
   FloatComplexQRP (const FloatComplexMatrix&, qr_type_t = qr_type_std);
 
   FloatComplexQRP (const FloatComplexQRP& a) : FloatComplexQR (a), p (a.p) { }
 
   FloatComplexQRP& operator = (const FloatComplexQRP& a)
-    {
-      if (this != &a)
-        {
-          FloatComplexQR::operator = (a);
-          p = a.p;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        FloatComplexQR::operator = (a);
+        p = a.p;
+      }
+    return *this;
+  }
 
   ~FloatComplexQRP (void) { }
 
   void init (const FloatComplexMatrix&, qr_type_t = qr_type_std);
 
   PermMatrix P (void) const { return p; }
 
   FloatRowVector Pvec (void) const;
diff --git a/liboctave/numeric/fCmplxSCHUR.cc b/liboctave/numeric/fCmplxSCHUR.cc
--- a/liboctave/numeric/fCmplxSCHUR.cc
+++ b/liboctave/numeric/fCmplxSCHUR.cc
@@ -59,17 +59,17 @@ select_ana (const FloatComplex& a)
 static octave_idx_type
 select_dig (const FloatComplex& a)
 {
   return (abs (a) < 1.0);
 }
 
 octave_idx_type
 FloatComplexSCHUR::init (const FloatComplexMatrix& a, const std::string& ord,
-                    bool calc_unitary)
+                         bool calc_unitary)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler)
         ("FloatComplexSCHUR requires square matrix");
diff --git a/liboctave/numeric/fCmplxSCHUR.h b/liboctave/numeric/fCmplxSCHUR.h
--- a/liboctave/numeric/fCmplxSCHUR.h
+++ b/liboctave/numeric/fCmplxSCHUR.h
@@ -33,60 +33,62 @@ class
 OCTAVE_API
 FloatComplexSCHUR
 {
 public:
 
   FloatComplexSCHUR (void) : schur_mat (), unitary_mat (), selector (0) { }
 
   FloatComplexSCHUR (const FloatComplexMatrix& a, const std::string& ord,
-                bool calc_unitary = true)
+                     bool calc_unitary = true)
     : schur_mat (), unitary_mat (), selector (0)
-    {
-      init (a, ord, calc_unitary);
-    }
+  {
+    init (a, ord, calc_unitary);
+  }
 
   FloatComplexSCHUR (const FloatComplexMatrix& a, const std::string& ord,
                      octave_idx_type& info, bool calc_unitary = true)
     : schur_mat (), unitary_mat (), selector (0)
-    {
-      info = init (a, ord, calc_unitary);
-    }
+  {
+    info = init (a, ord, calc_unitary);
+  }
 
   FloatComplexSCHUR (const FloatComplexSCHUR& a)
     : schur_mat (a.schur_mat), unitary_mat (a.unitary_mat), selector (0)
-    { }
+  { }
 
   FloatComplexSCHUR (const FloatComplexMatrix& s, const FloatComplexMatrix& u);
 
   FloatComplexSCHUR (const FloatSCHUR& s);
 
   FloatComplexSCHUR& operator = (const FloatComplexSCHUR& a)
-    {
-      if (this != &a)
-        {
-          schur_mat = a.schur_mat;
-          unitary_mat = a.unitary_mat;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        schur_mat = a.schur_mat;
+        unitary_mat = a.unitary_mat;
+      }
+    return *this;
+  }
 
   ~FloatComplexSCHUR (void) { }
 
   FloatComplexMatrix schur_matrix (void) const { return schur_mat; }
 
   FloatComplexMatrix unitary_matrix (void) const { return unitary_mat; }
 
-  friend std::ostream& operator << (std::ostream& os, const FloatComplexSCHUR& a);
+  friend std::ostream& operator << (std::ostream& os,
+                                    const FloatComplexSCHUR& a);
 
   typedef octave_idx_type (*select_function) (const FloatComplex&);
 
 private:
 
   FloatComplexMatrix schur_mat;
   FloatComplexMatrix unitary_mat;
 
   select_function selector;
 
-  octave_idx_type init (const FloatComplexMatrix& a, const std::string& ord, bool calc_unitary);
+  octave_idx_type init (const FloatComplexMatrix& a, const std::string& ord,
+                        bool calc_unitary);
 };
 
 #endif
diff --git a/liboctave/numeric/fCmplxSVD.h b/liboctave/numeric/fCmplxSVD.h
--- a/liboctave/numeric/fCmplxSVD.h
+++ b/liboctave/numeric/fCmplxSVD.h
@@ -32,60 +32,61 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 FloatComplexSVD
 {
 public:
 
   FloatComplexSVD (void)
     : type_computed (), sigma (), left_sm (), right_sm ()
-    { }
+  { }
 
   FloatComplexSVD (const FloatComplexMatrix& a,
                    SVD::type svd_type = SVD::std,
                    SVD::driver svd_driver = SVD::GESVD)
     : type_computed (), sigma (), left_sm (), right_sm ()
-    {
-      init (a, svd_type, svd_driver);
-    }
+  {
+    init (a, svd_type, svd_driver);
+  }
 
   FloatComplexSVD (const FloatComplexMatrix& a, octave_idx_type& info,
                    SVD::type svd_type = SVD::std,
                    SVD::driver svd_driver = SVD::GESVD)
     : type_computed (), sigma (), left_sm (), right_sm ()
-    {
-      info = init (a, svd_type, svd_driver);
-    }
+  {
+    info = init (a, svd_type, svd_driver);
+  }
 
   FloatComplexSVD (const FloatComplexSVD& a)
     : type_computed (a.type_computed), sigma (a.sigma),
       left_sm (a.left_sm), right_sm (a.right_sm)
-    { }
+  { }
 
   FloatComplexSVD& operator = (const FloatComplexSVD& a)
-    {
-      if (this != &a)
-        {
-          type_computed = a.type_computed;
-          sigma = a.sigma;
-          left_sm = a.left_sm;
-          right_sm = a.right_sm;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        type_computed = a.type_computed;
+        sigma = a.sigma;
+        left_sm = a.left_sm;
+        right_sm = a.right_sm;
+      }
+    return *this;
+  }
 
   ~FloatComplexSVD (void) { }
 
   FloatDiagMatrix singular_values (void) const { return sigma; }
 
   FloatComplexMatrix left_singular_matrix (void) const;
 
   FloatComplexMatrix right_singular_matrix (void) const;
 
-  friend std::ostream&  operator << (std::ostream& os, const FloatComplexSVD& a);
+  friend std::ostream&  operator << (std::ostream& os,
+                                     const FloatComplexSVD& a);
 
 private:
 
   SVD::type type_computed;
 
   FloatDiagMatrix sigma;
   FloatComplexMatrix left_sm;
   FloatComplexMatrix right_sm;
diff --git a/liboctave/numeric/fEIG.cc b/liboctave/numeric/fEIG.cc
--- a/liboctave/numeric/fEIG.cc
+++ b/liboctave/numeric/fEIG.cc
@@ -594,17 +594,18 @@ FloatEIG::init (const FloatMatrix& a, co
     }
   else
     (*current_liboctave_error_handler) ("sggev workspace query failed");
 
   return info;
 }
 
 octave_idx_type
-FloatEIG::symmetric_init (const FloatMatrix& a, const FloatMatrix& b, bool calc_ev)
+FloatEIG::symmetric_init (const FloatMatrix& a, const FloatMatrix& b,
+                          bool calc_ev)
 {
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols ())
     {
       (*current_liboctave_error_handler) ("EIG requires square matrix");
       return -1;
@@ -669,17 +670,18 @@ FloatEIG::symmetric_init (const FloatMat
     }
   else
     (*current_liboctave_error_handler) ("ssygv workspace query failed");
 
   return info;
 }
 
 octave_idx_type
-FloatEIG::init (const FloatComplexMatrix& a, const FloatComplexMatrix& b, bool calc_ev)
+FloatEIG::init (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
+                bool calc_ev)
 {
   if (a.any_element_is_inf_or_nan () || b.any_element_is_inf_or_nan ())
     {
       (*current_liboctave_error_handler)
         ("EIG: matrix contains Inf or NaN values");
       return -1;
     }
 
@@ -781,17 +783,18 @@ FloatEIG::init (const FloatComplexMatrix
     }
   else
     (*current_liboctave_error_handler) ("cggev workspace query failed");
 
   return info;
 }
 
 octave_idx_type
-FloatEIG::hermitian_init (const FloatComplexMatrix& a, const FloatComplexMatrix& b, bool calc_ev)
+FloatEIG::hermitian_init (const FloatComplexMatrix& a,
+                          const FloatComplexMatrix& b, bool calc_ev)
 {
   octave_idx_type n = a.rows ();
   octave_idx_type nb = b.rows ();
 
   if (n != a.cols () || nb != b.cols ())
     {
       (*current_liboctave_error_handler) ("EIG requires square matrix");
       return -1;
diff --git a/liboctave/numeric/fEIG.h b/liboctave/numeric/fEIG.h
--- a/liboctave/numeric/fEIG.h
+++ b/liboctave/numeric/fEIG.h
@@ -28,18 +28,18 @@ along with Octave; see the file COPYING.
 #include "fMatrix.h"
 #include "fCMatrix.h"
 #include "fCColVector.h"
 
 class
 OCTAVE_API
 FloatEIG
 {
-friend class FloatMatrix;
-friend class FloatComplexMatrix;
+  friend class FloatMatrix;
+  friend class FloatComplexMatrix;
 
 public:
 
   FloatEIG (void)
     : lambda (), v () { }
 
   FloatEIG (const FloatMatrix& a, bool calc_eigenvectors = true)
     : lambda (), v ()
@@ -93,42 +93,48 @@ public:
     : lambda (), v ()
   {
     info = init (a, b, calc_eigenvectors);
   }
 
   FloatEIG (const FloatEIG& a) : lambda (a.lambda), v (a.v) { }
 
   FloatEIG& operator = (const FloatEIG& a)
-    {
-      if (this != &a)
-        {
-          lambda = a.lambda;
-          v = a.v;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        lambda = a.lambda;
+        v = a.v;
+      }
+    return *this;
+  }
 
   ~FloatEIG (void) { }
 
   FloatComplexColumnVector eigenvalues (void) const { return lambda; }
 
   FloatComplexMatrix eigenvectors (void) const { return v; }
 
   friend std::ostream&  operator << (std::ostream& os, const FloatEIG& a);
 
 private:
 
   FloatComplexColumnVector lambda;
   FloatComplexMatrix v;
 
   octave_idx_type init (const FloatMatrix& a, bool calc_eigenvectors);
-  octave_idx_type init (const FloatMatrix& a, const FloatMatrix& b, bool calc_eigenvectors);
+  octave_idx_type init (const FloatMatrix& a, const FloatMatrix& b,
+                        bool calc_eigenvectors);
   octave_idx_type init (const FloatComplexMatrix& a, bool calc_eigenvectors);
-  octave_idx_type init (const FloatComplexMatrix& a, const FloatComplexMatrix& b, bool calc_eigenvectors);
+  octave_idx_type init (const FloatComplexMatrix& a,
+                        const FloatComplexMatrix& b, bool calc_eigenvectors);
 
   octave_idx_type symmetric_init (const FloatMatrix& a, bool calc_eigenvectors);
-  octave_idx_type symmetric_init (const FloatMatrix& a, const FloatMatrix& b, bool calc_eigenvectors);
-  octave_idx_type hermitian_init (const FloatComplexMatrix& a, bool calc_eigenvectors);
-  octave_idx_type hermitian_init (const FloatComplexMatrix& a, const FloatComplexMatrix& b, bool calc_eigenvectors);
+  octave_idx_type symmetric_init (const FloatMatrix& a, const FloatMatrix& b,
+                                  bool calc_eigenvectors);
+  octave_idx_type hermitian_init (const FloatComplexMatrix& a,
+                                  bool calc_eigenvectors);
+  octave_idx_type hermitian_init (const FloatComplexMatrix& a,
+                                  const FloatComplexMatrix& b,
+                                  bool calc_eigenvectors);
 };
 
 #endif
diff --git a/liboctave/numeric/floatCHOL.cc b/liboctave/numeric/floatCHOL.cc
--- a/liboctave/numeric/floatCHOL.cc
+++ b/liboctave/numeric/floatCHOL.cc
@@ -337,17 +337,17 @@ FloatCHOL::downdate (const FloatColumnVe
 
   if (u.length () == n)
     {
       if (singular (chol_mat))
         info = 2;
       else
         {
           info = init (chol_mat.transpose () * chol_mat
-                - FloatMatrix (u) * FloatMatrix (u).transpose (), false);
+                       - FloatMatrix (u) * FloatMatrix (u).transpose (), false);
           if (info) info = 1;
         }
     }
   else
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
   return info;
 }
diff --git a/liboctave/numeric/floatCHOL.h b/liboctave/numeric/floatCHOL.h
--- a/liboctave/numeric/floatCHOL.h
+++ b/liboctave/numeric/floatCHOL.h
@@ -34,38 +34,38 @@ OCTAVE_API
 FloatCHOL
 {
 public:
 
   FloatCHOL (void) : chol_mat (), xrcond (0) { }
 
   FloatCHOL (const FloatMatrix& a, bool calc_cond = false)
     : chol_mat (), xrcond (0)
-    {
-      init (a, calc_cond);
-    }
+  {
+    init (a, calc_cond);
+  }
 
   FloatCHOL (const FloatMatrix& a, octave_idx_type& info,
              bool calc_cond = false)
     : chol_mat (), xrcond (0)
-    {
-      info = init (a, calc_cond);
-    }
+  {
+    info = init (a, calc_cond);
+  }
 
   FloatCHOL (const FloatCHOL& a) : chol_mat (a.chol_mat), xrcond (a.xrcond) { }
 
   FloatCHOL& operator = (const FloatCHOL& a)
-    {
-      if (this != &a)
-        {
-          chol_mat = a.chol_mat;
-          xrcond = a.xrcond;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        chol_mat = a.chol_mat;
+        xrcond = a.xrcond;
+      }
+    return *this;
+  }
 
   FloatMatrix chol_matrix (void) const { return chol_mat; }
 
   float rcond (void) const { return xrcond; }
 
   // Compute the inverse of a matrix using the Cholesky factorization.
   FloatMatrix inverse (void) const;
 
@@ -76,17 +76,18 @@ public:
   octave_idx_type downdate (const FloatColumnVector& u);
 
   octave_idx_type insert_sym (const FloatColumnVector& u, octave_idx_type j);
 
   void delete_sym (octave_idx_type j);
 
   void shift_sym (octave_idx_type i, octave_idx_type j);
 
-  friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatCHOL& a);
+  friend OCTAVE_API std::ostream& operator << (std::ostream& os,
+                                               const FloatCHOL& a);
 
 private:
 
   FloatMatrix chol_mat;
 
   float xrcond;
 
   octave_idx_type init (const FloatMatrix& a, bool calc_cond);
diff --git a/liboctave/numeric/floatGEPBAL.cc b/liboctave/numeric/floatGEPBAL.cc
--- a/liboctave/numeric/floatGEPBAL.cc
+++ b/liboctave/numeric/floatGEPBAL.cc
@@ -55,23 +55,24 @@ extern "C"
                              const octave_idx_type& LDV, octave_idx_type& INFO
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
 }
 
 octave_idx_type
 FloatGEPBALANCE::init (const FloatMatrix& a, const FloatMatrix& b,
-                  const std::string& balance_job)
+                       const std::string& balance_job)
 {
   octave_idx_type n = a.cols ();
 
   if (a.rows () != n)
     {
-      (*current_liboctave_error_handler) ("FloatGEPBALANCE requires square matrix");
+      (*current_liboctave_error_handler)
+        ("FloatGEPBALANCE requires square matrix");
       return -1;
     }
 
   if (a.dims () != b.dims ())
     {
       gripe_nonconformant ("FloatGEPBALANCE", n, n, b.rows(), b.cols());
       return -1;
     }
diff --git a/liboctave/numeric/floatGEPBAL.h b/liboctave/numeric/floatGEPBAL.h
--- a/liboctave/numeric/floatGEPBAL.h
+++ b/liboctave/numeric/floatGEPBAL.h
@@ -31,39 +31,39 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 FloatGEPBALANCE
 {
 public:
 
   FloatGEPBALANCE (void)
     : balanced_mat (), balanced_mat2 (), balancing_mat (), balancing_mat2 ()
-    { }
+  { }
   FloatGEPBALANCE (const FloatMatrix& a, const FloatMatrix& b,
                    const std::string& balance_job)
     : balanced_mat (), balanced_mat2 (), balancing_mat (), balancing_mat2 ()
-    {
-      init (a, b, balance_job);
-    }
+  {
+    init (a, b, balance_job);
+  }
 
   FloatGEPBALANCE (const FloatGEPBALANCE& a)
     : balanced_mat (a.balanced_mat), balanced_mat2 (a.balanced_mat2),
       balancing_mat (a.balancing_mat), balancing_mat2 (a.balancing_mat2) { }
 
   FloatGEPBALANCE& operator = (const FloatGEPBALANCE& a)
-    {
-      if (this != &a)
-        {
-          balanced_mat = a.balanced_mat;
-          balanced_mat2 = a.balanced_mat2;
-          balancing_mat = a.balancing_mat;
-          balancing_mat2 = a.balancing_mat2;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        balanced_mat = a.balanced_mat;
+        balanced_mat2 = a.balanced_mat2;
+        balancing_mat = a.balancing_mat;
+        balancing_mat2 = a.balancing_mat2;
+      }
+    return *this;
+  }
 
   ~FloatGEPBALANCE (void) { }
 
   FloatMatrix balanced_matrix (void) const { return balanced_mat; }
 
   FloatMatrix balanced_matrix2 (void) const { return balanced_mat2; }
 
   FloatMatrix balancing_matrix (void) const { return balancing_mat; }
diff --git a/liboctave/numeric/floatHESS.h b/liboctave/numeric/floatHESS.h
--- a/liboctave/numeric/floatHESS.h
+++ b/liboctave/numeric/floatHESS.h
@@ -31,39 +31,39 @@ class
 OCTAVE_API
 FloatHESS
 {
 public:
 
   FloatHESS (void) : hess_mat (), unitary_hess_mat () { }
 
   FloatHESS (const FloatMatrix& a)
-     : hess_mat (), unitary_hess_mat ()
-    {
-      init (a);
-    }
+    : hess_mat (), unitary_hess_mat ()
+  {
+    init (a);
+  }
 
   FloatHESS (const FloatMatrix& a, octave_idx_type& info)
     : hess_mat (), unitary_hess_mat ()
-    {
-      info = init (a);
-    }
+  {
+    info = init (a);
+  }
 
   FloatHESS (const FloatHESS& a)
     : hess_mat (a.hess_mat), unitary_hess_mat (a.unitary_hess_mat) { }
 
   FloatHESS& operator = (const FloatHESS& a)
-    {
-      if (this != &a)
-        {
-          hess_mat = a.hess_mat;
-          unitary_hess_mat = a.unitary_hess_mat;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        hess_mat = a.hess_mat;
+        unitary_hess_mat = a.unitary_hess_mat;
+      }
+    return *this;
+  }
 
   ~FloatHESS (void) { }
 
   FloatMatrix hess_matrix (void) const { return hess_mat; }
 
   FloatMatrix unitary_hess_matrix (void) const { return unitary_hess_mat; }
 
   friend std::ostream& operator << (std::ostream& os, const FloatHESS& a);
diff --git a/liboctave/numeric/floatLU.cc b/liboctave/numeric/floatLU.cc
--- a/liboctave/numeric/floatLU.cc
+++ b/liboctave/numeric/floatLU.cc
@@ -95,17 +95,18 @@ void FloatLU::update (const FloatColumnV
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
   if (u.length () == m && v.length () == n)
     {
       FloatColumnVector utmp = u, vtmp = v;
-      F77_XFCN (slu1up, SLU1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
+      F77_XFCN (slu1up, SLU1UP, (m, n, l.fortran_vec (),
+                                 m, r.fortran_vec (), k,
                                  utmp.fortran_vec (), vtmp.fortran_vec ()));
     }
   else
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 }
 
 void FloatLU::update (const FloatMatrix& u, const FloatMatrix& v)
 {
@@ -119,43 +120,47 @@ void FloatLU::update (const FloatMatrix&
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
       for (volatile octave_idx_type i = 0; i < u.cols (); i++)
         {
           FloatColumnVector utmp = u.column (i), vtmp = v.column (i);
-          F77_XFCN (slu1up, SLU1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
+          F77_XFCN (slu1up, SLU1UP, (m, n, l.fortran_vec (),
+                                     m, r.fortran_vec (), k,
                                      utmp.fortran_vec (), vtmp.fortran_vec ()));
         }
     }
   else
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 }
 
-void FloatLU::update_piv (const FloatColumnVector& u, const FloatColumnVector& v)
+void FloatLU::update_piv (const FloatColumnVector& u,
+                          const FloatColumnVector& v)
 {
   if (packed ())
     unpack ();
 
   FloatMatrix& l = l_fact;
   FloatMatrix& r = a_fact;
 
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
   if (u.length () == m && v.length () == n)
     {
       FloatColumnVector utmp = u, vtmp = v;
       OCTAVE_LOCAL_BUFFER (float, w, m);
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
-      F77_XFCN (slup1up, SLUP1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
-                                   ipvt.fortran_vec (), utmp.data (), vtmp.data (), w));
+      F77_XFCN (slup1up, SLUP1UP, (m, n, l.fortran_vec (),
+                                   m, r.fortran_vec (), k,
+                                   ipvt.fortran_vec (),
+                                   utmp.data (), vtmp.data (), w));
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
   else
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 }
 
 void FloatLU::update_piv (const FloatMatrix& u, const FloatMatrix& v)
 {
@@ -171,40 +176,46 @@ void FloatLU::update_piv (const FloatMat
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
       OCTAVE_LOCAL_BUFFER (float, w, m);
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
       for (volatile octave_idx_type i = 0; i < u.cols (); i++)
         {
           FloatColumnVector utmp = u.column (i), vtmp = v.column (i);
-          F77_XFCN (slup1up, SLUP1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
-                                       ipvt.fortran_vec (), utmp.data (), vtmp.data (), w));
+          F77_XFCN (slup1up, SLUP1UP, (m, n, l.fortran_vec (),
+                                       m, r.fortran_vec (), k,
+                                       ipvt.fortran_vec (),
+                                       utmp.data (), vtmp.data (), w));
         }
       for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
   else
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 }
 
 #else
 
 void FloatLU::update (const FloatColumnVector&, const FloatColumnVector&)
 {
-  (*current_liboctave_error_handler) ("luupdate: not available in this version");
+  (*current_liboctave_error_handler)
+    ("luupdate: not available in this version");
 }
 
 void FloatLU::update (const FloatMatrix&, const FloatMatrix&)
 {
-  (*current_liboctave_error_handler) ("luupdate: not available in this version");
+  (*current_liboctave_error_handler)
+    ("luupdate: not available in this version");
 }
 
 void FloatLU::update_piv (const FloatColumnVector&, const FloatColumnVector&)
 {
-  (*current_liboctave_error_handler) ("luupdate: not available in this version");
+  (*current_liboctave_error_handler)
+    ("luupdate: not available in this version");
 }
 
 void FloatLU::update_piv (const FloatMatrix&, const FloatMatrix&)
 {
-  (*current_liboctave_error_handler) ("luupdate: not available in this version");
+  (*current_liboctave_error_handler)
+    ("luupdate: not available in this version");
 }
 
 #endif
diff --git a/liboctave/numeric/floatLU.h b/liboctave/numeric/floatLU.h
--- a/liboctave/numeric/floatLU.h
+++ b/liboctave/numeric/floatLU.h
@@ -39,22 +39,22 @@ public:
 
   FloatLU (const FloatLU& a) : base_lu <FloatMatrix> (a) { }
 
   FloatLU (const FloatMatrix& l, const FloatMatrix& u,
            const PermMatrix& p)
     : base_lu <FloatMatrix> (l, u, p) { }
 
   FloatLU& operator = (const FloatLU& a)
-    {
-      if (this != &a)
-        base_lu <FloatMatrix> :: operator = (a);
+  {
+    if (this != &a)
+      base_lu <FloatMatrix> :: operator = (a);
 
-      return *this;
-    }
+    return *this;
+  }
 
   ~FloatLU (void) { }
 
   void update (const FloatColumnVector& u, const FloatColumnVector& v);
 
   void update (const FloatMatrix& u, const FloatMatrix& v);
 
   void update_piv (const FloatColumnVector& u, const FloatColumnVector& v);
diff --git a/liboctave/numeric/floatQR.cc b/liboctave/numeric/floatQR.cc
--- a/liboctave/numeric/floatQR.cc
+++ b/liboctave/numeric/floatQR.cc
@@ -114,23 +114,25 @@ FloatQR::init (const FloatMatrix& a, qr_
   FloatMatrix afact = a;
   if (m > n && qr_type == qr_type_std)
     afact.resize (m, m);
 
   if (m > 0)
     {
       // workspace query.
       float rlwork;
-      F77_XFCN (sgeqrf, SGEQRF, (m, n, afact.fortran_vec (), m, tau, &rlwork, -1, info));
+      F77_XFCN (sgeqrf, SGEQRF, (m, n, afact.fortran_vec (), m, tau,
+                                 &rlwork, -1, info));
 
       // allocate buffer and do the job.
       octave_idx_type lwork = rlwork;
       lwork = std::max (lwork, static_cast<octave_idx_type> (1));
       OCTAVE_LOCAL_BUFFER (float, work, lwork);
-      F77_XFCN (sgeqrf, SGEQRF, (m, n, afact.fortran_vec (), m, tau, work, lwork, info));
+      F77_XFCN (sgeqrf, SGEQRF, (m, n, afact.fortran_vec (), m, tau,
+                                 work, lwork, info));
     }
 
   form (n, afact, tau, qr_type);
 }
 
 void FloatQR::form (octave_idx_type n, FloatMatrix& afact,
                     float *tau, qr_type_t qr_type)
 {
@@ -157,17 +159,17 @@ void FloatQR::form (octave_idx_type n, F
           q = afact;
           octave_idx_type k = qr_type == qr_type_economy ? n : m;
           r = FloatMatrix (k, n);
           for (octave_idx_type j = 0; j < n; j++)
             {
               octave_idx_type i = 0;
               for (; i <= j; i++)
                 r.xelem (i, j) = afact.xelem (i, j);
-              for (;i < k; i++)
+              for (; i < k; i++)
                 r.xelem (i, j) = 0;
             }
           afact = FloatMatrix (); // optimize memory
         }
       else
         {
           // afact will become r.
           q = FloatMatrix (m, m);
@@ -207,17 +209,18 @@ FloatQR::update (const FloatColumnVector
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = q.columns ();
 
   if (u.length () == m && v.length () == n)
     {
       FloatColumnVector utmp = u, vtmp = v;
       OCTAVE_LOCAL_BUFFER (float, w, 2*k);
-      F77_XFCN (sqr1up, SQR1UP, (m, n, k, q.fortran_vec (), m, r.fortran_vec (), k,
+      F77_XFCN (sqr1up, SQR1UP, (m, n, k, q.fortran_vec (),
+                                 m, r.fortran_vec (), k,
                                  utmp.fortran_vec (), vtmp.fortran_vec (), w));
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
 FloatQR::update (const FloatMatrix& u, const FloatMatrix& v)
@@ -227,18 +230,20 @@ FloatQR::update (const FloatMatrix& u, c
   octave_idx_type k = q.columns ();
 
   if (u.rows () == m && v.rows () == n && u.cols () == v.cols ())
     {
       OCTAVE_LOCAL_BUFFER (float, w, 2*k);
       for (volatile octave_idx_type i = 0; i < u.cols (); i++)
         {
           FloatColumnVector utmp = u.column (i), vtmp = v.column (i);
-          F77_XFCN (sqr1up, SQR1UP, (m, n, k, q.fortran_vec (), m, r.fortran_vec (), k,
-                                     utmp.fortran_vec (), vtmp.fortran_vec (), w));
+          F77_XFCN (sqr1up, SQR1UP, (m, n, k, q.fortran_vec (),
+                                     m, r.fortran_vec (), k,
+                                     utmp.fortran_vec (), vtmp.fortran_vec (),
+                                     w));
         }
     }
   else
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 }
 
 void
 FloatQR::insert_col (const FloatColumnVector& u, octave_idx_type j)
@@ -365,17 +370,18 @@ FloatQR::delete_col (const Array<octave_
   else if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (float, w, k);
       for (volatile octave_idx_type i = 0; i < js.length (); i++)
         {
           octave_idx_type ii = i;
           F77_XFCN (sqrdec, SQRDEC, (m, n - ii, k == m ? k : k - ii,
                                      q.fortran_vec (), q.rows (),
-                                     r.fortran_vec (), r.rows (), js(ii) + 1, w));
+                                     r.fortran_vec (), r.rows (),
+                                     js(ii) + 1, w));
         }
       if (k < m)
         {
           q.resize (m, k - nj);
           r.resize (k - nj, n - nj);
         }
       else
         {
diff --git a/liboctave/numeric/floatQRP.cc b/liboctave/numeric/floatQRP.cc
--- a/liboctave/numeric/floatQRP.cc
+++ b/liboctave/numeric/floatQRP.cc
@@ -67,25 +67,27 @@ FloatQRP::init (const FloatMatrix& a, qr
     afact.resize (m, m);
 
   MArray<octave_idx_type> jpvt (dim_vector (n, 1), 0);
 
   if (m > 0)
     {
       // workspace query.
       float rlwork;
-      F77_XFCN (sgeqp3, SGEQP3, (m, n, afact.fortran_vec (), m, jpvt.fortran_vec (),
-                                 tau, &rlwork, -1, info));
+      F77_XFCN (sgeqp3, SGEQP3, (m, n, afact.fortran_vec (),
+                                 m, jpvt.fortran_vec (), tau,
+                                 &rlwork, -1, info));
 
       // allocate buffer and do the job.
       octave_idx_type lwork = rlwork;
       lwork = std::max (lwork, static_cast<octave_idx_type> (1));
       OCTAVE_LOCAL_BUFFER (float, work, lwork);
-      F77_XFCN (sgeqp3, SGEQP3, (m, n, afact.fortran_vec (), m, jpvt.fortran_vec (),
-                                 tau, work, lwork, info));
+      F77_XFCN (sgeqp3, SGEQP3, (m, n, afact.fortran_vec (),
+                                 m, jpvt.fortran_vec (), tau,
+                                 work, lwork, info));
     }
   else
     for (octave_idx_type i = 0; i < n; i++) jpvt(i) = i+1;
 
   // Form Permutation matrix (if economy is requested, return the
   // indices only!)
 
   jpvt -= static_cast<octave_idx_type> (1);
diff --git a/liboctave/numeric/floatQRP.h b/liboctave/numeric/floatQRP.h
--- a/liboctave/numeric/floatQRP.h
+++ b/liboctave/numeric/floatQRP.h
@@ -37,25 +37,25 @@ public:
 
   FloatQRP (void) : FloatQR (), p () { }
 
   FloatQRP (const FloatMatrix&, qr_type_t = qr_type_std);
 
   FloatQRP (const FloatQRP& a) : FloatQR (a), p (a.p) { }
 
   FloatQRP& operator = (const FloatQRP& a)
-    {
-      if (this != &a)
-        {
-          FloatQR::operator = (a);
-          p = a.p;
-        }
+  {
+    if (this != &a)
+      {
+        FloatQR::operator = (a);
+        p = a.p;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   ~FloatQRP (void) { }
 
   void init (const FloatMatrix&, qr_type_t = qr_type_std);
 
   PermMatrix P (void) const { return p; }
 
   FloatRowVector Pvec (void) const;
diff --git a/liboctave/numeric/floatSCHUR.cc b/liboctave/numeric/floatSCHUR.cc
--- a/liboctave/numeric/floatSCHUR.cc
+++ b/liboctave/numeric/floatSCHUR.cc
@@ -46,27 +46,28 @@ extern "C"
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 }
 
 static octave_idx_type
 select_ana (const float& a, const float&)
 {
-   return (a < 0.0);
+  return (a < 0.0);
 }
 
 static octave_idx_type
 select_dig (const float& a, const float& b)
 {
   return (hypot (a, b) < 1.0);
 }
 
 octave_idx_type
-FloatSCHUR::init (const FloatMatrix& a, const std::string& ord, bool calc_unitary)
+FloatSCHUR::init (const FloatMatrix& a, const std::string& ord,
+                  bool calc_unitary)
 {
   octave_idx_type a_nr = a.rows ();
   octave_idx_type a_nc = a.cols ();
 
   if (a_nr != a_nc)
     {
       (*current_liboctave_error_handler) ("FloatSCHUR requires square matrix");
       return -1;
diff --git a/liboctave/numeric/floatSCHUR.h b/liboctave/numeric/floatSCHUR.h
--- a/liboctave/numeric/floatSCHUR.h
+++ b/liboctave/numeric/floatSCHUR.h
@@ -34,42 +34,42 @@ FloatSCHUR
 {
 public:
 
   FloatSCHUR (void) : schur_mat (), unitary_mat (), selector (0) { }
 
   FloatSCHUR (const FloatMatrix& a, const std::string& ord,
               bool calc_unitary = true)
     : schur_mat (), unitary_mat (), selector (0)
-    {
-      init (a, ord, calc_unitary);
-    }
+  {
+    init (a, ord, calc_unitary);
+  }
 
   FloatSCHUR (const FloatMatrix& a, const std::string& ord, int& info,
               bool calc_unitary = true)
     : schur_mat (), unitary_mat (), selector (0)
-    {
-      info = init (a, ord, calc_unitary);
-    }
+  {
+    info = init (a, ord, calc_unitary);
+  }
 
   FloatSCHUR (const FloatSCHUR& a)
     : schur_mat (a.schur_mat), unitary_mat (a.unitary_mat), selector (0)
-    { }
+  { }
 
   FloatSCHUR (const FloatMatrix& s, const FloatMatrix& u);
 
   FloatSCHUR& operator = (const FloatSCHUR& a)
-    {
-      if (this != &a)
-        {
-          schur_mat = a.schur_mat;
-          unitary_mat = a.unitary_mat;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        schur_mat = a.schur_mat;
+        unitary_mat = a.unitary_mat;
+      }
+    return *this;
+  }
 
   ~FloatSCHUR (void) { }
 
   FloatMatrix schur_matrix (void) const { return schur_mat; }
 
   FloatMatrix unitary_matrix (void) const { return unitary_mat; }
 
   friend std::ostream& operator << (std::ostream& os, const FloatSCHUR& a);
@@ -78,12 +78,13 @@ public:
 
 private:
 
   FloatMatrix schur_mat;
   FloatMatrix unitary_mat;
 
   select_function selector;
 
-  octave_idx_type init (const FloatMatrix& a, const std::string& ord, bool calc_unitary);
+  octave_idx_type init (const FloatMatrix& a, const std::string& ord,
+                        bool calc_unitary);
 };
 
 #endif
diff --git a/liboctave/numeric/floatSVD.cc b/liboctave/numeric/floatSVD.cc
--- a/liboctave/numeric/floatSVD.cc
+++ b/liboctave/numeric/floatSVD.cc
@@ -76,17 +76,18 @@ FloatSVD::right_singular_matrix (void) c
         ("FloatSVD: V not computed because type == SVD::sigma_only");
       return FloatMatrix ();
     }
   else
     return right_sm;
 }
 
 octave_idx_type
-FloatSVD::init (const FloatMatrix& a, SVD::type svd_type, SVD::driver svd_driver)
+FloatSVD::init (const FloatMatrix& a, SVD::type svd_type,
+                SVD::driver svd_driver)
 {
   octave_idx_type info;
 
   octave_idx_type m = a.rows ();
   octave_idx_type n = a.cols ();
 
   FloatMatrix atmp = a;
   float *tmp_data = atmp.fortran_vec ();
@@ -173,26 +174,26 @@ FloatSVD::init (const FloatMatrix& a, SV
     }
   else if (svd_driver == SVD::GESDD)
     {
       assert (jobu == jobv);
       char jobz = jobu;
       OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, 8*min_mn);
 
       F77_XFCN (sgesdd, SGESDD, (F77_CONST_CHAR_ARG2 (&jobz, 1),
-                                 m, n, tmp_data, m1, s_vec, u, m1, vt,
-                                 nrow_vt1, work.fortran_vec (), lwork, iwork, info
+                                 m, n, tmp_data, m1, s_vec, u, m1, vt, nrow_vt1,
+                                 work.fortran_vec (), lwork, iwork, info
                                  F77_CHAR_ARG_LEN (1)));
 
       lwork = static_cast<octave_idx_type> (work(0));
       work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (sgesdd, SGESDD, (F77_CONST_CHAR_ARG2 (&jobz, 1),
-                                 m, n, tmp_data, m1, s_vec, u, m1, vt,
-                                 nrow_vt1, work.fortran_vec (), lwork, iwork, info
+                                 m, n, tmp_data, m1, s_vec, u, m1, vt, nrow_vt1,
+                                 work.fortran_vec (), lwork, iwork, info
                                  F77_CHAR_ARG_LEN (1)));
 
     }
   else
     assert (0); // impossible
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm = right_sm.transpose ();
diff --git a/liboctave/numeric/floatSVD.h b/liboctave/numeric/floatSVD.h
--- a/liboctave/numeric/floatSVD.h
+++ b/liboctave/numeric/floatSVD.h
@@ -35,45 +35,45 @@ FloatSVD
 {
 public:
 
   FloatSVD (void) : type_computed (), sigma (), left_sm (), right_sm () { }
 
   FloatSVD (const FloatMatrix& a,
             SVD::type svd_type = SVD::std, SVD::driver svd_driver = SVD::GESVD)
     : type_computed (), sigma (), left_sm (), right_sm ()
-    {
-      init (a, svd_type, svd_driver);
-    }
+  {
+    init (a, svd_type, svd_driver);
+  }
 
   FloatSVD (const FloatMatrix& a, octave_idx_type& info,
             SVD::type svd_type = SVD::std,
             SVD::driver svd_driver = SVD::GESVD)
     : type_computed (), sigma (), left_sm (), right_sm ()
-    {
-      info = init (a, svd_type, svd_driver);
-    }
+  {
+    info = init (a, svd_type, svd_driver);
+  }
 
   FloatSVD (const FloatSVD& a)
     : type_computed (a.type_computed), sigma (a.sigma),
       left_sm (a.left_sm), right_sm (a.right_sm)
-    { }
+  { }
 
   FloatSVD& operator = (const FloatSVD& a)
-    {
-      if (this != &a)
-        {
-          type_computed = a.type_computed;
-          sigma = a.sigma;
-          left_sm = a.left_sm;
-          right_sm = a.right_sm;
-        }
+  {
+    if (this != &a)
+      {
+        type_computed = a.type_computed;
+        sigma = a.sigma;
+        left_sm = a.left_sm;
+        right_sm = a.right_sm;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   ~FloatSVD (void) { }
 
   FloatDiagMatrix singular_values (void) const { return sigma; }
 
   FloatMatrix left_singular_matrix (void) const;
 
   FloatMatrix right_singular_matrix (void) const;
diff --git a/liboctave/numeric/lo-mappers.cc b/liboctave/numeric/lo-mappers.cc
--- a/liboctave/numeric/lo-mappers.cc
+++ b/liboctave/numeric/lo-mappers.cc
@@ -242,17 +242,17 @@ octave_is_NA (const Complex& x)
 bool
 octave_is_NaN_or_NA (const Complex& x)
 {
   return (xisnan (real (x)) || xisnan (imag (x)));
 }
 
 // (complex, complex) -> complex mappers.
 
-// FIXME -- need to handle NA too?
+// FIXME: need to handle NA too?
 
 Complex
 xmin (const Complex& x, const Complex& y)
 {
   return abs (x) <= abs (y) ? x : (xisnan (x) ? x : y);
 }
 
 Complex
@@ -452,17 +452,18 @@ atan (const FloatComplex& x)
   static FloatComplex i (0, 1);
 
   return i * log ((i + x) / (i - x)) / static_cast<float>(2.0);
 }
 
 FloatComplex
 atanh (const FloatComplex& x)
 {
-  return log ((static_cast<float>(1.0) + x) / (static_cast<float>(1.0) - x)) / static_cast<float>(2.0);
+  return log ((static_cast<float>(1.0) + x) / (static_cast<float>
+              (1.0) - x)) / static_cast<float>(2.0);
 }
 
 // complex -> bool mappers.
 
 bool
 octave_is_NA (const FloatComplex& x)
 {
   return (octave_is_NA (real (x)) || octave_is_NA (imag (x)));
@@ -471,17 +472,17 @@ octave_is_NA (const FloatComplex& x)
 bool
 octave_is_NaN_or_NA (const FloatComplex& x)
 {
   return (xisnan (real (x)) || xisnan (imag (x)));
 }
 
 // (complex, complex) -> complex mappers.
 
-// FIXME -- need to handle NA too?
+// FIXME: need to handle NA too?
 
 FloatComplex
 xmin (const FloatComplex& x, const FloatComplex& y)
 {
   return abs (x) <= abs (y) ? x : (xisnan (x) ? x : y);
 }
 
 FloatComplex
@@ -530,17 +531,18 @@ Complex
 rc_atanh (double x)
 {
   return fabs (x) > 1.0 ? atanh (Complex (x)) : Complex (atanh (x));
 }
 
 FloatComplex
 rc_atanh (float x)
 {
-  return fabsf (x) > 1.0f ? atanh (FloatComplex (x)) : FloatComplex (atanhf (x));
+  return fabsf (x) > 1.0f ? atanh (FloatComplex (x))
+                          : FloatComplex (atanhf (x));
 }
 
 Complex
 rc_log (double x)
 {
   const double pi = 3.14159265358979323846;
   return x < 0.0 ? Complex (log (-x), pi) : Complex (log (x));
 }
@@ -572,17 +574,18 @@ rc_log10 (double x)
   const double pil10 = 1.36437635384184134748; // = pi / log(10)
   return x < 0.0 ? Complex (log10 (-x), pil10) : Complex (log10 (x));
 }
 
 FloatComplex
 rc_log10 (float x)
 {
   const float pil10 = 1.36437635384184134748f; // = pi / log(10)
-  return x < 0.0f ? FloatComplex (log10 (-x), pil10) : FloatComplex (log10f (x));
+  return x < 0.0f ? FloatComplex (log10 (-x), pil10)
+                  : FloatComplex (log10f (x));
 }
 
 Complex
 rc_sqrt (double x)
 {
   return x < 0.0 ? Complex (0.0, sqrt (-x)) : Complex (sqrt (x));
 }
 
diff --git a/liboctave/numeric/lo-mappers.h b/liboctave/numeric/lo-mappers.h
--- a/liboctave/numeric/lo-mappers.h
+++ b/liboctave/numeric/lo-mappers.h
@@ -173,18 +173,20 @@ extern OCTAVE_API FloatComplex acosh (co
 extern OCTAVE_API FloatComplex asin (const FloatComplex& x);
 extern OCTAVE_API FloatComplex asinh (const FloatComplex& x);
 extern OCTAVE_API FloatComplex atan (const FloatComplex& x);
 extern OCTAVE_API FloatComplex atanh (const FloatComplex& x);
 
 extern OCTAVE_API bool octave_is_NA (const FloatComplex& x);
 extern OCTAVE_API bool octave_is_NaN_or_NA (const FloatComplex& x);
 
-extern OCTAVE_API FloatComplex xmin (const FloatComplex& x, const FloatComplex& y);
-extern OCTAVE_API FloatComplex xmax (const FloatComplex& x, const FloatComplex& y);
+extern OCTAVE_API FloatComplex xmin (const FloatComplex& x,
+                                     const FloatComplex& y);
+extern OCTAVE_API FloatComplex xmax (const FloatComplex& x,
+                                     const FloatComplex& y);
 
 // These map reals to Complex.
 
 extern OCTAVE_API Complex rc_acos (double);
 extern OCTAVE_API FloatComplex rc_acos (float);
 extern OCTAVE_API Complex rc_acosh (double);
 extern OCTAVE_API FloatComplex rc_acosh (float);
 extern OCTAVE_API Complex rc_asin (double);
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -618,17 +618,17 @@ double
 log1p (double x)
 {
   double retval;
 
   double ax = fabs (x);
 
   if (ax < 0.2)
     {
-      // use approximation log (1+x) ~ 2*sum ((x/(2+x)).^ii ./ ii), ii = 1:2:2n+1
+      // approximation log (1+x) ~ 2*sum ((x/(2+x)).^ii ./ ii), ii = 1:2:2n+1
       double u = x / (2 + x), t = 1, s = 0;
       for (int i = 2; i < 12; i += 2)
         s += (t *= u*u) / (i+1);
 
       retval = 2 * (s + 1) * u;
     }
   else
     retval = log (1 + x);
@@ -677,17 +677,17 @@ float
 log1pf (float x)
 {
   float retval;
 
   float ax = fabs (x);
 
   if (ax < 0.2)
     {
-      // use approximation log (1+x) ~ 2*sum ((x/(2+x)).^ii ./ ii), ii = 1:2:2n+1
+      // approximation log (1+x) ~ 2*sum ((x/(2+x)).^ii ./ ii), ii = 1:2:2n+1
       float u = x / (2 + x), t = 1, s = 0;
       for (int i = 2; i < 12; i += 2)
         s += (t *= u*u) / (i+1);
 
       retval = 2 * (s + 1) * u;
     }
   else
     retval = log (1 + x);
@@ -702,17 +702,17 @@ log1p (const FloatComplex& x)
   FloatComplex retval;
 
   float r = x.real (), i = x.imag ();
 
   if (fabs (r) < 0.5 && fabs (i) < 0.5)
     {
       float u = 2*r + r*r + i*i;
       retval = FloatComplex (log1p (u / (1+sqrt (u+1))),
-                        atan2 (1 + r, i));
+                             atan2 (1 + r, i));
     }
   else
     retval = std::log (FloatComplex (1) + x);
 
   return retval;
 }
 
 #if !defined (HAVE_CBRTF)
@@ -949,17 +949,17 @@ zbesi (const Complex& z, double alpha, i
     {
       alpha = -alpha;
 
       Complex tmp = zbesi (z, alpha, kode, ierr);
 
       if (ierr == 0 || ierr == 3)
         {
           Complex tmp2 = (2.0 / M_PI) * sin (M_PI * alpha)
-            * zbesk (z, alpha, kode, ierr);
+                         * zbesk (z, alpha, kode, ierr);
 
           if (kode == 2)
             {
               // Compensate for different scaling factor of besk.
               tmp2 *= exp (-z - std::abs (z.real ()));
             }
 
           tmp += tmp2;
@@ -1207,17 +1207,17 @@ do_bessel (dptr f, const char *, double 
 {
   dim_vector dv = x.dims ();
   octave_idx_type nel = dv.numel ();
   ComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
-      retval(i) = f (x(i), alpha, (scaled ? 2 : 1), ierr(i));
+    retval(i) = f (x(i), alpha, (scaled ? 2 : 1), ierr(i));
 
   return retval;
 }
 
 static inline ComplexNDArray
 do_bessel (dptr f, const char *, const NDArray& alpha, const Complex& x,
            bool scaled, Array<octave_idx_type>& ierr)
 {
@@ -1254,17 +1254,18 @@ do_bessel (dptr f, const char *fn, const
     (*current_liboctave_error_handler)
       ("%s: the sizes of alpha and x must conform", fn);
 
   return retval;
 }
 
 static inline ComplexMatrix
 do_bessel (dptr f, const char *, const RowVector& alpha,
-           const ComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr)
+           const ComplexColumnVector& x, bool scaled,
+           Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = x.length ();
   octave_idx_type nc = alpha.length ();
 
   ComplexMatrix retval (nr, nc);
 
   ierr.resize (dim_vector (nr, nc));
 
@@ -1381,18 +1382,20 @@ static inline FloatComplex
 cbesh1 (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr);
 
 static inline FloatComplex
 cbesh2 (const FloatComplex& z, float alpha, int kode, octave_idx_type& ierr);
 
 static inline FloatComplex
 bessel_return_value (const FloatComplex& val, octave_idx_type ierr)
 {
-  static const FloatComplex inf_val = FloatComplex (octave_Float_Inf, octave_Float_Inf);
-  static const FloatComplex nan_val = FloatComplex (octave_Float_NaN, octave_Float_NaN);
+  static const FloatComplex inf_val = FloatComplex (octave_Float_Inf,
+                                                    octave_Float_Inf);
+  static const FloatComplex nan_val = FloatComplex (octave_Float_NaN,
+                                                    octave_Float_NaN);
 
   FloatComplex retval;
 
   switch (ierr)
     {
     case 0:
     case 3:
       retval = val;
@@ -1448,21 +1451,23 @@ cbesj (const FloatComplex& z, float alph
       if ((static_cast <long> (alpha)) & 1)
         tmp = - tmp;
       retval = bessel_return_value (tmp, ierr);
     }
   else
     {
       alpha = -alpha;
 
-      FloatComplex tmp = cosf (static_cast<float> (M_PI) * alpha) * cbesj (z, alpha, kode, ierr);
+      FloatComplex tmp = cosf (static_cast<float> (M_PI) * alpha)
+                         * cbesj (z, alpha, kode, ierr);
 
       if (ierr == 0 || ierr == 3)
         {
-          tmp -= sinf (static_cast<float> (M_PI) * alpha) * cbesy (z, alpha, kode, ierr);
+          tmp -= sinf (static_cast<float> (M_PI) * alpha)
+                 * cbesy (z, alpha, kode, ierr);
 
           retval = bessel_return_value (tmp, ierr);
         }
       else
         retval = FloatComplex (octave_Float_NaN, octave_Float_NaN);
     }
 
   return retval;
@@ -1511,21 +1516,23 @@ cbesy (const FloatComplex& z, float alph
       if ((static_cast <long> (alpha - 0.5)) & 1)
         tmp = - tmp;
       retval = bessel_return_value (tmp, ierr);
     }
   else
     {
       alpha = -alpha;
 
-      FloatComplex tmp = cosf (static_cast<float> (M_PI) * alpha) * cbesy (z, alpha, kode, ierr);
+      FloatComplex tmp = cosf (static_cast<float> (M_PI) * alpha)
+                         * cbesy (z, alpha, kode, ierr);
 
       if (ierr == 0 || ierr == 3)
         {
-          tmp += sinf (static_cast<float> (M_PI) * alpha) * cbesj (z, alpha, kode, ierr);
+          tmp += sinf (static_cast<float> (M_PI) * alpha)
+                 * cbesj (z, alpha, kode, ierr);
 
           retval = bessel_return_value (tmp, ierr);
         }
       else
         retval = FloatComplex (octave_Float_NaN, octave_Float_NaN);
     }
 
   return retval;
@@ -1558,18 +1565,19 @@ cbesi (const FloatComplex& z, float alph
   else
     {
       alpha = -alpha;
 
       FloatComplex tmp = cbesi (z, alpha, kode, ierr);
 
       if (ierr == 0 || ierr == 3)
         {
-          FloatComplex tmp2 = static_cast<float> (2.0 / M_PI) * sinf (static_cast<float> (M_PI) * alpha)
-            * cbesk (z, alpha, kode, ierr);
+          FloatComplex tmp2 = static_cast<float> (2.0 / M_PI)
+                              * sinf (static_cast<float> (M_PI) * alpha)
+                              * cbesk (z, alpha, kode, ierr);
 
           if (kode == 2)
             {
               // Compensate for different scaling factor of besk.
               tmp2 *= exp (-z - std::abs (z.real ()));
             }
 
           tmp += tmp2;
@@ -1662,17 +1670,18 @@ cbesh1 (const FloatComplex& z, float alp
       retval = bessel_return_value (y, ierr);
     }
   else
     {
       alpha = -alpha;
 
       static const FloatComplex eye = FloatComplex (0.0, 1.0);
 
-      FloatComplex tmp = exp (static_cast<float> (M_PI) * alpha * eye) * cbesh1 (z, alpha, kode, ierr);
+      FloatComplex tmp = exp (static_cast<float> (M_PI) * alpha * eye)
+                         * cbesh1 (z, alpha, kode, ierr);
 
       retval = bessel_return_value (tmp, ierr);
     }
 
   return retval;
 }
 
 static inline FloatComplex
@@ -1704,25 +1713,27 @@ cbesh2 (const FloatComplex& z, float alp
       retval = bessel_return_value (y, ierr);
     }
   else
     {
       alpha = -alpha;
 
       static const FloatComplex eye = FloatComplex (0.0, 1.0);
 
-      FloatComplex tmp = exp (-static_cast<float> (M_PI) * alpha * eye) * cbesh2 (z, alpha, kode, ierr);
+      FloatComplex tmp = exp (-static_cast<float> (M_PI) * alpha * eye)
+                         * cbesh2 (z, alpha, kode, ierr);
 
       retval = bessel_return_value (tmp, ierr);
     }
 
   return retval;
 }
 
-typedef FloatComplex (*fptr) (const FloatComplex&, float, int, octave_idx_type&);
+typedef FloatComplex (*fptr) (const FloatComplex&, float, int,
+                              octave_idx_type&);
 
 static inline FloatComplex
 do_bessel (fptr f, const char *, float alpha, const FloatComplex& x,
            bool scaled, octave_idx_type& ierr)
 {
   FloatComplex retval;
 
   retval = f (x, alpha, (scaled ? 2 : 1), ierr);
@@ -1744,17 +1755,18 @@ do_bessel (fptr f, const char *, float a
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x(i,j), alpha, (scaled ? 2 : 1), ierr(i,j));
 
   return retval;
 }
 
 static inline FloatComplexMatrix
-do_bessel (fptr f, const char *, const FloatMatrix& alpha, const FloatComplex& x,
+do_bessel (fptr f, const char *, const FloatMatrix& alpha,
+           const FloatComplex& x,
            bool scaled, Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = alpha.rows ();
   octave_idx_type nc = alpha.cols ();
 
   FloatComplexMatrix retval (nr, nc);
 
   ierr.resize (dim_vector (nr, nc));
@@ -1763,17 +1775,18 @@ do_bessel (fptr f, const char *, const F
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = f (x, alpha(i,j), (scaled ? 2 : 1), ierr(i,j));
 
   return retval;
 }
 
 static inline FloatComplexMatrix
 do_bessel (fptr f, const char *fn, const FloatMatrix& alpha,
-           const FloatComplexMatrix& x, bool scaled, Array<octave_idx_type>& ierr)
+           const FloatComplexMatrix& x, bool scaled,
+           Array<octave_idx_type>& ierr)
 {
   FloatComplexMatrix retval;
 
   octave_idx_type x_nr = x.rows ();
   octave_idx_type x_nc = x.cols ();
 
   octave_idx_type alpha_nr = alpha.rows ();
   octave_idx_type alpha_nc = alpha.cols ();
@@ -1804,40 +1817,41 @@ do_bessel (fptr f, const char *, float a
 {
   dim_vector dv = x.dims ();
   octave_idx_type nel = dv.numel ();
   FloatComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
-      retval(i) = f (x(i), alpha, (scaled ? 2 : 1), ierr(i));
+    retval(i) = f (x(i), alpha, (scaled ? 2 : 1), ierr(i));
 
   return retval;
 }
 
 static inline FloatComplexNDArray
-do_bessel (fptr f, const char *, const FloatNDArray& alpha, const FloatComplex& x,
-           bool scaled, Array<octave_idx_type>& ierr)
+do_bessel (fptr f, const char *, const FloatNDArray& alpha,
+           const FloatComplex& x, bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = alpha.dims ();
   octave_idx_type nel = dv.numel ();
   FloatComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     retval(i) = f (x, alpha(i), (scaled ? 2 : 1), ierr(i));
 
   return retval;
 }
 
 static inline FloatComplexNDArray
 do_bessel (fptr f, const char *fn, const FloatNDArray& alpha,
-           const FloatComplexNDArray& x, bool scaled, Array<octave_idx_type>& ierr)
+           const FloatComplexNDArray& x, bool scaled,
+           Array<octave_idx_type>& ierr)
 {
   dim_vector dv = x.dims ();
   FloatComplexNDArray retval;
 
   if (dv == alpha.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
@@ -1851,17 +1865,18 @@ do_bessel (fptr f, const char *fn, const
     (*current_liboctave_error_handler)
       ("%s: the sizes of alpha and x must conform", fn);
 
   return retval;
 }
 
 static inline FloatComplexMatrix
 do_bessel (fptr f, const char *, const FloatRowVector& alpha,
-           const FloatComplexColumnVector& x, bool scaled, Array<octave_idx_type>& ierr)
+           const FloatComplexColumnVector& x, bool scaled,
+           Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = x.length ();
   octave_idx_type nc = alpha.length ();
 
   FloatComplexMatrix retval (nr, nc);
 
   ierr.resize (dim_vector (nr, nc));
 
@@ -2024,66 +2039,70 @@ biry (const Complex& z, bool deriv, bool
 
   if (zi == 0.0 && (! scaled || zr >= 0.0))
     ai = 0.0;
 
   return bessel_return_value (Complex (ar, ai), ierr);
 }
 
 ComplexMatrix
-airy (const ComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
+airy (const ComplexMatrix& z, bool deriv, bool scaled,
+      Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = z.rows ();
   octave_idx_type nc = z.cols ();
 
   ComplexMatrix retval (nr, nc);
 
   ierr.resize (dim_vector (nr, nc));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = airy (z(i,j), deriv, scaled, ierr(i,j));
 
   return retval;
 }
 
 ComplexMatrix
-biry (const ComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
+biry (const ComplexMatrix& z, bool deriv, bool scaled,
+      Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = z.rows ();
   octave_idx_type nc = z.cols ();
 
   ComplexMatrix retval (nr, nc);
 
   ierr.resize (dim_vector (nr, nc));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = biry (z(i,j), deriv, scaled, ierr(i,j));
 
   return retval;
 }
 
 ComplexNDArray
-airy (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
+airy (const ComplexNDArray& z, bool deriv, bool scaled,
+      Array<octave_idx_type>& ierr)
 {
   dim_vector dv = z.dims ();
   octave_idx_type nel = dv.numel ();
   ComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     retval(i) = airy (z(i), deriv, scaled, ierr(i));
 
   return retval;
 }
 
 ComplexNDArray
-biry (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
+biry (const ComplexNDArray& z, bool deriv, bool scaled,
+      Array<octave_idx_type>& ierr)
 {
   dim_vector dv = z.dims ();
   octave_idx_type nel = dv.numel ();
   ComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
@@ -2136,17 +2155,18 @@ biry (const FloatComplex& z, bool deriv,
   float zi = z.imag ();
 
   octave_idx_type id = deriv ? 1 : 0;
 
   F77_FUNC (cbiry, CBIRY) (zr, zi, id, 2, ar, ai, ierr);
 
   if (! scaled)
     {
-      FloatComplex expz = exp (std::abs (real (static_cast<float> (2.0 / 3.0) * z * sqrt (z))));
+      FloatComplex expz = exp (std::abs (real (static_cast<float> (2.0 / 3.0)
+                          * z * sqrt (z))));
 
       float rexpz = real (expz);
       float iexpz = imag (expz);
 
       float tmp = ar*rexpz - ai*iexpz;
 
       ai = ar*iexpz + ai*rexpz;
       ar = tmp;
@@ -2154,66 +2174,70 @@ biry (const FloatComplex& z, bool deriv,
 
   if (zi == 0.0 && (! scaled || zr >= 0.0))
     ai = 0.0;
 
   return bessel_return_value (FloatComplex (ar, ai), ierr);
 }
 
 FloatComplexMatrix
-airy (const FloatComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
+airy (const FloatComplexMatrix& z, bool deriv, bool scaled,
+      Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = z.rows ();
   octave_idx_type nc = z.cols ();
 
   FloatComplexMatrix retval (nr, nc);
 
   ierr.resize (dim_vector (nr, nc));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = airy (z(i,j), deriv, scaled, ierr(i,j));
 
   return retval;
 }
 
 FloatComplexMatrix
-biry (const FloatComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
+biry (const FloatComplexMatrix& z, bool deriv, bool scaled,
+      Array<octave_idx_type>& ierr)
 {
   octave_idx_type nr = z.rows ();
   octave_idx_type nc = z.cols ();
 
   FloatComplexMatrix retval (nr, nc);
 
   ierr.resize (dim_vector (nr, nc));
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       retval(i,j) = biry (z(i,j), deriv, scaled, ierr(i,j));
 
   return retval;
 }
 
 FloatComplexNDArray
-airy (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
+airy (const FloatComplexNDArray& z, bool deriv, bool scaled,
+      Array<octave_idx_type>& ierr)
 {
   dim_vector dv = z.dims ();
   octave_idx_type nel = dv.numel ();
   FloatComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     retval(i) = airy (z(i), deriv, scaled, ierr(i));
 
   return retval;
 }
 
 FloatComplexNDArray
-biry (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
+biry (const FloatComplexNDArray& z, bool deriv, bool scaled,
+      Array<octave_idx_type>& ierr)
 {
   dim_vector dv = z.dims ();
   octave_idx_type nel = dv.numel ();
   FloatComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
@@ -2226,31 +2250,31 @@ static void
 gripe_betainc_nonconformant (const dim_vector& d1, const dim_vector& d2,
                              const dim_vector& d3)
 {
   std::string d1_str = d1.str ();
   std::string d2_str = d2.str ();
   std::string d3_str = d3.str ();
 
   (*current_liboctave_error_handler)
-  ("betainc: nonconformant arguments (x is %s, a is %s, b is %s)",
-   d1_str.c_str (), d2_str.c_str (), d3_str.c_str ());
+    ("betainc: nonconformant arguments (x is %s, a is %s, b is %s)",
+     d1_str.c_str (), d2_str.c_str (), d3_str.c_str ());
 }
 
 static void
 gripe_betaincinv_nonconformant (const dim_vector& d1, const dim_vector& d2,
                                 const dim_vector& d3)
 {
   std::string d1_str = d1.str ();
   std::string d2_str = d2.str ();
   std::string d3_str = d3.str ();
 
   (*current_liboctave_error_handler)
-  ("betaincinv: nonconformant arguments (x is %s, a is %s, b is %s)",
-   d1_str.c_str (), d2_str.c_str (), d3_str.c_str ());
+    ("betaincinv: nonconformant arguments (x is %s, a is %s, b is %s)",
+     d1_str.c_str (), d2_str.c_str (), d3_str.c_str ());
 }
 
 double
 betainc (double x, double a, double b)
 {
   double retval;
   F77_XFCN (xdbetai, XDBETAI, (x, a, b, retval));
   return retval;
@@ -2539,17 +2563,17 @@ betainc (const Array<float>& x, const Ar
         *pretval++ = betainc (x(i), a(i), b(i));
     }
   else
     gripe_betainc_nonconformant (dv, a.dims (), b.dims ());
 
   return retval;
 }
 
-// FIXME -- there is still room for improvement here...
+// FIXME: there is still room for improvement here...
 
 double
 gammainc (double x, double a, bool& err)
 {
   double retval;
 
   err = false;
 
@@ -2583,17 +2607,17 @@ gammainc (double x, const Matrix& a)
         result(i,j) = gammainc (x, a(i,j), err);
 
         if (err)
           goto done;
       }
 
   retval = result;
 
- done:
+done:
 
   return retval;
 }
 
 Matrix
 gammainc (const Matrix& x, double a)
 {
   octave_idx_type nr = x.rows ();
@@ -2610,17 +2634,17 @@ gammainc (const Matrix& x, double a)
         result(i,j) = gammainc (x(i,j), a, err);
 
         if (err)
           goto done;
       }
 
   retval = result;
 
- done:
+done:
 
   return retval;
 }
 
 Matrix
 gammainc (const Matrix& x, const Matrix& a)
 {
   Matrix result;
@@ -2649,17 +2673,17 @@ gammainc (const Matrix& x, const Matrix&
 
       retval = result;
     }
   else
     (*current_liboctave_error_handler)
       ("gammainc: nonconformant arguments (arg 1 is %dx%d, arg 2 is %dx%d)",
        nr, nc, a_nr, a_nc);
 
- done:
+done:
 
   return retval;
 }
 
 NDArray
 gammainc (double x, const NDArray& a)
 {
   dim_vector dv = a.dims ();
@@ -2675,17 +2699,17 @@ gammainc (double x, const NDArray& a)
       result (i) = gammainc (x, a(i), err);
 
       if (err)
         goto done;
     }
 
   retval = result;
 
- done:
+done:
 
   return retval;
 }
 
 NDArray
 gammainc (const NDArray& x, double a)
 {
   dim_vector dv = x.dims ();
@@ -2701,17 +2725,17 @@ gammainc (const NDArray& x, double a)
       result (i) = gammainc (x(i), a, err);
 
       if (err)
         goto done;
     }
 
   retval = result;
 
- done:
+done:
 
   return retval;
 }
 
 NDArray
 gammainc (const NDArray& x, const NDArray& a)
 {
   dim_vector dv = x.dims ();
@@ -2741,17 +2765,17 @@ gammainc (const NDArray& x, const NDArra
       std::string x_str = dv.str ();
       std::string a_str = a.dims ().str ();
 
       (*current_liboctave_error_handler)
         ("gammainc: nonconformant arguments (arg 1 is %s, arg 2 is %s)",
          x_str.c_str (), a_str. c_str ());
     }
 
- done:
+done:
 
   return retval;
 }
 
 float
 gammainc (float x, float a, bool& err)
 {
   float retval;
@@ -2788,17 +2812,17 @@ gammainc (float x, const FloatMatrix& a)
         result(i,j) = gammainc (x, a(i,j), err);
 
         if (err)
           goto done;
       }
 
   retval = result;
 
- done:
+done:
 
   return retval;
 }
 
 FloatMatrix
 gammainc (const FloatMatrix& x, float a)
 {
   octave_idx_type nr = x.rows ();
@@ -2815,17 +2839,17 @@ gammainc (const FloatMatrix& x, float a)
         result(i,j) = gammainc (x(i,j), a, err);
 
         if (err)
           goto done;
       }
 
   retval = result;
 
- done:
+done:
 
   return retval;
 }
 
 FloatMatrix
 gammainc (const FloatMatrix& x, const FloatMatrix& a)
 {
   FloatMatrix result;
@@ -2854,17 +2878,17 @@ gammainc (const FloatMatrix& x, const Fl
 
       retval = result;
     }
   else
     (*current_liboctave_error_handler)
       ("gammainc: nonconformant arguments (arg 1 is %dx%d, arg 2 is %dx%d)",
        nr, nc, a_nr, a_nc);
 
- done:
+done:
 
   return retval;
 }
 
 FloatNDArray
 gammainc (float x, const FloatNDArray& a)
 {
   dim_vector dv = a.dims ();
@@ -2880,17 +2904,17 @@ gammainc (float x, const FloatNDArray& a
       result (i) = gammainc (x, a(i), err);
 
       if (err)
         goto done;
     }
 
   retval = result;
 
- done:
+done:
 
   return retval;
 }
 
 FloatNDArray
 gammainc (const FloatNDArray& x, float a)
 {
   dim_vector dv = x.dims ();
@@ -2906,17 +2930,17 @@ gammainc (const FloatNDArray& x, float a
       result (i) = gammainc (x(i), a, err);
 
       if (err)
         goto done;
     }
 
   retval = result;
 
- done:
+done:
 
   return retval;
 }
 
 FloatNDArray
 gammainc (const FloatNDArray& x, const FloatNDArray& a)
 {
   dim_vector dv = x.dims ();
@@ -2946,59 +2970,68 @@ gammainc (const FloatNDArray& x, const F
       std::string x_str = dv.str ();
       std::string a_str = a.dims ().str ();
 
       (*current_liboctave_error_handler)
         ("gammainc: nonconformant arguments (arg 1 is %s, arg 2 is %s)",
          x_str.c_str (), a_str.c_str ());
     }
 
- done:
+done:
 
   return retval;
 }
 
 
 Complex rc_log1p (double x)
 {
   const double pi = 3.14159265358979323846;
   return x < -1.0 ? Complex (log (-(1.0 + x)), pi) : Complex (log1p (x));
 }
 
 FloatComplex rc_log1p (float x)
 {
   const float pi = 3.14159265358979323846f;
-  return x < -1.0f ? FloatComplex (logf (-(1.0f + x)), pi) : FloatComplex (log1pf (x));
+  return x < -1.0f ? FloatComplex (logf (-(1.0f + x)), pi)
+                   : FloatComplex (log1pf (x));
 }
 
 // This algorithm is due to P. J. Acklam.
 // See http://home.online.no/~pjacklam/notes/invnorm/
 // The rational approximation has relative accuracy 1.15e-9 in the whole region.
 // For doubles, it is refined by a single step of Halley's 3rd order method.
 // For single precision, the accuracy is already OK, so we skip it to get
 // faster evaluation.
 
 static double do_erfinv (double x, bool refine)
 {
   // Coefficients of rational approximation.
   static const double a[] =
-    { -2.806989788730439e+01,  1.562324844726888e+02,
-      -1.951109208597547e+02,  9.783370457507161e+01,
-      -2.168328665628878e+01,  1.772453852905383e+00 };
+  {
+    -2.806989788730439e+01,  1.562324844726888e+02,
+    -1.951109208597547e+02,  9.783370457507161e+01,
+    -2.168328665628878e+01,  1.772453852905383e+00
+  };
   static const double b[] =
-    { -5.447609879822406e+01,  1.615858368580409e+02,
-      -1.556989798598866e+02,  6.680131188771972e+01,
-      -1.328068155288572e+01 };
+  {
+    -5.447609879822406e+01,  1.615858368580409e+02,
+    -1.556989798598866e+02,  6.680131188771972e+01,
+    -1.328068155288572e+01
+  };
   static const double c[] =
-    { -5.504751339936943e-03, -2.279687217114118e-01,
-      -1.697592457770869e+00, -1.802933168781950e+00,
-       3.093354679843505e+00,  2.077595676404383e+00 };
+  {
+    -5.504751339936943e-03, -2.279687217114118e-01,
+    -1.697592457770869e+00, -1.802933168781950e+00,
+    3.093354679843505e+00,  2.077595676404383e+00
+  };
   static const double d[] =
-    {  7.784695709041462e-03,  3.224671290700398e-01,
-       2.445134137142996e+00,  3.754408661907416e+00 };
+  {
+    7.784695709041462e-03,  3.224671290700398e-01,
+    2.445134137142996e+00,  3.754408661907416e+00
+  };
 
   static const double spi2 = 8.862269254527579e-01; // sqrt(pi)/2.
   static const double pbreak = 0.95150;
   double ax = fabs (x), y;
 
   // Select case.
   if (ax <= pbreak)
     {
@@ -3044,30 +3077,38 @@ float erfinv (float x)
 // The algorthim for erfcinv is an adaptation of the erfinv algorithm above
 // from P. J. Acklam.  It has been modified to run over the different input
 // domain of erfcinv.  See the notes for erfinv for an explanation.
 
 static double do_erfcinv (double x, bool refine)
 {
   // Coefficients of rational approximation.
   static const double a[] =
-    { -2.806989788730439e+01,  1.562324844726888e+02,
-      -1.951109208597547e+02,  9.783370457507161e+01,
-      -2.168328665628878e+01,  1.772453852905383e+00 };
+  {
+    -2.806989788730439e+01,  1.562324844726888e+02,
+    -1.951109208597547e+02,  9.783370457507161e+01,
+    -2.168328665628878e+01,  1.772453852905383e+00
+  };
   static const double b[] =
-    { -5.447609879822406e+01,  1.615858368580409e+02,
-      -1.556989798598866e+02,  6.680131188771972e+01,
-      -1.328068155288572e+01 };
+  {
+    -5.447609879822406e+01,  1.615858368580409e+02,
+    -1.556989798598866e+02,  6.680131188771972e+01,
+    -1.328068155288572e+01
+  };
   static const double c[] =
-    { -5.504751339936943e-03, -2.279687217114118e-01,
-      -1.697592457770869e+00, -1.802933168781950e+00,
-       3.093354679843505e+00,  2.077595676404383e+00 };
+  {
+    -5.504751339936943e-03, -2.279687217114118e-01,
+    -1.697592457770869e+00, -1.802933168781950e+00,
+    3.093354679843505e+00,  2.077595676404383e+00
+  };
   static const double d[] =
-    {  7.784695709041462e-03,  3.224671290700398e-01,
-       2.445134137142996e+00,  3.754408661907416e+00 };
+  {
+    7.784695709041462e-03,  3.224671290700398e-01,
+    2.445134137142996e+00,  3.754408661907416e+00
+  };
 
   static const double spi2 = 8.862269254527579e-01; // sqrt(pi)/2.
   static const double pbreak_lo = 0.04850;  // 1-pbreak
   static const double pbreak_hi = 1.95150;  // 1+pbreak
   double y;
 
   // Select case.
   if (x >= pbreak_lo && x <= pbreak_hi)
@@ -3196,17 +3237,17 @@ betain (double x, double p, double q, do
     {
       term = term * temp * rx / (pp + ai);
       value = value + term;
       temp = fabs (term);
 
       if (temp <= acu && temp <= acu * value)
         {
           value = value * exp (pp * log (xx)
-          + (qq - 1.0) * log (cx) - beta) / pp;
+                               + (qq - 1.0) * log (cx) - beta) / pp;
 
           if (indx)
             {
               value = 1.0 - value;
             }
           break;
         }
 
@@ -3554,17 +3595,18 @@ betaincinv (const Array<double>& x, cons
     }
   else
     gripe_betaincinv_nonconformant (dv, a.dims (), dim_vector (0, 0));
 
   return retval;
 }
 
 Array<double>
-betaincinv (const Array<double>& x, const Array<double>& a, const Array<double>& b)
+betaincinv (const Array<double>& x, const Array<double>& a,
+            const Array<double>& b)
 {
   Array<double> retval;
   dim_vector dv = x.dims ();
 
   if (dv == a.dims () && dv == b.dims ())
     {
       octave_idx_type nel = dv.numel ();
 
@@ -3648,17 +3690,18 @@ ellipj (double u, double m, double& sn, 
         }
       sn = sin (phi);
       cn = cos (phi);
       dn = cn/cos (t - phi);
     }
 }
 
 void
-ellipj (const Complex& u, double m, Complex& sn, Complex& cn, Complex& dn, double& err)
+ellipj (const Complex& u, double m, Complex& sn, Complex& cn, Complex& dn,
+        double& err)
 {
   double m1 = 1 - m, ss1, cc1, dd1;
 
   ellipj (imag (u), m1, ss1, cc1, dd1, err);
   if (real (u) == 0)
     {
       // u is pure imag: Jacoby imag. transf.
       sn = Complex (0, ss1/cc1);
diff --git a/liboctave/numeric/lo-specfun.h b/liboctave/numeric/lo-specfun.h
--- a/liboctave/numeric/lo-specfun.h
+++ b/liboctave/numeric/lo-specfun.h
@@ -303,32 +303,38 @@ extern OCTAVE_API ComplexMatrix
 besselh1 (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
           Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
 besselh2 (const RowVector& alpha, const ComplexColumnVector& x, bool scaled,
           Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplex
-besselj (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
+besselj (float alpha, const FloatComplex& x, bool scaled,
+         octave_idx_type& ierr);
 
 extern OCTAVE_API FloatComplex
-bessely (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
+bessely (float alpha, const FloatComplex& x, bool scaled,
+         octave_idx_type& ierr);
 
 extern OCTAVE_API FloatComplex
-besseli (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
+besseli (float alpha, const FloatComplex& x, bool scaled,
+         octave_idx_type& ierr);
 
 extern OCTAVE_API FloatComplex
-besselk (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
+besselk (float alpha, const FloatComplex& x, bool scaled,
+         octave_idx_type& ierr);
 
 extern OCTAVE_API FloatComplex
-besselh1 (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
+besselh1 (float alpha, const FloatComplex& x, bool scaled,
+          octave_idx_type& ierr);
 
 extern OCTAVE_API FloatComplex
-besselh2 (float alpha, const FloatComplex& x, bool scaled, octave_idx_type& ierr);
+besselh2 (float alpha, const FloatComplex& x, bool scaled,
+          octave_idx_type& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 besselj (float alpha, const FloatComplexMatrix& x, bool scaled,
          Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
 bessely (float alpha, const FloatComplexMatrix& x, bool scaled,
          Array<octave_idx_type>& ierr);
@@ -465,88 +471,121 @@ extern OCTAVE_API FloatComplexNDArray
 besselh1 (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
           Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
 besselh2 (const FloatNDArray& alpha, const FloatComplexNDArray& x, bool scaled,
           Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
-besselj (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+besselj (const FloatRowVector& alpha, const FloatComplexColumnVector& x,
+         bool scaled, Array<octave_idx_type>& ierr);
+
+extern OCTAVE_API FloatComplexMatrix
+bessely (const FloatRowVector& alpha, const FloatComplexColumnVector& x,
+         bool scaled, Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
-bessely (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+besseli (const FloatRowVector& alpha, const FloatComplexColumnVector& x,
+         bool scaled, Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
-besseli (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+besselk (const FloatRowVector& alpha, const FloatComplexColumnVector& x,
+         bool scaled, Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
-besselk (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
-         Array<octave_idx_type>& ierr);
+besselh1 (const FloatRowVector& alpha, const FloatComplexColumnVector& x,
+          bool scaled, Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
-besselh1 (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+besselh2 (const FloatRowVector& alpha, const FloatComplexColumnVector& x,
+          bool scaled, Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API FloatComplexMatrix
-besselh2 (const FloatRowVector& alpha, const FloatComplexColumnVector& x, bool scaled,
-          Array<octave_idx_type>& ierr);
+extern OCTAVE_API Complex
+airy (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr);
 
-extern OCTAVE_API Complex airy (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr);
-extern OCTAVE_API Complex biry (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr);
+extern OCTAVE_API Complex
+biry (const Complex& z, bool deriv, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API ComplexMatrix
-airy (const ComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+airy (const ComplexMatrix& z, bool deriv, bool scaled,
+      Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexMatrix
-biry (const ComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+biry (const ComplexMatrix& z, bool deriv, bool scaled,
+      Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
-airy (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+airy (const ComplexNDArray& z, bool deriv, bool scaled,
+      Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API ComplexNDArray
-biry (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+biry (const ComplexNDArray& z, bool deriv, bool scaled,
+      Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API FloatComplex airy (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr);
-extern OCTAVE_API FloatComplex biry (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr);
+extern OCTAVE_API FloatComplex
+airy (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr);
+
+extern OCTAVE_API FloatComplex
+biry (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
-airy (const FloatComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+airy (const FloatComplexMatrix& z, bool deriv, bool scaled,
+      Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexMatrix
-biry (const FloatComplexMatrix& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+biry (const FloatComplexMatrix& z, bool deriv, bool scaled,
+      Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
-airy (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+airy (const FloatComplexNDArray& z, bool deriv, bool scaled,
+      Array<octave_idx_type>& ierr);
 
 extern OCTAVE_API FloatComplexNDArray
-biry (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr);
+biry (const FloatComplexNDArray& z, bool deriv, bool scaled,
+      Array<octave_idx_type>& ierr);
 
-extern OCTAVE_API double betainc (double x, double a, double b);
-extern OCTAVE_API Array<double> betainc (double x, double a, const Array<double>& b);
-extern OCTAVE_API Array<double> betainc (double x, const Array<double>& a, double b);
-extern OCTAVE_API Array<double> betainc (double x, const Array<double>& a, const Array<double>& b);
-extern OCTAVE_API Array<double> betainc (const Array<double>& x, double a, double b);
-extern OCTAVE_API Array<double> betainc (const Array<double>& x, double a, double b);
-extern OCTAVE_API Array<double> betainc (const Array<double>& x, double a, const Array<double>& b);
-extern OCTAVE_API Array<double> betainc (const Array<double>& x, const Array<double>& a, double b);
-extern OCTAVE_API Array<double> betainc (const Array<double>& x, const Array<double>& a, const Array<double>& b);
+extern OCTAVE_API double
+betainc (double x, double a, double b);
+extern OCTAVE_API Array<double>
+betainc (double x, double a, const Array<double>& b);
+extern OCTAVE_API Array<double>
+betainc (double x, const Array<double>& a, double b);
+extern OCTAVE_API Array<double>
+betainc (double x, const Array<double>& a, const Array<double>& b);
+extern OCTAVE_API Array<double>
+betainc (const Array<double>& x, double a, double b);
+extern OCTAVE_API Array<double>
+betainc (const Array<double>& x, double a, double b);
+extern OCTAVE_API Array<double>
+betainc (const Array<double>& x, double a, const Array<double>& b);
+extern OCTAVE_API Array<double>
+betainc (const Array<double>& x, const Array<double>& a, double b);
+extern OCTAVE_API Array<double>
+betainc (const Array<double>& x, const Array<double>& a,
+         const Array<double>& b);
 
-extern OCTAVE_API float betainc (float x, float a, float b);
-extern OCTAVE_API Array<float> betainc (float x, float a, const Array<float>& b);
-extern OCTAVE_API Array<float> betainc (float x, const Array<float>& a, float b);
-extern OCTAVE_API Array<float> betainc (float x, const Array<float>& a, const Array<float>& b);
-extern OCTAVE_API Array<float> betainc (const Array<float>& x, float a, float b);
-extern OCTAVE_API Array<float> betainc (const Array<float>& x, float a, float b);
-extern OCTAVE_API Array<float> betainc (const Array<float>& x, float a, const Array<float>& b);
-extern OCTAVE_API Array<float> betainc (const Array<float>& x, const Array<float>& a, float b);
-extern OCTAVE_API Array<float> betainc (const Array<float>& x, const Array<float>& a, const Array<float>& b);
+extern OCTAVE_API float
+betainc (float x, float a, float b);
+extern OCTAVE_API Array<float>
+betainc (float x, float a, const Array<float>& b);
+extern OCTAVE_API Array<float>
+betainc (float x, const Array<float>& a, float b);
+extern OCTAVE_API Array<float>
+betainc (float x, const Array<float>& a, const Array<float>& b);
+extern OCTAVE_API Array<float>
+betainc (const Array<float>& x, float a, float b);
+extern OCTAVE_API Array<float>
+betainc (const Array<float>& x, float a, float b);
+extern OCTAVE_API Array<float>
+betainc (const Array<float>& x, float a, const Array<float>& b);
+extern OCTAVE_API Array<float>
+betainc (const Array<float>& x, const Array<float>& a, float b);
+extern OCTAVE_API Array<float>
+betainc (const Array<float>& x, const Array<float>& a, const Array<float>& b);
 
 extern OCTAVE_API double gammainc (double x, double a, bool& err);
 extern OCTAVE_API Matrix gammainc (double x, const Matrix& a);
 extern OCTAVE_API Matrix gammainc (const Matrix& x, double a);
 extern OCTAVE_API Matrix gammainc (const Matrix& x, const Matrix& a);
 
 extern OCTAVE_API NDArray gammainc (double x, const NDArray& a);
 extern OCTAVE_API NDArray gammainc (const NDArray& x, double a);
@@ -556,21 +595,23 @@ inline double gammainc (double x, double
 {
   bool err;
   return gammainc (x, a, err);
 }
 
 extern OCTAVE_API float gammainc (float x, float a, bool& err);
 extern OCTAVE_API FloatMatrix gammainc (float x, const FloatMatrix& a);
 extern OCTAVE_API FloatMatrix gammainc (const FloatMatrix& x, float a);
-extern OCTAVE_API FloatMatrix gammainc (const FloatMatrix& x, const FloatMatrix& a);
+extern OCTAVE_API FloatMatrix
+gammainc (const FloatMatrix& x, const FloatMatrix& a);
 
 extern OCTAVE_API FloatNDArray gammainc (float x, const FloatNDArray& a);
 extern OCTAVE_API FloatNDArray gammainc (const FloatNDArray& x, float a);
-extern OCTAVE_API FloatNDArray gammainc (const FloatNDArray& x, const FloatNDArray& a);
+extern OCTAVE_API FloatNDArray
+gammainc (const FloatNDArray& x, const FloatNDArray& a);
 
 inline float gammainc (float x, float a)
 {
   bool err;
   return gammainc (x, a, err);
 }
 
 extern OCTAVE_API Complex rc_log1p (double);
@@ -593,21 +634,33 @@ extern OCTAVE_API Complex erfi (const Co
 extern OCTAVE_API FloatComplex erfi (const FloatComplex& x);
 
 extern OCTAVE_API float dawson (float x);
 extern OCTAVE_API double dawson (double x);
 extern OCTAVE_API Complex dawson (const Complex& x);
 extern OCTAVE_API FloatComplex dawson (const FloatComplex& x);
 
 extern OCTAVE_API double betaincinv (double x, double a, double b);
-extern OCTAVE_API Array<double> betaincinv (double x, double a, const Array<double>& b);
-extern OCTAVE_API Array<double> betaincinv (double x, const Array<double>& a, double b);
-extern OCTAVE_API Array<double> betaincinv (double x, const Array<double>& a, const Array<double>& b);
-extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a, double b);
-extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a, double b);
-extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, double a, const Array<double>& b);
-extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, const Array<double>& a, double b);
-extern OCTAVE_API Array<double> betaincinv (const Array<double>& x, const Array<double>& a, const Array<double>& b);
+extern OCTAVE_API Array<double>
+betaincinv (double x, double a, const Array<double>& b);
+extern OCTAVE_API Array<double>
+betaincinv (double x, const Array<double>& a, double b);
+extern OCTAVE_API Array<double>
+betaincinv (double x, const Array<double>& a, const Array<double>& b);
+extern OCTAVE_API Array<double>
+betaincinv (const Array<double>& x, double a, double b);
+extern OCTAVE_API Array<double>
+betaincinv (const Array<double>& x, double a, double b);
+extern OCTAVE_API Array<double>
+betaincinv (const Array<double>& x, double a, const Array<double>& b);
+extern OCTAVE_API Array<double>
+betaincinv (const Array<double>& x, const Array<double>& a, double b);
+extern OCTAVE_API Array<double>
+betaincinv (const Array<double>& x, const Array<double>& a,
+            const Array<double>& b);
 
-extern OCTAVE_API void ellipj (double u, double m, double& sn, double& cn, double& dn, double& err);
-extern OCTAVE_API void ellipj (const Complex& u, double m, Complex& sn, Complex& cn, Complex& dn, double& err);
+extern OCTAVE_API void
+ellipj (double u, double m, double& sn, double& cn, double& dn, double& err);
+extern OCTAVE_API void
+ellipj (const Complex& u, double m, Complex& sn, Complex& cn, Complex& dn,
+        double& err);
 
 #endif
diff --git a/liboctave/numeric/oct-convn.cc b/liboctave/numeric/oct-convn.cc
--- a/liboctave/numeric/oct-convn.cc
+++ b/liboctave/numeric/oct-convn.cc
@@ -77,23 +77,27 @@ template <class T, class R>
 void convolve_nd (const T *a, const dim_vector& ad, const dim_vector& acd,
                   const R *b, const dim_vector& bd, const dim_vector& bcd,
                   T *c, const dim_vector& ccd, int nd, bool inner)
 {
   if (nd == 2)
     convolve_2d<T, R> (a, ad(0), ad(1), b, bd(0), bd(1), c, inner);
   else
     {
-      octave_idx_type ma = acd(nd-2), na = ad(nd-1), mb = bcd(nd-2), nb = bd(nd-1);
+      octave_idx_type ma = acd(nd-2);
+      octave_idx_type na = ad(nd-1);
+      octave_idx_type mb = bcd(nd-2);
+      octave_idx_type nb = bd(nd-1);
       octave_idx_type ldc = ccd(nd-2);
       if (inner)
         {
           for (octave_idx_type ja = 0; ja < na - nb + 1; ja++)
             for (octave_idx_type jb = 0; jb < nb; jb++)
-              convolve_nd<T, R> (a + ma*(ja+jb), ad, acd, b + mb*(nb-jb-1), bd, bcd,
+              convolve_nd<T, R> (a + ma*(ja+jb), ad, acd,
+                                 b + mb*(nb-jb-1), bd, bcd,
                                  c + ldc*ja, ccd, nd-1, inner);
         }
       else
         {
           for (octave_idx_type ja = 0; ja < na; ja++)
             for (octave_idx_type jb = 0; jb < nb; jb++)
               convolve_nd<T, R> (a + ma*ja, ad, acd, b + mb*jb, bd, bcd,
                                  c + ldc*(ja+jb), ccd, nd-1, inner);
@@ -124,17 +128,18 @@ convolve (const MArray<T>& a, const MArr
         cdims(i) = std::max (adims(i) + bdims(i) - 1,
                              static_cast<octave_idx_type> (0));
     }
 
   MArray<T> c (cdims, T ());
 
   convolve_nd<T, R> (a.fortran_vec (), adims, adims.cumulative (),
                      b.fortran_vec (), bdims, bdims.cumulative (),
-                     c.fortran_vec (), cdims.cumulative (), nd, ct == convn_valid);
+                     c.fortran_vec (), cdims.cumulative (),
+                     nd, ct == convn_valid);
 
   if (ct == convn_same)
     {
       // Pick the relevant part.
       Array<idx_vector> sidx (dim_vector (nd, 1));
 
       for (int i = 0; i < nd; i++)
         sidx(i) = idx_vector::make_range (bdims(i)/2, 1, adims(i));
diff --git a/liboctave/numeric/oct-fftw.cc b/liboctave/numeric/oct-fftw.cc
--- a/liboctave/numeric/oct-fftw.cc
+++ b/liboctave/numeric/oct-fftw.cc
@@ -48,17 +48,17 @@ octave_fftw_planner *octave_fftw_planner
 
 // Also note that if FFTW_ESTIMATE is not used then the planner in FFTW3
 // will destroy the input and output arrays. We must, therefore, create a
 // temporary input array with the same size and 16-byte alignment as
 // the original array when using a different planner strategy.
 // Note that we also use any wisdom that is available, either in a
 // FFTW3 system wide file or as supplied by the user.
 
-// FIXME -- if we can ensure 16 byte alignment in Array<T>
+// FIXME: if we can ensure 16 byte alignment in Array<T>
 // (<T> *data) the FFTW3 can use SIMD instructions for further
 // acceleration.
 
 // Note that it is profitable to store the FFTW3 plans, for small FFTs.
 
 octave_fftw_planner::octave_fftw_planner (void)
   : meth (ESTIMATE), rplan (0), rd (0), rs (0), rr (0), rh (0), rn (),
     rsimd_align (false)
@@ -220,32 +220,34 @@ octave_fftw_planner::do_create_plan (int
       if (*cur_plan_p)
         fftw_destroy_plan (*cur_plan_p);
 
       if (plan_destroys_in)
         {
           // Create matrix with the same size and 16-byte alignment as input
           OCTAVE_LOCAL_BUFFER (Complex, itmp, nn * howmany + 32);
           itmp = reinterpret_cast<Complex *>
-            (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
-             ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
+                 (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
+                  ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
           *cur_plan_p =
             fftw_plan_many_dft (rank, tmp, howmany,
-              reinterpret_cast<fftw_complex *> (itmp),
-              0, stride, dist, reinterpret_cast<fftw_complex *> (out),
-              0, stride, dist, dir, plan_flags);
+                                reinterpret_cast<fftw_complex *> (itmp),
+                                0, stride, dist,
+                                reinterpret_cast<fftw_complex *> (out),
+                                0, stride, dist, dir, plan_flags);
         }
       else
         {
           *cur_plan_p =
             fftw_plan_many_dft (rank, tmp, howmany,
-              reinterpret_cast<fftw_complex *> (const_cast<Complex *> (in)),
-              0, stride, dist, reinterpret_cast<fftw_complex *> (out),
-              0, stride, dist, dir, plan_flags);
+                                reinterpret_cast<fftw_complex *> (const_cast<Complex *> (in)),
+                                0, stride, dist,
+                                reinterpret_cast<fftw_complex *> (out),
+                                0, stride, dist, dir, plan_flags);
         }
 
       if (*cur_plan_p == 0)
         (*current_liboctave_error_handler) ("Error creating fftw plan");
     }
 
   return *cur_plan_p;
 }
@@ -337,31 +339,33 @@ octave_fftw_planner::do_create_plan (con
       if (*cur_plan_p)
         fftw_destroy_plan (*cur_plan_p);
 
       if (plan_destroys_in)
         {
           // Create matrix with the same size and 16-byte alignment as input
           OCTAVE_LOCAL_BUFFER (double, itmp, nn + 32);
           itmp = reinterpret_cast<double *>
-            (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
-             ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
+                 (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
+                  ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
           *cur_plan_p =
             fftw_plan_many_dft_r2c (rank, tmp, howmany, itmp,
-              0, stride, dist, reinterpret_cast<fftw_complex *> (out),
-              0, stride, dist, plan_flags);
+                                    0, stride, dist,
+                                    reinterpret_cast<fftw_complex *> (out),
+                                    0, stride, dist, plan_flags);
         }
       else
         {
           *cur_plan_p =
             fftw_plan_many_dft_r2c (rank, tmp, howmany,
-              (const_cast<double *> (in)),
-              0, stride, dist, reinterpret_cast<fftw_complex *> (out),
-              0, stride, dist, plan_flags);
+                                    (const_cast<double *> (in)),
+                                    0, stride, dist,
+                                    reinterpret_cast<fftw_complex *> (out),
+                                    0, stride, dist, plan_flags);
         }
 
       if (*cur_plan_p == 0)
         (*current_liboctave_error_handler) ("Error creating fftw plan");
     }
 
   return *cur_plan_p;
 }
@@ -558,32 +562,34 @@ octave_float_fftw_planner::do_create_pla
       if (*cur_plan_p)
         fftwf_destroy_plan (*cur_plan_p);
 
       if (plan_destroys_in)
         {
           // Create matrix with the same size and 16-byte alignment as input
           OCTAVE_LOCAL_BUFFER (FloatComplex, itmp, nn * howmany + 32);
           itmp = reinterpret_cast<FloatComplex *>
-            (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
-             ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
+                 (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
+                  ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
           *cur_plan_p =
             fftwf_plan_many_dft (rank, tmp, howmany,
-              reinterpret_cast<fftwf_complex *> (itmp),
-              0, stride, dist, reinterpret_cast<fftwf_complex *> (out),
-              0, stride, dist, dir, plan_flags);
+                                 reinterpret_cast<fftwf_complex *> (itmp),
+                                 0, stride, dist,
+                                 reinterpret_cast<fftwf_complex *> (out),
+                                 0, stride, dist, dir, plan_flags);
         }
       else
         {
           *cur_plan_p =
             fftwf_plan_many_dft (rank, tmp, howmany,
-              reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *> (in)),
-              0, stride, dist, reinterpret_cast<fftwf_complex *> (out),
-              0, stride, dist, dir, plan_flags);
+                                 reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *> (in)),
+                                 0, stride, dist,
+                                 reinterpret_cast<fftwf_complex *> (out),
+                                 0, stride, dist, dir, plan_flags);
         }
 
       if (*cur_plan_p == 0)
         (*current_liboctave_error_handler) ("Error creating fftw plan");
     }
 
   return *cur_plan_p;
 }
@@ -676,31 +682,33 @@ octave_float_fftw_planner::do_create_pla
       if (*cur_plan_p)
         fftwf_destroy_plan (*cur_plan_p);
 
       if (plan_destroys_in)
         {
           // Create matrix with the same size and 16-byte alignment as input
           OCTAVE_LOCAL_BUFFER (float, itmp, nn + 32);
           itmp = reinterpret_cast<float *>
-            (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
-             ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
+                 (((reinterpret_cast<ptrdiff_t>(itmp) + 15) & ~ 0xF) +
+                  ((reinterpret_cast<ptrdiff_t> (in)) & 0xF));
 
           *cur_plan_p =
             fftwf_plan_many_dft_r2c (rank, tmp, howmany, itmp,
-              0, stride, dist, reinterpret_cast<fftwf_complex *> (out),
-              0, stride, dist, plan_flags);
+                                     0, stride, dist,
+                                     reinterpret_cast<fftwf_complex *> (out),
+                                     0, stride, dist, plan_flags);
         }
       else
         {
           *cur_plan_p =
             fftwf_plan_many_dft_r2c (rank, tmp, howmany,
-              (const_cast<float *> (in)),
-              0, stride, dist, reinterpret_cast<fftwf_complex *> (out),
-              0, stride, dist, plan_flags);
+                                     (const_cast<float *> (in)),
+                                     0, stride, dist,
+                                     reinterpret_cast<fftwf_complex *> (out),
+                                     0, stride, dist, plan_flags);
         }
 
       if (*cur_plan_p == 0)
         (*current_liboctave_error_handler) ("Error creating fftw plan");
     }
 
   return *cur_plan_p;
 }
@@ -821,17 +829,17 @@ octave_fftw::fft (const double *in, Comp
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts, 1);
   fftw_plan plan = octave_fftw_planner::create_plan (1, dv, nsamples,
                                                      stride, dist, in, out);
 
   fftw_execute_dft_r2c (plan, (const_cast<double *>(in)),
-                         reinterpret_cast<fftw_complex *> (out));
+                        reinterpret_cast<fftw_complex *> (out));
 
   // Need to create other half of the transform.
 
   convert_packcomplex_1d (out, nsamples, npts, stride, dist);
 
   return 0;
 }
 
@@ -842,36 +850,37 @@ octave_fftw::fft (const Complex *in, Com
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts, 1);
   fftw_plan plan = octave_fftw_planner::create_plan (FFTW_FORWARD, 1, dv,
                                                      nsamples, stride,
                                                      dist, in, out);
 
   fftw_execute_dft (plan,
-        reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
-        reinterpret_cast<fftw_complex *> (out));
+                    reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
+                    reinterpret_cast<fftw_complex *> (out));
 
   return 0;
 }
 
 int
 octave_fftw::ifft (const Complex *in, Complex *out, size_t npts,
-                   size_t nsamples, octave_idx_type stride, octave_idx_type dist)
+                   size_t nsamples, octave_idx_type stride,
+                   octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts, 1);
   fftw_plan plan = octave_fftw_planner::create_plan (FFTW_BACKWARD, 1, dv,
                                                      nsamples, stride,
                                                      dist, in, out);
 
   fftw_execute_dft (plan,
-        reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
-        reinterpret_cast<fftw_complex *> (out));
+                    reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
+                    reinterpret_cast<fftw_complex *> (out));
 
   const Complex scale = npts;
   for (size_t j = 0; j < nsamples; j++)
     for (size_t i = 0; i < npts; i++)
       out[i*stride + j*dist] /= scale;
 
   return 0;
 }
@@ -909,36 +918,36 @@ octave_fftw::fftNd (const Complex *in, C
   octave_idx_type dist = 1;
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   fftw_plan plan = octave_fftw_planner::create_plan (FFTW_FORWARD, rank,
                                                      dv, 1, 1, dist, in, out);
 
   fftw_execute_dft (plan,
-        reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
-        reinterpret_cast<fftw_complex *> (out));
+                    reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
+                    reinterpret_cast<fftw_complex *> (out));
 
   return 0;
 }
 
 int
 octave_fftw::ifftNd (const Complex *in, Complex *out, const int rank,
                      const dim_vector &dv)
 {
   octave_idx_type dist = 1;
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   fftw_plan plan = octave_fftw_planner::create_plan (FFTW_BACKWARD, rank,
                                                      dv, 1, 1, dist, in, out);
 
   fftw_execute_dft (plan,
-        reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
-        reinterpret_cast<fftw_complex *> (out));
+                    reinterpret_cast<fftw_complex *> (const_cast<Complex *>(in)),
+                    reinterpret_cast<fftw_complex *> (out));
 
   const size_t npts = dv.numel ();
   const Complex scale = npts;
   for (size_t i = 0; i < npts; i++)
     out[i] /= scale;
 
   return 0;
 }
@@ -950,17 +959,17 @@ octave_fftw::fft (const float *in, Float
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts, 1);
   fftwf_plan plan = octave_float_fftw_planner::create_plan (1, dv, nsamples,
                                                             stride, dist,
                                                             in, out);
 
   fftwf_execute_dft_r2c (plan, (const_cast<float *>(in)),
-                        reinterpret_cast<fftwf_complex *> (out));
+                         reinterpret_cast<fftwf_complex *> (out));
 
   // Need to create other half of the transform.
 
   convert_packcomplex_1d (out, nsamples, npts, stride, dist);
 
   return 0;
 }
 
@@ -972,37 +981,38 @@ octave_fftw::fft (const FloatComplex *in
 
   dim_vector dv (npts, 1);
   fftwf_plan plan = octave_float_fftw_planner::create_plan (FFTW_FORWARD, 1,
                                                             dv, nsamples,
                                                             stride, dist,
                                                             in, out);
 
   fftwf_execute_dft (plan,
-        reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
-        reinterpret_cast<fftwf_complex *> (out));
+                     reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
+                     reinterpret_cast<fftwf_complex *> (out));
 
   return 0;
 }
 
 int
 octave_fftw::ifft (const FloatComplex *in, FloatComplex *out, size_t npts,
-                   size_t nsamples, octave_idx_type stride, octave_idx_type dist)
+                   size_t nsamples, octave_idx_type stride,
+                   octave_idx_type dist)
 {
   dist = (dist < 0 ? npts : dist);
 
   dim_vector dv (npts, 1);
   fftwf_plan plan = octave_float_fftw_planner::create_plan (FFTW_BACKWARD, 1,
                                                             dv, nsamples,
                                                             stride, dist,
                                                             in, out);
 
   fftwf_execute_dft (plan,
-        reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
-        reinterpret_cast<fftwf_complex *> (out));
+                     reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
+                     reinterpret_cast<fftwf_complex *> (out));
 
   const FloatComplex scale = npts;
   for (size_t j = 0; j < nsamples; j++)
     for (size_t i = 0; i < npts; i++)
       out[i*stride + j*dist] /= scale;
 
   return 0;
 }
@@ -1020,17 +1030,17 @@ octave_fftw::fftNd (const float *in, Flo
 
   octave_idx_type offset = (dv.numel () / dv(0)) * ((dv(0) - 1) / 2);
 
   fftwf_plan plan = octave_float_fftw_planner::create_plan (rank, dv, 1, 1,
                                                             dist, in,
                                                             out + offset);
 
   fftwf_execute_dft_r2c (plan, (const_cast<float *>(in)),
-                        reinterpret_cast<fftwf_complex *> (out+ offset));
+                         reinterpret_cast<fftwf_complex *> (out+ offset));
 
   // Need to create other half of the transform.
 
   convert_packcomplex_Nd (out, dv);
 
   return 0;
 }
 
@@ -1042,18 +1052,18 @@ octave_fftw::fftNd (const FloatComplex *
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   fftwf_plan plan = octave_float_fftw_planner::create_plan (FFTW_FORWARD,
                                                             rank, dv, 1, 1,
                                                             dist, in, out);
 
   fftwf_execute_dft (plan,
-        reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
-        reinterpret_cast<fftwf_complex *> (out));
+                     reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
+                     reinterpret_cast<fftwf_complex *> (out));
 
   return 0;
 }
 
 int
 octave_fftw::ifftNd (const FloatComplex *in, FloatComplex *out, const int rank,
                      const dim_vector &dv)
 {
@@ -1061,18 +1071,18 @@ octave_fftw::ifftNd (const FloatComplex 
   for (int i = 0; i < rank; i++)
     dist *= dv(i);
 
   fftwf_plan plan = octave_float_fftw_planner::create_plan (FFTW_BACKWARD,
                                                             rank, dv, 1, 1,
                                                             dist, in, out);
 
   fftwf_execute_dft (plan,
-        reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
-        reinterpret_cast<fftwf_complex *> (out));
+                     reinterpret_cast<fftwf_complex *> (const_cast<FloatComplex *>(in)),
+                     reinterpret_cast<fftwf_complex *> (out));
 
   const size_t npts = dv.numel ();
   const FloatComplex scale = npts;
   for (size_t i = 0; i < npts; i++)
     out[i] /= scale;
 
   return 0;
 }
diff --git a/liboctave/numeric/oct-fftw.h b/liboctave/numeric/oct-fftw.h
--- a/liboctave/numeric/oct-fftw.h
+++ b/liboctave/numeric/oct-fftw.h
@@ -62,31 +62,32 @@ public:
   create_plan (int dir, const int rank, const dim_vector dims,
                octave_idx_type howmany, octave_idx_type stride,
                octave_idx_type dist, const Complex *in,
                Complex *out)
   {
     static fftw_plan dummy;
 
     return instance_ok ()
-      ? instance->do_create_plan (dir, rank, dims, howmany, stride,
-                                  dist, in, out)
-      : dummy;
+           ? instance->do_create_plan (dir, rank, dims, howmany, stride,
+                                       dist, in, out)
+           : dummy;
   }
 
   static fftw_plan
   create_plan (const int rank, const dim_vector dims,
                octave_idx_type howmany, octave_idx_type stride,
                octave_idx_type dist, const double *in, Complex *out)
   {
     static fftw_plan dummy;
 
     return instance_ok ()
-      ? instance->do_create_plan (rank, dims, howmany, stride, dist, in, out)
-      : dummy;
+           ? instance->do_create_plan (rank, dims, howmany, stride, dist,
+                                       in, out)
+           : dummy;
   }
 
   static FftwMethod method (void)
   {
     static FftwMethod dummy;
 
     return instance_ok () ? instance->do_method () : dummy;
   }
@@ -140,17 +141,17 @@ private:
                   octave_idx_type dist, const double *in, Complex *out);
 
   FftwMethod do_method (void);
 
   FftwMethod do_method (FftwMethod _meth);
 
   FftwMethod meth;
 
-  // FIXME -- perhaps this should be split into two classes?
+  // FIXME: perhaps this should be split into two classes?
 
   // Plan for fft and ifft of complex values
   fftw_plan plan[2];
 
   // dist
   octave_idx_type d[2];
 
   // stride
@@ -222,31 +223,32 @@ public:
   create_plan (int dir, const int rank, const dim_vector dims,
                octave_idx_type howmany, octave_idx_type stride,
                octave_idx_type dist, const FloatComplex *in,
                FloatComplex *out)
   {
     static fftwf_plan dummy;
 
     return instance_ok ()
-      ? instance->do_create_plan (dir, rank, dims, howmany, stride,
-                                  dist, in, out)
-      : dummy;
+           ? instance->do_create_plan (dir, rank, dims, howmany, stride,
+                                       dist, in, out)
+           : dummy;
   }
 
   static fftwf_plan
   create_plan (const int rank, const dim_vector dims,
                octave_idx_type howmany, octave_idx_type stride,
                octave_idx_type dist, const float *in, FloatComplex *out)
   {
     static fftwf_plan dummy;
 
     return instance_ok ()
-      ? instance->do_create_plan (rank, dims, howmany, stride, dist, in, out)
-      : dummy;
+           ? instance->do_create_plan (rank, dims, howmany, stride, dist,
+                                       in, out)
+           : dummy;
   }
 
   static FftwMethod method (void)
   {
     static FftwMethod dummy;
 
     return instance_ok () ? instance->do_method () : dummy;
   }
@@ -300,17 +302,17 @@ private:
                   octave_idx_type dist, const float *in, FloatComplex *out);
 
   FftwMethod do_method (void);
 
   FftwMethod do_method (FftwMethod _meth);
 
   FftwMethod meth;
 
-  // FIXME -- perhaps this should be split into two classes?
+  // FIXME: perhaps this should be split into two classes?
 
   // Plan for fft and ifft of complex values
   fftwf_plan plan[2];
 
   // dist
   octave_idx_type d[2];
 
   // stride
@@ -356,34 +358,40 @@ private:
 
 class
 OCTAVE_API
 octave_fftw
 {
 public:
 
   static int fft (const double *in, Complex *out, size_t npts,
-                  size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
+                  size_t nsamples = 1, octave_idx_type stride = 1,
+                  octave_idx_type dist = -1);
   static int fft (const Complex *in, Complex *out, size_t npts,
-                  size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
+                  size_t nsamples = 1, octave_idx_type stride = 1,
+                  octave_idx_type dist = -1);
   static int ifft (const Complex *in, Complex *out, size_t npts,
-                   size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
+                   size_t nsamples = 1, octave_idx_type stride = 1,
+                   octave_idx_type dist = -1);
 
   static int fftNd (const double*, Complex*, const int, const dim_vector &);
   static int fftNd (const Complex*, Complex*, const int,
                     const dim_vector &);
   static int ifftNd (const Complex*, Complex*, const int,
                      const dim_vector &);
 
   static int fft (const float *in, FloatComplex *out, size_t npts,
-                  size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
+                  size_t nsamples = 1, octave_idx_type stride = 1,
+                  octave_idx_type dist = -1);
   static int fft (const FloatComplex *in, FloatComplex *out, size_t npts,
-                  size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
+                  size_t nsamples = 1, octave_idx_type stride = 1,
+                  octave_idx_type dist = -1);
   static int ifft (const FloatComplex *in, FloatComplex *out, size_t npts,
-                   size_t nsamples = 1, octave_idx_type stride = 1, octave_idx_type dist = -1);
+                   size_t nsamples = 1, octave_idx_type stride = 1,
+                   octave_idx_type dist = -1);
 
   static int fftNd (const float*, FloatComplex*, const int, const dim_vector &);
   static int fftNd (const FloatComplex*, FloatComplex*, const int,
                     const dim_vector &);
   static int ifftNd (const FloatComplex*, FloatComplex*, const int,
                      const dim_vector &);
 
 private:
diff --git a/liboctave/numeric/oct-norm.cc b/liboctave/numeric/oct-norm.cc
--- a/liboctave/numeric/oct-norm.cc
+++ b/liboctave/numeric/oct-norm.cc
@@ -336,19 +336,19 @@ higham_subp (const ColVectorT& y, const 
         {
           lambda = lambda1;
           mu = mu1;
           nrm = nrm1;
         }
     }
 }
 
-// Complex version. Higham's paper does not deal with complex case, so we use a simple
-// extension. First, guess the magnitudes as in real version, then try to rotate lambda
-// to improve further.
+// Complex version. Higham's paper does not deal with complex case, so we use a
+// simple extension. First, guess the magnitudes as in real version, then try
+// to rotate lambda to improve further.
 template <class ColVectorT, class R>
 static void
 higham_subp (const ColVectorT& y, const ColVectorT& col,
              octave_idx_type nsamp, R p,
              std::complex<R>& lambda, std::complex<R>& mu)
 {
   typedef std::complex<R> CR;
   R nrm = 0;
@@ -455,18 +455,19 @@ R higham (const MatrixT& m, R p, R tol, 
 
   return gamma;
 }
 
 // derive column vector and SVD types
 
 static const char *p_less1_gripe = "xnorm: p must be at least 1";
 
-// Static constant to control the maximum number of iterations. 100 seems to be a good value.
-// Eventually, we can provide a means to change this constant from Octave.
+// Static constant to control the maximum number of iterations.  100 seems to
+// be a good value.  Eventually, we can provide a means to change this
+// constant from Octave.
 static int max_norm_iter = 100;
 
 // version with SVD for dense matrices
 template <class MatrixT, class VectorT, class SVDT, class R>
 R matrix_norm (const MatrixT& m, R p, VectorT, SVDT)
 {
   R res = 0;
   if (p == 2)
diff --git a/liboctave/numeric/oct-rand.cc b/liboctave/numeric/oct-rand.cc
--- a/liboctave/numeric/oct-rand.cc
+++ b/liboctave/numeric/oct-rand.cc
@@ -777,17 +777,17 @@ octave_rand::fill (octave_idx_type len, 
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               double tmp;
               F77_FUNC (dignpoi, DIGNPOI) (a + 1, tmp);
 #define RAND_FUNC(x) F77_FUNC (dignpoi, DIGNPOI) (a, x)
-                MAKE_RAND (len);
+              MAKE_RAND (len);
 #undef RAND_FUNC
             }
         }
       else
         oct_fill_randp (a, len, v);
       break;
 
     case gamma_dist:
@@ -867,17 +867,17 @@ octave_rand::fill (octave_idx_type len, 
             MAKE_RAND (len);
 #undef RAND_FUNC
           else
             {
               // workaround bug in ignpoi, by calling with different Mu
               double tmp;
               F77_FUNC (dignpoi, DIGNPOI) (da + 1, tmp);
 #define RAND_FUNC(x) F77_FUNC (dignpoi, DIGNPOI) (da, x)
-                MAKE_RAND (len);
+              MAKE_RAND (len);
 #undef RAND_FUNC
             }
         }
       else
         oct_fill_float_randp (a, len, v);
       break;
 
     case gamma_dist:
diff --git a/liboctave/numeric/oct-rand.h b/liboctave/numeric/oct-rand.h
--- a/liboctave/numeric/oct-rand.h
+++ b/liboctave/numeric/oct-rand.h
@@ -139,39 +139,40 @@ public:
   // Return the next number from the sequence.
   static float float_scalar (float a = 1.0)
   {
     return instance_ok () ? instance->do_float_scalar (a) : octave_Float_NaN;
   }
 
   // Return an array of numbers from the sequence.
   static Array<double> vector (octave_idx_type n, double a = 1.0)
-   {
-     return instance_ok () ? instance->do_vector (n, a) : Array<double> ();
-   }
+  {
+    return instance_ok () ? instance->do_vector (n, a) : Array<double> ();
+  }
 
   // Return an array of numbers from the sequence.
   static Array<float> float_vector (octave_idx_type n, float a = 1.0)
-   {
-     return instance_ok () ? instance->do_float_vector (n, a) : Array<float> ();
-   }
+  {
+    return instance_ok () ? instance->do_float_vector (n, a) : Array<float> ();
+  }
 
   // Return an N-dimensional array of numbers from the sequence,
   // filled in column major order.
   static NDArray nd_array (const dim_vector& dims, double a = 1.0)
   {
     return instance_ok () ? instance->do_nd_array (dims, a) : NDArray ();
   }
 
 
   // Return an N-dimensional array of numbers from the sequence,
   // filled in column major order.
   static FloatNDArray float_nd_array (const dim_vector& dims, float a = 1.0)
   {
-    return instance_ok () ? instance->do_float_nd_array (dims, a) : FloatNDArray ();
+    return instance_ok () ? instance->do_float_nd_array (dims, a)
+                          : FloatNDArray ();
   }
 
 private:
 
   static octave_rand *instance;
 
   static void cleanup_instance (void) { delete instance; instance = 0; }
 
diff --git a/liboctave/numeric/randgamma.c b/liboctave/numeric/randgamma.c
--- a/liboctave/numeric/randgamma.c
+++ b/liboctave/numeric/randgamma.c
@@ -122,17 +122,18 @@ oct_fill_randg (double a, octave_idx_typ
         goto restart; /* rare, so don't bother moving up */
       u = RUNI;
       xsq = x*x;
       if (u >= 1.-0.0331*xsq*xsq && log (u) >= 0.5*xsq + d*(1-v+log (v)))
         goto restart;
       r[i] = d*v;
     }
   if (a < 1)
-    { /* Use gamma(a) = gamma(1+a)*U^(1/a) */
+    {
+      /* Use gamma(a) = gamma(1+a)*U^(1/a) */
       /* Given REXP = -log(U) then U^(1/a) = exp(-REXP/a) */
       for (i = 0; i < n; i++)
         r[i] *= exp (-REXP/a);
     }
 }
 
 double
 oct_randg (double a)
@@ -178,17 +179,18 @@ oct_fill_float_randg (float a, octave_id
         goto frestart; /* rare, so don't bother moving up */
       u = RUNI;
       xsq = x*x;
       if (u >= 1.-0.0331*xsq*xsq && log (u) >= 0.5*xsq + d*(1-v+log (v)))
         goto frestart;
       r[i] = d*v;
     }
   if (a < 1)
-    { /* Use gamma(a) = gamma(1+a)*U^(1/a) */
+    {
+      /* Use gamma(a) = gamma(1+a)*U^(1/a) */
       /* Given REXP = -log(U) then U^(1/a) = exp(-REXP/a) */
       for (i = 0; i < n; i++)
         r[i] *= exp (-REXP/a);
     }
 }
 
 float
 oct_float_randg (float a)
diff --git a/liboctave/numeric/randgamma.h b/liboctave/numeric/randgamma.h
--- a/liboctave/numeric/randgamma.h
+++ b/liboctave/numeric/randgamma.h
@@ -28,14 +28,15 @@ along with Octave; see the file COPYING.
 #ifdef  __cplusplus
 extern "C" {
 #endif
 
 extern OCTAVE_API double oct_randg (double a);
 extern OCTAVE_API void oct_fill_randg (double a, octave_idx_type n, double *p);
 
 extern OCTAVE_API float oct_float_randg (float a);
-extern OCTAVE_API void oct_fill_float_randg (float a, octave_idx_type n, float *p);
+extern OCTAVE_API void oct_fill_float_randg (float a, octave_idx_type n,
+                                             float *p);
 
 #ifdef  __cplusplus
 }
 #endif
 #endif
diff --git a/liboctave/numeric/randmtzig.c b/liboctave/numeric/randmtzig.c
--- a/liboctave/numeric/randmtzig.c
+++ b/liboctave/numeric/randmtzig.c
@@ -190,60 +190,61 @@ static int left = 1;
 static int initf = 0;
 static int initt = 1;
 static int inittf = 1;
 
 /* initializes state[MT_N] with a seed */
 void
 oct_init_by_int (uint32_t s)
 {
-    int j;
-    state[0] = s & 0xffffffffUL;
-    for (j = 1; j < MT_N; j++) {
-        state[j] = (1812433253UL * (state[j-1] ^ (state[j-1] >> 30)) + j);
-        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
-        /* In the previous versions, MSBs of the seed affect   */
-        /* only MSBs of the array state[].                        */
-        /* 2002/01/09 modified by Makoto Matsumoto             */
-        state[j] &= 0xffffffffUL;  /* for >32 bit machines */
+  int j;
+  state[0] = s & 0xffffffffUL;
+  for (j = 1; j < MT_N; j++)
+    {
+      state[j] = (1812433253UL * (state[j-1] ^ (state[j-1] >> 30)) + j);
+      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
+      /* In the previous versions, MSBs of the seed affect   */
+      /* only MSBs of the array state[].                        */
+      /* 2002/01/09 modified by Makoto Matsumoto             */
+      state[j] &= 0xffffffffUL;  /* for >32 bit machines */
     }
-    left = 1;
-    initf = 1;
+  left = 1;
+  initf = 1;
 }
 
 /* initialize by an array with array-length */
 /* init_key is the array for initializing keys */
 /* key_length is its length */
 void
 oct_init_by_array (uint32_t *init_key, int key_length)
 {
   int i, j, k;
   oct_init_by_int (19650218UL);
   i = 1;
   j = 0;
   k = (MT_N > key_length ? MT_N : key_length);
   for (; k; k--)
     {
       state[i] = (state[i] ^ ((state[i-1] ^ (state[i-1] >> 30)) * 1664525UL))
-        + init_key[j] + j; /* non linear */
+                 + init_key[j] + j; /* non linear */
       state[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
       i++;
       j++;
       if (i >= MT_N)
         {
           state[0] = state[MT_N-1];
           i = 1;
         }
       if (j >= key_length)
         j = 0;
     }
   for (k = MT_N - 1; k; k--)
     {
       state[i] = (state[i] ^ ((state[i-1] ^ (state[i-1] >> 30)) * 1566083941UL))
-        - i; /* non linear */
+                 - i; /* non linear */
       state[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
       i++;
       if (i >= MT_N)
         {
           state[0] = state[MT_N-1];
           i = 1;
         }
     }
@@ -251,48 +252,48 @@ oct_init_by_array (uint32_t *init_key, i
   state[0] = 0x80000000UL; /* MSB is 1; assuring non-zero initial array */
   left = 1;
   initf = 1;
 }
 
 void
 oct_init_by_entropy (void)
 {
-    uint32_t entropy[MT_N];
-    int n = 0;
+  uint32_t entropy[MT_N];
+  int n = 0;
 
-    /* Look for entropy in /dev/urandom */
-    FILE* urandom = fopen ("/dev/urandom", "rb");
-    if (urandom)
-      {
-        while (n < MT_N)
-          {
-            unsigned char word[4];
-            if (fread (word, 4, 1, urandom) != 1)
-              break;
-            entropy[n++] = word[0]+(word[1]<<8)+(word[2]<<16)+((uint32_t)word[3]<<24);
-          }
-        fclose (urandom);
-      }
+  /* Look for entropy in /dev/urandom */
+  FILE* urandom = fopen ("/dev/urandom", "rb");
+  if (urandom)
+    {
+      while (n < MT_N)
+        {
+          unsigned char word[4];
+          if (fread (word, 4, 1, urandom) != 1)
+            break;
+          entropy[n++] = word[0]+(word[1]<<8)+(word[2]<<16)+((uint32_t)word[3]<<24);
+        }
+      fclose (urandom);
+    }
 
-    /* If there isn't enough entropy, gather some from various sources */
-    if (n < MT_N)
-      entropy[n++] = time (NULL); /* Current time in seconds */
-    if (n < MT_N)
-      entropy[n++] = clock ();    /* CPU time used (usec) */
+  /* If there isn't enough entropy, gather some from various sources */
+  if (n < MT_N)
+    entropy[n++] = time (NULL); /* Current time in seconds */
+  if (n < MT_N)
+    entropy[n++] = clock ();    /* CPU time used (usec) */
 #ifdef HAVE_GETTIMEOFDAY
-    if (n < MT_N)
-      {
-        struct timeval tv;
-        if (gettimeofday (&tv, NULL) != -1)
-          entropy[n++] = tv.tv_usec;   /* Fractional part of current time */
-      }
+  if (n < MT_N)
+    {
+      struct timeval tv;
+      if (gettimeofday (&tv, NULL) != -1)
+        entropy[n++] = tv.tv_usec;   /* Fractional part of current time */
+    }
 #endif
-    /* Send all the entropy into the initial state vector */
-    oct_init_by_array (entropy,n);
+  /* Send all the entropy into the initial state vector */
+  oct_init_by_array (entropy,n);
 }
 
 void
 oct_set_state (uint32_t *save)
 {
   int i;
   for (i = 0; i < MT_N; i++)
     state[i] = save[i];
diff --git a/liboctave/numeric/randpoisson.c b/liboctave/numeric/randpoisson.c
--- a/liboctave/numeric/randpoisson.c
+++ b/liboctave/numeric/randpoisson.c
@@ -75,23 +75,24 @@ xlgamma (double x)
 }
 
 /* ---- pprsc.c from Stadloeber's winrand --- */
 
 /* flogfak(k) = ln(k!) */
 static double
 flogfak (double k)
 {
-#define       C0      9.18938533204672742e-01
-#define       C1      8.33333333333333333e-02
-#define       C3     -2.77777777777777778e-03
-#define       C5      7.93650793650793651e-04
-#define       C7     -5.95238095238095238e-04
+#define C0  9.18938533204672742e-01
+#define C1  8.33333333333333333e-02
+#define C3 -2.77777777777777778e-03
+#define C5  7.93650793650793651e-04
+#define C7 -5.95238095238095238e-04
 
-  static double logfak[30L] = {
+  static double logfak[30L] =
+  {
     0.00000000000000000,   0.00000000000000000,   0.69314718055994531,
     1.79175946922805500,   3.17805383034794562,   4.78749174278204599,
     6.57925121201010100,   8.52516136106541430,  10.60460290274525023,
     12.80182748008146961,  15.10441257307551530,  17.50230784587388584,
     19.98721449566188615,  22.55216385312342289,  25.19122118273868150,
     27.89927138384089157,  30.67186010608067280,  33.50507345013688888,
     36.39544520803305358,  39.33988418719949404,  42.33561646075348503,
     45.38013889847690803,  48.47118135183522388,  51.60667556776437357,
@@ -147,22 +148,22 @@ static double
 f (double k, double l_nu, double c_pm)
 {
   return exp (k * l_nu - flogfak (k) - c_pm);
 }
 
 static double
 pprsc (double my)
 {
-  static double        my_last = -1.0;
-  static double        m,  k2, k4, k1, k5;
-  static double        dl, dr, r1, r2, r4, r5, ll, lr, l_my, c_pm,
-    f1, f2, f4, f5, p1, p2, p3, p4, p5, p6;
-  double               Dk, X, Y;
-  double               Ds, U, V, W;
+  static double my_last = -1.0;
+  static double m,  k2, k4, k1, k5;
+  static double dl, dr, r1, r2, r4, r5, ll, lr, l_my, c_pm,
+                f1, f2, f4, f5, p1, p2, p3, p4, p5, p6;
+  double        Dk, X, Y;
+  double        Ds, U, V, W;
 
   if (my != my_last)
     {                               /* set-up           */
       my_last = my;
       /* approximate deviation of reflection points k2, k4 from my - 1/2 */
       Ds = sqrt (my + 0.25);
 
       /* mode m, reflection points k2 and k4, and points k1 and k5,      */
@@ -317,146 +318,157 @@ poisson_cdf_lookup (double lambda, doubl
   /* Precompute the table for the u up to and including 0.458.
    * We will almost certainly need it. */
   int intlambda = (int)floor (lambda);
   double P;
   int tableidx;
   size_t i = n;
 
   t[0] = P = exp (-lambda);
-  for (tableidx = 1; tableidx <= intlambda; tableidx++) {
-    P = P*lambda/(double)tableidx;
-    t[tableidx] = t[tableidx-1] + P;
-  }
-
-  while (i-- > 0) {
-    double u = RUNI;
-
-    /* If u > 0.458 we know we can jump to floor(lambda) before
-     * comparing (this observation is based on Stadlober's winrand
-     * code). For lambda >= 1, this will be a win.  Lambda < 1
-     * is already fast, so adding an extra comparison is not a
-     * problem. */
-    int k = (u > 0.458 ? intlambda : 0);
-
-    /* We aren't using a for loop here because when we find the
-     * right k we want to jump to the next iteration of the
-     * outer loop, and the continue statement will only work for
-     * the inner loop. */
-  nextk:
-    if ( u <= t[k] ) {
-      p[i] = (double) k;
-      continue;
-    }
-    if (++k < tableidx) goto nextk;
-
-    /* We only need high values of the table very rarely so we
-     * don't automatically compute the entire table. */
-    while (tableidx < TABLESIZE) {
+  for (tableidx = 1; tableidx <= intlambda; tableidx++)
+    {
       P = P*lambda/(double)tableidx;
       t[tableidx] = t[tableidx-1] + P;
-      /* Make sure we converge to 1.0 just in case u is uniform
-       * on [0,1] rather than [0,1). */
-      if (t[tableidx] == t[tableidx-1]) t[tableidx] = 1.0;
-      tableidx++;
-      if (u <= t[tableidx-1]) break;
     }
 
-    /* We are assuming that the table size is big enough here.
-     * This should be true even if RUNI is returning values in
-     * the range [0,1] rather than [0,1).
-     */
-    p[i] = (double)(tableidx-1);
-  }
+  while (i-- > 0)
+    {
+      double u = RUNI;
+
+      /* If u > 0.458 we know we can jump to floor(lambda) before
+       * comparing (this observation is based on Stadlober's winrand
+       * code). For lambda >= 1, this will be a win.  Lambda < 1
+       * is already fast, so adding an extra comparison is not a
+       * problem. */
+      int k = (u > 0.458 ? intlambda : 0);
+
+      /* We aren't using a for loop here because when we find the
+       * right k we want to jump to the next iteration of the
+       * outer loop, and the continue statement will only work for
+       * the inner loop. */
+    nextk:
+      if (u <= t[k])
+        {
+          p[i] = (double) k;
+          continue;
+        }
+      if (++k < tableidx) goto nextk;
+
+      /* We only need high values of the table very rarely so we
+       * don't automatically compute the entire table. */
+      while (tableidx < TABLESIZE)
+        {
+          P = P*lambda/(double)tableidx;
+          t[tableidx] = t[tableidx-1] + P;
+          /* Make sure we converge to 1.0 just in case u is uniform
+           * on [0,1] rather than [0,1). */
+          if (t[tableidx] == t[tableidx-1]) t[tableidx] = 1.0;
+          tableidx++;
+          if (u <= t[tableidx-1]) break;
+        }
+
+      /* We are assuming that the table size is big enough here.
+       * This should be true even if RUNI is returning values in
+       * the range [0,1] rather than [0,1). */
+      p[i] = (double)(tableidx-1);
+    }
 }
 
 static void
 poisson_cdf_lookup_float (double lambda, float *p, size_t n)
 {
   double t[TABLESIZE];
 
   /* Precompute the table for the u up to and including 0.458.
    * We will almost certainly need it. */
   int intlambda = (int)floor (lambda);
   double P;
   int tableidx;
   size_t i = n;
 
   t[0] = P = exp (-lambda);
-  for (tableidx = 1; tableidx <= intlambda; tableidx++) {
-    P = P*lambda/(double)tableidx;
-    t[tableidx] = t[tableidx-1] + P;
-  }
-
-  while (i-- > 0) {
-    double u = RUNI;
-    int k = (u > 0.458 ? intlambda : 0);
-  nextk:
-    if ( u <= t[k] ) {
-      p[i] = (float) k;
-      continue;
-    }
-    if (++k < tableidx) goto nextk;
-
-    while (tableidx < TABLESIZE) {
+  for (tableidx = 1; tableidx <= intlambda; tableidx++)
+    {
       P = P*lambda/(double)tableidx;
       t[tableidx] = t[tableidx-1] + P;
-      if (t[tableidx] == t[tableidx-1]) t[tableidx] = 1.0;
-      tableidx++;
-      if (u <= t[tableidx-1]) break;
     }
 
-    p[i] = (float)(tableidx-1);
-  }
+  while (i-- > 0)
+    {
+      double u = RUNI;
+      int k = (u > 0.458 ? intlambda : 0);
+    nextk:
+      if (u <= t[k])
+        {
+          p[i] = (float) k;
+          continue;
+        }
+      if (++k < tableidx) goto nextk;
+
+      while (tableidx < TABLESIZE)
+        {
+          P = P*lambda/(double)tableidx;
+          t[tableidx] = t[tableidx-1] + P;
+          if (t[tableidx] == t[tableidx-1]) t[tableidx] = 1.0;
+          tableidx++;
+          if (u <= t[tableidx-1]) break;
+        }
+
+      p[i] = (float)(tableidx-1);
+    }
 }
 
 /* From Press, et al., Numerical Recipes */
 static void
 poisson_rejection (double lambda, double *p, size_t n)
 {
   double sq = sqrt (2.0*lambda);
   double alxm = log (lambda);
   double g = lambda*alxm - LGAMMA(lambda+1.0);
   size_t i;
 
   for (i = 0; i < n; i++)
     {
       double y, em, t;
-      do {
-        do {
-          y = tan (M_PI*RUNI);
-          em = sq * y + lambda;
-        } while (em < 0.0);
-        em = floor (em);
-        t = 0.9*(1.0+y*y)*exp (em*alxm-flogfak (em)-g);
-      } while (RUNI > t);
+      do
+        {
+          do
+            {
+              y = tan (M_PI*RUNI);
+              em = sq * y + lambda;
+            } while (em < 0.0);
+          em = floor (em);
+          t = 0.9*(1.0+y*y)*exp (em*alxm-flogfak (em)-g);
+        } while (RUNI > t);
       p[i] = em;
     }
 }
 
 /* From Press, et al., Numerical Recipes */
 static void
 poisson_rejection_float (double lambda, float *p, size_t n)
 {
   double sq = sqrt (2.0*lambda);
   double alxm = log (lambda);
   double g = lambda*alxm - LGAMMA(lambda+1.0);
   size_t i;
 
   for (i = 0; i < n; i++)
     {
       double y, em, t;
-      do {
-        do {
-          y = tan (M_PI*RUNI);
-          em = sq * y + lambda;
-        } while (em < 0.0);
-        em = floor (em);
-        t = 0.9*(1.0+y*y)*exp (em*alxm-flogfak (em)-g);
-      } while (RUNI > t);
+      do
+        {
+          do
+            {
+              y = tan (M_PI*RUNI);
+              em = sq * y + lambda;
+            } while (em < 0.0);
+          em = floor (em);
+          t = 0.9*(1.0+y*y)*exp (em*alxm-flogfak (em)-g);
+        } while (RUNI > t);
       p[i] = em;
     }
 }
 
 /* The cutoff of L <= 1e8 in the following two functions before using
  * the normal approximation is based on:
  *   > L=1e8; x=floor(linspace(0,2*L,1000));
  *   > max(abs(normal_pdf(x,L,L)-poisson_pdf(x,L)))
@@ -498,38 +510,46 @@ oct_fill_randp (double L, octave_idx_typ
 }
 
 /* Generate one poisson variate */
 double
 oct_randp (double L)
 {
   double ret;
   if (L < 0.0) ret = NAN;
-  else if (L <= 12.0) {
-    /* From Press, et al. Numerical recipes */
-    double g = exp (-L);
-    int em = -1;
-    double t = 1.0;
-    do {
-      ++em;
-      t *= RUNI;
-    } while (t > g);
-    ret = em;
-  } else if (L <= 1e8) {
-    /* numerical recipes */
-    poisson_rejection (L, &ret, 1);
-  } else if (INFINITE(L)) {
-    /* FIXME R uses NaN, but the normal approx. suggests that as
-     * limit should be inf. Which is correct? */
-    ret = NAN;
-  } else {
-    /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
-    ret = floor (RNOR*sqrt (L) + L + 0.5);
-    if (ret < 0.0) ret = 0.0; /* will probably never happen */
-  }
+  else if (L <= 12.0)
+    {
+      /* From Press, et al. Numerical recipes */
+      double g = exp (-L);
+      int em = -1;
+      double t = 1.0;
+      do
+        {
+          ++em;
+          t *= RUNI;
+        } while (t > g);
+      ret = em;
+    }
+  else if (L <= 1e8)
+    {
+      /* numerical recipes */
+      poisson_rejection (L, &ret, 1);
+    }
+  else if (INFINITE(L))
+    {
+      /* FIXME R uses NaN, but the normal approx. suggests that as
+       * limit should be inf. Which is correct? */
+      ret = NAN;
+    }
+  else
+    {
+      /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
+      ret = floor (RNOR*sqrt (L) + L + 0.5);
+      if (ret < 0.0) ret = 0.0; /* will probably never happen */
+    }
   return ret;
 }
 
 /* Generate a set of poisson numbers with the same distribution */
 void
 oct_fill_float_randp (float FL, octave_idx_type n, float *p)
 {
   double L = FL;
@@ -563,32 +583,40 @@ oct_fill_float_randp (float FL, octave_i
 
 /* Generate one poisson variate */
 float
 oct_float_randp (float FL)
 {
   double L = FL;
   float ret;
   if (L < 0.0) ret = NAN;
-  else if (L <= 12.0) {
-    /* From Press, et al. Numerical recipes */
-    double g = exp (-L);
-    int em = -1;
-    double t = 1.0;
-    do {
-      ++em;
-      t *= RUNI;
-    } while (t > g);
-    ret = em;
-  } else if (L <= 1e8) {
-    /* numerical recipes */
-    poisson_rejection_float (L, &ret, 1);
-  } else if (INFINITE(L)) {
-    /* FIXME R uses NaN, but the normal approx. suggests that as
-     * limit should be inf. Which is correct? */
-    ret = NAN;
-  } else {
-    /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
-    ret = floor (RNOR*sqrt (L) + L + 0.5);
-    if (ret < 0.0) ret = 0.0; /* will probably never happen */
-  }
+  else if (L <= 12.0)
+    {
+      /* From Press, et al. Numerical recipes */
+      double g = exp (-L);
+      int em = -1;
+      double t = 1.0;
+      do
+        {
+          ++em;
+          t *= RUNI;
+        } while (t > g);
+      ret = em;
+    }
+  else if (L <= 1e8)
+    {
+      /* numerical recipes */
+      poisson_rejection_float (L, &ret, 1);
+    }
+  else if (INFINITE(L))
+    {
+      /* FIXME R uses NaN, but the normal approx. suggests that as
+       * limit should be inf. Which is correct? */
+      ret = NAN;
+    }
+  else
+    {
+      /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
+      ret = floor (RNOR*sqrt (L) + L + 0.5);
+      if (ret < 0.0) ret = 0.0; /* will probably never happen */
+    }
   return ret;
 }
diff --git a/liboctave/numeric/randpoisson.h b/liboctave/numeric/randpoisson.h
--- a/liboctave/numeric/randpoisson.h
+++ b/liboctave/numeric/randpoisson.h
@@ -28,14 +28,15 @@ along with Octave; see the file COPYING.
 #ifdef  __cplusplus
 extern "C" {
 #endif
 
 extern OCTAVE_API double oct_randp (double L);
 extern OCTAVE_API void oct_fill_randp (double L, octave_idx_type n, double *p);
 
 extern OCTAVE_API float oct_float_randp (float L);
-extern OCTAVE_API void oct_fill_float_randp (float L, octave_idx_type n, float *p);
+extern OCTAVE_API void oct_fill_float_randp (float L, octave_idx_type n,
+                                             float *p);
 
 #ifdef  __cplusplus
 }
 #endif
 #endif
diff --git a/liboctave/numeric/sparse-base-chol.h b/liboctave/numeric/sparse-base-chol.h
--- a/liboctave/numeric/sparse-base-chol.h
+++ b/liboctave/numeric/sparse-base-chol.h
@@ -34,46 +34,46 @@ sparse_base_chol
 protected:
 #ifdef HAVE_CHOLMOD
   class sparse_base_chol_rep
   {
   public:
     sparse_base_chol_rep (void)
       : count (1), Lsparse (0), Common (), is_pd (false), minor_p (0),
         perms (), cond (0)
-      { }
+    { }
 
     sparse_base_chol_rep (const chol_type& a, bool natural, bool force)
       : count (1), Lsparse (0), Common (), is_pd (false), minor_p (0),
         perms (), cond (0)
-      {
-        init (a, natural, force);
-      }
+    {
+      init (a, natural, force);
+    }
 
     sparse_base_chol_rep (const chol_type& a, octave_idx_type& info,
                           bool natural, bool force)
       : count (1), Lsparse (0), Common (), is_pd (false), minor_p (0),
         perms (), cond (0)
-      {
-        info = init (a, natural, force);
-      }
+    {
+      info = init (a, natural, force);
+    }
 
     ~sparse_base_chol_rep (void)
-      {
-        if (is_pd)
-          CHOLMOD_NAME (free_sparse) (&Lsparse, &Common);
-      }
+    {
+      if (is_pd)
+        CHOLMOD_NAME (free_sparse) (&Lsparse, &Common);
+    }
 
     cholmod_sparse * L (void) const { return Lsparse; }
 
     octave_idx_type P (void) const
-      {
-        return (minor_p == static_cast<octave_idx_type>(Lsparse->ncol) ?
-                0 : minor_p + 1);
-      }
+    {
+      return (minor_p == static_cast<octave_idx_type>(Lsparse->ncol) ?
+              0 : minor_p + 1);
+    }
 
     ColumnVector perm (void) const { return perms + 1; }
 
     p_type Q (void) const;
 
     bool is_positive_definite (void) const { return is_pd; }
 
     double rcond (void) const { return cond; }
@@ -107,26 +107,26 @@ protected:
   class sparse_base_chol_rep
   {
   public:
     sparse_base_chol_rep (void)
       : count (1), is_pd (false), minor_p (0), perms (), cond (0) { }
 
     sparse_base_chol_rep (const chol_type& a, bool natural, bool force)
       : count (1), is_pd (false), minor_p (0), perms (), cond (0)
-      {
-        init (a, natural, force);
-      }
+    {
+      init (a, natural, force);
+    }
 
     sparse_base_chol_rep (const chol_type& a, octave_idx_type& info,
                           bool natural, bool force)
       : count (1), is_pd (false), minor_p (0), perms (), cond (0)
-      {
-        info = init (a, natural, force);
-      }
+    {
+      info = init (a, natural, force);
+    }
 
     ~sparse_base_chol_rep (void) { }
 
     octave_idx_type P (void) const { return 0; }
 
     ColumnVector perm (void) const { return perms + 1; }
 
     p_type Q (void) const;
@@ -151,71 +151,75 @@ protected:
     // No copying!
 
     sparse_base_chol_rep (const sparse_base_chol_rep&);
 
     sparse_base_chol_rep& operator = (const sparse_base_chol_rep&);
   };
 #endif
 
- private:
+private:
   sparse_base_chol_rep *rep;
 
 public:
 
   sparse_base_chol (void)
     : rep (new typename
-           sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep ())
-    { }
+           sparse_base_chol<chol_type, chol_elt, p_type>
+           ::sparse_base_chol_rep ())
+  { }
 
   sparse_base_chol (const chol_type& a, bool natural, bool force)
     : rep (new typename
-           sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep (a, natural, force))
-    { }
+           sparse_base_chol<chol_type, chol_elt, p_type>
+           ::sparse_base_chol_rep (a, natural, force))
+  { }
 
   sparse_base_chol (const chol_type& a, octave_idx_type& info,
                     bool natural, bool force)
-    : rep (new typename sparse_base_chol<chol_type, chol_elt, p_type>::sparse_base_chol_rep (a, info, natural, force))
-    { }
+    : rep (new typename
+           sparse_base_chol<chol_type, chol_elt, p_type>
+           ::sparse_base_chol_rep (a, info, natural, force))
+  { }
 
   sparse_base_chol (const sparse_base_chol<chol_type, chol_elt, p_type>& a)
     : rep (a.rep)
-    { rep->count++; }
+  { rep->count++; }
 
   virtual ~sparse_base_chol (void)
-    {
-      if (--rep->count == 0)
-        delete rep;
-    }
+  {
+    if (--rep->count == 0)
+      delete rep;
+  }
 
   sparse_base_chol& operator = (const sparse_base_chol& a)
-    {
-      if (this != &a)
-        {
-          if (--rep->count == 0)
-            delete rep;
+  {
+    if (this != &a)
+      {
+        if (--rep->count == 0)
+          delete rep;
 
-          rep = a.rep;
-          rep->count++;
-        }
+        rep = a.rep;
+        rep->count++;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   chol_type L (void) const;
 
   chol_type R (void) const { return L ().hermitian (); }
 
   octave_idx_type P (void) const { return rep->P (); }
 
   ColumnVector perm (void) const { return rep->perm (); }
 
   p_type Q (void) const { return rep->Q (); }
 
   bool is_positive_definite (void) const
-    { return rep->is_positive_definite (); }
+  { return rep->is_positive_definite (); }
 
   double rcond (void) const { return rep->rcond (); }
 
   chol_type inverse (void) const;
 };
 
 #endif
diff --git a/liboctave/numeric/sparse-base-lu.h b/liboctave/numeric/sparse-base-lu.h
--- a/liboctave/numeric/sparse-base-lu.h
+++ b/liboctave/numeric/sparse-base-lu.h
@@ -34,31 +34,31 @@ sparse_base_lu
 {
 public:
 
   sparse_base_lu (void)
     : Lfact (), Ufact (), Rfact (), cond (0), P (), Q () { }
 
   sparse_base_lu (const sparse_base_lu& a)
     : Lfact (a.Lfact), Ufact (a.Ufact), Rfact (), cond (a.cond),
-    P (a.P), Q (a.Q)
-    { }
+      P (a.P), Q (a.Q)
+  { }
 
   sparse_base_lu& operator = (const sparse_base_lu& a)
-    {
-      if (this != &a)
-        {
-          Lfact = a.Lfact;
-          Ufact = a.Ufact;
-          cond = a.cond;
-          P = a.P;
-          Q = a.Q;
-        }
-      return *this;
-    }
+  {
+    if (this != &a)
+      {
+        Lfact = a.Lfact;
+        Ufact = a.Ufact;
+        cond = a.cond;
+        P = a.P;
+        Q = a.Q;
+      }
+    return *this;
+  }
 
   virtual ~sparse_base_lu (void) { }
 
   lu_type L (void) const { return Lfact; }
 
   lu_type U (void) const { return Ufact; }
 
   SparseMatrix R (void) const { return Rfact; }
diff --git a/liboctave/numeric/sparse-dmsolve.cc b/liboctave/numeric/sparse-dmsolve.cc
--- a/liboctave/numeric/sparse-dmsolve.cc
+++ b/liboctave/numeric/sparse-dmsolve.cc
@@ -33,20 +33,20 @@ along with Octave; see the file COPYING.
 #include "MatrixType.h"
 #include "oct-sort.h"
 #include "oct-locbuf.h"
 #include "oct-inttypes.h"
 
 template <class T>
 static MSparse<T>
 dmsolve_extract (const MSparse<T> &A, const octave_idx_type *Pinv,
-                const octave_idx_type *Q, octave_idx_type rst,
-                octave_idx_type rend, octave_idx_type cst,
-                octave_idx_type cend, octave_idx_type maxnz = -1,
-                bool lazy = false)
+                 const octave_idx_type *Q, octave_idx_type rst,
+                 octave_idx_type rend, octave_idx_type cst,
+                 octave_idx_type cend, octave_idx_type maxnz = -1,
+                 bool lazy = false)
 {
   octave_idx_type nr = rend - rst, nc = cend - cst;
   maxnz = (maxnz < 0 ? A.nnz () : maxnz);
   octave_idx_type nz;
 
   // Cast to uint64 to handle overflow in this multiplication
   if (octave_uint64 (nr)*octave_uint64 (nc) < octave_uint64 (maxnz))
     nz = nr*nc;
@@ -106,27 +106,27 @@ dmsolve_extract (const MSparse<T> &A, co
     }
 
   return B;
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static MSparse<double>
 dmsolve_extract (const MSparse<double> &A, const octave_idx_type *Pinv,
-                const octave_idx_type *Q, octave_idx_type rst,
-                octave_idx_type rend, octave_idx_type cst,
-                octave_idx_type cend, octave_idx_type maxnz,
-                bool lazy);
+                 const octave_idx_type *Q, octave_idx_type rst,
+                 octave_idx_type rend, octave_idx_type cst,
+                 octave_idx_type cend, octave_idx_type maxnz,
+                 bool lazy);
 
 static MSparse<Complex>
 dmsolve_extract (const MSparse<Complex> &A, const octave_idx_type *Pinv,
-                const octave_idx_type *Q, octave_idx_type rst,
-                octave_idx_type rend, octave_idx_type cst,
-                octave_idx_type cend, octave_idx_type maxnz,
-                bool lazy);
+                 const octave_idx_type *Q, octave_idx_type rst,
+                 octave_idx_type rend, octave_idx_type cst,
+                 octave_idx_type cend, octave_idx_type maxnz,
+                 bool lazy);
 #endif
 
 template <class T>
 static MArray<T>
 dmsolve_extract (const MArray<T> &m, const octave_idx_type *,
                  const octave_idx_type *, octave_idx_type r1,
                  octave_idx_type r2, octave_idx_type c1,
                  octave_idx_type c2)
@@ -160,17 +160,17 @@ dmsolve_extract (const MArray<Complex> &
                  const octave_idx_type *, octave_idx_type r1,
                  octave_idx_type r2, octave_idx_type c1,
                  octave_idx_type c2)
 #endif
 
 template <class T>
 static void
 dmsolve_insert (MArray<T> &a, const MArray<T> &b, const octave_idx_type *Q,
-               octave_idx_type r, octave_idx_type c)
+                octave_idx_type r, octave_idx_type c)
 {
   T *ax = a.fortran_vec ();
   const T *bx = b.fortran_vec ();
   octave_idx_type anr = a.rows ();
   octave_idx_type nr = b.rows ();
   octave_idx_type nc = b.cols ();
   for (octave_idx_type j = 0; j < nc; j++)
     {
@@ -182,27 +182,27 @@ dmsolve_insert (MArray<T> &a, const MArr
           ax[Q[r + i] + aoff] = bx[i + boff];
         }
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
 dmsolve_insert (MArray<double> &a, const MArray<double> &b,
-               const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
+                const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 
 static void
 dmsolve_insert (MArray<Complex> &a, const MArray<Complex> &b,
-               const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
+                const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 #endif
 
 template <class T>
 static void
 dmsolve_insert (MSparse<T> &a, const MSparse<T> &b, const octave_idx_type *Q,
-               octave_idx_type r, octave_idx_type c)
+                octave_idx_type r, octave_idx_type c)
 {
   octave_idx_type b_rows = b.rows ();
   octave_idx_type b_cols = b.cols ();
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   OCTAVE_LOCAL_BUFFER (octave_idx_type, Qinv, nr);
   for (octave_idx_type i = 0; i < nr; i++)
@@ -269,21 +269,21 @@ dmsolve_insert (MSparse<T> &a, const MSp
         }
       a.xcidx (i+1) = ii;
     }
 }
 
 #if !defined (CXX_NEW_FRIEND_TEMPLATE_DECL)
 static void
 dmsolve_insert (MSparse<double> &a, const SparseMatrix &b,
-               const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
+                const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 
 static void
 dmsolve_insert (MSparse<Complex> &a, const MSparse<Complex> &b,
-               const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
+                const octave_idx_type *Q, octave_idx_type r, octave_idx_type c);
 #endif
 
 template <class T, class RT>
 static void
 dmsolve_permute (MArray<RT> &a, const MArray<T>& b, const octave_idx_type *p)
 {
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
diff --git a/liboctave/operators/Sparse-diag-op-defs.h b/liboctave/operators/Sparse-diag-op-defs.h
--- a/liboctave/operators/Sparse-diag-op-defs.h
+++ b/liboctave/operators/Sparse-diag-op-defs.h
@@ -35,40 +35,40 @@ RT do_mul_dm_sm (const DM& d, const SM& 
   const octave_idx_type a_nc = a.cols ();
 
   if (nc != a_nr)
     {
       gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc);
       return RT ();
     }
   else
-   {
-     RT r (nr, a_nc, a.nnz ());
+    {
+      RT r (nr, a_nc, a.nnz ());
 
-     octave_idx_type l = 0;
+      octave_idx_type l = 0;
 
-     for (octave_idx_type j = 0; j < a_nc; j++)
-       {
-         r.xcidx (j) = l;
-         const octave_idx_type colend = a.cidx (j+1);
-         for (octave_idx_type k = a.cidx (j); k < colend; k++)
-           {
-             const octave_idx_type i = a.ridx (k);
-             if (i >= nr) break;
-             r.xdata (l) = d.dgelem (i) * a.data (k);
-             r.xridx (l) = i;
-             l++;
-           }
-       }
+      for (octave_idx_type j = 0; j < a_nc; j++)
+        {
+          r.xcidx (j) = l;
+          const octave_idx_type colend = a.cidx (j+1);
+          for (octave_idx_type k = a.cidx (j); k < colend; k++)
+            {
+              const octave_idx_type i = a.ridx (k);
+              if (i >= nr) break;
+              r.xdata (l) = d.dgelem (i) * a.data (k);
+              r.xridx (l) = i;
+              l++;
+            }
+        }
 
-     r.xcidx (a_nc) = l;
+      r.xcidx (a_nc) = l;
 
-     r.maybe_compress (true);
-     return r;
-   }
+      r.maybe_compress (true);
+      return r;
+    }
 }
 
 template <typename RT, typename SM, typename DM>
 RT do_mul_sm_dm (const SM& a, const DM& d)
 {
   const octave_idx_type nr = d.rows ();
   const octave_idx_type nc = d.cols ();
 
@@ -76,38 +76,38 @@ RT do_mul_sm_dm (const SM& a, const DM& 
   const octave_idx_type a_nc = a.cols ();
 
   if (nr != a_nc)
     {
       gripe_nonconformant ("operator *", a_nr, a_nc, nr, nc);
       return RT ();
     }
   else
-   {
+    {
 
-     const octave_idx_type mnc = nc < a_nc ? nc: a_nc;
-     RT r (a_nr, nc, a.cidx (mnc));
+      const octave_idx_type mnc = nc < a_nc ? nc: a_nc;
+      RT r (a_nr, nc, a.cidx (mnc));
 
-     for (octave_idx_type j = 0; j < mnc; ++j)
-       {
-         const typename DM::element_type s = d.dgelem (j);
-         const octave_idx_type colend = a.cidx (j+1);
-         r.xcidx (j) = a.cidx (j);
-         for (octave_idx_type k = a.cidx (j); k < colend; ++k)
-           {
-             r.xdata (k) = s * a.data (k);
-             r.xridx (k) = a.ridx (k);
-           }
-       }
-     for (octave_idx_type j = mnc; j <= nc; ++j)
-       r.xcidx (j) = a.cidx (mnc);
+      for (octave_idx_type j = 0; j < mnc; ++j)
+        {
+          const typename DM::element_type s = d.dgelem (j);
+          const octave_idx_type colend = a.cidx (j+1);
+          r.xcidx (j) = a.cidx (j);
+          for (octave_idx_type k = a.cidx (j); k < colend; ++k)
+            {
+              r.xdata (k) = s * a.data (k);
+              r.xridx (k) = a.ridx (k);
+            }
+        }
+      for (octave_idx_type j = mnc; j <= nc; ++j)
+        r.xcidx (j) = a.cidx (mnc);
 
-     r.maybe_compress (true);
-     return r;
-   }
+      r.maybe_compress (true);
+      return r;
+    }
 }
 
 // FIXME: functors such as this should be gathered somewhere
 template <typename T>
 struct identity_val
   : public std::unary_function <T, T>
 {
   T operator () (const T x) { return x; }
diff --git a/liboctave/operators/Sparse-op-defs.h b/liboctave/operators/Sparse-op-defs.h
--- a/liboctave/operators/Sparse-op-defs.h
+++ b/liboctave/operators/Sparse-op-defs.h
@@ -662,17 +662,17 @@ along with Octave; see the file COPYING.
             r.maybe_compress (); \
           } \
       } \
     else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
  \
-        /* FIXME Kludge... Always double/Complex, so Complex () */ \
+        /* FIXME: Kludge... Always double/Complex, so Complex () */ \
         r = R (m1_nr, m1_nc, (Complex () OP Complex ())); \
         \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
           { \
             octave_idx_type  ja = m1.cidx (i); \
             octave_idx_type  ja_max = m1.cidx (i+1); \
             bool ja_lt_max= ja < ja_max; \
             \
@@ -712,18 +712,17 @@ along with Octave; see the file COPYING.
         r.maybe_compress (true); \
       } \
  \
     return r; \
   }
 
 // Note that SM ./ SM needs to take into account the NaN and Inf values
 // implied by the division by zero.
-// FIXME Are the NaNs double(NaN) or Complex(NaN,Nan) in the complex
-// case?
+// FIXME: Are the NaNs double(NaN) or Complex(NaN,Nan) in the complex case?
 #define SPARSE_SMSM_BIN_OPS(R1, R2, M1, M2)  \
   SPARSE_SMSM_BIN_OP_1 (R1, operator +,  +, M1, M2) \
   SPARSE_SMSM_BIN_OP_1 (R1, operator -,  -, M1, M2) \
   SPARSE_SMSM_BIN_OP_2 (R2, product,     *, M1, M2) \
   SPARSE_SMSM_BIN_OP_3 (R2, quotient,    /, M1, M2)
 
 #define SPARSE_SMSM_CMP_OP_DECLS(M1, M2, API) \
   SPARSE_CMP_OP_DECL (mx_el_lt, M1, M2, API); \
@@ -732,19 +731,18 @@ along with Octave; see the file COPYING.
   SPARSE_CMP_OP_DECL (mx_el_gt, M1, M2, API); \
   SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2, API); \
   SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2, API);
 
 #define SPARSE_SMSM_EQNE_OP_DECLS(M1, M2, API) \
   SPARSE_CMP_OP_DECL (mx_el_eq, M1, M2, API); \
   SPARSE_CMP_OP_DECL (mx_el_ne, M1, M2, API);
 
-// FIXME -- this macro duplicatest the bodies of the template
-// functions defined in the SPARSE_SSM_CMP_OP and SPARSE_SMS_CMP_OP
-// macros.
+// FIXME: this macro duplicates the bodies of the template functions
+// defined in the SPARSE_SSM_CMP_OP and SPARSE_SMS_CMP_OP macros.
 
 #define SPARSE_SMSM_CMP_OP(F, OP, M1, Z1, C1, M2, Z2, C2)       \
   SparseBoolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     SparseBoolMatrix r; \
     \
     octave_idx_type m1_nr = m1.rows (); \
@@ -916,19 +914,18 @@ along with Octave; see the file COPYING.
 #define SPARSE_SMSM_EQNE_OPS(M1, Z1, C1, M2, Z2, C2)  \
   SPARSE_SMSM_CMP_OP (mx_el_eq, ==, M1, Z1,   , M2, Z2,   ) \
   SPARSE_SMSM_CMP_OP (mx_el_ne, !=, M1, Z1,   , M2, Z2,   )
 
 #define SPARSE_SMSM_BOOL_OP_DECLS(M1, M2, API) \
   SPARSE_BOOL_OP_DECL (mx_el_and, M1, M2, API); \
   SPARSE_BOOL_OP_DECL (mx_el_or,  M1, M2, API);
 
-// FIXME -- this macro duplicatest the bodies of the template
-// functions defined in the SPARSE_SSM_BOOL_OP and SPARSE_SMS_BOOL_OP
-// macros.
+// FIXME: this macro duplicates the bodies of the template functions
+// defined in the SPARSE_SSM_BOOL_OP and SPARSE_SMS_BOOL_OP macros.
 
 #define SPARSE_SMSM_BOOL_OP(F, OP, M1, M2, LHS_ZERO, RHS_ZERO) \
   SparseBoolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
     SparseBoolMatrix r; \
     \
     octave_idx_type m1_nr = m1.rows (); \
@@ -1145,17 +1142,17 @@ along with Octave; see the file COPYING.
           } \
         else \
           r = R (F (m1, m2.matrix_value ())); \
       } \
  \
     return r; \
   }
 
-// FIXME Pass a specific ZERO value
+// FIXME: Pass a specific ZERO value
 #define SPARSE_MSM_BIN_OPS(R1, R2, M1, M2) \
   SPARSE_MSM_BIN_OP_1 (R1, operator +,  +, M1, M2) \
   SPARSE_MSM_BIN_OP_1 (R1, operator -,  -, M1, M2) \
   SPARSE_MSM_BIN_OP_2 (R2, product,     *, M1, M2) \
   SPARSE_MSM_BIN_OP_1 (R2, quotient,    /, M1, M2)
 
 #define SPARSE_MSM_CMP_OP_DECLS(M1, M2, API) \
   SPARSE_CMP_OP_DECL (mx_el_lt, M1, M2, API); \
@@ -1805,18 +1802,17 @@ along with Octave; see the file COPYING.
 #define SPARSE_REDUCTION_OP(RET_TYPE, EL_TYPE, OP, INIT_VAL, MT_RESULT) \
   SPARSE_BASE_REDUCTION_OP (RET_TYPE, EL_TYPE, \
                         SPARSE_REDUCTION_OP_ROW_EXPR (OP), \
                         SPARSE_REDUCTION_OP_COL_EXPR (OP), \
                         INIT_VAL, MT_RESULT)
 
 
 // Don't break from this loop if the test succeeds because
-// we are looping over the rows and not the columns in the inner
-// loop.
+// we are looping over the rows and not the columns in the inner loop.
 #define SPARSE_ANY_ALL_OP_ROW_CODE(TEST_OP, TEST_TRUE_VAL) \
   if (data (i) TEST_OP 0.0) \
     tmp[ridx (i)] = TEST_TRUE_VAL; \
 
 #define SPARSE_ANY_ALL_OP_COL_CODE(TEST_OP, TEST_TRUE_VAL) \
   if (data (i) TEST_OP 0.0) \
     { \
       tmp[j] = TEST_TRUE_VAL; \
diff --git a/liboctave/operators/mx-inlines.cc b/liboctave/operators/mx-inlines.cc
--- a/liboctave/operators/mx-inlines.cc
+++ b/liboctave/operators/mx-inlines.cc
@@ -1048,31 +1048,31 @@ void mx_inline_diff (const T *v, T *r, o
             {
               T dif = v[i+2] - v[i+1];
               r[i] = dif - lst;
               lst = dif;
             }
         }
       break;
     default:
-        {
-          OCTAVE_LOCAL_BUFFER (T, buf, n-1);
+      {
+        OCTAVE_LOCAL_BUFFER (T, buf, n-1);
 
-          for (octave_idx_type i = 0; i < n-1; i++)
-            buf[i] = v[i+1] - v[i];
+        for (octave_idx_type i = 0; i < n-1; i++)
+          buf[i] = v[i+1] - v[i];
 
-          for (octave_idx_type o = 2; o <= order; o++)
-            {
-              for (octave_idx_type i = 0; i < n-o; i++)
-                buf[i] = buf[i+1] - buf[i];
-            }
+        for (octave_idx_type o = 2; o <= order; o++)
+          {
+            for (octave_idx_type i = 0; i < n-o; i++)
+              buf[i] = buf[i+1] - buf[i];
+          }
 
-          for (octave_idx_type i = 0; i < n-order; i++)
-            r[i] = buf[i];
-        }
+        for (octave_idx_type i = 0; i < n-order; i++)
+          r[i] = buf[i];
+      }
     }
 }
 
 template <class T>
 void mx_inline_diff (const T *v, T *r,
                      octave_idx_type m, octave_idx_type n,
                      octave_idx_type order)
 {
@@ -1085,34 +1085,34 @@ void mx_inline_diff (const T *v, T *r,
     case 2:
       for (octave_idx_type i = 0; i < n-2; i++)
         {
           for (octave_idx_type j = i*m; j < i*m+m; j++)
             r[j] = (v[j+m+m] - v[j+m]) - (v[j+m] - v[j]);
         }
       break;
     default:
-        {
-          OCTAVE_LOCAL_BUFFER (T, buf, n-1);
+      {
+        OCTAVE_LOCAL_BUFFER (T, buf, n-1);
 
-          for (octave_idx_type j = 0; j < m; j++)
-            {
-              for (octave_idx_type i = 0; i < n-1; i++)
-                buf[i] = v[i*m+j+m] - v[i*m+j];
+        for (octave_idx_type j = 0; j < m; j++)
+          {
+            for (octave_idx_type i = 0; i < n-1; i++)
+              buf[i] = v[i*m+j+m] - v[i*m+j];
 
-              for (octave_idx_type o = 2; o <= order; o++)
-                {
-                  for (octave_idx_type i = 0; i < n-o; i++)
-                    buf[i] = buf[i+1] - buf[i];
-                }
+            for (octave_idx_type o = 2; o <= order; o++)
+              {
+                for (octave_idx_type i = 0; i < n-o; i++)
+                  buf[i] = buf[i+1] - buf[i];
+              }
 
-              for (octave_idx_type i = 0; i < n-order; i++)
-                r[i*m+j] = buf[i];
-            }
-        }
+            for (octave_idx_type i = 0; i < n-order; i++)
+              r[i*m+j] = buf[i];
+          }
+      }
     }
 }
 
 template <class T>
 inline void
 mx_inline_diff (const T *v, T *r,
                 octave_idx_type l, octave_idx_type n, octave_idx_type u,
                 octave_idx_type order)
diff --git a/liboctave/system/dir-ops.h b/liboctave/system/dir-ops.h
--- a/liboctave/system/dir-ops.h
+++ b/liboctave/system/dir-ops.h
@@ -30,36 +30,36 @@ along with Octave; see the file COPYING.
 class
 OCTAVE_API
 dir_entry
 {
 public:
 
   dir_entry (const std::string& n = std::string ())
     : name (n), dir (0), fail (false), errmsg ()
-    {
-      if (! name.empty ())
-        open ();
-    }
+  {
+    if (! name.empty ())
+      open ();
+  }
 
   dir_entry (const dir_entry& d)
     : name (d.name), dir (d.dir), fail (d.fail), errmsg (d.errmsg) { }
 
   dir_entry& operator = (const dir_entry& d)
-    {
-      if (this != &d)
-        {
-          name = d.name;
-          dir = d.dir;
-          fail = d.fail;
-          errmsg = d.errmsg;
-        }
+  {
+    if (this != &d)
+      {
+        name = d.name;
+        dir = d.dir;
+        fail = d.fail;
+        errmsg = d.errmsg;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   ~dir_entry (void) { close (); }
 
   bool open (const std::string& = std::string ());
 
   string_vector read (void);
 
   void close (void);
diff --git a/liboctave/system/file-ops.cc b/liboctave/system/file-ops.cc
--- a/liboctave/system/file-ops.cc
+++ b/liboctave/system/file-ops.cc
@@ -351,20 +351,20 @@ file_ops::tilde_expand (const string_vec
 
   return retval;
 }
 
 std::string
 file_ops::concat (const std::string& dir, const std::string& file)
 {
   return dir.empty ()
-    ? file
-    : (is_dir_sep (dir[dir.length ()-1])
-       ? dir + file
-       : dir + dir_sep_char () + file);
+         ? file
+         : (is_dir_sep (dir[dir.length ()-1])
+            ? dir + file
+            : dir + dir_sep_char () + file);
 }
 
 
 int
 octave_mkdir (const std::string& nm, mode_t md)
 {
   std::string msg;
   return octave_mkdir (nm, md, msg);
@@ -415,17 +415,17 @@ int
 octave_link (const std::string& old_name, const std::string& new_name)
 {
   std::string msg;
   return octave_link (old_name, new_name, msg);
 }
 
 int
 octave_link (const std::string& old_name,
-                const std::string& new_name, std::string& msg)
+             const std::string& new_name, std::string& msg)
 {
   msg = std::string ();
 
   int status = -1;
 
   status = gnulib::link (old_name.c_str (), new_name.c_str ());
 
   if (status < 0)
@@ -438,17 +438,17 @@ int
 octave_symlink (const std::string& old_name, const std::string& new_name)
 {
   std::string msg;
   return octave_symlink (old_name, new_name, msg);
 }
 
 int
 octave_symlink (const std::string& old_name,
-                   const std::string& new_name, std::string& msg)
+                const std::string& new_name, std::string& msg)
 {
   msg = std::string ();
 
   int status = -1;
 
   status = gnulib::symlink (old_name.c_str (), new_name.c_str ());
 
   if (status < 0)
@@ -461,17 +461,17 @@ int
 octave_readlink (const std::string& path, std::string& result)
 {
   std::string msg;
   return octave_readlink (path, result, msg);
 }
 
 int
 octave_readlink (const std::string& path, std::string& result,
-                    std::string& msg)
+                 std::string& msg)
 {
   int status = -1;
 
   msg = std::string ();
 
   char buf[MAXPATHLEN+1];
 
   status = gnulib::readlink (path.c_str (), buf, MAXPATHLEN);
@@ -492,17 +492,17 @@ int
 octave_rename (const std::string& from, const std::string& to)
 {
   std::string msg;
   return octave_rename (from, to, msg);
 }
 
 int
 octave_rename (const std::string& from, const std::string& to,
-                  std::string& msg)
+               std::string& msg)
 {
   int status = -1;
 
   msg = std::string ();
 
   status = gnulib::rename (from.c_str (), to.c_str ());
 
   if (status < 0)
@@ -781,17 +781,17 @@ extern int errno;
 
   OCTAVE_LOCAL_BUFFER (char, buf, PATH_MAX);
 
   if (::realpath (name.c_str (), buf))
     retval = buf;
 
 #else
 
-  // FIXME -- provide replacement here...
+  // FIXME: provide replacement here...
   retval = name;
 
 #endif
 
   if (retval.empty ())
     msg = gnulib::strerror (errno);
 
   return retval;
diff --git a/liboctave/system/file-stat.cc b/liboctave/system/file-stat.cc
--- a/liboctave/system/file-stat.cc
+++ b/liboctave/system/file-stat.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include <unistd.h>
 
 #include "filemode.h"
 
 #include "file-ops.h"
 #include "file-stat.h"
 #include "statdefs.h"
 
-// FIXME -- the is_* and mode_as_string functions are only valid
+// FIXME: the is_* and mode_as_string functions are only valid
 // for initialized objects.  If called for an object that is not
 // initialized, they should throw an exception.
 
 bool
 base_file_stat::is_blk (void) const
 {
   return exists () && is_blk (fs_mode);
 }
@@ -193,17 +193,17 @@ file_stat::update_internal (bool force)
         full_file_name.resize (full_file_name.length () - 1);
 #endif
 
       const char *cname = full_file_name.c_str ();
 
       struct stat buf;
 
       int status = follow_links
-        ? stat (cname, &buf) : gnulib::lstat (cname, &buf);
+                   ? stat (cname, &buf) : gnulib::lstat (cname, &buf);
 
       if (status < 0)
         {
           fail = true;
           errmsg = gnulib::strerror (errno);
         }
       else
         {
diff --git a/liboctave/system/file-stat.h b/liboctave/system/file-stat.h
--- a/liboctave/system/file-stat.h
+++ b/liboctave/system/file-stat.h
@@ -70,18 +70,18 @@ public:
         fs_blksize = fs.fs_blksize;
         fs_blocks = fs.fs_blocks;
       }
 
     return *this;
   }
 
   // The minimum difference in file time stamp values.
-  // FIXME -- this value should come from the filesystem itself.  How
-  // can we get that info?
+  // FIXME: This value should come from the filesystem itself.
+  //        How can we get that info?
   octave_time time_resolution (void) const
   {
     static octave_time resolution (1.0);
     return resolution;
   }
 
   // File status and info.  The is_XXX functions will return false for
   // file_stat objects that are not properly initialized.  The others
diff --git a/liboctave/system/lo-sysdep.cc b/liboctave/system/lo-sysdep.cc
--- a/liboctave/system/lo-sysdep.cc
+++ b/liboctave/system/lo-sysdep.cc
@@ -78,49 +78,55 @@ octave_chdir (const std::string& path_ar
 #endif
 
   return gnulib::chdir (path.c_str ());
 }
 
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
 
 pid_t
-octave_popen2 (const std::string& cmd, const string_vector& args, bool sync_mode,
-    int *fildes, std::string& msg)
+octave_popen2 (const std::string& cmd, const string_vector& args,
+               bool sync_mode,
+               int *fildes, std::string& msg)
 {
   pid_t pid;
   PROCESS_INFORMATION pi;
   STARTUPINFO si;
   std::string command = "\"" + cmd + "\"";
-  HANDLE hProcess = GetCurrentProcess (), childRead, childWrite, parentRead, parentWrite;
+  HANDLE hProcess = GetCurrentProcess ();
+  HANDLE childRead, childWrite, parentRead, parentWrite;
   DWORD pipeMode;
 
   ZeroMemory (&pi, sizeof (pi));
   ZeroMemory (&si, sizeof (si));
   si.cb = sizeof (si);
 
   if (! CreatePipe (&childRead, &parentWrite, 0, 0) ||
-      ! DuplicateHandle (hProcess, childRead, hProcess, &childRead, 0, TRUE, DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
+      ! DuplicateHandle (hProcess, childRead, hProcess, &childRead, 0, TRUE,
+                         DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
     {
       msg = "popen2: pipe creation failed";
       return -1;
     }
   if (! CreatePipe (&parentRead, &childWrite, 0, 0) ||
-      ! DuplicateHandle (hProcess, childWrite, hProcess, &childWrite, 0, TRUE, DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
+      ! DuplicateHandle (hProcess, childWrite, hProcess, &childWrite, 0, TRUE,
+                         DUPLICATE_SAME_ACCESS | DUPLICATE_CLOSE_SOURCE))
     {
       msg = "popen2: pipe creation failed";
       return -1;
     }
   if (! sync_mode)
     {
       pipeMode = PIPE_NOWAIT;
       SetNamedPipeHandleState (parentRead, &pipeMode, 0, 0);
     }
-  fildes[1] = _open_osfhandle (reinterpret_cast<intptr_t> (parentRead), _O_RDONLY | _O_BINARY);
-  fildes[0] = _open_osfhandle (reinterpret_cast<intptr_t> (parentWrite), _O_WRONLY | _O_BINARY);
+  fildes[1] = _open_osfhandle (reinterpret_cast<intptr_t> (parentRead),
+                               _O_RDONLY | _O_BINARY);
+  fildes[0] = _open_osfhandle (reinterpret_cast<intptr_t> (parentWrite),
+                               _O_WRONLY | _O_BINARY);
   si.dwFlags |= STARTF_USESTDHANDLES;
   si.hStdInput = childRead;
   si.hStdOutput = childWrite;
 
   // Ignore first arg as it is the command
   for (int k=1; k<args.length (); k++)
     command += " \"" + args[k] + "\"";
   OCTAVE_LOCAL_BUFFER (char, c_command, command.length () + 1);
diff --git a/liboctave/system/lo-sysdep.h b/liboctave/system/lo-sysdep.h
--- a/liboctave/system/lo-sysdep.h
+++ b/liboctave/system/lo-sysdep.h
@@ -29,12 +29,12 @@ along with Octave; see the file COPYING.
 class string_vector;
 
 extern std::string octave_getcwd (void);
 
 extern int octave_chdir (const std::string&);
 
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
 extern pid_t octave_popen2 (const std::string&, const string_vector&,
-    bool, int *, std::string&);
+                            bool, int *, std::string&);
 #endif
 
 #endif
diff --git a/liboctave/system/mach-info.cc b/liboctave/system/mach-info.cc
--- a/liboctave/system/mach-info.cc
+++ b/liboctave/system/mach-info.cc
@@ -159,31 +159,31 @@ oct_mach_info::instance_ok (void)
 
   return retval;
 }
 
 oct_mach_info::float_format
 oct_mach_info::native_float_format (void)
 {
   return (instance_ok ())
-    ? instance->native_float_fmt : oct_mach_info::flt_fmt_unknown;
+         ? instance->native_float_fmt : oct_mach_info::flt_fmt_unknown;
 }
 
 bool
 oct_mach_info::words_big_endian (void)
 {
   return (instance_ok ())
-    ? instance->big_chief : false;
+         ? instance->big_chief : false;
 }
 
 bool
 oct_mach_info::words_little_endian (void)
 {
   return (instance_ok ())
-    ? (! instance->big_chief) : false;
+         ? (! instance->big_chief) : false;
 }
 
 oct_mach_info::float_format
 oct_mach_info::string_to_float_format (const std::string& s)
 {
   oct_mach_info::float_format retval = oct_mach_info::flt_fmt_unknown;
 
   if (s == "native" || s == "n")
diff --git a/liboctave/system/mach-info.h b/liboctave/system/mach-info.h
--- a/liboctave/system/mach-info.h
+++ b/liboctave/system/mach-info.h
@@ -31,21 +31,21 @@ oct_mach_info
 {
 protected:
 
   oct_mach_info (void);
 
 public:
 
   enum float_format
-    {
-      flt_fmt_unknown,
-      flt_fmt_ieee_little_endian,
-      flt_fmt_ieee_big_endian,
-    };
+  {
+    flt_fmt_unknown,
+    flt_fmt_ieee_little_endian,
+    flt_fmt_ieee_big_endian,
+  };
 
   static bool instance_ok (void);
 
   static float_format native_float_format (void);
 
   static bool words_big_endian (void);
 
   static bool words_little_endian (void);
diff --git a/liboctave/system/oct-env.cc b/liboctave/system/oct-env.cc
--- a/liboctave/system/oct-env.cc
+++ b/liboctave/system/oct-env.cc
@@ -99,105 +99,105 @@ octave_env::instance_ok (void)
 
   return retval;
 }
 
 std::string
 octave_env::polite_directory_format (const std::string& name)
 {
   return (instance_ok ())
-    ? instance->do_polite_directory_format (name) : std::string ();
+         ? instance->do_polite_directory_format (name) : std::string ();
 }
 
 bool
 octave_env::absolute_pathname (const std::string& s)
 {
   return (instance_ok ())
-    ? instance->do_absolute_pathname (s) : false;
+         ? instance->do_absolute_pathname (s) : false;
 }
 
 bool
 octave_env::rooted_relative_pathname (const std::string& s)
 {
   return (instance_ok ())
-    ? instance->do_rooted_relative_pathname (s) : false;
+         ? instance->do_rooted_relative_pathname (s) : false;
 }
 
 std::string
 octave_env::base_pathname (const std::string& s)
 {
   return (instance_ok ())
-    ? instance->do_base_pathname (s) : std::string ();
+         ? instance->do_base_pathname (s) : std::string ();
 }
 
 std::string
 octave_env::make_absolute (const std::string& s, const std::string& dot_path)
 {
   return (instance_ok ())
-    ? instance->do_make_absolute (s, dot_path) : std::string ();
+         ? instance->do_make_absolute (s, dot_path) : std::string ();
 }
 
 std::string
 octave_env::get_current_directory ()
 {
   return (instance_ok ())
-    ? instance->do_getcwd () : std::string ();
+         ? instance->do_getcwd () : std::string ();
 }
 
 std::string
 octave_env::get_home_directory ()
 {
   return (instance_ok ())
-    ? instance->do_get_home_directory () : std::string ();
+         ? instance->do_get_home_directory () : std::string ();
 }
 
 std::string
 octave_env::get_program_name (void)
 {
   return (instance_ok ())
-    ? instance->prog_name : std::string ();
+         ? instance->prog_name : std::string ();
 }
 
 std::string
 octave_env::get_program_invocation_name (void)
 {
   return (instance_ok ())
-    ? instance->prog_invocation_name : std::string ();
+         ? instance->prog_invocation_name : std::string ();
 }
 
 void
 octave_env::set_program_name (const std::string& s)
 {
   if (instance_ok ())
     instance->do_set_program_name (s);
 }
 
 std::string
 octave_env::get_user_name (void)
 {
   return (instance_ok ())
-    ? instance->do_get_user_name () : std::string ();
+         ? instance->do_get_user_name () : std::string ();
 }
 
 std::string
 octave_env::get_host_name (void)
 {
   return (instance_ok ())
-    ? instance->do_get_host_name () : std::string ();
+         ? instance->do_get_host_name () : std::string ();
 }
 
-// FIXME -- this leaves no way to distinguish between a
+// FIXME: this leaves no way to distinguish between a
 // variable that is not set and one that is set to the empty string.
 // Is this a problem?
 
 std::string
 octave_env::getenv (const std::string& name)
 {
   return (instance_ok ())
-    ? instance->do_getenv (name) : std::string ();
+         ? instance->do_getenv (name) : std::string ();
 }
 
 void
 octave_env::putenv (const std::string& name, const std::string& value)
 {
   octave_putenv (name, value);
 }
 
@@ -208,34 +208,34 @@ octave_env::have_x11_display (void)
 
   return ! display.empty ();
 }
 
 bool
 octave_env::chdir (const std::string& newdir)
 {
   return (instance_ok ())
-    ? instance->do_chdir (newdir) : false;
+         ? instance->do_chdir (newdir) : false;
 }
 
 void
 octave_env::do_set_program_name (const std::string& s) const
 {
   // For gnulib.
   ::set_program_name (s.c_str ());
 
   // Let gnulib strip off things like the "lt-" prefix from libtool.
   prog_invocation_name = program_name;
 
   size_t pos
     = prog_invocation_name.find_last_of (file_ops::dir_sep_chars ());
 
   // Also keep a shortened version of the program name.
   prog_name = (pos == std::string::npos)
-    ? prog_invocation_name : prog_invocation_name.substr (pos+1);
+              ? prog_invocation_name : prog_invocation_name.substr (pos+1);
 }
 
 // Return a pretty pathname.  If the first part of the pathname is the
 // same as $HOME, then replace that with '~'.
 
 std::string
 octave_env::do_polite_directory_format (const std::string& name) const
 {
@@ -334,17 +334,17 @@ octave_env::do_make_absolute (const std:
   if (current_dir.empty ())
     current_dir = do_getcwd ();
 
   size_t pos = current_dir.length () - 1;
 
   if (! file_ops::is_dir_sep (current_dir[pos]))
     current_dir.append (file_ops::dir_sep_str ());
 
-  // FIXME -- this is probably not correct for all systems.
+  // FIXME: this is probably not correct for all systems.
 
   size_t i = 0;
   size_t slen = s.length ();
 
   while (i < slen)
     {
       if (s[i] == '.')
         {
diff --git a/liboctave/system/oct-group.cc b/liboctave/system/oct-group.cc
--- a/liboctave/system/oct-group.cc
+++ b/liboctave/system/oct-group.cc
@@ -183,19 +183,18 @@ octave_group::octave_group (void *p, std
       gr_name = gr->gr_name;
 
 #if defined (HAVE_GR_PASSWD)
       gr_passwd = gr->gr_passwd;
 #endif
 
       gr_gid = gr->gr_gid;
 
-      // FIXME -- maybe there should be a string_vector
-      // constructor that takes a NUL terminated list of C
-      // strings.
+      // FIXME: Maybe there should be a string_vector constructor
+      //        that takes a NUL terminated list of C strings?
 
       const char * const *tmp = gr->gr_mem;
 
       int k = 0;
       while (*tmp++)
         k++;
 
       if (k > 0)
diff --git a/liboctave/system/oct-syscalls.cc b/liboctave/system/oct-syscalls.cc
--- a/liboctave/system/oct-syscalls.cc
+++ b/liboctave/system/oct-syscalls.cc
@@ -294,34 +294,35 @@ octave_syscalls::kill (pid_t pid, int si
   msg = NOT_SUPPORTED ("kill");
 #endif
 
   return status;
 }
 
 pid_t
 octave_syscalls::popen2 (const std::string& cmd, const string_vector& args,
-    bool sync_mode, int *fildes)
+                         bool sync_mode, int *fildes)
 {
   std::string msg;
   bool interactive = false;
   return popen2 (cmd, args, sync_mode, fildes, msg, interactive);
 }
 
 pid_t
 octave_syscalls::popen2 (const std::string& cmd, const string_vector& args,
-    bool sync_mode, int *fildes, std::string& msg)
+                         bool sync_mode, int *fildes, std::string& msg)
 {
   bool interactive = false;
   return popen2 (cmd, args, sync_mode, fildes, msg, interactive);
 }
 
 pid_t
 octave_syscalls::popen2 (const std::string& cmd, const string_vector& args,
-    bool sync_mode, int *fildes, std::string& msg, bool &interactive)
+                         bool sync_mode, int *fildes, std::string& msg,
+                         bool &interactive)
 {
 #if defined (__WIN32__) && ! defined (__CYGWIN__)
   return ::octave_popen2 (cmd, args, sync_mode, fildes, msg);
 #else
   pid_t pid;
   int child_stdin[2], child_stdout[2];
 
   if (pipe (child_stdin, msg) == 0)
@@ -362,17 +363,18 @@ octave_syscalls::popen2 (const std::stri
             }
           else
             {
               // Parent process
               gnulib::close (child_stdin[0]);
               gnulib::close (child_stdout[1]);
 
 #if defined (F_SETFL) && defined (O_NONBLOCK)
-              if (! sync_mode && octave_fcntl (child_stdout[0], F_SETFL, O_NONBLOCK, msg) < 0)
+              if (! sync_mode && octave_fcntl (child_stdout[0], F_SETFL,
+                                               O_NONBLOCK, msg) < 0)
                 msg = "popen2: error setting file mode -- " + msg;
               else
 #endif
                 {
                   fildes[0] = child_stdin[1];
                   fildes[1] = child_stdout[0];
                   return pid;
                 }
diff --git a/liboctave/system/oct-syscalls.h b/liboctave/system/oct-syscalls.h
--- a/liboctave/system/oct-syscalls.h
+++ b/liboctave/system/oct-syscalls.h
@@ -58,16 +58,18 @@ octave_syscalls
 
   static pid_t waitpid (pid_t, int *status, int);
   static pid_t waitpid (pid_t, int *status, int, std::string&);
 
   static int kill (pid_t, int);
   static int kill (pid_t, int, std::string&);
 
   static pid_t popen2 (const std::string&, const string_vector&, bool, int *);
-  static pid_t popen2 (const std::string&, const string_vector&, bool, int *, std::string&);
-  static pid_t popen2 (const std::string&, const string_vector&, bool, int *, std::string&, bool &interactive);
+  static pid_t popen2 (const std::string&, const string_vector&, bool, int *,
+                       std::string&);
+  static pid_t popen2 (const std::string&, const string_vector&, bool, int *,
+                       std::string&, bool &interactive);
 };
 
 #endif
 
 extern OCTAVE_API int octave_fcntl (int, int, long);
 extern OCTAVE_API int octave_fcntl (int, int, long, std::string&);
diff --git a/liboctave/system/oct-time.h b/liboctave/system/oct-time.h
--- a/liboctave/system/oct-time.h
+++ b/liboctave/system/oct-time.h
@@ -231,17 +231,17 @@ public:
   octave_base_tm& yday (int v);
   octave_base_tm& isdst (int v);
   octave_base_tm& gmtoff (long v);
   octave_base_tm& zone (const std::string& s);
 
   std::string strftime (const std::string& fmt) const;
 
   std::string asctime (void) const
-    { return strftime ("%a %b %d %H:%M:%S %Y\n"); }
+  { return strftime ("%a %b %d %H:%M:%S %Y\n"); }
 
 protected:
 
   // Microseconds after the second (0, 999999).
   int tm_usec;
 
   // Seconds after the minute (0, 61).
   int tm_sec;
diff --git a/liboctave/system/tempname.c b/liboctave/system/tempname.c
--- a/liboctave/system/tempname.c
+++ b/liboctave/system/tempname.c
@@ -174,17 +174,17 @@ char *
                pfx, pid % 100000,
                letters[*idx
                        % (sizeof (letters) - 1)],
                letters[(*idx / (sizeof (letters) - 1))
                        % (sizeof (letters) - 1)],
                letters[(*idx / ((sizeof (letters) - 1) *
                                 (sizeof (letters) - 1)))
                        % (sizeof (letters) - 1)]
-               );
+              );
 
       if (! buf || strlen (buf) != (int) len)
         return NULL;
 
       if (streamptr != NULL)
         abort ();
       else if (exists (buf))
         continue;
diff --git a/liboctave/util/action-container.h b/liboctave/util/action-container.h
--- a/liboctave/util/action-container.h
+++ b/liboctave/util/action-container.h
@@ -23,17 +23,17 @@ along with Octave; see the file COPYING.
 
 #if !defined (octave_action_container_h)
 #define octave_action_container_h 1
 
 // This class allows registering actions in a list for later
 // execution, either explicitly or when the container goes out of
 // scope.
 
-// FIXME -- is there a better name for this class?
+// FIXME: is there a better name for this class?
 
 class
 action_container
 {
 public:
 
   // A generic unwind_protect element. Knows how to run itself and
   // discard itself.  Also, contains a pointer to the next element.
diff --git a/liboctave/util/base-list.h b/liboctave/util/base-list.h
--- a/liboctave/util/base-list.h
+++ b/liboctave/util/base-list.h
@@ -77,20 +77,22 @@ public:
 
   iterator begin (void) { return iterator (lst.begin ()); }
   const_iterator begin (void) const { return const_iterator (lst.begin ()); }
 
   iterator end (void) { return iterator (lst.end ()); }
   const_iterator end (void) const { return const_iterator (lst.end ()); }
 
   reverse_iterator rbegin (void) { return reverse_iterator (lst.rbegin ()); }
-  const_reverse_iterator rbegin (void) const { return const_reverse_iterator (lst.rbegin ()); }
+  const_reverse_iterator rbegin (void) const
+  { return const_reverse_iterator (lst.rbegin ()); }
 
   reverse_iterator rend (void) { return reverse_iterator (lst.rend ()); }
-  const_reverse_iterator rend (void) const { return const_reverse_iterator (lst.rend ()); }
+  const_reverse_iterator rend (void) const
+  { return const_reverse_iterator (lst.rend ()); }
 
   elt_type& front (void) { return lst.front (); }
   elt_type& back (void) { return lst.back (); }
 
   const elt_type& front (void) const { return lst.front (); }
   const elt_type& back (void) const { return lst.back (); }
 
   void push_front (const elt_type& s) { lst.push_front (s); }
@@ -106,23 +108,23 @@ protected:
 
   octave_base_list (void) : lst () { }
 
   octave_base_list (const std::list<elt_type>& l) : lst (l) { }
 
   octave_base_list (const octave_base_list& bl) : lst (bl.lst) { }
 
   octave_base_list& operator = (const octave_base_list& bl)
-    {
-      if (this != &bl)
-        {
-          lst = bl.lst;
-        }
-      return *this;
-    }
+  {
+    if (this != &bl)
+      {
+        lst = bl.lst;
+      }
+    return *this;
+  }
 
   ~octave_base_list (void) { }
 
 private:
 
   std::list<elt_type> lst;
 };
 
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -219,17 +219,17 @@ private:
 
 gnu_readline::gnu_readline ()
   : command_editor (), previous_startup_hook (0),
     previous_pre_input_hook (0),
     previous_event_hook (0), completion_function (0),
     quoting_function (0), dequoting_function (0),
     char_is_quoted_function (0), user_accept_line_function (0)
 {
-  // FIXME -- need interface to rl_add_defun, rl_initialize, and
+  // FIXME: need interface to rl_add_defun, rl_initialize, and
   // a function to set rl_terminal_name
 
   std::string term = octave_env::getenv ("TERM");
 
   octave_rl_set_terminal_name (term.c_str ());
 
   octave_rl_initialize ();
 
@@ -1055,52 +1055,52 @@ command_editor::set_input_stream (FILE *
   if (instance_ok ())
     instance->do_set_input_stream (f);
 }
 
 FILE *
 command_editor::get_input_stream (void)
 {
   return (instance_ok ())
-    ? instance->do_get_input_stream () : 0;
+         ? instance->do_get_input_stream () : 0;
 }
 
 void
 command_editor::set_output_stream (FILE *f)
 {
   if (instance_ok ())
     instance->do_set_output_stream (f);
 }
 
 FILE *
 command_editor::get_output_stream (void)
 {
   return (instance_ok ())
-    ? instance->do_get_output_stream () : 0;
+         ? instance->do_get_output_stream () : 0;
 }
 
 void
 command_editor::redisplay (void)
 {
   if (instance_ok ())
     instance->do_redisplay ();
 }
 
 int
 command_editor::terminal_rows (void)
 {
   return (instance_ok ())
-    ? instance->do_terminal_rows () : -1;
+         ? instance->do_terminal_rows () : -1;
 }
 
 int
 command_editor::terminal_cols (void)
 {
   return (instance_ok ())
-    ? instance->do_terminal_cols () : -1;
+         ? instance->do_terminal_cols () : -1;
 }
 
 void
 command_editor::clear_screen (bool skip_redisplay)
 {
   if (instance_ok ())
     instance->do_clear_screen (skip_redisplay);
 }
@@ -1111,24 +1111,24 @@ command_editor::resize_terminal (void)
   if (instance_ok ())
     instance->do_resize_terminal ();
 }
 
 std::string
 command_editor::decode_prompt_string (const std::string& s)
 {
   return (instance_ok ())
-    ? instance->do_decode_prompt_string (s) : std::string ();
+         ? instance->do_decode_prompt_string (s) : std::string ();
 }
 
 int
 command_editor::current_command_number (void)
 {
   return (instance_ok ())
-    ? instance->command_number : 0;
+         ? instance->command_number : 0;
 }
 
 void
 command_editor::reset_current_command_number (int n)
 {
   if (instance_ok ())
     instance->command_number = n;
 }
@@ -1230,52 +1230,52 @@ command_editor::set_user_accept_line_fun
   if (instance_ok ())
     instance->do_set_user_accept_line_function (f);
 }
 
 command_editor::completion_fcn
 command_editor::get_completion_function (void)
 {
   return (instance_ok ())
-    ? instance->do_get_completion_function () : 0;
+         ? instance->do_get_completion_function () : 0;
 }
 
 command_editor::quoting_fcn
 command_editor::get_quoting_function (void)
 {
   return (instance_ok ())
-    ? instance->do_get_quoting_function () : 0;
+         ? instance->do_get_quoting_function () : 0;
 }
 
 command_editor::dequoting_fcn
 command_editor::get_dequoting_function (void)
 {
   return (instance_ok ())
-    ? instance->do_get_dequoting_function () : 0;
+         ? instance->do_get_dequoting_function () : 0;
 }
 
 command_editor::char_is_quoted_fcn
 command_editor::get_char_is_quoted_function (void)
 {
   return (instance_ok ())
-    ? instance->do_get_char_is_quoted_function () : 0;
+         ? instance->do_get_char_is_quoted_function () : 0;
 }
 
 command_editor::user_accept_line_fcn
 command_editor::get_user_accept_line_function (void)
 {
   return (instance_ok ())
-    ? instance->do_get_user_accept_line_function () : 0;
+         ? instance->do_get_user_accept_line_function () : 0;
 }
 
 string_vector
 command_editor::generate_filename_completions (const std::string& text)
 {
   return (instance_ok ())
-    ? instance->do_generate_filename_completions (text) : string_vector ();
+         ? instance->do_generate_filename_completions (text) : string_vector ();
 }
 
 std::string
 command_editor::get_line_buffer (void)
 {
   return (instance_ok ()) ? instance->do_get_line_buffer () : "";
 }
 
@@ -1431,24 +1431,24 @@ command_editor::re_read_init_file (void)
   if (instance_ok ())
     instance->do_re_read_init_file ();
 }
 
 bool
 command_editor::filename_completion_desired (bool arg)
 {
   return (instance_ok ())
-    ? instance->do_filename_completion_desired (arg) : false;
+         ? instance->do_filename_completion_desired (arg) : false;
 }
 
 bool
 command_editor::filename_quoting_desired (bool arg)
 {
   return (instance_ok ())
-    ? instance->do_filename_quoting_desired (arg) : false;
+         ? instance->do_filename_quoting_desired (arg) : false;
 }
 
 bool
 command_editor::interrupt (bool arg)
 {
   bool retval;
 
   if (instance_ok ())
diff --git a/liboctave/util/cmd-edit.h b/liboctave/util/cmd-edit.h
--- a/liboctave/util/cmd-edit.h
+++ b/liboctave/util/cmd-edit.h
@@ -217,21 +217,21 @@ protected:
 
   // To use something other than the GNU readline library, derive a new
   // class from command_editor, overload these functions as
   // necessary, and make instance point to the new class.
 
   virtual void do_set_name (const std::string&) { }
 
   std::string do_readline (const std::string& prompt)
-    {
-      bool eof;
+  {
+    bool eof;
 
-      return do_readline (prompt, eof);
-    }
+    return do_readline (prompt, eof);
+  }
 
   virtual std::string do_readline (const std::string&, bool&) = 0;
 
   virtual void do_set_input_stream (FILE *) = 0;
 
   virtual FILE *do_get_input_stream (void) = 0;
 
   virtual void do_set_output_stream (FILE *) = 0;
@@ -279,21 +279,24 @@ protected:
   virtual void do_set_user_accept_line_function (user_accept_line_fcn) { }
 
   virtual completion_fcn do_get_completion_function (void) const { return 0; }
 
   virtual quoting_fcn do_get_quoting_function (void) const { return 0; }
 
   virtual dequoting_fcn do_get_dequoting_function (void) const { return 0; }
 
-  virtual char_is_quoted_fcn do_get_char_is_quoted_function (void) const { return 0; }
+  virtual char_is_quoted_fcn do_get_char_is_quoted_function (void) const
+  { return 0; }
 
-  virtual user_accept_line_fcn do_get_user_accept_line_function (void) const { return 0; }
+  virtual user_accept_line_fcn do_get_user_accept_line_function (void) const
+  { return 0; }
 
-  virtual string_vector do_generate_filename_completions (const std::string& text) = 0;
+  virtual string_vector
+  do_generate_filename_completions (const std::string& text) = 0;
 
   virtual std::string do_get_line_buffer (void) const = 0;
 
   virtual std::string do_get_current_line (void) const = 0;
 
   virtual void do_replace_line (const std::string& text, bool clear_undo) = 0;
 
   virtual void do_insert_text (const std::string& text) = 0;
diff --git a/liboctave/util/cmd-hist.cc b/liboctave/util/cmd-hist.cc
--- a/liboctave/util/cmd-hist.cc
+++ b/liboctave/util/cmd-hist.cc
@@ -151,19 +151,18 @@ gnu_history::do_process_histcontrol (con
             beg = end + 1;
         }
     }
 }
 
 std::string
 gnu_history::do_histcontrol (void) const
 {
-  // FIXME -- instead of reconstructing this value, should we just save
-  // the string we were given when constructing the command_history
-  // object?
+  // FIXME: instead of reconstructing this value, should we just save
+  // the string we were given when constructing the command_history object?
 
   std::string retval;
 
   if (history_control & HC_IGNSPACE)
     retval.append ("ignorespace");
 
   if (history_control & HC_IGNDUPS)
     {
@@ -187,17 +186,17 @@ gnu_history::do_histcontrol (void) const
 bool
 gnu_history::do_add (const std::string& s)
 {
   if (! do_ignoring_entries ())
     {
       if (s.empty ()
           || (s.length () == 1 && (s[0] == '\r' || s[0] == '\n')))
         return false;
-     
+
       // Strip newline before adding to list
       std::string stmp = s;
       int stmp_len = stmp.length ();
       if (stmp[stmp_len - 1] == '\n')
         stmp.resize (stmp_len - 1);
 
       int added = ::octave_add_history (stmp.c_str (), history_control);
       lines_this_session += added;
@@ -284,17 +283,17 @@ gnu_history::do_goto_mark (void)
           command_editor::insert_text (line);
 
           command_editor::clear_undo_list ();
         }
     }
 
   mark = 0;
 
-  // FIXME -- for operate_and_get_next.
+  // FIXME: for operate_and_get_next.
   command_editor::remove_startup_hook (command_history::goto_mark);
 
   return 0;
 }
 
 void
 gnu_history::do_read (const std::string& f, bool must_exist)
 {
@@ -540,59 +539,59 @@ command_history::set_file (const std::st
       instance->do_set_file (f);
     }
 }
 
 std::string
 command_history::file (void)
 {
   return (instance_ok ())
-    ? instance->do_file () : std::string ();
+         ? instance->do_file () : std::string ();
 }
 
 void
 command_history::process_histcontrol (const std::string& control_arg)
 {
   if (instance_ok ())
     instance->do_process_histcontrol (control_arg);
 }
 
 std::string
 command_history::histcontrol (void)
 {
   return (instance_ok ())
-    ? instance->do_histcontrol () : std::string ();
+         ? instance->do_histcontrol () : std::string ();
 }
 
 void
 command_history::set_size (int n)
 {
   if (instance_ok ())
     instance->do_set_size (n);
 }
 
 int
 command_history::size (void)
 {
   return (instance_ok ())
-    ? instance->do_size () : 0;
+         ? instance->do_size () : 0;
 }
 
 void
 command_history::ignore_entries (bool flag)
 {
   if (instance_ok ())
     instance->do_ignore_entries (flag);
 }
 
 bool
 command_history::ignoring_entries (void)
 {
   return (instance_ok ())
-    ? instance->do_ignoring_entries () : false;
+         ? instance->do_ignoring_entries () : false;
 }
 
 bool
 command_history::add (const std::string& s)
 {
   if (instance_ok ())
     return instance->do_add (s);
   return false;
@@ -611,80 +610,80 @@ command_history::clear (void)
   if (instance_ok ())
     instance->do_clear ();
 }
 
 int
 command_history::where (void)
 {
   return (instance_ok ())
-    ? instance->do_where () : 0;
+         ? instance->do_where () : 0;
 }
 
 int
 command_history::length (void)
 {
   return (instance_ok ())
-    ? instance->do_length () : 0;
+         ? instance->do_length () : 0;
 }
 
 int
 command_history::max_input_history (void)
 {
   return (instance_ok ())
-    ? instance->do_max_input_history () : 0;
+         ? instance->do_max_input_history () : 0;
 }
 
 int
 command_history::base (void)
 {
   return (instance_ok ())
-    ? instance->do_base () : 0;
+         ? instance->do_base () : 0;
 }
 
 int
 command_history::current_number (void)
 {
   return (instance_ok ())
-    ? instance->do_current_number () : 0;
+         ? instance->do_current_number () : 0;
 }
 
 void
 command_history::stifle (int n)
 {
   if (instance_ok ())
     instance->do_stifle (n);
 }
 
 int
 command_history::unstifle (void)
 {
   return (instance_ok ())
-    ? instance->do_unstifle () : 0;
+         ? instance->do_unstifle () : 0;
 }
 
 int
 command_history::is_stifled (void)
 {
   return (instance_ok ())
-    ? instance->do_is_stifled () : 0;
+         ? instance->do_is_stifled () : 0;
 }
 
 void
 command_history::set_mark (int n)
 {
   if (instance_ok ())
     instance->do_set_mark (n);
 }
 
 int
 command_history::goto_mark (void)
 {
   return (instance_ok ())
-    ? instance->do_goto_mark () : 0;
+         ? instance->do_goto_mark () : 0;
 }
 
 void
 command_history::read (bool must_exist)
 {
   read (file (), must_exist);
 }
 
@@ -729,24 +728,24 @@ command_history::truncate_file (const st
   if (instance_ok ())
     instance->do_truncate_file (f, n);
 }
 
 string_vector
 command_history::list (int limit, bool number_lines)
 {
   return (instance_ok ())
-    ? instance->do_list (limit, number_lines) : string_vector ();
+         ? instance->do_list (limit, number_lines) : string_vector ();
 }
 
 std::string
 command_history::get_entry (int n)
 {
   return (instance_ok ())
-    ? instance->do_get_entry (n) : std::string ();
+         ? instance->do_get_entry (n) : std::string ();
 }
 
 void
 command_history::replace_entry (int which, const std::string& line)
 {
   if (instance_ok ())
     instance->do_replace_entry (which, line);
 }
diff --git a/liboctave/util/cmd-hist.h b/liboctave/util/cmd-hist.h
--- a/liboctave/util/cmd-hist.h
+++ b/liboctave/util/cmd-hist.h
@@ -139,17 +139,18 @@ protected:
   virtual void do_set_file (const std::string&);
 
   virtual std::string do_file (void);
 
   virtual void do_process_histcontrol (const std::string&);
 
   virtual std::string do_histcontrol (void) const { return std::string (); }
 
-  virtual void do_initialize (bool, const std::string&, int, const std::string&);
+  virtual void do_initialize (bool, const std::string&, int,
+                              const std::string&);
 
   virtual bool do_is_initialized (void) const;
 
   virtual void do_set_size (int);
 
   virtual int do_size (void) const;
 
   virtual void do_ignore_entries (bool);
diff --git a/liboctave/util/data-conv.cc b/liboctave/util/data-conv.cc
--- a/liboctave/util/data-conv.cc
+++ b/liboctave/util/data-conv.cc
@@ -354,20 +354,19 @@ oct_data_conv::string_to_data_type (cons
   if (retval == dt_unknown)
     (*current_liboctave_error_handler)
       ("unable to find matching native data type for %s", s.c_str ());
 
   return retval;
 }
 
 void
-oct_data_conv::string_to_data_type
-  (const std::string& str, int& block_size,
-   oct_data_conv::data_type& input_type,
-   oct_data_conv::data_type& output_type)
+oct_data_conv::string_to_data_type (const std::string& str, int& block_size,
+                                    oct_data_conv::data_type& input_type,
+                                    oct_data_conv::data_type& output_type)
 {
   block_size = 1;
   input_type = dt_uchar;
   output_type = dt_double;
 
   bool input_is_output = false;
 
   std::string s = strip_spaces (str);
@@ -435,19 +434,18 @@ oct_data_conv::string_to_data_type
       input_type = string_to_data_type (s);
 
       if (input_is_output)
         output_type = input_type;
     }
 }
 
 void
-oct_data_conv::string_to_data_type
-  (const std::string& str, int& block_size,
-   oct_data_conv::data_type& output_type)
+oct_data_conv::string_to_data_type (const std::string& str, int& block_size,
+                                    oct_data_conv::data_type& output_type)
 {
   block_size = 1;
   output_type = dt_double;
 
   std::string s = strip_spaces (str);
 
   size_t pos = 0;
 
@@ -627,19 +625,19 @@ gripe_unrecognized_float_fmt (void)
     ("unrecognized floating point format requested");
 }
 
 // But first, some data conversion routines.
 
 // Currently, we only handle conversions for the IEEE types.  To fix
 // that, make more of the following routines work.
 
-// FIXME -- assumes sizeof (Complex) == 8
-// FIXME -- assumes sizeof (double) == 8
-// FIXME -- assumes sizeof (float) == 4
+// FIXME: assumes sizeof (Complex) == 8
+// FIXME: assumes sizeof (double) == 8
+// FIXME: assumes sizeof (float) == 4
 
 static void
 IEEE_big_double_to_IEEE_little_double (void *d, octave_idx_type len)
 {
   swap_bytes<8> (d, len);
 }
 
 static void
diff --git a/liboctave/util/data-conv.h b/liboctave/util/data-conv.h
--- a/liboctave/util/data-conv.h
+++ b/liboctave/util/data-conv.h
@@ -30,42 +30,42 @@ along with Octave; see the file COPYING.
 
 class
 OCTAVE_API
 oct_data_conv
 {
 public:
 
   enum data_type
-    {
-      dt_int8      =  0,
-      dt_uint8     =  1,
-      dt_int16     =  2,
-      dt_uint16    =  3,
-      dt_int32     =  4,
-      dt_uint32    =  5,
-      dt_int64     =  6,
-      dt_uint64    =  7,
-      dt_single    =  8,
-      dt_double    =  9,
-      dt_char      = 10,
-      dt_schar     = 11,
-      dt_uchar     = 12,
-      dt_logical   = 13,
-      dt_short     = 14,
-      dt_ushort    = 15,
-      dt_int       = 16,
-      dt_uint      = 17,
-      dt_long      = 18,
-      dt_ulong     = 19,
-      dt_longlong  = 20,
-      dt_ulonglong = 21,
-      dt_float     = 22,
-      dt_unknown   = 23 // Must be last, have largest value!
-    };
+  {
+    dt_int8      =  0,
+    dt_uint8     =  1,
+    dt_int16     =  2,
+    dt_uint16    =  3,
+    dt_int32     =  4,
+    dt_uint32    =  5,
+    dt_int64     =  6,
+    dt_uint64    =  7,
+    dt_single    =  8,
+    dt_double    =  9,
+    dt_char      = 10,
+    dt_schar     = 11,
+    dt_uchar     = 12,
+    dt_logical   = 13,
+    dt_short     = 14,
+    dt_ushort    = 15,
+    dt_int       = 16,
+    dt_uint      = 17,
+    dt_long      = 18,
+    dt_ulong     = 19,
+    dt_longlong  = 20,
+    dt_ulonglong = 21,
+    dt_float     = 22,
+    dt_unknown   = 23 // Must be last, have largest value!
+  };
 
   static size_t data_type_size (data_type dt);
 
   static data_type string_to_data_type (const std::string& s);
 
   static void string_to_data_type (const std::string& s, int& block_size,
                                    data_type& input_type,
                                    data_type& output_type);
@@ -76,46 +76,46 @@ public:
   static std::string data_type_as_string (data_type dt);
 };
 
 // Add new entries to the end of this enum, otherwise Octave will not
 // be able to read binary data files stored in Octave's binary data
 // format that were created with previous versions of Octave.
 
 enum save_type
-  {
-    LS_U_CHAR  = 0,
-    LS_U_SHORT = 1,
-    LS_U_INT   = 2,
-    LS_CHAR    = 3,
-    LS_SHORT   = 4,
-    LS_INT     = 5,
-    LS_FLOAT   = 6,
-    LS_DOUBLE  = 7,
-    LS_U_LONG  = 8,
-    LS_LONG    = 9
-  };
+{
+  LS_U_CHAR  = 0,
+  LS_U_SHORT = 1,
+  LS_U_INT   = 2,
+  LS_CHAR    = 3,
+  LS_SHORT   = 4,
+  LS_INT     = 5,
+  LS_FLOAT   = 6,
+  LS_DOUBLE  = 7,
+  LS_U_LONG  = 8,
+  LS_LONG    = 9
+};
 
 extern OCTAVE_API void
 do_double_format_conversion (void *data, octave_idx_type len,
                              oct_mach_info::float_format from_fmt,
                              oct_mach_info::float_format to_fmt
-                               = oct_mach_info::native_float_format ());
+                             = oct_mach_info::native_float_format ());
 
 extern OCTAVE_API void
 do_float_format_conversion (void *data, octave_idx_type len,
                             oct_mach_info::float_format from_fmt,
                             oct_mach_info::float_format to_fmt
-                              = oct_mach_info::native_float_format ());
+                            = oct_mach_info::native_float_format ());
 
 extern OCTAVE_API void
 do_float_format_conversion (void *data, size_t sz, octave_idx_type len,
                             oct_mach_info::float_format from_fmt,
                             oct_mach_info::float_format to_fmt
-                              = oct_mach_info::native_float_format ());
+                            = oct_mach_info::native_float_format ());
 
 extern OCTAVE_API void
 read_doubles (std::istream& is, double *data, save_type type,
               octave_idx_type len, bool swap, oct_mach_info::float_format fmt);
 
 extern OCTAVE_API void
 write_doubles (std::ostream& os, const double *data, save_type type,
                octave_idx_type len);
diff --git a/liboctave/util/kpse.cc b/liboctave/util/kpse.cc
--- a/liboctave/util/kpse.cc
+++ b/liboctave/util/kpse.cc
@@ -451,65 +451,65 @@ public:
 
   kpse_path_iterator (const std::string& p)
     : path (p), b (0), e (0), len (path.length ()) { set_end (); }
 
   kpse_path_iterator (const kpse_path_iterator& pi)
     : path (pi.path), b (pi.b), e (pi.e), len (pi.len) { }
 
   kpse_path_iterator operator ++ (int)
-    {
-      kpse_path_iterator retval (*this);
-      next ();
-      return retval;
-    }
+  {
+    kpse_path_iterator retval (*this);
+    next ();
+    return retval;
+  }
 
   std::string operator * (void) { return path.substr (b, e-b); }
 
   bool operator != (const size_t sz) { return b != sz; }
 
 private:
 
   const std::string& path;
   size_t b;
   size_t e;
   size_t len;
 
   void set_end (void)
-    {
-      e = b + 1;
-
-      if (e == len)
-        ; /* OK, we have found the last element.  */
-      else if (e > len)
-        b = e = std::string::npos;
-      else
-        {
-          /* Find the next colon not enclosed by braces (or the end of
-             the path).  */
-
-          int brace_level = 0;
-          while (e < len && ! (brace_level == 0 && kpse_is_env_sep (path[e])))
-            e++;
-        }
-    }
+  {
+    e = b + 1;
+
+    if (e == len)
+      ; /* OK, we have found the last element.  */
+    else if (e > len)
+      b = e = std::string::npos;
+    else
+      {
+        /* Find the next colon not enclosed by braces (or the end of
+           the path).  */
+
+        int brace_level = 0;
+        while (e < len && ! (brace_level == 0 && kpse_is_env_sep (path[e])))
+          e++;
+      }
+  }
 
   void next (void)
-    {
-      b = e + 1;
-
-      /* Skip any consecutive colons.  */
-      while (b < len && kpse_is_env_sep (path[b]))
-        b++;
-
-      if (b >= len)
-        b = e = std::string::npos;
-      else
-        set_end ();
-    }
+  {
+    b = e + 1;
+
+    /* Skip any consecutive colons.  */
+    while (b < len && kpse_is_env_sep (path[b]))
+      b++;
+
+    if (b >= len)
+      b = e = std::string::npos;
+    else
+      set_end ();
+  }
 
   // No assignment.
   kpse_path_iterator& operator = (const kpse_path_iterator&);
 };
 
 /* Here's the simple one, when a program just wants a value.  */
 
 static std::string
@@ -643,24 +643,24 @@ kpse_readable_file (const std::string& n
 
 static bool
 kpse_absolute_p (const std::string& filename, int relative_ok)
 {
   size_t len = filename.length ();
 
   int absolute = (len > 0 && IS_DIR_SEP (filename[0]))
 #ifdef DOSISH
-                     /* Novell allows non-alphanumeric drive letters. */
-    || (len > 0 && IS_DEVICE_SEP (filename[1]))
+                 /* Novell allows non-alphanumeric drive letters. */
+                 || (len > 0 && IS_DEVICE_SEP (filename[1]))
 #endif /* DOSISH */
 #ifdef WIN32
-                     /* UNC names */
-    || (len > 1 && filename[0] == '\\' && filename[1] == '\\')
+                 /* UNC names */
+                 || (len > 1 && filename[0] == '\\' && filename[1] == '\\')
 #endif
-    ;
+                 ;
 
   int explicit_relative
     = relative_ok
       && (len > 1
           && filename[0] == '.'
           && (IS_DIR_SEP (filename[1])
               || (len > 2 && filename[1] == '.' && IS_DIR_SEP (filename[2]))));
 
@@ -706,18 +706,18 @@ log_search (const string_vector& filenam
       /* FILENAMES should never be null, but safety doesn't hurt.  */
       for (int e = 0; e < filenames.length () && ! filenames[e].empty (); e++)
         {
           std::string filename = filenames[e];
 
           /* Only record absolute filenames, for privacy.  */
           if (log_file && kpse_absolute_p (filename.c_str (), false))
             gnulib::fprintf (log_file, "%lu %s\n",
-                     static_cast<unsigned long> (time (0)),
-                     filename.c_str ());
+                             static_cast<unsigned long> (time (0)),
+                             filename.c_str ());
 
           /* And show them online, if debugging.  We've already started
              the debugging line in 'search', where this is called, so
              just print the filename here, don't use DEBUGF.  */
           if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
             gnulib::fputs (filename.c_str (), stderr);
         }
     }
@@ -821,18 +821,17 @@ path_search (const std::string& path, co
           /* We never want to search the whole disk.  */
           while (elt.length () > 1
                  && IS_DIR_SEP (elt[0]) && IS_DIR_SEP (elt[1]))
             elt = elt.substr (1);
         }
 
       /* Try ls-R, unless we're searching for texmf.cnf.  Our caller
          (search), also tests first_search, and does the resetting.  */
-      found = first_search
-        ? string_vector () : kpse_db_search (name, elt, all);
+      found = first_search ? string_vector () : kpse_db_search (name, elt, all);
 
       /* Search the filesystem if (1) the path spec allows it, and either
          (2a) we are searching for texmf.cnf ; or
          (2b) no db exists; or
          (2c) no db's are relevant to this elt; or
          (3) MUST_EXIST && NAME was not in the db.
          In (2*), 'found' will be NULL.
          In (3),  'found' will be an empty list. */
@@ -1014,18 +1013,18 @@ path_find_first_of (const std::string& p
           int len = names.length ();
           for (int i = 0; i < len && !done; i++)
             {
               std::string name = names[i];
 
               /* Try ls-R, unless we're searching for texmf.cnf.  Our caller
                  (find_first_of), also tests first_search, and does the
                  resetting.  */
-              found = first_search
-                ? string_vector () : kpse_db_search (name, dir.c_str (), all);
+              found = first_search ? string_vector ()
+                                   : kpse_db_search (name, dir.c_str (), all);
 
               /* Search the filesystem if (1) the path spec allows it,
                  and either
 
                    (2a) we are searching for texmf.cnf ; or
                    (2b) no db exists; or
                    (2c) no db's are relevant to this elt; or
                    (3) MUST_EXIST && NAME was not in the db.
@@ -1656,17 +1655,17 @@ brace_gobbler (const std::string& text, 
              an open brace followed immediately by a close brace, that
              was preceded with whitespace.  */
           if (c == '{' &&
               ((i == 0 || brace_whitespace (text[i-1])) &&
                (i+1 < text_len &&
                 (brace_whitespace (text[i+1]) || text[i+1] == '}'))))
             continue;
           /* If this is being compiled as part of bash, ignore the '{'
-             in a '${}' construct */
+             in a '${ }' construct */
           if ((c != '{') || i == 0 || (text[i-1] != '$'))
             break;
         }
 
       if (c == '{')
         level++;
       else if (c == '}' && level)
         level--;
@@ -1824,18 +1823,18 @@ elt_in_db (const std::string& db_dir, co
 
   while (! found && db_dir[i] == path_elt[i])
     {
       i++;
       /* If we've matched the entire db directory, it's good.  */
       if (i == db_dir_len)
         found = true;
 
-    /* If we've reached the end of PATH_ELT, but not the end of the db
-       directory, it's no good.  */
+      /* If we've reached the end of PATH_ELT, but not the end of the db
+         directory, it's no good.  */
       else if (i == path_elt_len)
         break;
     }
 
   return found;
 }
 
 /* Avoid doing anything if this PATH_ELT is irrelevant to the databases. */
@@ -1916,17 +1915,18 @@ kpse_db_search (const std::string& name_
       int db_dirs_len = db_dirs.length ();
       for (int j = 0; j < db_dirs_len && !done; j++)
         {
           std::string db_file = db_dirs[j] + atry;
           bool matched = match (db_file, path_elt);
 
 #ifdef KPSE_DEBUG
           if (KPSE_DEBUG_P (KPSE_DEBUG_SEARCH))
-            DEBUGF3 ("db:match (%s,%s) = %d\n", db_file.c_str (), path_elt.c_str (), matched);
+            DEBUGF3 ("db:match (%s,%s) = %d\n",
+                     db_file.c_str (), path_elt.c_str (), matched);
 #endif
 
           /* We got a hit in the database.  Now see if the file actually
              exists, possibly under an alias.  */
           if (matched)
             {
               std::string found;
               std::string tmp = kpse_readable_file (db_file);
@@ -2164,17 +2164,17 @@ dir_links (const std::string& fn)
 
   if (link_table.find (fn) != link_table.end ())
     ret = link_table[fn];
   else
     {
       struct stat stats;
 
       ret = stat (fn.c_str (), &stats) == 0 && S_ISDIR (stats.st_mode)
-        ? stats.st_nlink : static_cast<unsigned> (-1);
+            ? stats.st_nlink : static_cast<unsigned> (-1);
 
       link_table[fn] = ret;
 
 #ifdef KPSE_DEBUG
       if (KPSE_DEBUG_P (KPSE_DEBUG_STAT))
         DEBUGF2 ("dir_links (%s) => %ld\n", fn.c_str (), ret);
 #endif
     }
@@ -2477,17 +2477,18 @@ str_llist_float (str_llist_type *l, str_
      guaranteed this will terminate, since MOVER itself is currently
      unmoved, and it must be in L (by hypothesis).  */
   for (last_moved = 0, unmoved = *l; STR_LLIST_MOVED (*unmoved);
        last_moved = unmoved, unmoved = STR_LLIST_NEXT (*unmoved))
     ;
 
   /* If we are the first unmoved element, nothing to relink.  */
   if (unmoved != mover)
-    { /* Remember 'mover's current successor, so we can relink 'mover's
+    {
+      /* Remember 'mover's current successor, so we can relink 'mover's
          predecessor to it.  */
       str_llist_elt_type *before_mover;
       str_llist_elt_type *after_mover = STR_LLIST_NEXT (*mover);
 
       /* Find 'mover's predecessor.  */
       for (before_mover = unmoved; STR_LLIST_NEXT (*before_mover) != mover;
            before_mover = STR_LLIST_NEXT (*before_mover))
         ;
@@ -2524,18 +2525,17 @@ expanding (const std::string& var, bool 
   expansions[var] = xp;
 }
 
 /* Return whether VAR is currently being expanding.  */
 
 static bool
 expanding_p (const std::string& var)
 {
-  return (expansions.find (var) != expansions.end ())
-    ? expansions[var] : false;
+  return (expansions.find (var) != expansions.end ()) ? expansions[var] : false;
 }
 
 /* Append the result of value of 'var' to EXPANSION, where 'var' begins
    at START and ends at END.  If 'var' is not set, do not complain.
    This is a subroutine for the more complicated expansion function.  */
 
 static void
 expand (std::string &expansion, const std::string& var)
diff --git a/liboctave/util/lo-array-gripes.cc b/liboctave/util/lo-array-gripes.cc
--- a/liboctave/util/lo-array-gripes.cc
+++ b/liboctave/util/lo-array-gripes.cc
@@ -132,17 +132,17 @@ gripe_invalid_index (void)
   (*current_liboctave_error_with_id_handler)
 #ifdef USE_64_BIT_IDX_T
     (err_id, "subscript indices must be either positive integers less than 2^63 or logicals");
 #else
     (err_id, "subscript indices must be either positive integers less than 2^31 or logicals");
 #endif
 }
 
-// FIXME -- the following is a common error message to resize,
+// FIXME: the following is a common error message to resize,
 // regardless of whether it's called from assign or elsewhere.  It
 // seems OK to me, but eventually the gripe can be specialized.
 // Anyway, propagating various error messages into procedure is, IMHO,
 // a nonsense.  If anything, we should change error handling here (and
 // throughout liboctave) to allow custom handling of errors
 
 void
 gripe_invalid_resize (void)
diff --git a/liboctave/util/lo-cieee.c b/liboctave/util/lo-cieee.c
--- a/liboctave/util/lo-cieee.c
+++ b/liboctave/util/lo-cieee.c
@@ -162,19 +162,19 @@ lo_ieee_nan_value (void)
 
 #if ! (defined (signbit) || defined (HAVE_DECL_SIGNBIT)) && defined (HAVE_SIGNBIT)
 extern int signbit (double);
 #endif
 
 int
 __lo_ieee_signbit (double x)
 {
-/* In the following definitions, only check x < 0 explicitly to avoid
-   a function call when it looks like signbit or copysign are actually
-   functions.  */
+  /* In the following definitions, only check x < 0 explicitly to avoid
+     a function call when it looks like signbit or copysign are actually
+     functions.  */
 
 #if defined (signbit)
   return signbit (x);
 #elif defined (HAVE_SIGNBIT)
   return (x < 0 || signbit (x));
 #elif defined (copysign)
   return (copysign (1.0, x) < 0);
 #elif defined (HAVE_COPYSIGN)
@@ -256,19 +256,19 @@ lo_ieee_float_nan_value (void)
 
 #if ! (defined (signbit) || defined (HAVE_DECL_SIGNBIT)) && defined (HAVE_SIGNBIT)
 extern int signbit (float);
 #endif
 
 int
 __lo_ieee_float_signbit (float x)
 {
-/* In the following definitions, only check x < 0 explicitly to avoid
-   a function call when it looks like signbit or copysign are actually
-   functions.  */
+  /* In the following definitions, only check x < 0 explicitly to avoid
+     a function call when it looks like signbit or copysign are actually
+     functions.  */
 
 #if defined (signbit)
   return signbit (x);
 #elif defined (HAVE_SIGNBIT)
   return (x < 0 || signbit (x));
 #elif defined (copysign)
   return (copysign (1.0, x) < 0);
 #elif defined (HAVE_COPYSIGN)
diff --git a/liboctave/util/lo-regexp.cc b/liboctave/util/lo-regexp.cc
--- a/liboctave/util/lo-regexp.cc
+++ b/liboctave/util/lo-regexp.cc
@@ -40,27 +40,27 @@ along with Octave; see the file COPYING.
 #include "Matrix.h"
 #include "base-list.h"
 #include "lo-error.h"
 #include "oct-locbuf.h"
 #include "quit.h"
 #include "lo-regexp.h"
 #include "str-vec.h"
 
-// Define the maximum number of retries for a pattern that possibly
-// results in an infinite recursion.
+// Define the maximum number of retries for a pattern
+// that possibly results in an infinite recursion.
 #define PCRE_MATCHLIMIT_MAX 10
 
-// FIXME -- should this be configurable?
+// FIXME: should this be configurable?
 #define MAXLOOKBEHIND 10
 
 static bool lookbehind_warned = false;
 
-// FIXME -- don't bother collecting and composing return values the user
-// doesn't want.
+// FIXME: don't bother collecting and composing return values
+//        the user doesn't want.
 
 void
 regexp::free (void)
 {
   if (data)
     pcre_free (static_cast<pcre *> (data));
 }
 
@@ -176,17 +176,17 @@ regexp::compile_internal (void)
 
               if (tmp_pos3 != std::string::npos && tmp_pos3 < tmp_pos1)
                 {
                   if (!lookbehind_warned)
                     {
                       lookbehind_warned = true;
                       (*current_liboctave_warning_handler)
                         ("%s: arbitrary length lookbehind patterns are only supported up to length %d",
-                               who.c_str (), MAXLOOKBEHIND);
+                         who.c_str (), MAXLOOKBEHIND);
                     }
 
                   buf << pattern.substr (pos, new_pos - pos) << "(";
 
                   size_t i;
 
                   if (pattern.at (tmp_pos3) == '*')
                     i = 0;
@@ -261,17 +261,17 @@ regexp::match (const std::string& buffer
   OCTAVE_LOCAL_BUFFER (int, ovector, (subpatterns+1)*3);
   OCTAVE_LOCAL_BUFFER (int, nidx, namecount);
 
   for (int i = 0; i < namecount; i++)
     {
       // Index of subpattern in first two bytes MSB first of name.
       // Extract index.
       nidx[i] = (static_cast<int> (nametable[i*nameentrysize])) << 8
-        | static_cast<int> (nametable[i*nameentrysize+1]);
+                | static_cast<int> (nametable[i*nameentrysize+1]);
     }
 
   while (true)
     {
       OCTAVE_QUIT;
 
       int matches = pcre_exec (re, 0, buffer.c_str (),
                                buffer.length (), idx,
@@ -367,23 +367,23 @@ regexp::match (const std::string& buffer
               if (ovector[2*i] >= 0 && ovector[2*i+1] > 0)
                 {
                   if (i == 1 || ovector[2*i] != ovector[2*i-2]
                       || ovector[2*i-1] != ovector[2*i+1])
                     {
                       if (namecount > 0)
                         {
                           // FIXME: Should probably do this with a map()
-                          // rather than a linear search.  However,
-                          // the number of captured, named expressions
-                          // is usually pretty small (< 4)
+                          //        rather than a linear search.  However,
+                          //        the number of captured, named expressions
+                          //        is usually pretty small (< 4)
                           for (int j = 0; j < namecount; j++)
                             {
                               if (nidx[j] == i)
-                                { 
+                                {
                                   named_tokens(named_idx(j)) =
                                     std::string (*(listptr+i-pos_offset));
                                   break;
                                 }
                             }
                         }
 
                       tokens(pos_match++) = std::string (*(listptr+i));
@@ -397,23 +397,23 @@ regexp::match (const std::string& buffer
 
           pcre_free_substring_list (listptr);
 
           regexp::match_element new_elem (named_tokens, tokens, match_string,
                                           token_extents, start, end);
           lst.push_back (new_elem);
 
           if (ovector[1] <= ovector[0])
-          {
-            // Zero length match.  Skip to next char.
-            idx = ovector[0] + 1;
-            if (idx <= buffer.length ())
-              continue;
-          }
-          else 
+            {
+              // Zero length match.  Skip to next char.
+              idx = ovector[0] + 1;
+              if (idx <= buffer.length ())
+                continue;
+            }
+          else
             idx = ovector[1];
 
           if (options.once () || idx >= buffer.length ())
             break;
         }
     }
 
   retval = regexp::match_data (lst, named_pats);
@@ -439,20 +439,20 @@ regexp::is_match (const string_vector& b
   for (octave_idx_type i = 0; i < buffer.length (); i++)
     retval(i) = is_match (buffer(i));
 
   return retval;
 }
 
 // Declare rep_token_t used in processing replacement string
 typedef struct
-  {
-    size_t pos;
-    int num;
-  } rep_token_t;
+{
+  size_t pos;
+  int num;
+} rep_token_t;
 
 
 std::string
 regexp::replace (const std::string& buffer, const std::string& replacement)
 {
   std::string retval;
 
   regexp::match_data rx_lst = match (buffer);
diff --git a/liboctave/util/lo-utils.cc b/liboctave/util/lo-utils.cc
--- a/liboctave/util/lo-utils.cc
+++ b/liboctave/util/lo-utils.cc
@@ -243,17 +243,17 @@ read_inf_nan_na (std::istream& is, char 
 // Read a double value.  Discard any sign on NaN and NA.
 
 template <typename T>
 double
 octave_read_fp_value (std::istream& is)
 {
   T val = 0.0;
 
-  // FIXME -- resetting stream position is likely to fail unless we are
+  // FIXME: resetting stream position is likely to fail unless we are
   // reading from a file.
   std::ios::streampos pos = is.tellg ();
 
   char c1 = ' ';
 
   while (isspace (c1))
     c1 = is.get ();
 
diff --git a/liboctave/util/oct-alloc.cc b/liboctave/util/oct-alloc.cc
--- a/liboctave/util/oct-alloc.cc
+++ b/liboctave/util/oct-alloc.cc
@@ -40,17 +40,17 @@ octave_allocator::alloc (size_t size)
         return 0;
     }
 
   link *tmp = head;
   head = head->next;
   return tmp;
 }
 
-// FIXME -- if we free the last item on the list, shouldn't we
+// FIXME: if we free the last item on the list, shouldn't we
 // also free the underlying character array used for storage?
 
 void
 octave_allocator::free (void *p, size_t size)
 {
   if (size != item_size)
     ::delete [] (static_cast<char *> (p));
   else
diff --git a/liboctave/util/oct-base64.cc b/liboctave/util/oct-base64.cc
--- a/liboctave/util/oct-base64.cc
+++ b/liboctave/util/oct-base64.cc
@@ -28,21 +28,21 @@ along with Octave; see the file COPYING.
 
 #include <base64.h>
 
 #include "Array.h"
 #include "oct-base64.h"
 
 bool
 octave_base64_encode (const char *inc, const size_t inlen, char **out)
-{  
+{
   bool ret = false;
 
   size_t outlen = base64_encode_alloc (inc, inlen, out);
-  
+
   if (! out)
     {
       if (outlen == 0 && inlen != 0)
         (*current_liboctave_error_handler)
           ("base64_encode: input array too large");
       else
         (*current_liboctave_error_handler)
           ("base64_encode: memory allocation error");
diff --git a/liboctave/util/oct-binmap.h b/liboctave/util/oct-binmap.h
--- a/liboctave/util/oct-binmap.h
+++ b/liboctave/util/oct-binmap.h
@@ -335,128 +335,136 @@ binmap (const Sparse<T>& xs, const Spars
 }
 
 // Overloads for function pointers.
 
 // Signature (T, R)
 
 template <class U, class T, class R>
 inline Array<U>
-binmap (const Array<T>& xa, const Array<R>& ya, U (*fcn) (T, R), const char *name)
+binmap (const Array<T>& xa, const Array<R>& ya, U (*fcn) (T, R),
+        const char *name)
 { return binmap<U, T, R, U (*) (T, R)> (xa, ya, fcn, name); }
 
 template <class U, class T, class R>
 inline Array<U>
 binmap (const T& x, const Array<R>& ya, U (*fcn) (T, R))
 { return binmap<U, T, R, U (*) (T, R)> (x, ya, fcn); }
 
 template <class U, class T, class R>
 inline Array<U>
 binmap (const Array<T>& xa, const R& y, U (*fcn) (T, R))
 { return binmap<U, T, R, U (*) (T, R)> (xa, y, fcn); }
 
 template <class U, class T, class R>
 inline Sparse<U>
-binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (*fcn) (T, R), const char *name)
+binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (*fcn) (T, R),
+        const char *name)
 { return binmap<U, T, R, U (*) (T, R)> (xa, ya, fcn, name); }
 
 template <class U, class T, class R>
 inline Sparse<U>
 binmap (const T& x, const Sparse<R>& ya, U (*fcn) (T, R))
 { return binmap<U, T, R, U (*) (T, R)> (x, ya, fcn); }
 
 template <class U, class T, class R>
 inline Sparse<U>
 binmap (const Sparse<T>& xa, const R& y, U (*fcn) (T, R))
 { return binmap<U, T, R, U (*) (T, R)> (xa, y, fcn); }
 
 // Signature (const T&, const R&)
 
 template <class U, class T, class R>
 inline Array<U>
-binmap (const Array<T>& xa, const Array<R>& ya, U (*fcn) (const T&, const R&), const char *name)
+binmap (const Array<T>& xa, const Array<R>& ya, U (*fcn) (const T&, const R&),
+        const char *name)
 { return binmap<U, T, R, U (*) (const T&, const R&)> (xa, ya, fcn, name); }
 
 template <class U, class T, class R>
 inline Array<U>
 binmap (const T& x, const Array<R>& ya, U (*fcn) (const T&, const R&))
 { return binmap<U, T, R, U (*) (const T&, const R&)> (x, ya, fcn); }
 
 template <class U, class T, class R>
 inline Array<U>
 binmap (const Array<T>& xa, const R& y, U (*fcn) (const T&, const R&))
 { return binmap<U, T, R, U (*) (const T&, const R&)> (xa, y, fcn); }
 
 template <class U, class T, class R>
 inline Sparse<U>
-binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (*fcn) (const T&, const R&), const char *name)
+binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (*fcn) (const T&, const R&),
+        const char *name)
 { return binmap<U, T, R, U (*) (const T&, const R&)> (xa, ya, fcn, name); }
 
 template <class U, class T, class R>
 inline Sparse<U>
 binmap (const T& x, const Sparse<R>& ya, U (*fcn) (const T&, const R&))
 { return binmap<U, T, R, U (*) (const T&, const R&)> (x, ya, fcn); }
 
 template <class U, class T, class R>
 inline Sparse<U>
 binmap (const Sparse<T>& xa, const R& y, U (*fcn) (const T&, const R&))
 { return binmap<U, T, R, U (*) (const T&, const R&)> (xa, y, fcn); }
 
 // Signature (const T&, R)
 
 template <class U, class T, class R>
 inline Array<U>
-binmap (const Array<T>& xa, const Array<R>& ya, U (*fcn) (const T&, R), const char *name)
+binmap (const Array<T>& xa, const Array<R>& ya, U (*fcn) (const T&, R),
+        const char *name)
 { return binmap<U, T, R, U (*) (const T&, R)> (xa, ya, fcn, name); }
 
 template <class U, class T, class R>
 inline Array<U>
 binmap (const T& x, const Array<R>& ya, U (*fcn) (const T&, R))
 { return binmap<U, T, R, U (*) (const T&, R)> (x, ya, fcn); }
 
 template <class U, class T, class R>
 inline Array<U>
 binmap (const Array<T>& xa, const R& y, U (*fcn) (const T&, R))
 { return binmap<U, T, R, U (*) (const T&, R)> (xa, y, fcn); }
 
 template <class U, class T, class R>
 inline Sparse<U>
-binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (*fcn) (const T&, R), const char *name)
+binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (*fcn) (const T&, R),
+        const char *name)
 { return binmap<U, T, R, U (*) (const T&, R)> (xa, ya, fcn, name); }
 
 template <class U, class T, class R>
 inline Sparse<U>
 binmap (const T& x, const Sparse<R>& ya, U (*fcn) (const T&, R))
 { return binmap<U, T, R, U (*) (const T&, R)> (x, ya, fcn); }
 
 template <class U, class T, class R>
 inline Sparse<U>
 binmap (const Sparse<T>& xa, const R& y, U (*fcn) (const T&, R))
 { return binmap<U, T, R, U (*) (const T&, R)> (xa, y, fcn); }
 
 // Signature (T, const R&)
 
 template <class U, class T, class R>
 inline Array<U>
-binmap (const Array<T>& xa, const Array<R>& ya, U (*fcn) (T, const R&), const char *name)
+binmap (const Array<T>& xa, const Array<R>& ya, U (*fcn) (T, const R&),
+        const char *name)
 { return binmap<U, T, R, U (*) (T, const R&)> (xa, ya, fcn, name); }
 
 template <class U, class T, class R>
 inline Array<U>
 binmap (const T& x, const Array<R>& ya, U (*fcn) (T, const R&))
 { return binmap<U, T, R, U (*) (T, const R&)> (x, ya, fcn); }
 
 template <class U, class T, class R>
 inline Array<U>
 binmap (const Array<T>& xa, const R& y, U (*fcn) (T, const R&))
 { return binmap<U, T, R, U (*) (T, const R&)> (xa, y, fcn); }
 
 template <class U, class T, class R>
 inline Sparse<U>
-binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (*fcn) (T, const R&), const char *name)
+binmap (const Sparse<T>& xa, const Sparse<R>& ya, U (*fcn) (T, const R&),
+        const char *name)
 { return binmap<U, T, R, U (*) (T, const R&)> (xa, ya, fcn, name); }
 
 template <class U, class T, class R>
 inline Sparse<U>
 binmap (const T& x, const Sparse<R>& ya, U (*fcn) (T, const R&))
 { return binmap<U, T, R, U (*) (T, const R&)> (x, ya, fcn); }
 
 template <class U, class T, class R>
diff --git a/liboctave/util/oct-cmplx.h b/liboctave/util/oct-cmplx.h
--- a/liboctave/util/oct-cmplx.h
+++ b/liboctave/util/oct-cmplx.h
@@ -24,22 +24,22 @@ along with Octave; see the file COPYING.
 #if !defined (octave_oct_cmplx_h)
 #define octave_oct_cmplx_h 1
 
 #include <complex>
 
 typedef std::complex<double> Complex;
 typedef std::complex<float> FloatComplex;
 
-// For complex-complex and complex-real comparisons, we use the following ordering:
-// compare absolute values first; if they match, compare phase angles.
+// For complex-complex and complex-real comparisons, we use the following
+// ordering: compare absolute values first; if they match, compare phase angles.
 // This is partially inconsistent with M*b, which compares complex numbers only
 // by their real parts; OTOH, it uses the same definition for max/min and sort.
-// The abs/arg comparison is definitely more useful (the other one is emulated rather
-// trivially), so let's be consistent and use that all over.
+// The abs/arg comparison is definitely more useful (the other one is emulated
+// rather trivially), so let's be consistent and use that all over.
 
 #define DEF_COMPLEXR_COMP(OP, OPS) \
 template <class T> \
 inline bool operator OP (const std::complex<T>& a, const std::complex<T>& b) \
 { \
   FLOAT_TRUNCATE const T ax = std::abs (a), bx = std::abs (b); \
   if (ax == bx) \
     { \
diff --git a/liboctave/util/oct-glob.cc b/liboctave/util/oct-glob.cc
--- a/liboctave/util/oct-glob.cc
+++ b/liboctave/util/oct-glob.cc
@@ -76,50 +76,50 @@ octave_glob (const string_vector& pat)
       std::string xpat = pat(i);
 
       if (! xpat.empty ())
         {
           glob_t glob_info;
 
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) \
           && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
-              std::replace_if (xpat.begin (), xpat.end (),
-                               std::bind2nd (std::equal_to<char> (), '\\'),
-                               '/');
+          std::replace_if (xpat.begin (), xpat.end (),
+                           std::bind2nd (std::equal_to<char> (), '\\'),
+                           '/');
 #endif
 
           int err = gnulib::glob (xpat.c_str (), GLOB_NOSORT, 0, &glob_info);
 
           if (! err)
             {
               int n = glob_info.gl_pathc;
 
               const char * const *matches = glob_info.gl_pathv;
 
-              // FIXME -- we shouldn't have to check to see if
+              // FIXME: we shouldn't have to check to see if
               // a single match exists, but it seems that glob() won't
               // check for us unless the pattern contains globbing
               // characters.  Hmm.
 
               if (n > 1
                   || (n == 1
                       && single_match_exists (std::string (matches[0]))))
                 {
                   retval.resize (k+n);
 
                   for (int j = 0; j < n; j++)
                     {
                       std::string tmp = matches[j];
 
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) \
                       && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
-                          std::replace_if (tmp.begin (), tmp.end (),
-                                           std::bind2nd (std::equal_to<char> (),
-                                                         '/'),
-                                           '\\');
+                      std::replace_if (tmp.begin (), tmp.end (),
+                                       std::bind2nd (std::equal_to<char> (),
+                                                     '/'),
+                                       '\\');
 #endif
 
                       retval[k++] = tmp;
                     }
                 }
 
               gnulib::globfree (&glob_info);
             }
diff --git a/liboctave/util/oct-inttypes.cc b/liboctave/util/oct-inttypes.cc
--- a/liboctave/util/oct-inttypes.cc
+++ b/liboctave/util/oct-inttypes.cc
@@ -188,17 +188,17 @@ int64_t
 octave_int_arith_base<int64_t, true>::mul (int64_t x, int64_t y)
 {
   // The signed case is far worse. The problem is that
   // even if neither integer fits into signed 32-bit range, the result may
   // still be OK. Uh oh.
 
   // Essentially, what we do is compute sign, multiply absolute values
   // (as above) and impose the sign.
-  // FIXME -- can we do something faster if we HAVE_FAST_INT_OPS?
+  // FIXME: can we do something faster if we HAVE_FAST_INT_OPS?
 
   uint64_t usx = octave_int_abs (x), usy = octave_int_abs (y);
   bool positive = (x < 0) == (y < 0);
 
   // Get upper words
   uint64_t ux = usx >> 32, uy = usy >> 32;
   uint64_t res;
   if (ux)
@@ -344,21 +344,22 @@ DOUBLE_INT_BINOP_DECL (-, int64)
     }
   else
     return x + (-y);
 }
 
 // NOTE:
 // Emulated mixed multiplications are tricky due to possible precision loss.
 // Here, after sorting out common cases for speed, we follow the strategy
-// of converting the double number into the form sign * 64-bit integer* 2**exponent,
-// multiply the 64-bit integers to get a 128-bit number, split that number into 32-bit words
-// and form 4 double-valued summands (none of which loases precision), then convert these
-// into integers and sum them. Though it is not immediately obvious, this should work
-// even w.r.t. rounding (none of the summands lose precision).
+// of converting the double number into the form sign * 64-bit integer *
+// 2**exponent, multiply the 64-bit integers to get a 128-bit number, split that
+// number into 32-bit words and form 4 double-valued summands (none of which
+// loses precision), then convert these into integers and sum them. Though it is
+// not immediately obvious, this should work even w.r.t. rounding (none of the
+// summands lose precision).
 
 // Multiplies two unsigned 64-bit ints to get a 128-bit number represented
 // as four 32-bit words.
 static void
 umul128 (uint64_t x, uint64_t y, uint32_t w[4])
 {
   uint64_t lx = static_cast<uint32_t> (x), ux = x >> 32;
   uint64_t ly = static_cast<uint32_t> (y), uy = y >> 32;
@@ -379,25 +380,25 @@ static void
 dblesplit (double x, bool& sign, uint64_t& mtis, int& exp)
 {
   sign = x < 0; x = fabs (x);
   x = frexp (x, &exp);
   exp -= 52;
   mtis = static_cast<uint64_t> (ldexp (x, 52));
 }
 
-// Gets a double number from a 32-bit unsigned integer mantissa, exponent and sign.
+// Gets a double number from a
+// 32-bit unsigned integer mantissa, exponent, and sign.
 static double
 dbleget (bool sign, uint32_t mtis, int exp)
 {
   double x = ldexp (static_cast<double> (mtis), exp);
   return sign ? -x : x;
 }
 
-
 INT_DOUBLE_BINOP_DECL (*, uint64)
 {
   if (y >= 0 && y < octave_uint64::max () && y == xround (y))
     {
       return x * octave_uint64 (static_cast<uint64_t> (y));
     }
   else if (y == 0.5)
     {
diff --git a/liboctave/util/oct-inttypes.h b/liboctave/util/oct-inttypes.h
--- a/liboctave/util/oct-inttypes.h
+++ b/liboctave/util/oct-inttypes.h
@@ -30,20 +30,21 @@ along with Octave; see the file COPYING.
 #include <iosfwd>
 
 #include "lo-traits.h"
 #include "lo-math.h"
 #include "lo-mappers.h"
 
 #ifdef OCTAVE_INT_USE_LONG_DOUBLE
 inline long double xround (long double x) { return roundl (x); }
-inline long double xisnan (long double x) { return xisnan (static_cast<double> (x)); }
+inline long double xisnan (long double x)
+{ return xisnan (static_cast<double> (x)); }
 #endif
 
-// FIXME -- we define this by our own because some compilers, such as
+// FIXME: we define this by our own because some compilers, such as
 // MSVC, do not provide std::abs (int64_t) and std::abs (uint64_t).  In
 // the future, it should go away in favor of std::abs.
 template <class T>
 inline T octave_int_abs (T x) { return x >= 0 ? x : -x; }
 
 // Query for an integer type of certain sizeof, and signedness.
 template<int qsize, bool qsigned>
 struct query_integer_type
@@ -101,84 +102,85 @@ class octave_int_cmp_op
 {
   // This determines a suitable promotion type for T1 when meeting T2 in a
   // binary relation. If promotion to int or T2 is safe, it is used. Otherwise,
   // the signedness of T1 is preserved and it is widened if T2 is wider.
   // Notice that if this is applied to both types, they must end up with equal
   // size.
   template <class T1, class T2>
   class prom
-    {
-      // Promote to int?
-      static const bool pint = (sizeof (T1) < sizeof (int)
-                                && sizeof (T2) < sizeof (int));
-      static const bool t1sig = std::numeric_limits<T1>::is_signed;
-      static const bool t2sig = std::numeric_limits<T2>::is_signed;
-      static const bool psig =
-        (pint || (sizeof (T2) > sizeof (T1) && t2sig) || t1sig);
-      static const int psize =
-        (pint ? sizeof (int) : (sizeof (T2) > sizeof (T1)
-                                ? sizeof (T2) : sizeof (T1)));
-    public:
-      typedef typename query_integer_type<psize, psig>::type type;
-    };
+  {
+    // Promote to int?
+    static const bool pint = (sizeof (T1) < sizeof (int)
+                              && sizeof (T2) < sizeof (int));
+    static const bool t1sig = std::numeric_limits<T1>::is_signed;
+    static const bool t2sig = std::numeric_limits<T2>::is_signed;
+    static const bool psig =
+      (pint || (sizeof (T2) > sizeof (T1) && t2sig) || t1sig);
+    static const int psize =
+      (pint ? sizeof (int) : (sizeof (T2) > sizeof (T1)
+                              ? sizeof (T2) : sizeof (T1)));
+  public:
+    typedef typename query_integer_type<psize, psig>::type type;
+  };
 
   // Implements comparisons between two types of equal size but
   // possibly different signedness.
   template<class xop, int size>
   class uiop
-    {
-      typedef typename query_integer_type<size, false>::type utype;
-      typedef typename query_integer_type<size, true>::type stype;
-    public:
-      static bool op (utype x, utype y)
-        { return xop::op (x, y); }
-      static bool op (stype x, stype y)
-        { return xop::op (x, y); }
-      static bool op (stype x, utype y)
-        { return (x < 0) ? xop::ltval : xop::op (static_cast<utype> (x), y); }
-      static bool op (utype x, stype y)
-        { return (y < 0) ? xop::gtval : xop::op (x, static_cast<utype> (y)); }
-    };
+  {
+    typedef typename query_integer_type<size, false>::type utype;
+    typedef typename query_integer_type<size, true>::type stype;
+  public:
+    static bool op (utype x, utype y)
+    { return xop::op (x, y); }
+    static bool op (stype x, stype y)
+    { return xop::op (x, y); }
+    static bool op (stype x, utype y)
+    { return (x < 0) ? xop::ltval : xop::op (static_cast<utype> (x), y); }
+    static bool op (utype x, stype y)
+    { return (y < 0) ? xop::gtval : xop::op (x, static_cast<utype> (y)); }
+  };
 
 public:
   REGISTER_OCTAVE_CMP_OP (lt, <);
   REGISTER_OCTAVE_CMP_OP (le, <=);
   REGISTER_OCTAVE_CMP_OP (gt, >);
   REGISTER_OCTAVE_CMP_OP (ge, >=);
   REGISTER_OCTAVE_CMP_OP (eq, ==);
   REGISTER_OCTAVE_CMP_OP (ne, !=);
   REGISTER_OCTAVE_CONST_OP (ct, true);
   REGISTER_OCTAVE_CONST_OP (cf, false);
 
   // Universal comparison operation.
   template<class xop, class T1, class T2>
   static bool
   op (T1 x, T2 y)
-    {
-      typedef typename prom<T1, T2>::type PT1;
-      typedef typename prom<T2, T1>::type PT2;
-      return uiop<xop, sizeof (PT1)>::op (static_cast<PT1> (x),
-                                          static_cast<PT2> (y));
-    }
+  {
+    typedef typename prom<T1, T2>::type PT1;
+    typedef typename prom<T2, T1>::type PT2;
+    return uiop<xop, sizeof (PT1)>::op (static_cast<PT1> (x),
+                                        static_cast<PT2> (y));
+  }
 
 public:
 
   // Mixed comparisons
   template <class xop, class T>
   static bool
   mop (T x, double y)
-    { return xop::op (static_cast<double> (x), y); }
+  { return xop::op (static_cast<double> (x), y); }
 
   template <class xop, class T>
   static bool
   mop (double x, T y)
-    { return xop::op (x, static_cast<double> (y)); }
+  { return xop::op (x, static_cast<double> (y)); }
 
-  // Typecasting to doubles won't work properly for 64-bit integers - they lose precision.
+  // Typecasting to doubles won't work properly for 64-bit integers --
+  // they lose precision.
   // If we have long doubles, use them...
 #ifdef OCTAVE_INT_USE_LONG_DOUBLE
 #define DEFINE_LONG_DOUBLE_CMP_OP(T1, T2) \
   template <class xop> \
   static bool \
   mop (T1 x, T2 y) \
     { \
       return xop::op (static_cast<long double> (x), \
@@ -219,89 +221,91 @@ protected:
   static T max_val () { return std::numeric_limits<T>:: max (); }
 
 public:
 
   // Convert integer value.
   template <class S>
   static T
   truncate_int (const S& value)
-    {
-      // An exhaustive test whether the max and/or min check can be omitted.
-      static const bool t_is_signed = std::numeric_limits<T>::is_signed;
-      static const bool s_is_signed = std::numeric_limits<S>::is_signed;
-      static const int t_size = sizeof (T), s_size = sizeof (S);
-      static const bool omit_chk_min =
-        (! s_is_signed || (t_is_signed && t_size >= s_size));
-      static const bool omit_chk_max =
-        (t_size > s_size || (t_size == s_size
-         && (! t_is_signed || s_is_signed)));
-      // If the check can be omitted, substitute constant false relation.
-      typedef octave_int_cmp_op::cf cf;
-      typedef octave_int_cmp_op::lt lt;
-      typedef octave_int_cmp_op::gt gt;
-      typedef typename if_then_else<omit_chk_min, cf, lt>::result chk_min;
-      typedef typename if_then_else<omit_chk_max, cf, gt>::result chk_max;
+  {
+    // An exhaustive test whether the max and/or min check can be omitted.
+    static const bool t_is_signed = std::numeric_limits<T>::is_signed;
+    static const bool s_is_signed = std::numeric_limits<S>::is_signed;
+    static const int t_size = sizeof (T), s_size = sizeof (S);
+    static const bool omit_chk_min =
+      (! s_is_signed || (t_is_signed && t_size >= s_size));
+    static const bool omit_chk_max =
+      (t_size > s_size || (t_size == s_size
+                           && (! t_is_signed || s_is_signed)));
+    // If the check can be omitted, substitute constant false relation.
+    typedef octave_int_cmp_op::cf cf;
+    typedef octave_int_cmp_op::lt lt;
+    typedef octave_int_cmp_op::gt gt;
+    typedef typename if_then_else<omit_chk_min, cf, lt>::result chk_min;
+    typedef typename if_then_else<omit_chk_max, cf, gt>::result chk_max;
 
-      // Efficiency of the following depends on inlining and dead code
-      // elimination, but that should be a piece of cake for most compilers.
-      if (chk_min::op (value, static_cast<S> (min_val ())))
-        {
-          return min_val ();
-        }
-      else if (chk_max::op (value, static_cast<S> (max_val ())))
-        {
-          return max_val ();
-        }
-      else
-        return static_cast<T> (value);
-    }
+    // Efficiency of the following depends on inlining and dead code
+    // elimination, but that should be a piece of cake for most compilers.
+    if (chk_min::op (value, static_cast<S> (min_val ())))
+      {
+        return min_val ();
+      }
+    else if (chk_max::op (value, static_cast<S> (max_val ())))
+      {
+        return max_val ();
+      }
+    else
+      return static_cast<T> (value);
+  }
 
 private:
 
   // Computes a real-valued threshold for a max/min check.
   template <class S>
   static S
   compute_threshold (S val, T orig_val)
-    {
-      val = xround (val); // Fool optimizations (maybe redundant)
-      // If val is even, but orig_val is odd, we're one unit off.
-      if (orig_val % 2 && val / 2 == xround (val / 2))
-        // FIXME -- is this always correct?
-        val *= (static_cast<S>(1) - (std::numeric_limits<S>::epsilon () / 2));
-      return val;
-    }
+  {
+    val = xround (val); // Fool optimizations (maybe redundant)
+    // If val is even, but orig_val is odd, we're one unit off.
+    if (orig_val % 2 && val / 2 == xround (val / 2))
+      // FIXME: is this always correct?
+      val *= (static_cast<S>(1) - (std::numeric_limits<S>::epsilon () / 2));
+    return val;
+  }
 
 public:
   // Convert a real number (check NaN and non-int).
   template <class S>
   static T
   convert_real (const S& value)
-    {
-      // Compute proper thresholds.
-      static const S thmin = compute_threshold (static_cast<S> (min_val ()), min_val ());
-      static const S thmax = compute_threshold (static_cast<S> (max_val ()), max_val ());
-      if (xisnan (value))
-        {
-          return static_cast<T> (0);
-        }
-      else if (value < thmin)
-        {
-          return min_val ();
-        }
-      else if (value > thmax)
-        {
-          return max_val ();
-        }
-      else
-        {
-          S rvalue = xround (value);
-          return static_cast<T> (rvalue);
-        }
-    }
+  {
+    // Compute proper thresholds.
+    static const S thmin = compute_threshold (static_cast<S> (min_val ()),
+                           min_val ());
+    static const S thmax = compute_threshold (static_cast<S> (max_val ()),
+                           max_val ());
+    if (xisnan (value))
+      {
+        return static_cast<T> (0);
+      }
+    else if (value < thmin)
+      {
+        return min_val ();
+      }
+    else if (value > thmax)
+      {
+        return max_val ();
+      }
+    else
+      {
+        S rvalue = xround (value);
+        return static_cast<T> (rvalue);
+      }
+  }
 };
 
 // Saturated (homogeneous) integer arithmetics. The signed and unsigned
 // implementations are significantly different, so we implement another layer
 // and completely specialize. Arithmetics inherits from octave_int_base so that
 // it can use its exceptions and truncation functions.
 
 template <class T, bool is_signed>
@@ -325,85 +329,85 @@ public:
   static T
   rshift (T x, int n) { return x >> n; }
 
   static T
   lshift (T x, int n) { return x << n; }
 
   static T
   minus (T)
-    {
-      return static_cast<T> (0);
-    }
+  {
+    return static_cast<T> (0);
+  }
 
   // the overflow behaviour for unsigned integers is guaranteed by C/C++,
   // so the following should always work.
   static T
   add (T x, T y)
-    {
-      T u = x + y;
-      if (u < x)
-        {
-          u = octave_int_base<T>::max_val ();
-        }
-      return u;
-    }
+  {
+    T u = x + y;
+    if (u < x)
+      {
+        u = octave_int_base<T>::max_val ();
+      }
+    return u;
+  }
 
   static T
   sub (T x, T y)
-    {
-      T u = x - y;
-      if (u > x)
-        {
-          u = 0;
-        }
-      return u;
-    }
+  {
+    T u = x - y;
+    if (u > x)
+      {
+        u = 0;
+      }
+    return u;
+  }
 
   // Multiplication is done using promotion to wider integer type. If there is
   // no suitable promotion type, this operation *MUST* be specialized.
   static T
   mul (T x, T y)
-    {
-      // Promotion type for multiplication (if exists).
-      typedef typename query_integer_type<2*sizeof (T), false>::type mptype;
-      return octave_int_base<T>::truncate_int (static_cast<mptype> (x)
-                                               * static_cast<mptype> (y));
-    }
+  {
+    // Promotion type for multiplication (if exists).
+    typedef typename query_integer_type<2*sizeof (T), false>::type mptype;
+    return octave_int_base<T>::truncate_int (static_cast<mptype> (x)
+           * static_cast<mptype> (y));
+  }
 
   // Division with rounding to nearest. Note that / and % are probably
   // computed by a single instruction.
   static T
   div (T x, T y)
-    {
-      if (y != 0)
-        {
-          T z = x / y, w = x % y;
-          if (w >= y-w) z += 1;
-          return z;
-        }
-      else
-        {
-          return x ? octave_int_base<T>::max_val () : 0;
-        }
-    }
+  {
+    if (y != 0)
+      {
+        T z = x / y, w = x % y;
+        if (w >= y-w) z += 1;
+        return z;
+      }
+    else
+      {
+        return x ? octave_int_base<T>::max_val () : 0;
+      }
+  }
 
   // Remainder.
   static T
   rem (T x, T y)
-    {
-      return y != 0 ? x % y : 0;
-    }
+  {
+    return y != 0 ? x % y : 0;
+  }
 
   // Modulus. Note the weird y = 0 case for Matlab compatibility.
   static T
   mod (T x, T y)
-    {
-      return y != 0 ? x % y : x;
-    }
+  {
+    return y != 0 ? x % y : x;
+  }
 };
 
 #ifdef OCTAVE_INT_USE_LONG_DOUBLE
 // Handle 64-bit multiply using long double
 template <>
 inline uint64_t
 octave_int_arith_base<uint64_t, false>:: mul (uint64_t x, uint64_t y)
 {
@@ -432,277 +436,278 @@ octave_int_arith_base<uint64_t, false>::
 // 3. Signed addition and subtraction yield the same bit results as unsigned.
 //    (We use casts to prevent optimization interference, so there is no
 //     need for things like -ftrapv).
 // 4. Bit operations on signed integers work like on unsigned integers,
 //    except for the shifts. Shifts are arithmetic.
 //
 // The above conditions are satisfied by most modern platforms. If
 // HAVE_FAST_INT_OPS is defined, bit tricks and wraparound arithmetics are used
-// to avoid conditional jumps as much as possible, thus being friendly to modern
-// pipeline processor architectures.
+// to avoid conditional jumps as much as possible, thus being friendly to
+// modern pipeline processor architectures.
 // Otherwise, we fall back to a bullet-proof code that only uses assumptions
 // guaranteed by the standard.
 
 template <class T>
 class octave_int_arith_base<T, true> : octave_int_base<T>
 {
   // The corresponding unsigned type.
   typedef typename query_integer_type<sizeof (T), false>::type UT;
 public:
 
   // Returns 1 for negative number, 0 otherwise.
   static T
   __signbit (T x)
-    {
+  {
 #ifdef HAVE_FAST_INT_OPS
-      return static_cast<UT> (x) >> std::numeric_limits<T>::digits;
+    return static_cast<UT> (x) >> std::numeric_limits<T>::digits;
 #else
-      return (x < 0) ? 1 : 0;
+    return (x < 0) ? 1 : 0;
 #endif
-    }
+  }
 
   static T
   abs (T x)
-    {
+  {
 #ifdef HAVE_FAST_INT_OPS
-      // This is close to how GCC does std::abs, but we can't just use std::abs,
-      // because its behaviour for INT_MIN is undefined and the compiler could
-      // discard the following test.
-      T m = x >> std::numeric_limits<T>::digits;
-      T y = (x ^ m) - m;
-      if (y < 0)
-        {
-          y = octave_int_base<T>::max_val ();
-        }
-      return y;
+    // This is close to how GCC does std::abs, but we can't just use std::abs,
+    // because its behaviour for INT_MIN is undefined and the compiler could
+    // discard the following test.
+    T m = x >> std::numeric_limits<T>::digits;
+    T y = (x ^ m) - m;
+    if (y < 0)
+      {
+        y = octave_int_base<T>::max_val ();
+      }
+    return y;
 #else
-      // -INT_MAX is safe because C++ actually allows only three implementations
-      // of integers: sign & magnitude, ones complement and twos complement.
-      // The first test will, with modest optimizations, evaluate at compile
-      // time, and maybe eliminate the branch completely.
-      T y;
-      if (octave_int_base<T>::min_val () < -octave_int_base<T>::max_val ()
-          && x == octave_int_base<T>::min_val ())
-        {
-          y = octave_int_base<T>::max_val ();
-        }
-      else
-        y = (x < 0) ? -x : x;
-      return y;
+    // -INT_MAX is safe because C++ actually allows only three implementations
+    // of integers: sign & magnitude, ones complement and twos complement.
+    // The first test will, with modest optimizations, evaluate at compile
+    // time, and maybe eliminate the branch completely.
+    T y;
+    if (octave_int_base<T>::min_val () < -octave_int_base<T>::max_val ()
+        && x == octave_int_base<T>::min_val ())
+      {
+        y = octave_int_base<T>::max_val ();
+      }
+    else
+      y = (x < 0) ? -x : x;
+    return y;
 #endif
-    }
+  }
 
   static T
   signum (T x)
-    {
-      // With modest optimizations, this will compile without a jump.
-      return ((x > 0) ? 1 : 0) - __signbit (x);
-    }
+  {
+    // With modest optimizations, this will compile without a jump.
+    return ((x > 0) ? 1 : 0) - __signbit (x);
+  }
 
-  // FIXME -- we do not have an authority what signed shifts should
+  // FIXME: we do not have an authority what signed shifts should
   // exactly do, so we define them the easy way. Note that Matlab does
   // not define signed shifts.
 
   static T
   rshift (T x, int n) { return x >> n; }
 
   static T
   lshift (T x, int n) { return x << n; }
 
   // Minus has problems similar to abs.
   static T
   minus (T x)
-    {
+  {
 #ifdef HAVE_FAST_INT_OPS
-      T y = -x;
-      if (y == octave_int_base<T>::min_val ())
-        {
-          --y;
-        }
-      return y;
+    T y = -x;
+    if (y == octave_int_base<T>::min_val ())
+      {
+        --y;
+      }
+    return y;
 #else
-      T y;
-      if (octave_int_base<T>::min_val () < -octave_int_base<T>::max_val ()
-          && x == octave_int_base<T>::min_val ())
-        {
-          y = octave_int_base<T>::max_val ();
-        }
-      else
-        y = -x;
-      return y;
+    T y;
+    if (octave_int_base<T>::min_val () < -octave_int_base<T>::max_val ()
+        && x == octave_int_base<T>::min_val ())
+      {
+        y = octave_int_base<T>::max_val ();
+      }
+    else
+      y = -x;
+    return y;
 #endif
-    }
+  }
 
   static T
   add (T x, T y)
-    {
+  {
 #ifdef HAVE_FAST_INT_OPS
     // The typecasts do nothing, but they are here to prevent an optimizing
     // compiler from interfering. Also, the signed operations on small types
     // actually return int.
-      T u = static_cast<UT> (x) + static_cast<UT> (y);
-      T ux = u ^ x, uy = u ^ y;
-      if ((ux & uy) < 0)
-        {
-          u = octave_int_base<T>::max_val () + __signbit (~u);
-        }
-      return u;
+    T u = static_cast<UT> (x) + static_cast<UT> (y);
+    T ux = u ^ x, uy = u ^ y;
+    if ((ux & uy) < 0)
+      {
+        u = octave_int_base<T>::max_val () + __signbit (~u);
+      }
+    return u;
 #else
-      // We shall carefully avoid anything that may overflow.
-      T u;
-      if (y < 0)
-        {
-          if (x < octave_int_base<T>::min_val () - y)
-            {
-              u = octave_int_base<T>::min_val ();
-            }
-          else
-            u = x + y;
-        }
-      else
-        {
-          if (x > octave_int_base<T>::max_val () - y)
-            {
-              u = octave_int_base<T>::max_val ();
-            }
-          else
-            u = x + y;
-        }
+    // We shall carefully avoid anything that may overflow.
+    T u;
+    if (y < 0)
+      {
+        if (x < octave_int_base<T>::min_val () - y)
+          {
+            u = octave_int_base<T>::min_val ();
+          }
+        else
+          u = x + y;
+      }
+    else
+      {
+        if (x > octave_int_base<T>::max_val () - y)
+          {
+            u = octave_int_base<T>::max_val ();
+          }
+        else
+          u = x + y;
+      }
 
-      return u;
+    return u;
 #endif
-    }
+  }
 
   // This is very similar to addition.
   static T
   sub (T x, T y)
-    {
+  {
 #ifdef HAVE_FAST_INT_OPS
     // The typecasts do nothing, but they are here to prevent an optimizing
     // compiler from interfering. Also, the signed operations on small types
     // actually return int.
-      T u = static_cast<UT> (x) - static_cast<UT> (y);
-      T ux = u ^ x, uy = u ^ ~y;
-      if ((ux & uy) < 0)
-        {
-          u = octave_int_base<T>::max_val () + __signbit (~u);
-        }
-      return u;
+    T u = static_cast<UT> (x) - static_cast<UT> (y);
+    T ux = u ^ x, uy = u ^ ~y;
+    if ((ux & uy) < 0)
+      {
+        u = octave_int_base<T>::max_val () + __signbit (~u);
+      }
+    return u;
 #else
-      // We shall carefully avoid anything that may overflow.
-      T u;
-      if (y < 0)
-        {
-          if (x > octave_int_base<T>::max_val () + y)
-            {
-              u = octave_int_base<T>::max_val ();
-            }
-          else
-            u = x - y;
-        }
-      else
-        {
-          if (x < octave_int_base<T>::min_val () + y)
-            {
-              u = octave_int_base<T>::min_val ();
-            }
-          else
-            u = x - y;
-        }
+    // We shall carefully avoid anything that may overflow.
+    T u;
+    if (y < 0)
+      {
+        if (x > octave_int_base<T>::max_val () + y)
+          {
+            u = octave_int_base<T>::max_val ();
+          }
+        else
+          u = x - y;
+      }
+    else
+      {
+        if (x < octave_int_base<T>::min_val () + y)
+          {
+            u = octave_int_base<T>::min_val ();
+          }
+        else
+          u = x - y;
+      }
 
-      return u;
+    return u;
 #endif
-    }
+  }
 
   // Multiplication is done using promotion to wider integer type. If there is
   // no suitable promotion type, this operation *MUST* be specialized.
   static T
   mul (T x, T y)
-    {
-      // Promotion type for multiplication (if exists).
-      typedef typename query_integer_type<2*sizeof (T), true>::type mptype;
-      return octave_int_base<T>::truncate_int (static_cast<mptype> (x)
-                                               * static_cast<mptype> (y));
-    }
+  {
+    // Promotion type for multiplication (if exists).
+    typedef typename query_integer_type<2*sizeof (T), true>::type mptype;
+    return octave_int_base<T>::truncate_int (static_cast<mptype> (x)
+           * static_cast<mptype> (y));
+  }
 
   // Division.
   static T
   div (T x, T y)
-    {
-      T z;
-      if (y == 0)
-        {
-          if (x < 0)
-            z = octave_int_base<T>::min_val ();
-          else if (x != 0)
+  {
+    T z;
+    if (y == 0)
+      {
+        if (x < 0)
+          z = octave_int_base<T>::min_val ();
+        else if (x != 0)
+          z = octave_int_base<T>::max_val ();
+        else
+          z = 0;
+      }
+    else if (y < 0)
+      {
+        // This is a special case that overflows as well.
+        if (y == -1 && x == octave_int_base<T>::min_val ())
+          {
             z = octave_int_base<T>::max_val ();
-          else
-            z = 0;
-        }
-      else if (y < 0)
-        {
-          // This is a special case that overflows as well.
-          if (y == -1 && x == octave_int_base<T>::min_val ())
-            {
-              z = octave_int_base<T>::max_val ();
-            }
-          else
-            {
-              z = x / y;
-              T w = -octave_int_abs (x % y); // Can't overflow, but std::abs (x) can!
-              if (w <= y - w)
-                z -= 1 - (__signbit (x) << 1);
-            }
-        }
-      else
-        {
-          z = x / y;
-          // FIXME -- this is a workaround due to MSVC's absence of
-          // std::abs (int64_t).  The call to octave_int_abs can't
-          // overflow, but std::abs (x) can!
-          T w = octave_int_abs (x % y);
+          }
+        else
+          {
+            z = x / y;
+            // Can't overflow, but std::abs (x) can!
+            T w = -octave_int_abs (x % y);
+            if (w <= y - w)
+              z -= 1 - (__signbit (x) << 1);
+          }
+      }
+    else
+      {
+        z = x / y;
+        // FIXME: this is a workaround due to MSVC's absence of
+        // std::abs (int64_t).  The call to octave_int_abs can't
+        // overflow, but std::abs (x) can!
+        T w = octave_int_abs (x % y);
 
-          if (w >= y - w)
-            z += 1 - (__signbit (x) << 1);
-        }
-      return z;
-    }
+        if (w >= y - w)
+          z += 1 - (__signbit (x) << 1);
+      }
+    return z;
+  }
 
   // Remainder.
   static T
   rem (T x, T y)
-    {
-      return y != 0 ? x % y : 0;
-    }
+  {
+    return y != 0 ? x % y : 0;
+  }
 
   // Modulus. Note the weird y = 0 case for Matlab compatibility.
   static T
   mod (T x, T y)
-    {
-      if (y != 0)
-        {
-          T r = x % y;
-          return ((r < 0) != (y < 0)) ? r + y : r;
-        }
-      else
-        return x;
-    }
+  {
+    if (y != 0)
+      {
+        T r = x % y;
+        return ((r < 0) != (y < 0)) ? r + y : r;
+      }
+    else
+      return x;
+  }
 };
 
 #ifdef OCTAVE_INT_USE_LONG_DOUBLE
 // Handle 64-bit multiply using long double
 template <>
 inline int64_t
 octave_int_arith_base<int64_t, true>:: mul (int64_t x, int64_t y)
 {
   long double p = static_cast<long double> (x) * static_cast<long double> (y);
-  // NOTE: We could maybe do it with a single branch if HAVE_FAST_INT_OPS, but it
-  // would require one more runtime conversion, so the question is whether it would
-  // really be faster.
+  // NOTE: We could maybe do it with a single branch if HAVE_FAST_INT_OPS,
+  // but it would require one more runtime conversion, so the question is
+  // whether it would really be faster.
   if (p > static_cast<long double> (octave_int_base<int64_t>::max_val ()))
     {
       return octave_int_base<int64_t>::max_val ();
     }
   else if (p < static_cast<long double> (octave_int_base<int64_t>::min_val ()))
     {
       return octave_int_base<int64_t>::min_val ();
     }
@@ -715,17 +720,17 @@ template <>
 OCTAVE_API int64_t
 octave_int_arith_base<int64_t, true>::mul (int64_t, int64_t);
 #endif
 
 // This class simply selects the proper arithmetics.
 template<class T>
 class octave_int_arith
  : public octave_int_arith_base<T, std::numeric_limits<T>::is_signed>
-{};
+{ };
 
 template <class T>
 class
 octave_int : public octave_int_base<T>
 {
 public:
   typedef T val_type;
 
@@ -778,17 +783,17 @@ public:
   // char and bool operators intentionally omitted.
 
   operator double (void) const { return double_value (); }
 
   operator float (void) const { return float_value (); }
 
   octave_int<T>
   operator + () const
-    { return *this; }
+  { return *this; }
 
   // unary operators & mappers
 #define OCTAVE_INT_UN_OP(OPNAME,NAME) \
   inline octave_int<T> \
   OPNAME () const \
   { return octave_int_arith<T>::NAME (ival); }
 
   OCTAVE_INT_UN_OP(operator -, minus)
@@ -852,17 +857,17 @@ mod (const octave_int<T>& x, const octav
 
 // No mixed integer binary operations!
 
 template <class T>
 inline bool
 xisnan (const octave_int<T>&)
 { return false; }
 
-// FIXME -- can/should any of these be inline?
+// FIXME: can/should any of these be inline?
 
 template <class T>
 extern OCTAVE_API octave_int<T>
 pow (const octave_int<T>&, const octave_int<T>&);
 
 template <class T>
 extern OCTAVE_API octave_int<T>
 pow (const double& a, const octave_int<T>& b);
diff --git a/liboctave/util/oct-locbuf.cc b/liboctave/util/oct-locbuf.cc
--- a/liboctave/util/oct-locbuf.cc
+++ b/liboctave/util/oct-locbuf.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <iostream>
 
 #include "lo-error.h"
 #include "oct-locbuf.h"
 
-// FIXME -- Maybe we should querying for available physical memory?
+// FIXME: Maybe we should querying for available physical memory?
 
 #ifndef OCTAVE_LOCBUF_CHUNKSIZE_MB
 #define OCTAVE_LOCBUF_CHUNKSIZE_MB 32
 #endif
 
 // Each chunk will be at least this big.
 
 const size_t octave_chunk_buffer::chunk_size =
@@ -107,18 +107,18 @@ octave_chunk_buffer::~octave_chunk_buffe
       if (cnk)
         {
           // Responsible for deletion.
 
           delete [] chunk;
           chunk = cnk;
           top = dat;
 
-          // FIXME -- the following calcuation of remaining data will
-          // only work if each chunk has the same chunk_size.
+          // FIXME: the following calcuation of remaining data will
+          //        only work if each chunk has the same chunk_size.
 
           left = chunk_size - (dat - cnk);
         }
       else
         {
           // We were a stand-alone buffer.
 
           delete [] dat;
diff --git a/liboctave/util/oct-locbuf.h b/liboctave/util/oct-locbuf.h
--- a/liboctave/util/oct-locbuf.h
+++ b/liboctave/util/oct-locbuf.h
@@ -31,20 +31,20 @@ along with Octave; see the file COPYING.
 // specializations.
 
 template <class T>
 class octave_local_buffer
 {
 public:
   octave_local_buffer (size_t size)
     : data (0)
-    {
-      if (size)
-        data = new T [size];
-    }
+  {
+    if (size)
+      data = new T [size];
+  }
   ~octave_local_buffer (void) { delete [] data; }
   operator T *() const { return data; }
 
 private:
   T *data;
 
   // No copying!
   octave_local_buffer (const octave_local_buffer&);
@@ -138,28 +138,28 @@ SPECIALIZE_POD_BUFFER (FloatComplex);
 
 // All pointers and const pointers are also POD types.
 template <class T>
 class octave_local_buffer<T *> : private octave_chunk_buffer
 {
 public:
   octave_local_buffer (size_t size)
     : octave_chunk_buffer (size * sizeof (T *))
-    { }
+  { }
 
   operator T **() const { return reinterpret_cast<T **> (this->data ()); }
 };
 
 template <class T>
 class octave_local_buffer<const T *> : private octave_chunk_buffer
 {
 public:
   octave_local_buffer (size_t size)
     : octave_chunk_buffer (size * sizeof (const T *))
-    { }
+  { }
 
   operator const T **() const
   {
     return reinterpret_cast<const T **> (this->data ());
   }
 };
 
 // If the compiler supports dynamic stack arrays, we can use the
diff --git a/liboctave/util/oct-mem.h b/liboctave/util/oct-mem.h
--- a/liboctave/util/oct-mem.h
+++ b/liboctave/util/oct-mem.h
@@ -38,17 +38,18 @@ along with Octave; see the file COPYING.
 
 inline size_t safe_size_comp (size_t n, size_t size)
 {
   if (n > static_cast<size_t> (-1) / size)
     throw std::bad_alloc ();
   return n * size;
 }
 
-// Unaliased copy. This boils down to memcpy, even for octave_int and complex types.
+// Unaliased copy. This boils down to memcpy, even for octave_int and
+// complex types.
 
 template <class T>
 inline void copy_or_memcpy (size_t n, const T *src, T *dest)
 { std::copy (src, src + n, dest); }
 
 #define DEFINE_POD_UCOPY(T) \
 inline void copy_or_memcpy (size_t n, const T *src, T *dest) \
 { std::memcpy (dest, src, n * sizeof (T)); }
@@ -74,17 +75,18 @@ DEFINE_POD_UCOPY (octave_int<T>)
 // a POD zero.
 template <class T>
 inline void fill_or_memset (size_t n, const T& value, T *dest)
 { std::fill_n (dest, n, value); }
 
 template <class T>
 inline bool helper_is_zero_mem (const T& value)
 {
-  typedef typename query_integer_type<sizeof (T), false>::type IT; // get integer type of the same size.
+  // get integer type of the same size.
+  typedef typename query_integer_type<sizeof (T), false>::type IT;
   return *(reinterpret_cast<const IT *>(&value)) == 0;
 }
 
 template <class T>
 inline bool helper_is_zero_mem (const std::complex<T>& value)
 {
   return (helper_is_zero_mem (value.real ())
           && helper_is_zero_mem (value.imag ()));
@@ -115,23 +117,24 @@ DEFINE_POD_FILL (unsigned int)
 DEFINE_POD_FILL (unsigned long)
 
 DEFINE_POD_FILL (Complex)
 DEFINE_POD_FILL (FloatComplex)
 
 template <class T>
 DEFINE_POD_FILL (octave_int<T>)
 
-// Uninitialized allocation. Will not initialize memory for complex and octave_int.
+// Uninitialized allocation.
+// Will not initialize memory for complex and octave_int.
 // Memory allocated by octave_new should be freed by octave_delete.
 template <class T>
 inline T *no_ctor_new (size_t n)
 {
-  // Some systems let us allocate > 2GB memory even though size_t, which is either
-  // buggy or completely cuckoo, so let's check here to stay safe.
+  // Some systems let us allocate > 2GB memory even though size_t, which is
+  // either buggy or completely cuckoo, so let's check here to stay safe.
   safe_size_comp (n, sizeof (T));
   return new T [n];
 }
 template <class T>
 inline void no_ctor_delete (T *ptr)
 { delete [] ptr; }
 
 #define DEFINE_POD_NEW_DELETE(T) \
diff --git a/liboctave/util/oct-mutex.cc b/liboctave/util/oct-mutex.cc
--- a/liboctave/util/oct-mutex.cc
+++ b/liboctave/util/oct-mutex.cc
@@ -84,17 +84,17 @@ public:
   {
     return (TryEnterCriticalSection (&cs) != 0);
   }
 
 private:
   CRITICAL_SECTION cs;
 };
 
-static DWORD octave_thread_id = 0; 
+static DWORD octave_thread_id = 0;
 
 void
 octave_thread::init (void)
 {
   octave_thread_id = GetCurrentThreadId ();
 }
 
 bool
diff --git a/liboctave/util/oct-refcount.h b/liboctave/util/oct-refcount.h
--- a/liboctave/util/oct-refcount.h
+++ b/liboctave/util/oct-refcount.h
@@ -49,46 +49,46 @@ along with Octave; see the file COPYING.
 
 // Encapsulates a reference counter.
 template <class T>
 class octave_refcount
 {
 public:
   typedef T count_type;
 
-  octave_refcount(count_type initial_count) : count(initial_count) {}
+  octave_refcount(count_type initial_count) : count(initial_count) { }
 
   // Increment/Decrement. int is postfix.
   count_type operator++(void)
-    {
-      return OCTREFCOUNT_ATOMIC_INCREMENT (&count);
-    }
+  {
+    return OCTREFCOUNT_ATOMIC_INCREMENT (&count);
+  }
 
   count_type operator++(int)
-    {
-      return OCTREFCOUNT_ATOMIC_INCREMENT_POST (&count);
-    }
+  {
+    return OCTREFCOUNT_ATOMIC_INCREMENT_POST (&count);
+  }
 
   count_type operator--(void)
-    {
-      return OCTREFCOUNT_ATOMIC_DECREMENT (&count);
-    }
+  {
+    return OCTREFCOUNT_ATOMIC_DECREMENT (&count);
+  }
 
   count_type operator--(int)
-    {
-      return OCTREFCOUNT_ATOMIC_DECREMENT_POST (&count);
-    }
+  {
+    return OCTREFCOUNT_ATOMIC_DECREMENT_POST (&count);
+  }
 
   operator count_type (void) const
-    {
-      return static_cast<count_type const volatile&> (count);
-    }
+  {
+    return static_cast<count_type const volatile&> (count);
+  }
 
   count_type *get (void)
-    {
-      return &count;
-    }
+  {
+    return &count;
+  }
 
 private:
   count_type count;
 };
 
 #endif
diff --git a/liboctave/util/oct-shlib.cc b/liboctave/util/oct-shlib.cc
--- a/liboctave/util/oct-shlib.cc
+++ b/liboctave/util/oct-shlib.cc
@@ -156,17 +156,18 @@ class
 octave_dlopen_shlib : public octave_shlib::shlib_rep
 {
 public:
 
   octave_dlopen_shlib (const std::string& f);
 
   ~octave_dlopen_shlib (void);
 
-  void *search (const std::string& name, octave_shlib::name_mangler mangler = 0);
+  void *search (const std::string& name,
+                octave_shlib::name_mangler mangler = 0);
 
   // FIXME: this is possibly redundant because failure to open a library will
   // normally throw an exception, avoiding the construction of an invalid
   // library. Leave it here for possible future use.
 
   bool is_open (void) const { return (library != 0); }
 
 private:
@@ -242,17 +243,18 @@ class
 octave_shl_load_shlib : public octave_shlib::shlib_rep
 {
 public:
 
   octave_shl_load_shlib (const std::string& f);
 
   ~octave_shl_load_shlib (void);
 
-  void *search (const std::string& name, octave_shlib::name_mangler mangler = 0);
+  void *search (const std::string& name,
+                octave_shlib::name_mangler mangler = 0);
 
   bool is_open (void) const { return (library != 0); }
 
 private:
 
   // No copying!
 
   octave_shl_load_shlib (const octave_shl_load_shlib&);
@@ -311,17 +313,18 @@ class
 octave_w32_shlib: public octave_shlib::shlib_rep
 {
 public:
 
   octave_w32_shlib (const std::string& f);
 
   ~octave_w32_shlib (void);
 
-  void *search (const std::string& name, octave_shlib::name_mangler mangler = 0);
+  void *search (const std::string& name,
+                octave_shlib::name_mangler mangler = 0);
 
   bool is_open (void) const { return (handle != 0); }
 
 private:
 
   // No copying!
 
   octave_w32_shlib (const octave_w32_shlib&);
@@ -405,17 +408,18 @@ octave_dyld_shlib : public octave_shlib:
 public:
 
   octave_dyld_shlib (void);
 
   ~octave_dyld_shlib (void);
 
   void open (const std::string& f);
 
-  void *search (const std::string& name, octave_shlib::name_mangler mangler = 0);
+  void *search (const std::string& name,
+                octave_shlib::name_mangler mangler = 0);
 
   void close (octave_shlib::close_hook cl_hook = 0);
 
   bool is_open (void) const {return (handle != 0); }
 
 private:
 
   // No copying!
@@ -454,17 +458,17 @@ octave_dyld_shlib::octave_dyld_shlib (co
             ("%s: %s", file.c_str (), errstr);
         }
     }
   else
     {
       (*current_liboctave_error_handler)
         ("got NSObjectFileImageReturnCode %d", returnCode);
 
-      // FIXME -- should use NSLinkEditError () to get
+      // FIXME: should use NSLinkEditError () to get
       // more info on what went wrong.
     }
 }
 
 octave_dyld_shlib::~octave_dyld_shlib (void)
 {
   if (handle)
     NSUnLinkModule (handle, NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES);
diff --git a/liboctave/util/oct-shlib.h b/liboctave/util/oct-shlib.h
--- a/liboctave/util/oct-shlib.h
+++ b/liboctave/util/oct-shlib.h
@@ -48,38 +48,38 @@ public: // FIXME: make this class privat
 
   protected:
 
     shlib_rep (const std::string& f);
 
   public:
 
     virtual ~shlib_rep (void)
-      {
-        instances.erase (file);
-      }
+    {
+      instances.erase (file);
+    }
 
     virtual bool is_open (void) const
-      { return false; }
+    { return false; }
 
     virtual void *search (const std::string&, name_mangler = 0)
-      { return 0; }
+    { return 0; }
 
     bool is_out_of_date (void) const;
 
     // This method will be overriden conditionally.
     static shlib_rep *new_instance (const std::string& f);
 
     static shlib_rep *get_instance (const std::string& f, bool fake);
 
     octave_time time_loaded (void) const
-      { return tm_loaded; }
+    { return tm_loaded; }
 
     std::string file_name (void) const
-      { return file; }
+    { return file; }
 
     size_t num_fcn_names (void) const { return fcn_names.size (); }
 
     void add_fcn_name (const std::string&);
 
     bool remove_fcn_name (const std::string&);
 
     void do_close_hook (close_hook cl_hook);
@@ -111,82 +111,82 @@ private:
 public:
 
   octave_shlib (void) : rep (&nil_rep) { rep->count++; }
 
   octave_shlib (const std::string& f, bool fake = true)
     : rep (shlib_rep::get_instance (f, fake)) { }
 
   ~octave_shlib (void)
-    {
-      if (--rep->count == 0)
-        delete rep;
-    }
+  {
+    if (--rep->count == 0)
+      delete rep;
+  }
 
   octave_shlib (const octave_shlib& sl)
     : rep (sl.rep)
-    {
-      rep->count++;
-    }
+  {
+    rep->count++;
+  }
 
   octave_shlib& operator = (const octave_shlib& sl)
-    {
-      if (rep != sl.rep)
-        {
-          if (--rep->count == 0)
-            delete rep;
+  {
+    if (rep != sl.rep)
+      {
+        if (--rep->count == 0)
+          delete rep;
 
-          rep = sl.rep;
-          rep->count++;
-        }
+        rep = sl.rep;
+        rep->count++;
+      }
 
-      return *this;
-    }
+    return *this;
+  }
 
   bool operator == (const octave_shlib& sl) const
-    { return (rep == sl.rep); }
+  { return (rep == sl.rep); }
 
   operator bool () const { return rep->is_open (); }
 
   void open (const std::string& f)
-    { *this = octave_shlib (f); }
+  { *this = octave_shlib (f); }
 
   void close (close_hook cl_hook = 0)
-    {
-      if (cl_hook)
-        rep->do_close_hook (cl_hook);
+  {
+    if (cl_hook)
+      rep->do_close_hook (cl_hook);
 
-      *this = octave_shlib ();
-    }
+    *this = octave_shlib ();
+  }
 
   void *search (const std::string& nm, name_mangler mangler = 0) const
-    {
-      void *f = rep->search (nm, mangler);
-      if (f)
-        rep->add_fcn_name (nm);
+  {
+    void *f = rep->search (nm, mangler);
+    if (f)
+      rep->add_fcn_name (nm);
 
-      return f;
-    }
+    return f;
+  }
 
   void add (const std::string& name)
-    { rep->add_fcn_name (name); }
+  { rep->add_fcn_name (name); }
 
   bool remove (const std::string& name)
-    { return rep->remove_fcn_name (name); }
+  { return rep->remove_fcn_name (name); }
 
   size_t number_of_functions_loaded (void) const
-    { return rep->num_fcn_names (); }
+  { return rep->num_fcn_names (); }
 
   bool is_out_of_date (void) const
-    { return rep->is_out_of_date (); }
+  { return rep->is_out_of_date (); }
 
   std::string file_name (void) const
-    { return rep->file_name (); }
+  { return rep->file_name (); }
 
   octave_time time_loaded (void) const
-    { return rep->time_loaded (); }
+  { return rep->time_loaded (); }
 
 private:
 
   shlib_rep *rep;
 };
 
 #endif
diff --git a/liboctave/util/oct-sort.cc b/liboctave/util/oct-sort.cc
--- a/liboctave/util/oct-sort.cc
+++ b/liboctave/util/oct-sort.cc
@@ -254,17 +254,18 @@ For its intended use in a stable mergeso
 sequence without violating stability (strict > ensures there are no equal
 elements to get out of order).
 
 Returns -1 in case of error.
 */
 template <class T>
 template <class Comp>
 octave_idx_type
-octave_sort<T>::count_run (T *lo, octave_idx_type nel, bool& descending, Comp comp)
+octave_sort<T>::count_run (T *lo, octave_idx_type nel, bool& descending,
+                           Comp comp)
 {
   octave_idx_type n;
   T *hi = lo + nel;
 
   descending = false;
   ++lo;
   if (lo == hi)
     return 1;
@@ -313,17 +314,18 @@ pretending that *(a-1) is minus infinity
 key belongs at index k; or, IOW, the first k elements of a should precede
 key, and the last n-k should follow key.
 
 Returns -1 on error.  See listsort.txt for info on the method.
 */
 template <class T>
 template <class Comp>
 octave_idx_type
-octave_sort<T>::gallop_left (T key, T *a, octave_idx_type n, octave_idx_type hint,
+octave_sort<T>::gallop_left (T key, T *a, octave_idx_type n,
+                             octave_idx_type hint,
                              Comp comp)
 {
   octave_idx_type ofs;
   octave_idx_type lastofs;
   octave_idx_type k;
 
   a += hint;
   lastofs = 0;
@@ -407,17 +409,18 @@ or -1 if error.
 
 The code duplication is massive, but this is enough different given that
 we're sticking to "<" comparisons that it's much harder to follow if
 written as one routine with yet another "left or right?" flag.
 */
 template <class T>
 template <class Comp>
 octave_idx_type
-octave_sort<T>::gallop_right (T key, T *a, octave_idx_type n, octave_idx_type hint,
+octave_sort<T>::gallop_right (T key, T *a, octave_idx_type n,
+                              octave_idx_type hint,
                               Comp comp)
 {
   octave_idx_type ofs;
   octave_idx_type lastofs;
   octave_idx_type k;
 
   a += hint;
   lastofs = 0;
@@ -686,25 +689,25 @@ octave_sort<T>::merge_lo (T *pa, octave_
             goto CopyB;
         }
       while (acount >= MIN_GALLOP || bcount >= MIN_GALLOP);
 
       ++min_gallop;     /* penalize it for leaving galloping mode */
       ms->min_gallop = min_gallop;
     }
 
- Succeed:
+Succeed:
   result = 0;
 
- Fail:
+Fail:
   if (na)
     std::copy (pa, pa + na, dest);
   return result;
 
- CopyB:
+CopyB:
   /* The last element of pa belongs at the end of the merge. */
   std::copy (pb, pb + nb, dest);
   dest[nb] = *pa;
 
   return 0;
 }
 
 template <class T>
@@ -822,28 +825,28 @@ octave_sort<T>::merge_lo (T *pa, octave_
             goto CopyB;
         }
       while (acount >= MIN_GALLOP || bcount >= MIN_GALLOP);
 
       ++min_gallop;     /* penalize it for leaving galloping mode */
       ms->min_gallop = min_gallop;
     }
 
- Succeed:
+Succeed:
   result = 0;
 
- Fail:
+Fail:
   if (na)
     {
       std::copy (pa, pa + na, dest);
       std::copy (ipa, ipa + na, idest);
     }
   return result;
 
- CopyB:
+CopyB:
   /* The last element of pa belongs at the end of the merge. */
   std::copy (pb, pb + nb, dest);
   std::copy (ipb, ipb + nb, idest);
   dest[nb] = *pa;
   idest[nb] = *ipa;
 
   return 0;
 }
@@ -1411,17 +1414,18 @@ octave_sort<T>::sort (T *data, octave_id
           n = count_run (data + lo, nremaining, descending, comp);
           if (n < 0)
             goto fail;
           if (descending)
             std::reverse (data + lo, data + lo + n);
           /* If short, extend to min (minrun, nremaining). */
           if (n < minrun)
             {
-              const octave_idx_type force = nremaining <= minrun ? nremaining : minrun;
+              const octave_idx_type force = nremaining <= minrun ? nremaining
+                                                                 : minrun;
               binarysort (data + lo, force, n, comp);
               n = force;
             }
           /* Push run onto pending-runs stack, and maybe merge. */
           assert (ms->n < MAX_MERGE_PENDING);
           ms->pending[ms->n].base = lo;
           ms->pending[ms->n].len = n;
           ms->n++;
@@ -1473,17 +1477,18 @@ octave_sort<T>::sort (T *data, octave_id
           if (descending)
             {
               std::reverse (data + lo, data + lo + n);
               std::reverse (idx + lo, idx + lo + n);
             }
           /* If short, extend to min (minrun, nremaining). */
           if (n < minrun)
             {
-              const octave_idx_type force = nremaining <= minrun ? nremaining : minrun;
+              const octave_idx_type force = nremaining <= minrun ? nremaining
+                                                                 : minrun;
               binarysort (data + lo, idx + lo, force, n, comp);
               n = force;
             }
           /* Push run onto pending-runs stack, and maybe merge. */
           assert (ms->n < MAX_MERGE_PENDING);
           ms->pending[ms->n].base = lo;
           ms->pending[ms->n].len = n;
           ms->n++;
@@ -1509,38 +1514,38 @@ octave_sort<T>::sort (T *data, octave_id
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     sort (data, nel, std::less<T> ());
   else
 #endif
 #ifdef INLINE_DESCENDING_SORT
     if (compare == descending_compare)
       sort (data, nel, std::greater<T> ());
-  else
+    else
 #endif
-    if (compare)
-      sort (data, nel, compare);
+      if (compare)
+        sort (data, nel, compare);
 }
 
 template <class T>
 void
 octave_sort<T>::sort (T *data, octave_idx_type *idx, octave_idx_type nel)
 {
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     sort (data, idx, nel, std::less<T> ());
   else
 #endif
 #ifdef INLINE_DESCENDING_SORT
     if (compare == descending_compare)
       sort (data, idx, nel, std::greater<T> ());
-  else
+    else
 #endif
-    if (compare)
-      sort (data, idx, nel, compare);
+      if (compare)
+        sort (data, idx, nel, compare);
 }
 
 template <class T> template <class Comp>
 bool
 octave_sort<T>::is_sorted (const T *data, octave_idx_type nel, Comp comp)
 {
   const T *end = data + nel;
   if (data != end)
@@ -1566,20 +1571,20 @@ octave_sort<T>::is_sorted (const T *data
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     retval = is_sorted (data, nel, std::less<T> ());
   else
 #endif
 #ifdef INLINE_DESCENDING_SORT
     if (compare == descending_compare)
       retval = is_sorted (data, nel, std::greater<T> ());
-  else
+    else
 #endif
-    if (compare)
-      retval = is_sorted (data, nel, compare);
+      if (compare)
+        retval = is_sorted (data, nel, compare);
 
   return retval;
 }
 
 // FIXME: is there really no way to make this local to the following function?
 struct sortrows_run_t
 {
   sortrows_run_t (octave_idx_type c, octave_idx_type o, octave_idx_type n)
@@ -1654,20 +1659,20 @@ octave_sort<T>::sort_rows (const T *data
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     sort_rows (data, idx, rows, cols, std::less<T> ());
   else
 #endif
 #ifdef INLINE_DESCENDING_SORT
     if (compare == descending_compare)
       sort_rows (data, idx, rows, cols, std::greater<T> ());
-  else
+    else
 #endif
-    if (compare)
-      sort_rows (data, idx, rows, cols, compare);
+      if (compare)
+        sort_rows (data, idx, rows, cols, compare);
 }
 
 template <class T> template <class Comp>
 bool
 octave_sort<T>::is_sorted_rows (const T *data, octave_idx_type rows,
                                 octave_idx_type cols, Comp comp)
 {
   if (rows <= 1 || cols == 0)
@@ -1690,17 +1695,17 @@ octave_sort<T>::is_sorted_rows (const T 
           // Not the final column.
           assert (n > 1);
           const T *hi = lo + n, *lst = lo;
           for (lo++; lo < hi; lo++)
             {
               if (comp (*lst, *lo))
                 {
                   if (lo > lst + 1)
-                      runs.push (run_t (lst + rows, lo - lst));
+                    runs.push (run_t (lst + rows, lo - lst));
                   lst = lo;
                 }
               else if (comp (*lo, *lst))
                 break;
 
             }
           if (lo == hi)
             {
@@ -1731,20 +1736,20 @@ octave_sort<T>::is_sorted_rows (const T 
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     retval = is_sorted_rows (data, rows, cols, std::less<T> ());
   else
 #endif
 #ifdef INLINE_DESCENDING_SORT
     if (compare == descending_compare)
       retval = is_sorted_rows (data, rows, cols, std::greater<T> ());
-  else
+    else
 #endif
-    if (compare)
-      retval = is_sorted_rows (data, rows, cols, compare);
+      if (compare)
+        retval = is_sorted_rows (data, rows, cols, compare);
 
   return retval;
 }
 
 // The simple binary lookup.
 
 template <class T> template <class Comp>
 octave_idx_type
@@ -1775,20 +1780,20 @@ octave_sort<T>::lookup (const T *data, o
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     retval = lookup (data, nel, value, std::less<T> ());
   else
 #endif
 #ifdef INLINE_DESCENDING_SORT
     if (compare == descending_compare)
       retval = lookup (data, nel, value, std::greater<T> ());
-  else
+    else
 #endif
-    if (compare)
-      retval = lookup (data, nel, value, std::ptr_fun (compare));
+      if (compare)
+        retval = lookup (data, nel, value, std::ptr_fun (compare));
 
   return retval;
 }
 
 template <class T> template <class Comp>
 void
 octave_sort<T>::lookup (const T *data, octave_idx_type nel,
                         const T *values, octave_idx_type nvalues,
@@ -1810,20 +1815,20 @@ octave_sort<T>::lookup (const T *data, o
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     lookup (data, nel, values, nvalues, idx, std::less<T> ());
   else
 #endif
 #ifdef INLINE_DESCENDING_SORT
     if (compare == descending_compare)
       lookup (data, nel, values, nvalues, idx, std::greater<T> ());
-  else
+    else
 #endif
-    if (compare)
-      lookup (data, nel, values, nvalues, idx, std::ptr_fun (compare));
+      if (compare)
+        lookup (data, nel, values, nvalues, idx, std::ptr_fun (compare));
 }
 
 template <class T> template <class Comp>
 void
 octave_sort<T>::lookup_sorted (const T *data, octave_idx_type nel,
                                const T *values, octave_idx_type nvalues,
                                octave_idx_type *idx, bool rev, Comp comp)
 {
@@ -1882,20 +1887,21 @@ octave_sort<T>::lookup_sorted (const T *
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     lookup_sorted (data, nel, values, nvalues, idx, rev, std::less<T> ());
   else
 #endif
 #ifdef INLINE_DESCENDING_SORT
     if (compare == descending_compare)
       lookup_sorted (data, nel, values, nvalues, idx, rev, std::greater<T> ());
-  else
+    else
 #endif
-    if (compare)
-      lookup_sorted (data, nel, values, nvalues, idx, rev, std::ptr_fun (compare));
+      if (compare)
+        lookup_sorted (data, nel, values, nvalues, idx, rev,
+                       std::ptr_fun (compare));
 }
 
 template <class T> template <class Comp>
 void
 octave_sort<T>::nth_element (T *data, octave_idx_type nel,
                              octave_idx_type lo, octave_idx_type up,
                              Comp comp)
 {
@@ -1929,20 +1935,20 @@ octave_sort<T>::nth_element (T *data, oc
 #ifdef INLINE_ASCENDING_SORT
   if (compare == ascending_compare)
     nth_element (data, nel, lo, up, std::less<T> ());
   else
 #endif
 #ifdef INLINE_DESCENDING_SORT
     if (compare == descending_compare)
       nth_element (data, nel, lo, up, std::greater<T> ());
-  else
+    else
 #endif
-    if (compare)
-      nth_element (data, nel, lo, up, std::ptr_fun (compare));
+      if (compare)
+        nth_element (data, nel, lo, up, std::ptr_fun (compare));
 }
 
 template <class T>
 bool
 octave_sort<T>::ascending_compare (typename ref_param<T>::type x,
                                    typename ref_param<T>::type y)
 {
   return x < y;
diff --git a/liboctave/util/oct-sort.h b/liboctave/util/oct-sort.h
--- a/liboctave/util/oct-sort.h
+++ b/liboctave/util/oct-sort.h
@@ -179,23 +179,23 @@ private:
   {
     octave_idx_type base, len;
   };
 
   struct MergeState
   {
     MergeState (void)
       : min_gallop (), a (0), ia (0), alloced (0), n (0)
-      { reset (); }
+    { reset (); }
 
     ~MergeState (void)
-      { delete [] a; delete [] ia; }
+    { delete [] a; delete [] ia; }
 
     void reset (void)
-      { min_gallop = MIN_GALLOP; n = 0; }
+    { min_gallop = MIN_GALLOP; n = 0; }
 
     void getmem (octave_idx_type need);
 
     void getmemi (octave_idx_type need);
 
     // This controls when we get *into* galloping mode.  It's
     // initialized to MIN_GALLOP.  merge_lo and merge_hi tend to nudge
     // it higher for random data, and lower for highly structured
@@ -228,32 +228,33 @@ private:
 
   compare_fcn_type compare;
 
   MergeState *ms;
 
 
   template <class Comp>
   void binarysort (T *data, octave_idx_type nel,
-              octave_idx_type start, Comp comp);
+                   octave_idx_type start, Comp comp);
 
   template <class Comp>
   void binarysort (T *data, octave_idx_type *idx, octave_idx_type nel,
-              octave_idx_type start, Comp comp);
+                   octave_idx_type start, Comp comp);
 
   template <class Comp>
-  octave_idx_type count_run (T *lo, octave_idx_type n, bool& descending, Comp comp);
+  octave_idx_type count_run (T *lo, octave_idx_type n, bool& descending,
+                             Comp comp);
 
   template <class Comp>
-  octave_idx_type gallop_left (T key, T *a, octave_idx_type n, octave_idx_type hint,
-                               Comp comp);
+  octave_idx_type gallop_left (T key, T *a, octave_idx_type n,
+                               octave_idx_type hint, Comp comp);
 
   template <class Comp>
-  octave_idx_type gallop_right (T key, T *a, octave_idx_type n, octave_idx_type hint,
-                                Comp comp);
+  octave_idx_type gallop_right (T key, T *a, octave_idx_type n,
+                                octave_idx_type hint, Comp comp);
 
   template <class Comp>
   int merge_lo (T *pa, octave_idx_type na,
                 T *pb, octave_idx_type nb,
                 Comp comp);
 
   template <class Comp>
   int merge_lo (T *pa, octave_idx_type *ipa, octave_idx_type na,
@@ -266,22 +267,20 @@ private:
                 Comp comp);
 
   template <class Comp>
   int merge_hi (T *pa, octave_idx_type *ipa, octave_idx_type na,
                 T *pb, octave_idx_type *ipb, octave_idx_type nb,
                 Comp comp);
 
   template <class Comp>
-  int merge_at (octave_idx_type i, T *data,
-                Comp comp);
+  int merge_at (octave_idx_type i, T *data, Comp comp);
 
   template <class Comp>
-  int merge_at (octave_idx_type i, T *data, octave_idx_type *idx,
-                Comp comp);
+  int merge_at (octave_idx_type i, T *data, octave_idx_type *idx, Comp comp);
 
   template <class Comp>
   int merge_collapse (T *data, Comp comp);
 
   template <class Comp>
   int merge_collapse (T *data, octave_idx_type *idx, Comp comp);
 
   template <class Comp>
diff --git a/liboctave/util/pathsearch.cc b/liboctave/util/pathsearch.cc
--- a/liboctave/util/pathsearch.cc
+++ b/liboctave/util/pathsearch.cc
@@ -127,24 +127,24 @@ dir_path::find_all (const std::string& n
 {
   return initialized ? kpse_all_path_search (p, nm) : string_vector ();
 }
 
 std::string
 dir_path::find_first_of (const string_vector& names)
 {
   return initialized
-    ? kpse_path_find_first_of (p, names, true) : std::string ();
+         ? kpse_path_find_first_of (p, names, true) : std::string ();
 }
 
 string_vector
 dir_path::find_all_first_of (const string_vector& names)
 {
   return initialized
-    ? kpse_all_path_find_first_of (p, names) : string_vector ();
+         ? kpse_all_path_find_first_of (p, names) : string_vector ();
 }
 
 void
 dir_path::init (void)
 {
   static bool octave_kpathsea_initialized = false;
 
   if (! octave_kpathsea_initialized)
diff --git a/liboctave/util/pathsearch.h b/liboctave/util/pathsearch.h
--- a/liboctave/util/pathsearch.h
+++ b/liboctave/util/pathsearch.h
@@ -31,61 +31,61 @@ class
 OCTAVE_API
 dir_path
 {
 public:
 
   dir_path (const std::string& s = std::string (),
             const std::string& d = std::string ())
     : p_orig (s), p_default (d), initialized (false), p (), pv ()
-    {
-      if (! p_orig.empty ())
-        init ();
-    }
+  {
+    if (! p_orig.empty ())
+      init ();
+  }
 
   dir_path (const dir_path& dp)
     : p_orig (dp.p_orig), p_default (dp.p_default),
       initialized (dp.initialized), p (dp.p), pv (dp.pv)
   { }
 
   dir_path& operator = (const dir_path& dp)
-    {
-      p_orig = dp.p_orig;
-      p_default = dp.p_default;
-      initialized = dp.initialized;
-      p = dp.p;
-      pv = dp.pv;
-      return *this;
-    }
+  {
+    p_orig = dp.p_orig;
+    p_default = dp.p_default;
+    initialized = dp.initialized;
+    p = dp.p;
+    pv = dp.pv;
+    return *this;
+  }
 
   ~dir_path (void) { }
 
   void set (const std::string& s)
-    {
-      initialized = false;
-      p_orig = s;
-      init ();
-    }
+  {
+    initialized = false;
+    p_orig = s;
+    init ();
+  }
 
   string_vector elements (void);
   string_vector all_directories (void);
 
   std::string find_first (const std::string&);
   std::string find (const std::string& nm) { return find_first (nm); }
 
   string_vector find_all (const std::string&);
 
   std::string find_first_of (const string_vector& names);
   string_vector find_all_first_of (const string_vector& names);
 
   void rehash (void)
-    {
-      initialized = false;
-      init ();
-    }
+  {
+    initialized = false;
+    init ();
+  }
 
   static char path_sep_char (void)
   {
     return static_members::path_sep_char ();
   }
 
   static void path_sep_char (char c)
   {
diff --git a/liboctave/util/sparse-util.cc b/liboctave/util/sparse-util.cc
--- a/liboctave/util/sparse-util.cc
+++ b/liboctave/util/sparse-util.cc
@@ -92,17 +92,18 @@ sparse_indices_ok (octave_idx_type *r, o
               (*current_liboctave_error_handler)
                 ("invalid sparse matrix: cidx elements must appear in ascending order");
               return false;
             }
 
           if (c[j] > nnz)
             {
               (*current_liboctave_error_handler)
-                ("invalid sparse matrix: cidx[%d] = %d exceeds number of nonzero elements", j, c[j]+1);
+                ("invalid sparse matrix: cidx[%d] = %d exceeds number of nonzero elements",
+                 j, c[j]+1);
               return false;
             }
 
           if (c[j] != jold)
             {
               for (octave_idx_type i = jold+1; i < c[j]; i++)
                 {
                   if (r[i] < r[i-1])
diff --git a/liboctave/util/str-vec.cc b/liboctave/util/str-vec.cc
--- a/liboctave/util/str-vec.cc
+++ b/liboctave/util/str-vec.cc
@@ -34,17 +34,17 @@ 90, 91, 95, 1996 Free Software Foundatio
 
 #include <iostream>
 #include <string>
 
 #include "cmd-edit.h"
 #include "lo-utils.h"
 #include "str-vec.h"
 
-// FIXME -- isn't there some STL trick that could be used to make this
+// FIXME: isn't there some STL trick that could be used to make this
 // work for all STL containers of std::string objects?
 
 string_vector::string_vector (const std::list<std::string>& lst)
   : Array<std::string> ()
 {
   size_t n = lst.size ();
 
   resize (n);
diff --git a/liboctave/util/str-vec.h b/liboctave/util/str-vec.h
--- a/liboctave/util/str-vec.h
+++ b/liboctave/util/str-vec.h
@@ -88,19 +88,21 @@ public:
     return longest;
   }
 
   void resize (octave_idx_type n, const std::string& rfv = std::string ())
   {
     Array<std::string>::resize (dim_vector (n, 1), rfv);
   }
 
-  std::string& operator[] (octave_idx_type i) { return Array<std::string>::elem (i); }
+  std::string& operator[] (octave_idx_type i)
+  { return Array<std::string>::elem (i); }
 
-  std::string operator[] (octave_idx_type i) const { return Array<std::string>::elem (i); }
+  std::string operator[] (octave_idx_type i) const
+  { return Array<std::string>::elem (i); }
 
   string_vector& sort (bool make_uniq = false);
 
   string_vector& uniq (void);
 
   string_vector& append (const std::string& s);
 
   string_vector& append (const string_vector& sv);
diff --git a/liboctave/util/unwind-prot.h b/liboctave/util/unwind-prot.h
--- a/liboctave/util/unwind-prot.h
+++ b/liboctave/util/unwind-prot.h
@@ -114,29 +114,29 @@ private:
 
   static void gripe_exception (void);
 
 public:
 
   unwind_protect_safe (void) : unwind_protect () { }
 
   ~unwind_protect_safe (void)
-    {
-      while (! empty ())
-        {
-          try
-            {
-              run_first ();
-            }
-          catch (...) // Yes, the black hole. Remember we're in a dtor.
-            {
-              gripe_exception ();
-            }
-        }
-    }
+  {
+    while (! empty ())
+      {
+        try
+          {
+            run_first ();
+          }
+        catch (...) // Yes, the black hole. Remember we're in a dtor.
+          {
+            gripe_exception ();
+          }
+      }
+  }
 
 private:
 
   // No copying!
 
   unwind_protect_safe (const unwind_protect_safe&);
 
   unwind_protect_safe& operator = (const unwind_protect_safe&);
diff --git a/liboctave/util/url-transfer.cc b/liboctave/util/url-transfer.cc
--- a/liboctave/util/url-transfer.cc
+++ b/liboctave/util/url-transfer.cc
@@ -62,17 +62,17 @@ base_url_transfer::mget_directory (const
     {
       std::string msg;
       int status = octave_mkdir (directory, 0777, msg);
 
       if (status < 0)
         {
           ok = false;
           errmsg = "__ftp_mget__: can not create directory '"
-            + target + sep + directory + "': " + msg;
+                   + target + sep + directory + "': " + msg;
           return;
         }
     }
 
   cwd (directory);
 
   if (good ())
     {
@@ -162,17 +162,17 @@ base_url_transfer::mput_directory (const
 
               std::string realfile = realdir + file_ops::dir_sep_str () + file;
               file_stat fs (realfile);
 
               if (! fs.exists ())
                 {
                   ok = false;
                   errmsg = "__ftp__mput: file '" + realfile
-                    + "' does not exist";
+                           + "' does not exist";
                   break;
                 }
 
               if (fs.is_dir ())
                 {
                   file_list.append (mput_directory (realdir, file));
 
                   if (! good ())
@@ -183,17 +183,17 @@ base_url_transfer::mput_directory (const
                   // FIXME Does ascii mode need to be flagged here?
                   std::ifstream ifile (realfile.c_str (), std::ios::in |
                                        std::ios::binary);
 
                   if (! ifile.is_open ())
                     {
                       ok = false;
                       errmsg = "__ftp_mput__: unable to open file '"
-                        + realfile + "'";
+                               + realfile + "'";
                       break;
                     }
 
                   put (file, ifile);
 
                   ifile.close ();
 
                   if (! good ())
@@ -202,17 +202,17 @@ base_url_transfer::mput_directory (const
                   file_list.append (realfile);
                 }
             }
         }
       else
         {
           ok = false;
           errmsg = "__ftp_mput__: can not read the directory '"
-            + realdir + "'";
+                   + realdir + "'";
         }
     }
 
   return file_list;
 }
 
 #if defined (HAVE_CURL)
 
diff --git a/liboctave/util/url-transfer.h b/liboctave/util/url-transfer.h
--- a/liboctave/util/url-transfer.h
+++ b/liboctave/util/url-transfer.h
@@ -88,17 +88,17 @@ public:
   virtual void ascii (void) { }
 
   virtual void binary (void) { }
 
   bool is_ascii (void) const { return ascii_mode; }
 
   bool is_binary (void) const { return !ascii_mode; }
 
-  virtual void cwd (const std::string& /* path */) { } 
+  virtual void cwd (const std::string& /* path */) { }
 
   virtual void del (const std::string& /* file */) { }
 
   virtual void rmdir (const std::string& /* path */) { }
 
   virtual void mkdir (const std::string& /* path */) { }
 
   virtual void rename (const std::string& /* oldname */,
