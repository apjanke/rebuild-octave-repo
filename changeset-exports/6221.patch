# HG changeset patch
# User jwe
# Date 1167845014 0
#      Wed Jan 03 17:23:34 2007 +0000
# Node ID 8e0f1eda266b7e1688d87959efab5369b4bdc0bb
# Parent  0c3537d2a84465bc17bd0252ab78fffaca22c023
[project @ 2007-01-03 17:23:33 by jwe]

diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,24 @@
+2007-01-03  David Bateman  <dbateman@free.fr>
+
+	* MSparse.cc (SPARSE_A2A2_OP, SPARSE_A2A2_FCN_1,
+	SPARSE_A2A2_FCN_1): Modify macros so that scalars stored as
+	sparse matrices are special cased.
+
+	* Sparse-op-defs.h: Include mx-ops.h to have access to mixed
+	matrix, sparse matrix operations.
+	(SPARSE_SMSM_BIN_OP_1, SPARSE_SMSM_BIN_OP_2, SPARSE_SMSM_BIN_OP_3,
+	SPARSE_SMSM_CMP_OP, SPARSE_SMSM_BOOL_OP, SPARSE_MSM_BIN_OP_1,
+	SPARSE_MSM_BIN_OP_2, SPARSE_MSM_CMP_OP, SPARSE_MSM_BOOL_OP,
+	SPARSE_SMM_BIN_OP_1, SPARSE_SMM_BIN_OP_2, SPARSE_SMM_CMP_OP, 
+	SPARSE_SMM_BOOL_OP, SPARSE_SPARSE_MUL, SPARSE_FULL_MUL, 
+	FULL_SPARSE_MUL): Modify macros so that scalars stored as
+	sparse matrices are special cased.
+
 2006-12-22  David Bateman  <dbateman@free.fr>
 
 	* boolSparse.cc (SparseBoolMatrix::operator !): Fix off-by-one error.
 
 2006-12-22  John W. Eaton  <jwe@octave.org>
 
 	* dim-vector.h (dim_vector::dim_vector): Always start with at
 	least 2 dimensions.
diff --git a/liboctave/MSparse.cc b/liboctave/MSparse.cc
--- a/liboctave/MSparse.cc
+++ b/liboctave/MSparse.cc
@@ -283,17 +283,59 @@ SPARSE_SA2_OP_2 (/)
     MSparse<T> r; \
  \
     octave_idx_type a_nr = a.rows (); \
     octave_idx_type a_nc = a.cols (); \
  \
     octave_idx_type b_nr = b.rows (); \
     octave_idx_type b_nc = b.cols (); \
  \
-    if (a_nr != b_nr || a_nc != b_nc) \
+    if (a_nr == 1 && a_nc == 1) \
+      { \
+        if (a.elem(0,0) == 0.) \
+          r = MSparse<T> (b); \
+        else \
+          { \
+	    r = MSparse<T> (b_nr, b_nc, a.data(0) OP 0.); \
+            \
+            for (octave_idx_type j = 0 ; j < b_nc ; j++) \
+              { \
+                OCTAVE_QUIT; \
+                octave_idx_type idxj = j * b_nr; \
+                for (octave_idx_type i = b.cidx(j) ; i < b.cidx(j+1) ; i++) \
+                  { \
+                   OCTAVE_QUIT; \
+                   r.data(idxj + b.ridx(i)) = a.data(0) OP b.data(i); \
+		  } \
+              } \
+            r.maybe_compress (); \
+          } \
+      } \
+    else if (b_nr == 1 && b_nc == 1) \
+      { \
+        if (b.elem(0,0) == 0.) \
+          r = MSparse<T> (a); \
+        else \
+          { \
+	    r = MSparse<T> (a_nr, a_nc, 0. OP b.data(0)); \
+            \
+            for (octave_idx_type j = 0 ; j < a_nc ; j++) \
+              { \
+                OCTAVE_QUIT; \
+                octave_idx_type idxj = j * a_nr; \
+                for (octave_idx_type i = a.cidx(j) ; i < a.cidx(j+1) ; i++) \
+                  { \
+                    OCTAVE_QUIT; \
+                    r.data(idxj + a.ridx(i)) = a.data(i) OP b.data(0); \
+		  } \
+              } \
+            r.maybe_compress (); \
+          } \
+      } \
+    else if (a_nr != b_nr || a_nc != b_nc) \
       gripe_nonconformant ("operator " # OP, a_nr, a_nc, b_nr, b_nc); \
     else \
       { \
         r = MSparse<T> (a_nr, a_nc, (a.nnz () + b.nnz ())); \
         \
         octave_idx_type jx = 0; \
 	r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < a_nc ; i++) \
@@ -358,17 +400,51 @@ SPARSE_SA2_OP_2 (/)
     MSparse<T> r; \
  \
     octave_idx_type a_nr = a.rows (); \
     octave_idx_type a_nc = a.cols (); \
  \
     octave_idx_type b_nr = b.rows (); \
     octave_idx_type b_nc = b.cols (); \
  \
-    if (a_nr != b_nr || a_nc != b_nc) \
+    if (a_nr == 1 && a_nc == 1) \
+      { \
+        if (a.elem(0,0) == 0.) \
+          r = MSparse<T> (b_nr, b_nc); \
+        else \
+          { \
+	    r = MSparse<T> (b); \
+            octave_idx_type b_nnz = b.nnz(); \
+            \
+            for (octave_idx_type i = 0 ; i < b_nnz ; i++) \
+              { \
+                OCTAVE_QUIT; \
+                r.data (i) = a.data(0) OP r.data(i); \
+              } \
+            r.maybe_compress (); \
+          } \
+      } \
+    else if (b_nr == 1 && b_nc == 1) \
+      { \
+        if (b.elem(0,0) == 0.) \
+          r = MSparse<T> (a_nr, a_nc); \
+        else \
+          { \
+	    r = MSparse<T> (a); \
+            octave_idx_type a_nnz = a.nnz(); \
+            \
+            for (octave_idx_type i = 0 ; i < a_nnz ; i++) \
+              { \
+                OCTAVE_QUIT; \
+                r.data (i) = r.data(i) OP b.data(0); \
+              } \
+            r.maybe_compress (); \
+          } \
+      } \
+    else if (a_nr != b_nr || a_nc != b_nc) \
       gripe_nonconformant (#FCN, a_nr, a_nc, b_nr, b_nc); \
     else \
       { \
         r = MSparse<T> (a_nr, a_nc, (a.nnz () > b.nnz () ? a.nnz () : b.nnz ())); \
         \
         octave_idx_type jx = 0; \
 	r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < a_nc ; i++) \
@@ -424,17 +500,73 @@ SPARSE_SA2_OP_2 (/)
     T Zero = T (); \
  \
     octave_idx_type a_nr = a.rows (); \
     octave_idx_type a_nc = a.cols (); \
  \
     octave_idx_type b_nr = b.rows (); \
     octave_idx_type b_nc = b.cols (); \
  \
-    if (a_nr != b_nr || a_nc != b_nc) \
+    if (a_nr == 1 && a_nc == 1) \
+      { \
+        T val = a.elem (0,0); \
+        T fill = val OP T(); \
+        if (fill == T()) \
+          { \
+            octave_idx_type b_nnz = b.nnz(); \
+            r = MSparse<T> (b); \
+            for (octave_idx_type i = 0 ; i < b_nnz ; i++) \
+              r.data (i) = val OP r.data(i); \
+            r.maybe_compress (); \
+          } \
+        else \
+          { \
+            r = MSparse<T> (b_nr, b_nc, fill); \
+            for (octave_idx_type j = 0 ; j < b_nc ; j++) \
+              { \
+                OCTAVE_QUIT; \
+                octave_idx_type idxj = j * b_nr; \
+                for (octave_idx_type i = b.cidx(j) ; i < b.cidx(j+1) ; i++) \
+                  { \
+                    OCTAVE_QUIT; \
+                    r.data(idxj + b.ridx(i)) = val OP b.data(i); \
+		  } \
+              } \
+            r.maybe_compress (); \
+          } \
+      } \
+    else if (b_nr == 1 && b_nc == 1) \
+      { \
+        T val = b.elem (0,0); \
+        T fill = T() OP val; \
+        if (fill == T()) \
+          { \
+            octave_idx_type a_nnz = a.nnz(); \
+            r = MSparse<T> (a); \
+            for (octave_idx_type i = 0 ; i < a_nnz ; i++) \
+              r.data (i) = r.data(i) OP val; \
+            r.maybe_compress (); \
+          } \
+        else \
+          { \
+            r = MSparse<T> (a_nr, a_nc, fill); \
+            for (octave_idx_type j = 0 ; j < a_nc ; j++) \
+              { \
+                OCTAVE_QUIT; \
+                octave_idx_type idxj = j * a_nr; \
+                for (octave_idx_type i = a.cidx(j) ; i < a.cidx(j+1) ; i++) \
+                  { \
+                    OCTAVE_QUIT; \
+                    r.data(idxj + a.ridx(i)) = a.data(i) OP val; \
+		  } \
+              } \
+            r.maybe_compress (); \
+          } \
+      } \
+    else if (a_nr != b_nr || a_nc != b_nc) \
       gripe_nonconformant (#FCN, a_nr, a_nc, b_nr, b_nc); \
     else \
       { \
         r = MSparse<T>( a_nr, a_nc, (Zero OP Zero)); \
         \
         for (octave_idx_type i = 0 ; i < a_nc ; i++) \
           { \
             octave_idx_type  ja = a.cidx(i); \
diff --git a/liboctave/Sparse-op-defs.h b/liboctave/Sparse-op-defs.h
--- a/liboctave/Sparse-op-defs.h
+++ b/liboctave/Sparse-op-defs.h
@@ -19,16 +19,17 @@ Free Software Foundation, Inc., 51 Frank
 Boston, MA 02110-1301, USA.
 
 */
 
 #if !defined (octave_sparse_op_defs_h)
 #define octave_sparse_op_defs_h 1
 
 #include "Array-util.h"
+#include "mx-ops.h"
 
 #define SPARSE_BIN_OP_DECL(R, OP, X, Y) \
   extern OCTAVE_API R OP (const X&, const Y&)
 
 #define SPARSE_CMP_OP_DECL(OP, X, Y) \
   extern OCTAVE_API SparseBoolMatrix OP (const X&, const Y&)
 
 #define SPARSE_BOOL_OP_DECL(OP, X, Y) \
@@ -468,17 +469,59 @@ Boston, MA 02110-1301, USA.
     R r; \
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
-    if (m1_nr != m2_nr || m1_nc != m2_nc) \
+    if (m1_nr == 1 && m1_nc == 1) \
+      { \
+        if (m1.elem(0,0) == 0.) \
+          r = R (m2); \
+        else \
+          { \
+	    r = R (m2_nr, m2_nc, m1.data(0) OP 0.); \
+            \
+            for (octave_idx_type j = 0 ; j < m2_nc ; j++) \
+              { \
+                OCTAVE_QUIT; \
+                octave_idx_type idxj = j * m2_nr; \
+                for (octave_idx_type i = m2.cidx(j) ; i < m2.cidx(j+1) ; i++) \
+                  { \
+                    OCTAVE_QUIT; \
+                    r.data(idxj + m2.ridx(i)) = m1.data(0) OP m2.data(i); \
+		  } \
+              } \
+            r.maybe_compress (); \
+          } \
+      } \
+    else if (m2_nr == 1 && m2_nc == 1) \
+      { \
+        if (m2.elem(0,0) == 0.) \
+          r = R (m1); \
+        else \
+          { \
+	    r = R (m1_nr, m1_nc, 0. OP m2.data(0)); \
+            \
+            for (octave_idx_type j = 0 ; j < m1_nc ; j++) \
+              { \
+                OCTAVE_QUIT; \
+                octave_idx_type idxj = j * m1_nr; \
+                for (octave_idx_type i = m1.cidx(j) ; i < m1.cidx(j+1) ; i++) \
+                  { \
+                    OCTAVE_QUIT; \
+                    r.data(idxj + m1.ridx(i)) = m1.data(i) OP m2.data(0); \
+		  } \
+              } \
+            r.maybe_compress (); \
+          } \
+      } \
+    else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
 	r = R (m1_nr, m1_nc, (m1.nnz () + m2.nnz ())); \
         \
         octave_idx_type jx = 0; \
         r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
@@ -542,17 +585,51 @@ Boston, MA 02110-1301, USA.
     R r; \
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
-    if (m1_nr != m2_nr || m1_nc != m2_nc) \
+    if (m1_nr == 1 && m1_nc == 1) \
+      { \
+        if (m1.elem(0,0) == 0.) \
+          r = R (m2_nr, m2_nc); \
+        else \
+          { \
+	    r = R (m2); \
+            octave_idx_type m2_nnz = m2.nnz(); \
+            \
+            for (octave_idx_type i = 0 ; i < m2_nnz ; i++) \
+              { \
+                OCTAVE_QUIT; \
+                r.data (i) = m1.data(0) OP r.data(i); \
+              } \
+            r.maybe_compress (); \
+          } \
+      } \
+    else if (m2_nr == 1 && m2_nc == 1) \
+      { \
+        if (m2.elem(0,0) == 0.) \
+          r = R (m1_nr, m1_nc); \
+        else \
+          { \
+	    r = R (m1); \
+            octave_idx_type m1_nnz = m1.nnz(); \
+            \
+            for (octave_idx_type i = 0 ; i < m1_nnz ; i++) \
+              { \
+                OCTAVE_QUIT; \
+                r.data (i) = r.data(i) OP m2.data(0); \
+              } \
+            r.maybe_compress (); \
+          } \
+      } \
+    else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (m1_nr, m1_nc, (m1.nnz () > m2.nnz () ? m1.nnz () : m2.nnz ())); \
         \
         octave_idx_type jx = 0; \
 	r.cidx (0) = 0; \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
@@ -606,17 +683,69 @@ Boston, MA 02110-1301, USA.
     R r; \
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
-    if (m1_nr != m2_nr || m1_nc != m2_nc) \
+    if (m1_nr == 1 && m1_nc == 1) \
+      { \
+        if ((m1.elem (0,0) OP Complex()) == Complex()) \
+          { \
+            octave_idx_type m2_nnz = m2.nnz(); \
+            r = R (m2); \
+            for (octave_idx_type i = 0 ; i < m2_nnz ; i++) \
+              r.data (i) = m1.elem(0,0) OP r.data(i); \
+            r.maybe_compress (); \
+          } \
+        else \
+          { \
+            r = R (m2_nr, m2_nc, m1.elem(0,0) OP Complex ()); \
+            for (octave_idx_type j = 0 ; j < m2_nc ; j++) \
+              { \
+                OCTAVE_QUIT; \
+                octave_idx_type idxj = j * m2_nr; \
+                for (octave_idx_type i = m2.cidx(j) ; i < m2.cidx(j+1) ; i++) \
+                  { \
+                    OCTAVE_QUIT; \
+                    r.data(idxj + m2.ridx(i)) = m1.elem(0,0) OP m2.data(i); \
+		  } \
+              } \
+            r.maybe_compress (); \
+          } \
+      } \
+    else if (m2_nr == 1 && m2_nc == 1) \
+      { \
+        if ((Complex() OP m1.elem (0,0)) == Complex()) \
+          { \
+            octave_idx_type m1_nnz = m1.nnz(); \
+            r = R (m1); \
+            for (octave_idx_type i = 0 ; i < m1_nnz ; i++) \
+              r.data (i) = r.data(i) OP m2.elem(0,0); \
+            r.maybe_compress (); \
+          } \
+        else \
+          { \
+            r = R (m1_nr, m1_nc, Complex() OP m2.elem(0,0)); \
+            for (octave_idx_type j = 0 ; j < m1_nc ; j++) \
+              { \
+                OCTAVE_QUIT; \
+                octave_idx_type idxj = j * m1_nr; \
+                for (octave_idx_type i = m1.cidx(j) ; i < m1.cidx(j+1) ; i++) \
+                  { \
+                    OCTAVE_QUIT; \
+                    r.data(idxj + m1.ridx(i)) = m1.data(i) OP m2.elem(0,0); \
+		  } \
+              } \
+            r.maybe_compress (); \
+          } \
+      } \
+    else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
  \
         /* FIXME Kludge... Always double/Complex, so Complex () */ \
         r = R (m1_nr, m1_nc, (Complex () OP Complex ())); \
         \
         for (octave_idx_type i = 0 ; i < m1_nc ; i++) \
@@ -693,17 +822,29 @@ Boston, MA 02110-1301, USA.
     SparseBoolMatrix r; \
     \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
-    if (m1_nr == m2_nr && m1_nc == m2_nc) \
+    if (m1_nr == 1 && m1_nc == 1) \
+      { \
+        extern OCTAVE_API SparseBoolMatrix F (const double&, const M2&); \
+        extern OCTAVE_API SparseBoolMatrix F (const Complex&, const M2&); \
+        r = F (m1.elem(0,0), m2); \
+      } \
+    else if (m2_nr == 1 && m2_nc == 1) \
+      { \
+        extern OCTAVE_API SparseBoolMatrix F (const M1&, const double&); \
+        extern OCTAVE_API SparseBoolMatrix F (const M1&, const Complex&); \
+        r = F (m1, m2.elem(0,0)); \
+      } \
+    else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
 	if (m1_nr != 0 || m1_nc != 0) \
 	  { \
 	    /* Count num of non-zero elements */ \
 	    octave_idx_type nel = 0; \
 	    for (octave_idx_type j = 0; j < m1_nc; j++) \
 	      for (octave_idx_type i = 0; i < m1_nr; i++) \
 		if (C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j))) \
@@ -759,17 +900,29 @@ Boston, MA 02110-1301, USA.
     SparseBoolMatrix r; \
     \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
-    if (m1_nr == m2_nr && m1_nc == m2_nc) \
+    if (m1_nr == 1 && m1_nc == 1) \
+      { \
+        extern OCTAVE_API SparseBoolMatrix F (const double&, const M2&); \
+        extern OCTAVE_API SparseBoolMatrix F (const Complex&, const M2&); \
+        r = F (m1.elem(0,0), m2); \
+      } \
+    else if (m2_nr == 1 && m2_nc == 1) \
+      { \
+        extern OCTAVE_API SparseBoolMatrix F (const M1&, const double&); \
+        extern OCTAVE_API SparseBoolMatrix F (const M1&, const Complex&); \
+        r = F (m1, m2.elem(0,0)); \
+      } \
+    else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
 	if (m1_nr != 0 || m1_nc != 0) \
 	  { \
 	    /* Count num of non-zero elements */ \
 	    octave_idx_type nel = 0; \
 	    for (octave_idx_type j = 0; j < m1_nc; j++) \
 	      for (octave_idx_type i = 0; i < m1_nr; i++) \
 		if ((m1.elem(i, j) != LHS_ZERO) \
@@ -831,17 +984,19 @@ Boston, MA 02110-1301, USA.
     R r; \
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
-    if (m1_nr != m2_nr || m1_nc != m2_nc) \
+    if (m2_nr == 1 && m2_nc == 1) \
+      r = R (m1 OP m2.elem(0,0)); \
+    else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (m1_nr, m1_nc); \
         \
         for (octave_idx_type j = 0; j < m1_nc; j++) \
 	  for (octave_idx_type i = 0; i < m1_nr; i++) \
 	    r.elem (i, j) = m1.elem (i, j) OP m2.elem (i, j); \
@@ -856,17 +1011,19 @@ Boston, MA 02110-1301, USA.
     R r; \
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
-    if (m1_nr != m2_nr || m1_nc != m2_nc) \
+    if (m2_nr == 1 && m2_nc == 1) \
+      r = R (m1 OP m2.elem(0,0)); \
+    else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
 	/* Count num of non-zero elements */ \
 	octave_idx_type nel = 0; \
 	for (octave_idx_type j = 0; j < m1_nc; j++) \
 	  for (octave_idx_type i = 0; i < m1_nr; i++) \
 	    if ((m1.elem(i, j) OP m2.elem(i, j)) != ZERO) \
@@ -919,17 +1076,19 @@ Boston, MA 02110-1301, USA.
     SparseBoolMatrix r; \
     \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
-    if (m1_nr == m2_nr && m1_nc == m2_nc) \
+    if (m2_nr == 1 && m2_nc == 1) \
+      r = SparseBoolMatrix (F (m1, m2.elem(0,0))); \
+    else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
 	if (m1_nr != 0 || m1_nc != 0) \
 	  { \
 	    /* Count num of non-zero elements */ \
 	    octave_idx_type nel = 0; \
 	    for (octave_idx_type j = 0; j < m1_nc; j++) \
 	      for (octave_idx_type i = 0; i < m1_nr; i++) \
 		if (C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j))) \
@@ -985,17 +1144,19 @@ Boston, MA 02110-1301, USA.
     SparseBoolMatrix r; \
     \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
-    if (m1_nr == m2_nr && m1_nc == m2_nc) \
+    if (m2_nr == 1 && m2_nc == 1) \
+      r = SparseBoolMatrix  (F (m1, m2.elem(0,0))); \
+    else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
 	if (m1_nr != 0 || m1_nc != 0) \
 	  { \
 	    /* Count num of non-zero elements */ \
 	    octave_idx_type nel = 0; \
 	    for (octave_idx_type j = 0; j < m1_nc; j++) \
 	      for (octave_idx_type i = 0; i < m1_nr; i++) \
 		if ((m1.elem(i, j) != LHS_ZERO) \
@@ -1057,17 +1218,19 @@ Boston, MA 02110-1301, USA.
     R r; \
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
-    if (m1_nr != m2_nr || m1_nc != m2_nc) \
+    if (m1_nr == 1 && m1_nc == 1) \
+      r = R (m1.elem(0,0) OP m2); \
+    else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
         r = R (m1_nr, m1_nc); \
         \
         for (octave_idx_type j = 0; j < m1_nc; j++) \
 	  for (octave_idx_type i = 0; i < m1_nr; i++) \
 	    r.elem (i, j) = m1.elem (i, j) OP m2.elem (i, j); \
@@ -1082,17 +1245,19 @@ Boston, MA 02110-1301, USA.
     R r; \
  \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
  \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
  \
-    if (m1_nr != m2_nr || m1_nc != m2_nc) \
+    if (m1_nr == 1 && m1_nc == 1) \
+      r = R (m1.elem(0,0) OP m2); \
+    else if (m1_nr != m2_nr || m1_nc != m2_nc) \
       gripe_nonconformant (#F, m1_nr, m1_nc, m2_nr, m2_nc); \
     else \
       { \
 	/* Count num of non-zero elements */ \
 	octave_idx_type nel = 0; \
 	for (octave_idx_type j = 0; j < m1_nc; j++) \
 	  for (octave_idx_type i = 0; i < m1_nr; i++) \
 	    if ((m1.elem(i, j) OP m2.elem(i, j)) != ZERO) \
@@ -1145,17 +1310,19 @@ Boston, MA 02110-1301, USA.
     SparseBoolMatrix r; \
     \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
-    if (m1_nr == m2_nr && m1_nc == m2_nc) \
+    if (m1_nr == 1 && m1_nc == 1) \
+      r = SparseBoolMatrix (F (m1.elem(0,0), m2)); \
+    else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
 	if (m1_nr != 0 || m1_nc != 0) \
 	  { \
 	    /* Count num of non-zero elements */ \
 	    octave_idx_type nel = 0; \
 	    for (octave_idx_type j = 0; j < m1_nc; j++) \
 	      for (octave_idx_type i = 0; i < m1_nr; i++) \
 		if (C1 (m1.elem(i, j)) OP C2 (m2.elem(i, j))) \
@@ -1211,17 +1378,19 @@ Boston, MA 02110-1301, USA.
     SparseBoolMatrix r; \
     \
     octave_idx_type m1_nr = m1.rows (); \
     octave_idx_type m1_nc = m1.cols (); \
     \
     octave_idx_type m2_nr = m2.rows (); \
     octave_idx_type m2_nc = m2.cols (); \
     \
-    if (m1_nr == m2_nr && m1_nc == m2_nc) \
+    if (m1_nr == 1 && m1_nc == 1) \
+      r = SparseBoolMatrix (F (m1.elem(0,0), m2)); \
+    else if (m1_nr == m2_nr && m1_nc == m2_nc) \
       { \
 	if (m1_nr != 0 || m1_nc != 0) \
 	  { \
 	    /* Count num of non-zero elements */ \
 	    octave_idx_type nel = 0; \
 	    for (octave_idx_type j = 0; j < m1_nc; j++) \
 	      for (octave_idx_type i = 0; i < m1_nr; i++) \
 		if ((m1.elem(i, j) != LHS_ZERO) \
@@ -1535,17 +1704,59 @@ Boston, MA 02110-1301, USA.
 
 #define SPARSE_SPARSE_MUL( RET_TYPE, RET_EL_TYPE, EL_TYPE ) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
-  if (nc != a_nr) \
+  if (nr == 1 && nc == 1) \
+   { \
+     RET_EL_TYPE s = m.elem(0,0); \
+     octave_idx_type nz = a.nnz(); \
+     RET_TYPE r (a_nr, a_nc, nz); \
+     \
+     for (octave_idx_type i = 0; i < nz; i++) \
+       { \
+         OCTAVE_QUIT; \
+	 r.data(i) = s * a.data(i); \
+	 r.ridx(i) = a.ridx(i); \
+       } \
+     for (octave_idx_type i = 0; i < a_nc + 1; i++) \
+       { \
+         OCTAVE_QUIT; \
+         r.cidx(i) = a.cidx(i); \
+       } \
+     \
+     r.maybe_compress (true); \
+     return r; \
+   } \
+  else if (a_nr == 1 && a_nc == 1) \
+   { \
+     RET_EL_TYPE s = a.elem(0,0); \
+     octave_idx_type nz = m.nnz(); \
+     RET_TYPE r (nr, nc, nz); \
+     \
+     for (octave_idx_type i = 0; i < nz; i++) \
+       { \
+         OCTAVE_QUIT; \
+	 r.data(i) = m.data(i) * s; \
+	 r.ridx(i) = m.ridx(i); \
+       } \
+     for (octave_idx_type i = 0; i < nc + 1; i++) \
+       { \
+         OCTAVE_QUIT; \
+         r.cidx(i) = m.cidx(i); \
+       } \
+     \
+     r.maybe_compress (true); \
+     return r; \
+   } \
+  else if (nc != a_nr) \
     { \
       gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
       return RET_TYPE (); \
     } \
   else \
     { \
       OCTAVE_LOCAL_BUFFER (octave_idx_type, w, nr); \
       RET_TYPE retval (nr, a_nc, static_cast<octave_idx_type> (0)); \
@@ -1662,17 +1873,30 @@ Boston, MA 02110-1301, USA.
 
 #define SPARSE_FULL_MUL( RET_TYPE, EL_TYPE, ZERO ) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
-  if (nc != a_nr) \
+  if (nr == 1 && nc == 1) \
+    { \
+      RET_TYPE retval (a_nr, a_nc, ZERO); \
+      for (octave_idx_type i = 0; i < a_nc ; i++) \
+	{ \
+	  for (octave_idx_type j = 0; j < a_nr; j++) \
+	    { \
+              OCTAVE_QUIT; \
+	      retval.elem (j,i) += a.elem(j,i) * m.elem(0,0); \
+	    } \
+        } \
+      return retval; \
+    } \
+  else if (nc != a_nr) \
     { \
       gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
       return RET_TYPE (); \
     } \
   else \
     { \
       RET_TYPE retval (nr, a_nc, ZERO); \
       \
@@ -1692,17 +1916,30 @@ Boston, MA 02110-1301, USA.
 
 #define FULL_SPARSE_MUL( RET_TYPE, EL_TYPE, ZERO ) \
   octave_idx_type nr = m.rows (); \
   octave_idx_type nc = m.cols (); \
   \
   octave_idx_type a_nr = a.rows (); \
   octave_idx_type a_nc = a.cols (); \
   \
-  if (nc != a_nr) \
+  if (a_nr == 1 && a_nc == 1) \
+    { \
+      RET_TYPE retval (nr, nc, ZERO); \
+      for (octave_idx_type i = 0; i < nc ; i++) \
+	{ \
+	  for (octave_idx_type j = 0; j < nr; j++) \
+	    { \
+              OCTAVE_QUIT; \
+	      retval.elem (j,i) += a.elem(0,0) * m.elem(j,i); \
+	    } \
+        } \
+      return retval; \
+    } \
+  else if (nc != a_nr) \
     { \
       gripe_nonconformant ("operator *", nr, nc, a_nr, a_nc); \
       return RET_TYPE (); \
     } \
   else \
     { \
       RET_TYPE retval (nr, a_nc, ZERO); \
       \
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,34 @@
+2007-01-03  David Bateman  <dbateman@free.fr>
+
+	* (OPERATORS/op-cm-scm.cc, OPERATORS/op-cm-sm.cc, 
+	OPERATORS/op-cs-scm.cc, OPERATORS/op-cs-sm.cc, 
+	OPERATORS/op-m-scm.cc, OPERATORS/op-m-sm.cc, 
+	OPERATORS/op-scm-cm.cc, OPERATORS/op-scm-cs.cc, 
+	OPERATORS/op-scm-m.cc, OPERATORS/op-scm-s.cc, 
+	OPERATORS/op-scm-scm.cc, OPERATORS/op-scm-sm.cc, 
+	OPERATORS/op-sm-cm.cc, OPERATORS/op-sm-cs.cc, 
+	OPERATORS/op-sm-m.cc, OPERATORS/op-sm-s.cc, 
+	OPERATORS/op-sm-scm.cc, OPERATORS/op-sm-sm.cc, 
+	OPERATORS/op-s-scm.cc, OPERATORS/op-s-sm.cc):
+	Modify div and ldiv functions so that scalars stored as sparse 
+	matrices are special cased.
+
+	* ov-re-sparse.cc (double_value, complex_value): Scalar can be
+	stored as a sparse matrix and so don't warn on implicit conversion
+	to a scalar.
+	* ov-cx-sparse.cc (double_value, complex_value): ditto.
+	* ov-bool-sparse.cc (double_value, complex_value): ditto.
+
+2007-01-03  John W. Eaton  <jwe@octave.org>
+
+	* dynamic-ld.cc (octave_dynamic_loader::do_load_mex): Also check
+	for _mexFunction.
+
 2006-12-30  John W. Eaton  <jwe@octave.org>
 
 	* ov-fcn-inline.cc: For compatibility, class id is
 	"function_handle", not "inline function".
 
 2006-12-27  John W. Eaton  <jwe@octave.org>
 
 	* Makefile.in (%.df : %.cc): Insert a "do not edit" notice in the
diff --git a/src/OPERATORS/op-cm-scm.cc b/src/OPERATORS/op-cm-scm.cc
--- a/src/OPERATORS/op-cm-scm.cc
+++ b/src/OPERATORS/op-cm-scm.cc
@@ -35,33 +35,45 @@ Boston, MA 02110-1301, USA.
 #include "sparse-xpow.h"
 #include "sparse-xdiv.h"
 #include "smx-scm-cm.h"
 #include "smx-cm-scm.h"
 #include "ov-cx-sparse.h"
 
 // complex matrix by sparse complex matrix ops.
 
-DEFBINOP_OP (add, complex_matrix, sparse_complex_matrix,+)
-DEFBINOP_OP (sub, complex_matrix, sparse_complex_matrix,-)
+DEFBINOP_OP (add, complex_matrix, sparse_complex_matrix, +)
+DEFBINOP_OP (sub, complex_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, complex_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&,
 		   const octave_sparse_complex_matrix&);
-  
-  MatrixType typ = v2.matrix_type ();
+
+  if (v2.rows() == 1 && v2.columns() == 1)
+    {
+      Complex d = v2.complex_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
-			    v2.sparse_complex_matrix_value (), typ);
+      return octave_value (v1.complex_array_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v2.matrix_type ();
 
-  v2.matrix_type (typ);
-  return ret;
+      ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
+				v2.sparse_complex_matrix_value (), typ);
+
+      v2.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOPX (pow, complex_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
diff --git a/src/OPERATORS/op-cm-sm.cc b/src/OPERATORS/op-cm-sm.cc
--- a/src/OPERATORS/op-cm-sm.cc
+++ b/src/OPERATORS/op-cm-sm.cc
@@ -44,23 +44,35 @@ DEFBINOP_OP (add, complex_matrix, sparse
 DEFBINOP_OP (sub, complex_matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, complex_matrix, sparse_matrix, *)
 
 DEFBINOP (div, complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_sparse_matrix&);
   
-  MatrixType typ = v2.matrix_type ();
+  if (v2.rows() == 1 && v2.columns() == 1)
+    {
+      double d = v2.scalar_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
-			    v2.sparse_matrix_value (), typ);
+      return octave_value (v1.complex_array_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v2.matrix_type ();
 
-  v2.matrix_type (typ);
-  return ret;
+      ComplexMatrix ret = xdiv (v1.complex_matrix_value (), 
+				v2.sparse_matrix_value (), typ);
+
+      v2.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOPX (pow, complex_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
diff --git a/src/OPERATORS/op-cs-scm.cc b/src/OPERATORS/op-cs-scm.cc
--- a/src/OPERATORS/op-cs-scm.cc
+++ b/src/OPERATORS/op-cs-scm.cc
@@ -42,23 +42,34 @@ Boston, MA 02110-1301, USA.
 DEFBINOP_OP (add, complex, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, complex, sparse_complex_matrix, -)
 DEFBINOP_OP (mul, complex, sparse_complex_matrix, *)
 
 DEFBINOP (div, complex, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_complex_matrix&);
 
-  MatrixType typ = v2.matrix_type ();
-  ComplexMatrix m1 = ComplexMatrix (1, 1, v1.complex_value ());
-  SparseComplexMatrix m2 = v2.sparse_complex_matrix_value ();
-  ComplexMatrix ret = xdiv (m1, m2, typ);
-  v2.matrix_type (typ);
+  if (v2.rows() == 1 && v2.columns() == 1)
+    {
+      Complex d = v2.complex_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  return ret;
+      return octave_value (v1.complex_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v2.matrix_type ();
+      ComplexMatrix m1 = ComplexMatrix (1, 1, v1.complex_value ());
+      SparseComplexMatrix m2 = v2.sparse_complex_matrix_value ();
+      ComplexMatrix ret = xdiv (m1, m2, typ);
+      v2.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOP (pow, complex, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, 
 		   const octave_sparse_complex_matrix&);
   return xpow (v1.complex_value (), v2.complex_matrix_value ());
 }
diff --git a/src/OPERATORS/op-cs-sm.cc b/src/OPERATORS/op-cs-sm.cc
--- a/src/OPERATORS/op-cs-sm.cc
+++ b/src/OPERATORS/op-cs-sm.cc
@@ -44,23 +44,34 @@ Boston, MA 02110-1301, USA.
 DEFBINOP_OP (add, complex, sparse_matrix, +)
 DEFBINOP_OP (sub, complex, sparse_matrix, -)
 DEFBINOP_OP (mul, complex, sparse_matrix, *)
 
 DEFBINOP (div, complex, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_matrix&);
 
-  MatrixType typ = v2.matrix_type ();
-  ComplexMatrix m1 = ComplexMatrix (1, 1, v1.complex_value ());
-  SparseMatrix m2 = v2.sparse_matrix_value ();
-  ComplexMatrix ret = xdiv (m1, m2, typ);
-  v2.matrix_type (typ);
+  if (v2.rows() == 1 && v2.columns() == 1)
+    {
+      double d = v2.scalar_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  return ret;
+      return octave_value (v1.complex_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v2.matrix_type ();
+      ComplexMatrix m1 = ComplexMatrix (1, 1, v1.complex_value ());
+      SparseMatrix m2 = v2.sparse_matrix_value ();
+      ComplexMatrix ret = xdiv (m1, m2, typ);
+      v2.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOP (pow, complex, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex&, const octave_sparse_matrix&);
   return xpow (v1.complex_value (), v2.matrix_value ());
 }
 
diff --git a/src/OPERATORS/op-m-scm.cc b/src/OPERATORS/op-m-scm.cc
--- a/src/OPERATORS/op-m-scm.cc
+++ b/src/OPERATORS/op-m-scm.cc
@@ -45,23 +45,35 @@ DEFBINOP_OP (add, matrix, sparse_complex
 DEFBINOP_OP (sub, matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_complex_matrix&);
 
-  MatrixType typ = v2.matrix_type ();
+  if (v2.rows() == 1 && v2.columns() == 1)
+    {
+      Complex d = v2.complex_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  ComplexMatrix ret = xdiv (v1.matrix_value (), 
-			    v2.sparse_complex_matrix_value (), typ);
+      return octave_value (v1.array_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v2.matrix_type ();
 
-  v2.matrix_type (typ);
-  return ret;
+      ComplexMatrix ret = xdiv (v1.matrix_value (), 
+				v2.sparse_complex_matrix_value (), typ);
+
+      v2.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOPX (pow, matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
diff --git a/src/OPERATORS/op-m-sm.cc b/src/OPERATORS/op-m-sm.cc
--- a/src/OPERATORS/op-m-sm.cc
+++ b/src/OPERATORS/op-m-sm.cc
@@ -43,22 +43,35 @@ Boston, MA 02110-1301, USA.
 DEFBINOP_OP (add, matrix, sparse_matrix, +)
 DEFBINOP_OP (sub, matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, matrix, sparse_matrix, *)
 
 DEFBINOP (div, matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
-  MatrixType typ = v2.matrix_type ();
+
+  if (v2.rows() == 1 && v2.columns() == 1)
+    {
+      double d = v2.scalar_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  Matrix ret = xdiv (v1.matrix_value (), v2.sparse_matrix_value (), typ);
+      return octave_value (v1.array_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v2.matrix_type ();
 
-  v2.matrix_type (typ);
-  return ret;
+      Matrix ret = xdiv (v1.matrix_value (), v2.sparse_matrix_value (), typ);
+
+      v2.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOPX (pow, matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
diff --git a/src/OPERATORS/op-s-scm.cc b/src/OPERATORS/op-s-scm.cc
--- a/src/OPERATORS/op-s-scm.cc
+++ b/src/OPERATORS/op-s-scm.cc
@@ -45,23 +45,34 @@ Boston, MA 02110-1301, USA.
 DEFBINOP_OP (add, scalar, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, scalar, sparse_complex_matrix, -)
 DEFBINOP_OP (mul, scalar, sparse_complex_matrix, *)
 
 DEFBINOP (div, scalar, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_complex_matrix&);
 
-  MatrixType typ = v2.matrix_type ();
-  Matrix m1 = Matrix (1, 1, v1.scalar_value ());
-  SparseComplexMatrix m2 = v2.sparse_complex_matrix_value ();
-  ComplexMatrix ret = xdiv (m1, m2, typ);
-  v2.matrix_type (typ);
+  if (v2.rows() == 1 && v2.columns() == 1)
+    {
+      Complex d = v2.complex_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  return ret;
+      return octave_value (v1.scalar_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v2.matrix_type ();
+      Matrix m1 = Matrix (1, 1, v1.scalar_value ());
+      SparseComplexMatrix m2 = v2.sparse_complex_matrix_value ();
+      ComplexMatrix ret = xdiv (m1, m2, typ);
+      v2.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOP (pow, scalar, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, 
 		   const octave_sparse_complex_matrix&);
   return xpow (v1.scalar_value (), v2.complex_matrix_value ());
 }
diff --git a/src/OPERATORS/op-s-sm.cc b/src/OPERATORS/op-s-sm.cc
--- a/src/OPERATORS/op-s-sm.cc
+++ b/src/OPERATORS/op-s-sm.cc
@@ -41,23 +41,34 @@ Boston, MA 02110-1301, USA.
 DEFBINOP_OP (add, scalar, sparse_matrix, +)
 DEFBINOP_OP (sub, scalar, sparse_matrix, -)
 DEFBINOP_OP (mul, scalar, sparse_matrix, *)
 
 DEFBINOP (div, scalar, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_matrix&);
 
-  MatrixType typ = v2.matrix_type ();
-  Matrix m1 = Matrix (1, 1, v1.double_value ());
-  SparseMatrix m2 = v2.sparse_matrix_value ();
-  Matrix ret = xdiv (m1, m2, typ);
-  v2.matrix_type (typ);
+  if (v2.rows() == 1 && v2.columns() == 1)
+    {
+      double d = v2.scalar_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  return ret;
+      return octave_value (v1.scalar_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v2.matrix_type ();
+      Matrix m1 = Matrix (1, 1, v1.double_value ());
+      SparseMatrix m2 = v2.sparse_matrix_value ();
+      Matrix ret = xdiv (m1, m2, typ);
+      v2.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOP (pow, scalar, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_scalar&, const octave_sparse_matrix&);
   return xpow (v1.scalar_value (), v2.matrix_value ());
 }
 
diff --git a/src/OPERATORS/op-scm-cm.cc b/src/OPERATORS/op-scm-cm.cc
--- a/src/OPERATORS/op-scm-cm.cc
+++ b/src/OPERATORS/op-scm-cm.cc
@@ -62,23 +62,36 @@ DEFBINOPX (pow, sparse_complex_matrix, c
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex_matrix&);
-  MatrixType typ = v1.matrix_type ();
+
+  if (v1.rows() == 1 && v1.columns() == 1)
+    {
+      Complex d = v1.complex_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
-				v2.complex_matrix_value (), typ);
+      return octave_value (v2.complex_array_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v1.matrix_type ();
 
-  v1.matrix_type (typ);
-  return ret;
+      ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
+		      v2.complex_matrix_value (), typ);
+
+      v1.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, complex_matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_complex_matrix, complex_matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_complex_matrix, complex_matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, complex_matrix, mx_el_ne)
diff --git a/src/OPERATORS/op-scm-cs.cc b/src/OPERATORS/op-scm-cs.cc
--- a/src/OPERATORS/op-scm-cs.cc
+++ b/src/OPERATORS/op-scm-cs.cc
@@ -69,23 +69,34 @@ DEFBINOP (pow, sparse_complex_matrix, co
 		   const octave_complex&);
   return xpow (v1.complex_matrix_value (), v2.scalar_value ());
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_complex&);
 
-  MatrixType typ = v1.matrix_type ();
-  SparseComplexMatrix m1 = v1.sparse_complex_matrix_value ();
-  ComplexMatrix m2 = ComplexMatrix (1, 1, v2.complex_value ());
-  ComplexMatrix ret = xleftdiv (m1, m2, typ);
-  v1.matrix_type (typ);
+  if (v1.rows() == 1 && v1.columns() == 1)
+    {
+      Complex d = v1.complex_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  return ret;
+      return octave_value (v2.complex_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v1.matrix_type ();
+      SparseComplexMatrix m1 = v1.sparse_complex_matrix_value ();
+      ComplexMatrix m2 = ComplexMatrix (1, 1, v2.complex_value ());
+      ComplexMatrix ret = xleftdiv (m1, m2, typ);
+      v1.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, complex, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, complex, mx_el_le)
 DEFBINOP_FN (eq, sparse_complex_matrix, complex, mx_el_eq)
 DEFBINOP_FN (ge, sparse_complex_matrix, complex, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, complex, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, complex, mx_el_ne)
diff --git a/src/OPERATORS/op-scm-m.cc b/src/OPERATORS/op-scm-m.cc
--- a/src/OPERATORS/op-scm-m.cc
+++ b/src/OPERATORS/op-scm-m.cc
@@ -64,23 +64,35 @@ DEFBINOPX (pow, sparse_complex_matrix, m
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_matrix&);
   
-  MatrixType typ = v1.matrix_type ();
+  if (v1.rows() == 1 && v1.columns() == 1)
+    {
+      Complex d = v1.complex_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
-				v2.matrix_value (), typ);
+      return octave_value (v2.array_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v1.matrix_type ();
 
-  v1.matrix_type (typ);
-  return ret;
+      ComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
+				    v2.matrix_value (), typ);
+
+      v1.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_complex_matrix, matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_complex_matrix, matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, matrix, mx_el_ne)
diff --git a/src/OPERATORS/op-scm-s.cc b/src/OPERATORS/op-scm-s.cc
--- a/src/OPERATORS/op-scm-s.cc
+++ b/src/OPERATORS/op-scm-s.cc
@@ -77,23 +77,34 @@ DEFBINOP (pow, sparse_complex_matrix, sc
   else
     return xpow (v1.complex_matrix_value (), tmp);
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_scalar&);
 
-  MatrixType typ = v1.matrix_type ();
-  SparseComplexMatrix m1 = v1.sparse_complex_matrix_value ();
-  Matrix m2 = Matrix (1, 1, v2.scalar_value ());
-  ComplexMatrix ret = xleftdiv (m1, m2, typ);
-  v1.matrix_type (typ);
+  if (v1.rows() == 1 && v1.columns() == 1)
+    {
+      Complex d = v1.complex_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  return ret;
+      return octave_value (v2.scalar_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v1.matrix_type ();
+      SparseComplexMatrix m1 = v1.sparse_complex_matrix_value ();
+      Matrix m2 = Matrix (1, 1, v2.scalar_value ());
+      ComplexMatrix ret = xleftdiv (m1, m2, typ);
+      v1.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, scalar, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, scalar, mx_el_le)
 DEFBINOP_FN (eq, sparse_complex_matrix, scalar, mx_el_eq)
 DEFBINOP_FN (ge, sparse_complex_matrix, scalar, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, scalar, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, scalar, mx_el_ne)
diff --git a/src/OPERATORS/op-scm-scm.cc b/src/OPERATORS/op-scm-scm.cc
--- a/src/OPERATORS/op-scm-scm.cc
+++ b/src/OPERATORS/op-scm-scm.cc
@@ -92,41 +92,68 @@ DEFBINOP_OP (add, sparse_complex_matrix,
 DEFBINOP_OP (sub, sparse_complex_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
 		   const octave_sparse_complex_matrix&);
-  MatrixType typ = v2.matrix_type ();
-  SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (), 
-				  v2.sparse_complex_matrix_value (), typ);
+ 
+  if (v2.rows() == 1 && v2.columns() == 1)
+    {
+      Complex d = v2.complex_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
+
+      return octave_value (v1.sparse_complex_matrix_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v2.matrix_type ();
+      SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (), 
+				      v2.sparse_complex_matrix_value (), typ);
   
-  v2.matrix_type (typ);
-  return ret;
+      v2.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, 
 		   const octave_sparse_complex_matrix&);
-  MatrixType typ = v1.matrix_type ();
+
+  if (v1.rows() == 1 && v1.columns() == 1)
+    {
+      Complex d = v1.complex_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  SparseComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
-				      v2.sparse_complex_matrix_value (), typ);
+      return octave_value (v2.sparse_complex_matrix_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v1.matrix_type ();
 
-  v1.matrix_type (typ);
-  return ret;
+      SparseComplexMatrix ret = 
+	xleftdiv (v1.sparse_complex_matrix_value (), 
+		  v2.sparse_complex_matrix_value (), typ);
+
+      v1.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, sparse_complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, sparse_complex_matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_complex_matrix, sparse_complex_matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_complex_matrix, sparse_complex_matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, sparse_complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, sparse_complex_matrix, mx_el_ne)
diff --git a/src/OPERATORS/op-scm-sm.cc b/src/OPERATORS/op-scm-sm.cc
--- a/src/OPERATORS/op-scm-sm.cc
+++ b/src/OPERATORS/op-scm-sm.cc
@@ -42,40 +42,66 @@ Boston, MA 02110-1301, USA.
 DEFBINOP_OP (add, sparse_complex_matrix, sparse_matrix, +)
 DEFBINOP_OP (sub, sparse_complex_matrix, sparse_matrix, -)
 
 DEFBINOP_OP (mul, sparse_complex_matrix, sparse_matrix, *)
 
 DEFBINOP (div, sparse_complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_sparse_matrix&);
-  MatrixType typ = v2.matrix_type ();
-  SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (), 
-				  v2.sparse_matrix_value (), typ);
+
+  if (v2.rows() == 1 && v2.columns() == 1)
+    {
+      double d = v2.scalar_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
+
+      return octave_value (v1.sparse_complex_matrix_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v2.matrix_type ();
+      SparseComplexMatrix ret = xdiv (v1.sparse_complex_matrix_value (), 
+				      v2.sparse_matrix_value (), typ);
   
-  v2.matrix_type (typ);
-  return ret;
+      v2.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_sparse_matrix&);
-  MatrixType typ = v1.matrix_type ();
+
+  if (v1.rows() == 1 && v1.columns() == 1)
+    {
+      Complex d = v1.complex_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  SparseComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
-				      v2.sparse_matrix_value (), typ);
+      return octave_value (v2.sparse_matrix_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v1.matrix_type ();
 
-  v1.matrix_type (typ);
-  return ret;
+      SparseComplexMatrix ret = xleftdiv (v1.sparse_complex_matrix_value (), 
+					  v2.sparse_matrix_value (), typ);
+
+      v1.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOP_FN (lt, sparse_complex_matrix, sparse_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_complex_matrix, sparse_matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_complex_matrix, sparse_matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_complex_matrix, sparse_matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_complex_matrix, sparse_matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_complex_matrix, sparse_matrix, mx_el_ne)
diff --git a/src/OPERATORS/op-sm-cm.cc b/src/OPERATORS/op-sm-cm.cc
--- a/src/OPERATORS/op-sm-cm.cc
+++ b/src/OPERATORS/op-sm-cm.cc
@@ -62,23 +62,36 @@ DEFBINOPX (pow, sparse_matrix, complex_m
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_matrix&);
-  MatrixType typ = v1.matrix_type ();
+
+  if (v1.rows() == 1 && v1.columns() == 1)
+    {
+      double d = v1.scalar_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  ComplexMatrix ret = xleftdiv (v1.sparse_matrix_value (), 
-				v2.complex_matrix_value (), typ);
+      return octave_value (v2.complex_array_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v1.matrix_type ();
 
-  v1.matrix_type (typ);
-  return ret;
+      ComplexMatrix ret = xleftdiv (v1.sparse_matrix_value (), 
+				    v2.complex_matrix_value (), typ);
+
+      v1.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOP_FN (lt, sparse_matrix, complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, complex_matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_matrix, complex_matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_matrix, complex_matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_matrix, complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_matrix, complex_matrix, mx_el_ne)
diff --git a/src/OPERATORS/op-sm-cs.cc b/src/OPERATORS/op-sm-cs.cc
--- a/src/OPERATORS/op-sm-cs.cc
+++ b/src/OPERATORS/op-sm-cs.cc
@@ -69,23 +69,34 @@ DEFBINOP (pow, sparse_matrix, complex)
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
   return xpow (v1.matrix_value (), v2.complex_value ());
 }
 
 DEFBINOP (ldiv, sparse_matrix, complex)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex&);
 
-  MatrixType typ = v1.matrix_type ();
-  SparseMatrix m1 = v1.sparse_matrix_value ();
-  ComplexMatrix m2 = ComplexMatrix (1, 1, v2.complex_value ());
-  ComplexMatrix ret = xleftdiv (m1, m2, typ);
-  v1.matrix_type (typ);
+  if (v1.rows() == 1 && v1.columns() == 1)
+    {
+      double d = v1.scalar_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  return ret;
+      return octave_value (v2.complex_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v1.matrix_type ();
+      SparseMatrix m1 = v1.sparse_matrix_value ();
+      ComplexMatrix m2 = ComplexMatrix (1, 1, v2.complex_value ());
+      ComplexMatrix ret = xleftdiv (m1, m2, typ);
+      v1.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOP_FN (lt, sparse_matrix, complex, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, complex, mx_el_le)
 DEFBINOP_FN (eq, sparse_matrix, complex, mx_el_eq)
 DEFBINOP_FN (ge, sparse_matrix, complex, mx_el_ge)
 DEFBINOP_FN (gt, sparse_matrix, complex, mx_el_gt)
 DEFBINOP_FN (ne, sparse_matrix, complex, mx_el_ne)
diff --git a/src/OPERATORS/op-sm-m.cc b/src/OPERATORS/op-sm-m.cc
--- a/src/OPERATORS/op-sm-m.cc
+++ b/src/OPERATORS/op-sm-m.cc
@@ -60,23 +60,36 @@ DEFBINOPX (pow, sparse_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
-  MatrixType typ = v1.matrix_type ();
+
+  if (v1.rows() == 1 && v1.columns() == 1)
+    {
+      double d = v1.scalar_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  Matrix ret = xleftdiv (v1.sparse_matrix_value (), 
-			       v2.matrix_value (), typ);
+      return octave_value (v2.array_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v1.matrix_type ();
 
-  v1.matrix_type (typ);
-  return ret;
+      Matrix ret = xleftdiv (v1.sparse_matrix_value (), 
+			     v2.matrix_value (), typ);
+
+      v1.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOP_FN (lt, sparse_matrix, matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_matrix, matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_matrix, matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_matrix, matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_matrix, matrix, mx_el_ne)
diff --git a/src/OPERATORS/op-sm-s.cc b/src/OPERATORS/op-sm-s.cc
--- a/src/OPERATORS/op-sm-s.cc
+++ b/src/OPERATORS/op-sm-s.cc
@@ -71,23 +71,34 @@ DEFBINOP (pow, sparse_matrix, scalar)
   else
     return xpow (v1.matrix_value (), tmp);
 }
 
 DEFBINOP (ldiv, sparse_matrix, scalar)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_scalar&);
 
-  MatrixType typ = v1.matrix_type ();
-  SparseMatrix m1 = v1.sparse_matrix_value ();
-  Matrix m2 = Matrix (1, 1, v2.scalar_value ());
-  Matrix ret = xleftdiv (m1, m2, typ);
-  v1.matrix_type (typ);
+  if (v1.rows() == 1 && v1.columns() == 1)
+    {
+      double d = v1.scalar_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  return ret;
+      return octave_value (v2.scalar_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v1.matrix_type ();
+      SparseMatrix m1 = v1.sparse_matrix_value ();
+      Matrix m2 = Matrix (1, 1, v2.scalar_value ());
+      Matrix ret = xleftdiv (m1, m2, typ);
+      v1.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOP_FN (lt, sparse_matrix, scalar, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, scalar, mx_el_le)
 DEFBINOP_FN (eq, sparse_matrix, scalar, mx_el_eq)
 DEFBINOP_FN (ge, sparse_matrix, scalar, mx_el_ge)
 DEFBINOP_FN (gt, sparse_matrix, scalar, mx_el_gt)
 DEFBINOP_FN (ne, sparse_matrix, scalar, mx_el_ne)
diff --git a/src/OPERATORS/op-sm-scm.cc b/src/OPERATORS/op-sm-scm.cc
--- a/src/OPERATORS/op-sm-scm.cc
+++ b/src/OPERATORS/op-sm-scm.cc
@@ -42,40 +42,67 @@ Boston, MA 02110-1301, USA.
 DEFBINOP_OP (add, sparse_matrix, sparse_complex_matrix, +)
 DEFBINOP_OP (sub, sparse_matrix, sparse_complex_matrix, -)
 
 DEFBINOP_OP (mul, sparse_matrix, sparse_complex_matrix, *)
 
 DEFBINOP (div, sparse_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_complex_matrix&);
-  MatrixType typ = v2.matrix_type ();
-  SparseComplexMatrix ret = xdiv (v1.sparse_matrix_value (), 
+
+  if (v2.rows() == 1 && v2.columns() == 1)
+    {
+      Complex d = v2.complex_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
+
+      return octave_value (v1.sparse_matrix_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v2.matrix_type ();
+      SparseComplexMatrix ret = xdiv (v1.sparse_matrix_value (), 
 				  v2.sparse_complex_matrix_value (), typ);
   
-  v2.matrix_type (typ);
-  return ret;
+      v2.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOPX (pow, sparse_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_complex_matrix&);
-  MatrixType typ = v1.matrix_type ();
+
+  if (v1.rows() == 1 && v1.columns() == 1)
+    {
+      double d = v1.scalar_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  SparseComplexMatrix ret = xleftdiv (v1.sparse_matrix_value (), 
-				      v2.sparse_complex_matrix_value (), typ);
+      return octave_value (v2.sparse_complex_matrix_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v1.matrix_type ();
 
-  v1.matrix_type (typ);
-  return ret;
+      SparseComplexMatrix ret = 
+	xleftdiv (v1.sparse_matrix_value (), 
+		  v2.sparse_complex_matrix_value (), typ);
+
+      v1.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOP_FN (lt, sparse_matrix, sparse_complex_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, sparse_complex_matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_matrix, sparse_complex_matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_matrix, sparse_complex_matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_matrix, sparse_complex_matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_matrix, sparse_complex_matrix, mx_el_ne)
diff --git a/src/OPERATORS/op-sm-sm.cc b/src/OPERATORS/op-sm-sm.cc
--- a/src/OPERATORS/op-sm-sm.cc
+++ b/src/OPERATORS/op-sm-sm.cc
@@ -52,40 +52,66 @@ DEFUNOP (transpose, sparse_matrix)
 
 DEFBINOP_OP (add, sparse_matrix, sparse_matrix, +)
 DEFBINOP_OP (sub, sparse_matrix, sparse_matrix, -)
 DEFBINOP_OP (mul, sparse_matrix, sparse_matrix, *)
 
 DEFBINOP (div, sparse_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
-  MatrixType typ = v2.matrix_type ();
-  SparseMatrix ret = xdiv (v1.sparse_matrix_value (), 
-			   v2.sparse_matrix_value (), typ);
+
+  if (v2.rows() == 1 && v2.columns() == 1)
+    {
+      double d = v2.scalar_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
+
+      return octave_value (v1.sparse_matrix_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v2.matrix_type ();
+      SparseMatrix ret = xdiv (v1.sparse_matrix_value (), 
+			       v2.sparse_matrix_value (), typ);
   
-  v2.matrix_type (typ);
-  return ret;
+      v2.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOPX (pow, sparse_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
   return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
-  MatrixType typ = v1.matrix_type ();
+
+  if (v1.rows() == 1 && v1.columns() == 1)
+    {
+      double d = v1.double_value ();
+
+      if (d == 0.0)
+	gripe_divide_by_zero ();
 
-  SparseMatrix ret = xleftdiv (v1.sparse_matrix_value (), 
-			       v2.sparse_matrix_value (), typ);
+      return octave_value (v2.sparse_matrix_value () / d);
+    }
+  else
+    {
+      MatrixType typ = v1.matrix_type ();
 
-  v1.matrix_type (typ);
-  return ret;
+      SparseMatrix ret = xleftdiv (v1.sparse_matrix_value (), 
+				   v2.sparse_matrix_value (), typ);
+
+      v1.matrix_type (typ);
+      return ret;
+    }
 }
 
 DEFBINOP_FN (lt, sparse_matrix, sparse_matrix, mx_el_lt)
 DEFBINOP_FN (le, sparse_matrix, sparse_matrix, mx_el_le)
 DEFBINOP_FN (eq, sparse_matrix, sparse_matrix, mx_el_eq)
 DEFBINOP_FN (ge, sparse_matrix, sparse_matrix, mx_el_ge)
 DEFBINOP_FN (gt, sparse_matrix, sparse_matrix, mx_el_gt)
 DEFBINOP_FN (ne, sparse_matrix, sparse_matrix, mx_el_ne)
diff --git a/src/dynamic-ld.cc b/src/dynamic-ld.cc
--- a/src/dynamic-ld.cc
+++ b/src/dynamic-ld.cc
@@ -408,19 +408,27 @@ octave_dynamic_loader::do_load_mex (cons
 	  if (mex_file)
 	    {
 	      octave_mex_file_list::append (mex_file);
 
 	      function = mex_file.search ("mexFunction");
 
 	      if (! function)
 		{
-		  function = mex_file.search (STRINGIFY (F77_FUNC (mexfunction, MEXFUNCTION)));
-		  if (function)
-		    have_fmex = true;
+		  // FIXME -- can we determine this C mangling scheme
+		  // automatically at run time or configure time?
+
+		  function = mex_file.search ("_mexFunction");
+
+		  if (! function)
+		    {
+		      function = mex_file.search (STRINGIFY (F77_FUNC (mexfunction, MEXFUNCTION)));
+		      if (function)
+			have_fmex = true;
+		    }
 		}
 	    }
 	  else
 	    ::error ("%s is not a valid shared library",
 		     mex_file_name.c_str ());
 	}
     }
 
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -95,18 +95,19 @@ octave_sparse_bool_matrix::valid_as_scal
 
 double
 octave_sparse_bool_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (numel () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "bool sparse matrix", "real scalar");
+      if (numel () > 1)
+	gripe_implicit_conversion ("Octave:array-as-scalar",
+				   "bool sparse matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("bool sparse matrix", "real scalar");
 
   return retval;
 }
@@ -115,18 +116,19 @@ Complex
 octave_sparse_bool_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "bool sparse matrix", "complex scalar");
+      if (numel () > 1)
+	gripe_implicit_conversion ("Octave:array-as-scalar",
+				   "bool sparse matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("bool sparse matrix", "complex scalar");
 
   return retval;
 }
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -121,18 +121,19 @@ octave_sparse_complex_matrix::double_val
 
   if (! force_conversion)
     gripe_implicit_conversion ("Octave:imag-to-real",
 			       "complex sparse matrix", "real scalar");
 
   // FIXME -- maybe this should be a function, valid_as_scalar()
   if (numel () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "complex sparse matrix", "real scalar");
+      if (numel () > 1)
+	gripe_implicit_conversion ("Octave:array-as-scalar",
+				   "complex sparse matrix", "real scalar");
 
       retval = std::real (matrix (0, 0));
     }
   else
     gripe_invalid_conversion ("complex sparse matrix", "real scalar");
 
   return retval;
 }
@@ -156,18 +157,19 @@ octave_sparse_complex_matrix::complex_va
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   // FIXME -- maybe this should be a function, valid_as_scalar()
   if (numel () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "complex sparse matrix", "real scalar");
+      if (numel () > 1)
+	gripe_implicit_conversion ("Octave:array-as-scalar",
+				   "complex sparse matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("complex sparse matrix", "real scalar");
 
   return retval;
 }
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -93,18 +93,19 @@ octave_sparse_matrix::valid_as_scalar_in
 
 double
 octave_sparse_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (numel () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "real sparse matrix", "real scalar");
+      if (numel () > 1)
+	gripe_implicit_conversion ("Octave:array-as-scalar",
+				   "real sparse matrix", "real scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real sparse matrix", "real scalar");
 
   return retval;
 }
@@ -114,18 +115,19 @@ octave_sparse_matrix::complex_value (boo
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   // FIXME -- maybe this should be a function, valid_as_scalar()
   if (rows () > 0 && columns () > 0)
     {
-      gripe_implicit_conversion ("Octave:array-as-scalar",
-				 "real sparse matrix", "complex scalar");
+      if (numel () > 1)
+	gripe_implicit_conversion ("Octave:array-as-scalar",
+				   "real sparse matrix", "complex scalar");
 
       retval = matrix (0, 0);
     }
   else
     gripe_invalid_conversion ("real sparse matrix", "complex scalar");
 
   return retval;
 }
