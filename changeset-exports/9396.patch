# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1245931058 -7200
#      Thu Jun 25 13:57:38 2009 +0200
# Node ID 17af7cce7d1bb1dcd5a7eafe0ec0e9e5251184f0
# Parent  1de00ca9c9f242af6be6611fc7c1ee046627715f
yet more unwind_protect improvements

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,34 @@
+2009-06-25  Jaroslav Hajek  <highegg@gmail.com>
+
+	* unwind-prot.h (unwind_protect::fcn_elem): New class.
+	(unwind_protect::fcn_arg_elem): New class.
+	(unwind_protect::method_elem): New class.
+	(unwind_protect::add_action_var): Rename to add_fcn.
+	(unwind_protect::add_fcn): New static method.
+	(unwind_protect::add_method): New static method.
+
+	* symtab.h: Split clear_variables into two overloads.
+	* toplev.h (octave_call_stack::restore_frame): New static method.
+
+	* graphics.cc: Update unwind_protect usage.
+	* input.cc: Ditto.
+	* lex.h: Ditto.
+	* ls-mat5.cc: Ditto.
+	* mex.cc: Ditto.
+	* ov-builtin.cc: Ditto.
+	* ov-fcn-handle.cc: Ditto.
+	* ov-mex-fcn.cc: Ditto.
+	* ov-usr-fcn.cc: Ditto.
+	* parse.y: Ditto.
+	* pt-eval.cc: Ditto.
+	* toplev.cc: Ditto.
+	* variables.cc: Ditto.
+
 2009-06-25  Jaroslav Hajek  <highegg@gmail.com>
 
 	* input.cc: Use unwind_protect::add_action_var where appropriate.
 	* ls-mat5.cc: Ditto.
 	* ov-fcn-handle.cc: Ditto.
 	* parse.y: Ditto.
 	* toplev.cc: Ditto.
 	* variables.cc: Ditto.
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -4185,17 +4185,17 @@ gh_manager::do_execute_callback (const g
 
   args(0) = h.as_octave_value ();
   if (data.is_defined ())
     args(1) = data;
   else
     args(1) = Matrix ();
 
   unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
-  unwind_protect::add (gh_manager::restore_gcbo);
+  unwind_protect::add_fcn (gh_manager::restore_gcbo);
 
   if (true)
     {
       gh_manager::autolock guard;
   
       callback_objects.push_front (get_object (h));
       xset_gcbo (h);
     }
@@ -4984,22 +4984,16 @@ DEFUN (available_backends, , ,
 Return a cell array of registered graphics backends.\n\
 @end deftypefn")
 {
   gh_manager::autolock guard;
 
   return octave_value (graphics_backend::available_backends_list ());
 }
 
-static void
-clear_drawnow_request (void *)
-{
-  Vdrawnow_requested = false;
-}
-
 DEFUN (drawnow, args, ,
    "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} drawnow ()\n\
 @deftypefnx {Built-in Function} {} drawnow (\"expose\")\n\
 @deftypefnx {Built-in Function} {} drawnow (@var{term}, @var{file}, @var{mono}, @var{debug_file})\n\
 Update figure windows and their children.  The event queue is flushed and\n\
 any callbacks generated are executed.  With the optional argument\n\
 @code{\"expose\"}, only graphic objects are updated and no other events or\n\
@@ -5011,17 +5005,17 @@ undocumented.\n\
   static int drawnow_executing = 0;
   static bool __go_close_all_registered__ = false;
 
   octave_value retval;
 
   gh_manager::lock ();
 
   unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
-  unwind_protect::add (clear_drawnow_request);
+  unwind_protect::protect_var (Vdrawnow_requested, false);
 
   unwind_protect::protect_var (drawnow_executing);
 
   if (++drawnow_executing <= 1)
     {
       if (! __go_close_all_registered__)
 	{
 	  octave_add_atexit_function ("__go_close_all__");
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -664,17 +664,17 @@ get_debug_input (const std::string& prom
       reset_parser ();
 
       // Save current value of global_command.
       unwind_protect::protect_var (global_command);
 
       // Do this with an unwind-protect cleanup function so that the
       // forced variables will be unmarked in the event of an interrupt.
       symbol_table::scope_id scope = symbol_table::top_scope ();
-      unwind_protect::add_action_var (symbol_table::unmark_forced_variables, scope);
+      unwind_protect::add_fcn (symbol_table::unmark_forced_variables, scope);
 
       // This is the same as yyparse in parse.y.
       int retval = octave_parse ();
 
       if (retval == 0 && global_command)
 	{
 	  global_command->accept (*current_evaluator);
 
@@ -869,54 +869,39 @@ RET and can edit it until it has been co
       retval = octave_yes_or_no (prompt);
     }
   else
     print_usage ();
 
   return retval;
 }
 
-static void
-restore_command_history (void *)
-{
-  command_history::ignore_entries (! Vsaving_history);
-}
-
-static size_t saved_frame = 0;
-
-static void
-restore_frame (void *)
-{
-  octave_call_stack::goto_frame (saved_frame);
-}
-
 octave_value
 do_keyboard (const octave_value_list& args)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   assert (nargin == 0 || nargin == 1);
 
   unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
   // FIXME -- we shouldn't need both the
   // command_history object and the
   // Vsaving_history variable...
   command_history::ignore_entries (false);
 
-  unwind_protect::add (restore_command_history, 0);
+  unwind_protect::add_fcn (command_history::ignore_entries, ! Vsaving_history);
 
   unwind_protect::protect_var (Vsaving_history);
   unwind_protect::protect_var (Vdebugging);
 
-  saved_frame = octave_call_stack::current_frame ();
-  unwind_protect::add (restore_frame);
-  unwind_protect::protect_var (saved_frame);
+  unwind_protect::add_fcn (octave_call_stack::restore_frame, 
+                           octave_call_stack::current_frame ());
 
   Vsaving_history = true;
   Vdebugging = true;
 
   std::string prompt = "debug> ";
   if (nargin > 0)
     prompt = args(0).string_value ();
 
@@ -946,19 +931,18 @@ If @code{keyboard} is invoked without ar
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin == 0 || nargin == 1)
     {
-      saved_frame = octave_call_stack::current_frame ();
-      unwind_protect::add (restore_frame);
-      unwind_protect::protect_var (saved_frame);
+      unwind_protect::add_fcn (octave_call_stack::restore_frame, 
+                               octave_call_stack::current_frame ());
 
       // Skip the frame assigned to the keyboard function.
       octave_call_stack::goto_frame (1);
 
       do_keyboard (args);
 
       unwind_protect::run ();
     }
diff --git a/src/lex.h b/src/lex.h
--- a/src/lex.h
+++ b/src/lex.h
@@ -38,22 +38,16 @@ extern OCTINTERP_API YY_BUFFER_STATE cre
 extern OCTINTERP_API YY_BUFFER_STATE current_buffer (void);
 
 // Connect to new buffer buffer.
 extern OCTINTERP_API void switch_to_buffer (YY_BUFFER_STATE buf);
 
 // Delete a buffer.
 extern OCTINTERP_API void delete_buffer (YY_BUFFER_STATE buf);
 
-// Restore a buffer (for unwind-prot).
-extern OCTINTERP_API void restore_input_buffer (void *buf);
-
-// Delete a buffer (for unwind-prot).
-extern OCTINTERP_API void delete_input_buffer (void *buf);
-
 // Is the given string a keyword?
 extern bool is_keyword (const std::string& s);
 
 extern void prep_lexer_for_script (void);
 
 // For communication between the lexer and parser.
 
 class
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -870,22 +870,22 @@ read_mat5_binary_element (std::istream& 
 	    m2 = tc2.map_value();
 
 	    unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
 	    // Set up temporary scope to use for evaluating the text
 	    // that defines the anonymous function.
 
 	    symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
-	    unwind_protect::add_action_var (symbol_table::erase_scope, local_scope);
+	    unwind_protect::add_fcn (symbol_table::erase_scope, local_scope);
 
 	    symbol_table::set_scope (local_scope);
 
 	    octave_call_stack::push (local_scope, 0);
-	    unwind_protect::add (octave_call_stack::unwind_pop, 0);
+	    unwind_protect::add_fcn (octave_call_stack::pop);
 
 	    if (m2.nfields() > 0)
 	      {
 		octave_value tmp;
       
 		for (Octave_map::iterator p0 = m2.begin() ; 
 		     p0 != m2.end(); p0++)
 		  {
diff --git a/src/mex.cc b/src/mex.cc
--- a/src/mex.cc
+++ b/src/mex.cc
@@ -3278,17 +3278,17 @@ mexGetVariable (const char *space, const
       if (caller || base)
 	{
 	  if (caller)
 	    octave_call_stack::goto_caller_frame ();
 	  else
 	    octave_call_stack::goto_base_frame ();
 
 	  if (! error_state)
-	    unwind_protect::add (octave_call_stack::unwind_pop);
+	    unwind_protect::add_fcn (octave_call_stack::pop);
 
 	  val = symbol_table::varval (name);
 	}
       else
 	mexErrMsgTxt ("mexGetVariable: symbol table does not exist");
 
       unwind_protect::run_frame (uwp_frame);
     }
@@ -3338,17 +3338,17 @@ mexPutVariable (const char *space, const
       if (caller || base)
 	{
 	  if (caller)
 	    octave_call_stack::goto_caller_frame ();
 	  else
 	    octave_call_stack::goto_base_frame ();
 
 	  if (! error_state)
-	    unwind_protect::add (octave_call_stack::unwind_pop);
+	    unwind_protect::add_fcn (octave_call_stack::pop);
 
 	  symbol_table::varref (name) = mxArray::as_octave_value (ptr);
 	}
       else
 	mexErrMsgTxt ("mexPutVariable: symbol table does not exist");
 
       unwind_protect::run_frame (uwp_frame);
     }
diff --git a/src/ov-builtin.cc b/src/ov-builtin.cc
--- a/src/ov-builtin.cc
+++ b/src/ov-builtin.cc
@@ -95,17 +95,17 @@ octave_builtin::do_multi_index_op (int n
   if (args.has_magic_colon ())
     ::error ("invalid use of colon in function argument list");
   else
     {
       unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
       octave_call_stack::push (this);
 
-      unwind_protect::add (octave_call_stack::unwind_pop, 0);
+      unwind_protect::add_fcn (octave_call_stack::pop);
 
       try
 	{
 	  retval = (*f) (args, nargout);
           // Do not allow null values to be returned from functions.
           // FIXME -- perhaps true builtins should be allowed?
           retval.make_storable_values ();
 	}
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -314,22 +314,22 @@ octave_fcn_handle::load_ascii (std::istr
       pos = is.tellg ();
 
       unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
-      unwind_protect::add_action_var (symbol_table::erase_scope, local_scope);
+      unwind_protect::add_fcn (symbol_table::erase_scope, local_scope);
 
       symbol_table::set_scope (local_scope);
 
       octave_call_stack::push (local_scope, 0);
-      unwind_protect::add (octave_call_stack::unwind_pop, 0);
+      unwind_protect::add_fcn (octave_call_stack::pop);
 
       octave_idx_type len = 0;
 
       if (extract_keyword (is, "length", len, true) && len >= 0)
 	{
 	  if (len > 0)
 	    {
 	      for (octave_idx_type i = 0; i < len; i++)
@@ -495,22 +495,22 @@ octave_fcn_handle::load_binary (std::ist
       is.get (ctmp2, tmp+1, 0);
 
       unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
-      unwind_protect::add_action_var (symbol_table::erase_scope, local_scope);	      
+      unwind_protect::add_fcn (symbol_table::erase_scope, local_scope);	      
 
       symbol_table::set_scope (local_scope);
 
       octave_call_stack::push (local_scope, 0);
-      unwind_protect::add (octave_call_stack::unwind_pop, 0);
+      unwind_protect::add_fcn (octave_call_stack::pop);
 
       if (len > 0)
 	{
 	  for (octave_idx_type i = 0; i < len; i++)
 	    {
 	      octave_value t2;
 	      bool dummy;
 	      std::string doc;
@@ -940,22 +940,22 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
       H5Eset_auto (err_func, err_func_data);
 
       unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       symbol_table::scope_id local_scope = symbol_table::alloc_scope ();
-      unwind_protect::add_action_var (symbol_table::erase_scope, local_scope);
+      unwind_protect::add_fcn (symbol_table::erase_scope, local_scope);
 
       symbol_table::set_scope (local_scope);
 
       octave_call_stack::push (local_scope, 0);
-      unwind_protect::add (octave_call_stack::unwind_pop, 0);
+      unwind_protect::add_fcn (octave_call_stack::pop);
 
       if (len > 0 && success)
 	{
 #ifdef HAVE_H5GGET_NUM_OBJS
 	  hsize_t num_obj = 0;
 	  data_hid = H5Gopen (group_hid, "symbol table"); 
 	  H5Gget_num_objs (data_hid, &num_obj);
 	  H5Gclose (data_hid);
diff --git a/src/ov-mex-fcn.cc b/src/ov-mex-fcn.cc
--- a/src/ov-mex-fcn.cc
+++ b/src/ov-mex-fcn.cc
@@ -138,17 +138,17 @@ octave_mex_function::do_multi_index_op (
   if (args.has_magic_colon ())
     ::error ("invalid use of colon in function argument list");
   else
     {
       unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
       octave_call_stack::push (this);
 
-      unwind_protect::add (octave_call_stack::unwind_pop, 0);
+      unwind_protect::add_fcn (octave_call_stack::pop);
 
       try
 	{
 	  retval = call_mex (have_fmex, mex_fcn_ptr, args, nargout, this);
 	}
       catch (octave_execution_exception)
 	{
 	  gripe_library_execution_error ();
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -121,17 +121,17 @@ octave_user_script::do_multi_index_op (i
 	    {
 	      unwind_protect::protect_var (call_depth);
 	      call_depth++;
 
 	      if (call_depth < Vmax_recursion_depth)
 		{
 		  octave_call_stack::push (this);
 
-		  unwind_protect::add (octave_call_stack::unwind_pop, 0);
+                  unwind_protect::add_fcn (octave_call_stack::pop);
 
 		  unwind_protect::protect_var (tree_evaluator::in_fcn_or_script_body);
 		  tree_evaluator::in_fcn_or_script_body = true;
 
 		  cmd_list->accept (*current_evaluator);
 
 		  if (tree_return_command::returning)
 		    tree_return_command::returning = 0;
@@ -270,34 +270,16 @@ octave_user_function::octave_all_va_args
   octave_idx_type n = num_args_passed - num_named_args;
 
   if (n > 0)
     retval = args_passed.slice (num_named_args, n);
 
   return retval;
 }
 
-static void
-clear_param_list (void *lst)
-{
-  tree_parameter_list *tmp = static_cast<tree_parameter_list *> (lst);
-
-  if (tmp)
-    tmp->undefine ();
-}
-
-static void
-restore_args_passed (void *fcn)
-{
-  octave_user_function *tmp = static_cast<octave_user_function *> (fcn);
-
-  if (tmp)
-    tmp->restore_args_passed ();
-}
-
 octave_value_list
 octave_user_function::subsref (const std::string& type,
 			       const std::list<octave_value_list>& idx,
 			       int nargout)
 {
   octave_value_list retval;
 
   switch (type[0])
@@ -357,30 +339,30 @@ octave_user_function::do_multi_index_op 
       unwind_protect::run_frame (uwp_frame);
       return retval;
     }
 
   // Save old and set current symbol table context, for
   // eval_undefined_error().
 
   octave_call_stack::push (this, local_scope, call_depth);
-  unwind_protect::add (octave_call_stack::unwind_pop, 0);
+  unwind_protect::add_fcn (octave_call_stack::pop);
 
   if (call_depth > 0)
     {
       symbol_table::push_context ();
 
-      unwind_protect::add (symbol_table::pop_context);
+      unwind_protect::add_fcn (symbol_table::pop_context);
     }
 
   // Save and restore args passed for recursive calls.
 
   save_args_passed (args);
 
-  unwind_protect::add (::restore_args_passed, this);
+  unwind_protect::add_method (this, &octave_user_function::restore_args_passed);
 
   string_vector arg_names = args.name_tags ();
 
   unwind_protect::protect_var (num_args_passed);
   num_args_passed = nargin;
 
   if (param_list && ! param_list->varargs_only ())
     {
@@ -388,37 +370,41 @@ octave_user_function::do_multi_index_op 
       if (error_state)
 	goto abort;
     }
 
   // Force parameter list to be undefined when this function exits.
   // Doing so decrements the reference counts on the values of local
   // variables that are also named function parameters.
 
-  unwind_protect::add (clear_param_list, param_list);
+  if (param_list)
+    unwind_protect::add_method (param_list, 
+                                &tree_parameter_list::undefine);
 
   // Force return list to be undefined when this function exits.
   // Doing so decrements the reference counts on the values of local
   // variables that are also named values returned by this function.
 
-  unwind_protect::add (clear_param_list, ret_list);
+  if (ret_list)
+    unwind_protect::add_method (ret_list, 
+                                &tree_parameter_list::undefine);
 
   if (call_depth == 0)
     {
       // Force symbols to be undefined again when this function
       // exits.
       //
       // This cleanup function is added to the unwind_protect stack
       // after the calls to clear the parameter lists so that local
       // variables will be cleared before the parameter lists are
       // cleared.  That way, any function parameters that have been
       // declared global will be unmarked as global before they are
       // undefined by the clear_param_list cleanup function.
 
-      unwind_protect::add (symbol_table::clear_variables);
+      unwind_protect::add_fcn (symbol_table::clear_variables);
     }
 
   // The following code is in a separate scope to avoid warnings from
   // G++ about `goto abort' crossing the initialization of some
   // variables.
 
   {
     bind_automatic_vars (arg_names, nargin, nargout, octave_all_va_args ());
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -1542,23 +1542,23 @@ maybe_warn_variable_switch_label (tree_e
     }
 }
 
 static tree_expression *
 fold (tree_binary_expression *e)
 {
   tree_expression *retval = e;
 
-  unwind_protect::begin_frame ("fold_binary_expression");
-
-  unwind_protect_int (error_state);
-  unwind_protect_int (warning_state);
-
-  unwind_protect_bool (discard_error_messages);
-  unwind_protect_bool (discard_warning_messages);
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+
+  unwind_protect::protect_var (error_state);
+  unwind_protect::protect_var (warning_state);
+
+  unwind_protect::protect_var (discard_error_messages);
+  unwind_protect::protect_var (discard_warning_messages);
 
   discard_error_messages = true;
   discard_warning_messages = true;
 
   tree_expression *op1 = e->lhs ();
   tree_expression *op2 = e->rhs ();
 
   octave_value::binary_op op_type = e->op_type ();
@@ -1585,33 +1585,33 @@ fold (tree_binary_expression *e)
 	  tc_retval->stash_original_text (buf.str ());
 
 	  delete e;
 
 	  retval = tc_retval;
 	}
     }
 
-  unwind_protect::run_frame ("fold_binary_expression");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 static tree_expression *
 fold (tree_unary_expression *e)
 {
   tree_expression *retval = e;
 
-  unwind_protect::begin_frame ("fold_unary_expression");
-
-  unwind_protect_int (error_state);
-  unwind_protect_int (warning_state);
-
-  unwind_protect_bool (discard_error_messages);
-  unwind_protect_bool (discard_warning_messages);
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+
+  unwind_protect::protect_var (error_state);
+  unwind_protect::protect_var (warning_state);
+
+  unwind_protect::protect_var (discard_error_messages);
+  unwind_protect::protect_var (discard_warning_messages);
 
   discard_error_messages = true;
   discard_warning_messages = true;
 
   tree_expression *op = e->operand ();
 
   if (op->is_constant ())
     {
@@ -1631,35 +1631,35 @@ fold (tree_unary_expression *e)
 	  tc_retval->stash_original_text (buf.str ());
 
 	  delete e;
 
 	  retval = tc_retval;
 	}
     }
 
-  unwind_protect::run_frame ("fold_unary_expression");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 // Finish building a range.
 
 static tree_expression *
 finish_colon_expression (tree_colon_expression *e)
 {
   tree_expression *retval = e;
 
-  unwind_protect::begin_frame ("finish_colon_expression");
-
-  unwind_protect_int (error_state);
-  unwind_protect_int (warning_state);
-
-  unwind_protect_bool (discard_error_messages);
-  unwind_protect_bool (discard_warning_messages);
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+
+  unwind_protect::protect_var (error_state);
+  unwind_protect::protect_var (warning_state);
+
+  unwind_protect::protect_var (discard_error_messages);
+  unwind_protect::protect_var (discard_warning_messages);
 
   discard_error_messages = true;
   discard_warning_messages = true;
 
   tree_expression *base = e->base ();
   tree_expression *limit = e->limit ();
   tree_expression *incr = e->increment ();
 
@@ -1697,17 +1697,17 @@ finish_colon_expression (tree_colon_expr
 	  delete e;
 
 	  // FIXME -- need to attempt constant folding here
 	  // too (we need a generic way to do that).
 	  retval = base;
 	}
     }
 
-  unwind_protect::run_frame ("finish_colon_expression");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 // Make a constant.
 
 static tree_constant *
 make_constant (int op, token *tok_val)
@@ -2854,23 +2854,23 @@ make_decl_command (int tok, token *tok_v
 
 // Finish building a matrix list.
 
 static tree_expression *
 finish_matrix (tree_matrix *m)
 {
   tree_expression *retval = m;
 
-  unwind_protect::begin_frame ("finish_matrix");
-
-  unwind_protect_int (error_state);
-  unwind_protect_int (warning_state);
-
-  unwind_protect_bool (discard_error_messages);
-  unwind_protect_bool (discard_warning_messages);
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+
+  unwind_protect::protect_var (error_state);
+  unwind_protect::protect_var (warning_state);
+
+  unwind_protect::protect_var (discard_error_messages);
+  unwind_protect::protect_var (discard_warning_messages);
 
   discard_error_messages = true;
   discard_warning_messages = true;
 
   if (m->all_elements_are_constant ())
     {
       octave_value tmp = m->rvalue1 ();
 
@@ -2888,17 +2888,17 @@ finish_matrix (tree_matrix *m)
 	  tc_retval->stash_original_text (buf.str ());
 
 	  delete m;
 
 	  retval = tc_retval;
 	}
     }
 
-  unwind_protect::run_frame ("finish_matrix");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 // Finish building a cell list.
 
 static tree_expression *
 finish_cell (tree_cell *c)
@@ -3134,72 +3134,61 @@ looking_at_function_keyword (FILE *ffile
       && ! (isalnum (buf[8]) || buf[8] == '_'))
     status = true;
 
   fseek (ffile, pos, SEEK_SET);
 
   return status;
 }
 
-static void
-restore_command_history (void *)
-{
-  command_history::ignore_entries (! Vsaving_history);
-}
-
-static void
-restore_input_stream (void *f)
-{
-  command_editor::set_input_stream (static_cast<FILE *> (f));
-}
-
 static octave_function *
 parse_fcn_file (const std::string& ff, const std::string& dispatch_type,
 		bool force_script = false, bool require_file = true,
 		const std::string& warn_for = std::string ())
 {
-  unwind_protect::begin_frame ("parse_fcn_file");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
   octave_function *fcn_ptr = 0;
 
   // Open function file and parse.
 
   bool old_reading_fcn_file_state = reading_fcn_file;
 
   FILE *in_stream = command_editor::get_input_stream ();
 
-  unwind_protect::add (restore_input_stream, in_stream);
-
-  unwind_protect_ptr (ff_instream);
-
-  unwind_protect_int (input_line_number);
-  unwind_protect_int (current_input_column);
-  unwind_protect_int (end_tokens_expected);
-  unwind_protect_bool (reading_fcn_file);
-  unwind_protect_bool (line_editing);
-  unwind_protect_str (parent_function_name);
-  unwind_protect_str (current_class_name);
+  unwind_protect::add_fcn (command_editor::set_input_stream,
+                           in_stream);
+
+  unwind_protect::protect_var (ff_instream);
+
+  unwind_protect::protect_var (input_line_number);
+  unwind_protect::protect_var (current_input_column);
+  unwind_protect::protect_var (end_tokens_expected);
+  unwind_protect::protect_var (reading_fcn_file);
+  unwind_protect::protect_var (line_editing);
+  unwind_protect::protect_var (parent_function_name);
+  unwind_protect::protect_var (current_class_name);
 
   input_line_number = 1;
   current_input_column = 1;
   end_tokens_expected = 0;
   reading_fcn_file = true;
   line_editing = false;
   parent_function_name = "";
   current_class_name = dispatch_type;
 
   // The next four lines must be in this order.
-  unwind_protect::add (restore_command_history, 0);
+  unwind_protect::add_fcn (command_history::ignore_entries, ! Vsaving_history);
 
   // FIXME -- we shouldn't need both the
   // command_history object and the
   // Vsaving_history variable...
   command_history::ignore_entries ();
 
-  unwind_protect_bool (Vsaving_history);
+  unwind_protect::protect_var (Vsaving_history);
 
   Vsaving_history = false;
 
   FILE *ffile = get_input_from_file (ff, 0);
 
   unwind_protect::add (safe_fclose, ffile);
 
   if (ffile)
@@ -3209,65 +3198,65 @@ parse_fcn_file (const std::string& ff, c
       std::string help_txt = gobble_leading_white_space (ffile, eof);
 
       if (! eof)
 	{
 	  std::string file_type;
 
 	  bool parsing_script = false;
 
-	  unwind_protect_bool (get_input_from_eval_string);
-	  unwind_protect_bool (parser_end_of_input);
+	  unwind_protect::protect_var (get_input_from_eval_string);
+	  unwind_protect::protect_var (parser_end_of_input);
 
 	  get_input_from_eval_string = false;
 	  parser_end_of_input = false;
 
 	  if (! force_script && looking_at_function_keyword (ffile))
 	    {
 	      file_type = "function";
 
-	      unwind_protect_int (Vecho_executing_commands);
-	      unwind_protect_bool (reading_fcn_file);
+	      unwind_protect::protect_var (Vecho_executing_commands);
+	      unwind_protect::protect_var (reading_fcn_file);
 
 	      Vecho_executing_commands = ECHO_OFF;
 	      reading_fcn_file = true;
 	    }
 	  else
 	    {
 	      file_type = "script";
 
 	      // The value of `reading_fcn_file' will be restored to the
 	      // proper value when we unwind from this frame.
 	      reading_fcn_file = old_reading_fcn_file_state;
 
-	      unwind_protect_bool (reading_script_file);
+	      unwind_protect::protect_var (reading_script_file);
 
 	      reading_script_file = true;
 
 	      parsing_script = true;
 	    }
 
 	  YY_BUFFER_STATE old_buf = current_buffer ();
 	  YY_BUFFER_STATE new_buf = create_buffer (ffile);
 
-	  unwind_protect::add (restore_input_buffer, old_buf);
-	  unwind_protect::add (delete_input_buffer, new_buf);
+	  unwind_protect::add_fcn (switch_to_buffer, old_buf);
+	  unwind_protect::add_fcn (delete_buffer, new_buf);
 
 	  switch_to_buffer (new_buf);
 
-	  unwind_protect_ptr (curr_fcn_ptr);
+	  unwind_protect::protect_var (curr_fcn_ptr);
 	  curr_fcn_ptr = 0;
 
 	  reset_parser ();
 
 	  // Do this with an unwind-protect cleanup function so that
 	  // the forced variables will be unmarked in the event of an
 	  // interrupt. 
 	  symbol_table::scope_id scope = symbol_table::top_scope ();
-	  unwind_protect::add_action_var (symbol_table::unmark_forced_variables, scope);
+	  unwind_protect::add_fcn (symbol_table::unmark_forced_variables, scope);
 
 	  if (! help_txt.empty ())
 	    help_buf.push (help_txt);
 
 	  if (parsing_script)
 	    prep_lexer_for_script ();
 
 	  lexer_flags.parsing_class_method = ! dispatch_type.empty ();
@@ -3281,17 +3270,17 @@ parse_fcn_file (const std::string& ff, c
 		   file_type.c_str(), ff.c_str ());
 	}
     }
   else if (require_file)
     error ("no such file, `%s'", ff.c_str ());
   else if (! warn_for.empty ())
     error ("%s: unable to open file `%s'", warn_for.c_str (), ff.c_str ());    
 
-  unwind_protect::run_frame ("parse_fcn_file");
+  unwind_protect::run_frame (uwp_frame);
 
   return fcn_ptr;
 }
 
 std::string
 get_help_from_file (const std::string& nm, bool& symbol_found,
 		    std::string& file)
 {
@@ -3381,41 +3370,41 @@ reverse_lookup_autoload (const std::stri
 
 octave_function *
 load_fcn_from_file (const std::string& file_name, const std::string& dir_name,
 		    const std::string& dispatch_type,
 		    const std::string& fcn_name, bool autoload)
 {
   octave_function *retval = 0;
 
-  unwind_protect::begin_frame ("load_fcn_from_file");
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
   std::string nm = file_name;
 
   size_t nm_len = nm.length ();
 
   std::string file;
 
-  unwind_protect_bool (fcn_file_from_relative_lookup);
+  unwind_protect::protect_var (fcn_file_from_relative_lookup);
 
   fcn_file_from_relative_lookup = false;
 
   file = nm;
 
   if ((nm_len > 4 && nm.substr (nm_len-4) == ".oct")
       || (nm_len > 4 && nm.substr (nm_len-4) == ".mex")
       || (nm_len > 2 && nm.substr (nm_len-2) == ".m"))
     {
       nm = octave_env::base_pathname (file);
       nm = nm.substr (0, nm.find_last_of ('.'));
     }
 
   if (autoload)
     {
-      unwind_protect_bool (autoloading);
+      unwind_protect::protect_var (autoloading);
       autoloading = true;
     }
 
   fcn_file_from_relative_lookup = ! octave_env::absolute_pathname (file);
 
   file = octave_env::make_absolute (file, octave_env::getcwd ());
 
   int len = file.length ();
@@ -3428,18 +3417,18 @@ load_fcn_from_file (const std::string& f
       retval = octave_dynamic_loader::load_oct (nm, file, fcn_file_from_relative_lookup);
     }
   else if (len > 4 && file.substr (len-4, len-1) == ".mex")
     retval = octave_dynamic_loader::load_mex (nm, file, fcn_file_from_relative_lookup);
   else if (len > 2)
     {
       // These are needed by yyparse.
 
-      unwind_protect_str (curr_fcn_file_name);
-      unwind_protect_str (curr_fcn_file_full_name);
+      unwind_protect::protect_var (curr_fcn_file_name);
+      unwind_protect::protect_var (curr_fcn_file_full_name);
 
       curr_fcn_file_name = nm;
       curr_fcn_file_full_name = file;
 
       retval = parse_fcn_file (file, dispatch_type, autoloading);
     }
 
   if (retval)
@@ -3449,17 +3438,17 @@ load_fcn_from_file (const std::string& f
       if (retval->is_user_function ())
 	{
 	  symbol_table::scope_id id = retval->scope ();
 
 	  symbol_table::stash_dir_name_for_subfunctions (id, dir_name);
 	}
     }
 
-  unwind_protect::run_frame ("load_fcn_from_file");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 DEFUN (autoload, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} autoload (@var{function}, @var{file})\n\
 Define @var{function} to autoload from @var{file}.\n\
@@ -3565,35 +3554,35 @@ With no arguments, return a structure co
 }
 
 void
 source_file (const std::string& file_name, const std::string& context,
 	     bool verbose, bool require_file, const std::string& warn_for)
 {
   std::string file_full_name = file_ops::tilde_expand (file_name);
 
-  unwind_protect::begin_frame ("source_file");
-
-  unwind_protect_str (curr_fcn_file_name);
-  unwind_protect_str (curr_fcn_file_full_name);
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+
+  unwind_protect::protect_var (curr_fcn_file_name);
+  unwind_protect::protect_var (curr_fcn_file_full_name);
 
   curr_fcn_file_name = file_name;
   curr_fcn_file_full_name = file_full_name;
 
   if (! context.empty ())
     {
       if (context == "caller")
 	octave_call_stack::goto_caller_frame ();
       else if (context == "base")
 	octave_call_stack::goto_base_frame ();
       else
 	error ("source: context must be \"caller\" or \"base\"");
 
       if (! error_state)
-	unwind_protect::add (octave_call_stack::unwind_pop);
+	unwind_protect::add_fcn (octave_call_stack::pop);
     }      
 
   if (! error_state)
     {
       octave_function *fcn = parse_fcn_file (file_full_name, "", true,
 					     require_file, warn_for);
 
       if (! error_state)
@@ -3617,17 +3606,17 @@ source_file (const std::string& file_nam
 	      delete fcn;
 	    }
 	}
       else
 	error ("source: error sourcing file `%s'",
 	       file_full_name.c_str ());
     }
 
-  unwind_protect::run_frame ("source_file");
+  unwind_protect::run_frame (uwp_frame);
 }
 
 DEFUN (mfilename, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} mfilename ()\n\
 @deftypefnx {Built-in Function} {} mfilename (@code{\"fullpath\"})\n\
 @deftypefnx {Built-in Function} {} mfilename (@code{\"fullpathext\"})\n\
 Return the name of the currently executing file.  At the top-level,\n\
@@ -3873,54 +3862,54 @@ by name, and use @code{feval} to call th
   return retval;
 }
 
 octave_value_list
 eval_string (const std::string& s, bool silent, int& parse_status, int nargout)
 {
   octave_value_list retval;
 
-  unwind_protect::begin_frame ("eval_string");
-
-  unwind_protect_int (input_line_number);
-  unwind_protect_int (current_input_column);
-  unwind_protect_bool (get_input_from_eval_string);
-  unwind_protect_bool (input_from_eval_string_pending);
-  unwind_protect_bool (parser_end_of_input);
-  unwind_protect_bool (line_editing);
-  unwind_protect_str (current_eval_string);
+  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
+
+  unwind_protect::protect_var (input_line_number);
+  unwind_protect::protect_var (current_input_column);
+  unwind_protect::protect_var (get_input_from_eval_string);
+  unwind_protect::protect_var (input_from_eval_string_pending);
+  unwind_protect::protect_var (parser_end_of_input);
+  unwind_protect::protect_var (line_editing);
+  unwind_protect::protect_var (current_eval_string);
 
   input_line_number = 1;
   current_input_column = 1;
   get_input_from_eval_string = true;
   input_from_eval_string_pending = true;
   parser_end_of_input = false;
   line_editing = false;
 
   current_eval_string = s;
 
   YY_BUFFER_STATE old_buf = current_buffer ();
   YY_BUFFER_STATE new_buf = create_buffer (0);
 
-  unwind_protect::add (restore_input_buffer, old_buf);
-  unwind_protect::add (delete_input_buffer, new_buf);
+  unwind_protect::add_fcn (switch_to_buffer, old_buf);
+  unwind_protect::add_fcn (delete_buffer, new_buf);
 
   switch_to_buffer (new_buf);
 
   do
     {
       reset_parser ();
 
-      unwind_protect_ptr (global_command);
+      unwind_protect::protect_var (global_command);
 
       // Do this with an unwind-protect cleanup function so that the
       // forced variables will be unmarked in the event of an
       // interrupt.
       symbol_table::scope_id scope = symbol_table::top_scope ();
-      unwind_protect::add (symbol_table::unmark_forced_variables, &scope);
+      unwind_protect::add_fcn (symbol_table::unmark_forced_variables, scope);
 
       parse_status = yyparse ();
 
       tree_statement_list *command_list = global_command;
 
       // Unmark forced variables.
       unwind_protect::run ();
 
@@ -3978,17 +3967,17 @@ eval_string (const std::string& s, bool 
 		break;
 	    }
 	  else if (parser_end_of_input)
 	    break;
         }
     }
   while (parse_status == 0);
 
-  unwind_protect::run_frame ("eval_string");
+  unwind_protect::run_frame (uwp_frame);
 
   return retval;
 }
 
 octave_value
 eval_string (const std::string& s, bool silent, int& parse_status)
 {
   octave_value retval;
@@ -4043,21 +4032,21 @@ eval ('error (\"This is a bad example\")
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 0)
     {
-      unwind_protect::begin_frame ("Feval");
+      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
       if (nargin > 1)
 	{
-	  unwind_protect_int (buffer_error_messages);
+	  unwind_protect::protect_var (buffer_error_messages);
 	  buffer_error_messages++;
 	}
 
       int parse_status = 0;
 
       octave_value_list tmp = eval_string (args(0), nargout > 0,
 					   parse_status, nargout);
 
@@ -4073,17 +4062,17 @@ eval ('error (\"This is a bad example\")
 	  tmp = eval_string (args(1), nargout > 0, parse_status, nargout);
 
 	  if (nargout > 0)
 	    retval = tmp;
 	}
       else if (nargout > 0)
 	retval = tmp;
 
-      unwind_protect::run_frame ("Feval");
+      unwind_protect::run_frame (uwp_frame);
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -4181,43 +4170,43 @@ may be either @code{\"base\"} or @code{\
   int nargin = args.length ();
 
   if (nargin == 3)
     {
       std::string context = args(0).string_value ();
 
       if (! error_state)
         {
-	  unwind_protect::begin_frame ("Fassignin");
+	  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
 	  if (context == "caller")
 	    octave_call_stack::goto_caller_frame ();
 	  else if (context == "base")
 	    octave_call_stack::goto_base_frame ();
 	  else
 	    error ("assignin: context must be \"caller\" or \"base\"");
 
 	  if (! error_state)
 	    {
-	      unwind_protect::add (octave_call_stack::unwind_pop);
+	      unwind_protect::add_fcn (octave_call_stack::pop);
 
 	      std::string nm = args(1).string_value ();
 
 	      if (! error_state)
 		{
 		  if (valid_identifier (nm))
 		    symbol_table::varref (nm) = args(2);
 		  else
 		    error ("assignin: invalid variable name");
 		}
 	      else
 		error ("assignin: expecting variable name as second argument");
 	    }
 
-	  unwind_protect::run_frame ("Fassignin");
+	  unwind_protect::run_frame (uwp_frame);
 	}
       else
         error ("assignin: expecting string as first argument");
     }
   else
     print_usage ();
 
   return retval;
@@ -4236,32 +4225,32 @@ context @var{context}, which may be eith
   int nargin = args.length ();
 
   if (nargin > 1)
     {
       std::string context = args(0).string_value ();
 
       if (! error_state)
         {
-	  unwind_protect::begin_frame ("Fevalin");
+	  unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
 	  if (context == "caller")
 	    octave_call_stack::goto_caller_frame ();
 	  else if (context == "base")
 	    octave_call_stack::goto_base_frame ();
 	  else
 	    error ("evalin: context must be \"caller\" or \"base\"");
 
 	  if (! error_state)
 	    {
-	      unwind_protect::add (octave_call_stack::unwind_pop);
+	      unwind_protect::add_fcn (octave_call_stack::pop);
 
 	      if (nargin > 2)
 	        {
-		  unwind_protect_int (buffer_error_messages);
+		  unwind_protect::protect_var (buffer_error_messages);
 		  buffer_error_messages++;
 		}
 
 	      int parse_status = 0;
 
 	      octave_value_list tmp = eval_string (args(1), nargout > 0,
 						   parse_status, nargout);
 
@@ -4278,17 +4267,17 @@ context @var{context}, which may be eith
 		  buffer_error_messages--;
 
 		  eval_string (args(2), 0, parse_status, nargout);
 
 		  retval = octave_value_list ();
 		}
 	    }
 
-	  unwind_protect::run_frame ("Fevalin");
+	  unwind_protect::run_frame (uwp_frame);
 	}
       else
         error ("evalin: expecting string as first argument");
     }
   else
     print_usage ();
 
   return retval;
diff --git a/src/pt-eval.cc b/src/pt-eval.cc
--- a/src/pt-eval.cc
+++ b/src/pt-eval.cc
@@ -815,17 +815,17 @@ tree_evaluator::visit_switch_command (tr
 	}
     }
   else
     ::error ("missing value in switch command near line %d, column %d",
 	     cmd.line (), cmd.column ());
 }
 
 static void
-do_catch_code (void *ptr)
+do_catch_code (tree_statement_list *list)
 {
   // Is it safe to call OCTAVE_QUIT here?  We are already running
   // something on the unwind_protect stack, but the element for this
   // action would have already been popped from the top of the stack,
   // so we should not be attempting to run it again.
 
   OCTAVE_QUIT;
 
@@ -840,18 +840,16 @@ do_catch_code (void *ptr)
   // probably let the catch code throw the exception because we don't
   // want to skip that and potentially run some other code.  For
   // example, an error may have originally brought us here for some
   // cleanup operation and we shouldn't skip that.
 
   if (octave_interrupt_immediately || octave_interrupt_state < 0)
     return;
 
-  tree_statement_list *list = static_cast<tree_statement_list *> (ptr);
-
   // Set up for letting the user print any messages from errors that
   // occurred in the body of the try_catch statement.
 
   buffer_error_messages--;
 
   if (list)
     list->accept (*current_evaluator);
 }
@@ -866,17 +864,17 @@ tree_evaluator::visit_try_catch_command 
   unwind_protect::protect_var (Vdebug_on_warning);
 
   buffer_error_messages++;
   Vdebug_on_error = false;
   Vdebug_on_warning = false;
 
   tree_statement_list *catch_code = cmd.cleanup ();
 
-  unwind_protect::add (do_catch_code, catch_code);
+  unwind_protect::add_fcn (do_catch_code, catch_code);
 
   tree_statement_list *try_code = cmd.body ();
 
   if (try_code)
     try_code->accept (*this);
 
   if (catch_code && error_state)
     {
@@ -894,20 +892,18 @@ tree_evaluator::visit_try_catch_command 
       unwind_protect::discard ();
 
       // Run the rest of the frame.
       unwind_protect::run_frame (uwp_frame);
     }
 }
 
 static void
-do_unwind_protect_cleanup_code (void *ptr)
+do_unwind_protect_cleanup_code (tree_statement_list *list)
 {
-  tree_statement_list *list = static_cast<tree_statement_list *> (ptr);
-
   unwind_protect::protect_var (octave_interrupt_state);
   octave_interrupt_state = 0;
 
   // We want to run the cleanup code without error_state being set,
   // but we need to restore its value, so that any errors encountered
   // in the first part of the unwind_protect are not completely
   // ignored.
 
@@ -976,17 +972,17 @@ do_unwind_protect_cleanup_code (void *pt
     unwind_protect::run ();
 }
 
 void
 tree_evaluator::visit_unwind_protect_command (tree_unwind_protect_command& cmd)
 {
   tree_statement_list *cleanup_code = cmd.cleanup ();
 
-  unwind_protect::add (do_unwind_protect_cleanup_code, cleanup_code);
+  unwind_protect::add_fcn (do_unwind_protect_cleanup_code, cleanup_code);
 
   tree_statement_list *unwind_protect_code = cmd.body ();
 
   if (unwind_protect_code)
     unwind_protect_code->accept (*this);
 
   unwind_protect::run ();
 }
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -1306,56 +1306,46 @@ public:
 
   static void clear_all (void)
   {
     clear_variables ();
 
     clear_functions ();
   }
 
-  static void clear_variables (scope_id scope = xcurrent_scope)
+  static void clear_variables (scope_id scope)
   {
     symbol_table *inst = get_instance (scope);
 
     if (inst)
       inst->do_clear_variables ();
   }
 
+  // This is split for unwind_protect.
+  static void clear_variables (void)
+  {
+    clear_variables (xcurrent_scope);
+  }
+
   static void clear_objects (scope_id scope = xcurrent_scope)
   {
     symbol_table *inst = get_instance (scope);
 
     if (inst)
       inst->do_clear_objects ();
   }
 
   static void unmark_forced_variables (scope_id scope = xcurrent_scope)
   {
     symbol_table *inst = get_instance (scope);
 
     if (inst)
       inst->do_unmark_forced_variables ();
   }
 
-  // For unwind_protect.
-  static void unmark_forced_variables (void *arg)
-  {
-    // Unmark any symbols that may have been tagged as local variables
-    // while parsing (for example, by force_local_variable in lex.l).
-
-    symbol_table::scope_id *p = static_cast <symbol_table::scope_id *> (arg);
-
-  if (p)
-    unmark_forced_variables (*p);
-}
-
-
-  // For unwind_protect.
-  static void clear_variables (void *) { clear_variables (); }
-
   static void clear_functions (void)
   {
     for (fcn_table_iterator p = fcn_table.begin (); p != fcn_table.end (); p++)
       p->second.clear ();
   }
 
   static void clear_function (const std::string& name)
   {
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -555,17 +555,17 @@ main_loop (void)
 	  reset_error_handler ();
 
 	  reset_parser ();
 
 	  // Do this with an unwind-protect cleanup function so that
 	  // the forced variables will be unmarked in the event of an
 	  // interrupt.
 	  symbol_table::scope_id scope = symbol_table::top_scope ();
-	  unwind_protect::add_action_var (symbol_table::unmark_forced_variables, scope);
+	  unwind_protect::add_fcn (symbol_table::unmark_forced_variables, scope);
 
 	  // This is the same as yyparse in parse.y.
 	  retval = octave_parse ();
 
 	  if (retval == 0)
 	    {
 	      if (global_command)
 		{
diff --git a/src/toplev.h b/src/toplev.h
--- a/src/toplev.h
+++ b/src/toplev.h
@@ -242,16 +242,21 @@ public:
       instance->do_set_statement (s);
   }
 
   static bool goto_frame (size_t n = 0, bool verbose = false)
   {
     return instance_ok () ? instance->do_goto_frame (n, verbose) : false;
   }
 
+  static void restore_frame (size_t n)
+  {
+    goto_frame (n);
+  }
+
   static bool goto_frame_relative (int n, bool verbose = false)
   {
     return instance_ok ()
       ? instance->do_goto_frame_relative (n, verbose) : false;
   }
 
   static void goto_caller_frame (void)
   {
@@ -272,20 +277,16 @@ public:
   }
 
   static void pop (void)
   {
     if (instance_ok ())
       instance->do_pop ();
   }
   
-  // A function for popping the top of the call stack that is suitable
-  // for use as an unwind_protect handler.
-  static void unwind_pop (void *) { pop (); }
-
   static void clear (void)
   {
     if (instance_ok ())
       instance->do_clear ();
   }
 
   static void backtrace_error_message (void)
   {
diff --git a/src/unwind-prot.h b/src/unwind-prot.h
--- a/src/unwind-prot.h
+++ b/src/unwind-prot.h
@@ -40,29 +40,61 @@ public:
   // A generic unwind_protect element. Knows how to run itself and discard itself.
   class elem
   {
   public:
     virtual void run (void) { }
     virtual ~elem (void) { }
   };
 
-  // An element that merely runs a void (*)(void *) function.
+  // An element that merely runs a void (*)(void) function.
   
   class fcn_elem : public elem
   {
   public:
-    fcn_elem (void (*fptr) (void *), void *ptr)
-      : e_fptr (fptr), e_ptr (ptr) { }
+    fcn_elem (void (*fptr) (void))
+      : e_fptr (fptr) { }
 
-    void run (void) { e_fptr (e_ptr); }
+    void run (void) { e_fptr (); }
 
   private:
-    void (*e_fptr) (void *);
-    void *e_ptr;
+    void (*e_fptr) (void);
+  };
+
+  // An element that stores a variable of type T along with a void (*) (T)
+  // function pointer, and calls the function with the parameter.
+
+  template <class T>
+  class fcn_arg_elem : public elem
+  {
+  public:
+    fcn_arg_elem (void (*fcn) (T), T arg)
+      : e_fcn (fcn), e_arg (arg) { }
+
+    void run (void) { e_fcn (e_arg); }
+
+  private:
+    void (*e_fcn) (T);
+    T e_arg;
+  };
+
+  // An element for calling a member function.
+
+  template <class T>
+  class method_elem : public elem
+  {
+  public:
+    method_elem (T *obj, void (T::*method) (void))
+      : e_obj (obj), e_method (method) { }
+
+    void run (void) { (e_obj->*e_method) (); }
+
+  private:
+    T *e_obj;
+    void (T::*e_method) (void);
   };
 
   // An element that stores arbitrary variable, and restores it.
 
   template <class T>
   class restore_var_elem : public elem
   {
   public:
@@ -70,31 +102,29 @@ public:
       : e_ptr (&ref), e_val (val) { }
 
     void run (void) { *e_ptr = e_val; }
 
   private:
     T *e_ptr, e_val;
   };
 
-  // An element that stores a variable of type T along with a void (*) (T)
-  // function pointer, and calls the function with the parameter.
+  // Deletes a class allocated using new.
 
   template <class T>
-  class action_var_elem : public elem
+  class delete_ptr_elem : public elem
   {
   public:
-    action_var_elem (void (*fcn) (T), T val)
-      : e_fcn (fcn), e_val (val) { }
+    delete_ptr_elem (T *ptr)
+      : e_ptr (ptr) { }
 
-    void run (void) { e_fcn (e_val); }
+    void run (void) { delete e_ptr; }
 
   private:
-    void (*e_fcn) (T);
-    T e_val;
+    T *e_ptr;
   };
 
   typedef size_t frame_id_t;
 
   // Generic. Users may subclass elem to provide their own cleanup.
   static void add (elem *el)
     {
       elt_list.push (el);
@@ -156,42 +186,64 @@ public:
 
   static void discard_all (void)
     { 
       discard_frame (0);
       while (! tag_list.empty ())
         tag_list.pop ();
     }
 
+  // For backward compatibility.
   static void add (void (*fcn) (void *), void *ptr = 0)
     {
-      elt_list.push (new fcn_elem (fcn, ptr));
+      elt_list.push (new fcn_arg_elem<void *> (fcn, ptr));
+    }
+
+  // Call to void func (void).
+  static void add_fcn (void (*fcn) (void))
+    {
+      elt_list.push (new fcn_elem (fcn));
+    }
+
+  // Call to void func (T).
+  template <class T>
+  static void add_fcn (void (*action) (T), T val)
+    {
+      elt_list.push (new fcn_arg_elem<T> (action, val));
+    }
+
+  // Call to T::method (void).
+  template <class T>
+  static void add_method (T *obj, void (T::*method) (void))
+    {
+      elt_list.push (new method_elem<T> (obj, method));
+    }
+
+  // Call to delete (T*).
+
+  template <class T>
+  static void add_delete (T *obj)
+    {
+      elt_list.push (new delete_ptr_elem<T> (obj));
     }
 
   // Protect any variable.
   template <class T>
   static void protect_var (T& var)
     {
       elt_list.push (new restore_var_elem<T> (var, var));
     }
 
   // Protect any variable, value given.
   template <class T>
   static void protect_var (T& var, const T& val)
     {
       elt_list.push (new restore_var_elem<T> (var, val));
     }
 
-  // Store a function pointer together with a single argument (passed by value).
-  template <class T>
-  static void add_action_var (void (*action) (T), T val)
-    {
-      elt_list.push (new action_var_elem<T> (action, val));
-    }
-
 private:
 
   static std::stack<elem *> elt_list;
 
   static std::stack<std::pair <std::string, frame_id_t> > tag_list;
 };
 
 // Backward compatibility macros. Avoid them; use protect_var directly.
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -1384,24 +1384,24 @@ do_who (int argc, const string_vector& a
 	    {
 	      std::string nm = argv [i + 1];
 
 	      unwind_protect::frame_id_t uwp_frame = unwind_protect::begin_frame ();
 
 	      // Set up temporary scope.
 
 	      symbol_table::scope_id tmp_scope = symbol_table::alloc_scope ();
-	      unwind_protect::add_action_var (symbol_table::erase_scope, tmp_scope);
+	      unwind_protect::add_fcn (symbol_table::erase_scope, tmp_scope);
 
 	      symbol_table::set_scope (tmp_scope);
 
 	      octave_call_stack::push (tmp_scope, 0);
-	      unwind_protect::add (octave_call_stack::unwind_pop, 0);
+	      unwind_protect::add_fcn (octave_call_stack::pop);
 
-	      unwind_protect::add (symbol_table::clear_variables);
+	      unwind_protect::add_fcn (symbol_table::clear_variables);
 
 	      feval ("load", octave_value (nm), 0);
 
 	      if (! error_state)
 		{
 		  std::string newmsg = std::string ("Variables in the file ") + 
 		    nm + ":\n\n";
 
