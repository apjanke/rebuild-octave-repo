# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1468849137 14400
#      Mon Jul 18 09:38:57 2016 -0400
# Node ID 407c66ae1e2022b39ab9fd1b65e136c015d0273c
# Parent  a51d5c5c71e65cf8b38c17b179c095b90982bc62
reduce warnings from GCC's link-time optimization feature (bug #48531)

* f77-fcn.h (F77_DBLE_CMPLX, F77_CMPLX): Use C types instead of
typedefs for std::complex<T> types.
(F77_CMPLX_ARG, F77_CONST_CMPLX_ARG, F77_DBLE_CMPLX_ARG,
F77_CONST_DBLE_CMPLX_ARG): New macros.

* dot.cc, ordschur.cc, qz.cc, CColVector.cc, CMatrix.cc,
CRowVector.cc, CSparse.cc, dSparse.cc, fCColVector.cc, fCMatrix.cc,
fCRowVector.cc, f77-fcn.h, EIG.cc, aepbalance.cc, chol.cc,
eigs-base.cc, fEIG.cc, gepbalance.cc, hess.cc, lo-specfun.cc, lu.cc,
oct-convn.cc, qr.cc, qrp.cc, schur.cc, svd.cc: Use new macros for
passing complex arguments to Fortran function.  Always pass pointers
to complex arguments.

diff --git a/libinterp/corefcn/dot.cc b/libinterp/corefcn/dot.cc
--- a/libinterp/corefcn/dot.cc
+++ b/libinterp/corefcn/dot.cc
@@ -166,30 +166,30 @@ but avoids forming a temporary array and
       if (argx.is_single_type () || argy.is_single_type ())
         {
           FloatComplexNDArray x = argx.float_complex_array_value ();
           FloatComplexNDArray y = argy.float_complex_array_value ();
           get_red_dims (dimx, dimy, dim, dimz, m, n, k);
           FloatComplexNDArray z (dimz);
 
           F77_XFCN (cdotc3, CDOTC3, (m, n, k,
-                                     x.data (), y.data (),
-                                     z.fortran_vec ()));
+                                     F77_CONST_CMPLX_ARG (x.data ()), F77_CONST_CMPLX_ARG (y.data ()),
+                                     F77_CMPLX_ARG (z.fortran_vec ())));
           retval = z;
         }
       else
         {
           ComplexNDArray x = argx.complex_array_value ();
           ComplexNDArray y = argy.complex_array_value ();
           get_red_dims (dimx, dimy, dim, dimz, m, n, k);
           ComplexNDArray z (dimz);
 
           F77_XFCN (zdotc3, ZDOTC3, (m, n, k,
-                                     x.data (), y.data (),
-                                     z.fortran_vec ()));
+                                     F77_CONST_DBLE_CMPLX_ARG (x.data ()), F77_CONST_DBLE_CMPLX_ARG (y.data ()),
+                                     F77_DBLE_CMPLX_ARG (z.fortran_vec ())));
           retval = z;
         }
     }
   else if (argx.is_float_type () && argy.is_float_type ())
     {
       if (argx.is_single_type () || argy.is_single_type ())
         {
           FloatNDArray x = argx.float_array_value ();
@@ -322,29 +322,29 @@ endfor
     {
       if (argx.is_single_type () || argy.is_single_type ())
         {
           FloatComplexNDArray x = argx.float_complex_array_value ();
           FloatComplexNDArray y = argy.float_complex_array_value ();
           FloatComplexNDArray z (dimz);
 
           F77_XFCN (cmatm3, CMATM3, (m, n, k, np,
-                                     x.data (), y.data (),
-                                     z.fortran_vec ()));
+                                     F77_CONST_CMPLX_ARG (x.data ()), F77_CONST_CMPLX_ARG (y.data ()),
+                                     F77_CMPLX_ARG (z.fortran_vec ())));
           retval = z;
         }
       else
         {
           ComplexNDArray x = argx.complex_array_value ();
           ComplexNDArray y = argy.complex_array_value ();
           ComplexNDArray z (dimz);
 
           F77_XFCN (zmatm3, ZMATM3, (m, n, k, np,
-                                     x.data (), y.data (),
-                                     z.fortran_vec ()));
+                                     F77_CONST_DBLE_CMPLX_ARG (x.data ()), F77_CONST_DBLE_CMPLX_ARG (y.data ()),
+                                     F77_DBLE_CMPLX_ARG (z.fortran_vec ())));
           retval = z;
         }
     }
   else
     {
       if (argx.is_single_type () || argy.is_single_type ())
         {
           FloatNDArray x = argx.float_array_value ();
diff --git a/libinterp/corefcn/ordschur.cc b/libinterp/corefcn/ordschur.cc
--- a/libinterp/corefcn/ordschur.cc
+++ b/libinterp/corefcn/ordschur.cc
@@ -147,18 +147,18 @@ is in the upper left corner, by doing:
   if (double_type)
     {
       if (complex_type)
         {
           PREPARE_ARGS (Complex, complex_matrix, double)
 
           F77_XFCN (ztrsen, ztrsen,
                     (F77_CONST_CHAR_ARG ("N"), F77_CONST_CHAR_ARG ("V"),
-                     sel.data (), n, S.fortran_vec (), n, U.fortran_vec (), n,
-                     w.fortran_vec (), m, cond1, cond2, work.fortran_vec (), n,
+                     sel.data (), n, F77_DBLE_CMPLX_ARG (S.fortran_vec ()), n, F77_DBLE_CMPLX_ARG (U.fortran_vec ()), n,
+                     F77_DBLE_CMPLX_ARG (w.fortran_vec ()), m, cond1, cond2, F77_DBLE_CMPLX_ARG (work.fortran_vec ()), n,
                      info));
 
           PREPARE_OUTPUT()
         }
       else
         {
           PREPARE_ARGS (, matrix, double)
           Matrix wi (dim_vector (n, 1));
@@ -176,18 +176,18 @@ is in the upper left corner, by doing:
   else
     {
       if (complex_type)
         {
           PREPARE_ARGS (FloatComplex, float_complex_matrix, float)
 
           F77_XFCN (ctrsen, ctrsen,
                     (F77_CONST_CHAR_ARG ("N"), F77_CONST_CHAR_ARG ("V"),
-                     sel.data (), n, S.fortran_vec (), n, U.fortran_vec (), n,
-                     w.fortran_vec (), m, cond1, cond2, work.fortran_vec (), n,
+                     sel.data (), n, F77_CMPLX_ARG (S.fortran_vec ()), n, F77_CMPLX_ARG (U.fortran_vec ()), n,
+                     F77_CMPLX_ARG (w.fortran_vec ()), m, cond1, cond2, F77_CMPLX_ARG (work.fortran_vec ()), n,
                      info));
 
           PREPARE_OUTPUT ()
         }
       else
         {
           PREPARE_ARGS (Float, float_matrix, float)
           FloatMatrix wi (dim_vector (n, 1));
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -541,17 +541,17 @@ compatibility with @sc{matlab}.
       if (compq == 'V')
         CQ = ComplexMatrix (QQ);
 
       if (compz == 'V')
         CZ = ComplexMatrix (ZZ);
 
       F77_XFCN (zggbal, ZGGBAL,
                 (F77_CONST_CHAR_ARG2 (&bal_job, 1),
-                 nn, caa.fortran_vec (), nn, cbb.fortran_vec (),
+                 nn, F77_DBLE_CMPLX_ARG (caa.fortran_vec ()), nn, F77_DBLE_CMPLX_ARG (cbb.fortran_vec ()),
                  nn, ilo, ihi, lscale.fortran_vec (),
                  rscale.fortran_vec (), work.fortran_vec (), info
                  F77_CHAR_ARG_LEN (1)));
     }
   else
     {
 #if defined (DEBUG)
       if (compq == 'V')
@@ -618,59 +618,60 @@ compatibility with @sc{matlab}.
       cbb = cbqr.R ();
       // (Q*)caa for following work.
       caa = (cbqr.Q ().hermitian ()) * caa;
       CQ = CQ * cbqr.Q ();
 
       F77_XFCN (zgghrd, ZGGHRD,
                 (F77_CONST_CHAR_ARG2 (&compq, 1),
                  F77_CONST_CHAR_ARG2 (&compz, 1),
-                 nn, ilo, ihi, caa.fortran_vec (),
-                 nn, cbb.fortran_vec (), nn, CQ.fortran_vec (), nn,
-                 CZ.fortran_vec (), nn, info
+                 nn, ilo, ihi, F77_DBLE_CMPLX_ARG (caa.fortran_vec ()),
+                 nn, F77_DBLE_CMPLX_ARG (cbb.fortran_vec ()), nn, F77_DBLE_CMPLX_ARG (CQ.fortran_vec ()), nn,
+                 F77_DBLE_CMPLX_ARG (CZ.fortran_vec ()), nn, info
                  F77_CHAR_ARG_LEN (1)
                  F77_CHAR_ARG_LEN (1)));
 
       ComplexRowVector cwork (1 * nn);
 
       F77_XFCN (zhgeqz, ZHGEQZ,
                 (F77_CONST_CHAR_ARG2 (&qz_job, 1),
                  F77_CONST_CHAR_ARG2 (&compq, 1),
                  F77_CONST_CHAR_ARG2 (&compz, 1),
                  nn, ilo, ihi,
-                 caa.fortran_vec (), nn,
-                 cbb.fortran_vec (),nn,
-                 xalpha.fortran_vec (), xbeta.fortran_vec (),
-                 CQ.fortran_vec (), nn,
-                 CZ.fortran_vec (), nn,
-                 cwork.fortran_vec (), nn, rwork.fortran_vec (), info
+                 F77_DBLE_CMPLX_ARG (caa.fortran_vec ()), nn,
+                 F77_DBLE_CMPLX_ARG (cbb.fortran_vec ()), nn,
+                 F77_DBLE_CMPLX_ARG (xalpha.fortran_vec ()),
+                 F77_DBLE_CMPLX_ARG (xbeta.fortran_vec ()),
+                 F77_DBLE_CMPLX_ARG (CQ.fortran_vec ()), nn,
+                 F77_DBLE_CMPLX_ARG (CZ.fortran_vec ()), nn,
+                 F77_DBLE_CMPLX_ARG (cwork.fortran_vec ()), nn, rwork.fortran_vec (), info
                  F77_CHAR_ARG_LEN (1)
                  F77_CHAR_ARG_LEN (1)
                  F77_CHAR_ARG_LEN (1)));
 
       if (compq == 'V')
         {
           // Left eigenvector.
           F77_XFCN (zggbak, ZGGBAK,
                     (F77_CONST_CHAR_ARG2 (&bal_job, 1),
                      F77_CONST_CHAR_ARG2 ("L", 1),
                      nn, ilo, ihi, lscale.data (), rscale.data (),
-                     nn, CQ.fortran_vec (), nn, info
+                     nn, F77_DBLE_CMPLX_ARG (CQ.fortran_vec ()), nn, info
                      F77_CHAR_ARG_LEN (1)
                      F77_CHAR_ARG_LEN (1)));
         }
 
       // Right eigenvector.
       if (compz == 'V')
         {
           F77_XFCN (zggbak, ZGGBAK,
                     (F77_CONST_CHAR_ARG2 (&bal_job, 1),
                      F77_CONST_CHAR_ARG2 ("R", 1),
                      nn, ilo, ihi, lscale.data (), rscale.data (),
-                     nn, CZ.fortran_vec (), nn, info
+                     nn, F77_DBLE_CMPLX_ARG (CZ.fortran_vec ()), nn, info
                      F77_CHAR_ARG_LEN (1)
                      F77_CHAR_ARG_LEN (1)));
         }
 
     }
   else
     {
 #if defined (DEBUG)
@@ -1047,19 +1048,19 @@ compatibility with @sc{matlab}.
           CVR = CZ;
           ComplexRowVector cwork2 (2 * nn);
           RowVector rwork2 (8 * nn);
           octave_idx_type m;
 
           F77_XFCN (ztgevc, ZTGEVC,
                     (F77_CONST_CHAR_ARG2 (&side, 1),
                      F77_CONST_CHAR_ARG2 (&howmny, 1),
-                     select, nn, caa.fortran_vec (), nn, cbb.fortran_vec (),
-                     nn, CVL.fortran_vec (), nn, CVR.fortran_vec (), nn, nn,
-                     m, cwork2.fortran_vec (), rwork2.fortran_vec (), info
+                     select, nn, F77_DBLE_CMPLX_ARG (caa.fortran_vec ()), nn, F77_DBLE_CMPLX_ARG (cbb.fortran_vec ()),
+                     nn, F77_DBLE_CMPLX_ARG (CVL.fortran_vec ()), nn, F77_DBLE_CMPLX_ARG (CVR.fortran_vec ()), nn, nn,
+                     m, F77_DBLE_CMPLX_ARG (cwork2.fortran_vec ()), rwork2.fortran_vec (), info
                      F77_CHAR_ARG_LEN (1)
                      F77_CHAR_ARG_LEN (1)));
         }
       else
         {
 #if defined (DEBUG)
           std::cout << "qz: computing generalized eigenvectors" << std::endl;
 #endif
diff --git a/liboctave/array/CColVector.cc b/liboctave/array/CColVector.cc
--- a/liboctave/array/CColVector.cc
+++ b/liboctave/array/CColVector.cc
@@ -329,18 +329,20 @@ operator * (const ComplexMatrix& m, cons
     {
       if (nc == 0)
         retval.fill (0.0);
       else
         {
           Complex *y = retval.fortran_vec ();
 
           F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                                   nr, nc, 1.0, m.data (), nr,
-                                   a.data (), 1, 0.0, y, 1
+                                   nr, nc, 1.0,
+                                   F77_CONST_DBLE_CMPLX_ARG (m.data ()), nr,
+                                   F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1, 0.0,
+                                   F77_DBLE_CMPLX_ARG (y), 1
                                    F77_CHAR_ARG_LEN (1)));
         }
     }
 
   return retval;
 }
 
 // matrix by column vector -> column vector operations
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -114,22 +114,22 @@ extern "C"
                            const F77_INT&, const F77_DBLE_CMPLX*,
                            const F77_INT&, const F77_DBLE_CMPLX&,
                            F77_DBLE_CMPLX*, const F77_INT&
                            F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xzdotu, XZDOTU) (const F77_INT&, const F77_DBLE_CMPLX*,
                              const F77_INT&, const F77_DBLE_CMPLX*,
-                             const F77_INT&, F77_DBLE_CMPLX&);
+                             const F77_INT&, F77_DBLE_CMPLX*);
 
   F77_RET_T
   F77_FUNC (xzdotc, XZDOTC) (const F77_INT&, const F77_DBLE_CMPLX*,
                              const F77_INT&, const F77_DBLE_CMPLX*,
-                             const F77_INT&, F77_DBLE_CMPLX&);
+                             const F77_INT&, F77_DBLE_CMPLX*);
 
   F77_RET_T
   F77_FUNC (zsyrk, ZSYRK) (F77_CONST_CHAR_ARG_DECL,
                            F77_CONST_CHAR_ARG_DECL,
                            const F77_INT&, const F77_INT&,
                            const F77_DBLE_CMPLX&, const F77_DBLE_CMPLX*,
                            const F77_INT&, const F77_DBLE_CMPLX&,
                            F77_DBLE_CMPLX*, const F77_INT&
@@ -236,18 +236,18 @@ extern "C"
                              const F77_INT&, const F77_INT&,
                              const F77_DBLE_CMPLX*, const F77_INT&, F77_DBLE_CMPLX*,
                              const F77_INT&, F77_INT&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (zlartg, ZLARTG) (const F77_DBLE_CMPLX&, const F77_DBLE_CMPLX&, F77_DBLE&,
-                             F77_DBLE_CMPLX&, F77_DBLE_CMPLX&);
+  F77_FUNC (zlartg, ZLARTG) (const F77_DBLE_CMPLX*, const F77_DBLE_CMPLX*, F77_DBLE&,
+                             F77_DBLE_CMPLX*, F77_DBLE_CMPLX*);
 
   F77_RET_T
   F77_FUNC (ztrsyl, ZTRSYL) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const F77_INT&, const F77_INT&,
                              const F77_INT&, const F77_DBLE_CMPLX*,
                              const F77_INT&, const F77_DBLE_CMPLX*,
                              const F77_INT&, const F77_DBLE_CMPLX*,
@@ -969,39 +969,39 @@ ComplexMatrix::tinverse (MatrixType &mat
     (*current_liboctave_error_handler) ("inverse requires square matrix");
 
   int typ = mattype.type ();
   char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
   char udiag = 'N';
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
-  F77_XFCN (ztrtri, ZTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
-                             F77_CONST_CHAR_ARG2 (&udiag, 1),
-                             nr, tmp_data, nr, info
-                             F77_CHAR_ARG_LEN (1)
-                             F77_CHAR_ARG_LEN (1)));
+  F77_XFCN (ztrtri, ZTRTRI,(F77_CONST_CHAR_ARG2 (&uplo, 1),
+                            F77_CONST_CHAR_ARG2 (&udiag, 1),
+                            nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, info
+                            F77_CHAR_ARG_LEN (1)
+                            F77_CHAR_ARG_LEN (1)));
 
   // Throw-away extra info LAPACK gives so as to not change output.
   rcon = 0.0;
   if (info != 0)
     info = -1;
   else if (calc_cond)
     {
       octave_idx_type ztrcon_info = 0;
       char job = '1';
 
       OCTAVE_LOCAL_BUFFER (Complex, cwork, 2*nr);
       OCTAVE_LOCAL_BUFFER (double, rwork, nr);
 
       F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&udiag, 1),
-                                 nr, tmp_data, nr, rcon,
-                                 cwork, rwork, ztrcon_info
+                                 nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, rcon,
+                                 F77_DBLE_CMPLX_ARG (cwork), rwork, ztrcon_info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
       if (ztrcon_info != 0)
         info = -1;
     }
 
@@ -1029,18 +1029,18 @@ ComplexMatrix::finverse (MatrixType &mat
   retval = *this;
   Complex *tmp_data = retval.fortran_vec ();
 
   Array<Complex> z (dim_vector (1, 1));
   octave_idx_type lwork = -1;
 
   // Query the optimum work array size.
 
-  F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt,
-                             z.fortran_vec (), lwork, info));
+  F77_XFCN (zgetri, ZGETRI, (nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
+                             F77_DBLE_CMPLX_ARG (z.fortran_vec ()), lwork, info));
 
   lwork = static_cast<octave_idx_type> (std::real (z(0)));
   lwork = (lwork <  2 *nc ? 2*nc : lwork);
   z.resize (dim_vector (lwork, 1));
   Complex *pz = z.fortran_vec ();
 
   info = 0;
 
@@ -1048,46 +1048,46 @@ ComplexMatrix::finverse (MatrixType &mat
   double anorm =
     retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
   // Work around bug #45577, LAPACK crashes Octave if norm is NaN
   // and bug #46330, segfault with matrices containing Inf & NaN
   if (octave::math::isnan (anorm) || octave::math::isinf (anorm))
     info = -1;
   else
-    F77_XFCN (zgetrf, ZGETRF, (nc, nc, tmp_data, nr, pipvt, info));
+    F77_XFCN (zgetrf, ZGETRF, (nc, nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt, info));
 
   // Throw-away extra info LAPACK gives so as to not change output.
   rcon = 0.0;
   if (info != 0)
     info = -1;
   else if (calc_cond)
     {
       // Now calculate the condition number for non-singular matrix.
       octave_idx_type zgecon_info = 0;
       char job = '1';
       Array<double> rz (dim_vector (2 * nc, 1));
       double *prz = rz.fortran_vec ();
       F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nc, tmp_data, nr, anorm,
-                                 rcon, pz, prz, zgecon_info
+                                 nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, anorm,
+                                 rcon, F77_DBLE_CMPLX_ARG (pz), prz, zgecon_info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (zgecon_info != 0)
         info = -1;
     }
 
   if ((info == -1 && ! force) || octave::math::isinf (anorm))
     retval = *this;  // Restore contents.
   else
     {
       octave_idx_type zgetri_info = 0;
 
-      F77_XFCN (zgetri, ZGETRI, (nc, tmp_data, nr, pipvt,
-                                 pz, lwork, zgetri_info));
+      F77_XFCN (zgetri, ZGETRI, (nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt,
+                                 F77_DBLE_CMPLX_ARG (pz), lwork, zgetri_info));
 
       if (zgetri_info != 0)
         info = -1;
     }
 
   if (info != 0)
     mattype.mark_as_rectangular ();
 
@@ -1564,35 +1564,35 @@ ComplexMatrix::determinant (MatrixType& 
       ComplexMatrix atmp = *this;
       Complex *tmp_data = atmp.fortran_vec ();
 
       double anorm = 0;
       if (calc_cond) anorm = xnorm (*this, 1);
 
       char job = 'L';
       F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
-                                 tmp_data, nr, info
+                                 F77_DBLE_CMPLX_ARG (tmp_data), nr, info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (info != 0)
         {
           rcon = 0.0;
           mattype.mark_as_unsymmetric ();
           typ = MatrixType::Full;
         }
       else
         {
           Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (nc, 1));
           double *prz = rz.fortran_vec ();
 
           F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nr, tmp_data, nr, anorm,
-                                     rcon, pz, prz, info
+                                     nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, anorm,
+                                     rcon, F77_DBLE_CMPLX_ARG (pz), prz, info
                                      F77_CHAR_ARG_LEN (1)));
 
           if (info != 0)
             rcon = 0.0;
 
           for (octave_idx_type i = 0; i < nc; i++)
             retval *= atmp (i,i);
 
@@ -1614,17 +1614,17 @@ ComplexMatrix::determinant (MatrixType& 
 
       // Calculate (always, see bug #45577) the norm of the matrix, for later use.
       double anorm = xnorm (*this, 1);
 
       // Work around bug #45577, LAPACK crashes Octave if norm is NaN
       if (octave::math::isnan (anorm))
         info = -1;
       else
-        F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+        F77_XFCN (zgetrf, ZGETRF, (nr, nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         {
           info = -1;
           retval = ComplexDET ();
         }
@@ -1635,18 +1635,18 @@ ComplexMatrix::determinant (MatrixType& 
               // Now calc the condition number for non-singular matrix.
               char job = '1';
               Array<Complex> z (dim_vector (2 * nc, 1));
               Complex *pz = z.fortran_vec ();
               Array<double> rz (dim_vector (2 * nc, 1));
               double *prz = rz.fortran_vec ();
 
               F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                         nc, tmp_data, nr, anorm,
-                                         rcon, pz, prz, info
+                                         nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, anorm,
+                                         rcon, F77_DBLE_CMPLX_ARG (pz), prz, info
                                          F77_CHAR_ARG_LEN (1)));
             }
 
           if (info != 0)
             {
               info = -1;
               retval = ComplexDET ();
             }
@@ -1702,18 +1702,18 @@ ComplexMatrix::rcond (MatrixType &mattyp
           Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (nc, 1));
           double *prz = rz.fortran_vec ();
 
           F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                      F77_CONST_CHAR_ARG2 (&uplo, 1),
                                      F77_CONST_CHAR_ARG2 (&dia, 1),
-                                     nr, tmp_data, nr, rcon,
-                                     pz, prz, info
+                                     nr, F77_CONST_DBLE_CMPLX_ARG (tmp_data), nr, rcon,
+                                     F77_DBLE_CMPLX_ARG (pz), prz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
           if (info != 0)
             rcon = 0;
         }
       else if  (typ == MatrixType::Permuted_Upper)
@@ -1730,18 +1730,18 @@ ComplexMatrix::rcond (MatrixType &mattyp
           Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (nc, 1));
           double *prz = rz.fortran_vec ();
 
           F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                      F77_CONST_CHAR_ARG2 (&uplo, 1),
                                      F77_CONST_CHAR_ARG2 (&dia, 1),
-                                     nr, tmp_data, nr, rcon,
-                                     pz, prz, info
+                                     nr, F77_CONST_DBLE_CMPLX_ARG (tmp_data), nr, rcon,
+                                     F77_DBLE_CMPLX_ARG (pz), prz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
           if (info != 0)
             rcon = 0.0;
         }
       else if (typ == MatrixType::Permuted_Lower)
@@ -1758,17 +1758,17 @@ ComplexMatrix::rcond (MatrixType &mattyp
 
               ComplexMatrix atmp = *this;
               Complex *tmp_data = atmp.fortran_vec ();
 
               anorm = atmp.abs().sum().
                       row(static_cast<octave_idx_type>(0)).max();
 
               F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
-                                         tmp_data, nr, info
+                                         F77_DBLE_CMPLX_ARG (tmp_data), nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
 
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
@@ -1776,18 +1776,18 @@ ComplexMatrix::rcond (MatrixType &mattyp
               else
                 {
                   Array<Complex> z (dim_vector (2 * nc, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> rz (dim_vector (nc, 1));
                   double *prz = rz.fortran_vec ();
 
                   F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nr, tmp_data, nr, anorm,
-                                             rcon, pz, prz, info
+                                             nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, anorm,
+                                             rcon, F77_DBLE_CMPLX_ARG (pz), prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     rcon = 0.0;
                 }
             }
 
           if (typ == MatrixType::Full)
@@ -1808,29 +1808,29 @@ ComplexMatrix::rcond (MatrixType &mattyp
               Complex *pz = z.fortran_vec ();
               Array<double> rz (dim_vector (2 * nc, 1));
               double *prz = rz.fortran_vec ();
 
               // Work around bug #45577, LAPACK crashes Octave if norm is NaN
               if (octave::math::isnan (anorm))
                 info = -1;
               else
-                F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+                F77_XFCN (zgetrf, ZGETRF, (nr, nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt, info));
 
               if (info != 0)
                 {
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
                 }
               else
                 {
                   char job = '1';
                   F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm,
-                                             rcon, pz, prz, info
+                                             nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, anorm,
+                                             rcon, F77_DBLE_CMPLX_ARG (pz), prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     rcon = 0.0;
                 }
             }
         }
       else
@@ -1879,18 +1879,18 @@ ComplexMatrix::utsolve (MatrixType &matt
 
       char uplo = 'U';
       char trans = get_blas_char (transt);
       char dia = 'N';
 
       F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&trans, 1),
                                  F77_CONST_CHAR_ARG2 (&dia, 1),
-                                 nr, b_nc, tmp_data, nr,
-                                 result, nr, info
+                                 nr, b_nc, F77_CONST_DBLE_CMPLX_ARG (tmp_data), nr,
+                                 F77_DBLE_CMPLX_ARG (result), nr, info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
       if (calc_cond)
         {
           char norm = '1';
           uplo = 'U';
@@ -1899,18 +1899,18 @@ ComplexMatrix::utsolve (MatrixType &matt
           Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (nc, 1));
           double *prz = rz.fortran_vec ();
 
           F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                      F77_CONST_CHAR_ARG2 (&uplo, 1),
                                      F77_CONST_CHAR_ARG2 (&dia, 1),
-                                     nr, tmp_data, nr, rcon,
-                                     pz, prz, info
+                                     nr, F77_CONST_DBLE_CMPLX_ARG (tmp_data), nr, rcon,
+                                     F77_DBLE_CMPLX_ARG (pz), prz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
           if (info != 0)
             info = -2;
 
           volatile double rcond_plus_one = rcon + 1.0;
@@ -1969,18 +1969,18 @@ ComplexMatrix::ltsolve (MatrixType &matt
 
       char uplo = 'L';
       char trans = get_blas_char (transt);
       char dia = 'N';
 
       F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&trans, 1),
                                  F77_CONST_CHAR_ARG2 (&dia, 1),
-                                 nr, b_nc, tmp_data, nr,
-                                 result, nr, info
+                                 nr, b_nc, F77_CONST_DBLE_CMPLX_ARG (tmp_data), nr,
+                                 F77_DBLE_CMPLX_ARG (result), nr, info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
       if (calc_cond)
         {
           char norm = '1';
           uplo = 'L';
@@ -1989,18 +1989,18 @@ ComplexMatrix::ltsolve (MatrixType &matt
           Array<Complex> z (dim_vector (2 * nc, 1));
           Complex *pz = z.fortran_vec ();
           Array<double> rz (dim_vector (nc, 1));
           double *prz = rz.fortran_vec ();
 
           F77_XFCN (ztrcon, ZTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                      F77_CONST_CHAR_ARG2 (&uplo, 1),
                                      F77_CONST_CHAR_ARG2 (&dia, 1),
-                                     nr, tmp_data, nr, rcon,
-                                     pz, prz, info
+                                     nr, F77_CONST_DBLE_CMPLX_ARG (tmp_data), nr, rcon,
+                                     F77_DBLE_CMPLX_ARG (pz), prz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
           if (info != 0)
             info = -2;
 
           volatile double rcond_plus_one = rcon + 1.0;
@@ -2050,17 +2050,17 @@ ComplexMatrix::fsolve (MatrixType &matty
           char job = 'L';
 
           ComplexMatrix atmp = *this;
           Complex *tmp_data = atmp.fortran_vec ();
 
           anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
           F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
-                                     tmp_data, nr, info
+                                     F77_DBLE_CMPLX_ARG (tmp_data), nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
@@ -2072,18 +2072,18 @@ ComplexMatrix::fsolve (MatrixType &matty
               if (calc_cond)
                 {
                   Array<Complex> z (dim_vector (2 * nc, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> rz (dim_vector (nc, 1));
                   double *prz = rz.fortran_vec ();
 
                   F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nr, tmp_data, nr, anorm,
-                                             rcon, pz, prz, info
+                                             nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, anorm,
+                                             rcon, F77_DBLE_CMPLX_ARG (pz), prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     info = -2;
 
                   volatile double rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
@@ -2100,18 +2100,18 @@ ComplexMatrix::fsolve (MatrixType &matty
               if (info == 0)
                 {
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   F77_XFCN (zpotrs, ZPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nr, b_nc, tmp_data, nr,
-                                             result, b.rows (), info
+                                             nr, b_nc, F77_DBLE_CMPLX_ARG (tmp_data), nr,
+                                             F77_DBLE_CMPLX_ARG (result), b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 {
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
             }
@@ -2137,17 +2137,17 @@ ComplexMatrix::fsolve (MatrixType &matty
             anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0))
                     .max ();
 
           // Work around bug #45577, LAPACK crashes Octave if norm is NaN
           // and bug #46330, segfault with matrices containing Inf & NaN
           if (octave::math::isnan (anorm) || octave::math::isinf (anorm))
             info = -2;
           else
-            F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+            F77_XFCN (zgetrf, ZGETRF, (nr, nr, F77_DBLE_CMPLX_ARG (tmp_data), nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
@@ -2160,18 +2160,18 @@ ComplexMatrix::fsolve (MatrixType &matty
           else
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
                   // non-singular matrix.
                   char job = '1';
                   F77_XFCN (zgecon, ZGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm,
-                                             rcon, pz, prz, info
+                                             nc, F77_DBLE_CMPLX_ARG (tmp_data), nr, anorm,
+                                             rcon, F77_DBLE_CMPLX_ARG (pz), prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     info = -2;
 
                   volatile double rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
@@ -2189,18 +2189,18 @@ ComplexMatrix::fsolve (MatrixType &matty
                 {
                   retval = b;
                   Complex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   char job = 'N';
                   F77_XFCN (zgetrs, ZGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nr, b_nc, tmp_data, nr,
-                                             pipvt, result, b.rows (), info
+                                             nr, b_nc, F77_DBLE_CMPLX_ARG (tmp_data), nr,
+                                             pipvt, F77_DBLE_CMPLX_ARG (result), b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 mattype.mark_as_rectangular ();
             }
         }
 
       if (octave::math::isinf (anorm))
@@ -2637,18 +2637,18 @@ ComplexMatrix::lssolve (const ComplexMat
       double *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
-      F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-                                 ps, rcon, rank, work.fortran_vec (),
+      F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m, F77_DBLE_CMPLX_ARG (pretval), maxmn,
+                                 ps, rcon, rank, F77_DBLE_CMPLX_ARG (work.fortran_vec ()),
                                  lwork, prwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
       // should provide sufficient workspace for ZGELSD to operate
       // efficiently.
       if (n > m && n >= mnthr)
         {
@@ -2674,19 +2674,19 @@ ComplexMatrix::lssolve (const ComplexMat
 
           if (std::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
       work.resize (dim_vector (lwork, 1));
 
-      F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval,
+      F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m, F77_DBLE_CMPLX_ARG (pretval),
                                  maxmn, ps, rcon, rank,
-                                 work.fortran_vec (), lwork,
+                                 F77_DBLE_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  prwork, piwork, info));
 
       if (s.elem (0) == 0.0)
         rcon = 0.0;
       else
         rcon = s.elem (minmn - 1) / s.elem (0);
 
       retval.resize (n, nrhs);
@@ -2825,28 +2825,28 @@ ComplexMatrix::lssolve (const ComplexCol
       double *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
-      F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-                                 ps, rcon, rank, work.fortran_vec (),
+      F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m, F77_DBLE_CMPLX_ARG (pretval), maxmn,
+                                 ps, rcon, rank, F77_DBLE_CMPLX_ARG (work.fortran_vec ()),
                                  lwork, prwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
       work.resize (dim_vector (lwork, 1));
       rwork.resize (dim_vector (static_cast<octave_idx_type> (rwork(0)), 1));
       iwork.resize (dim_vector (iwork(0), 1));
 
-      F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, tmp_data, m, pretval,
+      F77_XFCN (zgelsd, ZGELSD, (m, n, nrhs, F77_DBLE_CMPLX_ARG (tmp_data), m, F77_DBLE_CMPLX_ARG (pretval),
                                  maxmn, ps, rcon, rank,
-                                 work.fortran_vec (), lwork,
+                                 F77_DBLE_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  prwork, piwork, info));
 
       if (rank < minmn)
         {
           if (s.elem (0) == 0.0)
             rcon = 0.0;
           else
             rcon = s.elem (minmn - 1) / s.elem (0);
@@ -2885,18 +2885,18 @@ operator * (const ComplexColumnVector& v
     {
       octave_idx_type a_len = a.numel ();
 
       retval = ComplexMatrix (len, a_len);
       Complex *c = retval.fortran_vec ();
 
       F77_XFCN (zgemm, ZGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 ("N", 1),
-                               len, a_len, 1, 1.0, v.data (), len,
-                               a.data (), 1, 0.0, c, len
+                               len, a_len, 1, 1.0, F77_CONST_DBLE_CMPLX_ARG (v.data ()), len,
+                               F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1, 0.0, F77_DBLE_CMPLX_ARG (c), len
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
     }
 
   return retval;
 }
 
 // matrix by diagonal matrix -> matrix operations
@@ -3464,17 +3464,17 @@ operator >> (std::istream& is, ComplexMa
 }
 
 ComplexMatrix
 Givens (const Complex& x, const Complex& y)
 {
   double cc;
   Complex cs, temp_r;
 
-  F77_FUNC (zlartg, ZLARTG) (x, y, cc, cs, temp_r);
+  F77_FUNC (zlartg, ZLARTG) (F77_CONST_DBLE_CMPLX_ARG (&x), F77_CONST_DBLE_CMPLX_ARG (&y), cc, F77_DBLE_CMPLX_ARG (&cs), F77_DBLE_CMPLX_ARG (&temp_r));
 
   ComplexMatrix g (2, 2);
 
   g.elem (0, 0) = cc;
   g.elem (1, 1) = cc;
   g.elem (0, 1) = cs;
   g.elem (1, 0) = -conj (cs);
 
@@ -3513,18 +3513,18 @@ Sylvester (const ComplexMatrix& a, const
   octave_idx_type info;
 
   Complex *pa = sch_a.fortran_vec ();
   Complex *pb = sch_b.fortran_vec ();
   Complex *px = cx.fortran_vec ();
 
   F77_XFCN (ztrsyl, ZTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
-                             1, a_nr, b_nr, pa, a_nr, pb,
-                             b_nr, px, a_nr, scale, info
+                             1, a_nr, b_nr, F77_DBLE_CMPLX_ARG (pa), a_nr, F77_DBLE_CMPLX_ARG (pb),
+                             b_nr, F77_DBLE_CMPLX_ARG (px), a_nr, scale, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   // FIXME: check info?
 
   retval = ua * cx * ub.hermitian ();
 
   return retval;
@@ -3614,29 +3614,29 @@ xgemm (const ComplexMatrix& a, const Com
       Complex *c = retval.fortran_vec ();
 
       const char ctra = get_blas_trans_arg (tra, cja);
       if (cja || cjb)
         {
           F77_XFCN (zherk, ZHERK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                    F77_CONST_CHAR_ARG2 (&ctra, 1),
                                    a_nr, a_nc, 1.0,
-                                   a.data (), lda, 0.0, c, a_nr
+                                   F77_CONST_DBLE_CMPLX_ARG (a.data ()), lda, 0.0, F77_DBLE_CMPLX_ARG (c), a_nr
                                    F77_CHAR_ARG_LEN (1)
                                    F77_CHAR_ARG_LEN (1)));
           for (octave_idx_type j = 0; j < a_nr; j++)
             for (octave_idx_type i = 0; i < j; i++)
               retval.xelem (j,i) = std::conj (retval.xelem (i,j));
         }
       else
         {
           F77_XFCN (zsyrk, ZSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                    F77_CONST_CHAR_ARG2 (&ctra, 1),
                                    a_nr, a_nc, 1.0,
-                                   a.data (), lda, 0.0, c, a_nr
+                                   F77_CONST_DBLE_CMPLX_ARG (a.data ()), lda, 0.0, F77_DBLE_CMPLX_ARG (c), a_nr
                                    F77_CHAR_ARG_LEN (1)
                                    F77_CHAR_ARG_LEN (1)));
           for (octave_idx_type j = 0; j < a_nr; j++)
             for (octave_idx_type i = 0; i < j; i++)
               retval.xelem (j,i) = retval.xelem (i,j);
 
         }
 
@@ -3650,51 +3650,51 @@ xgemm (const ComplexMatrix& a, const Com
 
       retval = ComplexMatrix (a_nr, b_nc, 0.0);
       Complex *c = retval.fortran_vec ();
 
       if (b_nc == 1 && a_nr == 1)
         {
           if (cja == cjb)
             {
-              F77_FUNC (xzdotu, XZDOTU) (a_nc, a.data (), 1, b.data (), 1,
-                                         *c);
+              F77_FUNC (xzdotu, XZDOTU) (a_nc, F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1, F77_CONST_DBLE_CMPLX_ARG (b.data ()), 1,
+                                         F77_DBLE_CMPLX_ARG (c));
               if (cja) *c = std::conj (*c);
             }
           else if (cja)
-            F77_FUNC (xzdotc, XZDOTC) (a_nc, a.data (), 1, b.data (), 1,
-                                       *c);
+            F77_FUNC (xzdotc, XZDOTC) (a_nc, F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1, F77_CONST_DBLE_CMPLX_ARG (b.data ()), 1,
+                                       F77_DBLE_CMPLX_ARG (c));
           else
-            F77_FUNC (xzdotc, XZDOTC) (a_nc, b.data (), 1, a.data (), 1,
-                                       *c);
+            F77_FUNC (xzdotc, XZDOTC) (a_nc, F77_CONST_DBLE_CMPLX_ARG (b.data ()), 1, F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1,
+                                       F77_DBLE_CMPLX_ARG (c));
         }
       else if (b_nc == 1 && ! cjb)
         {
           const char ctra = get_blas_trans_arg (tra, cja);
           F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 (&ctra, 1),
-                                   lda, tda, 1.0,  a.data (), lda,
-                                   b.data (), 1, 0.0, c, 1
+                                   lda, tda, 1.0,  F77_CONST_DBLE_CMPLX_ARG (a.data ()), lda,
+                                   F77_CONST_DBLE_CMPLX_ARG (b.data ()), 1, 0.0, F77_DBLE_CMPLX_ARG (c), 1
                                    F77_CHAR_ARG_LEN (1)));
         }
       else if (a_nr == 1 && ! cja && ! cjb)
         {
           const char crevtrb = get_blas_trans_arg (! trb, cjb);
           F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 (&crevtrb, 1),
-                                   ldb, tdb, 1.0,  b.data (), ldb,
-                                   a.data (), 1, 0.0, c, 1
+                                   ldb, tdb, 1.0,  F77_CONST_DBLE_CMPLX_ARG (b.data ()), ldb,
+                                   F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1, 0.0, F77_DBLE_CMPLX_ARG (c), 1
                                    F77_CHAR_ARG_LEN (1)));
         }
       else
         {
           const char ctra = get_blas_trans_arg (tra, cja);
           const char ctrb = get_blas_trans_arg (trb, cjb);
           F77_XFCN (zgemm, ZGEMM, (F77_CONST_CHAR_ARG2 (&ctra, 1),
                                    F77_CONST_CHAR_ARG2 (&ctrb, 1),
-                                   a_nr, b_nc, a_nc, 1.0, a.data (),
-                                   lda, b.data (), ldb, 0.0, c, a_nr
+                                   a_nr, b_nc, a_nc, 1.0, F77_CONST_DBLE_CMPLX_ARG (a.data ()),
+                                   lda, F77_CONST_DBLE_CMPLX_ARG (b.data ()), ldb, 0.0, F77_DBLE_CMPLX_ARG (c), a_nr
                                    F77_CHAR_ARG_LEN (1)
                                    F77_CHAR_ARG_LEN (1)));
         }
     }
 
   return retval;
 }
 
diff --git a/liboctave/array/CRowVector.cc b/liboctave/array/CRowVector.cc
--- a/liboctave/array/CRowVector.cc
+++ b/liboctave/array/CRowVector.cc
@@ -46,17 +46,17 @@ extern "C"
                            const F77_INT&, const F77_DBLE_CMPLX*,
                            const F77_INT&, const F77_DBLE_CMPLX&, F77_DBLE_CMPLX*,
                            const F77_INT&
                            F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xzdotu, XZDOTU) (const F77_INT&, const F77_DBLE_CMPLX*,
                              const F77_INT&, const F77_DBLE_CMPLX*,
-                             const F77_INT&, F77_DBLE_CMPLX&);
+                             const F77_INT&, F77_DBLE_CMPLX*);
 }
 
 // Complex Row Vector class
 
 bool
 ComplexRowVector::operator == (const ComplexRowVector& a) const
 {
   octave_idx_type len = numel ();
@@ -316,18 +316,18 @@ operator * (const ComplexRowVector& v, c
       // Transpose A to form A'*x == (x'*A)'
 
       octave_idx_type ld = a_nr;
 
       retval.resize (a_nc);
       Complex *y = retval.fortran_vec ();
 
       F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
-                               a_nr, a_nc, 1.0, a.data (),
-                               ld, v.data (), 1, 0.0, y, 1
+                               a_nr, a_nc, 1.0, F77_CONST_DBLE_CMPLX_ARG (a.data ()),
+                               ld, F77_CONST_DBLE_CMPLX_ARG (v.data ()), 1, 0.0, F77_DBLE_CMPLX_ARG (y), 1
                                F77_CHAR_ARG_LEN (1)));
     }
 
   return retval;
 }
 
 ComplexRowVector
 operator * (const RowVector& v, const ComplexMatrix& a)
@@ -427,17 +427,17 @@ operator * (const ComplexRowVector& v, c
 
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     err_nonconformant ("operator *", len, a_len);
   if (len != 0)
-    F77_FUNC (xzdotu, XZDOTU) (len, v.data (), 1, a.data (), 1, retval);
+    F77_FUNC (xzdotu, XZDOTU) (len, F77_CONST_DBLE_CMPLX_ARG (v.data ()), 1, F77_CONST_DBLE_CMPLX_ARG (a.data ()), 1, F77_DBLE_CMPLX_ARG (&retval));
 
   return retval;
 }
 
 // other operations
 
 ComplexRowVector
 linspace (const Complex& x1, const Complex& x2, octave_idx_type n)
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -3751,17 +3751,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       DL[j] = data (i);
                   }
             }
 
           octave_idx_type b_nc = b.cols ();
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result,
+          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (result),
                                    b.rows (), err));
 
           if (err != 0)
             {
               err = 0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Tridiagonal;
             }
@@ -3808,17 +3808,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       DU[j-1] = data (i);
                   }
             }
 
           octave_idx_type b_nc = b.cols ();
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result,
+          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (result),
                                    b.rows (), err));
 
           if (err != 0)
             {
               rcond = 0.;
               err = -2;
 
               if (sing_handler)
@@ -3907,17 +3907,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          F77_XFCN (zgttrf, ZGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
+          F77_XFCN (zgttrf, ZGTTRF, (nr, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (DU2), pipvt, err));
 
           if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
                 {
@@ -3943,18 +3943,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
                 {
                   for (octave_idx_type i = 0; i < nr; i++)
                     work[i] = 0.;
                   for (octave_idx_type i = b.cidx (j); i < b.cidx (j+1); i++)
                     work[b.ridx (i)] = b.data (i);
 
                   F77_XFCN (zgttrs, ZGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, 1, DL, D, DU, DU2, pipvt,
-                             work, b.rows (), err
+                             nr, 1, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (DU2), pipvt,
+                             F77_DBLE_CMPLX_ARG (work), b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
 
                   // Count nonzeros in work vector and adjust
                   // space in retval if needed
                   octave_idx_type new_nnz = 0;
                   for (octave_idx_type i = 0; i < nr; i++)
                     if (work[i] != 0.)
                       new_nnz++;
@@ -4051,17 +4051,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
 
           octave_idx_type b_nr = b.rows ();
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result,
+          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (result),
                                    b_nr, err));
 
           if (err != 0)
             {
               err = 0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Tridiagonal;
             }
@@ -4109,17 +4109,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
 
           octave_idx_type b_nr = b.rows ();
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = ComplexMatrix (b);
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result,
+          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (result),
                                    b_nr, err));
 
           if (err != 0)
             {
               rcond = 0.;
               err = -2;
 
               if (sing_handler)
@@ -4206,17 +4206,17 @@ SparseComplexMatrix::trisolve (MatrixTyp
                       D[j] = data (i);
                     else if (ridx (i) == j + 1)
                       DL[j] = data (i);
                     else if (ridx (i) == j - 1)
                       DU[j-1] = data (i);
                   }
             }
 
-          F77_XFCN (zgttrf, ZGTTRF, (nr, DL, D, DU, DU2, pipvt, err));
+          F77_XFCN (zgttrf, ZGTTRF, (nr, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (DU2), pipvt, err));
 
           if (err != 0)
             {
               rcond = 0.0;
               err = -2;
 
               if (sing_handler)
                 {
@@ -4244,18 +4244,18 @@ SparseComplexMatrix::trisolve (MatrixTyp
               for (volatile octave_idx_type j = 0; j < b_nc; j++)
                 {
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
                     Bx[i] = b(i,j);
 
                   F77_XFCN (zgttrs, ZGTTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, 1, DL, D, DU, DU2, pipvt,
-                             Bx, b_nr, err
+                             nr, 1, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (DU2), pipvt,
+                             F77_DBLE_CMPLX_ARG (Bx), b_nr, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
                       // FIXME: This should probably be a warning so that
                       //        error value can be passed back.
                       (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
@@ -4349,17 +4349,17 @@ SparseComplexMatrix::bsolve (MatrixType 
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nr, n_lower, tmp_data, ldm, err
+                                     nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
               rcond = 0.0;
               // Matrix is not positive definite!! Fall through to
               // unsymmetric banded solver.
               mattype.mark_as_unsymmetric ();
@@ -4372,18 +4372,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                 {
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, tmp_data, ldm,
-                             anorm, rcond, pz, piz, err
+                             nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm,
+                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
@@ -4406,18 +4406,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                 {
                   retval = ComplexMatrix (b);
                   Complex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   F77_XFCN (zpbtrs, ZPBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, b_nc, tmp_data,
-                             ldm, result, b.rows (), err
+                             nr, n_lower, b_nc, F77_DBLE_CMPLX_ARG (tmp_data),
+                             ldm, F77_DBLE_CMPLX_ARG (result), b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
                       // FIXME: Probably should be a warning.
                       (*current_liboctave_error_handler)
                         ("SparseMatrix::solve solve failed");
                       err = -1;
@@ -4461,17 +4461,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-          F77_XFCN (zgbtrf, ZGBTRF, (nr, nc, n_lower, n_upper, tmp_data,
+          F77_XFCN (zgbtrf, ZGBTRF, (nr, nc, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data),
                                      ldm, pipvt, err));
 
           // Throw-away extra info LAPACK gives so as to not
           // change output.
           if (err != 0)
             {
               rcond = 0.0;
               err = -2;
@@ -4491,18 +4491,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zgbcon, ZGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-                             anorm, rcond, pz, piz, err
+                             nc, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data), ldm, pipvt,
+                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
@@ -4526,18 +4526,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                   retval = ComplexMatrix (b);
                   Complex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   char job = 'N';
                   F77_XFCN (zgbtrs, ZGBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, n_upper, b_nc, tmp_data,
-                             ldm, pipvt, result, b.rows (), err
+                             nr, n_lower, n_upper, b_nc, F77_DBLE_CMPLX_ARG (tmp_data),
+                             ldm, pipvt, F77_DBLE_CMPLX_ARG (result), b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -4595,17 +4595,17 @@ SparseComplexMatrix::bsolve (MatrixType 
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nr, n_lower, tmp_data, ldm, err
+                                     nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
               rcond = 0.0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
               err = 0;
@@ -4616,18 +4616,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                 {
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, tmp_data, ldm,
-                             anorm, rcond, pz, piz, err
+                             nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm,
+                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
@@ -4661,18 +4661,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                   retval.xcidx (0) = 0;
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         Bx[i] = b.elem (i, j);
 
                       F77_XFCN (zpbtrs, ZPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nr, n_lower, 1, tmp_data,
-                                 ldm, Bx, b_nr, err
+                                 nr, n_lower, 1, F77_DBLE_CMPLX_ARG (tmp_data),
+                                 ldm, F77_DBLE_CMPLX_ARG (Bx), b_nr, err
                                  F77_CHAR_ARG_LEN (1)));
 
                       if (err != 0)
                         {
                           // FIXME: Probably should be a warning.
                           (*current_liboctave_error_handler)
                             ("SparseComplexMatrix::solve solve failed");
                           err = -1;
@@ -4740,17 +4740,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data,
+          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data),
                                      ldm, pipvt, err));
 
           if (err != 0)
             {
               rcond = 0.0;
               err = -2;
 
               if (sing_handler)
@@ -4768,18 +4768,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zgbcon, ZGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-                             anorm, rcond, pz, piz, err
+                             nc, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data), ldm, pipvt,
+                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
@@ -4814,18 +4814,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                       for (octave_idx_type i = 0; i < nr; i++)
                         work[i] = 0.;
                       for (octave_idx_type i = b.cidx (j);
                            i < b.cidx (j+1); i++)
                         work[b.ridx (i)] = b.data (i);
 
                       F77_XFCN (zgbtrs, ZGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nr, n_lower, n_upper, 1, tmp_data,
-                                 ldm, pipvt, work, b.rows (), err
+                                 nr, n_lower, n_upper, 1, F77_DBLE_CMPLX_ARG (tmp_data),
+                                 ldm, pipvt, F77_DBLE_CMPLX_ARG (work), b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
                       // Count nonzeros in work vector and adjust
                       // space in retval if needed
                       octave_idx_type new_nnz = 0;
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (work[i] != 0.)
                           new_nnz++;
@@ -4909,17 +4909,17 @@ SparseComplexMatrix::bsolve (MatrixType 
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nr, n_lower, tmp_data, ldm, err
+                                     nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
               // Matrix is not positive definite!! Fall through to
               // unsymmetric banded solver.
               rcond = 0.0;
               mattype.mark_as_unsymmetric ();
@@ -4932,18 +4932,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                 {
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, tmp_data, ldm,
-                             anorm, rcond, pz, piz, err
+                             nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm,
+                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
@@ -4966,18 +4966,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                 {
                   octave_idx_type b_nr = b.rows ();
                   octave_idx_type b_nc = b.cols ();
                   retval = ComplexMatrix (b);
                   Complex *result = retval.fortran_vec ();
 
                   F77_XFCN (zpbtrs, ZPBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, b_nc, tmp_data,
-                             ldm, result, b_nr, err
+                             nr, n_lower, b_nc, F77_DBLE_CMPLX_ARG (tmp_data),
+                             ldm, F77_DBLE_CMPLX_ARG (result), b_nr, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     {
                       // FIXME: Probably should be a warning.
                       (*current_liboctave_error_handler)
                         ("SparseComplexMatrix::solve solve failed");
                       err = -1;
@@ -5021,17 +5021,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data,
+          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data),
                                      ldm, pipvt, err));
 
           if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
@@ -5049,18 +5049,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zgbcon, ZGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-                             anorm, rcond, pz, piz, err
+                             nc, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data), ldm, pipvt,
+                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
@@ -5083,18 +5083,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                 {
                   char job = 'N';
                   octave_idx_type b_nc = b.cols ();
                   retval = ComplexMatrix (b);
                   Complex *result = retval.fortran_vec ();
 
                   F77_XFCN (zgbtrs, ZGBTRS,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, n_upper, b_nc, tmp_data,
-                             ldm, pipvt, result, b.rows (), err
+                             nr, n_lower, n_upper, b_nc, F77_DBLE_CMPLX_ARG (tmp_data),
+                             ldm, pipvt, F77_DBLE_CMPLX_ARG (result), b.rows (), err
                              F77_CHAR_ARG_LEN (1)));
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -5152,17 +5152,17 @@ SparseComplexMatrix::bsolve (MatrixType 
 
           // Calculate the norm of the matrix, for later use.
           double anorm;
           if (calc_cond)
             anorm = m_band.abs ().sum ().row (0).max ();
 
           char job = 'L';
           F77_XFCN (zpbtrf, ZPBTRF, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nr, n_lower, tmp_data, ldm, err
+                                     nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm, err
                                      F77_CHAR_ARG_LEN (1)));
 
           if (err != 0)
             {
               // Matrix is not positive definite!! Fall through to
               // unsymmetric banded solver.
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Banded;
@@ -5176,18 +5176,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                 {
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zpbcon, ZPBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nr, n_lower, tmp_data, ldm,
-                             anorm, rcond, pz, piz, err
+                             nr, n_lower, F77_DBLE_CMPLX_ARG (tmp_data), ldm,
+                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
@@ -5222,18 +5222,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                   for (volatile octave_idx_type j = 0; j < b_nc; j++)
                     {
 
                       for (octave_idx_type i = 0; i < b_nr; i++)
                         Bx[i] = b(i,j);
 
                       F77_XFCN (zpbtrs, ZPBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nr, n_lower, 1, tmp_data,
-                                 ldm, Bx, b_nr, err
+                                 nr, n_lower, 1, F77_DBLE_CMPLX_ARG (tmp_data),
+                                 ldm, F77_DBLE_CMPLX_ARG (Bx), b_nr, err
                                  F77_CHAR_ARG_LEN (1)));
 
                       if (err != 0)
                         {
                           // FIXME: Probably should be a warning.
                           (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
@@ -5305,17 +5305,17 @@ SparseComplexMatrix::bsolve (MatrixType 
                   if (atmp > anorm)
                     anorm = atmp;
                 }
             }
 
           Array<octave_idx_type> ipvt (dim_vector (nr, 1));
           octave_idx_type *pipvt = ipvt.fortran_vec ();
 
-          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, tmp_data,
+          F77_XFCN (zgbtrf, ZGBTRF, (nr, nr, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data),
                                      ldm, pipvt, err));
 
           if (err != 0)
             {
               err = -2;
               rcond = 0.0;
 
               if (sing_handler)
@@ -5333,18 +5333,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                   char job = '1';
                   Array<Complex> z (dim_vector (2 * nr, 1));
                   Complex *pz = z.fortran_vec ();
                   Array<double> iz (dim_vector (nr, 1));
                   double *piz = iz.fortran_vec ();
 
                   F77_XFCN (zgbcon, ZGBCON,
                             (F77_CONST_CHAR_ARG2 (&job, 1),
-                             nc, n_lower, n_upper, tmp_data, ldm, pipvt,
-                             anorm, rcond, pz, piz, err
+                             nc, n_lower, n_upper, F77_DBLE_CMPLX_ARG (tmp_data), ldm, pipvt,
+                             anorm, rcond, F77_DBLE_CMPLX_ARG (pz), piz, err
                              F77_CHAR_ARG_LEN (1)));
 
                   if (err != 0)
                     err = -2;
 
                   volatile double rcond_plus_one = rcond + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcond))
@@ -5380,18 +5380,18 @@ SparseComplexMatrix::bsolve (MatrixType 
                         Bx[i] = 0.;
 
                       for (octave_idx_type i = b.cidx (j);
                            i < b.cidx (j+1); i++)
                         Bx[b.ridx (i)] = b.data (i);
 
                       F77_XFCN (zgbtrs, ZGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nr, n_lower, n_upper, 1, tmp_data,
-                                 ldm, pipvt, Bx, b.rows (), err
+                                 nr, n_lower, n_upper, 1, F77_DBLE_CMPLX_ARG (tmp_data),
+                                 ldm, pipvt, F77_DBLE_CMPLX_ARG (Bx), b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
                       // Count nonzeros in work vector and adjust
                       // space in retval if needed
                       octave_idx_type new_nnz = 0;
                       for (octave_idx_type i = 0; i < nr; i++)
                         if (Bx[i] != 0.)
                           new_nnz++;
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -4141,17 +4141,17 @@ SparseMatrix::trisolve (MatrixType &matt
 
           octave_idx_type b_nr = b.rows ();
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = b;
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, DL, result,
+          F77_XFCN (zptsv, ZPTSV, (nr, b_nc, D, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (result),
                                    b_nr, err));
 
           if (err != 0)
             {
               err = 0;
               mattype.mark_as_unsymmetric ();
               typ = MatrixType::Tridiagonal;
             }
@@ -4199,17 +4199,17 @@ SparseMatrix::trisolve (MatrixType &matt
 
           octave_idx_type b_nr = b.rows ();
           octave_idx_type b_nc = b.cols ();
           rcond = 1.;
 
           retval = b;
           Complex *result = retval.fortran_vec ();
 
-          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, DL, D, DU, result,
+          F77_XFCN (zgtsv, ZGTSV, (nr, b_nc, F77_DBLE_CMPLX_ARG (DL), F77_DBLE_CMPLX_ARG (D), F77_DBLE_CMPLX_ARG (DU), F77_DBLE_CMPLX_ARG (result),
                                    b_nr, err));
 
           if (err != 0)
             {
               rcond = 0.;
               err = -2;
 
               if (sing_handler)
diff --git a/liboctave/array/fCColVector.cc b/liboctave/array/fCColVector.cc
--- a/liboctave/array/fCColVector.cc
+++ b/liboctave/array/fCColVector.cc
@@ -332,18 +332,18 @@ operator * (const FloatComplexMatrix& m,
     {
       if (nc == 0)
         retval.fill (0.0);
       else
         {
           FloatComplex *y = retval.fortran_vec ();
 
           F77_XFCN (cgemv, CGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                                   nr, nc, 1.0f, m.data (), nr,
-                                   a.data (), 1, 0.0f, y, 1
+                                   nr, nc, 1.0f, F77_CONST_CMPLX_ARG (m.data ()), nr,
+                                   F77_CONST_CMPLX_ARG (a.data ()), 1, 0.0f, F77_CMPLX_ARG (y), 1
                                    F77_CHAR_ARG_LEN (1)));
         }
     }
 
   return retval;
 }
 
 // matrix by column vector -> column vector operations
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -113,22 +113,22 @@ extern "C"
                            const F77_INT&, const F77_CMPLX*,
                            const F77_INT&, const F77_CMPLX&,
                            F77_CMPLX*, const F77_INT&
                            F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xcdotu, XCDOTU) (const F77_INT&, const F77_CMPLX*,
                              const F77_INT&, const F77_CMPLX*,
-                             const F77_INT&, F77_CMPLX&);
+                             const F77_INT&, F77_CMPLX*);
 
   F77_RET_T
   F77_FUNC (xcdotc, XCDOTC) (const F77_INT&, const F77_CMPLX*,
                              const F77_INT&, const F77_CMPLX*,
-                             const F77_INT&, F77_CMPLX&);
+                             const F77_INT&, F77_CMPLX*);
 
   F77_RET_T
   F77_FUNC (csyrk, CSYRK) (F77_CONST_CHAR_ARG_DECL,
                            F77_CONST_CHAR_ARG_DECL,
                            const F77_INT&, const F77_INT&,
                            const F77_CMPLX&, const F77_CMPLX*,
                            const F77_INT&, const F77_CMPLX&,
                            F77_CMPLX*, const F77_INT&
@@ -236,18 +236,18 @@ extern "C"
                              const F77_CMPLX*, const F77_INT&,
                              F77_CMPLX*, const F77_INT&,
                              F77_INT&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
-  F77_FUNC (clartg, CLARTG) (const F77_CMPLX&, const F77_CMPLX&,
-                             F77_REAL&, F77_CMPLX&, F77_CMPLX&);
+  F77_FUNC (clartg, CLARTG) (const F77_CMPLX*, const F77_CMPLX*,
+                             F77_REAL&, F77_CMPLX*, F77_CMPLX*);
 
   F77_RET_T
   F77_FUNC (ctrsyl, CTRSYL) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const F77_INT&, const F77_INT&,
                              const F77_INT&, const F77_CMPLX*,
                              const F77_INT&, const F77_CMPLX*,
                              const F77_INT&, const F77_CMPLX*,
@@ -976,17 +976,17 @@ FloatComplexMatrix::tinverse (MatrixType
   int typ = mattype.type ();
   char uplo = (typ == MatrixType::Lower ? 'L' : 'U');
   char udiag = 'N';
   retval = *this;
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   F77_XFCN (ctrtri, CTRTRI, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                              F77_CONST_CHAR_ARG2 (&udiag, 1),
-                             nr, tmp_data, nr, info
+                             nr, F77_CMPLX_ARG (tmp_data), nr, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   // Throw-away extra info LAPACK gives so as to not change output.
   rcon = 0.0;
   if (info != 0)
     info = -1;
   else if (calc_cond)
@@ -995,18 +995,18 @@ FloatComplexMatrix::tinverse (MatrixType
       char job = '1';
 
       OCTAVE_LOCAL_BUFFER (FloatComplex, cwork, 2*nr);
       OCTAVE_LOCAL_BUFFER (float, rwork, nr);
 
       F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&job, 1),
                                  F77_CONST_CHAR_ARG2 (&uplo, 1),
                                  F77_CONST_CHAR_ARG2 (&udiag, 1),
-                                 nr, tmp_data, nr, rcon,
-                                 cwork, rwork, ztrcon_info
+                                 nr, F77_CMPLX_ARG (tmp_data), nr, rcon,
+                                 F77_CMPLX_ARG (cwork), rwork, ztrcon_info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
       if (ztrcon_info != 0)
         info = -1;
     }
 
@@ -1034,18 +1034,18 @@ FloatComplexMatrix::finverse (MatrixType
   retval = *this;
   FloatComplex *tmp_data = retval.fortran_vec ();
 
   Array<FloatComplex> z (dim_vector (1, 1));
   octave_idx_type lwork = -1;
 
   // Query the optimum work array size.
 
-  F77_XFCN (cgetri, CGETRI, (nc, tmp_data, nr, pipvt,
-                             z.fortran_vec (), lwork, info));
+  F77_XFCN (cgetri, CGETRI, (nc, F77_CMPLX_ARG (tmp_data), nr, pipvt,
+                             F77_CMPLX_ARG (z.fortran_vec ()), lwork, info));
 
   lwork = static_cast<octave_idx_type> (std::real (z(0)));
   lwork = (lwork <  2 *nc ? 2*nc : lwork);
   z.resize (dim_vector (lwork, 1));
   FloatComplex *pz = z.fortran_vec ();
 
   info = 0;
 
@@ -1053,46 +1053,46 @@ FloatComplexMatrix::finverse (MatrixType
   float anorm =
     retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
   // Work around bug #45577, LAPACK crashes Octave if norm is NaN
   // and bug #46330, segfault with matrices containing Inf & NaN
   if (octave::math::isnan (anorm) || octave::math::isinf (anorm))
     info = -1;
   else
-    F77_XFCN (cgetrf, CGETRF, (nc, nc, tmp_data, nr, pipvt, info));
+    F77_XFCN (cgetrf, CGETRF, (nc, nc, F77_CMPLX_ARG (tmp_data), nr, pipvt, info));
 
   // Throw-away extra info LAPACK gives so as to not change output.
   rcon = 0.0;
   if (info != 0)
     info = -1;
   else if (calc_cond)
     {
       // Now calculate the condition number for non-singular matrix.
       octave_idx_type zgecon_info = 0;
       char job = '1';
       Array<float> rz (dim_vector (2 * nc, 1));
       float *prz = rz.fortran_vec ();
       F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 nc, tmp_data, nr, anorm,
-                                 rcon, pz, prz, zgecon_info
+                                 nc, F77_CMPLX_ARG (tmp_data), nr, anorm,
+                                 rcon, F77_CMPLX_ARG (pz), prz, zgecon_info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (zgecon_info != 0)
         info = -1;
     }
 
   if ((info == -1 && ! force) || octave::math::isinf (anorm))
     retval = *this;  // Restore contents.
   else
     {
       octave_idx_type zgetri_info = 0;
 
-      F77_XFCN (cgetri, CGETRI, (nc, tmp_data, nr, pipvt,
-                                 pz, lwork, zgetri_info));
+      F77_XFCN (cgetri, CGETRI, (nc, F77_CMPLX_ARG (tmp_data), nr, pipvt,
+                                 F77_CMPLX_ARG (pz), lwork, zgetri_info));
 
       if (zgetri_info != 0)
         info = -1;
     }
 
   if (info != 0)
     mattype.mark_as_rectangular ();
 
@@ -1564,35 +1564,35 @@ FloatComplexMatrix::determinant (MatrixT
       FloatComplexMatrix atmp = *this;
       FloatComplex *tmp_data = atmp.fortran_vec ();
 
       float anorm = 0;
       if (calc_cond) anorm = xnorm (*this, 1);
 
       char job = 'L';
       F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
-                                 tmp_data, nr, info
+                                 F77_CMPLX_ARG (tmp_data), nr, info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (info != 0)
         {
           rcon = 0.0;
           mattype.mark_as_unsymmetric ();
           typ = MatrixType::Full;
         }
       else
         {
           Array<FloatComplex> z (dim_vector (2 * nc, 1));
           FloatComplex *pz = z.fortran_vec ();
           Array<float> rz (dim_vector (nc, 1));
           float *prz = rz.fortran_vec ();
 
           F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                     nr, tmp_data, nr, anorm,
-                                     rcon, pz, prz, info
+                                     nr, F77_CMPLX_ARG (tmp_data), nr, anorm,
+                                     rcon, F77_CMPLX_ARG (pz), prz, info
                                      F77_CHAR_ARG_LEN (1)));
 
           if (info != 0)
             rcon = 0.0;
 
           for (octave_idx_type i = 0; i < nc; i++)
             retval *= atmp (i,i);
 
@@ -1614,17 +1614,17 @@ FloatComplexMatrix::determinant (MatrixT
 
       // Calculate (always, see bug #45577) the norm of the matrix, for later use.
       float anorm = xnorm (*this, 1);
 
       // Work around bug #45577, LAPACK crashes Octave if norm is NaN
       if (octave::math::isnan (anorm))
         info = -1;
       else
-        F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+        F77_XFCN (cgetrf, CGETRF, (nr, nr, F77_CMPLX_ARG (tmp_data), nr, pipvt, info));
 
       // Throw-away extra info LAPACK gives so as to not change output.
       rcon = 0.0;
       if (info != 0)
         {
           info = -1;
           retval = FloatComplexDET ();
         }
@@ -1635,18 +1635,18 @@ FloatComplexMatrix::determinant (MatrixT
               // Now calc the condition number for non-singular matrix.
               char job = '1';
               Array<FloatComplex> z (dim_vector (2 * nc, 1));
               FloatComplex *pz = z.fortran_vec ();
               Array<float> rz (dim_vector (2 * nc, 1));
               float *prz = rz.fortran_vec ();
 
               F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                         nc, tmp_data, nr, anorm,
-                                         rcon, pz, prz, info
+                                         nc, F77_CMPLX_ARG (tmp_data), nr, anorm,
+                                         rcon, F77_CMPLX_ARG (pz), prz, info
                                          F77_CHAR_ARG_LEN (1)));
             }
 
           if (info != 0)
             {
               info = -1;
               retval = FloatComplexDET ();
             }
@@ -1702,18 +1702,18 @@ FloatComplexMatrix::rcond (MatrixType &m
           Array<FloatComplex> z (dim_vector (2 * nc, 1));
           FloatComplex *pz = z.fortran_vec ();
           Array<float> rz (dim_vector (nc, 1));
           float *prz = rz.fortran_vec ();
 
           F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                      F77_CONST_CHAR_ARG2 (&uplo, 1),
                                      F77_CONST_CHAR_ARG2 (&dia, 1),
-                                     nr, tmp_data, nr, rcon,
-                                     pz, prz, info
+                                     nr, F77_CONST_CMPLX_ARG (tmp_data), nr, rcon,
+                                     F77_CMPLX_ARG (pz), prz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
           if (info != 0)
             rcon = 0;
         }
       else if  (typ == MatrixType::Permuted_Upper)
@@ -1730,18 +1730,18 @@ FloatComplexMatrix::rcond (MatrixType &m
           Array<FloatComplex> z (dim_vector (2 * nc, 1));
           FloatComplex *pz = z.fortran_vec ();
           Array<float> rz (dim_vector (nc, 1));
           float *prz = rz.fortran_vec ();
 
           F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                      F77_CONST_CHAR_ARG2 (&uplo, 1),
                                      F77_CONST_CHAR_ARG2 (&dia, 1),
-                                     nr, tmp_data, nr, rcon,
-                                     pz, prz, info
+                                     nr, F77_CONST_CMPLX_ARG (tmp_data), nr, rcon,
+                                     F77_CMPLX_ARG (pz), prz, info
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)
                                      F77_CHAR_ARG_LEN (1)));
 
           if (info != 0)
             rcon = 0.0;
         }
       else if (typ == MatrixType::Permuted_Lower)
@@ -1758,17 +1758,17 @@ FloatComplexMatrix::rcond (MatrixType &m
 
               FloatComplexMatrix atmp = *this;
               FloatComplex *tmp_data = atmp.fortran_vec ();
 
               anorm = atmp.abs().sum().
                       row(static_cast<octave_idx_type>(0)).max();
 
               F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
-                                         tmp_data, nr, info
+                                         F77_CMPLX_ARG (tmp_data), nr, info
                                          F77_CHAR_ARG_LEN (1)));
 
               if (info != 0)
                 {
                   rcon = 0.0;
 
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
@@ -1776,18 +1776,18 @@ FloatComplexMatrix::rcond (MatrixType &m
               else
                 {
                   Array<FloatComplex> z (dim_vector (2 * nc, 1));
                   FloatComplex *pz = z.fortran_vec ();
                   Array<float> rz (dim_vector (nc, 1));
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nr, tmp_data, nr, anorm,
-                                             rcon, pz, prz, info
+                                             nr, F77_CMPLX_ARG (tmp_data), nr, anorm,
+                                             rcon, F77_CMPLX_ARG (pz), prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     rcon = 0.0;
                 }
             }
 
           if (typ == MatrixType::Full)
@@ -1808,29 +1808,29 @@ FloatComplexMatrix::rcond (MatrixType &m
               FloatComplex *pz = z.fortran_vec ();
               Array<float> rz (dim_vector (2 * nc, 1));
               float *prz = rz.fortran_vec ();
 
               // Work around bug #45577, LAPACK crashes Octave if norm is NaN
               if (octave::math::isnan (anorm))
                 info = -1;
               else
-                F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+                F77_XFCN (cgetrf, CGETRF, (nr, nr, F77_CMPLX_ARG (tmp_data), nr, pipvt, info));
 
               if (info != 0)
                 {
                   rcon = 0.0;
                   mattype.mark_as_rectangular ();
                 }
               else
                 {
                   char job = '1';
                   F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm,
-                                             rcon, pz, prz, info
+                                             nc, F77_CMPLX_ARG (tmp_data), nr, anorm,
+                                             rcon, F77_CMPLX_ARG (pz), prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     rcon = 0.0;
                 }
             }
         }
       else
@@ -1879,18 +1879,18 @@ FloatComplexMatrix::utsolve (MatrixType 
 
               char uplo = 'U';
               char trans = get_blas_char (transt);
               char dia = 'N';
 
               F77_XFCN (ctrtrs, CTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                                          F77_CONST_CHAR_ARG2 (&trans, 1),
                                          F77_CONST_CHAR_ARG2 (&dia, 1),
-                                         nr, b_nc, tmp_data, nr,
-                                         result, nr, info
+                                         nr, b_nc, F77_CONST_CMPLX_ARG (tmp_data), nr,
+                                         F77_CMPLX_ARG (result), nr, info
                                          F77_CHAR_ARG_LEN (1)
                                          F77_CHAR_ARG_LEN (1)
                                          F77_CHAR_ARG_LEN (1)));
 
               if (calc_cond)
                 {
                   char norm = '1';
                   uplo = 'U';
@@ -1899,18 +1899,18 @@ FloatComplexMatrix::utsolve (MatrixType 
                   Array<FloatComplex> z (dim_vector (2 * nc, 1));
                   FloatComplex *pz = z.fortran_vec ();
                   Array<float> rz (dim_vector (nc, 1));
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                              F77_CONST_CHAR_ARG2 (&uplo, 1),
                                              F77_CONST_CHAR_ARG2 (&dia, 1),
-                                             nr, tmp_data, nr, rcon,
-                                             pz, prz, info
+                                             nr, F77_CONST_CMPLX_ARG (tmp_data), nr, rcon,
+                                             F77_CMPLX_ARG (pz), prz, info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
@@ -1973,18 +1973,18 @@ FloatComplexMatrix::ltsolve (MatrixType 
 
               char uplo = 'L';
               char trans = get_blas_char (transt);
               char dia = 'N';
 
               F77_XFCN (ctrtrs, CTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1),
                                          F77_CONST_CHAR_ARG2 (&trans, 1),
                                          F77_CONST_CHAR_ARG2 (&dia, 1),
-                                         nr, b_nc, tmp_data, nr,
-                                         result, nr, info
+                                         nr, b_nc, F77_CONST_CMPLX_ARG (tmp_data), nr,
+                                         F77_CMPLX_ARG (result), nr, info
                                          F77_CHAR_ARG_LEN (1)
                                          F77_CHAR_ARG_LEN (1)
                                          F77_CHAR_ARG_LEN (1)));
 
               if (calc_cond)
                 {
                   char norm = '1';
                   uplo = 'L';
@@ -1993,18 +1993,18 @@ FloatComplexMatrix::ltsolve (MatrixType 
                   Array<FloatComplex> z (dim_vector (2 * nc, 1));
                   FloatComplex *pz = z.fortran_vec ();
                   Array<float> rz (dim_vector (nc, 1));
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (ctrcon, CTRCON, (F77_CONST_CHAR_ARG2 (&norm, 1),
                                              F77_CONST_CHAR_ARG2 (&uplo, 1),
                                              F77_CONST_CHAR_ARG2 (&dia, 1),
-                                             nr, tmp_data, nr, rcon,
-                                             pz, prz, info
+                                             nr, F77_CONST_CMPLX_ARG (tmp_data), nr, rcon,
+                                             F77_CMPLX_ARG (pz), prz, info
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
@@ -2058,17 +2058,17 @@ FloatComplexMatrix::fsolve (MatrixType &
           char job = 'L';
 
           FloatComplexMatrix atmp = *this;
           FloatComplex *tmp_data = atmp.fortran_vec ();
 
           anorm = atmp.abs().sum().row(static_cast<octave_idx_type>(0)).max();
 
           F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 (&job, 1), nr,
-                                     tmp_data, nr, info
+                                     F77_CMPLX_ARG (tmp_data), nr, info
                                      F77_CHAR_ARG_LEN (1)));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
@@ -2080,18 +2080,18 @@ FloatComplexMatrix::fsolve (MatrixType &
               if (calc_cond)
                 {
                   Array<FloatComplex> z (dim_vector (2 * nc, 1));
                   FloatComplex *pz = z.fortran_vec ();
                   Array<float> rz (dim_vector (nc, 1));
                   float *prz = rz.fortran_vec ();
 
                   F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nr, tmp_data, nr, anorm,
-                                             rcon, pz, prz, info
+                                             nr, F77_CMPLX_ARG (tmp_data), nr, anorm,
+                                             rcon, F77_CMPLX_ARG (pz), prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
@@ -2108,18 +2108,18 @@ FloatComplexMatrix::fsolve (MatrixType &
               if (info == 0)
                 {
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   F77_XFCN (cpotrs, CPOTRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nr, b_nc, tmp_data, nr,
-                                             result, b.rows (), info
+                                             nr, b_nc, F77_CMPLX_ARG (tmp_data), nr,
+                                             F77_CMPLX_ARG (result), b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 {
                   mattype.mark_as_unsymmetric ();
                   typ = MatrixType::Full;
                 }
             }
@@ -2145,17 +2145,17 @@ FloatComplexMatrix::fsolve (MatrixType &
             anorm = atmp.abs ().sum ().row (static_cast<octave_idx_type>(0))
                     .max ();
 
           // Work around bug #45577, LAPACK crashes Octave if norm is NaN
           // and bug #46330, segfault with matrices containing Inf & NaN
           if (octave::math::isnan (anorm) || octave::math::isinf (anorm))
             info = -2;
           else
-            F77_XFCN (cgetrf, CGETRF, (nr, nr, tmp_data, nr, pipvt, info));
+            F77_XFCN (cgetrf, CGETRF, (nr, nr, F77_CMPLX_ARG (tmp_data), nr, pipvt, info));
 
           // Throw-away extra info LAPACK gives so as to not change output.
           rcon = 0.0;
           if (info != 0)
             {
               info = -2;
 
               if (sing_handler)
@@ -2168,18 +2168,18 @@ FloatComplexMatrix::fsolve (MatrixType &
           else
             {
               if (calc_cond)
                 {
                   // Now calculate the condition number for
                   // non-singular matrix.
                   char job = '1';
                   F77_XFCN (cgecon, CGECON, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nc, tmp_data, nr, anorm,
-                                             rcon, pz, prz, info
+                                             nc, F77_CMPLX_ARG (tmp_data), nr, anorm,
+                                             rcon, F77_CMPLX_ARG (pz), prz, info
                                              F77_CHAR_ARG_LEN (1)));
 
                   if (info != 0)
                     info = -2;
 
                   volatile float rcond_plus_one = rcon + 1.0;
 
                   if (rcond_plus_one == 1.0 || octave::math::isnan (rcon))
@@ -2197,18 +2197,18 @@ FloatComplexMatrix::fsolve (MatrixType &
                 {
                   retval = b;
                   FloatComplex *result = retval.fortran_vec ();
 
                   octave_idx_type b_nc = b.cols ();
 
                   char job = 'N';
                   F77_XFCN (cgetrs, CGETRS, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                             nr, b_nc, tmp_data, nr,
-                                             pipvt, result, b.rows (), info
+                                             nr, b_nc, F77_CMPLX_ARG (tmp_data), nr,
+                                             pipvt, F77_CMPLX_ARG (result), b.rows (), info
                                              F77_CHAR_ARG_LEN (1)));
                 }
               else
                 mattype.mark_as_rectangular ();
             }
         }
 
       if (octave::math::isinf (anorm))
@@ -2657,18 +2657,18 @@ FloatComplexMatrix::lssolve (const Float
       float *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
-      F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-                                 ps, rcon, rank, work.fortran_vec (),
+      F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m, F77_CMPLX_ARG (pretval), maxmn,
+                                 ps, rcon, rank, F77_CMPLX_ARG (work.fortran_vec ()),
                                  lwork, prwork, piwork, info));
 
       // The workspace query is broken in at least LAPACK 3.0.0
       // through 3.1.1 when n >= mnthr.  The obtuse formula below
       // should provide sufficient workspace for ZGELSD to operate
       // efficiently.
       if (n > m && n >= mnthr)
         {
@@ -2694,19 +2694,19 @@ FloatComplexMatrix::lssolve (const Float
 
           if (std::real (work(0)) < lworkaround)
             work(0) = lworkaround;
         }
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
       work.resize (dim_vector (lwork, 1));
 
-      F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval,
+      F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m, F77_CMPLX_ARG (pretval),
                                  maxmn, ps, rcon, rank,
-                                 work.fortran_vec (), lwork,
+                                 F77_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  prwork, piwork, info));
 
       if (s.elem (0) == 0.0)
         rcon = 0.0;
       else
         rcon = s.elem (minmn - 1) / s.elem (0);
 
       retval.resize (n, nrhs);
@@ -2848,28 +2848,28 @@ FloatComplexMatrix::lssolve (const Float
       float *prwork = rwork.fortran_vec ();
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<octave_idx_type> iwork (dim_vector (liwork, 1));
       octave_idx_type* piwork = iwork.fortran_vec ();
 
-      F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval, maxmn,
-                                 ps, rcon, rank, work.fortran_vec (),
+      F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m, F77_CMPLX_ARG (pretval), maxmn,
+                                 ps, rcon, rank, F77_CMPLX_ARG (work.fortran_vec ()),
                                  lwork, prwork, piwork, info));
 
       lwork = static_cast<octave_idx_type> (std::real (work(0)));
       work.resize (dim_vector (lwork, 1));
       rwork.resize (dim_vector (static_cast<octave_idx_type> (rwork(0)), 1));
       iwork.resize (dim_vector (iwork(0), 1));
 
-      F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, tmp_data, m, pretval,
+      F77_XFCN (cgelsd, CGELSD, (m, n, nrhs, F77_CMPLX_ARG (tmp_data), m, F77_CMPLX_ARG (pretval),
                                  maxmn, ps, rcon, rank,
-                                 work.fortran_vec (), lwork,
+                                 F77_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  prwork, piwork, info));
 
       if (rank < minmn)
         {
           if (s.elem (0) == 0.0)
             rcon = 0.0;
           else
             rcon = s.elem (minmn - 1) / s.elem (0);
@@ -2908,18 +2908,18 @@ operator * (const FloatComplexColumnVect
     {
       octave_idx_type a_len = a.numel ();
 
       retval = FloatComplexMatrix (len, a_len);
       FloatComplex *c = retval.fortran_vec ();
 
       F77_XFCN (cgemm, CGEMM, (F77_CONST_CHAR_ARG2 ("N", 1),
                                F77_CONST_CHAR_ARG2 ("N", 1),
-                               len, a_len, 1, 1.0, v.data (), len,
-                               a.data (), 1, 0.0, c, len
+                               len, a_len, 1, 1.0, F77_CONST_CMPLX_ARG (v.data ()), len,
+                               F77_CONST_CMPLX_ARG (a.data ()), 1, 0.0, F77_CMPLX_ARG (c), len
                                F77_CHAR_ARG_LEN (1)
                                F77_CHAR_ARG_LEN (1)));
     }
 
   return retval;
 }
 
 // matrix by diagonal matrix -> matrix operations
@@ -3490,17 +3490,17 @@ operator >> (std::istream& is, FloatComp
 }
 
 FloatComplexMatrix
 Givens (const FloatComplex& x, const FloatComplex& y)
 {
   float cc;
   FloatComplex cs, temp_r;
 
-  F77_FUNC (clartg, CLARTG) (x, y, cc, cs, temp_r);
+  F77_FUNC (clartg, CLARTG) (F77_CONST_CMPLX_ARG (&x), F77_CONST_CMPLX_ARG (&y), cc, F77_CMPLX_ARG (&cs), F77_CMPLX_ARG (&temp_r));
 
   FloatComplexMatrix g (2, 2);
 
   g.elem (0, 0) = cc;
   g.elem (1, 1) = cc;
   g.elem (0, 1) = cs;
   g.elem (1, 0) = -conj (cs);
 
@@ -3541,18 +3541,18 @@ Sylvester (const FloatComplexMatrix& a, 
   octave_idx_type info;
 
   FloatComplex *pa = sch_a.fortran_vec ();
   FloatComplex *pb = sch_b.fortran_vec ();
   FloatComplex *px = cx.fortran_vec ();
 
   F77_XFCN (ctrsyl, CTRSYL, (F77_CONST_CHAR_ARG2 ("N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
-                             1, a_nr, b_nr, pa, a_nr, pb,
-                             b_nr, px, a_nr, scale, info
+                             1, a_nr, b_nr, F77_CMPLX_ARG (pa), a_nr, F77_CMPLX_ARG (pb),
+                             b_nr, F77_CMPLX_ARG (px), a_nr, scale, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   // FIXME: check info?
 
   retval = ua * cx * ub.hermitian ();
 
   return retval;
@@ -3642,29 +3642,29 @@ xgemm (const FloatComplexMatrix& a, cons
       FloatComplex *c = retval.fortran_vec ();
 
       const char ctra = get_blas_trans_arg (tra, cja);
       if (cja || cjb)
         {
           F77_XFCN (cherk, CHERK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                    F77_CONST_CHAR_ARG2 (&ctra, 1),
                                    a_nr, a_nc, 1.0,
-                                   a.data (), lda, 0.0, c, a_nr
+                                   F77_CONST_CMPLX_ARG (a.data ()), lda, 0.0, F77_CMPLX_ARG (c), a_nr
                                    F77_CHAR_ARG_LEN (1)
                                    F77_CHAR_ARG_LEN (1)));
           for (octave_idx_type j = 0; j < a_nr; j++)
             for (octave_idx_type i = 0; i < j; i++)
               retval.xelem (j,i) = std::conj (retval.xelem (i,j));
         }
       else
         {
           F77_XFCN (csyrk, CSYRK, (F77_CONST_CHAR_ARG2 ("U", 1),
                                    F77_CONST_CHAR_ARG2 (&ctra, 1),
                                    a_nr, a_nc, 1.0,
-                                   a.data (), lda, 0.0, c, a_nr
+                                   F77_CONST_CMPLX_ARG (a.data ()), lda, 0.0, F77_CMPLX_ARG (c), a_nr
                                    F77_CHAR_ARG_LEN (1)
                                    F77_CHAR_ARG_LEN (1)));
           for (octave_idx_type j = 0; j < a_nr; j++)
             for (octave_idx_type i = 0; i < j; i++)
               retval.xelem (j,i) = retval.xelem (i,j);
 
         }
 
@@ -3678,51 +3678,51 @@ xgemm (const FloatComplexMatrix& a, cons
 
       retval = FloatComplexMatrix (a_nr, b_nc, 0.0);
       FloatComplex *c = retval.fortran_vec ();
 
       if (b_nc == 1 && a_nr == 1)
         {
           if (cja == cjb)
             {
-              F77_FUNC (xcdotu, XCDOTU) (a_nc, a.data (), 1, b.data (), 1,
-                                         *c);
+              F77_FUNC (xcdotu, XCDOTU) (a_nc, F77_CONST_CMPLX_ARG (a.data ()), 1, F77_CONST_CMPLX_ARG (b.data ()), 1,
+                                         F77_CMPLX_ARG (&c));
               if (cja) *c = std::conj (*c);
             }
           else if (cja)
-            F77_FUNC (xcdotc, XCDOTC) (a_nc, a.data (), 1, b.data (), 1,
-                                       *c);
+            F77_FUNC (xcdotc, XCDOTC) (a_nc, F77_CONST_CMPLX_ARG (a.data ()), 1, F77_CONST_CMPLX_ARG (b.data ()), 1,
+                                       F77_CMPLX_ARG (&c));
           else
-            F77_FUNC (xcdotc, XCDOTC) (a_nc, b.data (), 1, a.data (), 1,
-                                       *c);
+            F77_FUNC (xcdotc, XCDOTC) (a_nc, F77_CONST_CMPLX_ARG (b.data ()), 1, F77_CONST_CMPLX_ARG (a.data ()), 1,
+                                       F77_CMPLX_ARG (&c));
         }
       else if (b_nc == 1 && ! cjb)
         {
           const char ctra = get_blas_trans_arg (tra, cja);
           F77_XFCN (cgemv, CGEMV, (F77_CONST_CHAR_ARG2 (&ctra, 1),
-                                   lda, tda, 1.0,  a.data (), lda,
-                                   b.data (), 1, 0.0, c, 1
+                                   lda, tda, 1.0,  F77_CONST_CMPLX_ARG (a.data ()), lda,
+                                   F77_CONST_CMPLX_ARG (b.data ()), 1, 0.0, F77_CMPLX_ARG (c), 1
                                    F77_CHAR_ARG_LEN (1)));
         }
       else if (a_nr == 1 && ! cja && ! cjb)
         {
           const char crevtrb = get_blas_trans_arg (! trb, cjb);
           F77_XFCN (cgemv, CGEMV, (F77_CONST_CHAR_ARG2 (&crevtrb, 1),
-                                   ldb, tdb, 1.0,  b.data (), ldb,
-                                   a.data (), 1, 0.0, c, 1
+                                   ldb, tdb, 1.0,  F77_CONST_CMPLX_ARG (b.data ()), ldb,
+                                   F77_CONST_CMPLX_ARG (a.data ()), 1, 0.0, F77_CMPLX_ARG (c), 1
                                    F77_CHAR_ARG_LEN (1)));
         }
       else
         {
           const char ctra = get_blas_trans_arg (tra, cja);
           const char ctrb = get_blas_trans_arg (trb, cjb);
           F77_XFCN (cgemm, CGEMM, (F77_CONST_CHAR_ARG2 (&ctra, 1),
                                    F77_CONST_CHAR_ARG2 (&ctrb, 1),
-                                   a_nr, b_nc, a_nc, 1.0, a.data (),
-                                   lda, b.data (), ldb, 0.0, c, a_nr
+                                   a_nr, b_nc, a_nc, 1.0, F77_CONST_CMPLX_ARG (a.data ()),
+                                   lda, F77_CONST_CMPLX_ARG (b.data ()), ldb, 0.0, F77_CMPLX_ARG (c), a_nr
                                    F77_CHAR_ARG_LEN (1)
                                    F77_CHAR_ARG_LEN (1)));
         }
     }
 
   return retval;
 }
 
diff --git a/liboctave/array/fCRowVector.cc b/liboctave/array/fCRowVector.cc
--- a/liboctave/array/fCRowVector.cc
+++ b/liboctave/array/fCRowVector.cc
@@ -46,17 +46,17 @@ extern "C"
                            const F77_INT&, const F77_CMPLX*,
                            const F77_INT&, const F77_CMPLX&,
                            F77_CMPLX*, const F77_INT&
                            F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (xcdotu, XCDOTU) (const F77_INT&, const F77_CMPLX*,
                              const F77_INT&, const F77_CMPLX*,
-                             const F77_INT&, F77_CMPLX&);
+                             const F77_INT&, F77_CMPLX*);
 }
 
 // FloatComplex Row Vector class
 
 bool
 FloatComplexRowVector::operator == (const FloatComplexRowVector& a) const
 {
   octave_idx_type len = numel ();
@@ -317,18 +317,18 @@ operator * (const FloatComplexRowVector&
       // Transpose A to form A'*x == (x'*A)'
 
       octave_idx_type ld = a_nr;
 
       retval.resize (a_nc);
       FloatComplex *y = retval.fortran_vec ();
 
       F77_XFCN (cgemv, CGEMV, (F77_CONST_CHAR_ARG2 ("T", 1),
-                               a_nr, a_nc, 1.0, a.data (),
-                               ld, v.data (), 1, 0.0, y, 1
+                               a_nr, a_nc, 1.0, F77_CONST_CMPLX_ARG (a.data ()),
+                               ld, F77_CONST_CMPLX_ARG (v.data ()), 1, 0.0, F77_CMPLX_ARG (y), 1
                                F77_CHAR_ARG_LEN (1)));
     }
 
   return retval;
 }
 
 FloatComplexRowVector
 operator * (const FloatRowVector& v, const FloatComplexMatrix& a)
@@ -429,17 +429,17 @@ operator * (const FloatComplexRowVector&
   octave_idx_type len = v.numel ();
 
   octave_idx_type a_len = a.numel ();
 
   if (len != a_len)
     err_nonconformant ("operator *", len, a_len);
 
   if (len != 0)
-    F77_FUNC (xcdotu, XCDOTU) (len, v.data (), 1, a.data (), 1, retval);
+    F77_FUNC (xcdotu, XCDOTU) (len, F77_CONST_CMPLX_ARG (v.data ()), 1, F77_CONST_CMPLX_ARG (a.data ()), 1, F77_CMPLX_ARG (&retval));
 
   return retval;
 }
 
 // other operations
 
 FloatComplexRowVector
 linspace (const FloatComplex& x1, const FloatComplex& x2, octave_idx_type n)
diff --git a/liboctave/cruft/misc/f77-fcn.h b/liboctave/cruft/misc/f77-fcn.h
--- a/liboctave/cruft/misc/f77-fcn.h
+++ b/liboctave/cruft/misc/f77-fcn.h
@@ -325,22 +325,34 @@ octave_make_cray_const_ftn_ch_dsc (const
 #else
 
 #error "unknown C++ to Fortran calling convention"
 
 #endif
 
 #define F77_DBLE double
 #define F77_REAL float
-#define F77_DBLE_CMPLX Complex
-#define F77_CMPLX FloatComplex
+#define F77_DBLE_CMPLX double _Complex
+#define F77_CMPLX float _Complex
 #define F77_INT octave_idx_type
 #define F77_INT4 int32_t
 #define F77_LOGICAL octave_idx_type
 
+#define F77_CMPLX_ARG(x) \
+  reinterpret_cast<float _Complex *> (x)
+
+#define F77_CONST_CMPLX_ARG(x) \
+  reinterpret_cast<const float _Complex *> (x)
+
+#define F77_DBLE_CMPLX_ARG(x) \
+  reinterpret_cast<double _Complex *> (x)
+
+#define F77_CONST_DBLE_CMPLX_ARG(x) \
+  reinterpret_cast<const double _Complex *> (x)
+
 /* Build a C string local variable CS from the Fortran string parameter S
    declared as F77_CHAR_ARG_DEF(s, len) or F77_CONST_CHAR_ARG_DEF(s, len).
    The string will be cleaned up at the end of the current block.
    Needs to include <cstring> and <vector>.  */
 
 #define F77_CSTRING(s, len, cs) \
  OCTAVE_LOCAL_BUFFER (char, cs, F77_CHAR_ARG_LEN_USE (s, len) + 1); \
  memcpy (cs, F77_CHAR_ARG_USE (s), F77_CHAR_ARG_LEN_USE (s, len)); \
diff --git a/liboctave/numeric/EIG.cc b/liboctave/numeric/EIG.cc
--- a/liboctave/numeric/EIG.cc
+++ b/liboctave/numeric/EIG.cc
@@ -315,32 +315,32 @@ EIG::init (const ComplexMatrix& a, bool 
   Array<double> rwork (dim_vector (lrwork, 1));
   double *prwork = rwork.fortran_vec ();
 
   Complex *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (zgeev, ZGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, tmp_data, n, pw, dummy, idummy,
-                           pv, n, &dummy_work, lwork, prwork, info
+                           n, F77_DBLE_CMPLX_ARG (tmp_data), n, F77_DBLE_CMPLX_ARG (pw), F77_DBLE_CMPLX_ARG (dummy), idummy,
+                           F77_DBLE_CMPLX_ARG (pv), n, F77_DBLE_CMPLX_ARG (&dummy_work), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("zgeev workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work.real ());
   Array<Complex> work (dim_vector (lwork, 1));
   Complex *pwork = work.fortran_vec ();
 
   F77_XFCN (zgeev, ZGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, tmp_data, n, pw, dummy, idummy,
-                           pv, n, pwork, lwork, prwork, info
+                           n, F77_DBLE_CMPLX_ARG (tmp_data), n, F77_DBLE_CMPLX_ARG (pw), F77_DBLE_CMPLX_ARG (dummy), idummy,
+                           F77_DBLE_CMPLX_ARG (pv), n, F77_DBLE_CMPLX_ARG (pwork), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in zgeev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("zgeev failed to converge");
@@ -371,31 +371,31 @@ EIG::hermitian_init (const ComplexMatrix
   Complex dummy_work;
 
   octave_idx_type lrwork = 3*n;
   Array<double> rwork (dim_vector (lrwork, 1));
   double *prwork = rwork.fortran_vec ();
 
   F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
-                           n, tmp_data, n, pwr, &dummy_work, lwork,
+                           n, F77_DBLE_CMPLX_ARG (tmp_data), n, pwr, F77_DBLE_CMPLX_ARG (&dummy_work), lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("zheev workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work.real ());
   Array<Complex> work (dim_vector (lwork, 1));
   Complex *pwork = work.fortran_vec ();
 
   F77_XFCN (zheev, ZHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
-                           n, tmp_data, n, pwr, pwork, lwork, prwork, info
+                           n, F77_DBLE_CMPLX_ARG (tmp_data), n, pwr, F77_DBLE_CMPLX_ARG (pwork), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in zheev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("zheev failed to converge");
@@ -605,17 +605,17 @@ EIG::init (const ComplexMatrix& a, const
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   octave_idx_type info = 0;
 
   ComplexMatrix tmp = b;
   Complex*tmp_data = tmp.fortran_vec ();
 
   F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
-                             n, tmp_data, n,
+                             n, F77_DBLE_CMPLX_ARG (tmp_data), n,
                              info
                              F77_CHAR_ARG_LEN (1)));
 
   if (a.is_hermitian () && b.is_hermitian () && info == 0)
     return hermitian_init (a, b, calc_ev);
 
   ComplexMatrix atmp = a;
   Complex *atmp_data = atmp.fortran_vec ();
@@ -640,34 +640,34 @@ EIG::init (const ComplexMatrix& a, const
   Array<double> rwork (dim_vector (lrwork, 1));
   double *prwork = rwork.fortran_vec ();
 
   Complex *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (zggev, ZGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, atmp_data, n, btmp_data, n,
-                           palpha, pbeta, dummy, idummy,
-                           pv, n, &dummy_work, lwork, prwork, info
+                           n, F77_DBLE_CMPLX_ARG (atmp_data), n, F77_DBLE_CMPLX_ARG (btmp_data), n,
+                           F77_DBLE_CMPLX_ARG (palpha), F77_DBLE_CMPLX_ARG (pbeta), F77_DBLE_CMPLX_ARG (dummy), idummy,
+                           F77_DBLE_CMPLX_ARG (pv), n, F77_DBLE_CMPLX_ARG (&dummy_work), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("zggev workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work.real ());
   Array<Complex> work (dim_vector (lwork, 1));
   Complex *pwork = work.fortran_vec ();
 
   F77_XFCN (zggev, ZGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, atmp_data, n, btmp_data, n,
-                           palpha, pbeta, dummy, idummy,
-                           pv, n, pwork, lwork, prwork, info
+                           n, F77_DBLE_CMPLX_ARG (atmp_data), n, F77_DBLE_CMPLX_ARG (btmp_data), n,
+                           F77_DBLE_CMPLX_ARG (palpha), F77_DBLE_CMPLX_ARG (pbeta), F77_DBLE_CMPLX_ARG (dummy), idummy,
+                           F77_DBLE_CMPLX_ARG (pv), n, F77_DBLE_CMPLX_ARG (pwork), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in zggev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("zggev failed to converge");
@@ -710,35 +710,35 @@ EIG::hermitian_init (const ComplexMatrix
   Complex dummy_work;
 
   octave_idx_type lrwork = 3*n;
   Array<double> rwork (dim_vector (lrwork, 1));
   double *prwork = rwork.fortran_vec ();
 
   F77_XFCN (zhegv, ZHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
-                           n, atmp_data, n,
-                           btmp_data, n,
-                           pwr, &dummy_work, lwork,
+                           n, F77_DBLE_CMPLX_ARG (atmp_data), n,
+                           F77_DBLE_CMPLX_ARG (btmp_data), n,
+                           pwr, F77_DBLE_CMPLX_ARG (&dummy_work), lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("zhegv workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work.real ());
   Array<Complex> work (dim_vector (lwork, 1));
   Complex *pwork = work.fortran_vec ();
 
   F77_XFCN (zhegv, ZHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
-                           n, atmp_data, n,
-                           btmp_data, n,
-                           pwr, pwork, lwork, prwork, info
+                           n, F77_DBLE_CMPLX_ARG (atmp_data), n,
+                           F77_DBLE_CMPLX_ARG (btmp_data), n,
+                           pwr, F77_DBLE_CMPLX_ARG (pwork), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in zhegv");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("zhegv failed to converge");
diff --git a/liboctave/numeric/aepbalance.cc b/liboctave/numeric/aepbalance.cc
--- a/liboctave/numeric/aepbalance.cc
+++ b/liboctave/numeric/aepbalance.cc
@@ -210,17 +210,17 @@ aepbalance<ComplexMatrix>::aepbalance (c
   if (a.rows () != n)
     (*current_liboctave_error_handler) ("aepbalance: requires square matrix");
 
   scale = ColumnVector (n);
 
   octave_idx_type info;
 
   F77_XFCN (zgebal, ZGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1), n,
-                             balanced_mat.fortran_vec (), n, ilo, ihi,
+                             F77_DBLE_CMPLX_ARG (balanced_mat.fortran_vec ()), n, ilo, ihi,
                              scale.fortran_vec (), info
                              F77_CHAR_ARG_LEN (1)));
 }
 
 template <>
 ComplexMatrix
 aepbalance<ComplexMatrix>::balancing_matrix (void) const
 {
@@ -231,17 +231,17 @@ aepbalance<ComplexMatrix>::balancing_mat
 
   octave_idx_type info;
 
   char side = 'R';
 
   F77_XFCN (zgebak, ZGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                              F77_CONST_CHAR_ARG2 (&side, 1),
                              n, ilo, ihi, scale.data (), n,
-                             balancing_mat.fortran_vec (), n, info
+                             F77_DBLE_CMPLX_ARG (balancing_mat.fortran_vec ()), n, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   return balancing_mat;
 }
 
 template <>
 aepbalance<FloatComplexMatrix>::aepbalance (const FloatComplexMatrix& a,
@@ -253,17 +253,17 @@ aepbalance<FloatComplexMatrix>::aepbalan
   if (a.rows () != n)
     (*current_liboctave_error_handler) ("aepbalance: requires square matrix");
 
   scale = FloatColumnVector (n);
 
   octave_idx_type info;
 
   F77_XFCN (cgebal, CGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1), n,
-                             balanced_mat.fortran_vec (), n, ilo, ihi,
+                             F77_CMPLX_ARG (balanced_mat.fortran_vec ()), n, ilo, ihi,
                              scale.fortran_vec (), info
                              F77_CHAR_ARG_LEN (1)));
 }
 
 template <>
 FloatComplexMatrix
 aepbalance<FloatComplexMatrix>::balancing_matrix (void) const
 {
@@ -274,17 +274,17 @@ aepbalance<FloatComplexMatrix>::balancin
 
   octave_idx_type info;
 
   char side = 'R';
 
   F77_XFCN (cgebak, CGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                              F77_CONST_CHAR_ARG2 (&side, 1),
                              n, ilo, ihi, scale.data (), n,
-                             balancing_mat.fortran_vec (), n, info
+                             F77_CMPLX_ARG (balancing_mat.fortran_vec ()), n, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   return balancing_mat;
 }
 
 // Instantiations we need.
 
diff --git a/liboctave/numeric/chol.cc b/liboctave/numeric/chol.cc
--- a/liboctave/numeric/chol.cc
+++ b/liboctave/numeric/chol.cc
@@ -343,21 +343,21 @@ chol2inv_internal (const ComplexMatrix& 
 
   octave_idx_type n = r_nc;
   octave_idx_type info;
 
   ComplexMatrix tmp = r;
 
   if (is_upper)
     F77_XFCN (zpotri, ZPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
-                               tmp.fortran_vec (), n, info
+                               F77_DBLE_CMPLX_ARG (tmp.fortran_vec ()), n, info
                                F77_CHAR_ARG_LEN (1)));
   else
     F77_XFCN (zpotri, ZPOTRI, (F77_CONST_CHAR_ARG2 ("L", 1), n,
-                               tmp.fortran_vec (), n, info
+                               F77_DBLE_CMPLX_ARG (tmp.fortran_vec ()), n, info
                                F77_CHAR_ARG_LEN (1)));
 
   // If someone thinks of a more graceful way of doing this (or
   // faster for that matter :-)), please let me know!
 
   if (n > 1)
     {
       if (is_upper)
@@ -388,21 +388,21 @@ chol2inv_internal (const FloatComplexMat
 
   octave_idx_type n = r_nc;
   octave_idx_type info;
 
   FloatComplexMatrix tmp = r;
 
   if (is_upper)
     F77_XFCN (cpotri, CPOTRI, (F77_CONST_CHAR_ARG2 ("U", 1), n,
-                               tmp.fortran_vec (), n, info
+                               F77_CMPLX_ARG (tmp.fortran_vec ()), n, info
                                F77_CHAR_ARG_LEN (1)));
   else
     F77_XFCN (cpotri, CPOTRI, (F77_CONST_CHAR_ARG2 ("L", 1), n,
-                               tmp.fortran_vec (), n, info
+                               F77_CMPLX_ARG (tmp.fortran_vec ()), n, info
                                F77_CHAR_ARG_LEN (1)));
 
   // If someone thinks of a more graceful way of doing this (or
   // faster for that matter :-)), please let me know!
 
   if (n > 1)
     {
       if (is_upper)
@@ -969,36 +969,36 @@ chol<ComplexMatrix>::init (const Complex
   Complex *h = chol_mat.fortran_vec ();
 
   // Calculate the norm of the matrix, for later use.
   double anorm = 0;
   if (calc_cond)
     anorm = xnorm (a, 1);
 
   if (is_upper)
-    F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, h, n, info
+    F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, F77_DBLE_CMPLX_ARG (h), n, info
                                F77_CHAR_ARG_LEN (1)));
   else
-    F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1), n, h, n, info
+    F77_XFCN (zpotrf, ZPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1), n, F77_DBLE_CMPLX_ARG (h), n, info
                                F77_CHAR_ARG_LEN (1)));
 
   xrcond = 0.0;
   if (info > 0)
     chol_mat.resize (info - 1, info - 1);
   else if (calc_cond)
     {
       octave_idx_type zpocon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
       Array<Complex> z (dim_vector (2*n, 1));
       Complex *pz = z.fortran_vec ();
       Array<double> rz (dim_vector (n, 1));
       double *prz = rz.fortran_vec ();
-      F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
-                                 n, anorm, xrcond, pz, prz, zpocon_info
+      F77_XFCN (zpocon, ZPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, F77_DBLE_CMPLX_ARG (h),
+                                 n, anorm, xrcond, F77_DBLE_CMPLX_ARG (pz), prz, zpocon_info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (zpocon_info != 0)
         info = -1;
     }
 
   return info;
 }
@@ -1013,18 +1013,18 @@ chol<ComplexMatrix>::update (const Compl
 
   if (u.numel () != n)
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
   ComplexColumnVector utmp = u;
 
   OCTAVE_LOCAL_BUFFER (double, rw, n);
 
-  F77_XFCN (zch1up, ZCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             utmp.fortran_vec (), rw));
+  F77_XFCN (zch1up, ZCH1UP, (n, F77_DBLE_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
+                             F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()), rw));
 }
 
 template <>
 octave_idx_type
 chol<ComplexMatrix>::downdate (const ComplexColumnVector& u)
 {
   octave_idx_type info = -1;
 
@@ -1032,18 +1032,18 @@ chol<ComplexMatrix>::downdate (const Com
 
   if (u.numel () != n)
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
   ComplexColumnVector utmp = u;
 
   OCTAVE_LOCAL_BUFFER (double, rw, n);
 
-  F77_XFCN (zch1dn, ZCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             utmp.fortran_vec (), rw, info));
+  F77_XFCN (zch1dn, ZCH1DN, (n, F77_DBLE_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
+                             F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()), rw, info));
 
   return info;
 }
 
 template <>
 octave_idx_type
 chol<ComplexMatrix>::insert_sym (const ComplexColumnVector& u,
                                  octave_idx_type j)
@@ -1058,34 +1058,34 @@ chol<ComplexMatrix>::insert_sym (const C
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
 
   ComplexColumnVector utmp = u;
 
   OCTAVE_LOCAL_BUFFER (double, rw, n);
 
   chol_mat.resize (n+1, n+1);
 
-  F77_XFCN (zchinx, ZCHINX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             j + 1, utmp.fortran_vec (), rw, info));
+  F77_XFCN (zchinx, ZCHINX, (n, F77_DBLE_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
+                             j + 1, F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()), rw, info));
 
   return info;
 }
 
 template <>
 void
 chol<ComplexMatrix>::delete_sym (octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("choldelete: index out of range");
 
   OCTAVE_LOCAL_BUFFER (double, rw, n);
 
-  F77_XFCN (zchdex, ZCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+  F77_XFCN (zchdex, ZCHDEX, (n, F77_DBLE_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
                              j + 1, rw));
 
   chol_mat.resize (n-1, n-1);
 }
 
 template <>
 void
 chol<ComplexMatrix>::shift_sym (octave_idx_type i, octave_idx_type j)
@@ -1093,18 +1093,18 @@ chol<ComplexMatrix>::shift_sym (octave_i
   octave_idx_type n = chol_mat.rows ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
 
   OCTAVE_LOCAL_BUFFER (Complex, w, n);
   OCTAVE_LOCAL_BUFFER (double, rw, n);
 
-  F77_XFCN (zchshx, ZCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             i + 1, j + 1, w, rw));
+  F77_XFCN (zchshx, ZCHSHX, (n, F77_DBLE_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
+                             i + 1, j + 1, F77_DBLE_CMPLX_ARG (w), rw));
 }
 
 #endif
 
 template <>
 octave_idx_type
 chol<FloatComplexMatrix>::init (const FloatComplexMatrix& a, bool upper,
                                 bool calc_cond)
@@ -1140,36 +1140,36 @@ chol<FloatComplexMatrix>::init (const Fl
   FloatComplex *h = chol_mat.fortran_vec ();
 
   // Calculate the norm of the matrix, for later use.
   float anorm = 0;
   if (calc_cond)
     anorm = xnorm (a, 1);
 
   if (is_upper)
-    F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, h, n, info
+    F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("U", 1), n, F77_CMPLX_ARG (h), n, info
                                F77_CHAR_ARG_LEN (1)));
   else
-    F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1), n, h, n, info
+    F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1), n, F77_CMPLX_ARG (h), n, info
                                F77_CHAR_ARG_LEN (1)));
 
   xrcond = 0.0;
   if (info > 0)
     chol_mat.resize (info - 1, info - 1);
   else if (calc_cond)
     {
       octave_idx_type cpocon_info = 0;
 
       // Now calculate the condition number for non-singular matrix.
       Array<FloatComplex> z (dim_vector (2*n, 1));
       FloatComplex *pz = z.fortran_vec ();
       Array<float> rz (dim_vector (n, 1));
       float *prz = rz.fortran_vec ();
-      F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, h,
-                                 n, anorm, xrcond, pz, prz, cpocon_info
+      F77_XFCN (cpocon, CPOCON, (F77_CONST_CHAR_ARG2 ("U", 1), n, F77_CMPLX_ARG (h),
+                                 n, anorm, xrcond, F77_CMPLX_ARG (pz), prz, cpocon_info
                                  F77_CHAR_ARG_LEN (1)));
 
       if (cpocon_info != 0)
         info = -1;
     }
 
   return info;
 }
@@ -1184,18 +1184,18 @@ chol<FloatComplexMatrix>::update (const 
 
   if (u.numel () != n)
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
   FloatComplexColumnVector utmp = u;
 
   OCTAVE_LOCAL_BUFFER (float, rw, n);
 
-  F77_XFCN (cch1up, CCH1UP, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             utmp.fortran_vec (), rw));
+  F77_XFCN (cch1up, CCH1UP, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
+                             F77_CMPLX_ARG (utmp.fortran_vec ()), rw));
 }
 
 template <>
 octave_idx_type
 chol<FloatComplexMatrix>::downdate (const FloatComplexColumnVector& u)
 {
   octave_idx_type info = -1;
 
@@ -1203,18 +1203,18 @@ chol<FloatComplexMatrix>::downdate (cons
 
   if (u.numel () != n)
     (*current_liboctave_error_handler) ("cholupdate: dimension mismatch");
 
   FloatComplexColumnVector utmp = u;
 
   OCTAVE_LOCAL_BUFFER (float, rw, n);
 
-  F77_XFCN (cch1dn, CCH1DN, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             utmp.fortran_vec (), rw, info));
+  F77_XFCN (cch1dn, CCH1DN, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
+                             F77_CMPLX_ARG (utmp.fortran_vec ()), rw, info));
 
   return info;
 }
 
 template <>
 octave_idx_type
 chol<FloatComplexMatrix>::insert_sym (const FloatComplexColumnVector& u,
                                       octave_idx_type j)
@@ -1229,34 +1229,34 @@ chol<FloatComplexMatrix>::insert_sym (co
     (*current_liboctave_error_handler) ("cholinsert: index out of range");
 
   FloatComplexColumnVector utmp = u;
 
   OCTAVE_LOCAL_BUFFER (float, rw, n);
 
   chol_mat.resize (n+1, n+1);
 
-  F77_XFCN (cchinx, CCHINX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             j + 1, utmp.fortran_vec (), rw, info));
+  F77_XFCN (cchinx, CCHINX, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
+                             j + 1, F77_CMPLX_ARG (utmp.fortran_vec ()), rw, info));
 
   return info;
 }
 
 template <>
 void
 chol<FloatComplexMatrix>::delete_sym (octave_idx_type j)
 {
   octave_idx_type n = chol_mat.rows ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("choldelete: index out of range");
 
   OCTAVE_LOCAL_BUFFER (float, rw, n);
 
-  F77_XFCN (cchdex, CCHDEX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
+  F77_XFCN (cchdex, CCHDEX, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
                              j + 1, rw));
 
   chol_mat.resize (n-1, n-1);
 }
 
 template <>
 void
 chol<FloatComplexMatrix>::shift_sym (octave_idx_type i, octave_idx_type j)
@@ -1264,18 +1264,18 @@ chol<FloatComplexMatrix>::shift_sym (oct
   octave_idx_type n = chol_mat.rows ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("cholshift: index out of range");
 
   OCTAVE_LOCAL_BUFFER (FloatComplex, w, n);
   OCTAVE_LOCAL_BUFFER (float, rw, n);
 
-  F77_XFCN (cchshx, CCHSHX, (n, chol_mat.fortran_vec (), chol_mat.rows (),
-                             i + 1, j + 1, w, rw));
+  F77_XFCN (cchshx, CCHSHX, (n, F77_CMPLX_ARG (chol_mat.fortran_vec ()), chol_mat.rows (),
+                             i + 1, j + 1, F77_CMPLX_ARG (w), rw));
 }
 
 #endif
 
 // Instantiations we need.
 
 template class chol<Matrix>;
 
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -121,17 +121,17 @@ extern "C"
                              const F77_INT&, F77_DBLE *, F77_INT&
                              F77_CHAR_ARG_LEN_DECL
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zneupd, ZNEUPD) (const F77_INT&,
                              F77_CONST_CHAR_ARG_DECL,
                              F77_INT*, F77_DBLE_CMPLX*, F77_DBLE_CMPLX*,
-                             const F77_INT&, const F77_DBLE_CMPLX&, F77_DBLE_CMPLX*,
+                             const F77_INT&, const F77_DBLE_CMPLX*, F77_DBLE_CMPLX*,
                              F77_CONST_CHAR_ARG_DECL,
                              const F77_INT&,
                              F77_CONST_CHAR_ARG_DECL,
                              const F77_INT&, const F77_DBLE&,
                              F77_DBLE_CMPLX*, const F77_INT&, F77_DBLE_CMPLX*,
                              const F77_INT&, F77_INT*,
                              F77_INT*, F77_DBLE_CMPLX*, F77_DBLE_CMPLX*,
                              const F77_INT&, F77_DBLE *, F77_INT&
@@ -283,18 +283,18 @@ vector_product (const SparseComplexMatri
 
 static bool
 vector_product (const ComplexMatrix& m, const Complex *x, Complex *y)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.cols ();
 
   F77_XFCN (zgemv, ZGEMV, (F77_CONST_CHAR_ARG2 ("N", 1),
-                           nr, nc, 1.0,  m.data (), nr,
-                           x, 1, 0.0, y, 1
+                           nr, nc, 1.0,  F77_CONST_DBLE_CMPLX_ARG (m.data ()), nr,
+                           F77_CONST_DBLE_CMPLX_ARG (x), 1, 0.0, F77_DBLE_CMPLX_ARG (y), 1
                            F77_CHAR_ARG_LEN (1)));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler) ("eigs: unrecoverable error in zgemv");
 
   return true;
 }
 
@@ -2576,18 +2576,18 @@ EigsComplexNonSymmetricMatrix (const M& 
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do
     {
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
-         k, tol, presid, p, v, n, iparam,
-         ipntr, workd, workl, lwork, rwork, info
+         k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n, iparam,
+         ipntr, F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in znaupd");
 
       if (disp > 0 && ! octave::math::isnan (workl[iptr (5)-1]))
         {
@@ -2652,20 +2652,20 @@ EigsComplexNonSymmetricMatrix (const M& 
   Complex *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, workev, 2 * p);
 
   F77_FUNC (zneupd, ZNEUPD)
-    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma, workev,
+    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, F77_DBLE_CMPLX_ARG (d), F77_DBLE_CMPLX_ARG (z), n, F77_CONST_DBLE_CMPLX_ARG (&sigma), F77_DBLE_CMPLX_ARG (workev),
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
-     k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, rwork, info2
+     k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n, iparam, ipntr, F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler)
       ("eigs: unrecoverable exception encountered in zneupd");
 
   if (info2 == 0)
     {
@@ -2832,18 +2832,18 @@ EigsComplexNonSymmetricMatrixShift (cons
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do
     {
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
-         k, tol, presid, p, v, n, iparam,
-         ipntr, workd, workl, lwork, rwork, info
+         k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n, iparam,
+         ipntr, F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in znaupd");
 
       if (disp > 0 && ! octave::math::isnan(workl[iptr(5)-1]))
         {
@@ -2954,20 +2954,20 @@ EigsComplexNonSymmetricMatrixShift (cons
   Complex *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, workev, 2 * p);
 
   F77_FUNC (zneupd, ZNEUPD)
-    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma, workev,
+    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, F77_DBLE_CMPLX_ARG (d), F77_DBLE_CMPLX_ARG (z), n, F77_CONST_DBLE_CMPLX_ARG (&sigma), F77_DBLE_CMPLX_ARG (workev),
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
-     k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, rwork, info2
+     k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n, iparam, ipntr, F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler)
       ("eigs: unrecoverable exception encountered in zneupd");
 
   if (info2 == 0)
     {
@@ -3117,18 +3117,18 @@ EigsComplexNonSymmetricFunc (EigsComplex
   OCTAVE_LOCAL_BUFFER (double, rwork, p);
   Complex *presid = cresid.fortran_vec ();
 
   do
     {
       F77_FUNC (znaupd, ZNAUPD)
         (ido, F77_CONST_CHAR_ARG2 (&bmat, 1), n,
          F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
-         k, tol, presid, p, v, n, iparam,
-         ipntr, workd, workl, lwork, rwork, info
+         k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n, iparam,
+         ipntr, F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork, info
          F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
       if (f77_exception_encountered)
         (*current_liboctave_error_handler)
           ("eigs: unrecoverable exception encountered in znaupd");
 
       if (disp > 0 && ! octave::math::isnan(workl[iptr(5)-1]))
         {
@@ -3194,20 +3194,20 @@ EigsComplexNonSymmetricFunc (EigsComplex
   Complex *z = eig_vec.fortran_vec ();
 
   eig_val.resize (k+1);
   Complex *d = eig_val.fortran_vec ();
 
   OCTAVE_LOCAL_BUFFER (Complex, workev, 2 * p);
 
   F77_FUNC (zneupd, ZNEUPD)
-    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, d, z, n, sigma, workev,
+    (rvec, F77_CONST_CHAR_ARG2 ("A", 1), sel, F77_DBLE_CMPLX_ARG (d), F77_DBLE_CMPLX_ARG (z), n, F77_DBLE_CMPLX_ARG (&sigma), F77_DBLE_CMPLX_ARG (workev),
      F77_CONST_CHAR_ARG2 (&bmat, 1), n,
      F77_CONST_CHAR_ARG2 ((typ.c_str ()), 2),
-     k, tol, presid, p, v, n, iparam, ipntr, workd, workl, lwork, rwork, info2
+     k, tol, F77_DBLE_CMPLX_ARG (presid), p, F77_DBLE_CMPLX_ARG (v), n, iparam, ipntr, F77_DBLE_CMPLX_ARG (workd), F77_DBLE_CMPLX_ARG (workl), lwork, rwork, info2
      F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(1) F77_CHAR_ARG_LEN(2));
 
   if (f77_exception_encountered)
     (*current_liboctave_error_handler)
       ("eigs: unrecoverable exception encountered in zneupd");
 
   if (info2 == 0)
     {
diff --git a/liboctave/numeric/fEIG.cc b/liboctave/numeric/fEIG.cc
--- a/liboctave/numeric/fEIG.cc
+++ b/liboctave/numeric/fEIG.cc
@@ -311,32 +311,32 @@ FloatEIG::init (const FloatComplexMatrix
   Array<float> rwork (dim_vector (lrwork, 1));
   float *prwork = rwork.fortran_vec ();
 
   FloatComplex *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (cgeev, CGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, tmp_data, n, pw, dummy, idummy,
-                           pv, n, &dummy_work, lwork, prwork, info
+                           n, F77_CMPLX_ARG (tmp_data), n, F77_CMPLX_ARG (pw), F77_CMPLX_ARG (dummy), idummy,
+                           F77_CMPLX_ARG (pv), n, F77_CMPLX_ARG (&dummy_work), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("cgeev workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work.real ());
   Array<FloatComplex> work (dim_vector (lwork, 1));
   FloatComplex *pwork = work.fortran_vec ();
 
   F77_XFCN (cgeev, CGEEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, tmp_data, n, pw, dummy, idummy,
-                           pv, n, pwork, lwork, prwork, info
+                           n, F77_CMPLX_ARG (tmp_data), n, F77_CMPLX_ARG (pw), F77_CMPLX_ARG (dummy), idummy,
+                           F77_CMPLX_ARG (pv), n, F77_CMPLX_ARG (pwork), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in cgeev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("cgeev failed to converge");
@@ -367,31 +367,31 @@ FloatEIG::hermitian_init (const FloatCom
   FloatComplex dummy_work;
 
   octave_idx_type lrwork = 3*n;
   Array<float> rwork (dim_vector (lrwork, 1));
   float *prwork = rwork.fortran_vec ();
 
   F77_XFCN (cheev, CHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
-                           n, tmp_data, n, pwr, &dummy_work, lwork,
+                           n, F77_CMPLX_ARG (tmp_data), n, pwr, F77_CMPLX_ARG (&dummy_work), lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("cheev workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work.real ());
   Array<FloatComplex> work (dim_vector (lwork, 1));
   FloatComplex *pwork = work.fortran_vec ();
 
   F77_XFCN (cheev, CHEEV, (F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
-                           n, tmp_data, n, pwr, pwork, lwork, prwork, info
+                           n, F77_CMPLX_ARG (tmp_data), n, pwr, F77_CMPLX_ARG (pwork), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in cheev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("cheev failed to converge");
@@ -602,17 +602,17 @@ FloatEIG::init (const FloatComplexMatrix
     (*current_liboctave_error_handler) ("EIG requires same size matrices");
 
   octave_idx_type info = 0;
 
   FloatComplexMatrix tmp = b;
   FloatComplex *tmp_data = tmp.fortran_vec ();
 
   F77_XFCN (cpotrf, CPOTRF, (F77_CONST_CHAR_ARG2 ("L", 1),
-                             n, tmp_data, n,
+                             n, F77_CMPLX_ARG (tmp_data), n,
                              info
                              F77_CHAR_ARG_LEN (1)));
 
   if (a.is_hermitian () && b.is_hermitian () && info == 0)
     return hermitian_init (a, b, calc_ev);
 
   FloatComplexMatrix atmp = a;
   FloatComplex *atmp_data = atmp.fortran_vec ();
@@ -637,34 +637,34 @@ FloatEIG::init (const FloatComplexMatrix
   Array<float> rwork (dim_vector (lrwork, 1));
   float *prwork = rwork.fortran_vec ();
 
   FloatComplex *dummy = 0;
   octave_idx_type idummy = 1;
 
   F77_XFCN (cggev, CGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, atmp_data, n, btmp_data, n,
-                           palpha, pbeta, dummy, idummy,
-                           pv, n, &dummy_work, lwork, prwork, info
+                           n, F77_CMPLX_ARG (atmp_data), n, F77_CMPLX_ARG (btmp_data), n,
+                           F77_CMPLX_ARG (palpha), F77_CMPLX_ARG (pbeta), F77_CMPLX_ARG (dummy), idummy,
+                           F77_CMPLX_ARG (pv), n, F77_CMPLX_ARG (&dummy_work), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("cggev workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work.real ());
   Array<FloatComplex> work (dim_vector (lwork, 1));
   FloatComplex *pwork = work.fortran_vec ();
 
   F77_XFCN (cggev, CGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
-                           n, atmp_data, n, btmp_data, n,
-                           palpha, pbeta, dummy, idummy,
-                           pv, n, pwork, lwork, prwork, info
+                           n, F77_CMPLX_ARG (atmp_data), n, F77_CMPLX_ARG (btmp_data), n,
+                           F77_CMPLX_ARG (palpha), F77_CMPLX_ARG (pbeta), F77_CMPLX_ARG (dummy), idummy,
+                           F77_CMPLX_ARG (pv), n, F77_CMPLX_ARG (pwork), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in cggev");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("cggev failed to converge");
@@ -707,35 +707,35 @@ FloatEIG::hermitian_init (const FloatCom
   FloatComplex dummy_work;
 
   octave_idx_type lrwork = 3*n;
   Array<float> rwork (dim_vector (lrwork, 1));
   float *prwork = rwork.fortran_vec ();
 
   F77_XFCN (chegv, CHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
-                           n, atmp_data, n,
-                           btmp_data, n,
-                           pwr, &dummy_work, lwork,
+                           n, F77_CMPLX_ARG (atmp_data), n,
+                           F77_CMPLX_ARG (btmp_data), n,
+                           pwr, F77_CMPLX_ARG (&dummy_work), lwork,
                            prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("zhegv workspace query failed");
 
   lwork = static_cast<octave_idx_type> (dummy_work.real ());
   Array<FloatComplex> work (dim_vector (lwork, 1));
   FloatComplex *pwork = work.fortran_vec ();
 
   F77_XFCN (chegv, CHEGV, (1, F77_CONST_CHAR_ARG2 (calc_ev ? "V" : "N", 1),
                            F77_CONST_CHAR_ARG2 ("U", 1),
-                           n, atmp_data, n,
-                           btmp_data, n,
-                           pwr, pwork, lwork, prwork, info
+                           n, F77_CMPLX_ARG (atmp_data), n,
+                           F77_CMPLX_ARG (btmp_data), n,
+                           pwr, F77_CMPLX_ARG (pwork), lwork, prwork, info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in zhegv");
 
   if (info > 0)
     (*current_liboctave_error_handler) ("zhegv failed to converge");
diff --git a/liboctave/numeric/gepbalance.cc b/liboctave/numeric/gepbalance.cc
--- a/liboctave/numeric/gepbalance.cc
+++ b/liboctave/numeric/gepbalance.cc
@@ -258,17 +258,17 @@ gepbalance<ComplexMatrix>::init (const C
   balanced_mat = a;
   Complex *p_balanced_mat = balanced_mat.fortran_vec ();
   balanced_mat2 = b;
   Complex *p_balanced_mat2 = balanced_mat2.fortran_vec ();
 
   char job = balance_job[0];
 
   F77_XFCN (zggbal, ZGGBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
-                             n, p_balanced_mat, n, p_balanced_mat2,
+                             n, F77_DBLE_CMPLX_ARG (p_balanced_mat), n, F77_DBLE_CMPLX_ARG (p_balanced_mat2),
                              n, ilo, ihi, plscale, prscale, pwork, info
                              F77_CHAR_ARG_LEN (1)));
 
   balancing_mat = Matrix (n, n, 0.0);
   balancing_mat2 = Matrix (n, n, 0.0);
   for (octave_idx_type i = 0; i < n; i++)
     {
       octave_quit ();
@@ -327,18 +327,18 @@ gepbalance<FloatComplexMatrix>::init (co
   balanced_mat = a;
   FloatComplex *p_balanced_mat = balanced_mat.fortran_vec ();
   balanced_mat2 = b;
   FloatComplex *p_balanced_mat2 = balanced_mat2.fortran_vec ();
 
   char job = balance_job[0];
 
   F77_XFCN (cggbal, CGGBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
-                             n, p_balanced_mat, n, p_balanced_mat2,
-                             n, ilo, ihi, plscale,prscale, pwork, info
+                             n, F77_CMPLX_ARG (p_balanced_mat), n, F77_CMPLX_ARG (p_balanced_mat2),
+                             n, ilo, ihi, plscale, prscale, pwork, info
                              F77_CHAR_ARG_LEN (1)));
 
   balancing_mat = FloatMatrix (n, n, 0.0);
   balancing_mat2 = FloatMatrix (n, n, 0.0);
   for (octave_idx_type i = 0; i < n; i++)
     {
       octave_quit ();
       balancing_mat.elem (i ,i) = 1.0;
diff --git a/liboctave/numeric/hess.cc b/liboctave/numeric/hess.cc
--- a/liboctave/numeric/hess.cc
+++ b/liboctave/numeric/hess.cc
@@ -300,36 +300,36 @@ hess<ComplexMatrix>::init (const Complex
 
   hess_mat = a;
   Complex *h = hess_mat.fortran_vec ();
 
   Array<double> scale (dim_vector (n, 1));
   double *pscale = scale.fortran_vec ();
 
   F77_XFCN (zgebal, ZGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
-                             n, h, n, ilo, ihi, pscale, info
+                             n, F77_DBLE_CMPLX_ARG (h), n, ilo, ihi, pscale, info
                              F77_CHAR_ARG_LEN (1)));
 
   Array<Complex> tau (dim_vector (n-1, 1));
   Complex *ptau = tau.fortran_vec ();
 
   Array<Complex> work (dim_vector (lwork, 1));
   Complex *pwork = work.fortran_vec ();
 
-  F77_XFCN (zgehrd, ZGEHRD, (n, ilo, ihi, h, n, ptau, pwork, lwork, info));
+  F77_XFCN (zgehrd, ZGEHRD, (n, ilo, ihi, F77_DBLE_CMPLX_ARG (h), n, F77_DBLE_CMPLX_ARG (ptau), F77_DBLE_CMPLX_ARG (pwork), lwork, info));
 
   unitary_hess_mat = hess_mat;
   Complex *z = unitary_hess_mat.fortran_vec ();
 
-  F77_XFCN (zunghr, ZUNGHR, (n, ilo, ihi, z, n, ptau, pwork,
+  F77_XFCN (zunghr, ZUNGHR, (n, ilo, ihi, F77_DBLE_CMPLX_ARG (z), n, F77_DBLE_CMPLX_ARG (ptau), F77_DBLE_CMPLX_ARG (pwork),
                              lwork, info));
 
   F77_XFCN (zgebak, ZGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                              F77_CONST_CHAR_ARG2 (&side, 1),
-                             n, ilo, ihi, pscale, n, z, n, info
+                             n, ilo, ihi, pscale, n, F77_DBLE_CMPLX_ARG (z), n, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   // If someone thinks of a more graceful way of
   // doing this (or faster for that matter :-)),
   // please let me know!
 
   if (n > 2)
@@ -364,36 +364,36 @@ hess<FloatComplexMatrix>::init (const Fl
 
   hess_mat = a;
   FloatComplex *h = hess_mat.fortran_vec ();
 
   Array<float> scale (dim_vector (n, 1));
   float *pscale = scale.fortran_vec ();
 
   F77_XFCN (cgebal, CGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
-                             n, h, n, ilo, ihi, pscale, info
+                             n, F77_CMPLX_ARG (h), n, ilo, ihi, pscale, info
                              F77_CHAR_ARG_LEN (1)));
 
   Array<FloatComplex> tau (dim_vector (n-1, 1));
   FloatComplex *ptau = tau.fortran_vec ();
 
   Array<FloatComplex> work (dim_vector (lwork, 1));
   FloatComplex *pwork = work.fortran_vec ();
 
-  F77_XFCN (cgehrd, CGEHRD, (n, ilo, ihi, h, n, ptau, pwork, lwork, info));
+  F77_XFCN (cgehrd, CGEHRD, (n, ilo, ihi, F77_CMPLX_ARG (h), n, F77_CMPLX_ARG (ptau), F77_CMPLX_ARG (pwork), lwork, info));
 
   unitary_hess_mat = hess_mat;
   FloatComplex *z = unitary_hess_mat.fortran_vec ();
 
-  F77_XFCN (cunghr, CUNGHR, (n, ilo, ihi, z, n, ptau, pwork,
+  F77_XFCN (cunghr, CUNGHR, (n, ilo, ihi, F77_CMPLX_ARG (z), n, F77_CMPLX_ARG (ptau), F77_CMPLX_ARG (pwork),
                              lwork, info));
 
   F77_XFCN (cgebak, CGEBAK, (F77_CONST_CHAR_ARG2 (&job, 1),
                              F77_CONST_CHAR_ARG2 (&side, 1),
-                             n, ilo, ihi, pscale, n, z, n, info
+                             n, ilo, ihi, pscale, n, F77_CMPLX_ARG (z), n, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   // If someone thinks of a more graceful way of
   // doing this (or faster for that matter :-)),
   // please let me know!
 
   if (n > 2)
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -79,62 +79,61 @@ extern "C"
 
   F77_RET_T
   F77_FUNC (zbesh, ZBESH) (const F77_DBLE&, const F77_DBLE&, const F77_DBLE&,
                            const F77_INT&, const F77_INT&,
                            const F77_INT&, F77_DBLE*, F77_DBLE*,
                            F77_INT&, F77_INT&);
 
   F77_RET_T
-  F77_FUNC (cbesj, cBESJ) (const F77_CMPLX&, const F77_REAL&,
+  F77_FUNC (cbesj, cBESJ) (const F77_CMPLX*, const F77_REAL&,
                            const F77_INT&, const F77_INT&,
                            F77_CMPLX*, F77_INT&, F77_INT&);
 
   F77_RET_T
-  F77_FUNC (cbesy, CBESY) (const F77_CMPLX&, const F77_REAL&,
+  F77_FUNC (cbesy, CBESY) (const F77_CMPLX*, const F77_REAL&,
                            const F77_INT&, const F77_INT&,
                            F77_CMPLX*, F77_INT&,
                            F77_CMPLX*, F77_INT&);
 
   F77_RET_T
-  F77_FUNC (cbesi, CBESI) (const F77_CMPLX&, const F77_REAL&,
+  F77_FUNC (cbesi, CBESI) (const F77_CMPLX*, const F77_REAL&,
                            const F77_INT&, const F77_INT&,
                            F77_CMPLX*, F77_INT&, F77_INT&);
 
   F77_RET_T
-  F77_FUNC (cbesk, CBESK) (const F77_CMPLX&, const F77_REAL&,
+  F77_FUNC (cbesk, CBESK) (const F77_CMPLX*, const F77_REAL&,
                            const F77_INT&, const F77_INT&,
                            F77_CMPLX*, F77_INT&, F77_INT&);
 
   F77_RET_T
-  F77_FUNC (cbesh, CBESH) (const F77_CMPLX&, const F77_REAL&,
+  F77_FUNC (cbesh, CBESH) (const F77_CMPLX*, const F77_REAL&,
                            const F77_INT&, const F77_INT&,
                            const F77_INT&, F77_CMPLX*,
                            F77_INT&, F77_INT&);
 
   F77_RET_T
   F77_FUNC (zairy, ZAIRY) (const F77_DBLE&, const F77_DBLE&,
                            const F77_INT&, const F77_INT&,
                            F77_DBLE&, F77_DBLE&, F77_INT&,
                            F77_INT&);
 
   F77_RET_T
-  F77_FUNC (cairy, CAIRY) (const F77_REAL&, const F77_REAL&, const F77_INT&,
-                           const F77_INT&, F77_REAL&, F77_REAL&,
+  F77_FUNC (cairy, CAIRY) (const F77_CMPLX*, const F77_INT&,
+                           const F77_INT&, F77_CMPLX*,
                            F77_INT&, F77_INT&);
 
   F77_RET_T
   F77_FUNC (zbiry, ZBIRY) (const F77_DBLE&, const F77_DBLE&,
                            const F77_INT&, const F77_INT&,
                            F77_DBLE&, F77_DBLE&, F77_INT&);
 
   F77_RET_T
-  F77_FUNC (cbiry, CBIRY) (const F77_REAL&, const F77_REAL&, const F77_INT&,
-                           const F77_INT&, F77_REAL&, F77_REAL&,
-                           F77_INT&);
+  F77_FUNC (cbiry, CBIRY) (const F77_CMPLX*, const F77_INT&, const F77_INT&,
+                           const F77_CMPLX*, F77_INT&);
 
   F77_RET_T
   F77_FUNC (xdacosh, XDACOSH) (const F77_DBLE&, F77_DBLE&);
 
   F77_RET_T
   F77_FUNC (xacosh, XACOSH) (const F77_REAL&, F77_REAL&);
 
   F77_RET_T
@@ -1555,17 +1554,17 @@ namespace octave
       FloatComplex retval;
 
       if (alpha >= 0.0)
         {
           FloatComplex y = 0.0;
 
           octave_idx_type nz;
 
-          F77_FUNC (cbesj, CBESJ) (z, alpha, 2, 1, &y, nz, ierr);
+          F77_FUNC (cbesj, CBESJ) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1, F77_CMPLX_ARG (&y), nz, ierr);
 
           if (kode != 2)
             {
               float expz = exp (std::abs (imag (z)));
               y *= expz;
             }
 
           if (imag (z) == 0.0 && real (z) >= 0.0)
@@ -1620,17 +1619,17 @@ namespace octave
           ierr = 0;
 
           if (real (z) == 0.0 && imag (z) == 0.0)
             {
               y = FloatComplex (-octave::numeric_limits<float>::Inf (), 0.0);
             }
           else
             {
-              F77_FUNC (cbesy, CBESY) (z, alpha, 2, 1, &y, nz, &w, ierr);
+              F77_FUNC (cbesy, CBESY) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1, F77_CMPLX_ARG (&y), nz, F77_CMPLX_ARG (&w), ierr);
 
               if (kode != 2)
                 {
                   float expz = exp (std::abs (imag (z)));
                   y *= expz;
                 }
 
               if (imag (z) == 0.0 && real (z) >= 0.0)
@@ -1676,17 +1675,17 @@ namespace octave
       FloatComplex retval;
 
       if (alpha >= 0.0)
         {
           FloatComplex y = 0.0;
 
           octave_idx_type nz;
 
-          F77_FUNC (cbesi, CBESI) (z, alpha, 2, 1, &y, nz, ierr);
+          F77_FUNC (cbesi, CBESI) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1, F77_CMPLX_ARG (&y), nz, ierr);
 
           if (kode != 2)
             {
               float expz = exp (std::abs (real (z)));
               y *= expz;
             }
 
           if (imag (z) == 0.0 && real (z) >= 0.0)
@@ -1738,17 +1737,17 @@ namespace octave
           ierr = 0;
 
           if (real (z) == 0.0 && imag (z) == 0.0)
             {
               y = FloatComplex (octave::numeric_limits<float>::Inf (), 0.0);
             }
           else
             {
-              F77_FUNC (cbesk, CBESK) (z, alpha, 2, 1, &y, nz, ierr);
+              F77_FUNC (cbesk, CBESK) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1, F77_CMPLX_ARG (&y), nz, ierr);
 
               if (kode != 2)
                 {
                   FloatComplex expz = exp (-z);
 
                   float rexpz = real (expz);
                   float iexpz = imag (expz);
 
@@ -1780,17 +1779,17 @@ namespace octave
       FloatComplex retval;
 
       if (alpha >= 0.0)
         {
           FloatComplex y = 0.0;
 
           octave_idx_type nz;
 
-          F77_FUNC (cbesh, CBESH) (z, alpha, 2, 1, 1, &y, nz, ierr);
+          F77_FUNC (cbesh, CBESH) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 1, 1, F77_CMPLX_ARG (&y), nz, ierr);
 
           if (kode != 2)
             {
               FloatComplex expz = exp (FloatComplex (0.0, 1.0) * z);
 
               float rexpz = real (expz);
               float iexpz = imag (expz);
 
@@ -1823,17 +1822,17 @@ namespace octave
       FloatComplex retval;
 
       if (alpha >= 0.0)
         {
           FloatComplex y = 0.0;
 
           octave_idx_type nz;
 
-          F77_FUNC (cbesh, CBESH) (z, alpha, 2, 2, 1, &y, nz, ierr);
+          F77_FUNC (cbesh, CBESH) (F77_CONST_CMPLX_ARG (&z), alpha, 2, 2, 1, F77_CMPLX_ARG (&y), nz, ierr);
 
           if (kode != 2)
             {
               FloatComplex expz = exp (-FloatComplex (0.0, 1.0) * z);
 
               float rexpz = real (expz);
               float iexpz = imag (expz);
 
@@ -2238,74 +2237,72 @@ namespace octave
         retval(i) = biry (z(i), deriv, scaled, ierr(i));
 
       return retval;
     }
 
     FloatComplex
     airy (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr)
     {
-      float ar = 0.0;
-      float ai = 0.0;
+      FloatComplex a;
 
       octave_idx_type nz;
 
-      float zr = z.real ();
-      float zi = z.imag ();
-
       octave_idx_type id = deriv ? 1 : 0;
 
-      F77_FUNC (cairy, CAIRY) (zr, zi, id, 2, ar, ai, nz, ierr);
+      F77_FUNC (cairy, CAIRY) (F77_CONST_CMPLX_ARG (&z), id, 2, F77_CMPLX_ARG (&a), nz, ierr);
+
+      float ar = a.real ();
+      float ai = a.imag ();
 
       if (! scaled)
         {
           FloatComplex expz = exp (- 2.0f / 3.0f * z * sqrt (z));
 
           float rexpz = real (expz);
           float iexpz = imag (expz);
 
           float tmp = ar*rexpz - ai*iexpz;
 
           ai = ar*iexpz + ai*rexpz;
           ar = tmp;
         }
 
-      if (zi == 0.0 && (! scaled || zr >= 0.0))
+      if (z.imag () == 0.0 && (! scaled || z.real () >= 0.0))
         ai = 0.0;
 
       return bessel_return_value (FloatComplex (ar, ai), ierr);
     }
 
     FloatComplex
     biry (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr)
     {
-      float ar = 0.0;
-      float ai = 0.0;
-
-      float zr = z.real ();
-      float zi = z.imag ();
+      FloatComplex a;
 
       octave_idx_type id = deriv ? 1 : 0;
 
-      F77_FUNC (cbiry, CBIRY) (zr, zi, id, 2, ar, ai, ierr);
+      F77_FUNC (cbiry, CBIRY) (F77_CONST_CMPLX_ARG (&z), id, 2, F77_CMPLX_ARG (&a), ierr);
+
+      float ar = a.real ();
+      float ai = a.imag ();
 
       if (! scaled)
         {
           FloatComplex expz = exp (std::abs (real (2.0f / 3.0f * z * sqrt (z))));
 
           float rexpz = real (expz);
           float iexpz = imag (expz);
 
           float tmp = ar*rexpz - ai*iexpz;
 
           ai = ar*iexpz + ai*rexpz;
           ar = tmp;
         }
 
-      if (zi == 0.0 && (! scaled || zr >= 0.0))
+      if (z.imag () == 0.0 && (! scaled || z.real () >= 0.0))
         ai = 0.0;
 
       return bessel_return_value (FloatComplex (ar, ai), ierr);
     }
 
     FloatComplexMatrix
     airy (const FloatComplexMatrix& z, bool deriv, bool scaled,
           Array<octave_idx_type>& ierr)
diff --git a/liboctave/numeric/lu.cc b/liboctave/numeric/lu.cc
--- a/liboctave/numeric/lu.cc
+++ b/liboctave/numeric/lu.cc
@@ -607,17 +607,17 @@ lu<ComplexMatrix>::lu (const ComplexMatr
   ipvt.resize (dim_vector (mn, 1));
   octave_idx_type *pipvt = ipvt.fortran_vec ();
 
   a_fact = a;
   Complex *tmp_data = a_fact.fortran_vec ();
 
   octave_idx_type info = 0;
 
-  F77_XFCN (zgetrf, ZGETRF, (a_nr, a_nc, tmp_data, a_nr, pipvt, info));
+  F77_XFCN (zgetrf, ZGETRF, (a_nr, a_nc, F77_DBLE_CMPLX_ARG (tmp_data), a_nr, pipvt, info));
 
   for (octave_idx_type i = 0; i < mn; i++)
     pipvt[i] -= 1;
 }
 
 #if defined (HAVE_QRUPDATE_LUU)
 
 template <>
@@ -635,18 +635,18 @@ lu<ComplexMatrix>::update (const Complex
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
   if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
   ComplexColumnVector utmp = u;
   ComplexColumnVector vtmp = v;
-  F77_XFCN (zlu1up, ZLU1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
-                             utmp.fortran_vec (), vtmp.fortran_vec ()));
+  F77_XFCN (zlu1up, ZLU1UP, (m, n, F77_DBLE_CMPLX_ARG (l.fortran_vec ()), m, F77_DBLE_CMPLX_ARG (r.fortran_vec ()), k,
+                             F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()), F77_DBLE_CMPLX_ARG (vtmp.fortran_vec ())));
 }
 
 template <>
 void
 lu<ComplexMatrix>::update (const ComplexMatrix& u, const ComplexMatrix& v)
 {
   if (packed ())
     unpack ();
@@ -660,19 +660,19 @@ lu<ComplexMatrix>::update (const Complex
 
   if (u.rows () != m || v.rows () != n || u.cols () != v.cols ())
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
   for (volatile octave_idx_type i = 0; i < u.cols (); i++)
     {
       ComplexColumnVector utmp = u.column (i);
       ComplexColumnVector vtmp = v.column (i);
-      F77_XFCN (zlu1up, ZLU1UP, (m, n, l.fortran_vec (),
-                                 m, r.fortran_vec (), k,
-                                 utmp.fortran_vec (), vtmp.fortran_vec ()));
+      F77_XFCN (zlu1up, ZLU1UP, (m, n, F77_DBLE_CMPLX_ARG (l.fortran_vec ()),
+                                 m, F77_DBLE_CMPLX_ARG (r.fortran_vec ()), k,
+                                 F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()), F77_DBLE_CMPLX_ARG (vtmp.fortran_vec ())));
     }
 }
 
 template <>
 void
 lu<ComplexMatrix>::update_piv (const ComplexColumnVector& u,
                                const ComplexColumnVector& v)
 {
@@ -688,20 +688,20 @@ lu<ComplexMatrix>::update_piv (const Com
 
   if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
   ComplexColumnVector utmp = u;
   ComplexColumnVector vtmp = v;
   OCTAVE_LOCAL_BUFFER (Complex, w, m);
   for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
-  F77_XFCN (zlup1up, ZLUP1UP, (m, n, l.fortran_vec (),
-                               m, r.fortran_vec (), k,
+  F77_XFCN (zlup1up, ZLUP1UP, (m, n, F77_DBLE_CMPLX_ARG (l.fortran_vec ()),
+                               m, F77_DBLE_CMPLX_ARG (r.fortran_vec ()), k,
                                ipvt.fortran_vec (),
-                               utmp.data (), vtmp.data (), w));
+                               F77_CONST_DBLE_CMPLX_ARG (utmp.data ()), F77_CONST_DBLE_CMPLX_ARG (vtmp.data ()), F77_DBLE_CMPLX_ARG (w)));
   for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
 }
 
 template <>
 void
 lu<ComplexMatrix>::update_piv (const ComplexMatrix& u, const ComplexMatrix& v)
 {
   if (packed ())
@@ -718,20 +718,20 @@ lu<ComplexMatrix>::update_piv (const Com
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
   OCTAVE_LOCAL_BUFFER (Complex, w, m);
   for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
   for (volatile octave_idx_type i = 0; i < u.cols (); i++)
     {
       ComplexColumnVector utmp = u.column (i);
       ComplexColumnVector vtmp = v.column (i);
-      F77_XFCN (zlup1up, ZLUP1UP, (m, n, l.fortran_vec (),
-                                   m, r.fortran_vec (), k,
+      F77_XFCN (zlup1up, ZLUP1UP, (m, n, F77_DBLE_CMPLX_ARG (l.fortran_vec ()),
+                                   m, F77_DBLE_CMPLX_ARG (r.fortran_vec ()), k,
                                    ipvt.fortran_vec (),
-                                   utmp.data (), vtmp.data (), w));
+                                   F77_CONST_DBLE_CMPLX_ARG (utmp.data ()), F77_CONST_DBLE_CMPLX_ARG (vtmp.data ()), F77_DBLE_CMPLX_ARG (w)));
     }
   for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
 }
 
 #endif
 
 template <>
 lu<FloatComplexMatrix>::lu (const FloatComplexMatrix& a)
@@ -743,17 +743,17 @@ lu<FloatComplexMatrix>::lu (const FloatC
   ipvt.resize (dim_vector (mn, 1));
   octave_idx_type *pipvt = ipvt.fortran_vec ();
 
   a_fact = a;
   FloatComplex *tmp_data = a_fact.fortran_vec ();
 
   octave_idx_type info = 0;
 
-  F77_XFCN (cgetrf, CGETRF, (a_nr, a_nc, tmp_data, a_nr, pipvt, info));
+  F77_XFCN (cgetrf, CGETRF, (a_nr, a_nc, F77_CMPLX_ARG (tmp_data), a_nr, pipvt, info));
 
   for (octave_idx_type i = 0; i < mn; i++)
     pipvt[i] -= 1;
 }
 
 #if defined (HAVE_QRUPDATE_LUU)
 
 template <>
@@ -770,18 +770,18 @@ lu<FloatComplexMatrix>::update (const Fl
   octave_idx_type m = l.rows ();
   octave_idx_type n = r.columns ();
   octave_idx_type k = l.columns ();
 
   if (u.numel () == m && v.numel () == n)
     {
       FloatComplexColumnVector utmp = u;
       FloatComplexColumnVector vtmp = v;
-      F77_XFCN (clu1up, CLU1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
-                                 utmp.fortran_vec (), vtmp.fortran_vec ()));
+      F77_XFCN (clu1up, CLU1UP, (m, n, F77_CMPLX_ARG (l.fortran_vec ()), m, F77_CMPLX_ARG (r.fortran_vec ()), k,
+                                 F77_CMPLX_ARG (utmp.fortran_vec ()), F77_CMPLX_ARG (vtmp.fortran_vec ())));
     }
   else
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 }
 
 template <>
 void
 lu<FloatComplexMatrix>::update (const FloatComplexMatrix& u,
@@ -799,19 +799,19 @@ lu<FloatComplexMatrix>::update (const Fl
 
   if (u.rows () != m || v.rows () != n || u.cols () != v.cols ())
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
   for (volatile octave_idx_type i = 0; i < u.cols (); i++)
     {
       FloatComplexColumnVector utmp = u.column (i);
       FloatComplexColumnVector vtmp = v.column (i);
-      F77_XFCN (clu1up, CLU1UP, (m, n, l.fortran_vec (),
-                                 m, r.fortran_vec (), k,
-                                 utmp.fortran_vec (), vtmp.fortran_vec ()));
+      F77_XFCN (clu1up, CLU1UP, (m, n, F77_CMPLX_ARG (l.fortran_vec ()),
+                                 m, F77_CMPLX_ARG (r.fortran_vec ()), k,
+                                 F77_CMPLX_ARG (utmp.fortran_vec ()), F77_CMPLX_ARG (vtmp.fortran_vec ())));
     }
 }
 
 template <>
 void
 lu<FloatComplexMatrix>::update_piv (const FloatComplexColumnVector& u,
                                  const FloatComplexColumnVector& v)
 {
@@ -827,20 +827,20 @@ lu<FloatComplexMatrix>::update_piv (cons
 
   if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
   FloatComplexColumnVector utmp = u;
   FloatComplexColumnVector vtmp = v;
   OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
   for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
-  F77_XFCN (clup1up, CLUP1UP, (m, n, l.fortran_vec (),
-                               m, r.fortran_vec (), k,
+  F77_XFCN (clup1up, CLUP1UP, (m, n, F77_CMPLX_ARG (l.fortran_vec ()),
+                               m, F77_CMPLX_ARG (r.fortran_vec ()), k,
                                ipvt.fortran_vec (),
-                               utmp.data (), vtmp.data (), w));
+                               F77_CONST_CMPLX_ARG (utmp.data ()), F77_CONST_CMPLX_ARG (vtmp.data ()), F77_CMPLX_ARG (w)));
   for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
 }
 
 template <>
 void
 lu<FloatComplexMatrix>::update_piv (const FloatComplexMatrix& u,
                                  const FloatComplexMatrix& v)
 {
@@ -858,20 +858,20 @@ lu<FloatComplexMatrix>::update_piv (cons
     (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
   OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
   for (octave_idx_type i = 0; i < m; i++) ipvt(i) += 1; // increment
   for (volatile octave_idx_type i = 0; i < u.cols (); i++)
     {
       FloatComplexColumnVector utmp = u.column (i);
       FloatComplexColumnVector vtmp = v.column (i);
-      F77_XFCN (clup1up, CLUP1UP, (m, n, l.fortran_vec (),
-                                   m, r.fortran_vec (), k,
+      F77_XFCN (clup1up, CLUP1UP, (m, n, F77_CMPLX_ARG (l.fortran_vec ()),
+                                   m, F77_CMPLX_ARG (r.fortran_vec ()), k,
                                    ipvt.fortran_vec (),
-                                   utmp.data (), vtmp.data (), w));
+                                   F77_CONST_CMPLX_ARG (utmp.data ()), F77_CONST_CMPLX_ARG (vtmp.data ()), F77_CMPLX_ARG (w)));
     }
   for (octave_idx_type i = 0; i < m; i++) ipvt(i) -= 1; // decrement
 }
 
 #endif
 
 // Instantiations we need.
 
diff --git a/liboctave/numeric/oct-convn.cc b/liboctave/numeric/oct-convn.cc
--- a/liboctave/numeric/oct-convn.cc
+++ b/liboctave/numeric/oct-convn.cc
@@ -35,48 +35,60 @@ along with Octave; see the file COPYING.
 // 2d convolution with a matrix kernel.
 template <typename T, typename R>
 static void
 convolve_2d (const T *a, octave_idx_type ma, octave_idx_type na,
              const R *b, octave_idx_type mb, octave_idx_type nb,
              T *c, bool inner);
 
 // Forward instances to our Fortran implementations.
-#define FORWARD_IMPL(T, R, f, F) \
+#define FORWARD_IMPL(T_CXX, R_CXX, T, R, T_CAST, T_CONST_CAST, \
+                     R_CONST_CAST, f, F) \
 extern "C" \
 F77_RET_T \
 F77_FUNC (f##conv2o, F##CONV2O) (const F77_INT&, \
                                  const F77_INT&, \
                                  const T*, const F77_INT&, \
                                  const F77_INT&, const R*, T *); \
 \
 extern "C" \
 F77_RET_T \
 F77_FUNC (f##conv2i, F##CONV2I) (const F77_INT&, \
                                  const F77_INT&, \
                                  const T*, const F77_INT&, \
                                  const F77_INT&, const R*, T *); \
 \
 template <> void \
-convolve_2d<T, R> (const T *a, F77_INT ma, F77_INT na, \
-                   const R *b, F77_INT mb, F77_INT nb, \
-                   T *c, bool inner) \
+convolve_2d<T_CXX, R_CXX> (const T_CXX *a, F77_INT ma, F77_INT na, \
+                           const R_CXX *b, F77_INT mb, F77_INT nb, \
+                           T_CXX *c, bool inner) \
 { \
   if (inner) \
-    F77_XFCN (f##conv2i, F##CONV2I, (ma, na, a, mb, nb, b, c)); \
+    F77_XFCN (f##conv2i, F##CONV2I, (ma, na, T_CONST_CAST (a), \
+                                     mb, nb, R_CONST_CAST (b), T_CAST (c))); \
   else \
-    F77_XFCN (f##conv2o, F##CONV2O, (ma, na, a, mb, nb, b, c)); \
+    F77_XFCN (f##conv2o, F##CONV2O, (ma, na, T_CONST_CAST (a), \
+                                     mb, nb, R_CONST_CAST (b), T_CAST (c))); \
 }
 
-FORWARD_IMPL (F77_DBLE, F77_DBLE, d, D)
-FORWARD_IMPL (F77_REAL, F77_REAL, s, S)
-FORWARD_IMPL (F77_DBLE_CMPLX, F77_DBLE_CMPLX, z, Z)
-FORWARD_IMPL (F77_CMPLX, F77_CMPLX, c, C)
-FORWARD_IMPL (F77_DBLE_CMPLX, F77_DBLE, zd, ZD)
-FORWARD_IMPL (F77_CMPLX, F77_REAL, cs, CS)
+FORWARD_IMPL (double, double, F77_DBLE, F77_DBLE, , , , d, D)
+FORWARD_IMPL (float, float, F77_REAL, F77_REAL, , , , s, S)
+
+FORWARD_IMPL (std::complex<double>, std::complex<double>,
+              F77_DBLE_CMPLX, F77_DBLE_CMPLX, F77_DBLE_CMPLX_ARG,
+              F77_CONST_DBLE_CMPLX_ARG, F77_CONST_DBLE_CMPLX_ARG, z, Z)
+FORWARD_IMPL (std::complex<float>, std::complex<float>,
+              F77_CMPLX, F77_CMPLX, F77_CMPLX_ARG,
+              F77_CONST_CMPLX_ARG, F77_CONST_CMPLX_ARG, c, C)
+
+FORWARD_IMPL (std::complex<double>, double,
+              F77_DBLE_CMPLX, F77_DBLE, F77_DBLE_CMPLX_ARG,
+              F77_CONST_DBLE_CMPLX_ARG, , zd, ZD)
+FORWARD_IMPL (std::complex<float>, float, F77_CMPLX, F77_REAL, F77_CMPLX_ARG,
+              F77_CONST_CMPLX_ARG, , cs, CS)
 
 template <typename T, typename R>
 void convolve_nd (const T *a, const dim_vector& ad, const dim_vector& acd,
                   const R *b, const dim_vector& bd, const dim_vector& bcd,
                   T *c, const dim_vector& ccd, int nd, bool inner)
 {
   if (nd == 2)
     convolve_2d<T, R> (a, ad(0), ad(1), b, bd(0), bd(1), c, inner);
diff --git a/liboctave/numeric/qr.cc b/liboctave/numeric/qr.cc
--- a/liboctave/numeric/qr.cc
+++ b/liboctave/numeric/qr.cc
@@ -1357,25 +1357,25 @@ qr<ComplexMatrix>::form (octave_idx_type
           r = afact;
         }
 
       if (m > 0)
         {
           octave_idx_type k = q.columns ();
           // workspace query.
           Complex clwork;
-          F77_XFCN (zungqr, ZUNGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
-                                     &clwork, -1, info));
+          F77_XFCN (zungqr, ZUNGQR, (m, k, min_mn, F77_DBLE_CMPLX_ARG (q.fortran_vec ()), m, F77_DBLE_CMPLX_ARG (tau),
+                                     F77_DBLE_CMPLX_ARG (&clwork), -1, info));
 
           // allocate buffer and do the job.
           octave_idx_type lwork = clwork.real ();
           lwork = std::max (lwork, static_cast<octave_idx_type> (1));
           OCTAVE_LOCAL_BUFFER (Complex, work, lwork);
-          F77_XFCN (zungqr, ZUNGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
-                                     work, lwork, info));
+          F77_XFCN (zungqr, ZUNGQR, (m, k, min_mn, F77_DBLE_CMPLX_ARG (q.fortran_vec ()), m, F77_DBLE_CMPLX_ARG (tau),
+                                     F77_DBLE_CMPLX_ARG (work), lwork, info));
         }
     }
 }
 
 template <>
 void
 qr<ComplexMatrix>::init (const ComplexMatrix& a, type qr_type)
 {
@@ -1390,25 +1390,25 @@ qr<ComplexMatrix>::init (const ComplexMa
   ComplexMatrix afact = a;
   if (m > n && qr_type == qr<ComplexMatrix>::std)
     afact.resize (m, m);
 
   if (m > 0)
     {
       // workspace query.
       Complex clwork;
-      F77_XFCN (zgeqrf, ZGEQRF, (m, n, afact.fortran_vec (), m, tau,
-                                 &clwork, -1, info));
+      F77_XFCN (zgeqrf, ZGEQRF, (m, n, F77_DBLE_CMPLX_ARG (afact.fortran_vec ()), m, F77_DBLE_CMPLX_ARG (tau),
+                                 F77_DBLE_CMPLX_ARG (&clwork), -1, info));
 
       // allocate buffer and do the job.
       octave_idx_type lwork = clwork.real ();
       lwork = std::max (lwork, static_cast<octave_idx_type> (1));
       OCTAVE_LOCAL_BUFFER (Complex, work, lwork);
-      F77_XFCN (zgeqrf, ZGEQRF, (m, n, afact.fortran_vec (), m, tau,
-                                 work, lwork, info));
+      F77_XFCN (zgeqrf, ZGEQRF, (m, n, F77_DBLE_CMPLX_ARG (afact.fortran_vec ()), m, F77_DBLE_CMPLX_ARG (tau),
+                                 F77_DBLE_CMPLX_ARG (work), lwork, info));
     }
 
   form (n, afact, tau, qr_type);
 }
 
 #if defined (HAVE_QRUPDATE)
 
 template <>
@@ -1421,20 +1421,20 @@ qr<ComplexMatrix>::update (const Complex
 
   if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
   ComplexColumnVector utmp = u;
   ComplexColumnVector vtmp = v;
   OCTAVE_LOCAL_BUFFER (Complex, w, k);
   OCTAVE_LOCAL_BUFFER (double, rw, k);
-  F77_XFCN (zqr1up, ZQR1UP, (m, n, k, q.fortran_vec (),
-                             m, r.fortran_vec (), k,
-                             utmp.fortran_vec (), vtmp.fortran_vec (),
-                             w, rw));
+  F77_XFCN (zqr1up, ZQR1UP, (m, n, k, F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
+                             m, F77_DBLE_CMPLX_ARG (r.fortran_vec ()), k,
+                             F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()), F77_DBLE_CMPLX_ARG (vtmp.fortran_vec ()),
+                             F77_DBLE_CMPLX_ARG (w), rw));
 }
 
 template <>
 void
 qr<ComplexMatrix>::update (const ComplexMatrix& u, const ComplexMatrix& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
@@ -1444,20 +1444,20 @@ qr<ComplexMatrix>::update (const Complex
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
   OCTAVE_LOCAL_BUFFER (Complex, w, k);
   OCTAVE_LOCAL_BUFFER (double, rw, k);
   for (volatile octave_idx_type i = 0; i < u.cols (); i++)
     {
       ComplexColumnVector utmp = u.column (i);
       ComplexColumnVector vtmp = v.column (i);
-      F77_XFCN (zqr1up, ZQR1UP, (m, n, k, q.fortran_vec (),
-                                 m, r.fortran_vec (), k,
-                                 utmp.fortran_vec (), vtmp.fortran_vec (),
-                                 w, rw));
+      F77_XFCN (zqr1up, ZQR1UP, (m, n, k, F77_DBLE_CMPLX_ARG (q.fortran_vec ()),
+                                 m, F77_DBLE_CMPLX_ARG (r.fortran_vec ()), k,
+                                 F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()), F77_DBLE_CMPLX_ARG (vtmp.fortran_vec ()),
+                                 F77_DBLE_CMPLX_ARG (w), rw));
     }
 }
 
 template <>
 void
 qr<ComplexMatrix>::insert_col (const ComplexColumnVector& u, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
@@ -1476,19 +1476,19 @@ qr<ComplexMatrix>::insert_col (const Com
     }
   else
     {
       r.resize (k, n+1);
     }
 
   ComplexColumnVector utmp = u;
   OCTAVE_LOCAL_BUFFER (double, rw, k);
-  F77_XFCN (zqrinc, ZQRINC, (m, n, k, q.fortran_vec (), q.rows (),
-                             r.fortran_vec (), r.rows (), j + 1,
-                             utmp.data (), rw));
+  F77_XFCN (zqrinc, ZQRINC, (m, n, k, F77_DBLE_CMPLX_ARG (q.fortran_vec ()), q.rows (),
+                             F77_DBLE_CMPLX_ARG (r.fortran_vec ()), r.rows (), j + 1,
+                             F77_CONST_DBLE_CMPLX_ARG (utmp.data ()), rw));
 }
 
 template <>
 void
 qr<ComplexMatrix>::insert_col (const ComplexMatrix& u, const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
@@ -1522,37 +1522,37 @@ qr<ComplexMatrix>::insert_col (const Com
         }
 
       OCTAVE_LOCAL_BUFFER (double, rw, kmax);
       for (volatile octave_idx_type i = 0; i < js.numel (); i++)
         {
           octave_idx_type ii = i;
           ComplexColumnVector utmp = u.column (jsi(i));
           F77_XFCN (zqrinc, ZQRINC, (m, n + ii, std::min (kmax, k + ii),
-                                     q.fortran_vec (), q.rows (),
-                                     r.fortran_vec (), r.rows (), js(ii) + 1,
-                                     utmp.data (), rw));
+                                     F77_DBLE_CMPLX_ARG (q.fortran_vec ()), q.rows (),
+                                     F77_DBLE_CMPLX_ARG (r.fortran_vec ()), r.rows (), js(ii) + 1,
+                                     F77_CONST_DBLE_CMPLX_ARG (utmp.data ()), rw));
         }
     }
 }
 
 template <>
 void
 qr<ComplexMatrix>::delete_col (octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type k = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
   OCTAVE_LOCAL_BUFFER (double, rw, k);
-  F77_XFCN (zqrdec, ZQRDEC, (m, n, k, q.fortran_vec (), q.rows (),
-                             r.fortran_vec (), r.rows (), j + 1, rw));
+  F77_XFCN (zqrdec, ZQRDEC, (m, n, k, F77_DBLE_CMPLX_ARG (q.fortran_vec ()), q.rows (),
+                             F77_DBLE_CMPLX_ARG (r.fortran_vec ()), r.rows (), j + 1, rw));
 
   if (k < m)
     {
       q.resize (m, k-1);
       r.resize (k-1, n-1);
     }
   else
     {
@@ -1582,18 +1582,18 @@ qr<ComplexMatrix>::delete_col (const Arr
 
   if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (double, rw, k);
       for (volatile octave_idx_type i = 0; i < js.numel (); i++)
         {
           octave_idx_type ii = i;
           F77_XFCN (zqrdec, ZQRDEC, (m, n - ii, k == m ? k : k - ii,
-                                     q.fortran_vec (), q.rows (),
-                                     r.fortran_vec (), r.rows (),
+                                     F77_DBLE_CMPLX_ARG (q.fortran_vec ()), q.rows (),
+                                     F77_DBLE_CMPLX_ARG (r.fortran_vec ()), r.rows (),
                                      js(ii) + 1, rw));
         }
       if (k < m)
         {
           q.resize (m, k - nj);
           r.resize (k - nj, n - nj);
         }
       else
@@ -1616,19 +1616,19 @@ qr<ComplexMatrix>::insert_row (const Com
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
   q.resize (m + 1, m + 1);
   r.resize (m + 1, n);
   ComplexRowVector utmp = u;
   OCTAVE_LOCAL_BUFFER (double, rw, k);
-  F77_XFCN (zqrinr, ZQRINR, (m, n, q.fortran_vec (), q.rows (),
-                             r.fortran_vec (), r.rows (),
-                             j + 1, utmp.fortran_vec (), rw));
+  F77_XFCN (zqrinr, ZQRINR, (m, n, F77_DBLE_CMPLX_ARG (q.fortran_vec ()), q.rows (),
+                             F77_DBLE_CMPLX_ARG (r.fortran_vec ()), r.rows (),
+                             j + 1, F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()), rw));
 
 }
 
 template <>
 void
 qr<ComplexMatrix>::delete_row (octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
@@ -1636,19 +1636,19 @@ qr<ComplexMatrix>::delete_row (octave_id
 
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
   if (j < 0 || j > m-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
   OCTAVE_LOCAL_BUFFER (Complex, w, m);
   OCTAVE_LOCAL_BUFFER (double, rw, m);
-  F77_XFCN (zqrder, ZQRDER, (m, n, q.fortran_vec (), q.rows (),
-                             r.fortran_vec (), r.rows (), j + 1,
-                             w, rw));
+  F77_XFCN (zqrder, ZQRDER, (m, n, F77_DBLE_CMPLX_ARG (q.fortran_vec ()), q.rows (),
+                             F77_DBLE_CMPLX_ARG (r.fortran_vec ()), r.rows (), j + 1,
+                             F77_DBLE_CMPLX_ARG (w), rw));
 
   q.resize (m - 1, m - 1);
   r.resize (m - 1, n);
 }
 
 template <>
 void
 qr<ComplexMatrix>::shift_cols (octave_idx_type i, octave_idx_type j)
@@ -1658,19 +1658,19 @@ qr<ComplexMatrix>::shift_cols (octave_id
   octave_idx_type n = r.columns ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrshift: index out of range");
 
   OCTAVE_LOCAL_BUFFER (Complex, w, k);
   OCTAVE_LOCAL_BUFFER (double, rw, k);
   F77_XFCN (zqrshc, ZQRSHC, (m, n, k,
-                             q.fortran_vec (), q.rows (),
-                             r.fortran_vec (), r.rows (),
-                             i + 1, j + 1, w, rw));
+                             F77_DBLE_CMPLX_ARG (q.fortran_vec ()), q.rows (),
+                             F77_DBLE_CMPLX_ARG (r.fortran_vec ()), r.rows (),
+                             i + 1, j + 1, F77_DBLE_CMPLX_ARG (w), rw));
 }
 
 #endif
 
 template <>
 void
 qr<FloatComplexMatrix>::form (octave_idx_type n, FloatComplexMatrix& afact, FloatComplex *tau, type qr_type)
 {
@@ -1721,25 +1721,25 @@ qr<FloatComplexMatrix>::form (octave_idx
           r = afact;
         }
 
       if (m > 0)
         {
           octave_idx_type k = q.columns ();
           // workspace query.
           FloatComplex clwork;
-          F77_XFCN (cungqr, CUNGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
-                                     &clwork, -1, info));
+          F77_XFCN (cungqr, CUNGQR, (m, k, min_mn, F77_CMPLX_ARG (q.fortran_vec ()), m, F77_CMPLX_ARG (tau),
+                                     F77_CMPLX_ARG (&clwork), -1, info));
 
           // allocate buffer and do the job.
           octave_idx_type lwork = clwork.real ();
           lwork = std::max (lwork, static_cast<octave_idx_type> (1));
           OCTAVE_LOCAL_BUFFER (FloatComplex, work, lwork);
-          F77_XFCN (cungqr, CUNGQR, (m, k, min_mn, q.fortran_vec (), m, tau,
-                                     work, lwork, info));
+          F77_XFCN (cungqr, CUNGQR, (m, k, min_mn, F77_CMPLX_ARG (q.fortran_vec ()), m, F77_CMPLX_ARG (tau),
+                                     F77_CMPLX_ARG (work), lwork, info));
         }
     }
 }
 
 template <>
 void
 qr<FloatComplexMatrix>::init (const FloatComplexMatrix& a, type qr_type)
 {
@@ -1754,25 +1754,25 @@ qr<FloatComplexMatrix>::init (const Floa
   FloatComplexMatrix afact = a;
   if (m > n && qr_type == qr<FloatComplexMatrix>::std)
     afact.resize (m, m);
 
   if (m > 0)
     {
       // workspace query.
       FloatComplex clwork;
-      F77_XFCN (cgeqrf, CGEQRF, (m, n, afact.fortran_vec (), m, tau,
-                                 &clwork, -1, info));
+      F77_XFCN (cgeqrf, CGEQRF, (m, n, F77_CMPLX_ARG (afact.fortran_vec ()), m, F77_CMPLX_ARG (tau),
+                                 F77_CMPLX_ARG (&clwork), -1, info));
 
       // allocate buffer and do the job.
       octave_idx_type lwork = clwork.real ();
       lwork = std::max (lwork, static_cast<octave_idx_type> (1));
       OCTAVE_LOCAL_BUFFER (FloatComplex, work, lwork);
-      F77_XFCN (cgeqrf, CGEQRF, (m, n, afact.fortran_vec (), m, tau,
-                                 work, lwork, info));
+      F77_XFCN (cgeqrf, CGEQRF, (m, n, F77_CMPLX_ARG (afact.fortran_vec ()), m, F77_CMPLX_ARG (tau),
+                                 F77_CMPLX_ARG (work), lwork, info));
     }
 
   form (n, afact, tau, qr_type);
 }
 
 #if defined (HAVE_QRUPDATE)
 
 template <>
@@ -1785,20 +1785,20 @@ qr<FloatComplexMatrix>::update (const Fl
 
   if (u.numel () != m || v.numel () != n)
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
   FloatComplexColumnVector utmp = u;
   FloatComplexColumnVector vtmp = v;
   OCTAVE_LOCAL_BUFFER (FloatComplex, w, k);
   OCTAVE_LOCAL_BUFFER (float, rw, k);
-  F77_XFCN (cqr1up, CQR1UP, (m, n, k, q.fortran_vec (),
-                             m, r.fortran_vec (), k,
-                             utmp.fortran_vec (), vtmp.fortran_vec (),
-                             w, rw));
+  F77_XFCN (cqr1up, CQR1UP, (m, n, k, F77_CMPLX_ARG (q.fortran_vec ()),
+                             m, F77_CMPLX_ARG (r.fortran_vec ()), k,
+                             F77_CMPLX_ARG (utmp.fortran_vec ()), F77_CMPLX_ARG (vtmp.fortran_vec ()),
+                             F77_CMPLX_ARG (w), rw));
 }
 
 template <>
 void
 qr<FloatComplexMatrix>::update (const FloatComplexMatrix& u, const FloatComplexMatrix& v)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
@@ -1808,20 +1808,20 @@ qr<FloatComplexMatrix>::update (const Fl
     (*current_liboctave_error_handler) ("qrupdate: dimensions mismatch");
 
   OCTAVE_LOCAL_BUFFER (FloatComplex, w, k);
   OCTAVE_LOCAL_BUFFER (float, rw, k);
   for (volatile octave_idx_type i = 0; i < u.cols (); i++)
     {
       FloatComplexColumnVector utmp = u.column (i);
       FloatComplexColumnVector vtmp = v.column (i);
-      F77_XFCN (cqr1up, CQR1UP, (m, n, k, q.fortran_vec (),
-                                 m, r.fortran_vec (), k,
-                                 utmp.fortran_vec (), vtmp.fortran_vec (),
-                                 w, rw));
+      F77_XFCN (cqr1up, CQR1UP, (m, n, k, F77_CMPLX_ARG (q.fortran_vec ()),
+                                 m, F77_CMPLX_ARG (r.fortran_vec ()), k,
+                                 F77_CMPLX_ARG (utmp.fortran_vec ()), F77_CMPLX_ARG (vtmp.fortran_vec ()),
+                                 F77_CMPLX_ARG (w), rw));
     }
 }
 
 template <>
 void
 qr<FloatComplexMatrix>::insert_col (const FloatComplexColumnVector& u, octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
@@ -1840,19 +1840,19 @@ qr<FloatComplexMatrix>::insert_col (cons
     }
   else
     {
       r.resize (k, n+1);
     }
 
   FloatComplexColumnVector utmp = u;
   OCTAVE_LOCAL_BUFFER (float, rw, k);
-  F77_XFCN (cqrinc, CQRINC, (m, n, k, q.fortran_vec (), q.rows (),
-                             r.fortran_vec (), r.rows (), j + 1,
-                             utmp.data (), rw));
+  F77_XFCN (cqrinc, CQRINC, (m, n, k, F77_CMPLX_ARG (q.fortran_vec ()), q.rows (),
+                             F77_CMPLX_ARG (r.fortran_vec ()), r.rows (), j + 1,
+                             F77_CONST_CMPLX_ARG (utmp.data ()), rw));
 }
 
 template <>
 void
 qr<FloatComplexMatrix>::insert_col (const FloatComplexMatrix& u, const Array<octave_idx_type>& j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type n = r.columns ();
@@ -1885,37 +1885,37 @@ qr<FloatComplexMatrix>::insert_col (cons
           r.resize (k, n + nj);
         }
 
       OCTAVE_LOCAL_BUFFER (float, rw, kmax);
       for (volatile octave_idx_type i = 0; i < js.numel (); i++)
         {
           octave_idx_type ii = i;
           F77_XFCN (cqrinc, CQRINC, (m, n + ii, std::min (kmax, k + ii),
-                                     q.fortran_vec (), q.rows (),
-                                     r.fortran_vec (), r.rows (), js(ii) + 1,
-                                     u.column (jsi(i)).data (), rw));
+                                     F77_CMPLX_ARG (q.fortran_vec ()), q.rows (),
+                                     F77_CMPLX_ARG (r.fortran_vec ()), r.rows (), js(ii) + 1,
+                                     F77_CONST_CMPLX_ARG (u.column (jsi(i)).data ()), rw));
         }
     }
 }
 
 template <>
 void
 qr<FloatComplexMatrix>::delete_col (octave_idx_type j)
 {
   octave_idx_type m = q.rows ();
   octave_idx_type k = r.rows ();
   octave_idx_type n = r.columns ();
 
   if (j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
   OCTAVE_LOCAL_BUFFER (float, rw, k);
-  F77_XFCN (cqrdec, CQRDEC, (m, n, k, q.fortran_vec (), q.rows (),
-                             r.fortran_vec (), r.rows (), j + 1, rw));
+  F77_XFCN (cqrdec, CQRDEC, (m, n, k, F77_CMPLX_ARG (q.fortran_vec ()), q.rows (),
+                             F77_CMPLX_ARG (r.fortran_vec ()), r.rows (), j + 1, rw));
 
   if (k < m)
     {
       q.resize (m, k-1);
       r.resize (k-1, n-1);
     }
   else
     {
@@ -1945,18 +1945,18 @@ qr<FloatComplexMatrix>::delete_col (cons
 
   if (nj > 0)
     {
       OCTAVE_LOCAL_BUFFER (float, rw, k);
       for (volatile octave_idx_type i = 0; i < js.numel (); i++)
         {
           octave_idx_type ii = i;
           F77_XFCN (cqrdec, CQRDEC, (m, n - ii, k == m ? k : k - ii,
-                                     q.fortran_vec (), q.rows (),
-                                     r.fortran_vec (), r.rows (),
+                                     F77_CMPLX_ARG (q.fortran_vec ()), q.rows (),
+                                     F77_CMPLX_ARG (r.fortran_vec ()), r.rows (),
                                      js(ii) + 1, rw));
         }
       if (k < m)
         {
           q.resize (m, k - nj);
           r.resize (k - nj, n - nj);
         }
       else
@@ -1979,19 +1979,19 @@ qr<FloatComplexMatrix>::insert_row (cons
     (*current_liboctave_error_handler) ("qrinsert: dimensions mismatch");
   if (j < 0 || j > m)
     (*current_liboctave_error_handler) ("qrinsert: index out of range");
 
   q.resize (m + 1, m + 1);
   r.resize (m + 1, n);
   FloatComplexRowVector utmp = u;
   OCTAVE_LOCAL_BUFFER (float, rw, k);
-  F77_XFCN (cqrinr, CQRINR, (m, n, q.fortran_vec (), q.rows (),
-                             r.fortran_vec (), r.rows (),
-                             j + 1, utmp.fortran_vec (), rw));
+  F77_XFCN (cqrinr, CQRINR, (m, n, F77_CMPLX_ARG (q.fortran_vec ()), q.rows (),
+                             F77_CMPLX_ARG (r.fortran_vec ()), r.rows (),
+                             j + 1, F77_CMPLX_ARG (utmp.fortran_vec ()), rw));
 
 }
 
 template <>
 void
 qr<FloatComplexMatrix>::delete_row (octave_idx_type j)
 {
   octave_idx_type m = r.rows ();
@@ -1999,19 +1999,19 @@ qr<FloatComplexMatrix>::delete_row (octa
 
   if (! q.is_square ())
     (*current_liboctave_error_handler) ("qrdelete: dimensions mismatch");
   if (j < 0 || j > m-1)
     (*current_liboctave_error_handler) ("qrdelete: index out of range");
 
   OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
   OCTAVE_LOCAL_BUFFER (float, rw, m);
-  F77_XFCN (cqrder, CQRDER, (m, n, q.fortran_vec (), q.rows (),
-                             r.fortran_vec (), r.rows (), j + 1,
-                             w, rw));
+  F77_XFCN (cqrder, CQRDER, (m, n, F77_CMPLX_ARG (q.fortran_vec ()), q.rows (),
+                             F77_CMPLX_ARG (r.fortran_vec ()), r.rows (), j + 1,
+                             F77_CMPLX_ARG (w), rw));
 
   q.resize (m - 1, m - 1);
   r.resize (m - 1, n);
 }
 
 template <>
 void
 qr<FloatComplexMatrix>::shift_cols (octave_idx_type i, octave_idx_type j)
@@ -2021,19 +2021,19 @@ qr<FloatComplexMatrix>::shift_cols (octa
   octave_idx_type n = r.columns ();
 
   if (i < 0 || i > n-1 || j < 0 || j > n-1)
     (*current_liboctave_error_handler) ("qrshift: index out of range");
 
   OCTAVE_LOCAL_BUFFER (FloatComplex, w, k);
   OCTAVE_LOCAL_BUFFER (float, rw, k);
   F77_XFCN (cqrshc, CQRSHC, (m, n, k,
-                             q.fortran_vec (), q.rows (),
-                             r.fortran_vec (), r.rows (),
-                             i + 1, j + 1, w, rw));
+                             F77_CMPLX_ARG (q.fortran_vec ()), q.rows (),
+                             F77_CMPLX_ARG (r.fortran_vec ()), r.rows (),
+                             i + 1, j + 1, F77_CMPLX_ARG (w), rw));
 }
 
 #endif
 
 // Instantiations we need.
 
 template class qr<Matrix>;
 
diff --git a/liboctave/numeric/qrp.cc b/liboctave/numeric/qrp.cc
--- a/liboctave/numeric/qrp.cc
+++ b/liboctave/numeric/qrp.cc
@@ -215,27 +215,27 @@ qrp<ComplexMatrix>::init (const ComplexM
   MArray<octave_idx_type> jpvt (dim_vector (n, 1), 0);
 
   if (m > 0)
     {
       OCTAVE_LOCAL_BUFFER (double, rwork, 2*n);
 
       // workspace query.
       Complex clwork;
-      F77_XFCN (zgeqp3, ZGEQP3, (m, n, afact.fortran_vec (),
-                                 m, jpvt.fortran_vec (), tau,
-                                 &clwork, -1, rwork, info));
+      F77_XFCN (zgeqp3, ZGEQP3, (m, n, F77_DBLE_CMPLX_ARG (afact.fortran_vec ()),
+                                 m, jpvt.fortran_vec (), F77_DBLE_CMPLX_ARG (tau),
+                                 F77_DBLE_CMPLX_ARG (&clwork), -1, rwork, info));
 
       // allocate buffer and do the job.
       octave_idx_type lwork = clwork.real ();
       lwork = std::max (lwork, static_cast<octave_idx_type> (1));
       OCTAVE_LOCAL_BUFFER (Complex, work, lwork);
-      F77_XFCN (zgeqp3, ZGEQP3, (m, n, afact.fortran_vec (),
-                                 m, jpvt.fortran_vec (), tau,
-                                 work, lwork, rwork, info));
+      F77_XFCN (zgeqp3, ZGEQP3, (m, n, F77_DBLE_CMPLX_ARG (afact.fortran_vec ()),
+                                 m, jpvt.fortran_vec (), F77_DBLE_CMPLX_ARG (tau),
+                                 F77_DBLE_CMPLX_ARG (work), lwork, rwork, info));
     }
   else
     for (octave_idx_type i = 0; i < n; i++) jpvt(i) = i+1;
 
   // Form Permutation matrix (if economy is requested, return the
   // indices only!)
 
   jpvt -= static_cast<octave_idx_type> (1);
@@ -281,27 +281,27 @@ qrp<FloatComplexMatrix>::init (const Flo
   MArray<octave_idx_type> jpvt (dim_vector (n, 1), 0);
 
   if (m > 0)
     {
       OCTAVE_LOCAL_BUFFER (float, rwork, 2*n);
 
       // workspace query.
       FloatComplex clwork;
-      F77_XFCN (cgeqp3, CGEQP3, (m, n, afact.fortran_vec (),
-                                 m, jpvt.fortran_vec (), tau,
-                                 &clwork, -1, rwork, info));
+      F77_XFCN (cgeqp3, CGEQP3, (m, n, F77_CMPLX_ARG (afact.fortran_vec ()),
+                                 m, jpvt.fortran_vec (), F77_CMPLX_ARG (tau),
+                                 F77_CMPLX_ARG (&clwork), -1, rwork, info));
 
       // allocate buffer and do the job.
       octave_idx_type lwork = clwork.real ();
       lwork = std::max (lwork, static_cast<octave_idx_type> (1));
       OCTAVE_LOCAL_BUFFER (FloatComplex, work, lwork);
-      F77_XFCN (cgeqp3, CGEQP3, (m, n, afact.fortran_vec (),
-                                 m, jpvt.fortran_vec (), tau,
-                                 work, lwork, rwork, info));
+      F77_XFCN (cgeqp3, CGEQP3, (m, n, F77_CMPLX_ARG (afact.fortran_vec ()),
+                                 m, jpvt.fortran_vec (), F77_CMPLX_ARG (tau),
+                                 F77_CMPLX_ARG (work), lwork, rwork, info));
     }
   else
     for (octave_idx_type i = 0; i < n; i++) jpvt(i) = i+1;
 
   // Form Permutation matrix (if economy is requested, return the
   // indices only!)
 
   jpvt -= static_cast<octave_idx_type> (1);
diff --git a/liboctave/numeric/schur.cc b/liboctave/numeric/schur.cc
--- a/liboctave/numeric/schur.cc
+++ b/liboctave/numeric/schur.cc
@@ -380,18 +380,18 @@ schur<ComplexMatrix>::init (const Comple
   octave_idx_type ntmp = (ord_char == 'N' || ord_char == 'n') ? 0 : n;
   Array<octave_idx_type> bwork (dim_vector (ntmp, 1));
   octave_idx_type *pbwork = bwork.fortran_vec ();
 
   F77_XFCN (zgeesx, ZGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
                              F77_CONST_CHAR_ARG2 (&sort, 1),
                              selector,
                              F77_CONST_CHAR_ARG2 (&sense, 1),
-                             n, s, n, sdim, pw, q, n, rconde, rcondv,
-                             pwork, lwork, prwork, pbwork, info
+                             n, F77_DBLE_CMPLX_ARG (s), n, sdim, F77_DBLE_CMPLX_ARG (pw), F77_DBLE_CMPLX_ARG (q), n, rconde, rcondv,
+                             F77_DBLE_CMPLX_ARG (pwork), lwork, prwork, pbwork, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   return info;
 }
 
 template <>
@@ -407,18 +407,18 @@ rsf2csf<ComplexMatrix, Matrix> (const Ma
     (*current_liboctave_error_handler)
       ("rsf2csf: inconsistent matrix dimensions");
 
   if (n > 0)
     {
       OCTAVE_LOCAL_BUFFER (double, c, n-1);
       OCTAVE_LOCAL_BUFFER (double, sx, n-1);
 
-      F77_XFCN (zrsf2csf, ZRSF2CSF, (n, s.fortran_vec (),
-                                     u.fortran_vec (), c, sx));
+      F77_XFCN (zrsf2csf, ZRSF2CSF, (n, F77_DBLE_CMPLX_ARG (s.fortran_vec ()),
+                                     F77_DBLE_CMPLX_ARG (u.fortran_vec ()), c, sx));
     }
 
   return schur<ComplexMatrix> (s, u);
 }
 
 template <>
 octave_idx_type
 schur<FloatComplexMatrix>::init (const FloatComplexMatrix& a,
@@ -487,18 +487,18 @@ schur<FloatComplexMatrix>::init (const F
   octave_idx_type ntmp = (ord_char == 'N' || ord_char == 'n') ? 0 : n;
   Array<octave_idx_type> bwork (dim_vector (ntmp, 1));
   octave_idx_type *pbwork = bwork.fortran_vec ();
 
   F77_XFCN (cgeesx, CGEESX, (F77_CONST_CHAR_ARG2 (&jobvs, 1),
                              F77_CONST_CHAR_ARG2 (&sort, 1),
                              selector,
                              F77_CONST_CHAR_ARG2 (&sense, 1),
-                             n, s, n, sdim, pw, q, n, rconde, rcondv,
-                             pwork, lwork, prwork, pbwork, info
+                             n, F77_CMPLX_ARG (s), n, sdim, F77_CMPLX_ARG (pw), F77_CMPLX_ARG (q), n, rconde, rcondv,
+                             F77_CMPLX_ARG (pwork), lwork, prwork, pbwork, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   return info;
 }
 
 template <>
@@ -514,18 +514,18 @@ rsf2csf<FloatComplexMatrix, FloatMatrix>
     (*current_liboctave_error_handler)
       ("rsf2csf: inconsistent matrix dimensions");
 
   if (n > 0)
     {
       OCTAVE_LOCAL_BUFFER (float, c, n-1);
       OCTAVE_LOCAL_BUFFER (float, sx, n-1);
 
-      F77_XFCN (crsf2csf, CRSF2CSF, (n, s.fortran_vec (),
-                                     u.fortran_vec (), c, sx));
+      F77_XFCN (crsf2csf, CRSF2CSF, (n, F77_CMPLX_ARG (s.fortran_vec ()),
+                                     F77_CMPLX_ARG (u.fortran_vec ()), c, sx));
     }
 
   return schur<FloatComplexMatrix> (s, u);
 }
 
 // Instantiations we need.
 
 template class schur<ComplexMatrix>;
diff --git a/liboctave/numeric/svd.cc b/liboctave/numeric/svd.cc
--- a/liboctave/numeric/svd.cc
+++ b/liboctave/numeric/svd.cc
@@ -512,29 +512,29 @@ svd<ComplexMatrix>::init (const ComplexM
 
   if (svd_driver == svd::GESVD)
     {
       octave_idx_type lrwork = 5*max_mn;
       Array<double> rwork (dim_vector (lrwork, 1));
 
       F77_XFCN (zgesvd, ZGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
-                                 m, n, tmp_data, m1, s_vec, u, m1, vt,
-                                 nrow_vt1, work.fortran_vec (), lwork,
+                                 m, n, F77_DBLE_CMPLX_ARG (tmp_data), m1, s_vec, F77_DBLE_CMPLX_ARG (u), m1, F77_DBLE_CMPLX_ARG (vt),
+                                 nrow_vt1, F77_DBLE_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  rwork.fortran_vec (), info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
       lwork = static_cast<octave_idx_type> (work(0).real ());
       work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (zgesvd, ZGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
-                                 m, n, tmp_data, m1, s_vec, u, m1, vt,
-                                 nrow_vt1, work.fortran_vec (), lwork,
+                                 m, n, F77_DBLE_CMPLX_ARG (tmp_data), m1, s_vec, F77_DBLE_CMPLX_ARG (u), m1, F77_DBLE_CMPLX_ARG (vt),
+                                 nrow_vt1, F77_DBLE_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  rwork.fortran_vec (), info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
     }
   else if (svd_driver == svd::GESDD)
     {
       assert (jobu == jobv);
       char jobz = jobu;
@@ -544,27 +544,27 @@ svd<ComplexMatrix>::init (const ComplexM
         lrwork = 7*min_mn;
       else
         lrwork = 5*min_mn*min_mn + 5*min_mn;
       Array<double> rwork (dim_vector (lrwork, 1));
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, 8*min_mn);
 
       F77_XFCN (zgesdd, ZGESDD, (F77_CONST_CHAR_ARG2 (&jobz, 1),
-                                 m, n, tmp_data, m1, s_vec, u, m1, vt,
-                                 nrow_vt1, work.fortran_vec (), lwork,
+                                 m, n, F77_DBLE_CMPLX_ARG (tmp_data), m1, s_vec, F77_DBLE_CMPLX_ARG (u), m1, F77_DBLE_CMPLX_ARG (vt),
+                                 nrow_vt1, F77_DBLE_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  rwork.fortran_vec (), iwork, info
                                  F77_CHAR_ARG_LEN (1)));
 
       lwork = static_cast<octave_idx_type> (work(0).real ());
       work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (zgesdd, ZGESDD, (F77_CONST_CHAR_ARG2 (&jobz, 1),
-                                 m, n, tmp_data, m1, s_vec, u, m1, vt,
-                                 nrow_vt1, work.fortran_vec (), lwork,
+                                 m, n, F77_DBLE_CMPLX_ARG (tmp_data), m1, s_vec, F77_DBLE_CMPLX_ARG (u), m1, F77_DBLE_CMPLX_ARG (vt),
+                                 nrow_vt1, F77_DBLE_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  rwork.fortran_vec (), iwork, info
                                  F77_CHAR_ARG_LEN (1)));
     }
   else
     abort ();
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm = right_sm.hermitian ();
@@ -651,29 +651,29 @@ svd<FloatComplexMatrix>::init (const Flo
 
   if (svd_driver == svd::GESVD)
     {
       octave_idx_type lrwork = 5*max_mn;
       Array<float> rwork (dim_vector (lrwork, 1));
 
       F77_XFCN (cgesvd, CGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
-                                 m, n, tmp_data, m1, s_vec, u, m1, vt,
-                                 nrow_vt1, work.fortran_vec (), lwork,
+                                 m, n, F77_CMPLX_ARG (tmp_data), m1, s_vec, F77_CMPLX_ARG (u), m1, F77_CMPLX_ARG (vt),
+                                 nrow_vt1, F77_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  rwork.fortran_vec (), info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
 
       lwork = static_cast<octave_idx_type> (work(0).real ());
       work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (cgesvd, CGESVD, (F77_CONST_CHAR_ARG2 (&jobu, 1),
                                  F77_CONST_CHAR_ARG2 (&jobv, 1),
-                                 m, n, tmp_data, m1, s_vec, u, m1, vt,
-                                 nrow_vt1, work.fortran_vec (), lwork,
+                                 m, n, F77_CMPLX_ARG (tmp_data), m1, s_vec, F77_CMPLX_ARG (u), m1, F77_CMPLX_ARG (vt),
+                                 nrow_vt1, F77_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  rwork.fortran_vec (), info
                                  F77_CHAR_ARG_LEN (1)
                                  F77_CHAR_ARG_LEN (1)));
     }
   else if (svd_driver == svd::GESDD)
     {
       assert (jobu == jobv);
       char jobz = jobu;
@@ -683,27 +683,27 @@ svd<FloatComplexMatrix>::init (const Flo
         lrwork = 5*min_mn;
       else
         lrwork = min_mn * std::max (5*min_mn+7, 2*max_mn+2*min_mn+1);
       Array<float> rwork (dim_vector (lrwork, 1));
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, iwork, 8*min_mn);
 
       F77_XFCN (cgesdd, CGESDD, (F77_CONST_CHAR_ARG2 (&jobz, 1),
-                                 m, n, tmp_data, m1, s_vec, u, m1, vt,
-                                 nrow_vt1, work.fortran_vec (), lwork,
+                                 m, n, F77_CMPLX_ARG (tmp_data), m1, s_vec, F77_CMPLX_ARG (u), m1, F77_CMPLX_ARG (vt),
+                                 nrow_vt1, F77_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  rwork.fortran_vec (), iwork, info
                                  F77_CHAR_ARG_LEN (1)));
 
       lwork = static_cast<octave_idx_type> (work(0).real ());
       work.resize (dim_vector (lwork, 1));
 
       F77_XFCN (cgesdd, CGESDD, (F77_CONST_CHAR_ARG2 (&jobz, 1),
-                                 m, n, tmp_data, m1, s_vec, u, m1, vt,
-                                 nrow_vt1, work.fortran_vec (), lwork,
+                                 m, n, F77_CMPLX_ARG (tmp_data), m1, s_vec, F77_CMPLX_ARG (u), m1, F77_CMPLX_ARG (vt),
+                                 nrow_vt1, F77_CMPLX_ARG (work.fortran_vec ()), lwork,
                                  rwork.fortran_vec (), iwork, info
                                  F77_CHAR_ARG_LEN (1)));
     }
   else
     abort ();
 
   if (! (jobv == 'N' || jobv == 'O'))
     right_sm = right_sm.hermitian ();
