# HG changeset patch
# User jwe
# Date 922470515 0
#      Fri Mar 26 17:48:35 1999 +0000
# Node ID 041ea33fbbf48020d8662cef3ca3ed3a46a433c1
# Parent  737b219ab65a8e8e56afd28879b90f8035d6184a
[project @ 1999-03-26 17:48:16 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,13 @@
+Wed Feb  3 01:02:37 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* configure.in: Use AC_OUTPUT_COMMANDS to chmod install-octave so
+	that the command will also executed in config.status.
+
 Thu Jan 28 21:05:32 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makeconf.in (do-subst-config-vals): Do substitution on
 	CANONICAL_HOST_TYPE, not TARGET_HOST_TYPE.
 	(do-subst-default-vals): Likewise.
 
 Wed Jan 20 12:56:02 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -16,17 +16,17 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ### for more details.
 ### 
 ### You should have received a copy of the GNU General Public License
 ### along with Octave; see the file COPYING.  If not, write to the Free
 ### Software Foundation, 59 Temple Place - Suite 330, Boston, MA
 ### 02111-1307, USA. 
 
-AC_REVISION($Revision: 1.315 $)
+AC_REVISION($Revision: 1.316 $)
 AC_PREREQ(2.9)
 AC_INIT(src/octave.cc)
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1)
 
 OCTAVE_HOST_TYPE
 
@@ -1171,17 +1171,17 @@ AC_OUTPUT(Makefile octMakefile Makeconf 
   libcruft/dassl/Makefile libcruft/fftpack/Makefile \
   libcruft/lapack/Makefile libcruft/linpack/Makefile \
   libcruft/minpack/Makefile libcruft/misc/Makefile \
   libcruft/odepack/Makefile libcruft/ordered-qz/Makefile \
   libcruft/quadpack/Makefile libcruft/ranlib/Makefile \
   libcruft/slatec-fn/Makefile libcruft/slatec-err/Makefile \
   libcruft/villad/Makefile)
 
-chmod 755 install-octave
+AC_OUTPUT_COMMANDS([chmod +x install-octave])
 
 ### Print a summary so that important information isn't missed.
 
 if test -z "$F77"; then
   FORT="$F2C $F2CFLAGS"
 else
   FORT="$F77 $FFLAGS"
 fi
diff --git a/doc/interpreter/dir b/doc/interpreter/dir
--- a/doc/interpreter/dir
+++ b/doc/interpreter/dir
@@ -4,9 +4,11 @@ Info hierarchy.	 The first time you invo
 looking at that node, which is (dir)Top.
 
 File: dir	Node: Top	This is the top of the INFO tree
   This (the Directory node) gives a menu of major topics. 
   Typing "d" returns here, "q" exits, "?" lists all INFO commands, "h" 
   gives a primer for first-timers, "mItem<Return>" visits the menu
   item named `Item', etc.
 
+* Menu: The list of major topics begins on the next line.
+
 * Octave: (octave).	Interactive language for numerical computations.
diff --git a/doc/interpreter/struct.texi b/doc/interpreter/struct.texi
--- a/doc/interpreter/struct.texi
+++ b/doc/interpreter/struct.texi
@@ -132,17 +132,17 @@ octave:1> function y = f (x)
 @end example
 
 When called with a complex-valued argument, @code{f} returns the data
 structure containing the real and imaginary parts of the original
 function argument.
 
 @example
 @group
-octave:2> f (rand (3) + rand (3) * I);
+octave:2> f (rand (2) + rand (2) * I);
 ans =
 @{
   im =
 
     0.26475  0.14828
     0.18436  0.83669
 
   re =
diff --git a/libcruft/ChangeLog b/libcruft/ChangeLog
--- a/libcruft/ChangeLog
+++ b/libcruft/ChangeLog
@@ -1,8 +1,14 @@
+Fri Mar 26 01:19:04 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* Makerules.in (all): Don't try to use a special rule for making
+	the archive.  The default rules may be slower, but they are also
+	correct.
+
 Wed Nov 11 17:27:35 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* Makefile.in (CRUFT_DIRS): Add amos.  Delete specfun.
 	* specfun: Delete directory.
 	* amos: New directory
 
 Thu Oct 15 00:43:13 1998  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
diff --git a/libcruft/Makerules.in b/libcruft/Makerules.in
--- a/libcruft/Makerules.in
+++ b/libcruft/Makerules.in
@@ -24,42 +24,27 @@ ifeq ($(SHARED_LIBS), true)
   endif
 endif
 
 CWD = $(shell pwd)
 THISDIR = $(notdir $(CWD))
 
 LIBCRUFT := ../libcruft.$(LIBEXT)
 
-ifeq ($(STATIC_LIBS), true)
-  LIBCRUFT_DEPEND := $(LIBCRUFT)
-endif
-
 LIBCRUFT_OBJS = $(CRUFT_OBJ) $(SPECIAL_DEPEND)
 
 LIBCRUFT_DEPS = $(LIBCRUFT)($(LIBCRUFT_OBJS))
 
+ifeq ($(STATIC_LIBS), true)
+  LIBCRUFT_DEPEND := $(LIBCRUFT_DEPS)
+endif
+
 all: pic $(LIBCRUFT_DEPEND) $(CRUFT_PICOBJ) $(SPECIAL_PICDEPEND)
 .PHONY: all
 
-# Cancel the default action for when an archive member is out of
-# date.  Instead of inserting the out of date members individually, we
-# will insert them in batches, even if some of them are up to date.
-# This is much faster for a large archive like libcruft.a.
-
-(%) : %
-	@true
-
-$(LIBCRUFT): $(LIBCRUFT_DEPS)
-	$(AR) $(ARFLAGS) $@ $^
-	$(RANLIB) $@
-
-# This is necessary, otherwise we won't have any .o files left when it
-# comes time to insert them in the archive.
-
 .PRECIOUS: $(LIBCRUFT_OBJS)
 
 pic:
 	@if [ -d pic ]; then \
 	  true; \
 	else \
 	  echo "mkdir pic"; \
 	  mkdir pic; \
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,23 @@
+Fri Mar 26 11:26:32 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* Makefile.in (libraries): Use the libfoo.a(objects) method of
+	creating static libs.
+
+Thu Mar  4 02:17:04 1999  James Macnicol <jamesm@evans.ee.adfa.oz.au>
+
+	* data-conv.cc (oct_data_conv::string_to_data_type): Handle uint16
+	and uint32 data types.
+
+Thu Mar  4 01:51:37 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* lo-ieee.cc (octave_ieee_init): Don't use __alpha__-specific code
+	for Linux.  Remove old Linux-specific code.
+
 Tue Jan 19 09:34:55 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* dMatrix.cc (operator * (const ColumnVector& v, const RowVector& a)):
 	Don't require lengths to be equal.
 	* CMatrix.cc (operator * (const ComplexColumnVector& v, const
 	ComplexRowVector& a)): Likewise
 
 Tue Nov 24 23:38:19 1998  Eric Norum <eric@skatter.USask.Ca>
diff --git a/liboctave/Makefile.in b/liboctave/Makefile.in
--- a/liboctave/Makefile.in
+++ b/liboctave/Makefile.in
@@ -108,18 +108,16 @@ OBJECTS := $(patsubst %.c, %.o, $(OBJECT
 ifeq ($(SHARED_LIBS), true)
   ifdef CXXPICFLAG
     PICOBJ := $(addprefix pic/, $(OBJECTS))
   else
     PICOBJ := $(OBJECTS)
   endif
 endif
 
-LIBOCTAVE_DEPEND := $(patsubst %, liboctave.$(LIBEXT)(%), $(OBJECTS))
-
 all: libraries
 .PHONY: all
 
 stmp-pic: pic
 	@if [ -f stmp-pic ]; then \
 	  true; \
 	else \
 	  echo "touch stmp-pic"; \
@@ -131,33 +129,29 @@ pic:
 	  true; \
 	else \
 	  echo "mkdir pic"; \
 	  mkdir pic; \
 	fi
 
 ifeq ($(SHARED_LIBS), true)
   ifeq ($(STATIC_LIBS), true)
-    libraries: liboctave.$(LIBEXT) liboctave.$(SHLEXT)
+    libraries: liboctave.$(LIBEXT)($(OBJECTS)) liboctave.$(SHLEXT)
   else
     libraries: liboctave.$(SHLEXT)
   endif
 else
   ifeq ($(STATIC_LIBS), true)
-    libraries: liboctave.$(LIBEXT)
+    libraries: liboctave.$(LIBEXT)($(OBJECTS))
   else
     libraries:
   endif
 endif
 .PHONY: libraries
 
-liboctave.$(LIBEXT): $(OBJECTS)
-	$(AR) $(ARFLAGS) $@ $^
-	$(RANLIB) $@
-
 liboctave.$(SHLEXT): liboctave.$(SHLEXT_VER)
 	rm -f $@
 	$(LN_S) $< $@
 
 liboctave.$(SHLEXT_VER): $(PICOBJ)
 	$(SH_LD) $(SH_LDFLAGS) $(SONAME_FLAGS) -o $@ $^
 
 $(PICOBJ): stmp-pic
diff --git a/liboctave/data-conv.cc b/liboctave/data-conv.cc
--- a/liboctave/data-conv.cc
+++ b/liboctave/data-conv.cc
@@ -90,16 +90,36 @@ oct_data_conv::string_to_data_type (cons
       if (sizeof (int) == 4)
 	retval = dt_int;
       else if (sizeof (long) == 4)
 	retval = dt_long;
       else
 	(*current_liboctave_error_handler)
 	  ("unable to find matching native data type for %s", s.c_str ());
     }
+  else if (s == "uint16")
+    {
+      if (sizeof (unsigned short) == 2)
+        retval = dt_ushort;
+      else if (sizeof (unsigned int) == 2)
+        retval = dt_uint;
+      else
+       (*current_liboctave_error_handler)
+         ("unable to find matching native data type for %s", s.c_str ());
+    }
+  else if (s == "uint32")
+    {
+      if (sizeof (unsigned int) == 4)
+        retval = dt_uint;
+      else if (sizeof (unsigned long) == 4)
+        retval = dt_ulong;
+      else
+       (*current_liboctave_error_handler)
+         ("unable to find matching native data type for %s", s.c_str ());
+    }
   else
     (*current_liboctave_error_handler) ("invalid data type specified");
 
   return retval;
 }
 
 #define swap_1_bytes(x, y)
 
diff --git a/liboctave/lo-ieee.cc b/liboctave/lo-ieee.cc
--- a/liboctave/lo-ieee.cc
+++ b/liboctave/lo-ieee.cc
@@ -63,23 +63,17 @@ octave_ieee_init (void)
 #if defined (HAVE_ISINF) || defined (HAVE_FINITE)
 
 // Some version of gcc on some old version of Linux used to crash when
 // trying to make Inf and NaN.
 
 #if defined (SCO)
   double tmp = 1.0;
   octave_Inf = 1.0 / (tmp - tmp);
-#elif defined (linux)
-#if defined (HUGE_VAL) && ! defined (arm)
-  octave_Inf = HUGE_VAL;
-#else
-  octave_Inf = 1.0/0.0;
-#endif
-#elif defined (__alpha__)
+#elif defined (__alpha__) && ! defined (linux)
   extern unsigned int DINFINITY[2];
   octave_Inf =  (*(X_CAST(double *, DINFINITY)));
 #elif defined (HAVE_INFINITY)
   octave_Inf = infinity ();
 #else
   double tmp = 1e+10;
   octave_Inf = tmp;
   for (;;)
@@ -90,23 +84,17 @@ octave_ieee_init (void)
       tmp = octave_Inf;
     }
 #endif
 
 #endif
 
 #if defined (HAVE_ISNAN)
 
-#if defined (linux)
-#if defined (NAN) && ! defined (arm)
-  octave_NaN = NAN;
-#else
-  octave_NaN = 0.0/0.0;
-#endif
-#elif defined (__alpha__)
+#if defined (__alpha__) && ! defined (linux)
   extern unsigned int DQNAN[2];
   octave_NaN = (*(X_CAST(double *, DQNAN)));
 #elif defined (HAVE_QUIET_NAN)
   octave_NaN = quiet_nan (0L);
 #else
   octave_NaN = octave_Inf / octave_Inf;
 #endif
 
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,64 @@
+Wed Mar 24 20:34:48 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* linear-algebra/norm.m: Do the right thing for 1- and
+	infinity-norms of complex matrices.  From Sven Khatri
+	<khatri@saturn.vocalpoint.com>.
+
+Tue Mar 16 13:36:36 1999  A. Scottedward Hodel" <scotte@eng.auburn.edu>
+
+	* linear-algebra/qrhouse.m: Handle default args correctly.
+
+Thu Mar 11 12:52:34 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* strings/split.m: Avoid problems when splitting strings that have
+	\ in them.
+
+Thu Mar 11 12:36:13 1999  Massimo Lorenzin <maxlorenzin@tin.it>
+
+	* image/colormap.m: Do better arg checking, handle string args
+	that name the colormap function to call (e.g., colormap ("ocean")).
+
+Mon Mar  8 22:23:24 1999  Rolf Fabian <fabian@TU-Cottbus.De>
+
+	* polynomial/polyfit.m: Use .' transpose operator, not '.
+	* linear-algebra/dot.m: Likewise.
+	* linear-algebra/cross.m: Likewise.
+	* general/rot90.m: Likewise.
+
+Sat Mar  6 01:45:00 1999  A Scott Hodel <hodel@edalf1.msfc.nasa.gov>
+
+	* linear-algebra/qrhouse.m: Permute columns at each iteration so
+	that the leading column is not all zeros.
+
+Fri Mar  5 00:37:47 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* general/shift.m: Fix potential problems with
+	whitespace_in_literal_matrix.
+	* signal/arch_rnd.m: Ditto.
+	* signal/autocov.m: Ditto.
+	* signal/diffpara.m: Ditto.
+	* signal/hurst.m: Ditto.
+	* signal/periodogram.m: Ditto.
+	* signal/spectral_adf.m: Ditto.
+	* signal/spectral_xdf.m: Ditto.
+	* signal/spencer.m: Ditto.
+	* signal/synthesis.m: Ditto.
+	* statistics/distributions/wiener_rnd.m: Ditto.
+	* statistics/models/logistic_regression_likelihood.m: Ditto.
+	* statistics/models/logistic_regression.m: Ditto.
+	* statistics/models/logistic_regression_derivatives.m: Ditto.
+	* statistics/tests/run_test.m: Ditto.
+	* statistics/tests/chisquare_test_independence.m: Ditto.
+
+Wed Mar  3 02:25:00 1999  Joao Cardoso <jcardoso@inescn.pt>
+
+	* plot/__plr2__.m: Fix typo.
+
 Tue Jan 12 10:31:15 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* plot/__pltopt1__.m: Accept "k" to mean black.
 
 Fri Dec 11 10:43:19 1998  A Scott Hodel <hodel@edalf1.msfc.nasa.gov>
 
 	* linear-algebra/krylov.m: Force empty_list_elements_ok for this
 	function.
diff --git a/scripts/control/buildssic.m b/scripts/control/buildssic.m
--- a/scripts/control/buildssic.m
+++ b/scripts/control/buildssic.m
@@ -124,17 +124,17 @@ function [sys] = buildssic(Clst,Ulst,Ols
     if (n && nz)
       error("---> cannot handle mixed continuous and discrete systems.");
     endif
     D_SYS = (nz > 0);
     [A,B,C,D,tsam] = sys2ss(s1);
     nt = n + nz;
   endif
   for ii = 6:nargin
-    eval(["ss = s" num2str(ii-4) ";"]);
+    eval(["ss = s", num2str(ii-4), ";"]);
     if (!is_struct(ss))
       error("---> Parameter must be a structed system.");
     endif
     ss = sysupdate(ss, "ss");
     [n1, nz1, m1, p1] = sysdimensions(ss);
     if (n1 && nz1)
       error("---> cannot handle mixed continuous and discrete systems.");
     endif
@@ -145,24 +145,24 @@ function [sys] = buildssic(Clst,Ulst,Ols
       if (tsam != sysgettsam(ss))
 	error("---> sampling time of all systems must match.");
       endif
     endif
     [as,bs,cs,ds] = sys2ss(ss);
     nt1 = n1 + nz1;
     if (!nt1)
       # pure gain (pad B, C with zeros)
-      B = [B  zeros(nt,m1)];
+      B = [B, zeros(nt,m1)];
       C = [C; zeros(p1,nt)];
     else
-      A = [A  zeros(nt,nt1); zeros(nt1,nt) as];
-      B = [B  zeros(nt,m1);  zeros(nt1,m)  bs];
-      C = [C  zeros(p,nt1);  zeros(p1,nt)  cs];
+      A = [A, zeros(nt,nt1); zeros(nt1,nt), as];
+      B = [B, zeros(nt,m1);  zeros(nt1,m),  bs];
+      C = [C, zeros(p,nt1);  zeros(p1,nt),  cs];
     endif
-    D = [D  zeros(p,m1); zeros(p1,m) ds];
+    D = [D, zeros(p,m1); zeros(p1,m), ds];
     n = n + n1;
     nz = nz + nz1;
     nt = nt + nt1;
     m = m + m1;
     p = p + p1;
   endfor
 
   # check maximum dimensions
diff --git a/scripts/control/c2d.m b/scripts/control/c2d.m
--- a/scripts/control/c2d.m
+++ b/scripts/control/c2d.m
@@ -92,28 +92,28 @@ function dsys = c2d (sys, opt, T)
     dsys = syssetsignals(sys,"yd",ones(1:p));
   elseif(strcmp(opt,"ex"))
     # construct new state-space (a,b,c,d) for continuous subsystem
     [csys,Acd] = syscont(sys);   	# extract continuous subsystem
     [csys_a, csys_b, csys_c, csys_d] = sys2ss(csys);
     [ sys_a,  sys_b,  sys_c,  sys_d] = sys2ss( sys);
     if(isempty(Acd))                Bmat = sys_b;
     elseif(isempty(csys_b))         Bmat = Acd;
-    else                            Bmat = [Acd csys_b];     endif
+    else                            Bmat = [Acd, csys_b];     endif
     
     row_zer = columns(Bmat);
     csysn = sysdimensions(csys);
     col_zer = csysn + row_zer;
 
     [csysa,csysb,csysc,csysd] = sys2ss(csys);
     if(isempty(Bmat) )
       warning("c2d: no inputs to continuous subsystem.");
       mat = csysa;
     else
-      mat = [csysa Bmat ; zeros( row_zer,col_zer) ];
+      mat = [csysa, Bmat ; zeros( row_zer,col_zer) ];
     endif
 
     matexp = expm(mat * T);
   
     Abar = matexp( 1:csysn , 1:(csysn + columns(Acd)) );  
     Bbar = matexp( 1:csysn , (columns(Abar) + 1):columns(matexp) );
 
     newnz = rows(Abar);
diff --git a/scripts/control/d2c.m b/scripts/control/d2c.m
--- a/scripts/control/d2c.m
+++ b/scripts/control/d2c.m
@@ -118,17 +118,17 @@ function csys = d2c(sys,opt)
   
     [ma,na] = size(a);
     [mb,nb] = size(b);
   
     if(isempty(b) )
       warning("d2c: empty b matrix");
       Amat = a;
     else
-      Amat = [a, b; zeros(nb, na) eye(nb)];
+      Amat = [a, b; zeros(nb,na), eye(nb)];
     endif
   
     poles = eig(a);
     if( find(abs(poles) < 200*(n+nz)*eps) )
       warning("d2c: some poles very close to zero.  logm not performed");
       Mtop = zeros(ma, na+nb);
     elseif( find(abs(poles-1) < 200*(n+nz)*eps) )
       warning("d2c: some poles very close to one.  May get bad results.");
@@ -155,18 +155,18 @@ function csys = d2c(sys,opt)
       if(geps == 0)
         geps = 1e-8;
       endif
       DMtop = Mtop;
       if(isempty(b))
         Mall = Mtop;
         DMall = DMtop;
       else
-        Mall = [Mtop; zeros(nb, na+nb)];
-        DMall = [DMtop; zeros(nb, na+nb) ];
+        Mall = [Mtop; zeros(nb,na+nb)];
+        DMall = [DMtop; zeros(nb,na+nb) ];
       endif
   
       if(newgrad)
         GrMall = zeros(size(Mall));
         for ii=1:rows(Mtop)
           for jj=1:columns(Mtop)
   	  DMall(ii,jj) = Mall(ii,jj) + geps;
             GrMall(ii,jj) = norm(Amat - expm(DMall*T),'fro') ...
diff --git a/scripts/control/dlqg.m b/scripts/control/dlqg.m
--- a/scripts/control/dlqg.m
+++ b/scripts/control/dlqg.m
@@ -107,18 +107,18 @@ else
 endif
 
 if (! (is_square(Sigw) && is_square(Sigv) ) )
   error("dlqg: Sigw, Sigv must be square");
 endif
 
 # now we can just do the design; call dlqr and dlqe, since all matrices
 # are not given in Cholesky factor form (as in h2syn case)
-[Ks P Er] = dlqr(A,B,Q,R);
-[Ke Q jnk Ee] = dlqe(A,G,C,Sigw,Sigv);
+[Ks, P, Er] = dlqr(A,B,Q,R);
+[Ke, Q, jnk, Ee] = dlqe(A,G,C,Sigw,Sigv);
 Ac = A - Ke*C - B*Ks;
 Bc = Ke;
 Cc = -Ks;
 Dc = zeros(rows(Cc),columns(Bc));
 K = ss2sys(Ac,Bc,Cc,Dc,1);
 disp("HODEL: need to add names to this guy!")
 
 endfunction
diff --git a/scripts/control/dre.m b/scripts/control/dre.m
--- a/scripts/control/dre.m
+++ b/scripts/control/dre.m
@@ -65,21 +65,21 @@ elseif(maxits <= 0)		error("maxits must 
 endif
 maxits = ceil(maxits);
 
 [aa,bb] = sys2ss(sys);
 nn = sysdimensions(sys,"cst");
 mm = sysdimensions(sys,"in");
 pp = sysdimensions(sys,"out");
 
-if(size(Q) != [nn nn])
+if(size(Q) != [nn, nn])
   error("Q(%dx%d); sys has %d states",rows(Q),columns(Q),nn);
-elseif(size(Qf) != [nn nn])
+elseif(size(Qf) != [nn, nn])
   error("Qf(%dx%d); sys has %d states",rows(Qf),columns(Qf),nn);
-elseif(size(R) != [mm mm])
+elseif(size(R) != [mm, mm])
   error("R(%dx%d); sys has %d inputs",rows(R),columns(R),mm);
 endif
 
 # construct Hamiltonian matrix
 H = [aa , -(bb/R)*bb' ; -Q, -aa'];
 
 # select time step to avoid numerical overflow
 fast_eig = max(abs(eig(H)));
@@ -104,17 +104,17 @@ while(!done)
     uv = expm(-H*delta_t)*uv_i_minus_1;
     Qi = uv(n1:n2,1:nn)/uv(1:nn,1:nn);
     Plist(ii) = (Qi+Qi')/2;
     # check error
     Perr = norm(nth(Plist,ii) - nth(Plist,ii-1))/norm(nth(Plist,ii));
     maxerr = max(maxerr,Perr);
     if(Perr > Ptol)
       new_t = mean(tvals([ii,ii-1]));
-      tvals = [tvals new_t];
+      tvals = [tvals, new_t];
       done = 0;
     endif
   endfor
 
   # check number of iterations
   maxits = maxits - 1;
   done = done+(maxits==0);
 endwhile
diff --git a/scripts/control/h2syn.m b/scripts/control/h2syn.m
--- a/scripts/control/h2syn.m
+++ b/scripts/control/h2syn.m
@@ -60,20 +60,20 @@ function [K,gain, Kc, Kf, Pc,  Pf] = h2s
   # extract dgs information
   			nw = dgs.nw; 	nu = dgs.nu;
   A = dgs.A;            Bw = dgs.Bw;    Bu = dgs.Bu;
   Cz = dgs.Cz;          Dzw = dgs.Dzw;  Dzu = dgs.Dzu;	nz = dgs.nz;
   Cy = dgs.Cy;          Dyw = dgs.Dyw;  Dyu = dgs.Dyu;	ny = dgs.ny;
   d22nz = dgs.Dyu_nz;
   dflg = dgs.dflg;
 
-  if(norm(Dzw,Inf) > norm([Dzw Dzu ; Dyw Dyu],Inf)*1e-12)
+  if(norm(Dzw,Inf) > norm([Dzw, Dzu ; Dyw, Dyu],Inf)*1e-12)
     warning("h2syn: Dzw nonzero; feedforward not implemented")
     Dzw
-    D = [Dzw Dzu ; Dyw Dyu]
+    D = [Dzw, Dzu ; Dyw, Dyu]
   endif
 
   # recover i/o transformations
   Ru = dgs.Ru;         Ry = dgs.Ry;
   [ncstates, ndstates, nout, nin] = sysdimensions(Asys);
   Atsam = sysgettsam(Asys);
   [Ast, Ain, Aout] = sysgetsignals(Asys);
 
diff --git a/scripts/control/hinf_ctr.m b/scripts/control/hinf_ctr.m
--- a/scripts/control/hinf_ctr.m
+++ b/scripts/control/hinf_ctr.m
@@ -105,27 +105,27 @@ function K = hinf_ctr(dgs,F,H,Z,g)
   c2hat = -d21hat*(C2+F12)*Z;
   b1hat = -H2 + (b2hat/d12hat)*d11hat;
   c1hat =  F2*Z + (d11hat/d21hat)*c2hat;
   ahat  =  A + H*C + (b2hat/d12hat)*c1hat;
 
   # rescale controller by Ru and Ry
   b1hat = b1hat/Ry;
   c1hat = Ru\c1hat;
-  bhat  = [b1hat b2hat];
+  bhat  = [b1hat, b2hat];
   chat  = [c1hat; c2hat];
-  dhat  = [Ru\d11hat/Ry Ru\d12hat; d21hat/Ry 0*d11hat'];
+  dhat  = [Ru\d11hat/Ry, Ru\d12hat; d21hat/Ry, 0*d11hat'];
 
   # non-zero D22 is a special case
   if (d22nz)
     if (rank(eye(nu) + d11hat*D22) < nu)
       error(" *** cannot compute controller for D22 non-zero.");
     endif
 
-    d22new = [D22 zeros(ny,ny); zeros(nu,nu) 0*D22'];
+    d22new = [D22, zeros(ny,ny); zeros(nu,nu), 0*D22'];
     xx = inv(eye(nu+ny) + d22new*dhat);
     mhat = inv(eye(nu+ny) + dhat*d22new);
     ahat = ahat - bhat*((eye(nu+ny)-xx)/dhat)*chat;
     bhat = bhat*xx;
     chat = mhat*chat;
     dhat = dhat*xx;
 
   endif
diff --git a/scripts/control/hinfnorm.m b/scripts/control/hinfnorm.m
--- a/scripts/control/hinfnorm.m
+++ b/scripts/control/hinfnorm.m
@@ -11,17 +11,17 @@
 # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or 
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License 
 # for more details.
 # 
 # You should have received a copy of the GNU General Public License 
 # along with Octave; see the file COPYING.  If not, write to the Free 
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA. 
  
-function [g gmin gmax] = hinfnorm(sys,tol,gmin,gmax,ptol)
+function [g, gmin, gmax] = hinfnorm(sys,tol,gmin,gmax,ptol)
   # Usage: [g gmin gmax] = hinfnorm(sys[,tol,gmin,gmax,ptol])
   #
   # Computes the H infinity norm of a system data structure
   # sys = system data structure
   # tol = H infinity norm search tolerance (default: 0.001)
   # gmin = minimum value for norm search (default: 1e-9)
   # gmax = maximum value for norm search (default: 1e+9)
   # ptol: pole tolerance:
@@ -103,17 +103,17 @@ function [g gmin gmax] = hinfnorm(sys,to
       # guard against roundoff again: zero out extremely small values
       # prior to balancing
       s1 = s1 .* (abs(s1) > ptol*norm(s1,"inf"));
       s2 = s2 .* (abs(s2) > ptol*norm(s2,"inf"));
       [cc,dd,s1,s2] = balance(s1,s2);
       [qza,qzb,zz,pls] = qz(s1,s2,"S");	# ordered qz decomposition
       eigerr = abs(abs(pls)-1);
       normH = norm([s1,s2]);
-      Hb = [s1 s2];
+      Hb = [s1, s2];
 
       # check R - B' X B condition (Iglesias and Glover's paper)
       X = zz((nz+1):(2*nz),1:nz)/zz(1:nz,1:nz);
       dcondfailed = min(real( eig(Rg - B'*X*B)) < ptol);
     else
       Rinv = inv(g*g*Im - (D' * D));
       H = [A + B*Rinv*D'*C,        B*Rinv*B'; ...
            -C'*(Ip + D*Rinv*D')*C, -(A + B*Rinv*D'*C)'];
diff --git a/scripts/control/hinfsyn.m b/scripts/control/hinfsyn.m
--- a/scripts/control/hinfsyn.m
+++ b/scripts/control/hinfsyn.m
@@ -98,19 +98,19 @@ function [K,g,GW,Xinf,Yinf] = hinfsyn(As
   dflg = dgs.dflg;
 
   # recover i/o transformations
   R12 = dgs.Ru;		R21 = dgs.Ry;
   [ncstates, ndstates, nin, nout] = sysdimensions(Asys);
   Atsam = sysgettsam(Asys);
   [Ast, Ain, Aout] = sysgetsignals(Asys);
 
-  BB = [B1 B2];
+  BB = [B1, B2];
   CC = [C1 ; C2];
-  DD = [D11 D12 ; D21  D22];
+  DD = [D11, D12 ; D21,  D22];
 
   if (dflg == 0)
     n = ncstates;
     # perform binary search to find gamma min
     ghi = gmax;
     # derive a lower lower bound for gamma from D matrices
     xx1 = norm((eye(nz) - (D12/(D12'*D12))*D12')*D11);
     xx2 = norm(D11*(eye(nw)-(D21'/(D21*D21'))*D21));
@@ -177,17 +177,17 @@ function [K,g,GW,Xinf,Yinf] = hinfsyn(As
         case (0) 	g = ghi;
         case (1) 	g = glo;
         case (2) 	g = 0.5 * (ghi + glo);
         otherwise 	error(" *** This should never happen!");
       endswitch
       printf("%10.4f ", g);
 
       # computing R and R~
-      d1dot = [D11 D12];
+      d1dot = [D11, D12];
       R = zeros(nin, nin);
       R(1:nw,1:nw) = -g*g*eye(nw);
       R = R + d1dot' * d1dot;
       ddot1 = [D11; D21];
       Rtilde = zeros(nout, nout);
       Rtilde(1:nz,1:nz) = -g*g*eye(nz);
       Rtilde = Rtilde + ddot1 * ddot1';
 
diff --git a/scripts/control/hinfsyn_ric.m b/scripts/control/hinfsyn_ric.m
--- a/scripts/control/hinfsyn_ric.m
+++ b/scripts/control/hinfsyn_ric.m
@@ -33,18 +33,18 @@ function [Xinf,x_ha_err] = hinfsyn_ric(A
 #    6: R is singular
 
 x_ha_err = 0;        # assume success
 Xinf = [];		     # default return value
 n = is_square(A);
 nw = is_square(R);
 if(rank(R) != nw)    x_ha_err = 6;
 else                 # build hamiltonian Ha for X_inf
-  xx = ([BB; -C1'*d1dot]/R) * [d1dot'*C1 BB'];
-  Ha = [A 0*A; -C1'*C1 -A'] - xx;
+  xx = ([BB; -C1'*d1dot]/R) * [d1dot'*C1, BB'];
+  Ha = [A, 0*A; -C1'*C1, -A'] - xx;
   x_ha_err = 0;
   [d, Ha] = balance(Ha);
   [u, s] = schur(Ha, "A");
   rev = real(eig(s));
 
   if (any(abs(rev) <= ptol))	# eigenvalues near the imaginary axis
     x_ha_err = 1;
   elseif (sum(rev > 0) != sum(rev < 0))
diff --git a/scripts/control/is_dgkf.m b/scripts/control/is_dgkf.m
--- a/scripts/control/is_dgkf.m
+++ b/scripts/control/is_dgkf.m
@@ -136,28 +136,28 @@ function [retval,dgkf_struct] = is_dgkf(
 
   # Check for loopo shifting
   Dyu_nz = (norm(Dyu,Inf) != 0);
   if (Dyu_nz)
     warning("is_dgkf: D22 nonzero; performing loop shifting");
   endif
 
   # 12 - rank condition at w = 0
-  xx =[A Bu; Cz Dzu];
+  xx =[A, Bu; Cz, Dzu];
   [nr, nc] = size(xx);
   irank = rank(xx);
   if (irank != nc)
     retval = 0;
     warning(sprintf("rank([A Bu; Cz Dzu]) = %d, need %d; n=%d, nz=%d, nu=%d", ...
 	irank,nc,(Anc+Anz),nz,nu));
     warning(" *** 12-rank condition violated at w = 0.");
   endif
 
   # 21 - rank condition at w = 0
-  xx =[A Bw; Cy Dyw];
+  xx =[A, Bw; Cy, Dyw];
   [nr, nc] = size(xx);
   irank = rank(xx);
   if (irank != nr)
     retval = 0;
     warning(sprintf("rank([A Bw; Cy Dyw]) = %d, need %d; n=%d, ny=%d, nw=%d", ...
 	irank,nr,(Anc+Anz),ny,nw));
     warning(" *** 21-rank condition violated at w = 0.");
   endif
@@ -169,41 +169,41 @@ function [retval,dgkf_struct] = is_dgkf(
   if (irank != nu)
     retval = 0;
     warning(sprintf("*** rank(Dzu(%d x %d) = %d", nz, nu, irank));
     warning(" *** Dzu does not have full column rank.");
   endif
   if (nu >= nz)
     Qz = Qz(:,1:nu)';
   else
-    Qz = [Qz(:,(nu+1):nz) Qz(:,1:nu)]';
+    Qz = [Qz(:,(nu+1):nz), Qz(:,1:nu)]';
   endif
   Ru = Ru(1:nu,:);
 
   # can Dyw be transformed to become [0 I] or [I]?
   # This ensures a normalized weight
   [Qw, Ry] = qr(Dyw');
   irank = rank(Ry);
   if (irank != ny)
     retval = 0;
     warning(sprintf("*** rank(Dyw(%d x %d) = %d", ny, nw, irank));
     warning(" *** Dyw does not have full row rank.");
   endif
 
   if (ny >= nw)
     Qw = Qw(:,1:ny);
   else
-    Qw = [Qw(:,(ny+1):nw) Qw(:,1:ny)];
+    Qw = [Qw(:,(ny+1):nw), Qw(:,1:ny)];
   endif
   Ry = Ry(1:ny,:)';
 
   # transform P by Qz/Ru and Qw/Ry
   Bw  = Bw*Qw;
   Bu  = Bu/Ru;
-  B   = [Bw Bu];
+  B   = [Bw, Bu];
   Cz  = Qz*Cz;
   Cy  = Ry\Cy;
   C   = [Cz; Cy];
   Dzw = Qz*Dzw*Qw;
   Dzu = Qz*Dzu/Ru;
   Dyw = Ry\Dyw*Qw;
 
   # pack the return structure
diff --git a/scripts/control/lqg.m b/scripts/control/lqg.m
--- a/scripts/control/lqg.m
+++ b/scripts/control/lqg.m
@@ -99,21 +99,21 @@ endif
 m1 = columns(Sigw);
 m2 = m1+1;
 G = B(:,1:m1);
 B = B(:,m2:nin);
 
 # now we can just do the design; call dlqr and dlqe, since all matrices
 # are not given in Cholesky factor form (as in h2syn case)
 if(DIG)
-  [Ks P1 Er] = dlqr(A,B,Q,R);
-  [Ke Q1 jnk Ee] = dlqe(A,G,C,Sigw,Sigv);
+  [Ks, P1, Er] = dlqr(A,B,Q,R);
+  [Ke, Q1, jnk, Ee] = dlqe(A,G,C,Sigw,Sigv);
 else
-  [Ks P1 Er] = lqr(A,B,Q,R);
-  [Ke Q1 Ee] = lqe(A,G,C,Sigw,Sigv);
+  [Ks, P1, Er] = lqr(A,B,Q,R);
+  [Ke, Q1, Ee] = lqe(A,G,C,Sigw,Sigv);
 endif
 Ac = A - Ke*C - B*Ks;
 Bc = Ke;
 Cc = -Ks;
 Dc = zeros(rows(Cc),columns(Bc));
 
 # fix state names
 stname1 = strappend(stname,"_e");
diff --git a/scripts/control/mb.m b/scripts/control/mb.m
--- a/scripts/control/mb.m
+++ b/scripts/control/mb.m
@@ -14,41 +14,41 @@
 #
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, write to the Free
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 # I think that this m-file can be deleted
 # a.s.hodel@eng.auburn.edu - 4 Dec. 1998
 
-Ap = [0 1;1960 0];
+Ap = [0, 1;1960, 0];
 Bp = [0;-6261];
-Cp = [1 0];
+Cp = [1, 0];
 Dp = 0;
 
 Gp = ss2sys(Ap,Bp,Cp,Dp,0,2,0,[],"delta_i","delta_y");
 Gp = syssetsignals(Gp,"st","delta_x1",1);
 Gp = syssetsignals(Gp,"st","delta_x2",2);
 
-Ak = [-20 1;-22160 -200];
+Ak = [-20, 1;-22160, -200];
 Bk = [-20;-2160];
-Ck = [-3.5074 -0.0319];
+Ck = [-3.5074, -0.0319];
 Dk = 0;
 
 Gk = ss2sys(Ak,Bk,Ck,Dk,0,2,0,[],"y","i");
 Gk = syssetsignals(Gk,"st","x1",1);
 Gk = syssetsignals(Gk,"st","x2",2);
 
 Gc = sysgroup(Gp,Gk);
 
-Gc = sysdup(Gc,[],[1 2]);
+Gc = sysdup(Gc,[],[1, 2]);
 # Gc = sysscale(Gc,[],diag([1,1,1,1]));
 
-Gc = sysconnect(Gc,[1 2],[4 3]);
-Gc = sysprune(Gc,1,[1 2]);
+Gc = sysconnect(Gc,[1, 2],[4, 3]);
+Gc = sysprune(Gc,1,[1, 2]);
 
 disp("after pruning, closed loop system is")
 sysout(Gc)
 
 # Gc = sysdup(Gc,[],2);
 # Gc = sysconnect(Gc,1,3);
 # Gc = sysprune(Gc,1,1);
 
diff --git a/scripts/control/pzmap.m b/scripts/control/pzmap.m
--- a/scripts/control/pzmap.m
+++ b/scripts/control/pzmap.m
@@ -38,21 +38,21 @@ function [zer,pol]=pzmap(sys)
   endif
 
   [zer,pol] = sys2zp(sys);
 
   # force to column vectors, split into real, imaginary parts
   zerdata = poldata = [];
   if(length(zer))
     zer = reshape(zer,length(zer),1);
-    zerdata = [real(zer(:,1)) imag(zer(:,1))];
+    zerdata = [real(zer(:,1)), imag(zer(:,1))];
   endif
   if(length(pol))
     pol = reshape(pol,length(pol),1);
-    poldata = [real(pol(:,1)) imag(pol(:,1))];
+    poldata = [real(pol(:,1)), imag(pol(:,1))];
   endif
 
   # determine continuous or discrete plane
   vars = "sz";
   varstr = vars(is_digital(sys) + 1);
 
   # Plot the data
   gset nologscale xy;
diff --git a/scripts/control/rlocus.m b/scripts/control/rlocus.m
--- a/scripts/control/rlocus.m
+++ b/scripts/control/rlocus.m
@@ -47,17 +47,17 @@ function [rldata,k_break,rlpol,gvec,real
     usage("rlocus(sys[,inc,mink,maxk])");
   endif
   
   [num,den] = sys2tf(sys);		# extract numerator/denom polyomials
   lnum = length(num);      lden = length(den);
   if(lden < 2)
     error(sprintf("length of derivative=%d, doesn't make sense",lden));
   elseif(lnum == 1)
-    num = [0 num];     # so that derivative is shortened by one
+    num = [0, num];     # so that derivative is shortened by one
   endif
 
   # root locus plot axis limits
   
   # compute real axis locus breakpoints
   # compute the derivative of the numerator and the denominator 
   dern=polyderiv(num);        derd=polyderiv(den);
   
@@ -175,17 +175,17 @@ function [rldata,k_break,rlpol,gvec,real
   endwhile
    
   # Plot the data
   if(nargout  == 0)
     rlpolv = vec(rlpol);
     idx = find(real(rlpolv) >= xmin & real(rlpolv) <= xmax);
     axdata = [real(rlpolv(idx)),imag(rlpolv(idx))];
     axlim = axis2dlim(axdata);
-    axlim(1:2) = [xmin xmax];
+    axlim(1:2) = [xmin, xmax];
     gset nologscale xy;
     grid("on");
     rldata = [real(rlpolv), imag(rlpolv) ];
     axis(axlim);
     [stn,inname,outname] = sysgetsignals(sys);
     xlabel(sprintf("Root locus from %s to %s, gain=[%f,%f]: Real axis", ...
 	nth(inname,1),nth(outname,1),gvec(1),gvec(ngain)));
     ylabel("Imag. axis");
diff --git a/scripts/control/series.m b/scripts/control/series.m
--- a/scripts/control/series.m
+++ b/scripts/control/series.m
@@ -74,19 +74,19 @@ function [a,b,c,d] = series(a1,b1,c1,d1,
 # of inputs of system2
 
    if(p1 ~= m2)
      error("System 1 output / System 2 input connection sizes do not match");
    endif
 
 # put the two state space systems in series
 
-    a = [a1 zeros(rows(a1),columns(a2));b2*c1 a2];
+    a = [a1, zeros(rows(a1),columns(a2));b2*c1, a2];
     b = [b1;b2*d1];
-    c = [d2*c1 c2];
+    c = [d2*c1, c2];
     d = [d2*d1];
 
 # take care of mu output
 
     if(muflag == 1)
       a=ss2sys(a,b,c,d);
       b=c=d=0;
     endif 
diff --git a/scripts/control/ss2sys.m b/scripts/control/ss2sys.m
--- a/scripts/control/ss2sys.m
+++ b/scripts/control/ss2sys.m
@@ -136,17 +136,17 @@ function  retsys = ss2sys  (a,b,c,d,tsam
   retsys.d = d;
 
   retsys.n = n;
   retsys.nz = nz;
   retsys.tsam = tsam;
   retsys.yd = zeros(1,p);     # default value entered below
 
   #  Set the system vector:  active = 2(ss), updated = [0 0 1];
-  retsys.sys = [2 0 0 1]; 
+  retsys.sys = [2, 0, 0, 1]; 
 
   retsys.stname = sysdefstname(n,nz);
   retsys.inname = sysdefioname(m,"u");
   retsys.outname = sysdefioname(p,"y");
 
   # check for state names
   if(nargin >= 8)
     if(!isempty(stname)) retsys = syssetsignals(retsys,"st",stname); endif
diff --git a/scripts/control/starp.m b/scripts/control/starp.m
--- a/scripts/control/starp.m
+++ b/scripts/control/starp.m
@@ -62,18 +62,18 @@ function [sys] = starp(P, K, ny, nu);
   np = n + nz;
   K = sysupdate(K, "ss");
   [n, nz, mk, pk] = sysdimensions(K);
   nk = n + nz;
   ny_sign = 1;
   nu_sign = 1;
   if (nargin == 2)
     # perform a LFT of P and K (upper or lower)
-    ny = min([pp mk]);
-    nu = min([pk mp]);
+    ny = min([pp, mk]);
+    nu = min([pk, mp]);
   else
     if (ny < 0)
       ny = -ny;
       ny_sign = -1;
     endif
     if (nu < 0)
       nu = -nu;
       nu_sign = -1;
@@ -99,21 +99,21 @@ function [sys] = starp(P, K, ny, nu);
     error("---> no inputs left for star product.");
   endif
   if ((nzp + nzk) < 1)
     error("---> no outputs left for star product.");
   endif
 
   # checks done, form sys
   if (nzp)  Olst = [1:nzp];  endif
-  if (nzk)  Olst = [Olst pp+nu+1:pp+pk];  endif
+  if (nzk)  Olst = [Olst, pp+nu+1:pp+pk];  endif
   if (nwp)  Ilst = [1:nwp];  endif
-  if (nwk)  Ilst = [Ilst mp+ny+1:mp+mk];  endif
+  if (nwk)  Ilst = [Ilst, mp+ny+1:mp+mk];  endif
   Clst = zeros(ny+nu,2);
   for ii = 1:nu
-    Clst(ii,:) = [nwp+ii nu_sign*(pp+ii)];
+    Clst(ii,:) = [nwp+ii, nu_sign*(pp+ii)];
   endfor
   for ii = 1:ny
-    Clst(nu+ii,:) = [mp+ii ny_sign*(nzp+ii)];
+    Clst(nu+ii,:) = [mp+ii, ny_sign*(nzp+ii)];
   endfor
   sys = buildssic(Clst,[],Olst,Ilst,P,K);
 
 endfunction
diff --git a/scripts/control/sysadd.m b/scripts/control/sysadd.m
--- a/scripts/control/sysadd.m
+++ b/scripts/control/sysadd.m
@@ -87,11 +87,11 @@ function sys = sysadd(Gsys,Hsys)
   Hsys = syssetsignals(Hsys,"in",sysdefioname(length(Hin),"Hin_u"));
   Hsys = syssetsignals(Hsys,"out",sysdefioname(length(Hout),"Hout_u"));
   
   sys = sysgroup(Gsys,Hsys);
 
   eyin = eye(mg);
   eyout = eye(pg);
 
-  sys = sysscale(sys,[eyout eyout],[eyin;eyin],Gout,Gin);
+  sys = sysscale(sys,[eyout, eyout],[eyin;eyin],Gout,Gin);
 
 endfunction
diff --git a/scripts/control/sysconnect.m b/scripts/control/sysconnect.m
--- a/scripts/control/sysconnect.m
+++ b/scripts/control/sysconnect.m
@@ -200,17 +200,17 @@ function sys = sysconnect(sys,output_lis
   endif
   if(p1 > 0)
     C1c  = C1+D12*C2h;
     D12c = D12*(eye(size(D22h))+D22h);
   endif
 
   # construct system data structure
   if(m1 > 0)
-   Bc = [B1c B2c];
+   Bc = [B1c, B2c];
   else
    Bc = B2c;
   endif
 
   if(p1 > 0)
     Cc = [C1c;C2h];
   else
     Cc = C2h;
diff --git a/scripts/control/tf2sys.m b/scripts/control/tf2sys.m
--- a/scripts/control/tf2sys.m
+++ b/scripts/control/tf2sys.m
@@ -61,17 +61,17 @@ function outsys = tf2sys(num,den,tsam,in
   if ( (! (is_scalar(tsam) && (imag(tsam) == 0) )) || (tsam < 0) )
     error('tsam must be a positive real scalar')
   endif
 
   outsys.num = num;
   outsys.den = den;
 
   #  Set the system vector:  active = 0(tf), updated = [1 0 0];
-  outsys.sys = [0 1 0 0];
+  outsys.sys = [0, 1, 0, 0];
 
   #  Set defaults
   outsys.tsam = tsam;
   outsys.n = length(den)-1;
   outsys.nz = 0;
   outsys.yd = 0;	# assume discrete-time
   # check discrete time
   if(tsam > 0)
diff --git a/scripts/control/tzero.m b/scripts/control/tzero.m
--- a/scripts/control/tzero.m
+++ b/scripts/control/tzero.m
@@ -62,36 +62,36 @@ function [zer, gain] = tzero(A,B,C,D)
     gain = D;
     return;
   endif
 
   # First, balance the system via the zero computation generalized eigenvalue
   # problem balancing method (Hodel and Tiller, Linear Alg. Appl., 1992)
 
   Asys = zgpbal(Asys); [A,B,C,D] = sys2ss(Asys);   # balance coefficients
-  meps = 2*eps*norm([A B; C D],'fro');
+  meps = 2*eps*norm([A, B; C, D],'fro');
   Asys = zgreduce(Asys,meps);  [A, B, C, D] = sys2ss(Asys); # ENVD algorithm
   if(!isempty(A))
     # repeat with dual system
     Asys = ss2sys(A', C', B', D');   Asys = zgreduce(Asys,meps);
 
     # transform back
     [A,B,C,D] = sys2ss(Asys);    Asys = ss2sys(A', C', B', D');
   endif
 
   zer = [];			# assume none
   [A,B,C,D] = sys2ss(Asys);
   if( !isempty(C) )
-    [W,r,Pi] = qr([C D]');
+    [W,r,Pi] = qr([C, D]');
     [nonz,ztmp] = zgrownorm(r,meps);
     if(nonz)
       # We can now solve the generalized eigenvalue problem.
       [pp,mm] = size(D);
       nn = rows(A);
-      Afm = [A , B ; C D] * W';
+      Afm = [A , B ; C, D] * W';
       Bfm = [eye(nn), zeros(nn,mm); zeros(pp,nn+mm)]*W';
 
       jdx = (mm+1):(mm+nn);
       Af = Afm(1:nn,jdx);
       Bf = Bfm(1:nn,jdx);
       zer = qz(Af,Bf);
     endif
   endif
diff --git a/scripts/control/zginit.m b/scripts/control/zginit.m
--- a/scripts/control/zginit.m
+++ b/scripts/control/zginit.m
@@ -69,17 +69,17 @@ function zz = zginit(a,b,c,d)
 
     # column of [b;d]
     bdidx = find(bd(:,i) != 0);
     bd_col_i = bd(bdidx,i);
     zz(i1) = sum(log(abs(bd_col_i)));
   endfor
 
   # zz part 3:
-  cd = [c d];
+  cd = [c, d];
   for i=1:pp
     i1 = i+nn+mm;
     cdidx = find(cd(i,:) != 0);
     cd_row_i = cd(i,cdidx);
     zz(i1) = -sum(log(abs(cd_row_i)));
   endfor
 
   # now set zz as log base 2
diff --git a/scripts/control/zp2ssg2.m b/scripts/control/zp2ssg2.m
--- a/scripts/control/zp2ssg2.m
+++ b/scripts/control/zp2ssg2.m
@@ -53,13 +53,13 @@ else
   # select two roots (they're all real)
   r1 = rvals(1);
   r2 = rvals(2);
   poly = [1, -(r1+r2), (r1*r2)];
   r1i = 1;  r2i = 2;
 endif
 
 # remove roots used
-idx = complement([r1i r2i],1:length(rvals));
+idx = complement([r1i, r2i],1:length(rvals));
 rvals = rvals(idx);
 
 endfunction
 
diff --git a/scripts/control/zp2sys.m b/scripts/control/zp2sys.m
--- a/scripts/control/zp2sys.m
+++ b/scripts/control/zp2sys.m
@@ -60,17 +60,17 @@ function  outsys = zp2sys (zer,pol,k,tsa
   endif
 
   #  Set the system transfer function
   outsys.zer = zer;
   outsys.pol = pol;
   outsys.k = k;
 
   #  Set the system vector:  active = 1, updated = [0 1 0];
-  outsys.sys = [1 0 1 0];
+  outsys.sys = [1, 0, 1, 0];
 
   #  Set defaults
   outsys.tsam = 0;
    outsys.n = length(pol);
   outsys.nz = 0;
   outsys.yd = 0;	# assume (for now) continuous time outputs
 
   #  Set the type of system
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -40,21 +40,21 @@ function y = rot90 (x, k)
   if (nargin == 1 || nargin == 2)
     k = rem (k, 4);
     if (k < 0)
       k = k + 4;
     endif
     if (k == 0)
       y = x;
     elseif (k == 1)
-      y = flipud (x');
+      y = flipud (x.');
     elseif (k == 2)
       y = flipud (fliplr (x));
     elseif (k == 3)
-      y = (flipud (x))';
+      y = (flipud (x)).';
     else
       error ("rot90: internal error!");
     endif
   else
     usage ("rot90 (x [, k])");
   endif
 
 endfunction
diff --git a/scripts/general/shift.m b/scripts/general/shift.m
--- a/scripts/general/shift.m
+++ b/scripts/general/shift.m
@@ -26,35 +26,39 @@
 ## Adapted-By: jwe
 
 function y = shift (x, b)
   
   if (nargin != 2)
     error ("usage: shift (X, b)");
   endif
 
-  [nr nc] = size (x);
+  [nr, nc] = size (x);
   
   if (nr == 0 || nc == 0)
     error ("shift: x must not be empty");
   elseif (nr == 1)
     x = x.';
     nr = nc;
     nc = 0;
   endif
 
   if (! (is_scalar (b) && b == round (b)))
     error ("shift: b must be an integer");
   endif
 
   if (b >= 0)
     b = rem (b, nr);
-    y = [x (nr - b + 1 : nr, :); x (1 : nr - b, :)];
+    t1 = x (nr-b+1:nr, :);
+    t2 = x (1:nr-b, :);
+    y = [t1; t2];
   elseif (b < 0)
     b = rem (abs (b), nr);
-    y = [x (b + 1 : nr, :); x (1 : b, :)];
+    t1 = x (b+1:nr, :)
+    t2 = x (1:b, :);
+    y = [t1; t2];
   endif
 
   if (nc == 0)
     y = reshape (y, 1, nr);
   endif
 
 endfunction
diff --git a/scripts/image/colormap.m b/scripts/image/colormap.m
--- a/scripts/image/colormap.m
+++ b/scripts/image/colormap.m
@@ -37,25 +37,40 @@ function cmap = colormap (map)
 
   global __current_color_map__ = gray ();
 
   if (nargin > 1)
     usage ("colormap (map)");
   endif
 
   if (nargin == 1)
+
     if (isstr (map))
       if (strcmp (map, "default"))
-        __current_color_map__ = gray ();
+        map = gray ();
       else
-        error ("invalid argument");
+	unwind_protect
+	  save_default_eval_print_flag = default_eval_print_flag;
+	  default_eval_print_flag = 0;
+	  map = eval (map);
+	unwind_protect_cleanup
+	  default_eval_print_flag = save_default_eval_print_flag;
+	end_unwind_protect
       endif
-    else
+    endif
+
+    if (! isempty (map))
+      if (columns (map) != 3)
+	error( "colormap: map must have 3 columns: [R,G,B]." );
+      endif
+      if (min (min (map)) < 0 || max (max (map)) > 1)
+        error( "colormap: map must have values in [0,1]." );
+      endif
       ## Set the new color map
       __current_color_map__ = map;
     endif
+
   endif
 
   ## Return current color map.
-
   cmap = __current_color_map__;
 
 endfunction
diff --git a/scripts/linear-algebra/cross.m b/scripts/linear-algebra/cross.m
--- a/scripts/linear-algebra/cross.m
+++ b/scripts/linear-algebra/cross.m
@@ -33,16 +33,16 @@ function z = cross (x, y)
 
     z = [x(2)*y(3) - x(3)*y(2); x(3)*y(1) - x(1)*y(3); x(1)*y(2) - x(2)*y(1)];
 
     x_nr = rows (x);
     y_nr = rows (y);
 
     if ((x_nr == y_nr && x_nr == 1)
  	|| (x_nr != y_nr && ! prefer_column_vectors))
-      z = z';
+      z = z.';
     endif
 
   else
     error ("cross: both x and y must be 3-dimensional vectors");
   endif
 
 endfunction
diff --git a/scripts/linear-algebra/dot.m b/scripts/linear-algebra/dot.m
--- a/scripts/linear-algebra/dot.m
+++ b/scripts/linear-algebra/dot.m
@@ -26,24 +26,24 @@ function z = dot (x, y)
     usage ("dot (x, y)");
   endif
 
   if (is_vector (x) && is_vector (y) && length (x) == length (y))
     [x_nr, x_nc] = size (x);
     [y_nr, y_nc] = size (y);
     if (x_nr == 1)
       if (y_nr == 1)
-	z = x * y';
+	z = x * y.';
       else
 	z = x * y;
       endif
     else
       if (y_nr == 1)
 	z = y * x;
       else
-	z = y' * x;
+	z = y.' * x;
       endif
     endif
   else
     error ("dot: both arguments must be vectors of the same length");
   endif
 
 endfunction
diff --git a/scripts/linear-algebra/norm.m b/scripts/linear-algebra/norm.m
--- a/scripts/linear-algebra/norm.m
+++ b/scripts/linear-algebra/norm.m
@@ -84,30 +84,28 @@ function retval = norm (x, p)
 
   else
 
     if (nargin == 2)
       if (isstr (p))
         if (strcmp (p, "fro"))
           retval = sqrt (sum (diag (x' * x)));
         elseif (strcmp (p, "inf"))
-          xp = x';
-          retval = max (sum (abs (real (xp)) + abs (imag (xp))));
+          retval = max (sum (abs (x')));
         else
           error ("norm: unrecognized norm");
         endif
       else
         if (p == 1)
-          retval = max (sum (abs (real (x)) + abs (imag (x))));
+          retval = max (sum (abs (x)));
         elseif (p == 2)
           s = svd (x);
           retval = s (1);
         elseif (p == Inf)
-          xp = x';
-          retval = max (sum (abs (real (xp)) + abs (imag (xp))));
+          retval = max (sum (abs (x')));
         endif
       endif
     elseif (nargin == 1)
       s = svd (x);
       retval = s (1);
     endif
 
   endif
diff --git a/scripts/linear-algebra/qrhouse.m b/scripts/linear-algebra/qrhouse.m
--- a/scripts/linear-algebra/qrhouse.m
+++ b/scripts/linear-algebra/qrhouse.m
@@ -12,17 +12,17 @@
 # FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 # for more details.
 #
 # You should have received a copy of the GNU General Public License
 # along with Octave; see the file COPYING.  If not, write to the Free
 # Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 function [hv,alph,kb] = qrhouse(VV,eps1)
-# function [hv,alph,kb] = qrhouse(VV,eps1)
+# function [hv,alph,kb] = qrhouse(VV{,eps1})
 # construct orthogonal basis of span(VV) with Householder vectors
 # Q R = VV; Q may be obtained via routine krygetq; R is upper triangular
 #   if all rows of VV are nonzero; otherwise it's a permuted uppert
 #   triangular matrix with zero rows matching those of VV.
 # Inputs: 
 #   VV: matrix
 #   eps1: zero threshhold; default: 0.  Used to check if a column
 #     of reduced R is already upper triangular; entries with magnitude
@@ -32,18 +32,20 @@ function [hv,alph,kb] = qrhouse(VV,eps1)
 #   alpha: vector of householder reflection values as returned by housh
 #   kb: computed rank of matrix
 # qrhouse is used in krylovb for block Arnoldi iteration
 #
 # Reference: Golub and Van Loan, MATRIX COMPUTATIONS, 2nd ed.
 
 # Written by A. S. Hodel, 1992
 
-if(nargin < 2)
-  usage("[hv,alph,kb] = qrhouse(VV,eps1)");
+if(nargin < 1 | nargin > 2)
+  usage("[hv,alph,kb] = qrhouse(VV{,eps1})");
+elseif(nargin == 1)     # default value for eps set to 0
+  eps1 = 0;
 endif
 
 
 # extract only those rows of VV that are nonzero
 if(is_vector(VV))	nzidx = find(abs(VV') > 0);
 else			nzidx = find(max(abs(VV')) > 0);    endif
 VVlen = rows(VV);	# remember original size
 
diff --git a/scripts/plot/__plr2__.m b/scripts/plot/__plr2__.m
--- a/scripts/plot/__plr2__.m
+++ b/scripts/plot/__plr2__.m
@@ -89,17 +89,17 @@ function __plr2__ (theta, rho, fmt)
 	theta = theta';
 	tmp = t_nr;
 	t_nr = t_nc;
 	t_nc = tmp;
       endif
       if (r_nr != t_nr)
 	error ("polar: vector and matrix sizes must match");
       endif
-      diag_r = diag (r);
+      diag_r = diag (rho);
       x = diag_r * cos (theta);
       y = diag_r * sin (theta);
       __plt2mv__ (x, y, fmt);
     elseif (is_matrix (rho))
       if (size (rho) != size (theta))
 	error ("polar: matrix dimensions must match");
       endif
       x = rho .* cos (theta);
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -61,12 +61,12 @@ function [p, yf] = polyfit (x, y, n)
     if (y_is_row_vector)
       yf = yf';
     endif
   endif
 
   p = flipud (p);
 
   if (! prefer_column_vectors)
-    p = p';
+    p = p.';
   endif
 
 endfunction
diff --git a/scripts/signal/arch_rnd.m b/scripts/signal/arch_rnd.m
--- a/scripts/signal/arch_rnd.m
+++ b/scripts/signal/arch_rnd.m
@@ -51,31 +51,31 @@ function y = arch_rnd (a, b, T)
     la = la + 1;
   endif
   lb = length (b);
   b  = reshape (b, 1, lb);
   if (lb == 1)
     b  = [b, 0];
     lb = lb + 1;
   endif
-  M  = max([la lb]);
+  M  = max([la, lb]);
   
   e  = zeros (T, 1);
   h  = zeros (T, 1);
   y  = zeros (T, 1);
   
   h(1) = a(1);
   e(1) = sqrt (h(1)) * randn;
   y(1) = b(1) + e(1);
   
   for t= 2 : M;
-    ta   = min ([t la]);
+    ta   = min ([t, la]);
     h(t) = a(1) + a(2:ta) * e(t-1:t-ta+1).^2;
     e(t) = sqrt (h(t)) * randn;
-    tb   = min ([t lb]);
+    tb   = min ([t, lb]);
     y(t) = b(1) + b(2:tb) * y(t-1:t-tb+1) + e(t);
   endfor
   if (T > M)
     for t = M+1 : T;
       h(t) = a(1) + a(2:la) * e(t-1:t-la+1).^2;
       e(t) = sqrt (h(t)) * randn;
       y(t) = b(1) + b(2:lb) * y(t-1:t-tb+1) + e(t);
     endfor
diff --git a/scripts/signal/autocov.m b/scripts/signal/autocov.m
--- a/scripts/signal/autocov.m
+++ b/scripts/signal/autocov.m
@@ -21,17 +21,17 @@
 ## If X is a matrix, the autocovariances of every single column are
 ## computed. 
 
 ## Author:  FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Compute autocovariances
   
 function retval = autocov (X, h)
   
-  [n c] = size (X);
+  [n, c] = size (X);
   
   if (is_vector (X))
     n = length (X);
     c = 1;
     X = reshape (X, n, 1);
   endif
   
   X = center (X);
diff --git a/scripts/signal/diffpara.m b/scripts/signal/diffpara.m
--- a/scripts/signal/diffpara.m
+++ b/scripts/signal/diffpara.m
@@ -39,17 +39,17 @@ function [d, D] = diffpara (X, a, b)
   if ((nargin < 1) || (nargin > 3))
     usage ("[d [, D]] = diffpara (X [, a [, b]])");
   else
     if is_vector (X)
       n = length (X);
       k = 1;
       X = reshape (X, n, 1);
     else
-      [n k] = size(X);
+      [n, k] = size(X);
     endif
     if (nargin == 1)
       a = 0.5 * sqrt (n);
       b = 1.5 * sqrt (n);
     elseif (nargin == 2)
       b = a;
       a = 1;
     endif
diff --git a/scripts/signal/hurst.m b/scripts/signal/hurst.m
--- a/scripts/signal/hurst.m
+++ b/scripts/signal/hurst.m
@@ -30,16 +30,16 @@ function H = hurst (x)
   endif
 
   if (is_scalar (x))
     error ("hurst:  x must not be a scalar")
   elseif is_vector (x)
     x = reshape (x, length (x), 1);
   end
     
-  [xr xc] = size (x);
+  [xr, xc] = size (x);
 
   s = std (x);
   w = cumsum (x - mean (x));
   RS = (max(w) - min(w)) ./ s;
   H = log (RS) / log (xr);
   
 endfunction
diff --git a/scripts/signal/periodogram.m b/scripts/signal/periodogram.m
--- a/scripts/signal/periodogram.m
+++ b/scripts/signal/periodogram.m
@@ -18,17 +18,17 @@
 ##
 ## For a data matrix x from a sample of size n, return the periodogram.
   
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description:  Compute the periodogram
 
 function retval = periodogram (x)
 
-  [r c] = size(x);
+  [r, c] = size(x);
 
   if (r == 1)
     r = c;
   endif
   
   retval = (abs (fft (x - mean (x)))) .^ 2 / r;
   
 endfunction
diff --git a/scripts/signal/spectral_adf.m b/scripts/signal/spectral_adf.m
--- a/scripts/signal/spectral_adf.m
+++ b/scripts/signal/spectral_adf.m
@@ -45,17 +45,17 @@ function retval = spectral_adf (c, win, 
   else
     win = [win, "_lw"];
     w = feval (win, cr, b);
   endif
       
   c = c .* w;
   
   retval = 2 * real (fft (c)) - c(1);
-  retval = [zeros (cr, 1) retval];
+  retval = [(zeros (cr, 1)), retval];
   retval(:, 1) = (0 : xr-1)' / xr;
   
 endfunction
     
 
   
 
 
diff --git a/scripts/signal/spectral_xdf.m b/scripts/signal/spectral_xdf.m
--- a/scripts/signal/spectral_xdf.m
+++ b/scripts/signal/spectral_xdf.m
@@ -47,17 +47,17 @@ function retval = spectral_xdf (X, win, 
     w = feval (win, xr, b);
   endif
   
   X = X - sum (X) / xr;
 
   retval = (abs (fft (X)) / xr).^2;
   retval = real (ifft (fft(retval) .* fft(w)));
   
-  retval = [zeros (xr, 1) retval];
+  retval = [(zeros (xr, 1)), retval];
   retval(:, 1) = (0 : xr-1)' / xr;
   
 endfunction
     
 
   
 
 
diff --git a/scripts/signal/spencer.m b/scripts/signal/spencer.m
--- a/scripts/signal/spencer.m
+++ b/scripts/signal/spencer.m
@@ -22,28 +22,28 @@
 ## Description:  Apply Spencer's 15-point MA filter
 
 function retval = spencer (X)
   
   if (nargin != 1)
     usage ("spencer (X)");
   endif
 
-  [xr xc] = size(X);
+  [xr, xc] = size(X);
   
   n = xr;
   c = xc;
   
   if (is_vector(X))
    n = length(X);
    c = 1;
    X = reshape(X, n, 1);
   endif
    
-  W = [ -3 -6 -5 3 21 46 67 74 67 46 21 3 -5 -6 -3 ] / 320;
+  W = [-3, -6, -5, 3, 21, 46, 67, 74, 67, 46, 21, 3, -5, -6, -3] / 320;
 
   retval = fftfilt (W, X);
   retval = [zeros(7,c); retval(15:n,:); zeros(7,c);];
   
   retval = reshape(retval, xr, xc);
   
 endfunction
 
diff --git a/scripts/signal/synthesis.m b/scripts/signal/synthesis.m
--- a/scripts/signal/synthesis.m
+++ b/scripts/signal/synthesis.m
@@ -25,17 +25,17 @@
 ## Description:  Recover a signal from its short-term Fourier transform
 
 function X = synthesis (Y, c)
   
   if (nargin != 2)
     usage ("X = synthesis (Y, c)");
   endif
   
-  [nr nc] = size (c);
+  [nr, nc] = size (c);
   if (nr * nc != 3)
     error ("synthesis:  c must contain exactly 3 elements");
   endif
   
   ## not necessary, enables better reading
   win = c(1);      
   inc = c(2);
   w_type = c(3);
diff --git a/scripts/statistics/distributions/wiener_rnd.m b/scripts/statistics/distributions/wiener_rnd.m
--- a/scripts/statistics/distributions/wiener_rnd.m
+++ b/scripts/statistics/distributions/wiener_rnd.m
@@ -37,10 +37,10 @@ function retval = wiener_rnd (t, d, n)
     n = 1000;
   elseif (nargin > 3)
     usage ("wiener_rnd (t [, d [,n]])");
   endif
 
   retval = randn (n * t, d);
   retval = cumsum (retval) / sqrt (n);
 
-  retval = [(1: n*t)' / n retval];
+  retval = [((1: n*t)' / n), retval];
 endfunction
diff --git a/scripts/statistics/models/logistic_regression.m b/scripts/statistics/models/logistic_regression.m
--- a/scripts/statistics/models/logistic_regression.m
+++ b/scripts/statistics/models/logistic_regression.m
@@ -61,34 +61,34 @@
 ## Uses the auxiliary functions logistic_regression_derivatives and
 ## logistic_regression_likelihood.
 
 function [theta, beta, dev, dl, d2l, p] ...
       = logistic_regression (y, x, print, theta, beta)
   
   ## check input
   y = round (vec (y)); 
-  [my ny] = size (y);   
+  [my, ny] = size (y);   
   if (nargin < 2)
     x = zeros (my, 0); 
   endif;
-  [mx nx] = size (x);
+  [mx, nx] = size (x);
   if (mx != my)
     error ("x and y must have the same number of observations");
   endif
   
   ## initial calculations
   x = -x;
   tol = 1e-6; incr = 10; decr = 2;
   ymin = min (y); ymax = max (y); yrange = ymax - ymin;
   z  = (y * ones (1, yrange)) == ((y * 0 + 1) * (ymin : (ymax - 1)));
   z1 = (y * ones (1, yrange)) == ((y * 0 + 1) * ((ymin + 1) : ymax));
   z  = z(:, any (z)); 
   z1 = z1 (:, any(z1)); 
-  [mz nz] = size (z);
+  [mz, nz] = size (z);
   
   ## starting values
   if (nargin < 3)
     print = 0; 
   endif;
   if (nargin < 4) 
     beta = zeros (nx, 1);     
   endif;
@@ -159,12 +159,12 @@ function [theta, beta, dev, dl, d2l, p] 
   endif
 
   if (nargout == 6)
     if (nx > 0)
       e = ((x * beta) * ones (1, nz)) + ((y * 0 + 1) * theta');
     else
       e = (y * 0 + 1) * theta';
     endif
-    gamma = diff ([(y * 0) exp (e) ./ (1 + exp (e)) (y * 0 + 1)]')';
+    gamma = diff ([(y * 0), (exp (e) ./ (1 + exp (e))), (y * 0 + 1)]')';
   endif
   
 endfunction
diff --git a/scripts/statistics/models/logistic_regression_derivatives.m b/scripts/statistics/models/logistic_regression_derivatives.m
--- a/scripts/statistics/models/logistic_regression_derivatives.m
+++ b/scripts/statistics/models/logistic_regression_derivatives.m
@@ -21,17 +21,17 @@
 ## Adapted-By:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Derivates of log-likelihood in logistic regression
 
 function [dl, d2l] ...
       = logistic_regression_derivatives (x, z, z1, g, g1, p)
   
   ## first derivative
   v = g .* (1 - g) ./ p; v1 = g1 .* (1 - g1) ./ p;
-  dlogp = [dmult (v, z) - dmult (v1, z1) dmult (v - v1, x)];
+  dlogp = [(dmult (v, z) - dmult (v1, z1)), (dmult (v - v1, x))];
   dl = sum (dlogp)';
 
   ## second derivative
   w = v .* (1 - 2 * g); w1 = v1 .* (1 - 2 * g1);
-  d2l = [z x]' * dmult (w, [z x]) - [z1 x]' * dmult (w1, [z1 x]) ...
+  d2l = [z, x]' * dmult (w, [z, x]) - [z1, x]' * dmult (w1, [z1, x]) ...
       - dlogp' * dlogp;
   
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/models/logistic_regression_likelihood.m b/scripts/statistics/models/logistic_regression_likelihood.m
--- a/scripts/statistics/models/logistic_regression_likelihood.m
+++ b/scripts/statistics/models/logistic_regression_likelihood.m
@@ -19,16 +19,16 @@
   
 ## Author:  Gordon K. Smyth <gks@maths.uq.oz.au>
 ## Adapted-By:  KH <Kurt.Hornik@ci.tuwien.ac.at>
 ## Description:  Likelihood in logistic regression
 
 function [g, g1, p, dev] ...
       = logistic_regression_likelihood (y, x, beta, z, z1)
   
-  e = exp ([z x] * beta); e1 = exp ([z1 x] * beta);
+  e = exp ([z, x] * beta); e1 = exp ([z1, x] * beta);
   g = e ./ (1 + e); g1 = e1 ./ (1 + e1);
   g = max (y == max (y), g); g1 = min (y > min(y), g1);
   
   p = g - g1;
   dev = -2 * sum (log (p));  
 
 endfunction
diff --git a/scripts/statistics/tests/chisquare_test_independence.m b/scripts/statistics/tests/chisquare_test_independence.m
--- a/scripts/statistics/tests/chisquare_test_independence.m
+++ b/scripts/statistics/tests/chisquare_test_independence.m
@@ -29,21 +29,21 @@
 ## Description:  Chi-square test for independence
 
 function [pval, chisq, df] = chisquare_test_independence (X)
 
   if (nargin != 1)
     usage ("chisquare_test_independence (X)");
   endif
   
-  [r s] = size (X);
-  df    = (r - 1) * (s - 1);
-  n     = sum (sum (X));
-  Y     = sum (X')' * sum (X) / n;
-  X     = (X - Y) .^2 ./ Y;
+  [r, s] = size (X);
+  df = (r - 1) * (s - 1);
+  n = sum (sum (X));
+  Y = sum (X')' * sum (X) / n;
+  X = (X - Y) .^2 ./ Y;
   chisq = sum (sum (X));
   pval  = 1 - chisquare_cdf (chisq, df);
   
   if (nargout == 0)
     printf("  pval:  %g\n", pval);
   endif
 
 endfunction
\ No newline at end of file
diff --git a/scripts/statistics/tests/run_test.m b/scripts/statistics/tests/run_test.m
--- a/scripts/statistics/tests/run_test.m
+++ b/scripts/statistics/tests/run_test.m
@@ -26,22 +26,22 @@
 ## Description:  Run test for independence
   
 function [pval, chisq] = run_test (x)
 
   if (nargin != 1)
     usage ("run_test (x)");
   endif
 
-  A = [ 4529.4 9044.9 13568 18091 22615 27892
-      9044.4 18097 27139 36187 45234 55789
-      13568 27139 40721 54281 67852 83685
-      18091 36187 54281 72414 90470 111580
-      22615 45234 67852 90470 113262 139476
-      27892 55789 83685 111580 139476 172860 ];
+  A = [4529.4,  9044.9, 13568,  18091,  22615,  27892;
+       9044.4, 18097,   27139,  36187,  45234,  55789;
+      13568,   27139,   40721,  54281,  67852,  83685;
+      18091,   36187,   54281,  72414,  90470, 111580;
+      22615,   45234,   67852,  90470, 113262, 139476;
+      27892,   55789,   83685, 111580, 139476, 172860];
 
   b = [1/6; 5/24; 11/120; 19/720; 29/5040; 1/840];
   
   n = rows (x);
   r = run_count (x, 6) - n * b * ones (1, columns(x));
 
   chisq = diag (r' * A * r)' / n;
   pval  = chisquare_cdf (chisq, 6);
diff --git a/scripts/strings/split.m b/scripts/strings/split.m
--- a/scripts/strings/split.m
+++ b/scripts/strings/split.m
@@ -56,19 +56,19 @@ function m = split (s, t)
 
   limit = length (ind) - 1;
 
   for k = 1 : limit
 
     range = (ind (k) + l_t) : ind (k + 1) - 1;
 
     if (k != limit)
-      cmd = sprintf ("%s\"%s\", ", cmd, s (range));
+      cmd = sprintf ("%s\"%s\", ", cmd, undo_string_escapes (s (range)));
     else
-      cmd = sprintf ("%s\"%s\"", cmd, s (range));
+      cmd = sprintf ("%s\"%s\"", cmd, undo_string_escapes (s (range)));
     endif
 
   endfor
 
   m = eval (sprintf ("str2mat (%s);", cmd));
 
 
   else
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,40 @@
+Fri Mar 26 00:51:53 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* Makefile.in (libraries): Use the libfoo.a(objects) method of
+	creating static libs.
+
+	* defaults.cc (symbols_of_defaults): Initialize LOADPATH to
+	Vload_path, not ":".
+
+Thu Mar 18 12:09:23 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* data.cc (Fisnumeric): Fix typo.
+
+Thu Mar  4 02:17:04 1999  James Macnicol <jamesm@evans.ee.adfa.oz.au>
+
+	* file-io.cc (Ffread, Ffwrite): Add uint16 and uint32 data types
+	to doc string.
+
+Wed Mar  3 11:55:17 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* lex.l (handle_string): Allow "" to pass through unchanged if
+	working on a gset command.
+
+Tue Mar  2 01:36:29 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* variables.cc (Fexist): If a variable isn't defined, only go on
+	to look for a global by the same name if we are at the top level.
+
+Fri Jan 29 02:18:36 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* version.h (OCTAVE_NAME_AND_VERSION): Say `GNU Octave', not just
+	Octave.
+
 Thu Jan 28 21:29:16 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* toplev.cc (Fcomputer): Use CANONICAL_HOST_TYPE, not TARGET_HOST_TYPE.
 	(octave_config_info): Likewise.
 	* version.h: Ditto.
 
 	* sysdep.cc (Fpause): Flush output before getting user input.
 
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -220,23 +220,23 @@ pic:
 	  true; \
 	else \
 	  echo "mkdir pic"; \
 	  mkdir pic; \
 	fi
 
 ifeq ($(SHARED_LIBS), true)
   ifeq ($(STATIC_LIBS), true)
-    libraries: liboctinterp.$(LIBEXT) liboctinterp.$(SHLEXT)
+    libraries: liboctinterp.$(LIBEXT)($(OBJECTS)) liboctinterp.$(SHLEXT)
   else
     libraries: liboctinterp.$(SHLEXT)
   endif
 else
   ifeq ($(STATIC_LIBS), true)
-    libraries: liboctinterp.$(LIBEXT)
+    libraries: liboctinterp.$(LIBEXT)($(OBJECTS))
   else
     libraries:
   endif
 endif
 .PHONY: libraries
 
 liboctinterp.$(LIBEXT): $(OBJECTS)
 	$(AR) $(ARFLAGS) $@ $^
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -804,17 +804,17 @@ DEFUN (isempty, args, ,
 DEFUN (isnumeric, args, ,
   "isnumeric (x): return nonzero if x is a numeric object")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_numeric_type () ? 1.0 : 0.0;
   else
-    print_usage ("is_list");
+    print_usage ("isnumeric");
 
   return retval;
 }
 
 DEFUN (is_list, args, ,
   "is_list (x): return nonzero if x is a list")
 {
   octave_value retval;
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -416,17 +416,17 @@ void
 symbols_of_defaults (void)
 {
   DEFVAR (EDITOR, Veditor, 0, editor,
     "name of the editor to be invoked by the edit_history command");
 
   DEFVAR (EXEC_PATH, Vexec_path, 0, exec_path,
     "colon separated list of directories to search for programs to run");
 
-  DEFVAR (LOADPATH, ":", 0, loadpath,
+  DEFVAR (LOADPATH, Vload_path, 0, loadpath,
     "colon separated list of directories to search for scripts.\n\
 The default value is \":\", which means to search the default list\n\
 of directories.  The default list of directories may be found in\n\
 the built-in constant DEFAULT_LOADPATH");
 
   DEFCONST (DEFAULT_LOADPATH, Vdefault_load_path,
     "the default colon separated list of directories to search for scripts");
   
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -930,17 +930,19 @@ Reads data in binary form of type PRECIS
    ushort, unsigned short         --  unsigned short integer\n\
    int                            --  integer\n\
    uint, unsigned int             --  unsigned integer\n\
    long                           --  long integer\n\
    ulong, unsigned long           --  unsigned long integer\n\
    float, float32, real*4         --  single precision float\n\
    double, float64, real*8        --  double precision float\n\
    int16, integer*2               --  two byte integer\n\
+   uint16                         --  two byte unsigned integer\n\
    int32, integer*4               --  four byte integer\n\
+   uint32                         --  four byte unsigned integer\n\
 \n\
   SKIP      : number of bytes to skip after each element is read\n\
               (default is 0)\n\
 \n\
   ARCH      : string specifying the data format for the file.  Valid\n\
               values are\n\
 \n\
     native   --  the format of the current machine (default)\n\
@@ -1062,17 +1064,19 @@ DEFUN (fwrite, args, ,
    ushort, unsigned short         --  unsigned short integer\n\
    int                            --  integer\n\
    uint, unsigned int             --  unsigned integer\n\
    long                           --  long integer\n\
    ulong, unsigned long           --  unsigned long integer\n\
    float, float32, real*4         --  single precision float\n\
    double, float64, real*8        --  double precision float\n\
    int16, integer*2               --  two byte integer\n\
+   uint16                         --  two byte unsigned integer\n\
    int32, integer*4               --  four byte integer\n\
+   uint32                         --  four byte unsigned integer\n\
 \n\
   SKIP      : number of bytes to skip before each element is written\n\
               (the default is 0)\n\
 \n\
   ARCH      : string specifying the data format for the file.  Valid\n\
               values are\n\
 \n\
     native   --  the format of the current machine (default)\n\
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -1596,18 +1596,17 @@ handle_string (char delim, int text_styl
 		  yyunput (c, yytext);
 		  buf << ends;
 		  char *t = buf.str ();
 		  string s = do_string_escapes (t);
 		  delete [] t;
 
 		  if (text_style && lexer_flags.doing_set)
 		    {
-		      if (! s.empty ())
-			s = string (1, delim) + s + string (1, delim);
+		      s = string (1, delim) + s + string (1, delim);
 		    }
 		  else
 		    {
 		      lexer_flags.quote_is_transpose = true;
 		      lexer_flags.cant_be_identifier = true;
 		      lexer_flags.convert_spaces_to_comma = true;
 		    }
 
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -269,24 +269,24 @@ verbose_usage (void)
 Usage: octave [options]\n\
 \n\
 Options:\n\
 \n\
   --debug, -d             Enter parser debugging mode.\n\
   --echo-commands, -x     Echo commands as they are executed.\n\
   --exec-path PATH        Set path for executing subprograms.\n\
   --help, -h, -?          Print short help message and exit.\n\
-  --norc, -f              Don't read any initialization files.\n\
   --info-file FILE        Use top-level info file FILE.\n\
   --info-program PROGRAM  Use PROGRAM for reading info files.\n\
   --interactive, -i       Force interactive behavior.\n\
   --no-history, -H        Don't save commands to the history list\n\
   --no-init-file          Don't read the ~/.octaverc or .octaverc files.\n\
   --no-line-editing       Don't use readline for command-line editing.\n\
   --no-site-file          Don't read the site-wide octaverc file.\n\
+  --norc, -f              Don't read any initialization files.\n\
   --path PATH, -p PATH    Set initial LOADPATH to PATH.\n\
   --silent, -q            Don't print message at startup.\n\
   --traditional           Set compatibility variables.\n\
   --verbose, -V           Enable verbose output in some cases.\n\
   --version, -v           Print version number and exit.\n\
 \n\
   FILE                    Execute commands from FILE.\n\
 \n\
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -437,17 +437,18 @@ and stat instead.")
 
   if (pos != NPOS && pos > 0)
     {
       struct_elts = name.substr (pos+1);
       symbol_name = name.substr (0, pos);
     }
 
   symbol_record *sr = curr_sym_tab->lookup (symbol_name);
-  if (! (sr && sr->is_defined ()))
+  if (! (sr && (sr->is_defined ()
+		|| (curr_sym_tab != top_level_sym_tab))))
     sr = global_sym_tab->lookup (symbol_name);
 
   retval = 0.0;
 
   if (sr && sr->is_variable () && sr->is_defined ())
     {
       if (struct_elts.empty () || sr->is_map_element (struct_elts))
 	retval = 1.0;
diff --git a/src/version.h b/src/version.h
--- a/src/version.h
+++ b/src/version.h
@@ -24,17 +24,17 @@ Software Foundation, 59 Temple Place - S
 #define octave_version_h 1
 
 #define OCTAVE_VERSION "2.1.13"
 
 #define OCTAVE_COPYRIGHT \
   "Copyright (C) 1996, 1997, 1998 John W. Eaton."
 
 #define OCTAVE_NAME_AND_VERSION \
-  "Octave, version " OCTAVE_VERSION " (" CANONICAL_HOST_TYPE ")"
+  "GNU Octave, version " OCTAVE_VERSION " (" CANONICAL_HOST_TYPE ")"
 
 #define OCTAVE_NAME_VERSION_AND_COPYRIGHT \
   OCTAVE_NAME_AND_VERSION ".\n" OCTAVE_COPYRIGHT "\n\
 This is free software with ABSOLUTELY NO WARRANTY."
 
 #define OCTAVE_STARTUP_MESSAGE \
   OCTAVE_NAME_VERSION_AND_COPYRIGHT "\n\
 For details, type `warranty'.\n\
