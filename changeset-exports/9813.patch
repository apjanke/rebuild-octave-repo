# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1258109139 -3600
#      Fri Nov 13 11:45:39 2009 +0100
# Node ID 8fa32b527d9acc7d3fc02b6d730ae6ab45f808c4
# Parent  f80c566bc751d302eca2cf326a177e2399ef507e
improve & partially revert previous change

diff --git a/src/Cell.cc b/src/Cell.cc
--- a/src/Cell.cc
+++ b/src/Cell.cc
@@ -261,29 +261,25 @@ Cell::insert (const Cell& a, octave_idx_
 Cell&
 Cell::insert (const Cell& a, const Array<octave_idx_type>& ra_idx)
 {
   Array<octave_value>::insert (a, ra_idx);
   return *this;
 }
 
 Cell
-Cell::map (unary_mapper_t umap) const
+Cell::map (ctype_mapper fcn) const
 {
   Cell retval (dims ());
   octave_value *r = retval.fortran_vec ();
 
   const octave_value *p = data ();
 
   for (octave_idx_type i = 0; i < numel (); i++)
-    {
-      r[i] = p[i].map (umap);
-      if (error_state)
-        break;
-    }
+    r[i] = ((p++)->*fcn) ();
 
   return retval;
 }
 
 Cell
 Cell::diag (octave_idx_type k) const
 {
   return Array<octave_value>::diag (k);
diff --git a/src/Cell.h b/src/Cell.h
--- a/src/Cell.h
+++ b/src/Cell.h
@@ -99,17 +99,37 @@ public:
   // FIXME
   bool any_element_is_nan (void) const { return false; }
   bool is_true (void) const { return false; }
 
   static octave_value resize_fill_value (void) { return Matrix (); }
 
   Cell diag (octave_idx_type k = 0) const;
 
-  Cell map (unary_mapper_t umap) const;
+  Cell xisalnum (void) const { return map (&octave_value::xisalnum); }
+  Cell xisalpha (void) const { return map (&octave_value::xisalpha); }
+  Cell xisascii (void) const { return map (&octave_value::xisascii); }
+  Cell xiscntrl (void) const { return map (&octave_value::xiscntrl); }
+  Cell xisdigit (void) const { return map (&octave_value::xisdigit); }
+  Cell xisgraph (void) const { return map (&octave_value::xisgraph); }
+  Cell xislower (void) const { return map (&octave_value::xislower); }
+  Cell xisprint (void) const { return map (&octave_value::xisprint); }
+  Cell xispunct (void) const { return map (&octave_value::xispunct); }
+  Cell xisspace (void) const { return map (&octave_value::xisspace); }
+  Cell xisupper (void) const { return map (&octave_value::xisupper); }
+  Cell xisxdigit (void) const { return map (&octave_value::xisxdigit); }
+  Cell xtoascii (void) const { return map (&octave_value::xtoascii); }
+  Cell xtolower (void) const { return map (&octave_value::xtolower); }
+  Cell xtoupper (void) const { return map (&octave_value::xtoupper); }
+
+private:
+
+  typedef octave_value (octave_value::*ctype_mapper) (void) const;
+
+  Cell map (ctype_mapper) const;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,23 @@
+2009-11-13  Jaroslav Hajek  <highegg@gmail.com>
+
+	* ov-base.h (unary_mapper_t): Move to octave_base_value.
+	* ov.h: Partially revert to c657c056240d.
+	(FORWARD_MAPPER): Update to use octave_base_value::map.
+	(octave_value::map): Ditto.
+	* mappers.cc: Revert to c657c056240d.
+	* data.cc: Ditto.
+	* Cell.h, Cell.cc: Ditto.
+	* ov-cell.cc (octave_cell::map): Rewrite.
+	* ov-base-sparse.cc (octave_base_sparse::map): New method.
+	* ov-base-sparse.h: Declare it.
+	* ov-re-sparse.cc (octave_sparse_matrix::map): Use it as a fallback.
+	* ov-cx-sparse.cc (octave_sparse_complexmatrix::map): Ditto.
+
 2009-11-12  Jaroslav Hajek  <highegg@gmail.com>
 
 	* ov-base.h (unary_mapper_t): New enum.
 	(octave_base_value::map (unary_mapper_t)): New method.
 	(octave_base_value::abs): Remove.
 	(octave_base_value::acos): Remove.
 	(octave_base_value::acosh): Remove.
 	(octave_base_value::angle): Remove.
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/DLD-FUNCTIONS/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/DLD-FUNCTIONS/lookup.cc
@@ -222,20 +222,20 @@ For string lookup, 'i' indicates case-in
 
   if (num_case) 
     {
 
       // In the case of a complex array, absolute values will be used for compatibility
       // (though it's not too meaningful).
       
       if (table.is_complex_type ())
-        table = table.map (umap_abs);
+        table = table.abs ();
 
       if (y.is_complex_type ())
-        y = y.map (umap_abs);
+        y = y.abs ();
 
       Array<octave_idx_type> idx;
 
       // PS: I learned this from data.cc
       if INT_ARRAY_LOOKUP (int8)
       else if INT_ARRAY_LOOKUP (int16)
       else if INT_ARRAY_LOOKUP (int32)
       else if INT_ARRAY_LOOKUP (int64)
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -973,16 +973,130 @@ avoids overflows for large values of @va
 %!assert (size (hypot (rand (2, 3, 4), zeros (2, 3, 4))), [2, 3, 4])
 %!assert (size (hypot (rand (2, 3, 4), 1)), [2, 3, 4])
 %!assert (size (hypot (1, rand (2, 3, 4))), [2, 3, 4])
 %!assert (size (hypot (1, 2)), [1, 1])
 %!assert (hypot (1:10, 1:10), sqrt(2) * [1:10], 16*eps)
 %!assert (hypot (single(1:10), single(1:10)), single(sqrt(2) * [1:10]));
 */
 
+template<typename T, typename ET>
+void 
+map_2_xlog2 (const Array<T>& x, Array<T>& f, Array<ET>& e)
+{
+  f = Array<T>(x.dims ());
+  e = Array<ET>(x.dims ());
+  for (octave_idx_type i = 0; i < x.numel (); i++)
+    {
+      int exp;
+      f.xelem (i) = xlog2 (x(i), exp);
+      e.xelem (i) = exp;
+    }
+}
+
+DEFUN (log2, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} log2 (@var{x})\n\
+@deftypefnx {Mapping Function} {[@var{f}, @var{e}] =} log2 (@var{x})\n\
+Compute the base-2 logarithm of each element of @var{x}.\n\
+\n\
+If called with two output arguments, split @var{x} into\n\
+binary mantissa and exponent so that\n\
+@tex\n\
+${1 \\over 2} \\le \\left| f \\right| < 1$\n\
+@end tex\n\
+@ifnottex\n\
+@code{1/2 <= abs(f) < 1}\n\
+@end ifnottex\n\
+and @var{e} is an integer.  If\n\
+@tex\n\
+$x = 0$, $f = e = 0$.\n\
+@end tex\n\
+@ifnottex\n\
+@code{x = 0}, @code{f = e = 0}.\n\
+@end ifnottex\n\
+@seealso{pow2, log, log10, exp}\n\
+@end deftypefn")
+{
+  octave_value_list retval;
+
+  if (args.length () == 1)
+    {
+      if (nargout < 2)
+        retval(0) = args(0).log2 ();
+      else if (args(0).is_single_type ())
+	{
+	  if (args(0).is_real_type ())
+	    {
+	      FloatNDArray f;
+	      FloatNDArray x = args(0).float_array_value ();
+	      // FIXME -- should E be an int value?
+	      FloatMatrix e;
+	      map_2_xlog2 (x, f, e);
+	      retval (1) = e;
+	      retval (0) = f;
+	    }
+	  else if (args(0).is_complex_type ())
+	    {
+	      FloatComplexNDArray f;
+	      FloatComplexNDArray x = args(0).float_complex_array_value ();
+	      // FIXME -- should E be an int value?
+	      FloatNDArray e;
+	      map_2_xlog2 (x, f, e);
+	      retval (1) = e;
+	      retval (0) = f;
+	    }
+	}
+      else if (args(0).is_real_type ())
+        {
+          NDArray f;
+          NDArray x = args(0).array_value ();
+          // FIXME -- should E be an int value?
+          Matrix e;
+          map_2_xlog2 (x, f, e);
+          retval (1) = e;
+          retval (0) = f;
+        }
+      else if (args(0).is_complex_type ())
+        {
+          ComplexNDArray f;
+          ComplexNDArray x = args(0).complex_array_value ();
+          // FIXME -- should E be an int value?
+          NDArray e;
+          map_2_xlog2 (x, f, e);
+          retval (1) = e;
+          retval (0) = f;
+        }
+      else
+        gripe_wrong_type_arg ("log2", args(0));
+    }
+  else
+    print_usage ();
+
+  return retval;
+}
+
+/*
+%!assert(log2 ([1/4, 1/2, 1, 2, 4]), [-2, -1, 0, 1, 2]);
+%!assert(log2(Inf), Inf);
+%!assert(isnan(log2(NaN)));
+%!assert(log2(4*i), 2 + log2(1*i));
+%!assert(log2(complex(0,Inf)), Inf + log2(i));
+
+%!test
+%! [f, e] = log2 ([0,-1; 2,-4; Inf,-Inf]);
+%! assert (f, [0,-0.5; 0.5,-0.5; Inf,-Inf]);
+%! assert (e(1:2,:), [0,1;2,3])
+
+%!test
+%! [f, e] = log2 (complex (zeros (3, 2), [0,-1; 2,-4; Inf,-Inf]));
+%! assert (f, complex (zeros (3, 2), [0,-0.5; 0.5,-0.5; Inf,-Inf]));
+%! assert (e(1:2,:), [0,1; 2,3]);
+*/
+
 DEFUN (fmod, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} fmod (@var{x}, @var{y})\n\
 Compute the floating point remainder of dividing @var{x} by @var{y}\n\
 using the C library function @code{fmod}.  The result has the same\n\
 sign as @var{x}.  If @var{y} is zero, the result is implementation-dependent.\n\
 @seealso{mod, rem}\n\
 @end deftypefn")
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -30,17 +30,16 @@ along with Octave; see the file COPYING.
 
 #include "lo-ieee.h"
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "error.h"
 #include "variables.h"
-#include "gripes.h"
 
 DEFUN (abs, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} abs (@var{z})\n\
 Compute the magnitude of @var{z}, defined as\n\
 @tex\n\
 $|z| = \\sqrt{x^2 + y^2}$.\n\
 @end tex\n\
@@ -55,17 +54,17 @@ For example,\n\
 abs (3 + 4i)\n\
      @result{} 5\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_abs);
+    retval = args(0).abs ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -90,17 +89,17 @@ DEFUN (acos, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} acos (@var{x})\n\
 Compute the inverse cosine in radians for each element of @var{x}.\n\
 @seealso{cos, acosd}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_acos);
+    retval = args(0).acos ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -127,17 +126,17 @@ DEFUN (acosh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} acosh (@var{x})\n\
 Compute the inverse hyperbolic cosine for each element of @var{x}.\n\
 @seealso{cosh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_acosh);
+    retval = args(0).acosh ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -159,17 +158,17 @@ Compute the inverse hyperbolic cosine fo
 DEFUN (angle, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} angle (@var{z})\n\
 See arg.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_arg);
+    retval = args(0).arg ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (arg, args, ,
     "-*- texinfo -*-\n\
@@ -191,17 +190,17 @@ For example,\n\
 arg (3 + 4i)\n\
      @result{} 0.92730\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_arg);
+    retval = args(0).arg ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -226,17 +225,17 @@ DEFUN (asin, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} asin (@var{x})\n\
 Compute the inverse sine in radians for each element of @var{x}.\n\
 @seealso{sin, asind}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_asin);
+    retval = args(0).asin ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
@@ -253,17 +252,17 @@ DEFUN (asinh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} asinh (@var{x})\n\
 Compute the inverse hyperbolic sine for each element of @var{x}.\n\
 @seealso{sinh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_asinh);
+    retval = args(0).asinh ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -286,17 +285,17 @@ DEFUN (atan, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atan (@var{x})\n\
 Compute the inverse tangent in radians for each element of @var{x}.\n\
 @seealso{tan, atand}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_atan);
+    retval = args(0).atan ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -323,17 +322,17 @@ DEFUN (atanh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atanh (@var{x})\n\
 Compute the inverse hyperbolic tangent for each element of @var{x}.\n\
 @seealso{tanh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_atanh);
+    retval = args(0).atanh ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -364,17 +363,17 @@ ceil ([-2.7, 2.7])\n\
    @result{}  -2   3\n\
 @end group\n\
 @end example\n\
 @seealso{floor, round, fix}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_ceil);
+    retval = args(0).ceil ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -405,17 +404,17 @@ Return the complex conjugate of @var{z},
 @ifnottex\n\
 @code{conj (@var{z})} = @var{x} - @var{i}@var{y}.\n\
 @end ifnottex\n\
 @seealso{real, imag}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_conj);
+    retval = args(0).conj ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -440,17 +439,17 @@ DEFUN (cos, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cos (@var{x})\n\
 Compute the cosine for each element of @var{x} in radians.\n\
 @seealso{acos, cosd, cosh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_cos);
+    retval = args(0).cos ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -477,17 +476,17 @@ DEFUN (cosh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cosh (@var{x})\n\
 Compute the hyperbolic cosine for each element of @var{x}.\n\
 @seealso{acosh, sinh, tanh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_cosh);
+    retval = args(0).cosh ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -527,17 +526,17 @@ erf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n\
 @end group\n\
 @end example\n\
 @end ifnottex\n\
 @seealso{erfc, erfinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_erf);
+    retval = args(0).erf ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -579,17 +578,17 @@ Computes the complementary error functio
 @ifnottex\n\
 @code{1 - erf (@var{z})}.\n\
 @end ifnottex\n\
 @seealso{erf, erfinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_erfc);
+    retval = args(0).erfc ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -611,17 +610,17 @@ Compute\n\
 @end ifnottex\n\
 for each element of @var{x}.  To compute the matrix\n\
 exponential, see @ref{Linear Algebra}.\n\
 @seealso{log}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_exp);
+    retval = args(0).exp ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -649,17 +648,17 @@ Compute\n\
 @code{exp (@var{x}) - 1}\n\
 @end ifnottex\n\
 accurately in the neighborhood of zero.\n\
 @seealso{exp}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_expm1);
+    retval = args(0).expm1 ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (finite, args, ,
     "-*- texinfo -*-\n\
@@ -672,17 +671,17 @@ otherwise.  For example,\n\
 finite ([13, Inf, NA, NaN])\n\
      @result{} [ 1, 0, 0, 0 ]\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_finite);
+    retval = args(0).finite ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -708,17 +707,17 @@ fix ([-2.7, 2.7])\n\
    @result{} -2   2\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, floor, round}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_fix);
+    retval = args(0).fix ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -744,17 +743,17 @@ floor ([-2.7, 2.7])\n\
      @result{} -3   2\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, round, fix}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_floor);
+    retval = args(0).floor ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -789,17 +788,17 @@ gamma (z) = | t^(z-1) exp (-t) dt.\n\
 @end group\n\
 @end example\n\
 @end ifnottex\n\
 @seealso{gammainc, lgamma}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_gamma);
+    retval = args(0).gamma ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -830,17 +829,17 @@ DEFUN (imag, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} imag (@var{z})\n\
 Return the imaginary part of @var{z} as a real number.\n\
 @seealso{real, conj}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_imag);
+    retval = args(0).imag ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -863,79 +862,79 @@ DEFUNX ("isalnum", Fisalnum, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isalnum (@var{s})\n\
 Return 1 for characters that are letters or digits (@code{isalpha\n\
 (@var{s})} or @code{isdigit (@var{s})} is true).\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_isalnum);
+    retval = args(0).xisalnum ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("isalpha", Fisalpha, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isalpha (@var{s})\n\
 @deftypefnx {Mapping Function} {} isletter (@var{s})\n\
 Return true for characters that are letters (@code{isupper (@var{s})}\n\
 or @code{islower (@var{s})} is true).\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_isalpha);
+    retval = args(0).xisalpha ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("isascii", Fisascii, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isascii (@var{s})\n\
 Return 1 for characters that are ASCII (in the range 0 to 127 decimal).\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_isascii);
+    retval = args(0).xisascii ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("iscntrl", Fiscntrl, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} iscntrl (@var{s})\n\
 Return 1 for control characters.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_iscntrl);
+    retval = args(0).xiscntrl ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("isdigit", Fisdigit, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isdigit (@var{s})\n\
 Return 1 for characters that are decimal digits.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_isdigit);
+    retval = args(0).xisdigit ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (isinf, args, ,
     "-*- texinfo -*-\n\
@@ -948,17 +947,17 @@ otherwise.  For example,\n\
 isinf ([13, Inf, NA, NaN])\n\
      @result{} [ 0, 1, 0, 0 ]\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_isinf);
+    retval = args(0).isinf ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -979,32 +978,32 @@ isinf ([13, Inf, NA, NaN])\n\
 DEFUNX ("isgraph", Fisgraph, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isgraph (@var{s})\n\
 Return 1 for printable characters (but not the space character).\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_isgraph);
+    retval = args(0).xisgraph ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("islower", Fislower, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} islower (@var{s})\n\
 Return 1 for characters that are lower case letters.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_islower);
+    retval = args(0).xislower ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (isna, args, ,
     "-*- texinfo -*-\n\
@@ -1018,17 +1017,17 @@ isna ([13, Inf, NA, NaN])\n\
      @result{} [ 0, 0, 1, 0 ]\n\
 @end group\n\
 @end example\n\
 @seealso{isnan}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_isna);
+    retval = args(0).isna ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1058,17 +1057,17 @@ isnan ([13, Inf, NA, NaN])\n\
      @result{} [ 0, 0, 1, 1 ]\n\
 @end group\n\
 @end example\n\
 @seealso{isna}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_isnan);
+    retval = args(0).isnan ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1089,95 +1088,95 @@ isnan ([13, Inf, NA, NaN])\n\
 DEFUNX ("isprint", Fisprint, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isprint (@var{s})\n\
 Return 1 for printable characters (including the space character).\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_isprint);
+    retval = args(0).xisprint ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("ispunct", Fispunct, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} ispunct (@var{s})\n\
 Return 1 for punctuation characters.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_ispunct);
+    retval = args(0).xispunct ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("isspace", Fisspace, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isspace (@var{s})\n\
 Return 1 for whitespace characters (space, formfeed, newline,\n\
 carriage return, tab, and vertical tab).\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_isspace);
+    retval = args(0).xisspace ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("isupper", Fisupper, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isupper (@var{s})\n\
 Return 1 for upper case letters.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_isupper);
+    retval = args(0).xisupper ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("isxdigit", Fisxdigit, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isxdigit (@var{s})\n\
 Return 1 for characters that are hexadecimal digits.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_isxdigit);
+    retval = args(0).xisxdigit ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (lgamma, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} lgamma (@var{x})\n\
 @deftypefnx {Mapping Function} {} gammaln (@var{x})\n\
 Return the natural logarithm of the gamma function of @var{x}.\n\
 @seealso{gamma, gammainc}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_lgamma);
+    retval = args(0).lgamma ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1216,17 +1215,17 @@ Compute the natural logarithm,\n\
 @end ifnottex\n\
 for each element of @var{x}.  To compute the\n\
 matrix logarithm, see @ref{Linear Algebra}.\n\
 @seealso{exp, log1p, log2, log10, logspace}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_log);
+    retval = args(0).log ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1236,140 +1235,26 @@ matrix logarithm, see @ref{Linear Algebr
 %!assert(log (single([1, e, e^2])), single([0, 1, 2]), sqrt (eps('single')));
 %!assert(log (single([-0.5, -1.5, -2.5])), single(log([0.5, 1.5, 2.5]) + pi*1i), 4*eps('single'));
 
 %!error log ();
 %!error log (1, 2);
 
  */
 
-template<typename T, typename ET>
-void 
-map_2_xlog2 (const Array<T>& x, Array<T>& f, Array<ET>& e)
-{
-  f = Array<T>(x.dims ());
-  e = Array<ET>(x.dims ());
-  for (octave_idx_type i = 0; i < x.numel (); i++)
-    {
-      int exp;
-      f.xelem (i) = xlog2 (x(i), exp);
-      e.xelem (i) = exp;
-    }
-}
-
-DEFUN (log2, args, nargout,
-  "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} log2 (@var{x})\n\
-@deftypefnx {Mapping Function} {[@var{f}, @var{e}] =} log2 (@var{x})\n\
-Compute the base-2 logarithm of each element of @var{x}.\n\
-\n\
-If called with two output arguments, split @var{x} into\n\
-binary mantissa and exponent so that\n\
-@tex\n\
-${1 \\over 2} \\le \\left| f \\right| < 1$\n\
-@end tex\n\
-@ifnottex\n\
-@code{1/2 <= abs(f) < 1}\n\
-@end ifnottex\n\
-and @var{e} is an integer.  If\n\
-@tex\n\
-$x = 0$, $f = e = 0$.\n\
-@end tex\n\
-@ifnottex\n\
-@code{x = 0}, @code{f = e = 0}.\n\
-@end ifnottex\n\
-@seealso{pow2, log, log10, exp}\n\
-@end deftypefn")
-{
-  octave_value_list retval;
-
-  if (args.length () == 1)
-    {
-      if (nargout < 2)
-        retval(0) = args(0).map (umap_log2);
-      else if (args(0).is_single_type ())
-	{
-	  if (args(0).is_real_type ())
-	    {
-	      FloatNDArray f;
-	      FloatNDArray x = args(0).float_array_value ();
-	      // FIXME -- should E be an int value?
-	      FloatMatrix e;
-	      map_2_xlog2 (x, f, e);
-	      retval (1) = e;
-	      retval (0) = f;
-	    }
-	  else if (args(0).is_complex_type ())
-	    {
-	      FloatComplexNDArray f;
-	      FloatComplexNDArray x = args(0).float_complex_array_value ();
-	      // FIXME -- should E be an int value?
-	      FloatNDArray e;
-	      map_2_xlog2 (x, f, e);
-	      retval (1) = e;
-	      retval (0) = f;
-	    }
-	}
-      else if (args(0).is_real_type ())
-        {
-          NDArray f;
-          NDArray x = args(0).array_value ();
-          // FIXME -- should E be an int value?
-          Matrix e;
-          map_2_xlog2 (x, f, e);
-          retval (1) = e;
-          retval (0) = f;
-        }
-      else if (args(0).is_complex_type ())
-        {
-          ComplexNDArray f;
-          ComplexNDArray x = args(0).complex_array_value ();
-          // FIXME -- should E be an int value?
-          NDArray e;
-          map_2_xlog2 (x, f, e);
-          retval (1) = e;
-          retval (0) = f;
-        }
-      else
-        gripe_wrong_type_arg ("log2", args(0));
-    }
-  else
-    print_usage ();
-
-  return retval;
-}
-
-/*
-%!assert(log2 ([1/4, 1/2, 1, 2, 4]), [-2, -1, 0, 1, 2]);
-%!assert(log2(Inf), Inf);
-%!assert(isnan(log2(NaN)));
-%!assert(log2(4*i), 2 + log2(1*i));
-%!assert(log2(complex(0,Inf)), Inf + log2(i));
-
-%!test
-%! [f, e] = log2 ([0,-1; 2,-4; Inf,-Inf]);
-%! assert (f, [0,-0.5; 0.5,-0.5; Inf,-Inf]);
-%! assert (e(1:2,:), [0,1;2,3])
-
-%!test
-%! [f, e] = log2 (complex (zeros (3, 2), [0,-1; 2,-4; Inf,-Inf]));
-%! assert (f, complex (zeros (3, 2), [0,-0.5; 0.5,-0.5; Inf,-Inf]));
-%! assert (e(1:2,:), [0,1; 2,3]);
-*/
-
 DEFUN (log10, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log10 (@var{x})\n\
 Compute the base-10 logarithm of each element of @var{x}.\n\
 @seealso{log, log2, logspace, exp}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_log10);
+    retval = args(0).log10 ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1392,33 +1277,33 @@ Compute\n\
 @code{log (1 + @var{x})}\n\
 @end ifnottex\n\
 accurately in the neighborhood of zero.\n\
 @seealso{log, exp, expm1}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_log1p);
+    retval = args(0).log1p ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (real, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} real (@var{z})\n\
 Return the real part of @var{z}.\n\
 @seealso{imag, conj}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_real);
+    retval = args(0).real ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1448,17 +1333,17 @@ round ([-2.7, 2.7])\n\
      @result{} -3   3\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, floor, fix}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_round);
+    retval = args(0).round ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1489,17 +1374,17 @@ DEFUN (roundb, args, ,
 Return the integer nearest to @var{x}.  If there are two nearest\n\
 integers, return the even one (banker's rounding).  If @var{x} is complex,\n\
 return @code{roundb (real (@var{x})) + roundb (imag (@var{x})) * I}.\n\
 @seealso{round}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_roundb);
+    retval = args(0).roundb ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (sign, args, ,
     "-*- texinfo -*-\n\
@@ -1521,17 +1406,17 @@ sign (x) =  0, x = 0;\n\
 @end example\n\
 @end ifnottex\n\
 \n\
 For complex arguments, @code{sign} returns @code{x ./ abs (@var{x})}.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_signum);
+    retval = args(0).signum ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1554,17 +1439,17 @@ DEFUN (sin, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sin (@var{x})\n\
 Compute the sine for each element of @var{x} in radians.\n\
 @seealso{asin, sind, sinh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_sin);
+    retval = args(0).sin ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1591,17 +1476,17 @@ DEFUN (sinh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sinh (@var{x})\n\
 Compute the hyperbolic sine for each element of @var{x}.\n\
 @seealso{asinh, cosh, tanh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_sinh);
+    retval = args(0).sinh ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1626,17 +1511,17 @@ DEFUN (sqrt, args, ,
 Compute the square root of each element of @var{x}.  If @var{x} is negative,\n\
 a complex result is returned.  To compute the matrix square root, see\n\
 @ref{Linear Algebra}.\n\
 @seealso{realsqrt}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_sqrt);
+    retval = args(0).sqrt ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1659,17 +1544,17 @@ DEFUN (tan, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tan (@var{z})\n\
 Compute the tangent for each element of @var{x} in radians.\n\
 @seealso{atan, tand, tanh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_tan);
+    retval = args(0).tan ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1696,17 +1581,17 @@ DEFUN (tanh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tanh (@var{x})\n\
 Compute hyperbolic tangent for each element of @var{x}.\n\
 @seealso{atanh, sinh, cosh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_tanh);
+    retval = args(0).tanh ();
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1737,17 +1622,17 @@ toascii (\"ASCII\")\n\
 @end group\n\
 \n\
 @end example\n\
 @seealso{char}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_toascii);
+    retval = args(0).xtoascii ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("tolower", Ftolower, args, ,
     "-*- texinfo -*-\n\
@@ -1763,17 +1648,17 @@ tolower (\"MiXeD cAsE 123\")\n\
      @result{} \"mixed case 123\"\n\
 @end group\n\
 @end example\n\
 @seealso{toupper}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_tolower);
+    retval = args(0).xtolower ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (lower, tolower);
 
@@ -1809,17 +1694,17 @@ toupper (\"MiXeD cAsE 123\")\n\
      @result{} \"MIXED CASE 123\"\n\
 @end group\n\
 @end example\n\
 @seealso{tolower}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).map (umap_toupper);
+    retval = args(0).xtoupper ();
   else
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (upper, toupper);
 
diff --git a/src/ov-base-sparse.cc b/src/ov-base-sparse.cc
--- a/src/ov-base-sparse.cc
+++ b/src/ov-base-sparse.cc
@@ -364,13 +364,43 @@ octave_base_sparse<T>::load_ascii (std::
     {
       error ("load: failed to extract number of rows and columns");
       success = false;
     }
 
   return success;
 }
 
+template <class T>
+octave_value
+octave_base_sparse<T>::map (octave_base_value::unary_mapper_t umap) const
+{
+  // Try the map on the dense value.
+  octave_value retval = this->full_value ().map (umap);
+
+  // Sparsify the result if possible.
+  // FIXME: intentionally skip this step for string mappers. Is this wanted?
+  if (umap >= umap_xisalnum && umap <= umap_xtoupper)
+    return retval;
+
+  switch (retval.builtin_type ())
+    {
+    case btyp_double:
+      retval = retval.sparse_matrix_value ();
+      break;
+    case btyp_complex:
+      retval = retval.sparse_complex_matrix_value ();
+      break;
+    case btyp_bool:
+      retval = retval.sparse_bool_matrix_value ();
+      break;
+    default:
+      break;
+    }
+
+  return retval;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-base-sparse.h b/src/ov-base-sparse.h
--- a/src/ov-base-sparse.h
+++ b/src/ov-base-sparse.h
@@ -164,16 +164,18 @@ octave_base_sparse : public octave_base_
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
   octave_idx_type *mex_get_ir (void) const { return matrix.mex_get_ir (); }
 
   octave_idx_type *mex_get_jc (void) const { return matrix.mex_get_jc (); }
 
 protected:
 
+  octave_value map (octave_base_value::unary_mapper_t umap) const;
+
   T matrix;
 
   mutable MatrixType typ;
 };
 
 #endif
 
 /*
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1112,18 +1112,19 @@ octave_base_value::sort_rows_idx (sortmo
 sortmode
 octave_base_value::is_sorted_rows (sortmode) const
 {
   gripe_wrong_type_arg ("octave_base_value::is_sorted_rows ()", type_name ());
 
   return UNSORTED;
 }
 
-extern OCTINTERP_API
-const char *get_umap_name (unary_mapper_t umap)
+
+const char *
+octave_base_value::get_umap_name (unary_mapper_t umap)
 {
   static const char *names[num_unary_mappers] = 
     {
       "abs",
       "acos",
       "acosh",
       "angle",
       "arg",
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -112,80 +112,16 @@ DEF_CLASS_TO_BTYP (octave_int32, btyp_in
 DEF_CLASS_TO_BTYP (octave_int64, btyp_int64);
 DEF_CLASS_TO_BTYP (octave_uint8, btyp_uint8);
 DEF_CLASS_TO_BTYP (octave_uint16, btyp_uint16);
 DEF_CLASS_TO_BTYP (octave_uint32, btyp_uint32);
 DEF_CLASS_TO_BTYP (octave_uint64, btyp_uint64);
 DEF_CLASS_TO_BTYP (bool, btyp_bool);
 DEF_CLASS_TO_BTYP (char, btyp_char);
 
-// Standard mappers.
-enum unary_mapper_t
-{
-  umap_abs,
-  umap_acos,
-  umap_acosh,
-  umap_angle,
-  umap_arg,
-  umap_asin,
-  umap_asinh,
-  umap_atan,
-  umap_atanh,
-  umap_ceil,
-  umap_conj,
-  umap_cos,
-  umap_cosh,
-  umap_erf,
-  umap_erfc,
-  umap_exp,
-  umap_expm1,
-  umap_finite,
-  umap_fix,
-  umap_floor,
-  umap_gamma,
-  umap_imag,
-  umap_isinf,
-  umap_isna,
-  umap_isnan,
-  umap_lgamma,
-  umap_log,
-  umap_log2,
-  umap_log10,
-  umap_log1p,
-  umap_real,
-  umap_round,
-  umap_roundb,
-  umap_signum,
-  umap_sin,
-  umap_sinh,
-  umap_sqrt,
-  umap_tan,
-  umap_tanh,
-  umap_isalnum,
-  umap_isalpha,
-  umap_isascii,
-  umap_iscntrl,
-  umap_isdigit,
-  umap_isgraph,
-  umap_islower,
-  umap_isprint,
-  umap_ispunct,
-  umap_isspace,
-  umap_isupper,
-  umap_isxdigit,
-  umap_toascii,
-  umap_tolower,
-  umap_toupper,
-  umap_unknown,
-  num_unary_mappers = umap_unknown
-};
-
-extern OCTINTERP_API
-const char *get_umap_name (unary_mapper_t);
-
 // T_ID is the type id of struct objects, set by register_type().
 // T_NAME is the type name of struct objects.
 
 #define DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA \
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA2 (OCTAVE_EMPTY_CPP_ARG)
 
 #define DECLARE_OV_BASE_TYPEID_FUNCTIONS_AND_DATA \
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA2(virtual)
@@ -691,16 +627,77 @@ public:
   virtual void lock (void);
 
   virtual void unlock (void);
 
   virtual bool islocked (void) const { return false; }
 
   virtual void dump (std::ostream& os) const;
 
+  // Standard mappers. Register new ones here.
+  enum unary_mapper_t
+    {
+      umap_abs,
+      umap_acos,
+      umap_acosh,
+      umap_angle,
+      umap_arg,
+      umap_asin,
+      umap_asinh,
+      umap_atan,
+      umap_atanh,
+      umap_ceil,
+      umap_conj,
+      umap_cos,
+      umap_cosh,
+      umap_erf,
+      umap_erfc,
+      umap_exp,
+      umap_expm1,
+      umap_finite,
+      umap_fix,
+      umap_floor,
+      umap_gamma,
+      umap_imag,
+      umap_isinf,
+      umap_isna,
+      umap_isnan,
+      umap_lgamma,
+      umap_log,
+      umap_log2,
+      umap_log10,
+      umap_log1p,
+      umap_real,
+      umap_round,
+      umap_roundb,
+      umap_signum,
+      umap_sin,
+      umap_sinh,
+      umap_sqrt,
+      umap_tan,
+      umap_tanh,
+      umap_xisalnum,
+      umap_xisalpha,
+      umap_xisascii,
+      umap_xiscntrl,
+      umap_xisdigit,
+      umap_xisgraph,
+      umap_xislower,
+      umap_xisprint,
+      umap_xispunct,
+      umap_xisspace,
+      umap_xisupper,
+      umap_xisxdigit,
+      umap_xtoascii,
+      umap_xtolower,
+      umap_xtoupper,
+      umap_unknown,
+      num_unary_mappers = umap_unknown
+    };
+
   virtual octave_value map (unary_mapper_t) const;
 
 protected:
 
   // This should only be called for derived types.
 
   octave_value numeric_assign (const std::string& type,
 			       const std::list<octave_value_list>& idx,
@@ -727,16 +724,18 @@ protected:
   // A reference count.
   // NOTE: the declaration is octave_idx_type because with 64-bit indexing,
   // it is well possible to have more than MAX_INT copies of a single value
   // (think of an empty cell array with >2G elements).
   octave_idx_type count;
 
 private:
 
+  static const char *get_umap_name (unary_mapper_t);
+
   static int curr_print_indent_level;
   static bool beginning_of_line;
 
   DECLARE_OV_BASE_TYPEID_FUNCTIONS_AND_DATA
 };
 
 // TRUE means to perform automatic sparse to real mutation if there
 // is memory to be saved
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -1421,13 +1421,42 @@ octave_cell::as_mxArray (void) const
   const octave_value *p = matrix.data ();
 
   for (mwIndex i = 0; i < nel; i++)
     elts[i] = new mxArray (p[i]);
 
   return retval;
 }
 
+octave_value
+octave_cell::map (unary_mapper_t umap) const
+{
+  switch (umap)
+    {
+#define FORWARD_MAPPER(UMAP) \
+    case umap_ ## UMAP: \
+      return matrix.UMAP ()
+    FORWARD_MAPPER (xisalnum);
+    FORWARD_MAPPER (xisalpha);
+    FORWARD_MAPPER (xisascii);
+    FORWARD_MAPPER (xiscntrl);
+    FORWARD_MAPPER (xisdigit);
+    FORWARD_MAPPER (xisgraph);
+    FORWARD_MAPPER (xislower);
+    FORWARD_MAPPER (xisprint);
+    FORWARD_MAPPER (xispunct);
+    FORWARD_MAPPER (xisspace);
+    FORWARD_MAPPER (xisupper);
+    FORWARD_MAPPER (xisxdigit);
+    FORWARD_MAPPER (xtoascii);
+    FORWARD_MAPPER (xtolower);
+    FORWARD_MAPPER (xtoupper);
+    
+    default:
+      return octave_base_value::map (umap);
+    }
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-cell.h b/src/ov-cell.h
--- a/src/ov-cell.h
+++ b/src/ov-cell.h
@@ -150,18 +150,17 @@ public:
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
 #endif
 
-  octave_value map (unary_mapper_t umap) const
-    { return matrix.map (umap); }
+  octave_value map (unary_mapper_t umap) const;
 
   mxArray *as_mxArray (void) const;
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const; 
 
 private:
diff --git a/src/ov-ch-mat.cc b/src/ov-ch-mat.cc
--- a/src/ov-ch-mat.cc
+++ b/src/ov-ch-mat.cc
@@ -163,34 +163,34 @@ static inline int xtoascii (int c)
 { return toascii (c); }
 
 octave_value
 octave_char_matrix::map (unary_mapper_t umap) const
 {
   switch (umap)
     {
 #define STRING_MAPPER(UMAP,FCN,TYPE) \
-    case UMAP: \
+    case umap_ ## UMAP: \
       return octave_value (matrix.map<TYPE, int (&) (int)> (FCN))
 
-    STRING_MAPPER (umap_isalnum, std::isalnum, bool);
-    STRING_MAPPER (umap_isalpha, std::isalpha, bool);
-    STRING_MAPPER (umap_isascii, xisascii, bool);
-    STRING_MAPPER (umap_iscntrl, std::iscntrl, bool);
-    STRING_MAPPER (umap_isdigit, std::isdigit, bool);
-    STRING_MAPPER (umap_isgraph, std::isgraph, bool);
-    STRING_MAPPER (umap_islower, std::islower, bool);
-    STRING_MAPPER (umap_isprint, std::isprint, bool);
-    STRING_MAPPER (umap_ispunct, std::ispunct, bool);
-    STRING_MAPPER (umap_isspace, std::isspace, bool);
-    STRING_MAPPER (umap_isupper, std::isupper, bool);
-    STRING_MAPPER (umap_isxdigit, std::isxdigit, bool);
-    STRING_MAPPER (umap_toascii, xtoascii, double);
-    STRING_MAPPER (umap_tolower, std::tolower, char);
-    STRING_MAPPER (umap_toupper, std::toupper, char);
+    STRING_MAPPER (xisalnum, std::isalnum, bool);
+    STRING_MAPPER (xisalpha, std::isalpha, bool);
+    STRING_MAPPER (xisascii, xisascii, bool);
+    STRING_MAPPER (xiscntrl, std::iscntrl, bool);
+    STRING_MAPPER (xisdigit, std::isdigit, bool);
+    STRING_MAPPER (xisgraph, std::isgraph, bool);
+    STRING_MAPPER (xislower, std::islower, bool);
+    STRING_MAPPER (xisprint, std::isprint, bool);
+    STRING_MAPPER (xispunct, std::ispunct, bool);
+    STRING_MAPPER (xisspace, std::isspace, bool);
+    STRING_MAPPER (xisupper, std::isupper, bool);
+    STRING_MAPPER (xisxdigit, std::isxdigit, bool);
+    STRING_MAPPER (xtoascii, xtoascii, double);
+    STRING_MAPPER (xtolower, std::tolower, char);
+    STRING_MAPPER (xtoupper, std::toupper, char);
 
     default: 
       {
         octave_matrix m (array_value (true));
         return m.map (umap);
       }
     }
 }
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -871,17 +871,17 @@ octave_sparse_complex_matrix::map (unary
       ARRAY_MAPPER (tan, Complex, std::tan);
       ARRAY_MAPPER (tanh, Complex, std::tanh);
       ARRAY_MAPPER (isnan, bool, xisnan);
       ARRAY_MAPPER (isna, bool, octave_is_NA);
       ARRAY_MAPPER (isinf, bool, xisinf);
       ARRAY_MAPPER (finite, bool, xfinite);
 
     default: // Attempt to go via dense matrix.
-      return full_value ().map (umap).sparse_matrix_value ();
+      return octave_base_sparse<SparseComplexMatrix>::map (umap);
     }
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -763,17 +763,23 @@ octave_matrix::map (unary_mapper_t umap)
       ARRAY_MAPPER (sin, double, ::sin);
       ARRAY_MAPPER (sinh, double, ::sinh);
       ARRAY_MAPPER (sqrt, Complex, rc_sqrt);
       ARRAY_MAPPER (tan, double, ::tan);
       ARRAY_MAPPER (tanh, double, ::tanh);
       ARRAY_MAPPER (isna, bool, octave_is_NA);
 
     default:
-      return octave_base_value::map (umap);
+      if (umap >= umap_xisalnum && umap <= umap_xtoupper)
+        {
+          octave_value str_conv = convert_to_str (true, true);
+          return error_state ? octave_value () : str_conv.map (umap);
+        }
+      else
+        return octave_base_value::map (umap);
     }
 }
 
 DEFUN (double, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} double (@var{x})\n\
 Convert @var{x} to double precision type.\n\
 @seealso{single}\n\
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -863,17 +863,17 @@ octave_sparse_matrix::map (unary_mapper_
       ARRAY_MAPPER (tan, double, ::tan);
       ARRAY_MAPPER (tanh, double, ::tanh);
       ARRAY_MAPPER (isnan, bool, xisnan);
       ARRAY_MAPPER (isna, bool, octave_is_NA);
       ARRAY_MAPPER (isinf, bool, xisinf);
       ARRAY_MAPPER (finite, bool, xfinite);
 
     default: // Attempt to go via dense matrix.
-      return full_value ().map (umap).sparse_matrix_value ();
+      return octave_base_sparse<SparseMatrix>::map (umap);
     }
 }
 
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -316,17 +316,23 @@ octave_scalar::map (unary_mapper_t umap)
       SCALAR_MAPPER (tan, ::tan);
       SCALAR_MAPPER (tanh, ::tanh);
       SCALAR_MAPPER (finite, xfinite);
       SCALAR_MAPPER (isinf, xisinf);
       SCALAR_MAPPER (isna, octave_is_NA);
       SCALAR_MAPPER (isnan, xisnan);
 
     default:
-      return octave_base_value::map (umap);
+      if (umap >= umap_xisalnum && umap <= umap_xtoupper)
+        {
+          octave_value str_conv = convert_to_str (true, true);
+          return error_state ? octave_value () : str_conv.map (umap);
+        }
+      else
+        return octave_base_value::map (umap);
     }
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -1071,18 +1071,82 @@ public:
   void lock (void) { rep->lock (); }
 
   void unlock (void) { rep->unlock (); }
 
   bool islocked (void) const { return rep->islocked (); }
 
   void dump (std::ostream& os) const { rep->dump (os); }
 
-  octave_value map (unary_mapper_t umap) const
-    { return rep->map (umap); } 
+#define MAPPER_FORWARD(F) \
+  octave_value F (void) const { return rep->map (octave_base_value::umap_ ## F); }
+
+  MAPPER_FORWARD (abs)
+  MAPPER_FORWARD (acos)
+  MAPPER_FORWARD (acosh)
+  MAPPER_FORWARD (angle)
+  MAPPER_FORWARD (arg)
+  MAPPER_FORWARD (asin)
+  MAPPER_FORWARD (asinh)
+  MAPPER_FORWARD (atan)
+  MAPPER_FORWARD (atanh)
+  MAPPER_FORWARD (ceil)
+  MAPPER_FORWARD (conj)
+  MAPPER_FORWARD (cos)
+  MAPPER_FORWARD (cosh)
+  MAPPER_FORWARD (erf)
+  MAPPER_FORWARD (erfc)
+  MAPPER_FORWARD (exp)
+  MAPPER_FORWARD (expm1)
+  MAPPER_FORWARD (finite)
+  MAPPER_FORWARD (fix)
+  MAPPER_FORWARD (floor)
+  MAPPER_FORWARD (gamma)
+  MAPPER_FORWARD (imag)
+  MAPPER_FORWARD (isinf)
+  MAPPER_FORWARD (isna)
+  MAPPER_FORWARD (isnan)
+  MAPPER_FORWARD (lgamma)
+  MAPPER_FORWARD (log)
+  MAPPER_FORWARD (log2)
+  MAPPER_FORWARD (log10)
+  MAPPER_FORWARD (log1p)
+  MAPPER_FORWARD (real)
+  MAPPER_FORWARD (round)
+  MAPPER_FORWARD (roundb)
+  MAPPER_FORWARD (signum)
+  MAPPER_FORWARD (sin)
+  MAPPER_FORWARD (sinh)
+  MAPPER_FORWARD (sqrt)
+  MAPPER_FORWARD (tan)
+  MAPPER_FORWARD (tanh)
+
+  // These functions are prefixed with X to avoid potential macro
+  // conflicts.
+
+  MAPPER_FORWARD (xisalnum)
+  MAPPER_FORWARD (xisalpha)
+  MAPPER_FORWARD (xisascii)
+  MAPPER_FORWARD (xiscntrl)
+  MAPPER_FORWARD (xisdigit)
+  MAPPER_FORWARD (xisgraph)
+  MAPPER_FORWARD (xislower)
+  MAPPER_FORWARD (xisprint)
+  MAPPER_FORWARD (xispunct)
+  MAPPER_FORWARD (xisspace)
+  MAPPER_FORWARD (xisupper)
+  MAPPER_FORWARD (xisxdigit)
+  MAPPER_FORWARD (xtoascii)
+  MAPPER_FORWARD (xtolower)
+  MAPPER_FORWARD (xtoupper)
+
+#undef MAPPER_FORWARD
+
+  octave_value map (octave_base_value::unary_mapper_t umap) const
+    { return rep->map (umap); }
 
 protected:
 
   // The real representation.
   octave_base_value *rep;
 
 private:
 
