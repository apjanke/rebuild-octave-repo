# HG changeset patch
# User Andrew Thornton <art27@cantab.net>
# Date 1462475006 -3600
#      Thu May 05 20:03:26 2016 +0100
# Node ID 6780a8657be363f261bc476ab2cbc249ed498c5e
# Parent  49d999dc443f4ac191ead6417b62bcf97547d003
Implement uibuttongroup (bug #47513)

* doc/interpreter/genpropdoc.m: Wire in uibuttongroup documentation creation
* doc/interpreter/gui.txi: Add documentation node for uibuttongroup
* doc/interpreter/module.mk: Wire in uibuttongroup documentation creation
* doc/interpreter/plot.txi: Add documentation node for uibuttongroup
* libgui/graphics/__init_qt__.cc (__init__): Set default styling for uibuttongroup
* libgui/graphics/Backend.cc (toolkitObjectProperty): Add uibuttongroup
* libgui/graphics/Backend.cc (Backend::initialize): Add uibuttongroup
* libgui/graphics/Backend.cc (Backend::update): Add uibuttongroup
* libgui/graphics/ButtonControl.cc (ButtonControl::update): Catch forced uncheck of selected button in buttongroup
* libgui/graphics/Canvas.cc (Canvas::select_object): Allow uibuttongroup to be selected like uicontrol or uipanel
* libgui/graphics/Figure.cc (hasUiControlChildren): Ensure that uibuttongroup is known to have children
* libgui/graphics/module.mk: Wire in ButtonGroup
* libgui/graphics/ObjectFactory.cc (ObjectFactory::createObject): Create ButtonGroup for uibuttongroup
* libgui/graphics/QtHandlesUtils.cc (computeFont<uibuttongroup>): Make computeFont template for uibuttongroup
* libgui/graphics/RadioButtonControl.cc (RadioButtonControl::RadioButtonControl): On creation of button add to ButtonGroup
* libgui/graphics/ToggleButtonControl.cc (ToggleButtonControl::ToggleButtonControl): On creation of button add to ButtonGroup
* libinterp/corefcn/gl-render.cc (opengl_renderer::draw): Allow uibuttongroup to be drawn
* libinterp/corefcn/gl-render.cc (opengl_renderer::draw_uibuttongroup): Method to draw uibuttongroup
* libinterp/corefcn/gl-render.h (opengl_renderer::draw_uibuttongroup): Method to draw uibuttongroup
* libinterp/corefcn/graphics.cc (lookup_object_name): Wire in uibuttongroup
* libinterp/corefcn/graphics.cc (make_graphics_object_from_type): Wire in uibuttongroup
* libinterp/corefcn/graphics.cc (property_list::set): Wire in uibuttongroup
* libinterp/corefcn/graphics.cc (property_list::lookup): Wire in uibuttongroup
* libinterp/corefcn/graphics.cc (uibuttongroup::properties::get_boundingbox uibuttongroup::properties::set_units uibuttongroup::properties::update_units uibuttongroup::properties::set_fontunits uibuttongroup::properties::update_fontunits uibuttongroup::properties::get_fontsize_points uibuttongroup::properties::set_selectedobject): Add property methods for uibuttongroup
* libinterp/corefcn/graphics.in.h: Add uibuttongroup
* scripts/gui/module.mk: Wire in uibuttongroup script
* scripts/help/__unimplemented__.m: Remove uibuttongroup from unimplemented
* libgui/graphics/ButtonGroup.cc: Add QT toolkit ButtonGroup object
* libgui/graphics/ButtonGroup.h: Add QT toolkit ButtonGroup object
* scripts/gui/uibuttongroup.m: Create uibuttongroup script

diff --git a/doc/interpreter/genpropdoc.m b/doc/interpreter/genpropdoc.m
--- a/doc/interpreter/genpropdoc.m
+++ b/doc/interpreter/genpropdoc.m
@@ -26,17 +26,17 @@
 ## property.
 ##
 ## @seealso{}
 ## @end deftypefn
 
 function genpropdoc (objname, fname)
   objnames = {"root", "figure", "axes", "line", ...
               "text", "image", "patch", "surface", "light", ...
-              "uimenu", "uicontextmenu", "uipanel", ...
+              "uimenu", "uibuttongroup", "uicontextmenu", "uipanel", ...
               "uicontrol", "uitoolbar", "uipushtool", "uitoggletool"};
 
   ## Base properties
   base = getstructure ("base");
 
   ## Object properties
   if (any (strcmp (objname, objnames)))
     obj = getstructure (objname, base);
@@ -1369,16 +1369,43 @@ is supported.";
       case "resizefcn"
       case "shadowcolor"
       case "title"
       case "titleposition"
       case "units"
 
     endswitch
 
+  ## uibuttongroup properties
+  elseif (strcmp (objname, "uibuttongroup"))
+    switch (field)
+      ## Overridden shared properties
+
+      ## Specific properties
+        case "backgroundcolor"
+        case "bordertype"
+        case "borderwidth"
+        case "fontangle"
+        case "fontname"
+        case "fontsize"
+        case "fontunits"
+        case "fontweight"
+        case "foregroundcolor"
+        case "highlightcolor"
+        case "position"
+        case "resizefcn"
+        case "selectedobject"
+        case "selectionchangedfcn"
+        case "shadowcolor"
+        case "title"
+        case "titleposition"
+        case "units"
+
+    endswitch
+
   ## uicontrol properties
   elseif (strcmp (objname, "uicontrol"))
     switch (field)
       ## Overridden shared properties
 
       ## Specific properties
       case "backgroundcolor"
       case "callback"
diff --git a/doc/interpreter/gui.txi b/doc/interpreter/gui.txi
--- a/doc/interpreter/gui.txi
+++ b/doc/interpreter/gui.txi
@@ -95,16 +95,18 @@ errors and to get textual input from the
 @section UI Elements
 
 The @nospell{ui*} series of functions work best with the @code{qt} graphics
 toolkit, although some functionality is available with the @code{fltk} toolkit.
 There is no support for the @code{gnuplot} toolkit.
 
 @DOCSTRING(uimenu)
 
+@DOCSTRING(uibuttongroup)
+
 @DOCSTRING(uicontextmenu)
 
 @DOCSTRING(uicontrol)
 
 @DOCSTRING(uipanel)
 
 @DOCSTRING(uipushtool)
 
@@ -144,9 +146,8 @@ programs that do.  The functions @code{u
 
 @DOCSTRING(addpref)
 
 @DOCSTRING(rmpref)
 
 @DOCSTRING(ispref)
 
 @DOCSTRING(preferences)
-
diff --git a/doc/interpreter/module.mk b/doc/interpreter/module.mk
--- a/doc/interpreter/module.mk
+++ b/doc/interpreter/module.mk
@@ -6,16 +6,17 @@ GRAPH_PROP_TEXI_SRC = \
   doc/interpreter/plot-imageproperties.texi \
   doc/interpreter/plot-lightproperties.texi \
   doc/interpreter/plot-lineproperties.texi \
   doc/interpreter/plot-patchproperties.texi \
   doc/interpreter/plot-rootproperties.texi \
   doc/interpreter/plot-surfaceproperties.texi \
   doc/interpreter/plot-textproperties.texi \
   doc/interpreter/plot-uimenuproperties.texi \
+  doc/interpreter/plot-uibuttongroupproperties.texi \
   doc/interpreter/plot-uicontextmenuproperties.texi \
   doc/interpreter/plot-uipanelproperties.texi \
   doc/interpreter/plot-uicontrolproperties.texi \
   doc/interpreter/plot-uitoolbarproperties.texi \
   doc/interpreter/plot-uipushtoolproperties.texi \
   doc/interpreter/plot-uitoggletoolproperties.texi
 
 $(GRAPH_PROP_TEXI_SRC): | $(OCTAVE_INTERPRETER_TARGETS)
@@ -51,16 +52,19 @@ doc/interpreter/plot-surfaceproperties.t
 	$(AM_V_GEN)$(call gen-propdoc-texi,surface)
 
 doc/interpreter/plot-textproperties.texi: doc/interpreter/genpropdoc.m
 	$(AM_V_GEN)$(call gen-propdoc-texi,text)
 
 doc/interpreter/plot-uimenuproperties.texi: doc/interpreter/genpropdoc.m
 	$(AM_V_GEN)$(call gen-propdoc-texi,uimenu)
 
+doc/interpreter/plot-uibuttongroupproperties.texi: doc/interpreter/genpropdoc.m
+	$(AM_V_GEN)$(call gen-propdoc-texi,uibuttongroup)
+
 doc/interpreter/plot-uicontextmenuproperties.texi: doc/interpreter/genpropdoc.m
 	$(AM_V_GEN)$(call gen-propdoc-texi,uicontextmenu)
 
 doc/interpreter/plot-uipanelproperties.texi: doc/interpreter/genpropdoc.m
 	$(AM_V_GEN)$(call gen-propdoc-texi,uipanel)
 
 doc/interpreter/plot-uicontrolproperties.texi: doc/interpreter/genpropdoc.m
 	$(AM_V_GEN)$(call gen-propdoc-texi,uicontrol)
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -1383,16 +1383,17 @@ struct2hdl (fig_struct);
 * Axes Properties::
 * Line Properties::
 * Text Properties::
 * Image Properties::
 * Patch Properties::
 * Surface Properties::
 * Light Properties::
 * Uimenu Properties::
+* Uibuttongroup Properties::
 * Uicontextmenu Properties::
 * Uipanel Properties::
 * Uicontrol Properties::
 * Uitoolbar Properties::
 * Uipushtool Properties::
 * Uitoggletool Properties::
 @end menu
 
@@ -1491,16 +1492,24 @@ The @code{light} properties are:
 @node Uimenu Properties
 @subsubsection Uimenu Properties
 @cindex uimenu properties
 
 The @code{uimenu} properties are:
 
 @include plot-uimenuproperties.texi
 
+@node Uibuttongroup Properties
+@subsubsection Uibuttongroup Properties
+@cindex uibuttongroup properties
+
+The @code{uibuttongroup} properties are:
+
+@include plot-uibuttongroupproperties.texi
+
 @node Uicontextmenu Properties
 @subsubsection Uicontextmenu Properties
 @cindex uicontextmenu properties
 
 The @code{uicontextmenu} properties are:
 
 @include plot-uicontextmenuproperties.texi
 
diff --git a/libgui/graphics/Backend.cc b/libgui/graphics/Backend.cc
--- a/libgui/graphics/Backend.cc
+++ b/libgui/graphics/Backend.cc
@@ -50,16 +50,17 @@ namespace QtHandles
 
 static std::string
 toolkitObjectProperty (const graphics_object& go)
 {
   if (go.isa ("figure"))
     return std::string ("__plot_stream__");
   else if (go.isa ("uicontrol")
            || go.isa ("uipanel")
+           || go.isa ("uibuttongroup")
            || go.isa ("uimenu")
            || go.isa ("uicontextmenu")
            || go.isa ("uitoolbar")
            || go.isa ("uipushtool")
            || go.isa ("uitoggletool"))
     return std::string ("__object__");
   else
     qCritical ("QtHandles::Backend: no __object__ property known for object "
@@ -82,16 +83,17 @@ Backend::~Backend (void)
 }
 
 bool
 Backend::initialize (const graphics_object& go)
 {
   if (go.isa ("figure")
       || go.isa ("uicontrol")
       || go.isa ("uipanel")
+      || go.isa ("uibuttongroup")
       || go.isa ("uimenu")
       || go.isa ("uicontextmenu")
       || go.isa ("uitoolbar")
       || go.isa ("uipushtool")
       || go.isa ("uitoggletool"))
     {
       Logger::debug ("Backend::initialize %s from thread %08x",
                      go.type ().c_str (), QThread::currentThreadId ());
@@ -112,16 +114,17 @@ Backend::initialize (const graphics_obje
 
 void
 Backend::update (const graphics_object& go, int pId)
 {
   // Rule out obvious properties we want to ignore.
   if (pId == figure::properties::ID___PLOT_STREAM__
       || pId == uicontrol::properties::ID___OBJECT__
       || pId == uipanel::properties::ID___OBJECT__
+      || pId == uibuttongroup::properties::ID___OBJECT__
       || pId == uimenu::properties::ID___OBJECT__
       || pId == uicontextmenu::properties::ID___OBJECT__
       || pId == uitoolbar::properties::ID___OBJECT__
       || pId == uipushtool::properties::ID___OBJECT__
       || pId == uitoggletool::properties::ID___OBJECT__
       || pId == base_properties::ID___MODIFIED__)
     return;
 
diff --git a/libgui/graphics/ButtonControl.cc b/libgui/graphics/ButtonControl.cc
--- a/libgui/graphics/ButtonControl.cc
+++ b/libgui/graphics/ButtonControl.cc
@@ -22,16 +22,17 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <QAbstractButton>
 
 #include "ButtonControl.h"
+#include "ButtonGroup.h"
 #include "Container.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
 ButtonControl::ButtonControl (const graphics_object& go, QAbstractButton* btn)
   : BaseControl (go, btn), m_blockCallback (false)
@@ -77,17 +78,26 @@ ButtonControl::update (int pId)
 
           if (value.numel () > 0)
             {
               double dValue = value(0);
 
               if (dValue != 0.0 && dValue != 1.0)
                 warning ("button value not within valid display range");
               else if (dValue == up.get_min () && btn->isChecked ())
-                btn->setChecked (false);
+                {
+                  btn->setChecked (false);
+                  if (up.style_is ("radiobutton") || up.style_is ("togglebutton"))
+                    {
+                      Object* parent = Object::parentObject (gh_manager::get_object (up.get___myhandle__ ()));
+                      ButtonGroup* btnGroup = dynamic_cast<ButtonGroup*>(parent);
+                      if (btnGroup)
+                        btnGroup->selectNothing ();
+                    }
+                }
               else if (dValue == up.get_max () && ! btn->isChecked ())
                 btn->setChecked (true);
             }
         }
       m_blockCallback = false;
       break;
 
     default:
diff --git a/libgui/graphics/ButtonGroup.cc b/libgui/graphics/ButtonGroup.cc
new file mode 100644
--- /dev/null
+++ b/libgui/graphics/ButtonGroup.cc
@@ -0,0 +1,487 @@
+/*
+
+Copyright (C) 2016 Andrew Thornton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#  include "config.h"
+#endif
+
+#include <QAbstractButton>
+#include <QButtonGroup>
+#include <QEvent>
+#include <QFrame>
+#include <QLabel>
+#include <QMouseEvent>
+#include <QRadioButton>
+#include <QTimer>
+
+#include "Canvas.h"
+#include "Container.h"
+#include "ContextMenu.h"
+#include "ButtonGroup.h"
+#include "ToggleButtonControl.h"
+#include "RadioButtonControl.h"
+#include "Backend.h"
+#include "QtHandlesUtils.h"
+
+#include "ov-struct.h"
+
+namespace QtHandles
+{
+
+static int
+frameStyleFromProperties (const uibuttongroup::properties& pp)
+{
+    if (pp.bordertype_is ("none"))
+      return QFrame::NoFrame;
+    else if (pp.bordertype_is ("etchedin"))
+      return (QFrame::Box | QFrame::Sunken);
+    else if (pp.bordertype_is ("etchedout"))
+      return (QFrame::Box | QFrame::Raised);
+    else if (pp.bordertype_is ("beveledin"))
+      return (QFrame::Panel | QFrame::Sunken);
+    else if (pp.bordertype_is ("beveledout"))
+      return (QFrame::Panel | QFrame::Raised);
+    else
+      return (QFrame::Panel | QFrame::Plain);
+}
+
+static void
+setupPalette (const uibuttongroup::properties& pp, QPalette &p)
+{
+  p.setColor (QPalette::Window,
+              Utils::fromRgb (pp.get_backgroundcolor_rgb ()));
+  p.setColor (QPalette::WindowText,
+              Utils::fromRgb (pp.get_foregroundcolor_rgb ()));
+  p.setColor (QPalette::Light,
+              Utils::fromRgb (pp.get_highlightcolor_rgb ()));
+  p.setColor (QPalette::Dark,
+              Utils::fromRgb (pp.get_shadowcolor_rgb ()));
+}
+
+static int
+borderWidthFromProperties (const uibuttongroup::properties& pp)
+{
+  int bw = 0;
+
+  if (! pp.bordertype_is ("none"))
+    {
+      bw = octave::math::round (pp.get_borderwidth ());
+      if (pp.bordertype_is ("etchedin") || pp.bordertype_is ("etchedout"))
+        bw *= 2;
+    }
+
+  return bw;
+}
+
+ButtonGroup*
+ButtonGroup::create (const graphics_object& go)
+{
+  Object* parent = Object::parentObject (go);
+
+  if (parent)
+    {
+      Container* container = parent->innerContainer ();
+
+      if (container) {
+        QFrame* frame = new QFrame(container);
+        return new ButtonGroup (go, new QButtonGroup (frame), frame);
+      }
+    }
+
+  return 0;
+}
+
+ButtonGroup::ButtonGroup (const graphics_object& go, QButtonGroup* buttongroup, QFrame* frame)
+  : Object (go, frame), m_hiddenbutton(0), m_container (0), m_title (0), m_blockUpdates (false)
+{
+  uibuttongroup::properties& pp = properties<uibuttongroup> ();
+
+  frame->setObjectName ("UIButtonGroup");
+  frame->setAutoFillBackground (true);
+  Matrix bb = pp.get_boundingbox (false);
+  frame->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
+                      octave::math::round (bb(2)), octave::math::round (bb(3)));
+  frame->setFrameStyle (frameStyleFromProperties (pp));
+  frame->setLineWidth (octave::math::round (pp.get_borderwidth ()));
+  QPalette pal = frame->palette ();
+  setupPalette (pp, pal);
+  frame->setPalette (pal);
+  m_buttongroup = buttongroup;
+  m_hiddenbutton = new QRadioButton (frame);
+  m_hiddenbutton->hide ();
+  m_buttongroup->addButton (m_hiddenbutton);
+
+  m_container = new Container (frame);
+  m_container->canvas (m_handle);
+
+  if (frame->hasMouseTracking ())
+    {
+      foreach (QWidget* w, frame->findChildren<QWidget*> ())
+        { w->setMouseTracking (true); }
+      foreach (QWidget* w, buttongroup->findChildren<QWidget*> ())
+        { w->setMouseTracking (true); }
+    }
+
+  QString title = Utils::fromStdString (pp.get_title ());
+  if (! title.isEmpty ())
+    {
+      m_title = new QLabel (title, frame);
+      m_title->setAutoFillBackground (true);
+      m_title->setContentsMargins (4, 0, 4, 0);
+      m_title->setPalette (pal);
+      m_title->setFont (Utils::computeFont<uibuttongroup> (pp, bb(3)));
+    }
+
+  frame->installEventFilter (this);
+  m_container->installEventFilter (this);
+
+  if (pp.is_visible ())
+    {
+      QTimer::singleShot (0, frame, SLOT (show (void)));
+      QTimer::singleShot (0, buttongroup, SLOT (show (void)));
+    }
+  else
+    frame->hide ();
+
+  connect (m_buttongroup, SIGNAL (buttonClicked (QAbstractButton*)), SLOT (buttonClicked (QAbstractButton*)));
+}
+
+ButtonGroup::~ButtonGroup (void)
+{
+}
+
+bool
+ButtonGroup::eventFilter (QObject* watched, QEvent* xevent)
+{
+  if (! m_blockUpdates)
+    {
+      if (watched == qObject ())
+        {
+          switch (xevent->type ())
+            {
+            case QEvent::Resize:
+                {
+                  gh_manager::auto_lock lock;
+                  graphics_object go = object ();
+
+                  if (go.valid_object ())
+                    {
+                      if (m_title)
+                        {
+                          const uibuttongroup::properties& pp =
+                            Utils::properties<uibuttongroup> (go);
+
+                          if (pp.fontunits_is ("normalized"))
+                            {
+                              QFrame* frame = qWidget<QFrame> ();
+
+                              m_title->setFont (Utils::computeFont<uibuttongroup>
+                                                (pp, frame->height ()));
+                              m_title->resize (m_title->sizeHint ());
+                            }
+                        }
+                      updateLayout ();
+                    }
+                }
+              break;
+
+            case QEvent::MouseButtonPress:
+                {
+                  QMouseEvent* m = dynamic_cast<QMouseEvent*> (xevent);
+
+                  if (m->button () == Qt::RightButton)
+                    {
+                      gh_manager::auto_lock lock;
+
+                      ContextMenu::executeAt (properties (), m->globalPos ());
+                    }
+                }
+              break;
+
+            default:
+              break;
+            }
+        }
+      else if (watched == m_container)
+        {
+          switch (xevent->type ())
+            {
+            case QEvent::Resize:
+              if (qWidget<QWidget> ()->isVisible ())
+                {
+                  gh_manager::auto_lock lock;
+
+                  properties ().update_boundingbox ();
+                }
+              break;
+
+            default:
+              break;
+            }
+        }
+    }
+
+  return false;
+}
+
+void
+ButtonGroup::update (int pId)
+{
+  uibuttongroup::properties& pp = properties<uibuttongroup> ();
+  QFrame* frame = qWidget<QFrame> ();
+
+  m_blockUpdates = true;
+
+  switch (pId)
+    {
+    case uibuttongroup::properties::ID_POSITION:
+      {
+        Matrix bb = pp.get_boundingbox (false);
+
+        frame->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
+                            octave::math::round (bb(2)), octave::math::round (bb(3)));
+        updateLayout ();
+      }
+      break;
+
+    case uibuttongroup::properties::ID_BORDERWIDTH:
+      frame->setLineWidth (octave::math::round (pp.get_borderwidth ()));
+      updateLayout ();
+      break;
+
+    case uibuttongroup::properties::ID_BACKGROUNDCOLOR:
+    case uibuttongroup::properties::ID_FOREGROUNDCOLOR:
+    case uibuttongroup::properties::ID_HIGHLIGHTCOLOR:
+    case uibuttongroup::properties::ID_SHADOWCOLOR:
+      {
+        QPalette pal = frame->palette ();
+
+        setupPalette (pp, pal);
+        frame->setPalette (pal);
+        if (m_title)
+          m_title->setPalette (pal);
+      }
+      break;
+
+    case uibuttongroup::properties::ID_TITLE:
+      {
+        QString title = Utils::fromStdString (pp.get_title ());
+
+        if (title.isEmpty ())
+          {
+            if (m_title)
+              delete m_title;
+            m_title = 0;
+          }
+        else
+          {
+            if (! m_title)
+              {
+                QPalette pal = frame->palette ();
+
+                m_title = new QLabel (title, frame);
+                m_title->setAutoFillBackground (true);
+                m_title->setContentsMargins (4, 0, 4, 0);
+                m_title->setPalette (pal);
+                m_title->setFont (Utils::computeFont<uibuttongroup> (pp));
+                m_title->show ();
+              }
+            else
+              {
+                m_title->setText (title);
+                m_title->resize (m_title->sizeHint ());
+              }
+          }
+        updateLayout ();
+      }
+      break;
+
+    case uibuttongroup::properties::ID_TITLEPOSITION:
+      updateLayout ();
+      break;
+
+    case uibuttongroup::properties::ID_BORDERTYPE:
+      frame->setFrameStyle (frameStyleFromProperties (pp));
+      updateLayout ();
+      break;
+
+    case uibuttongroup::properties::ID_FONTNAME:
+    case uibuttongroup::properties::ID_FONTSIZE:
+    case uibuttongroup::properties::ID_FONTWEIGHT:
+    case uibuttongroup::properties::ID_FONTANGLE:
+      if (m_title)
+        {
+          m_title->setFont (Utils::computeFont<uibuttongroup> (pp));
+          m_title->resize (m_title->sizeHint ());
+          updateLayout ();
+        }
+      break;
+
+    case uibuttongroup::properties::ID_VISIBLE:
+      frame->setVisible (pp.is_visible ());
+      updateLayout ();
+      break;
+
+    case uibuttongroup::properties::ID_SELECTEDOBJECT:
+      {
+        graphics_handle h = pp.get_selectedobject ();
+        gh_manager::auto_lock lock;
+        graphics_object go = gh_manager::get_object (h);
+        Object* selectedObject = Backend::toolkitObject (go);
+        ToggleButtonControl* toggle = static_cast<ToggleButtonControl*> (selectedObject);
+        RadioButtonControl* radio = static_cast<RadioButtonControl*>(selectedObject);
+        if (toggle)
+          {
+            go.get_properties ().set ("value", 1);
+          }
+        else if (radio)
+          {
+            go.get_properties ().set ("value", 1);
+          }
+        else
+          {
+            m_hiddenbutton->setChecked (true);
+          }
+      }
+      break;
+
+    default:
+      break;
+    }
+
+  m_blockUpdates = false;
+}
+
+void
+ButtonGroup::redraw (void)
+{
+  Canvas* canvas = m_container->canvas (m_handle);
+
+  if (canvas)
+    canvas->redraw ();
+}
+
+void
+ButtonGroup::updateLayout (void)
+{
+  uibuttongroup::properties& pp = properties<uibuttongroup> ();
+  QFrame* frame = qWidget<QFrame> ();
+
+  Matrix bb = pp.get_boundingbox (true);
+  int bw = borderWidthFromProperties (pp);
+
+  frame->setFrameRect (QRect (octave::math::round (bb(0)) - bw, octave::math::round (bb(1)) - bw,
+                              octave::math::round (bb(2)) + 2*bw, octave::math::round (bb(3)) + 2*bw));
+  m_container->setGeometry (octave::math::round (bb(0)), octave::math::round (bb(1)),
+                            octave::math::round (bb(2)), octave::math::round (bb(3)));
+
+  if (m_blockUpdates)
+    pp.update_boundingbox ();
+
+  if (m_title)
+    {
+      QSize sz = m_title->sizeHint ();
+      int offset = 5;
+
+      if (pp.titleposition_is ("lefttop"))
+        m_title->move (bw+offset, 0);
+      else if (pp.titleposition_is ("righttop"))
+        m_title->move (frame->width () - bw - offset - sz.width (), 0);
+      else if (pp.titleposition_is ("leftbottom"))
+        m_title->move (bw+offset, frame->height () - sz.height ());
+      else if (pp.titleposition_is ("rightbottom"))
+        m_title->move (frame->width () - bw - offset - sz.width (),
+                       frame->height () - sz.height ());
+      else if (pp.titleposition_is ("centertop"))
+        m_title->move (frame->width () / 2 - sz.width () / 2, 0);
+      else if (pp.titleposition_is ("centerbottom"))
+        m_title->move (frame->width () / 2 - sz.width () / 2,
+                       frame->height () - sz.height ());
+    }
+}
+
+void
+ButtonGroup::selectNothing (void)
+{
+  m_hiddenbutton->setChecked (true);
+}
+
+
+void
+ButtonGroup::addButton (QAbstractButton* btn)
+{
+  m_buttongroup->addButton(btn);
+  connect (btn, SIGNAL (toggled (bool)), SLOT (buttonToggled (bool)));
+}
+
+void
+ButtonGroup::buttonToggled (bool toggled)
+{
+  Q_UNUSED (toggled);
+  if (!m_blockUpdates)
+  {
+    gh_manager::auto_lock lock;
+    uibuttongroup::properties& bp = properties<uibuttongroup> ();
+
+    graphics_handle oldValue = bp.get_selectedobject();
+
+    QAbstractButton* checkedBtn = m_buttongroup->checkedButton();
+
+    graphics_handle newValue = graphics_handle ();
+    if (checkedBtn != m_hiddenbutton)
+      {
+        Object* checkedObj = Object::fromQObject(checkedBtn);
+        newValue = checkedObj->properties ().get___myhandle__ ();
+      }
+
+    if (oldValue != newValue)
+      gh_manager::post_set (m_handle, "selectedobject", newValue.as_octave_value (), false);
+  }
+}
+
+void
+ButtonGroup::buttonClicked (QAbstractButton* btn)
+{
+  Q_UNUSED(btn);
+
+  gh_manager::auto_lock lock;
+  uibuttongroup::properties& bp = properties<uibuttongroup> ();
+
+  graphics_handle oldValue = bp.get_selectedobject();
+
+  QAbstractButton* checkedBtn = m_buttongroup->checkedButton();
+  Object* checkedObj = Object::fromQObject(checkedBtn);
+  graphics_handle newValue = checkedObj->properties ().get___myhandle__ ();
+
+  if (oldValue != newValue)
+    {
+      octave_scalar_map eventData;
+      eventData.setfield ("OldValue", oldValue.as_octave_value ());
+      eventData.setfield ("NewValue", newValue.as_octave_value ());
+      eventData.setfield ("Source", bp.get___myhandle__ ().as_octave_value ());
+      eventData.setfield ("EventName", "SelectionChanged");
+      octave_value selectionChangedEventObject = octave_value (new octave_struct (eventData));
+      gh_manager::post_callback(m_handle, "selectionchangedfcn", selectionChangedEventObject);
+    }
+}
+
+};
diff --git a/libgui/graphics/ButtonGroup.h b/libgui/graphics/ButtonGroup.h
new file mode 100644
--- /dev/null
+++ b/libgui/graphics/ButtonGroup.h
@@ -0,0 +1,78 @@
+/*
+
+Copyright (C) 2016 Andrew Thornton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if ! defined (octave_ButtonGroup_h)
+#define octave_ButtonGroup_h 1
+
+#include "Object.h"
+
+class QAbstractButton;
+class QButtonGroup;
+class QFrame;
+class QLabel;
+class QRadioButton;
+
+namespace QtHandles
+{
+
+class Container;
+
+class ButtonGroup : public Object
+{
+  Q_OBJECT
+
+public:
+  ButtonGroup (const graphics_object& go, QButtonGroup* buttongroup, QFrame* frame);
+  ~ButtonGroup (void);
+
+  Container* innerContainer (void) { return m_container; }
+
+  bool eventFilter (QObject* watched, QEvent* event);
+
+  static ButtonGroup* create (const graphics_object& go);
+
+  void addButton (QAbstractButton* btn);
+
+  void selectNothing (void);
+
+protected:
+  void update (int pId);
+  void redraw (void);
+
+private slots:
+  void buttonToggled (bool toggled);
+  void buttonClicked (QAbstractButton* btn);
+
+private:
+  void updateLayout (void);
+
+private:
+  QButtonGroup* m_buttongroup;
+  QRadioButton* m_hiddenbutton;
+  Container* m_container;
+  QLabel* m_title;
+  bool m_blockUpdates;
+};
+
+}; // namespace QtHandles
+
+#endif
diff --git a/libgui/graphics/Canvas.cc b/libgui/graphics/Canvas.cc
--- a/libgui/graphics/Canvas.cc
+++ b/libgui/graphics/Canvas.cc
@@ -381,17 +381,18 @@ Canvas::select_object (graphics_object o
   octave_idx_type num_children = children.numel ();
 
   for (int i = 0; i < num_children; i++)
     {
       graphics_object childObj (gh_manager::get_object (children(i)));
 
       if (childObj.isa ("axes"))
         axesList.append (childObj);
-      else if (childObj.isa ("uicontrol") || childObj.isa ("uipanel"))
+      else if (childObj.isa ("uicontrol") || childObj.isa ("uipanel")
+               || childObj.isa ("uibuttongroup"))
         {
           Matrix bb = childObj.get_properties ().get_boundingbox (false);
           QRectF r (bb(0), bb(1), bb(2), bb(3));
 
           r.adjust (-5, -5, 5, 5);
           if (r.contains (event->posF ()))
             {
               currentObj = childObj;
diff --git a/libgui/graphics/Figure.cc b/libgui/graphics/Figure.cc
--- a/libgui/graphics/Figure.cc
+++ b/libgui/graphics/Figure.cc
@@ -366,22 +366,24 @@ Figure::redraw (void)
 
   if (canvas)
     {
     canvas->redraw ();
     //canvas->setMouseMode (RotateMode);
     }
 
   foreach (QFrame* frame,
-           qWidget<QWidget> ()->findChildren<QFrame*> ("UIPanel"))
+           qWidget<QWidget> ()->findChildren<QFrame*> ())
     {
-      Object* obj = Object::fromQObject (frame);
+      if (frame->objectName () == "UIPanel" || frame->objectName () == "UIButtonGroup") {
+        Object* obj = Object::fromQObject (frame);
 
-      if (obj)
-        obj->slotRedraw ();
+        if (obj)
+          obj->slotRedraw ();
+      }
     }
 
   updateFigureToolBarAndMenuBar ();
 }
 
 void
 Figure::print (const QString& file_cmd, const QString& term)
 {
diff --git a/libgui/graphics/ObjectFactory.cc b/libgui/graphics/ObjectFactory.cc
--- a/libgui/graphics/ObjectFactory.cc
+++ b/libgui/graphics/ObjectFactory.cc
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <QApplication>
 #include <QThread>
 
 #include "graphics.h"
 
 #include "Backend.h"
+#include "ButtonGroup.h"
 #include "CheckBoxControl.h"
 #include "ContextMenu.h"
 #include "EditControl.h"
 #include "Figure.h"
 #include "ListBoxControl.h"
 #include "Logger.h"
 #include "Menu.h"
 #include "ObjectFactory.h"
@@ -114,16 +115,18 @@ ObjectFactory::createObject (double hand
                     obj = TextControl::create (go);
                   else if (up.style_is ("popupmenu"))
                     obj = PopupMenuControl::create (go);
                   else if (up.style_is ("slider"))
                     obj = SliderControl::create (go);
                   else if (up.style_is ("listbox"))
                     obj = ListBoxControl::create (go);
                 }
+              else if (go.isa ("uibuttongroup"))
+                obj = ButtonGroup::create (go);
               else if (go.isa ("uipanel"))
                 obj = Panel::create (go);
               else if (go.isa ("uimenu"))
                 obj = Menu::create (go);
               else if (go.isa ("uicontextmenu"))
                 obj = ContextMenu::create (go);
               else if (go.isa ("uitoolbar"))
                 obj = ToolBar::create (go);
diff --git a/libgui/graphics/QtHandlesUtils.cc b/libgui/graphics/QtHandlesUtils.cc
--- a/libgui/graphics/QtHandlesUtils.cc
+++ b/libgui/graphics/QtHandlesUtils.cc
@@ -130,16 +130,18 @@ computeFont (const typename T::propertie
 }
 
 template QFont computeFont<uicontrol> (const uicontrol::properties& props,
                                        int height);
 
 template QFont computeFont<uipanel> (const uipanel::properties& props,
                                      int height);
 
+template QFont computeFont<uibuttongroup> (const uibuttongroup::properties& props,
+                                           int height);
 QColor
 fromRgb (const Matrix& rgb)
 {
   QColor c;
 
   if (rgb.numel () == 3)
     c.setRgbF (rgb(0), rgb(1), rgb(2));
 
diff --git a/libgui/graphics/RadioButtonControl.cc b/libgui/graphics/RadioButtonControl.cc
--- a/libgui/graphics/RadioButtonControl.cc
+++ b/libgui/graphics/RadioButtonControl.cc
@@ -21,16 +21,17 @@ along with Octave; see the file COPYING.
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <QRadioButton>
 
+#include "ButtonGroup.h"
 #include "RadioButtonControl.h"
 #include "Container.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
 RadioButtonControl*
@@ -48,16 +49,21 @@ RadioButtonControl::create (const graphi
 
   return 0;
 }
 
 RadioButtonControl::RadioButtonControl (const graphics_object& go,
                                         QRadioButton* radio)
   : ButtonControl (go, radio)
 {
+  Object* parent = Object::parentObject (go);
+  ButtonGroup* btnGroup = dynamic_cast<ButtonGroup*>(parent);
+  if (btnGroup)
+    btnGroup->addButton (radio);
+
   radio->setAutoFillBackground (true);
   radio->setAutoExclusive (false);
 }
 
 RadioButtonControl::~RadioButtonControl (void)
 {
 }
 
diff --git a/libgui/graphics/ToggleButtonControl.cc b/libgui/graphics/ToggleButtonControl.cc
--- a/libgui/graphics/ToggleButtonControl.cc
+++ b/libgui/graphics/ToggleButtonControl.cc
@@ -22,16 +22,17 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <QPushButton>
 
 #include "ToggleButtonControl.h"
+#include "ButtonGroup.h"
 #include "Container.h"
 #include "QtHandlesUtils.h"
 
 namespace QtHandles
 {
 
 ToggleButtonControl*
 ToggleButtonControl::create (const graphics_object& go)
@@ -48,16 +49,21 @@ ToggleButtonControl::create (const graph
 
   return 0;
 }
 
 ToggleButtonControl::ToggleButtonControl (const graphics_object& go,
                                           QPushButton* btn)
     : ButtonControl (go, btn)
 {
+  Object* parent = Object::parentObject (go);
+  ButtonGroup* btnGroup = dynamic_cast<ButtonGroup*>(parent);
+  if (btnGroup)
+    btnGroup->addButton (btn);
+
   btn->setCheckable (true);
   btn->setAutoFillBackground (true);
 }
 
 ToggleButtonControl::~ToggleButtonControl (void)
 {
 }
 
diff --git a/libgui/graphics/__init_qt__.cc b/libgui/graphics/__init_qt__.cc
--- a/libgui/graphics/__init_qt__.cc
+++ b/libgui/graphics/__init_qt__.cc
@@ -78,16 +78,25 @@ bool
                     octave_value (Utils::toRgb (p.color (QPalette::Window))));
           root.set ("defaultuipanelforegroundcolor",
                     octave_value (Utils::toRgb
                                   (p.color (QPalette::WindowText))));
           root.set ("defaultuipanelhighlightcolor",
                     octave_value (Utils::toRgb (p.color (QPalette::Light))));
           root.set ("defaultuipanelshadowcolor",
                     octave_value (Utils::toRgb (p.color (QPalette::Dark))));
+          root.set ("defaultuibuttongroupbackgroundcolor",
+                    octave_value (Utils::toRgb (p.color (QPalette::Window))));
+          root.set ("defaultuibuttongroupforegroundcolor",
+                    octave_value (Utils::toRgb
+                                  (p.color (QPalette::WindowText))));
+          root.set ("defaultuibuttongrouphighlightcolor",
+                    octave_value (Utils::toRgb (p.color (QPalette::Light))));
+          root.set ("defaultuibuttongroupshadowcolor",
+                    octave_value (Utils::toRgb (p.color (QPalette::Dark))));
 
           qtHandlesInitialized = true;
 
           return true;
         }
       else
         error ("__init_qt__: QApplication object must exist.");
     }
diff --git a/libgui/graphics/module.mk b/libgui/graphics/module.mk
--- a/libgui/graphics/module.mk
+++ b/libgui/graphics/module.mk
@@ -1,14 +1,15 @@
 if AMCOND_BUILD_QT_GRAPHICS
 
 OCTAVE_GUI_GRAPHICS_MOC = \
   libgui/graphics/moc-annotation-dialog.cc \
   libgui/graphics/moc-Backend.cc \
   libgui/graphics/moc-ButtonControl.cc \
+  libgui/graphics/moc-ButtonGroup.cc \
   libgui/graphics/moc-ContextMenu.cc \
   libgui/graphics/moc-EditControl.cc \
   libgui/graphics/moc-Figure.cc \
   libgui/graphics/moc-FigureWindow.cc \
   libgui/graphics/moc-ListBoxControl.cc \
   libgui/graphics/moc-Menu.cc \
   libgui/graphics/moc-MouseModeActionGroup.cc \
   libgui/graphics/moc-Object.cc \
@@ -43,16 +44,17 @@ octave_gui_graphics_RC = libgui/graphics
 $(octave_gui_graphics_RC): | libgui/graphics/$(octave_dirstamp)
 
 noinst_HEADERS += \
   libgui/graphics/__init_qt__.h \
   libgui/graphics/annotation-dialog.h \
   libgui/graphics/Backend.h \
   libgui/graphics/BaseControl.h \
   libgui/graphics/ButtonControl.h \
+  libgui/graphics/ButtonGroup.h \
   libgui/graphics/Canvas.h \
   libgui/graphics/CheckBoxControl.h \
   libgui/graphics/Container.h \
   libgui/graphics/ContextMenu.h \
   libgui/graphics/EditControl.h \
   libgui/graphics/Figure.h \
   libgui/graphics/FigureWindow.h \
   libgui/graphics/GenericEventNotify.h \
@@ -83,16 +85,17 @@ noinst_HEADERS += \
   $(TEMPLATE_SRC)
 
 libgui_graphics_libgui_graphics_la_SOURCES = \
   libgui/graphics/__init_qt__.cc \
   libgui/graphics/annotation-dialog.cc \
   libgui/graphics/Backend.cc \
   libgui/graphics/BaseControl.cc \
   libgui/graphics/ButtonControl.cc \
+  libgui/graphics/ButtonGroup.cc \
   libgui/graphics/Canvas.cc \
   libgui/graphics/CheckBoxControl.cc \
   libgui/graphics/Container.cc \
   libgui/graphics/ContextMenu.cc \
   libgui/graphics/EditControl.cc \
   libgui/graphics/Figure.cc \
   libgui/graphics/FigureWindow.cc \
   libgui/graphics/GLCanvas.cc \
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -646,16 +646,21 @@ opengl_renderer::draw (const graphics_ob
            || go.isa ("uicontextmenu") || go.isa ("uitoolbar")
            || go.isa ("uipushtool") || go.isa ("uitoggletool"))
     ; // SKIP
   else if (go.isa ("uipanel"))
     {
       if (toplevel)
         draw_uipanel (dynamic_cast<const uipanel::properties&> (props), go);
     }
+  else if (go.isa ("uibuttongroup"))
+    {
+      if (toplevel)
+        draw_uibuttongroup (dynamic_cast<const uibuttongroup::properties&> (props), go);
+    }
   else
     {
       warning ("opengl_renderer: cannot render object of type '%s'",
                props.graphics_object_name ().c_str ());
     }
 }
 
 #if defined (HAVE_OPENGL)
@@ -709,16 +714,34 @@ opengl_renderer::draw_uipanel (const uip
                    props.get_backgroundcolor_rgb ());
 
   // Draw children
 
   draw (props.get_all_children (), false);
 }
 
 void
+opengl_renderer::draw_uibuttongroup (const uibuttongroup::properties& props,
+                                     const graphics_object& go)
+{
+  graphics_object fig = go.get_ancestor ("figure");
+  const figure::properties& figProps =
+    dynamic_cast<const figure::properties&> (fig.get_properties ());
+
+  // Initialize OpenGL context
+
+  init_gl_context (figProps.is___enhanced__ (),
+                   props.get_backgroundcolor_rgb ());
+
+  // Draw children
+
+  draw (props.get_all_children (), false);
+}
+
+void
 opengl_renderer::init_gl_context (bool enhanced, const Matrix& c)
 {
 #if defined (HAVE_OPENGL)
 
   // Initialize OpenGL context
 
   glEnable (GL_DEPTH_TEST);
   glDepthFunc (GL_LEQUAL);
diff --git a/libinterp/corefcn/gl-render.h b/libinterp/corefcn/gl-render.h
--- a/libinterp/corefcn/gl-render.h
+++ b/libinterp/corefcn/gl-render.h
@@ -65,17 +65,18 @@ protected:
   virtual void draw_surface (const surface::properties& props);
   virtual void draw_patch (const patch::properties& props);
   virtual void draw_light (const light::properties& props);
   virtual void draw_hggroup (const hggroup::properties& props);
   virtual void draw_text (const text::properties& props);
   virtual void draw_image (const image::properties& props);
   virtual void draw_uipanel (const uipanel::properties& props,
                              const graphics_object& go);
-
+  virtual void draw_uibuttongroup (const uibuttongroup::properties& props,
+                                   const graphics_object& go);
   virtual void init_gl_context (bool enhanced, const Matrix& backgroundColor);
   virtual void setup_opengl_transformation (const axes::properties& props);
 
   virtual void set_color (const Matrix& c);
   virtual void set_polygon_offset (bool on, float offset = 0.0f);
   virtual void set_linewidth (float w);
   virtual void set_linestyle (const std::string& s, bool stipple = false);
   virtual void set_clipbox (double x1, double x2, double y1, double y2,
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1066,17 +1066,18 @@ lookup_object_name (const caseless_str& 
                               pfx = name.substr (0, 12);
 
                               if (pfx.compare ("uitoggletool"))
                                 offset = 12;
                               else if (len >= 13)
                                 {
                                   pfx = name.substr (0, 13);
 
-                                  if (pfx.compare ("uicontextmenu"))
+                                  if (pfx.compare ("uicontextmenu") ||
+                                      pfx.compare ("uibuttongroup"))
                                     offset = 13;
                                 }
                             }
                         }
                     }
                 }
             }
         }
@@ -1118,16 +1119,18 @@ make_graphics_object_from_type (const ca
   else if (type.compare ("hggroup"))
     go = new hggroup (h, p);
   else if (type.compare ("uimenu"))
     go = new uimenu (h, p);
   else if (type.compare ("uicontrol"))
     go = new uicontrol (h, p);
   else if (type.compare ("uipanel"))
     go = new uipanel (h, p);
+  else if (type.compare ("uibuttongroup"))
+    go = new uibuttongroup (h, p);
   else if (type.compare ("uicontextmenu"))
     go = new uicontextmenu (h, p);
   else if (type.compare ("uitoolbar"))
     go = new uitoolbar (h, p);
   else if (type.compare ("uipushtool"))
     go = new uipushtool (h, p);
   else if (type.compare ("uitoggletool"))
     go = new uitoggletool (h, p);
@@ -1980,17 +1983,18 @@ property_list::set (const caseless_str& 
                               pfx = name.substr (0, 12);
 
                               if (pfx.compare ("uitoogletool"))
                                 offset = 12;
                               else if (len > 13)
                                 {
                                   pfx = name.substr (0, 13);
 
-                                  if (pfx.compare ("uicontextmenu"))
+                                  if (pfx.compare ("uicontextmenu")
+                                      || pfx.compare ("uibuttongroup"))
                                     offset = 13;
                                 }
                             }
                         }
                     }
                 }
             }
         }
@@ -2021,16 +2025,18 @@ property_list::set (const caseless_str& 
           else if (pfx == "surface")
             has_property = surface::properties::has_core_property (pname);
           else if (pfx == "hggroup")
             has_property = hggroup::properties::has_core_property (pname);
           else if (pfx == "uimenu")
             has_property = uimenu::properties::has_core_property (pname);
           else if (pfx == "uicontrol")
             has_property = uicontrol::properties::has_core_property (pname);
+          else if (pfx == "uibuttongroup")
+            has_property = uibuttongroup::properties::has_core_property (pname);
           else if (pfx == "uipanel")
             has_property = uipanel::properties::has_core_property (pname);
           else if (pfx == "uicontextmenu")
             has_property = uicontextmenu::properties::has_core_property (pname);
           else if (pfx == "uitoolbar")
             has_property = uitoolbar::properties::has_core_property (pname);
           else if (pfx == "uipushtool")
             has_property = uipushtool::properties::has_core_property (pname);
@@ -2117,17 +2123,18 @@ property_list::lookup (const caseless_st
                               pfx = name.substr (0, 12);
 
                               if (pfx.compare ("uitoggletool"))
                                 offset = 12;
                               else if (len > 13)
                                 {
                                   pfx = name.substr (0, 13);
 
-                                  if (pfx.compare ("uicontextmenu"))
+                                  if (pfx.compare ("uicontextmenu")
+                                      || pfx.compare ("uibuttongroup"))
                                     offset = 13;
                                 }
                             }
                         }
                     }
                 }
             }
         }
@@ -8815,16 +8822,186 @@ uicontrol::properties::get_fontsize_poin
     parent_height = get_boundingbox (false).elem (3);
 
   return convert_font_size (fontsz, get_fontunits (), "points", parent_height);
 }
 
 // ---------------------------------------------------------------------
 
 Matrix
+uibuttongroup::properties::get_boundingbox (bool internal,
+                                            const Matrix& parent_pix_size) const
+{
+  Matrix pos = get_position ().matrix_value ();
+  Matrix parent_size (parent_pix_size);
+
+  if (parent_size.is_empty ())
+    {
+      graphics_object go = gh_manager::get_object (get_parent ());
+
+      parent_size =
+        go.get_properties ().get_boundingbox (true).extract_n (0, 2, 1, 2);
+    }
+
+  pos = convert_position (pos, get_units (), "pixels", parent_size);
+
+  pos(0)--;
+  pos(1)--;
+  pos(1) = parent_size(1) - pos(1) - pos(3);
+
+  if (internal)
+    {
+      double outer_height = pos(3);
+
+      pos(0) = pos(1) = 0;
+
+      if (! bordertype_is ("none"))
+        {
+          double bw = get_borderwidth ();
+          double mul = 1.0;
+
+          if (bordertype_is ("etchedin") || bordertype_is ("etchedout"))
+            mul = 2.0;
+
+          pos(0) += mul * bw;
+          pos(1) += mul * bw;
+          pos(2) -= 2 * mul * bw;
+          pos(3) -= 2 * mul * bw;
+        }
+
+      if (! get_title ().empty ())
+        {
+          double fontsz = get_fontsize ();
+
+          if (! fontunits_is ("pixels"))
+            {
+              double res = xget (0, "screenpixelsperinch").double_value ();
+
+              if (fontunits_is ("points"))
+                fontsz *= (res / 72.0);
+              else if (fontunits_is ("inches"))
+                fontsz *= res;
+              else if (fontunits_is ("centimeters"))
+                fontsz *= (res / 2.54);
+              else if (fontunits_is ("normalized"))
+                fontsz *= outer_height;
+            }
+
+          if (titleposition_is ("lefttop") || titleposition_is ("centertop")
+              || titleposition_is ("righttop"))
+            pos(1) += (fontsz / 2);
+          pos(3) -= (fontsz / 2);
+        }
+    }
+
+  return pos;
+}
+
+void
+uibuttongroup::properties::set_units (const octave_value& val)
+{
+  caseless_str old_units = get_units ();
+
+  if (units.set (val, true))
+    {
+      update_units (old_units);
+      mark_modified ();
+    }
+}
+
+void
+uibuttongroup::properties::update_units (const caseless_str& old_units)
+{
+  Matrix pos = get_position ().matrix_value ();
+
+  graphics_object parent_go = gh_manager::get_object (get_parent ());
+  Matrix parent_bbox = parent_go.get_properties ().get_boundingbox (true);
+  Matrix parent_size = parent_bbox.extract_n (0, 2, 1, 2);
+
+  pos = convert_position (pos, old_units, get_units (), parent_size);
+  set_position (pos);
+}
+
+void
+uibuttongroup::properties::set_fontunits (const octave_value& val)
+{
+  caseless_str old_fontunits = get_fontunits ();
+
+  if (fontunits.set (val, true))
+    {
+      update_fontunits (old_fontunits);
+      mark_modified ();
+    }
+}
+
+void
+uibuttongroup::properties::update_fontunits (const caseless_str& old_units)
+{
+  caseless_str new_units = get_fontunits ();
+  double parent_height = get_boundingbox (false).elem (3);
+  double fontsz = get_fontsize ();
+
+  fontsz = convert_font_size (fontsz, old_units, new_units, parent_height);
+
+  set_fontsize (octave_value (fontsz));
+}
+
+double
+uibuttongroup::properties::get_fontsize_points (double box_pix_height) const
+{
+  double fontsz = get_fontsize ();
+  double parent_height = box_pix_height;
+
+  if (fontunits_is ("normalized") && parent_height <= 0)
+    parent_height = get_boundingbox (false).elem (3);
+
+  return convert_font_size (fontsz, get_fontunits (), "points", parent_height);
+}
+
+void
+uibuttongroup::properties::set_selectedobject (const octave_value& v)
+{
+  graphics_handle current_selectedobject = get_selectedobject();
+  selectedobject = current_selectedobject;
+  if (v.is_empty ())
+    {
+      if (current_selectedobject.ok ())
+        {
+          selectedobject = graphics_handle ();
+          mark_modified ();
+        }
+      return;
+    }
+
+  graphics_handle val (v);
+  if (val.ok ())
+    {
+      graphics_object go (gh_manager::get_object (val));
+      base_properties& gop = go.get_properties ();
+
+      if (go.valid_object ()
+          && gop.get_parent () == get___myhandle__ ()
+          && go.isa ("uicontrol"))
+        {
+          uicontrol::properties& cop = dynamic_cast<uicontrol::properties&> (go.get_properties ());
+          const caseless_str& style = cop.get_style ();
+          if (style.compare ("radiobutton") || style.compare ("togglebutton"))
+            {
+              selectedobject = val;
+              mark_modified ();
+              return;
+            }
+        }
+    }
+  err_set_invalid ("selectedobject");
+}
+
+// ---------------------------------------------------------------------
+
+Matrix
 uipanel::properties::get_boundingbox (bool internal,
                                       const Matrix& parent_pix_size) const
 {
   Matrix pos = get_position ().matrix_value ();
   Matrix parent_size (parent_pix_size);
 
   if (parent_size.is_empty ())
     {
@@ -9534,16 +9711,17 @@ root_figure::init_factory_properties (vo
   plist_map["text"] = text::properties::factory_defaults ();
   plist_map["image"] = image::properties::factory_defaults ();
   plist_map["patch"] = patch::properties::factory_defaults ();
   plist_map["surface"] = surface::properties::factory_defaults ();
   plist_map["light"] = light::properties::factory_defaults ();
   plist_map["hggroup"] = hggroup::properties::factory_defaults ();
   plist_map["uimenu"] = uimenu::properties::factory_defaults ();
   plist_map["uicontrol"] = uicontrol::properties::factory_defaults ();
+  plist_map["uibuttongroup"] = uibuttongroup::properties::factory_defaults ();
   plist_map["uipanel"] = uipanel::properties::factory_defaults ();
   plist_map["uicontextmenu"] = uicontextmenu::properties::factory_defaults ();
   plist_map["uitoolbar"] = uitoolbar::properties::factory_defaults ();
   plist_map["uipushtool"] = uipushtool::properties::factory_defaults ();
   plist_map["uitoggletool"] = uitoggletool::properties::factory_defaults ();
 
   return plist_map;
 }
@@ -10390,16 +10568,25 @@ DEFUN (__go_uicontrol__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __go_uicontrol__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (uicontrol);
 }
 
+DEFUN (__go_uibuttongroup__, args, ,
+       "-*- texinfo -*-\n\
+@deftypefn {} {} __go_uibuttongroup__ (@var{parent})\n\
+Undocumented internal function.\n\
+@end deftypefn")
+{
+  GO_BODY (uibuttongroup);
+}
+
 DEFUN (__go_uipanel__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __go_uipanel__ (@var{parent})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   GO_BODY (uipanel);
 }
@@ -11521,9 +11708,8 @@ Undocumented internal function.\n\
       double factor = args(2).scalar_value ();
 
       ax_props.zoom (mode, factor);
       Vdrawnow_requested = true;
     }
 
   return ovl ();
 }
-
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -5563,16 +5563,101 @@ public:
     if (! retval)
       retval = base_properties::has_readonly_property (pname);
     return retval;
   }
 };
 
 // ---------------------------------------------------------------------
 
+class OCTINTERP_API uibuttongroup : public base_graphics_object
+{
+public:
+  class OCTINTERP_API properties : public base_properties
+  {
+  public:
+    Matrix get_boundingbox (bool internal = false,
+                            const Matrix& parent_pix_size = Matrix ()) const;
+
+    double get_fontsize_points (double box_pix_height = 0) const;
+
+    // See the genprops.awk script for an explanation of the
+    // properties declarations.
+    // Programming note: Keep property list sorted if new ones are added.
+
+    BEGIN_PROPERTIES (uibuttongroup)
+      any_property __object__ h , Matrix ()
+      color_property backgroundcolor , color_values (1, 1, 1)
+      radio_property bordertype , "none|{etchedin}|etchedout|beveledin|beveledout|line"
+      double_property borderwidth , 1
+      bool_property clipping , "on"
+      radio_property fontangle , "{normal}|italic|oblique"
+      string_property fontname , OCTAVE_DEFAULT_FONTNAME
+      double_property fontsize , 10
+      radio_property fontunits S , "inches|centimeters|normalized|{points}|pixels"
+      radio_property fontweight , "light|{normal}|demi|bold"
+      color_property foregroundcolor , color_values (0, 0, 0)
+      color_property highlightcolor , color_values (1, 1, 1)
+      array_property position , default_panel_position ()
+      callback_property resizefcn , Matrix ()
+      handle_property selectedobject S , graphics_handle()
+      callback_property selectionchangedfcn , Matrix()
+      color_property shadowcolor , color_values (0, 0, 0)
+      callback_property sizechangedfcn , Matrix ()
+      radio_property units S , "{normalized}|inches|centimeters|points|pixels|characters"
+      string_property title , ""
+      radio_property titleposition , "{lefttop}|centertop|righttop|leftbottom|centerbottom|rightbottom"
+    END_PROPERTIES
+
+  protected:
+    void init (void)
+    {
+      position.add_constraint (dim_vector (1, 4));
+    }
+
+    // void update_text_extent (void);
+    // void update_string (void) { update_text_extent (); }
+    // void update_fontname (void) { update_text_extent (); }
+    // void update_fontsize (void) { update_text_extent (); }
+    // void update_fontangle (void) { update_text_extent (); }
+    // void update_fontweight (void) { update_text_extent (); }
+
+    void update_units (const caseless_str& old_units);
+    void update_fontunits (const caseless_str& old_units);
+
+  };
+
+private:
+  properties xproperties;
+
+public:
+  uibuttongroup (const graphics_handle& mh, const graphics_handle& p)
+    : base_graphics_object (), xproperties (mh, p)
+  { }
+
+  ~uibuttongroup (void) { }
+
+  base_properties& get_properties (void) { return xproperties; }
+
+  const base_properties& get_properties (void) const { return xproperties; }
+
+  bool valid_object (void) const { return true; }
+
+  bool has_readonly_property (const caseless_str& pname) const
+  {
+    bool retval = xproperties.has_readonly_property (pname);
+    if (! retval)
+      retval = base_properties::has_readonly_property (pname);
+    return retval;
+  }
+
+};
+
+// ---------------------------------------------------------------------
+
 class OCTINTERP_API uipanel : public base_graphics_object
 {
 public:
   class OCTINTERP_API properties : public base_properties
   {
   public:
     Matrix get_boundingbox (bool internal = false,
                             const Matrix& parent_pix_size = Matrix ()) const;
diff --git a/scripts/gui/module.mk b/scripts/gui/module.mk
--- a/scripts/gui/module.mk
+++ b/scripts/gui/module.mk
@@ -16,16 +16,17 @@ scripts_gui_FCN_FILES = \
   scripts/gui/errordlg.m \
   scripts/gui/guidata.m \
   scripts/gui/guihandles.m \
   scripts/gui/helpdlg.m \
   scripts/gui/inputdlg.m \
   scripts/gui/listdlg.m \
   scripts/gui/msgbox.m \
   scripts/gui/questdlg.m \
+  scripts/gui/uibuttongroup.m \
   scripts/gui/uicontextmenu.m \
   scripts/gui/uicontrol.m \
   scripts/gui/uigetdir.m \
   scripts/gui/uigetfile.m \
   scripts/gui/uimenu.m \
   scripts/gui/uipanel.m \
   scripts/gui/uipushtool.m \
   scripts/gui/uiputfile.m \
diff --git a/scripts/gui/uibuttongroup.m b/scripts/gui/uibuttongroup.m
new file mode 100644
--- /dev/null
+++ b/scripts/gui/uibuttongroup.m
@@ -0,0 +1,104 @@
+## Copyright (C) 2016 Andrew Thornton
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {} {@var{hui} =} uibuttongroup (@var{property}, @var{value}, @dots{})
+## @deftypefnx {} {@var{hui} =} uibuttongroup (@var{parent}, @var{property}, @var{value}, @dots{})
+## @deftypefnx {} {} uibuttongroup (@var{h})
+##
+## Create a uibuttongroup object and return a handle to it.
+##
+## uibuttongroups are used to create group uicontrols.
+##
+## If @var{parent} is omitted then a uibuttongroup for the current figure is
+## created.  If no figure is available, a new figure is created first.
+##
+## If @var{parent} is given then a uibuttongroup relative to @var{parent} is
+## created.
+##
+## Any provided property value pairs will override the default values of the
+## created uibuttongroup object.
+##
+## Uibuttongroup properties are documented at @ref{Uibuttongroup Properties}.
+##
+## Examples:
+##
+## @example
+## @group
+## % create figure and panel on it
+## f = figure;
+## % create a button group
+## gp = uibuttongroup (f, "Position", [ 0 0.5 1 1])
+## % create a buttons in the group
+## b1 = uicontrol (gp, "style", "radiobutton", ...
+##                 "string", "Choice 1", ...
+##                 "Position", [ 10 150 100 50 ]);
+## b2 = uicontrol (gp, "style", "radiobutton", ...
+##                 "string", "Choice 2", ...
+##                 "Position", [ 10 50 100 30 ]);
+## % create a button not in the group
+## b3 = uicontrol (f, "style", "radiobutton", ...
+##                 "string", "Not in the group", ...
+##                 "Position", [ 10 50 100 50 ]);
+## @end group
+## @end example
+## @seealso{figure, uipanel}
+## @end deftypefn
+
+## Author: zeripath
+
+function hui = uibuttongroup (varargin)
+
+  if (nargin == 1 && ishandle (varargin{1})
+      && strcmpi (get (varargin{1}, "type"), "uibuttongroup"))
+    error ("uibuttongroup: focusing not implemented yet");
+  endif
+
+  [h, args] = __uiobject_split_args__ ("uibuttongroup", varargin,
+                                       {"figure", "uipanel", "uibuttongroup"});
+  hui = __go_uibuttongroup__ (h, args{:});
+
+endfunction
+
+%!demo
+%! f = figure;
+%! gp = uibuttongroup (f, "Position", [ 0 0.5 1 1], ...
+%!                     "selectionchangedfcn", ...
+%!                     @(x, y) display (['Selection Changed: ' get(y.NewValue, 'String')]));
+%! b1 = uicontrol (gp, "style", "radiobutton", ...
+%!                 "string", "Choice 1", ...
+%!                 "Position", [ 10 150 100 50 ]);
+%! b2 = uicontrol (gp, "style", "radiobutton", ...
+%!                 "string", "Choice 2", ...
+%!                 "Position", [ 10 50 100 30 ]);
+%! b3 = uicontrol (f, "style", "radiobutton", ...
+%!                 "string", "Not in the group", ...
+%!                 "Position", [ 10 50 100 50 ]);
+%! disp (['Current selected: ' get(get(gp, 'selectedobject'), 'String')]);
+%! pause (0.5);
+%! disp (['Select None']);
+%! set (gp, 'selectedobject', []);
+%! pause (0.1);
+%! disp (['Current selected: ' get(get(gp, 'selectedobject'), 'String')]);
+%! pause (0.5);
+%! disp (['Select b1']);
+%! set (gp, 'selectedobject', b1);
+%! disp (['Current selected: ' get(get(gp, 'selectedobject'), 'String')]);
+
+## Uncertain if tests can be performed
+%!assert (1)
diff --git a/scripts/help/__unimplemented__.m b/scripts/help/__unimplemented__.m
--- a/scripts/help/__unimplemented__.m
+++ b/scripts/help/__unimplemented__.m
@@ -840,17 +840,16 @@ function list = missing_functions ()
   "timeofday",
   "timer",
   "timeseries",
   "timezones",
   "todatenum",
   "toolboxdir",
   "triangulation",
   "tscollection",
-  "uibuttongroup",
   "uigetpref",
   "uiimport",
   "uiopen",
   "uiresume",
   "uisave",
   "uisetcolor",
   "uisetfont",
   "uisetpref",
@@ -895,9 +894,8 @@ endfunction
 
 %!test
 %! str = __unimplemented__ ("no_name_function");
 %! assert (isempty (str));
 %! str = __unimplemented__ ("quad2d");
 %! assert (str(1:51), "quad2d is not implemented.  Consider using dblquad.");
 %! str = __unimplemented__ ("MException");
 %! assert (str(1:58), "the 'MException' function is not yet implemented in Octave");
-
