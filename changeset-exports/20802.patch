# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1449248624 18000
#      Fri Dec 04 12:03:44 2015 -0500
# Node ID 8bb38ba1bad6b4a1d246ee36edd5918d877ad03b
# Parent  a542a9bf177e0b174628c340def6f4a9eb7c762a
eliminate return statements after calls to print_usage

* __contourc__.cc, __dispatch__.cc, __dsearchn__.cc, __ichol__.cc,
__lin_interpn__.cc, __qp__.cc, balance.cc, betainc.cc, bsxfun.cc,
colloc.cc, daspk.cc, dasrt.cc, dassl.cc, defaults.cc, det.cc,
dlmread.cc, dot.cc, eig.cc, ellipj.cc, fft.cc, fft2.cc, fftn.cc,
filter.cc, find.cc, gcd.cc, givens.cc, hex2num.cc, inv.cc, lookup.cc,
lu.cc, max.cc, mgorth.cc, ordschur.cc, pinv.cc, profiler.cc, quad.cc,
qz.cc, rcond.cc, schur.cc, str2double.cc:
Eliminate return statements after calls to print_usage.

diff --git a/libinterp/corefcn/__contourc__.cc b/libinterp/corefcn/__contourc__.cc
--- a/libinterp/corefcn/__contourc__.cc
+++ b/libinterp/corefcn/__contourc__.cc
@@ -39,16 +39,17 @@ along with Octave; see the file COPYING.
 #include <cfloat>
 
 #include "quit.h"
 
 #include "defun.h"
 #include "error.h"
 #include "oct-obj.h"
 
+// FIXME: this looks like trouble...
 static Matrix this_contour;
 static Matrix contourc;
 static int elem;
 
 // This is the quanta in which we increase this_contour.
 #define CONTOUR_QUANT 50
 
 // Add a coordinate point (x,y) to this_contour.
@@ -298,36 +299,30 @@ cntr (const RowVector& X, const RowVecto
 }
 
 DEFUN (__contourc__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __contourc__ (@var{x}, @var{y}, @var{z}, @var{levels})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 4)
-    {
-      RowVector X = args(0).row_vector_value ();
-      RowVector Y = args(1).row_vector_value ();
-      Matrix Z = args(2).matrix_value ();
-      RowVector L = args(3).row_vector_value ();
-
-      contourc.resize (2, 0);
-
-      for (int i = 0; i < L.numel (); i++)
-        cntr (X, Y, Z, L (i));
-
-      end_contour ();
-
-      retval = contourc;
-    }
-  else
+  if (args.length () != 4)
     print_usage ();
 
-  return retval;
+  RowVector X = args(0).row_vector_value ();
+  RowVector Y = args(1).row_vector_value ();
+  Matrix Z = args(2).matrix_value ();
+  RowVector L = args(3).row_vector_value ();
+
+  contourc.resize (2, 0);
+
+  for (int i = 0; i < L.numel (); i++)
+    cntr (X, Y, Z, L (i));
+
+  end_contour ();
+
+  return octave_value (contourc);
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
diff --git a/libinterp/corefcn/__dispatch__.cc b/libinterp/corefcn/__dispatch__.cc
--- a/libinterp/corefcn/__dispatch__.cc
+++ b/libinterp/corefcn/__dispatch__.cc
@@ -41,71 +41,69 @@ along with Octave; see the file COPYING.
 
 DEFUN (__dispatch__, args, nargout,
        "Undocumented internal function")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin > 0 && nargin < 4)
-    {
-      std::string f, r, t;
+  if (nargin < 1 || nargin > 3)
+    print_usage ();
 
-      f = args(0).xstring_value ("__dispatch__: first argument must be a function name");
+  std::string f, r, t;
 
-      if (nargin > 1)
-        r = args(1).xstring_value ("__dispatch__: second argument must be a function name");
+  f = args(0).xstring_value ("__dispatch__: first argument must be a function name");
 
-      if (nargin > 2)
-        t = args(2).xstring_value ("__dispatch__: third argument must be a type name");
+  if (nargin > 1)
+    r = args(1).xstring_value ("__dispatch__: second argument must be a function name");
 
-      if (nargin == 1)
+  if (nargin > 2)
+    t = args(2).xstring_value ("__dispatch__: third argument must be a type name");
+
+  if (nargin == 1)
+    {
+      if (nargout > 0)
         {
-          if (nargout > 0)
-            {
-              symbol_table::fcn_info::dispatch_map_type dm
-                = symbol_table::get_dispatch (f);
-
-              size_t len = dm.size ();
-
-              Cell type_field (len, 1);
-              Cell name_field (len, 1);
+          symbol_table::fcn_info::dispatch_map_type dm
+            = symbol_table::get_dispatch (f);
 
-              symbol_table::fcn_info::dispatch_map_type::const_iterator p
-                = dm.begin ();
+          size_t len = dm.size ();
 
-              for (size_t i = 0; i < len; i++)
-                {
-                  type_field(i) = p->first;
-                  name_field(i) = p->second;
+          Cell type_field (len, 1);
+          Cell name_field (len, 1);
 
-                  p++;
-                }
-
-              octave_scalar_map m;
+          symbol_table::fcn_info::dispatch_map_type::const_iterator p
+            = dm.begin ();
 
-              m.assign ("type", type_field);
-              m.assign ("name", name_field);
+          for (size_t i = 0; i < len; i++)
+            {
+              type_field(i) = p->first;
+              name_field(i) = p->second;
 
-              retval = m;
+              p++;
             }
-          else
-            symbol_table::print_dispatch (octave_stdout, f);
-        }
-      else if (nargin == 2)
-        {
-          t = r;
-          symbol_table::clear_dispatch (f, t);
+
+          octave_scalar_map m;
+
+          m.assign ("type", type_field);
+          m.assign ("name", name_field);
+
+          retval = m;
         }
       else
-        symbol_table::add_dispatch (f, t, r);
+        symbol_table::print_dispatch (octave_stdout, f);
+    }
+  else if (nargin == 2)
+    {
+      t = r;
+      symbol_table::clear_dispatch (f, t);
     }
   else
-    print_usage ();
+    symbol_table::add_dispatch (f, t, r);
 
   return retval;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
diff --git a/libinterp/corefcn/__dsearchn__.cc b/libinterp/corefcn/__dsearchn__.cc
--- a/libinterp/corefcn/__dsearchn__.cc
+++ b/libinterp/corefcn/__dsearchn__.cc
@@ -39,20 +39,17 @@ DEFUN (__dsearchn__, args, ,
 @deftypefn {Built-in Function} {[@var{idx}, @var{d}] =} dsearch (@var{x}, @var{xi})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 2)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   Matrix x = args(0).matrix_value ().transpose ();
   Matrix xi = args(1).matrix_value ().transpose ();
 
   if (x.rows () != xi.rows () || x.columns () < 1)
     error ("__dsearch__: number of rows of X and XI must match");
   else
     {
diff --git a/libinterp/corefcn/__ichol__.cc b/libinterp/corefcn/__ichol__.cc
--- a/libinterp/corefcn/__ichol__.cc
+++ b/libinterp/corefcn/__ichol__.cc
@@ -197,20 +197,17 @@ Undocumented internal function.\n\
 
 {
   octave_value_list retval;
 
   int nargin = args.length ();
   std::string michol = "off";
 
   if (nargout > 1 || nargin < 1 || nargin > 2)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   if (nargin == 2)
     michol = args(1).string_value ();
 
   // In ICHOL0 algorithm the zero-pattern of the input matrix is preserved
   // so it's structure does not change during the algorithm.  The same input
   // matrix is used to build the output matrix due to that fact.
   octave_value_list param_list;
@@ -451,20 +448,17 @@ Undocumented internal function.\n\
 {
   octave_value_list retval;
   int nargin = args.length ();
   // Default values of parameters
   std::string michol = "off";
   double droptol = 0;
 
   if (nargout > 1 || nargin < 1 || nargin > 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   // Don't repeat input validation of arguments done in ichol.m
 
   if (nargin >= 2)
     droptol = args(1).double_value ();
 
   if (nargin == 3)
     michol = args(2).string_value ();
diff --git a/libinterp/corefcn/__lin_interpn__.cc b/libinterp/corefcn/__lin_interpn__.cc
--- a/libinterp/corefcn/__lin_interpn__.cc
+++ b/libinterp/corefcn/__lin_interpn__.cc
@@ -273,20 +273,17 @@ DEFUN (__lin_interpn__, args, ,
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 2 ||  nargin % 2 == 0)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   // dimension of the problem
   int n = (nargin-1)/2;
 
   if (args(n).is_single_type ())
     {
       OCTAVE_LOCAL_BUFFER (FloatNDArray, X, n);
       OCTAVE_LOCAL_BUFFER (FloatNDArray, Y, n);
diff --git a/libinterp/corefcn/__qp__.cc b/libinterp/corefcn/__qp__.cc
--- a/libinterp/corefcn/__qp__.cc
+++ b/libinterp/corefcn/__qp__.cc
@@ -488,44 +488,42 @@ qp (const Matrix& H, const ColumnVector&
 DEFUN (__qp__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{x}, @var{lambda}, @var{info}, @var{iter}] =} __qp__ (@var{x0}, @var{H}, @var{q}, @var{Aeq}, @var{beq}, @var{Ain}, @var{bin}, @var{maxit})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  if (args.length () == 8)
-    {
-      const ColumnVector x0  (args(0) . vector_value ());
-      const Matrix H         (args(1) . matrix_value ());
-      const ColumnVector q   (args(2) . vector_value ());
-      const Matrix Aeq       (args(3) . matrix_value ());
-      const ColumnVector beq (args(4) . vector_value ());
-      const Matrix Ain       (args(5) . matrix_value ());
-      const ColumnVector bin (args(6) . vector_value ());
-      const int maxit        (args(7) . int_value ());
+  if (args.length () != 8)
+    print_usage ();
 
-      int iter = 0;
+  const ColumnVector x0  (args(0) . vector_value ());
+  const Matrix H         (args(1) . matrix_value ());
+  const ColumnVector q   (args(2) . vector_value ());
+  const Matrix Aeq       (args(3) . matrix_value ());
+  const ColumnVector beq (args(4) . vector_value ());
+  const Matrix Ain       (args(5) . matrix_value ());
+  const ColumnVector bin (args(6) . vector_value ());
+  const int maxit        (args(7) . int_value ());
 
-      // Copying the initial guess in the working variable
-      ColumnVector x = x0;
+  int iter = 0;
 
-      // Reordering the Lagrange multipliers
-      ColumnVector lambda;
-
-      int info = qp (H, q, Aeq, beq, Ain, bin, maxit, x, lambda, iter);
+  // Copying the initial guess in the working variable
+  ColumnVector x = x0;
 
-      retval(3) = iter;
-      retval(2) = info;
-      retval(1) = lambda;
-      retval(0) = x;
-    }
-  else
-    print_usage ();
+  // Reordering the Lagrange multipliers
+  ColumnVector lambda;
+
+  int info = qp (H, q, Aeq, beq, Ain, bin, maxit, x, lambda, iter);
+
+  retval(3) = iter;
+  retval(2) = info;
+  retval(1) = lambda;
+  retval(0) = x;
 
   return retval;
 }
 
 /*
 ## No test needed for internal helper function.
 %!assert (1)
 */
diff --git a/libinterp/corefcn/balance.cc b/libinterp/corefcn/balance.cc
--- a/libinterp/corefcn/balance.cc
+++ b/libinterp/corefcn/balance.cc
@@ -91,20 +91,17 @@ Generalized eigenvalue problem balancing
 (SIAM Journal on Scientific and Statistical Computing, 1981).\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3 || nargout < 0 || nargout > 4)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   // determine if it's AEP or GEP
   bool AEPcase = nargin == 1 || args(1).is_string ();
 
   // problem dimension
   octave_idx_type nn = args(0).rows ();
 
   if (nn != args(0).columns ())
diff --git a/libinterp/corefcn/betainc.cc b/libinterp/corefcn/betainc.cc
--- a/libinterp/corefcn/betainc.cc
+++ b/libinterp/corefcn/betainc.cc
@@ -64,189 +64,187 @@ scalars.  If @var{x} is a scalar, @var{a
 compatible dimensions.\n\
 @seealso{betaincinv, beta, betaln}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 3)
-    {
-      octave_value x_arg = args(0);
-      octave_value a_arg = args(1);
-      octave_value b_arg = args(2);
+  if (nargin != 3)
+    print_usage ();
 
-      // FIXME: Can we make a template version of the duplicated code below
-      if (x_arg.is_single_type () || a_arg.is_single_type ()
-          || b_arg.is_single_type ())
-        {
-          if (x_arg.is_scalar_type ())
-            {
-              float x = x_arg.float_value ();
+  octave_value x_arg = args(0);
+  octave_value a_arg = args(1);
+  octave_value b_arg = args(2);
 
-              if (a_arg.is_scalar_type ())
-                {
-                  float a = a_arg.float_value ();
-
-                  if (b_arg.is_scalar_type ())
-                    {
-                      float b = b_arg.float_value ();
+  // FIXME: Can we make a template version of the duplicated code below
+  if (x_arg.is_single_type () || a_arg.is_single_type ()
+      || b_arg.is_single_type ())
+    {
+      if (x_arg.is_scalar_type ())
+        {
+          float x = x_arg.float_value ();
 
-                      retval = betainc (x, a, b);
-                    }
-                  else
-                    {
-                      Array<float> b = b_arg.float_array_value ();
+          if (a_arg.is_scalar_type ())
+            {
+              float a = a_arg.float_value ();
 
-                      retval = betainc (x, a, b);
-                    }
+              if (b_arg.is_scalar_type ())
+                {
+                  float b = b_arg.float_value ();
+
+                  retval = betainc (x, a, b);
                 }
               else
                 {
-                  Array<float> a = a_arg.float_array_value ();
-
-                  if (b_arg.is_scalar_type ())
-                    {
-                      float b = b_arg.float_value ();
+                  Array<float> b = b_arg.float_array_value ();
 
-                      retval = betainc (x, a, b);
-                    }
-                  else
-                    {
-                      Array<float> b = b_arg.float_array_value ();
-
-                      retval = betainc (x, a, b);
-                    }
+                  retval = betainc (x, a, b);
                 }
             }
           else
             {
-              Array<float> x = x_arg.float_array_value ();
-
-              if (a_arg.is_scalar_type ())
-                {
-                  float a = a_arg.float_value ();
+              Array<float> a = a_arg.float_array_value ();
 
-                  if (b_arg.is_scalar_type ())
-                    {
-                      float b = b_arg.float_value ();
+              if (b_arg.is_scalar_type ())
+                {
+                  float b = b_arg.float_value ();
 
-                      retval = betainc (x, a, b);
-                    }
-                  else
-                    {
-                      Array<float> b = b_arg.float_array_value ();
-
-                      retval = betainc (x, a, b);
-                    }
+                  retval = betainc (x, a, b);
                 }
               else
                 {
-                  Array<float> a = a_arg.float_array_value ();
-
-                  if (b_arg.is_scalar_type ())
-                    {
-                      float b = b_arg.float_value ();
+                  Array<float> b = b_arg.float_array_value ();
 
-                      retval = betainc (x, a, b);
-                    }
-                  else
-                    {
-                      Array<float> b = b_arg.float_array_value ();
-
-                      retval = betainc (x, a, b);
-                    }
+                  retval = betainc (x, a, b);
                 }
             }
         }
       else
         {
-          if (x_arg.is_scalar_type ())
-            {
-              double x = x_arg.double_value ();
+          Array<float> x = x_arg.float_array_value ();
 
-              if (a_arg.is_scalar_type ())
-                {
-                  double a = a_arg.double_value ();
+          if (a_arg.is_scalar_type ())
+            {
+              float a = a_arg.float_value ();
 
-                  if (b_arg.is_scalar_type ())
-                    {
-                      double b = b_arg.double_value ();
+              if (b_arg.is_scalar_type ())
+                {
+                  float b = b_arg.float_value ();
 
-                      retval = betainc (x, a, b);
-                    }
-                  else
-                    {
-                      Array<double> b = b_arg.array_value ();
-
-                      retval = betainc (x, a, b);
-                    }
+                  retval = betainc (x, a, b);
                 }
               else
                 {
-                  Array<double> a = a_arg.array_value ();
-
-                  if (b_arg.is_scalar_type ())
-                    {
-                      double b = b_arg.double_value ();
+                  Array<float> b = b_arg.float_array_value ();
 
-                      retval = betainc (x, a, b);
-                    }
-                  else
-                    {
-                      Array<double> b = b_arg.array_value ();
-
-                      retval = betainc (x, a, b);
-                    }
+                  retval = betainc (x, a, b);
                 }
             }
           else
             {
-              Array<double> x = x_arg.array_value ();
-
-              if (a_arg.is_scalar_type ())
-                {
-                  double a = a_arg.double_value ();
+              Array<float> a = a_arg.float_array_value ();
 
-                  if (b_arg.is_scalar_type ())
-                    {
-                      double b = b_arg.double_value ();
+              if (b_arg.is_scalar_type ())
+                {
+                  float b = b_arg.float_value ();
 
-                      retval = betainc (x, a, b);
-                    }
-                  else
-                    {
-                      Array<double> b = b_arg.array_value ();
-
-                      retval = betainc (x, a, b);
-                    }
+                  retval = betainc (x, a, b);
                 }
               else
                 {
-                  Array<double> a = a_arg.array_value ();
-
-                  if (b_arg.is_scalar_type ())
-                    {
-                      double b = b_arg.double_value ();
+                  Array<float> b = b_arg.float_array_value ();
 
-                      retval = betainc (x, a, b);
-                    }
-                  else
-                    {
-                      Array<double> b = b_arg.array_value ();
-
-                      retval = betainc (x, a, b);
-                    }
+                  retval = betainc (x, a, b);
                 }
             }
         }
     }
   else
-    print_usage ();
+    {
+      if (x_arg.is_scalar_type ())
+        {
+          double x = x_arg.double_value ();
+
+          if (a_arg.is_scalar_type ())
+            {
+              double a = a_arg.double_value ();
+
+              if (b_arg.is_scalar_type ())
+                {
+                  double b = b_arg.double_value ();
+
+                  retval = betainc (x, a, b);
+                }
+              else
+                {
+                  Array<double> b = b_arg.array_value ();
+
+                  retval = betainc (x, a, b);
+                }
+            }
+          else
+            {
+              Array<double> a = a_arg.array_value ();
+
+              if (b_arg.is_scalar_type ())
+                {
+                  double b = b_arg.double_value ();
+
+                  retval = betainc (x, a, b);
+                }
+              else
+                {
+                  Array<double> b = b_arg.array_value ();
+
+                  retval = betainc (x, a, b);
+                }
+            }
+        }
+      else
+        {
+          Array<double> x = x_arg.array_value ();
+
+          if (a_arg.is_scalar_type ())
+            {
+              double a = a_arg.double_value ();
+
+              if (b_arg.is_scalar_type ())
+                {
+                  double b = b_arg.double_value ();
+
+                  retval = betainc (x, a, b);
+                }
+              else
+                {
+                  Array<double> b = b_arg.array_value ();
+
+                  retval = betainc (x, a, b);
+                }
+            }
+          else
+            {
+              Array<double> a = a_arg.array_value ();
+
+              if (b_arg.is_scalar_type ())
+                {
+                  double b = b_arg.double_value ();
+
+                  retval = betainc (x, a, b);
+                }
+              else
+                {
+                  Array<double> b = b_arg.array_value ();
+
+                  retval = betainc (x, a, b);
+                }
+            }
+        }
+    }
 
   return retval;
 }
 
 /*
 ## Double precision
 %!test
 %! a = [1, 1.5, 2, 3];
@@ -301,113 +299,112 @@ The inverse is the value @var{x} such th
 @end example\n\
 @seealso{betainc, beta, betaln}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 3)
-    {
-      octave_value x_arg = args(0);
-      octave_value a_arg = args(1);
-      octave_value b_arg = args(2);
+  if (nargin != 3)
+    print_usage ();
+
+  octave_value x_arg = args(0);
+  octave_value a_arg = args(1);
+  octave_value b_arg = args(2);
 
-      if (x_arg.is_scalar_type ())
+  if (x_arg.is_scalar_type ())
+    {
+      double x = x_arg.double_value ();
+
+      if (a_arg.is_scalar_type ())
         {
-          double x = x_arg.double_value ();
+          double a = a_arg.double_value ();
 
-          if (a_arg.is_scalar_type ())
+          if (b_arg.is_scalar_type ())
             {
-              double a = a_arg.double_value ();
-
-              if (b_arg.is_scalar_type ())
-                {
-                  double b = b_arg.double_value ();
+              double b = b_arg.double_value ();
 
-                  retval = betaincinv (x, a, b);
-                }
-              else
-                {
-                  Array<double> b = b_arg.array_value ();
-
-                  retval = betaincinv (x, a, b);
-                }
+              retval = betaincinv (x, a, b);
             }
           else
             {
-              Array<double> a = a_arg.array_value ();
-
-              if (b_arg.is_scalar_type ())
-                {
-                  double b = b_arg.double_value ();
+              Array<double> b = b_arg.array_value ();
 
-                  retval = betaincinv (x, a, b);
-                }
-              else
-                {
-                  Array<double> b = b_arg.array_value ();
-
-                  retval = betaincinv (x, a, b);
-                }
+              retval = betaincinv (x, a, b);
             }
         }
       else
         {
-          Array<double> x = x_arg.array_value ();
+          Array<double> a = a_arg.array_value ();
+
+          if (b_arg.is_scalar_type ())
+            {
+              double b = b_arg.double_value ();
 
-          if (a_arg.is_scalar_type ())
+              retval = betaincinv (x, a, b);
+            }
+          else
             {
-              double a = a_arg.double_value ();
+              Array<double> b = b_arg.array_value ();
 
-              if (b_arg.is_scalar_type ())
-                {
-                  double b = b_arg.double_value ();
+              retval = betaincinv (x, a, b);
+            }
+        }
+    }
+  else
+    {
+      Array<double> x = x_arg.array_value ();
 
-                  retval = betaincinv (x, a, b);
-                }
-              else
-                {
-                  Array<double> b = b_arg.array_value ();
+      if (a_arg.is_scalar_type ())
+        {
+          double a = a_arg.double_value ();
 
-                  retval = betaincinv (x, a, b);
-                }
+          if (b_arg.is_scalar_type ())
+            {
+              double b = b_arg.double_value ();
+
+              retval = betaincinv (x, a, b);
             }
           else
             {
-              Array<double> a = a_arg.array_value ();
-
-              if (b_arg.is_scalar_type ())
-                {
-                  double b = b_arg.double_value ();
+              Array<double> b = b_arg.array_value ();
 
-                  retval = betaincinv (x, a, b);
-                }
-              else
-                {
-                  Array<double> b = b_arg.array_value ();
-
-                  retval = betaincinv (x, a, b);
-                }
+              retval = betaincinv (x, a, b);
             }
         }
+      else
+        {
+          Array<double> a = a_arg.array_value ();
 
-      // FIXME: It would be better to have an algorithm for betaincinv which
-      // accepted float inputs and returned float outputs.  As it is, we do
-      // extra work to calculate betaincinv to double precision and then throw
-      // that precision away.
-      if (x_arg.is_single_type () || a_arg.is_single_type ()
-          || b_arg.is_single_type ())
-        {
-          retval = Array<float> (retval.array_value ());
+          if (b_arg.is_scalar_type ())
+            {
+              double b = b_arg.double_value ();
+
+              retval = betaincinv (x, a, b);
+            }
+          else
+            {
+              Array<double> b = b_arg.array_value ();
+
+              retval = betaincinv (x, a, b);
+            }
         }
     }
-  else
-    print_usage ();
+
+  // FIXME: It would be better to have an algorithm for betaincinv which
+  // accepted float inputs and returned float outputs.  As it is, we do
+  // extra work to calculate betaincinv to double precision and then throw
+  // that precision away.
+  if (x_arg.is_single_type () || a_arg.is_single_type ()
+      || b_arg.is_single_type ())
+    {
+      retval = Array<float> (retval.array_value ());
+    }
+
 
   return retval;
 }
 
 /*
 %!assert (betaincinv ([0.875 0.6875], [1 2], 3), [0.5 0.5], sqrt (eps))
 %!assert (betaincinv (0.5, 3, 3), 0.5, sqrt (eps))
 %!assert (betaincinv (0.34375, 4, 3), 0.5, sqrt (eps))
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -130,18 +130,20 @@ do_bsxfun_real_pow (const octave_value& 
 static void maybe_fill_table (void)
 {
   static bool filled = false;
   if (filled)
     return;
 
 #define REGISTER_OP_HANDLER(OP, BTYP, NDA, FUNOP) \
   bsxfun_handler_table[OP][BTYP] = bsxfun_forward_op<NDA, FUNOP>
+
 #define REGISTER_REL_HANDLER(REL, BTYP, NDA, FUNREL) \
   bsxfun_handler_table[REL][BTYP] = bsxfun_forward_rel<NDA, FUNREL>
+
 #define REGISTER_STD_HANDLERS(BTYP, NDA) \
   REGISTER_OP_HANDLER (bsxfun_builtin_plus, BTYP, NDA, bsxfun_add); \
   REGISTER_OP_HANDLER (bsxfun_builtin_minus, BTYP, NDA, bsxfun_sub); \
   REGISTER_OP_HANDLER (bsxfun_builtin_times, BTYP, NDA, bsxfun_mul); \
   REGISTER_OP_HANDLER (bsxfun_builtin_divide, BTYP, NDA, bsxfun_div); \
   REGISTER_OP_HANDLER (bsxfun_builtin_max, BTYP, NDA, bsxfun_max); \
   REGISTER_OP_HANDLER (bsxfun_builtin_min, BTYP, NDA, bsxfun_min); \
   REGISTER_REL_HANDLER (bsxfun_builtin_eq, BTYP, NDA, bsxfun_eq); \
@@ -333,332 +335,330 @@ dimensionality as the other array.\n\
 @seealso{arrayfun, cellfun}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 3)
     print_usage ();
-  else
-    {
-      octave_value func = args(0);
+
+  octave_value func = args(0);
 
-      if (func.is_string ())
-        {
-          std::string name = func.string_value ();
-          func = symbol_table::find_function (name);
-          if (func.is_undefined ())
-            error ("bsxfun: invalid function name: %s", name.c_str ());
-        }
-      else if (! (args(0).is_function_handle ()
-               || args(0).is_inline_function ()))
-        error ("bsxfun: F must be a string or function handle");
+  if (func.is_string ())
+    {
+      std::string name = func.string_value ();
+      func = symbol_table::find_function (name);
+      if (func.is_undefined ())
+        error ("bsxfun: invalid function name: %s", name.c_str ());
+    }
+  else if (! (args(0).is_function_handle ()
+              || args(0).is_inline_function ()))
+    error ("bsxfun: F must be a string or function handle");
+
+  const octave_value A = args(1);
+  const octave_value B = args(2);
 
-      const octave_value A = args(1);
-      const octave_value B = args(2);
-
-      if (func.is_builtin_function ()
-          || (func.is_function_handle ()
-              && ! A.is_object () && ! B.is_object ()))
+  if (func.is_builtin_function ()
+      || (func.is_function_handle ()
+          && ! A.is_object () && ! B.is_object ()))
+    {
+      // This may break if the default behavior is overridden.  But if you
+      // override arithmetic operators for builtin classes, you should
+      // expect mayhem anyway (constant folding etc).  Querying
+      // is_overloaded() may not be exactly what we need here.
+      octave_function *fcn_val = func.function_value ();
+      if (fcn_val)
         {
-          // This may break if the default behavior is overridden.  But if you
-          // override arithmetic operators for builtin classes, you should
-          // expect mayhem anyway (constant folding etc).  Querying
-          // is_overloaded() may not be exactly what we need here.
-          octave_function *fcn_val = func.function_value ();
-          if (fcn_val)
-            {
-              octave_value tmp = maybe_optimized_builtin (fcn_val->name (),
-                                                          A, B);
-              if (tmp.is_defined ())
-                retval(0) = tmp;
-            }
+          octave_value tmp = maybe_optimized_builtin (fcn_val->name (),
+                                                      A, B);
+          if (tmp.is_defined ())
+            retval(0) = tmp;
+        }
+    }
+
+  if (retval.empty ())
+    {
+      dim_vector dva = A.dims ();
+      octave_idx_type nda = dva.length ();
+      dim_vector dvb = B.dims ();
+      octave_idx_type ndb = dvb.length ();
+      octave_idx_type nd = nda;
+
+      if (nda > ndb)
+        dvb.resize (nda, 1);
+      else if (nda < ndb)
+        {
+          dva.resize (ndb, 1);
+          nd = ndb;
         }
 
-      if (retval.empty ())
-        {
-          dim_vector dva = A.dims ();
-          octave_idx_type nda = dva.length ();
-          dim_vector dvb = B.dims ();
-          octave_idx_type ndb = dvb.length ();
-          octave_idx_type nd = nda;
+      for (octave_idx_type i = 0; i < nd; i++)
+        if (dva(i) != dvb(i) && dva(i) != 1 && dvb(i) != 1)
+          {
+            error ("bsxfun: dimensions of A and B must match");
+            break;
+          }
 
-          if (nda > ndb)
-            dvb.resize (nda, 1);
-          else if (nda < ndb)
-            {
-              dva.resize (ndb, 1);
-              nd = ndb;
-            }
+      // Find the size of the output
+      dim_vector dvc;
+      dvc.resize (nd);
 
-          for (octave_idx_type i = 0; i < nd; i++)
-            if (dva(i) != dvb(i) && dva(i) != 1 && dvb(i) != 1)
-              {
-                error ("bsxfun: dimensions of A and B must match");
-                break;
-              }
+      for (octave_idx_type i = 0; i < nd; i++)
+        dvc(i) = (dva(i) < 1 ? dva(i)
+                  : (dvb(i) < 1 ? dvb(i)
+                     : (dva(i) > dvb(i)
+                        ? dva(i) : dvb(i))));
 
-          // Find the size of the output
-          dim_vector dvc;
-          dvc.resize (nd);
-
-          for (octave_idx_type i = 0; i < nd; i++)
-            dvc(i) = (dva(i) < 1 ? dva(i)
-                                 : (dvb(i) < 1 ? dvb(i)
-                                               : (dva(i) > dvb(i)
-                                                   ? dva(i) : dvb(i))));
-
-          if (dva == dvb || dva.numel () == 1 || dvb.numel () == 1)
-            {
-              octave_value_list inputs;
-              inputs (0) = A;
-              inputs (1) = B;
-              retval = func.do_multi_index_op (1, inputs);
-            }
-          else if (dvc.numel () < 1)
-            {
-              octave_value_list inputs;
-              inputs (0) = A.resize (dvc);
-              inputs (1) = B.resize (dvc);
-              retval = func.do_multi_index_op (1, inputs);
-            }
-          else
-            {
-              octave_idx_type ncount = 1;
-              for (octave_idx_type i = 1; i < nd; i++)
-                ncount *= dvc(i);
+      if (dva == dvb || dva.numel () == 1 || dvb.numel () == 1)
+        {
+          octave_value_list inputs;
+          inputs (0) = A;
+          inputs (1) = B;
+          retval = func.do_multi_index_op (1, inputs);
+        }
+      else if (dvc.numel () < 1)
+        {
+          octave_value_list inputs;
+          inputs (0) = A.resize (dvc);
+          inputs (1) = B.resize (dvc);
+          retval = func.do_multi_index_op (1, inputs);
+        }
+      else
+        {
+          octave_idx_type ncount = 1;
+          for (octave_idx_type i = 1; i < nd; i++)
+            ncount *= dvc(i);
 
 #define BSXDEF(T) \
-              T result_ ## T; \
-              bool have_ ## T = false;
+  T result_ ## T; \
+  bool have_ ## T = false;
 
-              BSXDEF(NDArray);
-              BSXDEF(ComplexNDArray);
-              BSXDEF(FloatNDArray);
-              BSXDEF(FloatComplexNDArray);
-              BSXDEF(boolNDArray);
-              BSXDEF(int8NDArray);
-              BSXDEF(int16NDArray);
-              BSXDEF(int32NDArray);
-              BSXDEF(int64NDArray);
-              BSXDEF(uint8NDArray);
-              BSXDEF(uint16NDArray);
-              BSXDEF(uint32NDArray);
-              BSXDEF(uint64NDArray);
+          BSXDEF(NDArray);
+          BSXDEF(ComplexNDArray);
+          BSXDEF(FloatNDArray);
+          BSXDEF(FloatComplexNDArray);
+          BSXDEF(boolNDArray);
+          BSXDEF(int8NDArray);
+          BSXDEF(int16NDArray);
+          BSXDEF(int32NDArray);
+          BSXDEF(int64NDArray);
+          BSXDEF(uint8NDArray);
+          BSXDEF(uint16NDArray);
+          BSXDEF(uint32NDArray);
+          BSXDEF(uint64NDArray);
 
-              octave_value Ac ;
-              octave_value_list idxA;
-              octave_value Bc;
-              octave_value_list idxB;
-              octave_value C;
-              octave_value_list inputs;
-              Array<int> ra_idx (dim_vector (dvc.length (), 1), 0);
+          octave_value Ac ;
+          octave_value_list idxA;
+          octave_value Bc;
+          octave_value_list idxB;
+          octave_value C;
+          octave_value_list inputs;
+          Array<int> ra_idx (dim_vector (dvc.length (), 1), 0);
 
 
-              for (octave_idx_type i = 0; i < ncount; i++)
-                {
-                  if (maybe_update_column (Ac, A, dva, dvc, i, idxA))
-                    inputs (0) = Ac;
+          for (octave_idx_type i = 0; i < ncount; i++)
+            {
+              if (maybe_update_column (Ac, A, dva, dvc, i, idxA))
+                inputs (0) = Ac;
 
-                  if (maybe_update_column (Bc, B, dvb, dvc, i, idxB))
-                    inputs (1) = Bc;
+              if (maybe_update_column (Bc, B, dvb, dvc, i, idxB))
+                inputs (1) = Bc;
 
-                  octave_value_list tmp = func.do_multi_index_op (1,
-                                                                  inputs);
+              octave_value_list tmp = func.do_multi_index_op (1,
+                                                              inputs);
 
 #define BSXINIT(T, CLS, EXTRACTOR) \
   (result_type == CLS) \
     { \
       have_ ## T = true; \
       result_ ## T = tmp (0). EXTRACTOR ## _array_value (); \
       result_ ## T .resize (dvc); \
     }
 
-                  if (i == 0)
+              if (i == 0)
+                {
+                  if (! tmp(0).is_sparse_type ())
                     {
-                      if (! tmp(0).is_sparse_type ())
+                      std::string result_type = tmp(0).class_name ();
+                      if (result_type == "double")
                         {
-                          std::string result_type = tmp(0).class_name ();
-                          if (result_type == "double")
+                          if (tmp(0).is_real_type ())
                             {
-                              if (tmp(0).is_real_type ())
-                                {
-                                  have_NDArray = true;
-                                  result_NDArray = tmp(0).array_value ();
-                                  result_NDArray.resize (dvc);
-                                }
-                              else
-                                {
-                                  have_ComplexNDArray = true;
-                                  result_ComplexNDArray =
-                                    tmp(0).complex_array_value ();
-                                  result_ComplexNDArray.resize (dvc);
-                                }
+                              have_NDArray = true;
+                              result_NDArray = tmp(0).array_value ();
+                              result_NDArray.resize (dvc);
                             }
-                          else if (result_type == "single")
+                          else
                             {
-                              if (tmp(0).is_real_type ())
-                                {
-                                  have_FloatNDArray = true;
-                                  result_FloatNDArray
-                                    = tmp(0).float_array_value ();
-                                  result_FloatNDArray.resize (dvc);
-                                }
-                              else
-                                {
-                                  have_ComplexNDArray = true;
-                                  result_ComplexNDArray =
-                                    tmp(0).complex_array_value ();
-                                  result_ComplexNDArray.resize (dvc);
-                                }
+                              have_ComplexNDArray = true;
+                              result_ComplexNDArray =
+                                tmp(0).complex_array_value ();
+                              result_ComplexNDArray.resize (dvc);
                             }
-                          else if BSXINIT(boolNDArray, "logical", bool)
-                          else if BSXINIT(int8NDArray, "int8", int8)
-                          else if BSXINIT(int16NDArray, "int16", int16)
-                          else if BSXINIT(int32NDArray, "int32", int32)
-                          else if BSXINIT(int64NDArray, "int64", int64)
-                          else if BSXINIT(uint8NDArray, "uint8", uint8)
-                          else if BSXINIT(uint16NDArray, "uint16", uint16)
-                          else if BSXINIT(uint32NDArray, "uint32", uint32)
-                          else if BSXINIT(uint64NDArray, "uint64", uint64)
+                        }
+                      else if (result_type == "single")
+                        {
+                          if (tmp(0).is_real_type ())
+                            {
+                              have_FloatNDArray = true;
+                              result_FloatNDArray
+                                = tmp(0).float_array_value ();
+                              result_FloatNDArray.resize (dvc);
+                            }
                           else
                             {
-                              C = tmp (0);
-                              C = C.resize (dvc);
+                              have_ComplexNDArray = true;
+                              result_ComplexNDArray =
+                                tmp(0).complex_array_value ();
+                              result_ComplexNDArray.resize (dvc);
+                            }
+                        }
+                      else if BSXINIT(boolNDArray, "logical", bool)
+                        else if BSXINIT(int8NDArray, "int8", int8)
+                          else if BSXINIT(int16NDArray, "int16", int16)
+                            else if BSXINIT(int32NDArray, "int32", int32)
+                              else if BSXINIT(int64NDArray, "int64", int64)
+                                else if BSXINIT(uint8NDArray, "uint8", uint8)
+                                  else if BSXINIT(uint16NDArray, "uint16", uint16)
+                                    else if BSXINIT(uint32NDArray, "uint32", uint32)
+                                      else if BSXINIT(uint64NDArray, "uint64", uint64)
+                                        else
+                                          {
+                                            C = tmp (0);
+                                            C = C.resize (dvc);
+                                          }
+                    }
+                }
+              else
+                {
+                  update_index (ra_idx, dvc, i);
+
+                  if (have_FloatNDArray
+                      || have_FloatComplexNDArray)
+                    {
+                      if (! tmp(0).is_float_type ())
+                        {
+                          if (have_FloatNDArray)
+                            {
+                              have_FloatNDArray = false;
+                              C = result_FloatNDArray;
                             }
+                          else
+                            {
+                              have_FloatComplexNDArray = false;
+                              C = result_FloatComplexNDArray;
+                            }
+                          C = do_cat_op (C, tmp(0), ra_idx);
+                        }
+                      else if (tmp(0).is_double_type ())
+                        {
+                          if (tmp(0).is_complex_type ()
+                              && have_FloatNDArray)
+                            {
+                              result_ComplexNDArray =
+                                ComplexNDArray (result_FloatNDArray);
+                              result_ComplexNDArray.insert
+                                (tmp(0).complex_array_value (), ra_idx);
+                              have_FloatComplexNDArray = false;
+                              have_ComplexNDArray = true;
+                            }
+                          else
+                            {
+                              result_NDArray =
+                                NDArray (result_FloatNDArray);
+                              result_NDArray.insert
+                                (tmp(0).array_value (), ra_idx);
+                              have_FloatNDArray = false;
+                              have_NDArray = true;
+                            }
+                        }
+                      else if (tmp(0).is_real_type ())
+                        result_FloatNDArray.insert
+                          (tmp(0).float_array_value (), ra_idx);
+                      else
+                        {
+                          result_FloatComplexNDArray =
+                            FloatComplexNDArray (result_FloatNDArray);
+                          result_FloatComplexNDArray.insert
+                            (tmp(0).float_complex_array_value (),
+                             ra_idx);
+                          have_FloatNDArray = false;
+                          have_FloatComplexNDArray = true;
                         }
                     }
-                  else
+                  else if (have_NDArray)
                     {
-                      update_index (ra_idx, dvc, i);
-
-                      if (have_FloatNDArray
-                          || have_FloatComplexNDArray)
+                      if (! tmp(0).is_float_type ())
                         {
-                          if (! tmp(0).is_float_type ())
-                            {
-                              if (have_FloatNDArray)
-                                {
-                                  have_FloatNDArray = false;
-                                  C = result_FloatNDArray;
-                                }
-                              else
-                                {
-                                  have_FloatComplexNDArray = false;
-                                  C = result_FloatComplexNDArray;
-                                }
-                              C = do_cat_op (C, tmp(0), ra_idx);
-                            }
-                          else if (tmp(0).is_double_type ())
-                            {
-                              if (tmp(0).is_complex_type ()
-                                  && have_FloatNDArray)
-                                {
-                                  result_ComplexNDArray =
-                                    ComplexNDArray (result_FloatNDArray);
-                                  result_ComplexNDArray.insert
-                                    (tmp(0).complex_array_value (), ra_idx);
-                                  have_FloatComplexNDArray = false;
-                                  have_ComplexNDArray = true;
-                                }
-                              else
-                                {
-                                  result_NDArray =
-                                    NDArray (result_FloatNDArray);
-                                  result_NDArray.insert
-                                    (tmp(0).array_value (), ra_idx);
-                                  have_FloatNDArray = false;
-                                  have_NDArray = true;
-                                }
-                            }
-                          else if (tmp(0).is_real_type ())
-                            result_FloatNDArray.insert
-                              (tmp(0).float_array_value (), ra_idx);
-                          else
-                            {
-                              result_FloatComplexNDArray =
-                                FloatComplexNDArray (result_FloatNDArray);
-                              result_FloatComplexNDArray.insert
-                                (tmp(0).float_complex_array_value (),
-                                 ra_idx);
-                              have_FloatNDArray = false;
-                              have_FloatComplexNDArray = true;
-                            }
+                          have_NDArray = false;
+                          C = result_NDArray;
+                          C = do_cat_op (C, tmp(0), ra_idx);
                         }
-                      else if (have_NDArray)
+                      else if (tmp(0).is_real_type ())
+                        result_NDArray.insert (tmp(0).array_value (),
+                                               ra_idx);
+                      else
                         {
-                          if (! tmp(0).is_float_type ())
-                            {
-                              have_NDArray = false;
-                              C = result_NDArray;
-                              C = do_cat_op (C, tmp(0), ra_idx);
-                            }
-                          else if (tmp(0).is_real_type ())
-                            result_NDArray.insert (tmp(0).array_value (),
-                                                   ra_idx);
-                          else
-                            {
-                              result_ComplexNDArray =
-                                ComplexNDArray (result_NDArray);
-                              result_ComplexNDArray.insert
-                                (tmp(0).complex_array_value (), ra_idx);
-                              have_NDArray = false;
-                              have_ComplexNDArray = true;
-                            }
+                          result_ComplexNDArray =
+                            ComplexNDArray (result_NDArray);
+                          result_ComplexNDArray.insert
+                            (tmp(0).complex_array_value (), ra_idx);
+                          have_NDArray = false;
+                          have_ComplexNDArray = true;
                         }
+                    }
 
 #define BSXLOOP(T, CLS, EXTRACTOR) \
   (have_ ## T) \
     { \
       if (tmp (0).class_name () != CLS) \
         { \
           have_ ## T = false; \
           C = result_ ## T; \
           C = do_cat_op (C, tmp (0), ra_idx); \
         } \
       else \
         result_ ## T .insert (tmp(0). EXTRACTOR ## _array_value (), ra_idx); \
     }
 
-                      else if BSXLOOP(ComplexNDArray, "double", complex)
-                      else if BSXLOOP(boolNDArray, "logical", bool)
-                      else if BSXLOOP(int8NDArray, "int8", int8)
-                      else if BSXLOOP(int16NDArray, "int16", int16)
-                      else if BSXLOOP(int32NDArray, "int32", int32)
-                      else if BSXLOOP(int64NDArray, "int64", int64)
-                      else if BSXLOOP(uint8NDArray, "uint8", uint8)
-                      else if BSXLOOP(uint16NDArray, "uint16", uint16)
-                      else if BSXLOOP(uint32NDArray, "uint32", uint32)
-                      else if BSXLOOP(uint64NDArray, "uint64", uint64)
-                      else
-                        C = do_cat_op (C, tmp(0), ra_idx);
-                    }
+                  else if BSXLOOP(ComplexNDArray, "double", complex)
+                  else if BSXLOOP(boolNDArray, "logical", bool)
+                  else if BSXLOOP(int8NDArray, "int8", int8)
+                  else if BSXLOOP(int16NDArray, "int16", int16)
+                  else if BSXLOOP(int32NDArray, "int32", int32)
+                  else if BSXLOOP(int64NDArray, "int64", int64)
+                  else if BSXLOOP(uint8NDArray, "uint8", uint8)
+                  else if BSXLOOP(uint16NDArray, "uint16", uint16)
+                  else if BSXLOOP(uint32NDArray, "uint32", uint32)
+                  else if BSXLOOP(uint64NDArray, "uint64", uint64)
+                  else
+                    C = do_cat_op (C, tmp(0), ra_idx);
                 }
+            }
 
 #define BSXEND(T) \
   (have_ ## T) \
     retval(0) = result_ ## T;
 
-              if BSXEND(NDArray)
-              else if BSXEND(ComplexNDArray)
-              else if BSXEND(FloatNDArray)
-              else if BSXEND(FloatComplexNDArray)
-              else if BSXEND(boolNDArray)
-              else if BSXEND(int8NDArray)
-              else if BSXEND(int16NDArray)
-              else if BSXEND(int32NDArray)
-              else if BSXEND(int64NDArray)
-              else if BSXEND(uint8NDArray)
-              else if BSXEND(uint16NDArray)
-              else if BSXEND(uint32NDArray)
-              else if BSXEND(uint64NDArray)
-              else
-                retval(0) = C;
-            }
+          if BSXEND(NDArray)
+          else if BSXEND(ComplexNDArray)
+          else if BSXEND(FloatNDArray)
+          else if BSXEND(FloatComplexNDArray)
+          else if BSXEND(boolNDArray)
+          else if BSXEND(int8NDArray)
+          else if BSXEND(int16NDArray)
+          else if BSXEND(int32NDArray)
+          else if BSXEND(int64NDArray)
+          else if BSXEND(uint8NDArray)
+          else if BSXEND(uint16NDArray)
+          else if BSXEND(uint32NDArray)
+          else if BSXEND(uint64NDArray)
+          else
+            retval(0) = C;
         }
     }
 
   return retval;
 }
 
 /*
 
diff --git a/libinterp/corefcn/colloc.cc b/libinterp/corefcn/colloc.cc
--- a/libinterp/corefcn/colloc.cc
+++ b/libinterp/corefcn/colloc.cc
@@ -43,41 +43,29 @@ Reference: @nospell{J. Villadsen}, @nosp
 @cite{Solution of Differential Equation Models by Polynomial Approximation}.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   if (! args(0).is_scalar_type ())
-    {
-      error ("colloc: N must be a scalar");
-      return retval;
-    }
+    error ("colloc: N must be a scalar");
 
   double tmp = args(0).double_value ();
 
   if (xisnan (tmp))
-    {
-      error ("colloc: N cannot be NaN");
-      return retval;
-    }
+    error ("colloc: N cannot be NaN");
 
   octave_idx_type ncol = NINTbig (tmp);
   if (ncol < 0)
-    {
-      error ("colloc: N must be positive");
-      return retval;
-    }
+    error ("colloc: N must be positive");
 
   octave_idx_type ntot = ncol;
   octave_idx_type left = 0;
   octave_idx_type right = 0;
 
   for (int i = 1; i < nargin; i++)
     {
       std::string s = args(i).xstring_value ("colloc: optional arguments must be strings");
diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -287,182 +287,180 @@ parameters for @code{daspk}.\n\
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     DASPK_ABORT1 ("invalid recursive call");
 
   int nargin = args.length ();
 
-  if (nargin > 3 && nargin < 6)
+  if (nargin < 4 || nargin > 5)
+    print_usage ();
+
+  std::string fcn_name, fname, jac_name, jname;
+  daspk_fcn = 0;
+  daspk_jac = 0;
+
+  octave_value f_arg = args(0);
+
+  if (f_arg.is_cell ())
     {
-      std::string fcn_name, fname, jac_name, jname;
-      daspk_fcn = 0;
-      daspk_jac = 0;
-
-      octave_value f_arg = args(0);
+      Cell c = f_arg.cell_value ();
+      if (c.numel () == 1)
+        f_arg = c(0);
+      else if (c.numel () == 2)
+        {
+          if (c(0).is_function_handle () || c(0).is_inline_function ())
+            daspk_fcn = c(0).function_value ();
+          else
+            {
+              fcn_name = unique_symbol_name ("__daspk_fcn__");
+              fname = "function y = ";
+              fname.append (fcn_name);
+              fname.append (" (x, xdot, t) y = ");
+              daspk_fcn = extract_function
+                (c(0), "daspk", fcn_name, fname, "; endfunction");
+            }
 
-      if (f_arg.is_cell ())
+          if (daspk_fcn)
+            {
+              if (c(1).is_function_handle () || c(1).is_inline_function ())
+                daspk_jac = c(1).function_value ();
+              else
+                {
+                  jac_name = unique_symbol_name ("__daspk_jac__");
+                  jname = "function jac = ";
+                  jname.append (jac_name);
+                  jname.append (" (x, xdot, t, cj) jac = ");
+                  daspk_jac = extract_function (c(1), "daspk", jac_name,
+                                                jname, "; endfunction");
+
+                  if (!daspk_jac)
+                    {
+                      if (fcn_name.length ())
+                        clear_function (fcn_name);
+                      daspk_fcn = 0;
+                    }
+                }
+            }
+        }
+      else
+        DASPK_ABORT1 ("incorrect number of elements in cell array");
+    }
+
+  if (!daspk_fcn && ! f_arg.is_cell ())
+    {
+      if (f_arg.is_function_handle () || f_arg.is_inline_function ())
+        daspk_fcn = f_arg.function_value ();
+      else
         {
-          Cell c = f_arg.cell_value ();
-          if (c.numel () == 1)
-            f_arg = c(0);
-          else if (c.numel () == 2)
+          switch (f_arg.rows ())
             {
-              if (c(0).is_function_handle () || c(0).is_inline_function ())
-                daspk_fcn = c(0).function_value ();
-              else
+            case 1:
+              do
                 {
                   fcn_name = unique_symbol_name ("__daspk_fcn__");
                   fname = "function y = ";
                   fname.append (fcn_name);
                   fname.append (" (x, xdot, t) y = ");
-                  daspk_fcn = extract_function
-                              (c(0), "daspk", fcn_name, fname, "; endfunction");
+                  daspk_fcn = extract_function (f_arg, "daspk", fcn_name,
+                                                fname, "; endfunction");
                 }
+              while (0);
+              break;
 
-              if (daspk_fcn)
-                {
-                  if (c(1).is_function_handle () || c(1).is_inline_function ())
-                    daspk_jac = c(1).function_value ();
-                  else
-                    {
-                      jac_name = unique_symbol_name ("__daspk_jac__");
-                      jname = "function jac = ";
-                      jname.append (jac_name);
-                      jname.append (" (x, xdot, t, cj) jac = ");
-                      daspk_jac = extract_function (c(1), "daspk", jac_name,
-                                                    jname, "; endfunction");
-
-                      if (!daspk_jac)
-                        {
-                          if (fcn_name.length ())
-                            clear_function (fcn_name);
-                          daspk_fcn = 0;
-                        }
-                    }
-                }
-            }
-          else
-            DASPK_ABORT1 ("incorrect number of elements in cell array");
-        }
+            case 2:
+              {
+                string_vector tmp = f_arg.all_strings ();
 
-      if (!daspk_fcn && ! f_arg.is_cell ())
-        {
-          if (f_arg.is_function_handle () || f_arg.is_inline_function ())
-            daspk_fcn = f_arg.function_value ();
-          else
-            {
-              switch (f_arg.rows ())
-                {
-                case 1:
-                  do
-                    {
-                      fcn_name = unique_symbol_name ("__daspk_fcn__");
-                      fname = "function y = ";
-                      fname.append (fcn_name);
-                      fname.append (" (x, xdot, t) y = ");
-                      daspk_fcn = extract_function (f_arg, "daspk", fcn_name,
-                                                    fname, "; endfunction");
-                    }
-                  while (0);
-                  break;
+                fcn_name = unique_symbol_name ("__daspk_fcn__");
+                fname = "function y = ";
+                fname.append (fcn_name);
+                fname.append (" (x, xdot, t) y = ");
+                daspk_fcn = extract_function (tmp(0), "daspk", fcn_name,
+                                              fname, "; endfunction");
 
-                case 2:
+                if (daspk_fcn)
                   {
-                    string_vector tmp = f_arg.all_strings ();
+                    jac_name = unique_symbol_name ("__daspk_jac__");
+                    jname = "function jac = ";
+                    jname.append (jac_name);
+                    jname.append (" (x, xdot, t, cj) jac = ");
+                    daspk_jac = extract_function (tmp(1), "daspk",
+                                                  jac_name, jname,
+                                                  "; endfunction");
 
-                    fcn_name = unique_symbol_name ("__daspk_fcn__");
-                    fname = "function y = ";
-                    fname.append (fcn_name);
-                    fname.append (" (x, xdot, t) y = ");
-                    daspk_fcn = extract_function (tmp(0), "daspk", fcn_name,
-                                                  fname, "; endfunction");
-
-                    if (daspk_fcn)
+                    if (!daspk_jac)
                       {
-                        jac_name = unique_symbol_name ("__daspk_jac__");
-                        jname = "function jac = ";
-                        jname.append (jac_name);
-                        jname.append (" (x, xdot, t, cj) jac = ");
-                        daspk_jac = extract_function (tmp(1), "daspk",
-                                                      jac_name, jname,
-                                                      "; endfunction");
-
-                        if (!daspk_jac)
-                          {
-                            if (fcn_name.length ())
-                              clear_function (fcn_name);
-                            daspk_fcn = 0;
-                          }
+                        if (fcn_name.length ())
+                          clear_function (fcn_name);
+                        daspk_fcn = 0;
                       }
                   }
-                }
+              }
             }
         }
+    }
 
-      if (! daspk_fcn)
-        DASPK_ABORT ();
+  if (! daspk_fcn)
+    DASPK_ABORT ();
 
-      ColumnVector state = args(1).xvector_value ("daspk: initial state X_0 must be a vector");
+  ColumnVector state = args(1).xvector_value ("daspk: initial state X_0 must be a vector");
 
-      ColumnVector deriv = args(2).xvector_value ("daspk: initial derivatives XDOT_0 must be a vector");
+  ColumnVector deriv = args(2).xvector_value ("daspk: initial derivatives XDOT_0 must be a vector");
 
-      ColumnVector out_times = args(3).xvector_value ("daspk: output time variable T must be a vector");
+  ColumnVector out_times = args(3).xvector_value ("daspk: output time variable T must be a vector");
 
-      ColumnVector crit_times;
-      int crit_times_set = 0;
-      if (nargin > 4)
-        {
-          crit_times = args(4).xvector_value ("daspk: list of critical times T_CRIT must be a vector");
-
-          crit_times_set = 1;
-        }
+  ColumnVector crit_times;
+  int crit_times_set = 0;
+  if (nargin > 4)
+    {
+      crit_times = args(4).xvector_value ("daspk: list of critical times T_CRIT must be a vector");
 
-      if (state.numel () != deriv.numel ())
-        DASPK_ABORT1 ("X_0 and XDOT_0 must have the same size");
-
-      double tzero = out_times (0);
+      crit_times_set = 1;
+    }
 
-      DAEFunc func (daspk_user_function);
-      if (daspk_jac)
-        func.set_jacobian_function (daspk_user_jacobian);
+  if (state.numel () != deriv.numel ())
+    DASPK_ABORT1 ("X_0 and XDOT_0 must have the same size");
 
-      DASPK dae (state, deriv, tzero, func);
-      dae.set_options (daspk_opts);
+  double tzero = out_times (0);
 
-      Matrix output;
-      Matrix deriv_output;
+  DAEFunc func (daspk_user_function);
+  if (daspk_jac)
+    func.set_jacobian_function (daspk_user_jacobian);
+
+  DASPK dae (state, deriv, tzero, func);
+  dae.set_options (daspk_opts);
 
-      if (crit_times_set)
-        output = dae.integrate (out_times, deriv_output, crit_times);
-      else
-        output = dae.integrate (out_times, deriv_output);
+  Matrix output;
+  Matrix deriv_output;
 
-      if (fcn_name.length ())
-        clear_function (fcn_name);
-      if (jac_name.length ())
-        clear_function (jac_name);
-
-      std::string msg = dae.error_message ();
+  if (crit_times_set)
+    output = dae.integrate (out_times, deriv_output, crit_times);
+  else
+    output = dae.integrate (out_times, deriv_output);
 
-      retval(3) = msg;
-      retval(2) = static_cast<double> (dae.integration_state ());
+  if (fcn_name.length ())
+    clear_function (fcn_name);
+  if (jac_name.length ())
+    clear_function (jac_name);
+
+  std::string msg = dae.error_message ();
 
-      if (dae.integration_ok ())
-        {
-          retval(1) = deriv_output;
-          retval(0) = output;
-        }
-      else
-        {
-          retval(1) = Matrix ();
-          retval(0) = Matrix ();
+  retval(3) = msg;
+  retval(2) = static_cast<double> (dae.integration_state ());
 
-          if (nargout < 3)
-            error ("daspk: %s", msg.c_str ());
-        }
+  if (dae.integration_ok ())
+    {
+      retval(1) = deriv_output;
+      retval(0) = output;
     }
   else
-    print_usage ();
+    {
+      retval(1) = Matrix ();
+      retval(0) = Matrix ();
+
+      if (nargout < 3)
+        error ("daspk: %s", msg.c_str ());
+    }
 
   return retval;
 }
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -370,20 +370,17 @@ parameters for @code{dasrt}.\n\
   if (call_depth > 1)
     DASRT_ABORT1 ("invalid recursive call");
 
   int argp = 0;
 
   int nargin = args.length ();
 
   if (nargin < 4 || nargin > 6)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   std::string fcn_name, fname, jac_name, jname;
   dasrt_f = 0;
   dasrt_j = 0;
   dasrt_cf = 0;
 
   // Check all the arguments.  Are they the right animals?
 
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -288,188 +288,186 @@ parameters for @code{dassl}.\n\
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     DASSL_ABORT1 ("invalid recursive call");
 
   int nargin = args.length ();
 
-  if (nargin > 3 && nargin < 6 && nargout < 5)
+  if (nargin < 4 || nargin > 5 || nargout > 4)
+    print_usage ();
+
+  std::string fcn_name, fname, jac_name, jname;
+  dassl_fcn = 0;
+  dassl_jac = 0;
+
+  octave_value f_arg = args(0);
+
+  if (f_arg.is_cell ())
     {
-      std::string fcn_name, fname, jac_name, jname;
-      dassl_fcn = 0;
-      dassl_jac = 0;
-
-      octave_value f_arg = args(0);
+      Cell c = f_arg.cell_value ();
+      if (c.numel () == 1)
+        f_arg = c(0);
+      else if (c.numel () == 2)
+        {
+          if (c(0).is_function_handle () || c(0).is_inline_function ())
+            dassl_fcn = c(0).function_value ();
+          else
+            {
+              fcn_name = unique_symbol_name ("__dassl_fcn__");
+              fname = "function y = ";
+              fname.append (fcn_name);
+              fname.append (" (x, xdot, t) y = ");
+              dassl_fcn = extract_function (c(0), "dassl", fcn_name, fname,
+                                            "; endfunction");
+            }
 
-      if (f_arg.is_cell ())
+          if (dassl_fcn)
+            {
+              if (c(1).is_function_handle () || c(1).is_inline_function ())
+                dassl_jac = c(1).function_value ();
+              else
+                {
+                  jac_name = unique_symbol_name ("__dassl_jac__");
+                  jname = "function jac = ";
+                  jname.append (jac_name);
+                  jname.append (" (x, xdot, t, cj) jac = ");
+                  dassl_jac = extract_function (c(1), "dassl", jac_name,
+                                                jname, "; endfunction");
+
+                  if (!dassl_jac)
+                    {
+                      if (fcn_name.length ())
+                        clear_function (fcn_name);
+                      dassl_fcn = 0;
+                    }
+                }
+            }
+        }
+      else
+        DASSL_ABORT1 ("incorrect number of elements in cell array");
+    }
+
+  if (!dassl_fcn && ! f_arg.is_cell ())
+    {
+      if (f_arg.is_function_handle () || f_arg.is_inline_function ())
+        dassl_fcn = f_arg.function_value ();
+      else
         {
-          Cell c = f_arg.cell_value ();
-          if (c.numel () == 1)
-            f_arg = c(0);
-          else if (c.numel () == 2)
+          switch (f_arg.rows ())
             {
-              if (c(0).is_function_handle () || c(0).is_inline_function ())
-                dassl_fcn = c(0).function_value ();
-              else
+            case 1:
+              do
                 {
                   fcn_name = unique_symbol_name ("__dassl_fcn__");
                   fname = "function y = ";
                   fname.append (fcn_name);
                   fname.append (" (x, xdot, t) y = ");
-                  dassl_fcn = extract_function (c(0), "dassl", fcn_name, fname,
-                                                "; endfunction");
+                  dassl_fcn = extract_function (f_arg, "dassl", fcn_name,
+                                                fname, "; endfunction");
                 }
+              while (0);
+              break;
 
-              if (dassl_fcn)
-                {
-                  if (c(1).is_function_handle () || c(1).is_inline_function ())
-                    dassl_jac = c(1).function_value ();
-                  else
-                    {
-                      jac_name = unique_symbol_name ("__dassl_jac__");
-                      jname = "function jac = ";
-                      jname.append (jac_name);
-                      jname.append (" (x, xdot, t, cj) jac = ");
-                      dassl_jac = extract_function (c(1), "dassl", jac_name,
-                                                    jname, "; endfunction");
-
-                      if (!dassl_jac)
-                        {
-                          if (fcn_name.length ())
-                            clear_function (fcn_name);
-                          dassl_fcn = 0;
-                        }
-                    }
-                }
-            }
-          else
-            DASSL_ABORT1 ("incorrect number of elements in cell array");
-        }
+            case 2:
+              {
+                string_vector tmp = f_arg.all_strings ();
 
-      if (!dassl_fcn && ! f_arg.is_cell ())
-        {
-          if (f_arg.is_function_handle () || f_arg.is_inline_function ())
-            dassl_fcn = f_arg.function_value ();
-          else
-            {
-              switch (f_arg.rows ())
-                {
-                case 1:
-                  do
-                    {
-                      fcn_name = unique_symbol_name ("__dassl_fcn__");
-                      fname = "function y = ";
-                      fname.append (fcn_name);
-                      fname.append (" (x, xdot, t) y = ");
-                      dassl_fcn = extract_function (f_arg, "dassl", fcn_name,
-                                                    fname, "; endfunction");
-                    }
-                  while (0);
-                  break;
+                fcn_name = unique_symbol_name ("__dassl_fcn__");
+                fname = "function y = ";
+                fname.append (fcn_name);
+                fname.append (" (x, xdot, t) y = ");
+                dassl_fcn = extract_function (tmp(0), "dassl", fcn_name,
+                                              fname, "; endfunction");
 
-                case 2:
+                if (dassl_fcn)
                   {
-                    string_vector tmp = f_arg.all_strings ();
+                    jac_name = unique_symbol_name ("__dassl_jac__");
+                    jname = "function jac = ";
+                    jname.append (jac_name);
+                    jname.append (" (x, xdot, t, cj) jac = ");
+                    dassl_jac = extract_function (tmp(1), "dassl",
+                                                  jac_name, jname,
+                                                  "; endfunction");
 
-                    fcn_name = unique_symbol_name ("__dassl_fcn__");
-                    fname = "function y = ";
-                    fname.append (fcn_name);
-                    fname.append (" (x, xdot, t) y = ");
-                    dassl_fcn = extract_function (tmp(0), "dassl", fcn_name,
-                                                  fname, "; endfunction");
-
-                    if (dassl_fcn)
+                    if (!dassl_jac)
                       {
-                        jac_name = unique_symbol_name ("__dassl_jac__");
-                        jname = "function jac = ";
-                        jname.append (jac_name);
-                        jname.append (" (x, xdot, t, cj) jac = ");
-                        dassl_jac = extract_function (tmp(1), "dassl",
-                                                      jac_name, jname,
-                                                      "; endfunction");
-
-                        if (!dassl_jac)
-                          {
-                            if (fcn_name.length ())
-                              clear_function (fcn_name);
-                            dassl_fcn = 0;
-                          }
+                        if (fcn_name.length ())
+                          clear_function (fcn_name);
+                        dassl_fcn = 0;
                       }
                   }
-                }
+              }
             }
         }
-
-      if (! dassl_fcn)
-        DASSL_ABORT ();
+    }
 
-      ColumnVector state = args(1).xvector_value ("dassl: initial state X_0 must be a vector");
-
-      ColumnVector deriv = args(2).xvector_value ("dassl: initial derivatives XDOT_0 must be a vector");
+  if (! dassl_fcn)
+    DASSL_ABORT ();
 
-      ColumnVector out_times = args(3).xvector_value ("dassl: output time variable T must be a vector");
+  ColumnVector state = args(1).xvector_value ("dassl: initial state X_0 must be a vector");
 
-      ColumnVector crit_times;
-      int crit_times_set = 0;
-      if (nargin > 4)
-        {
-          crit_times = args(4).xvector_value ("dassl: list of critical times T_CRIT must be a vector");
+  ColumnVector deriv = args(2).xvector_value ("dassl: initial derivatives XDOT_0 must be a vector");
+
+  ColumnVector out_times = args(3).xvector_value ("dassl: output time variable T must be a vector");
 
-          crit_times_set = 1;
-        }
-
-      if (state.numel () != deriv.numel ())
-        DASSL_ABORT1 ("X and XDOT_0 must have the same size");
-
-      double tzero = out_times (0);
+  ColumnVector crit_times;
+  int crit_times_set = 0;
+  if (nargin > 4)
+    {
+      crit_times = args(4).xvector_value ("dassl: list of critical times T_CRIT must be a vector");
 
-      DAEFunc func (dassl_user_function);
-      if (dassl_jac)
-        func.set_jacobian_function (dassl_user_jacobian);
+      crit_times_set = 1;
+    }
 
-      DASSL dae (state, deriv, tzero, func);
+  if (state.numel () != deriv.numel ())
+    DASSL_ABORT1 ("X and XDOT_0 must have the same size");
 
-      dae.set_options (dassl_opts);
+  double tzero = out_times (0);
 
-      Matrix output;
-      Matrix deriv_output;
+  DAEFunc func (dassl_user_function);
+  if (dassl_jac)
+    func.set_jacobian_function (dassl_user_jacobian);
 
-      if (crit_times_set)
-        output = dae.integrate (out_times, deriv_output, crit_times);
-      else
-        output = dae.integrate (out_times, deriv_output);
+  DASSL dae (state, deriv, tzero, func);
 
-      if (fcn_name.length ())
-        clear_function (fcn_name);
-      if (jac_name.length ())
-        clear_function (jac_name);
+  dae.set_options (dassl_opts);
 
-      std::string msg = dae.error_message ();
+  Matrix output;
+  Matrix deriv_output;
 
-      retval(3) = msg;
-      retval(2) = static_cast<double> (dae.integration_state ());
+  if (crit_times_set)
+    output = dae.integrate (out_times, deriv_output, crit_times);
+  else
+    output = dae.integrate (out_times, deriv_output);
+
+  if (fcn_name.length ())
+    clear_function (fcn_name);
+  if (jac_name.length ())
+    clear_function (jac_name);
 
-      if (dae.integration_ok ())
-        {
-          retval(1) = deriv_output;
-          retval(0) = output;
-        }
-      else
-        {
-          retval(1) = Matrix ();
-          retval(0) = Matrix ();
+  std::string msg = dae.error_message ();
+
+  retval(3) = msg;
+  retval(2) = static_cast<double> (dae.integration_state ());
 
-          if (nargout < 3)
-            error ("dassl: %s", msg.c_str ());
-        }
+  if (dae.integration_ok ())
+    {
+      retval(1) = deriv_output;
+      retval(0) = output;
     }
   else
-    print_usage ();
+    {
+      retval(1) = Matrix ();
+      retval(0) = Matrix ();
+
+      if (nargout < 3)
+        error ("dassl: %s", msg.c_str ());
+    }
 
   return retval;
 }
 
 /*
 ## dassl-1.m
 ##
 ## Test dassl() function
diff --git a/libinterp/corefcn/defaults.cc b/libinterp/corefcn/defaults.cc
--- a/libinterp/corefcn/defaults.cc
+++ b/libinterp/corefcn/defaults.cc
@@ -579,46 +579,36 @@ The original variable value is restored 
 
 DEFUN (OCTAVE_HOME, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} OCTAVE_HOME ()\n\
 Return the name of the top-level Octave installation directory.\n\
 @seealso{EXEC_PATH, IMAGE_PATH}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 0)
-    retval = Voctave_home;
-  else
+  if (args.length () != 0)
     print_usage ();
 
-  return retval;
+  return octave_value (Voctave_home);
 }
 
 /*
 %!assert (ischar (OCTAVE_HOME ()))
 %!error OCTAVE_HOME (1)
 */
 
 DEFUNX ("OCTAVE_VERSION", FOCTAVE_VERSION, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} OCTAVE_VERSION ()\n\
 Return the version number of Octave as a string.\n\
 @seealso{ver, version}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  int nargin = args.length ();
-
-  if (nargin == 0)
-    retval = OCTAVE_VERSION;
-  else
+  if (args.length () != 0)
     print_usage ();
 
-  return retval;
+  return octave_value (OCTAVE_VERSION);
 }
 
 /*
 %!assert (ischar (OCTAVE_VERSION ()))
 %!error OCTAVE_VERSION (1)
 */
diff --git a/libinterp/corefcn/det.cc b/libinterp/corefcn/det.cc
--- a/libinterp/corefcn/det.cc
+++ b/libinterp/corefcn/det.cc
@@ -64,20 +64,17 @@ For that, use any of the condition numbe
 @seealso{cond, condest, rcond}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (nr == 0 && nc == 0)
     {
diff --git a/libinterp/corefcn/dlmread.cc b/libinterp/corefcn/dlmread.cc
--- a/libinterp/corefcn/dlmread.cc
+++ b/libinterp/corefcn/dlmread.cc
@@ -198,20 +198,17 @@ fill empty fields.  The default is zero.
       && args(nargin-2).string_value () == "emptyvalue")
     {
       empty_value = args(nargin-1).double_value ();
 
       nargin -= 2;
     }
 
   if (nargin < 1 || nargin > 4)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   std::istream *input = 0;
   std::ifstream input_file;
 
   if (args(0).is_string ())
     {
       // Filename.
       std::string fname (args(0).string_value ());
diff --git a/libinterp/corefcn/dot.cc b/libinterp/corefcn/dot.cc
--- a/libinterp/corefcn/dot.cc
+++ b/libinterp/corefcn/dot.cc
@@ -121,20 +121,17 @@ but avoids forming a temporary array and
 @code{@var{X}' * @var{Y}}.\n\
 @seealso{cross, divergence}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value argx = args(0);
   octave_value argy = args(1);
 
   if (argx.is_numeric_type () && argy.is_numeric_type ())
     {
       dim_vector dimx = argx.dims ();
       dim_vector dimy = argy.dims ();
@@ -295,20 +292,17 @@ endfor\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
   if (nargin != 2)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value argx = args(0);
   octave_value argy = args(1);
 
   if (argx.is_numeric_type () && argy.is_numeric_type ())
     {
       const dim_vector dimx = argx.dims ();
       const dim_vector dimy = argy.dims ();
diff --git a/libinterp/corefcn/eig.cc b/libinterp/corefcn/eig.cc
--- a/libinterp/corefcn/eig.cc
+++ b/libinterp/corefcn/eig.cc
@@ -50,20 +50,17 @@ The eigenvalues returned by @code{eig} a
 @seealso{eigs, svd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 2 || nargin == 0 || nargout > 2)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value arg_a, arg_b;
 
   octave_idx_type nr_a, nr_b, nc_a, nc_b;
   nr_a = nr_b = nc_a = nc_b = 0;
 
   arg_a = args(0);
   nr_a = arg_a.rows ();
diff --git a/libinterp/corefcn/ellipj.cc b/libinterp/corefcn/ellipj.cc
--- a/libinterp/corefcn/ellipj.cc
+++ b/libinterp/corefcn/ellipj.cc
@@ -68,20 +68,17 @@ and 16.15), Dover, 1965.\n\
 @seealso{ellipke}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value u_arg = args(0);
   octave_value m_arg = args(1);
 
   if (m_arg.is_scalar_type ())
     {
       double m = args(1).xdouble_value ("ellipj: M must be a scalar or matrix");
 
diff --git a/libinterp/corefcn/fft.cc b/libinterp/corefcn/fft.cc
--- a/libinterp/corefcn/fft.cc
+++ b/libinterp/corefcn/fft.cc
@@ -42,20 +42,17 @@ along with Octave; see the file COPYING.
 static octave_value
 do_fft (const octave_value_list &args, const char *fcn, int type)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value arg = args(0);
   dim_vector dims = arg.dims ();
   octave_idx_type n_points = -1;
   int dim = -1;
 
   if (nargin > 1)
     {
diff --git a/libinterp/corefcn/fft2.cc b/libinterp/corefcn/fft2.cc
--- a/libinterp/corefcn/fft2.cc
+++ b/libinterp/corefcn/fft2.cc
@@ -44,20 +44,17 @@ along with Octave; see the file COPYING.
 static octave_value
 do_fft2 (const octave_value_list &args, const char *fcn, int type)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value arg = args(0);
   dim_vector dims = arg.dims ();
   octave_idx_type n_rows = -1;
 
   if (nargin > 1)
     {
       double dval = args(1).double_value ();
diff --git a/libinterp/corefcn/fftn.cc b/libinterp/corefcn/fftn.cc
--- a/libinterp/corefcn/fftn.cc
+++ b/libinterp/corefcn/fftn.cc
@@ -43,20 +43,17 @@ along with Octave; see the file COPYING.
 static octave_value
 do_fftn (const octave_value_list &args, const char *fcn, int type)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value arg = args(0);
   dim_vector dims = arg.dims ();
 
   for (int i = 0; i < dims.length (); i++)
     if (dims(i) < 0)
       return retval;
 
diff --git a/libinterp/corefcn/filter.cc b/libinterp/corefcn/filter.cc
--- a/libinterp/corefcn/filter.cc
+++ b/libinterp/corefcn/filter.cc
@@ -392,20 +392,17 @@ H(z) = ---------------------\n\
 @seealso{filter2, fftfilt, freqz}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin  = args.length ();
 
   if (nargin < 3 || nargin > 5)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   const char *a_b_errmsg = "filter: A and B must be vectors";
   const char *x_si_errmsg = "filter: X and SI must be arrays";
 
   int dim;
   dim_vector x_dims = args(2).dims ();
 
   if (nargin == 5)
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -383,20 +383,17 @@ b = sparse (i, j, v, sz(1), sz(2));\n\
 @seealso{nonzeros}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 3 || nargin < 1)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   // Setup the default options.
   octave_idx_type n_to_find = -1;
   if (nargin > 1)
     {
       double val = args(1).xscalar_value ("find: N must be an integer");
 
       if (val < 0 || (! xisinf (val) && val != xround (val)))
diff --git a/libinterp/corefcn/gcd.cc b/libinterp/corefcn/gcd.cc
--- a/libinterp/corefcn/gcd.cc
+++ b/libinterp/corefcn/gcd.cc
@@ -471,43 +471,41 @@ gcd ([15, 9], [20, 18])\n\
 \n\
 @seealso{lcm, factor, isprime}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
-  if (nargin > 1)
+  if (nargin < 2)
+    print_usage ();
+
+  if (nargout > 1)
     {
-      if (nargout > 1)
-        {
-          retval.resize (nargin + 1);
-
-          retval(0) = do_extended_gcd (args(0), args(1), retval(1), retval(2));
+      retval.resize (nargin + 1);
 
-          for (int j = 2; j < nargin; j++)
-            {
-              octave_value x;
-              retval(0) = do_extended_gcd (retval(0), args(j),
-                                           x, retval(j+1));
-              for (int i = 0; i < j; i++)
-                retval(i+1).assign (octave_value::op_el_mul_eq, x);
-            }
-        }
-      else
+      retval(0) = do_extended_gcd (args(0), args(1), retval(1), retval(2));
+
+      for (int j = 2; j < nargin; j++)
         {
-          retval(0) = do_simple_gcd (args(0), args(1));
-
-          for (int j = 2; j < nargin; j++)
-            retval(0) = do_simple_gcd (retval(0), args(j));
+          octave_value x;
+          retval(0) = do_extended_gcd (retval(0), args(j),
+                                       x, retval(j+1));
+          for (int i = 0; i < j; i++)
+            retval(i+1).assign (octave_value::op_el_mul_eq, x);
         }
     }
   else
-    print_usage ();
+    {
+      retval(0) = do_simple_gcd (args(0), args(1));
+
+      for (int j = 2; j < nargin; j++)
+        retval(0) = do_simple_gcd (retval(0), args(j));
+    }
 
   return retval;
 }
 
 /*
 %!assert (gcd (200, 300, 50, 35), 5)
 %!assert (gcd (int16 (200), int16 (300), int16 (50), int16 (35)), int16 (5))
 %!assert (gcd (uint64 (200), uint64 (300), uint64 (50), uint64 (35)), uint64 (5))
diff --git a/libinterp/corefcn/givens.cc b/libinterp/corefcn/givens.cc
--- a/libinterp/corefcn/givens.cc
+++ b/libinterp/corefcn/givens.cc
@@ -74,106 +74,101 @@ givens (1, 1)\n\
 @seealso{planerot}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 2 || nargout > 2)
+    print_usage ();
+
+  if (args(0).is_single_type () || args(1).is_single_type ())
     {
-      print_usage ();
-      return retval;
-    }
-  else
-    {
-      if (args(0).is_single_type () || args(1).is_single_type ())
+      if (args(0).is_complex_type () || args(1).is_complex_type ())
         {
-          if (args(0).is_complex_type () || args(1).is_complex_type ())
-            {
-              FloatComplex cx = args(0).float_complex_value ();
-              FloatComplex cy = args(1).float_complex_value ();
-
-              FloatComplexMatrix result = Givens (cx, cy);
+          FloatComplex cx = args(0).float_complex_value ();
+          FloatComplex cy = args(1).float_complex_value ();
 
-              switch (nargout)
-                {
-                case 0:
-                case 1:
-                  retval(0) = result;
-                  break;
+          FloatComplexMatrix result = Givens (cx, cy);
 
-                case 2:
-                  retval(1) = result (0, 1);
-                  retval(0) = result (0, 0);
-                  break;
-                }
-            }
-          else
+          switch (nargout)
             {
-              float x = args(0).float_value ();
-              float y = args(1).float_value ();
-
-              FloatMatrix result = Givens (x, y);
+            case 0:
+            case 1:
+              retval(0) = result;
+              break;
 
-              switch (nargout)
-                {
-                case 0:
-                case 1:
-                  retval(0) = result;
-                  break;
-
-                case 2:
-                  retval(1) = result (0, 1);
-                  retval(0) = result (0, 0);
-                  break;
-                }
+            case 2:
+              retval(1) = result (0, 1);
+              retval(0) = result (0, 0);
+              break;
             }
         }
       else
         {
-          if (args(0).is_complex_type () || args(1).is_complex_type ())
-            {
-              Complex cx = args(0).complex_value ();
-              Complex cy = args(1).complex_value ();
+          float x = args(0).float_value ();
+          float y = args(1).float_value ();
 
-              ComplexMatrix result = Givens (cx, cy);
+          FloatMatrix result = Givens (x, y);
 
-              switch (nargout)
-                {
-                case 0:
-                case 1:
-                  retval(0) = result;
-                  break;
+          switch (nargout)
+            {
+            case 0:
+            case 1:
+              retval(0) = result;
+              break;
 
-                case 2:
-                  retval(1) = result (0, 1);
-                  retval(0) = result (0, 0);
-                  break;
-                }
+            case 2:
+              retval(1) = result (0, 1);
+              retval(0) = result (0, 0);
+              break;
             }
-          else
+        }
+    }
+  else
+    {
+      if (args(0).is_complex_type () || args(1).is_complex_type ())
+        {
+          Complex cx = args(0).complex_value ();
+          Complex cy = args(1).complex_value ();
+
+          ComplexMatrix result = Givens (cx, cy);
+
+          switch (nargout)
             {
-              double x = args(0).double_value ();
-              double y = args(1).double_value ();
-
-              Matrix result = Givens (x, y);
+            case 0:
+            case 1:
+              retval(0) = result;
+              break;
 
-              switch (nargout)
-                {
-                case 0:
-                case 1:
-                  retval(0) = result;
-                  break;
+            case 2:
+              retval(1) = result (0, 1);
+              retval(0) = result (0, 0);
+              break;
+            }
+        }
+      else
+        {
+          double x = args(0).double_value ();
+          double y = args(1).double_value ();
 
-                case 2:
-                  retval(1) = result (0, 1);
-                  retval(0) = result (0, 0);
-                  break;
-                }
+          Matrix result = Givens (x, y);
+
+          switch (nargout)
+            {
+            case 0:
+            case 1:
+              retval(0) = result;
+              break;
+
+            case 2:
+              retval(1) = result (0, 1);
+              retval(0) = result (0, 0);
+              break;
             }
         }
     }
 
   return retval;
 }
 
 /*
diff --git a/libinterp/corefcn/hex2num.cc b/libinterp/corefcn/hex2num.cc
--- a/libinterp/corefcn/hex2num.cc
+++ b/libinterp/corefcn/hex2num.cc
@@ -65,17 +65,18 @@ hex2num ([\"402df854\"; \"41200000\"], \
 @seealso{num2hex, hex2dec, dec2hex}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
-  else if (nargin == 2 && ! args(1).is_string ())
+
+  if (nargin == 2 && ! args(1).is_string ())
     error ("hex2num: CLASS must be a string");
   else
     {
       const charMatrix cmat = args(0).char_matrix_value ();
       std::string prec = (nargin == 2) ? args(1).string_value () : "double";
       bool is_single = (prec == "single");
       octave_idx_type nchars = (is_single) ? 8 : 16;
 
@@ -218,17 +219,18 @@ num2hex (single ([-1, 1, e, Inf]))\n\
 @seealso{hex2num, hex2dec, dec2hex}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin != 1)
     print_usage ();
-  else if (args(0).is_single_type ())
+
+  if (args(0).is_single_type ())
     {
       const FloatColumnVector v (args(0).float_vector_value ());
 
       octave_idx_type nchars = 8;
       octave_idx_type nr = v.numel ();
       charMatrix m (nr, nchars);
       const float *pv = v.fortran_vec ();
 
diff --git a/libinterp/corefcn/inv.cc b/libinterp/corefcn/inv.cc
--- a/libinterp/corefcn/inv.cc
+++ b/libinterp/corefcn/inv.cc
@@ -58,20 +58,17 @@ sparse matrix if possible.\n\
 @seealso{ldivide, rdivide}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("inverse", nr, nc);
 
diff --git a/libinterp/corefcn/lookup.cc b/libinterp/corefcn/lookup.cc
--- a/libinterp/corefcn/lookup.cc
+++ b/libinterp/corefcn/lookup.cc
@@ -238,20 +238,17 @@ at most n-1).\n\
 @end table\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3 || (nargin == 3 && ! args(2).is_string ()))
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value table = args(0);
   octave_value y = args(1);
   if (table.ndims () > 2 || (table.columns () > 1 && table.rows () > 1))
     warning ("lookup: table is not a vector");
 
   bool num_case = ((table.is_numeric_type () && y.is_numeric_type ())
                    || (table.is_char_matrix () && y.is_char_matrix ()));
@@ -280,17 +277,16 @@ at most n-1).\n\
     error ("lookup: m, b cannot be specified with l or r");
   else if (match_idx && match_bool)
     error ("lookup: only one of m or b can be specified");
   else if (str_case && (left_inf || right_inf))
     error ("lookup: l, r are not recognized for string lookups");
 
   if (num_case)
     {
-
       // In the case of a complex array, absolute values will be used for
       // compatibility (though it's not too meaningful).
 
       if (table.is_complex_type ())
         table = table.abs ();
 
       if (y.is_complex_type ())
         y = y.abs ();
@@ -316,17 +312,16 @@ at most n-1).\n\
                                     y.float_array_value (),
                                     left_inf, right_inf,
                                     match_idx, match_bool);
       else
         retval = do_numeric_lookup (table.array_value (),
                                     y.array_value (),
                                     left_inf, right_inf,
                                     match_idx, match_bool);
-
     }
   else if (str_case)
     {
       Array<std::string> str_table = table.cellstr_value ();
       Array<std::string> str_y (dim_vector (1, 1));
 
       if (y.is_cellstr ())
         str_y = y.cellstr_value ();
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -144,20 +144,17 @@ information.\n\
 {
   octave_value_list retval;
   int nargin = args.length ();
   bool issparse = (nargin > 0 && args(0).is_sparse_type ());
   bool scale = (nargout  == 5);
 
   if (nargin < 1 || (issparse && (nargin > 3 || nargout > 5))
       || (!issparse && (nargin > 2 || nargout > 3)))
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   bool vecout = false;
   Matrix thres;
 
   int n = 1;
   while (n < nargin)
     {
       if (args(n).is_string ())
@@ -630,20 +627,17 @@ factorization from scratch.\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
   octave_value_list retval;
 
   bool pivoted = nargin == 5;
 
   if (nargin != 4 && nargin != 5)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value argl = args(0);
   octave_value argu = args(1);
   octave_value argp = pivoted ? args(2) : octave_value ();
   octave_value argx = args(2 + pivoted);
   octave_value argy = args(3 + pivoted);
 
   if (argl.is_numeric_type () && argu.is_numeric_type ()
diff --git a/libinterp/corefcn/max.cc b/libinterp/corefcn/max.cc
--- a/libinterp/corefcn/max.cc
+++ b/libinterp/corefcn/max.cc
@@ -228,16 +228,19 @@ do_minmax_body (const octave_value_list&
                 int nargout, bool ismin)
 {
   octave_value_list retval;
 
   const char *func = ismin ? "min" : "max";
 
   int nargin = args.length ();
 
+  if (nargin < 1 || nargin > 3)
+    print_usage ();
+  
   if (nargin == 3 || nargin == 1)
     {
       octave_value arg = args(0);
       int dim = -1;
       if (nargin == 3)
         {
           dim = args(2).int_value (true) - 1;
 
@@ -279,59 +282,69 @@ do_minmax_body (const octave_value_list&
                                   (range.inc () >= 0 ? range.numel () : 1);
                   }
               }
             else if (arg.is_sparse_type ())
               retval = do_minmax_red_op<SparseMatrix> (arg, nargout, dim,
                                                        ismin);
             else
               retval = do_minmax_red_op<NDArray> (arg, nargout, dim, ismin);
-            break;
+
           }
+          break;
+
         case btyp_complex:
           {
             if (arg.is_sparse_type ())
               retval = do_minmax_red_op<SparseComplexMatrix> (arg, nargout, dim,
                                                               ismin);
             else
               retval = do_minmax_red_op<ComplexNDArray> (arg, nargout, dim,
                                                          ismin);
-            break;
           }
+          break;
+
         case btyp_float:
           retval = do_minmax_red_op<FloatNDArray> (arg, nargout, dim, ismin);
           break;
+
         case btyp_float_complex:
           retval = do_minmax_red_op<FloatComplexNDArray> (arg, nargout, dim,
                                                           ismin);
           break;
+
         case btyp_char:
           retval = do_minmax_red_op<charNDArray> (arg, nargout, dim, ismin);
           break;
-#define MAKE_INT_BRANCH(X) \
+
+#define MAKE_INT_BRANCH(X)                      \
         case btyp_ ## X: \
           retval = do_minmax_red_op<X ## NDArray> (arg, nargout, dim, ismin); \
           break;
+
         MAKE_INT_BRANCH (int8);
         MAKE_INT_BRANCH (int16);
         MAKE_INT_BRANCH (int32);
         MAKE_INT_BRANCH (int64);
         MAKE_INT_BRANCH (uint8);
         MAKE_INT_BRANCH (uint16);
         MAKE_INT_BRANCH (uint32);
         MAKE_INT_BRANCH (uint64);
+
 #undef MAKE_INT_BRANCH
+
         case btyp_bool:
           retval = do_minmax_red_op<boolNDArray> (arg, nargout, dim, ismin);
           break;
+
         default:
           gripe_wrong_type_arg (func, arg);
         }
     }
-  else if (nargin == 2)
+  else
     {
       octave_value argx = args(0);
       octave_value argy = args(1);
       builtin_type_t xtyp = argx.builtin_type ();
       builtin_type_t ytyp = argy.builtin_type ();
       builtin_type_t rtyp;
       if (xtyp == btyp_char && ytyp == btyp_char)
         rtyp = btyp_char;
@@ -348,69 +361,75 @@ do_minmax_body (const octave_value_list&
         case btyp_double:
           {
             if ((argx.is_sparse_type ()
                  && (argy.is_sparse_type () || argy.is_scalar_type ()))
                 || (argy.is_sparse_type () && argx.is_scalar_type ()))
               retval = do_minmax_bin_op<SparseMatrix> (argx, argy, ismin);
             else
               retval = do_minmax_bin_op<NDArray> (argx, argy, ismin);
-            break;
           }
+          break;
+
         case btyp_complex:
           {
             if ((argx.is_sparse_type ()
                  && (argy.is_sparse_type () || argy.is_scalar_type ()))
                 || (argy.is_sparse_type () && argx.is_scalar_type ()))
               retval = do_minmax_bin_op<SparseComplexMatrix> (argx, argy,
                                                               ismin);
             else
               retval = do_minmax_bin_op<ComplexNDArray> (argx, argy, ismin);
-            break;
           }
+          break;
+
         case btyp_float:
           retval = do_minmax_bin_op<FloatNDArray> (argx, argy, ismin);
           break;
+
         case btyp_float_complex:
           retval = do_minmax_bin_op<FloatComplexNDArray> (argx, argy, ismin);
           break;
+
         case btyp_char:
           retval = do_minmax_bin_op<charNDArray> (argx, argy, ismin);
           break;
+
 #define MAKE_INT_BRANCH(X) \
         case btyp_ ## X: \
           retval = do_minmax_bin_op<X ## NDArray> (argx, argy, ismin); \
           break;
+
         MAKE_INT_BRANCH (int8);
         MAKE_INT_BRANCH (int16);
         MAKE_INT_BRANCH (int32);
         MAKE_INT_BRANCH (int64);
         MAKE_INT_BRANCH (uint8);
         MAKE_INT_BRANCH (uint16);
         MAKE_INT_BRANCH (uint32);
         MAKE_INT_BRANCH (uint64);
+
 #undef MAKE_INT_BRANCH
+
         /*
         FIXME: This is what should happen when boolNDArray has max()
         case btyp_bool:
           retval = do_minmax_bin_op<boolNDArray> (argx, argy, ismin);
           break;
         */
         default:
           error ("%s: cannot compute %s (%s, %s)", func, func,
                  argx.type_name ().c_str (), argy.type_name ().c_str ());
         }
 
       // FIXME: Delete when boolNDArray has max()
       if (xtyp == btyp_bool && ytyp == btyp_bool)
         retval(0) = retval(0).bool_array_value ();
 
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUN (min, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} min (@var{x})\n\
 @deftypefnx {Built-in Function} {} min (@var{x}, [], @var{dim})\n\
@@ -890,75 +909,81 @@ do_cumminmax_body (const octave_value_li
                    int nargout, bool ismin)
 {
   octave_value_list retval;
 
   const char *func = ismin ? "cummin" : "cummax";
 
   int nargin = args.length ();
 
-  if (nargin == 1 || nargin == 2)
-    {
-      octave_value arg = args(0);
-      int dim = -1;
-      if (nargin == 2)
-        {
-          dim = args(1).int_value (true) - 1;
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
 
-          if (dim < 0)
-            {
-              error ("%s: DIM must be a valid dimension", func);
-              return retval;
-            }
-        }
+  octave_value arg = args(0);
+  int dim = -1;
+  if (nargin == 2)
+    {
+      dim = args(1).int_value (true) - 1;
 
-      switch (arg.builtin_type ())
+      if (dim < 0)
         {
-        case btyp_double:
-          retval = do_cumminmax_red_op<NDArray> (arg, nargout, dim, ismin);
-          break;
-        case btyp_complex:
-          retval = do_cumminmax_red_op<ComplexNDArray> (arg, nargout, dim,
-                                                        ismin);
-          break;
-        case btyp_float:
-          retval = do_cumminmax_red_op<FloatNDArray> (arg, nargout, dim, ismin);
-          break;
-        case btyp_float_complex:
-          retval = do_cumminmax_red_op<FloatComplexNDArray> (arg, nargout, dim,
-                                                             ismin);
-          break;
-#define MAKE_INT_BRANCH(X) \
-        case btyp_ ## X: \
-          retval = do_cumminmax_red_op<X ## NDArray> (arg, nargout, dim, \
-                                                      ismin); \
-          break;
-        MAKE_INT_BRANCH (int8);
-        MAKE_INT_BRANCH (int16);
-        MAKE_INT_BRANCH (int32);
-        MAKE_INT_BRANCH (int64);
-        MAKE_INT_BRANCH (uint8);
-        MAKE_INT_BRANCH (uint16);
-        MAKE_INT_BRANCH (uint32);
-        MAKE_INT_BRANCH (uint64);
-#undef MAKE_INT_BRANCH
-        case btyp_bool:
-          {
-            retval = do_cumminmax_red_op<int8NDArray> (arg, nargout, dim,
-                                                       ismin);
-            if (retval.length () > 0)
-              retval(0) = retval(0).bool_array_value ();
-            break;
-          }
-        default:
-          gripe_wrong_type_arg (func, arg);
+          error ("%s: DIM must be a valid dimension", func);
+          return retval;
         }
     }
-  else
-    print_usage ();
+
+  switch (arg.builtin_type ())
+    {
+    case btyp_double:
+      retval = do_cumminmax_red_op<NDArray> (arg, nargout, dim, ismin);
+      break;
+
+    case btyp_complex:
+      retval = do_cumminmax_red_op<ComplexNDArray> (arg, nargout, dim,
+                                                    ismin);
+      break;
+
+    case btyp_float:
+      retval = do_cumminmax_red_op<FloatNDArray> (arg, nargout, dim, ismin);
+      break;
+
+    case btyp_float_complex:
+      retval = do_cumminmax_red_op<FloatComplexNDArray> (arg, nargout, dim,
+                                                         ismin);
+      break;
+
+#define MAKE_INT_BRANCH(X) \
+      case btyp_ ## X: \
+        retval = do_cumminmax_red_op<X ## NDArray> (arg, nargout, dim, \
+                                                    ismin); \
+        break;
+
+      MAKE_INT_BRANCH (int8);
+      MAKE_INT_BRANCH (int16);
+      MAKE_INT_BRANCH (int32);
+      MAKE_INT_BRANCH (int64);
+      MAKE_INT_BRANCH (uint8);
+      MAKE_INT_BRANCH (uint16);
+      MAKE_INT_BRANCH (uint32);
+      MAKE_INT_BRANCH (uint64);
+
+#undef MAKE_INT_BRANCH
+
+    case btyp_bool:
+      {
+        retval = do_cumminmax_red_op<int8NDArray> (arg, nargout, dim,
+                                                   ismin);
+        if (retval.length () > 0)
+          retval(0) = retval(0).bool_array_value ();
+      }
+      break;
+
+    default:
+      gripe_wrong_type_arg (func, arg);
+    }
 
   return retval;
 }
 
 DEFUN (cummin, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} cummin (@var{x})\n\
 @deftypefnx {Built-in Function} {} cummin (@var{x}, @var{dim})\n\
diff --git a/libinterp/corefcn/mgorth.cc b/libinterp/corefcn/mgorth.cc
--- a/libinterp/corefcn/mgorth.cc
+++ b/libinterp/corefcn/mgorth.cc
@@ -67,20 +67,17 @@ On exit, @var{y} is a unit vector such t
 \n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin != 2 || nargout > 2)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value arg_x = args(0);
   octave_value arg_v = args(1);
 
   if (arg_v.ndims () != 2 || arg_x.ndims () != 2 || arg_x.columns () != 1
       || arg_v.rows () != arg_x.rows ())
     {
       error ("mgorth: V should be a matrix, and X a column vector with"
diff --git a/libinterp/corefcn/ordschur.cc b/libinterp/corefcn/ordschur.cc
--- a/libinterp/corefcn/ordschur.cc
+++ b/libinterp/corefcn/ordschur.cc
@@ -106,20 +106,17 @@ is in the upper left corner, by doing:\n
 \n\
 @seealso{schur}\n\
 @end deftypefn")
 {
   const octave_idx_type nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 3)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   const Array<octave_idx_type> sel = args(2).octave_idx_type_vector_value ("ordschur: SELECT must be an array of integers");
 
   const octave_idx_type n = sel.numel ();
 
   const dim_vector dimU = args(0).dims ();
   const dim_vector dimS = args(1).dims ();
   if (n != dimU(0))
diff --git a/libinterp/corefcn/pinv.cc b/libinterp/corefcn/pinv.cc
--- a/libinterp/corefcn/pinv.cc
+++ b/libinterp/corefcn/pinv.cc
@@ -54,20 +54,17 @@ tol = max (size (@var{x})) * sigma_max (
 where @code{sigma_max (@var{x})} is the maximal singular value of @var{x}.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value arg = args(0);
 
   int arg_is_empty = empty_arg ("pinv", arg.rows (), arg.columns ());
 
   if (arg_is_empty < 0)
     return retval;
   else if (arg_is_empty > 0)
diff --git a/libinterp/corefcn/profiler.cc b/libinterp/corefcn/profiler.cc
--- a/libinterp/corefcn/profiler.cc
+++ b/libinterp/corefcn/profiler.cc
@@ -396,33 +396,25 @@ profile_data_accumulator profiler;
 
 // Enable or disable the profiler data collection.
 DEFUN (__profiler_enable__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Function File} {} __profiler_enable__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  int nargin = args.length ();
 
-  const int nargin = args.length ();
+  if (nargin > 1)
+    print_usage ();
+
   if (nargin > 0)
-    {
-      if (nargin > 1)
-        {
-          print_usage ();
-          return retval;
-        }
+    profiler.set_active (args(0).bool_value ());
 
-      profiler.set_active (args(0).bool_value ());
-    }
-
-  retval(0) = profiler.is_active ();
-
-  return retval;
+  return octave_value (profiler.is_active ());
 }
 
 // Clear all collected profiling data.
 DEFUN (__profiler_reset__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Function File} {} __profiler_reset__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
diff --git a/libinterp/corefcn/quad.cc b/libinterp/corefcn/quad.cc
--- a/libinterp/corefcn/quad.cc
+++ b/libinterp/corefcn/quad.cc
@@ -191,231 +191,229 @@ variable by routines @code{dblquad} and 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     error ("quad: invalid recursive call");
 
   int nargin = args.length ();
 
-  if (nargin > 2 && nargin < 6 && nargout < 5)
+  if (nargin < 3 || nargin > 5 || nargout > 4)
+    print_usage ();
+
+  if (args(0).is_function_handle () || args(0).is_inline_function ())
+    quad_fcn = args(0).function_value ();
+  else
     {
-      if (args(0).is_function_handle () || args(0).is_inline_function ())
-        quad_fcn = args(0).function_value ();
-      else
+      fcn_name = unique_symbol_name ("__quad_fcn__");
+      std::string fname = "function y = ";
+      fname.append (fcn_name);
+      fname.append ("(x) y = ");
+      quad_fcn = extract_function (args(0), "quad", fcn_name, fname,
+                                   "; endfunction");
+      frame.add_fcn (clear_function, fcn_name);
+    }
+
+  if (! quad_fcn)
+    error ("quad: FCN argument is not a valid function name or handle");
+
+  if (args(1).is_single_type () || args(2).is_single_type ())
+    {
+      float a = args(1).xfloat_value ("quad: lower limit of integration A must be a scalar");
+      float b = args(2).xfloat_value ("quad: upper limit of integration B must be a scalar");
+
+      int indefinite = 0;
+      FloatIndefQuad::IntegralType indef_type
+        = FloatIndefQuad::doubly_infinite;
+      float bound = 0.0;
+      if (xisinf (a) && xisinf (b))
         {
-          fcn_name = unique_symbol_name ("__quad_fcn__");
-          std::string fname = "function y = ";
-          fname.append (fcn_name);
-          fname.append ("(x) y = ");
-          quad_fcn = extract_function (args(0), "quad", fcn_name, fname,
-                                       "; endfunction");
-          frame.add_fcn (clear_function, fcn_name);
+          indefinite = 1;
+          indef_type = FloatIndefQuad::doubly_infinite;
+        }
+      else if (xisinf (a))
+        {
+          indefinite = 1;
+          bound = b;
+          indef_type = FloatIndefQuad::neg_inf_to_bound;
+        }
+      else if (xisinf (b))
+        {
+          indefinite = 1;
+          bound = a;
+          indef_type = FloatIndefQuad::bound_to_inf;
         }
 
-      if (! quad_fcn)
-        error ("quad: FCN argument is not a valid function name or handle");
-
-      if (args(1).is_single_type () || args(2).is_single_type ())
-        {
-          float a = args(1).xfloat_value ("quad: lower limit of integration A must be a scalar");
-          float b = args(2).xfloat_value ("quad: upper limit of integration B must be a scalar");
+      octave_idx_type ier = 0;
+      octave_idx_type nfun = 0;
+      float abserr = 0.0;
+      float val = 0.0;
+      bool have_sing = false;
+      FloatColumnVector sing;
+      FloatColumnVector tol;
 
-          int indefinite = 0;
-          FloatIndefQuad::IntegralType indef_type
-            = FloatIndefQuad::doubly_infinite;
-          float bound = 0.0;
-          if (xisinf (a) && xisinf (b))
-            {
-              indefinite = 1;
-              indef_type = FloatIndefQuad::doubly_infinite;
-            }
-          else if (xisinf (a))
-            {
-              indefinite = 1;
-              bound = b;
-              indef_type = FloatIndefQuad::neg_inf_to_bound;
-            }
-          else if (xisinf (b))
-            {
-              indefinite = 1;
-              bound = a;
-              indef_type = FloatIndefQuad::bound_to_inf;
-            }
-
-          octave_idx_type ier = 0;
-          octave_idx_type nfun = 0;
-          float abserr = 0.0;
-          float val = 0.0;
-          bool have_sing = false;
-          FloatColumnVector sing;
-          FloatColumnVector tol;
-
-          switch (nargin)
-            {
-            case 5:
-              if (indefinite)
-                error ("quad: singularities not allowed on infinite intervals");
+      switch (nargin)
+        {
+        case 5:
+          if (indefinite)
+            error ("quad: singularities not allowed on infinite intervals");
 
-              have_sing = true;
-
-              sing = args(4).xfloat_vector_value ("quad: fifth argument SING must be a vector vector of singularities");
-
-            case 4:
-              tol = args(3).xfloat_vector_value ("quad: TOL must be a 1 or 2-element vector");
+          have_sing = true;
 
-              switch (tol.numel ())
-                {
-                case 2:
-                  quad_opts.set_single_precision_relative_tolerance (tol (1));
+          sing = args(4).xfloat_vector_value ("quad: fifth argument SING must be a vector vector of singularities");
 
-                case 1:
-                  quad_opts.set_single_precision_absolute_tolerance (tol (0));
-                  break;
-
-                default:
-                  error ("quad: TOL must be a 1 or 2-element vector");
-                }
+        case 4:
+          tol = args(3).xfloat_vector_value ("quad: TOL must be a 1 or 2-element vector");
 
-            case 3:
-              if (indefinite)
-                {
-                  FloatIndefQuad iq (quad_float_user_function, bound,
-                                     indef_type);
-                  iq.set_options (quad_opts);
-                  val = iq.float_integrate (ier, nfun, abserr);
-                }
-              else
-                {
-                  if (have_sing)
-                    {
-                      FloatDefQuad dq (quad_float_user_function, a, b, sing);
-                      dq.set_options (quad_opts);
-                      val = dq.float_integrate (ier, nfun, abserr);
-                    }
-                  else
-                    {
-                      FloatDefQuad dq (quad_float_user_function, a, b);
-                      dq.set_options (quad_opts);
-                      val = dq.float_integrate (ier, nfun, abserr);
-                    }
-                }
+          switch (tol.numel ())
+            {
+            case 2:
+              quad_opts.set_single_precision_relative_tolerance (tol (1));
+
+            case 1:
+              quad_opts.set_single_precision_absolute_tolerance (tol (0));
               break;
 
             default:
-              panic_impossible ();
-              break;
-            }
-
-          retval(3) = abserr;
-          retval(2) = nfun;
-          retval(1) = ier;
-          retval(0) = val;
-
-        }
-      else
-        {
-          double a = args(1).xdouble_value ("quad: lower limit of integration A must be a scalar");
-          double b = args(2).xdouble_value ("quad: upper limit of integration B must be a scalar");
-
-          int indefinite = 0;
-          IndefQuad::IntegralType indef_type = IndefQuad::doubly_infinite;
-          double bound = 0.0;
-          if (xisinf (a) && xisinf (b))
-            {
-              indefinite = 1;
-              indef_type = IndefQuad::doubly_infinite;
-            }
-          else if (xisinf (a))
-            {
-              indefinite = 1;
-              bound = b;
-              indef_type = IndefQuad::neg_inf_to_bound;
-            }
-          else if (xisinf (b))
-            {
-              indefinite = 1;
-              bound = a;
-              indef_type = IndefQuad::bound_to_inf;
+              error ("quad: TOL must be a 1 or 2-element vector");
             }
 
-          octave_idx_type ier = 0;
-          octave_idx_type nfun = 0;
-          double abserr = 0.0;
-          double val = 0.0;
-          bool have_sing = false;
-          ColumnVector sing;
-          ColumnVector tol;
-
-          switch (nargin)
+        case 3:
+          if (indefinite)
             {
-            case 5:
-              if (indefinite)
-                error ("quad: singularities not allowed on infinite intervals");
-
-              have_sing = true;
-
-              sing = args(4).vector_value ("quad: fifth argument SING must be a vector vector of singularities");
-
-            case 4:
-              tol = args(3).xvector_value ("quad: TOL must be a 1 or 2-element vector");
-
-              switch (tol.numel ())
+              FloatIndefQuad iq (quad_float_user_function, bound,
+                                 indef_type);
+              iq.set_options (quad_opts);
+              val = iq.float_integrate (ier, nfun, abserr);
+            }
+          else
+            {
+              if (have_sing)
                 {
-                case 2:
-                  quad_opts.set_relative_tolerance (tol (1));
-
-                case 1:
-                  quad_opts.set_absolute_tolerance (tol (0));
-                  break;
-
-                default:
-                  error ("quad: TOL must be a 1 or 2-element vector");
-                }
-
-            case 3:
-              if (indefinite)
-                {
-                  IndefQuad iq (quad_user_function, bound, indef_type);
-                  iq.set_options (quad_opts);
-                  val = iq.integrate (ier, nfun, abserr);
+                  FloatDefQuad dq (quad_float_user_function, a, b, sing);
+                  dq.set_options (quad_opts);
+                  val = dq.float_integrate (ier, nfun, abserr);
                 }
               else
                 {
-                  if (have_sing)
-                    {
-                      DefQuad dq (quad_user_function, a, b, sing);
-                      dq.set_options (quad_opts);
-                      val = dq.integrate (ier, nfun, abserr);
-                    }
-                  else
-                    {
-                      DefQuad dq (quad_user_function, a, b);
-                      dq.set_options (quad_opts);
-                      val = dq.integrate (ier, nfun, abserr);
-                    }
+                  FloatDefQuad dq (quad_float_user_function, a, b);
+                  dq.set_options (quad_opts);
+                  val = dq.float_integrate (ier, nfun, abserr);
                 }
+            }
+          break;
+
+        default:
+          panic_impossible ();
+          break;
+        }
+
+      retval(3) = abserr;
+      retval(2) = nfun;
+      retval(1) = ier;
+      retval(0) = val;
+
+    }
+  else
+    {
+      double a = args(1).xdouble_value ("quad: lower limit of integration A must be a scalar");
+      double b = args(2).xdouble_value ("quad: upper limit of integration B must be a scalar");
+
+      int indefinite = 0;
+      IndefQuad::IntegralType indef_type = IndefQuad::doubly_infinite;
+      double bound = 0.0;
+      if (xisinf (a) && xisinf (b))
+        {
+          indefinite = 1;
+          indef_type = IndefQuad::doubly_infinite;
+        }
+      else if (xisinf (a))
+        {
+          indefinite = 1;
+          bound = b;
+          indef_type = IndefQuad::neg_inf_to_bound;
+        }
+      else if (xisinf (b))
+        {
+          indefinite = 1;
+          bound = a;
+          indef_type = IndefQuad::bound_to_inf;
+        }
+
+      octave_idx_type ier = 0;
+      octave_idx_type nfun = 0;
+      double abserr = 0.0;
+      double val = 0.0;
+      bool have_sing = false;
+      ColumnVector sing;
+      ColumnVector tol;
+
+      switch (nargin)
+        {
+        case 5:
+          if (indefinite)
+            error ("quad: singularities not allowed on infinite intervals");
+
+          have_sing = true;
+
+          sing = args(4).vector_value ("quad: fifth argument SING must be a vector vector of singularities");
+
+        case 4:
+          tol = args(3).xvector_value ("quad: TOL must be a 1 or 2-element vector");
+
+          switch (tol.numel ())
+            {
+            case 2:
+              quad_opts.set_relative_tolerance (tol (1));
+
+            case 1:
+              quad_opts.set_absolute_tolerance (tol (0));
               break;
 
             default:
-              panic_impossible ();
-              break;
+              error ("quad: TOL must be a 1 or 2-element vector");
             }
 
-          retval(3) = abserr;
-          retval(2) = nfun;
-          retval(1) = ier;
-          retval(0) = val;
+        case 3:
+          if (indefinite)
+            {
+              IndefQuad iq (quad_user_function, bound, indef_type);
+              iq.set_options (quad_opts);
+              val = iq.integrate (ier, nfun, abserr);
+            }
+          else
+            {
+              if (have_sing)
+                {
+                  DefQuad dq (quad_user_function, a, b, sing);
+                  dq.set_options (quad_opts);
+                  val = dq.integrate (ier, nfun, abserr);
+                }
+              else
+                {
+                  DefQuad dq (quad_user_function, a, b);
+                  dq.set_options (quad_opts);
+                  val = dq.integrate (ier, nfun, abserr);
+                }
+            }
+          break;
+
+        default:
+          panic_impossible ();
+          break;
         }
 
-      if (fcn_name.length ())
-        clear_function (fcn_name);
+      retval(3) = abserr;
+      retval(2) = nfun;
+      retval(1) = ier;
+      retval(0) = val;
     }
-  else
-    print_usage ();
+
+  if (fcn_name.length ())
+    clear_function (fcn_name);
 
   return retval;
 }
 
 /*
 %!function y = __f (x)
 %!  y = x + 1;
 %!endfunction
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -378,25 +378,20 @@ compatibility with @sc{matlab}.\n\
   int nargin = args.length ();
 
 #ifdef DEBUG
   std::cout << "qz: nargin = " << nargin
             << ", nargout = " << nargout << std::endl;
 #endif
 
   if (nargin < 2 || nargin > 3 || nargout > 7)
-    {
-      print_usage ();
-      return retval;
-    }
-  else if (nargin == 3 && (nargout < 3 || nargout > 4))
-    {
-      error ("qz: invalid number of output arguments for form [3] call");
-      return retval;
-    }
+    print_usage ();
+
+  if (nargin == 3 && (nargout < 3 || nargout > 4))
+    error ("qz: invalid number of output arguments for form [3] call");
 
 #ifdef DEBUG
   std::cout << "qz: determine ordering option" << std::endl;
 #endif
 
   // Determine ordering option.
   volatile char ord_job = 0;
   static double safmin;
diff --git a/libinterp/corefcn/rcond.cc b/libinterp/corefcn/rcond.cc
--- a/libinterp/corefcn/rcond.cc
+++ b/libinterp/corefcn/rcond.cc
@@ -46,17 +46,18 @@ instead.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ();
-  else if (args(0).is_sparse_type ())
+
+  if (args(0).is_sparse_type ())
     error ("rcond: for sparse matrices use 'rcond (full (a))' or 'condest (a)' instead");
   else if (args(0).is_single_type ())
     {
       if (args(0).is_complex_type ())
         {
           FloatComplexMatrix m = args(0).float_complex_matrix_value ();
           MatrixType mattyp;
           retval = m.rcond (mattyp);
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -128,20 +128,17 @@ in control (see @code{are} and @code{dar
 @seealso{rsf2csf, ordschur, lu, chol, hess, qr, qz, svd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2 || nargout > 2)
-    {
-      print_usage ();
-      return retval;
-    }
+    print_usage ();
 
   octave_value arg = args(0);
 
   std::string ord;
 
   if (nargin == 2)
     ord = args(1).xstring_value ("schur: second argument must be a string");
 
@@ -292,51 +289,49 @@ Note that the following relations hold:\
 @end ifnottex\n\
 \n\
 Note also that @var{U} and @var{T} are not unique.\n\
 @seealso{schur}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  if (args.length () == 2 && nargout <= 2)
+  if (args.length () != 2 || nargout > 2)
+    print_usage ();
+
+  if (! args(0).is_numeric_type ())
+    gripe_wrong_type_arg ("rsf2csf", args(0));
+  else if (! args(1).is_numeric_type ())
+    gripe_wrong_type_arg ("rsf2csf", args(1));
+  else if (args(0).is_complex_type () || args(1).is_complex_type ())
+    error ("rsf2csf: UR and TR must be real matrices");
+  else
     {
-      if (! args(0).is_numeric_type ())
-        gripe_wrong_type_arg ("rsf2csf", args(0));
-      else if (! args(1).is_numeric_type ())
-        gripe_wrong_type_arg ("rsf2csf", args(1));
-      else if (args(0).is_complex_type () || args(1).is_complex_type ())
-        error ("rsf2csf: UR and TR must be real matrices");
+
+      if (args(0).is_single_type () || args(1).is_single_type ())
+        {
+          FloatMatrix u = args(0).float_matrix_value ();
+          FloatMatrix t = args(1).float_matrix_value ();
+
+          FloatComplexSCHUR cs (FloatSCHUR (t, u));
+
+          retval(1) = cs.schur_matrix ();
+          retval(0) = cs.unitary_matrix ();
+        }
       else
         {
-
-          if (args(0).is_single_type () || args(1).is_single_type ())
-            {
-              FloatMatrix u = args(0).float_matrix_value ();
-              FloatMatrix t = args(1).float_matrix_value ();
-
-              FloatComplexSCHUR cs (FloatSCHUR (t, u));
+          Matrix u = args(0).matrix_value ();
+          Matrix t = args(1).matrix_value ();
 
-              retval(1) = cs.schur_matrix ();
-              retval(0) = cs.unitary_matrix ();
-            }
-          else
-            {
-              Matrix u = args(0).matrix_value ();
-              Matrix t = args(1).matrix_value ();
+          ComplexSCHUR cs (SCHUR (t, u));
 
-              ComplexSCHUR cs (SCHUR (t, u));
-
-              retval(1) = cs.schur_matrix ();
-              retval(0) = cs.unitary_matrix ();
-            }
+          retval(1) = cs.schur_matrix ();
+          retval(0) = cs.unitary_matrix ();
         }
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 /*
 %!test
 %! A = [1, 1, 1, 2; 1, 2, 1, 1; 1, 1, 3, 1; -2, 1, 1, 1];
 %! [u, t] = schur (A);
diff --git a/libinterp/corefcn/str2double.cc b/libinterp/corefcn/str2double.cc
--- a/libinterp/corefcn/str2double.cc
+++ b/libinterp/corefcn/str2double.cc
@@ -340,17 +340,18 @@ and return NaN.\n\
 risk of using @code{eval} on unknown data.\n\
 @seealso{str2num}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 1)
     print_usage ();
-  else if (args(0).is_string ())
+
+  if (args(0).is_string ())
     {
       if (args(0).rows () == 0 || args(0).columns () == 0)
         {
           retval = Matrix (1, 1, octave_NaN);
         }
       else if (args(0).rows () == 1 && args(0).ndims () == 2)
         {
           retval = str2double1 (args(0).string_value ());
@@ -372,17 +373,16 @@ risk of using @code{eval} on unknown dat
           if (cell(i).is_string ())
             output(i) = str2double1 (cell(i).string_value ());
         }
       retval = output;
     }
   else
     retval = Matrix (1, 1, octave_NaN);
 
-
   return retval;
 }
 
 /*
 %!assert (str2double ("1"), 1)
 %!assert (str2double ("-.1e-5"), -1e-6)
 %!assert (str2double (char ("1", "2 3", "4i")), [1; NaN; 4i])
 %!assert (str2double ("1,222.5"), 1222.5)
