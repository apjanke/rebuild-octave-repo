# HG changeset patch
# User Rik <rik@octave.org>
# Date 1513523071 28800
#      Sun Dec 17 07:04:31 2017 -0800
# Node ID 1d52db450db43df7adaacdb456cb6810e3adec52
# Parent  fc63541148647781f57398a3690622dd7df5db9b
Change ishandle to return true for Java objects for Matlab compatibility.
Add new function isgraphics() for Matlab compatibility.
Change over existing instances of ishandle to ishghandle.

* NEWS: Announce changes.

* scripts/plot/util/isgraphics.m: New function.

* scripts/plot/util/ishandle.m: New function.

* scripts/plot/util/module.mk: Add isgraphics.m and ishandle.m to build system.

* plot.txi: Change documentation around ishandle.  Add isgraphics DOCSTRING to
manual.

* graphics.cc (Fishghandle): Rename function from ishandle to ishghandle.  Add
seealso links in docstring.
* graphics.cc: Rename all instances of is_handle to is_hghandle.

* genpropdoc.m, voronoi.m, guidata.m, guihandles.m,
__uiobject_split_args__.m, uibuttongroup.m, uicontrol.m, uiwait.m, waitbar.m,
brighten.m, delete.m, getappdata.m, isappdata.m, rmappdata.m, setappdata.m,
__clabel__.m, camlookat.m, clabel.m, legend.m, material.m, thetaticks.m,
whitebg.m, camlight.m, colorbar.m, isocolors.m, isonormals.m, plotmatrix.m,
plotyy.m, reducepatch.m, shrinkfaces.m, __actual_axis_position__.m,
__opengl_info__.m, __plt_get_axis_arg__.m, ancestor.m, copyobj.m, findobj.m,
hdl2struct.m, hgsave.m, hold.m, isaxes.m, isfigure.m, ishold.m, isprop.m,
linkprop.m, newplot.m, print.m, __gnuplot_draw_axes__.m,
__gnuplot_draw_figure__.m, rotate.m, saveas.m, struct2hdl.m, subplot.m:
Replace instances of ishandle with ishghandle in existing code.

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -64,16 +64,21 @@ Summary of important user-visible change
     final argument of 0.
 
  ** Text objects now implement the properties "BackgroundColor",
     "EdgeColor", "LineStyle", "LineWidth", and "Margin".
 
  ** An initial implementation of alpha transparency has been made for
     patch and surface objects.  Printing to svg and pdf is supported.
 
+ ** ishandle now returns true for both graphics handle objects and
+    Java objects.  The latter change was made for Matlab compatibility.
+    Use ishghandle or isgraphics if it is important not to include Java
+    objects.
+
  ** The following statistical functions have been moved from core
     Octave to the statistics package available from Octave Forge.
 
     table -> crosstab
 
  ** Other new functions added in 4.4:
 
       camlookat
@@ -87,16 +92,17 @@ Summary of important user-visible change
       corrcoef
       getframe
       gsvd
       hgtransform
       humps
       integral
       integral2
       integral3
+      isgraphics
       openvar
       quad2d
       repelem
       rticks
       thetaticks
       vecnorm
       xticklabels
       xticks
diff --git a/doc/interpreter/genpropdoc.m b/doc/interpreter/genpropdoc.m
--- a/doc/interpreter/genpropdoc.m
+++ b/doc/interpreter/genpropdoc.m
@@ -1630,17 +1630,17 @@ property to be set to @qcode{\"manual\"}
   fcnmsg = "For information on how to write graphics listener \
 functions see @ref{Callbacks, , @w{Callbacks section}}.";
   strout = strrep (strout, "__fcnmsg__", fcnmsg);
 endfunction
 
 function s = getstructure (objname, base = [])
   hf = [];
   if (! strcmp (objname, "root"))
-    ## Use an improbable number to avoid ishandle to return true for 1
+    ## Use an improbable number to avoid ishghandle to return true for 1
     hf = figure (2265465, "visible", "off");
   endif
 
   ## Build a default object to extract its properties list and default values.
   if (strcmp (objname, "base"))
     ## Base properties are extracted from hggroup that only have 1 additional
     ## regular (non-hidden) property, "displayname".
     h = hggroup ();
@@ -1700,17 +1700,17 @@ function s = getstructure (objname, base
 endfunction
 
 function def = getdefault (h, objname, field)
   ## This function is meant to be run without initialization file so
   ## that the properties we get are the default.
   def = get (h, field);
 
   ## Don't print default values for graphics handles
-  if (isscalar (def) && def != 0 && ishandle (def))
+  if (isscalar (def) && def != 0 && ishghandle (def))
     def = "";
   else
     if (ischar (def))
       def = ['@qcode{"' def '"}'];
     else
       if ((isvector (def) && numel (def) < 5) || isempty (def))
         ## Use disp to print the default value for short vectors and
         ## empty values
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -1177,21 +1177,23 @@ the root object.
 2. Below the root are @code{figure} objects.
 
 3. Below the @code{figure} objects are @code{axes} objects.
 
 4. Below the @code{axes} objects are @code{line}, @code{text}, @code{patch},
 @code{surface}, @code{image}, and @code{light} objects.
 
 Graphics handles may be distinguished from function handles
-(@pxref{Function Handles}) by means of the function @code{ishandle}.
-@code{ishandle} returns true if its argument is a handle of a graphics object.
+(@pxref{Function Handles}) by means of the function @code{ishghandle}.
+@code{ishghandle} returns true if its argument is a handle of a graphics object.
 In addition, a figure or axes object may be tested using @code{isfigure} or
-@code{isaxes} respectively.  The test functions return true only if the
-argument is both a handle and of the correct type (figure or axes).
+@code{isaxes} respectively.  To test for a specific type of graphics handle,
+such as a patch or line object, use @code{isgraphics}.  The more specific test
+functions return true only if the argument is both a graphics handle and of the
+correct type (figure, axes, specified object type).
 
 The @code{whos} function can be used to show the object type of each currently
 defined graphics handle.  (Note: this is not true today, but it is, I hope,
 considered an error in whos.  It may be better to have whos just show
 graphics_handle as the class, and provide a new function which, given a
 graphics handle, returns its object type.  This could generalize the ishandle()
 functions and, in fact, replace them.)
 
@@ -1347,23 +1349,25 @@ Instead of calling @code{line}, use @cod
 @DOCSTRING(surface)
 
 @DOCSTRING(light)
 
 @subsubsection Handle Functions
 @cindex handle functions
 
 To determine whether a variable is a graphics object index, or an index
-to an axes or figure, use the functions @code{ishandle}, @code{isaxes}, and
-@code{isfigure}.
+to an axes or figure, use the functions @code{ishghandle}, @code{isgraphics},
+@code{isaxes}, and @code{isfigure}.
+
+@DOCSTRING(ishghandle)
+
+@DOCSTRING(isgraphics)
 
 @DOCSTRING(ishandle)
 
-@DOCSTRING(ishghandle)
-
 @DOCSTRING(isaxes)
 
 @DOCSTRING(isfigure)
 
 The function @code{gcf} returns an index to the current figure object,
 or creates one if none exists.  Similarly, @code{gca} returns the
 current axes object, or creates one (and its parent figure object) if
 none exists.
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -2908,44 +2908,44 @@ gh_manager::do_close_all_figures (void)
 static void
 adopt (const graphics_handle& parent_h, const graphics_handle& h)
 {
   graphics_object parent_go = gh_manager::get_object (parent_h);
   parent_go.adopt (h);
 }
 
 static bool
-is_handle (const graphics_handle& h)
+is_hghandle (const graphics_handle& h)
 {
   return h.ok ();
 }
 
 static bool
-is_handle (double val)
+is_hghandle (double val)
 {
   graphics_handle h = gh_manager::lookup (val);
 
   return h.ok ();
 }
 
 static octave_value
-is_handle (const octave_value& val)
+is_hghandle (const octave_value& val)
 {
   octave_value retval = false;
 
-  if (val.is_real_scalar () && is_handle (val.double_value ()))
+  if (val.is_real_scalar () && is_hghandle (val.double_value ()))
     retval = true;
   else if (val.isnumeric () && val.isreal ())
     {
       const NDArray handles = val.array_value ();
 
       boolNDArray result (handles.dims ());
 
       for (octave_idx_type i = 0; i < handles.numel (); i++)
-        result.xelem (i) = is_handle (handles(i));
+        result.xelem (i) = is_hghandle (handles(i));
 
       retval = result;
     }
 
   return retval;
 }
 
 static bool
@@ -3640,33 +3640,33 @@ root_figure::properties::set_callbackobj
         {
           val = cbo_stack.front ();
 
           cbo_stack.pop_front ();
         }
 
       callbackobject = val;
     }
-  else if (is_handle (val))
+  else if (is_hghandle (val))
     {
       if (get_callbackobject ().ok ())
         cbo_stack.push_front (get_callbackobject ());
 
       callbackobject = val;
     }
   else
     err_set_invalid ("callbackobject");
 }
 
 void
 root_figure::properties::set_currentfigure (const octave_value& v)
 {
   graphics_handle val (v);
 
-  if (octave::math::isnan (val.value ()) || is_handle (val))
+  if (octave::math::isnan (val.value ()) || is_hghandle (val))
     {
       currentfigure = val;
 
       if (val.ok ())
         gh_manager::push_figure (val);
     }
   else
     err_set_invalid ("currentfigure");
@@ -3814,17 +3814,17 @@ root_figure::reset_default_properties (v
 
 // ---------------------------------------------------------------------
 
 void
 figure::properties::set_currentaxes (const octave_value& val)
 {
   graphics_handle hax (val);
 
-  if (octave::math::isnan (hax.value ()) || is_handle (hax))
+  if (octave::math::isnan (hax.value ()) || is_hghandle (hax))
     currentaxes = hax;
   else
     err_set_invalid ("currentaxes");
 }
 
 void
 figure::properties::remove_child (const graphics_handle& h)
 {
@@ -10510,34 +10510,53 @@ root_figure::init_factory_properties (vo
   plist_map["uipushtool"] = uipushtool::properties::factory_defaults ();
   plist_map["uitoggletool"] = uitoggletool::properties::factory_defaults ();
 
   return plist_map;
 }
 
 // ---------------------------------------------------------------------
 
-DEFUN (ishandle, args, ,
+DEFUN (ishghandle, args, ,
        doc: /* -*- texinfo -*-
-@deftypefn {} {} ishandle (@var{h})
+@deftypefn {} {} ishghandle (@var{h})
 Return true if @var{h} is a graphics handle and false otherwise.
 
 @var{h} may also be a matrix of handles in which case a logical array is
 returned that is true where the elements of @var{h} are graphics handles and
 false where they are not.
-@seealso{isaxes, isfigure}
+@seealso{isgraphics, isaxes, isfigure, ishandle}
 @end deftypefn */)
 {
   gh_manager::auto_lock guard;
 
   if (args.length () != 1)
     print_usage ();
 
-  return ovl (is_handle (args(0)));
-}
+  return ovl (is_hghandle (args(0)));
+}
+
+/*
+%!test
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   assert (ishghandle (hf));
+%!   assert (! ishghandle (-hf));
+%!   ax = gca;
+%!   l = line;
+%!   assert (ishghandle (ax));
+%!   assert (! ishghandle (-ax));
+%!   assert (ishghandle ([l, -1, ax, hf]), logical ([1, 0, 1, 1]));
+%!   assert (ishghandle ([l, -1, ax, hf]'), logical ([1, 0, 1, 1]'));
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
+%!assert (ishghandle ([-1 0]), [false true])
+*/
 
 static bool
 is_handle_visible (const graphics_handle& h)
 {
   return h.ok () && gh_manager::is_handle_visible (h);
 }
 
 static bool
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -63,17 +63,17 @@
 function [vx, vy] = voronoi (varargin)
 
   if (nargin < 1)
     print_usage ();
   endif
 
   narg = 1;
   hax = NaN;
-  if (isscalar (varargin{1}) && ishandle (varargin{1}))
+  if (isscalar (varargin{1}) && ishghandle (varargin{1}))
     hax = varargin{1};
     if (! isaxes (hax))
       error ("voronoi: HAX argument must be an axes object");
     endif
     narg += 1;
   endif
 
   if (nargin < 1 + narg || nargin > 3 + narg)
diff --git a/scripts/gui/guidata.m b/scripts/gui/guidata.m
--- a/scripts/gui/guidata.m
+++ b/scripts/gui/guidata.m
@@ -34,17 +34,17 @@
 ## Author: goffioul
 
 function dataout = guidata (h, data)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
-  if (! ishandle (h))
+  if (! ishghandle (h))
     error ("guidata: H must be a valid object handle");
   endif
   h = ancestor (h, "figure");
   if (isempty (h))
     error ("guidata: no ancestor figure of H found");
   endif
 
   if (nargin == 1)
diff --git a/scripts/gui/guihandles.m b/scripts/gui/guihandles.m
--- a/scripts/gui/guihandles.m
+++ b/scripts/gui/guihandles.m
@@ -37,17 +37,17 @@
 
 function hdata = guihandles (h)
 
   if (nargin > 2)
     print_usage ();
   endif
 
   if (nargin == 1)
-    if (! ishandle (h))
+    if (! ishghandle (h))
       error ("guidata: H must be a valid object handle");
     endif
     h = ancestor (h, "figure");
     if (isempty (h))
       error ("guidata: no ancestor figure of H found");
     endif
   else
     h = gcf ();
diff --git a/scripts/gui/private/__uiobject_split_args__.m b/scripts/gui/private/__uiobject_split_args__.m
--- a/scripts/gui/private/__uiobject_split_args__.m
+++ b/scripts/gui/private/__uiobject_split_args__.m
@@ -25,17 +25,17 @@
 
 function [parent, args] = __uiobject_split_args__ (who, in_args, parent_type = {}, use_gcf = 1)
 
   parent = [];
   args = {};
   offset = 1;
 
   if (! isempty (in_args))
-    if (ishandle (in_args{1}))
+    if (ishghandle (in_args{1}))
       parent = in_args{1};
       offset = 2;
     elseif (! ischar (in_args{1}))
       error ("%s: invalid parent handle.", who);
     endif
 
     args = in_args(offset:end);
   endif
@@ -43,17 +43,17 @@ function [parent, args] = __uiobject_spl
   if (rem (length (args), 2))
     error ("%s: PROPERTY/VALUE arguments must occur in pairs", who);
   endif
 
   if (! isempty (args))
     i = find (strcmpi (args(1:2:end), "parent"), 1, "first");
     if (! isempty (i) && length (args) >= 2*i)
       parent = args{2*i};
-      if (! ishandle (parent))
+      if (! ishghandle (parent))
         error ("%s: invalid parent handle.", who);
       endif
       args([2*i-1, 2*i]) = [];
     endif
   endif
 
   if (! isempty (parent))
     if (! isempty (parent_type)
diff --git a/scripts/gui/uibuttongroup.m b/scripts/gui/uibuttongroup.m
--- a/scripts/gui/uibuttongroup.m
+++ b/scripts/gui/uibuttongroup.m
@@ -59,17 +59,17 @@
 ## @end example
 ## @seealso{figure, uipanel}
 ## @end deftypefn
 
 ## Author: zeripath
 
 function hui = uibuttongroup (varargin)
 
-  if (nargin == 1 && ishandle (varargin{1})
+  if (nargin == 1 && ishghandle (varargin{1})
       && strcmpi (get (varargin{1}, "type"), "uibuttongroup"))
     error ("uibuttongroup: focusing not implemented yet");
   endif
 
   [h, args] = __uiobject_split_args__ ("uibuttongroup", varargin,
                                        {"figure", "uipanel", "uibuttongroup"});
   hui = __go_uibuttongroup__ (h, args{:});
 
diff --git a/scripts/gui/uicontrol.m b/scripts/gui/uicontrol.m
--- a/scripts/gui/uicontrol.m
+++ b/scripts/gui/uicontrol.m
@@ -95,17 +95,17 @@
 ## @end example
 ## @seealso{figure, uipanel}
 ## @end deftypefn
 
 ## Author: goffioul
 
 function hui = uicontrol (varargin)
 
-  if (nargin == 1 && ishandle (varargin{1})
+  if (nargin == 1 && ishghandle (varargin{1})
       && strcmpi (get (varargin{1}, "type"), "uicontrol"))
     error ("uicontrol: focusing not implemented yet");
   endif
 
   [h, args] = __uiobject_split_args__ ("uicontrol", varargin,
                                        {"figure", "uipanel", "uibuttongroup"});
   htmp = __go_uicontrol__ (h, args{:});
 
diff --git a/scripts/gui/uiwait.m b/scripts/gui/uiwait.m
--- a/scripts/gui/uiwait.m
+++ b/scripts/gui/uiwait.m
@@ -66,15 +66,15 @@ function uiwait (varargin)
         set (h, "__uiwait_state__", "active");
       end_try_catch
       waitfor_args = {h, "__uiwait_state__", "triggered"};
       if (! isempty (timeout))
         waitfor_args(end+1:end+2) = {"timeout", timeout};
       endif
       waitfor (waitfor_args{:});
     unwind_protect_cleanup
-      if (ishandle (h) && isprop (h, "__uiwait_state__"))
+      if (ishghandle (h) && isprop (h, "__uiwait_state__"))
         set (h, "__uiwait_state__", "none");
       endif
     end_unwind_protect
   endif
 
 endfunction
diff --git a/scripts/gui/waitbar.m b/scripts/gui/waitbar.m
--- a/scripts/gui/waitbar.m
+++ b/scripts/gui/waitbar.m
@@ -60,17 +60,17 @@ function h = waitbar (varargin)
   frac = varargin{1};
   varargin(1) = [];
 
   if (! (isnumeric (frac) && isscalar (frac) && frac >= 0 && frac <= 1))
     error ("waitbar: FRAC must be between 0 and 1");
   endif
 
   ## Use existing waitbar if it still points to a valid graphics handle.
-  if (nargin == 1 && ishandle (curr_waitbar))
+  if (nargin == 1 && ishghandle (curr_waitbar))
     hf = curr_waitbar;
   else
     hf = false;
   endif
 
   if (! isempty (varargin) && isnumeric (varargin{1}))
     hf = varargin{1};
     varargin(1) = [];
@@ -259,17 +259,17 @@ endfunction
 %! yy = [0 0];
 %! hli = plot (xx, yy);
 %!
 %! disp ("Push the cancel to stop the process.");
 %! hf = waitbar(0,"0","Name","Building Koch curve ...",...
 %!              "createcancelbtn", "setappdata (gcbf,'interrupt', true)");
 %! for ii = 1:niter
 %!   ## Check cancel request
-%!   if (! ishandle (hf))
+%!   if (! ishghandle (hf))
 %!     break;
 %!   elseif (getappdata (hf, "interrupt"))
 %!     delete (hf);
 %!     break;
 %!   else
 %!     waitbar (ii/niter, hf, sprintf ("Step %d/%d", ii, niter));
 %!   endif
 %!
@@ -287,17 +287,17 @@ endfunction
 %!   tmp = cell2mat (tmp);
 %!   xx = [tmp(1,:) xx(end)];
 %!   yy = [tmp(2,:) yy(end)];
 %!   set (hli, "xdata", xx, "ydata", yy);
 %!   drawnow ();
 %!   pause (0.5);
 %! endfor
 %!
-%! if (ishandle (hf))
+%! if (ishghandle (hf))
 %!   delete (hf);
 %! endif
 
 ## Test input validation
 %!error <FRAC must be between 0 and 1> waitbar (-0.5)
 %!error <FRAC must be between 0 and 1> waitbar (1.5)
 %!error <MSG must be a character string> waitbar (0.5, struct ())
 %!error <invalid number of property/value pairs> waitbar (0.5, "msg", "Name")
diff --git a/scripts/image/brighten.m b/scripts/image/brighten.m
--- a/scripts/image/brighten.m
+++ b/scripts/image/brighten.m
@@ -44,17 +44,17 @@ function rmap = brighten (arg1, beta)
   endif
 
   h = -1;
   if (nargin == 1)
     beta = arg1;
     m = colormap ();
     h = gcf ();
   else
-    if (ishandle (arg1))
+    if (ishghandle (arg1))
       h = arg1;
       m = get (h, "colormap");
     elseif (iscolormap (arg1))
       m = arg1;
     else
       error ("brighten: first argument must be a colormap or a graphics handle");
     endif
   endif
@@ -65,17 +65,17 @@ function rmap = brighten (arg1, beta)
 
   if (beta > 0)
     gamma = 1 - beta;
   else
     gamma = 1 / (1 + beta);
   endif
 
   if (nargout == 0)
-    if (ishandle (h))
+    if (ishghandle (h))
       set (h, "colormap", m .^ gamma);
     else
       colormap (m .^ gamma);
     endif
   else
     rmap = m .^ gamma;
   endif
 
diff --git a/scripts/miscellaneous/delete.m b/scripts/miscellaneous/delete.m
--- a/scripts/miscellaneous/delete.m
+++ b/scripts/miscellaneous/delete.m
@@ -50,17 +50,17 @@ function delete (varargin)
         file = files{i};
         [err, msg] = unlink (file);
         if (err)
           warning ("delete: %s: %s", file, msg);
         endif
       endfor
     endfor
 
-  elseif (isscalar (varargin) && all (ishandle (varargin{1}(:))))
+  elseif (isscalar (varargin) && all (ishghandle (varargin{1}(:))))
     ## Delete a graphics object.
     __go_delete__ (varargin{1});
 
   else
     error ("delete: first argument must be a filename or graphics handle");
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/getappdata.m b/scripts/miscellaneous/getappdata.m
--- a/scripts/miscellaneous/getappdata.m
+++ b/scripts/miscellaneous/getappdata.m
@@ -33,17 +33,17 @@
 ## Created: 2010-07-15
 
 function value = getappdata (h, name)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
-  if (! all (ishandle (h(:))))
+  if (! all (ishghandle (h(:))))
     error ("getappdata: H must be a scalar or vector of graphic handles");
   endif
 
   if (nargin == 2)
     if (! ischar (name))
       error ("getappdata: NAME must be a string");
     endif
 
diff --git a/scripts/miscellaneous/isappdata.m b/scripts/miscellaneous/isappdata.m
--- a/scripts/miscellaneous/isappdata.m
+++ b/scripts/miscellaneous/isappdata.m
@@ -29,17 +29,17 @@
 ## Created: 2010-07-15
 
 function valid = isappdata (h, name)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
-  if (! all (ishandle (h(:))))
+  if (! all (ishghandle (h(:))))
     error ("isappdata: H must be a scalar or vector of graphic handles");
   elseif (! ischar (name))
     error ("isappdata: NAME must be a string");
   endif
 
   valid = false (size (h));
   for i = 1:numel (h)
     try
diff --git a/scripts/miscellaneous/rmappdata.m b/scripts/miscellaneous/rmappdata.m
--- a/scripts/miscellaneous/rmappdata.m
+++ b/scripts/miscellaneous/rmappdata.m
@@ -33,17 +33,17 @@
 
 function rmappdata (h, varargin)
 
   if (nargin < 2)
     print_usage ();
   endif
 
   h = h(:).';
-  if (! all (ishandle (h)))
+  if (! all (ishghandle (h)))
     error ("rmappdata: H must be a scalar or vector of graphic handles");
   elseif (! iscellstr (varargin))
     error ("rmappdata: NAME must be a string");
   endif
 
   for hg = h
     if (isprop (hg, "__appdata__"))
       appdata = get (hg, "__appdata__");
diff --git a/scripts/miscellaneous/setappdata.m b/scripts/miscellaneous/setappdata.m
--- a/scripts/miscellaneous/setappdata.m
+++ b/scripts/miscellaneous/setappdata.m
@@ -30,17 +30,17 @@
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2010-07-15
 
 function setappdata (h, varargin)
 
   h = h(:).';
-  if (! all (ishandle (h)))
+  if (! all (ishghandle (h)))
     error ("setappdata: H must be a scalar or vector of graphic handles");
   elseif (mod (numel (varargin), 2) != 0)
     error ("setappdata: NAME/VALUE arguments must occur in pairs");
   endif
 
   for hg = h
     try
       appdata = get (hg, "__appdata__");
diff --git a/scripts/plot/appearance/__clabel__.m b/scripts/plot/appearance/__clabel__.m
--- a/scripts/plot/appearance/__clabel__.m
+++ b/scripts/plot/appearance/__clabel__.m
@@ -27,17 +27,17 @@ function h = __clabel__ (c, v, hparent, 
   units = get (hax, "units");
   set (hax, "units", "points");
   axpos = get (hax, "position");
   set (hax, "units", units);
   lims = axis ();
   xspacing = axpos(3) / (lims(2) - lims (1));
   yspacing = axpos(4) / (lims(4) - lims (3));
 
-  if (isscalar (hparent) && ishandle (hparent)
+  if (isscalar (hparent) && ishghandle (hparent)
       && strcmp (get (hparent, "type"), "hggroup"))
     x = get (hparent, "xdata");
     xmin = min (x(:));
     xmax = max (x(:));
     y = get (hparent, "ydata");
     ymin = min (y(:));
     ymax = max (y(:));
   else
diff --git a/scripts/plot/appearance/camlookat.m b/scripts/plot/appearance/camlookat.m
--- a/scripts/plot/appearance/camlookat.m
+++ b/scripts/plot/appearance/camlookat.m
@@ -53,17 +53,17 @@ function camlookat (hh)
 
   if (nargin == 0)
     hax = gca ();
     hh = get (hax, "children");
   elseif (nargin == 1)
     if (isaxes (hh))
       hax = hh;
       hh = get (hax, "children");
-    elseif (all (ishandle (hh)))
+    elseif (all (ishghandle (hh)))
       hax = ancestor (hh, "axes");
       if numel (hax) > 1
         hax = unique ([hax{:}]);
       endif
       if (numel (hax) > 1)
         error ("camlookat: HANDLE_LIST must be children of the same axes.");
       endif
     endif
@@ -72,17 +72,17 @@ function camlookat (hh)
   if (isempty (hh))
     return
   end
 
   x0 = x1 = y0 = y1 = z0 = z1 = [];
   for i = 1:numel (hh)
     h = hh(i);
 
-    if (! ishandle (h))
+    if (! ishghandle (h))
       error ("camlookat: Inputs must be handles.");
     end
 
     x0_ = min (get (h, "xdata")(:));
     x1_ = max (get (h, "xdata")(:));
     y0_ = min (get (h, "ydata")(:));
     y1_ = max (get (h, "ydata")(:));
     z0_ = min (get (h, "zdata")(:));
diff --git a/scripts/plot/appearance/clabel.m b/scripts/plot/appearance/clabel.m
--- a/scripts/plot/appearance/clabel.m
+++ b/scripts/plot/appearance/clabel.m
@@ -68,17 +68,17 @@ function h = clabel (c, varargin)
   label_spacing = 144;  # 2 inches in points
 
   if (nargin < 1)
     print_usage ();
   elseif (nargin == 1)
     hparent = gca ();
   else
     arg = varargin{1};
-    if (isscalar (arg) && ishandle (arg)
+    if (isscalar (arg) && ishghandle (arg)
         && strcmp (get (arg, "type"), "hggroup"))
       try
         get (arg, "contourmatrix");
       catch
         error ("clabel: H must be a handle to a contour group");
       end_try_catch
       have_hg = true;
       hg = arg;
diff --git a/scripts/plot/appearance/legend.m b/scripts/plot/appearance/legend.m
--- a/scripts/plot/appearance/legend.m
+++ b/scripts/plot/appearance/legend.m
@@ -113,50 +113,50 @@
 ## of the current figure with the @qcode{"tag"} set to @qcode{"legend"}.
 ## Properties of the legend object may be manipulated directly by using
 ## @code{set}.
 ## @end deftypefn
 
 function [hleg, hleg_obj, hplot, labels] = legend (varargin)
 
   if (nargin > 0
-      && (! ishandle (varargin{1})
+      && (! ishghandle (varargin{1})
           || (strcmp (get (varargin{1}, "type"), "axes")
               && ! strcmp (get (varargin{1}, "tag"), "legend"))))
     [ca, varargin, nargin] = __plt_get_axis_arg__ ("legend", varargin{:});
     if (isempty (ca))
       ca = gca ();
     endif
     fig = ancestor (ca, "figure");
   else
     fig = get (0, "currentfigure");
     if (isempty (fig))
       fig = gcf ();
     endif
     ca = gca ();
   endif
 
   ## Special handling for plotyy which has two axes objects
-  if (ishandle (ca) && isprop (ca, "__plotyy_axes__"))
+  if (ishghandle (ca) && isprop (ca, "__plotyy_axes__"))
     plty = get (ca, "__plotyy_axes__");
-    if (isscalar (plty) && ishandle (plty))
+    if (isscalar (plty) && ishghandle (plty))
       ca = [ca, plty];
     elseif (iscell (plty))
       ca = [ca, plty{:}];
-    elseif (all (ishandle (plty)))
+    elseif (all (ishghandle (plty)))
       ca = [ca, plty(:).'];
     else
       error ("legend.m: This should not happen.  File a bug report.");
     endif
     ## Remove duplicates while preserving order
     [~, n] = unique (ca);
     ca = ca(sort (n));
   endif
 
-  if (nargin > 0 && all (ishandle (varargin{1})))
+  if (nargin > 0 && all (ishghandle (varargin{1})))
     kids = flipud (varargin{1}(:));
     varargin(1) = [];
   else
     kids = ca;
     kids(strcmp (get (ca, "tag"), "legend")) = [];
     if (isscalar (kids))
       kids = get (kids, "children")(:);
     else
@@ -1164,23 +1164,23 @@ function deletelegend2 (h, ~, ca, pos, o
           set (ca(i), "position", pos, "deletefcn", "");
         unwind_protect_cleanup
           set (ca(i), "units", units);
         end_unwind_protect
       endif
     endif
   endfor
 
-  if (ishandle (t1))
+  if (ishghandle (t1))
     set (t1, "deletefcn", "");
     delete (t1);
   endif
 
   for i = 1 : numel (hplots)
-    if (ishandle (hplots(i)) && strcmp (get (hplots(i), "type"), "line"))
+    if (ishghandle (hplots(i)) && strcmp (get (hplots(i), "type"), "line"))
       dellistener (hplots(i), "color");
       dellistener (hplots(i), "linestyle");
       dellistener (hplots(i), "linewidth");
       dellistener (hplots(i), "marker");
       dellistener (hplots(i), "markeredgecolor");
       dellistener (hplots(i), "markerfacecolor");
       dellistener (hplots(i), "markersize");
       dellistener (hplots(i), "displayname");
diff --git a/scripts/plot/appearance/material.m b/scripts/plot/appearance/material.m
--- a/scripts/plot/appearance/material.m
+++ b/scripts/plot/appearance/material.m
@@ -77,17 +77,17 @@ function retval = material (varargin)
          (nargout == 1 && (nargin == 0 || nargin == 1))) )
     print_usage ();
   endif
 
   ## resolve input
   h = [];
   if (nargout == 0)
     ## Check whether first argument is list of graphics handles.
-    if (all (ishandle (varargin{1})))
+    if (all (ishghandle (varargin{1})))
       h = varargin{1};
       varargin(1) = [];
     endif
 
     ## There must be one (additional) argument.
     if (numel (varargin) != 1)
       if (nargin == 2)
         error (["material: When called with two arguments, the first argument " ...
diff --git a/scripts/plot/appearance/thetaticks.m b/scripts/plot/appearance/thetaticks.m
--- a/scripts/plot/appearance/thetaticks.m
+++ b/scripts/plot/appearance/thetaticks.m
@@ -60,17 +60,17 @@ function retval = thetaticks (varargin)
       if (isaxes (varargin{1}))
         retval = get (varargin{1}, "ttick");
         return;
       else
         arg = varargin{1};
       endif
 
     case 2
-      if (! ishandle (varargin{1}))
+      if (! ishghandle (varargin{1}))
         error ("thetaticks: HAX must be a handle to an axes object");
       endif
       hax = varargin{1};
       arg = varargin{2};
 
     otherwise
       print_usage ();
 
diff --git a/scripts/plot/appearance/whitebg.m b/scripts/plot/appearance/whitebg.m
--- a/scripts/plot/appearance/whitebg.m
+++ b/scripts/plot/appearance/whitebg.m
@@ -61,17 +61,17 @@ function whitebg (varargin)
     print_usage ();
   endif
 
   h = 0;
   color = NaN;
   have_fig = false;
 
   if (nargin > 0)
-    if (all (ishandle (varargin{1})))
+    if (all (ishghandle (varargin{1})))
       h = varargin{1};
       have_fig = true;
       if (nargin == 2)
         color = varargin{2};
       endif
     elseif (nargin == 1)
       color = varargin{1};
     else
diff --git a/scripts/plot/draw/camlight.m b/scripts/plot/draw/camlight.m
--- a/scripts/plot/draw/camlight.m
+++ b/scripts/plot/draw/camlight.m
@@ -94,19 +94,19 @@ function h = camlight (varargin)
   if (nargin > 4)
     print_usage ();
   endif
 
   ## Note: There is a very small chance of a collision between a numeric double
   ## specifying azimuth and a light handle object (also a numeric double).
   ## We don't worry about that.
   if (numel (varargin) > 0 && numel (varargin{1}) == 1
-      && ishandle (varargin{1}))
+      && ishghandle (varargin{1}))
     hl = varargin{1};
-    if (! ishghandle (hl, "light"))
+    if (! isgraphics (hl, "light"))
       error ("camlight: HL must be a handle to a light object");
     endif
     varargin(1) = [];
     nargin = nargin - 1;
   else
     hl = [];
   endif
 
diff --git a/scripts/plot/draw/colorbar.m b/scripts/plot/draw/colorbar.m
--- a/scripts/plot/draw/colorbar.m
+++ b/scripts/plot/draw/colorbar.m
@@ -326,17 +326,17 @@ function update_colorbar_clim (hax, ~, h
     endif
   endif
 
 endfunction
 
 function update_colorbar_cmap (hf, d, hi, vert, init_sz)
   persistent sz = init_sz;
 
-  if (ishandle (hf) && strcmp (get (hf, "type"), "figure")
+  if (ishghandle (hf) && strcmp (get (hf, "type"), "figure")
       && (isempty (gcbf ()) || strcmp (get (gcbf (), "beingdeleted"), "off")))
     clen = rows (get (hf, "colormap"));
     if (clen != sz)
       if (vert)
         set (hi, "cdata", [1:clen]');
       else
         set (hi, "cdata", [1:clen]);
       endif
diff --git a/scripts/plot/draw/isocolors.m b/scripts/plot/draw/isocolors.m
--- a/scripts/plot/draw/isocolors.m
+++ b/scripts/plot/draw/isocolors.m
@@ -89,17 +89,17 @@ function cdat = isocolors (varargin)
       vp = varargin{7};
     otherwise
       print_usage ();
   endswitch
 
   if (isnumeric (vp) && columns (vp) == 3)
     pa = [];
     v = vp;
-  elseif (ishghandle (vp, "patch"))
+  elseif (isgraphics (vp, "patch"))
     pa = vp;
     v = get (pa, "Vertices");
   else
     error ("isocolors: last argument must be a vertex list or patch handle");
   endif
 
   if (calc_rgb)
     new_colors = zeros (rows (v), 3);
diff --git a/scripts/plot/draw/isonormals.m b/scripts/plot/draw/isonormals.m
--- a/scripts/plot/draw/isonormals.m
+++ b/scripts/plot/draw/isonormals.m
@@ -87,17 +87,17 @@ function vn = isonormals (varargin)
     otherwise
       print_usage ();
 
   endswitch
 
   if (isnumeric (vp) && columns (vp) == 3)
     pa = [];
     v = vp;
-  elseif (ishghandle (vp, "patch"))
+  elseif (isgraphics (vp, "patch"))
     pa = vp;
     v = get (pa, "Vertices");
   else
     error ("isonormals: input must be a list of vertices or a patch handle");
   endif
 
   if (negate)
     normals = __interp_cube__ ("isonormals", x, y, z, val, v, "normals");
diff --git a/scripts/plot/draw/plotmatrix.m b/scripts/plot/draw/plotmatrix.m
--- a/scripts/plot/draw/plotmatrix.m
+++ b/scripts/plot/draw/plotmatrix.m
@@ -116,17 +116,17 @@ endfunction
 
 function plotmatrixdelete (h, d, ax)
 
   for i = 1 : numel (ax)
     hc = ax(i);
     if (isaxes (hc) && strcmpi (get (hc, "beingdeleted"), "off"))
       parent = get (hc, "parent");
       ## If the parent is invalid or being deleted, then do nothing
-      if (ishandle (parent) && strcmpi (get (parent, "beingdeleted"), "off"))
+      if (ishghandle (parent) && strcmpi (get (parent, "beingdeleted"), "off"))
         delete (hc);
       endif
     endif
   endfor
 
 endfunction
 
 function [h, ax, p, pax] = __plotmatrix__ (bigax, varargin)
diff --git a/scripts/plot/draw/plotyy.m b/scripts/plot/draw/plotyy.m
--- a/scripts/plot/draw/plotyy.m
+++ b/scripts/plot/draw/plotyy.m
@@ -178,28 +178,28 @@ function [ax, h1, h2] = __plotyy__ (ax, 
   addlistener (ax(1), "plotboxaspectratio", {@update_position, ax(2)});
   addlistener (ax(2), "plotboxaspectratio", {@update_position, ax(1)});
   addlistener (ax(1), "plotboxaspectratiomode", {@update_position, ax(2)});
   addlistener (ax(2), "plotboxaspectratiomode", {@update_position, ax(1)});
   addlistener (ax(1), "nextplot", {@update_nextplot, ax(2)});
   addlistener (ax(2), "nextplot", {@update_nextplot, ax(1)});
 
   ## Store the axes handles for the sister axes.
-  if (ishandle (ax(1)) && ! isprop (ax(1), "__plotyy_axes__"))
+  if (ishghandle (ax(1)) && ! isprop (ax(1), "__plotyy_axes__"))
     addproperty ("__plotyy_axes__", ax(1), "data");
     set (ax(1), "__plotyy_axes__", ax);
-  elseif (ishandle (ax(1)))
+  elseif (ishghandle (ax(1)))
     set (ax(1), "__plotyy_axes__", ax);
   else
     error ("plotyy.m: This shouldn't happen.  File a bug report.");
   endif
-  if (ishandle (ax(2)) && ! isprop (ax(2), "__plotyy_axes__"))
+  if (ishghandle (ax(2)) && ! isprop (ax(2), "__plotyy_axes__"))
     addproperty ("__plotyy_axes__", ax(2), "data");
     set (ax(2), "__plotyy_axes__", ax);
-  elseif (ishandle (ax(2)))
+  elseif (ishghandle (ax(2)))
     set (ax(2), "__plotyy_axes__", ax);
   else
     error ("plotyy.m: This shouldn't happen.  File a bug report.");
   endif
 
 endfunction
 
 function deleteplotyy (h, ~, ax2, t2)
diff --git a/scripts/plot/draw/reducepatch.m b/scripts/plot/draw/reducepatch.m
--- a/scripts/plot/draw/reducepatch.m
+++ b/scripts/plot/draw/reducepatch.m
@@ -176,17 +176,17 @@ function [faces, vertices, max_faces, pa
       vertices = arg1.vertices;
       faces = arg1.faces;
     else
       error (["reducepatch: struct FV must contain the fields ", ...
               "'vertices' and 'faces'."]);
     endif
   elseif (isscalar (arg1))
     patch_handle = arg1;
-    if (ishghandle (patch_handle, "patch"))
+    if (isgraphics (patch_handle, "patch"))
       vertices = get (patch_handle, "Vertices");
       faces = get (patch_handle, "Faces");
     else
       error ("reducepatch: PATCH_HANDLE must be a valid handle to a patch");
     endif
   elseif (ismatrix (arg1))
     faces = arg1;
     if (nargin - num_string_inputs > 1 && ismatrix (varargin{2}))
diff --git a/scripts/plot/draw/shrinkfaces.m b/scripts/plot/draw/shrinkfaces.m
--- a/scripts/plot/draw/shrinkfaces.m
+++ b/scripts/plot/draw/shrinkfaces.m
@@ -71,17 +71,17 @@ function [nf, nv] = shrinkfaces (varargi
   if (nargin < 1 || nargin > 3 || nargout > 2)
     print_usage ();
   endif
 
   sf = 0.3;
   colors = [];
   p = varargin{1};
 
-  if (isscalar (p) && ishandle (p) && nargin < 3
+  if (isscalar (p) && ishghandle (p) && nargin < 3
       && strcmp (get (p, "type"), "patch"))
     faces = get (p, "Faces");
     vertices = get (p, "Vertices");
     colors = get (p, "FaceVertexCData");
     if (nargin == 2)
       sf = varargin{2};
     endif
   elseif (isstruct (p) && nargin < 3)
@@ -129,17 +129,17 @@ function [nf, nv] = shrinkfaces (varargi
   ## We have to deal with a possibly very large number of vertices, so use
   ## sparse as midpoint (1/m, ..., 1/m) in generalized barycentric coordinates.
   midpoints = full (kron (speye (sv / m), ones (m, m) / m) * sparse (v));
   v = sqrt (sf) * (v - midpoints) + midpoints;
   f = reshape (1:sv, m, sv / m)';
 
   switch (nargout)
     case 0
-      if (ishandle (p))
+      if (ishghandle (p))
         ## avoid exceptions
         set (p, "FaceVertexCData", [], "CData", []);
         set (p, "Vertices", v, "Faces", f, "FaceVertexCData", c);
       else
         nf = struct ("faces", f, "vertices", v, "facevertexcdata", c);
       endif
     case 1
       nf = struct ("faces", f, "vertices", v, "facevertexcdata", c);
diff --git a/scripts/plot/util/__actual_axis_position__.m b/scripts/plot/util/__actual_axis_position__.m
--- a/scripts/plot/util/__actual_axis_position__.m
+++ b/scripts/plot/util/__actual_axis_position__.m
@@ -21,17 +21,17 @@
 ## @deftypefnx {} {} __actual_axis_position__ (@var{axis_struct})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: Ben Abbott
 
 function pos = __actual_axis_position__ (h)
 
-  if (ishandle (h))
+  if (ishghandle (h))
     axis_obj = get (h);
   elseif (isstruct (h))
     axis_obj = h;
     h = axis_obj.__cbar_hax__;
   endif
 
   ## Get figure size in pixels
   orig_fig_units = get (axis_obj.parent, "units");
diff --git a/scripts/plot/util/__opengl_info__.m b/scripts/plot/util/__opengl_info__.m
--- a/scripts/plot/util/__opengl_info__.m
+++ b/scripts/plot/util/__opengl_info__.m
@@ -73,17 +73,17 @@ function retval = __opengl_info__ ()
   endif
 
 endfunction
 
 function info = fig_gl_info (h)
 
   info = [];
 
-  if (ishandle (h) && strcmp (get (h, "renderer"), "opengl"))
+  if (ishghandle (h) && strcmp (get (h, "renderer"), "opengl"))
     vend = get (h, "__gl_vendor__");
     if (isempty (vend))
       return;
     endif
     info.vendor   = vend;
     info.version  = get (h, "__gl_version__");
     info.renderer = get (h, "__gl_renderer__");
     info.extensions = strsplit (strtrim (get (h, "__gl_extensions__")));
diff --git a/scripts/plot/util/__plt_get_axis_arg__.m b/scripts/plot/util/__plt_get_axis_arg__.m
--- a/scripts/plot/util/__plt_get_axis_arg__.m
+++ b/scripts/plot/util/__plt_get_axis_arg__.m
@@ -26,28 +26,28 @@
 function [h, varargin, narg] = __plt_get_axis_arg__ (caller, varargin)
 
   h = [];
   parent = find (strcmpi (varargin, "parent"), 1);
 
   ## Look for a scalar which is a graphics handle but not the
   ## Root Figure (0) or an ordinary figure (integer).
   if (numel (varargin) > 0 && numel (varargin{1}) == 1
-      && ishandle (varargin{1}) && varargin{1} != 0 && ! isfigure (varargin{1}))
+      && ishghandle (varargin{1}) && varargin{1} != 0 && ! isfigure (varargin{1}))
     htmp = varargin{1};
     if (! isaxes (htmp))
       error ("%s: first argument must be axes handle", caller);
     endif
     if (! strcmp (get (htmp, "tag"), "legend"))
       h = htmp;
       varargin(1) = [];
     endif
   ## Look for "parent"/axis prop/value pair
   elseif (numel (varargin) > 1 && ! isempty (parent))
-    if (parent < numel (varargin) && ishandle (varargin{parent+1}))
+    if (parent < numel (varargin) && ishghandle (varargin{parent+1}))
       htmp = varargin{parent+1};
       if (isaxes (htmp) && ! strcmp (get (htmp, "tag"), "legend"))
         h = htmp;
         varargin(parent:parent+1) = [];
       else
         ## 'parent' property for some other type like hggroup
         h = [ancestor(htmp, "axes"), htmp];
       endif
diff --git a/scripts/plot/util/ancestor.m b/scripts/plot/util/ancestor.m
--- a/scripts/plot/util/ancestor.m
+++ b/scripts/plot/util/ancestor.m
@@ -56,17 +56,17 @@ function p = ancestor (h, type, toplevel
 
   if (isempty (h))
     p = [];
   else
     p = cell (numel (h), 1);
     h = num2cell (h);
     for nh = 1:numel (h)
       while (true)
-        if (isempty (h{nh}) || ! ishandle (h{nh}))
+        if (isempty (h{nh}) || ! ishghandle (h{nh}))
           break;
         endif
         if (any (strcmpi (get (h{nh}, "type"), type)))
           p{nh} = h{nh};
           if (find_first)
             break;
           endif
         endif
diff --git a/scripts/plot/util/copyobj.m b/scripts/plot/util/copyobj.m
--- a/scripts/plot/util/copyobj.m
+++ b/scripts/plot/util/copyobj.m
@@ -39,19 +39,19 @@
 ## Created: 2012-04-01
 
 function hnew = copyobj (horig, hparent = 0)
 
   partypes = {"root", "figure", "axes", "hggroup"};
   othertypes = {"line", "patch", "surface", "image", "text"};
   alltypes = [partypes othertypes];
 
-  if (! ishandle (horig) || nargin > 2)
+  if (! ishghandle (horig) || nargin > 2)
     print_usage ();
-  elseif (! ishandle (hparent))
+  elseif (! ishghandle (hparent))
     hparent = figure (fix (hparent));
   else
     for hp = hparent(:)'
       if (! any (strcmpi (get (hp, "type"), partypes)))
         print_usage ();
       endif
     endfor
   endif
diff --git a/scripts/plot/util/findobj.m b/scripts/plot/util/findobj.m
--- a/scripts/plot/util/findobj.m
+++ b/scripts/plot/util/findobj.m
@@ -91,17 +91,17 @@
 function h = findobj (varargin)
 
   depth = NaN;
   if (nargin == 0)
     handles = 0;
     n1 = 0;
   else
     if (! isempty (varargin{1}))
-      if (ishandle (varargin{1}(1)))
+      if (ishghandle (varargin{1}(1)))
         handles = varargin{1};
         n1 = 2;
       else
         handles = 0;
         n1 = 1;
       endif
     else
       ## Return [](0x1) for compatibility.
diff --git a/scripts/plot/util/hdl2struct.m b/scripts/plot/util/hdl2struct.m
--- a/scripts/plot/util/hdl2struct.m
+++ b/scripts/plot/util/hdl2struct.m
@@ -26,17 +26,17 @@
 ## @seealso{struct2hdl, hgsave, findobj}
 ## @end deftypefn
 
 ## Author: pdiribarne <pdiribarne@new-host.home>
 ## Created: 2012-03-04
 
 function s = hdl2struct (h)
 
-  if (nargin != 1 || ! ishandle (h))
+  if (nargin != 1 || ! ishghandle (h))
     print_usage ();
   endif
 
   hiddenh = get (0, "showhiddenhandles");
   unwind_protect
     set (0, "showhiddenhandles", "off");
 
     ## main object
diff --git a/scripts/plot/util/hgsave.m b/scripts/plot/util/hgsave.m
--- a/scripts/plot/util/hgsave.m
+++ b/scripts/plot/util/hgsave.m
@@ -60,17 +60,17 @@ function hgsave (h, filename, fmt = "-bi
 
   ## Check input arguments
   if (nargin == 1 && ischar (h))
     filename = h;
     h = get (0, "currentfigure");
     if (isempty (h))
       error ("hgsave: No current figure to save");
     endif
-  elseif (! (ishandle (h) && ischar (filename)))
+  elseif (! (ishghandle (h) && ischar (filename)))
     print_usage ();
   endif
 
   ## Check file extension
   [~, ~, ext] = fileparts (filename);
   if (isempty (ext))
     filename = [filename ".ofig"];
   endif
diff --git a/scripts/plot/util/hold.m b/scripts/plot/util/hold.m
--- a/scripts/plot/util/hold.m
+++ b/scripts/plot/util/hold.m
@@ -51,17 +51,17 @@
 
 function hold (varargin)
 
   if (nargin > 0 && isscalar (varargin{1}) && isaxes (varargin{1}))
     hax = varargin{1};
     varargin(1) = [];
     nargs = numel (varargin);
     hfig = ancestor (hax, "figure");
-  elseif (nargin > 0 && numel (varargin{1}) > 1 && ishandle (varargin{1}))
+  elseif (nargin > 0 && numel (varargin{1}) > 1 && ishghandle (varargin{1}))
     print_usage ();
   else
     hax = gca ();
     hfig = gcf ();
     nargs = numel (varargin);
   endif
 
   hold_all = false;
diff --git a/scripts/plot/util/isaxes.m b/scripts/plot/util/isaxes.m
--- a/scripts/plot/util/isaxes.m
+++ b/scripts/plot/util/isaxes.m
@@ -17,28 +17,28 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} isaxes (@var{h})
 ## Return true if @var{h} is an axes graphics handle and false otherwise.
 ##
 ## If @var{h} is a matrix then return a logical array which is true where the
 ## elements of @var{h} are axes graphics handles and false where they are not.
-## @seealso{isaxes, ishandle}
+## @seealso{isaxes, ishghandle}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = isaxes (h)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  hlist = ishandle (h);
+  hlist = ishghandle (h);
   retval = hlist;
 
   if (any (hlist))
     retval(hlist) = strcmp (get (h(hlist), "type"), "axes");
   endif
 
 endfunction
 
diff --git a/scripts/plot/util/isfigure.m b/scripts/plot/util/isfigure.m
--- a/scripts/plot/util/isfigure.m
+++ b/scripts/plot/util/isfigure.m
@@ -18,28 +18,28 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {} {} isfigure (@var{h})
 ## Return true if @var{h} is a figure graphics handle and false otherwise.
 ##
 ## If @var{h} is a matrix then return a logical array which is true where the
 ## elements of @var{h} are figure graphics handles and false where they are
 ## not.
-## @seealso{isaxes, ishandle}
+## @seealso{isaxes, ishghandle}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = isfigure (h)
 
   if (nargin != 1)
     print_usage ();
   endif
 
-  hlist = ishandle (h);
+  hlist = ishghandle (h);
   if (any (hlist))
     retval(hlist) = strcmp (get (h(hlist), "type"), "figure");
   else
     retval = hlist;
   endif
 
 endfunction
 
diff --git a/scripts/plot/util/ishghandle.m b/scripts/plot/util/isgraphics.m
rename from scripts/plot/util/ishghandle.m
rename to scripts/plot/util/isgraphics.m
--- a/scripts/plot/util/ishghandle.m
+++ b/scripts/plot/util/isgraphics.m
@@ -12,95 +12,95 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {} {} ishghandle (@var{h})
-## @deftypefnx {} {} ishghandle (@var{h}, @var{type})
+## @deftypefn  {} {} isgraphics (@var{h})
+## @deftypefnx {} {} isgraphics (@var{h}, @var{type})
 ## Return true if @var{h} is a graphics handle (of type @var{type}) and false
 ## otherwise.
 ##
 ## When no @var{type} is specified the function is equivalent to
-## @code{ishandle}.
-## @seealso{ishandle}
+## @code{ishghandle}.
+## @seealso{ishghandle, ishandle}
 ## @end deftypefn
 
-function retval = ishghandle (h, type = "")
+function retval = isgraphics (h, type = "")
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (nargin == 2 && (! ischar (type) || ! isrow (type)))
-    error ("ishghandle: TYPE must be a string");
+    error ("isgraphics: TYPE must be a string");
   endif
 
-  ## Octave has no Simulink equivalent so it is sufficient to call ishandle.
-  retval = ishandle (h);
+  ## Octave has no Simulink equivalent so it is sufficient to call ishghandle.
+  retval = ishghandle (h);
 
   if (nargin == 2 && any (retval))
     typematch = strcmpi (get (h(retval), "type"), type);
     retval(retval) = typematch;
   endif
 
 endfunction
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   assert (ishghandle (hf));
-%!   assert (ishghandle (hf, "figure"));
-%!   assert (! ishghandle (-hf));
-%!   assert (! ishghandle (hf, "foo"));
+%!   assert (isgraphics (hf));
+%!   assert (isgraphics (hf, "figure"));
+%!   assert (! isgraphics (-hf));
+%!   assert (! isgraphics (hf, "foo"));
 %!   l = line;
 %!   ax = gca;
-%!   assert (ishghandle (ax));
-%!   assert (ishghandle (ax, "axes"));
-%!   assert (! ishghandle (-ax));
-%!   assert (! ishghandle (ax, "foo"));
-%!   assert (ishghandle (l));
-%!   assert (ishghandle (l, "line"));
-%!   assert (! ishghandle (-l));
-%!   assert (! ishghandle (l, "foo"));
+%!   assert (isgraphics (ax));
+%!   assert (isgraphics (ax, "axes"));
+%!   assert (! isgraphics (-ax));
+%!   assert (! isgraphics (ax, "foo"));
+%!   assert (isgraphics (l));
+%!   assert (isgraphics (l, "line"));
+%!   assert (! isgraphics (-l));
+%!   assert (! isgraphics (l, "foo"));
 %!   p = patch;
-%!   assert (ishghandle (p));
-%!   assert (ishghandle (p, "patch"));
-%!   assert (! ishghandle (-p));
-%!   assert (! ishghandle (p, "foo"));
+%!   assert (isgraphics (p));
+%!   assert (isgraphics (p, "patch"));
+%!   assert (! isgraphics (-p));
+%!   assert (! isgraphics (p, "foo"));
 %!   s = surface;
-%!   assert (ishghandle (s));
-%!   assert (ishghandle (s, "surface"));
-%!   assert (! ishghandle (-s));
-%!   assert (! ishghandle (s, "foo"));
+%!   assert (isgraphics (s));
+%!   assert (isgraphics (s, "surface"));
+%!   assert (! isgraphics (-s));
+%!   assert (! isgraphics (s, "foo"));
 %!   t = text;
-%!   assert (ishghandle (t));
-%!   assert (ishghandle (t, "text"));
-%!   assert (! ishghandle (-t));
-%!   assert (! ishghandle (t, "foo"));
+%!   assert (isgraphics (t));
+%!   assert (isgraphics (t, "text"));
+%!   assert (! isgraphics (-t));
+%!   assert (! isgraphics (t, "foo"));
 %!   i = image ([1]);
-%!   assert (ishghandle (i));
-%!   assert (ishghandle (i, "image"));
-%!   assert (! ishghandle (-i));
-%!   assert (! ishghandle (i, "foo"));
+%!   assert (isgraphics (i));
+%!   assert (isgraphics (i, "image"));
+%!   assert (! isgraphics (-i));
+%!   assert (! isgraphics (i, "foo"));
 %!   hg = hggroup;
-%!   assert (ishghandle (hg));
-%!   assert (ishghandle (hg, "hggroup"));
-%!   assert (! ishghandle (-hg));
-%!   assert (! ishghandle (hg, "foo"));
+%!   assert (isgraphics (hg));
+%!   assert (isgraphics (hg, "hggroup"));
+%!   assert (! isgraphics (-hg));
+%!   assert (! isgraphics (hg, "foo"));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
-%! assert (ishghandle ([-1 0]), [false true]);
-%! assert (ishghandle ([-1 0], "root"), [false true]);
-%! assert (ishghandle ([-1 0], "foobar"), [false false]);
+%! assert (isgraphics ([-1 0]), [false true]);
+%! assert (isgraphics ([-1 0], "root"), [false true]);
+%! assert (isgraphics ([-1 0], "foobar"), [false false]);
 
 ## Test input validation
-%!error ishghandle ()
-%!error ishghandle (1, 2, 3)
-%!error <TYPE must be a string> ishghandle (0, 1)
-%!error <TYPE must be a string> ishghandle (0, {1})
+%!error isgraphics ()
+%!error isgraphics (1, 2, 3)
+%!error <TYPE must be a string> isgraphics (0, 1)
+%!error <TYPE must be a string> isgraphics (0, {1})
diff --git a/scripts/plot/util/ishandle.m b/scripts/plot/util/ishandle.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/util/ishandle.m
@@ -0,0 +1,69 @@
+## Copyright (C) 2017 Rik Wehbring
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or
+## (at your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+## GNU General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {} {} ishandle (@var{h})
+## Return true if @var{h} is a handle to a graphics or Java object and false
+## otherwise.
+##
+## @var{h} may also be a matrix of handles in which case a logical array is
+## returned that is true where the elements of @var{h} are handles to graphics
+## or Java objects and false where they are not.
+##
+## Programming Note: It is often more useful to test for a specific object
+## type.  To determine if a handle belongs to a graphics object use
+## @code{ishghandle} or @code{isgraphics}.  To determine if a handle belongs
+## to a Java object use @code{isjava}.
+## @seealso{ishghandle, isgraphics, isjava}
+## @end deftypefn
+
+function retval = ishandle (h)
+
+  if (nargin != 1)
+    print_usage ();
+  endif
+
+  retval = ishghandle (h) | isjava (h);
+
+endfunction
+
+
+%!test
+%! hf = figure ("visible", "off");
+%! unwind_protect
+%!   assert (ishandle (hf));
+%!   assert (! ishandle (-hf));
+%!   ax = gca;
+%!   l = line;
+%!   assert (ishandle (ax));
+%!   assert (! ishandle (-ax));
+%!   assert (ishandle ([l, -1, ax, hf]), logical ([1, 0, 1, 1]));
+%!   assert (ishandle ([l, -1, ax, hf]'), logical ([1, 0, 1, 1]'));
+%! unwind_protect_cleanup
+%!   close (hf);
+%! end_unwind_protect
+
+%!assert (ishandle ([-1 0]), [false true])
+
+%!testif HAVE_JAVA; usejava ("jvm")
+%! jobj = javaObject ("java.lang.Double", 1.0);
+%! assert (ishandle (jobj));
+
+## Test input validation
+%!error ishandle ()
+%!error ishandle (1, 2)
diff --git a/scripts/plot/util/ishold.m b/scripts/plot/util/ishold.m
--- a/scripts/plot/util/ishold.m
+++ b/scripts/plot/util/ishold.m
@@ -33,17 +33,17 @@ function retval = ishold (h)
   if (nargin > 1)
     print_usage ();
   endif
 
   if (nargin == 0)
     fig = gcf ();
     ax = get (fig, "currentaxes");
   else
-    if (! ishandle (h))
+    if (! ishghandle (h))
       error ("ishold: H must be an axes or figure graphics handle");
     endif
 
     switch (get (h, "type"))
       case "figure"
         fig = h;
         ax = get (fig, "currentaxes");
 
diff --git a/scripts/plot/util/isprop.m b/scripts/plot/util/isprop.m
--- a/scripts/plot/util/isprop.m
+++ b/scripts/plot/util/isprop.m
@@ -35,17 +35,17 @@ function res = isprop (obj, prop)
   if (nargin != 2)
     print_usage ();
   elseif (! ischar (prop))
     error ("isprop: PROP name must be a string");
   endif
 
   res = false (size (obj));
   for i = 1:numel (res)
-    if (ishandle (obj(i)))
+    if (ishghandle (obj(i)))
       try
         v = get (obj(i), prop);
         res(i) = true;
       end_try_catch
     endif
   endfor
 
 endfunction
diff --git a/scripts/plot/util/linkprop.m b/scripts/plot/util/linkprop.m
--- a/scripts/plot/util/linkprop.m
+++ b/scripts/plot/util/linkprop.m
@@ -57,17 +57,17 @@
 function hlink = linkprop (h, prop)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   if (numel (h) < 2)
     error ("linkprop: H must contain at least 2 handles");
-  elseif (! all (ishandle (h(:))))
+  elseif (! all (ishghandle (h(:))))
     error ("linkprop: invalid graphic handle in input H");
   endif
 
   if (ischar (prop))
     prop = {prop};
   elseif (! iscellstr (prop))
     error ("linkprop: PROP must be a string or cell string array");
   endif
@@ -92,28 +92,28 @@ endfunction
 
 function update_prop (h, ~, hlist, prop)
   persistent recursion = false;
 
   ## Don't allow recursion
   if (! recursion)
     unwind_protect
       recursion = true;
-      set (hlist(ishandle (hlist)), prop, get (h, prop));
+      set (hlist(ishghandle (hlist)), prop, get (h, prop));
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
   endif
 
 endfunction
 
 function delete_linkprop (hlist, prop)
 
   for i = 1 : numel (hlist)
-    if (ishandle (hlist(i)))
+    if (ishghandle (hlist(i)))
       for j = 1 : numel (prop)
         dellistener (hlist(i), prop{j});
       endfor
     endif
   endfor
 
 endfunction
 
diff --git a/scripts/plot/util/module.mk b/scripts/plot/util/module.mk
--- a/scripts/plot/util/module.mk
+++ b/scripts/plot/util/module.mk
@@ -55,17 +55,18 @@ GEN_FCN_FILES += $(%canon_reldir%_GEN_FC
   %reldir%/hdl2struct.m \
   %reldir%/hggroup.m \
   %reldir%/hgload.m \
   %reldir%/hgsave.m \
   %reldir%/hgtransform.m \
   %reldir%/hold.m \
   %reldir%/isaxes.m \
   %reldir%/isfigure.m \
-  %reldir%/ishghandle.m \
+  %reldir%/isgraphics.m \
+  %reldir%/ishandle.m \
   %reldir%/ishold.m \
   %reldir%/isprop.m \
   %reldir%/linkaxes.m \
   %reldir%/linkprop.m \
   %reldir%/meshgrid.m \
   %reldir%/ndgrid.m \
   %reldir%/newplot.m \
   %reldir%/pan.m \
diff --git a/scripts/plot/util/newplot.m b/scripts/plot/util/newplot.m
--- a/scripts/plot/util/newplot.m
+++ b/scripts/plot/util/newplot.m
@@ -239,26 +239,26 @@ endfunction
 %!   hold on;
 %!   hg1 = hggroup ();
 %!   hg2 = hggroup ("parent", hg1);
 %!   li0 = line (1:10, 1:10);
 %!   li1 = line (1:10, -1:-1:-10, "parent", hg1);
 %!   li2 = line (1:10, sin (1:10), "parent", hg2);
 %!   hold off;
 %!   newplot (hg2);
-%!   assert (ishandle (li0), false);
+%!   assert (ishghandle (li0), false);
 %!   assert (get (hax, "children"), hg1);
 %!
 %!   ## kids are preserved for hggroups
 %!   kids = get (hg1, "children");
 %!   newplot (hg1);
 %!   assert (get (hg1, "children"), kids);
 %!
 %!   ## preserve objects
 %!   newplot (li1);
-%!   assert (ishandle (li1));
+%!   assert (ishghandle (li1));
 %!
 %!   ## kids are deleted for axes
 %!   newplot (hax);
 %!   assert (isempty (get (hax, "children")));
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
diff --git a/scripts/plot/util/print.m b/scripts/plot/util/print.m
--- a/scripts/plot/util/print.m
+++ b/scripts/plot/util/print.m
@@ -480,17 +480,17 @@ function print (varargin)
     if (opts.use_color < 0)
       color_props = {"color", "facecolor", "edgecolor", "colormap"};
       for c = 1:numel (color_props)
         h = findall (opts.figure, "-property", color_props{c});
         hnone = findall (opts.figure, color_props{c}, "none");
         h = setdiff (h, hnone);
         m = numel (props);
         for n = 1:numel (h)
-          if (ishandle (h(n)))
+          if (ishghandle (h(n)))
             ## Need to verify objects exist since callbacks may delete objects
             ## as the colors for others are modified.
             rgb = get (h(n), color_props{c});
             props(end+1).h = h(n);
             props(end).name = color_props{c};
             props(end).value = {get(h(n), color_props{c})};
             if (isnumeric (rgb))
               ## convert RGB color to RGB gray scale
@@ -502,47 +502,47 @@ function print (varargin)
         endfor
       endfor
     endif
 
     if (! isempty (opts.font) || ! isempty (opts.fontsize))
       h = findall (opts.figure, "-property", "fontname");
       m = numel (props);
       for n = 1:numel (h)
-        if (ishandle (h(n)))
+        if (ishghandle (h(n)))
           if (! isempty (opts.font))
             props(end+1).h = h(n);
             props(end).name = "fontname";
             props(end).value = {get(h(n), "fontname")};
           endif
         endif
-        if (ishandle (h(n)))
+        if (ishghandle (h(n)))
           if (! isempty (opts.fontsize))
             props(end+1).h = h(n);
             props(end).name = "fontsize";
             props(end).value = {get(h(n), "fontsize")};
           endif
         endif
       endfor
       if (! isempty (opts.font))
-        set (h(ishandle (h)), "fontname", opts.font);
+        set (h(ishghandle (h)), "fontname", opts.font);
       endif
       if (! isempty (opts.fontsize))
         if (ischar (opts.fontsize))
           fontsize = str2double (opts.fontsize);
         else
           fontsize = opts.fontsize;
         endif
         if (! isempty (opts.scalefontsize) && ! opts.scalefontsize != 1)
           ## This is done to work around the bbox being whole numbers.
           fontsize *= opts.scalefontsize;
         endif
         ## FIXME: legend child objects need to be acted on first.
         ##        or legend fontsize callback will destroy them.
-        hlist = h(ishandle (h));
+        hlist = h(ishghandle (h));
         haxes = strcmp (get (hlist, "type"), "axes");
         set (hlist(! haxes), "fontsize", fontsize);
         set (hlist(haxes), "fontsize", fontsize);
       endif
     endif
 
     ## call the graphics toolkit print script
     switch (tk)
@@ -552,22 +552,22 @@ function print (varargin)
         opts = __opengl_print__ (opts);
     endswitch
 
   unwind_protect_cleanup
     ## restore modified properties
     if (isstruct (props))
       ## Restore figure position and units first
       for n = nfig:-1:1
-        if (ishandle (props(n).h))
+        if (ishghandle (props(n).h))
           set (props(n).h, props(n).name, props(n).value{1});
         endif
       endfor
       for n = numel (props):-1:(nfig + 1)
-        if (ishandle (props(n).h))
+        if (ishghandle (props(n).h))
           set (props(n).h, props(n).name, props(n).value{1});
         endif
       endfor
     endif
 
     ## Unlink temporary files
     for n = 1:numel (opts.unlink)
       [status, output] = unlink (opts.unlink{n});
diff --git a/scripts/plot/util/private/__gnuplot_draw_axes__.m b/scripts/plot/util/private/__gnuplot_draw_axes__.m
--- a/scripts/plot/util/private/__gnuplot_draw_axes__.m
+++ b/scripts/plot/util/private/__gnuplot_draw_axes__.m
@@ -35,21 +35,21 @@ function __gnuplot_draw_axes__ (h, plot_
   end_unwind_protect
 
   parent_figure_obj = get (axis_obj.parent);
   gnuplot_term = __gnuplot_get_var__ (axis_obj.parent, "GPVAL_TERM");
 
   ## Set to false for plotyy axes.
   ymirror = true;
   if (isfield (axis_obj, "__plotyy_axes__"))
-    if (all (ishandle (axis_obj.__plotyy_axes__)))
+    if (all (ishghandle (axis_obj.__plotyy_axes__)))
       ymirror = false;
     else
       h = axis_obj.__plotyy_axes__;
-      h = h(ishandle (h));
+      h = h(ishghandle (h));
       h = h(isprop (h, "__plotyy_axes__"));
       rmappdata (h, "__plotyy_axes__");
     endif
   endif
 
   nd = __calc_dimensions__ (h);
 
   if (strcmp (axis_obj.dataaspectratiomode, "manual")
diff --git a/scripts/plot/util/private/__gnuplot_draw_figure__.m b/scripts/plot/util/private/__gnuplot_draw_figure__.m
--- a/scripts/plot/util/private/__gnuplot_draw_figure__.m
+++ b/scripts/plot/util/private/__gnuplot_draw_figure__.m
@@ -153,17 +153,17 @@ function __gnuplot_draw_figure__ (h, plo
                 if (bg_is_set)
                   fprintf (plot_stream, ['set border linecolor rgb "#%02x%02x%02x"' "\n"], round (255 * (1 - bg)));
                 endif
                 ## Find if this axes has an associated legend axes and pass it
                 ## to __gnuplot_draw_axes__
                 hlegend = [];
                 fkids = get (h, "children");
                 for j = 1 : numel (fkids)
-                  if (ishandle (fkids (j))
+                  if (ishghandle (fkids (j))
                       && strcmp (get (fkids (j), "type"), "axes")
                       && (strcmp (get (fkids (j), "tag"), "legend")))
                     udata = get (fkids (j), "userdata");
                     if (isscalar (udata.handle)
                         && ! isempty (intersect (udata.handle, kids (i))))
                       hlegend = get (fkids (j));
                       break;
                     endif
diff --git a/scripts/plot/util/rotate.m b/scripts/plot/util/rotate.m
--- a/scripts/plot/util/rotate.m
+++ b/scripts/plot/util/rotate.m
@@ -37,17 +37,17 @@ function rotate (h, direction, alpha, or
   ## Note in doc string about compatibility issues with calculation of
   ## default origin due to possible differences in the auto-scaling
   ## algorithm between Octave and Matlab.
 
   if (nargin < 3 || nargin > 4)
     print_usage ();
   endif
 
-  is_h = ishandle (h);
+  is_h = ishghandle (h);
   if (is_h)
     ax_list = get (h, "parent");
     if (iscell (ax_list))
       ax_list = cell2mat (ax_list);
     endif
     if (ax_list == ax_list(1))
       ax = ax_list(1);
     else
diff --git a/scripts/plot/util/saveas.m b/scripts/plot/util/saveas.m
--- a/scripts/plot/util/saveas.m
+++ b/scripts/plot/util/saveas.m
@@ -64,17 +64,17 @@
 ## Author: Kai Habel
 
 function saveas (h, filename, fmt)
 
   if (nargin != 2 && nargin != 3)
     print_usage ();
   endif
 
-  if (! ishandle (h))
+  if (! ishghandle (h))
     error ("saveas: H must be a graphics handle");
   endif
   if (! ischar (filename))
     error ("saveas: FILENAME must be a string");
   endif
 
   if (isfigure (h))
     fig = h;
diff --git a/scripts/plot/util/struct2hdl.m b/scripts/plot/util/struct2hdl.m
--- a/scripts/plot/util/struct2hdl.m
+++ b/scripts/plot/util/struct2hdl.m
@@ -46,17 +46,17 @@ function [h, pout] = struct2hdl (s, p=[]
   othertypes = {"line", "patch", "surface", "image", "text"};
   alltypes = [partypes othertypes];
 
   if (nargin > 3 || ! isstruct (s))
     print_usage ();
   elseif (! all (isfield (s, fields)))
     print_usage ();
   elseif (isscalar (p))
-    if (! ishandle (p))
+    if (! ishghandle (p))
       error ("struct2hdl: P is not a handle to a graphic object");
     endif
     if (any (strcmp (get (p).type, partypes)))
       paridx = find (strcmp (get (p).type, alltypes));
       kididx = find (strcmp (s.type, alltypes));
       if (kididx <= paridx)
         error ("struct2hdl: incompatible input handles");
       endif
diff --git a/scripts/plot/util/subplot.m b/scripts/plot/util/subplot.m
--- a/scripts/plot/util/subplot.m
+++ b/scripts/plot/util/subplot.m
@@ -227,17 +227,17 @@ function h = subplot (varargin)
     if (! make_subplot)
       found = false;
       kids = get (cf, "children");
       for child = kids(:)'
         ## Check whether this child is still valid; this might not be the
         ## case anymore due to the deletion of previous children (due to
         ## "deletefcn" callback or for legends/colorbars that are deleted
         ## with their corresponding axes).
-        if (! ishandle (child))
+        if (! ishghandle (child))
           continue;
         endif
         if (strcmp (get (child, "type"), "axes"))
           ## Skip legend and colorbar objects.
           if (any (strcmp (get (child, "tag"), {"legend", "colorbar"})))
             continue;
           endif
 
@@ -574,43 +574,43 @@ endfunction
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   for ii = 1:9
 %!     hax(ii) = subplot (3,3,ii);
 %!   endfor
 %!   subplot (3,3,1);
 %!   assert (gca (), hax(1));
 %!   subplot (2,1,1);
-%!   assert (ishandle (hax),[false(1,6), true(1,3)]);
+%!   assert (ishghandle (hax),[false(1,6), true(1,3)]);
 %! unwind_protect_cleanup
 %!   delete (hf);
 %! end_unwind_protect
 
 ## Position mode
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h1 = subplot ("position", [0.1 0.1 0.3 0.3]);
 %!   h2 = subplot ("position", [0.5 0.5 0.3 0.3]);
 %!   subplot ("position", [0.1 0.1 0.3 0.3]);
 %!   assert (gca (), h1);
 %!   subplot ("position", [0.5 0.5 0.3 0.3]);
 %!   assert (gca (), h2);
 %!   subplot ("position", [0.5 0.5 0.3 0.2]);
-%!   assert (! ishandle (h2));
+%!   assert (! ishghandle (h2));
 %! unwind_protect_cleanup
 %!   delete (hf);
 %! end_unwind_protect
 
 ## Align mode
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h1 = subplot (3,5,1, "align");
 %!   h2 = subplot (3,5,2, "align");
 %!   subplot (3,5,1, "align");
 %!   assert (gca (), h1);
 %!   subplot (3,2,1, "align");
-%!   assert (! ishandle (h1));
-%!   assert (! ishandle (h2));
+%!   assert (! ishghandle (h1));
+%!   assert (! ishghandle (h2));
 %! unwind_protect_cleanup
 %!   delete (hf);
 %! end_unwind_protect
