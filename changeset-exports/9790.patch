# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1257768589 -3600
#      Mon Nov 09 13:09:49 2009 +0100
# Node ID a5035bc7fbfbc7504f9baa8c893a4b7025b5c9e0
# Parent  97f5de91427b4d465b11467e464f5886530564b1
rewrite dispatch part & slightly improve min,max,cummin,cummax

diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -82,27 +82,27 @@ public:
   ComplexNDArray cumsum (int dim = -1) const;
   ComplexNDArray prod (int dim = -1) const;
   ComplexNDArray sum (int dim = -1) const;
   ComplexNDArray xsum (int dim = -1) const;
   ComplexNDArray sumsq (int dim = -1) const;
   ComplexNDArray concat (const ComplexNDArray& rb, const Array<octave_idx_type>& ra_idx);
   ComplexNDArray concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx);
 
-  ComplexNDArray max (int dim = 0) const;
-  ComplexNDArray max (Array<octave_idx_type>& index, int dim = 0) const;
-  ComplexNDArray min (int dim = 0) const;
-  ComplexNDArray min (Array<octave_idx_type>& index, int dim = 0) const;
+  ComplexNDArray max (int dim = -1) const;
+  ComplexNDArray max (Array<octave_idx_type>& index, int dim = -1) const;
+  ComplexNDArray min (int dim = -1) const;
+  ComplexNDArray min (Array<octave_idx_type>& index, int dim = -1) const;
 
-  ComplexNDArray cummax (int dim = 0) const;
-  ComplexNDArray cummax (Array<octave_idx_type>& index, int dim = 0) const;
-  ComplexNDArray cummin (int dim = 0) const;
-  ComplexNDArray cummin (Array<octave_idx_type>& index, int dim = 0) const;
+  ComplexNDArray cummax (int dim = -1) const;
+  ComplexNDArray cummax (Array<octave_idx_type>& index, int dim = -1) const;
+  ComplexNDArray cummin (int dim = -1) const;
+  ComplexNDArray cummin (Array<octave_idx_type>& index, int dim = -1) const;
 
-  ComplexNDArray diff (octave_idx_type order = 1, int dim = 0) const;
+  ComplexNDArray diff (octave_idx_type order = 1, int dim = -1) const;
 
   ComplexNDArray& insert (const NDArray& a, octave_idx_type r, octave_idx_type c);
   ComplexNDArray& insert (const ComplexNDArray& a, octave_idx_type r, octave_idx_type c);
   ComplexNDArray& insert (const ComplexNDArray& a, const Array<octave_idx_type>& ra_idx);
   
   NDArray abs (void) const;
   boolNDArray isnan (void) const;
   boolNDArray isinf (void) const;
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -238,35 +238,38 @@ SparseComplexMatrix::is_hermitian (void)
   return false;
 }
 
 static const Complex Complex_NaN_result (octave_NaN, octave_NaN);
 
 SparseComplexMatrix
 SparseComplexMatrix::max (int dim) const
 {
-  Array2<octave_idx_type> dummy_idx;
+  Array<octave_idx_type> dummy_idx;
   return max (dummy_idx, dim);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::max (Array2<octave_idx_type>& idx_arg, int dim) const
+SparseComplexMatrix::max (Array<octave_idx_type>& idx_arg, int dim) const
 {
   SparseComplexMatrix result;
   dim_vector dv = dims ();
 
-  if (dv.numel () == 0 || dim > dv.length () || dim < 0)
+  if (dv.numel () == 0 || dim >= dv.length ())
     return result;
  
+  if (dim < 0)
+    dim = dv.first_non_singleton ();
+
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv(1);
 
   if (dim == 0)
     {
-      idx_arg.resize (1, nc);
+      idx_arg.clear (1, nc);
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  Complex tmp_max;
 	  double abs_max = octave_NaN;
 	  octave_idx_type idx_j = 0;
 	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
@@ -316,17 +319,17 @@ SparseComplexMatrix::max (Array2<octave_
 	      result.xdata (ii) = tmp;
 	      result.xridx (ii++) = 0;
 	    }
 	  result.xcidx (j+1) = ii;
 	}
     }
   else
     {
-      idx_arg.resize (nr, 1, 0);
+      idx_arg.resize_fill (nr, 1, 0);
 
       for (octave_idx_type i = cidx(0); i < cidx(1); i++)
 	idx_arg.elem(ridx(i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    if (idx_arg.elem(i) != -1)
@@ -390,35 +393,38 @@ SparseComplexMatrix::max (Array2<octave_
     }
 
   return result;
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::min (int dim) const
 {
-  Array2<octave_idx_type> dummy_idx;
+  Array<octave_idx_type> dummy_idx;
   return min (dummy_idx, dim);
 }
 
 SparseComplexMatrix
-SparseComplexMatrix::min (Array2<octave_idx_type>& idx_arg, int dim) const
+SparseComplexMatrix::min (Array<octave_idx_type>& idx_arg, int dim) const
 {
   SparseComplexMatrix result;
   dim_vector dv = dims ();
 
-  if (dv.numel () == 0 || dim > dv.length () || dim < 0)
+  if (dv.numel () == 0 || dim >= dv.length ())
     return result;
  
+  if (dim < 0)
+    dim = dv.first_non_singleton ();
+
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv(1);
 
   if (dim == 0)
     {
-      idx_arg.resize (1, nc);
+      idx_arg.clear (1, nc);
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  Complex tmp_min;
 	  double abs_min = octave_NaN;
 	  octave_idx_type idx_j = 0;
 	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
@@ -468,17 +474,17 @@ SparseComplexMatrix::min (Array2<octave_
 	      result.xdata (ii) = tmp;
 	      result.xridx (ii++) = 0;
 	    }
 	  result.xcidx (j+1) = ii;
 	}
     }
   else
     {
-      idx_arg.resize (nr, 1, 0);
+      idx_arg.resize_fill (nr, 1, 0);
 
       for (octave_idx_type i = cidx(0); i < cidx(1); i++)
 	idx_arg.elem(ridx(i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    if (idx_arg.elem(i) != -1)
diff --git a/liboctave/CSparse.h b/liboctave/CSparse.h
--- a/liboctave/CSparse.h
+++ b/liboctave/CSparse.h
@@ -104,20 +104,20 @@ public:
       return *this;
     }
 
   bool operator == (const SparseComplexMatrix& a) const;
   bool operator != (const SparseComplexMatrix& a) const;
 
   bool is_hermitian (void) const;
 
-  SparseComplexMatrix max (int dim = 0) const;
-  SparseComplexMatrix max (Array2<octave_idx_type>& index, int dim = 0) const;
-  SparseComplexMatrix min (int dim = 0) const;
-  SparseComplexMatrix min (Array2<octave_idx_type>& index, int dim = 0) const;
+  SparseComplexMatrix max (int dim = -1) const;
+  SparseComplexMatrix max (Array<octave_idx_type>& index, int dim = -1) const;
+  SparseComplexMatrix min (int dim = -1) const;
+  SparseComplexMatrix min (Array<octave_idx_type>& index, int dim = -1) const;
 
   SparseComplexMatrix& insert (const SparseComplexMatrix& a, octave_idx_type r, octave_idx_type c);
   SparseComplexMatrix& insert (const SparseMatrix& a, octave_idx_type r, octave_idx_type c);
   SparseComplexMatrix& insert (const SparseComplexMatrix& a, const Array<octave_idx_type>& indx);
   SparseComplexMatrix& insert (const SparseMatrix& a, const Array<octave_idx_type>& indx);
 
   SparseComplexMatrix concat (const SparseComplexMatrix& rb,
 			      const Array<octave_idx_type>& ra_idx);
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,14 +1,26 @@
 2009-11-09  Jaroslav Hajek  <highegg@gmail.com>
 
 	* dSparse.h (Sparse::max): Use Array<octave_idx_type>.
 	* dSparse.cc: Update.
 	* CSparse.h (Sparse::max): Use Array<octave_idx_type>.
 	* CSparse.cc: Update.
+	* dNDArray.h (NDArray::max, NDArray::min, NDArray::cummax,
+	NDArray::cummin, NDArray::diff): Use dim = -1 as default.
+	* fNDArray.h (FloatNDArray::max, FloatNDArray::min, FloatNDArray::cummax,
+	FloatNDArray::cummin, FloatNDArray::diff): Use dim = -1 as default.
+	* CNDArray.h (ComplexNDArray::max, ComplexNDArray::min,
+	ComplexNDArray::cummax, ComplexNDArray::cummin, ComplexNDArray::diff):
+	Use dim = -1 as default.
+	* fCNDArray.h (FloatComplexNDArray::max, FloatComplexNDArray::min,
+	FloatComplexNDArray::cummax, FloatComplexNDArray::cummin,
+	FloatComplexNDArray::diff): Use dim = -1 as default.
+	* intNDArray.h (intNDArray::max, intNDArray::min, intNDArray::cummax,
+	intNDArray::cummin, intNDArray::diff): Use dim = -1 as default.
 
 2009-11-03  Jaroslav Hajek  <highegg@gmail.com>
 
 	* oct-mem.h: Rename octave_ucopy -> copy_or_memcpy,
 	octave_fill -> fill_or_memset, octave_new -> no_ctor_new,
 	octave_delete -> no_ctor_delete.
 	* Array.h: Update.
 	* Array.cc: Update.
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -94,27 +94,27 @@ public:
   NDArray prod (int dim = -1) const;
   NDArray sum (int dim = -1) const;  
   NDArray xsum (int dim = -1) const;  
   NDArray sumsq (int dim = -1) const;
   NDArray concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx);
   ComplexNDArray concat (const ComplexNDArray& rb, const Array<octave_idx_type>& ra_idx);
   charNDArray concat (const charNDArray& rb, const Array<octave_idx_type>& ra_idx);
 
-  NDArray max (int dim = 0) const;
-  NDArray max (Array<octave_idx_type>& index, int dim = 0) const;
-  NDArray min (int dim = 0) const;
-  NDArray min (Array<octave_idx_type>& index, int dim = 0) const;
+  NDArray max (int dim = -1) const;
+  NDArray max (Array<octave_idx_type>& index, int dim = -1) const;
+  NDArray min (int dim = -1) const;
+  NDArray min (Array<octave_idx_type>& index, int dim = -1) const;
   
-  NDArray cummax (int dim = 0) const;
-  NDArray cummax (Array<octave_idx_type>& index, int dim = 0) const;
-  NDArray cummin (int dim = 0) const;
-  NDArray cummin (Array<octave_idx_type>& index, int dim = 0) const;
+  NDArray cummax (int dim = -1) const;
+  NDArray cummax (Array<octave_idx_type>& index, int dim = -1) const;
+  NDArray cummin (int dim = -1) const;
+  NDArray cummin (Array<octave_idx_type>& index, int dim = -1) const;
 
-  NDArray diff (octave_idx_type order = 1, int dim = 0) const;
+  NDArray diff (octave_idx_type order = 1, int dim = -1) const;
 
   NDArray& insert (const NDArray& a, octave_idx_type r, octave_idx_type c);
   NDArray& insert (const NDArray& a, const Array<octave_idx_type>& ra_idx);
 
   NDArray abs (void) const;
   boolNDArray isnan (void) const;
   boolNDArray isinf (void) const;
   boolNDArray isfinite (void) const;
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -269,35 +269,38 @@ SparseMatrix::insert (const SparseMatrix
 {
   MSparse<double>::insert (a, indx);
   return *this;
 }
 
 SparseMatrix
 SparseMatrix::max (int dim) const
 {
-  Array2<octave_idx_type> dummy_idx;
+  Array<octave_idx_type> dummy_idx;
   return max (dummy_idx, dim);
 }
 
 SparseMatrix
-SparseMatrix::max (Array2<octave_idx_type>& idx_arg, int dim) const
+SparseMatrix::max (Array<octave_idx_type>& idx_arg, int dim) const
 {
   SparseMatrix result;
   dim_vector dv = dims ();
 
-  if (dv.numel () == 0 || dim > dv.length () || dim < 0)
+  if (dv.numel () == 0 || dim >= dv.length ())
     return result;
  
+  if (dim < 0)
+    dim = dv.first_non_singleton ();
+
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv(1);
 
   if (dim == 0)
     {
-      idx_arg.resize (1, nc);
+      idx_arg.clear (1, nc);
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  double tmp_max = octave_NaN;
 	  octave_idx_type idx_j = 0;
 	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
 	      if (ridx(i) != idx_j)
@@ -341,17 +344,17 @@ SparseMatrix::max (Array2<octave_idx_typ
 	      result.xridx (ii++) = 0;
 	    }
 	  result.xcidx (j+1) = ii;
 
 	}
     }
   else
     {
-      idx_arg.resize (nr, 1, 0);
+      idx_arg.resize_fill (nr, 1, 0);
 
       for (octave_idx_type i = cidx(0); i < cidx(1); i++)
 	idx_arg.elem(ridx(i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    if (idx_arg.elem(i) != -1)
@@ -415,35 +418,38 @@ SparseMatrix::max (Array2<octave_idx_typ
     }
 
   return result;
 }
 
 SparseMatrix
 SparseMatrix::min (int dim) const
 {
-  Array2<octave_idx_type> dummy_idx;
+  Array<octave_idx_type> dummy_idx;
   return min (dummy_idx, dim);
 }
 
 SparseMatrix
-SparseMatrix::min (Array2<octave_idx_type>& idx_arg, int dim) const
+SparseMatrix::min (Array<octave_idx_type>& idx_arg, int dim) const
 {
   SparseMatrix result;
   dim_vector dv = dims ();
 
-  if (dv.numel () == 0 || dim > dv.length () || dim < 0)
+  if (dv.numel () == 0 || dim >= dv.length ())
     return result;
  
+  if (dim < 0)
+    dim = dv.first_non_singleton ();
+
   octave_idx_type nr = dv(0);
   octave_idx_type nc = dv(1);
 
   if (dim == 0)
     {
-      idx_arg.resize (1, nc);
+      idx_arg.clear (1, nc);
       octave_idx_type nel = 0;
       for (octave_idx_type j = 0; j < nc; j++)
 	{
 	  double tmp_min = octave_NaN;
 	  octave_idx_type idx_j = 0;
 	  for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
 	    {
 	      if (ridx(i) != idx_j)
@@ -487,17 +493,17 @@ SparseMatrix::min (Array2<octave_idx_typ
 	      result.xridx (ii++) = 0;
 	    }
 	  result.xcidx (j+1) = ii;
 
 	}
     }
   else
     {
-      idx_arg.resize (nr, 1, 0);
+      idx_arg.resize_fill (nr, 1, 0);
 
       for (octave_idx_type i = cidx(0); i < cidx(1); i++)
 	idx_arg.elem(ridx(i)) = -1;
 
       for (octave_idx_type j = 0; j < nc; j++)
 	for (octave_idx_type i = 0; i < nr; i++)
 	  {
 	    if (idx_arg.elem(i) != -1)
diff --git a/liboctave/dSparse.h b/liboctave/dSparse.h
--- a/liboctave/dSparse.h
+++ b/liboctave/dSparse.h
@@ -94,20 +94,20 @@ SparseMatrix : public MSparse<double>
       return *this;
     }
 
   bool operator == (const SparseMatrix& a) const;
   bool operator != (const SparseMatrix& a) const;
 
   bool is_symmetric (void) const;
 
-  SparseMatrix max (int dim = 0) const;
-  SparseMatrix max (Array2<octave_idx_type>& index, int dim = 0) const;
-  SparseMatrix min (int dim = 0) const;
-  SparseMatrix min (Array2<octave_idx_type>& index, int dim = 0) const;
+  SparseMatrix max (int dim = -1) const;
+  SparseMatrix max (Array<octave_idx_type>& index, int dim = -1) const;
+  SparseMatrix min (int dim = -1) const;
+  SparseMatrix min (Array<octave_idx_type>& index, int dim = -1) const;
   
   // destructive insert/delete/reorder operations
 
   SparseMatrix& insert (const SparseMatrix& a, octave_idx_type r, octave_idx_type c);
 
   SparseMatrix& insert (const SparseMatrix& a, const Array<octave_idx_type>& indx);
 
   SparseMatrix concat (const SparseMatrix& rb, const Array<octave_idx_type>& ra_idx);
diff --git a/liboctave/fCNDArray.h b/liboctave/fCNDArray.h
--- a/liboctave/fCNDArray.h
+++ b/liboctave/fCNDArray.h
@@ -82,27 +82,27 @@ public:
   FloatComplexNDArray cumsum (int dim = -1) const;
   FloatComplexNDArray prod (int dim = -1) const;
   FloatComplexNDArray sum (int dim = -1) const;
        ComplexNDArray dsum (int dim = -1) const;
   FloatComplexNDArray sumsq (int dim = -1) const;
   FloatComplexNDArray concat (const FloatComplexNDArray& rb, const Array<octave_idx_type>& ra_idx);
   FloatComplexNDArray concat (const FloatNDArray& rb, const Array<octave_idx_type>& ra_idx);
 
-  FloatComplexNDArray max (int dim = 0) const;
-  FloatComplexNDArray max (Array<octave_idx_type>& index, int dim = 0) const;
-  FloatComplexNDArray min (int dim = 0) const;
-  FloatComplexNDArray min (Array<octave_idx_type>& index, int dim = 0) const;
+  FloatComplexNDArray max (int dim = -1) const;
+  FloatComplexNDArray max (Array<octave_idx_type>& index, int dim = -1) const;
+  FloatComplexNDArray min (int dim = -1) const;
+  FloatComplexNDArray min (Array<octave_idx_type>& index, int dim = -1) const;
 
-  FloatComplexNDArray cummax (int dim = 0) const;
-  FloatComplexNDArray cummax (Array<octave_idx_type>& index, int dim = 0) const;
-  FloatComplexNDArray cummin (int dim = 0) const;
-  FloatComplexNDArray cummin (Array<octave_idx_type>& index, int dim = 0) const;
+  FloatComplexNDArray cummax (int dim = -1) const;
+  FloatComplexNDArray cummax (Array<octave_idx_type>& index, int dim = -1) const;
+  FloatComplexNDArray cummin (int dim = -1) const;
+  FloatComplexNDArray cummin (Array<octave_idx_type>& index, int dim = -1) const;
 
-  FloatComplexNDArray diff (octave_idx_type order = 1, int dim = 0) const;
+  FloatComplexNDArray diff (octave_idx_type order = 1, int dim = -1) const;
 
   FloatComplexNDArray& insert (const NDArray& a, octave_idx_type r, octave_idx_type c);
   FloatComplexNDArray& insert (const FloatComplexNDArray& a, octave_idx_type r, octave_idx_type c);
   FloatComplexNDArray& insert (const FloatComplexNDArray& a, const Array<octave_idx_type>& ra_idx);
   
   FloatNDArray abs (void) const;
   boolNDArray isnan (void) const;
   boolNDArray isinf (void) const;
diff --git a/liboctave/fNDArray.h b/liboctave/fNDArray.h
--- a/liboctave/fNDArray.h
+++ b/liboctave/fNDArray.h
@@ -91,27 +91,27 @@ public:
   FloatNDArray prod (int dim = -1) const;
   FloatNDArray sum (int dim = -1) const;  
        NDArray dsum (int dim = -1) const;  
   FloatNDArray sumsq (int dim = -1) const;
   FloatNDArray concat (const FloatNDArray& rb, const Array<octave_idx_type>& ra_idx);
   FloatComplexNDArray concat (const FloatComplexNDArray& rb, const Array<octave_idx_type>& ra_idx);
   charNDArray concat (const charNDArray& rb, const Array<octave_idx_type>& ra_idx);
 
-  FloatNDArray max (int dim = 0) const;
-  FloatNDArray max (Array<octave_idx_type>& index, int dim = 0) const;
-  FloatNDArray min (int dim = 0) const;
-  FloatNDArray min (Array<octave_idx_type>& index, int dim = 0) const;
+  FloatNDArray max (int dim = -1) const;
+  FloatNDArray max (Array<octave_idx_type>& index, int dim = -1) const;
+  FloatNDArray min (int dim = -1) const;
+  FloatNDArray min (Array<octave_idx_type>& index, int dim = -1) const;
   
-  FloatNDArray cummax (int dim = 0) const;
-  FloatNDArray cummax (Array<octave_idx_type>& index, int dim = 0) const;
-  FloatNDArray cummin (int dim = 0) const;
-  FloatNDArray cummin (Array<octave_idx_type>& index, int dim = 0) const;
+  FloatNDArray cummax (int dim = -1) const;
+  FloatNDArray cummax (Array<octave_idx_type>& index, int dim = -1) const;
+  FloatNDArray cummin (int dim = -1) const;
+  FloatNDArray cummin (Array<octave_idx_type>& index, int dim = -1) const;
 
-  FloatNDArray diff (octave_idx_type order = 1, int dim = 0) const;
+  FloatNDArray diff (octave_idx_type order = 1, int dim = -1) const;
 
   FloatNDArray& insert (const FloatNDArray& a, octave_idx_type r, octave_idx_type c);
   FloatNDArray& insert (const FloatNDArray& a, const Array<octave_idx_type>& ra_idx);
 
   FloatNDArray abs (void) const;
   boolNDArray isnan (void) const;
   boolNDArray isinf (void) const;
   boolNDArray isfinite (void) const;
diff --git a/liboctave/intNDArray.h b/liboctave/intNDArray.h
--- a/liboctave/intNDArray.h
+++ b/liboctave/intNDArray.h
@@ -72,31 +72,31 @@ public:
       return *this; 
     }
 
   // FIXME -- this is not quite the right thing.
 
   boolNDArray all (int dim = -1) const;
   boolNDArray any (int dim = -1) const;
 
-  intNDArray max (int dim = 0) const;
-  intNDArray max (Array<octave_idx_type>& index, int dim = 0) const;
-  intNDArray min (int dim = 0) const;
-  intNDArray min (Array<octave_idx_type>& index, int dim = 0) const;
+  intNDArray max (int dim = -1) const;
+  intNDArray max (Array<octave_idx_type>& index, int dim = -1) const;
+  intNDArray min (int dim = -1) const;
+  intNDArray min (Array<octave_idx_type>& index, int dim = -1) const;
   
-  intNDArray cummax (int dim = 0) const;
-  intNDArray cummax (Array<octave_idx_type>& index, int dim = 0) const;
-  intNDArray cummin (int dim = 0) const;
-  intNDArray cummin (Array<octave_idx_type>& index, int dim = 0) const;
+  intNDArray cummax (int dim = -1) const;
+  intNDArray cummax (Array<octave_idx_type>& index, int dim = -1) const;
+  intNDArray cummin (int dim = -1) const;
+  intNDArray cummin (Array<octave_idx_type>& index, int dim = -1) const;
   
   intNDArray sum (int dim) const;
   NDArray dsum (int dim) const;
   intNDArray cumsum (int dim) const;
 
-  intNDArray diff (octave_idx_type order = 1, int dim = 0) const;
+  intNDArray diff (octave_idx_type order = 1, int dim = -1) const;
 
   intNDArray abs (void) const;
   intNDArray signum (void) const;
 
   intNDArray squeeze (void) const
     { return intNDArray<T> (MArrayN<T>::squeeze ()); }
 
   intNDArray transpose (void) const
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,21 @@
+2009-11-09  Jaroslav Hajek  <highegg@gmail.com>
+
+	* ov-base.cc (btyp_mixed_numeric): New function.
+	* ov-base.h: Declare it.
+	(btyp_isnumeric): New inline function.
+	* DLD_FUNCTIONS/max.cc (do_minmax_red_op, do_minmax_bin_op,
+	do_minmax_body, do_cumminmax_red_op): New functions.
+	(MINMAX_DOUBLE_SBODY, MINMAX_DOUBLE_BODY,
+	MINMAX_SINGLE_SBODY, MINMAX_SINGLE_BODY,
+	MINMAX_SPARSE_BODY, MINMAX_INT_SBODY, MINMAX_INT_BODY,
+	MINMAX_BODY, CUMMINMAX_BODY): Remove.
+	(Fmin, Fmax, Fcummin, Fcummax): Update.
+
 2009-11-09  Jaroslav Hajek  <highegg@gmail.com>
 
 	* ov.h: Add sparse matrix extractors.
 
 2009-11-09  John W. Eaton  <jwe@octave.org>
 
 	* DLD-FUNCTIONS/__delaunayn__.cc, DLD-FUNCTIONS/__dsearchn__.cc,
 	DLD-FUNCTIONS/__voronoi__.cc, DLD-FUNCTIONS/convhulln.cc,
diff --git a/src/DLD-FUNCTIONS/max.cc b/src/DLD-FUNCTIONS/max.cc
--- a/src/DLD-FUNCTIONS/max.cc
+++ b/src/DLD-FUNCTIONS/max.cc
@@ -37,656 +37,246 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "gripes.h"
 #include "oct-obj.h"
 
 #include "ov-cx-mat.h"
 #include "ov-re-sparse.h"
 #include "ov-cx-sparse.h"
 
-#define MINMAX_DOUBLE_SBODY(FCN) \
-{ \
-  if (nargout == 1 || nargout == 0) \
-    { \
-      if (arg1.is_real_type ()) \
-	{ \
-	  NDArray m = arg1.array_value (); \
- \
-	  if (! error_state) \
-	    { \
-	      NDArray n = m. FCN (dim); \
-	      retval(0) = n; \
-	    } \
-	} \
-      else if (arg1.is_complex_type ()) \
-	{ \
-	  ComplexNDArray m = arg1.complex_array_value (); \
- \
-	  if (! error_state) \
-	    { \
-	      ComplexNDArray n = m. FCN (dim); \
-	      retval(0) = n; \
-	    } \
-	} \
-      else \
-	gripe_wrong_type_arg (#FCN, arg1); \
-    } \
-  else if (nargout == 2) \
-    { \
-      Array<octave_idx_type> index; \
- \
-      if (arg1.is_real_type ()) \
-	{ \
-	  NDArray m = arg1.array_value (); \
- \
-	  if (! error_state) \
-	    { \
-	      NDArray n = m. FCN (index, dim);	\
-	      retval(0) = n; \
-	    } \
-	} \
-      else if (arg1.is_complex_type ()) \
-	{ \
-	  ComplexNDArray m = arg1.complex_array_value (); \
- \
-	  if (! error_state) \
-	    { \
-	      ComplexNDArray n = m. FCN (index, dim);	\
-	      retval(0) = n; \
-	    } \
-	} \
-      else \
-	gripe_wrong_type_arg (#FCN, arg1); \
- \
-      octave_idx_type len = index.numel (); \
- \
-      if (len > 0) \
-	retval(1) = octave_value (index, true, true);	\
-      else \
-	retval(1) = NDArray (); \
-    } \
+template <class ArrayType>
+static octave_value_list
+do_minmax_red_op (const octave_value& arg,
+                  int nargout, int dim, bool ismin)
+{
+  octave_value_list retval;
+  ArrayType array = octave_value_extract<ArrayType> (arg);
+
+  if (error_state)
+    return retval;
+
+  if (nargout == 2)
+    {
+      retval.resize (2);
+      Array<octave_idx_type> idx;
+      if (ismin)
+        retval(0) = array.min (idx, dim);
+      else
+        retval(0) = array.max (idx, dim);
+
+      retval(1) = octave_value (idx, true, true);
+    }
+  else
+    {
+      if (ismin)
+        retval(0) = array.min (dim);
+      else
+        retval(0) = array.max (dim);
+    }
+
+  return retval;
 }
 
-#define MINMAX_DOUBLE_BODY(FCN) \
-{ \
-  bool single_arg = (nargin == 1) || (arg2.is_empty() && nargin == 3);	\
-  if (single_arg) \
-    MINMAX_DOUBLE_SBODY (FCN) \
-  else \
-    { \
-      int arg1_is_scalar = arg1.is_scalar_type (); \
-      int arg2_is_scalar = arg2.is_scalar_type (); \
- \
-      int arg1_is_complex = arg1.is_complex_type (); \
-      int arg2_is_complex = arg2.is_complex_type (); \
- \
-      if (arg1_is_scalar) \
-	{ \
-	  if (arg1_is_complex || arg2_is_complex) \
-	    { \
-	      Complex c1 = arg1.complex_value (); \
-	      ComplexNDArray m2 = arg2.complex_array_value (); \
-	      if (! error_state) \
-		{ \
-		  ComplexNDArray result = FCN (c1, m2); \
-		  if (! error_state) \
-		    retval(0) = result; \
-		} \
-	    } \
-	  else \
-	    { \
-	      double d1 = arg1.double_value (); \
-	      NDArray m2 = arg2.array_value (); \
- \
-	      if (! error_state) \
-		{ \
-		  NDArray result = FCN (d1, m2); \
-		  if (! error_state) \
-		    retval(0) = result; \
-		} \
-	    } \
-	} \
-      else if (arg2_is_scalar) \
-	{ \
-	  if (arg1_is_complex || arg2_is_complex) \
-	    { \
-	      ComplexNDArray m1 = arg1.complex_array_value (); \
- \
-	      if (! error_state) \
-		{ \
-		  Complex c2 = arg2.complex_value (); \
-		  ComplexNDArray result = FCN (m1, c2); \
-		  if (! error_state) \
-		    retval(0) = result; \
-		} \
-	    } \
-	  else \
-	    { \
-	      NDArray m1 = arg1.array_value (); \
- \
-	      if (! error_state) \
-		{ \
-		  double d2 = arg2.double_value (); \
-		  NDArray result = FCN (m1, d2); \
-		  if (! error_state) \
-		    retval(0) = result; \
-		} \
-	    } \
-	} \
-      else \
-	{ \
-	  if (arg1_is_complex || arg2_is_complex) \
-	    { \
-	      ComplexNDArray m1 = arg1.complex_array_value (); \
- \
-	      if (! error_state) \
-		{ \
-		  ComplexNDArray m2 = arg2.complex_array_value (); \
- \
-		  if (! error_state) \
-		    { \
-		      ComplexNDArray result = FCN (m1, m2); \
-		      if (! error_state) \
-			retval(0) = result; \
-		    } \
-		} \
-	    } \
-	  else \
-	    { \
-	      NDArray m1 = arg1.array_value (); \
- \
-	      if (! error_state) \
-		{ \
-		  NDArray m2 = arg2.array_value (); \
- \
-		  if (! error_state) \
-		    { \
-		      NDArray result = FCN (m1, m2); \
-		      if (! error_state) \
-			retval(0) = result; \
-		    } \
-		} \
-	    } \
-	} \
-    } \
-}
+template <class ArrayType>
+static octave_value
+do_minmax_bin_op (const octave_value& argx, const octave_value& argy,
+                  bool ismin)
+{
+  typedef typename ArrayType::element_type ScalarType;
+
+  octave_value retval;
+
+  if (argx.is_scalar_type () == 1)
+    {
+      ScalarType x = octave_value_extract<ScalarType> (argx);
+      ArrayType y = octave_value_extract<ArrayType> (argy);
 
-#define MINMAX_SINGLE_SBODY(FCN) \
-{ \
-  if (nargout == 1 || nargout == 0) \
-    { \
-      if (arg1.is_real_type ()) \
-	{ \
-	  FloatNDArray m = arg1.float_array_value (); \
- \
-	  if (! error_state) \
-	    { \
-	      FloatNDArray n = m. FCN (dim); \
-	      retval(0) = n; \
-	    } \
-	} \
-      else if (arg1.is_complex_type ()) \
-	{ \
-	  FloatComplexNDArray m = arg1.float_complex_array_value (); \
- \
-	  if (! error_state) \
-	    { \
-	      FloatComplexNDArray n = m. FCN (dim); \
-	      retval(0) = n; \
-	    } \
-	} \
-      else \
-	gripe_wrong_type_arg (#FCN, arg1); \
-    } \
-  else if (nargout == 2) \
-    { \
-      Array<octave_idx_type> index; \
- \
-      if (arg1.is_real_type ()) \
-	{ \
-	  FloatNDArray m = arg1.float_array_value (); \
- \
-	  if (! error_state) \
-	    { \
-	      FloatNDArray n = m. FCN (index, dim);	\
-	      retval(0) = n; \
-	    } \
-	} \
-      else if (arg1.is_complex_type ()) \
-	{ \
-	  FloatComplexNDArray m = arg1.float_complex_array_value (); \
- \
-	  if (! error_state) \
-	    { \
-	      FloatComplexNDArray n = m. FCN (index, dim);	\
-	      retval(0) = n; \
-	    } \
-	} \
-      else \
-	gripe_wrong_type_arg (#FCN, arg1); \
- \
-      octave_idx_type len = index.numel (); \
- \
-      if (len > 0) \
-	retval(1) = octave_value (index, true, true);	\
-      else \
-	retval(1) = NDArray (); \
-    } \
+      if (error_state)
+        ;
+      else if (ismin)
+        retval = min (x, y);
+      else
+        retval = max (x, y);
+    }
+  else if (argy.is_scalar_type () == 1)
+    {
+      ArrayType x = octave_value_extract<ArrayType> (argx);
+      ScalarType y = octave_value_extract<ScalarType> (argy);
+
+      if (error_state)
+        ;
+      else if (ismin)
+        retval = min (x, y);
+      else
+        retval = max (x, y);
+    }
+  else
+    {
+      ArrayType x = octave_value_extract<ArrayType> (argx);
+      ArrayType y = octave_value_extract<ArrayType> (argy);
+
+      if (error_state)
+        ;
+      else if (ismin)
+        retval = min (x, y);
+      else
+        retval = max (x, y);
+    }
+
+  return retval;
 }
 
-#define MINMAX_SINGLE_BODY(FCN) \
-{ \
-  bool single_arg = (nargin == 1) || (arg2.is_empty() && nargin == 3);	\
-  if (single_arg) \
-    MINMAX_SINGLE_SBODY(FCN) \
-  else \
-    { \
-      int arg1_is_scalar = arg1.is_scalar_type (); \
-      int arg2_is_scalar = arg2.is_scalar_type (); \
- \
-      int arg1_is_complex = arg1.is_complex_type (); \
-      int arg2_is_complex = arg2.is_complex_type (); \
- \
-      if (arg1_is_scalar) \
-	{ \
-	  if (arg1_is_complex || arg2_is_complex) \
-	    { \
-	      FloatComplex c1 = arg1.float_complex_value (); \
-	      FloatComplexNDArray m2 = arg2.float_complex_array_value (); \
-	      if (! error_state) \
-		{ \
-		  FloatComplexNDArray result = FCN (c1, m2); \
-		  if (! error_state) \
-		    retval(0) = result; \
-		} \
-	    } \
-	  else \
-	    { \
-	      float d1 = arg1.float_value (); \
-	      FloatNDArray m2 = arg2.float_array_value (); \
- \
-	      if (! error_state) \
-		{ \
-		  FloatNDArray result = FCN (d1, m2); \
-		  if (! error_state) \
-		    retval(0) = result; \
-		} \
-	    } \
-	} \
-      else if (arg2_is_scalar) \
-	{ \
-	  if (arg1_is_complex || arg2_is_complex) \
-	    { \
-	      FloatComplexNDArray m1 = arg1.float_complex_array_value (); \
- \
-	      if (! error_state) \
-		{ \
-		  FloatComplex c2 = arg2.float_complex_value (); \
-		  FloatComplexNDArray result = FCN (m1, c2); \
-		  if (! error_state) \
-		    retval(0) = result; \
-		} \
-	    } \
-	  else \
-	    { \
-	      FloatNDArray m1 = arg1.float_array_value (); \
- \
-	      if (! error_state) \
-		{ \
-		  float d2 = arg2.float_value (); \
-		  FloatNDArray result = FCN (m1, d2); \
-		  if (! error_state) \
-		    retval(0) = result; \
-		} \
-	    } \
-	} \
-      else \
-	{ \
-	  if (arg1_is_complex || arg2_is_complex) \
-	    { \
-	      FloatComplexNDArray m1 = arg1.float_complex_array_value (); \
- \
-	      if (! error_state) \
-		{ \
-		  FloatComplexNDArray m2 = arg2.float_complex_array_value (); \
- \
-		  if (! error_state) \
-		    { \
-		      FloatComplexNDArray result = FCN (m1, m2); \
-		      if (! error_state) \
-			retval(0) = result; \
-		    } \
-		} \
-	    } \
-	  else \
-	    { \
-	      FloatNDArray m1 = arg1.float_array_value (); \
- \
-	      if (! error_state) \
-		{ \
-		  FloatNDArray m2 = arg2.float_array_value (); \
- \
-		  if (! error_state) \
-		    { \
-		      FloatNDArray result = FCN (m1, m2); \
-		      if (! error_state) \
-			retval(0) = result; \
-		    } \
-		} \
-	    } \
-	} \
-    } \
-}
+static octave_value_list
+do_minmax_body (const octave_value_list& args,
+                int nargout, bool ismin)
+{
+  octave_value_list retval;
+
+  const char *func = ismin ? "min" : "max";
+
+  int nargin = args.length ();
 
-#define MINMAX_INT_SBODY(FCN, TYP) \
-{ \
-  if (nargout == 1 || nargout == 0) \
-    { \
-      TYP ## NDArray m = arg1. TYP ## _array_value (); \
- \
-      if (! error_state) \
-	{ \
-	  TYP ## NDArray n = m. FCN (dim); \
-	  retval(0) = n; \
-	} \
-    } \
-  else if (nargout == 2) \
-    { \
-      Array<octave_idx_type> index; \
- \
-      TYP ## NDArray m = arg1. TYP ## _array_value (); \
- \
-      if (! error_state) \
-        { \
-	  TYP ## NDArray n = m. FCN (index, dim);	\
-	  retval(0) = n; \
-	} \
- \
-      octave_idx_type len = index.numel (); \
- \
-      if (len > 0) \
-	retval(1) = octave_value (index, true, true);	\
-      else \
-	retval(1) = NDArray (); \
-    } \
-}
+  if (nargin == 3 || nargin == 1)
+    {
+      octave_value arg = args(0);
+      int dim = -1;
+      if (nargin == 3)
+        {
+          dim = args(2).int_value (true) - 1;
+          if (error_state || dim < 0)
+            {
+              error ("%s: invalid dimension", func);
+              return retval;
+            }
 
-#define MINMAX_INT_BODY(FCN, TYP) \
- { \
-  bool single_arg = (nargin == 1) || (arg2.is_empty() && nargin == 3);	\
-  if (single_arg) \
-    MINMAX_INT_SBODY (FCN, TYP) \
-  else \
-    { \
-      int arg1_is_scalar = arg1.is_scalar_type (); \
-      int arg2_is_scalar = arg2.is_scalar_type (); \
- \
-      if (arg1_is_scalar) \
-	{ \
-	  octave_ ## TYP d1 = arg1. TYP ## _scalar_value (); \
-	  TYP ## NDArray m2 = arg2. TYP ## _array_value (); \
- \
-	  if (! error_state) \
-	    { \
-	      TYP ## NDArray result = FCN (d1, m2); \
-	      if (! error_state) \
-		retval(0) = result; \
-	    } \
-	} \
-      else if (arg2_is_scalar) \
-	{ \
-	  TYP ## NDArray m1 = arg1. TYP ## _array_value (); \
- \
-	  if (! error_state) \
-	    { \
-	      octave_ ## TYP d2 = arg2. TYP ## _scalar_value (); \
-	      TYP ## NDArray result = FCN (m1, d2); \
-	      if (! error_state) \
-		retval(0) = result; \
-	    } \
-	} \
-      else \
-	{ \
-	  TYP ## NDArray m1 = arg1. TYP ## _array_value (); \
- \
-	  if (! error_state) \
-	    { \
-	      TYP ## NDArray m2 = arg2. TYP ## _array_value (); \
- \
-	      if (! error_state) \
-		{ \
-		  TYP ## NDArray result = FCN (m1, m2); \
-		  if (! error_state) \
-		    retval(0) = result; \
-		} \
-	    } \
-	} \
-    } \
-}
+          if (! args(1).is_empty ())
+            warning ("%s: second argument is ignored");
+        }
 
-#define MINMAX_SPARSE_BODY(FCN) \
-{ \
-  bool single_arg = (nargin == 1) || arg2.is_empty();	\
- \
-  if (single_arg && (nargout == 1 || nargout == 0)) \
-    { \
-      if (arg1.is_real_type ()) \
-	retval(0) = arg1.sparse_matrix_value () .FCN (dim); \
-      else if (arg1.is_complex_type ()) \
-	retval(0) = arg1.sparse_complex_matrix_value () .FCN (dim); \
-      else \
-	gripe_wrong_type_arg (#FCN, arg1); \
-    } \
-  else if (single_arg && nargout == 2) \
-    { \
-      Array2<octave_idx_type> index; \
- \
-      if (arg1.is_real_type ()) \
-	retval(0) = arg1.sparse_matrix_value () .FCN (index, dim); \
-      else if (arg1.is_complex_type ()) \
-	retval(0) = arg1.sparse_complex_matrix_value () .FCN (index, dim); \
-      else \
-	gripe_wrong_type_arg (#FCN, arg1); \
- \
-      octave_idx_type len = index.numel (); \
- \
-      if (len > 0) \
-	retval(1) = octave_value (index, true, true);	\
-      else \
-	retval(1) = NDArray (); \
-    } \
-  else \
-    { \
-      int arg1_is_scalar = arg1.is_scalar_type (); \
-      int arg2_is_scalar = arg2.is_scalar_type (); \
- \
-      int arg1_is_complex = arg1.is_complex_type (); \
-      int arg2_is_complex = arg2.is_complex_type (); \
- \
-      if (arg1_is_scalar) \
-	{ \
-	  if (arg1_is_complex || arg2_is_complex) \
-	    { \
-	      Complex c1 = arg1.complex_value (); \
-	      \
-	      SparseComplexMatrix m2 = arg2.sparse_complex_matrix_value (); \
-	      \
-	      if (! error_state) \
-		{ \
-		  SparseComplexMatrix result = FCN (c1, m2); \
-		  if (! error_state) \
-		    retval(0) = result; \
-		} \
-	    } \
-	  else \
-	    { \
-	      double d1 = arg1.double_value (); \
-	      SparseMatrix m2 = arg2.sparse_matrix_value (); \
-	      \
-	      if (! error_state) \
-		{ \
-		  SparseMatrix result = FCN (d1, m2); \
-		  if (! error_state) \
-		    retval(0) = result; \
-		} \
-	    } \
-	} \
-      else if (arg2_is_scalar) \
-	{ \
-	  if (arg1_is_complex || arg2_is_complex) \
-	    { \
-	      SparseComplexMatrix m1 = arg1.sparse_complex_matrix_value (); \
- \
-	      if (! error_state) \
-		{ \
-		  Complex c2 = arg2.complex_value (); \
-		  SparseComplexMatrix result = FCN (m1, c2); \
-		  if (! error_state) \
-		    retval(0) = result; \
-		} \
-	    } \
-	  else \
-	    { \
-	      SparseMatrix m1 = arg1.sparse_matrix_value (); \
- \
-	      if (! error_state) \
-		{ \
-		  double d2 = arg2.double_value (); \
-		  SparseMatrix result = FCN (m1, d2); \
-		  if (! error_state) \
-		    retval(0) = result; \
-		} \
-	    } \
-	} \
-      else \
-	{ \
-	  if (arg1_is_complex || arg2_is_complex) \
-	    { \
-	      SparseComplexMatrix m1 = arg1.sparse_complex_matrix_value (); \
- \
-	      if (! error_state) \
-		{ \
-		  SparseComplexMatrix m2 = arg2.sparse_complex_matrix_value (); \
- \
-		  if (! error_state) \
-		    { \
-		      SparseComplexMatrix result = FCN (m1, m2); \
-		      if (! error_state) \
-			retval(0) = result; \
-		    } \
-		} \
-	    } \
-	  else \
-	    { \
-	      SparseMatrix m1 = arg1.sparse_matrix_value (); \
- \
-	      if (! error_state) \
-		{ \
-		  SparseMatrix m2 = arg2.sparse_matrix_value (); \
- \
-		  if (! error_state) \
-		    { \
-		      SparseMatrix result = FCN (m1, m2); \
-		      if (! error_state) \
-			retval(0) = result; \
-		    } \
-		} \
-	    } \
-	} \
-    } \
+      switch (arg.builtin_type ())
+        {
+        case btyp_double:
+          {
+            if (arg.is_range () && (dim == -1 || dim == 1))
+              {
+                Range range = arg.range_value ();
+                if (range.nelem () == 0)
+                  {
+                    retval(0) = arg;
+                    if (nargout > 1)
+                      retval(1) = arg;
+                  }
+                else if (ismin)
+                  {
+                    retval(0) = range.min ();
+                    if (nargout > 1)
+                      retval(1) = static_cast<double> (range.inc () < 0 ? range.nelem () : 1);
+                  }
+                else
+                  {
+                    retval(0) = range.max ();
+                    if (nargout > 1)
+                      retval(1) = static_cast<double> (range.inc () >= 0 ? range.nelem () : 1);
+                  }
+              }
+            else if (arg.is_sparse_type ())
+              retval = do_minmax_red_op<SparseMatrix> (arg, nargout, dim, ismin);
+            else
+              retval = do_minmax_red_op<NDArray> (arg, nargout, dim, ismin);
+            break;
+          }
+        case btyp_complex:
+          {
+            if (arg.is_sparse_type ())
+              retval = do_minmax_red_op<SparseComplexMatrix> (arg, nargout, dim, ismin);
+            else
+              retval = do_minmax_red_op<ComplexNDArray> (arg, nargout, dim, ismin);
+            break;
+          }
+        case btyp_float:
+          retval = do_minmax_red_op<FloatNDArray> (arg, nargout, dim, ismin);
+          break;
+        case btyp_float_complex:
+          retval = do_minmax_red_op<FloatComplexNDArray> (arg, nargout, dim, ismin);
+          break;
+#define MAKE_INT_BRANCH(X) \
+        case btyp_ ## X: \
+          retval = do_minmax_red_op<X ## NDArray> (arg, nargout, dim, ismin); \
+          break;
+        MAKE_INT_BRANCH (int8);
+        MAKE_INT_BRANCH (int16);
+        MAKE_INT_BRANCH (int32);
+        MAKE_INT_BRANCH (int64);
+        MAKE_INT_BRANCH (uint8);
+        MAKE_INT_BRANCH (uint16);
+        MAKE_INT_BRANCH (uint32);
+        MAKE_INT_BRANCH (uint64);
+#undef MAKE_INT_BRANCH
+        default:
+          gripe_wrong_type_arg (func, arg);
+      }
+    }
+  else if (nargin == 2)
+    {
+      octave_value argx = args(0), argy = args(1);
+      builtin_type_t xtyp = argx.builtin_type (), ytyp = argy.builtin_type ();
+      builtin_type_t rtyp = btyp_mixed_numeric (xtyp, ytyp);
+
+      switch (rtyp)
+        {
+        case btyp_double:
+          {
+            if ((argx.is_sparse_type () 
+                 && (argy.is_sparse_type () || argy.is_scalar_type ()))
+                || (argy.is_sparse_type () && argx.is_scalar_type ()))
+              retval = do_minmax_bin_op<SparseMatrix> (argx, argy, ismin);
+            else
+              retval = do_minmax_bin_op<NDArray> (argx, argy, ismin);
+            break;
+          }
+        case btyp_complex:
+          {
+            if ((argx.is_sparse_type () 
+                 && (argy.is_sparse_type () || argy.is_scalar_type ()))
+                || (argy.is_sparse_type () && argx.is_scalar_type ()))
+              retval = do_minmax_bin_op<SparseComplexMatrix> (argx, argy, ismin);
+            else
+              retval = do_minmax_bin_op<ComplexNDArray> (argx, argy, ismin);
+            break;
+          }
+        case btyp_float:
+          retval = do_minmax_bin_op<FloatNDArray> (argx, argy, ismin);
+          break;
+        case btyp_float_complex:
+          retval = do_minmax_bin_op<FloatComplexNDArray> (argx, argy, ismin);
+          break;
+#define MAKE_INT_BRANCH(X) \
+        case btyp_ ## X: \
+          retval = do_minmax_bin_op<X ## NDArray> (argx, argy, ismin); \
+          break;
+        MAKE_INT_BRANCH (int8);
+        MAKE_INT_BRANCH (int16);
+        MAKE_INT_BRANCH (int32);
+        MAKE_INT_BRANCH (int64);
+        MAKE_INT_BRANCH (uint8);
+        MAKE_INT_BRANCH (uint16);
+        MAKE_INT_BRANCH (uint32);
+        MAKE_INT_BRANCH (uint64);
+#undef MAKE_INT_BRANCH
+        default:
+          error ("%s: cannot compute %s (%s, %s)", func, func,
+                 argx.type_name ().c_str (), argy.type_name ().c_str ());
+        }
+    }
+  else
+    print_usage ();
+
+  return retval;
 }
 
-
-#define MINMAX_BODY(FCN) \
- \
-  octave_value_list retval;  \
- \
-  int nargin = args.length (); \
- \
-  if (nargin < 1 || nargin > 3 || nargout > 2) \
-    { \
-      print_usage (); \
-      return retval; \
-    } \
- \
-  octave_value arg1; \
-  octave_value arg2; \
-  octave_value arg3; \
- \
-  switch (nargin) \
-    { \
-    case 3: \
-      arg3 = args(2); \
- \
-    case 2: \
-      arg2 = args(1); \
- \
-    case 1: \
-      arg1 = args(0); \
-      break; \
- \
-    default: \
-      panic_impossible (); \
-      break; \
-    } \
- \
-  int dim; \
-  dim_vector dv = arg1.dims (); \
-  if (error_state) \
-    { \
-      gripe_wrong_type_arg (#FCN, arg1);  \
-      return retval; \
-    } \
- \
-  if (nargin == 3) \
-    { \
-      dim = arg3.nint_value () - 1;  \
-      if (dim < 0 || dim >= dv.length ()) \
-        { \
-	  error ("%s: invalid dimension", #FCN); \
-	  return retval; \
-	} \
-    } \
-  else \
-    { \
-      dim = 0; \
-      while ((dim < dv.length ()) && (dv (dim) <= 1)) \
-	dim++; \
-      if (dim == dv.length ()) \
-	dim = 0; \
-    } \
- \
-  if (arg1.is_integer_type ()) \
-    { \
-      if (arg1.is_uint8_type ()) \
-        MINMAX_INT_BODY (FCN, uint8) \
-      else if (arg1.is_uint16_type ()) \
-        MINMAX_INT_BODY (FCN, uint16) \
-      else if (arg1.is_uint32_type ()) \
-        MINMAX_INT_BODY (FCN, uint32) \
-      else if (arg1.is_uint64_type ()) \
-        MINMAX_INT_BODY (FCN, uint64) \
-      else if (arg1.is_int8_type ()) \
-        MINMAX_INT_BODY (FCN, int8) \
-      else if (arg1.is_int16_type ()) \
-        MINMAX_INT_BODY (FCN, int16) \
-      else if (arg1.is_int32_type ()) \
-        MINMAX_INT_BODY (FCN, int32) \
-      else if (arg1.is_int64_type ()) \
-        MINMAX_INT_BODY (FCN, int64) \
-    } \
-  else if (arg1.is_sparse_type ()) \
-    MINMAX_SPARSE_BODY (FCN) \
-  else if (arg1.is_single_type ()) \
-    MINMAX_SINGLE_BODY (FCN) \
-  else \
-    MINMAX_DOUBLE_BODY (FCN) \
- \
- return retval;
-
 DEFUN_DLD (min, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} min (@var{x})\n\
 @deftypefnx {Loadable Function} {} min (@var{x}, @var{y})\n\
 @deftypefnx {Loadable Function} {} min (@var{x}, @var{y}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} min (@var{x})\n\
 For a vector argument, return the minimum value.  For a matrix\n\
 argument, return the minimum value from each column, as a row\n\
@@ -723,17 +313,17 @@ minimum value(s).  Thus,\n\
 [x, ix] = min ([1, 3, 0, 2, 0])\n\
     @result{}  x = 0\n\
         ix = 3\n\
 @end group\n\
 @end example\n\
 @seealso{max, cummin, cummax}\n\
 @end deftypefn")
 {
-  MINMAX_BODY (min);
+  return do_minmax_body (args, nargout, true);
 }
 
 /*
 
 %% test/octave.test/arith/min-1.m
 %!assert (min ([1, 4, 2, 3]) == 1);
 %!assert (min ([1; -10; 5; -2]) == -10);
 
@@ -799,17 +389,17 @@ maximum value(s).  Thus,\n\
 [x, ix] = max ([1, 3, 5, 2, 5])\n\
     @result{}  x = 5\n\
         ix = 3\n\
 @end group\n\
 @end example\n\
 @seealso{min, cummax, cummin}\n\
 @end deftypefn")
 {
-  MINMAX_BODY (max);
+  return do_minmax_body (args, nargout, false);
 }
 
 /* 
 
 %% test/octave.test/arith/max-1.m
 %!assert (max ([1, 4, 2, 3]) == 4);
 %!assert (max ([1; -10; 5; -2]) == 5);
  
@@ -830,96 +420,109 @@ maximum value(s).  Thus,\n\
 %! assert (y, [1, 3; 2, 4]);
 %! assert (ndims(y), 2);
 %! assert (i, [1, 1; 1, 1]);
 %! assert (ndims(i), 2);
 
 
 */
 
-#define CUMMINMAX_BODY(FCN) \
- \
-  octave_value_list retval;  \
- \
-  int nargin = args.length (); \
- \
-  if (nargin < 1 || nargin > 2 || nargout > 2) \
-    { \
-      print_usage (); \
-      return retval; \
-    } \
- \
-  octave_value arg1; \
-  octave_value arg2; \
- \
-  switch (nargin) \
-    { \
-    case 2: \
-      arg2 = args(1); \
- \
-    case 1: \
-      arg1 = args(0); \
-      break; \
- \
-    default: \
-      panic_impossible (); \
-      break; \
-    } \
- \
-  int dim; \
-  dim_vector dv = arg1.dims (); \
-  if (error_state) \
-    { \
-      gripe_wrong_type_arg (#FCN, arg1);  \
-      return retval; \
-    } \
- \
-  if (nargin == 2) \
-    { \
-      dim = arg2.nint_value () - 1;  \
-      if (dim < 0 || dim >= dv.length ()) \
-        { \
-	  error ("%s: invalid dimension", #FCN); \
-	  return retval; \
-	} \
-    } \
-  else \
-    { \
-      dim = 0; \
-      while ((dim < dv.length ()) && (dv (dim) <= 1)) \
-	dim++; \
-      if (dim == dv.length ()) \
-	dim = 0; \
-    } \
- \
-  if (arg1.is_integer_type ()) \
-    { \
-      if (arg1.is_uint8_type ()) \
-        MINMAX_INT_SBODY (FCN, uint8) \
-      else if (arg1.is_uint16_type ()) \
-        MINMAX_INT_SBODY (FCN, uint16) \
-      else if (arg1.is_uint32_type ()) \
-        MINMAX_INT_SBODY (FCN, uint32) \
-      else if (arg1.is_uint64_type ()) \
-        MINMAX_INT_SBODY (FCN, uint64) \
-      else if (arg1.is_int8_type ()) \
-        MINMAX_INT_SBODY (FCN, int8) \
-      else if (arg1.is_int16_type ()) \
-        MINMAX_INT_SBODY (FCN, int16) \
-      else if (arg1.is_int32_type ()) \
-        MINMAX_INT_SBODY (FCN, int32) \
-      else if (arg1.is_int64_type ()) \
-        MINMAX_INT_SBODY (FCN, int64) \
-    } \
-  else if (arg1.is_single_type ()) \
-    MINMAX_SINGLE_SBODY (FCN) \
-  else \
-    MINMAX_DOUBLE_SBODY (FCN) \
- \
- return retval;
+template <class ArrayType>
+static octave_value_list
+do_cumminmax_red_op (const octave_value& arg,
+                     int nargout, int dim, bool ismin)
+{
+  octave_value_list retval;
+  ArrayType array = octave_value_extract<ArrayType> (arg);
+
+  if (error_state)
+    return retval;
+
+  if (nargout == 2)
+    {
+      retval.resize (2);
+      Array<octave_idx_type> idx;
+      if (ismin)
+        retval(0) = array.cummin (idx, dim);
+      else
+        retval(0) = array.cummax (idx, dim);
+
+      retval(1) = octave_value (idx, true, true);
+    }
+  else
+    {
+      if (ismin)
+        retval(0) = array.cummin (dim);
+      else
+        retval(0) = array.cummax (dim);
+    }
+
+  return retval;
+}
+
+static octave_value_list
+do_cumminmax_body (const octave_value_list& args,
+                   int nargout, bool ismin)
+{
+  octave_value_list retval;
+
+  const char *func = ismin ? "cummin" : "cummax";
+
+  int nargin = args.length ();
+
+  if (nargin == 1 || nargin == 2)
+    {
+      octave_value arg = args(0);
+      int dim = -1;
+      if (nargin == 2)
+        {
+          dim = args(1).int_value (true) - 1;
+          if (error_state || dim < 0)
+            {
+              error ("%s: invalid dimension", func);
+              return retval;
+            }
+        }
+
+      switch (arg.builtin_type ())
+        {
+        case btyp_double:
+          retval = do_cumminmax_red_op<NDArray> (arg, nargout, dim, ismin);
+          break;
+        case btyp_complex:
+          retval = do_cumminmax_red_op<ComplexNDArray> (arg, nargout, dim, ismin);
+          break;
+        case btyp_float:
+          retval = do_cumminmax_red_op<FloatNDArray> (arg, nargout, dim, ismin);
+          break;
+        case btyp_float_complex:
+          retval = do_cumminmax_red_op<FloatComplexNDArray> (arg, nargout, dim, ismin);
+          break;
+#define MAKE_INT_BRANCH(X) \
+        case btyp_ ## X: \
+          retval = do_cumminmax_red_op<X ## NDArray> (arg, nargout, dim, ismin); \
+          break;
+        MAKE_INT_BRANCH (int8);
+        MAKE_INT_BRANCH (int16);
+        MAKE_INT_BRANCH (int32);
+        MAKE_INT_BRANCH (int64);
+        MAKE_INT_BRANCH (uint8);
+        MAKE_INT_BRANCH (uint16);
+        MAKE_INT_BRANCH (uint32);
+        MAKE_INT_BRANCH (uint64);
+#undef MAKE_INT_BRANCH
+        default:
+          gripe_wrong_type_arg (func, arg);
+      }
+    }
+  else
+    print_usage ();
+
+  return retval;
+}
 
 DEFUN_DLD (cummin, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} cummin (@var{x})\n\
 @deftypefnx {Loadable Function} {} cummin (@var{x}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} cummin (@var{x})\n\
 Return the cumulative minimum values along dimension @var{dim}.  If @var{dim}\n\
 is unspecified it defaults to column-wise operation.  For example,\n\
@@ -950,17 +553,17 @@ endfor\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 but computed in a much faster manner.\n\
 @seealso{cummax, min, max}\n\
 @end deftypefn")
 {
-  CUMMINMAX_BODY (cummin);
+  return do_cumminmax_body (args, nargout, true);
 }
 
 DEFUN_DLD (cummax, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} cummax (@var{x})\n\
 @deftypefnx {Loadable Function} {} cummax (@var{x}, @var{dim})\n\
 @deftypefnx {Loadable Function} {[@var{w}, @var{iw}] =} cummax (@var{x})\n\
 Return the cumulative maximum values along dimension @var{dim}.  If @var{dim}\n\
@@ -991,16 +594,16 @@ endfor\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 but computed in a much faster manner.\n\
 @seealso{cummin, max, min}\n\
 @end deftypefn")
 {
-  CUMMINMAX_BODY (cummax);
+  return do_cumminmax_body (args, nargout, false);
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -49,16 +49,40 @@ along with Octave; see the file COPYING.
 #include "ov-re-mat.h"
 #include "ov-scalar.h"
 #include "ov-str-mat.h"
 #include "ov-fcn-handle.h"
 #include "parse.h"
 #include "utils.h"
 #include "variables.h"
 
+builtin_type_t btyp_mixed_numeric (builtin_type_t x, builtin_type_t y)
+{
+  builtin_type_t retval = btyp_unknown;
+
+  if (x == btyp_bool)
+    x = btyp_double;
+  if (y == btyp_bool)
+    y = btyp_double;
+
+  if (x <= btyp_float_complex && y <= btyp_float_complex)
+    retval = static_cast<builtin_type_t> (x | y);
+  else if (x <= btyp_uint64 && y <= btyp_float)
+    retval = x;
+  else if (x <= btyp_float && y <= btyp_uint64)
+    retval = y;
+  else if ((x >= btyp_int8 && x <= btyp_int64 
+            && y >= btyp_int8 && y <= btyp_int64)
+           || (x >= btyp_uint8 && x <= btyp_uint64
+               && y >= btyp_uint8 && y <= btyp_uint64))
+    retval = (x > y) ? x : y;
+
+  return retval;
+}
+
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_base_value,
 				     "<unknown type>", "unknown");
 
 // TRUE means to perform automatic sparse to real mutation if there
 // is memory to be saved
 bool Vsparse_auto_mutate = false;
 
 octave_value
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -64,22 +64,38 @@ enum builtin_type_t
   btyp_int8,
   btyp_int16,
   btyp_int32,
   btyp_int64,
   btyp_uint8,
   btyp_uint16,
   btyp_uint32,
   btyp_uint64,
+  btyp_bool,
   btyp_char,
-  btyp_bool,
   btyp_unknown,
   btyp_num_types = btyp_unknown
 };
 
+inline bool btyp_isnumeric (builtin_type_t btyp)
+{ return btyp <= btyp_uint64; }
+
+// Compute a numeric type for a possibly mixed-type operation, using these rules:
+// bool -> double
+// single + double -> single
+// real + complex -> complex
+// integer + real -> integer
+// uint + uint -> uint (the bigger one)
+// sint + sint -> sint (the bigger one)
+//
+// failing otherwise.
+
+extern OCTINTERP_API
+builtin_type_t btyp_mixed_numeric (builtin_type_t x, builtin_type_t y);
+
 template <class T>
 struct class_to_btyp
 {
   static const builtin_type_t btyp = btyp_unknown;
 };
 
 #define DEF_CLASS_TO_BTYP(CLASS,BTYP) \
 template <> \
