# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1497455147 14400
#      Wed Jun 14 11:45:47 2017 -0400
# Node ID 18bd46c4b79aa62fd799d80b8a378e750b59c11e
# Parent  214cb58ccc1cef53c0e896edda5a9a178d4b9157
make symbol table context info mostly local to symbol table scopes

The context of a symbol table is used to handle recursion.  A new
context is created in a scope when a function is called recursively.
In the past, we managed the context globally.  Now it is local to the
scope and does not need to be passed to functions that access symbol
record data.

diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -951,17 +951,17 @@ do_save (std::ostream& os, const octave_
 }
 
 // Save the info from SR on stream OS in the format specified by FMT.
 
 void
 do_save (std::ostream& os, const symbol_table::symbol_record& sr,
          load_save_format fmt, bool save_as_floats)
 {
-  octave_value val = sr.varval (0);
+  octave_value val = sr.varval ();
 
   if (val.is_defined ())
     {
       std::string name = sr.name ();
       std::string help;
       bool global = sr.is_global ();
 
       do_save (os, val, name, help, global, fmt, save_as_floats);
@@ -1317,23 +1317,23 @@ static void
 dump_octave_core (std::ostream& os, const char *fname, load_save_format fmt,
                   bool save_as_floats)
 {
   write_header (os, fmt);
 
   symbol_table& symtab = octave::__get_symbol_table__ ("dump_octave_core");
 
   std::list<symbol_table::symbol_record> vars
-    = symtab.all_variables (symtab.top_scope (), 0);
+    = symtab.all_variables (symtab.top_scope ());
 
   double save_mem_size = 0;
 
   for (const auto& var : vars)
     {
-      octave_value val = var.varval (0);
+      octave_value val = var.varval ();
 
       if (val.is_defined ())
         {
           std::string name = var.name ();
           std::string help;
           bool global = var.is_global ();
 
           double val_size = val.byte_size () / 1024;
diff --git a/libinterp/corefcn/oct-lvalue.cc b/libinterp/corefcn/oct-lvalue.cc
--- a/libinterp/corefcn/oct-lvalue.cc
+++ b/libinterp/corefcn/oct-lvalue.cc
@@ -29,22 +29,20 @@ along with Octave; see the file COPYING.
 #include "oct-lvalue.h"
 #include "ov.h"
 
 void
 octave_lvalue::assign (octave_value::assign_op op, const octave_value& rhs)
 {
   if (! is_black_hole ())
     {
-      symbol_table::context_id context = sym.context ();
-
       if (idx.empty ())
-        sym->assign (op, rhs, context);
+        sym->assign (op, rhs);
       else
-        sym->assign (op, type, idx, rhs, context);
+        sym->assign (op, type, idx, rhs);
     }
 }
 
 void
 octave_lvalue::set_index (const std::string& t,
                           const std::list<octave_value_list>& i)
 {
   if (! idx.empty ())
@@ -69,35 +67,31 @@ octave_lvalue::index_is_empty (void) con
   return retval;
 }
 
 void
 octave_lvalue::do_unary_op (octave_value::unary_op op)
 {
   if (! is_black_hole ())
     {
-      symbol_table::context_id context = sym.context ();
-
       if (idx.empty ())
-        sym->do_non_const_unary_op (op, context);
+        sym->do_non_const_unary_op (op);
       else
-        sym->do_non_const_unary_op (op, type, idx, context);
+        sym->do_non_const_unary_op (op, type, idx);
     }
 }
 
 octave_value
 octave_lvalue::value (void) const
 {
   octave_value retval;
 
   if (! is_black_hole ())
     {
-      symbol_table::context_id context = sym.context ();
-
-      octave_value val = sym->varval (context);
+      octave_value val = sym->varval ();
 
       if (idx.empty ())
         retval = val;
       else
         {
           if (val.is_constant ())
             retval = val.subsref (type, idx);
           else
diff --git a/libinterp/corefcn/oct-lvalue.h b/libinterp/corefcn/oct-lvalue.h
--- a/libinterp/corefcn/oct-lvalue.h
+++ b/libinterp/corefcn/oct-lvalue.h
@@ -61,38 +61,27 @@ public:
   }
 
   ~octave_lvalue (void) = default;
 
   bool is_black_hole (void) const { return sym.is_black_hole (); }
 
   bool is_defined (void) const
   {
-    symbol_table::context_id context = sym.context ();
-    return ! is_black_hole () && sym->is_defined (context);
+    return ! is_black_hole () && sym->is_defined ();
   }
 
   bool is_undefined (void) const
   {
-    symbol_table::context_id context = sym.context ();
-    return is_black_hole () || sym->is_undefined (context);
+    return is_black_hole () || sym->is_undefined ();
   }
 
-  bool isstruct (void) const
-  {
-    return value().isstruct ();
-  }
+  bool isstruct (void) const { return value().isstruct (); }
 
-  void define (const octave_value& v)
-  {
-    symbol_table::scope *scope = sym.scope ();
-    symbol_table::context_id context = sym.context ();
-
-    sym->assign (v, context);
-  }
+  void define (const octave_value& v) { sym->assign (v); }
 
   void assign (octave_value::assign_op, const octave_value&);
 
   void numel (octave_idx_type n) { nel = n; }
 
   octave_idx_type numel (void) const { return nel; }
 
   void set_index (const std::string& t, const std::list<octave_value_list>& i);
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -65,36 +65,36 @@ symbol_table::symbol_record::symbol_reco
       if (is_global ())
         unmark_global ();
 
       symbol_table& symtab
         = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::clear");
 
       if (is_persistent ())
         {
-          symtab.persistent_assign (name, varval (symtab.current_context ()));
+          symtab.persistent_assign (name, varval ());
 
           unmark_persistent ();
         }
 
-      assign (octave_value (), symtab.current_context ());
+      assign (octave_value ());
     }
 }
 
 void
 symbol_table::symbol_record::symbol_record_rep::init_persistent (void)
 {
   symbol_table& symtab
     = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::init_persistent");
 
-  if (! is_defined (symtab.current_context ()))
+  if (! is_defined ())
     {
       mark_persistent ();
 
-      assign (symtab.persistent_varval (name), symtab.current_context ());
+      assign (symtab.persistent_varval (name));
     }
   // FIXME: this causes trouble with recursive calls.
   // else
   //   error ("unable to declare existing variable persistent");
 }
 
 void
 symbol_table::symbol_record::symbol_record_rep::erase_persistent (void)
@@ -109,29 +109,27 @@ symbol_table::symbol_record::symbol_reco
 }
 
 symbol_table::symbol_record::symbol_record_rep *
 symbol_table::symbol_record::symbol_record_rep::dup (scope *new_scope) const
 {
   symbol_table& symtab
     = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::dup");
 
-  return new symbol_record_rep (new_scope, name,
-                                varval (symtab.current_context ()),
-                                storage_class);
+  return new symbol_record_rep (new_scope, name, varval (), storage_class);
 }
 
 void
 symbol_table::symbol_record::symbol_record_rep::dump
   (std::ostream& os, const std::string& prefix) const
 {
   symbol_table& symtab
     = octave::__get_symbol_table__ ("symbol_table::symbol_record::symbol_record_rep::dump");
 
-  octave_value val = varval (symtab.current_context ());
+  octave_value val = varval ();
 
   os << prefix << name;
 
   if (val.is_defined ())
     {
       os << " ["
          << (is_local () ? "l" : "")
          << (is_automatic () ? "a" : "")
@@ -202,17 +200,17 @@ symbol_table::symbol_record::find (const
 
   symbol_table& symtab
     = octave::__get_symbol_table__ ("symbol_table::symbol_record::find");
 
   if (is_global ())
     retval = symtab.global_varval (name ());
   else
     {
-      retval = varval (symtab.current_context ());
+      retval = varval ();
 
       if (retval.is_undefined ())
         {
 #if 0
           // Use cached fcn_info pointer if possible.
           if (rep->finfo)
             retval = rep->finfo->find (args);
           else
@@ -1525,17 +1523,17 @@ symbol_table::scope::find (const std::st
       if (p != m_symbols.end ())
         {
           symbol_record sr = p->second;
 
           if (sr.is_global ())
             return symtab.global_varval (name);
           else
             {
-              octave_value val = sr.varval (m_context);
+              octave_value val = sr.varval ();
 
               if (val.is_defined ())
                 return val;
             }
         }
     }
 
   if (local_funcs)
@@ -1591,16 +1589,39 @@ symbol_table::scope::builtin_find (const
         symtab.m_fcn_table[name] = finfo;
 
       return fcn;
     }
 
   return retval;
 }
 
+symbol_table::symbol_record&
+symbol_table::scope::insert (const std::string& name, bool force_add)
+{
+  table_iterator p = m_symbols.find (name);
+
+  if (p == m_symbols.end ())
+    {
+      symbol_table::symbol_record ret (this, name);
+
+      if (m_is_nested && m_parent && m_parent->look_nonlocal (name, ret))
+        return m_symbols[name] = ret;
+      else
+        {
+          if (m_is_static && ! force_add)
+            ret.mark_added_static ();
+
+          return m_symbols[name] = ret;
+        }
+    }
+  else
+    return p->second;
+}
+
 void
 symbol_table::scope::clear_global (const std::string& name)
 {
   table_iterator p = m_symbols.find (name);
 
   if (p != m_symbols.end ())
     {
       symbol_table::symbol_record& sr = p->second;
@@ -1653,17 +1674,17 @@ symbol_table::scope::workspace_info (voi
 
   for (const auto& nm_sr : m_symbols)
     {
       std::string nm = nm_sr.first;
       symbol_record sr = nm_sr.second;
 
       if (! sr.is_hidden ())
         {
-          octave_value val = sr.varval (m_context);
+          octave_value val = sr.varval ();
 
           if (val.is_defined ())
             {
               // FIXME: fix size for objects, see kluge in variables.cc
               //dim_vector dv = val.dims ();
               octave_value tmp = val;
               Matrix sz = tmp.size ();
               dim_vector dv = dim_vector::alloc (sz.numel ());
@@ -1811,16 +1832,17 @@ symbol_table::scope::update_nest (void)
 {
   if (m_parent)
     {
       // fix bad symbol_records
       for (auto& nm_sr : m_symbols)
         {
           symbol_record& ours = nm_sr.second;
           symbol_record parents;
+
           if (! ours.is_formal ()
               && m_is_nested && m_parent->look_nonlocal (nm_sr.first, parents))
             {
               if (ours.is_global () || ours.is_persistent ())
                 error ("global and persistent may only be used in the topmost level in which a nested variable is used");
 
               if (! ours.is_formal ())
                 {
@@ -1838,16 +1860,35 @@ symbol_table::scope::update_nest (void)
       for (auto& nm_sr : m_symbols)
         nm_sr.second.set_curr_fcn (m_fcn);
     }
 
   for (auto& symtab_p : m_children)
     symtab_p->update_nest ();
 }
 
+bool
+symbol_table::scope::look_nonlocal (const std::string& name,
+                                    symbol_table::symbol_record& result)
+{
+  table_iterator p = m_symbols.find (name);
+  if (p == m_symbols.end ())
+    {
+      if (m_is_nested && m_parent)
+        return m_parent->look_nonlocal (name, result);
+    }
+  else if (! p->second.is_automatic ())
+    {
+      result = p->second;
+      return true;
+    }
+
+  return false;
+}
+
 DEFUN (ignore_function_time_stamp, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{val} =} ignore_function_time_stamp ()
 @deftypefnx {} {@var{old_val} =} ignore_function_time_stamp (@var{new_val})
 Query or set the internal variable that controls whether Octave checks
 the time stamp on files each time it looks up functions defined in
 function files.
 
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -105,68 +105,70 @@ public:
       // No copying!
 
       symbol_record_rep (const symbol_record_rep& ov) = delete;
 
       symbol_record_rep& operator = (const symbol_record_rep&) = delete;
 
       ~symbol_record_rep (void) = default;
 
-      void assign (const octave_value& value, context_id context)
+      void assign (const octave_value& value)
       {
-        varref (context) = value;
+        varref () = value;
       }
 
       void assign (octave_value::assign_op op,
                    const std::string& type,
                    const std::list<octave_value_list>& idx,
-                   const octave_value& value,
-                   context_id context)
+                   const octave_value& value)
       {
-        varref(context).assign (op, type, idx, value);
+        varref().assign (op, type, idx, value);
       }
 
-      void assign (octave_value::assign_op op, const octave_value& value,
-                   context_id context)
+      void assign (octave_value::assign_op op, const octave_value& value)
       {
-        varref(context).assign (op, value);
+        varref().assign (op, value);
       }
 
-      void do_non_const_unary_op (octave_value::unary_op op,
-                                  context_id context)
+      void do_non_const_unary_op (octave_value::unary_op op)
       {
-        varref(context).do_non_const_unary_op (op);
+        varref().do_non_const_unary_op (op);
       }
 
       void do_non_const_unary_op (octave_value::unary_op op,
                                   const std::string& type,
-                                  const std::list<octave_value_list>& idx,
-                                  context_id context)
+                                  const std::list<octave_value_list>& idx)
       {
-        varref(context).do_non_const_unary_op (op, type, idx);
+        varref().do_non_const_unary_op (op, type, idx);
       }
 
-      octave_value& varref (context_id context)
+      octave_value& varref (void)
       {
+        context_id context
+          = m_decl_scope ? m_decl_scope->current_context () : 0;
+
         if (is_global ())
           return xglobal_varref ();
         else if (is_persistent ())
           return xpersistent_varref ();
         else
           {
             context_id n = value_stack.size ();
             while (n++ <= context)
               value_stack.push_back (octave_value ());
 
             return value_stack[context];
           }
       }
 
-      octave_value varval (context_id context) const
+      octave_value varval (void) const
       {
+        context_id context
+          = m_decl_scope ? m_decl_scope->current_context () : 0;
+
         if (is_global ())
           return xglobal_varval ();
         else if (is_persistent ())
           return xpersistent_varval ();
         else
           {
             if (context < value_stack.size ())
               return value_stack[context];
@@ -209,29 +211,29 @@ public:
 
         return retval;
       }
 
       void clear (void) { clear (decl_scope ()); }
 
       void clear (const scope *sid);
 
-      bool is_defined (context_id context) const
+      bool is_defined (void) const
       {
-        return varval (context).is_defined ();
+        return varval ().is_defined ();
       }
 
       bool is_valid (void) const
       {
         return valid;
       }
 
-      bool is_variable (context_id context) const
+      bool is_variable (void) const
       {
-        return (! is_local () || is_defined (context));
+        return (! is_local () || is_defined ());
       }
 
       bool is_local (void) const { return storage_class & local; }
       bool is_automatic (void) const { return storage_class & automatic; }
       bool is_formal (void) const { return storage_class & formal; }
       bool is_hidden (void) const { return storage_class & hidden; }
       bool is_inherited (void) const { return storage_class & inherited; }
       bool is_global (void) const { return storage_class & global; }
@@ -357,87 +359,83 @@ public:
 
     const std::string& name (void) const { return rep->name; }
 
     void rename (const std::string& new_name) { rep->name = new_name; }
 
     octave_value
     find (const octave_value_list& args = octave_value_list ()) const;
 
-    void assign (const octave_value& value, context_id context)
+    void assign (const octave_value& value)
     {
-      rep->assign (value, context);
+      rep->assign (value);
     }
 
     void assign (octave_value::assign_op op,
                  const std::string& type,
                  const std::list<octave_value_list>& idx,
-                 const octave_value& value,
-                 context_id context)
+                 const octave_value& value)
     {
-      rep->assign (op, type, idx, value, context);
+      rep->assign (op, type, idx, value);
     }
 
-    void assign (octave_value::assign_op op, const octave_value& value,
-                 context_id context)
+    void assign (octave_value::assign_op op, const octave_value& value)
     {
-      rep->assign (op, value, context);
+      rep->assign (op, value);
     }
 
-    void do_non_const_unary_op (octave_value::unary_op op,
-                                context_id context)
+    void do_non_const_unary_op (octave_value::unary_op op)
     {
-      rep->do_non_const_unary_op (op, context);
+      rep->do_non_const_unary_op (op);
     }
 
     void do_non_const_unary_op (octave_value::unary_op op,
                                 const std::string& type,
-                                const std::list<octave_value_list>& idx,
-                                context_id context)
+                                const std::list<octave_value_list>& idx)
     {
-      rep->do_non_const_unary_op (op, type, idx, context);
+      rep->do_non_const_unary_op (op, type, idx);
     }
 
     // Delete when deprecated varref functions are removed.
-    octave_value& varref (context_id context)
+    octave_value& varref (void)
     {
-      return rep->varref (context);
+      return rep->varref ();
     }
 
-    octave_value varval (context_id context) const
+    octave_value varval (void) const
     {
-      return rep->varval (context);
+      return rep->varval ();
     }
 
     void push_context (scope *sid) { rep->push_context (sid); }
 
     size_t pop_context (scope *sid) { return rep->pop_context (sid); }
 
     void clear (void) { rep->clear (); }
 
     void clear (const scope *sid) { rep->clear (sid); }
 
-    bool is_defined (context_id context) const
+    bool is_defined (void) const
     {
-      return rep->is_defined (context);
+      return rep->is_defined ();
     }
 
-    bool is_undefined (context_id context) const
+    bool is_undefined (void) const
     {
-      return ! rep->is_defined (context);
+      return ! rep->is_defined ();
     }
 
     bool is_valid (void) const
     {
       return rep->is_valid ();
     }
 
-    bool is_variable (context_id context) const
+    bool is_variable (void) const
     {
-      return rep->is_variable (context);
+      return rep->is_variable ();
     }
 
     bool is_local (void) const { return rep->is_local (); }
     bool is_automatic (void) const { return rep->is_automatic (); }
     bool is_formal (void) const { return rep->is_formal (); }
     bool is_global (void) const { return rep->is_global (); }
     bool is_hidden (void) const { return rep->is_hidden (); }
     bool is_inherited (void) const { return rep->is_inherited (); }
@@ -475,16 +473,18 @@ public:
     void set_curr_fcn (octave_user_function *fcn) { rep->set_curr_fcn (fcn); }
 
     void
     dump (std::ostream& os, const std::string& prefix = "") const
     {
       rep->dump (os, prefix);
     }
 
+    const symbol_record_rep *xrep (void) const { return rep; }
+
   private:
 
     symbol_record_rep *rep;
 
     symbol_record (symbol_record_rep *new_rep) : rep (new_rep) { }
   };
 
   static symbol_record dummy_symbol_record;
@@ -496,17 +496,17 @@ public:
   {
   public:
 
     symbol_reference (void) : m_scope (0), m_context (0) { }
 
     symbol_reference (const symbol_record& record);
 
     symbol_reference (const symbol_record& record, scope *curr_scope,
-                      context_id context = 0)
+                      context_id context)
       : m_scope (curr_scope), m_context (context), m_sym (record)
     { }
 
     symbol_reference (const symbol_reference& ref) = default;
 
     symbol_reference& operator = (const symbol_reference& ref) = default;
 
     bool is_black_hole (void) const { return ! m_scope; }
@@ -934,60 +934,49 @@ public:
 
   void mark_nested (scope *sid)
   {
     if (sid)
       sid->mark_nested ();
   }
 
   void
-    mark_subfunctions_in_scope_as_private (scope *sid,
-                                           const std::string& class_name)
+  mark_subfunctions_in_scope_as_private (scope *sid,
+                                         const std::string& class_name)
   {
     if (sid)
       sid->mark_subfunctions_in_scope_as_private (class_name);
   }
 
-  symbol_record
-    find_symbol (const std::string& name, scope *sid)
+  symbol_record find_symbol (const std::string& name, scope *sid)
   {
     return sid ? sid->find_symbol (name) : symbol_record ();
   }
 
   symbol_record find_symbol (const std::string& name)
   {
     return find_symbol (name, m_current_scope);
   }
 
-  void
-    inherit (scope *recipient_scope, scope *donor_scope,
-             context_id donor_context)
+  void inherit (scope *recipient_scope, scope *donor_scope)
   {
     if (recipient_scope)
       {
         while (donor_scope)
           {
-            recipient_scope->inherit (*donor_scope, donor_context);
+            recipient_scope->inherit (*donor_scope);
 
             if (donor_scope->is_nested ())
               donor_scope = donor_scope->parent_scope ();
             else
               break;
           }
       }
   }
 
-  void
-  inherit (scope *sid, scope *donor_sid)
-  {
-    context_id donor_context = donor_sid ? donor_sid->current_context () : 0;
-
-    inherit (sid, donor_sid, donor_context);
-  }
-
   void inherit (scope *sid)
   {
     inherit (sid, m_current_scope);
   }
 
   bool at_top_level (void) { return m_current_scope == m_top_scope; }
 
   // Find a value corresponding to the given name in the table.
@@ -1015,32 +1004,25 @@ public:
 
   void rename (const std::string& old_name, const std::string& new_name)
   {
     if (m_current_scope)
       m_current_scope->rename (old_name, new_name);
   }
 
   void assign (const std::string& name, const octave_value& value,
-               scope *sid, context_id context, bool force_add)
+               scope *sid, bool force_add)
   {
     if (sid)
-      sid->assign (name, value, context, force_add);
+      sid->assign (name, value, force_add);
   }
 
-  void assign (const std::string& name, const octave_value& value,
-               scope *sid, context_id context)
+  void assign (const std::string& name, const octave_value& value, scope *sid)
   {
-    assign (name, value, sid, context, false);
-  }
-
-  void assign (const std::string& name, const octave_value& value,
-               scope *sid)
-  {
-    assign (name, value, sid, m_current_scope->current_context ());
+    assign (name, value, sid, false);
   }
 
   void assign (const std::string& name,
                const octave_value& value = octave_value ())
   {
     assign (name, value, m_current_scope);
   }
 
@@ -1048,47 +1030,35 @@ public:
   // octave_value&
   // varref (const std::string& name, scope_id sid = xcurrent_scope,
   //         context_id context = xdefault_context, bool force_add = false);
 
   // Convenience function to simplify
   // octave_user_function::bind_automatic_vars
 
   void force_assign (const std::string& name, const octave_value& value,
-                     scope *sid, context_id context)
-  {
-    assign (name, value, sid, context, true);
-  }
-
-  void force_assign (const std::string& name, const octave_value& value,
                      scope *sid)
   {
-    assign (name, value, sid, m_current_scope->current_context ());
+    assign (name, value, sid, true);
   }
 
   void force_assign (const std::string& name,
                      const octave_value& value = octave_value ())
   {
     assign (name, value, m_current_scope);
   }
 
   // use 'force_assign' instead
   // octave_value&
   // force_varref (const std::string& name, scope_id sid = xcurrent_scope,
   //               context_id context = xdefault_context);
 
-  octave_value varval (const std::string& name, scope *sid,
-                       context_id context)
-  {
-    return sid ? sid->varval (name, context) : octave_value ();
-  }
-
   octave_value varval (const std::string& name, scope *sid)
   {
-    return varval (name, sid, m_current_scope->current_context ());
+    return sid ? sid->varval (name) : octave_value ();
   }
 
   octave_value varval (const std::string& name)
   {
     return varval (name, m_current_scope);
   }
 
   void
@@ -1115,27 +1085,27 @@ public:
 
     return (p != m_global_symbols.end ()) ? p->second : octave_value ();
   }
 
   void
   top_level_assign (const std::string& name,
                     const octave_value& value = octave_value ())
   {
-    assign (name, value, top_scope (), 0);
+    assign (name, value, top_scope ());
   }
 
   // use 'top_level_assign' instead
   // octave_value&
   // top_level_varref (const std::string& name);
 
   octave_value
   top_level_varval (const std::string& name)
   {
-    return varval (name, top_scope (), 0);
+    return varval (name, top_scope ());
   }
 
   void
   persistent_assign (const std::string& name, scope *sid,
                      const octave_value& value = octave_value ())
   {
     if (sid)
       sid->persistent_assign (name, value);
@@ -1590,40 +1560,33 @@ public:
   void mark_global (const std::string& name)
   {
     if (m_current_scope)
       m_current_scope->mark_global (name);
   }
 
   // exclude: Storage classes to exclude, you can OR them together
   std::list<symbol_record>
-  all_variables (scope *sid, context_id context, bool defined_only,
-                 unsigned int exclude)
+  all_variables (scope *sid, bool defined_only, unsigned int exclude)
   {
     return (sid
-            ? sid->all_variables (context, defined_only, exclude)
+            ? sid->all_variables (defined_only, exclude)
             : std::list<symbol_record> ());
   }
 
   std::list<symbol_record>
-  all_variables (scope *sid, context_id context, bool defined_only)
+  all_variables (scope *sid, bool defined_only)
   {
-    return all_variables (sid, context, defined_only, symbol_record::hidden);
-  }
-
-  std::list<symbol_record>
-  all_variables (scope *sid, context_id context)
-  {
-    return all_variables (sid, context, true);
+    return all_variables (sid, defined_only, symbol_record::hidden);
   }
 
   std::list<symbol_record>
   all_variables (scope *sid)
   {
-    return all_variables (sid, m_current_scope->current_context ());
+    return all_variables (sid, true);
   }
 
   std::list<symbol_record>
   all_variables (void)
   {
     return all_variables (m_current_scope);
   }
 
@@ -1988,69 +1951,49 @@ public:
       table_iterator p = m_symbols.find (name);
 
       if (p == m_symbols.end ())
         return insert (name);
       else
         return p->second;
     }
 
-    void inherit (scope& donor_table, context_id donor_context)
+    void inherit (scope& donor_scope)
     {
       for (auto& nm_sr : m_symbols)
         {
           symbol_table::symbol_record& sr = nm_sr.second;
 
           if (! (sr.is_automatic () || sr.is_formal ()))
             {
               std::string nm = sr.name ();
 
               if (nm != "__retval__")
                 {
-                  octave_value val = donor_table.varval (nm, donor_context);
+                  octave_value val = donor_scope.varval (nm);
 
                   if (val.is_defined ())
                     {
-                      sr.assign (val, 0);
+                      sr.assign (val);
 
                       sr.mark_inherited ();
                     }
                 }
             }
         }
     }
 
     octave_value
     find (const std::string& name, const octave_value_list& args,
           bool skip_variables, bool local_funcs);
 
     octave_value builtin_find (const std::string& name);
 
     symbol_table::symbol_record&
-    insert (const std::string& name, bool force_add = false)
-    {
-      table_iterator p = m_symbols.find (name);
-
-      if (p == m_symbols.end ())
-        {
-          symbol_table::symbol_record ret (this, name);
-
-          if (m_is_nested && m_parent && m_parent->look_nonlocal (name, ret))
-            return m_symbols[name] = ret;
-          else
-            {
-              if (m_is_static && ! force_add)
-                ret.mark_added_static ();
-
-              return m_symbols[name] = ret;
-            }
-        }
-      else
-        return p->second;
-    }
+    insert (const std::string& name, bool force_add = false);
 
     void rename (const std::string& old_name, const std::string& new_name)
     {
       table_iterator p = m_symbols.find (old_name);
 
       if (p != m_symbols.end ())
         {
           symbol_table::symbol_record sr = p->second;
@@ -2059,105 +2002,72 @@ public:
 
           m_symbols.erase (p);
 
           m_symbols[new_name] = sr;
         }
     }
 
     void assign (const std::string& name, const octave_value& value,
-                 context_id context, bool force_add)
+                 bool force_add)
     {
       table_iterator p = m_symbols.find (name);
 
       if (p == m_symbols.end ())
         {
           symbol_table::symbol_record& sr = insert (name, force_add);
 
-          sr.assign (value, context);
+          sr.assign (value);
         }
       else
-        p->second.assign (value, context);
-    }
-
-    void assign (const std::string& name, const octave_value& value,
-                 context_id context)
-    {
-      table_iterator p = m_symbols.find (name);
-
-      if (p == m_symbols.end ())
-        {
-          symbol_table::symbol_record& sr = insert (name, false);
-
-          sr.assign (value, context);
-        }
-      else
-        p->second.assign (value, context);
+        p->second.assign (value);
     }
 
     void assign (const std::string& name,
                  const octave_value& value = octave_value ())
     {
-      table_iterator p = m_symbols.find (name);
-
-      if (p == m_symbols.end ())
-        {
-          symbol_table::symbol_record& sr = insert (name, false);
-
-          sr.assign (value, m_context);
-        }
-      else
-        p->second.assign (value, m_context);
+      assign (name, value, false);
     }
 
     void force_assign (const std::string& name, const octave_value& value)
     {
       table_iterator p = m_symbols.find (name);
 
       if (p == m_symbols.end ())
         {
           symbol_table::symbol_record& sr = insert (name, true);
 
-          sr.assign (value, m_context);
+          sr.assign (value);
         }
       else
-        p->second.assign (value, m_context);
+        p->second.assign (value);
     }
 
-    // Use assign (name, value, context, force_add) instead.
+    // Use assign (name, value, force_add) instead.
     // Delete when deprecated varref functions are removed.
-    octave_value&
-    varref (const std::string& name, context_id context, bool force_add)
+    octave_value& varref (const std::string& name, bool force_add)
     {
       table_iterator p = m_symbols.find (name);
 
       if (p == m_symbols.end ())
         {
           symbol_table::symbol_record& sr = insert (name, force_add);
 
-          return sr.varref (context);
+          return sr.varref ();
         }
       else
-        return p->second.varref (context);
-    }
-
-    octave_value varval (const std::string& name, context_id context) const
-    {
-      table_const_iterator p = m_symbols.find (name);
-
-      return (p != m_symbols.end ()
-              ? p->second.varval (context) : octave_value ());
+        return p->second.varref ();
     }
 
     octave_value varval (const std::string& name) const
     {
       table_const_iterator p = m_symbols.find (name);
 
       return (p != m_symbols.end ()
-              ? p->second.varval (m_context) : octave_value ());
+              ? p->second.varval () : octave_value ());
     }
 
     void persistent_assign (const std::string& name, const octave_value& value)
     {
       m_persistent_symbols_iterator p = m_persistent_symbols.find (name);
 
       if (p == m_persistent_symbols.end ())
         m_persistent_symbols[name] = value;
@@ -2195,17 +2105,17 @@ public:
       bool retval = false;
 
       table_const_iterator p = m_symbols.find (name);
 
       if (p != m_symbols.end ())
         {
           const symbol_table::symbol_record& sr = p->second;
 
-          retval = sr.is_variable (m_context);
+          retval = sr.is_variable ();
         }
 
       return retval;
     }
 
     void push_context (void)
     {
       for (auto& nm_sr : m_symbols)
@@ -2223,67 +2133,67 @@ public:
           else
             tbl_it++;
         }
     }
 
     void clear_variables (void)
     {
       for (auto& nm_sr : m_symbols)
-        nm_sr.second.clear ();
+        nm_sr.second.clear (this);
     }
 
     void clear_objects (void)
     {
       for (auto& nm_sr : m_symbols)
         {
           symbol_table::symbol_record& sr = nm_sr.second;
-          octave_value val = sr.varval (m_context);
-          if (val.is_object ())
-            nm_sr.second.clear ();
+          octave_value val = sr.varval ();
+          if (val.isobject ())
+            nm_sr.second.clear (this);
         }
     }
 
     void clear_global (const std::string& name);
 
     void clear_variable (const std::string& name)
     {
       table_iterator p = m_symbols.find (name);
 
       if (p != m_symbols.end ())
-        p->second.clear ();
+        p->second.clear (this);
     }
 
     void clear_global_pattern (const std::string& pat);
 
     void clear_variable_pattern (const std::string& pat)
     {
       glob_match pattern (pat);
 
       for (auto& nm_sr : m_symbols)
         {
           symbol_table::symbol_record& sr = nm_sr.second;
 
-          if (sr.is_defined (m_context) || sr.is_global ())
+          if (sr.is_defined () || sr.is_global ())
             {
               if (pattern.match (sr.name ()))
                 sr.clear (this);
             }
         }
     }
 
     void clear_variable_regexp (const std::string& pat)
     {
       octave::regexp pattern (pat);
 
       for (auto& nm_sr : m_symbols)
         {
           symbol_table::symbol_record& sr = nm_sr.second;
 
-          if (sr.is_defined (m_context) || sr.is_global ())
+          if (sr.is_defined () || sr.is_global ())
             {
               if (pattern.is_match (sr.name ()))
                 sr.clear (this);
             }
         }
     }
 
     void mark_automatic (const std::string& name)
@@ -2297,26 +2207,25 @@ public:
     }
 
     void mark_global (const std::string& name)
     {
       insert (name).mark_global ();
     }
 
     std::list<symbol_table::symbol_record>
-    all_variables (context_id context, bool defined_only,
-                   unsigned int exclude) const
+    all_variables (bool defined_only, unsigned int exclude) const
     {
       std::list<symbol_table::symbol_record> retval;
 
       for (const auto& nm_sr : m_symbols)
         {
           const symbol_table::symbol_record& sr = nm_sr.second;
 
-          if ((defined_only && ! sr.is_defined (context))
+          if ((defined_only && ! sr.is_defined ())
               || (sr.xstorage_class () & exclude))
             continue;
 
           retval.push_back (sr);
         }
 
       return retval;
     }
@@ -2329,17 +2238,17 @@ public:
       glob_match pat (pattern);
 
       for (const auto& nm_sr : m_symbols)
         {
           if (pat.match (nm_sr.first))
             {
               const symbol_table::symbol_record& sr = nm_sr.second;
 
-              if (vars_only && ! sr.is_variable (m_context))
+              if (vars_only && ! sr.is_variable ())
                 continue;
 
               retval.push_back (sr);
             }
         }
 
       return retval;
     }
@@ -2352,48 +2261,48 @@ public:
       octave::regexp pat (pattern);
 
       for (const auto& nm_sr : m_symbols)
         {
           if (pat.is_match (nm_sr.first))
             {
               const symbol_table::symbol_record& sr = nm_sr.second;
 
-              if (vars_only && ! sr.is_variable (m_context))
+              if (vars_only && ! sr.is_variable ())
                 continue;
 
               retval.push_back (sr);
             }
         }
 
       return retval;
     }
 
     std::list<std::string> variable_names (void)
     {
       std::list<std::string> retval;
 
       for (const auto& nm_sr : m_symbols)
         {
-          if (nm_sr.second.is_variable (m_context))
+          if (nm_sr.second.is_variable ())
             retval.push_back (nm_sr.first);
         }
 
       retval.sort ();
 
       return retval;
     }
 
     bool is_local_variable (const std::string& name) const
     {
       table_const_iterator p = m_symbols.find (name);
 
       return (p != m_symbols.end ()
               && ! p->second.is_global ()
-              && p->second.is_defined (m_context));
+              && p->second.is_defined ());
     }
 
     bool is_global (const std::string& name) const
     {
       table_const_iterator p = m_symbols.find (name);
 
       return p != m_symbols.end () && p->second.is_global ();
     }
@@ -2442,32 +2351,17 @@ public:
 
     void set_function (octave_user_function *fcn) { m_fcn = fcn; }
 
     void set_parent (scope *p) { m_parent = p; }
 
     void update_nest (void);
 
     bool look_nonlocal (const std::string& name,
-                        symbol_table::symbol_record& result)
-    {
-      table_iterator p = m_symbols.find (name);
-      if (p == m_symbols.end ())
-        {
-          if (m_is_nested && m_parent)
-            return m_parent->look_nonlocal (name, result);
-        }
-      else if (! p->second.is_automatic ())
-        {
-          result = p->second;
-          return true;
-        }
-
-      return false;
-    }
+                        symbol_table::symbol_record& result);
 
   private:
 
     // Name for this scope (usually the corresponding filename of the
     // function corresponding to the scope).
     std::string m_name;
 
     // Map from symbol names to symbol info.
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -1187,18 +1187,17 @@ private:
         is_automatic (sr.is_automatic ()),
         is_complex (varval.iscomplex ()),
         is_formal (sr.is_formal ()),
         is_global (sr.is_global ()),
         is_persistent (sr.is_persistent ())
     {
       symbol_table& symtab = octave::__get_symbol_table__ ("symbol_info");
 
-      varval = (expr_val.is_undefined ()
-                ? sr.varval (symtab.current_context ()) : expr_val);
+      varval = (expr_val.is_undefined () ? sr.varval () : expr_val);
 
       is_complex = varval.is_complex_type ();
     }
 
     void display_line (std::ostream& os,
                        const std::list<whos_parameter>& params) const
     {
       std::string dims_str = get_dims_str (varval);
@@ -1755,17 +1754,17 @@ do_who (octave::interpreter& interp, int
       if (have_regexp)
         {
           std::list<symbol_table::symbol_record> tmp = global_only
             ? symtab.regexp_global_variables (pat)
             : symtab.regexp_variables (pat);
 
           for (const auto& symrec : tmp)
             {
-              if (symrec.is_variable (symtab.current_context ()))
+              if (symrec.is_variable ())
                 {
                   if (verbose)
                     symbol_stats.append (symrec);
                   else
                     symbol_names.push_back (symrec.name ());
                 }
             }
         }
@@ -1806,17 +1805,17 @@ do_who (octave::interpreter& interp, int
           else
             {
               std::list<symbol_table::symbol_record> tmp = global_only
                 ? symtab.glob_global_variables (pat)
                 : symtab.glob_variables (pat);
 
               for (const auto& symrec : tmp)
                 {
-                  if (symrec.is_variable (symtab.current_context ()))
+                  if (symrec.is_variable ())
                     {
                       if (verbose)
                         symbol_stats.append (symrec);
                       else
                         symbol_names.push_back (symrec.name ());
                     }
                 }
             }
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -352,27 +352,27 @@ octave_fcn_handle::save_ascii (std::ostr
         return false;
 
       octave_user_function *f = fcn.user_function_value ();
 
       symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_fcn_handle::save_ascii");
 
       std::list<symbol_table::symbol_record> vars
-        = symtab.all_variables (f->scope (), 0);
+        = symtab.all_variables (f->scope ());
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           os << "# length: " << varlen << "\n";
 
           for (const auto& symrec : vars)
             {
-              if (! save_text_data (os, symrec.varval (0), symrec.name (),
+              if (! save_text_data (os, symrec.varval (), symrec.name (),
                                     false, 0))
                 return ! os.fail ();
             }
         }
     }
   else
     {
       octave_function *f = function_value ();
@@ -517,17 +517,17 @@ octave_fcn_handle::save_binary (std::ost
         return false;
 
       octave_user_function *f = fcn.user_function_value ();
 
       symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_fcn_handle::save_binary");
 
       std::list<symbol_table::symbol_record> vars
-        = symtab.all_variables (f->scope (), 0);
+        = symtab.all_variables (f->scope ());
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         nmbuf << nm << " " << varlen;
       else
         nmbuf << nm;
 
@@ -542,17 +542,17 @@ octave_fcn_handle::save_binary (std::ost
       tmp = stmp.length ();
       os.write (reinterpret_cast<char *> (&tmp), 4);
       os.write (stmp.c_str (), stmp.length ());
 
       if (varlen > 0)
         {
           for (const auto& symrec : vars)
             {
-              if (! save_binary_data (os, symrec.varval (0), symrec.name (),
+              if (! save_binary_data (os, symrec.varval (), symrec.name (),
                                       "", 0, save_as_floats))
                 return ! os.fail ();
             }
         }
     }
   else
     {
       std::ostringstream nmbuf;
@@ -795,17 +795,17 @@ octave_fcn_handle::save_hdf5 (octave_hdf
       H5Dclose (data_hid);
 
       octave_user_function *f = fcn.user_function_value ();
 
       symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_fcn_handle::load_hdf5");
 
       std::list<symbol_table::symbol_record> vars
-        = symtab.all_variables (f->scope (), 0);
+        = symtab.all_variables (f->scope ());
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           hid_t as_id = H5Screate (H5S_SCALAR);
 
           if (as_id >= 0)
@@ -844,17 +844,17 @@ octave_fcn_handle::save_hdf5 (octave_hdf
               H5Sclose (space_hid);
               H5Tclose (type_hid);
               H5Gclose (group_hid);
               return false;
             }
 
           for (const auto& symrec : vars)
             {
-              if (! add_hdf5_data (data_hid, symrec.varval (0), symrec.name (),
+              if (! add_hdf5_data (data_hid, symrec.varval (), symrec.name (),
                                    "", false, save_as_floats))
                 break;
             }
           H5Gclose (data_hid);
         }
     }
   else
     {
@@ -1791,25 +1791,25 @@ particular output format.
     {
       m.setfield ("file", nm);
 
       octave_user_function *fu = fh->user_function_value ();
 
       symbol_table& symtab = interp.get_symbol_table ();
 
       std::list<symbol_table::symbol_record> vars
-        = symtab.all_variables (fu->scope (), 0);
+        = symtab.all_variables (fu->scope ());
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           octave_scalar_map ws;
           for (const auto& symrec : vars)
-            ws.assign (symrec.name (), symrec.varval (0));
+            ws.assign (symrec.name (), symrec.varval ());
 
           m.setfield ("workspace", ws);
         }
     }
   else if (fcn->is_user_function () || fcn->is_user_script ())
     {
       octave_function *fu = fh->function_value ();
       m.setfield ("file", fu->fcn_file_name ());
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -1500,16 +1500,20 @@ fcn_name        : identifier
                         parser.bison_error ("duplicate subfunction or nested function name",
                                             $1->line (), $1->column ());
 
                         delete $1;
 
                         YYABORT;
                       }
 
+                    symbol_table::scope *curr_scope
+                      = lexer.symtab_context.curr_scope ();
+                    curr_scope->cache_name (id);
+
                     lexer.parsed_function_name.top () = true;
                     lexer.maybe_classdef_get_set_method = false;
 
                     $$ = $1;
                   }
                 | GET '.' identifier
                   {
                     YYUSE ($1);
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -979,16 +979,19 @@ namespace octave
 
   void
   tree_evaluator::visit_identifier (tree_identifier& expr)
   {
     octave_value_list retval;
 
     symbol_table::symbol_reference sym = expr.symbol ();
 
+    symbol_table::scope *scope = __get_current_scope__ ("visitor");
+    symbol_table::context_id context = scope ? scope->current_context () : 0;
+
     octave_value val = sym->find ();
 
     if (val.is_defined ())
       {
         // GAGME -- this would be cleaner if we required
         // parens to indicate function calls.
         //
         // If this identifier refers to a function, we need to know
diff --git a/libinterp/parse-tree/pt-id.h b/libinterp/parse-tree/pt-id.h
--- a/libinterp/parse-tree/pt-id.h
+++ b/libinterp/parse-tree/pt-id.h
@@ -68,27 +68,19 @@ namespace octave
     bool has_magic_end (void) const { return (name () == "end"); }
 
     bool is_identifier (void) const { return true; }
 
     // The name doesn't change with scope, so use sym instead of
     // accessing it through sym so that this function may remain const.
     std::string name (void) const { return sym.name (); }
 
-    bool is_defined (void)
-    {
-      symbol_table::context_id context = sym.context ();
-      return sym->is_defined (context);
-    }
+    bool is_defined (void) { return sym->is_defined (); }
 
-    virtual bool is_variable (void) const
-    {
-      symbol_table::context_id context = sym.context ();
-      return sym->is_variable (context);
-    }
+    virtual bool is_variable (void) const { return sym->is_variable (); }
 
     virtual bool is_black_hole (void) { return false; }
 
     // Try to find a definition for an identifier.  Here's how:
     //
     //   * If the identifier is already defined and is a function defined
     //     in an function file that has been modified since the last time
     //     we parsed it, parse it again.
