# HG changeset patch
# User Rik <rik@octave.org>
# Date 1515374003 28800
#      Sun Jan 07 17:13:23 2018 -0800
# Node ID fdc9ce839afddd47123079588f4fade44c455f17
# Parent  d3a507ca2d5d9c6bfd3011ab5f581b0128217663
maint: Remove statistics functions which have been shifted to Octave Forge package.

* NEWS: Announce list of functions removed from core.

* scripts/statistics/center.m, scripts/statistics/corr.m,
scripts/statistics/corrcoef.m, scripts/statistics/cov.m,
scripts/statistics/discrete_cdf.m, scripts/statistics/discrete_inv.m,
scripts/statistics/discrete_pdf.m, scripts/statistics/discrete_rnd.m,
scripts/statistics/empirical_cdf.m, scripts/statistics/empirical_inv.m,
scripts/statistics/empirical_pdf.m, scripts/statistics/empirical_rnd.m,
scripts/statistics/histc.m, scripts/statistics/iqr.m,
scripts/statistics/kendall.m, scripts/statistics/kurtosis.m,
scripts/statistics/mean.m, scripts/statistics/meansq.m,
scripts/statistics/median.m, scripts/statistics/mode.m,
scripts/statistics/module.mk, scripts/statistics/moment.m,
scripts/statistics/prctile.m, scripts/statistics/quantile.m,
scripts/statistics/range.m, scripts/statistics/ranks.m,
scripts/statistics/run_count.m, scripts/statistics/runlength.m,
scripts/statistics/skewness.m, scripts/statistics/spearman.m,
scripts/statistics/statistics.m, scripts/statistics/std.m,
scripts/statistics/var.m, scripts/statistics/zscore.m:
Moved from scripts/statistics/base.

* scripts/module.mk: Update build system.  Remove @include for directories
base/, tests/, models/, distributions/.

* octave.texi: Update @detailmenu.

* stats.txi: Rewrite statistics chapter with condensed list of functions.

* scripts/statistics/base/module.mk,
scripts/statistics/distributions/module.mk, scripts/statistics/models/module.mk
scripts/statistics/tests/module.mk:
Removed from build system.

* scripts/statistics/base/cloglog.m, scripts/statistics/base/crosstab.m,
scripts/statistics/base/logit.m, scripts/statistics/base/moment.m,
scripts/statistics/base/ppplot.m, scripts/statistics/base/probit.m,
scripts/statistics/base/qqplot.m, scripts/statistics/distributions/betacdf.m,
scripts/statistics/distributions/betainv.m,
scripts/statistics/distributions/betapdf.m,
scripts/statistics/distributions/betarnd.m,
scripts/statistics/distributions/binocdf.m,
scripts/statistics/distributions/binoinv.m,
scripts/statistics/distributions/binopdf.m,
scripts/statistics/distributions/binornd.m,
scripts/statistics/distributions/cauchy_cdf.m,
scripts/statistics/distributions/cauchy_inv.m,
scripts/statistics/distributions/cauchy_pdf.m,
scripts/statistics/distributions/cauchy_rnd.m,
scripts/statistics/distributions/chi2cdf.m,
scripts/statistics/distributions/chi2inv.m,
scripts/statistics/distributions/chi2pdf.m,
scripts/statistics/distributions/chi2rnd.m,
scripts/statistics/distributions/discrete_cdf.m,
scripts/statistics/distributions/discrete_inv.m,
scripts/statistics/distributions/discrete_pdf.m,
scripts/statistics/distributions/discrete_rnd.m,
scripts/statistics/distributions/empirical_cdf.m,
scripts/statistics/distributions/empirical_inv.m,
scripts/statistics/distributions/empirical_pdf.m,
scripts/statistics/distributions/empirical_rnd.m,
scripts/statistics/distributions/expcdf.m,
scripts/statistics/distributions/expinv.m,
scripts/statistics/distributions/exppdf.m,
scripts/statistics/distributions/exprnd.m,
scripts/statistics/distributions/fcdf.m,
scripts/statistics/distributions/finv.m,
scripts/statistics/distributions/fpdf.m,
scripts/statistics/distributions/frnd.m,
scripts/statistics/distributions/gamcdf.m,
scripts/statistics/distributions/gaminv.m,
scripts/statistics/distributions/gampdf.m,
scripts/statistics/distributions/gamrnd.m,
scripts/statistics/distributions/geocdf.m,
scripts/statistics/distributions/geoinv.m,
scripts/statistics/distributions/geopdf.m,
scripts/statistics/distributions/geornd.m,
scripts/statistics/distributions/hygecdf.m,
scripts/statistics/distributions/hygeinv.m,
scripts/statistics/distributions/hygepdf.m,
scripts/statistics/distributions/hygernd.m,
scripts/statistics/distributions/kolmogorov_smirnov_cdf.m,
scripts/statistics/distributions/laplace_cdf.m,
scripts/statistics/distributions/laplace_inv.m,
scripts/statistics/distributions/laplace_pdf.m,
scripts/statistics/distributions/laplace_rnd.m,
scripts/statistics/distributions/logistic_cdf.m,
scripts/statistics/distributions/logistic_inv.m,
scripts/statistics/distributions/logistic_pdf.m,
scripts/statistics/distributions/logistic_rnd.m,
scripts/statistics/distributions/logncdf.m,
scripts/statistics/distributions/logninv.m,
scripts/statistics/distributions/lognpdf.m,
scripts/statistics/distributions/lognrnd.m,
scripts/statistics/distributions/nbincdf.m,
scripts/statistics/distributions/nbininv.m,
scripts/statistics/distributions/nbinpdf.m,
scripts/statistics/distributions/nbinrnd.m,
scripts/statistics/distributions/normcdf.m,
scripts/statistics/distributions/norminv.m,
scripts/statistics/distributions/normpdf.m,
scripts/statistics/distributions/normrnd.m,
scripts/statistics/distributions/poisscdf.m,
scripts/statistics/distributions/poissinv.m,
scripts/statistics/distributions/poisspdf.m,
scripts/statistics/distributions/poissrnd.m,
scripts/statistics/distributions/stdnormal_cdf.m,
scripts/statistics/distributions/stdnormal_inv.m,
scripts/statistics/distributions/stdnormal_pdf.m,
scripts/statistics/distributions/stdnormal_rnd.m,
scripts/statistics/distributions/tcdf.m,
scripts/statistics/distributions/tinv.m,
scripts/statistics/distributions/tpdf.m,
scripts/statistics/distributions/trnd.m,
scripts/statistics/distributions/unidcdf.m,
scripts/statistics/distributions/unidinv.m,
scripts/statistics/distributions/unidpdf.m,
scripts/statistics/distributions/unidrnd.m,
scripts/statistics/distributions/unifcdf.m,
scripts/statistics/distributions/unifinv.m,
scripts/statistics/distributions/unifpdf.m,
scripts/statistics/distributions/unifrnd.m,
scripts/statistics/distributions/wblcdf.m,
scripts/statistics/distributions/wblinv.m,
scripts/statistics/distributions/wblpdf.m,
scripts/statistics/distributions/wblrnd.m,
scripts/statistics/distributions/wienrnd.m,
scripts/statistics/models/logistic_regression.m,
scripts/statistics/models/private/logistic_regression_derivatives.m,
scripts/statistics/models/private/logistic_regression_likelihood.m,
scripts/statistics/tests/anova.m, scripts/statistics/tests/bartlett_test.m,
scripts/statistics/tests/chisquare_test_homogeneity.m,
scripts/statistics/tests/chisquare_test_independence.m,
scripts/statistics/tests/cor_test.m,
scripts/statistics/tests/f_test_regression.m,
scripts/statistics/tests/hotelling_test.m,
scripts/statistics/tests/hotelling_test_2.m,
scripts/statistics/tests/kolmogorov_smirnov_test.m,
scripts/statistics/tests/kolmogorov_smirnov_test_2.m,
scripts/statistics/tests/kruskal_wallis_test.m,
scripts/statistics/tests/manova.m, scripts/statistics/tests/mcnemar_test.m,
scripts/statistics/tests/prop_test_2.m, scripts/statistics/tests/run_test.m,
scripts/statistics/tests/sign_test.m, scripts/statistics/tests/t_test.m,
scripts/statistics/tests/t_test_2.m,
scripts/statistics/tests/t_test_regression.m,
scripts/statistics/tests/u_test.m, scripts/statistics/tests/var_test.m,
scripts/statistics/tests/welch_test.m,
scripts/statistics/tests/wilcoxon_test.m, scripts/statistics/tests/z_test.m,
scripts/statistics/tests/z_test_2.m:
Removed functions.

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -79,17 +79,137 @@ Summary of important user-visible change
  ** ishandle now returns true for both graphics handle objects and
     Java objects.  The latter change was made for Matlab compatibility.
     Use ishghandle or isgraphics if it is important not to include Java
     objects.
 
  ** The following statistical functions have been moved from core
     Octave to the statistics package available from Octave Forge.
 
-    table -> crosstab
+    BASE
+      cloglog.m
+      table.m --renamed to --> crosstab.m
+      logit.m
+      prctile.m
+      probit.m
+      qqplot.m
+    
+    DISTRIBUTIONS
+      betacdf.m
+      betainv.m
+      betapdf.m
+      betarnd.m
+      binocdf.m
+      binoinv.m
+      binopdf.m
+      binornd.m
+      cauchy_cdf.m
+      cauchy_inv.m
+      cauchy_pdf.m
+      cauchy_rnd.m
+      chi2cdf.m
+      chi2inv.m
+      chi2pdf.m
+      chi2rnd.m
+      expcdf.m
+      expinv.m
+      exppdf.m
+      exprnd.m
+      fcdf.m
+      finv.m
+      fpdf.m
+      frnd.m
+      gamcdf.m
+      gaminv.m
+      gampdf.m
+      gamrnd.m
+      geocdf.m
+      geoinv.m
+      geopdf.m
+      geornd.m
+      hygecdf.m
+      hygeinv.m
+      hygepdf.m
+      hygernd.m
+      kolmogorov_smirnov_cdf.m
+      laplace_cdf.m
+      laplace_inv.m
+      laplace_pdf.m
+      laplace_rnd.m
+      logistic_cdf.m
+      logistic_inv.m
+      logistic_pdf.m
+      logistic_rnd.m
+      logncdf.m
+      logninv.m
+      lognpdf.m
+      lognrnd.m
+      nbincdf.m
+      nbininv.m
+      nbinpdf.m
+      nbinrnd.m
+      normcdf.m
+      norminv.m
+      normpdf.m
+      normrnd.m
+      poisscdf.m
+      poissinv.m
+      poisspdf.m
+      poissrnd.m
+      stdnormal_cdf.m
+      stdnormal_inv.m
+      stdnormal_pdf.m
+      stdnormal_rnd.m
+      tcdf.m
+      tinv.m
+      tpdf.m
+      trnd.m
+      unidcdf.m
+      unidinv.m
+      unidpdf.m
+      unidrnd.m
+      unifcdf.m
+      unifinv.m
+      unifpdf.m
+      unifrnd.m
+      wblcdf.m
+      wblinv.m
+      wblpdf.m
+      wblrnd.m
+      wienrnd.m
+
+    MODELS
+      logistic_regression.m
+
+    TESTS
+      anova.m
+      bartlett_test.m
+      chisquare_test_homogeneity.m
+      chisquare_test_independence.m
+      cor_test.m
+      f_test_regression.m
+      hotelling_test.m
+      hotelling_test_2.m
+      kolmogorov_smirnov_test.m
+      kolmogorov_smirnov_test_2.m
+      kruskal_wallis_test.m
+      manova.m
+      mcnemar_test.m
+      prop_test_2.m
+      run_test.m
+      sign_test.m
+      t_test.m
+      t_test_2.m
+      t_test_regression.m
+      u_test.m
+      var_test.m
+      welch_test.m
+      wilcoxon_test.m
+      z_test.m
+      z_test_2.m
 
  ** Other new functions added in 4.4:
 
       camlookat
       camorbit
       campos
       camroll
       camtarget
diff --git a/doc/interpreter/octave.texi b/doc/interpreter/octave.texi
--- a/doc/interpreter/octave.texi
+++ b/doc/interpreter/octave.texi
@@ -709,20 +709,18 @@ Optimization
 * Quadratic Programming::
 * Nonlinear Programming::
 * Linear Least Squares::
 
 Statistics
 
 * Descriptive Statistics::
 * Basic Statistical Functions::
-* Statistical Plots::
 * Correlation and Regression Analysis::
 * Distributions::
-* Tests::
 * Random Number Generation::
 
 Sets
 
 * Set Operations::
 
 Polynomial Manipulations
 
diff --git a/doc/interpreter/stats.txi b/doc/interpreter/stats.txi
--- a/doc/interpreter/stats.txi
+++ b/doc/interpreter/stats.txi
@@ -14,49 +14,47 @@
 @c
 @c You should have received a copy of the GNU General Public License
 @c along with Octave; see the file COPYING.  If not, see
 @c <https://www.gnu.org/licenses/>.
 
 @node Statistics
 @chapter Statistics
 
-Octave has support for various statistical methods.  This includes
-basic descriptive statistics, probability distributions, statistical tests,
-random number generation, and much more.
+Octave has support for various statistical methods.  The emphasis is on basic
+descriptive statistics, but the Octave Forge statistics package includes
+probability distributions, statistical tests, random number generation, and
+much more.
 
-The functions that analyze data all assume that multi-dimensional data
-is arranged in a matrix where each row is an observation, and each
-column is a variable.  Thus, the matrix defined by
+The functions that analyze data all assume that multi-dimensional data is
+arranged in a matrix where each row is an observation, and each column is a
+variable.  Thus, the matrix defined by
 
 @example
 @group
 a = [ 0.9, 0.7;
       0.1, 0.1;
       0.5, 0.4 ];
 @end group
 @end example
 
 @noindent
-contains three observations from a two-dimensional distribution.
-While this is the default data arrangement, most functions support
-different arrangements.
+contains three observations from a two-dimensional distribution.  While this is
+the default data arrangement, most functions support different arrangements.
 
-It should be noted that the statistics functions don't test for data
-containing NaN, NA, or Inf.  These values need to be detected and dealt
-with explicitly.  See @ref{XREFisnan,,isnan}, @ref{XREFisna,,isna},
-@ref{XREFisinf,,isinf}, @ref{XREFisfinite,,isfinite}.
+It should be noted that the statistics functions don't test for data containing
+NaN, NA, or Inf.  These values need to be detected and dealt with explicitly.
+See @ref{XREFisnan,,isnan}, @ref{XREFisna,,isna}, @ref{XREFisinf,,isinf},
+@ref{XREFisfinite,,isfinite}.
 
 @menu
 * Descriptive Statistics::
 * Basic Statistical Functions::
-* Statistical Plots::
 * Correlation and Regression Analysis::
 * Distributions::
-* Tests::
 * Random Number Generation::
 @end menu
 
 @node Descriptive Statistics
 @section Descriptive Statistics
 
 One principal goal of descriptive statistics is to represent the essence of a
 large data set concisely.  Octave provides the mean, median, and mode functions
@@ -127,575 +125,122 @@ useful for statistics.
 @DOCSTRING(perms)
 
 @DOCSTRING(ranks)
 
 @DOCSTRING(run_count)
 
 @DOCSTRING(runlength)
 
-@DOCSTRING(probit)
-
-@DOCSTRING(logit)
-
-@DOCSTRING(cloglog)
-
-@DOCSTRING(crosstab)
-
-@node Statistical Plots
-@section Statistical Plots
-
-@c Should hist be moved to here, or perhaps the qqplot and ppplot
-@c functions should be moved to the Plotting Chapter?
-
-Octave can create Quantile Plots (QQ-Plots), and Probability Plots
-(PP-Plots).  These are simple graphical tests for determining if a
-data set comes from a certain distribution.
-
-Note that Octave can also show histograms of data
-using the @code{hist} function as described in
-@ref{Two-Dimensional Plots}.
-
-@DOCSTRING(qqplot)
-
-@DOCSTRING(ppplot)
-
 @node Correlation and Regression Analysis
 @section Correlation and Regression Analysis
 
 @c FIXME: Need Intro Here
 
 @DOCSTRING(cov)
 
 @DOCSTRING(corr)
 
 @DOCSTRING(corrcoef)
 
 @DOCSTRING(spearman)
 
 @DOCSTRING(kendall)
 
-@c FIXME: Need discussion of ols & gls and references to them in optim.txi
-
-
-@DOCSTRING(logistic_regression)
-
 @node Distributions
 @section Distributions
 
-Octave has functions for computing the Probability Density Function
-(PDF), the Cumulative Distribution function (CDF), and the quantile
-(the inverse of the CDF) for a large number of distributions.
+Octave has functions for computing the Probability Density Function (PDF), the
+Cumulative Distribution function (CDF), and the quantile (the inverse of the
+CDF) for arbitrary user-defined distributions (discrete) and for experimental
+data (empirical).
 
-The following table summarizes the supported distributions (in
-alphabetical order).
+The following table summarizes the supported distributions (in alphabetical
+order).
 
 @tex
 \vskip 6pt
 {\hbox to \hsize {\hfill\vbox{\offinterlineskip \tabskip=0pt
 \halign{
 \vrule height2.0ex depth1.ex width 0.6pt #\tabskip=0.3em &
 # \hfil & \vrule # & # \hfil & \vrule # & # \hfil & \vrule # & # \hfil &
 # \vrule width 0.6pt \tabskip=0pt\cr
 \noalign{\hrule height 0.6pt}
 & {\bf Distribution} && {\bf PDF}      && {\bf CDF}     && {\bf Quantile}&\cr
 \noalign{\hrule}
-&Beta         && betapdf        && betacdf       && betainv&\cr
-&Binomial     && binopdf        && binocdf       && binoinv&\cr
-&Cauchy       && cauchy\_pdf    && cauchy\_cdf   && cauchy\_inv&\cr
-&Chi-Square   && chi2pdf        && chi2cdf       && chi2inv&\cr
 &Univariate Discrete       && discrete\_pdf  && discrete\_cdf && discrete\_inv&\cr
 &Empirical    && empirical\_pdf  && empirical\_cdf && empirical\_inv&\cr
-&Exponential  && exppdf         && expcdf        && expinv&\cr
-&F            && fpdf           && fcdf          && finv&\cr
-&Gamma        && gampdf         && gamcdf        && gaminv&\cr
-&Geometric    && geopdf         && geocdf        && geoinv&\cr
-&Hypergeometric  && hygepdf     && hygecdf       && hygeinv&\cr
-&Kolmogorov Smirnov && {\it Not Available} && kolmogorov\_&& {\it Not Available}&\cr
-&             &&                && smirnov\_cdf &&&\cr
-&Laplace      && laplace\_pdf   && laplace\_cdf  && laplace\_inv&\cr
-&Logistic     && logistic\_pdf  && logistic\_cdf && logistic\_inv&\cr
-&Log-Normal   && lognpdf        && logncdf       && logninv&\cr
-&Univariate Normal && normpdf   && normcdf       && norminv&\cr
-&Pascal       && nbinpdf        && nbincdf       && nbininv&\cr
-&Poisson      && poisspdf       && poisscdf      && poissinv&\cr
-&Standard Normal && stdnormal\_pdf  && stdnormal\_cdf && stdnormal\_inv&\cr
-&t (Student)  && tpdf           && tcdf          && tinv&\cr
-&Uniform Discrete && unidpdf    && unidcdf       && unidinv&\cr
-&Uniform      && unifpdf        && unifcdf       && unifinv&\cr
-&Weibull      && wblpdf         && wblcdf        && wblinv&\cr
 \noalign{\hrule height 0.6pt}
 }}\hfill}}
 @end tex
 @ifnottex
 @multitable @columnfractions .31 .23 .23 .23
 @headitem Distribution
   @tab PDF
   @tab CDF
   @tab Quantile
-@item Beta Distribution
-  @tab @code{betapdf}
-  @tab @code{betacdf}
-  @tab @code{betainv}
-@item Binomial Distribution
-  @tab @code{binopdf}
-  @tab @code{binocdf}
-  @tab @code{binoinv}
-@item Cauchy Distribution
-  @tab @code{cauchy_pdf}
-  @tab @code{cauchy_cdf}
-  @tab @code{cauchy_inv}
-@item Chi-Square Distribution
-  @tab @code{chi2pdf}
-  @tab @code{chi2cdf}
-  @tab @code{chi2inv}
 @item Univariate Discrete Distribution
   @tab @code{discrete_pdf}
   @tab @code{discrete_cdf}
   @tab @code{discrete_inv}
 @item Empirical Distribution
   @tab @code{empirical_pdf}
   @tab @code{empirical_cdf}
   @tab @code{empirical_inv}
-@item Exponential Distribution
-  @tab @code{exppdf}
-  @tab @code{expcdf}
-  @tab @code{expinv}
-@item F Distribution
-  @tab @code{fpdf}
-  @tab @code{fcdf}
-  @tab @code{finv}
-@item Gamma Distribution
-  @tab @code{gampdf}
-  @tab @code{gamcdf}
-  @tab @code{gaminv}
-@item Geometric Distribution
-  @tab @code{geopdf}
-  @tab @code{geocdf}
-  @tab @code{geoinv}
-@item Hypergeometric Distribution
-  @tab @code{hygepdf}
-  @tab @code{hygecdf}
-  @tab @code{hygeinv}
-@item Kolmogorov Smirnov Distribution
-  @tab @emph{Not Available}
-  @tab @code{kolmogorov_smirnov_cdf}
-  @tab @emph{Not Available}
-@item Laplace Distribution
-  @tab @code{laplace_pdf}
-  @tab @code{laplace_cdf}
-  @tab @code{laplace_inv}
-@item Logistic Distribution
-  @tab @code{logistic_pdf}
-  @tab @code{logistic_cdf}
-  @tab @code{logistic_inv}
-@item Log-Normal Distribution
-  @tab @code{lognpdf}
-  @tab @code{logncdf}
-  @tab @code{logninv}
-@item Univariate Normal Distribution
-  @tab @code{normpdf}
-  @tab @code{normcdf}
-  @tab @code{norminv}
-@item Pascal Distribution
-  @tab @code{nbinpdf}
-  @tab @code{nbincdf}
-  @tab @code{nbininv}
-@item Poisson Distribution
-  @tab @code{poisspdf}
-  @tab @code{poisscdf}
-  @tab @code{poissinv}
-@item Standard Normal Distribution
-  @tab @code{stdnormal_pdf}
-  @tab @code{stdnormal_cdf}
-  @tab @code{stdnormal_inv}
-@item t (Student) Distribution
-  @tab @code{tpdf}
-  @tab @code{tcdf}
-  @tab @code{tinv}
-@item Univariate Discrete Distribution
-  @tab @code{unidpdf}
-  @tab @code{unidcdf}
-  @tab @code{unidinv}
-@item Uniform Distribution
-  @tab @code{unifpdf}
-  @tab @code{unifcdf}
-  @tab @code{unifinv}
-@item Weibull Distribution
-  @tab @code{wblpdf}
-  @tab @code{wblcdf}
-  @tab @code{wblinv}
 @end multitable
 @end ifnottex
 
-@DOCSTRING(betapdf)
-
-@DOCSTRING(betacdf)
-
-@DOCSTRING(betainv)
-
-@DOCSTRING(binopdf)
-
-@DOCSTRING(binocdf)
-
-@DOCSTRING(binoinv)
-
-@DOCSTRING(cauchy_pdf)
-
-@DOCSTRING(cauchy_cdf)
-
-@DOCSTRING(cauchy_inv)
-
-@DOCSTRING(chi2pdf)
-
-@DOCSTRING(chi2cdf)
-
-@DOCSTRING(chi2inv)
-
 @DOCSTRING(discrete_pdf)
 
 @DOCSTRING(discrete_cdf)
 
 @DOCSTRING(discrete_inv)
 
 @DOCSTRING(empirical_pdf)
 
 @DOCSTRING(empirical_cdf)
 
 @DOCSTRING(empirical_inv)
 
-@DOCSTRING(exppdf)
-
-@DOCSTRING(expcdf)
-
-@DOCSTRING(expinv)
-
-@DOCSTRING(fpdf)
-
-@DOCSTRING(fcdf)
-
-@DOCSTRING(finv)
-
-@DOCSTRING(gampdf)
-
-@DOCSTRING(gamcdf)
-
-@DOCSTRING(gaminv)
-
-@DOCSTRING(geopdf)
-
-@DOCSTRING(geocdf)
-
-@DOCSTRING(geoinv)
-
-@DOCSTRING(hygepdf)
-
-@DOCSTRING(hygecdf)
-
-@DOCSTRING(hygeinv)
-
-@DOCSTRING(kolmogorov_smirnov_cdf)
-
-@DOCSTRING(laplace_pdf)
-
-@DOCSTRING(laplace_cdf)
-
-@DOCSTRING(laplace_inv)
-
-@DOCSTRING(logistic_pdf)
-
-@DOCSTRING(logistic_cdf)
-
-@DOCSTRING(logistic_inv)
-
-@DOCSTRING(lognpdf)
-
-@DOCSTRING(logncdf)
-
-@DOCSTRING(logninv)
-
-@DOCSTRING(nbinpdf)
-
-@DOCSTRING(nbincdf)
-
-@DOCSTRING(nbininv)
-
-@DOCSTRING(normpdf)
-
-@DOCSTRING(normcdf)
-
-@DOCSTRING(norminv)
-
-@DOCSTRING(poisspdf)
-
-@DOCSTRING(poisscdf)
-
-@DOCSTRING(poissinv)
-
-@DOCSTRING(stdnormal_pdf)
-
-@DOCSTRING(stdnormal_cdf)
-
-@DOCSTRING(stdnormal_inv)
-
-@DOCSTRING(tpdf)
-
-@DOCSTRING(tcdf)
-
-@DOCSTRING(tinv)
-
-@DOCSTRING(unidpdf)
-
-@DOCSTRING(unidcdf)
-
-@DOCSTRING(unidinv)
-
-@DOCSTRING(unifpdf)
-
-@DOCSTRING(unifcdf)
-
-@DOCSTRING(unifinv)
-
-@DOCSTRING(wblpdf)
-
-@DOCSTRING(wblcdf)
-
-@DOCSTRING(wblinv)
-
-@node Tests
-@section Tests
-
-Octave can perform many different statistical tests.  The following
-table summarizes the available tests.
-
-@tex
-\vskip 6pt
-{\hbox to \hsize {\hfill\vbox{\offinterlineskip \tabskip=0pt
-\halign{
-\vrule height2.0ex depth1.ex width 0.6pt #\tabskip=0.3em &
-# \hfil & \vrule # & # \hfil & # \vrule width 0.6pt \tabskip=0pt\cr
-\noalign{\hrule height 0.6pt}
-& @strong{Hypothesis} && {\bf Test Functions} &\cr
-\noalign{\hrule}
-& Equal mean values && anova, hotelling\_test2, t\_test\_2, &\cr
-&                   && welch\_test, wilcoxon\_test, z\_test\_2 &\cr
-& Equal medians && kruskal\_wallis\_test, sign\_test &\cr
-& Equal variances && bartlett\_test, manova, var\_test &\cr
-& Equal distributions && chisquare\_test\_homogeneity, &\cr
-&                     && kolmogorov\_smirnov\_test\_2, u\_test &\cr
-& Equal marginal frequencies && mcnemar\_test &\cr
-& Equal success probabilities && prop\_test\_2 &\cr
-& Independent observations && chisquare\_test\_independence, &\cr
-&                          && run\_test &\cr
-& Uncorrelated observations && cor\_test &\cr
-& Given mean value && hotelling\_test, t\_test, z\_test &\cr
-& Observations from distribution && kolmogorov\_smirnov\_test &\cr
-& Regression && f\_test\_regression, t\_test\_regression &\cr
-\noalign{\hrule height 0.6pt}
-}}\hfill}}
-@end tex
-@ifnottex
-@multitable @columnfractions .4 .5
-@headitem Hypothesis
-  @tab Test Functions
-@item Equal mean values
-  @tab @code{anova}, @code{hotelling_test2}, @code{t_test_2},
-       @code{welch_test}, @code{wilcoxon_test}, @code{z_test_2}
-@item Equal medians
-  @tab @code{kruskal_wallis_test}, @code{sign_test}
-@item Equal variances
-  @tab @code{bartlett_test}, @code{manova}, @code{var_test}
-@item Equal distributions
-  @tab @code{chisquare_test_homogeneity}, @code{kolmogorov_smirnov_test_2},
-       @code{u_test}
-@item Equal marginal frequencies
-  @tab @code{mcnemar_test}
-@item Equal success probabilities
-  @tab @code{prop_test_2}
-@item Independent observations
-  @tab @code{chisquare_test_independence}, @code{run_test}
-@item Uncorrelated observations
-  @tab @code{cor_test}
-@item Given mean value
-  @tab @code{hotelling_test}, @code{t_test}, @code{z_test}
-@item Observations from given distribution
-  @tab @code{kolmogorov_smirnov_test}
-@item Regression
-  @tab @code{f_test_regression}, @code{t_test_regression}
-@end multitable
-@end ifnottex
-
-The tests return a p-value that describes the outcome of the test.
-Assuming that the test hypothesis is true, the p-value is the probability
-of obtaining a worse result than the observed one.  So large p-values
-corresponds to a successful test.  Usually a test hypothesis is accepted
-if the p-value exceeds 0.05.
-
-@DOCSTRING(anova)
-
-@DOCSTRING(bartlett_test)
-
-@DOCSTRING(chisquare_test_homogeneity)
-
-@DOCSTRING(chisquare_test_independence)
-
-@DOCSTRING(cor_test)
-
-@DOCSTRING(f_test_regression)
-
-@DOCSTRING(hotelling_test)
-
-@DOCSTRING(hotelling_test_2)
-
-@DOCSTRING(kolmogorov_smirnov_test)
-
-@DOCSTRING(kolmogorov_smirnov_test_2)
-
-@DOCSTRING(kruskal_wallis_test)
-
-@DOCSTRING(manova)
-
-@DOCSTRING(mcnemar_test)
-
-@DOCSTRING(prop_test_2)
-
-@DOCSTRING(run_test)
-
-@DOCSTRING(sign_test)
-
-@DOCSTRING(t_test)
-
-@DOCSTRING(t_test_2)
-
-@DOCSTRING(t_test_regression)
-
-@DOCSTRING(u_test)
-
-@DOCSTRING(var_test)
-
-@DOCSTRING(welch_test)
-
-@DOCSTRING(wilcoxon_test)
-
-@DOCSTRING(z_test)
-
-@DOCSTRING(z_test_2)
-
 @node Random Number Generation
 @section Random Number Generation
 
-Octave can generate random numbers from a large number of distributions.
-The random number generators are based on the random number generators
-described in @ref{Special Utility Matrices}.
-@c Should rand, randn, rande, randp, and randg be moved to here?
+Octave can generate random numbers from a large number of distributions.  The
+random number generators are based on the random number generators described in
+@ref{Special Utility Matrices}.
 
-The following table summarizes the available random number generators
-(in alphabetical order).
+The following table summarizes the available random number generators (in
+alphabetical order).
 
 @tex
 \vskip 6pt
 {\hbox to \hsize {\hfill\vbox{\offinterlineskip \tabskip=0pt
 \halign{
 \vrule height2.0ex depth1.ex width 0.6pt #\tabskip=0.3em &
 # \hfil & \vrule # & # \hfil & # \vrule width 0.6pt \tabskip=0pt\cr
 \noalign{\hrule height 0.6pt}
 & {\bf Distribution}                && {\bf Function} &\cr
 \noalign{\hrule}
-& Beta Distribution                 && betarnd &\cr
-& Binomial Distribution             && binornd &\cr
-& Cauchy Distribution               && cauchy\_rnd &\cr
-& Chi-Square Distribution           && chi2rnd &\cr
 & Univariate Discrete Distribution  && discrete\_rnd &\cr
 & Empirical Distribution            && empirical\_rnd &\cr
-& Exponential Distribution          && exprnd &\cr
-& F Distribution                    && frnd &\cr
-& Gamma Distribution                && gamrnd &\cr
-& Geometric Distribution            && geornd &\cr
-& Hypergeometric Distribution       && hygernd &\cr
-& Laplace Distribution              && laplace\_rnd &\cr
-& Logistic Distribution             && logistic\_rnd &\cr
-& Log-Normal Distribution           && lognrnd &\cr
-& Pascal Distribution               && nbinrnd &\cr
-& Univariate Normal Distribution    && normrnd &\cr
-& Poisson Distribution              && poissrnd &\cr
-& Standard Normal Distribution      && stdnormal\_rnd &\cr
-& t (Student) Distribution          && trnd &\cr
-& Univariate Discrete Distribution  && unidrnd &\cr
-& Uniform Distribution              && unifrnd &\cr
-& Weibull Distribution              && wblrnd &\cr
-& Wiener Process                    && wienrnd &\cr
+& Exponential Distribution          && rande &\cr
+& Gamma Distribution                && randg &\cr
+& Poisson Distribution              && randp &\cr
+& Standard Normal Distribution      && randn &\cr
+& Uniform Distribution              && rand &\cr
+& Uniform Distribution (integers)   && randi &\cr
 \noalign{\hrule height 0.6pt}
 }}\hfill}}
 @end tex
 @ifnottex
 @multitable @columnfractions .4 .3
 @headitem Distribution                  @tab Function
-@item Beta Distribution                 @tab @code{betarnd}
-@item Binomial Distribution             @tab @code{binornd}
-@item Cauchy Distribution               @tab @code{cauchy_rnd}
-@item Chi-Square Distribution           @tab @code{chi2rnd}
 @item Univariate Discrete Distribution  @tab @code{discrete_rnd}
 @item Empirical Distribution            @tab @code{empirical_rnd}
-@item Exponential Distribution          @tab @code{exprnd}
-@item F Distribution                    @tab @code{frnd}
-@item Gamma Distribution                @tab @code{gamrnd}
-@item Geometric Distribution            @tab @code{geornd}
-@item Hypergeometric Distribution       @tab @code{hygernd}
-@item Laplace Distribution              @tab @code{laplace_rnd}
-@item Logistic Distribution             @tab @code{logistic_rnd}
-@item Log-Normal Distribution           @tab @code{lognrnd}
-@item Pascal Distribution               @tab @code{nbinrnd}
-@item Univariate Normal Distribution    @tab @code{normrnd}
-@item Poisson Distribution              @tab @code{poissrnd}
-@item Standard Normal Distribution      @tab @code{stdnormal_rnd}
-@item t (Student) Distribution          @tab @code{trnd}
-@item Univariate Discrete Distribution  @tab @code{unidrnd}
-@item Uniform Distribution              @tab @code{unifrnd}
-@item Weibull Distribution              @tab @code{wblrnd}
-@item Wiener Process                    @tab @code{wienrnd}
+@item Exponential Distribution          @tab @code{rande}
+@item Gamma Distribution                @tab @code{randg}
+@item Poisson Distribution              @tab @code{randp}
+@item Standard Normal Distribution      @tab @code{randn}
+@item Uniform Distribution              @tab @code{rand}
+@item Uniform Distribution (integers)   @tab @code{randi}
 @end multitable
 @end ifnottex
 
-@DOCSTRING(betarnd)
-
-@DOCSTRING(binornd)
-
-@DOCSTRING(cauchy_rnd)
-
-@DOCSTRING(chi2rnd)
-
-@DOCSTRING(discrete_rnd)
-
-@DOCSTRING(empirical_rnd)
-
-@DOCSTRING(exprnd)
-
-@DOCSTRING(frnd)
-
-@DOCSTRING(gamrnd)
-
-@DOCSTRING(geornd)
-
-@DOCSTRING(hygernd)
-
-@DOCSTRING(laplace_rnd)
-
-@DOCSTRING(logistic_rnd)
-
-@DOCSTRING(lognrnd)
-
-@DOCSTRING(nbinrnd)
-
-@DOCSTRING(normrnd)
-
-@DOCSTRING(poissrnd)
-
-@DOCSTRING(stdnormal_rnd)
-
-@DOCSTRING(trnd)
-
-@DOCSTRING(unidrnd)
-
-@DOCSTRING(unifrnd)
-
-@DOCSTRING(wblrnd)
-
-@DOCSTRING(wienrnd)
diff --git a/scripts/module.mk b/scripts/module.mk
--- a/scripts/module.mk
+++ b/scripts/module.mk
@@ -28,20 +28,17 @@ include %reldir%/polynomial/module.mk
 include %reldir%/prefs/module.mk
 include %reldir%/profiler/module.mk
 include %reldir%/set/module.mk
 include %reldir%/signal/module.mk
 include %reldir%/sparse/module.mk
 include %reldir%/specfun/module.mk
 include %reldir%/special-matrix/module.mk
 include %reldir%/startup/module.mk
-include %reldir%/statistics/base/module.mk
-include %reldir%/statistics/distributions/module.mk
-include %reldir%/statistics/models/module.mk
-include %reldir%/statistics/tests/module.mk
+include %reldir%/statistics/module.mk
 include %reldir%/strings/module.mk
 include %reldir%/testfun/module.mk
 include %reldir%/time/module.mk
 
 ## include %reldir%/@ftp/module.mk
 ## The include above fails because Automake cannot process the '@' character.
 ## As a work around, the contents of %reldir%/@ftp/module.mk are placed directly
 ## in this module.mk file.
diff --git a/scripts/statistics/base/cloglog.m b/scripts/statistics/base/cloglog.m
deleted file mode 100644
--- a/scripts/statistics/base/cloglog.m
+++ /dev/null
@@ -1,58 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} cloglog (@var{x})
-## Return the complementary log-log function of @var{x}.
-##
-## The complementary log-log function is defined as
-## @tex
-## $$
-## {\rm cloglog}(x) = - \log (- \log (x))
-## $$
-## @end tex
-## @ifnottex
-##
-## @example
-## cloglog (x) = - log (- log (@var{x}))
-## @end example
-##
-## @end ifnottex
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Complementary log-log function
-
-function y = cloglog (x)
-
-  if (nargin != 1)
-    print_usage ();
-  endif
-
-  y = - log (- log (x));
-
-endfunction
-
-
-%!assert (cloglog (0), -Inf)
-%!assert (cloglog (1), Inf)
-%!assert (cloglog (1/e), 0)
-
-## Test input validation
-%!error cloglog ()
-%!error cloglog (1, 2)
diff --git a/scripts/statistics/base/crosstab.m b/scripts/statistics/base/crosstab.m
deleted file mode 100644
--- a/scripts/statistics/base/crosstab.m
+++ /dev/null
@@ -1,64 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {@var{t} =} crosstab (@var{x}, @var{y})
-## Create a cross-tabulation (contingency table) @var{t} from data vectors.
-##
-## The inputs @var{x}, @var{y} must be vectors of equal length with a data
-## type of numeric, logical, or char.
-##
-## Currently, only 1- and 2-dimensional tables are supported.
-## @end deftypefn
-
-function t = crosstab (x, y)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! (   isvector (x) && isreal (x)
-         && isvector (y) && isreal (y)
-         && (numel (x) == numel (y))))
-    error ("crosstab: X and Y must be real vectors of the same length");
-  endif
-
-  x = x(:);
-  y = y(:);
-  v = unique (x);
-  w = unique (y);
-  for i = 1 : length (v)
-    for j = 1 : length (w)
-      t(i,j) = sum ((x == v(i) | isnan (v(i)) * isnan (x)) &
-                    (y == w(j) | isnan (w(j)) * isnan (y)));
-    endfor
-  endfor
-
-endfunction
-
-
-## Test input validation
-%!error crosstab ()
-%!error crosstab (1)
-%!error crosstab (1, 2, 3)
-%!error <X .* must be .* vector> crosstab (ones (2), [1 1])
-%!error <Y must be .* vector> crosstab ([1 1], ones (2))
-%!error <X .* must be real> crosstab ({true, true}, [1 1])
-%!error <Y must be real> crosstab ([1 1], {true, true})
-%!error <X and Y must be .* of the same length> crosstab ([1], [1 1])
-%!error <X and Y must be .* of the same length> crosstab ([1 1], [1])
diff --git a/scripts/statistics/base/logit.m b/scripts/statistics/base/logit.m
deleted file mode 100644
--- a/scripts/statistics/base/logit.m
+++ /dev/null
@@ -1,61 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} logit (@var{p})
-## Compute the logit for each value of @var{p}
-##
-## The logit is defined as
-## @tex
-## $$
-## {\rm logit}(p) = \log\Big({p \over 1-p}\Big)
-## $$
-## @end tex
-## @ifnottex
-##
-## @example
-## logit (@var{p}) = log (@var{p} / (1-@var{p}))
-## @end example
-##
-## @end ifnottex
-## @seealso{probit, logistic_cdf}
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Logit transformation
-
-function y = logit (p)
-
-  if (nargin != 1)
-    print_usage ();
-  endif
-
-  y = logistic_inv (p);
-
-endfunction
-
-
-%!test
-%! p = [0.01:0.01:0.99];
-%! assert (logit (p), log (p ./ (1-p)), 25*eps);
-
-%!assert (logit ([-1, 0, 0.5, 1, 2]), [NaN, -Inf, 0, +Inf, NaN])
-
-## Test input validation
-%!error logit ()
-%!error logit (1, 2)
diff --git a/scripts/statistics/base/ppplot.m b/scripts/statistics/base/ppplot.m
deleted file mode 100644
--- a/scripts/statistics/base/ppplot.m
+++ /dev/null
@@ -1,91 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{p}, @var{y}] =} ppplot (@var{x}, @var{dist}, @var{params})
-## Perform a PP-plot (probability plot).
-##
-## If F is the CDF of the distribution @var{dist} with parameters
-## @var{params} and @var{x} a sample vector of length @var{n}, the PP-plot
-## graphs ordinate @var{y}(@var{i}) = F (@var{i}-th largest element of
-## @var{x}) versus abscissa @var{p}(@var{i}) = (@var{i} - 0.5)/@var{n}.  If
-## the sample comes from F, the pairs will approximately follow a straight
-## line.
-##
-## The default for @var{dist} is the standard normal distribution.
-##
-## The optional argument @var{params} contains a list of parameters of
-## @var{dist}.
-##
-## For example, for a probability plot of the uniform distribution on [2,4]
-## and @var{x}, use
-##
-## @example
-## ppplot (x, "uniform", 2, 4)
-## @end example
-##
-## @noindent
-## @var{dist} can be any string for which a function @var{dist_cdf} that
-## calculates the CDF of distribution @var{dist} exists.
-##
-## If no output is requested then the data are plotted immediately.
-## @seealso{qqplot}
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Perform a PP-plot (probability plot)
-
-function [p, y] = ppplot (x, dist, varargin)
-
-  if (nargin < 1)
-    print_usage ();
-  endif
-
-  if (! isvector (x))
-    error ("ppplot: X must be a vector");
-  endif
-
-  s = sort (x);
-  n = length (x);
-  p = ((1 : n)' - 0.5) / n;
-  if (nargin == 1)
-    F = @stdnormal_cdf;
-  elseif (! ischar (dist))
-    error ("ppplot: DIST must be a string");
-  else
-    F = str2func ([dist "cdf"]);
-  endif
-
-  if (nargin <= 2)
-    y = feval (F, s);
-  else
-    y = feval (F, s, varargin{:});
-  endif
-
-  if (nargout == 0)
-    plot (p, y);
-    axis ([0, 1, 0, 1]);
-  endif
-
-endfunction
-
-
-## Test input validation
-%!error ppplot ()
-%!error ppplot (ones (2,2))
-%!error <DIST must be a string> ppplot (1, 2)
diff --git a/scripts/statistics/base/probit.m b/scripts/statistics/base/probit.m
deleted file mode 100644
--- a/scripts/statistics/base/probit.m
+++ /dev/null
@@ -1,45 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} probit (@var{p})
-## Return the probit (the quantile of the standard normal distribution) for
-## each element of @var{p}.
-## @seealso{logit}
-## @end deftypefn
-
-## Written by KH <Kurt.Hornik@wu-wien.ac.at> on 1995/02/04
-## Description: Probit transformation
-
-function y = probit (p)
-
-
-  if (nargin != 1)
-    print_usage ();
-  endif
-
-  y = stdnormal_inv (p);
-
-endfunction
-
-
-%!assert (probit ([-1, 0, 0.5, 1, 2]), [NaN, -Inf, 0, Inf, NaN])
-
-## Test input validation
-%!error probit ()
-%!error probit (1, 2)
diff --git a/scripts/statistics/base/qqplot.m b/scripts/statistics/base/qqplot.m
deleted file mode 100644
--- a/scripts/statistics/base/qqplot.m
+++ /dev/null
@@ -1,119 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {[@var{q}, @var{s}] =} qqplot (@var{x})
-## @deftypefnx {} {[@var{q}, @var{s}] =} qqplot (@var{x}, @var{y})
-## @deftypefnx {} {[@var{q}, @var{s}] =} qqplot (@var{x}, @var{dist})
-## @deftypefnx {} {[@var{q}, @var{s}] =} qqplot (@var{x}, @var{y}, @var{params})
-## @deftypefnx {} {} qqplot (@dots{})
-## Perform a QQ-plot (quantile plot).
-##
-## If F is the CDF of the distribution @var{dist} with parameters
-## @var{params} and G its inverse, and @var{x} a sample vector of length
-## @var{n}, the QQ-plot graphs ordinate @var{s}(@var{i}) = @var{i}-th
-## largest element of x versus abscissa @var{q}(@var{i}f) = G((@var{i} -
-## 0.5)/@var{n}).
-##
-## If the sample comes from F, except for a transformation of location
-## and scale, the pairs will approximately follow a straight line.
-##
-## If the second argument is a vector @var{y} the empirical CDF of @var{y}
-## is used as @var{dist}.
-##
-## The default for @var{dist} is the standard normal distribution.  The
-## optional argument @var{params} contains a list of parameters of
-## @var{dist}.  For example, for a quantile plot of the uniform
-## distribution on [2,4] and @var{x}, use
-##
-## @example
-## qqplot (x, "unif", 2, 4)
-## @end example
-##
-## @noindent
-## @var{dist} can be any string for which a function @var{distinv} or
-## @var{dist_inv} exists that calculates the inverse CDF of distribution
-## @var{dist}.
-##
-## If no output arguments are given, the data are plotted directly.
-## @seealso{ppplot}
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Perform a QQ-plot (quantile plot)
-
-function [qout, sout] = qqplot (x, dist, varargin)
-
-  if (nargin < 1)
-    print_usage ();
-  endif
-
-  if (! (isnumeric (x) && isvector (x)))
-    error ("qqplot: X must be a numeric vector");
-  endif
-
-  if (nargin == 1)
-    f = @stdnormal_inv;
-  else
-    if (isnumeric (dist))
-      f = @(y) empirical_inv (y, dist);
-    elseif (ischar (dist) && (exist (invname = [dist "inv"])
-                              || exist (invname = [dist "_inv"])))
-      f = str2func (invname);
-    else
-      error ("qqplot: no inverse CDF found for distribution DIST");
-    endif
-  endif;
-
-  s = sort (x);
-  n = length (x);
-  t = ((1 : n)' - .5) / n;
-  if (nargin <= 2)
-    q = f (t);
-    q_label = func2str (f);
-  else
-    q = f (t, varargin{:});
-    if (nargin == 3)
-      q_label = sprintf ("%s with parameter %g", func2str (f), varargin{1});
-    else
-      q_label = sprintf ("%s with parameters %g", func2str (f), varargin{1});
-      param_str = sprintf (", %g", varargin{2:end});
-      q_label = [q_label param_str];
-    endif
-  endif
-
-  if (nargout == 0)
-    plot (q, s, "-x");
-    q_label = strrep (q_label, '_inv', '\_inv');
-    if (q_label(1) == '@')
-      q_label = q_label(6:end);  # Strip "@(y) " from anon. function
-    endif
-    xlabel (q_label);
-    ylabel ("sample points");
-  else
-    qout = q;
-    sout = s;
-  endif
-
-endfunction
-
-## Test input validation
-%!error qqplot ()
-%!error <X must be a numeric> qqplot ({1})
-%!error <X must be a .* vector> qqplot (ones (2,2))
-%!error <no inverse CDF found> qqplot (1, "foobar")
diff --git a/scripts/statistics/base/center.m b/scripts/statistics/center.m
rename from scripts/statistics/base/center.m
rename to scripts/statistics/center.m
diff --git a/scripts/statistics/base/corr.m b/scripts/statistics/corr.m
rename from scripts/statistics/base/corr.m
rename to scripts/statistics/corr.m
diff --git a/scripts/statistics/base/corrcoef.m b/scripts/statistics/corrcoef.m
rename from scripts/statistics/base/corrcoef.m
rename to scripts/statistics/corrcoef.m
--- a/scripts/statistics/base/corrcoef.m
+++ b/scripts/statistics/corrcoef.m
@@ -54,17 +54,17 @@
 ## Determine processing of NaN values.  Acceptable values are @qcode{"all"},
 ## @qcode{"complete"}, and @qcode{"pairwise"}.  Default is @qcode{"all"}.
 ## With @qcode{"complete"}, only the rows without NaN values are considered.
 ## With @qcode{"pairwise"}, the selection of NaN-free rows is made for each
 ## pair of variables.
 ##
 ## @end table
 ##
-## @seealso{corr, cov, cor_test}
+## @seealso{corr, cov}
 ## @end deftypefn
 
 ## FIXME: It would be good to add a definition of the calculation method
 ## for a Pearson product moment correlation to the documentation.
 
 function [r, p, lci, hci] = corrcoef (x, varargin)
 
   if (nargin == 0)
@@ -158,34 +158,76 @@ function [r, p, lci, hci] = corrcoef (x,
       xj = x(:,j);
       if (pairwise)
         idx = any (isnan ([xi xj]), 2);
         xi(idx) = xj(idx) = [];
         mpw(i,j) = mpw(j,i) = m - nnz (idx);
       endif
       r(i,j) = r(j,i) = corr (xi, xj);
       if (calc_pval)
-        T = cor_test (xi, xj, "!=", "pearson");
-        p(i,j) = p(j,i) = T.pval;
+        df = m - 2;  
+        stat = sqrt (df) * r(i,j) / sqrt (1 - r(i,j)^2);
+        cdf = tcdf (stat, df);
+        p(i,j) = p(j,i) = 2 * min (cdf, 1 - cdf);
       endif
     endfor
   endfor
 
   if (nargout > 2)
     if (pairwise)
       m = mpw;
     endif
     CI = sqrt (2) * erfinv (1-alpha) ./ sqrt (m-3);
     lci = tanh (atanh (r) - CI);
     hci = tanh (atanh (r) + CI);
   endif
 
 endfunction
 
 
+## Compute cumulative distribution function for T distribution.
+function cdf = tcdf (x, n)
+
+  if (iscomplex (x))
+    error ("tcdf: X must not be complex");
+  endif
+
+  if (isa (x, "single"))
+    cdf = zeros (size (x), "single");
+  else
+    cdf = zeros (size (x));
+  endif
+
+  k = ! isinf (x) & (n > 0);
+
+  xx = x .^ 2;
+  x_big_abs = (xx > n);
+
+  ## deal with the case "abs(x) big"
+  kk = k & x_big_abs;
+  cdf(kk) = betainc (n ./ (n + xx(kk)), n/2, 1/2) / 2;
+
+  ## deal with the case "abs(x) small"
+  kk = k & ! x_big_abs;
+  cdf(kk) = 0.5 * (1 - betainc (xx(kk) ./ (n + xx(kk)), 1/2, n/2));
+
+  k &= (x > 0);
+  if (any (k(:)))
+    cdf(k) = 1 - cdf(k);
+  endif
+
+  k = isnan (x) | !(n > 0);
+  cdf(k) = NaN;
+
+  k = (x == Inf) & (n > 0);
+  cdf(k) = 1;
+
+endfunction
+
+
 %!test
 %! x = rand (5);
 %! r = corrcoef (x);
 %! assert (size (r) == [5, 5]);
 
 %!test
 %! x = [1 2 3];
 %! r = corrcoef (x);
diff --git a/scripts/statistics/base/cov.m b/scripts/statistics/cov.m
rename from scripts/statistics/base/cov.m
rename to scripts/statistics/cov.m
diff --git a/scripts/statistics/distributions/discrete_cdf.m b/scripts/statistics/discrete_cdf.m
rename from scripts/statistics/distributions/discrete_cdf.m
rename to scripts/statistics/discrete_cdf.m
diff --git a/scripts/statistics/distributions/discrete_inv.m b/scripts/statistics/discrete_inv.m
rename from scripts/statistics/distributions/discrete_inv.m
rename to scripts/statistics/discrete_inv.m
diff --git a/scripts/statistics/distributions/discrete_pdf.m b/scripts/statistics/discrete_pdf.m
rename from scripts/statistics/distributions/discrete_pdf.m
rename to scripts/statistics/discrete_pdf.m
diff --git a/scripts/statistics/distributions/discrete_rnd.m b/scripts/statistics/discrete_rnd.m
rename from scripts/statistics/distributions/discrete_rnd.m
rename to scripts/statistics/discrete_rnd.m
diff --git a/scripts/statistics/distributions/betacdf.m b/scripts/statistics/distributions/betacdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/betacdf.m
+++ /dev/null
@@ -1,92 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} betacdf (@var{x}, @var{a}, @var{b})
-## For each element of @var{x}, compute the cumulative distribution function
-## (CDF) at @var{x} of the Beta distribution with parameters @var{a} and
-## @var{b}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: CDF of the Beta distribution
-
-function cdf = betacdf (x, a, b)
-
-  if (nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (a) || ! isscalar (b))
-    [retval, x, a, b] = common_size (x, a, b);
-    if (retval > 0)
-      error ("betacdf: X, A, and B must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (a) || iscomplex (b))
-    error ("betacdf: X, A, and B must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (a, "single") || isa (b, "single"))
-    cdf = zeros (size (x), "single");
-  else
-    cdf = zeros (size (x));
-  endif
-
-  k = isnan (x) | !(a > 0) | !(b > 0);
-  cdf(k) = NaN;
-
-  k = (x >= 1) & (a > 0) & (b > 0);
-  cdf(k) = 1;
-
-  k = (x > 0) & (x < 1) & (a > 0) & (b > 0);
-  if (isscalar (a) && isscalar (b))
-    cdf(k) = betainc (x(k), a, b);
-  else
-    cdf(k) = betainc (x(k), a(k), b(k));
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 0.5 1 2];
-%! y = [0 0 0.75 1 1];
-%!assert (betacdf (x, ones (1,5), 2*ones (1,5)), y)
-%!assert (betacdf (x, 1, 2*ones (1,5)), y)
-%!assert (betacdf (x, ones (1,5), 2), y)
-%!assert (betacdf (x, [0 1 NaN 1 1], 2), [NaN 0 NaN 1 1])
-%!assert (betacdf (x, 1, 2*[0 1 NaN 1 1]), [NaN 0 NaN 1 1])
-%!assert (betacdf ([x(1:2) NaN x(4:5)], 1, 2), [y(1:2) NaN y(4:5)])
-
-## Test class of input preserved
-%!assert (betacdf ([x, NaN], 1, 2), [y, NaN])
-%!assert (betacdf (single ([x, NaN]), 1, 2), single ([y, NaN]))
-%!assert (betacdf ([x, NaN], single (1), 2), single ([y, NaN]))
-%!assert (betacdf ([x, NaN], 1, single (2)), single ([y, NaN]))
-
-## Test input validation
-%!error betacdf ()
-%!error betacdf (1)
-%!error betacdf (1,2)
-%!error betacdf (1,2,3,4)
-%!error betacdf (ones (3), ones (2), ones (2))
-%!error betacdf (ones (2), ones (3), ones (2))
-%!error betacdf (ones (2), ones (2), ones (3))
diff --git a/scripts/statistics/distributions/betainv.m b/scripts/statistics/distributions/betainv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/betainv.m
+++ /dev/null
@@ -1,136 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} betainv (@var{x}, @var{a}, @var{b})
-## For each element of @var{x}, compute the quantile (the inverse of the CDF)
-## at @var{x} of the Beta distribution with parameters @var{a} and @var{b}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Quantile function of the Beta distribution
-
-function inv = betainv (x, a, b)
-
-  if (nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (a) || ! isscalar (b))
-    [retval, x, a, b] = common_size (x, a, b);
-    if (retval > 0)
-      error ("betainv: X, A, and B must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (a) || iscomplex (b))
-    error ("betainv: X, A, and B must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (a, "single") || isa (b, "single"))
-    inv = zeros (size (x), "single");
-  else
-    inv = zeros (size (x));
-  endif
-
-  k = (x < 0) | (x > 1) | !(a > 0) | !(b > 0) | isnan (x);
-  inv(k) = NaN;
-
-  k = (x == 1) & (a > 0) & (b > 0);
-  inv(k) = 1;
-
-  k = find ((x > 0) & (x < 1) & (a > 0) & (b > 0));
-  if (! isempty (k))
-    if (! isscalar (a) || ! isscalar (b))
-      a = a(k);
-      b = b(k);
-      y = a ./ (a + b);
-    else
-      y = a / (a + b) * ones (size (k));
-    endif
-    x = x(k);
-
-    if (isa (y, "single"))
-      myeps = eps ("single");
-    else
-      myeps = eps;
-    endif
-
-    l = find (y < myeps);
-    if (any (l))
-      y(l) = sqrt (myeps) * ones (length (l), 1);
-    endif
-    l = find (y > 1 - myeps);
-    if (any (l))
-      y(l) = 1 - sqrt (myeps) * ones (length (l), 1);
-    endif
-
-    y_new = y;
-    loopcnt = 0;
-    do
-      y_old = y_new;
-      h     = (betacdf (y_old, a, b) - x) ./ betapdf (y_old, a, b);
-      y_new = y_old - h;
-      ind   = find (y_new <= myeps);
-      if (any (ind))
-        y_new(ind) = y_old(ind) / 10;
-      endif
-      ind = find (y_new >= 1 - myeps);
-      if (any (ind))
-        y_new(ind) = 1 - (1 - y_old(ind)) / 10;
-      endif
-      h = y_old - y_new;
-    until (max (abs (h)) < sqrt (myeps) || ++loopcnt == 40)
-
-    if (loopcnt == 40)
-      warning ("betainv: calculation failed to converge for some values");
-    endif
-
-    inv(k) = y_new;
-  endif
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 0.75 1 2];
-%!assert (betainv (x, ones (1,5), 2*ones (1,5)), [NaN 0 0.5 1 NaN])
-%!assert (betainv (x, 1, 2*ones (1,5)), [NaN 0 0.5 1 NaN])
-%!assert (betainv (x, ones (1,5), 2), [NaN 0 0.5 1 NaN])
-%!assert (betainv (x, [1 0 NaN 1 1], 2), [NaN NaN NaN 1 NaN])
-%!assert (betainv (x, 1, 2*[1 0 NaN 1 1]), [NaN NaN NaN 1 NaN])
-%!assert (betainv ([x(1:2) NaN x(4:5)], 1, 2), [NaN 0 NaN 1 NaN])
-
-## Test class of input preserved
-%!assert (betainv ([x, NaN], 1, 2), [NaN 0 0.5 1 NaN NaN])
-%!assert (betainv (single ([x, NaN]), 1, 2), single ([NaN 0 0.5 1 NaN NaN]))
-%!assert (betainv ([x, NaN], single (1), 2), single ([NaN 0 0.5 1 NaN NaN]))
-%!assert (betainv ([x, NaN], 1, single (2)), single ([NaN 0 0.5 1 NaN NaN]))
-
-## Test input validation
-%!error betainv ()
-%!error betainv (1)
-%!error betainv (1,2)
-%!error betainv (1,2,3,4)
-%!error betainv (ones (3), ones (2), ones (2))
-%!error betainv (ones (2), ones (3), ones (2))
-%!error betainv (ones (2), ones (2), ones (3))
-%!error betainv (i, 2, 2)
-%!error betainv (2, i, 2)
-%!error betainv (2, 2, i)
diff --git a/scripts/statistics/distributions/betapdf.m b/scripts/statistics/distributions/betapdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/betapdf.m
+++ /dev/null
@@ -1,129 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-## Copyright (C) 2010 Christos Dimitrakakis
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} betapdf (@var{x}, @var{a}, @var{b})
-## For each element of @var{x}, compute the probability density function (PDF)
-## at @var{x} of the Beta distribution with parameters @var{a} and @var{b}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>, CD <christos.dimitrakakis@gmail.com>
-## Description: PDF of the Beta distribution
-
-function pdf = betapdf (x, a, b)
-
-  if (nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (a) || ! isscalar (b))
-    [retval, x, a, b] = common_size (x, a, b);
-    if (retval > 0)
-      error ("betapdf: X, A, and B must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (a) || iscomplex (b))
-    error ("betapdf: X, A, and B must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (a, "single") || isa (b, "single"));
-    pdf = zeros (size (x), "single");
-  else
-    pdf = zeros (size (x));
-  endif
-
-  k = !(a > 0) | !(b > 0) | isnan (x);
-  pdf(k) = NaN;
-
-  k = (x > 0) & (x < 1) & (a > 0) & (b > 0) & ((a != 1) | (b != 1));
-  if (isscalar (a) && isscalar (b))
-    pdf(k) = exp ((a - 1) * log (x(k))
-                  + (b - 1) * log (1 - x(k))
-                  + gammaln (a + b) - gammaln (a) - gammaln (b));
-  else
-    pdf(k) = exp ((a(k) - 1) .* log (x(k))
-                  + (b(k) - 1) .* log (1 - x(k))
-                  + gammaln (a(k) + b(k)) - gammaln (a(k)) - gammaln (b(k)));
-  endif
-
-  ## Most important special cases when the density is finite.
-  k = (x == 0) & (a == 1) & (b > 0) & (b != 1);
-  if (isscalar (a) && isscalar (b))
-    pdf(k) = exp (gammaln (a + b) - gammaln (a) - gammaln (b));
-  else
-    pdf(k) = exp (gammaln (a(k) + b(k)) - gammaln (a(k)) - gammaln (b(k)));
-  endif
-
-  k = (x == 1) & (b == 1) & (a > 0) & (a != 1);
-  if (isscalar (a) && isscalar (b))
-    pdf(k) = exp (gammaln (a + b) - gammaln (a) - gammaln (b));
-  else
-    pdf(k) = exp (gammaln (a(k) + b(k)) - gammaln (a(k)) - gammaln (b(k)));
-  endif
-
-  k = (x >= 0) & (x <= 1) & (a == 1) & (b == 1);
-  pdf(k) = 1;
-
-  ## Other special case when the density at the boundary is infinite.
-  k = (x == 0) & (a < 1);
-  pdf(k) = Inf;
-
-  k = (x == 1) & (b < 1);
-  pdf(k) = Inf;
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 0.5 1 2];
-%! y = [0 2 1 0 0];
-%!assert (betapdf (x, ones (1,5), 2*ones (1,5)), y)
-%!assert (betapdf (x, 1, 2*ones (1,5)), y)
-%!assert (betapdf (x, ones (1,5), 2), y)
-%!assert (betapdf (x, [0 NaN 1 1 1], 2), [NaN NaN y(3:5)])
-%!assert (betapdf (x, 1, 2*[0 NaN 1 1 1]), [NaN NaN y(3:5)])
-%!assert (betapdf ([x, NaN], 1, 2), [y, NaN])
-
-## Test class of input preserved
-%!assert (betapdf (single ([x, NaN]), 1, 2), single ([y, NaN]))
-%!assert (betapdf ([x, NaN], single (1), 2), single ([y, NaN]))
-%!assert (betapdf ([x, NaN], 1, single (2)), single ([y, NaN]))
-
-## Beta (1/2,1/2) == arcsine distribution
-%!test
-%! x = rand (10,1);
-%! y = 1./(pi * sqrt (x.*(1-x)));
-%! assert (betapdf (x, 1/2, 1/2), y, 50*eps);
-
-## Test large input values to betapdf
-%!assert (betapdf (0.5, 1000, 1000), 35.678, 1e-3)
-
-## Test input validation
-%!error betapdf ()
-%!error betapdf (1)
-%!error betapdf (1,2)
-%!error betapdf (1,2,3,4)
-%!error betapdf (ones (3), ones (2), ones (2))
-%!error betapdf (ones (2), ones (3), ones (2))
-%!error betapdf (ones (2), ones (2), ones (3))
-%!error betapdf (i, 2, 2)
-%!error betapdf (2, i, 2)
-%!error betapdf (2, 2, i)
diff --git a/scripts/statistics/distributions/betarnd.m b/scripts/statistics/distributions/betarnd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/betarnd.m
+++ /dev/null
@@ -1,133 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} betarnd (@var{a}, @var{b})
-## @deftypefnx {} {} betarnd (@var{a}, @var{b}, @var{r})
-## @deftypefnx {} {} betarnd (@var{a}, @var{b}, @var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} betarnd (@var{a}, @var{b}, [@var{sz}])
-## Return a matrix of random samples from the Beta distribution with parameters
-## @var{a} and @var{b}.
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-##
-## If no size arguments are given then the result matrix is the common size of
-## @var{a} and @var{b}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Random deviates from the Beta distribution
-
-function rnd = betarnd (a, b, varargin)
-
-  if (nargin < 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (a) || ! isscalar (b))
-    [retval, a, b] = common_size (a, b);
-    if (retval > 0)
-      error ("betarnd: A and B must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (a) || iscomplex (b))
-    error ("betarnd: A and B must not be complex");
-  endif
-
-  if (nargin == 2)
-    sz = size (a);
-  elseif (nargin == 3)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1};
-    else
-      error ("betarnd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 3)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("betarnd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  if (! isscalar (a) && ! isequal (size (a), sz))
-    error ("betarnd: A and B must be scalar or of size SZ");
-  endif
-
-  if (isa (a, "single") || isa (b, "single"))
-    cls = "single";
-  else
-    cls = "double";
-  endif
-
-  if (isscalar (a) && isscalar (b))
-    if ((a > 0) && (a < Inf) && (b > 0) && (b < Inf))
-      r = randg (a, sz, cls);
-      rnd = r ./ (r + randg (b, sz, cls));
-    else
-      rnd = NaN (sz, cls);
-    endif
-  else
-    rnd = NaN (sz, cls);
-
-    k = (a > 0) & (a < Inf) & (b > 0) & (b < Inf);
-    r = randg (a(k), cls);
-    rnd(k) = r ./ (r + randg (b(k), cls));
-  endif
-
-endfunction
-
-
-%!assert (size (betarnd (1,2)), [1, 1])
-%!assert (size (betarnd (ones (2,1), 2)), [2, 1])
-%!assert (size (betarnd (ones (2,2), 2)), [2, 2])
-%!assert (size (betarnd (1, 2*ones (2,1))), [2, 1])
-%!assert (size (betarnd (1, 2*ones (2,2))), [2, 2])
-%!assert (size (betarnd (1, 2, 3)), [3, 3])
-%!assert (size (betarnd (1, 2, [4 1])), [4, 1])
-%!assert (size (betarnd (1, 2, 4, 1)), [4, 1])
-
-## Test class of input preserved
-%!assert (class (betarnd (1, 2)), "double")
-%!assert (class (betarnd (single (1), 2)), "single")
-%!assert (class (betarnd (single ([1 1]), 2)), "single")
-%!assert (class (betarnd (1, single (2))), "single")
-%!assert (class (betarnd (1, single ([2 2]))), "single")
-
-## Test input validation
-%!error betarnd ()
-%!error betarnd (1)
-%!error betarnd (ones (3), ones (2))
-%!error betarnd (ones (2), ones (3))
-%!error betarnd (i, 2)
-%!error betarnd (2, i)
-%!error betarnd (1,2, -1)
-%!error betarnd (1,2, ones (2))
-%!error binornd (1,2, [2 -1 2])
-%!error betarnd (1,2, 1, ones (2))
-%!error betarnd (1,2, 1, -1)
-%!error betarnd (ones (2,2), 2, 3)
-%!error betarnd (ones (2,2), 2, [3, 2])
-%!error betarnd (ones (2,2), 2, 2, 3)
diff --git a/scripts/statistics/distributions/binocdf.m b/scripts/statistics/distributions/binocdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/binocdf.m
+++ /dev/null
@@ -1,97 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} binocdf (@var{x}, @var{n}, @var{p})
-## For each element of @var{x}, compute the cumulative distribution function
-## (CDF) at @var{x} of the binomial distribution with parameters @var{n} and
-## @var{p}, where @var{n} is the number of trials and @var{p} is the
-## probability of success.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: CDF of the binomial distribution
-
-function cdf = binocdf (x, n, p)
-
-  if (nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (n) || ! isscalar (p))
-    [retval, x, n, p] = common_size (x, n, p);
-    if (retval > 0)
-      error ("binocdf: X, N, and P must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (n) || iscomplex (p))
-    error ("binocdf: X, N, and P must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (n, "single") || isa (p, "single"));
-    cdf = zeros (size (x), "single");
-  else
-    cdf = zeros (size (x));
-  endif
-
-  k = isnan (x) | !(n >= 0) | (n != fix (n)) | !(p >= 0) | !(p <= 1);
-  cdf(k) = NaN;
-
-  k = (x >= n) & (n >= 0) & (n == fix (n) & (p >= 0) & (p <= 1));
-  cdf(k) = 1;
-
-  k = (x >= 0) & (x < n) & (n == fix (n)) & (p >= 0) & (p <= 1);
-  tmp = floor (x(k));
-  if (isscalar (n) && isscalar (p))
-    cdf(k) = betainc (1 - p, n - tmp, tmp + 1);
-  else
-    cdf(k) = betainc (1 .- p(k), n(k) - tmp, tmp + 1);
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 1 2 3];
-%! y = [0 1/4 3/4 1 1];
-%!assert (binocdf (x, 2*ones (1,5), 0.5*ones (1,5)), y)
-%!assert (binocdf (x, 2, 0.5*ones (1,5)), y)
-%!assert (binocdf (x, 2*ones (1,5), 0.5), y)
-%!assert (binocdf (x, 2*[0 -1 NaN 1.1 1], 0.5), [0 NaN NaN NaN 1])
-%!assert (binocdf (x, 2, 0.5*[0 -1 NaN 3 1]), [0 NaN NaN NaN 1])
-%!assert (binocdf ([x(1:2) NaN x(4:5)], 2, 0.5), [y(1:2) NaN y(4:5)])
-
-## Test class of input preserved
-%!assert (binocdf ([x, NaN], 2, 0.5), [y, NaN])
-%!assert (binocdf (single ([x, NaN]), 2, 0.5), single ([y, NaN]))
-%!assert (binocdf ([x, NaN], single (2), 0.5), single ([y, NaN]))
-%!assert (binocdf ([x, NaN], 2, single (0.5)), single ([y, NaN]))
-
-## Test input validation
-%!error binocdf ()
-%!error binocdf (1)
-%!error binocdf (1,2)
-%!error binocdf (1,2,3,4)
-%!error binocdf (ones (3), ones (2), ones (2))
-%!error binocdf (ones (2), ones (3), ones (2))
-%!error binocdf (ones (2), ones (2), ones (3))
-%!error binocdf (i, 2, 2)
-%!error binocdf (2, i, 2)
-%!error binocdf (2, 2, i)
diff --git a/scripts/statistics/distributions/binoinv.m b/scripts/statistics/distributions/binoinv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/binoinv.m
+++ /dev/null
@@ -1,198 +0,0 @@
-## Copyright (C) 2016-2017 Lachlan Andrew
-## Copyright (C) 2012-2016 Rik Wehbring
-## Copyright (C) 1995-2012 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} binoinv (@var{x}, @var{n}, @var{p})
-## For each element of @var{x}, compute the quantile (the inverse of the CDF)
-## at @var{x} of the binomial distribution with parameters
-## @var{n} and @var{p}, where @var{n} is the number of trials and
-## @var{p} is the probability of success.
-## @end deftypefn
-
-function inv = binoinv (x, n, p)
-
-  if (nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (n) || ! isscalar (p))
-    [retval, x, n, p] = common_size (x, n, p);
-    if (retval > 0)
-      error ("binoinv: X, N, and P must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (n) || iscomplex (p))
-    error ("binoinv: X, N, and P must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (n, "single") || isa (p, "single"));
-    inv = zeros (size (x), "single");
-  else
-    inv = zeros (size (x));
-  endif
-
-  k = (!(x >= 0) | !(x <= 1) | !(n >= 0) | (n != fix (n)) |
-       !(p >= 0) | !(p <= 1));
-  inv(k) = NaN;
-
-  k = find ((x >= 0) & (x <= 1) & (n >= 0) & (n == fix (n)
-             & (p >= 0) & (p <= 1)));
-  if (! isempty (k))
-    x = x(k);
-    if (isscalar (n) && isscalar (p))
-      [inv(k), unfinished] = scalar_binoinv (x(:), n, p);
-      k = k(unfinished);
-      if (! isempty (k))
-        inv(k) = bin_search_binoinv (x(k), n, p);
-      endif
-    else
-      [inv(k), unfinished] = vector_binoinv (x(:), n(:), p(:));
-      k = k(unfinished);
-      if (! isempty (k))
-        inv(k) = bin_search_binoinv (x(k), n(k), p(k));
-      endif
-    endif
-  endif
-
-endfunction
-
-## Core algorithm to calculate the inverse binomial, for n and p real scalars
-## and y a column vector, and for which the output is not NaN or Inf.
-## Compute CDF in batches of doubling size until CDF > x, or answer > 500
-## Return the locations of unfinished cases in k.
-function [m, k] = scalar_binoinv (x, n, p)
-
-  k = 1:length (x);
-  m = zeros (size (x));
-  prev_limit = 0;
-  limit = 10;
-  cdf = 0;
-  v = 0;
-  do
-    cdf = binocdf (prev_limit:limit-1, n, p);
-    r = bsxfun (@le, x(k), cdf);
-    [v, m(k)] = max (r, [], 2);     # find first instance of x <= cdf
-    m(k) += prev_limit - 1;
-    k = k(v == 0);
-
-    prev_limit = limit;
-    limit += limit;
-  until (isempty (k) || limit >= 1000)
-
-endfunction
-
-## Core algorithm to calculate the inverse binomial, for n, p, and y column
-## vectors, and for which the output is not NaN or Inf.
-## Compute CDF in batches of doubling size until CDF > x, or answer > 500
-## Return the locations of unfinished cases in k.
-## Calculates CDF by summing PDF, which is faster than calls to binocdf.
-function [m, k] = vector_binoinv (x, n, p)
-
-  k = 1:length(x);
-  m = zeros (size (x));
-  prev_limit = 0;
-  limit = 10;
-  cdf = 0;
-  v = 0;
-  do
-    xx = repmat (prev_limit:limit-1, [length(k), 1]);
-    nn = kron (ones (1, limit-prev_limit), n(k));
-    pp = kron (ones (1, limit-prev_limit), p(k));
-    pdf = binopdf (xx, nn, pp);
-    pdf(:,1) += cdf(v==0, end);
-    cdf = cumsum (pdf, 2);
-    r = bsxfun (@le, x(k), cdf);
-    [v, m(k)] = max (r, [], 2);     # find first instance of x <= cdf
-    m(k) += prev_limit - 1;
-    k = k(v == 0);
-
-    prev_limit = limit;
-    limit += min (limit, max (1e4/numel (k), 10));  # limit memory use
-  until (isempty (k) || limit >= 1000)
-
-endfunction
-
-## Vectorized binary search.
-## Can handle vectors n and p, and is faster than the scalar case when the
-## answer is large.
-## Could be optimized to call binocdf only for a subset of the x at each stage,
-## but care must be taken to handle both scalar and vector n, p.  Bookkeeping
-## may cost more than the extra computations.
-function m = bin_search_binoinv (x, n, p)
-
-  k = 1:length (x);
-  lower = zeros (size (x));
-  limit = 500;              # lower bound on point at which prev phase finished
-  while (any (k) && limit < 1e100)
-    cdf = binocdf (limit, n, p);
-    k = (x > cdf);
-    lower(k) = limit;
-    limit += limit;
-  endwhile
-  upper = max (2*lower, 1);
-  k = find (lower != limit/2);       # elements for which above loop finished
-  for i = 1:ceil (log2 (max (lower)))
-    mid = (upper + lower)/2;
-    cdf = binocdf (floor(mid(:)), n, p);
-    r = (x <= cdf);
-    upper(r)  = mid(r);
-    lower(! r) = mid(! r);
-  endfor
-  m = ceil (lower);
-  m(x > binocdf (m(:), n, p)) += 1;  # fix off-by-one errors from binary search
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 0.5 1 2];
-%!assert (binoinv (x, 2*ones (1,5), 0.5*ones (1,5)), [NaN 0 1 2 NaN])
-%!assert (binoinv (x, 2, 0.5*ones (1,5)), [NaN 0 1 2 NaN])
-%!assert (binoinv (x, 2*ones (1,5), 0.5), [NaN 0 1 2 NaN])
-%!assert (binoinv (x, 2*[0 -1 NaN 1.1 1], 0.5), [NaN NaN NaN NaN NaN])
-%!assert (binoinv (x, 2, 0.5*[0 -1 NaN 3 1]), [NaN NaN NaN NaN NaN])
-%!assert (binoinv ([x(1:2) NaN x(4:5)], 2, 0.5), [NaN 0 NaN 2 NaN])
-
-## Test class of input preserved
-%!assert (binoinv ([x, NaN], 2, 0.5), [NaN 0 1 2 NaN NaN])
-%!assert (binoinv (single ([x, NaN]), 2, 0.5), single ([NaN 0 1 2 NaN NaN]))
-%!assert (binoinv ([x, NaN], single (2), 0.5), single ([NaN 0 1 2 NaN NaN]))
-%!assert (binoinv ([x, NaN], 2, single (0.5)), single ([NaN 0 1 2 NaN NaN]))
-
-## Test accuracy, to within +/- 1 since it is a discrete distribution
-%!shared y, tol
-%! y = magic (3) + 1;
-%! tol = 1;
-%!assert (binoinv (binocdf (1:10, 11, 0.1), 11, 0.1), 1:10, tol)
-%!assert (binoinv (binocdf (1:10, 2*(1:10), 0.1), 2*(1:10), 0.1), 1:10, tol)
-%!assert (binoinv (binocdf (y, 2*y, 1./y), 2*y, 1./y), y, tol)
-
-## Test input validation
-%!error binoinv ()
-%!error binoinv (1)
-%!error binoinv (1,2)
-%!error binoinv (1,2,3,4)
-%!error binoinv (ones (3), ones (2), ones (2))
-%!error binoinv (ones (2), ones (3), ones (2))
-%!error binoinv (ones (2), ones (2), ones (3))
-%!error binoinv (i, 2, 2)
-%!error binoinv (2, i, 2)
-%!error binoinv (2, 2, i)
diff --git a/scripts/statistics/distributions/binopdf.m b/scripts/statistics/distributions/binopdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/binopdf.m
+++ /dev/null
@@ -1,111 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} binopdf (@var{x}, @var{n}, @var{p})
-## For each element of @var{x}, compute the probability density function (PDF)
-## at @var{x} of the binomial distribution with parameters @var{n} and @var{p},
-## where @var{n} is the number of trials and @var{p} is the probability of
-## success.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: PDF of the binomial distribution
-
-function pdf = binopdf (x, n, p)
-
-  if (nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (n) || ! isscalar (p))
-    [retval, x, n, p] = common_size (x, n, p);
-    if (retval > 0)
-      error ("binopdf: X, N, and P must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (n) || iscomplex (p))
-    error ("binopdf: X, N, and P must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (n, "single") || isa (p, "single"));
-    pdf = zeros (size (x), "single");
-  else
-    pdf = zeros (size (x));
-  endif
-
-  k = (x == fix (x)) & (n == fix (n)) & (n >= 0) & (p >= 0) & (p <= 1);
-
-  pdf(! k) = NaN;
-
-  k &= ((x >= 0) & (x <= n));
-  if (isscalar (n) && isscalar (p))
-    pdf(k) = exp (gammaln (n+1) - gammaln (x(k)+1) - gammaln (n-x(k)+1)
-                  + x(k)*log (p) + (n-x(k))*log (1-p));
-  else
-    pdf(k) = exp (gammaln (n(k)+1) - gammaln (x(k)+1) - gammaln (n(k)-x(k)+1)
-                  + x(k).*log (p(k)) + (n(k)-x(k)).*log (1-p(k)));
-  endif
-
-  ## Special case inputs
-  ksp = k & (p == 0) & (x == 0);
-  pdf(ksp) = 1;
-  ksp = k & (p == 1) & (x == n);
-  pdf(ksp) = 1;
-
-endfunction
-
-
-%!shared x,y,tol
-%! if (ismac ())
-%!   tol = eps ();
-%! else
-%!   tol = 0;
-%! endif
-%! x = [-1 0 1 2 3];
-%! y = [0 1/4 1/2 1/4 0];
-%!assert (binopdf (x, 2*ones (1,5), 0.5*ones (1,5)), y, tol)
-%!assert (binopdf (x, 2, 0.5*ones (1,5)), y, tol)
-%!assert (binopdf (x, 2*ones (1,5), 0.5), y, tol)
-%!assert (binopdf (x, 2*[0 -1 NaN 1.1 1], 0.5), [0 NaN NaN NaN 0])
-%!assert (binopdf (x, 2, 0.5*[0 -1 NaN 3 1]), [0 NaN NaN NaN 0])
-%!assert (binopdf ([x, NaN], 2, 0.5), [y, NaN], tol)
-
-## Test Special input values
-%!assert (binopdf (0, 3, 0), 1)
-%!assert (binopdf (2, 2, 1), 1)
-%!assert (binopdf (1, 2, 1), 0)
-
-## Test class of input preserved
-%!assert (binopdf (single ([x, NaN]), 2, 0.5), single ([y, NaN]))
-%!assert (binopdf ([x, NaN], single (2), 0.5), single ([y, NaN]))
-%!assert (binopdf ([x, NaN], 2, single (0.5)), single ([y, NaN]))
-
-## Test input validation
-%!error binopdf ()
-%!error binopdf (1)
-%!error binopdf (1,2)
-%!error binopdf (1,2,3,4)
-%!error binopdf (ones (3), ones (2), ones (2))
-%!error binopdf (ones (2), ones (3), ones (2))
-%!error binopdf (ones (2), ones (2), ones (3))
-%!error binopdf (i, 2, 2)
-%!error binopdf (2, i, 2)
-%!error binopdf (2, 2, i)
diff --git a/scripts/statistics/distributions/binornd.m b/scripts/statistics/distributions/binornd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/binornd.m
+++ /dev/null
@@ -1,153 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} binornd (@var{n}, @var{p})
-## @deftypefnx {} {} binornd (@var{n}, @var{p}, @var{r})
-## @deftypefnx {} {} binornd (@var{n}, @var{p}, @var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} binornd (@var{n}, @var{p}, [@var{sz}])
-## Return a matrix of random samples from the binomial distribution with
-## parameters @var{n} and @var{p}, where @var{n} is the number of trials
-## and @var{p} is the probability of success.
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-##
-## If no size arguments are given then the result matrix is the common size of
-## @var{n} and @var{p}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Random deviates from the binomial distribution
-
-function rnd = binornd (n, p, varargin)
-
-  if (nargin < 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (n) || ! isscalar (p))
-    [retval, n, p] = common_size (n, p);
-    if (retval > 0)
-      error ("binornd: N and P must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (n) || iscomplex (p))
-    error ("binornd: N and P must not be complex");
-  endif
-
-  if (nargin == 2)
-    sz = size (n);
-  elseif (nargin == 3)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1};
-    else
-      error ("binornd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 3)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("binornd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  if (! isscalar (n) && ! isequal (size (n), sz))
-    error ("binornd: N and P must be scalar or of size SZ");
-  endif
-
-  if (isa (n, "single") || isa (p, "single"))
-    cls = "single";
-  else
-    cls = "double";
-  endif
-
-  if (isscalar (n) && isscalar (p))
-    if ((n > 0) && (n < Inf) && (n == fix (n)) && (p >= 0) && (p <= 1))
-      nel = prod (sz);
-      tmp = rand (n, nel);
-      rnd = sum (tmp < p, 1);
-      rnd = reshape (rnd, sz);
-      if (strcmp (cls, "single"))
-        rnd = single (rnd);
-      endif
-    elseif ((n == 0) && (p >= 0) && (p <= 1))
-      rnd = zeros (sz, cls);
-    else
-      rnd = NaN (sz, cls);
-    endif
-  else
-    rnd = zeros (sz, cls);
-
-    k = !(n >= 0) | !(n < Inf) | !(n == fix (n)) | !(p >= 0) | !(p <= 1);
-    rnd(k) = NaN;
-
-    k = (n > 0) & (n < Inf) & (n == fix (n)) & (p >= 0) & (p <= 1);
-    if (any (k(:)))
-      N = max (n(k));
-      L = sum (k(:));
-      tmp = rand (N, L);
-      ind = repmat ((1 : N)', 1, L);
-      rnd(k) = sum ((tmp < repmat (p(k)(:)', N, 1)) &
-                    (ind <= repmat (n(k)(:)', N, 1)), 1);
-    endif
-  endif
-
-endfunction
-
-
-%!assert (binornd (0, 0, 1), 0)
-%!assert (binornd ([0, 0], [0, 0], 1, 2), [0, 0])
-
-%!assert (size (binornd (2, 1/2)), [1, 1])
-%!assert (size (binornd (2*ones (2,1), 1/2)), [2, 1])
-%!assert (size (binornd (2*ones (2,2), 1/2)), [2, 2])
-%!assert (size (binornd (2, 1/2*ones (2,1))), [2, 1])
-%!assert (size (binornd (2, 1/2*ones (2,2))), [2, 2])
-%!assert (size (binornd (2, 1/2, 3)), [3, 3])
-%!assert (size (binornd (2, 1/2, [4 1])), [4, 1])
-%!assert (size (binornd (2, 1/2, 4, 1)), [4, 1])
-
-## Test class of input preserved
-%!assert (class (binornd (2, 0.5)), "double")
-%!assert (class (binornd (single (2), 0.5)), "single")
-%!assert (class (binornd (single ([2 2]), 0.5)), "single")
-%!assert (class (binornd (2, single (0.5))), "single")
-%!assert (class (binornd (2, single ([0.5 0.5]))), "single")
-
-## Test input validation
-%!error binornd ()
-%!error binornd (1)
-%!error binornd (ones (3), ones (2))
-%!error binornd (ones (2), ones (3))
-%!error binornd (i, 2)
-%!error binornd (2, i)
-%!error binornd (1,2, -1)
-%!error binornd (1,2, ones (2))
-%!error binornd (1,2, [2 -1 2])
-%!error binornd (1,2, 1, ones (2))
-%!error binornd (1,2, 1, -1)
-%!error binornd (ones (2,2), 2, 3)
-%!error binornd (ones (2,2), 2, [3, 2])
-%!error binornd (ones (2,2), 2, 2, 3)
diff --git a/scripts/statistics/distributions/cauchy_cdf.m b/scripts/statistics/distributions/cauchy_cdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/cauchy_cdf.m
+++ /dev/null
@@ -1,91 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} cauchy_cdf (@var{x})
-## @deftypefnx {} {} cauchy_cdf (@var{x}, @var{location}, @var{scale})
-## For each element of @var{x}, compute the cumulative distribution function
-## (CDF) at @var{x} of the Cauchy distribution with location parameter
-## @var{location} and scale parameter @var{scale}.
-##
-## Default values are @var{location} = 0, @var{scale} = 1.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: CDF of the Cauchy distribution
-
-function cdf = cauchy_cdf (x, location = 0, scale = 1)
-
-  if (nargin != 1 && nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (location) || ! isscalar (scale))
-    [retval, x, location, scale] = common_size (x, location, scale);
-    if (retval > 0)
-      error ("cauchy_cdf: X, LOCATION, and SCALE must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (location) || iscomplex (scale))
-    error ("cauchy_cdf: X, LOCATION, and SCALE must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (location, "single") || isa (scale, "single"));
-    cdf = NaN (size (x), "single");
-  else
-    cdf = NaN (size (x));
-  endif
-
-  k = ! isinf (location) & (scale > 0) & (scale < Inf);
-  if (isscalar (location) && isscalar (scale))
-    cdf = 0.5 + atan ((x - location) / scale) / pi;
-  else
-    cdf(k) = 0.5 + atan ((x(k) - location(k)) ./ scale(k)) / pi;
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 0.5 1 2];
-%! y = 1/pi * atan ((x-1) / 2) + 1/2;
-%!assert (cauchy_cdf (x, ones (1,5), 2*ones (1,5)), y)
-%!assert (cauchy_cdf (x, 1, 2*ones (1,5)), y)
-%!assert (cauchy_cdf (x, ones (1,5), 2), y)
-%!assert (cauchy_cdf (x, [-Inf 1 NaN 1 Inf], 2), [NaN y(2) NaN y(4) NaN])
-%!assert (cauchy_cdf (x, 1, 2*[0 1 NaN 1 Inf]), [NaN y(2) NaN y(4) NaN])
-%!assert (cauchy_cdf ([x(1:2) NaN x(4:5)], 1, 2), [y(1:2) NaN y(4:5)])
-
-## Test class of input preserved
-%!assert (cauchy_cdf ([x, NaN], 1, 2), [y, NaN])
-%!assert (cauchy_cdf (single ([x, NaN]), 1, 2), single ([y, NaN]), eps ("single"))
-%!assert (cauchy_cdf ([x, NaN], single (1), 2), single ([y, NaN]), eps ("single"))
-%!assert (cauchy_cdf ([x, NaN], 1, single (2)), single ([y, NaN]), eps ("single"))
-
-## Test input validation
-%!error cauchy_cdf ()
-%!error cauchy_cdf (1,2)
-%!error cauchy_cdf (1,2,3,4)
-%!error cauchy_cdf (ones (3), ones (2), ones (2))
-%!error cauchy_cdf (ones (2), ones (3), ones (2))
-%!error cauchy_cdf (ones (2), ones (2), ones (3))
-%!error cauchy_cdf (i, 2, 2)
-%!error cauchy_cdf (2, i, 2)
-%!error cauchy_cdf (2, 2, i)
diff --git a/scripts/statistics/distributions/cauchy_inv.m b/scripts/statistics/distributions/cauchy_inv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/cauchy_inv.m
+++ /dev/null
@@ -1,98 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} cauchy_inv (@var{x})
-## @deftypefnx {} {} cauchy_inv (@var{x}, @var{location}, @var{scale})
-## For each element of @var{x}, compute the quantile (the inverse of the CDF)
-## at @var{x} of the Cauchy distribution with location parameter
-## @var{location} and scale parameter @var{scale}.
-##
-## Default values are @var{location} = 0, @var{scale} = 1.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Quantile function of the Cauchy distribution
-
-function inv = cauchy_inv (x, location = 0, scale = 1)
-
-  if (nargin != 1 && nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (location) || ! isscalar (scale))
-    [retval, x, location, scale] = common_size (x, location, scale);
-    if (retval > 0)
-      error ("cauchy_inv: X, LOCATION, and SCALE must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (location) || iscomplex (scale))
-    error ("cauchy_inv: X, LOCATION, and SCALE must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (location, "single") || isa (scale, "single"))
-    inv = NaN (size (x), "single");
-  else
-    inv = NaN (size (x));
-  endif
-
-  ok = ! isinf (location) & (scale > 0) & (scale < Inf);
-
-  k = (x == 0) & ok;
-  inv(k) = -Inf;
-
-  k = (x == 1) & ok;
-  inv(k) = Inf;
-
-  k = (x > 0) & (x < 1) & ok;
-  if (isscalar (location) && isscalar (scale))
-    inv(k) = location - scale * cot (pi * x(k));
-  else
-    inv(k) = location(k) - scale(k) .* cot (pi * x(k));
-  endif
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 0.5 1 2];
-%!assert (cauchy_inv (x, ones (1,5), 2*ones (1,5)), [NaN -Inf 1 Inf NaN], eps)
-%!assert (cauchy_inv (x, 1, 2*ones (1,5)), [NaN -Inf 1 Inf NaN], eps)
-%!assert (cauchy_inv (x, ones (1,5), 2), [NaN -Inf 1 Inf NaN], eps)
-%!assert (cauchy_inv (x, [1 -Inf NaN Inf 1], 2), [NaN NaN NaN NaN NaN])
-%!assert (cauchy_inv (x, 1, 2*[1 0 NaN Inf 1]), [NaN NaN NaN NaN NaN])
-%!assert (cauchy_inv ([x(1:2) NaN x(4:5)], 1, 2), [NaN -Inf NaN Inf NaN])
-
-## Test class of input preserved
-%!assert (cauchy_inv ([x, NaN], 1, 2), [NaN -Inf 1 Inf NaN NaN], eps)
-%!assert (cauchy_inv (single ([x, NaN]), 1, 2), single ([NaN -Inf 1 Inf NaN NaN]), eps ("single"))
-%!assert (cauchy_inv ([x, NaN], single (1), 2), single ([NaN -Inf 1 Inf NaN NaN]), eps ("single"))
-%!assert (cauchy_inv ([x, NaN], 1, single (2)), single ([NaN -Inf 1 Inf NaN NaN]), eps ("single"))
-
-## Test input validation
-%!error cauchy_inv ()
-%!error cauchy_inv (1,2)
-%!error cauchy_inv (1,2,3,4)
-%!error cauchy_inv (ones (3), ones (2), ones (2))
-%!error cauchy_inv (ones (2), ones (3), ones (2))
-%!error cauchy_inv (ones (2), ones (2), ones (3))
-%!error cauchy_inv (i, 2, 2)
-%!error cauchy_inv (2, i, 2)
-%!error cauchy_inv (2, 2, i)
diff --git a/scripts/statistics/distributions/cauchy_pdf.m b/scripts/statistics/distributions/cauchy_pdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/cauchy_pdf.m
+++ /dev/null
@@ -1,97 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} cauchy_pdf (@var{x})
-## @deftypefnx {} {} cauchy_pdf (@var{x}, @var{location}, @var{scale})
-## For each element of @var{x}, compute the probability density function (PDF)
-## at @var{x} of the Cauchy distribution with location parameter
-## @var{location} and scale parameter @var{scale} > 0.
-##
-## Default values are @var{location} = 0, @var{scale} = 1.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: PDF of the Cauchy distribution
-
-function pdf = cauchy_pdf (x, location = 0, scale = 1)
-
-  if (nargin != 1 && nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (location) || ! isscalar (scale))
-    [retval, x, location, scale] = common_size (x, location, scale);
-    if (retval > 0)
-      error ("cauchy_pdf: X, LOCATION, and SCALE must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (location) || iscomplex (scale))
-    error ("cauchy_pdf: X, LOCATION, and SCALE must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (location, "single") || isa (scale, "single"))
-    pdf = NaN (size (x), "single");
-  else
-    pdf = NaN (size (x));
-  endif
-
-  k = ! isinf (location) & (scale > 0) & (scale < Inf);
-  if (isscalar (location) && isscalar (scale))
-    pdf = ((1 ./ (1 + ((x - location) / scale) .^ 2))
-              / pi / scale);
-  else
-    pdf(k) = ((1 ./ (1 + ((x(k) - location(k)) ./ scale(k)) .^ 2))
-              / pi ./ scale(k));
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 0.5 1 2];
-%! y = 1/pi * ( 2 ./ ((x-1).^2 + 2^2) );
-%!assert (cauchy_pdf (x, ones (1,5), 2*ones (1,5)), y)
-%!assert (cauchy_pdf (x, 1, 2*ones (1,5)), y)
-%!assert (cauchy_pdf (x, ones (1,5), 2), y)
-%!assert (cauchy_pdf (x, [-Inf 1 NaN 1 Inf], 2), [NaN y(2) NaN y(4) NaN])
-%!assert (cauchy_pdf (x, 1, 2*[0 1 NaN 1 Inf]), [NaN y(2) NaN y(4) NaN])
-%!assert (cauchy_pdf ([x, NaN], 1, 2), [y, NaN])
-
-## Test class of input preserved
-%!assert (cauchy_pdf (single ([x, NaN]), 1, 2), single ([y, NaN]), eps ("single"))
-%!assert (cauchy_pdf ([x, NaN], single (1), 2), single ([y, NaN]), eps ("single"))
-%!assert (cauchy_pdf ([x, NaN], 1, single (2)), single ([y, NaN]), eps ("single"))
-
-## Cauchy (0,1) == Student's T distribution with 1 DOF
-%!test
-%! x = rand (10, 1);
-%! assert (cauchy_pdf (x, 0, 1), tpdf (x, 1), eps);
-
-## Test input validation
-%!error cauchy_pdf ()
-%!error cauchy_pdf (1,2)
-%!error cauchy_pdf (1,2,3,4)
-%!error cauchy_pdf (ones (3), ones (2), ones (2))
-%!error cauchy_pdf (ones (2), ones (3), ones (2))
-%!error cauchy_pdf (ones (2), ones (2), ones (3))
-%!error cauchy_pdf (i, 2, 2)
-%!error cauchy_pdf (2, i, 2)
-%!error cauchy_pdf (2, 2, i)
diff --git a/scripts/statistics/distributions/cauchy_rnd.m b/scripts/statistics/distributions/cauchy_rnd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/cauchy_rnd.m
+++ /dev/null
@@ -1,132 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} cauchy_rnd (@var{location}, @var{scale})
-## @deftypefnx {} {} cauchy_rnd (@var{location}, @var{scale}, @var{r})
-## @deftypefnx {} {} cauchy_rnd (@var{location}, @var{scale}, @var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} cauchy_rnd (@var{location}, @var{scale}, [@var{sz}])
-## Return a matrix of random samples from the Cauchy distribution with
-## parameters @var{location} and @var{scale}.
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-##
-## If no size arguments are given then the result matrix is the common size of
-## @var{location} and @var{scale}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Random deviates from the Cauchy distribution
-
-function rnd = cauchy_rnd (location, scale, varargin)
-
-  if (nargin < 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (location) || ! isscalar (scale))
-    [retval, location, scale] = common_size (location, scale);
-    if (retval > 0)
-      error ("cauchy_rnd: LOCATION and SCALE must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (location) || iscomplex (scale))
-    error ("cauchy_rnd: LOCATION and SCALE must not be complex");
-  endif
-
-  if (nargin == 2)
-    sz = size (location);
-  elseif (nargin == 3)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1};
-    else
-      error ("cauchy_rnd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 3)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("cauchy_rnd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  if (! isscalar (location) && ! isequal (size (location), sz))
-    error ("cauchy_rnd: LOCATION and SCALE must be scalar or of size SZ");
-  endif
-
-  if (isa (location, "single") || isa (scale, "single"))
-    cls = "single";
-  else
-    cls = "double";
-  endif
-
-  if (isscalar (location) && isscalar (scale))
-    if (! isinf (location) && (scale > 0) && (scale < Inf))
-      rnd = location - cot (pi * rand (sz, cls)) * scale;
-    else
-      rnd = NaN (sz, cls);
-    endif
-  else
-    rnd = NaN (sz, cls);
-
-    k = ! isinf (location) & (scale > 0) & (scale < Inf);
-    rnd(k) = location(k)(:) ...
-             - cot (pi * rand (sum (k(:)), 1, cls)) .* scale(k)(:);
-  endif
-
-endfunction
-
-
-%!assert (size (cauchy_rnd (1,2)), [1, 1])
-%!assert (size (cauchy_rnd (ones (2,1), 2)), [2, 1])
-%!assert (size (cauchy_rnd (ones (2,2), 2)), [2, 2])
-%!assert (size (cauchy_rnd (1, 2*ones (2,1))), [2, 1])
-%!assert (size (cauchy_rnd (1, 2*ones (2,2))), [2, 2])
-%!assert (size (cauchy_rnd (1, 2, 3)), [3, 3])
-%!assert (size (cauchy_rnd (1, 2, [4 1])), [4, 1])
-%!assert (size (cauchy_rnd (1, 2, 4, 1)), [4, 1])
-
-## Test class of input preserved
-%!assert (class (cauchy_rnd (1, 2)), "double")
-%!assert (class (cauchy_rnd (single (1), 2)), "single")
-%!assert (class (cauchy_rnd (single ([1 1]), 2)), "single")
-%!assert (class (cauchy_rnd (1, single (2))), "single")
-%!assert (class (cauchy_rnd (1, single ([2 2]))), "single")
-
-## Test input validation
-%!error cauchy_rnd ()
-%!error cauchy_rnd (1)
-%!error cauchy_rnd (ones (3), ones (2))
-%!error cauchy_rnd (ones (2), ones (3))
-%!error cauchy_rnd (i, 2)
-%!error cauchy_rnd (2, i)
-%!error cauchy_rnd (1,2, -1)
-%!error cauchy_rnd (1,2, ones (2))
-%!error cauchy_rnd (1,2, [2 -1 2])
-%!error cauchy_rnd (1,2, 1, ones (2))
-%!error cauchy_rnd (1,2, 1, -1)
-%!error cauchy_rnd (ones (2,2), 2, 3)
-%!error cauchy_rnd (ones (2,2), 2, [3, 2])
-%!error cauchy_rnd (ones (2,2), 2, 2, 3)
diff --git a/scripts/statistics/distributions/chi2cdf.m b/scripts/statistics/distributions/chi2cdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/chi2cdf.m
+++ /dev/null
@@ -1,72 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} chi2cdf (@var{x}, @var{n})
-## For each element of @var{x}, compute the cumulative distribution function
-## (CDF) at @var{x} of the chi-square distribution with @var{n} degrees of
-## freedom.
-## @end deftypefn
-
-## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
-## Description: CDF of the chi-square distribution
-
-function cdf = chi2cdf (x, n)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (n))
-    [retval, x, n] = common_size (x, n);
-    if (retval > 0)
-      error ("chi2cdf: X and N must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (n))
-    error ("chi2cdf: X and N must not be complex");
-  endif
-
-  cdf = gamcdf (x, n/2, 2);
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 0.5 1 2];
-%! y = [0, 1 - exp(-x(2:end)/2)];
-%!assert (chi2cdf (x, 2*ones (1,5)), y, eps)
-%!assert (chi2cdf (x, 2), y, eps)
-%!assert (chi2cdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)], eps)
-%!assert (chi2cdf ([x(1:2) NaN x(4:5)], 2), [y(1:2) NaN y(4:5)], eps)
-
-## Test class of input preserved
-%!assert (chi2cdf ([x, NaN], 2), [y, NaN], eps)
-%!assert (chi2cdf (single ([x, NaN]), 2), single ([y, NaN]), eps ("single"))
-%!assert (chi2cdf ([x, NaN], single (2)), single ([y, NaN]), eps ("single"))
-
-## Test input validation
-%!error chi2cdf ()
-%!error chi2cdf (1)
-%!error chi2cdf (1,2,3)
-%!error chi2cdf (ones (3), ones (2))
-%!error chi2cdf (ones (2), ones (3))
-%!error chi2cdf (i, 2)
-%!error chi2cdf (2, i)
diff --git a/scripts/statistics/distributions/chi2inv.m b/scripts/statistics/distributions/chi2inv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/chi2inv.m
+++ /dev/null
@@ -1,70 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} chi2inv (@var{x}, @var{n})
-## For each element of @var{x}, compute the quantile (the inverse of the CDF)
-## at @var{x} of the chi-square distribution with @var{n} degrees of freedom.
-## @end deftypefn
-
-## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
-## Description: Quantile function of the chi-square distribution
-
-function inv = chi2inv (x, n)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (n))
-    [retval, x, n] = common_size (x, n);
-    if (retval > 0)
-      error ("chi2inv: X and N must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (n))
-    error ("chi2inv: X and N must not be complex");
-  endif
-
-  inv = gaminv (x, n/2, 2);
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 0.3934693402873666 1 2];
-%!assert (chi2inv (x, 2*ones (1,5)), [NaN 0 1 Inf NaN], 5*eps)
-%!assert (chi2inv (x, 2), [NaN 0 1 Inf NaN], 5*eps)
-%!assert (chi2inv (x, 2*[0 1 NaN 1 1]), [NaN 0 NaN Inf NaN], 5*eps)
-%!assert (chi2inv ([x(1:2) NaN x(4:5)], 2), [NaN 0 NaN Inf NaN], 5*eps)
-
-## Test class of input preserved
-%!assert (chi2inv ([x, NaN], 2), [NaN 0 1 Inf NaN NaN], 5*eps)
-%!assert (chi2inv (single ([x, NaN]), 2), single ([NaN 0 1 Inf NaN NaN]), 5*eps ("single"))
-%!assert (chi2inv ([x, NaN], single (2)), single ([NaN 0 1 Inf NaN NaN]), 5*eps ("single"))
-
-## Test input validation
-%!error chi2inv ()
-%!error chi2inv (1)
-%!error chi2inv (1,2,3)
-%!error chi2inv (ones (3), ones (2))
-%!error chi2inv (ones (2), ones (3))
-%!error chi2inv (i, 2)
-%!error chi2inv (2, i)
diff --git a/scripts/statistics/distributions/chi2pdf.m b/scripts/statistics/distributions/chi2pdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/chi2pdf.m
+++ /dev/null
@@ -1,70 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} chi2pdf (@var{x}, @var{n})
-## For each element of @var{x}, compute the probability density function (PDF)
-## at @var{x} of the chi-square distribution with @var{n} degrees of freedom.
-## @end deftypefn
-
-## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
-## Description: PDF of the chi-square distribution
-
-function pdf = chi2pdf (x, n)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (n))
-    [retval, x, n] = common_size (x, n);
-    if (retval > 0)
-      error ("chi2pdf: X and N must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (n))
-    error ("chi2pdf: X and N must not be complex");
-  endif
-
-  pdf = gampdf (x, n/2, 2);
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 0.5 1 Inf];
-%! y = [0, 1/2 * exp(-x(2:5)/2)];
-%!assert (chi2pdf (x, 2*ones (1,5)), y)
-%!assert (chi2pdf (x, 2), y)
-%!assert (chi2pdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)])
-%!assert (chi2pdf ([x, NaN], 2), [y, NaN])
-
-## Test class of input preserved
-%!assert (chi2pdf (single ([x, NaN]), 2), single ([y, NaN]))
-%!assert (chi2pdf ([x, NaN], single (2)), single ([y, NaN]))
-
-## Test input validation
-%!error chi2pdf ()
-%!error chi2pdf (1)
-%!error chi2pdf (1,2,3)
-%!error chi2pdf (ones (3), ones (2))
-%!error chi2pdf (ones (2), ones (3))
-%!error chi2pdf (i, 2)
-%!error chi2pdf (2, i)
diff --git a/scripts/statistics/distributions/chi2rnd.m b/scripts/statistics/distributions/chi2rnd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/chi2rnd.m
+++ /dev/null
@@ -1,116 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} chi2rnd (@var{n})
-## @deftypefnx {} {} chi2rnd (@var{n}, @var{r})
-## @deftypefnx {} {} chi2rnd (@var{n}, @var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} chi2rnd (@var{n}, [@var{sz}])
-## Return a matrix of random samples from the chi-square distribution with
-## @var{n} degrees of freedom.
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-##
-## If no size arguments are given then the result matrix is the size of
-## @var{n}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Random deviates from the chi-square distribution
-
-function rnd = chi2rnd (n, varargin)
-
-  if (nargin < 1)
-    print_usage ();
-  endif
-
-  if (nargin == 1)
-    sz = size (n);
-  elseif (nargin == 2)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1};
-    else
-      error ("chi2rnd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 2)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("chi2rnd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  if (! isscalar (n) && ! isequal (size (n), sz))
-    error ("chi2rnd: N must be scalar or of size SZ");
-  endif
-
-  if (iscomplex (n))
-    error ("chi2rnd: N must not be complex");
-  endif
-
-  if (isa (n, "single"))
-    cls = "single";
-  else
-    cls = "double";
-  endif
-
-  if (isscalar (n))
-    if ((n > 0) && (n < Inf))
-      rnd = 2 * randg (n/2, sz, cls);
-    else
-      rnd = NaN (sz, cls);
-    endif
-  else
-    rnd = NaN (sz, cls);
-
-    k = (n > 0) | (n < Inf);
-    rnd(k) = 2 * randg (n(k)/2, cls);
-  endif
-
-endfunction
-
-
-%!assert (size (chi2rnd (2)), [1, 1])
-%!assert (size (chi2rnd (ones (2,1))), [2, 1])
-%!assert (size (chi2rnd (ones (2,2))), [2, 2])
-%!assert (size (chi2rnd (1, 3)), [3, 3])
-%!assert (size (chi2rnd (1, [4 1])), [4, 1])
-%!assert (size (chi2rnd (1, 4, 1)), [4, 1])
-
-## Test class of input preserved
-%!assert (class (chi2rnd (2)), "double")
-%!assert (class (chi2rnd (single (2))), "single")
-%!assert (class (chi2rnd (single ([2 2]))), "single")
-
-## Test input validation
-%!error chi2rnd ()
-%!error chi2rnd (ones (3), ones (2))
-%!error chi2rnd (ones (2), ones (3))
-%!error chi2rnd (i)
-%!error chi2rnd (1, -1)
-%!error chi2rnd (1, ones (2))
-%!error chi2rnd (1, [2 -1 2])
-%!error chi2rnd (ones (2,2), 3)
-%!error chi2rnd (ones (2,2), [3, 2])
-%!error chi2rnd (ones (2,2), 2, 3)
diff --git a/scripts/statistics/distributions/expcdf.m b/scripts/statistics/distributions/expcdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/expcdf.m
+++ /dev/null
@@ -1,89 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} expcdf (@var{x}, @var{lambda})
-## For each element of @var{x}, compute the cumulative distribution function
-## (CDF) at @var{x} of the exponential distribution with mean @var{lambda}.
-##
-## The arguments can be of common size or scalars.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: CDF of the exponential distribution
-
-function cdf = expcdf (x, lambda)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (lambda))
-    [retval, x, lambda] = common_size (x, lambda);
-    if (retval > 0)
-      error ("expcdf: X and LAMBDA must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (lambda))
-    error ("expcdf: X and LAMBDA must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (lambda, "single"))
-    cdf = zeros (size (x), "single");
-  else
-    cdf = zeros (size (x));
-  endif
-
-  k = isnan (x) | !(lambda > 0);
-  cdf(k) = NaN;
-
-  k = (x == Inf) & (lambda > 0);
-  cdf(k) = 1;
-
-  k = (x > 0) & (x < Inf) & (lambda > 0);
-  if (isscalar (lambda))
-    cdf(k) = 1 - exp (-x(k) / lambda);
-  else
-    cdf(k) = 1 - exp (-x(k) ./ lambda(k));
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 0.5 1 Inf];
-%! y = [0, 1 - exp(-x(2:end)/2)];
-%!assert (expcdf (x, 2*ones (1,5)), y)
-%!assert (expcdf (x, 2), y)
-%!assert (expcdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)])
-
-## Test class of input preserved
-%!assert (expcdf ([x, NaN], 2), [y, NaN])
-%!assert (expcdf (single ([x, NaN]), 2), single ([y, NaN]))
-%!assert (expcdf ([x, NaN], single (2)), single ([y, NaN]))
-
-## Test input validation
-%!error expcdf ()
-%!error expcdf (1)
-%!error expcdf (1,2,3)
-%!error expcdf (ones (3), ones (2))
-%!error expcdf (ones (2), ones (3))
-%!error expcdf (i, 2)
-%!error expcdf (2, i)
diff --git a/scripts/statistics/distributions/expinv.m b/scripts/statistics/distributions/expinv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/expinv.m
+++ /dev/null
@@ -1,94 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} expinv (@var{x}, @var{lambda})
-## For each element of @var{x}, compute the quantile (the inverse of the CDF)
-## at @var{x} of the exponential distribution with mean @var{lambda}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Quantile function of the exponential distribution
-
-function inv = expinv (x, lambda)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (lambda))
-    [retval, x, lambda] = common_size (x, lambda);
-    if (retval > 0)
-      error ("expinv: X and LAMBDA must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (lambda))
-    error ("expinv: X and LAMBDA must not be complex");
-  endif
-
-  if (! isscalar (x))
-    sz = size (x);
-  else
-    sz = size (lambda);
-  endif
-
-  if (iscomplex (x) || iscomplex (lambda))
-    error ("expinv: X and LAMBDA must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (lambda, "single"))
-    inv = NaN (size (x), "single");
-  else
-    inv = NaN (size (x));
-  endif
-
-  k = (x == 1) & (lambda > 0);
-  inv(k) = Inf;
-
-  k = (x >= 0) & (x < 1) & (lambda > 0);
-  if (isscalar (lambda))
-    inv(k) = - lambda * log (1 - x(k));
-  else
-    inv(k) = - lambda(k) .* log (1 - x(k));
-  endif
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 0.3934693402873666 1 2];
-%!assert (expinv (x, 2*ones (1,5)), [NaN 0 1 Inf NaN], eps)
-%!assert (expinv (x, 2), [NaN 0 1 Inf NaN], eps)
-%!assert (expinv (x, 2*[1 0 NaN 1 1]), [NaN NaN NaN Inf NaN], eps)
-%!assert (expinv ([x(1:2) NaN x(4:5)], 2), [NaN 0 NaN Inf NaN], eps)
-
-## Test class of input preserved
-%!assert (expinv ([x, NaN], 2), [NaN 0 1 Inf NaN NaN], eps)
-%!assert (expinv (single ([x, NaN]), 2), single ([NaN 0 1 Inf NaN NaN]), eps)
-%!assert (expinv ([x, NaN], single (2)), single ([NaN 0 1 Inf NaN NaN]), eps)
-
-## Test input validation
-%!error expinv ()
-%!error expinv (1)
-%!error expinv (1,2,3)
-%!error expinv (ones (3), ones (2))
-%!error expinv (ones (2), ones (3))
-%!error expinv (i, 2)
-%!error expinv (2, i)
diff --git a/scripts/statistics/distributions/exppdf.m b/scripts/statistics/distributions/exppdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/exppdf.m
+++ /dev/null
@@ -1,83 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} exppdf (@var{x}, @var{lambda})
-## For each element of @var{x}, compute the probability density function (PDF)
-## at @var{x} of the exponential distribution with mean @var{lambda}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: PDF of the exponential distribution
-
-function pdf = exppdf (x, lambda)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (lambda))
-    [retval, x, lambda] = common_size (x, lambda);
-    if (retval > 0)
-      error ("exppdf: X and LAMBDA must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (lambda))
-    error ("exppdf: X and LAMBDA must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (lambda, "single"))
-    pdf = zeros (size (x), "single");
-  else
-    pdf = zeros (size (x));
-  endif
-
-  k = isnan (x) | !(lambda > 0);
-  pdf(k) = NaN;
-
-  k = (x >= 0) & (x < Inf) & (lambda > 0);
-  if (isscalar (lambda))
-    pdf(k) = exp (-x(k) / lambda) / lambda;
-  else
-    pdf(k) = exp (-x(k) ./ lambda(k)) ./ lambda(k);
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 0.5 1 Inf];
-%! y = gampdf (x, 1, 2);
-%!assert (exppdf (x, 2*ones (1,5)), y)
-%!assert (exppdf (x, 2*[1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)])
-%!assert (exppdf ([x, NaN], 2), [y, NaN])
-
-## Test class of input preserved
-%!assert (exppdf (single ([x, NaN]), 2), single ([y, NaN]))
-%!assert (exppdf ([x, NaN], single (2)), single ([y, NaN]))
-
-## Test input validation
-%!error exppdf ()
-%!error exppdf (1)
-%!error exppdf (1,2,3)
-%!error exppdf (ones (3), ones (2))
-%!error exppdf (ones (2), ones (3))
-%!error exppdf (i, 2)
-%!error exppdf (2, i)
diff --git a/scripts/statistics/distributions/exprnd.m b/scripts/statistics/distributions/exprnd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/exprnd.m
+++ /dev/null
@@ -1,116 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} exprnd (@var{lambda})
-## @deftypefnx {} {} exprnd (@var{lambda}, @var{r})
-## @deftypefnx {} {} exprnd (@var{lambda}, @var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} exprnd (@var{lambda}, [@var{sz}])
-## Return a matrix of random samples from the exponential distribution with
-## mean @var{lambda}.
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-##
-## If no size arguments are given then the result matrix is the size of
-## @var{lambda}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Random deviates from the exponential distribution
-
-function rnd = exprnd (lambda, varargin)
-
-  if (nargin < 1)
-    print_usage ();
-  endif
-
-  if (nargin == 1)
-    sz = size (lambda);
-  elseif (nargin == 2)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1};
-    else
-      error ("exprnd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 2)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("exprnd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  if (! isscalar (lambda) && ! isequal (size (lambda), sz))
-    error ("exprnd: LAMBDA must be scalar or of size SZ");
-  endif
-
-  if (iscomplex (lambda))
-    error ("exprnd: LAMBDA must not be complex");
-  endif
-
-  if (isa (lambda, "single"))
-    cls = "single";
-  else
-    cls = "double";
-  endif
-
-  if (isscalar (lambda))
-    if ((lambda > 0) && (lambda < Inf))
-      rnd = rande (sz, cls) * lambda;
-    else
-      rnd = NaN (sz, cls);
-    endif
-  else
-    rnd = NaN (sz, cls);
-
-    k = (lambda > 0) & (lambda < Inf);
-    rnd(k) = rande (sum (k(:)), 1, cls) .* lambda(k)(:);
-  endif
-
-endfunction
-
-
-%!assert (size (exprnd (2)), [1, 1])
-%!assert (size (exprnd (ones (2,1))), [2, 1])
-%!assert (size (exprnd (ones (2,2))), [2, 2])
-%!assert (size (exprnd (1, 3)), [3, 3])
-%!assert (size (exprnd (1, [4 1])), [4, 1])
-%!assert (size (exprnd (1, 4, 1)), [4, 1])
-
-## Test class of input preserved
-%!assert (class (exprnd (1)), "double")
-%!assert (class (exprnd (single (1))), "single")
-%!assert (class (exprnd (single ([1 1]))), "single")
-
-## Test input validation
-%!error exprnd ()
-%!error exprnd (1, -1)
-%!error exprnd (1, ones (2))
-%!error exprnd (i)
-%!error exprnd (1, [2 -1 2])
-%!error exprnd (1, 2, -1)
-%!error exprnd (1, 2, ones (2))
-%!error exprnd (ones (2,2), 3)
-%!error exprnd (ones (2,2), [3, 2])
-%!error exprnd (ones (2,2), 2, 3)
diff --git a/scripts/statistics/distributions/fcdf.m b/scripts/statistics/distributions/fcdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/fcdf.m
+++ /dev/null
@@ -1,95 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} fcdf (@var{x}, @var{m}, @var{n})
-## For each element of @var{x}, compute the cumulative distribution function
-## (CDF) at @var{x} of the F distribution with @var{m} and @var{n} degrees of
-## freedom.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: CDF of the F distribution
-
-function cdf = fcdf (x, m, n)
-
-  if (nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (m) || ! isscalar (n))
-    [retval, x, m, n] = common_size (x, m, n);
-    if (retval > 0)
-      error ("fcdf: X, M, and N must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (m) || iscomplex (n))
-    error ("fcdf: X, M, and N must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (m, "single") || isa (n, "single"))
-    cdf = zeros (size (x), "single");
-  else
-    cdf = zeros (size (x));
-  endif
-
-  k = isnan (x) | !(m > 0) | !(m < Inf) | !(n > 0) | !(n < Inf);
-  cdf(k) = NaN;
-
-  k = (x == Inf) & (m > 0) & (m < Inf) & (n > 0) & (n < Inf);
-  cdf(k) = 1;
-
-  k = (x > 0) & (x < Inf) & (m > 0) & (m < Inf) & (n > 0) & (n < Inf);
-  if (isscalar (m) && isscalar (n))
-    cdf(k) = 1 - betainc (1 ./ (1 + m * x(k) / n), n/2, m/2);
-  else
-    cdf(k) = 1 - betainc (1 ./ (1 + m(k) .* x(k) ./ n(k)), n(k)/2, m(k)/2);
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 0.5 1 2 Inf];
-%! y = [0 0 1/3 1/2 2/3 1];
-%!assert (fcdf (x, 2*ones (1,6), 2*ones (1,6)), y, eps)
-%!assert (fcdf (x, 2, 2*ones (1,6)), y, eps)
-%!assert (fcdf (x, 2*ones (1,6), 2), y, eps)
-%!assert (fcdf (x, [0 NaN Inf 2 2 2], 2), [NaN NaN NaN y(4:6)], eps)
-%!assert (fcdf (x, 2, [0 NaN Inf 2 2 2]), [NaN NaN NaN y(4:6)], eps)
-%!assert (fcdf ([x(1:2) NaN x(4:6)], 2, 2), [y(1:2) NaN y(4:6)], eps)
-
-## Test class of input preserved
-%!assert (fcdf ([x, NaN], 2, 2), [y, NaN], eps)
-%!assert (fcdf (single ([x, NaN]), 2, 2), single ([y, NaN]), eps ("single"))
-%!assert (fcdf ([x, NaN], single (2), 2), single ([y, NaN]), eps ("single"))
-%!assert (fcdf ([x, NaN], 2, single (2)), single ([y, NaN]), eps ("single"))
-
-## Test input validation
-%!error fcdf ()
-%!error fcdf (1)
-%!error fcdf (1,2)
-%!error fcdf (1,2,3,4)
-%!error fcdf (ones (3), ones (2), ones (2))
-%!error fcdf (ones (2), ones (3), ones (2))
-%!error fcdf (ones (2), ones (2), ones (3))
-%!error fcdf (i, 2, 2)
-%!error fcdf (2, i, 2)
-%!error fcdf (2, 2, i)
diff --git a/scripts/statistics/distributions/finv.m b/scripts/statistics/distributions/finv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/finv.m
+++ /dev/null
@@ -1,92 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} finv (@var{x}, @var{m}, @var{n})
-## For each element of @var{x}, compute the quantile (the inverse of the CDF)
-## at @var{x} of the F distribution with @var{m} and @var{n} degrees of
-## freedom.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Quantile function of the F distribution
-
-function inv = finv (x, m, n)
-
-  if (nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (m) || ! isscalar (n))
-    [retval, x, m, n] = common_size (x, m, n);
-    if (retval > 0)
-      error ("finv: X, M, and N must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (m) || iscomplex (n))
-    error ("finv: X, M, and N must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (m, "single") || isa (n, "single"))
-    inv = NaN (size (x), "single");
-  else
-    inv = NaN (size (x));
-  endif
-
-  k = (x == 1) & (m > 0) & (m < Inf) & (n > 0) & (n < Inf);
-  inv(k) = Inf;
-
-  k = (x >= 0) & (x < 1) & (m > 0) & (m < Inf) & (n > 0) & (n < Inf);
-  if (isscalar (m) && isscalar (n))
-    inv(k) = ((1 ./ betainv (1 - x(k), n/2, m/2) - 1) * n / m);
-  else
-    inv(k) = ((1 ./ betainv (1 - x(k), n(k)/2, m(k)/2) - 1)
-              .* n(k) ./ m(k));
-  endif
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 0.5 1 2];
-%!assert (finv (x, 2*ones (1,5), 2*ones (1,5)), [NaN 0 1 Inf NaN])
-%!assert (finv (x, 2, 2*ones (1,5)), [NaN 0 1 Inf NaN])
-%!assert (finv (x, 2*ones (1,5), 2), [NaN 0 1 Inf NaN])
-%!assert (finv (x, [2 -Inf NaN Inf 2], 2), [NaN NaN NaN NaN NaN])
-%!assert (finv (x, 2, [2 -Inf NaN Inf 2]), [NaN NaN NaN NaN NaN])
-%!assert (finv ([x(1:2) NaN x(4:5)], 2, 2), [NaN 0 NaN Inf NaN])
-
-## Test class of input preserved
-%!assert (finv ([x, NaN], 2, 2), [NaN 0 1 Inf NaN NaN])
-%!assert (finv (single ([x, NaN]), 2, 2), single ([NaN 0 1 Inf NaN NaN]))
-%!assert (finv ([x, NaN], single (2), 2), single ([NaN 0 1 Inf NaN NaN]))
-%!assert (finv ([x, NaN], 2, single (2)), single ([NaN 0 1 Inf NaN NaN]))
-
-## Test input validation
-%!error finv ()
-%!error finv (1)
-%!error finv (1,2)
-%!error finv (1,2,3,4)
-%!error finv (ones (3), ones (2), ones (2))
-%!error finv (ones (2), ones (3), ones (2))
-%!error finv (ones (2), ones (2), ones (3))
-%!error finv (i, 2, 2)
-%!error finv (2, i, 2)
-%!error finv (2, 2, i)
diff --git a/scripts/statistics/distributions/fpdf.m b/scripts/statistics/distributions/fpdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/fpdf.m
+++ /dev/null
@@ -1,104 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} fpdf (@var{x}, @var{m}, @var{n})
-## For each element of @var{x}, compute the probability density function (PDF)
-## at @var{x} of the F distribution with @var{m} and @var{n} degrees of
-## freedom.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: PDF of the F distribution
-
-function pdf = fpdf (x, m, n)
-
-  if (nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (m) || ! isscalar (n))
-    [retval, x, m, n] = common_size (x, m, n);
-    if (retval > 0)
-      error ("fpdf: X, M, and N must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (m) || iscomplex (n))
-    error ("fpdf: X, M, and N must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (m, "single") || isa (n, "single"))
-    pdf = zeros (size (x), "single");
-  else
-    pdf = zeros (size (x));
-  endif
-
-  k = isnan (x) | !(m > 0) | !(m < Inf) | !(n > 0) | !(n < Inf);
-  pdf(k) = NaN;
-
-  k = (x > 0) & (x < Inf) & (m > 0) & (m < Inf) & (n > 0) & (n < Inf);
-  if (isscalar (m) && isscalar (n))
-    tmp = m / n * x(k);
-    pdf(k) = (exp ((m/2 - 1) * log (tmp)
-                   - ((m + n) / 2) * log (1 + tmp))
-              * (m / n) ./ beta (m/2, n/2));
-  else
-    tmp = m(k) .* x(k) ./ n(k);
-    pdf(k) = (exp ((m(k)/2 - 1) .* log (tmp)
-                   - ((m(k) + n(k)) / 2) .* log (1 + tmp))
-              .* (m(k) ./ n(k)) ./ beta (m(k)/2, n(k)/2));
-  endif
-
-endfunction
-
-
-## F (x, 1, m) == T distribution (sqrt (x), m) / sqrt (x)
-%!test
-%! x = rand (10,1);
-%! x = x(x > 0.1 & x < 0.9);
-%! y = tpdf (sqrt (x), 2) ./ sqrt (x);
-%! assert (fpdf (x, 1, 2), y, 5*eps);
-
-%!shared x,y
-%! x = [-1 0 0.5 1 2];
-%! y = [0 0 4/9 1/4 1/9];
-%!assert (fpdf (x, 2*ones (1,5), 2*ones (1,5)), y, eps)
-%!assert (fpdf (x, 2, 2*ones (1,5)), y, eps)
-%!assert (fpdf (x, 2*ones (1,5), 2), y, eps)
-%!assert (fpdf (x, [0 NaN Inf 2 2], 2), [NaN NaN NaN y(4:5)], eps)
-%!assert (fpdf (x, 2, [0 NaN Inf 2 2]), [NaN NaN NaN y(4:5)], eps)
-%!assert (fpdf ([x, NaN], 2, 2), [y, NaN], eps)
-
-## Test class of input preserved
-%!assert (fpdf (single ([x, NaN]), 2, 2), single ([y, NaN]), eps ("single"))
-%!assert (fpdf ([x, NaN], single (2), 2), single ([y, NaN]), eps ("single"))
-%!assert (fpdf ([x, NaN], 2, single (2)), single ([y, NaN]), eps ("single"))
-
-## Test input validation
-%!error fpdf ()
-%!error fpdf (1)
-%!error fpdf (1,2)
-%!error fpdf (1,2,3,4)
-%!error fpdf (ones (3), ones (2), ones (2))
-%!error fpdf (ones (2), ones (3), ones (2))
-%!error fpdf (ones (2), ones (2), ones (3))
-%!error fpdf (i, 2, 2)
-%!error fpdf (2, i, 2)
-%!error fpdf (2, 2, i)
diff --git a/scripts/statistics/distributions/frnd.m b/scripts/statistics/distributions/frnd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/frnd.m
+++ /dev/null
@@ -1,131 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} frnd (@var{m}, @var{n})
-## @deftypefnx {} {} frnd (@var{m}, @var{n}, @var{r})
-## @deftypefnx {} {} frnd (@var{m}, @var{n}, @var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} frnd (@var{m}, @var{n}, [@var{sz}])
-## Return a matrix of random samples from the F distribution with
-## @var{m} and @var{n} degrees of freedom.
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-##
-## If no size arguments are given then the result matrix is the common size of
-## @var{m} and @var{n}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Random deviates from the F distribution
-
-function rnd = frnd (m, n, varargin)
-
-  if (nargin < 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (m) || ! isscalar (n))
-    [retval, m, n] = common_size (m, n);
-    if (retval > 0)
-      error ("frnd: M and N must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (m) || iscomplex (n))
-    error ("frnd: M and N must not be complex");
-  endif
-
-  if (nargin == 2)
-    sz = size (m);
-  elseif (nargin == 3)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1};
-    else
-      error ("frnd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 3)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("frnd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  if (! isscalar (m) && ! isequal (size (m), sz))
-    error ("frnd: M and N must be scalar or of size SZ");
-  endif
-
-  if (isa (m, "single") || isa (n, "single"))
-    cls = "single";
-  else
-    cls = "double";
-  endif
-
-  if (isscalar (m) && isscalar (n))
-    if ((m > 0) && (m < Inf) && (n > 0) && (n < Inf))
-      rnd = n/m * randg (m/2, sz, cls) ./ randg (n/2, sz, cls);
-    else
-      rnd = NaN (sz, cls);
-    endif
-  else
-    rnd = NaN (sz, cls);
-
-    k = (m > 0) & (m < Inf) & (n > 0) & (n < Inf);
-    rnd(k) = n(k) ./ m(k) .* randg (m(k)/2, cls) ./ randg (n(k)/2, cls);
-  endif
-
-endfunction
-
-
-%!assert (size (frnd (1,2)), [1, 1])
-%!assert (size (frnd (ones (2,1), 2)), [2, 1])
-%!assert (size (frnd (ones (2,2), 2)), [2, 2])
-%!assert (size (frnd (1, 2*ones (2,1))), [2, 1])
-%!assert (size (frnd (1, 2*ones (2,2))), [2, 2])
-%!assert (size (frnd (1, 2, 3)), [3, 3])
-%!assert (size (frnd (1, 2, [4 1])), [4, 1])
-%!assert (size (frnd (1, 2, 4, 1)), [4, 1])
-
-## Test class of input preserved
-%!assert (class (frnd (1, 2)), "double")
-%!assert (class (frnd (single (1), 2)), "single")
-%!assert (class (frnd (single ([1 1]), 2)), "single")
-%!assert (class (frnd (1, single (2))), "single")
-%!assert (class (frnd (1, single ([2 2]))), "single")
-
-## Test input validation
-%!error frnd ()
-%!error frnd (1)
-%!error frnd (ones (3), ones (2))
-%!error frnd (ones (2), ones (3))
-%!error frnd (i, 2)
-%!error frnd (2, i)
-%!error frnd (1,2, -1)
-%!error frnd (1,2, ones (2))
-%!error frnd (1, 2, [2 -1 2])
-%!error frnd (1,2, 1, ones (2))
-%!error frnd (1,2, 1, -1)
-%!error frnd (ones (2,2), 2, 3)
-%!error frnd (ones (2,2), 2, [3, 2])
-%!error frnd (ones (2,2), 2, 2, 3)
diff --git a/scripts/statistics/distributions/gamcdf.m b/scripts/statistics/distributions/gamcdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/gamcdf.m
+++ /dev/null
@@ -1,90 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} gamcdf (@var{x}, @var{a}, @var{b})
-## For each element of @var{x}, compute the cumulative distribution function
-## (CDF) at @var{x} of the Gamma distribution with shape parameter @var{a} and
-## scale @var{b}.
-## @end deftypefn
-
-## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
-## Description: CDF of the Gamma distribution
-
-function cdf = gamcdf (x, a, b)
-
-  if (nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (a) || ! isscalar (b))
-    [retval, x, a, b] = common_size (x, a, b);
-    if (retval > 0)
-      error ("gamcdf: X, A, and B must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (a) || iscomplex (b))
-    error ("gamcdf: X, A, and B must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (a, "single") || isa (b, "single"))
-    cdf = zeros (size (x), "single");
-  else
-    cdf = zeros (size (x));
-  endif
-
-  k = isnan (x) | !(a > 0) | !(a < Inf) | !(b > 0) | !(b < Inf);
-  cdf(k) = NaN;
-
-  k = (x > 0) & (a > 0) & (a < Inf) & (b > 0) & (b < Inf);
-  if (isscalar (a) && isscalar (b))
-    cdf(k) = gammainc (x(k) / b, a);
-  else
-    cdf(k) = gammainc (x(k) ./ b(k), a(k));
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 0.5 1 2 Inf];
-%! y = [0, gammainc(x(2:end), 1)];
-%!assert (gamcdf (x, ones (1,6), ones (1,6)), y)
-%!assert (gamcdf (x, 1, ones (1,6)), y)
-%!assert (gamcdf (x, ones (1,6), 1), y)
-%!assert (gamcdf (x, [0 -Inf NaN Inf 1 1], 1), [NaN NaN NaN NaN y(5:6)])
-%!assert (gamcdf (x, 1, [0 -Inf NaN Inf 1 1]), [NaN NaN NaN NaN y(5:6)])
-%!assert (gamcdf ([x(1:2) NaN x(4:6)], 1, 1), [y(1:2) NaN y(4:6)])
-
-## Test class of input preserved
-%!assert (gamcdf ([x, NaN], 1, 1), [y, NaN])
-%!assert (gamcdf (single ([x, NaN]), 1, 1), single ([y, NaN]), eps ("single"))
-
-## Test input validation
-%!error gamcdf ()
-%!error gamcdf (1)
-%!error gamcdf (1,2)
-%!error gamcdf (1,2,3,4)
-%!error gamcdf (ones (3), ones (2), ones (2))
-%!error gamcdf (ones (2), ones (3), ones (2))
-%!error gamcdf (ones (2), ones (2), ones (3))
-%!error gamcdf (i, 2, 2)
-%!error gamcdf (2, i, 2)
-%!error gamcdf (2, 2, i)
diff --git a/scripts/statistics/distributions/gaminv.m b/scripts/statistics/distributions/gaminv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/gaminv.m
+++ /dev/null
@@ -1,131 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} gaminv (@var{x}, @var{a}, @var{b})
-## For each element of @var{x}, compute the quantile (the inverse of the CDF)
-## at @var{x} of the Gamma distribution with shape parameter @var{a} and
-## scale @var{b}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Quantile function of the Gamma distribution
-
-function inv = gaminv (x, a, b)
-
-  if (nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (a) || ! isscalar (b))
-    [retval, x, a, b] = common_size (x, a, b);
-    if (retval > 0)
-      error ("gaminv: X, A, and B must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (a) || iscomplex (b))
-    error ("gaminv: X, A, and B must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (a, "single") || isa (b, "single"))
-    inv = zeros (size (x), "single");
-  else
-    inv = zeros (size (x));
-  endif
-
-  k = ((x < 0) | (x > 1) | isnan (x)
-       | !(a > 0) | !(a < Inf) | !(b > 0) | !(b < Inf));
-  inv(k) = NaN;
-
-  k = (x == 1) & (a > 0) & (a < Inf) & (b > 0) & (b < Inf);
-  inv(k) = Inf;
-
-  k = find ((x > 0) & (x < 1) & (a > 0) & (a < Inf) & (b > 0) & (b < Inf));
-  if (! isempty (k))
-    if (! isscalar (a) || ! isscalar (b))
-      a = a(k);
-      b = b(k);
-      y = a .* b;
-    else
-      y = a * b * ones (size (k));
-    endif
-    x = x(k);
-
-    if (isa (x, "single"))
-      myeps = eps ("single");
-    else
-      myeps = eps;
-    endif
-
-    l = find (x < myeps);
-    if (any (l))
-      y(l) = sqrt (myeps) * ones (length (l), 1);
-    endif
-
-    y_new = y;
-    loopcnt = 0;
-    do
-      y_old = y_new;
-      h     = (gamcdf (y_old, a, b) - x) ./ gampdf (y_old, a, b);
-      y_new = y_old - h;
-      ind   = find (y_new <= myeps);
-      if (any (ind))
-        y_new(ind) = y_old(ind) / 10;
-        h = y_old - y_new;
-      endif
-    until (max (abs (h)) < sqrt (myeps) || ++loopcnt == 40)
-
-    if (loopcnt == 40)
-      warning ("gaminv: calculation failed to converge for some values");
-    endif
-
-    inv(k) = y_new;
-
-  endif
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 0.63212055882855778 1 2];
-%!assert (gaminv (x, ones (1,5), ones (1,5)), [NaN 0 1 Inf NaN], eps)
-%!assert (gaminv (x, 1, ones (1,5)), [NaN 0 1 Inf NaN], eps)
-%!assert (gaminv (x, ones (1,5), 1), [NaN 0 1 Inf NaN], eps)
-%!assert (gaminv (x, [1 -Inf NaN Inf 1], 1), [NaN NaN NaN NaN NaN])
-%!assert (gaminv (x, 1, [1 -Inf NaN Inf 1]), [NaN NaN NaN NaN NaN])
-%!assert (gaminv ([x(1:2) NaN x(4:5)], 1, 1), [NaN 0 NaN Inf NaN])
-
-## Test class of input preserved
-%!assert (gaminv ([x, NaN], 1, 1), [NaN 0 1 Inf NaN NaN], eps)
-%!assert (gaminv (single ([x, NaN]), 1, 1), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
-%!assert (gaminv ([x, NaN], single (1), 1), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
-%!assert (gaminv ([x, NaN], 1, single (1)), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
-
-## Test input validation
-%!error gaminv ()
-%!error gaminv (1)
-%!error gaminv (1,2)
-%!error gaminv (1,2,3,4)
-%!error gaminv (ones (3), ones (2), ones (2))
-%!error gaminv (ones (2), ones (3), ones (2))
-%!error gaminv (ones (2), ones (2), ones (3))
-%!error gaminv (i, 2, 2)
-%!error gaminv (2, i, 2)
-%!error gaminv (2, 2, i)
diff --git a/scripts/statistics/distributions/gampdf.m b/scripts/statistics/distributions/gampdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/gampdf.m
+++ /dev/null
@@ -1,102 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} gampdf (@var{x}, @var{a}, @var{b})
-## For each element of @var{x}, return the probability density function
-## (PDF) at @var{x} of the Gamma distribution with shape parameter @var{a} and
-## scale @var{b}.
-## @end deftypefn
-
-## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
-## Description: PDF of the Gamma distribution
-
-function pdf = gampdf (x, a, b)
-
-  if (nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (a) || ! isscalar (b))
-    [retval, x, a, b] = common_size (x, a, b);
-    if (retval > 0)
-      error ("gampdf: X, A, and B must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (a) || iscomplex (b))
-    error ("gampdf: X, A, and B must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (a, "single") || isa (b, "single"))
-    pdf = zeros (size (x), "single");
-  else
-    pdf = zeros (size (x));
-  endif
-
-  k = !(a > 0) | !(b > 0) | isnan (x);
-  pdf(k) = NaN;
-
-  k = (x >= 0) & (a > 0) & (a <= 1) & (b > 0);
-  if (isscalar (a) && isscalar (b))
-    pdf(k) = (x(k) .^ (a - 1)) ...
-              .* exp (- x(k) / b) / gamma (a) / (b ^ a);
-  else
-    pdf(k) = (x(k) .^ (a(k) - 1)) ...
-              .* exp (- x(k) ./ b(k)) ./ gamma (a(k)) ./ (b(k) .^ a(k));
-  endif
-
-  k = (x >= 0) & (a > 1) & (b > 0);
-  if (isscalar (a) && isscalar (b))
-    pdf(k) = exp (- a * log (b) + (a-1) * log (x(k))
-                  - x(k) / b - gammaln (a));
-  else
-    pdf(k) = exp (- a(k) .* log (b(k)) + (a(k)-1) .* log (x(k))
-                  - x(k) ./ b(k) - gammaln (a(k)));
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 0.5 1 Inf];
-%! y = [0 exp(-x(2:end))];
-%!assert (gampdf (x, ones (1,5), ones (1,5)), y)
-%!assert (gampdf (x, 1, ones (1,5)), y)
-%!assert (gampdf (x, ones (1,5), 1), y)
-%!assert (gampdf (x, [0 -Inf NaN Inf 1], 1), [NaN NaN NaN NaN y(5)])
-%!assert (gampdf (x, 1, [0 -Inf NaN Inf 1]), [NaN NaN NaN 0 y(5)])
-%!assert (gampdf ([x, NaN], 1, 1), [y, NaN])
-
-## Test class of input preserved
-%!assert (gampdf (single ([x, NaN]), 1, 1), single ([y, NaN]))
-%!assert (gampdf ([x, NaN], single (1), 1), single ([y, NaN]))
-%!assert (gampdf ([x, NaN], 1, single (1)), single ([y, NaN]))
-
-## Test input validation
-%!error gampdf ()
-%!error gampdf (1)
-%!error gampdf (1,2)
-%!error gampdf (1,2,3,4)
-%!error gampdf (ones (3), ones (2), ones (2))
-%!error gampdf (ones (2), ones (3), ones (2))
-%!error gampdf (ones (2), ones (2), ones (3))
-%!error gampdf (i, 2, 2)
-%!error gampdf (2, i, 2)
-%!error gampdf (2, 2, i)
diff --git a/scripts/statistics/distributions/gamrnd.m b/scripts/statistics/distributions/gamrnd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/gamrnd.m
+++ /dev/null
@@ -1,131 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} gamrnd (@var{a}, @var{b})
-## @deftypefnx {} {} gamrnd (@var{a}, @var{b}, @var{r})
-## @deftypefnx {} {} gamrnd (@var{a}, @var{b}, @var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} gamrnd (@var{a}, @var{b}, [@var{sz}])
-## Return a matrix of random samples from the Gamma distribution with
-## shape parameter @var{a} and scale @var{b}.
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-##
-## If no size arguments are given then the result matrix is the common size of
-## @var{a} and @var{b}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Random deviates from the Gamma distribution
-
-function rnd = gamrnd (a, b, varargin)
-
-  if (nargin < 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (a) || ! isscalar (b))
-    [retval, a, b] = common_size (a, b);
-    if (retval > 0)
-      error ("gamrnd: A and B must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (a) || iscomplex (b))
-    error ("gamrnd: A and B must not be complex");
-  endif
-
-  if (nargin == 2)
-    sz = size (a);
-  elseif (nargin == 3)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1};
-    else
-      error ("gamrnd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 3)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("gamrnd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  if (! isscalar (a) && ! isequal (size (a), sz))
-    error ("gamrnd: A and B must be scalar or of size SZ");
-  endif
-
-  if (isa (a, "single") || isa (b, "single"))
-    cls = "single";
-  else
-    cls = "double";
-  endif
-
-  if (isscalar (a) && isscalar (b))
-    if ((a > 0) && (a < Inf) && (b > 0) && (b < Inf))
-      rnd = b * randg (a, sz, cls);
-    else
-      rnd = NaN (sz, cls);
-    endif
-  else
-    rnd = NaN (sz, cls);
-
-    k = (a > 0) & (a < Inf) & (b > 0) & (b < Inf);
-    rnd(k) = b(k) .* randg (a(k), cls);
-  endif
-
-endfunction
-
-
-%!assert (size (gamrnd (1,2)), [1, 1])
-%!assert (size (gamrnd (ones (2,1), 2)), [2, 1])
-%!assert (size (gamrnd (ones (2,2), 2)), [2, 2])
-%!assert (size (gamrnd (1, 2*ones (2,1))), [2, 1])
-%!assert (size (gamrnd (1, 2*ones (2,2))), [2, 2])
-%!assert (size (gamrnd (1, 2, 3)), [3, 3])
-%!assert (size (gamrnd (1, 2, [4 1])), [4, 1])
-%!assert (size (gamrnd (1, 2, 4, 1)), [4, 1])
-
-## Test class of input preserved
-%!assert (class (gamrnd (1, 2)), "double")
-%!assert (class (gamrnd (single (1), 2)), "single")
-%!assert (class (gamrnd (single ([1 1]), 2)), "single")
-%!assert (class (gamrnd (1, single (2))), "single")
-%!assert (class (gamrnd (1, single ([2 2]))), "single")
-
-## Test input validation
-%!error gamrnd ()
-%!error gamrnd (1)
-%!error gamrnd (ones (3), ones (2))
-%!error gamrnd (ones (2), ones (3))
-%!error gamrnd (i, 2)
-%!error gamrnd (2, i)
-%!error gamrnd (1,2, -1)
-%!error gamrnd (1,2, ones (2))
-%!error gamrnd (1, 2, [2 -1 2])
-%!error gamrnd (1,2, 1, ones (2))
-%!error gamrnd (1,2, 1, -1)
-%!error gamrnd (ones (2,2), 2, 3)
-%!error gamrnd (ones (2,2), 2, [3, 2])
-%!error gamrnd (ones (2,2), 2, 2, 3)
diff --git a/scripts/statistics/distributions/geocdf.m b/scripts/statistics/distributions/geocdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/geocdf.m
+++ /dev/null
@@ -1,91 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} geocdf (@var{x}, @var{p})
-## For each element of @var{x}, compute the cumulative distribution function
-## (CDF) at @var{x} of the geometric distribution with parameter @var{p}.
-##
-## The geometric distribution models the number of failures (@var{x}-1) of a
-## Bernoulli trial with probability @var{p} before the first success (@var{x}).
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: CDF of the geometric distribution
-
-function cdf = geocdf (x, p)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (p))
-    [retval, x, p] = common_size (x, p);
-    if (retval > 0)
-      error ("geocdf: X and P must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (p))
-    error ("geocdf: X and P must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (p, "single"))
-    cdf = zeros (size (x), "single");
-  else
-    cdf = zeros (size (x));
-  endif
-
-  k = isnan (x) | !(p >= 0) | !(p <= 1);
-  cdf(k) = NaN;
-
-  k = (x == Inf) & (p >= 0) & (p <= 1);
-  cdf(k) = 1;
-
-  k = (x >= 0) & (x < Inf) & (x == fix (x)) & (p > 0) & (p <= 1);
-  if (isscalar (p))
-    cdf(k) = 1 - ((1 - p) .^ (x(k) + 1));
-  else
-    cdf(k) = 1 - ((1 - p(k)) .^ (x(k) + 1));
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 1 Inf];
-%! y = [0 0.5 0.75 1];
-%!assert (geocdf (x, 0.5*ones (1,4)), y)
-%!assert (geocdf (x, 0.5), y)
-%!assert (geocdf (x, 0.5*[-1 NaN 4 1]), [NaN NaN NaN y(4)])
-%!assert (geocdf ([x(1:2) NaN x(4)], 0.5), [y(1:2) NaN y(4)])
-
-## Test class of input preserved
-%!assert (geocdf ([x, NaN], 0.5), [y, NaN])
-%!assert (geocdf (single ([x, NaN]), 0.5), single ([y, NaN]))
-%!assert (geocdf ([x, NaN], single (0.5)), single ([y, NaN]))
-
-## Test input validation
-%!error geocdf ()
-%!error geocdf (1)
-%!error geocdf (1,2,3)
-%!error geocdf (ones (3), ones (2))
-%!error geocdf (ones (2), ones (3))
-%!error geocdf (i, 2)
-%!error geocdf (2, i)
diff --git a/scripts/statistics/distributions/geoinv.m b/scripts/statistics/distributions/geoinv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/geoinv.m
+++ /dev/null
@@ -1,87 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} geoinv (@var{x}, @var{p})
-## For each element of @var{x}, compute the quantile (the inverse of the CDF)
-## at @var{x} of the geometric distribution with parameter @var{p}.
-##
-## The geometric distribution models the number of failures (@var{x}-1) of a
-## Bernoulli trial with probability @var{p} before the first success (@var{x}).
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Quantile function of the geometric distribution
-
-function inv = geoinv (x, p)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (p))
-    [retval, x, p] = common_size (x, p);
-    if (retval > 0)
-      error ("geoinv: X and P must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (p))
-    error ("geoinv: X and P must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (p, "single"))
-    inv = NaN (size (x), "single");
-  else
-    inv = NaN (size (x));
-  endif
-
-  k = (x == 1) & (p >= 0) & (p <= 1);
-  inv(k) = Inf;
-
-  k = (x >= 0) & (x < 1) & (p > 0) & (p <= 1);
-  if (isscalar (p))
-    inv(k) = max (ceil (log (1 - x(k)) / log (1 - p)) - 1, 0);
-  else
-    inv(k) = max (ceil (log (1 - x(k)) ./ log (1 - p(k))) - 1, 0);
-  endif
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 0.75 1 2];
-%!assert (geoinv (x, 0.5*ones (1,5)), [NaN 0 1 Inf NaN])
-%!assert (geoinv (x, 0.5), [NaN 0 1 Inf NaN])
-%!assert (geoinv (x, 0.5*[1 -1 NaN 4 1]), [NaN NaN NaN NaN NaN])
-%!assert (geoinv ([x(1:2) NaN x(4:5)], 0.5), [NaN 0 NaN Inf NaN])
-
-## Test class of input preserved
-%!assert (geoinv ([x, NaN], 0.5), [NaN 0 1 Inf NaN NaN])
-%!assert (geoinv (single ([x, NaN]), 0.5), single ([NaN 0 1 Inf NaN NaN]))
-%!assert (geoinv ([x, NaN], single (0.5)), single ([NaN 0 1 Inf NaN NaN]))
-
-## Test input validation
-%!error geoinv ()
-%!error geoinv (1)
-%!error geoinv (1,2,3)
-%!error geoinv (ones (3), ones (2))
-%!error geoinv (ones (2), ones (3))
-%!error geoinv (i, 2)
-%!error geoinv (2, i)
diff --git a/scripts/statistics/distributions/geopdf.m b/scripts/statistics/distributions/geopdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/geopdf.m
+++ /dev/null
@@ -1,87 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} geopdf (@var{x}, @var{p})
-## For each element of @var{x}, compute the probability density function (PDF)
-## at @var{x} of the geometric distribution with parameter @var{p}.
-##
-## The geometric distribution models the number of failures (@var{x}-1) of a
-## Bernoulli trial with probability @var{p} before the first success (@var{x}).
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: PDF of the geometric distribution
-
-function pdf = geopdf (x, p)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (p))
-    [retval, x, p] = common_size (x, p);
-    if (retval > 0)
-      error ("geopdf: X and P must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (p))
-    error ("geopdf: X and P must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (p, "single"))
-    pdf = zeros (size (x), "single");
-  else
-    pdf = zeros (size (x));
-  endif
-
-  k = isnan (x) | (x == Inf) | !(p >= 0) | !(p <= 1);
-  pdf(k) = NaN;
-
-  k = (x >= 0) & (x < Inf) & (x == fix (x)) & (p > 0) & (p <= 1);
-  if (isscalar (p))
-    pdf(k) = p * ((1 - p) .^ x(k));
-  else
-    pdf(k) = p(k) .* ((1 - p(k)) .^ x(k));
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 1 Inf];
-%! y = [0, 1/2, 1/4, NaN];
-%!assert (geopdf (x, 0.5*ones (1,4)), y)
-%!assert (geopdf (x, 0.5), y)
-%!assert (geopdf (x, 0.5*[-1 NaN 4 1]), [NaN NaN NaN y(4)])
-%!assert (geopdf ([x, NaN], 0.5), [y, NaN])
-
-## Test class of input preserved
-%!assert (geopdf (single ([x, NaN]), 0.5), single ([y, NaN]), 5*eps ("single"))
-%!assert (geopdf ([x, NaN], single (0.5)), single ([y, NaN]), 5*eps ("single"))
-
-## Test input validation
-%!error geopdf ()
-%!error geopdf (1)
-%!error geopdf (1,2,3)
-%!error geopdf (ones (3), ones (2))
-%!error geopdf (ones (2), ones (3))
-%!error geopdf (i, 2)
-%!error geopdf (2, i)
diff --git a/scripts/statistics/distributions/geornd.m b/scripts/statistics/distributions/geornd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/geornd.m
+++ /dev/null
@@ -1,127 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} geornd (@var{p})
-## @deftypefnx {} {} geornd (@var{p}, @var{r})
-## @deftypefnx {} {} geornd (@var{p}, @var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} geornd (@var{p}, [@var{sz}])
-## Return a matrix of random samples from the geometric distribution with
-## parameter @var{p}.
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-##
-## If no size arguments are given then the result matrix is the size of
-## @var{p}.
-##
-## The geometric distribution models the number of failures (@var{x}-1) of a
-## Bernoulli trial with probability @var{p} before the first success (@var{x}).
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Random deviates from the geometric distribution
-
-function rnd = geornd (p, varargin)
-
-  if (nargin < 1)
-    print_usage ();
-  endif
-
-  if (nargin == 1)
-    sz = size (p);
-  elseif (nargin == 2)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1};
-    else
-      error ("geornd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 2)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("geornd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  if (! isscalar (p) && ! isequal (size (p), sz))
-    error ("geornd: P must be scalar or of size SZ");
-  endif
-
-  if (iscomplex (p))
-    error ("geornd: P must not be complex");
-  endif
-
-  if (isa (p, "single"))
-    cls = "single";
-  else
-    cls = "double";
-  endif
-
-  if (isscalar (p))
-    if (p > 0 && p < 1);
-      rnd = floor (- rande (sz, cls) ./ log (1 - p));
-    elseif (p == 0)
-      rnd = Inf (sz, cls);
-    elseif (p == 1)
-      rnd = zeros (sz, cls);
-    elseif (p < 0 || p > 1)
-      rnd = NaN (sz, cls);
-    endif
-  else
-    rnd = floor (- rande (sz, cls) ./ log (1 - p));
-
-    k = !(p >= 0) | !(p <= 1);
-    rnd(k) = NaN;
-
-    k = (p == 0);
-    rnd(k) = Inf;
-  endif
-
-endfunction
-
-
-%!assert (size (geornd (0.5)), [1, 1])
-%!assert (size (geornd (0.5*ones (2,1))), [2, 1])
-%!assert (size (geornd (0.5*ones (2,2))), [2, 2])
-%!assert (size (geornd (0.5, 3)), [3, 3])
-%!assert (size (geornd (0.5, [4 1])), [4, 1])
-%!assert (size (geornd (0.5, 4, 1)), [4, 1])
-
-## Test class of input preserved
-%!assert (class (geornd (0.5)), "double")
-%!assert (class (geornd (single (0.5))), "single")
-%!assert (class (geornd (single ([0.5 0.5]))), "single")
-%!assert (class (geornd (single (0))), "single")
-%!assert (class (geornd (single (1))), "single")
-
-## Test input validation
-%!error geornd ()
-%!error geornd (ones (3), ones (2))
-%!error geornd (ones (2), ones (3))
-%!error geornd (i)
-%!error geornd (1, -1)
-%!error geornd (1, ones (2))
-%!error geornd (1, [2 -1 2])
-%!error geornd (ones (2,2), 2, 3)
-%!error geornd (ones (2,2), 3, 2)
diff --git a/scripts/statistics/distributions/hygecdf.m b/scripts/statistics/distributions/hygecdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/hygecdf.m
+++ /dev/null
@@ -1,109 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1997-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} hygecdf (@var{x}, @var{t}, @var{m}, @var{n})
-## Compute the cumulative distribution function (CDF) at @var{x} of the
-## hypergeometric distribution with parameters @var{t}, @var{m}, and @var{n}.
-##
-## This is the probability of obtaining not more than @var{x} marked items
-## when randomly drawing a sample of size @var{n} without replacement from a
-## population of total size @var{t} containing @var{m} marked items.
-##
-## The parameters @var{t}, @var{m}, and @var{n} must be positive integers
-## with @var{m} and @var{n} not greater than @var{t}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: CDF of the hypergeometric distribution
-
-function cdf = hygecdf (x, t, m, n)
-
-  if (nargin != 4)
-    print_usage ();
-  endif
-
-  if (! isscalar (t) || ! isscalar (m) || ! isscalar (n))
-    [retval, x, t, m, n] = common_size (x, t, m, n);
-    if (retval > 0)
-      error ("hygecdf: X, T, M, and N must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (t) || iscomplex (m) || iscomplex (n))
-    error ("hygecdf: X, T, M, and N must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (t, "single")
-      || isa (m, "single") || isa (n, "single"))
-    cdf = NaN (size (x), "single");
-  else
-    cdf = NaN (size (x));
-  endif
-
-  ok = ((t >= 0) & (m >= 0) & (n > 0) & (m <= t) & (n <= t) &
-        (t == fix (t)) & (m == fix (m)) & (n == fix (n)));
-
-  if (isscalar (t))
-    if (ok)
-      cdf = discrete_cdf (x, 0 : n, hygepdf (0 : n, t, m, n));
-    endif
-  else
-    for i = find (ok(:)')  # Must be row vector arg to for loop
-      v = 0 : n(i);
-      cdf(i) = discrete_cdf (x(i), v, hygepdf (v, t(i), m(i), n(i)));
-    endfor
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 1 2 3];
-%! y = [0 1/6 5/6 1 1];
-%!assert (hygecdf (x, 4*ones (1,5), 2, 2), y, eps)
-%!assert (hygecdf (x, 4, 2*ones (1,5), 2), y, eps)
-%!assert (hygecdf (x, 4, 2, 2*ones (1,5)), y, eps)
-%!assert (hygecdf (x, 4*[1 -1 NaN 1.1 1], 2, 2), [y(1) NaN NaN NaN y(5)], eps)
-%!assert (hygecdf (x, 4, 2*[1 -1 NaN 1.1 1], 2), [y(1) NaN NaN NaN y(5)], eps)
-%!assert (hygecdf (x, 4, 5, 2), [NaN NaN NaN NaN NaN])
-%!assert (hygecdf (x, 4, 2, 2*[1 -1 NaN 1.1 1]), [y(1) NaN NaN NaN y(5)], eps)
-%!assert (hygecdf (x, 4, 2, 5), [NaN NaN NaN NaN NaN])
-%!assert (hygecdf ([x(1:2) NaN x(4:5)], 4, 2, 2), [y(1:2) NaN y(4:5)], eps)
-
-## Test class of input preserved
-%!assert (hygecdf ([x, NaN], 4, 2, 2), [y, NaN], eps)
-%!assert (hygecdf (single ([x, NaN]), 4, 2, 2), single ([y, NaN]), eps ("single"))
-%!assert (hygecdf ([x, NaN], single (4), 2, 2), single ([y, NaN]), eps ("single"))
-%!assert (hygecdf ([x, NaN], 4, single (2), 2), single ([y, NaN]), eps ("single"))
-%!assert (hygecdf ([x, NaN], 4, 2, single (2)), single ([y, NaN]), eps ("single"))
-
-## Test input validation
-%!error hygecdf ()
-%!error hygecdf (1)
-%!error hygecdf (1,2)
-%!error hygecdf (1,2,3)
-%!error hygecdf (1,2,3,4,5)
-%!error hygecdf (ones (2), ones (3), 1, 1)
-%!error hygecdf (1, ones (2), ones (3), 1)
-%!error hygecdf (1, 1, ones (2), ones (3))
-%!error hygecdf (i, 2, 2, 2)
-%!error hygecdf (2, i, 2, 2)
-%!error hygecdf (2, 2, i, 2)
-%!error hygecdf (2, 2, 2, i)
diff --git a/scripts/statistics/distributions/hygeinv.m b/scripts/statistics/distributions/hygeinv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/hygeinv.m
+++ /dev/null
@@ -1,115 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1997-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} hygeinv (@var{x}, @var{t}, @var{m}, @var{n})
-## For each element of @var{x}, compute the quantile (the inverse of the CDF)
-## at @var{x} of the hypergeometric distribution with parameters
-## @var{t}, @var{m}, and @var{n}.
-##
-## This is the probability of obtaining @var{x} marked items when randomly
-## drawing a sample of size @var{n} without replacement from a population of
-## total size @var{t} containing @var{m} marked items.
-##
-## The parameters @var{t}, @var{m}, and @var{n} must be positive integers
-## with @var{m} and @var{n} not greater than @var{t}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Random deviates from the hypergeometric distribution
-
-function inv = hygeinv (x, t, m, n)
-
-  if (nargin != 4)
-    print_usage ();
-  endif
-
-  if (! isscalar (t) || ! isscalar (m) || ! isscalar (n))
-    [retval, x, t, m, n] = common_size (x, t, m, n);
-    if (retval > 0)
-      error ("hygeinv: X, T, M, and N must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (t) || iscomplex (m) || iscomplex (n))
-    error ("hygeinv: X, T, M, and N must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (t, "single")
-      || isa (m, "single") || isa (n, "single"))
-    inv = NaN (size (x), "single");
-  else
-    inv = NaN (size (x));
-  endif
-
-  ok = ((t >= 0) & (m >= 0) & (n > 0) & (m <= t) & (n <= t) &
-        (t == fix (t)) & (m == fix (m)) & (n == fix (n)));
-
-  if (isscalar (t))
-    if (ok)
-      inv = discrete_inv (x, 0 : n, hygepdf (0 : n, t, m, n));
-      inv(x == 0) = 0;  # Hack to return correct value for start of distribution
-    endif
-  else
-    for i = find (ok(:)')  # Must be row vector arg to for loop
-      v = 0 : n(i);
-      if (x(i) == 0)
-        inv(i) = 0;  # Hack to return correct value for start of distribution
-      else
-        inv(i) = discrete_inv (x(i), v, hygepdf (v, t(i), m(i), n(i)));
-      endif
-    endfor
-  endif
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 0.5 1 2];
-%!assert (hygeinv (x, 4*ones (1,5), 2*ones (1,5), 2*ones (1,5)), [NaN 0 1 2 NaN])
-%!assert (hygeinv (x, 4*ones (1,5), 2, 2), [NaN 0 1 2 NaN])
-%!assert (hygeinv (x, 4, 2*ones (1,5), 2), [NaN 0 1 2 NaN])
-%!assert (hygeinv (x, 4, 2, 2*ones (1,5)), [NaN 0 1 2 NaN])
-%!assert (hygeinv (x, 4*[1 -1 NaN 1.1 1], 2, 2), [NaN NaN NaN NaN NaN])
-%!assert (hygeinv (x, 4, 2*[1 -1 NaN 1.1 1], 2), [NaN NaN NaN NaN NaN])
-%!assert (hygeinv (x, 4, 5, 2), [NaN NaN NaN NaN NaN])
-%!assert (hygeinv (x, 4, 2, 2*[1 -1 NaN 1.1 1]), [NaN NaN NaN NaN NaN])
-%!assert (hygeinv (x, 4, 2, 5), [NaN NaN NaN NaN NaN])
-%!assert (hygeinv ([x(1:2) NaN x(4:5)], 4, 2, 2), [NaN 0 NaN 2 NaN])
-
-## Test class of input preserved
-%!assert (hygeinv ([x, NaN], 4, 2, 2), [NaN 0 1 2 NaN NaN])
-%!assert (hygeinv (single ([x, NaN]), 4, 2, 2), single ([NaN 0 1 2 NaN NaN]))
-%!assert (hygeinv ([x, NaN], single (4), 2, 2), single ([NaN 0 1 2 NaN NaN]))
-%!assert (hygeinv ([x, NaN], 4, single (2), 2), single ([NaN 0 1 2 NaN NaN]))
-%!assert (hygeinv ([x, NaN], 4, 2, single (2)), single ([NaN 0 1 2 NaN NaN]))
-
-## Test input validation
-%!error hygeinv ()
-%!error hygeinv (1)
-%!error hygeinv (1,2)
-%!error hygeinv (1,2,3)
-%!error hygeinv (1,2,3,4,5)
-%!error hygeinv (ones (2), ones (3), 1, 1)
-%!error hygeinv (1, ones (2), ones (3), 1)
-%!error hygeinv (1, 1, ones (2), ones (3))
-%!error hygeinv (i, 2, 2, 2)
-%!error hygeinv (2, i, 2, 2)
-%!error hygeinv (2, 2, i, 2)
-%!error hygeinv (2, 2, 2, i)
diff --git a/scripts/statistics/distributions/hygepdf.m b/scripts/statistics/distributions/hygepdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/hygepdf.m
+++ /dev/null
@@ -1,113 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1996-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} hygepdf (@var{x}, @var{t}, @var{m}, @var{n})
-## Compute the probability density function (PDF) at @var{x} of the
-## hypergeometric distribution with parameters @var{t}, @var{m}, and @var{n}.
-##
-## This is the probability of obtaining @var{x} marked items when randomly
-## drawing a sample of size @var{n} without replacement from a population of
-## total size @var{t} containing @var{m} marked items.
-##
-## The parameters @var{t}, @var{m}, and @var{n} must be positive integers
-## with @var{m} and @var{n} not greater than @var{t}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: PDF of the hypergeometric distribution
-
-function pdf = hygepdf (x, t, m, n)
-
-  if (nargin != 4)
-    print_usage ();
-  endif
-
-  if (! isscalar (t) || ! isscalar (m) || ! isscalar (n))
-    [retval, x, t, m, n] = common_size (x, t, m, n);
-    if (retval > 0)
-      error ("hygepdf: X, T, M, and N must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (t) || iscomplex (m) || iscomplex (n))
-    error ("hygepdf: X, T, M, and N must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (t, "single")
-      || isa (m, "single") || isa (n, "single"))
-    pdf = zeros (size (x), "single");
-  else
-    pdf = zeros (size (x));
-  endif
-
-  ## everything in nel gives NaN
-  nel = (isnan (x) | (t < 0) | (m < 0) | (n <= 0) | (m > t) | (n > t) |
-        (t != fix (t)) | (m != fix (m)) | (n != fix (n)));
-  ## everything in zel gives 0 unless in nel
-  zel = ((x != fix (x)) | (x < 0) | (x > m) | (n < x) | (n-x > t-m));
-
-  pdf(nel) = NaN;
-
-  k = ! nel & ! zel;
-  if (any (k(:)))
-    if (isscalar (t) && isscalar (m) && isscalar (n))
-      pdf(k) = (bincoeff (m, x(k)) .* bincoeff (t-m, n-x(k))
-                / bincoeff (t, n));
-    else
-      pdf(k) = (bincoeff (m(k), x(k)) .* bincoeff (t(k)-m(k), n(k)-x(k))
-                ./ bincoeff (t(k), n(k)));
-    endif
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 1 2 3];
-%! y = [0 1/6 4/6 1/6 0];
-%!assert (hygepdf (x, 4*ones (1,5), 2, 2), y)
-%!assert (hygepdf (x, 4, 2*ones (1,5), 2), y)
-%!assert (hygepdf (x, 4, 2, 2*ones (1,5)), y)
-%!assert (hygepdf (x, 4*[1 -1 NaN 1.1 1], 2, 2), [0 NaN NaN NaN 0])
-%!assert (hygepdf (x, 4, 2*[1 -1 NaN 1.1 1], 2), [0 NaN NaN NaN 0])
-%!assert (hygepdf (x, 4, 5, 2), [NaN NaN NaN NaN NaN])
-%!assert (hygepdf (x, 4, 2, 2*[1 -1 NaN 1.1 1]), [0 NaN NaN NaN 0])
-%!assert (hygepdf (x, 4, 2, 5), [NaN NaN NaN NaN NaN])
-%!assert (hygepdf ([x, NaN], 4, 2, 2), [y, NaN], eps)
-
-## Test class of input preserved
-%!assert (hygepdf (single ([x, NaN]), 4, 2, 2), single ([y, NaN]))
-%!assert (hygepdf ([x, NaN], single (4), 2, 2), single ([y, NaN]))
-%!assert (hygepdf ([x, NaN], 4, single (2), 2), single ([y, NaN]))
-%!assert (hygepdf ([x, NaN], 4, 2, single (2)), single ([y, NaN]))
-
-## Test input validation
-%!error hygepdf ()
-%!error hygepdf (1)
-%!error hygepdf (1,2)
-%!error hygepdf (1,2,3)
-%!error hygepdf (1,2,3,4,5)
-%!error hygepdf (1, ones (3), ones (2), ones (2))
-%!error hygepdf (1, ones (2), ones (3), ones (2))
-%!error hygepdf (1, ones (2), ones (2), ones (3))
-%!error hygepdf (i, 2, 2, 2)
-%!error hygepdf (2, i, 2, 2)
-%!error hygepdf (2, 2, i, 2)
-%!error hygepdf (2, 2, 2, i)
diff --git a/scripts/statistics/distributions/hygernd.m b/scripts/statistics/distributions/hygernd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/hygernd.m
+++ /dev/null
@@ -1,147 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1997-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} hygernd (@var{t}, @var{m}, @var{n})
-## @deftypefnx {} {} hygernd (@var{t}, @var{m}, @var{n}, @var{r})
-## @deftypefnx {} {} hygernd (@var{t}, @var{m}, @var{n}, @var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} hygernd (@var{t}, @var{m}, @var{n}, [@var{sz}])
-## Return a matrix of random samples from the hypergeometric distribution
-## with parameters @var{t}, @var{m}, and @var{n}.
-##
-## The parameters @var{t}, @var{m}, and @var{n} must be positive integers
-## with @var{m} and @var{n} not greater than @var{t}.
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-##
-## If no size arguments are given then the result matrix is the common size of
-## @var{t}, @var{m}, and @var{n}.
-## @end deftypefn
-
-function rnd = hygernd (t, m, n, varargin)
-
-  if (nargin < 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (t) || ! isscalar (m) || ! isscalar (n))
-    [retval, t, m, n] = common_size (t, m, n);
-    if (retval > 0)
-      error ("hygernd: T, M, and N must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (t) || iscomplex (m) || iscomplex (n))
-    error ("hygernd: T, M, and N must not be complex");
-  endif
-
-  if (nargin == 3)
-    sz = size (t);
-  elseif (nargin == 4)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1};
-    else
-      error ("hygernd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 4)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("hygernd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  if (! isscalar (t) && ! isequal (size (t), sz))
-    error ("hygernd: T, M, and N must be scalar or of size SZ");
-  endif
-
-  if (isa (t, "single") || isa (m, "single") || isa (n, "single"))
-    cls = "single";
-  else
-    cls = "double";
-  endif
-
-  ok = ((t >= 0) & (m >= 0) & (n > 0) & (m <= t) & (n <= t) &
-        (t == fix (t)) & (m == fix (m)) & (n == fix (n)));
-
-  if (isscalar (t))
-    if (ok)
-      v = 0:n;
-      p = hygepdf (v, t, m, n);
-      rnd = v(lookup (cumsum (p(1:end-1)) / sum (p), rand (sz)) + 1);
-      rnd = reshape (rnd, sz);
-      if (strcmp (cls, "single"))
-        rnd = single (rnd);
-      endif
-    else
-      rnd = NaN (sz, cls);
-    endif
-  else
-    rnd = NaN (sz, cls);
-    rn = rand (sz);
-    for i = find (ok(:)')  # Must be row vector arg to for loop
-      v = 0 : n(i);
-      p = hygepdf (v, t(i), m(i), n(i));
-      rnd(i) = v(lookup (cumsum (p(1 : end-1)) / sum (p), rn(i)) + 1);
-    endfor
-  endif
-
-endfunction
-
-
-%!assert (size (hygernd (4,2,2)), [1, 1])
-%!assert (size (hygernd (4*ones (2,1), 2,2)), [2, 1])
-%!assert (size (hygernd (4*ones (2,2), 2,2)), [2, 2])
-%!assert (size (hygernd (4, 2*ones (2,1), 2)), [2, 1])
-%!assert (size (hygernd (4, 2*ones (2,2), 2)), [2, 2])
-%!assert (size (hygernd (4, 2, 2*ones (2,1))), [2, 1])
-%!assert (size (hygernd (4, 2, 2*ones (2,2))), [2, 2])
-%!assert (size (hygernd (4, 2, 2, 3)), [3, 3])
-%!assert (size (hygernd (4, 2, 2, [4 1])), [4, 1])
-%!assert (size (hygernd (4, 2, 2, 4, 1)), [4, 1])
-
-%!assert (class (hygernd (4,2,2)), "double")
-%!assert (class (hygernd (single (4),2,2)), "single")
-%!assert (class (hygernd (single ([4 4]),2,2)), "single")
-%!assert (class (hygernd (4,single (2),2)), "single")
-%!assert (class (hygernd (4,single ([2 2]),2)), "single")
-%!assert (class (hygernd (4,2,single (2))), "single")
-%!assert (class (hygernd (4,2,single ([2 2]))), "single")
-
-## Test input validation
-%!error hygernd ()
-%!error hygernd (1)
-%!error hygernd (1,2)
-%!error hygernd (ones (3), ones (2), ones (2), 2)
-%!error hygernd (ones (2), ones (3), ones (2), 2)
-%!error hygernd (ones (2), ones (2), ones (3), 2)
-%!error hygernd (i, 2, 2)
-%!error hygernd (2, i, 2)
-%!error hygernd (2, 2, i)
-%!error hygernd (4,2,2, -1)
-%!error hygernd (4,2,2, ones (2))
-%!error hygernd (4,2,2, [2 -1 2])
-%!error hygernd (4*ones (2),2,2, 3)
-%!error hygernd (4*ones (2),2,2, [3, 2])
-%!error hygernd (4*ones (2),2,2, 3, 2)
diff --git a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
+++ /dev/null
@@ -1,96 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} kolmogorov_smirnov_cdf (@var{x}, @var{tol})
-## Return the cumulative distribution function (CDF) at @var{x} of the
-## Kolmogorov-Smirnov distribution.
-##
-## This is defined as
-## @tex
-## $$ Q(x) = \sum_{k=-\infty}^\infty (-1)^k \exp (-2 k^2 x^2) $$
-## @end tex
-## @ifnottex
-##
-## @example
-## @group
-##          Inf
-## Q(x) =   SUM    (-1)^k exp (-2 k^2 x^2)
-##        k = -Inf
-## @end group
-## @end example
-##
-## @end ifnottex
-## @noindent
-## for @var{x} > 0.
-##
-## The optional parameter @var{tol} specifies the precision up to which
-## the series should be evaluated; the default is @var{tol} = @code{eps}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: CDF of the Kolmogorov-Smirnov distribution
-
-function cdf = kolmogorov_smirnov_cdf (x, tol)
-
-  if (nargin < 1 || nargin > 2)
-    print_usage ();
-  endif
-
-  if (nargin == 1)
-    if (isa (x, "single"))
-      tol = eps ("single");
-    else
-      tol = eps;
-    endif
-  else
-    if (! (isscalar (tol) && (tol > 0)))
-      error ("kolmogorov_smirnov_cdf: TOL must be a positive scalar");
-    endif
-  endif
-
-  if (numel (x) == 0)
-    error ("kolmogorov_smirnov_cdf: X must not be empty");
-  endif
-
-  cdf = zeros (size (x));
-
-  ind = find (x > 0);
-  if (length (ind) > 0)
-    if (columns (ind) < rows (ind))
-      y = x(ind.');
-    else
-      y = x(ind);
-    endif
-    K   = ceil (sqrt (- log (tol) / 2) / min (y));
-    k   = (1:K)';
-    A   = exp (- 2 * k.^2 * y.^2);
-    odd = find (rem (k, 2) == 1);
-    A(odd,:) = -A(odd,:);
-    cdf(ind) = 1 + 2 * sum (A);
-  endif
-
-endfunction
-
-
-## Test input validation
-%!error kolmogorov_smirnov_cdf ()
-%!error kolmogorov_smirnov_cdf (1,2,3)
-%!error kolmogorov_smirnov_cdf (1, ones (2))
-%!error kolmogorov_smirnov_cdf ([], 1)
diff --git a/scripts/statistics/distributions/laplace_cdf.m b/scripts/statistics/distributions/laplace_cdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/laplace_cdf.m
+++ /dev/null
@@ -1,55 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} laplace_cdf (@var{x})
-## For each element of @var{x}, compute the cumulative distribution function
-## (CDF) at @var{x} of the Laplace distribution.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: CDF of the Laplace distribution
-
-function cdf = laplace_cdf (x)
-
-  if (nargin != 1)
-    print_usage ();
-  endif
-
-  if (iscomplex (x))
-    error ("laplace_cdf: X must not be complex");
-  endif
-
-  cdf = (1 + sign (x) .* (1 - exp (- abs (x)))) / 2;
-
-endfunction
-
-
-%!shared x,y
-%! x = [-Inf -log(2) 0 log(2) Inf];
-%! y = [0, 1/4, 1/2, 3/4, 1];
-%!assert (laplace_cdf ([x, NaN]), [y, NaN])
-
-## Test class of input preserved
-%!assert (laplace_cdf (single ([x, NaN])), single ([y, NaN]))
-
-## Test input validation
-%!error laplace_cdf ()
-%!error laplace_cdf (1,2)
-%!error laplace_cdf (i)
diff --git a/scripts/statistics/distributions/laplace_inv.m b/scripts/statistics/distributions/laplace_inv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/laplace_inv.m
+++ /dev/null
@@ -1,63 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} laplace_inv (@var{x})
-## For each element of @var{x}, compute the quantile (the inverse of the CDF)
-## at @var{x} of the Laplace distribution.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Quantile function of the Laplace distribution
-
-function inv = laplace_inv (x)
-
-  if (nargin != 1)
-    print_usage ();
-  endif
-
-  if (iscomplex (x))
-    error ("laplace_inv: X must not be complex");
-  endif
-
-  if (isa (x, "single"))
-    inv = NaN (size (x), "single");
-  else
-    inv = NaN (size (x));
-  endif
-
-  k = (x >= 0) & (x <= 1);
-  inv(k) = ((x(k) < 1/2) .* log (2 * x(k))
-            - (x(k) > 1/2) .* log (2 * (1 - x(k))));
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 0.5 1 2];
-%!assert (laplace_inv (x), [NaN -Inf 0 Inf NaN])
-
-## Test class of input preserved
-%!assert (laplace_inv ([x, NaN]), [NaN -Inf 0 Inf NaN NaN])
-%!assert (laplace_inv (single ([x, NaN])), single ([NaN -Inf 0 Inf NaN NaN]))
-
-## Test input validation
-%!error laplace_inv ()
-%!error laplace_inv (1,2)
-%!error laplace_inv (i)
diff --git a/scripts/statistics/distributions/laplace_pdf.m b/scripts/statistics/distributions/laplace_pdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/laplace_pdf.m
+++ /dev/null
@@ -1,55 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} laplace_pdf (@var{x})
-## For each element of @var{x}, compute the probability density function (PDF)
-## at @var{x} of the Laplace distribution.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: PDF of the Laplace distribution
-
-function pdf = laplace_pdf (x)
-
-  if (nargin != 1)
-    print_usage ();
-  endif
-
-  if (iscomplex (x))
-    error ("laplace_pdf: X must not be complex");
-  endif
-
-  pdf = exp (- abs (x)) / 2;
-
-endfunction
-
-
-%!shared x,y
-%! x = [-Inf -log(2) 0 log(2) Inf];
-%! y = [0, 1/4, 1/2, 1/4, 0];
-%!assert (laplace_pdf ([x, NaN]), [y, NaN])
-
-## Test class of input preserved
-%!assert (laplace_pdf (single ([x, NaN])), single ([y, NaN]))
-
-## Test input validation
-%!error laplace_pdf ()
-%!error laplace_pdf (1,2)
-%!error laplace_pdf (i)
diff --git a/scripts/statistics/distributions/laplace_rnd.m b/scripts/statistics/distributions/laplace_rnd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/laplace_rnd.m
+++ /dev/null
@@ -1,73 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} laplace_rnd (@var{r})
-## @deftypefnx {} {} laplace_rnd (@var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} laplace_rnd ([@var{sz}])
-## Return a matrix of random samples from the Laplace distribution.
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Random deviates from the Laplace distribution
-
-function rnd = laplace_rnd (varargin)
-
-  if (nargin < 1)
-    print_usage ();
-  endif
-
-  if (nargin == 1)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1}(:)';
-    else
-      error ("laplace_rnd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 1)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("laplace_rnd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  tmp = rand (sz);
-  rnd = (tmp < 1/2) .* log (2 * tmp) - (tmp > 1/2) .* log (2 * (1 - tmp));
-
-endfunction
-
-
-%!assert (size (laplace_rnd (3)), [3, 3])
-%!assert (size (laplace_rnd ([4 1])), [4, 1])
-%!assert (size (laplace_rnd (4,1)), [4, 1])
-
-## Test input validation
-%!error laplace_rnd ()
-%!error laplace_rnd (-1)
-%!error laplace_rnd (ones (2))
-%!error laplace_rnd ([2 -1 2])
-%!error laplace_rnd (1, ones (2))
-%!error laplace_rnd (1, -1)
diff --git a/scripts/statistics/distributions/logistic_cdf.m b/scripts/statistics/distributions/logistic_cdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/logistic_cdf.m
+++ /dev/null
@@ -1,55 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} logistic_cdf (@var{x})
-## For each element of @var{x}, compute the cumulative distribution function
-## (CDF) at @var{x} of the logistic distribution.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: CDF of the logistic distribution
-
-function cdf = logistic_cdf (x)
-
-  if (nargin != 1)
-    print_usage ();
-  endif
-
-  if (iscomplex (x))
-    error ("logistic_cdf: X must not be complex");
-  endif
-
-  cdf = 1 ./ (1 + exp (-x));
-
-endfunction
-
-
-%!shared x,y
-%! x = [-Inf -log(3) 0 log(3) Inf];
-%! y = [0, 1/4, 1/2, 3/4, 1];
-%!assert (logistic_cdf ([x, NaN]), [y, NaN], eps)
-
-## Test class of input preserved
-%!assert (logistic_cdf (single ([x, NaN])), single ([y, NaN]), eps ("single"))
-
-## Test input validation
-%!error logistic_cdf ()
-%!error logistic_cdf (1,2)
-%!error logistic_cdf (i)
diff --git a/scripts/statistics/distributions/logistic_inv.m b/scripts/statistics/distributions/logistic_inv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/logistic_inv.m
+++ /dev/null
@@ -1,68 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} logistic_inv (@var{x})
-## For each element of @var{x}, compute the quantile (the inverse of the CDF)
-## at @var{x} of the logistic distribution.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Quantile function of the logistic distribution
-
-function inv = logistic_inv (x)
-
-  if (nargin != 1)
-    print_usage ();
-  endif
-
-  if (iscomplex (x))
-    error ("logistic_inv: X must not be complex");
-  endif
-
-  if (isa (x, "single"))
-    inv = NaN (size (x), "single");
-  else
-    inv = NaN (size (x));
-  endif
-
-  k = (x == 0);
-  inv(k) = -Inf;
-
-  k = (x == 1);
-  inv(k) = Inf;
-
-  k = (x > 0) & (x < 1);
-  inv(k) = - log (1 ./ x(k) - 1);
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 0.5 1 2];
-%!assert (logistic_inv (x), [NaN -Inf 0 Inf NaN])
-
-## Test class of input preserved
-%!assert (logistic_inv ([x, NaN]), [NaN -Inf 0 Inf NaN NaN])
-%!assert (logistic_inv (single ([x, NaN])), single ([NaN -Inf 0 Inf NaN NaN]))
-
-## Test input validation
-%!error logistic_inv ()
-%!error logistic_inv (1,2)
-%!error logistic_inv (i)
diff --git a/scripts/statistics/distributions/logistic_pdf.m b/scripts/statistics/distributions/logistic_pdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/logistic_pdf.m
+++ /dev/null
@@ -1,55 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} logistic_pdf (@var{x})
-## For each element of @var{x}, compute the PDF at @var{x} of the
-## logistic distribution.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: PDF of the logistic distribution
-
-function pdf = logistic_pdf (x)
-
-  if (nargin != 1)
-    print_usage ();
-  endif
-
-  if (iscomplex (x))
-    error ("logistic_pdf: X must not be complex");
-  endif
-
-  cdf = logistic_cdf (x);
-  pdf = cdf .* (1 - cdf);
-
-endfunction
-
-
-%!shared x,y
-%! x = [-Inf -log(4) 0 log(4) Inf];
-%! y = [0, 0.16, 1/4, 0.16, 0];
-%!assert (logistic_pdf ([x, NaN]), [y, NaN], eps)
-
-## Test class of input preserved
-%!assert (logistic_pdf (single ([x, NaN])), single ([y, NaN]), eps ("single"))
-
-## Test input validation
-%!error logistic_pdf ()
-%!error logistic_pdf (1,2)
-%!error logistic_pdf (i)
diff --git a/scripts/statistics/distributions/logistic_rnd.m b/scripts/statistics/distributions/logistic_rnd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/logistic_rnd.m
+++ /dev/null
@@ -1,72 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} logistic_rnd (@var{r})
-## @deftypefnx {} {} logistic_rnd (@var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} logistic_rnd ([@var{sz}])
-## Return a matrix of random samples from the logistic distribution.
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Random deviates from the logistic distribution
-
-function rnd = logistic_rnd (varargin)
-
-  if (nargin < 1)
-    print_usage ();
-  endif
-
-  if (nargin == 1)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1};
-    else
-      error ("logistic_rnd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 1)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("logistic_rnd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  rnd = - log (1 ./ rand (sz) - 1);
-
-endfunction
-
-
-%!assert (size (logistic_rnd (3)), [3, 3])
-%!assert (size (logistic_rnd ([4 1])), [4, 1])
-%!assert (size (logistic_rnd (4,1)), [4, 1])
-
-## Test input validation
-%!error logistic_rnd ()
-%!error logistic_rnd (-1)
-%!error logistic_rnd (ones (2))
-%!error logistic_rnd ([2 -1 2])
-%!error logistic_rnd (1, ones (2))
-%!error logistic_rnd (1, -1)
diff --git a/scripts/statistics/distributions/logncdf.m b/scripts/statistics/distributions/logncdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/logncdf.m
+++ /dev/null
@@ -1,100 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} logncdf (@var{x})
-## @deftypefnx {} {} logncdf (@var{x}, @var{mu}, @var{sigma})
-## For each element of @var{x}, compute the cumulative distribution function
-## (CDF) at @var{x} of the lognormal distribution with parameters
-## @var{mu} and @var{sigma}.
-##
-## If a random variable follows this distribution, its logarithm is normally
-## distributed with mean @var{mu} and standard deviation @var{sigma}.
-##
-## Default values are @var{mu} = 0, @var{sigma} = 1.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: CDF of the log normal distribution
-
-function cdf = logncdf (x, mu = 0, sigma = 1)
-
-  if (nargin != 1 && nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (mu) || ! isscalar (sigma))
-    [retval, x, mu, sigma] = common_size (x, mu, sigma);
-    if (retval > 0)
-      error ("logncdf: X, MU, and SIGMA must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (mu) || iscomplex (sigma))
-    error ("logncdf: X, MU, and SIGMA must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (mu, "single") || isa (sigma, "single"))
-    cdf = zeros (size (x), "single");
-  else
-    cdf = zeros (size (x));
-  endif
-
-  k = isnan (x) | !(sigma > 0) | !(sigma < Inf);
-  cdf(k) = NaN;
-
-  k = (x == Inf) & (sigma > 0) & (sigma < Inf);
-  cdf(k) = 1;
-
-  k = (x > 0) & (x < Inf) & (sigma > 0) & (sigma < Inf);
-  if (isscalar (mu) && isscalar (sigma))
-    cdf(k) = stdnormal_cdf ((log (x(k)) - mu) / sigma);
-  else
-    cdf(k) = stdnormal_cdf ((log (x(k)) - mu(k)) ./ sigma(k));
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 1 e Inf];
-%! y = [0, 0, 0.5, 1/2+1/2*erf(1/2), 1];
-%!assert (logncdf (x, zeros (1,5), sqrt(2)*ones (1,5)), y, eps)
-%!assert (logncdf (x, 0, sqrt(2)*ones (1,5)), y, eps)
-%!assert (logncdf (x, zeros (1,5), sqrt(2)), y, eps)
-%!assert (logncdf (x, [0 1 NaN 0 1], sqrt(2)), [0 0 NaN y(4:5)], eps)
-%!assert (logncdf (x, 0, sqrt(2)*[0 NaN Inf 1 1]), [NaN NaN NaN y(4:5)], eps)
-%!assert (logncdf ([x(1:3) NaN x(5)], 0, sqrt(2)), [y(1:3) NaN y(5)], eps)
-
-## Test class of input preserved
-%!assert (logncdf ([x, NaN], 0, sqrt(2)), [y, NaN], eps)
-%!assert (logncdf (single ([x, NaN]), 0, sqrt(2)), single ([y, NaN]), eps ("single"))
-%!assert (logncdf ([x, NaN], single (0), sqrt(2)), single ([y, NaN]), eps ("single"))
-%!assert (logncdf ([x, NaN], 0, single (sqrt(2))), single ([y, NaN]), eps ("single"))
-
-## Test input validation
-%!error logncdf ()
-%!error logncdf (1,2)
-%!error logncdf (1,2,3,4)
-%!error logncdf (ones (3), ones (2), ones (2))
-%!error logncdf (ones (2), ones (3), ones (2))
-%!error logncdf (ones (2), ones (2), ones (3))
-%!error logncdf (i, 2, 2)
-%!error logncdf (2, i, 2)
-%!error logncdf (2, 2, i)
diff --git a/scripts/statistics/distributions/logninv.m b/scripts/statistics/distributions/logninv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/logninv.m
+++ /dev/null
@@ -1,99 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} logninv (@var{x})
-## @deftypefnx {} {} logninv (@var{x}, @var{mu}, @var{sigma})
-## For each element of @var{x}, compute the quantile (the inverse of the CDF)
-## at @var{x} of the lognormal distribution with parameters
-## @var{mu} and @var{sigma}.
-##
-## If a random variable follows this distribution, its logarithm is normally
-## distributed with mean @var{mu} and standard deviation @var{sigma}.
-##
-## Default values are @var{mu} = 0, @var{sigma} = 1.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Quantile function of the log normal distribution
-
-function inv = logninv (x, mu = 0, sigma = 1)
-
-  if (nargin != 1 && nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (mu) || ! isscalar (sigma))
-    [retval, x, mu, sigma] = common_size (x, mu, sigma);
-    if (retval > 0)
-      error ("logninv: X, MU, and SIGMA must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (mu) || iscomplex (sigma))
-    error ("logninv: X, MU, and SIGMA must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (mu, "single") || isa (sigma, "single"))
-    inv = NaN (size (x), "single");
-  else
-    inv = NaN (size (x));
-  endif
-
-  k = !(x >= 0) | !(x <= 1) | !(sigma > 0) | !(sigma < Inf);
-  inv(k) = NaN;
-
-  k = (x == 1) & (sigma > 0) & (sigma < Inf);
-  inv(k) = Inf;
-
-  k = (x >= 0) & (x < 1) & (sigma > 0) & (sigma < Inf);
-  if (isscalar (mu) && isscalar (sigma))
-    inv(k) = exp (mu) .* exp (sigma .* stdnormal_inv (x(k)));
-  else
-    inv(k) = exp (mu(k)) .* exp (sigma(k) .* stdnormal_inv (x(k)));
-  endif
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 0.5 1 2];
-%!assert (logninv (x, ones (1,5), ones (1,5)), [NaN 0 e Inf NaN])
-%!assert (logninv (x, 1, ones (1,5)), [NaN 0 e Inf NaN])
-%!assert (logninv (x, ones (1,5), 1), [NaN 0 e Inf NaN])
-%!assert (logninv (x, [1 1 NaN 0 1], 1), [NaN 0 NaN Inf NaN])
-%!assert (logninv (x, 1, [1 0 NaN Inf 1]), [NaN NaN NaN NaN NaN])
-%!assert (logninv ([x(1:2) NaN x(4:5)], 1, 2), [NaN 0 NaN Inf NaN])
-
-## Test class of input preserved
-%!assert (logninv ([x, NaN], 1, 1), [NaN 0 e Inf NaN NaN])
-%!assert (logninv (single ([x, NaN]), 1, 1), single ([NaN 0 e Inf NaN NaN]))
-%!assert (logninv ([x, NaN], single (1), 1), single ([NaN 0 e Inf NaN NaN]))
-%!assert (logninv ([x, NaN], 1, single (1)), single ([NaN 0 e Inf NaN NaN]))
-
-## Test input validation
-%!error logninv ()
-%!error logninv (1,2)
-%!error logninv (1,2,3,4)
-%!error logninv (ones (3), ones (2), ones (2))
-%!error logninv (ones (2), ones (3), ones (2))
-%!error logninv (ones (2), ones (2), ones (3))
-%!error logninv (i, 2, 2)
-%!error logninv (2, i, 2)
-%!error logninv (2, 2, i)
diff --git a/scripts/statistics/distributions/lognpdf.m b/scripts/statistics/distributions/lognpdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/lognpdf.m
+++ /dev/null
@@ -1,96 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} lognpdf (@var{x})
-## @deftypefnx {} {} lognpdf (@var{x}, @var{mu}, @var{sigma})
-## For each element of @var{x}, compute the probability density function (PDF)
-## at @var{x} of the lognormal distribution with parameters
-## @var{mu} and @var{sigma}.
-##
-## If a random variable follows this distribution, its logarithm is normally
-## distributed with mean @var{mu} and standard deviation @var{sigma}.
-##
-## Default values are @var{mu} = 0, @var{sigma} = 1.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: PDF of the log normal distribution
-
-function pdf = lognpdf (x, mu = 0, sigma = 1)
-
-  if (nargin != 1 && nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (mu) || ! isscalar (sigma))
-    [retval, x, mu, sigma] = common_size (x, mu, sigma);
-    if (retval > 0)
-      error ("lognpdf: X, MU, and SIGMA must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (mu) || iscomplex (sigma))
-    error ("lognpdf: X, MU, and SIGMA must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (mu, "single") || isa (sigma, "single"))
-    pdf = zeros (size (x), "single");
-  else
-    pdf = zeros (size (x));
-  endif
-
-  k = isnan (x) | !(sigma > 0) | !(sigma < Inf);
-  pdf(k) = NaN;
-
-  k = (x > 0) & (x < Inf) & (sigma > 0) & (sigma < Inf);
-  if (isscalar (mu) && isscalar (sigma))
-    pdf(k) = normpdf (log (x(k)), mu, sigma) ./ x(k);
-  else
-    pdf(k) = normpdf (log (x(k)), mu(k), sigma(k)) ./ x(k);
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 e Inf];
-%! y = [0, 0, 1/(e*sqrt(2*pi)) * exp(-1/2), 0];
-%!assert (lognpdf (x, zeros (1,4), ones (1,4)), y, eps)
-%!assert (lognpdf (x, 0, ones (1,4)), y, eps)
-%!assert (lognpdf (x, zeros (1,4), 1), y, eps)
-%!assert (lognpdf (x, [0 1 NaN 0], 1), [0 0 NaN y(4)], eps)
-%!assert (lognpdf (x, 0, [0 NaN Inf 1]), [NaN NaN NaN y(4)], eps)
-%!assert (lognpdf ([x, NaN], 0, 1), [y, NaN], eps)
-
-## Test class of input preserved
-%!assert (lognpdf (single ([x, NaN]), 0, 1), single ([y, NaN]), eps ("single"))
-%!assert (lognpdf ([x, NaN], single (0), 1), single ([y, NaN]), eps ("single"))
-%!assert (lognpdf ([x, NaN], 0, single (1)), single ([y, NaN]), eps ("single"))
-
-## Test input validation
-%!error lognpdf ()
-%!error lognpdf (1,2)
-%!error lognpdf (1,2,3,4)
-%!error lognpdf (ones (3), ones (2), ones (2))
-%!error lognpdf (ones (2), ones (3), ones (2))
-%!error lognpdf (ones (2), ones (2), ones (3))
-%!error lognpdf (i, 2, 2)
-%!error lognpdf (2, i, 2)
-%!error lognpdf (2, 2, i)
diff --git a/scripts/statistics/distributions/lognrnd.m b/scripts/statistics/distributions/lognrnd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/lognrnd.m
+++ /dev/null
@@ -1,131 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} lognrnd (@var{mu}, @var{sigma})
-## @deftypefnx {} {} lognrnd (@var{mu}, @var{sigma}, @var{r})
-## @deftypefnx {} {} lognrnd (@var{mu}, @var{sigma}, @var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} lognrnd (@var{mu}, @var{sigma}, [@var{sz}])
-## Return a matrix of random samples from the lognormal distribution with
-## parameters @var{mu} and @var{sigma}.
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-##
-## If no size arguments are given then the result matrix is the common size of
-## @var{mu} and @var{sigma}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Random deviates from the log normal distribution
-
-function rnd = lognrnd (mu, sigma, varargin)
-
-  if (nargin < 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (mu) || ! isscalar (sigma))
-    [retval, mu, sigma] = common_size (mu, sigma);
-    if (retval > 0)
-      error ("lognrnd: MU and SIGMA must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (mu) || iscomplex (sigma))
-    error ("lognrnd: MU and SIGMA must not be complex");
-  endif
-
-  if (nargin == 2)
-    sz = size (mu);
-  elseif (nargin == 3)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1};
-    else
-      error ("lognrnd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 3)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("lognrnd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  if (! isscalar (mu) && ! isequal (size (mu), sz))
-    error ("lognrnd: MU and SIGMA must be scalar or of size SZ");
-  endif
-
-  if (isa (mu, "single") || isa (sigma, "single"))
-    cls = "single";
-  else
-    cls = "double";
-  endif
-
-  if (isscalar (mu) && isscalar (sigma))
-    if ((sigma > 0) && (sigma < Inf))
-      rnd = exp (mu + sigma * randn (sz, cls));
-    else
-      rnd = NaN (sz, cls);
-    endif
-  else
-    rnd = exp (mu + sigma .* randn (sz, cls));
-
-    k = (sigma < 0) | (sigma == Inf);
-    rnd(k) = NaN;
-  endif
-
-endfunction
-
-
-%!assert (size (lognrnd (1,2)), [1, 1])
-%!assert (size (lognrnd (ones (2,1), 2)), [2, 1])
-%!assert (size (lognrnd (ones (2,2), 2)), [2, 2])
-%!assert (size (lognrnd (1, 2*ones (2,1))), [2, 1])
-%!assert (size (lognrnd (1, 2*ones (2,2))), [2, 2])
-%!assert (size (lognrnd (1, 2, 3)), [3, 3])
-%!assert (size (lognrnd (1, 2, [4 1])), [4, 1])
-%!assert (size (lognrnd (1, 2, 4, 1)), [4, 1])
-
-## Test class of input preserved
-%!assert (class (lognrnd (1, 2)), "double")
-%!assert (class (lognrnd (single (1), 2)), "single")
-%!assert (class (lognrnd (single ([1 1]), 2)), "single")
-%!assert (class (lognrnd (1, single (2))), "single")
-%!assert (class (lognrnd (1, single ([2 2]))), "single")
-
-## Test input validation
-%!error lognrnd ()
-%!error lognrnd (1)
-%!error lognrnd (ones (3), ones (2))
-%!error lognrnd (ones (2), ones (3))
-%!error lognrnd (i, 2)
-%!error lognrnd (2, i)
-%!error lognrnd (1,2, -1)
-%!error lognrnd (1,2, ones (2))
-%!error lognrnd (1, 2, [2 -1 2])
-%!error lognrnd (1,2, 1, ones (2))
-%!error lognrnd (1,2, 1, -1)
-%!error lognrnd (ones (2,2), 2, 3)
-%!error lognrnd (ones (2,2), 2, [3, 2])
-%!error lognrnd (ones (2,2), 2, 2, 3)
diff --git a/scripts/statistics/distributions/module.mk b/scripts/statistics/distributions/module.mk
deleted file mode 100644
--- a/scripts/statistics/distributions/module.mk
+++ /dev/null
@@ -1,103 +0,0 @@
-FCN_FILE_DIRS += scripts/statistics/distributions
-
-%canon_reldir%_FCN_FILES = \
-  %reldir%/betacdf.m \
-  %reldir%/betainv.m \
-  %reldir%/betapdf.m \
-  %reldir%/betarnd.m \
-  %reldir%/binocdf.m \
-  %reldir%/binoinv.m \
-  %reldir%/binopdf.m \
-  %reldir%/binornd.m \
-  %reldir%/cauchy_cdf.m \
-  %reldir%/cauchy_inv.m \
-  %reldir%/cauchy_pdf.m \
-  %reldir%/cauchy_rnd.m \
-  %reldir%/chi2cdf.m \
-  %reldir%/chi2inv.m \
-  %reldir%/chi2pdf.m \
-  %reldir%/chi2rnd.m \
-  %reldir%/discrete_cdf.m \
-  %reldir%/discrete_inv.m \
-  %reldir%/discrete_pdf.m \
-  %reldir%/discrete_rnd.m \
-  %reldir%/empirical_cdf.m \
-  %reldir%/empirical_inv.m \
-  %reldir%/empirical_pdf.m \
-  %reldir%/empirical_rnd.m \
-  %reldir%/expcdf.m \
-  %reldir%/expinv.m \
-  %reldir%/exppdf.m \
-  %reldir%/exprnd.m \
-  %reldir%/fcdf.m \
-  %reldir%/finv.m \
-  %reldir%/fpdf.m \
-  %reldir%/frnd.m \
-  %reldir%/gamcdf.m \
-  %reldir%/gaminv.m \
-  %reldir%/gampdf.m \
-  %reldir%/gamrnd.m \
-  %reldir%/geocdf.m \
-  %reldir%/geoinv.m \
-  %reldir%/geopdf.m \
-  %reldir%/geornd.m \
-  %reldir%/hygecdf.m \
-  %reldir%/hygeinv.m \
-  %reldir%/hygepdf.m \
-  %reldir%/hygernd.m \
-  %reldir%/kolmogorov_smirnov_cdf.m \
-  %reldir%/laplace_cdf.m \
-  %reldir%/laplace_inv.m \
-  %reldir%/laplace_pdf.m \
-  %reldir%/laplace_rnd.m \
-  %reldir%/logistic_cdf.m \
-  %reldir%/logistic_inv.m \
-  %reldir%/logistic_pdf.m \
-  %reldir%/logistic_rnd.m \
-  %reldir%/logncdf.m \
-  %reldir%/logninv.m \
-  %reldir%/lognpdf.m \
-  %reldir%/lognrnd.m \
-  %reldir%/nbincdf.m \
-  %reldir%/nbininv.m \
-  %reldir%/nbinpdf.m \
-  %reldir%/nbinrnd.m \
-  %reldir%/normcdf.m \
-  %reldir%/norminv.m \
-  %reldir%/normpdf.m \
-  %reldir%/normrnd.m \
-  %reldir%/poisscdf.m \
-  %reldir%/poissinv.m \
-  %reldir%/poisspdf.m \
-  %reldir%/poissrnd.m \
-  %reldir%/stdnormal_cdf.m \
-  %reldir%/stdnormal_inv.m \
-  %reldir%/stdnormal_pdf.m \
-  %reldir%/stdnormal_rnd.m \
-  %reldir%/tcdf.m \
-  %reldir%/tinv.m \
-  %reldir%/tpdf.m \
-  %reldir%/trnd.m \
-  %reldir%/unidcdf.m \
-  %reldir%/unidinv.m \
-  %reldir%/unidpdf.m \
-  %reldir%/unidrnd.m \
-  %reldir%/unifcdf.m \
-  %reldir%/unifinv.m \
-  %reldir%/unifpdf.m \
-  %reldir%/unifrnd.m \
-  %reldir%/wblcdf.m \
-  %reldir%/wblinv.m \
-  %reldir%/wblpdf.m \
-  %reldir%/wblrnd.m \
-  %reldir%/wienrnd.m
-
-%canon_reldir%dir = $(fcnfiledir)/statistics/distributions
-
-%canon_reldir%_DATA = $(%canon_reldir%_FCN_FILES)
-
-FCN_FILES += $(%canon_reldir%_FCN_FILES)
-
-PKG_ADD_FILES += %reldir%/PKG_ADD
-
-DIRSTAMP_FILES += %reldir%/$(octave_dirstamp)
diff --git a/scripts/statistics/distributions/nbincdf.m b/scripts/statistics/distributions/nbincdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/nbincdf.m
+++ /dev/null
@@ -1,103 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} nbincdf (@var{x}, @var{n}, @var{p})
-## For each element of @var{x}, compute the cumulative distribution function
-## (CDF) at @var{x} of the negative binomial distribution with parameters
-## @var{n} and @var{p}.
-##
-## When @var{n} is integer this is the Pascal distribution.
-## When @var{n} is extended to real numbers this is the Polya distribution.
-##
-## The number of failures in a Bernoulli experiment with success probability
-## @var{p} before the @var{n}-th success follows this distribution.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: CDF of the Pascal (negative binomial) distribution
-
-function cdf = nbincdf (x, n, p)
-
-  if (nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (n) || ! isscalar (p))
-    [retval, x, n, p] = common_size (x, n, p);
-    if (retval > 0)
-      error ("nbincdf: X, N, and P must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (n) || iscomplex (p))
-    error ("nbincdf: X, N, and P must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (n, "single") || isa (p, "single"))
-    cdf = zeros (size (x), "single");
-  else
-    cdf = zeros (size (x));
-  endif
-
-  k = (isnan (x) | isnan (n) | (n < 1) | (n == Inf)
-       | (p < 0) | (p > 1) | isnan (p));
-  cdf(k) = NaN;
-
-  k = (x == Inf) & (n > 0) & (n < Inf) & (p >= 0) & (p <= 1);
-  cdf(k) = 1;
-
-  k = ((x >= 0) & (x < Inf) & (x == fix (x))
-       & (n > 0) & (n < Inf) & (p > 0) & (p <= 1));
-  if (isscalar (n) && isscalar (p))
-    cdf(k) = 1 - betainc (1-p, x(k)+1, n);
-  else
-    cdf(k) = 1 - betainc (1-p(k), x(k)+1, n(k));
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 1 2 Inf];
-%! y = [0 1/2 3/4 7/8 1];
-%!assert (nbincdf (x, ones (1,5), 0.5*ones (1,5)), y)
-%!assert (nbincdf (x, 1, 0.5*ones (1,5)), y)
-%!assert (nbincdf (x, ones (1,5), 0.5), y)
-%!assert (nbincdf ([x(1:3) 0 x(5)], [0 1 NaN 1.5 Inf], 0.5), [NaN 1/2 NaN nbinpdf(0,1.5,0.5) NaN], eps)
-%!assert (nbincdf (x, 1, 0.5*[-1 NaN 4 1 1]), [NaN NaN NaN y(4:5)])
-%!assert (nbincdf ([x(1:2) NaN x(4:5)], 1, 0.5), [y(1:2) NaN y(4:5)])
-
-## Test class of input preserved
-%!assert (nbincdf ([x, NaN], 1, 0.5), [y, NaN])
-%!assert (nbincdf (single ([x, NaN]), 1, 0.5), single ([y, NaN]))
-%!assert (nbincdf ([x, NaN], single (1), 0.5), single ([y, NaN]))
-%!assert (nbincdf ([x, NaN], 1, single (0.5)), single ([y, NaN]))
-
-## Test input validation
-%!error nbincdf ()
-%!error nbincdf (1)
-%!error nbincdf (1,2)
-%!error nbincdf (1,2,3,4)
-%!error nbincdf (ones (3), ones (2), ones (2))
-%!error nbincdf (ones (2), ones (3), ones (2))
-%!error nbincdf (ones (2), ones (2), ones (3))
-%!error nbincdf (i, 2, 2)
-%!error nbincdf (2, i, 2)
-%!error nbincdf (2, 2, i)
diff --git a/scripts/statistics/distributions/nbininv.m b/scripts/statistics/distributions/nbininv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/nbininv.m
+++ /dev/null
@@ -1,170 +0,0 @@
-## Copyright (C) 2016-2017 Lachlan Andrew
-## Copyright (C) 2012-2016 Rik Wehbring
-## Copyright (C) 1995-2012 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} nbininv (@var{x}, @var{n}, @var{p})
-## For each element of @var{x}, compute the quantile (the inverse of the CDF)
-## at @var{x} of the negative binomial distribution with parameters
-## @var{n} and @var{p}.
-##
-## When @var{n} is integer this is the Pascal distribution.
-## When @var{n} is extended to real numbers this is the Polya distribution.
-##
-## The number of failures in a Bernoulli experiment with success probability
-## @var{p} before the @var{n}-th success follows this distribution.
-## @end deftypefn
-
-function inv = nbininv (x, n, p)
-
-  if (nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (n) || ! isscalar (p))
-    [retval, x, n, p] = common_size (x, n, p);
-    if (retval > 0)
-      error ("nbininv: X, N, and P must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (n) || iscomplex (p))
-    error ("nbininv: X, N, and P must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (n, "single") || isa (p, "single"))
-    inv = zeros (size (x), "single");
-  else
-    inv = zeros (size (x));
-  endif
-
-  k = (isnan (x) | (x < 0) | (x > 1) | isnan (n) | (n < 1) | (n == Inf)
-       | isnan (p) | (p < 0) | (p > 1));
-  inv(k) = NaN;
-
-  k = (x == 1) & (n > 0) & (n < Inf) & (p >= 0) & (p <= 1);
-  inv(k) = Inf;
-
-  k = find ((x >= 0) & (x < 1) & (n > 0) & (n < Inf)
-            & (p > 0) & (p <= 1));
-  if (! isempty (k))
-    x = x(k);
-    m = zeros (size (k));
-    if (isscalar (n) && isscalar (p))
-      [m, unfinished] = scalar_nbininv (x(:), n, p);
-      m(unfinished) = bin_search_nbininv (x(unfinished), n, p);
-    else
-      m = bin_search_nbininv (x, n(k), p(k));
-    endif
-    inv(k) = m;
-  endif
-
-endfunction
-
-
-## Core algorithm to calculate the inverse negative binomial, for n and p real
-## scalars and y a column vector, and for which the output is not NaN or Inf.
-## Compute CDF in batches of doubling size until CDF > x, or answer > 500.
-## Return the locations of unfinished cases in k.
-function [m, k] = scalar_nbininv (x, n, p)
-
-  k = 1:length (x);
-  m = zeros (size (x));
-  prev_limit = 0;
-  limit = 10;
-  do
-    cdf = nbincdf (prev_limit:limit, n, p);
-    r = bsxfun (@le, x(k), cdf);
-    [v, m(k)] = max (r, [], 2);     # find first instance of x <= cdf
-    m(k) += prev_limit - 1;
-    k = k(v == 0);
-
-    prev_limit = limit;
-    limit += limit;
-  until (isempty (k) || limit >= 1000)
-
-endfunction
-
-## Vectorized binary search.
-## Can handle vectors n and p, and is faster than the scalar case when the
-## answer is large.
-## Could be optimized to call nbincdf only for a subset of the x at each stage,
-## but care must be taken to handle both scalar and vector n,p.  Bookkeeping
-## may cost more than the extra computations.
-function m = bin_search_nbininv (x, n, p)
-
-  k = 1:length (x);
-  lower = zeros (size (x));
-  limit = 1;
-  while (any (k) && limit < 1e100)
-    cdf = nbincdf (limit, n, p);
-    k = (x > cdf);
-    lower(k) = limit;
-    limit += limit;
-  endwhile
-  upper = max (2*lower, 1);
-  k = find (lower != limit/2);    # elements for which above loop finished
-  for i = 1:ceil (log2 (max (lower)))
-    mid = (upper + lower)/2;
-    cdf = nbincdf (floor (mid), n, p);
-    r = (x <= cdf);
-    upper(r)  = mid(r);
-    lower(! r) = mid(! r);
-  endfor
-  m = ceil (lower);
-  m(x > nbincdf (m, n, p)) += 1;  # fix off-by-one errors from binary search
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 3/4 1 2];
-%!assert (nbininv (x, ones (1,5), 0.5*ones (1,5)), [NaN 0 1 Inf NaN])
-%!assert (nbininv (x, 1, 0.5*ones (1,5)), [NaN 0 1 Inf NaN])
-%!assert (nbininv (x, ones (1,5), 0.5), [NaN 0 1 Inf NaN])
-%!assert (nbininv (x, [1 0 NaN Inf 1], 0.5), [NaN NaN NaN NaN NaN])
-%!assert (nbininv (x, [1 0 1.5 Inf 1], 0.5), [NaN NaN 2 NaN NaN])
-%!assert (nbininv (x, 1, 0.5*[1 -Inf NaN Inf 1]), [NaN NaN NaN NaN NaN])
-%!assert (nbininv ([x(1:2) NaN x(4:5)], 1, 0.5), [NaN 0 NaN Inf NaN])
-
-## Test class of input preserved
-%!assert (nbininv ([x, NaN], 1, 0.5), [NaN 0 1 Inf NaN NaN])
-%!assert (nbininv (single ([x, NaN]), 1, 0.5), single ([NaN 0 1 Inf NaN NaN]))
-%!assert (nbininv ([x, NaN], single (1), 0.5), single ([NaN 0 1 Inf NaN NaN]))
-%!assert (nbininv ([x, NaN], 1, single (0.5)), single ([NaN 0 1 Inf NaN NaN]))
-
-## Test accuracy, to within +/- 1 since it is a discrete distribution
-%!shared y, tol
-%! y = magic (3) + 1;
-%! tol = 1;
-%!assert (nbininv (nbincdf (1:10, 3, 0.1), 3, 0.1), 1:10, tol)
-%!assert (nbininv (nbincdf (1:10, 3./(1:10), 0.1), 3./(1:10), 0.1), 1:10, tol)
-%!assert (nbininv (nbincdf (y, 3./y, 1./y), 3./y, 1./y), y, tol)
-
-## Test input validation
-%!error nbininv ()
-%!error nbininv (1)
-%!error nbininv (1,2)
-%!error nbininv (1,2,3,4)
-%!error nbininv (ones (3), ones (2), ones (2))
-%!error nbininv (ones (2), ones (3), ones (2))
-%!error nbininv (ones (2), ones (2), ones (3))
-%!error nbininv (i, 2, 2)
-%!error nbininv (2, i, 2)
-%!error nbininv (2, 2, i)
diff --git a/scripts/statistics/distributions/nbinpdf.m b/scripts/statistics/distributions/nbinpdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/nbinpdf.m
+++ /dev/null
@@ -1,100 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} nbinpdf (@var{x}, @var{n}, @var{p})
-## For each element of @var{x}, compute the probability density function (PDF)
-## at @var{x} of the negative binomial distribution with parameters
-## @var{n} and @var{p}.
-##
-## When @var{n} is integer this is the Pascal distribution.
-## When @var{n} is extended to real numbers this is the Polya distribution.
-##
-## The number of failures in a Bernoulli experiment with success probability
-## @var{p} before the @var{n}-th success follows this distribution.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: PDF of the Pascal (negative binomial) distribution
-
-function pdf = nbinpdf (x, n, p)
-
-  if (nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (n) || ! isscalar (p))
-    [retval, x, n, p] = common_size (x, n, p);
-    if (retval > 0)
-      error ("nbinpdf: X, N, and P must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (n) || iscomplex (p))
-    error ("nbinpdf: X, N, and P must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (n, "single") || isa (p, "single"))
-    pdf = NaN (size (x), "single");
-  else
-    pdf = NaN (size (x));
-  endif
-
-  ok = (x < Inf) & (x == fix (x)) & (n > 0) & (n < Inf) & (p >= 0) & (p <= 1);
-
-  k = (x < 0) & ok;
-  pdf(k) = 0;
-
-  k = (x >= 0) & ok;
-  if (isscalar (n) && isscalar (p))
-    pdf(k) = bincoeff (-n, x(k)) .* (p ^ n) .* ((p - 1) .^ x(k));
-  else
-    pdf(k) = bincoeff (-n(k), x(k)) .* (p(k) .^ n(k)) .* ((p(k) - 1) .^ x(k));
-  endif
-
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 1 2 Inf];
-%! y = [0 1/2 1/4 1/8 NaN];
-%!assert (nbinpdf (x, ones (1,5), 0.5*ones (1,5)), y)
-%!assert (nbinpdf (x, 1, 0.5*ones (1,5)), y)
-%!assert (nbinpdf (x, ones (1,5), 0.5), y)
-%!assert (nbinpdf (x, [0 1 NaN 1.5 Inf], 0.5), [NaN 1/2 NaN 1.875*0.5^1.5/4 NaN], eps)
-%!assert (nbinpdf (x, 1, 0.5*[-1 NaN 4 1 1]), [NaN NaN NaN y(4:5)])
-%!assert (nbinpdf ([x, NaN], 1, 0.5), [y, NaN])
-
-## Test class of input preserved
-%!assert (nbinpdf (single ([x, NaN]), 1, 0.5), single ([y, NaN]))
-%!assert (nbinpdf ([x, NaN], single (1), 0.5), single ([y, NaN]))
-%!assert (nbinpdf ([x, NaN], 1, single (0.5)), single ([y, NaN]))
-
-## Test input validation
-%!error nbinpdf ()
-%!error nbinpdf (1)
-%!error nbinpdf (1,2)
-%!error nbinpdf (1,2,3,4)
-%!error nbinpdf (ones (3), ones (2), ones (2))
-%!error nbinpdf (ones (2), ones (3), ones (2))
-%!error nbinpdf (ones (2), ones (2), ones (3))
-%!error nbinpdf (i, 2, 2)
-%!error nbinpdf (2, i, 2)
-%!error nbinpdf (2, 2, i)
diff --git a/scripts/statistics/distributions/nbinrnd.m b/scripts/statistics/distributions/nbinrnd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/nbinrnd.m
+++ /dev/null
@@ -1,136 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} nbinrnd (@var{n}, @var{p})
-## @deftypefnx {} {} nbinrnd (@var{n}, @var{p}, @var{r})
-## @deftypefnx {} {} nbinrnd (@var{n}, @var{p}, @var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} nbinrnd (@var{n}, @var{p}, [@var{sz}])
-## Return a matrix of random samples from the negative binomial distribution
-## with parameters @var{n} and @var{p}.
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-##
-## If no size arguments are given then the result matrix is the common size of
-## @var{n} and @var{p}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Random deviates from the Pascal distribution
-
-function rnd = nbinrnd (n, p, varargin)
-
-  if (nargin < 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (n) || ! isscalar (p))
-    [retval, n, p] = common_size (n, p);
-    if (retval > 0)
-      error ("nbinrnd: N and P must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (n) || iscomplex (p))
-    error ("nbinrnd: N and P must not be complex");
-  endif
-
-  if (nargin == 2)
-    sz = size (n);
-  elseif (nargin == 3)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1};
-    else
-      error ("nbinrnd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 3)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("nbinrnd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  if (! isscalar (n) && ! isequal (size (n), sz))
-    error ("nbinrnd: N and P must be scalar or of size SZ");
-  endif
-
-  if (isa (n, "single") || isa (p, "single"))
-    cls = "single";
-  else
-    cls = "double";
-  endif
-
-  if (isscalar (n) && isscalar (p))
-    if ((n > 0) && (n < Inf) && (p > 0) && (p <= 1))
-      rnd = randp ((1 - p) ./ p .* randg (n, sz, cls), cls);
-    elseif ((n > 0) && (n < Inf) && (p == 0))
-      rnd = zeros (sz, cls);
-    else
-      rnd = NaN (sz, cls);
-    endif
-  else
-    rnd = NaN (sz, cls);
-
-    k = (n > 0) & (n < Inf) & (p == 0);
-    rnd(k) = 0;
-
-    k = (n > 0) & (n < Inf) & (p > 0) & (p <= 1);
-    rnd(k) = randp ((1 - p(k)) ./ p(k) .* randg (n(k), cls));
-  endif
-
-endfunction
-
-
-%!assert (size (nbinrnd (2, 1/2)), [1, 1])
-%!assert (size (nbinrnd (2*ones (2,1), 1/2)), [2, 1])
-%!assert (size (nbinrnd (2*ones (2,2), 1/2)), [2, 2])
-%!assert (size (nbinrnd (2, 1/2*ones (2,1))), [2, 1])
-%!assert (size (nbinrnd (2, 1/2*ones (2,2))), [2, 2])
-%!assert (size (nbinrnd (2, 1/2, 3)), [3, 3])
-%!assert (size (nbinrnd (2, 1/2, [4 1])), [4, 1])
-%!assert (size (nbinrnd (2, 1/2, 4, 1)), [4, 1])
-
-## Test class of input preserved
-%!assert (class (nbinrnd (2, 1/2)), "double")
-%!assert (class (nbinrnd (single (2), 1/2)), "single")
-%!assert (class (nbinrnd (single ([2 2]), 1/2)), "single")
-%!assert (class (nbinrnd (2, single (1/2))), "single")
-%!assert (class (nbinrnd (2, single ([1/2 1/2]))), "single")
-
-## Test input validation
-%!error nbinrnd ()
-%!error nbinrnd (1)
-%!error nbinrnd (ones (3), ones (2))
-%!error nbinrnd (ones (2), ones (3))
-%!error nbinrnd (i, 2)
-%!error nbinrnd (2, i)
-%!error nbinrnd (1,2, -1)
-%!error nbinrnd (1,2, ones (2))
-%!error nbinrnd (1, 2, [2 -1 2])
-%!error nbinrnd (1,2, 1, ones (2))
-%!error nbinrnd (1,2, 1, -1)
-%!error nbinrnd (ones (2,2), 2, 3)
-%!error nbinrnd (ones (2,2), 2, [3, 2])
-%!error nbinrnd (ones (2,2), 2, 2, 3)
diff --git a/scripts/statistics/distributions/normcdf.m b/scripts/statistics/distributions/normcdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/normcdf.m
+++ /dev/null
@@ -1,98 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} normcdf (@var{x})
-## @deftypefnx {} {} normcdf (@var{x}, @var{mu}, @var{sigma})
-## For each element of @var{x}, compute the cumulative distribution function
-## (CDF) at @var{x} of the normal distribution with mean @var{mu} and
-## standard deviation @var{sigma}.
-##
-## Default values are @var{mu} = 0, @var{sigma} = 1.
-## @end deftypefn
-
-## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
-## Description: CDF of the normal distribution
-
-function cdf = normcdf (x, mu = 0, sigma = 1)
-
-  if (nargin != 1 && nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (mu) || ! isscalar (sigma))
-    [retval, x, mu, sigma] = common_size (x, mu, sigma);
-    if (retval > 0)
-      error ("normcdf: X, MU, and SIGMA must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (mu) || iscomplex (sigma))
-    error ("normcdf: X, MU, and SIGMA must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (mu, "single") || isa (sigma, "single"));
-    cdf = zeros (size (x), "single");
-  else
-    cdf = zeros (size (x));
-  endif
-
-  if (isscalar (mu) && isscalar (sigma))
-    if (isfinite (mu) && (sigma > 0) && (sigma < Inf))
-      cdf = stdnormal_cdf ((x - mu) / sigma);
-    else
-      cdf = NaN (size (x), class (cdf));
-    endif
-  else
-    k = ! isfinite (mu) | !(sigma > 0) | !(sigma < Inf);
-    cdf(k) = NaN;
-
-    k = ! k;
-    cdf(k) = stdnormal_cdf ((x(k) - mu(k)) ./ sigma(k));
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-Inf 1 2 Inf];
-%! y = [0, 0.5, 1/2*(1+erf(1/sqrt(2))), 1];
-%!assert (normcdf (x, ones (1,4), ones (1,4)), y)
-%!assert (normcdf (x, 1, ones (1,4)), y)
-%!assert (normcdf (x, ones (1,4), 1), y)
-%!assert (normcdf (x, [0 -Inf NaN Inf], 1), [y(1) NaN NaN NaN])
-%!assert (normcdf (x, 1, [Inf NaN -1 0]), [NaN NaN NaN NaN])
-%!assert (normcdf ([x(1:2) NaN x(4)], 1, 1), [y(1:2) NaN y(4)])
-
-## Test class of input preserved
-%!assert (normcdf ([x, NaN], 1, 1), [y, NaN])
-%!assert (normcdf (single ([x, NaN]), 1, 1), single ([y, NaN]), eps ("single"))
-%!assert (normcdf ([x, NaN], single (1), 1), single ([y, NaN]), eps ("single"))
-%!assert (normcdf ([x, NaN], 1, single (1)), single ([y, NaN]), eps ("single"))
-
-## Test input validation
-%!error normcdf ()
-%!error normcdf (1,2)
-%!error normcdf (1,2,3,4)
-%!error normcdf (ones (3), ones (2), ones (2))
-%!error normcdf (ones (2), ones (3), ones (2))
-%!error normcdf (ones (2), ones (2), ones (3))
-%!error normcdf (i, 2, 2)
-%!error normcdf (2, i, 2)
-%!error normcdf (2, 2, i)
diff --git a/scripts/statistics/distributions/norminv.m b/scripts/statistics/distributions/norminv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/norminv.m
+++ /dev/null
@@ -1,92 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} norminv (@var{x})
-## @deftypefnx {} {} norminv (@var{x}, @var{mu}, @var{sigma})
-## For each element of @var{x}, compute the quantile (the inverse of the CDF)
-## at @var{x} of the normal distribution with mean @var{mu} and
-## standard deviation @var{sigma}.
-##
-## Default values are @var{mu} = 0, @var{sigma} = 1.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Quantile function of the normal distribution
-
-function inv = norminv (x, mu = 0, sigma = 1)
-
-  if (nargin != 1 && nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (mu) || ! isscalar (sigma))
-    [retval, x, mu, sigma] = common_size (x, mu, sigma);
-    if (retval > 0)
-      error ("norminv: X, MU, and SIGMA must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (mu) || iscomplex (sigma))
-    error ("norminv: X, MU, and SIGMA must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (mu, "single") || isa (sigma, "single"))
-    inv = NaN (size (x), "single");
-  else
-    inv = NaN (size (x));
-  endif
-
-  if (isscalar (mu) && isscalar (sigma))
-    if (isfinite (mu) && (sigma > 0) && (sigma < Inf))
-      inv = mu + sigma * stdnormal_inv (x);
-    endif
-  else
-    k = isfinite (mu) & (sigma > 0) & (sigma < Inf);
-    inv(k) = mu(k) + sigma(k) .* stdnormal_inv (x(k));
-  endif
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 0.5 1 2];
-%!assert (norminv (x, ones (1,5), ones (1,5)), [NaN -Inf 1 Inf NaN])
-%!assert (norminv (x, 1, ones (1,5)), [NaN -Inf 1 Inf NaN])
-%!assert (norminv (x, ones (1,5), 1), [NaN -Inf 1 Inf NaN])
-%!assert (norminv (x, [1 -Inf NaN Inf 1], 1), [NaN NaN NaN NaN NaN])
-%!assert (norminv (x, 1, [1 0 NaN Inf 1]), [NaN NaN NaN NaN NaN])
-%!assert (norminv ([x(1:2) NaN x(4:5)], 1, 1), [NaN -Inf NaN Inf NaN])
-
-## Test class of input preserved
-%!assert (norminv ([x, NaN], 1, 1), [NaN -Inf 1 Inf NaN NaN])
-%!assert (norminv (single ([x, NaN]), 1, 1), single ([NaN -Inf 1 Inf NaN NaN]))
-%!assert (norminv ([x, NaN], single (1), 1), single ([NaN -Inf 1 Inf NaN NaN]))
-%!assert (norminv ([x, NaN], 1, single (1)), single ([NaN -Inf 1 Inf NaN NaN]))
-
-## Test input validation
-%!error norminv ()
-%!error norminv (1,2)
-%!error norminv (1,2,3,4)
-%!error norminv (ones (3), ones (2), ones (2))
-%!error norminv (ones (2), ones (3), ones (2))
-%!error norminv (ones (2), ones (2), ones (3))
-%!error norminv (i, 2, 2)
-%!error norminv (2, i, 2)
-%!error norminv (2, 2, i)
diff --git a/scripts/statistics/distributions/normpdf.m b/scripts/statistics/distributions/normpdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/normpdf.m
+++ /dev/null
@@ -1,97 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} normpdf (@var{x})
-## @deftypefnx {} {} normpdf (@var{x}, @var{mu}, @var{sigma})
-## For each element of @var{x}, compute the probability density function (PDF)
-## at @var{x} of the normal distribution with mean @var{mu} and
-## standard deviation @var{sigma}.
-##
-## Default values are @var{mu} = 0, @var{sigma} = 1.
-## @end deftypefn
-
-## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
-## Description: PDF of the normal distribution
-
-function pdf = normpdf (x, mu = 0, sigma = 1)
-
-  if (nargin != 1 && nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (mu) || ! isscalar (sigma))
-    [retval, x, mu, sigma] = common_size (x, mu, sigma);
-    if (retval > 0)
-      error ("normpdf: X, MU, and SIGMA must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (mu) || iscomplex (sigma))
-    error ("normpdf: X, MU, and SIGMA must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (mu, "single") || isa (sigma, "single"))
-    pdf = zeros (size (x), "single");
-  else
-    pdf = zeros (size (x));
-  endif
-
-  if (isscalar (mu) && isscalar (sigma))
-    if (isfinite (mu) && (sigma > 0) && (sigma < Inf))
-      pdf = stdnormal_pdf ((x - mu) / sigma) / sigma;
-    else
-      pdf = NaN (size (x), class (pdf));
-    endif
-  else
-    k = isinf (mu) | !(sigma > 0) | !(sigma < Inf);
-    pdf(k) = NaN;
-
-    k = ! isinf (mu) & (sigma > 0) & (sigma < Inf);
-    pdf(k) = stdnormal_pdf ((x(k) - mu(k)) ./ sigma(k)) ./ sigma(k);
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-Inf 1 2 Inf];
-%! y = 1/sqrt(2*pi)*exp (-(x-1).^2/2);
-%!assert (normpdf (x, ones (1,4), ones (1,4)), y)
-%!assert (normpdf (x, 1, ones (1,4)), y)
-%!assert (normpdf (x, ones (1,4), 1), y)
-%!assert (normpdf (x, [0 -Inf NaN Inf], 1), [y(1) NaN NaN NaN])
-%!assert (normpdf (x, 1, [Inf NaN -1 0]), [NaN NaN NaN NaN])
-%!assert (normpdf ([x, NaN], 1, 1), [y, NaN])
-
-## Test class of input preserved
-%!assert (normpdf (single ([x, NaN]), 1, 1), single ([y, NaN]), eps ("single"))
-%!assert (normpdf ([x, NaN], single (1), 1), single ([y, NaN]), eps ("single"))
-%!assert (normpdf ([x, NaN], 1, single (1)), single ([y, NaN]), eps ("single"))
-
-## Test input validation
-%!error normpdf ()
-%!error normpdf (1,2)
-%!error normpdf (1,2,3,4)
-%!error normpdf (ones (3), ones (2), ones (2))
-%!error normpdf (ones (2), ones (3), ones (2))
-%!error normpdf (ones (2), ones (2), ones (3))
-%!error normpdf (i, 2, 2)
-%!error normpdf (2, i, 2)
-%!error normpdf (2, 2, i)
diff --git a/scripts/statistics/distributions/normrnd.m b/scripts/statistics/distributions/normrnd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/normrnd.m
+++ /dev/null
@@ -1,130 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} normrnd (@var{mu}, @var{sigma})
-## @deftypefnx {} {} normrnd (@var{mu}, @var{sigma}, @var{r})
-## @deftypefnx {} {} normrnd (@var{mu}, @var{sigma}, @var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} normrnd (@var{mu}, @var{sigma}, [@var{sz}])
-## Return a matrix of random samples from the normal distribution with
-## parameters mean @var{mu} and standard deviation @var{sigma}.
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-##
-## If no size arguments are given then the result matrix is the common size of
-## @var{mu} and @var{sigma}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Random deviates from the normal distribution
-
-function rnd = normrnd (mu, sigma, varargin)
-
-  if (nargin < 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (mu) || ! isscalar (sigma))
-    [retval, mu, sigma] = common_size (mu, sigma);
-    if (retval > 0)
-      error ("normrnd: MU and SIGMA must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (mu) || iscomplex (sigma))
-    error ("normrnd: MU and SIGMA must not be complex");
-  endif
-
-  if (nargin == 2)
-    sz = size (mu);
-  elseif (nargin == 3)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1};
-    else
-      error ("normrnd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 3)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("normrnd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  if (! isscalar (mu) && ! isequal (size (mu), sz))
-    error ("normrnd: MU and SIGMA must be scalar or of size SZ");
-  endif
-
-  if (isa (mu, "single") || isa (sigma, "single"))
-    cls = "single";
-  else
-    cls = "double";
-  endif
-
-  if (isscalar (mu) && isscalar (sigma))
-    if (isfinite (mu) && (sigma >= 0) && (sigma < Inf))
-      rnd = mu + sigma * randn (sz, cls);
-    else
-      rnd = NaN (sz, cls);
-    endif
-  else
-    rnd = mu + sigma .* randn (sz, cls);
-    k = ! isfinite (mu) | !(sigma >= 0) | !(sigma < Inf);
-    rnd(k) = NaN;
-  endif
-
-endfunction
-
-
-%!assert (size (normrnd (1,2)), [1, 1])
-%!assert (size (normrnd (ones (2,1), 2)), [2, 1])
-%!assert (size (normrnd (ones (2,2), 2)), [2, 2])
-%!assert (size (normrnd (1, 2*ones (2,1))), [2, 1])
-%!assert (size (normrnd (1, 2*ones (2,2))), [2, 2])
-%!assert (size (normrnd (1, 2, 3)), [3, 3])
-%!assert (size (normrnd (1, 2, [4 1])), [4, 1])
-%!assert (size (normrnd (1, 2, 4, 1)), [4, 1])
-
-## Test class of input preserved
-%!assert (class (normrnd (1, 2)), "double")
-%!assert (class (normrnd (single (1), 2)), "single")
-%!assert (class (normrnd (single ([1 1]), 2)), "single")
-%!assert (class (normrnd (1, single (2))), "single")
-%!assert (class (normrnd (1, single ([2 2]))), "single")
-
-## Test input validation
-%!error normrnd ()
-%!error normrnd (1)
-%!error normrnd (ones (3), ones (2))
-%!error normrnd (ones (2), ones (3))
-%!error normrnd (i, 2)
-%!error normrnd (2, i)
-%!error normrnd (1,2, -1)
-%!error normrnd (1,2, ones (2))
-%!error normrnd (1, 2, [2 -1 2])
-%!error normrnd (1,2, 1, ones (2))
-%!error normrnd (1,2, 1, -1)
-%!error normrnd (ones (2,2), 2, 3)
-%!error normrnd (ones (2,2), 2, [3, 2])
-%!error normrnd (ones (2,2), 2, 2, 3)
diff --git a/scripts/statistics/distributions/poisscdf.m b/scripts/statistics/distributions/poisscdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/poisscdf.m
+++ /dev/null
@@ -1,88 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} poisscdf (@var{x}, @var{lambda})
-## For each element of @var{x}, compute the cumulative distribution function
-## (CDF) at @var{x} of the Poisson distribution with parameter @var{lambda}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: CDF of the Poisson distribution
-
-function cdf = poisscdf (x, lambda)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (lambda))
-    [retval, x, lambda] = common_size (x, lambda);
-    if (retval > 0)
-      error ("poisscdf: X and LAMBDA must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (lambda))
-    error ("poisscdf: X and LAMBDA must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (lambda, "single"))
-    cdf = zeros (size (x), "single");
-  else
-    cdf = zeros (size (x));
-  endif
-
-  k = isnan (x) | !(lambda > 0);
-  cdf(k) = NaN;
-
-  k = (x == Inf) & (lambda > 0);
-  cdf(k) = 1;
-
-  k = (x >= 0) & (x < Inf) & (lambda > 0);
-  if (isscalar (lambda))
-    cdf(k) = 1 - gammainc (lambda, floor (x(k)) + 1);
-  else
-    cdf(k) = 1 - gammainc (lambda(k), floor (x(k)) + 1);
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 1 2 Inf];
-%! y = [0, gammainc(1, (x(2:4) +1), "upper"), 1];
-%!assert (poisscdf (x, ones (1,5)), y)
-%!assert (poisscdf (x, 1), y)
-%!assert (poisscdf (x, [1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)])
-%!assert (poisscdf ([x(1:2) NaN Inf x(5)], 1), [y(1:2) NaN 1 y(5)])
-
-## Test class of input preserved
-%!assert (poisscdf ([x, NaN], 1), [y, NaN])
-%!assert (poisscdf (single ([x, NaN]), 1), single ([y, NaN]), eps ("single"))
-%!assert (poisscdf ([x, NaN], single (1)), single ([y, NaN]), eps ("single"))
-
-## Test input validation
-%!error poisscdf ()
-%!error poisscdf (1)
-%!error poisscdf (1,2,3)
-%!error poisscdf (ones (3), ones (2))
-%!error poisscdf (ones (2), ones (3))
-%!error poisscdf (i, 2)
-%!error poisscdf (2, i)
diff --git a/scripts/statistics/distributions/poissinv.m b/scripts/statistics/distributions/poissinv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/poissinv.m
+++ /dev/null
@@ -1,212 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-## Copyright (C) 2016 Lachlan Andrew
-## Copyright (C) 2014 Mike Giles
-## Copyright (C) 2012 Rik Wehbring
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} poissinv (@var{x}, @var{lambda})
-## For each element of @var{x}, compute the quantile (the inverse of the CDF)
-## at @var{x} of the Poisson distribution with parameter @var{lambda}.
-## @end deftypefn
-
-## Author: Lachlan <lachlanbis@gmail.com>
-## based on code by
-##      KH <Kurt.Hornik@wu-wien.ac.at>
-##      Mike Giles <mike.giles@maths.ox.ac.uk>
-## Description: Quantile function of the Poisson distribution
-
-function inv = poissinv (x, lambda)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (lambda))
-    [retval, x, lambda] = common_size (x, lambda);
-    if (retval > 0)
-      error ("poissinv: X and LAMBDA must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (lambda))
-    error ("poissinv: X and LAMBDA must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (lambda, "single"))
-    inv = zeros (size (x), "single");
-  else
-    inv = zeros (size (x));
-  endif
-
-  k = (x < 0) | (x > 1) | isnan (x) | !(lambda > 0);
-  inv(k) = NaN;
-
-  k = (x == 1) & (lambda > 0);
-  inv(k) = Inf;
-
-  k = (x > 0) & (x < 1) & (lambda > 0);
-  if (any (k(:)))
-    limit = 20;                         # After 'limit' iterations, use approx
-    if (isscalar (lambda))
-      cdf = [(cumsum (poisspdf (0:limit-1,lambda))), 2];
-      y = x(:);                         # force to column
-      r = bsxfun (@le, y(k), cdf);
-      [~, inv(k)] = max (r, [], 2);     # find first instance of x <= cdf
-      inv(k) -= 1;
-    else
-      kk = find (k);
-      cdf = exp (-lambda(kk));
-      for i = 1:limit
-        m = find (cdf < x(kk));
-        if (isempty (m))
-          break;
-        else
-          inv(kk(m)) += 1;
-          cdf(m) += poisspdf (i, lambda(kk(m)));
-        endif
-      endfor
-    endif
-
-    ## Use Mike Giles's magic when inv isn't < limit
-    k &= (inv == limit);
-    if (any (k(:)))
-      if (isscalar (lambda))
-        lam = repmat (lambda, size (x));
-      else
-        lam = lambda;
-      endif
-      inv(k) = analytic_approx (x(k), lam(k));
-    endif
-  endif
-
-endfunction
-
-
-## The following is based on Mike Giles's CUDA implementation,
-## [http://people.maths.ox.ac.uk/gilesm/codes/poissinv/poissinv_cuda.h]
-## which is copyright by the University of Oxford
-## and is provided under the terms of the GNU GPLv3 license:
-## http://www.gnu.org/licenses/gpl.html
-
-function inv = analytic_approx (x, lambda)
-
-  s = norminv (x, 0, 1) ./ sqrt (lambda);
-  k = (s > -0.6833501) & (s < 1.777993);
-  ## use polynomial approximations in central region
-  if (any (k))
-    lam = lambda(k);
-    if (isscalar (s))
-      sk = s;
-    else
-      sk = s(k);
-    endif
-
-    ## polynomial approximation to f^{-1}(s) - 1
-    rm =  2.82298751e-07;
-    rm = -2.58136133e-06 + rm.*sk;
-    rm =  1.02118025e-05 + rm.*sk;
-    rm = -2.37996199e-05 + rm.*sk;
-    rm =  4.05347462e-05 + rm.*sk;
-    rm = -6.63730967e-05 + rm.*sk;
-    rm =  0.000124762566 + rm.*sk;
-    rm = -0.000256970731 + rm.*sk;
-    rm =  0.000558953132 + rm.*sk;
-    rm =  -0.00133129194 + rm.*sk;
-    rm =   0.00370367937 + rm.*sk;
-    rm =   -0.0138888706 + rm.*sk;
-    rm =     0.166666667 + rm.*sk;
-    rm =         sk + sk.*(rm.*sk);
-
-    ## polynomial approximation to correction c0(r)
-
-    t  =   1.86386867e-05;
-    t  =  -0.000207319499 + t.*rm;
-    t  =     0.0009689451 + t.*rm;
-    t  =   -0.00247340054 + t.*rm;
-    t  =    0.00379952985 + t.*rm;
-    t  =   -0.00386717047 + t.*rm;
-    t  =    0.00346960934 + t.*rm;
-    t  =   -0.00414125511 + t.*rm;
-    t  =    0.00586752093 + t.*rm;
-    t  =   -0.00838583787 + t.*rm;
-    t  =     0.0132793933 + t.*rm;
-    t  =     -0.027775536 + t.*rm;
-    t  =      0.333333333 + t.*rm;
-
-    ##  O(1/lam) correction
-
-    y  =   -0.00014585224;
-    y  =    0.00146121529 + y.*rm;
-    y  =   -0.00610328845 + y.*rm;
-    y  =     0.0138117964 + y.*rm;
-    y  =    -0.0186988746 + y.*rm;
-    y  =     0.0168155118 + y.*rm;
-    y  =     -0.013394797 + y.*rm;
-    y  =     0.0135698573 + y.*rm;
-    y  =    -0.0155377333 + y.*rm;
-    y  =     0.0174065334 + y.*rm;
-    y  =    -0.0198011178 + y.*rm;
-    y ./= lam;
-
-    inv(k) = floor (lam + (y+t)+lam.*rm);
-  endif
-
-  k = ! k & (s > -sqrt (2));
-  if (any (k))
-    ## Newton iteration
-    r = 1 + s(k);
-    r2 = r + 1;
-    while (any (abs (r - r2) > 1e-5))
-      t = log (r);
-      r2 = r;
-      s2 = sqrt (2 * ((1-r) + r.*t));
-      s2(r<1) *= -1;
-      r = r2 - (s2 - s(k)) .* s2 ./ t;
-      if (r < 0.1 * r2)
-        r = 0.1 * r2;
-      endif
-    endwhile
-    t = log (r);
-    y = lambda(k) .* r + log (sqrt (2*r.*((1-r) + r.*t)) ./ abs (r-1)) ./ t;
-    inv(k) = floor (y - 0.0218 ./ (y + 0.065 * lambda(k)));
-  endif
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 0.5 1 2];
-%!assert (poissinv (x, ones (1,5)), [NaN 0 1 Inf NaN])
-%!assert (poissinv (x, 1), [NaN 0 1 Inf NaN])
-%!assert (poissinv (x, [1 0 NaN 1 1]), [NaN NaN NaN Inf NaN])
-%!assert (poissinv ([x(1:2) NaN x(4:5)], 1), [NaN 0 NaN Inf NaN])
-
-## Test class of input preserved
-%!assert (poissinv ([x, NaN], 1), [NaN 0 1 Inf NaN NaN])
-%!assert (poissinv (single ([x, NaN]), 1), single ([NaN 0 1 Inf NaN NaN]))
-%!assert (poissinv ([x, NaN], single (1)), single ([NaN 0 1 Inf NaN NaN]))
-
-## Test input validation
-%!error poissinv ()
-%!error poissinv (1)
-%!error poissinv (1,2,3)
-%!error poissinv (ones (3), ones (2))
-%!error poissinv (ones (2), ones (3))
-%!error poissinv (i, 2)
-%!error poissinv (2, i)
diff --git a/scripts/statistics/distributions/poisspdf.m b/scripts/statistics/distributions/poisspdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/poisspdf.m
+++ /dev/null
@@ -1,84 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} poisspdf (@var{x}, @var{lambda})
-## For each element of @var{x}, compute the probability density function (PDF)
-## at @var{x} of the Poisson distribution with parameter @var{lambda}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: PDF of the Poisson distribution
-
-function pdf = poisspdf (x, lambda)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (lambda))
-    [retval, x, lambda] = common_size (x, lambda);
-    if (retval > 0)
-      error ("poisspdf: X and LAMBDA must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (lambda))
-    error ("poisspdf: X and LAMBDA must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (lambda, "single"))
-    pdf = zeros (size (x), "single");
-  else
-    pdf = zeros (size (x));
-  endif
-
-  k = isnan (x) | !(lambda > 0);
-  pdf(k) = NaN;
-
-  k = (x >= 0) & (x < Inf) & (x == fix (x)) & (lambda > 0);
-  if (isscalar (lambda))
-    pdf(k) = exp (x(k) * log (lambda) - lambda - gammaln (x(k) + 1));
-  else
-    pdf(k) = exp (x(k) .* log (lambda(k)) - lambda(k) - gammaln (x(k) + 1));
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 1 2 Inf];
-%! y = [0, exp(-1)*[1 1 0.5], 0];
-%!assert (poisspdf (x, ones (1,5)), y, eps)
-%!assert (poisspdf (x, 1), y, eps)
-%!assert (poisspdf (x, [1 0 NaN 1 1]), [y(1) NaN NaN y(4:5)], eps)
-%!assert (poisspdf ([x, NaN], 1), [y, NaN], eps)
-
-## Test class of input preserved
-%!assert (poisspdf (single ([x, NaN]), 1), single ([y, NaN]), eps ("single"))
-%!assert (poisspdf ([x, NaN], single (1)), single ([y, NaN]), eps ("single"))
-
-## Test input validation
-%!error poisspdf ()
-%!error poisspdf (1)
-%!error poisspdf (1,2,3)
-%!error poisspdf (ones (3), ones (2))
-%!error poisspdf (ones (2), ones (3))
-%!error poisspdf (i, 2)
-%!error poisspdf (2, i)
diff --git a/scripts/statistics/distributions/poissrnd.m b/scripts/statistics/distributions/poissrnd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/poissrnd.m
+++ /dev/null
@@ -1,119 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} poissrnd (@var{lambda})
-## @deftypefnx {} {} poissrnd (@var{lambda}, @var{r})
-## @deftypefnx {} {} poissrnd (@var{lambda}, @var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} poissrnd (@var{lambda}, [@var{sz}])
-## Return a matrix of random samples from the Poisson distribution with
-## parameter @var{lambda}.
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-##
-## If no size arguments are given then the result matrix is the size of
-## @var{lambda}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Random deviates from the Poisson distribution
-
-function rnd = poissrnd (lambda, varargin)
-
-  if (nargin < 1)
-    print_usage ();
-  endif
-
-  if (nargin == 1)
-    sz = size (lambda);
-  elseif (nargin == 2)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1};
-    else
-      error ("poissrnd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 2)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("poissrnd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  if (! isscalar (lambda) && ! isequal (size (lambda), sz))
-    error ("poissrnd: LAMBDA must be scalar or of size SZ");
-  endif
-
-  if (iscomplex (lambda))
-    error ("poissrnd: LAMBDA must not be complex");
-  endif
-
-  if (isa (lambda, "single"))
-    cls = "single";
-  else
-    cls = "double";
-  endif
-
-  if (isscalar (lambda))
-    if (lambda >= 0 && lambda < Inf)
-      rnd = randp (lambda, sz, cls);
-    else
-      rnd = NaN (sz, cls);
-    endif
-  else
-    rnd = NaN (sz, cls);
-
-    k = (lambda >= 0) & (lambda < Inf);
-    rnd(k) = randp (lambda(k), cls);
-  endif
-
-endfunction
-
-
-%!assert (size (poissrnd (2)), [1, 1])
-%!assert (size (poissrnd (ones (2,1))), [2, 1])
-%!assert (size (poissrnd (ones (2,2))), [2, 2])
-%!assert (size (poissrnd (1, 3)), [3, 3])
-%!assert (size (poissrnd (1, [4 1])), [4, 1])
-%!assert (size (poissrnd (1, 4, 1)), [4, 1])
-
-## Test class of input preserved
-%!assert (class (poissrnd (2)), "double")
-%!assert (class (poissrnd (single (2))), "single")
-%!assert (class (poissrnd (single ([2 2]))), "single")
-
-## Test input validation
-%!error poissrnd ()
-%!error poissrnd (1, -1)
-%!error poissrnd (1, ones (2))
-%!error poissrnd (1, 2, ones (2))
-%!error poissrnd (i)
-%!error poissrnd (1, 2, -1)
-%!error poissrnd (1, [2 -1 2])
-%!error poissrnd (ones (2,2), 3)
-%!error poissrnd (ones (2,2), [3, 2])
-%!error poissrnd (ones (2,2), 2, 3)
-
-%!assert (poissrnd (0, 1, 1), 0)
-%!assert (poissrnd ([0, 0, 0], [1, 3]), [0 0 0])
diff --git a/scripts/statistics/distributions/stdnormal_cdf.m b/scripts/statistics/distributions/stdnormal_cdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/stdnormal_cdf.m
+++ /dev/null
@@ -1,56 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} stdnormal_cdf (@var{x})
-## For each element of @var{x}, compute the cumulative distribution function
-## (CDF) at @var{x} of the standard normal distribution
-## (mean = 0, standard deviation = 1).
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: CDF of the standard normal distribution
-
-function cdf = stdnormal_cdf (x)
-
-  if (nargin != 1)
-    print_usage ();
-  endif
-
-  if (iscomplex (x))
-    error ("stdnormal_cdf: X must not be complex");
-  endif
-
-  cdf = erfc (x / (-sqrt(2))) / 2;
-
-endfunction
-
-
-%!shared x,y
-%! x = [-Inf 0 1 Inf];
-%! y = [0, 0.5, 1/2*(1+erf(1/sqrt(2))), 1];
-%!assert (stdnormal_cdf ([x, NaN]), [y, NaN])
-
-## Test class of input preserved
-%!assert (stdnormal_cdf (single ([x, NaN])), single ([y, NaN]), eps ("single"))
-
-## Test input validation
-%!error stdnormal_cdf ()
-%!error stdnormal_cdf (1,2)
-%!error stdnormal_cdf (i)
diff --git a/scripts/statistics/distributions/stdnormal_inv.m b/scripts/statistics/distributions/stdnormal_inv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/stdnormal_inv.m
+++ /dev/null
@@ -1,56 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} stdnormal_inv (@var{x})
-## For each element of @var{x}, compute the quantile (the
-## inverse of the CDF) at @var{x} of the standard normal distribution
-## (mean = 0, standard deviation = 1).
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Quantile function of the standard normal distribution
-
-function inv = stdnormal_inv (x)
-
-  if (nargin != 1)
-    print_usage ();
-  endif
-
-  if (iscomplex (x))
-    error ("stdnormal_inv: X must not be complex");
-  endif
-
-  inv = - sqrt (2) * erfcinv (2 * x);
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 0.5 1 2];
-%!assert (stdnormal_inv (x), [NaN -Inf 0 Inf NaN])
-
-## Test class of input preserved
-%!assert (stdnormal_inv ([x, NaN]), [NaN -Inf 0 Inf NaN NaN])
-%!assert (stdnormal_inv (single ([x, NaN])), single ([NaN -Inf 0 Inf NaN NaN]))
-
-## Test input validation
-%!error stdnormal_inv ()
-%!error stdnormal_inv (1,2)
-%!error stdnormal_inv (i)
diff --git a/scripts/statistics/distributions/stdnormal_pdf.m b/scripts/statistics/distributions/stdnormal_pdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/stdnormal_pdf.m
+++ /dev/null
@@ -1,56 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} stdnormal_pdf (@var{x})
-## For each element of @var{x}, compute the probability density function (PDF)
-## at @var{x} of the standard normal distribution
-## (mean = 0, standard deviation = 1).
-## @end deftypefn
-
-## Author: TT <Teresa.Twaroch@ci.tuwien.ac.at>
-## Description: PDF of the standard normal distribution
-
-function pdf = stdnormal_pdf (x)
-
-  if (nargin != 1)
-    print_usage ();
-  endif
-
-  if (iscomplex (x))
-    error ("stdnormal_pdf: X must not be complex");
-  endif
-
-  pdf = (2 * pi)^(- 1/2) * exp (- x .^ 2 / 2);
-
-endfunction
-
-
-%!shared x,y
-%! x = [-Inf 0 1 Inf];
-%! y = 1/sqrt(2*pi)*exp (-x.^2/2);
-%!assert (stdnormal_pdf ([x, NaN]), [y, NaN], eps)
-
-## Test class of input preserved
-%!assert (stdnormal_pdf (single ([x, NaN])), single ([y, NaN]), eps ("single"))
-
-## Test input validation
-%!error stdnormal_pdf ()
-%!error stdnormal_pdf (1,2)
-%!error stdnormal_pdf (i)
diff --git a/scripts/statistics/distributions/stdnormal_rnd.m b/scripts/statistics/distributions/stdnormal_rnd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/stdnormal_rnd.m
+++ /dev/null
@@ -1,73 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} stdnormal_rnd (@var{r})
-## @deftypefnx {} {} stdnormal_rnd (@var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} stdnormal_rnd ([@var{sz}])
-## Return a matrix of random samples from the standard normal distribution
-## (mean = 0, standard deviation = 1).
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Random deviates from the standard normal distribution
-
-function rnd = stdnormal_rnd (varargin)
-
-  if (nargin < 1)
-    print_usage ();
-  endif
-
-  if (nargin == 1)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1};
-    else
-      error ("stdnormal_rnd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 1)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("stdnormal_rnd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  rnd = randn (sz);
-
-endfunction
-
-
-%!assert (size (stdnormal_rnd (3)), [3, 3])
-%!assert (size (stdnormal_rnd ([4 1])), [4, 1])
-%!assert (size (stdnormal_rnd (4,1)), [4, 1])
-
-## Test input validation
-%!error stdnormal_rnd ()
-%!error stdnormal_rnd (-1)
-%!error stdnormal_rnd (ones (2))
-%!error stdnormal_rnd ([2 -1 2])
-%!error stdnormal_rnd (1, ones (2))
-%!error stdnormal_rnd (1, -1)
diff --git a/scripts/statistics/distributions/tcdf.m b/scripts/statistics/distributions/tcdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/tcdf.m
+++ /dev/null
@@ -1,159 +0,0 @@
-## Copyright (C) 2013-2017 Julien Bect
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} tcdf (@var{x}, @var{n})
-## For each element of @var{x}, compute the cumulative distribution function
-## (CDF) at @var{x} of the t (Student) distribution with
-## @var{n} degrees of freedom.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: CDF of the t distribution
-
-function cdf = tcdf (x, n)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (n))
-    [retval, x, n] = common_size (x, n);
-    if (retval > 0)
-      error ("tcdf: X and N must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (n))
-    error ("tcdf: X and N must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (n, "single"))
-    cdf = zeros (size (x), "single");
-  else
-    cdf = zeros (size (x));
-  endif
-
-  k = ! isinf (x) & (n > 0);
-
-  xx = x .^ 2;
-  x_big_abs = (xx > n);
-
-  ## deal with the case "abs(x) big"
-  kk = k & x_big_abs;
-  if (isscalar (n))
-    cdf(kk) = betainc (n ./ (n + xx(kk)), n/2, 1/2) / 2;
-  else
-    cdf(kk) = betainc (n(kk) ./ (n(kk) + xx(kk)), n(kk)/2, 1/2) / 2;
-  endif
-
-  ## deal with the case "abs(x) small"
-  kk = k & ! x_big_abs;
-  if (isscalar (n))
-    cdf(kk) = 0.5 * (1 - betainc (xx(kk) ./ (n + xx(kk)), 1/2, n/2));
-  else
-    cdf(kk) = 0.5 * (1 - betainc (xx(kk) ./ (n(kk) + xx(kk)), 1/2, n(kk)/2));
-  endif
-
-  k &= (x > 0);
-  if (any (k(:)))
-    cdf(k) = 1 - cdf(k);
-  endif
-
-  k = isnan (x) | !(n > 0);
-  cdf(k) = NaN;
-
-  k = (x == Inf) & (n > 0);
-  cdf(k) = 1;
-
-endfunction
-
-
-%!shared x,y
-%! x = [-Inf 0 1 Inf];
-%! y = [0 1/2 3/4 1];
-%!assert (tcdf (x, ones (1,4)), y, eps)
-%!assert (tcdf (x, 1), y, eps)
-%!assert (tcdf (x, [0 1 NaN 1]), [NaN 1/2 NaN 1], eps)
-%!assert (tcdf ([x(1:2) NaN x(4)], 1), [y(1:2) NaN y(4)], eps)
-
-## Test class of input preserved
-%!assert (tcdf ([x, NaN], 1), [y, NaN], eps)
-%!assert (tcdf (single ([x, NaN]), 1), single ([y, NaN]), eps ("single"))
-%!assert (tcdf ([x, NaN], single (1)), single ([y, NaN]), eps ("single"))
-
-## Test input validation
-%!error tcdf ()
-%!error tcdf (1)
-%!error tcdf (1,2,3)
-%!error tcdf (ones (3), ones (2))
-%!error tcdf (ones (2), ones (3))
-%!error tcdf (i, 2)
-%!error tcdf (2, i)
-
-## Check some reference values
-
-%!shared tol_rel
-%! tol_rel = 10 * eps;
-
-## check accuracy for small positive values
-%!assert (tcdf (10^(-10), 2.5), 0.50000000003618087, -tol_rel)
-%!assert (tcdf (10^(-11), 2.5), 0.50000000000361809, -tol_rel)
-%!assert (tcdf (10^(-12), 2.5), 0.50000000000036181, -tol_rel)
-%!assert (tcdf (10^(-13), 2.5), 0.50000000000003618, -tol_rel)
-%!assert (tcdf (10^(-14), 2.5), 0.50000000000000362, -tol_rel)
-%!assert (tcdf (10^(-15), 2.5), 0.50000000000000036, -tol_rel)
-%!assert (tcdf (10^(-16), 2.5), 0.50000000000000004, -tol_rel)
-
-## check accuracy for large negative values
-%!assert (tcdf (-10^1, 2.5), 2.2207478836537124e-03, -tol_rel)
-%!assert (tcdf (-10^2, 2.5), 7.1916492116661878e-06, -tol_rel)
-%!assert (tcdf (-10^3, 2.5), 2.2747463948307452e-08, -tol_rel)
-%!assert (tcdf (-10^4, 2.5), 7.1933970159922115e-11, -tol_rel)
-%!assert (tcdf (-10^5, 2.5), 2.2747519231756221e-13, -tol_rel)
-
-## # Reference values obtained using Python 2.7.4 and mpmath 0.17
-##
-## from mpmath import *
-##
-## mp.dps = 100
-##
-## def F(x_in, nu_in):
-##     x = mpf(x_in);
-##     nu = mpf(nu_in);
-##     t = nu / (nu + x*x)
-##     a = nu / 2
-##     b = mpf(0.5)
-##     F = betainc(a, b, 0, t, regularized=True) / 2
-##     if (x > 0):
-##         F = 1 - F
-##     return F
-##
-## nu = 2.5
-##
-## for i in range(1, 6):
-##     x = - power(mpf(10), mpf(i))
-##     print "%%!assert (tcdf (-10^%d, 2.5), %s, -eps)" \
-##         % (i, nstr(F(x, nu), 17))
-##
-## for i in range(10, 17):
-##     x = power(mpf(10), -mpf(i))
-##     print "%%!assert (tcdf (10^(-%d), 2.5), %s, -eps)" \
-##         % (i, nstr(F(x, nu), 17))
diff --git a/scripts/statistics/distributions/tinv.m b/scripts/statistics/distributions/tinv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/tinv.m
+++ /dev/null
@@ -1,109 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} tinv (@var{x}, @var{n})
-## For each element of @var{x}, compute the quantile (the inverse of the CDF)
-## at @var{x} of the t (Student) distribution with @var{n}
-## degrees of freedom.
-##
-## This function is analogous to looking in a table for the t-value of a
-## single-tailed distribution.
-## @end deftypefn
-
-## For very large n, the "correct" formula does not really work well,
-## and the quantiles of the standard normal distribution are used
-## directly.
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Quantile function of the t distribution
-
-function inv = tinv (x, n)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (n))
-    [retval, x, n] = common_size (x, n);
-    if (retval > 0)
-      error ("tinv: X and N must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (n))
-    error ("tinv: X and N must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (n, "single"))
-    inv = NaN (size (x), "single");
-  else
-    inv = NaN (size (x));
-  endif
-
-  k = (x == 0) & (n > 0);
-  inv(k) = -Inf;
-
-  k = (x == 1) & (n > 0);
-  inv(k) = Inf;
-
-  if (isscalar (n))
-    k = (x > 0) & (x < 1);
-    if ((n > 0) && (n < 10000))
-      inv(k) = (sign (x(k) - 1/2)
-                .* sqrt (n * (1 ./ betainv (2*min (x(k), 1 - x(k)),
-                                            n/2, 1/2) - 1)));
-    elseif (n >= 10000)
-      ## For large n, use the quantiles of the standard normal
-      inv(k) = stdnormal_inv (x(k));
-    endif
-  else
-    k = (x > 0) & (x < 1) & (n > 0) & (n < 10000);
-    inv(k) = (sign (x(k) - 1/2)
-              .* sqrt (n(k) .* (1 ./ betainv (2*min (x(k), 1 - x(k)),
-                                              n(k)/2, 1/2) - 1)));
-
-    ## For large n, use the quantiles of the standard normal
-    k = (x > 0) & (x < 1) & (n >= 10000);
-    inv(k) = stdnormal_inv (x(k));
-  endif
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 0.5 1 2];
-%!assert (tinv (x, ones (1,5)), [NaN -Inf 0 Inf NaN])
-%!assert (tinv (x, 1), [NaN -Inf 0 Inf NaN], eps)
-%!assert (tinv (x, [1 0 NaN 1 1]), [NaN NaN NaN Inf NaN], eps)
-%!assert (tinv ([x(1:2) NaN x(4:5)], 1), [NaN -Inf NaN Inf NaN])
-
-## Test class of input preserved
-%!assert (tinv ([x, NaN], 1), [NaN -Inf 0 Inf NaN NaN], eps)
-%!assert (tinv (single ([x, NaN]), 1), single ([NaN -Inf 0 Inf NaN NaN]), eps ("single"))
-%!assert (tinv ([x, NaN], single (1)), single ([NaN -Inf 0 Inf NaN NaN]), eps ("single"))
-
-## Test input validation
-%!error tinv ()
-%!error tinv (1)
-%!error tinv (1,2,3)
-%!error tinv (ones (3), ones (2))
-%!error tinv (ones (2), ones (3))
-%!error tinv (i, 2)
-%!error tinv (2, i)
diff --git a/scripts/statistics/distributions/tpdf.m b/scripts/statistics/distributions/tpdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/tpdf.m
+++ /dev/null
@@ -1,92 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} tpdf (@var{x}, @var{n})
-## For each element of @var{x}, compute the probability density function (PDF)
-## at @var{x} of the @var{t} (Student) distribution with
-## @var{n} degrees of freedom.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: PDF of the t distribution
-
-function pdf = tpdf (x, n)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (n))
-    [retval, x, n] = common_size (x, n);
-    if (retval > 0)
-      error ("tpdf: X and N must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (n))
-    error ("tpdf: X and N must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (n, "single"))
-    pdf = zeros (size (x), "single");
-  else
-    pdf = zeros (size (x));
-  endif
-
-  k = isnan (x) | !(n > 0) | !(n < Inf);
-  pdf(k) = NaN;
-
-  k = isfinite (x) & (n > 0) & (n < Inf);
-  if (isscalar (n))
-    pdf(k) = (exp (- (n + 1) * log (1 + x(k) .^ 2 / n)/2)
-              / (sqrt (n) * beta (n/2, 1/2)));
-  else
-    pdf(k) = (exp (- (n(k) + 1) .* log (1 + x(k) .^ 2 ./ n(k))/2)
-              ./ (sqrt (n(k)) .* beta (n(k)/2, 1/2)));
-  endif
-
-endfunction
-
-
-%!test
-%! x = rand (10,1);
-%! y = 1./(pi * (1 + x.^2));
-%! assert (tpdf (x, 1), y, 5*eps);
-
-%!shared x,y
-%! x = [-Inf 0 0.5 1 Inf];
-%! y = 1./(pi * (1 + x.^2));
-%!assert (tpdf (x, ones (1,5)), y, eps)
-%!assert (tpdf (x, 1), y, eps)
-%!assert (tpdf (x, [0 NaN 1 1 1]), [NaN NaN y(3:5)], eps)
-
-## Test class of input preserved
-%!assert (tpdf ([x, NaN], 1), [y, NaN], eps)
-%!assert (tpdf (single ([x, NaN]), 1), single ([y, NaN]), eps ("single"))
-%!assert (tpdf ([x, NaN], single (1)), single ([y, NaN]), eps ("single"))
-
-## Test input validation
-%!error tpdf ()
-%!error tpdf (1)
-%!error tpdf (1,2,3)
-%!error tpdf (ones (3), ones (2))
-%!error tpdf (ones (2), ones (3))
-%!error tpdf (i, 2)
-%!error tpdf (2, i)
diff --git a/scripts/statistics/distributions/trnd.m b/scripts/statistics/distributions/trnd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/trnd.m
+++ /dev/null
@@ -1,117 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} trnd (@var{n})
-## @deftypefnx {} {} trnd (@var{n}, @var{r})
-## @deftypefnx {} {} trnd (@var{n}, @var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} trnd (@var{n}, [@var{sz}])
-## Return a matrix of random samples from the t (Student) distribution with
-## @var{n} degrees of freedom.
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-##
-## If no size arguments are given then the result matrix is the size of
-## @var{n}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Random deviates from the t distribution
-
-function rnd = trnd (n, varargin)
-
-  if (nargin < 1)
-    print_usage ();
-  endif
-
-  if (nargin == 1)
-    sz = size (n);
-  elseif (nargin == 2)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1};
-    else
-      error ("trnd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 2)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("trnd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  if (! isscalar (n) && ! isequal (size (n), sz))
-    error ("trnd: N must be scalar or of size SZ");
-  endif
-
-  if (iscomplex (n))
-    error ("trnd: N must not be complex");
-  endif
-
-  if (isa (n, "single"))
-    cls = "single";
-  else
-    cls = "double";
-  endif
-
-  if (isscalar (n))
-    if ((n > 0) && (n < Inf))
-      rnd = randn (sz, cls) ./ sqrt (2*randg (n/2, sz, cls) / n);
-    else
-      rnd = NaN (sz, cls);
-    endif
-  else
-    rnd = NaN (sz, cls);
-
-    k = (n > 0) & (n < Inf);
-    rnd(k) = randn (sum (k(:)), 1, cls) ...
-             ./ sqrt (2*randg (n(k)/2, cls) ./ n(k))(:);
-  endif
-
-endfunction
-
-
-%!assert (size (trnd (2)), [1, 1])
-%!assert (size (trnd (ones (2,1))), [2, 1])
-%!assert (size (trnd (ones (2,2))), [2, 2])
-%!assert (size (trnd (1, 3)), [3, 3])
-%!assert (size (trnd (1, [4 1])), [4, 1])
-%!assert (size (trnd (1, 4, 1)), [4, 1])
-
-## Test class of input preserved
-%!assert (class (trnd (1)), "double")
-%!assert (class (trnd (single (1))), "single")
-%!assert (class (trnd (single ([1 1]))), "single")
-
-## Test input validation
-%!error trnd ()
-%!error trnd (1, -1)
-%!error trnd (1, ones (2))
-%!error trnd (i)
-%!error trnd (1, [2 -1 2])
-%!error trnd (1, 2, ones (2))
-%!error trnd (1, 2, -1)
-%!error trnd (ones (2,2), 3)
-%!error trnd (ones (2,2), [3, 2])
-%!error trnd (ones (2,2), 2, 3)
diff --git a/scripts/statistics/distributions/unidcdf.m b/scripts/statistics/distributions/unidcdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/unidcdf.m
+++ /dev/null
@@ -1,88 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 2007-2016 David Bateman
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} unidcdf (@var{x}, @var{n})
-## For each element of @var{x}, compute the cumulative distribution function
-## (CDF) at @var{x} of a discrete uniform distribution which assumes
-## the integer values 1--@var{n} with equal probability.
-## @end deftypefn
-
-function cdf = unidcdf (x, n)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (n))
-    [retval, x, n] = common_size (x, n);
-    if (retval > 0)
-      error ("unidcdf: X and N must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (n))
-    error ("unidcdf: X and N must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (n, "single"))
-    cdf = zeros (size (x), "single");
-  else
-    cdf = zeros (size (x));
-  endif
-
-  knan = isnan (x) | ! (n > 0 & n == fix (n));
-  if (any (knan(:)))
-    cdf(knan) = NaN;
-  endif
-
-  k = (x >= n) & ! knan;
-  cdf(k) = 1;
-
-  k = (x >= 1) & (x < n) & ! knan;
-  if (isscalar (n))
-    cdf(k) = floor (x(k)) / n;
-  else
-    cdf(k) = floor (x(k)) ./ n(k);
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [0 1 2.5 10 11];
-%! y = [0, 0.1 0.2 1.0 1.0];
-%!assert (unidcdf (x, 10*ones (1,5)), y)
-%!assert (unidcdf (x, 10), y)
-%!assert (unidcdf (x, 10*[0 1 NaN 1 1]), [NaN 0.1 NaN y(4:5)])
-%!assert (unidcdf ([x(1:2) NaN Inf x(5)], 10), [y(1:2) NaN 1 y(5)])
-
-## Test class of input preserved
-%!assert (unidcdf ([x, NaN], 10), [y, NaN])
-%!assert (unidcdf (single ([x, NaN]), 10), single ([y, NaN]))
-%!assert (unidcdf ([x, NaN], single (10)), single ([y, NaN]))
-
-## Test input validation
-%!error unidcdf ()
-%!error unidcdf (1)
-%!error unidcdf (1,2,3)
-%!error unidcdf (ones (3), ones (2))
-%!error unidcdf (ones (2), ones (3))
-%!error unidcdf (i, 2)
-%!error unidcdf (2, i)
diff --git a/scripts/statistics/distributions/unidinv.m b/scripts/statistics/distributions/unidinv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/unidinv.m
+++ /dev/null
@@ -1,80 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 2007-2016 David Bateman
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} unidinv (@var{x}, @var{n})
-## For each element of @var{x}, compute the quantile (the inverse of the CDF)
-## at @var{x} of the discrete uniform distribution which assumes
-## the integer values 1--@var{n} with equal probability.
-## @end deftypefn
-
-function inv = unidinv (x, n)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (n))
-    [retval, x, n] = common_size (x, n);
-    if (retval > 0)
-      error ("unidcdf: X and N must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (n))
-    error ("unidinv: X and N must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (n, "single"))
-    inv = NaN (size (x), "single");
-  else
-    inv = NaN (size (x));
-  endif
-
-  ## For Matlab compatibility, unidinv(0) = NaN
-  k = (x > 0) & (x <= 1) & (n > 0 & n == fix (n));
-  if (isscalar (n))
-    inv(k) = floor (x(k) * n);
-  else
-    inv(k) = floor (x(k) .* n(k));
-  endif
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 0.5 1 2];
-%!assert (unidinv (x, 10*ones (1,5)), [NaN NaN 5 10 NaN], eps)
-%!assert (unidinv (x, 10), [NaN NaN 5 10 NaN], eps)
-%!assert (unidinv (x, 10*[0 1 NaN 1 1]), [NaN NaN NaN 10 NaN], eps)
-%!assert (unidinv ([x(1:2) NaN x(4:5)], 10), [NaN NaN NaN 10 NaN], eps)
-
-## Test class of input preserved
-%!assert (unidinv ([x, NaN], 10), [NaN NaN 5 10 NaN NaN], eps)
-%!assert (unidinv (single ([x, NaN]), 10), single ([NaN NaN 5 10 NaN NaN]), eps)
-%!assert (unidinv ([x, NaN], single (10)), single ([NaN NaN 5 10 NaN NaN]), eps)
-
-## Test input validation
-%!error unidinv ()
-%!error unidinv (1)
-%!error unidinv (1,2,3)
-%!error unidinv (ones (3), ones (2))
-%!error unidinv (ones (2), ones (3))
-%!error unidinv (i, 2)
-%!error unidinv (2, i)
diff --git a/scripts/statistics/distributions/unidpdf.m b/scripts/statistics/distributions/unidpdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/unidpdf.m
+++ /dev/null
@@ -1,86 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 2007-2016 David Bateman
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} unidpdf (@var{x}, @var{n})
-## For each element of @var{x}, compute the probability density function (PDF)
-## at @var{x} of a discrete uniform distribution which assumes
-## the integer values 1--@var{n} with equal probability.
-##
-## Warning: The underlying implementation uses the double class and will only
-## be accurate for @var{n} < @code{flintmax} (@w{@math{2^{53}}} on
-## IEEE 754 compatible systems).
-## @end deftypefn
-
-function pdf = unidpdf (x, n)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (n))
-    [retval, x, n] = common_size (x, n);
-    if (retval > 0)
-      error ("unidpdf: X and N must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (n))
-    error ("unidpdf: X and N must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (n, "single"))
-    pdf = zeros (size (x), "single");
-  else
-    pdf = zeros (size (x));
-  endif
-
-  k = isnan (x) | ! (n > 0 & n == fix (n));
-  pdf(k) = NaN;
-
-  k = ! k & (x >= 1) & (x <= n) & (x == fix (x));
-  if (isscalar (n))
-    pdf(k) = 1 / n;
-  else
-    pdf(k) = 1 ./ n(k);
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 1 2 10 11];
-%! y = [0 0 0.1 0.1 0.1 0];
-%!assert (unidpdf (x, 10*ones (1,6)), y)
-%!assert (unidpdf (x, 10), y)
-%!assert (unidpdf (x, 10*[0 NaN 1 1 1 1]), [NaN NaN y(3:6)])
-%!assert (unidpdf ([x, NaN], 10), [y, NaN])
-
-## Test class of input preserved
-%!assert (unidpdf (single ([x, NaN]), 10), single ([y, NaN]))
-%!assert (unidpdf ([x, NaN], single (10)), single ([y, NaN]))
-
-## Test input validation
-%!error unidpdf ()
-%!error unidpdf (1)
-%!error unidpdf (1,2,3)
-%!error unidpdf (ones (3), ones (2))
-%!error unidpdf (ones (2), ones (3))
-%!error unidpdf (i, 2)
-%!error unidpdf (2, i)
diff --git a/scripts/statistics/distributions/unidrnd.m b/scripts/statistics/distributions/unidrnd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/unidrnd.m
+++ /dev/null
@@ -1,111 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 2005-2016 John W. Eaton
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} unidrnd (@var{n})
-## @deftypefnx {} {} unidrnd (@var{n}, @var{r})
-## @deftypefnx {} {} unidrnd (@var{n}, @var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} unidrnd (@var{n}, [@var{sz}])
-## Return a matrix of random samples from the discrete uniform distribution
-## which assumes the integer values 1--@var{n} with equal probability.
-##
-## @var{n} may be a scalar or a multi-dimensional array.
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-##
-## If no size arguments are given then the result matrix is the size of
-## @var{n}.
-## @end deftypefn
-
-## Author: jwe
-
-function rnd = unidrnd (n, varargin)
-
-  if (nargin < 1)
-    print_usage ();
-  endif
-
-  if (nargin == 1)
-    sz = size (n);
-  elseif (nargin == 2)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1};
-    else
-      error ("unidrnd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 2)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("unidrnd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  if (! isscalar (n) && ! isequal (size (n), sz))
-    error ("unidrnd: N must be scalar or of size SZ");
-  endif
-
-  if (iscomplex (n))
-    error ("unidrnd: N must not be complex");
-  endif
-
-  if (isa (n, "single"))
-    cls = "single";
-  else
-    cls = "double";
-  endif
-
-  if (isscalar (n))
-    if (n > 0 && n == fix (n))
-      rnd = ceil (rand (sz, cls) * n);
-    else
-      rnd = NaN (sz, cls);
-    endif
-  else
-    rnd = ceil (rand (sz, cls) .* n);
-
-    k = ! (n > 0 & n == fix (n));
-    rnd(k) = NaN;
-  endif
-
-endfunction
-
-
-%!assert (size (unidrnd (2)), [1, 1])
-%!assert (size (unidrnd (ones (2,1))), [2, 1])
-%!assert (size (unidrnd (ones (2,2))), [2, 2])
-%!assert (size (unidrnd (10, [4 1])), [4, 1])
-%!assert (size (unidrnd (10, 4, 1)), [4, 1])
-
-## Test class of input preserved
-%!assert (class (unidrnd (2)), "double")
-%!assert (class (unidrnd (single (2))), "single")
-%!assert (class (unidrnd (single ([2 2]))), "single")
-
-## Test input validation
-%!error unidrnd ()
-%!error unidrnd (10, [1;2;3])
-%!error unidrnd (10, 2, ones (2))
-%!error unidrnd (10*ones (2), 2, 1)
-%!error unidrnd (i)
diff --git a/scripts/statistics/distributions/unifcdf.m b/scripts/statistics/distributions/unifcdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/unifcdf.m
+++ /dev/null
@@ -1,97 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} unifcdf (@var{x})
-## @deftypefnx {} {} unifcdf (@var{x}, @var{a}, @var{b})
-## For each element of @var{x}, compute the cumulative distribution function
-## (CDF) at @var{x} of the uniform distribution on the interval
-## [@var{a}, @var{b}].
-##
-## Default values are @var{a} = 0, @var{b} = 1.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: CDF of the uniform distribution
-
-function cdf = unifcdf (x, a = 0, b = 1)
-
-  if (nargin != 1 && nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (a) || ! isscalar (b))
-    [retval, x, a, b] = common_size (x, a, b);
-    if (retval > 0)
-      error ("unifcdf: X, A, and B must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (a) || iscomplex (b))
-    error ("unifcdf: X, A, and B must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (a, "single") || isa (b, "single"))
-    cdf = zeros (size (x), "single");
-  else
-    cdf = zeros (size (x));
-  endif
-
-  k = isnan (x) | !(a < b);
-  cdf(k) = NaN;
-
-  k = (x >= b) & (a < b);
-  cdf(k) = 1;
-
-  k = (x > a) & (x < b);
-  if (isscalar (a) && isscalar (b))
-    cdf(k) = (x(k) < b) .* (x(k) - a) / (b - a);
-  else
-    cdf(k) = (x(k) < b(k)) .* (x(k) - a(k)) ./ (b(k) - a(k));
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 0.5 1 2] + 1;
-%! y = [0 0 0.5 1 1];
-%!assert (unifcdf (x, ones (1,5), 2*ones (1,5)), y)
-%!assert (unifcdf (x, 1, 2*ones (1,5)), y)
-%!assert (unifcdf (x, ones (1,5), 2), y)
-%!assert (unifcdf (x, [2 1 NaN 1 1], 2), [NaN 0 NaN 1 1])
-%!assert (unifcdf (x, 1, 2*[0 1 NaN 1 1]), [NaN 0 NaN 1 1])
-%!assert (unifcdf ([x(1:2) NaN x(4:5)], 1, 2), [y(1:2) NaN y(4:5)])
-
-## Test class of input preserved
-%!assert (unifcdf ([x, NaN], 1, 2), [y, NaN])
-%!assert (unifcdf (single ([x, NaN]), 1, 2), single ([y, NaN]))
-%!assert (unifcdf ([x, NaN], single (1), 2), single ([y, NaN]))
-%!assert (unifcdf ([x, NaN], 1, single (2)), single ([y, NaN]))
-
-## Test input validation
-%!error unifcdf ()
-%!error unifcdf (1,2)
-%!error unifcdf (1,2,3,4)
-%!error unifcdf (ones (3), ones (2), ones (2))
-%!error unifcdf (ones (2), ones (3), ones (2))
-%!error unifcdf (ones (2), ones (2), ones (3))
-%!error unifcdf (i, 2, 2)
-%!error unifcdf (2, i, 2)
-%!error unifcdf (2, 2, i)
diff --git a/scripts/statistics/distributions/unifinv.m b/scripts/statistics/distributions/unifinv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/unifinv.m
+++ /dev/null
@@ -1,89 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} unifinv (@var{x})
-## @deftypefnx {} {} unifinv (@var{x}, @var{a}, @var{b})
-## For each element of @var{x}, compute the quantile (the inverse of the CDF)
-## at @var{x} of the uniform distribution on the interval [@var{a}, @var{b}].
-##
-## Default values are @var{a} = 0, @var{b} = 1.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Quantile function of the uniform distribution
-
-function inv = unifinv (x, a = 0, b = 1)
-
-  if (nargin != 1 && nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (a) || ! isscalar (b))
-    [retval, x, a, b] = common_size (x, a, b);
-    if (retval > 0)
-      error ("unifinv: X, A, and B must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (a) || iscomplex (b))
-    error ("unifinv: X, A, and B must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (a, "single") || isa (b, "single"))
-    inv = NaN (size (x), "single");
-  else
-    inv = NaN (size (x));
-  endif
-
-  k = (x >= 0) & (x <= 1) & (a < b);
-  if (isscalar (a) && isscalar (b))
-    inv(k) = a + x(k) * (b - a);
-  else
-    inv(k) = a(k) + x(k) .* (b(k) - a(k));
-  endif
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 0.5 1 2];
-%!assert (unifinv (x, ones (1,5), 2*ones (1,5)), [NaN 1 1.5 2 NaN])
-%!assert (unifinv (x, 1, 2*ones (1,5)), [NaN 1 1.5 2 NaN])
-%!assert (unifinv (x, ones (1,5), 2), [NaN 1 1.5 2 NaN])
-%!assert (unifinv (x, [1 2 NaN 1 1], 2), [NaN NaN NaN 2 NaN])
-%!assert (unifinv (x, 1, 2*[1 0 NaN 1 1]), [NaN NaN NaN 2 NaN])
-%!assert (unifinv ([x(1:2) NaN x(4:5)], 1, 2), [NaN 1 NaN 2 NaN])
-
-## Test class of input preserved
-%!assert (unifinv ([x, NaN], 1, 2), [NaN 1 1.5 2 NaN NaN])
-%!assert (unifinv (single ([x, NaN]), 1, 2), single ([NaN 1 1.5 2 NaN NaN]))
-%!assert (unifinv ([x, NaN], single (1), 2), single ([NaN 1 1.5 2 NaN NaN]))
-%!assert (unifinv ([x, NaN], 1, single (2)), single ([NaN 1 1.5 2 NaN NaN]))
-
-## Test input validation
-%!error unifinv ()
-%!error unifinv (1,2)
-%!error unifinv (1,2,3,4)
-%!error unifinv (ones (3), ones (2), ones (2))
-%!error unifinv (ones (2), ones (3), ones (2))
-%!error unifinv (ones (2), ones (2), ones (3))
-%!error unifinv (i, 2, 2)
-%!error unifinv (2, i, 2)
-%!error unifinv (2, 2, i)
diff --git a/scripts/statistics/distributions/unifpdf.m b/scripts/statistics/distributions/unifpdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/unifpdf.m
+++ /dev/null
@@ -1,92 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} unifpdf (@var{x})
-## @deftypefnx {} {} unifpdf (@var{x}, @var{a}, @var{b})
-## For each element of @var{x}, compute the probability density function (PDF)
-## at @var{x} of the uniform distribution on the interval [@var{a}, @var{b}].
-##
-## Default values are @var{a} = 0, @var{b} = 1.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: PDF of the uniform distribution
-
-function pdf = unifpdf (x, a = 0, b = 1)
-
-  if (nargin != 1 && nargin != 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (a) || ! isscalar (b))
-    [retval, x, a, b] = common_size (x, a, b);
-    if (retval > 0)
-      error ("unifpdf: X, A, and B must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (a) || iscomplex (b))
-    error ("unifpdf: X, A, and B must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (a, "single") || isa (b, "single"))
-    pdf = zeros (size (x), "single");
-  else
-    pdf = zeros (size (x));
-  endif
-
-  k = isnan (x) | !(a < b);
-  pdf(k) = NaN;
-
-  k = (x >= a) & (x <= b) & (a < b);
-  if (isscalar (a) && isscalar (b))
-    pdf(k) = 1 / (b - a);
-  else
-    pdf(k) = 1 ./ (b(k) - a(k));
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 0.5 1 2] + 1;
-%! y = [0 1 1 1 0];
-%!assert (unifpdf (x, ones (1,5), 2*ones (1,5)), y)
-%!assert (unifpdf (x, 1, 2*ones (1,5)), y)
-%!assert (unifpdf (x, ones (1,5), 2), y)
-%!assert (unifpdf (x, [2 NaN 1 1 1], 2), [NaN NaN y(3:5)])
-%!assert (unifpdf (x, 1, 2*[0 NaN 1 1 1]), [NaN NaN y(3:5)])
-%!assert (unifpdf ([x, NaN], 1, 2), [y, NaN])
-
-## Test class of input preserved
-%!assert (unifpdf (single ([x, NaN]), 1, 2), single ([y, NaN]))
-%!assert (unifpdf (single ([x, NaN]), single (1), 2), single ([y, NaN]))
-%!assert (unifpdf ([x, NaN], 1, single (2)), single ([y, NaN]))
-
-## Test input validation
-%!error unifpdf ()
-%!error unifpdf (1,2)
-%!error unifpdf (1,2,3,4)
-%!error unifpdf (ones (3), ones (2), ones (2))
-%!error unifpdf (ones (2), ones (3), ones (2))
-%!error unifpdf (ones (2), ones (2), ones (3))
-%!error unifpdf (i, 2, 2)
-%!error unifpdf (2, i, 2)
-%!error unifpdf (2, 2, i)
diff --git a/scripts/statistics/distributions/unifrnd.m b/scripts/statistics/distributions/unifrnd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/unifrnd.m
+++ /dev/null
@@ -1,131 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} unifrnd (@var{a}, @var{b})
-## @deftypefnx {} {} unifrnd (@var{a}, @var{b}, @var{r})
-## @deftypefnx {} {} unifrnd (@var{a}, @var{b}, @var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} unifrnd (@var{a}, @var{b}, [@var{sz}])
-## Return a matrix of random samples from the uniform distribution on
-## [@var{a}, @var{b}].
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-##
-## If no size arguments are given then the result matrix is the common size of
-## @var{a} and @var{b}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Random deviates from the uniform distribution
-
-function rnd = unifrnd (a, b, varargin)
-
-  if (nargin < 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (a) || ! isscalar (b))
-    [retval, a, b] = common_size (a, b);
-    if (retval > 0)
-      error ("unifrnd: A and B must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (a) || iscomplex (b))
-    error ("unifrnd: A and B must not be complex");
-  endif
-
-  if (nargin == 2)
-    sz = size (a);
-  elseif (nargin == 3)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1};
-    else
-      error ("unifrnd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 3)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("unifrnd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  if (! isscalar (a) && ! isequal (size (a), sz))
-    error ("unifrnd: A and B must be scalar or of size SZ");
-  endif
-
-  if (isa (a, "single") || isa (b, "single"))
-    cls = "single";
-  else
-    cls = "double";
-  endif
-
-  if (isscalar (a) && isscalar (b))
-    if ((-Inf < a) && (a < b) && (b < Inf))
-      rnd = a + (b - a) * rand (sz, cls);
-    else
-      rnd = NaN (sz, cls);
-    endif
-  else
-    rnd = a + (b - a) .* rand (sz, cls);
-
-    k = !(-Inf < a) | !(a < b) | !(b < Inf);
-    rnd(k) = NaN;
-  endif
-
-endfunction
-
-
-%!assert (size (unifrnd (1,2)), [1, 1])
-%!assert (size (unifrnd (ones (2,1), 2)), [2, 1])
-%!assert (size (unifrnd (ones (2,2), 2)), [2, 2])
-%!assert (size (unifrnd (1, 2*ones (2,1))), [2, 1])
-%!assert (size (unifrnd (1, 2*ones (2,2))), [2, 2])
-%!assert (size (unifrnd (1, 2, 3)), [3, 3])
-%!assert (size (unifrnd (1, 2, [4 1])), [4, 1])
-%!assert (size (unifrnd (1, 2, 4, 1)), [4, 1])
-
-## Test class of input preserved
-%!assert (class (unifrnd (1, 2)), "double")
-%!assert (class (unifrnd (single (1), 2)), "single")
-%!assert (class (unifrnd (single ([1 1]), 2)), "single")
-%!assert (class (unifrnd (1, single (2))), "single")
-%!assert (class (unifrnd (1, single ([2 2]))), "single")
-
-## Test input validation
-%!error unifrnd ()
-%!error unifrnd (1)
-%!error unifrnd (ones (3), ones (2))
-%!error unifrnd (ones (2), ones (3))
-%!error unifrnd (i, 2)
-%!error unifrnd (2, i)
-%!error unifrnd (1,2, -1)
-%!error unifrnd (1,2, ones (2))
-%!error unifrnd (1, 2, [2 -1 2])
-%!error unifrnd (1,2, 1, ones (2))
-%!error unifrnd (1,2, 1, -1)
-%!error unifrnd (ones (2,2), 2, 3)
-%!error unifrnd (ones (2,2), 2, [3, 2])
-%!error unifrnd (ones (2,2), 2, 2, 3)
diff --git a/scripts/statistics/distributions/wblcdf.m b/scripts/statistics/distributions/wblcdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/wblcdf.m
+++ /dev/null
@@ -1,114 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} wblcdf (@var{x})
-## @deftypefnx {} {} wblcdf (@var{x}, @var{scale})
-## @deftypefnx {} {} wblcdf (@var{x}, @var{scale}, @var{shape})
-## Compute the cumulative distribution function (CDF) at @var{x} of the
-## Weibull distribution with scale parameter @var{scale} and shape
-## parameter @var{shape}.
-##
-## This is defined as
-## @tex
-## $$ 1 - e^{-({x \over scale})^{shape}} $$
-## for $x \geq 0$.
-## @end tex
-## @ifnottex
-##
-## @example
-## 1 - exp (-(x/scale)^shape)
-## @end example
-##
-## @noindent
-## for @var{x} @geq{} 0.
-##
-## Default values are @var{scale} = 1, @var{shape} = 1.
-## @end ifnottex
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: CDF of the Weibull distribution
-
-function cdf = wblcdf (x, scale = 1, shape = 1)
-
-  if (nargin < 1 || nargin > 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (shape) || ! isscalar (scale))
-    [retval, x, shape, scale] = common_size (x, shape, scale);
-    if (retval > 0)
-      error ("wblcdf: X, SCALE, and SHAPE must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (scale) || iscomplex (shape))
-    error ("wblcdf: X, SCALE, and SHAPE must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (scale, "single") || isa (shape, "single"))
-    cdf = NaN (size (x), "single");
-  else
-    cdf = NaN (size (x));
-  endif
-
-  ok = (shape > 0) & (shape < Inf) & (scale > 0) & (scale < Inf);
-
-  k = (x <= 0) & ok;
-  cdf(k) = 0;
-
-  k = (x == Inf) & ok;
-  cdf(k) = 1;
-
-  k = (x > 0) & (x < Inf) & ok;
-  if (isscalar (shape) && isscalar (scale))
-    cdf(k) = 1 - exp (- (x(k) / scale) .^ shape);
-  else
-    cdf(k) = 1 - exp (- (x(k) ./ scale(k)) .^ shape(k));
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 0.5 1 Inf];
-%! y = [0, 1-exp(-x(2:4)), 1];
-%!assert (wblcdf (x, ones (1,5), ones (1,5)), y)
-%!assert (wblcdf (x, 1, ones (1,5)), y)
-%!assert (wblcdf (x, ones (1,5), 1), y)
-%!assert (wblcdf (x, [0 1 NaN Inf 1], 1), [NaN 0 NaN NaN 1])
-%!assert (wblcdf (x, 1, [0 1 NaN Inf 1]), [NaN 0 NaN NaN 1])
-%!assert (wblcdf ([x(1:2) NaN x(4:5)], 1, 1), [y(1:2) NaN y(4:5)])
-
-## Test class of input preserved
-%!assert (wblcdf ([x, NaN], 1, 1), [y, NaN])
-%!assert (wblcdf (single ([x, NaN]), 1, 1), single ([y, NaN]))
-%!assert (wblcdf ([x, NaN], single (1), 1), single ([y, NaN]))
-%!assert (wblcdf ([x, NaN], 1, single (1)), single ([y, NaN]))
-
-## Test input validation
-%!error wblcdf ()
-%!error wblcdf (1,2,3,4)
-%!error wblcdf (ones (3), ones (2), ones (2))
-%!error wblcdf (ones (2), ones (3), ones (2))
-%!error wblcdf (ones (2), ones (2), ones (3))
-%!error wblcdf (i, 2, 2)
-%!error wblcdf (2, i, 2)
-%!error wblcdf (2, 2, i)
diff --git a/scripts/statistics/distributions/wblinv.m b/scripts/statistics/distributions/wblinv.m
deleted file mode 100644
--- a/scripts/statistics/distributions/wblinv.m
+++ /dev/null
@@ -1,98 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} wblinv (@var{x})
-## @deftypefnx {} {} wblinv (@var{x}, @var{scale})
-## @deftypefnx {} {} wblinv (@var{x}, @var{scale}, @var{shape})
-## Compute the quantile (the inverse of the CDF) at @var{x} of the
-## Weibull distribution with scale parameter @var{scale} and
-## shape parameter @var{shape}.
-##
-## Default values are @var{scale} = 1, @var{shape} = 1.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Quantile function of the Weibull distribution
-
-function inv = wblinv (x, scale = 1, shape = 1)
-
-  if (nargin < 1 || nargin > 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (scale) || ! isscalar (shape))
-    [retval, x, scale, shape] = common_size (x, scale, shape);
-    if (retval > 0)
-      error ("wblinv: X, SCALE, and SHAPE must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (scale) || iscomplex (shape))
-    error ("wblinv: X, SCALE, and SHAPE must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (scale, "single") || isa (shape, "single"))
-    inv = NaN (size (x), "single");
-  else
-    inv = NaN (size (x));
-  endif
-
-  ok = (scale > 0) & (scale < Inf) & (shape > 0) & (shape < Inf);
-
-  k = (x == 0) & ok;
-  inv(k) = 0;
-
-  k = (x == 1) & ok;
-  inv(k) = Inf;
-
-  k = (x > 0) & (x < 1) & ok;
-  if (isscalar (scale) && isscalar (shape))
-    inv(k) = scale * (- log (1 - x(k))) .^ (1 / shape);
-  else
-    inv(k) = scale(k) .* (- log (1 - x(k))) .^ (1 ./ shape(k));
-  endif
-
-endfunction
-
-
-%!shared x
-%! x = [-1 0 0.63212055882855778 1 2];
-%!assert (wblinv (x, ones (1,5), ones (1,5)), [NaN 0 1 Inf NaN], eps)
-%!assert (wblinv (x, 1, ones (1,5)), [NaN 0 1 Inf NaN], eps)
-%!assert (wblinv (x, ones (1,5), 1), [NaN 0 1 Inf NaN], eps)
-%!assert (wblinv (x, [1 -1 NaN Inf 1], 1), [NaN NaN NaN NaN NaN])
-%!assert (wblinv (x, 1, [1 -1 NaN Inf 1]), [NaN NaN NaN NaN NaN])
-%!assert (wblinv ([x(1:2) NaN x(4:5)], 1, 1), [NaN 0 NaN Inf NaN])
-
-## Test class of input preserved
-%!assert (wblinv ([x, NaN], 1, 1), [NaN 0 1 Inf NaN NaN], eps)
-%!assert (wblinv (single ([x, NaN]), 1, 1), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
-%!assert (wblinv ([x, NaN], single (1), 1), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
-%!assert (wblinv ([x, NaN], 1, single (1)), single ([NaN 0 1 Inf NaN NaN]), eps ("single"))
-
-## Test input validation
-%!error wblinv ()
-%!error wblinv (1,2,3,4)
-%!error wblinv (ones (3), ones (2), ones (2))
-%!error wblinv (ones (2), ones (3), ones (2))
-%!error wblinv (ones (2), ones (2), ones (3))
-%!error wblinv (i, 2, 2)
-%!error wblinv (2, i, 2)
-%!error wblinv (2, 2, i)
diff --git a/scripts/statistics/distributions/wblpdf.m b/scripts/statistics/distributions/wblpdf.m
deleted file mode 100644
--- a/scripts/statistics/distributions/wblpdf.m
+++ /dev/null
@@ -1,113 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} wblpdf (@var{x})
-## @deftypefnx {} {} wblpdf (@var{x}, @var{scale})
-## @deftypefnx {} {} wblpdf (@var{x}, @var{scale}, @var{shape})
-## Compute the probability density function (PDF) at @var{x} of the
-## Weibull distribution with scale parameter @var{scale} and
-## shape parameter @var{shape}.
-##
-## This is given by
-## @tex
-## $$  {shape \over scale^{shape}} \cdot x^{shape-1} \cdot e^{-({x \over scale})^{shape}} $$
-## @end tex
-## @ifnottex
-##
-## @example
-## shape * scale^(-shape) * x^(shape-1) * exp (-(x/scale)^shape)
-## @end example
-##
-## @end ifnottex
-## @noindent
-## for @var{x} @geq{} 0.
-##
-## Default values are @var{scale} = 1, @var{shape} = 1.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: PDF of the Weibull distribution
-
-function pdf = wblpdf (x, scale = 1, shape = 1)
-
-  if (nargin < 1 || nargin > 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (scale) || ! isscalar (shape))
-    [retval, x, scale, shape] = common_size (x, scale, shape);
-    if (retval > 0)
-      error ("wblpdf: X, SCALE, and SHAPE must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (x) || iscomplex (scale) || iscomplex (shape))
-    error ("wblpdf: X, SCALE, and SHAPE must not be complex");
-  endif
-
-  if (isa (x, "single") || isa (scale, "single") || isa (shape, "single"))
-    pdf = NaN (size (x), "single");
-  else
-    pdf = NaN (size (x));
-  endif
-
-  ok = ((scale > 0) & (scale < Inf) & (shape > 0) & (shape < Inf));
-
-  k = (x < 0) & ok;
-  pdf(k) = 0;
-
-  k = (x >= 0) & (x < Inf) & ok;
-  if (isscalar (scale) && isscalar (shape))
-    pdf(k) = (shape * (scale .^ -shape)
-              .* (x(k) .^ (shape - 1))
-              .* exp (- (x(k) / scale) .^ shape));
-  else
-    pdf(k) = (shape(k) .* (scale(k) .^ -shape(k))
-              .* (x(k) .^ (shape(k) - 1))
-              .* exp (- (x(k) ./ scale(k)) .^ shape(k)));
-  endif
-
-endfunction
-
-
-%!shared x,y
-%! x = [-1 0 0.5 1 Inf];
-%! y = [0, exp(-x(2:4)), NaN];
-%!assert (wblpdf (x, ones (1,5), ones (1,5)), y)
-%!assert (wblpdf (x, 1, ones (1,5)), y)
-%!assert (wblpdf (x, ones (1,5), 1), y)
-%!assert (wblpdf (x, [0 NaN Inf 1 1], 1), [NaN NaN NaN y(4:5)])
-%!assert (wblpdf (x, 1, [0 NaN Inf 1 1]), [NaN NaN NaN y(4:5)])
-%!assert (wblpdf ([x, NaN], 1, 1), [y, NaN])
-
-## Test class of input preserved
-%!assert (wblpdf (single ([x, NaN]), 1, 1), single ([y, NaN]))
-%!assert (wblpdf ([x, NaN], single (1), 1), single ([y, NaN]))
-%!assert (wblpdf ([x, NaN], 1, single (1)), single ([y, NaN]))
-
-## Test input validation
-%!error wblpdf ()
-%!error wblpdf (1,2,3,4)
-%!error wblpdf (ones (3), ones (2), ones (2))
-%!error wblpdf (ones (2), ones (3), ones (2))
-%!error wblpdf (ones (2), ones (2), ones (3))
-%!error wblpdf (i, 2, 2)
-%!error wblpdf (2, i, 2)
-%!error wblpdf (2, 2, i)
diff --git a/scripts/statistics/distributions/wblrnd.m b/scripts/statistics/distributions/wblrnd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/wblrnd.m
+++ /dev/null
@@ -1,131 +0,0 @@
-## Copyright (C) 2012 Rik Wehbring
-## Copyright (C) 1995-2016 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn  {} {} wblrnd (@var{scale}, @var{shape})
-## @deftypefnx {} {} wblrnd (@var{scale}, @var{shape}, @var{r})
-## @deftypefnx {} {} wblrnd (@var{scale}, @var{shape}, @var{r}, @var{c}, @dots{})
-## @deftypefnx {} {} wblrnd (@var{scale}, @var{shape}, [@var{sz}])
-## Return a matrix of random samples from the Weibull distribution with
-## parameters @var{scale} and @var{shape}.
-##
-## When called with a single size argument, return a square matrix with
-## the dimension specified.  When called with more than one scalar argument the
-## first two arguments are taken as the number of rows and columns and any
-## further arguments specify additional matrix dimensions.  The size may also
-## be specified with a vector of dimensions @var{sz}.
-##
-## If no size arguments are given then the result matrix is the common size of
-## @var{scale} and @var{shape}.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Random deviates from the Weibull distribution
-
-function rnd = wblrnd (scale, shape, varargin)
-
-  if (nargin < 2)
-    print_usage ();
-  endif
-
-  if (! isscalar (scale) || ! isscalar (shape))
-    [retval, scale, shape] = common_size (scale, shape);
-    if (retval > 0)
-      error ("wblrnd: SCALE and SHAPE must be of common size or scalars");
-    endif
-  endif
-
-  if (iscomplex (scale) || iscomplex (shape))
-    error ("wblrnd: SCALE and SHAPE must not be complex");
-  endif
-
-  if (nargin == 2)
-    sz = size (scale);
-  elseif (nargin == 3)
-    if (isscalar (varargin{1}) && varargin{1} >= 0)
-      sz = [varargin{1}, varargin{1}];
-    elseif (isrow (varargin{1}) && all (varargin{1} >= 0))
-      sz = varargin{1};
-    else
-      error ("wblrnd: dimension vector must be row vector of non-negative integers");
-    endif
-  elseif (nargin > 3)
-    if (any (cellfun (@(x) (! isscalar (x) || x < 0), varargin)))
-      error ("wblrnd: dimensions must be non-negative integers");
-    endif
-    sz = [varargin{:}];
-  endif
-
-  if (! isscalar (scale) && ! isequal (size (scale), sz))
-    error ("wblrnd: SCALE and SHAPE must be scalar or of size SZ");
-  endif
-
-  if (isa (scale, "single") || isa (shape, "single"))
-    cls = "single";
-  else
-    cls = "double";
-  endif
-
-  if (isscalar (scale) && isscalar (shape))
-    if ((scale > 0) && (scale < Inf) && (shape > 0) && (shape < Inf))
-      rnd = scale * rande (sz, cls) .^ (1/shape);
-    else
-      rnd = NaN (sz, cls);
-    endif
-  else
-    rnd = scale .* rande (sz, cls) .^ (1./shape);
-
-    k = (scale <= 0) | (scale == Inf) | (shape <= 0) | (shape == Inf);
-    rnd(k) = NaN;
-  endif
-
-endfunction
-
-
-%!assert (size (wblrnd (1,2)), [1, 1])
-%!assert (size (wblrnd (ones (2,1), 2)), [2, 1])
-%!assert (size (wblrnd (ones (2,2), 2)), [2, 2])
-%!assert (size (wblrnd (1, 2*ones (2,1))), [2, 1])
-%!assert (size (wblrnd (1, 2*ones (2,2))), [2, 2])
-%!assert (size (wblrnd (1, 2, 3)), [3, 3])
-%!assert (size (wblrnd (1, 2, [4 1])), [4, 1])
-%!assert (size (wblrnd (1, 2, 4, 1)), [4, 1])
-
-## Test class of input preserved
-%!assert (class (wblrnd (1, 2)), "double")
-%!assert (class (wblrnd (single (1), 2)), "single")
-%!assert (class (wblrnd (single ([1 1]), 2)), "single")
-%!assert (class (wblrnd (1, single (2))), "single")
-%!assert (class (wblrnd (1, single ([2 2]))), "single")
-
-## Test input validation
-%!error wblrnd ()
-%!error wblrnd (1)
-%!error wblrnd (ones (3), ones (2))
-%!error wblrnd (ones (2), ones (3))
-%!error wblrnd (i, 2)
-%!error wblrnd (2, i)
-%!error wblrnd (1,2, -1)
-%!error wblrnd (1,2, ones (2))
-%!error wblrnd (1, 2, [2 -1 2])
-%!error wblrnd (1,2, 1, ones (2))
-%!error wblrnd (1,2, 1, -1)
-%!error wblrnd (ones (2,2), 2, 3)
-%!error wblrnd (ones (2,2), 2, [3, 2])
-%!error wblrnd (ones (2,2), 2, 2, 3)
diff --git a/scripts/statistics/distributions/wienrnd.m b/scripts/statistics/distributions/wienrnd.m
deleted file mode 100644
--- a/scripts/statistics/distributions/wienrnd.m
+++ /dev/null
@@ -1,56 +0,0 @@
-## Copyright (C) 1995-2017 Friedrich Leisch
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} wienrnd (@var{t}, @var{d}, @var{n})
-## Return a simulated realization of the @var{d}-dimensional Wiener Process
-## on the interval [0, @var{t}].
-##
-## If @var{d} is omitted, @var{d} = 1 is used.  The first column of the
-## return matrix contains time, the remaining columns contain the Wiener
-## process.
-##
-## The optional parameter @var{n} defines the number of summands used for
-## simulating the process over an interval of length 1.  If @var{n} is
-## omitted, @var{n} = 1000 is used.
-## @end deftypefn
-
-## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description: Simulate a Wiener process
-
-function retval = wienrnd (t, d, n)
-
-  if (nargin == 1)
-    d = 1;
-    n = 1000;
-  elseif (nargin == 2)
-    n = 1000;
-  elseif (nargin > 3)
-    print_usage ();
-  endif
-
-  if (! isscalar (t) || ! isscalar (d) || ! isscalar (n))
-    error ("wienrnd: T, D and N must all be positive integers");
-  endif
-
-  retval = randn (n * t, d);
-  retval = cumsum (retval) / sqrt (n);
-
-  retval = [((1: n*t)' / n), retval];
-
-endfunction
diff --git a/scripts/statistics/distributions/empirical_cdf.m b/scripts/statistics/empirical_cdf.m
rename from scripts/statistics/distributions/empirical_cdf.m
rename to scripts/statistics/empirical_cdf.m
diff --git a/scripts/statistics/distributions/empirical_inv.m b/scripts/statistics/empirical_inv.m
rename from scripts/statistics/distributions/empirical_inv.m
rename to scripts/statistics/empirical_inv.m
diff --git a/scripts/statistics/distributions/empirical_pdf.m b/scripts/statistics/empirical_pdf.m
rename from scripts/statistics/distributions/empirical_pdf.m
rename to scripts/statistics/empirical_pdf.m
diff --git a/scripts/statistics/distributions/empirical_rnd.m b/scripts/statistics/empirical_rnd.m
rename from scripts/statistics/distributions/empirical_rnd.m
rename to scripts/statistics/empirical_rnd.m
diff --git a/scripts/statistics/base/histc.m b/scripts/statistics/histc.m
rename from scripts/statistics/base/histc.m
rename to scripts/statistics/histc.m
diff --git a/scripts/statistics/base/iqr.m b/scripts/statistics/iqr.m
rename from scripts/statistics/base/iqr.m
rename to scripts/statistics/iqr.m
diff --git a/scripts/statistics/base/kendall.m b/scripts/statistics/kendall.m
rename from scripts/statistics/base/kendall.m
rename to scripts/statistics/kendall.m
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/kurtosis.m
rename from scripts/statistics/base/kurtosis.m
rename to scripts/statistics/kurtosis.m
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/mean.m
rename from scripts/statistics/base/mean.m
rename to scripts/statistics/mean.m
diff --git a/scripts/statistics/base/meansq.m b/scripts/statistics/meansq.m
rename from scripts/statistics/base/meansq.m
rename to scripts/statistics/meansq.m
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/median.m
rename from scripts/statistics/base/median.m
rename to scripts/statistics/median.m
diff --git a/scripts/statistics/base/mode.m b/scripts/statistics/mode.m
rename from scripts/statistics/base/mode.m
rename to scripts/statistics/mode.m
diff --git a/scripts/statistics/models/logistic_regression.m b/scripts/statistics/models/logistic_regression.m
deleted file mode 100644
--- a/scripts/statistics/models/logistic_regression.m
+++ /dev/null
@@ -1,192 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{theta}, @var{beta}, @var{dev}, @var{dl}, @var{d2l}, @var{p}] =} logistic_regression (@var{y}, @var{x}, @var{print}, @var{theta}, @var{beta})
-## Perform ordinal logistic regression.
-##
-## Suppose @var{y} takes values in @var{k} ordered categories, and let
-## @code{gamma_i (@var{x})} be the cumulative probability that @var{y}
-## falls in one of the first @var{i} categories given the covariate
-## @var{x}.  Then
-##
-## @example
-## [theta, beta] = logistic_regression (y, x)
-## @end example
-##
-## @noindent
-## fits the model
-##
-## @example
-## logit (gamma_i (x)) = theta_i - beta' * x,   i = 1 @dots{} k-1
-## @end example
-##
-## The number of ordinal categories, @var{k}, is taken to be the number
-## of distinct values of @code{round (@var{y})}.  If @var{k} equals 2,
-## @var{y} is binary and the model is ordinary logistic regression.  The
-## matrix @var{x} is assumed to have full column rank.
-##
-## Given @var{y} only, @code{theta = logistic_regression (y)}
-## fits the model with baseline logit odds only.
-##
-## The full form is
-##
-## @example
-## @group
-## [theta, beta, dev, dl, d2l, gamma]
-##    = logistic_regression (y, x, print, theta, beta)
-## @end group
-## @end example
-##
-## @noindent
-## in which all output arguments and all input arguments except @var{y}
-## are optional.
-##
-## Setting @var{print} to 1 requests summary information about the fitted
-## model to be displayed.  Setting @var{print} to 2 requests information
-## about convergence at each iteration.  Other values request no
-## information to be displayed.  The input arguments @var{theta} and
-## @var{beta} give initial estimates for @var{theta} and @var{beta}.
-##
-## The returned value @var{dev} holds minus twice the log-likelihood.
-##
-## The returned values @var{dl} and @var{d2l} are the vector of first
-## and the matrix of second derivatives of the log-likelihood with
-## respect to @var{theta} and @var{beta}.
-##
-## @var{p} holds estimates for the conditional distribution of @var{y}
-## given @var{x}.
-## @end deftypefn
-
-## Original for MATLAB written by Gordon K Smyth <gks@maths.uq.oz.au>,
-## U of Queensland, Australia, on Nov 19, 1990.  Last revision Aug 3,
-## 1992.
-
-## Author: Gordon K Smyth <gks@maths.uq.oz.au>,
-## Adapted-By: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Ordinal logistic regression
-
-## Uses the auxiliary functions logistic_regression_derivatives and
-## logistic_regression_likelihood.
-
-function [theta, beta, dev, dl, d2l, p] = logistic_regression (y, x, print, theta, beta)
-
-  ## check input
-  y = round (vec (y));
-  [my, ny] = size (y);
-  if (nargin < 2)
-    x = zeros (my, 0);
-  endif;
-  [mx, nx] = size (x);
-  if (mx != my)
-    error ("logistic_regression: X and Y must have the same number of observations");
-  endif
-
-  ## initial calculations
-  x = -x;
-  tol = 1e-6; incr = 10; decr = 2;
-  ymin = min (y); ymax = max (y); yrange = ymax - ymin;
-  z  = (y * ones (1, yrange)) == ((y * 0 + 1) * (ymin : (ymax - 1)));
-  z1 = (y * ones (1, yrange)) == ((y * 0 + 1) * ((ymin + 1) : ymax));
-  z  = z(:, any (z));
-  z1 = z1(:, any(z1));
-  [mz, nz] = size (z);
-
-  ## starting values
-  if (nargin < 3)
-    print = 0;
-  endif;
-  if (nargin < 4)
-    beta = zeros (nx, 1);
-  endif;
-  if (nargin < 5)
-    g = cumsum (sum (z))' ./ my;
-    theta = log (g ./ (1 - g));
-  endif;
-  tb = [theta; beta];
-
-  ## likelihood and derivatives at starting values
-  [g, g1, p, dev] = logistic_regression_likelihood (y, x, tb, z, z1);
-  [dl, d2l] = logistic_regression_derivatives (x, z, z1, g, g1, p);
-  epsilon = std (vec (d2l)) / 1000;
-
-  ## maximize likelihood using Levenberg modified Newton's method
-  iter = 0;
-  while (abs (dl' * (d2l \ dl) / length (dl)) > tol)
-    iter += 1;
-    tbold = tb;
-    devold = dev;
-    tb = tbold - d2l \ dl;
-    [g, g1, p, dev] = logistic_regression_likelihood (y, x, tb, z, z1);
-    if ((dev - devold) / (dl' * (tb - tbold)) < 0)
-      epsilon /= decr;
-    else
-      while ((dev - devold) / (dl' * (tb - tbold)) > 0)
-        epsilon *= incr;
-         if (epsilon > 1e+15)
-           error ("logistic_regression: epsilon too large");
-         endif
-         tb = tbold - (d2l - epsilon * eye (size (d2l))) \ dl;
-         [g, g1, p, dev] = logistic_regression_likelihood (y, x, tb, z, z1);
-         disp ("epsilon"); disp (epsilon);
-      endwhile
-    endif
-    [dl, d2l] = logistic_regression_derivatives (x, z, z1, g, g1, p);
-    if (print == 2)
-      disp ("Iteration"); disp (iter);
-      disp ("Deviance"); disp (dev);
-      disp ("First derivative"); disp (dl');
-      disp ("Eigenvalues of second derivative"); disp (eig (d2l)');
-    endif
-  endwhile
-
-  ## tidy up output
-
-  theta = tb(1 : nz, 1);
-  beta  = tb((nz + 1) : (nz + nx), 1);
-
-  if (print >= 1)
-    printf ("\n");
-    printf ("Logistic Regression Results:\n");
-    printf ("\n");
-    printf ("Number of Iterations: %d\n", iter);
-    printf ("Deviance:             %f\n", dev);
-    printf ("Parameter Estimates:\n");
-    printf ("     Theta         S.E.\n");
-    se = sqrt (diag (inv (-d2l)));
-    for i = 1 : nz
-      printf ("   %8.4f     %8.4f\n", tb (i), se (i));
-    endfor
-    if (nx > 0)
-      printf ("      Beta         S.E.\n");
-      for i = (nz + 1) : (nz + nx)
-        printf ("   %8.4f     %8.4f\n", tb (i), se (i));
-      endfor
-    endif
-  endif
-
-  if (nargout == 6)
-    if (nx > 0)
-      e = ((x * beta) * ones (1, nz)) + ((y * 0 + 1) * theta');
-    else
-      e = (y * 0 + 1) * theta';
-    endif
-    gamma = diff ([(y * 0), (exp (e) ./ (1 + exp (e))), (y * 0 + 1)]')';
-  endif
-
-endfunction
diff --git a/scripts/statistics/models/module.mk b/scripts/statistics/models/module.mk
deleted file mode 100644
--- a/scripts/statistics/models/module.mk
+++ /dev/null
@@ -1,26 +0,0 @@
-FCN_FILE_DIRS += \
-  scripts/statistics/models \
-  %reldir%/private
-
-%canon_reldir%_PRIVATE_FCN_FILES = \
-  %reldir%/private/logistic_regression_derivatives.m \
-  %reldir%/private/logistic_regression_likelihood.m
-
-%canon_reldir%_FCN_FILES = \
-  %reldir%/logistic_regression.m
-
-%canon_reldir%dir = $(fcnfiledir)/statistics/models
-
-%canon_reldir%_DATA = $(%canon_reldir%_FCN_FILES)
-
-%canon_reldir%_privatedir = $(fcnfiledir)/statistics/models/private
-
-%canon_reldir%_private_DATA = $(%canon_reldir%_PRIVATE_FCN_FILES)
-
-FCN_FILES += \
-  $(%canon_reldir%_FCN_FILES) \
-  $(%canon_reldir%_PRIVATE_FCN_FILES)
-
-PKG_ADD_FILES += %reldir%/PKG_ADD
-
-DIRSTAMP_FILES += %reldir%/$(octave_dirstamp)
diff --git a/scripts/statistics/models/private/logistic_regression_derivatives.m b/scripts/statistics/models/private/logistic_regression_derivatives.m
deleted file mode 100644
--- a/scripts/statistics/models/private/logistic_regression_derivatives.m
+++ /dev/null
@@ -1,44 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{dl}, @var{d2l}] =} logistic_regression_derivatives (@var{x}, @var{z}, @var{z1}, @var{g}, @var{g1}, @var{p})
-## Calculate derivatives of the log-likelihood for ordinal logistic regression
-## model.
-##
-## Private function called by @code{logistic_regression}.
-## @seealso{logistic_regression}
-## @end deftypefn
-
-## Author: Gordon K. Smyth <gks@maths.uq.oz.au>
-## Adapted-By: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Derivates of log-likelihood in logistic regression
-
-function [dl, d2l] = logistic_regression_derivatives (x, z, z1, g, g1, p)
-
-  ## first derivative
-  v = g .* (1 - g) ./ p; v1 = g1 .* (1 - g1) ./ p;
-  dlogp = [(diag (v) * z - diag (v1) * z1), (diag (v - v1) * x)];
-  dl = sum (dlogp)';
-
-  ## second derivative
-  w = v .* (1 - 2 * g); w1 = v1 .* (1 - 2 * g1);
-  d2l = [z, x]' * diag (w) * [z, x] - [z1, x]' * diag (w1) * [z1, x] ...
-      - dlogp' * dlogp;
-
-endfunction
diff --git a/scripts/statistics/models/private/logistic_regression_likelihood.m b/scripts/statistics/models/private/logistic_regression_likelihood.m
deleted file mode 100644
--- a/scripts/statistics/models/private/logistic_regression_likelihood.m
+++ /dev/null
@@ -1,40 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{g}, @var{g1}, @var{p}, @var{dev}] =} logistic_regression_likelihood (@var{y}, @var{x}, @var{beta}, @var{z}, @var{z1})
-## Calculate the likelihood for the ordinal logistic regression model.
-##
-## Private function called by @code{logistic_regression}.
-## @seealso{logistic_regression}
-## @end deftypefn
-
-## Author: Gordon K. Smyth <gks@maths.uq.oz.au>
-## Adapted-By: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Likelihood in logistic regression
-
-function [g, g1, p, dev] = logistic_regression_likelihood (y, x, beta, z, z1)
-
-  e = exp ([z, x] * beta); e1 = exp ([z1, x] * beta);
-  g = e ./ (1 + e); g1 = e1 ./ (1 + e1);
-  g = max (y == max (y), g); g1 = min (y > min (y), g1);
-
-  p = g - g1;
-  dev = -2 * sum (log (p));
-
-endfunction
diff --git a/scripts/statistics/base/module.mk b/scripts/statistics/module.mk
rename from scripts/statistics/base/module.mk
rename to scripts/statistics/module.mk
--- a/scripts/statistics/base/module.mk
+++ b/scripts/statistics/module.mk
@@ -1,44 +1,48 @@
-FCN_FILE_DIRS += scripts/statistics/base
+FCN_FILE_DIRS += scripts/statistics
 
 %canon_reldir%_FCN_FILES = \
   %reldir%/center.m \
-  %reldir%/cloglog.m \
+  %reldir%/corrcoef.m \
   %reldir%/corr.m \
-  %reldir%/corrcoef.m \
   %reldir%/cov.m \
-  %reldir%/crosstab.m \
+  %reldir%/discrete_cdf.m \
+  %reldir%/discrete_inv.m \
+  %reldir%/discrete_pdf.m \
+  %reldir%/discrete_rnd.m \
+  %reldir%/empirical_cdf.m \
+  %reldir%/empirical_inv.m \
+  %reldir%/empirical_pdf.m \
+  %reldir%/empirical_rnd.m \
   %reldir%/histc.m \
   %reldir%/iqr.m \
   %reldir%/kendall.m \
   %reldir%/kurtosis.m \
-  %reldir%/logit.m \
   %reldir%/mean.m \
   %reldir%/meansq.m \
   %reldir%/median.m \
   %reldir%/mode.m \
   %reldir%/moment.m \
-  %reldir%/ppplot.m \
   %reldir%/prctile.m \
-  %reldir%/probit.m \
-  %reldir%/qqplot.m \
   %reldir%/quantile.m \
   %reldir%/range.m \
   %reldir%/ranks.m \
   %reldir%/run_count.m \
   %reldir%/runlength.m \
   %reldir%/skewness.m \
   %reldir%/spearman.m \
   %reldir%/statistics.m \
   %reldir%/std.m \
   %reldir%/var.m \
   %reldir%/zscore.m
 
-%canon_reldir%dir = $(fcnfiledir)/statistics/base
+%canon_reldir%dir = $(fcnfiledir)/statistics
 
 %canon_reldir%_DATA = $(%canon_reldir%_FCN_FILES)
 
-FCN_FILES += $(%canon_reldir%_FCN_FILES)
+FCN_FILES += \
+  $(%canon_reldir%_FCN_FILES) \
+  $(%canon_reldir%_PRIVATE_FCN_FILES)
 
 PKG_ADD_FILES += %reldir%/PKG_ADD
 
 DIRSTAMP_FILES += %reldir%/$(octave_dirstamp)
diff --git a/scripts/statistics/base/moment.m b/scripts/statistics/moment.m
rename from scripts/statistics/base/moment.m
rename to scripts/statistics/moment.m
diff --git a/scripts/statistics/base/prctile.m b/scripts/statistics/prctile.m
rename from scripts/statistics/base/prctile.m
rename to scripts/statistics/prctile.m
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/quantile.m
rename from scripts/statistics/base/quantile.m
rename to scripts/statistics/quantile.m
diff --git a/scripts/statistics/base/range.m b/scripts/statistics/range.m
rename from scripts/statistics/base/range.m
rename to scripts/statistics/range.m
diff --git a/scripts/statistics/base/ranks.m b/scripts/statistics/ranks.m
rename from scripts/statistics/base/ranks.m
rename to scripts/statistics/ranks.m
diff --git a/scripts/statistics/base/run_count.m b/scripts/statistics/run_count.m
rename from scripts/statistics/base/run_count.m
rename to scripts/statistics/run_count.m
diff --git a/scripts/statistics/base/runlength.m b/scripts/statistics/runlength.m
rename from scripts/statistics/base/runlength.m
rename to scripts/statistics/runlength.m
diff --git a/scripts/statistics/base/skewness.m b/scripts/statistics/skewness.m
rename from scripts/statistics/base/skewness.m
rename to scripts/statistics/skewness.m
diff --git a/scripts/statistics/base/spearman.m b/scripts/statistics/spearman.m
rename from scripts/statistics/base/spearman.m
rename to scripts/statistics/spearman.m
diff --git a/scripts/statistics/base/statistics.m b/scripts/statistics/statistics.m
rename from scripts/statistics/base/statistics.m
rename to scripts/statistics/statistics.m
diff --git a/scripts/statistics/base/std.m b/scripts/statistics/std.m
rename from scripts/statistics/base/std.m
rename to scripts/statistics/std.m
diff --git a/scripts/statistics/tests/anova.m b/scripts/statistics/tests/anova.m
deleted file mode 100644
--- a/scripts/statistics/tests/anova.m
+++ /dev/null
@@ -1,111 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{f}, @var{df_b}, @var{df_w}] =} anova (@var{y}, @var{g})
-## Perform a one-way analysis of variance (ANOVA).
-##
-## The goal is to test whether the population means of data taken from
-## @var{k} different groups are all equal.
-##
-## Data may be given in a single vector @var{y} with groups specified by a
-## corresponding vector of group labels @var{g} (e.g., numbers from 1 to
-## @var{k}).  This is the general form which does not impose any restriction
-## on the number of data in each group or the group labels.
-##
-## If @var{y} is a matrix and @var{g} is omitted, each column of @var{y} is
-## treated as a group.  This form is only appropriate for balanced ANOVA in
-## which the numbers of samples from each group are all equal.
-##
-## Under the null of constant means, the statistic @var{f} follows an F
-## distribution with @var{df_b} and @var{df_w} degrees of freedom.
-##
-## The p-value (1 minus the CDF of this distribution at @var{f}) is returned
-## in @var{pval}.
-##
-## If no output argument is given, the standard one-way ANOVA table is printed.
-## @seealso{manova}
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: One-way analysis of variance (ANOVA)
-
-function [pval, f, df_b, df_w] = anova (y, g)
-
-  if (nargin < 1 || nargin > 2)
-    print_usage ();
-  elseif (nargin == 1)
-    if (isvector (y))
-      error ("anova: for 'anova (Y)', Y must not be a vector");
-    endif
-    [group_count, k] = size (y);
-    n = group_count * k;
-    group_mean = mean (y);
-  else
-    if (! isvector (y))
-      error ("anova: for 'anova (Y, G)', Y must be a vector");
-    endif
-    n = length (y);
-    if (! isvector (g) || (length (g) != n))
-      error ("anova: G must be a vector of the same length as Y");
-    endif
-    s = sort (g);
-    i = find (s (2 : n) > s(1 : (n-1)));
-    k = length (i) + 1;
-    if (k == 1)
-      error ("anova: there should be at least 2 groups");
-    else
-      group_label = s ([1, (reshape (i, 1, k-1) + 1)]);
-    endif
-    for i = 1 : k;
-      v = y (find (g == group_label (i)));
-      group_count (i) = length (v);
-      group_mean (i) = mean (v);
-    endfor
-
-  endif
-
-  total_mean = mean (y(:));
-  SSB = sum (group_count .* (group_mean - total_mean) .^ 2);
-  SST = sumsq (reshape (y, n, 1) - total_mean);
-  SSW = SST - SSB;
-  df_b = k - 1;
-  df_w = n - k;
-  v_b = SSB / df_b;
-  v_w = SSW / df_w;
-  f = v_b / v_w;
-  pval = 1 - fcdf (f, df_b, df_w);
-
-  if (nargout == 0)
-    ## This eventually needs to be done more cleanly ...
-    printf ("\n");
-    printf ("One-way ANOVA Table:\n");
-    printf ("\n");
-    printf ("Source of Variation   Sum of Squares    df  Empirical Var\n");
-    printf ("*********************************************************\n");
-    printf ("Between Groups       %15.4f  %4d  %13.4f\n", SSB, df_b, v_b);
-    printf ("Within Groups        %15.4f  %4d  %13.4f\n", SSW, df_w, v_w);
-    printf ("---------------------------------------------------------\n");
-    printf ("Total                %15.4f  %4d\n", SST, n - 1);
-    printf ("\n");
-    printf ("Test Statistic f     %15.4f\n", f);
-    printf ("p-value              %15.4f\n", pval);
-    printf ("\n");
-  endif
-
-endfunction
diff --git a/scripts/statistics/tests/bartlett_test.m b/scripts/statistics/tests/bartlett_test.m
deleted file mode 100644
--- a/scripts/statistics/tests/bartlett_test.m
+++ /dev/null
@@ -1,67 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{chisq}, @var{df}] =} bartlett_test (@var{x1}, @dots{})
-## Perform a Bartlett test for the homogeneity of variances in the data
-## vectors @var{x1}, @var{x2}, @dots{}, @var{xk}, where @var{k} > 1.
-##
-## Under the null of equal variances, the test statistic @var{chisq}
-## approximately follows a chi-square distribution with @var{df} degrees of
-## freedom.
-##
-## The p-value (1 minus the CDF of this distribution at @var{chisq}) is
-## returned in @var{pval}.
-##
-## If no output argument is given, the p-value is displayed.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Bartlett test for homogeneity of variances
-
-function [pval, chisq, df] = bartlett_test (varargin)
-
-  k = nargin;
-  if (k < 2)
-    print_usage ();
-  endif
-
-  f = zeros (k, 1);
-  v = zeros (k, 1);
-
-  for i = 1 : k;
-    x = varargin{i};
-    if (! isvector (x))
-      error ("bartlett_test: all arguments must be vectors");
-    endif
-    f(i) = length (x) - 1;
-    v(i) = var (x);
-  endfor
-
-  f_tot = sum (f);
-  v_tot = sum (f .* v) / f_tot;
-  c     = 1 + (sum (1 ./ f) - 1 / f_tot) / (3 * (k - 1));
-  chisq = (f_tot * log (v_tot) - sum (f .* log (v))) / c;
-  df    = k;
-  pval  = 1 - chi2cdf (chisq, df);
-
-  if (nargout == 0)
-    printf ("  pval: %g\n", pval);
-  endif
-
-endfunction
diff --git a/scripts/statistics/tests/chisquare_test_homogeneity.m b/scripts/statistics/tests/chisquare_test_homogeneity.m
deleted file mode 100644
--- a/scripts/statistics/tests/chisquare_test_homogeneity.m
+++ /dev/null
@@ -1,68 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{chisq}, @var{df}] =} chisquare_test_homogeneity (@var{x}, @var{y}, @var{c})
-## Given two samples @var{x} and @var{y}, perform a chisquare test for
-## homogeneity of the null hypothesis that @var{x} and @var{y} come from
-## the same distribution, based on the partition induced by the
-## (strictly increasing) entries of @var{c}.
-##
-## For large samples, the test statistic @var{chisq} approximately follows a
-## chisquare distribution with @var{df} = @code{length (@var{c})} degrees of
-## freedom.
-##
-## The p-value (1 minus the CDF of this distribution at @var{chisq}) is
-## returned in @var{pval}.
-##
-## If no output argument is given, the p-value is displayed.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Chi-square test for homogeneity
-
-function [pval, chisq, df] = chisquare_test_homogeneity (x, y, c)
-
-  if (nargin != 3)
-    print_usage ();
-  endif
-
-  if (! (isvector (x) && isvector (y) && isvector (c)))
-    error ("chisquare_test_homogeneity: X, Y and C must be vectors");
-  endif
-  ## Now test c for strictly increasing entries
-  df = length (c);
-  if (any ((c(2 : df) - c(1 : (df - 1))) <= 0))
-    error ("chisquare_test_homogeneity: C must be increasing");
-  endif
-
-  c     = [(reshape (c, 1, df)), Inf];
-  l_x   = length (x);
-  x     = reshape (x, l_x, 1);
-  n_x   = sum (x * ones (1, df+1) < ones (l_x, 1) * c);
-  l_y   = length (y);
-  y     = reshape (y, l_y, 1);
-  n_y   = sum (y * ones (1, df+1) < ones (l_y, 1) * c);
-  chisq = l_x * l_y * sum ((n_x/l_x - n_y/l_y).^2 ./ (n_x + n_y));
-  pval  = 1 - chi2cdf (chisq, df);
-
-  if (nargout == 0)
-    printf ("  pval: %g\n", pval);
-  endif
-
-endfunction
diff --git a/scripts/statistics/tests/chisquare_test_independence.m b/scripts/statistics/tests/chisquare_test_independence.m
deleted file mode 100644
--- a/scripts/statistics/tests/chisquare_test_independence.m
+++ /dev/null
@@ -1,54 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{chisq}, @var{df}] =} chisquare_test_independence (@var{x})
-## Perform a chi-square test for independence based on the contingency table
-## @var{x}.
-##
-## Under the null hypothesis of independence, @var{chisq} approximately has a
-## chi-square distribution with @var{df} degrees of freedom.
-##
-## The p-value (1 minus the CDF of this distribution at chisq) of the test is
-## returned in @var{pval}.
-##
-## If no output argument is given, the p-value is displayed.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Chi-square test for independence
-
-function [pval, chisq, df] = chisquare_test_independence (x)
-
-  if (nargin != 1)
-    print_usage ();
-  endif
-
-  [r, s] = size (x);
-  df = (r - 1) * (s - 1);
-  n = sum (sum (x));
-  y = sum (x')' * sum (x) / n;
-  x = (x - y) .^2 ./ y;
-  chisq = sum (sum (x));
-  pval = 1 - chi2cdf (chisq, df);
-
-  if (nargout == 0)
-    printf ("  pval: %g\n", pval);
-  endif
-
-endfunction
diff --git a/scripts/statistics/tests/cor_test.m b/scripts/statistics/tests/cor_test.m
deleted file mode 100644
--- a/scripts/statistics/tests/cor_test.m
+++ /dev/null
@@ -1,135 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} cor_test (@var{x}, @var{y}, @var{alt}, @var{method})
-## Test whether two samples @var{x} and @var{y} come from uncorrelated
-## populations.
-##
-## The optional argument string @var{alt} describes the alternative
-## hypothesis, and can be @qcode{"!="} or @qcode{"<>"} (nonzero), @qcode{">"}
-## (greater than 0), or @qcode{"<"} (less than 0).  The default is the
-## two-sided case.
-##
-## The optional argument string @var{method} specifies which correlation
-## coefficient to use for testing.  If @var{method} is @qcode{"pearson"}
-## (default), the (usual) Pearson's product moment correlation coefficient is
-## used.  In this case, the data should come from a bivariate normal
-## distribution.  Otherwise, the other two methods offer nonparametric
-## alternatives.  If @var{method} is @qcode{"kendall"}, then Kendall's rank
-## correlation tau is used.  If @var{method} is @qcode{"spearman"}, then
-## Spearman's rank correlation rho is used.  Only the first character is
-## necessary.
-##
-## The output is a structure with the following elements:
-##
-## @table @var
-## @item pval
-## The p-value of the test.
-##
-## @item stat
-## The value of the test statistic.
-##
-## @item dist
-## The distribution of the test statistic.
-##
-## @item params
-## The parameters of the null distribution of the test statistic.
-##
-## @item alternative
-## The alternative hypothesis.
-##
-## @item method
-## The method used for testing.
-## @end table
-##
-## If no output argument is given, the p-value is displayed.
-## @end deftypefn
-
-## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Adapted-by: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Test for zero correlation
-
-function t = cor_test (x, y, alt, method)
-
-  if (nargin < 2 || nargin > 4)
-    print_usage ();
-  endif
-
-  if (! isvector (x) || ! isvector (y) || length (x) != length (y))
-    error ("cor_test: X and Y must be vectors of the same length");
-  endif
-
-  if (nargin < 3)
-    alt = "!=";
-  elseif (! ischar (alt))
-    error ("cor_test: ALT must be a string");
-  endif
-
-  if (nargin < 4)
-    method = "pearson";
-  elseif (! ischar (method))
-    error ("cor_test: METHOD must be a string");
-  endif
-
-  n = length (x);
-  m = method(1);
-
-  if (m == "p")
-    r = corr (x, y);
-    df = n - 2;
-    t.method = "Pearson's product moment correlation";
-    t.params = df;
-    t.stat = sqrt (df) .* r / sqrt (1 - r.^2);
-    t.dist = "t";
-    cdf = tcdf (t.stat, df);
-  elseif (m == "k")
-    tau = kendall (x, y);
-    t.method = "Kendall's rank correlation tau";
-    t.params = [];
-    t.stat = tau / sqrt ((2 * (2*n+5)) / (9*n*(n-1)));
-    t.dist = "stdnormal";
-    cdf = stdnormal_cdf (t.stat);
-  elseif (m == "s")
-    rho = spearman (x, y);
-    t.method = "Spearman's rank correlation rho";
-    t.params = [];
-    t.stat = sqrt (n-1) * (rho - 6/(n^3-n));
-    t.dist = "stdnormal";
-    cdf = stdnormal_cdf (t.stat);
-  else
-    error ("cor_test: METHOD '%s' not recognized", method);
-  endif
-
-  if (strcmp (alt, "!=") || strcmp (alt, "<>"))
-    t.pval = 2 * min (cdf, 1 - cdf);
-  elseif (strcmp (alt, ">"))
-    t.pval = 1 - cdf;
-  elseif (strcmp (alt, "<"))
-    t.pval = cdf;
-  else
-    error ("cor_test: alternative '%s' not recognized", alt);
-  endif
-
-  t.alternative = alt;
-
-  if (nargout == 0)
-    printf ("pval: %g\n", t.pval);
-  endif
-
-endfunction
diff --git a/scripts/statistics/tests/f_test_regression.m b/scripts/statistics/tests/f_test_regression.m
deleted file mode 100644
--- a/scripts/statistics/tests/f_test_regression.m
+++ /dev/null
@@ -1,77 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{f}, @var{df_num}, @var{df_den}] =} f_test_regression (@var{y}, @var{x}, @var{rr}, @var{r})
-## Perform an F test for the null hypothesis @nospell{rr * b = r} in a
-## classical normal regression model y = X * b + e.
-##
-## Under the null, the test statistic @var{f} follows an F distribution with
-## @var{df_num} and @var{df_den} degrees of freedom.
-##
-## The p-value (1 minus the CDF of this distribution at @var{f}) is returned
-## in @var{pval}.
-##
-## If not given explicitly, @var{r} = 0.
-##
-## If no output argument is given, the p-value is displayed.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Test linear hypotheses in linear regression model
-
-function [pval, f, df_num, df_den] = f_test_regression (y, x, rr, r)
-
-  if (nargin < 3 || nargin > 4)
-    print_usage ();
-  endif
-
-  [T, k] = size (x);
-  if (! (isvector (y) && (length (y) == T)))
-    error ("f_test_regression: Y must be a vector of length rows (X)");
-  endif
-  y = reshape (y, T, 1);
-
-  [q, c_R ] = size (rr);
-  if (c_R != k)
-    error ("f_test_regression: RR must have as many columns as X");
-  endif
-
-  if (nargin == 4)
-    s_r = size (r);
-    if ((min (s_r) != 1) || (max (s_r) != q))
-      error ("f_test_regression: R must be a vector of length rows (RR)");
-    endif
-    r = reshape (r, q, 1);
-  else
-    r = zeros (q, 1);
-  endif
-
-  df_num = q;
-  df_den = T - k;
-
-  [b, v] = ols (y, x);
-  diff   = rr * b - r;
-  f      = diff' * inv (rr * inv (x' * x) * rr') * diff / (q * v);
-  pval   = 1 - fcdf (f, df_num, df_den);
-
-  if (nargout == 0)
-    printf ("  pval: %g\n", pval);
-  endif
-
-endfunction
diff --git a/scripts/statistics/tests/hotelling_test.m b/scripts/statistics/tests/hotelling_test.m
deleted file mode 100644
--- a/scripts/statistics/tests/hotelling_test.m
+++ /dev/null
@@ -1,72 +0,0 @@
-## Copyright (C) 1996-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{tsq}] =} hotelling_test (@var{x}, @var{m})
-## For a sample @var{x} from a multivariate normal distribution with unknown
-## mean and covariance matrix, test the null hypothesis that
-## @code{mean (@var{x}) == @var{m}}.
-##
-## Hotelling's @math{T^2} is returned in @var{tsq}.  Under the null,
-## @math{(n-p) T^2 / (p(n-1))} has an F distribution with @math{p} and
-## @math{n-p} degrees of freedom, where @math{n} and @math{p} are the
-## numbers of samples and variables, respectively.
-##
-## The p-value of the test is returned in @var{pval}.
-##
-## If no output argument is given, the p-value of the test is displayed.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Test for mean of a multivariate normal
-
-function [pval, Tsq] = hotelling_test (x, m)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (isvector (x))
-    if (! isscalar (m))
-      error ("hotelling_test: if X is a vector, M must be a scalar");
-    endif
-    n = length (x);
-    p = 1;
-  elseif (ismatrix (x))
-    [n, p] = size (x);
-    if (n <= p)
-      error ("hotelling_test: X must have more rows than columns");
-    endif
-    if (isvector (m) && length (m) == p)
-      m = reshape (m, 1, p);
-    else
-      error ("hotelling_test: if X is a matrix, M must be a vector of length columns (X)");
-    endif
-  else
-    error ("hotelling_test: X must be a matrix or vector");
-  endif
-
-  d    = mean (x) - m;
-  Tsq  = n * d * (cov (x) \ d');
-  pval = 1 - fcdf ((n-p) * Tsq / (p * (n-1)), p, n-p);
-
-  if (nargout == 0)
-    printf ("  pval: %g\n", pval);
-  endif
-
-endfunction
diff --git a/scripts/statistics/tests/hotelling_test_2.m b/scripts/statistics/tests/hotelling_test_2.m
deleted file mode 100644
--- a/scripts/statistics/tests/hotelling_test_2.m
+++ /dev/null
@@ -1,86 +0,0 @@
-## Copyright (C) 1996-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{tsq}] =} hotelling_test_2 (@var{x}, @var{y})
-## For two samples @var{x} from multivariate normal distributions with
-## the same number of variables (columns), unknown means and unknown
-## equal covariance matrices, test the null hypothesis @code{mean
-## (@var{x}) == mean (@var{y})}.
-##
-## Hotelling's two-sample @math{T^2} is returned in @var{tsq}.  Under the null,
-## @tex
-## $$
-## {(n_x+n_y-p-1) T^2 \over p(n_x+n_y-2)}
-## $$
-## @end tex
-## @ifnottex
-##
-## @example
-## (n_x+n_y-p-1) T^2 / (p(n_x+n_y-2))
-## @end example
-##
-## @end ifnottex
-## @noindent
-## has an F distribution with @math{p} and @math{n_x+n_y-p-1} degrees of
-## freedom, where @math{n_x} and @math{n_y} are the sample sizes and
-## @math{p} is the number of variables.
-##
-## The p-value of the test is returned in @var{pval}.
-##
-## If no output argument is given, the p-value of the test is displayed.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Compare means of two multivariate normals
-
-function [pval, Tsq] = hotelling_test_2 (x, y)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (isvector (x))
-    n_x = length (x);
-    if (! isvector (y))
-      error ("hotelling_test_2: if X is a vector, Y must also be a vector");
-    else
-      n_y = length (y);
-      p   = 1;
-    endif
-  elseif (ismatrix (x))
-    [n_x, p] = size (x);
-    [n_y, q] = size (y);
-    if (p != q)
-      error ("hotelling_test_2: X and Y must have the same number of columns");
-    endif
-  else
-    error ("hotelling_test_2: X and Y must be matrices (or vectors)");
-  endif
-
-  d    = mean (x) - mean (y);
-  S    = ((n_x - 1) * cov (x) + (n_y - 1) * cov (y)) / (n_x + n_y - 2);
-  Tsq  = (n_x * n_y / (n_x + n_y)) * d * (S \ d');
-  pval = 1 - fcdf ((n_x + n_y - p - 1) * Tsq / (p * (n_x + n_y - 2)),
-                    p, n_x + n_y - p - 1);
-
-  if (nargout == 0)
-    printf ("  pval: %g\n", pval);
-  endif
-
-endfunction
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test.m b/scripts/statistics/tests/kolmogorov_smirnov_test.m
deleted file mode 100644
--- a/scripts/statistics/tests/kolmogorov_smirnov_test.m
+++ /dev/null
@@ -1,127 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{ks}] =} kolmogorov_smirnov_test (@var{x}, @var{dist}, @var{params}, @var{alt})
-## Perform a Kolmogorov-Smirnov test of the null hypothesis that the
-## sample @var{x} comes from the (continuous) distribution @var{dist}.
-##
-## if F and G are the CDFs corresponding to the sample and dist,
-## respectively, then the null is that F == G.
-##
-## The optional argument @var{params} contains a list of parameters of
-## @var{dist}.  For example, to test whether a sample @var{x} comes from
-## a uniform distribution on [2,4], use
-##
-## @example
-## kolmogorov_smirnov_test (x, "unif", 2, 4)
-## @end example
-##
-## @noindent
-## @var{dist} can be any string for which a function @var{distcdf}
-## that calculates the CDF of distribution @var{dist} exists.
-##
-## With the optional argument string @var{alt}, the alternative of interest
-## can be selected.  If @var{alt} is @qcode{"!="} or @qcode{"<>"}, the null
-## is tested against the two-sided alternative F != G@.  In this case, the
-## test statistic @var{ks} follows a two-sided Kolmogorov-Smirnov
-## distribution.  If @var{alt} is @qcode{">"}, the one-sided alternative F >
-## G is considered.  Similarly for @qcode{"<"}, the one-sided alternative F >
-## G is considered.  In this case, the test statistic @var{ks} has a
-## one-sided Kolmogorov-Smirnov distribution.  The default is the two-sided
-## case.
-##
-## The p-value of the test is returned in @var{pval}.
-##
-## If no output argument is given, the p-value is displayed.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: One-sample Kolmogorov-Smirnov test
-
-function [pval, ks] = kolmogorov_smirnov_test (x, dist, varargin)
-
-  if (nargin < 2)
-    print_usage ();
-  endif
-
-  if (! isvector (x))
-    error ("kolmogorov_smirnov_test: X must be a vector");
-  endif
-
-  n = length (x);
-  s = sort (x);
-  try
-    f = str2func (sprintf ("%scdf", dist));
-  catch
-    try
-      f = str2func (sprintf ("%s_cdf", dist));
-    catch
-      error ("kolmogorov_smirnov_test: no %scdf or %s_cdf function found",
-             dist, dist);
-    end_try_catch
-  end_try_catch
-
-  alt = "!=";
-
-  args{1} = s;
-  nvargs = numel (varargin);
-  if (nvargs > 0)
-    if (ischar (varargin{end}))
-      alt = varargin{end};
-      args(2:nvargs) = varargin(1:end-1);
-    else
-      args(2:nvargs+1) = varargin;
-    endif
-  endif
-
-  z = reshape (feval (f, args{:}), 1, n);
-
-  if (strcmp (alt, "!=") || strcmp (alt, "<>"))
-    ks   = sqrt (n) * max (max ([abs(z - (0:(n-1))/n); abs(z - (1:n)/n)]));
-    pval = 1 - kolmogorov_smirnov_cdf (ks);
-  elseif (strcmp (alt, ">"))
-    ks   = sqrt (n) * max (max ([z - (0:(n-1))/n; z - (1:n)/n]));
-    pval = exp (- 2 * ks^2);
-  elseif (strcmp (alt, "<"))
-    ks   = - sqrt (n) * min (min ([z - (0:(n-1))/n; z - (1:n)/n]));
-    pval = exp (- 2 * ks^2);
-  else
-    error ("kolmogorov_smirnov_test: alternative %s not recognized", alt);
-  endif
-
-  if (nargout == 0)
-    printf ("pval: %g\n", pval);
-  endif
-
-endfunction
-
-
-## test for recognition of unifcdf function
-%!assert (kolmogorov_smirnov_test (0:100, "unif", 0, 100), 1.0, eps)
-## test for recognition of logistic_cdf function
-%!assert (kolmogorov_smirnov_test (0:100, "logistic"), 0)
-## test for F < G
-%!assert (kolmogorov_smirnov_test (50:100, "unif", 0, 50, "<"))
-
-%!error kolmogorov_smirnov_test (1)
-%!error <X must be a vector> kolmogorov_smirnov_test ({}, "unif", 2, 4)
-%!error <no not_a_distcdf or not_a_dist_cdf function found>
-%! kolmogorov_smirnov_test (1, "not_a_dist");
-%!error <alternative foo not recognized>
-%! kolmogorov_smirnov_test (1, "unif", 2, 4, "foo");
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
deleted file mode 100644
--- a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
+++ /dev/null
@@ -1,104 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{ks}, @var{d}] =} kolmogorov_smirnov_test_2 (@var{x}, @var{y}, @var{alt})
-## Perform a 2-sample Kolmogorov-Smirnov test of the null hypothesis that the
-## samples @var{x} and @var{y} come from the same (continuous) distribution.
-##
-## If F and G are the CDFs corresponding to the @var{x} and @var{y} samples,
-## respectively, then the null is that F == G.
-##
-## With the optional argument string @var{alt}, the alternative of interest
-## can be selected.  If @var{alt} is @qcode{"!="} or @qcode{"<>"}, the null
-## is tested against the two-sided alternative F != G@.  In this case, the
-## test statistic @var{ks} follows a two-sided Kolmogorov-Smirnov
-## distribution.  If @var{alt} is @qcode{">"}, the one-sided alternative F >
-## G is considered.  Similarly for @qcode{"<"}, the one-sided alternative F <
-## G is considered.  In this case, the test statistic @var{ks} has a
-## one-sided Kolmogorov-Smirnov distribution.  The default is the two-sided
-## case.
-##
-## The p-value of the test is returned in @var{pval}.
-##
-## The third returned value, @var{d}, is the test statistic, the maximum
-## vertical distance between the two cumulative distribution functions.
-##
-## If no output argument is given, the p-value is displayed.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Two-sample Kolmogorov-Smirnov test
-
-function [pval, ks, d] = kolmogorov_smirnov_test_2 (x, y, alt)
-
-  if (nargin < 2 || nargin > 3)
-    print_usage ();
-  endif
-
-  if (! (isvector (x) && isvector (y)))
-    error ("kolmogorov_smirnov_test_2: both X and Y must be vectors");
-  endif
-
-  if (nargin == 2)
-    alt = "!=";
-  else
-    if (! ischar (alt))
-      error ("kolmogorov_smirnov_test_2: ALT must be a string");
-    endif
-  endif
-
-  n_x = length (x);
-  n_y = length (y);
-  n   = n_x * n_y / (n_x + n_y);
-  x   = reshape (x, n_x, 1);
-  y   = reshape (y, n_y, 1);
-  [s, i] = sort ([x; y]);
-  count (find (i <= n_x)) = 1 / n_x;
-  count (find (i > n_x)) = - 1 / n_y;
-
-  z = cumsum (count);
-  ds = diff (s);
-  if (any (ds == 0))
-    ## There are some ties, so keep only those changes.
-    warning ("kolmogorov_smirnov_test_2: cannot compute correct p-values with ties");
-    elems = [find(ds); n_x+n_y];
-    z = z(elems);
-  endif
-
-  if (strcmp (alt, "!=") || strcmp (alt, "<>"))
-    d    = max (abs (z));
-    ks   = sqrt (n) * d;
-    pval = 1 - kolmogorov_smirnov_cdf (ks);
-  elseif (strcmp (alt, ">"))
-    d    = max (z);
-    ks   = sqrt (n) * d;
-    pval = exp (-2 * ks^2);
-  elseif (strcmp (alt, "<"))
-    d    = min (z);
-    ks   = -sqrt (n) * d;
-    pval = exp (-2 * ks^2);
-  else
-    error ("kolmogorov_smirnov_test_2: option %s not recognized", alt);
-  endif
-
-  if (nargout == 0)
-    printf ("  pval: %g\n", pval);
-  endif
-
-endfunction
diff --git a/scripts/statistics/tests/kruskal_wallis_test.m b/scripts/statistics/tests/kruskal_wallis_test.m
deleted file mode 100644
--- a/scripts/statistics/tests/kruskal_wallis_test.m
+++ /dev/null
@@ -1,99 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{k}, @var{df}] =} kruskal_wallis_test (@var{x1}, @dots{})
-## Perform a @nospell{Kruskal-Wallis} one-factor analysis of variance.
-##
-## Suppose a variable is observed for @var{k} > 1 different groups, and let
-## @var{x1}, @dots{}, @var{xk} be the corresponding data vectors.
-##
-## Under the null hypothesis that the ranks in the pooled sample are not
-## affected by the group memberships, the test statistic @var{k} is
-## approximately chi-square with @var{df} = @var{k} - 1 degrees of freedom.
-##
-## If the data contains ties (some value appears more than once)
-## @var{k} is divided by
-##
-## 1 - @var{sum_ties} / (@var{n}^3 - @var{n})
-##
-## where @var{sum_ties} is the sum of @var{t}^2 - @var{t} over each group of
-## ties where @var{t} is the number of ties in the group and @var{n} is the
-## total number of values in the input data.  For more info on this
-## adjustment see @nospell{William H. Kruskal and W. Allen Wallis},
-## @cite{Use of Ranks in One-Criterion Variance Analysis},
-## Journal of the American Statistical Association, Vol. 47, No. 260 (Dec
-## 1952).
-##
-## The p-value (1 minus the CDF of this distribution at @var{k}) is returned
-## in @var{pval}.
-##
-## If no output argument is given, the p-value is displayed.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Kruskal-Wallis test
-
-function [pval, k, df] = kruskal_wallis_test (varargin)
-
-  m = nargin;
-  if (m < 2)
-    print_usage ();
-  endif
-
-  n = [];
-  p = [];
-
-  for i = 1 : m;
-    x = varargin{i};
-    if (! isvector (x))
-      error ("kruskal_wallis_test: all arguments must be vectors");
-    endif
-    l = length (x);
-    n = [n, l];
-    p = [p, (reshape (x, 1, l))];
-  endfor
-
-  r = ranks (p);
-
-  k = 0;
-  j = 0;
-  for i = 1 : m;
-    k += (sum (r ((j + 1) : (j + n(i))))) ^ 2 / n(i);
-    j = j + n(i);
-  endfor
-
-  n = length (p);
-  k = 12 * k / (n * (n + 1)) - 3 * (n + 1);
-
-  ## Adjust the result to takes ties into account.
-  sum_ties = sum (polyval ([1, 0, -1, 0], runlength (sort (p))));
-  k /= (1 - sum_ties / (n^3 - n));
-
-  df = m - 1;
-  pval = 1 - chi2cdf (k, df);
-
-  if (nargout == 0)
-    printf ("pval: %g\n", pval);
-  endif
-
-endfunction
-
-
-## Test with ties
-%!assert (abs (kruskal_wallis_test ([86 86], [74]) - 0.157299207050285) < 0.0000000000001)
diff --git a/scripts/statistics/tests/manova.m b/scripts/statistics/tests/manova.m
deleted file mode 100644
--- a/scripts/statistics/tests/manova.m
+++ /dev/null
@@ -1,164 +0,0 @@
-## Copyright (C) 1996-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {} manova (@var{x}, @var{g})
-## Perform a one-way multivariate analysis of variance (MANOVA).
-##
-## The goal is to test whether the p-dimensional population means of data
-## taken from @var{k} different groups are all equal.  All data are assumed
-## drawn independently from p-dimensional normal distributions with the same
-## covariance matrix.
-##
-## The data matrix is given by @var{x}.  As usual, rows are observations and
-## columns are variables.  The vector @var{g} specifies the corresponding
-## group labels (e.g., numbers from 1 to @var{k}).
-##
-## The LR test statistic (@nospell{Wilks' Lambda}) and approximate p-values are
-## computed and displayed.
-## @seealso{anova}
-## @end deftypefn
-
-## The Hotelling-Lawley and Pillai-Bartlett test statistics are coded.
-## However, they are currently disabled until they can be verified by someone
-## with sufficient understanding of the algorithms.  Please feel free to
-## improve this.
-
-## Author: TF <Thomas.Fuereder@ci.tuwien.ac.at>
-## Adapted-By: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: One-way multivariate analysis of variance (MANOVA)
-
-function manova (x, g)
-
-  if (nargin != 2)
-    print_usage ();
-  endif
-
-  if (isvector (x))
-    error ("manova: X must not be a vector");
-  endif
-
-  [n, p] = size (x);
-
-  if (! isvector (g) || (length (g) != n))
-    error ("manova: G must be a vector of length rows (X)");
-  endif
-
-  s = sort (g);
-  i = find (s (2:n) > s(1:(n-1)));
-  k = length (i) + 1;
-
-  if (k == 1)
-    error ("manova: there should be at least 2 groups");
-  else
-    group_label = s ([1, (reshape (i, 1, k - 1) + 1)]);
-  endif
-
-  x -= ones (n, 1) * mean (x);
-  SST = x' * x;
-
-  s = zeros (1, p);
-  SSB = zeros (p, p);
-  for i = 1 : k;
-    v = x (find (g == group_label (i)), :);
-    s = sum (v);
-    SSB += s' * s / rows (v);
-  endfor
-  n_b = k - 1;
-
-  SSW = SST - SSB;
-  n_w = n - k;
-
-  l = real (eig (SSB / SSW));
-
-  if (isa (l, "single"))
-    l(l < eps ("single")) = 0;
-  else
-    l(l < eps) = 0;
-  endif
-
-  ## Wilks' Lambda
-  ## =============
-
-  Lambda = prod (1 ./ (1 + l));
-
-  delta = n_w + n_b - (p + n_b + 1) / 2;
-  df_num = p * n_b;
-  W_pval_1 = 1 - chi2cdf (- delta * log (Lambda), df_num);
-
-  if (p < 3)
-    eta = p;
-  else
-    eta = sqrt ((p^2 * n_b^2 - 4) / (p^2 + n_b^2 - 5));
-  endif
-
-  df_den = delta * eta - df_num / 2 + 1;
-
-  WT = exp (- log (Lambda) / eta) - 1;
-  W_pval_2 = 1 - fcdf (WT * df_den / df_num, df_num, df_den);
-
-  if (0)
-
-    ## Hotelling-Lawley Test
-    ## =====================
-
-    HL = sum (l);
-
-    theta = min (p, n_b);
-    u = (abs (p - n_b) - 1) / 2;
-    v = (n_w - p - 1) / 2;
-
-    df_num = theta * (2 * u + theta + 1);
-    df_den = 2 * (theta * v + 1);
-
-    HL_pval = 1 - fcdf (HL * df_den / df_num, df_num, df_den);
-
-    ## Pillai-Bartlett
-    ## ===============
-
-    PB = sum (l ./ (1 + l));
-
-    df_den = theta * (2 * v + theta + 1);
-    PB_pval = 1 - fcdf (PB * df_den / df_num, df_num, df_den);
-
-    printf ("\n");
-    printf ("One-way MANOVA Table:\n");
-    printf ("\n");
-    printf ("Test             Test Statistic      Approximate p\n");
-    printf ("**************************************************\n");
-    printf ("Wilks            %10.4f           %10.9f \n", Lambda, W_pval_1);
-    printf ("                                      %10.9f \n", W_pval_2);
-    printf ("Hotelling-Lawley %10.4f           %10.9f \n", HL, HL_pval);
-    printf ("Pillai-Bartlett  %10.4f           %10.9f \n", PB, PB_pval);
-    printf ("\n");
-
-  endif
-
-  printf ("\n");
-  printf ("MANOVA Results:\n");
-  printf ("\n");
-  printf ("# of groups:    %d\n", k);
-  printf ("# of samples:   %d\n", n);
-  printf ("# of variables: %d\n", p);
-  printf ("\n");
-  printf ("Wilks' Lambda:  %5.4f\n", Lambda);
-  printf ("Approximate p:  %10.9f (chisquare approximation)\n", W_pval_1);
-  printf ("                 %10.9f (F approximation)\n", W_pval_2);
-  printf ("\n");
-
-endfunction
diff --git a/scripts/statistics/tests/mcnemar_test.m b/scripts/statistics/tests/mcnemar_test.m
deleted file mode 100644
--- a/scripts/statistics/tests/mcnemar_test.m
+++ /dev/null
@@ -1,64 +0,0 @@
-## Copyright (C) 1996-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{chisq}, @var{df}] =} mcnemar_test (@var{x})
-## For a square contingency table @var{x} of data cross-classified on the row
-## and column variables, @nospell{McNemar's} test can be used for testing the
-## null hypothesis of symmetry of the classification probabilities.
-##
-## Under the null, @var{chisq} is approximately distributed as chisquare with
-## @var{df} degrees of freedom.
-##
-## The p-value (1 minus the CDF of this distribution at @var{chisq}) is
-## returned in @var{pval}.
-##
-## If no output argument is given, the p-value of the test is displayed.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: McNemar's test for symmetry
-
-function [pval, chisq, df] = mcnemar_test (x)
-
-  if (nargin != 1)
-    print_usage ();
-  endif
-
-  if (! (min (size (x)) > 1) && issquare (x))
-    error ("mcnemar_test: X must be a square matrix of size > 1");
-  elseif (! (all ((x(:) >= 0)) && all (x(:) == fix (x(:)))))
-    error ("mcnemar_test: all entries of X must be non-negative integers");
-  endif
-
-  r = rows (x);
-  df = r * (r - 1) / 2;
-  if (r == 2)
-    num = max (abs (x - x') - 1, 0) .^ 2;
-  else
-    num = abs (x - x') .^ 2;
-  endif
-
-  chisq = sum (sum (triu (num ./ (x + x'), 1)));
-  pval = 1 - chi2cdf (chisq, df);
-
-  if (nargout == 0)
-    printf ("  pval: %g\n", pval);
-  endif
-
-endfunction
diff --git a/scripts/statistics/tests/module.mk b/scripts/statistics/tests/module.mk
deleted file mode 100644
--- a/scripts/statistics/tests/module.mk
+++ /dev/null
@@ -1,38 +0,0 @@
-FCN_FILE_DIRS += scripts/statistics/tests
-
-%canon_reldir%_FCN_FILES = \
-  %reldir%/anova.m \
-  %reldir%/bartlett_test.m \
-  %reldir%/chisquare_test_homogeneity.m \
-  %reldir%/chisquare_test_independence.m \
-  %reldir%/cor_test.m \
-  %reldir%/f_test_regression.m \
-  %reldir%/hotelling_test.m \
-  %reldir%/hotelling_test_2.m \
-  %reldir%/kolmogorov_smirnov_test.m \
-  %reldir%/kolmogorov_smirnov_test_2.m \
-  %reldir%/kruskal_wallis_test.m \
-  %reldir%/manova.m \
-  %reldir%/mcnemar_test.m \
-  %reldir%/prop_test_2.m \
-  %reldir%/run_test.m \
-  %reldir%/sign_test.m \
-  %reldir%/t_test.m \
-  %reldir%/t_test_2.m \
-  %reldir%/t_test_regression.m \
-  %reldir%/u_test.m \
-  %reldir%/var_test.m \
-  %reldir%/welch_test.m \
-  %reldir%/wilcoxon_test.m \
-  %reldir%/z_test.m \
-  %reldir%/z_test_2.m
-
-%canon_reldir%dir = $(fcnfiledir)/statistics/tests
-
-%canon_reldir%_DATA = $(%canon_reldir%_FCN_FILES)
-
-FCN_FILES += $(%canon_reldir%_FCN_FILES)
-
-PKG_ADD_FILES += %reldir%/PKG_ADD
-
-DIRSTAMP_FILES += %reldir%/$(octave_dirstamp)
diff --git a/scripts/statistics/tests/prop_test_2.m b/scripts/statistics/tests/prop_test_2.m
deleted file mode 100644
--- a/scripts/statistics/tests/prop_test_2.m
+++ /dev/null
@@ -1,81 +0,0 @@
-## Copyright (C) 1996-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{z}] =} prop_test_2 (@var{x1}, @var{n1}, @var{x2}, @var{n2}, @var{alt})
-## If @var{x1} and @var{n1} are the counts of successes and trials in one
-## sample, and @var{x2} and @var{n2} those in a second one, test the null
-## hypothesis that the success probabilities @var{p1} and @var{p2} are the
-## same.
-##
-## Under the null, the test statistic @var{z} approximately follows a
-## standard normal distribution.
-##
-## With the optional argument string @var{alt}, the alternative of interest
-## can be selected.  If @var{alt} is @qcode{"!="} or @qcode{"<>"}, the null
-## is tested against the two-sided alternative @var{p1} != @var{p2}.  If
-## @var{alt} is @qcode{">"}, the one-sided alternative @var{p1} > @var{p2} is
-## used.  Similarly for @qcode{"<"}, the one-sided alternative
-## @var{p1} < @var{p2} is used.  The default is the two-sided case.
-##
-## The p-value of the test is returned in @var{pval}.
-##
-## If no output argument is given, the p-value of the test is displayed.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Compare two proportions
-
-function [pval, z] = prop_test_2 (x1, n1, x2, n2, alt)
-
-  if (nargin < 4 || nargin > 5)
-    print_usage ();
-  endif
-
-  ## Could do sanity checking on x1, n1, x2, n2 here
-
-  p1 = x1 / n1;
-  p2 = x2 / n2;
-  pc = (x1 + x2) / (n1 + n2);
-
-  z  = (p1 - p2) / sqrt (pc * (1 - pc) * (1/n1 + 1/n2));
-
-  cdf = stdnormal_cdf (z);
-
-  if (nargin == 4)
-    alt = "!=";
-  endif
-
-  if (! ischar (alt))
-    error ("prop_test_2: ALT must be a string");
-  endif
-  if (strcmp (alt, "!=") || strcmp (alt, "<>"))
-    pval = 2 * min (cdf, 1 - cdf);
-  elseif (strcmp (alt, ">"))
-    pval = 1 - cdf;
-  elseif (strcmp (alt, "<"))
-    pval = cdf;
-  else
-    error ("prop_test_2: option %s not recognized", alt);
-  endif
-
-  if (nargout == 0)
-    printf ("  pval: %g\n", pval);
-  endif
-
-endfunction
diff --git a/scripts/statistics/tests/run_test.m b/scripts/statistics/tests/run_test.m
deleted file mode 100644
--- a/scripts/statistics/tests/run_test.m
+++ /dev/null
@@ -1,60 +0,0 @@
-## Copyright (C) 1995-2017 Friedrich Leisch
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{chisq}] =} run_test (@var{x})
-## Perform a chi-square test with 6 degrees of freedom based on the upward
-## runs in the columns of @var{x}.
-##
-## @code{run_test} can be used to decide whether @var{x} contains independent
-## data.
-##
-## The p-value of the test is returned in @var{pval}.
-##
-## If no output argument is given, the p-value is displayed.
-## @end deftypefn
-
-## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
-## Description: Run test for independence
-
-function [pval, chisq] = run_test (x)
-
-  if (nargin != 1)
-    print_usage ();
-  endif
-
-  A = [4529.4,  9044.9, 13568,  18091,  22615,  27892;
-       9044.4, 18097,   27139,  36187,  45234,  55789;
-      13568,   27139,   40721,  54281,  67852,  83685;
-      18091,   36187,   54281,  72414,  90470, 111580;
-      22615,   45234,   67852,  90470, 113262, 139476;
-      27892,   55789,   83685, 111580, 139476, 172860];
-
-  b = [1/6; 5/24; 11/120; 19/720; 29/5040; 1/840];
-
-  n = rows (x);
-  r = run_count (x, 6) - n * b * ones (1, columns (x));
-
-  chisq = diag (r' * A * r)' / n;
-  pval  = chi2cdf (chisq, 6);
-
-  if (nargout == 0)
-    printf ("pval: %g\n", pval);
-  endif
-
-endfunction
diff --git a/scripts/statistics/tests/sign_test.m b/scripts/statistics/tests/sign_test.m
deleted file mode 100644
--- a/scripts/statistics/tests/sign_test.m
+++ /dev/null
@@ -1,84 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{b}, @var{n}] =} sign_test (@var{x}, @var{y}, @var{alt})
-## For two matched-pair samples @var{x} and @var{y}, perform a sign test
-## of the null hypothesis
-## PROB (@var{x} > @var{y}) == PROB (@var{x} < @var{y}) == 1/2.
-##
-## Under the null, the test statistic @var{b} roughly follows a
-## binomial distribution with parameters
-## @code{@var{n} = sum (@var{x} != @var{y})} and @var{p} = 1/2.
-##
-## With the optional argument @code{alt}, the alternative of interest can be
-## selected.  If @var{alt} is @qcode{"!="} or @qcode{"<>"}, the null
-## hypothesis is tested against the two-sided alternative
-## PROB (@var{x} < @var{y}) != 1/2.  If @var{alt} is @qcode{">"}, the one-sided
-## alternative PROB (@var{x} > @var{y}) > 1/2 ("x is stochastically greater
-## than y") is considered.  Similarly for @qcode{"<"}, the one-sided
-## alternative PROB (@var{x} > @var{y}) < 1/2 ("x is stochastically less than
-## y") is considered.  The default is the two-sided case.
-##
-## The p-value of the test is returned in @var{pval}.
-##
-## If no output argument is given, the p-value of the test is displayed.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Sign test
-
-function [pval, b, n] = sign_test (x, y, alt)
-
-  if (nargin < 2 || nargin > 3)
-    print_usage ();
-  endif
-
-  if (! (isvector (x) && isvector (y) && (length (x) == length (y))))
-    error ("sign_test: X and Y must be vectors of the same length");
-  endif
-
-  n   = length (x);
-  x   = reshape (x, 1, n);
-  y   = reshape (y, 1, n);
-  n   = sum (x != y);
-  b   = sum (x > y);
-  cdf = binocdf (b, n, 1/2);
-
-  if (nargin == 2)
-    alt = "!=";
-  endif
-
-  if (! ischar (alt))
-    error ("sign_test: ALT must be a string");
-  endif
-  if (strcmp (alt, "!=") || strcmp (alt, "<>"))
-    pval = 2 * min (cdf, 1 - cdf);
-  elseif (strcmp (alt, ">"))
-    pval = 1 - cdf;
-  elseif (strcmp (alt, "<"))
-    pval = cdf;
-  else
-    error ("sign_test: option %s not recognized", alt);
-  endif
-
-  if (nargout == 0)
-    printf ("  pval: %g\n", pval);
-  endif
-
-endfunction
diff --git a/scripts/statistics/tests/t_test.m b/scripts/statistics/tests/t_test.m
deleted file mode 100644
--- a/scripts/statistics/tests/t_test.m
+++ /dev/null
@@ -1,114 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{t}, @var{df}] =} t_test (@var{x}, @var{m}, @var{alt})
-## For a sample @var{x} from a normal distribution with unknown mean and
-## variance, perform a t-test of the null hypothesis
-## @code{mean (@var{x}) == @var{m}}.
-##
-## Under the null, the test statistic @var{t} follows a Student distribution
-## with @code{@var{df} = length (@var{x}) - 1} degrees of freedom.
-##
-## With the optional argument string @var{alt}, the alternative of interest
-## can be selected.  If @var{alt} is @qcode{"!="} or @qcode{"<>"}, the null
-## is tested against the two-sided alternative @code{mean (@var{x}) !=
-## @var{m}}.  If @var{alt} is @qcode{">"}, the one-sided alternative
-## @code{mean (@var{x}) > @var{m}} is considered.  Similarly for @var{"<"},
-## the one-sided alternative @code{mean (@var{x}) < @var{m}} is considered.
-## The default is the two-sided case.
-##
-## The p-value of the test is returned in @var{pval}.
-##
-## If no output argument is given, the p-value of the test is displayed.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Student's one-sample t test
-
-function [pval, t, df] = t_test (x, m, alt)
-
-  if (nargin < 2 || nargin > 3)
-    print_usage ();
-  endif
-
-  if (! isvector (x))
-    error ("t_test: X must be a vector");
-  endif
-  if (! isscalar (m))
-    error ("t_test: M must be a scalar");
-  endif
-
-  n   = length (x);
-  df  = n - 1;
-  t   = sqrt (n) * (sum (x) / n - m) / std (x);
-  cdf = tcdf (t, df);
-
-  if (nargin == 2)
-    alt = "!=";
-  endif
-
-  if (! ischar (alt))
-    error ("t_test: ALT must be a string");
-  endif
-  if (strcmp (alt, "!=") || strcmp (alt, "<>"))
-    pval = 2 * min (cdf, 1 - cdf);
-  elseif (strcmp (alt, ">"))
-    pval = 1 - cdf;
-  elseif (strcmp (alt, "<"))
-    pval = cdf;
-  else
-    error ("t_test: option %s not recognized", alt);
-  endif
-
-  if (nargout == 0)
-    printf ("  pval: %g\n", pval);
-  endif
-
-endfunction
-
-
-%!test
-%! ## Two-sided (also the default option)
-%! x = rand (10,1); n = length (x);
-%! u0 = 0.5; # true mean
-%! xbar = mean (x);
-%! pval = t_test (x, u0, "!=");
-%! if (xbar >= u0)
-%!   tval = abs (tinv (0.5*pval, n-1));
-%! else
-%!   tval = -abs (tinv (0.5*pval, n-1));
-%! endif
-%! unew = tval * std(x)/sqrt(n) + u0;
-%! assert (xbar, unew, 100*eps);
-
-%!test
-%! x = rand (10,1); n = length (x);
-%! u0 = 0.5;
-%! pval = t_test (x, u0, ">");
-%! tval = tinv (1-pval, n-1);
-%! unew = tval * std(x)/sqrt(n) + u0;
-%! assert (mean (x), unew, 100*eps);
-
-%!test
-%! x = rand (10,1); n = length (x);
-%! u0 = 0.5;
-%! pval = t_test (x, u0, "<");
-%! tval = tinv (pval, n-1);
-%! unew = tval * std(x)/sqrt(n) + u0;
-%! assert (mean (x), unew, 100*eps);
diff --git a/scripts/statistics/tests/t_test_2.m b/scripts/statistics/tests/t_test_2.m
deleted file mode 100644
--- a/scripts/statistics/tests/t_test_2.m
+++ /dev/null
@@ -1,84 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{t}, @var{df}] =} t_test_2 (@var{x}, @var{y}, @var{alt})
-## For two samples x and y from normal distributions with unknown means and
-## unknown equal variances, perform a two-sample t-test of the null
-## hypothesis of equal means.
-##
-## Under the null, the test statistic @var{t} follows a Student distribution
-## with @var{df} degrees of freedom.
-##
-## With the optional argument string @var{alt}, the alternative of interest
-## can be selected.  If @var{alt} is @qcode{"!="} or @qcode{"<>"}, the null
-## is tested against the two-sided alternative @code{mean (@var{x}) != mean
-## (@var{y})}.  If @var{alt} is @qcode{">"}, the one-sided alternative
-## @code{mean (@var{x}) > mean (@var{y})} is used.  Similarly for
-## @qcode{"<"}, the one-sided alternative @code{mean (@var{x}) < mean
-## (@var{y})} is used.  The default is the two-sided case.
-##
-## The p-value of the test is returned in @var{pval}.
-##
-## If no output argument is given, the p-value of the test is displayed.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Student's two-sample t test
-
-function [pval, t, df] = t_test_2 (x, y, alt)
-
-  if (nargin < 2 || nargin > 3)
-    print_usage ();
-  endif
-
-  if (! (isvector (x) && isvector (y)))
-    error ("t_test_2: both X and Y must be vectors");
-  endif
-
-  n_x  = length (x);
-  n_y  = length (y);
-  df   = n_x + n_y - 2;
-  mu_x = sum (x) / n_x;
-  mu_y = sum (y) / n_y;
-  v    = sumsq (x - mu_x) + sumsq (y - mu_y);
-  t    = (mu_x - mu_y) * sqrt ((n_x * n_y * df) / (v * (n_x + n_y)));
-  cdf  = tcdf (t, df);
-
-  if (nargin == 2)
-    alt = "!=";
-  endif
-
-  if (! ischar (alt))
-    error ("t_test_2: ALT must be a string");
-  endif
-  if (strcmp (alt, "!=") || strcmp (alt, "<>"))
-    pval = 2 * min (cdf, 1 - cdf);
-  elseif (strcmp (alt, ">"))
-    pval = 1 - cdf;
-  elseif (strcmp (alt, "<"))
-    pval = cdf;
-  else
-    error ("t_test_2: option %s not recognized", alt);
-  endif
-
-  if (nargout == 0)
-    printf ("  pval: %g\n", pval);
-  endif
-
-endfunction
diff --git a/scripts/statistics/tests/t_test_regression.m b/scripts/statistics/tests/t_test_regression.m
deleted file mode 100644
--- a/scripts/statistics/tests/t_test_regression.m
+++ /dev/null
@@ -1,98 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{t}, @var{df}] =} t_test_regression (@var{y}, @var{x}, @var{rr}, @var{r}, @var{alt})
-## Perform a t test for the null hypothesis
-## @nospell{@code{@var{rr} * @var{b} = @var{r}}} in a classical normal
-## regression model @code{@var{y} = @var{x} * @var{b} + @var{e}}.
-##
-## Under the null, the test statistic @var{t} follows a @var{t} distribution
-## with @var{df} degrees of freedom.
-##
-## If @var{r} is omitted, a value of 0 is assumed.
-##
-## With the optional argument string @var{alt}, the alternative of interest
-## can be selected.  If @var{alt} is @qcode{"!="} or @qcode{"<>"}, the null
-## is tested against the two-sided alternative @nospell{@code{@var{rr} *
-## @var{b} != @var{r}}}.  If @var{alt} is @qcode{">"}, the one-sided
-## alternative @nospell{@code{@var{rr} * @var{b} > @var{r}}} is used.
-## Similarly for @var{"<"}, the one-sided alternative @nospell{@code{@var{rr}
-## * @var{b} < @var{r}}} is used.  The default is the two-sided case.
-##
-## The p-value of the test is returned in @var{pval}.
-##
-## If no output argument is given, the p-value of the test is displayed.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Test one linear hypothesis in linear regression model
-
-function [pval, t, df] = t_test_regression (y, x, rr, r, alt)
-
-  if (nargin == 3)
-    r   = 0;
-    alt = "!=";
-  elseif (nargin == 4)
-    if (ischar (r))
-      alt = r;
-      r   = 0;
-    else
-      alt = "!=";
-    endif
-  elseif (! (nargin == 5))
-    print_usage ();
-  endif
-
-  if (! isscalar (r))
-    error ("t_test_regression: R must be a scalar");
-  elseif (! ischar (alt))
-    error ("t_test_regression: ALT must be a string");
-  endif
-
-  [T, k] = size (x);
-  if (! (isvector (y) && (length (y) == T)))
-    error ("t_test_regression: Y must be a vector of length rows (X)");
-  endif
-  s = size (rr);
-  if (! ((max (s) == k) && (min (s) == 1)))
-    error ("t_test_regression: RR must be a vector of length columns (X)");
-  endif
-
-  rr     = reshape (rr, 1, k);
-  y      = reshape (y, T, 1);
-  [b, v] = ols (y, x);
-  df     = T - k;
-  t      = (rr * b - r) / sqrt (v * rr * inv (x' * x) * rr');
-  cdf    = tcdf (t, df);
-
-  if (strcmp (alt, "!=") || strcmp (alt, "<>"))
-    pval = 2 * min (cdf, 1 - cdf);
-  elseif (strcmp (alt, ">"))
-    pval = 1 - cdf;
-  elseif (strcmp (alt, "<"))
-    pval = cdf;
-  else
-    error ("t_test_regression: the value '%s' for ALT is not possible", alt);
-  endif
-
-  if (nargout == 0)
-    printf ("pval: %g\n", pval);
-  endif
-
-endfunction
diff --git a/scripts/statistics/tests/u_test.m b/scripts/statistics/tests/u_test.m
deleted file mode 100644
--- a/scripts/statistics/tests/u_test.m
+++ /dev/null
@@ -1,87 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{z}] =} u_test (@var{x}, @var{y}, @var{alt})
-## For two samples @var{x} and @var{y}, perform a Mann-Whitney U-test of
-## the null hypothesis
-## PROB (@var{x} > @var{y}) == 1/2 == PROB (@var{x} < @var{y}).
-##
-## Under the null, the test statistic @var{z} approximately follows a
-## standard normal distribution.  Note that this test is equivalent to the
-## Wilcoxon rank-sum test.
-##
-## With the optional argument string @var{alt}, the alternative of interest
-## can be selected.  If @var{alt} is @qcode{"!="} or @qcode{"<>"}, the null
-## is tested against the two-sided alternative
-## PROB (@var{x} > @var{y}) != 1/2.  If @var{alt} is @qcode{">"}, the one-sided
-## alternative PROB (@var{x} > @var{y}) > 1/2 is considered.  Similarly for
-## @qcode{"<"}, the one-sided alternative PROB (@var{x} > @var{y}) < 1/2 is
-## considered.  The default is the two-sided case.
-##
-## The p-value of the test is returned in @var{pval}.
-##
-## If no output argument is given, the p-value of the test is displayed.
-## @end deftypefn
-
-## This implementation is still incomplete---for small sample sizes,
-## the normal approximation is rather bad ...
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Mann-Whitney U-test
-
-function [pval, z] = u_test (x, y, alt)
-
-  if (nargin < 2 || nargin > 3)
-    print_usage ();
-  endif
-
-  if (! (isvector (x) && isvector (y)))
-    error ("u_test: both X and Y must be vectors");
-  endif
-
-  n_x = length (x);
-  n_y = length (y);
-  r   = ranks ([(reshape (x, 1, n_x)), (reshape (y, 1, n_y))]);
-  z   = (sum (r(1 : n_x)) - n_x * (n_x + n_y + 1) / 2) ...
-          / sqrt (n_x * n_y * (n_x + n_y + 1) / 12);
-
-  cdf = stdnormal_cdf (z);
-
-  if (nargin == 2)
-    alt = "!=";
-  endif
-
-  if (! ischar (alt))
-    error ("u_test: ALT must be a string");
-  endif
-  if (strcmp (alt, "!=") || strcmp (alt, "<>"))
-    pval = 2 * min (cdf, 1 - cdf);
-  elseif (strcmp (alt, ">"))
-    pval = cdf;
-  elseif (strcmp (alt, "<"))
-    pval = 1 - cdf;
-  else
-    error ("u_test: option %s not recognized", alt);
-  endif
-
-  if (nargout == 0)
-    printf ("  pval: %g\n", pval);
-  endif
-
-endfunction
diff --git a/scripts/statistics/tests/var_test.m b/scripts/statistics/tests/var_test.m
deleted file mode 100644
--- a/scripts/statistics/tests/var_test.m
+++ /dev/null
@@ -1,80 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{f}, @var{df_num}, @var{df_den}] =} var_test (@var{x}, @var{y}, @var{alt})
-## For two samples @var{x} and @var{y} from normal distributions with
-## unknown means and unknown variances, perform an F-test of the null
-## hypothesis of equal variances.
-##
-## Under the null, the test statistic @var{f} follows an F-distribution with
-## @var{df_num} and @var{df_den} degrees of freedom.
-##
-## With the optional argument string @var{alt}, the alternative of interest
-## can be selected.  If @var{alt} is @qcode{"!="} or @qcode{"<>"}, the null
-## is tested against the two-sided alternative @code{var (@var{x}) != var
-## (@var{y})}.  If @var{alt} is @qcode{">"}, the one-sided alternative
-## @code{var (@var{x}) > var (@var{y})} is used.  Similarly for "<", the
-## one-sided alternative @code{var (@var{x}) > var (@var{y})} is used.  The
-## default is the two-sided case.
-##
-## The p-value of the test is returned in @var{pval}.
-##
-## If no output argument is given, the p-value of the test is displayed.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: F test to compare two variances
-
-function [pval, f, df_num, df_den] = var_test (x, y, alt)
-
-  if (nargin < 2 || nargin > 3)
-    print_usage ();
-  endif
-
-  if (! (isvector (x) && isvector (y)))
-    error ("var_test: both X and Y must be vectors");
-  endif
-
-  df_num = length (x) - 1;
-  df_den = length (y) - 1;
-  f      = var (x) / var (y);
-  cdf    = fcdf (f, df_num, df_den);
-
-  if (nargin == 2)
-    alt = "!=";
-  endif
-
-  if (! ischar (alt))
-    error ("var_test: ALT must be a string");
-  endif
-  if (strcmp (alt, "!=") || strcmp (alt, "<>"))
-    pval = 2 * min (cdf, 1 - cdf);
-  elseif (strcmp (alt, ">"))
-    pval = 1 - cdf;
-  elseif (strcmp (alt, "<"))
-    pval = cdf;
-  else
-    error ("var_test: option %s not recognized", alt);
-  endif
-
-  if (nargout == 0)
-    printf ("pval: %g\n", pval);
-  endif
-
-endfunction
diff --git a/scripts/statistics/tests/welch_test.m b/scripts/statistics/tests/welch_test.m
deleted file mode 100644
--- a/scripts/statistics/tests/welch_test.m
+++ /dev/null
@@ -1,86 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{t}, @var{df}] =} welch_test (@var{x}, @var{y}, @var{alt})
-## For two samples @var{x} and @var{y} from normal distributions with
-## unknown means and unknown and not necessarily equal variances,
-## perform a Welch test of the null hypothesis of equal means.
-##
-## Under the null, the test statistic @var{t} approximately follows a
-## Student distribution with @var{df} degrees of freedom.
-##
-## With the optional argument string @var{alt}, the alternative of interest
-## can be selected.  If @var{alt} is @qcode{"!="} or @qcode{"<>"}, the null
-## is tested against the two-sided alternative
-## @code{mean (@var{x}) != @var{m}}.  If @var{alt} is @qcode{">"}, the
-## one-sided alternative mean(x) > @var{m} is considered.  Similarly for
-## @qcode{"<"}, the one-sided alternative mean(x) < @var{m} is considered.
-## The default is the two-sided case.
-##
-## The p-value of the test is returned in @var{pval}.
-##
-## If no output argument is given, the p-value of the test is displayed.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Welch two-sample t test
-
-function [pval, t, df] = welch_test (x, y, alt)
-
-  if (nargin < 2 || nargin > 3)
-    print_usage ();
-  endif
-
-  if (! (isvector (x) && isvector (y)))
-    error ("welch_test: both X and Y must be vectors");
-  endif
-
-  n_x  = length (x);
-  n_y  = length (y);
-  mu_x = sum (x) / n_x;
-  mu_y = sum (y) / n_y;
-  v_x  = sumsq (x - mu_x) / (n_x * (n_x - 1));
-  v_y  = sumsq (y - mu_y) / (n_y * (n_y - 1));
-  c    = v_x / (v_x + v_y);
-  df   = 1 / (c^2 / (n_x - 1) + (1 - c)^2 / (n_y - 1));
-  t    = (mu_x - mu_y) / sqrt (v_x + v_y);
-  cdf  = tcdf (t, df);
-
-  if (nargin == 2)
-    alt = "!=";
-  endif
-
-  if (! ischar (alt))
-    error ("welch_test: ALT must be a string");
-  endif
-  if (strcmp (alt, "!=") || strcmp (alt, "<>"))
-    pval = 2 * min (cdf, 1 - cdf);
-  elseif (strcmp (alt, ">"))
-    pval = 1 - cdf;
-  elseif (strcmp (alt, "<"))
-    pval = cdf;
-  else
-    error ("welch_test: option %s not recognized", alt);
-  endif
-
-  if (nargout == 0)
-    printf ("  pval: %g\n", pval);
-  endif
-
-endfunction
diff --git a/scripts/statistics/tests/wilcoxon_test.m b/scripts/statistics/tests/wilcoxon_test.m
deleted file mode 100644
--- a/scripts/statistics/tests/wilcoxon_test.m
+++ /dev/null
@@ -1,93 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{z}] =} wilcoxon_test (@var{x}, @var{y}, @var{alt})
-## For two matched-pair sample vectors @var{x} and @var{y}, perform a
-## Wilcoxon signed-rank test of the null hypothesis
-## PROB (@var{x} > @var{y}) == 1/2.
-##
-## Under the null, the test statistic @var{z} approximately follows a
-## standard normal distribution when @var{n} > 25.
-##
-## @strong{Caution:} This function assumes a normal distribution for @var{z}
-## and thus is invalid for @var{n} @leq{} 25.
-##
-## With the optional argument string @var{alt}, the alternative of interest
-## can be selected.  If @var{alt} is @qcode{"!="} or @qcode{"<>"}, the null
-## is tested against the two-sided alternative
-## PROB (@var{x} > @var{y}) != 1/2.  If alt is @qcode{">"}, the one-sided
-## alternative PROB (@var{x} > @var{y}) > 1/2 is considered.  Similarly for
-## @qcode{"<"}, the one-sided alternative PROB (@var{x} > @var{y}) < 1/2 is
-## considered.  The default is the two-sided case.
-##
-## The p-value of the test is returned in @var{pval}.
-##
-## If no output argument is given, the p-value of the test is displayed.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Wilcoxon signed-rank test
-
-function [pval, z] = wilcoxon_test (x, y, alt)
-
-  if (nargin < 2 || nargin > 3)
-    print_usage ();
-  endif
-
-  if (! (isvector (x) && isvector (y) && (length (x) == length (y))))
-    error ("wilcoxon_test: X and Y must be vectors of the same length");
-  endif
-
-  n = length (x);
-  x = reshape (x, 1, n);
-  y = reshape (y, 1, n);
-  d = x - y;
-  d = d(find (d != 0));
-  n = length (d);
-  if (n > 25)
-    r = ranks (abs (d));
-    z = sum (r(find (d > 0)));
-    z = ((z - n * (n + 1) / 4) / sqrt (n * (n + 1) * (2 * n + 1) / 24));
-  else
-    error ("wilcoxon_test: implementation requires more than 25 different pairs");
-  endif
-
-  cdf = stdnormal_cdf (z);
-
-  if (nargin == 2)
-    alt = "!=";
-  endif
-
-  if (! ischar (alt))
-    error ("wilcoxon_test: ALT must be a string");
-  elseif (strcmp (alt, "!=") || strcmp (alt, "<>"))
-    pval = 2 * min (cdf, 1 - cdf);
-  elseif (strcmp (alt, ">"))
-    pval = 1 - cdf;
-  elseif (strcmp (alt, "<"))
-    pval = cdf;
-  else
-    error ("wilcoxon_test: option %s not recognized", alt);
-  endif
-
-  if (nargout == 0)
-    printf ("  pval: %g\n", pval);
-  endif
-
-endfunction
diff --git a/scripts/statistics/tests/z_test.m b/scripts/statistics/tests/z_test.m
deleted file mode 100644
--- a/scripts/statistics/tests/z_test.m
+++ /dev/null
@@ -1,119 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{z}] =} z_test (@var{x}, @var{m}, @var{v}, @var{alt})
-## Perform a Z-test of the null hypothesis @code{mean (@var{x}) == @var{m}}
-## for a sample @var{x} from a normal distribution with unknown mean and known
-## variance @var{v}.
-##
-## Under the null, the test statistic @var{z} follows a standard normal
-## distribution.
-##
-## With the optional argument string @var{alt}, the alternative of interest
-## can be selected.  If @var{alt} is @qcode{"!="} or @qcode{"<>"}, the null
-## is tested against the two-sided alternative
-## @code{mean (@var{x}) != @var{m}}.  If @var{alt} is @qcode{">"}, the
-## one-sided alternative @code{mean (@var{x}) > @var{m}} is considered.
-## Similarly for @qcode{"<"}, the one-sided alternative
-## @code{mean (@var{x}) < @var{m}} is considered.  The default is the two-sided
-## case.
-##
-## The p-value of the test is returned in @var{pval}.
-##
-## If no output argument is given, the p-value of the test is displayed along
-## with some information.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Test for mean of a normal sample with known variance
-
-function [pval, z] = z_test (x, m, v, alt)
-
-  if (nargin < 3 || nargin > 4)
-    print_usage ();
-  endif
-
-  if (! isvector (x))
-    error ("z_test: X must be a vector");
-  endif
-  if (! isscalar (m))
-    error ("z_test: M must be a scalar");
-  endif
-  if (! (isscalar (v) && (v > 0)))
-    error ("z_test: V must be a positive scalar");
-  endif
-
-  n = length (x);
-  z = sqrt (n/v) * (sum (x) / n - m);
-  cdf = stdnormal_cdf (z);
-
-  if (nargin == 3)
-    alt = "!=";
-  endif
-
-  if (! ischar (alt))
-    error ("z_test: ALT must be a string");
-  elseif (strcmp (alt, "!=") || strcmp (alt, "<>"))
-    pval = 2 * min (cdf, 1 - cdf);
-  elseif (strcmp (alt, ">"))
-    pval = 1 - cdf;
-  elseif (strcmp (alt, "<"))
-    pval = cdf;
-  else
-    error ("z_test: option %s not recognized", alt);
-  endif
-
-  if (nargout == 0)
-    s = ["Z-test of mean(x) == %g against mean(x) %s %g,\n", ...
-         "with known var(x) == %g:\n",                       ...
-         "  pval = %g\n"];
-    printf (s, m, alt, m, v, pval);
-  endif
-
-endfunction
-
-
-%!test
-%! ## Two-sided (also the default option)
-%! x = rand (10,1); n = length (x);
-%! u0 = 0.5; v = 1/12; # true mean, var
-%! pval = z_test (x, u0, v, "!=");
-%! if (mean (x) >= u0)
-%!   zval = abs (norminv (0.5*pval));
-%! else
-%!   zval = -abs (norminv (0.5*pval));
-%! endif
-%! unew = zval * sqrt (v/n) + u0;
-%! assert (mean (x), unew, 100*eps);
-
-%!test
-%! x = rand (10,1); n = length (x);
-%! u0 = 0.5; v = 1/12;
-%! pval = z_test (x, u0, v, ">");
-%! zval = norminv (1-pval);
-%! unew = zval * sqrt (v/n) + u0;
-%! assert (mean (x), unew, 100*eps);
-
-%!test
-%! x = rand (10,1); n = length (x);
-%! u0 = 0.5; v = 1/12;
-%! pval = z_test (x, u0, v, "<");
-%! zval = norminv (pval);
-%! unew = zval * sqrt (v/n) + u0;
-%! assert (mean (x), unew, 100*eps);
diff --git a/scripts/statistics/tests/z_test_2.m b/scripts/statistics/tests/z_test_2.m
deleted file mode 100644
--- a/scripts/statistics/tests/z_test_2.m
+++ /dev/null
@@ -1,144 +0,0 @@
-## Copyright (C) 1995-2017 Kurt Hornik
-##
-## This file is part of Octave.
-##
-## Octave is free software: you can redistribute it and/or modify it
-## under the terms of the GNU General Public License as published by
-## the Free Software Foundation, either version 3 of the License, or
-## (at your option) any later version.
-##
-## Octave is distributed in the hope that it will be useful, but
-## WITHOUT ANY WARRANTY; without even the implied warranty of
-## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-## GNU General Public License for more details.
-##
-## You should have received a copy of the GNU General Public License
-## along with Octave; see the file COPYING.  If not, see
-## <https://www.gnu.org/licenses/>.
-
-## -*- texinfo -*-
-## @deftypefn {} {[@var{pval}, @var{z}] =} z_test_2 (@var{x}, @var{y}, @var{v_x}, @var{v_y}, @var{alt})
-## For two samples @var{x} and @var{y} from normal distributions with unknown
-## means and known variances @var{v_x} and @var{v_y}, perform a Z-test of the
-## hypothesis of equal means.
-##
-## Under the null, the test statistic @var{z} follows a standard normal
-## distribution.
-##
-## With the optional argument string @var{alt}, the alternative of interest
-## can be selected.  If @var{alt} is @qcode{"!="} or @qcode{"<>"}, the null
-## is tested against the two-sided alternative
-## @code{mean (@var{x}) != mean (@var{y})}.  If alt is @qcode{">"}, the
-## one-sided alternative @code{mean (@var{x}) > mean (@var{y})} is used.
-## Similarly for @qcode{"<"}, the one-sided alternative
-## @code{mean (@var{x}) < mean (@var{y})} is used.  The default is the
-## two-sided case.
-##
-## The p-value of the test is returned in @var{pval}.
-##
-## If no output argument is given, the p-value of the test is displayed along
-## with some information.
-## @end deftypefn
-
-## Author: KH <Kurt.Hornik@wu-wien.ac.at>
-## Description: Compare means of two normal samples with known variances
-
-function [pval, z] = z_test_2 (x, y, v_x, v_y, alt)
-
-  if (nargin < 4 || nargin > 5)
-    print_usage ();
-  endif
-
-  if (! (isvector (x) && isvector (y)))
-    error ("z_test_2: both X and Y must be vectors");
-  elseif (! (isscalar (v_x) && (v_x > 0)
-             && isscalar (v_y) && (v_y > 0)))
-    error ("z_test_2: both V_X and V_Y must be positive scalars");
-  endif
-
-  n_x  = length (x);
-  n_y  = length (y);
-  mu_x = sum (x) / n_x;
-  mu_y = sum (y) / n_y;
-  z    = (mu_x - mu_y) / sqrt (v_x / n_x + v_y / n_y);
-  cdf  = stdnormal_cdf (z);
-
-  if (nargin == 4)
-    alt = "!=";
-  endif
-
-  if (! ischar (alt))
-    error ("z_test_2: ALT must be a string");
-  elseif (strcmp (alt, "!=") || strcmp (alt, "<>"))
-    pval = 2 * min (cdf, 1 - cdf);
-  elseif (strcmp (alt, ">"))
-    pval = 1 - cdf;
-  elseif (strcmp (alt, "<"))
-    pval = cdf;
-  else
-    error ("z_test_2: option %s not recognized", alt);
-  endif
-
-  if (nargout == 0)
-    s = ["Two-sample Z-test of mean(x) == mean(y) against ", ...
-         "mean(x) %s mean(y),\n",                            ...
-         "with known var(x) == %g and var(y) == %g:\n",      ...
-         "  pval = %g\n"];
-    printf (s, alt, v_x, v_y, pval);
-  endif
-
-endfunction
-
-#!test
-%! ## Two-sided (also the default option)
-%! x = randn (100, 1); v_x = 2; x = v_x * x;
-%! [pval, z] = z_test_2 (x, x, v_x, v_x);
-%! zval_exp = 0; pval_exp = 1.0;
-%! assert (zval, zval_exp, eps);
-%! assert (pval, pval_exp, eps);
-
-#!test
-%! ## Two-sided (also the default option)
-%! x = randn (10000, 1); v_x = 2; x = v_x * x; n_x = length (x);
-%! y = randn (20000, 1); v_y = 3; y = v_y * y; n_y = length (y);
-%! [pval, z] = z_test_2 (x, y, v_x, v_y);
-%! if (mean (x) >= mean (y))
-%!   zval = abs (norminv (0.5*pval));
-%! else
-%!   zval = -abs (norminv (0.5*pval));
-%! endif
-%! unew = zval * sqrt (v_x/n_x + v_y/n_y);
-%! delmu = mean (x) - mean (y);
-%! assert (delmu, unew, 100*eps);
-
-#!test
-%! x = randn (100, 1); v_x = 2; x = v_x * x;
-%! [pval, z] = z_test_2 (x, x, v_x, v_x, ">");
-%! zval_exp = 0; pval_exp = 0.5;
-%! assert (zval, zval_exp, eps);
-%! assert (pval, pval_exp, eps);
-
-%!test
-%! x = randn (10000, 1); v_x = 2; x = v_x * x; n_x = length (x);
-%! y = randn (20000, 1); v_y = 3; y = v_y * y; n_y = length (y);
-%! [pval, z] = z_test_2 (x, y, v_x, v_y, ">");
-%! zval = norminv (1-pval);
-%! unew = zval * sqrt (v_x/n_x + v_y/n_y);
-%! delmu = mean (x) - mean (y);
-%! assert (delmu, unew, 100*eps);
-
-%!test
-%! x = randn (100, 1); v_x = 2; x = v_x * x;
-%! [pval, zval] = z_test_2 (x, x, v_x, v_x, "<");
-%! zval_exp = 0; pval_exp = 0.5;
-%! assert (zval, zval_exp, eps);
-%! assert (pval, pval_exp, eps);
-
-%!test
-%! x = randn (10000, 1); v_x = 2; x = v_x * x; n_x = length (x);
-%! y = randn (20000, 1); v_y = 3; y = v_y * y; n_y = length (y);
-%! [pval, z] = z_test_2 (x, y, v_x, v_y, "<");
-%! zval = norminv (pval);
-%! unew = zval * sqrt (v_x/n_x + v_y/n_y);
-%! delmu = mean (x) - mean (y);
-%! assert (delmu, unew, 100*eps);
diff --git a/scripts/statistics/base/var.m b/scripts/statistics/var.m
rename from scripts/statistics/base/var.m
rename to scripts/statistics/var.m
diff --git a/scripts/statistics/base/zscore.m b/scripts/statistics/zscore.m
rename from scripts/statistics/base/zscore.m
rename to scripts/statistics/zscore.m
