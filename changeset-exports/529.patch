# HG changeset patch
# User jwe
# Date 774731948 0
#      Wed Jul 20 19:19:08 1994 +0000
# Node ID 7ea224e713cd98e2327927cec9a57c466352592f
# Parent  e1e6e33e26f8f75419950f5ee17ec6451abbd6fe
[project @ 1994-07-20 18:54:27 by jwe]

diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -17,88 +17,119 @@ include $(TOPDIR)/Makeconf
 LIBOBJS = @LIBOBJS@
 
 # Cancel default rule for .c from .y and make .cc from .y instead.
 
 %.c : %.y
 
 %.cc : %.y
 	$(YACC) $(YFLAGS) $<
-	mv y.tab.c $(@F)
+	@$(top_srcdir)/move-if-change y.tab.c $(@F)
 
 # Likewise for .c from .l.
 
 %.c : %.l
 
 %.cc : %.l
 	$(LEX) $(LFLAGS) $< > $(@F)
 
-INCLUDES = arith-ops.h builtins.h dynamic-ld.h defaults.h.in \
-	defaults.h error.h f-balance.h f-chol.h f-colloc.h f-dassl.h \
-	f-det.h f-eig.h f-expm.h f-fft.h f-fsolve.h f-fsqp.h f-givens.h \
-	f-hess.h f-ifft.h f-inv.h f-lpsolve.h f-lsode.h f-lu.h \
-	f-npsol.h f-qpsol.h f-qr.h f-quad.h f-qzval.h f-rand.h \
-	f-schur.h f-svd.h f-syl.h file-io.h fnmatch.h g-builtins.h \
-	getopt.h gripes.h help.h idx-vector.h input.h lex.h mappers.h \
-	missing-math.h octave.h octave-hist.h oct-obj.h pager.h parse.h \
-	pr-output.h procstream.h sighandlers.h statdefs.h symtab.h \
-	sysdep.h t-builtins.h token.h tree.h tree-cmd.h tree-const.h \
-	tree-expr.h tree-plot.h tc-rep.h unwind-prot.h user-prefs.h \
-	utils.h variables.h version.h xdiv.h xpow.h SLStack.h Stack.h
+%.def : %.cc
+	@echo making $@ from $<
+	@$(CXXCPP) -c $(CPPFLAGS) $(ALL_CXXFLAGS) -DMAKE_BUILTINS $< \
+	  | $(srcdir)/mkdefs > $@.tmp
+	@mv $@.tmp $@
+
+DLD_SRC = f-balance.cc f-chol.cc f-colloc.cc f-dassl.cc f-det.cc \
+	f-eig.cc f-expm.cc f-fft.cc f-find.cc \
+	f-fsolve.cc f-fsqp.cc f-givens.cc f-hess.cc f-ifft.cc \
+	f-inv.cc f-log.cc f-lpsolve.cc f-lsode.cc f-lu.cc \
+	f-minmax.cc f-npsol.cc f-qpsol.cc f-qr.cc f-quad.cc f-qzval.cc \
+	f-rand.cc f-schur.cc f-sort.cc f-svd.cc f-syl.cc
+
+
+DLD_OBJ = f-balance.o f-chol.o f-colloc.o f-dassl.o f-det.o f-eig.o \
+	f-expm.o f-fft.o f-find.o f-fsolve.o \
+	f-fsqp.o f-givens.o f-hess.o f-ifft.o f-inv.o \
+	f-log.o f-lpsolve.o f-lsode.o f-lu.o f-minmax.o f-npsol.o \
+	f-qpsol.o f-qr.o f-quad.o f-qzval.o f-rand.o f-schur.o \
+	f-sort.o f-svd.o f-syl.o
 
-SOURCES = arith-ops.cc builtins.cc dynamic-ld.cc error.cc f-chol.cc \
-	f-colloc.cc f-balance.cc f-dassl.cc f-det.cc f-eig.cc \
-	f-expm.cc f-fft.cc f-fsolve.cc f-fsqp.cc f-givens.cc \
-	f-hess.cc f-ifft.cc f-inv.cc f-lpsolve.cc f-lsode.cc f-lu.cc \
-	f-npsol.cc f-qpsol.cc f-qr.cc f-quad.cc f-qzval.cc f-rand.cc \
-	f-schur.cc f-svd.cc f-syl.cc file-io.cc	fnmatch.c \
-	g-builtins.cc getopt.c getopt1.c gripes.cc help.cc \
-	idx-vector.cc input.cc lex.l mappers.cc octave.cc \
-	octave-hist.cc pager.cc parse.y pr-output.cc procstream.cc \
-	sighandlers.cc strcasecmp.c strncase.c symtab.cc sysdep.cc \
-	t-builtins.cc token.cc tree-cmd.cc tree-const.cc tree-expr.cc \
-	tree-plot.cc tc-rep.cc unwind-prot.cc user-prefs.cc utils.cc \
-	variables.cc xdiv.cc xpow.cc SLStack.cc
+INCLUDES = arith-ops.h builtins.h defaults.h.in defun.h defun-dld.h \
+	defun-int.h dirfns.h dynamic-ld.h error.h file-io.h fnmatch.h \
+	getopt.h gripes.h help.h idx-vector.h input.h lex.h mappers.h \
+	missing-math.h octave.h octave-hist.h \
+	oct-obj.h pager.h parse.h pr-output.h procstream.h \
+	sighandlers.h statdefs.h symtab.h sysdep.h token.h tree.h \
+	tree-base.h tree-cmd.h tree-const.h tree-expr.h tree-plot.h \
+	tc-rep.h unwind-prot.h user-prefs.h utils.h variables.h \
+	version.h xdiv.h xpow.h SLStack.h Stack.h
 
-DEP_SOURCES_2 = $(patsubst %.l, %.cc, $(SOURCES))
+SOURCES = arith-ops.cc data.cc dirfns.cc dynamic-ld.cc \
+	error.cc file-io.cc fnmatch.c getopt.c getopt1.c gripes.cc \
+	help.cc idx-vector.cc input.cc lex.l mappers.cc octave.cc \
+	oct-obj.cc octave-hist.cc pager.cc parse.y pr-output.cc \
+	procstream.cc sighandlers.cc strcasecmp.c strncase.c symtab.cc \
+	sysdep.cc tc-rep.cc timefns.cc token.cc tree-cmd.cc \
+	tree-const.cc tree-expr.cc tree-plot.cc unwind-prot.cc \
+	user-prefs.cc utils.cc variables.cc xdiv.cc xpow.cc SLStack.cc \
+	$(DLD_SRC)
+
+# Ugh.
+
+DEP_SOURCES_2 = $(patsubst %.l, %.cc, $(SOURCES)) builtins.cc
 DEP_SOURCES_1 = $(patsubst %.y, %.cc, $(DEP_SOURCES_2))
 DEP_SOURCES = $(patsubst %.c, %.d, $(DEP_SOURCES_1))
 MAKEDEPS = $(patsubst %.cc, %.d, $(DEP_SOURCES))
 
-DLD_OBJECTS = f-balance.o f-chol.o f-colloc.o f-dassl.o f-det.o \
-	f-eig.o f-expm.o f-fft.o f-fsolve.o f-fsqp.o f-givens.o \
-	f-hess.o f-ifft.o f-inv.o f-lpsolve.o f-lsode.o f-lu.o \
-	f-npsol.o f-qpsol.o f-qr.o f-quad.o f-qzval.o f-rand.o \
-	f-schur.o f-svd.o f-syl.o 
+DEF_FILES_4 = $(addprefix $(srcdir)/, $(SOURCES))
+DEF_FILES_3 = $(notdir $(shell grep -l "^DEFUN" $(DEF_FILES_4)))
+DEF_FILES_2 = $(patsubst %.y, %.def, $(DEF_FILES_3))
+DEF_FILES_1 = $(patsubst %.l, %.def, $(DEF_FILES_2))
+DEF_FILES = $(patsubst %.cc, %.def, $(DEF_FILES_1))
+
+# XXX FIXME XXX -- Should these be generated automatically from the
+# list of source files?
 
-OBJECTS = arith-ops.o builtins.o error.o file-io.o fnmatch.o \
-	g-builtins.o getopt.o getopt1.o gripes.o help.o idx-vector.o \
-	input.o lex.o mappers.o octave.o octave-hist.o pager.o \
-	parse.o pr-output.o procstream.o sighandlers.o strcasecmp.o \
-	strncase.o symtab.o sysdep.o t-builtins.o token.o tree-cmd.o \
-	tree-const.o tree-expr.o tree-plot.o tc-rep.o unwind-prot.o \
-	user-prefs.o utils.o variables.o xdiv.o xpow.o SLStack.o \
+OBJECTS = arith-ops.o builtins.o data.o dirfns.o error.o \
+	file-io.o fnmatch.o getopt.o getopt1.o gripes.o help.o \
+	idx-vector.o input.o lex.o mappers.o octave.o octave-hist.o \
+	oct-obj.o pager.o parse.o pr-output.o procstream.o sighandlers.o \
+	strcasecmp.o strncase.o symtab.o sysdep.o tc-rep.o timefns.o \
+	token.o tree-cmd.o tree-const.o tree-expr.o tree-plot.o \
+	unwind-prot.o user-prefs.o utils.o variables.o xdiv.o xpow.o \
+	SLStack.o \
 	@DYNAMIC_LD_OBJ@
 
-OCTAVE_LIBS = ../liboctave.a ../libcruft.a ../libinfo.a \
+OCTAVE_LIBS = @LIBOCTDLD@ ../liboctave.a ../libcruft.a ../libinfo.a \
 	../libreadline.a @LIBDLD@
 
-DISTFILES = Makefile.in move-if-change parse.cc lex.cc y.tab.h \
-	$(INCLUDES) $(SOURCES)
+DISTFILES = Makefile.in mkdefs mkbuiltins \
+	parse.cc lex.cc y.tab.h $(INCLUDES) $(SOURCES)
 
 all: defaults.h octave
 .PHONY: all
 
-octave: $(DLD_OBJECTS) $(OBJECTS) $(OCTAVE_LIBS) $(LIBOBJS)
+octave: $(OBJECTS) $(DLD_OBJ) $(LIBOBJS) $(OCTAVE_LIBS) ../liboctdld.a
 	$(CXX) $(CPPFLAGS) $(ALL_CXXFLAGS) $(ALL_LDFLAGS) -o octave \
-	$(OBJECTS) @DLD_OBJECTS@ \
+	$(OBJECTS) \
 	$(OCTAVE_LIBS) \
 	$(LIBOBJS) \
 	$(FLIBS) $(LEXLIB) -ltermcap -lm -lg++
 
+../liboctdld.a: $(DLD_OBJ)
+	$(AR) $(ARFLAGS) ../liboctdld.a $(DLD_OBJ)
+	$(RANLIB) ../liboctdld.a
+
+builtins.cc: $(DEF_FILES) mkbuiltins
+	@echo making $@ from $(DEF_FILES)
+	@$(srcdir)/mkbuiltins $(DEF_FILES) > $@.tmp
+	@$(top_srcdir)/move-if-change $@.tmp $@
+
+$(DEF_FILES): mkdefs
+
 check: all
 .PHONY: check
 
 install: all
 	if test -d $(bindir) ; then true ; else $(TOPDIR)/mkpath $(bindir) ; fi
 	rm -f $(bindir)/octave
 	$(INSTALL) octave $(bindir)/octave-$(version)
 	ln $(bindir)/octave-$(version) $(bindir)/octave
@@ -110,17 +141,17 @@ uninstall:
 
 tags: $(SOURCES)
 	ctags $(SOURCES)
 
 TAGS: $(SOURCES)
 	etags $(SOURCES)
 
 clean:
-	rm -f *.a *.o
+	rm -f *.a *.o *.def builtins.cc
 .PHONY: clean
 
 mostlyclean:
 	rm -f *.o
 .PHONY: mostlyclean
 
 distclean: clean
 	rm -f Makefile octave .fname *.d
@@ -137,18 +168,18 @@ local-dist: parse.cc lex.cc
 
 dist: parse.cc lex.cc
 	ln $(DISTFILES) ../`cat ../.fname`/src
 	rm -f parse.cc lex.cc y.tab.h
 .PHONY: dist
 
 # Special rules -- these files need special things to be defined.
 
-defaults.h: ../Makeconf Makefile defaults.h.in
-	@echo "Making defaults.h from defaults.h.in..."
-	@(sed < $(srcdir)/defaults.h.in > defaults.h.tmp \
+defaults.h: defaults.h.in ../Makeconf Makefile
+	@echo "making defaults.h from defaults.h.in"
+	@(sed < $< > $@.tmp \
 	  -e 's;%DEFAULT_PAGER%;\"${DEFAULT_PAGER}\";' \
 	  -e 's;%OCTAVE_HOME%;\"${OCTAVE_HOME}\";' \
 	  -e 's;%OCTAVE_LIB_DIR%;\"${OCTAVE_LIB_DIR}\";' \
 	  -e 's;%OCTAVE_INFO_DIR%;\"${OCTAVE_INFO_DIR}\";')
-	@$(srcdir)/move-if-change defaults.h.tmp defaults.h
+	@$(top_srcdir)/move-if-change $@.tmp $@
 
 include $(MAKEDEPS)
diff --git a/src/builtins.h b/src/builtins.h
--- a/src/builtins.h
+++ b/src/builtins.h
@@ -1,9 +1,9 @@
-// Builtin function support.                               -*- C++ -*-
+// builtins.h                                          -*- C++ -*-
 /*
 
 Copyright (C) 1992, 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -19,79 +19,17 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (octave_builtins_h)
 #define octave_builtins_h 1
 
-class ostrstream;
-class Complex;
-struct help_list;
-
-typedef double (*d_d_Mapper)(double);
-typedef double (*d_c_Mapper)(const Complex&);
-typedef Complex (*c_c_Mapper)(const Complex&);
-
-// If can_return_complex_for_real_arg is 1, lower_limit and
-// upper_limit specify the range of values for which a real arg
-// returns a real value.  Outside that range, we have to convert args
-// to complex, and call the complex valued function.
-//
-// If can_return_complex_for_real_arg is 0, lower_limit and
-// upper_limit are ignored.
-
-struct Mapper_fcn
-{
-  int can_return_complex_for_real_arg;
-  double lower_limit;
-  double upper_limit;
-  d_d_Mapper d_d_mapper;
-  d_c_Mapper d_c_mapper;
-  c_c_Mapper c_c_mapper;
-};
-
-struct builtin_mapper_functions
-{
-  char *name;
-  int can_return_complex_for_real_arg;
-  double lower_limit;
-  double upper_limit;
-  d_d_Mapper d_d_mapper;
-  d_c_Mapper d_c_mapper;
-  c_c_Mapper c_c_mapper;
-  char *help_string;
-};
-
-typedef int (*sv_Function)(void);
-
-struct builtin_string_variables
-{
-  char *name;
-  char *value;
-  sv_Function sv_function;
-  char *help_string;
-};
-
 extern void install_builtins (void);
-extern int is_text_function_name (const char *s);
-
-extern help_list *builtin_mapper_functions_help (void);
-extern help_list *builtin_general_functions_help (void);
-extern help_list *builtin_text_functions_help (void);
-extern help_list *builtin_variables_help (void);
-
-extern int help_from_list (ostrstream& output_buf,
-			   const help_list *list, const char *string,
-			   int usage);
-
-extern void additional_help_message (ostrstream& output_buf);
-
-extern void print_usage (const char *s, int just_usage = 0);
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -41,18 +41,20 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "statdefs.h"
 #include "file-io.h"
 #include "input.h"
 #include "octave-hist.h"
 #include "tree-const.h"
 #include "error.h"
 #include "utils.h"
 #include "pager.h"
+#include "defun.h"
 #include "sysdep.h"
 #include "mappers.h"
+#include "variables.h"
 
 // keeps a count of how many files are open and in the file list
 static int file_count = 0;
 
 // keeps a count of args sent to printf or scanf
 static int fmt_arg_count = 0;
 
 class file_info
@@ -79,19 +81,19 @@ class file_info
   char *file_name;
   FILE *file_fptr;
   char *file_mode;
 };
 
 file_info::file_info (void)
 {
   file_number = -1;
-  file_name = (char *) NULL;
-  file_fptr = (FILE *) NULL;
-  file_mode = (char *) NULL;
+  file_name = 0;
+  file_fptr = 0;
+  file_mode = 0;
 }
 
 file_info::file_info (int n, const char *nm, FILE *t, const char *md)
 {
   file_number = n;
   file_name = strsave (nm);
   file_fptr = t;
   file_mode = strsave (md);
@@ -204,27 +206,27 @@ return_valid_file (const tree_constant& 
 	      file_list.next (p);
 	    }
 	  error ("no file with that number");
 	}
       }
     else
       error ("inapproriate file specifier");
 
-  return (Pix) NULL;
+  return 0;
 }
 
 static Pix 
 fopen_file_for_user (const tree_constant& arg, const char *mode,
 		     const char *warn_for)
 {
   char *file_name = arg.string_value ();
 
   FILE *file_ptr = fopen (file_name, mode);
-  if (file_ptr != (FILE *) NULL)
+  if (file_ptr)
     {
       file_info file (++file_count, file_name, file_ptr, mode);
       file_list.append (file);
       
       Pix p = file_list.first ();
       file_info file_from_list;
       
       for (int i = 0; i < file_count; i++)
@@ -233,26 +235,26 @@ fopen_file_for_user (const tree_constant
 	  if (strcmp (file_from_list.name (), file_name) == 0)
 	    return p;
 	  file_list.next (p);
 	}
     }
 
   error ("%s: unable to open file `%s'", warn_for, file_name);
 
-  return (Pix) NULL;
+  return 0;
 }
 
 static Pix
 file_io_get_file (const tree_constant arg, const char *mode,
 		  const char *warn_for)
 {
   Pix p = return_valid_file (arg);
 
-  if (p == (Pix) NULL)
+  if (! p)
     {
       if (arg.is_string_type ())
 	{
 	  char *name = arg.string_value ();
 
 	  struct stat buffer;
 	  int status = stat (name, &buffer);
 
@@ -270,24 +272,39 @@ file_io_get_file (const tree_constant ar
 	}
       else
 	error ("%s: invalid file specifier", warn_for);
     }
 
   return p;
 }
 
+DEFUN ("fclose", Ffclose, Sfclose, 2, 1,
+  "fclose (FILENAME or FILENUM): close a file")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin != 2)
+    print_usage ("fclose");
+  else
+    retval = fclose_internal (args);
+
+  return retval;
+}
+
 Octave_object
 fclose_internal (const Octave_object& args)
 {
   Octave_object retval;
 
   Pix p = return_valid_file (args(1));
 
-  if (p == (Pix) NULL)
+  if (! p)
     return retval;
 
   file_info file = file_list (p);
 
   if (file.number () < 3)
     {
       warning ("fclose: can't close stdin, stdout, or stderr!");
       return retval;
@@ -304,24 +321,39 @@ fclose_internal (const Octave_object& ar
     {
       error ("fclose: error on closing file");
       retval(0) = tree_constant (0.0); // failed
     }
 
   return retval;
 }
 
+DEFUN ("fflush", Ffflush, Sfflush, 2, 1,
+  "fflush (FILENAME or FILENUM): flush buffered data to output file")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin != 2)
+    print_usage ("fflush");
+  else
+    retval = fflush_internal (args);
+
+  return retval;
+}
+
 Octave_object
 fflush_internal (const Octave_object& args)
 {
   Octave_object retval;
 
   Pix p = return_valid_file (args(1));
 
-  if (p == (Pix) NULL)
+  if (! p)
     return retval;
 
   file_info file = file_list (p);
 
   if (strcmp (file.mode (), "r") == 0)
     {
       warning ("can't flush an input stream");
       return retval;
@@ -344,36 +376,53 @@ fflush_internal (const Octave_object& ar
     }
 
   return retval;
 }
 
 static int
 valid_mode (const char *mode)
 {
-  if (mode != (char *) NULL)
+  if (mode)
     {
       char m = mode[0];
       if (m == 'r' || m == 'w' || m == 'a')
 	{
 	  m = mode[1];
 	  return (m == '\0' || (m == '+' && mode[2] == '\0'));
 	}
     }
   return 0;
 }
 
+DEFUN ("fgets", Ffgets, Sfgets, 3, 2,
+  "[STRING, LENGTH] = fgets (FILENAME or FILENUM, LENGTH)\n\
+\n\
+read a string from a file")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin != 3)
+    print_usage ("fgets");
+  else
+    retval = fgets_internal (args, nargout);
+
+  return retval;
+}
+
 Octave_object
 fgets_internal (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
   Pix p = file_io_get_file (args(1), "r", "fgets");
   
-  if (p == (Pix) NULL)
+  if (! p)
     return retval;
 
   int length = 0;
   if (args(2).is_scalar_type ())
     {
       length = (int) args(2).double_value ();
       if ((double) NINT (length) != length)
 	{
@@ -382,17 +431,17 @@ fgets_internal (const Octave_object& arg
 	}
     }
 
   file_info file = file_list (p);
 
   char string[length+1];
   char *success = fgets (string, length+1, file.fptr ());
 
-  if (success == (char *) NULL)
+  if (! success)
     {
       retval.resize (1);
       retval(0) = tree_constant (-1.0);
       return retval;
     }
 
   if (nargout == 2)
     {
@@ -402,31 +451,56 @@ fgets_internal (const Octave_object& arg
   else
     retval.resize (1);
 
   retval(0) = tree_constant (string);
 
   return retval;
 }
 
+DEFUN ("fopen", Ffopen, Sfopen, 3, 1,
+  "FILENUM = fopen (FILENAME, MODE): open a file\n\
+\n\
+  Valid values for mode include:\n\
+\n\
+   r  : open text file for reading\n\
+   w  : open text file for writing; discard previous contents if any\n\
+   a  : append; open or create text file for writing at end of file\n\
+   r+ : open text file for update (i.e., reading and writing)\n\
+   w+ : create text file for update; discard previous contents if any\n\
+   a+ : append; open or create text file for update, writing at end\n\n\
+ Update mode permits reading from and writing to the same file.")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin != 3)
+    print_usage ("fopen");
+  else
+    retval = fopen_internal (args);
+
+  return retval;
+}
+
 Octave_object
 fopen_internal (const Octave_object& args)
 {
   Octave_object retval;
   Pix p;
 
   if (! args(1).is_string_type ())
     {
       error ("fopen: file name must be a string");
       return retval;
     }
 
   p = return_valid_file (args(1));
 
-  if (p != (Pix) NULL)
+  if (p)
     {
       file_info file = file_list (p);
 
       retval.resize (1);
       retval(0) = tree_constant ((double) file.number ());
 
       return retval;
     }
@@ -450,33 +524,48 @@ fopen_internal (const Octave_object& arg
   if (stat (name, &buffer) == 0 && (buffer.st_mode & S_IFDIR) == S_IFDIR)
     {
       error ("fopen: can't open directory");
       return retval;
     }
 
   FILE *file_ptr = fopen (name, mode);
 
-  if (file_ptr == (FILE *) NULL)
+  if (! file_ptr)
     {
       error ("fopen: unable to open file `%s'", name);
       return retval;
     }
 
   int number = file_count++;
 
   file_info file (number, name, file_ptr, mode);
   file_list.append (file);
 
   retval.resize (1);
   retval(0) = tree_constant ((double) number);
 
   return retval;
 }
 
+DEFUN ("freport", Ffreport, Sfreport, 1, 1,
+  "freport (): list open files and their status")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin > 1)
+    warning ("freport: ignoring extra arguments");
+
+  retval = freport_internal ();
+
+  return retval;
+}
+
 Octave_object
 freport_internal (void)
 {
   Octave_object retval;
   Pix p = file_list.first ();
 
   ostrstream output_buf;
 
@@ -490,42 +579,74 @@ freport_internal (void)
     }
 
   output_buf << "\n" << ends;
   maybe_page_output (output_buf);
 
   return retval;
 }
 
+DEFUN ("frewind", Ffrewind, Sfrewind, 2, 1,
+  "frewind (FILENAME or FILENUM): set file position at beginning of file")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin != 2)
+    print_usage ("frewind");
+  else
+    retval = frewind_internal (args);
+
+  return retval;
+}
+
 Octave_object
 frewind_internal (const Octave_object& args)
 {
   Octave_object retval;
 
   Pix p = file_io_get_file (args(1), "a+", "frewind");
 
-  if (p != (Pix) NULL)
+  if (p)
     {
       file_info file = file_list (p);
       rewind (file.fptr ());
     }
 
   return retval;
 }
 
+DEFUN ("fseek", Ffseek, Sfseek, 4, 1,
+  "fseek (FILENAME or FILENUM, OFFSET [, ORIGIN])\n\
+\n\
+set file position for reading or writing")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin != 3 && nargin != 4)
+    print_usage ("fseek");
+  else
+    retval = fseek_internal (args);
+
+  return retval;
+}
+
 Octave_object
 fseek_internal (const Octave_object& args)
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   Pix p = file_io_get_file (args(1), "a+", "fseek");
 
-  if (p == (Pix) NULL)
+  if (! p)
     return retval;
 
   long origin = SEEK_SET;
   long offset = 0;
   if (args(2).is_scalar_type ())
     {
       offset = (long) args(2).double_value ();
       if ((double) NINT (offset) != offset)
@@ -562,24 +683,42 @@ fseek_internal (const Octave_object& arg
     {
       error ("fseek: file error");
       retval(0) = tree_constant (0.0); // failed
     }
 
   return retval;
 }
 
+/*
+ * Tell current position of file.
+ */
+DEFUN ("ftell", Fftell, Sftell, 2, 1,
+  "POSITION = ftell (FILENAME or FILENUM): returns the current file position")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin != 2)
+    print_usage ("ftell");
+  else
+    retval = ftell_internal (args);
+
+  return retval;
+}
+
 Octave_object
 ftell_internal (const Octave_object& args)
 {
   Octave_object retval;
 
   Pix p = file_io_get_file (args(1), "a+", "ftell");
 
-  if (p != (Pix) NULL)
+  if (p)
     {
       file_info file = file_list (p);
       long offset = ftell (file.fptr ());
       retval.resize (1);
       retval(0) = tree_constant ((double) offset);
 
       if (offset == -1L)
 	error ("ftell: write error");
@@ -802,16 +941,70 @@ process_printf_format (const char *s, co
   return -1;
 
  invalid_format:
   error ("%s: invalid format", type);
   return -1;
 }
 
 
+/*
+ * Formatted printing to a file.
+ */
+DEFUN ("fprintf", Ffprintf, Sfprintf, -1, 1,
+  "fprintf (FILENAME or FILENUM, FORMAT, ...)")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin < 3)
+    print_usage ("fprintf");
+  else
+    retval = do_printf ("fprintf", args, nargout);
+
+  return retval;
+}
+
+/*
+ * Formatted printing.
+ */
+DEFUN ("printf", Fprintf, Sprintf, -1, 1,
+  "printf (FORMAT, ...)")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin < 2)
+    print_usage ("printf");
+  else
+    retval = do_printf ("printf", args, nargout);
+
+  return retval;
+}
+
+/*
+ * Formatted printing to a string.
+ */
+DEFUN ("sprintf", Fsprintf, Ssprintf, -1, 1,
+  "s = sprintf (FORMAT, ...)")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin < 2)
+    print_usage ("sprintf");
+  else
+    retval = do_printf ("sprintf", args, nargout);
+
+  return retval;
+}
+
 Octave_object
 do_printf (const char *type, const Octave_object& args, int nargout)
 {
   Octave_object retval;
   fmt_arg_count = 1;
   char *fmt;
   file_info file;
 
@@ -825,17 +1018,17 @@ do_printf (const char *type, const Octav
       else
 	{
 	  error ("%s: format must be a string", type);
 	  return retval;
 	}
 
       Pix p = file_io_get_file (args(1), "a+", type);
 
-      if (p == (Pix) NULL)
+      if (! p)
 	return retval;
 
       file = file_list (p);
 
       if (file.mode () == "r")
 	{
 	  error ("%s: file is read only", type);
 	  return retval;
@@ -1065,24 +1258,78 @@ process_scanf_format (const char *s, ost
     {
     invalid_format:
       warning ("%s: invalid format", type);
     }
 
   return -1;
 }
 
+/*
+ * Formatted reading from a file.
+ */
+DEFUN ("fscanf", Ffscanf, Sfscanf, 3, -1,
+  "[A, B, C, ...] = fscanf (FILENAME or FILENUM, FORMAT)")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin != 2 && nargin != 3)
+    print_usage ("fscanf");
+  else
+    retval = do_scanf ("fscanf", args, nargout);
+
+  return retval;
+}
+
+/*
+ * Formatted reading.
+ */
+DEFUN ("scanf", Fscanf, Sscanf, 2, -1,
+  "[A, B, C, ...] = scanf (FORMAT)")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin != 2)
+    print_usage ("scanf");
+  else
+    retval = do_scanf ("scanf", args, nargout);
+
+  return retval;
+}
+
+/*
+ * Formatted reading from a string.
+ */
+DEFUN ("sscanf", Fsscanf, Ssscanf, 3, -1,
+  "[A, B, C, ...] = sscanf (STRING, FORMAT)")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin != 3)
+    print_usage ("sscanf");
+  else
+    retval = do_scanf ("sscanf", args, nargout);
+
+  return retval;
+}
+
 Octave_object
 do_scanf (const char *type, const Octave_object& args, int nargout)
 {
   Octave_object retval;
-  char *scanf_fmt = (char *) NULL;
-  char *tmp_file = (char *) NULL;
+  char *scanf_fmt = 0;
+  char *tmp_file = 0;
   int tmp_file_open = 0;
-  FILE *fptr = (FILE *) NULL;
+  FILE *fptr = 0;
   file_info file;
 
   fmt_arg_count = 0;
 
   if (strcmp (type, "scanf") != 0)
     {
       if (args(2).is_string_type ())
 	scanf_fmt = args(2).string_value ();
@@ -1094,31 +1341,31 @@ do_scanf (const char *type, const Octave
     }
 
   int doing_fscanf = (strcmp (type, "fscanf") == 0);
 
   if (doing_fscanf)
     {
       Pix p = file_io_get_file (args(1), "r", type);
 
-      if (p == (Pix) NULL)
+      if (! p)
 	return retval;
 
       file = file_list (p);
 
       if (strcmp (file.mode (), "w") == 0 || strcmp (file.mode (), "a") == 0)
 	{
 	  error ("%s: this file is opened for writing only", type);
 	  return retval;
 	}
 
       fptr = file.fptr ();
     }
 
-  if ((fptr == (FILE *) NULL && args(1).is_string_type ())
+  if ((! fptr && args(1).is_string_type ())
       || (doing_fscanf && file.number () == 0))
     {
       char *string;
 
       if (strcmp (type, "scanf") == 0)
 	scanf_fmt = args(1).string_value ();
 
       if (strcmp (type, "scanf") == 0
@@ -1126,28 +1373,28 @@ do_scanf (const char *type, const Octave
 	{
 	  string = gnu_readline ("");
 	  if (string && *string)
 	    maybe_save_history (string);
 	}
       else
 	string = args(1).string_value ();
 
-      tmp_file = tmpnam ((char *) NULL);
+      tmp_file = tmpnam (0);
 
       fptr = fopen (tmp_file, "w+");
-      if (fptr == (FILE *) NULL)
+      if (! fptr)
 	{
 	  error ("%s: error opening temporary file", type);
 	  return retval;
 	}
       tmp_file_open = 1;
       unlink (tmp_file);
 
-      if (string == (char *) NULL)
+      if (! string)
 	panic_impossible ();
 
       int success = fputs (string, fptr);
       fflush (fptr);
       rewind (fptr);
 
       if (success < 0)
 	{
@@ -1244,16 +1491,43 @@ num_items_remaining (FILE *fptr, char *t
 
   fseek (fptr, curr_pos, SEEK_SET);
 
   long len = end_of_file - curr_pos;
 
   return len / size;
 }
 
+DEFUN ("fread", Ffread, Sfread, 4, 2,
+  "[DATA, COUNT] = fread (FILENUM, SIZE, PRECISION)\n\
+\n\
+ Reads data in binary form of type PRECISION from a file.\n\
+\n\
+ FILENUM   : file number from fopen\n\
+ SIZE      : size specification for the Data matrix\n\
+ PRECISION : type of data to read, valid types are\n\
+\n\
+               'char',   'schar', 'short',  'int',  'long', 'float'\n\
+               'double', 'uchar', 'ushort', 'uint', 'ulong'\n\
+\n\
+ DATA      : matrix in which the data is stored\n\
+ COUNT     : number of elements read")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin < 2 || nargin > 4)
+    print_usage ("fread");
+  else
+    retval = fread_internal (args, nargout);
+
+  return retval;
+}
+
 /*
  * Read binary data from a file.
  *
  *   [data, count] = fread (fid, size, 'precision')
  *
  *     fid       : the file id from fopen
  *     size      : the size of the matrix or vector or scaler to read
  *
@@ -1276,17 +1550,17 @@ Octave_object
 fread_internal (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   Pix p = file_io_get_file (args(1), "r", "fread");
 
-  if (p == (Pix) NULL)
+  if (! p)
     return retval;
 
 // Get type and number of bytes per element to read.
   char *prec = "uchar";
   if (nargin > 3)
     {
       if (args(3).is_string_type ())
 	prec = args(3).string_value ();
@@ -1387,16 +1661,42 @@ fread_internal (const Octave_object& arg
   else
     retval.resize (1);
 
   retval(0) = tree_constant (m);
 
   return retval;
 }
 
+DEFUN ("fwrite", Ffwrite, Sfwrite, 4, 1,
+  "COUNT = fwrite (FILENUM, DATA, PRECISION)\n\
+\n\
+ Writes data to a file in binary form of size PRECISION\n\
+\n\
+ FILENUM   : file number from fopen\n\
+ DATA      : matrix of elements to be written\n\
+ PRECISION : type of data to read, valid types are\n\
+\n\
+               'char',   'schar', 'short',  'int',  'long', 'float'\n\
+               'double', 'uchar', 'ushort', 'uint', 'ulong'\n\
+\n\
+ COUNT     : number of elements written")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin < 3 || nargin > 4)
+    print_usage ("fwrite");
+  else
+    retval = fwrite_internal (args, nargout);
+
+  return retval;
+}
+
 /*
  * Write binary data to a file.
  *
  *   count = fwrite (fid, data, 'precision')
  *
  *    fid	: file id from fopen
  *    Data	: data to be written
  *    precision	: type of output element.  Can be:
@@ -1412,17 +1712,17 @@ Octave_object
 fwrite_internal (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
   int nargin = args.length ();
 
   Pix p = file_io_get_file (args(1), "a+", "fwrite");
 
-  if (p == (Pix) NULL)
+  if (! p)
     return retval;
 
 // Get type and number of bytes per element to read.
   char *prec = "uchar";
   if (nargin > 3)
     {
       if (args(3).is_string_type ())
 	prec = args(3).string_value ();
@@ -1440,39 +1740,75 @@ fwrite_internal (const Octave_object& ar
   int count = m.write (file.fptr (), prec);
 
   retval.resize (1);
   retval(0) = tree_constant ((double) count);
 
   return retval;
 }
 
+DEFUN ("feof", Ffeof, Sfeof, 2, 1,
+  "ERROR = feof (FILENAME or FILENUM)\n\
+\n\
+ Returns a non zero value for an end of file condition for the\n\
+ file specified by FILENAME or FILENUM from fopen")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin != 2)
+    print_usage ("feof");
+  else
+    retval = feof_internal (args, nargout);
+
+  return retval;
+}
+
 /*
  * Check for an EOF condition on a file opened by fopen.
  *
  *   eof = feof (fid)
  *
  *     fid : file id from fopen
  *     eof : non zero for an end of file condition
  */
 Octave_object
 feof_internal (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
 // Get file info.
   Pix p = return_valid_file (args(1));
 
-  if (p == (Pix) NULL)
+  if (! p)
     return retval;
 
   file_info file = file_list (p);
 
   retval.resize (1);
-  retval(0) = tree_constant (feof (file.fptr ()));
+  retval(0) = (double) feof (file.fptr ());
+
+  return retval;
+}
+
+DEFUN ("ferror", Fferror, Sferror, 2, 1,
+  "ERROR = ferror (FILENAME or FILENUM)\n\
+\n\
+ Returns a non zero value for an error condition on the\n\
+ file specified by FILENAME or FILENUM from fopen")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin != 2)
+    print_usage ("ferror");
+  else
+    retval = ferror_internal (args, nargout);
 
   return retval;
 }
 
 /*
  * Check for an error condition on a file opened by fopen.
  *
  *   [message, errnum] = ferror (fid)
@@ -1484,17 +1820,17 @@ feof_internal (const Octave_object& args
 Octave_object
 ferror_internal (const Octave_object& args, int nargout)
 {
   Octave_object retval;
 
 // Get file info.
   Pix p = return_valid_file (args(1));
 
-  if (p == (Pix) NULL)
+  if (! p)
     return retval;
 
   file_info file = file_list (p);
 
   int ierr = ferror (file.fptr ());
 
   if (nargout > 1)
     {
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -20,21 +20,52 @@ along with Octave; see the file COPYING.
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
+#include <signal.h>
+#include <stdlib.h>
 #include <iostream.h>
+#include <strstream.h>
 
-#include "builtins.h"
+#include "tree.h"
+#include "sighandlers.h"
+#include "user-prefs.h"
+#include "tree-expr.h"
+#include "variables.h"
+#include "oct-obj.h"
+#include "symtab.h"
+#include "octave.h"
+#include "dirfns.h"
+#include "pager.h"
+#include "error.h"
 #include "utils.h"
 #include "help.h"
+#include "defun.h"
+
+extern "C"
+{
+#include "info/info.h"
+#include "info/dribble.h"
+#include "info/terminal.h"
+
+extern int initialize_info_session ();
+extern int index_entry_exists ();
+extern int do_info_index_search ();
+extern void finish_info_session ();
+extern char *replace_in_documentation ();
+
+// XXX FIXME XXX
+#undef __FUNCTION_DEF
+#include <readline/tilde.h>
+}
 
 static help_list operators[] =
 {
   { "!",
     "Logical not operator.  See also `~'.\n", },
 
   { "!=",
     "Logical not equals operator.  See also `~' and `<>'.\n", },
@@ -154,17 +185,17 @@ transpose, *not* the complex conjugate t
     "Logical or operator.  See also `|'.\n", },
 
   { "~",
     "Logical not operator.  See also `!' and `~'.\n", },
 
   { "~=",
     "Logical not equals operator.  See also `<>' and `!='.\n", },
 
-  { (char *) NULL, (char *) NULL, },
+  { 0, 0, },
 };
 
 static help_list keywords[] =
 {
   { "break",
     "Exit the innermost enclosing while or for loop.\n", },
 
   { "continue",
@@ -210,60 +241,321 @@ static help_list keywords[] =
     "Begin an if block.\n", },
 
   { "return",
     "Return from a function.\n", },
 
   { "while",
     "Begin a while loop.\n", },
 
-  { (char *) NULL, (char *) NULL, },
+  { 0, 0, },
 };
 
 /*
  * Return a copy of the operator or keyword names.
  */
 char **
 names (help_list *lst, int& count)
 {
   count = 0;
   help_list *ptr = lst;
-  while (ptr->name != (char *) NULL)
+  while (ptr->name)
     {
       count++;
       ptr++;
     }
 
   if (count == 0)
-    return (char **) NULL;
+    return 0;
     
   char **name_list = new char * [count+1];
 
   ptr = lst;
   int i = 0;
-  while (ptr->name != (char *) NULL)
+  while (ptr->name)
     {
       name_list[i++] = strsave (ptr->name);
       ptr++;
     }
 
-  name_list[i] = (char *) NULL;
+  name_list[i] = 0;
   return name_list;
 }
 
 help_list *
 operator_help (void)
 {
   return operators;
 }
 
 help_list *
 keyword_help (void)
 {
   return keywords;
 }
 
+static void
+help_syms_list (ostrstream& output_buf, help_list *list,
+		const char *desc)
+{
+  int count = 0;
+  char **symbols = names (list, count);
+  output_buf << "\n*** " << desc << ":\n\n";
+  if (symbols && count > 0)
+    list_in_columns (output_buf, symbols);
+  delete [] symbols;
+}
+
+static void
+simple_help (void)
+{
+  ostrstream output_buf;
+
+  help_syms_list (output_buf, operator_help (), "operators");
+
+  help_syms_list (output_buf, keyword_help (), "reserved words");
+
+  help_syms_list (output_buf, builtin_text_functions_help (),
+		  "text functions (these names are also reserved)");
+
+  help_syms_list (output_buf, builtin_mapper_functions_help (),
+		  "mapper functions");
+
+  help_syms_list (output_buf, builtin_general_functions_help (),
+		  "general functions");
+
+  help_syms_list (output_buf, builtin_variables_help (),
+		  "builtin variables");
+      
+// Also need to list variables and currently compiled functions from
+// the symbol table, if there are any.
+
+// Also need to search octave_path for script files.
+
+  char **path = pathstring_to_vector (user_pref.loadpath);
+
+  char **ptr = path;
+  if (ptr)
+    {
+      while (*ptr)
+	{
+	  int count;
+	  char **names = get_fcn_file_names (count, *ptr, 0);
+	  output_buf << "\n*** function files in "
+		     << make_absolute (*ptr, the_current_working_directory)
+		     << ":\n\n";
+	  if (names && count > 0)
+	    list_in_columns (output_buf, names);
+	  delete [] names;
+	  ptr++;
+	}
+    }
+
+  additional_help_message (output_buf);
+  output_buf << ends;
+  maybe_page_output (output_buf);
+}
+
+static int
+try_info (const char *string, int force = 0)
+{
+  int status = 0;
+
+  char *directory_name = strsave (user_pref.info_file);
+  char *temp = filename_non_directory (directory_name);
+
+  if (temp != directory_name)
+    {
+      *temp = 0;
+      info_add_path (directory_name, INFOPATH_PREPEND);
+    }
+
+  delete [] directory_name;
+
+  NODE *initial_node = info_get_node (user_pref.info_file, 0);
+
+  if (! initial_node)
+    {
+      warning ("can't find info file!\n");
+      status = -1;
+    }
+  else
+    {
+      status = initialize_info_session (initial_node, 0);
+
+      if (status == 0 && (force || index_entry_exists (windows, string)))
+	{
+	  terminal_clear_screen ();
+
+	  terminal_prep_terminal ();
+
+	  display_update_display (windows);
+
+	  info_last_executed_command = 0;
+
+	  if (! force)
+	    do_info_index_search (windows, 0, string);
+
+	  char *format = replace_in_documentation
+	    ("Type \"\\[quit]\" to quit, \"\\[get-help-window]\" for help.");
+
+	  window_message_in_echo_area (format);
+
+	  info_read_and_dispatch ();
+
+	  terminal_goto_xy (0, screenheight - 1);
+
+	  terminal_clear_to_eol ();
+
+	  terminal_unprep_terminal ();
+
+	  status = 1;
+	}
+
+      finish_info_session (initial_node, 0);
+    }
+
+  return status;
+}
+
+DEFUN_TEXT ("help", Fhelp, Shelp, -1, 1,
+  "help [-i] [topic ...]\n\
+\n\
+print cryptic yet witty messages")
+{
+  Octave_object retval;
+
+  DEFINE_ARGV("help");
+
+  if (argc == 1)
+    {
+      simple_help ();
+    }
+  else
+    {
+      if (argv[1] && strcmp (argv[1], "-i") == 0)
+	{
+	  argc--;
+	  argv++;
+
+	  if (argc == 1)
+	    {
+	      volatile sig_handler *old_sigint_handler;
+	      old_sigint_handler = signal (SIGINT, SIG_IGN);
+
+	      try_info (0, 1);
+
+	      signal (SIGINT, old_sigint_handler);
+	    }
+	  else
+	    {
+	      while (--argc > 0)
+		{
+		  argv++;
+
+		  if (! *argv || ! **argv)
+		    continue;
+
+		  volatile sig_handler *old_sigint_handler;
+		  old_sigint_handler = signal (SIGINT, SIG_IGN);
+
+		  if (! try_info (*argv))
+		    {
+		      message ("help",
+			       "sorry, `%s' is not indexed in the manual",
+			       *argv); 
+		      sleep (2);
+		    }
+
+		  signal (SIGINT, old_sigint_handler);
+		}
+	    }
+	}
+      else
+	{
+	  ostrstream output_buf;
+
+	  char *fcn_file_name = 0;
+	  symbol_record *sym_rec;
+	  help_list *op_help_list = operator_help ();
+	  help_list *kw_help_list = keyword_help ();
+
+	  while (--argc > 0)
+	    {
+	      argv++;
+
+	      if (! *argv || ! **argv)
+		continue;
+
+	      if (help_from_list (output_buf, op_help_list, *argv, 0))
+		continue;
+
+	      if (help_from_list (output_buf, kw_help_list, *argv, 0))
+		continue;
+
+	      sym_rec = curr_sym_tab->lookup (*argv, 0, 0);
+	      if (sym_rec)
+		{
+		  char *h = sym_rec->help ();
+		  if (h && *h)
+		    {
+		      output_buf << "\n*** " << *argv << ":\n\n"
+				 << h << "\n";
+		      continue;
+		    }
+		}
+
+	      sym_rec = global_sym_tab->lookup (*argv, 0, 0);
+	      if (sym_rec && ! symbol_out_of_date (sym_rec))
+		{
+		  char *h = sym_rec->help ();
+		  if (h && *h)
+		    {
+		      output_buf << "\n*** " << *argv << ":\n\n"
+				 << h << "\n";
+		      continue;
+		    }
+		}
+
+// Try harder to find function files that might not be defined yet, or
+// that appear to be out of date.  Don\'t execute commands from the
+// file if it turns out to be a script file.
+
+	      fcn_file_name = fcn_file_in_path (*argv);
+	      if (fcn_file_name)
+		{
+		  sym_rec = global_sym_tab->lookup (*argv, 1, 0);
+		  if (sym_rec)
+		    {
+		      tree_identifier tmp (sym_rec);
+		      tmp.parse_fcn_file (0);
+		      char *h = sym_rec->help ();
+		      if (h && *h)
+			{
+			  output_buf << "\n*** " << *argv << ":\n\n"
+				     << h << "\n"; 
+			  continue;
+			}
+		    }
+		}
+	      delete [] fcn_file_name;
+
+	      output_buf << "\nhelp: sorry, `" << *argv
+			 << "' is not documented\n"; 
+	    }
+
+	  additional_help_message (output_buf);
+	  output_buf << ends;
+	  maybe_page_output (output_buf);
+	}
+    }
+
+  DELETE_ARGV;
+
+  return retval;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -22,16 +22,21 @@ Software Foundation, 675 Mass Ave, Cambr
 */
 
 // Use the GNU readline library for command line editing and hisory.
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
+#include <sys/types.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
+#include <time.h>
 #include <stdio.h>
 #include <stdlib.h>
 #include <iostream.h>
 #include <string.h>
 #include <assert.h>
 
 // This must come before anything that includes iostream.h...
 extern "C"
@@ -44,25 +49,25 @@ extern void free_undo_list ();
 extern char *xmalloc ();
 
 /*
  * Yes, this sucks, but it avoids a conflict with another readline
  * function declared in iostream.h.
  */
 #if 0
 #define LINE_SIZE 8192
-static int no_line_editing = 1;
+static int no_line_editing = 0;
 #endif
 
 char *
 gnu_readline (char *s)
 {
 #if 0
   static int state = 0;
-  static char *line_from_stdin = (char *) NULL;
+  static char *line_from_stdin = 0;
   if (no_line_editing)
     {
       if (! state)
 	{
 	  line_from_stdin = (char *) malloc (LINE_SIZE);
 	  state = 1;
 	}
       fputs ("octave> ", stdout);
@@ -70,45 +75,63 @@ gnu_readline (char *s)
       return line_from_stdin;
     }
   else
 #endif
     return readline (s);
 }
 }
 
-#include "variables.h"
+#include "help.h"
 #include "error.h"
 #include "utils.h"
 #include "input.h"
 #include "pager.h"
-#include "help.h"
+#include "parse.h"
+#include "dirfns.h"
+#include "octave.h"
+#include "variables.h"
+#include "tree-const.h"
 #include "octave-hist.h"
 #include "sighandlers.h"
-#include "parse.h"
 #include "user-prefs.h"
-#include "builtins.h"
+#include "oct-obj.h"
+#include "defun.h"
+
+#ifndef MAXPATHLEN
+#define MAXPATHLEN 1024
+#endif
+
+// The size that strings change by.
+#ifndef DEFAULT_ARRAY_SIZE
+#define DEFAULT_ARRAY_SIZE 512
+#endif
+
+// The growth rate for the prompt string.
+#ifndef PROMPT_GROWTH
+#define PROMPT_GROWTH 50
+#endif
 
 // Global pointer for eval().
-const char *current_eval_string = (char *) NULL;
+const char *current_eval_string = 0;
 
 // Nonzero means get input from current_eval_string.
 int get_input_from_eval_string = 0;
 
 // Nonzero means we're parsing a function file.
 int reading_fcn_file = 0;
 
 // Simple name of function file we are reading.
-char *curr_fcn_file_name = (char *) NULL;
+char *curr_fcn_file_name = 0;
 
 // Nonzero means we're parsing a script file.
 int reading_script_file = 0;
 
 // If we are reading from an M-file, this is it.
-FILE *ff_instream = (FILE *) NULL;
+FILE *ff_instream = 0;
 
 // Nonzero means we are using readline.
 int using_readline = 1;
 
 // Nonzero means commands are echoed as they are executed (-x).
 int echo_input = 0;
 
 // Nonzero means this is an interactive shell.
@@ -116,32 +139,303 @@ int interactive = 0;
 
 // Nonzero means the user forced this shell to be interactive (-i).
 int forced_interactive = 0;
 
 // Should we issue a prompt?
 int promptflag = 1;
 
 // The current line of input, from wherever.
-char *current_input_line = (char *) NULL;
+char *current_input_line = 0;
 
 // A line of input from readline.
-static char *octave_gets_line = (char *) NULL;
+static char *octave_gets_line = 0;
+
+extern tree_constant eval_string (const char *string, int print,
+				  int ans_assign, int& parse_status);
+
+/*
+ * Append SOURCE to TARGET at INDEX.  SIZE is the current amount of
+ * space allocated to TARGET.  SOURCE can be NULL, in which case
+ * nothing happens.  Gets rid of SOURCE by free ()ing it.  Returns
+ * TARGET in case the location has changed.
+ */
+static char *
+sub_append_string (char *source, char *target, int *index, int *size)
+{
+  if (source)
+    {
+      while ((int)strlen (source) >= (int)(*size - *index))
+	{
+	  char *tmp = new char [*size += DEFAULT_ARRAY_SIZE];
+	  strcpy (tmp, target);
+	  delete [] target;
+	  target = tmp;
+	}
+
+      strcat (target, source);
+      *index += strlen (source);
+
+      delete [] source;
+    }
+  return target;
+}
+
+/*
+ * Return the octal number parsed from STRING, or -1 to indicate that
+ * the string contained a bad number.
+ */
+int
+read_octal (const char *string)
+{
+  int result = 0;
+  int digits = 0;
+
+  while (*string && *string >= '0' && *string < '8')
+    {
+      digits++;
+      result = (result * 8) + *string++ - '0';
+    }
+
+  if (! digits || result > 0777 || *string)
+    result = -1;
+
+  return result;
+}
+
+/*
+ * Return a string which will be printed as a prompt.  The string may
+ * contain special characters which are decoded as follows: 
+ *   
+ *	\t	the time
+ *	\d	the date
+ *	\n	CRLF
+ *	\s	the name of the shell (program)
+ *	\w	the current working directory
+ *	\W	the last element of PWD
+ *	\u	your username
+ *	\h	the hostname
+ *	\#	the command number of this command
+ *	\!	the history number of this command
+ *	\$	a $ or a # if you are root
+ *	\<octal> character code in octal
+ *	\\	a backslash
+ */
+static char *
+decode_prompt_string (const char *string)
+{
+  int result_size = PROMPT_GROWTH;
+  int result_index = 0;
+  char *result = new char [PROMPT_GROWTH];
+  int c;
+  char *temp = 0;
+
+  result[0] = 0;
+  while (c = *string++)
+    {
+      if (c == '\\')
+	{
+	  c = *string;
+
+	  switch (c)
+	    {
+	    case '0':
+	    case '1':
+	    case '2':
+	    case '3':
+	    case '4':
+	    case '5':
+	    case '6':
+	    case '7':
+	      {
+		char octal_string[4];
+		int n;
+
+		strncpy (octal_string, string, 3);
+		octal_string[3] = '\0';
+
+		n = read_octal (octal_string);
+
+		temp = strsave ("\\");
+		if (n != -1)
+		  {
+		    string += 3;
+		    temp[0] = n;
+		  }
+
+		c = 0;
+		goto add_string;
+	      }
+	  
+	    case 't':
+	    case 'd':
+	      /* Make the current time/date into a string. */
+	      {
+		time_t the_time = time (0);
+		char *ttemp = ctime (&the_time);
+		temp = strsave (ttemp);
+
+		if (c == 't')
+		  {
+		    strcpy (temp, temp + 11);
+		    temp[8] = '\0';
+		  }
+		else
+		  temp[10] = '\0';
+
+		goto add_string;
+	      }
 
+	    case 'n':
+	      if (! no_line_editing)
+		temp = strsave ("\r\n");
+	      else
+		temp = strsave ("\n");
+	      goto add_string;
+
+	    case 's':
+	      {
+		temp = base_pathname (prog_name);
+		temp = strsave (temp);
+		goto add_string;
+	      }
+	
+	    case 'w':
+	    case 'W':
+	      {
+		char t_string[MAXPATHLEN];
+#define EFFICIENT
+#ifdef EFFICIENT
+
+// Use the value of PWD because it is much more effecient.
+
+		temp = user_pref.pwd;
+
+		if (! temp)
+		  getcwd (t_string, MAXPATHLEN);
+		else
+		  strcpy (t_string, temp);
+#else
+		getcwd (t_string, MAXPATHLEN);
+#endif	/* EFFICIENT */
+
+		if (c == 'W')
+		  {
+		    char *dir = strrchr (t_string, '/');
+		    if (dir && dir != t_string)
+		      strcpy (t_string, dir + 1);
+		    temp = strsave (t_string);
+		  }
+		else
+		  temp = strsave (polite_directory_format (t_string));
+		goto add_string;
+	      }
+      
+	    case 'u':
+	      {
+		temp = strsave (user_name);
+
+		goto add_string;
+	      }
+
+	    case 'h':
+	      {
+		char *t_string;
+
+		temp = strsave (host_name);
+		if (t_string = strchr (temp, '.'))
+		  *t_string = '\0';
+		
+		goto add_string;
+	      }
+
+	    case '#':
+	      {
+		char number_buffer[128];
+		sprintf (number_buffer, "%d", current_command_number);
+		temp = strsave (number_buffer);
+		goto add_string;
+	      }
+
+	    case '!':
+	      {
+		char number_buffer[128];
+		int num = current_history_number ();
+		if (num > 0)
+                  sprintf (number_buffer, "%d", num);
+		else
+		  strcpy (number_buffer, "!");
+		temp = strsave (number_buffer);
+		goto add_string;
+	      }
+
+	    case '$':
+	      temp = strsave (geteuid () == 0 ? "#" : "$");
+	      goto add_string;
+
+	    case '\\':
+	      temp = strsave ("\\");
+	      goto add_string;
+
+	    default:
+	      temp = strsave ("\\ ");
+	      temp[1] = c;
+
+	    add_string:
+	      if (c)
+		string++;
+	      result =
+		(char *)sub_append_string (temp, result,
+					   &result_index, &result_size);
+	      temp = 0; /* Free ()'ed in sub_append_string (). */
+	      result[result_index] = '\0';
+	      break;
+	    }
+	}
+      else
+	{
+	  while (3 + result_index > result_size)
+	    {
+	      char *tmp = new char [result_size += PROMPT_GROWTH];
+	      strcpy (tmp, result);
+	      delete [] result;
+	      result = tmp;
+	    }
+	  result[result_index++] = c;
+	  result[result_index] = '\0';
+	}
+    }
+
+#if 0
+  /* I don't really think that this is a good idea.  Do you? */
+  if (! find_variable ("NO_PROMPT_VARS"))
+    {
+      WORD_LIST *expand_string (), *list;
+      char *string_list ();
+
+      list = expand_string (result, 1);
+      free (result);
+      result = string_list (list);
+      dispose_words (list);
+    }
+#endif
+
+  return result;
+}
 /*
  * Use GNU readline to get an input line and store it in the history
  * list.
  */
 static char *
 octave_gets (void)
 {
-  if (octave_gets_line != NULL)
+  if (octave_gets_line)
     {
       free (octave_gets_line);
-      octave_gets_line = (char *) NULL;
+      octave_gets_line = 0;
     }
 
   if (interactive || forced_interactive)
     {
       char *ps = (promptflag > 0) ? user_pref.ps1 : user_pref.ps2;
       char *prompt = decode_prompt_string (ps);
 
       if (interactive)
@@ -176,17 +470,17 @@ octave_gets (void)
 /*
  * Read a line from the input stream.
  */
 int
 octave_read (char *buf, int max_size)
 {
   int status = 0;
 
-  static char *stashed_line = (char *) NULL;
+  static char *stashed_line = 0;
 
   if (get_input_from_eval_string)
     {
       int len = strlen (current_eval_string);
       if (len < max_size - 1)
 	{
 	  strcpy (buf, current_eval_string);
 	  buf[len++] = '\n';
@@ -200,17 +494,17 @@ octave_read (char *buf, int max_size)
 	delete [] stashed_line;
 
       stashed_line = strsave (buf);
       current_input_line = stashed_line;
     }
   else if (using_readline)
     {
       char *cp = octave_gets ();
-      if (cp != (char *) NULL)
+      if (cp)
 	{
 	  int len = strlen (cp);
 	  if (len >= max_size)
 	    status = -1;
 	  else
 	    {
 	      strcpy (buf, cp);
 	      buf[len++] = '\n';
@@ -221,22 +515,22 @@ octave_read (char *buf, int max_size)
       current_input_line = cp;
     }
   else
     {
       FILE *curr_stream = rl_instream;
       if (reading_fcn_file || reading_script_file)
 	curr_stream = ff_instream;
 
-      assert (curr_stream != (FILE *) NULL);
+      assert (curr_stream);
 
 // Why is this required?
       buf[0] = '\0';
 
-      if (fgets (buf, max_size, curr_stream) != (char *) NULL)
+      if (fgets (buf, max_size, curr_stream))
 	{
 	  int len = strlen (buf);
 	  if (len > max_size - 2)
 	    status = -1;
 	  else
 	    {
 	      if (buf[len-1] != '\n')
 		{
@@ -267,24 +561,24 @@ octave_read (char *buf, int max_size)
   return status;
 }
 
 /*
  * Fix things up so that input can come from file `name', printing a
  * warning if the file doesn't exist.
  */
 FILE *
-get_input_from_file (char *name, int warn = 1)
+get_input_from_file (char *name, int warn)
 {
-  FILE *instream = (FILE *) NULL;
+  FILE *instream = 0;
 
   if (name && *name)
     instream = fopen (name, "r");
 
-  if (instream == (FILE *) NULL && warn)
+  if (! instream && warn)
     warning ("%s: no such file or directory", name);
 
   if (reading_fcn_file || reading_script_file)
     ff_instream = instream;
   else
     rl_instream = instream;
 
   return instream;
@@ -303,68 +597,68 @@ get_input_from_stdin (void)
 }
 
 static char *
 command_generator (char *text, int state)
 {
   static int len = 0;
   static int list_index = 0;
 
-  static char **name_list = (char **) NULL;
+  static char **name_list = 0;
 
   if (state == 0)
     {
       list_index = 0;
       len = strlen (text);
 
-      if (name_list != (char **) NULL)
+      if (name_list)
 	{
 	  char **ptr = name_list;
 	  while (ptr && *ptr)
 	    delete [] *ptr++;
 	  delete [] name_list;
 	}
 
       name_list = make_name_list ();
     }
 
   char *name;
-  while ((name = name_list[list_index]) != (char *) NULL)
+  while ((name = name_list[list_index]) != 0)
     {
       list_index++;
       if (strncmp (name, text, len) == 0)
 	{
 	  char *buf = xmalloc (1 + strlen (name));
 	  strcpy (buf, name);
 	  return buf;
 	}
     }
 
-  return (char *) NULL;
+  return 0;
 }
 
 static char **
 command_completer (char *text, int start, int end)
 {
-  char **matches = (char **) NULL;
+  char **matches = 0;
   matches = completion_matches (text, command_generator);
   return matches;
 }
 
 /*
  * The next two functions implement the equivalent of the K*rn shell
  * C-o operate-and-get-next-history-line editing command.  Stolen from
  * the GNU Bourne Again SHell.
  */
 
 // ??
 static int saved_history_line_to_use = 0;
 
 // ??
-static Function *old_rl_startup_hook = (Function *) NULL;
+static Function *old_rl_startup_hook = 0;
 
 static void
 set_saved_history (void)
 {
   HIST_ENTRY *h;
 
   if (saved_history_line_to_use)
     {
@@ -377,17 +671,17 @@ set_saved_history (void)
 
 // Get rid of any undo list created by the previous insert, so the
 // line won't totally be erased when the edits are undone (they will
 // be normally, because this is a history  line -- cf. readline.c:
 // line 380 or so).
 	      if (rl_undo_list)
 		{
 		  free_undo_list ();
-		  rl_undo_list = (UNDO_LIST *) NULL;
+		  rl_undo_list = 0;
 		}
 	    }
 	}
     }
   saved_history_line_to_use = 0;
   rl_startup_hook = old_rl_startup_hook;
 }
 
@@ -421,14 +715,132 @@ initialize_readline (void)
 // Tell the completer that we want to try first.
   rl_attempted_completion_function = (CPPFunction *) command_completer;
 
 // Bind operate-and-get-next.
   rl_add_defun ("operate-and-get-next",
 		(Function *) operate_and_get_next, CTRL ('O'));
 }
 
+static int
+match_sans_spaces (const char *standard, const char *test)
+{
+  const char *tp = test;
+  while (*tp == ' ' || *tp == '\t')
+    tp++;
+
+  const char *ep = test + strlen (test) - 1;
+  while (*ep == ' ' || *ep == '\t')
+    ep--;
+
+  int len = ep - tp + 1;
+
+  return (strncmp (standard, tp, len) == 0);
+}
+
+static Octave_object
+get_user_input (const Octave_object& args, int nargout, int debug = 0)
+{
+  tree_constant retval;
+
+  int nargin = args.length ();
+
+  int read_as_string = 0;
+
+  if (nargin == 3)
+    read_as_string++;
+
+  char *prompt = "debug> ";
+  if (nargin > 1)
+   {
+      if (args(1).is_string_type ())
+	prompt = args(1).string_value ();
+      else
+	{
+	  error ("input: unrecognized argument");
+	  return retval;
+	}
+    }
+
+ again:
+
+  flush_output_to_pager ();
+
+  char *input_buf = gnu_readline (prompt);
+
+  if (input_buf)
+    {
+      maybe_save_history (input_buf);
+
+      int len = strlen (input_buf);
+
+      if (len < 1)
+	{
+	  if (debug)
+	    goto again;
+	  else
+	    return retval;
+	}
+
+      if (match_sans_spaces ("exit", input_buf)
+	  || match_sans_spaces ("quit", input_buf)
+	  || match_sans_spaces ("return", input_buf))
+	return tree_constant ();
+      else if (read_as_string)
+	retval = input_buf;
+      else
+	{
+	  int parse_status = 0;
+	  retval = eval_string (input_buf, 0, 0, parse_status);
+	  if (debug && retval.is_defined ())
+	    retval.eval (1);
+	}
+    }
+  else
+    error ("input: reading user-input failed!");
+
+  if (debug)
+    goto again;
+
+  return retval;
+}
+
+DEFUN ("input", Finput, Sinput, 3, 1,
+  "input (PROMPT [, S])\n\
+\n\
+Prompt user for input.  If the second argument is present, return
+value as a string.")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin == 2 || nargin == 3)
+    retval = get_user_input (args, nargout);
+  else
+    print_usage ("input");
+
+  return retval;
+}
+
+DEFUN ("keyboard", Fkeyboard, Skeyboard, 2, 1,
+  "keyboard (PROMPT)\n\
+\n\
+maybe help in debugging function files")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin == 1 || nargin == 2)
+    retval = get_user_input (args, nargout, 1);
+  else
+    print_usage ("keyboard");
+
+  return retval;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -23,18 +23,21 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #include <float.h>
 #include <Complex.h>
 
+#include "missing-math.h"
+#include "variables.h"
 #include "mappers.h"
 #include "utils.h"
+#include "defun.h"
 
 #if defined (_AIX) && defined (__GNUG__)
 #undef finite
 #define finite(x) ((x) < DBL_MAX && (x) > -DBL_MAX)
 #endif
 
 #ifndef M_LOG10E
 #define M_LOG10E 0.43429448190325182765
@@ -267,14 +270,110 @@ tan (const Complex& x)
 
 Complex
 tanh (const Complex& x)
 {
   Complex retval = sinh (x) / cosh (x);
   return retval;
 }
 
+void
+install_mapper_functions (void)
+{
+  DEFUN_MAPPER ("abs", Sabs, 0, 0.0, 0.0, fabs, abs, 0,
+    "abs (X): compute abs (X) for each element of X");
+
+  DEFUN_MAPPER ("acos", Sacos, 1, -1.0, 1.0, acos, 0, acos,
+    "acos (X): compute acos (X) for each element of X");
+
+  DEFUN_MAPPER ("acosh", Sacosh, 1, 1.0, DBL_MAX, acosh, 0, acosh,
+    "acosh (X): compute acosh (X) for each element of X");
+
+  DEFUN_MAPPER ("angle", Sangle, 0, 0.0, 0.0, arg, arg, 0,
+    "angle (X): compute arg (X) for each element of X");
+
+  DEFUN_MAPPER ("arg", Sarg, 0, 0.0, 0.0, arg, arg, 0,
+    "arg (X): compute arg (X) for each element of X");
+
+  DEFUN_MAPPER ("asin", Sasin, 1, -1.0, 1.0, asin, 0, asin,
+    "asin (X): compute asin (X) for each element of X");
+
+  DEFUN_MAPPER ("asinh", Sasinh, 0, 0.0, 0.0, asinh, 0, asinh,
+    "asinh (X): compute asinh (X) for each element of X");
+
+  DEFUN_MAPPER ("atan", Satan, 0, 0.0, 0.0, atan, 0, atan,
+    "atan (X): compute atan (X) for each element of X");
+
+  DEFUN_MAPPER ("atanh", Satanh, 1, -1.0, 1.0, atanh, 0, atanh,
+    "atanh (X): compute atanh (X) for each element of X");
+
+  DEFUN_MAPPER ("ceil", Sceil, 0, 0.0, 0.0, ceil, 0, ceil,
+    "ceil (X): round elements of X toward +Inf");
+
+  DEFUN_MAPPER ("conj", Sconj, 0, 0.0, 0.0, conj, 0, conj,
+    "conj (X): compute complex conjugate for each element of X");
+
+  DEFUN_MAPPER ("cos", Scos, 0, 0.0, 0.0, cos, 0, cos,
+    "cos (X): compute cos (X) for each element of X");
+
+  DEFUN_MAPPER ("cosh", Scosh, 0, 0.0, 0.0, cosh, 0, cosh,
+    "cosh (X): compute cosh (X) for each element of X");
+
+  DEFUN_MAPPER ("exp", Sexp, 0, 0.0, 0.0, exp, 0, exp,
+    "exp (X): compute exp (X) for each element of X");
+
+  DEFUN_MAPPER ("finite", Sfinite, 0, 0.0, 0.0, xfinite, xfinite, 0,
+    "finite (X): return 1 for finite elements of X");
+
+  DEFUN_MAPPER ("fix", Sfix, 0, 0.0, 0.0, fix, 0, fix,
+    "fix (X): round elements of X toward zero");
+
+  DEFUN_MAPPER ("floor", Sfloor, 0, 0.0, 0.0, floor, 0, floor,
+    "floor (X): round elements of X toward -Inf");
+
+  DEFUN_MAPPER ("isinf", Sisinf, 0, 0.0, 0.0, xisinf, xisinf, 0,
+    "isinf (X): return 1 for elements of X infinite");
+
+  DEFUN_MAPPER ("imag", Simag, 0, 0.0, 0.0, imag, imag, 0,
+    "imag (X): return imaginary part for each elements of X");
+
+#ifdef HAVE_ISNAN
+  DEFUN_MAPPER ("isnan", Sisnan, 0, 0.0, 0.0, xisnan, xisnan, 0,
+    "isnan (X): return 1 where elements of X are NaNs");
+#endif
+
+  DEFUN_MAPPER ("log", Slog, 1, 0.0, DBL_MAX, log, 0, log,
+    "log (X): compute log (X) for each element of X");
+
+  DEFUN_MAPPER ("log10", Slog10, 1, 0.0, DBL_MAX, log10, 0, log10,
+    "log10 (X): compute log10 (X) for each element of X");
+
+  DEFUN_MAPPER ("real", Sreal, 0, 0.0, 0.0, real, real, 0,
+    "real (X): return real part for each element of X");
+
+  DEFUN_MAPPER ("round", Sround, 0, 0.0, 0.0, round, 0, round,
+    "round (X): round elements of X to nearest integer");
+
+  DEFUN_MAPPER ("sign", Ssign, 0, 0.0, 0.0, signum, 0, signum,
+    "sign (X): apply signum function to elements of X");
+
+  DEFUN_MAPPER ("sin", Ssin, 0, 0.0, 0.0, sin, 0, sin,
+    "sin (X): compute sin (X) for each element of X");
+
+  DEFUN_MAPPER ("sinh", Ssinh, 0, 0.0, 0.0, sinh, 0, sinh,
+    "sinh (X): compute sinh (X) for each element of X");
+
+  DEFUN_MAPPER ("sqrt", Ssqrt, 1, 0.0, DBL_MAX, sqrt, 0, sqrt,
+    "sqrt (X): compute sqrt (X) for each element of X");
+
+  DEFUN_MAPPER ("tan", Stan, 0, 0.0, 0.0, tan, 0, tan,
+    "tan (X): compute tan (X) for each element of X");
+
+  DEFUN_MAPPER ("tanh", Stanh, 0, 0.0, 0.0, tanh, 0, tanh,
+    "tanh (X): compute tanh (X) for each element of X");
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/mappers.h b/src/mappers.h
--- a/src/mappers.h
+++ b/src/mappers.h
@@ -21,48 +21,82 @@ Software Foundation, 675 Mass Ave, Cambr
 
 */
 
 #if !defined (octave_mappers_h)
 #define octave_mappers_h 1
 
 class Complex;
 
-#include "missing-math.h"
+typedef double (*d_d_Mapper)(double);
+typedef double (*d_c_Mapper)(const Complex&);
+typedef Complex (*c_c_Mapper)(const Complex&);
+
+// If can_return_complex_for_real_arg is 1, lower_limit and
+// upper_limit specify the range of values for which a real arg
+// returns a real value.  Outside that range, we have to convert args
+// to complex, and call the complex valued function.
+//
+// If can_return_complex_for_real_arg is 0, lower_limit and
+// upper_limit are ignored.
+
+struct Mapper_fcn
+{
+  int can_return_complex_for_real_arg;
+  double lower_limit;
+  double upper_limit;
+  d_d_Mapper d_d_mapper;
+  d_c_Mapper d_c_mapper;
+  c_c_Mapper c_c_mapper;
+};
+
+struct builtin_mapper_function
+{
+  char *name;
+  int can_return_complex_for_real_arg;
+  double lower_limit;
+  double upper_limit;
+  d_d_Mapper d_d_mapper;
+  d_c_Mapper d_c_mapper;
+  c_c_Mapper c_c_mapper;
+  char *help_string;
+};
 
 extern double arg (double x);
 extern double conj (double x);
 extern double fix (double x);
 extern double imag (double x);
 extern double real (double x);
 extern double round (double x);
 extern double signum (double x);
+extern double xisnan (double x);
 extern double xfinite (double x);
 extern double xisinf (double x);
-extern double xisnan (double x);
 
+extern double xisnan (const Complex& x);
 extern double xfinite (const Complex& x);
 extern double xisinf (const Complex& x);
-extern double xisnan (const Complex& x);
 
 extern Complex acos (const Complex& x);
 extern Complex acosh (const Complex& x);
 extern Complex asin (const Complex& x);
 extern Complex asinh (const Complex& x);
 extern Complex atan (const Complex& x);
 extern Complex atanh (const Complex& x);
 extern Complex ceil (const Complex& x);
 extern Complex fix (const Complex& x);
 extern Complex floor (const Complex& x);
 extern Complex log10 (const Complex& x);
 extern Complex round (const Complex& x);
 extern Complex signum (const Complex& x);
 extern Complex tan (const Complex& x);
 extern Complex tanh (const Complex& x);
 
+extern void install_mapper_functions (void);
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -44,20 +44,22 @@ Software Foundation, Inc.
 #include <fstream.h>
 #include <strstream.h>
 
 #include "statdefs.h"
 #include "utils.h"
 #include "error.h"
 #include "input.h"
 #include "octave.h"
+#include "oct-obj.h"
 #include "user-prefs.h"
 #include "unwind-prot.h"
 #include "octave-hist.h"
 #include "sighandlers.h"
+#include "defun.h"
 
 extern "C"
 {
 #include <readline/history.h>
 }
 
 // Nonzero means input is coming from temporary history file.
 int input_from_tmp_history_file = 0;
@@ -81,46 +83,43 @@ static int history_lines_this_session = 
  * Get some default values, possibly reading them from the
  * environment.
  */
 static int
 default_history_size (void)
 {
   int size = 1024;
   char *env_size = getenv ("OCTAVE_HISTSIZE");
-  if (env_size != (char *) NULL)
+  if (env_size)
     {
       int val;
       if (sscanf (env_size, "%d", &val) == 1)
 	size = val > 0 ? val : 0;
     }
   return size;
 }
 
 static char *
 default_history_file (void)
 {
-  char *file = (char *) NULL;;
+  char *file = 0;
 
   char *env_file = getenv ("OCTAVE_HISTFILE");
-  if (env_file != (char *) NULL)
+  if (env_file)
     {
       fstream f (env_file, (ios::in | ios::out));
-      if (f != 0)
+      if (f)
 	{
 	  file = strsave (env_file);
 	  f.close ();
 	}
     }
 
-  if (file == (char *) NULL)
-    {
-      if (home_directory != NULL)
-	file = strconcat (home_directory, "/.octave_hist");
-    }
+  if (! file && home_directory)
+    file = strconcat (home_directory, "/.octave_hist");
 
   return file;
 }
 
 /*
  * Prime the history list.
  */
 void
@@ -255,17 +254,17 @@ do_history (int argc, char **argv)
 	  return;
         }
     }
 
   hlist = history_list ();
 
   if (hlist)
     {
-      for (int i = 0; hlist[i] != (HIST_ENTRY *) NULL; i++)
+      for (int i = 0; hlist[i]; i++)
 	; // Do nothing.
 
       if (limit < 0)
 	limit = -limit;
 
       if (!limited)
 	i = 0;
       else
@@ -316,17 +315,17 @@ edit_history_readline (fstream& stream)
 	}
       else
 	line[lindex++] = c;
     }
 
   if (! lindex)
     {
       delete [] line;
-      return (char *) NULL;
+      return 0;
     }
 
   if (lindex + 2 >= line_len)
     {
       char *tmp_line = new char [lindex+3];
       strcpy (tmp_line, line);
       delete [] line;
       line = tmp_line;
@@ -349,66 +348,66 @@ extern "C"
  * by this time, is `run_history blah...'.  The intent is that the
  * new command become the history entry, and that `fc' should never
  * appear in the history list.  This way you can do `run_history' to
  * your heart's content.
  */ 
 static void
 edit_history_repl_hist (char *command)
 {
-  if (command == (char *) NULL || *command == '\0')
+  if (! command || ! *command)
     return;
 
   HIST_ENTRY **hlist = history_list ();
 
-  if (hlist == (HIST_ENTRY **) NULL)
+  if (! hlist)
     return;
 
   for (int i = 0; hlist[i]; i++)
     ; // Count 'em.
   i--;
 
   /* History_get () takes a parameter that should be
      offset by history_base. */
 
 // Don't free this.
   HIST_ENTRY *histent = history_get (history_base + i);
-  if (histent == (HIST_ENTRY *) NULL)
+  if (! histent)
     return;
 
-  char *data = (char *) NULL;
-  if (histent->data != (char *) NULL)
+  char *data = 0;
+  if (histent->data)
     {
       int len = strlen (histent->data);
       data = (char *) malloc (len);
       strcpy (data, histent->data);
     }
 
   int n = strlen (command);
 
   if (command[n - 1] == '\n')
     command[n - 1] = '\0';
 
-  if (command != (char *) NULL && *command != '\0')
+  if (command && *command)
     {
       HIST_ENTRY *discard = replace_history_entry (i, command, data);
-      if (discard != (HIST_ENTRY *) NULL)
+      if (discard)
 	{
-	  if (discard->line != (char *) NULL)
+	  if (discard->line)
 	    free (discard->line);
 
 	  free ((char *) discard);
 	}
     }
 }
 
 static void
 edit_history_add_hist (char *line)
 {
-  if (line != (char *) NULL)
+  if (line)
     {
       int len = strlen (line);
       if (len > 0 && line[len-1] == '\n')
 	line[len-1] = '\0';
 
       if (line[0] != '\0')
 	add_history (line);
     }
@@ -420,17 +419,17 @@ static char *
 mk_tmp_hist_file (int argc, char **argv, int insert_curr, char *warn_for)
 {
   HIST_ENTRY **hlist;
 
   hlist = history_list ();
 
   int hist_count = 0;
 
-  while (hlist[hist_count++] != (HIST_ENTRY *) NULL)
+  while (hlist[hist_count++])
     ; // Find the number of items in the history list.
 
 // The current command line is already part of the history list by the
 // time we get to this point.  Delete it from the list.
 
   hist_count -= 2;
   if (! insert_curr)
     remove_history (hist_count);
@@ -469,41 +468,41 @@ mk_tmp_hist_file (int argc, char **argv,
 	  hist_end = hist_beg;
 	}
     }
 
   if (hist_beg < 0 || hist_end < 0 || hist_beg > hist_count
       || hist_end > hist_count)
     {
       error ("%s: history specification out of range", warn_for);
-      return (char *) NULL;
+      return 0;
     }
 
   if (usage_error)
     {
       usage ("%s [first] [last]", warn_for);
-      return (char *) NULL;
+      return 0;
     }
 
   if (hist_end < hist_beg)
     {
       int t = hist_end;
       hist_end = hist_beg;
       hist_beg = t;
       reverse = 1;
     }
 
-  char *name = tmpnam ((char *) NULL);
+  char *name = tmpnam (0);
 
   fstream file (name, ios::out);
 
   if (! file)
     {
       error ("%s: couldn't open temporary file `%s'", warn_for, name);
-      return (char *) NULL;
+      return 0;
     }
 
   if (reverse)
     {
       for (int i = hist_end; i >= hist_beg; i--)
 	file << histline (i) << "\n";
     }
   else
@@ -517,17 +516,17 @@ mk_tmp_hist_file (int argc, char **argv,
   return strsave (name);
 }
 
 void
 do_edit_history (int argc, char **argv)
 {
   char *name = mk_tmp_hist_file (argc, argv, 0, "edit_history");
 
-  if (name == (char *) NULL)
+  if (! name)
     return;
 
 // Call up our favorite editor on the file of commands.
 
   ostrstream buf;
   buf << user_pref.editor << " " << name << ends;
   char *cmd = buf.str ();
 
@@ -540,17 +539,17 @@ do_edit_history (int argc, char **argv)
 
 // Write the commands to the history file since parse_and_execute
 // disables command line history while it executes.
 
   fstream file (name, ios::in);
 
   char *line;
   int first = 1;
-  while ((line = edit_history_readline (file)) != NULL)
+  while ((line = edit_history_readline (file)) != 0)
     {
 
 // Skip blank lines
 
       if (line[0] == '\n')
 	{
 	  delete [] line;
 	  continue;
@@ -587,17 +586,17 @@ do_edit_history (int argc, char **argv)
   delete [] name;
 }
 
 void
 do_run_history (int argc, char **argv)
 {
   char *name = mk_tmp_hist_file (argc, argv, 1, "run_history");
 
-  if (name == (char *) NULL)
+  if (! name)
     return;
 
 // Turn on command echo, so the output from this will make better sense.
 
   begin_unwind_frame ("do_run_history");
   unwind_protect_int (echo_input);
   unwind_protect_int (input_from_tmp_history_file);
   echo_input = 1;
@@ -622,14 +621,62 @@ current_history_number (void)
 
   if (octave_hist_size > 0)
     return history_base + where_history ();
   else
     return -1;
 
 }
 
+DEFUN_TEXT ("edit_history", Fedit_history, Sedit_history, -1, 1,
+  "edit_history [first] [last]\n\
+\n\
+edit commands from the history list")
+{
+  Octave_object retval;
+
+  DEFINE_ARGV("edit_history");
+
+  do_edit_history (argc, argv);
+
+  DELETE_ARGV;
+
+  return retval;
+}
+
+DEFUN_TEXT ("history", Fhistory, Shistory, -1, 1,
+  "history [N] [-w file] [-r file] [-q]\n\
+\n\
+display, save, or load command history")
+{
+  Octave_object retval;
+
+  DEFINE_ARGV("history");
+
+  do_history (argc, argv);
+
+  DELETE_ARGV;
+
+  return retval;
+}
+
+DEFUN_TEXT ("run_history", Frun_history, Srun_history, -1, 1,
+  "run_history [first] [last]\n\
+\n\
+run commands from the history list")
+{
+  Octave_object retval;
+
+  DEFINE_ARGV("run_history");
+
+  do_run_history (argc, argv);
+
+  DELETE_ARGV;
+
+  return retval;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -35,85 +35,88 @@ Software Foundation, 675 Mass Ave, Cambr
 #include <time.h>
 #include <pwd.h>
 #include <setjmp.h>
 #include <stdlib.h>
 #include <string.h>
 #include <signal.h>
 #include <assert.h>
 #include <iostream.h>
+#include <strstream.h>
 #include <fstream.h>
 
 #include "getopt.h"
 
 #include "lo-error.h"
 
 #include "sighandlers.h"
 #include "variables.h"
 #include "error.h"
 #include "tree-const.h"
+#include "tree-plot.h"
 #include "utils.h"
-#include "builtins.h"
 #include "input.h"
 #include "pager.h"
 #include "lex.h"
 #include "octave.h"
 #include "parse.h"
 #include "unwind-prot.h"
 #include "octave-hist.h"
+#include "builtins.h"
 #include "version.h"
 #include "file-io.h"
 #include "sysdep.h"
+#include "defun.h"
 
 #if !defined (HAVE_ATEXIT) && defined (HAVE_ON_EXIT)
 extern "C" { int on_exit (); }
 #define atexit on_exit
 #endif
 
 // argv[0] for this program.
-char *raw_prog_name = (char *) NULL;
+char *raw_prog_name = 0;
 
 // Cleaned-up name of this program, not including path information.
-char *prog_name = (char *) NULL;
+char *prog_name = 0;
 
 // Login name for user running this program.
-char *user_name = (char *) NULL;
+char *user_name = 0;
 
 // Name of the host we are running on.
-char *host_name = (char *) NULL;
+char *host_name = 0;
 
 // User's home directory.
-char *home_directory = (char *) NULL;
+char *home_directory = 0;
 
 // Guess what?
-char *the_current_working_directory = (char *) NULL;
+char *the_current_working_directory = 0;
 
 // Load path specified on command line.
-char *load_path = (char *) NULL;
+char *load_path = 0;
 
 // Name of the info file specified on command line.
-char *info_file = (char *) NULL;
+char *info_file = 0;
 
 // Name of the editor to be invoked by the edit_history command.
-char *editor = (char *) NULL;
+char *editor = 0;
 
 // If nonzero, don't do fancy line editing.
 int no_line_editing = 0;
 
 // Command number, counting from the beginning of this session.
 int current_command_number = 1;
 
 // Nonzero means we are exiting via the builtin exit or quit functions.
 int quitting_gracefully = 0;
 
 // Current command to execute.
-tree *global_command = (tree *) NULL;
+tree *global_command = 0;
 
 // Pointer to function that is currently being evaluated.
-tree_function *curr_function = (tree_function *) NULL;
+tree_function *curr_function = 0;
 
 // Nonzero means input is coming from startup file.
 int input_from_startup_file = 0;
 
 // Top level context (?)
 jmp_buf toplevel;
 
 // This is not really the right place to do this...
@@ -177,20 +180,20 @@ initialize_globals (char *name)
 
   char hostname[256];
   if (gethostname (hostname, 255) < 0)
     host_name = strsave ("I have no host!");
   else
     host_name = strsave (hostname);
 
   char *hd = getenv ("HOME");
-  if (hd == (char *) NULL)
-    home_directory = strsave ("I have no home~!");
+  if (hd)
+    home_directory = strsave (hd);
   else
-    home_directory = strsave (hd);
+    home_directory = strsave ("I have no home!");
 
   raw_prog_name = strsave (name);
   prog_name = strsave ("octave");
 
   load_path = default_path ();
 
   info_file = default_info_file ();
 
@@ -220,17 +223,17 @@ parse_and_execute (FILE *f, int print)
 
   unwind_protect_ptr (curr_sym_tab);
 
   int retval;
   do
     {
       reset_parser ();
       retval = yyparse ();
-      if (retval == 0 && global_command != NULL_TREE)
+      if (retval == 0 && global_command)
 	{
 	  global_command->eval (print);
 	  delete global_command;
 	}
     }
   while (retval == 0);
 
   run_unwind_frame ("parse_and_execute");
@@ -241,17 +244,17 @@ parse_and_execute (char *s, int print)
 {
   begin_unwind_frame ("parse_and_execute_2");
 
   unwind_protect_int (reading_script_file);
 
   reading_script_file = 1;
 
   FILE *f = get_input_from_file (s, 0);
-  if (f != (FILE *) NULL)
+  if (f)
     {
       unwind_protect_int (input_line_number);
       unwind_protect_int (current_input_column);
       unwind_protect_int (echo_input);
 
       input_line_number = 0;
       current_input_column = 1;
       echo_input = 0;
@@ -276,18 +279,18 @@ execute_startup_files (void)
 // Execute commands from the site-wide configuration file.
 
   char *sd = get_site_defaults ();
 
   parse_and_execute (sd, 0);
 
 // Try to execute commands from $HOME/.octaverc and ./.octaverc.
 
-  char *home_rc = (char *) NULL;
-  if (home_directory != NULL)
+  char *home_rc = 0;
+  if (home_directory)
     {
       home_rc = strconcat (home_directory, "/.octaverc");
       parse_and_execute (home_rc, 0);
     }
 
 // Names alone are not enough.
 
   struct stat home_rc_statbuf;
@@ -411,30 +414,30 @@ main (int argc, char **argv)
 	case 'h':
 	case '?':
 	  verbose_usage ();
 	  break;
 	case 'i':
 	  forced_interactive = 1;
 	  break;
 	case 'p':
-	  if (optarg != (char *) NULL)
+	  if (optarg)
 	    load_path = strsave (optarg);
 	  break;
 	case 'q':
 	  inhibit_startup_message = 1;
 	  break;
 	case 'x':
 	  echo_input = 1;
 	  break;
 	case 'v':
 	  print_version_and_exit ();
 	  break;
 	case INFO_FILE_OPTION:
-	  if (optarg != (char *) NULL)
+	  if (optarg)
 	    info_file = strsave (optarg);
 	  break;
 	default:
 	  usage ();
 	  break;
 	}
     }
 
@@ -474,23 +477,23 @@ main (int argc, char **argv)
   int remaining_args = argc - optind;
   if (remaining_args > 1)
     {
       usage ();
     }
   else if (remaining_args == 1)
     {
       FILE *infile = get_input_from_file (argv[optind]);
-      if (infile == (FILE *) NULL)
-	clean_up_and_exit (1);
-      else
+      if (infile)
 	{
 	  rl_blink_matching_paren = 0;
 	  switch_to_buffer (create_buffer (infile));
 	}
+      else
+	clean_up_and_exit (1);
     }
   else
     {
       switch_to_buffer (create_buffer (get_input_from_stdin ()));
 
 // Is input coming from a terminal?  If so, we are probably
 // interactive.
 
@@ -539,26 +542,216 @@ main (int argc, char **argv)
   do
     {
       curr_sym_tab = top_level_sym_tab;
 
       reset_parser ();
 
       retval = yyparse ();
 
-      if (retval == 0 && global_command != NULL_TREE)
+      if (retval == 0 && global_command)
 	{
 	  global_command->eval (1);
 	  delete global_command;
 	  current_command_number++;
 	}
     }
   while (retval == 0);
 
   clean_up_and_exit (retval);
 }
 
+DEFUN_TEXT ("casesen", Fcasesen, Scasesen, 2, 1,
+  "casesen [on|off]")
+{
+  Octave_object retval;
+
+  DEFINE_ARGV("casesen");
+
+  if (argc == 1 || (argc > 1 && strcmp (argv[1], "off") == 0))
+    warning ("casesen: sorry, Octave is always case sensitive");
+  else if (argc > 1 && strcmp (argv[1], "on") == 0)
+    ; // ok.
+  else
+    print_usage ("casesen");
+
+  DELETE_ARGV;
+
+  return retval;
+}
+
+DEFALIAS (exit, quit)
+
+DEFUN ("flops", Fflops, Sflops, 2, 1,
+  "flops (): count floating point operations")
+{
+  int nargin = args.length ();
+
+  if (nargin > 2)
+    print_usage ("flops");
+
+  warning ("flops is a flop, always returning zero");
+
+  return 0.0;
+}
+
+DEFUN ("quit", Fquit, Squit, 1, 0,
+  "quit (): exit Octave gracefully")
+{
+  Octave_object retval;
+  quitting_gracefully = 1;
+  clean_up_and_exit (0);
+  return retval;
+}
+
+DEFUN ("warranty", Fwarranty, Swarranty, 1, 0,
+  "warranty (): describe copying conditions")
+{
+  Octave_object retval;
+
+  ostrstream output_buf;
+  output_buf << "\n    Octave, version " << version_string
+	     << ".  Copyright (C) 1992, 1993, 1994 John W. Eaton\n"
+	     << "\n\
+    This program is free software; you can redistribute it and/or modify\n\
+    it under the terms of the GNU General Public License as published by\n\
+    the Free Software Foundation; either version 2 of the License, or\n\
+    (at your option) any later version.\n\
+\n\
+    This program is distributed in the hope that it will be useful,\n\
+    but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
+    GNU General Public License for more details.\n\
+\n\
+    You should have received a copy of the GNU General Public License\n\
+    along with this program. If not, write to the Free Software\n\
+    Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.\n\
+\n";
+
+  output_buf << ends;
+  maybe_page_output (output_buf);
+
+  return retval;
+}
+
+// XXX FIXME XXX -- this may not be the best place for these...
+
+Octave_object
+feval (const Octave_object& args, int nargout)
+{
+  Octave_object retval;
+
+  tree_fvc *fcn = is_valid_function (args(1), "feval", 1);
+  if (fcn)
+    {
+      int nargin = args.length () - 1;
+      Octave_object tmp_args (nargin);
+      for (int i = 0; i < nargin; i++)
+	tmp_args(i) = args(i+1);
+      retval = fcn->eval (0, nargout, tmp_args);
+    }
+
+  return retval;
+}
+
+DEFUN ("feval", Ffeval, Sfeval, -1, 1,
+  "feval (NAME, ARGS, ...)\n\
+\n\
+evaluate NAME as a function, passing ARGS as its arguments")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin > 1)
+    retval = feval (args, nargout);
+  else
+    print_usage ("feval");
+
+  return retval;
+}
+
+tree_constant
+eval_string (const char *string, int print, int ans_assign,
+	     int& parse_status)
+{
+  begin_unwind_frame ("eval_string");
+
+  unwind_protect_int (get_input_from_eval_string);
+  unwind_protect_ptr (global_command);
+  unwind_protect_ptr (current_eval_string);
+
+  get_input_from_eval_string = 1;
+  current_eval_string = string;
+
+  YY_BUFFER_STATE old_buf = current_buffer ();
+  YY_BUFFER_STATE new_buf = create_buffer (0);
+
+  add_unwind_protect (restore_input_buffer, (void *) old_buf);
+  add_unwind_protect (delete_input_buffer, (void *) new_buf);
+
+  switch_to_buffer (new_buf);
+
+  unwind_protect_ptr (curr_sym_tab);
+
+  reset_parser ();
+
+  parse_status = yyparse ();
+
+// Important to reset the idea of where input is coming from before
+// trying to eval the command we just parsed -- it might contain the
+// name of an function file that still needs to be parsed!
+
+  tree *command = global_command;
+
+  run_unwind_frame ("eval_string");
+
+  tree_constant retval;
+
+  if (parse_status == 0 && command)
+    {
+      retval = command->eval (print);
+      delete command;
+    }
+
+  return retval;
+}
+
+tree_constant
+eval_string (const tree_constant& arg, int& parse_status)
+{
+  if (! arg.is_string_type ())
+    {
+      error ("eval: expecting string argument");
+      return -1;
+    }
+
+  char *string = arg.string_value ();
+
+// Yes Virginia, we always print here...
+
+  return eval_string (string, 1, 1, parse_status);
+}
+
+DEFUN ("eval", Feval, Seval, 2, 1,
+  "eval (STRING): evaluate STRING as octave code")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin == 2)
+    {
+      int parse_status = 0;
+      retval = eval_string (args(1), parse_status);
+    }
+  else
+    print_usage ("eval");
+
+  return retval;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -1,12 +1,12 @@
 // pager.cc                                               -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993 John W. Eaton
+Copyright (C) 1992, 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -31,23 +31,23 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "procstream.h"
 
 #include "user-prefs.h"
 #include "input.h"
 #include "pager.h"
 
 // Where we stash output headed for the screen.
-static ostrstream *pager_buf = (ostrstream *) NULL;
+static ostrstream *pager_buf = 0;
 
 static int
 line_count (char *s)
 {
   int count = 0;
-  if (s != (char *) NULL)
+  if (s)
     {
       char c;
       while ((c = *s++) != '\0')
 	if (c == '\n')
 	  count++;
     }
   return count;
 }
@@ -84,17 +84,17 @@ void
 maybe_page_output (ostrstream& msg_buf)
 {
   msg_buf << ends;
 
   char *message = msg_buf.str ();
 
   if (interactive
       && user_pref.page_screen_output
-      && user_pref.pager_binary != (char *) NULL)
+      && user_pref.pager_binary)
     {
       *pager_buf << message;
       delete [] message;
     }
   else
     {
       cout << message;
       cout.flush ();
@@ -104,29 +104,29 @@ maybe_page_output (ostrstream& msg_buf)
 
 void
 flush_output_to_pager (void)
 {
   *pager_buf << ends;
 
   char *message = pager_buf->str ();
 
-  if (message == (char *) NULL || *message == '\0')
+  if (! message || ! *message)
     {
       delete [] message;
       initialize_pager ();
       return;
     }
 
   int nlines = line_count (message);
 
   if (nlines > terminal_rows () - 2)
     {
       char *pgr = user_pref.pager_binary;
-      if (pgr != (char *) NULL)
+      if (pgr)
 	{
 	  oprocstream pager_stream (pgr);
 	  if (pager_stream)
 	    {
 	      pager_stream << message;
 	      pager_stream.flush ();
 
 	      delete [] message;
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -22,17 +22,16 @@ Software Foundation, 675 Mass Ave, Cambr
 */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #include <iostream.h>
 #include <strstream.h>
-#include <stdio.h>
 #include <string.h>
 #include <math.h>
 #include <float.h>
 #include <Complex.h>
 
 #include "dMatrix.h"
 #include "CMatrix.h"
 #include "Range.h"
@@ -40,23 +39,24 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "tree-const.h"
 #include "variables.h"
 #include "user-prefs.h"
 #include "pr-output.h"
 #include "mappers.h"
 #include "pager.h"
 #include "error.h"
 #include "utils.h"
+#include "defun.h"
 
 // Current format string for real numbers and the real part of complex
 // numbers.
-static char *curr_real_fmt = (char *) NULL;
+static char *curr_real_fmt = 0;
 
 // Current format string for the imaginary part of complex numbers.
-static char *curr_imag_fmt = (char *) NULL;
+static char *curr_imag_fmt = 0;
 
 // Nonzero means don\'t do any fancy formatting.
 static int free_format = 0;
 
 // Nonzero means print plus sign for nonzero, blank for zero.
 static int plus_format = 0;
 
 // Nonzero means always print like dollars and cents.
@@ -179,18 +179,18 @@ pr_min_internal (const Matrix& m)
 	  result = val;
       }
   return result;
 }
 
 static void
 set_format (double d, int& fw)
 {
-  curr_real_fmt = (char *) NULL;
-  curr_imag_fmt = (char *) NULL;
+  curr_real_fmt = 0;
+  curr_imag_fmt = 0;
 
   if (free_format)
     return;
 
   static char fmt_buf[128];
 
   int sign = (d < 0.0);
 
@@ -270,18 +270,18 @@ set_format (double d)
 {
   int fw;
   set_format (d, fw);
 }
 
 static void
 set_format (const Matrix& m, int& fw)
 {
-  curr_real_fmt = (char *) NULL;
-  curr_imag_fmt = (char *) NULL;
+  curr_real_fmt = 0;
+  curr_imag_fmt = 0;
 
   if (free_format)
     return;
 
   static char fmt_buf[128];
 
   int sign = any_element_is_negative (m);
 
@@ -384,18 +384,18 @@ set_format (const Matrix& m)
 {
   int fw;
   set_format (m, fw);
 }
 
 static void
 set_format (const Complex& c, int& r_fw, int& i_fw)
 {
-  curr_real_fmt = (char *) NULL;
-  curr_imag_fmt = (char *) NULL;
+  curr_real_fmt = 0;
+  curr_imag_fmt = 0;
 
   if (free_format)
     return;
 
   static char r_fmt_buf[128];
   static char i_fmt_buf[128];
 
   double rp = c.real ();
@@ -523,18 +523,18 @@ set_format (const Complex& c)
 {
   int r_fw, i_fw;
   set_format (c, r_fw, i_fw);
 }
 
 static void
 set_format (const ComplexMatrix& cm, int& r_fw, int& i_fw)
 {
-  curr_real_fmt = (char *) NULL;
-  curr_imag_fmt = (char *) NULL;
+  curr_real_fmt = 0;
+  curr_imag_fmt = 0;
 
   if (free_format)
     return;
 
   static char r_fmt_buf[128];
   static char i_fmt_buf[128];
 
   Matrix rp = real (cm);
@@ -673,18 +673,18 @@ set_format (const ComplexMatrix& cm)
 {
   int r_fw, i_fw;
   set_format (cm, r_fw, i_fw);
 }
 
 static void
 set_format (const Range& r, int& fw)
 {
-  curr_real_fmt = (char *) NULL;
-  curr_imag_fmt = (char *) NULL;
+  curr_real_fmt = 0;
+  curr_imag_fmt = 0;
 
   if (free_format)
     return;
 
   static char fmt_buf[128];
 
   double r_min = r.base ();
   double r_max = r.limit ();
@@ -785,19 +785,17 @@ set_format (const Range& r)
 }
 
 static inline void
 pr_any_float (const char *fmt, ostrstream& os, double d, int fw = 0)
 {
   if (d == -0.0)
     d = 0.0;
 
-  if (fmt == (char *) NULL)
-    os << d;
-  else
+  if (fmt)
     {
       if (xisinf (d))
 	{
 	  char *s;
 	  if (d < 0.0)
 	    s = "-Inf";
 	  else
 	    s = "Inf";
@@ -812,16 +810,18 @@ pr_any_float (const char *fmt, ostrstrea
 	  if (fw > 0)
 	    os.form ("%*s", fw, "NaN");
 	  else
 	    os << "NaN";
 	}
       else
 	os.form (fmt, d);
     }
+  else
+    os << d;
 }
 
 static inline void
 pr_float (ostrstream& os, double d, int fw = 0)
 {
   pr_any_float (curr_real_fmt, os, d, fw);
 }
 
@@ -1125,30 +1125,45 @@ octave_print_internal (ostrstream& os, c
 
 	  os << "\n";
 
 	  col += inc;
 	}
     }
 }
 
+DEFUN ("disp", Fdisp, Sdisp, 3, 1,
+  "disp (X): display value without name tag")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin == 2)
+    args(1).eval (1);
+  else
+    print_usage ("disp");
+
+  return retval;
+}
+
 static void
 init_format_state (void)
 {
   free_format = 0;
   plus_format = 0;
   bank_format = 0;
   print_e = 0;
   print_big_e = 0;
 }
 
 static void
 set_output_prec_and_fw (int prec, int fw)
 {
-  tree_constant *tmp = NULL_TREE_CONST;
+  tree_constant *tmp = 0;
 
   tmp = new tree_constant ((double) prec);
   bind_builtin_variable ("output_precision", tmp);
 
   tmp = new tree_constant ((double) fw);
   bind_builtin_variable ("output_max_field_width", tmp);
 }
 
@@ -1248,14 +1263,30 @@ set_format_style (int argc, char **argv)
     }
   else
     {
       init_format_state ();
       set_output_prec_and_fw (5, 10);
     }
 }
 
+DEFUN_TEXT ("format", Fformat, Sformat, -1, 1,
+  "format [style]\n\
+\n\
+set output formatting style")
+{
+  Octave_object retval;
+
+  DEFINE_ARGV("format");
+
+  set_format_style (argc, argv);
+
+  DELETE_ARGV;
+
+  return retval;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/pt-base.h b/src/pt-base.h
--- a/src/pt-base.h
+++ b/src/pt-base.h
@@ -1,9 +1,9 @@
-// tree.h                                                -*- C++ -*-
+// tree-base.h                                           -*- C++ -*-
 /*
 
 Copyright (C) 1992, 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -19,34 +19,17 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (octave_tree_base_h)
 #define octave_tree_base_h 1
 
-#include <stdio.h>
-#include <time.h>
-#include <assert.h>
-
-#ifndef NULL_TREE
-#define NULL_TREE (tree *)NULL
-#endif
-
-#ifndef NULL_TREE_CONST
-#define NULL_TREE_CONST (tree_constant *)NULL
-#endif
-
-class tree;
-class tree_fvc;
-class ostream;
 class tree_constant;
-class tree_identifier;
-class tree_argument_list;
 
 /*
  * Base class for the parse tree.
  */
 class
 tree
 {
 public:
diff --git a/src/pt-cmd.cc b/src/pt-cmd.cc
--- a/src/pt-cmd.cc
+++ b/src/pt-cmd.cc
@@ -1,9 +1,9 @@
-// Tree class.                                          -*- C++ -*-
+// tree-cmd.cc                                           -*- C++ -*-
 /*
 
 Copyright (C) 1992, 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -26,19 +26,16 @@ Software Foundation, 675 Mass Ave, Cambr
 #endif
 
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
 #include <iostream.h>
 
-// For NULL.
-#include <stdio.h>
-
 #include "user-prefs.h"
 #include "variables.h"
 #include "symtab.h"
 #include "error.h"
 #include "gripes.h"
 #include "tree.h"
 #include "tree-cmd.h"
 #include "tree-const.h"
@@ -97,26 +94,26 @@ list_to_vector (tree *list, int& len)
 }
 #endif
 
 /*
  * A command or two to be executed.
  */
 tree_command_list::tree_command_list (void)
 {
-  command = NULL_TREE;
+  command = 0;
   print_flag = 1;
-  next = (tree_command_list *) NULL;
+  next = 0;
 }
 
 tree_command_list::tree_command_list (tree *t)
 {
   command = t;
   print_flag = 1;
-  next = (tree_command_list *) NULL;
+  next = 0;
 }
 
 tree_command_list::~tree_command_list (void)
 {
   delete command;
   delete next;
 }
 
@@ -134,19 +131,19 @@ tree_command_list::chain (tree *t)
   return tmp;
 }
 
 tree_command_list *
 tree_command_list::reverse (void)
 {
   tree_command_list *list = this;
   tree_command_list *next;
-  tree_command_list *prev = (tree_command_list *) NULL;
+  tree_command_list *prev = 0;
 
-  while (list != (tree_command_list *) NULL)
+  while (list)
     {
       next = list->next;
       list->next = prev;
       prev = list;
       list = next;
     }
   return prev;
 }
@@ -155,26 +152,25 @@ tree_constant
 tree_command_list::eval (int print)
 {
   int pf;
   tree_constant retval;
 
   if (error_state)
     return retval;
 
-  tree_command_list *list;
-  for (list = this; list != (tree_command_list *) NULL; list = list->next)
+  for (tree_command_list *list = this; list; list = list->next)
     {
       if (print == 0)
 	pf = 0;
       else
 	pf = list->print_flag;
 
       tree *cmd = list->command;
-      if (cmd == NULL_TREE)
+      if (! cmd)
 	retval = tree_constant ();
       else
 	{
 	  retval = cmd->eval (pf);
 
 	  if (error_state)
 	    return tree_constant ();
 
@@ -186,93 +182,92 @@ tree_command_list::eval (int print)
 	}
     }
   return retval;
 }
 
 /*
  * Global.
  */
-tree_global_command::tree_global_command (int l = -1, int c = -1)
+tree_global_command::tree_global_command (int l, int c)
 {
   line_num = l;
   column_num = c;
-  sr = (symbol_record *) NULL;
-  rhs = (tree_expression *) NULL;
-  next = (tree_global_command *) NULL;
+  sr = 0;
+  rhs = 0;
+  next = 0;
 }
 
-tree_global_command::tree_global_command (symbol_record *s,
-					  int l = -1, int c = -1)
+tree_global_command::tree_global_command (symbol_record *s, int l, int c)
 {
   line_num = l;
   column_num = c;
   sr = s;
-  rhs = (tree_expression *) NULL;
-  next = (tree_global_command *) NULL;
+  rhs = 0;
+  next = 0;
 }
 
 tree_global_command::tree_global_command (symbol_record *s,
 					  tree_expression *e,
-					  int l = -1, int c = -1) 
+					  int l, int c) 
 {
   line_num = l;
   column_num = c;
   sr = s;
   rhs = e;
-  next = (tree_global_command *) NULL;
+  next = 0;
 }
 
 tree_global_command::~tree_global_command (void)
 {
   delete next;
 }
 
 tree_global_command *
-tree_global_command::chain (symbol_record *s, int l = -1, int c = -1)
+tree_global_command::chain (symbol_record *s, int l, int c)
 {
   tree_global_command *tmp = new tree_global_command (s, l, c);
   tmp->next = this;
   return tmp;
 }
 
 tree_global_command *
 tree_global_command::chain (symbol_record *s, tree_expression *e,
-			    int l = -1, int c = -1)
+			    int l, int c)
 {
   tree_global_command *tmp = new tree_global_command (s, e, l, c);
   tmp->next = this;
   return tmp;
 }
 
 tree_global_command *
 tree_global_command::reverse (void)
 {
   tree_global_command *list = this;
   tree_global_command *next;
-  tree_global_command *prev = (tree_global_command *) NULL;
+  tree_global_command *prev = 0;
 
-  while (list != (tree_global_command *) NULL)
+  while (list)
     {
       next = list->next;
       list->next = prev;
       prev = list;
       list = next;
     }
   return prev;
 }
 
 tree_constant
 tree_global_command::eval (int print)
 {
   tree_constant retval;
 
   link_to_global_variable (sr);
 
-  if (rhs != NULL_TREE)
+  if (rhs)
     {
       tree_identifier *id = new tree_identifier (sr);
       tree_constant tmp_rhs = rhs->eval (0);
       if (error_state)
 	{
 	  delete id;
 	  eval_error ();
 	  return retval;
@@ -290,52 +285,51 @@ tree_global_command::eval (int print)
 	  if (error_state)
 	    {
 	      eval_error ();
 	      return retval;
 	    }
 	}
     }
 
-  if (next != (tree_global_command *) NULL)
+  if (next)
     next->eval (print);
 
   return retval;
 }
 
 void
 tree_global_command::eval_error (void)
 {
   if (error_state > 0)
     ::error ("evaluating global command near line %d, column %d",
 	     line (), column ());
 }
 
 /*
  * While.
  */
-tree_while_command::tree_while_command (int l = -1, int c = -1)
+tree_while_command::tree_while_command (int l, int c)
 {
   line_num = l;
   column_num = c;
-  expr = (tree_expression *) NULL;
-  list = NULL_TREE;
+  expr = 0;
+  list = 0;
 }
 
-tree_while_command::tree_while_command (tree_expression *e,
-					int l = -1, int c = -1) 
+tree_while_command::tree_while_command (tree_expression *e, int l, int c) 
 {
   line_num = l;
   column_num = c;
   expr = e;
-  list = NULL_TREE;
+  list = 0;
 }
 
 tree_while_command::tree_while_command (tree_expression *e, tree *lst,
-					int l = -1, int c = -1)
+					int l, int c)
 {
   line_num = l;
   column_num = c;
   expr = e;
   list = lst;
 }
 
 tree_while_command::~tree_while_command (void)
@@ -350,17 +344,17 @@ tree_while_command::eval (int print)
   tree_constant retval;
 
   if (error_state)
     return retval;
 
   for (;;)
     {
       int expr_value = 0;
-      if (expr == (tree_expression *) NULL)
+      if (! expr)
 	return tree_constant ();
       tree_constant t1 = expr->eval (0);
 
       if (error_state)
 	{
 	  eval_error ();
 	  return tree_constant ();
 	}
@@ -388,17 +382,17 @@ tree_while_command::eval (int print)
 	expr_value = (int) t1.double_value ();
       else if (t == tree_constant_rep::complex_scalar_constant)
 	expr_value = t1.complex_value () != 0.0;
       else
 	panic_impossible ();
 
       if (expr_value)
 	{
-	  if (list != NULL_TREE)
+	  if (list)
 	    {
 	      retval = list->eval (1);
 	      if (error_state)
 		{
 		  eval_error ();
 		  return tree_constant ();
 		}
 	    }
@@ -418,28 +412,28 @@ tree_while_command::eval_error (void)
   if (error_state > 0)
     ::error ("evaluating while command near line %d, column %d",
 	     line (), column ());
 }
 
 /*
  * For.
  */
-tree_for_command::tree_for_command (int l = -1, int c = -1)
+tree_for_command::tree_for_command (int l, int c)
 {
   line_num = l;
   column_num = c;
-  id = (tree_index_expression *) NULL;
-  expr = (tree_expression *) NULL;
-  list = NULL_TREE;
+  id = 0;
+  expr = 0;
+  list = 0;
 }
 
 tree_for_command::tree_for_command (tree_index_expression *ident,
 				    tree_expression *e, tree *lst,
-				    int l = -1, int c = -1)
+				    int l, int c)
 {
   line_num = l;
   column_num = c;
   id = ident;
   expr = e;
   list = lst;
 }
 
@@ -450,17 +444,17 @@ tree_for_command::~tree_for_command (voi
   delete list;
 }
 
 tree_constant
 tree_for_command::eval (int print)
 {
   tree_constant retval;
 
-  if (error_state || expr == (tree_expression *) NULL)
+  if (error_state || ! expr)
     return retval;
 
   tree_constant tmp_expr = expr->eval (0);
 
   if (error_state || tmp_expr.is_undefined ())
     {
       eval_error ();
       return retval;
@@ -575,17 +569,17 @@ tree_for_command::do_for_loop_once (tree
   tmp_ass.eval (0);
 
   if (error_state)
     {
       eval_error ();
       return tree_constant ();
     }
 
-  if (list != NULL_TREE)
+  if (list)
     {
       retval = list->eval (1);
       if (error_state)
 	{
 	  eval_error ();
 	  quit = 1;
 	  return tree_constant ();
 	}
@@ -594,75 +588,75 @@ tree_for_command::do_for_loop_once (tree
   quit = quit_loop_now ();
 
   return retval;
 }
 
 /*
  * If.
  */
-tree_if_command::tree_if_command (int l = -1, int c = -1)
+tree_if_command::tree_if_command (int l, int c)
 {
   line_num = l;
   column_num = c;
-  expr = (tree_expression *) NULL;
-  list = NULL_TREE;
-  next = (tree_if_command *) NULL;
+  expr = 0;
+  list = 0;
+  next = 0;
 }
 
-tree_if_command::tree_if_command (tree *lst, int l = -1, int c = -1)
+tree_if_command::tree_if_command (tree *lst, int l, int c)
 {
   line_num = l;
   column_num = c;
-  expr = (tree_expression *) NULL;
+  expr = 0;
   list = lst;
-  next = (tree_if_command *) NULL;
+  next = 0;
 }
 
 tree_if_command::tree_if_command (tree_expression *e, tree *lst,
-				  int l = -1, int c = -1)
+				  int l, int c)
 {
   line_num = l;
   column_num = c;
   expr = e;
   list = lst;
-  next = (tree_if_command *) NULL;
+  next = 0;
 }
 
 tree_if_command::~tree_if_command (void)
 {
   delete expr;
   delete list;
   delete next;
 }
 
 tree_if_command *
-tree_if_command::chain (tree *lst, int l = -1, int c = -1)
+tree_if_command::chain (tree *lst, int l, int c)
 {
   tree_if_command *tmp = new tree_if_command (lst, l, c);
   tmp->next = this;
   return tmp;
 }
 
 tree_if_command *
-tree_if_command::chain (tree_expression *e, tree *lst, int l = -1, int c = -1)
+tree_if_command::chain (tree_expression *e, tree *lst, int l, int c)
 {
   tree_if_command *tmp = new tree_if_command (e, lst, l, c);
   tmp->next = this;
   return tmp;
 }
 
 tree_if_command *
 tree_if_command::reverse (void)
 {
   tree_if_command *list = this;
   tree_if_command *next;
-  tree_if_command *prev = (tree_if_command *) NULL;
+  tree_if_command *prev = 0;
 
-  while (list != (tree_if_command *) NULL)
+  while (list)
     {
       next = list->next;
       list->next = prev;
       prev = list;
       list = next;
     }
   return prev;
 }
@@ -671,23 +665,23 @@ tree_constant
 tree_if_command::eval (int print)
 {
   int expr_value = 0;
   tree_constant retval;
 
   if (error_state)
     return retval;
 
-  tree_if_command *lst;
-  for (lst = this; lst != (tree_if_command *) NULL; lst = lst->next)
+  
+  for (tree_if_command *lst = this; lst; lst = lst->next)
     {
-      if (lst->expr != (tree_expression *) NULL)
+      if (lst->expr)
 	{
 	  tree_expression *tmp = lst->expr;
-	  if (tmp == (tree_expression *) NULL)
+	  if (! tmp)
 	    return tree_constant ();
 	  tree_constant t1 = tmp->eval (0);
 	  if (error_state || t1.is_undefined ())
 	    {
 	      lst->eval_error ();
 	      break;
 	    }
 
@@ -715,30 +709,30 @@ tree_if_command::eval (int print)
 	    expr_value = (int) t1.double_value ();
 	  else if (t == tree_constant_rep::complex_scalar_constant)
 	    expr_value = t1.complex_value () != 0.0;
 	  else
 	    panic_impossible ();
 
 	  if (expr_value)
 	    {
-	      if (lst->list != NULL_TREE)
+	      if (lst->list)
 		retval = lst->list->eval (1);
 	      else
 		::error ("if: empty command list");
 
 	      if (error_state)
 		lst->eval_error ();
 
 	      break;
 	    }
 	}
       else
 	{
-	  if (lst->list != NULL_TREE)
+	  if (lst->list)
 	    retval = lst->list->eval (1);
 	  else
 	    ::error ("if: empty command list");
 
 	  if (error_state)
 	    lst->eval_error ();
 
 	  break;
@@ -754,17 +748,17 @@ tree_if_command::eval_error (void)
   if (error_state > 0)
     ::error ("evaluating if command near line %d, column %d",
 	     line (), column ());
 }
 
 /*
  * Break.  Is this overkill, or what?
  */
-tree_break_command::tree_break_command (int l = -1, int c = -1)
+tree_break_command::tree_break_command (int l, int c)
 {
   line_num = l;
   column_num = c;
 }
 
 tree_break_command::~tree_break_command (void)
 {
 }
@@ -775,17 +769,17 @@ tree_break_command::eval (int print)
   if (! error_state)
     breaking = 1;
   return tree_constant ();
 }
 
 /*
  * Continue.
  */
-tree_continue_command::tree_continue_command (int l = -1, int c = -1)
+tree_continue_command::tree_continue_command (int l, int c)
 {
   line_num = l;
   column_num = c;
 }
 
 tree_continue_command::~tree_continue_command (void)
 {
 }
@@ -796,17 +790,17 @@ tree_continue_command::eval (int print)
   if (! error_state)
     continuing = 1;
   return tree_constant ();
 }
 
 /*
  * Return.
  */
-tree_return_command::tree_return_command (int l = -1, int c = -1)
+tree_return_command::tree_return_command (int l, int c)
 {
   line_num = l;
   column_num = c;
 }
 
 tree_return_command::~tree_return_command (void)
 {
 }
diff --git a/src/pt-cmd.h b/src/pt-cmd.h
--- a/src/pt-cmd.h
+++ b/src/pt-cmd.h
@@ -1,9 +1,9 @@
-// Tree classes.                                      -*- C++ -*-
+// tree-cmd.h                                          -*- C++ -*-
 /*
 
 Copyright (C) 1992, 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -1,9 +1,9 @@
-// The constants for the tree class.                      -*- C++ -*-
+// tree-const.cc                                         -*- C++ -*-
 /*
 
 Copyright (C) 1992, 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -24,45 +24,20 @@ Software Foundation, 675 Mass Ave, Cambr
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
 #if defined (__GNUG__)
 #pragma implementation
 #endif
 
-#include <strstream.h>
-#include <iostream.h>
-#include <fstream.h>
-#include <string.h>
-#include <ctype.h>
-
-#include "EIG.h"
-
-#include "unwind-prot.h"
 #include "tree-const.h"
-#include "user-prefs.h"
-#include "variables.h"
-#include "octave.h"
 #include "error.h"
 #include "gripes.h"
-#include "input.h"
-#include "octave-hist.h"
-#include "pager.h"
-#include "utils.h"
-#include "parse.h"
-#include "lex.h"
-
-#ifndef MAX
-#define MAX(a,b) ((a) > (b) ? (a) : (b))
-#endif
-
-#ifndef MIN
-#define MIN(a,b) ((a) < (b) ? (a) : (b))
-#endif
+#include "user-prefs.h"
 
 tree_constant::~tree_constant (void)
 {
 #if defined (MDEBUG)
   cerr << "~tree_constant: rep: " << rep
        << " rep->count: " << rep->count << "\n";
 #endif
 
@@ -105,1391 +80,22 @@ vector_of_empties (int nargout, const ch
   if (flag != 0)
     {
       if (flag < 0)
 	gripe_empty_arg (fcn_name, 0);
 
       Matrix m;
       retval.resize (nargout ? nargout : 1);
       for (int i = 0; i < nargout; i++)
-	retval(i) = tree_constant (m);
+	retval(i) = m;
     }
   else
     gripe_empty_arg (fcn_name, 1);
 
   return retval;
 }
 
-Matrix
-max (const Matrix& a, const Matrix& b)
-{
-  int nr = a.rows ();
-  int nc = a.columns ();
-  if (nr != b.rows () || nc != b.columns ())
-    {
-      error ("two-arg max expecting args of same size");
-      return Matrix ();
-    }
-
-  Matrix result (nr, nc);
-
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
-      {
-	double a_elem = a.elem (i, j);
-	double b_elem = b.elem (i, j);
-	result.elem (i, j) = MAX (a_elem, b_elem);
-      }
-
-  return result;
-}
-
-ComplexMatrix
-max (const ComplexMatrix& a, const ComplexMatrix& b)
-{
-  int nr = a.rows ();
-  int nc = a.columns ();
-  if (nr != b.rows () || nc != b.columns ())
-    {
-      error ("two-arg max expecting args of same size");
-      return ComplexMatrix ();
-    }
-
-  ComplexMatrix result (nr, nc);
-
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
-      {
-        double abs_a_elem = abs (a.elem (i, j));
-        double abs_b_elem = abs (b.elem (i, j));
-        if (abs_a_elem > abs_b_elem)
-          result.elem (i, j) = a.elem (i, j);
-        else
-          result.elem (i, j) = b.elem (i, j);
-      }
-
-  return result;
-}
-
-Matrix
-min (const Matrix& a, const Matrix& b)
-{
-  int nr = a.rows ();
-  int nc = a.columns ();
-  if (nr != b.rows () || nc != b.columns ())
-    {
-      error ("two-arg min expecting args of same size");
-      return Matrix ();
-    }
-
-  Matrix result (nr, nc);
-
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
-      {
-	double a_elem = a.elem (i, j);
-	double b_elem = b.elem (i, j);
-	result.elem (i, j) = MIN (a_elem, b_elem);
-      }
-
-  return result;
-}
-
-ComplexMatrix
-min (const ComplexMatrix& a, const ComplexMatrix& b)
-{
-  int nr = a.rows ();
-  int nc = a.columns ();
-  if (nr != b.rows () || nc != b.columns ())
-    {
-      error ("two-arg min expecting args of same size");
-      return ComplexMatrix ();
-    }
-
-  ComplexMatrix result (nr, nc);
-
-  for (int j = 0; j < nc; j++)
-    for (int i = 0; i < nr; i++)
-      {
-        double abs_a_elem = abs (a.elem (i, j));
-        double abs_b_elem = abs (b.elem (i, j));
-        if (abs_a_elem < abs_b_elem)
-          result.elem (i, j) = a.elem (i, j);
-        else
-          result.elem (i, j) = b.elem (i, j);
-      }
-
-  return result;
-}
-
-static void
-get_dimensions (const tree_constant& a, const char *warn_for,
-		int& nr, int& nc)
-{
-  tree_constant tmpa = a.make_numeric ();
-
-  if (tmpa.is_scalar_type ())
-    {
-      double tmp = tmpa.double_value ();
-      nr = nc = NINT (tmp);
-    }
-  else
-    {
-      nr = tmpa.rows ();
-      nc = tmpa.columns ();
-
-      if ((nr == 1 && nc == 2) || (nr == 2 && nc == 1))
-	{
-	  ColumnVector v = tmpa.to_vector ();
-
-	  nr = NINT (v.elem (0));
-	  nc = NINT (v.elem (1));
-	}
-      else
-	warning ("%s (A): use %s (size (A)) instead", warn_for, warn_for);
-    }
-
-  check_dimensions (nr, nc, warn_for); // May set error_state.
-}
-
-static void
-get_dimensions (const tree_constant& a, const tree_constant& b,
-		const char *warn_for, int& nr, int& nc)
-{
-  tree_constant tmpa = a.make_numeric ();
-  tree_constant tmpb = b.make_numeric ();
-
-  if (tmpa.is_scalar_type () && tmpb.is_scalar_type ())
-    {
-      nr = NINT (tmpa.double_value ());
-      nc = NINT (tmpb.double_value ());
-
-      check_dimensions (nr, nc, warn_for); // May set error_state.
-    }
-  else
-    error ("%s: expecting two scalar arguments", warn_for);
-}
-
-tree_constant
-fill_matrix (const tree_constant& a, double val, const char *warn_for)
-{
-  int nr, nc;
-  get_dimensions (a, warn_for, nr, nc);
-
-  if (error_state)
-    return  tree_constant ();
-
-  Matrix m (nr, nc, val);
-
-  return tree_constant (m);
-}
-
-tree_constant
-fill_matrix (const tree_constant& a, const tree_constant& b,
-	     double val, const char *warn_for)
-{
-  int nr, nc;
-  get_dimensions (a, b, warn_for, nr, nc); // May set error_state.
-
-  if (error_state)
-    return tree_constant ();
-
-  Matrix m (nr, nc, val);
-
-  return tree_constant (m);
-}
-
-tree_constant
-identity_matrix (const tree_constant& a)
-{
-  int nr, nc;
-  get_dimensions (a, "eye", nr, nc); // May set error_state.
-
-  if (error_state)
-    return tree_constant ();
-
-  Matrix m (nr, nc, 0.0);
-
-  if (nr > 0 && nc > 0)
-    {
-      int n = MIN (nr, nc);
-      for (int i = 0; i < n; i++)
-	m.elem (i, i) = 1.0;
-    }
-
-  return tree_constant (m);
-}
-
-tree_constant
-identity_matrix (const tree_constant& a, const tree_constant& b)
-{
-  int nr, nc;
-  get_dimensions (a, b, "eye", nr, nc);  // May set error_state.
-
-  if (error_state)
-    return tree_constant ();
-
-  Matrix m (nr, nc, 0.0);
-
-  if (nr > 0 && nc > 0)
-    {
-      int n = MIN (nr, nc);
-      for (int i = 0; i < n; i++)
-	m.elem (i, i) = 1.0;
-    }
-
-  return tree_constant (m);
-}
-
-static Octave_object
-find_to_fortran_idx (const ColumnVector i_idx, const ColumnVector j_idx,
-		     const tree_constant& val, int nr, int nc, int nargout)
-{
-  Octave_object retval (nargout);
-
-  switch (nargout)
-    {
-    case 1:
-      {
-	int count = i_idx.length ();
-	ColumnVector tmp (count);
-	for (int i = 0; i < count; i++)
-	  tmp (i) = nr * (j_idx (i) - 1.0) + i_idx (i);
-	retval(0) = tree_constant (tmp, 1);
-// If you want this to work more like Matlab, use the following line
-// instead of the previous one.
-//	retval(0) = tree_constant (tmp, (nr != 1));
-      }
-      break;
-    case 3:
-      retval(2) = val;
-    case 2:
-      retval(0) = tree_constant (i_idx, 1);
-// If you want this to work more like Matlab, use the following line
-// instead of the previous one.
-//    retval(0) = tree_constant (i_idx, (nr != 1));
-      retval(1) = tree_constant (j_idx, 1);
-      break;
-    default:
-      panic_impossible ();
-      break;
-    }
-
-  return retval;
-}
-
-static Octave_object
-find_nonzero_elem_idx (const Matrix& m, int nargout)
-{
-  int count = 0;
-  int m_nr = m.rows ();
-  int m_nc = m.columns ();
-
-  int i, j;
-  for (j = 0; j < m_nc; j++)
-    for (i = 0; i < m_nr; i++)
-      if (m.elem (i, j) != 0.0)
-	count++;
-
-  Matrix result;
-  Octave_object retval (nargout, result);
-
-  if (count == 0)
-    return retval;
-
-  ColumnVector i_idx (count);
-  ColumnVector j_idx (count);
-  ColumnVector v (count);
-
-  count = 0;
-  for (j = 0; j < m_nc; j++)
-    for (i = 0; i < m_nr; i++)
-      {
-	double d = m.elem (i, j);
-	if (d != 0.0)
-	  {
-	    i_idx (count) = i + 1;
-	    j_idx (count) = j + 1;
-	    v (count) = d;
-	    count++;
-	  }
-      }
-
-  tree_constant tmp (v, 1);
-  return find_to_fortran_idx (i_idx, j_idx, tmp, m_nr, m_nc, nargout);
-}
-
-static Octave_object
-find_nonzero_elem_idx (const ComplexMatrix& m, int nargout)
-{
-  int count = 0;
-  int m_nr = m.rows ();
-  int m_nc = m.columns ();
-
-  int i, j;
-  for (j = 0; j < m_nc; j++)
-    for (i = 0; i < m_nr; i++)
-      if (m.elem (i, j) != 0.0)
-	count++;
-
-  Matrix result;
-  Octave_object retval (nargout, result);
-
-  if (count == 0)
-    return retval;
-
-  ColumnVector i_idx (count);
-  ColumnVector j_idx (count);
-  ComplexColumnVector v (count);
-
-  count = 0;
-  for (j = 0; j < m_nc; j++)
-    for (i = 0; i < m_nr; i++)
-      {
-	Complex c = m.elem (i, j);
-	if (c != 0.0)
-	  {
-	    i_idx (count) = i;
-	    j_idx (count) = j;
-	    v (count) = c;
-	    count++;
-	  }
-      }
-
-  tree_constant tmp (v, 1);
-  return find_to_fortran_idx (i_idx, j_idx, tmp, m_nr, m_nc, nargout);
-}
-
-Octave_object
-find_nonzero_elem_idx (const tree_constant& a, int nargout)
-{
-  Matrix result;
-
-  nargout = (nargout == 0) ? 1 : nargout;
-  Octave_object retval (nargout, result);
-
-  tree_constant tmp = a.make_numeric ();
-
-  switch (tmp.const_type ())
-    {
-    case tree_constant_rep::matrix_constant:
-      {
-	Matrix m = tmp.matrix_value ();
-	return find_nonzero_elem_idx (m, nargout);
-      }
-      break;
-    case tree_constant_rep::scalar_constant:
-      {
-	double d = tmp.double_value ();
-	if (d != 0.0)
-	  {
-	    retval(0) = 1.0;
-	    if (nargout > 1)
-	      retval(1) = 1.0;
-	    if (nargout > 2)
-	      retval(2) = d;
-	  }
-      }
-      break;
-    case tree_constant_rep::complex_matrix_constant:
-      {
-	ComplexMatrix m = tmp.complex_matrix_value ();
-	return find_nonzero_elem_idx (m, nargout);
-      }
-      break;
-    case tree_constant_rep::complex_scalar_constant:
-      {
-	Complex c = tmp.complex_value ();
-	if (c != 0.0)
-	  {
-	    retval(0) = 1.0;
-	    if (nargout > 1)
-	      retval(1) = 1.0;
-	    if (nargout > 2)
-	      retval(2) = c;
-	  }
-      }
-      break;
-    default:
-      break;
-    }
-  return retval;
-}
-
-// XXX FIXME XXX -- the next two functions (and expm) should really be just
-// one...
-
-Octave_object
-matrix_log (const tree_constant& a)
-{
-  Octave_object retval (1);
-
-  tree_constant tmp = a.make_numeric ();;
-    
-  if (tmp.rows () == 0 || tmp.columns () == 0)
-    {
-      int flag = user_pref.propagate_empty_matrices;
-      if (flag != 0)
-	{
-	  if (flag < 0)
-	    gripe_empty_arg ("logm", 0);
-	  Matrix m;
-	  retval(0) = tree_constant (m);
-	  return retval;
-	}
-      else
-	gripe_empty_arg ("logm", 1);
-    }
-
-  switch (tmp.const_type ())
-    {
-    case tree_constant_rep::matrix_constant:
-      {
-	Matrix m = tmp.matrix_value ();
-
-	int nr = m.rows ();
-	int nc = m.columns ();
-
-	if (nr == 0 || nc == 0 || nr != nc)
-	  gripe_square_matrix_required ("logm");
-	else
-	  {
-	    EIG m_eig (m);
-	    ComplexColumnVector lambda (m_eig.eigenvalues ());
-	    ComplexMatrix Q (m_eig.eigenvectors ());
-
-	    for (int i = 0; i < nr; i++)
-	      {
-		Complex elt = lambda.elem (i);
-		if (imag (elt) == 0.0 && real (elt) > 0.0)
-		  lambda.elem (i) = log (real (elt));
-		else
-		  lambda.elem (i) = log (elt);
-	      }
-
-	    ComplexDiagMatrix D (lambda);
-	    ComplexMatrix result = Q * D * Q.inverse ();
-
-	    retval(0) = tree_constant (result);
-	  }
-      }
-      break;
-    case tree_constant_rep::complex_matrix_constant:
-      {
-	ComplexMatrix m = tmp.complex_matrix_value ();
-
-	int nr = m.rows ();
-	int nc = m.columns ();
-
-	if (nr == 0 || nc == 0 || nr != nc)
-	  gripe_square_matrix_required ("logm");
-	else
-	  {
-	    EIG m_eig (m);
-	    ComplexColumnVector lambda (m_eig.eigenvalues ());
-	    ComplexMatrix Q (m_eig.eigenvectors ());
-
-	    for (int i = 0; i < nr; i++)
-	      {
-		Complex elt = lambda.elem (i);
-		if (imag (elt) == 0.0 && real (elt) > 0.0)
-		  lambda.elem (i) = log (real (elt));
-		else
-		  lambda.elem (i) = log (elt);
-	      }
-
-	    ComplexDiagMatrix D (lambda);
-	    ComplexMatrix result = Q * D * Q.inverse ();
-
-	    retval(0) = tree_constant (result);
-	  }
-      }
-      break;
-    case tree_constant_rep::scalar_constant:
-      {
-	double d = tmp.double_value ();
-	if (d > 0.0)
-	  retval(0) = tree_constant (log (d));
-	else
-	  {
-	    Complex dtmp (d);
-	    retval(0) = tree_constant (log (dtmp));
-	  }
-      }
-      break;
-    case tree_constant_rep::complex_scalar_constant:
-      {
-	Complex c = tmp.complex_value ();
-	retval(0) = tree_constant (log (c));
-      }
-      break;
-    default:
-      break;
-    }
-  return retval;
-}
-
-Octave_object
-matrix_sqrt (const tree_constant& a)
-{
-  Octave_object retval (1);
-
-  tree_constant tmp = a.make_numeric ();;
-    
-  if (tmp.rows () == 0 || tmp.columns () == 0)
-    {
-      int flag = user_pref.propagate_empty_matrices;
-      if (flag != 0)
-	{
-	  if (flag < 0)
-	    gripe_empty_arg ("sqrtm", 0);
-	  Matrix m;
-	  retval(0) = tree_constant (m);
-	  return retval;
-	}
-      else
-	gripe_empty_arg ("sqrtm", 1);
-    }
-
-  switch (tmp.const_type ())
-    {
-    case tree_constant_rep::matrix_constant:
-      {
-	Matrix m = tmp.matrix_value ();
-
-	int nr = m.rows ();
-	int nc = m.columns ();
-
-	if (nr == 0 || nc == 0 || nr != nc)
-	  gripe_square_matrix_required ("sqrtm");
-	else
-	  {
-	    EIG m_eig (m);
-	    ComplexColumnVector lambda (m_eig.eigenvalues ());
-	    ComplexMatrix Q (m_eig.eigenvectors ());
-
-	    for (int i = 0; i < nr; i++)
-	      {
-		Complex elt = lambda.elem (i);
-		if (imag (elt) == 0.0 && real (elt) > 0.0)
-		  lambda.elem (i) = sqrt (real (elt));
-		else
-		  lambda.elem (i) = sqrt (elt);
-	      }
-
-	    ComplexDiagMatrix D (lambda);
-	    ComplexMatrix result = Q * D * Q.inverse ();
-
-	    retval(0) = tree_constant (result);
-	  }
-      }
-      break;
-    case tree_constant_rep::complex_matrix_constant:
-      {
-	ComplexMatrix m = tmp.complex_matrix_value ();
-
-	int nr = m.rows ();
-	int nc = m.columns ();
-
-	if (nr == 0 || nc == 0 || nr != nc)
-	  gripe_square_matrix_required ("sqrtm");
-	else
-	  {
-	    EIG m_eig (m);
-	    ComplexColumnVector lambda (m_eig.eigenvalues ());
-	    ComplexMatrix Q (m_eig.eigenvectors ());
-
-	    for (int i = 0; i < nr; i++)
-	      {
-		Complex elt = lambda.elem (i);
-		if (imag (elt) == 0.0 && real (elt) > 0.0)
-		  lambda.elem (i) = sqrt (real (elt));
-		else
-		  lambda.elem (i) = sqrt (elt);
-	      }
-
-	    ComplexDiagMatrix D (lambda);
-	    ComplexMatrix result = Q * D * Q.inverse ();
-
-	    retval(0) = tree_constant (result);
-	  }
-      }
-      break;
-    case tree_constant_rep::scalar_constant:
-      {
-	double d = tmp.double_value ();
-	if (d > 0.0)
-	  retval(0) = tree_constant (sqrt (d));
-	else
-	  {
-	    Complex dtmp (d);
-	    retval(0) = tree_constant (sqrt (dtmp));
-	  }
-      }
-      break;
-    case tree_constant_rep::complex_scalar_constant:
-      {
-	Complex c = tmp.complex_value ();
-	retval(0) = tree_constant (log (c));
-      }
-      break;
-    default:
-      break;
-    }
-  return retval;
-}
-
-Octave_object
-column_max (const Octave_object& args, int nargout)
-{
-  Octave_object retval;
-
-  tree_constant arg1;
-  tree_constant arg2;
-  tree_constant_rep::constant_type arg1_type =
-    tree_constant_rep::unknown_constant;
-  tree_constant_rep::constant_type arg2_type =
-    tree_constant_rep::unknown_constant;
-
-  int nargin = args.length ();
-
-  switch (nargin)
-    {
-    case 3:
-      arg2 = args(2).make_numeric ();
-      arg2_type = arg2.const_type ();
-// Fall through...
-    case 2:
-      arg1 = args(1).make_numeric ();
-      arg1_type = arg1.const_type ();
-      break;
-    default:
-      panic_impossible ();
-      break;
-    }
-
-  if (nargin == 2 && (nargout == 1 || nargout == 0))
-    {
-      retval.resize (1);
-      switch (arg1_type)
-	{
-        case tree_constant_rep::scalar_constant:
-	  retval(0) = tree_constant (arg1.double_value ());
-          break;
-        case tree_constant_rep::complex_scalar_constant:
-          retval(0) = tree_constant (arg1.complex_value ());
-          break;
-        case tree_constant_rep::matrix_constant:
-          {
-  	    Matrix m = arg1.matrix_value ();
-	    if (m.rows () == 1)
-	      retval(0) = tree_constant (m.row_max ());
-	    else
-	      retval(0) = tree_constant (m.column_max (), 0);
- 	  }
-          break;
-        case tree_constant_rep::complex_matrix_constant:
-          {
-            ComplexMatrix m = arg1.complex_matrix_value ();
-            if (m.rows () == 1)
-              retval(0) = tree_constant (m.row_max ());
-            else
-              retval(0) = tree_constant (m.column_max (), 0);
-          }
-	  break;
-	default:
-	  panic_impossible ();
-	  break;
-	}
-    }
-  else if (nargin == 2 && nargout == 2)
-    {
-      retval.resize (2);
-      switch (arg1_type)
-        {
-	case tree_constant_rep::scalar_constant:
-	  {
-	    retval(0) = tree_constant (arg1.double_value ());
-	    retval(1) = tree_constant (1);
-	  }
-          break;
-	case tree_constant_rep::complex_scalar_constant:
-	  {
-	    retval(0) = tree_constant (arg1.complex_value ());
-	    retval(1) = tree_constant (1);
-	  }
-          break;
-	case tree_constant_rep::matrix_constant:
-	  {
-	    Matrix m = arg1.matrix_value ();
-	    if (m.rows () == 1)
-	      {
-		retval(0) = tree_constant (m.row_max ());
-		retval(1) = tree_constant (m.row_max_loc ());
-	      }
-	    else
-	      {
-		retval(0) = tree_constant (m.column_max (), 0);
-		retval(1) = tree_constant (m.column_max_loc (), 0);
-	      }
-	  }
-          break;
-	case tree_constant_rep::complex_matrix_constant:
-	  {
-	    ComplexMatrix m = arg1.complex_matrix_value ();
-	    if (m.rows () == 1)
-	      {
-		retval(0) = tree_constant (m.row_max ());
-		retval(1) = tree_constant (m.row_max_loc ());
-	      }
-	    else
-	      {
-		retval(0) = tree_constant (m.column_max (), 0);
-		retval(1) = tree_constant (m.column_max_loc (), 0);
-	      }
-	  }
-          break;
-	default:
-	  panic_impossible ();
-	  break;
-        }
-    }
-  else if (nargin == 3)
-    {
-      if (arg1.rows () == arg2.rows ()
-	  && arg1.columns () == arg2.columns ())
-	{
-	  retval.resize (1);
-          switch (arg1_type)
-            {
-	    case tree_constant_rep::scalar_constant:
-	      {
-		double result;
-		double a_elem = arg1.double_value ();
-		double b_elem = arg2.double_value ();
-		result = MAX (a_elem, b_elem);
-		retval(0) = tree_constant (result);
-	      }
-              break;
-	    case tree_constant_rep::complex_scalar_constant:
-	      {
-		Complex result;
-		Complex a_elem = arg1.complex_value ();
-		Complex b_elem = arg2.complex_value ();
-		if (abs (a_elem) > abs (b_elem))
-		  result = a_elem;
-		else
-		  result = b_elem;
-		retval(0) = tree_constant (result);
-	      }
-              break;
-	    case tree_constant_rep::matrix_constant:
-	      {
-		Matrix result;
-		result = max (arg1.matrix_value (), arg2.matrix_value ());
-		retval(0) = tree_constant (result);
-	      }
-              break;
-	    case tree_constant_rep::complex_matrix_constant:
-	      {
-		ComplexMatrix result;
-		result = max (arg1.complex_matrix_value (),
-			      arg2.complex_matrix_value ());
-		retval(0) = tree_constant (result);
-	      }
-	      break;
-	    default:
-	      panic_impossible ();
-	      break;
-	    }
-	}
-      else
-	error ("max: nonconformant matrices");
-    }
-  else
-    panic_impossible ();
-
-  return retval;
-}
-
-Octave_object
-column_min (const Octave_object& args, int nargout)
-{
-  Octave_object retval;
-
-  tree_constant arg1;
-  tree_constant arg2;
-  tree_constant_rep::constant_type arg1_type =
-    tree_constant_rep::unknown_constant;
-  tree_constant_rep::constant_type arg2_type =
-    tree_constant_rep::unknown_constant;
-
-  int nargin = args.length ();
-
-  switch (nargin)
-    {
-    case 3:
-      arg2 = args(2).make_numeric ();
-      arg2_type = arg2.const_type ();
-// Fall through...
-    case 2:
-      arg1 = args(1).make_numeric ();
-      arg1_type = arg1.const_type ();
-      break;
-    default:
-      panic_impossible ();
-      break;
-    }
-
-  if (nargin == 2 && (nargout == 1 || nargout == 0))
-    {
-      retval.resize (1);
-      switch (arg1_type)
-	{
-        case tree_constant_rep::scalar_constant:
-	  retval(0) = tree_constant (arg1.double_value ());
-          break;
-        case tree_constant_rep::complex_scalar_constant:
-          retval(0) = tree_constant (arg1.complex_value ());
-          break;
-        case tree_constant_rep::matrix_constant:
-          {
-  	    Matrix m = arg1.matrix_value ();
-	    if (m.rows () == 1)
-	      retval(0) = tree_constant (m.row_min ());
-	    else
-	      retval(0) = tree_constant (m.column_min (), 0);
- 	  }
-          break;
-        case tree_constant_rep::complex_matrix_constant:
-          {
-            ComplexMatrix m = arg1.complex_matrix_value ();
-            if (m.rows () == 1)
-              retval(0) = tree_constant (m.row_min ());
-            else
-              retval(0) = tree_constant (m.column_min (), 0);
-          }
-	  break;
-	default:
-	  panic_impossible ();
-	  break;
-	}
-    }
-  else if (nargin == 2 && nargout == 2)
-    {
-      retval.resize (2);
-      switch (arg1_type)
-        {
-	case tree_constant_rep::scalar_constant:
-	  {
-	    retval(0) = tree_constant (arg1.double_value ());
-	    retval(1) = tree_constant (1);
-	  }
-          break;
-	case tree_constant_rep::complex_scalar_constant:
-	  {
-	    retval(0) = tree_constant (arg1.complex_value ());
-	    retval(1) = tree_constant (1);
-	  }
-          break;
-	case tree_constant_rep::matrix_constant:
-	  {
-	    Matrix m = arg1.matrix_value ();
-	    if (m.rows () == 1)
-	      {
-		retval(0) = tree_constant (m.row_min ());
-		retval(1) = tree_constant (m.row_min_loc ());
-	      }
-	    else
-	      {
-		retval(0) = tree_constant (m.column_min (), 0);
-		retval(1) = tree_constant (m.column_min_loc (), 0);
-	      }
-	  }
-          break;
-	case tree_constant_rep::complex_matrix_constant:
-	  {
-	    ComplexMatrix m = arg1.complex_matrix_value ();
-	    if (m.rows () == 1)
-	      {
-		retval(0) = tree_constant (m.row_min ());
-		retval(1) = tree_constant (m.row_min_loc ());
-	      }
-	    else
-	      {
-		retval(0) = tree_constant (m.column_min (), 0);
-		retval(1) = tree_constant (m.column_min_loc (), 0);
-	      }
-	  }
-          break;
-	default:
-	  panic_impossible ();
-	  break;
-        }
-    }
-  else if (nargin == 3)
-    {
-      if (arg1.rows () == arg2.rows ()
-	  && arg1.columns () == arg2.columns ())
-	{
-	  retval.resize (1);
-          switch (arg1_type)
-            {
-	    case tree_constant_rep::scalar_constant:
-	      {
-		double result;
-		double a_elem = arg1.double_value ();
-		double b_elem = arg2.double_value ();
-		result = MIN (a_elem, b_elem);
-		retval(0) = tree_constant (result);
-	      }
-              break;
-	    case tree_constant_rep::complex_scalar_constant:
-	      {
-		Complex result;
-		Complex a_elem = arg1.complex_value ();
-		Complex b_elem = arg2.complex_value ();
-		if (abs (a_elem) < abs (b_elem))
-		  result = a_elem;
-		else
-		  result = b_elem;
-		retval(0) = tree_constant (result);
-	      }
-              break;
-	    case tree_constant_rep::matrix_constant:
-	      {
-		Matrix result;
-		result = min (arg1.matrix_value (), arg2.matrix_value ());
-		retval(0) = tree_constant (result);
-	      }
-              break;
-	    case tree_constant_rep::complex_matrix_constant:
-	      {
-		ComplexMatrix result;
-		result = min (arg1.complex_matrix_value (),
-			      arg2.complex_matrix_value ());
-		retval(0) = tree_constant (result);
-	      }
-	      break;
-	    default:
-	      panic_impossible ();
-	      break;
-	    }
-	}
-      else
-	error ("min: nonconformant matrices");
-    }
-  else
-    panic_impossible ();
-
-  return retval;
-}
-
-static void
-mx_sort (Matrix& m, Matrix& idx, int return_idx)
-{
-  int nr = m.rows ();
-  int nc = m.columns ();
-  idx.resize (nr, nc);
-  int i, j;
-
-  if (return_idx)
-    {
-      for (j = 0; j < nc; j++)
-	for (i = 0; i < nr; i++)
-	  idx.elem (i, j) = i+1;
-    }
-
-  for (j = 0; j < nc; j++)
-    {
-      for (int gap = nr/2; gap > 0; gap /= 2)
-	for (i = gap; i < nr; i++)
-	  for (int k = i - gap;
-	       k >= 0 && m.elem (k, j) > m.elem (k+gap, j);
-	       k -= gap)
-	    {
-	      double tmp = m.elem (k, j);
-	      m.elem (k, j) = m.elem (k+gap, j);
-	      m.elem (k+gap, j) = tmp;
-
-	      if (return_idx)
-		{
-		  double tmp = idx.elem (k, j);
-		  idx.elem (k, j) = idx.elem (k+gap, j);
-		  idx.elem (k+gap, j) = tmp;
-		}
-	    }
-    }
-}
-
-static void
-mx_sort (RowVector& v, RowVector& idx, int return_idx)
-{
-  int n = v.capacity ();
-  idx.resize (n);
-  int i;
-
-  if (return_idx)
-    for (i = 0; i < n; i++)
-      idx.elem (i) = i+1;
-
-  for (int gap = n/2; gap > 0; gap /= 2)
-    for (i = gap; i < n; i++)
-      for (int k = i - gap;
-	   k >= 0 && v.elem (k) > v.elem (k+gap);
-	   k -= gap)
-	{
-	  double tmp = v.elem (k);
-	  v.elem (k) = v.elem (k+gap);
-	  v.elem (k+gap) = tmp;
-
-	  if (return_idx)
-	    {
-	      double tmp = idx.elem (k);
-	      idx.elem (k) = idx.elem (k+gap);
-	      idx.elem (k+gap) = tmp;
-	    }
-	}
-}
-
-static void
-mx_sort (ComplexMatrix& cm, Matrix& idx, int return_idx)
-{
-  int nr = cm.rows ();
-  int nc = cm.columns ();
-  idx.resize (nr, nc);
-  int i, j;
-
-  if (return_idx)
-    {
-      for (j = 0; j < nc; j++)
-	for (i = 0; i < nr; i++)
-	  idx.elem (i, j) = i+1;
-    }
-
-  for (j = 0; j < nc; j++)
-    {
-      for (int gap = nr/2; gap > 0; gap /= 2)
-	for (i = gap; i < nr; i++)
-	  for (int k = i - gap;
-	       k >= 0 && abs (cm.elem (k, j)) > abs (cm.elem (k+gap, j));
-	       k -= gap)
-	    {
-	      Complex ctmp = cm.elem (k, j);
-	      cm.elem (k, j) = cm.elem (k+gap, j);
-	      cm.elem (k+gap, j) = ctmp;
-
-	      if (return_idx)
-		{
-		  double tmp = idx.elem (k, j);
-		  idx.elem (k, j) = idx.elem (k+gap, j);
-		  idx.elem (k+gap, j) = tmp;
-		}
-	    }
-    }
-}
-
-static void
-mx_sort (ComplexRowVector& cv, RowVector& idx, int return_idx)
-{
-  int n = cv.capacity ();
-  idx.resize (n);
-  int i;
-
-  if (return_idx)
-    for (i = 0; i < n; i++)
-      idx.elem (i) = i+1;
-
-  for (int gap = n/2; gap > 0; gap /= 2)
-    for (i = gap; i < n; i++)
-      for (int k = i - gap;
-	   k >= 0 && abs (cv.elem (k)) > abs (cv.elem (k+gap));
-	   k -= gap)
-	{
-	  Complex tmp = cv.elem (k);
-	  cv.elem (k) = cv.elem (k+gap);
-	  cv.elem (k+gap) = tmp;
-
-	  if (return_idx)
-	    {
-	      double tmp = idx.elem (k);
-	      idx.elem (k) = idx.elem (k+gap);
-	      idx.elem (k+gap) = tmp;
-	    }
-	}
-}
-
-Octave_object
-sort (const Octave_object& args, int nargout)
-{
-// Assumes that we have been given the correct number of arguments.
-
-  Octave_object retval;
-
-  int return_idx = nargout > 1;
-  if (return_idx)
-    retval.resize (2);
-  else
-    retval.resize (1);
-
-  switch (args(1).const_type ())
-    {
-    case tree_constant_rep::scalar_constant:
-      {
-	retval(0) = tree_constant (args(1).double_value ());
-	if (return_idx)
-	  retval(1) = tree_constant (1.0);
-      }
-      break;
-    case tree_constant_rep::complex_scalar_constant:
-      {
-	retval(0) = tree_constant (args(1).complex_value ());
-	if (return_idx)
-	  retval(1) = tree_constant (1.0);
-      }
-      break;
-    case tree_constant_rep::string_constant:
-    case tree_constant_rep::range_constant:
-    case tree_constant_rep::matrix_constant:
-      {
-	Matrix m = args(1).to_matrix ();
-	if (m.rows () == 1)
-	  {
-	    int nc = m.columns ();
-	    RowVector v (nc);
-	    for (int i = 0; i < nc; i++)
-	      v.elem (i) = m.elem (0, i);
-	    RowVector idx;
-	    mx_sort (v, idx, return_idx);
-
-	    retval(0) = tree_constant (v, 0);
-	    if (return_idx)
-	      retval(1) = tree_constant (idx, 0);
-	  }
-	else
-	  {
-// Sorts m in place, optionally computes index Matrix.
-	    Matrix idx;
-	    mx_sort (m, idx, return_idx);
-
-	    retval(0) = tree_constant (m);
-	    if (return_idx)
-	      retval(1) = tree_constant (idx);
-	  }
-      }
-      break;
-    case tree_constant_rep::complex_matrix_constant:
-      {
-	ComplexMatrix cm = args(1).complex_matrix_value ();
-	if (cm.rows () == 1)
-	  {
-	    int nc = cm.columns ();
-	    ComplexRowVector cv (nc);
-	    for (int i = 0; i < nc; i++)
-	      cv.elem (i) = cm.elem (0, i);
-	    RowVector idx;
-	    mx_sort (cv, idx, return_idx);
-
-	    retval(0) = tree_constant (cv, 0);
-	    if (return_idx)
-	      retval(1) = tree_constant (idx, 0);
-	  }
-	else
-	  {
-// Sorts cm in place, optionally computes index Matrix.
-	    Matrix idx;
-	    mx_sort (cm, idx, return_idx);
-
-	    retval(0) = tree_constant (cm);
-	    if (return_idx)
-	      retval(1) = tree_constant (idx);
-	  }
-      }
-      break;
-    default:
-      panic_impossible ();
-      break;
-    }
-
-  return retval;
-}
-
-Octave_object
-feval (const Octave_object& args, int nargout)
-{
-// Assumes that we have been given the correct number of arguments.
-
-  Octave_object retval;
-
-  tree_fvc *fcn = is_valid_function (args(1), "feval", 1);
-  if (fcn != (tree_fvc *) NULL)
-    {
-      int nargin = args.length () - 1;
-      Octave_object tmp_args (nargin);
-      for (int i = 0; i < nargin; i++)
-	tmp_args(i) = args(i+1);
-      retval = fcn->eval (0, nargout, tmp_args);
-    }
-
-  return retval;
-}
-
-tree_constant
-eval_string (const char *string, int print, int ans_assign,
-	     int& parse_status)
-{
-  begin_unwind_frame ("eval_string");
-
-  unwind_protect_int (get_input_from_eval_string);
-  unwind_protect_ptr (global_command);
-  unwind_protect_ptr (current_eval_string);
-
-  get_input_from_eval_string = 1;
-  current_eval_string = string;
-
-  YY_BUFFER_STATE old_buf = current_buffer ();
-  YY_BUFFER_STATE new_buf = create_buffer ((FILE *) NULL);
-
-  add_unwind_protect (restore_input_buffer, (void *) old_buf);
-  add_unwind_protect (delete_input_buffer, (void *) new_buf);
-
-  switch_to_buffer (new_buf);
-
-  unwind_protect_ptr (curr_sym_tab);
-
-  reset_parser ();
-
-  parse_status = yyparse ();
-
-// Important to reset the idea of where input is coming from before
-// trying to eval the command we just parsed -- it might contain the
-// name of an function file that still needs to be parsed!
-
-  tree *command = global_command;
-
-  run_unwind_frame ("eval_string");
-
-  tree_constant retval;
-
-  if (parse_status == 0 && command != NULL_TREE)
-    {
-      retval = command->eval (print);
-      delete command;
-    }
-
-  return retval;
-}
-
-tree_constant
-eval_string (const tree_constant& arg, int& parse_status)
-{
-  if (! arg.is_string_type ())
-    {
-      error ("eval: expecting string argument");
-      return -1;
-    }
-
-  char *string = arg.string_value ();
-
-// Yes Virginia, we always print here...
-
-  return eval_string (string, 1, 1, parse_status);
-}
-
-static int
-match_sans_spaces (const char *standard, const char *test)
-{
-  const char *tp = test;
-  while (*tp == ' ' || *tp == '\t')
-    tp++;
-
-  const char *ep = test + strlen (test) - 1;
-  while (*ep == ' ' || *ep == '\t')
-    ep--;
-
-  int len = ep - tp + 1;
-
-  return (strncmp (standard, tp, len) == 0);
-}
-
-tree_constant
-get_user_input (const Octave_object& args, int nargout, int debug = 0)
-{
-  tree_constant retval;
-
-  int nargin = args.length ();
-
-  int read_as_string = 0;
-
-  if (nargin == 3)
-    {
-      if (args(2).is_string_type ()
-	  && strcmp ("s", args(2).string_value ()) == 0)
-	read_as_string++;
-      else
-	{
-	  error ("input: unrecognized second argument");
-	  return retval;
-	}
-    }
-
-  char *prompt = "debug> ";
-  if (nargin > 1)
-   {
-      if (args(1).is_string_type ())
-	prompt = args(1).string_value ();
-      else
-	{
-	  error ("input: unrecognized argument");
-	  return retval;
-	}
-    }
-
- again:
-
-  flush_output_to_pager ();
-
-  char *input_buf = gnu_readline (prompt);
-
-  if (input_buf != (char *) NULL)
-    {
-      if (input_buf)
-	maybe_save_history (input_buf);
-
-      int len = strlen (input_buf);
-
-      if (len < 1)
-	{
-	  if (debug)
-	    goto again;
-	  else
-	    return retval;
-	}
-
-      if (match_sans_spaces ("exit", input_buf)
-	  || match_sans_spaces ("quit", input_buf)
-	  || match_sans_spaces ("return", input_buf))
-	return tree_constant ();
-      else if (read_as_string)
-	retval = tree_constant (input_buf);
-      else
-	{
-	  int parse_status;
-	  retval = eval_string (input_buf, 0, 0, parse_status);
-	  if (debug && retval.is_defined ())
-	    retval.eval (1);
-	}
-    }
-  else
-    error ("input: reading user-input failed!");
-
-  if (debug)
-    goto again;
-
-  return retval;
-}
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -1,9 +1,9 @@
-// The rest of the tree classes.                          -*- C++ -*-
+// tree-const.h                                        -*- C++ -*-
 /*
 
 Copyright (C) 1992, 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -28,24 +28,25 @@ Software Foundation, 675 Mass Ave, Cambr
 #pragma interface
 #endif
 
 #include <stdlib.h>
 
 #include "mx-base.h"
 #include "Range.h"
 
-#include "builtins.h"
 #include "tree-base.h"
 #include "tree-expr.h"
 #include "tc-rep.h"
 #include "oct-obj.h"
 
 class idx_vector;
 
+struct Mapper_fcn;
+
 /*
  * Constants.
  */
 class
 tree_constant : public tree_fvc
 {
 friend class tree_constant_rep;
 
@@ -93,17 +94,17 @@ public:
 
   ~tree_constant (void);
 
 #if defined (MDEBUG)
   void *operator new (size_t size);
   void operator delete (void *p, size_t size);
 #endif
 
-  tree_constant operator = (tree_constant& a)
+  tree_constant operator = (const tree_constant& a)
     {
       if (--rep->count <= 0 && rep != a.rep)
 	delete rep;
 
       rep = a.rep;
       rep->count++;
       return *this;  
     }
@@ -281,52 +282,20 @@ public:
 	retval(0).eval (print);
       return retval;
     }
 
 private:
   tree_constant_rep *rep;
 };
 
-/*
- * Here are some extra functions that are related to the tree_constant
- * class but that don't need to be class members or friends.
- */
-
+// XXX FIXME XXX -- this is not used very much now.  Perhaps it can be
+// eliminated.
 extern Octave_object vector_of_empties (int nargout, const char *fcn_name);
 
-extern tree_constant fill_matrix (const tree_constant& a,
-				  double d, const char *warn_for);
-extern tree_constant fill_matrix (const tree_constant& a,
-				  const tree_constant& b,
-				  double d, const char *warn_for);
-
-extern tree_constant identity_matrix (const tree_constant& a);
-extern tree_constant identity_matrix (const tree_constant& a,
-				      const tree_constant& b);
-
-extern Octave_object find_nonzero_elem_idx (const tree_constant& a,
-					    int nargout);
-
-extern Octave_object matrix_log (const tree_constant& a);
-extern Octave_object matrix_sqrt (const tree_constant& a);
-
-extern Octave_object column_max (const Octave_object& args, int nargout);
-extern Octave_object column_min (const Octave_object& args, int nargout);
-  
-extern Octave_object sort (const Octave_object& args, int nargout);
- 
-extern Octave_object feval (const Octave_object& args, int nargout);
-
-extern tree_constant eval_string (const tree_constant& arg, int&
-				  parse_status);
-
-extern tree_constant get_user_input (const Octave_object& args,
-				     int nargout, int debug = 0);
-
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/pt-exp-base.cc b/src/pt-exp-base.cc
--- a/src/pt-exp-base.cc
+++ b/src/pt-exp-base.cc
@@ -1,9 +1,9 @@
-// Tree class.                                          -*- C++ -*-
+// tree-expr.cc                                          -*- C++ -*-
 /*
 
 Copyright (C) 1992, 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -50,16 +50,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "input.h"
 #include "symtab.h"
 #include "utils.h"
 #include "octave.h"
 #include "octave-hist.h"
 #include "unwind-prot.h"
 #include "parse.h"
 #include "lex.h"
+#include "defun.h"
 
 extern "C"
 {
 #include <readline/readline.h>
 }
 
 // Nonzero means we're returning from a function.
 extern int returning;
@@ -143,25 +144,25 @@ any_arg_is_magic_colon (const Octave_obj
 /*
  * General matrices.  This list type is much more work to handle than
  * constant matrices, but it allows us to construct matrices from
  * other matrices, variables, and functions.
  */
 tree_matrix::tree_matrix (void)
 {
   dir = tree::md_none;
-  element = (tree_expression *) NULL;
-  next = (tree_matrix *) NULL;
+  element = 0;
+  next = 0;
 }
 
 tree_matrix::tree_matrix (tree_expression *e, tree::matrix_dir d)
 {
   dir = d;
   element = e;
-  next = (tree_matrix *) NULL;
+  next = 0;
 }
 
 tree_matrix::~tree_matrix (void)
 {
   delete element;
   delete next;
 }
 
@@ -173,47 +174,47 @@ tree_matrix::chain (tree_expression *t, 
   return tmp;
 }
 
 tree_matrix *
 tree_matrix::reverse (void)
 {
   tree_matrix *list = this;
   tree_matrix *next;
-  tree_matrix *prev = (tree_matrix *) NULL;
-
-  while (list != (tree_matrix *) NULL)
+  tree_matrix *prev = 0;
+
+  while (list)
     {
       next = list->next;
       list->next = prev;
       prev = list;
       list = next;
     }
   return prev;
 }
 
 int
 tree_matrix::length (void)
 {
   tree_matrix *list = this;
   int len = 0;
-  while (list != (tree_matrix *) NULL)
+  while (list)
     {
       len++;
       list = list->next;
     }
   return len;
 }
 
 tree_return_list *
 tree_matrix::to_return_list (void)
 {
-  tree_return_list *retval = (tree_return_list *) NULL;
+  tree_return_list *retval = 0;
   tree_matrix *list;
-  for (list = this; list != (tree_matrix *) NULL; list = list->next)
+  for (list = this; list; list = list->next)
     {
       tree_expression *elem = list->element;
       if (elem->is_identifier ())
 	{
 	  tree_identifier *id = (tree_identifier *) elem;
 	  if (list == this)
 	    retval = new tree_return_list (id);
 	  else
@@ -227,22 +228,22 @@ tree_matrix::to_return_list (void)
 	  if (list == this)
 	    retval = new tree_return_list (idx_expr);
 	  else
 	    retval = retval->chain (idx_expr);
 	}
       else
 	{
 	  delete retval;
-	  retval = (tree_return_list *) NULL;
+	  retval = 0;
 	  break;
 	}
     }
 
-  if (retval != (tree_return_list *) NULL)
+  if (retval)
     retval = retval->reverse ();
   return retval;
 }
 
 // Just about as ugly as it gets.
 
 struct const_matrix_list
 {
@@ -297,28 +298,28 @@ tree_matrix::eval (int print)
   int put_col = 0;
 
   int prev_nr = 0;
   int prev_nc = 0;
 
   Matrix m;
   ComplexMatrix cm;
 
-  char *string = (char *) NULL;
-  char *str_ptr = (char *) NULL;
+  char *string = 0;
+  char *str_ptr = 0;
 
 // Eliminate empties and gather stats.
 
   int found_new_row_in_empties = 0;
 
   int len = 0;
   for (int i = 0; i < total_len; i++)
     {
       tree_expression *elem = ptr->element;
-      if (elem == (tree_expression *) NULL)
+      if (! elem)
 	{
 	  retval = tree_constant (Matrix ());
 	  goto done;
 	}
 
       tree_constant tmp = elem->eval (0);
       if (error_state || tmp.is_undefined ())
 	{
@@ -489,17 +490,17 @@ tree_matrix::eval (int print)
       if (found_complex)
 	{
 	  switch (tmp_type)
 	    {
 	    case tree_constant_rep::scalar_constant:
 	      cm (put_row, put_col) = tmp.double_value ();
 	      break;
 	    case tree_constant_rep::string_constant:
-	      if (all_strings && str_ptr != (char *) NULL)
+	      if (all_strings && str_ptr)
 		{
 		  memcpy (str_ptr, tmp.string_value (), nc);
 		  str_ptr += nc;
 		  break;
 		}
 	    case tree_constant_rep::range_constant:
 	      tmp_type = tmp.force_numeric (1);
 	      if (tmp_type == tree_constant_rep::scalar_constant)
@@ -527,17 +528,17 @@ tree_matrix::eval (int print)
       else
 	{
 	  switch (tmp_type)
 	    {
 	    case tree_constant_rep::scalar_constant:
 	      m (put_row, put_col) = tmp.double_value ();
 	      break;
 	    case tree_constant_rep::string_constant:
-	      if (all_strings && str_ptr != (char *) NULL)
+	      if (all_strings && str_ptr)
 		{
 		  memcpy (str_ptr, tmp.string_value (), nc);
 		  str_ptr += nc;
 		  break;
 		}
 	    case tree_constant_rep::range_constant:
 	      tmp_type = tmp.force_numeric (1);
 	      if (tmp_type == tree_constant_rep::scalar_constant)
@@ -558,17 +559,17 @@ tree_matrix::eval (int print)
 	      break;
 	    }
 	}
 
       prev_nr = nr;
       prev_nc = nc;
     }
 
-  if (all_strings && string != (char *) NULL)
+  if (all_strings && string)
     retval = tree_constant (string);
   else if (found_complex)
     retval = tree_constant (cm);
   else
     retval = tree_constant (m);
 
  done:
   delete [] list;
@@ -581,94 +582,80 @@ tree_fvc::assign (tree_constant& t, cons
 {
   panic_impossible ();
   return tree_constant ();
 }
 
 /*
  * Builtin functions.
  */
-tree_builtin::tree_builtin (const char *nm = (char *) NULL)
+tree_builtin::tree_builtin (const char *nm)
 {
   nargin_max = -1;
   nargout_max = -1;
-  text_fcn = (Text_fcn) NULL;
-  general_fcn = (General_fcn) NULL;
-  if (nm != (char *) NULL)
+  is_mapper = 0;
+  fcn = 0;
+  if (nm)
     my_name = strsave (nm);
 }
 
 tree_builtin::tree_builtin (int i_max, int o_max, Mapper_fcn& m_fcn,
-			    const char *nm = (char *) NULL)
+			    const char *nm)
 {
   nargin_max = i_max;
   nargout_max = o_max;
   mapper_fcn = m_fcn;
-  text_fcn = (Text_fcn) NULL;
-  general_fcn = (General_fcn) NULL;
-  if (nm != (char *) NULL)
+  is_mapper = 1;
+  fcn = 0;
+  if (nm)
     my_name = strsave (nm);
 }
 
-tree_builtin::tree_builtin (int i_max, int o_max, Text_fcn t_fcn,
-			    const char *nm = (char *) NULL)
+tree_builtin::tree_builtin (int i_max, int o_max, Octave_builtin_fcn g_fcn,
+			    const char *nm)
 {
   nargin_max = i_max;
   nargout_max = o_max;
-  text_fcn = t_fcn;
-  general_fcn = (General_fcn) NULL;
-  if (nm != (char *) NULL)
-    my_name = strsave (nm);
-}
-
-tree_builtin::tree_builtin (int i_max, int o_max, General_fcn g_fcn,
-			    const char *nm = (char *) NULL)
-{
-  nargin_max = i_max;
-  nargout_max = o_max;
-  text_fcn = (Text_fcn) NULL;
-  general_fcn = g_fcn;
-  if (nm != (char *) NULL)
+  is_mapper = 0;
+  fcn = g_fcn;
+  if (nm)
     my_name = strsave (nm);
 }
 
 tree_builtin::~tree_builtin (void)
 {
 }
 
 #if 0
 int
 tree_builtin::is_builtin (void) const
 {
   return 1;
 }
 #endif
 
+int
+tree_builtin::is_mapper_function (void) const
+{
+  return is_mapper;
+}
+
 tree_constant
 tree_builtin::eval (int print)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
-  if (text_fcn != (Text_fcn) NULL)
-    {
-      char **argv = new char * [1];
-      argv[0] = strsave (my_name);
-      Octave_object tmp = (*text_fcn) (1, argv, 1);
-      if (tmp.length () > 0)
-	retval = tmp(0);
-      delete [] argv;
-    }
-  else if (general_fcn != (General_fcn) NULL)
+  if (fcn)
     {
       Octave_object args (1);
       args(0) = tree_constant (my_name);
-      Octave_object tmp = (*general_fcn) (args, 1);
+      Octave_object tmp = (*fcn) (args, 1);
       if (tmp.length () > 0)
 	retval = tmp(0);
     }
   else // Assume mapper function
     ::error ("%s: argument expected", my_name);
 
   return retval;
 }
@@ -678,51 +665,36 @@ tree_builtin::eval (int print, int nargo
 {
   Octave_object retval;
 
   if (error_state)
     return retval;
 
   int nargin = args.length ();
 
-  if (text_fcn != (Text_fcn) NULL)
-    {
-// XXX FIXME XXX -- what if some arg is not a string?
-
-      int argc = nargin;
-      char **argv = new char * [argc + 1];
-      argv[0] = strsave (my_name);
-      for (int i = 1; i < argc; i++)
-	argv[i] = strsave (args(i).string_value ());
-      argv[argc] = (char *) NULL;
-
-      retval = (*text_fcn) (argc, argv, nargout);
-
-      for (i = 0; i < argc; i++)
-	delete [] argv[i];
-      delete [] argv;
-    }
-  else if (general_fcn != (General_fcn) NULL)
+  if (fcn)
     {
       if (any_arg_is_magic_colon (args))
 	::error ("invalid use of colon in function argument list");
       else
-	retval = (*general_fcn) (args, nargout);
+	retval = (*fcn) (args, nargout);
     }
-  else
+  else if (is_mapper)
     {
       if (nargin > nargin_max)
 	::error ("%s: too many arguments", my_name);
       else if (nargin > 0 && args.length () > 0 && args(1).is_defined ())
 	{
 	  tree_constant tmp = args(1).mapper (mapper_fcn, 0);
 	  retval.resize (1);
 	  retval(0) = tmp;
 	}	
     }
+  else
+    panic_impossible ();
 
   return retval;
 }
 
 char *
 tree_builtin::name (void) const
 {
   return my_name;
@@ -737,25 +709,25 @@ tree_builtin::max_expected_args (void)
   else
     ea = nargin_max;
   return ea;
 }
 
 /*
  * Symbols from the symbol table.
  */
-tree_identifier::tree_identifier (int l = -1, int c = -1)
+tree_identifier::tree_identifier (int l, int c)
 {
-  sym = (symbol_record *) NULL;
+  sym = 0;
   line_num = l;
   column_num = c;
   maybe_do_ans_assign = 0;
 }
 
-tree_identifier::tree_identifier (symbol_record *s, int l = -1, int c = -1)
+tree_identifier::tree_identifier (symbol_record *s, int l, int c)
 {
   sym = s;
   line_num = l;
   column_num = c;
   maybe_do_ans_assign = 0;
 }
 
 tree_identifier::~tree_identifier (void)
@@ -782,33 +754,33 @@ tree_identifier::rename (const char *n)
 
 tree_identifier *
 tree_identifier::define (tree_constant *t)
 {
   int status = sym->define (t);
   if (status)
     return this;
   else
-    return (tree_identifier *) NULL;
+    return 0;
 }
 
 tree_identifier *
 tree_identifier::define (tree_function *t)
 {
   int status = sym->define (t);
   if (status)
     return this;
   else
-    return (tree_identifier *) NULL;
+    return 0;
 }
 
 void
 tree_identifier::document (char *s)
 {
-  if (sym != (symbol_record *) NULL && s != (char *) NULL)
+  if (sym && s)
     {
       char *tmp = strsave (s);
       sym->document (tmp);
     }
 }
 
 tree_constant
 tree_identifier::assign (tree_constant& rhs)
@@ -884,32 +856,32 @@ tree_identifier::assign (tree_constant& 
     }
 
   return retval;
 }
 
 int
 tree_identifier::is_defined (void)
 {
-  return (sym != (symbol_record *) NULL && sym->is_defined ());
+  return (sym && sym->is_defined ());
 }
 
 void
 tree_identifier::bump_value (tree::expression_type etype)
 {
-  if (sym != (symbol_record *) NULL)
+  if (sym)
     {
       tree_fvc *tmp = sym->def ();
-      if (tmp != NULL_TREE)
+      if (tmp)
 	tmp->bump_value (etype);
     }
 }
 
 int
-tree_identifier::parse_fcn_file (int exec_script = 1)
+tree_identifier::parse_fcn_file (int exec_script)
 {
   curr_fcn_file_name = name ();
   char *ff = fcn_file_in_path (curr_fcn_file_name);
   int script_file_executed = parse_fcn_file (ff, exec_script);
   delete [] ff;
 
   if (! (error_state || script_file_executed))
     force_link_to_function (name ());
@@ -961,23 +933,23 @@ is_function_file (FILE *ffile)
     status = 1;
 
   fseek (ffile, pos, SEEK_SET);
 
   return status;
 }
 
 int
-tree_identifier::parse_fcn_file (char *ff, int exec_script = 1)
+tree_identifier::parse_fcn_file (char *ff, int exec_script)
 {
   begin_unwind_frame ("parse_fcn_file");
 
   int script_file_executed = 0;
 
-  if (ff != (char *) NULL)
+  if (ff)
     {
 // Open function file and parse.
 
       int old_reading_fcn_file_state = reading_fcn_file;
 
       unwind_protect_ptr (rl_instream);
       unwind_protect_ptr (ff_instream);
 
@@ -988,17 +960,17 @@ tree_identifier::parse_fcn_file (char *f
 
       using_readline = 0;
       reading_fcn_file = 1;
       input_line_number = 0;
       current_input_column = 1;
 
       FILE *ffile = get_input_from_file (ff, 0);
 
-      if (ffile != (FILE *) NULL)
+      if (ffile)
 	{
 // Check to see if this file defines a function or is just a list of
 // commands.
 
 	  if (is_function_file (ffile))
 	    {
 	      parse_fcn_file (ffile, ff);
 	    }
@@ -1109,28 +1081,28 @@ tree_identifier::do_lookup (int& script_
 	    }
 	  else if (sym->is_function () && symbol_out_of_date (sym))
 	    {
 	      script_file_executed = parse_fcn_file ();
 	    }
 	}
     }
 
-  tree_fvc *ans = (tree_fvc *) NULL;
+  tree_fvc *ans = 0;
 
   if (! script_file_executed)
     ans = sym->def ();
 
   return ans;
 }
 
 void
 tree_identifier::mark_as_formal_parameter (void)
 {
-  if (sym != (symbol_record *) NULL)
+  if (sym)
     sym->mark_as_formal_parameter ();
 }
 
 void
 tree_identifier::mark_for_possible_ans_assign (void)
 {
   maybe_do_ans_assign = 1;
 }
@@ -1144,39 +1116,39 @@ tree_identifier::eval (int print)
     return retval;
 
   int script_file_executed = 0;
 
   tree_fvc *ans = do_lookup (script_file_executed);
 
   if (! script_file_executed)
     {
-      if (ans == (tree_fvc *) NULL)
-	eval_undefined_error ();
-      else
+      if (ans)
 	{
 	  int nargout = maybe_do_ans_assign ? 0 : 1;
 
 	  int nargin = (ans->is_constant ()) ? 0 : 1;
 	  Octave_object tmp_args (nargin);
 	  Octave_object tmp = ans->eval (0, nargout, tmp_args);
 
 	  if (tmp.length () > 0)
 	    retval = tmp(0);
 	}
+      else
+	eval_undefined_error ();
     }
 
   if (! error_state && retval.is_defined ())
     {
       if (maybe_do_ans_assign && ! ans->is_constant ())
 	{
 	  symbol_record *sr = global_sym_tab->lookup ("ans", 1, 0);
 
-	  assert (sr != (symbol_record *) NULL);
-      
+	  assert (sr);
+
 	  tree_identifier *ans_id = new tree_identifier (sr);
 
 	  tree_constant *tmp = new tree_constant (retval);
 
 	  tree_simple_assignment_expression tmp_ass (ans_id, tmp);
 
 	  tmp_ass.eval (print);
 
@@ -1229,82 +1201,82 @@ tree_identifier::eval (int print, int na
     return retval;
 
   int script_file_executed = 0;
 
   tree_fvc *ans = do_lookup (script_file_executed);
 
   if (! script_file_executed)
     {
-      if (ans == (tree_fvc *) NULL)
-	eval_undefined_error ();
-      else
+      if (ans)
 	{
 	  if (maybe_do_ans_assign && nargout == 1)
 	    {
 
 // Don't count the output arguments that we create automatically.
 
 	      nargout = 0;
 
 	      retval = ans->eval (0, nargout, args);
 
 	      if (retval.length () > 0 && retval(0).is_defined ())
 		{
 		  symbol_record *sr = global_sym_tab->lookup ("ans", 1, 0);
 
-		  assert (sr != (symbol_record *) NULL);
+		  assert (sr);
       
 		  tree_identifier *ans_id = new tree_identifier (sr);
 
 		  tree_constant *tmp = new tree_constant (retval(0));
 
 		  tree_simple_assignment_expression tmp_ass (ans_id, tmp);
 
 		  tmp_ass.eval (print);
 
 		  delete ans_id;  // XXX FIXME XXX
 		}
 	    }
 	  else
 	    retval = ans->eval (print, nargout, args);
 	}
+      else
+	eval_undefined_error ();
     }
 
   return retval;
 }
 
 /*
  * User defined functions.
  */
 tree_function::tree_function (void)
 {
   call_depth = 0;
-  param_list = (tree_parameter_list *) NULL;
-  ret_list = (tree_parameter_list *) NULL;
-  sym_tab = (symbol_table *) NULL;
-  cmd_list = NULL_TREE;
-  file_name = (char *) NULL;
-  fcn_name = (char *) NULL;
+  param_list = 0;
+  ret_list = 0;
+  sym_tab = 0;
+  cmd_list = 0;
+  file_name = 0;
+  fcn_name = 0;
   t_parsed = 0;
   system_fcn_file = 0;
   num_named_args = 0;
   num_args_passed = 0;
   curr_va_arg_number = 0;
 }
 
 tree_function::tree_function (tree *cl, symbol_table *st)
 {
   call_depth = 0;
-  param_list = (tree_parameter_list *) NULL;
-  ret_list = (tree_parameter_list *) NULL;
+  param_list = 0;
+  ret_list = 0;
   sym_tab = st;
   cmd_list = cl;
-  file_name = (char *) NULL;
-  fcn_name = (char *) NULL;
+  file_name = 0;
+  fcn_name = 0;
   t_parsed = 0;
   system_fcn_file = 0;
   num_named_args = 0;
   num_args_passed = 0;
   curr_va_arg_number = 0;
 }
 
 tree_function::~tree_function (void)
@@ -1318,17 +1290,17 @@ tree_function::define (tree *t)
   return this;
 }
 
 tree_function *
 tree_function::define_param_list (tree_parameter_list *t)
 {
   param_list = t;
 
-  if (param_list != (tree_parameter_list *) NULL)
+  if (param_list)
     {
       int len = param_list->length ();
       int va_only = param_list->varargs_only ();
       num_named_args = va_only ? len - 1 : len;
       curr_va_arg_number = num_named_args;
     }
 
   return this;
@@ -1364,17 +1336,17 @@ time_t
 tree_function::time_parsed (void)
 {
   return t_parsed;
 }
 
 void
 tree_function::mark_as_system_fcn_file (void)
 {
-  if (file_name != (char *) NULL)
+  if (file_name)
     {
 // We really should stash the whole path to the file we found, when we
 // looked it up, to avoid possible race conditions...  XXX FIXME XXX
 //
 // We probably also don't need to get the library directory every
 // time, but since this function is only called when the function file
 // is parsed, it probably doesn't matter that much.
 
@@ -1396,18 +1368,17 @@ int
 tree_function::is_system_fcn_file (void) const
 {
   return system_fcn_file;
 }
 
 int
 tree_function::takes_varargs (void) const
 {
-  return (param_list != (tree_parameter_list *) NULL
-	  && param_list->takes_varargs ());
+  return (param_list && param_list->takes_varargs ());
 }
 
 void
 tree_function::octave_va_start (void)
 {
   curr_va_arg_number = num_named_args;
 }
 
@@ -1438,17 +1409,17 @@ tree_function::function_name (void)
   return fcn_name;
 }
 
 tree_constant
 tree_function::eval (int print)
 {
   tree_constant retval;
 
-  if (error_state || cmd_list == NULL_TREE)
+  if (error_state || ! cmd_list)
     return retval;
 
   Octave_object tmp_args (1);
   Octave_object tmp = eval (print, 1, tmp_args);
 
   if (! error_state && tmp.length () > 0)
     retval = tmp(0);
 
@@ -1474,17 +1445,17 @@ clear_symbol_table (void *table)
 Octave_object
 tree_function::eval (int print, int nargout, const Octave_object& args)
 {
   Octave_object retval;
 
   if (error_state)
     return retval;
 
-  if (cmd_list == NULL_TREE)
+  if (! cmd_list)
     return retval;
 
   int nargin = args.length ();
 
   begin_unwind_frame ("func_eval");
 
   unwind_protect_int (call_depth);
   call_depth++;
@@ -1511,18 +1482,17 @@ tree_function::eval (int print, int narg
   args_passed = args;
 
   unwind_protect_int (num_args_passed);
   num_args_passed = nargin;
 
   unwind_protect_int (num_named_args);
   unwind_protect_int (curr_va_arg_number);
 
-  if (param_list != (tree_parameter_list *) NULL
-      && ! param_list->varargs_only ())
+  if (param_list && ! param_list->varargs_only ())
     {
       param_list->define_from_arg_vector (args);
       if (error_state)
 	goto abort;
     }
 
 // The following code is in a separate scope to avoid warnings from
 // G++ about `goto abort' crossing the initialization of some
@@ -1544,17 +1514,17 @@ tree_function::eval (int print, int narg
     if (error_state)
       {
 	traceback_error ();
 	goto abort;
       }
     
 // Copy return values out.
 
-    if (ret_list != (tree_parameter_list *) NULL)
+    if (ret_list)
       {
 	retval = ret_list->convert_to_const_vector ();
       }
     else if (user_pref.return_last_computed_value)
       {
 	retval.resize (1);
 	retval(0) = last_computed_value;
       }
@@ -1564,49 +1534,107 @@ tree_function::eval (int print, int narg
   run_unwind_frame ("func_eval");
 
   return retval;
 }
 
 int
 tree_function::max_expected_args (void)
 {
-  if (param_list != NULL_TREE)
+  if (param_list)
     {
       if (param_list->takes_varargs ())
 	return -1;
       else
 	return param_list->length () + 1;
     }
   else
     return 1;
 }
 
 void
 tree_function::traceback_error (void)
 {
   if (error_state >= 0)
     error_state = -1;
 
-  if (fcn_name != (char *) NULL)
+  if (fcn_name)
     {
-      if (file_name != (char *) NULL)
+      if (file_name)
 	::error ("called from `%s' in file `%s'", fcn_name, file_name);
       else 
 	::error ("called from `%s'", fcn_name);
     }
   else
     {
-      if (file_name != (char *) NULL)
+      if (file_name)
 	::error ("called from file `%s'", file_name);
       else
 	::error ("called from `?unknown?'");
     }
 }
 
+DEFUN ("va_arg", Fva_arg, Sva_arg, 1, 1,
+  "va_arg (): return next argument in a function that takes a\n\
+varible number of parameters")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin == 1)
+    {
+      if (curr_function)
+	{
+	  if (curr_function->takes_varargs ())
+	    retval = curr_function->octave_va_arg ();
+	  else
+	    {
+	      error ("va_arg only valid within function taking variable");
+	      error ("number of arguments");
+	    }
+	}
+      else
+	error ("va_arg only valid within function body");
+    }
+  else
+    print_usage ("va_arg");
+
+  return retval;
+}
+
+DEFUN ("va_start", Fva_start, Sva_start, 1, 0,
+  "va_start (): reset the pointer to the list of optional arguments\n\
+to the beginning")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin == 1)
+    {
+      if (curr_function)
+	{
+	  if (curr_function->takes_varargs ())
+	    curr_function->octave_va_start ();
+	  else
+	    {
+	      error ("va_start only valid within function taking variable");
+	      error ("number of arguments");
+	    }
+	}
+      else
+	error ("va_start only valid within function body");
+    }
+  else
+    print_usage ("va_start");
+
+  return retval;
+}
+
 /*
  * Expressions.
  */
 tree_expression::tree_expression (void)
 {
   etype = tree::unknown;
 }
 
@@ -1626,27 +1654,27 @@ tree_expression::eval (int print, int na
 {
   panic_impossible ();
   return Octave_object ();
 }
 
 /*
  * Prefix expressions.
  */
-tree_prefix_expression::tree_prefix_expression (int l = -1, int c = -1)
+tree_prefix_expression::tree_prefix_expression (int l, int c)
 {
-  id = (tree_identifier *) NULL;
+  id = 0;
   etype = unknown;
   line_num = l;
   column_num = c;
 }
 
 tree_prefix_expression::tree_prefix_expression (tree_identifier *t,
 						tree::expression_type et,
-						int l = -1, int c = -1)
+						int l, int c)
 {
   id = t;
   etype = et;
   line_num = l;
   column_num = c;
 }
 
 tree_prefix_expression::~tree_prefix_expression (void)
@@ -1657,17 +1685,17 @@ tree_prefix_expression::~tree_prefix_exp
 tree_constant
 tree_prefix_expression::eval (int print)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
-  if (id != (tree_identifier *) NULL)
+  if (id)
     {
       id->bump_value (etype);
       retval = id->eval (print);
       if (error_state)
 	{
 	  retval = tree_constant ();
 	  if (error_state)
 	    eval_error ();
@@ -1698,27 +1726,27 @@ int
 tree_prefix_expression::is_prefix_expression (void) const
 {
   return 1;
 }
 
 /*
  * Postfix expressions.
  */
-tree_postfix_expression::tree_postfix_expression (int l = -1, int c = -1)
+tree_postfix_expression::tree_postfix_expression (int l, int c)
 {
-  id = (tree_identifier *) NULL;
+  id = 0;
   etype = unknown;
   line_num = l;
   column_num = c;
 }
 
 tree_postfix_expression::tree_postfix_expression (tree_identifier *t,
 						  tree::expression_type et,
-						  int l = -1, int c = -1)
+						  int l, int c)
 {
   id = t;
   etype = et;
   line_num = l;
   column_num = c;
 }
 
 tree_postfix_expression::~tree_postfix_expression (void)
@@ -1729,17 +1757,17 @@ tree_postfix_expression::~tree_postfix_e
 tree_constant
 tree_postfix_expression::eval (int print)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
-  if (id != (tree_identifier *) NULL)
+  if (id)
     {
       retval = id->eval (print);
       id->bump_value (etype);
       if (error_state)
 	{
 	  retval = tree_constant ();
 	  if (error_state)
 	    eval_error ();
@@ -1764,27 +1792,27 @@ tree_postfix_expression::eval_error (voi
       ::error ("evaluating postfix operator `%s' near line %d, column %d",
 	       op, line (), column ());
     }
 }
 
 /*
  * Unary expressions.
  */
-tree_unary_expression::tree_unary_expression (int l = -1, int c = -1)
+tree_unary_expression::tree_unary_expression (int l, int c)
 {
   etype = tree::unknown;
-  op = (tree_expression *) NULL;
+  op = 0;
   line_num = l;
   column_num = c;
 }
 
 tree_unary_expression::tree_unary_expression (tree_expression *a,
 					      tree::expression_type t,
-					      int l = -1, int c = -1)
+					      int l, int c)
 {
   etype = t;
   op = a;
   line_num = l;
   column_num = c;
 }
 
 tree_unary_expression::~tree_unary_expression (void)
@@ -1801,17 +1829,17 @@ tree_unary_expression::eval (int print)
   tree_constant ans;
 
   switch (etype)
     {
     case tree::not:
     case tree::uminus:
     case tree::hermitian:
     case tree::transpose:
-      if (op != (tree_expression *) NULL)
+      if (op)
 	{
 	  tree_constant u = op->eval (0);
 	  if (error_state)
 	    eval_error ();
 	  else if (u.is_defined ())
 	    {
 	      ans = do_unary_op (u, etype);
 	      if (error_state)
@@ -1849,29 +1877,29 @@ tree_unary_expression::eval_error (void)
       ::error ("evaluating unary operator `%s' near line %d, column %d",
 	       op, line (), column ());
     }
 }
 
 /*
  * Binary expressions.
  */
-tree_binary_expression::tree_binary_expression (int l = -1, int c = -1)
+tree_binary_expression::tree_binary_expression (int l, int c)
 {
   etype = tree::unknown;
-  op1 = (tree_expression *) NULL;
-  op2 = (tree_expression *) NULL;
+  op1 = 0;
+  op2 = 0;
   line_num = l;
   column_num = c;
 }
 
 tree_binary_expression::tree_binary_expression (tree_expression *a,
 						tree_expression *b,
 						tree::expression_type t,
-						int l = -1, int c = -1)
+						int l, int c)
 {
   etype = t;
   op1 = a;
   op2 = b;
   line_num = l;
   column_num = c;
 }
 
@@ -1903,22 +1931,22 @@ tree_binary_expression::eval (int print)
     case tree::cmp_lt:
     case tree::cmp_le:
     case tree::cmp_eq:
     case tree::cmp_ge:
     case tree::cmp_gt:
     case tree::cmp_ne:
     case tree::and:
     case tree::or:
-      if (op1 != (tree_expression *) NULL)
+      if (op1)
 	{
 	  tree_constant a = op1->eval (0);
 	  if (error_state)
 	    eval_error ();
-	  else if (a.is_defined () && op2 != (tree_expression *) NULL)
+	  else if (a.is_defined () && op2)
 	    {
 	      tree_constant b = op2->eval (0);
 	      if (error_state)
 		eval_error ();
 	      else if (b.is_defined ())
 		{
 		  ans = do_binary_op (a, b, etype);
 		  if (error_state)
@@ -1930,17 +1958,17 @@ tree_binary_expression::eval (int print)
 		}
 	    }
 	}
       break;
     case tree::and_and:
     case tree::or_or:
       {
 	int result = 0;
-	if (op1 != NULL_TREE)
+	if (op1)
 	  {
 	    tree_constant a = op1->eval (0);
 	    if (error_state)
 	      {
 		eval_error ();
 		break;
 	      }
 
@@ -1963,17 +1991,17 @@ tree_binary_expression::eval (int print)
 	      {
 		if (etype == tree::and_and)
 		  {
 		    result = 0;
 		    goto done;
 		  }
 	      }
 
-	    if (op2 != NULL_TREE)
+	    if (op2)
 	      {
 		tree_constant b = op2->eval (0);
 		if (error_state)
 		  {
 		    eval_error ();
 		    break;
 		  }
 
@@ -2058,39 +2086,39 @@ tree_assignment_expression::is_assignmen
 {
   return 1;
 }
 
 /*
  * Simple assignment expressions.
  */
 tree_simple_assignment_expression::tree_simple_assignment_expression
-  (int l = -1, int c = -1)
+  (int l, int c)
 {
   etype = tree::assignment;
-  lhs = (tree_identifier *) NULL;
-  index = (tree_argument_list *) NULL;
-  rhs = (tree_expression *) NULL;
+  lhs = 0;
+  index = 0;
+  rhs = 0;
   line_num = l;
   column_num = c;
 }
 
 tree_simple_assignment_expression::tree_simple_assignment_expression
-  (tree_identifier *i, tree_expression *r, int l = -1, int c = -1)
+  (tree_identifier *i, tree_expression *r, int l, int c)
 {
   etype = tree::assignment;
   lhs = i;
-  index = (tree_argument_list *) NULL;
+  index = 0;
   rhs = r;
   line_num = l;
   column_num = c;
 }
 
 tree_simple_assignment_expression::tree_simple_assignment_expression
-  (tree_index_expression *idx_expr, tree_expression *r, int l = -1, int c = -1)
+  (tree_index_expression *idx_expr, tree_expression *r, int l, int c)
 {
   etype = tree::assignment;
   lhs = idx_expr->ident ();
   index = idx_expr->arg_list ();
   rhs = r;
   line_num = l;
   column_num = c;
 }
@@ -2108,25 +2136,25 @@ tree_simple_assignment_expression::eval 
   assert (etype == tree::assignment);
 
   tree_constant ans;
   tree_constant retval;
 
   if (error_state)
     return retval;
 
-  if (rhs != (tree_expression *) NULL)
+  if (rhs)
     {
       tree_constant rhs_val = rhs->eval (0);
       if (error_state)
 	{
 	  if (error_state)
 	    eval_error ();
 	}
-      else if (index == NULL_TREE)
+      else if (! index)
 	{
 	  ans = lhs->assign (rhs_val);
 	  if (error_state)
 	    eval_error ();
 	}
       else
 	{
 // Extract the arguments into a simple vector.
@@ -2192,27 +2220,27 @@ tree_simple_assignment_expression::eval_
 //	error ("evaluating assignment expression");
     }
 }
 
 /*
  * Multi-valued assignmnt expressions.
  */
 tree_multi_assignment_expression::tree_multi_assignment_expression
-  (int l = -1, int c = -1)
+  (int l, int c)
 {
   etype = tree::multi_assignment;
-  lhs = (tree_return_list *) NULL;
-  rhs = (tree_expression *) NULL;
+  lhs = 0;
+  rhs = 0;
   line_num = l;
   column_num = c;
 }
 
 tree_multi_assignment_expression::tree_multi_assignment_expression
-  (tree_return_list *lst, tree_expression *r, int l = -1, int c = -1)
+  (tree_return_list *lst, tree_expression *r, int l, int c)
 {
   etype = tree::multi_assignment;
   lhs = lst;
   rhs = r;
   line_num = l;
   column_num = c;
 }
 
@@ -2240,17 +2268,17 @@ tree_multi_assignment_expression::eval (
 }
 
 Octave_object
 tree_multi_assignment_expression::eval (int print, int nargout,
 					const Octave_object& args)
 {
   assert (etype == tree::multi_assignment);
 
-  if (error_state || rhs == (tree_expression *) NULL)
+  if (error_state || ! rhs)
     return Octave_object ();
 
   nargout = lhs->length ();
   Octave_object tmp_args;
   Octave_object results = rhs->eval (0, nargout, tmp_args);
 
   if (error_state)
     eval_error ();
@@ -2259,26 +2287,25 @@ tree_multi_assignment_expression::eval (
   int ma_column = column ();
 
   if (results.length () > 0)
     {
       tree_return_list *elem;
       int i = 0;
       int pad_after = 0;
       int last_was_scalar_type = 0;
-      for (elem = lhs; elem != (tree_return_list *) NULL;
-	   elem = elem->next_elem ())
+      for (elem = lhs; elem; elem = elem->next_elem ())
 	{
 	  tree_index_expression *lhs_expr = elem->idx_expr ();
 	  if (i < nargout)
 	    {
 // XXX FIXME? XXX -- this is apparently the way Matlab works, but
 // maybe we should have the option of skipping the assignment instead.
 
-	      tree_constant *tmp = NULL_TREE_CONST;
+	      tree_constant *tmp = 0;
 	      if (results(i).is_undefined ())
 		{
 		  Matrix m;
 		  tmp = new tree_constant (m);
 		}
 	      else
 		tmp = new tree_constant (results(i));
 
@@ -2321,17 +2348,17 @@ tree_multi_assignment_expression::eval (
 	      results(i).eval (print);
 
 	      pad_after++;
 	      i++;
 	    }
 	  else
 	    {
 	      tree_simple_assignment_expression tmp_expr
-		(lhs_expr, NULL_TREE_CONST, ma_line, ma_column);
+		(lhs_expr, 0, ma_line, ma_column);
 
 	      tmp_expr.eval (0);
 
 	      if (error_state)
 		break;
 
 	      if (last_was_scalar_type && i == 1)
 		pad_after = 0;
@@ -2357,66 +2384,66 @@ tree_multi_assignment_expression::eval_e
   if (error_state > 0)
     ::error ("evaluating assignment expression near line %d, column %d",
 	     line (), column ());
 }
 
 /*
  * Colon expressions.
  */
-tree_colon_expression::tree_colon_expression (int l = -1, int c = -1)
+tree_colon_expression::tree_colon_expression (int l, int c)
 {
   etype = tree::colon;
-  op1 = (tree_expression *) NULL;
-  op2 = (tree_expression *) NULL;
-  op3 = (tree_expression *) NULL;
+  op1 = 0;
+  op2 = 0;
+  op3 = 0;
   line_num = l;
   column_num = c;
 }
 
 tree_colon_expression::tree_colon_expression (tree_expression *a, tree_expression *b,
-					      int l = -1, int c = -1)
+					      int l, int c)
 {
   etype = tree::colon;
-  op1 = a;			// base
-  op2 = b;			// limit
-  op3 = (tree_expression *) NULL;	// increment if not empty.
+  op1 = a;	// base
+  op2 = b;	// limit
+  op3 = 0;	// increment if not empty.
   line_num = l;
   column_num = c;
 }
 
 tree_colon_expression::~tree_colon_expression (void)
 {
   delete op1;
   delete op2;
   delete op3;
 }
 
 tree_colon_expression *
 tree_colon_expression::chain (tree_expression *t)
 {
-  tree_colon_expression *retval = (tree_colon_expression *) NULL;
-  if (op1 == NULL_TREE || op3 != NULL_TREE)
+  tree_colon_expression *retval = 0;
+  if (! op1 || op3)
     ::error ("invalid colon expression");
   else
     {
       op3 = op2;	// Stupid syntax.
       op2 = t;
 
       retval = this;
     }
   return retval;
 }
 
 tree_constant
 tree_colon_expression::eval (int print)
 {
   tree_constant retval;
 
-  if (error_state || op1 == NULL_TREE || op2 == NULL_TREE) 
+  if (error_state || ! op1 || ! op2)
     return retval;
 
   tree_constant tmp;
 
   tmp = op1->eval (0);
 
   if (tmp.is_undefined ())
     {
@@ -2446,17 +2473,17 @@ tree_colon_expression::eval (int print)
       && tmp.const_type () != tree_constant_rep::complex_scalar_constant)
     {
       eval_error ("limit for colon expression must be a scalar");
       return retval;
     }
   double limit = tmp.double_value ();
 
   double inc = 1.0;
-  if (op3 != NULL_TREE)
+  if (op3)
     {
       tmp = op3->eval (0);
 
       if (tmp.is_undefined ())
 	{
 	  eval_error ("invalid null value in colon expression");
 	  return retval;
 	}
@@ -2489,39 +2516,39 @@ tree_colon_expression::eval_error (const
 {
   if (error_state > 0)
     ::error ("%s near line %d column %d", s, line (), column ());
 }
 
 /*
  * Index expressions.
  */
-tree_index_expression::tree_index_expression (int l = -1, int c = -1)
+tree_index_expression::tree_index_expression (int l, int c)
 {
-  id = (tree_identifier *) NULL;
-  list = (tree_argument_list *) NULL;
+  id = 0;
+  list = 0;
   line_num = l;
   column_num = c;
 }
 
 tree_index_expression::tree_index_expression (tree_identifier *i,
 					      tree_argument_list *lst,
-					      int l = -1, int c = -1)
+					      int l, int c)
 {
   id = i;
   list = lst;
   line_num = l;
   column_num = c;
 }
 
 tree_index_expression::tree_index_expression (tree_identifier *i,
-					      int l = -1, int c = -1)
+					      int l, int c)
 {
   id = i;
-  list = (tree_argument_list *) NULL;
+  list = 0;
   line_num = l;
   column_num = c;
 }
 
 tree_index_expression::~tree_index_expression (void)
 {
   delete id;
   delete list;
@@ -2555,23 +2582,17 @@ tree_index_expression::mark_for_possible
 tree_constant
 tree_index_expression::eval (int print)
 {
   tree_constant retval;
 
   if (error_state)
     return retval;
 
-  if (list == (tree_argument_list *) NULL)
-    {
-      retval = id->eval (print);
-      if (error_state)
-	eval_error ();
-    }
-  else
+  if (list)
     {
 // Extract the arguments into a simple vector.
       Octave_object args = list->convert_to_const_vector ();
 // Don't pass null arguments.
       int nargin = args.length ();
       if (error_state)
 	eval_error ();
       else if (nargin > 1 && all_args_defined (args))
@@ -2580,91 +2601,99 @@ tree_index_expression::eval (int print)
 
 	  if (error_state)
 	    eval_error ();
 
 	  if (tmp.length () > 0)
 	    retval = tmp(0);
 	}
     }
+  else
+    {
+      retval = id->eval (print);
+      if (error_state)
+	eval_error ();
+    }
+
   return retval;
 }
 
 Octave_object
 tree_index_expression::eval (int print, int nargout, const Octave_object& args)
 {
   Octave_object retval;
 
   if (error_state)
     return retval;
 
-  if (list == (tree_argument_list *) NULL)
-    {
-      Octave_object tmp_args;
-      retval = id->eval (print, nargout, tmp_args);
-      if (error_state)
-	eval_error ();
-    }
-  else
+  if (list)
     {
 // Extract the arguments into a simple vector.
       Octave_object args = list->convert_to_const_vector ();
 // Don't pass null arguments.
       if (error_state)
 	eval_error ();
       else if (args.length () > 1 && all_args_defined (args))
 	{
 	  retval = id->eval (print, nargout, args);
 	  if (error_state)
 	    eval_error ();
 	}
     }
+  else
+    {
+      Octave_object tmp_args;
+      retval = id->eval (print, nargout, tmp_args);
+      if (error_state)
+	eval_error ();
+    }
+
   return retval;
 }
 
 void
 tree_index_expression::eval_error (void)
 {
   if (error_state > 0)
     {
       int l = line ();
       int c = column ();
       char *fmt;
       if (l != -1 && c != -1)
 	{
-	  if (list != (tree_argument_list *) NULL)
+	  if (list)
 	    fmt = "evaluating index expression near line %d, column %d";
 	  else
 	    fmt = "evaluating expression near line %d, column %d";
 
 	  ::error (fmt, l, c);
 	}
       else
 	{
-	  if (list != (tree_argument_list *) NULL)
+	  if (list)
 	    ::error ("evaluating index expression");
 	  else
 	    ::error ("evaluating expression");
 	}
     }
 }
 
 /*
  * Argument lists.
  */
 tree_argument_list::tree_argument_list (void)
 {
-  arg = NULL_TREE;
-  next = (tree_argument_list *) NULL;
+  arg = 0;
+  next = 0;
 }
 
 tree_argument_list::tree_argument_list (tree *t)
 {
   arg = t;
-  next = (tree_argument_list *) NULL;
+  next = 0;
 }
 
 tree_argument_list::~tree_argument_list (void)
 {
   delete arg;
   delete next;
 }
 
@@ -2676,34 +2705,34 @@ tree_argument_list::chain (tree *t)
   return tmp;
 }
 
 tree_argument_list *
 tree_argument_list::reverse (void)
 {
   tree_argument_list *list = this;
   tree_argument_list *next;
-  tree_argument_list *prev = (tree_argument_list *) NULL;
-
-  while (list != (tree_argument_list *) NULL)
+  tree_argument_list *prev = 0;
+
+  while (list)
     {
       next = list->next;
       list->next = prev;
       prev = list;
       list = next;
     }
   return prev;
 }
 
 int
 tree_argument_list::length (void)
 {
   tree_argument_list *list = this;
   int len = 0;
-  while (list != (tree_argument_list *) NULL)
+  while (list)
     {
       len++;
       list = list->next;
     }
   return len;
 }
 
 tree_argument_list *
@@ -2723,17 +2752,17 @@ tree_argument_list::convert_to_const_vec
 
   Octave_object args (len);
 
 // args[0] may eventually hold something useful, like the function
 // name.
   tree_argument_list *tmp_list = this;
   for (int k = 1; k < len; k++)
     {
-      if (tmp_list != (tree_argument_list *) NULL)
+      if (tmp_list)
 	{
 	  args(k) = tmp_list->eval (0);
 	  if (error_state)
 	    {
 	      ::error ("evaluating argument list element number %d", k);
 	      break;
 	    }
 	  tmp_list = tmp_list->next;
@@ -2745,37 +2774,37 @@ tree_argument_list::convert_to_const_vec
 	}
     }
   return args;
 }
 
 tree_constant
 tree_argument_list::eval (int print)
 {
-  if (error_state || arg == NULL_TREE)
+  if (error_state || ! arg)
     return tree_constant ();
   else
     return arg->eval (print);
 }
 
 /*
  * Parameter lists.
  */
 tree_parameter_list::tree_parameter_list (void)
 {
   marked_for_varargs = 0;
-  param = (tree_identifier *) NULL;
-  next = (tree_parameter_list *) NULL;
+  param = 0;
+  next = 0;
 }
 
 tree_parameter_list::tree_parameter_list (tree_identifier *t)
 {
   marked_for_varargs = 0;
   param = t;
-  next = (tree_parameter_list *) NULL;
+  next = 0;
 }
 
 tree_parameter_list::~tree_parameter_list (void)
 {
   delete param;
   delete next;
 }
 
@@ -2787,34 +2816,34 @@ tree_parameter_list::chain (tree_identif
   return tmp;
 }
 
 tree_parameter_list *
 tree_parameter_list::reverse (void)
 {
   tree_parameter_list *list = this;
   tree_parameter_list *next;
-  tree_parameter_list *prev = (tree_parameter_list *) NULL;
-
-  while (list != (tree_parameter_list *) NULL)
+  tree_parameter_list *prev = 0;
+
+  while (list)
     {
       next = list->next;
       list->next = prev;
       prev = list;
       list = next;
     }
   return prev;
 }
 
 int
 tree_parameter_list::length (void)
 {
   tree_parameter_list *list = this;
   int len = 0;
-  while (list != (tree_parameter_list *) NULL)
+  while (list)
     {
       len++;
       list = list->next;
     }
   return len;
 }
 
 char *
@@ -2822,17 +2851,17 @@ tree_parameter_list::name (void) const
 {
   return param->name ();
 }
 
 void
 tree_parameter_list::mark_as_formal_parameters (void)
 {
   param->mark_as_formal_parameter ();
-  if (next != (tree_parameter_list *) NULL)
+  if (next)
     next->mark_as_formal_parameters ();
 }
 
 void
 tree_parameter_list::mark_varargs (void)
 {
   marked_for_varargs = 1;
 }
@@ -2870,17 +2899,17 @@ tree_parameter_list::define_from_arg_vec
   int nargin = args.length ();
 
   int expected_nargin = length () + 1;
 
   tree_parameter_list *ptr = this;
 
   for (int i = 1; i < expected_nargin; i++)
     {
-      tree_constant *tmp = NULL_TREE_CONST;
+      tree_constant *tmp = 0;
 
       if (i < nargin)
 	{
 	  if (args(i).is_defined ()
 	      && (args(i).const_type () == tree_constant_rep::magic_colon))
 	    {
 	      ::error ("invalid use of colon in function argument list");
 	      return;
@@ -2896,69 +2925,67 @@ tree_parameter_list::define_from_arg_vec
 Octave_object
 tree_parameter_list::convert_to_const_vector (void)
 {
   int nout = length ();
 
   Octave_object retval (nout);
 
   int i = 0;
-
-  tree_parameter_list *elem = this;
-
-  for ( ; elem != (tree_parameter_list *) NULL;	elem = elem->next)
+  
+  for (tree_parameter_list *elem = this; elem; elem = elem->next)
     {
       if (elem->is_defined ())
 	retval(i) = elem->eval (0);
       i++;
     }
 
   return retval;
 }
 
 int
 tree_parameter_list::is_defined (void)
 {
-  return (param != (tree_identifier *) NULL && param->is_defined ());
+  return (param && param->is_defined ());
 }
 
 tree_parameter_list *
 tree_parameter_list::next_elem (void)
 {
   return next;
 }
 
 tree_constant
 tree_parameter_list::eval (int print)
 {
-  if (error_state || param == NULL_TREE)
+  if (error_state || ! param)
     return tree_constant ();
   else
     return param->eval (print);
 }
 
 /*
  * Return lists.
  */
 tree_return_list::tree_return_list (void)
 {
-  retval = (tree_index_expression *) NULL;
-  next = (tree_return_list *) NULL;
+  retval = 0;
+  next = 0;
 }
 
 tree_return_list::tree_return_list (tree_identifier *t)
 {
   retval = new tree_index_expression (t);
-  next = (tree_return_list *) NULL;
+  next = 0;
 }
 
 tree_return_list::tree_return_list (tree_index_expression *t)
 {
   retval = t;
-  next = (tree_return_list *) NULL;
+  next = 0;
 }
 
 tree_return_list::~tree_return_list (void)
 {
   delete retval;
   delete next;
 }
 
@@ -2978,34 +3005,34 @@ tree_return_list::chain (tree_index_expr
   return tmp;
 }
 
 tree_return_list *
 tree_return_list::reverse (void)
 {
   tree_return_list *list = this;
   tree_return_list *next;
-  tree_return_list *prev = (tree_return_list *) NULL;
-
-  while (list != (tree_return_list *) NULL)
+  tree_return_list *prev = 0;
+
+  while (list)
     {
       next = list->next;
       list->next = prev;
       prev = list;
       list = next;
     }
   return prev;
 }
 
 int
 tree_return_list::length (void)
 {
   tree_return_list *list = this;
   int len = 0;
-  while (list != (tree_return_list *) NULL)
+  while (list)
     {
       len++;
       list = list->next;
     }
   return len;
 }
 
 tree_index_expression *
diff --git a/src/pt-exp-base.h b/src/pt-exp-base.h
--- a/src/pt-exp-base.h
+++ b/src/pt-exp-base.h
@@ -1,9 +1,9 @@
-// Tree classes.                                      -*- C++ -*-
+// tree-expr.h                                      -*- C++ -*-
 /*
 
 Copyright (C) 1992, 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -23,29 +23,28 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #if !defined (octave_tree_expr_h)
 #define octave_tree_expr_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
+#include <time.h>
 #include <stdio.h>
 
-#include "builtins.h"
+#include "variables.h"
+#include "mappers.h"
 #include "error.h"
 #include "oct-obj.h"
 
 class tree_constant;
 class symbol_record;
 class symbol_table;
 
-typedef Octave_object (*Text_fcn)(int, char **, int);
-typedef Octave_object (*General_fcn)(const Octave_object&, int);
-
 class tree_matrix;
 class tree_builtin;
 class tree_identifier;
 class tree_function;
 class tree_expression;
 class tree_prefix_expression;
 class tree_postfix_expression;
 class tree_unary_expression;
@@ -346,26 +345,26 @@ public:
     { return 0; }
 
 //  virtual int is_builtin (void) const
 //    { return 0; }
 
   virtual tree_constant assign (tree_constant& t, const Octave_object& args);
 
   virtual char *name (void) const
-    { panic_impossible (); return (char *) NULL; }
+    { panic_impossible (); return 0; }
 
   virtual void bump_value (tree::expression_type)
     { panic_impossible (); }
 
   virtual int max_expected_args (void)
     { panic_impossible (); return 0; }
   
   virtual char *fcn_file_name (void)
-    { return (char *) NULL; }
+    { return 0; }
 
   virtual time_t time_parsed (void)
     { panic_impossible (); return 0; }
 
   virtual int is_system_fcn_file (void) const
     { return 0; }
 
   virtual int save (ostream& os, int mark_as_global = 0,
@@ -375,45 +374,44 @@ public:
 
 /*
  * Builtin functions.
  */
 class
 tree_builtin : public tree_fvc
 {
 public:
-  tree_builtin (const char *nm = (char *) NULL);
+  tree_builtin (const char *nm = 0);
 
   tree_builtin (int i_max, int o_max, Mapper_fcn& m_fcn,
-		const char *nm = (char *) NULL);
+		const char *nm = 0);
 
-  tree_builtin (int i_max, int o_max, Text_fcn t_fcn,
-		const char *nm = (char *) NULL);
-
-  tree_builtin (int i_max, int o_max, General_fcn t_fcn,
-		const char *nm = (char *) NULL);
+  tree_builtin (int i_max, int o_max, Octave_builtin_fcn f,
+		const char *nm = 0);
 
   ~tree_builtin (void);
 
 //  int is_builtin (void) const;
 
+  int is_mapper_function (void) const;
+
   tree_constant eval (int print);
 
   Octave_object eval (int print, int nargout, const Octave_object& args);
 
   char *name (void) const;
 
   int max_expected_args (void);
 
 private:
   int nargin_max;
   int nargout_max;
+  int is_mapper;
   Mapper_fcn mapper_fcn;
-  Text_fcn text_fcn;
-  General_fcn general_fcn;
+  Octave_builtin_fcn fcn;
   char *my_name;
 };
 
 /*
  * Symbols from the symbol table.
  */
 class
 tree_identifier : public tree_fvc
diff --git a/src/sighandlers.cc b/src/sighandlers.cc
--- a/src/sighandlers.cc
+++ b/src/sighandlers.cc
@@ -1,12 +1,12 @@
 // sighandlers.cc                                         -*- C++ -*-
 /*
 
-Copyright (C) 1992, 1993 John W. Eaton
+Copyright (C) 1992, 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 2, or (at your option) any
 later version.
 
@@ -122,17 +122,17 @@ siglost_handler (int i)
 {
   my_friendly_exit ("SIGLOST", i);
 }
 
 static RETSIGTYPE
 sigpipe_handler (int i)
 {
   if (pipe_handler_error_count++ == 0)
-    message ((char *) NULL, "broken pipe");
+    message (0, "broken pipe");
 
 // Don\'t loop forever on account of this.
   if (pipe_handler_error_count  > 100)
     jump_to_top_level ();
 
 #if RETSIGTYPE == void
   return;
 #else
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -20,21 +20,57 @@ along with Octave; see the file COPYING.
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include "config.h"
 #endif
 
+#include <sys/types.h>
+#ifdef HAVE_UNISTD_H
+#include <unistd.h>
+#endif
 #include <math.h>
+#include <stddef.h>
 #include <stdlib.h>
+#include <stdio.h>
 
+#include "tree-const.h"
+#include "octave.h"
+#include "input.h"
+#include "utils.h"
+#include "oct-obj.h"
 #include "error.h"
 #include "sysdep.h"
+#include "defun.h"
+
+extern "C"
+{
+#include <readline/readline.h>
+
+extern char *term_clrpag;
+extern void _rl_output_character_function ();
+
+#if defined (HAVE_TERMIOS_H)
+#include <termios.h>
+#elif defined (HAVE_TERMIO_H)
+#include <termio.h>
+#elif defined (HAVE_SGTTY_H)
+#include <sgtty.h>
+#else
+LOSE! LOSE!
+#endif
+
+extern int ioctl ();
+}
+
+#ifndef STDIN_FILENO
+#define STDIN_FILENO 1
+#endif
 
 // Octave's idea of infinity.
 double octave_Inf;
 
 // Octave's idea of not a number.
 double octave_NaN;
 
 #if defined (__386BSD__) && defined (HAVE_FLOATINGPOINT_H)
@@ -75,37 +111,49 @@ octave_ieee_init (void)
 // trying to make Inf and NaN.
 
 #if defined (HAVE_INFINITY)
   octave_Inf = (double) infinity ();
 #else
 #ifdef linux
   octave_Inf = HUGE_VAL;
 #else
+#ifdef __alpha__
+  extern unsigned int DINFINITY[2];
+  octave_Inf =  (*((double *) (DINFINITY)));
+#else
   double tmp = 1e+10;
   octave_Inf = tmp;
   for (;;)
     {
       octave_Inf *= 1e+10;
       if (octave_Inf == tmp)
 	break;
       tmp = octave_Inf;
     }
 #endif
 #endif
+#endif
+
+
 
 #if defined (HAVE_QUIET_NAN)
   octave_NaN = (double) quiet_nan ();
 #else
 #ifdef linux
   octave_NaN = NAN;
 #else
+#ifdef __alpha__
+  extern unsigned int DQNAN[2];
+  octave_NaN = (*((double *) (DQNAN)));
+#else
   octave_NaN = octave_Inf / octave_Inf;
 #endif
 #endif
+#endif
 
 #else
 
 // This is sort of cheesy, but what can we do, other than blowing it
 // off completely, or writing an entire IEEE emulation package?
 
   octave_Inf = DBL_MAX;
   octave_NaN = DBL_MAX;
@@ -153,13 +201,296 @@ sysdep_init (void)
 #ifdef NeXT
   NeXT_init ();
 #endif
 
   octave_ieee_init ();
 }
 
 /*
+ * Set terminal in raw mode.  From less-177.
+ *
+ * Change terminal to "raw mode", or restore to "normal" mode.
+ * "Raw mode" means 
+ *	1. An outstanding read will complete on receipt of a single keystroke.
+ *	2. Input is not echoed.  
+ *	3. On output, \n is mapped to \r\n.
+ *	4. \t is NOT expanded into spaces.
+ *	5. Signal-causing characters such as ctrl-C (interrupt),
+ *	   etc. are NOT disabled.
+ * It doesn't matter whether an input \n is mapped to \r, or vice versa.
+ */
+void
+raw_mode (int on)
+{
+  static int curr_on = 0;
+
+  int tty_fd = STDIN_FILENO;
+  if (! isatty (tty_fd))
+    {
+      if (interactive)
+	error ("stdin is not a tty!");
+      return;
+    }
+
+  if (on == curr_on)
+    return;
+
+#if defined (HAVE_TERMIOS_H)
+  {
+    struct termios s;
+    static struct termios save_term;
+
+    if (on)
+      {
+// Get terminal modes.
+
+	tcgetattr (tty_fd, &s);
+
+// Save modes and set certain variables dependent on modes.
+
+	save_term = s;
+//	ospeed = s.c_cflag & CBAUD;
+//	erase_char = s.c_cc[VERASE];
+//	kill_char = s.c_cc[VKILL];
+
+// Set the modes to the way we want them.
+
+	s.c_lflag &= ~(ICANON|ECHO|ECHOE|ECHOK|ECHONL);
+	s.c_oflag |=  (OPOST|ONLCR);
+#if defined (OCRNL)
+	s.c_oflag &= ~(OCRNL);
+#endif
+#if defined (ONOCR)
+	s.c_oflag &= ~(ONOCR);
+#endif
+#if defined (ONLRET)
+	s.c_oflag &= ~(ONLRET);
+#endif
+	s.c_cc[VMIN] = 1;
+	s.c_cc[VTIME] = 0;
+      }      
+    else
+      {
+// Restore saved modes.
+	s = save_term;
+      }
+    tcsetattr (tty_fd, TCSAFLUSH, &s);
+  }
+#elif defined (HAVE_TERMIO_H)
+  {
+    struct termio s;
+    static struct termio save_term;
+
+    if (on)
+      {
+// Get terminal modes.
+
+	ioctl (tty_fd, TCGETA, &s);
+
+// Save modes and set certain variables dependent on modes.
+
+	save_term = s;
+//	ospeed = s.c_cflag & CBAUD;
+//	erase_char = s.c_cc[VERASE];
+//	kill_char = s.c_cc[VKILL];
+
+// Set the modes to the way we want them.
+
+	s.c_lflag &= ~(ICANON|ECHO|ECHOE|ECHOK|ECHONL);
+	s.c_oflag |=  (OPOST|ONLCR);
+#if defined (OCRNL)
+	s.c_oflag &= ~(OCRNL);
+#endif
+#if defined (ONOCR)
+	s.c_oflag &= ~(ONOCR);
+#endif
+#if defined (ONLRET)
+	s.c_oflag &= ~(ONLRET);
+#endif
+	s.c_cc[VMIN] = 1;
+	s.c_cc[VTIME] = 0;
+      }      
+    else
+      {
+// Restore saved modes.
+	s = save_term;
+      }
+    ioctl (tty_fd, TCSETAW, &s);
+  }
+#elif defined (HAVE_SGTTY_H)
+  {
+    struct sgttyb s;
+    static struct sgttyb save_term;
+
+    if (on)
+      {
+// Get terminal modes.
+
+	ioctl (tty_fd, TIOCGETP, &s);
+
+// Save modes and set certain variables dependent on modes.
+
+	save_term = s;
+//	ospeed = s.sg_ospeed;
+//	erase_char = s.sg_erase;
+//	kill_char = s.sg_kill;
+
+// Set the modes to the way we want them.
+
+	s.sg_flags |= CBREAK;
+	s.sg_flags &= ~(ECHO);
+      } 
+    else
+      {
+// Restore saved modes.
+	s = save_term;
+      }
+    ioctl (tty_fd, TIOCSETN, &s);
+  }
+#else
+LOSE! LOSE!
+#endif
+
+  curr_on = on;
+}
+
+/*
+ * Read one character from the terminal.
+ */
+int
+kbhit (void)
+{
+  int c;
+  raw_mode (1);
+  c = cin.get ();
+  raw_mode (0);
+  return c;
+}
+
+DEFUN ("clc", Fclc, Sclc, 1, 0,
+  "clc (): clear screen")
+{
+  Octave_object retval;
+
+  rl_beg_of_line ();
+  rl_kill_line (1);
+
+#if ! defined (_GO32_)
+  if (term_clrpag)
+    tputs (term_clrpag, 1, _rl_output_character_function);
+  else
+    crlf ();
+#else
+  crlf ();
+#endif
+
+  fflush (rl_outstream);
+
+  return retval;
+}
+
+DEFUN ("getenv", Fgetenv, Sgetenv, 2, 1,
+  "getenv (STRING): get environment variable values")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin == 2 && args(1).is_string_type ())
+    {
+      char *value = getenv (args(1).string_value ());
+      if (value)
+	retval = value;
+      else
+	retval = "";
+    }
+  else
+    print_usage ("getenv");
+
+  return retval;
+}
+
+DEFALIAS (home, clc)
+
+DEFUN ("kbhit", Fkbhit, Skbhit, 1, 1,
+  "kbhit: get a single character from the terminal")
+{
+  Octave_object retval;
+
+// XXX FIXME XXX -- add timeout and default value args?
+
+  if (interactive)
+    {
+      int c = kbhit ();
+      char *s = new char [2];
+      s[0] = c;
+      s[1] = '\0';
+      retval = s;
+    }
+
+  return retval;
+}
+
+DEFUN ("pause", Fpause, Spause, 1, 1,
+  "pause (seconds): suspend program execution")
+{
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (! (nargin == 1 || nargin == 2))
+    {
+      print_usage ("pause");
+      return retval;
+    }
+
+  if (interactive)
+    {
+      switch (nargin)
+	{
+	case 2:
+	  {
+	    int delay = NINT (args(1).double_value ());
+	    if (delay > 0)
+	      {
+		sleep (delay);
+		break;
+	      }
+	  }
+	default:
+	  if (kbhit () == EOF)
+	    clean_up_and_exit (0);
+	  break;
+	}
+    }
+
+  return retval;
+}
+
+#if !defined (HAVE_GETHOSTNAME) && defined (HAVE_SYS_UTSNAME_H)
+extern "C"
+{
+#include <sys/utsname.h>
+int
+gethostname (char *name, int namelen)
+{
+  int i;
+  struct utsname ut;
+
+  --namelen;
+
+  uname (&ut);
+  i = strlen (ut.nodename) + 1;
+  strncpy (name, ut.nodename, i < namelen ? i : namelen);
+  name[namelen] = '\0';
+
+  return 0;
+}
+}
+#endif
+
+/*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/sysdep.h b/src/sysdep.h
--- a/src/sysdep.h
+++ b/src/sysdep.h
@@ -21,16 +21,25 @@ Software Foundation, 675 Mass Ave, Cambr
 
 */
 
 #if !defined (octave_sysdep_h)
 #define octave_sysdep_h 1
 
 extern void sysdep_init (void);
 
+extern void raw_mode (int);
+extern int kbhit (void);
+
+
+extern "C"
+{
+extern int gethostname ();
+}
+
 // Octave's idea of infinity.
 extern double octave_Inf;
 
 // Octave's idea of not a number.
 extern double octave_NaN;
 
 #endif
 
diff --git a/src/tc-rep.cc b/src/tc-rep.cc
--- a/src/tc-rep.cc
+++ b/src/tc-rep.cc
@@ -1,9 +1,9 @@
-// The constants for the tree class.                      -*- C++ -*-
+// tc-rep.cc                                            -*- C++ -*-
 /*
 
 Copyright (C) 1992, 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -651,17 +651,17 @@ tree_constant_rep::maybe_resize (int i, 
 	  if (j > nc)
 	    ::error ("column index = %d exceeds max column dimension = %d",
 		     j, nc);
 	}
     }
 }
 
 void
-tree_constant_rep::maybe_resize (int i, force_orient f_orient = no_orient)
+tree_constant_rep::maybe_resize (int i, force_orient f_orient)
 {
   int nr = rows ();
   int nc = columns ();
 
   i++;
 
   assert (i >= 0 && (nr <= 1 || nc <= 1));
 
@@ -811,17 +811,17 @@ tree_constant_rep::to_matrix (void) cons
       break;
     default:
       break;
     }
   return retval;
 }
 
 tree_constant_rep::constant_type
-tree_constant_rep::force_numeric (int force_str_conv = 0)
+tree_constant_rep::force_numeric (int force_str_conv)
 {
   switch (type_tag)
     {
     case scalar_constant:
     case matrix_constant:
     case complex_scalar_constant:
     case complex_matrix_constant:
       break;
@@ -882,17 +882,17 @@ tree_constant_rep::force_numeric (int fo
     default:
       panic_impossible ();
       break;
     }
   return type_tag;
 }
 
 tree_constant
-tree_constant_rep::make_numeric (int force_str_conv = 0) const
+tree_constant_rep::make_numeric (int force_str_conv) const
 {
   tree_constant retval;
   switch (type_tag)
     {
     case scalar_constant:
       retval = tree_constant (scalar);
       break;
     case matrix_constant:
@@ -1483,20 +1483,20 @@ tree_constant_rep::load (istream& is)
   int is_global = 0;
 
   type_tag = unknown_constant;
 
 // Look for type keyword
 
   char *tag = extract_keyword (is, "type");
 
-  if (tag != (char *) NULL && *tag != '\0')
+  if (tag && *tag)
     {
       char *ptr = strchr (tag, ' ');
-      if (ptr != (char *) NULL)
+      if (ptr)
 	{
 	  *ptr = '\0';
 	  is_global = (strncmp (tag, "global", 6) == 0);
 	  *ptr = ' ';
 	  if (is_global)
 	    ptr++;
 	  else
 	    ptr = tag;
@@ -2562,84 +2562,84 @@ tree_constant_rep::mapper (Mapper_fcn& m
 
   switch (type_tag)
     {
     case scalar_constant:
       if (m_fcn.can_return_complex_for_real_arg
 	  && (scalar < m_fcn.lower_limit
 	      || scalar > m_fcn.upper_limit))
 	{
-	  if (m_fcn.c_c_mapper != NULL)
+	  if (m_fcn.c_c_mapper)
 	    {
 	      Complex c = m_fcn.c_c_mapper (Complex (scalar));
 	      retval = tree_constant (c);
 	    }
 	  else
 	    panic_impossible ();
 	}
       else
 	{
-	  if (m_fcn.d_d_mapper != NULL)
+	  if (m_fcn.d_d_mapper)
 	    {
 	      double d = m_fcn.d_d_mapper (scalar);
 	      retval = tree_constant (d);
 	    }
 	  else
 	    panic_impossible ();
 	}
       break;
     case matrix_constant:
       if (m_fcn.can_return_complex_for_real_arg
 	  && (any_element_less_than (*matrix, m_fcn.lower_limit)
 	      || any_element_greater_than (*matrix, m_fcn.upper_limit)))
 	{
-	  if (m_fcn.c_c_mapper != NULL)
+	  if (m_fcn.c_c_mapper)
 	    {
 	      ComplexMatrix cm = map (m_fcn.c_c_mapper,
 				      ComplexMatrix (*matrix));
 	      retval = tree_constant (cm);
 	    }
 	  else
 	    panic_impossible ();
 	}
       else
 	{
-	  if (m_fcn.d_d_mapper != NULL)
+	  if (m_fcn.d_d_mapper)
 	    {
 	      Matrix m = map (m_fcn.d_d_mapper, *matrix);
 	      retval = tree_constant (m);
 	    }
 	  else
 	    panic_impossible ();
 	}
       break;
     case complex_scalar_constant:
-      if (m_fcn.d_c_mapper != NULL)
+      if (m_fcn.d_c_mapper)
 	{
 	  double d;
 	  d = m_fcn.d_c_mapper (*complex_scalar);
 	  retval = tree_constant (d);
 	}
-      else if (m_fcn.c_c_mapper != NULL)
+      else if (m_fcn.c_c_mapper)
 	{
 	  Complex c;
 	  c = m_fcn.c_c_mapper (*complex_scalar);
 	  retval = tree_constant (c);
 	}
       else
 	panic_impossible ();
       break;
     case complex_matrix_constant:
-      if (m_fcn.d_c_mapper != NULL)
+      if (m_fcn.d_c_mapper)
 	{
 	  Matrix m;
 	  m = map (m_fcn.d_c_mapper, *complex_matrix);
 	  retval = tree_constant (m);
 	}
-      else if (m_fcn.c_c_mapper != NULL)
+      else if (m_fcn.c_c_mapper)
 	{
 	  ComplexMatrix cm;
 	  cm = map (m_fcn.c_c_mapper, *complex_matrix);
 	  retval = tree_constant (cm);
 	}
       else
 	panic_impossible ();
       break;
@@ -2654,17 +2654,17 @@ tree_constant_rep::mapper (Mapper_fcn& m
 }
 
 /*
  * Top-level tree-constant function that handles assignments.  Only
  * decide if the left-hand side is currently a scalar or a matrix and
  * hand off to other functions to do the real work.
  */
 void
-tree_constant_rep::assign (tree_constant& rhs, const Octave_object& args)
+tree_constant_rep::assign (const tree_constant& rhs, const Octave_object& args)
 {
   tree_constant rhs_tmp = rhs.make_numeric ();
 
 // This is easier than actually handling assignments to strings.
 // An assignment to a range will normally require a conversion to a
 // vector since it will normally destroy the equally-spaced property
 // of the range elements.
 
@@ -2693,17 +2693,17 @@ tree_constant_rep::assign (tree_constant
     }
 }
 
 /*
  * Assignments to scalars.  If resize_on_range_error is true,
  * this can convert the left-hand side to a matrix.
  */
 void
-tree_constant_rep::do_scalar_assignment (tree_constant& rhs,
+tree_constant_rep::do_scalar_assignment (const tree_constant& rhs,
 					 const Octave_object& args)
 {
   assert (type_tag == unknown_constant
 	  || type_tag == scalar_constant
 	  || type_tag == complex_scalar_constant);
 
   int nargin = args.length ();
 
@@ -2800,17 +2800,17 @@ tree_constant_rep::do_scalar_assignment 
 
 /*
  * Assignments to matrices (and vectors).
  *
  * For compatibility with Matlab, we allow assignment of an empty
  * matrix to an expression with empty indices to do nothing.
  */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
 					 const Octave_object& args)
 {
   assert (type_tag == unknown_constant
 	  || type_tag == matrix_constant
 	  || type_tag == complex_matrix_constant);
 
   if (type_tag == matrix_constant && rhs.is_complex_type ())
     {
@@ -2873,18 +2873,18 @@ tree_constant_rep::do_matrix_assignment 
       break;
     }
 }
 
 /*
  * Matrix assignments indexed by a single value.
  */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
-					 tree_constant& i_arg)
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
+					 const tree_constant& i_arg)
 {
   int nr = rows ();
   int nc = columns ();
 
   if (user_pref.do_fortran_indexing || nr <= 1 || nc <= 1)
     {
       if (i_arg.is_empty ())
 	{
@@ -2919,18 +2919,18 @@ tree_constant_rep::do_matrix_assignment 
 }
 
 /*
  * Fortran-style assignments.  Matrices are assumed to be stored in
  * column-major order and it is ok to use a single index for
  * multi-dimensional matrices.
  */
 void
-tree_constant_rep::fortran_style_matrix_assignment (tree_constant& rhs,
-						    tree_constant& i_arg)
+tree_constant_rep::fortran_style_matrix_assignment (const tree_constant& rhs,
+						    const tree_constant& i_arg)
 {
   tree_constant tmp_i = i_arg.make_numeric_or_magic ();
 
   tree_constant_rep::constant_type itype = tmp_i.const_type ();
 
   int nr = rows ();
   int nc = columns ();
 
@@ -3082,17 +3082,17 @@ tree_constant_rep::fortran_style_matrix_
       break;
     }
 }
 
 /*
  * Fortran-style assignment for vector index.
  */
 void
-tree_constant_rep::fortran_style_matrix_assignment (tree_constant& rhs,
+tree_constant_rep::fortran_style_matrix_assignment (const tree_constant& rhs,
 						    idx_vector& i)
 {
   assert (rhs.is_matrix_type ());
 
   int ilen = i.capacity ();
 
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
@@ -3128,17 +3128,17 @@ tree_constant_rep::fortran_style_matrix_
     ::error ("number of rows and columns must match for indexed assignment");
 }
 
 /*
  * Fortran-style assignment for colon index.
  */
 void
 tree_constant_rep::fortran_style_matrix_assignment
-  (tree_constant& rhs, tree_constant_rep::constant_type mci)
+  (const tree_constant& rhs, tree_constant_rep::constant_type mci)
 {
   assert (rhs.is_matrix_type () && mci == tree_constant_rep::magic_colon);
 
   int nr = rows ();
   int nc = columns ();
 
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
@@ -3177,17 +3177,18 @@ tree_constant_rep::fortran_style_matrix_
 }
 
 /*
  * Assignments to vectors.  Hand off to other functions once we know
  * what kind of index we have.  For a colon, it is the same as
  * assignment to a matrix indexed by two colons.
  */
 void
-tree_constant_rep::vector_assignment (tree_constant& rhs, tree_constant& i_arg)
+tree_constant_rep::vector_assignment (const tree_constant& rhs,
+				      const tree_constant& i_arg)
 {
   int nr = rows ();
   int nc = columns ();
 
   assert ((nr == 1 || nc == 1 || (nr == 0 && nc == 0))
 	  && ! user_pref.do_fortran_indexing);
 
   tree_constant tmp_i = i_arg.make_numeric_or_range_or_magic ();
@@ -3296,17 +3297,17 @@ tree_constant_rep::check_vector_assign (
   else
     panic_impossible ();
 }
 
 /*
  * Assignment to a vector with an integer index.
  */
 void
-tree_constant_rep::do_vector_assign (tree_constant& rhs, int i)
+tree_constant_rep::do_vector_assign (const tree_constant& rhs, int i)
 {
   int rhs_nr = rhs.rows ();
   int rhs_nc = rhs.columns ();
 
   if (indexed_assign_conforms (1, 1, rhs_nr, rhs_nc))
     {
       maybe_resize (i);
       if (error_state)
@@ -3354,17 +3355,18 @@ tree_constant_rep::do_vector_assign (tre
       return;
     }
 }
 
 /*
  * Assignment to a vector with a vector index.
  */
 void
-tree_constant_rep::do_vector_assign (tree_constant& rhs, idx_vector& iv)
+tree_constant_rep::do_vector_assign (const tree_constant& rhs,
+				     idx_vector& iv)
 {
   if (rhs.is_zero_by_zero ())
     {
       int nr = rows ();
       int nc = columns ();
 
       int len = MAX (nr, nc);
 
@@ -3459,17 +3461,18 @@ tree_constant_rep::do_vector_assign (tre
   else
     panic_impossible ();
 }
 
 /*
  * Assignment to a vector with a range index.
  */
 void
-tree_constant_rep::do_vector_assign (tree_constant& rhs, Range& ri)
+tree_constant_rep::do_vector_assign (const tree_constant& rhs,
+				     Range& ri)
 {
   if (rhs.is_zero_by_zero ())
     {
       int nr = rows ();
       int nc = columns ();
 
       int len = MAX (nr, nc);
 
@@ -3568,19 +3571,19 @@ tree_constant_rep::do_vector_assign (tre
  *   M (range,   arg2) = RHS  (MA3)
  *   M (colon,   arg2) = RHS  (MA4)
  *
  * Each of those functions determines the type of the second argument
  * and calls another function to handle the real work of doing the
  * assignment.
  */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
-					 tree_constant& i_arg,
-					 tree_constant& j_arg)
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
+					 const tree_constant& i_arg,
+					 const tree_constant& j_arg)
 {
   tree_constant tmp_i = i_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type itype = tmp_i.const_type ();
 
   switch (itype)
     {
     case complex_scalar_constant:
@@ -3632,18 +3635,18 @@ tree_constant_rep::do_matrix_assignment 
     default:
       panic_impossible ();
       break;
     }
 }
 
 /* MA1 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs, int i,
-					 tree_constant& j_arg)
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs, int i,
+					 const tree_constant& j_arg)
 {
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type jtype = tmp_j.const_type ();
 
   int rhs_nr = rhs.rows ();
   int rhs_nc = rhs.columns ();
 
@@ -3770,18 +3773,19 @@ tree_constant_rep::do_matrix_assignment 
     default:
       panic_impossible ();
       break;
     }
 }
 
 /* MA2 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs, idx_vector& iv,
-					 tree_constant& j_arg)
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
+					 idx_vector& iv,
+					 const tree_constant& j_arg)
 {
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type jtype = tmp_j.const_type ();
 
   int rhs_nr = rhs.rows ();
   int rhs_nc = rhs.columns ();
 
@@ -3902,18 +3906,19 @@ tree_constant_rep::do_matrix_assignment 
     default:
       panic_impossible ();
       break;
     }
 }
 
 /* MA3 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
-					 Range& ri, tree_constant& j_arg)
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
+					 Range& ri,
+					 const tree_constant& j_arg)
 {
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type jtype = tmp_j.const_type ();
 
   int rhs_nr = rhs.rows ();
   int rhs_nc = rhs.columns ();
 
@@ -4039,19 +4044,19 @@ tree_constant_rep::do_matrix_assignment 
     default:
       panic_impossible ();
       break;
     }
 }
 
 /* MA4 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
 					 tree_constant_rep::constant_type i,
-					 tree_constant& j_arg)
+					 const tree_constant& j_arg)
 {
   tree_constant tmp_j = j_arg.make_numeric_or_range_or_magic ();
 
   tree_constant_rep::constant_type jtype = tmp_j.const_type ();
 
   int rhs_nr = rhs.rows ();
   int rhs_nc = rhs.columns ();
 
@@ -4222,37 +4227,39 @@ tree_constant_rep::do_matrix_assignment 
  *   range    | 3 | 7 | 11 | 15 |
  *   ---------+---+---+----+----+
  *   colon    | 4 | 8 | 12 | 16 |
  *   ---------+---+---+----+----+
  */
 
 /* 1 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs, int i, int j)
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
+					 int i, int j)
 {
   REP_ELEM_ASSIGN (i, j, rhs.double_value (), rhs.complex_value (),
 		   rhs.is_real_type ());
 }
 
 /* 2 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs, int i,
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs, int i,
 					 idx_vector& jv)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   for (int j = 0; j < jv.capacity (); j++)
     REP_ELEM_ASSIGN (i, jv.elem (j), rhs_m.elem (0, j),
 		     rhs_cm.elem (0, j), rhs.is_real_type ());
 }
 
 /* 3 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs, int i, Range& rj)
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
+					 int i, Range& rj)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   double b = rj.base ();
   double increment = rj.inc ();
 
   for (int j = 0; j < rj.nelem (); j++)
     {
@@ -4260,17 +4267,17 @@ tree_constant_rep::do_matrix_assignment 
       int col = tree_to_mat_idx (tmp);
       REP_ELEM_ASSIGN (i, col, rhs_m.elem (0, j), rhs_cm.elem (0, j),
 		       rhs.is_real_type ());
     }
 }
 
 /* 4 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs, int i,
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs, int i,
 					 tree_constant_rep::constant_type mcj)
 {
   assert (mcj == magic_colon);
 
   int nc = columns ();
 
   if (rhs.is_zero_by_zero ())
     {
@@ -4290,33 +4297,34 @@ tree_constant_rep::do_matrix_assignment 
 		       rhs.complex_value (), rhs.is_real_type ());
     }
   else
     panic_impossible ();
 }
 
 /* 5 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
 					 idx_vector& iv, int j)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   for (int i = 0; i < iv.capacity (); i++)
     {
       int row = iv.elem (i);
       REP_ELEM_ASSIGN (row, j, rhs_m.elem (i, 0),
 		       rhs_cm.elem (i, 0), rhs.is_real_type ());
     }
 }
 
 /* 6 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
-					 idx_vector& iv, idx_vector& jv)
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
+					 idx_vector& iv,
+					 idx_vector& jv)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   for (int i = 0; i < iv.capacity (); i++)
     {
       int row = iv.elem (i);
       for (int j = 0; j < jv.capacity (); j++)
 	{
@@ -4324,18 +4332,19 @@ tree_constant_rep::do_matrix_assignment 
 	  REP_ELEM_ASSIGN (row, col, rhs_m.elem (i, j),
 			   rhs_cm.elem (i, j), rhs.is_real_type ());
 	}
     }
 }
 
 /* 7 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
-					 idx_vector& iv, Range& rj)
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
+					 idx_vector& iv,
+					 Range& rj)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   double b = rj.base ();
   double increment = rj.inc ();
 
   for (int i = 0; i < iv.capacity (); i++)
     {
@@ -4347,17 +4356,18 @@ tree_constant_rep::do_matrix_assignment 
 	  REP_ELEM_ASSIGN (row, col, rhs_m.elem (i, j),
 			   rhs_cm.elem (i, j), rhs.is_real_type ());
 	}
     }
 }
 
 /* 8 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs, idx_vector& iv,
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
+					 idx_vector& iv,
 					 tree_constant_rep::constant_type mcj)
 {
   assert (mcj == magic_colon);
 
   if (rhs.is_zero_by_zero ())
     {
       delete_rows (iv);
     }
@@ -4376,17 +4386,18 @@ tree_constant_rep::do_matrix_assignment 
 			       rhs_cm.elem (i, j), rhs.is_real_type ());
 	    }
 	}
     }
 }
 
 /* 9 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs, Range& ri, int j)
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
+					 Range& ri, int j)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   double b = ri.base ();
   double increment = ri.inc ();
 
   for (int i = 0; i < ri.nelem (); i++)
     {
@@ -4394,17 +4405,18 @@ tree_constant_rep::do_matrix_assignment 
       int row = tree_to_mat_idx (tmp);
       REP_ELEM_ASSIGN (row, j, rhs_m.elem (i, 0),
 		       rhs_cm.elem (i, 0), rhs.is_real_type ());
     }
 }
 
 /* 10 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs, Range& ri,
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
+					 Range& ri,
 					 idx_vector& jv)
 {
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
 
   double b = ri.base ();
   double increment = ri.inc ();
 
   for (int j = 0; j < jv.capacity (); j++)
@@ -4417,17 +4429,18 @@ tree_constant_rep::do_matrix_assignment 
 	  REP_ELEM_ASSIGN (row, col, rhs_m.elem (i, j),
 			   rhs_m.elem (i, j), rhs.is_real_type ());
 	}
     }
 }
 
 /* 11 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs, Range& ri,
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
+					 Range& ri,
 					 Range& rj)
 {
   double ib = ri.base ();
   double iinc = ri.inc ();
   double jb = rj.base ();
   double jinc = rj.inc ();
 
   REP_RHS_MATRIX (rhs, rhs_m, rhs_cm, rhs_nr, rhs_nc);
@@ -4443,17 +4456,18 @@ tree_constant_rep::do_matrix_assignment 
 	  REP_ELEM_ASSIGN (row, col, rhs_m.elem  (i, j),
 			   rhs_cm.elem (i, j), rhs.is_real_type ());
 	}
     }
 }
 
 /* 12 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs, Range& ri,
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
+					 Range& ri,
 					 tree_constant_rep::constant_type mcj)
 {
   assert (mcj == magic_colon);
 
   if (rhs.is_zero_by_zero ())
     {
       delete_rows (ri);
     }
@@ -4474,17 +4488,17 @@ tree_constant_rep::do_matrix_assignment 
 	    REP_ELEM_ASSIGN (row, j, rhs_m.elem (i, j),
 			     rhs_cm.elem (i, j), rhs.is_real_type ());
 	}
     }
 }
 
 /* 13 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
 					 tree_constant_rep::constant_type mci,
 					 int j)
 {
   assert (mci == magic_colon);
 
   int nr = rows ();
 
   if (rhs.is_zero_by_zero ())
@@ -4505,17 +4519,17 @@ tree_constant_rep::do_matrix_assignment 
 		       rhs.complex_value (), rhs.is_real_type ());
     }
   else
     panic_impossible ();
 }
 
 /* 14 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
 					 tree_constant_rep::constant_type mci,
 					 idx_vector& jv)
 {
   assert (mci == magic_colon);
 
   if (rhs.is_zero_by_zero ())
     {
       delete_columns (jv);
@@ -4535,17 +4549,17 @@ tree_constant_rep::do_matrix_assignment 
 			       rhs_cm.elem (i, j), rhs.is_real_type ());
 	    }
 	}
     }
 }
 
 /* 15 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
 					 tree_constant_rep::constant_type mci,
 					 Range& rj)
 {
   assert (mci == magic_colon);
 
   if (rhs.is_zero_by_zero ())
     {
       delete_columns (rj);
@@ -4569,17 +4583,17 @@ tree_constant_rep::do_matrix_assignment 
 			       rhs_cm.elem (i, j), rhs.is_real_type ());
 	    }
 	}
     }
 }
 
 /* 16 */
 void
-tree_constant_rep::do_matrix_assignment (tree_constant& rhs,
+tree_constant_rep::do_matrix_assignment (const tree_constant& rhs,
 					 tree_constant_rep::constant_type mci,
 					 tree_constant_rep::constant_type mcj)
 {
   assert (mci == magic_colon && mcj == magic_colon);
 
   switch (type_tag)
     {
     case scalar_constant:
@@ -5242,18 +5256,18 @@ tree_constant_rep::fortran_style_matrix_
 
   int len = nr * nc;
 
   int index_nr = mi.rows ();
   int index_nc = mi.columns ();
 
   if (index_nr >= 1 && index_nc >= 1)
     {
-      const double *cop_out = (const double *) NULL;
-      const Complex *c_cop_out = (const Complex *) NULL;
+      const double *cop_out = 0;
+      const Complex *c_cop_out = 0;
       int real_type = type_tag == matrix_constant;
       if (real_type)
 	cop_out = matrix->data ();
       else
 	c_cop_out = complex_matrix->data ();
 
       const double *cop_out_index = mi.data ();
 
@@ -6219,19 +6233,20 @@ tree_constant_rep::do_matrix_index (tree
 
   return retval;
 }
 
 tree_constant
 tree_constant_rep::do_matrix_index (tree_constant_rep::constant_type mci,
 				    tree_constant_rep::constant_type mcj) const
 {
+  tree_constant retval;
   assert (mci == magic_colon && mcj == magic_colon);
-
-  return tree_constant (*this);
+  retval = tree_constant (*this);
+  return retval;
 }
 
 tree_constant
 tree_constant_rep::do_matrix_index
   (tree_constant_rep::constant_type mci) const
 {
   assert (mci == magic_colon);
 
diff --git a/src/tc-rep.h b/src/tc-rep.h
--- a/src/tc-rep.h
+++ b/src/tc-rep.h
@@ -1,9 +1,9 @@
-// The rest of the tree classes.                          -*- C++ -*-
+// tc-rep.h                                             -*- C++ -*-
 /*
 
 Copyright (C) 1992, 1993, 1994 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -32,16 +32,18 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "tree-base.h"
 
 #include "mx-base.h"
 #include "Range.h"
 
 class idx_vector;
 
+struct Mapper_fcn;
+
 /*
  * Forward class declarations.
  */
 class tree;
 class tree_constant;
 
 /*
  * The actual representation of the tree_constant.
@@ -151,74 +153,88 @@ public:
 
   double to_scalar (void) const;
   ColumnVector to_vector (void) const;
   Matrix to_matrix (void) const;
 
   tree_constant_rep::constant_type force_numeric (int force_str_conv = 0);
   tree_constant make_numeric (int force_str_conv = 0) const;
 
-  void assign (tree_constant& rhs, const Octave_object& args);
+  void assign (const tree_constant& rhs, const Octave_object& args);
 
-  void do_scalar_assignment (tree_constant& rhs, const Octave_object& args);
+  void do_scalar_assignment (const tree_constant& rhs,
+			     const Octave_object& args);
 
-  void do_matrix_assignment (tree_constant& rhs, const Octave_object& args);
+  void do_matrix_assignment (const tree_constant& rhs,
+			     const Octave_object& args);
 
-  void do_matrix_assignment (tree_constant& rhs, tree_constant& i_arg);
+  void do_matrix_assignment (const tree_constant& rhs,
+			     const tree_constant& i_arg);
 
-  void do_matrix_assignment
-    (tree_constant& rhs, tree_constant& i_arg, tree_constant& j_arg);
+  void do_matrix_assignment (const tree_constant& rhs,
+			     const tree_constant& i_arg,
+			     const tree_constant& j_arg);
 
-  void fortran_style_matrix_assignment (tree_constant& rhs,
-					tree_constant& i_arg);
+  void fortran_style_matrix_assignment (const tree_constant& rhs,
+					const tree_constant& i_arg);
 
-  void fortran_style_matrix_assignment (tree_constant& rhs, constant_type ci);
+  void fortran_style_matrix_assignment (const tree_constant& rhs,
+					constant_type ci);
 
-  void fortran_style_matrix_assignment (tree_constant& rhs, idx_vector& i);
+  void fortran_style_matrix_assignment (const tree_constant& rhs,
+					idx_vector& i);
 
-  void vector_assignment (tree_constant& rhs, tree_constant& i_arg);
+  void vector_assignment (const tree_constant& rhs,
+			  const tree_constant& i_arg);
 
   void check_vector_assign (int rhs_nr, int rhs_nc, int ilen,
 			    const char *rm);
 
-  void do_vector_assign (tree_constant& rhs, int i);
-  void do_vector_assign (tree_constant& rhs, idx_vector& i);
-  void do_vector_assign (tree_constant& rhs, Range& i);
+  void do_vector_assign (const tree_constant& rhs, int i);
+  void do_vector_assign (const tree_constant& rhs, idx_vector& i);
+  void do_vector_assign (const tree_constant& rhs, Range& i);
+
+  void do_matrix_assignment (const tree_constant& rhs, int i,
+			     const tree_constant& j_arg);
+  void do_matrix_assignment (const tree_constant& rhs, idx_vector& i,
+			     const tree_constant& j_arg);
+  void do_matrix_assignment (const tree_constant& rhs, Range& i,
+			     const tree_constant& j_arg);
+  void do_matrix_assignment (const tree_constant& rhs, constant_type i,
+			     const tree_constant& j_arg);
 
-  void do_matrix_assignment
-    (tree_constant& rhs, int i, tree_constant& j_arg);
-  void do_matrix_assignment
-    (tree_constant& rhs, idx_vector& i, tree_constant& j_arg);
-  void do_matrix_assignment
-    (tree_constant& rhs, Range& i, tree_constant& j_arg);
-  void do_matrix_assignment
-    (tree_constant& rhs, constant_type i, tree_constant& j_arg);
+  void do_matrix_assignment (const tree_constant& rhs, int i, int j);
+  void do_matrix_assignment (const tree_constant& rhs, int i, idx_vector& jv);
+  void do_matrix_assignment (const tree_constant& rhs, int i, Range& j);
+  void do_matrix_assignment (const tree_constant& rhs, int i, constant_type cj);
 
-  void do_matrix_assignment (tree_constant& rhs, int i, int j);
-  void do_matrix_assignment (tree_constant& rhs, int i, idx_vector& jv);
-  void do_matrix_assignment (tree_constant& rhs, int i, Range& j);
-  void do_matrix_assignment (tree_constant& rhs, int i, constant_type cj);
-
-  void do_matrix_assignment (tree_constant& rhs, idx_vector& iv, int j);
-  void do_matrix_assignment (tree_constant& rhs, idx_vector& iv,
+  void do_matrix_assignment (const tree_constant& rhs, idx_vector& iv,
+			     int j);
+  void do_matrix_assignment (const tree_constant& rhs, idx_vector& iv,
 			     idx_vector& jv);
-  void do_matrix_assignment (tree_constant& rhs, idx_vector& iv, Range& j);
-  void do_matrix_assignment (tree_constant& rhs, idx_vector& iv,
+  void do_matrix_assignment (const tree_constant& rhs, idx_vector& iv,
+			     Range& j);
+  void do_matrix_assignment (const tree_constant& rhs, idx_vector& iv,
 			     constant_type j);
 
-  void do_matrix_assignment (tree_constant& rhs, Range& i, int j);
-  void do_matrix_assignment (tree_constant& rhs, Range& i, idx_vector& jv);
-  void do_matrix_assignment (tree_constant& rhs, Range& i, Range& j);
-  void do_matrix_assignment (tree_constant& rhs, Range& i, constant_type j);
+  void do_matrix_assignment (const tree_constant& rhs, Range& i, int j);
+  void do_matrix_assignment (const tree_constant& rhs, Range& i,
+			     idx_vector& jv);
+  void do_matrix_assignment (const tree_constant& rhs, Range& i,
+			     Range& j);
+  void do_matrix_assignment (const tree_constant& rhs, Range& i,
+			     constant_type j);
 
-  void do_matrix_assignment (tree_constant& rhs, constant_type i, int j);
-  void do_matrix_assignment (tree_constant& rhs, constant_type i,
+  void do_matrix_assignment (const tree_constant& rhs, constant_type i, int j);
+  void do_matrix_assignment (const tree_constant& rhs, constant_type i,
 			     idx_vector& jv);
-  void do_matrix_assignment (tree_constant& rhs, constant_type i, Range& j);
-  void do_matrix_assignment (tree_constant& rhs, constant_type i,
+  void do_matrix_assignment (const tree_constant& rhs, constant_type i,
+			     Range& j);
+  void do_matrix_assignment (const tree_constant& rhs,
+			     const constant_type i,
 			     constant_type j);
 
   void delete_row (int);
   void delete_rows (idx_vector& i);
   void delete_rows (Range& i);
 
   void delete_column (int);
   void delete_columns (idx_vector& j);
diff --git a/src/token.cc b/src/token.cc
--- a/src/token.cc
+++ b/src/token.cc
@@ -30,56 +30,56 @@ Software Foundation, 675 Mass Ave, Cambr
 #endif
 
 #include <assert.h>
 
 #include "token.h"
 #include "utils.h"
 #include "symtab.h"
 
-token::token (int l = -1, int c = -1)
+token::token (int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = generic_token;
 }
 
-token::token (char *s, int l = -1, int c = -1)
+token::token (char *s, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = string_token;
   str = strsave (s);
 }
 
-token::token (double d, int l = -1, int c = -1)
+token::token (double d, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = double_token;
   num = d;
 }
 
-token::token (end_tok_type t, int l = -1, int c = -1)
+token::token (end_tok_type t, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = ettype_token;
   et = t;
 }
 
-token::token (plot_tok_type t, int l = -1, int c = -1)
+token::token (plot_tok_type t, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = pttype_token;
   pt = t;
 }
 
-token::token (symbol_record *s, int l = -1, int c = -1)
+token::token (symbol_record *s, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = sym_rec_token;
   sr = s;
 }
 
 token::~token (void)
diff --git a/src/unwind-prot.cc b/src/unwind-prot.cc
--- a/src/unwind-prot.cc
+++ b/src/unwind-prot.cc
@@ -36,31 +36,31 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "CMatrix.h"
 
 #include "unwind-prot.h"
 #include "error.h"
 #include "utils.h"
 
 unwind_elem::unwind_elem (void)
 {
-  unwind_elem_tag = (char *) NULL;
-  unwind_elem_fptr = (cleanup_func) NULL;
-  unwind_elem_ptr = (void *) NULL;
+  unwind_elem_tag = 0;
+  unwind_elem_fptr = 0;
+  unwind_elem_ptr = 0;
 }
 
 unwind_elem::unwind_elem (char *t)
 {
   unwind_elem_tag = strsave (t);
-  unwind_elem_fptr = (cleanup_func) NULL;
-  unwind_elem_ptr = (void *) NULL;
+  unwind_elem_fptr = 0;
+  unwind_elem_ptr = 0;
 }
 
 unwind_elem::unwind_elem (cleanup_func f, void *p)
 {
-  unwind_elem_tag = (char *) NULL;
+  unwind_elem_tag = 0;
   unwind_elem_fptr = f;
   unwind_elem_ptr = p;
 }
 
 unwind_elem::unwind_elem (const unwind_elem& el)
 {
   unwind_elem_tag = strsave (el.unwind_elem_tag);
   unwind_elem_fptr = el.unwind_elem_fptr;
@@ -110,17 +110,17 @@ add_unwind_protect (cleanup_func fptr, v
 }
 
 void
 run_unwind_protect (void)
 {
   unwind_elem el = unwind_protect_list.pop ();
 
   cleanup_func f = el.fptr ();
-  if (f != (cleanup_func) NULL)
+  if (f)
     f (el.ptr ());
 }
 
 void
 discard_unwind_protect (void)
 {
   unwind_protect_list.pop ();
 }
@@ -135,46 +135,46 @@ begin_unwind_frame (char *tag)
 void
 run_unwind_frame (char *tag)
 {
   while (! unwind_protect_list.empty ())
     {
       unwind_elem el = unwind_protect_list.pop ();
 
       cleanup_func f = el.fptr ();
-      if (f != (cleanup_func) NULL)
+      if (f)
 	f (el.ptr ());
 
       char *t = el.tag ();
-      if (t != (char *) NULL && strcmp (t, tag) == 0)
+      if (t && strcmp (t, tag) == 0)
 	break;
     }
 }
 
 void
 discard_unwind_frame (char *tag)
 {
   while (! unwind_protect_list.empty ())
     {
       unwind_elem el = unwind_protect_list.pop ();
       char *t = el.tag ();
-      if (t != (char *) NULL && strcmp (t, tag) == 0)
+      if (t && strcmp (t, tag) == 0)
 	break;
     }
 }
 
 void
 run_all_unwind_protects (void)
 {
   while (! unwind_protect_list.empty ())
     {
       unwind_elem el = unwind_protect_list.pop ();
 
       cleanup_func f = el.fptr ();
-      if (f != (cleanup_func) NULL)
+      if (f)
 	f (el.ptr ());
     }
 }
 
 void
 discard_all_unwind_protects (void)
 {
   unwind_protect_list.clear ();
@@ -220,18 +220,18 @@ class saved_variable
     };
 
   var_type type_tag;
   size_t size;
 };
 
 saved_variable::saved_variable (void)
 {
-  gen_ptr = (void *) NULL;
-  gen_ptr_value = (void *) NULL;
+  gen_ptr = 0;
+  gen_ptr_value = 0;
   type_tag = generic;
   size = 0;
 }
 
 saved_variable::saved_variable (int *p, int v)
 {
   type_tag = integer;
   ptr_to_int = p;
diff --git a/src/unwind-prot.h b/src/unwind-prot.h
--- a/src/unwind-prot.h
+++ b/src/unwind-prot.h
@@ -23,16 +23,18 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #if !defined (octave_unwind_prot_h)
 #define octave_unwind_prot_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
+#include <stddef.h>
+
 typedef void (*cleanup_func)(void *ptr);
 
 void add_unwind_protect (cleanup_func fptr, void *ptr);
 void run_unwind_protect (void);
 void discard_unwind_protect (void);
 void begin_unwind_frame (char *tag);
 void run_unwind_frame (char *tag);
 void discard_unwind_frame (char *tag);
diff --git a/src/user-prefs.cc b/src/user-prefs.cc
--- a/src/user-prefs.cc
+++ b/src/user-prefs.cc
@@ -45,17 +45,17 @@ user_preferences user_pref;
  *   return of  0 => always ok.
  *   return of  1 => never ok.
  */
 static int
 check_str_pref (char *var)
 {
   char *val = builtin_string_variable (var);
   int pref = -1;
-  if (val != (char *) NULL)
+  if (val)
     {
       if (strncmp (val, "yes", 3) == 0
 	  || strncmp (val, "true", 4) == 0)
 	pref = 1;
       else if (strncmp (val, "never", 5) == 0
 	       || strncmp (val, "no", 2) == 0
 	       || strncmp (val, "false", 5) == 0)
 	pref = 0;
@@ -98,17 +98,17 @@ check_str_pref (char *var)
  *
  * will result in a call to `eye' with the argument `2'. 
  */
 int
 commas_in_literal_matrix (void)
 {
   int pref = 0;
   char *val = builtin_string_variable ("commas_in_literal_matrix");
-  if (val != (char *) NULL)
+  if (val)
     {
       if (strncmp (val, "required", 8) == 0)
 	pref = 2;
       else if (strncmp (val, "traditional", 11) == 0)
 	pref = 1;
     }
   user_pref.commas_in_literal_matrix = pref;
   return 0;
@@ -149,17 +149,17 @@ empty_list_elements_ok (void)
  */
 int
 ignore_function_time_stamp (void)
 {
   int pref = 0;
 
   char *val = builtin_string_variable ("ignore_function_time_stamp");
 
-  if (val != (char *) NULL)
+  if (val)
     {
       if (strncmp (val, "all", 3) == 0)
 	pref = 2;
       if (strncmp (val, "system", 6) == 0)
 	pref = 1;
     }
 
   user_pref.ignore_function_time_stamp = pref;
@@ -481,17 +481,17 @@ set_save_precision (void)
 }
 
 int
 sv_editor (void)
 {
   int status = 0;
 
   char *s = builtin_string_variable ("EDITOR");
-  if (s != (char *) NULL)
+  if (s)
     {
       delete [] user_pref.editor;
       user_pref.editor = s;
     }
   else
     {
       warning ("invalid value specified for EDITOR");
       status = -1;
@@ -501,17 +501,17 @@ sv_editor (void)
 }
 
 int
 sv_gnuplot_binary (void)
 {
   int status = 0;
 
   char *s = builtin_string_variable ("gnuplot_binary");
-  if (s != (char *) NULL)
+  if (s)
     {
       delete [] user_pref.gnuplot_binary;
       user_pref.gnuplot_binary = s;
     }
   else
     {
       warning ("invalid value specified for gnuplot_binary");
       status = -1;
@@ -521,17 +521,17 @@ sv_gnuplot_binary (void)
 }
 
 int
 sv_info_file (void)
 {
   int status = 0;
 
   char *s = builtin_string_variable ("INFO_FILE");
-  if (s != (char *) NULL)
+  if (s)
     {
       delete [] user_pref.info_file;
       user_pref.info_file = s;
     }
   else
     {
       warning ("invalid value specified for INFO_FILE");
       status = -1;
@@ -541,17 +541,17 @@ sv_info_file (void)
 }
 
 int
 sv_loadpath (void)
 {
   int status = 0;
 
   char *s = builtin_string_variable ("LOADPATH");
-  if (s != (char *) NULL)
+  if (s)
     {
       delete [] user_pref.loadpath;
       user_pref.loadpath = s;
     }
   else
     {
       warning ("invalid value specified for LOADPATH");
       status = -1;
@@ -561,17 +561,17 @@ sv_loadpath (void)
 }
 
 int
 sv_pager_binary (void)
 {
   int status = 0;
 
   char *s = builtin_string_variable ("PAGER");
-  if (s != (char *) NULL)
+  if (s)
     {
       delete [] user_pref.pager_binary;
       user_pref.pager_binary = s;
     }
   else
     {
       warning ("invalid value specified for PAGER");
       status = -1;
@@ -581,17 +581,17 @@ sv_pager_binary (void)
 }
 
 int
 sv_ps1 (void)
 {
   int status = 0;
 
   char *s = builtin_string_variable ("PS1");
-  if (s != (char *) NULL)
+  if (s)
     {
       delete [] user_pref.ps1;
       user_pref.ps1 = s;
     }
   else
     {
       warning ("invalid value specified for PS1");
       status = -1;
@@ -601,17 +601,17 @@ sv_ps1 (void)
 }
 
 int
 sv_ps2 (void)
 {
   int status = 0;
 
   char *s = builtin_string_variable ("PS2");
-  if (s != (char *) NULL)
+  if (s)
     {
       delete [] user_pref.ps2;
       user_pref.ps2 = s;
     }
   else
     {
       warning ("invalid value specified for PS2");
       status = -1;
@@ -621,17 +621,17 @@ sv_ps2 (void)
 }
 
 int
 sv_pwd (void)
 {
   int status = 0;
 
   char *s = builtin_string_variable ("PWD");
-  if (s != (char *) NULL)
+  if (s)
     {
       delete [] user_pref.pwd;
       user_pref.pwd = s;
     }
   else
     {
       warning ("invalid value specified for PWD");
       status = -1;
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -25,31 +25,47 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "config.h"
 #endif
 
 #include <sys/types.h>
 #ifdef HAVE_UNISTD_H
 #include <unistd.h>
 #endif
 #include <ctype.h>
+#include <float.h>
+#include <string.h>
+#include <fstream.h>
 #include <iostream.h>
 #include <strstream.h>
 
 #include "statdefs.h"
 #include "tree-const.h"
 #include "variables.h"
+#include "mappers.h"
 #include "user-prefs.h"
+#include "version.h"
 #include "symtab.h"
-#include "builtins.h"
-#include "g-builtins.h"
-#include "t-builtins.h"
+#include "defaults.h"
+#include "dirfns.h"
+#include "pager.h"
+#include "sysdep.h"
+#include "octave.h"
+#include "oct-obj.h"
 #include "error.h"
 #include "utils.h"
 #include "tree.h"
 #include "help.h"
+#include "defun.h"
+
+extern "C"
+{
+#include <readline/tilde.h>
+
+#include "fnmatch.h"
+}
 
 // Symbol table for symbols at the top level.
 symbol_table *top_level_sym_tab;
 
 // Symbol table for the current scope.
 symbol_table *curr_sym_tab;
 
 // Symbol table for global symbols.
@@ -72,24 +88,23 @@ initialize_symbol_tables (void)
 int
 symbol_out_of_date (symbol_record *sr)
 {
   int ignore = user_pref.ignore_function_time_stamp;
 
   if (ignore == 2)
     return 0;
 
-  if (sr != (symbol_record *) NULL)
+  if (sr)
     {
       tree_fvc *ans = sr->def ();
-      if (ans != (tree_fvc *) NULL)
+      if (ans)
 	{
 	  char *ff = ans->fcn_file_name ();
-	  if (! (ff == (char *) NULL
-		 || (ignore && ans->is_system_fcn_file ())))
+	  if (ff && ! (ignore && ans->is_system_fcn_file ()))
 	    {
 	      time_t tp = ans->time_parsed ();
 	      char *fname = fcn_file_in_path (ff);
 	      int status = is_newer (fname, tp);
 	      delete [] fname;
 	      if (status > 0)
 		return 1;
 	    }
@@ -103,29 +118,25 @@ document_symbol (const char *name, const
 {
   if (is_builtin_variable (name))
     {
       error ("sorry, can't redefine help for builtin variables");
     }
   else
     {
       symbol_record *sym_rec = curr_sym_tab->lookup (name, 0);
-      if (sym_rec == (symbol_record *) NULL)
-	{
-	  error ("document: no such symbol `%s'", name);
-	}
+      if (sym_rec)
+	sym_rec->document (help);
       else
-	{
-	  sym_rec->document (help);
-	}
+	error ("document: no such symbol `%s'", name);
     }
 }
 
 void
-install_builtin_mapper_function (builtin_mapper_functions *mf)
+install_builtin_mapper (builtin_mapper_function *mf)
 {
   symbol_record *sym_rec = global_sym_tab->lookup (mf->name, 1);
   sym_rec->unprotect ();
 
   Mapper_fcn mfcn;
   mfcn.can_return_complex_for_real_arg = mf->can_return_complex_for_real_arg;
   mfcn.lower_limit = mf->lower_limit;
   mfcn.upper_limit = mf->upper_limit;
@@ -138,66 +149,53 @@ install_builtin_mapper_function (builtin
   sym_rec->define (def);
 
   sym_rec->document (mf->help_string);
   sym_rec->make_eternal ();
   sym_rec->protect ();
 }
 
 void
-install_builtin_text_function (builtin_text_functions *tf)
+install_builtin_function (builtin_function *f)
 {
-  symbol_record *sym_rec = global_sym_tab->lookup (tf->name, 1);
+  symbol_record *sym_rec = global_sym_tab->lookup (f->name, 1);
   sym_rec->unprotect ();
 
-  tree_builtin *def = new tree_builtin (tf->nargin_max, 1,
-					tf->text_fcn, tf->name);
-
-  sym_rec->define (def);
-
-  sym_rec->document (tf->help_string);
-  sym_rec->make_eternal ();
-  sym_rec->protect ();
-
-}
+  tree_builtin *def = new tree_builtin (f->nargin_max, f->nargout_max,
+					f->fcn, f->name);
 
-void
-install_builtin_general_function (builtin_general_functions *gf)
-{
-  symbol_record *sym_rec = global_sym_tab->lookup (gf->name, 1);
-  sym_rec->unprotect ();
+  sym_rec->define (def, f->is_text_fcn);
 
-  tree_builtin *def = new tree_builtin (gf->nargin_max,
-					gf->nargout_max,
-					gf->general_fcn, gf->name);
-
-  sym_rec->define (def);
-
-  sym_rec->document (gf->help_string);
+  sym_rec->document (f->help_string);
   sym_rec->make_eternal ();
   sym_rec->protect ();
 }
 
 void
-install_builtin_variable (builtin_string_variables *sv)
+install_builtin_variable (builtin_variable *v)
 {
-  tree_constant *val = new tree_constant (sv->value);
-
-  bind_builtin_variable (sv->name, val, 0, 1, sv->sv_function,
-			 sv->help_string);
+  if (v->install_as_function)
+    install_builtin_variable_as_function (v->name, v->value, v->protect,
+					  v->eternal, v->help_string);
+  else
+    bind_builtin_variable (v->name, v->value, v->protect, v->eternal,
+			   v->sv_function, v->help_string);
 }
 
 void
 install_builtin_variable_as_function (const char *name, tree_constant *val,
-				      int protect = 0, int eternal = 0)
+				      int protect, int eternal,
+				      const char *help)
 {
   symbol_record *sym_rec = global_sym_tab->lookup (name, 1);
   sym_rec->unprotect ();
 
-  char *tmp_help = sym_rec->help ();
+  const char *tmp_help = help;
+  if (! help)
+    tmp_help = sym_rec->help ();
 
   sym_rec->define_as_fcn (val);
 
   sym_rec->document (tmp_help);
 
   if (protect)
     sym_rec->protect ();
 
@@ -225,26 +223,25 @@ bind_nargin_and_nargout (symbol_table *s
 }
 
 /*
  * Give a global variable a definition.  This will insert the symbol
  * in the global table if necessary.
  */
 void
 bind_builtin_variable (const char *varname, tree_constant *val,
-		       int protect = 0, int eternal = 0,
-		       sv_Function sv_fcn = (sv_Function) 0,
-		       const char *help = (char *) 0)
+		       int protect, int eternal, sv_Function sv_fcn,
+		       const char *help)
 {
   symbol_record *sr = global_sym_tab->lookup (varname, 1, 0);
 
 // It is a programming error for a builtin symbol to be missing.
 // Besides, we just inserted it, so it must be there.
 
-  assert (sr != (symbol_record *) NULL);
+  assert (sr);
 
   sr->unprotect ();
 
 // Must do this before define, since define will call the special
 // variable function only if it knows about it, and it needs to, so
 // that user prefs can be properly initialized.
 
   if (sv_fcn)
@@ -259,39 +256,39 @@ bind_builtin_variable (const char *varna
     sr->make_eternal ();
 
   if (help)
     sr->document (help);    
 }
 
 /*
  * Look for the given name in the global symbol table.  If it refers
- * to a string, return a new copy.  If not, return NULL.
+ * to a string, return a new copy.  If not, return 0;
  */
 char *
 builtin_string_variable (const char *name)
 {
   symbol_record *sr = global_sym_tab->lookup (name, 0, 0);
 
 // It is a prorgramming error to look for builtins that aren't.
 
-  assert (sr != (symbol_record *) NULL);
+  assert (sr);
 
-  char *retval = (char *) NULL;
+  char *retval = 0;
 
   tree_fvc *defn = sr->def ();
 
-  if (defn != (tree_fvc *) NULL)
+  if (defn)
     {
       tree_constant val = defn->eval (0);
 
       if (! error_state && val.is_string_type ())
 	{
 	  char *s = val.string_value ();
-	  if (s != (char *) NULL)
+	  if (s)
 	    retval = strsave (s);
 	}
     }
 
   return retval;
 }
 
 /*
@@ -302,21 +299,21 @@ builtin_string_variable (const char *nam
 int
 builtin_real_scalar_variable (const char *name, double& d)
 {
   int status = -1;
   symbol_record *sr = global_sym_tab->lookup (name, 0, 0);
 
 // It is a prorgramming error to look for builtins that aren't.
 
-  assert (sr != (symbol_record *) NULL);
+  assert (sr);
 
   tree_fvc *defn = sr->def ();
 
-  if (defn != (tree_fvc *) NULL)
+  if (defn)
     {
       tree_constant val = defn->eval (0);
 
       if (! error_state
 	  && val.const_type () == tree_constant_rep::scalar_constant)
 	{
 	  d = val.double_value ();
 	  status = 0;
@@ -346,74 +343,63 @@ link_to_global_variable (symbol_record *
     }
 
 // There must be a better way to do this.   XXX FIXME XXX
 
   if (sr->is_variable ())
     {
 // Would be nice not to have this cast.  XXX FIXME XXX
       tree_constant *tmp = (tree_constant *) sr->def ();
-      if (tmp == NULL_TREE_CONST)
+      if (tmp)
+	tmp = new tree_constant (*tmp);
+      else
 	tmp = new tree_constant ();
-      else
-	tmp = new tree_constant (*tmp);
       gsr->define (tmp);
     }
   else
-    {
-      sr->clear ();
-    }
+    sr->clear ();
 
 // If the global symbol is currently defined as a function, we need to
 // hide it with a variable.
 
   if (gsr->is_function ())
-    gsr->define (NULL_TREE_CONST);
+    gsr->define ((tree_constant *) 0);
 
   sr->alias (gsr, 1);
   sr->mark_as_linked_to_global ();
 }
 
 /*
  * Make the definition of the symbol record sr be the same as the
  * definition of the builtin variable of the same name.
  */
 void
 link_to_builtin_variable (symbol_record *sr)
 {
   symbol_record *tmp_sym = global_sym_tab->lookup (sr->name (), 0, 0);
 
-  if (tmp_sym != (symbol_record *) NULL)
-    {
-      if (tmp_sym->is_builtin_variable ())
-	{
-	  sr->alias (tmp_sym);
-	}
-    }
+  if (tmp_sym && tmp_sym->is_builtin_variable ())
+    sr->alias (tmp_sym);
 }
 
 /*
  * Make the definition of the symbol record sr be the same as the
  * definition of the builtin variable or function, or user function of
  * the same name, provided that the name has not been used as a formal
  * parameter.
  */
 void
 link_to_builtin_or_function (symbol_record *sr)
 {
   symbol_record *tmp_sym = global_sym_tab->lookup (sr->name (), 0, 0);
 
-  if (tmp_sym != (symbol_record *) NULL)
-    {
-      if ((tmp_sym->is_builtin_variable () || tmp_sym->is_function ())
-	  && ! tmp_sym->is_formal_parameter ())
-	{
-	  sr->alias (tmp_sym);
-	}
-    }
+  if (tmp_sym
+      && (tmp_sym->is_builtin_variable () || tmp_sym->is_function ())
+      && ! tmp_sym->is_formal_parameter ())
+    sr->alias (tmp_sym);
 }
 
 /*
  * Force a link to a function in the current symbol table.  This is
  * used just after defining a function to avoid different behavior
  * depending on whether or not the function has been evaluated after
  * being defined.
  *
@@ -427,42 +413,54 @@ force_link_to_function (const char *id_n
   if (gsr->is_function ())
     {
       curr_sym_tab->clear (id_name);
       symbol_record *csr = curr_sym_tab->lookup (id_name, 1, 0);
       csr->alias (gsr);
     }
 }
 
-/*
- * Return 1 if the argument names a globally visible variable.
- * Otherwise, return 0.
- */
-int
-is_globally_visible (const char *name)
+DEFUN ("is_global", Fis_global, Sis_global, 2, 1,
+  "is_global (X): return 1 if the string X names a global variable\n\
+otherwise, return 0.")
 {
+  Octave_object retval (0.0);
+
+  int nargin = args.length ();
+
+  if (nargin != 2 || ! args(1).is_string_type ())
+    {
+      print_usage ("is_global");
+      return retval;
+    }
+
+  char *name = args(1).string_value ();
+
   symbol_record *sr = curr_sym_tab->lookup (name, 0, 0);
-  return (sr != (symbol_record *) NULL && sr->is_linked_to_global ());
+
+  retval = (double) (sr && sr->is_linked_to_global ());
+
+  return retval;
 }
 
 /*
  * Extract a keyword and its value from a file.  Input should look
  * something like:
  *
  *  #[ \t]*keyword[ \t]*:[ \t]*string-value\n
  *
  * Returns a pointer to new storage.  The caller is responsible for
  * deleting it.
  */
 char *
 extract_keyword (istream& is, char *keyword)
 {
   ostrstream buf;
 
-  char *retval = (char *) NULL;
+  char *retval = 0;
 
   char c;
   while (is.get (c))
     {
       if (c == '#')
 	{
 	  while (is.get (c) && (c == ' ' || c == '\t' || c == '#'))
 	    ; // Skip whitespace and comment characters.
@@ -571,145 +569,160 @@ skip_comments (istream& is)
 }
 
 /*
  * Is `s' a valid identifier?
  */
 int
 valid_identifier (char *s)
 {
-  if (s == (char *) NULL || ! (isalnum (*s) || *s == '_'))
+  if (! s || ! (isalnum (*s) || *s == '_'))
      return 0;
 
   while (*++s != '\0')
     if (! (isalnum (*s) || *s == '_'))
       return 0;
 
   return 1;
 }
 
-/*
- * See if the identifier is in scope.
- */
-int
-identifier_exists (char *name)
+DEFUN ("exist", Fexist, Sexist, 2, 1,
+  "exist (NAME): check if variable or file exists\n\
+\n\
+return 0 if NAME is undefined, 1 if it is a variable, or 2 if it is\n\
+a function.") 
 {
+  Octave_object retval;
+
+  int nargin = args.length ();
+
+  if (nargin != 2 || ! args(1).is_string_type ())
+    {
+      print_usage ("exist");
+      return retval;
+    }
+
+  char *name = args(1).string_value ();
+
   symbol_record *sr = curr_sym_tab->lookup (name, 0, 0);
-  if (sr == (symbol_record *) NULL)
+  if (! sr)
     sr = global_sym_tab->lookup (name, 0, 0);
 
-  if (sr != (symbol_record *) NULL && sr->is_variable () && sr->is_defined ())
-    return 1;
-  else if (sr != (symbol_record *) NULL && sr->is_function ())
-    return 2;
+  retval = 0.0;
+
+  if (sr && sr->is_variable () && sr->is_defined ())
+    retval = 1.0;
+  else if (sr && sr->is_function ())
+    retval = 2.0;
   else
     {
       char *path = fcn_file_in_path (name);
-      if (path != (char *) NULL)
+      if (path)
 	{
 	  delete [] path;
-	  return 2;
+	  retval = 2.0;
 	}
       else
 	{
 	  struct stat buf;
 	  if (stat (name, &buf) == 0 && S_ISREG (buf.st_mode))
-	    return 2;
+	    retval = 2.0;
 	}
     }
-  return 0;
+
+  return retval;
 }
 
 /*
  * Is this variable a builtin?
  */
 int
 is_builtin_variable (const char *name)
 {
   symbol_record *sr = global_sym_tab->lookup (name, 0, 0);
-  return (sr != (symbol_record *) NULL && sr->is_builtin_variable ());
+  return (sr && sr->is_builtin_variable ());
 }
 
 /*
  * Is this tree_constant a valid function?
  */
 tree_fvc *
-is_valid_function (tree_constant& arg, char *warn_for, int warn = 0)
+is_valid_function (const tree_constant& arg, char *warn_for, int warn)
 {
-  tree_fvc *ans = (tree_fvc *) NULL;
+  tree_fvc *ans = 0;
 
   if (! arg.is_string_type ())
     {
       if (warn)
 	error ("%s: expecting function name as argument", warn_for);
       return ans;
     }
 
   char *fcn_name = arg.string_value ();
   symbol_record *sr = global_sym_tab->lookup (fcn_name, 0, 0);
 
-  if (sr == (symbol_record *) NULL)
+  if (sr && symbol_out_of_date (sr))
+    {
+      tree_identifier tmp (sr);
+      tmp.parse_fcn_file (0);
+    }
+  else
     {
       sr = global_sym_tab->lookup (fcn_name, 1, 0);
       tree_identifier tmp (sr);
       tmp.parse_fcn_file (0);
     }
-  else if (symbol_out_of_date (sr))
-    {
-      tree_identifier tmp (sr);
-      tmp.parse_fcn_file (0);
-    }
 
   ans = sr->def ();
-  if (ans == (tree_fvc *) NULL || ! sr->is_function ())
+  if (! ans || ! sr->is_function ())
     {
       if (warn)
 	error ("%s: the symbol `%s' is not valid as a function",
 	       warn_for, fcn_name);
-      ans = (tree_fvc *) NULL;
+      ans = 0;
     }
 
   return ans;
 }
 
 /*
  * Does this function take the right number of arguments?
  */
 int
 takes_correct_nargs (tree_fvc *fcn, int expected_nargin, char *warn_for,
-		     int warn = 0) 
+		     int warn)
 {
   int nargin = fcn->max_expected_args () - 1;
   int e_nargin = expected_nargin - 1;
   if (nargin != e_nargin)
     {
       if (warn)
 	error ("%s: expecting function to take %d argument%c", 
-	       warn_for, e_nargin, s_plural (e_nargin));
+	       warn_for, e_nargin, (e_nargin == 1 ? "" : "s"));
       return 0;
     }
   return 1;
 }
 
 // It's not likely that this does the right thing now.  XXX FIXME XXX
 
 char **
 make_name_list (void)
 {
   int key_len = 0;
   int glb_len = 0;
   int top_len = 0;
   int lcl_len = 0;
   int ffl_len = 0;
 
-  char **key = (char **) NULL;
-  char **glb = (char **) NULL;
-  char **top = (char **) NULL;
-  char **lcl = (char **) NULL;
-  char **ffl = (char **) NULL;
+  char **key = 0;
+  char **glb = 0;
+  char **top = 0;
+  char **lcl = 0;
+  char **ffl = 0;
 
 // Each of these functions returns a new vector of pointers to new
 // strings.
 
   key = names (keyword_help (), key_len);
   glb = global_sym_tab->list (glb_len);
   top = top_level_sym_tab->list (top_len);
   if (top_level_sym_tab != curr_sym_tab)
@@ -736,25 +749,1243 @@ make_name_list (void)
     list[j++] = top[i];
 
   for (i = 0; i < lcl_len; i++)
     list[j++] = lcl[i];
 
   for (i = 0; i < ffl_len; i++)
     list[j++] = ffl[i];
 
-  list[j] = (char *) NULL;
+  list[j] = 0;
 
   delete [] key;
   delete [] glb;
   delete [] top;
   delete [] lcl;
   delete [] ffl;
 
   return list;
 }
 
+int
+is_text_function_name (const char *s)
+{
+  symbol_record *sr = global_sym_tab->lookup (s);
+  return (sr && sr->is_text_function ());
+}
+
+/*
+ * Help stuff.
+ */
+help_list *
+builtin_mapper_functions_help (void)
+{
+#if 0
+  int count = 0;
+  builtin_mapper_functions *mfptr;
+
+  mfptr = mapper_functions;
+  while (mfptr->name)
+    {
+      count++;
+      mfptr++;
+    }
+
+  if (count == 0)
+    return 0;
+
+  help_list *hl = new help_list [count+1];
+
+  int i = 0;
+  mfptr = mapper_functions;
+  while (mfptr->name)
+    {
+      hl[i].name = mfptr->name;
+      hl[i].help = mfptr->help_string;
+      i++;
+      mfptr++;
+    }
+
+  hl[count].name = 0;
+  hl[count].help = 0;
+
+  return hl;
+#endif
+
+  return 0;
+}
+
+help_list *
+builtin_general_functions_help (void)
+{
+#if 0
+  int count = 0;
+  builtin_general_functions *gfptr;
+
+  gfptr = general_functions;
+  while (gfptr->name)
+    {
+      count++;
+      gfptr++;
+    }
+
+  if (count == 0)
+    return 0;
+
+  help_list *hl = new help_list [count+1];
+
+  int i = 0;
+  gfptr = general_functions;
+  while (gfptr->name)
+    {
+      hl[i].name = gfptr->name;
+      hl[i].help = gfptr->help_string;
+      i++;
+      gfptr++;
+    }
+
+  hl[count].name = 0;
+  hl[count].help = 0;
+
+  return hl;
+#endif
+
+  return 0;
+}
+
+help_list *
+builtin_text_functions_help (void)
+{
+#if 0
+  int count = 0;
+  builtin_text_functions *tfptr;
+
+  tfptr = text_functions;
+  while (tfptr->name)
+    {
+      count++;
+      tfptr++;
+    }
+
+  if (count == 0)
+    return 0;
+
+  help_list *hl = new help_list [count+1];
+
+  int i = 0;
+  tfptr = text_functions;
+  while (tfptr->name)
+    {
+      hl[i].name = tfptr->name;
+      hl[i].help = tfptr->help_string;
+      i++;
+      tfptr++;
+    }
+
+  hl[count].name = 0;
+  hl[count].help = 0;
+
+  return hl;
+#endif
+
+  return 0;
+}
+
+help_list *
+builtin_variables_help (void)
+{
+#if 0
+  int count = 0;
+
+  builtin_string_variables *svptr;
+
+  svptr = string_variables;
+  while (svptr->name)
+    {
+      count++;
+      svptr++;
+    }
+
+  if (count == 0)
+    return 0;
+
+  help_list *hl = new help_list [count+1];
+
+  int i = 0;
+  svptr = string_variables;
+  while (svptr->name)
+    {
+      hl[i].name = svptr->name;
+      hl[i].help = svptr->help_string;
+      i++;
+      svptr++;
+    }
+
+  hl[count].name = 0;
+  hl[count].help = 0;
+
+  return hl;
+#endif
+
+  return 0;
+}
+
+int
+help_from_list (ostrstream& output_buf, const help_list *list,
+		const char *string, int usage)
+{
+  char *name;
+  while ((name = list->name) != 0)
+    {
+      if (strcmp (name, string) == 0)
+	{
+	  if (usage)
+	    output_buf << "\nusage: ";
+	  else
+	    {
+	      output_buf << "\n*** " << string << ":\n\n";
+	    }
+
+	  output_buf << list->help << "\n";
+
+	  return 1;
+	}
+      list++;
+    }
+  return 0;
+}
+
+void
+additional_help_message (ostrstream& output_buf)
+{
+  output_buf
+    << "\n"
+    << "Additional help for builtin functions, operators, and variables\n"
+    << "is available in the on-line version of the manual.\n"
+    << "\n"
+    << "Use the command `help -i <topic>' to search the manual index.\n";
+}
+
+void
+print_usage (const char *string, int just_usage)
+{
+  ostrstream output_buf;
+
+  help_list *gf_help_list = builtin_general_functions_help ();
+  help_list *tf_help_list = builtin_text_functions_help ();
+  help_list *mf_help_list = builtin_mapper_functions_help ();
+
+  if (help_from_list (output_buf, gf_help_list, string, 1)
+      || help_from_list (output_buf, tf_help_list, string, 1)
+      || help_from_list (output_buf, mf_help_list, string, 1))
+    {
+      if (! just_usage)
+	additional_help_message (output_buf);
+      output_buf << ends;
+      maybe_page_output (output_buf);
+    }
+}
+
+void
+install_builtin_variables (void)
+{
+// XXX FIXME XX -- these should probably be moved to where they
+// logically belong instead of being all grouped here.
+
+  DEFVAR ("EDITOR", SBV_EDITOR, editor, 0, 0, 1, sv_editor,
+    "name of the editor to be invoked by the edit_history command");
+
+  DEFVAR ("I", SBV_I, Complex (0.0, 1.0), 0, 1, 1, 0,
+    "sqrt (-1)");
+
+  DEFVAR ("Inf", SBV_Inf, octave_Inf, 0, 1, 1, 0,
+    "infinity");
+
+  DEFVAR ("INFO_FILE", SBV_INFO_FILE, info_file, 0, 0, 1, sv_info_file,
+    "name of the Octave info file");
+
+  DEFVAR ("J", SBV_J, Complex (0.0, 1.0), 0, 1, 1, 0,
+    "sqrt (-1)");
+
+  #if defined (HAVE_ISNAN)
+  DEFVAR ("NaN", SBV_NaN, octave_NaN, 0, 1, 1, 0,
+    "not a number");
+  #endif
+
+  DEFVAR ("LOADPATH", SBV_LOADPATH, load_path, 0, 0, 1, sv_loadpath,
+    "colon separated list of directories to search for scripts");
+
+  DEFVAR ("PAGER", SBV_PAGER, default_pager (), 0, 0, 1, sv_pager_binary,
+    "path to pager binary");
+
+  DEFVAR ("PS1", SBV_PS1, "\\s:\\#> ", 0, 0, 1, sv_ps1,
+    "primary prompt string");
+
+  DEFVAR ("PS2", SBV_PS2, "> ", 0, 0, 1, sv_ps2,
+    "secondary prompt string");
+
+  DEFVAR ("PWD", SBV_PWD, get_working_directory ("initialize_globals"),
+	  0, 1, 1, sv_pwd,
+    "current working directory");
+
+  DEFVAR ("SEEK_SET", SBV_SEEK_SET, 0.0, 0, 1, 1, 0,
+    "used with fseek to position file relative to the beginning");
+
+  DEFVAR ("SEEK_CUR", SBV_SEEK_CUR, 1.0, 0, 1, 1, 0,
+    "used with fseek to position file relative to the current position");
+
+  DEFVAR ("SEEK_END", SBV_SEEK_END, 2.0, 0, 1, 1, 0,
+    "used with fseek to position file relative to the end");
+
+  DEFVAR ("ans", SBV_ans, , 0, 0, 1, 0,
+    "");
+
+  DEFVAR ("commas_in_literal_matrix", SBV_commas_in_literal_matrix, "",
+	  0, 0, 1, commas_in_literal_matrix,
+    "control auto-insertion of commas in literal matrices");
+
+  DEFVAR ("do_fortran_indexing", SBV_do_fortran_indexing, "false", 0, 0,
+	  1, do_fortran_indexing,
+    "allow single indices for matrices");
+
+  DEFVAR ("empty_list_elements_ok", SBV_empty_list_elements_ok, "warn",
+	  0, 0, 1, empty_list_elements_ok,
+    "ignore the empty element in expressions like `a = [[], 1]'");
+
+  DEFVAR ("eps", SBV_eps, DBL_EPSILON, 0, 1, 1, 0,
+    "machine precision");
+
+  DEFVAR ("gnuplot_binary", SBV_gnuplot_binary, "gnuplot", 0, 0, 1,
+	  sv_gnuplot_binary,
+    "path to gnuplot binary");
+
+  DEFVAR ("i", SBV_i, Complex (0.0, 1.0), 1, 1, 1, 0,
+    "sqrt (-1)");
+
+  DEFVAR ("ignore_function_time_stamp", SBV_ignore_function_time_stamp,
+	  "system", 0, 0, 1,
+	  ignore_function_time_stamp,
+    "don't check to see if function files have changed since they were\n\
+  last compiled.  Possible values are \"system\" and \"all\"");
+
+  DEFVAR ("implicit_str_to_num_ok", SBV_implicit_str_to_num_ok, "false",
+	  0, 0, 1, implicit_str_to_num_ok,
+    "allow implicit string to number conversion");
+
+  DEFVAR ("inf", SBV_inf, octave_Inf, 0, 1, 1, 0,
+    "infinity");
+
+  DEFVAR ("j", SBV_j, Complex (0.0, 1.0), 1, 1, 1, 0,
+    "sqrt (-1)");
+
+  #if defined (HAVE_ISNAN)
+  DEFVAR ("nan", SBV_nan, octave_NaN, 0, 1, 1, 0,
+    "not a number");
+  #endif
+
+  DEFVAR ("ok_to_lose_imaginary_part", SBV_ok_to_lose_imaginary_part,
+	  "warn", 0, 0, 1, ok_to_lose_imaginary_part,
+    "silently convert from complex to real by dropping imaginary part");
+
+  DEFVAR ("output_max_field_width", SBV_output_max_field_width, 10.0, 0,
+	  0, 1, set_output_max_field_width,
+    "maximum width of an output field for numeric output");
+
+  DEFVAR ("output_precision", SBV_output_precision, 5.0, 0, 0, 1,
+	  set_output_precision,
+    "number of significant figures to display for numeric output");
+
+  DEFVAR ("page_screen_output", SBV_page_screen_output, "true", 0, 0, 1,
+	  page_screen_output,
+    "if possible, send output intended for the screen through the pager");
+
+  DEFVAR ("pi", SBV_pi, 4.0 * atan (1.0), 0, 1, 1, 0,
+    "ratio of the circumference of a circle to its diameter");
+
+  DEFVAR ("prefer_column_vectors", SBV_prefer_column_vectors, "true", 0,
+	  0, 1, prefer_column_vectors,
+    "prefer column/row vectors");
+
+  DEFVAR ("prefer_zero_one_indexing", SBV_prefer_zero_one_indexing,
+	  "false", 0, 0, 1, prefer_zero_one_indexing,
+    "when there is a conflict, prefer zero-one style indexing");
+
+  DEFVAR ("print_answer_id_name", SBV_print_answer_id_name, "true", 0,
+	  0, 1, print_answer_id_name,
+    "set output style to print `var_name = ...'");
+
+  DEFVAR ("print_empty_dimensions", SBV_print_empty_dimensions, "true",
+	  0, 0, 1, print_empty_dimensions,
+    "also print dimensions of empty matrices");
+
+  DEFVAR ("propagate_empty_matrices", SBV_propagate_empty_matrices,
+	  "true", 0, 0, 1, propagate_empty_matrices,
+    "operations on empty matrices return an empty matrix, not an error");
+
+  DEFVAR ("resize_on_range_error", SBV_resize_on_range_error, "true", 0,
+	  0, 1, resize_on_range_error,
+    "enlarge matrices on assignment");
+
+  DEFVAR ("return_last_computed_value", SBV_return_last_computed_value,
+	  "false", 0, 0, 1,
+	  return_last_computed_value,
+    "if a function does not return any values explicitly, return the\n\
+  last computed value");
+
+  DEFVAR ("save_precision", SBV_save_precision, 17.0, 0, 0, 1,
+	  set_save_precision,
+    "number of significant figures kept by the ASCII save command");
+
+  DEFVAR ("silent_functions", SBV_silent_functions, "false", 0, 0, 1,
+	  silent_functions,
+    "suppress printing results in called functions");
+
+  DEFVAR ("split_long_rows", SBV_split_long_rows, "true", 0, 0, 1,
+	  split_long_rows,
+    "split long matrix rows instead of wrapping");
+
+  DEFVAR ("stdin", SBV_stdin, 0.0, 0, 1, 1, 0,
+    "file number of the standard input stream");
+
+  DEFVAR ("stdout", SBV_stdout, 1.0, 0, 1, 1, 0,
+    "file number of the standard output stream");
+
+  DEFVAR ("stderr", SBV_stderr, 2.0, 0, 1, 1, 0,
+    "file number of the standard error stream");
+
+  DEFVAR ("treat_neg_dim_as_zero", SBV_treat_neg_dim_as_zero, "false",
+	  0, 0, 1, treat_neg_dim_as_zero,
+    "convert negative dimensions to zero");
+
+  DEFVAR ("warn_assign_as_truth_value", SBV_warn_assign_as_truth_value,
+	  "true", 0, 0, 1,
+	  warn_assign_as_truth_value,
+    "produce warning for assignments used as truth values");
+
+  DEFVAR ("warn_comma_in_global_decl", SBV_warn_comma_in_global_decl,
+	  "true", 0, 0, 1, warn_comma_in_global_decl,
+    "produce warning for commas in global declarations");
+
+  DEFVAR ("warn_divide_by_zero", SBV_warn_divide_by_zero, "true", 0, 0,
+	  1, warn_divide_by_zero,
+    "on IEEE machines, allow divide by zero errors to be suppressed");
+}
+
+/*
+ * List variable names.
+ */
+static void
+print_symbol_info_line (ostrstream& output_buf, const symbol_record_info& s)
+{
+  output_buf << (s.is_read_only () ? " -" : " w");
+  output_buf << (s.is_eternal () ? "- " : "d ");
+#if 0
+  output_buf << (s.hides_fcn () ? "f" : (s.hides_builtin () ? "F" : "-"));
+#endif
+  output_buf.form ("  %-16s", s.type_as_string ());
+  if (s.is_function ())
+    output_buf << "      -      -";
+  else
+    {
+      output_buf.form ("%7d", s.rows ());
+      output_buf.form ("%7d", s.columns ());
+    }
+  output_buf << "  " << s.name () << "\n";
+}
+
+static void
+print_long_listing (ostrstream& output_buf, symbol_record_info *s)
+{
+  if (! s)
+    return;
+
+  symbol_record_info *ptr = s;
+  while (ptr->is_defined ())
+    {
+      print_symbol_info_line (output_buf, *ptr);
+      ptr++;
+    }
+}
+
+static int
+maybe_list (const char *header, ostrstream& output_buf,
+	    int show_verbose, symbol_table *sym_tab, unsigned type,
+	    unsigned scope)
+{
+  int count;
+  int status = 0;
+  if (show_verbose)
+    {
+      symbol_record_info *symbols;
+      symbols = sym_tab->long_list (count, 1, type, scope);
+      if (symbols && count > 0)
+	{
+	  output_buf << "\n" << header << "\n\n"
+		     << "prot  type               rows   cols  name\n"
+		     << "====  ====               ====   ====  ====\n";
+
+	  print_long_listing (output_buf, symbols);
+	  status = 1;
+	}
+      delete [] symbols;
+    }
+  else
+    {
+      char **symbols = sym_tab->list (count, 1, type, scope);
+      if (symbols && count > 0)
+	{
+	  output_buf << "\n" << header << "\n\n";
+	  list_in_columns (output_buf, symbols);
+	  status = 1;
+	}
+      delete [] symbols;
+    }
+  return status;
+}
+
+DEFUN_TEXT ("clear", Fclear, Sclear, -1, 1,
+  "clear [name ...]\n\
+\n\
+clear symbol(s) matching a list of globbing patterns\n\
+if no arguments are given, clear all user-defined variables and functions")
+{
+  Octave_object retval;
+
+  DEFINE_ARGV("clear");
+
+// Always clear the local table, but don't clear currently compiled
+// functions unless we are at the top level.  (Allowing that to happen
+// inside functions would result in pretty odd behavior...)
+
+  int clear_user_functions = (curr_sym_tab == top_level_sym_tab);
+
+  if (argc == 1)
+    {
+      curr_sym_tab->clear ();
+      global_sym_tab->clear (clear_user_functions);
+    }
+  else
+    {
+      int lcount;
+      char **lvars = curr_sym_tab->list (lcount, 0,
+					 symbol_def::USER_VARIABLE,
+					 SYMTAB_LOCAL_SCOPE);
+      int gcount;
+      char **gvars = curr_sym_tab->list (gcount, 0,
+					 symbol_def::USER_VARIABLE,
+					 SYMTAB_GLOBAL_SCOPE);
+      int fcount;
+      char **fcns = curr_sym_tab->list (fcount, 0,
+					symbol_def::USER_FUNCTION,
+					SYMTAB_ALL_SCOPES);
+
+      while (--argc > 0)
+	{
+	  argv++;
+	  if (*argv)
+	    {
+	      int i;
+	      for (i = 0; i < lcount; i++)
+		{
+		  if (fnmatch (*argv, lvars[i], __FNM_FLAGS) == 0)
+		    curr_sym_tab->clear (lvars[i]);
+		}
+
+	      int count;
+	      for (i = 0; i < gcount; i++)
+		{
+		  if (fnmatch (*argv, gvars[i], __FNM_FLAGS) == 0)
+		    {
+		      count = curr_sym_tab->clear (gvars[i]);
+		      if (count > 0)
+			global_sym_tab->clear (gvars[i], clear_user_functions);
+		    }
+		}
+
+	      for (i = 0; i < fcount; i++)
+		{
+		  if (fnmatch (*argv, fcns[i], __FNM_FLAGS) == 0)
+		    {
+		      count = curr_sym_tab->clear (fcns[i]);
+		      if (count > 0)
+			global_sym_tab->clear (fcns[i], clear_user_functions);
+		    }
+		}
+	    }
+	}
+
+      delete [] lvars;
+      delete [] gvars;
+      delete [] fcns;
+
+    }
+
+  DELETE_ARGV;
+
+  return retval;
+}
+
+DEFUN_TEXT ("document", Fdocument, Sdocument, -1, 1,
+  "document symbol string ...\n\
+\n\
+Associate a cryptic message with a variable name.")
+{
+  Octave_object retval;
+
+  DEFINE_ARGV("document");
+
+  if (argc == 3)
+    document_symbol (argv[1], argv[2]);
+  else
+    print_usage ("document");
+
+  DELETE_ARGV;
+
+  return retval;
+}
+
+static int
+load_variable (char *nm, int force, istream& is)
+{
+// Is there already a symbol by this name?  If so, what is it?
+
+  symbol_record *lsr = curr_sym_tab->lookup (nm, 0, 0);
+
+  int is_undefined = 1;
+  int is_variable = 0;
+  int is_function = 0;
+  int is_global = 0;
+
+  if (lsr)
+    {
+      is_undefined = ! lsr->is_defined ();
+      is_variable = lsr->is_variable ();
+      is_function = lsr->is_function ();
+      is_global = lsr->is_linked_to_global ();
+    }
+
+// Try to read data for this name.
+
+  tree_constant tc;
+  int global = tc.load (is);
+
+  if (tc.const_type () == tree_constant_rep::unknown_constant)
+    {
+      error ("load: unable to load variable `%s'", nm);
+      return 0;
+    }
+
+  symbol_record *sr = 0;
+
+  if (global)
+    {
+      if (is_global || is_undefined)
+	{
+	  if (force || is_undefined)
+	    {
+	      lsr = curr_sym_tab->lookup (nm, 1, 0);
+	      link_to_global_variable (lsr);
+	      sr = lsr;
+	    }
+	  else
+	    {
+	      warning ("load: global variable name `%s' exists.", nm);
+	      warning ("use `load -force' to overwrite");
+	    }
+	}
+      else if (is_function)
+	{
+	  if (force)
+	    {
+	      lsr = curr_sym_tab->lookup (nm, 1, 0);
+	      link_to_global_variable (lsr);
+	      sr = lsr;
+	    }
+	  else
+	    {
+	      warning ("load: `%s' is currently a function in this scope", nm);
+	      warning ("`load -force' will load variable and hide function");
+	    }
+	}
+      else if (is_variable)
+	{
+	  if (force)
+	    {
+	      lsr = curr_sym_tab->lookup (nm, 1, 0);
+	      link_to_global_variable (lsr);
+	      sr = lsr;
+	    }
+	  else
+	    {
+	      warning ("load: local variable name `%s' exists.", nm);
+	      warning ("use `load -force' to overwrite");
+	    }
+	}
+      else
+	panic_impossible ();
+    }
+  else
+    {
+      if (is_global)
+	{
+	  if (force || is_undefined)
+	    {
+	      lsr = curr_sym_tab->lookup (nm, 1, 0);
+	      link_to_global_variable (lsr);
+	      sr = lsr;
+	    }
+	  else
+	    {
+	      warning ("load: global variable name `%s' exists.", nm);
+	      warning ("use `load -force' to overwrite");
+	    }
+	}
+      else if (is_function)
+	{
+	  if (force)
+	    {
+	      lsr = curr_sym_tab->lookup (nm, 1, 0);
+	      link_to_global_variable (lsr);
+	      sr = lsr;
+	    }
+	  else
+	    {
+	      warning ("load: `%s' is currently a function in this scope", nm);
+	      warning ("`load -force' will load variable and hide function");
+	    }
+	}
+      else if (is_variable || is_undefined)
+	{
+	  if (force || is_undefined)
+	    {
+	      lsr = curr_sym_tab->lookup (nm, 1, 0);
+	      sr = lsr;
+	    }
+	  else
+	    {
+	      warning ("load: local variable name `%s' exists.", nm);
+	      warning ("use `load -force' to overwrite");
+	    }
+	}
+      else
+	panic_impossible ();
+    }
+
+  if (sr)
+    {
+      tree_constant *tmp_tc = new tree_constant (tc);
+      sr->define (tmp_tc);
+      return 1;
+    }
+  else
+    error ("load: unable to load variable `%s'", nm);
+
+  return 0;
+}
+
+DEFUN_TEXT ("load", Fload, Sload, -1, 1,
+  "load [-force] file\n
+\n\
+load variables from a file")
+{
+  Octave_object retval;
+
+  DEFINE_ARGV("load");
+
+  argc--;
+  argv++;
+
+  int force = 0;
+  if (argc > 0 && strcmp (*argv, "-force") == 0)
+    {
+      force++;
+      argc--;
+      argv++;
+    }
+
+  if (argc < 1)
+    {
+      error ("load: you must specify a single file to read");
+      DELETE_ARGV;
+      return retval;
+    }
+
+  static istream stream;
+  static ifstream file;
+  if (strcmp (*argv, "-") == 0)
+    {
+      stream = cin;
+    }
+  else
+    {
+      char *fname = tilde_expand (*argv);
+      file.open (fname);
+      if (! file)
+	{
+	  error ("load: couldn't open input file `%s'", *argv);
+	  DELETE_ARGV;
+	  return retval;
+	}
+      stream = file;
+    }
+
+  int count = 0;
+  char *nm = 0;
+  for (;;)
+    {
+// Read name for this entry or break on EOF.
+      delete [] nm;
+      nm = extract_keyword (stream, "name");
+      if (nm)
+	count++;
+      else
+	{
+	  if (count == 0)
+	    {
+	      error ("load: no name keywords found in file `%s'", *argv);
+	      error ("Are you sure this is an octave data file?");
+	    }
+	  break;
+	}
+
+      if (! *nm)
+	continue;
+
+      if (! valid_identifier (nm))
+	{
+	  warning ("load: skipping bogus identifier `%s'");
+	  continue;
+	}
+
+      load_variable (nm, force, stream);
+
+      if (error_state)
+	{
+	  error ("reading file %s", *argv);
+	  break;
+	}
+    }
+
+  if (file);
+    file.close ();
+
+  DELETE_ARGV;
+
+  return retval;
+}
+
+/*
+ * Return nonzero if PATTERN has any special globbing chars in it.
+ */
+static int
+glob_pattern_p (char *pattern)
+{
+  char *p = pattern;
+  char c;
+  int open = 0;
+
+  while ((c = *p++) != '\0')
+    {
+      switch (c)
+	{
+	case '?':
+	case '*':
+	  return 1;
+
+	case '[':	// Only accept an open brace if there is a close
+	  open++;	// brace to match it.  Bracket expressions must be
+	  continue;	// complete, according to Posix.2
+
+	case ']':
+	  if (open)
+	    return 1;
+	  continue;
+	  
+	case '\\':
+	  if (*p++ == '\0')
+	    return 0;
+
+	default:
+	  continue;
+	}
+    }
+
+  return 0;
+}
+
+DEFUN_TEXT ("save", Fsave, Ssave, -1, 1,
+  "save file [var ...]\n\
+\n\
+save variables in a file")
+{
+  Octave_object retval;
+
+#if 0
+  DEFINE_ARGV("save");
+
+  if (argc < 2)
+    {
+      print_usage ("save");
+      DELETE_ARGV;
+      return retval;
+    }
+
+  argc--;
+  argv++;
+
+  static ostream stream;
+  static ofstream file;
+  if (strcmp (*argv, "-") == 0)
+    {
+// XXX FIXME XXX -- should things intended for the screen end up in a 
+// tree_constant (string)?
+      stream = cout;
+    }
+  else if (argc == 1 && glob_pattern_p (*argv)) // Guard against things
+    {						// like `save a*',
+      print_usage ("save");			// which are probably
+      DELETE_ARGV;				// mistakes...
+      return retval;
+    }
+  else
+    {
+      char *fname = tilde_expand (*argv);
+      file.open (fname);
+      if (! file)
+	{
+	  error ("save: couldn't open output file `%s'", *argv);
+	  DELETE_ARGV;
+	  return retval;
+	}
+      stream = file;
+
+    }
+
+  int prec = user_pref.save_precision;
+
+  if (argc == 1)
+    {
+      int count;
+      char **vars = curr_sym_tab->list (count, 0,
+					symbol_def::USER_VARIABLE,
+					SYMTAB_ALL_SCOPES);
+
+      for (int i = 0; i < count; i++)
+	curr_sym_tab->save (stream, vars[i],
+			    is_globally_visible (vars[i]), prec);
+
+      delete [] vars;
+    }
+  else
+    {
+      while (--argc > 0)
+	{
+	  argv++;
+
+	  int count;
+	  char **lvars = curr_sym_tab->list (count, 0,
+					     symbol_def::USER_VARIABLE);
+
+	  int saved_or_error = 0;
+	  int i;
+	  for (i = 0; i < count; i++)
+	    {
+	      if (fnmatch (*argv, lvars[i], __FNM_FLAGS) == 0
+		  && curr_sym_tab->save (stream, lvars[i],
+					 is_globally_visible (lvars[i]),
+					 prec) != 0)
+		saved_or_error++;
+	    }
+
+	  char **bvars = global_sym_tab->list (count, 0,
+					       symbol_def::BUILTIN_VARIABLE);
+
+	  for (i = 0; i < count; i++)
+	    {
+	      if (fnmatch (*argv, bvars[i], __FNM_FLAGS) == 0
+		  && global_sym_tab->save (stream, bvars[i], 0, prec) != 0)
+		saved_or_error++;
+	    }
+
+	  delete [] lvars;
+	  delete [] bvars;
+
+	  if (! saved_or_error)
+	    warning ("save: no such variable `%s'", *argv);
+	}
+    }
+
+  if (file);
+    file.close ();
+
+  DELETE_ARGV;
+#endif
+
+  return retval;
+}
+
+DEFUN_TEXT ("who", Fwho, Swho, -1, 1,
+  "who [-all] [-builtins] [-functions] [-long] [-variables]\n\
+\n\
+List currently defined symbol(s).  Options may be shortened to one\n\
+character, but may not be combined.")
+{
+  Octave_object retval;
+
+  DEFINE_ARGV("who");
+
+  int show_builtins = 0;
+  int show_functions = (curr_sym_tab == top_level_sym_tab);
+  int show_variables = 1;
+  int show_verbose = 0;
+
+  if (argc > 1)
+    {
+      show_functions = 0;
+      show_variables = 0;
+    }
+
+  for (int i = 1; i < argc; i++)
+    {
+      argv++;
+      if (strcmp (*argv, "-all") == 0 || strcmp (*argv, "-a") == 0)
+	{
+	  show_builtins++;
+	  show_functions++;
+	  show_variables++;	  
+	}
+      else if (strcmp (*argv, "-builtins") == 0
+	       || strcmp (*argv, "-b") == 0)
+	show_builtins++;
+      else if (strcmp (*argv, "-functions") == 0
+	       || strcmp (*argv, "-f") == 0)
+	show_functions++;
+      else if (strcmp (*argv, "-long") == 0 
+	       || strcmp (*argv, "-l") == 0)
+	  show_verbose++;
+      else if (strcmp (*argv, "-variables") == 0
+	       || strcmp (*argv, "-v") == 0)
+	show_variables++;
+      else
+	warning ("who: unrecognized option `%s'", *argv);
+    }
+
+// If the user specified -l and nothing else, show variables.  If
+// evaluating this at the top level, also show functions.
+
+  if (show_verbose && ! (show_builtins || show_functions || show_variables))
+    {
+      show_functions = (curr_sym_tab == top_level_sym_tab);
+      show_variables = 1;
+    }
+
+  ostrstream output_buf;
+  int pad_after = 0;
+
+  if (show_builtins)
+    {
+      pad_after += maybe_list ("*** built-in variables:",
+			       output_buf, show_verbose, global_sym_tab,
+			       symbol_def::BUILTIN_VARIABLE,
+			       SYMTAB_ALL_SCOPES);
+
+      pad_after += maybe_list ("*** built-in functions:",
+			       output_buf, show_verbose, global_sym_tab,
+			       symbol_def::BUILTIN_FUNCTION,
+			       SYMTAB_ALL_SCOPES);
+    }
+
+  if (show_functions)
+    {
+      pad_after += maybe_list ("*** currently compiled functions:",
+			       output_buf, show_verbose, global_sym_tab,
+			       symbol_def::USER_FUNCTION,
+			       SYMTAB_ALL_SCOPES);
+    }
+
+  if (show_variables)
+    {
+      pad_after += maybe_list ("*** local user variables:",
+			       output_buf, show_verbose, curr_sym_tab,
+			       symbol_def::USER_VARIABLE,
+			       SYMTAB_LOCAL_SCOPE); 
+
+      pad_after += maybe_list ("*** globally visible user variables:",
+			       output_buf, show_verbose, curr_sym_tab,
+			       symbol_def::USER_VARIABLE,
+			       SYMTAB_GLOBAL_SCOPE);
+    }
+
+  if (pad_after)
+    output_buf << "\n";
+
+  output_buf << ends;
+  maybe_page_output (output_buf);
+
+  DELETE_ARGV;
+
+  return retval;
+}
+
+// XXX FIXME XXX -- should these really be here?
+
+char *
+octave_home (void)
+{
+#ifdef RUN_IN_PLACE
+  static char *home = OCTAVE_HOME;
+  return home;
+#else
+  static char *home = 0;
+  delete [] home;
+  char *oh = getenv ("OCTAVE_HOME");
+  if (oh)
+    home = strsave (oh);
+  else
+    home = strsave (OCTAVE_HOME);
+  return home;
+#endif
+}
+
+char *
+octave_lib_dir (void)
+{
+#ifdef RUN_IN_PLACE
+  static char *ol = OCTAVE_LIB_DIR;
+  return ol;
+#else
+  static char *ol = 0;
+  delete [] ol;
+  char *oh = octave_home ();
+  char *tmp = strconcat (oh, "/lib/octave/");
+  ol = strconcat (tmp, version_string);
+  delete [] tmp;
+  return ol;
+#endif
+}
+
+char *
+octave_info_dir (void)
+{
+#ifdef RUN_IN_PLACE
+  static char *oi = OCTAVE_INFO_DIR;
+  return oi;
+#else
+  static char *oi = 0;
+  delete [] oi;
+  char *oh = octave_home ();
+  oi = strconcat (oh, "/info/");
+  return oi;
+#endif
+}
+
+/*
+ * Handle OCTAVE_PATH from the environment like TeX handles TEXINPUTS.
+ * If the path starts with `:', prepend the standard path.  If it ends
+ * with `:' append the standard path.  If it begins and ends with
+ * `:', do both (which is useless, but the luser asked for it...).
+ *
+ * This function may eventually be called more than once, so be
+ * careful not to create memory leaks. 
+ */
+char *
+default_path (void)
+{
+  static char *pathstring = 0;
+  delete [] pathstring;
+
+  static char *std_path = 0;
+  delete [] std_path;
+
+  char *libdir = octave_lib_dir ();
+
+  std_path = strconcat (".:", libdir);
+
+  char *oct_path = getenv ("OCTAVE_PATH");
+
+  if (oct_path)
+    {
+      pathstring = strsave (oct_path);
+
+      if (pathstring[0] == ':')
+	{
+	  char *tmp = pathstring;
+	  pathstring = strconcat (std_path, pathstring);
+	  delete [] tmp;
+	}
+
+      int tmp_len = strlen (pathstring);
+      if (pathstring[tmp_len-1] == ':')
+	{
+	  char *tmp = pathstring;
+	  pathstring = strconcat (pathstring, std_path);
+	  delete [] tmp;
+	}
+    }
+  else
+    pathstring = strsave (std_path);
+
+  return pathstring;
+}
+
+char *
+default_info_file (void)
+{
+  static char *info_file_string = 0;
+  delete [] info_file_string;
+  char *oct_info_file = getenv ("OCTAVE_INFO_FILE");
+  if (oct_info_file)
+    info_file_string = strsave (oct_info_file);
+  else
+    {
+      char *infodir = octave_info_dir ();
+      info_file_string = strconcat (infodir, "/octave.info");
+    }
+  return info_file_string;
+}
+
+char *
+default_editor (void)
+{
+  static char *editor_string = 0;
+  delete [] editor_string;
+  char *env_editor = getenv ("EDITOR");
+  if (env_editor && *env_editor)
+    editor_string = strsave (env_editor);
+  else
+    editor_string = strsave ("vi");
+  return editor_string;
+}
+
+char *
+get_site_defaults (void)
+{
+  static char *sd = 0;
+  delete [] sd;
+  char *libdir = octave_lib_dir ();
+  sd = strconcat (libdir, "/octaverc");
+  return sd;
+}
+
+char *
+default_pager (void)
+{
+  static char *pager_binary = 0;
+  delete [] pager_binary;
+  char *pgr = getenv ("PAGER");
+  if (pgr)
+    pager_binary = strsave (pgr);
+  else
+#ifdef DEFAULT_PAGER
+    pager_binary = strsave (DEFAULT_PAGER);
+#else
+    pager_binary = strsave ("");
+#endif
+
+  return pager_binary;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -20,55 +20,78 @@ along with Octave; see the file COPYING.
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
 #if !defined (octave_variables_h)
 #define octave_variables_h 1
 
 class istream;
+class ostrstream;
 class symbol_record;
 class symbol_table;
 class tree;
 class tree_fvc;
 class tree_constant;
+class Octave_object;
 
-struct builtin_mapper_functions;
-struct builtin_text_functions;
-struct builtin_general_functions;
-struct builtin_string_variables;
+struct builtin_mapper_function;
+struct builtin_function;
+struct builtin_variable;
+
+typedef int (*sv_Function)(void);
 
-#include "builtins.h"
+struct builtin_variable
+{
+  char *name;
+  tree_constant *value;
+  int install_as_function;
+  int protect;
+  int eternal;
+  sv_Function sv_function;
+  char *help_string;
+};
+
+typedef Octave_object (*Octave_builtin_fcn)(const Octave_object&, int);
+
+struct builtin_function
+{
+  char *name;
+  int nargin_max;
+  int nargout_max;
+  int is_text_fcn;
+  Octave_builtin_fcn fcn;
+  char *help_string;
+};
 
 extern void initialize_symbol_tables (void);
 
 extern int symbol_out_of_date (symbol_record *sr);
 
 extern void document_symbol (const char *name, const char *help);
 
-extern void install_builtin_mapper_function (builtin_mapper_functions *mf);
-
-extern void install_builtin_text_function (builtin_text_functions *tf);
+extern void install_builtin_mapper (builtin_mapper_function *mf);
 
-extern void install_builtin_general_function (builtin_general_functions *gf);
+extern void install_builtin_function (builtin_function *gf);
 
-extern void install_builtin_variable (builtin_string_variables *sv);
+extern void install_builtin_variable (builtin_variable *v);
 
 extern void install_builtin_variable_as_function (const char *name,
 						  tree_constant *val,
 						  int protect = 0,
-						  int eternal = 0);  
+						  int eternal = 0,
+						  const char *help = 0);
 
 extern void bind_nargin_and_nargout (symbol_table *sym_tab,
 				     int nargin, int nargout);
 
 extern void bind_builtin_variable (const char *, tree_constant *,
 				   int protect = 0, int eternal = 0,
 				   sv_Function f = (sv_Function) 0,
-				   const char *help = (char *) 0);
+				   const char *help = 0);
 
 extern char *builtin_string_variable (const char *);
 extern int builtin_real_scalar_variable (const char *, double&);
 
 extern void link_to_global_variable (symbol_record *sr);
 extern void link_to_builtin_variable (symbol_record *sr);
 extern void link_to_builtin_or_function (symbol_record *sr);
 
@@ -78,20 +101,49 @@ extern int is_globally_visible (const ch
 
 extern char *extract_keyword (istream&, char *);
 extern int extract_keyword (istream&, char *, int&);
 
 extern void skip_comments (istream&);
 extern int valid_identifier (char *);
 extern int identifier_exists (char *);
 extern int is_builtin_variable (const char *name);
-extern tree_fvc *is_valid_function (tree_constant&, char *, int warn = 0);
+extern tree_fvc *is_valid_function (const tree_constant&, char *,
+				    int warn = 0); 
 extern int takes_correct_nargs (tree_fvc *, int, char *, int warn = 0);
 extern char **make_name_list (void);
 
+extern int is_text_function_name (const char *s);
+
+struct help_list;
+
+extern help_list *builtin_mapper_functions_help (void);
+extern help_list *builtin_general_functions_help (void);
+extern help_list *builtin_text_functions_help (void);
+extern help_list *builtin_variables_help (void);
+
+extern int help_from_list (ostrstream& output_buf,
+			   const help_list *list, const char *string,
+			   int usage);
+
+extern void additional_help_message (ostrstream& output_buf);
+
+extern void print_usage (const char *s, int just_usage = 0);
+
+extern void install_builtin_variables (void);
+
+extern char *octave_home (void);
+extern char *octave_lib_dir (void);
+extern char *octave_info_dir (void);
+extern char *default_path (void);
+extern char *default_info_file (void);
+extern char *default_editor (void);
+extern char *get_site_defaults (void);
+extern char *default_pager (void);
+
 // Symbol table for symbols at the top level.
 extern symbol_table *top_level_sym_tab;
 
 // Symbol table for the current scope.
 extern symbol_table *curr_sym_tab;
 
 // Symbol table for global symbols.
 extern symbol_table *global_sym_tab;
