# HG changeset patch
# User Rik <rik@octave.org>
# Date 1501263273 25200
#      Fri Jul 28 10:34:33 2017 -0700
# Node ID 90689bdbe0483cc83d45899dd7eaabb013d13ccd
# Parent  3f7226b07a38a66587ae85d84edd1236c220efd8
Use C++11 raw string literals to avoid escaping double quotes.

* parser.cc, workspace-view.cc, __lin_interpn__.cc, cellfun.cc, colloc.cc,
data.cc, dirfns.cc, eig.cc, file-io.cc, find.cc, gammainc.cc, gl2ps-print.cc,
graphics.cc, graphics.in.h, help.cc, input.cc, load-path.cc, load-save.cc,
oct-hist.cc, oct-stream.cc, pager.cc, pr-output.cc, spparms.cc, symtab.cc,
toplev.cc, tril.cc, urlwrite.cc, utils.cc, variables.cc, chol.cc, qr.cc,
symbfact.cc, ov-struct.cc, octave.cc, pt-id.h, version.cc, mkoctfile.in.cc:
Replace regular strings containing "\"" patterns with R"(..."...)".

diff --git a/libgui/src/qtinfo/parser.cc b/libgui/src/qtinfo/parser.cc
--- a/libgui/src/qtinfo/parser.cc
+++ b/libgui/src/qtinfo/parser.cc
@@ -35,21 +35,21 @@ along with Octave; see the file COPYING.
 #include <QFile>
 #include <QUrl>
 #include <QRegExp>
 #include <QBuffer>
 
 parser::parser (QObject *p)
   : QObject(p)
 {
-  _compressors_map.insert ("bz2",  "bzip2 -dc \"%1\"");
-  _compressors_map.insert ("gz",   "gzip -dc \"%1\"");
-  _compressors_map.insert ("lzma", "lzma -dc \"%1\"");
-  _compressors_map.insert ("xz",   "xz -dc \"%1\"");
-  _compressors_map.insert ("Z",    "gunzip -c \"%1\"");
+  _compressors_map.insert ( "bz2",  R"(bzip2 -dc "%1")" );
+  _compressors_map.insert ( "gz",   R"(gzip -dc "%1")"  );
+  _compressors_map.insert ( "lzma", R"(lzma -dc "%1")"  );
+  _compressors_map.insert ( "xz",   R"(xz -dc "%1")"    );
+  _compressors_map.insert ( "Z",    R"(gunzip -c "%1")" );
 }
 
 bool
 parser::set_info_path (const QString& infoPath)
 {
   this->_info_path = infoPath;
 
   _info_files.clear ();
@@ -340,33 +340,33 @@ replace_links (QString& text)
       note.replace (re_break,"&nbsp;");
 
       url_link = url_link.trimmed ();
       url_link.replace ("\n"," ");
       url_link.replace (QRegExp ("  +")," ");
       url_link.replace ("<b>","");
       url_link.replace ("</b>","");
 
-      href += "<font style=\"color:DarkGray; font-weight:bold;\">&raquo;</font>";
+      href += R"(<font style="color:DarkGray; font-weight:bold;">&raquo;</font>)";
       href += "&nbsp;<a href='" + url_link + "'>" + note + "</a>" + term;
       f = re.matchedLength ();
       text.replace (i, f, href);
       i += href.size ();
     }
 }
 
 static void
 replace_colons (QString& text)
 {
   QRegExp re ("`([^']+)'");
   int i = 0, f;
   while ((i = re.indexIn (text, i)) != -1)
     {
       QString t = re.cap (1);
-      QString bold = "<font style=\"color:SteelBlue;font-weight:bold\">" + t +
+      QString bold = R"(<font style="color:SteelBlue;font-weight:bold">)" + t +
                      "</font>";
 
       f = re.matchedLength ();
       text.replace (i, f, bold);
       i += bold.size ();
     }
 }
 
@@ -375,17 +375,17 @@ info_to_html (QString& text)
 {
   text.replace ("&", "&amp;");
   text.replace ("<", "&lt;");
   text.replace (">", "&gt;");
 
   text.replace ("\n *Menu:",
                 "\n<font style=\"color:DarkRed;font-weight:bold\">Menu:</font>");
   text.replace ("See also:",
-                "<font style=\"color:DarkRed;font-style:italic;font-weight:bold\">See also:</font>");
+                R"(<font style="color:DarkRed;font-style:italic;font-weight:bold">See also:</font>)");
   replace_links (text);
   replace_colons (text);
 }
 
 QString
 parser::node_text_to_html (const QString& text_arg, int anchorPos,
                            const QString& anchor)
 {
@@ -403,28 +403,28 @@ parser::node_text_to_html (const QString
 
       int n = text1.indexOf ("\n");
       text1.remove (0, n);
 
       info_to_html (text1);
       info_to_html (text2);
 
       text = text1 + "<a name='" + anchor
-             + "'/><font style=\"color:DarkBlue; font: bold monospace large;\">&diams;</font><br>&nbsp;"
+             + R"('/><font style="color:DarkBlue; font: bold monospace large;">&diams;</font><br>&nbsp;)"
              + text2;
     }
   else
     {
       int n = text.indexOf ("\n");
       text.remove (0, n);
       info_to_html (text);
     }
 
   QString navigationLinks = QString (
-        "<b>Section:</b> <font style=\"color:DarkRed\">%1</font><br>"
+        R"(<b>Section:</b> <font style="color:DarkRed">%1</font><br>)"
         "<b>Previous Section:</b> <a href='%2'>%3</a><br>"
         "<b>Next Section:</b> <a href='%4'>%5</a><br>"
         "<b>Up:</b> <a href='%6'>%7</a><br>\n"
         )
     .arg (nodeName, nodePrev, nodePrev, nodeNext, nodeNext, nodeUp, nodeUp);
 
   text.prepend ("<hr>\n<pre style=\"font-family:monospace\">");
   text.append ("</pre>\n<hr><hr>\n");
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -481,17 +481,17 @@ workspace_view::notice_settings (const Q
 
   if (! settings->value ("workspaceview/hide_tool_tips",false).toBool ())
     {
       tool_tip  = QString (tr ("View the variables in the active workspace.<br>"));
       tool_tip += QString (tr ("Colors for variable attributes:"));
       for (i = 0; i < resource_manager::storage_class_chars ().length (); i++)
         {
           tool_tip +=
-            QString ("<div style=\"background-color:%1;color:#000000\">%2</div>")
+            QString (R"(<div style="background-color:%1;color:#000000">%2</div>)")
             .arg (_model->storage_class_color (i).name ())
             .arg (resource_manager::storage_class_names ().at (i));
         }
     }
 
   setToolTip (tool_tip);
 
   _columns_shown = QStringList ();
diff --git a/libinterp/corefcn/__lin_interpn__.cc b/libinterp/corefcn/__lin_interpn__.cc
--- a/libinterp/corefcn/__lin_interpn__.cc
+++ b/libinterp/corefcn/__lin_interpn__.cc
@@ -246,17 +246,17 @@ lin_interpn (int n, M *X, const M V, M *
 
   return retval;
 }
 
 // Perform @var{n}-dimensional interpolation.  Each element of then
 // @var{n}-dimensional array @var{v} represents a value at a location
 // given by the parameters @var{x1}, @var{x2},...,@var{xn}.  The parameters
 // @var{x1}, @var{x2}, @dots{}, @var{xn} are either @var{n}-dimensional
-// arrays of the same size as the array @var{v} in the \"ndgrid\" format
+// arrays of the same size as the array @var{v} in the "ndgrid" format
 // or vectors.  The parameters @var{y1}, @var{y2}, @dots{}, @var{yn} are
 // all @var{n}-dimensional arrays of the same size and represent the
 // points at which the array @var{vi} is interpolated.
 //
 //This function only performs linear interpolation.
 
 DEFUN (__lin_interpn__, args, ,
        doc: /* -*- texinfo -*-
diff --git a/libinterp/corefcn/cellfun.cc b/libinterp/corefcn/cellfun.cc
--- a/libinterp/corefcn/cellfun.cc
+++ b/libinterp/corefcn/cellfun.cc
@@ -177,17 +177,17 @@ try_cellfun_internal_ops (const octave_v
       NDA result (f_args.dims ());
       for (octave_idx_type count = 0; count < k; count++)
         result(count) = static_cast<double> (f_args.elem (count).numel ());
       retval(0) = result;
     }
   else if (name == "size")
     {
       if (nargin != 3)
-        error ("cellfun: not enough arguments for \"size\"");
+        error (R"(cellfun: not enough arguments for "size")");
 
       int d = args(2).nint_value () - 1;
 
       if (d < 0)
         error ("cellfun: K must be a positive integer");
 
       NDA result (f_args.dims ());
 
@@ -200,17 +200,17 @@ try_cellfun_internal_ops (const octave_v
             result(count) = 1.0;
         }
 
       retval(0) = result;
     }
   else if (name == "isclass")
     {
       if (nargin != 3)
-        error ("cellfun: not enough arguments for \"isclass\"");
+        error (R"(cellfun: not enough arguments for "isclass")");
 
       std::string class_name = args(2).string_value ();
       BNDA result (f_args.dims ());
       for (octave_idx_type count = 0; count < k; count++)
         result(count) = (f_args.elem (count).class_name () == class_name);
 
       retval(0) = result;
     }
diff --git a/libinterp/corefcn/colloc.cc b/libinterp/corefcn/colloc.cc
--- a/libinterp/corefcn/colloc.cc
+++ b/libinterp/corefcn/colloc.cc
@@ -68,17 +68,17 @@ Reference: @nospell{J. Villadsen}, @nosp
       std::string s = args(i).xstring_value ("colloc: optional arguments must be strings");
 
       if ((s.length () == 1 && (s[0] == 'R' || s[0] == 'r')) || s == "right")
         right = 1;
       else if ((s.length () == 1 && (s[0] == 'L' || s[0] == 'l'))
                || s == "left")
         left = 1;
       else
-        error ("colloc: string argument must be \"left\" or \"right\"");
+        error (R"(colloc: string argument must be "left" or "right")");
     }
 
   ntot += left + right;
   if (ntot < 1)
     error ("colloc: the total number of roots must be positive");
 
   CollocWt wts (ncol, left, right);
 
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -6425,17 +6425,17 @@ ordered lists.
       if (have_sortmode)
         {
           std::string mode = args(1).string_value ();
           if (mode == "ascend")
             smode = ASCENDING;
           else if (mode == "descend")
             smode = DESCENDING;
           else
-            error ("sort: MODE must be either \"ascend\" or \"descend\"");
+            error (R"(sort: MODE must be either "ascend" or "descend")");
         }
       else
         dim = args(1).nint_value () - 1;
     }
 
   if (nargin > 2)
     {
       if (have_sortmode)
@@ -6443,17 +6443,17 @@ ordered lists.
 
       std::string mode = args(2).xstring_value ("sort: MODE must be a string");
 
       if (mode == "ascend")
         smode = ASCENDING;
       else if (mode == "descend")
         smode = DESCENDING;
       else
-        error ("sort: MODE must be either \"ascend\" or \"descend\"");
+        error (R"(sort: MODE must be either "ascend" or "descend")");
     }
 
   const dim_vector dv = arg.dims ();
   if (nargin == 1 || have_sortmode)
     {
       dim = dv.first_non_singleton ();
     }
   else
@@ -6679,17 +6679,17 @@ Undocumented internal function.
   if (nargin > 1)
     {
       std::string mode = args(1).string_value ();
       if (mode == "ascend")
         smode = ASCENDING;
       else if (mode == "descend")
         smode = DESCENDING;
       else
-        error ("__sort_rows_idx__: MODE must be either \"ascend\" or \"descend\"");
+        error (R"(__sort_rows_idx__: MODE must be either "ascend" or "descend")");
     }
 
   octave_value arg = args(0);
 
   if (arg.issparse ())
     error ("__sort_rows_idx__: sparse matrices not yet supported");
 
   if (arg.ndims () != 2)
@@ -6713,17 +6713,17 @@ get_sort_mode_option (const octave_value
 
   if (mode == "ascending")
     smode = ASCENDING;
   else if (mode == "descending")
     smode = DESCENDING;
   else if (mode == "either")
     smode = UNSORTED;
   else
-    error ("issorted: MODE must be \"ascending\", \"descending\", or \"either\"");
+    error (R"(issorted: MODE must be "ascending", "descending", or "either")");
 
   return smode;
 }
 
 DEFUN (issorted, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} issorted (@var{a})
 @deftypefnx {} {} issorted (@var{a}, @var{mode})
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -276,17 +276,17 @@ identifier.
 
   std::string fulldir = octave::sys::file_ops::tilde_expand (dirname);
   int status = -1;
   std::string msg;
 
   if (nargin == 2)
     {
       if (args(1).string_value () != "s")
-        error ("rmdir: second argument must be \"s\" for recursive removal");
+        error (R"(rmdir: second argument must be "s" for recursive removal)");
 
       bool doit = true;
 
       if (octave::application::interactive ()
           && ! octave::application::forced_interactive ()
           && Vconfirm_recursive_rmdir)
         {
           std::string prompt = "remove entire contents of " + fulldir + "? ";
@@ -639,17 +639,17 @@ It is @samp{/} (forward slash) under UNI
   octave_value retval;
 
   if (nargin == 0)
     retval = octave::sys::file_ops::dir_sep_str ();
   else
     {
       std::string s = args(0).xstring_value ("filesep: argument must be a string");
       if (s != "all")
-        error ("filesep: argument must be \"all\"");
+        error (R"(filesep: argument must be "all")");
 
       retval = octave::sys::file_ops::dir_sep_chars ();
     }
 
   return retval;
 }
 
 DEFUN (pathsep, args, ,
diff --git a/libinterp/corefcn/eig.cc b/libinterp/corefcn/eig.cc
--- a/libinterp/corefcn/eig.cc
+++ b/libinterp/corefcn/eig.cc
@@ -155,39 +155,39 @@ The eigenvalues returned by @code{eig} a
         balance_flag = true;
       else if (octave::string::strcmpi (arg_i, "nobalance"))
         no_balance_flag = true;
       else if (octave::string::strcmpi (arg_i, "matrix"))
         matrix_flag = true;
       else if (octave::string::strcmpi (arg_i, "vector"))
         vector_flag = true;
       else
-        error ("eig: invalid option \"%s\"", arg_i.c_str ());
+        error (R"(eig: invalid option "%s")", arg_i.c_str ());
     }
 
   if (balance_flag && no_balance_flag)
-    error ("eig: \"balance\" and \"nobalance\" options are mutually exclusive");
+    error (R"(eig: "balance" and "nobalance" options are mutually exclusive)");
   if (vector_flag && matrix_flag)
-    error ("eig: \"vector\" and \"matrix\" options are mutually exclusive");
+    error (R"(eig: "vector" and "matrix" options are mutually exclusive)");
   if (qz_flag && chol_flag)
-    error ("eig: \"qz\" and \"chol\" options are mutually exclusive");
+    error (R"(eig: "qz" and "chol" options are mutually exclusive)");
 
   if (AEPcase)
     {
       if (qz_flag)
-        error ("eig: invalid \"qz\" option for algebraic eigenvalue problem");
+        error (R"(eig: invalid "qz" option for algebraic eigenvalue problem)");
       if (chol_flag)
-        error ("eig: invalid \"chol\" option for algebraic eigenvalue problem");
+        error (R"(eig: invalid "chol" option for algebraic eigenvalue problem)");
     }
   else
     {
       if (balance_flag)
-        error ("eig: invalid \"balance\" option for generalized eigenvalue problem");
+        error (R"(eig: invalid "balance" option for generalized eigenvalue problem)");
       if (no_balance_flag)
-        error ("eig: invalid \"nobalance\" option for generalized eigenvalue problem");
+        error (R"(eig: invalid "nobalance" option for generalized eigenvalue problem)");
     }
 
   // Default is to balance
   const bool balance = (no_balance_flag ? false : true);
   const bool force_qz = qz_flag;
 
 
   Matrix tmp_a, tmp_b;
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -116,35 +116,35 @@ normalize_fopen_mode (std::string& mode,
       // them because Matlab says they don't perform "automatic
       // flushing" but we don't know precisely what action that implies.
 
       size_t pos = mode.find ('W');
 
       if (pos != std::string::npos)
         {
           warning_with_id ("Octave:fopen-mode",
-                           "fopen: treating mode \"W\" as equivalent to \"w\"");
+                           R"(fopen: treating mode "W" as equivalent to "w")");
           mode[pos] = 'w';
         }
 
       pos = mode.find ('R');
 
       if (pos != std::string::npos)
         {
           warning_with_id ("Octave:fopen-mode",
-                           "fopen: treating mode \"R\" as equivalent to \"r\"");
+                           R"(fopen: treating mode "R" as equivalent to "r")");
           mode[pos] = 'r';
         }
 
       pos = mode.find ('A');
 
       if (pos != std::string::npos)
         {
           warning_with_id ("Octave:fopen-mode",
-                           "fopen: treating mode \"A\" as equivalent to \"a\"");
+                           R"(fopen: treating mode "A" as equivalent to "a")");
           mode[pos] = 'a';
         }
 
       pos = mode.find ('z');
 
       if (pos != std::string::npos)
         {
 #if defined (HAVE_ZLIB)
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -413,17 +413,17 @@ b = sparse (i, j, v, sz(1), sz(2));
 
       std::string s_arg = args(2).string_value ();
 
       if (s_arg == "first")
         direction = 1;
       else if (s_arg == "last")
         direction = -1;
       else
-        error ("find: DIRECTION must be \"first\" or \"last\"");
+        error (R"(find: DIRECTION must be "first" or "last")");
     }
 
   octave_value_list retval;
 
   octave_value arg = args(0);
 
   if (arg.islogical ())
     {
diff --git a/libinterp/corefcn/gammainc.cc b/libinterp/corefcn/gammainc.cc
--- a/libinterp/corefcn/gammainc.cc
+++ b/libinterp/corefcn/gammainc.cc
@@ -81,26 +81,26 @@ gammainc (@var{x}, @var{a}) @equiv{} 1 -
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
   bool lower = true;
   if (nargin == 3)
     {
-      std::string s = args(2).xstring_value ("gammainc: third argument must be \"lower\" or \"upper\"");
+      std::string s = args(2).xstring_value (R"(gammainc: third argument must be "lower" or "upper")");
 
       std::transform (s.begin (), s.end (), s.begin (), tolower);
 
       if (s == "upper")
         lower = false;
       else if (s == "lower")
         lower = true;
       else
-        error ("gammainc: third argument must be \"lower\" or \"upper\"");
+        error (R"(gammainc: third argument must be "lower" or "upper")");
     }
 
   octave_value retval;
 
   octave_value x_arg = args(0);
   octave_value a_arg = args(1);
 
   // FIXME: Can we make a template version of the duplicated code below
diff --git a/libinterp/corefcn/gl2ps-print.cc b/libinterp/corefcn/gl2ps-print.cc
--- a/libinterp/corefcn/gl2ps-print.cc
+++ b/libinterp/corefcn/gl2ps-print.cc
@@ -855,28 +855,28 @@ namespace octave
       {
         // Create process and pipe gl2ps output to it.
 
         std::string cmd = stream.substr (1);
 
         fp = octave_popen (cmd.c_str (), "w");
 
         if (! fp)
-          error ("print: failed to open pipe \"%s\"", stream.c_str ());
+          error (R"(print: failed to open pipe "%s")", stream.c_str ());
 
         frame.add_fcn (safe_pclose, fp);
       }
     else
       {
         // Write gl2ps output directly to file.
 
         fp = std::fopen (stream.c_str (), "w");
 
         if (! fp)
-          error ("gl2ps_print: failed to create file \"%s\"", stream.c_str ());
+          error (R"(gl2ps_print: failed to create file "%s")", stream.c_str ());
 
         frame.add_fcn (safe_fclose, fp);
       }
 
     gl2ps_renderer rend (fp, term);
 
     rend.draw (fig, stream);
 
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1304,17 +1304,17 @@ color_values::str2rgb (const std::string
 bool
 color_property::do_set (const octave_value& val)
 {
   if (val.is_string ())
     {
       std::string s = val.string_value ();
 
       if (s.empty ())
-        error ("invalid value for color property \"%s\"",
+        error (R"(invalid value for color property "%s")",
                get_name ().c_str ());
 
       std::string match;
 
       if (radio_val.contains (s, match))
         {
           if (current_type != radio_t || match != current_val)
             {
@@ -1338,55 +1338,55 @@ color_property::do_set (const octave_val
                 {
                   color_val = col;
                   current_type = color_t;
                   return true;
                 }
             }
           catch (octave::execution_exception& e)
             {
-              error (e, "invalid value for color property \"%s\" (value = %s)",
+              error (e, R"(invalid value for color property "%s" (value = %s))",
                      get_name ().c_str (), s.c_str ());
             }
         }
     }
   else if (val.isnumeric ())
     {
       Matrix m = val.matrix_value ();
 
       if (m.numel () != 3)
-        error ("invalid value for color property \"%s\"",
+        error (R"(invalid value for color property "%s")",
                get_name ().c_str ());
 
       color_values col (m(0), m(1), m(2));
 
       if (current_type != color_t || col != color_val)
         {
           color_val = col;
           current_type = color_t;
           return true;
         }
     }
   else
-    error ("invalid value for color property \"%s\"",
+    error (R"(invalid value for color property "%s")",
            get_name ().c_str ());
 
   return false;
 }
 
 bool
 double_radio_property::do_set (const octave_value& val)
 {
   if (val.is_string ())
     {
       std::string s = val.string_value ();
       std::string match;
 
       if (s.empty () || ! radio_val.contains (s, match))
-        error ("invalid value for double_radio property \"%s\"",
+        error (R"(invalid value for double_radio property "%s")",
                get_name ().c_str ());
 
       if (current_type != radio_t || match != current_val)
         {
           if (s.length () != match.length ())
             warning_with_id ("Octave:abbreviated-property-match",
                              "%s: allowing %s to match %s value %s",
                              "set", s.c_str (), get_name ().c_str (),
@@ -1403,17 +1403,17 @@ double_radio_property::do_set (const oct
       if (current_type != double_t || new_dval != dval)
         {
           dval = new_dval;
           current_type = double_t;
           return true;
         }
     }
   else
-    error ("invalid value for double_radio property \"%s\"",
+    error (R"(invalid value for double_radio property "%s")",
            get_name ().c_str ());
 
   return false;
 }
 
 bool
 array_property::validate (const octave_value& v)
 {
@@ -1472,52 +1472,52 @@ array_property::validate (const octave_v
   if (xok)
     {
       NDArray v_mat = v.array_value ();
       // Check min and max
       if (! octave::math::isnan (minval.first))
         {
           for (octave_idx_type i = 0; i < v_mat.numel (); i++)
             if (minval.second && minval.first > v_mat(i))
-              error ("set: \"%s\" must be greater than or equal to %g",
+              error (R"(set: "%s" must be greater than or equal to %g)",
                      get_name ().c_str (), minval.first);
             else if (! minval.second && minval.first >= v_mat(i))
-              error ("set: \"%s\" must be greater than %g",
+              error (R"(set: "%s" must be greater than %g)",
                      get_name ().c_str (), minval.first);
         }
 
       if (! octave::math::isnan (maxval.first))
         {
           for (octave_idx_type i = 0; i < v_mat.numel (); i++)
             if (maxval.second && maxval.first < v_mat(i))
-              error ("set: \"%s\" must be less than or equal to %g",
+              error (R"(set: "%s" must be less than or equal to %g)",
                      get_name ().c_str (), maxval.first);
             else if (! maxval.second && maxval.first <= v_mat(i))
-              error ("set: \"%s\" must be less than %g",
+              error (R"(set: "%s" must be less than %g)",
                      get_name ().c_str (), maxval.first);
         }
 
       if (finite_constraint == NO_CHECK) { /* do nothing */ }
       else if (finite_constraint == FINITE)
         {
           for (octave_idx_type i = 0; i < v_mat.numel (); i++)
             if (! octave::math::isfinite (v_mat(i)))
-              error ("set: \"%s\" must be finite", get_name ().c_str ());
+              error (R"(set: "%s" must be finite)", get_name ().c_str ());
         }
       else if (finite_constraint == NOT_NAN)
         {
           for (octave_idx_type i = 0; i < v_mat.numel (); i++)
             if (octave::math::isnan (v_mat(i)))
-              error ("set: \"%s\" must not be nan", get_name ().c_str ());
+              error (R"(set: "%s" must not be nan)", get_name ().c_str ());
         }
       else if (finite_constraint == NOT_INF)
         {
           for (octave_idx_type i = 0; i < v_mat.numel (); i++)
             if (octave::math::isinf (v_mat(i)))
-              error ("set: \"%s\" must not be infinite", get_name ().c_str ());
+              error (R"(set: "%s" must not be infinite)", get_name ().c_str ());
         }
 
     }
 
   return xok;
 }
 
 bool
@@ -1629,17 +1629,17 @@ handle_property::do_set (const octave_va
         {
           current_val = graphics_handle ();
           return true;
         }
       else
         return false;
     }
 
-  double dv = v.xdouble_value ("set: invalid graphics handle for property \"%s\"",
+  double dv = v.xdouble_value (R"(set: invalid graphics handle for property "%s")",
                                get_name ().c_str ());
 
   graphics_handle gh = gh_manager::lookup (dv);
 
   // Check the object type if necessary
   bool type_ok = true;
   if (gh.ok () && ! type_constraints.empty ())
     {
@@ -1652,20 +1652,20 @@ handle_property::do_set (const octave_va
             type_ok = true;
             break;
           }
     }
 
   if (! octave::math::isnan (gh.value ()) && ! (gh.ok () && type_ok))
     {
       if (type_ok)
-        error ("set: invalid graphics handle (= %g) for property \"%s\"",
+        error (R"(set: invalid graphics handle (= %g) for property "%s")",
                dv, get_name ().c_str ());
       else
-        error ("set: invalid graphics object type for property \"%s\"",
+        error (R"(set: invalid graphics object type for property "%s")",
                get_name ().c_str ());
     }
 
   if (current_val != gh)
     {
       current_val = gh;
       return true;
     }
@@ -3040,17 +3040,17 @@ base_properties::set_from_list (base_gra
 
 octave_value
 base_properties::get_dynamic (const caseless_str& pname) const
 {
   std::map<caseless_str, property, cmp_caseless_str>::const_iterator it =
     all_props.find (pname);
 
   if (it == all_props.end ())
-    error ("get: unknown property \"%s\"", pname.c_str ());
+    error (R"(get: unknown property "%s")", pname.c_str ());
 
   return it->second.get ();
 }
 
 octave_value
 base_properties::get_dynamic (bool all) const
 {
   octave_scalar_map m;
@@ -3083,33 +3083,33 @@ base_properties::has_dynamic_property (c
 void
 base_properties::set_dynamic (const caseless_str& pname,
                               const octave_value& val)
 {
   std::map<caseless_str, property, cmp_caseless_str>::iterator it =
     all_props.find (pname);
 
   if (it == all_props.end ())
-    error ("set: unknown property \"%s\"", pname.c_str ());
+    error (R"(set: unknown property "%s")", pname.c_str ());
 
   it->second.set (val);
 
   dynamic_properties.insert (pname);
 
   mark_modified ();
 }
 
 property
 base_properties::get_property_dynamic (const caseless_str& pname)
 {
   std::map<caseless_str, property, cmp_caseless_str>::const_iterator it =
     all_props.find (pname);
 
   if (it == all_props.end ())
-    error ("get_property: unknown property \"%s\"", pname.c_str ());
+    error (R"(get_property: unknown property "%s")", pname.c_str ());
 
   return it->second;
 }
 
 void
 base_properties::set_parent (const octave_value& val)
 {
   double hp = val.xdouble_value ("set: parent must be a graphics handle");
@@ -8560,17 +8560,17 @@ patch::properties::update_data (void)
 
   octave_idx_type nfaces = idx.columns ();
   octave_idx_type nvert = vert.rows ();
 
   // Check all vertices in faces are defined
   bad_data_msg = "";
   if (static_cast<double> (nvert) < idx.row_max ().max ())
     {
-      bad_data_msg = "some vertices in \"faces\" property are undefined";
+      bad_data_msg = R"(some vertices in "faces" property are undefined)";
       return;
     }
 
   // Replace NaNs
   if (idx.any_element_is_inf_or_nan ())
     {
       for (octave_idx_type jj = 0; jj < idx.columns (); jj++)
         {
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -307,27 +307,27 @@ public:
 
   // Sets property value, notifies graphics toolkit.
   // If do_run is true, runs associated listeners.
   OCTINTERP_API bool set (const octave_value& v, bool do_run = true,
                           bool do_notify_toolkit = true);
 
   virtual octave_value get (void) const
   {
-    error ("get: invalid property \"%s\"", name.c_str ());
+    error (R"(get: invalid property "%s")", name.c_str ());
   }
 
   virtual std::string values_as_string (void) const
   {
-    error ("values_as_string: invalid property \"%s\"", name.c_str ());
+    error (R"(values_as_string: invalid property "%s")", name.c_str ());
   }
 
   virtual Cell values_as_cell (void) const
   {
-    error ("values_as_cell: invalid property \"%s\"", name.c_str ());
+    error (R"(values_as_cell: invalid property "%s")", name.c_str ());
   }
 
   base_property& operator = (const octave_value& val)
   {
     set (val);
     return *this;
   }
 
@@ -391,17 +391,17 @@ public:
   OCTINTERP_API void run_listeners (listener_mode mode = POSTSET);
 
   virtual base_property * clone (void) const
   { return new base_property (*this); }
 
 protected:
   virtual bool do_set (const octave_value&)
   {
-    error ("set: invalid property \"%s\"", name.c_str ());
+    error (R"(set: invalid property "%s")", name.c_str ());
   }
 
 private:
   typedef std::map<listener_mode, octave_value_list> listener_map;
   typedef std::map<listener_mode, octave_value_list>::iterator
     listener_map_iterator;
   typedef std::map<listener_mode, octave_value_list>::const_iterator
     listener_map_const_iterator;
@@ -439,17 +439,17 @@ public:
   }
 
   base_property * clone (void) const { return new string_property (*this); }
 
 protected:
   bool do_set (const octave_value& val)
   {
     if (! val.is_string ())
-      error ("set: invalid string property value for \"%s\"",
+      error (R"(set: invalid string property value for "%s")",
              get_name ().c_str ());
 
     std::string new_str = val.string_value ();
 
     if (new_str != str)
       {
         str = new_str;
         return true;
@@ -492,17 +492,17 @@ public:
   }
 
   string_array_property (const std::string& s, const graphics_handle& h,
                          const Cell& c, const char& sep = '|',
                          const desired_enum& typ = string_t)
     : base_property (s, h), desired_type (typ), separator (sep), str ()
   {
     if (! c.iscellstr ())
-      error ("set: invalid order property value for \"%s\"",
+      error (R"(set: invalid order property value for "%s")",
              get_name ().c_str ());
 
     string_vector strings (c.numel ());
 
     for (octave_idx_type i = 0; i < c.numel (); i++)
       strings[i] = c(i).string_value ();
 
     str = strings;
@@ -644,17 +644,17 @@ protected:
 
         if (replace)
           {
             str = strings;
             return true;
           }
       }
     else
-      error ("set: invalid string property value for \"%s\"",
+      error (R"(set: invalid string property value for "%s")",
              get_name ().c_str ());
 
     return false;
   }
 
 private:
   desired_enum desired_type;
   char separator;
@@ -792,17 +792,17 @@ protected:
         NDArray nda;
 
         try
           {
             nda = val.array_value ();
           }
         catch (octave::execution_exception& e)
           {
-            error (e, "set: invalid string property value for \"%s\"",
+            error (e, R"(set: invalid string property value for "%s")",
                    get_name ().c_str ());
           }
 
         octave_idx_type nel = nda.numel ();
 
         value.resize (nel);
 
         for (octave_idx_type i = 0; i < nel; i++)
@@ -948,25 +948,25 @@ public:
   }
 
   base_property * clone (void) const { return new radio_property (*this); }
 
 protected:
   bool do_set (const octave_value& newval)
   {
     if (! newval.is_string ())
-      error ("set: invalid value for radio property \"%s\"",
+      error (R"(set: invalid value for radio property "%s")",
              get_name ().c_str ());
 
     std::string s = newval.string_value ();
 
     std::string match;
 
     if (! vals.validate (s, match))
-      error ("set: invalid value for radio property \"%s\" (value = %s)",
+      error (R"(set: invalid value for radio property "%s" (value = %s))",
              get_name ().c_str (), s.c_str ());
 
     if (match != current_val)
       {
         if (s.length () != match.length ())
           warning_with_id ("Octave:abbreviated-property-match",
                            "%s: allowing %s to match %s value %s",
                            "set", s.c_str (), get_name ().c_str (),
@@ -1206,57 +1206,57 @@ public:
 
   void add_constraint (const finite_type finite)
   { finite_constraint = finite; }
 
 protected:
   bool do_set (const octave_value& v)
   {
     if (! v.is_scalar_type () || ! v.isreal ())
-      error ("set: invalid value for double property \"%s\"",
+      error (R"(set: invalid value for double property "%s")",
              get_name ().c_str ());
 
     double new_val = v.double_value ();
 
     // Check min and max
     if (! octave::math::isnan (minval.first))
       {
         if (minval.second && minval.first > new_val)
-          error ("set: \"%s\" must be greater than or equal to %g",
+          error (R"(set: "%s" must be greater than or equal to %g)",
                  get_name ().c_str (), minval.first);
         else if (! minval.second && minval.first >= new_val)
-          error ("set: \"%s\" must be greater than %g",
+          error (R"(set: "%s" must be greater than %g)",
                  get_name ().c_str (), minval.first);
       }
 
     if (! octave::math::isnan (maxval.first))
       {
         if (maxval.second && maxval.first < new_val)
-          error ("set: \"%s\" must be less than or equal to %g",
+          error (R"(set: "%s" must be less than or equal to %g)",
                  get_name ().c_str (), maxval.first);
         else if (! maxval.second && maxval.first <= new_val)
-          error ("set: \"%s\" must be less than %g",
+          error (R"(set: "%s" must be less than %g)",
                  get_name ().c_str (), maxval.first);
       }
 
       if (finite_constraint == NO_CHECK) { /* do nothing */ }
       else if (finite_constraint == FINITE)
         {
           if (! octave::math::isfinite (new_val))
-            error ("set: \"%s\" must be finite", get_name ().c_str ());
+            error (R"(set: "%s" must be finite)", get_name ().c_str ());
         }
       else if (finite_constraint == NOT_NAN)
         {
           if (octave::math::isnan (new_val))
-            error ("set: \"%s\" must not be nan", get_name ().c_str ());
+            error (R"(set: "%s" must not be nan)", get_name ().c_str ());
         }
       else if (finite_constraint == NOT_INF)
         {
           if (octave::math::isinf (new_val))
-            error ("set: \"%s\" must not be infinite", get_name ().c_str ());
+            error (R"(set: "%s" must not be infinite)", get_name ().c_str ());
         }
 
     if (new_val != current_val)
       {
         current_val = new_val;
         return true;
       }
 
@@ -1444,17 +1444,17 @@ public:
   }
 
 protected:
   bool do_set (const octave_value& v)
   {
     octave_value tmp = (v.issparse () ? v.full_value () : v);
 
     if (! validate (tmp))
-      error ("invalid value for array property \"%s\"",
+      error (R"(invalid value for array property "%s")",
              get_name ().c_str ());
 
     // FIXME: should we check for actual data change?
     if (! is_equal (tmp))
       {
         data = tmp;
 
         get_data_limits ();
@@ -1912,17 +1912,17 @@ public:
   }
 
   base_property * clone (void) const { return new callback_property (*this); }
 
 protected:
   bool do_set (const octave_value& v)
   {
     if (! validate (v))
-      error ("invalid value for callback property \"%s\"",
+      error (R"(invalid value for callback property "%s")",
              get_name ().c_str ());
 
     callback = v;
     return true;
     return false;
   }
 
 private:
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -73,17 +73,17 @@ along with Octave; see the file COPYING.
 #include "default-defs.h"
 
 const static char * const operators[] =
 {
   "!",
   "~",
   "!=",
   "~=",
-  "\"",
+  R"(")",
   "#",
   "%",
   "#{",
   "%{",
   "#}",
   "%}",
   "...",
   "&",
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -521,17 +521,17 @@ initialize_command_input (void)
   // causes trouble for the new struct element completion code.
 
   static const char *s = "\t\n !\"\'*+-/:;<=>(){}[\\]^`~";
 
   octave::command_editor::set_basic_word_break_characters (s);
 
   octave::command_editor::set_completer_word_break_characters (s);
 
-  octave::command_editor::set_basic_quote_characters ("\"");
+  octave::command_editor::set_basic_quote_characters (R"(")");
 
   octave::command_editor::set_filename_quote_characters (" \t\n\\\"'@<>=;|&()#$`?*[!:{");
   octave::command_editor::set_completer_quote_characters ("'\"");
 
   octave::command_editor::set_completion_function (generate_completion);
 
   octave::command_editor::set_quoting_function (quoting_filename);
 }
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -322,17 +322,17 @@ namespace octave
   load_path::remove (const std::string& dir_arg)
   {
     bool retval = false;
 
     if (! dir_arg.empty ())
       {
         if (dir_arg == ".")
           {
-            warning ("rmpath: can't remove \".\" from path");
+            warning (R"(rmpath: can't remove "." from path)");
 
             // Avoid additional warnings.
             retval = true;
           }
         else
           {
             std::string dir = sys::file_ops::tilde_expand (dir_arg);
 
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -1124,25 +1124,25 @@ parse_save_options (const string_vector&
         retval.append (argv[i]);
     }
 
   if (do_double)
     {
       if (format == LS_MAT_ASCII)
         format.opts |= LS_MAT_ASCII_LONG;
       else
-        warning ("save: \"-double\" option only has an effect with \"-ascii\"");
+        warning (R"(save: "-double" option only has an effect with "-ascii")");
     }
 
   if (do_tabs)
     {
       if (format == LS_MAT_ASCII)
         format.opts |= LS_MAT_ASCII_TABS;
       else
-        warning ("save: \"-tabs\" option only has an effect with \"-ascii\"");
+        warning (R"(save: "-tabs" option only has an effect with "-ascii")");
     }
 
   return retval;
 }
 
 static string_vector
 parse_save_options (const std::string& arg, load_save_format& format,
                     bool& append, bool& save_as_floats, bool& use_zlib)
diff --git a/libinterp/corefcn/oct-hist.cc b/libinterp/corefcn/oct-hist.cc
--- a/libinterp/corefcn/oct-hist.cc
+++ b/libinterp/corefcn/oct-hist.cc
@@ -446,17 +446,17 @@ do_edit_history (octave::interpreter& in
 
   if (name.empty ())
     return;
 
   // Call up our favorite editor on the file of commands.
 
   octave::environment& env = interp.get_environment ();
   std::string cmd = env.editor ();
-  cmd.append (" \"" + name + "\"");
+  cmd.append (R"( ")" + name + '"');
 
   // Ignore interrupts while we are off editing commands.  Should we
   // maybe avoid using system()?
 
   volatile octave::interrupt_handler old_interrupt_handler
     = octave::ignore_interrupts ();
 
   int status = system (cmd.c_str ());
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -3218,30 +3218,30 @@ namespace octave
   // removed.  A consecutive pair "" is inserted into VAL as a single ".
 
   void
   textscan::scan_qstring (delimited_stream& is, const textscan_format_elt& fmt,
                           std::string& val)
   {
     skip_whitespace (is);
 
-    if (is.peek () != '\"')
+    if (is.peek () != '"')
       scan_string (is, fmt, val);
     else
       {
         is.get ();
-        scan_caret (is, "\"", val);       // read everything until "
+        scan_caret (is, R"(")", val);     // read everything until "
         is.get ();                        // swallow "
 
-        while (is && is.peek () == '\"')  // if double ", insert one in stream,
+        while (is && is.peek () == '"')  // if double ", insert one in stream,
           {                               // and keep looking for single "
             is.get ();
             std::string val1;
-            scan_caret (is, "\"", val1);
-            val = val + "\"" + val1;
+            scan_caret (is, R"(")", val1);
+            val = val + '"' + val1;
             is.get_undelim ();
           }
       }
   }
 
   // Read from IS into VAL a string of the next fmt.width characters,
   // including any whitespace or delimiters.
 
diff --git a/libinterp/corefcn/pager.cc b/libinterp/corefcn/pager.cc
--- a/libinterp/corefcn/pager.cc
+++ b/libinterp/corefcn/pager.cc
@@ -607,24 +607,24 @@ The current state can be determined via 
 {
   int nargin = args.length ();
 
   if (nargin > 1)
     print_usage ();
 
   if (nargin > 0)
     {
-      std::string arg = args(0).xstring_value ("more: argument must be string \"on\" or \"off\"");
+      std::string arg = args(0).xstring_value (R"(more: argument must be string "on" or "off")");
 
       if (arg == "on")
         Vpage_screen_output = true;
       else if (arg == "off")
         Vpage_screen_output = false;
       else
-        error ("more: argument must be \"on\" or \"off\"");
+        error (R"(more: argument must be "on" or "off")");
     }
   else
     Vpage_screen_output = ! Vpage_screen_output;
 
   return ovl ();
 }
 
 DEFUN (terminal_size, , ,
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -2801,17 +2801,17 @@ octave_print_internal (std::ostream& os,
           for (octave_idx_type i = 0; i < nstr; i++)
             {
               octave_quit ();
 
               std::string row = chm.row_as_string (i);
 
               if (pr_as_read_syntax)
                 {
-                  os << "\"" << undo_string_escapes (row) << "\"";
+                  os << '"' << undo_string_escapes (row) << '"';
 
                   if (i < nstr - 1)
                     os << "; ";
                 }
               else
                 {
                   os << row;
 
diff --git a/libinterp/corefcn/spparms.cc b/libinterp/corefcn/spparms.cc
--- a/libinterp/corefcn/spparms.cc
+++ b/libinterp/corefcn/spparms.cc
@@ -130,17 +130,17 @@ longer running time.
             str[i] = tolower (str[i]);
 
           if (str == "defaults" || str == "default")
             {
               // FIXME: deprecated in 4.0, remove "defaults" for 4.4 release
               static bool warned = false;
               if (! warned && str == "defaults")
                 {
-                  warning ("spparms: use \"default\" instead of \"defaults\"");
+                  warning (R"(spparms: use "default" instead of "defaults")");
                   warned = true;
                 }
               octave_sparse_params::defaults ();
             }
           else if (str == "tight")
             octave_sparse_params::tight ();
           else
             {
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -1897,17 +1897,17 @@ determine whether functions defined in f
 
       if (sval == "all")
         Vignore_function_time_stamp = 2;
       else if (sval == "system")
         Vignore_function_time_stamp = 1;
       else if (sval == "none")
         Vignore_function_time_stamp = 0;
       else
-        error ("ignore_function_time_stamp: argument must be one of \"all\", \"system\", or \"none\"");
+        error (R"(ignore_function_time_stamp: argument must be one of "all", "system", or "none")");
     }
 
   return retval;
 }
 
 /*
 %!shared old_state
 %! old_state = ignore_function_time_stamp ();
diff --git a/libinterp/corefcn/toplev.cc b/libinterp/corefcn/toplev.cc
--- a/libinterp/corefcn/toplev.cc
+++ b/libinterp/corefcn/toplev.cc
@@ -209,17 +209,17 @@ command shell that is started to run the
     {
       std::string type_str = args(2).xstring_value ("system: TYPE must be a string");
 
       if (type_str == "sync")
         type = et_sync;
       else if (type_str == "async")
         type = et_async;
       else
-        error ("system: TYPE must be \"sync\" or \"async\"");
+        error (R"(system: TYPE must be "sync" or "async")");
     }
 
   octave_value_list retval;
 
   // FIXME: Is this unwind_protect frame needed anymore (12/16/15)?
   octave::unwind_protect frame;
 
   bool return_output = (nargin == 1 && nargout > 1);
@@ -239,17 +239,17 @@ command shell that is started to run the
   if (return_output && type == et_async)
     error ("system: can't return output from commands run asynchronously");
 
   std::string cmd_str = args(0).xstring_value ("system: first argument must be a string");
 
 #if defined (OCTAVE_USE_WINDOWS_API)
   // Work around weird double-quote handling on Windows systems.
   if (type == et_sync)
-    cmd_str = "\"" + cmd_str + "\"";
+    cmd_str = '"' + cmd_str + '"';
 #endif
 
   if (type == et_async)
     retval(0) = octave_async_system_wrapper (cmd_str.c_str ());
   else if (return_output)
     retval = run_command_and_return_output (cmd_str);
   else
     {
diff --git a/libinterp/corefcn/tril.cc b/libinterp/corefcn/tril.cc
--- a/libinterp/corefcn/tril.cc
+++ b/libinterp/corefcn/tril.cc
@@ -126,17 +126,17 @@ do_triu (const Array<T>& a, octave_idx_t
 // These two are by David Bateman.
 // FIXME: optimizations possible. "pack" support missing.
 
 template <typename T>
 static Sparse<T>
 do_tril (const Sparse<T>& a, octave_idx_type k, bool pack)
 {
   if (pack) // FIXME
-    error ("tril: \"pack\" not implemented for sparse matrices");
+    error (R"(tril: "pack" not implemented for sparse matrices)");
 
   Sparse<T> m = a;
   octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
       if (m.ridx (i) < j-k)
         m.data(i) = 0.;
@@ -146,17 +146,17 @@ do_tril (const Sparse<T>& a, octave_idx_
   return m;
 }
 
 template <typename T>
 static Sparse<T>
 do_triu (const Sparse<T>& a, octave_idx_type k, bool pack)
 {
   if (pack) // FIXME
-    error ("triu: \"pack\" not implemented for sparse matrices");
+    error (R"(triu: "pack" not implemented for sparse matrices)");
 
   Sparse<T> m = a;
   octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
       if (m.ridx (i) > j-k)
         m.data(i) = 0.;
@@ -256,17 +256,17 @@ do_trilu (const std::string& name,
 
 #undef ARRAYCASE
 
     default:
       {
         // Generic code that works on octave-values, that is slow
         // but will also work on arbitrary user types
         if (pack) // FIXME
-          error ("%s: \"pack\" not implemented for class %s",
+          error (R"(%s: "pack" not implemented for class %s)",
                  name.c_str (), arg.class_name ().c_str ());
 
         octave_value tmp = arg;
         if (arg.isempty ())
           return arg;
 
         octave_idx_type nr = dims(0);
         octave_idx_type nc = dims(1);
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -123,17 +123,17 @@ urlwrite ("http://www.google.com/search"
   std::string method;
   Array<std::string> param;
 
   if (nargin == 4)
     {
       method = args(2).xstring_value ("urlwrite: METHOD must be a string");
 
       if (method != "get" && method != "post")
-        error ("urlwrite: METHOD must be \"get\" or \"post\"");
+        error (R"(urlwrite: METHOD must be "get" or "post")");
 
       param = args(3).xcellstr_value ("urlwrite: parameters (PARAM) for get and post requests must be given as a cell array of strings");
 
       if (param.numel () % 2 == 1)
         error ("urlwrite: number of elements in PARAM must be even");
     }
 
   // The file should only be deleted if it doesn't initially exist, we
@@ -234,17 +234,17 @@ s = urlread ("http://www.google.com/sear
   std::string method;
   Array<std::string> param;
 
   if (nargin == 3)
     {
       method = args(1).xstring_value ("urlread: METHOD must be a string");
 
       if (method != "get" && method != "post")
-        error ("urlread: METHOD must be \"get\" or \"post\"");
+        error (R"(urlread: METHOD must be "get" or "post")");
 
       param = args(2).xcellstr_value ("urlread: parameters (PARAM) for get and post requests must be given as a cell array of strings");
 
       if (param.numel () % 2 == 1)
         error ("urlread: number of elements in PARAM must be even");
     }
 
   std::ostringstream buf;
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -316,17 +316,17 @@ If no files are found, return an empty c
 
   if (nargin == 1)
     return ovl (octave::sys::env::make_absolute (lp.find_first_of (names)));
   else
     {
       std::string opt = args(1).xstring_value ("file_in_loadpath: optional second argument must be a string");
 
       if (opt != "all")
-        error ("file_in_loadpath: \"all\" is only valid second argument");
+        error (R"(file_in_loadpath: "all" is only valid second argument)");
 
       return ovl (Cell (make_absolute (lp.find_all_first_of (names))));
     }
 }
 
 /*
 %!test
 %! f = file_in_loadpath ("plot.m");
@@ -387,17 +387,17 @@ If no files are found, return an empty c
 
   if (nargin == 2)
     return ovl (search_path_for_file (path, names));
   else
     {
       std::string opt = args(2).xstring_value ("file_in_path: optional third argument must be a string");
 
       if (opt != "all")
-        error ("file_in_path: \"all\" is only valid third argument");
+        error (R"(file_in_path: "all" is only valid third argument)");
 
       return ovl (Cell (make_absolute (search_path_for_all_files (path, names))));
     }
 }
 
 /*
 %!test
 %! f = file_in_path (path (), "plot.m");
@@ -799,44 +799,44 @@ const char *
 undo_string_escape (char c)
 {
   if (! c)
     return "";
 
   switch (c)
     {
     case '\0':
-      return "\\0";
+      return R"(\0)";
 
     case '\a':
-      return "\\a";
+      return R"(\a)";
 
     case '\b': // backspace
-      return "\\b";
+      return R"(\b)";
 
     case '\f': // formfeed
-      return "\\f";
+      return R"(\f)";
 
     case '\n': // newline
-      return "\\n";
+      return R"(\n)";
 
     case '\r': // carriage return
-      return "\\r";
+      return R"(\r)";
 
     case '\t': // horizontal tab
-      return "\\t";
+      return R"(\t)";
 
     case '\v': // vertical tab
-      return "\\v";
+      return R"(\v)";
 
     case '\\': // backslash
-      return "\\\\";
+      return R"(\\)";
 
     case '"': // double quote
-      return "\\\"";
+      return R"(\")";
 
     default:
       {
         static char retval[2] = "\0";
 
         retval[0] = c;
         return retval;
       }
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -378,17 +378,17 @@ symbol_exist (octave::interpreter& inter
   bool search_var = type == "var";
   bool search_dir = type == "dir";
   bool search_file = type == "file";
   bool search_builtin = type == "builtin";
   bool search_class = type == "class";
 
   if (! (search_any || search_var || search_dir || search_file ||
          search_builtin || search_class))
-    error ("exist: unrecognized type argument \"%s\"", type.c_str ());
+    error (R"(exist: unrecognized type argument "%s")", type.c_str ());
 
   octave::symbol_table& symtab = interp.get_symbol_table ();
 
   if (search_any || search_var)
     {
       octave::symbol_table::scope *scope = symtab.current_scope ();
 
       octave_value val = scope ? scope->varval (name) : octave_value ();
@@ -589,17 +589,17 @@ them.
 
   std::string name = args(0).xstring_value ("exist: NAME must be a string");
 
   if (nargin == 2)
     {
       std::string type = args(1).xstring_value ("exist: TYPE must be a string");
 
       if (type == "class")
-        warning ("exist: \"class\" type argument is not implemented");
+        warning (R"(exist: "class" type argument is not implemented)");
 
       return ovl (symbol_exist (interp, name, type));
     }
   else
     return ovl (symbol_exist (interp, name));
 }
 
 /*
@@ -677,17 +677,17 @@ them.
 static bool
 wants_local_change (const octave_value_list& args, int& nargin)
 {
   bool retval = false;
 
   if (nargin == 2)
     {
       if (! args(1).is_string () || args(1).string_value () != "local")
-        error_with_cfn ("second argument must be \"local\"");
+        error_with_cfn (R"(second argument must be "local")");
 
       nargin = 1;
       retval = true;
     }
 
   return retval;
 }
 
@@ -730,17 +730,17 @@ set_internal_variable (bool& var, const 
   int nargin = args.length ();
 
   if (nargout > 0 || nargin == 0)
     retval = var;
 
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
-        warning ("\"local\" has no effect outside a function");
+        warning (R"("local" has no effect outside a function)");
     }
 
   if (nargin > 1)
     print_usage ();
 
   if (nargin == 1)
     {
       bool bval = args(0).xbool_value ("%s: argument must be a logical value", nm);
@@ -760,17 +760,17 @@ set_internal_variable (char& var, const 
   int nargin = args.length ();
 
   if (nargout > 0 || nargin == 0)
     retval = var;
 
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
-        warning ("\"local\" has no effect outside a function");
+        warning (R"("local" has no effect outside a function)");
     }
 
   if (nargin > 1)
     print_usage ();
 
   if (nargin == 1)
     {
       std::string sval = args(0).xstring_value ("%s: argument must be a single character", nm);
@@ -804,17 +804,17 @@ set_internal_variable (int& var, const o
   int nargin = args.length ();
 
   if (nargout > 0 || nargin == 0)
     retval = var;
 
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
-        warning ("\"local\" has no effect outside a function");
+        warning (R"("local" has no effect outside a function)");
     }
 
   if (nargin > 1)
     print_usage ();
 
   if (nargin == 1)
     {
       int ival = args(0).xint_value ("%s: argument must be an integer value", nm);
@@ -840,17 +840,17 @@ set_internal_variable (double& var, cons
   int nargin = args.length ();
 
   if (nargout > 0 || nargin == 0)
     retval = var;
 
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
-        warning ("\"local\" has no effect outside a function");
+        warning (R"("local" has no effect outside a function)");
     }
 
   if (nargin > 1)
     print_usage ();
 
   if (nargin == 1)
     {
       double dval = args(0).xscalar_value ("%s: argument must be a scalar value", nm);
@@ -875,17 +875,17 @@ set_internal_variable (std::string& var,
   int nargin = args.length ();
 
   if (nargout > 0 || nargin == 0)
     retval = var;
 
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
-        warning ("\"local\" has no effect outside a function");
+        warning (R"("local" has no effect outside a function)");
     }
 
   if (nargin > 1)
     print_usage ();
 
   if (nargin == 1)
     {
       std::string sval = args(0).xstring_value ("%s: first argument must be a string", nm);
@@ -913,17 +913,17 @@ set_internal_variable (int& var, const o
   assert (var < nchoices);
 
   if (nargout > 0 || nargin == 0)
     retval = choices[var];
 
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
-        warning ("\"local\" has no effect outside a function");
+        warning (R"("local" has no effect outside a function)");
     }
 
   if (nargin > 1)
     print_usage ();
 
   if (nargin == 1)
     {
       std::string sval = args(0).xstring_value ("%s: first argument must be a string", nm);
@@ -933,17 +933,17 @@ set_internal_variable (int& var, const o
         {
           if (sval == choices[i])
             {
               var = i;
               break;
             }
         }
       if (i == nchoices)
-        error ("%s: value not allowed (\"%s\")", nm, sval.c_str ());
+        error (R"(%s: value not allowed ("%s"))", nm, sval.c_str ());
     }
 
   return retval;
 }
 
 octave_value
 set_internal_variable (std::string& var, const octave_value_list& args,
                        int nargout, const char *nm, const char **choices)
@@ -956,17 +956,17 @@ set_internal_variable (std::string& var,
   int nargin = args.length ();
 
   if (nargout > 0 || nargin == 0)
     retval = var;
 
   if (wants_local_change (args, nargin))
     {
       if (! try_local_protect (var))
-        warning ("\"local\" has no effect outside a function");
+        warning (R"("local" has no effect outside a function)");
     }
 
   if (nargin > 1)
     print_usage ();
 
   if (nargin == 1)
     {
       std::string sval = args(0).xstring_value ("%s: first argument must be a string", nm);
@@ -976,17 +976,17 @@ set_internal_variable (std::string& var,
         {
           if (sval == choices[i])
             {
               var = sval;
               break;
             }
         }
       if (i == nchoices)
-        error ("%s: value not allowed (\"%s\")", nm, sval.c_str ());
+        error (R"(%s: value not allowed ("%s"))", nm, sval.c_str ());
     }
 
   return retval;
 }
 
 struct
 whos_parameter
 {
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -165,17 +165,17 @@ sparse matrices.
 
       if (octave::string::strcmpi (tmp, "vector"))
         vecout = true;
       else if (octave::string::strcmpi (tmp, "lower"))
         LLt = true;
       else if (octave::string::strcmpi (tmp, "upper"))
         LLt = false;
       else
-        error ("chol: optional argument must be one of \"vector\", \"lower\", or \"upper\"");
+        error (R"(chol: optional argument must be one of "vector", "lower", or "upper")");
     }
 
   octave_value_list retval;
   octave_value arg = args(0);
 
   if (arg.isempty ())
     return ovl (Matrix ());
 
@@ -236,17 +236,17 @@ sparse matrices.
             error ("chol: input matrix must be positive definite");
         }
       else
         err_wrong_type_arg ("chol", arg);
     }
   else if (arg.is_single_type ())
     {
       if (vecout)
-        error ("chol: A must be sparse for the \"vector\" option");
+        error (R"(chol: A must be sparse for the "vector" option)");
       if (arg.isreal ())
         {
           FloatMatrix m = arg.float_matrix_value ();
 
           octave_idx_type info;
 
           octave::math::chol<FloatMatrix> fact (m, info, LLt != true);
 
@@ -269,17 +269,17 @@ sparse matrices.
             error ("chol: input matrix must be positive definite");
         }
       else
         err_wrong_type_arg ("chol", arg);
     }
   else
     {
       if (vecout)
-        error ("chol: A must be sparse for the \"vector\" option");
+        error (R"(chol: A must be sparse for the "vector" option)");
       if (arg.isreal ())
         {
           Matrix m = arg.matrix_value ();
 
           octave_idx_type info;
 
           octave::math::chol<Matrix> fact (m, info, LLt != true);
 
@@ -637,17 +637,17 @@ If @var{info} is not present, an error m
 
   octave_idx_type n = argr.rows ();
 
   std::string op = (nargin < 3) ? "+" : args(2).string_value ();
 
   bool down = (op == "-");
 
   if (! down && op != "+")
-    error ("cholupdate: OP must be \"+\" or \"-\"");
+    error (R"(cholupdate: OP must be "+" or "-")");
 
   if (argr.columns () != n || argu.rows () != n || argu.columns () != 1)
     error ("cholupdate: dimension mismatch between R and U");
 
   int err = 0;
   if (argr.is_single_type () || argu.is_single_type ())
     {
       if (argr.isreal () && argu.isreal ())
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -1082,17 +1082,17 @@ If @var{orient} is @qcode{"row"}, full f
       || ! argx.isnumeric ()
       || (nargin > 4 && ! args(4).is_string ()))
     print_usage ();
 
   std::string orient = (nargin < 5) ? "col" : args(4).string_value ();
   bool col = (orient == "col");
 
   if (! col && orient != "row")
-    error ("qrinsert: ORIENT must be \"col\" or \"row\"");
+    error (R"(qrinsert: ORIENT must be "col" or "row")");
 
   if (! check_qr_dims (argq, argr, col) || (! col && argx.rows () != 1))
     error ("qrinsert: dimension mismatch");
 
   if (! check_index (argj, col))
     error ("qrinsert: invalid index J");
 
   octave_value_list retval;
@@ -1276,17 +1276,17 @@ If @var{orient} is @qcode{"row"}, full f
   if (! argq.isnumeric () || ! argr.isnumeric ()
       || (nargin > 3 && ! args(3).is_string ()))
     print_usage ();
 
   std::string orient = (nargin < 4) ? "col" : args(3).string_value ();
   bool col = orient == "col";
 
   if (! col && orient != "row")
-    error ("qrdelete: ORIENT must be \"col\" or \"row\"");
+    error (R"(qrdelete: ORIENT must be "col" or "row")");
 
   if (! check_qr_dims (argq, argr, col))
     error ("qrdelete: dimension mismatch");
 
   MArray<octave_idx_type> j = argj.octave_idx_type_vector_value ();
   if (! check_index (argj, col))
     error ("qrdelete: invalid index J");
 
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -177,27 +177,27 @@ Cholesky@tie{}factorization as determine
           coletree = true;
           A->stype = 0;
         }
       else if (ch == 's')     // 'sym' (default)
         A->stype = 1;
       else if (ch == 'l')     // 'lo'
         A->stype = -1;
       else
-        error ("symbfact: unrecognized TYP \"%s\"", str.c_str ());
+        error (R"(symbfact: unrecognized TYP "%s")", str.c_str ());
     }
 
   if (nargin == 3)
     {
       std::string str = args(2).xstring_value ("MODE must be a string");
       // FIXME: The input validation could be improved to use strncmp
       char ch;
       ch = toupper (str[0]);
       if (ch != 'L')
-        error ("symbfact: unrecognized MODE \"%s\"", str.c_str ());
+        error (R"(symbfact: unrecognized MODE "%s")", str.c_str ());
     }
 
   if (A->stype && A->nrow != A->ncol)
     err_square_matrix_required ("symbfact", "S");
 
   OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, Parent, n);
   OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, Post, n);
   OCTAVE_LOCAL_BUFFER (octave::suitesparse_integer, ColCount, n);
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -1720,17 +1720,17 @@ produces a struct @strong{array}.
         return ovl (octave_map (args(0).dims ()));
     }
 
   // Check for "field", VALUE pairs.
 
   for (int i = 0; i < nargin; i += 2)
     {
       if (! args(i).is_string () || i + 1 >= nargin)
-        error ("struct: additional arguments must occur as \"field\", VALUE pairs");
+        error (R"(struct: additional arguments must occur as "field", VALUE pairs)");
     }
 
   // Check that the dimensions of the values correspond.
 
   dim_vector dims (1, 1);
 
   int first_dimensioned_value = 0;
 
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -357,17 +357,17 @@ namespace octave
     std::string code_to_eval = m_options.code_to_eval ();
 
     m_have_script_file = ! remaining_args.empty ();
 
     m_have_eval_option_code = ! code_to_eval.empty ();
 
     if (m_have_eval_option_code && m_have_script_file)
       {
-        warning ("--eval \"CODE\" and script file are mutually exclusive options");
+        warning (R"(--eval "CODE" and script file are mutually exclusive options)");
 
         octave_print_terse_usage_and_exit ();
       }
 
     m_is_octave_program = ((m_have_script_file || m_have_eval_option_code)
                            && ! m_options.persist ()
                            && ! m_options.traditional ());
 
diff --git a/libinterp/parse-tree/pt-id.h b/libinterp/parse-tree/pt-id.h
--- a/libinterp/parse-tree/pt-id.h
+++ b/libinterp/parse-tree/pt-id.h
@@ -112,17 +112,17 @@ namespace octave
     bool lvalue_ok (void) const { return true; }
 
     octave_lvalue lvalue (tree_evaluator *);
 
     void eval_undefined_error (void);
 
     void static_workspace_error (void)
     {
-      error ("can not add variable \"%s\" to a static workspace",
+      error (R"(can not add variable "%s" to a static workspace)",
              name ().c_str ());
     }
 
     tree_identifier * dup (symbol_table::scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_identifier (*this);
diff --git a/libinterp/version.cc b/libinterp/version.cc
--- a/libinterp/version.cc
+++ b/libinterp/version.cc
@@ -35,17 +35,17 @@ octave_warranty_statement (const std::st
   return "There is ABSOLUTELY NO WARRANTY; not even for MERCHANTABILITY or\n\
 FITNESS FOR A PARTICULAR PURPOSE."
          + extra_info;
 }
 
 static std::string
 format_url (bool html, const std::string& url)
 {
-  return html ? "<a href=\"" + url + "\">" + url + "</a>" : url;
+  return html ? R"(<a href=")" + url + R"(">)" + url + "</a>" : url;
 }
 
 std::string
 octave_www_statement (bool html)
 {
   return "Additional information about Octave is available at "
          + format_url (html, "http://www.octave.org.");
 }
@@ -83,19 +83,19 @@ octave_name_version_copyright_copying_an
   std::string sep = (html ? "\n</p>\n<p>\n" : "\n\n");
 
   return octave_name_version_and_copyright ()
          + br
          + "This is free software; see the source code for copying conditions."
          + br
          + octave_warranty_statement (extra_info)
          + sep
-         + "Octave was configured for \""
+         + R"(Octave was configured for ")"
          + octave::config::canonical_host_type ()
-         + "\".";
+         + R"(".)";
 }
 
 std::string
 octave_name_version_copyright_copying_warranty_and_bugs
   (bool html, const std::string& extra_info)
 {
   std::string sep = (html ? "\n</p>\n<p>\n" : "\n\n");
 
diff --git a/src/mkoctfile.in.cc b/src/mkoctfile.in.cc
--- a/src/mkoctfile.in.cc
+++ b/src/mkoctfile.in.cc
@@ -115,17 +115,17 @@ get_variable (const char *name, const st
   else
     return defval;
 }
 
 static std::string
 quote_path (const std::string& s)
 {
   if (s.find (' ') != std::string::npos && s[0] != '"')
-    return "\"" + s + "\"";
+    return '"' + s + '"';
   else
     return s;
 }
 
 static void
 initialize (void)
 {
   set_octave_home ();
