# HG changeset patch
# User Rik <rik@octave.org>
# Date 1450126769 28800
#      Mon Dec 14 12:59:29 2015 -0800
# Node ID 384ff5aa9437fcb83d89d541cf4111f70acfcc33
# Parent  c07bee629973c176e9a492c2576b62b1e05de645
2015 Code Sprint: Eliminate useless return statements after error ().

* data.cc, graphics.cc, graphics.in.h, ls-mat4.cc, ls-mat5.cc, oct-fstrm.cc,
oct-stream.cc, oct-strstrm.cc, __delaunayn__.cc, ov-base-int.cc, ov-classdef.h,
ov-complex.cc, ov-cx-sparse.cc, ov-fcn-inline.cc, ov-float.cc,
ov-flt-complex.cc, ov-java.cc, ov-range.cc, ov-re-sparse.cc, ov-scalar.cc,
ov-struct.cc, ov-usr-fcn.cc, ov.cc, op-cm-cm.cc, op-cm-m.cc, op-cm-scm.cc,
op-cm-sm.cc, op-fcm-fcm.cc, op-fcm-fm.cc, op-fm-fcm.cc, op-fm-fm.cc,
op-m-cm.cc, op-m-m.cc, op-m-scm.cc, op-m-sm.cc, op-scm-cm.cc, op-scm-m.cc,
op-scm-scm.cc, op-scm-sm.cc, op-sm-cm.cc, op-sm-m.cc, op-sm-scm.cc,
op-sm-sm.cc, pt-exp.cc:
Eliminate useless return statements after error ().

diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -2056,21 +2056,17 @@ do_cat (const octave_value_list& xargs, 
             {
               concat_rule = &dim_vector::hvcat;
               dim = -dim - 1;
             }
 
           for (int i = 1; i < args.length (); i++)
             {
               if (! (dv.*concat_rule) (args(i).dims (), dim))
-                {
-                  // Dimensions do not match.
-                  error ("cat: dimension mismatch");
-                  return retval;
-                }
+                error ("cat: dimension mismatch");
             }
 
           // The lines below might seem crazy, since we take a copy
           // of the first argument, resize it to be empty and then resize
           // it to be full. This is done since it means that there is no
           // recopying of data, as would happen if we used a single resize.
           // It should be noted that resize operation is also significantly
           // slower than the do_cat_op function, so it makes sense to have
@@ -5344,20 +5340,17 @@ the unspecified dimension.\n\
 
   dim_vector new_dims;
 
   if (nargin == 2)
     {
       Array<octave_idx_type> new_size = args(1).octave_idx_type_vector_value ();
 
       if (new_size.numel () < 2)
-        {
-          error ("reshape: SIZE must have 2 or more dimensions");
-          return retval;
-        }
+        error ("reshape: SIZE must have 2 or more dimensions");
 
       new_dims = dim_vector::alloc (new_size.numel ());
 
       for (octave_idx_type i = 0; i < new_size.numel (); i++)
         {
           if (new_size(i) < 0)
             {
               error ("reshape: SIZE must be non-negative");
@@ -6720,20 +6713,17 @@ Undocumented internal function.\n\
   if (nargin > 1)
     {
       std::string mode = args(1).string_value ();
       if (mode == "ascend")
         smode = ASCENDING;
       else if (mode == "descend")
         smode = DESCENDING;
       else
-        {
           error ("__sort_rows_idx__: MODE must be either \"ascend\" or \"descend\"");
-          return retval;
-        }
     }
 
   octave_value arg = args(0);
 
   if (arg.is_sparse_type ())
     error ("__sort_rows_idx__: sparse matrices not yet supported");
   if (arg.ndims () == 2)
     {
@@ -7666,20 +7656,17 @@ do_repelems (const Array<T>& src, const 
   assert (rep.ndims () == 2 && rep.rows () == 2);
 
   octave_idx_type n = rep.columns ();
   octave_idx_type l = 0;
   for (octave_idx_type i = 0; i < n; i++)
     {
       octave_idx_type k = rep(1, i);
       if (k < 0)
-        {
-          error ("repelems: second row must contain non-negative numbers");
-          return retval;
-        }
+        error ("repelems: second row must contain non-negative numbers");
 
       l += k;
     }
 
   retval.clear (1, l);
   T *dest = retval.fortran_vec ();
   l = 0;
   for (octave_idx_type i = 0; i < n; i++)
@@ -7731,20 +7718,17 @@ endfor\n\
       octave_value x = args(0);
 
       NoAlias< Array<octave_idx_type> > r (rm.dims ());
 
       for (octave_idx_type i = 0; i < rm.numel (); i++)
         {
           octave_idx_type rx = rm(i);
           if (static_cast<double> (rx) != rm(i))
-            {
-              error ("repelems: R must be a matrix of integers");
-              return retval;
-            }
+            error ("repelems: R must be a matrix of integers");
 
           r(i) = rx;
         }
 
       switch (x.builtin_type ())
         {
 #define BTYP_BRANCH(X, EX) \
         case btyp_ ## X: \
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -2992,22 +2992,19 @@ base_properties::set_dynamic (const case
 
 property
 base_properties::get_property_dynamic (const caseless_str& pname)
 {
   std::map<caseless_str, property, cmp_caseless_str>::const_iterator it =
     all_props.find (pname);
 
   if (it == all_props.end ())
-    {
-      error ("get_property: unknown property \"%s\"", pname.c_str ());
-      return property ();
-    }
-  else
-    return it->second;
+    error ("get_property: unknown property \"%s\"", pname.c_str ());
+    
+  return it->second;
 }
 
 void
 base_properties::set_parent (const octave_value& val)
 {
   double hp = val.xdouble_value ("set: parent must be a graphics handle");
 
   graphics_handle new_parent = octave_NaN;
@@ -11648,20 +11645,17 @@ Undocumented internal function.\n\
 
   double h = args(0).double_value ();
 
   gh_manager::auto_lock guard;
 
   graphics_handle handle = gh_manager::lookup (h);
 
   if (! handle.ok ())
-    {
-      error ("__zoom__: invalid handle");
-      return retval;
-    }
+    error ("__zoom__: invalid handle");
 
   graphics_object ax = gh_manager::get_object (handle);
 
   axes::properties& ax_props =
     dynamic_cast<axes::properties&> (ax.get_properties ());
 
   if (nargin == 2)
     {
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -59,38 +59,34 @@ typedef octave_handle graphics_handle;
 
 class base_scaler
 {
 public:
   base_scaler (void) { }
 
   virtual ~base_scaler (void) { }
 
-  virtual Matrix scale (const Matrix& m) const
+  virtual Matrix scale (const Matrix&) const
   {
     error ("invalid axis scale");
-    return m;
-  }
-
-  virtual NDArray scale (const NDArray& m) const
+  }
+
+  virtual NDArray scale (const NDArray&) const
   {
     error ("invalid axis scale");
-    return m;
-  }
-
-  virtual double scale (double d) const
+  }
+
+  virtual double scale (double) const
   {
     error ("invalid axis scale");
-    return d;
-  }
-
-  virtual double unscale (double d) const
+  }
+
+  virtual double unscale (double) const
   {
     error ("invalid axis scale");
-    return d;
   }
 
   virtual base_scaler* clone () const
   { return new base_scaler (); }
 
   virtual bool is_linear (void) const
   { return false; }
 };
@@ -311,30 +307,27 @@ public:
   // Sets property value, notifies graphics toolkit.
   // If do_run is true, runs associated listeners.
   OCTINTERP_API bool set (const octave_value& v, bool do_run = true,
                           bool do_notify_toolkit = true);
 
   virtual octave_value get (void) const
   {
     error ("get: invalid property \"%s\"", name.c_str ());
-    return octave_value ();
   }
 
 
   virtual std::string values_as_string (void) const
   {
     error ("values_as_string: invalid property \"%s\"", name.c_str ());
-    return std::string ();
   }
 
   virtual Cell values_as_cell (void) const
   {
     error ("values_as_cell: invalid property \"%s\"", name.c_str ());
-    return Cell ();
   }
 
   base_property& operator = (const octave_value& val)
   {
     set (val);
     return *this;
   }
 
@@ -399,17 +392,16 @@ public:
 
   virtual base_property* clone (void) const
   { return new base_property (*this); }
 
 protected:
   virtual bool do_set (const octave_value&)
   {
     error ("set: invalid property \"%s\"", name.c_str ());
-    return false;
   }
 
 private:
   typedef std::map<listener_mode, octave_value_list> listener_map;
   typedef std::map<listener_mode, octave_value_list>::iterator
     listener_map_iterator;
   typedef std::map<listener_mode, octave_value_list>::const_iterator
     listener_map_const_iterator;
@@ -2731,58 +2723,53 @@ public:
 
   virtual octave_value get (bool all = false) const
   {
     if (valid_object ())
       return get_properties ().get (all);
     else
       {
         error ("base_graphics_object::get: invalid graphics object");
-        return octave_value ();
       }
   }
 
   virtual octave_value get (const caseless_str& pname) const
   {
     if (valid_object ())
       return get_properties ().get (pname);
     else
       {
         error ("base_graphics_object::get: invalid graphics object");
-        return octave_value ();
       }
   }
 
   virtual octave_value get_default (const caseless_str&) const;
 
   virtual octave_value get_factory_default (const caseless_str&) const;
 
   virtual octave_value get_defaults (void) const
   {
     error ("base_graphics_object::get_defaults: invalid graphics object");
-    return octave_value ();
   }
 
   virtual property_list get_defaults_list (void) const
   {
     if (! valid_object ())
       error ("base_graphics_object::get_defaults_list: invalid graphics object");
     return property_list ();
   }
 
   virtual octave_value get_factory_defaults (void) const
   {
     error ("base_graphics_object::get_factory_defaults: invalid graphics object");
-    return octave_value ();
   }
 
   virtual property_list get_factory_defaults_list (void) const
   {
     error ("base_graphics_object::get_factory_defaults_list: invalid graphics object");
-    return property_list ();
   }
 
   virtual bool has_readonly_property (const caseless_str& pname) const
   {
     return base_properties::has_readonly_property (pname);
   }
 
   virtual std::string values_as_string (void);
@@ -2793,28 +2780,26 @@ public:
 
   virtual graphics_handle get_parent (void) const
   {
     if (valid_object ())
       return get_properties ().get_parent ();
     else
       {
         error ("base_graphics_object::get_parent: invalid graphics object");
-        return graphics_handle ();
       }
   }
 
   graphics_handle get_handle (void) const
   {
     if (valid_object ())
       return get_properties ().get___myhandle__ ();
     else
       {
         error ("base_graphics_object::get_handle: invalid graphics object");
-        return graphics_handle ();
       }
   }
 
   virtual void remove_child (const graphics_handle& h)
   {
     if (valid_object ())
       get_properties ().remove_child (h);
     else
@@ -2847,24 +2832,22 @@ public:
     else
       error ("base_graphics_object::default: invalid graphics object");
   }
 
   virtual base_properties& get_properties (void)
   {
     static base_properties properties;
     error ("base_graphics_object::get_properties: invalid graphics object");
-    return properties;
   }
 
   virtual const base_properties& get_properties (void) const
   {
     static base_properties properties;
     error ("base_graphics_object::get_properties: invalid graphics object");
-    return properties;
   }
 
   virtual void update_axis_limits (const std::string& axis_type);
 
   virtual void update_axis_limits (const std::string& axis_type,
                                    const graphics_handle& h);
 
   virtual bool valid_object (void) const { return false; }
@@ -2884,17 +2867,16 @@ public:
 
   virtual graphics_toolkit get_toolkit (void) const
   {
     if (valid_object ())
       return get_properties ().get_toolkit ();
     else
       {
         error ("base_graphics_object::get_toolkit: invalid graphics object");
-        return graphics_toolkit ();
       }
   }
 
   virtual void add_property_listener (const std::string& nm,
                                       const octave_value& v,
                                       listener_mode mode = POSTSET)
   {
     if (valid_object ())
diff --git a/libinterp/corefcn/ls-mat4.cc b/libinterp/corefcn/ls-mat4.cc
--- a/libinterp/corefcn/ls-mat4.cc
+++ b/libinterp/corefcn/ls-mat4.cc
@@ -394,19 +394,20 @@ read_mat_binary_data (std::istream& is, 
 
         if (type == 1)
           tc = tc.convert_to_str (false, true, '\'');
       }
 
     return retval;
   }
 
+// FIXME: With short-circuiting error(), no need for goto in code
 data_read_error:
   error ("load: trouble reading binary file '%s'", filename.c_str ());
-  return retval;
+
 }
 
 // Save the data from TC along with the corresponding NAME on stream OS
 // in the MatLab version 4 binary format.
 
 bool
 save_mat_binary_data (std::ostream& os, const octave_value& tc,
                       const std::string& name)
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -1460,19 +1460,19 @@ read_mat5_binary_element (std::istream& 
 
   is.seekg (pos + static_cast<std::streamoff> (element_length));
 
   if (is.eof ())
     is.clear ();
 
   return retval;
 
+// FIXME: With short-circuiting error(), no need for goto in code
 data_read_error:
   error ("load: trouble reading binary file '%s'", filename.c_str ());
-  return std::string ();
 
 skip_ahead:
   warning ("load: skipping over '%s'", retval.c_str ());
   is.seekg (pos + static_cast<std::streamoff> (element_length));
   return read_mat5_binary_element (is, filename, swap, global, tc);
 }
 
 int
@@ -2677,13 +2677,13 @@ save_mat5_binary_element (std::ostream& 
       }
     }
   else
     gripe_wrong_type_arg ("save", tc, false);
 
 skip_to_next:
   return true;
 
+// FIXME: With short-circuiting error(), no need for goto in code
 error_cleanup:
   error ("save: error while writing '%s' to MAT file", name.c_str ());
 
-  return false;
 }
diff --git a/libinterp/corefcn/oct-fstrm.cc b/libinterp/corefcn/oct-fstrm.cc
--- a/libinterp/corefcn/oct-fstrm.cc
+++ b/libinterp/corefcn/oct-fstrm.cc
@@ -60,26 +60,24 @@ octave_fstream::octave_fstream (const st
 }
 
 // Position a stream at OFFSET relative to ORIGIN.
 
 int
 octave_fstream::seek (off_t, int)
 {
   error ("fseek: invalid_operation");
-  return -1;
 }
 
 // Return current stream position.
 
 off_t
 octave_fstream::tell (void)
 {
   error ("ftell: invalid_operation");
-  return -1;
 }
 
 // Return nonzero if EOF has been reached on this stream.
 
 bool
 octave_fstream::eof (void) const
 {
   return fs.eof ();
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -2604,18 +2604,16 @@ octave_base_stream::do_numeric_printf_co
             double dval = val.double_value (true);
 
             retval += do_printf_conv (os, fmt, nsa, sa_1, sa_2, dval, who);
           }
           break;
 
         default:
           error ("%s: invalid format specifier", who.c_str ());
-          return -1;
-          break;
         }
     }
 
   return retval;
 }
 
 int
 octave_base_stream::do_printf (printf_format_list& fmt_list,
diff --git a/libinterp/corefcn/oct-strstrm.cc b/libinterp/corefcn/oct-strstrm.cc
--- a/libinterp/corefcn/oct-strstrm.cc
+++ b/libinterp/corefcn/oct-strstrm.cc
@@ -27,26 +27,24 @@ along with Octave; see the file COPYING.
 #include "oct-strstrm.h"
 
 // Position a stream at OFFSET relative to ORIGIN.
 
 int
 octave_base_strstream::seek (off_t, int)
 {
   error ("fseek: invalid operation");
-  return -1;
 }
 
 // Return current stream position.
 
 off_t
 octave_base_strstream::tell (void)
 {
   error ("ftell: invalid operation");
-  return -1;
 }
 
 octave_stream
 octave_istrstream::create (const char *data, std::ios::openmode arg_md,
                            oct_mach_info::float_format flt_fmt)
 {
   return octave_stream (new octave_istrstream (data, arg_md, flt_fmt));
 }
diff --git a/libinterp/dldfcn/__delaunayn__.cc b/libinterp/dldfcn/__delaunayn__.cc
--- a/libinterp/dldfcn/__delaunayn__.cc
+++ b/libinterp/dldfcn/__delaunayn__.cc
@@ -69,20 +69,17 @@ close_fcn (FILE *f)
 static bool
 octave_qhull_dims_ok (octave_idx_type dim, octave_idx_type n, const char *who)
 {
   if (sizeof (octave_idx_type) > sizeof (int))
     {
       int maxval = std::numeric_limits<int>::max ();
 
       if (dim > maxval || n > maxval)
-        {
-          error ("%s: dimension too large for Qhull", who);
-          return false;
-        }
+        error ("%s: dimension too large for Qhull", who);
     }
 
   return true;
 }
 
 DEFUN_DLD (__delaunayn__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn  {} {@var{T} =} __delaunayn__ (@var{pts})\n\
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -503,21 +503,19 @@ octave_base_int_scalar<T>::save_ascii (s
   return true;
 }
 
 template <class T>
 bool
 octave_base_int_scalar<T>::load_ascii (std::istream& is)
 {
   is >> this->scalar;
-  if (!is)
-    {
-      error ("load: failed to load scalar constant");
-      return false;
-    }
+  if (! is)
+    error ("load: failed to load scalar constant");
+
   return true;
 }
 
 template <class T>
 bool
 octave_base_int_scalar<T>::save_binary (std::ostream& os, bool&)
 {
   os.write (reinterpret_cast<char *> (&(this->scalar)), this->byte_size ());
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -407,23 +407,20 @@ public:
 
   void put (const std::string& pname, const octave_value& val)
   { map.assign (pname, val); }
 
   octave_value get (const std::string& pname) const
   {
     Cell val = map.contents (pname);
 
-    if (val.numel () > 0)
-      return val(0, 0);
-    else
-      {
+    if (val.numel () < 1)
         error ("get: unknown slot: %s", pname.c_str ());
-        return octave_value ();
-      }
+
+    return val(0, 0);
   }
 
   octave_value_list
   subsref (const std::string& type, const std::list<octave_value_list>& idx,
            int nargout, size_t& skip, const cdef_class& context,
            bool auto_add);
 
   octave_value
@@ -542,17 +539,16 @@ public:
   virtual bool is_package (void) const { return false; }
 
   virtual octave_value_list
   meta_subsref (const std::string& /* type */,
                 const std::list<octave_value_list>& /* idx */,
                 int /* nargout */)
   {
     error ("subsref: invalid meta object");
-    return octave_value_list ();
   }
 
   virtual void meta_release (void) { }
 
   virtual bool meta_is_postfix_index_handled (char /* type */) const
   { return false; }
 
 protected:
@@ -1505,37 +1501,29 @@ to_ov (const cdef_object& obj)
 
 inline octave_value
 to_ov (const octave_value& ov)
 { return ov; }
 
 inline cdef_object
 to_cdef (const octave_value& val)
 {
-  if (val.type_name () == "object")
-    return dynamic_cast<octave_classdef *> (val.internal_rep ())->get_object ();
-  else
-    {
-      error ("cannot convert `%s' into `object'", val.type_name().c_str ());
-      return cdef_object ();
-    }
+  if (val.type_name () != "object")
+    error ("cannot convert `%s' into `object'", val.type_name().c_str ());
+
+  return dynamic_cast<octave_classdef *> (val.internal_rep ())->get_object ();
 }
 
 inline cdef_object&
 to_cdef_ref (const octave_value& val)
 {
-  static cdef_object empty;
+  if (val.type_name () != "object")
+    error ("cannot convert `%s' into `object'", val.type_name().c_str ());
 
-  if (val.type_name () == "object")
-    return dynamic_cast<octave_classdef *> (val.internal_rep ())->get_object_ref ();
-  else
-    {
-      error ("cannot convert `%s' into `object'", val.type_name().c_str ());
-      return empty;
-    }
+  return dynamic_cast<octave_classdef *> (val.internal_rep ())->get_object_ref ();
 }
 
 inline cdef_object
 to_cdef (const cdef_object& obj)
 { return obj; }
 
 OCTINTERP_API void install_classdef (void);
 
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -306,21 +306,18 @@ octave_complex::save_ascii (std::ostream
   return true;
 }
 
 bool
 octave_complex::load_ascii (std::istream& is)
 {
   scalar = octave_read_value<Complex> (is);
 
-  if (!is)
-    {
-      error ("load: failed to load complex scalar constant");
-      return false;
-    }
+  if (! is)
+    error ("load: failed to load complex scalar constant");
 
   return true;
 }
 
 
 bool
 octave_complex::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -303,20 +303,17 @@ octave_sparse_complex_matrix::load_binar
 
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
   if (tmp != -2)
-    {
-      error ("load: only 2-D sparse matrices are supported");
-      return false;
-    }
+    error ("load: only 2-D sparse matrices are supported");
 
   if (! is.read (reinterpret_cast<char *> (&nr), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nc), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nz), 4))
     return false;
 
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -775,40 +775,32 @@ functions from strings is through the us
 
       if (fargs.numel () == 0)
         fargs.append (std::string ("x"));
 
     }
   else if (nargin == 2 && args(1).is_numeric_type ())
     {
       if (! args(1).is_scalar_type ())
-        {
-          error ("inline: N must be an integer");
-          return retval;
-        }
+        error ("inline: N must be an integer");
 
       int n = args(1).int_value ("inline: N must be an integer");
 
-      if (n >= 0)
-        {
-          fargs.resize (n+1);
+      if (n < 0)
+        error ("inline: N must be a positive integer or zero");
 
-          fargs(0) = "x";
+      fargs.resize (n+1);
 
-          for (int i = 1; i < n+1; i++)
-            {
-              std::ostringstream buf;
-              buf << "P" << i;
-              fargs(i) = buf.str ();
-            }
-        }
-      else
+      fargs(0) = "x";
+
+      for (int i = 1; i < n+1; i++)
         {
-          error ("inline: N must be a positive integer or zero");
-          return retval;
+          std::ostringstream buf;
+          buf << "P" << i;
+          fargs(i) = buf.str ();
         }
     }
   else
     {
       fargs.resize (nargin - 1);
 
       for (int i = 1; i < nargin; i++)
         {
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -142,21 +142,18 @@ octave_float_scalar::save_ascii (std::os
 
   return true;
 }
 
 bool
 octave_float_scalar::load_ascii (std::istream& is)
 {
   scalar = octave_read_value<float> (is);
-  if (!is)
-    {
-      error ("load: failed to load scalar constant");
-      return false;
-    }
+  if (! is)
+    error ("load: failed to load scalar constant");
 
   return true;
 }
 
 bool
 octave_float_scalar::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
   char tmp = LS_FLOAT;
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -250,21 +250,18 @@ octave_float_complex::save_ascii (std::o
   return true;
 }
 
 bool
 octave_float_complex::load_ascii (std::istream& is)
 {
   scalar = octave_read_value<FloatComplex> (is);
 
-  if (!is)
-    {
-      error ("load: failed to load complex scalar constant");
-      return false;
-    }
+  if (! is)
+    error ("load: failed to load complex scalar constant");
 
   return true;
 }
 
 
 bool
 octave_float_complex::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -2084,17 +2084,16 @@ Function will directly call initialize_j
 
   initialize_java ();
 
   retval = 1;
 
   return retval;
 #else
   error ("__java_init__: Octave was not compiled with Java interface");
-  return octave_value ();
 #endif
 }
 
 DEFUN (__java_exit__, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __java_exit__ ()\n\
 Internal function used @strong{only} when debugging Java interface.\n\
 \n\
@@ -2453,17 +2452,16 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{java_matrix_autoconversion, debug_java}\n\
 @end deftypefn")
 {
 #ifdef HAVE_JAVA
   return SET_INTERNAL_VARIABLE (java_unsigned_autoconversion);
 #else
   error ("java_unsigned_autoconversion: Octave was not compiled with Java interface");
-  return octave_value ();
 #endif
 }
 
 DEFUN (debug_java, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{val} =} debug_java ()\n\
 @deftypefnx {} {@var{old_val} =} debug_java (@var{new_val})\n\
 @deftypefnx {} {} debug_java (@var{new_val}, \"local\")\n\
@@ -2476,17 +2474,16 @@ variable is changed locally for the func
 The original variable value is restored when exiting the function.\n\
 @seealso{java_matrix_autoconversion, java_unsigned_autoconversion}\n\
 @end deftypefn")
 {
 #ifdef HAVE_JAVA
   return SET_INTERNAL_VARIABLE (debug_java);
 #else
   error ("debug_java: Octave was not compiled with Java interface");
-  return octave_value ();
 #endif
 }
 
 // Outside of #ifdef HAVE_JAVA because it is desirable to be able to
 // test for the presence of a Java object without having Java installed.
 DEFUN (isjava, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} isjava (@var{x})\n\
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -467,21 +467,18 @@ bool
 octave_range::load_ascii (std::istream& is)
 {
   // # base, limit, range comment added by save ().
   skip_comments (is);
 
   double base, limit, inc;
   is >> base >> limit >> inc;
 
-  if (!is)
-    {
-      error ("load: failed to load range constant");
-      return false;
-    }
+  if (! is)
+    error ("load: failed to load range constant");
 
   if (inc != 0)
     range = Range (base, limit, inc);
   else
     range = Range (base, inc, static_cast<octave_idx_type> (limit));
 
   return true;
 }
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -334,20 +334,17 @@ octave_sparse_matrix::load_binary (std::
 
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
   if (tmp != -2)
-    {
-      error ("load: only 2-D sparse matrices are supported");
-      return false;
-    }
+    error ("load: only 2-D sparse matrices are supported");
 
   if (! is.read (reinterpret_cast<char *> (&nr), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nc), 4))
     return false;
   if (! is.read (reinterpret_cast<char *> (&nz), 4))
     return false;
 
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -157,21 +157,19 @@ octave_scalar::save_ascii (std::ostream&
 
   return true;
 }
 
 bool
 octave_scalar::load_ascii (std::istream& is)
 {
   scalar = octave_read_value<double> (is);
-  if (!is)
-    {
-      error ("load: failed to load scalar constant");
-      return false;
-    }
+
+  if (! is)
+    error ("load: failed to load scalar constant");
 
   return true;
 }
 
 bool
 octave_scalar::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
   char tmp = LS_DOUBLE;
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -275,20 +275,17 @@ octave_struct::subsasgn (const std::stri
 {
   octave_value retval;
 
   int n = type.length ();
 
   octave_value t_rhs = rhs;
 
   if (idx.front ().empty ())
-    {
-      error ("missing index in indexed assignment");
-      return retval;
-    }
+    error ("missing index in indexed assignment");
 
   if (n > 1 && ! (type.length () == 2 && type[0] == '(' && type[1] == '.'))
     {
       switch (type[0])
         {
         case '(':
           {
             if (type.length () > 1 && type[1] == '.')
@@ -1163,20 +1160,17 @@ octave_scalar_struct::numeric_conv (cons
 octave_value
 octave_scalar_struct::subsasgn (const std::string& type,
                                 const std::list<octave_value_list>& idx,
                                 const octave_value& rhs)
 {
   octave_value retval;
 
   if (idx.front ().empty ())
-    {
-      error ("missing index in indexed assignment");
-      return retval;
-    }
+    error ("missing index in indexed assignment");
 
   if (type[0] == '.')
     {
       int n = type.length ();
 
       octave_value t_rhs = rhs;
 
       octave_value_list key_idx = idx.front ();
@@ -1750,20 +1744,17 @@ produces a struct @strong{array}.\n\
       return retval;
     }
 
   // Check for "field", VALUE pairs.
 
   for (int i = 0; i < nargin; i += 2)
     {
       if (! args(i).is_string () || i + 1 >= nargin)
-        {
-          error ("struct: additional arguments must occur as \"field\", VALUE pairs");
-          return retval;
-        }
+        error ("struct: additional arguments must occur as \"field\", VALUE pairs");
     }
 
   // Check that the dimensions of the values correspond.
 
   dim_vector dims (1, 1);
 
   int first_dimensioned_value = 0;
 
@@ -2004,58 +1995,43 @@ A(1)\n\
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
   if (! args(0).is_cell ())
-    {
-      error ("cell2struct: argument CELL must be of type cell");
-      return retval;
-    }
+    error ("cell2struct: argument CELL must be of type cell");
 
   if (! (args(1).is_cellstr () || args(1).is_char_matrix ()))
-    {
-      error ("cell2struct: FIELDS must be a cell array of strings or a character matrix");
-      return retval;
-    }
+    error ("cell2struct: FIELDS must be a cell array of strings or a character matrix");
 
   const Cell vals = args(0).cell_value ();
   const Array<std::string> fields = args(1).cellstr_value ();
 
   octave_idx_type ext = 0;
 
   int dim = 0;
 
   if (nargin == 3)
     {
-      if (args(2).is_real_scalar ())
-        dim = nargin == 2 ? 0 : args(2).int_value () - 1;
-      else
-        {
-          error ("cell2struct: DIM must be a real scalar");
-          return retval;
-        }
+      if (! args(2).is_real_scalar ())
+        error ("cell2struct: DIM must be a real scalar");
+
+      dim = nargin == 2 ? 0 : args(2).int_value () - 1;
     }
 
   if (dim < 0)
-    {
-      error ("cell2struct: DIM must be a valid dimension");
-      return retval;
-    }
+    error ("cell2struct: DIM must be a valid dimension");
 
   ext = vals.ndims () > dim ? vals.dims ()(dim) : 1;
 
   if (ext != fields.numel ())
-    {
-      error ("cell2struct: number of FIELDS does not match dimension");
-      return retval;
-    }
+    error ("cell2struct: number of FIELDS does not match dimension");
 
   int nd = std::max (dim+1, vals.ndims ());
   // result dimensions.
   dim_vector rdv = vals.dims ().redim (nd);
 
   assert (ext == rdv(dim));
   if (nd == 2)
     {
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -110,21 +110,17 @@ octave_user_script::~octave_user_script 
 
   delete cmd_list;
 }
 
 octave_value_list
 octave_user_script::subsref (const std::string&,
                              const std::list<octave_value_list>&, int)
 {
-  octave_value_list retval;
-
   error ("invalid use of script %s in index expression", file_name.c_str ());
-
-  return retval;
 }
 
 octave_value_list
 octave_user_script::do_multi_index_op (int nargout,
                                        const octave_value_list& args)
 {
   octave_value_list retval;
 
@@ -500,20 +496,17 @@ octave_user_function::do_multi_index_op 
 #endif
 
   unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth >= Vmax_recursion_depth)
-    {
-      error ("max_recursion_depth exceeded");
-      return retval;
-    }
+    error ("max_recursion_depth exceeded");
 
   // Save old and set current symbol table context, for
   // eval_undefined_error().
 
   int context = active_context ();
 
   octave_call_stack::push (this, local_scope, context);
   frame.add_fcn (octave_call_stack::pop);
@@ -836,20 +829,17 @@ Programming Note: @code{nargin} does not
     {
       octave_value func = args(0);
 
       if (func.is_string ())
         {
           std::string name = func.string_value ();
           func = symbol_table::find_function (name);
           if (func.is_undefined ())
-            {
-              error ("nargin: invalid function name: %s", name.c_str ());
-              return retval;
-            }
+            error ("nargin: invalid function name: %s", name.c_str ());
         }
 
       octave_function *fcn_val = func.function_value ();
       if (fcn_val)
         {
           octave_user_function *fcn = fcn_val->user_function_value (true);
 
           if (fcn)
@@ -947,20 +937,17 @@ returns -1 for all anonymous functions.\
     {
       octave_value func = args(0);
 
       if (func.is_string ())
         {
           std::string name = func.string_value ();
           func = symbol_table::find_function (name);
           if (func.is_undefined ())
-            {
-              error ("nargout: invalid function name: %s", name.c_str ());
-              return retval;
-            }
+            error ("nargout: invalid function name: %s", name.c_str ());
         }
 
       if (func.is_inline_function ())
         {
           retval = 1;
           return retval;
         }
 
@@ -1043,22 +1030,19 @@ static bool val_in_table (const Matrix& 
 
   octave_idx_type i = table.lookup (val, ASCENDING);
   return (i > 0 && table(i-1) == val);
 }
 
 static bool isargout1 (int nargout, const Matrix& ignored, double k)
 {
   if (k != xround (k) || k <= 0)
-    {
-      error ("isargout: K must be a positive integer");
-      return false;
-    }
-  else
-    return (k == 1 || k <= nargout) && ! val_in_table (ignored, k);
+    error ("isargout: K must be a positive integer");
+  
+  return (k == 1 || k <= nargout) && ! val_in_table (ignored, k);
 }
 
 DEFUN (isargout, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} isargout (@var{k})\n\
 Within a function, return a logical value indicating whether the argument\n\
 @var{k} will be assigned to a variable on output.\n\
 \n\
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2965,20 +2965,17 @@ decode_subscripts (const char* name, con
 
           if (item == "{}")
             type_string[k] = '{';
           else if (item == "()")
             type_string[k] = '(';
           else if (item == ".")
             type_string[k] = '.';
           else
-            {
-              error ("%s: invalid indexing type '%s'", name, item.c_str ());
-              return;
-            }
+            error ("%s: invalid indexing type '%s'", name, item.c_str ());
 
           octave_value_list idx_item;
 
           if (subs(k).is_string ())
             idx_item(0) = subs(k);
           else if (subs(k).is_cell ())
             {
               Cell subs_cell = subs(k).cell_value ();
@@ -2988,20 +2985,17 @@ decode_subscripts (const char* name, con
                   if (subs_cell(n).is_string ()
                       && subs_cell(n).string_value () == ":")
                     idx_item(n) = octave_value(octave_value::magic_colon_t);
                   else
                     idx_item(n) = subs_cell(n);
                 }
             }
           else
-            {
-              error ("%s: subs(%d) must be a string or cell array", name, k+1);
-              return;
-            }
+            error ("%s: subs(%d) must be a string or cell array", name, k+1);
 
           idx.push_back (idx_item);
         }
     }
   else
     error ("%s: second argument must be a structure with fields 'type' and 'subs'",
            name);
 }
diff --git a/libinterp/operators/op-cm-cm.cc b/libinterp/operators/op-cm-cm.cc
--- a/libinterp/operators/op-cm-cm.cc
+++ b/libinterp/operators/op-cm-cm.cc
@@ -84,17 +84,16 @@ DEFBINOP (div, complex_matrix, complex_m
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, complex_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
diff --git a/libinterp/operators/op-cm-m.cc b/libinterp/operators/op-cm-m.cc
--- a/libinterp/operators/op-cm-m.cc
+++ b/libinterp/operators/op-cm-m.cc
@@ -68,17 +68,16 @@ DEFBINOP (div, complex_matrix, matrix)
   v2.matrix_type (typ);
   return ret;
 }
 
 
 DEFBINOPX (pow, complex_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_matrix&);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (),
diff --git a/libinterp/operators/op-cm-scm.cc b/libinterp/operators/op-cm-scm.cc
--- a/libinterp/operators/op-cm-scm.cc
+++ b/libinterp/operators/op-cm-scm.cc
@@ -70,17 +70,16 @@ DEFBINOP (div, complex_matrix, sparse_co
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, complex_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&,
                    const octave_sparse_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
 
diff --git a/libinterp/operators/op-cm-sm.cc b/libinterp/operators/op-cm-sm.cc
--- a/libinterp/operators/op-cm-sm.cc
+++ b/libinterp/operators/op-cm-sm.cc
@@ -69,17 +69,16 @@ DEFBINOP (div, complex_matrix, sparse_ma
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, complex_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&,
                    const octave_sparse_matrix&);
   MatrixType typ = v1.matrix_type ();
 
diff --git a/libinterp/operators/op-fcm-fcm.cc b/libinterp/operators/op-fcm-fcm.cc
--- a/libinterp/operators/op-fcm-fcm.cc
+++ b/libinterp/operators/op-fcm-fcm.cc
@@ -85,17 +85,16 @@ DEFBINOP (div, float_complex_matrix, flo
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, float_complex_matrix, float_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, float_complex_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
 
diff --git a/libinterp/operators/op-fcm-fm.cc b/libinterp/operators/op-fcm-fm.cc
--- a/libinterp/operators/op-fcm-fm.cc
+++ b/libinterp/operators/op-fcm-fm.cc
@@ -74,17 +74,16 @@ DEFBINOP (div, float_complex_matrix, flo
   v2.matrix_type (typ);
   return ret;
 }
 
 
 DEFBINOPX (pow, float_complex_matrix, float_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, float_complex_matrix, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&,
                    const octave_float_matrix&);
   MatrixType typ = v1.matrix_type ();
 
diff --git a/libinterp/operators/op-fm-fcm.cc b/libinterp/operators/op-fm-fcm.cc
--- a/libinterp/operators/op-fm-fcm.cc
+++ b/libinterp/operators/op-fm-fcm.cc
@@ -73,17 +73,16 @@ DEFBINOP (div, float_matrix, float_compl
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, float_matrix, float_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, float_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&,
                    const octave_float_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
 
diff --git a/libinterp/operators/op-fm-fm.cc b/libinterp/operators/op-fm-fm.cc
--- a/libinterp/operators/op-fm-fm.cc
+++ b/libinterp/operators/op-fm-fm.cc
@@ -72,17 +72,16 @@ DEFBINOP (div, float_matrix, float_matri
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, float_matrix, float_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, float_matrix, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
   MatrixType typ = v1.matrix_type ();
 
   FloatMatrix ret = xleftdiv (v1.float_matrix_value (),
diff --git a/libinterp/operators/op-m-cm.cc b/libinterp/operators/op-m-cm.cc
--- a/libinterp/operators/op-m-cm.cc
+++ b/libinterp/operators/op-m-cm.cc
@@ -69,17 +69,16 @@ DEFBINOP (div, matrix, complex_matrix)
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
 
   ComplexMatrix ret = xleftdiv (v1.matrix_value (),
diff --git a/libinterp/operators/op-m-m.cc b/libinterp/operators/op-m-m.cc
--- a/libinterp/operators/op-m-m.cc
+++ b/libinterp/operators/op-m-m.cc
@@ -71,17 +71,16 @@ DEFBINOP (div, matrix, matrix)
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
   MatrixType typ = v1.matrix_type ();
 
   Matrix ret = xleftdiv (v1.matrix_value (), v2.matrix_value (), typ);
diff --git a/libinterp/operators/op-m-scm.cc b/libinterp/operators/op-m-scm.cc
--- a/libinterp/operators/op-m-scm.cc
+++ b/libinterp/operators/op-m-scm.cc
@@ -70,17 +70,16 @@ DEFBINOP (div, matrix, sparse_complex_ma
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&,
                    const octave_sparse_complex_matrix&);
   MatrixType typ = v1.matrix_type ();
 
diff --git a/libinterp/operators/op-m-sm.cc b/libinterp/operators/op-m-sm.cc
--- a/libinterp/operators/op-m-sm.cc
+++ b/libinterp/operators/op-m-sm.cc
@@ -68,17 +68,16 @@ DEFBINOP (div, matrix, sparse_matrix)
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_sparse_matrix&);
   MatrixType typ = v1.matrix_type ();
 
   Matrix ret = xleftdiv (v1.matrix_value (), v2.matrix_value (), typ);
diff --git a/libinterp/operators/op-scm-cm.cc b/libinterp/operators/op-scm-cm.cc
--- a/libinterp/operators/op-scm-cm.cc
+++ b/libinterp/operators/op-scm-cm.cc
@@ -57,17 +57,16 @@ DEFBINOP (div, sparse_complex_matrix, co
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_complex_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
diff --git a/libinterp/operators/op-scm-m.cc b/libinterp/operators/op-scm-m.cc
--- a/libinterp/operators/op-scm-m.cc
+++ b/libinterp/operators/op-scm-m.cc
@@ -58,17 +58,16 @@ DEFBINOP (div, sparse_complex_matrix, ma
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&, const octave_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
diff --git a/libinterp/operators/op-scm-scm.cc b/libinterp/operators/op-scm-scm.cc
--- a/libinterp/operators/op-scm-scm.cc
+++ b/libinterp/operators/op-scm-scm.cc
@@ -118,17 +118,16 @@ DEFBINOP (div, sparse_complex_matrix, sp
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_sparse_complex_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
diff --git a/libinterp/operators/op-scm-sm.cc b/libinterp/operators/op-scm-sm.cc
--- a/libinterp/operators/op-scm-sm.cc
+++ b/libinterp/operators/op-scm-sm.cc
@@ -68,17 +68,16 @@ DEFBINOP (div, sparse_complex_matrix, sp
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, sparse_complex_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_complex_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_complex_matrix&,
                    const octave_sparse_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
diff --git a/libinterp/operators/op-sm-cm.cc b/libinterp/operators/op-sm-cm.cc
--- a/libinterp/operators/op-sm-cm.cc
+++ b/libinterp/operators/op-sm-cm.cc
@@ -57,17 +57,16 @@ DEFBINOP (div, sparse_matrix, complex_ma
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_matrix, complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_complex_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
diff --git a/libinterp/operators/op-sm-m.cc b/libinterp/operators/op-sm-m.cc
--- a/libinterp/operators/op-sm-m.cc
+++ b/libinterp/operators/op-sm-m.cc
@@ -55,17 +55,16 @@ DEFBINOP (div, sparse_matrix, matrix)
 
   v2.matrix_type (typ);
   return ret;
 }
 
 DEFBINOPX (pow, sparse_matrix, matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
diff --git a/libinterp/operators/op-sm-scm.cc b/libinterp/operators/op-sm-scm.cc
--- a/libinterp/operators/op-sm-scm.cc
+++ b/libinterp/operators/op-sm-scm.cc
@@ -68,17 +68,16 @@ DEFBINOP (div, sparse_matrix, sparse_com
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, sparse_matrix, sparse_complex_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, sparse_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&,
                    const octave_sparse_complex_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
diff --git a/libinterp/operators/op-sm-sm.cc b/libinterp/operators/op-sm-sm.cc
--- a/libinterp/operators/op-sm-sm.cc
+++ b/libinterp/operators/op-sm-sm.cc
@@ -92,17 +92,16 @@ DEFBINOP (div, sparse_matrix, sparse_mat
       v2.matrix_type (typ);
       return ret;
     }
 }
 
 DEFBINOPX (pow, sparse_matrix, sparse_matrix)
 {
   error ("can't do A ^ B for A and B both matrices");
-  return octave_value ();
 }
 
 DEFBINOP (ldiv, sparse_matrix, sparse_matrix)
 {
   CAST_BINOP_ARGS (const octave_sparse_matrix&, const octave_sparse_matrix&);
 
   if (v1.rows () == 1 && v1.columns () == 1)
     {
diff --git a/libinterp/parse-tree/pt-exp.cc b/libinterp/parse-tree/pt-exp.cc
--- a/libinterp/parse-tree/pt-exp.cc
+++ b/libinterp/parse-tree/pt-exp.cc
@@ -50,36 +50,33 @@ tree_expression::is_logically_true (cons
 
   return expr_value;
 }
 
 octave_value
 tree_expression::rvalue1 (int)
 {
   error ("invalid rvalue function called in expression");
-  return octave_value ();
 }
 
 octave_value_list
 tree_expression::rvalue (int)
 {
   error ("invalid rvalue function called in expression");
-  return octave_value_list ();
 }
 
 octave_value_list
 tree_expression::rvalue (int nargout, const std::list<octave_lvalue> *)
 {
   return rvalue (nargout);
 }
 
 octave_lvalue
 tree_expression::lvalue (void)
 {
   error ("invalid lvalue function called in expression");
-  return octave_lvalue ();
 }
 
 std::string
 tree_expression::original_text (void) const
 {
   return std::string ();
 }
