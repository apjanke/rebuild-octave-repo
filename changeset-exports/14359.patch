# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1329147503 28800
#      Mon Feb 13 07:38:23 2012 -0800
# Node ID 7277fe922e99f3c32b3505da05a32f553f3104cc
# Parent  adb352685deda43b90030f513342fef36db329a7
doc: Use Octave preference for double quote in docstrings in scripts/

* interp1.m, interp2.m, interp3.m, interpn.m, profexplore.m, profile.m,
profshow.m, quadgk.m, lookfor.m, imagesc.m, bzip2.m, gzip.m, parseparams.m,
pkg.m, ancestor.m, caxis.m, ezmesh.m, ezmeshc.m, ezsurf.m, ezsurfc.m, hidden.m,
hold.m, patch.m, pie.m, pie3.m, quiver.m, quiver3.m, scatter3.m,
uicontextmenu.m, uicontrol.m, uipanel.m, uipushtool.m, uitoggletool.m,
uitoolbar.m, xlim.m, ylim.m, zlim.m, ismember.m, setxor.m, filter2.m, bicg.m,
demo.m, example.m, fail.m, test.m: Use Octave preference for double quote in
docstrings in scripts/ directory.

diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -17,59 +17,59 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{yi} =} interp1 (@var{x}, @var{y}, @var{xi})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@var{y}, @var{xi})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@dots{}, @var{extrap})
-## @deftypefnx {Function File} {@var{pp} =} interp1 (@dots{}, 'pp')
+## @deftypefnx {Function File} {@var{pp} =} interp1 (@dots{}, "pp")
 ##
 ## One-dimensional interpolation.  Interpolate @var{y}, defined at the
 ## points @var{x}, at the points @var{xi}.  The sample points @var{x}
 ## must be monotonic.  If not specified, @var{x} is taken to be the
 ## indices of @var{y}.  If @var{y} is an array, treat the columns
 ## of @var{y} separately.
 ##
 ## Method is one of:
 ##
 ## @table @asis
-## @item 'nearest'
+## @item "nearest"
 ## Return the nearest neighbor.
 ##
-## @item 'linear'
+## @item "linear"
 ## Linear interpolation from nearest neighbors
 ##
-## @item 'pchip'
+## @item "pchip"
 ## Piecewise cubic Hermite interpolating polynomial
 ##
-## @item 'cubic'
+## @item "cubic"
 ## Cubic interpolation (same as @code{pchip})
 ##
-## @item 'spline'
+## @item "spline"
 ## Cubic spline interpolation---smooth first and second derivatives
 ## throughout the curve
 ## @end table
 ##
 ## Appending '*' to the start of the above method forces @code{interp1}
 ## to assume that @var{x} is uniformly spaced, and only @code{@var{x}
 ## (1)} and @code{@var{x} (2)} are referenced.  This is usually faster,
-## and is never slower.  The default method is 'linear'.
+## and is never slower.  The default method is "linear".
 ##
-## If @var{extrap} is the string 'extrap', then extrapolate values beyond
+## If @var{extrap} is the string "extrap", then extrapolate values beyond
 ## the endpoints.  If @var{extrap} is a number, replace values beyond the
 ## endpoints with that number.  If @var{extrap} is missing, assume NA.
 ##
-## If the string argument 'pp' is specified, then @var{xi} should not be
+## If the string argument "pp" is specified, then @var{xi} should not be
 ## supplied and @code{interp1} returns the piecewise polynomial that
 ## can later be used with @code{ppval} to evaluate the interpolation.
 ## There is an equivalence, such that @code{ppval (interp1 (@var{x},
-## @var{y}, @var{method}, 'pp'), @var{xi}) == interp1 (@var{x}, @var{y},
-## @var{xi}, @var{method}, 'extrap')}.
+## @var{y}, @var{method}, "pp"), @var{xi}) == interp1 (@var{x}, @var{y},
+## @var{xi}, @var{method}, "extrap")}.
 ##
 ## Duplicate points in @var{x} specify a discontinuous interpolant.  There
 ## should be at most 2 consecutive points with the same value.
 ## The discontinuous interpolant is right-continuous if @var{x} is increasing,
 ## left-continuous if it is decreasing.
 ## Discontinuities are (currently) only allowed for "nearest" and "linear"
 ## methods; in all other cases, @var{x} must be strictly monotonic.
 ##
@@ -348,17 +348,17 @@ endfunction
 %! legend ("original", "nearest", "linear");
 %! %--------------------------------------------------------
 %! % confirm that interpolated function matches the original
 
 ##FIXME: add test for n-d arguments here
 
 ## For each type of interpolated test, confirm that the interpolated
 ## value at the knots match the values at the knots.  Points away
-## from the knots are requested, but only 'nearest' and 'linear'
+## from the knots are requested, but only "nearest" and "linear"
 ## confirm they are the correct values.
 
 %!shared xp, yp, xi, style
 %! xp = 0:2:10;
 %! yp = sin (2*pi*xp/5);
 %! xi = [-1, 0, 2.2, 4, 6.6, 10, 11];
 
 ## The following BLOCK/ENDBLOCK section is repeated for each style
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -31,45 +31,45 @@
 ## format.
 ##
 ## @table @code
 ## @item interp2 (@var{x}, @var{y}, @var{Z}, @var{xi}, @var{yi}, @dots{})
 ## Returns a matrix corresponding to the points described by the
 ## matrices @var{xi}, @var{yi}.
 ##
 ## If the last argument is a string, the interpolation method can
-## be specified.  The method can be 'linear', 'nearest' or 'cubic'.
-## If it is omitted 'linear' interpolation is assumed.
+## be specified.  The method can be "linear", "nearest" or "cubic".
+## If it is omitted "linear" interpolation is assumed.
 ##
 ## @item interp2 (@var{z}, @var{xi}, @var{yi})
 ## Assumes @code{@var{x} = 1:rows (@var{z})} and @code{@var{y} =
 ## 1:columns (@var{z})}
 ##
 ## @item interp2 (@var{z}, @var{n})
 ## Interleaves the matrix @var{z} n-times.  If @var{n} is omitted a value
 ## of @code{@var{n} = 1} is assumed.
 ## @end table
 ##
 ## The variable @var{method} defines the method to use for the
 ## interpolation.  It can take one of the following values
 ##
 ## @table @asis
-## @item 'nearest'
+## @item "nearest"
 ## Return the nearest neighbor.
 ##
-## @item 'linear'
+## @item "linear"
 ## Linear interpolation from nearest neighbors.
 ##
-## @item 'pchip'
+## @item "pchip"
 ## Piecewise cubic Hermite interpolating polynomial.
 ##
-## @item 'cubic'
+## @item "cubic"
 ## Cubic interpolation from four nearest neighbors.
 ##
-## @item 'spline'
+## @item "spline"
 ## Cubic spline interpolation---smooth first and second derivatives
 ## throughout the curve.
 ## @end table
 ##
 ## If a scalar value @var{extrapval} is defined as the final value, then
 ## values outside the mesh as set to this value.  Note that in this case
 ## @var{method} must be defined as well.  If @var{extrapval} is not
 ## defined then NA is assumed.
diff --git a/scripts/general/interp3.m b/scripts/general/interp3.m
--- a/scripts/general/interp3.m
+++ b/scripts/general/interp3.m
@@ -23,47 +23,47 @@
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@var{v})
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@dots{}, @var{method}, @var{extrapval})
 ##
 ## Perform 3-dimensional interpolation.  Each element of the 3-dimensional
 ## array @var{v} represents a value at a location given by the parameters
 ## @var{x}, @var{y}, and @var{z}.  The parameters @var{x}, @var{x}, and
 ## @var{z} are either 3-dimensional arrays of the same size as the array
-## @var{v} in the 'meshgrid' format or vectors.  The parameters @var{xi}, etc.
+## @var{v} in the "meshgrid" format or vectors.  The parameters @var{xi}, etc.
 ## respect a similar format to @var{x}, etc., and they represent the points
 ## at which the array @var{vi} is interpolated.
 ##
 ## If @var{x}, @var{y}, @var{z} are omitted, they are assumed to be
 ## @code{x = 1 : size (@var{v}, 2)}, @code{y = 1 : size (@var{v}, 1)} and
 ## @code{z = 1 : size (@var{v}, 3)}.  If @var{m} is specified, then
 ## the interpolation adds a point half way between each of the interpolation
 ## points.  This process is performed @var{m} times.  If only @var{v} is
 ## specified, then @var{m} is assumed to be @code{1}.
 ##
 ## Method is one of:
 ##
 ## @table @asis
-## @item 'nearest'
+## @item "nearest"
 ## Return the nearest neighbor.
 ##
-## @item 'linear'
+## @item "linear"
 ## Linear interpolation from nearest neighbors.
 ##
-## @item 'cubic'
+## @item "cubic"
 ## Cubic interpolation from four nearest neighbors (not implemented yet).
 ##
-## @item 'spline'
+## @item "spline"
 ## Cubic spline interpolation---smooth first and second derivatives
 ## throughout the curve.
 ## @end table
 ##
-## The default method is 'linear'.
+## The default method is "linear".
 ##
-## If @var{extrap} is the string 'extrap', then extrapolate values beyond
+## If @var{extrap} is the string "extrap", then extrapolate values beyond
 ## the endpoints.  If @var{extrap} is a number, replace values beyond the
 ## endpoints with that number.  If @var{extrap} is missing, assume NA.
 ## @seealso{interp1, interp2, spline, meshgrid}
 ## @end deftypefn
 
 function vi = interp3 (varargin)
   method = "linear";
   extrapval = NA;
diff --git a/scripts/general/interpn.m b/scripts/general/interpn.m
--- a/scripts/general/interpn.m
+++ b/scripts/general/interpn.m
@@ -24,44 +24,44 @@
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@dots{}, @var{method}, @var{extrapval})
 ##
 ## Perform @var{n}-dimensional interpolation, where @var{n} is at least two.
 ## Each element of the @var{n}-dimensional array @var{v} represents a value
 ## at a location given by the parameters @var{x1}, @var{x2}, @dots{}, @var{xn}.
 ## The parameters @var{x1}, @var{x2}, @dots{}, @var{xn} are either
 ## @var{n}-dimensional arrays of the same size as the array @var{v} in
-## the 'ndgrid' format or vectors.  The parameters @var{y1}, etc. respect a
+## the "ndgrid" format or vectors.  The parameters @var{y1}, etc. respect a
 ## similar format to @var{x1}, etc., and they represent the points at which
 ## the array @var{vi} is interpolated.
 ##
 ## If @var{x1}, @dots{}, @var{xn} are omitted, they are assumed to be
 ## @code{x1 = 1 : size (@var{v}, 1)}, etc.  If @var{m} is specified, then
 ## the interpolation adds a point half way between each of the interpolation
 ## points.  This process is performed @var{m} times.  If only @var{v} is
 ## specified, then @var{m} is assumed to be @code{1}.
 ##
 ## Method is one of:
 ##
 ## @table @asis
-## @item 'nearest'
+## @item "nearest"
 ## Return the nearest neighbor.
 ##
-## @item 'linear'
+## @item "linear"
 ## Linear interpolation from nearest neighbors.
 ##
-## @item 'cubic'
+## @item "cubic"
 ## Cubic interpolation from four nearest neighbors (not implemented yet).
 ##
-## @item 'spline'
+## @item "spline"
 ## Cubic spline interpolation---smooth first and second derivatives
 ## throughout the curve.
 ## @end table
 ##
-## The default method is 'linear'.
+## The default method is "linear".
 ##
 ## If @var{extrapval} is the scalar value, use it to replace the values
 ## beyond the endpoints with that number.  If @var{extrapval} is missing,
 ## assume NA.
 ## @seealso{interp1, interp2, spline, ndgrid}
 ## @end deftypefn
 
 function vi = interpn (varargin)
diff --git a/scripts/general/profexplore.m b/scripts/general/profexplore.m
--- a/scripts/general/profexplore.m
+++ b/scripts/general/profexplore.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} profexplore (@var{data})
 ## Interactively explore hierarchical profiler output.
 ##
 ## Assuming @var{data} is the structure with profile data returned by
-## @code{profile ('info')}, this command opens an interactive prompt
+## @code{profile ("info")}, this command opens an interactive prompt
 ## that can be used to explore the call-tree.  Type @kbd{help} to get a list
 ## of possible commands.
 ## @seealso{profile, profshow}
 ## @end deftypefn
 
 ## Built-in profiler.
 ## Author: Daniel Kraft <d@domob.eu>
 
@@ -40,17 +40,17 @@ function profexplore (data)
   ## is an easy way to traverse the tree datastructure.  Here, we just check
   ## the arguments (already done) and give over to it.
 
   __profexplore_worker (data.FunctionTable, data.Hierarchical, "Top\n", "  ");
 
 endfunction
 
 ## This is the worker function.  tree is the current subtree we want to
-## display / explore.  parents is a string containing the already 'rendered'
+## display / explore.  parents is a string containing the already "rendered"
 ## data for the parents which is displayed on top of the list of current
 ## children.  prefix is the prefix to add to each line rendered; this
 ## is just a string of spaces to get indentation right.
 ##
 ## Returning 0 indicates that the user requested to totally exit the
 ## explorer, thus also all higher levels should exit immediately.  An integer
 ## greater zero indicates to exit that many levels since the user wants to go
 ## up (but not necessarily quit).
diff --git a/scripts/general/profile.m b/scripts/general/profile.m
--- a/scripts/general/profile.m
+++ b/scripts/general/profile.m
@@ -16,42 +16,42 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} profile on
 ## @deftypefnx {Command} {} profile off
 ## @deftypefnx {Command} {} profile resume
 ## @deftypefnx {Command} {} profile clear
-## @deftypefnx {Function File} {@var{S} =} profile ('status')
-## @deftypefnx {Function File} {@var{T} =} profile ('info')
+## @deftypefnx {Function File} {@var{S} =} profile ("status")
+## @deftypefnx {Function File} {@var{T} =} profile ("info")
 ## Control the built-in profiler.
 ##
 ## @table @code
 ## @item profile on
 ## Start the profiler, clearing all previously collected data if there
 ## is any.
 ##
 ## @item profile off
 ## Stop profiling.  The collected data can later be retrieved and examined
-## with calls like @code{S = profile ('info')}.
+## with calls like @code{S = profile ("info")}.
 ##
 ## @item profile clear
 ## Clear all collected profiler data.
 ##
 ## @item profile resume
 ## Restart profiling without cleaning up the old data and instead
 ## all newly collected statistics are added to the already existing ones.
 ##
-## @item @var{S} = profile ('status')
+## @item @var{S} = profile ("status")
 ## Return a structure filled with certain information about the current status
 ## of the profiler.  At the moment, the only field is @code{ProfilerStatus}
-## which is either 'on' or 'off'.
+## which is either "on" or "off".
 ##
-## @item @var{T} = profile ('info')
+## @item @var{T} = profile ("info")
 ## Return the collected profiling statistics in the structure @var{T}.
 ## The flat profile is returned in the field @code{FunctionTable} which is an
 ## array of structures, each entry corresponding to a function which was called
 ## and for which profiling statistics are present.  Furthermore, the field
 ## @code{Hierarchical} contains the hierarchical call-tree.  Each node
 ## has an index into the @code{FunctionTable} identifying the function it
 ## corresponds to as well as data fields for number of calls and time spent
 ## at this level in the call-tree.
diff --git a/scripts/general/profshow.m b/scripts/general/profshow.m
--- a/scripts/general/profshow.m
+++ b/scripts/general/profshow.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} profshow (@var{data})
 ## @deftypefnx {Function File} {} profshow (@var{data}, @var{n})
 ## Show flat profiler results.
 ##
 ## This command prints out profiler data as a flat profile.  @var{data} is the
-## structure returned by @code{profile ('info')}.  If @var{n} is given, it
+## structure returned by @code{profile ("info")}.  If @var{n} is given, it
 ## specifies the number of functions to show in the profile; functions are
 ## sorted in descending order by total time spent in them.  If there are more
 ## than @var{n} included in the profile, those will not be shown.  @var{n}
 ## defaults to 20.
 ##
 ## The attribute column shows @samp{R} for recursive functions and nothing
 ## otherwise.
 ## @seealso{profexplore, profile}
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -73,17 +73,17 @@
 ## relative tolerance is 1e-5.
 ##
 ## @item MaxIntervalCount
 ## @code{quadgk} initially subdivides the interval on which to perform
 ## the quadrature into 10 intervals.  Subintervals that have an
 ## unacceptable error are subdivided and re-evaluated.  If the number of
 ## subintervals exceeds 650 subintervals at any point then a poor
 ## convergence is signaled and the current estimate of the integral is
-## returned.  The property 'MaxIntervalCount' can be used to alter the
+## returned.  The property "MaxIntervalCount" can be used to alter the
 ## number of subintervals that can exist before exiting.
 ##
 ## @item WayPoints
 ## Discontinuities in the first derivative of the function to integrate can be
 ## flagged with the  @code{"WayPoints"} property.  This forces the ends of
 ## a subinterval to fall on the breakpoints of the function and can result in
 ## significantly improved estimation of the error in the integral, faster
 ## computation, or both.  For example,
diff --git a/scripts/help/lookfor.m b/scripts/help/lookfor.m
--- a/scripts/help/lookfor.m
+++ b/scripts/help/lookfor.m
@@ -15,33 +15,33 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} lookfor @var{str}
 ## @deftypefnx {Command} {} lookfor -all @var{str}
 ## @deftypefnx {Function File} {[@var{func}, @var{helpstring}] =} lookfor (@var{str})
-## @deftypefnx {Function File} {[@var{func}, @var{helpstring}] =} lookfor ('-all', @var{str})
+## @deftypefnx {Function File} {[@var{func}, @var{helpstring}] =} lookfor ("-all", @var{str})
 ## Search for the string @var{str} in all functions found in the current
 ## function search path.  By default, @code{lookfor} searches for @var{str}
 ## in the first sentence of the help string of each function found.  The entire
-## help text of each function can be searched if the '-all' argument is
+## help text of each function can be searched if the "-all" argument is
 ## supplied.  All searches are case insensitive.
 ##
 ## Called with no output arguments, @code{lookfor} prints the list of
 ## matching functions to the terminal.  Otherwise, the output arguments
 ## @var{func} and @var{helpstring} define the matching functions and the
 ## first sentence of each of their help strings.
 ##
 ## The ability of @code{lookfor} to correctly identify the first
 ## sentence of the help text is dependent on the format of the
 ## function's help.  All Octave core functions are correctly
 ## formatted, but the same can not be guaranteed for external packages and
-## user-supplied functions.  Therefore, the use of the '-all' argument may
+## user-supplied functions.  Therefore, the use of the "-all" argument may
 ## be necessary to find related functions that are not a part of Octave.
 ## @seealso{help, doc, which}
 ## @end deftypefn
 
 function [out_fun, out_help_text] = lookfor (str, arg2)
 
   if (strcmpi (str, "-all"))
     ## The difference between using '-all' and not, is which part of the caches
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -20,17 +20,17 @@
 ## @deftypefn  {Function File} {} imagesc (@var{A})
 ## @deftypefnx {Function File} {} imagesc (@var{x}, @var{y}, @var{A})
 ## @deftypefnx {Function File} {} imagesc (@dots{}, @var{limits})
 ## @deftypefnx {Function File} {} imagesc (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} imagesc (@dots{})
 ## Display a scaled version of the matrix @var{A} as a color image.  The
 ## colormap is scaled so that the entries of the matrix occupy the entire
 ## colormap.  If @var{limits} = [@var{lo}, @var{hi}] are given, then that
-## range is set to the 'clim' of the current axes.
+## range is set to the "clim" of the current axes.
 ##
 ## The axis values corresponding to the matrix elements are specified in
 ## @var{x} and @var{y}, either as pairs giving the minimum and maximum
 ## values for the respective axes, or as values for each row and column
 ## of the matrix @var{A}.
 ##
 ## The optional return value @var{h} is a graphics handle to the image.
 ## @seealso{image, imshow, caxis}
diff --git a/scripts/miscellaneous/bzip2.m b/scripts/miscellaneous/bzip2.m
--- a/scripts/miscellaneous/bzip2.m
+++ b/scripts/miscellaneous/bzip2.m
@@ -16,17 +16,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{entries} =} bzip2 (@var{files})
 ## @deftypefnx {Function File} {@var{entries} =} bzip2 (@var{files}, @var{outdir})
 ## Compress the list of files specified in @var{files}.
-## Each file is compressed separately and a new file with a '.bz2' extension
+## Each file is compressed separately and a new file with a ".bz2" extension
 ## is created.  The original files are not modified.  Existing compressed files
 ## are silently overwritten.  If @var{outdir} is defined the compressed
 ## files are placed in this directory.
 ## @seealso{bunzip2, gzip, zip, tar}
 ## @end deftypefn
 
 function entries = bzip2 (varargin)
 
diff --git a/scripts/miscellaneous/gzip.m b/scripts/miscellaneous/gzip.m
--- a/scripts/miscellaneous/gzip.m
+++ b/scripts/miscellaneous/gzip.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{entries} =} gzip (@var{files})
 ## @deftypefnx {Function File} {@var{entries} =} gzip (@var{files}, @var{outdir})
 ## Compress the list of files and/or directories specified in @var{files}.
-## Each file is compressed separately and a new file with a '.gz' extension
+## Each file is compressed separately and a new file with a ".gz" extension
 ## is created.  The original files are not modified.  Existing compressed
 ## files are silently overwritten.  If @var{outdir} is defined the compressed
 ## files are placed in this directory.
 ## @seealso{gunzip, bzip2, zip, tar}
 ## @end deftypefn
 
 function entries = gzip (varargin)
   if (nargin != 1 && nargin != 2) || (nargout > 1)
diff --git a/scripts/miscellaneous/parseparams.m b/scripts/miscellaneous/parseparams.m
--- a/scripts/miscellaneous/parseparams.m
+++ b/scripts/miscellaneous/parseparams.m
@@ -35,17 +35,17 @@
 ## prop =
 ## @{
 ##   [1,1] = linewidth
 ##   [1,2] = 10
 ## @}
 ## @end group
 ## @end example
 ##
-## The parseparams function may be used to separate 'regular'
+## The parseparams function may be used to separate "regular"
 ## arguments and additional arguments given as property/value pairs of
 ## the @var{varargin} cell array.
 ##
 ## In the second form of the call, available options are specified directly
 ## with their default values given as name-value pairs.
 ## If @var{params} do not form name-value pairs, or if an option occurs
 ## that does not match any of the available options, an error occurs.
 ## When called from an m-file function, the error is prefixed with the
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -131,26 +131,26 @@
 ## If two output arguments are requested @code{pkg} splits the list of
 ## installed packages into those which were installed by the current user,
 ## and those which were installed by the system administrator.
 ##
 ## @example
 ## [user_packages, system_packages] = pkg ("list")
 ## @end example
 ##
-## The option '-forge' lists packages available at the Octave-Forge repository.
+## The option "-forge" lists packages available at the Octave-Forge repository.
 ## This requires an internet connection and the cURL library.  For example:
 ##
 ## @example
 ## oct_forge_pkgs = pkg ("list", "-forge")
 ## @end example
 ##
 ## @item describe
 ## Show a short description of the named installed packages, with the option
-## '-verbose' also list functions provided by the package.  For example,
+## "-verbose" also list functions provided by the package.  For example,
 ##
 ## @example
 ## pkg describe -verbose all
 ## @end example
 ##
 ## @noindent
 ## will describe all installed packages and the functions they provide.
 ## If one output is requested a cell of structure containing the
diff --git a/scripts/plot/ancestor.m b/scripts/plot/ancestor.m
--- a/scripts/plot/ancestor.m
+++ b/scripts/plot/ancestor.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{parent} =} ancestor (@var{h}, @var{type})
-## @deftypefnx {Function File} {@var{parent} =} ancestor (@var{h}, @var{type}, 'toplevel')
+## @deftypefnx {Function File} {@var{parent} =} ancestor (@var{h}, @var{type}, "toplevel")
 ## Return the first ancestor of handle object @var{h} whose type matches
 ## @var{type}, where @var{type} is a character string.  If @var{type} is a
 ## cell array of strings, return the first parent whose type matches
 ## any of the given type strings.
 ##
 ## If the handle object @var{h} is of type @var{type}, return @var{h}.
 ##
 ## If @code{"toplevel"} is given as a 3rd argument, return the highest
diff --git a/scripts/plot/caxis.m b/scripts/plot/caxis.m
--- a/scripts/plot/caxis.m
+++ b/scripts/plot/caxis.m
@@ -21,18 +21,18 @@
 ## @deftypefnx {Function File} {} caxis (@var{h}, @dots{})
 ## Set color axis limits for plots.
 ##
 ## The argument @var{limits} should be a 2-element vector specifying the
 ## lower and upper limits to assign to the first and last value in the
 ## colormap.  Values outside this range are clamped to the first and last
 ## colormap entries.
 ##
-## If @var{limits} is 'auto', then automatic colormap scaling is applied,
-## whereas if @var{limits} is 'manual' the colormap scaling is set to manual.
+## If @var{limits} is "auto", then automatic colormap scaling is applied,
+## whereas if @var{limits} is "manual" the colormap scaling is set to manual.
 ##
 ## Called without any arguments to current color axis limits are returned.
 ##
 ## If an axes handle is passed as the first argument, then operate on
 ## this axes rather than the current axes.
 ## @end deftypefn
 
 function varargout = caxis (varargin)
diff --git a/scripts/plot/ezmesh.m b/scripts/plot/ezmesh.m
--- a/scripts/plot/ezmesh.m
+++ b/scripts/plot/ezmesh.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezmesh (@var{f})
 ## @deftypefnx {Function File} {} ezmesh (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezmesh (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezmesh (@dots{}, @var{n})
-## @deftypefnx {Function File} {} ezmesh (@dots{}, 'circ')
+## @deftypefnx {Function File} {} ezmesh (@dots{}, "circ")
 ## @deftypefnx {Function File} {} ezmesh (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezmesh (@dots{})
 ##
 ## Plot the mesh defined by a function.  @var{f} is a string, inline
 ## function or function handle with two arguments defining the function.  By
 ## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
 ## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
@@ -36,17 +36,17 @@
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
-## If the argument 'circ' is given, then the function is plotted over a disk
+## If the argument "circ" is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created 
 ## surface object.
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
diff --git a/scripts/plot/ezmeshc.m b/scripts/plot/ezmeshc.m
--- a/scripts/plot/ezmeshc.m
+++ b/scripts/plot/ezmeshc.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezmeshc (@var{f})
 ## @deftypefnx {Function File} {} ezmeshc (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezmeshc (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezmeshc (@dots{}, @var{n})
-## @deftypefnx {Function File} {} ezmeshc (@dots{}, 'circ')
+## @deftypefnx {Function File} {} ezmeshc (@dots{}, "circ")
 ## @deftypefnx {Function File} {} ezmeshc (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezmeshc (@dots{})
 ##
 ## Plot the mesh and contour lines defined by a function.  @var{f} is a string,
 ## inline function or function handle with two arguments defining the function.
 ## By default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
 ## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
@@ -36,17 +36,17 @@
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
-## If the argument 'circ' is given, then the function is plotted over a disk
+## If the argument "circ" is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
 ## The optional return value @var{h} is a 2-element vector with a graphics
 ## handle for the created mesh plot and a second handle for the created contour
 ## plot.
 ##
 ## @example
 ## @group
diff --git a/scripts/plot/ezsurf.m b/scripts/plot/ezsurf.m
--- a/scripts/plot/ezsurf.m
+++ b/scripts/plot/ezsurf.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezsurf (@var{f})
 ## @deftypefnx {Function File} {} ezsurf (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezsurf (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezsurf (@dots{}, @var{n})
-## @deftypefnx {Function File} {} ezsurf (@dots{}, 'circ')
+## @deftypefnx {Function File} {} ezsurf (@dots{}, "circ")
 ## @deftypefnx {Function File} {} ezsurf (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezsurf (@dots{})
 ##
 ## Plot the surface defined by a function.  @var{f} is a string, inline
 ## function or function handle with two arguments defining the function.  By
 ## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
 ## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
@@ -36,17 +36,17 @@
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
-## If the argument 'circ' is given, then the function is plotted over a disk
+## If the argument "circ" is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
 ## The optional return value @var{h} is a graphics handle to the created
 ## surface object.
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
diff --git a/scripts/plot/ezsurfc.m b/scripts/plot/ezsurfc.m
--- a/scripts/plot/ezsurfc.m
+++ b/scripts/plot/ezsurfc.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezsurfc (@var{f})
 ## @deftypefnx {Function File} {} ezsurfc (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezsurfc (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezsurfc (@dots{}, @var{n})
-## @deftypefnx {Function File} {} ezsurfc (@dots{}, 'circ')
+## @deftypefnx {Function File} {} ezsurfc (@dots{}, "circ")
 ## @deftypefnx {Function File} {} ezsurfc (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezsurfc (@dots{})
 ##
 ## Plot the surface and contour lines defined by a function.  @var{f} is a
 ## string, inline function or function handle with two arguments defining the
 ## function.  By default the plot is over the domain @code{-2*pi < @var{x} <
 ## 2*pi} and @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
@@ -36,17 +36,17 @@
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
 ## If three functions are passed, then plot the parametrically defined
 ## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
 ## @var{fz} (@var{s}, @var{t})]}.
 ##
-## If the argument 'circ' is given, then the function is plotted over a disk
+## If the argument "circ" is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
 ## The optional return value @var{h} is a 2-element vector with a graphics
 ## for the created surface plot and a second handle for the created contour
 ## plot.
 ##
 ## @example
 ## @group
diff --git a/scripts/plot/hidden.m b/scripts/plot/hidden.m
--- a/scripts/plot/hidden.m
+++ b/scripts/plot/hidden.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} hidden (@var{mode})
 ## @deftypefnx {Function File} {} hidden ()
 ## Manipulation the mesh hidden line removal.  Called with no argument
 ## the hidden line removal is toggled.  The argument @var{mode} can be either
-## 'on' or 'off' and the set of the hidden line removal is set accordingly.
+## "on" or "off" and the set of the hidden line removal is set accordingly.
 ## @seealso{mesh, meshc, surf}
 ## @end deftypefn
 
 function retval = hidden (mode)
 
   if (nargin == 0)
     mode = "swap";
   elseif (nargin == 1);
diff --git a/scripts/plot/hold.m b/scripts/plot/hold.m
--- a/scripts/plot/hold.m
+++ b/scripts/plot/hold.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} hold
 ## @deftypefnx {Command} {} hold @var{state}
 ## @deftypefnx {Function File} {} hold (@var{hax}, @dots{})
-## Toggle or set the 'hold' state of the plotting engine which determines
+## Toggle or set the "hold" state of the plotting engine which determines
 ## whether new graphic objects are added to the plot or replace the existing
 ## objects.
 ##
 ## @table @code
 ## @item hold on
 ## Retain plot data and settings so that subsequent plot commands are displayed
 ## on a single graph.
 ##
@@ -34,23 +34,23 @@
 ## plot commands are displayed on a single graph with the next line color and
 ## style.
 ##
 ## @item hold off
 ## Clear plot and restore default graphics settings before each new plot
 ## command.  (default).
 ##
 ## @item hold
-## Toggle the current 'hold' state.
+## Toggle the current hold state.
 ## @end table
 ##
 ## When given the additional argument @var{hax}, the hold state is modified
 ## only for the given axis handle.
 ##
-## To query the current 'hold' state use the @code{ishold} function.
+## To query the current hold state use the @code{ishold} function.
 ## @seealso{ishold, cla, newplot, clf}
 ## @end deftypefn
 
 function hold (varargin)
 
   if (nargin > 0 && numel (varargin{1}) == 1 && ishandle (varargin{1})
       && strcmp (get (varargin{1}, "type"), "axes"))
     [ax, varargin, nargs] = __plt_get_axis_arg__ ("hold", varargin{:});
diff --git a/scripts/plot/patch.m b/scripts/plot/patch.m
--- a/scripts/plot/patch.m
+++ b/scripts/plot/patch.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} patch ()
 ## @deftypefnx {Function File} {} patch (@var{x}, @var{y}, @var{c})
 ## @deftypefnx {Function File} {} patch (@var{x}, @var{y}, @var{z}, @var{c})
 ## @deftypefnx {Function File} {} patch (@var{fv})
-## @deftypefnx {Function File} {} patch ('Faces', @var{f}, 'Vertices', @var{v}, @dots{})
+## @deftypefnx {Function File} {} patch ("Faces", @var{f}, "Vertices", @var{v}, @dots{})
 ## @deftypefnx {Function File} {} patch (@dots{}, @var{prop}, @var{val})
 ## @deftypefnx {Function File} {} patch (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} patch (@dots{})
 ## Create patch object from @var{x} and @var{y} with color @var{c} and
 ## insert in the current axes object.  Return handle to patch object.
 ##
 ## For a uniform colored patch, @var{c} can be given as an RGB vector,
 ## scalar value referring to the current colormap, or string value (for
diff --git a/scripts/plot/pie.m b/scripts/plot/pie.m
--- a/scripts/plot/pie.m
+++ b/scripts/plot/pie.m
@@ -24,17 +24,17 @@
 ## @deftypefnx {Function File} {@var{h} =} pie (@dots{});
 ## Produce a 2-D pie chart.
 ##
 ## Called with a single vector argument, produces a pie chart of the
 ## elements in @var{x}, with the size of the slice determined by percentage
 ## size of the values of @var{x}.
 ##
 ## The variable @var{explode} is a vector of the same length as @var{x} that
-## if non zero 'explodes' the slice from the pie chart.
+## if non zero "explodes" the slice from the pie chart.
 ##
 ## If given @var{labels} is a cell array of strings of the same length as
 ## @var{x}, giving the labels of each of the slices of the pie chart.
 ##
 ## The optional return value @var{h} is a list of handles to the patch
 ## and text objects generating the plot.
 ##
 ## @seealso{pie3, bar, stem}
diff --git a/scripts/plot/pie3.m b/scripts/plot/pie3.m
--- a/scripts/plot/pie3.m
+++ b/scripts/plot/pie3.m
@@ -25,17 +25,17 @@
 ## @deftypefnx {Function File} {@var{h} =} pie3 (@dots{});
 ## Draw a 3-D pie chart.
 ##
 ## Called with a single vector argument, produces a 3-D pie chart of the
 ## elements in @var{x}, with the size of the slice determined by percentage
 ## size of the values of @var{x}.
 ##
 ## The variable @var{explode} is a vector of the same length as @var{x} that
-## if non zero 'explodes' the slice from the pie chart.
+## if non zero "explodes" the slice from the pie chart.
 ##
 ## If given @var{labels} is a cell array of strings of the same length as
 ## @var{x}, giving the labels of each of the slices of the pie chart.
 ##
 ## The optional return value @var{h} is a list of graphics handles to the patch,
 ## surface, and text objects generating the plot.
 ##
 ## @seealso{pie, bar, stem}
diff --git a/scripts/plot/quiver.m b/scripts/plot/quiver.m
--- a/scripts/plot/quiver.m
+++ b/scripts/plot/quiver.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} quiver (@var{u}, @var{v})
 ## @deftypefnx {Function File} {} quiver (@var{x}, @var{y}, @var{u}, @var{v})
 ## @deftypefnx {Function File} {} quiver (@dots{}, @var{s})
 ## @deftypefnx {Function File} {} quiver (@dots{}, @var{style})
-## @deftypefnx {Function File} {} quiver (@dots{}, 'filled')
+## @deftypefnx {Function File} {} quiver (@dots{}, "filled")
 ## @deftypefnx {Function File} {} quiver (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} quiver (@dots{})
 ##
 ## Plot the @code{(@var{u}, @var{v})} components of a vector field in
 ## an @code{(@var{x}, @var{y})} meshgrid.  If the grid is uniform, you can
 ## specify @var{x} and @var{y} as vectors.
 ##
 ## If @var{x} and @var{y} are undefined they are assumed to be
@@ -35,17 +35,17 @@
 ##
 ## The variable @var{s} is a scalar defining a scaling factor to use for
 ## the arrows of the field relative to the mesh spacing.  A value of 0
 ## disables all scaling.  The default value is 1.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ## If a marker is specified then markers at the grid points of the vectors are
-## printed rather than arrows.  If the argument 'filled' is given then the
+## printed rather than arrows.  If the argument "filled" is given then the
 ## markers as filled.
 ##
 ## The optional return value @var{h} is a graphics handle to a quiver object.
 ## A quiver object regroups the components of the quiver plot (body, arrow,
 ## and marker), and allows them to be changed together.
 ##
 ## @example
 ## @group
diff --git a/scripts/plot/quiver3.m b/scripts/plot/quiver3.m
--- a/scripts/plot/quiver3.m
+++ b/scripts/plot/quiver3.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} quiver3 (@var{u}, @var{v}, @var{w})
 ## @deftypefnx {Function File} {} quiver3 (@var{x}, @var{y}, @var{z}, @var{u}, @var{v}, @var{w})
 ## @deftypefnx {Function File} {} quiver3 (@dots{}, @var{s})
 ## @deftypefnx {Function File} {} quiver3 (@dots{}, @var{style})
-## @deftypefnx {Function File} {} quiver3 (@dots{}, 'filled')
+## @deftypefnx {Function File} {} quiver3 (@dots{}, "filled")
 ## @deftypefnx {Function File} {} quiver3 (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} quiver3 (@dots{})
 ##
 ## Plot the @code{(@var{u}, @var{v}, @var{w})} components of a vector field in
 ## an @code{(@var{x}, @var{y}), @var{z}} meshgrid.  If the grid is uniform, you
 ## can specify @var{x}, @var{y} @var{z} as vectors.
 ##
 ## If @var{x}, @var{y} and @var{z} are undefined they are assumed to be
@@ -35,17 +35,17 @@
 ##
 ## The variable @var{s} is a scalar defining a scaling factor to use for
 ##  the arrows of the field relative to the mesh spacing.  A value of 0
 ## disables all scaling.  The default value is 1.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ## If a marker is specified then markers at the grid points of the vectors are
-## printed rather than arrows.  If the argument 'filled' is given then the
+## printed rather than arrows.  If the argument "filled" is given then the
 ## markers as filled.
 ##
 ## The optional return value @var{h} is a graphics handle to a quiver object.
 ## A quiver object regroups the components of the quiver plot (body, arrow,
 ## and marker), and allows them to be changed together.
 ##
 ## @example
 ## @group
diff --git a/scripts/plot/scatter3.m b/scripts/plot/scatter3.m
--- a/scripts/plot/scatter3.m
+++ b/scripts/plot/scatter3.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} scatter3 (@var{x}, @var{y}, @var{z}, @var{s}, @var{c})
-## @deftypefnx {Function File} {} scatter3 (@dots{}, 'filled')
+## @deftypefnx {Function File} {} scatter3 (@dots{}, "filled")
 ## @deftypefnx {Function File} {} scatter3 (@dots{}, @var{style})
 ## @deftypefnx {Function File} {} scatter3 (@dots{}, @var{prop}, @var{val})
 ## @deftypefnx {Function File} {} scatter3 (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} scatter3 (@dots{})
 ##
 ## Plot a scatter plot of the data in 3D@.  A marker is plotted at each point
 ## defined by the points in the vectors @var{x}, @var{y} and @var{z}.  The size
 ## of the markers used is determined by @var{s}, which can be a scalar or
@@ -33,17 +33,17 @@
 ## The color of the markers is determined by @var{c}, which can be a string
 ## defining a fixed color; a 3-element vector giving the red, green, and blue
 ## components of the color; a vector of the same length as @var{x} that gives
 ## a scaled index into the current colormap; or a @var{n}-by-3 matrix defining
 ## the colors of each of the markers individually.
 ##
 ## The marker to use can be changed with the @var{style} argument, that is a
 ## string defining a marker in the same manner as the @code{plot} command.
-## If the argument 'filled' is given then the markers as filled.  All
+## If the argument "filled" is given then the markers as filled.  All
 ## additional arguments are passed to the underlying patch command.
 ##
 ## The optional return value @var{h} is a graphics handle to the hggroup
 ## object representing the points.
 ##
 ## @example
 ## @group
 ## [x, y, z] = peaks (20);
diff --git a/scripts/plot/uicontextmenu.m b/scripts/plot/uicontextmenu.m
--- a/scripts/plot/uicontextmenu.m
+++ b/scripts/plot/uicontextmenu.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {@var{handle} =} uicontextmenu ('Name', value, @dots{})
+## @deftypefn {Function File} {@var{handle} =} uicontextmenu ("Name", value, @dots{})
 ## @end deftypefn
 
 ## Author: goffioul
 
 function handle = uicontextmenu (varargin)
 
   [h, args] = __uiobject_split_args__ ("uicontextmenu", varargin, {"figure"});
   handle = __go_uicontextmenu__ (h, args{:});
diff --git a/scripts/plot/uicontrol.m b/scripts/plot/uicontrol.m
--- a/scripts/plot/uicontrol.m
+++ b/scripts/plot/uicontrol.m
@@ -12,18 +12,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{handle} =} uicontrol ('Name', value, @dots{})
-## @deftypefnx {Function File} {@var{handle} =} uicontrol (@var{parent}, 'Name', value, @dots{})
+## @deftypefn  {Function File} {@var{handle} =} uicontrol ("Name", value, @dots{})
+## @deftypefnx {Function File} {@var{handle} =} uicontrol (@var{parent}, "Name", value, @dots{})
 ## @deftypefnx {Function File} {} uicontrol (@var{handle})
 ## @end deftypefn
 
 ## Author: goffioul
 
 function handle = uicontrol (varargin)
 
   if (nargin == 1 && ishandle (varargin{1}) && strcmpi (get (varargin{1}, "type"), "uicontrol"))
diff --git a/scripts/plot/uipanel.m b/scripts/plot/uipanel.m
--- a/scripts/plot/uipanel.m
+++ b/scripts/plot/uipanel.m
@@ -12,18 +12,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{handle} =} uipanel ('Name', value, @dots{})
-## @deftypefnx {Function File} {@var{handle} =} uipanel (@var{parent}, 'Name', value, @dots{})
+## @deftypefn  {Function File} {@var{handle} =} uipanel ("Name", value, @dots{})
+## @deftypefnx {Function File} {@var{handle} =} uipanel (@var{parent}, "Name", value, @dots{})
 ## @end deftypefn
 
 ## Author: goffioul
 
 function handle = uipanel (varargin)
 
   [h, args] = __uiobject_split_args__ ("uipanel", varargin, {"figure", "uipanel", "uibuttongroup"});
   handle = __go_uipanel__ (h, args{:});
diff --git a/scripts/plot/uipushtool.m b/scripts/plot/uipushtool.m
--- a/scripts/plot/uipushtool.m
+++ b/scripts/plot/uipushtool.m
@@ -12,18 +12,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{handle} =} uipushtool ('Name', value, @dots{})
-## @deftypefnx {Function File} {@var{handle} =} uipushtool (@var{parent}, 'Name', value, @dots{})
+## @deftypefn  {Function File} {@var{handle} =} uipushtool ("Name", value, @dots{})
+## @deftypefnx {Function File} {@var{handle} =} uipushtool (@var{parent}, "Name", value, @dots{})
 ## @end deftypefn
 
 ## Author: goffioul
 
 function handle = uipushtool (varargin)
 
   [h, args] = __uiobject_split_args__ ("uipushtool", varargin, {"uitoolbar"}, 0);
   if (isempty (h))
diff --git a/scripts/plot/uitoggletool.m b/scripts/plot/uitoggletool.m
--- a/scripts/plot/uitoggletool.m
+++ b/scripts/plot/uitoggletool.m
@@ -12,18 +12,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{handle} =} uitoggletool ('Name', value, @dots{})
-## @deftypefnx {Function File} {@var{handle} =} uitoggletool (@var{parent}, 'Name', value, @dots{})
+## @deftypefn  {Function File} {@var{handle} =} uitoggletool ("Name", value, @dots{})
+## @deftypefnx {Function File} {@var{handle} =} uitoggletool (@var{parent}, "Name", value, @dots{})
 ## @end deftypefn
 
 ## Author: goffioul
 
 function handle = uitoggletool (varargin)
 
   [h, args] = __uiobject_split_args__ ("uitoggletool", varargin, {"uitoolbar"}, 0);
   if (isempty (h))
diff --git a/scripts/plot/uitoolbar.m b/scripts/plot/uitoolbar.m
--- a/scripts/plot/uitoolbar.m
+++ b/scripts/plot/uitoolbar.m
@@ -12,18 +12,18 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{handle} =} uitoolbar ('Name', value, @dots{})
-## @deftypefnx {Function File} {@var{handle} =} uitoolbar (@var{parent}, 'Name', value, @dots{})
+## @deftypefn  {Function File} {@var{handle} =} uitoolbar ("Name", value, @dots{})
+## @deftypefnx {Function File} {@var{handle} =} uitoolbar (@var{parent}, "Name", value, @dots{})
 ## @end deftypefn
 
 ## Author: goffioul
 
 function handle = uitoolbar (varargin)
 
   [h, args] = __uiobject_split_args__ ("uitoolbar", varargin, {"figure"});
   handle = __go_uitoolbar__ (h, args{:});
diff --git a/scripts/plot/xlim.m b/scripts/plot/xlim.m
--- a/scripts/plot/xlim.m
+++ b/scripts/plot/xlim.m
@@ -18,27 +18,27 @@
 
 ## -*- texinfo -*-
 ## @c List other forms of function in documentation index
 ## @findex ylim
 ## @findex zlim
 ##
 ## @deftypefn  {Function File} {@var{xl} =} xlim ()
 ## @deftypefnx {Function File} {} xlim (@var{xl})
-## @deftypefnx {Function File} {@var{m} =} xlim ('mode')
+## @deftypefnx {Function File} {@var{m} =} xlim ("mode")
 ## @deftypefnx {Function File} {} xlim (@var{m})
 ## @deftypefnx {Function File} {} xlim (@var{h}, @dots{})
 ## Get or set the limits of the x-axis of the current plot.  Called without
 ## arguments @code{xlim} returns the x-axis limits of the current plot.
 ## If passed a two element vector @var{xl}, the limits of the x-axis are set
 ## to this value.
 ##
 ## The current mode for calculation of the x-axis can be returned with a
-## call @code{xlim ('mode')}, and can be either 'auto' or 'manual'.  The
-## current plotting mode can be set by passing either 'auto' or 'manual'
+## call @code{xlim ("mode")}, and can be either "auto" or "manual".  The
+## current plotting mode can be set by passing either "auto" or "manual"
 ## as the argument.
 ##
 ## If passed a handle as the first argument, then operate on this handle
 ## rather than the current axes handle.
 ## @seealso{ylim, zlim, set, get, gca}
 ## @end deftypefn
 
 function retval = xlim (varargin)
diff --git a/scripts/plot/ylim.m b/scripts/plot/ylim.m
--- a/scripts/plot/ylim.m
+++ b/scripts/plot/ylim.m
@@ -14,27 +14,27 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{yl} =} ylim ()
 ## @deftypefnx {Function File} {} ylim (@var{yl})
-## @deftypefnx {Function File} {@var{m} =} ylim ('mode')
+## @deftypefnx {Function File} {@var{m} =} ylim ("mode")
 ## @deftypefnx {Function File} {} ylim (@var{m})
 ## @deftypefnx {Function File} {} ylim (@var{h}, @dots{})
 ## Get or set the limits of the y-axis of the current plot.  Called without
 ## arguments @code{ylim} returns the y-axis limits of the current plot.
 ## If passed a two element vector @var{yl}, the limits of the y-axis are set
 ## to this value.
 ##
 ## The current mode for calculation of the y-axis can be returned with a
-## call @code{ylim ('mode')}, and can be either 'auto' or 'manual'.  The
-## current plotting mode can be set by passing either 'auto' or 'manual'
+## call @code{ylim ("mode")}, and can be either "auto" or "manual".  The
+## current plotting mode can be set by passing either "auto" or "manual"
 ## as the argument.
 ##
 ## If passed a handle as the first argument, then operate on this handle
 ## rather than the current axes handle.
 ## @seealso{xlim, zlim, set, get, gca}
 ## @end deftypefn
 
 function retval = ylim (varargin)
diff --git a/scripts/plot/zlim.m b/scripts/plot/zlim.m
--- a/scripts/plot/zlim.m
+++ b/scripts/plot/zlim.m
@@ -14,27 +14,27 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{zl} =} zlim ()
 ## @deftypefnx {Function File} {} zlim (@var{zl})
-## @deftypefnx {Function File} {@var{m} =} zlim ('mode')
+## @deftypefnx {Function File} {@var{m} =} zlim ("mode")
 ## @deftypefnx {Function File} {} zlim (@var{m})
 ## @deftypefnx {Function File} {} zlim (@var{h}, @dots{})
 ## Get or set the limits of the z-axis of the current plot.  Called without
 ## arguments @code{zlim} returns the z-axis limits of the current plot.
 ## If passed a two element vector @var{zl}, the limits of the z-axis are set
 ## to this value.
 ##
 ## The current mode for calculation of the z-axis can be returned with a
-## call @code{zlim ('mode')}, and can be either 'auto' or 'manual'.  The
-## current plotting mode can be set by passing either 'auto' or 'manual'
+## call @code{zlim ("mode")}, and can be either "auto" or "manual".  The
+## current plotting mode can be set by passing either "auto" or "manual"
 ## as the argument.
 ##
 ## If passed a handle as the first argument, then operate on this handle
 ## rather than the current axes handle.
 ## @seealso{xlim, ylim, set, get, gca}
 ## @end deftypefn
 
 function retval = zlim (varargin)
diff --git a/scripts/set/ismember.m b/scripts/set/ismember.m
--- a/scripts/set/ismember.m
+++ b/scripts/set/ismember.m
@@ -35,18 +35,18 @@
 ##      @result{} s_idx = [4, 0, 2]
 ## @end group
 ## @end example
 ##
 ## The inputs, @var{A} and @var{s}, may also be cell arrays.
 ##
 ## @example
 ## @group
-## a = @{'abc'@};
-## s = @{'abc', 'def'@};
+## a = @{"abc"@};
+## s = @{"abc", "def"@};
 ## [tf, s_idx] = ismember (a, s)
 ##      @result{} tf = [1, 0]
 ##      @result{} s_idx = [1, 0]
 ## @end group
 ## @end example
 ##
 ## With the optional third argument @code{"rows"}, and matrices
 ## @var{A} and @var{s} with the same number of columns, compare rows in
diff --git a/scripts/set/setxor.m b/scripts/set/setxor.m
--- a/scripts/set/setxor.m
+++ b/scripts/set/setxor.m
@@ -14,17 +14,17 @@
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} setxor (@var{a}, @var{b})
-## @deftypefnx {Function File} {} setxor (@var{a}, @var{b}, 'rows')
+## @deftypefnx {Function File} {} setxor (@var{a}, @var{b}, "rows")
 ## @deftypefnx {Function File} {[@var{c}, @var{ia}, @var{ib}] =} setxor (@var{a}, @var{b})
 ##
 ## Return the elements exclusive to @var{a} or @var{b}, sorted in ascending
 ## order.  If @var{a} and @var{b} are both column vectors return a column
 ## vector, otherwise return a row vector.
 ## @var{a}, @var{b} may be cell arrays of string(s).
 ##
 ## With three output arguments, return index vectors @var{ia} and @var{ib}
diff --git a/scripts/signal/filter2.m b/scripts/signal/filter2.m
--- a/scripts/signal/filter2.m
+++ b/scripts/signal/filter2.m
@@ -19,23 +19,23 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{y} =} filter2 (@var{b}, @var{x})
 ## @deftypefnx {Function File} {@var{y} =} filter2 (@var{b}, @var{x}, @var{shape})
 ## Apply the 2-D FIR filter @var{b} to @var{x}.  If the argument
 ## @var{shape} is specified, return an array of the desired shape.
 ## Possible values are:
 ##
 ## @table @asis
-## @item 'full'
+## @item "full"
 ## pad @var{x} with zeros on all sides before filtering.
 ##
-## @item 'same'
+## @item "same"
 ## unpadded @var{x} (default)
 ##
-## @item 'valid'
+## @item "valid"
 ## trim @var{x} after filtering so edge effects are no included.
 ## @end table
 ##
 ## Note this is just a variation on convolution, with the parameters
 ## reversed and @var{b} rotated 180 degrees.
 ## @seealso{conv2}
 ## @end deftypefn
 
diff --git a/scripts/sparse/bicg.m b/scripts/sparse/bicg.m
--- a/scripts/sparse/bicg.m
+++ b/scripts/sparse/bicg.m
@@ -35,18 +35,18 @@
 ##
 ## @var{A} can be passed as a matrix or as a function handle or
 ## inline function @code{f} such that @code{f(x, "notransp") = A*x}
 ## and @code{f(x, "transp") = A'*x}.
 ##
 ## The preconditioner @var{P} is given as @code{P = M1 * M2}.
 ## Both @var{M1} and @var{M2} can be passed as a matrix or as
 ## a function handle or inline function @code{g} such that
-## @code{g(x, 'notransp') = M1 \ x} or @code{g(x, 'notransp') = M2 \ x} and
-## @code{g(x, 'transp') = M1' \ x} or @code{g(x, 'transp') = M2' \ x}.
+## @code{g(x, "notransp") = M1 \ x} or @code{g(x, "notransp") = M2 \ x} and
+## @code{g(x, "transp") = M1' \ x} or @code{g(x, "transp") = M2' \ x}.
 ##
 ## If called with more than one output parameter
 ##
 ## @itemize @minus
 ## @item @var{flag} indicates the exit status:
 ## @itemize @minus
 ## @item 0: iteration converged to the within the chosen tolerance
 ##
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -14,18 +14,18 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} demo @var{name}
 ## @deftypefnx {Command} {} demo @var{name} @var{n}
-## @deftypefnx {Function File} {} demo ('@var{name}')
-## @deftypefnx {Function File} {} demo ('@var{name}', @var{n})
+## @deftypefnx {Function File} {} demo ("@var{name}")
+## @deftypefnx {Function File} {} demo ("@var{name}", @var{n})
 ##
 ## Run example code block @var{n} associated with the function @var{name}.
 ## If @var{n} is not specified, all examples are run.
 ##
 ## Examples are stored in the script file, or in a file with the same
 ## name but no extension located on Octave's load path.  To keep examples
 ## separate from regular script code, all lines are prefixed by @code{%!}.  Each
 ## example must also be introduced by the keyword 'demo' flush left to the
@@ -60,17 +60,17 @@
 ## between the sections, but this is discouraged.  Other techniques
 ## to avoid multiple initialization blocks include using multiple plots
 ## with a new @code{figure} command between each plot, or using @code{subplot}
 ## to put multiple plots in the same window.
 ##
 ## Also, because demo evaluates within a function context, you cannot
 ## define new functions inside a demo.  If you must have function blocks,
 ## rather than just anonymous functions or inline functions, you will have to
-## use @code{eval(example('function',n))} to see them.  Because eval only
+## use @code{eval(example("function",n))} to see them.  Because eval only
 ## evaluates one line, or one statement if the statement crosses
 ## multiple lines, you must wrap your demo in "if 1 <demo stuff> endif"
 ## with the 'if' on the same line as 'demo'.  For example:
 ##
 ## @example
 ## @group
 ## %!demo if 1
 ## %!  function y=f(x)
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -14,22 +14,22 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} example @var{name}
 ## @deftypefnx {Command} {} example @var{name} @var{n}
-## @deftypefnx {Function File} {} example ('@var{name}')
-## @deftypefnx {Function File} {} example ('@var{name}', @var{n})
+## @deftypefnx {Function File} {} example ("@var{name}")
+## @deftypefnx {Function File} {} example ("@var{name}", @var{n})
 ## @deftypefnx {Function File} {[@var{s}, @var{idx}] =} example (@dots{})
 ##
 ## Display the code for example @var{n} associated with the function
-## '@var{name}', but do not run it.  If @var{n} is not specified, all examples
+## "@var{name}", but do not run it.  If @var{n} is not specified, all examples
 ## are displayed.
 ##
 ## When called with output arguments, the examples are returned in the form of
 ## a string @var{s}, with @var{idx} indicating the ending position of the
 ## various examples.
 ##
 ## See @code{demo} for a complete explanation.
 ## @seealso{demo, test}
diff --git a/scripts/testfun/fail.m b/scripts/testfun/fail.m
--- a/scripts/testfun/fail.m
+++ b/scripts/testfun/fail.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 ##
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} fail (@var{code})
 ## @deftypefnx {Function File} {} fail (@var{code}, @var{pattern})
-## @deftypefnx {Function File} {} fail (@var{code}, 'warning', @var{pattern})
+## @deftypefnx {Function File} {} fail (@var{code}, "warning", @var{pattern})
 ##
 ## Return true if @var{code} fails with an error message matching
 ## @var{pattern}, otherwise produce an error.  Note that @var{code}
 ## is a string and if @var{code} runs successfully, the error produced is:
 ##
 ## @example
 ##           expected error but got none
 ## @end example
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -14,61 +14,61 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} test @var{name}
 ## @deftypefnx {Command} {} test @var{name} quiet|normal|verbose
-## @deftypefnx {Function File} {} test ('@var{name}', 'quiet|normal|verbose', @var{fid})
-## @deftypefnx {Function File} {} test ([], 'explain', @var{fid})
+## @deftypefnx {Function File} {} test ("@var{name}", "quiet|normal|verbose", @var{fid})
+## @deftypefnx {Function File} {} test ([], "explain", @var{fid})
 ## @deftypefnx {Function File} {@var{success} =} test (@dots{})
 ## @deftypefnx {Function File} {[@var{n}, @var{max}] =} test (@dots{})
-## @deftypefnx {Function File} {[@var{code}, @var{idx}] =} test ('@var{name}', 'grabdemo')
+## @deftypefnx {Function File} {[@var{code}, @var{idx}] =} test ("@var{name}", "grabdemo")
 ##
 ## Perform tests from the first file in the loadpath matching @var{name}.
 ## @code{test} can be called as a command or as a function.  Called with
 ## a single argument @var{name}, the tests are run interactively and stop
 ## after the first error is encountered.
 ##
 ## With a second argument the tests which are performed and the amount of
 ## output is selected.
 ##
 ## @table @asis
-## @item 'quiet'
+## @item "quiet"
 ##  Don't report all the tests as they happen, just the errors.
 ##
-## @item 'normal'
+## @item "normal"
 ## Report all tests as they happen, but don't do tests which require
 ## user interaction.
 ##
-## @item 'verbose'
+## @item "verbose"
 ## Do tests which require user interaction.
 ## @end table
 ##
 ## The argument @var{fid} can be used to allow batch processing.  Errors
 ## can be written to the already open file defined by @var{fid}, and
 ## hopefully when Octave crashes this file will tell you what was happening
 ## when it did.  You can use @code{stdout} if you want to see the results as
 ## they happen.  You can also give a file name rather than an @var{fid}, in
 ## which case the contents of the file will be replaced with the log from
 ## the current test.
 ##
 ## Called with a single output argument @var{success}, @code{test} returns
 ## true if all of the tests were successful.  Called with two output arguments
 ## @var{n} and @var{max}, the number of successful tests and the total number
 ## of tests in the file @var{name} are returned.
 ##
-## If the second argument is the string 'grabdemo', the contents of the demo
+## If the second argument is the string "grabdemo", the contents of the demo
 ## blocks are extracted but not executed.  Code for all code blocks is
 ## concatenated and returned as @var{code} with @var{idx} being a vector of
 ## positions of the ends of the demo blocks.
 ##
-## If the second argument is 'explain', then @var{name} is ignored and an
+## If the second argument is "explain", then @var{name} is ignored and an
 ## explanation of the line markers used is written to the file @var{fid}.
 ## @seealso{assert, fail, error, demo, example}
 ## @end deftypefn
 
 ## FIXME: * Consider using keyword fail rather then error?  This allows us
 ## to make a functional form of error blocks, which means we
 ## can include them in test sections which means that we can use
 ## octave flow control for both kinds of tests.
