# HG changeset patch
# User Rik <rik@octave.org>
# Date 1447893622 28800
#      Wed Nov 18 16:40:22 2015 -0800
# Node ID 5b7643257978d4f8f2870f41c434993d067dc05f
# Parent  7b6d8c19dab09416a9748c7d2973c1ac002b7e77
Remove trailing whitespace at end of lines.

* stl_algo.h-fixed, container.txi, genpropdoc.m, gui.txi, plot.txi,
plotimages.m, RELEASE.PROCESS, Figure.cc, Figure.h, gl-render.h,
gl2ps-renderer.cc, gl2ps-renderer.h, graphics.cc, jit-typeinfo.cc, sub2ind.cc,
txt-eng-ft.cc, txt-eng-ft.h, ov-base-diag.h, ov-base-mat.cc, pt-eval.cc,
CMatrix.cc, acinclude.m4, quadgk.m, uicontextmenu.m, uicontrol.m, uipanel.m,
uipushtool.m, uitoggletool.m, uitoolbar.m, waitbar.m, imshow.m, viridis.m,
ode_event_handler.m, fminunc.m, fplot.m, plot.m, surfnorm.m, quantile.m,
datevec.m: Remove trailing whitespace at end of lines.

diff --git a/.hgignore b/.hgignore
--- a/.hgignore
+++ b/.hgignore
@@ -1,17 +1,17 @@
 syntax: regexp
 # The recurrent (^|/) idiom in the regexps below should be understood
 # to mean "at any directory" while the ^ idiom means "from the
 # project's top-level directory".
 
 # gnulib makes these silly backup files
 .~$
 
-# This directory gets created by gnulib during the build. 
+# This directory gets created by gnulib during the build.
 # It contains no Octave files.
 ^libgnu/*
 
 # This directory mostly contains cruft during build time, but it does
 # contain some Octave code, so we gotta be a bit more careful about
 # what we ignore here
 ^m4/(?!ax_).+\.m4$
 
diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -33,17 +33,17 @@ Summary of important user-visible change
  ** Unknown escape sequences in the replacement string for regexprep are now
     substituted with their unescaped version and no warning is emitted.
     This change was made for Matlab compatibility.
 
     Example: regexprep ('a', 'a', 'x\yz')
              => 'xyz'
 
  ** mkfifo now interprets the MODE argument as an octal, not decimal, integer.
-    This is consistent with the equivalent shell command. 
+    This is consistent with the equivalent shell command.
 
  ** linspace now returns an empty matrix if the number of requested points
     is 0 or a negative number.  This change was made to be compatible with
     Matlab releases newer than 2011.  In addition, Octave no longer supports
     matrix inputs for A or B.
 
  ** The griddata function no longer plots the interpolated mesh if no output
     argument is requested, instead the vector or array of interpolated values
@@ -240,17 +240,17 @@ Summary of important user-visible change
     switches to '%g'.
 
  ** The functions intersect, setdiff, setxor, and union now return a
     column vector as output unless the input was a row vector.  This change
     was made for Matlab compatibility.
 
  ** The inpolygon function now returns true for points that are within
     the polygon OR on it's edge.  This change was made for Matlab
-    compatibility. 
+    compatibility.
 
  ** The archive family of functions (bzip2, gzip, zip, tar) and their
     unpacking routines (bunzip2, gunzip, unzip, untar, unpack) have
     been recoded.  Excepting unpack, the default is now to place files
     in the same directory as the archive (on unpack) or as the original
     files (on archiving).
 
  ** Qt and FLTK graphics toolkits now support offscreen rendering on Linux.
diff --git a/build-aux/stl_algo.h-fixed b/build-aux/stl_algo.h-fixed
--- a/build-aux/stl_algo.h-fixed
+++ b/build-aux/stl_algo.h-fixed
@@ -378,33 +378,33 @@ namespace std _GLIBCXX_VISIBILITY(defaul
   /**
    *  This is an uglified
    *  search_n(_ForwardIterator, _ForwardIterator, _Integer, const _Tp&)
    *  overloaded for random access iterators.
   */
   template<typename _RandomAccessIter, typename _Integer, typename _Tp>
     _RandomAccessIter
     __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
-	       _Integer __count, const _Tp& __val, 
+	       _Integer __count, const _Tp& __val,
 	       std::random_access_iterator_tag)
     {
-      
+
       typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 	_DistanceType;
 
       _DistanceType __tailSize = __last - __first;
       _DistanceType __remainder = __count;
 
       while (__remainder <= __tailSize) // the main loop...
 	{
 	  __first += __remainder;
 	  __tailSize -= __remainder;
 	  // __first here is always pointing to one past the last element of
 	  // next possible match.
-	  _RandomAccessIter __backTrack = __first; 
+	  _RandomAccessIter __backTrack = __first;
 	  while (*--__backTrack == __val)
 	    {
 	      if (--__remainder == 0)
 	        return (__first - __count); // Success
 	    }
 	  __remainder = __count + 1 - (__first - __backTrack);
 	}
       return __last; // Failure
@@ -459,30 +459,30 @@ namespace std _GLIBCXX_VISIBILITY(defaul
   */
   template<typename _RandomAccessIter, typename _Integer, typename _Tp,
 	   typename _BinaryPredicate>
     _RandomAccessIter
     __search_n(_RandomAccessIter __first, _RandomAccessIter __last,
 	       _Integer __count, const _Tp& __val,
 	       _BinaryPredicate __binary_pred, std::random_access_iterator_tag)
     {
-      
+
       typedef typename std::iterator_traits<_RandomAccessIter>::difference_type
 	_DistanceType;
 
       _DistanceType __tailSize = __last - __first;
       _DistanceType __remainder = __count;
 
       while (__remainder <= __tailSize) // the main loop...
 	{
 	  __first += __remainder;
 	  __tailSize -= __remainder;
 	  // __first here is always pointing to one past the last element of
 	  // next possible match.
-	  _RandomAccessIter __backTrack = __first; 
+	  _RandomAccessIter __backTrack = __first;
 	  while (__binary_pred(*--__backTrack, __val))
 	    {
 	      if (--__remainder == 0)
 	        return (__first - __count); // Success
 	    }
 	  __remainder = __count + 1 - (__first - __backTrack);
 	}
       return __last; // Failure
@@ -1047,17 +1047,17 @@ namespace std _GLIBCXX_VISIBILITY(defaul
       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)
       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator1,
 	    typename iterator_traits<_InputIterator>::value_type>)
       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator2,
 	    typename iterator_traits<_InputIterator>::value_type>)
       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,
 	    typename iterator_traits<_InputIterator>::value_type>)
       __glibcxx_requires_valid_range(__first, __last);
-      
+
       for (; __first != __last; ++__first)
 	if (__pred(*__first))
 	  {
 	    *__out_true = *__first;
 	    ++__out_true;
 	  }
 	else
 	  {
@@ -1652,17 +1652,17 @@ namespace std _GLIBCXX_VISIBILITY(defaul
   /**
    *  @brief Rotate the elements of a sequence.
    *  @ingroup mutating_algorithms
    *  @param  __first   A forward iterator.
    *  @param  __middle  A forward iterator.
    *  @param  __last    A forward iterator.
    *  @return  Nothing.
    *
-   *  Rotates the elements of the range @p [__first,__last) by 
+   *  Rotates the elements of the range @p [__first,__last) by
    *  @p (__middle - __first) positions so that the element at @p __middle
    *  is moved to @p __first, the element at @p __middle+1 is moved to
    *  @p __first+1 and so on for each element in the range
    *  @p [__first,__last).
    *
    *  This effectively swaps the ranges @p [__first,__middle) and
    *  @p [__middle,__last).
    *
@@ -1691,23 +1691,23 @@ namespace std _GLIBCXX_VISIBILITY(defaul
    *  @ingroup mutating_algorithms
    *  @param  __first   A forward iterator.
    *  @param  __middle  A forward iterator.
    *  @param  __last    A forward iterator.
    *  @param  __result  An output iterator.
    *  @return   An iterator designating the end of the resulting sequence.
    *
    *  Copies the elements of the range @p [__first,__last) to the
-   *  range beginning at @result, rotating the copied elements by 
+   *  range beginning at @result, rotating the copied elements by
    *  @p (__middle-__first) positions so that the element at @p __middle
    *  is moved to @p __result, the element at @p __middle+1 is moved
    *  to @p __result+1 and so on for each element in the range @p
    *  [__first,__last).
    *
-   *  Performs 
+   *  Performs
    *  @p *(__result+(n+(__last-__middle))%(__last-__first))=*(__first+n)
    *  for each @p n in the range @p [0,__last-__first).
   */
   template<typename _ForwardIterator, typename _OutputIterator>
     _OutputIterator
     rotate_copy(_ForwardIterator __first, _ForwardIterator __middle,
                 _ForwardIterator __last, _OutputIterator __result)
     {
@@ -2579,20 +2579,20 @@ namespace std _GLIBCXX_VISIBILITY(defaul
       typedef typename iterator_traits<_ForwardIterator>::difference_type
 	_DistanceType;
 
       // concept requirements
       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)
       __glibcxx_function_requires(_LessThanOpConcept<_ValueType, _Tp>)
       __glibcxx_function_requires(_LessThanOpConcept<_Tp, _ValueType>)	
       __glibcxx_requires_partitioned_lower(__first, __last, __val);
-      __glibcxx_requires_partitioned_upper(__first, __last, __val);      
+      __glibcxx_requires_partitioned_upper(__first, __last, __val);
 
       _DistanceType __len = std::distance(__first, __last);
- 
+
       while (__len > 0)
 	{
 	  _DistanceType __half = __len >> 1;
 	  _ForwardIterator __middle = __first;
 	  std::advance(__middle, __half);
 	  if (*__middle < __val)
 	    {
 	      __first = __middle;
@@ -2979,17 +2979,17 @@ namespace std _GLIBCXX_VISIBILITY(defaul
 				__len22, __buffer, __buffer_size);
 	  std::__merge_adaptive(__new_middle, __second_cut, __last,
 				__len1 - __len11,
 				__len2 - __len22, __buffer, __buffer_size);
 	}
     }
 
   /// This is a helper function for the merge routines.
-  template<typename _BidirectionalIterator, typename _Distance, 
+  template<typename _BidirectionalIterator, typename _Distance,
 	   typename _Pointer, typename _Compare>
     void
     __merge_adaptive(_BidirectionalIterator __first,
                      _BidirectionalIterator __middle,
 		     _BidirectionalIterator __last,
 		     _Distance __len1, _Distance __len2,
 		     _Pointer __buffer, _Distance __buffer_size,
 		     _Compare __comp)
@@ -4063,17 +4063,17 @@ namespace std _GLIBCXX_VISIBILITY(defaul
     }
 
   /**
    *  @brief  Return a pair of iterators pointing to the minimum and maximum
    *          elements in a range.
    *  @ingroup sorting_algorithms
    *  @param  __first  Start of range.
    *  @param  __last   End of range.
-   *  @return  make_pair(m, M), where m is the first iterator i in 
+   *  @return  make_pair(m, M), where m is the first iterator i in
    *           [__first, __last) such that no other element in the range is
    *           smaller, and where M is the last iterator i in [__first, __last)
    *           such that no other element in the range is larger.
   */
   template<typename _ForwardIterator>
     pair<_ForwardIterator, _ForwardIterator>
     minmax_element(_ForwardIterator __first, _ForwardIterator __last)
     {
@@ -4139,17 +4139,17 @@ namespace std _GLIBCXX_VISIBILITY(defaul
 
   /**
    *  @brief  Return a pair of iterators pointing to the minimum and maximum
    *          elements in a range.
    *  @ingroup sorting_algorithms
    *  @param  __first  Start of range.
    *  @param  __last   End of range.
    *  @param  __comp   Comparison functor.
-   *  @return  make_pair(m, M), where m is the first iterator i in 
+   *  @return  make_pair(m, M), where m is the first iterator i in
    *           [__first, __last) such that no other element in the range is
    *           smaller, and where M is the last iterator i in [__first, __last)
    *           such that no other element in the range is larger.
   */
   template<typename _ForwardIterator, typename _Compare>
     pair<_ForwardIterator, _ForwardIterator>
     minmax_element(_ForwardIterator __first, _ForwardIterator __last,
 		   _Compare __comp)
@@ -4257,17 +4257,17 @@ namespace std _GLIBCXX_VISIBILITY(defaul
   /**
    *  @brief  Checks whether a permutaion of the second sequence is equal
    *          to the first sequence.
    *  @ingroup non_mutating_algorithms
    *  @param  __first1  Start of first range.
    *  @param  __last1   End of first range.
    *  @param  __first2  Start of second range.
    *  @return true if there exists a permutation of the elements in the range
-   *          [__first2, __first2 + (__last1 - __first1)), beginning with 
+   *          [__first2, __first2 + (__last1 - __first1)), beginning with
    *          ForwardIterator2 begin, such that equal(__first1, __last1, begin)
    *          returns true; otherwise, returns false.
   */
   template<typename _ForwardIterator1, typename _ForwardIterator2>
     bool
     is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
 		   _ForwardIterator2 __first2)
     {
@@ -4332,17 +4332,17 @@ namespace std _GLIBCXX_VISIBILITY(defaul
       std::advance(__last2, std::distance(__first1, __last1));
       for (_ForwardIterator1 __scan = __first1; __scan != __last1; ++__scan)
 	{
 	  using std::placeholders::_1;
 
 	  if (__scan != _GLIBCXX_STD_A::find_if(__first1, __scan,
 						std::bind(__pred, _1, *__scan)))
 	    continue; // We've seen this one before.
-	  
+	
 	  auto __matches = std::count_if(__first2, __last2,
 					 std::bind(__pred, _1, *__scan));
 	  if (0 == __matches
 	      || std::count_if(__scan, __last1,
 			       std::bind(__pred, _1, *__scan)) != __matches)
 	    return false;
 	}
       return true;
@@ -5101,19 +5101,19 @@ namespace std _GLIBCXX_VISIBILITY(defaul
    *  Copies each element in the range @p [__first,__last) to the range
    *  beginning at @p __result, except that only the first element is copied
    *  from groups of consecutive elements that compare equal.
    *  unique_copy() is stable, so the relative order of elements that are
    *  copied is unchanged.
    *
    *  _GLIBCXX_RESOLVE_LIB_DEFECTS
    *  DR 241. Does unique_copy() require CopyConstructible and Assignable?
-   *  
+   *
    *  _GLIBCXX_RESOLVE_LIB_DEFECTS
-   *  DR 538. 241 again: Does unique_copy() require CopyConstructible and 
+   *  DR 538. 241 again: Does unique_copy() require CopyConstructible and
    *  Assignable?
   */
   template<typename _InputIterator, typename _OutputIterator>
     inline _OutputIterator
     unique_copy(_InputIterator __first, _InputIterator __last,
 		_OutputIterator __result)
     {
       // concept requirements
@@ -5422,17 +5422,17 @@ namespace std _GLIBCXX_VISIBILITY(defaul
   /**
    *  @brief Sort the elements of a sequence.
    *  @ingroup sorting_algorithms
    *  @param  __first   An iterator.
    *  @param  __last    Another iterator.
    *  @return  Nothing.
    *
    *  Sorts the elements in the range @p [__first,__last) in ascending order,
-   *  such that for each iterator @e i in the range @p [__first,__last-1),  
+   *  such that for each iterator @e i in the range @p [__first,__last-1),
    *  *(i+1)<*i is false.
    *
    *  The relative ordering of equivalent elements is not preserved, use
    *  @p stable_sort() if this is needed.
   */
   template<typename _RandomAccessIterator>
     inline void
     sort(_RandomAccessIterator __first, _RandomAccessIterator __last)
@@ -6197,17 +6197,17 @@ namespace std _GLIBCXX_VISIBILITY(defaul
 	    ++__first2;
 	    ++__result;
 	  }
 	else
 	  {
 	    ++__first1;
 	    ++__first2;
 	  }
-      return std::copy(__first2, __last2, 
+      return std::copy(__first2, __last2,
 		       std::copy(__first1, __last1, __result));
     }
 
 
   /**
    *  @brief  Return the minimum element in a range.
    *  @ingroup sorting_algorithms
    *  @param  __first  Start of range.
diff --git a/doc/interpreter/container.txi b/doc/interpreter/container.txi
--- a/doc/interpreter/container.txi
+++ b/doc/interpreter/container.txi
@@ -886,18 +886,19 @@ strcmp ("hello", c)
 @end example
 
 @noindent
 The following string functions support cell arrays of strings:
 @code{char}, @code{strvcat}, @code{strcat} (@pxref{Concatenating
 Strings}), @code{strcmp}, @code{strncmp}, @code{strcmpi},
 @code{strncmpi} (@pxref{Comparing Strings}), @code{str2double},
 @code{deblank}, @code{strtrim}, @code{strtrunc}, @code{strfind},
-@code{strmatch}, , @code{regexp}, @code{regexpi} (@pxref{Manipulating 
-Strings}) and @code{str2double} (@pxref{String Conversions}).
+@code{strmatch}, , @code{regexp}, @code{regexpi}
+(@pxref{Manipulating Strings}) and @code{str2double}
+(@pxref{String Conversions}).
 
 The function @code{iscellstr} can be used to test if an object is a
 cell array of strings.
 
 @DOCSTRING(iscellstr)
 
 @node Processing Data in Cell Arrays
 @subsection Processing Data in Cell Arrays
diff --git a/doc/interpreter/genpropdoc.m b/doc/interpreter/genpropdoc.m
--- a/doc/interpreter/genpropdoc.m
+++ b/doc/interpreter/genpropdoc.m
@@ -167,17 +167,17 @@ handle is not visible in its parent's \"
 always @qcode{\"__objname__\"}";
         s.valid = valid_string;
         s.printdefault = false;
 
       case "uicontextmenu"
         s.doc = "Graphics handle of the uicontextmenu object that is \
 currently associated to this __objname__ object.";
         s.valid = valid_handle;
-        
+
       case "userdata"
         s.doc = "User-defined data to associate with the graphics object.";
         s.valid = "Any Octave data";
 
       case "visible"
         s.doc = "If __prop__ is @qcode{\"off\"}, the __objname__ is \
 not rendered on screen.";
     endswitch
@@ -358,17 +358,17 @@ Lowercase value of the key\n\
 @item Modifier:\n\
 A cell array containing strings representing the modifiers pressed with the \
 key.\n\
 @end table";
         s.valid = valid_fcn;
 
       case "menubar"
         s.doc = "Control the display of the figure menu bar in the upper \
-left of the figure.";  
+left of the figure.";
 
       case "name"
         s.doc = "Name to be displayed in the figure title bar.  The name is \
 displayed to the right of any title determined by the @code{numbertitle} \
 property.";
         s.valid = valid_string;
 
       ## FIXME: Uncomment when support added in graphics.in.h
@@ -588,17 +588,17 @@ to be the same as the length of 2 units 
 
       case "gridcolor"
         s.doc = doc_unused;
 
       case "gridcolormode"
         s.doc = doc_unused;
 
       case "gridlinestyle"
-           
+
       case "labelfontsizemultiplier"
         s.doc = doc_unused;
 
       case "layer"
         s.doc = "Control whether the axes is drawn below child graphics \
 objects (ticks, labels, etc. covered by plotted objects) or above.";
 
       case "linestyleorder"
@@ -618,17 +618,17 @@ objects (ticks, labels, etc. covered by 
       case "minorgridcolor"
         s.doc = doc_unused;
 
       case "minorgridcolormode"
         s.doc = doc_unused;
 
       case "minorgridlinestyle"
       case "mousewheelzoom"
-        s.doc = "Fraction of axes limits to zoom for each wheel movement."; 
+        s.doc = "Fraction of axes limits to zoom for each wheel movement.";
         s.valid = "scalar in the range (0, 1)";
 
       case "nextplot"
       case "outerposition"
         s.doc = "Specify the position of the plot including titles, \
 axes, and legend.  The four elements of the vector are the \
 coordinates of the lower left corner and width and height of the \
 plot, in units normalized to the width and height of the plot \
@@ -664,17 +664,17 @@ height to be 0.4 and 0.5 respectively.  
         s.doc = "Control whether axes tick marks project \"in\" to the plot \
 box or \"out\".";
 
       case "tickdirmode"
 
       case "ticklabelinterpreter"
         s.doc = "Control the way x/y/zticklabel properties are interpreted.\n\
 @xref{XREFinterpreterusage, , @w{Use of the interpreter property}}.";
-        
+
       case "ticklength"
         s.doc = "Two-element vector @code{[2Dlen 3Dlen]} specifying the \
 length of the tickmarks relative to the longest visible axis.";
         s.valid = valid_2elvec;
 
       case "tightinset"
       case "title"
         s.doc = "Graphics handle of the title text object.";
@@ -831,17 +831,17 @@ for the z-axis.  __modemsg__.  @xref{XRE
       case "displayname"
         s.doc = "Text for the legend entry corresponding to this line.";
         s.valid = valid_cellstring;
 
       case "erasemode"
         s.doc = doc_unused;
 
       case "interpreter"
-        
+
       case "linestyle"
         s.doc = "@xref{Line Styles}.";
 
       case "linewidth"
         s.doc = "Width of the line object measured in points.";
 
       case "marker"
         s.doc = "Shape of the marker for each data point.  \
@@ -937,17 +937,17 @@ z data.";
       case "fontweight"
         s.doc = "Control variant of base font used: bold, light, normal, etc.";
 
       case "horizontalalignment"
       case "interpreter"
         s.doc = "Control the way the @qcode{\"string\"} property is \
 interpreted.\n\
 @xref{XREFinterpreterusage, , @w{Use of the interpreter property}}.";
-        
+
       case "linestyle"
         s.doc = sprintf (doc_notimpl, "Background area");
 
       case "linewidth"
         s.doc = sprintf (doc_notimpl, "Background area");
         s.valid = "scalar";
 
       case "margin"
@@ -1232,47 +1232,47 @@ it defines the color at each vertex.";
 
       case "ydata"
         s.valid = valid_vecmat;
 
       case "zdata"
         s.valid = valid_vecmat;
 
     endswitch
-      
+
   ## uimenu properties
   elseif (strcmp (objname, "uimenu"))
     switch (field)
       ## Overridden shared properties
       case "buttondownfcn"
         s.doc = doc_unused;
 
       ## Specific properties
       case "accelerator"
       case "callback"
       case "checked"
       case "enable"
       case "foregroundcolor"
       case "label"
       case "position"
-      case "separator"  
-        
+      case "separator"
+
     endswitch
 
   ## uicontextmenu properties
   elseif (strcmp (objname, "uicontextmenu"))
     switch (field)
       ## Overridden shared properties
       case "buttondownfcn"
         s.doc = doc_unused;
 
       ## Specific properties
       case "callback"
-      case "position" 
-        
+      case "position"
+
     endswitch
 
   ## uipanel properties
   elseif (strcmp (objname, "uipanel"))
     switch (field)
       ## Overridden shared properties
 
       ## Specific properties
diff --git a/doc/interpreter/gui.txi b/doc/interpreter/gui.txi
--- a/doc/interpreter/gui.txi
+++ b/doc/interpreter/gui.txi
@@ -23,17 +23,17 @@ Octave is principally a batch or command
 offer some features for constructing graphical interfaces that interact with
 users.
 
 The GUI elements available are I/O dialogs, a progress bar, and UI elements
 for plot windows.  For example, rather than hardcoding a filename for output
 results a script can open a dialog box and allow the user to choose a file.
 Similarly, if a calculation is expected to take a long time a script can
 display a progress bar.  The various UI elements can be used to fully customize
-the plot window with menubars, context menus, 
+the plot window with menubars, context menus,
 
 Several utility functions make it possible to store private data for use with
 a GUI which will not pollute the user's variable space.
 
 Finally, a program written in Octave might want to have long term storage of
 preferences or state variables.  This can be done with user-defined
 preferences.
 
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -999,17 +999,17 @@ commands can be used to save and re-crea
 
 @DOCSTRING(hgload)
 
 @node Interacting with Plots
 @subsection Interacting with Plots
 
 The user can select points on a plot with the @code{ginput} function or
 select the position at which to place text on the plot with the
-@code{gtext} function using the mouse.  
+@code{gtext} function using the mouse.
 
 @DOCSTRING(ginput)
 
 @DOCSTRING(waitforbuttonpress)
 
 @DOCSTRING(gtext)
 
 More sophisticated user interaction mechanisms can be obtained using the ui*
diff --git a/doc/interpreter/plotimages.m b/doc/interpreter/plotimages.m
--- a/doc/interpreter/plotimages.m
+++ b/doc/interpreter/plotimages.m
@@ -92,17 +92,17 @@ function plotimages (d, nm, typ)
     xlabel ("x");
     ylabel ("erf (x)");
     title ("erf (x) with text annotation");
     if (strcmp (typ, "pdf") && ! strcmp (graphics_toolkit, "gnuplot"))
       text (0.65, 0.6175, ['$\displaystyle\leftarrow x = {2\over\sqrt{\pi}}'...
                            '\int_{0}^{x}e^{-t^2} dt = 0.6175$']);
       ## Be very careful about modifying this.  pdflatex expects to be in
       ## the same directory as the file it is operating on.
-      cd (make_absolute_filename (d)); 
+      cd (make_absolute_filename (d));
       print ([nm ".pdf"], "-dpdflatexstandalone");
       [status, output] = system (["pdflatex " nm]);
       if (status)
         error ("plotimages: Failed to run pdflatex on <extended.pdf>");
       endif
       delete ([nm ".aux"], [nm "-inc.pdf"], [nm ".log"], [nm ".tex"]);
     else
       text (0.65, 0.6175, ['\leftarrow x = {2/\surd\pi {\fontsize{16}' ...
diff --git a/etc/RELEASE.PROCESS b/etc/RELEASE.PROCESS
--- a/etc/RELEASE.PROCESS
+++ b/etc/RELEASE.PROCESS
@@ -40,17 +40,17 @@ This page shows the tasks to be complete
 #: Completion Date:
 <!----------------------------------------------------------------------------->
 # Verify 'make check' is passing
 #* Start discussion on octave-maintainers list about which failing tests must be fixed
 #* Identify and fix any tests determined critical in step above
 #: Completion Date:
 <!----------------------------------------------------------------------------->
 # Run Octave test suite under [http://valgrind.org Valgrind] to check for memory leaks
-#* Results posted to bug report: 
+#* Results posted to bug report:
 #: Completion Date:
 <!----------------------------------------------------------------------------->
 # Review documentation
 #* Grammar check documentation so that it conforms to Octave standards
 #* Spell check documentation
 #* Verify no functions missing from manual
 #* Verify deprecated functions removed from "see also" links
 #* Verify all formats (Info, HTML, pdf) build correctly
diff --git a/libgui/graphics/Figure.cc b/libgui/graphics/Figure.cc
--- a/libgui/graphics/Figure.cc
+++ b/libgui/graphics/Figure.cc
@@ -158,33 +158,33 @@ Figure::Figure (const graphics_object& g
   else
     m_menuBar->hide ();
 
   m_innerRect = boundingBoxToRect (fp.get_boundingbox (true));
   m_outerRect = boundingBoxToRect (fp.get_boundingbox (false));
 
   win->setGeometry (m_innerRect.adjusted (0, -toffset, 0, boffset));
 
-  // Enable mouse tracking unconditionally  
+  // Enable mouse tracking unconditionally
   enableMouseTracking ();
 
-  // When this constructor gets called all properties are already 
+  // When this constructor gets called all properties are already
   // set, even non default. We force "update" here to get things right.
 
   // Figure title
   update (figure::properties::ID_NUMBERTITLE);
 
   // Decide what keyboard events we listen to
   m_container->canvas (m_handle)->setEventMask (0);
   update (figure::properties::ID_KEYPRESSFCN);
   update (figure::properties::ID_KEYRELEASEFCN);
 
   // Visibility
   update (figure::properties::ID_VISIBLE);
-  
+
 
   connect (this, SIGNAL (asyncUpdate (void)),
            this, SLOT (updateContainer (void)));
 
   win->addReceiver (this);
   m_container->addReceiver (this);
 }
 
diff --git a/libgui/graphics/Figure.h b/libgui/graphics/Figure.h
--- a/libgui/graphics/Figure.h
+++ b/libgui/graphics/Figure.h
@@ -108,17 +108,17 @@ private:
 
   void updateFigureToolBarAndMenuBar (void);
 
   static void updateBoundingBoxHelper (void*);
 
   void save_figure_callback (const std::string& file);
   void copy_figure_callback (const std::string& format);
 
-  void enableMouseTracking (void);  
+  void enableMouseTracking (void);
 
 private slots:
   void setMouseMode (MouseMode mode);
   void fileSaveFigure (bool prompt = false);
   void fileSaveFigureAs (void);
   void fileCloseFigure (void);
   void editCopy (bool choose_format = false);
   void helpAboutQtHandles (void);
diff --git a/libinterp/corefcn/gl-render.h b/libinterp/corefcn/gl-render.h
--- a/libinterp/corefcn/gl-render.h
+++ b/libinterp/corefcn/gl-render.h
@@ -122,17 +122,17 @@ protected:
                                uint8NDArray& pixels,
                                Matrix& bbox,
                                int halign = 0, int valign = 0,
                                double rotation = 0.0);
 
   virtual void text_to_strlist (const std::string& txt,
                                 std::list<ft_render::ft_string>& lst,
                                 Matrix& bbox,
-                                int halign = 0, int valign = 0, 
+                                int halign = 0, int valign = 0,
                                 double rotation = 0.0);
 
   virtual Matrix render_text (const std::string& txt,
                               double x, double y, double z,
                               int halign, int valign, double rotation = 0.0);
 
   virtual void draw_pixels (GLsizei w, GLsizei h, GLenum format,
                             GLenum type, const GLvoid *data);
diff --git a/libinterp/corefcn/gl2ps-renderer.cc b/libinterp/corefcn/gl2ps-renderer.cc
--- a/libinterp/corefcn/gl2ps-renderer.cc
+++ b/libinterp/corefcn/gl2ps-renderer.cc
@@ -190,45 +190,45 @@ glps_renderer::alignment_to_mode (int ha
         gl2psa=GL2PS_TEXT_T;
       else if (va == 1)
         gl2psa=GL2PS_TEXT_C;
     }
 
   return gl2psa;
 }
 
-void 
-glps_renderer::fix_strlist_position (double x, double y, double z, 
+void
+glps_renderer::fix_strlist_position (double x, double y, double z,
                                      Matrix box, double rotation,
                                      std::list<ft_render::ft_string>& lst)
 {
-  for (std::list<ft_render::ft_string>::iterator p = lst.begin (); 
+  for (std::list<ft_render::ft_string>::iterator p = lst.begin ();
        p != lst.end (); p++)
     {
       // Get pixel coordinates
       ColumnVector coord_pix = get_transform ().transform (x, y, z, false);
 
       // Translate and rotate
       double rot = rotation * 4.0 * atan (1.0) / 180;
       coord_pix(0) += ((*p).get_x () + box(0))*cos (rot)
                       - ((*p).get_y () + box(1))*sin (rot);
       coord_pix(1) -= ((*p).get_y () + box(1))*cos (rot)
                       + ((*p).get_x () + box(0))*sin (rot);;
-      
+
       // Turn coordinates back into current gl coordinates
-      ColumnVector coord = 
-        get_transform ().untransform (coord_pix(0), coord_pix(1), 
+      ColumnVector coord =
+        get_transform ().untransform (coord_pix(0), coord_pix(1),
                                       coord_pix(2), false);
       (*p).set_x (coord(0));
       (*p).set_y (coord(1));
       (*p).set_z (coord(2));
     }
 }
 
-static std::string 
+static std::string
 code_to_symbol (uint32_t code)
 {
   std::string retval;
 
   uint32_t idx = code - 945;
   if (idx < 25)
     {
       std::string characters("abgdezhqiklmnxoprVstufcyw");
@@ -373,34 +373,34 @@ code_to_symbol (uint32_t code)
 
   if (retval.empty ())
     warning ("print: unhandled symbol %d", code);
 
   return retval;
 }
 
 
-static std::string 
+static std::string
 select_font (caseless_str fn, bool isbold, bool isitalic)
 {
   std::transform (fn.begin (), fn.end (), fn.begin (), ::tolower);
   std::string fontname;
   if (fn == "times" || fn == "times-roman")
     {
       if (isitalic && isbold)
         fontname = "Times-BoldItalic";
       else if (isitalic)
         fontname = "Times-Italic";
       else if (isbold)
         fontname = "Times-Bold";
       else
         fontname = "Times-Roman";
     }
   else if (fn == "courier")
-    { 
+    {
       if (isitalic && isbold)
         fontname = "Courier-BoldOblique";
       else if (isitalic)
         fontname = "Courier-Oblique";
       else if (isbold)
         fontname = "Courier-Bold";
       else
         fontname = "Courier";
@@ -418,17 +418,17 @@ select_font (caseless_str fn, bool isbol
       else if (isbold)
         fontname = "Helvetica-Bold";
       else
         fontname = "Helvetica";
     }
   return fontname;
 }
 
-static void 
+static void
 escape_character (const std::string chr, std::string& str)
 {
   std::size_t idx = str.find (chr);
   while (idx != std::string::npos)
     {
       str.insert (idx, "\\");
       idx = str.find (chr, idx + 2);
     }
@@ -438,28 +438,28 @@ Matrix
 glps_renderer::render_text (const std::string& txt,
                             double x, double y, double z,
                             int ha, int va, double rotation)
 {
   std::string saved_font = fontname;
 
   if (txt.empty ())
     return Matrix (1, 4, 0.0);
-  
-  // We have no way to get a bounding box from gl2ps, so we parse the raw 
+
+  // We have no way to get a bounding box from gl2ps, so we parse the raw
   // string using freetype
   Matrix bbox;
   std::string str = txt;
   std::list<ft_render::ft_string> lst;
 
   text_to_strlist (str, lst, bbox, ha, va, rotation);
 
-  // When using "tex" or when the string has only one line and no 
+  // When using "tex" or when the string has only one line and no
   // special characters, use gl2ps for alignment
-  if (lst.empty () || term.find ("tex") != std::string::npos 
+  if (lst.empty () || term.find ("tex") != std::string::npos
       || (lst.size () == 1  && ! lst.front ().get_code ()))
     {
       std::string name = fontname;
       int sz = fontsize;
       if (! lst.empty () && term.find ("tex") == std::string::npos)
         {
           ft_render::ft_string s = lst.front ();
           name = select_font (s.get_name (), s.get_weight () == "bold",
@@ -467,41 +467,41 @@ glps_renderer::render_text (const std::s
           set_color (s.get_color ());
           str = s.get_string ();
           sz = s.get_size ();
         }
 
       glRasterPos3d (x, y, z);
 
       // Escape parenthesis until gl2ps does it (see bug ##45301).
-      if (term.find ("svg") == std::string::npos 
+      if (term.find ("svg") == std::string::npos
           && term.find ("tex") == std::string::npos)
         {
           escape_character ("(", str);
           escape_character (")", str);
         }
 
       gl2psTextOpt (str.c_str (), name.c_str (), sz,
                     alignment_to_mode (ha, va), rotation);
       return bbox;
     }
 
   // Translate and rotate coordinates in order to use bottom-left alignment
   fix_strlist_position (x, y, z, bbox, rotation, lst);
 
-  for (std::list<ft_render::ft_string>::iterator p = lst.begin (); 
+  for (std::list<ft_render::ft_string>::iterator p = lst.begin ();
        p != lst.end (); p++)
     {
-      fontname = select_font ((*p).get_name (), 
+      fontname = select_font ((*p).get_name (),
                               (*p).get_weight () == "bold",
                               (*p).get_angle () == "italic");
       if ((*p).get_code ())
         {
-          // This is only one character represented by a uint32 (utf8) code. 
-          // We replace it by the corresponding character in the 
+          // This is only one character represented by a uint32 (utf8) code.
+          // We replace it by the corresponding character in the
           // "Symbol" font except for svg which has built-in utf8 support.
           if (term.find ("svg") == std::string::npos)
             {
               fontname = "Symbol";
               str = code_to_symbol ((*p).get_code ());
             }
           else
             {
@@ -515,33 +515,33 @@ glps_renderer::render_text (const std::s
           str = (*p).get_string ();
           // Escape parenthesis until gl2ps does it (see bug ##45301).
           if (term.find ("svg") == std::string::npos)
             {
               escape_character ("(", str);
               escape_character (")", str);
             }
         }
- 
+
       set_color ((*p).get_color ());
       glRasterPos3d ((*p).get_x (), (*p).get_y (), (*p).get_z ());
       gl2psTextOpt (str.c_str (), fontname.c_str (), (*p).get_size (),
                     GL2PS_TEXT_BL, rotation);
     }
-  
+
   fontname = saved_font;
   return bbox;
 }
 
 void
 glps_renderer::set_font (const base_properties& props)
 {
   opengl_renderer::set_font (props);
 
-  // Set the interpreter so that text_to_pixels can parse strings properly 
+  // Set the interpreter so that text_to_pixels can parse strings properly
   if (props.has_property ("interpreter"))
     set_interpreter (props.get ("interpreter").string_value ());
 
   fontsize = props.get ("fontsize_points").double_value ();
 
   caseless_str fn = props.get ("fontname").xtolower ().string_value ();
   bool isbold =
     (props.get ("fontweight").xtolower ().string_value () == "bold");
@@ -580,18 +580,18 @@ glps_renderer::draw_pixels (GLsizei w, G
 
 void
 glps_renderer::draw_text (const text::properties& props)
 {
   if (props.get_string ().is_empty ())
     return;
 
   // First set font properties: freetype will use them to compute
-  // coordinates and gl2ps will retrieve the color directly from the 
-  // feedback buffer 
+  // coordinates and gl2ps will retrieve the color directly from the
+  // feedback buffer
   set_font (props);
   set_color (props.get_color_rgb ());
 
   std::string saved_font = fontname;
 
   // Alignment
   int halign = 0;
   int valign = 0;
diff --git a/libinterp/corefcn/gl2ps-renderer.h b/libinterp/corefcn/gl2ps-renderer.h
--- a/libinterp/corefcn/gl2ps-renderer.h
+++ b/libinterp/corefcn/gl2ps-renderer.h
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include <gl2ps.h>
 
 class
 OCTINTERP_API
 glps_renderer : public opengl_renderer
 {
 public:
   glps_renderer (FILE *_fp, const std::string& _term)
-    : opengl_renderer () , fp (_fp), term (_term), fontsize (), 
+    : opengl_renderer () , fp (_fp), term (_term), fontsize (),
     fontname () { }
 
   ~glps_renderer (void) { }
 
   void draw (const graphics_object& go, const std::string& print_cmd);
 
 protected:
 
@@ -98,20 +98,20 @@ protected:
   }
 
   void set_linewidth (float w)
   {
     gl2psLineWidth (w);
   }
 
 private:
-  // Use xform to compute the coordinates of the ft_string list 
+  // Use xform to compute the coordinates of the ft_string list
   // that have been parsed by freetype
-  void fix_strlist_position (double x, double y, double z, 
-                             Matrix box, double rotation, 
+  void fix_strlist_position (double x, double y, double z,
+                             Matrix box, double rotation,
                              std::list<ft_render::ft_string>& lst);
 
 private:
   int alignment_to_mode (int ha, int va) const;
   FILE *fp;
   caseless_str term;
   double fontsize;
   std::string fontname;
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -6923,17 +6923,17 @@ axes::properties::calc_ticklabels (const
         {
           if (values(i) < 0.0)
             exponent = gnulib::floor (std::log10 (-values(i)));
           else
             exponent = gnulib::floor (std::log10 (values(i)));
           significand = values(i) * std::pow (10., -exponent);
 
           os.str (std::string ());
-          if ((std::abs (significand) - 1) > 
+          if ((std::abs (significand) - 1) >
               std::numeric_limits<double>::epsilon())
             os << significand << ".";
           else if (significand < 0)
             os << "-";
 
           os << "10^{";
 
           if (exponent < 0.0)
@@ -6977,17 +6977,17 @@ axes::properties::get_ticklabel_extents 
     {
       double val = ticks(i);
       if (limits(0) <= val && val <= limits(1))
         {
           std::string label (ticklabels(i));
           label.erase (0, label.find_first_not_of (" "));
           label = label.substr (0, label.find_last_not_of (" ")+1);
 #ifdef HAVE_FREETYPE
-          ext = text_renderer.get_extent (label, 0.0, 
+          ext = text_renderer.get_extent (label, 0.0,
                                           get_ticklabelinterpreter ());
           wmax = std::max (wmax, ext(0));
           hmax = std::max (hmax, ext(1));
 #else
           // FIXME: find a better approximation
           int len = label.length ();
           wmax = std::max (wmax, 0.5*fontsize*len);
           hmax = fontsize;
diff --git a/libinterp/corefcn/jit-typeinfo.cc b/libinterp/corefcn/jit-typeinfo.cc
--- a/libinterp/corefcn/jit-typeinfo.cc
+++ b/libinterp/corefcn/jit-typeinfo.cc
@@ -216,17 +216,17 @@ extern "C" void
 octave_jit_gripe_nan_to_logical_conversion (void)
 {
   gripe_nan_to_logical_conversion ();
 }
 
 extern "C" void
 octave_jit_ginvalid_index (void)
 {
-  // FIXME: 0-argument form of gripe_invalid_index removed in cset dd6345fd8a97 
+  // FIXME: 0-argument form of gripe_invalid_index removed in cset dd6345fd8a97
   //        Report -1 as the bad index for all occurrences.
   gripe_invalid_index (-1);
 }
 
 extern "C" void
 octave_jit_gindex_range (int nd, int dim, octave_idx_type iext,
                          octave_idx_type ext)
 {
diff --git a/libinterp/corefcn/sub2ind.cc b/libinterp/corefcn/sub2ind.cc
--- a/libinterp/corefcn/sub2ind.cc
+++ b/libinterp/corefcn/sub2ind.cc
@@ -196,17 +196,17 @@ moving from one column to next, filling 
       dim_vector dv = get_dim_vector (args(0), "ind2sub");
 
       try
         {
           idx_vector idx = args(1).index_vector ();
 
           if (nargout > dv.length ())
             dv = dv.redim (nargout);
-          
+
           retval = Array<octave_value> (ind2sub (dv, idx));
         }
       catch (const index_exception& e)
         {
           std::string idx = e.idx ();
           std::string msg = e.details ();
           error ("ind2sub: Invalid index %s. %s", idx.c_str (), msg.c_str ());
         }
diff --git a/libinterp/corefcn/txt-eng-ft.cc b/libinterp/corefcn/txt-eng-ft.cc
--- a/libinterp/corefcn/txt-eng-ft.cc
+++ b/libinterp/corefcn/txt-eng-ft.cc
@@ -637,33 +637,33 @@ ft_render::visit (text_element_string& e
       std::string str = e.string_value ();
       size_t n = str.length ();
       size_t curr = 0;
       size_t idx = 0;
       mbstate_t ps;
       memset (&ps, 0, sizeof (ps));  // Initialize state to 0.
       wchar_t wc;
 
-      ft_string fs (str, font.get_angle (), font.get_weight (), 
+      ft_string fs (str, font.get_angle (), font.get_weight (),
                     font.get_name (), font.get_size (), xoffset, yoffset);
 
       while (n > 0)
         {
           size_t r = gnulib::mbrtowc (&wc, str.data () + curr, n, &ps);
 
           if (r > 0
               && r != static_cast<size_t> (-1)
               && r != static_cast<size_t> (-2))
             {
               n -= r;
               curr += r;
 
               if (wc == L'\n')
                 {
-                  // Finish previous string in srtlist before processing 
+                  // Finish previous string in srtlist before processing
                   // the newline character
                   fs.set_y (line_yoffset + yoffset);
                   fs.set_color (color);
                   std::string s = str.substr (idx, curr - idx - 1);
                   if (! s.empty ())
                     {
                       fs.set_string (s);
                       strlist.push_back (fs);
@@ -672,20 +672,20 @@ ft_render::visit (text_element_string& e
 
               glyph_index = process_character (wc, previous);
 
               if (wc == L'\n')
                 {
                   previous = 0;
                   // Start a new string in strlist
                   idx = curr;
-                  fs = ft_string (str.substr (idx), font.get_angle (), 
-                                  font.get_weight (), font.get_name (), 
+                  fs = ft_string (str.substr (idx), font.get_angle (),
+                                  font.get_weight (), font.get_name (),
                                   font.get_size (), line_xoffset, yoffset);
-                  
+
                 }
               else
                 previous = glyph_index;
             }
           else
             {
               if (r != 0)
                 ::warning ("ft_render: failed to decode string `%s' with "
@@ -832,18 +832,18 @@ ft_render::visit (text_element_fontstyle
   if (mode == MODE_BBOX)
     update_line_bbox ();
 }
 
 void
 ft_render::visit (text_element_symbol& e)
 {
   uint32_t code = e.get_symbol_code ();
- 
-  ft_string fs (std::string ("-"), font.get_angle (), font.get_weight (), 
+
+  ft_string fs (std::string ("-"), font.get_angle (), font.get_weight (),
                 font.get_name (), font.get_size (), xoffset, yoffset);
 
   if (code != text_element_symbol::invalid_code && font.is_valid ())
     {
       process_character (code);
       fs.set_code (code);
     }
   else if (font.is_valid ())
@@ -1019,17 +1019,17 @@ ft_render::rotation_to_mode (double rota
   else
     return ROTATION_0;
 }
 
 void
 ft_render::text_to_pixels (const std::string& txt,
                            uint8NDArray& pixels_, Matrix& box,
                            int _halign, int valign, double rotation,
-                           const caseless_str& interpreter, 
+                           const caseless_str& interpreter,
                            bool handle_rotation)
 {
   int rot_mode = rotation_to_mode (rotation);
 
   halign = _halign;
 
   text_element *elt = text_parser::parse (txt, interpreter);
   pixels_ = render (elt, box, rot_mode);
diff --git a/libinterp/corefcn/txt-eng-ft.h b/libinterp/corefcn/txt-eng-ft.h
--- a/libinterp/corefcn/txt-eng-ft.h
+++ b/libinterp/corefcn/txt-eng-ft.h
@@ -50,17 +50,17 @@ public:
   {
     ROTATION_0   = 0,
     ROTATION_90  = 1,
     ROTATION_180 = 2,
     ROTATION_270 = 3
   };
 
 public:
-  
+
   ft_render (void);
 
   ~ft_render (void);
 
   void visit (text_element_string& e);
 
   void visit (text_element_list& e);
 
@@ -163,27 +163,27 @@ private:
 
   void compute_bbox (void);
 
   int compute_line_xoffset (const Matrix& lb) const;
 
   FT_UInt process_character (FT_ULong code, FT_UInt previous = 0);
 
 public:
-  // A class to store informations on substrings after parsing. 
+  // A class to store informations on substrings after parsing.
   class ft_string : public ft_font
   {
   public:
     ft_string (const std::string s, const std::string fontang,
               const std::string fontwgt, const std::string nm,
               const double fontsz, const double x0, const double y0)
       : ft_font (nm, fontwgt, fontang, fontsz),
         string(s), x(x0), y(y0), z(0.0), code(0),
         color(Matrix (1,3,0.0)){ }
-  
+
     void set_string (const std::string str) { string = str; }
 
     std::string get_string (void) const { return string; }
 
     void set_x (const double x0) { x = x0; }
 
     double get_x (void) const { return x; }
 
@@ -194,41 +194,41 @@ public:
     void set_z (const double z0) { z = z0; }
 
     double get_z (void) const { return z; }
 
     void set_code (const uint32_t c) { code = c; }
 
     uint32_t get_code (void) const { return code; }
 
-    void set_color (const uint8NDArray c) 
-    { 
-      color(0) = static_cast<double> (c(0)) / 255; 
+    void set_color (const uint8NDArray c)
+    {
+      color(0) = static_cast<double> (c(0)) / 255;
       color(1) = static_cast<double> (c(1)) / 255;
       color(2) = static_cast<double> (c(2)) / 255;
     }
 
     Matrix get_color (void) const { return color; }
-  
+
   private:
     std::string  string;
     double x, y, z;
     uint32_t code;
     Matrix color;
   };
 
  void text_to_strlist (const std::string& txt,
                         std::list<ft_string>& lst, Matrix& box,
                         int ha, int va, double rot,
-                        const caseless_str& interp = "tex")  
+                        const caseless_str& interp = "tex")
   {
     uint8NDArray pixels_;
-    // First run text_to_pixels which will also build the string list 
+    // First run text_to_pixels which will also build the string list
     text_to_pixels (txt, pixels_, box, ha, va, rot, interp, false);
-    
+
     lst = strlist;
   }
 
 private:
   // The current font used by the renderer.
   ft_font font;
 
   // Used to stored the bounding box corresponding to the rendered text.
diff --git a/libinterp/octave-value/ov-base-diag.h b/libinterp/octave-value/ov-base-diag.h
--- a/libinterp/octave-value/ov-base-diag.h
+++ b/libinterp/octave-value/ov-base-diag.h
@@ -81,17 +81,17 @@ public:
   dim_vector dims (void) const { return matrix.dims (); }
 
   octave_idx_type nnz (void) const { return to_dense ().nnz (); }
 
   octave_value reshape (const dim_vector& new_dims) const
   { return to_dense ().reshape (new_dims); }
 
   octave_value permute (const Array<int>& vec, bool inv = false) const
-  { 
+  {
     if (vec.numel () == 2
         && ((vec.xelem (0) == 1 && vec.xelem (1) == 0)
             || (vec.xelem (0) == 0 && vec.xelem (1) == 1)))
       return DMT (matrix);
     else
       return to_dense ().permute (vec, inv);
   }
 
diff --git a/libinterp/octave-value/ov-base-mat.cc b/libinterp/octave-value/ov-base-mat.cc
--- a/libinterp/octave-value/ov-base-mat.cc
+++ b/libinterp/octave-value/ov-base-mat.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 
 #include "Cell.h"
 #include "oct-obj.h"
 #include "oct-map.h"
 #include "ov-base.h"
 #include "ov-base-mat.h"
 #include "ov-base-scalar.h"
 #include "pr-output.h"
- 
+
 template <class MT>
 octave_value
 octave_base_matrix<MT>::subsref (const std::string& type,
                                  const std::list<octave_value_list>& idx)
 {
   octave_value retval;
 
   switch (type[0])
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -854,17 +854,17 @@ tree_evaluator::visit_try_catch_command 
   tree_statement_list *catch_code = cmd.cleanup ();
 
   // The catch code is *not* added to unwind_protect stack; it doesn't need
   // to be run on interrupts.
 
   tree_statement_list *try_code = cmd.body ();
 
   bool execution_error = false;
-  
+
   if (try_code)
     {
       try
         {
           try_code->accept (*this);
         }
       catch (const octave_execution_exception&)
         {
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -1126,17 +1126,17 @@ ComplexMatrix::finverse (MatrixType &mat
       lwork = (lwork <  2 *nc ? 2*nc : lwork);
       z.resize (dim_vector (lwork, 1));
       Complex *pz = z.fortran_vec ();
 
       info = 0;
 
       // Calculate the norm of the matrix, for later use.
       double anorm;
-      //if (calc_cond)   // Must always calculate anorm for bug #45577 
+      //if (calc_cond)   // Must always calculate anorm for bug #45577
       anorm = retval.abs ().sum ().row (static_cast<octave_idx_type>(0)).max ();
 
       // Work around bug #45577, LAPACK crashes Octave if norm is NaN
       if (xisnan (anorm))
         info = -1;
       else
         F77_XFCN (zgetrf, ZGETRF, (nc, nc, tmp_data, nr, pipvt, info));
 
@@ -1696,17 +1696,17 @@ ComplexMatrix::determinant (MatrixType& 
 
           ComplexMatrix atmp = *this;
           Complex *tmp_data = atmp.fortran_vec ();
 
           info = 0;
 
           // Calculate the norm of the matrix, for later use.
           double anorm = 0;
-          //if (calc_cond)   // Must always calculate anorm for bug #45577 
+          //if (calc_cond)   // Must always calculate anorm for bug #45577
           anorm = xnorm (*this, 1);
 
           // Work around bug #45577, LAPACK crashes Octave if norm is NaN
           if (xisnan (anorm))
             info = -1;
           else
             F77_XFCN (zgetrf, ZGETRF, (nr, nr, tmp_data, nr, pipvt, info));
 
diff --git a/m4/acinclude.m4 b/m4/acinclude.m4
--- a/m4/acinclude.m4
+++ b/m4/acinclude.m4
@@ -1054,17 +1054,17 @@ AC_DEFUN([OCTAVE_CHECK_LIB_QHULL_OK], [
   if test $octave_cv_lib_qhull_ok = yes; then
     $1
     :
   else
     $2
     :
   fi
 ])
-dnl 
+dnl
 dnl Check whether sndfile library is modern enough to include things like Ogg
 dnl
 AC_DEFUN([OCTAVE_CHECK_LIB_SNDFILE_OK], [
   AC_CACHE_CHECK([whether sndfile library is modern enough],
     [octave_cv_lib_sndfile_ok],
     [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[
         #include <sndfile.h>
         ]], [[
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -130,17 +130,17 @@ function [q, err] = quadgk (f, a, b, var
   endif
 
   if (b < a)
     ## Reverse integration
     [q, err] = quadgk (f, b, a, varargin{:});
     q = -q;
     return;
   endif
-  
+
   abstol = [];
   reltol = [];
   waypoints = [];
   maxint = 650;
   trace = false;
 
   ## Parse options if present.
   if (nargin > 3)
@@ -186,23 +186,23 @@ function [q, err] = quadgk (f, a, b, var
       endwhile
     endif
   endif
 
   issingle = (isa (a, "single") || isa (b, "single")
               || isa (waypoints, "single"));
 
   if (isempty (abstol))
-    abstol = ifelse (issingle, 1e-5, 1e-10);  
+    abstol = ifelse (issingle, 1e-5, 1e-10);
   elseif (! isscalar (abstol) || abstol < 0)
     error ("quadv: ABSTOL must be a scalar >=0");
   endif
 
   if (isempty (reltol))
-    reltol = ifelse (issingle, 1e-4, 1e-6);  
+    reltol = ifelse (issingle, 1e-4, 1e-6);
   elseif (! isscalar (reltol) || reltol < 0)
     error ("quadv: RELTOL must be a scalar >=0");
   endif
 
   ## Convert function given as a string to a function handle
   if (ischar (f))
     f = @(x) feval (f, x);
   endif
diff --git a/scripts/gui/uicontextmenu.m b/scripts/gui/uicontextmenu.m
--- a/scripts/gui/uicontextmenu.m
+++ b/scripts/gui/uicontextmenu.m
@@ -18,21 +18,21 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{hui} =} uicontextmenu (@var{property}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {@var{hui} =} uicontextmenu (@var{h}, @var{property}, @var{value}, @dots{})
 ##
 ## Create a uicontextmenu object and return a handle to it.
 ##
 ## If @var{h} is omitted then a uicontextmenu for the current figure is
-## created. If no figure is available, a new figure is created first. 
+## created. If no figure is available, a new figure is created first.
 ##
-## If @var{h} is given then a uicontextmenu relative to @var{h} is created. 
-## 
-## Any provided property value pairs will override the default values of the created 
+## If @var{h} is given then a uicontextmenu relative to @var{h} is created.
+##
+## Any provided property value pairs will override the default values of the created
 ## uicontextmenu object.
 ##
 ## Uicontextmenu propertes are documented at @ref{Uicontextmenu Properties}.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
diff --git a/scripts/gui/uicontrol.m b/scripts/gui/uicontrol.m
--- a/scripts/gui/uicontrol.m
+++ b/scripts/gui/uicontrol.m
@@ -21,61 +21,61 @@
 ## @deftypefnx {Function File} {@var{hui} =} uicontrol (@var{parent}, @var{property}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {} uicontrol (@var{h})
 ##
 ## Create a uicontrol object and return a handle to it.
 ##
 ## uicontrols are used to create simple interactive controls such as push buttons, checkboxes, edit and list controls.
 ##
 ## If @var{parent} is omitted then a uicontrol for the current figure is
-## created. If no figure is available, a new figure is created first. 
+## created. If no figure is available, a new figure is created first.
 ##
-## If @var{parent} is given then a uicontrol relative to @var{parent} is created. 
-## 
-## Any provided property value pairs will override the default values of the created 
-## uicontrol object. 
+## If @var{parent} is given then a uicontrol relative to @var{parent} is created.
+##
+## Any provided property value pairs will override the default values of the created
+## uicontrol object.
 ##
 ## Uicontrol propertes are documented at @ref{Uicontrol Properties}.
 ##
 ## Control of the type of uicontrol created is through the use of the @var{style} property.
 ## If no style property is provided, a push button will be created.
 ##
 ## Valid styles for uicontrol are:
 ##
 ## @table @asis
 ## @item @qcode{"checkbox"}
 ## Create a checkbox control that allows user on/off selection.
 ##
 ## @item @qcode{"edit"}
 ## Create a edit control that allows user input of single or multiple lines of text.
 ##
 ## @item @qcode{"listbox"}
-## Create a listbox control that displays a lit of items and allows user slelection of 
+## Create a listbox control that displays a lit of items and allows user slelection of
 ## single or multiple items.
 ##
 ## @item @qcode{"popupmenu"}
-## Create a popupmenu control that displays a list of options that can be selected 
+## Create a popupmenu control that displays a list of options that can be selected
 ## when the user clicks on the control.
 ##
 ## @item @qcode{"pushbutton"}
 ## Create a push button control that allows user to press to cause an action.
 ##
 ## @item @qcode{"radiobutton"}
 ## Create a radio button control intended to be used for mutually exclusive input in a group of
 ## of radiobutton controls.
 ##
 ## @item @qcode{"slider"}
-## Create a slider control that allows user selection from a range of values by sliding 
+## Create a slider control that allows user selection from a range of values by sliding
 ## knob on the control.
 ##
 ## @item @qcode{"text"}
 ## Create a static text control to display single or multiple lines of text.
 ##
 ## @item @qcode{"togglebutton"}
-## Create a toggle button control that appears like a push button but allows the user to 
+## Create a toggle button control that appears like a push button but allows the user to
 ## select between two states.
 ##
 ## @end table
 ##
 ## Examples:
 ##
 ## @example
 ## @group
diff --git a/scripts/gui/uipanel.m b/scripts/gui/uipanel.m
--- a/scripts/gui/uipanel.m
+++ b/scripts/gui/uipanel.m
@@ -20,21 +20,21 @@
 ## @deftypefn  {Function File} {@var{hui} =} uipanel (@var{property}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {@var{hui} =} uipanel (@var{parent}, "@var{property}, @var{value}, @dots{})
 ##
 ## Create a uipanel object and return a handle to it.
 ##
 ## uipanels are used as containers to group other uicontrol objects.
 ##
 ## If @var{parent} is omitted then a uipanel for the current figure is
-## created. If no figure is available, a new figure is created first. 
+## created. If no figure is available, a new figure is created first.
 ##
-## If @var{parent} is given then a uipanel relative to @var{parent} is created. 
-## 
-## Any provided property value pairs will override the default values of the created 
+## If @var{parent} is given then a uipanel relative to @var{parent} is created.
+##
+## Any provided property value pairs will override the default values of the created
 ## uipanel object.
 ##
 ## Uipanel propertes are documented at @ref{Uipanel Properties}.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
diff --git a/scripts/gui/uipushtool.m b/scripts/gui/uipushtool.m
--- a/scripts/gui/uipushtool.m
+++ b/scripts/gui/uipushtool.m
@@ -24,19 +24,19 @@
 ##
 ## uipushtools are buttons that appear on a figure toolbar. The button is created with a border that
 ## is shown when the user hovers over the button. An image can be set using the cdata property.
 ##
 ## If @var{parent} is omitted then a uipushtool for the current figure is
 ## created. If no figure is available, a new figure is created first.  If a figure is
 ## available, but does not contain a uitoolbar, a uitoolbar will be created.
 ##
-## If @var{parent} is given then a uipushtools is created on the @var{parent} uitoolbar. 
-## 
-## Any provided property value pairs will override the default values of the created 
+## If @var{parent} is given then a uipushtools is created on the @var{parent} uitoolbar.
+##
+## Any provided property value pairs will override the default values of the created
 ## uipushtool object.
 ##
 ## Uipushtool propertes are documented at @ref{Uipushtool Properties}.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
diff --git a/scripts/gui/uitoggletool.m b/scripts/gui/uitoggletool.m
--- a/scripts/gui/uitoggletool.m
+++ b/scripts/gui/uitoggletool.m
@@ -24,19 +24,19 @@
 ##
 ## uitoggletool are togglebuttons that appear on a figure toolbar. The button is created with a border that
 ## is shown when the user hovers over the button. An image can be set using the cdata property.
 ##
 ## If @var{parent} is omitted then a uitoggletool for the current figure is
 ## created. If no figure is available, a new figure is created first.  If a figure is
 ## available, but does not contain a uitoolbar, a uitoolbar will be created.
 ##
-## If @var{parent} is given then a uitoggletool is created on the @var{parent} uitoolbar. 
-## 
-## Any provided property value pairs will override the default values of the created 
+## If @var{parent} is given then a uitoggletool is created on the @var{parent} uitoolbar.
+##
+## Any provided property value pairs will override the default values of the created
 ## uitoggletool object.
 ##
 ## Uitoggletool propertes are documented at @ref{Uitoggletool Properties}.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
diff --git a/scripts/gui/uitoolbar.m b/scripts/gui/uitoolbar.m
--- a/scripts/gui/uitoolbar.m
+++ b/scripts/gui/uitoolbar.m
@@ -18,30 +18,30 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{hui} =} uitoolbar (@var{property}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {@var{hui} =} uitoolbar (@var{parent}, @var{property}, @var{value}, @dots{})
 ##
 ## Create a uitoolbar object and return a handle to it. A uitoolbar displays uitoggletool and uipushtool buttons.
 ##
 ## If @var{parent} is omitted then a uitoolbar for the current figure is
-## created. If no figure is available, a new figure is created first. 
+## created. If no figure is available, a new figure is created first.
 ##
-## If @var{parent} is given then a uitoolbar relative to @var{parent} is created. 
-## 
-## Any provided property value pairs will override the default values of the created 
-## uitoolbar object. 
+## If @var{parent} is given then a uitoolbar relative to @var{parent} is created.
+##
+## Any provided property value pairs will override the default values of the created
+## uitoolbar object.
 ##
 ## Uitoolbar propertes are documented at @ref{Uitoolbar Properties}.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
-## % create figure without a default toolbar 
+## % create figure without a default toolbar
 ## f = figure ("toolbar", "none");
 ## % create empty toolbar
 ## t = uitoolbar (f);
 ## @end group
 ## @end example
 ## @seealso{figure, uitoggletool, uipushtool}
 ## @end deftypefn
 
diff --git a/scripts/gui/waitbar.m b/scripts/gui/waitbar.m
--- a/scripts/gui/waitbar.m
+++ b/scripts/gui/waitbar.m
@@ -30,17 +30,17 @@
 ## [0, 1].
 ##
 ## The optional message @var{msg} is centered and displayed above the waitbar.
 ##
 ## A cancel button can be added to the bottom of the waitbar using the
 ## "createcancelbtn" property of waitbar figures. The action to be
 ## executed when the user presses the button is specified using a string or
 ## function handle @var{fcn}.
-## 
+##
 ## The appearance of the waitbar figure window can be configured by passing
 ## @var{prop}/@var{val} pairs to the function.
 ##
 ## When called with a single input the current waitbar, if it exists, is
 ## updated to the new value @var{frac}.  If there are multiple outstanding
 ## waitbars they can be updated individually by passing the handle @var{hwbar}
 ## of the specific waitbar to modify.
 ## @end deftypefn
@@ -117,30 +117,30 @@ function h = waitbar (varargin)
 
     hf = figure ("units", "pixels",
                  "position", [250, 500, 400, 100],
                  "numbertitle", "off",
                  "menubar", "none", "toolbar", "none",
                  "integerhandle", "off",
                  "handlevisibility", "callback",
                  "tag", "waitbar");
-    
+
     ax = axes ("parent", hf,
                "xtick", [], "ytick", [],
                "xlim", [0, 1], "ylim", [0, 1],
                "position", [0.1, 0.3, 0.8, 0.2]);
 
     ## Add createcancelbtn property
     addproperty ("createcancelbtn", hf, "figurebuttondownfcn");
     addlistener (hf, "createcancelbtn", {@updatecancelbutton, ax});
 
     if (! isempty (varargin))
       set (hf, varargin{:});
     endif
-    
+
     hp = patch (ax, [0; frac; frac; 0], [0; 0; 1; 1], [0, 0.35, 0.75]);
 
     ## Cache the axes and patch handles.
     set (hf, "__guidata__", [ax hp]);
 
     if (! (ischar (msg) || iscellstr (msg)))
       msg = "Please wait...";
     endif
@@ -168,36 +168,36 @@ function updatecancelbutton (hf, dummy, 
   hbtn = findobj (hf, "type", "uicontrol", "-and", "style", "pushbutton");
   cb = get (hf, "createcancelbtn");
   if (! isempty (cb))
     if (isempty (hbtn))
       units =  get (hax, "units");
       fpos = get (hf, "position");
       set (hax, "units", "pixels");
       apos = get (hax, "position");
-      
+
       fpos (2) -= 40;
       fpos (4) += 40;
       apos (2) += 40;
       set (hf, "position", fpos);
       set (hax, "position", apos, "units", units);
-      
+
       hbtn = uicontrol ("style", "pushbutton", "string", "Cancel", ...
                         "position", [fpos(3)-100 10 60 25],...
                         "callback", cb, "parent", hf);
     else
       set (hbtn, "callback", cb)
     endif
   elseif (! isempty (hbtn))
     delete (hbtn);
     units =  get (hax, "units");
     fpos = get (hf, "position");
     set (hax, "units", "pixels");
     apos = get (hax, "position");
-    
+
     fpos (2) += 40;
     fpos (4) -= 40;
     apos (2) -= 40;
     set (hf, "position", fpos);
     set (hax, "position", apos, "units", units);
   endif
 endfunction
 
@@ -241,58 +241,58 @@ endfunction
 %!   waitbar (i/4, h1);
 %!   pause (0.5);
 %!   waitbar (i/4, h2);
 %!   pause (0.5);
 %! end
 %! pause (0.5);
 %! close (h1);
 %! close (h2);
- 
+
 %!demo
 %! clf ();
 %! niter = 9;
 %! l = 1;
 %! xx = [0 l];
 %! yy = [0 0];
 %! hli = plot (xx, yy);
-%! 
+%!
 %! disp ("Push the cancel to stop the process.")
 %! hf = waitbar(0,"0","Name","Building Koch curve ...",...
 %!              "createcancelbtn", "setappdata (gcbf,'interrupt', true)");
 %! for ii = 1:niter
 %!   ## Check cancel request
 %!   if (! ishandle (hf))
 %!     break
 %!   elseif (getappdata (hf, "interrupt"))
 %!     delete (hf)
 %!     break
 %!   else
 %!     waitbar (ii/niter, hf, sprintf ("Step %d/%d", ii, niter));
 %!   endif
-%! 
+%!
 %!   ## Increasingly lengthy computation
 %!   l /= 3;
 %!   theta = angle (complex (diff (xx), diff (yy)));
-%!   
+%!
 %!   xy = @(th, x0, y0) [cos(th) -sin(th) x0
-%!                       sin(th) cos(th) y0] * [0 l l*3/2      2*l; 
+%!                       sin(th) cos(th) y0] * [0 l l*3/2      2*l;
 %!                                              0 0 l*(3)^.5/2 0;
 %!                                              1 1 1          1];
 %!   tmp = arrayfun (xy, theta, xx(1:end-1), yy(1:end-1),
 %!                  "uniformoutput", false);
-%! 
+%!
 %!   tmp = cell2mat (tmp);
 %!   xx = [tmp(1,:) xx(end)];
 %!   yy = [tmp(2,:) yy(end)];
 %!   set (hli, "xdata", xx, "ydata", yy)
 %!   drawnow ();
 %!   pause (0.5)
 %! endfor
-%! 
+%!
 %! if (ishandle (hf))
 %!   delete (hf)
 %! endif
 
 ## Test input validation
 %!error <FRAC must be between 0 and 1> waitbar (-0.5)
 %!error <FRAC must be between 0 and 1> waitbar (1.5)
 %!error <MSG must be a character string> waitbar (0.5, struct ())
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -135,17 +135,17 @@ function h = imshow (im, varargin)
             error ("imshow: invalid colormap");
           endif
         case "displayrange"
           display_range = varargin{narg++};
         case {"initialmagnification"}
           warning ("imshow: zoom argument ignored -- use GUI features");
           narg++;
         case "parent"
-          prop_val_args(end+(1:2)) = {"parent", varargin{narg++}}; 
+          prop_val_args(end+(1:2)) = {"parent", varargin{narg++}};
           if (! isaxes (prop_val_args{end}))
             error ("imshow: parent must be an axes handle");
           endif
         case "reduce"
           warning ("imshow: reduce argument is not implemented");
           narg++;
         case "xdata"
           xdata = varargin{narg++};
diff --git a/scripts/image/viridis.m b/scripts/image/viridis.m
--- a/scripts/image/viridis.m
+++ b/scripts/image/viridis.m
@@ -18,34 +18,34 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} viridis ()
 ## @deftypefnx {Function File} {@var{map} =} viridis (@var{n})
 ## Create color colormap.  The colors begin with dark purplish-blue and
-## blue, range through green and end with yellow. 
+## blue, range through green and end with yellow.
 ##
 ## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author: Carlo de Falco
 
 ## PKG_ADD: colormap ("register", "viridis");
 ## PKG_DEL: colormap ("unregister", "viridis");
 
 ## This is a port of the the default matplotlib colormap "viridis"
 ## by Eric Firing to Octave, the original file is distributed under CC0:
 ## http://creativecommons.org/publicdomain/zero/1.0
 
 function c = viridis (n = rows (colormap ()))
-  
+
   if (nargin > 1)
     print_usage ();
   elseif (! isscalar (n))
     error ("viridis: N must be a scalar");
   endif
 
   viridi = [0.26700401  0.00487433  0.32941519
             0.26851048  0.00960483  0.33542652
@@ -64,17 +64,17 @@ function c = viridis (n = rows (colormap
             0.28144581  0.0843197   0.40741404
             0.28192358  0.08966622  0.41241521
             0.28232739  0.09495545  0.41733086
             0.28265633  0.10019576  0.42216032
             0.28291049  0.10539345  0.42690202
             0.28309095  0.11055307  0.43155375
             0.28319704  0.11567966  0.43611482
             0.28322882  0.12077701  0.44058404
-            0.28318684  0.12584799  0.44496   
+            0.28318684  0.12584799  0.44496
             0.283072    0.13089477  0.44924127
             0.28288389  0.13592005  0.45342734
             0.28262297  0.14092556  0.45751726
             0.28229037  0.14591233  0.46150995
             0.28188676  0.15088147  0.46540474
             0.28141228  0.15583425  0.46920128
             0.28086773  0.16077132  0.47289909
             0.28025468  0.16569272  0.47649762
@@ -84,47 +84,47 @@ function c = viridis (n = rows (colormap
             0.27713437  0.18522836  0.48989831
             0.27619376  0.19007447  0.49300074
             0.27519116  0.1949054   0.49600488
             0.27412802  0.19972086  0.49891131
             0.27300596  0.20452049  0.50172076
             0.27182812  0.20930306  0.50443413
             0.27059473  0.21406899  0.50705243
             0.26930756  0.21881782  0.50957678
-            0.26796846  0.22354911  0.5120084 
-            0.26657984  0.2282621   0.5143487 
-            0.2651445   0.23295593  0.5165993 
+            0.26796846  0.22354911  0.5120084
+            0.26657984  0.2282621   0.5143487
+            0.2651445   0.23295593  0.5165993
             0.2636632   0.23763078  0.51876163
             0.26213801  0.24228619  0.52083736
             0.26057103  0.2469217   0.52282822
             0.25896451  0.25153685  0.52473609
             0.25732244  0.2561304   0.52656332
             0.25564519  0.26070284  0.52831152
             0.25393498  0.26525384  0.52998273
             0.25219404  0.26978306  0.53157905
             0.25042462  0.27429024  0.53310261
             0.24862899  0.27877509  0.53455561
             0.2468114   0.28323662  0.53594093
             0.24497208  0.28767547  0.53726018
             0.24311324  0.29209154  0.53851561
             0.24123708  0.29648471  0.53970946
             0.23934575  0.30085494  0.54084398
-            0.23744138  0.30520222  0.5419214 
+            0.23744138  0.30520222  0.5419214
             0.23552606  0.30952657  0.54294396
             0.23360277  0.31382773  0.54391424
             0.2316735   0.3181058   0.54483444
             0.22973926  0.32236127  0.54570633
-            0.22780192  0.32659432  0.546532  
+            0.22780192  0.32659432  0.546532
             0.2258633   0.33080515  0.54731353
             0.22392515  0.334994    0.54805291
             0.22198915  0.33916114  0.54875211
             0.22005691  0.34330688  0.54941304
             0.21812995  0.34743154  0.55003755
             0.21620971  0.35153548  0.55062743
-            0.21429757  0.35561907  0.5511844 
+            0.21429757  0.35561907  0.5511844
             0.21239477  0.35968273  0.55171011
             0.2105031   0.36372671  0.55220646
             0.20862342  0.36775151  0.55267486
             0.20675628  0.37175775  0.55311653
             0.20490257  0.37574589  0.55353282
             0.20306309  0.37971644  0.55392505
             0.20123854  0.38366989  0.55429441
             0.1994295   0.38760678  0.55464205
@@ -132,58 +132,58 @@ function c = viridis (n = rows (colormap
             0.19585993  0.39543297  0.55527637
             0.19410009  0.39932336  0.55556494
             0.19235719  0.40319934  0.55583559
             0.19063135  0.40706148  0.55608907
             0.18892259  0.41091033  0.55632606
             0.18723083  0.41474645  0.55654717
             0.18555593  0.4185704   0.55675292
             0.18389763  0.42238275  0.55694377
-            0.18225561  0.42618405  0.5571201 
+            0.18225561  0.42618405  0.5571201
             0.18062949  0.42997486  0.55728221
             0.17901879  0.43375572  0.55743035
             0.17742298  0.4375272   0.55756466
             0.17584148  0.44128981  0.55768526
             0.17427363  0.4450441   0.55779216
             0.17271876  0.4487906   0.55788532
             0.17117615  0.4525298   0.55796464
             0.16964573  0.45626209  0.55803034
             0.16812641  0.45998802  0.55808199
             0.1666171   0.46370813  0.55811913
             0.16511703  0.4674229   0.55814141
             0.16362543  0.47113278  0.55814842
             0.16214155  0.47483821  0.55813967
             0.16066467  0.47853961  0.55811466
-            0.15919413  0.4822374   0.5580728 
+            0.15919413  0.4822374   0.5580728
             0.15772933  0.48593197  0.55801347
-            0.15626973  0.4896237   0.557936  
+            0.15626973  0.4896237   0.557936
             0.15481488  0.49331293  0.55783967
             0.15336445  0.49700003  0.55772371
             0.1519182   0.50068529  0.55758733
             0.15047605  0.50436904  0.55742968
-            0.14903918  0.50805136  0.5572505 
+            0.14903918  0.50805136  0.5572505
             0.14760731  0.51173263  0.55704861
             0.14618026  0.51541316  0.55682271
             0.14475863  0.51909319  0.55657181
             0.14334327  0.52277292  0.55629491
             0.14193527  0.52645254  0.55599097
             0.14053599  0.53013219  0.55565893
             0.13914708  0.53381201  0.55529773
             0.13777048  0.53749213  0.55490625
             0.1364085   0.54117264  0.55448339
             0.13506561  0.54485335  0.55402906
             0.13374299  0.54853458  0.55354108
             0.13244401  0.55221637  0.55301828
             0.13117249  0.55589872  0.55245948
             0.1299327   0.55958162  0.55186354
             0.12872938  0.56326503  0.55122927
             0.12756771  0.56694891  0.55055551
-            0.12645338  0.57063316  0.5498411 
+            0.12645338  0.57063316  0.5498411
             0.12539383  0.57431754  0.54908564
-            0.12439474  0.57800205  0.5482874 
+            0.12439474  0.57800205  0.5482874
             0.12346281  0.58168661  0.54744498
             0.12260562  0.58537105  0.54655722
             0.12183122  0.58905521  0.54562298
             0.12114807  0.59273889  0.54464114
             0.12056501  0.59642187  0.54361058
             0.12009154  0.60010387  0.54253043
             0.11973756  0.60378459  0.54139999
             0.11951163  0.60746388  0.54021751
@@ -195,73 +195,73 @@ function c = viridis (n = rows (colormap
             0.12137972  0.62949242  0.53197275
             0.12231244  0.63315277  0.53039808
             0.12344358  0.63680899  0.52876343
             0.12477953  0.64046069  0.52706792
             0.12632581  0.64410744  0.52531069
             0.12808703  0.64774881  0.52349092
             0.13006688  0.65138436  0.52160791
             0.13226797  0.65501363  0.51966086
-            0.13469183  0.65863619  0.5176488 
+            0.13469183  0.65863619  0.5176488
             0.13733921  0.66225157  0.51557101
-            0.14020991  0.66585927  0.5134268 
+            0.14020991  0.66585927  0.5134268
             0.14330291  0.66945881  0.51121549
             0.1466164   0.67304968  0.50893644
-            0.15014782  0.67663139  0.5065889 
+            0.15014782  0.67663139  0.5065889
             0.15389405  0.68020343  0.50417217
             0.15785146  0.68376525  0.50168574
             0.16201598  0.68731632  0.49912906
             0.1663832   0.69085611  0.49650163
             0.1709484   0.69438405  0.49380294
             0.17570671  0.6978996   0.49103252
             0.18065314  0.70140222  0.48818938
             0.18578266  0.70489133  0.48527326
             0.19109018  0.70836635  0.48228395
             0.19657063  0.71182668  0.47922108
             0.20221902  0.71527175  0.47608431
-            0.20803045  0.71870095  0.4728733 
+            0.20803045  0.71870095  0.4728733
             0.21400015  0.72211371  0.46958774
             0.22012381  0.72550945  0.46622638
             0.2263969   0.72888753  0.46278934
             0.23281498  0.73224735  0.45927675
             0.2393739   0.73558828  0.45568838
             0.24606968  0.73890972  0.45202405
             0.25289851  0.74221104  0.44828355
             0.25985676  0.74549162  0.44446673
             0.26694127  0.74875084  0.44057284
-            0.27414922  0.75198807  0.4366009 
+            0.27414922  0.75198807  0.4366009
             0.28147681  0.75520266  0.43255207
             0.28892102  0.75839399  0.42842626
             0.29647899  0.76156142  0.42422341
             0.30414796  0.76470433  0.41994346
             0.31192534  0.76782207  0.41558638
             0.3198086   0.77091403  0.41115215
             0.3277958   0.77397953  0.40664011
             0.33588539  0.7770179   0.40204917
             0.34407411  0.78002855  0.39738103
             0.35235985  0.78301086  0.39263579
             0.36074053  0.78596419  0.38781353
             0.3692142   0.78888793  0.38291438
-            0.37777892  0.79178146  0.3779385 
+            0.37777892  0.79178146  0.3779385
             0.38643282  0.79464415  0.37288606
             0.39517408  0.79747541  0.36775726
             0.40400101  0.80027461  0.36255223
             0.4129135   0.80304099  0.35726893
             0.42190813  0.80577412  0.35191009
             0.43098317  0.80847343  0.34647607
-            0.44013691  0.81113836  0.3409673 
+            0.44013691  0.81113836  0.3409673
             0.44936763  0.81376835  0.33538426
             0.45867362  0.81636288  0.32972749
             0.46805314  0.81892143  0.32399761
             0.47750446  0.82144351  0.31819529
             0.4870258   0.82392862  0.31232133
             0.49661536  0.82637633  0.30637661
             0.5062713   0.82878621  0.30036211
             0.51599182  0.83115784  0.29427888
-            0.52577622  0.83349064  0.2881265 
+            0.52577622  0.83349064  0.2881265
             0.5356211   0.83578452  0.28190832
             0.5455244   0.83803918  0.27562602
             0.55548397  0.84025437  0.26928147
             0.5654976   0.8424299   0.26287683
             0.57556297  0.84456561  0.25641457
             0.58567772  0.84666139  0.24989748
             0.59583934  0.84871722  0.24332878
             0.60604528  0.8507331   0.23671214
@@ -281,25 +281,25 @@ function c = viridis (n = rows (colormap
             0.75188414  0.87495143  0.14322828
             0.76237342  0.87642392  0.13706449
             0.77285183  0.87786808  0.13110864
             0.78331535  0.87928545  0.12540538
             0.79375994  0.88067763  0.12000532
             0.80418159  0.88204632  0.11496505
             0.81457634  0.88339329  0.11034678
             0.82494028  0.88472036  0.10621724
-            0.83526959  0.88602943  0.1026459 
+            0.83526959  0.88602943  0.1026459
             0.84556056  0.88732243  0.09970219
             0.8558096   0.88860134  0.09745186
             0.86601325  0.88986815  0.09595277
             0.87616824  0.89112487  0.09525046
             0.88627146  0.89237353  0.09537439
             0.89632002  0.89361614  0.09633538
             0.90631121  0.89485467  0.09812496
-            0.91624212  0.89609127  0.1007168 
+            0.91624212  0.89609127  0.1007168
             0.92610579  0.89732977  0.10407067
             0.93590444  0.8985704   0.10813094
             0.94563626  0.899815    0.11283773
             0.95529972  0.90106534  0.11812832
             0.96489353  0.90232311  0.12394051
             0.97441665  0.90358991  0.13021494
             0.98386829  0.90486726  0.13689671
             0.99324789  0.90615657  0.1439362];
diff --git a/scripts/ode/private/ode_event_handler.m b/scripts/ode/private/ode_event_handler.m
--- a/scripts/ode/private/ode_event_handler.m
+++ b/scripts/ode/private/ode_event_handler.m
@@ -91,17 +91,17 @@ function retval = ode_event_handler (evt
     endif
     [evtold, term, dir] = feval (inpargs{:});
 
     ## FIXME: This actually seems to assume that everything must be row vectors
     ## We assume that all return values must be column vectors
     evtold = evtold(:)'; term = term(:)'; dir = dir(:)';
     told = t; yold = y; evtcnt = 1; retcell = cell (1,4);
 
-  ## Process the event, i.e., 
+  ## Process the event, i.e.,
   ## find the zero crossings for either a rising or falling edge
   elseif (isempty (flag))
 
     if (! iscell (y))
       inpargs = {evtfun, t, y};
     else
       inpargs = {evtfun, t, y{1}, y{2}};
       y = y{1};  # Delete cell element 2
diff --git a/scripts/optimization/fminunc.m b/scripts/optimization/fminunc.m
--- a/scripts/optimization/fminunc.m
+++ b/scripts/optimization/fminunc.m
@@ -337,24 +337,24 @@ function [x, fval, info, output, grad, h
         endif
       endif
 
     endwhile
   endwhile
 
   ## When info != 1, recalculate the gradient and Hessian using the final x.
   if (nargout > 4 && (info == -1 || info == 2 || info == 3))
-    grad0 = grad;  
+    grad0 = grad;
     if (has_grad)
       [fval, grad] = fcn (reshape (x, xsz));
       grad = grad(:);
     else
       grad = __fdjac__ (fcn, reshape (x, xsz), fval, typicalx, cdif)(:);
     endif
-    
+
     if (nargout > 5)
       ## Use the damped BFGS formula.
       y = grad - grad0;
       sBs = sumsq (w);
       Bs = hesr' * w;
       sy = y' * s;
       theta = 0.8 / max (1 - sy / sBs, 0.8);
       r = theta * y + (1-theta) * Bs;
diff --git a/scripts/plot/draw/fplot.m b/scripts/plot/draw/fplot.m
--- a/scripts/plot/draw/fplot.m
+++ b/scripts/plot/draw/fplot.m
@@ -65,17 +65,17 @@
 ## @code{fplot} works best with continuous functions.  Functions with
 ## discontinuities are unlikely to plot well.  This restriction may be removed
 ## in the future.
 ##
 ## @code{fplot} requires that the function accept and return a vector argument.
 ## Consider this when writing user-defined functions and use @code{.*},
 ## @code{./}, etc.  See the function @code{vectorize} for potentially
 ## converting inline or anonymous functions to vectorized versions.
-##  
+##
 ## @seealso{ezplot, plot, vectorize}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
 function [X, Y] = fplot (varargin)
 
   [hax, varargin, nargin] = __plt_get_axis_arg__ ("fplot", varargin{:});
diff --git a/scripts/plot/draw/plot.m b/scripts/plot/draw/plot.m
--- a/scripts/plot/draw/plot.m
+++ b/scripts/plot/draw/plot.m
@@ -94,18 +94,18 @@
 ## the same number of rows and columns and no attempt is made to transpose
 ## the arguments to make the number of rows match.
 ## @end itemize
 ##
 ## Multiple property-value pairs may be specified, but they must appear
 ## in pairs.  These arguments are applied to the line objects drawn by
 ## @code{plot}.  Useful properties to modify are @qcode{"linestyle"},
 ## @qcode{"linewidth"}, @qcode{"color"}, @qcode{"marker"},
-## @qcode{"markersize"}, @qcode{"markeredgecolor"}, @qcode{"markerfacecolor"}.  
-## @xref{Line Properties}.  
+## @qcode{"markersize"}, @qcode{"markeredgecolor"}, @qcode{"markerfacecolor"}.
+## @xref{Line Properties}.
 ##
 ## The @var{fmt} format argument can also be used to control the plot style.
 ## It is a string composed of four optional parts:
 ## "<linestyle><marker><color><;displayname;>".
 ## When a marker is specified, but no linestyle, only the markers are
 ## plotted.  Similarly, if a linestyle is specified, but no marker, then
 ## only lines are drawn.  If both are specified then lines and markers will
 ## be plotted.  If no @var{fmt} and no @var{property}/@var{value} pairs are
diff --git a/scripts/plot/draw/surfnorm.m b/scripts/plot/draw/surfnorm.m
--- a/scripts/plot/draw/surfnorm.m
+++ b/scripts/plot/draw/surfnorm.m
@@ -140,17 +140,17 @@ function [Nx, Ny, Nz] = surfnorm (vararg
       unwind_protect
         set (hax, "nextplot", "add");
 
         ## Normalize the normal vectors
         nmag = sqrt (nx.^2 + ny.^2 + nz.^2);
 
         ## And correct for the aspect ratio of the display
         daratio = daspect (hax);
-        damag = sqrt (sumsq (daratio)); 
+        damag = sqrt (sumsq (daratio));
 
         ## FIXME: May also want to normalize the vectors relative to the size
         ##        of the diagonal.
 
         nx ./= nmag / (daratio(1)^2 / damag);
         ny ./= nmag / (daratio(2)^2 / damag);
         nz ./= nmag / (daratio(3)^2 / damag);
 
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/base/quantile.m
--- a/scripts/statistics/base/quantile.m
+++ b/scripts/statistics/base/quantile.m
@@ -316,17 +316,17 @@ endfunction
 %! sx = [2, 3, 4];
 %! x = rand (sx);
 %! dim = 2;
 %! p = 0.5;
 %! yobs = quantile (x, p, dim);
 %! yexp = median (x, dim);
 %! assert (yobs, yexp);
 
-## Bug #45455 
+## Bug #45455
 %!assert (quantile ([1 3 2], 0.5, 1), [1 3 2])
 
 ## Test input validation
 %!error quantile ()
 %!error quantile (1, 2, 3, 4, 5)
 %!error quantile (['A'; 'B'], 10)
 %!error quantile (1:10, [true, false])
 %!error quantile (1:10, ones (2,2))
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -252,33 +252,33 @@ function [found, y, m, d, h, mi, s] = __
 
   idx = strfind (f, "FFF");
   if (! isempty (idx))
     ## Kludge to handle FFF millisecond format since strptime does not.
 
     ## Find location of FFF in ds.
     ## Might not match idx because of things like yyyy -> %y.
     [~, nc] = strptime (ds, f(1:idx-1));
-    
+
     msec = ds(nc:min (nc+2,end)); # pull 3-digit fractional seconds.
     msec_idx = find (! isdigit (msec), 1);
-    
+
     if (! isempty (msec_idx))  # non-digits in msec
       msec = msec(1:msec_idx-1);
       msec(end+1:3) = "0";     # pad msec with trailing zeros
       ds = [ds(1:(nc-1)), msec, ds((nc-1)+msec_idx:end)];  # zero pad ds
     elseif (numel (msec) < 3)  # less than three digits in msec
-      m_len = numel (msec); 
+      m_len = numel (msec);
       msec(end+1:3) = "0";     # pad msec with trailing zeros
       ds = [ds(1:(nc-1)), msec, ds(nc+m_len:end)];  # zero pad ds as well
     endif
-    
+
     ## replace FFF with digits to guarantee match in strptime.
     f(idx:idx+2) = msec;
-  
+
     if (nc > 0)
       [tm, nc] = strptime (ds, f);
       tm.usec = 1000 * str2double (msec);
     endif
 
   else
     [tm, nc] = strptime (ds, f);
   endif
