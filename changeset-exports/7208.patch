# HG changeset patch
# User jwe
# Date 1196217162 0
#      Wed Nov 28 02:32:42 2007 +0000
# Node ID a730e47fda4de105a529be53f0e7d2292dd96285
# Parent  71c03c7239fb5949d3fd7197429660f87c8421a1
[project @ 2007-11-28 02:32:41 by jwe]

diff --git a/scripts/general/diff.m b/scripts/general/diff.m
--- a/scripts/general/diff.m
+++ b/scripts/general/diff.m
@@ -93,41 +93,41 @@ function x = diff (x, k, dim)
   if (nargin == 3)
     if (sz (dim) <= k)
       sz(dim) = 0;
       x = zeros (sz);
     else
       n = sz (dim);
       idx1 = cell ();
       for i = 1:nd
-	idx1 {i} = 1:sz(i);
+	idx1{i} = 1:sz(i);
       endfor
       idx2 = idx1;
       for i = 1 : k;
-	idx1 {dim} = 2 : (n - i + 1);	
-	idx2 {dim} = 1 : (n - i);	
-	x = x (idx1 {:}) - x (idx2 {:});
+	idx1{dim} = 2 : (n - i + 1);	
+	idx2{dim} = 1 : (n - i);	
+	x = x(idx1{:}) - x(idx2{:});
       endfor
     endif
   else
     if (sum (sz - 1) < k)
       x = [];
     else
       idx1 = cell ();
       for i = 1:nd
-	idx1 {i} = 1:sz(i);
+	idx1{i} = 1:sz(i);
       endfor
       idx2 = idx1;
       while (k)
 	n = sz (dim);
 	for i = 1 : min (k, n - 1)
-	  idx1 {dim} = 2 : (n - i + 1);	
-	  idx2 {dim} = 1 : (n - i);	
-	  x = x (idx1 {:}) - x (idx2 {:});
+	  idx1{dim} = 2 : (n - i + 1);	
+	  idx2{dim} = 1 : (n - i);	
+	  x = x(idx1{:}) - x(idx2{:});
 	endfor
-	idx1 {dim} = idx2 {dim} = 1;
+	idx1{dim} = idx2{dim} = 1;
 	k = k - min (k, n - 1);
 	dim = dim + 1;
       endwhile
     endif
   endif
 
 endfunction
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -32,17 +32,17 @@ function retval = int2str (x)
   if (nargin == 1)
     x = round (real(x));
     sz = size(x);
     nd = ndims (x);
     nc = columns (x);
     if (nc > 1)
       idx = cell ();
       for i = 1:nd
-	idx {i} = 1:sz(i);
+	idx{i} = 1:sz(i);
       endfor
       idx(2) = 1;
       ifmt = get_fmt (x(idx{:}), 0);
       idx(2) = 2:sz(2);
       rfmt = get_fmt (x(idx{:}), 2);
       fmt = strcat (ifmt, repmat (rfmt, 1, nc-1), "\n")
     else
       fmt = strcat (get_fmt (x, 0), "\n");
diff --git a/scripts/general/interpn.m b/scripts/general/interpn.m
--- a/scripts/general/interpn.m
+++ b/scripts/general/interpn.m
@@ -66,57 +66,57 @@ function vi = interpn (varargin)
   method = "linear";
   extrapval = NA;
   nargs = nargin;
 
   if (nargin < 1)
     print_usage ();
   endif
 
-  if (ischar (varargin {end}))
-    method = varargin {end};
+  if (ischar (varargin{end}))
+    method = varargin{end};
     nargs = nargs - 1;
-  elseif (ischar (varargin {end - 1}))
-    if (! isnumeric (varargin {end}) || ! isscalar (varargin {end}))
+  elseif (ischar (varargin{end - 1}))
+    if (! isnumeric (varargin{end}) || ! isscalar (varargin{end}))
       error ("extrapal is expected to be a numeric scalar");
     endif
-    method = varargin {end - 1};
+    method = varargin{end - 1};
     nargs = nargs - 2;
   endif
 
   if (nargs < 3)
-    v = varargin {1};
+    v = varargin{1};
     m = 1;
     if (nargs == 2)
-      m = varargin {2};
+      m = varargin{2};
       if (! isnumeric (m) || ! isscalar (m) || floor (m) != m)
 	error ("m is expected to be a integer scalar");
       endif
     endif
     sz = size (v);
     nd = ndims (v);
     x = cell (1, nd);
     y = cell (1, nd);
     for i = 1 : nd;
       x{i} = 1 : sz(i);
       y{i} = 1 : (1 / (2 ^ m)) : sz(i);
     endfor
-  elseif (! isvector (varargin {1}) && nargs == (ndims (varargin {1}) + 1))
-    v = varargin {1};
+  elseif (! isvector (varargin{1}) && nargs == (ndims (varargin{1}) + 1))
+    v = varargin{1};
     sz = size (v);
     nd = ndims (v);
     x = cell (1, nd);
     y = varargin (2 : nargs);
     for i = 1 : nd;
       x{i} = 1 : sz(i);
     endfor
   elseif (rem (nargs, 2) == 1 && nargs ==  
-	  (2 * ndims (varargin {ceil (nargs / 2)})) + 1)
+	  (2 * ndims (varargin{ceil (nargs / 2)})) + 1)
     nv = ceil (nargs / 2);
-    v = varargin {nv};
+    v = varargin{nv};
     sz = size (v);
     nd = ndims (v);
     x = varargin (1 : (nv - 1));
     y = varargin ((nv + 1) : nargs);
   else
     error ("wrong number or incorrectly formatted input arguments");
   endif
 
@@ -154,18 +154,17 @@ function vi = interpn (varargin)
     yshape = size (y{1});
     yidx = cell (1, nd);
     for i = 1 : nd
       y{i} = y{i}(:);
       yidx{i} = lookup (x{i}(2:end-1), y{i}) + 1;
     endfor
     idx = cell (1,nd);
     for i = 1 : nd
-      idx {i} = yidx{i} + (y{i} - x{i}(yidx{i}).' > ...
-			   x{i}(yidx{i} + 1).' - y{i});
+      idx{i} = yidx{i} + (y{i} - x{i}(yidx{i}).' > x{i}(yidx{i} + 1).' - y{i});
     endfor
     vi = v (sub2ind (sz, idx{:}));
     idx = zeros (prod(yshape),1);
     for i = 1 : nd
       idx |= y{i} < min (x{i}(:)) | y{i} > max (x{i}(:));
     endfor
     vi(idx) = extrapval;
     vi = reshape (vi, yshape); 
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -77,20 +77,20 @@ function retval = num2str (x, arg)
     ## columns and imaginary values in the even columns.
     sz = size (x);
     nc = sz(2);
     nd = ndims (x);
     perm = fix ([1:0.5:nc+0.5]);
     perm(2:2:2*nc) = perm(2:2:2*nc) + nc;
     idx = cell ();
     for i = 1:nd
-      idx {i} = 1:sz(i);
+      idx{i} = 1:sz(i);
     endfor
     idx{2} = perm;
-    x = horzcat (real(x), imag(x));
+    x = horzcat (real (x), imag (x));
     x = x(idx{:});
 
     fmt = strcat (deblank (repmat (fmt, 1, nc)), "\n");
     tmp = sprintf (fmt, permute (x, [2, 1, 3:nd]));
 
     ## Put the "i"'s where they are supposed to be.
     while (true)
       tmp2 = strrep (tmp, " i\n", "i\n");
diff --git a/scripts/general/postpad.m b/scripts/general/postpad.m
--- a/scripts/general/postpad.m
+++ b/scripts/general/postpad.m
@@ -65,18 +65,18 @@ function y = postpad (x, l, c, dim)
     sz(nd+1:dim) = 1;
   endif
 
   d = sz (dim);
 
   if (d >= l)
     idx = cell ();
     for i = 1:nd
-      idx {i} = 1:sz(i);
+      idx{i} = 1:sz(i);
     endfor
-    idx {dim} = 1:l;
-    y = x (idx {:});
+    idx{dim} = 1:l;
+    y = x(idx{:});
   else
     sz (dim) = l - d;
     y = cat (dim, x, c * ones (sz));
   endif
 
 endfunction
diff --git a/scripts/general/prepad.m b/scripts/general/prepad.m
--- a/scripts/general/prepad.m
+++ b/scripts/general/prepad.m
@@ -78,18 +78,18 @@ function y = prepad (x, l, c, dim)
     sz(nd+1:dim) = 1;
   endif
 
   d = sz (dim);
 
   if (d >= l)
     idx = cell ();
     for i = 1:nd
-      idx {i} = 1:sz(i);
+      idx{i} = 1:sz(i);
     endfor
-    idx {dim} = d-l+1:d;
-    y = x (idx {:});
+    idx{dim} = d-l+1:d;
+    y = x(idx{:});
   else
     sz (dim) = l - d;
     y = cat (dim, c * ones (sz), x);
   endif
 
 endfunction
diff --git a/scripts/general/shift.m b/scripts/general/shift.m
--- a/scripts/general/shift.m
+++ b/scripts/general/shift.m
@@ -64,21 +64,21 @@ function y = shift (x, b, dim)
   if (numel (x) < 1)
     error ("shift: x must not be empty");
   endif
 
   d = sz (dim);
 
   idx = cell ();
   for i = 1:nd
-    idx {i} = 1:sz(i);
+    idx{i} = 1:sz(i);
   endfor
   if (b >= 0)
     b = rem (b, d);
-    idx {dim} = [d-b+1:d, 1:d-b];
+    idx{dim} = [d-b+1:d, 1:d-b];
   elseif (b < 0)
     b = rem (abs (b), d);
-    idx {dim} = [b+1:d, 1:b];
+    idx{dim} = [b+1:d, 1:b];
   endif
-  y = x (idx {:});
+  y = x(idx{:});
 
 
 endfunction
diff --git a/scripts/general/structfun.m b/scripts/general/structfun.m
--- a/scripts/general/structfun.m
+++ b/scripts/general/structfun.m
@@ -63,17 +63,17 @@
 ## @end deftypefn
 
 function varargout = structfun (fun, s, varargin);
   if (nargin < 2)
     print_usage ();
   endif
 
   varargout = cell (max ([nargout, 1]), 1);
-  [varargout{:}] = cellfun (fun, struct2cell (s), varargin {:});
+  [varargout{:}] = cellfun (fun, struct2cell (s), varargin{:});
 
   if (iscell (varargout{1}))
     [varargout{:}] = cell2struct (varargout{1}, fieldnames(s), 1);
   endif
 endfunction
 
 
 %!test
diff --git a/scripts/geometry/delaunayn.m b/scripts/geometry/delaunayn.m
--- a/scripts/geometry/delaunayn.m
+++ b/scripts/geometry/delaunayn.m
@@ -47,17 +47,17 @@
 ## 
 ## @end deftypefn
 
 function t = delaunayn (x, varargin)
   if (nargin < 1)
     print_usage ();
   endif
 
-  t = __delaunayn__ (x, varargin {:});
+  t = __delaunayn__ (x, varargin{:});
 
   ## Try to remove the zero volume simplices. The volume of the i-th simplex is
   ## given by abs(det(x(t(i,1:end-1),:)-x(t(i,2:end),:)))/prod(1:n) 
   ## (reference http://en.wikipedia.org/wiki/Simplex). Any simplex with a 
   ## relative volume less than some arbitrary criteria is rejected. The 
   ## criteria we use is the volume of the simplex corresponding to an 
   ## orthogonal simplex is equal edge length all equal to the edge length of 
   ## the original simplex. If the relative volume is 1e3*eps then the simplex
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -131,17 +131,17 @@ function [vvx, vvy] = voronoi (varargin)
 
   for i = 1 : ll
     k += length (c{idx(i)});
   endfor
 
   edges = zeros (2, k);
 
   for i = 1 : ll
-    fac = c {idx(i)};
+    fac = c{idx(i)};
     lf = length (fac);
     fac = [fac, fac(1)];
     fst = fac (1 : length(fac) - 1);
     sec = fac(2 : length(fac));
     edges (:, r : r + lf - 1) = [fst; sec];
     r += lf;
   endfor
 
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -41,17 +41,17 @@
 
 function retval = image (varargin)
 
   if (nargin == 0)
     __image__ (gca ());
   elseif (nargin == 1)
     print_usage ();
   elseif (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin {1};
+    h = varargin{1};
     if (! strcmp (get (h, "type"), "axes"))
       error ("image: expecting first argument to be an axes object");
     endif
     oldh = gca ();
     unwind_protect
       axes (h);
       tmp = __image__ (h, varargin{2:end});
     unwind_protect_cleanup
diff --git a/scripts/image/imagesc.m b/scripts/image/imagesc.m
--- a/scripts/image/imagesc.m
+++ b/scripts/image/imagesc.m
@@ -40,17 +40,17 @@
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function retval = imagesc (varargin)
 
   if (nargin < 1)
     print_usage ();
   elseif (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin {1};
+    h = varargin{1};
     if (! strcmp (get (h, "type"), "axes"))
       error ("imagesc: expecting first argument to be an axes object");
     endif
     oldh = gca ();
     unwind_protect
       axes (h);
       tmp = __imagesc__ (h, varargin{2:end});
     unwind_protect_cleanup
diff --git a/scripts/miscellaneous/what.m b/scripts/miscellaneous/what.m
--- a/scripts/miscellaneous/what.m
+++ b/scripts/miscellaneous/what.m
@@ -62,25 +62,25 @@ function ret = what (d)
     n = files(i).name;
     ## Ignore . and ..
     if (strcmp (n, ".") || strcmp (n, ".."))
       continue;
     else
       ## Ignore mdl and p files
       [dummy, f, e] = fileparts (n);
       if (strcmp (e, ".m"))
-	w.m {end+1} = n; 
+	w.m{end+1} = n; 
       elseif (strcmp (e, mexext ()))
-	w.mex {end + 1} = n; 
+	w.mex{end+1} = n; 
       elseif (strcmp (e, ".oct"))
-	w.oct {end + 1} = n;
+	w.oct{end+1} = n;
       elseif (strcmp (e, ".mat"))
-	w.mat {end + 1} = n; 
+	w.mat{end+1} = n; 
       elseif(strcmp (n(1), "@"))
-	w.classes {end + 1} = n;
+	w.classes{end+1} = n;
       endif
     endif
   endfor
 
   if (nargout == 0)
     __display_filenames__ ("M-files in directory", w.path, w.m);
     __display_filenames__ ("\nMEX-files in directory", w.path, w.mex);
     __display_filenames__ ("\nOCT-files in directory", w.path, w.oct);
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -1851,34 +1851,34 @@ function unload_packages (files, handle_
   if (length (files) == 1 && strcmp (files{1}, "all"))
       dirs = pdirs;
       desc = installed_pkgs_lst;
   ## unload package_name1 ...
   else
     dirs = {};
     desc = {};
     for i = 1:length (files)
-      idx = strcmp (pnames, files {i});
+      idx = strcmp (pnames, files{i});
       if (! any (idx))
 	error ("package %s is not installed", files{i});
       endif
-	dirs {end + 1} = pdirs {idx};
-        desc {end + 1} = installed_pkgs_lst {idx};
+	dirs{end+1} = pdirs{idx};
+        desc{end+1} = installed_pkgs_lst{idx};
       endfor
   endif
 
   ## Check for architecture dependent directories
   archdirs = {};
   for i = 1:length (dirs)
-    tmpdir = getarchdir (desc {i});
+    tmpdir = getarchdir (desc{i});
     if (exist (tmpdir, "dir"))
-      archdirs{end + 1} = dirs{i};
-      archdirs{end + 1} = tmpdir;
+      archdirs{end+1} = dirs{i};
+      archdirs{end+1} = tmpdir;
     else
-      archdirs{end+ 1} = dirs {i};
+      archdirs{end+1} = dirs{i};
     endif
   endfor
 
   ## Unload the packages
   for i = 1:length (archdirs)
     d = archdirs{i};
     idx = strcmp (p, d);
     if (any (idx))
@@ -1992,25 +1992,25 @@ function newdesc = save_order (desc)
     if (isempty (deps) || (length (deps) == 1 && 
 			  strcmp(deps{1}.package, "octave")))
       newdesc {end + 1} = desc{i};
     else
       tmpdesc = {};
       for k = 1 : length (deps)
         for j = 1 : length (desc)
           if (strcmp (desc{j}.name, deps{k}.package))
-            tmpdesc {end + 1} = desc{j};
+            tmpdesc{end+1} = desc{j};
 	    break;
           endif
         endfor
       endfor
       if (! isempty (tmpdesc))					     
         newdesc = {newdesc{:}, save_order(tmpdesc){:}, desc{i}};
       else
-        newdesc {end + 1} = desc{i};
+        newdesc{end+1} = desc{i};
       endif
     endif
   endfor
   ## Eliminate the duplicates
   idx = [];
   for i = 1 : length (newdesc)
     for j = (i + 1) : length (newdesc)
       if (strcmp (newdesc{i}.name, newdesc{j}.name))
@@ -2023,21 +2023,21 @@ endfunction
 
 function load_packages_and_dependencies (idx, handle_deps, installed_pkgs_lst,
 					 global_install)
   idx = load_package_dirs (idx, [], handle_deps, installed_pkgs_lst);
   dirs = {};
   execpath = EXEC_PATH ();
   for i = idx;
     ndir = installed_pkgs_lst{i}.dir;
-    dirs {end + 1} = ndir;
+    dirs{end+1} = ndir;
     if (exist (fullfile (dirs{end}, "bin"), "dir"))
       execpath = strcat (fullfile(dirs{end}, "bin"), ":", execpath);
     endif
-    tmpdir = getarchdir (installed_pkgs_lst {i});
+    tmpdir = getarchdir (installed_pkgs_lst{i});
     if (exist (tmpdir, "dir"))
       dirs{end + 1} = tmpdir;
       if (exist (fullfile (dirs{end}, "bin"), "dir"))
         execpath = strcat (fullfile(dirs{end}, "bin"), ":", execpath);
       endif
     endif
   endfor
 
@@ -2082,25 +2082,25 @@ function idx = load_package_dirs (lidx, 
   endfor
 endfunction
 
 function dep = is_architecture_dependent (nm)
   persistent archdepsuffix = {".oct",".mex",".a",".so",".so.*",".dll","dylib"};
 
   dep = false;
   for i = 1 : length (archdepsuffix)
-    ext = archdepsuffix {i};
+    ext = archdepsuffix{i};
     if (ext(end) == "*")
       isglob = true;
       ext(end) = [];
     else
       isglob = false;
     endif
     pos = findstr (nm, ext);
     if (pos)
-      if (! isglob &&  (length(nm) - pos(end) != length(ext) - 1))
+      if (! isglob && (length(nm) - pos(end) != length(ext) - 1))
 	continue;
       endif
       dep = true;
       break;
     endif
   endfor
 endfunction
diff --git a/scripts/plot/__axes_limits__.m b/scripts/plot/__axes_limits__.m
--- a/scripts/plot/__axes_limits__.m
+++ b/scripts/plot/__axes_limits__.m
@@ -18,30 +18,30 @@
 
 ## Undocumented internal function.
 
 function retval = __axes_limits__ (fcn, varargin)
   retval = [];
   fcnmode = sprintf("%smode", fcn);
 
   if (nargin > 1 && isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin {1};
+    h = varargin{1};
     off = 1;
     if (! strcmp (get (h, "type"), "axes"))
       error ("%s: expecting first argument to be an axes object", fcn);
     endif
   else
     off = 0;
     h = gca ();
   endif
 
   if (nargin == off + 1)
     retval = get (h, fcn);
   else
-    arg = varargin {off + 1};
+    arg = varargin{off + 1};
 
     if (ischar (arg))
       arg = tolower (arg);
       if (strcmp ("mode", arg))
 
 	retval = get (h, fcnmode);
       elseif (strcmp ("auto", arg) ||  strcmp ("manual", arg))  
 	set (h, fcnmode, arg);
diff --git a/scripts/plot/__bar__.m b/scripts/plot/__bar__.m
--- a/scripts/plot/__bar__.m
+++ b/scripts/plot/__bar__.m
@@ -155,17 +155,17 @@ function varargout = __bar2__ (h, vertic
   yb(4:4:4*ylen,:) = y0;
 
   xb = reshape (xb, [4, numel(xb) / 4 / ycols, ycols]);
   yb = reshape (yb, [4, numel(yb) / 4 / ycols, ycols]);
 
   if (nargout < 2)
     newplot ();
     tmp = __bars__ (h, vertical, x, y, xb, yb, width, group,
-		    have_line_spec, newargs {:});
+		    have_line_spec, newargs{:});
     if (nargout == 1)
       varargout{1} = tmp;
     endif
   else
     if (vertical)
       varargout{1} = xb;
       varargout{2} = yb;
     else
diff --git a/scripts/plot/__bars__.m b/scripts/plot/__bars__.m
--- a/scripts/plot/__bars__.m
+++ b/scripts/plot/__bars__.m
@@ -30,30 +30,30 @@ function tmp = __bars__ (h, vertical, x,
     for i = 1:ycols
       if (! have_color_spec)
 	if (ycols == 1)
 	  lev = clim(1);
 	else
 	  lev = (i - 1) * (clim(2) - clim(1)) / (ycols - 1) - clim(1);
 	endif
 	tmp = [tmp; patch(xb(:,:,i), yb(:,:,i), "FaceColor", "flat", 
-			  "cdata", lev, varargin {:})];
+			  "cdata", lev, varargin{:})];
       else
-	tmp = [tmp; patch(xb(:,:,i), yb(:,:,i), varargin {:})];
+	tmp = [tmp; patch(xb(:,:,i), yb(:,:,i), varargin{:})];
       endif
     endfor
   else
     tmp = [];
     for i = 1:ycols
       if (! have_color_spec)
 	if (ycols == 1)
 	  lev = clim(1)
 	else
 	  lev = (i - 1) * (clim(2) - clim(1)) / (ycols - 1) - clim(1);
 	endif
 	tmp = [tmp; patch(yb(:,:,i), xb(:,:,i), "FaceColor", "flat", 
-			  "cdata", lev, varargin {:})];
+			  "cdata", lev, varargin{:})];
       else
-	tmp = [tmp; patch(yb(:,:,i), xb(:,:,i), varargin {:})];
+	tmp = [tmp; patch(yb(:,:,i), xb(:,:,i), varargin{:})];
       endif
     endfor
   endif
 endfunction
diff --git a/scripts/plot/__contour__.m b/scripts/plot/__contour__.m
--- a/scripts/plot/__contour__.m
+++ b/scripts/plot/__contour__.m
@@ -15,27 +15,27 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## Undocumented internal function.
 
 function [c, h] = __contour__ (varargin)
 
-  ax = varargin {1};
-  z = varargin {2};
+  ax = varargin{1};
+  z = varargin{2};
 
   if (ischar (z))
     if (strcmp (z, "none"))
       z = NaN;
     elseif (strcmp (z, "base"))
       if (nargin == 1)
-	z = varargin {1};
+	z = varargin{1};
       else
-	z = varargin {3};
+	z = varargin{3};
       endif
       z = 2 * (min (z(:)) - max (z(:)));
     elseif (! strcmp (z, "level"))
       error ("unrecognized z argument");
     endif
   endif
 
   [c, lev] = contourc (varargin{3:end});
diff --git a/scripts/plot/__patch__.m b/scripts/plot/__patch__.m
--- a/scripts/plot/__patch__.m
+++ b/scripts/plot/__patch__.m
@@ -43,17 +43,17 @@ function [h, fail] = __patch__ (p, varar
 
     x = varargin{1};
     y = varargin{2};
     have_x = true;
     iarg += 2;
 
     if (nargin > 3 && ndims (varargin{3}) == 2 && ndims (x) == 2
 	&& isequal (size (varargin{3}), size (x)))
-      z = varargin {3};
+      z = varargin{3};
       have_z = true;
       iarg++;
     endif
   elseif (ischar (varargin{1})
 	  && (strcmp (tolower (varargin{1}), "faces")
 	      || trcmp (tolower (varargin{1}), "vertices")))
     if (! isnumeric (varargin{2}))
       fail = true;
diff --git a/scripts/plot/colorbar.m b/scripts/plot/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/colorbar.m
@@ -62,17 +62,17 @@ function colorbar (varargin)
       error ("colorbar: misisng axes handle after 'peer'");
     endif
   else
     ax = gca ();
   endif
 
   pos = "eastoutside";
   for i = 1 : length (varargin)
-    arg = varargin {i};
+    arg = varargin{i};
     if (length(arg) < 1)
       pos = "eastoutside";
     elseif (ischar (arg))
       arg = tolower (arg);
       if (strcmp (arg, "off") || strcmp (arg, "none"))
 	pos = "none";
       elseif (strcmp (arg, "north") || strcmp (arg, "south")
 	      || strcmp (arg, "east") || strcmp (arg, "west")
diff --git a/scripts/plot/fill.m b/scripts/plot/fill.m
--- a/scripts/plot/fill.m
+++ b/scripts/plot/fill.m
@@ -25,17 +25,17 @@
 ## Create one or more filled patch objects, returning a patch object for each.
 ## @end deftypefn
 
 function h = fill (varargin)
 
   htmp = [];
 
   if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin {1};
+    h = varargin{1};
     if (! strcmp (get (h, "type"), "axes"))
       error ("fill: expecting first argument to be an axes object");
     endif
 
     iargs = __find_patches__ (varargin{:}) + 1;
     oldh = gca ();
     unwind_protect
       axes (h);
@@ -77,35 +77,35 @@ function h = fill (varargin)
   endif
 endfunction
 
 function iargs = __find_patches__ (varargin)
   iargs = [];
   i = 1;
   while (i < nargin)
     iargs (end + 1) = i;
-    if (ischar (varargin {i}) && (strcmp (tolower (varargin{i}), "faces") || 
+    if (ischar (varargin{i}) && (strcmp (tolower (varargin{i}), "faces") || 
 				  strcmp (tolower (varargin{i}), "vertices")))
       i += 4;
-    elseif (isnumeric (varargin {i}))
+    elseif (isnumeric (varargin{i}))
       i += 2;
     endif
 
     if (i <= nargin)
       while (true);
-	if (ischar (varargin {i}) && 
+	if (ischar (varargin{i}) && 
 	    (strcmp (tolower (varargin{i}), "faces") || 
 	     strcmp (tolower (varargin{i}), "vertices")))
 	  break;
-	elseif (isnumeric (varargin {i}))
+	elseif (isnumeric (varargin{i}))
 	  ## Assume its the colorspec
 	  i++;
 	  break;
-	elseif (ischar (varargin {i}))
-	  colspec = tolower (varargin {i});
+	elseif (ischar (varargin{i}))
+	  colspec = tolower (varargin{i});
 	  collen = length (colspec);
 
 	  if (strncmp (colspec, "blue", collen) ||
 	      strncmp (colspec, "black", collen) ||
 	      strncmp (colspec, "k", collen) ||
 	      strncmp (colspec, "black", collen) ||
 	      strncmp (colspec, "red", collen) ||
 	      strncmp (colspec, "green", collen) ||
diff --git a/scripts/plot/findobj.m b/scripts/plot/findobj.m
--- a/scripts/plot/findobj.m
+++ b/scripts/plot/findobj.m
@@ -104,17 +104,17 @@ function h = findobj (varargin)
   pvalue            = {};
   np = 1;
   na = 1;
 
   while (na <= numel (args))
     regularexpression(np) = 0;
     property(np) = 0;
     logicaloperator{np} = 'and';
-    if (ischar (args {na}))
+    if (ischar (args{na}))
       if (strcmpi(args{na}, '-regexp'))
 	if (na + 2 <= numel (args))
 	  regularexpression(np) = 1;
 	  na = na + 1;
 	  pname{np} = args{na};
 	  na = na + 1;
 	  pvalue{np} = args{na};
 	  na = na + 1;
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -64,17 +64,17 @@ function [nn, xx] = hist (y, varargin)
 
   iarg = 1;
   if (nargin == 1 || ischar (varargin{iarg}))
     n = 10;
     x = [0.5:n]'/n;
     x = x * (max_val - min_val) + ones(size(x)) * min_val;
   else
     ## nargin is either 2 or 3
-    x = varargin {iarg++};
+    x = varargin{iarg++};
     if (isscalar (x))
       n = x;
       if (n <= 0)
         error ("hist: number of bins must be positive");
       endif
       x = [0.5:n]'/n;
       x = x * (max_val - min_val) + ones (size (x)) * min_val;
     elseif (isreal (x))
diff --git a/scripts/plot/meshz.m b/scripts/plot/meshz.m
--- a/scripts/plot/meshz.m
+++ b/scripts/plot/meshz.m
@@ -25,17 +25,17 @@
 ## columns of @var{z} correspond to different @var{x} values and rows of 
 ## @var{z} correspond to different @var{y} values.
 ## @seealso{meshgrid, mesh, contour}
 ## @end deftypefn
  
 function retval = meshz (varargin)
 
   if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin {1};
+    h = varargin{1};
     if (! strcmp (get (h, "type"), "axes"))
       error ("meshz: expecting first argument to be an axes object");
     endif
     oldh = gca ();
     unwind_protect
       axes (h);
       tmp = __meshz__ (varargin{2:end});
     unwind_protect_cleanup
@@ -50,36 +50,36 @@ function retval = meshz (varargin)
   endif
 
 endfunction
 
 function h = __meshz__ (varargin)
 
   ioff = nargin + 1;
   for i = 1 : nargin
-    if (ischar (varargin {i}))
+    if (ischar (varargin{i}))
       ioff = i;
       break;
     endif
   endfor
 
   ## Bundle C matrix back into varargin
   if (ioff == 3 || ioff == 5)
     ioff --;
   endif
 
   if (ioff == 2)
-    z = varargin {1};
+    z = varargin{1};
     [m, n] = size (z);
     x = 1 : n;
     y = (1 : m).';
   else
-    x = varargin {1};
-    y = varargin {2};
-    z = varargin {3};
+    x = varargin{1};
+    y = varargin{2};
+    z = varargin{3};
   endif
 
 
   if (isvector (x) && isvector (y))
     x = [x(1), x(:).', x(end)];
     y = [y(1); y(:); y(end)];
   else
     x = [x(1, 1), x(1, :), x(1, end);
diff --git a/scripts/plot/patch.m b/scripts/plot/patch.m
--- a/scripts/plot/patch.m
+++ b/scripts/plot/patch.m
@@ -32,17 +32,17 @@
 ## example, "r" or "red"). 
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = patch (varargin)
 
   if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin {1};
+    h = varargin{1};
     if (! strcmp (get (h, "type"), "axes") && ! strcmp (get (h, "type"), "hggroup"))
       error ("patch: expecting first argument to be an axes or hggroup object");
     endif
     oldh = gca ();
     unwind_protect
       axes (ancestor (h, "axes"));
       [tmp, fail] = __patch__ (h, varargin{2:end});
     unwind_protect_cleanup
diff --git a/scripts/plot/pie.m b/scripts/plot/pie.m
--- a/scripts/plot/pie.m
+++ b/scripts/plot/pie.m
@@ -42,17 +42,17 @@
 ## Very roughly based on pie.m from octave-forge whose author was
 ## Daniel Heiserer <Daniel.heiserer@physik.tu-muenchen.de>
 
 function retval = pie (varargin)
 
   if (nargin < 1)
     print_usage ();
   elseif (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin {1};
+    h = varargin{1};
     if (! strcmp (get (h, "type"), "axes"))
       error ("pie: expecting first argument to be an axes object");
     endif
     oldh = gca ();
     unwind_protect
       axes (h);
       newplot ();
       tmp = __pie__ (h, varargin{2:end});
@@ -135,17 +135,17 @@ function hlist = __pie__ (varargin)
     yt = 1.2 * cosd (xn2);
     if (xt > 0)
       align = "left";
     else
       align = "right";
     endif
 
     hlist = [hlist; patch(xoff + [0, - sind(xn)], yoff + [0, cosd(xn)], i);
-    	     text(xt, yt, labels {i}, "horizontalalignment", align)];
+    	     text(xt, yt, labels{i}, "horizontalalignment", align)];
   endfor
 
   if (len == 1)
     set (h, "clim", [1, 2]);
   else
     set (h, "clim", [1, len]);
   endif
 
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -174,17 +174,17 @@
 ## stairs, errorbar, xlabel, ylabel, title, print}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = plot (varargin)
 
   if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin {1};
+    h = varargin{1};
     if (! strcmp (get (h, "type"), "axes"))
       error ("plot: expecting first argument to be an axes object");
     endif
     oldh = gca ();
     unwind_protect
       axes (h);
       newplot ();
       tmp = __plt__ ("plot", h, varargin{2:end});
diff --git a/scripts/plot/plotyy.m b/scripts/plot/plotyy.m
--- a/scripts/plot/plotyy.m
+++ b/scripts/plot/plotyy.m
@@ -51,17 +51,17 @@
 ## ylabel (ax(2), "Axis 2");
 ## @end group
 ## @end example
 ## @end deftypefn
 
 function [Ax, H1, H2] = plotyy (varargin)
 
   if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    ax = varargin {1};
+    ax = varargin{1};
     if (! strcmp (get (ax, "type"), "axes"))
       error ("plotyy: expecting first argument to be an axes object");
     endif
     if (nargin < 5)
       print_usage ();
     endif
     oldh = gca ();
     unwind_protect
diff --git a/scripts/plot/quiver.m b/scripts/plot/quiver.m
--- a/scripts/plot/quiver.m
+++ b/scripts/plot/quiver.m
@@ -56,17 +56,17 @@
 ## @seealso{plot}
 ## @end deftypefn
 
 function retval = quiver (varargin)
 
   if (nargin < 2)
     print_usage ();
   elseif (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin {1};
+    h = varargin{1};
     if (! strcmp (get (h, "type"), "axes"))
       error ("quiver: expecting first argument to be an axes object");
     endif
     oldh = gca ();
     unwind_protect
       axes (h);
       newplot ();
       tmp = __quiver__ (h, 0, varargin{2:end});
diff --git a/scripts/plot/quiver3.m b/scripts/plot/quiver3.m
--- a/scripts/plot/quiver3.m
+++ b/scripts/plot/quiver3.m
@@ -59,17 +59,17 @@
 ## @seealso{plot}
 ## @end deftypefn
 
 function retval = quiver3 (varargin)
 
   if (nargin < 2)
     print_usage ();
   elseif (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin {1};
+    h = varargin{1};
     if (! strcmp (get (h, "type"), "axes"))
       error ("quiver: expecting first argument to be an axes object");
     endif
     oldh = gca ();
     unwind_protect
       axes (h);
       newplot ();
       tmp = __quiver__ (h, 1, varargin{2:end});
diff --git a/scripts/plot/scatter.m b/scripts/plot/scatter.m
--- a/scripts/plot/scatter.m
+++ b/scripts/plot/scatter.m
@@ -54,17 +54,17 @@
 ## @seealso{plot, patch, scatter3}
 ## @end deftypefn
 
 function retval = scatter (varargin)
 
   if (nargin < 2)
     print_usage ();
   elseif (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin {1};
+    h = varargin{1};
     if (! strcmp (get (h, "type"), "axes"))
       error ("scatter: expecting first argument to be an axes object");
     endif
     oldh = gca ();
     unwind_protect
       axes (h);
       newplot ();
       tmp = __scatter__ (h, 2, "scatter", varargin{2:end});
diff --git a/scripts/plot/scatter3.m b/scripts/plot/scatter3.m
--- a/scripts/plot/scatter3.m
+++ b/scripts/plot/scatter3.m
@@ -53,17 +53,17 @@
 ## @seealso{plot, patch, scatter}
 ## @end deftypefn
 
 function retval = scatter3 (varargin)
 
   if (nargin < 2)
     print_usage ();
   elseif (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin {1};
+    h = varargin{1};
     if (! strcmp (get (h, "type"), "axes"))
       error ("scatter3: expecting first argument to be an axes object");
     endif
     oldh = gca ();
     unwind_protect
       axes (h);
       newplot ();
       tmp = __scatter__ (h, 3, "scatter3", varargin{2:end});
diff --git a/scripts/plot/surface.m b/scripts/plot/surface.m
--- a/scripts/plot/surface.m
+++ b/scripts/plot/surface.m
@@ -37,17 +37,17 @@
 ## @seealso{surf, mesh, patch, line}
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = surface (varargin)
 
   if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin {1};
+    h = varargin{1};
     if (! strcmp (get (h, "type"), "axes"))
       error ("surface: expecting first argument to be an axes object");
     endif
     oldh = gca ();
     unwind_protect
       axes (h);
       [tmp, bad_usage] = __surface__ (h, varargin{2:end});
     unwind_protect_cleanup
@@ -67,17 +67,17 @@ function h = surface (varargin)
 endfunction
 
 function [h, bad_usage] = __surface__ (ax, varargin)
 
   bad_usage = false;
   h = 0;
   firststring = nargin;
   for i = 2 : nargin
-    if (ischar (varargin {i - 1}))
+    if (ischar (varargin{i - 1}))
       firststring = i - 1;
       break;
     endif
   endfor
 
   if (firststring > 5)
     bad_usage = true;
   elseif (firststring == 5)
@@ -118,27 +118,27 @@ function [h, bad_usage] = __surface__ (a
     elseif (ismatrix (x) && ismatrix (y) && ismatrix (z))
       if (! (size_equal (x, y) && size_equal (x, z)))
         error ("surface: x, y, and z must have same dimensions");
       endif
     else
       error ("surface: x and y must be vectors and z must be a matrix");
     endif
   elseif (firststring == 3)    
-    z = varargin {1};
-    c = varargin {2};
+    z = varargin{1};
+    c = varargin{2};
     if (ismatrix (z))
       [nr, nc] = size (z);
       x = 1:nc;
       y = (1:nr)';
     else
       error ("surface: argument must be a matrix");
     endif
   elseif (firststring == 2)    
-    z = varargin {1};
+    z = varargin{1};
     c = z;
     if (ismatrix (z))
       [nr, nc] = size (z);
       x = 1:nc;
       y = (1:nr)';
     else
       error ("surface: argument must be a matrix");
     endif
@@ -146,17 +146,17 @@ function [h, bad_usage] = __surface__ (a
     bad_usage = true;
   endif
 
   if (! bad_usage)
     ## Make a default surface object.
     h = __go_surface__ (ax, "xdata", x, "ydata", y, "zdata", z, "cdata", c);
     set (h, "facecolor","flat");
     if (firststring < nargin)
-      set (h, varargin {firststring:end});
+      set (h, varargin{firststring:end});
      endif
 
      if (! ishold ())
        set (ax, "view", [0, 90], "box", "off", "xgrid", "on",
 	    "ygrid", "on", "zgrid", "on");
      endif
    endif
 
diff --git a/scripts/plot/surfc.m b/scripts/plot/surfc.m
--- a/scripts/plot/surfc.m
+++ b/scripts/plot/surfc.m
@@ -37,19 +37,19 @@ function h = surfc (varargin)
 
   set (tmp, "facecolor", "flat");
 
   if (! ishold ())
     set (ax, "view", [-37.5, 30]);
   endif
 
   if (nargin == 1)
-    z = varargin {1};
+    z = varargin{1};
   else
-    z = varargin {3};
+    z = varargin{3};
   endif
   zmin = 2 * (min(z(:)) - max(z(:)));
 
   [c, tmp2] = __contour__ (ax, zmin, varargin{:});
 
   tmp = [tmp; tmp2];
 
   if (nargout > 0)
diff --git a/scripts/plot/surfnorm.m b/scripts/plot/surfnorm.m
--- a/scripts/plot/surfnorm.m
+++ b/scripts/plot/surfnorm.m
@@ -52,17 +52,17 @@
 function varargout = surfnorm (varargin)
 
   if (nargout > 0)
     varargout = cell (nargout, 1);
   else
     varargout = cell (0, 0);
   endif
   if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    h = varargin {1};
+    h = varargin{1};
     if (! strcmp (get (h, "type"), "axes"))
       error ("surfnorm: expecting first argument to be an axes object");
     endif
     if (nargin != 2 && nargin != 4)
       print_usage ();
     endif
     oldh = gca ();
     unwind_protect
diff --git a/scripts/plot/xlabel.m b/scripts/plot/xlabel.m
--- a/scripts/plot/xlabel.m
+++ b/scripts/plot/xlabel.m
@@ -28,17 +28,17 @@
 ## bar, stairs,  ylabel, title}
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = xlabel (varargin)
 
   if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    ax = varargin {1};
+    ax = varargin{1};
     if (! strcmp (get (ax, "type"), "axes"))
       error ("xlabel: expecting first argument to be an axes object");
     endif
     if (rem (nargin, 2) == 1)
       print_usage ();
     endif
     oldh = gca ();
     unwind_protect
diff --git a/scripts/plot/xlim.m b/scripts/plot/xlim.m
--- a/scripts/plot/xlim.m
+++ b/scripts/plot/xlim.m
@@ -33,14 +33,14 @@
 ## as the argument.
 ##
 ## If passed an handle as the first argument, then operate on this handle
 ## rather than the current axes handle.
 ## @seealso{ylim, zlim, set, get, gca}
 ## @end deftypefn
 
 function retval = xlim (varargin)
-  ret = __axes_limits__ ("xlim", varargin {:});
+  ret = __axes_limits__ ("xlim", varargin{:});
 
   if (! isempty (ret))
     retval = ret;
   endif
 endfunction
diff --git a/scripts/plot/ylabel.m b/scripts/plot/ylabel.m
--- a/scripts/plot/ylabel.m
+++ b/scripts/plot/ylabel.m
@@ -23,17 +23,17 @@
 ## See xlabel.
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = ylabel (varargin)
 
   if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    ax = varargin {1};
+    ax = varargin{1};
     if (! strcmp (get (ax, "type"), "axes"))
       error ("ylabel: expecting first argument to be an axes object");
     endif
     if (rem (nargin, 2) == 1)
       print_usage ();
     endif
     oldh = gca ();
     unwind_protect
diff --git a/scripts/plot/ylim.m b/scripts/plot/ylim.m
--- a/scripts/plot/ylim.m
+++ b/scripts/plot/ylim.m
@@ -33,14 +33,14 @@
 ## as the argument.
 ##
 ## If passed an handle as the first argument, then operate on this handle
 ## rather than the current axes handle.
 ## @seealso{xlim, zlim, set, get, gca}
 ## @end deftypefn
 
 function retval = ylim (varargin)
-  ret = __axes_limits__ ("ylim", varargin {:});
+  ret = __axes_limits__ ("ylim", varargin{:});
 
   if (! isempty (ret))
     retval = ret;
   endif
 endfunction
diff --git a/scripts/plot/zlabel.m b/scripts/plot/zlabel.m
--- a/scripts/plot/zlabel.m
+++ b/scripts/plot/zlabel.m
@@ -23,17 +23,17 @@
 ## See xlabel.
 ## @end deftypefn
 
 ## Author: jwe
 
 function h = zlabel (varargin)
 
   if (isscalar (varargin{1}) && ishandle (varargin{1}))
-    ax = varargin {1};
+    ax = varargin{1};
     if (! strcmp (get (ax, "type"), "axes"))
       error ("zlabel: expecting first argument to be an axes object");
     endif
     if (rem (nargin, 2) == 1)
       print_usage ();
     endif
     oldh = gca ();
     unwind_protect
diff --git a/scripts/plot/zlim.m b/scripts/plot/zlim.m
--- a/scripts/plot/zlim.m
+++ b/scripts/plot/zlim.m
@@ -33,14 +33,14 @@
 ## as the argument.
 ##
 ## If passed an handle as the first argument, then operate on this handle
 ## rather than the current axes handle.
 ## @seealso{xlim, ylim, set, get, gca}
 ## @end deftypefn
 
 function retval = zlim (varargin)
-  ret = __axes_limits__ ("zlim", varargin {:});
+  ret = __axes_limits__ ("zlim", varargin{:});
 
   if (! isempty (ret))
     retval = ret;
   endif
 endfunction
diff --git a/scripts/signal/fftshift.m b/scripts/signal/fftshift.m
--- a/scripts/signal/fftshift.m
+++ b/scripts/signal/fftshift.m
@@ -55,19 +55,19 @@ function retval = fftshift (V, dim)
     if (!isscalar (dim))
       error ("fftshift: dimension must be an integer scalar");
     endif
     nd = ndims (V);
     sz = size (V);
     sz2 = ceil (sz(dim) / 2);
     idx = cell ();
     for i=1:nd
-      idx {i} = 1:sz(i);
+      idx{i} = 1:sz(i);
     endfor
-    idx {dim} = [sz2+1:sz(dim), 1:sz2];
+    idx{dim} = [sz2+1:sz(dim), 1:sz2];
     retval = V (idx{:});
   else
     if (isvector (V))
       x = length (V);
       xx = ceil (x/2);
       retval = V([xx+1:x, 1:xx]);
     elseif (ismatrix (V))
       nd = ndims (V);
diff --git a/scripts/signal/ifftshift.m b/scripts/signal/ifftshift.m
--- a/scripts/signal/ifftshift.m
+++ b/scripts/signal/ifftshift.m
@@ -34,27 +34,27 @@ function retval = ifftshift (V, dim)
 
   retval = 0;
 
   if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
   if (nargin == 2)
-    if (!isscalar (dim))
+    if (! isscalar (dim))
       error ("ifftshift: dimension must be an integer scalar");
     endif
     nd = ndims (V);
     sz = size (V);
     sz2 = floor (sz(dim) / 2);
     idx = cell ();
     for i=1:nd
-      idx {i} = 1:sz(i);
+      idx{i} = 1:sz(i);
     endfor
-    idx {dim} = [sz2+1:sz(dim), 1:sz2];
+    idx{dim} = [sz2+1:sz(dim), 1:sz2];
     retval = V (idx{:});
   else
     if (isvector (V))
       x = length (V);
       xx = floor (x/2);
       retval = V([xx+1:x, 1:xx]);
     elseif (ismatrix (V))
       nd = ndims (V);
diff --git a/scripts/signal/unwrap.m b/scripts/signal/unwrap.m
--- a/scripts/signal/unwrap.m
+++ b/scripts/signal/unwrap.m
@@ -41,49 +41,49 @@ function retval = unwrap (a, tol, dim)
   if (nargin == 3)
     if (! (isscalar (dim) && dim == round (dim)) && dim > 0 && 
 	dim < (nd + 1))
       error ("unwrap: dim must be an integer and valid dimension");
     endif
   else
     ## Find the first non-singleton dimension
     dim  = 1;
-    while (dim < nd + 1 && sz (dim) == 1)
+    while (dim < nd + 1 && sz(dim) == 1)
       dim = dim + 1;
     endwhile
     if (dim > nd)
       dim = 1;
     endif
   endif
 
   if (nargin < 2 || isempty (tol))
     tol = pi;
   endif
 
   ## Don't let anyone use a negative value for TOL.
   tol = abs (tol);
   
   rng = 2*pi;
-  m = sz (dim);
+  m = sz(dim);
 
   ## Handle case where we are trying to unwrap a scalar, or only have
   ## one sample in the specified dimension.
   if (m == 1)       
     retval = a;     
     return;         
   endif
 
   ## Take first order difference to see so that wraps will show up
   ## as large values, and the sign will show direction.
   idx = cell ();
   for i = 1:nd
-    idx {i} = 1:sz(i);
+    idx{i} = 1:sz(i);
   endfor
-  idx {dim} = [1,1:m-1];
-  d = a (idx {:}) - a;
+  idx{dim} = [1,1:m-1];
+  d = a(idx{:}) - a;
 
   ## Find only the peaks, and multiply them by the range so that there
   ## are kronecker deltas at each wrap point multiplied by the range
   ## value.
   p =  rng * (((d > tol) > 0) - ((d < -tol) > 0));
 
   ## Now need to "integrate" this so that the deltas become steps.
   r = cumsum (p, dim);
diff --git a/scripts/statistics/base/center.m b/scripts/statistics/base/center.m
--- a/scripts/statistics/base/center.m
+++ b/scripts/statistics/base/center.m
@@ -39,17 +39,17 @@ function retval = center (x, varargin)
     retval = x - mean (x, varargin{:});
   elseif (ismatrix (x))
     if nargin < 2
       dim = find (size (x) > 1, 1);
       if isempty (dim), 
 	dim=1; 
       endif;
     else
-      dim = varargin {1};
+      dim = varargin{1};
     endif
     sz = ones (1, ndims (x));
     sz (dim) = size (x, dim);
     retval = x - repmat (mean (x, dim), sz);
   elseif (isempty (x))
     retval = x;
   else
     error ("center: x must be a vector or a matrix");
diff --git a/scripts/statistics/base/mode.m b/scripts/statistics/base/mode.m
--- a/scripts/statistics/base/mode.m
+++ b/scripts/statistics/base/mode.m
@@ -81,17 +81,17 @@ function [m, f, c] = mode (x, dim)
   else
     t2 (t) = diff ([find(t); prod(sz)+1]);
     f = max (t2, [], dim);
   endif
 
   c = cell (sz2);
   m = zeros (sz2);
   for i = 1 : prod (sz2)
-    c {i} = xs (t2 (:, i) == f(i), i);
+    c{i} = xs (t2 (:, i) == f(i), i);
     m (i) = c{i}(1);
   endfor
 endfunction
 
 %!test
 %! [m, f, c] = mode (toeplitz (1:5));
 %! assert (m, [1,2,2,2,1]);
 %! assert (f, [1,2,2,2,1]);
diff --git a/scripts/statistics/base/run_count.m b/scripts/statistics/base/run_count.m
--- a/scripts/statistics/base/run_count.m
+++ b/scripts/statistics/base/run_count.m
@@ -80,15 +80,15 @@ function retval = run_count (x, n, dim)
 
   sz(1) = n;
   retval = zeros (sz);
   for k = 1 : (n-1)
     idx{1} = k;
     retval(idx{:}) = sum (tmp == k);
   endfor
   idx{1} = n;
-  retval (idx {:}) = sum (tmp >= n);
+  retval (idx{:}) = sum (tmp >= n);
 
   if (dim != 1)
     retval = ipermute (retval, perm);
   endif
 
 endfunction
diff --git a/scripts/strings/strvcat.m b/scripts/strings/strvcat.m
--- a/scripts/strings/strvcat.m
+++ b/scripts/strings/strvcat.m
@@ -38,35 +38,35 @@ function retval = strvcat (varargin)
 
   if (nargin == 0)
     print_usage ();
   endif
 
   nr = zeros (nargin, 1);
   nc = zeros (nargin, 1);
   K = 0; 
-  nd = ndims (varargin {1});
-  sz = size (varargin {1});
-  for k = 1 : nargin
+  nd = ndims (varargin{1});
+  sz = size (varargin{1});
+  for k = 1:nargin
     s = varargin{k};
     if (iscell (s))
       for k1 = 1:length(s)
-	K = K+1;
+	K++;
 	nr(K) = size (s{k1}, 1);
 	nc(K) = size (s{k1}, 2);
 	if (ndims (s{k1}) != nd)
 	  error ("strvcat: dimension mismatch");
 	else
 	  if (any (sz(3:nd) != size (s{k1}) (3:nd)))
 	    error ("strvcat: dimension mismatch");
 	  endif
 	endif
       endfor
     else
-      K = K + 1;
+      K++;
       nr(K) = size (s, 1);
       nc(K) = size (s, 2);
       if (ndims (s) != nd)
 	error ("strvcat: dimension mismatch");
       else
 	if (any (sz(3:nd) != size (s) (3:nd)))
 	  error ("strvcat: dimension mismatch");
 	endif
@@ -74,36 +74,36 @@ function retval = strvcat (varargin)
     endif
   endfor
 
   sz(1) = sum (nr);
   sz(2) = max (nc);
   retval = char (ones (sz) * toascii (" "));
 
   idx = cell(nd,1);
-  for k = 3 : nd;
-    idx {k} = sz {k};
+  for k = 3:nd
+    idx{k} = sz{k};
   endfor
 
   K = 0;
   row_offset = 0;
-  for k = 1 : nargin
+  for k = 1:nargin
     s = varargin{k};
     if (iscell (s))
       for k1 = 1:length(s)
 	K = K + 1;
 	idx{1} = [row_offset + 1 : row_offset + nr(k)];
 	idx{2} = [1 : nc(K)];
 	retval(idx{:}) = char(s{k1});
 	row_offset = row_offset + size (s{k1}, 1);
       endfor
     else
-      K = K + 1;
+      K++;
       if (nc(K) > 0)
-    	retval ((row_offset + 1) : (row_offset + nr(K)), 1:nc(K)) = char(s);
+    	retval ((row_offset+1):(row_offset+nr(K)), 1:nc(K)) = char (s);
       endif
       row_offset = row_offset + nr(K);
     endif
   endfor
 
 endfunction
 
 %!shared s1,s2,s3,s4,c
