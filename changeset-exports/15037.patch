# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1343423425 14400
#      Fri Jul 27 17:10:25 2012 -0400
# Branch classdef
# Node ID 56b8eb7c9c043f069867116f4df79c70dd31322a
# Parent  aa1f9e479c6e54f7b17453a633b7f2f963092910
improvements in parsing classdef

* liboctave/base-list.h (octave_base_list::octave_base_list (void),
octave_base_list::octave_base_list (const std::list<elt_type>&),
octave_base_list::operator = (const octave_base_list&),
octave_base_list::~octave_base_list (void)):
Now public.

* pt-classdef.h, pt-classdef.cc: New files.
* src/Makefile.am (PT_INCLUDES): Add pt-classdef.h to the list.
(PT_SRC): Add pt-classdef.cc to the list.
* pt-all.h: Include pt-classdef.h.
* ov.cc: Include ov-classdef.h.
* ov-classdef.cc: Include pt-classdef.h.
(cdef_class:make_meta_class): New method.
(F__meta_get_class__): Delete.
(F__superclass_reference__, F__meta_class_query__):
New functions.
* pt-id.h: Include oct-lvalue.h.
* pt-walk.h (tree_walker::visit_classdef (tree_classdef&),
tree_walker::visit_classdef_attribute (tree_classdef_attribute&),
tree_walker::visit_classdef_attribute_list (tree_classdef_attribute_list&),
tree_walker::visit_classdef_superclass (tree_classdef_superclass&),
tree_walker::visit_classdef_superclass_list (tree_classdef_superclass_list&),
tree_walker::visit_classdef_property (tree_classdef_property&),
tree_walker::visit_classdef_property_list (tree_classdef_property_list&),
tree_walker::visit_classdef_properties_block (tree_classdef_properties_block&),
tree_walker::visit_classdef_methods_list (tree_classdef_methods_list&),
tree_walker::visit_classdef_methods_block (tree_classdef_methods_block&),
tree_walker::visit_classdef_event (tree_classdef_event&),
tree_walker::visit_classdef_events_list (tree_classdef_events_list&),
tree_walker::visit_classdef_events_block (tree_classdef_events_block&),
tree_walker::visit_classdef_enum (tree_classdef_enum&),
tree_walker::visit_classdef_enum_list (tree_classdef_enum_list&),
tree_walker::visit_classdef_enum_block (tree_classdef_enum_block&),
tree_walker::visit_classdef_body (tree_classdef_body&)):
New virtual functions.
* token.h, token.cc (token::sc::mr, token::sc::cr, token::sc::pr,
token::mc::mr, token::mc::pr): Delete.
(token::sc::method_name, token::sc::package_name, token::sc::class_name,
token::mc::package_name, token::mc::class_name): New member variables.
(token::method_rec, token::class_rec, token::package_rec,
token::meta_class_rec, token::meta_package_rec): Delete.
(token::superclass_method_name, token::superclass_package_name,
token::superclass_class_name, token::meta_package_name,
token::meta_class_name): New methods.
(token::token (symbol_table::symbol_record*, int, int),
token::token (symbol_table::symbol_record*, symbol_table::symbol_record*, int, int),
token::token (symbol_table::symbol_record*, symbol_table::symbol_record*, symbol_table::symbol_record*, int, int)):
Delete.
(token::token (const std::string&, const std::string&, int, int),
token::token (const std::string&, const std::string&, const std::string&, int, int)):
New constructors.
(token::scls_rec_token, token::meta_rec_token): Delete enum values.
(token::scls_name_token, token::meta_rec_token): New enum values.
(token::~token): Delete sc and mc struct memebers.
* lex.ll, lex.h (lexical_feedback::parsing_classdef_get_method,
lexical_feedback::parsing_classdef_set_method)): New data members.
(lexical_feedback::lexical_feedback, lexical_feedback::init):
Initialize new data members.
(prep_lexer_for_classdef_file): New function.
(CLASSDEF_FILE_BEGIN): New exclusive start state.
(handle_superclass_identifier, handle_meta_identifier): Split
identifier here and create token with character strings.
(display_token): Handle CLASSDEF_FILE.
(display_state): Handle CLASSDEF_FILE_BEGIN.
* oct-parse.yy: Include ov-classdef.h and pt-funcall.h.
(classdef_object): New static variable.
(make_superclass_ref, make_meta_class_query, make_classdef,
make_classdef_properties_block, make_classdef_methods_block,
make_classdef_events_block, make_classdef_enum_block)): New functions.
(dummy_type): Delete unused nonterminal type.
(tok_type, tree_funcall_type, tree_function_def_type,
tree_classdef_type, tree_classdef_attribute_type,
tree_classdef_attribute_list_type, tree_classdef_superclass_type,
tree_classdef_superclass_list_type, tree_classdef_body_type,
tree_classdef_property_type, tree_classdef_property_list_type,
tree_classdef_properties_block_type, tree_classdef_methods_list_type,
tree_classdef_methods_block_type, tree_classdef_event_type,
tree_classdef_events_list_type, tree_classdef_events_block_type,
tree_classdef_enum_type, tree_classdef_enum_list_type,
tree_classdef_enum_block_type):
New types for nonterminals.
(CLASSDEF): Declare to have a tok_val token value.
(CLASSDEF_FILE): New token.
(classdef_end, properties_beg, methods_beg, events_beg, enum_beg,
classdef1): Delete nonterminals.
(property_list): Rename from properties_list.
(attr, class_event, class_enum, class_property, property_list,
properties_block, methods_list, methods_block, opt_attr_list,
attr_list, events_list, events_blcok, enum_list, enum_block,
class_body, classdef): Declare with specific types.  Create parse tree
objects for these nonterminals.
(classdef_file): New nonterminal.
(parse_fcn_file): Handle classdef files.  Don't treat classdef files
as scripts.
(command): Don't handle classdef here.
(input): Accept classdef_file here.
(fcn_name): If GET, set lexer_flags.parsing_classdef_get_method.
If SET, set lexer_flags.parsing_classdef_set_method.

diff --git a/liboctave/base-list.h b/liboctave/base-list.h
--- a/liboctave/base-list.h
+++ b/liboctave/base-list.h
@@ -82,18 +82,16 @@ public:
   void push_back (const elt_type& s) { lst.push_back (s); }
 
   void pop_front (void) { lst.pop_front (); }
   void pop_back (void) { lst.pop_back (); }
 
   // For backward compatibility.
   void append (const elt_type& s) { lst.push_back (s); }
 
-protected:
-
   octave_base_list (void) : lst () { }
 
   octave_base_list (const std::list<elt_type>& l) : lst (l) { }
 
   octave_base_list (const octave_base_list& bl) : lst (bl.lst) { }
 
   octave_base_list& operator = (const octave_base_list& bl)
     {
diff --git a/src/Makefile.am b/src/Makefile.am
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -206,16 +206,17 @@ PT_INCLUDES = \
   pt-all.h \
   pt-arg-list.h \
   pt-assign.h \
   pt-binop.h \
   pt-bp.h \
   pt-cbinop.h \
   pt-cell.h \
   pt-check.h \
+  pt-classdef.h \
   pt-cmd.h \
   pt-colon.h \
   pt-const.h \
   pt-decl.h \
   pt-eval.h \
   pt-except.h \
   pt-exp.h \
   pt-fcn-handle.h \
@@ -388,16 +389,17 @@ PT_SRC = \
   pt-arg-list.cc \
   pt-assign.cc \
   pt-binop.cc \
   pt-bp.cc \
   pt-cbinop.cc \
   pt-cell.cc \
   pt-check.cc \
   pt-cmd.cc \
+  pt-classdef.cc \
   pt-colon.cc \
   pt-const.cc \
   pt-decl.cc \
   pt-eval.cc \
   pt-except.cc \
   pt-exp.cc \
   pt-fcn-handle.cc \
   pt-funcall.cc \
diff --git a/src/lex.h b/src/lex.h
--- a/src/lex.h
+++ b/src/lex.h
@@ -47,16 +47,17 @@ extern OCTINTERP_API void clear_all_buff
 
 extern OCTINTERP_API void cleanup_parser (void);
 
 // Is the given string a keyword?
 extern bool is_keyword (const std::string& s);
 
 extern void prep_lexer_for_script_file (void);
 extern void prep_lexer_for_function_file (void);
+extern void prep_lexer_for_classdef_file (void);
 
 // For communication between the lexer and parser.
 
 class
 lexical_feedback
 {
 public:
 
@@ -67,17 +68,18 @@ public:
       defining_func (0), looking_at_function_handle (0),
       looking_at_anon_fcn_args (true),
       looking_at_return_list (false), looking_at_parameter_list (false),
       looking_at_decl_list (false), looking_at_initializer_expression (false),
       looking_at_matrix_or_assign_lhs (false), looking_at_object_index (),
       looking_for_object_index (false), do_comma_insert (false),
       looking_at_indirect_ref (false), parsed_function_name (),
       parsing_class_method (false), maybe_classdef_get_set_method (false),
-      parsing_classdef (false), quote_is_transpose (false),
+      parsing_classdef (false), parsing_classdef_get_method (false),
+      parsing_classdef_set_method (false), quote_is_transpose (false),
       pending_local_variables ()
 
     {
       init ();
     }
 
   ~lexical_feedback (void) { }
 
@@ -152,16 +154,22 @@ public:
   // TRUE means we are parsing a class method declaration line in a
   // classdef file and can accept a property get or set method name.
   // For example, "get.PropertyName" is recognized as a function name.
   bool maybe_classdef_get_set_method;
 
   // TRUE means we are parsing a classdef file
   bool parsing_classdef;
 
+  // TRUE means we are parsing a classdef get.method.
+  bool parsing_classdef_get_method;
+
+  // TRUE means we are parsing a classdef set.method.
+  bool parsing_classdef_set_method;
+
   // Return transpose or start a string?
   bool quote_is_transpose;
 
   // Set of identifiers that might be local variable names.
   std::set<std::string> pending_local_variables;
 
 private:
 
diff --git a/src/lex.ll b/src/lex.ll
--- a/src/lex.ll
+++ b/src/lex.ll
@@ -29,16 +29,17 @@ along with Octave; see the file COPYING.
 
 }
 
 %s COMMAND_START
 %s MATRIX_START
 
 %x SCRIPT_FILE_BEGIN
 %x FUNCTION_FILE_BEGIN
+%x CLASSDEF_FILE_BEGIN
 
 %{
 
 #include <cctype>
 #include <cstring>
 
 #include <iostream>
 #include <set>
@@ -368,16 +369,24 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
 <FUNCTION_FILE_BEGIN>. {
     LEXER_DEBUG ("<FUNCTION_FILE_BEGIN>.");
 
     BEGIN (INITIAL);
     xunput (yytext[0], yytext);
     COUNT_TOK_AND_RETURN (FUNCTION_FILE);
   }
 
+<CLASSDEF_FILE_BEGIN>. {
+    LEXER_DEBUG ("<CLASSDEF_FILE_BEGIN>.");
+
+    BEGIN (INITIAL);
+    xunput (yytext[0], yytext);
+    COUNT_TOK_AND_RETURN (CLASSDEF_FILE);
+  }
+
 %{
 // Help and other command-style functions.
 %}
 
 <COMMAND_START>{NL} {
     LEXER_DEBUG ("<COMMAND_START>{NL}");
 
     BEGIN (INITIAL);
@@ -751,17 +760,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
     LEXER_DEBUG ("{IDENT}@{IDENT}{S}*|{IDENT}@{IDENT}.{IDENT}{S}*");
 
     int id_tok = handle_superclass_identifier ();
 
     if (id_tok >= 0)
       {
         lexer_flags.looking_for_object_index = true;
 
-        COUNT_TOK_AND_RETURN (SUPERCLASSREF);
+        COUNT_TOK_AND_RETURN (id_tok);
       }
   }
 
 %{
 // Metaclass query
 %}
 
 \?{IDENT}{S}* |
@@ -769,17 +778,17 @@ NUMBER  (({D}+\.?{D}*{EXPON}?)|(\.{D}+{E
     LEXER_DEBUG ("\\?{IDENT}{S}*|\\?{IDENT}\\.{IDENT}{S}*");
 
     int id_tok = handle_meta_identifier ();
 
     if (id_tok >= 0)
       {
         lexer_flags.looking_for_object_index = true;
 
-        COUNT_TOK_AND_RETURN (METAQUERY);
+        COUNT_TOK_AND_RETURN (id_tok);
       }
   }
 
 %{
 // Function handles and superclass references
 %}
 
 "@" {
@@ -3147,82 +3156,87 @@ looks_like_command_arg (void)
   xunput (c0, yytext);
 
   return retval;
 }
 
 static int
 handle_superclass_identifier (void)
 {
-  eat_continuation ();
+  int c = yytext[yyleng-1];
+
+  std::string meth = strip_trailing_whitespace (yytext);
+
+  int cont_is_spc = eat_continuation ();
+
+  int spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
+
+  size_t pos = meth.find ("@");
+  std::string cls = meth.substr (pos + 1);
+  meth = meth.substr (0, pos);
 
   std::string pkg;
-  std::string meth = strip_trailing_whitespace (yytext);
-  size_t pos = meth.find ("@");
-  std::string cls = meth.substr (pos).substr (1);
-  meth = meth.substr (0, pos - 1);
-
   pos = cls.find (".");
   if (pos != std::string::npos)
     {
-      pkg = cls.substr (pos).substr (1);
-      cls = cls.substr (0, pos - 1);
+      pkg = cls.substr (0, pos);
+      cls = cls.substr (pos + 1);
     }
 
   int kw_token = (is_keyword_token (meth) || is_keyword_token (cls)
                   || is_keyword_token (pkg));
   if (kw_token)
     {
-      error ("method, class and package names may not be keywords");
+      error ("method, class, and package names may not be keywords");
       return LEXICAL_ERROR;
     }
 
-  yylval.tok_val
-    = new token (meth.empty () ? 0 : &(symbol_table::insert (meth)),
-                 cls.empty () ? 0 : &(symbol_table::insert (cls)),
-                 pkg.empty () ? 0 : &(symbol_table::insert (pkg)),
-                 input_line_number, current_input_column);
+  yylval.tok_val = new token (meth, pkg, cls, input_line_number,
+                              current_input_column);
   token_stack.push (yylval.tok_val);
 
-  lexer_flags.convert_spaces_to_comma = true;
+  do_comma_insert_check ();
+  maybe_unput_comma (spc_gobbled);
   current_input_column += yyleng;
 
   return SUPERCLASSREF;
 }
 
 static int
 handle_meta_identifier (void)
 {
-  eat_continuation ();
+  int c = yytext[yyleng-1];
+
+  std::string cls = strip_trailing_whitespace (yytext).substr (1);
+
+  int cont_is_spc = eat_continuation ();
+
+  int spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
 
   std::string pkg;
-  std::string cls = strip_trailing_whitespace (yytext).substr (1);
   size_t pos = cls.find (".");
-
   if (pos != std::string::npos)
     {
-      pkg = cls.substr (pos).substr (1);
-      cls = cls.substr (0, pos - 1);
+      pkg = cls.substr (0, pos);
+      cls = cls.substr (pos + 1);
     }
 
   int kw_token = is_keyword_token (cls) || is_keyword_token (pkg);
   if (kw_token)
     {
-       error ("class and package names may not be keywords");
+      error ("class and package names may not be keywords");
       return LEXICAL_ERROR;
     }
 
-  yylval.tok_val
-    = new token (cls.empty () ? 0 : &(symbol_table::insert (cls)),
-                 pkg.empty () ? 0 : &(symbol_table::insert (pkg)),
-                 input_line_number, current_input_column);
-
+  yylval.tok_val = new token (pkg, cls, input_line_number,
+                              current_input_column);
   token_stack.push (yylval.tok_val);
 
-  lexer_flags.convert_spaces_to_comma = true;
+  do_comma_insert_check ();
+  maybe_unput_comma (spc_gobbled);
   current_input_column += yyleng;
 
   return METAQUERY;
 }
 
 // Figure out exactly what kind of token to return when we have seen
 // an identifier.  Handles keywords.  Return -1 if the identifier
 // should be ignored.
@@ -3417,16 +3431,18 @@ lexical_feedback::init (void)
   while (! parsed_function_name.empty ())
     parsed_function_name.pop ();
 
   parsing_class_method = false;
 
   // Not initially defining a class with classdef.
   maybe_classdef_get_set_method = false;
   parsing_classdef = false;
+  parsing_classdef_get_method = false;
+  parsing_classdef_set_method = false;
 
   // Not initiallly looking at a function handle.
   looking_at_function_handle = 0;
 
   // Not initiallly looking at an anonymous function argument list.
   looking_at_anon_fcn_args = 0;
 
   // Not parsing a function return, parameter, or declaration list.
@@ -3545,16 +3561,22 @@ prep_lexer_for_script_file (void)
 }
 
 void
 prep_lexer_for_function_file (void)
 {
   BEGIN (FUNCTION_FILE_BEGIN);
 }
 
+void
+prep_lexer_for_classdef_file (void)
+{
+  BEGIN (CLASSDEF_FILE_BEGIN);
+}
+
 static void
 maybe_warn_separator_insert (char sep)
 {
   std::string nm = curr_fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:separator-insert",
                      "potential auto-insertion of `%c' near line %d",
@@ -3717,16 +3739,17 @@ display_token (int tok)
     case PERSISTENT: std::cerr << "PERSISTENT\n"; break;
     case FCN_HANDLE: std::cerr << "FCN_HANDLE\n"; break;
     case END_OF_INPUT: std::cerr << "END_OF_INPUT\n\n"; break;
     case LEXICAL_ERROR: std::cerr << "LEXICAL_ERROR\n\n"; break;
     case FCN: std::cerr << "FCN\n"; break;
     case CLOSE_BRACE: std::cerr << "CLOSE_BRACE\n"; break;
     case SCRIPT_FILE: std::cerr << "SCRIPT_FILE\n"; break;
     case FUNCTION_FILE: std::cerr << "FUNCTION_FILE\n"; break;
+    case CLASSDEF_FILE: std::cerr << "CLASSDEF_FILE\n"; break;
     case SUPERCLASSREF: std::cerr << "SUPERCLASSREF\n"; break;
     case METAQUERY: std::cerr << "METAQUERY\n"; break;
     case GET: std::cerr << "GET\n"; break;
     case SET: std::cerr << "SET\n"; break;
     case PROPERTIES: std::cerr << "PROPERTIES\n"; break;
     case METHODS: std::cerr << "METHODS\n"; break;
     case EVENTS: std::cerr << "EVENTS\n"; break;
     case CLASSDEF: std::cerr << "CLASSDEF\n"; break;
@@ -3766,16 +3789,20 @@ display_state (void)
     case SCRIPT_FILE_BEGIN:
       std::cerr << "SCRIPT_FILE_BEGIN" << std::endl;
       break;
 
     case FUNCTION_FILE_BEGIN:
       std::cerr << "FUNCTION_FILE_BEGIN" << std::endl;
       break;
 
+    case CLASSDEF_FILE_BEGIN:
+      std::cerr << "CLASSDEF_FILE_BEGIN" << std::endl;
+      break;
+
     default:
       std::cerr << "UNKNOWN START STATE!" << std::endl;
       break;
     }
 }
 
 static void
 lexer_debug (const char *pattern, const char *text)
diff --git a/src/oct-parse.yy b/src/oct-parse.yy
--- a/src/oct-parse.yy
+++ b/src/oct-parse.yy
@@ -57,25 +57,27 @@ along with Octave; see the file COPYING.
 #include "dirfns.h"
 #include "dynamic-ld.h"
 #include "error.h"
 #include "input.h"
 #include "lex.h"
 #include "load-path.h"
 #include "oct-hist.h"
 #include "oct-map.h"
+#include "ov-classdef.h"
 #include "ov-fcn-handle.h"
 #include "ov-usr-fcn.h"
 #include "ov-null-mat.h"
 #include "toplev.h"
 #include "pager.h"
 #include "parse.h"
 #include "parse-private.h"
 #include "pt-all.h"
 #include "pt-eval.h"
+#include "pt-funcall.h"
 #include "symtab.h"
 #include "token.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 #if defined (GNULIB_NAMESPACE)
 // Calls to the following functions appear in the generated output from
@@ -147,16 +149,19 @@ static bool fcn_file_from_relative_looku
 
 // Pointer to the primary user function or user script function.
 static octave_function *primary_fcn_ptr = 0;
 
 // Scope where we install all subfunctions and nested functions. Only
 // used while reading function files.
 static symbol_table::scope_id primary_fcn_scope;
 
+// Pointer to the classdef object we just parsed, if any.
+static tree_classdef *classdef_object = 0;
+
 // List of autoloads (function -> file mapping).
 static std::map<std::string, std::string> autoload_map;
 
 // Forward declarations for some functions defined at the bottom of
 // the file.
 
 // Generic error messages.
 static void
@@ -351,16 +356,57 @@ set_stmt_print_flag (tree_statement_list
 // Create a statement list.
 static tree_statement_list *make_statement_list (tree_statement *stmt);
 
 // Append a statement to an existing statement list.
 static tree_statement_list *
 append_statement_list (tree_statement_list *list, char sep,
                        tree_statement *stmt, bool warn_missing_semi);
 
+static tree_funcall *
+make_superclass_ref (const std::string& method_nm,
+                     const std::string& package_nm,
+                     const std::string& class_nm,
+                     int l, int c);
+
+static tree_funcall *
+make_meta_class_query (const std::string& package_nm,
+                       const std::string& class_nm,
+                       int l, int c);
+
+static tree_classdef *
+make_classdef (token *tok_val, tree_classdef_attribute_list *a,
+               tree_identifier *id, tree_classdef_superclass_list *sc,
+               tree_classdef_body *body, token *end_tok,
+               octave_comment_list *lc);
+
+static tree_classdef_properties_block *
+make_classdef_properties_block (token *tok_val,
+                                tree_classdef_attribute_list *a,
+                                tree_classdef_property_list *plist,
+                                token *end_tok, octave_comment_list *lc);
+
+static tree_classdef_methods_block *
+make_classdef_methods_block (token *tok_val,
+                             tree_classdef_attribute_list *a,
+                             tree_classdef_methods_list *mlist,
+                             token *end_tok, octave_comment_list *lc);
+
+static tree_classdef_events_block *
+make_classdef_events_block (token *tok_val,
+                            tree_classdef_attribute_list *a,
+                            tree_classdef_events_list *elist,
+                            token *end_tok, octave_comment_list *lc);
+
+static tree_classdef_enum_block *
+make_classdef_enum_block (token *tok_val,
+                          tree_classdef_attribute_list *a,
+                          tree_classdef_enum_list *elist,
+                          token *end_tok, octave_comment_list *lc);
+
 // Finish building a statement.
 template <class T>
 static tree_statement *
 make_statement (T *arg)
 {
   octave_comment_list *comment = octave_comment_buffer::get_comment ();
 
   return new tree_statement (arg, comment);
@@ -395,22 +441,25 @@ make_statement (T *arg)
   // The type of the basic tokens returned by the lexer.
   token *tok_val;
 
   // Comment strings that we need to deal with mid-rule.
   octave_comment_list *comment_type;
 
   // Types for the nonterminals we generate.
   char sep_type;
+  token *tok_type;
   tree *tree_type;
   tree_matrix *tree_matrix_type;
   tree_cell *tree_cell_type;
   tree_expression *tree_expression_type;
   tree_constant *tree_constant_type;
   tree_fcn_handle *tree_fcn_handle_type;
+  tree_funcall *tree_funcall_type;
+  tree_function_def *tree_function_def_type;
   tree_anon_fcn_handle *tree_anon_fcn_handle_type;
   tree_identifier *tree_identifier_type;
   tree_index_expression *tree_index_expression_type;
   tree_colon_expression *tree_colon_expression_type;
   tree_argument_list *tree_argument_list_type;
   tree_parameter_list *tree_parameter_list_type;
   tree_command *tree_command_type;
   tree_if_command *tree_if_command_type;
@@ -420,17 +469,34 @@ make_statement (T *arg)
   tree_switch_case *tree_switch_case_type;
   tree_switch_case_list *tree_switch_case_list_type;
   tree_decl_elt *tree_decl_elt_type;
   tree_decl_init_list *tree_decl_init_list_type;
   tree_decl_command *tree_decl_command_type;
   tree_statement *tree_statement_type;
   tree_statement_list *tree_statement_list_type;
   octave_user_function *octave_user_function_type;
-  void *dummy_type;
+
+  tree_classdef *tree_classdef_type;
+  tree_classdef_attribute* tree_classdef_attribute_type;
+  tree_classdef_attribute_list* tree_classdef_attribute_list_type;
+  tree_classdef_superclass* tree_classdef_superclass_type;
+  tree_classdef_superclass_list* tree_classdef_superclass_list_type;
+  tree_classdef_body* tree_classdef_body_type;
+  tree_classdef_property* tree_classdef_property_type;
+  tree_classdef_property_list* tree_classdef_property_list_type;
+  tree_classdef_properties_block* tree_classdef_properties_block_type;
+  tree_classdef_methods_list* tree_classdef_methods_list_type;
+  tree_classdef_methods_block* tree_classdef_methods_block_type;
+  tree_classdef_event* tree_classdef_event_type;
+  tree_classdef_events_list* tree_classdef_events_list_type;
+  tree_classdef_events_block* tree_classdef_events_block_type;
+  tree_classdef_enum* tree_classdef_enum_type;
+  tree_classdef_enum_list* tree_classdef_enum_list_type;
+  tree_classdef_enum_block* tree_classdef_enum_block_type;
 }
 
 // Tokens with line and column information.
 %token <tok_val> '=' ':' '-' '+' '*' '/'
 %token <tok_val> ADD_EQ SUB_EQ MUL_EQ DIV_EQ LEFTDIV_EQ POW_EQ
 %token <tok_val> EMUL_EQ EDIV_EQ ELEFTDIV_EQ EPOW_EQ AND_EQ OR_EQ
 %token <tok_val> LSHIFT_EQ RSHIFT_EQ LSHIFT RSHIFT
 %token <tok_val> EXPR_AND_AND EXPR_OR_OR
@@ -447,82 +513,85 @@ make_statement (T *arg)
 %token <tok_val> FOR PARFOR WHILE DO UNTIL
 %token <tok_val> IF ELSEIF ELSE
 %token <tok_val> SWITCH CASE OTHERWISE
 %token <tok_val> BREAK CONTINUE FUNC_RET
 %token <tok_val> UNWIND CLEANUP
 %token <tok_val> TRY CATCH
 %token <tok_val> GLOBAL PERSISTENT
 %token <tok_val> FCN_HANDLE
+%token <tok_val> CLASSDEF
 %token <tok_val> PROPERTIES METHODS EVENTS ENUMERATION
 %token <tok_val> METAQUERY
 %token <tok_val> SUPERCLASSREF
 %token <tok_val> GET SET
 
 // Other tokens.
 %token END_OF_INPUT LEXICAL_ERROR
-%token FCN SCRIPT_FILE FUNCTION_FILE CLASSDEF
+%token FCN SCRIPT_FILE CLASSDEF_FILE FUNCTION_FILE
 // %token VARARGIN VARARGOUT
 %token CLOSE_BRACE
 
 // Nonterminals we construct.
-%type <comment_type> stash_comment function_beg classdef_beg
-%type <comment_type> properties_beg methods_beg events_beg enum_beg
+%type <comment_type> stash_comment function_beg
+%type <tok_type> classdef_beg
 %type <sep_type> sep_no_nl opt_sep_no_nl sep opt_sep opt_comma
 %type <tree_type> input
 %type <tree_constant_type> string constant magic_colon
 %type <tree_anon_fcn_handle_type> anon_fcn_handle
 %type <tree_fcn_handle_type> fcn_handle
 %type <tree_matrix_type> matrix_rows matrix_rows1
 %type <tree_cell_type> cell_rows cell_rows1
 %type <tree_expression_type> matrix cell
 %type <tree_expression_type> primary_expr oper_expr
 %type <tree_expression_type> simple_expr colon_expr assign_expr expression
 %type <tree_identifier_type> identifier fcn_name magic_tilde
-%type <tree_identifier_type> superclass_identifier meta_identifier
-%type <octave_user_function_type> function1 function2 classdef1
+%type <tree_funcall_type> superclass_identifier meta_identifier
+%type <octave_user_function_type> function1 function2
 %type <tree_index_expression_type> word_list_cmd
 %type <tree_colon_expression_type> colon_expr1
 %type <tree_argument_list_type> arg_list word_list assign_lhs
 %type <tree_argument_list_type> cell_or_matrix_row
 %type <tree_parameter_list_type> param_list param_list1 param_list2
 %type <tree_parameter_list_type> return_list return_list1
-%type <tree_parameter_list_type> superclasses opt_superclasses
 %type <tree_command_type> command select_command loop_command
-%type <tree_command_type> jump_command except_command function
-%type <tree_command_type> script_file classdef
+%type <tree_command_type> jump_command except_command
+%type <tree_function_def_type> function
+%type <tree_classdef_type> classdef
+%type <tree_command_type> script_file classdef_file
 %type <tree_command_type> function_file function_list
 %type <tree_if_command_type> if_command
 %type <tree_if_clause_type> elseif_clause else_clause
 %type <tree_if_command_list_type> if_cmd_list1 if_cmd_list
 %type <tree_switch_command_type> switch_command
 %type <tree_switch_case_type> switch_case default_case
 %type <tree_switch_case_list_type> case_list1 case_list
 %type <tree_decl_elt_type> decl2
 %type <tree_decl_init_list_type> decl1
 %type <tree_decl_command_type> declaration
-%type <tree_statement_type> statement function_end classdef_end
+%type <tree_statement_type> statement function_end
 %type <tree_statement_list_type> simple_list simple_list1 list list1
 %type <tree_statement_list_type> opt_list input1
-// These types need to be specified.
-%type <dummy_type> attr
-%type <dummy_type> class_event
-%type <dummy_type> class_enum
-%type <dummy_type> class_property
-%type <dummy_type> properties_list
-%type <dummy_type> properties_block
-%type <dummy_type> methods_list
-%type <dummy_type> methods_block
-%type <dummy_type> opt_attr_list
-%type <dummy_type> attr_list
-%type <dummy_type> events_list
-%type <dummy_type> events_block
-%type <dummy_type> enum_list
-%type <dummy_type> enum_block
-%type <dummy_type> class_body
+
+%type <tree_classdef_attribute_type> attr
+%type <tree_classdef_attribute_list_type> attr_list opt_attr_list
+%type <tree_classdef_superclass_type> superclass
+%type <tree_classdef_superclass_list_type> superclass_list opt_superclass_list
+%type <tree_classdef_body_type> class_body
+%type <tree_classdef_property_type> class_property
+%type <tree_classdef_property_list_type> property_list
+%type <tree_classdef_properties_block_type> properties_block
+%type <tree_classdef_methods_list_type> methods_list
+%type <tree_classdef_methods_block_type> methods_block
+%type <tree_classdef_event_type> class_event
+%type <tree_classdef_events_list_type> events_list
+%type <tree_classdef_events_block_type> events_block
+%type <tree_classdef_enum_type> class_enum
+%type <tree_classdef_enum_list_type> enum_list
+%type <tree_classdef_enum_block_type> enum_block
 
 // Precedence and associativity.
 %right '=' ADD_EQ SUB_EQ MUL_EQ DIV_EQ LEFTDIV_EQ POW_EQ EMUL_EQ EDIV_EQ ELEFTDIV_EQ EPOW_EQ OR_EQ AND_EQ LSHIFT_EQ RSHIFT_EQ
 %left EXPR_OR_OR
 %left EXPR_AND_AND
 %left EXPR_OR
 %left EXPR_AND
 %left EXPR_LT EXPR_LE EXPR_EQ EXPR_NE EXPR_GE EXPR_GT
@@ -547,16 +616,18 @@ make_statement (T *arg)
 input           : input1
                   {
                     global_command = $1;
                     promptflag = 1;
                     YYACCEPT;
                   }
                 | function_file
                   { YYACCEPT; }
+                | classdef_file
+                  { YYACCEPT; }
                 | simple_list parse_error
                   { ABORT_PARSE; }
                 | parse_error
                   { ABORT_PARSE; }
                 ;
 
 input1          : '\n'
                   { $$ = 0; }
@@ -636,21 +707,34 @@ identifier      : NAME
                   {
                     symbol_table::symbol_record *sr = $1->sym_rec ();
                     $$ = new tree_identifier (*sr, $1->line (), $1->column ());
                   }
                 ;
 
 superclass_identifier
                 : SUPERCLASSREF
-                  { $$ = new tree_identifier ($1->line (), $1->column ()); }
+                  {
+                    std::string method_nm = $1->superclass_method_name ();
+                    std::string package_nm = $1->superclass_package_name ();
+                    std::string class_nm = $1->superclass_class_name ();
+
+                    $$ = make_superclass_ref (method_nm, package_nm, class_nm,
+                                              $1->line (), $1->column ());
+                  }
                 ;
 
 meta_identifier : METAQUERY
-                  { $$ = new tree_identifier ($1->line (), $1->column ()); }
+                  {
+                    std::string package_nm = $1->meta_package_name ();
+                    std::string class_nm = $1->meta_class_name ();
+
+                    $$ = make_meta_class_query (package_nm, class_nm,
+                                                $1->line (), $1->column ());
+                  }
                 ;
 
 string          : DQ_STRING
                   { $$ = make_constant (DQ_STRING, $1); }
                 | SQ_STRING
                   { $$ = make_constant (SQ_STRING, $1); }
                 ;
 
@@ -979,18 +1063,16 @@ command         : declaration
                 | jump_command
                   { $$ = $1; }
                 | except_command
                   { $$ = $1; }
                 | function
                   { $$ = $1; }
                 | script_file
                   { $$ = $1; }
-                | classdef
-                  { $$ = $1; }
                 ;
 
 // =====================
 // Declaration statemnts
 // =====================
 
 parsing_decl_list
                 : // empty
@@ -1399,22 +1481,24 @@ fcn_name        : identifier
                     lexer_flags.maybe_classdef_get_set_method = false;
 
                     $$ = $1;
                   }
                 | GET '.' identifier
                   {
                     lexer_flags.parsed_function_name.top () = true;
                     lexer_flags.maybe_classdef_get_set_method = false;
+                    lexer_flags.parsing_classdef_get_method = true;
                     $$ = $3;
                   }
                 | SET '.' identifier
                   {
                     lexer_flags.parsed_function_name.top () = true;
                     lexer_flags.maybe_classdef_get_set_method = false;
+                    lexer_flags.parsing_classdef_set_method = true;
                     $$ = $3;
                   }
                 ;
 
 function1       : fcn_name function2
                   {
                     std::string fname = $1->name ();
 
@@ -1469,171 +1553,221 @@ function_end    : END
                         YYABORT;
                       }
 
                     $$ = make_end ("endfunction", input_line_number,
                                    current_input_column);
                   }
                 ;
 
+// =============
+// Classdef file
+// =============
+
+classdef_file   : CLASSDEF_FILE classdef opt_sep END_OF_INPUT
+                  {
+                    classdef_object = $2;
+                    $$ = 0;
+                  }
+                ;
+
 // ========
 // Classdef
 // ========
 
-classdef_beg    : CLASSDEF stash_comment
+classdef_beg    : CLASSDEF
                   {
-                    $$ = 0;
+                    if (! reading_classdef_file)
+                      {
+                        yyerror ("classdef must appear inside a file containing only a class definition");
+                        YYABORT;
+                      }
+
                     lexer_flags.parsing_classdef = true;
+                    $$ = $1;
                   }
                 ;
 
-classdef_end    : END
+classdef        : classdef_beg stash_comment opt_attr_list identifier opt_superclass_list opt_sep class_body opt_sep END
                   {
                     lexer_flags.parsing_classdef = false;
-
-                    if (end_token_ok ($1, token::classdef_end))
-                      $$ = make_end ("endclassdef", $1->line (), $1->column ());
-                    else
-                      ABORT_PARSE;
+                    $$ = make_classdef ($1, $3, $4, $5, $7, $9, $2);
                   }
                 ;
 
-classdef1       : classdef_beg opt_attr_list identifier opt_superclasses
-                  { $$ = 0; }
-                ;
-
-classdef        : classdef1 opt_sep class_body opt_sep stash_comment classdef_end
-                  { $$ = 0; }
-                ;
-
 opt_attr_list   : // empty
                   { $$ = 0; }
                 | '(' attr_list ')'
-                  { $$ = 0; }
+                  { $$ = $2; }
                 ;
 
 attr_list       : attr
-                  { $$ = 0; }
+                  { $$ = new tree_classdef_attribute_list ($1); }
                 | attr_list ',' attr
-                  { $$ = 0; }
+                  {
+                    $1->append ($3);
+                    $$ = $1;
+                  }
                 ;
 
 attr            : identifier
-                  { $$ = 0; }
+                  { $$ = new tree_classdef_attribute ($1); }
                 | identifier '=' decl_param_init expression
-                  { $$ = 0; }
+                  {
+                    lexer_flags.looking_at_initializer_expression = false;
+                    $$ = new tree_classdef_attribute ($1, $4);
+                  }
                 | EXPR_NOT identifier
-                  { $$ = 0; }
+                  { $$ = new tree_classdef_attribute ($2, false); }
                 ;
 
-opt_superclasses
+opt_superclass_list
                 : // empty
                   { $$ = 0; }
-                | superclasses
-                  { $$ = 0; }
+                | superclass_list
+                  { $$ = $1; }
                 ;
 
-superclasses    : EXPR_LT identifier '.' identifier
-                  { $$ = 0; }
-                | EXPR_LT identifier
-                  { $$ = 0; }
-                | superclasses EXPR_AND identifier '.' identifier
-                  { $$ = 0; }
-                | superclasses EXPR_AND identifier
-                  { $$ = 0; }
+superclass_list : EXPR_LT superclass
+                  { $$ = new tree_classdef_superclass_list ($2); }
+                | superclass_list EXPR_AND superclass
+                  {
+                    $1->append ($3);
+                    $$ = $1;
+                  }
+                ;
+
+superclass      : identifier
+                  { $$ = new tree_classdef_superclass ($1); }
+                | identifier '.' identifier
+                  { $$ = new tree_classdef_superclass ($3, $1); }
                 ;
 
 class_body      : properties_block
-                  { $$ = 0; }
+                  { $$ = new tree_classdef_body ($1); }
                 | methods_block
-                  { $$ = 0; }
+                  { $$ = new tree_classdef_body ($1); }
                 | events_block
-                  { $$ = 0; }
+                  { $$ = new tree_classdef_body ($1); }
                 | enum_block
-                  { $$ = 0; }
+                  { $$ = new tree_classdef_body ($1); }
                 | class_body opt_sep properties_block
-                  { $$ = 0; }
+                  {
+                    $1->append ($3);
+                    $$ = $1;
+                  }
                 | class_body opt_sep methods_block
-                  { $$ = 0; }
+                  {
+                    $1->append ($3);
+                    $$ = $1;
+                  }
                 | class_body opt_sep events_block
-                  { $$ = 0; }
+                  {
+                    $1->append ($3);
+                    $$ = $1;
+                  }
                 | class_body opt_sep enum_block
-                  { $$ = 0; }
-                ;
-
-properties_beg  : PROPERTIES stash_comment
-                  { $$ = 0; }
+                  {
+                    $1->append ($3);
+                    $$ = $1;
+                  }
                 ;
 
 properties_block
-                : properties_beg opt_attr_list opt_sep properties_list opt_sep END
-                  { $$ = 0; }
+                : PROPERTIES stash_comment opt_attr_list opt_sep property_list opt_sep END
+                  {
+                    if (! ($$ = make_classdef_properties_block ($1, $3, $5, $7, $2)))
+                      ABORT_PARSE;
+                  }
                 ;
 
-properties_list
+property_list
                 : class_property
-                  { $$ = 0; }
-                | properties_list opt_sep class_property
-                  { $$ = 0; }
+                  { $$ = new tree_classdef_property_list ($1); }
+                | property_list opt_sep class_property
+                  {
+                    $1->append ($3);
+                    $$ = $1;
+                  }
                 ;
 
 class_property  : identifier
-                  { $$ = 0; }
+                  { $$ = new tree_classdef_property ($1); }
                 | identifier '=' decl_param_init expression ';'
-                  { $$ = 0; }
+                  {
+                    lexer_flags.looking_at_initializer_expression = false;
+                    $$ = new tree_classdef_property ($1, $4);
+                  }
                 ;
 
-methods_beg     : METHODS stash_comment
-                  { $$ = 0; }
-                ;
-
-methods_block   : methods_beg opt_attr_list opt_sep methods_list opt_sep END
-                  { $$ = 0; }
+methods_block   : METHODS stash_comment opt_attr_list opt_sep methods_list opt_sep END
+                  {
+                    if (! ($$ = make_classdef_methods_block ($1, $3, $5, $7, $2)))
+                      ABORT_PARSE;
+                  }
                 ;
 
 methods_list    : function
-                  { $$ = 0; }
+                  {
+                    octave_value fcn;
+                    if ($1)
+                      fcn = $1->function ();
+                    delete $1;
+                    $$ = new tree_classdef_methods_list (fcn);
+                  }
                 | methods_list opt_sep function
-                  { $$ = 0; }
+                  {
+                    octave_value fcn;
+                    if ($3)
+                      fcn = $3->function ();
+                    delete $3;
+
+                    $1->append (fcn);
+                    $$ = $1;
+                  }
                 ;
 
-events_beg      : EVENTS stash_comment
-                  { $$ = 0; }
-                ;
-
-events_block    : events_beg opt_attr_list opt_sep events_list opt_sep END
-                  { $$ = 0; }
+events_block    : EVENTS stash_comment opt_attr_list opt_sep events_list opt_sep END
+                  {
+                    if (! ($$ = make_classdef_events_block ($1, $3, $5, $7, $2)))
+                      ABORT_PARSE;
+                  }
                 ;
 
 events_list     : class_event
-                  { $$ = 0; }
+                  { $$ = new tree_classdef_events_list ($1); }
                 | events_list opt_sep class_event
-                  { $$ = 0; }
+                  {
+                    $1->append ($3);
+                    $$ = $1;
+                  }
                 ;
 
 class_event     : identifier
-                  { $$ = 0; }
+                  { $$ = new tree_classdef_event ($1); }
                 ;
 
-enum_beg        : ENUMERATION stash_comment
-                  { $$ = 0; }
-                ;
-
-enum_block      : enum_beg opt_attr_list opt_sep enum_list opt_sep END
-                  { $$ = 0; }
+enum_block      : ENUMERATION stash_comment opt_attr_list opt_sep enum_list opt_sep END
+                  {
+                    if (! ($$ = make_classdef_enum_block ($1, $3, $5, $7, $2)))
+                      ABORT_PARSE;
+                  }
                 ;
 
 enum_list       : class_enum
-                  { $$ = 0; }
+                  { $$ = new tree_classdef_enum_list ($1); }
                 | enum_list opt_sep class_enum
-                  { $$ = 0; }
+                  {
+                    $1->append ($3);
+                    $$ = $1;
+                  }
                 ;
 
 class_enum      : identifier '(' expression ')'
-                  { $$ = 0; }
+                  { $$ = new tree_classdef_enum ($1, $3); }
                 ;
 
 // =============
 // Miscellaneous
 // =============
 
 stash_comment   : // empty
                   { $$ = octave_comment_buffer::get_comment (); }
@@ -3263,16 +3397,161 @@ append_statement_list (tree_statement_li
 {
   set_stmt_print_flag (list, sep, warn_missing_semi);
 
   list->append (stmt);
 
   return list;
 }
 
+static tree_funcall *
+make_superclass_ref (const std::string& method_nm,
+                     const std::string& package_nm,
+                     const std::string& class_nm,
+                     int l, int c)
+{
+  octave_value_list args;
+
+  args(2) = class_nm;
+  args(1) = package_nm;
+  args(0) = method_nm;
+
+  octave_value fcn
+    = symbol_table::find_built_in_function ("__superclass_reference__");
+
+  return new tree_funcall (fcn, args);
+}
+
+static tree_funcall *
+make_meta_class_query (const std::string& package_nm,
+                       const std::string& class_nm,
+                       int l, int c)
+{
+  octave_value_list args;
+
+  args(1) = class_nm;
+  args(0) = package_nm;
+
+  octave_value fcn
+    = symbol_table::find_built_in_function ("__meta_class_query__");
+
+  return new tree_funcall (fcn, args);
+}
+
+// A CLASSDEF block defines a class that has a constructor and other
+// methods, but it is not an executable command.  Parsing the block
+// makes some changes in the symbol table (inserting the constructor
+// and methods, and adding to the list of known objects) and creates
+// a parse tree containing meta information about the class.
+
+static tree_classdef *
+make_classdef (token *tok_val, tree_classdef_attribute_list *a,
+               tree_identifier *id, tree_classdef_superclass_list *sc,
+               tree_classdef_body *body, token *end_tok,
+               octave_comment_list *lc)
+{
+  tree_classdef *retval = 0;
+
+  if (end_token_ok (end_tok, token::classdef_end))
+    {
+      octave_comment_list *tc = octave_comment_buffer::get_comment ();
+
+      int l = tok_val->line ();
+      int c = tok_val->column ();
+
+      retval = new tree_classdef (a, id, sc, body, lc, tc, l, c);
+    }
+
+  return retval;
+}
+
+static tree_classdef_properties_block *
+make_classdef_properties_block (token *tok_val,
+                                tree_classdef_attribute_list *a,
+                                tree_classdef_property_list *plist,
+                                token *end_tok, octave_comment_list *lc)
+{
+  tree_classdef_properties_block *retval = 0;
+
+  if (end_token_ok (end_tok, token::properties_end))
+    {
+      octave_comment_list *tc = octave_comment_buffer::get_comment ();
+
+      int l = tok_val->line ();
+      int c = tok_val->column ();
+
+      retval = new tree_classdef_properties_block (a, plist, lc, tc, l, c);
+    }
+
+  return retval;
+}
+
+static tree_classdef_methods_block *
+make_classdef_methods_block (token *tok_val,
+                             tree_classdef_attribute_list *a,
+                             tree_classdef_methods_list *mlist,
+                             token *end_tok, octave_comment_list *lc)
+{
+  tree_classdef_methods_block *retval = 0;
+
+  if (end_token_ok (end_tok, token::methods_end))
+    {
+      octave_comment_list *tc = octave_comment_buffer::get_comment ();
+
+      int l = tok_val->line ();
+      int c = tok_val->column ();
+
+      retval = new tree_classdef_methods_block (a, mlist, lc, tc, l, c);
+    }
+
+  return retval;
+}
+
+static tree_classdef_events_block *
+make_classdef_events_block (token *tok_val,
+                            tree_classdef_attribute_list *a,
+                            tree_classdef_events_list *elist,
+                            token *end_tok, octave_comment_list *lc)
+{
+  tree_classdef_events_block *retval = 0;
+
+  if (end_token_ok (end_tok, token::events_end))
+    {
+      octave_comment_list *tc = octave_comment_buffer::get_comment ();
+
+      int l = tok_val->line ();
+      int c = tok_val->column ();
+
+      retval = new tree_classdef_events_block (a, elist, lc, tc, l, c);
+    }
+
+  return retval;
+}
+
+static tree_classdef_enum_block *
+make_classdef_enum_block (token *tok_val,
+                          tree_classdef_attribute_list *a,
+                          tree_classdef_enum_list *elist,
+                          token *end_tok, octave_comment_list *lc)
+{
+  tree_classdef_enum_block *retval = 0;
+
+  if (end_token_ok (end_tok, token::enumeration_end))
+    {
+      octave_comment_list *tc = octave_comment_buffer::get_comment ();
+
+      int l = tok_val->line ();
+      int c = tok_val->column ();
+
+      retval = new tree_classdef_enum_block (a, elist, lc, tc, l, c);
+    }
+
+  return retval;
+}
+
 static void
 safe_fclose (FILE *f)
 {
   // FIXME -- comments at the end of an input file are
   // discarded (otherwise, they would be appended to the next
   // statement, possibly from the command line or another file, which
   // can be quite confusing).
 
@@ -3541,21 +3820,17 @@ parse_fcn_file (const std::string& ff, c
           else if (! force_script && looking_at_classdef_keyword (ffile))
             {
               file_type = "classdef";
 
               Vecho_executing_commands = ECHO_OFF;
 
               reading_classdef_file = true;
               reading_fcn_file = false;
-              // FIXME -- Should classdef files be handled as
-              // scripts or separately?  Currently, without setting up
-              // for reading script files, parsing classdef files
-              // fails.
-              reading_script_file = true;
+              reading_script_file = false;
             }
           else
             {
               file_type = "script";
 
               Vecho_executing_commands = ECHO_OFF;
 
               reading_classdef_file = false;
@@ -3569,29 +3844,34 @@ parse_fcn_file (const std::string& ff, c
           frame.add_fcn (switch_to_buffer, old_buf);
           frame.add_fcn (delete_buffer, new_buf);
 
           switch_to_buffer (new_buf);
 
           frame.protect_var (primary_fcn_ptr);
           primary_fcn_ptr = 0;
 
+          frame.protect_var (classdef_object);
+          classdef_object = 0;
+
           reset_parser ();
 
           // Do this with an unwind-protect cleanup function so that
           // the forced variables will be unmarked in the event of an
           // interrupt.
           symbol_table::scope_id scope = symbol_table::top_scope ();
           frame.add_fcn (symbol_table::unmark_forced_variables, scope);
 
           if (! help_txt.empty ())
             help_buf.push (help_txt);
 
           if (reading_script_file)
             prep_lexer_for_script_file ();
+          else if (reading_classdef_file)
+            prep_lexer_for_classdef_file ();
           else
             prep_lexer_for_function_file ();
 
           lexer_flags.parsing_class_method = ! dispatch_type.empty ();
 
           frame.protect_var (global_command);
 
           global_command = 0;
@@ -3601,19 +3881,32 @@ parse_fcn_file (const std::string& ff, c
           // Use an unwind-protect cleanup function so that the
           // global_command list will be deleted in the event of an
           // interrupt.
 
           frame.add_fcn (cleanup_statement_list, &global_command);
 
           fcn_ptr = primary_fcn_ptr;
 
-          if (status != 0)
-            error ("parse error while reading %s file %s",
-                   file_type.c_str (), ff.c_str ());
+          if (status == 0)
+            {
+              if (reading_classdef_file && classdef_object)
+                {
+                  // Convert parse tree for classdef object to
+                  // meta.class info (and stash it in the symbol
+                  // table?).  Return pointer to constructor?
+                  
+                  octave_value meta_class = classdef_object->make_meta_class ();
+                }
+            }
+          else
+            {
+              error ("parse error while reading %s file %s",
+                     file_type.c_str(), ff.c_str ());
+            }
         }
       else
         {
           tree_statement *end_of_script
             = make_end ("endscript", input_line_number, current_input_column);
 
           make_script (0, end_of_script);
 
diff --git a/src/ov-classdef.cc b/src/ov-classdef.cc
--- a/src/ov-classdef.cc
+++ b/src/ov-classdef.cc
@@ -26,16 +26,17 @@ along with Octave; see the file COPYING.
 
 #include <map>
 
 #include "defun.h"
 #include "ov-builtin.h"
 #include "ov-classdef.h"
 #include "ov-fcn-handle.h"
 #include "ov-typeinfo.h"
+#include "pt-classdef.h"
 
 static std::map<std::string, cdef_class> all_classes;
 static std::map<std::string, cdef_package> all_packages;
 
 static void
 gripe_method_access (const std::string& from, const cdef_method& meth)
 {
   error ("%s: method `%s' has %s access and cannot be run in this context",
@@ -951,16 +952,24 @@ cdef_class::cdef_class_rep::delete_objec
     {
       cdef_class cls = lookup_class (super_classes(i).string_value ());
 
       if (!error_state)
 	cls.delete_object (obj);
     }
 }
 
+cdef_class
+cdef_class::make_meta_class (const tree_classdef* t)
+{
+  cdef_class retval;
+
+  return retval;
+}
+
 octave_value
 cdef_property::cdef_property_rep::get_value (const cdef_object& obj)
 {
   // FIXME: should check whether we're already in get accessor method
 
   octave_value retval;
  
   octave_value get_fcn = get ("GetMethod");
@@ -1365,35 +1374,16 @@ install_classdef (void)
   package_meta.install_class (meta_class,       "class");
   package_meta.install_class (meta_property,    "property");
   package_meta.install_class (meta_method,      "method");
   package_meta.install_class (meta_package,     "package");
   package_meta.install_class (meta_event,       "event");
   package_meta.install_class (meta_dynproperty, "dynproperty");
 }
 
-DEFUN (__meta_get_class__, args, , "")
-{
-  octave_value retval;
-
-  if (args.length () == 1)
-    {
-      std::string cname = args(0).string_value ();
-
-      if (! error_state)
-	retval = to_ov (lookup_class (cname));
-      else
-	error ("invalid class name, expected a string value");
-    }
-  else
-    print_usage ();
-
-  return retval;
-}
-
 DEFUN (__meta_get_package__, args, , "")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       std::string cname = args(0).string_value ();
 
@@ -1403,13 +1393,62 @@ DEFUN (__meta_get_package__, args, , "")
 	error ("invalid package name, expected a string value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
+DEFUN (__superclass_reference__, args, /* nargout */,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} __superclass_reference__ ()\n\
+Undocumented internal function.\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  std::cerr << "__superclass_reference__ ("
+            << args(0).string_value () << ", "
+            << args(1).string_value () << ", "
+            << args(2).string_value () << ")"
+            << std::endl;
+
+  return retval;
+}
+
+DEFUN (__meta_class_query__, args, /* nargout */,
+  "-*- texinfo -*-\n\
+@deftypefn {Built-in Function} {} __meta_class_query__ ()\n\
+Undocumented internal function.\n\
+@end deftypefn")
+{
+  octave_value retval;
+
+  std::cerr << "__meta_class_query__ ("
+            << args(0).string_value () << ", "
+            << args(1).string_value () << ")"
+            << std::endl;
+
+  if (args.length () == 2)
+    {
+      std::string pkg = args(0).string_value ();
+      std::string cls = args(1).string_value ();
+
+      if (! pkg.empty ())
+        cls = pkg + "." + cls;
+
+      if (! error_state)
+	retval = to_ov (lookup_class (cls));
+      else
+	error ("invalid class name, expected a string value");
+    }
+  else
+    print_usage ();
+
+  return retval;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-classdef.h b/src/ov-classdef.h
--- a/src/ov-classdef.h
+++ b/src/ov-classdef.h
@@ -30,16 +30,18 @@ along with Octave; see the file COPYING.
 #include "ov-base.h"
 
 class cdef_object;
 class cdef_class;
 class cdef_property;
 class cdef_method;
 class cdef_package;
 
+class tree_classdef;
+
 class
 cdef_object_rep
 {
 public:
   friend class cdef_object;
 
 public:
   cdef_object_rep (void)
@@ -331,16 +333,18 @@ public:
     { return get ("Name").string_value (); }
 
   bool is_builtin (void) const
     { return get_directory ().empty (); }
 
   void delete_object (cdef_object obj)
     { get_rep ()->delete_object (obj); }
 
+  static cdef_class make_meta_class (const tree_classdef* t);
+
 private:
   cdef_class_rep* get_rep (void)
     { return dynamic_cast<cdef_class_rep *> (cdef_object::get_rep ()); }
   
   const cdef_class_rep* get_rep (void) const
     { return dynamic_cast<const cdef_class_rep *> (cdef_object::get_rep ()); }
 
   friend bool operator == (const cdef_class&, const cdef_class&);
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -60,16 +60,17 @@ along with Octave; see the file COPYING.
 #include "ov-flt-cx-mat.h"
 #include "ov-cx-diag.h"
 #include "ov-flt-cx-diag.h"
 #include "ov-ch-mat.h"
 #include "ov-str-mat.h"
 #include "ov-range.h"
 #include "ov-struct.h"
 #include "ov-class.h"
+#include "ov-classdef.h"
 #include "ov-oncleanup.h"
 #include "ov-cs-list.h"
 #include "ov-colon.h"
 #include "ov-builtin.h"
 #include "ov-dld-fcn.h"
 #include "ov-usr-fcn.h"
 #include "ov-fcn-handle.h"
 #include "ov-fcn-inline.h"
diff --git a/src/pt-all.h b/src/pt-all.h
--- a/src/pt-all.h
+++ b/src/pt-all.h
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 
 #include "pt.h"
 #include "pt-arg-list.h"
 #include "pt-assign.h"
 #include "pt-bp.h"
 #include "pt-binop.h"
 #include "pt-cbinop.h"
 #include "pt-check.h"
+#include "pt-classdef.h"
 #include "pt-cmd.h"
 #include "pt-colon.h"
 #include "pt-const.h"
 #include "pt-decl.h"
 #include "pt-except.h"
 #include "pt-exp.h"
 #include "pt-fcn-handle.h"
 #include "pt-funcall.h"
diff --git a/src/pt-classdef.cc b/src/pt-classdef.cc
new file mode 100644
--- /dev/null
+++ b/src/pt-classdef.cc
@@ -0,0 +1,260 @@
+/*
+
+Copyright (C) 2012 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include "ov-classdef.h"
+#include "pt-classdef.h"
+
+// Classdef attribute
+
+void
+tree_classdef_attribute::accept (tree_walker& tw)
+{
+  tw.visit_classdef_attribute (*this);
+}
+
+// Classdef attribute_list
+
+tree_classdef_attribute_list::~tree_classdef_attribute_list (void)
+{
+  while (! empty ())
+    {
+      iterator p = begin ();
+      delete *p;
+      erase (p);
+    }
+}
+
+void
+tree_classdef_attribute_list::accept (tree_walker& tw)
+{
+  tw.visit_classdef_attribute_list (*this);
+}
+
+// Classdef superclass
+
+void
+tree_classdef_superclass::accept (tree_walker& tw)
+{
+  tw.visit_classdef_superclass (*this);
+}
+
+// Classdef superclass_list
+
+tree_classdef_superclass_list::~tree_classdef_superclass_list (void)
+{
+  while (! empty ())
+    {
+      iterator p = begin ();
+      delete *p;
+      erase (p);
+    }
+}
+
+void
+tree_classdef_superclass_list::accept (tree_walker& tw)
+{
+  tw.visit_classdef_superclass_list (*this);
+}
+
+// Classdef property
+
+void
+tree_classdef_property::accept (tree_walker& tw)
+{
+  tw.visit_classdef_property (*this);
+}
+
+// Classdef property_list
+
+tree_classdef_property_list::~tree_classdef_property_list (void)
+{
+  while (! empty ())
+    {
+      iterator p = begin ();
+      delete *p;
+      erase (p);
+    }
+}
+
+void
+tree_classdef_property_list::accept (tree_walker& tw)
+{
+  tw.visit_classdef_property_list (*this);
+}
+
+// Classdef properties_block
+
+void
+tree_classdef_properties_block::accept (tree_walker& tw)
+{
+  tw.visit_classdef_properties_block (*this);
+}
+
+// Classdef methods_list
+
+void
+tree_classdef_methods_list::accept (tree_walker& tw)
+{
+  tw.visit_classdef_methods_list (*this);
+}
+
+// Classdef methods_block
+
+void
+tree_classdef_methods_block::accept (tree_walker& tw)
+{
+  tw.visit_classdef_methods_block (*this);
+}
+
+// Classdef event
+
+void
+tree_classdef_event::accept (tree_walker& tw)
+{
+  tw.visit_classdef_event (*this);
+}
+
+// Classdef events_list
+
+tree_classdef_events_list::~tree_classdef_events_list (void)
+{
+  while (! empty ())
+    {
+      iterator p = begin ();
+      delete *p;
+      erase (p);
+    }
+}
+
+void
+tree_classdef_events_list::accept (tree_walker& tw)
+{
+  tw.visit_classdef_events_list (*this);
+}
+
+// Classdef events_block
+
+void
+tree_classdef_events_block::accept (tree_walker& tw)
+{
+  tw.visit_classdef_events_block (*this);
+}
+
+// Classdef enum
+
+void
+tree_classdef_enum::accept (tree_walker& tw)
+{
+  tw.visit_classdef_enum (*this);
+}
+
+// Classdef enum_list
+
+tree_classdef_enum_list::~tree_classdef_enum_list (void)
+{
+  while (! empty ())
+    {
+      iterator p = begin ();
+      delete *p;
+      erase (p);
+    }
+}
+
+void
+tree_classdef_enum_list::accept (tree_walker& tw)
+{
+  tw.visit_classdef_enum_list (*this);
+}
+
+// Classdef enum_block
+
+void
+tree_classdef_enum_block::accept (tree_walker& tw)
+{
+  tw.visit_classdef_enum_block (*this);
+}
+
+// Classdef body
+
+tree_classdef_body::~tree_classdef_body (void)
+{
+  while (! properties_lst.empty ())
+    {
+      properties_list_iterator p = properties_lst.begin ();
+      delete *p;
+      properties_lst.erase (p);
+    }
+
+  while (! methods_lst.empty ())
+    {
+      methods_list_iterator p = methods_lst.begin ();
+      delete *p;
+      methods_lst.erase (p);
+    }
+
+  while (! events_lst.empty ())
+    {
+      events_list_iterator p = events_lst.begin ();
+      delete *p;
+      events_lst.erase (p);
+    }
+
+  while (! enum_lst.empty ())
+    {
+      enum_list_iterator p = enum_lst.begin ();
+      delete *p;
+      enum_lst.erase (p);
+    }
+}
+
+// Classdef
+
+octave_value
+tree_classdef::make_meta_class (void) const
+{
+  octave_value retval;
+  cdef_class cls = cdef_class::make_meta_class (this);
+
+  if (cls.ok ())
+    retval = to_ov (cls);
+
+  return retval;
+}
+
+tree_classdef *
+tree_classdef::dup (symbol_table::scope_id,
+                    symbol_table::context_id) const
+{
+  // FIXME
+  return 0;
+}
+
+void
+tree_classdef::accept (tree_walker& tw)
+{
+  std::cerr << "I am super accepting" << std::endl;
+  // tw.visit_classdef (*this);
+}
diff --git a/src/pt-classdef.h b/src/pt-classdef.h
new file mode 100644
--- /dev/null
+++ b/src/pt-classdef.h
@@ -0,0 +1,653 @@
+/*
+
+Copyright (C) 2012 John W. Eaton
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 3 of the License, or (at your
+option) any later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, see
+<http://www.gnu.org/licenses/>.
+
+*/
+
+#if !defined (octave_tree_classdef_h)
+#define octave_tree_classdef_h 1
+
+class octave_value;
+
+class tree_walker;
+
+#include "pt-cmd.h"
+#include "pt-exp.h"
+#include "pt-id.h"
+
+#include "base-list.h"
+
+#include <list>
+
+class tree_classdef_attribute
+{
+public:
+
+  tree_classdef_attribute (tree_identifier *i = 0, tree_expression *e = 0)
+    : id (i), expr (e), neg (false) { }
+
+  tree_classdef_attribute (tree_identifier *i, bool b)
+    : id (i), expr (0), neg (b) { }
+
+  ~tree_classdef_attribute (void)
+  {
+    delete id;
+    delete expr;
+  }
+
+  tree_identifier *ident (void) { return id; }
+
+  tree_expression *expression (void) { return expr; }
+
+  bool negate (void) { return neg; }
+
+  void accept (tree_walker&);
+
+private:
+  
+  tree_identifier *id;
+  tree_expression *expr;
+  bool neg;
+
+  // No copying!
+
+  tree_classdef_attribute (const tree_classdef_attribute&);
+
+  tree_classdef_attribute& operator = (const tree_classdef_attribute&);
+};
+
+class tree_classdef_attribute_list : public octave_base_list<tree_classdef_attribute *>
+{
+public:
+
+  tree_classdef_attribute_list (void) { }
+
+  tree_classdef_attribute_list (tree_classdef_attribute *a) { append (a); }
+
+  tree_classdef_attribute_list (const octave_base_list<tree_classdef_attribute *>& a)
+    : octave_base_list<tree_classdef_attribute *> (a) { }
+
+  ~tree_classdef_attribute_list (void);
+
+  void accept (tree_walker&);
+
+private:
+
+  // No copying!
+
+  tree_classdef_attribute_list (const tree_classdef_attribute_list&);
+
+  tree_classdef_attribute_list& operator = (const tree_classdef_attribute_list&);
+};
+
+class tree_classdef_superclass
+{
+public:
+
+  tree_classdef_superclass (tree_identifier *i = 0, tree_identifier *p = 0)
+    : id (i), pkg (p) { }
+
+  ~tree_classdef_superclass (void)
+  {
+    delete id;
+    delete pkg;
+  }
+
+  tree_identifier *ident (void) { return id; }
+
+  tree_identifier * package (void) { return pkg; }
+
+  void accept (tree_walker&);
+
+private:
+
+  tree_identifier *id;
+  tree_identifier *pkg;
+
+  // No copying!
+
+  tree_classdef_superclass (const tree_classdef_superclass&);
+
+  tree_classdef_superclass& operator = (const tree_classdef_superclass&);
+};
+
+class tree_classdef_superclass_list : public octave_base_list<tree_classdef_superclass *>
+{
+public:
+
+  tree_classdef_superclass_list (void) { }
+
+  tree_classdef_superclass_list (tree_classdef_superclass *sc) { append (sc); }
+
+  tree_classdef_superclass_list (const octave_base_list<tree_classdef_superclass *>& a)
+    : octave_base_list<tree_classdef_superclass *> (a) { }
+
+  ~tree_classdef_superclass_list (void);
+
+  void accept (tree_walker&);
+
+private:
+
+  // No copying!
+
+  tree_classdef_superclass_list (const tree_classdef_superclass_list&);
+
+  tree_classdef_superclass_list& operator = (const tree_classdef_superclass_list&);
+};
+
+template <typename T>
+class tree_classdef_element : public tree
+{
+public:
+
+  tree_classdef_element (tree_classdef_attribute_list *a,
+                         octave_base_list<T> *elist,
+                         octave_comment_list *lc, octave_comment_list *tc,
+                         int l = -1, int c = -1)
+    : tree (l, c), attr_list (a), elt_list (elist),
+      lead_comm (lc), trail_comm (tc)
+  { }
+
+  ~tree_classdef_element (void)
+  {
+    delete attr_list;
+    delete elt_list;
+    delete lead_comm;
+    delete trail_comm;
+  }
+
+  tree_classdef_attribute_list *attribute_list (void) { return attr_list; }
+
+  octave_base_list<T> *element_list (void) { return elt_list; }
+
+  octave_comment_list *leading_comment (void) { return lead_comm; }
+
+  octave_comment_list *trailing_comment (void) { return trail_comm; }
+
+  void accept (tree_walker&) { }
+
+private:
+
+  // List of attributes that apply to this class.
+  tree_classdef_attribute_list *attr_list;
+
+  // The list of objects contained in this block.
+  octave_base_list<T> *elt_list;
+  
+  // Comment preceding the token marking the beginning of the block.
+  octave_comment_list *lead_comm;
+
+  // Comment preceding END token.
+  octave_comment_list *trail_comm;
+
+  // No copying!
+
+  tree_classdef_element (const tree_classdef_element&);
+
+  tree_classdef_element& operator = (const tree_classdef_element&);
+};
+
+class tree_classdef_property
+{
+public:
+
+  tree_classdef_property (tree_identifier *i = 0, tree_expression *e = 0)
+    : id (i), expr (e) { }
+
+  ~tree_classdef_property (void)
+  {
+    delete id;
+    delete expr;
+  }
+
+  tree_identifier *ident (void) { return id; }
+
+  tree_expression *expression (void) { return expr; }
+
+  void accept (tree_walker&);
+
+private:
+
+  tree_identifier *id;
+  tree_expression *expr;
+
+  // No copying!
+
+  tree_classdef_property (const tree_classdef_property&);
+
+  tree_classdef_property& operator = (const tree_classdef_property&);
+};
+
+class tree_classdef_property_list : public octave_base_list<tree_classdef_property *>
+{
+public:
+
+  tree_classdef_property_list (void) { }
+
+  tree_classdef_property_list (tree_classdef_property* p) { append (p); }
+
+  tree_classdef_property_list (const octave_base_list<tree_classdef_property *>& a)
+    : octave_base_list<tree_classdef_property *> (a) { }
+
+  ~tree_classdef_property_list (void);
+
+  void accept (tree_walker&);
+
+private:
+
+  // No copying!
+
+  tree_classdef_property_list (const tree_classdef_property_list&);
+
+  tree_classdef_property_list& operator = (const tree_classdef_property_list&);
+};
+
+class tree_classdef_properties_block
+  : public tree_classdef_element<tree_classdef_property *>
+{
+public:
+
+  tree_classdef_properties_block (tree_classdef_attribute_list *a,
+                                  tree_classdef_property_list *plist,
+                                  octave_comment_list *lc,
+                                  octave_comment_list *tc,
+                                  int l = -1, int c = -1)
+    : tree_classdef_element<tree_classdef_property *> (a, plist, lc, tc, l, c) { }
+
+  ~tree_classdef_properties_block (void) { }
+
+  void accept (tree_walker&);
+
+private:
+
+  // No copying!
+
+  tree_classdef_properties_block (const tree_classdef_properties_block&);
+
+  tree_classdef_properties_block& operator = (const tree_classdef_properties_block&);
+};
+
+class tree_classdef_methods_list : public octave_base_list<octave_value>
+{
+public:
+
+  tree_classdef_methods_list (void) { }
+
+  tree_classdef_methods_list (const octave_value& f) { append (f); }
+
+  tree_classdef_methods_list (const octave_base_list<octave_value>& a)
+    : octave_base_list<octave_value> (a) { }
+
+  ~tree_classdef_methods_list (void) { }
+
+  void accept (tree_walker&);
+
+private:
+
+  // No copying!
+
+  tree_classdef_methods_list (const tree_classdef_methods_list&);
+
+  tree_classdef_methods_list& operator = (const tree_classdef_methods_list&);
+};
+
+class tree_classdef_methods_block : public tree_classdef_element<octave_value>
+{
+public:
+
+  tree_classdef_methods_block (tree_classdef_attribute_list *a,
+                               tree_classdef_methods_list *mlist,
+                               octave_comment_list *lc,
+                               octave_comment_list *tc, int l = -1, int c = -1)
+    : tree_classdef_element<octave_value> (a, mlist, lc, tc, l, c) { }
+
+  ~tree_classdef_methods_block (void) { }
+
+  void accept (tree_walker&);
+
+private:
+
+  // No copying!
+
+  tree_classdef_methods_block (const tree_classdef_methods_block&);
+
+  tree_classdef_methods_block& operator = (const tree_classdef_methods_block&);
+};
+
+class tree_classdef_event
+{
+public:
+
+  tree_classdef_event (tree_identifier *i = 0) : id (i) { }
+
+  ~tree_classdef_event (void)
+  {
+    delete id;
+  }
+
+  tree_identifier *ident (void) { return id; }
+
+  void accept (tree_walker&);
+
+private:
+
+  tree_identifier *id;
+
+  // No copying!
+
+  tree_classdef_event (const tree_classdef_event&);
+
+  tree_classdef_event& operator = (const tree_classdef_event&);
+};
+
+class tree_classdef_events_list : public octave_base_list<tree_classdef_event *>
+{
+public:
+
+  tree_classdef_events_list (void) { }
+
+  tree_classdef_events_list (tree_classdef_event *e) { append (e); }
+
+  tree_classdef_events_list (const octave_base_list<tree_classdef_event *>& a)
+    : octave_base_list<tree_classdef_event *> (a) { }
+
+  ~tree_classdef_events_list (void);
+
+  void accept (tree_walker&);
+
+private:
+
+  // No copying!
+
+  tree_classdef_events_list (const tree_classdef_events_list&);
+
+  tree_classdef_events_list& operator = (const tree_classdef_events_list&);
+};
+
+class tree_classdef_events_block
+  : public tree_classdef_element<tree_classdef_event *>
+{
+public:
+
+  tree_classdef_events_block (tree_classdef_attribute_list *a,
+                              tree_classdef_events_list *elist,
+                              octave_comment_list *lc,
+                              octave_comment_list *tc, int l = -1, int c = -1)
+    : tree_classdef_element<tree_classdef_event *> (a, elist, lc, tc, l, c) { }
+
+  ~tree_classdef_events_block (void) { }
+
+  void accept (tree_walker&);
+
+private:
+
+  // No copying!
+
+  tree_classdef_events_block (const tree_classdef_events_block&);
+
+  tree_classdef_events_block& operator = (const tree_classdef_events_block&);
+};
+
+class tree_classdef_enum
+{
+public:
+
+  tree_classdef_enum (void) : id (0), expr (0) { }
+
+  tree_classdef_enum (tree_identifier *i, tree_expression *e)
+    : id (i), expr (e) { }
+
+  ~tree_classdef_enum (void)
+  {
+    delete id;
+    delete expr;
+  }
+
+  tree_identifier *ident (void) { return id; }
+
+  tree_expression *expression (void) { return expr; }
+
+  void accept (tree_walker&);
+
+private:
+
+  tree_identifier *id;
+  tree_expression *expr;
+
+  // No copying!
+
+  tree_classdef_enum (const tree_classdef_enum&);
+
+  tree_classdef_enum& operator = (const tree_classdef_enum&);
+};
+
+class tree_classdef_enum_list : public octave_base_list<tree_classdef_enum *>
+{
+public:
+
+  tree_classdef_enum_list (void) { }
+
+  tree_classdef_enum_list (tree_classdef_enum *e) { append (e); }
+
+  tree_classdef_enum_list (const octave_base_list<tree_classdef_enum *>& a)
+    : octave_base_list<tree_classdef_enum *> (a) { }
+
+  ~tree_classdef_enum_list (void);
+
+  void accept (tree_walker&);
+
+private:
+
+  // No copying!
+
+  tree_classdef_enum_list (const tree_classdef_enum_list&);
+
+  tree_classdef_enum_list& operator = (const tree_classdef_enum_list&);
+};
+
+class tree_classdef_enum_block
+  : public tree_classdef_element<tree_classdef_enum *>
+{
+public:
+
+  tree_classdef_enum_block (tree_classdef_attribute_list *a,
+                            tree_classdef_enum_list *elist,
+                            octave_comment_list *lc,
+                            octave_comment_list *tc, int l = -1, int c = -1)
+    : tree_classdef_element<tree_classdef_enum *> (a, elist, lc, tc, l, c) { }
+
+  ~tree_classdef_enum_block (void) { }
+
+  void accept (tree_walker&);
+
+private:
+
+  // No copying!
+
+  tree_classdef_enum_block (const tree_classdef_enum_block&);
+
+  tree_classdef_enum_block& operator = (const tree_classdef_enum_block&);
+};
+
+class tree_classdef_body
+{
+public:
+
+  typedef typename std::list<tree_classdef_properties_block *>::iterator properties_list_iterator;
+  typedef typename std::list<tree_classdef_properties_block *>::const_iterator properties_list_const_iterator;
+
+  typedef typename std::list<tree_classdef_methods_block *>::iterator methods_list_iterator;
+  typedef typename std::list<tree_classdef_methods_block *>::const_iterator methods_list_const_iterator;
+
+  typedef typename std::list<tree_classdef_events_block *>::iterator events_list_iterator;
+  typedef typename std::list<tree_classdef_events_block *>::const_iterator events_list_const_iterator;
+
+  typedef typename std::list<tree_classdef_enum_block *>::iterator enum_list_iterator;
+  typedef typename std::list<tree_classdef_enum_block *>::const_iterator enum_list_const_iterator;
+
+  tree_classdef_body (void)
+    : properties_lst (), methods_lst (), events_lst (), enum_lst () { }
+
+  tree_classdef_body (tree_classdef_properties_block *pb)
+    : properties_lst (), methods_lst (), events_lst (), enum_lst ()
+  {
+    append (pb);
+  }
+
+  tree_classdef_body (tree_classdef_methods_block *mb)
+    : properties_lst (), methods_lst (), events_lst (), enum_lst ()
+  {
+    append (mb);
+  }
+
+  tree_classdef_body (tree_classdef_events_block *evb)
+    : properties_lst (), methods_lst (), events_lst (), enum_lst ()
+  {
+    append (evb);
+  }
+
+  tree_classdef_body (tree_classdef_enum_block *enb)
+    : properties_lst (), methods_lst (), events_lst (), enum_lst ()
+  {
+    append (enb);
+  }
+
+  ~tree_classdef_body (void);
+
+  void append (tree_classdef_properties_block *pb)
+  {
+    properties_lst.push_back (pb);
+  }
+
+  void append (tree_classdef_methods_block *mb)
+  {
+    methods_lst.push_back (mb);
+  }
+
+  void append (tree_classdef_events_block *evb)
+  {
+    events_lst.push_back (evb);
+  }
+
+  void append (tree_classdef_enum_block *enb)
+  {
+    enum_lst.push_back (enb);
+  }
+
+  std::list<tree_classdef_properties_block *> properties_list (void)
+  {
+    return properties_lst;
+  }
+
+  std::list<tree_classdef_methods_block *> methods_list (void)
+  {
+    return methods_lst;
+  }
+
+  std::list<tree_classdef_events_block *> events_list (void)
+  {
+    return events_lst;
+  }
+
+  std::list<tree_classdef_enum_block *> enum_list (void)
+  {
+    return enum_lst;
+  }
+
+  void accept (tree_walker&);
+
+private:
+
+  std::list<tree_classdef_properties_block *> properties_lst;
+
+  std::list<tree_classdef_methods_block *> methods_lst;
+
+  std::list<tree_classdef_events_block *> events_lst;
+
+  std::list<tree_classdef_enum_block *> enum_lst;
+
+  // No copying!
+
+  tree_classdef_body (const tree_classdef_body&);
+
+  tree_classdef_body& operator = (const tree_classdef_body&);
+};
+
+// Classdef definition.
+
+class tree_classdef : public tree_command
+{
+public:
+
+  tree_classdef (tree_classdef_attribute_list *a, tree_identifier *i,
+                 tree_classdef_superclass_list *sc,
+                 tree_classdef_body *b, octave_comment_list *lc,
+                 octave_comment_list *tc, int l = -1, int c = -1)
+    : tree_command (l, c), attr_list (a), id (i),
+      supclass_list (sc), element_list (b), lead_comm (lc), trail_comm (tc) { }
+
+  ~tree_classdef (void)
+  {
+    delete attr_list;
+    delete id;
+    delete supclass_list;
+    delete element_list;
+    delete lead_comm;
+    delete trail_comm;
+  }
+
+  tree_classdef_attribute_list *attribute_list (void) { return attr_list; }
+
+  tree_identifier *ident (void) { return id; }
+
+  tree_classdef_superclass_list *superclass_list (void) { return supclass_list; }
+
+  tree_classdef_body *body (void) { return element_list; }
+
+  octave_comment_list *leading_comment (void) { return lead_comm; }
+  octave_comment_list *trailing_comment (void) { return trail_comm; }
+
+  octave_value make_meta_class (void) const;
+
+  tree_classdef *dup (symbol_table::scope_id scope,
+                      symbol_table::context_id context) const;
+
+  void accept (tree_walker& tw);
+
+private:
+
+  tree_classdef_attribute_list *attr_list;
+
+  tree_identifier *id;
+
+  tree_classdef_superclass_list *supclass_list;
+
+  tree_classdef_body *element_list;
+
+  octave_comment_list *lead_comm;
+  octave_comment_list *trail_comm;
+
+  // No copying!
+
+  tree_classdef (const tree_classdef&);
+
+  tree_classdef& operator = (const tree_classdef&);
+};
+
+#endif
diff --git a/src/pt-id.h b/src/pt-id.h
--- a/src/pt-id.h
+++ b/src/pt-id.h
@@ -27,16 +27,17 @@ along with Octave; see the file COPYING.
 #include <string>
 
 class octave_value;
 class octave_value_list;
 class octave_function;
 
 class tree_walker;
 
+#include "oct-lvalue.h"
 #include "pt-bp.h"
 #include "pt-exp.h"
 #include "symtab.h"
 
 // Symbols from the symbol table.
 
 class
 tree_identifier : public tree_expression
diff --git a/src/pt-walk.h b/src/pt-walk.h
--- a/src/pt-walk.h
+++ b/src/pt-walk.h
@@ -61,16 +61,34 @@ class tree_return_list;
 class tree_simple_assignment;
 class tree_statement;
 class tree_statement_list;
 class tree_try_catch_command;
 class tree_unwind_protect_command;
 class tree_while_command;
 class tree_do_until_command;
 
+class tree_classdef_attribute;
+class tree_classdef_attribute_list;
+class tree_classdef_superclass;
+class tree_classdef_superclass_list;
+class tree_classdef_property;
+class tree_classdef_property_list;
+class tree_classdef_properties_block;
+class tree_classdef_methods_list;
+class tree_classdef_methods_block;
+class tree_classdef_event;
+class tree_classdef_events_list;
+class tree_classdef_events_block;
+class tree_classdef_enum;
+class tree_classdef_enum_list;
+class tree_classdef_enum_block;
+class tree_classdef_body;
+class tree_classdef;
+
 class
 tree_walker
 {
 public:
 
   virtual void
   visit_anon_fcn_handle (tree_anon_fcn_handle&) = 0;
 
@@ -192,16 +210,67 @@ public:
   visit_unwind_protect_command (tree_unwind_protect_command&) = 0;
 
   virtual void
   visit_while_command (tree_while_command&) = 0;
 
   virtual void
   visit_do_until_command (tree_do_until_command&) = 0;
 
+  virtual void
+  visit_classdef_attribute (tree_classdef_attribute&) { } /* = 0; */
+
+  virtual void
+  visit_classdef_attribute_list (tree_classdef_attribute_list&) { } /* = 0; */
+
+  virtual void
+  visit_classdef_superclass (tree_classdef_superclass&) { } /* = 0; */
+
+  virtual void
+  visit_classdef_superclass_list (tree_classdef_superclass_list&) { } /* = 0; */
+
+  virtual void
+  visit_classdef_property (tree_classdef_property&) { } /* = 0; */
+
+  virtual void
+  visit_classdef_property_list (tree_classdef_property_list&) { } /* = 0; */
+
+  virtual void
+  visit_classdef_properties_block (tree_classdef_properties_block&) { } /* = 0; */
+
+  virtual void
+  visit_classdef_methods_list (tree_classdef_methods_list&) { } /* = 0; */
+
+  virtual void
+  visit_classdef_methods_block (tree_classdef_methods_block&) { } /* = 0; */
+
+  virtual void
+  visit_classdef_event (tree_classdef_event&) { } /* = 0; */
+
+  virtual void
+  visit_classdef_events_list (tree_classdef_events_list&) { } /* = 0; */
+
+  virtual void
+  visit_classdef_events_block (tree_classdef_events_block&) { } /* = 0; */
+
+  virtual void
+  visit_classdef_enum (tree_classdef_enum&) { } /* = 0; */
+
+  virtual void
+  visit_classdef_enum_list (tree_classdef_enum_list&) { } /* = 0; */
+
+  virtual void
+  visit_classdef_enum_block (tree_classdef_enum_block&) { } /* = 0; */
+
+  virtual void
+  visit_classdef_body (tree_classdef_body&) { } /* = 0; */
+
+  virtual void
+  visit_classdef (tree_classdef&) { } /* = 0; */
+
 protected:
 
   tree_walker (void) { }
 
   virtual ~tree_walker (void) { }
 
 private:
 
diff --git a/src/token.cc b/src/token.cc
--- a/src/token.cc
+++ b/src/token.cc
@@ -67,42 +67,53 @@ token::token (end_tok_type t, int l, int
 token::token (symbol_table::symbol_record *s, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = sym_rec_token;
   sr = s;
 }
 
-token::token (symbol_table::symbol_record *cls,
-              symbol_table::symbol_record *pkg, int l, int c)
+token::token (const std::string& pkg, const std::string& cls, int l, int c)
 {
   line_num = l;
   column_num = c;
-  type_tag = meta_rec_token;
-  mc.cr = cls;
-  mc.pr = pkg;
+  type_tag = meta_name_token;
+  mc.package_nm = new std::string (pkg);
+  mc.class_nm = new std::string (cls);
 }
 
-token::token (symbol_table::symbol_record *mth,
-              symbol_table::symbol_record *cls,
-              symbol_table::symbol_record *pkg, int l, int c)
+token::token (const std::string& mth, const std::string& pkg,
+              const std::string& cls, int l, int c)
 {
   line_num = l;
   column_num = c;
-  type_tag = scls_rec_token;
-  sc.mr = mth;
-  sc.cr = cls;
-  sc.pr = pkg;
+  type_tag = scls_name_token;
+  sc.method_nm = new std::string (mth);
+  sc.package_nm = new std::string (pkg);
+  sc.class_nm = new std::string (cls);
 }
 
 token::~token (void)
 {
   if (type_tag == string_token)
     delete str;
+
+  if (type_tag == scls_name_token)
+    {
+      delete sc.method_nm;
+      delete sc.package_nm;
+      delete sc.class_nm;
+    }
+
+  if (type_tag == meta_name_token)
+    {
+      delete mc.package_nm;
+      delete mc.class_nm;
+    }
 }
 
 std::string
 token::text (void)
 {
   assert (type_tag == string_token);
   return *str;
 }
@@ -123,48 +134,48 @@ token::ettype (void)
 
 symbol_table::symbol_record *
 token::sym_rec (void)
 {
   assert (type_tag == sym_rec_token);
   return sr;
 }
 
-symbol_table::symbol_record *
-token::method_rec (void)
+std::string
+token::superclass_method_name (void)
 {
-  assert (type_tag == scls_rec_token);
-  return sc.mr;
+  assert (type_tag == scls_name_token);
+  return *sc.method_nm;
 }
 
-symbol_table::symbol_record *
-token::class_rec (void)
+std::string
+token::superclass_package_name (void)
 {
-  assert (type_tag == scls_rec_token);
-  return sc.cr;
+  assert (type_tag == scls_name_token);
+  return *sc.package_nm;
 }
 
-symbol_table::symbol_record *
-token::package_rec (void)
+std::string
+token::superclass_class_name (void)
 {
-  assert (type_tag == scls_rec_token);
-  return sc.pr;
+  assert (type_tag == scls_name_token);
+  return *sc.class_nm;
 }
 
-symbol_table::symbol_record *
-token::meta_class_rec (void)
+std::string
+token::meta_package_name (void)
 {
-  assert (type_tag == meta_rec_token);
-  return mc.cr;
+  assert (type_tag == meta_name_token);
+  return *mc.package_nm;
 }
 
-symbol_table::symbol_record *
-token::meta_package_rec (void)
+std::string
+token::meta_class_name (void)
 {
-  assert (type_tag == meta_rec_token);
-  return mc.pr;
+  assert (type_tag == meta_name_token);
+  return *mc.class_nm;
 }
 
 std::string
 token::text_rep (void)
 {
   return orig_text;
 }
diff --git a/src/token.h b/src/token.h
--- a/src/token.h
+++ b/src/token.h
@@ -32,18 +32,18 @@ public:
 
   enum token_type
     {
       generic_token,
       string_token,
       double_token,
       ettype_token,
       sym_rec_token,
-      scls_rec_token,
-      meta_rec_token
+      scls_name_token,
+      meta_name_token
     };
 
   enum end_tok_type
     {
       simple_end,
       classdef_end,
       enumeration_end,
       events_end,
@@ -60,38 +60,37 @@ public:
     };
 
   token (int l = -1, int c = -1);
   token (const std::string& s, int l = -1, int c = -1);
   token (double d, const std::string& s = std::string (),
          int l = -1, int c = -1);
   token (end_tok_type t, int l = -1, int c = -1);
   token (symbol_table::symbol_record *s, int l = -1, int c = -1);
-  token (symbol_table::symbol_record *cls,
-         symbol_table::symbol_record *pkg, int l = -1, int c = -1);
-  token (symbol_table::symbol_record *mth,
-         symbol_table::symbol_record *cls,
-         symbol_table::symbol_record *pkg, int l = -1, int c = -1);
+  token (const std::string& pkg, const std::string& cls,
+         int l = -1, int c = -1);
+  token (const std::string& mth, const std::string& pkg,
+         const std::string& cls, int l = -1, int c = -1);
 
   ~token (void);
 
   int line (void) { return line_num; }
   int column (void) { return column_num; }
 
   std::string text (void);
   double number (void);
   end_tok_type ettype (void);
   symbol_table::symbol_record *sym_rec (void);
 
-  symbol_table::symbol_record *method_rec (void);
-  symbol_table::symbol_record *class_rec (void);
-  symbol_table::symbol_record *package_rec (void);
+  std::string superclass_method_name (void);
+  std::string superclass_package_name (void);
+  std::string superclass_class_name (void);
 
-  symbol_table::symbol_record *meta_class_rec (void);
-  symbol_table::symbol_record *meta_package_rec (void);
+  std::string meta_package_name (void);
+  std::string meta_class_name (void);
 
   std::string text_rep (void);
 
 private:
 
   // No copying!
 
   token (const token& tok);
@@ -104,22 +103,22 @@ private:
   union
     {
       std::string *str;
       double num;
       end_tok_type et;
       symbol_table::symbol_record *sr;
       struct
         {
-          symbol_table::symbol_record *mr;
-          symbol_table::symbol_record *cr;
-          symbol_table::symbol_record *pr;
+          std::string *method_nm;
+          std::string *package_nm;
+          std::string *class_nm;
         } sc;
       struct
         {
-          symbol_table::symbol_record *cr;
-          symbol_table::symbol_record *pr;
+          std::string *package_nm;
+          std::string *class_nm;
         } mc;
     };
   std::string orig_text;
 };
 
 #endif
