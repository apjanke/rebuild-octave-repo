# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1521288150 18000
#      Sat Mar 17 07:02:30 2018 -0500
# Node ID 49e0447413ad4a83290653220d7159b6617b0081
# Parent  d8aa0e66aa5c49047bbc739a69732a8323712062
use templates and move rand functions inside octave namespace

* oct-rand.h, oct-rand.cc (rand): Move class inside octave namespace
and rename from octave_rand.  Use templates to eliminate duplicate
code.  Change all uses.

* randgamma.h, randgamma.cc, randmtzig.h, randmtzig.cc, randpoisson.h,
randpoisson.cc: Move functions inside Octave namespace.
Use templates to eliminate duplicate code.  Change all uses.

diff --git a/libinterp/corefcn/rand.cc b/libinterp/corefcn/rand.cc
--- a/libinterp/corefcn/rand.cc
+++ b/libinterp/corefcn/rand.cc
@@ -113,20 +113,20 @@ do_rand (const octave_value_list& args, 
         }
     }
 
   octave_value retval;
   dim_vector dims;
 
   octave::unwind_protect frame;
   // Restore current distribution on any exit.
-  frame.add_fcn (octave_rand::distribution,
-                 octave_rand::distribution ());
+  frame.add_fcn (octave::rand::distribution,
+                 octave::rand::distribution ());
 
-  octave_rand::distribution (distribution);
+  octave::rand::distribution (distribution);
 
   switch (nargin)
     {
     case 0:
       {
         if (additional_arg)
           dims = a.dims ();
         else
@@ -145,31 +145,31 @@ do_rand (const octave_value_list& args, 
       {
         octave_value tmp = args(idx);
 
         if (tmp.is_string ())
           {
             std::string s_arg = tmp.string_value ();
 
             if (s_arg == "dist")
-              retval = octave_rand::distribution ();
+              retval = octave::rand::distribution ();
             else if (s_arg == "seed")
-              retval = octave_rand::seed ();
+              retval = octave::rand::seed ();
             else if (s_arg == "state" || s_arg == "twister")
-              retval = octave_rand::state (fcn);
+              retval = octave::rand::state (fcn);
             else if (s_arg == "uniform")
-              octave_rand::uniform_distribution ();
+              octave::rand::uniform_distribution ();
             else if (s_arg == "normal")
-              octave_rand::normal_distribution ();
+              octave::rand::normal_distribution ();
             else if (s_arg == "exponential")
-              octave_rand::exponential_distribution ();
+              octave::rand::exponential_distribution ();
             else if (s_arg == "poisson")
-              octave_rand::poisson_distribution ();
+              octave::rand::poisson_distribution ();
             else if (s_arg == "gamma")
-              octave_rand::gamma_distribution ();
+              octave::rand::gamma_distribution ();
             else
               error ("%s: unrecognized string argument", fcn);
           }
         else if (tmp.is_scalar_type ())
           {
             double dval = tmp.double_value ();
 
             if (octave::math::isnan (dval))
@@ -245,35 +245,35 @@ do_rand (const octave_value_list& args, 
             std::string ts = tmp.string_value ();
 
             if (ts == "seed")
               {
                 if (args(idx+1).is_real_scalar ())
                   {
                     double d = args(idx+1).double_value ();
 
-                    octave_rand::seed (d);
+                    octave::rand::seed (d);
                   }
                 else if (args(idx+1).is_string ()
                          && args(idx+1).string_value () == "reset")
-                  octave_rand::reset ();
+                  octave::rand::reset ();
                 else
                   error ("%s: seed must be a real scalar", fcn);
               }
             else if (ts == "state" || ts == "twister")
               {
                 if (args(idx+1).is_string ()
                     && args(idx+1).string_value () == "reset")
-                  octave_rand::reset (fcn);
+                  octave::rand::reset (fcn);
                 else
                   {
                     ColumnVector s =
                       ColumnVector (args(idx+1).vector_value(false, true));
 
-                    octave_rand::state (s, fcn);
+                    octave::rand::state (s, fcn);
                   }
               }
             else
               error ("%s: unrecognized string argument", fcn);
           }
         else
           {
             dims.resize (nargin);
@@ -302,58 +302,58 @@ gen_matrix:
 
   dims.chop_trailing_singletons ();
 
   if (is_single)
     {
       if (additional_arg)
         {
           if (a.numel () == 1)
-            return octave_rand::float_nd_array (dims, a(0));
+            return octave::rand::float_nd_array (dims, a(0));
           else
             {
               if (a.dims () != dims)
                 error ("%s: mismatch in argument size", fcn);
 
               octave_idx_type len = a.numel ();
               FloatNDArray m (dims);
               float *v = m.fortran_vec ();
 
               for (octave_idx_type i = 0; i < len; i++)
-                v[i] = octave_rand::float_scalar (a(i));
+                v[i] = octave::rand::float_scalar (a(i));
 
               return m;
             }
         }
       else
-        return octave_rand::float_nd_array (dims);
+        return octave::rand::float_nd_array (dims);
     }
   else
     {
       if (additional_arg)
         {
           if (a.numel () == 1)
-            return octave_rand::nd_array (dims, a(0));
+            return octave::rand::nd_array (dims, a(0));
           else
             {
               if (a.dims () != dims)
                 error ("%s: mismatch in argument size", fcn);
 
               octave_idx_type len = a.numel ();
               NDArray m (dims);
               double *v = m.fortran_vec ();
 
               for (octave_idx_type i = 0; i < len; i++)
-                v[i] = octave_rand::scalar (a(i));
+                v[i] = octave::rand::scalar (a(i));
 
               return m;
             }
         }
       else
-        return octave_rand::nd_array (dims);
+        return octave::rand::nd_array (dims);
     }
 }
 
 DEFUN (rand, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} rand (@var{n})
 @deftypefnx {} {} rand (@var{m}, @var{n}, @dots{})
 @deftypefnx {} {} rand ([@var{m} @var{n} @dots{}])
@@ -527,17 +527,17 @@ classes.
 %!
 %!assert (__rand_sample__ (-1), __rand_sample__ (0))
 %!assert (__rand_sample__ (-Inf), __rand_sample__ (0))
 %!assert (__rand_sample__ (2^33), __rand_sample__ (intmax ("uint32")))
 %!assert (__rand_sample__ (Inf), __rand_sample__ (intmax ("uint32")))
 %!assert (__rand_sample__ (NaN), __rand_sample__ (0))
 */
 
-static std::string current_distribution = octave_rand::distribution ();
+static std::string current_distribution = octave::rand::distribution ();
 
 DEFUN (randn, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} randn (@var{n})
 @deftypefnx {} {} randn (@var{m}, @var{n}, @dots{})
 @deftypefnx {} {} randn ([@var{m} @var{n} @dots{}])
 @deftypefnx {} {@var{v} =} randn ("state")
 @deftypefnx {} {} randn ("state", @var{v})
@@ -1120,17 +1120,17 @@ likely.
   if (m > n)
     error ("randperm: M must be less than or equal to N");
 
   // Quick and dirty heuristic to decide if we allocate or not the
   // whole vector for tracking the truncated shuffle.
   bool short_shuffle = m < n/5;
 
   // Generate random numbers.
-  NDArray r = octave_rand::nd_array (dim_vector (1, m));
+  NDArray r = octave::rand::nd_array (dim_vector (1, m));
   double *rvec = r.fortran_vec ();
 
   octave_idx_type idx_len = (short_shuffle ? m : n);
   Array<octave_idx_type> idx;
   try
     {
       idx = Array<octave_idx_type> (dim_vector (1, idx_len));
     }
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -636,20 +636,20 @@ EigsRealSymmetricMatrix (const M& m, con
   if (m.rows () != m.cols ())
     (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     (*current_liboctave_error_handler)
       ("eigs: B must be square and the same size as A");
 
   if (resid.isempty ())
     {
-      std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution ("uniform");
-      resid = ColumnVector (octave_rand::vector (n));
-      octave_rand::distribution (rand_dist);
+      std::string rand_dist = octave::rand::distribution ();
+      octave::rand::distribution ("uniform");
+      resid = ColumnVector (octave::rand::vector (n));
+      octave::rand::distribution (rand_dist);
     }
   else if (m.cols () != resid.numel ())
     (*current_liboctave_error_handler) ("eigs: opts.v0 must be n-by-1");
 
   if (n < 3)
     (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (p < 0)
@@ -928,20 +928,20 @@ EigsRealSymmetricMatrixShift (const M& m
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigma))
   //  return EigsRealSymmetricMatrix (m, "SM", k, p, info, eig_vec, eig_val,
   //                                _b, permB, resid, os, tol, rvec, cholB,
   //                                disp, maxit);
 
   if (resid.isempty ())
     {
-      std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution ("uniform");
-      resid = ColumnVector (octave_rand::vector (n));
-      octave_rand::distribution (rand_dist);
+      std::string rand_dist = octave::rand::distribution ();
+      octave::rand::distribution ("uniform");
+      resid = ColumnVector (octave::rand::vector (n));
+      octave::rand::distribution (rand_dist);
     }
   else if (m.cols () != resid.numel ())
     (*current_liboctave_error_handler) ("eigs: opts.v0 must be n-by-1");
 
   if (n < 3)
     (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (k <= 0 || k >= n - 1)
@@ -1216,20 +1216,20 @@ EigsRealSymmetricFunc (EigsFunc fun, oct
   std::string typ (_typ);
   bool have_sigma = (sigma ? true : false);
   char bmat = 'I';
   F77_INT mode = 1;
   int err = 0;
 
   if (resid.isempty ())
     {
-      std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution ("uniform");
-      resid = ColumnVector (octave_rand::vector (n));
-      octave_rand::distribution (rand_dist);
+      std::string rand_dist = octave::rand::distribution ();
+      octave::rand::distribution ("uniform");
+      resid = ColumnVector (octave::rand::vector (n));
+      octave::rand::distribution (rand_dist);
     }
   else if (n != resid.numel ())
     (*current_liboctave_error_handler) ("eigs: opts.v0 must be n-by-1");
 
   if (n < 3)
     (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (p < 0)
@@ -1480,20 +1480,20 @@ EigsRealNonSymmetricMatrix (const M& m, 
   if (m.rows () != m.cols ())
     (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     (*current_liboctave_error_handler)
       ("eigs: B must be square and the same size as A");
 
   if (resid.isempty ())
     {
-      std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution ("uniform");
-      resid = ColumnVector (octave_rand::vector (n));
-      octave_rand::distribution (rand_dist);
+      std::string rand_dist = octave::rand::distribution ();
+      octave::rand::distribution ("uniform");
+      resid = ColumnVector (octave::rand::vector (n));
+      octave::rand::distribution (rand_dist);
     }
   else if (m.cols () != resid.numel ())
     (*current_liboctave_error_handler) ("eigs: opts.v0 must be n-by-1");
 
   if (n < 3)
     (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (p < 0)
@@ -1835,20 +1835,20 @@ EigsRealNonSymmetricMatrixShift (const M
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigmar))
   //  return EigsRealNonSymmetricMatrix (m, "SM", k, p, info, eig_vec, eig_val,
   //                                   _b, permB, resid, os, tol, rvec, cholB,
   //                                   disp, maxit);
 
   if (resid.isempty ())
     {
-      std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution ("uniform");
-      resid = ColumnVector (octave_rand::vector (n));
-      octave_rand::distribution (rand_dist);
+      std::string rand_dist = octave::rand::distribution ();
+      octave::rand::distribution ("uniform");
+      resid = ColumnVector (octave::rand::vector (n));
+      octave::rand::distribution (rand_dist);
     }
   else if (m.cols () != resid.numel ())
     (*current_liboctave_error_handler) ("eigs: opts.v0 must be n-by-1");
 
   if (n < 3)
     (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (p < 0)
@@ -2194,20 +2194,20 @@ EigsRealNonSymmetricFunc (EigsFunc fun, 
   bool have_sigma = (sigmar ? true : false);
   char bmat = 'I';
   double sigmai = 0.;
   F77_INT mode = 1;
   int err = 0;
 
   if (resid.isempty ())
     {
-      std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution ("uniform");
-      resid = ColumnVector (octave_rand::vector (n));
-      octave_rand::distribution (rand_dist);
+      std::string rand_dist = octave::rand::distribution ();
+      octave::rand::distribution ("uniform");
+      resid = ColumnVector (octave::rand::vector (n));
+      octave::rand::distribution (rand_dist);
     }
   else if (n != resid.numel ())
     (*current_liboctave_error_handler) ("eigs: opts.v0 must be n-by-1");
 
   if (n < 3)
     (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (p < 0)
@@ -2522,24 +2522,24 @@ EigsComplexNonSymmetricMatrix (const M& 
   if (m.rows () != m.cols ())
     (*current_liboctave_error_handler) ("eigs: A must be square");
   if (have_b && (m.rows () != b.rows () || m.rows () != b.cols ()))
     (*current_liboctave_error_handler)
       ("eigs: B must be square and the same size as A");
 
   if (cresid.isempty ())
     {
-      std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution ("uniform");
-      Array<double> rr (octave_rand::vector (n));
-      Array<double> ri (octave_rand::vector (n));
+      std::string rand_dist = octave::rand::distribution ();
+      octave::rand::distribution ("uniform");
+      Array<double> rr (octave::rand::vector (n));
+      Array<double> ri (octave::rand::vector (n));
       cresid = ComplexColumnVector (n);
       for (F77_INT i = 0; i < n; i++)
         cresid(i) = Complex (rr(i),ri(i));
-      octave_rand::distribution (rand_dist);
+      octave::rand::distribution (rand_dist);
     }
   else if (m.cols () != cresid.numel ())
     (*current_liboctave_error_handler) ("eigs: opts.v0 must be n-by-1");
 
   if (n < 3)
     (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (p < 0)
@@ -2826,24 +2826,24 @@ EigsComplexNonSymmetricMatrixShift (cons
   // FIXME: The "SM" type for mode 1 seems unstable though faster!!
   //if (! std::abs (sigma))
   //  return EigsComplexNonSymmetricMatrix (m, "SM", k, p, info, eig_vec,
   //                                      eig_val, _b, permB, cresid, os, tol,
   //                                      rvec, cholB, disp, maxit);
 
   if (cresid.isempty ())
     {
-      std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution ("uniform");
-      Array<double> rr (octave_rand::vector (n));
-      Array<double> ri (octave_rand::vector (n));
+      std::string rand_dist = octave::rand::distribution ();
+      octave::rand::distribution ("uniform");
+      Array<double> rr (octave::rand::vector (n));
+      Array<double> ri (octave::rand::vector (n));
       cresid = ComplexColumnVector (n);
       for (F77_INT i = 0; i < n; i++)
         cresid(i) = Complex (rr(i),ri(i));
-      octave_rand::distribution (rand_dist);
+      octave::rand::distribution (rand_dist);
     }
   else if (m.cols () != cresid.numel ())
     (*current_liboctave_error_handler) ("eigs: opts.v0 must be n-by-1");
 
   if (n < 3)
     (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (p < 0)
@@ -3134,24 +3134,24 @@ EigsComplexNonSymmetricFunc (EigsComplex
   std::string typ (_typ);
   bool have_sigma = (std::abs (sigma) ? true : false);
   char bmat = 'I';
   F77_INT mode = 1;
   int err = 0;
 
   if (cresid.isempty ())
     {
-      std::string rand_dist = octave_rand::distribution ();
-      octave_rand::distribution ("uniform");
-      Array<double> rr (octave_rand::vector (n));
-      Array<double> ri (octave_rand::vector (n));
+      std::string rand_dist = octave::rand::distribution ();
+      octave::rand::distribution ("uniform");
+      Array<double> rr (octave::rand::vector (n));
+      Array<double> ri (octave::rand::vector (n));
       cresid = ComplexColumnVector (n);
       for (F77_INT i = 0; i < n; i++)
         cresid(i) = Complex (rr(i),ri(i));
-      octave_rand::distribution (rand_dist);
+      octave::rand::distribution (rand_dist);
     }
   else if (n != cresid.numel ())
     (*current_liboctave_error_handler) ("eigs: opts.v0 must be n-by-1");
 
   if (n < 3)
     (*current_liboctave_error_handler) ("eigs: n must be at least 3");
 
   if (p < 0)
diff --git a/liboctave/numeric/oct-rand.cc b/liboctave/numeric/oct-rand.cc
--- a/liboctave/numeric/oct-rand.cc
+++ b/liboctave/numeric/oct-rand.cc
@@ -38,752 +38,757 @@ along with Octave; see the file COPYING.
 #include "oct-rand.h"
 #include "oct-time.h"
 #include "quit.h"
 #include "randgamma.h"
 #include "randmtzig.h"
 #include "randpoisson.h"
 #include "singleton-cleanup.h"
 
-octave_rand *octave_rand::instance = nullptr;
-
-octave_rand::octave_rand (void)
-  : current_distribution (uniform_dist), use_old_generators (false),
-    rand_states ()
-{
-  initialize_ranlib_generators ();
-
-  initialize_mersenne_twister ();
-}
-
-bool
-octave_rand::instance_ok (void)
+namespace octave
 {
-  bool retval = true;
-
-  if (! instance)
-    {
-      instance = new octave_rand ();
-
-      if (instance)
-        singleton_cleanup_list::add (cleanup_instance);
-    }
-
-  if (! instance)
-    (*current_liboctave_error_handler)
-      ("unable to create octave_rand object!");
-
-  return retval;
-}
-
-double
-octave_rand::do_seed (void)
-{
-  union d2i { double d; int32_t i[2]; };
-  union d2i u;
-
-  octave::mach_info::float_format ff = octave::mach_info::native_float_format ();
+  rand *rand::instance = nullptr;
 
-  switch (ff)
-    {
-    case octave::mach_info::flt_fmt_ieee_big_endian:
-      F77_FUNC (getsd, GETSD) (u.i[1], u.i[0]);
-      break;
-
-    default:
-      F77_FUNC (getsd, GETSD) (u.i[0], u.i[1]);
-      break;
-    }
-
-  return u.d;
-}
-
-static int32_t
-force_to_fit_range (int32_t i, int32_t lo, int32_t hi)
-{
-  assert (hi > lo && lo >= 0 && hi > lo);
-
-  i = (i > 0 ? i : -i);
+  rand::rand (void)
+    : current_distribution (uniform_dist), use_old_generators (false),
+      rand_states ()
+  {
+    initialize_ranlib_generators ();
 
-  if (i < lo)
-    i = lo;
-  else if (i > hi)
-    i = i % hi;
-
-  return i;
-}
-
-void
-octave_rand::do_seed (double s)
-{
-  use_old_generators = true;
-
-  int i0, i1;
-  union d2i { double d; int32_t i[2]; };
-  union d2i u;
-  u.d = s;
-
-  octave::mach_info::float_format ff = octave::mach_info::native_float_format ();
-
-  switch (ff)
-    {
-    case octave::mach_info::flt_fmt_ieee_big_endian:
-      i1 = force_to_fit_range (u.i[0], 1, 2147483563);
-      i0 = force_to_fit_range (u.i[1], 1, 2147483399);
-      break;
+    initialize_mersenne_twister ();
+  }
 
-    default:
-      i0 = force_to_fit_range (u.i[0], 1, 2147483563);
-      i1 = force_to_fit_range (u.i[1], 1, 2147483399);
-      break;
-    }
-
-  F77_FUNC (setsd, SETSD) (i0, i1);
-}
-
-void
-octave_rand::do_reset (void)
-{
-  use_old_generators = true;
-  initialize_ranlib_generators ();
-}
-
-uint32NDArray
-octave_rand::do_state (const std::string& d)
-{
-  return rand_states[d.empty () ? current_distribution : get_dist_id (d)];
-}
-
-void
-octave_rand::do_state (const uint32NDArray& s, const std::string& d)
-{
-  use_old_generators = false;
-
-  int old_dist = current_distribution;
-
-  int new_dist = (d.empty () ? current_distribution : get_dist_id (d));
-
-  uint32NDArray saved_state;
-
-  if (old_dist != new_dist)
-    saved_state = get_internal_state ();
-
-  set_internal_state (s);
-
-  rand_states[new_dist] = get_internal_state ();
-
-  if (old_dist != new_dist)
-    rand_states[old_dist] = saved_state;
-}
+  bool rand::instance_ok (void)
+  {
+    bool retval = true;
 
-void
-octave_rand::do_reset (const std::string& d)
-{
-  use_old_generators = false;
-
-  int old_dist = current_distribution;
-
-  int new_dist = (d.empty () ? current_distribution : get_dist_id (d));
-
-  uint32NDArray saved_state;
-
-  if (old_dist != new_dist)
-    saved_state = get_internal_state ();
-
-  oct_init_by_entropy ();
-  rand_states[new_dist] = get_internal_state ();
-
-  if (old_dist != new_dist)
-    rand_states[old_dist] = saved_state;
-}
+    if (! instance)
+      {
+        instance = new rand ();
 
-std::string
-octave_rand::do_distribution (void)
-{
-  std::string retval;
-
-  switch (current_distribution)
-    {
-    case uniform_dist:
-      retval = "uniform";
-      break;
+        if (instance)
+          singleton_cleanup_list::add (cleanup_instance);
+      }
 
-    case normal_dist:
-      retval = "normal";
-      break;
-
-    case expon_dist:
-      retval = "exponential";
-      break;
-
-    case poisson_dist:
-      retval = "poisson";
-      break;
-
-    case gamma_dist:
-      retval = "gamma";
-      break;
-
-    default:
+    if (! instance)
       (*current_liboctave_error_handler)
-        ("rand: invalid distribution ID = %d", current_distribution);
-      break;
-    }
+        ("unable to create rand object!");
+
+    return retval;
+  }
 
-  return retval;
-}
+  double rand::do_seed (void)
+  {
+    union d2i { double d; int32_t i[2]; };
+    union d2i u;
+
+    mach_info::float_format ff = mach_info::native_float_format ();
+
+    switch (ff)
+      {
+      case mach_info::flt_fmt_ieee_big_endian:
+        F77_FUNC (getsd, GETSD) (u.i[1], u.i[0]);
+        break;
 
-void
-octave_rand::do_distribution (const std::string& d)
-{
-  int id = get_dist_id (d);
+      default:
+        F77_FUNC (getsd, GETSD) (u.i[0], u.i[1]);
+        break;
+      }
+
+    return u.d;
+  }
 
-  switch (id)
-    {
-    case uniform_dist:
-      octave_rand::uniform_distribution ();
-      break;
+  static int32_t
+  force_to_fit_range (int32_t i, int32_t lo, int32_t hi)
+  {
+    assert (hi > lo && lo >= 0 && hi > lo);
+
+    i = (i > 0 ? i : -i);
+
+    if (i < lo)
+      i = lo;
+    else if (i > hi)
+      i = i % hi;
+
+    return i;
+  }
 
-    case normal_dist:
-      octave_rand::normal_distribution ();
-      break;
+  void rand::do_seed (double s)
+  {
+    use_old_generators = true;
+
+    int i0, i1;
+    union d2i { double d; int32_t i[2]; };
+    union d2i u;
+    u.d = s;
 
-    case expon_dist:
-      octave_rand::exponential_distribution ();
-      break;
+    mach_info::float_format ff = mach_info::native_float_format ();
+
+    switch (ff)
+      {
+      case mach_info::flt_fmt_ieee_big_endian:
+        i1 = force_to_fit_range (u.i[0], 1, 2147483563);
+        i0 = force_to_fit_range (u.i[1], 1, 2147483399);
+        break;
 
-    case poisson_dist:
-      octave_rand::poisson_distribution ();
-      break;
+      default:
+        i0 = force_to_fit_range (u.i[0], 1, 2147483563);
+        i1 = force_to_fit_range (u.i[1], 1, 2147483399);
+        break;
+      }
+
+    F77_FUNC (setsd, SETSD) (i0, i1);
+  }
 
-    case gamma_dist:
-      octave_rand::gamma_distribution ();
-      break;
+  void rand::do_reset (void)
+  {
+    use_old_generators = true;
+    initialize_ranlib_generators ();
+  }
 
-    default:
-      (*current_liboctave_error_handler)
-        ("rand: invalid distribution ID = %d", id);
-      break;
-    }
-}
+  uint32NDArray rand::do_state (const std::string& d)
+  {
+    return rand_states[d.empty () ? current_distribution : get_dist_id (d)];
+  }
+
+  void rand::do_state (const uint32NDArray& s, const std::string& d)
+  {
+    use_old_generators = false;
+
+    int old_dist = current_distribution;
 
-void
-octave_rand::do_uniform_distribution (void)
-{
-  switch_to_generator (uniform_dist);
+    int new_dist = (d.empty () ? current_distribution : get_dist_id (d));
+
+    uint32NDArray saved_state;
+
+    if (old_dist != new_dist)
+      saved_state = get_internal_state ();
+
+    set_internal_state (s);
 
-  F77_FUNC (setcgn, SETCGN) (uniform_dist);
-}
+    rand_states[new_dist] = get_internal_state ();
+
+    if (old_dist != new_dist)
+      rand_states[old_dist] = saved_state;
+  }
+
+  void rand::do_reset (const std::string& d)
+  {
+    use_old_generators = false;
 
-void
-octave_rand::do_normal_distribution (void)
-{
-  switch_to_generator (normal_dist);
+    int old_dist = current_distribution;
+
+    int new_dist = (d.empty () ? current_distribution : get_dist_id (d));
+
+    uint32NDArray saved_state;
+
+    if (old_dist != new_dist)
+      saved_state = get_internal_state ();
 
-  F77_FUNC (setcgn, SETCGN) (normal_dist);
-}
+    init_mersenne_twister ();
+    rand_states[new_dist] = get_internal_state ();
 
-void
-octave_rand::do_exponential_distribution (void)
-{
-  switch_to_generator (expon_dist);
+    if (old_dist != new_dist)
+      rand_states[old_dist] = saved_state;
+  }
+
+  std::string rand::do_distribution (void)
+  {
+    std::string retval;
 
-  F77_FUNC (setcgn, SETCGN) (expon_dist);
-}
+    switch (current_distribution)
+      {
+      case uniform_dist:
+        retval = "uniform";
+        break;
+
+      case normal_dist:
+        retval = "normal";
+        break;
 
-void
-octave_rand::do_poisson_distribution (void)
-{
-  switch_to_generator (poisson_dist);
+      case expon_dist:
+        retval = "exponential";
+        break;
 
-  F77_FUNC (setcgn, SETCGN) (poisson_dist);
-}
+      case poisson_dist:
+        retval = "poisson";
+        break;
+
+      case gamma_dist:
+        retval = "gamma";
+        break;
 
-void
-octave_rand::do_gamma_distribution (void)
-{
-  switch_to_generator (gamma_dist);
+      default:
+        (*current_liboctave_error_handler)
+          ("rand: invalid distribution ID = %d", current_distribution);
+        break;
+      }
+
+    return retval;
+  }
+
+  void rand::do_distribution (const std::string& d)
+  {
+    int id = get_dist_id (d);
 
-  F77_FUNC (setcgn, SETCGN) (gamma_dist);
-}
+    switch (id)
+      {
+      case uniform_dist:
+        rand::uniform_distribution ();
+        break;
 
-double
-octave_rand::do_scalar (double a)
-{
-  double retval = 0.0;
+      case normal_dist:
+        rand::normal_distribution ();
+        break;
+
+      case expon_dist:
+        rand::exponential_distribution ();
+        break;
 
-  if (use_old_generators)
-    {
-      switch (current_distribution)
-        {
-        case uniform_dist:
-          F77_FUNC (dgenunf, DGENUNF) (0.0, 1.0, retval);
-          break;
+      case poisson_dist:
+        rand::poisson_distribution ();
+        break;
+
+      case gamma_dist:
+        rand::gamma_distribution ();
+        break;
+
+      default:
+        (*current_liboctave_error_handler)
+          ("rand: invalid distribution ID = %d", id);
+        break;
+      }
+  }
+
+  void rand::do_uniform_distribution (void)
+  {
+    switch_to_generator (uniform_dist);
 
-        case normal_dist:
-          F77_FUNC (dgennor, DGENNOR) (0.0, 1.0, retval);
-          break;
+    F77_FUNC (setcgn, SETCGN) (uniform_dist);
+  }
+
+  void rand::do_normal_distribution (void)
+  {
+    switch_to_generator (normal_dist);
+
+    F77_FUNC (setcgn, SETCGN) (normal_dist);
+  }
 
-        case expon_dist:
-          F77_FUNC (dgenexp, DGENEXP) (1.0, retval);
-          break;
+  void rand::do_exponential_distribution (void)
+  {
+    switch_to_generator (expon_dist);
+
+    F77_FUNC (setcgn, SETCGN) (expon_dist);
+  }
+
+  void rand::do_poisson_distribution (void)
+  {
+    switch_to_generator (poisson_dist);
+
+    F77_FUNC (setcgn, SETCGN) (poisson_dist);
+  }
 
-        case poisson_dist:
-          if (a < 0.0 || ! octave::math::isfinite (a))
-            retval = octave::numeric_limits<double>::NaN ();
-          else
-            {
-              // workaround bug in ignpoi, by calling with different Mu
-              F77_FUNC (dignpoi, DIGNPOI) (a + 1, retval);
-              F77_FUNC (dignpoi, DIGNPOI) (a, retval);
-            }
-          break;
+  void rand::do_gamma_distribution (void)
+  {
+    switch_to_generator (gamma_dist);
+
+    F77_FUNC (setcgn, SETCGN) (gamma_dist);
+  }
+
+  template <>
+  double rand::uniform<double> (void)
+  {
+    double retval;
+
+    if (use_old_generators)
+      F77_FUNC (dgenunf, DGENUNF) (0.0, 1.0, retval);
+    else
+      retval = octave::rand_uniform<double> ();
+
+    return retval;
+  }
 
-        case gamma_dist:
-          if (a <= 0.0 || ! octave::math::isfinite (a))
-            retval = octave::numeric_limits<double>::NaN ();
-          else
-            F77_FUNC (dgengam, DGENGAM) (1.0, a, retval);
-          break;
+  template <>
+  double rand::normal<double> (void)
+  {
+    double retval;
+
+    if (use_old_generators)
+      F77_FUNC (dgennor, DGENNOR) (0.0, 1.0, retval);
+    else
+      retval = octave::rand_normal<double> ();
 
-        default:
-          (*current_liboctave_error_handler)
-            ("rand: invalid distribution ID = %d", current_distribution);
-          break;
-        }
-    }
-  else
-    {
-      switch (current_distribution)
-        {
-        case uniform_dist:
-          retval = oct_randu ();
-          break;
+    return retval;
+  }
+
+  template <>
+  double rand::exponential<double> (void)
+  {
+    double retval;
+
+    if (use_old_generators)
+      F77_FUNC (dgenexp, DGENEXP) (1.0, retval);
+    else
+      retval = octave::rand_exponential<double> ();
 
-        case normal_dist:
-          retval = oct_randn ();
-          break;
+    return retval;
+  }
 
-        case expon_dist:
-          retval = oct_rande ();
-          break;
+  template <>
+  double rand::poisson<double> (double a)
+  {
+    double retval;
 
-        case poisson_dist:
-          retval = oct_randp (a);
-          break;
+    if (use_old_generators)
+      {
+        if (a < 0.0 || ! math::isfinite (a))
+          retval = numeric_limits<double>::NaN ();
+        else
+          {
+            // workaround bug in ignpoi, by calling with different Mu
+            F77_FUNC (dignpoi, DIGNPOI) (a + 1, retval);
+            F77_FUNC (dignpoi, DIGNPOI) (a, retval);
+          }
+      }
+    else
+      retval = octave::rand_poisson<double> (a);
+
+    return retval;
+  }
 
-        case gamma_dist:
-          retval = oct_randg (a);
-          break;
+  template <>
+  double rand::gamma<double> (double a)
+  {
+    double retval;
 
-        default:
-          (*current_liboctave_error_handler)
-            ("rand: invalid distribution ID = %d", current_distribution);
-          break;
-        }
+    if (use_old_generators)
+      {
+        if (a <= 0.0 || ! math::isfinite (a))
+          retval = numeric_limits<double>::NaN ();
+        else
+          F77_FUNC (dgengam, DGENGAM) (1.0, a, retval);
+      }
+    else
+      retval = octave::rand_gamma<double> (a);
+
+    return retval;
+  }
 
-      save_state ();
-    }
+  template <>
+  float rand::uniform<float> (void)
+  {
+    float retval;
 
-  return retval;
-}
+    if (use_old_generators)
+      F77_FUNC (fgenunf, FGENUNF) (0.0f, 1.0f, retval);
+    else
+      retval = octave::rand_uniform<float> ();
 
-float
-octave_rand::do_float_scalar (float a)
-{
-  float retval = 0.0;
+    return retval;
+  }
+
+  template <>
+  float rand::normal<float> (void)
+  {
+    float retval;
 
-  if (use_old_generators)
-    {
-      switch (current_distribution)
-        {
-        case uniform_dist:
-          F77_FUNC (fgenunf, FGENUNF) (0.0f, 1.0f, retval);
-          break;
+    if (use_old_generators)
+      F77_FUNC (fgennor, FGENNOR) (0.0f, 1.0f, retval);
+    else
+      retval = octave::rand_normal<float> ();
+
+    return retval;
+  }
+
+  template <>
+  float rand::exponential<float> (void)
+  {
+    float retval;
 
-        case normal_dist:
-          F77_FUNC (fgennor, FGENNOR) (0.0f, 1.0f, retval);
-          break;
+    if (use_old_generators)
+      F77_FUNC (fgenexp, FGENEXP) (1.0f, retval);
+    else
+      retval = octave::rand_exponential<float> ();
 
-        case expon_dist:
-          F77_FUNC (fgenexp, FGENEXP) (1.0f, retval);
-          break;
+    return retval;
+  }
+
+  template <>
+  float rand::poisson<float> (float a)
+  {
+    float retval;
 
-        case poisson_dist:
-          if (a < 0.0f || ! octave::math::isfinite (a))
-            retval = octave::numeric_limits<float>::NaN ();
-          else
-            {
-              // workaround bug in ignpoi, by calling with different Mu
-              F77_FUNC (fignpoi, FIGNPOI) (a + 1, retval);
-              F77_FUNC (fignpoi, FIGNPOI) (a, retval);
-            }
-          break;
+    if (use_old_generators)
+      {
+        if (a < 0.0f || ! math::isfinite (a))
+          retval = numeric_limits<float>::NaN ();
+        else
+          {
+            // workaround bug in ignpoi, by calling with different Mu
+            F77_FUNC (fignpoi, FIGNPOI) (a + 1, retval);
+            F77_FUNC (fignpoi, FIGNPOI) (a, retval);
+          }
+      }
+    else
+      {
+        // Keep poisson distribution in double precision for accuracy
+        retval = octave::rand_poisson<double> (a);
+      }
+
+    return retval;
+  }
 
-        case gamma_dist:
-          if (a <= 0.0f || ! octave::math::isfinite (a))
-            retval = octave::numeric_limits<float>::NaN ();
-          else
-            F77_FUNC (fgengam, FGENGAM) (1.0, a, retval);
-          break;
+  template <>
+  float rand::gamma<float> (float a)
+  {
+    float retval;
+
+    if (use_old_generators)
+      {
+        if (a <= 0.0f || ! math::isfinite (a))
+          retval = numeric_limits<float>::NaN ();
+        else
+          F77_FUNC (fgengam, FGENGAM) (1.0f, a, retval);
+      }
+    else
+      retval = octave::rand_gamma<float> (a);
+
+    return retval;
+  }
+
+  template <typename T>
+  T rand::do_scalar (T a)
+  {
+    T retval = 0;
 
-        default:
-          (*current_liboctave_error_handler)
-            ("rand: invalid distribution ID = %d", current_distribution);
-          break;
-        }
-    }
-  else
-    {
-      switch (current_distribution)
-        {
-        case uniform_dist:
-          retval = oct_float_randu ();
-          break;
+    switch (current_distribution)
+      {
+      case uniform_dist:
+        retval = uniform<T> ();
+        break;
+
+      case normal_dist:
+        retval = normal<T> ();
+        break;
+
+      case expon_dist:
+        retval = exponential<T> ();
+        break;
+
+      case poisson_dist:
+        retval = poisson<T> (a);
+        break;
+
+      case gamma_dist:
+        retval = gamma<T> (a);
+        break;
 
-        case normal_dist:
-          retval = oct_float_randn ();
-          break;
+      default:
+        (*current_liboctave_error_handler)
+          ("rand: invalid distribution ID = %d", current_distribution);
+        break;
+      }
+
+    if (! use_old_generators)
+      save_state ();
+
+    return retval;
+  }
 
-        case expon_dist:
-          retval = oct_float_rande ();
-          break;
+  template double rand::do_scalar<double> (double);
+  template float rand::do_scalar<float> (float);
 
-        case poisson_dist:
-          // Keep poisson distribution in double precision for accuracy
-          retval = oct_randp (a);
-          break;
+  template <typename T>
+  Array<T>
+  rand::do_vector (octave_idx_type n, T a)
+  {
+    Array<T> retval;
+
+    if (n > 0)
+      {
+        retval.clear (n, 1);
 
-        case gamma_dist:
-          retval = oct_float_randg (a);
-          break;
+        fill (retval.numel (), retval.fortran_vec (), a);
+      }
+    else if (n < 0)
+      (*current_liboctave_error_handler) ("rand: invalid negative argument");
+
+    return retval;
+  }
+
+  template Array<double> rand::do_vector<double> (octave_idx_type, double);
+  template Array<float> rand::do_vector<float> (octave_idx_type, float);
 
-        default:
-          (*current_liboctave_error_handler)
-            ("rand: invalid distribution ID = %d", current_distribution);
-          break;
-        }
+  NDArray rand::do_nd_array (const dim_vector& dims, double a)
+  {
+    NDArray retval;
+
+    if (! dims.all_zero ())
+      {
+        retval.clear (dims);
+
+        fill (retval.numel (), retval.fortran_vec (), a);
+      }
 
-      save_state ();
-    }
+    return retval;
+  }
 
-  return retval;
-}
+  FloatNDArray rand::do_float_nd_array (const dim_vector& dims, float a)
+  {
+    FloatNDArray retval;
+
+    if (! dims.all_zero ())
+      {
+        retval.clear (dims);
 
-Array<double>
-octave_rand::do_vector (octave_idx_type n, double a)
-{
-  Array<double> retval;
+        fill (retval.numel (), retval.fortran_vec (), a);
+      }
 
-  if (n > 0)
-    {
-      retval.clear (n, 1);
+    return retval;
+  }
+
+  // Make the random number generator give us a different sequence every
+  // time we start octave unless we specifically set the seed.  The
+  // technique used below will cycle monthly, but it does seem to
+  // work ok to give fairly different seeds each time Octave starts.
 
-      fill (retval.numel (), retval.fortran_vec (), a);
-    }
-  else if (n < 0)
-    (*current_liboctave_error_handler) ("rand: invalid negative argument");
+  void rand::initialize_ranlib_generators (void)
+  {
+    sys::localtime tm;
+    int stored_distribution = current_distribution;
+    F77_FUNC (setcgn, SETCGN) (uniform_dist);
+
+    int hour = tm.hour () + 1;
+    int minute = tm.min () + 1;
+    int second = tm.sec () + 1;
 
-  return retval;
-}
+    int32_t s0 = tm.mday () * hour * minute * second;
+    int32_t s1 = hour * minute * second;
+
+    s0 = force_to_fit_range (s0, 1, 2147483563);
+    s1 = force_to_fit_range (s1, 1, 2147483399);
+
+    F77_FUNC (setall, SETALL) (s0, s1);
+    F77_FUNC (setcgn, SETCGN) (stored_distribution);
+  }
+
+  void rand::initialize_mersenne_twister (void)
+  {
+    uint32NDArray s;
 
-Array<float>
-octave_rand::do_float_vector (octave_idx_type n, float a)
-{
-  Array<float> retval;
+    init_mersenne_twister ();
+    s = get_internal_state ();
+    rand_states[uniform_dist] = s;
+
+    init_mersenne_twister ();
+    s = get_internal_state ();
+    rand_states[normal_dist] = s;
+
+    init_mersenne_twister ();
+    s = get_internal_state ();
+    rand_states[expon_dist] = s;
 
-  if (n > 0)
-    {
-      retval.clear (n, 1);
+    init_mersenne_twister ();
+    s = get_internal_state ();
+    rand_states[poisson_dist] = s;
+
+    init_mersenne_twister ();
+    s = get_internal_state ();
+    rand_states[gamma_dist] = s;
 
-      fill (retval.numel (), retval.fortran_vec (), a);
-    }
-  else if (n < 0)
-    (*current_liboctave_error_handler) ("rand: invalid negative argument");
+    // All of the initializations above have messed with the internal state.
+    // Restore the state of the currently selected distribution.
+    set_internal_state (rand_states[current_distribution]);
+  }
 
-  return retval;
-}
+  uint32NDArray rand::get_internal_state (void)
+  {
+    uint32NDArray s (dim_vector (MT_N + 1, 1));
 
-NDArray
-octave_rand::do_nd_array (const dim_vector& dims, double a)
-{
-  NDArray retval;
+    get_mersenne_twister_state (reinterpret_cast<uint32_t *> (s.fortran_vec ()));
+
+    return s;
+  }
 
-  if (! dims.all_zero ())
-    {
-      retval.clear (dims);
+  void rand::save_state (void)
+  {
+    rand_states[current_distribution] = get_internal_state ();;
+  }
+
+  int rand::get_dist_id (const std::string& d)
+  {
+    int retval = unknown_dist;
 
-      fill (retval.numel (), retval.fortran_vec (), a);
-    }
+    if (d == "uniform" || d == "rand")
+      retval = uniform_dist;
+    else if (d == "normal" || d == "randn")
+      retval = normal_dist;
+    else if (d == "exponential" || d == "rande")
+      retval = expon_dist;
+    else if (d == "poisson" || d == "randp")
+      retval = poisson_dist;
+    else if (d == "gamma" || d == "randg")
+      retval = gamma_dist;
+    else
+      (*current_liboctave_error_handler)
+        ("rand: invalid distribution '%s'", d.c_str ());
 
-  return retval;
-}
+    return retval;
+  }
 
-FloatNDArray
-octave_rand::do_float_nd_array (const dim_vector& dims, float a)
-{
-  FloatNDArray retval;
+  void rand::set_internal_state (const uint32NDArray& s)
+  {
+    octave_idx_type len = s.numel ();
+
+    const uint32_t *sdata = reinterpret_cast <const uint32_t *> (s.data ());
 
-  if (! dims.all_zero ())
-    {
-      retval.clear (dims);
+    if (len == MT_N + 1 && sdata[MT_N] <= MT_N && sdata[MT_N] > 0)
+      set_mersenne_twister_state (sdata);
+    else
+      init_mersenne_twister (sdata, len);
+  }
 
-      fill (retval.numel (), retval.fortran_vec (), a);
-    }
+  void rand::switch_to_generator (int dist)
+  {
+    if (dist != current_distribution)
+      {
+        current_distribution = dist;
 
-  return retval;
-}
+        set_internal_state (rand_states[dist]);
+      }
+  }
+
+  void rand::fill (octave_idx_type len, double *v, double a)
+  {
+    if (len < 1)
+      return;
 
-// Make the random number generator give us a different sequence every
-// time we start octave unless we specifically set the seed.  The
-// technique used below will cycle monthly, but it does seem to
-// work ok to give fairly different seeds each time Octave starts.
+    switch (current_distribution)
+      {
+      case uniform_dist:
+        if (use_old_generators)
+          std::generate_n (v, len, [](void) { double x; F77_FUNC (dgenunf, DGENUNF) (0.0, 1.0, x); return x; });
+        else
+          rand_uniform<double> (len, v);
+        break;
 
-void
-octave_rand::initialize_ranlib_generators (void)
-{
-  octave::sys::localtime tm;
-  int stored_distribution = current_distribution;
-  F77_FUNC (setcgn, SETCGN) (uniform_dist);
+      case normal_dist:
+        if (use_old_generators)
+          std::generate_n (v, len, [](void) { double x; F77_FUNC (dgennor, DGENNOR) (0.0, 1.0, x); return x; });
+        else
+          rand_normal<double> (len, v);
+        break;
 
-  int hour = tm.hour () + 1;
-  int minute = tm.min () + 1;
-  int second = tm.sec () + 1;
+      case expon_dist:
+        if (use_old_generators)
+          std::generate_n (v, len, [](void) { double x; F77_FUNC (dgenexp, DGENEXP) (1.0, x); return x; });
+        else
+          rand_exponential<double> (len, v);
+        break;
 
-  int32_t s0 = tm.mday () * hour * minute * second;
-  int32_t s1 = hour * minute * second;
-
-  s0 = force_to_fit_range (s0, 1, 2147483563);
-  s1 = force_to_fit_range (s1, 1, 2147483399);
-
-  F77_FUNC (setall, SETALL) (s0, s1);
-  F77_FUNC (setcgn, SETCGN) (stored_distribution);
-}
+      case poisson_dist:
+        if (use_old_generators)
+          {
+            if (a < 0.0 || ! math::isfinite (a))
+              std::fill_n (v, len, numeric_limits<double>::NaN ());
+            else
+              {
+                // workaround bug in ignpoi, by calling with different Mu
+                double tmp;
+                F77_FUNC (dignpoi, DIGNPOI) (a + 1, tmp);
+                std::generate_n (v, len, [a](void) { double x; F77_FUNC (dignpoi, DIGNPOI) (a, x); return x; });
+              }
+          }
+        else
+          rand_poisson<double> (a, len, v);
+        break;
 
-void
-octave_rand::initialize_mersenne_twister (void)
-{
-  uint32NDArray s;
+      case gamma_dist:
+        if (use_old_generators)
+          {
+            if (a <= 0.0 || ! math::isfinite (a))
+              std::fill_n (v, len, numeric_limits<double>::NaN ());
+            else
+              std::generate_n (v, len, [a](void) { double x; F77_FUNC (dgengam, DGENGAM) (1.0, a, x); return x; });
+          }
+        else
+          rand_gamma<double> (a, len, v);
+        break;
+
+      default:
+        (*current_liboctave_error_handler)
+          ("rand: invalid distribution ID = %d", current_distribution);
+        break;
+      }
 
-  oct_init_by_entropy ();
-  s = get_internal_state ();
-  rand_states[uniform_dist] = s;
+    save_state ();
+
+    return;
+  }
 
-  oct_init_by_entropy ();
-  s = get_internal_state ();
-  rand_states[normal_dist] = s;
+  void rand::fill (octave_idx_type len, float *v, float a)
+  {
+    if (len < 1)
+      return;
+
+    switch (current_distribution)
+      {
+      case uniform_dist:
+        if (use_old_generators)
+          std::generate_n (v, len, [](void) { float x; F77_FUNC (fgenunf, FGENUNF) (0.0f, 1.0f, x); return x; });
+        else
+          octave::rand_uniform<float> (len, v);
+        break;
 
-  oct_init_by_entropy ();
-  s = get_internal_state ();
-  rand_states[expon_dist] = s;
+      case normal_dist:
+        if (use_old_generators)
+          std::generate_n (v, len, [](void) { float x; F77_FUNC (fgennor, FGENNOR) (0.0f, 1.0f, x); return x; });
+        else
+          octave::rand_normal<float> (len, v);
+        break;
 
-  oct_init_by_entropy ();
-  s = get_internal_state ();
-  rand_states[poisson_dist] = s;
-
-  oct_init_by_entropy ();
-  s = get_internal_state ();
-  rand_states[gamma_dist] = s;
+      case expon_dist:
+        if (use_old_generators)
+          std::generate_n (v, len, [](void) { float x; F77_FUNC (fgenexp, FGENEXP) (1.0f, x); return x; });
+        else
+          octave::rand_exponential<float> (len, v);
+        break;
 
-  // All of the initializations above have messed with the internal state.
-  // Restore the state of the currently selected distribution.
-  set_internal_state (rand_states[current_distribution]);
-}
+      case poisson_dist:
+        if (use_old_generators)
+          {
+            if (a < 0.0f || ! math::isfinite (a))
+              std::fill_n (v, len, numeric_limits<float>::NaN ());
+            else
+              {
+                // workaround bug in ignpoi, by calling with different Mu
+                float tmp;
+                F77_FUNC (fignpoi, FIGNPOI) (a + 1, tmp);
+                std::generate_n (v, len, [a](void) { float x; F77_FUNC (fignpoi, FIGNPOI) (a, x); return x; });
+              }
+          }
+        else
+          octave::rand_poisson<float> (a, len, v);
+        break;
 
-uint32NDArray
-octave_rand::get_internal_state (void)
-{
-  uint32NDArray s (dim_vector (MT_N + 1, 1));
+      case gamma_dist:
+        if (use_old_generators)
+          {
+            if (a <= 0.0f || ! math::isfinite (a))
+              std::fill_n (v, len, numeric_limits<float>::NaN ());
+            else
+              std::generate_n (v, len, [a](void) { float x; F77_FUNC (fgengam, FGENGAM) (1.0f, a, x); return x; });
+          }
+        else
+          octave::rand_gamma<float> (a, len, v);
+        break;
 
-  oct_get_state (reinterpret_cast<uint32_t *> (s.fortran_vec ()));
+      default:
+        (*current_liboctave_error_handler)
+          ("rand: invalid distribution ID = %d", current_distribution);
+        break;
+      }
 
-  return s;
+    save_state ();
+
+    return;
+  }
 }
-
-void
-octave_rand::save_state (void)
-{
-  rand_states[current_distribution] = get_internal_state ();;
-}
-
-int
-octave_rand::get_dist_id (const std::string& d)
-{
-  int retval = unknown_dist;
-
-  if (d == "uniform" || d == "rand")
-    retval = uniform_dist;
-  else if (d == "normal" || d == "randn")
-    retval = normal_dist;
-  else if (d == "exponential" || d == "rande")
-    retval = expon_dist;
-  else if (d == "poisson" || d == "randp")
-    retval = poisson_dist;
-  else if (d == "gamma" || d == "randg")
-    retval = gamma_dist;
-  else
-    (*current_liboctave_error_handler)
-      ("rand: invalid distribution '%s'", d.c_str ());
-
-  return retval;
-}
-
-void
-octave_rand::set_internal_state (const uint32NDArray& s)
-{
-  octave_idx_type len = s.numel ();
-
-  const uint32_t *sdata = reinterpret_cast <const uint32_t *> (s.data ());
-
-  if (len == MT_N + 1 && sdata[MT_N] <= MT_N && sdata[MT_N] > 0)
-    oct_set_state (sdata);
-  else
-    oct_init_by_array (sdata, len);
-}
-
-void
-octave_rand::switch_to_generator (int dist)
-{
-  if (dist != current_distribution)
-    {
-      current_distribution = dist;
-
-      set_internal_state (rand_states[dist]);
-    }
-}
-
-void
-octave_rand::fill (octave_idx_type len, double *v, double a)
-{
-  if (len < 1)
-    return;
-
-  switch (current_distribution)
-    {
-    case uniform_dist:
-      if (use_old_generators)
-        std::generate_n (v, len, [](void) { double x; F77_FUNC (dgenunf, DGENUNF) (0.0, 1.0, x); return x; });
-      else
-        oct_fill_randu (len, v);
-      break;
-
-    case normal_dist:
-      if (use_old_generators)
-        std::generate_n (v, len, [](void) { double x; F77_FUNC (dgennor, DGENNOR) (0.0, 1.0, x); return x; });
-      else
-        oct_fill_randn (len, v);
-      break;
-
-    case expon_dist:
-      if (use_old_generators)
-        std::generate_n (v, len, [](void) { double x; F77_FUNC (dgenexp, DGENEXP) (1.0, x); return x; });
-      else
-        oct_fill_rande (len, v);
-      break;
-
-    case poisson_dist:
-      if (use_old_generators)
-        {
-          if (a < 0.0 || ! octave::math::isfinite (a))
-            std::fill_n (v, len, octave::numeric_limits<double>::NaN ());
-          else
-            {
-              // workaround bug in ignpoi, by calling with different Mu
-              double tmp;
-              F77_FUNC (dignpoi, DIGNPOI) (a + 1, tmp);
-              std::generate_n (v, len, [a](void) { double x; F77_FUNC (dignpoi, DIGNPOI) (a, x); return x; });
-            }
-        }
-      else
-        oct_fill_randp (a, len, v);
-      break;
-
-    case gamma_dist:
-      if (use_old_generators)
-        {
-          if (a <= 0.0 || ! octave::math::isfinite (a))
-            std::fill_n (v, len, octave::numeric_limits<double>::NaN ());
-          else
-            std::generate_n (v, len, [a](void) { double x; F77_FUNC (dgengam, DGENGAM) (1.0, a, x); return x; });
-        }
-      else
-        oct_fill_randg (a, len, v);
-      break;
-
-    default:
-      (*current_liboctave_error_handler)
-        ("rand: invalid distribution ID = %d", current_distribution);
-      break;
-    }
-
-  save_state ();
-
-  return;
-}
-
-void
-octave_rand::fill (octave_idx_type len, float *v, float a)
-{
-  if (len < 1)
-    return;
-
-  switch (current_distribution)
-    {
-    case uniform_dist:
-      if (use_old_generators)
-        std::generate_n (v, len, [](void) { float x; F77_FUNC (fgenunf, FGENUNF) (0.0f, 1.0f, x); return x; });
-      else
-        oct_fill_float_randu (len, v);
-      break;
-
-    case normal_dist:
-      if (use_old_generators)
-        std::generate_n (v, len, [](void) { float x; F77_FUNC (fgennor, FGENNOR) (0.0f, 1.0f, x); return x; });
-      else
-        oct_fill_float_randn (len, v);
-      break;
-
-    case expon_dist:
-      if (use_old_generators)
-        std::generate_n (v, len, [](void) { float x; F77_FUNC (fgenexp, FGENEXP) (1.0f, x); return x; });
-      else
-        oct_fill_float_rande (len, v);
-      break;
-
-    case poisson_dist:
-      if (use_old_generators)
-        {
-          if (a < 0.0f || ! octave::math::isfinite (a))
-            std::fill_n (v, len, octave::numeric_limits<float>::NaN ());
-          else
-            {
-              // workaround bug in ignpoi, by calling with different Mu
-              float tmp;
-              F77_FUNC (fignpoi, FIGNPOI) (a + 1, tmp);
-              std::generate_n (v, len, [a](void) { float x; F77_FUNC (fignpoi, FIGNPOI) (a, x); return x; });
-            }
-        }
-      else
-        oct_fill_float_randp (a, len, v);
-      break;
-
-    case gamma_dist:
-      if (use_old_generators)
-        {
-          if (a <= 0.0f || ! octave::math::isfinite (a))
-            std::fill_n (v, len, octave::numeric_limits<float>::NaN ());
-          else
-            std::generate_n (v, len, [a](void) { float x; F77_FUNC (fgengam, FGENGAM) (1.0f, a, x); return x; });
-        }
-      else
-        oct_fill_float_randg (a, len, v);
-      break;
-
-    default:
-      (*current_liboctave_error_handler)
-        ("rand: invalid distribution ID = %d", current_distribution);
-      break;
-    }
-
-  save_state ();
-
-  return;
-}
diff --git a/liboctave/numeric/oct-rand.h b/liboctave/numeric/oct-rand.h
--- a/liboctave/numeric/oct-rand.h
+++ b/liboctave/numeric/oct-rand.h
@@ -31,252 +31,267 @@ along with Octave; see the file COPYING.
 #include "Array.h"
 #include "dNDArray.h"
 #include "fNDArray.h"
 #include "lo-ieee.h"
 #include "uint32NDArray.h"
 
 //class dim_vector;
 
-class
-OCTAVE_API
-octave_rand
+namespace octave
 {
-protected:
-
-  octave_rand (void);
-
-public:
-
-  ~octave_rand (void) = default;
-
-  static bool instance_ok (void);
-
-  // Return the current seed.
-  static double seed (void)
-  {
-    return instance_ok () ? instance->do_seed ()
-                          : octave::numeric_limits<double>::NaN ();
-  }
-
-  // Set the seed.
-  static void seed (double s)
-  {
-    if (instance_ok ())
-      instance->do_seed (s);
-  }
-
-  // Reset the seed.
-  static void reset (void)
-  {
-    if (instance_ok ())
-      instance->do_reset ();
-  }
-
-  // Return the current state.
-  static uint32NDArray state (const std::string& d = "")
-  {
-    return instance_ok () ? instance->do_state (d) : uint32NDArray ();
-  }
-
-  // Set the current state/
-  static void state (const uint32NDArray& s,
-                     const std::string& d = "")
-  {
-    if (instance_ok ())
-      instance->do_state (s, d);
-  }
-
-  // Reset the current state/
-  static void reset (const std::string& d)
-  {
-    if (instance_ok ())
-      instance->do_reset (d);
-  }
-
-  // Return the current distribution.
-  static std::string distribution (void)
+  class OCTAVE_API rand
   {
-    return instance_ok () ? instance->do_distribution () : "";
-  }
+  protected:
+
+    rand (void);
+
+  public:
+
+    ~rand (void) = default;
+
+    static bool instance_ok (void);
 
-  // Set the current distribution.  May be either "uniform" (the
-  // default), "normal", "exponential", "poisson", or "gamma".
-  static void distribution (const std::string& d)
-  {
-    if (instance_ok ())
-      instance->do_distribution (d);
-  }
+    // Return the current seed.
+    static double seed (void)
+    {
+      return instance_ok () ? instance->do_seed ()
+        : octave::numeric_limits<double>::NaN ();
+    }
+
+    // Set the seed.
+    static void seed (double s)
+    {
+      if (instance_ok ())
+        instance->do_seed (s);
+    }
 
-  static void uniform_distribution (void)
-  {
-    if (instance_ok ())
-      instance->do_uniform_distribution ();
-  }
+    // Reset the seed.
+    static void reset (void)
+    {
+      if (instance_ok ())
+        instance->do_reset ();
+    }
+
+    // Return the current state.
+    static uint32NDArray state (const std::string& d = "")
+    {
+      return instance_ok () ? instance->do_state (d) : uint32NDArray ();
+    }
 
-  static void normal_distribution (void)
-  {
-    if (instance_ok ())
-      instance->do_normal_distribution ();
-  }
+    // Set the current state/
+    static void state (const uint32NDArray& s,
+                       const std::string& d = "")
+    {
+      if (instance_ok ())
+        instance->do_state (s, d);
+    }
 
-  static void exponential_distribution (void)
-  {
-    if (instance_ok ())
-      instance->do_exponential_distribution ();
-  }
+    // Reset the current state/
+    static void reset (const std::string& d)
+    {
+      if (instance_ok ())
+        instance->do_reset (d);
+    }
+
+    // Return the current distribution.
+    static std::string distribution (void)
+    {
+      return instance_ok () ? instance->do_distribution () : "";
+    }
 
-  static void poisson_distribution (void)
-  {
-    if (instance_ok ())
-      instance->do_poisson_distribution ();
-  }
+    // Set the current distribution.  May be either "uniform" (the
+    // default), "normal", "exponential", "poisson", or "gamma".
+    static void distribution (const std::string& d)
+    {
+      if (instance_ok ())
+        instance->do_distribution (d);
+    }
+
+    static void uniform_distribution (void)
+    {
+      if (instance_ok ())
+        instance->do_uniform_distribution ();
+    }
 
-  static void gamma_distribution (void)
-  {
-    if (instance_ok ())
-      instance->do_gamma_distribution ();
-  }
+    static void normal_distribution (void)
+    {
+      if (instance_ok ())
+        instance->do_normal_distribution ();
+    }
+
+    static void exponential_distribution (void)
+    {
+      if (instance_ok ())
+        instance->do_exponential_distribution ();
+    }
+
+    static void poisson_distribution (void)
+    {
+      if (instance_ok ())
+        instance->do_poisson_distribution ();
+    }
 
-  // Return the next number from the sequence.
-  static double scalar (double a = 1.0)
-  {
-    return instance_ok () ? instance->do_scalar (a)
-                          : octave::numeric_limits<double>::NaN ();
-  }
+    static void gamma_distribution (void)
+    {
+      if (instance_ok ())
+        instance->do_gamma_distribution ();
+    }
+
+    // Return the next number from the sequence.
+    static double scalar (double a = 1.0)
+    {
+      return instance_ok () ? instance->do_scalar (a)
+        : octave::numeric_limits<double>::NaN ();
+    }
 
-  // Return the next number from the sequence.
-  static float float_scalar (float a = 1.0)
-  {
-    return instance_ok () ? instance->do_float_scalar (a)
-                          : octave::numeric_limits<float>::NaN ();
-  }
+    // Return the next number from the sequence.
+    static float float_scalar (float a = 1.0)
+    {
+      return instance_ok () ? instance->do_scalar (a)
+        : octave::numeric_limits<float>::NaN ();
+    }
 
-  // Return an array of numbers from the sequence.
-  static Array<double> vector (octave_idx_type n, double a = 1.0)
-  {
-    return instance_ok () ? instance->do_vector (n, a) : Array<double> ();
-  }
+    // Return an array of numbers from the sequence.
+    static Array<double> vector (octave_idx_type n, double a = 1.0)
+    {
+      return instance_ok () ? instance->do_vector (n, a) : Array<double> ();
+    }
+
+    // Return an array of numbers from the sequence.
+    static Array<float> float_vector (octave_idx_type n, float a = 1.0)
+    {
+      return instance_ok () ? instance->do_vector (n, a) : Array<float> ();
+    }
 
-  // Return an array of numbers from the sequence.
-  static Array<float> float_vector (octave_idx_type n, float a = 1.0)
-  {
-    return instance_ok () ? instance->do_float_vector (n, a) : Array<float> ();
-  }
+    // Return an N-dimensional array of numbers from the sequence,
+    // filled in column major order.
+    static NDArray nd_array (const dim_vector& dims, double a = 1.0)
+    {
+      return instance_ok () ? instance->do_nd_array (dims, a) : NDArray ();
+    }
 
-  // Return an N-dimensional array of numbers from the sequence,
-  // filled in column major order.
-  static NDArray nd_array (const dim_vector& dims, double a = 1.0)
-  {
-    return instance_ok () ? instance->do_nd_array (dims, a) : NDArray ();
-  }
+    // Return an N-dimensional array of numbers from the sequence,
+    // filled in column major order.
+    static FloatNDArray float_nd_array (const dim_vector& dims, float a = 1.0)
+    {
+      return instance_ok () ? instance->do_float_nd_array (dims, a)
+        : FloatNDArray ();
+    }
 
-  // Return an N-dimensional array of numbers from the sequence,
-  // filled in column major order.
-  static FloatNDArray float_nd_array (const dim_vector& dims, float a = 1.0)
-  {
-    return instance_ok () ? instance->do_float_nd_array (dims, a)
-                          : FloatNDArray ();
-  }
+  private:
+
+    static rand *instance;
+
+    static void cleanup_instance (void) { delete instance; instance = nullptr; }
 
-private:
-
-  static octave_rand *instance;
-
-  static void cleanup_instance (void) { delete instance; instance = nullptr; }
+    enum
+    {
+      unknown_dist,
+      uniform_dist,
+      normal_dist,
+      expon_dist,
+      poisson_dist,
+      gamma_dist
+    };
 
-  enum
-  {
-    unknown_dist,
-    uniform_dist,
-    normal_dist,
-    expon_dist,
-    poisson_dist,
-    gamma_dist
-  };
+    // Current distribution of random numbers.
+    int current_distribution;
 
-  // Current distribution of random numbers.
-  int current_distribution;
+    // If TRUE, use old RANLIB generators.  Otherwise, use Mersenne
+    // Twister generator.
+    bool use_old_generators;
+
+    // Saved MT states.
+    std::map<int, uint32NDArray> rand_states;
+
+    // Return the current seed.
+    double do_seed (void);
 
-  // If TRUE, use old RANLIB generators.  Otherwise, use Mersenne
-  // Twister generator.
-  bool use_old_generators;
+    // Set the seed.
+    void do_seed (double s);
 
-  // Saved MT states.
-  std::map<int, uint32NDArray> rand_states;
+    // Reset the seed.
+    void do_reset ();
+
+    // Return the current state.
+    uint32NDArray do_state (const std::string& d);
 
-  // Return the current seed.
-  double do_seed (void);
-
-  // Set the seed.
-  void do_seed (double s);
+    // Set the current state/
+    void do_state (const uint32NDArray& s, const std::string& d);
 
-  // Reset the seed.
-  void do_reset ();
+    // Reset the current state/
+    void do_reset (const std::string& d);
 
-  // Return the current state.
-  uint32NDArray do_state (const std::string& d);
+    // Return the current distribution.
+    std::string do_distribution (void);
 
-  // Set the current state/
-  void do_state (const uint32NDArray& s, const std::string& d);
+    // Set the current distribution.  May be either "uniform" (the
+    // default), "normal", "exponential", "poisson", or "gamma".
+    void do_distribution (const std::string& d);
 
-  // Reset the current state/
-  void do_reset (const std::string& d);
+    void do_uniform_distribution (void);
 
-  // Return the current distribution.
-  std::string do_distribution (void);
+    void do_normal_distribution (void);
+
+    void do_exponential_distribution (void);
 
-  // Set the current distribution.  May be either "uniform" (the
-  // default), "normal", "exponential", "poisson", or "gamma".
-  void do_distribution (const std::string& d);
+    void do_poisson_distribution (void);
 
-  void do_uniform_distribution (void);
+    void do_gamma_distribution (void);
 
-  void do_normal_distribution (void);
-
-  void do_exponential_distribution (void);
+    // The following templates only make sense for double and float
+    // types.
 
-  void do_poisson_distribution (void);
+    template <typename T> T uniform (void);
 
-  void do_gamma_distribution (void);
+    template <typename T> T normal (void);
+
+    template <typename T> T exponential (void);
 
-  // Return the next number from the sequence.
-  double do_scalar (double a = 1.);
+    template <typename T> T poisson (T a);
+
+    template <typename T> T gamma (T a);
 
-  // Return the next number from the sequence.
-  float do_float_scalar (float a = 1.);
+    // Return the next number from the sequence.
+    template <typename T> T do_scalar (T a = 1);
 
-  // Return an array of numbers from the sequence.
-  Array<double> do_vector (octave_idx_type n, double a = 1.);
+    // Return an array of numbers from the sequence.
+    template <typename T> Array<T> do_vector (octave_idx_type n, T a = 1);
 
-  // Return an array of numbers from the sequence.
-  Array<float> do_float_vector (octave_idx_type n, float a = 1.);
+    // Return an N-dimensional array of numbers from the sequence,
+    // filled in column major order.
+    NDArray do_nd_array (const dim_vector& dims, double a = 1.);
 
-  // Return an N-dimensional array of numbers from the sequence,
-  // filled in column major order.
-  NDArray do_nd_array (const dim_vector& dims, double a = 1.);
+    // Return an N-dimensional array of numbers from the sequence,
+    // filled in column major order.
+    FloatNDArray do_float_nd_array (const dim_vector& dims, float a = 1.);
 
-  // Return an N-dimensional array of numbers from the sequence,
-  // filled in column major order.
-  FloatNDArray do_float_nd_array (const dim_vector& dims, float a = 1.);
+    // Some helper functions.
+
+    void initialize_ranlib_generators (void);
 
-  // Some helper functions.
+    void initialize_mersenne_twister (void);
 
-  void initialize_ranlib_generators (void);
+    uint32NDArray get_internal_state (void);
 
-  void initialize_mersenne_twister (void);
+    void save_state (void);
 
-  uint32NDArray get_internal_state (void);
+    int get_dist_id (const std::string& d);
 
-  void save_state (void);
+    void set_internal_state (const uint32NDArray& s);
 
-  int get_dist_id (const std::string& d);
+    void switch_to_generator (int dist);
 
-  void set_internal_state (const uint32NDArray& s);
-
-  void switch_to_generator (int dist);
+    void fill (octave_idx_type len, double *v, double a);
 
-  void fill (octave_idx_type len, double *v, double a);
+    void fill (octave_idx_type len, float *v, float a);
+  };
+}
 
-  void fill (octave_idx_type len, float *v, float a);
-};
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand' instead")
+typedef octave::rand octave_rand;
 
 #endif
+
+#endif
diff --git a/liboctave/numeric/randgamma.cc b/liboctave/numeric/randgamma.cc
--- a/liboctave/numeric/randgamma.cc
+++ b/liboctave/numeric/randgamma.cc
@@ -82,115 +82,103 @@ Dirichlet(a1,...,ak) for ai > 0
 #endif
 
 #include <cmath>
 
 #include "lo-ieee.h"
 #include "randgamma.h"
 #include "randmtzig.h"
 
-#define INFINITE lo_ieee_isinf
-#define RUNI oct_randu()
-#define RNOR oct_randn()
-#define REXP oct_rande()
-
-void
-oct_fill_randg (double a, octave_idx_type n, double *r)
+namespace octave
 {
-  octave_idx_type i;
-  /* If a < 1, start by generating gamma (1+a) */
-  const double d = (a < 1. ? 1.+a : a) - 1./3.;
-  const double c = 1./std::sqrt (9.*d);
+
+#define INFINITE lo_ieee_isinf
+#define RUNI rand_uniform<double> ()
+#define RNOR rand_normal<double> ()
+#define REXP rand_exponential<double> ()
 
-  /* Handle invalid cases */
-  if (a <= 0 || INFINITE(a))
-    {
-      for (i=0; i < n; i++)
-        r[i] = octave::numeric_limits<double>::NaN ();
-      return;
-    }
+  template <> void rand_gamma<double> (double a, octave_idx_type n, double *r)
+  {
+    octave_idx_type i;
+    /* If a < 1, start by generating gamma (1+a) */
+    const double d = (a < 1. ? 1.+a : a) - 1./3.;
+    const double c = 1./std::sqrt (9.*d);
+
+    /* Handle invalid cases */
+    if (a <= 0 || INFINITE(a))
+      {
+        for (i=0; i < n; i++)
+          r[i] = numeric_limits<double>::NaN ();
+        return;
+      }
 
-  for (i=0; i < n; i++)
-    {
-      double x, xsq, v, u;
-    restart:
-      x = RNOR;
-      v = (1+c*x);
-      v *= v*v;
-      if (v <= 0)
-        goto restart; /* rare, so don't bother moving up */
-      u = RUNI;
-      xsq = x*x;
-      if (u >= 1.-0.0331*xsq*xsq && std::log (u) >= 0.5*xsq + d*(1-v+std::log (v)))
-        goto restart;
-      r[i] = d*v;
-    }
-  if (a < 1)
-    {
-      /* Use gamma(a) = gamma(1+a)*U^(1/a) */
-      /* Given REXP = -log(U) then U^(1/a) = exp(-REXP/a) */
-      for (i = 0; i < n; i++)
-        r[i] *= exp (-REXP/a);
-    }
-}
-
-double
-oct_randg (double a)
-{
-  double ret;
-  oct_fill_randg (a,1,&ret);
-  return ret;
-}
+    for (i=0; i < n; i++)
+      {
+        double x, xsq, v, u;
+      restart:
+        x = RNOR;
+        v = (1+c*x);
+        v *= v*v;
+        if (v <= 0)
+          goto restart; /* rare, so don't bother moving up */
+        u = RUNI;
+        xsq = x*x;
+        if (u >= 1.-0.0331*xsq*xsq && std::log (u) >= 0.5*xsq + d*(1-v+std::log (v)))
+          goto restart;
+        r[i] = d*v;
+      }
+    if (a < 1)
+      {
+        /* Use gamma(a) = gamma(1+a)*U^(1/a) */
+        /* Given REXP = -log(U) then U^(1/a) = exp(-REXP/a) */
+        for (i = 0; i < n; i++)
+          r[i] *= exp (-REXP/a);
+      }
+  }
 
 #undef RUNI
 #undef RNOR
 #undef REXP
-#define RUNI oct_float_randu()
-#define RNOR oct_float_randn()
-#define REXP oct_float_rande()
+
+#define RUNI rand_uniform<float> ()
+#define RNOR rand_normal<float> ()
+#define REXP rand_exponential<float> ()
 
-void
-oct_fill_float_randg (float a, octave_idx_type n, float *r)
-{
-  octave_idx_type i;
-  /* If a < 1, start by generating gamma(1+a) */
-  const float d = (a < 1. ? 1.+a : a) - 1./3.;
-  const float c = 1./std::sqrt (9.*d);
+  template <> void rand_gamma<float> (float a, octave_idx_type n, float *r)
+  {
+    octave_idx_type i;
+    /* If a < 1, start by generating gamma(1+a) */
+    const float d = (a < 1. ? 1.+a : a) - 1./3.;
+    const float c = 1./std::sqrt (9.*d);
 
-  /* Handle invalid cases */
-  if (a <= 0 || INFINITE(a))
-    {
-      for (i=0; i < n; i++)
-        r[i] = octave::numeric_limits<float>::NaN ();
-      return;
-    }
+    /* Handle invalid cases */
+    if (a <= 0 || INFINITE(a))
+      {
+        for (i=0; i < n; i++)
+          r[i] = numeric_limits<float>::NaN ();
+        return;
+      }
 
-  for (i=0; i < n; i++)
-    {
-      float x, xsq, v, u;
-    frestart:
-      x = RNOR;
-      v = (1+c*x);
-      v *= v*v;
-      if (v <= 0)
-        goto frestart; /* rare, so don't bother moving up */
-      u = RUNI;
-      xsq = x*x;
-      if (u >= 1.-0.0331*xsq*xsq && std::log (u) >= 0.5*xsq + d*(1-v+std::log (v)))
-        goto frestart;
-      r[i] = d*v;
-    }
-  if (a < 1)
-    {
-      /* Use gamma(a) = gamma(1+a)*U^(1/a) */
-      /* Given REXP = -log(U) then U^(1/a) = exp(-REXP/a) */
-      for (i = 0; i < n; i++)
-        r[i] *= exp (-REXP/a);
-    }
+    for (i=0; i < n; i++)
+      {
+        float x, xsq, v, u;
+      frestart:
+        x = RNOR;
+        v = (1+c*x);
+        v *= v*v;
+        if (v <= 0)
+          goto frestart; /* rare, so don't bother moving up */
+        u = RUNI;
+        xsq = x*x;
+        if (u >= 1.-0.0331*xsq*xsq && std::log (u) >= 0.5*xsq + d*(1-v+std::log (v)))
+          goto frestart;
+        r[i] = d*v;
+      }
+    if (a < 1)
+      {
+        /* Use gamma(a) = gamma(1+a)*U^(1/a) */
+        /* Given REXP = -log(U) then U^(1/a) = exp(-REXP/a) */
+        for (i = 0; i < n; i++)
+          r[i] *= exp (-REXP/a);
+      }
+  }
+
 }
-
-float
-oct_float_randg (float a)
-{
-  float ret;
-  oct_fill_float_randg (a,1,&ret);
-  return ret;
-}
diff --git a/liboctave/numeric/randgamma.h b/liboctave/numeric/randgamma.h
--- a/liboctave/numeric/randgamma.h
+++ b/liboctave/numeric/randgamma.h
@@ -23,16 +23,59 @@ along with Octave; see the file COPYING.
 /* Original version written by Paul Kienzle distributed as free
    software in the in the public domain.  */
 
 #if ! defined (octave_randgamma_h)
 #define octave_randgamma_h 1
 
 #include "octave-config.h"
 
-extern OCTAVE_API double oct_randg (double a);
-extern OCTAVE_API void oct_fill_randg (double a, octave_idx_type n, double *p);
+namespace octave
+{
+  template <typename T>
+  void
+  rand_gamma (T a, octave_idx_type n, T *p);
+
+  template <> void
+  rand_gamma<double> (double a, octave_idx_type n, double  *p);
+
+  template <> void
+  rand_gamma<float> (float a, octave_idx_type n, float  *p);
+
+  template <typename T>
+  T
+  rand_gamma (T a)
+  {
+    T retval;
+    rand_gamma (a, 1, &retval);
+    return retval;
+  }
+}
 
-extern OCTAVE_API float oct_float_randg (float a);
-extern OCTAVE_API void oct_fill_float_randg (float a, octave_idx_type n,
-                                             float *p);
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_gamma<double>' instead")
+inline double
+oct_randg (double a)
+{
+  return octave::rand_gamma (a);
+}
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_gamma<float>' instead")
+inline float
+oct_float_randg (float a)
+{
+  return octave::rand_gamma (a);
+}
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_gamma<double>' instead")
+inline void
+oct_fill_randg (double a, octave_idx_type n, double *p)
+{
+  octave::rand_gamma (a, n, p);
+}
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_gamma<float>' instead")
+inline void
+oct_fill_float_randg (float a, octave_idx_type n, float *p)
+{
+  octave::rand_gamma (a, n, p);
+}
 
 #endif
diff --git a/liboctave/numeric/randmtzig.cc b/liboctave/numeric/randmtzig.cc
--- a/liboctave/numeric/randmtzig.cc
+++ b/liboctave/numeric/randmtzig.cc
@@ -107,51 +107,53 @@ along with Octave; see the file COPYING.
    extra performance. Check whether -DUSE_X86_32=0 is faster on 64-bit
    x86 architectures.
 
    If you want to replace the Mersenne Twister with another
    generator then redefine randi32 appropriately.
 
    === Usage instructions ===
    Before using any of the generators, initialize the state with one of
-   oct_init_by_int, oct_init_by_array or oct_init_by_entropy.
+   the init_mersenne_twister functions.
 
    All generators share the same state vector.
 
    === Mersenne Twister ===
-   void oct_init_by_int (uint32_t s)           32-bit initial state
-   void oct_init_by_array (uint32_t k[],int m) m*32-bit initial state
-   void oct_init_by_entropy (void)             random initial state
-   void oct_get_state (uint32_t save[MT_N+1])  saves state in array
-   void oct_set_state (uint32_t save[MT_N+1])  restores state from array
+   random initial state:
+   void init_mersenne_twister (void)
+
+   // 32-bit initial state:
+   void init_mersenne_twister (uint32_t s)
+
+   // m*32-bit initial state:
+   void init_mersenne_twister (uint32_t k[],int m)
+
+   // saves state in array:
+   void get_mersenne_twister_state (uint32_t save[MT_N+1])
+
+   // restores state from array
+   void set_mersenne_twister_state (uint32_t save[MT_N+1])
+
    static uint32_t randmt (void)               returns 32-bit unsigned int
 
    === inline generators ===
    static uint32_t randi32 (void)   returns 32-bit unsigned int
    static uint64_t randi53 (void)   returns 53-bit unsigned int
    static uint64_t randi54 (void)   returns 54-bit unsigned int
    static float randu32 (void)      returns 32-bit uniform in (0,1)
    static double randu53 (void)     returns 53-bit uniform in (0,1)
 
-   double oct_randu (void)       returns M-bit uniform in (0,1)
-   double oct_randn (void)       returns M-bit standard normal
-   double oct_rande (void)       returns N-bit standard exponential
-
-   float oct_float_randu (void)       returns M-bit uniform in (0,1)
-   float oct_float_randn (void)       returns M-bit standard normal
-   float oct_float_rande (void)       returns N-bit standard exponential
+   double rand_uniform (void)       returns M-bit uniform in (0,1)
+   double rand_normal (void)        returns M-bit standard normal
+   double rand_exponential (void)   returns N-bit standard exponential
 
    === Array generators ===
-   void oct_fill_randu (octave_idx_type, double [])
-   void oct_fill_randn (octave_idx_type, double [])
-   void oct_fill_rande (octave_idx_type, double [])
-
-   void oct_fill_float_randu (octave_idx_type, float [])
-   void oct_fill_float_randn (octave_idx_type, float [])
-   void oct_fill_float_rande (octave_idx_type, float [])
+   void rand_uniform (octave_idx_type, double [])
+   void rand_normal (octave_idx_type, double [])
+   void rand_exponential (octave_idx_type, double [])
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <cmath>
 #include <cstdio>
@@ -165,259 +167,252 @@ along with Octave; see the file COPYING.
 #if ! defined (USE_X86_32)
 #  if defined (i386) || defined (HAVE_X86_32)
 #    define USE_X86_32 1
 #  else
 #    define USE_X86_32 0
 #  endif
 #endif
 
-/* ===== Mersenne Twister 32-bit generator ===== */
+namespace octave
+{
+  /* ===== Mersenne Twister 32-bit generator ===== */
 
 #define MT_M 397
 #define MATRIX_A 0x9908b0dfUL   /* constant vector a */
 #define UMASK 0x80000000UL /* most significant w-r bits */
 #define LMASK 0x7fffffffUL /* least significant r bits */
 #define MIXBITS(u,v) ( ((u) & UMASK) | ((v) & LMASK) )
 #define TWIST(u,v) ((MIXBITS(u,v) >> 1) ^ ((v)&1UL ? MATRIX_A : 0UL))
 
-static uint32_t *next;
-static uint32_t state[MT_N]; /* the array for the state vector  */
-static int left = 1;
-static int initf = 0;
-static int initt = 1;
-static int inittf = 1;
+  static uint32_t *next;
+  static uint32_t state[MT_N]; /* the array for the state vector  */
+  static int left = 1;
+  static int initf = 0;
+  static int initt = 1;
+  static int inittf = 1;
 
-/* initializes state[MT_N] with a seed */
-void
-oct_init_by_int (const uint32_t s)
-{
-  int j;
-  state[0] = s & 0xffffffffUL;
-  for (j = 1; j < MT_N; j++)
-    {
-      state[j] = (1812433253UL * (state[j-1] ^ (state[j-1] >> 30)) + j);
-      /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
-      /* In the previous versions, MSBs of the seed affect   */
-      /* only MSBs of the array state[].                        */
-      /* 2002/01/09 modified by Makoto Matsumoto             */
-      state[j] &= 0xffffffffUL;  /* for >32 bit machines */
-    }
-  left = 1;
-  initf = 1;
-}
+  /* initializes state[MT_N] with a seed */
+  void init_mersenne_twister (const uint32_t s)
+  {
+    int j;
+    state[0] = s & 0xffffffffUL;
+    for (j = 1; j < MT_N; j++)
+      {
+        state[j] = (1812433253UL * (state[j-1] ^ (state[j-1] >> 30)) + j);
+        /* See Knuth TAOCP Vol2. 3rd Ed. P.106 for multiplier. */
+        /* In the previous versions, MSBs of the seed affect   */
+        /* only MSBs of the array state[].                        */
+        /* 2002/01/09 modified by Makoto Matsumoto             */
+        state[j] &= 0xffffffffUL;  /* for >32 bit machines */
+      }
+    left = 1;
+    initf = 1;
+  }
 
-/* initialize by an array with array-length */
-/* init_key is the array for initializing keys */
-/* key_length is its length */
-void
-oct_init_by_array (const uint32_t *init_key, const int key_length)
-{
-  int i, j, k;
-  oct_init_by_int (19650218UL);
-  i = 1;
-  j = 0;
-  k = (MT_N > key_length ? MT_N : key_length);
-  for (; k; k--)
-    {
-      state[i] = (state[i] ^ ((state[i-1] ^ (state[i-1] >> 30)) * 1664525UL))
-                 + init_key[j] + j; /* non linear */
-      state[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
-      i++;
-      j++;
-      if (i >= MT_N)
-        {
-          state[0] = state[MT_N-1];
-          i = 1;
-        }
-      if (j >= key_length)
-        j = 0;
-    }
-  for (k = MT_N - 1; k; k--)
-    {
-      state[i] = (state[i] ^ ((state[i-1] ^ (state[i-1] >> 30)) * 1566083941UL))
-                 - i; /* non linear */
-      state[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
-      i++;
-      if (i >= MT_N)
-        {
-          state[0] = state[MT_N-1];
-          i = 1;
-        }
-    }
+  /* initialize by an array with array-length */
+  /* init_key is the array for initializing keys */
+  /* key_length is its length */
+  void init_mersenne_twister (const uint32_t *init_key, const int key_length)
+  {
+    int i, j, k;
+    init_mersenne_twister (19650218UL);
+    i = 1;
+    j = 0;
+    k = (MT_N > key_length ? MT_N : key_length);
+    for (; k; k--)
+      {
+        state[i] = (state[i] ^ ((state[i-1] ^ (state[i-1] >> 30)) * 1664525UL))
+          + init_key[j] + j; /* non linear */
+        state[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
+        i++;
+        j++;
+        if (i >= MT_N)
+          {
+            state[0] = state[MT_N-1];
+            i = 1;
+          }
+        if (j >= key_length)
+          j = 0;
+      }
+    for (k = MT_N - 1; k; k--)
+      {
+        state[i] = (state[i] ^ ((state[i-1] ^ (state[i-1] >> 30)) * 1566083941UL))
+          - i; /* non linear */
+        state[i] &= 0xffffffffUL; /* for WORDSIZE > 32 machines */
+        i++;
+        if (i >= MT_N)
+          {
+            state[0] = state[MT_N-1];
+            i = 1;
+          }
+      }
 
-  state[0] = 0x80000000UL; /* MSB is 1; assuring nonzero initial array */
-  left = 1;
-  initf = 1;
-}
+    state[0] = 0x80000000UL; /* MSB is 1; assuring nonzero initial array */
+    left = 1;
+    initf = 1;
+  }
 
-void
-oct_init_by_entropy (void)
-{
-  uint32_t entropy[MT_N];
-  int n = 0;
+  void init_mersenne_twister (void)
+  {
+    uint32_t entropy[MT_N];
+    int n = 0;
 
-  /* Look for entropy in /dev/urandom */
-  FILE *urandom = std::fopen ("/dev/urandom", "rb");
-  if (urandom)
-    {
-      while (n < MT_N)
-        {
-          unsigned char word[4];
-          if (std::fread (word, 4, 1, urandom) != 1)
-            break;
-          entropy[n++] = word[0] + (word[1]<<8) + (word[2]<<16)
-                         + (static_cast<uint32_t> (word[3])<<24);
-        }
-      std::fclose (urandom);
-    }
+    /* Look for entropy in /dev/urandom */
+    FILE *urandom = std::fopen ("/dev/urandom", "rb");
+    if (urandom)
+      {
+        while (n < MT_N)
+          {
+            unsigned char word[4];
+            if (std::fread (word, 4, 1, urandom) != 1)
+              break;
+            entropy[n++] = word[0] + (word[1]<<8) + (word[2]<<16)
+              + (static_cast<uint32_t> (word[3])<<24);
+          }
+        std::fclose (urandom);
+      }
 
-  /* If there isn't enough entropy, gather some from various sources */
+    /* If there isn't enough entropy, gather some from various sources */
 
-  octave::sys::time now;
+    octave::sys::time now;
 
-  if (n < MT_N)
-    entropy[n++] = now.unix_time (); /* Current time in seconds */
+    if (n < MT_N)
+      entropy[n++] = now.unix_time (); /* Current time in seconds */
 
-  if (n < MT_N)
-    entropy[n++] = clock ();    /* CPU time used (usec) */
+    if (n < MT_N)
+      entropy[n++] = clock ();    /* CPU time used (usec) */
 
-  if (n < MT_N)
-    entropy[n++] = now.usec ();   /* Fractional part of current time */
+    if (n < MT_N)
+      entropy[n++] = now.usec ();   /* Fractional part of current time */
 
-  /* Send all the entropy into the initial state vector */
-  oct_init_by_array (entropy,n);
-}
+    /* Send all the entropy into the initial state vector */
+    init_mersenne_twister (entropy,n);
+  }
 
-void
-oct_set_state (const uint32_t *save)
-{
-  std::copy_n (save, MT_N, state);
-  left = save[MT_N];
-  next = state + (MT_N - left + 1);
-}
+  void set_mersenne_twister_state (const uint32_t *save)
+  {
+    std::copy_n (save, MT_N, state);
+    left = save[MT_N];
+    next = state + (MT_N - left + 1);
+  }
 
-void
-oct_get_state (uint32_t *save)
-{
-  std::copy_n (state, MT_N, save);
-  save[MT_N] = left;
-}
+  void get_mersenne_twister_state (uint32_t *save)
+  {
+    std::copy_n (state, MT_N, save);
+    save[MT_N] = left;
+  }
 
-static void
-next_state (void)
-{
-  uint32_t *p = state;
-  int j;
+  static void next_state (void)
+  {
+    uint32_t *p = state;
+    int j;
 
-  /* if init_by_int() has not been called, */
-  /* a default initial seed is used         */
-  /* if (initf==0) init_by_int(5489UL); */
-  /* Or better yet, a random seed! */
-  if (initf == 0)
-    oct_init_by_entropy ();
+    /* if init_by_int() has not been called, */
+    /* a default initial seed is used         */
+    /* if (initf==0) init_by_int(5489UL); */
+    /* Or better yet, a random seed! */
+    if (initf == 0)
+      init_mersenne_twister ();
 
-  left = MT_N;
-  next = state;
+    left = MT_N;
+    next = state;
 
-  for (j = MT_N - MT_M + 1; --j; p++)
-    *p = p[MT_M] ^ TWIST(p[0], p[1]);
+    for (j = MT_N - MT_M + 1; --j; p++)
+      *p = p[MT_M] ^ TWIST(p[0], p[1]);
 
-  for (j = MT_M; --j; p++)
-    *p = p[MT_M-MT_N] ^ TWIST(p[0], p[1]);
-
-  *p = p[MT_M-MT_N] ^ TWIST(p[0], state[0]);
-}
+    for (j = MT_M; --j; p++)
+      *p = p[MT_M-MT_N] ^ TWIST(p[0], p[1]);
 
-/* generates a random number on [0,0xffffffff]-interval */
-static uint32_t
-randmt (void)
-{
-  uint32_t y;
+    *p = p[MT_M-MT_N] ^ TWIST(p[0], state[0]);
+  }
+
+  /* generates a random number on [0,0xffffffff]-interval */
+  static uint32_t randmt (void)
+  {
+    uint32_t y;
 
-  if (--left == 0)
-    next_state ();
-  y = *next++;
+    if (--left == 0)
+      next_state ();
+    y = *next++;
 
-  /* Tempering */
-  y ^= (y >> 11);
-  y ^= (y << 7) & 0x9d2c5680UL;
-  y ^= (y << 15) & 0xefc60000UL;
-  return (y ^ (y >> 18));
-}
+    /* Tempering */
+    y ^= (y >> 11);
+    y ^= (y << 7) & 0x9d2c5680UL;
+    y ^= (y << 15) & 0xefc60000UL;
+    return (y ^ (y >> 18));
+  }
 
-/* ===== Uniform generators ===== */
+  /* ===== Uniform generators ===== */
 
-/* Select which 32 bit generator to use */
+  /* Select which 32 bit generator to use */
 #define randi32 randmt
 
-static uint64_t
-randi53 (void)
-{
-  const uint32_t lo = randi32 ();
-  const uint32_t hi = randi32 () & 0x1FFFFF;
+  static uint64_t randi53 (void)
+  {
+    const uint32_t lo = randi32 ();
+    const uint32_t hi = randi32 () & 0x1FFFFF;
 #if defined (HAVE_X86_32)
-  uint64_t u;
-  uint32_t *p = (uint32_t *)&u;
-  p[0] = lo;
-  p[1] = hi;
-  return u;
+    uint64_t u;
+    uint32_t *p = (uint32_t *)&u;
+    p[0] = lo;
+    p[1] = hi;
+    return u;
 #else
-  return ((static_cast<uint64_t> (hi) << 32) | lo);
+    return ((static_cast<uint64_t> (hi) << 32) | lo);
 #endif
-}
+  }
 
-static uint64_t
-randi54 (void)
-{
-  const uint32_t lo = randi32 ();
-  const uint32_t hi = randi32 () & 0x3FFFFF;
+  static uint64_t randi54 (void)
+  {
+    const uint32_t lo = randi32 ();
+    const uint32_t hi = randi32 () & 0x3FFFFF;
 #if defined (HAVE_X86_32)
-  uint64_t u;
-  uint32_t *p = static_cast<uint32_t *> (&u);
-  p[0] = lo;
-  p[1] = hi;
-  return u;
+    uint64_t u;
+    uint32_t *p = static_cast<uint32_t *> (&u);
+    p[0] = lo;
+    p[1] = hi;
+    return u;
 #else
-  return ((static_cast<uint64_t> (hi) << 32) | lo);
+    return ((static_cast<uint64_t> (hi) << 32) | lo);
 #endif
-}
+  }
 
-/* generates a random number on (0,1)-real-interval */
-static float
-randu32 (void)
-{
-  return (static_cast<float> (randi32 ()) + 0.5) * (1.0/4294967296.0);
-  /* divided by 2^32 */
-}
+  /* generates a random number on (0,1)-real-interval */
+  static float randu32 (void)
+  {
+    return (static_cast<float> (randi32 ()) + 0.5) * (1.0/4294967296.0);
+    /* divided by 2^32 */
+  }
+
+  /* generates a random number on (0,1) with 53-bit resolution */
+  static double randu53 (void)
+  {
+    const uint32_t a = randi32 () >> 5;
+    const uint32_t b = randi32 () >> 6;
+    return (a*67108864.0+b+0.4) * (1.0/9007199254740992.0);
+  }
 
-/* generates a random number on (0,1) with 53-bit resolution */
-static double
-randu53 (void)
-{
-  const uint32_t a = randi32 () >> 5;
-  const uint32_t b = randi32 () >> 6;
-  return (a*67108864.0+b+0.4) * (1.0/9007199254740992.0);
-}
+  /* Determine mantissa for uniform doubles */
+  template <>
+  double
+  rand_uniform<double> (void)
+  {
+    return randu53 ();
+  }
 
-/* Determine mantissa for uniform doubles */
-double
-oct_randu (void)
-{
-  return randu53 ();
-}
+  /* Determine mantissa for uniform floats */
+  template <>
+  float
+  rand_uniform<float> (void)
+  {
+    return randu32 ();
+  }
 
-/* Determine mantissa for uniform floats */
-float
-oct_float_randu (void)
-{
-  return randu32 ();
-}
-
-/* ===== Ziggurat normal and exponential generators ===== */
+  /* ===== Ziggurat normal and exponential generators ===== */
 
 #define ZIGGURAT_TABLE_SIZE 256
 
 #define ZIGGURAT_NOR_R 3.6541528853610088
 #define ZIGGURAT_NOR_INV_R 0.27366123732975828
 #define NOR_SECTION_AREA 0.00492867323399
 
 #define ZIGGURAT_EXP_R 7.69711747013104972
@@ -426,424 +421,414 @@ oct_float_randu (void)
 
 #define ZIGINT uint64_t
 #define EMANTISSA 9007199254740992.0  /* 53 bit mantissa */
 #define ERANDI randi53() /* 53 bits for mantissa */
 #define NMANTISSA EMANTISSA
 #define NRANDI randi54() /* 53 bits for mantissa + 1 bit sign */
 #define RANDU randu53()
 
-static ZIGINT ki[ZIGGURAT_TABLE_SIZE];
-static double wi[ZIGGURAT_TABLE_SIZE], fi[ZIGGURAT_TABLE_SIZE];
-static ZIGINT ke[ZIGGURAT_TABLE_SIZE];
-static double we[ZIGGURAT_TABLE_SIZE], fe[ZIGGURAT_TABLE_SIZE];
+  static ZIGINT ki[ZIGGURAT_TABLE_SIZE];
+  static double wi[ZIGGURAT_TABLE_SIZE], fi[ZIGGURAT_TABLE_SIZE];
+  static ZIGINT ke[ZIGGURAT_TABLE_SIZE];
+  static double we[ZIGGURAT_TABLE_SIZE], fe[ZIGGURAT_TABLE_SIZE];
+
+  /*
+    This code is based on the paper Marsaglia and Tsang, "The ziggurat method
+    for generating random variables", Journ. Statistical Software. Code was
+    presented in this paper for a Ziggurat of 127 levels and using a 32 bit
+    integer random number generator. This version of the code, uses the
+    Mersenne Twister as the integer generator and uses 256 levels in the
+    Ziggurat. This has several advantages.
 
-/*
-This code is based on the paper Marsaglia and Tsang, "The ziggurat method
-for generating random variables", Journ. Statistical Software. Code was
-presented in this paper for a Ziggurat of 127 levels and using a 32 bit
-integer random number generator. This version of the code, uses the
-Mersenne Twister as the integer generator and uses 256 levels in the
-Ziggurat. This has several advantages.
+    1) As Marsaglia and Tsang themselves states, the more levels the few
+    times the expensive tail algorithm must be called
+    2) The cycle time of the generator is determined by the integer
+    generator, thus the use of a Mersenne Twister for the core random
+    generator makes this cycle extremely long.
+    3) The license on the original code was unclear, thus rewriting the code
+    from the article means we are free of copyright issues.
+    4) Compile flag for full 53-bit random mantissa.
 
-  1) As Marsaglia and Tsang themselves states, the more levels the few
-     times the expensive tail algorithm must be called
-  2) The cycle time of the generator is determined by the integer
-     generator, thus the use of a Mersenne Twister for the core random
-     generator makes this cycle extremely long.
-  3) The license on the original code was unclear, thus rewriting the code
-     from the article means we are free of copyright issues.
-  4) Compile flag for full 53-bit random mantissa.
+    It should be stated that the authors made my life easier, by the fact that
+    the algorithm developed in the text of the article is for a 256 level
+    ziggurat, even if the code itself isn't...
 
-It should be stated that the authors made my life easier, by the fact that
-the algorithm developed in the text of the article is for a 256 level
-ziggurat, even if the code itself isn't...
-
-One modification to the algorithm developed in the article, is that it is
-assumed that 0 <= x < Inf, and "unsigned long"s are used, thus resulting in
-terms like 2^32 in the code. As the normal distribution is defined between
--Inf < x < Inf, we effectively only have 31 bit integers plus a sign. Thus
-in Marsaglia and Tsang, terms like 2^32 become 2^31. We use NMANTISSA for
-this term.  The exponential distribution is one sided so we use the
-full 32 bits.  We use EMANTISSA for this term.
+    One modification to the algorithm developed in the article, is that it is
+    assumed that 0 <= x < Inf, and "unsigned long"s are used, thus resulting in
+    terms like 2^32 in the code. As the normal distribution is defined between
+    -Inf < x < Inf, we effectively only have 31 bit integers plus a sign. Thus
+    in Marsaglia and Tsang, terms like 2^32 become 2^31. We use NMANTISSA for
+    this term.  The exponential distribution is one sided so we use the
+    full 32 bits.  We use EMANTISSA for this term.
 
-It appears that I'm slightly slower than the code in the article, this
-is partially due to a better generator of random integers than they
-use. But might also be that the case of rapid return was optimized by
-inlining the relevant code with a #define. As the basic Mersenne
-Twister is only 25% faster than this code I suspect that the main
-reason is just the use of the Mersenne Twister and not the inlining,
-so I'm not going to try and optimize further.
-*/
+    It appears that I'm slightly slower than the code in the article, this
+    is partially due to a better generator of random integers than they
+    use. But might also be that the case of rapid return was optimized by
+    inlining the relevant code with a #define. As the basic Mersenne
+    Twister is only 25% faster than this code I suspect that the main
+    reason is just the use of the Mersenne Twister and not the inlining,
+    so I'm not going to try and optimize further.
+  */
 
-static void
-create_ziggurat_tables (void)
-{
-  int i;
-  double x, x1;
+  void create_ziggurat_tables (void)
+  {
+    int i;
+    double x, x1;
+
+    /* Ziggurat tables for the normal distribution */
+    x1 = ZIGGURAT_NOR_R;
+    wi[255] = x1 / NMANTISSA;
+    fi[255] = exp (-0.5 * x1 * x1);
 
-  /* Ziggurat tables for the normal distribution */
-  x1 = ZIGGURAT_NOR_R;
-  wi[255] = x1 / NMANTISSA;
-  fi[255] = exp (-0.5 * x1 * x1);
-
-  /* Index zero is special for tail strip, where Marsaglia and Tsang
-   * defines this as
-   * k_0 = 2^31 * r * f(r) / v, w_0 = 0.5^31 * v / f(r), f_0 = 1,
-   * where v is the area of each strip of the ziggurat.
-   */
-  ki[0] = static_cast<ZIGINT> (x1 * fi[255] / NOR_SECTION_AREA * NMANTISSA);
-  wi[0] = NOR_SECTION_AREA / fi[255] / NMANTISSA;
-  fi[0] = 1.;
+    /* Index zero is special for tail strip, where Marsaglia and Tsang
+     * defines this as
+     * k_0 = 2^31 * r * f(r) / v, w_0 = 0.5^31 * v / f(r), f_0 = 1,
+     * where v is the area of each strip of the ziggurat.
+     */
+    ki[0] = static_cast<ZIGINT> (x1 * fi[255] / NOR_SECTION_AREA * NMANTISSA);
+    wi[0] = NOR_SECTION_AREA / fi[255] / NMANTISSA;
+    fi[0] = 1.;
 
-  for (i = 254; i > 0; i--)
-    {
-      /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
-       * need inverse operator of y = exp(-0.5*x*x) -> x = sqrt(-2*ln(y))
-       */
-      x = std::sqrt (-2. * std::log (NOR_SECTION_AREA / x1 + fi[i+1]));
-      ki[i+1] = static_cast<ZIGINT> (x / x1 * NMANTISSA);
-      wi[i] = x / NMANTISSA;
-      fi[i] = exp (-0.5 * x * x);
-      x1 = x;
-    }
+    for (i = 254; i > 0; i--)
+      {
+        /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
+         * need inverse operator of y = exp(-0.5*x*x) -> x = sqrt(-2*ln(y))
+         */
+        x = std::sqrt (-2. * std::log (NOR_SECTION_AREA / x1 + fi[i+1]));
+        ki[i+1] = static_cast<ZIGINT> (x / x1 * NMANTISSA);
+        wi[i] = x / NMANTISSA;
+        fi[i] = exp (-0.5 * x * x);
+        x1 = x;
+      }
 
-  ki[1] = 0;
+    ki[1] = 0;
 
-  /* Zigurrat tables for the exponential distribution */
-  x1 = ZIGGURAT_EXP_R;
-  we[255] = x1 / EMANTISSA;
-  fe[255] = exp (-x1);
+    /* Zigurrat tables for the exponential distribution */
+    x1 = ZIGGURAT_EXP_R;
+    we[255] = x1 / EMANTISSA;
+    fe[255] = exp (-x1);
 
-  /* Index zero is special for tail strip, where Marsaglia and Tsang
-   * defines this as
-   * k_0 = 2^32 * r * f(r) / v, w_0 = 0.5^32 * v / f(r), f_0 = 1,
-   * where v is the area of each strip of the ziggurat.
-   */
-  ke[0] = static_cast<ZIGINT> (x1 * fe[255] / EXP_SECTION_AREA * EMANTISSA);
-  we[0] = EXP_SECTION_AREA / fe[255] / EMANTISSA;
-  fe[0] = 1.;
+    /* Index zero is special for tail strip, where Marsaglia and Tsang
+     * defines this as
+     * k_0 = 2^32 * r * f(r) / v, w_0 = 0.5^32 * v / f(r), f_0 = 1,
+     * where v is the area of each strip of the ziggurat.
+     */
+    ke[0] = static_cast<ZIGINT> (x1 * fe[255] / EXP_SECTION_AREA * EMANTISSA);
+    we[0] = EXP_SECTION_AREA / fe[255] / EMANTISSA;
+    fe[0] = 1.;
 
-  for (i = 254; i > 0; i--)
-    {
-      /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
-       * need inverse operator of y = exp(-x) -> x = -ln(y)
-       */
-      x = - std::log (EXP_SECTION_AREA / x1 + fe[i+1]);
-      ke[i+1] = static_cast<ZIGINT> (x / x1 * EMANTISSA);
-      we[i] = x / EMANTISSA;
-      fe[i] = exp (-x);
-      x1 = x;
-    }
-  ke[1] = 0;
+    for (i = 254; i > 0; i--)
+      {
+        /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
+         * need inverse operator of y = exp(-x) -> x = -ln(y)
+         */
+        x = - std::log (EXP_SECTION_AREA / x1 + fe[i+1]);
+        ke[i+1] = static_cast<ZIGINT> (x / x1 * EMANTISSA);
+        we[i] = x / EMANTISSA;
+        fe[i] = exp (-x);
+        x1 = x;
+      }
+    ke[1] = 0;
 
-  initt = 0;
-}
+    initt = 0;
+  }
 
-/*
- * Here is the guts of the algorithm. As Marsaglia and Tsang state the
- * algorithm in their paper
- *
- * 1) Calculate a random signed integer j and let i be the index
- *     provided by the rightmost 8-bits of j
- * 2) Set x = j * w_i. If j < k_i return x
- * 3) If i = 0, then return x from the tail
- * 4) If [f(x_{i-1}) - f(x_i)] * U < f(x) - f(x_i), return x
- * 5) goto step 1
- *
- * Where f is the functional form of the distribution, which for a normal
- * distribution is exp(-0.5*x*x)
- */
+  /*
+   * Here is the guts of the algorithm. As Marsaglia and Tsang state the
+   * algorithm in their paper
+   *
+   * 1) Calculate a random signed integer j and let i be the index
+   *     provided by the rightmost 8-bits of j
+   * 2) Set x = j * w_i. If j < k_i return x
+   * 3) If i = 0, then return x from the tail
+   * 4) If [f(x_{i-1}) - f(x_i)] * U < f(x) - f(x_i), return x
+   * 5) goto step 1
+   *
+   * Where f is the functional form of the distribution, which for a normal
+   * distribution is exp(-0.5*x*x)
+   */
 
-double
-oct_randn (void)
-{
-  if (initt)
-    create_ziggurat_tables ();
+
+  template <> double rand_normal<double> (void)
+  {
+    if (initt)
+      create_ziggurat_tables ();
 
-  while (1)
-    {
-      /* The following code is specialized for 32-bit mantissa.
-       * Compared to the arbitrary mantissa code, there is a performance
-       * gain for 32-bits:  PPC: 2%, MIPS: 8%, x86: 40%
-       * There is a bigger performance gain compared to using a full
-       * 53-bit mantissa:  PPC: 60%, MIPS: 65%, x86: 240%
-       * Of course, different compilers and operating systems may
-       * have something to do with this.
-       */
+    while (1)
+      {
+        /* The following code is specialized for 32-bit mantissa.
+         * Compared to the arbitrary mantissa code, there is a performance
+         * gain for 32-bits:  PPC: 2%, MIPS: 8%, x86: 40%
+         * There is a bigger performance gain compared to using a full
+         * 53-bit mantissa:  PPC: 60%, MIPS: 65%, x86: 240%
+         * Of course, different compilers and operating systems may
+         * have something to do with this.
+         */
 # if defined (HAVE_X86_32)
-      /* 53-bit mantissa, 1-bit sign, x86 32-bit architecture */
-      double x;
-      int si,idx;
-      uint32_t lo, hi;
-      int64_t rabs;
-      uint32_t *p = (uint32_t *)&rabs;
-      lo = randi32 ();
-      idx = lo & 0xFF;
-      hi = randi32 ();
-      si = hi & UMASK;
-      p[0] = lo;
-      p[1] = hi & 0x1FFFFF;
-      x = ( si ? -rabs : rabs ) * wi[idx];
+        /* 53-bit mantissa, 1-bit sign, x86 32-bit architecture */
+        double x;
+        int si,idx;
+        uint32_t lo, hi;
+        int64_t rabs;
+        uint32_t *p = (uint32_t *)&rabs;
+        lo = randi32 ();
+        idx = lo & 0xFF;
+        hi = randi32 ();
+        si = hi & UMASK;
+        p[0] = lo;
+        p[1] = hi & 0x1FFFFF;
+        x = ( si ? -rabs : rabs ) * wi[idx];
 # else
-      /* arbitrary mantissa (selected by NRANDI, with 1 bit for sign) */
-      const uint64_t r = NRANDI;
-      const int64_t rabs = r >> 1;
-      const int idx = static_cast<int> (rabs & 0xFF);
-      const double x = ( (r & 1) ? -rabs : rabs) * wi[idx];
+        /* arbitrary mantissa (selected by NRANDI, with 1 bit for sign) */
+        const uint64_t r = NRANDI;
+        const int64_t rabs = r >> 1;
+        const int idx = static_cast<int> (rabs & 0xFF);
+        const double x = ( (r & 1) ? -rabs : rabs) * wi[idx];
 # endif
-      if (rabs < static_cast<int64_t> (ki[idx]))
-        return x;        /* 99.3% of the time we return here 1st try */
-      else if (idx == 0)
-        {
-          /* As stated in Marsaglia and Tsang
-           *
-           * For the normal tail, the method of Marsaglia[5] provides:
-           * generate x = -ln(U_1)/r, y = -ln(U_2), until y+y > x*x,
-           * then return r+x. Except that r+x is always in the positive
-           * tail!!!! Any thing random might be used to determine the
-           * sign, but as we already have r we might as well use it
-           *
-           * [PAK] but not the bottom 8 bits, since they are all 0 here!
-           */
-          double xx, yy;
-          do
-            {
-              xx = - ZIGGURAT_NOR_INV_R * std::log (RANDU);
-              yy = - std::log (RANDU);
-            }
-          while ( yy+yy <= xx*xx);
-          return ((rabs & 0x100) ? -ZIGGURAT_NOR_R-xx : ZIGGURAT_NOR_R+xx);
-        }
-      else if ((fi[idx-1] - fi[idx]) * RANDU + fi[idx] < exp (-0.5*x*x))
-        return x;
-    }
-}
+        if (rabs < static_cast<int64_t> (ki[idx]))
+          return x;        /* 99.3% of the time we return here 1st try */
+        else if (idx == 0)
+          {
+            /* As stated in Marsaglia and Tsang
+             *
+             * For the normal tail, the method of Marsaglia[5] provides:
+             * generate x = -ln(U_1)/r, y = -ln(U_2), until y+y > x*x,
+             * then return r+x. Except that r+x is always in the positive
+             * tail!!!! Any thing random might be used to determine the
+             * sign, but as we already have r we might as well use it
+             *
+             * [PAK] but not the bottom 8 bits, since they are all 0 here!
+             */
+            double xx, yy;
+            do
+              {
+                xx = - ZIGGURAT_NOR_INV_R * std::log (RANDU);
+                yy = - std::log (RANDU);
+              }
+            while ( yy+yy <= xx*xx);
+            return ((rabs & 0x100) ? -ZIGGURAT_NOR_R-xx : ZIGGURAT_NOR_R+xx);
+          }
+        else if ((fi[idx-1] - fi[idx]) * RANDU + fi[idx] < exp (-0.5*x*x))
+          return x;
+      }
+  }
+
+  template <> double rand_exponential<double> (void)
+  {
+    if (initt)
+      create_ziggurat_tables ();
 
-double
-oct_rande (void)
-{
-  if (initt)
-    create_ziggurat_tables ();
+    while (1)
+      {
+        ZIGINT ri = ERANDI;
+        const int idx = static_cast<int> (ri & 0xFF);
+        const double x = ri * we[idx];
+        if (ri < ke[idx])
+          return x;               /* 98.9% of the time we return here 1st try */
+        else if (idx == 0)
+          {
+            /* As stated in Marsaglia and Tsang
+             *
+             * For the exponential tail, the method of Marsaglia[5] provides:
+             * x = r - ln(U);
+             */
+            return ZIGGURAT_EXP_R - std::log (RANDU);
+          }
+        else if ((fe[idx-1] - fe[idx]) * RANDU + fe[idx] < exp (-x))
+          return x;
+      }
+  }
 
-  while (1)
-    {
-      ZIGINT ri = ERANDI;
-      const int idx = static_cast<int> (ri & 0xFF);
-      const double x = ri * we[idx];
-      if (ri < ke[idx])
-        return x;               /* 98.9% of the time we return here 1st try */
-      else if (idx == 0)
-        {
-          /* As stated in Marsaglia and Tsang
-           *
-           * For the exponential tail, the method of Marsaglia[5] provides:
-           * x = r - ln(U);
-           */
-          return ZIGGURAT_EXP_R - std::log (RANDU);
-        }
-      else if ((fe[idx-1] - fe[idx]) * RANDU + fe[idx] < exp (-x))
-        return x;
-    }
-}
+  template <> void rand_uniform<double> (octave_idx_type n, double *p)
+  {
+    std::generate_n (p, n, [](void) { return rand_uniform<double> (); });
+  }
+
+  template <> void rand_normal (octave_idx_type n, double *p)
+  {
+    std::generate_n (p, n, [](void) { return rand_normal<double> (); });
+  }
+
+  template <> void rand_exponential (octave_idx_type n, double *p)
+  {
+    std::generate_n (p, n, [](void) { return rand_exponential<double> (); });
+  }
 
 #undef ZIGINT
 #undef EMANTISSA
 #undef ERANDI
 #undef NMANTISSA
 #undef NRANDI
 #undef RANDU
 
 #define ZIGINT uint32_t
 #define EMANTISSA 4294967296.0 /* 32 bit mantissa */
 #define ERANDI randi32() /* 32 bits for mantissa */
 #define NMANTISSA 2147483648.0 /* 31 bit mantissa */
 #define NRANDI randi32() /* 31 bits for mantissa + 1 bit sign */
 #define RANDU randu32()
 
-static ZIGINT fki[ZIGGURAT_TABLE_SIZE];
-static float fwi[ZIGGURAT_TABLE_SIZE], ffi[ZIGGURAT_TABLE_SIZE];
-static ZIGINT fke[ZIGGURAT_TABLE_SIZE];
-static float fwe[ZIGGURAT_TABLE_SIZE], ffe[ZIGGURAT_TABLE_SIZE];
+  static ZIGINT fki[ZIGGURAT_TABLE_SIZE];
+  static float fwi[ZIGGURAT_TABLE_SIZE], ffi[ZIGGURAT_TABLE_SIZE];
+  static ZIGINT fke[ZIGGURAT_TABLE_SIZE];
+  static float fwe[ZIGGURAT_TABLE_SIZE], ffe[ZIGGURAT_TABLE_SIZE];
+
+  static void create_ziggurat_float_tables (void)
+  {
+    int i;
+    float x, x1;
 
-static void
-create_ziggurat_float_tables (void)
-{
-  int i;
-  float x, x1;
+    /* Ziggurat tables for the normal distribution */
+    x1 = ZIGGURAT_NOR_R;
+    fwi[255] = x1 / NMANTISSA;
+    ffi[255] = exp (-0.5 * x1 * x1);
+
+    /* Index zero is special for tail strip, where Marsaglia and Tsang
+     * defines this as
+     * k_0 = 2^31 * r * f(r) / v, w_0 = 0.5^31 * v / f(r), f_0 = 1,
+     * where v is the area of each strip of the ziggurat.
+     */
+    fki[0] = static_cast<ZIGINT> (x1 * ffi[255] / NOR_SECTION_AREA * NMANTISSA);
+    fwi[0] = NOR_SECTION_AREA / ffi[255] / NMANTISSA;
+    ffi[0] = 1.;
 
-  /* Ziggurat tables for the normal distribution */
-  x1 = ZIGGURAT_NOR_R;
-  fwi[255] = x1 / NMANTISSA;
-  ffi[255] = exp (-0.5 * x1 * x1);
+    for (i = 254; i > 0; i--)
+      {
+        /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
+         * need inverse operator of y = exp(-0.5*x*x) -> x = sqrt(-2*ln(y))
+         */
+        x = std::sqrt (-2. * std::log (NOR_SECTION_AREA / x1 + ffi[i+1]));
+        fki[i+1] = static_cast<ZIGINT> (x / x1 * NMANTISSA);
+        fwi[i] = x / NMANTISSA;
+        ffi[i] = exp (-0.5 * x * x);
+        x1 = x;
+      }
+
+    fki[1] = 0;
+
+    /* Zigurrat tables for the exponential distribution */
+    x1 = ZIGGURAT_EXP_R;
+    fwe[255] = x1 / EMANTISSA;
+    ffe[255] = exp (-x1);
 
-  /* Index zero is special for tail strip, where Marsaglia and Tsang
-   * defines this as
-   * k_0 = 2^31 * r * f(r) / v, w_0 = 0.5^31 * v / f(r), f_0 = 1,
-   * where v is the area of each strip of the ziggurat.
-   */
-  fki[0] = static_cast<ZIGINT> (x1 * ffi[255] / NOR_SECTION_AREA * NMANTISSA);
-  fwi[0] = NOR_SECTION_AREA / ffi[255] / NMANTISSA;
-  ffi[0] = 1.;
+    /* Index zero is special for tail strip, where Marsaglia and Tsang
+     * defines this as
+     * k_0 = 2^32 * r * f(r) / v, w_0 = 0.5^32 * v / f(r), f_0 = 1,
+     * where v is the area of each strip of the ziggurat.
+     */
+    fke[0] = static_cast<ZIGINT> (x1 * ffe[255] / EXP_SECTION_AREA * EMANTISSA);
+    fwe[0] = EXP_SECTION_AREA / ffe[255] / EMANTISSA;
+    ffe[0] = 1.;
+
+    for (i = 254; i > 0; i--)
+      {
+        /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
+         * need inverse operator of y = exp(-x) -> x = -ln(y)
+         */
+        x = - std::log (EXP_SECTION_AREA / x1 + ffe[i+1]);
+        fke[i+1] = static_cast<ZIGINT> (x / x1 * EMANTISSA);
+        fwe[i] = x / EMANTISSA;
+        ffe[i] = exp (-x);
+        x1 = x;
+      }
+    fke[1] = 0;
+
+    inittf = 0;
+  }
 
-  for (i = 254; i > 0; i--)
-    {
-      /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
-       * need inverse operator of y = exp(-0.5*x*x) -> x = sqrt(-2*ln(y))
-       */
-      x = std::sqrt (-2. * std::log (NOR_SECTION_AREA / x1 + ffi[i+1]));
-      fki[i+1] = static_cast<ZIGINT> (x / x1 * NMANTISSA);
-      fwi[i] = x / NMANTISSA;
-      ffi[i] = exp (-0.5 * x * x);
-      x1 = x;
-    }
+  /*
+   * Here is the guts of the algorithm. As Marsaglia and Tsang state the
+   * algorithm in their paper
+   *
+   * 1) Calculate a random signed integer j and let i be the index
+   *     provided by the rightmost 8-bits of j
+   * 2) Set x = j * w_i. If j < k_i return x
+   * 3) If i = 0, then return x from the tail
+   * 4) If [f(x_{i-1}) - f(x_i)] * U < f(x) - f(x_i), return x
+   * 5) goto step 1
+   *
+   * Where f is the functional form of the distribution, which for a normal
+   * distribution is exp(-0.5*x*x)
+   */
 
-  fki[1] = 0;
-
-  /* Zigurrat tables for the exponential distribution */
-  x1 = ZIGGURAT_EXP_R;
-  fwe[255] = x1 / EMANTISSA;
-  ffe[255] = exp (-x1);
+  template <> float rand_normal<float> (void)
+  {
+    if (inittf)
+      create_ziggurat_float_tables ();
 
-  /* Index zero is special for tail strip, where Marsaglia and Tsang
-   * defines this as
-   * k_0 = 2^32 * r * f(r) / v, w_0 = 0.5^32 * v / f(r), f_0 = 1,
-   * where v is the area of each strip of the ziggurat.
-   */
-  fke[0] = static_cast<ZIGINT> (x1 * ffe[255] / EXP_SECTION_AREA * EMANTISSA);
-  fwe[0] = EXP_SECTION_AREA / ffe[255] / EMANTISSA;
-  ffe[0] = 1.;
+    while (1)
+      {
+        /* 32-bit mantissa */
+        const uint32_t r = randi32 ();
+        const uint32_t rabs = r & LMASK;
+        const int idx = static_cast<int> (r & 0xFF);
+        const float x = static_cast<int32_t> (r) * fwi[idx];
+        if (rabs < fki[idx])
+          return x;        /* 99.3% of the time we return here 1st try */
+        else if (idx == 0)
+          {
+            /* As stated in Marsaglia and Tsang
+             *
+             * For the normal tail, the method of Marsaglia[5] provides:
+             * generate x = -ln(U_1)/r, y = -ln(U_2), until y+y > x*x,
+             * then return r+x. Except that r+x is always in the positive
+             * tail!!!! Any thing random might be used to determine the
+             * sign, but as we already have r we might as well use it
+             *
+             * [PAK] but not the bottom 8 bits, since they are all 0 here!
+             */
+            float xx, yy;
+            do
+              {
+                xx = - ZIGGURAT_NOR_INV_R * std::log (RANDU);
+                yy = - std::log (RANDU);
+              }
+            while ( yy+yy <= xx*xx);
+            return ((rabs & 0x100) ? -ZIGGURAT_NOR_R-xx : ZIGGURAT_NOR_R+xx);
+          }
+        else if ((ffi[idx-1] - ffi[idx]) * RANDU + ffi[idx] < exp (-0.5*x*x))
+          return x;
+      }
+  }
 
-  for (i = 254; i > 0; i--)
-    {
-      /* New x is given by x = f^{-1}(v/x_{i+1} + f(x_{i+1})), thus
-       * need inverse operator of y = exp(-x) -> x = -ln(y)
-       */
-      x = - std::log (EXP_SECTION_AREA / x1 + ffe[i+1]);
-      fke[i+1] = static_cast<ZIGINT> (x / x1 * EMANTISSA);
-      fwe[i] = x / EMANTISSA;
-      ffe[i] = exp (-x);
-      x1 = x;
-    }
-  fke[1] = 0;
+  template <> float rand_exponential<float> (void)
+  {
+    if (inittf)
+      create_ziggurat_float_tables ();
 
-  inittf = 0;
+    while (1)
+      {
+        ZIGINT ri = ERANDI;
+        const int idx = static_cast<int> (ri & 0xFF);
+        const float x = ri * fwe[idx];
+        if (ri < fke[idx])
+          return x;               /* 98.9% of the time we return here 1st try */
+        else if (idx == 0)
+          {
+            /* As stated in Marsaglia and Tsang
+             *
+             * For the exponential tail, the method of Marsaglia[5] provides:
+             * x = r - ln(U);
+             */
+            return ZIGGURAT_EXP_R - std::log (RANDU);
+          }
+        else if ((ffe[idx-1] - ffe[idx]) * RANDU + ffe[idx] < exp (-x))
+          return x;
+      }
+  }
+
+  template <> void rand_uniform (octave_idx_type n, float *p)
+  {
+    std::generate_n (p, n, [](void) { return rand_uniform<float> (); });
+  }
+
+  template <> void rand_normal (octave_idx_type n, float *p)
+  {
+    std::generate_n (p, n, [](void) { return rand_normal<float> (); });
+  }
+
+  template <> void rand_exponential (octave_idx_type n, float *p)
+  {
+    std::generate_n (p, n, [](void) { return rand_exponential<float> (); });
+  }
 }
 
-/*
- * Here is the guts of the algorithm. As Marsaglia and Tsang state the
- * algorithm in their paper
- *
- * 1) Calculate a random signed integer j and let i be the index
- *     provided by the rightmost 8-bits of j
- * 2) Set x = j * w_i. If j < k_i return x
- * 3) If i = 0, then return x from the tail
- * 4) If [f(x_{i-1}) - f(x_i)] * U < f(x) - f(x_i), return x
- * 5) goto step 1
- *
- * Where f is the functional form of the distribution, which for a normal
- * distribution is exp(-0.5*x*x)
- */
-
-float
-oct_float_randn (void)
-{
-  if (inittf)
-    create_ziggurat_float_tables ();
-
-  while (1)
-    {
-      /* 32-bit mantissa */
-      const uint32_t r = randi32 ();
-      const uint32_t rabs = r & LMASK;
-      const int idx = static_cast<int> (r & 0xFF);
-      const float x = static_cast<int32_t> (r) * fwi[idx];
-      if (rabs < fki[idx])
-        return x;        /* 99.3% of the time we return here 1st try */
-      else if (idx == 0)
-        {
-          /* As stated in Marsaglia and Tsang
-           *
-           * For the normal tail, the method of Marsaglia[5] provides:
-           * generate x = -ln(U_1)/r, y = -ln(U_2), until y+y > x*x,
-           * then return r+x. Except that r+x is always in the positive
-           * tail!!!! Any thing random might be used to determine the
-           * sign, but as we already have r we might as well use it
-           *
-           * [PAK] but not the bottom 8 bits, since they are all 0 here!
-           */
-          float xx, yy;
-          do
-            {
-              xx = - ZIGGURAT_NOR_INV_R * std::log (RANDU);
-              yy = - std::log (RANDU);
-            }
-          while ( yy+yy <= xx*xx);
-          return ((rabs & 0x100) ? -ZIGGURAT_NOR_R-xx : ZIGGURAT_NOR_R+xx);
-        }
-      else if ((ffi[idx-1] - ffi[idx]) * RANDU + ffi[idx] < exp (-0.5*x*x))
-        return x;
-    }
-}
-
-float
-oct_float_rande (void)
-{
-  if (inittf)
-    create_ziggurat_float_tables ();
-
-  while (1)
-    {
-      ZIGINT ri = ERANDI;
-      const int idx = static_cast<int> (ri & 0xFF);
-      const float x = ri * fwe[idx];
-      if (ri < fke[idx])
-        return x;               /* 98.9% of the time we return here 1st try */
-      else if (idx == 0)
-        {
-          /* As stated in Marsaglia and Tsang
-           *
-           * For the exponential tail, the method of Marsaglia[5] provides:
-           * x = r - ln(U);
-           */
-          return ZIGGURAT_EXP_R - std::log (RANDU);
-        }
-      else if ((ffe[idx-1] - ffe[idx]) * RANDU + ffe[idx] < exp (-x))
-        return x;
-    }
-}
-
-/* Array generators */
-void
-oct_fill_randu (octave_idx_type n, double *p)
-{
-  std::generate_n (p, n, oct_randu);
-}
-
-void
-oct_fill_randn (octave_idx_type n, double *p)
-{
-  std::generate_n (p, n, oct_randn);
-}
-
-void
-oct_fill_rande (octave_idx_type n, double *p)
-{
-  std::generate_n (p, n, oct_rande);
-}
-
-void
-oct_fill_float_randu (octave_idx_type n, float *p)
-{
-  std::generate_n (p, n, oct_float_randu);
-}
-
-void
-oct_fill_float_randn (octave_idx_type n, float *p)
-{
-  std::generate_n (p, n, oct_float_randn);
-}
-
-void
-oct_fill_float_rande (octave_idx_type n, float *p)
-{
-  std::generate_n (p, n, oct_float_rande);
-}
diff --git a/liboctave/numeric/randmtzig.h b/liboctave/numeric/randmtzig.h
--- a/liboctave/numeric/randmtzig.h
+++ b/liboctave/numeric/randmtzig.h
@@ -63,35 +63,175 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_randmtzig_h)
 #define octave_randmtzig_h 1
 
 #include "octave-config.h"
 
 #define MT_N 624
 
-// Mersenne Twister.
-extern OCTAVE_API void oct_init_by_int (const uint32_t s);
-extern OCTAVE_API void oct_init_by_array (const uint32_t *init_key,
-                                          const int key_length);
-extern OCTAVE_API void oct_init_by_entropy (void);
-extern OCTAVE_API void oct_set_state (const uint32_t *save);
-extern OCTAVE_API void oct_get_state (uint32_t *save);
+namespace octave
+{
+  // Mersenne Twister.
+
+  extern void init_mersenne_twister (void);
+  extern void init_mersenne_twister (const uint32_t seed);
+  extern void init_mersenne_twister (const uint32_t *init_key,
+                                     const int key_length);
+
+  extern void set_mersenne_twister_state (const uint32_t *save);
+  extern void get_mersenne_twister_state (uint32_t *save);
+
+  template <typename T> T rand_uniform (void);
+  template <typename T> T rand_normal (void);
+  template <typename T> T rand_exponential (void);
+
+  template <typename T> void rand_uniform (octave_idx_type n, T *p);
+  template <typename T> void rand_normal (octave_idx_type n, T *p);
+  template <typename T> void rand_exponential (octave_idx_type n, T *p);
+
+  template <> double rand_uniform<double> (void);
+  template <> double rand_normal<double> (void);
+  template <> double rand_exponential<double> (void);
+
+  template <> float rand_uniform<float> (void);
+  template <> float rand_normal<float> (void);
+  template <> float rand_exponential<float> (void);
+
+  template <> void
+  rand_uniform<double> (octave_idx_type n, double *p);
+
+  template <> void
+  rand_normal<double> (octave_idx_type n, double *p);
+
+  template <> void
+  rand_exponential<double> (octave_idx_type n, double *p);
+
+  template <> void
+  rand_uniform<float> (octave_idx_type n, float *p);
 
-// Array generators.
-extern OCTAVE_API double oct_randu (void);
-extern OCTAVE_API double oct_randn (void);
-extern OCTAVE_API double oct_rande (void);
+  template <> void
+  rand_normal<float> (octave_idx_type n, float *p);
+
+  template <> void
+  rand_exponential<float> (octave_idx_type n, float *p);
+}
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::init_mersenne_twister' instead")
+inline void
+oct_init_by_entropy (void)
+{
+  octave::init_mersenne_twister ();
+}
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::init_mersenne_twister' instead")
+inline void
+oct_init_by_int (const uint32_t seed)
+{
+  octave::init_mersenne_twister (seed);
+}
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::init_mersenne_twister' instead")
+inline void
+oct_init_by_array (const uint32_t *init_key, const int key_length)
+{
+  octave::init_mersenne_twister (init_key, key_length);
+}
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::set_mersenne_twister_state' instead")
+inline void
+oct_set_state (const uint32_t *save)
+{
+  octave::set_mersenne_twister_state (save);
+}
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::get_mersenne_twister_state' instead")
+inline void
+oct_get_state (uint32_t *save)
+{
+  octave::get_mersenne_twister_state (save);
+}
 
-extern OCTAVE_API float oct_float_randu (void);
-extern OCTAVE_API float oct_float_randn (void);
-extern OCTAVE_API float oct_float_rande (void);
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_uniform<double>' instead")
+inline double
+oct_randu (void)
+{
+  return octave::rand_uniform<double> ();
+}
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_normal<double>' instead")
+inline double
+oct_randn (void)
+{
+  return octave::rand_normal<double> ();
+}
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_exponential<double>' instead")
+inline double
+oct_rande (void)
+{
+  return octave::rand_exponential<double> ();
+}
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_uniform' instead")
+inline void
+oct_fill_randu (octave_idx_type n, double *p)
+{
+  octave::rand_uniform (n, p);
+}
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_normal' instead")
+inline void
+oct_fill_randn (octave_idx_type n, double *p)
+{
+  octave::rand_normal (n, p);
+}
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_exponential' instead")
+inline void
+oct_fill_rande (octave_idx_type n, double *p)
+{
+  octave::rand_exponential (n, p);
+}
 
-// Array generators.
-extern OCTAVE_API void oct_fill_randu (octave_idx_type n, double *p);
-extern OCTAVE_API void oct_fill_randn (octave_idx_type n, double *p);
-extern OCTAVE_API void oct_fill_rande (octave_idx_type n, double *p);
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_uniform<float>' instead")
+inline float
+oct_float_randu (void)
+{
+  return octave::rand_uniform<float> ();
+}
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_normal<float>' instead")
+inline float
+oct_float_randn (void)
+{
+  return octave::rand_normal<float> ();
+}
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_exponential<float>' instead")
+inline float
+oct_float_rande (void)
+{
+  return octave::rand_exponential<float> ();
+}
 
-extern OCTAVE_API void oct_fill_float_randu (octave_idx_type n, float *p);
-extern OCTAVE_API void oct_fill_float_randn (octave_idx_type n, float *p);
-extern OCTAVE_API void oct_fill_float_rande (octave_idx_type n, float *p);
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_uniform' instead")
+inline void
+oct_fill_float_randu (octave_idx_type n, float *p)
+{
+  octave::rand_uniform (n, p);
+}
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_normal' instead")
+inline void
+oct_fill_float_randn (octave_idx_type n, float *p)
+{
+  octave::rand_normal (n, p);
+}
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_exponential' instead")
+inline void
+oct_fill_float_rande (octave_idx_type n, float *p)
+{
+  octave::rand_exponential (n, p);
+}
 
 #endif
diff --git a/liboctave/numeric/randpoisson.cc b/liboctave/numeric/randpoisson.cc
--- a/liboctave/numeric/randpoisson.cc
+++ b/liboctave/numeric/randpoisson.cc
@@ -18,588 +18,566 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <https://www.gnu.org/licenses/>.
 
 */
 
 /* Original version written by Paul Kienzle distributed as free
    software in the in the public domain.  */
 
-/* Needs the following defines:
- * NAN: value to return for Not-A-Number
- * RUNI: uniform generator on (0,1)
- * RNOR: normal generator
- * LGAMMA: log gamma function
- * INFINITE: function to test whether a value is infinite
- */
-
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <cmath>
 #include <cstddef>
 
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "randmtzig.h"
 #include "randpoisson.h"
 
-#undef INFINITE
-#define INFINITE lo_ieee_isinf
-#define RUNI oct_randu()
-#define RNOR oct_randn()
-#define LGAMMA xlgamma
-
-static double
-xlgamma (double x)
+namespace octave
 {
-  return std::lgamma (x);
-}
-
-/* ---- pprsc.c from Stadloeber's winrand --- */
+  static double xlgamma (double x)
+  {
+    return std::lgamma (x);
+  }
 
-/* flogfak(k) = ln(k!) */
-static double
-flogfak (double k)
-{
+  /* ---- pprsc.c from Stadloeber's winrand --- */
+
+  /* flogfak(k) = ln(k!) */
+  static double flogfak (double k)
+  {
 #define C0  9.18938533204672742e-01
 #define C1  8.33333333333333333e-02
 #define C3 -2.77777777777777778e-03
 #define C5  7.93650793650793651e-04
 #define C7 -5.95238095238095238e-04
 
-  static double logfak[30L] =
-  {
-    0.00000000000000000,   0.00000000000000000,   0.69314718055994531,
-    1.79175946922805500,   3.17805383034794562,   4.78749174278204599,
-    6.57925121201010100,   8.52516136106541430,  10.60460290274525023,
-    12.80182748008146961,  15.10441257307551530,  17.50230784587388584,
-    19.98721449566188615,  22.55216385312342289,  25.19122118273868150,
-    27.89927138384089157,  30.67186010608067280,  33.50507345013688888,
-    36.39544520803305358,  39.33988418719949404,  42.33561646075348503,
-    45.38013889847690803,  48.47118135183522388,  51.60667556776437357,
-    54.78472939811231919,  58.00360522298051994,  61.26170176100200198,
-    64.55753862700633106,  67.88974313718153498,  71.25703896716800901
-  };
+    static double logfak[30L] =
+      {
+        0.00000000000000000,   0.00000000000000000,   0.69314718055994531,
+        1.79175946922805500,   3.17805383034794562,   4.78749174278204599,
+        6.57925121201010100,   8.52516136106541430,  10.60460290274525023,
+        12.80182748008146961,  15.10441257307551530,  17.50230784587388584,
+        19.98721449566188615,  22.55216385312342289,  25.19122118273868150,
+        27.89927138384089157,  30.67186010608067280,  33.50507345013688888,
+        36.39544520803305358,  39.33988418719949404,  42.33561646075348503,
+        45.38013889847690803,  48.47118135183522388,  51.60667556776437357,
+        54.78472939811231919,  58.00360522298051994,  61.26170176100200198,
+        64.55753862700633106,  67.88974313718153498,  71.25703896716800901
+      };
 
-  double r, rr;
+    double r, rr;
 
-  if (k >= 30.0)
-    {
-      r  = 1.0 / k;
-      rr = r * r;
-      return ((k + 0.5)*std::log (k) - k + C0
-              + r*(C1 + rr*(C3 + rr*(C5 + rr*C7))));
-    }
-  else
-    return (logfak[static_cast<int> (k)]);
-}
+    if (k >= 30.0)
+      {
+        r  = 1.0 / k;
+        rr = r * r;
+        return ((k + 0.5)*std::log (k) - k + C0
+                + r*(C1 + rr*(C3 + rr*(C5 + rr*C7))));
+      }
+    else
+      return (logfak[static_cast<int> (k)]);
+  }
 
-/******************************************************************
- *                                                                *
- * Poisson Distribution - Patchwork Rejection/Inversion           *
- *                                                                *
- ******************************************************************
- *                                                                *
- * For parameter my < 10, Tabulated Inversion is applied.         *
- * For my >= 10, Patchwork Rejection is employed:                 *
- * The area below the histogram function f(x) is rearranged in    *
- * its body by certain point reflections. Within a large center   *
- * interval variates are sampled efficiently by rejection from    *
- * uniform hats. Rectangular immediate acceptance regions speed   *
- * up the generation. The remaining tails are covered by          *
- * exponential functions.                                         *
- *                                                                *
- ******************************************************************
- *                                                                *
- * FUNCTION :   - pprsc samples a random number from the Poisson  *
- *                distribution with parameter my > 0.             *
- * REFERENCE :  - H. Zechner (1994): Efficient sampling from      *
- *                continuous and discrete unimodal distributions, *
- *                Doctoral Dissertation, 156 pp., Technical       *
- *                University Graz, Austria.                       *
- * SUBPROGRAM : - drand(seed) ... (0,1)-Uniform generator with    *
- *                unsigned long integer *seed.                    *
- *                                                                *
- * Implemented by H. Zechner, January 1994                        *
- * Revised by F. Niederl, July 1994                               *
- *                                                                *
- ******************************************************************/
+  /******************************************************************
+   *                                                                *
+   * Poisson Distribution - Patchwork Rejection/Inversion           *
+   *                                                                *
+   ******************************************************************
+   *                                                                *
+   * For parameter my < 10, Tabulated Inversion is applied.         *
+   * For my >= 10, Patchwork Rejection is employed:                 *
+   * The area below the histogram function f(x) is rearranged in    *
+   * its body by certain point reflections. Within a large center   *
+   * interval variates are sampled efficiently by rejection from    *
+   * uniform hats. Rectangular immediate acceptance regions speed   *
+   * up the generation. The remaining tails are covered by          *
+   * exponential functions.                                         *
+   *                                                                *
+   ******************************************************************
+   *                                                                *
+   * FUNCTION :   - pprsc samples a random number from the Poisson  *
+   *                distribution with parameter my > 0.             *
+   * REFERENCE :  - H. Zechner (1994): Efficient sampling from      *
+   *                continuous and discrete unimodal distributions, *
+   *                Doctoral Dissertation, 156 pp., Technical       *
+   *                University Graz, Austria.                       *
+   * SUBPROGRAM : - drand(seed) ... (0,1)-Uniform generator with    *
+   *                unsigned long integer *seed.                    *
+   *                                                                *
+   * Implemented by H. Zechner, January 1994                        *
+   * Revised by F. Niederl, July 1994                               *
+   *                                                                *
+   ******************************************************************/
 
-static double
-f (double k, double l_nu, double c_pm)
-{
-  return exp (k * l_nu - flogfak (k) - c_pm);
-}
+  static double f (double k, double l_nu, double c_pm)
+  {
+    return exp (k * l_nu - flogfak (k) - c_pm);
+  }
 
-static double
-pprsc (double my)
-{
-  static double my_last = -1.0;
-  static double m,  k2, k4, k1, k5;
-  static double dl, dr, r1, r2, r4, r5, ll, lr, l_my, c_pm,
-                f1, f2, f4, f5, p1, p2, p3, p4, p5, p6;
-  double        Dk, X, Y;
-  double        Ds, U, V, W;
+  static double pprsc (double my)
+  {
+    static double my_last = -1.0;
+    static double m,  k2, k4, k1, k5;
+    static double dl, dr, r1, r2, r4, r5, ll, lr, l_my, c_pm,
+      f1, f2, f4, f5, p1, p2, p3, p4, p5, p6;
+    double        Dk, X, Y;
+    double        Ds, U, V, W;
 
-  if (my != my_last)
-    {                               /* set-up           */
-      my_last = my;
-      /* approximate deviation of reflection points k2, k4 from my - 1/2 */
-      Ds = std::sqrt (my + 0.25);
+    if (my != my_last)
+      {                               /* set-up           */
+        my_last = my;
+        /* approximate deviation of reflection points k2, k4 from my - 1/2 */
+        Ds = std::sqrt (my + 0.25);
 
-      /* mode m, reflection points k2 and k4, and points k1 and k5,      */
-      /* which delimit the centre region of h(x)                         */
-      m  = std::floor (my);
-      k2 = ceil (my - 0.5 - Ds);
-      k4 = std::floor (my - 0.5 + Ds);
-      k1 = k2 + k2 - m + 1L;
-      k5 = k4 + k4 - m;
+        /* mode m, reflection points k2 and k4, and points k1 and k5,      */
+        /* which delimit the centre region of h(x)                         */
+        m  = std::floor (my);
+        k2 = ceil (my - 0.5 - Ds);
+        k4 = std::floor (my - 0.5 + Ds);
+        k1 = k2 + k2 - m + 1L;
+        k5 = k4 + k4 - m;
 
-      /* range width of the critical left and right centre region        */
-      dl = (k2 - k1);
-      dr = (k5 - k4);
+        /* range width of the critical left and right centre region        */
+        dl = (k2 - k1);
+        dr = (k5 - k4);
 
-      /* recurrence constants r(k)=p(k)/p(k-1) at k = k1, k2, k4+1, k5+1 */
-      r1 = my / k1;
-      r2 = my / k2;
-      r4 = my / (k4 + 1.0);
-      r5 = my / (k5 + 1.0);
+        /* recurrence constants r(k)=p(k)/p(k-1) at k = k1, k2, k4+1, k5+1 */
+        r1 = my / k1;
+        r2 = my / k2;
+        r4 = my / (k4 + 1.0);
+        r5 = my / (k5 + 1.0);
 
-      /* reciprocal values of the scale parameters of exp. tail envelope */
-      ll =  std::log (r1);                        /* expon. tail left */
-      lr = -std::log (r5);                        /* expon. tail right*/
+        /* reciprocal values of the scale parameters of exp. tail envelope */
+        ll =  std::log (r1);                        /* expon. tail left */
+        lr = -std::log (r5);                        /* expon. tail right*/
 
-      /* Poisson constants, necessary for computing function values f(k) */
-      l_my = std::log (my);
-      c_pm = m * l_my - flogfak (m);
+        /* Poisson constants, necessary for computing function values f(k) */
+        l_my = std::log (my);
+        c_pm = m * l_my - flogfak (m);
 
-      /* function values f(k) = p(k)/p(m) at k = k2, k4, k1, k5          */
-      f2 = f (k2, l_my, c_pm);
-      f4 = f (k4, l_my, c_pm);
-      f1 = f (k1, l_my, c_pm);
-      f5 = f (k5, l_my, c_pm);
+        /* function values f(k) = p(k)/p(m) at k = k2, k4, k1, k5          */
+        f2 = f (k2, l_my, c_pm);
+        f4 = f (k4, l_my, c_pm);
+        f1 = f (k1, l_my, c_pm);
+        f5 = f (k5, l_my, c_pm);
 
-      /* area of the two centre and the two exponential tail regions     */
-      /* area of the two immediate acceptance regions between k2, k4     */
-      p1 = f2 * (dl + 1.0);                            /* immed. left    */
-      p2 = f2 * dl         + p1;                       /* centre left    */
-      p3 = f4 * (dr + 1.0) + p2;                       /* immed. right   */
-      p4 = f4 * dr         + p3;                       /* centre right   */
-      p5 = f1 / ll         + p4;                       /* exp. tail left */
-      p6 = f5 / lr         + p5;                       /* exp. tail right*/
-    }
+        /* area of the two centre and the two exponential tail regions     */
+        /* area of the two immediate acceptance regions between k2, k4     */
+        p1 = f2 * (dl + 1.0);                            /* immed. left    */
+        p2 = f2 * dl         + p1;                       /* centre left    */
+        p3 = f4 * (dr + 1.0) + p2;                       /* immed. right   */
+        p4 = f4 * dr         + p3;                       /* centre right   */
+        p5 = f1 / ll         + p4;                       /* exp. tail left */
+        p6 = f5 / lr         + p5;                       /* exp. tail right*/
+      }
 
-  for (;;)
-    {
-      /* generate uniform number U -- U(0, p6)                           */
-      /* case distinction corresponding to U                             */
-      if ((U = RUNI * p6) < p2)
-        {                                            /* centre left      */
+    for (;;)
+      {
+        /* generate uniform number U -- U(0, p6)                           */
+        /* case distinction corresponding to U                             */
+        if ((U = octave::rand_uniform<double> () * p6) < p2)
+          {                                            /* centre left      */
 
-          /* immediate acceptance region
-             R2 = [k2, m) *[0, f2),  X = k2, ... m -1 */
-          if ((V = U - p1) < 0.0)  return (k2 + std::floor (U/f2));
-          /* immediate acceptance region
-             R1 = [k1, k2)*[0, f1),  X = k1, ... k2-1 */
-          if ((W = V / dl) < f1 )  return (k1 + std::floor (V/f1));
+            /* immediate acceptance region
+               R2 = [k2, m) *[0, f2),  X = k2, ... m -1 */
+            if ((V = U - p1) < 0.0)  return (k2 + std::floor (U/f2));
+            /* immediate acceptance region
+               R1 = [k1, k2)*[0, f1),  X = k1, ... k2-1 */
+            if ((W = V / dl) < f1 )  return (k1 + std::floor (V/f1));
 
-          /* computation of candidate X < k2, and its counterpart Y > k2 */
-          /* either squeeze-acceptance of X or acceptance-rejection of Y */
-          Dk = std::floor (dl * RUNI) + 1.0;
-          if (W <= f2 - Dk * (f2 - f2/r2))
-            {                                        /* quick accept of  */
-              return (k2 - Dk);                      /* X = k2 - Dk      */
-            }
-          if ((V = f2 + f2 - W) < 1.0)
-            {                                        /* quick reject of Y*/
-              Y = k2 + Dk;
-              if (V <= f2 + Dk * (1.0 - f2)/(dl + 1.0))
-                {                                    /* quick accept of  */
-                  return (Y);                        /* Y = k2 + Dk      */
-                }
-              if (V <= f (Y, l_my, c_pm))  return (Y); /* final accept of Y*/
-            }
-          X = k2 - Dk;
-        }
-      else if (U < p4)
-        {                                            /* centre right     */
-          /*  immediate acceptance region
-              R3 = [m, k4+1)*[0, f4), X = m, ... k4    */
-          if ((V = U - p3) < 0.0)  return (k4 - std::floor ((U - p2)/f4));
-          /* immediate acceptance region
-             R4 = [k4+1, k5+1)*[0, f5)                */
-          if ((W = V / dr) < f5 )  return (k5 - std::floor (V/f5));
+            /* computation of candidate X < k2, and its counterpart Y > k2 */
+            /* either squeeze-acceptance of X or acceptance-rejection of Y */
+            Dk = std::floor (dl * octave::rand_uniform<double> ()) + 1.0;
+            if (W <= f2 - Dk * (f2 - f2/r2))
+              {                                        /* quick accept of  */
+                return (k2 - Dk);                      /* X = k2 - Dk      */
+              }
+            if ((V = f2 + f2 - W) < 1.0)
+              {                                        /* quick reject of Y*/
+                Y = k2 + Dk;
+                if (V <= f2 + Dk * (1.0 - f2)/(dl + 1.0))
+                  {                                    /* quick accept of  */
+                    return (Y);                        /* Y = k2 + Dk      */
+                  }
+                if (V <= f (Y, l_my, c_pm))  return (Y); /* final accept of Y*/
+              }
+            X = k2 - Dk;
+          }
+        else if (U < p4)
+          {                                            /* centre right     */
+            /*  immediate acceptance region
+                R3 = [m, k4+1)*[0, f4), X = m, ... k4    */
+            if ((V = U - p3) < 0.0)  return (k4 - std::floor ((U - p2)/f4));
+            /* immediate acceptance region
+               R4 = [k4+1, k5+1)*[0, f5)                */
+            if ((W = V / dr) < f5 )  return (k5 - std::floor (V/f5));
 
-          /* computation of candidate X > k4, and its counterpart Y < k4 */
-          /* either squeeze-acceptance of X or acceptance-rejection of Y */
-          Dk = std::floor (dr * RUNI) + 1.0;
-          if (W <= f4 - Dk * (f4 - f4*r4))
-            {                                        /* quick accept of  */
-              return (k4 + Dk);                      /* X = k4 + Dk      */
-            }
-          if ((V = f4 + f4 - W) < 1.0)
-            {                                        /* quick reject of Y*/
-              Y = k4 - Dk;
-              if (V <= f4 + Dk * (1.0 - f4)/ dr)
-                {                                    /* quick accept of  */
-                  return (Y);                        /* Y = k4 - Dk      */
-                }
-              if (V <= f (Y, l_my, c_pm))  return (Y); /* final accept of Y*/
-            }
-          X = k4 + Dk;
-        }
-      else
-        {
-          W = RUNI;
-          if (U < p5)
-            {                                        /* expon. tail left */
-              Dk = std::floor (1.0 - std::log (W)/ll);
-              if ((X = k1 - Dk) < 0L)  continue;     /* 0 <= X <= k1 - 1 */
-              W *= (U - p4) * ll;                    /* W -- U(0, h(x))  */
-              if (W <= f1 - Dk * (f1 - f1/r1))
-                return (X);                          /* quick accept of X*/
-            }
-          else
-            {                                        /* expon. tail right*/
-              Dk = std::floor (1.0 - std::log (W)/lr);
-              X  = k5 + Dk;                          /* X >= k5 + 1      */
-              W *= (U - p5) * lr;                    /* W -- U(0, h(x))  */
-              if (W <= f5 - Dk * (f5 - f5*r5))
-                return (X);                          /* quick accept of X*/
-            }
-        }
+            /* computation of candidate X > k4, and its counterpart Y < k4 */
+            /* either squeeze-acceptance of X or acceptance-rejection of Y */
+            Dk = std::floor (dr * octave::rand_uniform<double> ()) + 1.0;
+            if (W <= f4 - Dk * (f4 - f4*r4))
+              {                                        /* quick accept of  */
+                return (k4 + Dk);                      /* X = k4 + Dk      */
+              }
+            if ((V = f4 + f4 - W) < 1.0)
+              {                                        /* quick reject of Y*/
+                Y = k4 - Dk;
+                if (V <= f4 + Dk * (1.0 - f4)/ dr)
+                  {                                    /* quick accept of  */
+                    return (Y);                        /* Y = k4 - Dk      */
+                  }
+                if (V <= f (Y, l_my, c_pm))  return (Y); /* final accept of Y*/
+              }
+            X = k4 + Dk;
+          }
+        else
+          {
+            W = octave::rand_uniform<double> ();
+            if (U < p5)
+              {                                        /* expon. tail left */
+                Dk = std::floor (1.0 - std::log (W)/ll);
+                if ((X = k1 - Dk) < 0L)  continue;     /* 0 <= X <= k1 - 1 */
+                W *= (U - p4) * ll;                    /* W -- U(0, h(x))  */
+                if (W <= f1 - Dk * (f1 - f1/r1))
+                  return (X);                          /* quick accept of X*/
+              }
+            else
+              {                                        /* expon. tail right*/
+                Dk = std::floor (1.0 - std::log (W)/lr);
+                X  = k5 + Dk;                          /* X >= k5 + 1      */
+                W *= (U - p5) * lr;                    /* W -- U(0, h(x))  */
+                if (W <= f5 - Dk * (f5 - f5*r5))
+                  return (X);                          /* quick accept of X*/
+              }
+          }
 
-      /* acceptance-rejection test of candidate X from the original area */
-      /* test, whether  W <= f(k),    with  W = U*h(x)  and  U -- U(0, 1)*/
-      /* log f(X) = (X - m)*log(my) - log X! + log m!                    */
-      if (std::log (W) <= X * l_my - flogfak (X) - c_pm)  return (X);
-    }
-}
-/* ---- pprsc.c end ------ */
+        /* acceptance-rejection test of candidate X from the original area */
+        /* test, whether  W <= f(k),    with  W = U*h(x)  and  U -- U(0, 1)*/
+        /* log f(X) = (X - m)*log(my) - log X! + log m!                    */
+        if (std::log (W) <= X * l_my - flogfak (X) - c_pm)  return (X);
+      }
+  }
+  /* ---- pprsc.c end ------ */
 
-/* The remainder of the file is by Paul Kienzle */
+  /* The remainder of the file is by Paul Kienzle */
 
-/* Given uniform u, find x such that CDF(L,x)==u.  Return x. */
-static void
-poisson_cdf_lookup (double lambda, double *p, size_t n)
-{
-  /* Table size is predicated on the maximum value of lambda
-   * we want to store in the table, and the maximum value of
-   * returned by the uniform random number generator on [0,1).
-   * With lambda==10 and u_max = 1 - 1/(2^32+1), we
-   * have poisson_pdf(lambda,36) < 1-u_max.  If instead our
-   * generator uses more bits of mantissa or returns a value
-   * in the range [0,1], then for lambda==10 we need a table
-   * size of 46 instead.  For long doubles, the table size
-   * will need to be longer still.  */
+  /* Given uniform u, find x such that CDF(L,x)==u.  Return x. */
+  static void poisson_cdf_lookup (double lambda, double *p, size_t n)
+  {
+    /* Table size is predicated on the maximum value of lambda
+     * we want to store in the table, and the maximum value of
+     * returned by the uniform random number generator on [0,1).
+     * With lambda==10 and u_max = 1 - 1/(2^32+1), we
+     * have poisson_pdf(lambda,36) < 1-u_max.  If instead our
+     * generator uses more bits of mantissa or returns a value
+     * in the range [0,1], then for lambda==10 we need a table
+     * size of 46 instead.  For long doubles, the table size
+     * will need to be longer still.  */
 #define TABLESIZE 46
-  double t[TABLESIZE];
+    double t[TABLESIZE];
 
-  /* Precompute the table for the u up to and including 0.458.
-   * We will almost certainly need it. */
-  int intlambda = static_cast<int> (std::floor (lambda));
-  double P;
-  int tableidx;
-  size_t i = n;
+    /* Precompute the table for the u up to and including 0.458.
+     * We will almost certainly need it. */
+    int intlambda = static_cast<int> (std::floor (lambda));
+    double P;
+    int tableidx;
+    size_t i = n;
 
-  t[0] = P = exp (-lambda);
-  for (tableidx = 1; tableidx <= intlambda; tableidx++)
-    {
-      P = P*lambda/static_cast<double> (tableidx);
-      t[tableidx] = t[tableidx-1] + P;
-    }
+    t[0] = P = exp (-lambda);
+    for (tableidx = 1; tableidx <= intlambda; tableidx++)
+      {
+        P = P*lambda/static_cast<double> (tableidx);
+        t[tableidx] = t[tableidx-1] + P;
+      }
 
-  while (i-- > 0)
-    {
-      double u = RUNI;
+    while (i-- > 0)
+      {
+        double u = octave::rand_uniform<double> ();
 
-      /* If u > 0.458 we know we can jump to floor(lambda) before
-       * comparing (this observation is based on Stadlober's winrand
-       * code). For lambda >= 1, this will be a win.  Lambda < 1
-       * is already fast, so adding an extra comparison is not a
-       * problem. */
-      int k = (u > 0.458 ? intlambda : 0);
+        /* If u > 0.458 we know we can jump to floor(lambda) before
+         * comparing (this observation is based on Stadlober's winrand
+         * code). For lambda >= 1, this will be a win.  Lambda < 1
+         * is already fast, so adding an extra comparison is not a
+         * problem. */
+        int k = (u > 0.458 ? intlambda : 0);
 
-      /* We aren't using a for loop here because when we find the
-       * right k we want to jump to the next iteration of the
-       * outer loop, and the continue statement will only work for
-       * the inner loop. */
-    nextk:
-      if (u <= t[k])
-        {
-          p[i] = static_cast<double> (k);
-          continue;
-        }
-      if (++k < tableidx)
-        goto nextk;
+        /* We aren't using a for loop here because when we find the
+         * right k we want to jump to the next iteration of the
+         * outer loop, and the continue statement will only work for
+         * the inner loop. */
+      nextk:
+        if (u <= t[k])
+          {
+            p[i] = static_cast<double> (k);
+            continue;
+          }
+        if (++k < tableidx)
+          goto nextk;
 
-      /* We only need high values of the table very rarely so we
-       * don't automatically compute the entire table. */
-      while (tableidx < TABLESIZE)
-        {
-          P = P*lambda/static_cast<double> (tableidx);
-          t[tableidx] = t[tableidx-1] + P;
-          /* Make sure we converge to 1.0 just in case u is uniform
-           * on [0,1] rather than [0,1). */
-          if (t[tableidx] == t[tableidx-1]) t[tableidx] = 1.0;
-          tableidx++;
-          if (u <= t[tableidx-1]) break;
-        }
+        /* We only need high values of the table very rarely so we
+         * don't automatically compute the entire table. */
+        while (tableidx < TABLESIZE)
+          {
+            P = P*lambda/static_cast<double> (tableidx);
+            t[tableidx] = t[tableidx-1] + P;
+            /* Make sure we converge to 1.0 just in case u is uniform
+             * on [0,1] rather than [0,1). */
+            if (t[tableidx] == t[tableidx-1]) t[tableidx] = 1.0;
+            tableidx++;
+            if (u <= t[tableidx-1]) break;
+          }
 
-      /* We are assuming that the table size is big enough here.
-       * This should be true even if RUNI is returning values in
-       * the range [0,1] rather than [0,1). */
-      p[i] = static_cast<double> (tableidx-1);
-    }
-}
+        /* We are assuming that the table size is big enough here.
+         * This should be true even if rand_uniform is returning values in
+         * the range [0,1] rather than [0,1). */
+        p[i] = static_cast<double> (tableidx-1);
+      }
+  }
 
-static void
-poisson_cdf_lookup_float (double lambda, float *p, size_t n)
-{
-  double t[TABLESIZE];
+  static void poisson_cdf_lookup_float (double lambda, float *p, size_t n)
+  {
+    double t[TABLESIZE];
 
-  /* Precompute the table for the u up to and including 0.458.
-   * We will almost certainly need it. */
-  int intlambda = static_cast<int> (std::floor (lambda));
-  double P;
-  int tableidx;
-  size_t i = n;
+    /* Precompute the table for the u up to and including 0.458.
+     * We will almost certainly need it. */
+    int intlambda = static_cast<int> (std::floor (lambda));
+    double P;
+    int tableidx;
+    size_t i = n;
 
-  t[0] = P = exp (-lambda);
-  for (tableidx = 1; tableidx <= intlambda; tableidx++)
-    {
-      P = P*lambda/static_cast<double> (tableidx);
-      t[tableidx] = t[tableidx-1] + P;
-    }
+    t[0] = P = exp (-lambda);
+    for (tableidx = 1; tableidx <= intlambda; tableidx++)
+      {
+        P = P*lambda/static_cast<double> (tableidx);
+        t[tableidx] = t[tableidx-1] + P;
+      }
 
-  while (i-- > 0)
-    {
-      double u = RUNI;
-      int k = (u > 0.458 ? intlambda : 0);
-    nextk:
-      if (u <= t[k])
-        {
-          p[i] = static_cast<float> (k);
-          continue;
-        }
-      if (++k < tableidx)
-        goto nextk;
+    while (i-- > 0)
+      {
+        double u = octave::rand_uniform<double> ();
+        int k = (u > 0.458 ? intlambda : 0);
+      nextk:
+        if (u <= t[k])
+          {
+            p[i] = static_cast<float> (k);
+            continue;
+          }
+        if (++k < tableidx)
+          goto nextk;
 
-      while (tableidx < TABLESIZE)
-        {
-          P = P*lambda/static_cast<double> (tableidx);
-          t[tableidx] = t[tableidx-1] + P;
-          if (t[tableidx] == t[tableidx-1]) t[tableidx] = 1.0;
-          tableidx++;
-          if (u <= t[tableidx-1]) break;
-        }
+        while (tableidx < TABLESIZE)
+          {
+            P = P*lambda/static_cast<double> (tableidx);
+            t[tableidx] = t[tableidx-1] + P;
+            if (t[tableidx] == t[tableidx-1]) t[tableidx] = 1.0;
+            tableidx++;
+            if (u <= t[tableidx-1]) break;
+          }
 
-      p[i] = static_cast<float> (tableidx-1);
-    }
-}
+        p[i] = static_cast<float> (tableidx-1);
+      }
+  }
 
-/* From Press, et al., Numerical Recipes */
-static void
-poisson_rejection (double lambda, double *p, size_t n)
-{
-  double sq = std::sqrt (2.0*lambda);
-  double alxm = std::log (lambda);
-  double g = lambda*alxm - LGAMMA(lambda+1.0);
-  size_t i;
+  /* From Press, et al., Numerical Recipes */
+  static void poisson_rejection (double lambda, double *p, size_t n)
+  {
+    double sq = std::sqrt (2.0*lambda);
+    double alxm = std::log (lambda);
+    double g = lambda*alxm - xlgamma (lambda+1.0);
+    size_t i;
 
-  for (i = 0; i < n; i++)
-    {
-      double y, em, t;
-      do
-        {
-          do
-            {
-              y = tan (M_PI*RUNI);
-              em = sq * y + lambda;
-            } while (em < 0.0);
-          em = std::floor (em);
-          t = 0.9*(1.0+y*y)*exp (em*alxm-flogfak (em)-g);
-        } while (RUNI > t);
-      p[i] = em;
-    }
-}
+    for (i = 0; i < n; i++)
+      {
+        double y, em, t;
+        do
+          {
+            do
+              {
+                y = tan (M_PI*octave::rand_uniform<double> ());
+                em = sq * y + lambda;
+              } while (em < 0.0);
+            em = std::floor (em);
+            t = 0.9*(1.0+y*y)*exp (em*alxm-flogfak (em)-g);
+          } while (octave::rand_uniform<double> () > t);
+        p[i] = em;
+      }
+  }
 
-/* From Press, et al., Numerical Recipes */
-static void
-poisson_rejection_float (double lambda, float *p, size_t n)
-{
-  double sq = std::sqrt (2.0*lambda);
-  double alxm = std::log (lambda);
-  double g = lambda*alxm - LGAMMA(lambda+1.0);
-  size_t i;
+  /* From Press, et al., Numerical Recipes */
+  static void poisson_rejection_float (double lambda, float *p, size_t n)
+  {
+    double sq = std::sqrt (2.0*lambda);
+    double alxm = std::log (lambda);
+    double g = lambda*alxm - xlgamma (lambda+1.0);
+    size_t i;
 
-  for (i = 0; i < n; i++)
-    {
-      double y, em, t;
-      do
-        {
-          do
-            {
-              y = tan (M_PI*RUNI);
-              em = sq * y + lambda;
-            } while (em < 0.0);
-          em = std::floor (em);
-          t = 0.9*(1.0+y*y)*exp (em*alxm-flogfak (em)-g);
-        } while (RUNI > t);
-      p[i] = em;
-    }
-}
+    for (i = 0; i < n; i++)
+      {
+        double y, em, t;
+        do
+          {
+            do
+              {
+                y = tan (M_PI*octave::rand_uniform<double> ());
+                em = sq * y + lambda;
+              } while (em < 0.0);
+            em = std::floor (em);
+            t = 0.9*(1.0+y*y)*exp (em*alxm-flogfak (em)-g);
+          } while (octave::rand_uniform<double> () > t);
+        p[i] = em;
+      }
+  }
 
-/* The cutoff of L <= 1e8 in the following two functions before using
- * the normal approximation is based on:
- *   > L=1e8; x=floor(linspace(0,2*L,1000));
- *   > max(abs(normal_pdf(x,L,L)-poisson_pdf(x,L)))
- *   ans = 1.1376e-28
- * For L=1e7, the max is around 1e-9, which is within the step size of RUNI.
- * For L>1e10 the pprsc function breaks down, as I saw from the histogram
- * of a large sample, so 1e8 is both small enough and large enough. */
+  /* The cutoff of L <= 1e8 in the following two functions before using
+   * the normal approximation is based on:
+   *   > L=1e8; x=floor(linspace(0,2*L,1000));
+   *   > max(abs(normal_pdf(x,L,L)-poisson_pdf(x,L)))
+   *   ans = 1.1376e-28
+   * For L=1e7, the max is around 1e-9, which is within the step size of
+   * rand_uniform.  For L>1e10 the pprsc function breaks down, as I saw
+   * from the histogram of a large sample, so 1e8 is both small enough
+   * and large enough. */
 
-/* Generate a set of poisson numbers with the same distribution */
-void
-oct_fill_randp (double L, octave_idx_type n, double *p)
-{
-  octave_idx_type i;
-  if (L < 0.0 || INFINITE(L))
-    {
-      for (i=0; i<n; i++)
-        p[i] = octave::numeric_limits<double>::NaN ();
-    }
-  else if (L <= 10.0)
-    {
-      poisson_cdf_lookup (L, p, n);
-    }
-  else if (L <= 1e8)
-    {
-      for (i=0; i<n; i++)
-        p[i] = pprsc (L);
-    }
-  else
-    {
-      /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
-      const double sqrtL = std::sqrt (L);
-      for (i = 0; i < n; i++)
-        {
-          p[i] = std::floor (RNOR*sqrtL + L + 0.5);
-          if (p[i] < 0.0)
-            p[i] = 0.0; /* will probably never happen */
-        }
-    }
-}
+  /* Generate a set of poisson numbers with the same distribution */
+  template <> void rand_poisson<double> (double L, octave_idx_type n, double *p)
+  {
+    octave_idx_type i;
+    if (L < 0.0 || lo_ieee_isinf (L))
+      {
+        for (i=0; i<n; i++)
+          p[i] = numeric_limits<double>::NaN ();
+      }
+    else if (L <= 10.0)
+      {
+        poisson_cdf_lookup (L, p, n);
+      }
+    else if (L <= 1e8)
+      {
+        for (i=0; i<n; i++)
+          p[i] = pprsc (L);
+      }
+    else
+      {
+        /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
+        const double sqrtL = std::sqrt (L);
+        for (i = 0; i < n; i++)
+          {
+            p[i] = std::floor (rand_normal<double> () * sqrtL + L + 0.5);
+            if (p[i] < 0.0)
+              p[i] = 0.0; /* will probably never happen */
+          }
+      }
+  }
 
-/* Generate one poisson variate */
-double
-oct_randp (double L)
-{
-  double ret;
-  if (L < 0.0) ret = octave::numeric_limits<double>::NaN ();
-  else if (L <= 12.0)
-    {
-      /* From Press, et al. Numerical recipes */
-      double g = exp (-L);
-      int em = -1;
-      double t = 1.0;
-      do
-        {
-          ++em;
-          t *= RUNI;
-        } while (t > g);
-      ret = em;
-    }
-  else if (L <= 1e8)
-    {
-      /* numerical recipes */
-      poisson_rejection (L, &ret, 1);
-    }
-  else if (INFINITE(L))
-    {
-      /* FIXME: R uses NaN, but the normal approximation suggests that
-       * limit should be Inf.  Which is correct? */
-      ret = octave::numeric_limits<double>::NaN ();
-    }
-  else
-    {
-      /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
-      ret = std::floor (RNOR*std::sqrt (L) + L + 0.5);
-      if (ret < 0.0) ret = 0.0; /* will probably never happen */
-    }
-  return ret;
-}
+  /* Generate one poisson variate */
+  template <> double rand_poisson<double> (double L)
+  {
+    double ret;
+    if (L < 0.0) ret = numeric_limits<double>::NaN ();
+    else if (L <= 12.0)
+      {
+        /* From Press, et al. Numerical recipes */
+        double g = exp (-L);
+        int em = -1;
+        double t = 1.0;
+        do
+          {
+            ++em;
+            t *= rand_uniform<double> ();
+          } while (t > g);
+        ret = em;
+      }
+    else if (L <= 1e8)
+      {
+        /* numerical recipes */
+        poisson_rejection (L, &ret, 1);
+      }
+    else if (lo_ieee_isinf (L))
+      {
+        /* FIXME: R uses NaN, but the normal approximation suggests that
+         * limit should be Inf.  Which is correct? */
+        ret = numeric_limits<double>::NaN ();
+      }
+    else
+      {
+        /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
+        ret = std::floor (rand_normal<double> () * std::sqrt (L) + L + 0.5);
+        if (ret < 0.0) ret = 0.0; /* will probably never happen */
+      }
+    return ret;
+  }
 
-/* Generate a set of poisson numbers with the same distribution */
-void
-oct_fill_float_randp (float FL, octave_idx_type n, float *p)
-{
-  double L = FL;
-  octave_idx_type i;
-  if (L < 0.0 || INFINITE(L))
-    {
-      for (i=0; i<n; i++)
-        p[i] = octave::numeric_limits<double>::NaN ();
-    }
-  else if (L <= 10.0)
-    {
-      poisson_cdf_lookup_float (L, p, n);
-    }
-  else if (L <= 1e8)
-    {
-      for (i=0; i<n; i++)
-        p[i] = pprsc (L);
-    }
-  else
-    {
-      /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
-      const double sqrtL = std::sqrt (L);
-      for (i = 0; i < n; i++)
-        {
-          p[i] = std::floor (RNOR*sqrtL + L + 0.5);
-          if (p[i] < 0.0)
-            p[i] = 0.0; /* will probably never happen */
-        }
-    }
-}
+  /* Generate a set of poisson numbers with the same distribution */
+  template <> void rand_poisson<float> (float FL, octave_idx_type n, float *p)
+  {
+    double L = FL;
+    octave_idx_type i;
+    if (L < 0.0 || lo_ieee_isinf (L))
+      {
+        for (i=0; i<n; i++)
+          p[i] = numeric_limits<double>::NaN ();
+      }
+    else if (L <= 10.0)
+      {
+        poisson_cdf_lookup_float (L, p, n);
+      }
+    else if (L <= 1e8)
+      {
+        for (i=0; i<n; i++)
+          p[i] = pprsc (L);
+      }
+    else
+      {
+        /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
+        const double sqrtL = std::sqrt (L);
+        for (i = 0; i < n; i++)
+          {
+            p[i] = std::floor (rand_normal<float> () * sqrtL + L + 0.5);
+            if (p[i] < 0.0)
+              p[i] = 0.0; /* will probably never happen */
+          }
+      }
+  }
 
-/* Generate one poisson variate */
-float
-oct_float_randp (float FL)
-{
-  double L = FL;
-  float ret;
-  if (L < 0.0) ret = octave::numeric_limits<float>::NaN ();
-  else if (L <= 12.0)
-    {
-      /* From Press, et al. Numerical recipes */
-      double g = exp (-L);
-      int em = -1;
-      double t = 1.0;
-      do
-        {
-          ++em;
-          t *= RUNI;
-        } while (t > g);
-      ret = em;
-    }
-  else if (L <= 1e8)
-    {
-      /* numerical recipes */
-      poisson_rejection_float (L, &ret, 1);
-    }
-  else if (INFINITE(L))
-    {
-      /* FIXME: R uses NaN, but the normal approximation suggests that
-       * limit should be Inf. Which is correct? */
-      ret = octave::numeric_limits<float>::NaN ();
-    }
-  else
-    {
-      /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
-      ret = std::floor (RNOR*std::sqrt (L) + L + 0.5);
-      if (ret < 0.0) ret = 0.0; /* will probably never happen */
-    }
-  return ret;
+  /* Generate one poisson variate */
+  template <> float rand_poisson<float> (float FL)
+  {
+    double L = FL;
+    float ret;
+    if (L < 0.0) ret = numeric_limits<float>::NaN ();
+    else if (L <= 12.0)
+      {
+        /* From Press, et al. Numerical recipes */
+        double g = exp (-L);
+        int em = -1;
+        double t = 1.0;
+        do
+          {
+            ++em;
+            t *= rand_uniform<float> ();
+          } while (t > g);
+        ret = em;
+      }
+    else if (L <= 1e8)
+      {
+        /* numerical recipes */
+        poisson_rejection_float (L, &ret, 1);
+      }
+    else if (lo_ieee_isinf (L))
+      {
+        /* FIXME: R uses NaN, but the normal approximation suggests that
+         * limit should be Inf. Which is correct? */
+        ret = numeric_limits<float>::NaN ();
+      }
+    else
+      {
+        /* normal approximation: from Phys. Rev. D (1994) v50 p1284 */
+        ret = std::floor (rand_normal<float> () * std::sqrt (L) + L + 0.5);
+        if (ret < 0.0) ret = 0.0; /* will probably never happen */
+      }
+    return ret;
+  }
 }
diff --git a/liboctave/numeric/randpoisson.h b/liboctave/numeric/randpoisson.h
--- a/liboctave/numeric/randpoisson.h
+++ b/liboctave/numeric/randpoisson.h
@@ -23,21 +23,54 @@ along with Octave; see the file COPYING.
 /* Original version written by Paul Kienzle distributed as free
    software in the in the public domain.  */
 
 #if ! defined (octave_randpoisson_h)
 #define octave_randpoisson_h 1
 
 #include "octave-config.h"
 
-extern OCTAVE_API double
-oct_randp (double L);
+namespace octave
+{
+  template <typename T> T rand_poisson (T L);
+
+  template <> double rand_poisson<double> (double L);
+  template <> float rand_poisson<float> (float L);
 
-extern OCTAVE_API void
-oct_fill_randp (double L, octave_idx_type n, double *p);
+  template <typename T> void
+  rand_poisson (T L, octave_idx_type n, T *p);
+
+  template <> void
+  rand_poisson<double> (double L, octave_idx_type n, double *p);
+
+  template <> void
+  rand_poisson<float> (float L, octave_idx_type n, float *p);
+}
 
-extern OCTAVE_API float
-oct_float_randp (float L);
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_poisson<double>' instead")
+inline double
+oct_randp (double L)
+{
+  return octave::rand_poisson (L);
+}
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_poisson<double>' instead")
+inline void
+oct_fill_randp (double L, octave_idx_type n, double *p)
+{
+  octave::rand_poisson (L, n, p);
+}
 
-extern OCTAVE_API void
-oct_fill_float_randp (float L, octave_idx_type n, float *p);
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_poisson<float>' instead")
+inline float
+oct_float_randp (float L)
+{
+  return octave::rand_poisson (L);
+}
+
+OCTAVE_DEPRECATED (4.4, "use 'octave::rand_poisson<float>' instead")
+inline void
+oct_fill_float_randp (float L, octave_idx_type n, float *p)
+{
+  octave::rand_poisson (L, n, p);
+}
 
 #endif
