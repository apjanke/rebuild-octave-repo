# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1210182330 14400
#      Wed May 07 13:45:30 2008 -0400
# Node ID 71f068b22fccc42d7a55b2cb379887eda29406eb
# Parent  fc81e027c53c487657f0799289f1ee82131c8e95
scope and context fixes for function handles

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,72 @@
+2008-05-07  John W. Eaton  <jwe@octave.org>
+
+	* pt-arg-list.cc, pt-arg-list.h (tree_argument_list::dup):
+	New arg, context.
+	* pt-assign.cc, pt-assign.h (tree_simple_assignment::dup,
+	tree_multi_assignment::dup): Likewise.
+	* pt-binop.cc, pt-binop.h (tree_binary_expression::dup,
+	tree_boolean_expression::dup): Likewise.
+	* pt-cell.cc, pt-cell.h (tree_cell::dup): Likewise.
+	* pt-cmd.cc, pt-cmd.h (tree_no_op_command::dup,
+	tree_function_def::dup): Likewise.
+	* pt-colon.cc, pt-colon.h (tree_colon_expression::dup): Likewise.
+	* pt-const.cc, pt-const.h (tree_constant::dup): Likewise.
+	* pt-decl.cc, pt-decl.h (tree_decl_elt::dup, tree_decl_init_list::dup,
+	tree_global_command::dup, tree_static_command::dup): Likewise.
+	* pt-except.cc, pt-except.h (tree_try_catch_command::dup,
+	tree_unwind_protect_command::dup): Likewise.
+	* pt-exp.h (tree_expression:dup): Likewise.
+	* pt-fcn-handle.cc, pt-exp.h (tree_expression:dup): Likewise.
+	* pt-fcn-handle.h (tree_fcn_handle::dup,
+	tree_anon_fcn_handle::dup): Likewise.
+	* pt-id.cc, pt-id.h (tree_identifier::dup): Likewise.
+	* pt-idx.cc, pt-idx.h (tree_index_expression::dup): Likewise.
+	* pt-jump.cc, pt-jump.h (tree_break_command::dup,
+	tree_continue_command::dup, tree_return_command::dup): Likewise.
+	* pt-loop.cc, pt-loop.h (tree_while_command::dup,
+	tree_do_until_command::dup, tree_simple_for_command::dup,
+	tree_complex_for_command::dup): Likewise.
+	* pt-mat.cc, pt-mat.h (tree_matrix::dup): Likewise.
+	* pt-misc.cc, pt-misc.h (tree_parameter_list::dup,
+	tree_return_list::dup): Likewise.
+	* pt-select.cc, pt-select.h (tree_if_clause::dup,
+	tree_if_command_list::dup, tree_if_command::dup,
+	tree_switch_case::dup, tree_switch_case_list::dup,
+	tree_switch_command::dup, tree_statement::dup,
+	tree_statement_list::dup, tree_prefix_expression::dup,
+	tree_postfix_expression::dup): Likewise.
+
+	* ov-fcn-handle.cc (octave_fcn_handle::save_ascii,
+	octave_fcn_handle::save_binary, octave_fcn_handle::save_hdf5):
+ 	Pass context to symbol_table::all_variables.
+	* load-save.cc (dump_octave_core): Likewise.
+	* ov-fcn-handle.cc (Ffunctions): Don't skip anonymous functions
+	with the name set to the text of the function body.
+ 	Pass context to symbol_table::all_variables and
+	symbol_table::symbol_record::varval.
+
+	* symtab.h (symbol_table::varref, symbol_table::do_varref,
+	symbol_table::varval, symbol_table::do_varval,
+	symbol_table::all_variables, symbol_table::do_all_variables, 
+	symbol_table::symbol_record::varref,
+	symbol_table::symbol_record::varval,
+	symbol_table::symbol_record::is_defined,
+	symbol_table::symbol_record::is_variable,
+	symbol_table::symbol_record::symbol_record_rep::varref,
+	symbol_table::symbol_record::symbol_record_rep::varval,
+	symbol_table::symbol_record::symbol_record_rep::is_defined,
+	symbol_table::symbol_record::symbol_record_rep::is_variable,
+	):
+	* symtab.h (symbol_table::do_inherit): New arg, donor_context.
+	Look for value in donor_contxt.  Set value in base context.
+	* symtab.cc (symbol_table::symbol_record::symbol_record_rep::dump):
+	Pass xcurrent_context to varval.
+
 2008-05-06  David Bateman  <dbateman@free.fr>
 
 	* ov-fcn-inline.cc (Finline): Also ignore NaN, Inf, pi, NA and eps.
 
 	* bitfcns.cc (BITOP): Treat octave_bool types and octave_scalar.
 
 2008-05-06  John W. Eaton  <jwe@octave.org>
 
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -1265,17 +1265,18 @@ save_vars (const string_vector& argv, in
 }
 
 static void
 dump_octave_core (std::ostream& os, const char *fname, load_save_format fmt,
 		  bool save_as_floats)
 {
   write_header (os, fmt);
 
-  std::list<symbol_table::symbol_record> vars = symbol_table::all_variables ();
+  std::list<symbol_table::symbol_record> vars
+    = symbol_table::all_variables (symbol_table::top_scope (), 0);
 
   double save_mem_size = 0;
 
   typedef std::list<symbol_table::symbol_record>::const_iterator const_vars_iterator;
 
   for (const_vars_iterator p = vars.begin (); p != vars.end (); p++)
     {
       octave_value val = p->varval ();
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -237,17 +237,17 @@ octave_fcn_handle::save_ascii (std::ostr
       os << "\n";
 
       if (fcn.is_undefined ())
 	return false;
 
       octave_user_function *f = fcn.user_function_value ();
 
       std::list<symbol_table::symbol_record> vars
-	= symbol_table::all_variables (f->scope ());
+	= symbol_table::all_variables (f->scope (), 0);
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
 	{
 	  os << "# length: " << varlen << "\n";
 
 	  for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
@@ -405,17 +405,17 @@ octave_fcn_handle::save_binary (std::ost
       std::ostringstream nmbuf;
 
       if (fcn.is_undefined ())
 	return false;
 
       octave_user_function *f = fcn.user_function_value ();
 
       std::list<symbol_table::symbol_record> vars
-	= symbol_table::all_variables (f->scope ());
+	= symbol_table::all_variables (f->scope (), 0);
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
 	nmbuf << nm << " " << varlen;
       else
 	nmbuf << nm;
 
@@ -649,17 +649,17 @@ octave_fcn_handle::save_hdf5 (hid_t loc_
 	  return false;
 	}
 
       H5Dclose (data_hid);
 
       octave_user_function *f = fcn.user_function_value ();
 
       std::list<symbol_table::symbol_record> vars
-	= symbol_table::all_variables (f->scope ());
+	= symbol_table::all_variables (f->scope (), 0);
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
 	{
 	  hid_t as_id = H5Screate (H5S_SCALAR);
 
 	  if (as_id >= 0)
@@ -1271,51 +1271,46 @@ Return a struct containing information a
 		      m.assign ("parentage", octave_value (parentage)); 
 		    }
 		  else
 		    m.assign ("type", "simple");
 		}
 
 	      std::string nm = fcn->fcn_file_name ();
 
-	      if (nm.empty ())
+	      if (fh_nm == "@<anonymous>")
 		{
-		  if (fh_nm == "@<anonymous>")
-		    {
-		      m.assign ("file", "");
+		  m.assign ("file", nm);
+
+		  octave_user_function *fu = fh->user_function_value ();
 
-		      octave_user_function *fu = fh->user_function_value ();
+		  std::list<symbol_table::symbol_record> vars
+		    = symbol_table::all_variables (fu->scope (), 0);
+
+		  size_t varlen = vars.size ();
 
-		      std::list<symbol_table::symbol_record> vars
-			= symbol_table::all_variables (fu->scope ());
-
-		      size_t varlen = vars.size ();
-
-		      if (varlen > 0)
+		  if (varlen > 0)
+		    {
+		      Octave_map ws;
+		      for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
+			   p != vars.end (); p++)
 			{
-			  Octave_map ws;
-			  for (std::list<symbol_table::symbol_record>::const_iterator p = vars.begin ();
-			       p != vars.end (); p++)
-			    {
-			      ws.assign (p->name (), p->varval ());
-			    }
-
-			  m.assign ("workspace", ws);
+			  ws.assign (p->name (), p->varval (0));
 			}
+
+		      m.assign ("workspace", ws);
 		    }
-		  else if (fcn->is_user_function () || fcn->is_user_script ())
-		    {
-		      octave_function *fu = fh->function_value ();
-		      m.assign ("file", fu->fcn_file_name ());
-		    }
-		  else
-		    m.assign ("file", "");
+		}
+	      else if (fcn->is_user_function () || fcn->is_user_script ())
+		{
+		  octave_function *fu = fh->function_value ();
+		  m.assign ("file", fu->fcn_file_name ());
 		}
 	      else
-		m.assign ("file", nm);
+		m.assign ("file", "");
 
 	      retval = m;
 	    }
 	  else
 	    error ("functions: invalid function handle object");
 	}
       else
 	error ("functions: argument must be a function handle object");
@@ -1382,12 +1377,27 @@ Return a function handle constructed fro
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
+%!function y = testrecursionfunc (f, x, n)
+%!  if (nargin < 3)
+%!    n = 0;
+%!  endif
+%!  if (n > 2)
+%!    y = f (x);
+%!  else
+%!    n++;
+%!    y = testrecursionfunc (@(x) f(2*x), x, n);
+%!  endif
+%!test
+%! assert (testrecursionfunc (@(x) x, 1), 8);
+*/
+
+/*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-arg-list.cc b/src/pt-arg-list.cc
--- a/src/pt-arg-list.cc
+++ b/src/pt-arg-list.cc
@@ -248,28 +248,29 @@ tree_argument_list::get_arg_names (void)
 
       retval(k++) = elt->str_print_code ();
     }
 
   return retval;
 }
 
 tree_argument_list *
-tree_argument_list::dup (symbol_table::scope_id scope)
+tree_argument_list::dup (symbol_table::scope_id scope,
+			 symbol_table::context_id context)
 {
   tree_argument_list *new_list = new tree_argument_list ();
 
   new_list->list_includes_magic_end = list_includes_magic_end;
   new_list->simple_assign_lhs = simple_assign_lhs;
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_expression *elt = *p;
 
-      new_list->append (elt ? elt->dup (scope) : 0);
+      new_list->append (elt ? elt->dup (scope, context) : 0);
     }
 
   return new_list;
 }
 
 void
 tree_argument_list::accept (tree_walker& tw)
 {
diff --git a/src/pt-arg-list.h b/src/pt-arg-list.h
--- a/src/pt-arg-list.h
+++ b/src/pt-arg-list.h
@@ -73,17 +73,18 @@ public:
   bool all_elements_are_constant (void) const;
 
   octave_value_list convert_to_const_vector (const octave_value *object = 0);
 
   std::list<octave_lvalue> lvalue_list (void);
 
   string_vector get_arg_names (void) const;
 
-  tree_argument_list *dup (symbol_table::scope_id scope);
+  tree_argument_list *dup (symbol_table::scope_id scope,
+			   symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   bool list_includes_magic_end;
 
   bool simple_assign_lhs;
diff --git a/src/pt-assign.cc b/src/pt-assign.cc
--- a/src/pt-assign.cc
+++ b/src/pt-assign.cc
@@ -284,21 +284,22 @@ tree_simple_assignment::eval_error (void
 
 std::string
 tree_simple_assignment::oper (void) const
 {
   return octave_value::assign_op_as_string (etype);
 }
 
 tree_expression *
-tree_simple_assignment::dup (symbol_table::scope_id scope)
+tree_simple_assignment::dup (symbol_table::scope_id scope,
+			     symbol_table::context_id context)
 {
   tree_simple_assignment *new_sa
-    = new tree_simple_assignment (lhs ? lhs->dup (scope) : 0,
-				  rhs ? rhs->dup (scope) : 0,
+    = new tree_simple_assignment (lhs ? lhs->dup (scope, context) : 0,
+				  rhs ? rhs->dup (scope, context) : 0,
 				  preserve, etype);
 
   new_sa->copy_base (*this);
 
   return new_sa;
 }
 
 void
@@ -511,21 +512,22 @@ tree_multi_assignment::eval_error (void)
 
 std::string
 tree_multi_assignment::oper (void) const
 {
   return octave_value::assign_op_as_string (etype);
 }
 
 tree_expression *
-tree_multi_assignment::dup (symbol_table::scope_id scope)
+tree_multi_assignment::dup (symbol_table::scope_id scope,
+			    symbol_table::context_id context)
 {
   tree_multi_assignment *new_ma
-    = new tree_multi_assignment (lhs ? lhs->dup (scope) : 0,
-				 rhs ? rhs->dup (scope) : 0,
+    = new tree_multi_assignment (lhs ? lhs->dup (scope, context) : 0,
+				 rhs ? rhs->dup (scope, context) : 0,
 				 preserve, etype);
 
   new_ma->copy_base (*this);
 
   return new_ma;
 }
 
 void
diff --git a/src/pt-assign.h b/src/pt-assign.h
--- a/src/pt-assign.h
+++ b/src/pt-assign.h
@@ -68,17 +68,18 @@ public:
   void eval_error (void);
 
   std::string oper (void) const;
 
   tree_expression *left_hand_side (void) { return lhs; }
 
   tree_expression *right_hand_side (void) { return rhs; }
 
-  tree_expression *dup (symbol_table::scope_id scope);
+  tree_expression *dup (symbol_table::scope_id scope,
+			symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
   octave_value::assign_op op_type (void) const { return etype; }
 
 private:
 
   void do_assign (octave_lvalue& ult, const octave_value_list& args,
@@ -138,17 +139,18 @@ public:
   void eval_error (void);
 
   std::string oper (void) const;
 
   tree_argument_list *left_hand_side (void) { return lhs; }
 
   tree_expression *right_hand_side (void) { return rhs; }
 
-  tree_expression *dup (symbol_table::scope_id scope);
+  tree_expression *dup (symbol_table::scope_id scope,
+			symbol_table::context_id context);
 
   void accept (tree_walker& tw);
   
   octave_value::assign_op op_type (void) const { return etype; }
 
 private:
 
   // The left hand side of the assignment.
diff --git a/src/pt-binop.cc b/src/pt-binop.cc
--- a/src/pt-binop.cc
+++ b/src/pt-binop.cc
@@ -101,21 +101,22 @@ tree_binary_expression::eval_error (void
 
 std::string
 tree_binary_expression::oper (void) const
 {
   return octave_value::binary_op_as_string (etype);
 }
 
 tree_expression *
-tree_binary_expression::dup (symbol_table::scope_id scope)
+tree_binary_expression::dup (symbol_table::scope_id scope,
+			     symbol_table::context_id context)
 {
   tree_binary_expression *new_be
-    = new tree_binary_expression (op_lhs ? op_lhs->dup (scope) : 0,
-				  op_rhs ? op_rhs->dup (scope) : 0,
+    = new tree_binary_expression (op_lhs ? op_lhs->dup (scope, context) : 0,
+				  op_rhs ? op_rhs->dup (scope, context) : 0,
 				  line (), column (), etype);
 
   new_be->copy_base (*this);
 
   return new_be;
 }
 
 void
@@ -228,21 +229,22 @@ tree_boolean_expression::oper (void) con
     default:
       break;
     }
 
   return retval;
 }
 
 tree_expression *
-tree_boolean_expression::dup (symbol_table::scope_id scope)
+tree_boolean_expression::dup (symbol_table::scope_id scope,
+			      symbol_table::context_id context)
 {
   tree_boolean_expression *new_be
-    = new tree_boolean_expression (op_lhs ? op_lhs->dup (scope) : 0,
-				   op_rhs ? op_rhs->dup (scope) : 0,
+    = new tree_boolean_expression (op_lhs ? op_lhs->dup (scope, context) : 0,
+				   op_rhs ? op_rhs->dup (scope, context) : 0,
 				   line (), column (), etype);
 
   new_be->copy_base (*this);
 
   return new_be;
 }
 
 /*
diff --git a/src/pt-binop.h b/src/pt-binop.h
--- a/src/pt-binop.h
+++ b/src/pt-binop.h
@@ -78,17 +78,18 @@ public:
 
   std::string oper (void) const;
 
   octave_value::binary_op op_type (void) const { return etype; }
 
   tree_expression *lhs (void) { return op_lhs; }
   tree_expression *rhs (void) { return op_rhs; }
 
-  tree_expression *dup (symbol_table::scope_id scope);
+  tree_expression *dup (symbol_table::scope_id scope,
+			symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 protected:
 
   // The operands for the expression.
   tree_expression *op_lhs;
   tree_expression *op_rhs;
@@ -135,17 +136,18 @@ public:
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   std::string oper (void) const;
 
   type op_type (void) const { return etype; }
 
-  tree_expression *dup (symbol_table::scope_id scope);
+  tree_expression *dup (symbol_table::scope_id scope,
+			symbol_table::context_id context);
 
 private:
 
   // The type of the expression.
   type etype;
 
   // No copying!
 
diff --git a/src/pt-cell.cc b/src/pt-cell.cc
--- a/src/pt-cell.cc
+++ b/src/pt-cell.cc
@@ -97,25 +97,26 @@ tree_cell::rvalue (int nargout)
     error ("invalid number of output arguments for cell array");
   else
     retval = rvalue ();
 
   return retval;
 }
 
 tree_expression *
-tree_cell::dup (symbol_table::scope_id scope)
+tree_cell::dup (symbol_table::scope_id scope,
+		symbol_table::context_id context)
 {
   tree_cell *new_cell = new tree_cell (0, line (), column ());
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_argument_list *elt = *p;
 
-      new_cell->append (elt ? elt->dup (scope) : 0);
+      new_cell->append (elt ? elt->dup (scope, context) : 0);
     }
 
   new_cell->copy_base (*this);
 
   return new_cell;
 }
 
 void
diff --git a/src/pt-cell.h b/src/pt-cell.h
--- a/src/pt-cell.h
+++ b/src/pt-cell.h
@@ -48,17 +48,18 @@ public:
   ~tree_cell (void) { }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int);
 
-  tree_expression *dup (symbol_table::scope_id scope);
+  tree_expression *dup (symbol_table::scope_id scope,
+			symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_cell (const tree_cell&);
diff --git a/src/pt-cmd.cc b/src/pt-cmd.cc
--- a/src/pt-cmd.cc
+++ b/src/pt-cmd.cc
@@ -26,17 +26,18 @@ along with Octave; see the file COPYING.
 #endif
 
 #include "pt-cmd.h"
 #include "pt-walk.h"
 
 // No-op.
 
 tree_command *
-tree_no_op_command::dup (symbol_table::scope_id)
+tree_no_op_command::dup (symbol_table::scope_id,
+			 symbol_table::context_id context)
 {
   return new tree_no_op_command (orig_cmd, line (), column ());
 }
 
 void
 tree_no_op_command::accept (tree_walker& tw)
 {
   tw.visit_no_op_command (*this);
@@ -58,17 +59,18 @@ tree_function_def::eval (void)
       // Make sure that any variable with the same name as the new
       // function is cleared.
 
       symbol_table::varref (nm) = octave_value ();
     }
 }
 
 tree_command *
-tree_function_def::dup (symbol_table::scope_id)
+tree_function_def::dup (symbol_table::scope_id,
+			symbol_table::context_id context)
 {
   return new tree_function_def (fcn, line (), column ());
 }
 
 void
 tree_function_def::accept (tree_walker& tw)
 {
   tw.visit_function_def (*this);
diff --git a/src/pt-cmd.h b/src/pt-cmd.h
--- a/src/pt-cmd.h
+++ b/src/pt-cmd.h
@@ -42,17 +42,18 @@ public:
 
   tree_command (int l = -1, int c = -1)
     : tree (l, c) { }
 
   virtual ~tree_command (void) { }
 
   virtual void eval (void) = 0;
 
-  virtual tree_command *dup (symbol_table::scope_id) = 0;
+  virtual tree_command *dup (symbol_table::scope_id,
+			     symbol_table::context_id context) = 0;
 
 private:
 
   // No copying!
 
   tree_command (const tree_command&);
 
   tree_command& operator = (const tree_command&);
@@ -67,17 +68,18 @@ public:
 
   tree_no_op_command (const std::string& cmd = "no_op", int l = -1, int c = -1)
     : tree_command (l, c), orig_cmd (cmd) { }
 
   ~tree_no_op_command (void) { }
 
   void eval (void) { MAYBE_DO_BREAKPOINT; }
 
-  tree_command *dup (symbol_table::scope_id scope);
+  tree_command *dup (symbol_table::scope_id scope,
+		     symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
   std::string original_command (void) { return orig_cmd; }
 
 private:
 
   std::string orig_cmd;
@@ -98,17 +100,18 @@ public:
 
   tree_function_def (octave_function *f, int l = -1, int c = -1)
     : tree_command (l, c), fcn (f) { }
 
   ~tree_function_def (void) { }
 
   void eval (void);
 
-  tree_command *dup (symbol_table::scope_id scope);
+  tree_command *dup (symbol_table::scope_id scope,
+		     symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
   octave_function *function (void) { return fcn.function_value (); }
 
 private:
 
   octave_value fcn;
diff --git a/src/pt-colon.cc b/src/pt-colon.cc
--- a/src/pt-colon.cc
+++ b/src/pt-colon.cc
@@ -205,23 +205,24 @@ tree_colon_expression::column (void) con
 {
   return (op_base ? op_base->column ()
 	  : (op_increment ? op_increment->column ()
 	     : (op_limit ? op_limit->column ()
 		: -1)));
 }
 
 tree_expression *
-tree_colon_expression::dup (symbol_table::scope_id scope)
+tree_colon_expression::dup (symbol_table::scope_id scope,
+			    symbol_table::context_id context)
 {
-  tree_colon_expression *new_ce
-    = new tree_colon_expression (op_base ? op_base->dup (scope) : 0,
-				 op_limit ? op_limit->dup (scope) : 0,
-				 op_increment ? op_increment->dup (scope) : 0,
-				 line (), column ());
+  tree_colon_expression *new_ce = new
+    tree_colon_expression (op_base ? op_base->dup (scope, context) : 0,
+			   op_limit ? op_limit->dup (scope, context) : 0,
+			   op_increment ? op_increment->dup (scope, context) : 0,
+			   line (), column ());
 
   new_ce->copy_base (*new_ce);
 
   return new_ce;
 }
 
 void
 tree_colon_expression::accept (tree_walker& tw)
diff --git a/src/pt-colon.h b/src/pt-colon.h
--- a/src/pt-colon.h
+++ b/src/pt-colon.h
@@ -87,17 +87,18 @@ public:
 
   tree_expression *limit (void) { return op_limit; }
 
   tree_expression *increment (void) { return op_increment; }
 
   int line (void) const;
   int column (void) const;
 
-  tree_expression *dup (symbol_table::scope_id scope);
+  tree_expression *dup (symbol_table::scope_id scope,
+			symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The components of the expression.
   tree_expression *op_base;
   tree_expression *op_limit;
diff --git a/src/pt-const.cc b/src/pt-const.cc
--- a/src/pt-const.cc
+++ b/src/pt-const.cc
@@ -66,17 +66,18 @@ tree_constant::rvalue (int nargout)
     error ("invalid number of output arguments for constant expression");
   else
     retval = rvalue ();
 
   return retval;
 }
 
 tree_expression *
-tree_constant::dup (symbol_table::scope_id)
+tree_constant::dup (symbol_table::scope_id,
+		    symbol_table::context_id context)
 {
   tree_constant *new_tc
     = new tree_constant (val, orig_text, line (), column ());
 
   new_tc->copy_base (*this);
 
   return new_tc;
 }
diff --git a/src/pt-const.h b/src/pt-const.h
--- a/src/pt-const.h
+++ b/src/pt-const.h
@@ -77,17 +77,18 @@ public:
   octave_value rvalue (void)
     {
       MAYBE_DO_BREAKPOINT;
       return val;
     }
 
   octave_value_list rvalue (int nargout);
 
-  tree_expression *dup (symbol_table::scope_id scope);
+  tree_expression *dup (symbol_table::scope_id scope,
+			symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
   // Store the original text corresponding to this constant for later
   // pretty printing.
 
   void stash_original_text (const std::string& s) { orig_text = s; }
 
diff --git a/src/pt-decl.cc b/src/pt-decl.cc
--- a/src/pt-decl.cc
+++ b/src/pt-decl.cc
@@ -64,20 +64,21 @@ tree_decl_elt::eval (void)
 	  retval = true;
 	}
     }
 
   return retval;
 }
 
 tree_decl_elt *
-tree_decl_elt::dup (symbol_table::scope_id scope)
+tree_decl_elt::dup (symbol_table::scope_id scope,
+		    symbol_table::context_id context)
 {
-  return new tree_decl_elt (id ? id->dup (scope) : 0,
-			    expr ? expr->dup (scope) : 0);
+  return new tree_decl_elt (id ? id->dup (scope, context) : 0,
+			    expr ? expr->dup (scope, context) : 0);
 }
 
 void
 tree_decl_elt::accept (tree_walker& tw)
 {
   tw.visit_decl_elt (*this);
 }
 
@@ -93,25 +94,26 @@ tree_decl_init_list::eval (tree_decl_elt
       f (*elt);
 
       if (error_state)
 	break;
     }
 }
 
 tree_decl_init_list *
-tree_decl_init_list::dup (symbol_table::scope_id scope)
+tree_decl_init_list::dup (symbol_table::scope_id scope,
+			  symbol_table::context_id context)
 {
   tree_decl_init_list *new_dil = new tree_decl_init_list ();
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_decl_elt *elt = *p;
 
-      new_dil->append (elt ? elt->dup (scope) : 0);
+      new_dil->append (elt ? elt->dup (scope, context) : 0);
     }
   
   return new_dil;
 }
 
 void
 tree_decl_init_list::accept (tree_walker& tw)
 {
@@ -172,20 +174,22 @@ tree_global_command::eval (void)
     init_list->eval (do_init);
 
   if (error_state)
     ::error ("evaluating global command near line %d, column %d",
 	     line (), column ());
 }
 
 tree_command *
-tree_global_command::dup (symbol_table::scope_id scope)
+tree_global_command::dup (symbol_table::scope_id scope,
+			  symbol_table::context_id context)
 {
-  return new tree_global_command (init_list ? init_list->dup (scope) : 0,
-				  line (), column ());
+  return
+    new tree_global_command (init_list ? init_list->dup (scope, context) : 0,
+			     line (), column ());
 }
 
 // Static.
 
 void
 tree_static_command::do_init (tree_decl_elt& elt)
 {
   tree_identifier *id = elt.ident ();
@@ -223,19 +227,21 @@ tree_static_command::eval (void)
     init_list->eval (do_init);
 
   if (error_state)
     ::error ("evaluating static command near line %d, column %d",
 	     line (), column ());
 }
 
 tree_command *
-tree_static_command::dup (symbol_table::scope_id scope)
+tree_static_command::dup (symbol_table::scope_id scope,
+			  symbol_table::context_id context)
 {
-  return new tree_static_command (init_list ? init_list->dup (scope) : 0,
-				  line (), column ());
+  return
+    new tree_static_command (init_list ? init_list->dup (scope, context) : 0,
+			     line (), column ());
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-decl.h b/src/pt-decl.h
--- a/src/pt-decl.h
+++ b/src/pt-decl.h
@@ -73,17 +73,18 @@ public:
   }
 
   octave_lvalue lvalue (void) { return id ? id->lvalue () : octave_lvalue (); }
 
   tree_identifier *ident (void) { return id; }
 
   tree_expression *expression (void) { return expr; }
 
-  tree_decl_elt *dup (symbol_table::scope_id scope);
+  tree_decl_elt *dup (symbol_table::scope_id scope,
+		      symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // An identifier to tag with the declared property.
   tree_identifier *id;
 
@@ -113,17 +114,18 @@ public:
 	  iterator p = begin ();
 	  delete *p;
 	  erase (p);
 	}
     }
 
   void eval (tree_decl_elt::eval_fcn);
 
-  tree_decl_init_list *dup (symbol_table::scope_id scope);
+  tree_decl_init_list *dup (symbol_table::scope_id scope,
+			    symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_decl_init_list (const tree_decl_init_list&);
@@ -182,17 +184,18 @@ public:
 
   tree_global_command (tree_decl_init_list *t, int l = -1, int c = -1)
     : tree_decl_command ("global", t, l, c) { }
 
   ~tree_global_command (void) { }
 
   void eval (void);
 
-  tree_command *dup (symbol_table::scope_id scope);
+  tree_command *dup (symbol_table::scope_id scope,
+		     symbol_table::context_id context);
 
 private:
 
   static void do_init (tree_decl_elt& elt);
 
   // No copying!
 
   tree_global_command (const tree_global_command&);
@@ -212,17 +215,18 @@ public:
 
   tree_static_command (tree_decl_init_list *t, int l = -1, int c = -1)
     : tree_decl_command ("static", t, l, c) { }
 
   ~tree_static_command (void) { }
 
   void eval (void);
 
-  tree_command *dup (symbol_table::scope_id scope);
+  tree_command *dup (symbol_table::scope_id scope,
+		     symbol_table::context_id context);
 
 private:
 
   static void do_init (tree_decl_elt& elt);
 
   // No copying!
 
   tree_static_command (const tree_static_command&);
diff --git a/src/pt-except.cc b/src/pt-except.cc
--- a/src/pt-except.cc
+++ b/src/pt-except.cc
@@ -130,24 +130,26 @@ tree_try_catch_command::eval (void)
       unwind_protect::run ();
 
       // Also clear the frame marker.
       unwind_protect::discard ();
     }
 }
 
 tree_command *
-tree_try_catch_command::dup (symbol_table::scope_id scope)
+tree_try_catch_command::dup (symbol_table::scope_id scope,
+			     symbol_table::context_id context)
 {
-  return new tree_try_catch_command (try_code ? try_code->dup (scope) : 0,
-				     catch_code ? catch_code->dup (scope) : 0,
-				     lead_comm ? lead_comm->dup () : 0,
-				     mid_comm ? mid_comm->dup () : 0,
-				     trail_comm ? trail_comm->dup () : 0,
-				     line (), column ());
+  return new
+    tree_try_catch_command (try_code ? try_code->dup (scope, context) : 0,
+			    catch_code ? catch_code->dup (scope, context) : 0,
+			    lead_comm ? lead_comm->dup () : 0,
+			    mid_comm ? mid_comm->dup () : 0,
+			    trail_comm ? trail_comm->dup () : 0,
+			    line (), column ());
 }
 
 void
 tree_try_catch_command::accept (tree_walker& tw)
 {
   tw.visit_try_catch_command (*this);
 }
 
@@ -246,21 +248,22 @@ tree_unwind_protect_command::eval (void)
 
   if (unwind_protect_code)
     unwind_protect_code->eval ();
 
   unwind_protect::run ();
 }
 
 tree_command *
-tree_unwind_protect_command::dup (symbol_table::scope_id scope)
+tree_unwind_protect_command::dup (symbol_table::scope_id scope,
+				  symbol_table::context_id context)
 {
   return new tree_unwind_protect_command
-    (unwind_protect_code ? unwind_protect_code->dup (scope) : 0,
-     cleanup_code ? cleanup_code->dup (scope) : 0,
+    (unwind_protect_code ? unwind_protect_code->dup (scope, context) : 0,
+     cleanup_code ? cleanup_code->dup (scope, context) : 0,
      lead_comm ? lead_comm->dup () : 0,
      mid_comm ? mid_comm->dup () : 0,
      trail_comm ? trail_comm->dup () : 0,
      line (), column ());
 }
 
 void
 tree_unwind_protect_command::accept (tree_walker& tw)
diff --git a/src/pt-except.h b/src/pt-except.h
--- a/src/pt-except.h
+++ b/src/pt-except.h
@@ -60,17 +60,18 @@ public:
   tree_statement_list *cleanup (void) { return catch_code; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *middle_comment (void) { return mid_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  tree_command *dup (symbol_table::scope_id scope);
+  tree_command *dup (symbol_table::scope_id scope,
+		     symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The first block of code to attempt to execute.
   tree_statement_list *try_code;
 
@@ -122,17 +123,18 @@ public:
   tree_statement_list *cleanup (void) { return cleanup_code; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *middle_comment (void) { return mid_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  tree_command *dup (symbol_table::scope_id scope);
+  tree_command *dup (symbol_table::scope_id scope,
+		     symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The first body of code to attempt to execute.
   tree_statement_list *unwind_protect_code;
 
diff --git a/src/pt-exp.h b/src/pt-exp.h
--- a/src/pt-exp.h
+++ b/src/pt-exp.h
@@ -42,17 +42,18 @@ public:
   tree_expression (int l = -1, int c = -1)
     : tree (l, c), num_parens (0), postfix_indexed (false),
       print_flag (false) { }
 
   virtual ~tree_expression (void) { }
 
   virtual bool has_magic_end (void) const = 0;
 
-  virtual tree_expression *dup (symbol_table::scope_id) = 0;
+  virtual tree_expression *dup (symbol_table::scope_id,
+				symbol_table::context_id context) = 0;
 
   virtual bool is_constant (void) const { return false; }
 
   virtual bool is_matrix_constant (void) const { return false; }
 
   virtual bool is_identifier (void) const { return false; }
 
   virtual bool is_index_expression (void) const { return false; }
diff --git a/src/pt-fcn-handle.cc b/src/pt-fcn-handle.cc
--- a/src/pt-fcn-handle.cc
+++ b/src/pt-fcn-handle.cc
@@ -66,17 +66,18 @@ tree_fcn_handle::rvalue (int nargout)
     error ("invalid number of output arguments for function handle expression");
   else
     retval = rvalue ();
 
   return retval;
 }
 
 tree_expression *
-tree_fcn_handle::dup (symbol_table::scope_id)
+tree_fcn_handle::dup (symbol_table::scope_id,
+		      symbol_table::context_id)
 {
   tree_fcn_handle *new_fh = new tree_fcn_handle (nm, line (), column ());
 
   new_fh->copy_base (*this);
 
   return new_fh;
 }
 
@@ -94,23 +95,24 @@ tree_anon_fcn_handle::rvalue (void)
   tree_parameter_list *param_list = parameter_list ();
   tree_parameter_list *ret_list = return_list ();
   tree_statement_list *cmd_list = body ();
   symbol_table::scope_id this_scope = scope ();
 
   symbol_table::scope_id new_scope = symbol_table::dup_scope (this_scope);
 
   if (new_scope > 0)
-    symbol_table::inherit (new_scope, symbol_table::current_scope ());
+    symbol_table::inherit (new_scope, symbol_table::current_scope (),
+			   symbol_table::current_context ());
 
   octave_user_function *uf
     = new octave_user_function (new_scope,
-				param_list ? param_list->dup (new_scope) : 0,
-				ret_list ? ret_list->dup (new_scope) : 0,
-				cmd_list ? cmd_list->dup (new_scope) : 0);
+				param_list ? param_list->dup (new_scope, 0) : 0,
+				ret_list ? ret_list->dup (new_scope, 0) : 0,
+				cmd_list ? cmd_list->dup (new_scope, 0) : 0);
 
   octave_function *curr_fcn = octave_call_stack::current ();
 
   if (curr_fcn)
     uf->stash_parent_fcn_name (curr_fcn->name ());
 
   uf->mark_as_inline_function ();
 
@@ -130,33 +132,34 @@ tree_anon_fcn_handle::rvalue (int nargou
     error ("invalid number of output arguments for anonymous function handle expression");
   else
     retval = rvalue ();
 
   return retval;
 }
 
 tree_expression *
-tree_anon_fcn_handle::dup (symbol_table::scope_id parent_scope)
+tree_anon_fcn_handle::dup (symbol_table::scope_id parent_scope,
+			   symbol_table::context_id parent_context)
 {
   tree_parameter_list *param_list = parameter_list ();
   tree_parameter_list *ret_list = return_list ();
   tree_statement_list *cmd_list = body ();
   symbol_table::scope_id this_scope = scope ();
 
   symbol_table::scope_id new_scope = symbol_table::dup_scope (this_scope);
 
   if (new_scope > 0)
-    symbol_table::inherit (new_scope, parent_scope);
+    symbol_table::inherit (new_scope, parent_scope, parent_context);
 
-  tree_anon_fcn_handle *new_afh
-    = new tree_anon_fcn_handle (param_list ? param_list->dup (new_scope) : 0,
-				ret_list ? ret_list->dup (new_scope) : 0,
-				cmd_list ? cmd_list->dup (new_scope) : 0,
-				new_scope, line (), column ());
+  tree_anon_fcn_handle *new_afh = new
+    tree_anon_fcn_handle (param_list ? param_list->dup (new_scope, 0) : 0,
+			  ret_list ? ret_list->dup (new_scope, 0) : 0,
+			  cmd_list ? cmd_list->dup (new_scope, 0) : 0,
+			  new_scope, line (), column ());
 
   new_afh->copy_base (*this);
 
   return new_afh;
 }
 
 void
 tree_anon_fcn_handle::accept (tree_walker& tw)
diff --git a/src/pt-fcn-handle.h b/src/pt-fcn-handle.h
--- a/src/pt-fcn-handle.h
+++ b/src/pt-fcn-handle.h
@@ -64,17 +64,18 @@ public:
   std::string name (void) const { return nm; }
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
-  tree_expression *dup (symbol_table::scope_id scope);
+  tree_expression *dup (symbol_table::scope_id scope,
+			symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The name of this function handle.
   std::string nm;
 
@@ -118,17 +119,18 @@ public:
   {
     return fcn ? fcn->return_list () : 0;
   }
 
   tree_statement_list *body (void) { return fcn ? fcn->body () : 0; }
 
   symbol_table::scope_id scope (void) { return fcn ? fcn->scope () : -1; }
 
-  tree_expression *dup (symbol_table::scope_id scope);
+  tree_expression *dup (symbol_table::scope_id scope,
+			symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The function.
   octave_user_function *fcn;
 
diff --git a/src/pt-id.cc b/src/pt-id.cc
--- a/src/pt-id.cc
+++ b/src/pt-id.cc
@@ -118,17 +118,18 @@ octave_lvalue
 tree_identifier::lvalue (void)
 {
   MAYBE_DO_BREAKPOINT;
 
   return octave_lvalue (&(xsym().varref ()));
 }
 
 tree_identifier *
-tree_identifier::dup (symbol_table::scope_id sc)
+tree_identifier::dup (symbol_table::scope_id sc,
+		      symbol_table::context_id context)
 {
   // The new tree_identifier object contains a symbol_record
   // entry from the duplicated scope.
 
   // FIXME -- is this the best way?
   symbol_table::symbol_record new_sym
     = symbol_table::find_symbol (xsym().name (), sc);
 
diff --git a/src/pt-id.h b/src/pt-id.h
--- a/src/pt-id.h
+++ b/src/pt-id.h
@@ -106,17 +106,18 @@ public:
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   octave_lvalue lvalue (void);
 
   void eval_undefined_error (void);
 
-  tree_identifier *dup (symbol_table::scope_id scope);
+  tree_identifier *dup (symbol_table::scope_id scope,
+			symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The symbol record that this identifier references.
   symbol_table::symbol_record sym;
 
diff --git a/src/pt-idx.cc b/src/pt-idx.cc
--- a/src/pt-idx.cc
+++ b/src/pt-idx.cc
@@ -684,49 +684,50 @@ tree_index_expression::eval_error (void)
 
   if (l != -1 && c != -1)
     ::error ("evaluating %s near line %d, column %d", type_str, l, c);
   else
     ::error ("evaluating %s", type_str);
 }
 
 tree_index_expression *
-tree_index_expression::dup (symbol_table::scope_id scope)
+tree_index_expression::dup (symbol_table::scope_id scope,
+			    symbol_table::context_id context)
 {
   tree_index_expression *new_idx_expr
     = new tree_index_expression (line (), column ());
 
-  new_idx_expr->expr = expr ? expr->dup (scope) : 0;
+  new_idx_expr->expr = expr ? expr->dup (scope, context) : 0;
 
   std::list<tree_argument_list *> new_args;
 
   for (std::list<tree_argument_list *>::iterator p = args.begin ();
        p != args.end ();
        p++)
     {
       tree_argument_list *elt = *p;
 
-      new_args.push_back (elt ? elt->dup (scope) : 0);
+      new_args.push_back (elt ? elt->dup (scope, context) : 0);
     }
 
   new_idx_expr->args = new_args;
   
   new_idx_expr->type = type;
 
   new_idx_expr->arg_nm = arg_nm;
 
   std::list<tree_expression *> new_dyn_field;
 
   for (std::list<tree_expression *>::iterator p = dyn_field.begin ();
        p != dyn_field.end ();
        p++)
     {
       tree_expression *elt = *p;
 
-      new_dyn_field.push_back (elt ? elt->dup (scope) : 0);
+      new_dyn_field.push_back (elt ? elt->dup (scope, context) : 0);
     }
 
   new_idx_expr->dyn_field = new_dyn_field;
 
   new_idx_expr->copy_base (*this);
   
   return new_idx_expr;
 }
diff --git a/src/pt-idx.h b/src/pt-idx.h
--- a/src/pt-idx.h
+++ b/src/pt-idx.h
@@ -85,17 +85,18 @@ public:
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   octave_lvalue lvalue (void);
 
   void eval_error (void) const;
 
-  tree_index_expression *dup (symbol_table::scope_id scope);
+  tree_index_expression *dup (symbol_table::scope_id scope,
+			      symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The LHS of this index expression.
   tree_expression *expr;
 
diff --git a/src/pt-jump.cc b/src/pt-jump.cc
--- a/src/pt-jump.cc
+++ b/src/pt-jump.cc
@@ -44,17 +44,18 @@ tree_break_command::eval (void)
   // Even if we have an error we should still enter debug mode.
   MAYBE_DO_BREAKPOINT;
 
   if (! error_state)
     breaking = 1;
 }
 
 tree_command *
-tree_break_command::dup (symbol_table::scope_id)
+tree_break_command::dup (symbol_table::scope_id,
+			 symbol_table::context_id context)
 {
   return new tree_break_command (line (), column ());
 }
 
 void
 tree_break_command::accept (tree_walker& tw)
 {
   tw.visit_break_command (*this);
@@ -70,17 +71,18 @@ tree_continue_command::eval (void)
 {
   MAYBE_DO_BREAKPOINT;
 
   if (! error_state)
     continuing = 1;
 }
 
 tree_command *
-tree_continue_command::dup (symbol_table::scope_id)
+tree_continue_command::dup (symbol_table::scope_id,
+			    symbol_table::context_id context)
 {
   return new tree_continue_command (line (), column ());
 }
 
 void
 tree_continue_command::accept (tree_walker& tw)
 {
   tw.visit_continue_command (*this);
@@ -96,17 +98,18 @@ tree_return_command::eval (void)
 {
   MAYBE_DO_BREAKPOINT;
 
   if (! error_state)
     returning = 1;
 }
 
 tree_command *
-tree_return_command::dup (symbol_table::scope_id)
+tree_return_command::dup (symbol_table::scope_id,
+			  symbol_table::context_id context)
 {
   return new tree_return_command (line (), column ());
 }
 
 void
 tree_return_command::accept (tree_walker& tw)
 {
   tw.visit_return_command (*this);
diff --git a/src/pt-jump.h b/src/pt-jump.h
--- a/src/pt-jump.h
+++ b/src/pt-jump.h
@@ -37,17 +37,18 @@ public:
 
   tree_break_command (int l = -1, int c = -1)
     : tree_command (l, c) { }
 
   ~tree_break_command (void) { }
 
   void eval (void);
 
-  tree_command *dup (symbol_table::scope_id scope);
+  tree_command *dup (symbol_table::scope_id scope,
+		     symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
   static int breaking;
 
 private:
 
   // No copying!
@@ -66,17 +67,18 @@ public:
 
   tree_continue_command (int l = -1, int c = -1)
     : tree_command (l, c) { }
 
   ~tree_continue_command (void) { }
 
   void eval (void);
 
-  tree_command *dup (symbol_table::scope_id scope);
+  tree_command *dup (symbol_table::scope_id scope,
+		     symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
   static int continuing;
 
 private:
 
   // No copying!
@@ -95,17 +97,18 @@ public:
 
   tree_return_command (int l = -1, int c = -1)
     : tree_command (l, c) { }
 
   ~tree_return_command (void) { }
 
   void eval (void);
 
-  tree_command *dup (symbol_table::scope_id scope);
+  tree_command *dup (symbol_table::scope_id scope,
+		     symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
   static int returning;
 
 private:
 
   // No copying!
diff --git a/src/pt-loop.cc b/src/pt-loop.cc
--- a/src/pt-loop.cc
+++ b/src/pt-loop.cc
@@ -121,20 +121,21 @@ tree_while_command::eval (void)
 void
 tree_while_command::eval_error (void)
 {
   ::error ("evaluating while command near line %d, column %d",
 	   line (), column ());
 }
 
 tree_command *
-tree_while_command::dup (symbol_table::scope_id scope)
+tree_while_command::dup (symbol_table::scope_id scope,
+			 symbol_table::context_id context)
 {
-  return new tree_while_command (expr ? expr->dup (scope) : 0,
-				 list ? list->dup (scope) : 0,
+  return new tree_while_command (expr ? expr->dup (scope, context) : 0,
+				 list ? list->dup (scope, context) : 0,
 				 lead_comm ? lead_comm->dup () : 0,
 				 trail_comm ? trail_comm->dup (): 0,
 				 line (), column ());
 }
 
 void
 tree_while_command::accept (tree_walker& tw)
 {
@@ -184,20 +185,21 @@ tree_do_until_command::eval (void)
 void
 tree_do_until_command::eval_error (void)
 {
   ::error ("evaluating do-until command near line %d, column %d",
 	   line (), column ());
 }
 
 tree_command *
-tree_do_until_command::dup (symbol_table::scope_id scope)
+tree_do_until_command::dup (symbol_table::scope_id scope,
+			    symbol_table::context_id context)
 {
-  return new tree_do_until_command (expr ? expr->dup (scope) : 0,
-				    list ? list->dup (scope) : 0,
+  return new tree_do_until_command (expr ? expr->dup (scope, context) : 0,
+				    list ? list->dup (scope, context) : 0,
 				    lead_comm ? lead_comm->dup () : 0,
 				    trail_comm ? trail_comm->dup (): 0,
 				    line (), column ());
 }
 
 void
 tree_do_until_command::accept (tree_walker& tw)
 {
@@ -490,21 +492,22 @@ tree_simple_for_command::eval (void)
 void
 tree_simple_for_command::eval_error (void)
 {
   ::error ("evaluating for command near line %d, column %d",
 	   line (), column ());
 }
 
 tree_command *
-tree_simple_for_command::dup (symbol_table::scope_id scope)
+tree_simple_for_command::dup (symbol_table::scope_id scope,
+			      symbol_table::context_id context)
 {
-  return new tree_simple_for_command (lhs ? lhs->dup (scope) : 0,
-				      expr ? expr->dup (scope) : 0,
-				      list ? list->dup (scope) : 0,
+  return new tree_simple_for_command (lhs ? lhs->dup (scope, context) : 0,
+				      expr ? expr->dup (scope, context) : 0,
+				      list ? list->dup (scope, context) : 0,
 				      lead_comm ? lead_comm->dup () : 0,
 				      trail_comm ? trail_comm->dup () : 0,
 				      line (), column ());
 }
 
 void
 tree_simple_for_command::accept (tree_walker& tw)
 {
@@ -611,24 +614,25 @@ tree_complex_for_command::eval (void)
 void
 tree_complex_for_command::eval_error (void)
 {
   ::error ("evaluating for command near line %d, column %d",
 	   line (), column ());
 }
 
 tree_command *
-tree_complex_for_command::dup (symbol_table::scope_id scope)
+tree_complex_for_command::dup (symbol_table::scope_id scope,
+			       symbol_table::context_id context)
 {
-  return new tree_complex_for_command (lhs ? lhs->dup (scope) : 0,
-				      expr ? expr->dup (scope) : 0,
-				      list ? list->dup (scope) : 0,
-				      lead_comm ? lead_comm->dup () : 0,
-				      trail_comm ? trail_comm->dup () : 0,
-				      line (), column ());
+  return new tree_complex_for_command (lhs ? lhs->dup (scope, context) : 0,
+				       expr ? expr->dup (scope, context) : 0,
+				       list ? list->dup (scope, context) : 0,
+				       lead_comm ? lead_comm->dup () : 0,
+				       trail_comm ? trail_comm->dup () : 0,
+				       line (), column ());
 }
 
 void
 tree_complex_for_command::accept (tree_walker& tw)
 {
   tw.visit_complex_for_command (*this);
 }
 
diff --git a/src/pt-loop.h b/src/pt-loop.h
--- a/src/pt-loop.h
+++ b/src/pt-loop.h
@@ -74,17 +74,18 @@ public:
   tree_expression *condition (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  tree_command *dup (symbol_table::scope_id scope);
+  tree_command *dup (symbol_table::scope_id scope,
+		     symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 protected:
 
   // Expression to test.
   tree_expression *expr;
 
@@ -129,17 +130,18 @@ public:
     : tree_while_command (e, lst, lc, tc, l, c) { }
 
   ~tree_do_until_command (void) { }
 
   void eval (void);
 
   void eval_error (void);
 
-  tree_command *dup (symbol_table::scope_id scope);
+  tree_command *dup (symbol_table::scope_id scope,
+		     symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_do_until_command (const tree_do_until_command&);
@@ -177,17 +179,18 @@ public:
   tree_expression *control_expr (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  tree_command *dup (symbol_table::scope_id scope);
+  tree_command *dup (symbol_table::scope_id scope,
+		     symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // Expression to modify.
   tree_expression *lhs;
 
@@ -241,17 +244,18 @@ public:
   tree_expression *control_expr (void) { return expr; }
 
   tree_statement_list *body (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  tree_command *dup (symbol_table::scope_id scope);
+  tree_command *dup (symbol_table::scope_id scope,
+		     symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // Expression to modify.
   tree_argument_list *lhs;
 
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -946,25 +946,26 @@ tree_matrix::rvalue (void)
 	}
     }
 
 done:
   return retval;
 }
 
 tree_expression *
-tree_matrix::dup (symbol_table::scope_id scope)
+tree_matrix::dup (symbol_table::scope_id scope,
+		  symbol_table::context_id context)
 {
   tree_matrix *new_matrix = new tree_matrix (0, line (), column ());
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_argument_list *elt = *p;
 
-      new_matrix->append (elt ? elt->dup (scope) : 0);
+      new_matrix->append (elt ? elt->dup (scope, context) : 0);
     }
 
   new_matrix->copy_base (*this);
 
   return new_matrix;
 }
 
 void
diff --git a/src/pt-mat.h b/src/pt-mat.h
--- a/src/pt-mat.h
+++ b/src/pt-mat.h
@@ -59,17 +59,18 @@ public:
   bool all_elements_are_constant (void) const;
 
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
-  tree_expression *dup (symbol_table::scope_id scope);
+  tree_expression *dup (symbol_table::scope_id scope,
+			symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_matrix (const tree_matrix&);
diff --git a/src/pt-misc.cc b/src/pt-misc.cc
--- a/src/pt-misc.cc
+++ b/src/pt-misc.cc
@@ -242,28 +242,29 @@ tree_parameter_list::is_defined (void)
 	  break;
 	}
     }
 
   return status;
 }
 
 tree_parameter_list *
-tree_parameter_list::dup (symbol_table::scope_id scope)
+tree_parameter_list::dup (symbol_table::scope_id scope,
+			  symbol_table::context_id context)
 {
   tree_parameter_list *new_list = new tree_parameter_list ();
 
   if (takes_varargs ())
     new_list->mark_varargs ();
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_decl_elt *elt = *p;
 
-      new_list->append (elt->dup (scope));
+      new_list->append (elt->dup (scope, context));
     }
 
   return new_list;
 }
 
 void
 tree_parameter_list::accept (tree_walker& tw)
 {
@@ -278,25 +279,26 @@ tree_return_list::~tree_return_list (voi
     {
       iterator p = begin ();
       delete *p;
       erase (p);
     }
 }
 
 tree_return_list *
-tree_return_list::dup (symbol_table::scope_id scope)
+tree_return_list::dup (symbol_table::scope_id scope,
+		       symbol_table::context_id context)
 {
   tree_return_list *new_list = new tree_return_list ();
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_index_expression *elt = *p;
 
-      new_list->append (elt->dup (scope));
+      new_list->append (elt->dup (scope, context));
     }
 
   return new_list;
 }
 
 void
 tree_return_list::accept (tree_walker& tw)
 {
diff --git a/src/pt-misc.h b/src/pt-misc.h
--- a/src/pt-misc.h
+++ b/src/pt-misc.h
@@ -76,17 +76,18 @@ public:
   void define_from_arg_vector (const octave_value_list& args);
 
   void undefine (void);
 
   bool is_defined (void);
 
   octave_value_list convert_to_const_vector (const Cell& varargout);
 
-  tree_parameter_list *dup (symbol_table::scope_id scope);
+  tree_parameter_list *dup (symbol_table::scope_id scope,
+			    symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   int marked_for_varargs;
 
   void mark_varargs (void) { marked_for_varargs = 1; }
@@ -109,17 +110,18 @@ tree_return_list : public octave_base_li
 public:
 
   tree_return_list (void) { }
 
   tree_return_list (tree_index_expression *t) { append (t); }
 
   ~tree_return_list (void);
 
-  tree_return_list *dup (symbol_table::scope_id scope);
+  tree_return_list *dup (symbol_table::scope_id scope,
+			 symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_return_list (const tree_return_list&);
diff --git a/src/pt-select.cc b/src/pt-select.cc
--- a/src/pt-select.cc
+++ b/src/pt-select.cc
@@ -55,20 +55,21 @@ tree_if_clause::eval (void)
 
       return 1;
     }
 
   return 0;
 }
 
 tree_if_clause *
-tree_if_clause::dup (symbol_table::scope_id scope)
+tree_if_clause::dup (symbol_table::scope_id scope,
+		     symbol_table::context_id context)
 {
-  return new tree_if_clause (expr ? expr->dup (scope) : 0,
-			     list ? list->dup (scope) : 0,
+  return new tree_if_clause (expr ? expr->dup (scope, context) : 0,
+			     list ? list->dup (scope, context) : 0,
 			     lead_comm ? lead_comm->dup () : 0);
 }
 
 void
 tree_if_clause::accept (tree_walker& tw)
 {
   tw.visit_if_clause (*this);
 }
@@ -83,25 +84,26 @@ tree_if_command_list::eval (void)
       tree_if_clause *t = *p;
 
       if (t->eval () || error_state)
 	break;
     }
 }
 
 tree_if_command_list *
-tree_if_command_list::dup (symbol_table::scope_id scope)
+tree_if_command_list::dup (symbol_table::scope_id scope,
+			   symbol_table::context_id context)
 {
   tree_if_command_list *new_icl = new tree_if_command_list ();
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_if_clause *elt = *p;
 
-      new_icl->append (elt ? elt->dup (scope) : 0);
+      new_icl->append (elt ? elt->dup (scope, context) : 0);
     }
 
   return new_icl;
 }
 
 void
 tree_if_command_list::accept (tree_walker& tw)
 {
@@ -124,19 +126,20 @@ tree_if_command::eval (void)
     list->eval ();
 
   if (error_state)
     ::error ("evaluating if command near line %d, column %d",
 	     line (), column ());
 }
 
 tree_command *
-tree_if_command::dup (symbol_table::scope_id scope)
+tree_if_command::dup (symbol_table::scope_id scope,
+		      symbol_table::context_id context)
 {
-  return new tree_if_command (list ? list->dup (scope) : 0,
+  return new tree_if_command (list ? list->dup (scope, context) : 0,
 			      lead_comm ? lead_comm->dup () : 0,
 			      trail_comm ? trail_comm->dup () : 0,
 			      line (), column ());
 }
 
 void
 tree_if_command::accept (tree_walker& tw)
 {
@@ -238,20 +241,21 @@ tree_switch_case::eval (const octave_val
 
 void
 tree_switch_case::eval_error (void)
 {
   ::error ("evaluating switch case label");
 }
 
 tree_switch_case *
-tree_switch_case::dup (symbol_table::scope_id scope)
+tree_switch_case::dup (symbol_table::scope_id scope,
+		       symbol_table::context_id context)
 {
-  return new tree_switch_case (label ? label->dup (scope) : 0,
-			       list ? list->dup (scope) : 0,
+  return new tree_switch_case (label ? label->dup (scope, context) : 0,
+			       list ? list->dup (scope, context) : 0,
 			       lead_comm ? lead_comm->dup () : 0);
 }
 
 void
 tree_switch_case::accept (tree_walker& tw)
 {
   tw.visit_switch_case (*this);
 }
@@ -266,25 +270,26 @@ tree_switch_case_list::eval (const octav
       tree_switch_case *t = *p;
 
       if (t->eval (val) || error_state)
 	break;
     }
 }
 
 tree_switch_case_list *
-tree_switch_case_list::dup (symbol_table::scope_id scope)
+tree_switch_case_list::dup (symbol_table::scope_id scope,
+			    symbol_table::context_id context)
 {
   tree_switch_case_list *new_scl = new tree_switch_case_list ();
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_switch_case *elt = *p;
 
-      new_scl->append (elt ? elt->dup (scope) : 0);
+      new_scl->append (elt ? elt->dup (scope, context) : 0);
     }
   
   return new_scl;
 }
 
 void
 tree_switch_case_list::accept (tree_walker& tw)
 {
@@ -327,20 +332,21 @@ tree_switch_command::eval (void)
 void
 tree_switch_command::eval_error (void)
 {
   ::error ("evaluating switch command near line %d, column %d",
 	   line (), column ());
 }
 
 tree_command *
-tree_switch_command::dup (symbol_table::scope_id scope)
+tree_switch_command::dup (symbol_table::scope_id scope,
+			  symbol_table::context_id context)
 {
-  return new tree_switch_command (expr ? expr->dup (scope) : 0,
-				  list ? list->dup (scope) : 0,
+  return new tree_switch_command (expr ? expr->dup (scope, context) : 0,
+				  list ? list->dup (scope, context) : 0,
 				  lead_comm ? lead_comm->dup () : 0,
 				  trail_comm ? trail_comm->dup () : 0,
 				  line (), column ());
 }
 
 void
 tree_switch_command::accept (tree_walker& tw)
 {
diff --git a/src/pt-select.h b/src/pt-select.h
--- a/src/pt-select.h
+++ b/src/pt-select.h
@@ -59,17 +59,18 @@ public:
   int eval (void);
 
   tree_expression *condition (void) { return expr; }
 
   tree_statement_list *commands (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
-  tree_if_clause *dup (symbol_table::scope_id scope);
+  tree_if_clause *dup (symbol_table::scope_id scope,
+		       symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The condition to test.
   tree_expression *expr;
 
@@ -102,17 +103,18 @@ public:
 	  iterator p = begin ();
 	  delete *p;
 	  erase (p);
 	}
     }
 
   void eval (void);
 
-  tree_if_command_list *dup (symbol_table::scope_id scope);
+  tree_if_command_list *dup (symbol_table::scope_id scope,
+			     symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_if_command_list (const tree_if_command_list&);
@@ -137,17 +139,18 @@ public:
   void eval (void);
 
   tree_if_command_list *cmd_list (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  tree_command *dup (symbol_table::scope_id scope);
+  tree_command *dup (symbol_table::scope_id scope,
+		     symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // List of if commands (if, elseif, elseif, ... else, endif)
   tree_if_command_list *list;
 
@@ -192,17 +195,18 @@ public:
   void eval_error (void);
 
   tree_expression *case_label (void) { return label; }
 
   tree_statement_list *commands (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
-  tree_switch_case *dup (symbol_table::scope_id scope);
+  tree_switch_case *dup (symbol_table::scope_id scope,
+			 symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // The case label.
   tree_expression *label;
 
@@ -235,17 +239,18 @@ public:
 	  iterator p = begin ();
 	  delete *p;
 	  erase (p);
 	}
     }
 
   void eval (const octave_value& val);
 
-  tree_switch_case_list *dup (symbol_table::scope_id scope);
+  tree_switch_case_list *dup (symbol_table::scope_id scope,
+			      symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_switch_case_list (const tree_switch_case_list&);
@@ -277,17 +282,18 @@ public:
   tree_expression *switch_value (void) { return expr; }
 
   tree_switch_case_list *case_list (void) { return list; }
 
   octave_comment_list *leading_comment (void) { return lead_comm; }
 
   octave_comment_list *trailing_comment (void) { return trail_comm; }
 
-  tree_command *dup (symbol_table::scope_id scope);
+  tree_command *dup (symbol_table::scope_id scope,
+		     symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // Value on which to switch.
   tree_expression *expr;
 
diff --git a/src/pt-stmt.cc b/src/pt-stmt.cc
--- a/src/pt-stmt.cc
+++ b/src/pt-stmt.cc
@@ -133,23 +133,24 @@ tree_statement::eval (bool silent, int n
 	  error ("caught execution error in library function");
 	}
     }
 
   return retval;
 }
 
 tree_statement *
-tree_statement::dup (symbol_table::scope_id scope)
+tree_statement::dup (symbol_table::scope_id scope,
+		     symbol_table::context_id context)
 {
   tree_statement *new_stmt = new tree_statement ();
 
-  new_stmt->cmd = cmd ? cmd->dup (scope) : 0;
+  new_stmt->cmd = cmd ? cmd->dup (scope, context) : 0;
 
-  new_stmt->expr = expr ? expr->dup (scope) : 0;
+  new_stmt->expr = expr ? expr->dup (scope, context) : 0;
 
   new_stmt->comm = comm ? comm->dup () : 0;
 
   new_stmt->print_flag = print_flag;
 
   return new_stmt;
 }
 
@@ -258,27 +259,28 @@ tree_statement_list::list_breakpoints (v
 {
   tree_breakpoint tbp (0, tree_breakpoint::list);
   accept (tbp);
 
   return tbp.get_list ();
 }
 
 tree_statement_list *
-tree_statement_list::dup (symbol_table::scope_id scope)
+tree_statement_list::dup (symbol_table::scope_id scope,
+			  symbol_table::context_id context)
 {
   tree_statement_list *new_list = new tree_statement_list ();
 
   new_list->function_body = function_body;
 
   for (iterator p = begin (); p != end (); p++)
     {
       tree_statement *elt = *p;
 
-      new_list->append (elt ? elt->dup (scope) : 0);
+      new_list->append (elt ? elt->dup (scope, context) : 0);
     }
 
   return new_list;
 }
 
 void
 tree_statement_list::accept (tree_walker& tw)
 {
diff --git a/src/pt-stmt.h b/src/pt-stmt.h
--- a/src/pt-stmt.h
+++ b/src/pt-stmt.h
@@ -81,17 +81,18 @@ public:
   // Allow modification of this statement.  Note that there is no
   // checking.  If you use these, are you sure you knwo what you are
   // doing?
 
   void set_command (tree_command *c) { cmd = c; }
 
   void set_expression (tree_expression *e) { expr = e; }
 
-  tree_statement *dup (symbol_table::scope_id scope);
+  tree_statement *dup (symbol_table::scope_id scope,
+		       symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // Only one of cmd or expr can be valid at once.
 
   // Command to execute.
@@ -142,17 +143,18 @@ public:
   octave_value_list eval (bool silent = false, int nargout = 0);
 
   int set_breakpoint (int line);
 
   void delete_breakpoint (int line);
 
   octave_value_list list_breakpoints (void);
 
-  tree_statement_list *dup (symbol_table::scope_id scope);
+  tree_statement_list *dup (symbol_table::scope_id scope,
+			    symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // Does this list of statements make up the body of a function?
   bool function_body;
 
diff --git a/src/pt-unop.cc b/src/pt-unop.cc
--- a/src/pt-unop.cc
+++ b/src/pt-unop.cc
@@ -116,20 +116,21 @@ tree_prefix_expression::rvalue (void)
 void
 tree_prefix_expression::eval_error (void)
 {
   ::error ("evaluating prefix operator `%s' near line %d, column %d",
 	   oper () . c_str (), line (), column ());
 }
 
 tree_expression *
-tree_prefix_expression::dup (symbol_table::scope_id scope)
+tree_prefix_expression::dup (symbol_table::scope_id scope,
+			     symbol_table::context_id context)
 {
   tree_prefix_expression *new_pe
-    = new tree_prefix_expression (op ? op->dup (scope) : 0,
+    = new tree_prefix_expression (op ? op->dup (scope, context) : 0,
 				  line (), column (), etype);
 
   new_pe->copy_base (*this);
 
   return new_pe;
 }
 
 void
@@ -213,20 +214,21 @@ tree_postfix_expression::rvalue (void)
 void
 tree_postfix_expression::eval_error (void)
 {
   ::error ("evaluating postfix operator `%s' near line %d, column %d",
 	   oper () . c_str (), line (), column ());
 }
 
 tree_expression *
-tree_postfix_expression::dup (symbol_table::scope_id scope)
+tree_postfix_expression::dup (symbol_table::scope_id scope,
+			      symbol_table::context_id context)
 {
   tree_postfix_expression *new_pe
-    = new tree_postfix_expression (op ? op->dup (scope) : 0,
+    = new tree_postfix_expression (op ? op->dup (scope, context) : 0,
 				   line (), column (), etype);
 
   new_pe->copy_base (*this);
 
   return new_pe;
 }
 
 void
diff --git a/src/pt-unop.h b/src/pt-unop.h
--- a/src/pt-unop.h
+++ b/src/pt-unop.h
@@ -99,17 +99,18 @@ public:
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   void eval_error (void);
 
-  tree_expression *dup (symbol_table::scope_id scope);
+  tree_expression *dup (symbol_table::scope_id scope,
+			symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_prefix_expression (const tree_prefix_expression&);
@@ -137,17 +138,18 @@ public:
   bool rvalue_ok (void) const { return true; }
 
   octave_value rvalue (void);
 
   octave_value_list rvalue (int nargout);
 
   void eval_error (void);
 
-  tree_expression *dup (symbol_table::scope_id scope);
+  tree_expression *dup (symbol_table::scope_id scope,
+			symbol_table::context_id context);
 
   void accept (tree_walker& tw);
 
 private:
 
   // No copying!
 
   tree_postfix_expression (const tree_postfix_expression&);
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -68,17 +68,17 @@ symbol_table::context_id symbol_table::x
 // Should Octave always check to see if function files have changed
 // since they were last compiled?
 static int Vignore_function_time_stamp = 1;
 
 void
 symbol_table::symbol_record::symbol_record_rep::dump
   (std::ostream& os, const std::string& prefix) const
 {
-  octave_value val = varval ();
+  octave_value val = varval (xcurrent_context);
 
   os << prefix << name;
 
   if (val.is_defined ())
     {
       os << " ["
 	 << (is_local () ? "l" : "")
 	 << (is_automatic () ? "a" : "")
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -190,42 +190,42 @@ public:
 
       symbol_record_rep (const std::string& nm, const octave_value& v,
 			 unsigned int sc)
 	: name (nm), value_stack (), storage_class (sc), count (1)
       {
 	value_stack.push_back (v);
       }
 
-      octave_value& varref (void)
+      octave_value& varref (context_id context)
       {
 	if (is_global ())
 	  return symbol_table::global_varref (name);
 	else if (is_persistent ())
 	  return symbol_table::persistent_varref (name);
 	else
 	  {
 	    context_id n = value_stack.size ();
-	    while (n++ <= symbol_table::xcurrent_context)
+	    while (n++ <= context)
 	      value_stack.push_back (octave_value ());
 
-	    return value_stack[symbol_table::xcurrent_context];
+	    return value_stack[context];
 	  }
       }
 
-      octave_value varval (void) const
+      octave_value varval (context_id context) const
       {
 	if (is_global ())
 	  return symbol_table::global_varval (name);
 	else if (is_persistent ())
 	  return symbol_table::persistent_varval (name);
 	else
 	  {
-	    if (symbol_table::xcurrent_context < value_stack.size ())
-	      return value_stack[symbol_table::xcurrent_context];
+	    if (context < value_stack.size ())
+	      return value_stack[context];
 	    else
 	      return octave_value ();
 	  }
       }
 
       void push_context (void)
       {
 	if (! (is_persistent () || is_global ()))
@@ -263,29 +263,34 @@ public:
       {
 	if (! (is_hidden () || is_inherited ()))
 	  {
 	    if (is_global ())
 	      unmark_global ();
 
 	    if (is_persistent ())
 	      {
-		symbol_table::persistent_varref (name) = varval ();
+		symbol_table::persistent_varref (name)
+		  = varval (xcurrent_context);
+
 		unmark_persistent ();
 	      }
 
-	    varref () = octave_value ();
+	    varref (xcurrent_context) = octave_value ();
 	  }
       }
 
-      bool is_defined (void) const { return varval ().is_defined (); }
-
-      bool is_variable (void) const
+      bool is_defined (context_id context) const
       {
-	return (storage_class != local || is_defined ());
+	return varval (context).is_defined ();
+      }
+
+      bool is_variable (context_id context) const
+      {
+	return (storage_class != local || is_defined (context));
       }
 
       bool is_local (void) const { return storage_class & local; }
       bool is_automatic (void) const { return storage_class & automatic; }
       bool is_formal (void) const { return storage_class & formal; }
       bool is_hidden (void) const { return storage_class & hidden; }
       bool is_inherited (void) const { return storage_class & inherited; }
       bool is_global (void) const { return storage_class & global; }
@@ -316,36 +321,37 @@ public:
       void unmark_formal (void) { storage_class &= ~formal; }
       void unmark_hidden (void) { storage_class &= ~hidden; }
       void unmark_inherited (void) { storage_class &= ~inherited; }
       void unmark_global (void) { storage_class &= ~global; }
       void unmark_persistent (void) { storage_class &= ~persistent; }
 
       void init_persistent (void)
       {
-	if (! is_defined ())
+	if (! is_defined (xcurrent_context))
 	  {
 	    mark_persistent ();
 
-	    varref () = symbol_table::persistent_varval (name);
+	    varref (xcurrent_context) = symbol_table::persistent_varval (name);
 	  }
 	// FIXME -- this causes trouble with recursive calls.
 	// else
 	//   error ("unable to declare existing variable persistent");
       }
 
       void erase_persistent (void)
       {
 	unmark_persistent ();
 	symbol_table::erase_persistent (name);
       }
 
       symbol_record_rep *dup (void)
       {
-	return new symbol_record_rep (name, varval (), storage_class);
+	return new symbol_record_rep (name, varval (xcurrent_context),
+				      storage_class);
       }
 
       void dump (std::ostream& os, const std::string& prefix) const;
 
       std::string name;
 
       std::deque<octave_value> value_stack;
 
@@ -395,28 +401,41 @@ public:
     symbol_record dup (void) const { return symbol_record (rep->dup ()); }
 
     std::string name (void) const { return rep->name; }
 
     octave_value
     find (tree_argument_list *args, const string_vector& arg_names,
 	  octave_value_list& evaluated_args, bool& args_evaluated) const;
 
-    octave_value& varref (void) { return rep->varref (); }
-
-    octave_value varval (void) const { return rep->varval (); }
+    octave_value& varref (context_id context = xcurrent_context)
+    {
+      return rep->varref (context);
+    }
+
+    octave_value varval (context_id context = xcurrent_context) const
+    {
+      return rep->varval (context);
+    }
 
     void push_context (void) { rep->push_context (); }
 
     size_t pop_context (void) { return rep->pop_context (); }
 
     void clear (void) { rep->clear (); }
 
-    bool is_defined (void) const { return rep->is_defined (); }
-    bool is_variable (void) const { return rep->is_variable (); }
+    bool is_defined (context_id context = xcurrent_context) const
+    {
+      return rep->is_defined (context);
+    }
+
+    bool is_variable (context_id context = xcurrent_context) const
+    {
+      return rep->is_variable (context);
+    }
 
     bool is_local (void) const { return rep->is_local (); }
     bool is_automatic (void) const { return rep->is_automatic (); }
     bool is_formal (void) const { return rep->is_formal (); }
     bool is_global (void) const { return rep->is_global (); }
     bool is_hidden (void) const { return rep->is_hidden (); }
     bool is_inherited (void) const { return rep->is_inherited (); }
     bool is_persistent (void) const { return rep->is_persistent (); }
@@ -972,22 +991,23 @@ public:
   static symbol_record
   find_symbol (const std::string& name, scope_id scope = xcurrent_scope)
   {
     symbol_table *inst = get_instance (scope);
 
     return inst ? inst->do_find_symbol (name) : symbol_record ();
   }
 
-  static void inherit (scope_id scope, scope_id donor_scope)
+  static void
+  inherit (scope_id scope, scope_id donor_scope, context_id donor_context)
   {
     symbol_table *inst = get_instance (scope);
 
     if (inst)
-      inst->do_inherit (donor_scope);
+      inst->do_inherit (donor_scope, donor_context);
   }
 
   static bool at_top_level (void) { return xcurrent_scope == xtop_scope; }
 
   // Find a value corresponding to the given name in the table.
   static octave_value
   find (const std::string& name, tree_argument_list *args,
 	const string_vector& arg_names,
@@ -1000,31 +1020,33 @@ public:
     static symbol_record foobar;
 
     symbol_table *inst = get_instance (xcurrent_scope);
 
     return inst ? inst->do_insert (name) : foobar;
   }
 
   static octave_value& varref (const std::string& name,
-			       scope_id scope = xcurrent_scope)
+			       scope_id scope = xcurrent_scope,
+			       context_id context = xcurrent_context)
   {
     static octave_value foobar;
 
     symbol_table *inst = get_instance (scope);
 
-    return inst ? inst->do_varref (name) : foobar;
+    return inst ? inst->do_varref (name, context) : foobar;
   }
 
   static octave_value varval (const std::string& name,
-			      scope_id scope = xcurrent_scope)
+			      scope_id scope = xcurrent_scope,
+			      context_id context = xcurrent_context)
   {
     symbol_table *inst = get_instance (scope);
 
-    return inst ? inst->do_varval (name) : octave_value ();
+    return inst ? inst->do_varval (name, context) : octave_value ();
   }
 
   static octave_value&
   global_varref (const std::string& name)
   {
     global_table_iterator p = global_table.find (name);
 
     return (p == global_table.end ()) ? global_table[name] : p->second;
@@ -1483,22 +1505,24 @@ public:
   {
     symbol_table *inst = get_instance (xcurrent_scope);
 
     if (inst)
       inst->do_mark_global (name);
   }
 
   static std::list<symbol_record>
-  all_variables (scope_id scope = xcurrent_scope, bool defined_only = true)
+  all_variables (scope_id scope = xcurrent_scope,
+		 context_id context = xcurrent_context,
+		 bool defined_only = true)
   {
     symbol_table *inst = get_instance (scope);
 
     return inst
-      ? inst->do_all_variables (defined_only) : std::list<symbol_record> ();
+      ? inst->do_all_variables (context, defined_only) : std::list<symbol_record> ();
   }
 
   static std::list<symbol_record> glob (const std::string& pattern)
   {
     symbol_table *inst = get_instance (xcurrent_scope);
 
     return inst ? inst->do_glob (pattern) : std::list<symbol_record> ();
   }
@@ -1806,31 +1830,37 @@ private:
     table_iterator p = table.find (name);
 
     if (p == table.end ())
       return do_insert (name);
     else
       return p->second;
   }
 
-  void do_inherit (scope_id donor_scope)
+  void do_inherit (scope_id donor_scope, context_id donor_context)
   {
     for (table_iterator p = table.begin (); p != table.end (); p++)
       {
 	symbol_record& sr = p->second;
 
 	std::string nm = sr.name ();
 
 	if (! (sr.is_automatic () || sr.is_formal () || nm == "__retval__"))
 	  {
-	    octave_value val = symbol_table::varval (nm, donor_scope);
+	    octave_value val
+	      = symbol_table::varval (nm, donor_scope, donor_context);
 
 	    if (val.is_defined ())
 	      {
-		sr.varref () = val;
+		// Currently, inherit is always called when creating a
+		// new table, so it only makes sense to copy values into
+		// the base context (== 0), but maybe the context
+		// should be passed in as a parameter instead?
+
+		sr.varref (0) = val;
 
 		sr.mark_inherited ();
 	      }
 	  }
       }
   }
 
   octave_value
@@ -1842,35 +1872,35 @@ private:
   symbol_record& do_insert (const std::string& name)
   {
     table_iterator p = table.find (name);
 
     return p == table.end ()
       ? (table[name] = symbol_record (name)) : p->second;
   }
 
-  octave_value& do_varref (const std::string& name)
+  octave_value& do_varref (const std::string& name, context_id context)
   {
     table_iterator p = table.find (name);
 
     if (p == table.end ())
       {
 	symbol_record& sr = do_insert (name);
 
-	return sr.varref ();
+	return sr.varref (context);
       }
     else
-      return p->second.varref ();
+      return p->second.varref (context);
   }
 
-  octave_value do_varval (const std::string& name) const
+  octave_value do_varval (const std::string& name, context_id context) const
   {
     table_const_iterator p = table.find (name);
 
-    return (p != table.end ()) ? p->second.varval () : octave_value ();
+    return (p != table.end ()) ? p->second.varval (context) : octave_value ();
   }
 
   octave_value& do_persistent_varref (const std::string& name)
   {
     persistent_table_iterator p = persistent_table.find (name);
 
     return (p == persistent_table.end ())
       ? persistent_table[name] : p->second;
@@ -2012,25 +2042,26 @@ private:
   void do_mark_global (const std::string& name)
   {
     table_iterator p = table.find (name);
 
     if (p != table.end ())
       p->second.mark_global ();
   }
 
-  std::list<symbol_record> do_all_variables (bool defined_only) const
+  std::list<symbol_record>
+  do_all_variables (context_id context, bool defined_only) const
   {
     std::list<symbol_record> retval;
 
     for (table_const_iterator p = table.begin (); p != table.end (); p++)
       {
 	const symbol_record& sr = p->second;
 
-	if (defined_only && ! sr.is_defined ())
+	if (defined_only && ! sr.is_defined (context))
 	  continue;
 
 	retval.push_back (sr);
       }
 
     return retval;
   }
 
