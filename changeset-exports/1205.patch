# HG changeset patch
# User jwe
# Date 796961101 0
#      Tue Apr 04 02:05:01 1995 +0000
# Node ID 8302fab9fe24eeb6bc6335af643643effd050e8e
# Parent  68d147abe7ca51c26b6fd0853bc43637d795ff36
[project @ 1995-04-04 02:05:01 by jwe]

diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -33,21 +33,20 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "mx-inlines.cc"
 #include "f77-uscore.h"
 #include "lo-error.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FCN (zgemm) (const char*, const char*, const int*,
-		       const int*, const int*, const Complex*,
+  int F77_FCN (zgemv) (const char*, const int*, const int*,
+		       const Complex*, const Complex*, const int*,
 		       const Complex*, const int*, const Complex*,
-		       const int*, const Complex*, Complex*, const int*,
-		       long, long);
+		       Complex*, const int*, long);
 }
 
 /*
  * Complex Column Vector class
  */
 
 #define KLUDGE_VECTORS
 #define TYPE Complex
@@ -59,67 +58,16 @@ extern "C"
 
 ComplexColumnVector::ComplexColumnVector (const ColumnVector& a)
    : Array<Complex> (a.length ())
 {
   for (int i = 0; i < length (); i++)
     elem (i) = a.elem (i);
 }
 
-#if 0
-ComplexColumnVector&
-ComplexColumnVector::resize (int n)
-{
-  if (n < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't resize to negative dimension");
-      return *this;
-    }
-
-  Complex *new_data = 0;
-  if (n > 0)
-    {
-      new_data = new Complex [n];
-      int min_len = len < n ? len : n;
-
-      for (int i = 0; i < min_len; i++)
-	new_data[i] = data[i];
-    }
-
-  delete [] data;
-  len = n;
-  data = new_data;
-
-  return *this;
-}
-
-ComplexColumnVector&
-ComplexColumnVector::resize (int n, double val)
-{
-  int old_len = len;
-  resize (n);
-  for (int i = old_len; i < len; i++)
-    data[i] = val;
-
-  return *this;
-}
-
-ComplexColumnVector&
-ComplexColumnVector::resize (int n, const Complex& val)
-{
-  int old_len = len;
-  resize (n);
-  for (int i = old_len; i < len; i++)
-    data[i] = val;
-
-  return *this;
-}
-#endif
-
 int
 ComplexColumnVector::operator == (const ComplexColumnVector& a) const
 {
   int len = length ();
   if (len != a.length ())
     return 0;
   return equal (data (), a.data (), len);
 }
@@ -251,36 +199,16 @@ ComplexColumnVector::hermitian (void) co
 
 ComplexRowVector
 ComplexColumnVector::transpose (void) const
 {
   int len = length ();
   return ComplexRowVector (dup (data (), len), len);
 }
 
-ColumnVector
-real (const ComplexColumnVector& a)
-{
-  int a_len = a.length ();
-  ColumnVector retval;
-  if (a_len > 0)
-    retval = ColumnVector (real_dup (a.data (), a_len), a_len);
-  return retval;
-}
-
-ColumnVector
-imag (const ComplexColumnVector& a)
-{
-  int a_len = a.length ();
-  ColumnVector retval;
-  if (a_len > 0)
-    retval = ColumnVector (imag_dup (a.data (), a_len), a_len);
-  return retval;
-}
-
 ComplexColumnVector
 conj (const ComplexColumnVector& a)
 {
   int a_len = a.length ();
   ComplexColumnVector retval;
   if (a_len > 0)
     retval = ComplexColumnVector (conj_dup (a.data (), a_len), a_len);
   return retval;
@@ -411,16 +339,44 @@ operator * (const ComplexColumnVector& v
 
 ComplexColumnVector
 operator / (const ComplexColumnVector& v, double s)
 {
   int len = v.length ();
   return ComplexColumnVector (divide (v.data (), len, s), len);
 }
 
+ComplexColumnVector
+operator + (const ColumnVector& a, const Complex& s)
+{
+  int len = a.length ();
+  return ComplexColumnVector (add (a.data (), len, s), len);
+}
+
+ComplexColumnVector
+operator - (const ColumnVector& a, const Complex& s)
+{
+  int len = a.length ();
+  return ComplexColumnVector (subtract (a.data (), len, s), len);
+}
+
+ComplexColumnVector
+operator * (const ColumnVector& a, const Complex& s)
+{
+  int len = a.length ();
+  return ComplexColumnVector (multiply (a.data (), len, s), len);
+}
+
+ComplexColumnVector
+operator / (const ColumnVector& a, const Complex& s)
+{
+  int len = a.length ();
+  return ComplexColumnVector (divide (a.data (), len, s), len);
+}
+
 // scalar by column vector -> column vector operations
 
 ComplexColumnVector
 operator + (double s, const ComplexColumnVector& a)
 {
   int a_len = a.length ();
   return ComplexColumnVector (add (a.data (), a_len, s), a_len);
 }
@@ -441,46 +397,80 @@ operator * (double s, const ComplexColum
 
 ComplexColumnVector
 operator / (double s, const ComplexColumnVector& a)
 {
   int a_len = a.length ();
   return ComplexColumnVector (divide (s, a.data (), a_len), a_len);
 }
 
-// column vector by row vector -> matrix operations
+ComplexColumnVector
+operator + (const Complex& s, const ColumnVector& a)
+{
+  int a_len = a.length ();
+  return ComplexColumnVector (add (a.data (), a_len, s), a_len);
+}
+
+ComplexColumnVector
+operator - (const Complex& s, const ColumnVector& a)
+{
+  int a_len = a.length ();
+  return ComplexColumnVector (subtract (s, a.data (), a_len), a_len);
+}
+
+ComplexColumnVector
+operator * (const Complex& s, const ColumnVector& a)
+{
+  int a_len = a.length ();
+  return ComplexColumnVector (multiply (a.data (), a_len, s), a_len);
+}
 
-ComplexMatrix
-operator * (const ComplexColumnVector& v, const ComplexRowVector& a)
+ComplexColumnVector
+operator / (const Complex& s, const ColumnVector& a)
 {
-  int len = v.length ();
   int a_len = a.length ();
-  if (len != a_len)
+  return ComplexColumnVector (divide (s, a.data (), a_len), a_len);
+}
+
+// matrix by column vector -> column vector operations
+
+ComplexColumnVector
+operator * (const ComplexMatrix& m, const ColumnVector& a)
+{
+  ComplexColumnVector tmp (a);
+  return m * tmp;
+}
+
+ComplexColumnVector
+operator * (const ComplexMatrix& m, const ComplexColumnVector& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nc != a.length ())
     {
       (*current_liboctave_error_handler)
-	("nonconformant vector multiplication attempted");
-      return ComplexMatrix ();
+	("nonconformant matrix multiplication attempted");
+      return ComplexColumnVector ();
     }
 
-  if (len == 0)
-    return ComplexMatrix (len, len, 0.0);
+  if (nc == 0 || nr == 0)
+    return ComplexColumnVector (0);
 
-  char transa = 'N';
-  char transb = 'N';
+  char trans = 'N';
+  int ld = nr;
   Complex alpha (1.0);
   Complex beta (0.0);
-  int anr = 1;
+  int i_one = 1;
 
-  Complex *c = new Complex [len * a_len];
+  Complex *y = new Complex [nr];
 
-  F77_FCN (zgemm) (&transa, &transb, &len, &a_len, &anr, &alpha,
-		   v.data (), &len, a.data (), &anr, &beta, c, &len,
-		   1L, 1L);
+  F77_FCN (zgemv) (&trans, &nr, &nc, &alpha, m.data (), &ld, a.data (),
+		   &i_one, &beta, y, &i_one, 1L); 
 
-  return ComplexMatrix (c, len, a_len);
+  return ComplexColumnVector (y, nr);
 }
 
 // column vector by column vector -> column vector operations
 
 ComplexColumnVector
 operator + (const ComplexColumnVector& v, const ColumnVector& a)
 {
   int len = v.length ();
@@ -510,16 +500,50 @@ operator - (const ComplexColumnVector& v
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (subtract (v.data (), a.data (), len), len);
 }
 
 ComplexColumnVector
+operator + (const ColumnVector& v, const ComplexColumnVector& a)
+{
+  int len = v.length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector subtraction attempted");
+      return ComplexColumnVector ();
+    }
+
+  if (len == 0)
+    return ComplexColumnVector (0);
+
+  return ComplexColumnVector (add (v.data (), a.data (), len), len);
+}
+
+ComplexColumnVector
+operator - (const ColumnVector& v, const ComplexColumnVector& a)
+{
+  int len = v.length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector subtraction attempted");
+      return ComplexColumnVector ();
+    }
+
+  if (len == 0)
+    return ComplexColumnVector (0);
+
+  return ComplexColumnVector (subtract (v.data (), a.data (), len), len);
+}
+
+ComplexColumnVector
 product (const ComplexColumnVector& v, const ColumnVector& a)
 {
   int len = v.length ();
   if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector product attempted");
       return ComplexColumnVector ();
@@ -543,36 +567,152 @@ quotient (const ComplexColumnVector& v, 
     }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (divide (v.data (), a.data (), len), len);
 }
 
+ComplexColumnVector
+product (const ColumnVector& v, const ComplexColumnVector& a)
+{
+  int len = v.length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector product attempted");
+      return ColumnVector ();
+    }
+
+  if (len == 0)
+    return ComplexColumnVector (0);
+
+  return ComplexColumnVector (multiply (v.data (), a.data (), len), len);
+}
+
+ComplexColumnVector
+quotient (const ColumnVector& v, const ComplexColumnVector& a)
+{
+  int len = v.length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector quotient attempted");
+      return ColumnVector ();
+    }
+
+  if (len == 0)
+    return ComplexColumnVector (0);
+
+  return ComplexColumnVector (divide (v.data (), a.data (), len), len);
+}
+
+// matrix by column vector -> column vector operations
+
+ComplexColumnVector
+operator * (const Matrix& m, const ComplexColumnVector& a)
+{
+  ComplexMatrix tmp (m);
+  return tmp * a;
+}
+
+// diagonal matrix by column vector -> column vector operations
+
+ComplexColumnVector
+operator * (const DiagMatrix& m, const ComplexColumnVector& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_len = a.length ();
+  if (nc != a_len)
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return ColumnVector ();
+    }
+
+  if (nc == 0 || nr == 0)
+    return ComplexColumnVector (0);
+
+  ComplexColumnVector result (nr);
+
+  for (int i = 0; i < a_len; i++)
+    result.elem (i) = a.elem (i) * m.elem (i, i);
+
+  for (i = a_len; i < nr; i++)
+    result.elem (i) = 0.0;
+
+  return result;
+}
+
+ComplexColumnVector
+operator * (const ComplexDiagMatrix& m, const ColumnVector& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_len = a.length ();
+  if (nc != a_len)
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix muliplication attempted");
+      return ComplexColumnVector ();
+    }
+
+  if (nc == 0 || nr == 0)
+    return ComplexColumnVector (0);
+
+  ComplexColumnVector result (nr);
+
+  for (int i = 0; i < a_len; i++)
+    result.elem (i) = a.elem (i) * m.elem (i, i);
+
+  for (i = a_len; i < nr; i++)
+    result.elem (i) = 0.0;
+
+  return result;
+}
+
+ComplexColumnVector
+operator * (const ComplexDiagMatrix& m, const ComplexColumnVector& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_len = a.length ();
+  if (nc != a_len)
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix muliplication attempted");
+      return ComplexColumnVector ();
+    }
+
+  if (nc == 0 || nr == 0)
+    return ComplexColumnVector (0);
+
+  ComplexColumnVector result (nr);
+
+  for (int i = 0; i < a_len; i++)
+    result.elem (i) = a.elem (i) * m.elem (i, i);
+
+  for (i = a_len; i < nr; i++)
+    result.elem (i) = 0.0;
+
+  return result;
+}
+
 // other operations
 
 ComplexColumnVector
 map (c_c_Mapper f, const ComplexColumnVector& a)
 {
   ComplexColumnVector b (a);
   b.map (f);
   return b;
 }
 
-ColumnVector
-map (d_c_Mapper f, const ComplexColumnVector& a)
-{
-  int a_len = a.length ();
-  ColumnVector b (a_len);
-  for (int i = 0; i < a_len; i++)
-    b.elem (i) = f (a.elem (i));
-  return b;
-}
-
 void
 ComplexColumnVector::map (c_c_Mapper f)
 {
   for (int i = 0; i < length (); i++)
     elem (i) = f (elem (i));
 }
 
 Complex
diff --git a/liboctave/CColVector.h b/liboctave/CColVector.h
--- a/liboctave/CColVector.h
+++ b/liboctave/CColVector.h
@@ -27,31 +27,27 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "Array.h"
 
 #include "mx-defs.h"
 
 extern "C++" {
 
 class ComplexColumnVector : public Array<Complex>
 {
-friend class ColumnVector;
+friend class ComplexMatrix;
 friend class ComplexRowVector;
-friend class ComplexMatrix;
 
 public:
 
   ComplexColumnVector (void) : Array<Complex> () { }
   ComplexColumnVector (int n) : Array<Complex> (n) { }
-  ComplexColumnVector (int n, const Complex& val)
-    : Array<Complex> (n, val) { }
+  ComplexColumnVector (int n, const Complex& val) : Array<Complex> (n, val) { }
   ComplexColumnVector (const ColumnVector& a);
   ComplexColumnVector (const Array<Complex>& a) : Array<Complex> (a) { }
   ComplexColumnVector (const ComplexColumnVector& a) : Array<Complex> (a) { }
-//  ComplexColumnVector (double a) : Array<Complex> (1, a) { }
-//  ComplexColumnVector (const Complex& a) : Array<Complex> (1, a) { }
 
   ComplexColumnVector& operator = (const ComplexColumnVector& a)
     {
       Array<Complex>::operator = (a);
       return *this;
     }
 
 //  operator Array<Complex>& () const { return *this; }
@@ -70,18 +66,16 @@ public:
   ComplexColumnVector& fill (const Complex& val, int r1, int r2);
 
   ComplexColumnVector stack (const ColumnVector& a) const;
   ComplexColumnVector stack (const ComplexColumnVector& a) const;
 
   ComplexRowVector hermitian (void) const;  // complex conjugate transpose.
   ComplexRowVector transpose (void) const;
 
-  friend ColumnVector real (const ComplexColumnVector& a);
-  friend ColumnVector imag (const ComplexColumnVector& a);
   friend ComplexColumnVector conj (const ComplexColumnVector& a);
 
 // resize is the destructive equivalent for this one
 
   ComplexColumnVector extract (int r1, int r2) const;
 
 // column vector by column vector -> column vector operations
 
@@ -97,48 +91,94 @@ public:
 					 double s);
   friend ComplexColumnVector operator - (const ComplexColumnVector& a,
 					 double s);
   friend ComplexColumnVector operator * (const ComplexColumnVector& a,
 					 double s);
   friend ComplexColumnVector operator / (const ComplexColumnVector& a,
 					 double s);
 
+  friend ComplexColumnVector operator + (const ColumnVector& a,
+					 const Complex& s);  
+  friend ComplexColumnVector operator - (const ColumnVector& a,
+					 const Complex& s);
+  friend ComplexColumnVector operator * (const ColumnVector& a,
+					 const Complex& s);
+  friend ComplexColumnVector operator / (const ColumnVector& a,
+					 const Complex& s);
+
 // scalar by column vector -> column vector operations
 
   friend ComplexColumnVector operator + (double s,
 					 const ComplexColumnVector& a); 
   friend ComplexColumnVector operator - (double s,
 					 const ComplexColumnVector& a);
   friend ComplexColumnVector operator * (double s,
 					 const ComplexColumnVector& a);
   friend ComplexColumnVector operator / (double s,
 					 const ComplexColumnVector& a);
 
-// column vector by row vector -> matrix operations
+  friend ComplexColumnVector operator + (const Complex& s,
+					 const ColumnVector& a); 
+  friend ComplexColumnVector operator - (const Complex& s,
+					 const ColumnVector& a);
+  friend ComplexColumnVector operator * (const Complex& s,
+					 const ColumnVector& a);
+  friend ComplexColumnVector operator / (const Complex& s,
+					 const ColumnVector& a);
 
-  friend ComplexMatrix operator * (const ComplexColumnVector& a,
-				   const ComplexRowVector& b);
+// matrix by column vector -> column vector operations
+
+  friend ComplexColumnVector operator * (const ComplexMatrix& a,
+					 const ColumnVector& b);
+
+  friend ComplexColumnVector operator * (const ComplexMatrix& a,
+					 const ComplexColumnVector& b);
 
 // column vector by column vector -> column vector operations
 
   friend ComplexColumnVector operator + (const ComplexColumnVector& a,
 					 const ColumnVector& b);
   friend ComplexColumnVector operator - (const ComplexColumnVector& a,
 					 const ColumnVector& b);
 
+  friend ComplexColumnVector operator + (const ColumnVector& a,
+					 const ComplexColumnVector& b);
+  friend ComplexColumnVector operator - (const ColumnVector& a,
+					 const ComplexColumnVector& b); 
+
   friend ComplexColumnVector product (const ComplexColumnVector& a,
 				      const ColumnVector& b);
   friend ComplexColumnVector quotient (const ComplexColumnVector& a,
 				       const ColumnVector& b);
 
+  friend ComplexColumnVector product (const ColumnVector& a,
+				      const ComplexColumnVector& b); 
+  friend ComplexColumnVector quotient (const ColumnVector& a,
+				       const ComplexColumnVector& b); 
+
+// matrix by column vector -> column vector operations
+
+  friend ComplexColumnVector operator * (const Matrix& a,
+					 const ComplexColumnVector& b);
+
+// diagonal matrix by column vector -> column vector operations
+
+  friend ComplexColumnVector operator * (const DiagMatrix& a,
+					 const ComplexColumnVector& b);
+
+  friend ComplexColumnVector operator * (const ComplexDiagMatrix& a,
+					 const ColumnVector& b);
+
+  friend ComplexColumnVector operator * (const ComplexDiagMatrix& a,
+					 const ComplexColumnVector& b);
+
 // other operations
 
   friend ComplexColumnVector map (c_c_Mapper f, const ComplexColumnVector& a);
-  friend ColumnVector map (d_c_Mapper f, const ComplexColumnVector& a);
   void map (c_c_Mapper f);
 
   Complex min (void) const;
   Complex max (void) const;
 
 // i/o
 
   friend ostream& operator << (ostream& os, const ComplexColumnVector& a);
@@ -147,20 +187,18 @@ public:
 #define KLUDGE_VECTORS
 #define TYPE Complex
 #define KL_VEC_TYPE ComplexColumnVector
 #include "mx-kludge.h"
 #undef KLUDGE_VECTORS
 #undef TYPE
 #undef KL_VEC_TYPE
 
-// private:
-// XXX FIXME XXX -- why does it not work to make this private, with
-// ColumnVector declared as a friend of ComplexColumnVector?  It seems
-// to work for the similar case with Matrix/ComplexMatrix.  Hmm...
+private:
+
   ComplexColumnVector (Complex *d, int l) : Array<Complex> (d, l) { }
 };
 
 } // extern "C++"
 
 #endif
 
 /*
diff --git a/liboctave/CDiagMatrix.cc b/liboctave/CDiagMatrix.cc
--- a/liboctave/CDiagMatrix.cc
+++ b/liboctave/CDiagMatrix.cc
@@ -61,138 +61,31 @@ ComplexDiagMatrix::ComplexDiagMatrix (co
 
 ComplexDiagMatrix::ComplexDiagMatrix (const DiagMatrix& a)
   : DiagArray<Complex> (a.rows (), a.cols ())
 {
   for (int i = 0; i < length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
-#if 0
-ComplexDiagMatrix&
-ComplexDiagMatrix::resize (int r, int c)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't resize to negative dimensions");
-      return *this;
-    }
-
-  int new_len = r < c ? r : c;
-  Complex *new_data = 0;
-  if (new_len > 0)
-    {
-      new_data = new Complex [new_len];
-
-      int min_len = new_len < len ? new_len : len;
-
-      for (int i = 0; i < min_len; i++)
-	new_data[i] = data[i];
-    }
-
-  delete [] data;
-  nr = r;
-  nc = c;
-  len = new_len;
-  data = new_data;
-
-  return *this;
-}
-
-ComplexDiagMatrix&
-ComplexDiagMatrix::resize (int r, int c, double val)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't resize to negative dimensions");
-      return *this;
-    }
-
-  int new_len = r < c ? r : c;
-  Complex *new_data = 0;
-  if (new_len > 0)
-    {
-      new_data = new Complex [new_len];
-
-      int min_len = new_len < len ? new_len : len;
-
-      for (int i = 0; i < min_len; i++)
-	new_data[i] = data[i];
-
-      for (i = min_len; i < new_len; i++)
-	new_data[i] = val;
-    }
-
-  delete [] data;
-  nr = r;
-  nc = c;
-  len = new_len;
-  data = new_data;
-
-  return *this;
-}
-
-ComplexDiagMatrix&
-ComplexDiagMatrix::resize (int r, int c, const Complex& val)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't resize to negative dimensions");
-      return *this;
-    }
-
-  int new_len = r < c ? r : c;
-  Complex *new_data = 0;
-  if (new_len > 0)
-    {
-      new_data = new Complex [new_len];
-
-      int min_len = new_len < len ? new_len : len;
-
-      for (int i = 0; i < min_len; i++)
-	new_data[i] = data[i];
-
-      for (i = min_len; i < new_len; i++)
-	new_data[i] = val;
-    }
-
-  delete [] data;
-  nr = r;
-  nc = c;
-  len = new_len;
-  data = new_data;
-
-  return *this;
-}
-#endif
-
 int
 ComplexDiagMatrix::operator == (const ComplexDiagMatrix& a) const
 {
   if (rows () != a.rows () || cols () != a.cols ())
     return 0;
 
   return equal (data (), a.data (), length ());
 }
 
 int
 ComplexDiagMatrix::operator != (const ComplexDiagMatrix& a) const
 {
   return !(*this == a);
 }
 
-ComplexDiagMatrix
-ComplexDiagMatrix::hermitian (void) const
-{
-  return ComplexDiagMatrix (conj_dup (data (), length ()), cols (), rows ());
-}
-
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (double val)
 {
   for (int i = 0; i < length (); i++)
     elem (i, i) = val;
   return *this;
 }
 
@@ -358,43 +251,27 @@ ComplexDiagMatrix::fill (const ComplexRo
 
   for (int i = 0; i < a_len; i++)
     elem (i+beg, i+beg) = a.elem (i);
 
   return *this;
 }
 
 ComplexDiagMatrix
+ComplexDiagMatrix::hermitian (void) const
+{
+  return ComplexDiagMatrix (conj_dup (data (), length ()), cols (), rows ());
+}
+
+ComplexDiagMatrix
 ComplexDiagMatrix::transpose (void) const
 {
   return ComplexDiagMatrix (dup (data (), length ()), cols (), rows ());
 }
 
-DiagMatrix
-real (const ComplexDiagMatrix& a)
-{
-  DiagMatrix retval;
-  int a_len = a.length ();
-  if (a_len > 0)
-    retval = DiagMatrix (real_dup (a.data (), a_len), a.rows (),
-			 a.cols ());
-  return retval;
-}
-
-DiagMatrix
-imag (const ComplexDiagMatrix& a)
-{
-  DiagMatrix retval;
-  int a_len = a.length ();
-  if (a_len > 0)
-    retval = DiagMatrix (imag_dup (a.data (), a_len), a.rows (),
-			 a.cols ());
-  return retval;
-}
-
 ComplexDiagMatrix
 conj (const ComplexDiagMatrix& a)
 {
   ComplexDiagMatrix retval;
   int a_len = a.length ();
   if (a_len > 0)
     retval = ComplexDiagMatrix (conj_dup (a.data (), a_len),
 				a.rows (), a.cols ());
@@ -617,155 +494,60 @@ ComplexDiagMatrix::operator -= (const Co
     return *this;
 
   Complex *d = fortran_vec (); // Ensures only one reference to my privates!
 
   subtract2 (d, a.data (), length ());
   return *this;
 }
 
-// diagonal matrix by scalar -> matrix operations
-
-ComplexMatrix
-operator + (const ComplexDiagMatrix& a, double s)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), s);
-  return a + tmp;
-}
-
-ComplexMatrix
-operator - (const ComplexDiagMatrix& a, double s)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), -s);
-  return a + tmp;
-}
-
-ComplexMatrix
-operator + (const ComplexDiagMatrix& a, const Complex& s)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), s);
-  return a + tmp;
-}
-
-ComplexMatrix
-operator - (const ComplexDiagMatrix& a, const Complex& s)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), -s);
-  return a + tmp;
-}
-
 // diagonal matrix by scalar -> diagonal matrix operations
 
 ComplexDiagMatrix
 operator * (const ComplexDiagMatrix& a, double s)
 {
   return ComplexDiagMatrix (multiply (a.data (), a.length (), s),
 			    a.rows (), a.cols ());
 }
 
 ComplexDiagMatrix
 operator / (const ComplexDiagMatrix& a, double s)
 {
   return ComplexDiagMatrix (divide (a.data (), a.length (), s),
 			    a.rows (), a.cols ());
 }
 
-// scalar by diagonal matrix -> matrix operations
-
-ComplexMatrix
-operator + (double s, const ComplexDiagMatrix& a)
+ComplexDiagMatrix
+operator * (const DiagMatrix& a, const Complex& s)
 {
-  ComplexMatrix tmp (a.rows (), a.cols (), s);
-  return tmp + a;
+  return ComplexDiagMatrix (multiply (a.data (), a.length (), s),
+			    a.rows (), a.cols ());
 }
 
-ComplexMatrix
-operator - (double s, const ComplexDiagMatrix& a)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), s);
-  return tmp - a;
-}
-
-ComplexMatrix
-operator + (const Complex& s, const ComplexDiagMatrix& a)
+ComplexDiagMatrix
+operator / (const DiagMatrix& a, const Complex& s)
 {
-  ComplexMatrix tmp (a.rows (), a.cols (), s);
-  return tmp + a;
-}
-
-ComplexMatrix
-operator - (const Complex& s, const ComplexDiagMatrix& a)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), s);
-  return tmp - a;
+  return ComplexDiagMatrix (divide (a.data (), a.length (), s),
+			    a.rows (), a.cols ());
 }
 
 // scalar by diagonal matrix -> diagonal matrix operations
 
 ComplexDiagMatrix
 operator * (double s, const ComplexDiagMatrix& a)
 {
   return ComplexDiagMatrix (multiply (a.data (), a.length (), s),
 			    a.rows (), a.cols ());
 }
 
-// diagonal matrix by column vector -> column vector operations
-
-ComplexColumnVector
-operator * (const ComplexDiagMatrix& m, const ColumnVector& a)
+ComplexDiagMatrix
+operator * (const Complex& s, const DiagMatrix& a)
 {
-  int nr = m.rows ();
-  int nc = m.cols ();
-  int a_len = a.length ();
-  if (nc != a_len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix muliplication attempted");
-      return ComplexColumnVector ();
-    }
-
-  if (nc == 0 || nr == 0)
-    return ComplexColumnVector (0);
-
-  ComplexColumnVector result (nr);
-
-  for (int i = 0; i < a_len; i++)
-    result.elem (i) = a.elem (i) * m.elem (i, i);
-
-  for (i = a_len; i < nr; i++)
-    result.elem (i) = 0.0;
-
-  return result;
-}
-
-ComplexColumnVector
-operator * (const ComplexDiagMatrix& m, const ComplexColumnVector& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  int a_len = a.length ();
-  if (nc != a_len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix muliplication attempted");
-      return ComplexColumnVector ();
-    }
-
-  if (nc == 0 || nr == 0)
-    return ComplexColumnVector (0);
-
-  ComplexColumnVector result (nr);
-
-  for (int i = 0; i < a_len; i++)
-    result.elem (i) = a.elem (i) * m.elem (i, i);
-
-  for (i = a_len; i < nr; i++)
-    result.elem (i) = 0.0;
-
-  return result;
+  return ComplexDiagMatrix (multiply (a.data (), a.length (), s),
+			    a.rows (), a.cols ());
 }
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 ComplexDiagMatrix
 operator * (const ComplexDiagMatrix& a, const ComplexDiagMatrix& b)
 {
   int nr_a = a.rows ();
@@ -876,16 +658,92 @@ operator * (const ComplexDiagMatrix& a, 
       else
         c.elem (i, i) = a_element * b_element;
     }
 
   return c;
 }
 
 ComplexDiagMatrix
+operator + (const DiagMatrix& m, const ComplexDiagMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return ComplexDiagMatrix ();
+    }
+
+  if (nc == 0 || nr == 0)
+    return ComplexDiagMatrix (nr, nc);
+
+  return ComplexDiagMatrix (add (m.data (), a.data (), m.length ()),  nr, nc);
+}
+
+ComplexDiagMatrix
+operator - (const DiagMatrix& m, const ComplexDiagMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return ComplexDiagMatrix ();
+    }
+
+  if (nc == 0 || nr == 0)
+    return ComplexDiagMatrix (nr, nc);
+
+  return ComplexDiagMatrix (subtract (m.data (), a.data (), m.length ()),
+			    nr, nc);
+}
+
+ComplexDiagMatrix
+operator * (const DiagMatrix& a, const ComplexDiagMatrix& b)
+{
+  int nr_a = a.rows ();
+  int nc_a = a.cols ();
+  int nr_b = b.rows ();
+  int nc_b = b.cols ();
+  if (nc_a != nr_b)
+    {
+      (*current_liboctave_error_handler)
+        ("nonconformant matrix multiplication attempted");
+      return ComplexDiagMatrix ();
+    }
+
+  if (nr_a == 0 || nc_a == 0 || nc_b == 0)
+    return ComplexDiagMatrix (nr_a, nc_a, 0.0);
+
+  ComplexDiagMatrix c (nr_a, nc_b);
+
+  int len = nr_a < nc_b ? nr_a : nc_b;
+
+  for (int i = 0; i < len; i++)
+    {
+      double a_element = a.elem (i, i);
+      Complex b_element = b.elem (i, i);
+
+      if (a_element == 0.0 || b_element == 0.0)
+        c.elem (i, i) = 0.0;
+      else if (a_element == 1.0)
+        c.elem (i, i) = b_element;
+      else if (b_element == 1.0)
+        c.elem (i, i) = a_element;
+      else
+        c.elem (i, i) = a_element * b_element;
+    }
+
+  return c;
+}
+
+ComplexDiagMatrix
 product (const ComplexDiagMatrix& m, const DiagMatrix& a)
 {
   int nr = m.rows ();
   int nc = m.cols ();
   if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix product attempted");
@@ -894,200 +752,33 @@ product (const ComplexDiagMatrix& m, con
 
   if (nr == 0 || nc == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (multiply (m.data (), a.data (), m.length ()),
 			    nr, nc);
 }
 
-// diagonal matrix by matrix -> matrix operations
-
-ComplexMatrix
-operator + (const ComplexDiagMatrix& m, const Matrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix addition attempted");
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  ComplexMatrix result (a);
-  for (int i = 0; i < m.length (); i++)
-    result.elem (i, i) += m.elem (i, i);
-
-  return result;
-}
-
-ComplexMatrix
-operator - (const ComplexDiagMatrix& m, const Matrix& a)
+ComplexDiagMatrix
+product (const DiagMatrix& m, const ComplexDiagMatrix& a)
 {
   int nr = m.rows ();
   int nc = m.cols ();
   if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
-	("nonconformant matrix subtraction attempted");
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  ComplexMatrix result (-a);
-  for (int i = 0; i < m.length (); i++)
-    result.elem (i, i) += m.elem (i, i);
-
-  return result;
-}
-
-ComplexMatrix
-operator * (const ComplexDiagMatrix& m, const Matrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-  if (nc != a_nr)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix multiplication attempted");
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0 || a_nc == 0)
-    return ComplexMatrix (nr, a_nc, 0.0);
-
-  ComplexMatrix c (nr, a_nc);
-
-  for (int i = 0; i < m.length (); i++)
-    {
-      if (m.elem (i, i) == 1.0)
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = a.elem (i, j);
-	}
-      else if (m.elem (i, i) == 0.0)
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = 0.0;
-	}
-      else
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = m.elem (i, i) * a.elem (i, j);
-	}
-    }
-
-  if (nr > nc)
-    {
-      for (int j = 0; j < a_nc; j++)
-	for (int i = a_nr; i < nr; i++)
-	  c.elem (i, j) = 0.0;
-    }
-
-  return c;
-}
-
-ComplexMatrix
-operator + (const ComplexDiagMatrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix addition attempted");
-      return ComplexMatrix ();
+	("nonconformant matrix product attempted");
+      return ComplexDiagMatrix ();
     }
 
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  ComplexMatrix result (a);
-  for (int i = 0; i < m.length (); i++)
-    result.elem (i, i) += m.elem (i, i);
-
-  return result;
-}
-
-ComplexMatrix
-operator - (const ComplexDiagMatrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix subtraction attempted");
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  ComplexMatrix result (-a);
-  for (int i = 0; i < m.length (); i++)
-    result.elem (i, i) += m.elem (i, i);
-
-  return result;
-}
+  if (nc == 0 || nr == 0)
+    return ComplexDiagMatrix (nr, nc);
 
-ComplexMatrix
-operator * (const ComplexDiagMatrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-  if (nc != a_nr)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix multiplication attempted");
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0 || a_nc == 0)
-    return ComplexMatrix (nr, a_nc, 0.0);
-
-  ComplexMatrix c (nr, a_nc);
-
-  for (int i = 0; i < m.length (); i++)
-    {
-      if (m.elem (i, i) == 1.0)
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = a.elem (i, j);
-	}
-      else if (m.elem (i, i) == 0.0)
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = 0.0;
-	}
-      else
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = m.elem (i, i) * a.elem (i, j);
-	}
-    }
-
-  if (nr > nc)
-    {
-      for (int j = 0; j < a_nc; j++)
-	for (int i = a_nr; i < nr; i++)
-	  c.elem (i, j) = 0.0;
-    }
-
-  return c;
+  return ComplexDiagMatrix (multiply (m.data (), a.data (), m.length ()),
+			    nr, nc);
 }
 
 // other operations
 
 ComplexColumnVector
 ComplexDiagMatrix::diag (void) const
 {
   return diag (0);
diff --git a/liboctave/CDiagMatrix.h b/liboctave/CDiagMatrix.h
--- a/liboctave/CDiagMatrix.h
+++ b/liboctave/CDiagMatrix.h
@@ -32,18 +32,16 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "CColVector.h"
 
 #include "mx-defs.h"
 
 extern "C++" {
 
 class ComplexDiagMatrix : public DiagArray<Complex>
 {
-  friend DiagMatrix;
-
 public:
 
   ComplexDiagMatrix (void) : DiagArray<Complex> () { }
   ComplexDiagMatrix (int n) : DiagArray<Complex> (n) { }
   ComplexDiagMatrix (int n, const Complex& val)
     : DiagArray<Complex> (n, val) { }
   ComplexDiagMatrix (int r, int c) : DiagArray<Complex> (r, c) { }
   ComplexDiagMatrix (int r, int c, const Complex& val)
@@ -52,26 +50,23 @@ public:
   ComplexDiagMatrix (const ComplexRowVector& a) : DiagArray<Complex> (a) { }
   ComplexDiagMatrix (const ColumnVector& a);
   ComplexDiagMatrix (const ComplexColumnVector& a)
     : DiagArray<Complex> (a) { }
   ComplexDiagMatrix (const DiagMatrix& a);
   ComplexDiagMatrix (const DiagArray<Complex>& a)
     : DiagArray<Complex> (a) { }
   ComplexDiagMatrix (const ComplexDiagMatrix& a) : DiagArray<Complex> (a) { }
-//  ComplexDiagMatrix (const Complex& a) : DiagArray<Complex> (1, a) { }
 
   ComplexDiagMatrix& operator = (const ComplexDiagMatrix& a)
     {
       DiagArray<Complex>::operator = (a);
       return *this;
     }
 
-//  operator DiagArray<Complex>& () const { return *this; }
-
   int operator == (const ComplexDiagMatrix& a) const;
   int operator != (const ComplexDiagMatrix& a) const;
 
   ComplexDiagMatrix& fill (double val);
   ComplexDiagMatrix& fill (const Complex& val);
   ComplexDiagMatrix& fill (double val, int beg, int end);
   ComplexDiagMatrix& fill (const Complex& val, int beg, int end);
   ComplexDiagMatrix& fill (const ColumnVector& a);
@@ -81,18 +76,16 @@ public:
   ComplexDiagMatrix& fill (const ColumnVector& a, int beg);
   ComplexDiagMatrix& fill (const ComplexColumnVector& a, int beg);
   ComplexDiagMatrix& fill (const RowVector& a, int beg);
   ComplexDiagMatrix& fill (const ComplexRowVector& a, int beg);
 
   ComplexDiagMatrix hermitian (void) const;  // complex conjugate transpose
   ComplexDiagMatrix transpose (void) const;
 
-  friend DiagMatrix real (const ComplexDiagMatrix& a);
-  friend DiagMatrix imag (const ComplexDiagMatrix& a);
   friend ComplexDiagMatrix conj (const ComplexDiagMatrix& a);
 
 // resize is the destructive analog for this one
 
   ComplexMatrix extract (int r1, int c1, int r2, int c2) const;
 
 // extract row or column i.
 
@@ -108,83 +101,54 @@ public:
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
   ComplexDiagMatrix& operator += (const DiagMatrix& a);
   ComplexDiagMatrix& operator -= (const DiagMatrix& a);
 
   ComplexDiagMatrix& operator += (const ComplexDiagMatrix& a);
   ComplexDiagMatrix& operator -= (const ComplexDiagMatrix& a);
 
-// diagonal matrix by scalar -> matrix operations
-
-  friend ComplexMatrix operator + (const ComplexDiagMatrix& a, double s);
-  friend ComplexMatrix operator - (const ComplexDiagMatrix& a, double s);
-
-  friend ComplexMatrix operator + (const ComplexDiagMatrix& a,
-				   const Complex& s);
-  friend ComplexMatrix operator - (const ComplexDiagMatrix& a,
-				   const Complex& s);
-
 // diagonal matrix by scalar -> diagonal matrix operations
 
   friend ComplexDiagMatrix operator * (const ComplexDiagMatrix& a, double s);
   friend ComplexDiagMatrix operator / (const ComplexDiagMatrix& a, double s);
 
-// scalar by diagonal matrix -> matrix operations
-
-  friend ComplexMatrix operator + (double s, const ComplexDiagMatrix& a);
-  friend ComplexMatrix operator - (double s, const ComplexDiagMatrix& a);
-
-  friend ComplexMatrix operator + (const Complex& s,
-				   const ComplexDiagMatrix& a);
-  friend ComplexMatrix operator - (const Complex& s,
-				   const ComplexDiagMatrix& a);
+  friend ComplexDiagMatrix operator * (const DiagMatrix& a, const Complex& s);
+  friend ComplexDiagMatrix operator / (const DiagMatrix& a, const Complex& s);
 
 // scalar by diagonal matrix -> diagonal matrix operations
 
   friend ComplexDiagMatrix operator * (double s, const ComplexDiagMatrix& a);
 
-// diagonal matrix by column vector -> column vector operations
-
-  friend ComplexColumnVector operator * (const ComplexDiagMatrix& a,
-					 const ColumnVector& b);
-
-  friend ComplexColumnVector operator * (const ComplexDiagMatrix& a,
-					 const ComplexColumnVector& b);
+  friend ComplexDiagMatrix operator * (const Complex& s, const DiagMatrix& a);
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
   friend ComplexDiagMatrix operator * (const ComplexDiagMatrix& a,
 				       const ComplexDiagMatrix& b);
 
   friend ComplexDiagMatrix operator + (const ComplexDiagMatrix& a,
 				       const DiagMatrix& b);
   friend ComplexDiagMatrix operator - (const ComplexDiagMatrix& a,
 				       const DiagMatrix& b);
   friend ComplexDiagMatrix operator * (const ComplexDiagMatrix& a,
 				       const DiagMatrix& b);
 
+  friend ComplexDiagMatrix operator + (const DiagMatrix& a,
+				       const ComplexDiagMatrix& b);
+  friend ComplexDiagMatrix operator - (const DiagMatrix& a,
+				       const ComplexDiagMatrix& b);
+  friend ComplexDiagMatrix operator * (const DiagMatrix& a,
+				       const ComplexDiagMatrix& b);
+
   friend ComplexDiagMatrix product (const ComplexDiagMatrix& a,
 				    const DiagMatrix& b); 
 
-// diagonal matrix by matrix -> matrix operations
-
-  friend ComplexMatrix operator + (const ComplexDiagMatrix& a,
-				   const Matrix& b); 
-  friend ComplexMatrix operator - (const ComplexDiagMatrix& a,
-				   const Matrix& b);
-  friend ComplexMatrix operator * (const ComplexDiagMatrix& a,
-				   const Matrix& b);
-
-  friend ComplexMatrix operator + (const ComplexDiagMatrix& a,
-				   const ComplexMatrix& b);
-  friend ComplexMatrix operator - (const ComplexDiagMatrix& a,
-				   const ComplexMatrix& b);
-  friend ComplexMatrix operator * (const ComplexDiagMatrix& a,
-				   const ComplexMatrix& b);
+  friend ComplexDiagMatrix product (const DiagMatrix& a,
+				    const ComplexDiagMatrix& b);
 
 // other operations
 
   ComplexColumnVector diag (void) const;
   ComplexColumnVector diag (int k) const;
 
 // i/o
 
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -43,21 +43,16 @@ Software Foundation, 675 Mass Ave, Cambr
 extern "C"
 {
   int F77_FCN (zgemm) (const char*, const char*, const int*,
 		       const int*, const int*, const Complex*,
 		       const Complex*, const int*, const Complex*,
 		       const int*, const Complex*, Complex*, const int*,
 		       long, long);
 
-  int F77_FCN (zgemv) (const char*, const int*, const int*,
-		       const Complex*, const Complex*, const int*,
-		       const Complex*, const int*, const Complex*,
-		       Complex*, const int*, long);
-
   int F77_FCN (zgeco) (Complex*, const int*, const int*, int*,
 		       double*, Complex*);
 
   int F77_FCN (zgedi) (Complex*, const int*, const int*, int*,
 		       Complex*, Complex*, const int*);
 
   int F77_FCN (zgesl) (Complex*, const int*, const int*, int*,
 		       Complex*, const int*);
@@ -108,127 +103,16 @@ ComplexMatrix::ComplexMatrix (const Diag
 
 ComplexMatrix::ComplexMatrix (const ComplexDiagMatrix& a)
   : Array2<Complex> (a.rows (), a.cols (), 0.0)
 {
   for (int i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
-#if 0
-ComplexMatrix&
-ComplexMatrix::resize (int r, int c)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't resize to negative dimensions");
-      return *this;
-    }
-
-  int new_len = r * c;
-  Complex* new_data = 0;
-  if (new_len > 0)
-    {
-      new_data = new Complex [new_len];
-
-      int min_r = nr < r ? nr : r;
-      int min_c = nc < c ? nc : c;
-
-      for (int j = 0; j < min_c; j++)
-	for (int i = 0; i < min_r; i++)
-	  new_data[r*j+i] = elem (i, j);
-    }
-
-  delete [] data;
-  nr = r;
-  nc = c;
-  len = new_len;
-  data = new_data;
-
-  return *this;
-}
-
-ComplexMatrix&
-ComplexMatrix::resize (int r, int c, double val)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't resize to negative dimensions");
-      return *this;
-    }
-
-  int new_len = r * c;
-  Complex *new_data = 0;
-  if (new_len > 0)
-    {
-      new_data = new Complex [new_len];
-
-// There may be faster or cleaner ways to do this.
-
-      if (r > nr || c > nc)
-	copy (new_data, new_len, val);
-
-      int min_r = nr < r ? nr : r;
-      int min_c = nc < c ? nc : c;
-
-      for (int j = 0; j < min_c; j++)
-	for (int i = 0; i < min_r; i++)
-	  new_data[r*j+i] = elem (i, j);
-    }
-
-  delete [] data;
-  nr = r;
-  nc = c;
-  len = new_len;
-  data = new_data;
-
-  return *this;
-}
-
-ComplexMatrix&
-ComplexMatrix::resize (int r, int c, const Complex& val)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't resize to negative dimensions");
-      return *this;
-    }
-
-  int new_len = r * c;
-  Complex *new_data = 0;
-  if (new_len > 0)
-    {
-      new_data = new Complex [new_len];
-
-// There may be faster or cleaner ways to do this.
-
-      if (r > nr || c > nc)
-	copy (new_data, new_len, val);
-
-      int min_r = nr < r ? nr : r;
-      int min_c = nc < c ? nc : c;
-
-      for (int j = 0; j < min_c; j++)
-	for (int i = 0; i < min_r; i++)
-	  new_data[r*j+i] = elem (i, j);
-    }
-
-  delete [] data;
-  nr = r;
-  nc = c;
-  len = new_len;
-  data = new_data;
-
-  return *this;
-}
-#endif
-
 int
 ComplexMatrix::operator == (const ComplexMatrix& a) const
 {
   if (rows () != a.rows () || cols () != a.cols ())
     return 0;
 
   return equal (data (), a.data (), length ());
 }
@@ -765,36 +649,16 @@ ComplexMatrix::transpose (void) const
     {
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  result.elem (j, i) = elem (i, j);
     }
   return result;
 }
 
-Matrix
-real (const ComplexMatrix& a)
-{
-  int a_len = a.length ();
-  Matrix retval;
-  if (a_len > 0)
-    retval = Matrix (real_dup (a.data (), a_len), a.rows (), a.cols ());
-  return retval;
-}
-
-Matrix
-imag (const ComplexMatrix& a)
-{
-  int a_len = a.length ();
-  Matrix retval;
-  if (a_len > 0)
-    retval = Matrix (imag_dup (a.data (), a_len), a.rows (), a.cols ());
-  return retval;
-}
-
 ComplexMatrix
 conj (const ComplexMatrix& a)
 {
   int a_len = a.length ();
   ComplexMatrix retval;
   if (a_len > 0)
     retval = ComplexMatrix (conj_dup (a.data (), a_len), a.rows (),
 			    a.cols ());
@@ -1513,16 +1377,150 @@ ComplexMatrix::lssolve (const ComplexCol
   delete [] tmp_data;
   delete [] s;
   delete [] work;
   delete [] rwork;
 
   return retval;
 }
 
+// column vector by row vector -> matrix operations
+
+ComplexMatrix
+operator * (const ColumnVector& v, const ComplexRowVector& a)
+{
+  ComplexColumnVector tmp (v);
+  return tmp * a;
+}
+
+ComplexMatrix
+operator * (const ComplexColumnVector& a, const RowVector& b)
+{
+  ComplexRowVector tmp (b);
+  return a * tmp;
+}
+
+ComplexMatrix
+operator * (const ComplexColumnVector& v, const ComplexRowVector& a)
+{
+  int len = v.length ();
+  int a_len = a.length ();
+  if (len != a_len)
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector multiplication attempted");
+      return ComplexMatrix ();
+    }
+
+  if (len == 0)
+    return ComplexMatrix (len, len, 0.0);
+
+  char transa = 'N';
+  char transb = 'N';
+  Complex alpha (1.0);
+  Complex beta (0.0);
+  int anr = 1;
+
+  Complex *c = new Complex [len * a_len];
+
+  F77_FCN (zgemm) (&transa, &transb, &len, &a_len, &anr, &alpha,
+		   v.data (), &len, a.data (), &anr, &beta, c, &len,
+		   1L, 1L);
+
+  return ComplexMatrix (c, len, a_len);
+}
+
+// diagonal matrix by scalar -> matrix operations
+
+ComplexMatrix
+operator + (const DiagMatrix& a, const Complex& s)
+{
+  ComplexMatrix tmp (a.rows (), a.cols (), s);
+  return a + tmp;
+}
+
+ComplexMatrix
+operator - (const DiagMatrix& a, const Complex& s)
+{
+  ComplexMatrix tmp (a.rows (), a.cols (), -s);
+  return a + tmp;
+}
+
+ComplexMatrix
+operator + (const ComplexDiagMatrix& a, double s)
+{
+  ComplexMatrix tmp (a.rows (), a.cols (), s);
+  return a + tmp;
+}
+
+ComplexMatrix
+operator - (const ComplexDiagMatrix& a, double s)
+{
+  ComplexMatrix tmp (a.rows (), a.cols (), -s);
+  return a + tmp;
+}
+
+ComplexMatrix
+operator + (const ComplexDiagMatrix& a, const Complex& s)
+{
+  ComplexMatrix tmp (a.rows (), a.cols (), s);
+  return a + tmp;
+}
+
+ComplexMatrix
+operator - (const ComplexDiagMatrix& a, const Complex& s)
+{
+  ComplexMatrix tmp (a.rows (), a.cols (), -s);
+  return a + tmp;
+}
+
+// scalar by diagonal matrix -> matrix operations
+
+ComplexMatrix
+operator + (const Complex& s, const DiagMatrix& a)
+{
+  ComplexMatrix tmp (a.rows (), a.cols (), s);
+  return tmp + a;
+}
+
+ComplexMatrix
+operator - (const Complex& s, const DiagMatrix& a)
+{
+  ComplexMatrix tmp (a.rows (), a.cols (), s);
+  return tmp - a;
+}
+
+ComplexMatrix
+operator + (double s, const ComplexDiagMatrix& a)
+{
+  ComplexMatrix tmp (a.rows (), a.cols (), s);
+  return tmp + a;
+}
+
+ComplexMatrix
+operator - (double s, const ComplexDiagMatrix& a)
+{
+  ComplexMatrix tmp (a.rows (), a.cols (), s);
+  return tmp - a;
+}
+
+ComplexMatrix
+operator + (const Complex& s, const ComplexDiagMatrix& a)
+{
+  ComplexMatrix tmp (a.rows (), a.cols (), s);
+  return tmp + a;
+}
+
+ComplexMatrix
+operator - (const Complex& s, const ComplexDiagMatrix& a)
+{
+  ComplexMatrix tmp (a.rows (), a.cols (), s);
+  return tmp - a;
+}
+
 // matrix by diagonal matrix -> matrix operations
 
 ComplexMatrix&
 ComplexMatrix::operator += (const DiagMatrix& a)
 {
   int nr = rows ();
   int nc = cols ();
   if (nr != a.rows () || nc != a.cols ())
@@ -1587,16 +1585,388 @@ ComplexMatrix::operator -= (const Comple
     }
 
   for (int i = 0; i < a.length (); i++)
     elem (i, i) -= a.elem (i, i);
 
   return *this;
 }
 
+ComplexMatrix
+operator + (const Matrix& m, const ComplexDiagMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return ComplexMatrix ();
+    }
+
+  if (nr == 0 || nc == 0)
+    return ComplexMatrix (nr, nc);
+
+  ComplexMatrix result (m);
+  for (int i = 0; i < a.length (); i++)
+    result.elem (i, i) += a.elem (i, i);
+
+  return result;
+}
+
+ComplexMatrix
+operator - (const Matrix& m, const ComplexDiagMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return ComplexMatrix ();
+    }
+
+  if (nr == 0 || nc == 0)
+    return ComplexMatrix (nr, nc);
+
+  ComplexMatrix result (m);
+  for (int i = 0; i < a.length (); i++)
+    result.elem (i, i) -= a.elem (i, i);
+
+  return result;
+}
+
+ComplexMatrix
+operator * (const Matrix& m, const ComplexDiagMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  if (nc != a_nr)
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return ComplexMatrix ();
+    }
+
+  if (nr == 0 || nc == 0 || a_nc == 0)
+    return ComplexMatrix (nr, a_nc, 0.0);
+
+  Complex *c = new Complex [nr*a_nc];
+  Complex *ctmp = 0;
+
+  for (int j = 0; j < a.length (); j++)
+    {
+      int idx = j * nr;
+      ctmp = c + idx;
+      if (a.elem (j, j) == 1.0)
+	{
+	  for (int i = 0; i < nr; i++)
+	    ctmp[i] = m.elem (i, j);
+	}
+      else if (a.elem (j, j) == 0.0)
+	{
+	  for (int i = 0; i < nr; i++)
+	    ctmp[i] = 0.0;
+	}
+      else
+	{
+	  for (int i = 0; i < nr; i++)
+	    ctmp[i] = a.elem (j, j) * m.elem (i, j);
+	}
+    }
+
+  if (a_nr < a_nc)
+    {
+      for (int i = nr * nc; i < nr * a_nc; i++)
+	ctmp[i] = 0.0;
+    }
+
+  return ComplexMatrix (c, nr, a_nc);
+}
+
+// diagonal matrix by matrix -> matrix operations
+
+ComplexMatrix
+operator + (const DiagMatrix& m, const ComplexMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return ComplexMatrix ();
+    }
+
+  if (nr == 0 || nc == 0)
+    return ComplexMatrix (nr, nc);
+
+  ComplexMatrix result (a);
+  for (int i = 0; i < m.length (); i++)
+    result.elem (i, i) += m.elem (i, i);
+
+  return result;
+}
+
+ComplexMatrix
+operator - (const DiagMatrix& m, const ComplexMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return ComplexMatrix ();
+    }
+
+  if (nr == 0 || nc == 0)
+    return ComplexMatrix (nr, nc);
+
+  ComplexMatrix result (-a);
+  for (int i = 0; i < m.length (); i++)
+    result.elem (i, i) += m.elem (i, i);
+
+  return result;
+}
+
+ComplexMatrix
+operator * (const DiagMatrix& m, const ComplexMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  if (nc != a_nr)
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return ComplexMatrix ();
+    }
+
+  if (nr == 0 || nc == 0 || a_nc == 0)
+    return ComplexMatrix (nr, nc, 0.0);
+
+  ComplexMatrix c (nr, a_nc);
+
+  for (int i = 0; i < m.length (); i++)
+    {
+      if (m.elem (i, i) == 1.0)
+	{
+	  for (int j = 0; j < a_nc; j++)
+	    c.elem (i, j) = a.elem (i, j);
+	}
+      else if (m.elem (i, i) == 0.0)
+	{
+	  for (int j = 0; j < a_nc; j++)
+	    c.elem (i, j) = 0.0;
+	}
+      else
+	{
+	  for (int j = 0; j < a_nc; j++)
+	    c.elem (i, j) = m.elem (i, i) * a.elem (i, j);
+	}
+    }
+
+  if (nr > nc)
+    {
+      for (int j = 0; j < a_nc; j++)
+	for (int i = a_nr; i < nr; i++)
+	  c.elem (i, j) = 0.0;
+    }
+
+  return c;
+}
+
+ComplexMatrix
+operator + (const ComplexDiagMatrix& m, const Matrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return ComplexMatrix ();
+    }
+
+  if (nr == 0 || nc == 0)
+    return ComplexMatrix (nr, nc);
+
+  ComplexMatrix result (a);
+  for (int i = 0; i < m.length (); i++)
+    result.elem (i, i) += m.elem (i, i);
+
+  return result;
+}
+
+ComplexMatrix
+operator - (const ComplexDiagMatrix& m, const Matrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return ComplexMatrix ();
+    }
+
+  if (nr == 0 || nc == 0)
+    return ComplexMatrix (nr, nc);
+
+  ComplexMatrix result (-a);
+  for (int i = 0; i < m.length (); i++)
+    result.elem (i, i) += m.elem (i, i);
+
+  return result;
+}
+
+ComplexMatrix
+operator * (const ComplexDiagMatrix& m, const Matrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  if (nc != a_nr)
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return ComplexMatrix ();
+    }
+
+  if (nr == 0 || nc == 0 || a_nc == 0)
+    return ComplexMatrix (nr, a_nc, 0.0);
+
+  ComplexMatrix c (nr, a_nc);
+
+  for (int i = 0; i < m.length (); i++)
+    {
+      if (m.elem (i, i) == 1.0)
+	{
+	  for (int j = 0; j < a_nc; j++)
+	    c.elem (i, j) = a.elem (i, j);
+	}
+      else if (m.elem (i, i) == 0.0)
+	{
+	  for (int j = 0; j < a_nc; j++)
+	    c.elem (i, j) = 0.0;
+	}
+      else
+	{
+	  for (int j = 0; j < a_nc; j++)
+	    c.elem (i, j) = m.elem (i, i) * a.elem (i, j);
+	}
+    }
+
+  if (nr > nc)
+    {
+      for (int j = 0; j < a_nc; j++)
+	for (int i = a_nr; i < nr; i++)
+	  c.elem (i, j) = 0.0;
+    }
+
+  return c;
+}
+
+ComplexMatrix
+operator + (const ComplexDiagMatrix& m, const ComplexMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return ComplexMatrix ();
+    }
+
+  if (nr == 0 || nc == 0)
+    return ComplexMatrix (nr, nc);
+
+  ComplexMatrix result (a);
+  for (int i = 0; i < m.length (); i++)
+    result.elem (i, i) += m.elem (i, i);
+
+  return result;
+}
+
+ComplexMatrix
+operator - (const ComplexDiagMatrix& m, const ComplexMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return ComplexMatrix ();
+    }
+
+  if (nr == 0 || nc == 0)
+    return ComplexMatrix (nr, nc);
+
+  ComplexMatrix result (-a);
+  for (int i = 0; i < m.length (); i++)
+    result.elem (i, i) += m.elem (i, i);
+
+  return result;
+}
+
+ComplexMatrix
+operator * (const ComplexDiagMatrix& m, const ComplexMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_nr = a.rows ();
+  int a_nc = a.cols ();
+  if (nc != a_nr)
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return ComplexMatrix ();
+    }
+
+  if (nr == 0 || nc == 0 || a_nc == 0)
+    return ComplexMatrix (nr, a_nc, 0.0);
+
+  ComplexMatrix c (nr, a_nc);
+
+  for (int i = 0; i < m.length (); i++)
+    {
+      if (m.elem (i, i) == 1.0)
+	{
+	  for (int j = 0; j < a_nc; j++)
+	    c.elem (i, j) = a.elem (i, j);
+	}
+      else if (m.elem (i, i) == 0.0)
+	{
+	  for (int j = 0; j < a_nc; j++)
+	    c.elem (i, j) = 0.0;
+	}
+      else
+	{
+	  for (int j = 0; j < a_nc; j++)
+	    c.elem (i, j) = m.elem (i, i) * a.elem (i, j);
+	}
+    }
+
+  if (nr > nc)
+    {
+      for (int j = 0; j < a_nc; j++)
+	for (int i = a_nr; i < nr; i++)
+	  c.elem (i, j) = 0.0;
+    }
+
+  return c;
+}
+
 // matrix by matrix -> matrix operations
 
 ComplexMatrix&
 ComplexMatrix::operator += (const Matrix& a)
 {
   int nr = rows ();
   int nc = cols ();
   if (nr != a.rows () || nc != a.cols ())
@@ -1684,16 +2054,44 @@ Matrix
 ComplexMatrix::operator ! (void) const
 {
   return Matrix (not (data (), length ()), rows (), cols ());
 }
 
 // matrix by scalar -> matrix operations
 
 ComplexMatrix
+operator + (const Matrix& a, const Complex& s)
+{
+  return ComplexMatrix (add (a.data (), a.length (), s),
+			a.rows (), a.cols ());
+}
+
+ComplexMatrix
+operator - (const Matrix& a, const Complex& s)
+{
+  return ComplexMatrix (subtract (a.data (), a.length (), s),
+			a.rows (), a.cols ());
+}
+
+ComplexMatrix
+operator * (const Matrix& a, const Complex& s)
+{
+  return ComplexMatrix (multiply (a.data (), a.length (), s),
+			a.rows (), a.cols ());
+}
+
+ComplexMatrix
+operator / (const Matrix& a, const Complex& s)
+{
+  return ComplexMatrix (divide (a.data (), a.length (), s),
+			a.rows (), a.cols ());
+}
+
+ComplexMatrix
 operator + (const ComplexMatrix& a, double s)
 {
   return ComplexMatrix (add (a.data (), a.length (), s),
 			a.rows (), a.cols ());
 }
 
 ComplexMatrix
 operator - (const ComplexMatrix& a, double s)
@@ -1741,52 +2139,42 @@ operator * (double s, const ComplexMatri
 
 ComplexMatrix
 operator / (double s, const ComplexMatrix& a)
 {
   return ComplexMatrix (divide (s, a.data (), a.length ()),
 			a.rows (), a.cols ());
 }
 
-// matrix by column vector -> column vector operations
-
-ComplexColumnVector
-operator * (const ComplexMatrix& m, const ColumnVector& a)
+ComplexMatrix
+operator + (const Complex& s, const Matrix& a)
 {
-  ComplexColumnVector tmp (a);
-  return m * tmp;
+  return ComplexMatrix (add (s, a.data (), a.length ()),
+			a.rows (), a.cols ());
 }
 
-ComplexColumnVector
-operator * (const ComplexMatrix& m, const ComplexColumnVector& a)
+ComplexMatrix
+operator - (const Complex& s, const Matrix& a)
 {
-  int nr = m.rows ();
-  int nc = m.cols ();
-  if (nc != a.length ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix multiplication attempted");
-      return ComplexColumnVector ();
-    }
-
-  if (nc == 0 || nr == 0)
-    return ComplexColumnVector (0);
-
-  char trans = 'N';
-  int ld = nr;
-  Complex alpha (1.0);
-  Complex beta (0.0);
-  int i_one = 1;
-
-  Complex *y = new Complex [nr];
-
-  F77_FCN (zgemv) (&trans, &nr, &nc, &alpha, m.data (), &ld, a.data (),
-		   &i_one, &beta, y, &i_one, 1L); 
-
-  return ComplexColumnVector (y, nr);
+  return ComplexMatrix (subtract (s, a.data (), a.length ()),
+			a.rows (), a.cols ());
+}
+
+ComplexMatrix
+operator * (const Complex& s, const Matrix& a)
+{
+  return ComplexMatrix (multiply (a.data (), a.length (), s),
+			a.rows (), a.cols ());
+}
+
+ComplexMatrix
+operator / (const Complex& s, const Matrix& a)
+{
+  return ComplexMatrix (divide (s, a.data (), a.length ()),
+			a.rows (), a.cols ());
 }
 
 // matrix by diagonal matrix -> matrix operations
 
 ComplexMatrix
 operator + (const ComplexMatrix& m, const DiagMatrix& a)
 {
   int nr = m.rows ();
@@ -2006,23 +2394,63 @@ operator - (const ComplexMatrix& m, cons
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   return ComplexMatrix (subtract (m.data (), a.data (), m.length ()), nr, nc);
 }
 
 ComplexMatrix
+operator + (const Matrix& m, const ComplexMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return ComplexMatrix ();
+    }
+
+  return ComplexMatrix (add (m.data (), a.data (), m.length ()), nr, nc);
+}
+
+ComplexMatrix
+operator - (const Matrix& m, const ComplexMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return ComplexMatrix ();
+    }
+
+  if (nr == 0 || nc == 0)
+    return ComplexMatrix (nr, nc);
+
+  return ComplexMatrix (subtract (m.data (), a.data (), m.length ()), nr, nc);
+}
+
+ComplexMatrix
 operator * (const ComplexMatrix& m, const Matrix& a)
 {
   ComplexMatrix tmp (a);
   return m * tmp;
 }
 
 ComplexMatrix
+operator * (const Matrix& m, const ComplexMatrix& a)
+{
+  ComplexMatrix tmp (m);
+  return tmp * a;
+}
+
+ComplexMatrix
 operator * (const ComplexMatrix& m, const ComplexMatrix& a)
 {
   int nr = m.rows ();
   int nc = m.cols ();
   int a_nc = a.cols ();
   if (nc != a.rows ())
     {
       (*current_liboctave_error_handler)
@@ -2081,38 +2509,62 @@ quotient (const ComplexMatrix& m, const 
     }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   return ComplexMatrix (divide (m.data (), a.data (), m.length ()), nr, nc);
 }
 
+ComplexMatrix
+product (const Matrix& m, const ComplexMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix product attempted");
+      return ComplexMatrix ();
+    }
+
+  if (nr == 0 || nc == 0)
+    return ComplexMatrix (nr, nc);
+
+  return ComplexMatrix (multiply (m.data (), a.data (), m.length ()), nr, nc);
+}
+
+ComplexMatrix
+quotient (const Matrix& m, const ComplexMatrix& a)
+{
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nr != a.rows () || nc != a.cols ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix quotient attempted");
+      return ComplexMatrix ();
+    }
+
+  if (nr == 0 || nc == 0)
+    return ComplexMatrix (nr, nc);
+
+  return ComplexMatrix (divide (m.data (), a.data (), m.length ()), nr, nc);
+}
+
 // other operations
 
 ComplexMatrix
 map (c_c_Mapper f, const ComplexMatrix& a)
 {
   ComplexMatrix b (a);
   b.map (f);
   return b;
 }
 
-Matrix
-map (d_c_Mapper f, const ComplexMatrix& a)
-{
-  int a_nc = a.cols ();
-  int a_nr = a.rows ();
-  Matrix b (a_nr, a_nc);
-  for (int j = 0; j < a_nc; j++)
-    for (int i = 0; i < a_nr; i++)
-      b.elem (i, j) = f (a.elem (i, j));
-  return b;
-}
-
 void
 ComplexMatrix::map (c_c_Mapper f)
 {
   for (int j = 0; j < cols (); j++)
     for (int i = 0; i < rows (); i++)
       elem (i, j) = f (elem (i, j));
 }
 
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -29,49 +29,44 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "Array.h"
 
 #include "mx-defs.h"
 
 extern "C++" {
 
 class ComplexMatrix : public Array2<Complex>
 {
+friend class Matrix;
 friend class ComplexCHOL;
 friend class ComplexHESS;
 friend class ComplexLU;
 friend class ComplexQR;
 friend class ComplexQRP;
 friend class ComplexSCHUR;
 friend class ComplexSVD;
-friend class ComplexColumnVector;
-friend class Matrix;
 
 public:
  
   ComplexMatrix (void) : Array2<Complex> () { }
   ComplexMatrix (int r, int c) : Array2<Complex> (r, c) { }
   ComplexMatrix (int r, int c, const Complex& val)
     : Array2<Complex> (r, c, val) { }
   ComplexMatrix (const Matrix& a);
   ComplexMatrix (const Array2<Complex>& a) : Array2<Complex> (a) { }
   ComplexMatrix (const ComplexMatrix& a) : Array2<Complex> (a) { }
   ComplexMatrix (const DiagMatrix& a);
   ComplexMatrix (const DiagArray<Complex>& a) : Array2<Complex> (a) { }
   ComplexMatrix (const ComplexDiagMatrix& a);
-//  ComplexMatrix (double a) : Array2<Complex> (1, 1, a) { }
-//  ComplexMatrix (const Complex& a) : Array2<Complex> (1, 1, a) { }
 
   ComplexMatrix& operator = (const ComplexMatrix& a)
     {
       Array2<Complex>::operator = (a);
       return *this;
     }
 
-//  operator Array2<Complex>& () const { return *this; }
-
   int operator == (const ComplexMatrix& a) const;
   int operator != (const ComplexMatrix& a) const;
 
 // destructive insert/delete/reorder operations
 
   ComplexMatrix& insert (const Matrix& a, int r, int c);
   ComplexMatrix& insert (const RowVector& a, int r, int c);
   ComplexMatrix& insert (const ColumnVector& a, int r, int c);
@@ -105,18 +100,16 @@ public:
   ComplexMatrix stack (const ComplexMatrix& a) const;
   ComplexMatrix stack (const ComplexRowVector& a) const;
   ComplexMatrix stack (const ComplexColumnVector& a) const;
   ComplexMatrix stack (const ComplexDiagMatrix& a) const;
 
   ComplexMatrix hermitian (void) const;  // complex conjugate transpose
   ComplexMatrix transpose (void) const;
 
-  friend Matrix real (const ComplexMatrix& a);
-  friend Matrix imag (const ComplexMatrix& a);
   friend ComplexMatrix conj (const ComplexMatrix& a);
 
 // resize is the destructive equivalent for this one
 
   ComplexMatrix extract (int r1, int c1, int r2, int c2) const;
 
 // extract row or column i.
 
@@ -160,57 +153,126 @@ public:
   ComplexMatrix lssolve (const ComplexMatrix& b, int& info,
 			 int& rank) const;
 
   ComplexColumnVector lssolve (const ComplexColumnVector& b) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b, int& info) const;
   ComplexColumnVector lssolve (const ComplexColumnVector& b, int& info,
 			       int& rank) const;
 
+// column vector by row vector -> matrix operations
+
+  friend ComplexMatrix operator * (const ColumnVector& a,
+				   const ComplexRowVector& b);
+
+  friend ComplexMatrix operator * (const ComplexColumnVector& a,
+				   const RowVector& b);
+
+  friend ComplexMatrix operator * (const ComplexColumnVector& a,
+				   const ComplexRowVector& b);
+
+// diagonal matrix by scalar -> matrix operations
+
+  friend ComplexMatrix operator + (const DiagMatrix& a, const Complex& s);
+  friend ComplexMatrix operator - (const DiagMatrix& a, const Complex& s);
+
+  friend ComplexMatrix operator + (const ComplexDiagMatrix& a, double s);
+  friend ComplexMatrix operator - (const ComplexDiagMatrix& a, double s);
+
+  friend ComplexMatrix operator + (const ComplexDiagMatrix& a,
+				   const Complex& s);
+  friend ComplexMatrix operator - (const ComplexDiagMatrix& a,
+				   const Complex& s);
+
+// scalar by diagonal matrix -> matrix operations
+
+  friend ComplexMatrix operator + (const Complex& s, const DiagMatrix& a);
+  friend ComplexMatrix operator - (const Complex& s, const DiagMatrix& a);
+
+  friend ComplexMatrix operator + (double s, const ComplexDiagMatrix& a);
+  friend ComplexMatrix operator - (double s, const ComplexDiagMatrix& a);
+
+  friend ComplexMatrix operator + (const Complex& s,
+				   const ComplexDiagMatrix& a);
+  friend ComplexMatrix operator - (const Complex& s,
+				   const ComplexDiagMatrix& a);
+
 // matrix by diagonal matrix -> matrix operations
 
   ComplexMatrix& operator += (const DiagMatrix& a);
   ComplexMatrix& operator -= (const DiagMatrix& a);
 
   ComplexMatrix& operator += (const ComplexDiagMatrix& a);
   ComplexMatrix& operator -= (const ComplexDiagMatrix& a);
 
+  friend ComplexMatrix operator + (const Matrix& a,
+				   const ComplexDiagMatrix& b); 
+  friend ComplexMatrix operator - (const Matrix& a,
+				   const ComplexDiagMatrix& b);
+  friend ComplexMatrix operator * (const Matrix& a,
+				   const ComplexDiagMatrix& b);
+
+// diagonal matrix by matrix -> matrix operations
+
+  friend ComplexMatrix operator + (const DiagMatrix& a,
+				   const ComplexMatrix& b);
+  friend ComplexMatrix operator - (const DiagMatrix& a,
+				   const ComplexMatrix& b);
+  friend ComplexMatrix operator * (const DiagMatrix& a,
+				   const ComplexMatrix& b);
+
+  friend ComplexMatrix operator + (const ComplexDiagMatrix& a,
+				   const Matrix& b); 
+  friend ComplexMatrix operator - (const ComplexDiagMatrix& a,
+				   const Matrix& b);
+  friend ComplexMatrix operator * (const ComplexDiagMatrix& a,
+				   const Matrix& b);
+
+  friend ComplexMatrix operator + (const ComplexDiagMatrix& a,
+				   const ComplexMatrix& b);
+  friend ComplexMatrix operator - (const ComplexDiagMatrix& a,
+				   const ComplexMatrix& b);
+  friend ComplexMatrix operator * (const ComplexDiagMatrix& a,
+				   const ComplexMatrix& b);
+
 // matrix by matrix -> matrix operations
 
   ComplexMatrix& operator += (const Matrix& a);
   ComplexMatrix& operator -= (const Matrix& a);
 
   ComplexMatrix& operator += (const ComplexMatrix& a);
   ComplexMatrix& operator -= (const ComplexMatrix& a);
 
 // unary operations
 
   Matrix operator ! (void) const;
 
 // matrix by scalar -> matrix operations
 
+  friend ComplexMatrix operator + (const Matrix& a, const Complex& s);
+  friend ComplexMatrix operator - (const Matrix& a, const Complex& s);
+  friend ComplexMatrix operator * (const Matrix& a, const Complex& s);
+  friend ComplexMatrix operator / (const Matrix& a, const Complex& s);
+
   friend ComplexMatrix operator + (const ComplexMatrix& a, double s);
   friend ComplexMatrix operator - (const ComplexMatrix& a, double s);
   friend ComplexMatrix operator * (const ComplexMatrix& a, double s);
   friend ComplexMatrix operator / (const ComplexMatrix& a, double s);
 
 // scalar by matrix -> matrix operations
 
   friend ComplexMatrix operator + (double s, const ComplexMatrix& a);
   friend ComplexMatrix operator - (double s, const ComplexMatrix& a);
   friend ComplexMatrix operator * (double s, const ComplexMatrix& a);
   friend ComplexMatrix operator / (double s, const ComplexMatrix& a);
 
-// matrix by column vector -> column vector operations
-
-  friend ComplexColumnVector operator * (const ComplexMatrix& a,
-					 const ColumnVector& b);
-
-  friend ComplexColumnVector operator * (const ComplexMatrix& a,
-					 const ComplexColumnVector& b);
+  friend ComplexMatrix operator + (const Complex& s, const Matrix& a);
+  friend ComplexMatrix operator - (const Complex& s, const Matrix& a);
+  friend ComplexMatrix operator * (const Complex& s, const Matrix& a);
+  friend ComplexMatrix operator / (const Complex& s, const Matrix& a);
 
 // matrix by diagonal matrix -> matrix operations
 
   friend ComplexMatrix operator + (const ComplexMatrix& a,
 				   const DiagMatrix& b);
   friend ComplexMatrix operator - (const ComplexMatrix& a,
 				   const DiagMatrix& b);
   friend ComplexMatrix operator * (const ComplexMatrix& a,
@@ -223,27 +285,35 @@ public:
   friend ComplexMatrix operator * (const ComplexMatrix& a,
 				   const ComplexDiagMatrix& b);
 
 // matrix by matrix -> matrix operations
 
   friend ComplexMatrix operator + (const ComplexMatrix& a, const Matrix& b);
   friend ComplexMatrix operator - (const ComplexMatrix& a, const Matrix& b);
 
+  friend ComplexMatrix operator + (const Matrix& a, const ComplexMatrix& b);
+  friend ComplexMatrix operator - (const Matrix& a, const ComplexMatrix& b);
+
   friend ComplexMatrix operator * (const ComplexMatrix& a, const Matrix& b);
+
+  friend ComplexMatrix operator * (const Matrix& a, const ComplexMatrix& b);
+
   friend ComplexMatrix operator * (const ComplexMatrix& a,
 				   const ComplexMatrix& b);
 
   friend ComplexMatrix product (const ComplexMatrix& a, const Matrix& b);
   friend ComplexMatrix quotient (const ComplexMatrix& a, const Matrix& b);
 
+  friend ComplexMatrix product (const Matrix& a, const ComplexMatrix& b);
+  friend ComplexMatrix quotient (const Matrix& a, const ComplexMatrix& b);
+
 // other operations
 
   friend ComplexMatrix map (c_c_Mapper f, const ComplexMatrix& a);
-  friend Matrix map (d_c_Mapper f, const ComplexMatrix& a);
   void map (c_c_Mapper f);
 
   Matrix all (void) const;
   Matrix any (void) const;
 
   ComplexMatrix cumprod (void) const;
   ComplexMatrix cumsum (void) const;
   ComplexMatrix prod (void) const;
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -58,67 +58,16 @@ extern "C"
 
 ComplexRowVector::ComplexRowVector (const RowVector& a)
   : Array<Complex> (a.length ())
 {
   for (int i = 0; i < length (); i++)
     elem (i) = a.elem (i);
 }
 
-#if 0
-ComplexRowVector&
-ComplexRowVector::resize (int n)
-{
-  if (n < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't resize to negative dimension");
-      return *this;
-    }
-
-  Complex *new_data = 0;
-  if (n > 0)
-    {
-      new_data = new Complex [n];
-      int min_len = len < n ? len : n;
-
-      for (int i = 0; i < min_len; i++)
-	new_data[i] = data[i];
-    }
-
-  delete [] data;
-  len = n;
-  data = new_data;
-
-  return *this;
-}
-
-ComplexRowVector&
-ComplexRowVector::resize (int n, double val)
-{
-  int old_len = len;
-  resize (n);
-  for (int i = old_len; i < len; i++)
-    data[i] = val;
-
-  return *this;
-}
-
-ComplexRowVector&
-ComplexRowVector::resize (int n, const Complex& val)
-{
-  int old_len = len;
-  resize (n);
-  for (int i = old_len; i < len; i++)
-    data[i] = val;
-
-  return *this;
-}
-#endif
-
 int
 ComplexRowVector::operator == (const ComplexRowVector& a) const
 {
   int len = length ();
   if (len != a.length ())
     return 0;
   return equal (data (), a.data (), len);
 }
@@ -250,36 +199,16 @@ ComplexRowVector::hermitian (void) const
 
 ComplexColumnVector
 ComplexRowVector::transpose (void) const
 {
   int len = length ();
   return ComplexColumnVector (dup (data (), len), len);
 }
 
-RowVector
-real (const ComplexRowVector& a)
-{
-  int a_len = a.length ();
-  RowVector retval;
-  if (a_len > 0)
-    retval = RowVector (real_dup (a.data (), a_len), a_len);
-  return retval;
-}
-
-RowVector
-imag (const ComplexRowVector& a)
-{
-  int a_len = a.length ();
-  RowVector retval;
-  if (a_len > 0)
-    retval = RowVector (imag_dup (a.data (), a_len), a_len);
-  return retval;
-}
-
 ComplexRowVector
 conj (const ComplexRowVector& a)
 {
   int a_len = a.length ();
   ComplexRowVector retval;
   if (a_len > 0)
     retval = ComplexRowVector (conj_dup (a.data (), a_len), a_len);
   return retval;
@@ -409,16 +338,44 @@ operator * (const ComplexRowVector& v, d
 
 ComplexRowVector
 operator / (const ComplexRowVector& v, double s)
 {
   int len = v.length ();
   return ComplexRowVector (divide (v.data (), len, s), len);
 }
 
+ComplexRowVector
+operator + (const RowVector& v, const Complex& s)
+{
+  int len = v.length ();
+  return ComplexRowVector (add (v.data (), len, s), len);
+}
+
+ComplexRowVector
+operator - (const RowVector& v, const Complex& s)
+{
+  int len = v.length ();
+  return ComplexRowVector (subtract (v.data (), len, s), len);
+}
+
+ComplexRowVector
+operator * (const RowVector& v, const Complex& s)
+{
+  int len = v.length ();
+  return ComplexRowVector (multiply (v.data (), len, s), len);
+}
+
+ComplexRowVector
+operator / (const RowVector& v, const Complex& s)
+{
+  int len = v.length ();
+  return ComplexRowVector (divide (v.data (), len, s), len);
+}
+
 // scalar by row vector -> row vector operations
 
 ComplexRowVector
 operator + (double s, const ComplexRowVector& a)
 {
   int a_len = a.length ();
   return ComplexRowVector (add (a.data (), a_len, s), a_len);
 }
@@ -439,42 +396,38 @@ operator * (double s, const ComplexRowVe
 
 ComplexRowVector
 operator / (double s, const ComplexRowVector& a)
 {
   int a_len = a.length ();
   return ComplexRowVector (divide (s, a.data (), a_len), a_len);
 }
 
-// row vector by column vector -> scalar
-
-Complex
-operator * (const ComplexRowVector& v, const ColumnVector& a)
+ComplexRowVector
+operator + (const Complex& s, const RowVector& a)
 {
-  ComplexColumnVector tmp (a);
-  return v * tmp;
+  return ComplexRowVector ();
 }
 
-Complex
-operator * (const ComplexRowVector& v, const ComplexColumnVector& a)
+ComplexRowVector
+operator - (const Complex& s, const RowVector& a)
 {
-  int len = v.length ();
-  if (len != a.length ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector multiplication attempted");
-      return 0.0;
-    }
+  return ComplexRowVector ();
+}
 
-  Complex retval (0.0, 0.0);
+ComplexRowVector
+operator * (const Complex& s, const RowVector& a)
+{
+  return ComplexRowVector ();
+}
 
-  for (int i = 0; i < len; i++)
-    retval += v.elem (i) * a.elem (i);
-
-  return retval;
+ComplexRowVector
+operator / (const Complex& s, const RowVector& a)
+{
+  return ComplexRowVector ();
 }
 
 // row vector by matrix -> row vector
 
 ComplexRowVector
 operator * (const ComplexRowVector& v, const ComplexMatrix& a)
 {
   int len = v.length ();
@@ -502,16 +455,23 @@ operator * (const ComplexRowVector& v, c
   Complex *y = new Complex [len];
 
   F77_FCN (zgemv) (&trans, &a_nc, &a_nr, &alpha, a.data (), &ld,
 		   v.data (), &i_one, &beta, y, &i_one, 1L); 
 
   return ComplexRowVector (y, len);
 }
 
+ComplexRowVector
+operator * (const RowVector& v, const ComplexMatrix& a)
+{
+  ComplexRowVector tmp (v);
+  return tmp * a;
+}
+
 // row vector by row vector -> row vector operations
 
 ComplexRowVector
 operator + (const ComplexRowVector& v, const RowVector& a)
 {
   int len = v.length ();
   if (len != a.length ())
     {
@@ -539,16 +499,50 @@ operator - (const ComplexRowVector& v, c
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (subtract (v.data (), a.data (), len), len);
 }
 
 ComplexRowVector
+operator + (const RowVector& v, const ComplexRowVector& a)
+{
+  int len = v.length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector addition attempted");
+      return ComplexRowVector ();
+    }
+
+  if (len == 0)
+    return ComplexRowVector (0);
+
+  return ComplexRowVector (add (v.data (), a.data (), len), len);
+}
+
+ComplexRowVector
+operator - (const RowVector& v, const ComplexRowVector& a)
+{
+  int len = v.length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector subtraction attempted");
+      return ComplexRowVector ();
+    }
+
+  if (len == 0)
+    return ComplexRowVector (0);
+
+  return ComplexRowVector (subtract (v.data (), a.data (), len), len);
+}
+
+ComplexRowVector
 product (const ComplexRowVector& v, const RowVector& a)
 {
   int len = v.length ();
   if (len != a.length ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant vector product attempted");
       return ComplexRowVector ();
@@ -572,61 +566,67 @@ quotient (const ComplexRowVector& v, con
     }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (divide (v.data (), a.data (), len), len);
 }
 
+ComplexRowVector
+product (const RowVector& v, const ComplexRowVector& a)
+{
+  int len = v.length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector product attempted");
+      return ComplexRowVector ();
+    }
+
+  if (len == 0)
+    return ComplexRowVector (0);
+
+  return ComplexRowVector (multiply (v.data (), a.data (), len), len);
+}
+
+ComplexRowVector
+quotient (const RowVector& v, const ComplexRowVector& a)
+{
+  int len = v.length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector quotient attempted");
+      return ComplexRowVector ();
+    }
+
+  if (len == 0)
+    return ComplexRowVector (0);
+
+  return ComplexRowVector (divide (v.data (), a.data (), len), len);
+}
+
 // other operations
 
 ComplexRowVector
 map (c_c_Mapper f, const ComplexRowVector& a)
 {
   ComplexRowVector b (a);
   b.map (f);
   return b;
 }
 
-RowVector
-map (d_c_Mapper f, const ComplexRowVector& a)
-{
-  int a_len = a.length ();
-  RowVector b (a_len);
-  for (int i = 0; i < a_len; i++)
-    b.elem (i) = f (a.elem (i));
-  return b;
-}
-
 void
 ComplexRowVector::map (c_c_Mapper f)
 {
   for (int i = 0; i < length (); i++)
     elem (i) = f (elem (i));
 }
 
-ComplexRowVector
-linspace (const Complex& x1, const Complex& x2, int n)
-{
-  ComplexRowVector retval;
-
-  if (n > 0)
-    {
-      retval.resize (n);
-      Complex delta = (x2 - x1) / (n - 1);
-      retval.elem (0) = x1;
-      for (int i = 1; i < n-1; i++)
-	retval.elem (i) = x1 + i * delta;
-      retval.elem (n-1) = x2;
-    }
-
-  return retval;
-}
-
 Complex
 ComplexRowVector::min (void) const
 {
   int len = length ();
   if (len == 0)
     return Complex (0.0);
 
   Complex res = elem (0);
@@ -690,14 +690,64 @@ operator >> (istream& is, ComplexRowVect
             a.elem (i) = tmp;
           else
             break;
         }
     }
   return is;
 }
 
+// row vector by column vector -> scalar
+
+// row vector by column vector -> scalar
+
+Complex
+operator * (const ComplexRowVector& v, const ColumnVector& a)
+{
+  ComplexColumnVector tmp (a);
+  return v * tmp;
+}
+
+Complex
+operator * (const ComplexRowVector& v, const ComplexColumnVector& a)
+{
+  int len = v.length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector multiplication attempted");
+      return 0.0;
+    }
+
+  Complex retval (0.0, 0.0);
+
+  for (int i = 0; i < len; i++)
+    retval += v.elem (i) * a.elem (i);
+
+  return retval;
+}
+
+// other operations
+
+ComplexRowVector
+linspace (const Complex& x1, const Complex& x2, int n)
+{
+  ComplexRowVector retval;
+
+  if (n > 0)
+    {
+      retval.resize (n);
+      Complex delta = (x2 - x1) / (n - 1);
+      retval.elem (0) = x1;
+      for (int i = 1; i < n-1; i++)
+	retval.elem (i) = x1 + i * delta;
+      retval.elem (n-1) = x2;
+    }
+
+  return retval;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/CRowVector.h b/liboctave/CRowVector.h
--- a/liboctave/CRowVector.h
+++ b/liboctave/CRowVector.h
@@ -28,37 +28,32 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "mx-defs.h"
 
 extern "C++" {
 
 class ComplexRowVector : public Array<Complex>
 {
 friend class ComplexColumnVector;
-friend class RowVector;
 
 public:
 
   ComplexRowVector (void) : Array<Complex> () { }
   ComplexRowVector (int n) : Array<Complex> (n) { }
   ComplexRowVector (int n, const Complex& val) : Array<Complex> (n, val) { }
   ComplexRowVector (const RowVector& a);
   ComplexRowVector (const Array<Complex>& a) : Array<Complex> (a) { }
   ComplexRowVector (const ComplexRowVector& a) : Array<Complex> (a) { }
-//  ComplexRowVector (double a) : Array<Complex> (1, a) { }
-//  ComplexRowVector (const Complex& a) : Array<Complex> (1, a) { }
 
   ComplexRowVector& operator = (const ComplexRowVector& a)
     {
       Array<Complex>::operator = (a);
       return *this;
     }
 
-//  operator Array<Complex>& () const { return *this; }
-
   int operator == (const ComplexRowVector& a) const;
   int operator != (const ComplexRowVector& a) const;
 
 // destructive insert/delete/reorder operations
 
   ComplexRowVector& insert (const RowVector& a, int c);
   ComplexRowVector& insert (const ComplexRowVector& a, int c);
 
@@ -68,18 +63,16 @@ public:
   ComplexRowVector& fill (const Complex& val, int c1, int c2);
 
   ComplexRowVector append (const RowVector& a) const;
   ComplexRowVector append (const ComplexRowVector& a) const;
 
   ComplexColumnVector hermitian (void) const;  // complex conjugate transpose.
   ComplexColumnVector transpose (void) const;
 
-  friend RowVector real (const ComplexRowVector& a);
-  friend RowVector imag (const ComplexRowVector& a);
   friend ComplexRowVector conj (const ComplexRowVector& a);
 
 // resize is the destructive equivalent for this one
 
   ComplexRowVector extract (int c1, int c2) const;
 
 // row vector by row vector -> row vector operations
 
@@ -91,51 +84,66 @@ public:
 
 // row vector by scalar -> row vector operations
 
   friend ComplexRowVector operator + (const ComplexRowVector& a, double s);
   friend ComplexRowVector operator - (const ComplexRowVector& a, double s);
   friend ComplexRowVector operator * (const ComplexRowVector& a, double s);
   friend ComplexRowVector operator / (const ComplexRowVector& a, double s);
 
+  friend ComplexRowVector operator + (const RowVector& a, const Complex& s);
+  friend ComplexRowVector operator - (const RowVector& a, const Complex& s);
+  friend ComplexRowVector operator * (const RowVector& a, const Complex& s);
+  friend ComplexRowVector operator / (const RowVector& a, const Complex& s);
+
 // scalar by row vector -> row vector operations
 
   friend ComplexRowVector operator + (double s, const ComplexRowVector& a);
   friend ComplexRowVector operator - (double s, const ComplexRowVector& a);
   friend ComplexRowVector operator * (double s, const ComplexRowVector& a);
   friend ComplexRowVector operator / (double s, const ComplexRowVector& a);
 
-// row vector by column vector -> scalar
-
-  friend Complex operator * (const ComplexRowVector& a, const ColumnVector& b);
-
-  friend Complex operator * (const ComplexRowVector& a,
-			     const ComplexColumnVector& b);
+  friend ComplexRowVector operator + (const Complex& s, const RowVector& a);
+  friend ComplexRowVector operator - (const Complex& s, const RowVector& a);
+  friend ComplexRowVector operator * (const Complex& s, const RowVector& a);
+  friend ComplexRowVector operator / (const Complex& s, const RowVector& a);
 
 // row vector by matrix -> row vector
 
   friend ComplexRowVector operator * (const ComplexRowVector& a,
 				      const ComplexMatrix& b);
 
+  friend ComplexRowVector operator * (const RowVector& a,
+				      const ComplexMatrix& b);
+
 // row vector by row vector -> row vector operations
 
   friend ComplexRowVector operator + (const ComplexRowVector& a,
 				      const RowVector& b);
   friend ComplexRowVector operator - (const ComplexRowVector& a,
 				      const RowVector& b);
 
+  friend ComplexRowVector operator + (const RowVector& a,
+				      const ComplexRowVector& b);
+  friend ComplexRowVector operator - (const RowVector& a,
+				      const ComplexRowVector& b);
+
   friend ComplexRowVector product (const ComplexRowVector& a,
 				   const RowVector& b);
   friend ComplexRowVector quotient (const ComplexRowVector& a,
 				    const RowVector& b);
 
+  friend ComplexRowVector product (const RowVector& a,
+				   const ComplexRowVector& b);
+  friend ComplexRowVector quotient (const RowVector& a,
+				    const ComplexRowVector& b);
+
 // other operations
 
   friend ComplexRowVector map (c_c_Mapper f, const ComplexRowVector& a);
-  friend RowVector map (d_c_Mapper f, const ComplexRowVector& a);
   void map (c_c_Mapper f);
 
   Complex min (void) const;
   Complex max (void) const;
 
 // i/o
 
   friend ostream& operator << (ostream& os, const ComplexRowVector& a);
@@ -149,16 +157,24 @@ public:
 #undef TYPE
 #undef KL_VEC_TYPE
 
 private:
 
   ComplexRowVector (Complex *d, int l) : Array<Complex> (d, l) { }
 };
 
+// row vector by column vector -> scalar
+
+Complex operator * (const ComplexRowVector& a, const ColumnVector& b);
+
+Complex operator * (const ComplexRowVector& a, const ComplexColumnVector& b);
+
+// other operations
+
 ComplexRowVector linspace (const Complex& x1, const Complex& x2, int n);
 
 } // extern "C++"
 
 #endif
 
 /*
 ;;; Local Variables: ***
diff --git a/liboctave/dColVector.cc b/liboctave/dColVector.cc
--- a/liboctave/dColVector.cc
+++ b/liboctave/dColVector.cc
@@ -33,75 +33,34 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "mx-inlines.cc"
 #include "f77-uscore.h"
 #include "lo-error.h"
 
 // Fortran functions we call.
 
 extern "C"
 {
-  int F77_FCN (dgemm) (const char*, const char*, const int*,
-		       const int*, const int*, const double*,
+  int F77_FCN (dgemv) (const char*, const int*, const int*,
+		       const double*, const double*, const int*,
 		       const double*, const int*, const double*,
-		       const int*, const double*, double*, const int*,
-		       long, long);
+		       double*, const int*, long);
 }
 
 /*
  * Column Vector class.
  */
 
 #define KLUDGE_VECTORS
 #define TYPE double
 #define KL_VEC_TYPE ColumnVector
 #include "mx-kludge.cc"
 #undef KLUDGE_VECTORS
 #undef TYPE
 #undef KL_VEC_TYPE
 
-#if 0
-ColumnVector&
-ColumnVector::resize (int n)
-{
-  if (n < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't resize to negative dimension");
-      return *this;
-    }
-
-  double *new_data = 0;
-  if (n > 0)
-    {
-      new_data = new double [n];
-      int min_len = len < n ? len : n;
-
-      for (int i = 0; i < min_len; i++)
-	new_data[i] = data[i];
-    }
-
-  delete [] data;
-  len = n;
-  data = new_data;
-
-  return *this;
-}
-
-ColumnVector&
-ColumnVector::resize (int n, double val)
-{
-  int old_len = len;
-  resize (n);
-  for (int i = old_len; i < len; i++)
-    data[i] = val;
-
-  return *this;
-}
-#endif
-
 int
 ColumnVector::operator == (const ColumnVector& a) const
 {
   int len = length ();
   if (len != a.length ())
     return 0;
   return equal (data (), a.data (), len);
 }
@@ -169,16 +128,36 @@ ColumnVector::stack (const ColumnVector&
 
 RowVector
 ColumnVector::transpose (void) const
 {
   int len = length ();
   return RowVector (dup (data (), len), len);
 }
 
+ColumnVector
+real (const ComplexColumnVector& a)
+{
+  int a_len = a.length ();
+  ColumnVector retval;
+  if (a_len > 0)
+    retval = ColumnVector (real_dup (a.data (), a_len), a_len);
+  return retval;
+}
+
+ColumnVector
+imag (const ComplexColumnVector& a)
+{
+  int a_len = a.length ();
+  ColumnVector retval;
+  if (a_len > 0)
+    retval = ColumnVector (imag_dup (a.data (), a_len), a_len);
+  return retval;
+}
+
 // resize is the destructive equivalent for this one
 
 ColumnVector
 ColumnVector::extract (int r1, int r2) const
 {
   if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
 
   int new_r = r2 - r1 + 1;
@@ -228,193 +207,96 @@ ColumnVector::operator -= (const ColumnV
     return *this;
 
   double *d = fortran_vec (); // Ensures only one reference to my privates!
 
   subtract2 (d, a.data (), len);
   return *this;
 }
 
-// scalar by column vector -> column vector operations
-
-ComplexColumnVector
-operator + (const ColumnVector& a, const Complex& s)
-{
-  int len = a.length ();
-  return ComplexColumnVector (add (a.data (), len, s), len);
-}
-
-ComplexColumnVector
-operator - (const ColumnVector& a, const Complex& s)
-{
-  int len = a.length ();
-  return ComplexColumnVector (subtract (a.data (), len, s), len);
-}
-
-ComplexColumnVector
-operator * (const ColumnVector& a, const Complex& s)
-{
-  int len = a.length ();
-  return ComplexColumnVector (multiply (a.data (), len, s), len);
-}
-
-ComplexColumnVector
-operator / (const ColumnVector& a, const Complex& s)
-{
-  int len = a.length ();
-  return ComplexColumnVector (divide (a.data (), len, s), len);
-}
-
-// scalar by column vector -> column vector operations
+// matrix by column vector -> column vector operations
 
-ComplexColumnVector
-operator + (const Complex& s, const ColumnVector& a)
-{
-  int a_len = a.length ();
-  return ComplexColumnVector (add (a.data (), a_len, s), a_len);
-}
-
-ComplexColumnVector
-operator - (const Complex& s, const ColumnVector& a)
-{
-  int a_len = a.length ();
-  return ComplexColumnVector (subtract (s, a.data (), a_len), a_len);
-}
-
-ComplexColumnVector
-operator * (const Complex& s, const ColumnVector& a)
+ColumnVector
+operator * (const Matrix& m, const ColumnVector& a)
 {
-  int a_len = a.length ();
-  return ComplexColumnVector (multiply (a.data (), a_len, s), a_len);
-}
-
-ComplexColumnVector
-operator / (const Complex& s, const ColumnVector& a)
-{
-  int a_len = a.length ();
-  return ComplexColumnVector (divide (s, a.data (), a_len), a_len);
-}
-
-// column vector by row vector -> matrix operations
-
-Matrix
-operator * (const ColumnVector& v, const RowVector& a)
-{
-  int len = v.length ();
-  int a_len = a.length ();
-  if (len != a_len)
+  int nr = m.rows ();
+  int nc = m.cols ();
+  if (nc != a.length ())
     {
       (*current_liboctave_error_handler)
-	("nonconformant vector multiplication attempted");
-      return Matrix ();
-    }
-
-  if (len == 0)
-    return Matrix (len, len, 0.0);
-
-  char transa = 'N';
-  char transb = 'N';
-  double alpha = 1.0;
-  double beta  = 0.0;
-  int anr = 1;
-
-  double *c = new double [len * a_len];
-
-  F77_FCN (dgemm) (&transa, &transb, &len, &a_len, &anr, &alpha,
-		   v.data (), &len, a.data (), &anr, &beta, c, &len,
-		   1L, 1L); 
-
-  return Matrix (c, len, a_len);
-}
-
-ComplexMatrix
-operator * (const ColumnVector& v, const ComplexRowVector& a)
-{
-  ComplexColumnVector tmp (v);
-  return tmp * a;
-}
-
-ComplexColumnVector
-operator + (const ColumnVector& v, const ComplexColumnVector& a)
-{
-  int len = v.length ();
-  if (len != a.length ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector subtraction attempted");
-      return ComplexColumnVector ();
-    }
-
-  if (len == 0)
-    return ComplexColumnVector (0);
-
-  return ComplexColumnVector (add (v.data (), a.data (), len), len);
-}
-
-ComplexColumnVector
-operator - (const ColumnVector& v, const ComplexColumnVector& a)
-{
-  int len = v.length ();
-  if (len != a.length ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector subtraction attempted");
-      return ComplexColumnVector ();
-    }
-
-  if (len == 0)
-    return ComplexColumnVector (0);
-
-  return ComplexColumnVector (subtract (v.data (), a.data (), len), len);
-}
-
-ComplexColumnVector
-product (const ColumnVector& v, const ComplexColumnVector& a)
-{
-  int len = v.length ();
-  if (len != a.length ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector product attempted");
+	("nonconformant matrix multiplication attempted");
       return ColumnVector ();
     }
 
-  if (len == 0)
-    return ComplexColumnVector (0);
+  if (nr == 0 || nc == 0)
+    return ColumnVector (0);
 
-  return ComplexColumnVector (multiply (v.data (), a.data (), len), len);
+  char trans = 'N';
+  int ld = nr;
+  double alpha = 1.0;
+  double beta  = 0.0;
+  int i_one = 1;
+
+  double *y = new double [nr];
+
+  F77_FCN (dgemv) (&trans, &nr, &nc, &alpha, m.data (), &ld, a.data (),
+		   &i_one, &beta, y, &i_one, 1L); 
+
+  return ColumnVector (y, nr);
 }
 
-ComplexColumnVector
-quotient (const ColumnVector& v, const ComplexColumnVector& a)
+// diagonal matrix by column vector -> column vector operations
+
+ColumnVector
+operator * (const DiagMatrix& m, const ColumnVector& a)
 {
-  int len = v.length ();
-  if (len != a.length ())
+  int nr = m.rows ();
+  int nc = m.cols ();
+  int a_len = a.length ();
+  if (nc != a_len)
     {
       (*current_liboctave_error_handler)
-	("nonconformant vector quotient attempted");
+	("nonconformant matrix multiplication attempted");
       return ColumnVector ();
     }
 
-  if (len == 0)
-    return ComplexColumnVector (0);
+  if (nc == 0 || nr == 0)
+    return ColumnVector (0);
+
+  ColumnVector result (nr);
 
-  return ComplexColumnVector (divide (v.data (), a.data (), len), len);
+  for (int i = 0; i < a_len; i++)
+    result.elem (i) = a.elem (i) * m.elem (i, i);
+
+  for (i = a_len; i < nr; i++)
+    result.elem (i) = 0.0;
+
+  return result;
 }
 
 // other operations
 
 ColumnVector
 map (d_d_Mapper f, const ColumnVector& a)
 {
   ColumnVector b (a);
   b.map (f);
   return b;
 }
 
+ColumnVector
+map (d_c_Mapper f, const ComplexColumnVector& a)
+{
+  int a_len = a.length ();
+  ColumnVector b (a_len);
+  for (int i = 0; i < a_len; i++)
+    b.elem (i) = f (a.elem (i));
+  return b;
+}
+
 void
 ColumnVector::map (d_d_Mapper f)
 {
   for (int i = 0; i < length (); i++)
     elem (i) = f (elem (i));
 }
 
 double
diff --git a/liboctave/dColVector.h b/liboctave/dColVector.h
--- a/liboctave/dColVector.h
+++ b/liboctave/dColVector.h
@@ -29,104 +29,69 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "mx-defs.h"
 
 extern "C++" {
 
 class ColumnVector : public Array<double>
 {
 friend class Matrix;
 friend class RowVector;
-friend class ComplexColumnVector;
 
 public:
 
   ColumnVector (void) : Array<double> () { }
   ColumnVector (int n) : Array<double> (n) { }
   ColumnVector (int n, double val) : Array<double> (n, val) { }
   ColumnVector (const Array<double>& a) : Array<double> (a) { }
   ColumnVector (const ColumnVector& a) : Array<double> (a) { }
-//  ColumnVector (double a) : Array<double> (1, a) { }
 
   ColumnVector& operator = (const ColumnVector& a)
     {
       Array<double>::operator = (a);
       return *this;
     }
 
-//  operator Array<double>& () const { return *this; }
-
   int operator == (const ColumnVector& a) const;
   int operator != (const ColumnVector& a) const;
 
 // destructive insert/delete/reorder operations
 
   ColumnVector& insert (const ColumnVector& a, int r);
 
   ColumnVector& fill (double val);
   ColumnVector& fill (double val, int r1, int r2);
 
   ColumnVector stack (const ColumnVector& a) const;
 
   RowVector transpose (void) const;
 
+  friend ColumnVector real (const ComplexColumnVector& a);
+  friend ColumnVector imag (const ComplexColumnVector& a);
+
 // resize is the destructive equivalent for this one
 
   ColumnVector extract (int r1, int r2) const;
 
 // column vector by column vector -> column vector operations
 
   ColumnVector& operator += (const ColumnVector& a);
   ColumnVector& operator -= (const ColumnVector& a);
 
-// column vector by scalar -> column vector operations
+// matrix by column vector -> column vector operations
 
-  friend ComplexColumnVector operator + (const ColumnVector& a,
-					 const Complex& s);  
-  friend ComplexColumnVector operator - (const ColumnVector& a,
-					 const Complex& s);
-  friend ComplexColumnVector operator * (const ColumnVector& a,
-					 const Complex& s);
-  friend ComplexColumnVector operator / (const ColumnVector& a,
-					 const Complex& s);
-
-// scalar by column vector -> column vector operations
+  friend ColumnVector operator * (const Matrix& a, const ColumnVector& b);
 
-  friend ComplexColumnVector operator + (const Complex& s,
-					 const ColumnVector& a); 
-  friend ComplexColumnVector operator - (const Complex& s,
-					 const ColumnVector& a);
-  friend ComplexColumnVector operator * (const Complex& s,
-					 const ColumnVector& a);
-  friend ComplexColumnVector operator / (const Complex& s,
-					 const ColumnVector& a);
-
-// column vector by row vector -> matrix operations
-
-  friend Matrix operator * (const ColumnVector& a, const RowVector& a);
+// diagonal matrix by column vector -> column vector operations
 
-  friend ComplexMatrix operator * (const ColumnVector& a,
-				   const ComplexRowVector& b);
-
-// column vector by column vector -> column vector operations
-
-  friend ComplexColumnVector operator + (const ComplexColumnVector& a,
-					 const ComplexColumnVector& b);
-
-  friend ComplexColumnVector operator - (const ComplexColumnVector& a,
-					 const ComplexColumnVector& b); 
-
-  friend ComplexColumnVector product (const ComplexColumnVector& a,
-				      const ComplexColumnVector& b); 
-
-  friend ComplexColumnVector quotient (const ComplexColumnVector& a,
-				       const ComplexColumnVector& b); 
+  friend ColumnVector operator * (const DiagMatrix& a, const ColumnVector& b);
 
 // other operations
 
   friend ColumnVector map (d_d_Mapper f, const ColumnVector& a);
+  friend ColumnVector map (d_c_Mapper f, const ComplexColumnVector& a);
   void map (d_d_Mapper f);
 
   double min (void) const;
   double max (void) const;
 
 // i/o
 
   friend ostream& operator << (ostream& os, const ColumnVector& a);
diff --git a/liboctave/dDiagMatrix.cc b/liboctave/dDiagMatrix.cc
--- a/liboctave/dDiagMatrix.cc
+++ b/liboctave/dDiagMatrix.cc
@@ -40,83 +40,16 @@ Software Foundation, 675 Mass Ave, Cambr
 #define KLUDGE_DIAG_MATRICES
 #define TYPE double
 #define KL_DMAT_TYPE DiagMatrix
 #include "mx-kludge.cc"
 #undef KLUDGE_DIAG_MATRICES
 #undef TYPE
 #undef KL_DMAT_TYPE
 
-#if 0
-DiagMatrix&
-DiagMatrix::resize (int r, int c)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't resize to negative dimensions");
-      return *this;
-    }
-
-  int new_len = r < c ? r : c;
-  double *new_data = 0;
-  if (new_len > 0)
-    {
-      new_data = new double [new_len];
-
-      int min_len = new_len < len ? new_len : len;
-
-      for (int i = 0; i < min_len; i++)
-	new_data[i] = data[i];
-    }
-
-  delete [] data;
-  nr = r;
-  nc = c;
-  len = new_len;
-  data = new_data;
-
-  return *this;
-}
-
-DiagMatrix&
-DiagMatrix::resize (int r, int c, double val)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't resize to negative dimensions");
-      return *this;
-    }
-
-  int new_len = r < c ? r : c;
-  double *new_data = 0;
-  if (new_len > 0)
-    {
-      new_data = new double [new_len];
-
-      int min_len = new_len < len ? new_len : len;
-
-      for (int i = 0; i < min_len; i++)
-	new_data[i] = data[i];
-
-      for (i = min_len; i < new_len; i++)
-	new_data[i] = val;
-    }
-
-  delete [] data;
-  nr = r;
-  nc = c;
-  len = new_len;
-  data = new_data;
-
-  return *this;
-}
-#endif
-
 int
 DiagMatrix::operator == (const DiagMatrix& a) const
 {
   if (rows () != a.rows () || cols () != a.cols ())
     return 0;
 
   return equal (data (), a.data (), length ());
 }
@@ -215,16 +148,38 @@ DiagMatrix::fill (const RowVector& a, in
 }
 
 DiagMatrix
 DiagMatrix::transpose (void) const
 {
   return DiagMatrix (dup (data (), length ()), cols (), rows ());
 }
 
+DiagMatrix
+real (const ComplexDiagMatrix& a)
+{
+  DiagMatrix retval;
+  int a_len = a.length ();
+  if (a_len > 0)
+    retval = DiagMatrix (real_dup (a.data (), a_len), a.rows (),
+			 a.cols ());
+  return retval;
+}
+
+DiagMatrix
+imag (const ComplexDiagMatrix& a)
+{
+  DiagMatrix retval;
+  int a_len = a.length ();
+  if (a_len > 0)
+    retval = DiagMatrix (imag_dup (a.data (), a_len), a.rows (),
+			 a.cols ());
+  return retval;
+}
+
 Matrix
 DiagMatrix::extract (int r1, int c1, int r2, int c2) const
 {
   if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
 
   int new_r = r2 - r1 + 1;
   int new_c = c2 - c1 + 1;
@@ -395,157 +350,16 @@ DiagMatrix::operator -= (const DiagMatri
     return *this;
 
   double *d = fortran_vec (); // Ensures only one reference to my privates!
 
   subtract2 (d, a.data (), length ());
   return *this;
 }
 
-// diagonal matrix by scalar -> matrix operations
-
-Matrix
-operator + (const DiagMatrix& a, double s)
-{
-  Matrix tmp (a.rows (), a.cols (), s);
-  return a + tmp;
-}
-
-Matrix
-operator - (const DiagMatrix& a, double s)
-{
-  Matrix tmp (a.rows (), a.cols (), -s);
-  return a + tmp;
-}
-
-ComplexMatrix
-operator + (const DiagMatrix& a, const Complex& s)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), s);
-  return a + tmp;
-}
-
-ComplexMatrix
-operator - (const DiagMatrix& a, const Complex& s)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), -s);
-  return a + tmp;
-}
-
-// diagonal matrix by scalar -> diagonal matrix operations
-
-ComplexDiagMatrix
-operator * (const DiagMatrix& a, const Complex& s)
-{
-  return ComplexDiagMatrix (multiply (a.data (), a.length (), s),
-			    a.rows (), a.cols ());
-}
-
-ComplexDiagMatrix
-operator / (const DiagMatrix& a, const Complex& s)
-{
-  return ComplexDiagMatrix (divide (a.data (), a.length (), s),
-			    a.rows (), a.cols ());
-}
-
-// scalar by diagonal matrix -> matrix operations
-
-Matrix
-operator + (double s, const DiagMatrix& a)
-{
-  Matrix tmp (a.rows (), a.cols (), s);
-  return tmp + a;
-}
-
-Matrix
-operator - (double s, const DiagMatrix& a)
-{
-  Matrix tmp (a.rows (), a.cols (), s);
-  return tmp - a;
-}
-
-ComplexMatrix
-operator + (const Complex& s, const DiagMatrix& a)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), s);
-  return tmp + a;
-}
-
-ComplexMatrix
-operator - (const Complex& s, const DiagMatrix& a)
-{
-  ComplexMatrix tmp (a.rows (), a.cols (), s);
-  return tmp - a;
-}
-
-// scalar by diagonal matrix -> diagonal matrix operations
-
-ComplexDiagMatrix
-operator * (const Complex& s, const DiagMatrix& a)
-{
-  return ComplexDiagMatrix (multiply (a.data (), a.length (), s),
-			    a.rows (), a.cols ());
-}
-
-// diagonal matrix by column vector -> column vector operations
-
-ColumnVector
-operator * (const DiagMatrix& m, const ColumnVector& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  int a_len = a.length ();
-  if (nc != a_len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix multiplication attempted");
-      return ColumnVector ();
-    }
-
-  if (nc == 0 || nr == 0)
-    return ColumnVector (0);
-
-  ColumnVector result (nr);
-
-  for (int i = 0; i < a_len; i++)
-    result.elem (i) = a.elem (i) * m.elem (i, i);
-
-  for (i = a_len; i < nr; i++)
-    result.elem (i) = 0.0;
-
-  return result;
-}
-
-ComplexColumnVector
-operator * (const DiagMatrix& m, const ComplexColumnVector& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  int a_len = a.length ();
-  if (nc != a_len)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix multiplication attempted");
-      return ColumnVector ();
-    }
-
-  if (nc == 0 || nr == 0)
-    return ComplexColumnVector (0);
-
-  ComplexColumnVector result (nr);
-
-  for (int i = 0; i < a_len; i++)
-    result.elem (i) = a.elem (i) * m.elem (i, i);
-
-  for (i = a_len; i < nr; i++)
-    result.elem (i) = 0.0;
-
-  return result;
-}
-
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 DiagMatrix
 operator * (const DiagMatrix& a, const DiagMatrix& b)
 {
   int nr_a = a.rows ();
   int nc_a = a.cols ();
   int nr_b = b.rows ();
@@ -577,297 +391,16 @@ operator * (const DiagMatrix& a, const D
         c.elem (i, i) = a_element;
       else
         c.elem (i, i) = a_element * b_element;
     }
 
   return c;
 }
 
-ComplexDiagMatrix
-operator + (const DiagMatrix& m, const ComplexDiagMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix addition attempted");
-      return ComplexDiagMatrix ();
-    }
-
-  if (nc == 0 || nr == 0)
-    return ComplexDiagMatrix (nr, nc);
-
-  return ComplexDiagMatrix (add (m.data (), a.data (), m.length ()),  nr, nc);
-}
-
-ComplexDiagMatrix
-operator - (const DiagMatrix& m, const ComplexDiagMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix subtraction attempted");
-      return ComplexDiagMatrix ();
-    }
-
-  if (nc == 0 || nr == 0)
-    return ComplexDiagMatrix (nr, nc);
-
-  return ComplexDiagMatrix (subtract (m.data (), a.data (), m.length ()),
-			    nr, nc);
-}
-
-ComplexDiagMatrix
-operator * (const DiagMatrix& a, const ComplexDiagMatrix& b)
-{
-  int nr_a = a.rows ();
-  int nc_a = a.cols ();
-  int nr_b = b.rows ();
-  int nc_b = b.cols ();
-  if (nc_a != nr_b)
-    {
-      (*current_liboctave_error_handler)
-        ("nonconformant matrix multiplication attempted");
-      return ComplexDiagMatrix ();
-    }
-
-  if (nr_a == 0 || nc_a == 0 || nc_b == 0)
-    return ComplexDiagMatrix (nr_a, nc_a, 0.0);
-
-  ComplexDiagMatrix c (nr_a, nc_b);
-
-  int len = nr_a < nc_b ? nr_a : nc_b;
-
-  for (int i = 0; i < len; i++)
-    {
-      double a_element = a.elem (i, i);
-      Complex b_element = b.elem (i, i);
-
-      if (a_element == 0.0 || b_element == 0.0)
-        c.elem (i, i) = 0.0;
-      else if (a_element == 1.0)
-        c.elem (i, i) = b_element;
-      else if (b_element == 1.0)
-        c.elem (i, i) = a_element;
-      else
-        c.elem (i, i) = a_element * b_element;
-    }
-
-  return c;
-}
-
-ComplexDiagMatrix
-product (const DiagMatrix& m, const ComplexDiagMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix product attempted");
-      return ComplexDiagMatrix ();
-    }
-
-  if (nc == 0 || nr == 0)
-    return ComplexDiagMatrix (nr, nc);
-
-  return ComplexDiagMatrix (multiply (m.data (), a.data (), m.length ()),
-			    nr, nc);
-}
-
-// diagonal matrix by matrix -> matrix operations
-
-Matrix
-operator + (const DiagMatrix& m, const Matrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix addition attempted");
-      return Matrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return Matrix (nr, nc);
-
-  Matrix result (a);
-  for (int i = 0; i < m.length (); i++)
-    result.elem (i, i) += m.elem (i, i);
-
-  return result;
-}
-
-Matrix
-operator - (const DiagMatrix& m, const Matrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix subtraction attempted");
-      return Matrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return Matrix (nr, nc);
-
-  Matrix result (-a);
-  for (int i = 0; i < m.length (); i++)
-    result.elem (i, i) += m.elem (i, i);
-
-  return result;
-}
-
-Matrix
-operator * (const DiagMatrix& m, const Matrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-  if (nc != a_nr)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix multiplication attempted");
-      return Matrix ();
-    }
-
-  if (nr == 0 || nc == 0 || a_nc == 0)
-    return Matrix (nr, a_nc, 0.0);
-
-  Matrix c (nr, a_nc);
-
-  for (int i = 0; i < m.length (); i++)
-    {
-      if (m.elem (i, i) == 1.0)
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = a.elem (i, j);
-	}
-      else if (m.elem (i, i) == 0.0)
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = 0.0;
-	}
-      else
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = m.elem (i, i) * a.elem (i, j);
-	}
-    }
-
-  if (nr > nc)
-    {
-      for (int j = 0; j < a_nc; j++)
-	for (int i = a_nr; i < nr; i++)
-	  c.elem (i, j) = 0.0;
-    }
-
-  return c;
-}
-
-ComplexMatrix
-operator + (const DiagMatrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix addition attempted");
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  ComplexMatrix result (a);
-  for (int i = 0; i < m.length (); i++)
-    result.elem (i, i) += m.elem (i, i);
-
-  return result;
-}
-
-ComplexMatrix
-operator - (const DiagMatrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix subtraction attempted");
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  ComplexMatrix result (-a);
-  for (int i = 0; i < m.length (); i++)
-    result.elem (i, i) += m.elem (i, i);
-
-  return result;
-}
-
-ComplexMatrix
-operator * (const DiagMatrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  int a_nr = a.rows ();
-  int a_nc = a.cols ();
-  if (nc != a_nr)
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix multiplication attempted");
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0 || a_nc == 0)
-    return ComplexMatrix (nr, nc, 0.0);
-
-  ComplexMatrix c (nr, a_nc);
-
-  for (int i = 0; i < m.length (); i++)
-    {
-      if (m.elem (i, i) == 1.0)
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = a.elem (i, j);
-	}
-      else if (m.elem (i, i) == 0.0)
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = 0.0;
-	}
-      else
-	{
-	  for (int j = 0; j < a_nc; j++)
-	    c.elem (i, j) = m.elem (i, i) * a.elem (i, j);
-	}
-    }
-
-  if (nr > nc)
-    {
-      for (int j = 0; j < a_nc; j++)
-	for (int i = a_nr; i < nr; i++)
-	  c.elem (i, j) = 0.0;
-    }
-
-  return c;
-}
-
 // other operations
 
 ColumnVector
 DiagMatrix::diag (void) const
 {
   return diag (0);
 }
 
diff --git a/liboctave/dDiagMatrix.h b/liboctave/dDiagMatrix.h
--- a/liboctave/dDiagMatrix.h
+++ b/liboctave/dDiagMatrix.h
@@ -32,17 +32,16 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "mx-defs.h"
 
 extern "C++" {
 
 class DiagMatrix : public DiagArray<double>
 {
 friend class SVD;
 friend class ComplexSVD;
-friend class ComplexDiagMatrix;
 
 public:
 
   DiagMatrix (void) : DiagArray<double> () { }
   DiagMatrix (int n) : DiagArray<double> (n) { }
   DiagMatrix (int n, double val) : DiagArray<double> (n, val) { }
   DiagMatrix (int r, int c) : DiagArray<double> (r, c) { }
   DiagMatrix (int r, int c, double val) : DiagArray<double> (r, c, val) { }
@@ -67,16 +66,19 @@ public:
   DiagMatrix& fill (double val, int beg, int end);
   DiagMatrix& fill (const ColumnVector& a);
   DiagMatrix& fill (const RowVector& a);
   DiagMatrix& fill (const ColumnVector& a, int beg);
   DiagMatrix& fill (const RowVector& a, int beg);
 
   DiagMatrix transpose (void) const;
 
+  friend DiagMatrix real (const ComplexDiagMatrix& a);
+  friend DiagMatrix imag (const ComplexDiagMatrix& a);
+
 // resize is the destructive analog for this one
 
   Matrix extract (int r1, int c1, int r2, int c2) const;
 
 // extract row or column i.
 
   RowVector row (int i) const;
   RowVector row (char *s) const;
@@ -87,76 +89,21 @@ public:
   DiagMatrix inverse (void) const;
   DiagMatrix inverse (int& info) const;
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
   DiagMatrix& operator += (const DiagMatrix& a);
   DiagMatrix& operator -= (const DiagMatrix& a);
 
-// diagonal matrix by scalar -> matrix operations
-
-  friend Matrix operator + (const DiagMatrix& a, double s);
-  friend Matrix operator - (const DiagMatrix& a, double s);
-
-  friend ComplexMatrix operator + (const DiagMatrix& a, const Complex& s);
-  friend ComplexMatrix operator - (const DiagMatrix& a, const Complex& s);
-
-// diagonal matrix by scalar -> diagonal matrix operations
-
-  friend ComplexDiagMatrix operator * (const DiagMatrix& a, const Complex& s);
-  friend ComplexDiagMatrix operator / (const DiagMatrix& a, const Complex& s);
-
-// scalar by diagonal matrix -> matrix operations
-
-  friend Matrix operator + (double s, const DiagMatrix& a);
-  friend Matrix operator - (double s, const DiagMatrix& a);
-
-  friend ComplexMatrix operator + (const Complex& s, const DiagMatrix& a);
-  friend ComplexMatrix operator - (const Complex& s, const DiagMatrix& a);
-
-// scalar by diagonal matrix -> diagonal matrix operations
-
-  friend ComplexDiagMatrix operator * (const Complex& s, const DiagMatrix& a);
-
-// diagonal matrix by column vector -> column vector operations
-
-  friend ColumnVector operator * (const DiagMatrix& a, const ColumnVector& b);
-
-  friend ComplexColumnVector operator * (const DiagMatrix& a,
-					 const ComplexColumnVector& b);
-
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
   friend DiagMatrix operator * (const DiagMatrix& a,
 				const DiagMatrix& b);
 
-  friend ComplexDiagMatrix operator + (const DiagMatrix& a,
-				       const ComplexDiagMatrix& b);
-  friend ComplexDiagMatrix operator - (const DiagMatrix& a,
-				       const ComplexDiagMatrix& b);
-  friend ComplexDiagMatrix operator * (const DiagMatrix& a,
-				       const ComplexDiagMatrix& b);
-
-  friend ComplexDiagMatrix product (const DiagMatrix& a,
-				    const ComplexDiagMatrix& b);
-
-// diagonal matrix by matrix -> matrix operations
-
-  friend Matrix operator + (const DiagMatrix& a, const Matrix& b);
-  friend Matrix operator - (const DiagMatrix& a, const Matrix& b);
-  friend Matrix operator * (const DiagMatrix& a, const Matrix& b);
-
-  friend ComplexMatrix operator + (const DiagMatrix& a,
-				   const ComplexMatrix& b);
-  friend ComplexMatrix operator - (const DiagMatrix& a,
-				   const ComplexMatrix& b);
-  friend ComplexMatrix operator * (const DiagMatrix& a,
-				   const ComplexMatrix& b);
-
 // other operations
 
   ColumnVector diag (void) const;
   ColumnVector diag (int k) const;
 
 // i/o
 
   friend ostream& operator << (ostream& os, const DiagMatrix& a);
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -44,21 +44,16 @@ Software Foundation, 675 Mass Ave, Cambr
 extern "C"
 {
   int F77_FCN (dgemm) (const char*, const char*, const int*,
 		       const int*, const int*, const double*,
 		       const double*, const int*, const double*,
 		       const int*, const double*, double*, const int*,
 		       long, long);
 
-  int F77_FCN (dgemv) (const char*, const int*, const int*,
-		       const double*, const double*, const int*,
-		       const double*, const int*, const double*,
-		       double*, const int*, long);
-
   int F77_FCN (dgeco) (double*, const int*, const int*, int*, double*,
 		       double*);
 
   int F77_FCN (dgesl) (const double*, const int*, const int*,
 		       const int*, double*, const int*); 
 
   int F77_FCN (dgedi) (double*, const int*, const int*, const int*,
 		       double*, double*, const int*);
@@ -94,89 +89,16 @@ extern "C"
 
 Matrix::Matrix (const DiagMatrix& a)
   : Array2<double> (a.rows (), a.cols (), 0.0)
 {
   for (int i = 0; i < a.length (); i++)
     elem (i, i) = a.elem (i, i);
 }
 
-#if 0
-Matrix&
-Matrix::resize (int r, int c)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't resize to negative dimensions");
-      return *this;
-    }
-
-  int new_len = r * c;
-  double* new_data = 0;
-  if (new_len > 0)
-    {
-      new_data = new double [new_len];
-
-      int min_r = nr < r ? nr : r;
-      int min_c = nc < c ? nc : c;
-
-      for (int j = 0; j < min_c; j++)
-	for (int i = 0; i < min_r; i++)
-	  new_data[r*j+i] = elem (i, j);
-    }
-
-  delete [] data;
-  nr = r;
-  nc = c;
-  len = new_len;
-  data = new_data;
-
-  return *this;
-}
-
-Matrix&
-Matrix::resize (int r, int c, double val)
-{
-  if (r < 0 || c < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't resize to negative dimensions");
-      return *this;
-    }
-
-  int new_len = r * c;
-  double *new_data = 0;
-  if (new_len > 0)
-    {
-      new_data = new double [new_len];
-
-// There may be faster or cleaner ways to do this.
-
-      if (r > nr || c > nc)
-	copy (new_data, new_len, val);
-
-      int min_r = nr < r ? nr : r;
-      int min_c = nc < c ? nc : c;
-
-      for (int j = 0; j < min_c; j++)
-	for (int i = 0; i < min_r; i++)
-	  new_data[r*j+i] = elem (i, j);
-    }
-
-  delete [] data;
-  nr = r;
-  nc = c;
-  len = new_len;
-  data = new_data;
-
-  return *this;
-}
-#endif
-
 int
 Matrix::operator == (const Matrix& a) const
 {
   if (rows () != a.rows () || cols () != a.cols ())
     return 0;
 
   return equal (data (), a.data (), length ());
 }
@@ -448,16 +370,36 @@ Matrix::transpose (void) const
       for (int j = 0; j < nc; j++)
 	for (int i = 0; i < nr; i++)
 	  result.elem (j, i) = elem (i, j);
     }
   return result;
 }
 
 Matrix
+real (const ComplexMatrix& a)
+{
+  int a_len = a.length ();
+  Matrix retval;
+  if (a_len > 0)
+    retval = Matrix (real_dup (a.data (), a_len), a.rows (), a.cols ());
+  return retval;
+}
+
+Matrix
+imag (const ComplexMatrix& a)
+{
+  int a_len = a.length ();
+  Matrix retval;
+  if (a_len > 0)
+    retval = Matrix (imag_dup (a.data (), a_len), a.rows (), a.cols ());
+  return retval;
+}
+
+Matrix
 Matrix::extract (int r1, int c1, int r2, int c2) const
 {
   if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
 
   int new_r = r2 - r1 + 1;
   int new_c = c2 - c1 + 1;
 
@@ -1304,112 +1246,78 @@ Matrix::operator ! (void) const
 
   for (int j = 0; j < nc; j++)
     for (int i = 0; i < nr; i++)
       b.elem (i, j) = ! elem (i, j);
 
   return b;
 }
 
-// matrix by scalar -> matrix operations.
-
-ComplexMatrix
-operator + (const Matrix& a, const Complex& s)
-{
-  return ComplexMatrix (add (a.data (), a.length (), s),
-			a.rows (), a.cols ());
-}
+// column vector by row vector -> matrix operations
 
-ComplexMatrix
-operator - (const Matrix& a, const Complex& s)
-{
-  return ComplexMatrix (subtract (a.data (), a.length (), s),
-			a.rows (), a.cols ());
-}
-
-ComplexMatrix
-operator * (const Matrix& a, const Complex& s)
+Matrix
+operator * (const ColumnVector& v, const RowVector& a)
 {
-  return ComplexMatrix (multiply (a.data (), a.length (), s),
-			a.rows (), a.cols ());
-}
+  int len = v.length ();
+  int a_len = a.length ();
+  if (len != a_len)
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector multiplication attempted");
+      return Matrix ();
+    }
 
-ComplexMatrix
-operator / (const Matrix& a, const Complex& s)
-{
-  return ComplexMatrix (divide (a.data (), a.length (), s),
-			a.rows (), a.cols ());
-}
-
-// scalar by matrix -> matrix operations.
+  if (len == 0)
+    return Matrix (len, len, 0.0);
 
-ComplexMatrix
-operator + (const Complex& s, const Matrix& a)
-{
-  return ComplexMatrix (add (s, a.data (), a.length ()),
-			a.rows (), a.cols ());
-}
+  char transa = 'N';
+  char transb = 'N';
+  double alpha = 1.0;
+  double beta  = 0.0;
+  int anr = 1;
 
-ComplexMatrix
-operator - (const Complex& s, const Matrix& a)
-{
-  return ComplexMatrix (subtract (s, a.data (), a.length ()),
-			a.rows (), a.cols ());
+  double *c = new double [len * a_len];
+
+  F77_FCN (dgemm) (&transa, &transb, &len, &a_len, &anr, &alpha,
+		   v.data (), &len, a.data (), &anr, &beta, c, &len,
+		   1L, 1L); 
+
+  return Matrix (c, len, a_len);
 }
 
-ComplexMatrix
-operator * (const Complex& s, const Matrix& a)
+// diagonal matrix by scalar -> matrix operations
+
+Matrix
+operator + (const DiagMatrix& a, double s)
 {
-  return ComplexMatrix (multiply (a.data (), a.length (), s),
-			a.rows (), a.cols ());
-}
-
-ComplexMatrix
-operator / (const Complex& s, const Matrix& a)
-{
-  return ComplexMatrix (divide (s, a.data (), a.length ()),
-			a.rows (), a.cols ());
+  Matrix tmp (a.rows (), a.cols (), s);
+  return a + tmp;
 }
 
-// matrix by column vector -> column vector operations
-
-ColumnVector
-operator * (const Matrix& m, const ColumnVector& a)
+Matrix
+operator - (const DiagMatrix& a, double s)
 {
-  int nr = m.rows ();
-  int nc = m.cols ();
-  if (nc != a.length ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix multiplication attempted");
-      return ColumnVector ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ColumnVector (0);
-
-  char trans = 'N';
-  int ld = nr;
-  double alpha = 1.0;
-  double beta  = 0.0;
-  int i_one = 1;
-
-  double *y = new double [nr];
-
-  F77_FCN (dgemv) (&trans, &nr, &nc, &alpha, m.data (), &ld, a.data (),
-		   &i_one, &beta, y, &i_one, 1L); 
-
-  return ColumnVector (y, nr);
+  Matrix tmp (a.rows (), a.cols (), -s);
+  return a + tmp;
 }
 
-ComplexColumnVector
-operator * (const Matrix& m, const ComplexColumnVector& a)
+// scalar by diagonal matrix -> matrix operations
+
+Matrix
+operator + (double s, const DiagMatrix& a)
 {
-  ComplexMatrix tmp (m);
-  return tmp * a;
+  Matrix tmp (a.rows (), a.cols (), s);
+  return tmp + a;
+}
+
+Matrix
+operator - (double s, const DiagMatrix& a)
+{
+  Matrix tmp (a.rows (), a.cols (), s);
+  return tmp - a;
 }
 
 // matrix by diagonal matrix -> matrix operations
 
 Matrix
 operator + (const Matrix& m, const DiagMatrix& a)
 {
   int nr = m.rows ();
@@ -1501,108 +1409,108 @@ operator * (const Matrix& m, const DiagM
     {
       for (int i = nr * nc; i < nr * a_nc; i++)
 	ctmp[i] = 0.0;
     }
 
   return Matrix (c, nr, a_nc);
 }
 
-ComplexMatrix
-operator + (const Matrix& m, const ComplexDiagMatrix& a)
+// diagonal matrix by matrix -> matrix operations
+
+Matrix
+operator + (const DiagMatrix& m, const Matrix& a)
 {
   int nr = m.rows ();
   int nc = m.cols ();
   if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix addition attempted");
-      return ComplexMatrix ();
+      return Matrix ();
     }
 
   if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
+    return Matrix (nr, nc);
 
-  ComplexMatrix result (m);
-  for (int i = 0; i < a.length (); i++)
-    result.elem (i, i) += a.elem (i, i);
+  Matrix result (a);
+  for (int i = 0; i < m.length (); i++)
+    result.elem (i, i) += m.elem (i, i);
 
   return result;
 }
 
-ComplexMatrix
-operator - (const Matrix& m, const ComplexDiagMatrix& a)
+Matrix
+operator - (const DiagMatrix& m, const Matrix& a)
 {
   int nr = m.rows ();
   int nc = m.cols ();
   if (nr != a.rows () || nc != a.cols ())
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix subtraction attempted");
-      return ComplexMatrix ();
+      return Matrix ();
     }
 
   if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
+    return Matrix (nr, nc);
 
-  ComplexMatrix result (m);
-  for (int i = 0; i < a.length (); i++)
-    result.elem (i, i) -= a.elem (i, i);
+  Matrix result (-a);
+  for (int i = 0; i < m.length (); i++)
+    result.elem (i, i) += m.elem (i, i);
 
   return result;
 }
 
-ComplexMatrix
-operator * (const Matrix& m, const ComplexDiagMatrix& a)
+Matrix
+operator * (const DiagMatrix& m, const Matrix& a)
 {
   int nr = m.rows ();
   int nc = m.cols ();
   int a_nr = a.rows ();
   int a_nc = a.cols ();
   if (nc != a_nr)
     {
       (*current_liboctave_error_handler)
 	("nonconformant matrix multiplication attempted");
-      return ComplexMatrix ();
+      return Matrix ();
     }
 
   if (nr == 0 || nc == 0 || a_nc == 0)
-    return ComplexMatrix (nr, a_nc, 0.0);
+    return Matrix (nr, a_nc, 0.0);
 
-  Complex *c = new Complex [nr*a_nc];
-  Complex *ctmp = 0;
+  Matrix c (nr, a_nc);
 
-  for (int j = 0; j < a.length (); j++)
+  for (int i = 0; i < m.length (); i++)
     {
-      int idx = j * nr;
-      ctmp = c + idx;
-      if (a.elem (j, j) == 1.0)
+      if (m.elem (i, i) == 1.0)
 	{
-	  for (int i = 0; i < nr; i++)
-	    ctmp[i] = m.elem (i, j);
+	  for (int j = 0; j < a_nc; j++)
+	    c.elem (i, j) = a.elem (i, j);
 	}
-      else if (a.elem (j, j) == 0.0)
+      else if (m.elem (i, i) == 0.0)
 	{
-	  for (int i = 0; i < nr; i++)
-	    ctmp[i] = 0.0;
+	  for (int j = 0; j < a_nc; j++)
+	    c.elem (i, j) = 0.0;
 	}
       else
 	{
-	  for (int i = 0; i < nr; i++)
-	    ctmp[i] = a.elem (j, j) * m.elem (i, j);
+	  for (int j = 0; j < a_nc; j++)
+	    c.elem (i, j) = m.elem (i, i) * a.elem (i, j);
 	}
     }
 
-  if (a_nr < a_nc)
+  if (nr > nc)
     {
-      for (int i = nr * nc; i < nr * a_nc; i++)
-	ctmp[i] = 0.0;
+      for (int j = 0; j < a_nc; j++)
+	for (int i = a_nr; i < nr; i++)
+	  c.elem (i, j) = 0.0;
     }
 
-  return ComplexMatrix (c, nr, a_nc);
+  return c;
 }
 
 // matrix by matrix -> matrix operations
 
 Matrix
 operator * (const Matrix& m, const Matrix& a)
 {
   int nr = m.rows ();
@@ -1631,102 +1539,38 @@ operator * (const Matrix& m, const Matri
   double *c = new double [nr*a_nc];
 
   F77_FCN (dgemm) (&trans, &transa, &nr, &a_nc, &nc, &alpha, m.data (),
 		   &ld, a.data (), &lda, &beta, c, &nr, 1L, 1L);
 
   return Matrix (c, nr, a_nc);
 }
 
-ComplexMatrix
-operator * (const Matrix& m, const ComplexMatrix& a)
-{
-  ComplexMatrix tmp (m);
-  return tmp * a;
-}
-
-ComplexMatrix
-operator + (const Matrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix addition attempted");
-      return ComplexMatrix ();
-    }
-
-  return ComplexMatrix (add (m.data (), a.data (), m.length ()), nr, nc);
-}
-
-ComplexMatrix
-operator - (const Matrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix subtraction attempted");
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  return ComplexMatrix (subtract (m.data (), a.data (), m.length ()), nr, nc);
-}
-
-ComplexMatrix
-product (const Matrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix product attempted");
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  return ComplexMatrix (multiply (m.data (), a.data (), m.length ()), nr, nc);
-}
-
-ComplexMatrix
-quotient (const Matrix& m, const ComplexMatrix& a)
-{
-  int nr = m.rows ();
-  int nc = m.cols ();
-  if (nr != a.rows () || nc != a.cols ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant matrix quotient attempted");
-      return ComplexMatrix ();
-    }
-
-  if (nr == 0 || nc == 0)
-    return ComplexMatrix (nr, nc);
-
-  return ComplexMatrix (divide (m.data (), a.data (), m.length ()), nr, nc);
-}
-
 // other operations.
 
 Matrix
 map (d_d_Mapper f, const Matrix& a)
 {
   Matrix b (a);
   b.map (f);
   return b;
 }
 
+Matrix
+map (d_c_Mapper f, const ComplexMatrix& a)
+{
+  int a_nc = a.cols ();
+  int a_nr = a.rows ();
+  Matrix b (a_nr, a_nc);
+  for (int j = 0; j < a_nc; j++)
+    for (int i = 0; i < a_nr; i++)
+      b.elem (i, j) = f (a.elem (i, j));
+  return b;
+}
+
 void
 Matrix::map (d_d_Mapper f)
 {
   double *d = fortran_vec (); // Ensures only one reference to my privates!
 
   for (int i = 0; i < length (); i++)
     d[i] = f (d[i]);
 }
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -30,38 +30,36 @@ Software Foundation, 675 Mass Ave, Cambr
 #include "Array.h"
 
 #include "mx-defs.h"
 
 extern "C++" {
 
 class Matrix : public Array2<double>
 {
-friend class ColumnVector;
+friend class ComplexMatrix;
 friend class AEPBAL;
 friend class CHOL;
 friend class GEPBAL;
 friend class HESS;
 friend class LU;
 friend class QR;
 friend class QRP;
 friend class SCHUR;
 friend class SVD;
-friend class ComplexMatrix;
 
 public:
 
   Matrix (void) : Array2<double> () { }
   Matrix (int r, int c) : Array2<double> (r, c) { }
   Matrix (int r, int c, double val) : Array2<double> (r, c, val) { }
   Matrix (const Array2<double>& a) : Array2<double> (a) { }
   Matrix (const Matrix& a) : Array2<double> (a) { }
   Matrix (const DiagArray<double>& a) : Array2<double> (a) { }
   Matrix (const DiagMatrix& a);
-//  Matrix (double a) : Array2<double> (1, 1, a) { }
 
   Matrix& operator = (const Matrix& a)
     {
       Array2<double>::operator = (a);
       return *this;
     }
 
   int operator == (const Matrix& a) const;
@@ -84,16 +82,19 @@ public:
 
   Matrix stack (const Matrix& a) const;
   Matrix stack (const RowVector& a) const;
   Matrix stack (const ColumnVector& a) const;
   Matrix stack (const DiagMatrix& a) const;
 
   Matrix transpose (void) const;
 
+  friend Matrix real (const ComplexMatrix& a);
+  friend Matrix imag (const ComplexMatrix& a);
+
 // resize is the destructive equivalent for this one
 
   Matrix extract (int r1, int c1, int r2, int c2) const;
 
 // extract row or column i.
 
   RowVector row (int i) const;
   RowVector row (char *s) const;
@@ -157,63 +158,50 @@ public:
 
   Matrix& operator += (const DiagMatrix& a);
   Matrix& operator -= (const DiagMatrix& a);
 
 // unary operations
 
   Matrix operator ! (void) const;
 
-// matrix by scalar -> matrix operations
+// column vector by row vector -> matrix operations
 
-  friend ComplexMatrix operator + (const Matrix& a, const Complex& s);
-  friend ComplexMatrix operator - (const Matrix& a, const Complex& s);
-  friend ComplexMatrix operator * (const Matrix& a, const Complex& s);
-  friend ComplexMatrix operator / (const Matrix& a, const Complex& s);
+  friend Matrix operator * (const ColumnVector& a, const RowVector& a);
 
-// scalar by matrix -> matrix operations
+// diagonal matrix by scalar -> matrix operations
 
-  friend ComplexMatrix operator + (const Complex& s, const Matrix& a);
-  friend ComplexMatrix operator - (const Complex& s, const Matrix& a);
-  friend ComplexMatrix operator * (const Complex& s, const Matrix& a);
-  friend ComplexMatrix operator / (const Complex& s, const Matrix& a);
+  friend Matrix operator + (const DiagMatrix& a, double s);
+  friend Matrix operator - (const DiagMatrix& a, double s);
 
-// matrix by column vector -> column vector operations
+// scalar by diagonal matrix -> matrix operations
 
-  friend ColumnVector operator * (const Matrix& a, const ColumnVector& b);
-  friend ComplexColumnVector operator * (const Matrix& a,
-					 const ComplexColumnVector& b);
+  friend Matrix operator + (double s, const DiagMatrix& a);
+  friend Matrix operator - (double s, const DiagMatrix& a);
 
 // matrix by diagonal matrix -> matrix operations
 
   friend Matrix operator + (const Matrix& a, const DiagMatrix& b);
   friend Matrix operator - (const Matrix& a, const DiagMatrix& b);
   friend Matrix operator * (const Matrix& a, const DiagMatrix& b);
 
-  friend ComplexMatrix operator + (const Matrix& a,
-				   const ComplexDiagMatrix& b); 
-  friend ComplexMatrix operator - (const Matrix& a,
-				   const ComplexDiagMatrix& b);
-  friend ComplexMatrix operator * (const Matrix& a,
-				   const ComplexDiagMatrix& b);
+// diagonal matrix by matrix -> matrix operations
+
+  friend Matrix operator + (const DiagMatrix& a, const Matrix& b);
+  friend Matrix operator - (const DiagMatrix& a, const Matrix& b);
+  friend Matrix operator * (const DiagMatrix& a, const Matrix& b);
 
 // matrix by matrix -> matrix operations
 
   friend Matrix operator * (const Matrix& a, const Matrix& b);
-  friend ComplexMatrix operator * (const Matrix& a, const ComplexMatrix& b);
-
-  friend ComplexMatrix operator + (const Matrix& a, const ComplexMatrix& b);
-  friend ComplexMatrix operator - (const Matrix& a, const ComplexMatrix& b);
-
-  friend ComplexMatrix product (const Matrix& a, const ComplexMatrix& b);
-  friend ComplexMatrix quotient (const Matrix& a, const ComplexMatrix& b);
 
 // other operations
 
   friend Matrix map (d_d_Mapper f, const Matrix& a);
+  friend Matrix map (d_c_Mapper f, const ComplexMatrix& a);
   void map (d_d_Mapper f);
 
   Matrix all (void) const;
   Matrix any (void) const;
 
   Matrix cumprod (void) const;
   Matrix cumsum (void) const;
   Matrix prod (void) const;
diff --git a/liboctave/dRowVector.cc b/liboctave/dRowVector.cc
--- a/liboctave/dRowVector.cc
+++ b/liboctave/dRowVector.cc
@@ -54,56 +54,16 @@ extern "C"
 #define KLUDGE_VECTORS
 #define TYPE double
 #define KL_VEC_TYPE RowVector
 #include "mx-kludge.cc"
 #undef KLUDGE_VECTORS
 #undef TYPE
 #undef KL_VEC_TYPE
 
-#if 0
-RowVector&
-RowVector::resize (int n)
-{
-  if (n < 0)
-    {
-      (*current_liboctave_error_handler)
-	("can't resize to negative dimension");
-      return *this;
-    }
-
-  double *new_data = 0;
-  if (n > 0)
-    {
-      new_data = new double [n];
-      int min_len = len < n ? len : n;
-
-      for (int i = 0; i < min_len; i++)
-	new_data[i] = data[i];
-    }
-
-  delete [] data;
-  len = n;
-  data = new_data;
-
-  return *this;
-}
-
-RowVector&
-RowVector::resize (int n, double val)
-{
-  int old_len = len;
-  resize (n);
-  for (int i = old_len; i < len; i++)
-    data[i] = val;
-
-  return *this;
-}
-#endif
-
 int
 RowVector::operator == (const RowVector& a) const
 {
   int len = length ();
   if (len != a.length ())
     return 0;
   return equal (data (), a.data (), len);
 }
@@ -172,16 +132,36 @@ RowVector::append (const RowVector& a) c
 ColumnVector
 RowVector::transpose (void) const
 {
   int len = length ();
   return ColumnVector (dup (data (), len), len);
 }
 
 RowVector
+real (const ComplexRowVector& a)
+{
+  int a_len = a.length ();
+  RowVector retval;
+  if (a_len > 0)
+    retval = RowVector (real_dup (a.data (), a_len), a_len);
+  return retval;
+}
+
+RowVector
+imag (const ComplexRowVector& a)
+{
+  int a_len = a.length ();
+  RowVector retval;
+  if (a_len > 0)
+    retval = RowVector (imag_dup (a.data (), a_len), a_len);
+  return retval;
+}
+
+RowVector
 RowVector::extract (int c1, int c2) const
 {
   if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
 
   int new_c = c2 - c1 + 1;
 
   RowVector result (new_c);
 
@@ -228,96 +208,16 @@ RowVector::operator -= (const RowVector&
     return *this;
 
   double *d = fortran_vec (); // Ensures only one reference to my privates!
 
   subtract2 (d, a.data (), len);
   return *this;
 }
 
-// row vector by scalar -> row vector operations
-
-ComplexRowVector
-operator + (const RowVector& v, const Complex& s)
-{
-  int len = v.length ();
-  return ComplexRowVector (add (v.data (), len, s), len);
-}
-
-ComplexRowVector
-operator - (const RowVector& v, const Complex& s)
-{
-  int len = v.length ();
-  return ComplexRowVector (subtract (v.data (), len, s), len);
-}
-
-ComplexRowVector
-operator * (const RowVector& v, const Complex& s)
-{
-  int len = v.length ();
-  return ComplexRowVector (multiply (v.data (), len, s), len);
-}
-
-ComplexRowVector
-operator / (const RowVector& v, const Complex& s)
-{
-  int len = v.length ();
-  return ComplexRowVector (divide (v.data (), len, s), len);
-}
-
-// scalar by row vector -> row vector operations
-
-ComplexRowVector
-operator + (const Complex& s, const RowVector& a)
-{
-  return ComplexRowVector ();
-}
-
-ComplexRowVector
-operator - (const Complex& s, const RowVector& a)
-{
-  return ComplexRowVector ();
-}
-
-ComplexRowVector
-operator * (const Complex& s, const RowVector& a)
-{
-  return ComplexRowVector ();
-}
-
-ComplexRowVector
-operator / (const Complex& s, const RowVector& a)
-{
-  return ComplexRowVector ();
-}
-
-// row vector by column vector -> scalar
-
-double
-operator * (const RowVector& v, const ColumnVector& a)
-{
-  int len = v.length ();
-  if (len != a.length ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector multiplication attempted");
-      return 0.0;
-    }
-
-  int i_one = 1;
-  return F77_FCN (ddot) (&len, v.data (), &i_one, a.data (), &i_one);
-}
-
-Complex
-operator * (const RowVector& v, const ComplexColumnVector& a)
-{
-  ComplexRowVector tmp (v);
-  return tmp * a;
-}
-
 // row vector by matrix -> row vector
 
 RowVector
 operator * (const RowVector& v, const Matrix& a)
 {
   int len = v.length ();
   if (a.rows () != len)
     {
@@ -343,128 +243,43 @@ operator * (const RowVector& v, const Ma
   double *y = new double [len];
 
   F77_FCN (dgemv) (&trans, &a_nc, &a_nr, &alpha, a.data (), &ld,
 		   v.data (), &i_one, &beta, y, &i_one, 1L); 
 
   return RowVector (y, len);
 }
 
-ComplexRowVector
-operator * (const RowVector& v, const ComplexMatrix& a)
-{
-  ComplexRowVector tmp (v);
-  return tmp * a;
-}
-
-// row vector by row vector -> row vector operations
-
-ComplexRowVector
-operator + (const RowVector& v, const ComplexRowVector& a)
-{
-  int len = v.length ();
-  if (len != a.length ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector addition attempted");
-      return ComplexRowVector ();
-    }
-
-  if (len == 0)
-    return ComplexRowVector (0);
-
-  return ComplexRowVector (add (v.data (), a.data (), len), len);
-}
-
-ComplexRowVector
-operator - (const RowVector& v, const ComplexRowVector& a)
-{
-  int len = v.length ();
-  if (len != a.length ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector subtraction attempted");
-      return ComplexRowVector ();
-    }
-
-  if (len == 0)
-    return ComplexRowVector (0);
-
-  return ComplexRowVector (subtract (v.data (), a.data (), len), len);
-}
-
-ComplexRowVector
-product (const RowVector& v, const ComplexRowVector& a)
-{
-  int len = v.length ();
-  if (len != a.length ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector product attempted");
-      return ComplexRowVector ();
-    }
-
-  if (len == 0)
-    return ComplexRowVector (0);
-
-  return ComplexRowVector (multiply (v.data (), a.data (), len), len);
-}
-
-ComplexRowVector
-quotient (const RowVector& v, const ComplexRowVector& a)
-{
-  int len = v.length ();
-  if (len != a.length ())
-    {
-      (*current_liboctave_error_handler)
-	("nonconformant vector quotient attempted");
-      return ComplexRowVector ();
-    }
-
-  if (len == 0)
-    return ComplexRowVector (0);
-
-  return ComplexRowVector (divide (v.data (), a.data (), len), len);
-}
-
 // other operations
 
 RowVector
 map (d_d_Mapper f, const RowVector& a)
 {
   RowVector b (a);
   b.map (f);
   return b;
 }
 
+RowVector
+map (d_c_Mapper f, const ComplexRowVector& a)
+{
+  int a_len = a.length ();
+  RowVector b (a_len);
+  for (int i = 0; i < a_len; i++)
+    b.elem (i) = f (a.elem (i));
+  return b;
+}
+
 void
 RowVector::map (d_d_Mapper f)
 {
   for (int i = 0; i < length (); i++)
     elem (i) = f (elem (i));
 }
 
-RowVector
-linspace (double x1, double x2, int n)
-{
-  RowVector retval;
-
-  if (n > 0)
-    {
-      retval.resize (n);
-      double delta = (x2 - x1) / (n - 1);
-      retval.elem (0) = x1;
-      for (int i = 1; i < n-1; i++)
-	retval.elem (i) = x1 + i * delta;
-      retval.elem (n-1) = x2;
-    }
-
-  return retval;
-}
-
 double
 RowVector::min (void) const
 {
   int len = length ();
   if (len == 0)
     return 0;
 
   double res = elem (0);
@@ -518,14 +333,58 @@ operator >> (istream& is, RowVector& a)
             a.elem (i) = tmp;
           else
             break;
         }
     }
   return is;
 }
 
+// other operations
+
+RowVector
+linspace (double x1, double x2, int n)
+{
+  RowVector retval;
+
+  if (n > 0)
+    {
+      retval.resize (n);
+      double delta = (x2 - x1) / (n - 1);
+      retval.elem (0) = x1;
+      for (int i = 1; i < n-1; i++)
+	retval.elem (i) = x1 + i * delta;
+      retval.elem (n-1) = x2;
+    }
+
+  return retval;
+}
+
+// row vector by column vector -> scalar
+
+double
+operator * (const RowVector& v, const ColumnVector& a)
+{
+  int len = v.length ();
+  if (len != a.length ())
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector multiplication attempted");
+      return 0.0;
+    }
+
+  int i_one = 1;
+  return F77_FCN (ddot) (&len, v.data (), &i_one, a.data (), &i_one);
+}
+
+Complex
+operator * (const RowVector& v, const ComplexColumnVector& a)
+{
+  ComplexRowVector tmp (v);
+  return tmp * a;
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/liboctave/dRowVector.h b/liboctave/dRowVector.h
--- a/liboctave/dRowVector.h
+++ b/liboctave/dRowVector.h
@@ -28,100 +28,65 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #include "mx-defs.h"
 
 extern "C++" {
 
 class RowVector : public Array<double>
 {
 friend class ColumnVector;
-friend class ComplexRowVector;
 
 public:
 
   RowVector (void) : Array<double> () { }
   RowVector (int n) : Array<double> (n) { }
   RowVector (int n, double val) : Array<double> (n, val) { }
   RowVector (const Array<double>& a) : Array<double> (a) { }
   RowVector (const RowVector& a) : Array<double> (a) { }
-//  RowVector (double a) : Array<double> (1, a) { }
 
   RowVector& operator = (const RowVector& a)
     {
       Array<double>::operator = (a);
       return *this;
     }
 
-//  operator Array<double>& () const { return *this; }
-
   int operator == (const RowVector& a) const;
   int operator != (const RowVector& a) const;
 
 // destructive insert/delete/reorder operations
 
   RowVector& insert (const RowVector& a, int c);
 
   RowVector& fill (double val);
   RowVector& fill (double val, int c1, int c2);
 
   RowVector append (const RowVector& a) const;
 
   ColumnVector transpose (void) const;
 
+  friend RowVector real (const ComplexRowVector& a);
+  friend RowVector imag (const ComplexRowVector& a);
+
 // resize is the destructive equivalent for this one
 
   RowVector extract (int c1, int c2) const;
 
 // row vector by row vector -> row vector operations
 
   RowVector& operator += (const RowVector& a);
   RowVector& operator -= (const RowVector& a);
 
-// row vector by scalar -> row vector operations
-
-  friend ComplexRowVector operator + (const RowVector& a, const Complex& s);
-  friend ComplexRowVector operator - (const RowVector& a, const Complex& s);
-  friend ComplexRowVector operator * (const RowVector& a, const Complex& s);
-  friend ComplexRowVector operator / (const RowVector& a, const Complex& s);
-
-// scalar by row vector -> row vector operations
-
-  friend ComplexRowVector operator + (const Complex& s, const RowVector& a);
-  friend ComplexRowVector operator - (const Complex& s, const RowVector& a);
-  friend ComplexRowVector operator * (const Complex& s, const RowVector& a);
-  friend ComplexRowVector operator / (const Complex& s, const RowVector& a);
-
-// row vector by column vector -> scalar
-
-  friend double operator * (const RowVector& a, const ColumnVector& b);
-
-  friend Complex operator * (const RowVector& a, const ComplexColumnVector& b);
-
 // row vector by matrix -> row vector
 
   friend RowVector operator * (const RowVector& a, const Matrix& b);
 
-  friend ComplexRowVector operator * (const RowVector& a,
-				      const ComplexMatrix& b);
-
-// row vector by row vector -> row vector operations
-
-  friend ComplexRowVector operator + (const RowVector& a,
-				      const ComplexRowVector& b);
-  friend ComplexRowVector operator - (const RowVector& a,
-				      const ComplexRowVector& b);
-
-  friend ComplexRowVector product (const RowVector& a,
-				   const ComplexRowVector& b);
-  friend ComplexRowVector quotient (const RowVector& a,
-				    const ComplexRowVector& b);
-
 // other operations
 
   friend RowVector map (d_d_Mapper f, const RowVector& a);
+  friend RowVector map (d_c_Mapper f, const ComplexRowVector& a);
   void map (d_d_Mapper f);
 
   double min (void) const;
   double max (void) const;
 
 // i/o
 
   friend ostream& operator << (ostream& os, const RowVector& a);
@@ -135,16 +100,24 @@ public:
 #undef TYPE
 #undef KL_VEC_TYPE
 
 private:
 
   RowVector (double *d, int l) : Array<double> (d, l) { }
 };
 
+// row vector by column vector -> scalar
+
+double operator * (const RowVector& a, const ColumnVector& b);
+
+Complex operator * (const RowVector& a, const ComplexColumnVector& b);
+
+// other operations
+
 RowVector linspace (double x1, double x2, int n);
 
 } // extern "C++"
 
 #endif
 
 /*
 ;;; Local Variables: ***
