# HG changeset patch
# User Rik <rik@octave.org>
# Date 1450144407 28800
#      Mon Dec 14 17:53:27 2015 -0800
# Node ID 8da80da1ac37eef20ebc65da5b169448947d48b7
# Parent  9aad16a799c941536b253b98f1263bb61de679e2
maint: Use ovl() more places in the code.

diff --git a/libinterp/corefcn/det.cc b/libinterp/corefcn/det.cc
--- a/libinterp/corefcn/det.cc
+++ b/libinterp/corefcn/det.cc
@@ -140,34 +140,32 @@ For that, use any of the condition numbe
         retval(1) = 1.0;
     }
   else if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
         {
           octave_idx_type info;
           float rcond = 0.0;
-          // Always compute rcond, so we can detect numerically
-          // singular matrices.
+          // Always compute rcond, so we can detect singular matrices.
           FloatMatrix m = arg.float_matrix_value ();
 
           MAYBE_CAST (rep, octave_float_matrix);
           MatrixType mtype = rep ? rep -> matrix_type () : MatrixType ();
           FloatDET det = m.determinant (mtype, info, rcond);
           retval(0) = info == -1 ? 0.0f : det.value ();
           retval(1) = rcond;
           if (rep)
             rep->matrix_type (mtype);
         }
       else if (arg.is_complex_type ())
         {
           octave_idx_type info;
           float rcond = 0.0;
-          // Always compute rcond, so we can detect numerically
-          // singular matrices.
+          // Always compute rcond, so we can detect singular matrices.
           FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
           MAYBE_CAST (rep, octave_float_complex_matrix);
           MatrixType mtype = rep ? rep -> matrix_type () : MatrixType ();
           FloatComplexDET det = m.determinant (mtype, info, rcond);
           retval(0) = info == -1 ? FloatComplex (0.0) : det.value ();
           retval(1) = rcond;
           if (rep)
@@ -175,18 +173,17 @@ For that, use any of the condition numbe
         }
     }
   else
     {
       if (arg.is_real_type ())
         {
           octave_idx_type info;
           double rcond = 0.0;
-          // Always compute rcond, so we can detect numerically
-          // singular matrices.
+          // Always compute rcond, so we can detect singular matrices.
           if (arg.is_sparse_type ())
             {
               SparseMatrix m = arg.sparse_matrix_value ();
 
               DET det = m.determinant (info, rcond);
               retval(0) = info == -1 ? 0.0 : det.value ();
               retval(1) = rcond;
             }
@@ -203,18 +200,17 @@ For that, use any of the condition numbe
               if (rep)
                 rep->matrix_type (mtype);
             }
         }
       else if (arg.is_complex_type ())
         {
           octave_idx_type info;
           double rcond = 0.0;
-          // Always compute rcond, so we can detect numerically
-          // singular matrices.
+          // Always compute rcond, so we can detect singular matrices.
           if (arg.is_sparse_type ())
             {
               SparseComplexMatrix m = arg.sparse_complex_matrix_value ();
 
               ComplexDET det = m.determinant (info, rcond);
               retval(0) = info == -1 ? Complex (0.0) : det.value ();
               retval(1) = rcond;
             }
diff --git a/libinterp/corefcn/dirfns.cc b/libinterp/corefcn/dirfns.cc
--- a/libinterp/corefcn/dirfns.cc
+++ b/libinterp/corefcn/dirfns.cc
@@ -172,34 +172,30 @@ strings.\n\
 \n\
 If an error occurs, return an empty cell array in @var{files}.\n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{ls, dir, glob, what}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 1)
     print_usage ();
 
-  retval(2) = std::string ();
-  retval(1) = -1.0;
-  retval(0) = Cell ();
+  std::string dirname = args(0).xstring_value ("readdir: DIR must be a string");
 
-  std::string dirname = args(0).xstring_value ("readdir: DIR must be a string");
+  octave_value_list retval = ovl (Cell (), -1.0, "");
 
   dir_entry dir (dirname);
 
   if (dir)
     {
       string_vector dirlist = dir.read ();
+      retval(0) = Cell (dirlist.sort ());
       retval(1) = 0.0;
-      retval(0) = Cell (dirlist.sort ());
     }
   else
     retval(2) = dir.error ();
 
   return retval;
 }
 
 // FIXME: should maybe also allow second arg to specify mode?
@@ -220,68 +216,53 @@ character strings ("").  Otherwise, @var
 system-dependent error message, and @var{msgid} contains a unique message\n\
 identifier.\n\
 \n\
 When creating a directory permissions will be set to\n\
 @code{0777 - @var{umask}}.\n\
 @seealso{rmdir, pwd, cd, umask}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
-  retval(2) = std::string ();
-  retval(1) = std::string ();
-  retval(0) = false;
-
   std::string dirname;
 
   if (nargin == 2)
     {
       std::string parent = args(0).xstring_value ("mkdir: PARENT must be a string");
       std::string dir = args(1).xstring_value ("mkdir: DIR must be a string");
 
       dirname = file_ops::concat (parent, dir);
     }
   else if (nargin == 1)
     dirname = args(0).xstring_value ("mkdir: DIR must be a string");
 
-  std::string msg;
-
   dirname = file_ops::tilde_expand (dirname);
 
   file_stat fs (dirname);
 
   if (fs && fs.is_dir ())
     {
-      // For compatibility with Matlab, we return true when the
-      // directory already exists.
-
-      retval(2) = "mkdir";
-      retval(1) = "directory exists";
-      retval(0) = true;
+      // For Matlab compatibility, return true when directory already exists.
+      return ovl (true, "directory exists", "mkdir");
     }
   else
     {
+      std::string msg;
+
       int status = octave_mkdir (dirname, 0777, msg);
 
       if (status < 0)
-        {
-          retval(2) = "mkdir";
-          retval(1) = msg;
-        }
+        return ovl (false, msg, "mkdir");
       else
-        retval(0) = true;
+        return ovl (true, "", "");
     }
-
-  return retval;
 }
 
 DEFUNX ("rmdir", Frmdir, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {} {} rmdir @var{dir}\n\
 @deftypefnx {} {} rmdir (@var{dir}, \"s\")\n\
 @deftypefnx {} {[@var{status}, @var{msg}, @var{msgid}] =} rmdir (@dots{})\n\
 Remove the directory named @var{dir}.\n\
@@ -292,209 +273,163 @@ recursively remove all subdirectories as
 If successful, @var{status} is 1, and @var{msg}, @var{msgid} are empty\n\
 character strings ("").  Otherwise, @var{status} is 0, @var{msg} contains a\n\
 system-dependent error message, and @var{msgid} contains a unique message\n\
 identifier.\n\
 \n\
 @seealso{mkdir, confirm_recursive_rmdir, pwd}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
-  retval(2) = std::string ();
-  retval(1) = std::string ();
-  retval(0) = false;
-
   std::string dirname = args(0).xstring_value ("rmdir: DIR must be a string");
 
   std::string fulldir = file_ops::tilde_expand (dirname);
   int status = -1;
   std::string msg;
 
   if (nargin == 2)
     {
-      if (args(1).string_value () == "s")
-        {
-          bool doit = true;
+      if (args(1).string_value () != "s")
+        error ("rmdir: second argument must be \"s\" for recursive removal");
+
+      bool doit = true;
 
-          if (interactive && ! forced_interactive
-              && Vconfirm_recursive_rmdir)
-            {
-              std::string prompt
-                = "remove entire contents of " + fulldir + "? ";
+      if (interactive && ! forced_interactive && Vconfirm_recursive_rmdir)
+        {
+          std::string prompt = "remove entire contents of " + fulldir + "? ";
 
-              doit = octave_yes_or_no (prompt);
-            }
+          doit = octave_yes_or_no (prompt);
+        }
 
-          if (doit)
-            status = octave_recursive_rmdir (fulldir, msg);
-        }
-      else
-        error ("rmdir: second argument must be \"s\" for recursive removal");
+      if (doit)
+        status = octave_recursive_rmdir (fulldir, msg);
     }
   else
     status = octave_rmdir (fulldir, msg);
 
   if (status < 0)
-    {
-      retval(2) = "rmdir";
-      retval(1) = msg;
-    }
+    return ovl (false, msg, "rmdir");
   else
-    retval(0) = true;
-
-  return retval;
+    return ovl (true, "", "");
 }
 
 DEFUNX ("link", Flink, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {} {} link @var{old} @var{new}\n\
 @deftypefnx {} {[@var{err}, @var{msg}] =} link (@var{old}, @var{new})\n\
 Create a new link (also known as a hard link) to an existing file.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{symlink, unlink, readlink, lstat}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 2)
     print_usage ();
 
-  retval(1) = std::string ();
-  retval(0) = -1.0;
-
   std::string from = args(0).xstring_value ("link: OLD must be a string");
   std::string to = args(1).xstring_value ("link: NEW must be a string");
 
   std::string msg;
 
   int status = octave_link (from, to, msg);
 
   if (status < 0)
-    retval(1) = msg;
-
-  retval(0) = status;
-
-  return retval;
+    return ovl (-1.0, msg);
+  else
+    return ovl (status, "");
 }
 
 DEFUNX ("symlink", Fsymlink, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {} {} symlink @var{old} @var{new}\n\
 @deftypefnx {} {[@var{err}, @var{msg}] =} symlink (@var{old}, @var{new})\n\
 Create a symbolic link @var{new} which contains the string @var{old}.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{link, unlink, readlink, lstat}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 2)
     print_usage ();
 
-  retval(1) = std::string ();
-  retval(0) = -1.0;
-
   std::string from = args(0).xstring_value ("symlink: OLD must be a string");
   std::string to = args(1).xstring_value ("symlink: NEW must be a string");
 
   std::string msg;
 
   int status = octave_symlink (from, to, msg);
 
   if (status < 0)
-    retval(1) = msg;
-
-  retval(0) = status;
-
-  return retval;
+    return ovl (-1.0, msg);
+  else
+    return ovl (status, "");
 }
 
 DEFUNX ("readlink", Freadlink, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {} {} readlink @var{symlink}\n\
 @deftypefnx {} {[@var{result}, @var{err}, @var{msg}] =} readlink (@var{symlink})\n\
 Read the value of the symbolic link @var{symlink}.\n\
 \n\
 If successful, @var{result} contains the contents of the symbolic link\n\
 @var{symlink}, @var{err} is 0, and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{lstat, symlink, link, unlink, delete}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 1)
     print_usage ();
 
-  retval(2) = std::string ();
-  retval(1) = -1.0;
-  retval(0) = std::string ();
-
   std::string symlink = args(0).xstring_value ("readlink: SYMLINK must be a string");
 
-  std::string result;
-  std::string msg;
+  std::string result, msg;
 
   int status = octave_readlink (symlink, result, msg);
 
   if (status < 0)
-    retval(2) = msg;
-
-  retval(1) = status;
-  retval(0) = result;
-
-  return retval;
+    return ovl ("", -1.0, msg);
+  else
+    return ovl (result, status, "");
 }
 
 DEFUNX ("rename", Frename, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {} {} rename @var{old} @var{new}\n\
 @deftypefnx {} {[@var{err}, @var{msg}] =} rename (@var{old}, @var{new})\n\
 Change the name of file @var{old} to @var{new}.\n\
 \n\
 If successful, @var{err} is 0 and @var{msg} is an empty string.\n\
 Otherwise, @var{err} is nonzero and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{movefile, copyfile, ls, dir}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 2)
     print_usage ();
 
-  retval(1) = std::string ();
-  retval(0) = -1.0;
-
   std::string from = args(0).xstring_value ("rename: OLD must be a string");
   std::string to = args(1).xstring_value ("rename: NEW must be a string");
 
   std::string msg;
 
   int status = octave_rename (from, to, msg);
 
   if (status < 0)
-    retval(1) = msg;
-
-  retval(0) = status;
-
-  return retval;
+    return ovl (-1.0, msg);
+  else
+    return ovl (status, "");
 }
 
 DEFUN (glob, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} glob (@var{pattern})\n\
 Given an array of pattern strings (as a char array or a cell array) in\n\
 @var{pattern}, return a cell array of filenames that match any of\n\
 them, or an empty cell array if no patterns match.\n\
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -970,60 +970,53 @@ string, automatically sized to hold all 
 Implementation Note: For compatibility with @sc{matlab}, escape sequences in\n\
 the template string (e.g., @qcode{\"@xbackslashchar{}n\"} => newline) are\n\
 expanded even when the template string is defined with single quotes.\n\
 @seealso{printf, fprintf, sscanf}\n\
 @end deftypefn")
 {
   static std::string who = "sprintf";
 
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin == 0)
     print_usage ();
 
-  retval = ovl ("", "unknown error", -1.0);
-
   octave_ostrstream *ostr = new octave_ostrstream ();
 
   octave_stream os (ostr);
 
-  if (os.is_valid ())
-    {
-      octave_value fmt_arg = args(0);
+  if (! os.is_valid ())
+    error ("%s: unable to create output buffer", who.c_str ());
 
-      if (fmt_arg.is_string ())
-        {
-          octave_value_list tmp_args;
+  octave_value fmt_arg = args(0);
 
-          if (nargin > 1)
-            {
-              tmp_args.resize (nargin-1, octave_value ());
+  if (! fmt_arg.is_string ())
+    error ("%s: format TEMPLATE must be a string", who.c_str ());
 
-              for (int i = 1; i < nargin; i++)
-                tmp_args(i-1) = args(i);
-            }
+  octave_value_list retval (3);
 
-          retval(2) = os.printf (fmt_arg, tmp_args, who);
-          retval(1) = os.error ();
+  octave_value_list tmp_args;
+  if (nargin > 1)
+    {
+      tmp_args.resize (nargin-1, octave_value ());
 
-          std::string result = ostr->str ();
-          char type = fmt_arg.is_sq_string () ? '\'' : '"';
+      for (int i = 1; i < nargin; i++)
+        tmp_args(i-1) = args(i);
+    }
 
-          retval(0) = (result.empty ()
-                       ? octave_value (charMatrix (1, 0), type)
-                       : octave_value (result, type));
-        }
-      else
-        error ("%s: format TEMPLATE must be a string", who.c_str ());
-    }
-  else
-    error ("%s: unable to create output buffer", who.c_str ());
+  // NOTE: Call to os.error must precede next call to ostr which might reset it.
+  retval(2) = os.printf (fmt_arg, tmp_args, who);
+  retval(1) = os.error ();
+
+  std::string result = ostr->str ();
+  char type = fmt_arg.is_sq_string () ? '\'' : '"';
+
+  retval(0) = (result.empty () ? octave_value (charMatrix (1, 0), type)
+                               : octave_value (result, type));
 
   return retval;
 }
 
 DEFUN (fscanf, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {[@var{val}, @var{count}, @var{errmsg}] =} fscanf (@var{fid}, @var{template}, @var{size})\n\
 @deftypefnx {} {[@var{v1}, @var{v2}, @dots{}, @var{count}, @var{errmsg}] =} fscanf (@var{fid}, @var{template}, \"C\")\n\
diff --git a/libinterp/corefcn/inv.cc b/libinterp/corefcn/inv.cc
--- a/libinterp/corefcn/inv.cc
+++ b/libinterp/corefcn/inv.cc
@@ -56,34 +56,32 @@ If called with a sparse matrix, then in 
 matrix requiring significantly more storage.  Avoid forming the inverse of a\n\
 sparse matrix if possible.\n\
 @seealso{ldivide, rdivide}\n\
 @end deftypefn")
 {
   if (args.length () != 1)
     print_usage ();
 
-  octave_value_list retval;
-
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("inverse", nr, nc);
 
   if (arg_is_empty < 0)
-    return retval;
+    return octave_value_list ();
   else if (arg_is_empty > 0)
     return octave_value (Matrix ());
 
   if (nr != nc)
     {
       gripe_square_matrix_required ("inverse");
-      return retval;
+      return octave_value_list ();
     }
 
   octave_value result;
   octave_idx_type info;
   double rcond = 0.0;
   float frcond = 0.0;
   bool isfloat = arg.is_single_type ();
 
@@ -186,21 +184,22 @@ sparse matrix if possible.\n\
               result = m.inverse (mattyp, info, rcond, 1);
               args(0).matrix_type (mattyp);
             }
         }
       else
         gripe_wrong_type_arg ("inv", arg);
     }
 
+  octave_value_list retval (nargout > 1 ? 2 : 1);
+
+  retval(0) = result;
   if (nargout > 1)
     retval(1) = isfloat ? octave_value (frcond) : octave_value (rcond);
 
-  retval(0) = result;
-
   bool rcond_plus_one_eq_one = false;
 
   if (isfloat)
     {
       volatile float xrcond = frcond;
       rcond_plus_one_eq_one = xrcond + 1.0F == 1.0F;
     }
   else
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -256,34 +256,32 @@ After a successful computation, the valu
 If the computation is not successful, @var{istate} will be something\n\
 other than 2 and @var{msg} will contain additional information.\n\
 \n\
 You can use the function @code{lsode_options} to set optional\n\
 parameters for @code{lsode}.\n\
 @seealso{daspk, dassl, dasrt}\n\
 @end deftypefn")
 {
-  octave_value_list retval (3);
+  int nargin = args.length ();
+
+  if (nargin < 3 || nargin > 4 || nargout > 3)
+    print_usage ();
 
   warned_fcn_imaginary = false;
   warned_jac_imaginary = false;
 
   unwind_protect frame;
 
   frame.protect_var (call_depth);
   call_depth++;
 
   if (call_depth > 1)
     error ("lsode: invalid recursive call");
 
-  int nargin = args.length ();
-
-  if (nargin < 3 || nargin > 4 || nargout > 3)
-    print_usage ();
-
   std::string fcn_name, fname, jac_name, jname;
   lsode_fcn = 0;
   lsode_jac = 0;
 
   octave_value f_arg = args(0);
 
   if (f_arg.is_cell ())
     {
@@ -422,16 +420,18 @@ parameters for @code{lsode}.\n\
 
   if (fcn_name.length ())
     clear_function (fcn_name);
   if (jac_name.length ())
     clear_function (jac_name);
 
   std::string msg = ode.error_message ();
 
+  octave_value_list retval (3);
+
   if (ode.integration_ok ())
     retval(0) = output;
   else if (nargout < 2)
     error ("lsode: %s", msg.c_str ());
   else
     retval(0) = Matrix ();
 
   retval(1) = static_cast<double> (ode.integration_state ());
diff --git a/libinterp/corefcn/lu.cc b/libinterp/corefcn/lu.cc
--- a/libinterp/corefcn/lu.cc
+++ b/libinterp/corefcn/lu.cc
@@ -631,17 +631,16 @@ factorization from scratch.\n\
   if (! (argl.is_numeric_type () && argu.is_numeric_type ()
          && argx.is_numeric_type () && argy.is_numeric_type ()
          && (! pivoted || argp.is_perm_matrix ())))
     error ("luupdate: L, U, X, and Y must be numeric");
 
   if (! check_lu_dims (argl, argu, argp))
     error ("luupdate: dimension mismatch");
 
-  octave_value_list retval;
   PermMatrix P = (pivoted
                   ? argp.perm_matrix_value ()
                   : PermMatrix::eye (argl.rows ()));
 
   if (argl.is_real_type () && argu.is_real_type ()
       && argx.is_real_type () && argy.is_real_type ())
     {
       // all real case
@@ -655,37 +654,37 @@ factorization from scratch.\n\
 
           FloatLU fact (L, U, P);
           if (pivoted)
             fact.update_piv (x, y);
           else
             fact.update (x, y);
 
           if (pivoted)
-            retval(2) = fact.P ();
-          retval(1) = get_lu_u (fact);
-          retval(0) = get_lu_l (fact);
+            return ovl (get_lu_l (fact), get_lu_u (fact), fact.P ());
+          else
+            return ovl (get_lu_l (fact), get_lu_u (fact));
         }
       else
         {
           Matrix L = argl.matrix_value ();
           Matrix U = argu.matrix_value ();
           Matrix x = argx.matrix_value ();
           Matrix y = argy.matrix_value ();
 
           LU fact (L, U, P);
           if (pivoted)
             fact.update_piv (x, y);
           else
             fact.update (x, y);
 
           if (pivoted)
-            retval(2) = fact.P ();
-          retval(1) = get_lu_u (fact);
-          retval(0) = get_lu_l (fact);
+            return ovl (get_lu_l (fact), get_lu_u (fact), fact.P ());
+          else
+            return ovl (get_lu_l (fact), get_lu_u (fact));
         }
     }
   else
     {
       // complex case
       if (argl.is_single_type () || argu.is_single_type ()
           || argx.is_single_type () || argy.is_single_type ())
         {
@@ -696,41 +695,39 @@ factorization from scratch.\n\
 
           FloatComplexLU fact (L, U, P);
           if (pivoted)
             fact.update_piv (x, y);
           else
             fact.update (x, y);
 
           if (pivoted)
-            retval(2) = fact.P ();
-          retval(1) = get_lu_u (fact);
-          retval(0) = get_lu_l (fact);
+            return ovl (get_lu_l (fact), get_lu_u (fact), fact.P ());
+          else
+            return ovl (get_lu_l (fact), get_lu_u (fact));
         }
       else
         {
           ComplexMatrix L = argl.complex_matrix_value ();
           ComplexMatrix U = argu.complex_matrix_value ();
           ComplexMatrix x = argx.complex_matrix_value ();
           ComplexMatrix y = argy.complex_matrix_value ();
 
           ComplexLU fact (L, U, P);
           if (pivoted)
             fact.update_piv (x, y);
           else
             fact.update (x, y);
 
           if (pivoted)
-            retval(2) = fact.P ();
-          retval(1) = get_lu_u (fact);
-          retval(0) = get_lu_l (fact);
+            return ovl (get_lu_l (fact), get_lu_u (fact), fact.P ());
+          else
+            return ovl (get_lu_l (fact), get_lu_u (fact));
         }
     }
-
-  return retval;
 }
 
 /*
 %!shared A, u, v, Ac, uc, vc
 %! A = [0.091364  0.613038  0.999083;
 %!      0.594638  0.425302  0.603537;
 %!      0.383594  0.291238  0.085574;
 %!      0.265712  0.268003  0.238409;
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -189,226 +189,206 @@ Undocumented internal function.\n\
 }
 
 DEFUN (__octave_link_file_dialog__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __octave_link_file_dialog__ (@var{filterlist}, @var{title}, @var{filename}, @var{size} @var{multiselect}, @var{pathname})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  if (args.length () != 6)
+    return octave_value_list ();
 
-  if (args.length () == 6)
-    {
+  octave_value_list retval (3);
 
-      const Array<std::string> flist = args(0).cellstr_value ();
-      std::string title = args(1).string_value ();
-      std::string filename = args(2).string_value ();
-      Matrix pos = args(3).matrix_value ();
-      std::string multi_on = args(4).string_value (); // on, off, create
-      std::string pathname = args(5).string_value ();
-
-      octave_idx_type nel;
-      octave_link::filter_list filter_lst;
+  const Array<std::string> flist = args(0).cellstr_value ();
+  std::string title = args(1).string_value ();
+  std::string filename = args(2).string_value ();
+  Matrix pos = args(3).matrix_value ();
+  std::string multi_on = args(4).string_value (); // on, off, create
+  std::string pathname = args(5).string_value ();
 
-      for (octave_idx_type i = 0; i < flist.rows (); i++)
-        filter_lst.push_back (std::make_pair (flist(i,0),
-                                              (flist.columns () > 1
-                                               ? flist(i,1) : "")));
+  octave_idx_type nel;
+  octave_link::filter_list filter_lst;
 
-      flush_octave_stdout ();
+  for (octave_idx_type i = 0; i < flist.rows (); i++)
+    filter_lst.push_back (std::make_pair (flist(i,0),
+                                          (flist.columns () > 1
+                                           ? flist(i,1) : "")));
 
-      std::list<std::string> items_lst
-        = octave_link::file_dialog (filter_lst, title, filename, pathname,
-                                    multi_on);
+  flush_octave_stdout ();
 
-      nel = items_lst.size ();
+  std::list<std::string> items_lst
+    = octave_link::file_dialog (filter_lst, title, filename, pathname,
+                                multi_on);
 
-      retval.resize (3);
+  nel = items_lst.size ();
 
-      // If 3, then retval is filename, directory, and selected index.
-      if (nel <= 3)
+  // If 3, then retval is filename, directory, and selected index.
+  if (nel <= 3)
+    {
+      int idx = 0;
+      for (std::list<std::string>::iterator it = items_lst.begin ();
+           it != items_lst.end (); it++)
         {
-          int idx = 0;
-          for (std::list<std::string>::iterator it = items_lst.begin ();
-               it != items_lst.end (); it++)
-            {
-              retval(idx++) = *it;
+          retval(idx++) = *it;
 
-              if (idx == 1 && retval(0).string_value ().length () == 0)
-                retval(0) = 0;
+          if (idx == 1 && retval(0).string_value ().length () == 0)
+            retval(0) = 0;
 
-              if (idx == 3)
-                retval(2) = atoi (retval(2).string_value ().c_str ());
-            }
+          if (idx == 3)
+            retval(2) = atoi (retval(2).string_value ().c_str ());
         }
-      else
-        {
-          // Multiple files.
-          nel = items_lst.size () - 2;
-          Cell items (dim_vector (1, nel));
-
-          std::list<std::string>::iterator it = items_lst.begin ();
+    }
+  else
+    {
+      // Multiple files.
+      nel = items_lst.size () - 2;
+      Cell items (dim_vector (1, nel));
 
-          for (int idx = 0; idx < nel; idx++)
-            {
-              items.xelem (idx) = *it;
-              it++;
-            }
+      std::list<std::string>::iterator it = items_lst.begin ();
 
-          retval = ovl (items, *it++, atoi (it->c_str ()));
+      for (int idx = 0; idx < nel; idx++)
+        {
+          items.xelem (idx) = *it;
+          it++;
         }
+
+      retval = ovl (items, *it++, atoi (it->c_str ()));
     }
 
   return retval;
 }
 
 DEFUN (__octave_link_list_dialog__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __octave_link_list_dialog__ (@var{list}, @var{mode}, @var{size}, @var{intial}, @var{name}, @var{prompt}, @var{ok_string}, @var{cancel_string})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+  if (args.length () != 8)
+    return octave_value_list ();
 
-  if (args.length () == 8)
-    {
-      Cell list = args(0).cell_value ();
-      const Array<std::string> tlist = list.cellstr_value ();
-      octave_idx_type nel = tlist.numel ();
-      std::list<std::string> list_lst;
-      for (octave_idx_type i = 0; i < nel; i++)
-        list_lst.push_back (tlist(i));
+  Cell list = args(0).cell_value ();
+  const Array<std::string> tlist = list.cellstr_value ();
+  octave_idx_type nel = tlist.numel ();
+  std::list<std::string> list_lst;
+  for (octave_idx_type i = 0; i < nel; i++)
+    list_lst.push_back (tlist(i));
 
-      std::string mode = args(1).string_value ();
+  std::string mode = args(1).string_value ();
 
-      Matrix size_matrix = args(2).matrix_value ();
-      int width = size_matrix(0);
-      int height = size_matrix(1);
+  Matrix size_matrix = args(2).matrix_value ();
+  int width = size_matrix(0);
+  int height = size_matrix(1);
 
-      Matrix initial_matrix = args(3).matrix_value ();
-      nel = initial_matrix.numel ();
-      std::list<int> initial_lst;
-      for (octave_idx_type i = 0; i < nel; i++)
-        initial_lst.push_back (initial_matrix(i));
+  Matrix initial_matrix = args(3).matrix_value ();
+  nel = initial_matrix.numel ();
+  std::list<int> initial_lst;
+  for (octave_idx_type i = 0; i < nel; i++)
+    initial_lst.push_back (initial_matrix(i));
 
-      std::string name = args(4).string_value ();
-      list = args(5).cell_value ();
-      const Array<std::string> plist = list.cellstr_value ();
-      nel = plist.numel ();
-      std::list<std::string> prompt_lst;
-      for (octave_idx_type i = 0; i < nel; i++)
-        prompt_lst.push_back (plist(i));
-      std::string ok_string = args(6).string_value ();
-      std::string cancel_string = args(7).string_value ();
+  std::string name = args(4).string_value ();
+  list = args(5).cell_value ();
+  const Array<std::string> plist = list.cellstr_value ();
+  nel = plist.numel ();
+  std::list<std::string> prompt_lst;
+  for (octave_idx_type i = 0; i < nel; i++)
+    prompt_lst.push_back (plist(i));
+  std::string ok_string = args(6).string_value ();
+  std::string cancel_string = args(7).string_value ();
 
-      flush_octave_stdout ();
+  flush_octave_stdout ();
 
-      std::pair<std::list<int>, int> result
-        = octave_link::list_dialog (list_lst, mode, width, height,
-                                    initial_lst, name, prompt_lst,
-                                    ok_string, cancel_string);
+  std::pair<std::list<int>, int> result
+    = octave_link::list_dialog (list_lst, mode, width, height,
+                                initial_lst, name, prompt_lst,
+                                ok_string, cancel_string);
 
-      std::list<int> items_lst = result.first;
-      nel = items_lst.size ();
-      Matrix items (dim_vector (1, nel));
-      octave_idx_type i = 0;
-      for (std::list<int>::iterator it = items_lst.begin ();
-           it != items_lst.end (); it++)
-        {
-          items.xelem(i++) = *it;
-        }
-
-      retval = ovl (items, result.second);
+  std::list<int> items_lst = result.first;
+  nel = items_lst.size ();
+  Matrix items (dim_vector (1, nel));
+  octave_idx_type i = 0;
+  for (std::list<int>::iterator it = items_lst.begin ();
+       it != items_lst.end (); it++)
+    {
+      items.xelem(i++) = *it;
     }
 
-  return retval;
+  return ovl (items, result.second);
 }
 
 DEFUN (__octave_link_input_dialog__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __octave_link_input_dialog__ (@var{prompt}, @var{title}, @var{rowscols}, @var{defaults})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 4)
-    {
-      Cell prompt = args(0).cell_value ();
-      Array<std::string> tmp = prompt.cellstr_value ();
-      octave_idx_type nel = tmp.numel ();
-      std::list<std::string> prompt_lst;
-      for (octave_idx_type i = 0; i < nel; i++)
-        prompt_lst.push_back (tmp(i));
+  if (args.length () != 4)
+    return octave_value_list ();
 
-      std::string title = args(1).string_value ();
-
-      Matrix rc = args(2).matrix_value ();
-      nel = rc.rows ();
-      std::list<float> nr;
-      std::list<float> nc;
-      for (octave_idx_type i = 0; i < nel; i++)
-        {
-          nr.push_back (rc(i,0));
-          nc.push_back (rc(i,1));
-        }
+  Cell prompt = args(0).cell_value ();
+  Array<std::string> tmp = prompt.cellstr_value ();
+  octave_idx_type nel = tmp.numel ();
+  std::list<std::string> prompt_lst;
+  for (octave_idx_type i = 0; i < nel; i++)
+    prompt_lst.push_back (tmp(i));
 
-      Cell defaults = args(3).cell_value ();
-      tmp = defaults.cellstr_value ();
-      nel = tmp.numel ();
-      std::list<std::string> defaults_lst;
-      for (octave_idx_type i = 0; i < nel; i++)
-        defaults_lst.push_back (tmp(i));
-
-      flush_octave_stdout ();
+  std::string title = args(1).string_value ();
 
-      std::list<std::string> items_lst
-        = octave_link::input_dialog (prompt_lst, title, nr, nc,
-                                     defaults_lst);
-
-      nel = items_lst.size ();
-      Cell items (dim_vector (nel, 1));
-      octave_idx_type i = 0;
-      for (std::list<std::string>::iterator it = items_lst.begin ();
-           it != items_lst.end (); it++)
-        {
-          items.xelem(i++) = *it;
-        }
-
-      retval = items;
+  Matrix rc = args(2).matrix_value ();
+  nel = rc.rows ();
+  std::list<float> nr;
+  std::list<float> nc;
+  for (octave_idx_type i = 0; i < nel; i++)
+    {
+      nr.push_back (rc(i,0));
+      nc.push_back (rc(i,1));
     }
 
-  return retval;
+  Cell defaults = args(3).cell_value ();
+  tmp = defaults.cellstr_value ();
+  nel = tmp.numel ();
+  std::list<std::string> defaults_lst;
+  for (octave_idx_type i = 0; i < nel; i++)
+    defaults_lst.push_back (tmp(i));
+
+  flush_octave_stdout ();
+
+  std::list<std::string> items_lst
+    = octave_link::input_dialog (prompt_lst, title, nr, nc,
+                                 defaults_lst);
+
+  nel = items_lst.size ();
+  Cell items (dim_vector (nel, 1));
+  octave_idx_type i = 0;
+  for (std::list<std::string>::iterator it = items_lst.begin ();
+       it != items_lst.end (); it++)
+    {
+      items.xelem(i++) = *it;
+    }
+
+  return ovl (items);
 }
 
 DEFUN (__octave_link_show_preferences__, , ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __octave_link_show_preferences__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  retval = octave_link::show_preferences ();
-
-  return retval;
+  return octave_value (octave_link::show_preferences ());
 }
 
 DEFUN (__octave_link_show_doc__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __octave_link_show_doc__ (@var{filename})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  octave_value retval;
   std::string file;
 
   if (args.length () >= 1)
     file = args(0).string_value();
 
-  retval = octave_link::show_doc (file);
-
-  return retval;
+  return octave_value (octave_link::show_doc (file));
 }
 
-
-
diff --git a/libinterp/corefcn/profiler.cc b/libinterp/corefcn/profiler.cc
--- a/libinterp/corefcn/profiler.cc
+++ b/libinterp/corefcn/profiler.cc
@@ -431,17 +431,14 @@ DEFUN (__profiler_data__, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {} {} __profiler_data__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   if (args.length () > 0)
     warning ("profiler_data: ignoring extra arguments");
 
-  octave_value_list retval;
-
   if (nargout > 1)
-    retval(1) = profiler.get_hierarchical ();
-  retval(0) = profiler.get_flat ();
-
-  return retval;
+    return ovl (profiler.get_flat (), profiler.get_hierarchical ());
+  else
+    return ovl (profiler.get_flat ());
 }
 
diff --git a/libinterp/corefcn/quadcc.cc b/libinterp/corefcn/quadcc.cc
--- a/libinterp/corefcn/quadcc.cc
+++ b/libinterp/corefcn/quadcc.cc
@@ -1550,18 +1550,16 @@ successive interpolations of the integra
 quadrature rules.\n\
 \n\
 Reference: @nospell{P. Gonnet}, @cite{Increasing the Reliability of Adaptive\n\
 Quadrature Using Explicit Interpolants}, ACM Transactions on\n\
 Mathematical Software, Vol. 37, Issue 3, Article No. 3, 2010.\n\
 @seealso{quad, quadv, quadl, quadgk, trapz, dblquad, triplequad}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   /* Some constants that we will need. */
   static const int n[4] = { 4, 8, 16, 32 };
   static const int skip[4] = { 8, 4, 2, 1 };
   static const int idx[4] = { 0, 5, 14, 31 };
   static const double w = M_SQRT2 / 2;
   static const int ndiv_max = 20;
 
   /* Arguments left and right */
@@ -2212,16 +2210,18 @@ Mathematical Software, Vol. 37, Issue 3,
       iv = &(ivals[heap[i]]);
       printf ("quadcc: ival %i (%i) with [%e,%e], int=%e, err=%e, depth=%i, rdepth=%i, ndiv=%i\n",
               i, heap[i], iv->a, iv->b, iv->igral, iv->err, iv->depth,
               iv->rdepth, iv->ndiv);
     }
 #endif
 
   /* Clean up and present the results. */
+  octave_value_list retval;
+
   if (nargout > 2)
     retval(2) = neval;
   if (nargout > 1)
     retval(1) = err;
   retval(0) = igral;
   /* All is well that ends well. */
   return retval;
 }
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -286,49 +286,47 @@ Note that the following relations hold:\
 @tcode{@var{UR} * @var{TR} * @var{UR}' = @var{U} * @var{T} * @var{U}'} and\n\
 @code{@var{U}' * @var{U}} is the identity matrix I.\n\
 @end ifnottex\n\
 \n\
 Note also that @var{U} and @var{T} are not unique.\n\
 @seealso{schur}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   if (args.length () != 2 || nargout > 2)
     print_usage ();
 
+  octave_value_list retval;
+
   if (! args(0).is_numeric_type ())
     gripe_wrong_type_arg ("rsf2csf", args(0));
   else if (! args(1).is_numeric_type ())
     gripe_wrong_type_arg ("rsf2csf", args(1));
   else if (args(0).is_complex_type () || args(1).is_complex_type ())
     error ("rsf2csf: UR and TR must be real matrices");
   else
     {
 
       if (args(0).is_single_type () || args(1).is_single_type ())
         {
           FloatMatrix u = args(0).float_matrix_value ();
           FloatMatrix t = args(1).float_matrix_value ();
 
           FloatComplexSCHUR cs (FloatSCHUR (t, u));
 
-          retval(1) = cs.schur_matrix ();
-          retval(0) = cs.unitary_matrix ();
+          retval = ovl (cs.unitary_matrix (), cs.schur_matrix ());
         }
       else
         {
           Matrix u = args(0).matrix_value ();
           Matrix t = args(1).matrix_value ();
 
           ComplexSCHUR cs (SCHUR (t, u));
 
-          retval(1) = cs.schur_matrix ();
-          retval(0) = cs.unitary_matrix ();
+          retval = ovl (cs.unitary_matrix (), cs.schur_matrix ());
         }
     }
 
   return retval;
 }
 
 /*
 %!test
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -680,21 +680,16 @@ error message.\n\
 
   std::string name = args(0).xstring_value ("mkfifo: FILE must be a string");
 
   int octal_mode = args(1).xint_value ("mkfifo: MODE must be an integer");
 
   if (octal_mode < 0)
     error ("mkfifo: MODE must be a positive integer value");
 
-  octave_value_list retval (2);
-
-  retval(1) = std::string ();
-  retval(0) = -1;
-
   int mode = convert (octal_mode, 8, 10);
 
   std::string msg;
 
   int status = octave_mkfifo (name, mode, msg);
 
   return ovl (status, msg);
 }
diff --git a/libinterp/dldfcn/amd.cc b/libinterp/dldfcn/amd.cc
--- a/libinterp/dldfcn/amd.cc
+++ b/libinterp/dldfcn/amd.cc
@@ -79,18 +79,16 @@ absorption.  The default is not to perfo
 @end table\n\
 \n\
 The author of the code itself is Timothy A. Davis\n\
 @email{davis@@cise.ufl.edu}, University of Florida\n\
 (see @url{http://www.cise.ufl.edu/research/sparse/amd}).\n\
 @seealso{symamd, colamd}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
 #ifdef HAVE_AMD
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   octave_idx_type n_row, n_col;
   const octave_idx_type *ridx, *cidx;
@@ -159,45 +157,35 @@ The author of the code itself is Timothy
   SUITESPARSE_ASSIGN_FPTR (free_func, amd_free, free);
   SUITESPARSE_ASSIGN_FPTR (calloc_func, amd_calloc, calloc);
   SUITESPARSE_ASSIGN_FPTR (realloc_func, amd_realloc, realloc);
   SUITESPARSE_ASSIGN_FPTR (printf_func, amd_printf, printf);
 
   octave_idx_type result = AMD_NAME (_order) (n_col, cidx, ridx, P,
                                               Control, Info);
 
-  switch (result)
-    {
-    case AMD_OUT_OF_MEMORY:
-      error ("amd: out of memory");
-      break;
-
-    case AMD_INVALID:
-      error ("amd: matrix S is corrupted");
-      break;
+  if (result == AMD_OUT_OF_MEMORY)
+    error ("amd: out of memory");
+  else if (result == AMD_INVALID)
+    error ("amd: matrix S is corrupted");
 
-    default:
-      {
-        if (nargout > 1)
-          retval(1) = xinfo;
+  Matrix Pout (1, n_col);
+  for (octave_idx_type i = 0; i < n_col; i++)
+    Pout.xelem (i) = P[i] + 1;
 
-        Matrix Pout (1, n_col);
-        for (octave_idx_type i = 0; i < n_col; i++)
-          Pout.xelem (i) = P[i] + 1;
+  if (nargout > 1)
+    return ovl (Pout, xinfo);
+  else
+    return ovl (Pout);
 
-        retval(0) = Pout;
-      }
-    }
 #else
 
   error ("amd: not available in this version of Octave");
 
 #endif
-
-  return retval;
 }
 /*
 %!shared A, A2, opts
 %! A = ones (20, 30);
 %! A2 = ones (30, 30);
 %!
 %!testif HAVE_AMD
 %! assert(amd (A2), [1:30])
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -138,27 +138,25 @@ The authors of the code itself are @nosp
 @nospell{J. Bilbert and E. Ng}.  Supported by the National Science Foundation\n\
 @nospell{(DMS-9504974, DMS-9803599, CCR-0203270)}, and a grant from\n\
 @nospell{Sandia} National Lab.\n\
 See @url{http://www.cise.ufl.edu/research/sparse} for\n\
 ccolamd, csymamd, amd, colamd, symamd, and other related orderings.\n\
 @seealso{colamd, csymamd}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
 #ifdef HAVE_CCOLAMD
 
   int nargin = args.length ();
-  int spumoni = 0;
 
   if (nargout > 2 || nargin < 1 || nargin > 3)
     usage ("ccolamd: incorrect number of input and/or output arguments");
 
-  retval.resize (nargout == 2 ? 2 : 1);
+  octave_value_list retval (nargout == 2 ? 2 : 1);
+  int spumoni = 0;
 
   // Get knobs
   OCTAVE_LOCAL_BUFFER (double, knobs, CCOLAMD_KNOBS);
   CCOLAMD_NAME (_set_defaults) (knobs);
 
   // Check for user-passed knobs
   if (nargin > 1)
     {
@@ -324,23 +322,23 @@ ccolamd, csymamd, amd, colamd, symamd, a
 
       // fix stats (5) and (6), for 1-based information on
       // jumbled matrix.  note that this correction doesn't
       // occur if symamd returns FALSE
       out_stats (CCOLAMD_INFO1) ++ ;
       out_stats (CCOLAMD_INFO2) ++ ;
     }
 
+  return retval;
+
 #else
 
   error ("ccolamd: not available in this version of Octave");
 
 #endif
-
-  return retval;
 }
 
 DEFUN_DLD (csymamd, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {} {@var{p} =} csymamd (@var{S})\n\
 @deftypefnx {} {@var{p} =} csymamd (@var{S}, @var{knobs})\n\
 @deftypefnx {} {@var{p} =} csymamd (@var{S}, @var{knobs}, @var{cmember})\n\
 @deftypefnx {} {[@var{p}, @var{stats}] =} csymamd (@dots{})\n\
@@ -398,27 +396,25 @@ The authors of the code itself are @nosp
 @nospell{J. Bilbert and E. Ng}.  Supported by the National Science Foundation\n\
 @nospell{(DMS-9504974, DMS-9803599, CCR-0203270)}, and a grant from\n\
 @nospell{Sandia} National Lab.\n\
 See @url{http://www.cise.ufl.edu/research/sparse} for\n\
 ccolamd, csymamd, amd, colamd, symamd, and other related orderings.\n\
 @seealso{symamd, ccolamd}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
 #if HAVE_CCOLAMD
 
   int nargin = args.length ();
-  int spumoni = 0;
 
   if (nargout > 2 || nargin < 1 || nargin > 3)
     usage ("ccolamd: incorrect number of input and/or output arguments");
 
-  retval.resize (nargout == 2 ? 2 : 1);
+  octave_value_list retval (nargout == 2 ? 2 : 1);
+  int spumoni = 0;
 
   // Get knobs
   OCTAVE_LOCAL_BUFFER (double, knobs, CCOLAMD_KNOBS);
   CCOLAMD_NAME (_set_defaults) (knobs);
 
   // Check for user-passed knobs
   if (nargin > 1)
     {
@@ -557,16 +553,16 @@ ccolamd, csymamd, amd, colamd, symamd, a
 
       // fix stats (5) and (6), for 1-based information on
       // jumbled matrix.  note that this correction doesn't
       // occur if symamd returns FALSE
       out_stats (CCOLAMD_INFO1) ++ ;
       out_stats (CCOLAMD_INFO2) ++ ;
     }
 
+  return retval;
+
 #else
 
   error ("csymamd: not available in this version of Octave");
 
 #endif
-
-  return retval;
 }
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -142,49 +142,50 @@ For full matrices, if the @qcode{\"lower
 triangular part of the matrix is used for the factorization, otherwise the\n\
 upper triangular part is used.\n\
 \n\
 In general the lower triangular factorization is significantly faster for\n\
 sparse matrices.\n\
 @seealso{hess, lu, qr, qz, schur, svd, ichol, cholinv, chol2inv, cholupdate, cholinsert, choldelete, cholshift}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
   int nargin = args.length ();
-  bool LLt = false;
-  bool vecout = false;
 
   if (nargin < 1 || nargin > 3 || nargout > 3
       || (! args(0).is_sparse_type () && nargout > 2))
     print_usage ();
 
+  bool LLt = false;
+  bool vecout = false;
+
   int n = 1;
   while (n < nargin)
     {
       std::string tmp = args(n++).xstring_value ("chol: optional arguments must be strings");
 
       if (tmp == "vector")
         vecout = true;
       else if (tmp == "lower")
         LLt = true;
       else if (tmp == "upper")
         LLt = false;
       else
         error ("chol: optional argument must be one of \"vector\", \"lower\", or \"upper\"");
     }
 
+  octave_value_list retval;
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("chol", nr, nc);
 
   if (arg_is_empty < 0)
-    return retval;
+    return octave_value_list ();
   if (arg_is_empty > 0)
     return octave_value (Matrix ());
 
   if (arg.is_sparse_type ())
     {
       octave_idx_type info;
       bool natural = (nargout != 3);
       bool force = nargout > 1;
@@ -198,17 +199,17 @@ sparse matrices.\n\
           if (nargout == 3)
             {
               if (vecout)
                 retval(2) = fact.perm ();
               else
                 retval(2) = fact.Q ();
             }
 
-          if (nargout > 1 || info == 0)
+          if (nargout >= 2 || info == 0)
             {
               retval(1) = info;
               if (LLt)
                 retval(0) = fact.L ();
               else
                 retval(0) = fact.R ();
             }
           else
@@ -223,17 +224,17 @@ sparse matrices.\n\
           if (nargout == 3)
             {
               if (vecout)
                 retval(2) = fact.perm ();
               else
                 retval(2) = fact.Q ();
             }
 
-          if (nargout > 1 || info == 0)
+          if (nargout >= 2 || info == 0)
             {
               retval(1) = info;
               if (LLt)
                 retval(0) = fact.L ();
               else
                 retval(0) = fact.R ();
             }
           else
@@ -565,17 +566,17 @@ If @var{op} is @qcode{\"-\"}, @var{info}
 @end itemize\n\
 \n\
 If @var{info} is not present, an error message is printed in cases 1 and 2.\n\
 @seealso{chol, cholinsert, choldelete, cholshift}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
 
-  if (nargin > 3 || nargin < 2)
+  if (nargin < 2 || nargin > 3)
     print_usage ();
 
   octave_value argr = args(0);
   octave_value argu = args(1);
 
   if (! argr.is_numeric_type () || ! argu.is_numeric_type ()
       || (nargin > 2 && ! args(2).is_string ()))
     print_usage ();
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -273,27 +273,24 @@ The ordering is followed by a column eli
 \n\
 The authors of the code itself are @nospell{Stefan I. Larimore} and\n\
 @nospell{Timothy A. Davis @email{davis@@cise.ufl.edu}}, University of Florida.  The algorithm was developed in collaboration with @nospell{John Gilbert},\n\
 Xerox PARC, and @nospell{Esmond Ng}, Oak Ridge National Laboratory.  (see\n\
 @url{http://www.cise.ufl.edu/research/sparse/colamd})\n\
 @seealso{colperm, symamd, ccolamd}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
 #ifdef HAVE_COLAMD
-
   int nargin = args.length ();
-  int spumoni = 0;
 
   if (nargout > 2 || nargin < 1 || nargin > 2)
     print_usage ();
 
-  retval.resize (nargout == 2 ? 2 : 1);
+  octave_value_list retval (nargout == 2 ? 2 : 1);
+  int spumoni = 0;
 
   // Get knobs
   OCTAVE_LOCAL_BUFFER (double, knobs, COLAMD_KNOBS);
   COLAMD_NAME (_set_defaults) (knobs);
 
   // Check for user-passed knobs
   if (nargin == 2)
     {
@@ -436,23 +433,23 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
 
       // fix stats (5) and (6), for 1-based information on
       // jumbled matrix.  note that this correction doesn't
       // occur if symamd returns FALSE
       out_stats (COLAMD_INFO1) ++ ;
       out_stats (COLAMD_INFO2) ++ ;
     }
 
+  return retval;
+
 #else
 
   error ("colamd: not available in this version of Octave");
 
 #endif
-
-  return retval;
 }
 
 DEFUN_DLD (symamd, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {} {@var{p} =} symamd (@var{S})\n\
 @deftypefnx {} {@var{p} =} symamd (@var{S}, @var{knobs})\n\
 @deftypefnx {} {[@var{p}, @var{stats}] =} symamd (@var{S})\n\
 @deftypefnx {} {[@var{p}, @var{stats}] =} symamd (@var{S}, @var{knobs})\n\
@@ -510,27 +507,25 @@ The ordering is followed by a column eli
 \n\
 The authors of the code itself are @nospell{Stefan I. Larimore} and\n\
 @nospell{Timothy A. Davis @email{davis@@cise.ufl.edu}}, University of Florida.  The algorithm was developed in collaboration with @nospell{John Gilbert},\n\
 Xerox PARC, and @nospell{Esmond Ng}, Oak Ridge National Laboratory.  (see\n\
 @url{http://www.cise.ufl.edu/research/sparse/colamd})\n\
 @seealso{colperm, colamd}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
 #ifdef HAVE_COLAMD
 
   int nargin = args.length ();
-  int spumoni = 0;
 
   if (nargout > 2 || nargin < 1 || nargin > 2)
     print_usage ();
 
-  retval.resize (nargin == 2 ? 2 : 1);
+  octave_value_list retval (nargin == 2 ? 2 : 1);
+  int spumoni = 0;
 
   // Get knobs
   OCTAVE_LOCAL_BUFFER (double, knobs, COLAMD_KNOBS);
   COLAMD_NAME (_set_defaults) (knobs);
 
   // Check for user-passed knobs
   if (nargin == 2)
     {
@@ -628,23 +623,23 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
 
       // fix stats (5) and (6), for 1-based information on
       // jumbled matrix.  note that this correction doesn't
       // occur if symamd returns FALSE
       out_stats (COLAMD_INFO1) ++ ;
       out_stats (COLAMD_INFO2) ++ ;
     }
 
+  return retval;
+
 #else
 
   error ("symamd: not available in this version of Octave");
 
 #endif
-
-  return retval;
 }
 
 DEFUN_DLD (etree, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {} {@var{p} =} etree (@var{S})\n\
 @deftypefnx {} {@var{p} =} etree (@var{S}, @var{typ})\n\
 @deftypefnx {} {[@var{p}, @var{q}] =} etree (@var{S}, @var{typ})\n\
 \n\
@@ -655,27 +650,27 @@ tree is returned.  The argument @var{typ
 column elimination tree is returned.  Valid values of @var{typ} are\n\
 @qcode{\"sym\"} or @qcode{\"col\"}, for symmetric or column elimination tree\n\
 respectively.\n\
 \n\
 Called with a second argument, @code{etree} also returns the postorder\n\
 permutations on the tree.\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargout > 2 || nargin < 1 || nargin > 2)
     print_usage ();
 
-  retval.resize (nargout == 2 ? 2 : 1);
+  octave_value_list retval (nargout == 2 ? 2 : 1);
 
-  octave_idx_type n_row = 0, n_col = 0;
-  octave_idx_type *ridx = 0, *cidx = 0;
+  octave_idx_type n_row = 0;
+  octave_idx_type n_col = 0;
+  octave_idx_type *ridx = 0;
+  octave_idx_type *cidx = 0;
 
   if (args(0).is_sparse_type ())
     {
       if (args(0).is_complex_type ())
         {
           SparseComplexMatrix scm = args(0).sparse_complex_matrix_value ();
 
           n_row = scm.rows ();
diff --git a/libinterp/dldfcn/convhulln.cc b/libinterp/dldfcn/convhulln.cc
--- a/libinterp/dldfcn/convhulln.cc
+++ b/libinterp/dldfcn/convhulln.cc
@@ -99,24 +99,25 @@ used.  Otherwise, @var{options} replaces
 To append user options to the defaults it is necessary to repeat the\n\
 default arguments in @var{options}.  Use a null string to pass no arguments.\n\
 \n\
 If the second output @var{v} is requested the volume of the enclosing\n\
 convex hull is calculated.\n\n\
 @seealso{convhull, delaunayn, voronoin}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
 #if defined (HAVE_QHULL)
 
   int nargin = args.length ();
+
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
+  octave_value_list retval;
+
   Matrix points (args(0).matrix_value ());
   const octave_idx_type dim = points.columns ();
   const octave_idx_type num_points = points.rows ();
 
   if (! octave_qhull_dims_ok (dim, num_points, "convhulln"))
     return retval;
 
   points = points.transpose ();
@@ -154,149 +155,147 @@ convex hull is calculated.\n\n\
   // Replace the outfile pointer with stdout for debugging information.
 #if defined (OCTAVE_HAVE_WINDOWS_FILESYSTEM) && ! defined (OCTAVE_HAVE_POSIX_FILESYSTEM)
   FILE *outfile = gnulib::fopen ("NUL", "w");
 #else
   FILE *outfile = gnulib::fopen ("/dev/null", "w");
 #endif
   FILE *errfile = stderr;
 
-  if (outfile)
-    frame.add_fcn (close_fcn, outfile);
-  else
+  if (! outfile)
     error ("convhulln: unable to create temporary file for output");
 
+  frame.add_fcn (close_fcn, outfile);
+
   // qh_new_qhull command and points arguments are not const...
 
   std::string cmd = "qhull" + options;
 
   OCTAVE_LOCAL_BUFFER (char, cmd_str, cmd.length () + 1);
 
   strcpy (cmd_str, cmd.c_str ());
 
   int exitcode = qh_new_qhull (dim, num_points, points.fortran_vec (),
                                ismalloc, cmd_str, outfile, errfile);
-  if (! exitcode)
-    {
-      bool nonsimp_seen = false;
+  if (exitcode)
+    error ("convhulln: qhull failed");
 
-      octave_idx_type nf = qh num_facets;
+  bool nonsimp_seen = false;
+
+  octave_idx_type nf = qh num_facets;
+
+  Matrix idx (nf, dim + 1);
 
-      Matrix idx (nf, dim + 1);
+  facetT *facet;
 
-      facetT *facet;
+  octave_idx_type i = 0;
 
-      octave_idx_type i = 0;
+  FORALLfacets
+    {
+      octave_idx_type j = 0;
 
-      FORALLfacets
+      if (! (nonsimp_seen || facet->simplicial || qh hull_dim == 2))
         {
-          octave_idx_type j = 0;
+          nonsimp_seen = true;
 
-          if (! (nonsimp_seen || facet->simplicial || qh hull_dim == 2))
-            {
-              nonsimp_seen = true;
+          if (cmd.find ("QJ") != std::string::npos)
+            // Should never happen with QJ.
+            error ("convhulln: qhull failed: option 'QJ' returned non-simplicial facet");
+        }
+
+      if (dim == 3)
+        {
+          setT *vertices = qh_facet3vertex (facet);
 
-              if (cmd.find ("QJ") != std::string::npos)
-                // Should never happen with QJ.
-                error ("convhulln: qhull failed: option 'QJ' returned non-simplicial facet");
-            }
+          vertexT *vertex, **vertexp;
+
+          FOREACHvertex_ (vertices)
+            idx(i, j++) = 1 + qh_pointid(vertex->point);
 
-          if (dim == 3)
+          qh_settempfree (&vertices);
+        }
+      else
+        {
+          if (facet->toporient ^ qh_ORIENTclock)
             {
-              setT *vertices = qh_facet3vertex (facet);
-
               vertexT *vertex, **vertexp;
 
-              FOREACHvertex_ (vertices)
+              FOREACHvertex_ (facet->vertices)
                 idx(i, j++) = 1 + qh_pointid(vertex->point);
-
-              qh_settempfree (&vertices);
             }
           else
             {
-              if (facet->toporient ^ qh_ORIENTclock)
-                {
-                  vertexT *vertex, **vertexp;
+              vertexT *vertex, **vertexp;
+
+              FOREACHvertexreverse12_ (facet->vertices)
+                idx(i, j++) = 1 + qh_pointid(vertex->point);
+            }
+        }
+      if (j < dim)
+        warning ("convhulln: facet %d only has %d vertices", i, j);
+
+      i++;
+    }
+
+  // Remove extra dimension if all facets were simplicial.
+
+  if (! nonsimp_seen)
+    idx.resize (nf, dim, 0.0);
+
+  if (nargout == 2)
+    {
+      // Calculate volume of convex hull, taken from qhull src/geom2.c.
 
-                  FOREACHvertex_ (facet->vertices)
-                    idx(i, j++) = 1 + qh_pointid(vertex->point);
-                }
-              else
-                {
-                  vertexT *vertex, **vertexp;
+      realT area;
+      realT dist;
+
+      FORALLfacets
+        {
+          if (! facet->normal)
+            continue;
+
+          if (facet->upperdelaunay && qh ATinfinity)
+            continue;
 
-                  FOREACHvertexreverse12_ (facet->vertices)
-                    idx(i, j++) = 1 + qh_pointid(vertex->point);
-                }
+          facet->f.area = area = qh_facetarea (facet);
+          facet->isarea = True;
+
+          if (qh DELAUNAY)
+            {
+              if (facet->upperdelaunay == qh UPPERdelaunay)
+                qh totarea += area;
             }
-          if (j < dim)
-            warning ("convhulln: facet %d only has %d vertices", i, j);
-
-          i++;
+          else
+            {
+              qh totarea += area;
+              qh_distplane (qh interior_point, facet, &dist);
+              qh totvol += -dist * area/ qh hull_dim;
+            }
         }
 
-      // Remove extra dimension if all facets were simplicial.
-
-      if (! nonsimp_seen)
-        idx.resize (nf, dim, 0.0);
-
-      if (nargout == 2)
-        {
-          // Calculate volume of convex hull, taken from qhull src/geom2.c.
-
-          realT area;
-          realT dist;
-
-          FORALLfacets
-            {
-              if (! facet->normal)
-                continue;
-
-              if (facet->upperdelaunay && qh ATinfinity)
-                continue;
+      retval(1) = octave_value (qh totvol);
+    }
 
-              facet->f.area = area = qh_facetarea (facet);
-              facet->isarea = True;
-
-              if (qh DELAUNAY)
-                {
-                  if (facet->upperdelaunay == qh UPPERdelaunay)
-                    qh totarea += area;
-                }
-              else
-                {
-                  qh totarea += area;
-                  qh_distplane (qh interior_point, facet, &dist);
-                  qh totvol += -dist * area/ qh hull_dim;
-                }
-            }
-
-          retval(1) = octave_value (qh totvol);
-        }
-
-      retval(0) = idx;
-    }
-  else
-    error ("convhulln: qhull failed");
+  retval(0) = idx;
 
   // Free memory from Qhull
   qh_freeqhull (! qh_ALL);
 
   int curlong, totlong;
   qh_memfreeshort (&curlong, &totlong);
 
   if (curlong || totlong)
     warning ("convhulln: did not free %d bytes of long memory (%d pieces)",
              totlong, curlong);
 
+  return retval;
+
 #else
   error ("convhulln: not available in this version of Octave");
 #endif
-
-  return retval;
 }
 
 /*
 %!testif HAVE_QHULL
 %! cube = [0 0 0;1 0 0;1 1 0;0 1 0;0 0 1;1 0 1;1 1 1;0 1 1];
 %! [h, v] = convhulln (cube, "Qt");
 %! assert (size (h), [12 3]);
 %! h = sortrows (sort (h, 2), [1:3]);
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -194,23 +194,23 @@ as\n\
 @group\n\
 [@var{C}, @var{R}] = qr (@var{A}, @var{B})\n\
 x = @var{R} \\ @var{C}\n\
 @end group\n\
 @end example\n\
 @seealso{chol, hess, lu, qz, schur, svd, qrupdate, qrinsert, qrdelete, qrshift}\n\
 @end deftypefn")
 {
-  octave_value_list retval;
-
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > (args(0).is_sparse_type () ? 3 : 2))
     print_usage ();
 
+  octave_value_list retval;
+
   octave_value arg = args(0);
 
   int arg_is_empty = empty_arg ("qr", arg.rows (), arg.columns ());
 
   if (arg_is_empty < 0)
     return retval;
 
   if (arg.is_sparse_type ())
@@ -302,22 +302,21 @@ x = @var{R} \\ @var{C}\n\
                     FloatQR fact (m, type);
                     retval = ovl (fact.Q (), get_qr_r (fact));
                   }
                   break;
 
                 default:
                   {
                     FloatQRP fact (m, type);
+
                     if (type == QR::economy)
-                      retval(2) = fact.Pvec ();
+                      retval = ovl (fact.Q (), get_qr_r (fact), fact.Pvec ());
                     else
-                      retval(2) = fact.P ();
-                    retval(1) = get_qr_r (fact);
-                    retval(0) = fact.Q ();
+                      retval = ovl (fact.Q (), get_qr_r (fact), fact.P ());
                   }
                   break;
                 }
             }
           else if (arg.is_complex_type ())
             {
               FloatComplexMatrix m = arg.float_complex_matrix_value ();
 
@@ -337,21 +336,19 @@ x = @var{R} \\ @var{C}\n\
                     retval = ovl (fact.Q (), get_qr_r (fact));
                   }
                   break;
 
                 default:
                   {
                     FloatComplexQRP fact (m, type);
                     if (type == QR::economy)
-                      retval(2) = fact.Pvec ();
+                      retval = ovl (fact.Q (), get_qr_r (fact), fact.Pvec ());
                     else
-                      retval(2) = fact.P ();
-                    retval(1) = get_qr_r (fact);
-                    retval(0) = fact.Q ();
+                      retval = ovl (fact.Q (), get_qr_r (fact), fact.P ());
                   }
                   break;
                 }
             }
         }
       else
         {
           if (arg.is_real_type ())
@@ -374,21 +371,19 @@ x = @var{R} \\ @var{C}\n\
                     retval = ovl (fact.Q (), get_qr_r (fact));
                   }
                   break;
 
                 default:
                   {
                     QRP fact (m, type);
                     if (type == QR::economy)
-                      retval(2) = fact.Pvec ();
+                      retval = ovl (fact.Q (), get_qr_r (fact), fact.Pvec ());
                     else
-                      retval(2) = fact.P ();
-                    retval(1) = get_qr_r (fact);
-                    retval(0) = fact.Q ();
+                      retval = ovl (fact.Q (), get_qr_r (fact), fact.P ());
                   }
                   break;
                 }
             }
           else if (arg.is_complex_type ())
             {
               ComplexMatrix m = arg.complex_matrix_value ();
 
@@ -408,21 +403,19 @@ x = @var{R} \\ @var{C}\n\
                     retval = ovl (fact.Q (), get_qr_r (fact));
                   }
                   break;
 
                 default:
                   {
                     ComplexQRP fact (m, type);
                     if (type == QR::economy)
-                      retval(2) = fact.Pvec ();
+                      retval = ovl (fact.Q (), get_qr_r (fact), fact.Pvec ());
                     else
-                      retval(2) = fact.P ();
-                    retval(1) = get_qr_r (fact);
-                    retval(0) = fact.Q ();
+                      retval = ovl (fact.Q (), get_qr_r (fact), fact.P ());
                   }
                   break;
                 }
             }
           else
             gripe_wrong_type_arg ("qr", arg);
         }
     }
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -91,23 +91,24 @@ The height of the elimination tree.\n\
 The elimination tree itself.\n\
 \n\
 @item post\n\
 A sparse boolean matrix whose structure is that of the Cholesky\n\
 factorization as determined by @var{typ}.\n\
 @end table\n\
 @end deftypefn")
 {
-  octave_value_list retval;
+#ifdef HAVE_CHOLMOD
+
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 3 || nargout > 5)
     print_usage ();
 
-#ifdef HAVE_CHOLMOD
+  octave_value_list retval;
 
   cholmod_common Common;
   cholmod_common *cm = &Common;
   CHOLMOD_NAME(start) (cm);
 
   double spu = octave_sparse_params::get_key ("spumoni");
   if (spu == 0.)
     {
