# HG changeset patch
# User jwe
# Date 1076953550 0
#      Mon Feb 16 17:45:50 2004 +0000
# Node ID b8105302cfe8c8ec7874f83fe3cf2ccf010ac73f
# Parent  ef5e598f099b67e91b91b6f4190ef20d84260e94
[project @ 2004-02-16 17:45:50 by jwe]

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,45 @@
+2004-02-16  A S Hodel  <a.s.hodel@Eng.Auburn.EDU>
+
+	* control/base/__bodquist__.m, control/base/__stepimp__.m,
+	control/base/analdemo.m, control/base/bddemo.m,
+	control/base/bode.m, control/base/dre.m, control/base/frdemo.m,
+	control/base/lqg.m, control/base/nyquist.m, control/base/place.m,
+	control/base/rldemo.m, control/base/rlocus.m,
+	control/base/tzero.m, control/hinf/dgkfdemo.m,
+	control/hinf/dhinfdemo.m, control/hinf/h2syn.m,
+	control/hinf/hinf_ctr.m, control/hinf/hinfsyn.m,
+	control/hinf/wgt1o.m, control/obsolete/dlqg.m,
+	control/obsolete/packsys.m, control/obsolete/series.m,
+	control/system/__sysdefioname__.m,
+	control/system/__sysdefstname__.m, control/system/__sysgroupn__.m,
+	control/system/__tf2sysl__.m, control/system/buildssic.m,
+	control/system/c2d.m, control/system/d2c.m,
+	control/system/dmr2d.m, control/system/fir2sys.m,
+	control/system/is_signal_list.m, control/system/is_siso.m,
+	control/system/jet707.m, control/system/listidx.m,
+	control/system/moddemo.m, control/system/ord2.m,
+	control/system/packedform.m, control/system/parallel.m,
+	control/system/ss2sys.m, control/system/sys2tf.m,
+	control/system/sys2zp.m, control/system/sysadd.m,
+	control/system/sysappend.m, control/system/sysconnect.m,
+	control/system/syscont.m, control/system/sysdimensions.m,
+	control/system/sysdisc.m, control/system/sysdup.m,
+	control/system/sysgetsignals.m, control/system/sysgettype.m,
+	control/system/sysgroup.m, control/system/sysmin.m,
+	control/system/sysmult.m, control/system/sysprune.m,
+	control/system/sysrepdemo.m, control/system/sysscale.m,
+	control/system/syssetsignals.m, control/system/syssub.m,
+	control/system/sysupdate.m, control/system/tf2sys.m,
+	control/system/ugain.m, control/system/zp2ss.m,
+	control/system/zp2sys.m, control/util/__outlist__.m,
+	control/util/__zgpbal__.m, control/util/strappend.m:
+	Use cell arrays instead of lists.
+
 2004-01-23  Stefan van der Walt  <stefan@sun.ac.za>
 
 	* plot/bar.m: Increase size of cutoff vector from xlen-1 to xlen
 	so that bar (1, 1) will work.
 
 2004-01-22  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* plot/__errcomm__.m: Cope with nargin now being a function.
diff --git a/scripts/control/base/__bodquist__.m b/scripts/control/base/__bodquist__.m
--- a/scripts/control/base/__bodquist__.m
+++ b/scripts/control/base/__bodquist__.m
@@ -82,17 +82,17 @@ function [f, w, rsys] = __bodquist__ (sy
     sys = sysprune(sys,outputs,inputs);
     [nn,nz,mm,pp ] = sysdimensions(sys);
   endif
 
   ## for speed in computation, convert local copy of
   ## SISO state space systems to zero-pole  form
   if( is_siso(sys) & strcmp( sysgettype(sys), "ss") )
     [zer,pol,k,tsam,inname,outname] = sys2zp(sys);
-    sys = zp2sys(zer,pol,k,tsam,inname,outname);
+    sys = zp(zer,pol,k,tsam,inname,outname);
   endif
 
   ## get system frequency response
   [f, w] = __freqresp__ (sys, USEW, w);
 
   phase = arg(f)*180.0/pi;
 
   if(!USEW)
diff --git a/scripts/control/base/__stepimp__.m b/scripts/control/base/__stepimp__.m
--- a/scripts/control/base/__stepimp__.m
+++ b/scripts/control/base/__stepimp__.m
@@ -223,17 +223,17 @@ function [y, t] = __stepimp__ (sitype, s
       gset nologscale
       gset autoscale
       gset nokey
       clearplot();
       if (IMPULSE)
 	gm = zeros(NOUT, 1);
 	tt = "impulse";
       else
-	ssys = ss2sys(F, G, C, D, t_step);
+	ssys = ss(F, G, C, D, t_step);
 	gm = dcgain(ssys);
 	tt = "step";
       endif
       ncols = floor(sqrt(NOUT));
       nrows = ceil(NOUT / ncols);
       for i = 1:NOUT
 	subplot(nrows, ncols, i);
 	title(sprintf("%s: | %s -> %s", tt,sysgetsignals(sys,"in",inp,1), ...
diff --git a/scripts/control/base/analdemo.m b/scripts/control/base/analdemo.m
--- a/scripts/control/base/analdemo.m
+++ b/scripts/control/base/analdemo.m
@@ -108,17 +108,17 @@ function analdemo ()
       zer = tzero(a,b,c,d)
       disp("Variable Description:\n");
       disp("zer => zeros of state space system");
       disp("a, b, c, d => state space system used as input argument");
       prompt
       clc
 
       disp("Example #2, consider the state space system from example 1 again:");
-      cmd = "sys = ss2sys(a,b,c,d);";
+      cmd = "sys = ss(a,b,c,d);";
       disp(cmd);
       eval(cmd);
       sysout(sys);
       disp("\nThe zeros of this system can also be calculated directly from the");
       disp("system variable:");
       cmd = "zer = tzero(sys);";
       run_cmd;
       disp("Results:\n")
@@ -132,17 +132,17 @@ function analdemo ()
     elseif (k == 3)
       clc
       help c2d
       prompt
 
       clc
       disp("Continuous => Discrete and Discrete => Continuous conversions (c2d,d2c)");
       disp("\nExample #1, consider the following continuous state space system");
-      cmd = "sys_cont = ss2sys([-11, 6; -15, 8], [1; 2], [2, -1], 0);";
+      cmd = "sys_cont = ss([-11, 6; -15, 8], [1; 2], [2, -1], 0);";
       eval(cmd);
       disp(cmd);
       disp("Examine the poles and zeros of the continuous system:");
       sysout(sys_cont,"all");
       disp("\nTo convert this to a discrete system, a sampling time is needed:");
       cmd = "Tsam = 0.5;";
       run_cmd;
       disp("\nNow convert to a discrete system with the command:");
@@ -213,17 +213,17 @@ function analdemo ()
       clc
 
     elseif (k == 5)
       disp("--- Balanced realization: not yet implemented")
     elseif (k == 6)
       disp("--- Open loop balanced truncation: not yet implemented")
     elseif (k == 7)
       disp("SISO pole placement example:")
-      cmd = "sys=tf2sys(1, [1, -2, 1]);";
+      cmd = "sys=tf(1, [1, -2, 1]);";
       run_cmd
       disp("System in zero-pole form is:")
       cmd = "sysout(sys,\"zp\");";
       run_cmd
       disp("and in state space form:")
       cmd = "sysout(sys,\"ss\");";
       run_cmd
       disp("Desired poles at -1, -1");
diff --git a/scripts/control/base/bddemo.m b/scripts/control/base/bddemo.m
--- a/scripts/control/base/bddemo.m
+++ b/scripts/control/base/bddemo.m
@@ -55,19 +55,19 @@ function bddemo ()
       disp("sysadd: add two systems together")
       disp("syssub: subtract F = G - H")
       prompt
       help sysadd
       prompt
       help syssub
       prompt
       disp("Example #1, \n")
-      cmd = "sys1 = tf2sys([1 -1],[1 2 1]);";
+      cmd = "sys1 = tf([1 -1],[1 2 1]);";
       run_cmd
-      cmd = "sys2 = tf2sys([1 -1],[1 2 3]);";
+      cmd = "sys2 = tf([1 -1],[1 2 3]);";
       run_cmd
       disp("sys1=")
       sysout(sys1);
       prompt
       disp("sys2=")
       sysout(sys2);
       cmd = "sys_sum1 = sysadd(sys1,sys1);";
       run_cmd
@@ -91,17 +91,17 @@ function bddemo ()
       disp("the two systems are both SISO, they both have the same poles,")
       disp("and at least one of them has  tf for its primary system type.");
       prompt
     elseif (k == 2)
       disp("sysappend: add new inputs and/or outputs to a system")
       help sysappend
       prompt
       disp("Consider a double-integrator system:")
-      sys = tf2sys(1, [1, 0, 0]);
+      sys = tf(1, [1, 0, 0]);
       sys=sysupdate(sys,"ss");
       sysout(sys,"ss");
       disp("We add a velocity disturbance input as follows:")
       cmd = "sys1=sysappend(sys,[1;0]);";
       run_cmd
       sysout(sys1,"ss");
       disp("Names of inputs can be included as follows:")
       cmd = "sys1=sysappend(sys,[1;0], [],[],[],\"Disturb\");";
@@ -114,24 +114,24 @@ function bddemo ()
       prompt
     elseif (k == 3)
       disp("syssetsignals:")
       help syssetsignals
       disp("Example system");
       a = rand(3,3);
       b = rand(3,2);
       c = rand(2,3);
-      sys = ss2sys(a,b,c);
+      sys = ss(a,b,c);
       sysout(sys);
       prompt
       disp("Change state names to larry, moe, and curly as follows:")
-      cmd = "sys = syssetsignals(sys,\"st\",list(\"larry\",\"moe  \" , \"curly\"));";
+      cmd = 'sys = syssetsignals(sys,"st",{"larry","moe" , "curly"});';
       run_cmd
       disp("Indicate that output 2 is discrete-time:")
-      cmd = "sys = syssetsignals(sys,\"yd\",1,2);";
+      cmd = 'sys = syssetsignals(sys,"yd",1,2);';
       run_cmd
       disp("Change output 2 name to \"Vir\"");
       cmd = "sys = syssetsignals(sys,\"out\",\"Vir\",2);";
       run_cmd
       disp("Resulting system is:")
       sysout(sys);
       prompt
     elseif (k == 4)
@@ -141,18 +141,18 @@ function bddemo ()
       disp("sysconnect is demonstrated fully in the design examples (option 13)");
       prompt
     elseif (k == 5)
       disp("syscont and sysdisc: ")
       disp("Example block diagram 1:")
       disp("        ------------------     ---------------------");
       disp(" u_in ->| Discrete system |--->| Continuous system | ---> y_out");
       disp("        ------------------     ---------------------");
-      sys1 = tf2sys([1, 2],[1, 2, 1], 1,"u_in","y_disc");
-      sys2 = tf2sys([1, 0],[1, -3, -2],0,"c_in","y_out");
+      sys1 = tf([1, 2],[1, 2, 1], 1,"u_in","y_disc");
+      sys2 = tf([1, 0],[1, -3, -2],0,"c_in","y_out");
       sys = sysmult(sys2,sys1);
       disp("Consider the hybrid system")
       sysout(sys);
       prompt
       help syscont
       disp("The continuous part of the system can be extracted with syscont")
       cmd = "[csys,Acd,Ccd] = syscont(sys);";
       run_cmd
@@ -165,18 +165,18 @@ function bddemo ()
       disp("The discrete part of the system can be extracted with sysdisc")
       cmd = "[dsys,Adc,Cdc] = sysdisc(sys)";
       run_cmd
       disp("The resulting dsys is")
       sysout(dsys);
       disp("sysdisc returns dsys=empty since sys has no discrete outputs.");
       prompt
       disp("Example block diagram 2:")
-      sys1 = tf2sys([1, 2],[1, 2, 1], 1,"u_in","y_disc");
-      sys2 = tf2sys([1, 0],[1, -3, -2],0,"c_in","y_out");
+      sys1 = tf([1, 2],[1, 2, 1], 1,"u_in","y_disc");
+      sys2 = tf([1, 0],[1, -3, -2],0,"c_in","y_out");
       disp("             ---------------------")
       disp(" u_in -->o-->| Discrete system   | --------> y_disc")
       disp("         ^   ---------------------    |")
       disp("         |                            | ");
       disp("         -----------------------------|---")
       disp("                                      |  |")
       disp("         ------------------------------  |")
       disp("         |                               |")
@@ -204,19 +204,19 @@ function bddemo ()
       disp("********* N O T E *********")
       disp("sysdup is fully demonstrated in the design examples (option 13)")
       prompt
     elseif (k == 7)
       help sysgroup
       disp(" ")
       prompt
       disp("Example: combine two SISO systems together:")
-      cmd = "sys_a=tf2sys([1, 2],[3, 4]);";
+      cmd = "sys_a=tf([1, 2],[3, 4]);";
       run_cmd
-      cmd = "sys_b=tf2sys([5, 6],[7, 8],1);";
+      cmd = "sys_b=tf([5, 6],[7, 8],1);";
       run_cmd
       cmd = "sys_g=sysgroup(sys_a,sys_b);";
       run_cmd
       disp("Notice that sysgroup warns you when you join a purely continuous")
       disp("system to a purely discrete system.  sysgroup also warns when")
       disp("you join two systems that have common state, input, or output names.")
       cmd = "sysout(sys_g)";
       run_cmd
@@ -230,32 +230,32 @@ function bddemo ()
       help sysmult
       disp("sysmult performs a series connection of two systems.")
       disp("Example 1")
       disp(" ")
       disp("         ----------     ----------")
       disp("   u --->|  Bsys  |---->|  Asys  |---> y")
       disp("         ----------     ----------")
       disp(" ")
-      Asys = tf2sys(1,[1, 2, 1],0,"a_in","a_out");
-      Bsys = tf2sys([2, 3],[1, 3, 2],0,"b_in","b_out");
+      Asys = tf(1,[1, 2, 1],0,"a_in","a_out");
+      Bsys = tf([2, 3],[1, 3, 2],0,"b_in","b_out");
       disp("Asys=")
       sysout(Asys);
       disp("Bsys=");
       sysout(Bsys);
       cmd = "sys = sysmult(Asys,Bsys);";
       run_cmd
       disp("sys =")
       sysout(sys);
       disp("Notice that sysmult automatically transforms to state space")
       disp("internal representation.  This is to avoid numerical problems")
       disp("when multiplying polynomials");
       prompt
       disp("Example 2: same system, except that Bsys is discrete-time");
-      Bsys = tf2sys([2, 3],[1, 3, 2],1e-2,"b_in","b_out");
+      Bsys = tf([2, 3],[1, 3, 2],1e-2,"b_in","b_out");
       sysout(Bsys);
       cmd = "sys = sysmult(Asys,Bsys);";
       run_cmd
       disp("sys =")
       sysout(sys);
       prompt
     elseif (k == 9)
       help sysprune
@@ -269,36 +269,36 @@ function bddemo ()
       prompt
       disp("********* N O T E *********")
       disp("See the design examples (option 13) for use of sysscale.")
       prompt
     elseif ( k == 11)
       help parallel
       disp("parallel operates by making a call to sysgroup and sysscale.")
       disp("Example:")
-      sys1 = tf2sys(1,[1, 1],0,"in1","out1");
-      sys2 = tf2sys(2,[1, 2],0,"in2","out2");
+      sys1 = tf(1,[1, 1],0,"in1","out1");
+      sys2 = tf(2,[1, 2],0,"in2","out2");
       disp("sys1=")
       sysout(sys1);
       disp("sys2=")
       sysout(sys2);
       cmd = "sysp = parallel(sys1,sys2);";
       run_cmd
       disp("sysp=")
       sysout(sysp);
       prompt
       disp("parallel can be used for multiple input systems as well:")
 
-      in1 = list("u1.1","u1.2");
-      in2 = list("u2.1","u2.2");
-      out1 = list("y1.1","y1.2");
-      out2 = list("y2.1","y2.2");
+      in1 = {"u1.1","u1.2"};
+      in2 = {"u2.1","u2.2"};
+      out1 = {"y1.1","y1.2"};
+      out2 = {"y2.1","y2.2"};
 
-      sys1 = ss2sys([-1, 0; 0, -2],eye(2),eye(2),[]);
-      sys2 = ss2sys([-2, 0; 0, -4],eye(2),eye(2),[]);
+      sys1 = ss([-1, 0; 0, -2],eye(2),eye(2),[]);
+      sys2 = ss([-2, 0; 0, -4],eye(2),eye(2),[]);
 
       sys1 = syssetsignals(sys1,"in",in1);
       sys1 = syssetsignals(sys1,"out",out1);
 
       sys2 = syssetsignals(sys2,"in",in2);
       sys2 = syssetsignals(sys2,"out",out2);
 
       disp("sys1=")
@@ -366,18 +366,18 @@ function bddemo ()
       disp("P(s)=")
       tfout(nump,denp)
       numk = [1, 1];
       denk = [1, 0];
       disp("\nK(s)=")
       tfout(numk,denk);
       prompt
       disp("We'll show three approaches.  ")
-      P = tf2sys(nump,denp,0,"plant input","plant output");
-      K = tf2sys(numk, denk,0,"controller input","controller output");
+      P = tf(nump,denp,0,"plant input","plant output");
+      K = tf(numk, denk,0,"controller input","controller output");
 
       meth = 0;
       while(meth != 5)
         disp("The first method consists of the following steps:")
         disp("   step 1: create systems P and K")
         disp("   step 2: group P and K together")
         disp("   step 3: create a summing junction")
         disp("   step 4: connect outputs to respective inputs")
@@ -405,24 +405,24 @@ function bddemo ()
           disp("  r(t) ---> (+) --->| K(s) |--->| P(s) | ----> y(t)");
           disp("            -^      --------    --------  |");
           disp("             |                            |");
           disp("             ------------------------------");
           disp(" ")
           disp("Step 1: put plants in system format:");
           nump
           denp
-          cmd =  "P = tf2sys(nump,denp,0,""plant input"",""plant output"");";
+          cmd =  "P = tf(nump,denp,0,""plant input"",""plant output"");";
           run_cmd
           disp("P=")
           sysout(P)
           prompt
           numk
           denk
-          cmd = "K = tf2sys(numk, denk,0,""controller input"",""controller output"");";
+          cmd = "K = tf(numk, denk,0,""controller input"",""controller output"");";
           run_cmd
           sysout(K)
           prompt
           disp("Step 2: group the systems together")
           cmd = "PK = sysgroup(P,K);";
           run_cmd
           disp("PK=")
           sysout(PK);
@@ -532,19 +532,19 @@ function bddemo ()
           disp("         +          --------    --------");
           disp("  r(t) ---> (+) --->| K(s) |--->| P(s) | ----> y(t)");
           disp("            -^      --------    --------  |");
           disp("             |                            |");
           disp("             ------------------------------");
           disp(" ")
       disp("Step 1: We've already created systems P and K.  Create a sum ")
       disp("block as follows:")
-      cmd = "S = ss2sys([],[],[],[1, -1],0,0,0,[],list(""r(t)"",""y(t)""),""e(t)"");";
+      cmd = 'S = ss([],[],[],[1, -1],0,0,0,[],{"r(t)", "y(t)"},"e(t)");';
       run_cmd
-      disp("(You may wish to look at help ss2sys to see what the above does)");
+      disp("(You may wish to look at help ss to see what the above does)");
       disp("S=")
       sysout(S)
       disp("notice that this is just a gain block that outputs e = r - y")
       prompt
       disp("Step 2: series connections of P, K, and S")
       cmd = "PKS = sysmult(P,sysmult(K,S));";
       run_cmd
       disp("PKS=")
diff --git a/scripts/control/base/bode.m b/scripts/control/base/bode.m
--- a/scripts/control/base/bode.m
+++ b/scripts/control/base/bode.m
@@ -158,17 +158,17 @@ function [mag_r, phase_r, w_r] = bode (s
 	tistr = "(exp(jwT)) ";
       else
 	xlstr = "Frequency in rad/sec";
 	tistr = "(jw)";
       endif
       xlabel(xlstr);
       if(is_siso(sys))
 	subplot(2,1,1);
-	title(["|[Y/U]",tistr,"|, u=", nth(inname,1),", y=",nth(outname,1)]);
+	title(["|[Y/U]",tistr,"|, u=", inname{1},", y=",outname{1}]);
       else
 	title([ "||Y(", tistr, ")/U(", tistr, ")||"]);
 	disp("MIMO plot from")
 	disp(__outlist__(inname,"     "));
 	disp("to")
 	disp(__outlist__(outname,"    "));
       endif
       wv = [min(w), max(w)];
@@ -192,17 +192,17 @@ function [mag_r, phase_r, w_r] = bode (s
       if (is_siso(sys))
 	subplot(2,1,2);
 	axvec = axis2dlim([vec(w),vec(phase)]);
 	axvec(1:2) = wv;
 	axis(axvec);
 	xlabel(xlstr);
 	ylabel("Phase in deg");
 	title([ "phase([Y/U]", tistr, ...
-	   "), u=", nth(inname,1),", y=",nth(outname,1)]);
+	   "), u=", inname{1},", y=",outname{1}]);
 	grid("on");
 	semilogx(w,phase);
 	## This should be the default for subsequent plot commands.
 	oneplot();
       endif
     unwind_protect_cleanup
       automatic_replot = save_automatic_replot;
     end_unwind_protect
diff --git a/scripts/control/base/dre.m b/scripts/control/base/dre.m
--- a/scripts/control/base/dre.m
+++ b/scripts/control/base/dre.m
@@ -72,22 +72,22 @@
 ## @item maxits
 ## number of refinement iterations (default=10)
 ## @end table
 ## @strong{Outputs}
 ## @table @var
 ## @item tvals
 ## time values at which @var{p}(@var{t}) is computed
 ## @item plist
-## list values of @var{p}(@var{t}); nth (@var{plist}, @var{ii})
+## list values of @var{p}(@var{t}); @var{plist} {  @var{ii} }
 ## is @var{p}(@var{tvals}(@var{ii})).
 ##
 ## @item tvals
 ## @example
-## is selected so that || nth(Plist,ii) - nth(Plist,ii-1) || < Ptol
+## is selected so that || Plist{ii} - Plist{ii-1} || < Ptol
 ## for ii=2:length(tvals)
 ## @end example
 ## @end table
 ## @end deftypefn
 
 function [tvals, Plist] = dre (sys, Q, R, Qf, t0, tf, Ptol, maxits)
 
   if(nargin < 6 | nargin > 8 | nargout != 2)
@@ -141,23 +141,23 @@ function [tvals, Plist] = dre (sys, Q, R
   while(!done)
     done = 1;      # assume this pass will do the job
     ## sort time values in reverse order
     tvals = -sort(-tvals);
     tvlen = length(tvals);
     maxerr = 0;
     ## compute new values of P(t); recompute old values just in case
     for ii=2:tvlen
-      uv_i_minus_1 = [ In ; nth(Plist,ii-1) ];
+      uv_i_minus_1 = [ In ; Plist{ii-1} ];
       delta_t = tvals(ii-1) - tvals(ii);
       uv = expm(-H*delta_t)*uv_i_minus_1;
       Qi = uv(n1:n2,1:nn)/uv(1:nn,1:nn);
       Plist(ii) = (Qi+Qi')/2;
       ## check error
-      Perr = norm(nth(Plist,ii) - nth(Plist,ii-1))/norm(nth(Plist,ii));
+      Perr = norm(Plist{ii} - Plist{ii-1})/norm(Plist{ii});
       maxerr = max(maxerr,Perr);
       if(Perr > Ptol)
         new_t = mean(tvals([ii,ii-1]));
         tvals = [tvals, new_t];
         done = 0;
       endif
     endfor
 
diff --git a/scripts/control/base/frdemo.m b/scripts/control/base/frdemo.m
--- a/scripts/control/base/frdemo.m
+++ b/scripts/control/base/frdemo.m
@@ -52,17 +52,17 @@ function frdemo ()
                   "Return to frdemo menu");
 
         if( k1 == 1 )
           disp(" ")
           clc
           disp("\nContinuous system bode analysis\n");
           disp("Example #1:")
           disp("\nConsider the system sys1=");
-          sys1=tf2sys([1, 1], [1, 0, -1]);
+          sys1=tf([1, 1], [1, 0, -1]);
           sysout(sys1);
           disp("\nPole-zero form can be obtained as follows:")
           cmd = "sysout(sys1,""zp"");";
           run_cmd;
           disp("The systems bode plot is obtained as follows:");
           cmd = "bode(sys1);";
           run_cmd;
           disp("\nNotice that bode automatically labels the plots according to")
@@ -82,31 +82,31 @@ function frdemo ()
           disp("\n[Mag,Phase,w] = bode(sys);");
           disp("\nThis will return three vectors containing the magnitude,");
           disp("phase and frequency.\n");
           prompt;
 
           disp("")
           clc
           disp("Example #2, sys2=")
-          cmd = "sys2=zp2sys(1, [-1, -5], 10);";
+          cmd = "sys2=zp(1, [-1, -5], 10);";
           eval(cmd);
           cmd = "sysout(sys2);";
           eval(cmd);
           disp("\nThe bode plot command is identical to the tf form:")
           cmd = "bode(sys2);";
           run_cmd;
           disp("\nThe internal representation of the system is not important;")
           disp("bode automatically sorts it out internally.")
           prompt;
 
           disp("")
           clc
           disp("Example #3, Consider the following state space system sys3=:\n");
-          cmd = "sys3=ss2sys([0, 1; -1000, -1001], [0; 1], [0, -891], 1);";
+          cmd = "sys3=ss([0, 1; -1000, -1001], [0; 1], [0, -891], 1);";
           eval(cmd);
           cmd = "sysout(sys3);";
           eval(cmd);
           disp("\nOnce again, the bode plot command is the same:");
           cmd = "bode(sys3);";
           run_cmd;
           disp("\nSuppose the user is interested in the response of the system");
           disp("defined over the input frequency range of 1 - 1000 rad/s.\n");
@@ -170,17 +170,17 @@ function frdemo ()
 
         elseif( k1 == 2 )
           disp("")
           clc
           disp("\nDiscrete system bode analysis\n");
           disp("Display bode plots of a discrete SISO system (dbode)\n")
           disp("Example #1, Consider the following discrete transfer");
           disp(" function:\n");
-          cmd = "sys1 = tf2sys([0.00100502, -0.00099502], [1, -2, 1], 0.001);";
+          cmd = "sys1 = tf([0.00100502, -0.00099502], [1, -2, 1], 0.001);";
           disp(cmd);
           eval(cmd);
           cmd = "sysout(sys1)";
           disp(cmd);
           eval(cmd);
           disp("\nTo examine open loop zeros and poles of the system,");
           disp("use the command:\n")
           cmd = "sysout(sys1,""zp"");";
@@ -209,17 +209,17 @@ function frdemo ()
           disp("          system will be evaluated at these specific");
           disp("          frequencies\n");
 
           prompt
           disp("")
           clc
           disp("Example #2, Consider the following set of discrete poles and");
           disp("zeros:\n")
-          cmd = "sys2 = zp2sys([0.99258;0.99745],[0.99961;0.99242],1,0.001);";
+          cmd = "sys2 = zp([0.99258;0.99745],[0.99961;0.99242],1,0.001);";
           disp(cmd);
           eval(cmd);
           cmd = "sysout(sys2)";
           disp(cmd);
           eval(cmd);
           disp("\nTo view the system's bode plots, execute the following");
           disp("command:\n")
           cmd = "bode(sys2);";
@@ -227,17 +227,17 @@ function frdemo ()
           disp("Notice that the bode command is the same in both of the previous");
           disp("examples.  The bode command is also the same for the continuous case.");
           disp("The function, dbode, is no longer used.");
 
           prompt
           disp("")
           clc
           disp("\nExample #3, Now consider the following state space system:\n");
-          cmd = "sys3 = ss2sys([.857, .0011; 0, .99930],[1;1],[-.6318, .0057096],5.2, .001);";
+          cmd = "sys3 = ss([.857, .0011; 0, .99930],[1;1],[-.6318, .0057096],5.2, .001);";
           disp(cmd);
           eval(cmd);
           cmd = "sysout(sys3);";
           disp(cmd);
           eval(cmd);
           disp("\nTo view the system's bode plots, execute the following command:\n")
           cmd = "bode(sys3);";
           run_cmd;
@@ -318,17 +318,17 @@ function frdemo ()
                   "Return to frdemo menu");
 
         if( k2 == 1 )
           disp("")
           clc
           disp("\nContinuous system nyquist analysis\n");
           disp("Display Nyquist plots of a SISO system (nyquist)\n")
           disp("Example #1, Consider the following transfer function:\n")
-          cmd = "sys1 = tf2sys(1, [1, 0.8, 1]);";
+          cmd = "sys1 = tf(1, [1, 0.8, 1]);";
           disp(cmd);
           eval(cmd);
           disp("To examine the transfer function, use the command:");
           cmd = "sysout(sys1);";
           disp(cmd);
           eval(cmd);
           disp("\nTo examine the open loop zeros and poles, use the command:");
           cmd = "sysout(sys1,""zp"");";
@@ -355,33 +355,33 @@ function frdemo ()
           disp("          if wrange is entered in the argument list, the");
           disp("          system will be evaluated at these specific");
           disp("          frequencies\n")
           prompt
 
           disp("")
           clc
           disp("Example #2, Consider the following set of poles and zeros:\n")
-          cmd = "sys2 = zp2sys([-1;-4],[-2+1.4142i;-2-1.4142i],1);";
+          cmd = "sys2 = zp([-1;-4],[-2+1.4142i;-2-1.4142i],1);";
           disp(cmd);
           eval(cmd);
           disp("\nTo examine the poles and zeros, use the command:");
           cmd = "sysout(sys2)";
           disp(cmd);
           eval(cmd);
           disp("\nTo view the system""s nyquist plot, execute the following");
           disp("command:\n")
           cmd = "nyquist(sys2);";
           run_cmd;
           prompt
 
           disp("")
           clc
           disp("\nExample #3, Consider the following state space system:\n")
-          cmd = "sys3 = ss2sys([0, 1, 0, 0; 0, 0, 1, 0; 0, 0, 0, 1; 0, 0, -20, -12],[0;0;0;1],[50, 100, 0, 0],0);";
+          cmd = "sys3 = ss([0, 1, 0, 0; 0, 0, 1, 0; 0, 0, 0, 1; 0, 0, -20, -12],[0;0;0;1],[50, 100, 0, 0],0);";
           disp(cmd);
           eval(cmd);
           disp("\nTo examine the state-space system, use the command:");
           cmd = "sysout(sys3)";
           disp(cmd);
           eval(cmd);
           disp("\nTo examine the poles and zeros, use the command:");
           cmd = "sysout(sys3,""zp"")";
@@ -444,17 +444,17 @@ function frdemo ()
           clc
           disp("\nDiscrete system nyquist analysis\n");
           disp("Display Nyquist plots of a discrete SISO system (nyquist)\n")
           disp("We will first define a sampling time, T");
           cmd = "T = 0.01;";
           disp(cmd);
           eval(cmd);
           disp("\nExample #1, Consider the following transfer function:\n")
-          cmd = "sys1 = tf2sys([2, -3.4, 1.5],[1, -1.6, 0.8],T);";
+          cmd = "sys1 = tf([2, -3.4, 1.5],[1, -1.6, 0.8],T);";
           disp(cmd);
           eval(cmd);
           disp("To examine the transfer function, use the command:");
           cmd = "sysout(sys1);";
           disp(cmd);
           eval(cmd);
           disp("\nTo examine the open loop zeros and poles, use the command:");
           cmd = "sysout(sys1,""zp"")";
@@ -486,17 +486,17 @@ function frdemo ()
           disp("wrange => optional vector of frequencies")
           disp("          if wrange is entered in the argument list, the");
           disp("          system will be evaluated at these specific");
           prompt
 
           disp("")
           clc
           disp("\nExample #2, Consider the following set of poles and zeros:\n")
-          cmd = "sys2 = zp2sys([0.98025 + 0.01397i; 0.98025 - 0.01397i],[0.96079;0.99005],1,T);";
+          cmd = "sys2 = zp([0.98025 + 0.01397i; 0.98025 - 0.01397i],[0.96079;0.99005],1,T);";
           disp(cmd);
           eval(cmd);
           disp("\nTo examine the open loop zeros and poles, use the command:");
           cmd = "sysout(sys2)";
           disp(cmd);
           eval(cmd);
           disp("\nTo view the system's nyquist plot between the frequencies");
           disp("0.01 - 100 rad/s, execute the following commands:\n")
@@ -509,17 +509,17 @@ function frdemo ()
 
           disp("")
           clc
           disp("\nExample #3, Consider the following discrete state space");
           disp("system:\n");
           disp("This example will use the same system used in the third");
           disp("example in the continuous nyquist demo.  First, that system");
           disp("will have to be re-entered useing the following commands:\n");
-          cmd = "sys3 = ss2sys([0, 1, 0, 0; 0, 0, 1, 0; 0, 0, 0, 1; 0, 0, -20, -12],[0;0;0;1],[50, 100, 0, 0],0);";
+          cmd = "sys3 = ss([0, 1, 0, 0; 0, 0, 1, 0; 0, 0, 0, 1; 0, 0, -20, -12],[0;0;0;1],[50, 100, 0, 0],0);";
           disp(cmd);
           eval(cmd);
           disp("\nTo examine the state-space system, use the command:");
           cmd = "sysout(sys3)";
           disp(cmd);
           eval(cmd);
           disp("\nTo examine the poles and zeros, use the command:");
           cmd = "sysout(sys3,""zp"")";
diff --git a/scripts/control/base/lqg.m b/scripts/control/base/lqg.m
--- a/scripts/control/base/lqg.m
+++ b/scripts/control/base/lqg.m
@@ -101,20 +101,20 @@ function [K, Q1, P1, Ee, Er] = lqg (sys,
     input_list = sysidx(sys,"in",input_list);
   endif
 
   if(length(input_list) != columns(R))
     error(["lqg: length(input_list)=",num2str(length(input_list)), ...
           ", columns(R)=", num2str(columns(R))]);
   endif
 
-  varname = list("Sigw","Sigv","Q","R");
+  varname = {"Sigw","Sigv","Q","R"};
   for kk=1:length(varname);
-    eval(sprintf("chk = issquare(%s);",nth(varname,kk)));
-    if(! chk ) error("lqg: %s is not square",nth(varname,kk)); endif
+    eval(sprintf("chk = issquare(%s);",varname{kk}));
+    if(! chk ) error("lqg: %s is not square",varname{kk}); endif
   endfor
 
   ## permute (if need be)
   if(nargin == 6)
     all_inputs = sysreorder(nin,input_list);
     B = B(:,all_inputs);
     inname = inname(all_inputs);
   endif
@@ -144,14 +144,14 @@ function [K, Q1, P1, Ee, Er] = lqg (sys,
 
   ## fix controller output names
   outname1 = strappend(inname(m2:nin),"_K");
 
   ## fix controller input names
   inname1 = strappend(outname,"_K");
 
   if(DIG)
-    K = ss2sys(Ac,Bc,Cc,Dc,tsam,n,nz,stname1,inname1,outname1,1:rows(Cc));
+    K = ss(Ac,Bc,Cc,Dc,tsam,n,nz,stname1,inname1,outname1,1:rows(Cc));
   else
-    K = ss2sys(Ac,Bc,Cc,Dc,tsam,n,nz,stname,inname1,outname1);
+    K = ss(Ac,Bc,Cc,Dc,tsam,n,nz,stname,inname1,outname1);
   endif
 
 endfunction
diff --git a/scripts/control/base/nyquist.m b/scripts/control/base/nyquist.m
--- a/scripts/control/base/nyquist.m
+++ b/scripts/control/base/nyquist.m
@@ -141,17 +141,17 @@ function [realp, imagp, w] = nyquist (sy
         tstr = " G(jw) ";
       endif
       xlabel(["Re(",tstr,")"]);
       ylabel(["Im(",tstr,")"]);
 
       [stn, inn, outn] = sysgetsignals(sys);
       if(is_siso(sys))
         title(sprintf("Nyquist plot from %s to %s, w (rad/s) in [%e, %e]", ...
-          nth(inn,1), nth(outn,1), w(1), w(length(w))) )
+          inn{1}, outn{1}, w(1), w(length(w))) )
       endif
 
       gset nologscale xy;
 
       axis(axis2dlim([[vec(realp),vec(imagp)];[vec(realp),-vec(imagp)]]));
       plot(realp,imagp,"- ;+w;",realp,-imagp,"-@ ;-w;");
 
       ## check for interactive plots
diff --git a/scripts/control/base/place.m b/scripts/control/base/place.m
--- a/scripts/control/base/place.m
+++ b/scripts/control/base/place.m
@@ -46,17 +46,17 @@ function K = place (sys, P)
 
   save_warn_empty_list_elements = warn_empty_list_elements;
   unwind_protect
     warn_empty_list_elements = 0;
 
     ## check arguments
 
     if(!isstruct(sys))
-      error("sys must be in system data structure format (see ss2sys)");
+      error("sys must be in system data structure format (see ss)");
     endif
     sys = sysupdate(sys,"ss");    # make sure it has state space form up to date
     if(!is_controllable(sys))
       error("sys is not controllable.");
     elseif( min(size(P)) != 1)
       error("P must be a vector")
     else
       P = reshape(P,length(P),1); # make P a column vector
diff --git a/scripts/control/base/rldemo.m b/scripts/control/base/rldemo.m
--- a/scripts/control/base/rldemo.m
+++ b/scripts/control/base/rldemo.m
@@ -39,49 +39,49 @@ function rldemo ()
     if (k == 1)
       clc
       help pzmap
       prompt
 
       clc
       disp("Display continuous system's open loop poles and zeros (pzmap)\n");
       disp("Example #1, Consider the following continuous transfer function:");
-      cmd = "sys1 = tf2sys([1.5, 18.5, 6], [1, 4, 155, 302, 5050]);";
+      cmd = "sys1 = tf([1.5, 18.5, 6], [1, 4, 155, 302, 5050]);";
       disp(cmd);
       eval(cmd);
       cmd ="sysout(sys1);";
       disp(cmd);
       eval(cmd);
       disp("\nPole-zero form can be obtained as follows:");
       cmd = "sysout(sys1,""zp"");";
       disp(cmd);
       eval(cmd);
       disp("View the system's open loop poles and zeros with the command:")
       cmd = "pzmap(sys1);";
       run_cmd
       prompt
 
       clc
       disp("Example #2, Consider the following set of poles and zeros:");
-      cmd = "sys2 = zp2sys([-1, 5, -23],[-1, -10, -7+5i, -7-5i],5);";
+      cmd = "sys2 = zp([-1, 5, -23],[-1, -10, -7+5i, -7-5i],5);";
       disp(cmd);
       eval(cmd);
       cmd = "sysout(sys2);";
       disp(cmd);
       eval(cmd);
       disp("\nThe pzmap command for the zp form is the same as the tf form:")
       cmd = "pzmap(sys2);";
       run_cmd;
       disp("\nThe internal representation of the system is not important;");
       disp("pzmap automatically sorts it out internally.");
       prompt;
 
       clc
       disp("Example #3, Consider the following state space system:\n");
-      cmd = "sys3=ss2sys([0, 1; -10, -11], [0; 1], [0, -2], 1);";
+      cmd = "sys3=ss([0, 1; -10, -11], [0; 1], [0, -2], 1);";
       disp(cmd);
       eval(cmd);
       cmd = "sysout(sys3);";
       disp(cmd);
       eval(cmd);
       disp("\nPole-zero form can be obtained as follows:");
       cmd = "sysout(sys3,""zp"");";
       disp(cmd);
@@ -100,49 +100,49 @@ function rldemo ()
       prompt
 
       clc
       disp("\nDisplay discrete system's open loop poles and zeros (pzmap)\n");
       disp("First we must define a sampling time, as follows:\n");
       cmd = "Tsam = 1;";
       run_cmd;
       disp("Example #1, Consider the following discrete transfer function:");
-      cmd = "sys1 = tf2sys([1.05, -0.09048], [1, -2, 1],Tsam);";
+      cmd = "sys1 = tf([1.05, -0.09048], [1, -2, 1],Tsam);";
       disp(cmd);
       eval(cmd);
       cmd ="sysout(sys1);";
       disp(cmd);
       eval(cmd);
       disp("\nPole-zero form can be obtained as follows:");
       cmd = "sysout(sys1,""zp"");";
       disp(cmd);
       eval(cmd);
       disp("View the system's open loop poles and zeros with the command:")
       cmd = "pzmap(sys1);";
       run_cmd
       prompt
 
       clc
       disp("Example #2, Consider the following set of discrete poles and zeros:");
-      cmd = "sys2 = zp2sys(-0.717, [1, -0.368], 3.68, Tsam);";
+      cmd = "sys2 = zp(-0.717, [1, -0.368], 3.68, Tsam);";
       disp(cmd);
       eval(cmd);
       cmd = "sysout(sys2);";
       disp(cmd);
       eval(cmd);
       disp("\nThe pzmap command for the zp form is the same as the tf form:")
       cmd = "pzmap(sys2);";
       run_cmd;
       disp("\nThe internal representation of the system is not important;");
       disp("pzmap automatically sorts it out internally.");
       prompt;
 
       clc
       disp("Example #3, Consider the following discrete state space system:\n");
-      cmd = "sys3=ss2sys([1, 0.0952; 0, 0.905], [0.00484; 0.0952], [1, 0], 0, Tsam);";
+      cmd = "sys3=ss([1, 0.0952; 0, 0.905], [0.00484; 0.0952], [1, 0], 0, Tsam);";
       disp(cmd);
       eval(cmd);
       cmd = "sysout(sys3);";
       disp(cmd);
       eval(cmd);
       disp("\nPole-zero form can be obtained as follows:");
       cmd = "sysout(sys3,""zp"");";
       disp(cmd);
@@ -158,17 +158,17 @@ function rldemo ()
     elseif (k == 3)
       clc
       help rlocus
       prompt;
 
       clc
       disp("Display root locus of a continuous SISO system (rlocus)\n")
       disp("Example #1, Consider the following continuous transfer function:");
-      cmd = "sys1 = tf2sys([1.5, 18.5, 6],[1, 4, 155, 302, 5050]);";
+      cmd = "sys1 = tf([1.5, 18.5, 6],[1, 4, 155, 302, 5050]);";
       disp(cmd);
       eval(cmd);
       cmd ="sysout(sys1);";
       disp(cmd);
       eval(cmd);
       disp("\nPole-zero form can be obtained as follows:");
       cmd = "sysout(sys1,""zp"");";
       disp(cmd);
@@ -181,32 +181,32 @@ function rldemo ()
       disp("\nrlocus automatically selects the minimum and maximum gains based")
       disp("on the real-axis locus breakpoints.  The plot limits are chosen")
       disp("to be no more than 10 times the maximum magnitude of the open")
       disp("loop poles/zeros.");
       prompt
 
       clc
       disp("Example #2, Consider the following set of poles and zeros:");
-      cmd = "sys2 = zp2sys([],[0, -20, -2, -0.1],5);";
+      cmd = "sys2 = zp([],[0, -20, -2, -0.1],5);";
       disp(cmd);
       eval(cmd);
       cmd = "sysout(sys2);";
       disp(cmd);
       eval(cmd);
       disp("\nThe rlocus command for the zp form is the same as the tf form:")
       cmd = "rlocus(sys2);";
       run_cmd;
       disp("\nThe internal representation of the system is not important;");
       disp("rlocus automatically sorts it out internally.");
       prompt;
 
       clc
       disp("Example #3, Consider the following state space system:\n");
-      cmd = "sys3=ss2sys([0, 1; -10, -11], [0; 1], [0, -2], 0);";
+      cmd = "sys3=ss([0, 1; -10, -11], [0; 1], [0, -2], 0);";
       disp(cmd);
       eval(cmd);
       cmd = "sysout(sys3);";
       disp(cmd);
       eval(cmd);
       disp("\nPole-zero form can be obtained as follows:");
       cmd = "sysout(sys3,""zp"");";
       disp(cmd);
@@ -228,17 +228,17 @@ function rldemo ()
       prompt
 
       clc
       disp("Display root locus of a discrete SISO system (rlocus)\n")
       disp("First we must define a sampling time, as follows:\n");
       cmd = "Tsam = 1;";
       run_cmd;
       disp("Example #1, Consider the following discrete transfer function:");
-      cmd = "sys1 = tf2sys([1.05, -0.09048],[1, -2, 1],Tsam);";
+      cmd = "sys1 = tf([1.05, -0.09048],[1, -2, 1],Tsam);";
       disp(cmd);
       eval(cmd);
       cmd ="sysout(sys1);";
       disp(cmd);
       eval(cmd);
       disp("\nPole-zero form can be obtained as follows:");
       cmd = "sysout(sys1,""zp"");";
       disp(cmd);
@@ -251,34 +251,34 @@ function rldemo ()
       disp("\nrlocus automatically selects the minimum and maximum gains based")
       disp("on the real-axis locus breakpoints.  The plot limits are chosen")
       disp("to be no more than 10 times the maximum magnitude of the open")
       disp("loop poles/zeros.");
       prompt
 
       clc
       disp("Example #2, Consider the following set of discrete poles and zeros:");
-      cmd = "sys2 = zp2sys(-0.717, [1, -0.368], 3.68, Tsam);";
+      cmd = "sys2 = zp(-0.717, [1, -0.368], 3.68, Tsam);";
       disp(cmd);
       eval(cmd);
       cmd = "sysout(sys2);";
       disp(cmd);
       eval(cmd);
       disp("\nThe rlocus command for the zp form is the same as the tf form:")
       cmd = "rlocus(sys2);";
       run_cmd;
       disp("\nThe internal representation of the system is not important;");
       disp("rlocus automatically sorts it out internally.  Also, it does not");
       disp("matter if the system is continuous or discrete.  rlocus also sorts");
       disp("this out automatically");
       prompt;
 
       clc
       disp("Example #3, Consider the following discrete state space system:\n");
-      cmd = "sys3=ss2sys([1, 0.0952; 0, 0.905], [0.00484; 0.0952], [1, 0], 0, Tsam);";
+      cmd = "sys3=ss([1, 0.0952; 0, 0.905], [0.00484; 0.0952], [1, 0], 0, Tsam);";
       disp(cmd);
       eval(cmd);
       cmd = "sysout(sys3);";
       disp(cmd);
       eval(cmd);
       disp("\nPole-zero form can be obtained as follows:");
       cmd = "sysout(sys3,""zp"");";
       disp(cmd);
diff --git a/scripts/control/base/rlocus.m b/scripts/control/base/rlocus.m
--- a/scripts/control/base/rlocus.m
+++ b/scripts/control/base/rlocus.m
@@ -186,17 +186,17 @@ function [rldata, k_break, rlpol, gvec, 
     axlim = axis2dlim(axdata);
     axlim(1:2) = [xmin, xmax];
     gset nologscale xy;
     grid("on");
     rldata = [real(rlpolv), imag(rlpolv) ];
     axis(axlim);
     [stn,inname,outname] = sysgetsignals(sys);
     xlabel(sprintf("Root locus from %s to %s, gain=[%f,%f]: Real axis", ...
-        nth(inname,1),nth(outname,1),gvec(1),gvec(ngain)));
+        inname{1}, outname{1},gvec(1),gvec(ngain)));
     ylabel("Imag. axis");
 
     plot(real(rlpolv),imag(rlpolv),".1;locus points;", ...
         real(olpol),imag(olpol),"x2;open loop poles;", ...
         real(rlzer),imag(rlzer),"o3;zeros;");
     rldata = [];
   endif
 endfunction
diff --git a/scripts/control/base/tzero.m b/scripts/control/base/tzero.m
--- a/scripts/control/base/tzero.m
+++ b/scripts/control/base/tzero.m
@@ -49,17 +49,17 @@
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: July 4, 1994
 ## A. S. Hodel Aug 1995: allow for MIMO and system data structures
 
 function [zer, gain] = tzero (A, B, C, D)
 
   ## get A,B,C,D and Asys variables, regardless of initial form
   if(nargin == 4)
-    Asys = ss2sys(A,B,C,D);
+    Asys = ss(A,B,C,D);
   elseif( (nargin == 1) && (! isstruct(A)))
     usage("[zer,gain] = tzero(A,B,C,D) or zer = tzero(Asys)");
   elseif(nargin != 1)
     usage("[zer,gain] = tzero(A,B,C,D) or zer = tzero(Asys)");
   else
     Asys = A;
     [A,B,C,D] = sys2ss(Asys);
   endif
@@ -78,20 +78,20 @@ function [zer, gain] = tzero (A, B, C, D
   ## First, balance the system via the zero computation generalized eigenvalue
   ## problem balancing method (Hodel and Tiller, Linear Alg. Appl., 1992)
 
   Asys = __zgpbal__ (Asys); [A,B,C,D] = sys2ss(Asys);   # balance coefficients
   meps = 2*eps*norm ([A, B; C, D], "fro");
   Asys = zgreduce(Asys,meps);  [A, B, C, D] = sys2ss(Asys); # ENVD algorithm
   if(!isempty(A))
     ## repeat with dual system
-    Asys = ss2sys(A', C', B', D');   Asys = zgreduce(Asys,meps);
+    Asys = ss(A', C', B', D');   Asys = zgreduce(Asys,meps);
 
     ## transform back
-    [A,B,C,D] = sys2ss(Asys);    Asys = ss2sys(A', C', B', D');
+    [A,B,C,D] = sys2ss(Asys);    Asys = ss(A', C', B', D');
   endif
 
   zer = [];                     # assume none
   [A,B,C,D] = sys2ss(Asys);
   if( !isempty(C) )
     [W,r,Pi] = qr([C, D]');
     [nonz,ztmp] = zgrownorm(r,meps);
     if(nonz)
diff --git a/scripts/control/hinf/dgkfdemo.m b/scripts/control/hinf/dgkfdemo.m
--- a/scripts/control/hinf/dgkfdemo.m
+++ b/scripts/control/hinf/dgkfdemo.m
@@ -22,17 +22,17 @@
 ## @end deftypefn
 
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: June 1995
 
 function dgkfdemo ()
 
   save_val = page_screen_output;
-  page_screen_output = 1;
+  page_screen_output = 0;
   while (1)
     clc
     sel = 0;
     while (sel > 10 || sel < 1)
       sel = menu ("Octave H2/Hinfinity options demo",
                   "LQ regulator",
                   "LG state estimator",
                   "LQG optimal control design",
@@ -92,17 +92,17 @@ function dgkfdemo ()
       disp("Example 1: continuous time design:")
       prompt
       help lqg
       disp("Example system")
       A = [0, 1; .5, .5];
       B = [0; 2];
       G = eye(2)
       C = [1, 1];
-      sys = ss2sys(A, [B, G], C);
+      sys = ss(A, [B, G], C);
       sys = syssetsignals(sys,"in", ...
                        ["control input"; "disturbance 1"; "disturbance 2"]);
       sysout(sys)
       prompt
       disp("Filtering/estimator parameters:")
       SigW = eye(2)
       SigV = 1
       prompt
@@ -119,17 +119,17 @@ function dgkfdemo ()
       cmd = "Acl = [A, B*Cc; Bc*C, Ac]";
       run_cmd
       disp("Check: poles of Acl:")
       Acl_poles = sortcom(eig(Acl))
       disp("Predicted poles from design = union(Er,Ee)")
       cmd = "pred_poles = sortcom([Er; Ee])";
       run_cmd
       disp("Example 2: discrete-time example")
-      cmd1 = "Dsys = ss2sys(A, [G, B], C, [0, 0, 0], 1);";
+      cmd1 = "Dsys = ss(A, [G, B], C, [0, 0, 0], 1);";
       cmd2 = "[K,Q1,P1,Ee,Er] = lqg(Dsys,SigW, SigV,Q,R);";
       disp("Run commands:")
       cmd = cmd1;
       run_cmd
       cmd = cmd2;
       run_cmd
       prompt
       disp("Check: closed loop system A-matrix is")
@@ -143,17 +143,17 @@ function dgkfdemo ()
       disp("Predicted poles from design = union(Er,Ee)")
       pred_poles = sortcom([Er;Ee])
     elseif (sel == 4)
       disp("H2 gain of a system: (Energy in impulse response)")
       disp("Example 1: Stable plant:")
       cmd = "A = [0, 1; -2, -1]; B = [0; 1]; C = [1, 0]; sys_poles = eig(A)";
       run_cmd
       disp("Put into Packed system form:")
-      cmd = "Asys = ss2sys(A,B,C);";
+      cmd = "Asys = ss(A,B,C);";
       run_cmd
       disp("Evaluate system 2-norm (impulse response energy):");
       cmd = "AsysH2 = h2norm(Asys)";
       run_cmd
       disp("Compare with a plot of the system impulse response:")
       tt = 0:0.1:20;
       for ii=1:length(tt)
         ht(ii) = C*expm(A*tt(ii))*B;
@@ -167,17 +167,17 @@ function dgkfdemo ()
       cmd = "B = [0; 1]";
       eval(cmd);
       cmd = "C = [1, 0]";
       eval(cmd);
       cmd = "sys_poles = eig(A)";
       run_cmd
       prompt
       disp("Put into system data structure form:")
-      cmd="Bsys = ss2sys(A,B,C);";
+      cmd="Bsys = ss(A,B,C);";
       run_cmd
       disp("Evaluate 2-norm:")
       cmd = "BsysH2 = h2norm(Bsys)";
       run_cmd
       disp(" ")
       prompt("NOTICE: program returns a value without an error signal.")
       disp("")
 
@@ -207,17 +207,17 @@ function dgkfdemo ()
       eval(cmd);
       cmd = "D12 = [0; 1];  D21 = [0, 1];  D22 = 0; D = [D11, D12; D21, D22];";
       disp(cmd)
       eval(cmd);
       disp("Design objective: compute U(s)=K(s)Y1(s) to minimize the closed")
       disp("loop impulse response from w(t) =[w1; w2] to z(t) = [y1; y2]");
       prompt
       disp("First: pack system:")
-      cmd="Asys = ss2sys(A, [B1, B2], [C1; C2], D);";
+      cmd="Asys = ss(A, [B1, B2], [C1; C2], D);";
       run_cmd
       disp("Open loop multivariable Bode plot: (will take a moment)")
       cmd="bode(Asys);";
       run_cmd
       prompt("Press a key to close plot and continue");
       closeplot
       disp("Controller design command: (only need 1st two output arguments)")
       cmd="[K,gain, Kc, Kf, Pc,  Pf] = h2syn(Asys,1,1);";
@@ -245,17 +245,17 @@ function dgkfdemo ()
       disp("Related functions: is_dgkf, is_controllable, is_stabilizable,")
       disp("                is_observable, is_detectable")
     elseif (sel == 6)
       disp("Hinfinity gain of a system: (max gain over all j-omega)")
       disp("Example 1: Stable plant:")
       cmd = "A = [0, 1; -2, -1]; B = [0; 1]; C = [1, 0]; sys_poles = eig(A)";
       run_cmd
       disp("Pack into system format:")
-      cmd = "Asys = ss2sys(A,B,C);";
+      cmd = "Asys = ss(A,B,C);";
       run_cmd
       disp("The infinity norm must be computed iteratively by")
       disp("binary search.  For this example, we select tolerance tol = 0.01, ")
       disp("min gain gmin = 1e-2, max gain gmax=1e4.")
       disp("Search quits when upper bound <= (1+tol)*lower bound.")
       cmd = "tol = 0.01; gmin = 1e-2; gmax = 1e+4;";
       run_cmd
       cmd = "[AsysHinf,gmin,gmax] = hinfnorm(Asys,tol,gmin,gmax)"
@@ -269,17 +269,17 @@ function dgkfdemo ()
       disp(["Max magnitude is ",num2str(max(M)), ...
         ", compared with gmin=",num2str(gmin)," and gmax=", ...
         num2str(gmax),"."])
       prompt
       disp("Example 2: unstable plant")
       cmd = "A = [0, 1; 2, 1]; B = [0; 1]; C = [1, 0]; sys_poles = eig(A)";
       run_cmd
       disp("Pack into system format:")
-      cmd = "Bsys = ss2sys(A,B,C);";
+      cmd = "Bsys = ss(A,B,C);";
       run_cmd
       disp("Evaluate with BsysH2 = hinfnorm(Bsys,tol,gmin,gmax)")
       BsysH2 = hinfnorm(Bsys,tol,gmin,gmax)
       disp(" ")
       disp("NOTICE: program returns a value without an error signal.")
       disp("")
 
     elseif (sel == 7)
@@ -296,17 +296,17 @@ function dgkfdemo ()
       C2 = [1, 0]
       D11 = zeros(2);
       D12 = [0; 1];
       D21 = [0, 1];
       D22 = 0;
       D = [D11, D12; D21, D22]
       prompt
       disp("First: pack system:")
-      cmd="Asys = ss2sys(A, [B1, B2], [C1; C2], D);";
+      cmd="Asys = ss(A, [B1, B2], [C1; C2], D);";
       run_cmd
       prompt
       disp("Open loop multivariable Bode plot: (will take a moment)")
       cmd="bode(Asys);";
       run_cmd
       prompt
       disp("Controller design command: (only need 1st two output arguments)")
       gmax = 1000
diff --git a/scripts/control/hinf/dhinfdemo.m b/scripts/control/hinf/dhinfdemo.m
--- a/scripts/control/hinf/dhinfdemo.m
+++ b/scripts/control/hinf/dhinfdemo.m
@@ -83,17 +83,17 @@ eval(cmd);
 disp("weighting on controlled variable y");
 cmd = "W2 = wgt1o(350.0, 0.05, 0.0002);";
 disp(cmd);
 eval(cmd);
 ## omega axis (column vector)
 ww = vec(logspace(-4.99, 3.99, 100));
 
 disp("Create ZOH equivalent model of a continuous plant");
-cmd = "G = tf2sys(2,[1 3 2]);  Gd = c2d(G, Ts);";
+cmd = "G = tf(2,[1 3 2]);  Gd = c2d(G, Ts);";
 run_cmd
 
 ## w-plane (continuous representation of the sampled system)
 disp("W-plane transform of discrete time system:");
 cmd = "Gw = d2c(Gd, \"bi\");";
 run_cmd
 
 disp(" ");
diff --git a/scripts/control/hinf/h2syn.m b/scripts/control/hinf/h2syn.m
--- a/scripts/control/hinf/h2syn.m
+++ b/scripts/control/hinf/h2syn.m
@@ -23,17 +23,17 @@
 ## H2 and Hinf Control Problems", IEEE TAC August 1989
 ##
 ## Discrete time control per Zhou, Doyle, and Glover, ROBUST AND OPTIMAL
 ## CONTROL, Prentice-Hall, 1996
 ##
 ## @strong{Inputs} input system is passed as either
 ## @table @var
 ## @item asys
-## system data structure (see ss2sys, sys2ss)
+## system data structure (see ss, sys2ss)
 ## @itemize @bullet
 ## @item controller is implemented for continuous time systems
 ## @item controller is NOT implemented for discrete time systems
 ## @end itemize
 ## @item nu
 ## number of controlled inputs
 ## @item ny
 ## number of measured outputs
@@ -112,58 +112,58 @@ function [K, gain, Kc, Kf, Pc, Pf] = h2s
     error("h2syn: discrete-time case not yet implemented")
     Pc = dare(A,Bu*Bu',Cz'*Cz);
     Pf = dare(A',Cy'*Cy,Bw*Bw');
   endif
 
   nn = ncstates + ndstates;
   In = eye(nn);
   KA = A + Bu*F2 + L2*Cy;
-  Kc1 = ss2sys(AF2,Bw,CzF2,zeros(nz,nw));
-  Kf1 = ss2sys(AL2,BwL2,F2,zeros(nu,nw));
+  Kc1 = ss(AF2,Bw,CzF2,zeros(nz,nw));
+  Kf1 = ss(AL2,BwL2,F2,zeros(nu,nw));
 
   g1 = h2norm(Kc1);
   g2 = h2norm(Kf1);
 
   ## compute optimal closed loop gain
   gain = sqrt ( g1*g1 + g2*g2 );
 
   if(nargout)
     Kst = strappend(Ast,"_K");
     Kin = strappend(Aout((nout-ny+1):(nout)),"_K");
     Kout = strappend(Ain((nin-nu+1):(nin)),"_K");
 
     ## compute systems for return
-    K = ss2sys(KA,-L2/Ru,Ry\F2,zeros(nu,ny),Atsam,ncstates,ndstates,Kst,Kin,Kout);
+    K = ss(KA,-L2/Ru,Ry\F2,zeros(nu,ny),Atsam,ncstates,ndstates,Kst,Kin,Kout);
   endif
 
   if (nargout > 2)
     ## system full information control state names
     stname2 = strappend(Ast,"_FI");
 
    ## system full information control input names
    inname2 = strappend(Ast,"_FI_in");
 
     ## system full information control output names
     outname2 = strappend(Aout(1:(nout-ny)),"_FI_out");
 
     nz = rows (Cz);
     nw = columns (Bw);
 
-    Kc = ss2sys(AF2, In, CzF2, zeros(nz,nn), Atsam, ...
+    Kc = ss(AF2, In, CzF2, zeros(nz,nn), Atsam, ...
         ncstates, ndstates, stname2, inname2, outname2);
   endif
 
   if (nargout >3)
     ## fix system state estimator state names
     stname3 = strappend(Ast,"_Kf");
 
     ## fix system state estimator input names
     inname3 = strappend(Ast,"_Kf_noise");
 
     ## fix system state estimator output names
     outname3 = strappend(Ast,"_est");
 
-    Kf = ss2sys(AL2, BwL2, In, zeros(nn,nw),Atsam,  ...
+    Kf = ss(AL2, BwL2, In, zeros(nn,nw),Atsam,  ...
       ncstates, ndstates, stname3, inname3,outname3);
   endif
 
 endfunction
diff --git a/scripts/control/hinf/hinf_ctr.m b/scripts/control/hinf/hinf_ctr.m
--- a/scripts/control/hinf/hinf_ctr.m
+++ b/scripts/control/hinf/hinf_ctr.m
@@ -134,11 +134,11 @@ function K = hinf_ctr (dgs, F, H, Z, g)
     mhat = inv(eye(nu+ny) + dhat*d22new);
     ahat = ahat - bhat*((eye(nu+ny)-xx)/dhat)*chat;
     bhat = bhat*xx;
     chat = mhat*chat;
     dhat = dhat*xx;
 
   endif
 
-  K = ss2sys(ahat,bhat(:,1:ny),chat(1:nu,:),dhat(1:nu,1:ny));
+  K = ss(ahat,bhat(:,1:ny),chat(1:nu,:),dhat(1:nu,1:ny));
 
 endfunction
diff --git a/scripts/control/hinf/hinfsyn.m b/scripts/control/hinf/hinfsyn.m
--- a/scripts/control/hinf/hinfsyn.m
+++ b/scripts/control/hinf/hinfsyn.m
@@ -17,17 +17,17 @@
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{k}, @var{g}, @var{gw}, @var{xinf}, @var{yinf}] =} hinfsyn (@var{asys}, @var{nu}, @var{ny}, @var{gmin}, @var{gmax}, @var{gtol}, @var{ptol}, @var{tol})
 ##
 ## @strong{Inputs} input system is passed as either
 ## @table @var
 ## @item asys
-## system data structure (see ss2sys, sys2ss)
+## system data structure (see ss, sys2ss)
 ## @itemize @bullet
 ## @item controller is implemented for continuous time systems
 ## @item controller is NOT implemented for discrete time systems  (see
 ## bilinear transforms in @code{c2d}, @code{d2c})
 ## @end itemize
 ## @item nu
 ## number of controlled inputs
 ## @item ny
@@ -166,38 +166,38 @@ function [K, g, GW, Xinf, Yinf] = hinfsy
     printf("           .........X......... .........Y......... ");
     printf(".Z. PASS REMARKS\n");
     printf("        ga iax nev ene sym pos iax nev ene sym pos ");
     printf("rho  y/n ======>\n");
     printf("----------------------------------------");
     printf("--------------------------------------\n");
 
     ## set up error messages
-    errmesg = list(" o   o   o   o   o  ", ...
+    errmesg = {" o   o   o   o   o  ", ...
         " #   -   -   -   -  ", ...
         " o   #   -   -   -  ", ...
         " o   o   #   -   -  ", ...
         " o   o   o   #   -  ", ...
         " o   o   o   o   #  ", ...
-        " -   -   -   -   -  ");
-    errdesx = list("", ...
+        " -   -   -   -   -  "};
+    errdesx = {"", ...
         "X im eig.", ...
         "Hx not Ham.", ...
         "X inf.eig", ...
         "X not symm.", ...
         "X not pos", ...
-        "R singular");
+        "R singular"};
 
-    errdesy = list(" ", ...
+    errdesy = {" ", ...
         "Y im eig.", ...
         "Hy not Ham.", ...
         "Y inf.eig", ...
         "Y not symm.", ...
         "Y not pos", ...
-        "Rtilde singular");
+        "Rtilde singular"};
 
 
     ## now do the search
     while (!iteration_finished)
       switch (search_state)
         case (0)        g = ghi;
         case (1)        g = glo;
         case (2)        g = 0.5 * (ghi + glo);
@@ -228,25 +228,25 @@ function [K, g, GW, Xinf, Yinf] = hinfsy
           ## spectral radius condition passed
           passed = 1;
         else
           rerr = sprintf("rho=%f",rho);
         endif
       endif
 
       if(x_ha_err >= 0 & x_ha_err <= 6)
-        printf("%s",nth(errmesg,x_ha_err+1));
-        xerr = nth(errdesx,x_ha_err+1);
+        printf("%s",errmesg{x_ha_err+1});
+        xerr = errdesx{x_ha_err+1};
       else
         error(" *** Xinf fail: this should never happen!");
       endif
 
       if(y_ha_err >= 0 & y_ha_err <= 6)
-        printf("%s",nth(errmesg,y_ha_err+1));
-        yerr = nth(errdesy,y_ha_err+1);
+        printf("%s",errmesg{y_ha_err+1});
+        yerr = errdesy{y_ha_err+1};
       else
         error(" *** Yinf fail: this should never happen!");
       endif
 
       if(passed)  printf("  y all tests passed.\n");
       else        printf("  n %s/%s%s\n",xerr,yerr,rerr);          endif
 
       if (passed && (de/g < gtol))
@@ -293,17 +293,17 @@ function [K, g, GW, Xinf, Yinf] = hinfsy
       F = -R \ (d1dot'*C1 + BB'*Xinf);
       H = -(B1*ddot1' + Yinf*CC') / Rtilde;
       K = hinf_ctr(dgs,F,H,Z,g);
 
       Kst = strappend(Ast,"_K");
       Kin = strappend(Aout((nout-ny+1):(nout)),"_K");
       Kout = strappend(Ain((nin-nu+1):(nin)),"_K");
       [Ac, Bc, Cc, Dc] = sys2ss(K);
-      K = ss2sys(Ac,Bc,Cc,Dc,Atsam,ncstates,ndstates,Kst,Kin,Kout);
+      K = ss(Ac,Bc,Cc,Dc,Atsam,ncstates,ndstates,Kst,Kin,Kout);
       if (nargout >= 3)
         GW = starp(Asys, K);
       endif
     endif
 
   elseif(ndstates)
 
     ## discrete time solution
diff --git a/scripts/control/hinf/wgt1o.m b/scripts/control/hinf/wgt1o.m
--- a/scripts/control/hinf/wgt1o.m
+++ b/scripts/control/hinf/wgt1o.m
@@ -50,10 +50,10 @@ function wsys = wgt1o (vl, vh, fc)
       c = [];
   else
       a = [-2*pi*fc];
       b = [-2*pi*fc];
       c = [vh-vl];
   endif
   d=[vh];
 
-  wsys = ss2sys(a,b,c,d);
+  wsys = ss(a,b,c,d);
 endfunction
diff --git a/scripts/control/obsolete/dlqg.m b/scripts/control/obsolete/dlqg.m
--- a/scripts/control/obsolete/dlqg.m
+++ b/scripts/control/obsolete/dlqg.m
@@ -113,12 +113,12 @@ function [K, Q, P, Ee, Er] = dlqg (A, B,
   ## now we can just do the design; call dlqr and dlqe, since all matrices
   ## are not given in Cholesky factor form (as in h2syn case)
   [Ks, P, Er] = dlqr(A,B,Q,R);
   [Ke, Q, jnk, Ee] = dlqe(A,G,C,Sigw,Sigv);
   Ac = A - Ke*C - B*Ks;
   Bc = Ke;
   Cc = -Ks;
   Dc = zeros(rows(Cc),columns(Bc));
-  K = ss2sys(Ac,Bc,Cc,Dc,1);
+  K = ss(Ac,Bc,Cc,Dc,1);
   disp("HODEL: need to add names to this guy!")
 
 endfunction
diff --git a/scripts/control/obsolete/packsys.m b/scripts/control/obsolete/packsys.m
--- a/scripts/control/obsolete/packsys.m
+++ b/scripts/control/obsolete/packsys.m
@@ -11,17 +11,17 @@
 ## ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
-## O B S O L E T E: use ss2sys instead.
+## O B S O L E T E: use ss instead.
 ## function Asys = packsys(a,b,c[,d,dflg])
 ##
 ##   dflg: 0 for continuous time system, 1 for discrete-time system.
 ##
 ## defaults:
 ##      D: 0 matrix of appropriate dimension.
 ##   dflg: 0 (continuous time)
 ##
@@ -29,17 +29,17 @@
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: July 29, 1994
 ## Modified by David Clem November 13, 1994
 ## Modified by A. S. Hodel April 1995
 
 function Asys = packsys (a, b, c, d, dflg)
 
-  warning("packsys is obsolete!  Use ss2sys instead.");
+  warning("packsys is obsolete!  Use ss instead.");
 
   if (nargin < 3 || nargin > 5)
     disp("packsys: Invalid number of arguments")
   endif
 
   ## check dflg
   if(nargin == 5)
     if( !isscalar(dflg))
@@ -61,11 +61,11 @@ function Asys = packsys (a, b, c, d, dfl
     d = zeros(crows,bcols);
   endif
 
   [n,m,p] = abcddim(a,b,c,d);
   if (n == -1 || m == -1 || p == -1)
     error("packsys: incompatible dimensions")
   endif
 
-  Asys = ss2sys(a,b,c,d,dflg);
+  Asys = ss(a,b,c,d,dflg);
 
 endfunction
diff --git a/scripts/control/obsolete/series.m b/scripts/control/obsolete/series.m
--- a/scripts/control/obsolete/series.m
+++ b/scripts/control/obsolete/series.m
@@ -85,15 +85,15 @@ function [a, b, c, d] = series (a1, b1, 
     a = [a1, zeros(rows(a1),columns(a2));b2*c1, a2];
     b = [b1;b2*d1];
     c = [d2*c1, c2];
     d = [d2*d1];
 
     ## take care of mu output
 
     if(muflag == 1)
-      a=ss2sys(a,b,c,d);
+      a=ss(a,b,c,d);
       b=c=d=0;
     endif
   endif
 
 endfunction
 
diff --git a/scripts/control/system/__sysdefioname__.m b/scripts/control/system/__sysdefioname__.m
--- a/scripts/control/system/__sysdefioname__.m
+++ b/scripts/control/system/__sysdefioname__.m
@@ -20,17 +20,17 @@
 ## @deftypefn {Function File} {} __sysdefioname__ (@var{n}, @var{str}, @var{m})
 ## return default input or output names given @var{n}, @var{str}, @var{m}.
 ## @var{n} is the final value, @var{str} is the string prefix, and @var{m}
 ## is start value
 ##
 ## used internally, minimal argument checking
 ##
 ## @strong{Example} @code{ioname = __sysdefioname__(5,"u",3)}
-## returns the list:
+## returns the cell array:
 ## @example
 ## ioname =
 ## (
 ##   [1] = u_3
 ##   [2] = u_4
 ##   [3] = u_5
 ## )
 ## @end example
@@ -39,19 +39,19 @@
 function ioname = __sysdefioname__ (n, str, m)
 
   if (nargin < 2 | nargin > 3)
     usage ("ioname = __sysdefioname__ (n, str, m)");
   endif
 
   if (nargin == 2)           m = min(1,n);            endif
 
-  ioname = list();
+  ioname = {};
   jj = 1;
   if(n > 0 & m > 0 & m <= n)
     for ii = m:n
-      ioname(ii+1-m) = sprintf("%s_%d",str,ii);
+      ioname{ii+1-m} = sprintf("%s_%d",str,ii);
     endfor
   elseif(m > n)
     error("str=%s; start value m=%d > final value n=%d",str,m,n);
   endif
 
 endfunction
diff --git a/scripts/control/system/__sysdefstname__.m b/scripts/control/system/__sysdefstname__.m
--- a/scripts/control/system/__sysdefstname__.m
+++ b/scripts/control/system/__sysdefstname__.m
@@ -20,23 +20,23 @@
 ## @deftypefn {Function File} {} __sysdefstname__ (@var{n}, @var{nz})
 ## return default state names given @var{n}, @var{nz}
 ##
 ## used internally, minimal argument checking
 ## @end deftypefn
 
 function stname = __sysdefstname__ (n, nz)
 
-  stname = list ();
+  stname = {};
   if (n > 0)
     for ii = 1:n
-      stname(ii) = sprintf ("x_%d", ii);
+      stname{ii} = sprintf ("x_%d", ii);
     endfor
   endif
 
   ## Set default names for discrete states
   if (nz > 0)
     for ii = (n+1):(n+nz)
-      stname(ii) = sprintf ("xd_%d", ii);
+      stname{ii} = sprintf ("xd_%d", ii);
     endfor
   endif
 
 endfunction
diff --git a/scripts/control/system/__sysgroupn__.m b/scripts/control/system/__sysgroupn__.m
--- a/scripts/control/system/__sysgroupn__.m
+++ b/scripts/control/system/__sysgroupn__.m
@@ -30,26 +30,26 @@
 ## @end deftypefn
 
 function names = __sysgroupn__ (names, kind)
 
   ## check for duplicate names
   l = length(names);
   ii = 1;
   while(ii <= l-1)
-    st1 = nth(names,ii);
+    st1 = names{ii};
     jj = ii+1;
     while ( jj <= l)
-      st2 = nth(names,jj);
+      st2 = names{jj};
       if(strcmp(st1,st2))
         suffix = ["_",num2str(jj)];
         warning("sysgroup: %s name(%d) = %s name(%d) = %s", ...
           kind,ii,kind,jj,st1);
         strval = sprintf("%s%s",st2,suffix);
-        names(jj) = strval;
+        names{jj} = strval;
         warning("sysgroup:     changed %s name %d to %s",kind,jj,strval);
         ## restart the check (just to be sure there's no further duplications)
         ii = 0; jj = l;
       endif
       jj = jj+1;
     endwhile
     ii = ii+1;
   endwhile
diff --git a/scripts/control/system/__tf2sysl__.m b/scripts/control/system/__tf2sysl__.m
--- a/scripts/control/system/__tf2sysl__.m
+++ b/scripts/control/system/__tf2sysl__.m
@@ -19,17 +19,11 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} __tf2sysl__ (@var{vec})
 ## used internally in tf2sys.
 ## strip leading zero coefficients to get the true polynomial length
 ## @end deftypefn
 
 function vec = __tf2sysl__ (vec)
 
-  while (length (vec) > 1 && vec(1) == 0)
-    vec = vec (2:end);
-  endwhile
-
-  if (vec(1) == 0)
-    warning ("tf2sys: polynomial has no nonzero coefficients!")
-  endif
+  error("__tf2sysl__ no longer used; use the tf function.");
 
 endfunction
diff --git a/scripts/control/system/buildssic.m b/scripts/control/system/buildssic.m
--- a/scripts/control/system/buildssic.m
+++ b/scripts/control/system/buildssic.m
@@ -145,34 +145,34 @@ function sys = buildssic (Clst, Ulst, Ol
     if (n && nz)
       error("---> cannot handle mixed continuous and discrete systems.");
     endif
     D_SYS = (nz > 0);
     [A,B,C,D,tsam] = sys2ss(s1);
     nt = n + nz;
   endif
   for ii = 6:nargin
-    eval(["ss = s", num2str(ii-4), ";"]);
-    if (!isstruct(ss))
+    eval(["mysys = s", num2str(ii-4), ";"]);
+    if (!isstruct(mysys))
       error("---> Parameter must be a structed system.");
     endif
-    ss = sysupdate(ss, "ss");
-    [n1, nz1, m1, p1] = sysdimensions(ss);
+    mysys = sysupdate(mysys, "ss");
+    [n1, nz1, m1, p1] = sysdimensions(mysys);
     if (n1 && nz1)
       error("---> cannot handle mixed continuous and discrete systems.");
     endif
     if (D_SYS)
       if (n1)
         error("---> cannot handle mixed cont. and discr. systems.");
       endif
-      if (tsam != sysgettsam(ss))
+      if (tsam != sysgettsam(mysys))
         error("---> sampling time of all systems must match.");
       endif
     endif
-    [as,bs,cs,ds] = sys2ss(ss);
+    [as,bs,cs,ds] = sys2ss(mysys);
     nt1 = n1 + nz1;
     if (!nt1)
       ## pure gain (pad B, C with zeros)
       B = [B, zeros(nt,m1)];
       C = [C; zeros(p1,nt)];
     else
       A = [A, zeros(nt,nt1); zeros(nt1,nt), as];
       B = [B, zeros(nt,m1);  zeros(nt1,m),  bs];
@@ -290,11 +290,11 @@ function sys = buildssic (Clst, Ulst, Ol
     iu = Ilst(ii);
     if (!iu || (abs(iu) > m))
       error("---> invalid value in Ilst.");
     endif
     Bnew(:,ii) = sign(iu)*B(:,abs(iu));
     Dnew(:,ii) = sign(iu)*D(:,abs(iu));
   endfor
 
-  sys = ss2sys(A, Bnew, C, Dnew, tsam, n, nz);
+  sys = ss(A, Bnew, C, Dnew, tsam, n, nz);
 
 endfunction
diff --git a/scripts/control/system/c2d.m b/scripts/control/system/c2d.m
--- a/scripts/control/system/c2d.m
+++ b/scripts/control/system/c2d.m
@@ -148,17 +148,17 @@ function dsys = c2d (sys, opt, T)
     if(nz)
       aa(crng,drng) = matexp(crng,n+m+(1:nz));
     end
 
     stnames = sysgetsignals(sys,"st");   ## continuous states renamed below
     innames = sysgetsignals(sys,"in");
     outnames = sysgetsignals(sys,"out");
     outlist = 1:p;
-    dsys = ss2sys(aa,bb,cc,dd,T,0,n+nz,stnames,innames, ...
+    dsys = ss(aa,bb,cc,dd,T,0,n+nz,stnames,innames, ...
         outnames,outlist);
     ## rename states
     for ii=1:n
       strval = sprintf("%s_d",sysgetsignals(dsys,"st",ii,1));
       dsys = syssetsignals(dsys,"st",strval,ii);
     endfor
 
   elseif(strcmp(opt,"bi"))
@@ -170,33 +170,33 @@ function dsys = c2d (sys, opt, T)
       IT = (2/T)*eye(size(a));
       A = (IT+a)/(IT-a);
       iab = (IT-a)\b;
       tk=2/sqrt(T);
       B = tk*iab;
       C = tk*(c/(IT-a));
       D = d + (c*iab);
       stnamed = strappend(stname,"_d");
-      dsys = ss2sys(A,B,C,D,T,0,rows(A),stnamed,inname,outname);
+      dsys = ss(A,B,C,D,T,0,rows(A),stnamed,inname,outname);
      endif
    elseif(strcmp(opt,"matched"))
      if(is_digital(sys))
        error("c2d: system is already digital");
      elseif((length(sys.inname) != 1) || (length(sys.outname) != 1))
        error("c2d: system in not single input, single output");
      else
        sys = sysupdate(sys,"zp");
        p = exp(sys.pol*T);
        z = exp(sys.zer*T);
        infinite_zeros = max(size(sys.pol))-max(size(sys.zer))-1;
        for i = 1:infinite_zeros
 	 z = [z ; -1];
        endfor
        ## Should the freaquency we adjust around always be 1?   
        [cmag,cphase,cw] = bode(sys,1);
-       [dmag,dpahse,dw] = bode(zp2sys(z,p,1,T),1);
-      dsys = zp2sys(z,p,cmag/dmag,T);
+       [dmag,dpahse,dw] = bode(zp(z,p,1,T),1);
+      dsys = zp(z,p,cmag/dmag,T);
     endif
   else
     error ("invalid option = %s", opt);
   endif
 
 endfunction
diff --git a/scripts/control/system/d2c.m b/scripts/control/system/d2c.m
--- a/scripts/control/system/d2c.m
+++ b/scripts/control/system/d2c.m
@@ -101,17 +101,17 @@ function csys = d2c (sys, opt)
     I = eye(size(a));
     tk = 2/sqrt(T);
     A = (2/T)*(a-I)/(a+I);
     iab = (I+a)\b;
     B = tk*iab;
     C = tk*(c/(I+a));
     D = d- (c*iab);
     stnamec = strappend(stname,"_c");
-    csys = ss2sys(A,B,C,D,0,rows(A),0,stnamec,inname,outname);
+    csys = ss(A,B,C,D,0,rows(A),0,stnamec,inname,outname);
   elseif(strcmp(opt,"log"))
     sys = sysupdate(sys,"ss");
     [n,nz,m,p] = sysdimensions(sys);
 
     if(nz == 0)
       warning("d2c: all states continuous; setting outputs to agree");
       csys = syssetsignals(sys,"yd",zeros(1,1:p));
       return;
@@ -204,17 +204,17 @@ function csys = d2c (sys, opt)
 
     endwhile
 
     [aa,bb,cc,dd,tsam,nn,nz,stnam,innam,outnam,yd] = sys2ss(sys);
     aa = Mall(1:na,1:na);
     if(!isempty(b))
       bb = Mall(1:na,(na+1):(na+nb));
     endif
-    csys = ss2sys(aa,bb,cc,dd,0,na,0,stnam,innam,outnam);
+    csys = ss(aa,bb,cc,dd,0,na,0,stnam,innam,outnam);
 
     ## update names
     nn = sysdimensions(sys);
     for ii = (nn+1):na
       strval = sprintf("%s_c",sysgetsignals(csys,"st",ii,1));
       csys = syssetsignals(csys,"st",strval,ii);
     endfor
   endif
diff --git a/scripts/control/system/dmr2d.m b/scripts/control/system/dmr2d.m
--- a/scripts/control/system/dmr2d.m
+++ b/scripts/control/system/dmr2d.m
@@ -136,22 +136,22 @@ function [dsys, fidx] = dmr2d (sys, idx,
     return
   elseif(isempty(sprefix))
     fidx = idx;
   else
     fidx = reshape(idx,1,length(idx));
     ## find states whose name begins with any strings in sprefix.
     ns = length(sprefix);
     for kk=1:ns
-      spk = nth(sprefix,kk);  # get next prefix and length
+      spk = sprefix{kk};  # get next prefix and length
       spl = length(spk);
 
       ## check each state name
       for ii=1:nz
-        sti = nth(stname,ii);  # compare spk with this state name
+        sti = stname{ii};  # compare spk with this state name
         if(length(sti) >= spl)
           ## if the prefix matches and ii isn't already in the list, add ii
           if(strcmp(sti(1:spl),spk) & !any(fidx == ii) )
             fidx = sort([fidx,ii]);
           endif
         endif
       endfor
     endfor
@@ -237,27 +237,27 @@ function [dsys, fidx] = dmr2d (sys, idx,
 
     ## similar for b1 block (checking for cuflg first!)
     b1w = a11*b1w;
     if(cuflg)
       b1b = b1b + b1w;        # update b1 block just like we did a12
     else
       b1b = [b1b, b1w];       # append new inputs
       newin = strappend(innamenz,["_d",num2str(kk-1)]);
-      inname = append(inname,newin);
+      inname = __sysconcat__(inname,newin);
     endif
   endfor
 
   ## reconstruct system and return
   da(bki,bki) = a11h;
   db(bki,1:columns(b1b)) = b1b;
   if(!isempty(bki2))
     da(bki,bki2) = a12b;
   endif
 
   da = da(pvi,pvi);
   db = db(pvi,:);
   stname = stname(pvi);
 
   ## construct new system and return
-  dsys = ss2sys(da,db,dc,dd,Ts2,0,nz,stname,inname,outname,find(yd == 1));
+  dsys = ss(da,db,dc,dd,Ts2,0,nz,stname,inname,outname,find(yd == 1));
 
 endfunction
diff --git a/scripts/control/system/fir2sys.m b/scripts/control/system/fir2sys.m
--- a/scripts/control/system/fir2sys.m
+++ b/scripts/control/system/fir2sys.m
@@ -75,17 +75,17 @@
 
 function sys = fir2sys (num, tsam, inname, outname)
 
   ## Test for the correct number of input arguments
   if (nargin < 1 | nargin > 4)
     usage ("sys = fir2sys(num [, tsam, inname, outname])");
   endif
 
-  ## let tf2sys do the argument checking
+  ## let tf do the argument checking
   den = [1,zeros(1,length(num)-1)];
 
   ## check sampling interval (if any)
   if (nargin <= 1)
     tsam = 1;           # default
   elseif (isempty(tsam))
     tsam = 1;
   endif
@@ -95,11 +95,11 @@ function sys = fir2sys (num, tsam, innam
     inname = __sysdefioname__ (1, "u");
   endif
 
   ## Set name of output
   if (nargin < 4)
     outname = __sysdefioname__ (1, "y");
   endif
 
-  sys = tf2sys (num, den, tsam, inname, outname);
+  sys = tf (num, den, tsam, inname, outname);
 
 endfunction
diff --git a/scripts/control/system/is_signal_list.m b/scripts/control/system/is_signal_list.m
--- a/scripts/control/system/is_signal_list.m
+++ b/scripts/control/system/is_signal_list.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996, 1998, 2000 Auburn University.  All rights reserved.
+## Copyright (C) 1996, 1998, 2000, 2004 Auburn University.  All rights reserved.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
 ##
@@ -18,19 +18,21 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} is_signal_list (@var{mylist})
 ## Return true if @var{mylist} is a list of individual strings.
 ## @end deftypefn
 
 function flg = is_signal_list (mylist)
 
-  flg = islist (mylist);
-
+  flg = iscell (mylist);
+  if(flg)
+    flg = (rows(mylist) == 1 | columns(mylist) == 1);
+  end
   if (flg)
     for ii = 1:length (mylist)
-      if (! (isstr (nth (mylist, ii)) && rows (nth (mylist,ii)) == 1))
+      if (! (isstr (mylist{ii}) && rows (mylist{ii}) == 1))
 	flg = 0;
       endif
     endfor
   endif
 
 endfunction
diff --git a/scripts/control/system/is_siso.m b/scripts/control/system/is_siso.m
--- a/scripts/control/system/is_siso.m
+++ b/scripts/control/system/is_siso.m
@@ -25,16 +25,16 @@
 ## Author: A. S. Hodel <a.s.hodel@eng.auburn.edu>
 ## Created: July 1996, 1998
 
 function  SISO = is_siso (sys)
 
   if (nargin != 1)
     usage ("SISO = is_siso (sys)");
   elseif (! isstruct (sys))
-    error ("input must be a system structure (see ss2sys, tf2sys, zp2sys)");
+    error ("input must be a system structure (see ss, tf, zp)");
   endif
 
   [n, nz, m, p] = sysdimensions (sys);
 
   SISO = (m == 1 && p == 1);
 
 endfunction
diff --git a/scripts/control/system/jet707.m b/scripts/control/system/jet707.m
--- a/scripts/control/system/jet707.m
+++ b/scripts/control/system/jet707.m
@@ -47,11 +47,11 @@ function outsys = jet707 ()
         0.9173594317692437E-01, -0.75283075;
         0.0,                     0.0 ];
   c = [ 1.0,  0.0,  0.0,  0.0;
         0.0,  0.0,  0.0,  1.0 ];
   d=zeros(2,2);
   inam = ["thrust"; "rudder"];
   onam = ["speed"; "pitch"];
   snam = ["x1"; "x2"; "x3"; "x4"];
-  outsys = ss2sys(a, b, c, d, 0.0, 4, 0, snam, inam, onam);
+  outsys = ss(a, b, c, d, 0.0, 4, 0, snam, inam, onam);
 
 endfunction
diff --git a/scripts/control/system/listidx.m b/scripts/control/system/listidx.m
--- a/scripts/control/system/listidx.m
+++ b/scripts/control/system/listidx.m
@@ -29,16 +29,17 @@
 ##
 ## If @var{strlist} contains a string not in @var{listvar}, then
 ## an error message is returned in @var{errmsg}.  If only one output
 ## argument is requested, then @var{listidx} prints @var{errmsg} to the
 ## screen and exits with an error.
 ## @end deftypefn
 
 function [idxvec,errmsg]  = listidx(listvar,strlist)
+  error("listidx: don't use this anymore, ok?\n");
 
 if(nargin != 2)
   usage("idxvec = listidx(listvar,strlist)");
 endif
 
 if(isstr(strlist))
   tmp = strlist;
   strlist = list();
@@ -68,22 +69,22 @@ endif
 if(length(errmsg))
   if(nargout < 2) error(errmsg);
   else return;
   endif
 endif
 
 nsigs = length(listvar);
 for idx = 1:length(strlist)
-  signame = nth(strlist,idx);
+  signame = strlist{idx};
   for jdx = 1:nsigs
-    if( strcmp(signame,nth(listvar,jdx)) )
+    if( strcmp(signame,listvar{jdx}) )
       if(idxvec(idx) != 0)
         warning("Duplicate signal name %s (%d,%d)\n", ...
-          nth(listvar,jdx),jdx,idxvec(idx));
+          listvar{jdx},jdx,idxvec(idx));
       else
         idxvec(idx) = jdx;
       endif
     endif
   endfor
   if(idxvec(idx) == 0)
     errmsg = sprintf("Did not find %s",signame);
     if(nargout == 1)
diff --git a/scripts/control/system/moddemo.m b/scripts/control/system/moddemo.m
--- a/scripts/control/system/moddemo.m
+++ b/scripts/control/system/moddemo.m
@@ -50,17 +50,17 @@ function moddemo ()
       disp("Example #1, Consider the following continuous time state space system:\n")
       a=[0, 1; -25, -4]
       b=[0; 1]
       c=[1, 1]
       d=1
       prompt
       disp("\nTo convert this to a discrete time system (using a zero order hold),")
       disp("use the following commands:\n")
-      cmd="sys=ss2sys(a,b,c,d);";
+      cmd="sys=ss(a,b,c,d);";
       run_cmd
       cmd="dsys = c2d(sys,0.2);";
       run_cmd
       cmd="sysout(dsys);";
       run_cmd
       disp("Function check\n")
       disp("Check the poles of sys vs dsys:\n")
       cmd="[da,db]=sys2ss(dsys);";
diff --git a/scripts/control/system/ord2.m b/scripts/control/system/ord2.m
--- a/scripts/control/system/ord2.m
+++ b/scripts/control/system/ord2.m
@@ -57,10 +57,10 @@ function outsys = ord2 (nfreq, damp, gai
   if (nargout > 1)
     usage("outsys = ord2(nfreq, damp[, gain])")
   endif
   if (nargin == 2)
     gain = 1.0;
   endif
 
   w = 2.0 * pi * nfreq;
-  outsys = ss2sys([-2.0*w*damp, -w; w, 0], [w; 0], [0, gain]);
+  outsys = ss ([-2.0*w*damp, -w; w, 0], [w; 0], [0, gain]);
 endfunction
diff --git a/scripts/control/system/packedform.m b/scripts/control/system/packedform.m
--- a/scripts/control/system/packedform.m
+++ b/scripts/control/system/packedform.m
@@ -82,14 +82,14 @@ disp(" ")
 disp("WARNING: some functions (e.g., bode) will not accept systems")
 disp("with both discrete and continuous states/outputs")
 disp("stname: list of signal names (strings) containing name(s) of system ")
 disp("        states");
 disp("===============================")
 disp("Object oriented programming:")
 disp("It is recommended that users do not directly access the internal")
 disp("variables themselves, but use the interface functions")
-disp("  fir2sys         ss2sys          tf2sys          sys2fir")
+disp("  fir             ss              tf              sys2fir")
 disp("  sys2ss          sys2tf          sys2zp          syschtsam")
 disp("  sysdimensions   sysgetsignals   syssetsignals   sysgettype")
-disp("  zp2sys")
+disp("  zp    ")
 disp("to create/access internal variables.  ");
 page_screen_output = save_var;
diff --git a/scripts/control/system/parallel.m b/scripts/control/system/parallel.m
--- a/scripts/control/system/parallel.m
+++ b/scripts/control/system/parallel.m
@@ -55,14 +55,14 @@ function sysp = parallel (Asys, Bsys)
   ## save signal names
   Ain = sysgetsignals(Asys,"in");
 
   ## change signal names to avoid warning messages from sysgroup
   Asys = syssetsignals(Asys,"in",__sysdefioname__(length(Ain),"Ain_u"));
   Bsys = syssetsignals(Bsys,"in",__sysdefioname__(length(Ain),"Bin_u"));
 
   sysp = sysgroup(Asys,Bsys);
-  sysD = ss2sys([],[],[],[eye(mA);eye(mA)]);
+  sysD = ss([],[],[],[eye(mA);eye(mA)]);
 
   sysp = sysmult(sysp,sysD);
   sysp = syssetsignals(sysp,"in",Ain);
 
 endfunction
diff --git a/scripts/control/system/ss2sys.m b/scripts/control/system/ss2sys.m
--- a/scripts/control/system/ss2sys.m
+++ b/scripts/control/system/ss2sys.m
@@ -12,17 +12,17 @@
 ## FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 ## for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {} ss2sys (@var{a}, @var{b}, @var{c}, @var{d}, @var{tsam}, @var{n}, @var{nz}, @var{stname}, @var{inname}, @var{outname}, @var{outlist})
+## @deftypefn {Function File} {} ss (@var{a}, @var{b}, @var{c}, @var{d}, @var{tsam}, @var{n}, @var{nz}, @var{stname}, @var{inname}, @var{outname}, @var{outlist})
 ## Create system structure from state-space data.   May be continous,
 ## discrete, or mixed (sampeled-data)
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item a
 ## @itemx b
 ## @itemx c
@@ -135,17 +135,17 @@
 ## that are not contained in outlist. (Discrete/continuous outputs
 ## may be entered in any order desired by the user.)
 ##
 ## @strong{Example}
 ## @example
 ## octave:1> a = [1 2 3; 4 5 6; 7 8 10];
 ## octave:2> b = [0 0 ; 0 1 ; 1 0];
 ## octave:3> c = eye(3);
-## octave:4> sys = ss2sys(a,b,c,[],0,3,0,list("volts","amps","joules"));
+## octave:4> sys = ss(a,b,c,[],0,3,0,list("volts","amps","joules"));
 ## octave:5> sysout(sys);
 ## Input(s)
 ##         1: u_1
 ##         2: u_2
 ##
 ## Output(s):
 ##         1: y_1
 ##         2: y_2
@@ -178,110 +178,14 @@
 ## Notice that the @math{D} matrix is constructed  by default to the
 ## correct dimensions.  Default input and output signals names were assigned
 ## since none were given.
 ## @end deftypefn
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 20, 1996
 
-function retsys = ss2sys (a, b, c, d, tsam, n, nz, stname, inname, outname, outlist)
-
-  ## Test for correct number of inputs
-  if ((nargin < 3) | (nargin > 11))
-    usage("retsys = ss2sys  (a,b,c{,d,tsam,n,nz,stname,inname,outname,outlist})");
-  endif
-
-  ## verify A, B, C, D arguments
-  ## If D is not specified, set it to a zero matrix of appriate dimension.
-  if (nargin == 3)          d = zeros(rows(c) , columns(b));
-  elseif (isempty(d))       d = zeros(rows(c) , columns(b));      endif
-
-  ## Check the dimensions
-  [na,m,p] = abcddim(a,b,c,d);
-
-  ## If dimensions are wrong, exit function
-  if (m == -1)
-    error("a(%dx%d), b(%dx%d), c(%dx%d), d(%dx%d); incompatible", ...
-      rows(a), columns(a), rows(b), columns(b), rows(c), columns(c), ...
-      rows(d), columns(d));
-  endif
-
-  ## check for tsam input
-  if(nargin < 5) tsam = 0;
-  elseif( !( is_sample(tsam) | (tsam == 0) ) )
-    error("tsam must be a nonnegative real scalar");
-  endif
-
-  ## check for continuous states
-  if( (nargin < 6) & (tsam == 0) )               n = na;
-  elseif(nargin < 6)                             n = 0;
-  elseif((!ismatrix(n)) | isstr(n))
-    error("Parameter n is not a numerical value.");
-  elseif( (!isscalar(n)) | (n < 0 ) | (n != round(n)) )
-    if(isscalar(n))     error("invalid value of n=%d,%e",n,n);
-    else                 error("invalid value of n=(%dx%d)", ...
-                           rows(n), columns(n));                endif
-  endif
-
-  ## check for num discrete states
-  if( (nargin < 7) & (tsam == 0))               nz = 0;
-  elseif(nargin < 7)                            nz = na - n;
-  elseif((!ismatrix(nz)) | isstr(nz))
-    error("Parameter nz is not a numerical value.");
-  elseif( (!isscalar(nz)) | (nz < 0 ) | (nz != round(nz)) )
-    if(isscalar(nz))
-      error(["invalid value of nz=",num2str(nz)]);
-    else
-      error(["invalid value of nz=(",num2str(rows(nz)),"x", ...
-        num2str(columns(nz)),")"]);
-    endif
-  endif
-
-  ## check for total number of states
-  if( (n + nz) != na )
-    error(["invalid: a is ",num2str(na),"x",num2str(na),", n=", ...
-        num2str(n),", nz=",num2str(nz)]);
-  endif
-
-  ## construct system with default names
-  retsys.a = a;
-  retsys.b = b;
-  retsys.c = c;
-  retsys.d = d;
-
-  retsys.n = n;
-  retsys.nz = nz;
-  retsys.tsam = tsam;
-  retsys.yd = zeros(1,p);     # default value entered below
-
-  ## Set the system vector:  active = 2(ss), updated = [0 0 1];
-  retsys.sys = [2, 0, 0, 1];
-
-  retsys.stname = __sysdefstname__ (n, nz);
-  retsys.inname = __sysdefioname__ (m, "u");
-  retsys.outname = __sysdefioname__ (p, "y");
-
-  ## check for state names
-  if(nargin >= 8)
-    if(!isempty(stname)) retsys = syssetsignals(retsys,"st",stname); endif
-  endif
-
-  ## check for input names
-  if(nargin >= 9)
-    if(!isempty(inname)) retsys = syssetsignals(retsys,"in",inname); endif
-  endif
-
-  ## check for output names
-  if(nargin >= 10)
-    if(!isempty(outname)) retsys = syssetsignals(retsys,"out",outname); endif
-  endif
-
-  ## set up yd
-  if(nargin < 11)
-    retsys = syssetsignals(retsys,"yd",ones(1,p)*(tsam > 0));
-  else
-    if(!isempty(outlist))
-      retsys = syssetsignals(retsys,"yd",ones(size(outlist)),outlist);
-    endif
-  endif
+function retsys = ss2sys (varargin )
+  
+  warning("ss2sys is deprecated.  Use ss() instead.");
+  retsys = ss(varargin{:});
 
 endfunction
diff --git a/scripts/control/system/sys2tf.m b/scripts/control/system/sys2tf.m
--- a/scripts/control/system/sys2tf.m
+++ b/scripts/control/system/sys2tf.m
@@ -15,21 +15,21 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{num}, @var{den}, @var{tsam}, @var{inname}, @var{outname}] =} sys2tf (@var{sys})
 ## Extract transfer function data from a system data structure
 ##
-## See tf2sys for parameter descriptions.
+## See tf for parameter descriptions.
 ##
 ## @strong{Example}
 ## @example
-## octave:1> sys=ss2sys([1 -2; -1.1,-2.1],[0;1],[1 1]);
+## octave:1> sys=ss([1 -2; -1.1,-2.1],[0;1],[1 1]);
 ## octave:2> [num,den] = sys2tf(sys)
 ## num = 1.0000  -3.0000
 ## den = 1.0000   1.1000  -4.3000
 ## @end example
 ## @end deftypefn
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: June 24, 1994
@@ -38,17 +38,17 @@
 
 function [num, den, tsam, inname, outname] = sys2tf (Asys)
 
   if(nargin != 1)
     usage("[num,den,tsam,inname,outname] = sys2tf(Asys)");
   endif
 
   if( !isstruct(Asys))
-    error("Asys must be a system data structure (see ss2sys, tf2sys, zp2sys)");
+    error("Asys must be a system data structure (see ss, tf, zp)");
   elseif (! is_siso(Asys) )
     [n, nz, m, p] = sysdimensions(Asys);
     error(["system is not SISO (",num2str(m)," inputs, ...
         ", num2str(p)," outputs"]);
   endif
 
   Asys = sysupdate(Asys,"tf");          # just in case
 
diff --git a/scripts/control/system/sys2zp.m b/scripts/control/system/sys2zp.m
--- a/scripts/control/system/sys2zp.m
+++ b/scripts/control/system/sys2zp.m
@@ -16,21 +16,21 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, 59 Temple Place, Suite 330, Boston, MA 02111 USA.
 
 ## -*- texinfo -*-
 ##@deftypefn {Function File} {[@var{zer}, @var{pol}, @var{k}, @var{tsam}, @var{inname}, @var{outname}] =} sys2zp (@var{sys})
 ## Extract zero/pole/leading coefficient information from a system data
 ## structure
 ##
-## See zp2sys for parameter descriptions.
+## See zp for parameter descriptions.
 ##
 ## @strong{Example}
 ## @example
-## octave:1> sys=ss2sys([1 -2; -1.1,-2.1],[0;1],[1 1]);
+## octave:1> sys=ss([1 -2; -1.1,-2.1],[0;1],[1 1]);
 ## octave:2> [zer,pol,k] = sys2zp(sys)
 ## zer = 3.0000
 ## pol =
 ##   -2.6953
 ##    1.5953
 ## k = 1
 ## @end example
 ## @end deftypefn
diff --git a/scripts/control/system/sysadd.m b/scripts/control/system/sysadd.m
--- a/scripts/control/system/sysadd.m
+++ b/scripts/control/system/sysadd.m
@@ -45,79 +45,82 @@
 
 function sys = sysadd (varargin)
 
   if(nargin < 1)
     usage("sysadd: sys = sysysadd(Gsys{,Hsys, ...})");
   endif
 
   ## collect all arguments
-  arglist = list();
+  arglist = {};
   for kk=1:nargin
-    arglist(kk) = varargin{kk};
-    if(!isstruct(nth(arglist,kk)))
+    arglist{kk} = varargin{kk};
+    if(!isstruct(arglist{kk}))
       error("sysadd: argument %d is not a data structure",kk);
     endif
   endfor
 
   ## check system dimensions
-  [n,nz,mg,pg,Gyd] = sysdimensions(nth(arglist,1));
+  [n,nz,mg,pg,Gyd] = sysdimensions(arglist{1});
   for kk=2:nargin
-    [n,nz,mh,ph,Hyd] = sysdimensions(nth(arglist,kk));
+    [n,nz,mh,ph,Hyd] = sysdimensions(arglist{kk});
     if(mg != mh)
       error("arg 1 has %d inputs; arg %d has vs %d inputs",mg,kk,mh);
     elseif(pg != ph)
       error("arg 1 has %d outputs; arg %d has vs %d outputs",pg,kk,ph);
     elseif(norm(Gyd - Hyd))
       warning("cannot add a discrete output to a continuous output");
       error("Output type mismatch: arguments 1 and %d\n",kk);
     endif
   endfor
 
   ## perform the add
   if (nargin == 2)
-    Gsys = nth(arglist,1);
-    Hsys = nth(arglist,2);
+    Gsys = arglist{1};
+    Hsys = arglist{2};
 
-    if (! strcmp (sysgettype (Gsys), "tf"))
+    # check if adding scalar transfer functions with identical denoms
+    [Gn, Gnz, Gm, Gp] = sysdimensions(Gsys);
+    [Hn, Hnz, Hm, Hp] = sysdimensions(Hsys);
+    if ( Gm ==1 & Gp == 1 & Hm == 1 & Hp == 1 & Gn == Hn & Gnz == Hnz )
+      # dimensions are compatible, check if can add
       [Gnum,Gden,GT,Gin,Gout] = sys2tf(Gsys);
-    endif
-
-    if (! strcmp (sysgettype (Hsys),"tf"))
       [Hnum,Hden,HT,Hin,Hout] = sys2tf(Hsys);
-    endif
+      if (length(Hden) == length(Gden) )
+        if( (Hden == Gden) & (HT == GT) )
+          sys = tf(Gnum+Hnum,Gden,GT,Gin,Gout);
 
-    ## see if adding  transfer functions with identical denominators
-    if (length(Hden) == length(Gden) )
-      if( (Hden == Gden) & (HT == GT) )
-        sys = tf2sys(Gnum+Hnum,Gden,GT,Gin,Gout);
-        return
+          return;   # return prematurely since the add is done.
+        endif
       endif
-      ## if not, we go on and do the usual thing...
     endif
 
     ## make sure in ss form
     Gsys = sysupdate(Gsys,"ss");
     Hsys = sysupdate(Hsys,"ss");
+    Gin = sysgetsignals(Gsys,"in");
+    Gout = sysgetsignals(Gsys,"out");
+    Hin = sysgetsignals(Hsys,"in");
+    Hout = sysgetsignals(Hsys,"out");
 
     ## change signal names to avoid warning messages from sysgroup
     Gsys = syssetsignals(Gsys,"in",__sysdefioname__(length(Gin),"Gin_u"));
     Gsys = syssetsignals(Gsys,"out",__sysdefioname__(length(Gout),"Gout_u"));
     Hsys = syssetsignals(Hsys,"in",__sysdefioname__(length(Hin),"Hin_u"));
     Hsys = syssetsignals(Hsys,"out",__sysdefioname__(length(Hout),"Hout_u"));
 
     sys = sysgroup(Gsys,Hsys);
 
     eyin = eye(mg);
     eyout = eye(pg);
 
     sys = sysscale(sys,[eyout, eyout],[eyin;eyin],Gout,Gin);
 
   else
     ## multiple systems (or a single system); combine together one by one
-    sys = nth(arglist,1);
+    sys = arglist{1};
     for kk=2:length(arglist)
-      sys = sysadd(sys,nth(arglist,kk));
+      sys = sysadd(sys,arglist{kk});
     endfor
   endif
 
 endfunction
 
diff --git a/scripts/control/system/sysappend.m b/scripts/control/system/sysappend.m
--- a/scripts/control/system/sysappend.m
+++ b/scripts/control/system/sysappend.m
@@ -110,18 +110,22 @@ function retsys = sysappend (sys, b, c, 
 	  error("inname must be a string");
 	elseif(rows(inname) != (Bm - Am))
 	  error(sprintf("%d new inputs requested; inname(%dx%d)", ...
 	    (Bm-Am),rows(inname),columns(inname)));
 	endif
       else
 	inname = __sysdefioname__(Bm,"u",(Am+1));
       endif
-      if(Am)   Ain = append(Ain,inname);
-      else     Ain = inname;              endif
+
+      if(Am)
+        Ain = __sysconcat__(Ain,inname);
+      else
+        Ain = inname;
+      endif
 
       ## default b matrix
       if(isempty(b))     b  = zeros(Ann+Anz,(Bm-Am));
       elseif(rows(b) != Ann+Anz | columns(b) != (Bm-Am))
 	  error(sprintf("b(%dx%d); should be (%dx%d)", rows(b), columns(b), ...
 	    (Ann+Anz), (Bm-Am)));
       endif
 
@@ -139,17 +143,17 @@ function retsys = sysappend (sys, b, c, 
 	  error("outname must be a string");
 	elseif(rows(outname) != (Bp - Ap))
 	  error(sprintf("%d new outputs requested; outname(%dx%d)", ...
 	    (Bp-Ap),rows(outname),columns(outname)));
 	endif
       else
 	outname = __sysdefioname__(Bp,"y",(Ap+1));
       endif
-      if(Ap)   Aout = append(Aout,outname);
+      if(Ap)   Aout = __sysconcat__(Aout,outname);
       else     Aout = outname;                endif
 
       ## construct new yd entries
       if(nargin == 7)
 	if(!isvector(yd))
 	  error(sprintf("yd(%dx%d) must be a vector",rows(yd),columns(yd)))
 	elseif(rows(c) != length(yd) & rows(d) != length(yd))
 	  error(sprintf("length(yd) = %d; c(%dx%d), d(%dx%d); mismatch", ...
@@ -178,15 +182,15 @@ function retsys = sysappend (sys, b, c, 
       error(sprintf("d(%dx%d) should be (%dx%d)",rows(d), columns(d), Bp, Bp));
     endif
 
     ## Splice in original D matrix
     if(Am & Ap)          d(1:Ap, 1:Am) = Ad;       endif
     Ad = d;
 
     ## construct return system
-    retsys = ss2sys(Aa,Ab,Ac,Ad,Ats,Ann,Anz,Ast,Ain,Aout,find(Ayd == 1));
+    retsys = ss(Aa,Ab,Ac,Ad,Ats,Ann,Anz,Ast,Ain,Aout,find(Ayd == 1));
 
   unwind_protect_cleanup
     warn_empty_list_elements = save_warn_empty_list_elements;
   end_unwind_protect
 
 endfunction
diff --git a/scripts/control/system/sysconnect.m b/scripts/control/system/sysconnect.m
--- a/scripts/control/system/sysconnect.m
+++ b/scripts/control/system/sysconnect.m
@@ -262,22 +262,23 @@ function sys = sysconnect (sys, output_l
   Bc = Bc(:,back_inputs);
   Cc = Cc(back_outputs,:);
   Dc = Dc(back_outputs,back_inputs);
   yd = yd(back_outputs);
 
   ## rebuild system
   Ts = sysgettsam(sys);
   [stnam,innam,outnam] = sysgetsignals(sys);
-  sys = ss2sys(Ac,Bc,Cc,Dc,Ts,nc,nz,stnam,innam,outnam,find(yd));
+  sys = ss(Ac,Bc,Cc,Dc,Ts,nc,nz,stnam,innam,outnam,find(yd));
 
   ## update connected input names
   for ii = 1:length(input_list)
     idx = input_list(ii);
-    strval = sprintf("%s*",nth(sysgetsignals(sys,"in",idx),1) );
+    tmpval = sysgetsignals(sys,"in",idx);
+    strval = sprintf("%s*",tmpval{1} );
     sys = syssetsignals(sys,"in",strval,idx);
   endfor
 
   ## maintain original system type if it was SISO
   if (strcmp (sysgettype (sys), "tf"))
     sysupdate (sys, "tf");
   elseif (strcmp (sysgettype (sys),"zp"))
     sysupdate (sys, "zp");
diff --git a/scripts/control/system/syscont.m b/scripts/control/system/syscont.m
--- a/scripts/control/system/syscont.m
+++ b/scripts/control/system/syscont.m
@@ -77,15 +77,15 @@ function [csys, Acd, Ccd] = syscont (sys
     else
       stname=[];
     endif
     outname = sys_outname(y_c);
     Dcc = sys_d(y_c,:);
     Ccd = sys_c(y_c,st_d);
     inname = sys_inname;
 
-    csys = ss2sys(Acc,Bcc,Ccc,Dcc,0,sys_n,0,stname,inname,outname);
+    csys = ss(Acc,Bcc,Ccc,Dcc,0,sys_n,0,stname,inname,outname);
 
   unwind_protect_cleanup
     warn_empty_list_elements = save_warn_empty_list_elements;
   end_unwind_protect
 
 endfunction
diff --git a/scripts/control/system/sysdimensions.m b/scripts/control/system/sysdimensions.m
--- a/scripts/control/system/sysdimensions.m
+++ b/scripts/control/system/sysdimensions.m
@@ -75,23 +75,23 @@ function [n, nz, m, p, yd] = sysdimensio
     opt = "all";
   endif
 
   n = sys.n;
   nz = sys.nz;
   m = length(sysgetsignals(sys,"in"));
   p = length(sysgetsignals(sys,"out"));
   yd = sys.yd;
-  valid_options = list("all","cst","dst","st","in","out");
-  valid_values = list(n,n,nz,n+nz,m,p);
+  valid_options = {"all","cst","dst","st","in","out"};
+  valid_values = {n,n,nz,n+nz,m,p};
 
   valid_opt = 0;
   for ii=1:length(valid_options)
-    if(strcmp(nth(valid_options,ii),opt))
-      n = nth(valid_values,ii);
+    if(strcmp(valid_options{ii},opt))
+      n = valid_values{ii};
       valid_opt = 1;
       if(ii > 1 & nargout > 1)
         warning("opt=%s, %d output arguments requested",opt,nargout);
       endif
     endif
   endfor
 
   if (! valid_opt)
diff --git a/scripts/control/system/sysdisc.m b/scripts/control/system/sysdisc.m
--- a/scripts/control/system/sysdisc.m
+++ b/scripts/control/system/sysdisc.m
@@ -84,17 +84,17 @@ function [dsys, Adc, Cdc] = sysdisc (sys
       outname=[];
     endif
     inname = sysgetsignals(sys,"in");
     outlist = 1:rows(outname);
 
     if(!isempty(outname))
       tsam = sysgettsam(sys);
       [nc,nz] = sysdimensions(sys);
-      dsys = ss2sys(Add,Bdd,Cdd,Ddd,tsam,0,nz,stname,inname,outname,outlist);
+      dsys = ss(Add,Bdd,Cdd,Ddd,tsam,0,nz,stname,inname,outname,outlist);
     else
       dsys=[];
     endif
 
   unwind_protect_cleanup
     warn_empty_list_elements = save_warn_empty_list_elements;
   end_unwind_protect
 
diff --git a/scripts/control/system/sysdup.m b/scripts/control/system/sysdup.m
--- a/scripts/control/system/sysdup.m
+++ b/scripts/control/system/sysdup.m
@@ -57,17 +57,17 @@
 
 function retsys = sysdup (Asys, output_list, input_list)
 
   if( nargin != 3)
     usage("retsys = sysdup(Asys,output_list,input_list)");
   endif
 
   if( !isstruct(Asys))
-    error("Asys must be a system data structure (see ss2sys, tf2sys, or zp2sys)")
+    error("Asys must be a system data structure (see ss, tf, or zp)")
   endif
 
   Asys = sysupdate(Asys,"ss");
   [nn,nz,mm,pp] = sysdimensions(Asys);
   [aa,bb,cc,dd] = sys2ss(Asys);
 
   ## check for signal names
   if(is_signal_list(input_list) | isstr(input_list))
@@ -98,17 +98,17 @@ function retsys = sysdup (Asys, output_l
   elseif(osize != 0)
     error("output_list must be a vector or empty");
   endif
 
   [stnam,innam,outnam,yd] = sysgetsignals(Asys);
   tsam = sysgettsam(Asys);
 
   ## pack system and then rename signals
-  retsys = ss2sys(aa,bb,cc,dd,tsam,nn,nz);
+  retsys = ss(aa,bb,cc,dd,tsam,nn,nz);
   retsys = syssetsignals(retsys,"in",innam,1:mm);
   retsys = syssetsignals(retsys,"out",outnam,1:pp);
   retsys = syssetsignals(retsys,"yd",yd,1:pp);
 
   ## update added input names
   for ii=(mm+1):(mm+length(input_list))
     onum = input_list(ii-mm);
     strval = sprintf("%s(dup)",sysgetsignals(retsys,"in",onum,1) );
diff --git a/scripts/control/system/sysgetsignals.m b/scripts/control/system/sysgetsignals.m
--- a/scripts/control/system/sysgetsignals.m
+++ b/scripts/control/system/sysgetsignals.m
@@ -39,71 +39,71 @@
 ## @item "yd"
 ## value of logical vector @var{yd}
 ## @end table
 ##
 ## @item signum
 ## index(indices) or name(s) or signals; see @code{sysidx}
 ##
 ## @item strflg
-## flag to return a string instead of a list;  Values:
+## flag to return a string instead of a cell array;  Values:
 ## @table @code
 ## @item 0
-## (default) return a list (even if signum specifies an individual signal)
+## (default) return a cell array (even if signum specifies an individual signal)
 ##
 ## @item 1
 ## return a string.  Exits with an error if signum does not specify an 
 ## individual signal.
 ## @end table
 ##
 ## @end table
 ##
 ## @strong{Outputs}
 ## @table @bullet
 ## @item If @var{sigid} is not specified
 ## @table @var
 ## @item stname
 ## @itemx inname
 ## @itemx outname
-## signal names (lists of strings);  names of states,
+## signal names (cell array of strings);  names of states,
 ## inputs, and outputs, respectively
 ## @item yd
 ## binary vector; @var{yd}(@var{ii}) is nonzero if output @var{ii} is
 ## discrete.
 ## @end table
 ##
 ## @item If @var{sigid} is specified but @var{signum} is not specified, then
 ## @table @code
 ## @item sigid="in"
-## @var{siglist} is set to the list of input names
+## @var{siglist} is set to the cell array of input names
 ##
 ## @item sigid="out"
-## @var{siglist} is set to the list of output names
+## @var{siglist} is set to the cell array of output names
 ##
 ## @item sigid="st"
-## @var{siglist} is set to the list of state names
+## @var{siglist} is set to the cell array of state names
 ##
 ## stage signals
 ## @item sigid="yd"
 ## @var{siglist} is set to logical vector indicating discrete outputs;
 ## @var{siglist}(@var{ii}) = 0 indicates that output @var{ii} is continuous
 ## (unsampled), otherwise it is discrete.
 ##
 ## @end table
 ##
 ## @item if the first three input arguments are specified, then @var{signame} is
-## a list of the specified signal names (@var{sigid} is @code{"in"},
+## a cell array of the specified signal names (@var{sigid} is @code{"in"},
 ## @code{"out"}, or @code{"st"}), or else the logical flag
 ## indicating whether output(s) @var{signum} is(are) discrete (@var{sigval}=1)
 ## or continuous (@var{sigval}=0).
 ## @end table
 ##
 ## @strong{Examples} (From @code{sysrepdemo})
 ## @example
-## octave> sys=ss2sys(rand(4),rand(4,2),rand(3,4));
+## octave> sys=ss(rand(4),rand(4,2),rand(3,4));
 ## octave> [Ast,Ain,Aout,Ayd] = sysgetsignals(sys) i  # get all signal names
 ## Ast =
 ## (
 ##   [1] = x_1
 ##   [2] = x_2
 ##   [3] = x_3
 ##   [4] = x_4
 ## )
@@ -122,29 +122,29 @@
 ##
 ##   0  0  0
 ## octave> Ain = sysgetsignals(sys,"in")   # get only input signal names
 ## Ain =
 ## (
 ##   [1] = u_1
 ##   [2] = u_2
 ## )
-## octave> Aout = sysgetsignals(sys,"out",2)   # get name of output 2 (in list)
+## octave> Aout = sysgetsignals(sys,"out",2)   # get name of output 2 (in cell array)
 ## Aout =
 ## (
 ##   [1] = y_2
 ## )
 ## octave> Aout = sysgetsignals(sys,"out",2,1)  # get name of output 2 (as string)
 ## Aout = y_2
 ## @end example
 ## @end deftypefn
 
 function [stname, inname, outname, yd] = sysgetsignals (sys, sigid, signum, strflg)
 
-  ## Adapted from ss2sys
+  ## Adapted from ss
 
   if(nargin < 1 | nargin > 4 | nargout > 4)
     usage("[stname{,inname,outname,yd}] = sysgetsignals(sys{,sigid,signum})")
   elseif(nargin > 1 & nargout > 1)
     usage("sig = sysgetsignals(sys,sigid{,signum,strflg})")
   elseif( ! isstruct(sys) )
     error("input argument must be a system data structure");
   endif
@@ -163,33 +163,33 @@ function [stname, inname, outname, yd] =
     elseif(strcmp("out",sigid))    stname = sys.outname;
     elseif(strcmp("yd",sigid))     stname = vec(sys.yd)';
     else
       error(sprintf("sigid=%s must be \"st\", \"in\", \"out\", or \"yd\"", ...
         sigid));
     endif
     if(nargin >= 3)
       if( is_signal_list(signum) | isstr(signum) )
-        signum = listidx(stname,signum);
+        signum = cellidx(stname,signum);
       end
       if(max(signum) > length(stname))
         error(sprintf("sysgetsignals(sys,\"%s\",%d):only %d entries.\n", ...
           sigid,signum, rows(stname)));
       else
         if(!isscalar(strflg))
           error("strflg must be a scalar");
         endif
         switch(strflg)
         case(0),
           stname = stname(signum);
         case(1),
           if(length(signum) > 1)
             error("strflg=1, length(signum) = %d",length(signum));
           endif
-          stname = nth(stname,signum);
+          stname = stname{signum};
         otherwise,
           error ("invalid value of strflg = %e", strflg);
         endswitch
 
       endif
     endif
   endif
 
diff --git a/scripts/control/system/sysgettype.m b/scripts/control/system/sysgettype.m
--- a/scripts/control/system/sysgettype.m
+++ b/scripts/control/system/sysgettype.m
@@ -32,12 +32,12 @@
 ## @end deftypefn
 
 function systype = sysgettype (sys)
 
   if (! isstruct (sys))
     error ("sysgettype: input sys is not a structure");
   endif
 
-  typestr = list ("tf", "zp", "ss");
-  systype = nth (typestr, sys.sys(1) + 1);
+  typestr = {"tf", "zp", "ss"};
+  systype = typestr{ sys.sys(1) + 1};
 
 endfunction
diff --git a/scripts/control/system/sysgroup.m b/scripts/control/system/sysgroup.m
--- a/scripts/control/system/sysgroup.m
+++ b/scripts/control/system/sysgroup.m
@@ -56,28 +56,28 @@ function sys = sysgroup (varargin)
   unwind_protect
     warn_empty_list_elements = 0;
 
     if(nargin < 1)
       usage("sys = sysgroup(Asys{,Bsys,...})");
     endif
 
     ## collect all arguments
-    arglist = list();
+    arglist = {};
     for kk=1:nargin
       arglist(kk) = varargin{kk};
-      if(!isstruct(nth(arglist,kk)))
+      if(!isstruct(arglist{kk}))
 	error("sysgroup: argument %d is not a data structure",kk);
       endif
     endfor
 
     if(nargin == 2)
       ## the usual case; group the two systems together
-      Asys = nth(arglist,1);
-      Bsys = nth(arglist,2);
+      Asys = arglist{1};
+      Bsys = arglist{2};
 
       ## extract information from Asys, Bsys to consruct sys
       Asys = sysupdate(Asys,"ss");
       Bsys = sysupdate(Bsys,"ss");
       [n1,nz1,m1,p1] = sysdimensions(Asys);
       [n2,nz2,m2,p2] = sysdimensions(Bsys);
       [Aa,Ab,Ac,Ad,Atsam,An,Anz,Ast,Ain,Aout,Ayd] = sys2ss(Asys);
       [Ba,Bb,Bc,Bd,Btsam,Bn,Bnz,Bst,Bin,Bout,Byd] = sys2ss(Bsys);
@@ -89,32 +89,76 @@ function sys = sysgroup (varargin)
 
       elseif((Atsam + Btsam > 0) & (Atsam * Btsam == 0) )
 	warning("sysgroup: creating combination of continuous and discrete systems")
 
       elseif(Atsam != Btsam)
 	error("sysgroup: Asys.tsam=%e, Bsys.tsam =%e", Atsam, Btsam);
       endif
 
-      A = [Aa,zeros(nA,nB); zeros(nB,nA),Ba];
-      B = [Ab,zeros(nA,m2); zeros(nB,m1),Bb];
-      C = [Ac,zeros(p1,nB); zeros(p2,nA),Bc];
-      D = [Ad,zeros(p1,m2); zeros(p2,m1),Bd];
+      if(nA*nB > 0)
+        A12 = zeros(nA,nB);
+      else
+        A12 = [];
+      endif
+      A = [Aa,A12; A12', Ba];
+ 
+      if(nA*m2 > 0)
+        B12 = zeros(nA,m2);
+      else
+        B12 = [];
+      endif
+      if(nB*m1 > 0)
+        B21 = zeros(nB,m1);
+      else
+        B21 = [];
+      endif
+      if(isempty(Ab))
+        Ab = [];
+      endif
+      if(isempty(Bb))
+        Bb = [];
+      endif
+      B = [Ab, B12; B21, Bb];
+ 
+      if(p1*nB > 0)
+        C12 = zeros(p1,nB);
+      else
+        C12 = [];
+      endif
+      if(p2*nA > 0)
+        C21 = zeros(p2,nA);
+      else
+        C21 = [];
+      endif
+      C = [Ac, C12; C21,Bc];
+ 
+      if(p1*m2 > 0)
+        D12 = zeros(p1,m2);
+      else
+        D12 = [];
+      endif
+      if(p2*m1 > 0)
+        D21 = zeros(p2,m1);
+      else
+        D21 = [];
+      endif
+      D = [Ad, D12; D21, Bd];
       tsam = max(Atsam,Btsam);
 
       ## construct combined signal names; stnames must check for pure gain blocks
       if(isempty(Ast))
 	stname = Bst;
       elseif(isempty(Bst))
 	stname = Ast;
       else
-	stname  = append(Ast, Bst);
+        stname= __sysconcat__(Ast,Bst);
       endif
-      inname  = append(Ain, Bin);
-      outname = append(Aout,Bout);
+      inname = __sysconcat__(Ain,Bin);
+      outname = __sysconcat__(Aout,Bout);
 
       ## Sort states into continous first, then discrete
       dstates = ones(1,(nA+nB));
       if(An)
 	dstates(1:(An)) = zeros(1,An);
       endif
       if(Bn)
 	dstates((nA+1):(nA+Bn)) = zeros(1,Bn);
@@ -129,24 +173,24 @@ function sys = sysgroup (varargin)
       inname = __sysgroupn__ (inname, "input");
       stname = __sysgroupn__ (stname, "state");
       outname = __sysgroupn__ (outname, "output");
 
       ## mark discrete outputs
       outlist = find([Ayd, Byd]);
 
       ## build new system
-      sys = ss2sys(A,B,C,D,tsam,An+Bn,Anz+Bnz,stname,inname,outname);
+      sys = ss(A,B,C,D,tsam,An+Bn,Anz+Bnz,stname,inname,outname);
 
     else
       ## multiple systems (or a single system); combine together one by one
-      sys = nth(arglist,1);
+      sys = arglist{1};
       for kk=2:length(arglist)
 	printf("sysgroup: kk=%d\n",kk);
-	sys = sysgroup(sys,nth(arglist,kk));
+	sys = sysgroup(sys,arglist{kk});
       endfor
     endif
 
   unwind_protect_cleanup
     warn_empty_list_elements = save_warn_empty_list_elements;
   end_unwind_protect
 
 endfunction
diff --git a/scripts/control/system/sysmin.m b/scripts/control/system/sysmin.m
--- a/scripts/control/system/sysmin.m
+++ b/scripts/control/system/sysmin.m
@@ -59,19 +59,19 @@ function [retsys, nc, no, cflg, oflg] = 
     Ad  = aa(drng,drng);
     Bc  = bb(crng,:);
     Bd  = bb(drng,:);
     Cc  = cc(:,crng);
     Cd  = cc(:,drng);
 
     cstnam = stnam(crng);
     dstnam = stnam(drng);
-    cinnam = append(innam,stnam(drng));
-    coutnam = append(outnam,stnam(drng));
-    csys = ss2sys(Ac,[Bc,Acd],[Cc;Adc]);
+    cinnam = __sysconcat__(innam,stnam(drng));
+    coutnam = __sysconcat__(outnam,stnam(drng));
+    csys = ss(Ac,[Bc,Acd],[Cc;Adc]);
     csys = syssetsignals(csys,"st",cstnam);
     csys = syssetsignals(csys,"in",cinnam);
     csys = syssetsignals(csys,"out",coutnam);
 
     # reduce continuous system, recombine with discrete part
     csys = sysmin(csys,flg);
     cn = sysdimensions(csys);
 
@@ -85,19 +85,19 @@ function [retsys, nc, no, cflg, oflg] = 
       crng = 1:cn;
       Ac  = caa;
       Bc  = cbb(:,1:m);
       Acd = cbb(:,m+(1:nz));
       Cc  = ccc(1:p,:);
       Adc = ccc(p + (1:nz),:);
 
       # recombine to reduce discrete part of the system
-      dinnam = append(innam,cstnam);
-      doutnam = append(outnam,cstnam);
-      dsys = ss2sys(Ad,[Bd,Adc],[Cd;Acd],[],tsam);
+      dinnam = __sysconcat__(innam,cstnam);
+      doutnam = __sysconcat__(outnam,cstnam);
+      dsys = ss(Ad,[Bd,Adc],[Cd;Acd],[],tsam);
       dsys = syssetsignals(dsys,"st",dstnam);
       dsys = syssetsignals(dsys,"in",dinnam);
       dsys = syssetsignals(dsys,"out",doutnam);
 
       # reduce discrete subsystem
       dsys = sysmin(dsys);
       [n1,nz] = sysdimensions(dsys);
       if(nz == 0)
@@ -106,21 +106,21 @@ function [retsys, nc, no, cflg, oflg] = 
       else
         # combine discrete, continuous subsystems
         [Ad,dbb,dcc] = sys2ss(dsys);
         dstnam = sysgetsignals(dsys,"st");
         Bd  = dbb(:,1:m);
         Adc = dbb(:,m+(1:cn));
         Cd  = dcc(1:p,:);
         Acd = dcc(p+(1:cn),:);
-        stnam = append(cstnam,dstnam);
+        stnam = __sysconcat__(cstnam,dstnam);
         aa = [Ac, Acd; Adc, Ad];
         bb = [Bc; Bd];
         cc = [Cc, Cd];
-        retsys = ss2sys([Ac, Acd; Adc, Ad], [Bc ; Bd], [Cc, Cd], dd, tsam, ...
+        retsys = ss([Ac, Acd; Adc, Ad], [Bc ; Bd], [Cc, Cd], dd, tsam, ...
           cn, nz, stnam, innam, outnam, find(yd == 1));
       end
     endif
   else
     Ts = sysgettsam(sys);
     switch(flg)
     case(0),
       ## reduce to a minimal system
@@ -153,17 +153,17 @@ function [retsys, nc, no, cflg, oflg] = 
         nc = no = nn = columns(aa);
         nz = 0;
       case(1),
         nc = no = nz = columns(aa);
         nn = 0;
       endswitch
       innam = sysgetsignals(sys,"in");
       outnam= sysgetsignals(sys,"out");
-      retsys = ss2sys(aa,bb,cc,dd,Ts,nn,nz,[],innam,outnam);
+      retsys = ss(aa,bb,cc,dd,Ts,nn,nz,[],innam,outnam);
     case(1),
       ## reduced model with physical states
       [cflg,Uc] = is_controllable(sys); xc = find(max(abs(Uc')) != 0);
       [oflg,Uo] = is_observable(sys);   xo = find(max(abs(Uo')) != 0);
       xx = intersection(xc,xo);
       if(isempty(xx)) xx = 0;  endif    # signal no states in reduced model
       retsys = sysprune(sys,[],[],xx);
     otherwise,
diff --git a/scripts/control/system/sysmult.m b/scripts/control/system/sysmult.m
--- a/scripts/control/system/sysmult.m
+++ b/scripts/control/system/sysmult.m
@@ -38,37 +38,38 @@
 
 function sys = sysmult (varargin)
 
   if(nargin < 1)
     usage("sysmult: sys = sysmult(Asys{,Bsys,...})");
   endif
 
   ## collect all arguments
-  arglist = list();
+  arglist = {};
   for kk=1:nargin
-    arglist(kk) = varargin{kk};
-    if(!isstruct(nth(arglist,kk)))
+    arglist{kk} = varargin{kk};
+    if(!isstruct(arglist{kk}))
       error("sysadd: argument %d is not a data structure",kk);
     endif
   endfor
 
   ## check system dimensions
-  [n,nz,mg,pg,Gyd] = sysdimensions(nth(arglist,1));
+  [n,nz,mg,pg,Gyd] = sysdimensions(arglist{1});
   for kk=2:nargin
-    [n,nz,mh,ph,Hyd] = sysdimensions(nth(arglist,kk));
+    [n,nz,mh,ph,Hyd] = sysdimensions(arglist{kk});
     if(ph != mg)
       error("arg %d has %d outputs; arg %d has %d inputs",kk,ph,kk-1,mg);
     endif
-    [n,nz,mg,pg,Gyd] = sysdimensions(nth(arglist,kk));   # for next iteration
+    [n,nz,mg,pg,Gyd] = sysdimensions(arglist{kk});   # for next iteration
   endfor
 
   ## perform the multiply
   if(nargin == 2)
-    Asys = nth(arglist,1);   Bsys = nth(arglist,2);
+    Asys = arglist{1};
+    Bsys = arglist{2};
 
     [An,Anz,Am,Ap] = sysdimensions(Asys);
     [Bn,Bnz,Bm,Bp] = sysdimensions(Bsys);
 
     [Aa,Ab,Ac,Ad,Atsam,An,Anz,Astname,Ainname,Aoutname,Ayd] = sys2ss(Asys);
     [Ba,Bb,Bc,Bd,Btsam,Bn,Bnz,Bstname,Binname,Boutname,Byd] = sys2ss(Bsys);
 
     if(Byd)
@@ -98,16 +99,16 @@ function sys = sysmult (varargin)
     ## connect outputs of B to inputs of A
     sys = sysconnect(sys,Ap+(1:Bp),1:Am);
 
     ## now keep only  outputs of A and inputs of B
     sys = sysprune(sys,1:Ap,Am+(1:Bm));
 
   else
     ## multiple systems (or a single system); combine together one by one
-    sys = nth(arglist,1);
+    sys = arglist{1};
     for kk=2:length(arglist)
-      sys = sysmult(sys,nth(arglist,kk));
+      sys = sysmult(sys,arglist{kk});
     endfor
   endif
 
 endfunction
 
diff --git a/scripts/control/system/sysprune.m b/scripts/control/system/sysprune.m
--- a/scripts/control/system/sysprune.m
+++ b/scripts/control/system/sysprune.m
@@ -113,17 +113,17 @@ function sys = sysprune (sys, output_idx
     endif
   endif
 
   lo = length(output_idx);
   li = length(input_idx);
   lst = length(state_idx);
 
   if( !isstruct(sys))
-    error("Asys must be a system data structure (see ss2sys, tf2sys, or zp2sys)")
+    error("Asys must be a system data structure (see ss, tf, or zp)")
   elseif(pp < lo)
     error([num2str(lo)," output_idx entries, system has only ", ...
         num2str(pp)," outputs"]);
   elseif(mm < li)
     error([num2str(li)," input_idx entries, system has only ", ...
         num2str(mm)," inputs"]);
   elseif(nn+nz < lst)
     error([num2str(lst)," state_idx entries, system has only ", ...
@@ -142,17 +142,17 @@ function sys = sysprune (sys, output_idx
     else                min_d = nn+nz;            endif
     if(max_c > min_d)
       warning("sysprune: state_idx(%d)=%d (discrete) preceeds", ...
         min_d,state_idx(min_d));
       warning("          state_idx(%d)=%d (continuous)",...
         max_c,state_idx(max_c));
       warning("sysprune: sys has %d continuous states, %d discrete states", ...
         nn,nz);
-      error("continuous/discrete state partition not preserved ; see ss2sys");
+      error("continuous/discrete state partition not preserved ; see ss");
     endif
   endif
 
   idx = input_idx;
   odx = output_idx;
   if(isempty(state_idx))
     idx = [];
     odx = [];
@@ -163,10 +163,10 @@ function sys = sysprune (sys, output_idx
   dd = dd(output_idx,input_idx);
   yd = yd(output_idx);
 
   innam  = innam(input_idx);
   outnam = outnam(output_idx);
   stnam = stnam(state_idx);
   nn1 = length(find(state_idx <= nn));
   nz1 = length(find(state_idx > nn));
-  sys = ss2sys(aa,bb,cc,dd,tsam,nn1,nz1,stnam,innam,outnam,find(yd));
+  sys = ss(aa,bb,cc,dd,tsam,nn1,nz1,stnam,innam,outnam,find(yd));
 endfunction
diff --git a/scripts/control/system/sysrepdemo.m b/scripts/control/system/sysrepdemo.m
--- a/scripts/control/system/sysrepdemo.m
+++ b/scripts/control/system/sysrepdemo.m
@@ -40,17 +40,17 @@ function sysrepdemo ()
   ch_update = ch_extract+1;
   ch_view = ch_update+1;
   ch_details = ch_view+1;
   ch_quit = ch_details+1;
   while(syschoice != ch_quit)
    disp(" ")
     syschoice = menu("Octave System Representation Menu", ...
       "General overview of system representation (DO THIS FIRST)", ...
-      "Initialize a system (ss2sys, tf2sys, zp2sys)", ...
+      "Initialize a system (ss, tf, zp)", ...
       "Extract data from a system(sys2ss, sys2tf, sys2zp, etc.)", ...
       "Update internal representation (sysupdate)", ...
       "View the internal contents of a system (sysout)", ...
       "Details of internal representation", ...
       "Return to main menu");
     if(syschoice == 1)  # general overview
       disp("The Octave Control Systems Toolbox (OCST) was designed to")
       disp("provide a simple user interface to a powerful set of tools.")
@@ -74,20 +74,20 @@ function sysrepdemo ()
       disp("likelihood of user error is greatly reduced when calling OCST")
       disp("functions.  Further, all OCST functions have been written to")
       disp("provide meaningful warning or error message to assist the user")
       disp("in correcting their programming errors while using the OCST.")
       disp("The details of the internal representation can be seen in ");
       disp(["menu option ",num2str(ch_details)]);
       disp("The data structure used in the OCST is called a \"system data structure.\"");
       disp("A system data structure is contstructed with one of:")
-      disp("   fir2sys (FIR transfer function to system)")
-      disp("   ss2sys (state space matrices to system)")
-      disp("   tf2sys (SISO transfer function to system)")
-      disp("   zp2sys (SISO zero/pole/leading coefficient to system)")
+      disp("   fir (FIR transfer function to system)")
+      disp("   ss (state space matrices to system)")
+      disp("   tf (SISO transfer function to system)")
+      disp("   zp (SISO zero/pole/leading coefficient to system)")
       disp(" ")
       disp(["These functions are discussed in in menu option ",num2str(ch_init)])
       disp("The data in a system may be extracted using ")
       disp("   sys2fir (FIR transfer function from system")
       disp("   sys2ss (state space matrices from system)")
       disp("   sys2tf (SISO transfer function from system)")
       disp("   sys2zp (SISO zero/pole/leading coefficient from system)")
       disp(" ")
@@ -101,19 +101,19 @@ function sysrepdemo ()
       disp("OCST package will be quite easy to use.")
     elseif(syschoice == ch_init) % Initialize
       disp("Initialization of a system:");
       disp(" ");
       formopt = 0;
       while(formopt != 4)
       disp("Three data formats may be used to initialize a system:")
         formopt = menu("System data structure initialization menu", ...
-                "State space form       (ss2sys)", ...
-                "Transfer function form (tf2sys)", ...
-                "zero-pole form         (zp2sys)", ...
+                "State space form       (ss)", ...
+                "Transfer function form (tf)", ...
+                "zero-pole form         (zp)", ...
                 "Return to System representation menu");
         if(formopt == 1)
           disp("State space representation of a system is based on the usual")
           disp("multi-variable differential equations")
           disp(" ")
           disp("  . ")
           disp("  x = A x + B u      -or -   x(k+1) = A x(k) + B u(k) ")
           disp("  y = C x + D u                y(k) = C x(k) + D u(k) ")
@@ -122,29 +122,29 @@ function sysrepdemo ()
           disp(" ")
           ssopt = 0;
           ssquit = 5;
           while(ssopt < ssquit)
             ssopt = menu("State space initialization examples", ...
                 "Double integrator example", ...
                 "Double delay (discrete-time) example", ...
                 "Summing junction (D-matrix only) example", ...
-                "ss2sys details (help ss2sys)", ...
+                "ss details (help ss)", ...
                 "return to system initialization menu", ...
                 "return to system representation main menu");
             if(ssopt == 1)
               disp("Example: construct a system representation of a")
               disp("double integrator via state-space form")
               cmd = "a = [0, 1; 0, 0];";
               run_cmd
               cmd = "b = [0; 1];";
               run_cmd
               cmd = "c = [1, 0];";
               run_cmd
-              cmd = "sys = ss2sys(a,b,c);";
+              cmd = "sys = ss(a,b,c);";
               run_cmd
               disp("The state space form of the system is seen via sysout:")
               cmd = "sysout(sys)";
               run_cmd
               disp("Notice that the Octave controls  toolbox automatically")
               disp("assigns names to the states, inputs and outputs,")
               disp("and that the D matrix was filled in automatically.")
               disp("We verify that it's a double integrator via sysout:")
@@ -157,17 +157,17 @@ function sysrepdemo ()
               disp("except that it is a discrete-time system, and so has")
               disp("a sampling interval.  We arbitrarily select T=1e-3.");
               cmd = "a = [0, 1; 0, 0];";
               run_cmd
               cmd = "b = [0; 1];";
               run_cmd
               cmd = "c = [1, 0];";
               run_cmd
-              cmd = "sys=ss2sys(a,b,c,[],1e-3);";
+              cmd = "sys=ss(a,b,c,[],1e-3);";
               run_cmd
               cmd = "sysout(sys)";
               run_cmd
               disp("Notice that the D matrix was filled in automatically.")
               disp("This is done if D is input as the empty matrix.")
               disp(" ")
               disp("Notice also that the output y_1 is labelled as a discrete")
               disp("output.  The OCST data structure keeps track of states")
@@ -194,39 +194,39 @@ function sysrepdemo ()
               disp("if this convention is violated.")
               prompt
             elseif(ssopt == 3)
               disp("A summing junction that computes e(t) = r(t) - y(t) may be");
               disp("constructed as follows:");
               disp("First, we set the matrix D:")
               cmd = "D = [1, -1];";
               run_cmd
-              disp("ss2sys allows the initialization of signal and state names")
+              disp("ss allows the initialization of signal and state names")
               disp("(see option 4), so we initialize these as follows:")
-              cmd = "inname = list(\"r(t)\",\"y(t)\");";
+              cmd = "inname = {\"r(t)\",\"y(t)\"};";
               run_cmd;
               cmd = "outname = \"e(t)\";";
               run_cmd
               disp("Since the system is continous time and without states,")
-              disp("the ss2sys inputs tsam, n, and nz are all zero:")
-              cmd = "sys = ss2sys([],[],[],D,0,0,0,[],inname,outname);";
+              disp("the ss inputs tsam, n, and nz are all zero:")
+              cmd = "sys = ss([],[],[],D,0,0,0,[],inname,outname);";
               run_cmd
               disp("The resulting system is:")
               cmd = "sysout(sys)";
               run_cmd
               disp("A discrete-time summing block can be implemented by setting")
               disp("the sampling time positive:")
-              cmd = "sys = ss2sys([],[],[],D,1e-3,0,0,[],inname,outname);";
+              cmd = "sys = ss([],[],[],D,1e-3,0,0,[],inname,outname);";
               run_cmd
               disp("The resulting system is:")
               cmd = "sysout(sys)";
               run_cmd
               prompt
             elseif(ssopt == 4)
-              help ss2sys
+              help ss
               disp(" ")
               disp(" ")
               disp("Notice that state-space form allows a single system to have")
               disp("both continuous and discrete-time states and to have both continuous")
               disp("and discrete-time outputs.  Since it's fairly easy to make an")
               disp("error when mixing systems of this form, the Octave controls")
               disp("toolbox attempts to print warning messages whenever something")
               disp("questionable occurs.")
@@ -236,17 +236,17 @@ function sysrepdemo ()
           endwhile
         elseif(formopt == 2)
           tfopt = 0;
           while(tfopt < 5)
             tfopt = menu("Transfer function initialization menu", ...
                 "Continuous time initialization" , ...
                 "Discrete time initialization" , ...
                 "User specified signal names" , ...
-                "tf2sys details (help tf2sys)", ...
+                "tf details (help tf)", ...
                 "Return to system initialization menu", ...
                 "Return to system representation main menu");
             if(tfopt == 1) # continuous time
               disp("A transfer function is represented by vectors of the")
               disp("coefficients of the numerator and denominator polynomials");
               disp(" ")
               disp("For example: the transfer function");
               disp(" ");
@@ -254,77 +254,77 @@ function sysrepdemo ()
               denom = [1, -2, 6];
               tfout(num,denom);
               disp(" ")
               disp("is generated by the following commands:")
               cmd = "num = [5, -1]";
               run_cmd
               cmd = "denom = [1, -2, 6]";
               run_cmd
-              cmd = "sys = tf2sys(num,denom);";
+              cmd = "sys = tf(num,denom);";
               run_cmd
               disp("alternatively, the system can be generated in a single command:");
-              cmd = "sys = tf2sys([5, -1], [1, -2, 6]);";
+              cmd = "sys = tf([5, -1], [1, -2, 6]);";
               run_cmd
               disp("Notice the output of sys: it is an Octave data structure.")
               disp("The details of its member variables are explained under")
               disp("System Representation Menu option 5 (the details of system form)")
               disp(" ");
               disp("The data structure can be observed with the sysout command:")
               cmd = "sysout(sys)";
               run_cmd
               disp("Notice that Octave assigns names to inputs and outputs.")
               disp("The user may manually select input and output names; see option 3");
               prompt
             elseif(tfopt == 2) # discrete time
               disp("A transfer function is represented by vectors of the")
               disp("coefficients of the numerator and denominator polynomials");
               disp("Discrete-time transfer functions require ")
               disp("the additional parameter of a sampling period:")
-              cmd = "sys=tf2sys([5, -1], [1, 2, -6], 1e-3);";
+              cmd = "sys=tf([5, -1], [1, 2, -6], 1e-3);";
               run_cmd
               cmd = "sysout(sys)";
               run_cmd
               disp("The OCST recognizes discrete-time transfer functions and")
               disp("accordingly prints them with the frequency domain variable z.");
               disp("Notice that Octave assigns names to inputs and outputs.")
               disp("The user may set input and output names; see option 3");
             elseif(tfopt == 3) # user specified names
               disp("The OCST requires all signals to have names.  The OCST assigned default");
               disp("names to the signals in the other examples.  We may initialize a transfer");
               disp("function with user-specified names as follows: Consider a simple ")
               disp("double-integrator model of aircraft roll dynamics with ")
               disp("input \"aileron angle\" and output \"theta\".  A ")
               disp("system for this model is generated by the command")
-              cmd = "aircraft=tf2sys(1, [1, 0, 0], 0,\"aileron angle\",\"theta\");";          run_cmd
+              cmd = "aircraft=tf(1, [1, 0, 0], 0,\"aileron angle\",\"theta\");";          run_cmd
               disp("The sampling  time parameter 0 indicates that the system")
               disp("is continuous time.  A positive sampling time indicates a")
               disp("discrete-time system (or sampled data system).")
               cmd = "sysout(aircraft)";
               run_cmd
               disp("Notice that the user-selected signal names are listed.")
               disp("These signal names are used in OCST plots and design functions.");
               disp("(Run the frequency response demo to see an example of the use of ");
               disp("signal names in plots.)")
               prompt
             elseif(tfopt == 4) # help
-              help  tf2sys
+              help  tf
               prompt
             elseif(tfopt == 6) # return to main menu
               formopt = 4;
             endif
           endwhile
         elseif (formopt == 3)
           zpopt = 0;
           while(zpopt < 5)
             zpopt = menu("Zero-pole initialization menu", ...
                 "Continuous time initialization" , ...
                 "Discrete time initialization" , ...
                 "User specified signal names" , ...
-                "zp2sys details (help zp2sys)", ...
+                "zp details (help zp)", ...
                 "Return to system initialization menu", ...
                 "Return to system representation main menu");
             if(zpopt == 1) # continuous time
               disp("A zero-pole form representation of a system includes vectors")
               disp("of the system poles and zeros and a scalar leading coefficient.");
               disp(" ")
               disp("For example: the transfer function");
               disp(" ");
@@ -335,74 +335,74 @@ function sysrepdemo ()
               disp(" ")
               disp("is generated by the following commands:")
               cmd = "num = [5, -1]";
               run_cmd
               cmd = "denom = [1, -2, 6]";
               run_cmd
               cmd = "k = 5";
               run_cmd
-              cmd = "sys = zp2sys(num,denom,k);";
+              cmd = "sys = zp(num,denom,k);";
               run_cmd
               disp("alternatively, the system can be generated in a single command:");
-              cmd = "sys = zp2sys([5, -1],[1, -2, 6],5);";
+              cmd = "sys = zp([5, -1],[1, -2, 6],5);";
               run_cmd
               disp("Notice the output of sys: it is an Octave data structure.")
               disp("The details of its member variables are explained under")
               disp("System Representation Menu option 5 (the details of system form)")
               disp(" ");
               disp("The data structure can be observed with the sysout command:")
               cmd = "sysout(sys)";
               run_cmd
               disp("Notice that Octave assigns names to inputs and outputs.")
               disp("The user may manually select input and output names; see option 3");
               prompt
             elseif(zpopt == 2) # discrete time
               disp("A zero-pole form representation of a system includes vectors")
               disp("of the system poles and zeros and a scalar leading coefficient.");
               disp(" ")
               disp("Discrete-time systems require the additional parameter of a sampling period:")
-              cmd = "sys=zp2sys([5, -1],[1, 2, -6],5,1e-3);";
+              cmd = "sys=zp([5, -1],[1, 2, -6],5,1e-3);";
               run_cmd
               cmd = "sysout(sys)";
               run_cmd
               disp("The OCST recognizes discrete-time transfer functions and")
               disp("accordingly prints them with the frequency domain variable z.");
               disp("Notice that Octave assigns names to inputs and outputs.")
               disp("The user may set input and output names; see option 3");
             elseif(zpopt == 3) # user specified names
               disp("The OCST requires all signals to have names.  The OCST assigned default");
               disp("names to the signals in the other examples.  We may initialize a transfer");
               disp("function with user-specified names as follows: Consider a simple ")
               disp("double-integrator model of aircraft roll dynamics with ")
               disp("input \"aileron angle\" and output \"theta\".  A ")
               disp("system for this model is generated by the command")
-              cmd = "aircraft=zp2sys([],[0, 0],1,0,\"aileron angle\",\"theta\");";            run_cmd
+              cmd = "aircraft=zp([],[0, 0],1,0,\"aileron angle\",\"theta\");";            run_cmd
               disp("The sampling  time parameter 0 indicates that the system")
               disp("is continuous time.  A positive sampling time indicates a")
               disp("discrete-time system (or sampled data system).")
               cmd = "sysout(aircraft)";
               run_cmd
               disp("Notice that the user-selected signal names are listed.")
               disp("These signal names are used in OCST plots and design functions.");
               disp("(Run the frequency response demo to see an example of the use of ");
               disp("signal names in plots.)")
               prompt
             elseif(zpopt == 4) # help
-              help  zp2sys
+              help  zp
               prompt
             elseif(zpopt == 6) # return to main menu
               formopt = 4;
             endif
           endwhile
         endif
       endwhile
     elseif(syschoice == ch_extract)  # extract system information
       disp("Extract information from a system data structure in a selected format:")
-      disp("The actions of operations ss2sys, tf2sys, and zp2sys are reversed by")
+      disp("The actions of operations ss, tf, and zp are reversed by")
       disp("respective functions sys2ss, sys2tf, and sys2zp.  The latter two");
       disp("functions are applicable only to SISO systems.")
       formopt = 0;
       while(formopt != 8)
         formopt = menu("Extract system information", ...
                 "in state space form       (sys2ss)", ...
                 "in transfer function form (sys2tf)", ...
                 "in zero pole form         (sys2zp)", ...
@@ -414,28 +414,28 @@ function sysrepdemo ()
         if(formopt == 1)
           help sys2ss
         elseif(formopt == 2)
           help sys2tf
         elseif(formopt == 3)
           help sys2zp
         elseif(formopt == 4)
           help sysgetsignals
-          cmd="sys=ss2sys(rand(4),rand(4,2),rand(3,4));";
+          cmd="sys=ss(rand(4),rand(4,2),rand(3,4));";
           run_cmd
           printf("Example: All signals names can be extracted by\n");
           cmd = "[Ast,Ain,Aout,Ayd] = sysgetsignals(sys)";
           run_cmd
           printf("Example: Input signal names can be extracted as\n");
           cmd = "Ain = sysgetsignals(sys,\"in\")";
           run_cmd
           printf("Example: The name of output signal 2 can be extracted as\n");
           cmd = "Aout = sysgetsignals(sys,\"out\",2)";
           run_cmd
-          printf("\nNotice that Aout is returned as a list; the signal name\n");
+          printf("\nNotice that Aout is returned as a cell array; the signal name\n");
           printf("itself is obtained by specifying the input parameter strflg\n");
           cmd = "Aout = sysgetsignals(sys,\"out\",2,1)";
           run_cmd
           prompt
           cmd = "help syssetsignals";
           run_cmd
           printf("Example: set input 2 name to \"motor voltage\"\n");
           cmd = "sys = syssetsignals(sys,\"in\",\"motor voltage\",2); sysout(sys)";
@@ -449,17 +449,17 @@ function sysrepdemo ()
         elseif(formopt == 7)
           help sysgettype
         endif
         prompt
       endwhile
     elseif(syschoice== ch_update)
       disp("The OCST system data structure format will store a system in the same format")
       disp("as that with which it was initialized.  For example, consider the following:")
-      cmd = "sys=zp2sys([1, 2],[3, 4, 5],6)";
+      cmd = "sys=zp([1, 2],[3, 4, 5],6)";
       run_cmd
       disp(" ")
       disp("Notice the internal variables in the structure include zer, pol, and k,")
       disp("the required variables for zero-pole form.  We can update the system")
       disp("to include state-space form as follows:")
       cmd = "sys = sysupdate(sys,\"ss\")";
       run_cmd
       disp(" ")
@@ -467,17 +467,17 @@ function sysrepdemo ()
       disp("the default state names stname.  sysupdate is usually used internally in")
       disp("the OCST, but can be used manually if desired.  A full description of")
       disp("sysupdate is as follows:")
       help sysupdate
       prompt
     elseif(syschoice == ch_view)
       disp("The sysout command can be used to view a system in any desired format.")
       disp("For example, consider the system created as follows:")
-      cmd = "aircraft=zp2sys(1,[0, 0],1,0,\"aileron angle\",\"theta\");";             run_cmd
+      cmd = "aircraft=zp(1,[0, 0],1,0,\"aileron angle\",\"theta\");";             run_cmd
       disp("The system may be viewed in its default format (zero-pole) as follows")
       cmd = "sysout(aircraft)";
       run_cmd
       disp(" ")
       disp("The system may be viewed in state-space or transfer function form as well:")
       cmd = "sysout(aircraft,\"ss\")";
       run_cmd
       cmd = "sysout(aircraft,\"tf\")";
diff --git a/scripts/control/system/sysscale.m b/scripts/control/system/sysscale.m
--- a/scripts/control/system/sysscale.m
+++ b/scripts/control/system/sysscale.m
@@ -87,22 +87,22 @@ function sys = sysscale (sys, outscale, 
   else
     sysyd = ones(1,rows(outscale))*( length(outd) > 0);
   endif
 
   ## check for SISO system type
   if strcmp(sysgettype(sys),"tf")
     [num,den,tsam,innam,outnam] = sys2tf(sys);
     num = num*inscale*outscale;
-    sys = tf2sys(num,den,tsam,innam,outnam,find(sysyd));
+    sys = tf(num,den,tsam,innam,outnam,find(sysyd));
     return
   elseif strcmp(sysgettype(sys),"zp")
     [zer,pol,kk,tsam,innam,outnam] = sys2zp(sys);
     kk = kk*inscale*outscale;
-    sys = zp2sys(zer,pol,k,tsam,innam,outnam,find(sysyd));
+    sys = zp(zer,pol,k,tsam,innam,outnam,find(sysyd));
     return
   endif
 
   ## it's a state space system...
 
   [sysa,sysb,sysc,sysd,systsam, ...
     sysn,sysnz,sysstname,sysinname,sysoutname,oldyd] = sys2ss(sys);
 
@@ -128,12 +128,12 @@ function sys = sysscale (sys, outscale, 
       warning("sysscale: inscale not square, inname not specified");
       warning("sysscale:  using default input names");
       inname = __sysdefioname__(columns(sysb),"u");
     endif
   else
     inname = sysgetsignals(sys,"in");
   endif
 
-  sys = ss2sys(sysa,sysb,sysc,sysd,systsam,nn,nz,sysstname, ...
+  sys = ss(sysa,sysb,sysc,sysd,systsam,nn,nz,sysstname, ...
         inname,outname,find(sysyd==1));
 
 endfunction
diff --git a/scripts/control/system/syssetsignals.m b/scripts/control/system/syssetsignals.m
--- a/scripts/control/system/syssetsignals.m
+++ b/scripts/control/system/syssetsignals.m
@@ -46,25 +46,25 @@
 ## @item opt = "yd"
 ## To desired output continuous/discrete flag.
 ## Set name to 0 for continuous, or 1 for discrete.
 ## @end table
 ## @item sig_idx
 ## indices or names of outputs, yd, inputs, or
 ## states whose respective names/values should be changed.
 ##
-## Default: replace entire list of names/entire yd vector.
+## Default: replace entire cell array of names/entire yd vector.
 ## @end table
 ## @strong{Outputs}
 ## @var{retsys=sys} with appropriate signal names changed
 ## (or yd values, where appropriate)
 ##
 ## @strong{Example}
 ## @example
-## octave:1> sys=ss2sys([1 2; 3 4],[5;6],[7 8]);
+## octave:1> sys=ss([1 2; 3 4],[5;6],[7 8]);
 ## octave:2> sys = syssetsignals(sys,"st",str2mat("Posx","Velx"));
 ## octave:3> sysout(sys)
 ## Input(s)
 ##         1: u_1
 ## Output(s):
 ##         1: y_1
 ## state-space form:
 ## 2 continuous states, 0 discrete states
@@ -116,33 +116,35 @@ function retsys = syssetsignals (sys, op
       disp(sig_idx);
       error("sig_idx must be a vector")
     endif
   endif
 
   sig_vals = sysgetsignals(sys,opt);
 
   ## make sure it's in state space form if state names are given
-  if(strcmp(opt,"st"))    sys = sysupdate(sys,"ss");    endif
+  if(strcmp(opt,"st"))
+    sys = sysupdate(sys,"ss");
+  endif
 
   if(strcmp(opt,"yd") == 0)
     ## it's a signal name list we're changing
-    if(!islist(names))
-      names = list(names);
+    if(!iscell(names))
+      names = {names};
     endif
-    if(!is_signal_list(names))
-      if(isstr(nth(names,1)))
-        warning("syssetsignals(opt=%s): converting string matrix \"names\" to a list of strings",opt);
-        tmpstr = nth(names,1);
+    if( (!is_signal_list(names)) & (!isempty(names)) )
+      if(isstr(names{1}))
+        warning("syssetsignals(opt=%s): converting string matrix \"names\" to a cell array of strings",opt);
+        tmpstr = names{1};
         for ii=1:rows(tmpstr)
-          names(ii) = deblank(tmpstr(ii,:));
+          names{ii} = deblank(tmpstr(ii,:));
         endfor
       else
         names
-        error("parameter \"names\" must be a list of strings");
+        error("parameter \"names\" must be a cell array of strings");
       endif
     endif
     nsigs = length(sig_vals);
 
     if(nargin == 3)
       ## replace all signal names
       if(length(names) != nsigs)
         error("opt=%s, sig_idx omitted: names(len=%d) should have %d entries ", ...
@@ -156,17 +158,17 @@ function retsys = syssetsignals (sys, op
     endif
 
     for ii=1:length(sig_idx)
       jj = sig_idx(ii);
       if(jj < 1 | jj > nsigs | jj != floor(jj+0.5))
         error("opt=%s, sig_idx(%d)=%d, %e: must be an integer between 1 and %d", ...
           opt, ii, jj, jj, nsigs);
       endif
-      sig_vals(jj) = nth(names,ii);
+      sig_vals{jj} = names{ii};
     endfor
 
   else
     ## update yd
     ## 1st check pathological case: no outputs
     nout = sysdimensions(sys,"out");
     if(nout == 0)
       if(nargin != 3)
diff --git a/scripts/control/system/syssub.m b/scripts/control/system/syssub.m
--- a/scripts/control/system/syssub.m
+++ b/scripts/control/system/syssub.m
@@ -44,48 +44,49 @@
 
 function sys = syssub (varargin)
 
   if(nargin < 1)
     usage("syssub: sys = syssub(Gsys{,Hsys,...})");
   endif
 
   ## collect all arguments
-  arglist = list();
+  arglist = {};
   for kk=1:nargin
-    arglist(kk) = varargin{kk};
-    if(!isstruct(nth(arglist,kk)))
+    arglist{kk} = varargin{kk};
+    if(!isstruct(arglist{kk}))
       error("syssub: argument %d is not a data structure",kk);
     endif
   endfor
 
   ## check system dimensions
-  [n,nz,mg,pg,Gyd] = sysdimensions(nth(arglist,1));
+  [n,nz,mg,pg,Gyd] = sysdimensions(arglist{1});
   for kk=2:nargin
-    [n,nz,mh,ph,Hyd] = sysdimensions(nth(arglist,kk));
+    [n,nz,mh,ph,Hyd] = sysdimensions(arglist{kk});
     if(mg != mh)
       error("arg 1 has %d inputs; arg %d has vs %d inputs",mg,kk,mh);
     elseif(pg != ph)
       error("arg 1 has %d outputs; arg %d has vs %d outputs",pg,kk,ph);
     elseif(norm(Gyd - Hyd))
       warning("cannot add a discrete output to a continuous output");
       error("Output type mismatch: arguments 1 and %d\n",kk);
     endif
   endfor
 
   ## perform the subtract
   if(nargin == 2)
-    Gsys = nth(arglist,1);   Hsys = nth(arglist,2);
+    Gsys = arglist{1};
+    Hsys = arglist{2};
     if( strcmp(sysgettype(Gsys),"tf") | strcmp(sysgettype(Hsys),"tf") )
       ## see if subtracting  transfer functions with identical denominators
       [Gnum,Gden,GT,Gin,Gout] = sys2tf(Gsys);
       [Hnum,Hden,HT,Hin,Hout] = sys2tf(Hsys);
       if(length(Hden) == length(Gden) )
         if( (Hden == Gden) & (HT == GT) )
-          sys = tf2sys(Gnum-Hnum,Gden,GT,Gin,Gout);
+          sys = tf(Gnum-Hnum,Gden,GT,Gin,Gout);
           return
         endif
         ## if not, we go on and do the usual thing...
       endif
     endif
 
     ## make sure in ss form
     Gsys = sysupdate(Gsys,"ss");
@@ -101,15 +102,15 @@ function sys = syssub (varargin)
 
     eyin = eye(mg);
     eyout = eye(pg);
 
     sys = sysscale (sys, [eyout, -eyout], [eyin; eyin], Gout, Gin);
 
   else
     ## multiple systems (or a single system); combine together one by one
-    sys = nth(arglist,1);
+    sys = arglist{1};
     for kk=2:length(arglist)
-      sys = syssub(sys,nth(arglist,kk));
+      sys = syssub(sys,arglist{kk});
     endfor
   endif
 
 endfunction
diff --git a/scripts/control/system/sysupdate.m b/scripts/control/system/sysupdate.m
--- a/scripts/control/system/sysupdate.m
+++ b/scripts/control/system/sysupdate.m
@@ -40,17 +40,17 @@
 ##
 ## @strong{Outputs}
 ## @var{retsys}: contains union of data in sys and requested data.
 ## If requested data in sys is already up to date then retsys=sys.
 ##
 ## Conversion to @code{tf} or @code{zp} exits with an error if the system is
 ## mixed continuous/digital.
 ## @end deftypefn
-## @seealso{tf2sys, ss2sys, zp2sys, sysout, sys2ss, sys2tf, and sys2zp}
+## @seealso{tf, ss, zp, sysout, sys2ss, sys2tf, and sys2zp}
 
 ## Author: John Ingram <ingraje@eng.auburn.edu>
 ## Created: July 9, 1996
 
 function sys = sysupdate (sys, opt)
 
   ## check for correct number of inputs
   if (nargin != 2)
diff --git a/scripts/control/system/tf2sys.m b/scripts/control/system/tf2sys.m
--- a/scripts/control/system/tf2sys.m
+++ b/scripts/control/system/tf2sys.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996, 1998 Auburn University.  All rights reserved.
+## Copyright (C) 1996, 1998, 2004 Auburn University.  All rights reserved.
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by the
 ## Free Software Foundation; either version 2, or (at your option) any
 ## later version.
 ##
@@ -24,17 +24,17 @@
 ## @table @var
 ## @item  num
 ## @itemx den
 ## coefficients of numerator/denominator polynomials
 ## @item tsam
 ## sampling interval. default: 0 (continuous time)
 ## @item inname
 ## @itemx outname
-## input/output signal names; may be a string or list with a single string
+## input/output signal names; may be a string or cell array with a single string
 ## entry.
 ## @end table
 ##
 ## @strong{Outputs}
 ## @var{sys} = system data structure
 ##
 ## @strong{Example}
 ## @example
@@ -51,93 +51,16 @@
 ## 1*z^2 + 2*z^1 + 1
 ## @end example
 ## @end deftypefn
 
 ## Author: R. Bruce Tenison <btenison@eng.auburn.edu>
 ## Created: July 29, 1994
 ## Name changed to TF2SYS July 1995
 ## updated for new system data structure format July 1996
-
-function outsys = tf2sys (num, den, tsam, inname, outname)
-
-  ## Test for the correct number of input arguments
-  if ((nargin < 2) || (nargin > 5))
-    usage ("outsys = tf2sys (num, den [, tsam, inname, outname])");
-    return
-  endif
-
-  ## check input format
-  if( ! ( (isvector(num) || isscalar(num)) && ...
-        (isvector(den) || isscalar(den))) )
-    error(["num (",num2str(rows(num)),"x",num2str(columns(num)), ...
-      ") and den (",num2str(rows(den)),"x",num2str(columns(den)), ...
-      ") must be vectors"])
-  endif
-
-  ## strip leading zero coefficients
-  num = __tf2sysl__ (num);
-  den = __tf2sysl__ (den);
-
-  if (length(num) >  length(den))
-    error("# of poles (%d) < # of zeros (%d)",length(den)-1, length(num)-1);
-  endif
-
-  ## check sampling interval (if any)
-  if(nargin <= 2)           tsam = 0;           # default
-  elseif (isempty(tsam))    tsam = 0;           endif
-  if ( (! (isscalar(tsam) && (imag(tsam) == 0) )) || (tsam < 0) )
-    error("tsam must be a positive real scalar")
-  endif
-
-  outsys.num = num;
-  outsys.den = den;
-
-  ## Set the system vector:  active = 0(tf), updated = [1 0 0];
-  outsys.sys = [0, 1, 0, 0];
+## name changed to tf Feb 2004
 
-  ## Set defaults
-  outsys.tsam = tsam;
-  outsys.n = length(den)-1;
-  outsys.nz = 0;
-  outsys.yd = 0;        # assume discrete-time
-  ## check discrete time
-  if(tsam > 0)
-    [outsys.n,outsys.nz] = swap(outsys.n, outsys.nz);
-    outsys.yd = 1;
-  endif
-
-  outsys.inname  = __sysdefioname__ (1, "u");
-  outsys.outname = __sysdefioname__ (1, "y");
-  outsys.stname  = __sysdefstname__ (outsys.n, outsys.nz);
-
-  ## Set name of input
-  if (nargin > 3)
-    ## make sure its a list of a single string
-    if(!isempty(inname))
-      if(!islist(inname))  inname = list(inname);  endif
-      if( !is_signal_list(inname) )
-        error("inname must be a string or list of strings");
-      endif
-      if(length(inname) > 1)
-        warning("tf2sys: %d input names provided; first used",length(inname));
-        inname = inname(1);
-      endif
-      outsys = syssetsignals(outsys,"in",inname);
-    endif
-  endif
-
-  ## Set name of output
-  if (nargin > 4)
-    if(!isempty(outname))
-      if(!islist(outname))  outname = list(outname);  endif
-      if(!is_signal_list(outname))
-        error("outname must be a string or a list of strings");
-      endif
-      if(length(outname) > 1)
-        warning("tf2sys: %d output names provided; first used",length(outname));
-        outname = outname(1);
-      endif
-      outsys = syssetsignals(outsys,"out",outname);
-    endif
-  endif
+function outsys = tf2sys (varargin)
+  
+  warning("tf2sys is deprecated.  Use tf() instead.");
+  outsys = tf(varargin{:});
 
 endfunction
diff --git a/scripts/control/system/ugain.m b/scripts/control/system/ugain.m
--- a/scripts/control/system/ugain.m
+++ b/scripts/control/system/ugain.m
@@ -29,11 +29,11 @@
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: April 1998
 
 function outsys = ugain (n)
 
   if (nargin != 1 || nargout > 1)
     usage ("outsys = ugain(n)");
   endif
-  outsys = ss2sys ([], [], [], eye (n));
+  outsys = ss ([], [], [], eye (n));
 
 endfunction
diff --git a/scripts/control/system/zp2ss.m b/scripts/control/system/zp2ss.m
--- a/scripts/control/system/zp2ss.m
+++ b/scripts/control/system/zp2ss.m
@@ -63,17 +63,17 @@ function [a, b, c, d] = zp2ss (zer, pol,
 	  ") should be a vector"]);
     elseif(! isscalar(k))
       error(["k(",num2str(rows(k)),",",num2str(columns(k)), ...
 	  ") should be a scalar"]);
     elseif( k != real(k))
       warning("zp2ss: k is complex")
     endif
 
-    zpsys = ss2sys (zeros (0, 0), zeros (0, 1), zeros (1, 0), k);
+    zpsys = ss (zeros (0, 0), zeros (0, 1), zeros (1, 0), k);
 
     ## Find the number of zeros and the number of poles
     nzer=length(zer);
     npol =length(pol);
 
     if(nzer > npol)
       error([num2str(nzer)," zeros, exceeds number of poles=",num2str(npol)]);
     endif
@@ -125,17 +125,17 @@ function [a, b, c, d] = zp2ss (zer, pol,
 	  zer = [];
 	endif
 	[den, pol] = __zp2ssg2__ (pol);         # get two poles
       otherwise
 	error(["pcnt = ",num2str(pcnt)])
       endswitch
 
       ## pack tf into system form and put in series with earlier realization
-      zpsys1 = tf2sys(num,den,0,"u","yy");
+      zpsys1 = tf(num,den,0,"u","yy");
 
       ## change names to avoid warning messages from sysgroup
       zpsys  = syssetsignals (zpsys, "in", "u1", 1);
       zpsys1 = sysupdate (zpsys1, "ss");
       nn     = sysdimensions (zpsys);        # working with continuous system
       zpsys  = syssetsignals (zpsys, "st", __sysdefioname__ (nn, "x"));
       nn1    = sysdimensions (zpsys1);
       zpsys1 = syssetsignals (zpsys1, "st", __sysdefioname__ (nn1, "xx"));
diff --git a/scripts/control/system/zp2sys.m b/scripts/control/system/zp2sys.m
--- a/scripts/control/system/zp2sys.m
+++ b/scripts/control/system/zp2sys.m
@@ -50,98 +50,14 @@
 ## 1 (s - 1) (s + 1)
 ## -----------------
 ## s (s + 2) (s + 2)
 ## @end example
 ## @end deftypefn
 
 ## Modified by John Ingram  July 20, 1996
 
-function outsys = zp2sys (zer, pol, k, tsam, inname, outname)
-
-  ## Test for the correct number of input arguments
-  if ((nargin < 3) || (nargin > 6))
-    usage("outsys = zp2sys(zer,pol,k[,tsam,inname,outname])");
-  endif
-
-  ## check input format
-  if( ! (isvector(zer) | isempty(zer) ) )
-    error("zer must be a vector or empty");
-  endif
-  if(!isempty(zer))
-    zer = reshape(zer,1,length(zer));           # make it a row vector
-  endif
-
-  if( ! (isvector(pol) | isempty(pol)))
-    error("pol must be a vector");
-  endif
-  if(!isempty(pol))
-    pol = reshape(pol,1,length(pol));
-  endif
-
-  if (! isscalar(k))
-     error("k must be a scalar");
-  endif
-
-  ## Test proper numbers of poles and zeros.  The number of poles must be
-  ## greater than or equal to the number of zeros.
-  if (length(zer) >  length(pol))
-    error(["number of poles (", num2str(length(pol)), ...
-        ") < number of zeros (", num2str(length(zer)),")"]);
-  endif
-
-  ## Set the system transfer function
-  outsys.zer = zer;
-  outsys.pol = pol;
-  outsys.k = k;
-
-  ## Set the system vector:  active = 1, updated = [0 1 0];
-  outsys.sys = [1, 0, 1, 0];
+function outsys = zp2sys ( varargin )
 
-  ## Set defaults
-  outsys.tsam = 0;
-  outsys.n = length(pol);
-  outsys.nz = 0;
-  outsys.yd = 0;        # assume (for now) continuous time outputs
-
-  ## Set the type of system
-  if (nargin > 3)
-    if( !isscalar(tsam) )
-      error("tsam must be a nonnegative scalar");
-    endif
-    if (tsam < 0)
-      error("sampling time must be positve")
-    elseif (tsam > 0)
-      [outsys.n,outsys.nz] = swap(outsys.n, outsys.nz);
-      outsys.yd = 1;            # discrete-time output
-    endif
-
-    outsys.tsam = tsam;
-  endif
-
-  outsys.inname = __sysdefioname__ (1, "u");
-  outsys.outname = __sysdefioname__ (1, "y");
-  outsys.stname = __sysdefstname__ (outsys.n, outsys.nz);
-
-  ## Set name of input
-  if (nargin > 4)
-    ## make sure its a string
-    if(!isempty(inname))
-      if(!islist(inname))  inname = list(inname); endif
-      if(!is_signal_list(inname))
-        error("inname must be a single signal name");
-      endif
-      outsys.inname = inname(1);
-    endif
-  endif
-
-  ## Set name of output
-  if (nargin > 5)
-    if(!isempty(outname))
-      if(!islist(outname))        outname = list(outname);    endif
-      if(!is_signal_list(outname))
-        error("outname must be a single signal name");
-      endif
-      outsys.outname = outname(1);
-    endif
-  endif
+  warning("zp2sys is deprecated.  Use zp() instead.");
+  outsys = zp(varargin{:});
 
 endfunction
diff --git a/scripts/control/util/__outlist__.m b/scripts/control/util/__outlist__.m
--- a/scripts/control/util/__outlist__.m
+++ b/scripts/control/util/__outlist__.m
@@ -50,30 +50,35 @@ function str_val = __outlist__ (name_lis
   unwind_protect
     warn_empty_list_elements = 0;
 
     if( nargin < 1 | nargin > 4 )
       usage("str_val = outlist(x[,tabchar,yd,ilist])");
     endif
 
     m = length(name_list);
-    if(nargin < 4)           ilist = 1:m;          endif
+    if(nargin < 4)
+      ilist = 1:m;
+    endif
     if(nargin ==1)
       tabchar = "";
     endif
 
-    if(nargin < 3)             yd = zeros(1,m);
-    elseif(isempty(yd))        yd = zeros(1,m);          endif
+    if(nargin < 3)
+      yd = zeros(1,m);
+    elseif(isempty(yd))
+      yd = zeros(1,m);
+    endif
 
     str_val = "";
-    dstr = list(""," (discrete)");
-    if((m >= 1) && (islist(name_list)))
+    dstr = {""," (discrete)"};
+    if((m >= 1) && (iscell(name_list)))
       for ii=1:m
 	str_val = sprintf("%s%s%d: %s%s\n",str_val,tabchar, ilist(ii), ...
-			  nth(name_list,ii),nth(dstr,yd(ii)+1));
+			  name_list{ii},dstr{yd(ii)+1});
       endfor
     else
       str_val = sprintf("%sNone",tabchar);
     endif
 
   unwind_protect_cleanup
     warn_empty_list_elements = save_warn_empty_list_elements;
   end_unwind_protect
diff --git a/scripts/control/util/__zgpbal__.m b/scripts/control/util/__zgpbal__.m
--- a/scripts/control/util/__zgpbal__.m
+++ b/scripts/control/util/__zgpbal__.m
@@ -99,11 +99,11 @@ function retsys = __zgpbal__ (Asys)
       d(1:pp,j) = d(1:pp,j)*xx(j1);
     endfor
     for i=1:pp
       i1 = i + nn + mm;
       d(i,1:mm) = d(i,1:mm)*xx(i1);
     endfor
   endif
 
-  retsys = ss2sys(a,b,c,d);
+  retsys = ss(a,b,c,d);
 endfunction
 
diff --git a/scripts/control/util/strappend.m b/scripts/control/util/strappend.m
--- a/scripts/control/util/strappend.m
+++ b/scripts/control/util/strappend.m
@@ -26,15 +26,15 @@ function retval = strappend (strlist, su
   if (nargin != 2 || nargout > 1)
     usage ("retval = strappend (strlist, suffix)");
   elseif (! is_signal_list (strlist))
     error ("strlist must be a list of strings (see is_signal_list)");
   elseif (! (isstr (suffix) && rows (suffix) == 1))
     error ("suffix must be a single string");
   endif
 
-  retval = list ();
+  retval = {};
 
   for ii = 1:length (strlist)
-    retval(ii) = sprintf ("%s%s", nth (strlist, ii), suffix);
+    retval{ii} = sprintf ("%s%s", strlist{ii}, suffix);
   endfor
 
 endfunction
