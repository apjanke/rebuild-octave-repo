# HG changeset patch
# User jwe
# Date 1192039382 0
#      Wed Oct 10 18:03:02 2007 +0000
# Node ID 8b0cfeb063654ab16e98bb3bb38358e76e6e7502
# Parent  e87f860624cc7c0a273fd42dc2ff53feada45a96
[project @ 2007-10-10 18:02:59 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,12 @@
+2007-10-10  Kim Hansen  <kimhanse@gmail.com>
+
+        * run-octave.in: Use $args.  Eliminate "if [ -n "$args" ]" conditional.
+
 2007-10-09  John W. Eaton  <jwe@octave.org>
 
 	* gdbinit.in: Delete.
 	* octMakefile.in (DISTFILES): Remove it from the list.
 	(.gdbinit): Delete rule.
 	(maintainer-clean, distclean): No need to delete .gdbinit.
 
 2007-10-09  Kim Hansen  <kimhanse@gmail.com>
diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,8 +1,19 @@
+2007-10-10  Olli Saarela  <Olli.Saarela@kcl.fi>
+
+	* interpreter/arith.txi, interpreter/basics.txi,
+	interpreter/container.txi, interpreter/dynamic.txi,
+	interpreter/eval.txi, interpreter/expr.txi, interpreter/func.txi,
+	interpreter/geometry.txi, interpreter/intro.txi,
+	interpreter/numbers.txi, interpreter/plot.txi,
+	interpreter/poly.txi, interpreter/set.txi, interpreter/sparse.txi,
+	interpreter/stmt.txi, interpreter/strings.txi,
+	interpreter/testfun.txi, interpreter/tips.txi: Spelling fixes. 
+
 2007-10-06  John W. Eaton  <jwe@octave.org>
 
 	* interpreter/octave.texi: Add David Bateman and Søren Hauberg as
 	authors.
 
 2006-09-28  Henry Mollet  mollet@pacbell.net
 
 	* interpreter/func.txi: Correct results of a couple of examples.
diff --git a/doc/interpreter/arith.txi b/doc/interpreter/arith.txi
--- a/doc/interpreter/arith.txi
+++ b/doc/interpreter/arith.txi
@@ -144,17 +144,17 @@ specified in radians.  To convert from d
 
 @DOCSTRING(asinh)
 @DOCSTRING(acosh)
 @DOCSTRING(atanh)
 @DOCSTRING(asech)
 @DOCSTRING(acsch)
 @DOCSTRING(acoth)
 
-Each of these functions expect a single argument.  For matrix arguments,
+Each of these functions expects a single argument.  For matrix arguments,
 they work on an element by element basis.  For example,
 
 @example
 @group
 sin ([1, 2; 3, 4])
      @result{}  0.84147   0.90930
          0.14112  -0.75680
 @end group
diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -346,17 +346,17 @@ Many of the command-line editing functio
 characters.  For example, the character @kbd{Control-a} moves the cursor
 to the beginning of the line.  To type @kbd{C-a}, hold down @key{CTRL}
 and then press @key{a}.  In the following sections, control characters
 such as @kbd{Control-a} are written as @kbd{C-a}.
 
 Another set of command-line editing functions use Meta characters.  On
 some terminals, you type @kbd{M-u} by holding down @key{META} and
 pressing @key{u}.  If your terminal does not have a @key{META} key, you
-can still type Meta charcters using two-character sequences starting
+can still type Meta characters using two-character sequences starting
 with @kbd{ESC}.  Thus, to enter @kbd{M-u}, you could type
 @key{ESC}@key{u}.  The @kbd{ESC} character sequences are also allowed on
 terminals with real Meta keys.  In the following sections, Meta
 characters such as @kbd{Meta-u} are written as @kbd{M-u}.
 
 
 @menu
 * Cursor Motion::               
diff --git a/doc/interpreter/container.txi b/doc/interpreter/container.txi
--- a/doc/interpreter/container.txi
+++ b/doc/interpreter/container.txi
@@ -286,17 +286,17 @@ the example above
 octave:4> size(x)
 ans =
 
    1   2
 @end group
 @end example
 
 Elements can be deleted from a structure array in a similar manner to a
-numerial array, by assignment the elements to an empty matrix. For
+numerical array, by assigning the elements to an empty matrix. For
 example
 
 @example
 @group
 in = struct ('call1', @{x, Inf, 'last'@}, 'call2', @{x, Inf, 'first'@});
 in (1, :) = []
 @result{} in =
       @{
@@ -685,28 +685,28 @@ using the @code{cell2mat} and @code{cell
 Comma separated lists are the basic argument type to all Octave
 functions. In the example
 
 @example
 max (@var{a}, @var{b})
 @end example
 
 @noindent
-@code{@var{a}, @var{b}} is a somma separated list. Comma separated lists
+@code{@var{a}, @var{b}} is a comma separated list. Comma separated lists
 can appear on both the right and left hand side of an equation. For
 example
 
 @example
 [@var{i}, @var{j}] = ceil (find (@var{x}, [], 'last'));
 @end example
 
 @noindent
 where @code{@var{i}, @var{j}} is equally a comma separated list. Comma
 separated lists can not be directly manipulated by the user. However,
-both structures are cell arrays can be converted into into comma
+both structures are cell arrays can be converted into comma
 separated lists, which makes them useful to keep the input arguments and
 return values of functions organized. Another example of where a comma
 separated list can be used is in the creation of a new array. If all the
 accessed elements of a cell array are scalars or column vectors, they
 can be concatenated into a new column vector containing the elements, by
 surrounding the list with @code{[} and @code{]} as in the following
 example
 
@@ -716,17 +716,17 @@ b = [a@{:@}]
      @result{} b =
          1   2   3   4
 @end example
 
 It is also possible to pass the accessed elements directly to a
 function.  The list of elements from the cell array will be passed as an
 argument list to a given function as if it is called with the elements as
 arguments.  The two calls to @code{printf} in the following example are
-identical but the latter is more simple and handles more situations
+identical but the latter is simpler and handles more situations
 
 @example
 c = @{"GNU", "Octave", "is", "Free", "Software"@};
 printf ("%s ", c@{1@}, c@{2@}, c@{3@}, c@{4@}, c@{5@});
      @print{} GNU Octave is Free Software 
 printf ("%s ", c@{:@});
      @print{} GNU Octave is Free Software 
 @end example
diff --git a/doc/interpreter/dynamic.txi b/doc/interpreter/dynamic.txi
--- a/doc/interpreter/dynamic.txi
+++ b/doc/interpreter/dynamic.txi
@@ -51,17 +51,17 @@ routines?  These are highly optimized an
 of being interpreted.
 @item
 Does writing a dynamically linked function represent useful investment
 of your time, relative to staying in Octave?
 @end itemize
 
 Also, as oct- and mex-files are dynamically linked to octave, they
 introduce to possibility of having Octave abort due to coding errors in
-the user code.  For example a segmentation violation in the users code
+the user code.  For example a segmentation violation in the user's code
 will cause Octave to abort.
 
 @menu
 * Oct-Files::                   
 * Mex-Files::                   
 * Standalone Programs::         
 @end menu
 
@@ -239,18 +239,18 @@ selection of which include
 The @code{()} operator or @code{elem} method allow the values of the
 matrix or array to be read or set.  These can take a single argument,
 which is of type @code{octave_idx_type}, that is the index into the matrix or
 array.  Additionally, the matrix type allows two argument versions of the
 @code{()} operator and elem method, giving the row and column index of the
 value to obtain or set.
 @end deftypefn
 
-Note that these function do significant error checking and so in some
-circumstances the user might prefer the access the data of the array or
+Note that these functions do significant error checking and so in some
+circumstances the user might prefer to access the data of the array or
 matrix directly through the fortran_vec method discussed below.
 
 @deftypefn Method octave_idx_type nelem (void) const
 The total number of elements in the matrix or array.
 @end deftypefn
 
 @deftypefn Method size_t byte_size (void) const
 The number of bytes used to store the matrix or array.
@@ -388,17 +388,17 @@ retval(1) = octave_value (ch, true, '\''
 // Create a double quoted string
 retval(0) = octave_value (ch, true);
 @end group
 @end example
 
 @node Cell Arrays in Oct-Files
 @subsection Cell Arrays in Oct-Files
 
-Octave's cell type is equally accessible within an oct-files.  A cell
+Octave's cell type is equally accessible within oct-files.  A cell
 array is just an array of @code{octave_value}s, and so each element of the cell
 array can then be treated just like any other @code{octave_value}.  A simple
 example is
 
 @examplefile{celldemo.cc}
 
 Note that cell arrays are used less often in standard oct-files and so
 the @file{Cell.h} header file must be explicitly included.  The rest of this
@@ -435,17 +435,17 @@ An example of its use is
 @example
 @group
 x.a = 1; x.b = "test"; x.c = [1, 2];
 structdemo (x, "b")
 @result{} selected = test
 @end group
 @end example
 
-The commented code above demonstrates how to iterated over all of the
+The commented code above demonstrates how to iterate over all of the
 fields of the structure, where as the following code demonstrates finding
 a particular field in a more concise manner.
 
 As can be seen the @code{contents} method of the @code{Octave_map} class
 returns a @code{Cell} which allows structure arrays to be represented.
 Therefore, to obtain the underlying @code{octave_value} we write
 
 @example
@@ -505,18 +505,18 @@ SparseMatrix sm;
 @dots{}
 int nel = sm.nelem ();
 @end group
 @end example
 
 returns the number of non-zero elements.  If the user really requires the
 number of elements in the matrix, including the non-zero elements, they
 should use @code{numel} rather than @code{nelem}.  Note that for very
-large matrices, where the product of the two dimensions is large that
-the representation of the an unsigned int, then @code{numel} can overflow.
+large matrices, where the product of the two dimensions is larger than
+the representation of an unsigned int, then @code{numel} can overflow.
 An example is @code{speye(1e6)} which will create a matrix with a million
 rows and columns, but only a million non-zero elements.  Therefore the
 number of rows by the number of columns in this case is more than two
 hundred times the maximum value that can be represented by an unsigned int.
 The use of @code{numel} should therefore be avoided useless it is known
 it won't overflow.
 
 Extreme care must be take with the elem method and the "()" operator,
@@ -979,18 +979,18 @@ OCTAVE_LOCAL_BUFFER (double, tmp, len)
 
 that returns a pointer @code{tmp} of type @code{double *} of length
 @code{len}.
 
 @node Input Parameter Checking in Oct-Files
 @subsection Input Parameter Checking in Oct-Files
 
 As oct-files are compiled functions they have the possibility of causing
-Octave to abort abnormally.  It is therefore inportant that the input
-parameters to each and every function has the minimum of parameter
+Octave to abort abnormally.  It is therefore important that
+each and every function has the minimum of parameter
 checking needed to ensure that Octave behaves well.
 
 The minimum requirement, as previously discussed, is to check the number
 of input arguments before using them to avoid referencing a non existent
 argument.  However, it some case this might not be sufficient as the
 underlying code imposes further constraints.  For example an external
 function call might be undefined if the input arguments are not
 integers, or if one of the arguments is zero.  Therefore, oct-files often
@@ -1094,17 +1094,17 @@ The division by zero (and in fact all wa
 The documentation of an oct-file is the fourth string parameter of the
 @code{DEFUN_DLD} macro.  This string can be formatted in the same manner
 as the help strings for user functions (@ref{Documentation Tips}),
 however there are some issue that are particular to the formatting of
 help strings within oct-files.
 
 The major issue is that the help string will typically be longer than a
 single line of text, and so the formatting of long help strings need to
-be taken into account.  There are several manner in which to treat this
+be taken into account.  There are several manners in which to treat this
 issue, but the most common is illustrated in the following example
 
 @example
 @group
 DEFUN_DLD (do_what_i_want, args, nargout, 
   "-*- texinfo -*-\n\
 @@deftypefn @{Function File@} @{@} do_what_i_say (@@var@{n@})\n\
 A function that does what the user actually wants rather than what\n\
@@ -1501,17 +1501,17 @@ b = mystruct(a)
     @}
 @end group
 @end example
 
 @node Sparse Matrices with Mex-Files
 @subsection Sparse Matrices with Mex-Files
 
 The Octave format for sparse matrices is identical to the mex format in
-that it is a compressed colument sparse format.  Also in both, sparse
+that it is a compressed column sparse format.  Also in both, sparse
 matrices are required to be two dimensional.  The only difference is that
 the real and imaginary parts of the matrix are stored separately.
 
 The mex-file interface, as well as using @code{mxGetM}, @code{mxGetN},
 @code{mxSetM}, @code{mxSetN}, @code{mxGetPr}, @code{mxGetPi},
 @code{mxSetPr} and @code{mxSetPi}, the mex-file interface supplies the
 functions
 
diff --git a/doc/interpreter/eval.txi b/doc/interpreter/eval.txi
--- a/doc/interpreter/eval.txi
+++ b/doc/interpreter/eval.txi
@@ -18,17 +18,17 @@ been computed and stored in a string, wh
 @menu
 * Calling a Function by its Name::
 * Evaluation in a Different Context::
 @end menu
 
 @node Calling a Function by its Name
 @section Calling a Function by its Name
 
-The @code{feval} function allow you to call a function from a string
+The @code{feval} function allows you to call a function from a string
 containing its name. This is useful when writing a function that need to
 call user-supplied functions. The @code{feval} function takes the name
 of the function to call as its first argument, and the remaining 
 arguments are given to the function.
 
 The following example is a simple-minded function using @code{feval}
 that finds the root of a user-supplied function of one variable using
 Newton's method.
diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -439,17 +439,17 @@ by each corresponding element of @var{x}
 
 @item @var{x} ^ @var{y}
 @itemx @var{x} ** @var{y}
 @opindex **
 @opindex ^
 Power operator.  If @var{x} and @var{y} are both scalars, this operator
 returns @var{x} raised to the power @var{y}.  If @var{x} is a scalar and
 @var{y} is a square matrix, the result is computed using an eigenvalue
-expansion.  If @var{x} is a square matrix. the result is computed by
+expansion.  If @var{x} is a square matrix, the result is computed by
 repeated multiplication if @var{y} is an integer, and by an eigenvalue
 expansion if @var{y} is not an integer.  An error results if both
 @var{x} and @var{y} are matrices.
 
 The implementation of this operator needs to be improved.
 
 @item @var{x} .^ @var{y}
 @item @var{x} .** @var{y}
diff --git a/doc/interpreter/func.txi b/doc/interpreter/func.txi
--- a/doc/interpreter/func.txi
+++ b/doc/interpreter/func.txi
@@ -1067,17 +1067,17 @@ The general form of a command call is
 
 @noindent
 which translates directly to
 
 @example
 @var{name} ("@var{arg1}", "@var{arg2}", @dots{})
 @end example
 
-A function can be used as a command if it accept string input arguments.
+A function can be used as a command if it accepts string input arguments.
 To do this, the function must be marked as a command, which can be done
 with the @code{mark_as_command} command like this
 
 @example
 mark_as_command name
 @end example
 
 @noindent
diff --git a/doc/interpreter/geometry.txi b/doc/interpreter/geometry.txi
--- a/doc/interpreter/geometry.txi
+++ b/doc/interpreter/geometry.txi
@@ -351,17 +351,17 @@ The result of which can be seen in @ref{
 @caption{Demonstration of the @code{inpolygon} function to determine the
 points inside a polygon}
 @end float
 @end ifnotinfo
 
 @node Convex Hull
 @section Convex Hull
 
-The convex hull of a set of points, is the minimum convex envelope
+The convex hull of a set of points is the minimum convex envelope
 containing all of the points. Octave has the functions @code{convhull}
 and @code{convhulln} to calculate the convec hull of 2-dimensional and
 N-dimensional sets of points.
 
 @DOCSTRING(convhull)
 
 @DOCSTRING(convhulln)
 
diff --git a/doc/interpreter/intro.txi b/doc/interpreter/intro.txi
--- a/doc/interpreter/intro.txi
+++ b/doc/interpreter/intro.txi
@@ -262,17 +262,17 @@ a separate window to display the plot.
 To save a plot once it has been displayed on the screen, use the print
 command.  For example,
 
 @example
 print -deps foo.eps
 @end example
 
 @noindent
-will create a fille called @file{foo.eps} that contains a rendering of
+will create a file called @file{foo.eps} that contains a rendering of
 the current plot.  The command
 
 @example
 help print
 @end example
 
 @noindent
 explains more options for the @code{print} command and provides a list
@@ -508,17 +508,17 @@ Any parameter whose name contains the na
 @var{integer}, @var{integer1} or @var{matrix}) is expected to be of that
 type.  Parameters named @var{object} may be of any type.  Parameters
 with other sorts of names (e.g., @var{new_file}) are discussed
 specifically in the description of the function.  In some sections,
 features common to parameters of several functions are described at the
 beginning.
 
 Functions in Octave may be defined in several different ways.  The
-catagory name for functions may include another name that indicates the
+category name for functions may include another name that indicates the
 way that the function is defined.  These additional tags include
 
 @table @asis
 @item Function File
 @cindex function file
 The function described is defined using Octave commands stored in a text
 file.  @xref{Function Files}.
 
@@ -541,17 +541,17 @@ arguments.
 @end table
 
 @node A Sample Command Description
 @subsubsection A Sample Command Description
 @cindex command descriptions
 
 Command descriptions have a format similar to function descriptions,
 except that the word `Function' is replaced by `Command.  Commands are
-functions that may called without surrounding their arguments in
+functions that may be called without surrounding their arguments in
 parentheses.  For example, here is the description for Octave's
 @code{cd} command:
 
 @deffn {Command} cd dir
 @deffnx {Command} chdir dir
 Change the current working directory to @var{dir}.  For example,
 @kbd{cd ~/octave} changes the current working directory to
 @file{~/octave}.  If the directory does not exist, an error message is
diff --git a/doc/interpreter/numbers.txi b/doc/interpreter/numbers.txi
--- a/doc/interpreter/numbers.txi
+++ b/doc/interpreter/numbers.txi
@@ -594,17 +594,17 @@ or @code{false} functions.
 
 @node Predicates for Numeric Objects
 @section Predicates for Numeric Objects
 
 Since the type of a variable may change during the execution of a
 program, it can be necessary to type checking at run-time. Doing this
 also allows you to change the behaviour of a function depending on the
 type of the input. As an example, this naive implementation of @code{abs}
-return the absolute value of the input if it is a real number, and the
+returns the absolute value of the input if it is a real number, and the
 length of the input if it is a complex number.
 
 @example
 function a = abs (x)
   if (isreal (x))
     a = sign (x) .* x;
   elseif (iscomplex (x))
     a = sqrt (real(x).^2 + imag(x).^2);
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -139,17 +139,17 @@ produces the figure shown in @ref{fig:er
 
 @DOCSTRING(semilogxerr)
 
 @DOCSTRING(semilogyerr)
 
 @DOCSTRING(loglogerr)
 
 Finally, the @code{polar} function allows you to easily plot data in
-polor coordinates.  However, the display coordinates remain rectangular
+polar coordinates.  However, the display coordinates remain rectangular
 and linear.  For example,
 
 @example
 polar (0:0.1:10*pi, 0:0.1:10*pi);
 @end example
 
 @noindent
 produces the spiral plot shown in @ref{fig:polar}.
@@ -586,17 +586,17 @@ Indicates the orientation for printing. 
 @node Axes Properties
 @subsubsection Axes Properties
 
 @table @code
 @item position
 A four-element vector specifying the coordinates of the lower left
 corner and width and height of the plot, in normalized units.  For
 example, @code{[0.2, 0.3, 0.4, 0.5]} sets the lower left corner of the
-axes at @math{(0.2, 0.3)} and the width and heigth to be 0.4 and 0.5
+axes at @math{(0.2, 0.3)} and the width and height to be 0.4 and 0.5
 respectively.
 
 @item title
 Index of text object for the axes title.
 
 @item box
 Either @code{"on"} or @code{"off"} to toggle display of the box around
 the axes.
@@ -709,17 +709,17 @@ May be one of
 @item "replace"
 @item "replacechildren"
 @end table
 
 @item outerposition
 A four-element vector specifying the coordinates of the lower left
 corner and width and height of the plot, in normalized units.  For
 example, @code{[0.2, 0.3, 0.4, 0.5]} sets the lower left corner of the
-axes at @math{(0.2, 0.3)} and the width and heigth to be 0.4 and 0.5
+axes at @math{(0.2, 0.3)} and the width and height to be 0.4 and 0.5
 respectively.
 @end table
 
 @node Line Properties
 @subsubsection Line Properties
 
 @table @code
 @itemx xdata
@@ -783,17 +783,17 @@ The color of the text.  @xref{Colors}.
 The data for the image.  Each pixel of the image corresponds to an
 element of @code{cdata}.  The value of an element of @code{cdata}
 specifies the row-index into the colormap of the axes object containing
 the image.  The color value found in the color map for the given index
 determines the color of the pixel.
 
 @item xdata
 @itemx ydata
-Two-element vectors specifing the range of the x- and y- coordinates for
+Two-element vectors specifying the range of the x- and y- coordinates for
 the image.
 @end table
 
 @node Patch Properties
 @subsubsection Patch Properties
 
 @table @code
 @item cdata
@@ -929,17 +929,17 @@ returns a list of factory defaults.
 
 Colors may be specified as RGB triplets with values ranging from zero to
 one, or by name.  Recognized color names include @code{"blue"},
 @code{"black"}, @code{"cyan"}, @code{"green"}, @code{"magenta"},
 @code{"red"}, @code{"white"}, and @code{"yellow"}.
 
 @node Line Styles
 @subsection Line Styles
-Line styles are specified by the folowing properties:
+Line styles are specified by the following properties:
 
 @table @code
 @item linestyle
 May be one of
 @table @code
 @item "-"
 Solid lines.
 @item "--"
@@ -952,17 +952,17 @@ A dash-dot line.
 
 @item linewidth
 A number specifying the width of the line.  The default is 1.  A value
 of 2 is twice as wide as the default, etc.
 @end table
 
 @node Marker Styles
 @subsection Marker Styles
-Marker styles are specified by the folowing properties:
+Marker styles are specified by the following properties:
 @table @code
 @item marker
 A character indicating a plot marker to be place at each data point, or
 @code{"none"}, meaning no markers should be displayed.
 
 @itemx markeredgecolor
 The color of the edge around the marker, or @code{"auto"}, meaning that
 the edge color is the same as the face color.  @xref{Colors}.
diff --git a/doc/interpreter/poly.txi b/doc/interpreter/poly.txi
--- a/doc/interpreter/poly.txi
+++ b/doc/interpreter/poly.txi
@@ -120,17 +120,17 @@ in a least-squares sense, which is what 
 
 In situations where a single polynomial isn't good enough, a solution
 is to use several polynomials pieced together.  The function @code{mkpp}
 creates a piece-wise polynomial, @code{ppval} evaluates the function 
 created by @code{mkpp}, and @code{unmkpp} returns detailed information
 about the function.
 
 The following example shows how to combine two linear functions and a
-quadratic into one function.  Each of these functions are expressed
+quadratic into one function.  Each of these functions is expressed
 on adjoined intervals.
 
 @example
 x = [-2, -1, 1, 2];
 p = [ 0,  1, 0;
       1, -2, 1;
       0, -1, 1 ];
 pp = mkpp(x, p);
diff --git a/doc/interpreter/set.txi b/doc/interpreter/set.txi
--- a/doc/interpreter/set.txi
+++ b/doc/interpreter/set.txi
@@ -1,17 +1,17 @@
 @c Copyright (C) 1996, 1997, 2007 John W. Eaton
 @c This is part of the Octave manual.
 @c For copying conditions, see the file gpl.texi.
 
 @node Sets
 @chapter Sets
 
 Octave has a limited set of functions for managing sets of data, where a
-set is defined as a collection unique elements.  In Octave a set is
+set is defined as a collection of unique elements.  In Octave a set is
 represented as a vector of numbers.
 
 @DOCSTRING(create_set)
 
 @DOCSTRING(unique)
 
 @menu
 * Set Operations:: 
diff --git a/doc/interpreter/sparse.txi b/doc/interpreter/sparse.txi
--- a/doc/interpreter/sparse.txi
+++ b/doc/interpreter/sparse.txi
@@ -80,17 +80,17 @@ data are stored as previously. However, 
 in the same column are stored adjacent in the computers memory, then
 we only need to store information on the number of non-zero elements
 in each column, rather than their positions. Thus assuming that the
 matrix has more non-zero elements than there are columns in the
 matrix, we win in terms of the amount of memory used.
 
 In fact, the column index contains one more element than the number of
 columns, with the first element always being zero. The advantage of
-this is a simplification in the code, in that their is no special case
+this is a simplification in the code, in that there is no special case
 for the first or last columns. A short example, demonstrating this in
 C is.
 
 @example
   for (j = 0; j < nc; j++)
     for (i = cidx (j); i < cidx(j+1); i++)
        printf ("non-zero element (%i,%i) is %d\n", 
 	   ridx(i), j, data(i));
@@ -143,17 +143,17 @@ it makes sense that the elements of the 
 same order as the dense matrices. Octave stores dense matrices in
 column major ordering, and so sparse matrices are equally stored in
 this manner.
 
 A further constraint on the sparse matrix storage used by Octave is that 
 all elements in the rows are stored in increasing order of their row
 index, which makes certain operations faster. However, it imposes
 the need to sort the elements on the creation of sparse matrices. Having
-dis-ordered elements is potentially an advantage in that it makes operations
+disordered elements is potentially an advantage in that it makes operations
 such as concatenating two sparse matrices together easier and faster, however
 it adds complexity and speed problems elsewhere.
 
 @node Creation, Information, Storage, Basics
 @subsection Creating Sparse Matrices
 
 There are several means to create sparse matrix.
 
@@ -182,17 +182,17 @@ matrix.
 
 Another typical sparse matrix that is often needed is a random distribution
 of random elements. The functions @dfn{sprand} and @dfn{sprandn} perform
 this for uniform and normal random distributions of elements. They have exactly
 the same calling convention, where @code{sprand (@var{r}, @var{c}, @var{d})},
 creates an @var{r}-by-@var{c} sparse matrix with a density of filled
 elements of @var{d}.
 
-Other functions of interest that directly creates a sparse matrices, are
+Other functions of interest that directly create sparse matrices, are
 @dfn{spdiag} or its generalization @dfn{spdiags}, that can take the
 definition of the diagonals of the matrix and create the sparse matrix 
 that corresponds to this. For example
 
 @example
 s = spdiag (sparse(randn(1,n)), -1);
 @end example
 
@@ -371,17 +371,17 @@ matrix. @xref{fig:spmatrix}, for an exap
 @dfn{treeplot}, @dfn{etreeplot} and @dfn{gplot} commands.
 
 @float Figure,fig:spmatrix
 @image{spmatrix,8cm}
 @caption{Structure of simple sparse matrix.}
 @end float
 
 One use of sparse matrices is in graph theory, where the
-interconnections between nodes is represented as an adjacency
+interconnections between nodes are represented as an adjacency
 matrix. That is, if the i-th node in a graph is connected to the j-th
 node. Then the ij-th node (and in the case of undirected graphs the
 ji-th node) of the sparse adjacency matrix is non-zero. If each node
 is then associated with a set of co-ordinates, then the @dfn{gplot}
 command can be used to graphically display the interconnections
 between nodes.
 
 As a trivial example of the use of @dfn{gplot}, consider the example
@@ -439,17 +439,18 @@ Octave is that many of the internal func
 @dfn{diag}, can not accept sparse matrices as an input. The sparse
 implementation in Octave therefore uses the @dfn{dispatch}
 function to overload the normal Octave functions with equivalent
 functions that work with sparse matrices. However, at any time the
 sparse matrix specific version of the function can be used by
 explicitly calling its function name. 
 
 The table below lists all of the sparse functions of Octave.  Note that
-in this specific sparse forms of the functions are typically the same as
+the names of the 
+specific sparse forms of the functions are typically the same as
 the general versions with a @dfn{sp} prefix. In the table below, and the
 rest of this article the specific sparse versions of the functions are
 used.
 
 @c Table includes in comments the missing sparse functions
 
 @table @asis
 @item Generate sparse matrices:
@@ -626,17 +627,17 @@ also available.
 @xref{fig:simplematrix}, for an example of the structure of a simple 
 positive definite matrix.
 
 @float Figure,fig:simplematrix
 @image{spmatrix,8cm}
 @caption{Structure of simple sparse matrix.}
 @end float
 
-The standard Cholesky factorization of this matrix, can be
+The standard Cholesky factorization of this matrix can be
 obtained by the same command that would be used for a full
 matrix. This can be visualized with the command 
 @code{r = chol(A); spy(r);}.
 @ifset HAVE_CHOLMOD
 @ifset HAVE_COLAMD
 @xref{fig:simplechol}.
 @end ifset
 @end ifset
@@ -1005,17 +1006,17 @@ distribution in
 @ifinfo
 Omega
 @end ifinfo
 as constant on each simplex (represented by the vector @code{conductivity}).
 Based on the finite element geometry, we first calculate a system (or
 stiffness) matrix for each simplex (represented as 3-by-3 elements on the
 diagonal of the element-wise system matrix @code{SE}. Based on @code{SE} 
 and a N-by-DE connectivity matrix @code{C}, representing the connections 
-between simplices and vectices, the global connectivity matrix @code{S} is
+between simplices and vertices, the global connectivity matrix @code{S} is
 calculated.
 
 @example
   # Element conductivity
   conductivity= [1*ones(1,16), ...
          2*ones(1,48), 1*ones(1,16)];
 
   # Connectivity matrix
diff --git a/doc/interpreter/stmt.txi b/doc/interpreter/stmt.txi
--- a/doc/interpreter/stmt.txi
+++ b/doc/interpreter/stmt.txi
@@ -546,17 +546,17 @@ for i = @{1,"two";"three",4@}
   i
 endfor
 @end group 
 @end example
 
 @noindent
 In this case the variable @code{i} takes on the value of the columns of
 the matrix or cell matrix. So the first loop iterates twice, producing
-two column vectors @code{[1;2]}, follwed by @code{[3;4]}, and likewise
+two column vectors @code{[1;2]}, followed by @code{[3;4]}, and likewise
 for the loop over the cell array. This can be extended to loops over
 multidimensional arrays. For example
 
 @example
 @group
 a = [1,3;2,4]; b = cat(3, a, 2*a);
 for i = c
   i
diff --git a/doc/interpreter/strings.txi b/doc/interpreter/strings.txi
--- a/doc/interpreter/strings.txi
+++ b/doc/interpreter/strings.txi
@@ -198,17 +198,17 @@ GNU = "GNU's Not UNIX";
 spaces = (GNU == " ")
      @result{} spaces =
            0   0   0   0   0   1   0   0   0   1   0   0   0   0
 @end example
 
 @noindent
 To determine if two functions are identical it is therefore necessary
 to use the @code{strcmp} or @code{strncpm} functions. Similar 
-functions exists for doing case-insensitive comparisons.
+functions exist for doing case-insensitive comparisons.
 
 @DOCSTRING(strcmp)
 
 @DOCSTRING(strcmpi)
 
 @DOCSTRING(strncmp)
 
 @DOCSTRING(strncmpi)
@@ -223,17 +223,17 @@ all blank characters with underscores.
 
 @example
 quote = "First things first, but not necessarily in that order";
 quote( quote == " " ) = "_"
      @print{} quote = First_things_first,_but_not_necessarily_in_that_order
 @end example
 
 For more complex manipulations, such as searching, replacing, and
-general regular expressions, the following function come with Octave.
+general regular expressions, the following functions come with Octave.
 
 @DOCSTRING(deblank)
 
 @DOCSTRING(findstr)
 
 @DOCSTRING(index)
 
 @DOCSTRING(rindex)
diff --git a/doc/interpreter/testfun.txi b/doc/interpreter/testfun.txi
--- a/doc/interpreter/testfun.txi
+++ b/doc/interpreter/testfun.txi
@@ -107,17 +107,17 @@ which is equivalent to:
 
 @example
    %!test assert (@dots{})
 @end example
 
 Sometimes during development there is a test that should work but is
 known to fail.  You still want to leave the test in because when the
 final code is ready the test should pass, but you may not be able to
-fix it immediately.  To avoid unecessary bug reports for these known
+fix it immediately.  To avoid unnecessary bug reports for these known
 failures, mark the block with @code{xtest} rather than @code{test}:
 
 @example
    %!xtest assert (1==0)
    %!xtest fail ('success=1','error'))
 @end example
 
 Another use of @code{xtest} is for statistical tests which should
diff --git a/doc/interpreter/tips.txi b/doc/interpreter/tips.txi
--- a/doc/interpreter/tips.txi
+++ b/doc/interpreter/tips.txi
@@ -270,17 +270,17 @@ Just about every Octave function ought t
 appropriate.  You can also put in header lines with other header
 names---they have no standard meanings, so they can't do any harm.
 
 @node Documentation Tips
 @section Tips for Documentation Strings
 
 As noted above, documentation is typically in a commented header block
 on an Octave function following the copyright statement. The help string
-shown above is an unformated stringed and will be displayed as is by
+shown above is an unformatted string and will be displayed as is by
 Octave. Here are some tips for the writing of documentation strings.
 
 @itemize @bullet
 @item
 Every command, function, or variable intended for users to know about
 should have a documentation string.
 
 @item
@@ -513,17 +513,17 @@ of @@var@{n@} and @@var@{k@}, defined as
  | n |    n (n-1) (n-2) ... (n-k+1)
  |   |  = -------------------------
  | k |               k!
  \   /
 @@end group
 @@end example
 @@end ifinfo
 
-If @@var@{n@} is a vector generate all combinations of the elements
+If @@var@{n@} is a vector, this generates all combinations of the elements
 of @@var@{n@}, taken @@var@{k@} at a time, one row per combination. The 
 resulting @@var@{c@} has size @@code@{[nchoosek (length (@@var@{n@}), 
 @@var@{k@}), @@var@{k@}]@}.
 
 @@seealso@{bincoeff@}
 @@end deftypefn
 @end group
 @end example
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,12 @@
+2007-10-10  Olli Saarela  <Olli.Saarela@kcl.fi>
+
+	* DASPK-opts.in, DASRT-opts.in, DASSL-opts.in: Spelling fixes.
+
 2007-10-10  John W. Eaton  <jwe@octave.org>
 
 	* LPsolve.h, LPsolve.cc: Delete.
 	* Makefile.in: Remove them from the INCLUDES and
 	LIBOCTAVE_CXX_SOURCES lists.
 
 2007-10-09  John W. Eaton  <jwe@octave.org>
 
diff --git a/liboctave/DASPK-opts.in b/liboctave/DASPK-opts.in
--- a/liboctave/DASPK-opts.in
+++ b/liboctave/DASPK-opts.in
@@ -260,17 +260,17 @@ This option only has an effect if the
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
 
 OPTION
   NAME = "initial step size"
   DOC_ITEM
-Differential-algebraic problems may occaisionally suffer from severe
+Differential-algebraic problems may occasionally suffer from severe
 scaling difficulties on the first step.  If you know a great deal
 about the scaling of your problem, you can help to alleviate this
 problem by specifying an initial stepsize (default is computed
 automatically).
   END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "-1.0"
   SET_EXPR = "(val >= 0.0) ? val : -1.0"
diff --git a/liboctave/DASRT-opts.in b/liboctave/DASRT-opts.in
--- a/liboctave/DASRT-opts.in
+++ b/liboctave/DASRT-opts.in
@@ -57,17 +57,17 @@ The local error test applied at each int
     void set_$OPT (const $TYPE& val)
       { $OPTVAR = val; reset = true; }
   END_SET_CODE
 END_OPTION
 
 OPTION
   NAME = "initial step size"
   DOC_ITEM
-Differential-algebraic problems may occaisionally suffer from severe
+Differential-algebraic problems may occasionally suffer from severe
 scaling difficulties on the first step.  If you know a great deal
 about the scaling of your problem, you can help to alleviate this
 problem by specifying an initial stepsize.
   END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "-1.0"
   SET_EXPR = "(val >= 0.0) ? val : -1.0"
 END_OPTION
diff --git a/liboctave/DASSL-opts.in b/liboctave/DASSL-opts.in
--- a/liboctave/DASSL-opts.in
+++ b/liboctave/DASSL-opts.in
@@ -85,17 +85,17 @@ work very well.
   TYPE = "octave_idx_type"
   INIT_VALUE = "0"
   SET_EXPR = "val"
 END_OPTION
 
 OPTION
   NAME = "initial step size"
   DOC_ITEM
-Differential-algebraic problems may occaisionally suffer from severe
+Differential-algebraic problems may occasionally suffer from severe
 scaling difficulties on the first step.  If you know a great deal
 about the scaling of your problem, you can help to alleviate this
 problem by specifying an initial stepsize.
   END_DOC_ITEM
   TYPE = "double"
   INIT_VALUE = "-1.0"
   SET_EXPR = "(val >= 0.0) ? val : -1.0"
 END_OPTION
diff --git a/run-octave.in b/run-octave.in
--- a/run-octave.in
+++ b/run-octave.in
@@ -41,19 +41,13 @@ if [ $# -gt 0 ]; then
     driver="valgrind --tool=memcheck"
     shift
   elif [ "x$1" = "x-strace" ]; then
     driver="strace -o octave.trace"
     shift
   fi
 fi
 
-if [ -n "$args" ]; then
-  OCTAVE_SITE_INITFILE="$top_srcdir/scripts/startup/main-rcfile" \
-  LD_PRELOAD="$liboctinterp $liboctave $libcruft" \
-  %library_path_var%="$builddir/src:$builddir/liboctave:$builddir/libcruft:$%library_path_var%" \
-    exec $driver "$builddir/src/octave" --no-initial-path --path="$LOADPATH" --image-path="$IMAGEPATH" "$@"
-else
-  OCTAVE_SITE_INITFILE="$top_srcdir/scripts/startup/main-rcfile" \
-  LD_PRELOAD="$liboctinterp $liboctave $libcruft" \
-  %library_path_var%="$builddir/src:$builddir/liboctave:$builddir/libcruft:$%library_path_var%" \
-    exec $driver "$builddir/src/octave" "$@"
-fi
+OCTAVE_SITE_INITFILE="$top_srcdir/scripts/startup/main-rcfile" \
+LD_PRELOAD="$liboctinterp $liboctave $libcruft" \
+%library_path_var%="$builddir/src:$builddir/liboctave:$builddir/libcruft:$%library_path_var%" \
+  exec $driver "$builddir/src/octave" $args "$@"
+
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,34 @@
+2007-10-10  Olli Saarela  <Olli.Saarela@kcl.fi>
+
+	* control/hinf/hinfsyn.m, control/hinf/wgt1o.m,
+	control/system/buildssic.m, control/system/c2d.m,
+	control/system/d2c.m, control/system/ord2.m, control/system/ss.m,
+	control/system/ss2sys.m, control/system/ss2tf.m,
+	control/system/syscont.m, control/system/sysdimensions.m,
+	control/system/sysdisc.m, control/system/sysmult.m,
+	control/system/sysrepdemo.m, control/system/tf2ss.m, elfun/lcm.m,
+	finance/fv.m, general/cumtrapz.m, general/gradient.m,
+	general/interp1.m, general/interp2.m, general/interp3.m,
+	general/interpft.m, general/interpn.m, general/polyarea.m,
+	general/rat.m, general/structfun.m, general/trapz.m,
+	geometry/tsearchn.m, image/rgb2hsv.m, linear-algebra/krylov.m,
+	miscellaneous/ans.m, miscellaneous/gzip.m, optimization/glpk.m,
+	optimization/sqp.m, plot/findobj.m, plot/legend.m, plot/peaks.m,
+	plot/plot3.m, plot/stem.m, polynomial/deconv.m,
+	polynomial/pchip.m, polynomial/spline.m, polynomial/unmkpp.m,
+	sparse/pcr.m, sparse/spalloc.m, sparse/spconvert.m,
+	specfun/factor.m, specfun/legendre.m, statistics/base/mean.m,
+	statistics/base/meansq.m, statistics/base/var.m,
+	statistics/tests/chisquare_test_independence.m,
+	statistics/tests/t_test.m, statistics/tests/u_test.m,
+	strings/dec2base.m, strings/mat2str.m, testfun/speed.m,
+	testfun/test.m: Spelling fixes.
+
 2007-10-10  Ben Abbott  <bpabbott@mac.com>
 
 	* polynomial/mpoles.m: Return indx = ordr(indx), not indx(ordr).
 
 2007-10-10  John W. Eaton  <jwe@octave.org>
 
 	* general/num2str.m: Always allow for sign for automatically
 	computed format widths.
diff --git a/scripts/control/hinf/hinfsyn.m b/scripts/control/hinf/hinfsyn.m
--- a/scripts/control/hinf/hinfsyn.m
+++ b/scripts/control/hinf/hinfsyn.m
@@ -68,17 +68,17 @@
 ## < ptol*||H|| 
 ## @end ifinfo
 ## (@var{H} is appropriate
 ## Hamiltonian) are considered to be on the imaginary axis.
 ## Default: 1e-9.
 ## @item tol
 ## threshold for 0.  Default: 200*@code{eps}.
 ##
-## @var{gmax}, @var{min}, @var{tol}, and @var{tol} must all be postive scalars.
+## @var{gmax}, @var{min}, @var{tol}, and @var{tol} must all be positive scalars.
 ## @end table
 ## @strong{Outputs}
 ## @table @var
 ## @item k
 ## System controller.
 ## @item g
 ## Designed gain value.
 ## @item gw
diff --git a/scripts/control/hinf/wgt1o.m b/scripts/control/hinf/wgt1o.m
--- a/scripts/control/hinf/wgt1o.m
+++ b/scripts/control/hinf/wgt1o.m
@@ -26,17 +26,17 @@
 ## @tex
 ## $ { \cal H }_2 / { \cal H }_\infty $
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## H-2/H-infinity
 ## @end ifinfo
 ## design procedure.
-## These function are part of the augmented plant @var{P}
+## These functions are part of the augmented plant @var{P}
 ## (see @command{hinfdemo} for an application example).
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item vl
 ## Gain at low frequencies.
 ## @item vh
 ## Gain at high frequencies.
diff --git a/scripts/control/system/buildssic.m b/scripts/control/system/buildssic.m
--- a/scripts/control/system/buildssic.m
+++ b/scripts/control/system/buildssic.m
@@ -57,24 +57,24 @@
 ##
 ## @item ulst
 ## if not empty the old inputs in vector @var{ulst} will
 ## be appended to the outputs. You need this if you
 ## want to ``pull out'' the input of a system. Elements
 ## are input numbers of @var{s1}--@var{s8}.
 ##
 ## @item olst
-## output list, specifiy the outputs of the resulting
+## output list, specifies the outputs of the resulting
 ## systems. Elements are output numbers of @var{s1}--@var{s8}.
 ## The numbers are allowed to be negative and may
 ## appear in any order. An empty matrix means
 ## all outputs.
 ##
 ## @item ilst
-## input list, specifiy the inputs of the resulting
+## input list, specifies the inputs of the resulting
 ## systems. Elements are input numbers of @var{s1}--@var{s8}.
 ## The numbers are allowed to be negative and may
 ## appear in any order. An empty matrix means
 ## all inputs.
 ## @end table
 ##
 ## Example:  Very simple closed loop system.
 ## @example
@@ -86,17 +86,17 @@
 ##      |  |            +----------------> u
 ##      |  |                         |
 ##      |  +-------------------------|---> e
 ##      |                            |
 ##      +----------------------------+
 ## @end group
 ## @end example
 ##
-## The closed loop system @var{GW} can be optained by
+## The closed loop system @var{GW} can be obtained by
 ## @example
 ## GW = buildssic([1 2; 2 -1], 2, [1 2 3], 2, G, K);
 ## @end example
 ## @table @var
 ## @item clst
 ## 1st row: connect input 1 (@var{G}) with output 2 (@var{K}).
 ##
 ## 2nd row: connect input 2 (@var{K}) with negative output 1 (@var{G}).
@@ -146,17 +146,17 @@
 ## @ifinfo
 ## from [z, u]' to [v1, v2, y]' 
 ## @end ifinfo
 ## can be obtained by (all @acronym{SISO} systems):
 ## @example
 ## GW = buildssic([1, 4; 2, 4; 3, 1], 3, [2, 3, 5],
 ##                [3, 4], G, W1, W2, One);
 ## @end example
-## where ``One'' is a unity gain (auxillary) function with order 0.
+## where ``One'' is a unity gain (auxiliary) function with order 0.
 ## (e.g. @code{One = ugain(1);})
 ## @end deftypefn
 
 ## Author: Kai P. Mueller <mueller@ifr.ing.tu-bs.de>
 ## Created: April 1998
 
 function sys = buildssic (Clst, Ulst, Olst, Ilst, s1, s2, s3, s4, s5, s6, s7, s8)
 
diff --git a/scripts/control/system/c2d.m b/scripts/control/system/c2d.m
--- a/scripts/control/system/c2d.m
+++ b/scripts/control/system/c2d.m
@@ -125,17 +125,17 @@ function dsys = c2d (sys, opt, T)
     endif
   elseif (T != Ts & Ts > 0)
     warning(["c2d: T=",num2str(T),", system tsam==",num2str(Ts), ...
       ": using T=", num2str(min(T,Ts))]);
     T = min(T,Ts);
   endif
 
   if (!is_sample(T))
-    error("sampling period T must be a postive, real scalar");
+    error("sampling period T must be a positive, real scalar");
   elseif (! (strcmp (opt, "ex")
 	     || strcmp (opt, "bi")
 	     || strcmp (opt, "matched")))
     error ("invalid option passed: %s", opt);
   endif
 
   sys = sysupdate(sys,"ss");
   [n,nz,m,p] = sysdimensions(sys);
diff --git a/scripts/control/system/d2c.m b/scripts/control/system/d2c.m
--- a/scripts/control/system/d2c.m
+++ b/scripts/control/system/d2c.m
@@ -74,17 +74,17 @@ function csys = d2c (sys, opt)
     opt = "log";
     tol = 1e-12;
   elseif(ischar(opt))   # all remaining cases are for nargin == 2
     tol = 1e-12;
     if( !(strcmp(opt,"log") | strcmp(opt,"bi") ) )
       error(["d2c: invalid opt passed=",opt]);
     endif
   elseif(!is_sample(opt))
-    error("tol must be a postive scalar")
+    error("tol must be a positive scalar")
   elseif(opt > 1e-2)
     warning(["d2c: ridiculous error tolerance passed=",num2str(opt); ...
         ", intended c2d call?"])
   else
     tol = opt;
     opt = "log";
   endif
   T = sysgettsam(sys);
diff --git a/scripts/control/system/ord2.m b/scripts/control/system/ord2.m
--- a/scripts/control/system/ord2.m
+++ b/scripts/control/system/ord2.m
@@ -25,17 +25,17 @@
 ## @table @var
 ## @item nfreq
 ## natural frequency [Hz]. (not in rad/s)
 ## @item damp
 ## damping coefficient
 ## @item gain
 ## dc-gain
 ## This is steady state value only for damp > 0.
-## gain is assumed to be 1.0 if ommitted.
+## gain is assumed to be 1.0 if omitted.
 ## @end table
 ##
 ## @strong{Output}
 ## @table @var
 ## @item outsys
 ## system data structure has representation with 
 ## @ifinfo
 ## @math{w = 2 * pi * nfreq}:
diff --git a/scripts/control/system/ss.m b/scripts/control/system/ss.m
--- a/scripts/control/system/ss.m
+++ b/scripts/control/system/ss.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{outsys} =} ss (@var{a}, @var{b}, @var{c}, @var{d}, @var{tsam}, @var{n}, @var{nz}, @var{stname}, @var{inname}, @var{outname}, @var{outlist})
-## Create system structure from state-space data.   May be continous,
+## Create system structure from state-space data.   May be continuous,
 ## discrete, or mixed (sampled data)
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item a
 ## @itemx b
 ## @itemx c
 ## @itemx d
@@ -66,17 +66,17 @@
 ##
 ## list of indices of outputs y that are sampled
 ##
 ## If @var{tsam} is 0, @math{outlist = []}.
 ##
 ## If @var{tsam} is greater than 0, @math{outlist = 1:@code{rows}(@var{c})}.
 ## @end table
 ##
-## Unlike states, discrete/continous outputs may appear in any order.
+## Unlike states, discrete/continuous outputs may appear in any order.
 ##
 ## @code{sys2ss} returns a vector @var{yd} where
 ## @var{yd}(@var{outlist}) = 1; all other entries of @var{yd} are 0.
 ##
 ## @strong{Output}
 ## @table @var
 ## @item outsys
 ## system data structure
diff --git a/scripts/control/system/ss2sys.m b/scripts/control/system/ss2sys.m
--- a/scripts/control/system/ss2sys.m
+++ b/scripts/control/system/ss2sys.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ss (@var{a}, @var{b}, @var{c}, @var{d}, @var{tsam}, @var{n}, @var{nz}, @var{stname}, @var{inname}, @var{outname}, @var{outlist})
-## Create system structure from state-space data.   May be continous,
+## Create system structure from state-space data.   May be continuous,
 ## discrete, or mixed (sampled data)
 ##
 ## @strong{Inputs}
 ## @table @var
 ## @item a
 ## @itemx b
 ## @itemx c
 ## @itemx d
@@ -66,17 +66,17 @@
 ##
 ## list of indices of outputs y that are sampled
 ##
 ## If @var{tsam} is 0, @math{outlist = []}.
 ##
 ## If @var{tsam} is greater than 0, @math{outlist = 1:@code{rows}(@var{c})}.
 ## @end table
 ##
-## Unlike states, discrete/continous outputs may appear in any order.
+## Unlike states, discrete/continuous outputs may appear in any order.
 ##
 ## @code{sys2ss} returns a vector @var{yd} where
 ## @var{yd}(@var{outlist}) = 1; all other entries of @var{yd} are 0.
 ##
 ## @strong{Outputs}
 ## @var{outsys} = system data structure
 ##
 ## @strong{System partitioning}
diff --git a/scripts/control/system/ss2tf.m b/scripts/control/system/ss2tf.m
--- a/scripts/control/system/ss2tf.m
+++ b/scripts/control/system/ss2tf.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{num}, @var{den}] =} ss2tf (@var{a}, @var{b}, @var{c}, @var{d})
-## Conversion from tranfer function to state-space.
+## Conversion from transfer function to state-space.
 ## The state space system:
 ## @iftex
 ## @tex
 ## $$ \dot x = Ax + Bu $$
 ## $$ y = Cx + Du $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
diff --git a/scripts/control/system/syscont.m b/scripts/control/system/syscont.m
--- a/scripts/control/system/syscont.m
+++ b/scripts/control/system/syscont.m
@@ -53,17 +53,17 @@ function [csys, Acd, Ccd] = syscont (sys
 
   sys = sysupdate (sys, "ss");
   [n_tot, st_c, st_d, y_c, y_d] = __syscont_disc__ (sys);        # get ranges
 
   ## assume there's nothing there; build partitions as appropriate
   Acc = Acd = Bcc = Ccc = Ccd = Dcc = [];
 
   if(isempty(st_c) & isempty(y_c))
-    error("syscont: expecting continous states and/or continous outputs");
+    error("syscont: expecting continuous states and/or continuous outputs");
   elseif (isempty(st_c))
     warning("syscont: no continuous states");
   elseif(isempty(y_c))
     warning("syscont: no continuous outputs");
   endif
 
   [sys_a, sys_b, sys_c, sys_d ] = sys2ss(sys);
   [sys_stname, sys_inname, sys_outname] = sysgetsignals(sys);
diff --git a/scripts/control/system/sysdimensions.m b/scripts/control/system/sysdimensions.m
--- a/scripts/control/system/sysdimensions.m
+++ b/scripts/control/system/sysdimensions.m
@@ -56,17 +56,17 @@
 ##  number of discrete states
 ## @item  m
 ##  number of system inputs
 ## @item  p
 ##  number of system outputs
 ## @item  yd
 ##  binary vector; @var{yd}(@var{ii}) is nonzero if output @var{ii} is
 ## discrete.
-## @math{yd(ii) = 0} if output @var{ii} is continous
+## @math{yd(ii) = 0} if output @var{ii} is continuous
 ## @end table
 ## @seealso{sysgetsignals, sysgettsam}
 ## @end deftypefn
 
 function [n, nz, m, p, yd] = sysdimensions (sys, opt)
 
   if(nargout > 5 | nargin < 1 | nargin > 2)
     print_usage ();
diff --git a/scripts/control/system/sysdisc.m b/scripts/control/system/sysdisc.m
--- a/scripts/control/system/sysdisc.m
+++ b/scripts/control/system/sysdisc.m
@@ -28,17 +28,17 @@
 ##
 ## @strong{Outputs}
 ## @table @var
 ## @item dsys
 ## Purely discrete portion of sys (returned empty if there is
 ## no purely discrete path from inputs to outputs).
 ## @item    adc
 ## @itemx   cdc
-## Connections from continuous states to discrete states and discrete.
+## Connections from continuous states to discrete states and discrete
 ## outputs, respectively.
 ## @end table
 ## @end deftypefn
 
 function [dsys, Adc, Cdc] = sysdisc (sys)
 
   if (nargin != 1)
     print_usage ();
@@ -48,17 +48,17 @@ function [dsys, Adc, Cdc] = sysdisc (sys
 
   sys = sysupdate (sys, "ss");
   [n_tot, st_c, st_d, y_c, y_d] = __syscont_disc__ (sys);        # get ranges
 
   ## assume there's nothing there; build partitions as appropriate
   Add = Adc = Bdd = Cdd = Cdc = Ddd = [];
 
   if(isempty(st_d) & isempty(y_d))
-    error("sysdisc: expecting discrete states and/or continous outputs");
+    error("sysdisc: expecting discrete states and/or continuous outputs");
   elseif (isempty(st_d))
     warning("sysdisc: no discrete states");
   elseif(isempty(y_d))
     warning("sysdisc: no discrete outputs");
   endif
 
   [aa,bb,cc,dd] = sys2ss(sys);
   if(!isempty(st_d) )
diff --git a/scripts/control/system/sysmult.m b/scripts/control/system/sysmult.m
--- a/scripts/control/system/sysmult.m
+++ b/scripts/control/system/sysmult.m
@@ -74,17 +74,17 @@ function sys = sysmult (varargin)
     [Ba,Bb,Bc,Bd,Btsam,Bn,Bnz,Bstname,Binname,Boutname,Byd] = sys2ss(Bsys);
 
     if(Byd)
       ## check direct feed-through of inputs through discrete outputs
       alist = find(Byd);
       if(An)
         bd = Ab(1:An)* Bd(alist,:);
         if(norm(bd,1))
-          warning("sysmult: inputs -> Bsys discrete outputs -> continous states of Asys");
+          warning("sysmult: inputs -> Bsys discrete outputs -> continuous states of Asys");
         endif
       endif
       ## check direct feed-through of continuous state through discrete outputs
       if(Bn)
         bc = Ab(1:An)* Bc(alist,1:(Bn));
         if( norm(bc,1) )
           warning("sysmult: Bsys states -> Bsys discrete outputs -> continuous states of Asys");
         endif
diff --git a/scripts/control/system/sysrepdemo.m b/scripts/control/system/sysrepdemo.m
--- a/scripts/control/system/sysrepdemo.m
+++ b/scripts/control/system/sysrepdemo.m
@@ -201,17 +201,17 @@ function sysrepdemo ()
               cmd = "D = [1, -1];";
               run_cmd
               disp("ss allows the initialization of signal and state names")
               disp("(see option 4), so we initialize these as follows:")
               cmd = "inname = {\"r(t)\",\"y(t)\"};";
               run_cmd;
               cmd = "outname = \"e(t)\";";
               run_cmd
-              disp("Since the system is continous time and without states,")
+              disp("Since the system is continuous time and without states,")
               disp("the ss inputs tsam, n, and nz are all zero:")
               cmd = "sys = ss([],[],[],D,0,0,0,[],inname,outname);";
               run_cmd
               disp("The resulting system is:")
               cmd = "sysout(sys)";
               run_cmd
               disp("A discrete-time summing block can be implemented by setting")
               disp("the sampling time positive:")
diff --git a/scripts/control/system/tf2ss.m b/scripts/control/system/tf2ss.m
--- a/scripts/control/system/tf2ss.m
+++ b/scripts/control/system/tf2ss.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301 USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{a}, @var{b}, @var{c}, @var{d}] =} tf2ss (@var{num}, @var{den})
-## Conversion from tranfer function to state-space.
+## Conversion from transfer function to state-space.
 ## The state space system:
 ## @iftex
 ## @tex
 ## $$ \dot x = Ax + Bu $$
 ## $$ y = Cx + Du $$
 ## @end tex
 ## @end iftex
 ## @ifinfo
diff --git a/scripts/elfun/lcm.m b/scripts/elfun/lcm.m
--- a/scripts/elfun/lcm.m
+++ b/scripts/elfun/lcm.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Mapping Function} {} lcm (@var{x}, @dots{})
-## Compute the least common multiple of the elements elements of @var{x}, or
+## Compute the least common multiple of the elements of @var{x}, or
 ## the list of all the arguments.  For example,
 ##
 ## @example
 ## lcm (a1, ..., ak)
 ## @end example
 ##
 ## @noindent
 ## is the same as
diff --git a/scripts/finance/fv.m b/scripts/finance/fv.m
--- a/scripts/finance/fv.m
+++ b/scripts/finance/fv.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {} fv (@var{r}, @var{n}, @var{p}, @var{l}, @var{method})
 ## Return the future value at the end of period @var{n} of an investment
 ## which consists of @var{n} payments of @var{p} in each period,
 ## assuming an interest rate @var{r}.
 ##
 ## The optional argument @var{l} may be used to specify an
 ## additional lump-sum payment.
 ##
-## The optional argument @var{method} may be used ot specify whether the
+## The optional argument @var{method} may be used to specify whether the
 ## payments are made at the end (@code{"e"}, default) or at the
 ## beginning (@code{"b"}) of each period.
 ##
 ## Note that the rate @var{r} is specified as a fraction (i.e., 0.05,
 ## not 5 percent).
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
diff --git a/scripts/general/cumtrapz.m b/scripts/general/cumtrapz.m
--- a/scripts/general/cumtrapz.m
+++ b/scripts/general/cumtrapz.m
@@ -17,21 +17,21 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{z} =} cumtrapz (@var{y})
 ## @deftypefnx {Function File} {@var{z} =} cumtrapz (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{z} =} cumtrapz (@dots{}, @var{dim})
 ## 
-## Cumulative numerical intergration using trapezodial method.
-## @code{cumtrapz (@var{y})} computes the cummulative integral of the 
+## Cumulative numerical integration using trapezoidal method.
+## @code{cumtrapz (@var{y})} computes the cumulative integral of the 
 ## @var{y} along the first non singleton dimension. If the argument 
 ## @var{x} is omitted a equally spaced vector is assumed. @code{cumtrapz 
-## (@var{x}, @var{y})} evaluates the cummulative integral with respect 
+## (@var{x}, @var{y})} evaluates the cumulative integral with respect 
 ## to @var{x}.
 ##  
 ## @seealso{trapz,cumsum}
 ## @end deftypefn
 
 ## Author:	Kai Habel <kai.habel@gmx.de>
 ##
 ## also: June 2000 Paul Kienzle (fixes,suggestions) 
diff --git a/scripts/general/gradient.m b/scripts/general/gradient.m
--- a/scripts/general/gradient.m
+++ b/scripts/general/gradient.m
@@ -29,17 +29,17 @@
 ##
 ## @code{[@var{x}, @var{y}] = gradient (@var{M})} calculates the one
 ## dimensional gradient for each direction if @var{M} if @var{M} is a
 ## matrix. Additional return arguments can be use for multi-dimensional
 ## matrices.
 ##
 ## Spacing values between two points can be provided by the
 ## @var{dx}, @var{dy} or @var{h} parameters. If @var{h} is supplied it
-## is assumed to be the spacing in all directions. Otherwise, seperate
+## is assumed to be the spacing in all directions. Otherwise, separate
 ## values of the spacing can be supplied by the @var{dx}, etc variables.
 ## A scalar value specifies an equidistant spacing, while a vector value
 ## can be used to specify a variable spacing. The length must match
 ## their respective dimension of @var{M}.
 ## 
 ## At boundary points a linear extrapolation is applied. Interior points
 ## are calculated with the first approximation of the numerical gradient
 ##
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {@var{yi} =} interp1 (@var{x}, @var{y}, @var{xi})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@dots{}, @var{extrap})
 ## @deftypefnx {Function File} {@var{pp} =} interp1 (@dots{}, 'pp')
 ##
 ## One-dimensional interpolation. Interpolate @var{y}, defined at the
 ## points @var{x}, at the points @var{xi}. The sample points @var{x} 
 ## must be strictly monotonic. If @var{y} is an array, treat the columns
-## of @var{y} seperately.
+## of @var{y} separately.
 ##
 ## Method is one of:
 ##
 ## @table @asis
 ## @item 'nearest'
 ## Return the nearest neighbour.
 ## @item 'linear'
 ## Linear interpolation from nearest neighbours
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -39,17 +39,17 @@
 ## be specified. The method can be 'linear', 'nearest' or 'cubic'.
 ## If it is omitted 'linear' interpolation  is assumed.
 ##
 ## @item  interp2 (@var{z}, @var{xi}, @var{yi})
 ## Assumes @code{@var{x} = 1:rows (@var{z})} and @code{@var{y} = 
 ## 1:columns (@var{z})}
 ## 
 ## @item interp2 (@var{z}, @var{n}) 
-## Interleaves the Matrix @var{z} n-times. If @var{n} is ommited a value
+## Interleaves the Matrix @var{z} n-times. If @var{n} is omitted a value
 ## of @code{@var{n} = 1} is assumed.
 ## @end table
 ##
 ## The variable @var{method} defines the method to use for the
 ## interpolation. It can take one of the values
 ##
 ## @table @asis
 ## @item 'nearest'
diff --git a/scripts/general/interp3.m b/scripts/general/interp3.m
--- a/scripts/general/interp3.m
+++ b/scripts/general/interp3.m
@@ -28,20 +28,20 @@
 ## Perform 3-dimensional interpolation. Each element of then 3-dimensional 
 ## array @var{v} represents a value at a location given by the parameters 
 ## @var{x}, @var{y}, and @var{z}. The parameters @var{x}, @var{x}, and 
 ## @var{z} are either 3-dimensional arrays of the same size as the array 
 ## @var{v} in the 'meshgrid' format or vectors. The parameters @var{xi}, etc 
 ## respect a similar format to @var{x}, etc, and they represent the points 
 ## at which the array @var{vi} is interpolated.
 ##
-## If @var{x}, @var{y}, @var{z} are ommitted, they are assumed to be 
+## If @var{x}, @var{y}, @var{z} are omitted, they are assumed to be 
 ## @code{x = 1 : size (@var{v}, 2)}, @code{y = 1 : size (@var{v}, 1)} and
 ## @code{z = 1 : size (@var{v}, 3)}. If @var{m} is specified, then
-## the interpolation adds a point half way between each of the interplation 
+## the interpolation adds a point half way between each of the interpolation 
 ## points. This process is performed @var{m} times. If only @var{v} is 
 ## specified, then @var{m} is assumed to be @code{1}.
 ##
 ## Method is one of:
 ##
 ## @table @asis
 ## @item 'nearest'
 ## Return the nearest neighbour.
diff --git a/scripts/general/interpft.m b/scripts/general/interpft.m
--- a/scripts/general/interpft.m
+++ b/scripts/general/interpft.m
@@ -19,21 +19,21 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} interpft (@var{x}, @var{n})
 ## @deftypefnx {Function File} {} interpft (@var{x}, @var{n}, @var{dim})
 ##
 ## Fourier interpolation. If @var{x} is a vector, then @var{x} is
 ## resampled with @var{n} points. The data in @var{x} is assumed to be
 ## equispaced. If @var{x} is an array, then operate along each column of
-## the array seperately. If @var{dim} is specified, then interpolate
+## the array separately. If @var{dim} is specified, then interpolate
 ## along the dimension @var{dim}.
 ##
 ## @code{interpft} assumes that the interpolated function is periodic,
-## and so assumption are made about the end points of the inetrpolation.
+## and so assumptions are made about the end points of the interpolation.
 ##
 ## @seealso{interp1}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ## 2001-02-11
 ##    * initial version
 ## 2002-03-17 aadler
diff --git a/scripts/general/interpn.m b/scripts/general/interpn.m
--- a/scripts/general/interpn.m
+++ b/scripts/general/interpn.m
@@ -29,19 +29,19 @@
 ## Each element of then @var{n}-dimensional array @var{v} represents a value 
 ## at a location given by the parameters @var{x1}, @var{x2}, @dots{}, @var{xn}. 
 ## The parameters @var{x1}, @var{x2}, @dots{}, @var{xn} are either 
 ## @var{n}-dimensional arrays of the same size as the array @var{v} in 
 ## the 'ndgrid' format or vectors. The parameters @var{y1}, etc respect a 
 ## similar format to @var{x1}, etc, and they represent the points at which
 ## the array @var{vi} is interpolated.
 ##
-## If @var{x1}, @dots{}, @var{xn} are ommitted, they are assumed to be 
+## If @var{x1}, @dots{}, @var{xn} are omitted, they are assumed to be 
 ## @code{x1 = 1 : size (@var{v}, 1)}, etc. If @var{m} is specified, then
-## the interpolation adds a point half way between each of the interplation 
+## the interpolation adds a point half way between each of the interpolation 
 ## points. This process is performed @var{m} times. If only @var{v} is 
 ## specified, then @var{m} is assumed to be @code{1}.
 ##
 ## Method is one of:
 ##
 ## @table @asis
 ## @item 'nearest'
 ## Return the nearest neighbour.
diff --git a/scripts/general/polyarea.m b/scripts/general/polyarea.m
--- a/scripts/general/polyarea.m
+++ b/scripts/general/polyarea.m
@@ -18,18 +18,18 @@
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} polyarea (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} polyarea (@var{x}, @var{y}, @var{dim})
 ##
 ## Determines area of a polygon by triangle method. The variables
 ## @var{x} and @var{y} define the vertex pairs, and must therefore have
-## the same shape. Then might be either vectors or arrays. If they are
-## arrays then the columns of @var{x} and @var{y} are treated seperately
+## the same shape. They can be either vectors or arrays. If they are
+## arrays then the columns of @var{x} and @var{y} are treated separately
 ## and an area returned for each.
 ##
 ## If the optional @var{dim} argument is given, then @code{polyarea}
 ## works along this dimension of the arrays @var{x} and @var{y}.
 ##
 ## @end deftypefn
 
 ## todo:  Add moments for centroid, etc.
diff --git a/scripts/general/rat.m b/scripts/general/rat.m
--- a/scripts/general/rat.m
+++ b/scripts/general/rat.m
@@ -24,17 +24,17 @@
 ## Find a rational approximation to @var{x} within tolerance defined
 ## by @var{tol} using a continued fraction expansion. E.g,
 ##
 ## @example
 ##    rat(pi) = 3 + 1/(7 + 1/16) = 355/113
 ##    rat(e) = 3 + 1/(-4 + 1/(2 + 1/(5 + 1/(-2 + 1/(-7))))) = 1457/536
 ## @end example
 ##
-## Called with two arguments returns the numerator and deniminator seperately
+## Called with two arguments returns the numerator and denominator separately
 ## as two matrices.
 ## @end deftypefn
 ## @seealso{rats}
 
 function [n,d] = rat(x,tol)
 
   if (nargin != [1,2] || nargout > 2)
     print_usage ();
diff --git a/scripts/general/structfun.m b/scripts/general/structfun.m
--- a/scripts/general/structfun.m
+++ b/scripts/general/structfun.m
@@ -19,17 +19,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} structfun (@var{func}, @var{s})
 ## @deftypefnx {Function File} {[@var{a}, @var{b}] =} structfun (@dots{})
 ## @deftypefnx {Function File} {} structfun (@dots{}, 'ErrorHandler', @var{errfunc})
 ## @deftypefnx {Function File} {} structfun (@dots{}, 'UniformOutput', @var{val})
 ## 
 ## Evaluate the function named @var{name} on the fields of the structure
-## @var{s}. The fields of @var{s} are passed the the function @var{func}
+## @var{s}. The fields of @var{s} are passed to the function @var{func}
 ## individually.
 ##
 ## @code{structfun} accepts an arbitrary function @var{func} in the form of 
 ## an inline function, function handle, or the name of a function (in a 
 ## character string). In the case of a character string argument, the 
 ## function must accept a single argument named @var{x}, and it must return 
 ## a string value. If the function returns more than one argument, they are
 ## returned as separate output variables.
diff --git a/scripts/general/trapz.m b/scripts/general/trapz.m
--- a/scripts/general/trapz.m
+++ b/scripts/general/trapz.m
@@ -17,17 +17,17 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{z} =} trapz (@var{y})
 ## @deftypefnx {Function File} {@var{z} =} trapz (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{z} =} trapz (@dots{}, @var{dim})
 ## 
-## Numerical intergration using trapezodial method. @code{trapz
+## Numerical integration using trapezoidal method. @code{trapz
 ## (@var{y})} computes the integral of the @var{y} along the first
 ## non singleton dimension. If the argument @var{x} is omitted a 
 ## equally spaced vector is assumed. @code{trapz (@var{x}, @var{y})} 
 ## evaluates the integral with respect to @var{x}.
 ##  
 ## @seealso{cumtrapz}
 ## @end deftypefn
 
diff --git a/scripts/geometry/tsearchn.m b/scripts/geometry/tsearchn.m
--- a/scripts/geometry/tsearchn.m
+++ b/scripts/geometry/tsearchn.m
@@ -17,17 +17,17 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{idx}, @var{p}] =} tsearchn (@var{x}, @var{t}, @var{xi})
 ## Searches for the enclosing Delaunay convex hull. For @code{@var{t} =
 ## delaunayn (@var{x})}, finds the index in @var{t} containing the
 ## points @var{xi}. For points outside the convex hull, @var{idx} is NaN.
-## If requested @code{tsearchn} also returns the barycentric coorinates @var{p}
+## If requested @code{tsearchn} also returns the barycentric coordinates @var{p}
 ## of the enclosing triangles.
 ## @seealso{delaunay, delaunayn}
 ## @end deftypefn
 
 function [idx, p] = tsearchn (x, t, xi)
   if (nargin != 3)
     print_usage ();
   endif
diff --git a/scripts/image/rgb2hsv.m b/scripts/image/rgb2hsv.m
--- a/scripts/image/rgb2hsv.m
+++ b/scripts/image/rgb2hsv.m
@@ -20,17 +20,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{hsv_map} =} rgb2hsv (@var{rgb_map})
 ## Transform a colormap from the rgb space to the hsv space.
 ##
 ## A color n the RGB space consists of the red, green and blue intensities.
 ##
 ## In the HSV space each color is represented by their hue, saturation
 ## and value (brightness).  Value gives the amount of light in the color.
-## Hue describes the dominant wavelegth. 
+## Hue describes the dominant wavelength. 
 ## Saturation is the amount of Hue mixed into the color.
 ## @seealso{hsv2rgb}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function hsval = rgb2hsv (rgb)
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -30,17 +30,17 @@
 ##
 ## If @var{v} is a vector, then @var{h} contains the Hessenberg matrix
 ## such that @code{a*u == u*h}.  Otherwise, @var{h} is meaningless.
 ##
 ## The value of @var{nu} is the dimension of the span of the krylov
 ## subspace (based on @var{eps1}).
 ##
 ## If @var{b} is a vector and @var{k} is greater than @var{m-1}, then
-## @var{h} contains the Hessenberg decompostion of @var{a}.
+## @var{h} contains the Hessenberg decomposition of @var{a}.
 ##
 ## The optional parameter @var{eps1} is the threshold for zero.  The
 ## default value is 1e-12.
 ##
 ## If the optional parameter @var{pflg} is nonzero, row pivoting is used
 ## to improve numerical behavior.  The default value is 0.
 ##
 ## Reference: Hodel and Misra, "Partial Pivoting in the Computation of
diff --git a/scripts/miscellaneous/ans.m b/scripts/miscellaneous/ans.m
--- a/scripts/miscellaneous/ans.m
+++ b/scripts/miscellaneous/ans.m
@@ -1,11 +1,11 @@
 ## -*- texinfo -*-
 ## @defvr {Automatic Variable} ans
-## The the most recently computed result that was not
+## The most recently computed result that was not
 ## explicitly assigned to a variable.  For example, after the expression
 ## 
 ## @example
 ## 3^2 + 4^2
 ## @end example
 ## 
 ## @noindent
 ## is evaluated, the value returned by @code{ans} is 25.
diff --git a/scripts/miscellaneous/gzip.m b/scripts/miscellaneous/gzip.m
--- a/scripts/miscellaneous/gzip.m
+++ b/scripts/miscellaneous/gzip.m
@@ -17,17 +17,17 @@
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{entries} =} gzip (@var{files})
 ## @deftypefnx {Function File} {@var{entries} =} gzip (@var{files}, @var{outdir})
 ## Compress the list of files and/or directories specified in @var{files}.
 ## Each file is compressed separately and a new file with a '.gz' extension
-## is create. The original file is not touch. If @var{rootdir} is defined 
+## is created. The original file is not touched. If @var{rootdir} is defined 
 ## the compressed versions of the files are placed in this directory.
 ## @seealso{gunzip, zip, tar}
 ## @end deftypefn
 
 function entries = gzip (files, outdir)
 
   if (nargin == 1 || nargin == 2)
 
diff --git a/scripts/optimization/glpk.m b/scripts/optimization/glpk.m
--- a/scripts/optimization/glpk.m
+++ b/scripts/optimization/glpk.m
@@ -163,19 +163,19 @@
 ## @item 3
 ## Full output (includes informational messages).
 ## @end table
 ## 
 ## @item scale (@code{LPX_K_SCALE}, default: 1)
 ## Scaling option: 
 ## @table @asis
 ## @item 0
-## No scaling .
+## No scaling.
 ## @item 1
-## Equilibration scaling .
+## Equilibration scaling.
 ## @item 2
 ## Geometric mean scaling, then equilibration scaling.
 ## @end table
 ## 
 ## @item dual	 (@code{LPX_K_DUAL}, default: 0)
 ## Dual simplex option:
 ## @table @asis
 ## @item 0
@@ -244,17 +244,17 @@
 ## will be ignored.
 ## @table @asis
 ## @item 1
 ## Revised simplex method.
 ## @item 2
 ## Interior point method.
 ## @end table
 ## @item save (default: 0)
-## If this parameter is nonzero, save a copy of the problem problem in
+## If this parameter is nonzero, save a copy of the problem in
 ## CPLEX LP format to the file @file{"outpb.lp"}.  There is currently no
 ## way to change the name of the output file.
 ## @end table
 ## 
 ## Real parameters:
 ## 
 ## @table @code
 ## @item relax (@code{LPX_K_RELAX}, default: 0.07)
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -51,17 +51,17 @@
 ## @end example
 ## @end ifnottex
 ##
 ## @noindent
 ## using a successive quadratic programming method.
 ##
 ## The first argument is the initial guess for the vector @var{x}.
 ##
-## The second argument is a function handle pointing to the ojective
+## The second argument is a function handle pointing to the objective
 ## function.  The objective function must be of the form
 ##
 ## @example
 ##      y = phi (x)
 ## @end example
 ##
 ## @noindent
 ## in which @var{x} is a vector and @var{y} is a scalar.
@@ -703,9 +703,9 @@ function res = cigrad_ub_lb (x)
   if (iscell (__sqp_cif__) && length (__sqp_cif__) > 1)
     cigradfcn = __sqp_cif__{2};
   endif
 	
   if (! isempty (cigradfcn))
     res = [feval(cigradfcn,x); eye(numel(x)); -eye(numel(x))];
   endif
 
-### endfunction
\ No newline at end of file
+### endfunction
diff --git a/scripts/plot/findobj.m b/scripts/plot/findobj.m
--- a/scripts/plot/findobj.m
+++ b/scripts/plot/findobj.m
@@ -18,17 +18,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{h} =} findobj ()
 ## @deftypefnx {Function File} {@var{h} =} findobj (@var{propName}, @var{propValue})
 ## @deftypefnx {Function File} {@var{h} =} findobj ('-property', @var{propName})
 ## @deftypefnx {Function File} {@var{h} =} findobj ('-regexp', @var{propName},, @var{pattern})
 ## @deftypefnx {Function File} {@var{h} =} findobj ('flat', @dots{})
 ## @deftypefnx {Function File} {@var{h} =} findobj (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} findobj (@var{h}, '-depth', @var{d}, @dots{})
-## Find object with specified property values. The simpliest form is
+## Find object with specified property values. The simplest form is
 ##
 ## @example
 ## findobj (@var{propName}, @var{propValue})
 ## @end example
 ##
 ## @noindent
 ## which returns all of the handles to the objects with the name 
 ## @var{propName} and the name @var{propValue}. The search can be limited
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -53,17 +53,17 @@
 ##   right bottom
 ## @item @tab southwest @tab
 ##   left bottom
 ## @item 
 ## @item @tab outside @tab
 ##   can be appended to any location string
 ## @end multitable
 ##
-## Some specific functions are directely avaliable using @var{func}:
+## Some specific functions are directly available using @var{func}:
 ##
 ## @table @code
 ## @item "show"
 ##   Show legends from the plot
 ## @item "hide"
 ## @itemx off
 ##   Hide legends from the plot
 ## @item "boxon"
diff --git a/scripts/plot/peaks.m b/scripts/plot/peaks.m
--- a/scripts/plot/peaks.m
+++ b/scripts/plot/peaks.m
@@ -36,17 +36,17 @@
 ## f(x,y) = 3*(1-x)^2*exp(-x^2 - (y+1)^2) ...
 ##          - 10*(x/5 - x^3 - y^5)*exp(-x^2-y^2) ...
 ##          - 1/3*exp(-(x+1)^2 - y^2)
 ## @end verbatim
 ## @end ifnottex
 ##
 ## Called without a return argument, @code{peaks} plots the surface of the 
 ## above function using @code{mesh}. If @var{n} is a scalar, the @code{peaks}
-## returns the values of the above funxtion on a @var{n}-by-@var{n} mesh over
+## returns the values of the above function on a @var{n}-by-@var{n} mesh over
 ## the range @code{[-3,3]}. The default value for @var{n} is 49.
 ##
 ## If @var{n} is a vector, then it represents the @var{x} and @var{y} values
 ## of the grid on which to calculate the above function. The @var{x} and 
 ## @var{y} values can be specified separately.
 ## @seealso{mesh}
 ## @end deftypefn
 
diff --git a/scripts/plot/plot3.m b/scripts/plot/plot3.m
--- a/scripts/plot/plot3.m
+++ b/scripts/plot/plot3.m
@@ -26,17 +26,17 @@
 ## plot3 (@var{x}, @var{y}, @var{z})
 ## @end example
 ##
 ## @noindent
 ## in which the arguments are taken to be the vertices of the points to
 ## be plotted in three dimensions. If all arguments are vectors of the
 ## same length, then a single continuous line is drawn. If all arguments
 ## are matrices, then each column of the matrices is treated as a
-## seperate line.  No attempt is made to transpose the arguments to make
+## separate line.  No attempt is made to transpose the arguments to make
 ## the number of rows match.
 ##
 ## If only two arguments are given, as
 ##
 ## @example
 ## plot3 (@var{x}, @var{c})
 ## @end example
 ##
@@ -56,17 +56,17 @@
 ##
 ## Arguments may also be given in groups of three as
 ##
 ## @example
 ## plot3 (@var{x1}, @var{y1}, @var{z1}, @var{x2}, @var{y2}, @var{z2}, @dots{})
 ## @end example
 ## 
 ## @noindent
-## in which each set of three arguments is treated as a seperate line or
+## in which each set of three arguments is treated as a separate line or
 ## set of lines in three dimensions.
 ##
 ## To plot multiple one- or two-argument groups, separate each group
 ## with an empty format string, as
 ##
 ## @example
 ## plot3 (@var{x1}, @var{c1}, "", @var{c2}, "", @dots{})
 ## @end example
diff --git a/scripts/plot/stem.m b/scripts/plot/stem.m
--- a/scripts/plot/stem.m
+++ b/scripts/plot/stem.m
@@ -43,29 +43,29 @@
 ## @example
 ## x = 1:10;
 ## y = ones (size (x))*2.*x;
 ## h = stem (x, y, "b");
 ## @end example
 ## @noindent
 ## plots 10 bars with heights from 2 to 20
 ## (the color is blue, and @var{h} is a 2-by-10 array of handles in
-## which the first row holds the line handles and the 
+## which the first row holds the line handles and
 ## the second row holds the marker handles);
 ##
 ## @example
 ## x = 1:10;
 ## y = ones (size (x))*2.*x;
 ## h = stem (x, y, "-.k");
 ## @end example
 ## @noindent
 ## plots 10 stems with heights from 2 to 20
 ## (the color is black, line style is @code{"-."}, and @var{h} is a 2-by-10
 ## array of handles in which the first row holds the line handles and
-## the second rows holds the marker handles);
+## the second row holds the marker handles);
 ##
 ## @example
 ## x = 1:10;
 ## y = ones (size (x))*2.*x;
 ## h = stem (x, y, "-.k.");
 ## @end example
 ## @noindent
 ## plots 10 stems with heights from 2 to 20
diff --git a/scripts/polynomial/deconv.m b/scripts/polynomial/deconv.m
--- a/scripts/polynomial/deconv.m
+++ b/scripts/polynomial/deconv.m
@@ -21,17 +21,17 @@
 ## @deftypefn {Function File} {} deconv (@var{y}, @var{a})
 ## Deconvolve two vectors.
 ##
 ## @code{[b, r] = deconv (y, a)} solves for @var{b} and @var{r} such that
 ## @code{y = conv (a, b) + r}.
 ##
 ## If @var{y} and @var{a} are polynomial coefficient vectors, @var{b} will
 ## contain the coefficients of the polynomial quotient and @var{r} will be
-## a remander polynomial of lowest order.
+## a remainder polynomial of lowest order.
 ## @seealso{conv, poly, roots, residue, polyval, polyderiv, polyinteg}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
 
 function [b, r] = deconv (y, a)
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -34,29 +34,29 @@
 ## @iftex
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n]$$
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n}]}
 ## @end ifinfo
-## The array is then reshaped internally to a matrix where to leading
+## The array is then reshaped internally to a matrix where the leading
 ## dimension is given by 
 ## @iftex
 ## @tex
 ## $$s_1 s_2 \cdots s_k$$
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## @code{@var{s1} * @var{s2} * @dots{} * @var{sk}}
 ## @end ifinfo
-## and each row this matrix is then treated seperately. Note that this
+## and each row in this matrix is then treated separately. Note that this
 ## is exactly the opposite treatment than @code{interp1} and is done
-## for compatiability.
+## for compatibility.
 ##
 ## Called with a third input argument, @code{pchip} evaluates the 
 ## piece-wise polynomial at the points @var{xi}. There is an equivalence
 ## between @code{ppval (pchip (@var{x}, @var{y}), @var{xi})} and
 ## @code{pchip (@var{x}, @var{y}, @var{xi})}.
 ##
 ## @seealso{spline, ppval, mkpp, unmkpp}
 ## @end deftypefn
diff --git a/scripts/polynomial/spline.m b/scripts/polynomial/spline.m
--- a/scripts/polynomial/spline.m
+++ b/scripts/polynomial/spline.m
@@ -58,19 +58,19 @@
 ## @iftex
 ## @tex
 ## $$s_1 s_2 \cdots s_k$$
 ## @end tex
 ## @end iftex
 ## @ifinfo
 ## @code{@var{s1} * @var{s2} * @dots{} * @var{sk}}
 ## @end ifinfo
-## and each row this matrix is then treated seperately. Note that this
+## and each row this matrix is then treated separately. Note that this
 ## is exactly the opposite treatment than @code{interp1} and is done
-## for compatiability.
+## for compatibility.
 ##
 ## Called with a third input argument, @code{spline} evaluates the 
 ## piece-wise spline at the points @var{xi}. There is an equivalence
 ## between @code{ppval (spline (@var{x}, @var{y}), @var{xi})} and
 ## @code{spline (@var{x}, @var{y}, @var{xi})}.
 ##
 ## @seealso{ppval, mkpp, unmkpp}
 ## @end deftypefn
diff --git a/scripts/polynomial/unmkpp.m b/scripts/polynomial/unmkpp.m
--- a/scripts/polynomial/unmkpp.m
+++ b/scripts/polynomial/unmkpp.m
@@ -25,17 +25,17 @@
 ##
 ## @table @asis
 ## @item @var{x}
 ## Samples points.
 ## @item @var{p}
 ## Polynomial coefficients for points in sample interval. @code{@var{p}
 ## (@var{i}, :)} contains the coefficients for the polynomial over
 ## interval @var{i} ordered from highest to lowest. If @code{@var{d} >
-## 1}, @code{@var{p} (@var{r}, @var{i}, :)} contains the coeffients for 
+## 1}, @code{@var{p} (@var{r}, @var{i}, :)} contains the coefficients for 
 ## the r-th polynomial defined on interval @var{i}. However, this is 
 ## stored as a 2-D array such that @code{@var{c} = reshape (@var{p} (:,
 ## @var{j}), @var{n}, @var{d})} gives @code{@var{c} (@var{i},  @var{r})}
 ## is the j-th coefficient of the r-th polynomial over the i-th interval.
 ## @item @var{n}
 ## Number of polynomial pieces.
 ## @item @var{k}
 ## Order of the polynomial plus 1.
diff --git a/scripts/sparse/pcr.m b/scripts/sparse/pcr.m
--- a/scripts/sparse/pcr.m
+++ b/scripts/sparse/pcr.m
@@ -87,17 +87,17 @@
 ## measured in the Euclidean norm.
 ## 
 ## @item
 ## @var{iter} is the actual number of iterations performed.
 ##
 ## @item 
 ## @var{resvec} describes the convergence history of the method,
 ## so that @code{@var{resvec} (i)} contains the Euclidean norms of the 
-## residualafter the (@var{i}-1)-th iteration, @code{@var{i} =
+## residual after the (@var{i}-1)-th iteration, @code{@var{i} =
 ## 1,2, @dots{}, @var{iter}+1}.
 ## @end itemize
 ## 
 ## Let us consider a trivial problem with a diagonal matrix (we exploit the
 ## sparsity of A) 
 ## 
 ## @example
 ## @group
@@ -286,17 +286,17 @@ function [x, flag, relres, iter, resvec]
     fprintf (stderr, "pcr: converged in %d iterations. \n", iter);
     fprintf (stderr, "the initial residual norm was reduced %g times.\n",
 	     1.0/relres);
   endif
 
   if (breakdown)
     flag = 3;
     if (nargout < 2)
-      warning ("pcr: breakdown occured:\n");
+      warning ("pcr: breakdown occurred:\n");
       warning ("system matrix singular or preconditioner indefinite?\n");
     endif
   endif
 
 endfunction
 
 %!demo
 %!
diff --git a/scripts/sparse/spalloc.m b/scripts/sparse/spalloc.m
--- a/scripts/sparse/spalloc.m
+++ b/scripts/sparse/spalloc.m
@@ -15,17 +15,17 @@
 ## Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301  USA
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{s} =} spalloc (@var{r}, @var{c}, @var{nz})
 ## Returns an empty sparse matrix of size @var{r}-by-@var{c}. As Octave
 ## resizes sparse matrices at the first opportunity, so that no additional 
 ## space is needed, the argument @var{nz} is ignored. This function is 
-## provided only for compatiability reasons.
+## provided only for compatibility reasons.
 ##
 ## It should be noted that this means that code like
 ##
 ## @example
 ## k = 5;
 ## nz = r * k;
 ## s = spalloc (r, c, nz)
 ## for j = 1:c
diff --git a/scripts/sparse/spconvert.m b/scripts/sparse/spconvert.m
--- a/scripts/sparse/spconvert.m
+++ b/scripts/sparse/spconvert.m
@@ -16,17 +16,17 @@
 ## 02110-1301  USA
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{x} =} spconvert (@var{m})
 ## This function converts for a simple sparse matrix format easily
 ## produced by other programs into Octave's internal sparse format. The
 ## input @var{x} is either a 3 or 4 column real matrix, containing
 ## the row, column, real and imaginary parts of the elements of the
-## sparse matrix. An element with a zero real and imaginay part can
+## sparse matrix. An element with a zero real and imaginary part can
 ## be used to force a particular matrix size.
 ## @end deftypefn
 
 function s = spconvert (m)
 
   if (issparse (m))
     s = m;
   else
diff --git a/scripts/specfun/factor.m b/scripts/specfun/factor.m
--- a/scripts/specfun/factor.m
+++ b/scripts/specfun/factor.m
@@ -19,18 +19,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{p} =} factor (@var{q})
 ## @deftypefnx {Function File} {[@var{p}, @var{n}] =} factor (@var{q})
 ##
 ## Return prime factorization of @var{q}. That is @code{prod (@var{p})
 ## == @var{q}}. If @code{@var{q} == 1}, returns 1. 
 ##
-## With two output arguments, returns the uniques primes @var{p} and
-## their mulyiplicities. That is @code{prod (@var{p} .^ @var{n}) ==
+## With two output arguments, returns the unique primes @var{p} and
+## their multiplicities. That is @code{prod (@var{p} .^ @var{n}) ==
 ## @var{q}}.
 ## 
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 
 ## 2002-01-28 Paul Kienzle
 ## * remove recursion; only check existing primes for multiplicity > 1
diff --git a/scripts/specfun/legendre.m b/scripts/specfun/legendre.m
--- a/scripts/specfun/legendre.m
+++ b/scripts/specfun/legendre.m
@@ -30,17 +30,17 @@
 ##
 ## @group
 ##  m        m       2  m/2   d^m
 ## P(x) = (-1) * (1-x  )    * ----  P (x)
 ##  n                         dx^m   n
 ## @end group
 ##
 ## with:
-## Legendre Polynom of degree n
+## Legendre polynomial of degree n
 ##
 ## @group
 ##           1     d^n   2    n
 ## P (x) = ------ [----(x - 1)  ] 
 ##  n      2^n n!  dx^n
 ## @end group
 ##
 ## legendre(3,[-1.0 -0.9 -0.8]) returns the matrix
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/base/mean.m
--- a/scripts/statistics/base/mean.m
+++ b/scripts/statistics/base/mean.m
@@ -37,17 +37,17 @@
 ## With the optional argument @var{opt}, the kind of mean computed can be
 ## selected.  The following options are recognized:
 ##
 ## @table @code
 ## @item "a"
 ## Compute the (ordinary) arithmetic mean.  This is the default.
 ##
 ## @item "g"
-## Computer the geometric mean.
+## Compute the geometric mean.
 ##
 ## @item "h"
 ## Compute the harmonic mean.
 ## @end table
 ##
 ## If the optional argument @var{dim} is supplied, work along dimension
 ## @var{dim}.
 ##
diff --git a/scripts/statistics/base/meansq.m b/scripts/statistics/base/meansq.m
--- a/scripts/statistics/base/meansq.m
+++ b/scripts/statistics/base/meansq.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} meansq (@var{x})
 ## @deftypefnx {Function File} {} meansq (@var{x}, @var{dim})
 ## For vector arguments, return the mean square of the values.
-## For matrix arguments, return a row vector contaning the mean square
+## For matrix arguments, return a row vector containing the mean square
 ## of each column. With the optional @var{dim} argument, returns the
 ## mean squared of the values along this dimension.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compute mean square
 
 function y = meansq (x, varargin)
diff --git a/scripts/statistics/base/var.m b/scripts/statistics/base/var.m
--- a/scripts/statistics/base/var.m
+++ b/scripts/statistics/base/var.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} var (@var{x})
 ## For vector arguments, return the (real) variance of the values.
-## For matrix arguments, return a row vector contaning the variance for
+## For matrix arguments, return a row vector containing the variance for
 ## each column.
 ##
 ## The argument @var{opt} determines the type of normalization to use.
 ## Valid values are
 ##
 ## @table @asis 
 ## @item 0:
 ## Normalizes with @math{N-1}, provides the best unbiased estimator of the
diff --git a/scripts/statistics/tests/chisquare_test_independence.m b/scripts/statistics/tests/chisquare_test_independence.m
--- a/scripts/statistics/tests/chisquare_test_independence.m
+++ b/scripts/statistics/tests/chisquare_test_independence.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{pval}, @var{chisq}, @var{df}] =} chisquare_test_independence (@var{x})
-## Perform a chi-square test for indepence based on the contingency
+## Perform a chi-square test for independence based on the contingency
 ## table @var{x}.  Under the null hypothesis of independence,
 ## @var{chisq} approximately has a chi-square distribution with
 ## @var{df} degrees of freedom.
 ##
 ## The p-value (1 minus the CDF of this distribution at chisq) of the
 ## test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value is displayed.
@@ -46,9 +46,9 @@ function [pval, chisq, df] = chisquare_t
   X = (X - Y) .^2 ./ Y;
   chisq = sum (sum (X));
   pval  = 1 - chisquare_cdf (chisq, df);
 
   if (nargout == 0)
     printf("  pval: %g\n", pval);
   endif
 
-endfunction
\ No newline at end of file
+endfunction
diff --git a/scripts/statistics/tests/t_test.m b/scripts/statistics/tests/t_test.m
--- a/scripts/statistics/tests/t_test.m
+++ b/scripts/statistics/tests/t_test.m
@@ -26,17 +26,17 @@
 ## - 1} degrees of freedom.
 ##
 ## With the optional argument string @var{alt}, the alternative of
 ## interest can be selected.  If @var{alt} is @code{"!="} or
 ## @code{"<>"}, the null is tested against the two-sided alternative
 ## @code{mean (@var{x}) != @var{m}}.  If @var{alt} is @code{">"}, the
 ## one-sided alternative @code{mean (@var{x}) > @var{m}} is considered.
 ## Similarly for @var{"<"}, the one-sided alternative @code{mean
-## (@var{x}) < @var{m}} is considered,  The default is the two-sided
+## (@var{x}) < @var{m}} is considered.  The default is the two-sided
 ## case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
diff --git a/scripts/statistics/tests/u_test.m b/scripts/statistics/tests/u_test.m
--- a/scripts/statistics/tests/u_test.m
+++ b/scripts/statistics/tests/u_test.m
@@ -26,17 +26,17 @@
 ## equivalent to the Wilcoxon rank-sum test.
 ##
 ## With the optional argument string @var{alt}, the alternative of
 ## interest can be selected.  If @var{alt} is @code{"!="} or
 ## @code{"<>"}, the null is tested against the two-sided alternative
 ## PROB (@var{x} > @var{y}) != 1/2.  If @var{alt} is @code{">"}, the
 ## one-sided alternative PROB (@var{x} > @var{y}) > 1/2 is considered.
 ## Similarly for @code{"<"}, the one-sided alternative PROB (@var{x} >
-## @var{y}) < 1/2 is considered,  The default is the two-sided case.
+## @var{y}) < 1/2 is considered.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## This implementation is still incomplete---for small sample sizes,
 ## the normal approximation is rather bad ...
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dec2base (@var{n}, @var{b}, @var{len})
-## Return a string of symbols in base @var{b} corresponding to the
+## Return a string of symbols in base @var{b} corresponding to
 ## the nonnegative integer @var{n}.
 ##
 ## @example
 ## dec2base (123, 3)
 ##      @result{} "11120"
 ## @end example
 ##
 ## If @var{n} is a vector, return a string matrix with one row per value,
diff --git a/scripts/strings/mat2str.m b/scripts/strings/mat2str.m
--- a/scripts/strings/mat2str.m
+++ b/scripts/strings/mat2str.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, write to the Free
 ## Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
 ## 02110-1301, USA.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{s} =} mat2str (@var{x}, @var{n})
 ## @deftypefnx {Function File} {@var{s} =} mat2str (@dots{}, 'class')
 ##
-## Format real/complex numerial matrices as strings. This function
+## Format real/complex numerical matrices as strings. This function
 ## returns values that are suitable for the use of the @code{eval}
 ## function.
 ##
 ## The precision of the values is given by @var{n}. If @var{n} is a
 ## scalar then both real and imaginary parts of the matrix are printed
 ## to the same precision. Otherwise @code{@var{n} (1)} defines the
 ## precision of the real part and @code{@var{n} (2)} defines the
 ## precision of the imaginary part. The default for @var{n} is 17.
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -47,25 +47,25 @@
 ## can be compared. Default is @code{[]}.
 ##
 ## @item @var{tol}
 ## If @var{tol} is @code{Inf}, then no comparison will be made between the
 ## results of expression @var{f} and expression @var{f2}.  Otherwise,
 ## expression @var{f} should produce a value @var{v} and expression @var{f2} 
 ## should produce a value @var{v2}, and these shall be compared using 
 ## @code{assert(@var{v},@var{v2},@var{tol})}. If @var{tol} is positive,
-## the tolerance is assumed to be absolutr. If @var{tol} is negative,
+## the tolerance is assumed to be absolute. If @var{tol} is negative,
 ## the tolerance is assumed to be relative. The default is @code{eps}.
 ##
 ## @item @var{order}
 ## The time complexity of the expression @code{O(a n^p)}.  This
 ## is a structure with fields @code{a} and @code{p}.
 ##
 ## @item @var{n}
-## The values @var{n} for which the expression was calculated and the
+## The values @var{n} for which the expression was calculated and
 ## the execution time was greater than zero.
 ##
 ## @item @var{T_f}
 ## The nonzero execution times recorded for the expression @var{f} in seconds.
 ##
 ## @item @var{T_f2}
 ## The nonzero execution times recorded for the expression @var{f2} in seconds.
 ## If it is needed, the mean time ratio is just @code{mean(T_f./T_f2)}.
@@ -123,17 +123,17 @@
 ##
 ## @example
 ##   speed("v=xcorr(x,n)", "x=rand(128,1);", 100, ...
 ##         "v2=xcorr_orig(x,n)", -100*eps)
 ##   speed("v=xcorr(x,15)", "x=rand(20+n,1);", 100, ...
 ##         "v2=xcorr_orig(x,n)", -100*eps)
 ## @end example
 ##
-## Assuming one of the two versions is in @var{xcorr_orig}, this would
+## Assuming one of the two versions is in @var{xcorr_orig}, this
 ## would compare their speed and their output values.  Note that the
 ## FFT version is not exact, so we specify an acceptable tolerance on
 ## the comparison @code{100*eps}, and the errors should be computed
 ## relatively, as @code{abs((@var{x} - @var{y})./@var{y})} rather than 
 ## absolutely as @code{abs(@var{x} - @var{y})}.
 ##
 ## Type @code{example('speed')} to see some real examples. Note for 
 ## obscure reasons, you can't run examples 1 and 2 directly using 
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -49,22 +49,22 @@
 ## hopefully when octave crashes this file will tell you what was happening
 ## when it did. You can use @code{stdout} if you want to see the results as
 ## they happen.  You can also give a file name rather than an @var{fid}, in
 ## which case the contents of the file will be replaced with the log from 
 ## the current test.
 ##
 ## Called with a single output argument @var{success}, @code{test} returns
 ## true if all of the tests were successful. Called with two output arguments
-## @var{n} and @var{max}, the number of sucessful test and the total number
+## @var{n} and @var{max}, the number of successful tests and the total number
 ## of tests in the file @var{name} are returned.
 ##
 ## If the second argument is the string 'grabdemo', the contents of the demo
 ## blocks are extracted but not executed. Code for all code blocks is
-## concatented and returned as @var{code} with @var{idx} being a vector of
+## concatenated and returned as @var{code} with @var{idx} being a vector of
 ## positions of the ends of the demo blocks.
 ##
 ## If the second argument is 'explain', then @var{name} is ignored and an
 ## explanation of the line markers used is written to the file @var{fid}.
 ## @seealso{error, assert, fail, demo, example}
 ## @end deftypefn
 
 ## TODO: * Consider using keyword fail rather then error?  This allows us
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,21 @@
+2007-10-10  Olli Saarela  <Olli.Saarela@kcl.fi>
+
+	* data.cc, debug.cc, dirfns.cc, error.cc, file-io.cc, help.cc,
+	load-save.cc, ov-fcn-inline.cc, parse.y, pr-output.cc, symtab.cc,
+	syscalls.cc, toplev.cc, variables.cc, DLD-FUNCTIONS/bsxfun.cc,
+	DLD-FUNCTIONS/cellfun.cc, DLD-FUNCTIONS/fft.cc,
+	DLD-FUNCTIONS/fft2.cc, DLD-FUNCTIONS/fftw.cc,
+	DLD-FUNCTIONS/gcd.cc, DLD-FUNCTIONS/lsode.cc,
+	DLD-FUNCTIONS/luinc.cc, DLD-FUNCTIONS/matrix_type.cc,
+	DLD-FUNCTIONS/rand.cc, DLD-FUNCTIONS/regexp.cc,
+	DLD-FUNCTIONS/sparse.cc, DLD-FUNCTIONS/spchol.cc,
+	DLD-FUNCTIONS/splu.cc, DLD-FUNCTIONS/spparms.cc: Spelling fixes.
+
 2007-10-10  Kim Hansen  <kimhanse@gmail.com>
 
 	* DLD-FUNCTIONS/lpsolve.cc: Delete.
 	* Makefile.in (DLD_XSRC): Remove it from the list.
 
         * data.cc (Fsqueeze): Document 2d behaviour.
         * ov-range.h (octave_range::squeeze): New function.
 
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -124,24 +124,24 @@ update_index (Array<int>& idx, const dim
     {
       idx (j) = i % dv (j);
       i = i / dv (j);
     }
 }
 
 DEFUN_DLD (bsxfun, args, ,
   " -*- texinfo -*-\n\
-@deftypefn {Lodable Function} {} bsxfun (@var{f}, @var{a}, @var{b})\n\
+@deftypefn {Loadable Function} {} bsxfun (@var{f}, @var{a}, @var{b})\n\
 Applies a binary function @var{f} element-wise to two matrix arguments\n\
 @var{a} and @var{b}. The function @var{f} must be capable of accepting\n\
 two column vector arguments of equal length, or one column vector\n\
 argument and a scalar.\n\
 \n\
 The dimensions of @var{a} and @var{b} must be equal or singleton. The\n\
-singleton dimensions of the matirces will be expanded to the same\n\
+singleton dimensions of the matrices will be expanded to the same\n\
 dimensionality as the other matrix.\n\
 \n\
 @seealso{arrayfun, cellfun}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value_list retval;
 
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -214,17 +214,17 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
     }
   else if (name == "size")
     {
       if (nargin == 3)
         {
           int d = args(2).nint_value () - 1;
 
           if (d < 0)
-	    error ("cellfun: third argument must be a postive integer");
+	    error ("cellfun: third argument must be a positive integer");
 
 	  if (! error_state)
             {
               NDArray result (f_args.dims ());
               for (octave_idx_type count = 0; count < k ; count++)
                 {
                   dim_vector dv = f_args.elem(count).dims ();
                   if (d < dv.length ())
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/DLD-FUNCTIONS/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/DLD-FUNCTIONS/fft.cc
@@ -199,17 +199,17 @@ the inverse FFT for each column of @var{
 If called with two arguments, @var{n} is expected to be an integer\n\
 specifying the number of elements of @var{a} to use, or an empty\n\
 matrix to specify that its value should be ignored. If @var{n} is\n\
 larger than the dimension along which the inverse FFT is calculated, then\n\
 @var{a} is resized and padded with zeros. Otherwise, if@var{n} is\n\
 smaller than the dimension along which the inverse FFT is calculated,\n\
 then @var{a} is truncated.\n\
 \n\
-If called with three agruments, @var{dim} is an integer specifying the\n\
+If called with three arguments, @var{dim} is an integer specifying the\n\
 dimension of the matrix along which the inverse FFT is performed\n\
 @seealso{fft, ifft2, ifftn, fftw}\n\
 @end deftypefn")
 {
   return do_fft (args, "ifft", 1);
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/fft2.cc b/src/DLD-FUNCTIONS/fft2.cc
--- a/src/DLD-FUNCTIONS/fft2.cc
+++ b/src/DLD-FUNCTIONS/fft2.cc
@@ -143,17 +143,17 @@ DEFUN_DLD (fft2, args, ,
 Compute the two dimensional FFT of @var{a} using subroutines from\n"
 FFTSRC
 ". The optional arguments @var{n} and @var{m} may be used specify the\n\
 number of rows and columns of @var{a} to use.  If either of these is\n\
 larger than the size of @var{a}, @var{a} is resized and padded with\n\
 zeros.\n\
 \n\
 If @var{a} is a multi-dimensional matrix, each two-dimensional sub-matrix\n\
-of @var{a} is treated seperately\n\
+of @var{a} is treated separately\n\
 @seealso {ifft2, fft, fftn, fftw}\n\
 @end deftypefn")
 {
   return do_fft2 (args, "fft2", 0);
 }
 
 
 DEFUN_DLD (ifft2, args, ,
@@ -162,17 +162,17 @@ DEFUN_DLD (ifft2, args, ,
 Compute the inverse two dimensional FFT of @var{a} using subroutines from\n"
 FFTSRC
 ". The optional arguments @var{n} and @var{m} may be used specify the\n\
 number of rows and columns of @var{a} to use.  If either of these is\n\
 larger than the size of @var{a}, @var{a} is resized and padded with\n\
 zeros.\n\
 \n\
 If @var{a} is a multi-dimensional matrix, each two-dimensional sub-matrix\n\
-of @var{a} is treated seperately\n\
+of @var{a} is treated separately\n\
 @seealso {fft2, ifft, ifftn, fftw}\n\
 @end deftypefn")
 {
   return do_fft2 (args, "ifft2", 1);
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/DLD-FUNCTIONS/fftw.cc b/src/DLD-FUNCTIONS/fftw.cc
--- a/src/DLD-FUNCTIONS/fftw.cc
+++ b/src/DLD-FUNCTIONS/fftw.cc
@@ -37,17 +37,17 @@ 02110-1301, USA.
 DEFUN_DLD (fftw, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{method} =} fftw ('planner')\n\
 @deftypefnx {Loadable Function} {} fftw ('planner', @var{method})\n\
 @deftypefnx {Loadable Function} {@var{wisdom} =} fftw ('dwisdom')\n\
 @deftypefnx {Loadable Function} {@var{wisdom} =} fftw ('dwisdom', @var{wisdom})\n\
 \n\
 Manage FFTW wisdom data. Wisdom data can be used to significantly\n\
-accelerate the calculation of the FFTs but implies a initial cost\n\
+accelerate the calculation of the FFTs but implies an initial cost\n\
 in its calculation. The wisdom used by Octave can be imported directly,\n\
 usually from a file /etc/fftw/wisdom, or @dfn{fftw} can be used\n\
 to import wisdom. For example\n\
 \n\
 @example\n\
 @var{wisdom} = fftw ('dwisdom')\n\
 @end example\n\
 \n\
@@ -76,23 +76,23 @@ is appropriate for a fourier transform t
 \n\
 @item 'measure'\n\
 In this case a range of algorithms to perform the transform is considered\n\
 and the best is selected based on their execution time.\n\
 \n\
 @item 'patient'\n\
 This is like 'measure', but a wider range of algorithms is considered.\n\
 \n\
-@item 'exhasutive'\n\
-This is like 'meaure', but all possible algorithms that may be used to\n\
+@item 'exhaustive'\n\
+This is like 'measure', but all possible algorithms that may be used to\n\
 treat the transform are considered.\n\
 \n\
 @item 'hybrid'\n\
 As run-time measurement of the algorithm can be expensive, this is a\n\
-compromise where 'measure' is used for transforms upto the size of 8192\n\
+compromise where 'measure' is used for transforms up to the size of 8192\n\
 and beyond that the 'estimate' method is used.\n\
 @end table\n\
 \n\
 The default method is 'estimate', and the method currently being used can\n\
 be probed with\n\
 \n\
 @example\n\
 @var{method} = fftw ('planner')\n\
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -76,18 +76,18 @@ that,\n\
 @end example\n\
 @end ifinfo\n\
 @iftex\n\
 @tex\n\
 $g = v_1 a_1 + v_2 a_2 + \\cdots$\n\
 @end tex\n\
 @end iftex\n\
 \n\
-For backward compatiability with previous versions of this function, when\n\
-all arguments are scalr, a single return argument @var{v1} containing\n\
+For backward compatibility with previous versions of this function, when\n\
+all arguments are scalar, a single return argument @var{v1} containing\n\
 all of the values of @var{v1}, @dots{} is acceptable.\n\
 @seealso{lcm, min, max, ceil, floor}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -247,17 +247,17 @@ jac = ---- = |                       |\n
              |                       |\n\
              | df_N  df_N       df_N |\n\
              | ----  ----  ...  ---- |\n\
              | dx_1  dx_2       dx_N |\n\
 @end example\n\
 \n\
 @end ifinfo\n\
 \n\
-The second and third arguments specify the intial state of the system,\n\
+The second and third arguments specify the initial state of the system,\n\
 @math{x_0}, and the initial value of the independent variable @math{t_0}.\n\
 \n\
 The fourth argument is optional, and may be used to specify a set of\n\
 times that the ODE solver should not integrate past.  It is useful for\n\
 avoiding difficulties with singularities and points where there is a\n\
 discontinuity in the derivative.\n\
 \n\
 After a successful computation, the value of @var{istate} will be 2\n\
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -49,17 +49,17 @@ is determined by the second argument to 
 Called with a second argument of '0', the zero-level incomplete\n\
 LU factorization is produced. This creates a factorization of @var{a}\n\
 where the position of the non-zero arguments correspond to the same\n\
 positions as in the matrix @var{a}.\n\
 \n\
 Alternatively, the fill-in of the incomplete LU factorization can\n\
 be controlled through the variable @var{droptol} or the structure\n\
 @var{opts}. The UMFPACK multifrontal factorization code by Tim A.\n\
-Davis is used for the incomplete LU factorication, (availability\n\
+Davis is used for the incomplete LU factorization, (availability\n\
 @url{http://www.cise.ufl.edu/research/sparse/umfpack/})\n\
 \n\
 @var{droptol} determines the values below which the values in the LU\n\
 factorization are dropped and replaced by zero. It must be a positive\n\
 scalar, and any values in the factorization whose absolute value are\n\
 less than this value are dropped, expect if leaving them increase the\n\
 sparsity of the matrix. Setting @var{droptol} to zero results in a\n\
 complete LU factorization which is the default.\n\
@@ -69,17 +69,17 @@ complete LU factorization which is the d
 @table @code\n\
 @item droptol\n\
 The drop tolerance as above. If @var{opts} only contains @code{droptol}\n\
 then this is equivalent to using the variable @var{droptol}.\n\
 \n\
 @item milu\n\
 A logical variable flagging whether to use the modified incomplete LU\n\
 factorization. In the case that @code{milu} is true, the dropped values\n\
-are subtract from the diagonal of the matrix U of the factorization.\n\
+are subtracted from the diagonal of the matrix U of the factorization.\n\
 The default is @code{false}.\n\
 \n\
 @item udiag\n\
 A logical variable that flags whether zero elements on the diagonal of U\n\
 should be replaced with @var{droptol} to attempt to avoid singular\n\
 factors. The default is @code{false}.\n\
 \n\
 @item thresh\n\
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -91,17 +91,17 @@ with specialized code. In addition the m
 The matrix is assumed to be singular and will be treated with a minimum norm solution\n\
 \n\
 @end table\n\
 \n\
 Note that the matrix type will be discovered automatically on the first attempt to\n\
 solve a linear equation involving @var{a}. Therefore @code{matrix_type} is only\n\
 useful to give Octave hints of the matrix type. Incorrectly defining the\n\
 matrix type will result in incorrect results from solutions of linear equations,\n\
-and so it is entirely the responsibility of the user to correctly indentify the\n\
+and so it is entirely the responsibility of the user to correctly identify the\n\
 matrix type.\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value retval;
 
   if (nargin == 0)
     print_usage ();
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -339,17 +339,17 @@ value of @var{v}, not @var{v} itself.\n\
 \n\
 By default, the generator is initialized from @code{/dev/urandom} if it is\n\
 available, otherwise from cpu time, wall clock time and the current\n\
 fraction of a second.\n\
 \n\
 @code{rand} uses the Mersenne Twister with a period of 2^19937-1\n\
 (See M. Matsumoto and T. Nishimura, ``Mersenne Twister: A 623-dimensionally\n\
 equidistributed uniform pseudorandom number generator'', ACM Trans. on\n\
-Modeling and Computer Simulation Vol. 8, No. 1, Januray pp.3-30 1998,\n\
+Modeling and Computer Simulation Vol. 8, No. 1, January pp.3-30 1998,\n\
 @url{http://www.math.keio.ac.jp/~matumoto/emt.html}).\n\
 Do @strong{not} use for cryptography without securely hashing\n\
 several returned values together, otherwise the generator state\n\
 can be learned after reading 624 consecutive values.\n\
 \n\
 @code{rand} includes a second random number generator, that was the\n\
 previous generator used in Octave. The new generator is used by default\n\
 as it is significantly faster than the old generator, and produces\n\
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -743,17 +743,17 @@ Match range operator, which is of the fo
 @code{@{@var{m},@var{n}@}} to match between @var{m} and @var{n} times.\n\
 @end table\n\
 @item [@dots{}] [^@dots{}]\n\
 List operators, where for example @code{[ab]c} matches @code{ac} and @code{bc}\n\
 @item ()\n\
 Grouping operator\n\
 @item |\n\
 Alternation operator. Match one of a choice of regular expressions. The\n\
-alternatives must be delimited by the grouoing operator @code{()} above\n\
+alternatives must be delimited by the grouping operator @code{()} above\n\
 @item ^ $\n\
 Anchoring operator. @code{^} matches the start of the string @var{str} and\n\
 @code{$} the end\n\
 @end table\n\
 \n\
 In addition the following escaped characters have special meaning. It should\n\
 be noted that it is recommended to quote @var{pat} in single quotes rather\n\
 than double quotes, to avoid the escape sequences being interpreted by octave\n\
@@ -1402,17 +1402,17 @@ for the ith set of parentheses in the ma
 \n\
 @end example\n\
 returns \"Dunn, Bill\"\n\
 \n\
 @var{options} may be zero or more of\n\
 @table @samp\n\
 \n\
 @item once\n\
-Replace only the first occurance of @var{pat} in the result.\n\
+Replace only the first occurrence of @var{pat} in the result.\n\
 \n\
 @item warnings\n\
 This option is present for compatibility but is ignored.\n\
 \n\
 @item ignorecase or matchcase\n\
 Ignore case for the pattern matching (see @code{regexpi}).\n\
 Alternatively, use (?i) or (?-i) in the pattern.\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/sparse.cc b/src/DLD-FUNCTIONS/sparse.cc
--- a/src/DLD-FUNCTIONS/sparse.cc
+++ b/src/DLD-FUNCTIONS/sparse.cc
@@ -68,17 +68,17 @@ is forced back to a full matrix is resul
 @deftypefnx {Loadable Function} {@var{s} =} sparse (@var{a}, 1)\n\
 Create a sparse matrix and convert it back to a full matrix.\n\
 is forced back to a full matrix is resulting matrix is sparse\n\
 \n\
 @deftypefnx {Loadable Function} {@var{s} =} sparse (@var{i}, @var{j}, @var{sv}, @var{m}, @var{n}, @var{nzmax})\n\
 Create a sparse matrix given integer index vectors @var{i} and @var{j},\n\
 a 1-by-@code{nnz} vector of real of complex values @var{sv}, overall\n\
 dimensions @var{m} and @var{n} of the sparse matrix.  The argument\n\
-@code{nzmax} is ignored but accepted for compatability with @sc{Matlab}.\n\
+@code{nzmax} is ignored but accepted for compatibility with @sc{Matlab}.\n\
 \n\
 @strong{Note}: if multiple values are specified with the same\n\
 @var{i}, @var{j} indices, the corresponding values in @var{s} will\n\
 be added.\n\
 \n\
 The following are all equivalent:\n\
 \n\
 @example\n\
diff --git a/src/DLD-FUNCTIONS/spchol.cc b/src/DLD-FUNCTIONS/spchol.cc
--- a/src/DLD-FUNCTIONS/spchol.cc
+++ b/src/DLD-FUNCTIONS/spchol.cc
@@ -152,17 +152,17 @@ is the factorization of @code{@var{a}(@v
 @end iftex\n\
 @ifinfo\n\
 \n\
 @example\n\
 r' * r = q * a * q'.\n\
 @end example\n\
 @end ifinfo\n\
 \n\
-Note that @code{splchol} factorizations is faster and use less memory.\n\
+Note that @code{splchol} factorization is faster and uses less memory.\n\
 @seealso{spcholinv, spchol2inv, splchol}\n\
 @end deftypefn")
 {
   return sparse_chol (args, nargout, "spchol", false);
 }
 
 // PKG_ADD: dispatch ("lchol", "splchol", "sparse matrix");
 // PKG_ADD: dispatch ("lchol", "splchol", "sparse complex matrix");
@@ -200,17 +200,17 @@ is the factorization of @code{@var{a}(@v
 @end iftex\n\
 @ifinfo\n\
 \n\
 @example\n\
 r * r' = a (q, q).\n\
 @end example\n\
 @end ifinfo\n\
 \n\
-Note that @code{splchol} factorizations is faster and use less memory\n\
+Note that @code{splchol} factorization is faster and uses less memory\n\
 than @code{spchol}. @code{splchol(@var{a})} is equivalent to\n\
 @code{spchol(@var{a})'}.\n\
 @seealso{spcholinv, spchol2inv, splchol}\n\
 @end deftypefn")
 {
   return sparse_chol (args, nargout, "splchol", true);
 }
 
@@ -354,17 +354,17 @@ Factorize @code{@var{s}' * @var{s}}.\n\
 @item row\n\
 Factorize @code{@var{s} * @var{s}'}.\n\
 @item lo\n\
 Factorize @code{@var{s}'}\n\
 @end table\n\
 \n\
 @item @var{mode}\n\
 The default is to return the Cholesky factorization for @var{r}, and if\n\
-@var{mode} is 'L', the conjugate transpose of the Choleksy factorization\n\
+@var{mode} is 'L', the conjugate transpose of the Cholesky factorization\n\
 is returned. The conjugate transpose version is faster and uses less\n\
 memory, but returns the same values for @var{count}, @var{h}, @var{parent}\n\
 and @var{post} outputs.\n\
 @end table\n\
 \n\
 The output variables are\n\
 \n\
 @table @asis\n\
diff --git a/src/DLD-FUNCTIONS/splu.cc b/src/DLD-FUNCTIONS/splu.cc
--- a/src/DLD-FUNCTIONS/splu.cc
+++ b/src/DLD-FUNCTIONS/splu.cc
@@ -55,17 +55,17 @@ Called with two or three output argument
 preserving column permutations @var{Q} are not performed. Called with\n\
 a fourth output argument, the sparsity preserving column transformation\n\
 @var{Q} is returned, such that @code{@var{P} * @var{a} * @var{Q} =\n\
 @var{l} * @var{u}}.\n\
 \n\
 An additional input argument @var{thres}, that defines the pivoting\n\
 threshold can be given. Alternatively, the desired sparsity preserving\n\
 column permutations @var{Q} can be passed. Note that @var{Q} is assumed\n\
-to be fixed if three are fewer than four output arguments. Otherwise,\n\
+to be fixed if there are fewer than four output arguments. Otherwise,\n\
 the updated column permutations are returned as the fourth argument.\n\
 \n\
 With two output arguments, returns the permuted forms of the upper and\n\
 lower triangular matrices, such that @code{@var{a} = @var{l} * @var{u}}.\n\
 With two or three output arguments, if a user-defined @var{Q} is given,\n\
 then @code{@var{u} * @var{Q}'} is returned. The matrix is not required to\n\
 be square.\n\
 @seealso{sparse, spinv, colamd, symamd}\n\
diff --git a/src/DLD-FUNCTIONS/spparms.cc b/src/DLD-FUNCTIONS/spparms.cc
--- a/src/DLD-FUNCTIONS/spparms.cc
+++ b/src/DLD-FUNCTIONS/spparms.cc
@@ -47,27 +47,27 @@ functions. The first four calls above ge
 settings, while the others change the current settings. The parameters are\n\
 stored as pairs of keys and values, where the values are all floats and the\n\
 keys are one of the strings\n\
 \n\
 @itemize\n\
 @item spumoni\n\
 Printing level of debugging information of the solvers (default 0)\n\
 @item ths_rel\n\
-Included for compatiability. Bot used. (default 1)\n\
+Included for compatibility. Not used. (default 1)\n\
 @item ths_abs\n\
-Included for compatiability. Bot used. (default 1)\n\
+Included for compatibility. Not used. (default 1)\n\
 @item exact_d\n\
-Included for compatiability. Bot used. (default 0)\n\
+Included for compatibility. Not used. (default 0)\n\
 @item supernd\n\
-Included for compatiability. Not used. (default 3)\n\
+Included for compatibility. Not used. (default 3)\n\
 @item rreduce\n\
-Included for compatiability. Not used. (default 3)\n\
+Included for compatibility. Not used. (default 3)\n\
 @item wh_frac\n\
-Inluded for compatiability. Not used. (default 0.5)\n\
+Included for compatibility. Not used. (default 0.5)\n\
 @item autommd\n\
 Flag whether the LU/QR and the '\\' and '/' operators will automatically\n\
 use the sparsity preserving mmd functions (default 1)\n\
 @item autoamd\n\
 Flag whether the LU and the '\\' and '/' operators will automatically\n\
 use the sparsity preserving amd functions (default 1)\n\
 @item piv_tol\n\
 The pivot tolerance of the UMFPACK solvers (default 0.1)\n\
@@ -76,17 +76,17 @@ The pivot tolerance of the UMFPACK solve
 @item umfpack\n\
 Flag whether the UMFPACK or mmd solvers are used for the LU, '\\' and\n\
 '/' operations (default 1)\n\
 @end itemize\n\
 \n\
 The value of individual keys can be set with @code{spparms (@var{key},\n\
 @var{val})}. The default values can be restored with the special keyword\n\
 'defaults'. The special keyword 'tight' can be used to set the mmd solvers\n\
-to attempt for a sparser solution at the potetial cost of longer running\n\
+to attempt for a sparser solution at the potential cost of longer running\n\
 time.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
 
   if (nargin == 0)
     {
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -1143,17 +1143,17 @@ Returns the number of non zero elements 
 
   return retval;
 }
 
 DEFUN (nzmax, args, ,
    "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{scalar} =} nzmax (@var{SM})\n\
 Return the amount of storage allocated to the sparse matrix @var{SM}.\n\
-Note that Octave tends to crop unused memory at the first oppurtunity\n\
+Note that Octave tends to crop unused memory at the first opportunity\n\
 for sparse objects. There are some cases of user created sparse objects\n\
 where the value returned by @dfn{nzmaz} will not be the same as @dfn{nnz},\n\
 but in general they will give the same result.\n\
 @seealso{sparse, spalloc}\n\
 @end deftypefn")
 {
   octave_value retval;
 
@@ -2052,17 +2052,17 @@ to the pure imaginary unit, defined as\n
 @iftex\n\
 @tex\n\
   $\\sqrt{-1}$.\n\
 @end tex\n\
 @end iftex\n\
 @ifinfo\n\
   @code{sqrt (-1)}.\n\
 @end ifinfo\n\
-Since I (also i, J, and J) is a function, you can use the name(s) for\n\
+Since I (also i, J, and j) is a function, you can use the name(s) for\n\
 other purposes.\n\
 @end deftypefn")
 {
   return fill_matrix (args, Complex (0.0, 1.0), "I");
 }
 
 DEFALIAS (i, I);
 DEFALIAS (J, I);
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -90,17 +90,17 @@ DEFCMD (dbstop, args, ,
 @deftypefn {Loadable Function} {rline =} dbstop (func, line, @dots{})\n\
 Set a breakpoint in a function\n\
 @table @code\n\
 @item func\n\
 String representing the function name.  When already in debug\n\
 mode this should be left out and only the line should be given.\n\
 @item line\n\
 Line you would like the breakpoint to be set on. Multiple\n\
-lines might be given as seperate arguments or as a vector.\n\
+lines might be given as separate arguments or as a vector.\n\
 @end table\n\
 \n\
 The rline returned is the real line that the breakpoint was set at.\n\
 @seealso{dbclear, dbstatus, dbnext}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
@@ -185,17 +185,17 @@ DEFCMD (dbclear, args, ,
 @deftypefn {Loadable Function} {} dbclear (func, line, @dots{})\n\
 Delete a breakpoint in a function\n\
 @table @code\n\
 @item func\n\
 String representing the function name.  When already in debug\n\
 mode this should be left out and only the line should be given.\n\
 @item line\n\
 Line where you would like to remove the breakpoint. Multiple\n\
-lines might be given as seperate arguments or as a vector.\n\
+lines might be given as separate arguments or as a vector.\n\
 @end table\n\
 No checking is done to make sure that the line you requested is really\n\
 a breakpoint. If you get the wrong line nothing will happen.\n\
 @seealso{dbstop, dbstatus, dbwhere}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -96,17 +96,17 @@ octave_change_to_directory (const std::s
   return cd_ok;
 }
 
 DEFCMD (cd, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} cd dir\n\
 @deffnx {Command} chdir dir\n\
 Change the current working directory to @var{dir}.  If @var{dir} is\n\
-omitted, the current directory is changed to the users home\n\
+omitted, the current directory is changed to the user's home\n\
 directory.  For example,\n\
 \n\
 @example\n\
 cd ~/octave\n\
 @end example\n\
 \n\
 @noindent\n\
 Changes the current working directory to @file{~/octave}.  If the\n\
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -1353,27 +1353,27 @@ returns a structure containing the last 
 information related to this error. The elements of this structure are:\n\
 \n\
 @table @asis\n\
 @item 'message'\n\
 The text of the last error message\n\
 @item 'identifier'\n\
 The message identifier of this error message\n\
 @item 'stack'\n\
-A structure containing information on where the message occured. This might\n\
+A structure containing information on where the message occurred. This might\n\
 be an empty structure if this in the case where this information can not\n\
 be obtained. The fields of this structure are:\n\
 \n\
 @table @asis\n\
 @item 'file'\n\
 The name of the file where the error occurred\n\
 @item 'name'\n\
-The name of function in which the error occured\n\
+The name of function in which the error occurred\n\
 @item 'line'\n\
-The line number at which the error occured\n\
+The line number at which the error occurred\n\
 @item 'column'\n\
 An optional field with the column number at which the error occurred\n\
 @end table\n\
 @end table\n\
 \n\
 The @var{err} structure may also be passed to @code{lasterror} to set the\n\
 information about the last error. The only constraint on @var{err} in that\n\
 case is that it is a scalar structure. Any fields of @var{err} that match\n\
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -534,17 +534,17 @@ produce unexpected results.\n\
 \n\
 The possible values @samp{mode} may have are\n\
 \n\
 @table @asis\n\
 @item @samp{r}\n\
 Open a file for reading.\n\
 \n\
 @item @samp{w}\n\
-Open a file for writing.  The previous contents are discared.\n\
+Open a file for writing.  The previous contents are discarded.\n\
 \n\
 @item @samp{a}\n\
 Open or create a file for writing at the end of the file.\n\
 \n\
 @item @samp{r+}\n\
 Open an existing file for reading and writing.\n\
 \n\
 @item @samp{w+}\n\
@@ -1869,17 +1869,17 @@ permissions that are system dependent (o
 will be 0600 for versions of glibc 2.0.7 and later).  The file is opened\n\
 with the @code{O_EXCL} flag.\n\
 \n\
 If the optional argument @var{delete} is supplied and is true,\n\
 the file will be deleted automatically when Octave exits, or when\n\
 the function @code{purge_tmp_files} is called.\n\
 \n\
 If successful, @var{fid} is a valid file ID, @var{name} is the name of\n\
-the file, and and @var{msg} is an empty string.  Otherwise, @var{fid}\n\
+the file, and @var{msg} is an empty string.  Otherwise, @var{fid}\n\
 is -1, @var{name} is empty, and @var{msg} contains a system-dependent\n\
 error message.\n\
 @seealso{tmpfile, tmpnam, P_tmpdir}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(2) = std::string ();
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -1739,19 +1739,19 @@ print_lookfor (const std::string& name, 
 
 DEFCMD (lookfor, args, nargout, 
   "-*- texinfo -*-\n\
 @deffn {Command} lookfor @var{str}\n\
 @deffnx {Command} lookfor -all @var{str}\n\
 @deffnx {Function} {[@var{fun}, @var{helpstring}] = } lookfor (@var{str})\n\
 @deffnx {Function} {[@var{fun}, @var{helpstring}] = } lookfor ('-all', @var{str})\n\
 Search for the string @var{str} in all of the functions found in the\n\
-function search path.  By default @code{lookfor} searchs for @var{str}\n\
+function search path.  By default @code{lookfor} searches for @var{str}\n\
 in the first sentence of the help string of each function found. The entire\n\
-help string of each function found in the path can be search if\n\
+help string of each function found in the path can be searched if\n\
 the '-all' argument is supplied. All searches are case insensitive.\n\
 \n\
 Called with no output arguments, @code{lookfor} prints the list of matching\n\
 functions to the terminal. Otherwise the output arguments @var{fun} and\n\
 @var{helpstring} define the matching functions and the first sentence of\n\
 each of their help strings.\n\
 \n\
 Note that the ability of @code{lookfor} to correctly identify the first\n\
@@ -2156,17 +2156,17 @@ Texinfo markup commands.  The default in
 {
   return SET_NONEMPTY_INTERNAL_STRING_VARIABLE (makeinfo_program);
 }
 
 DEFUN (suppress_verbose_help_message, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{val} =} suppress_verbose_help_message ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} suppress_verbose_help_message (@var{new_val})\n\
-Query or set the internal vaiable that controls whether Octave\n\
+Query or set the internal variable that controls whether Octave\n\
 will add additional help information to the end of the output from\n\
 the @code{help} command and usage messages for built-in commands.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (suppress_verbose_help_message);
 }
 
 /*
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -1797,17 +1797,17 @@ The default value is @code{-ascii}.\n\
 DEFUN (octave_core_file_limit, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{val} =} octave_core_file_limit ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} octave_core_file_limit (@var{new_val})\n\
 Query or set the internal variable that specifies the maximum amount\n\
 of memory (in kilobytes) of the top-level workspace that Octave will\n\
 attempt to save when writing data to the crash dump file (the name of\n\
 the file is specified by @var{octave_core_file_name}).  If\n\
-@var{octave_core_file_options} flags specifies a binary format,\n\
+@var{octave_core_file_options} flags specify a binary format,\n\
 then @var{octave_core_file_limit} will be approximately the maximum\n\
 size of the file.  If a text file format is used, then the file could\n\
 be much larger than the limit.  The default value is -1 (unlimited)\n\
 @seealso{crash_dumps_octave_core, octave_core_file_name, octave_core_file_options}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (octave_core_file_limit);
 }
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -584,17 +584,17 @@ DEFUNX ("inline", Finline, args, ,
 @deftypefnx {Built-in Function} {} inline (@var{str}, @var{arg1}, @dots{})\n\
 @deftypefnx {Built-in Function} {} inline (@var{str}, @var{n})\n\
 Create an inline function from the character string @var{str}.\n\
 If called with a single argument, the arguments of the generated\n\
 function are extracted from the function itself. The generated\n\
 function arguments will then be in alphabetical order. It should\n\
 be noted that i, and j are ignored as arguments due to the\n\
 ambiguity between their use as a variable or their use as an inbuilt\n\
-constant. All arguments followed by a parentheses are considered\n\
+constant. All arguments followed by a parenthesis are considered\n\
 to be functions.\n\
 \n\
 If the second and subsequent arguments are character strings,\n\
 they are the names of the arguments of the function.\n\
 \n\
 If the second argument is an integer @var{n}, the arguments are\n\
 @code{\"x\"}, @code{\"P1\"}, @dots{}, @code{\"P@var{N}\"}.\n\
 @seealso{argnames, formula, vectorize}\n\
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -3976,18 +3976,18 @@ value 3.1416 available.\n\
 eval(\"a = acos(-1);\");\n\
 @end example\n\
 \n\
 If an error occurs during the evaluation of @var{try} the @var{catch}\n\
 string is evaluated, as the following example shows.\n\
 \n\
 @example\n\
 eval ('error (\"This is a bad example\");',\n\
-      'printf (\"This error occured:\\n%s\", lasterr ());');\n\
-     @print{} This error occured:\n\
+      'printf (\"This error occurred:\\n%s\", lasterr ());');\n\
+     @print{} This error occurred:\n\
         error: This is a bad example\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -3113,17 +3113,17 @@ format, @code{pi} is displayed as @code{
 @item long E\n\
 @itemx short E\n\
 The same as @samp{format long e} or @samp{format short e} but always\n\
 display output with an uppercase @samp{E} format.  For example, with\n\
 the @samp{long E} format, @code{pi} is displayed as\n\
 @code{3.14159265358979E+00}.\n\
 @item long g\n\
 @itemx short g\n\
-Choose between normal @samp{long} (or @samp{short}) and and\n\
+Choose between normal @samp{long} (or @samp{short}) and\n\
 @samp{long e} (or @samp{short e}) formats based on the magnitude\n\
 of the number.  For example, with the @samp{short g} format,\n\
 @code{pi .^ [2; 4; 8; 16; 32]} is displayed as\n\
 \n\
 @example\n\
 @group\n\
 ans =\n\
 \n\
@@ -3283,17 +3283,17 @@ this reason, you should be careful when 
 {
   return SET_INTERNAL_VARIABLE (fixed_point_format);
 }
 
 DEFUN (print_empty_dimensions, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{val} =} print_empty_dimensions ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} print_empty_dimensions (@var{new_val})\n\
-Query or set the internal varaible that controls whether the\n\
+Query or set the internal variable that controls whether the\n\
 dimensions of empty matrices are printed along with the empty matrix\n\
 symbol, @samp{[]}.  For example, the expression\n\
 \n\
 @example\n\
 zeros (3, 0)\n\
 @end example\n\
 \n\
 @noindent\n\
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -1944,17 +1944,17 @@ The following escape sequences may be us
 Prints number of bytes occupied by variables.\n\
 @item %c\n\
 Prints class names of variables.\n\
 @item %e\n\
 Prints elements held by variables.\n\
 @item %n\n\
 Prints variable names.\n\
 @item %p\n\
-Prints protection attributtes of variables.\n\
+Prints protection attributes of variables.\n\
 @item %s\n\
 Prints dimensions of variables.\n\
 @item %t\n\
 Prints type names of variables.\n\
 @end table\n\
 \n\
 Every command may also have a modifier:\n\
 @table @code\n\
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -684,17 +684,17 @@ If @var{pid} is -1, then signal @var{sig
 except process 1.\n\
 \n\
 If @var{pid} is less than -1, then signal @var{sig} is sent to every\n\
 process in the process group @var{-pid}.\n\
 \n\
 If @var{sig} is 0, then no signal is sent, but error checking is still\n\
 performed.\n\
 \n\
-Return 0 if sucessful, otherwise return -1.\n\
+Return 0 if successful, otherwise return -1.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1;
 
   if (args.length () == 2)
@@ -927,17 +927,17 @@ Number of blocks allocated for file.\n\
 @end table\n\
 \n\
 If the call is successful @var{err} is 0 and @var{msg} is an empty\n\
 string.  If the file does not exist, or some other error occurs, @var{s}\n\
 is an empty matrix, @var{err} is @minus{}1, and @var{msg} contains the\n\
 corresponding system error message.\n\
 \n\
 If @var{file} is a symbolic link, @code{stat} will return information\n\
-about the actual file the is referenced by the link.  Use @code{lstat}\n\
+about the actual file that is referenced by the link.  Use @code{lstat}\n\
 if you want information about the symbolic link itself.\n\
 \n\
 For example,\n\
 \n\
 @example\n\
 @group\n\
 [s, err, msg] = stat (\"/vmlinuz\")\n\
       @result{} s =\n\
@@ -1287,17 +1287,17 @@ status has not yet been reported since t
 @item WCONTINUED\n\
 Return if a stopped child has been resumed by delivery of @code{SIGCONT}.\n\
 This value may not be meaningful on all systems.\n\
 @end table\n\
 \n\
 If the returned value of @var{pid} is greater than 0, it is the process\n\
 ID of the child process that exited.  If an error occurs, @var{pid} will\n\
 be less than zero and @var{msg} will contain a system-dependent error\n\
-message.  The value of @var{status} contains additional system-depenent\n\
+message.  The value of @var{status} contains additional system-dependent\n\
 information about the subprocess that exited.\n\
 @seealso{WNOHANG, WUNTRACED, WCONTINUED, WEXITSTATUS, WIFSIGNALED, WTERMSIG, WCOREDUMP, WIFSTOPPED, WSTOPSIG, WIFCONTINUED}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(2) = std::string ();
   retval(1) = 0;
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -685,17 +685,17 @@ after registering the function @code{bye
 @example\n\
 atexit (\"bye_bye\", false);\n\
 @end example\n\
 \n\
 @noindent\n\
 will remove the function from the list and Octave will not call\n\
 the function @code{bye_by} when it exits.\n\
 \n\
-Note that @code{atexit} only removes the first occurence of a function\n\
+Note that @code{atexit} only removes the first occurrence of a function\n\
 from the list, so if a function was placed in the list multiple\n\
 times with @code{atexit}, it must also be removed from the list\n\
 multiple times.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -2626,17 +2626,17 @@ the time stamp on files each time it loo
 function files.  If the internal variable is set to @code{\"system\"},\n\
 Octave will not automatically recompile function files in subdirectories of\n\
 @file{@var{octave-home}/lib/@var{version}} if they have changed since\n\
 they were last compiled, but will recompile other function files in the\n\
 search path if they change.  If set to @code{\"all\"}, Octave will not\n\
 recompile any function files unless their definitions are removed with\n\
 @code{clear}.  If set to \"none\", Octave will always check time stamps\n\
 on files to determine whether functions defined in function files\n\
-need to recompiled.\n\
+need to be recompiled.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (nargout > 0)
     {
       switch (Vignore_function_time_stamp)
 	{
