# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1307228737 25200
#      Sat Jun 04 16:05:37 2011 -0700
# Node ID da6cbb75236832c72b28be98898f2120952cc454
# Parent  c0d102ad9bba26e797aa71c26a8fc9d9183f0f31
# Parent  d326be468b13878b8c17f11365538d8a80e9abc8
maint: Periodic merge of stable to default branch.

diff --git a/NEWS b/NEWS
--- a/NEWS
+++ b/NEWS
@@ -162,17 +162,17 @@ Summary of important user-visible change
       logical matrix |= logical matrix
       logical matrix &= logical matrix
 
     where matrix and scalar belong to the same class.  The left-hand
     side must be a simple variable reference.
 
     Moreover, when unary operators occur in expressions, Octave will
     also try to do the operation in-place if it's argument is a
-    temporary expresssion.
+    temporary expression.
 
  ** The effect of comparison operators (<, >, <=, and >=) applied to
     complex numbers has changed to be consistent with the strict
     ordering defined by the `max', `min', and `sort' functions.  More
     specifically, complex numbers are compared by lexicographical
     comparison of the pairs `[abs(z), arg(z)]'.  Previously, only real
     parts were compared; this can be trivially achieved by wrapping the
     operands in real().
@@ -350,25 +350,25 @@ Summary of important user-visible change
 
       format short eng
       format long eng
 
     Both display numbers in engineering notation, i.e., mantissa +
     exponent where the exponent is a multiple of 3.
 
  ** The following functions are new in Octave 3.4:
-      accumdim   divergence   merge        ppjumps    textread
-      bitpack    erfcx        nfields      pqpnonneg  uigetdir
-      bitunpack  fileread     nth_element  quadcc     uigetfile
-      blkmm      fminbnd      onCleanup    randi      uiputfile
-      cbrt       fskipl       pbaspect     repelems   uimenu
-      curl       ifelse       pie3         reset      whitebg
-      chop       ishermitian  powerset     rsf2csf 
-      colstyle   isindex      ppder        saveas  
-      daspect    luupdate     ppint        strread 
+      accumdim   divergence   merge        ppjumps    strread 
+      bitpack    erfcx        nfields      pqpnonneg  textread
+      bitunpack  fileread     nth_element  quadcc     uigetdir
+      blkmm      fminbnd      onCleanup    randi      uigetfile
+      cbrt       fskipl       pbaspect     rectangle  uiputfile
+      curl       ifelse       pie3         repelems   uimenu
+      chop       ishermitian  powerset     reset      whitebg  
+      colstyle   isindex      ppder        rsf2csf  
+      daspect    luupdate     ppint        saveas  
 
  ** Using the image function to view images with external programs such
     as display, xv, and xloadimage is no longer supported.  The
     image_viewer function has also been removed.
 
  ** The behavior of struct assignments to non-struct values has been
     changed.  Previously, it was possible to overwrite an arbitrary
     value:
@@ -686,17 +686,17 @@ Summary of important user-visible change
     The performance of the sum, prod, sumsq, cumsum, cumprod, any, all,
     max and min functions has been significantly improved.
 
  ** Sorting and searching.
     
     The performance of sort has been improved, especially when sorting
     indices are requested.  An efficient built-in issorted
     implementation was added.  The sortrows function now uses a more
-    efficient algorithm, especially in the homegeneous case.  The lookup
+    efficient algorithm, especially in the homogeneous case.  The lookup
     function is now a built-in function performing a binary search,
     optimized for long runs of close elements.  Lookup also works with
     cell arrays of strings.
 
  ** Range arithmetics
 
     For some operations on ranges, Octave will attempt to keep the
     result as a range.  These include negation, adding a scalar,
diff --git a/NEWS.1 b/NEWS.1
--- a/NEWS.1
+++ b/NEWS.1
@@ -138,19 +138,19 @@ Summary of changes for version 1.1.0:
         -0.81742  -0.57605
 
       octave:8> x
       x =
 
       <structure: s u v>
 
     This feature should be considered experimental, but it seems to
-    work ok.  Suggestions for ways to improve it are welcome.
+    work OK.  Suggestions for ways to improve it are welcome.
 
-  * Octave now supports a limited form of exception handling modelled
+  * Octave now supports a limited form of exception handling modeled
     after the unwind-protect form of Lisp:
 
       unwind_protect
         BODY
       unwind_protect_cleanup
         CLEANUP
       end_unwind_protect
 
@@ -193,33 +193,33 @@ Summary of changes for version 1.1.0:
     without having to clutter up the if statement with continuation
     characters.
 
   * Continuation lines are now allowed in string constants and are
     handled correctly inside matrix constants.
 
   * Both `...{whitespace}\n' and `\{whitespace}\n' can be used to
     introduce continuation lines, where {whitespace} may include
-    spaces, tabs and comemnts.
+    spaces, tabs and comments.
 
   * The script directory has been split up by topic.
 
   * Dynamic linking mostly works with dld.  The following limitations
     are known problems:
 
     -- Clearing dynamically linked functions doesn't work.
 
     -- Dynamic linking only works with dld, which has not been ported
        to very many systems yet.
 
     -- Configuring with --enable-lite-kernel seems to mostly work to
        make nonessential built-in functions dynamically loaded, but
        there also seem to be some problems.  For example, fsolve seems
        to always return info == 3.  This is difficult to debug since
-       gdb won't seem to allow breakpoints to be set inside
+       GDB doesn't appear to allow breakpoints to be set inside
        dynamically loaded functions.
 
     -- Octave uses a lot of memory if the dynamically linked functions
        are compiled with -g.  This appears to be a limitation with
        dld, and can be avoided by not using -g to compile functions
        that will be linked dynamically.
 
   * fft2 and ifft2 are now built-in functions.
@@ -344,17 +344,17 @@ Summary of changes for version 1.1.0:
       ind2rgb   -- image format conversion
       loadimage -- load an image from a file
       ntsc2rgb  -- image format conversion
       ocean     -- set a color colormap
       rgb2ind   -- image format conversion
       rgb2ntsc  -- image format conversion
       saveimage -- save an image to a file
 
-  * New time and date funcitons:
+  * New time and date functions:
 
       tic          -- set wall-clock timer
       toc          -- get elapsed wall-clock time, since timer last set
       etime        -- another way to get elapsed wall-clock time
       cputime      -- get CPU time used since Octave started
       is_leap_year -- is the given year a leap year?
 
   * Other new functions:
@@ -447,17 +447,17 @@ Summary of changes for version 1.1.0:
       2
       3
       end
 
     all_va_args may be used more than once, but can only be used
     within functions that take a variable number of arguments.
 
   * If given a second argument, svd now returns an economy-sized
-    decomposition, eliminating the unecessary rows or columns of U or
+    decomposition, eliminating the unnecessary rows or columns of U or
     V.
 
   * The max and min functions correctly handle complex matrices in
     which some columns contain real values only.
 
   * The find function now handles 2 and 3 output arguments.
 
   * The qr function now allows computation of QR with pivoting.
@@ -930,17 +930,17 @@ Summary of changes for version 0.78:
 
   * Line and column information is included in more error messages.
 
 Summary of changes for version 0.77:
 -----------------------------------
 
   * Improved help.  The command `help -i topic' now uses the GNU Info
     browser to display help for the given topic directly from the
-    Texinfo documenation.
+    Texinfo documentation.
 
   * New function: chol -- Cholesky factorization.
 
 Summary of changes for version 0.76:
 -----------------------------------
 
   * Better run-time error messages.  Many now include line and column
     information indicating where the error occurred.  Octave will also
@@ -1281,17 +1281,17 @@ Summary of changes for version 0.71:
   * The command `save file' now saves all variables in the named file.
 
   * If do_fortran_indexing is 'true', indexing a scalar with
     [1,1,1,...] (n times) replicates its value n times.  The
     orientation of the resulting vector depends on the value of
     prefer_column_vectors.
 
   * Things like [[1,2][3,4]] no longer cause core dumps, and invalid
-    input like [1,2;3,4,[5,6]] now produces a diagnositic message.
+    input like [1,2;3,4,[5,6]] now produces a diagnostic message.
 
   * The cd, save, and load commands now do tilde expansion.
 
   * It's now possible to clear global variables and functions by name.
 
   * Use of clear inside functions is now a parse error.
 
 Summary of changes for version 0.70:
@@ -1375,17 +1375,17 @@ Summary of changes for version 0.67:
 
       find -- return the indices of nonzero elements.
 
   * Zero-one style indexing now works.  For example,
 
       a = [1,2,3,4];
       b = a([1,0,0,1])
 
-    sets b to the first and fourth elememnts of a.
+    sets b to the first and fourth elements of a.
 
     Zero-one style indexing also works for indexing the left hand side
     of an assignment.  For example,
 
       a = rand (1,2;3,4);
       a([0,1],:) = [-1,-2]
 
     sets the second row of a to [-1 -2]
@@ -1396,17 +1396,17 @@ Summary of changes for version 0.67:
       b = a([1,1,1,1]);
 
     is controlled by the new global variable `prefer_zero_one_indexing'.
     If this variable is equal to 'true', b will be set to [1 2 3 4].
     If it is false, b will be set to [1 1 1 1].  The default value is
     'false'.
 
   * Using the new global variable `propagate_empty_matrices', it is
-    possible to have unary andy binary operations on empty matrices
+    possible to have unary and binary operations on empty matrices
     return an empty matrix.  The default value of this variable is
     'warn', so that empty matrices are propagated but you get a
     warning.  Some functions, like eig and svd have also been changed
     to handle this.
 
   * Empty matrices can be used in conditionals, but they always
     evaluate to `false'.  With propagate_empty_matrices = 'true', both
     of the following expressions print 0: 
@@ -1589,14 +1589,14 @@ Summary of changes for version 0.50:
       win_texas_lotto  -- produce six unique random numbers between 1 and 50.
       quad             -- numerical integration.
       lu               -- LU factorization
       qr               -- QR factorization
       dassl            -- Solution of DAEs using DASSL.
 
   * New files:
 
-      THANKS -- A list of people and organazations who have supported
+      THANKS -- A list of people and organizations who have supported
                 the development of Octave.
 
       NEWS   -- This file, listing recent changes.
 
   * Help is now available at the gnuplot prompt.
diff --git a/NEWS.2 b/NEWS.2
--- a/NEWS.2
+++ b/NEWS.2
@@ -168,17 +168,17 @@ Summary of changes for version 2.1.x:
 
       cauchy_cdf         -- CDF of the Cauchy distribution
       cauchy_inv         -- Quantile function of the Cauchy distribution
       cauchy_pdf         -- PDF of the Cauchy distribution
       cauchy_rnd         -- Random deviates from the Cauchy distribution
 
       chisquare_cdf      -- CDF of the chi-square distribution
       chisquare_inv      -- Quantile function of the chi-square distribution
-      chisquare_pdf      -- PDF of the chi-sqaure distribution
+      chisquare_pdf      -- PDF of the chi-square distribution
       chisquare_rnd      -- Random deviates from the chi-square distribution
 
       discrete_cdf       -- CDF of a discrete distribution
       discrete_inv       -- Quantile function of a discrete distribution
       discrete_pdf       -- PDF of a discrete distribution
       discrete_rnd       -- Random deviates from a discrete distribution
 
       empirical_cdf      -- CDF of the empirical distribution
@@ -544,17 +544,17 @@ Summary of changes for version 2.0.5:
   * More tests.
 
 Summary of changes for version 2.0.4:
 ------------------------------------
 
   * It is now possible to use commands like ls, save, and cd as simple
     variable names.  They still cannot be used as formal parameters
     for functions, or as the names of structure variables.  Failed
-    assignments leave them undefined (you can recover the orginal
+    assignments leave them undefined (you can recover the original
     function definition using clear).
 
   * Is is now possible to invoke commands like ls, save, and cd as
     normal functions (for example, load ("foo", "x", "y", "z")).
 
 Summary of changes for version 2.0.3:
 ------------------------------------
 
@@ -977,17 +977,17 @@ Summary of changes for version 2.0:
       setpwent  -- rewind the password-file stream
       endpwent  -- close the password-file stream
 
   * Functions for getting info from the group database on Unix systems:
 
       getgrent  -- read entry from group-file stream, opening if necessary
       getgrgid  -- search for group entry with matching group ID
       getgrnam  -- search for group entry with matching group name
-      setgrent  -- rewind the pgroup-file stream
+      setgrent  -- rewind the group-file stream
       endgrent  -- close the group-file stream
 
   * The New function octave_config_info returns a structure containing
     information about how Octave was configured and compiled.
 
   * New function getrusage returns a structure containing system
     resource usage statistics.  The `cputime' function is now defined
     in an M-file using getrusage.
diff --git a/NEWS.3 b/NEWS.3
--- a/NEWS.3
+++ b/NEWS.3
@@ -55,17 +55,17 @@ Summary of important user-visible change
 	__gnuplot_splot__
 	__gnuplot_replot__
 
       Additionally, these functions no longer have any effect on plots
       created with the Matlab-style plot commands (plot, line, mesh,
       semilogx, etc.).
 
     + Plot property values are not extensively checked.  Specifying
-      invalid property values may produce unpredictible results.
+      invalid property values may produce unpredictable results.
 
     + Octave now sends data over the same pipe that is used to send
       commands to gnuplot.  While this avoids the problem of
       cluttering /tmp with data files, it is no longer possible to use
       the mouse to zoom in on plots.  This is a limitation of gnuplot,
       which is unable to zoom when the data it plots is not stored in
       a file.  Some work has been done to fix this problem in newer
       versions of gnuplot (> 4.2.2).  See for example, this thread
diff --git a/README.MacOS b/README.MacOS
--- a/README.MacOS
+++ b/README.MacOS
@@ -264,17 +264,17 @@ be installed.
 [2] Optionally the "xfig" package may be installed.
 
 
 2.3.2 Building With Dependencies Satisfied by Fink
 --------------------------------------------------
 
 After installing each of the dependencies, the sources are compiled by
 setting the proper environment variables and then following the standard build
-sequence.  The following is an example set of variables to for a 32-bit build
+sequence.  The following is an example set of variables for a 32-bit build
 using gcc-4.2.  When building from the sources obtained from the mercurial
 archive, ./autogen.sh must be run prior to ./configure.
 
   export FINK_PREFIX="/sw"
   export PREFIX="/usr/local/bin"
 
   export OPTFLAGS="-O2 -g"
   export LDFLAGS="-L$FINK_PREFIX/lib -L/usr/lib -m32"
diff --git a/README.Windows b/README.Windows
--- a/README.Windows
+++ b/README.Windows
@@ -1,11 +1,11 @@
 See the file README.Cygwin for information about installing the binary
 package of Octave for Cygwin.
 
 See the file README.MinGW for information about Octave on the MinGW platform
-including installation of binaries or compiling Octave frome source.
+including installation of binaries or compiling Octave from source.
 
 
 John W. Eaton
 jwe@octave.org
 
 Last updated: Sat Jan 22 16:56:05 PST 2011
diff --git a/doc/faq/OctaveFAQ.texi b/doc/faq/OctaveFAQ.texi
--- a/doc/faq/OctaveFAQ.texi
+++ b/doc/faq/OctaveFAQ.texi
@@ -237,17 +237,17 @@ encourage users of Octave to release the
 under terms that are compatible with the GPL.
 
 @node Requesting License Changes
 @section I wrote a program that links with Octave libraries and I don't want to release it under the terms of the GPL.  Will you change the license of the Octave libraries for me?
 
 No.  Instead of asking us to change the licensing terms for Octave, we
 recommend that you release your program under terms that are compatible
 with the GPL so that the free software community can benefit from your
-work the same as you have benefitted from the work of all the people who
+work the same as you have benefited from the work of all the people who
 have contributed to Octave.
 
 @node How can I cite Octave?
 @chapter How can I cite Octave?
 
 Pointing to @url{http://www.octave.org} is good, because that gives
 people a direct way to find out more.  If citation of a URL is not
 allowed by a publisher, or if you also want to point to a traditional
@@ -379,17 +379,17 @@ features:
 
 
 @node Octave Features
 @chapter What features are unique to Octave?
 
 @menu
 * Functions defined on the command-line::
 * Comments with #::
-* Strings delimitted by double quotes "::
+* Strings delimited by double quotes "::
 * Line continuation by backslash::
 * Informative block closing::
 * Coherent syntax::
 * Exclamation mark as not operator::
 * Increment and decrement operators::
 * Unwind-protect::
 * Built-in ODE and DAE solvers::
 @end menu
@@ -419,18 +419,18 @@ ans = Hello Moon
 @section Comments with #
 
 The pound character, @samp{#}, may be used to start comments, in
 addition to @samp{%}. See the previous example. The major advantage of
 this is that as @samp{#} is also a comment character for unix script
 files, any file that starts with a string like @samp{#! /usr/bin/octave
 -q} will be treated as an octave script and be executed by octave.
 
-@node Strings delimitted by double quotes "
-@section Strings delimitted by double quotes "
+@node Strings delimited by double quotes "
+@section Strings delimited by double quotes "
 The double quote, @samp{"}, may be used to delimit strings, in addition
 to the single quote @samp{'}. See the previous example. Also,
 double-quoted strings include backslash interpretation (like C++, C, and
 Perl) while single quoted are uninterpreted (like @sc{Matlab} and Perl).
 
 @node Line continuation by backslash
 @section Line continuation by backslash
 
@@ -508,17 +508,17 @@ value of @var{x} is 3.
 For matrix and vector arguments, the increment and decrement operators
 work on each element of the operand.
 
 @node Unwind-protect
 @section Unwind-protect
 
 @cindex Unwind-protect
 
-Octave supports a limited form of exception handling modelled after the
+Octave supports a limited form of exception handling modeled after the
 unwind-protect form of Lisp.  The general form of an
 @code{unwind_protect} block looks like this:
 
 @example
 @group
 unwind_protect
   @var{body}
 unwind_protect_cleanup
@@ -639,17 +639,17 @@ maintainers can duplicate your bug.
 Source code is available on the Octave development site, where you are
 sure to get the latest version.
 
 @itemize @bullet
 @item @url{http://www.octave.org/download.html}
 @item @url{ftp://ftp.octave.org/pub/octave/}
 @end itemize
 
-Since Octave is distrubted under the terms of the GPL, you can get
+Since Octave is distributed under the terms of the GPL, you can get
 Octave from a friend who has a copy, or from the Octave website.
 
 @node Pre-compiled binary packages
 @section Pre-compiled binary packages
 @cindex  Pre-compiled binary packages
 @cindex  Binaries
 
 The Octave project does not distribute binary packages, but other
@@ -894,17 +894,17 @@ end
 
 The main difference with @sc{Matlab} is a matter of scope. While nested
 functions have access to the parent function's scope in @sc{Matlab}, no
 such thing is available in Octave, due to how Octave essentially
 ``un-nests'' nested functions.
 
 The authors of Octave consider the nested function scoping rules of
 @sc{Matlab} to be more problems than they are worth as they introduce
-diffiult to find bugs as inadvertantly modifying a variable in a
+difficult to find bugs as inadvertently modifying a variable in a
 nested function that is also used in the parent is particularly easy.
 
 @item Differences in core syntax
 There a few core @sc{Matlab} syntaxes that are not accepted by Octave,
 these being
 
 @itemize @bullet
 @item
@@ -1028,17 +1028,17 @@ for more details.
 Octave is a community project and so the toolboxes that exist are
 donated by those interested in them through the Octave Forge website
 (@url{http://octave.sourceforge.net}). These might be lacking in certain
 functionality relative to the @sc{Matlab} toolboxes, and might not
 exactly duplicate the @sc{Matlab} functionality or interface.
 
 @item Short-circuit & and | operators
 The @code{&} and @code{|} operators in @sc{Matlab} short-circuit when
-included in an if statemant and not otherwise.  In Octave only the
+included in an if statement and not otherwise.  In Octave only the
 @code{&&} and @code{||} short circuit.  Note that this means that
 
 @example
 @group
   if (a | b)
     @dots{}
   end
 @end group
@@ -1294,17 +1294,17 @@ Octave has the operators "++", "--", "-=
 @item
 Character strings in Octave can be denoted with double or single
 quotes. There is a subtle difference between the two in that escaped
 characters like @code{\n} (newline), @code{\t} (tab), etc are
 interpreted in double quoted strings but not single quoted strings. This
 difference is important on Windows platforms where the "\" character is
 used in path names, and so single quoted strings should be used in
 paths. @sc{Matlab} doesn't have double quoted strings and so they should
-be avoided if the code will be transfered to a @sc{Matlab} user.
+be avoided if the code will be transferred to a @sc{Matlab} user.
 @end itemize
 
 @end itemize
 
 @node Index
 @appendix Concept Index
 
 @printindex cp
diff --git a/doc/interpreter/basics.txi b/doc/interpreter/basics.txi
--- a/doc/interpreter/basics.txi
+++ b/doc/interpreter/basics.txi
@@ -1054,17 +1054,17 @@ endfunction
 @end group
 @end example
 
 @noindent
 will produce a very quick countdown from '3' to 'Blast Off' as the
 lines "@code{disp(2);}" and "@code{disp(1);}" won't be executed.
 
 The block comment markers must appear alone as the only characters on a line
-(excepting whitepsace) in order to to be parsed correctly.
+(excepting whitespace) in order to to be parsed correctly.
 
 @node Comments and the Help System
 @subsection Comments and the Help System
 @cindex documenting functions
 @cindex documenting user scripts
 @cindex help, user-defined functions
 
 The @code{help} command (@pxref{Getting Help}) is able to find the first
diff --git a/doc/interpreter/doccheck/aspell-octave.en.pws b/doc/interpreter/doccheck/aspell-octave.en.pws
--- a/doc/interpreter/doccheck/aspell-octave.en.pws
+++ b/doc/interpreter/doccheck/aspell-octave.en.pws
@@ -45,16 +45,17 @@ backend
 Backends
 backends
 bartlett
 Bateman
 BDF
 bdf
 betacdf
 betainv
+betaln
 betapdf
 betarnd
 BFGS
 bigtriangledown
 Bilbert
 bincoeff
 binocdf
 binoinv
@@ -228,16 +229,17 @@ Engle's
 eof
 EOF
 EOS
 eps
 eq
 equidistributed
 equispaced
 erf
+erfc
 errno
 Errorbar
 errorbar
 Errorbars
 errorbars
 ErrorHandler
 Esmond
 et
diff --git a/doc/interpreter/install.txi b/doc/interpreter/install.txi
--- a/doc/interpreter/install.txi
+++ b/doc/interpreter/install.txi
@@ -218,17 +218,17 @@ features not generally available in all 
 Octave's makefiles to work with other make programs is probably not
 worth your time; instead, we simply recommend installing GNU Make.
 
 There are currently two options for plotting in Octave: (1) the external
 program gnuplot, or (2) the internal graphics engine using OpenGL and
 FLTK@.  Gnuplot is a command-driven interactive function plotting
 program.  Gnuplot is copyrighted, but freely distributable.  As of
 Octave release 3.4, gnuplot is the default option for plotting.  But,
-the internal graphics engine is nearly 100% compatibile, certainly for
+the internal graphics engine is nearly 100% compatible, certainly for
 most ordinary plots, and users are encouraged to test it.  It is
 anticipated that the internal engine will become the default option at
 the next major release of Octave.
 
 To compile Octave, you will need a recent version of @code{g++} or other
 ANSI C++ compiler.  In addition, you will need a Fortran 77 compiler or
 @code{f2c}.  If you use @code{f2c}, you will need a script like
 @code{fort77} that works like a normal Fortran compiler by combining
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -2507,26 +2507,29 @@ one, or by name.  Recognized color names
 
 Line styles are specified by the following properties:
 
 @table @code
 @item linestyle
 May be one of
 @table @code
 @item "-"
-Solid lines.
+Solid line.  [default]
 
 @item "--"
-Dashed lines.
+Dashed line.
 
 @item ":"
-Points.
+Dotted line.
 
 @item "-."
 A dash-dot line.
+
+@item "none"
+No line.  Points will still be marked using the current Marker Style.
 @end table
 
 @item linewidth
 A number specifying the width of the line.  The default is 1.  A value
 of 2 is twice as wide as the default, etc.
 @end table
 
 @node Marker Styles
diff --git a/doc/interpreter/sparseimages.m b/doc/interpreter/sparseimages.m
--- a/doc/interpreter/sparseimages.m
+++ b/doc/interpreter/sparseimages.m
@@ -195,17 +195,17 @@ function femimages (nm, typ)
     for idx = 1:w-1
       widx = (idx-1)*h;
       elems = [elems; widx+[(1:h-1);(2:h);h+(1:h-1)]']; 
       elems = [elems; widx+[(2:h);h+(2:h);h+(1:h-1)]']; 
     endfor
 
     E = size(elems,1);  #No. of elements
     N = size(nodes,1);  #No. of elements
-    D = size(elems,2);  #dimentions+1
+    D = size(elems,2);  #dimensions+1
 
     ## Plot FEM Geometry
     elemx = elems(:,[1,2,3,1])';
     xelems = reshape( nodes(elemx, 1), 4, E);
     yelems = reshape( nodes(elemx, 2), 4, E);
 
     ## Set element conductivity
     conductivity = [1*ones(1,16),2*ones(1,48),1*ones(1,16)];
diff --git a/doc/liboctave/array.texi b/doc/liboctave/array.texi
--- a/doc/liboctave/array.texi
+++ b/doc/liboctave/array.texi
@@ -172,17 +172,17 @@ the current size, the length is updated 
 @deftypefnx Constructor {} DiagArray<T> (int @var{n})
 @deftypefnx Constructor {} DiagArray<T> (int @var{n}, const T &@var{val})
 @deftypefnx Constructor {} DiagArray<T> (int @var{r}, int @var{c})
 @deftypefnx Constructor {} DiagArray<T> (int @var{r}, int @var{c}, const T &@var{val})
 @deftypefnx Constructor {} DiagArray<T> (const Array<T> &@var{a})
 @deftypefnx Constructor {} DiagArray<T> (const DiagArray<T> &@var{a})
 @end deftypefn
 
-@deftypeop Assginment DiagArray<T>& {} {operator =} (const DiagArray<T> &@var{a})
+@deftypeop Assignment DiagArray<T>& {} {operator =} (const DiagArray<T> &@var{a})
 @end deftypeop
 
 @deftypemethod DiagArray<T> int dim1 (void) const
 @deftypemethodx DiagArray<T> int rows (void) const
 @end deftypemethod
 
 @deftypemethod DiagArray<T> int dim2 (void) const
 @deftypemethodx DiagArray<T> int cols (void) const
diff --git a/examples/COPYING b/examples/COPYING
--- a/examples/COPYING
+++ b/examples/COPYING
@@ -1,3 +1,3 @@
-Copyright notices are intentionlly omitted from the files in the
+Copyright notices are intentionally omitted from the files in the
 examples directory.  We don't want copyright notices cluttering the
 manual.
diff --git a/scripts/audio/wavread.m b/scripts/audio/wavread.m
--- a/scripts/audio/wavread.m
+++ b/scripts/audio/wavread.m
@@ -17,19 +17,19 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{y} =} wavread (@var{filename})
 ## Load the RIFF/WAVE sound file @var{filename}, and return the samples
 ## in vector @var{y}.  If the file contains multichannel data, then
 ## @var{y} is a matrix with the channels represented as columns.
 ##
-## @deftypefnx {Function File} {[@var{y}, @var{Fs}, @var{bits}] =} wavread (@var{filename})
+## @deftypefnx {Function File} {[@var{y}, @var{Fs}, @var{bps}] =} wavread (@var{filename})
 ## Additionally return the sample rate (@var{fs}) in Hz and the number of bits
-## per sample (@var{bits}).
+## per sample (@var{bps}).
 ##
 ## @deftypefnx {Function File} {[@dots{}] =} wavread (@var{filename}, @var{n})
 ## Read only the first @var{n} samples from each channel.
 ##
 ## @deftypefnx {Function File} {[@dots{}] =} wavread (@var{filename}, @var{n1} @var{n2})
 ## Read only samples @var{n1} through @var{n2} from each channel.
 ##
 ## @deftypefnx {Function File} {[@var{samples}, @var{channels}] =} wavread (@var{filename}, "size")
@@ -70,17 +70,17 @@ function [y, samples_per_sec, bits_per_s
   riff_size = find_chunk (fid, "RIFF", file_size);
   riff_pos = ftell (fid);
   if (riff_size == -1)
     fclose (fid);
     error ("wavread: file contains no RIFF chunk");
   endif
 
   riff_type = char (fread (fid, 4))';
-  if(! strcmp (riff_type, "WAVE"))
+  if (! strcmp (riff_type, "WAVE"))
     fclose (fid);
     error ("wavread: file contains no WAVE signature");
   endif
   riff_pos = riff_pos + 4;
   riff_size = riff_size - 4;
 
   ## Find format chunk inside the RIFF chunk.
   fseek (fid, riff_pos, "bof");
@@ -152,34 +152,34 @@ function [y, samples_per_sec, bits_per_s
                bits_per_sample);
     endswitch
   endif
 
   ## Parse arguments.
   if (nargin == 1)
     length = 8 * data_size / bits_per_sample;
   else
-    nparams = size (param, 2);
+    nparams = numel (param);
     if (nparams == 1)
       ## Number of samples is given.
       length = param * channels;
     elseif (nparams == 2)
       ## Sample range is given.
       if (fseek (fid, (param(1)-1) * channels * (bits_per_sample/8), "cof") < 0)
         warning ("wavread: seeking failed");
       endif
       length = (param(2)-param(1)+1) * channels;
     elseif (nparams == 4 && char (param) == "size")
       ## Size of the file is requested.
       fclose (fid);
       y = [data_size/channels/(bits_per_sample/8), channels];
       return;
     else
       fclose (fid);
-      error ("wavread: invalid argument 2");
+      error ("wavread: invalid PARAM argument");
     endif
   endif
 
   ## Read samples and close file.
   if (bits_per_sample == 24)
     length *= 3;
   endif
   [yi, n] = fread (fid, length, format, 0, BYTEORDER);
@@ -196,23 +196,23 @@ function [y, samples_per_sec, bits_per_s
     yi(yi(:,3) >= 128, 3) -= 256;
     yi = yi * [1; 256; 65536];
   endif
 
   if (format_tag == FORMAT_PCM)
     ## Normalize samples.
     switch (bits_per_sample)
       case 8
-        yi = (yi - 128)/127;
+        yi = (yi - 128)/128;
       case 16
-        yi /= 32767;
+        yi /= 32768;
       case 24
-        yi /= 8388607;
+        yi /= 8388608;
       case 32
-        yi /= 2147483647;
+        yi /= 2147483648;
     endswitch
   endif
 
   ## Deinterleave.
   nr = numel (yi) / channels;
   y = reshape (yi, channels, nr)';
 
 endfunction
@@ -234,8 +234,13 @@ function chunk_size = find_chunk (fid, c
     ## Chunk sizes must be word-aligned (2 byte)
     chunk_size += rem (chunk_size, 2);
     offset = offset + 8 + chunk_size;
   endwhile
   if (! strcmp (id, chunk_id))
     chunk_size = -1;
   endif
 endfunction
+
+
+%% Tests for wavread/wavwrite pair are in wavrite.m
+%!assert(1)  # stop fntests.m from reporting no tests for wavread
+
diff --git a/scripts/audio/wavwrite.m b/scripts/audio/wavwrite.m
--- a/scripts/audio/wavwrite.m
+++ b/scripts/audio/wavwrite.m
@@ -13,98 +13,79 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} wavwrite (@var{y}, @var{filename})
-## @deftypefnx {Function File} {} wavwrite (@var{y}, @var{fs}, @var{filename})
-## @deftypefnx {Function File} {} wavwrite (@var{y}, @var{fs}, @var{bits}, @var{filename})
+## @deftypefnx {Function File} {} wavwrite (@var{y}, @var{Fs}, @var{filename})
+## @deftypefnx {Function File} {} wavwrite (@var{y}, @var{Fs}, @var{bps}, @var{filename})
 ## Write @var{y} to the canonical RIFF/WAVE sound file @var{filename}
-## with sample rate @var{fs} and bits per sample @var{bits}.  The
+## with sample rate @var{Fs} and bits per sample @var{bps}.  The
 ## default sample rate is 8000 Hz with 16-bits per sample.  Each column
 ## of the data represents a separate channel.
 ## @seealso{wavread}
 ## @end deftypefn
 
 ## Author: Michael Zeising <michael@michaels-website.de>
 ## Created: 06 December 2005
 
 function wavwrite (y, varargin)
 
   BYTEORDER = "ieee-le";
 
-  ## For backward compatibility with previous versions of Octave, also
-  ## accept the inputs
-  ##
-  ##   wavwrite (filename, y)
-  ##   wavwrite (filename, y, fs)
-  ##   wavwrite (filename, y, fs, bits)
-
   if (nargin < 2 || nargin > 4)
     print_usage ();
   endif
 
   ## Defaults.
   samples_per_sec = 8000;
   bits_per_sample = 16;
 
-  if (ischar (y))
-    filename = y;
-    y = varargin{1};
-    if (nargin > 2)
-      samples_per_sec = varargin{2};
-      if (nargin > 3)
-        bits_per_sample = varargin{3};
-      endif
-    endif
-  else
-    filename = varargin{end};
-    if (nargin > 2)
-      samples_per_sec = varargin{1};
-      if (nargin > 3)
-        bits_per_sample = varargin{2};
-      endif
+  filename = varargin{end};
+  if (nargin > 2)
+    samples_per_sec = varargin{1};
+    if (nargin > 3)
+      bits_per_sample = varargin{2};
     endif
   endif
 
   ## test arguments
   if (columns (y) < 1)
     error ("wavwrite: Y must have at least one column");
   endif
-  if (columns (y) > 2^15-1)
+  if (columns (y) > 0x7FFF)
     error ("wavwrite: Y has more than 32767 columns (too many for a WAV-file)");
   endif
 
   ## determine sample format
   switch (bits_per_sample)
     case 8
       format = "uint8";
     case 16
       format = "int16";
     case 32
       format = "int32";
     otherwise
       error ("wavwrite: sample resolution not supported");
   endswitch
 
   ## calculate filesize
-  [n, channels] = size(y);
+  [n, channels] = size (y);
 
   ## size of data chunk
   ck_size = n*channels*(bits_per_sample/8);
 
-  ## open file for writing binary
-
   if (! ischar (filename))
     error ("wavwrite: expecting FILENAME to be a character string");
   endif
 
+  ## open file for writing binary
   [fid, msg] = fopen (filename, "wb");
   if (fid < 0)
     error ("wavwrite: %s", msg);
   endif
 
   ## write RIFF/WAVE header
   c = 0;
   c += fwrite (fid, "RIFF", "uchar");
@@ -121,18 +102,18 @@ function wavwrite (y, varargin)
 
   ## channels
   c += fwrite (fid, channels, "uint16", 0, BYTEORDER);
 
   ## sample rate
   c += fwrite (fid, samples_per_sec, "uint32", 0, BYTEORDER);
 
   ## bytes per second
-  bps = samples_per_sec*channels*bits_per_sample/8;
-  c += fwrite (fid, bps, "uint32", 0, BYTEORDER);
+  byteps = samples_per_sec*channels*bits_per_sample/8;
+  c += fwrite (fid, byteps, "uint32", 0, BYTEORDER);
 
   ## block align
   c += fwrite (fid, channels*bits_per_sample/8, "uint16", 0, BYTEORDER);
 
   c += fwrite (fid, bits_per_sample, "uint16", 0, BYTEORDER);
   c += fwrite (fid, "data", "uchar");
   c += fwrite (fid, ck_size, "uint32", 0, BYTEORDER);
 
@@ -142,48 +123,58 @@ function wavwrite (y, varargin)
   endif
 
   ## interleave samples
   yi = reshape (y', n*channels, 1);
 
   ## scale samples
   switch (bits_per_sample)
     case 8
-      yi = round (yi*127 + 128);
+      yi = round (yi*128 + 128);
     case 16
-      yi = round (yi*32767);
+      yi = round (yi*32768);
     case 32
-      yi = round (yi*2147483647);
+      yi = round (yi*2147483648);
   endswitch
 
   ## write to file
   c = fwrite (fid, yi, format, 0, BYTEORDER);
 
   fclose (fid);
 
 endfunction
 
+
 %!test
-%! A = [1:10; 1:10]/10;
-%! wavwrite("a.wav", A);
-%! [B, samples_per_sec, bits_per_sample] = wavread("a.wav");
-%! assert(A,B, 10^(-4));
+%! A = [-1:0.1:1; -1:0.1:1];
+%! wavwrite (A, "a.wav");
+%! [B, samples_per_sec, bits_per_sample] = wavread ("a.wav");
+%! assert(A,B, 1/2^15);
 %! assert(samples_per_sec, 8000);
 %! assert(bits_per_sample, 16);
 %! delete ("a.wav");
 %
 %!test
-%! A=[1:10; 1:10] / 10;
-%! wavwrite("a.wav", A, 4000);
-%! [B, samples_per_sec, bits_per_sample] = wavread("a.wav");
-%! assert(A,B, 10^(-4));
+%! A = [-1:0.1:1; -1:0.1:1];
+%! wavwrite (A, 4000, "a.wav");
+%! [B, samples_per_sec, bits_per_sample] = wavread ("a.wav");
+%! assert(A,B, 1/2^15);
 %! assert(samples_per_sec, 4000);
 %! assert(bits_per_sample, 16);
 %! delete ("a.wav");
 %
 %!test
-%! A=[1:10; 1:10] / 10;
-%! wavwrite("a.wav", A, 4000, 8);
-%! [B, samples_per_sec, bits_per_sample] = wavread("a.wav");
-%! assert(A,B, 10^(-2));
+%! A = [-1:0.1:1; -1:0.1:1];
+%! wavwrite (A, 4000, 8, "a.wav");
+%! [B, samples_per_sec, bits_per_sample] = wavread ("a.wav");
+%! assert(A,B, 1/128);
 %! assert(samples_per_sec, 4000);
 %! assert(bits_per_sample, 8);
 %! delete ("a.wav");
+%
+%!test
+%! A = [-2:2];
+%! wavwrite (A, "a.wav");
+%! B = wavread ("a.wav");
+%! B *= 32768;
+%! assert(B, [-32768 -32768 0 32767 32767]);
+%! delete ("a.wav");
+
diff --git a/scripts/miscellaneous/unimplemented.m b/scripts/miscellaneous/unimplemented.m
--- a/scripts/miscellaneous/unimplemented.m
+++ b/scripts/miscellaneous/unimplemented.m
@@ -324,17 +324,16 @@ function list = missing_functions ()
   "profsave",
   "propedit",
   "propertyeditor",
   "publish",
   "qmr",
   "quad2d",
   "questdlg",
   "rbbox",
-  "rectangle",
   "recycle",
   "reducepatch",
   "reducevolume",
   "resample",
   "rgbplot",
   "rmpref",
   "root",
   "rotate",
diff --git a/scripts/plot/module.mk b/scripts/plot/module.mk
--- a/scripts/plot/module.mk
+++ b/scripts/plot/module.mk
@@ -136,16 +136,17 @@ plot_FCN_FILES = \
   plot/plot.m \
   plot/plot3.m \
   plot/plotmatrix.m \
   plot/plotyy.m \
   plot/polar.m \
   plot/print.m \
   plot/quiver.m \
   plot/quiver3.m \
+  plot/rectangle.m \
   plot/refresh.m \
   plot/refreshdata.m \
   plot/ribbon.m \
   plot/rose.m \
   plot/saveas.m \
   plot/scatter.m \
   plot/scatter3.m \
   plot/semilogx.m \
diff --git a/scripts/plot/rectangle.m b/scripts/plot/rectangle.m
new file mode 100644
--- /dev/null
+++ b/scripts/plot/rectangle.m
@@ -0,0 +1,221 @@
+## Copyright (C) 2011 David Bateman
+##
+## This file is part of Octave.
+##
+## Octave is free software; you can redistribute it and/or modify it
+## under the terms of the GNU General Public License as published by
+## the Free Software Foundation; either version 3 of the License, or (at
+## your option) any later version.
+##
+## Octave is distributed in the hope that it will be useful, but
+## WITHOUT ANY WARRANTY; without even the implied warranty of
+## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+## General Public License for more details.
+##
+## You should have received a copy of the GNU General Public License
+## along with Octave; see the file COPYING.  If not, see
+## <http://www.gnu.org/licenses/>.
+
+## -*- texinfo -*-
+## @deftypefn  {Function File} {} rectangle ()
+## @deftypefnx {Function File} {} rectangle (@dots{}, "Position", @var{pos})
+## @deftypefnx {Function File} {} rectangle (@dots{}, "Curvature", @var{curv})
+## @deftypefnx {Function File} {} rectangle (@dots{}, "EdgeColor", @var{ec})
+## @deftypefnx {Function File} {} rectangle (@dots{}, "FaceColor", @var{fc})
+## @deftypefnx {Function File} {@var{h} =} rectangle (@dots{})
+##
+## Draw rectangular patch defined by @var{pos} and @var{curv}.  The variable
+## @code{@var{pos}(1 : 2)} defines the lower left-hand corner of the patch
+## and @code{@var{pos}(3 : 4)} its width and height.  By default the value of
+## @var{pos} is @var{[0, 0, 1, 1]}.
+##
+## The variable @var{curv} defines the curvature of the sides of the rectangle
+## and it can be a scalar or two-element vector with values between 0 and 1.
+## A value of 0 represents no curvature of the side, where as a value of 1
+## means that the rectangular side is entirely curved into an arc of a circle.
+## If curvature is a two-element vector, then the first element is the 
+## curvature along the x-axis of the patch and the second along y-axis.
+##
+## If @var{curv} is a scalar, it represents the curvature of the shorter of the
+## two sides of the rectangle and the curvature of the other side is defined
+## by
+##
+## @example
+## min (pos (1: 2)) / max (pos (1:2)) * curv
+## @end example
+##
+## Other properties are passed to the underlying patch command.  If called 
+## with an output argument, @code{rectangle} returns the handle to the 
+## rectangle.
+## @end deftypefn
+## @seealso{patch}
+
+function h = rectangle (varargin)
+
+  [hax, varargin] = __plt_get_axis_arg__ ("rectangle", varargin{:});
+
+  tmp =  __rectangle__ (hax, varargin{:});
+
+  if (nargout > 0)
+    h = tmp;
+  endif
+endfunction
+
+function hg = __rectangle__ (hax, varargin)
+
+  iarg = 1;
+  pos = [0, 0, 1, 1];
+  curv2 = [0, 0];
+  ec = [0, 0, 0];
+  fc = "none";
+
+  while (iarg < length (varargin))
+    arg = varargin{iarg};
+    if (ischar(arg))
+      if (strcmpi (arg, "position"))
+        pos = varargin{iarg+1};
+        varargin(iarg:iarg+1) = [];
+        if (!isvector (pos) || numel (pos) != 4)
+          error ("rectangle: position must be a 4 element vector");
+        endif
+      elseif (strcmpi (arg, "curvature"))
+        curv2 = varargin{iarg+1};
+        varargin(iarg:iarg+1) = [];
+        if (!isnumeric (curv2) || (numel (curv2) != 1 && numel (curv2) != 2))
+          error ("rectangle: curvature must be a 2 element vector or a scalar");
+        endif
+        if (any (curv2 < 0) || any (curv2 > 1))
+          error ("rectangle: curvature values must be between 0 and 1");
+        endif
+      elseif (strcmpi (arg, "edgecolor"))
+        ec = varargin{iarg+1};
+        varargin(iarg:iarg+1) = [];
+      elseif (strcmpi (arg, "facecolor"))
+        fc = varargin{iarg+1};
+        varargin(iarg:iarg+1) = [];
+      else
+        iarg ++;
+      endif
+    else
+      iarg ++;
+    endif
+  endwhile
+
+  if (numel (curv2) == 1)
+    [a, ai] = min (pos (3 : 4));
+    [b, bi] = max (pos (3 : 4));
+    if (ai < bi)
+      curv = [curv2, curv2 .* a ./ b];
+    else
+      curv = [curv2 .* a ./ b, curv2];
+    endif
+  else
+    curv = curv2;
+  endif
+
+  if (all (curv) < 0.01)
+    ## Special case : no curvature
+    x = [pos(1), pos(1) + pos(3), pos(1) + pos(3), pos(1), pos(1)];
+    y = [pos(2), pos(2), pos(2) + pos(4), pos(2) + pos(4), pos(2)];
+  else
+    p = pi / 2 * [0 : 15] / 15;
+    c = curv .* pos(3 : 4) / 2;
+    cx = c(1) * sin (p) - c(1);
+    cy = c(2) * cos (p) - c(2);
+    x = [pos(1) - fliplr(cx), pos(1) + pos(3) + cx, ...
+         pos(1) + pos(3) + fliplr(cx), pos(1) - cx, pos(1)];
+    y = [pos(2) - fliplr(cy), pos(2) - cy, pos(2) + pos(4) + fliplr(cy), ...
+         pos(2) + pos(4) + cy, pos(2) + c(2)];
+  endif
+
+  hg = hggroup ();
+
+  h = patch ("xdata", x(:), "ydata", y(:), "facecolor", fc, "edgecolor", ec, ...
+             "parent", hg, varargin{:});
+
+  addproperty ("curvature", hg, "data", curv2);
+  addproperty ("position",  hg, "data", pos);
+  addproperty ("edgecolor", hg, "patchedgecolor", get (h, "edgecolor"));
+  addproperty ("linewidth", hg, "patchlinewidth", get (h, "linewidth"));
+  addproperty ("linestyle", hg, "patchlinestyle", get (h, "linestyle"));
+  addproperty ("facecolor", hg, "patchfacecolor", get (h, "facecolor"));
+
+  addlistener (hg, "curvature", @update_data);
+  addlistener (hg, "position",  @update_data);
+  addlistener (hg, "edgecolor", @update_props);
+  addlistener (hg, "linewidth", @update_props);
+  addlistener (hg, "linestyle", @update_props);
+  addlistener (hg, "facecolor", @update_props);
+endfunction
+
+function update_data (h, d)
+  persistent recursion = false;
+
+  ## Don't allow recursion
+  if (!recursion)
+    unwind_protect
+      recursion = true;
+
+      kids = get (h, "children");
+      pos = get (h, "position");
+      curv2 = get (h, "curvature");
+
+      if (numel (curv2) == 1)
+        [a, ai] = min (pos (3 : 4));
+        [b, bi] = max (pos (3 : 4));
+        if (ai < bi)
+          curv = [curv2, curv2 .* a ./ b];
+        else
+          curv = [curv2 .* a ./ b, curv2];
+        endif
+      else
+        curv = curv2;
+      endif
+
+      if (all (curv) < 0.01)
+        ## Special case : no curvature
+        x = [pos(1), pos(1) + pos(3), pos(1) + pos(3), pos(1), pos(1)];
+        y = [pos(2), pos(2), pos(2) + pos(4), pos(2) + pos(4), pos(2)];
+      else
+        p = pi / 2 * [0 : 15] / 15;
+        c = curv .* pos(3 : 4) / 2;
+        cx = c(1) * sin (p) - c(1);
+        cy = c(2) * cos (p) - c(2);
+        x = [pos(1) - fliplr(cx), pos(1) + pos(3) + cx, ...
+             pos(1) + pos(3) + fliplr(cx), pos(1) - cx, pos(1)];
+        y = [pos(2) - fliplr(cy), pos(2) - cy, pos(2) + pos(4) + fliplr(cy), ...
+             pos(2) + pos(4) + cy, pos(2) + c(2)];
+      endif
+
+      set (kids, "xdata", x, "ydata", y);
+    unwind_protect_cleanup
+      recursion = false;
+    end_unwind_protect
+  endif
+endfunction
+
+function update_props (h, d)
+  kids = get (h, "children");
+  set (kids, "edgecolor", get (h, "edgecolor"),
+       "linewidth", get (h, "linewidth"),
+       "linestyle", get (h, "linestyle"),
+       "facecolor", get (h, "facecolor"));
+endfunction
+
+
+%!demo
+%! close all
+%! axis equal
+%! rectangle ("Position", [0.05, 0.05, 0.9, 0.9], "Curvature", [0.5, 0.5]);
+
+%!demo
+%! close all
+%! axis equal
+%! rectangle ("Position", [0.05, 0.05, 0.9, 0.4], "Curvature", 1.0);
+
+%!demo
+%! close all
+%! axis equal
+%! h = rectangle ("Position", [0.05, 0.05, 0.9, 0.4], "Curvature",  1.0);
+%! set (h, "FaceColor", [0, 1, 0]);
+
diff --git a/scripts/statistics/distributions/geornd.m b/scripts/statistics/distributions/geornd.m
--- a/scripts/statistics/distributions/geornd.m
+++ b/scripts/statistics/distributions/geornd.m
@@ -55,17 +55,17 @@ function rnd = geornd (p, r, c)
       error ("geornd: R must be a positive integer or vector");
     endif
 
     if (any (size (p) != 1)
         && ((length (size (p)) != length (sz)) || any (size (p) != sz)))
       error ("geornd: n must be scalar or of size SZ");
     endif
   elseif (nargin == 1)
-    sz = size(n);
+    sz = size(p);
   elseif (nargin != 1)
     print_usage ();
   endif
 
 
   if (isscalar (p))
     if (p < 0 || p > 1)
       rnd = NaN (sz);
diff --git a/scripts/statistics/distributions/unifpdf.m b/scripts/statistics/distributions/unifpdf.m
--- a/scripts/statistics/distributions/unifpdf.m
+++ b/scripts/statistics/distributions/unifpdf.m
@@ -48,17 +48,17 @@ function pdf = unifpdf (x, a, b)
   sz = size (x);
   pdf = zeros (sz);
 
   k = find (isnan (x) | !(a < b));
   if (any (k))
     pdf(k) = NaN;
   endif
 
-  k = find ((x > a) & (x < b));
+  k = find ((x >= a) & (x <= b));
   if (any (k))
     if (isscalar (a) && isscalar(b))
       pdf(k) = 1 ./ (b - a);
     else
       pdf(k) = 1 ./ (b(k) - a(k));
     endif
   endif
 
diff --git a/scripts/statistics/distributions/wblinv.m b/scripts/statistics/distributions/wblinv.m
--- a/scripts/statistics/distributions/wblinv.m
+++ b/scripts/statistics/distributions/wblinv.m
@@ -48,17 +48,17 @@ function inv = wblinv (x, scale, shape)
   endif
 
   inv = NaN (size (x));
 
   ok = ((scale > 0) & (scale < Inf) & (shape > 0) & (shape < Inf));
 
   k = find ((x == 0) & ok);
   if (any (k))
-    inv(k) = -Inf;
+    inv(k) = 0;
   endif
 
   k = find ((x > 0) & (x < 1) & ok);
   if (any (k))
     if (isscalar (scale) && isscalar (shape))
       inv(k) = scale * (- log (1 - x(k))) .^ (1 / shape);
     else
       inv(k) = scale(k) .* (- log (1 - x(k))) .^ (1 ./ shape(k));
diff --git a/scripts/statistics/distributions/wblpdf.m b/scripts/statistics/distributions/wblpdf.m
--- a/scripts/statistics/distributions/wblpdf.m
+++ b/scripts/statistics/distributions/wblpdf.m
@@ -57,22 +57,22 @@ function pdf = wblpdf (x, scale, shape)
     if (retval > 0)
       error ("wblpdf: X, SCALE and SHAPE must be of common size or scalar");
     endif
   endif
 
   pdf = NaN (size (x));
   ok = ((scale > 0) & (scale < Inf) & (shape > 0) & (shape < Inf));
 
-  k = find ((x > -Inf) & (x <= 0) & ok);
+  k = find ((x > -Inf) & (x < 0) & ok);
   if (any (k))
     pdf(k) = 0;
   endif
 
-  k = find ((x > 0) & (x < Inf) & ok);
+  k = find ((x >= 0) & (x < Inf) & ok);
   if (any (k))
     if (isscalar (scale) && isscalar (shape))
       pdf(k) = (shape .* (scale .^ -shape)
                 .* (x(k) .^ (shape - 1))
                 .* exp(- (x(k) / scale) .^ shape));
     else
       pdf(k) = (shape(k) .* (scale(k) .^ -shape(k))
                 .* (x(k) .^ (shape(k) - 1))
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -451,29 +451,20 @@ H(z) = {\\displaystyle\\sum_{k=0}^M d_{k
                   for (int i = dim; i > 0; i--)
                     si_dims(i) = si_dims(i-1);
                   si_dims(0) = si_len;
 
                   si.resize (si_dims, 0.0);
                 }
               else
                 {
-                  dim_vector si_dims = args (3).dims ();
-                  bool si_is_vector = true;
-                  for (int i = 0; i < si_dims.length (); i++)
-                    if (si_dims(i) != 1 && si_dims(i) < si_dims.numel ())
-                      {
-                        si_is_vector = false;
-                        break;
-                      }
-
                   si = args(3).float_complex_array_value ();
 
-                  if (si_is_vector)
-                    si = si.reshape (dim_vector (1, si.numel ()));
+                  if (si.is_vector () && x.is_vector ())
+                    si = si.reshape (dim_vector (si.numel (), 1));
                 }
 
               if (! error_state)
                 {
                   FloatComplexNDArray y (filter (b, a, x, si, dim));
 
                   if (nargout == 2)
                     retval(1) = si;
@@ -508,29 +499,20 @@ H(z) = {\\displaystyle\\sum_{k=0}^M d_{k
                   for (int i = dim; i > 0; i--)
                     si_dims(i) = si_dims(i-1);
                   si_dims(0) = si_len;
 
                   si.resize (si_dims, 0.0);
                 }
               else
                 {
-                  dim_vector si_dims = args (3).dims ();
-                  bool si_is_vector = true;
-                  for (int i = 0; i < si_dims.length (); i++)
-                    if (si_dims(i) != 1 && si_dims(i) < si_dims.numel ())
-                      {
-                        si_is_vector = false;
-                        break;
-                      }
-
                   si = args(3).complex_array_value ();
 
-                  if (si_is_vector)
-                    si = si.reshape (dim_vector (1, si.numel ()));
+                  if (si.is_vector () && x.is_vector ())
+                    si = si.reshape (dim_vector (si.numel (), 1));
                 }
 
               if (! error_state)
                 {
                   ComplexNDArray y (filter (b, a, x, si, dim));
 
                   if (nargout == 2)
                     retval(1) = si;
@@ -568,29 +550,20 @@ H(z) = {\\displaystyle\\sum_{k=0}^M d_{k
                   for (int i = dim; i > 0; i--)
                     si_dims(i) = si_dims(i-1);
                   si_dims(0) = si_len;
 
                   si.resize (si_dims, 0.0);
                 }
               else
                 {
-                  dim_vector si_dims = args (3).dims ();
-                  bool si_is_vector = true;
-                  for (int i = 0; i < si_dims.length (); i++)
-                    if (si_dims(i) != 1 && si_dims(i) < si_dims.numel ())
-                      {
-                        si_is_vector = false;
-                        break;
-                      }
-
                   si = args(3).float_array_value ();
 
-                  if (si_is_vector)
-                    si = si.reshape (dim_vector (1, si.numel ()));
+                  if (si.is_vector () && x.is_vector ())
+                    si = si.reshape (dim_vector (si.numel (), 1));
                 }
 
               if (! error_state)
                 {
                   FloatNDArray y (filter (b, a, x, si, dim));
 
                   if (nargout == 2)
                     retval(1) = si;
@@ -625,29 +598,20 @@ H(z) = {\\displaystyle\\sum_{k=0}^M d_{k
                   for (int i = dim; i > 0; i--)
                     si_dims(i) = si_dims(i-1);
                   si_dims(0) = si_len;
 
                   si.resize (si_dims, 0.0);
                 }
               else
                 {
-                  dim_vector si_dims = args (3).dims ();
-                  bool si_is_vector = true;
-                  for (int i = 0; i < si_dims.length (); i++)
-                    if (si_dims(i) != 1 && si_dims(i) < si_dims.numel ())
-                      {
-                        si_is_vector = false;
-                        break;
-                      }
-
                   si = args(3).array_value ();
 
-                  if (si_is_vector)
-                    si = si.reshape (dim_vector (1, si.numel ()));
+                  if (si.is_vector () && x.is_vector ())
+                    si = si.reshape (dim_vector (si.numel (), 1));
                 }
 
               if (! error_state)
                 {
                   NDArray y (filter (b, a, x, si, dim));
 
                   if (nargout == 2)
                     retval(1) = si;
@@ -744,13 +708,18 @@ filter (MArray<FloatComplex>&, MArray<Fl
 %!  a = [1,1]; b=[1,1];
 %!  x = zeros (4,4,2); x(1,1:4,1) = +1; x(1,1:4,2) = -1;
 %!  y0 = zeros (4,4,2); y0(1:2,1:4,1) = +1; y0(1:2,1:4,2) = -1;
 %!  y = filter (b, [1], x);
 %!  assert(y, y0);
 %!
 %!assert(filter (1, ones(10,1)/10, []), []);
 %!assert(filter (1, ones(10,1)/10, zeros(0,10)), zeros(0,10));
+%!assert(filter (1, ones(10,1)/10, single (1:5)), repmat (single (10), 1, 5));
+%% Test using initial conditions
+%!assert(filter([1, 1, 1], [1, 1], [1 2], [1, 1]), [2 2]);
+%!assert(filter([1, 1, 1], [1, 1], [1 2], [1, 1]'), [2 2]);
 %!assert(filter([1, 3], [1], [1 2; 3 4; 5 6], [4, 5]), [5 7; 6 10; 14 18]);
-%!assert(filter (1, ones(10,1)/10, single (1:5)), repmat (single (10), 1, 5));
+%!error (filter([1, 3], [1], [1 2; 3 4; 5 6], [4, 5]'));
+%!assert(filter([1, 3, 2], [1], [1 2; 3 4; 5 6], [1 0 0; 1 0 0], 2), [2 6; 3 13; 5 21]);
 %%  Should put some tests of the "DIM" parameter in here.
 
 */
diff --git a/src/DLD-FUNCTIONS/str2double.cc b/src/DLD-FUNCTIONS/str2double.cc
--- a/src/DLD-FUNCTIONS/str2double.cc
+++ b/src/DLD-FUNCTIONS/str2double.cc
@@ -239,18 +239,21 @@ the brackets indicate optional arguments
 digits.  The special input values @code{Inf}, @code{NaN}, and @code{NA} are\n\
 also accepted.\n\
 \n\
 @var{s} may also be a character matrix, in which case the conversion is\n\
 repeated for each row.  Or @var{s} may be a cell array of strings, in which\n\
 case each element is converted and an array of the same dimensions is\n\
 returned.\n\
 \n\
-@code{str2double} can replace @code{str2num}, and it avoids the use of\n\
-@code{eval} on unknown data.\n\
+@code{str2double} returns NaN for elements of @var{s} which cannot be\n\
+converted.\n\
+\n\
+@code{str2double} can replace @code{str2num}, and it avoids the security\n\
+risk of using @code{eval} on unknown data.\n\
 @seealso{str2num}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       if (args(0).is_string ())
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -1475,55 +1475,54 @@ initialize_default_warning_state (void)
   set_warning_state ("Octave:allow-noninteger-ranges-as-indices", "error");
 }
 
 DEFUN (lasterror, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{lasterr} =} lasterror ()\n\
 @deftypefnx {Built-in Function} {} lasterror (@var{err})\n\
 @deftypefnx {Built-in Function} {} lasterror ('reset')\n\
-Query or set the last error message.  Called without any arguments\n\
-returns a structure containing the last error message, as well as other\n\
-information related to this error.  The elements of this structure are:\n\
+Query or set the last error message structure.  When called without arguments\n\
+, return a structure containing the last error message and other\n\
+information related to this error.  The elements of the structure are:\n\
 \n\
 @table @asis\n\
 @item 'message'\n\
 The text of the last error message\n\
 \n\
 @item 'identifier'\n\
 The message identifier of this error message\n\
 \n\
 @item 'stack'\n\
-A structure containing information on where the message occurred.  This might\n\
-be an empty structure if this in the case where this information cannot\n\
-be obtained.  The fields of this structure are:\n\
+A structure containing information on where the message occurred.  This may\n\
+be an empty structure if the information cannot\n\
+be obtained.  The fields of the structure are:\n\
 \n\
 @table @asis\n\
 @item 'file'\n\
 The name of the file where the error occurred\n\
 \n\
 @item 'name'\n\
 The name of function in which the error occurred\n\
 \n\
 @item 'line'\n\
 The line number at which the error occurred\n\
 \n\
 @item 'column'\n\
 An optional field with the column number at which the error occurred\n\
 @end table\n\
 @end table\n\
 \n\
-The @var{err} structure may also be passed to @code{lasterror} to set the\n\
-information about the last error.  The only constraint on @var{err} in that\n\
-case is that it is a scalar structure.  Any fields of @var{err} that match\n\
-the above are set to the value passed in @var{err}, while other fields are\n\
+The last error structure may be set by passing a scalar structure, @var{err},\n\
+as input.  Any fields of @var{err} that match those above are set while any\n\
+unspecified fields are initialized with default values.\n\
+\n\
+If @code{lasterror} is called with the argument 'reset', all fields are\n\
 set to their default values.\n\
-\n\
-If @code{lasterror} is called with the argument 'reset', all values take\n\
-their default values.\n\
+@seealso{lasterr}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length();
 
   unwind_protect frame;
 
   frame.protect_var (error_state);
@@ -1631,20 +1630,24 @@ their default values.\n\
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (lasterr, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {[@var{msg}, @var{msgid}] =} lasterr (@var{msg}, @var{msgid})\n\
-Without any arguments, return the last error message.  With one\n\
+@deftypefn  {Built-in Function} {[@var{msg}, @var{msgid}] =} lasterr ()\n\
+@deftypefnx {Built-in Function} {} lasterr (@var{msg})\n\
+@deftypefnx {Built-in Function} {} lasterr (@var{msg}, @var{msgid})\n\
+Query or set the last error message.  When called without input arguments,\n\
+return the last error message and message identifier.  With one\n\
 argument, set the last error message to @var{msg}.  With two arguments,\n\
 also set the last message identifier.\n\
+@seealso{lasterror}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   unwind_protect frame;
 
   frame.protect_var (error_state);
   error_state = 0;
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -1959,18 +1959,19 @@ Lock the current function into memory so
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (munlock, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} munlock (@var{fcn})\n\
-Unlock the named function.  If no function is named\n\
+@deftypefn  {Built-in Function} {} munlock ()\n\
+@deftypefnx {Built-in Function} {} munlock (@var{fcn})\n\
+Unlock the named function @var{fcn}.  If no function is named\n\
 then unlock the current function.\n\
 @seealso{mlock, mislocked, persistent}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length() == 1)
     {
@@ -1994,19 +1995,20 @@ then unlock the current function.\n\
     print_usage ();
 
   return retval;
 }
 
 
 DEFUN (mislocked, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} mislocked (@var{fcn})\n\
-Return true if the named function is locked.  If no function is named\n\
-then return true if the current function is locked.\n\
+@deftypefn  {Built-in Function} {} mislocked ()\n\
+@deftypefnx {Built-in Function} {} mislocked (@var{fcn})\n\
+Return true if the named function @var{fcn} is locked.  If no function is\n\
+named then return true if the current function is locked.\n\
 @seealso{mlock, munlock, persistent}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length() == 1)
     {
       std::string name = args(0).string_value ();
