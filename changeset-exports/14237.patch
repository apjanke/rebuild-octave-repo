# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1327093193 28800
#      Fri Jan 20 12:59:53 2012 -0800
# Node ID 11949c9795a0517a4febe365de454ac8f44e1d3e
# Parent  35903f03539082e5e193139b1f8b03f95227c074
Revamp %!demos in m-files to use Octave coding conventions on spacing, etc.
Add clf() to all demos using plot features to get reproducibility.
Use 64 as input to all colormaps (jet (64)) to get reproducibility.

* bicubic.m, cell2mat.m, celldisp.m, cplxpair.m, interp1.m, interp2.m,
interpft.m, interpn.m, profile.m, profshow.m, convhull.m, delaunay.m,
griddata.m, inpolygon.m, voronoi.m, autumn.m, bone.m, contrast.m, cool.m,
copper.m, flag.m, gmap40.m, gray.m, hot.m, hsv.m, image.m, imshow.m, jet.m,
ocean.m, pink.m, prism.m, rainbow.m, spring.m, summer.m, white.m, winter.m,
condest.m, onenormest.m, axis.m, clabel.m, colorbar.m, comet.m, comet3.m,
compass.m, contour.m, contour3.m, contourf.m, cylinder.m, daspect.m,
ellipsoid.m, errorbar.m, ezcontour.m, ezcontourf.m, ezmesh.m, ezmeshc.m,
ezplot.m, ezplot3.m, ezpolar.m, ezsurf.m, ezsurfc.m, feather.m, fill.m,
fplot.m, grid.m, hold.m, isosurface.m, legend.m, loglog.m, loglogerr.m,
pareto.m, patch.m, pbaspect.m, pcolor.m, pie.m, pie3.m, plot3.m, plotmatrix.m,
plotyy.m, polar.m, quiver.m, quiver3.m, rectangle.m, refreshdata.m, ribbon.m,
rose.m, scatter.m, scatter3.m, semilogx.m, semilogxerr.m, semilogy.m,
semilogyerr.m, shading.m, slice.m, sombrero.m, stairs.m, stem.m, stem3.m,
subplot.m, surf.m, surfc.m, surfl.m, surfnorm.m, text.m, title.m, trimesh.m,
triplot.m, trisurf.m, uigetdir.m, uigetfile.m, uimenu.m, uiputfile.m,
waitbar.m, xlim.m, ylim.m, zlim.m, mkpp.m, pchip.m, polyaffine.m, spline.m,
bicgstab.m, cgs.m, gplot.m, pcg.m, pcr.m, treeplot.m, strtok.m, demo.m,
example.m, rundemos.m, speed.m, test.m, calendar.m, datestr.m, datetick.m,
weekday.m: Revamp %!demos to use Octave coding conventions on spacing, etc.

diff --git a/scripts/general/bicubic.m b/scripts/general/bicubic.m
--- a/scripts/general/bicubic.m
+++ b/scripts/general/bicubic.m
@@ -193,16 +193,20 @@ function zi = bicubic (x, y, z, xi, yi, 
     zi(:, [xfirst_ind, xlast_ind]) = extrapval;
   endif
   if (! (isempty (yfirst_ind) && isempty (ylast_ind)))
     zi([yfirst_ind; ylast_ind], :) = extrapval;
   endif
 
 endfunction
 
+
 %!demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,4]+10; y=[-10,-9,-8];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,bicubic(x,y,A,xi,yi));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! clf;
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,4]+10;
+%! y = [-10,-9,-8];
+%! xi = linspace (min (x), max (x), 17);
+%! yi = linspace (min (y), max (y), 26)';
+%! mesh (xi, yi, bicubic (x,y,A,xi,yi));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
+
diff --git a/scripts/general/cell2mat.m b/scripts/general/cell2mat.m
--- a/scripts/general/cell2mat.m
+++ b/scripts/general/cell2mat.m
@@ -73,32 +73,33 @@ function m = cell2mat (c)
       cc = num2cell (c, xdim);
       c = cellfun ("cat", {idim}, cc{:}, "uniformoutput", false);
     endfor
     m = c{1};
   endif
 
 endfunction
 
-## Tests
-%!shared C, D, E, F
+
+%!demo
+%! C = {[1], [2 3 4]; [5; 9], [6 7 8; 10 11 12]};
+%! cell2mat (C)
+
+%!assert (cell2mat ({}), []);
+%!test
 %! C = {[1], [2 3 4]; [5; 9], [6 7 8; 10 11 12]};
 %! D = C; D(:,:,2) = C;
 %! E = [1 2 3 4; 5 6 7 8; 9 10 11 12];
 %! F = E; F(:,:,2) = E;
-%!assert (cell2mat (C), E);
-%!assert (cell2mat (D), F);
+%! assert (cell2mat (C), E);
+%! assert (cell2mat (D), F);
 %!test
 %! m = rand (10) + i * rand (10);
 %! c = mat2cell (m, [1 2 3 4], [4 3 2 1]);
-%! assert (cell2mat (c), m)
+%! assert (cell2mat (c), m);
 %!test
 %! m = int8 (256*rand (4, 5, 6, 7, 8));
 %! c = mat2cell (m, [1 2 1], [1 2 2], [3 1 1 1], [4 1 2], [3 1 4]);
-%! assert (cell2mat (c), m)
+%! assert (cell2mat (c), m);
 %!test
 %! m = {1, 2, 3};
 %! assert (cell2mat (mat2cell (m, 1, [1 1 1])), m);
-%!assert (cell2mat ({}), []);
-## Demos
-%!demo
-%! C = {[1], [2 3 4]; [5; 9], [6 7 8; 10 11 12]};
-%! cell2mat (C)
+
diff --git a/scripts/general/celldisp.m b/scripts/general/celldisp.m
--- a/scripts/general/celldisp.m
+++ b/scripts/general/celldisp.m
@@ -73,15 +73,16 @@ function s = indices (dv, i)
     [c{:}] = ind2sub (dv, i);
     s = sprintf("%i,", c{:});
     s(end) = [];
   else
     s = sprintf("%i", i);
   endif
 endfunction
 
+
 %!demo
 %! c = {1, 2, {31, 32}};
-%! celldisp(c, "b")
+%! celldisp (c, "b")
 
 %!error celldisp ();
 %!error celldisp ({}, "name", 1);
 %!error celldisp (1);
diff --git a/scripts/general/cplxpair.m b/scripts/general/cplxpair.m
--- a/scripts/general/cplxpair.m
+++ b/scripts/general/cplxpair.m
@@ -134,31 +134,33 @@ function y = cplxpair (z, tol, dim)
     endfor
   endfor
 
   ## Reshape the output matrix.
   y = ipermute (reshape (y, sz), perm);
 
 endfunction
 
+
 %!demo
 %! [ cplxpair(exp(2i*pi*[0:4]'/5)), exp(2i*pi*[3; 2; 4; 1; 0]/5) ]
 
-%!assert (isempty(cplxpair([])));
-%!assert (cplxpair(1), 1)
-%!assert (cplxpair([1+1i, 1-1i]), [1-1i, 1+1i])
-%!assert (cplxpair([1+1i, 1+1i, 1, 1-1i, 1-1i, 2]), \
-%!        [1-1i, 1+1i, 1-1i, 1+1i, 1, 2])
-%!assert (cplxpair([1+1i; 1+1i; 1; 1-1i; 1-1i; 2]), \
-%!        [1-1i; 1+1i; 1-1i; 1+1i; 1; 2])
-%!assert (cplxpair([0, 1, 2]), [0, 1, 2]);
+%!assert (isempty (cplxpair ([])))
+%!assert (cplxpair (1), 1)
+%!assert (cplxpair ([1+1i, 1-1i]), [1-1i, 1+1i])
+%!assert (cplxpair ([1+1i, 1+1i, 1, 1-1i, 1-1i, 2]), ...
+%!                  [1-1i, 1+1i, 1-1i, 1+1i, 1, 2])
+%!assert (cplxpair ([1+1i; 1+1i; 1; 1-1i; 1-1i; 2]), ...
+%!                  [1-1i; 1+1i; 1-1i; 1+1i; 1; 2])
+%!assert (cplxpair ([0, 1, 2]), [0, 1, 2])
 
 %!shared z
-%! z=exp(2i*pi*[4; 3; 5; 2; 6; 1; 0]/7);
-%!assert (cplxpair(z(randperm(7))), z);
-%!assert (cplxpair(z(randperm(7))), z);
-%!assert (cplxpair(z(randperm(7))), z);
-%!assert (cplxpair([z(randperm(7)),z(randperm(7))]),[z,z])
-%!assert (cplxpair([z(randperm(7)),z(randperm(7))],[],1),[z,z])
-%!assert (cplxpair([z(randperm(7)).';z(randperm(7)).'],[],2),[z.';z.'])
+%! z = exp (2i*pi*[4; 3; 5; 2; 6; 1; 0]/7);
+%!assert (cplxpair (z(randperm (7))), z)
+%!assert (cplxpair (z(randperm (7))), z)
+%!assert (cplxpair (z(randperm (7))), z)
+%!assert (cplxpair ([z(randperm(7)),z(randperm(7))]), [z,z])
+%!assert (cplxpair ([z(randperm(7)),z(randperm(7))],[],1), [z,z])
+%!assert (cplxpair ([z(randperm(7)).';z(randperm(7)).'],[],2), [z.';z.'])
 
 %!## tolerance test
-%!assert (cplxpair([1i, -1i, 1+(1i*eps)],2*eps), [-1i, 1i, 1+(1i*eps)]);
+%!assert (cplxpair ([1i, -1i, 1+(1i*eps)],2*eps), [-1i, 1i, 1+(1i*eps)])
+
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -293,83 +293,88 @@ function yi = interp1 (x, y, varargin)
       endif
     endif
   else
     yi.orient = "first";
   endif
 
 endfunction
 
+
 %!demo
-%! xf=0:0.05:10; yf = sin(2*pi*xf/5);
-%! xp=0:10;      yp = sin(2*pi*xp/5);
-%! lin=interp1(xp,yp,xf,"linear");
-%! spl=interp1(xp,yp,xf,"spline");
-%! cub=interp1(xp,yp,xf,"pchip");
-%! near=interp1(xp,yp,xf,"nearest");
-%! plot(xf,yf,"r",xf,near,"g",xf,lin,"b",xf,cub,"c",xf,spl,"m",xp,yp,"r*");
-%! legend ("original","nearest","linear","pchip","spline")
+%! clf;
+%! xf = 0:0.05:10; yf = sin (2*pi*xf/5);
+%! xp = 0:10;      yp = sin (2*pi*xp/5);
+%! lin = interp1 (xp,yp,xf, "linear");
+%! spl = interp1 (xp,yp,xf, "spline");
+%! cub = interp1 (xp,yp,xf, "pchip");
+%! near= interp1 (xp,yp,xf, "nearest");
+%! plot (xf,yf,"r",xf,near,"g",xf,lin,"b",xf,cub,"c",xf,spl,"m",xp,yp,"r*");
+%! legend ("original", "nearest", "linear", "pchip", "spline");
 %! %--------------------------------------------------------
 %! % confirm that interpolated function matches the original
 
 %!demo
-%! xf=0:0.05:10; yf = sin(2*pi*xf/5);
-%! xp=0:10;      yp = sin(2*pi*xp/5);
-%! lin=interp1(xp,yp,xf,"*linear");
-%! spl=interp1(xp,yp,xf,"*spline");
-%! cub=interp1(xp,yp,xf,"*cubic");
-%! near=interp1(xp,yp,xf,"*nearest");
-%! plot(xf,yf,"r",xf,near,"g",xf,lin,"b",xf,cub,"c",xf,spl,"m",xp,yp,"r*");
-%! legend ("*original","*nearest","*linear","*cubic","*spline")
+%! clf;
+%! xf = 0:0.05:10; yf = sin (2*pi*xf/5);
+%! xp = 0:10;      yp = sin (2*pi*xp/5);
+%! lin = interp1 (xp,yp,xf, "*linear");
+%! spl = interp1 (xp,yp,xf, "*spline");
+%! cub = interp1 (xp,yp,xf, "*cubic");
+%! near= interp1 (xp,yp,xf, "*nearest");
+%! plot (xf,yf,"r",xf,near,"g",xf,lin,"b",xf,cub,"c",xf,spl,"m",xp,yp,"r*");
+%! legend ("*original", "*nearest", "*linear", "*cubic", "*spline");
 %! %--------------------------------------------------------
 %! % confirm that interpolated function matches the original
 
 %!demo
+%! clf;
 %! t = 0 : 0.3 : pi; dt = t(2)-t(1);
 %! n = length (t); k = 100; dti = dt*n/k;
 %! ti = t(1) + [0 : k-1]*dti;
 %! y = sin (4*t + 0.3) .* cos (3*t - 0.1);
-%! ddyc = diff(diff(interp1(t,y,ti,'cubic'))./dti)./dti;
-%! ddys = diff(diff(interp1(t,y,ti,'spline'))./dti)./dti;
-%! ddyp = diff(diff(interp1(t,y,ti,'pchip'))./dti)./dti;
-%! plot (ti(2:end-1), ddyc,'g+',ti(2:end-1),ddys,'b*', ...
-%!       ti(2:end-1),ddyp,'c^');
-%! legend('cubic','spline','pchip');
-%! title("Second derivative of interpolated 'sin (4*t + 0.3) .* cos (3*t - 0.1)'");
+%! ddyc = diff (diff (interp1 (t,y,ti, "cubic")) ./dti)./dti;
+%! ddys = diff (diff (interp1 (t,y,ti, "spline"))./dti)./dti;
+%! ddyp = diff (diff (interp1 (t,y,ti, "pchip")) ./dti)./dti;
+%! plot (ti(2:end-1),ddyc,'g+', ti(2:end-1),ddys,'b*', ti(2:end-1),ddyp,'c^');
+%! legend ("cubic", "spline", "pchip");
+%! title ("Second derivative of interpolated 'sin (4*t + 0.3) .* cos (3*t - 0.1)'");
 
 %!demo
-%! xf=0:0.05:10; yf = sin(2*pi*xf/5) - (xf >= 5);
-%! xp=[0:.5:4.5,4.99,5:.5:10];      yp = sin(2*pi*xp/5) - (xp >= 5);
-%! lin=interp1(xp,yp,xf,"linear");
-%! near=interp1(xp,yp,xf,"nearest");
-%! plot(xf,yf,"r",xf,near,"g",xf,lin,"b",xp,yp,"r*");
-%! legend ("original","nearest","linear")
+%! clf;
+%! xf = 0:0.05:10;               yf = sin (2*pi*xf/5) - (xf >= 5);
+%! xp = [0:.5:4.5,4.99,5:.5:10]; yp = sin (2*pi*xp/5) - (xp >= 5);
+%! lin = interp1 (xp,yp,xf, "linear");
+%! near= interp1 (xp,yp,xf, "nearest");
+%! plot (xf,yf,"r", xf,near,"g", xf,lin,"b", xp,yp,"r*");
+%! legend ("original", "nearest", "linear");
 %! %--------------------------------------------------------
 %! % confirm that interpolated function matches the original
 
 ##FIXME: add test for n-d arguments here
 
 ## For each type of interpolated test, confirm that the interpolated
 ## value at the knots match the values at the knots.  Points away
 ## from the knots are requested, but only 'nearest' and 'linear'
 ## confirm they are the correct values.
 
 %!shared xp, yp, xi, style
-%! xp=0:2:10;      yp = sin(2*pi*xp/5);
+%! xp = 0:2:10;
+%! yp = sin (2*pi*xp/5);
 %! xi = [-1, 0, 2.2, 4, 6.6, 10, 11];
 
-
 ## The following BLOCK/ENDBLOCK section is repeated for each style
 ##    nearest, linear, cubic, spline, pchip
 ## The test for ppval of cubic has looser tolerance, but otherwise
 ## the tests are identical.
 ## Note that the block checks style and *style; if you add more tests
-## before to add them to both sections of each block.  One test,
+## be sure to add them to both sections of each block.  One test,
 ## style vs. *style, occurs only in the first section.
 ## There is an ENDBLOCKTEST after the final block
+
 %!test style = "nearest";
 ## BLOCK
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
@@ -394,16 +399,17 @@ endfunction
 %!assert (interp1(xp,[yp',yp'],xi(:),style),...
 %!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
 %!assert (interp1(xp,yp,xi,style),...
 %!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
 %!assert (ppval(interp1(xp,yp,style,"pp"),xi),
 %!        interp1(xp,yp,xi,style,"extrap"),10*eps);
 %!error interp1(1,1,1, style);
 ## ENDBLOCK
+
 %!test style='linear';
 ## BLOCK
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
@@ -428,16 +434,17 @@ endfunction
 %!assert (interp1(xp,[yp',yp'],xi(:),style),...
 %!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
 %!assert (interp1(xp,yp,xi,style),...
 %!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
 %!assert (ppval(interp1(xp,yp,style,"pp"),xi),
 %!        interp1(xp,yp,xi,style,"extrap"),10*eps);
 %!error interp1(1,1,1, style);
 ## ENDBLOCK
+
 %!test style='cubic';
 ## BLOCK
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
@@ -462,16 +469,17 @@ endfunction
 %!assert (interp1(xp,[yp',yp'],xi(:),style),...
 %!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
 %!assert (interp1(xp,yp,xi,style),...
 %!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
 %!assert (ppval(interp1(xp,yp,style,"pp"),xi),
 %!        interp1(xp,yp,xi,style,"extrap"),100*eps);
 %!error interp1(1,1,1, style);
 ## ENDBLOCK
+
 %!test style='pchip';
 ## BLOCK
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
@@ -496,16 +504,17 @@ endfunction
 %!assert (interp1(xp,[yp',yp'],xi(:),style),...
 %!        [interp1(xp,yp,xi(:),style),interp1(xp,yp,xi(:),style)]);
 %!assert (interp1(xp,yp,xi,style),...
 %!        interp1(fliplr(xp),fliplr(yp),xi,style),100*eps);
 %!assert (ppval(interp1(xp,yp,style,"pp"),xi),
 %!        interp1(xp,yp,xi,style,"extrap"),10*eps);
 %!error interp1(1,1,1, style);
 ## ENDBLOCK
+
 %!test style='spline';
 ## BLOCK
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp,style), yp, 100*eps);
 %!assert (isempty(interp1(xp',yp',[],style)));
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -441,118 +441,118 @@ function ind = sym_sub2ind(sz, Y, X)
     X (X > 2 * sz (2)) = round (X (X > 2 * sz (2)) / 2);
   endwhile
   X (X > sz (2)) = 1 + 2 * sz (2) - X (X > sz (2));
   ind = sub2ind(sz, Y, X);
 endfunction
 
 
 %!demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,4]; y=[10,11,12];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'linear'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,4]; y = [10,11,12];
+%! xi = linspace (min(x), max(x), 17);
+%! yi = linspace (min(y), max(y), 26)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "linear"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! [x,y,A] = peaks(10);
+%! [x,y,A] = peaks (10);
 %! x = x(1,:)'; y = y(:,1);
-%! xi=linspace(min(x),max(x),41);
-%! yi=linspace(min(y),max(y),41)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'linear'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! xi = linspace (min(x), max(x), 41);
+%! yi = linspace (min(y), max(y), 41)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "linear"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,4]; y=[10,11,12];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'nearest'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,4]; y = [10,11,12];
+%! xi = linspace (min(x), max(x), 17);
+%! yi = linspace (min(y), max(y), 26)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "nearest"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! [x,y,A] = peaks(10);
+%! [x,y,A] = peaks (10);
 %! x = x(1,:)'; y = y(:,1);
-%! xi=linspace(min(x),max(x),41);
-%! yi=linspace(min(y),max(y),41)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'nearest'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! xi = linspace (min(x), max(x), 41);
+%! yi = linspace (min(y), max(y), 41)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "nearest"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,2]; y=[10,11,12];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'pchip'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,2]; y = [10,11,12];
+%! xi = linspace (min(x), max(x), 17);
+%! yi = linspace (min(y), max(y), 26)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "pchip"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! [x,y,A] = peaks(10);
+%! [x,y,A] = peaks (10);
 %! x = x(1,:)'; y = y(:,1);
-%! xi=linspace(min(x),max(x),41);
-%! yi=linspace(min(y),max(y),41)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'pchip'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! xi = linspace (min(x), max(x), 41);
+%! yi = linspace (min(y), max(y), 41)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "pchip"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,2]; y=[10,11,12];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'cubic'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,2]; y = [10,11,12];
+%! xi = linspace (min(x), max(x), 17);
+%! yi = linspace (min(y), max(y), 26)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "cubic"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! [x,y,A] = peaks(10);
+%! [x,y,A] = peaks (10);
 %! x = x(1,:)'; y = y(:,1);
-%! xi=linspace(min(x),max(x),41);
-%! yi=linspace(min(y),max(y),41)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'cubic'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! xi = linspace (min(x), max(x), 41);
+%! yi = linspace (min(y), max(y), 41)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "cubic"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,2]; y=[10,11,12];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'spline'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,2]; y = [10,11,12];
+%! xi = linspace (min(x), max(x), 17);
+%! yi = linspace (min(y), max(y), 26)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "spline"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! [x,y,A] = peaks(10);
+%! [x,y,A] = peaks (10);
 %! x = x(1,:)'; y = y(:,1);
-%! xi=linspace(min(x),max(x),41);
-%! yi=linspace(min(y),max(y),41)';
-%! mesh(xi,yi,interp2(x,y,A,xi,yi,'spline'));
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! xi = linspace (min(x), max(x), 41);
+%! yi = linspace (min(y), max(y), 41)';
+%! mesh (xi,yi,interp2 (x,y,A,xi,yi, "spline"));
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!test % simple test
 %!  x = [1,2,3];
 %!  y = [4,5,6,7];
-%!  [X, Y] = meshgrid(x,y);
+%!  [X, Y] = meshgrid (x,y);
 %!  Orig = X.^2 + Y.^3;
 %!  xi = [1.2,2, 1.5];
 %!  yi = [6.2, 4.0, 5.0]';
 %!
 %!  Expected = ...
 %!    [243,   245.4,  243.9;
 %!      65.6,  68,     66.5;
 %!     126.6, 129,    127.5];
-%!  Result = interp2(x,y,Orig, xi, yi);
+%!  Result = interp2 (x,y,Orig, xi, yi);
 %!
 %!  assert(Result, Expected, 1000*eps);
 
 %!test % 2^n form
 %!  x = [1,2,3];
 %!  y = [4,5,6,7];
 %!  [X, Y] = meshgrid(x,y);
 %!  Orig = X.^2 + Y.^3;
diff --git a/scripts/general/interpft.m b/scripts/general/interpft.m
--- a/scripts/general/interpft.m
+++ b/scripts/general/interpft.m
@@ -87,30 +87,33 @@ function z = interpft (x, n, dim)
   endif
 
   z = ipermute (z, perm);
 
 endfunction
 
 
 %!demo
+%! clf;
 %! t = 0 : 0.3 : pi; dt = t(2)-t(1);
 %! n = length (t); k = 100;
 %! ti = t(1) + [0 : k-1]*dt*n/k;
 %! y = sin (4*t + 0.3) .* cos (3*t - 0.1);
 %! yp = sin (4*ti + 0.3) .* cos (3*ti - 0.1);
-%! plot (ti, yp, 'g', ti, interp1(t, y, ti, 'spline'), 'b', ...
-%!       ti, interpft (y, k), 'c', t, y, 'r+');
-%! legend ('sin(4t+0.3)cos(3t-0.1','spline','interpft','data');
+%! plot (ti, yp, 'g', ti, interp1(t, y, ti, "spline"), 'b', ...
+%!       ti, interpft (y, k), 'c', t, y, "r+");
+%! legend ("sin(4t+0.3)cos(3t-0.1)", "spline", "interpft", "data");
 
 %!shared n,y
 %! x = [0:10]'; y = sin(x); n = length (x);
-%!assert (interpft(y, n), y, 20*eps);
-%!assert (interpft(y', n), y', 20*eps);
-%!assert (interpft([y,y],n), [y,y], 20*eps);
+%!assert (interpft (y, n), y, 20*eps);
+%!assert (interpft (y', n), y', 20*eps);
+%!assert (interpft ([y,y],n), [y,y], 20*eps);
 
 %% Test input validation
 %!error interpft ()
 %!error interpft (1)
 %!error interpft (1,2,3)
-%!error (interpft(1,[n,n]))
-%!error (interpft(1,2,0))
-%!error (interpft(1,2,3))
+%!error <N must be a scalar integer> interpft (1,[2,2])
+%!error <N must be a scalar integer> interpft (1,2.1)
+%!error <invalid dimension DIM> interpft (1,2,0)
+%!error <invalid dimension DIM> interpft (1,2,3)
+
diff --git a/scripts/general/interpn.m b/scripts/general/interpn.m
--- a/scripts/general/interpn.m
+++ b/scripts/general/interpn.m
@@ -204,111 +204,112 @@ function vi = interpn (varargin)
   elseif (strcmp (method, "cubic"))
     error ("interpn: cubic interpolation not yet implemented");
   else
     error ("interpn: unrecognized interpolation METHOD");
   endif
 
 endfunction
 
+
 %!demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,4]; y=[10,11,12];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,interpn(x,y,A.',xi,yi,"linear").');
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! clf;
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,4]; y = [10,11,12];
+%! xi = linspace (min(x), max(x), 17);
+%! yi = linspace (min(y), max(y), 26)';
+%! mesh (xi, yi, interpn (x,y,A.',xi,yi, "linear").');
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,4]; y=[10,11,12];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,interpn(x,y,A.',xi,yi,"nearest").');
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%! clf;
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,4]; y = [10,11,12];
+%! xi = linspace (min(x), max(x), 17);
+%! yi = linspace (min(y), max(y), 26)';
+%! mesh (xi, yi, interpn (x,y,A.',xi,yi, "nearest").');
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
-%!#demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,2]; y=[10,11,12];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,interpn(x,y,A.',xi,yi,"cubic").');
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
+%!#demo  # FIXME: Uncomment when support for "cubic" has been added
+%! clf;
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,2]; y = [10,11,12];
+%! xi = linspace (min(x), max(x), 17);
+%! yi = linspace (min(y), max(y), 26)';
+%! mesh (xi, yi, interpn (x,y,A.',xi,yi, "cubic").');
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
-%! A=[13,-1,12;5,4,3;1,6,2];
-%! x=[0,1,2]; y=[10,11,12];
-%! xi=linspace(min(x),max(x),17);
-%! yi=linspace(min(y),max(y),26)';
-%! mesh(xi,yi,interpn(x,y,A.',xi,yi,"spline").');
-%! [x,y] = meshgrid(x,y);
-%! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
-
+%! clf;
+%! A = [13,-1,12;5,4,3;1,6,2];
+%! x = [0,1,2]; y = [10,11,12];
+%! xi = linspace (min(x), max(x), 17);
+%! yi = linspace (min(y), max(y), 26)';
+%! mesh (xi, yi, interpn (x,y,A.',xi,yi, "spline").');
+%! [x,y] = meshgrid (x,y);
+%! hold on; plot3 (x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
+%! clf;
 %! x = y = z = -1:1;
 %! f = @(x,y,z) x.^2 - y - z.^2;
 %! [xx, yy, zz] = meshgrid (x, y, z);
 %! v = f (xx,yy,zz);
 %! xi = yi = zi = -1:0.1:1;
 %! [xxi, yyi, zzi] = ndgrid (xi, yi, zi);
-%! vi = interpn(x, y, z, v, xxi, yyi, zzi, 'spline');
+%! vi = interpn (x, y, z, v, xxi, yyi, zzi, 'spline');
 %! mesh (yi, zi, squeeze (vi(1,:,:)));
 
-
 %!test
-%! [x,y,z] = ndgrid(0:2);
-%! f = x+y+z;
-%! assert (interpn(x,y,z,f,[.5 1.5],[.5 1.5],[.5 1.5]), [1.5, 4.5])
-%! assert (interpn(x,y,z,f,[.51 1.51],[.51 1.51],[.51 1.51],'nearest'), [3, 6])
-%! assert (interpn(x,y,z,f,[.5 1.5],[.5 1.5],[.5 1.5],'spline'), [1.5, 4.5])
-%! assert (interpn(x,y,z,f,x,y,z), f)
-%! assert (interpn(x,y,z,f,x,y,z,'nearest'), f)
-%! assert (interpn(x,y,z,f,x,y,z,'spline'), f)
+%! [x,y,z] = ndgrid (0:2);
+%! f = x + y + z;
+%! assert (interpn (x,y,z,f,[.5 1.5],[.5 1.5],[.5 1.5]), [1.5, 4.5]);
+%! assert (interpn (x,y,z,f,[.51 1.51],[.51 1.51],[.51 1.51],"nearest"), [3, 6]);
+%! assert (interpn (x,y,z,f,[.5 1.5],[.5 1.5],[.5 1.5],"spline"), [1.5, 4.5]);
+%! assert (interpn (x,y,z,f,x,y,z), f);
+%! assert (interpn (x,y,z,f,x,y,z,"nearest"), f);
+%! assert (interpn (x,y,z,f,x,y,z,"spline"), f);
 
 %!test
 %! [x, y, z] = ndgrid (0:2, 1:4, 2:6);
 %! f = x + y + z;
-%! xi = [0.5 1.0 1.5];
-%! yi = [1.5 2.0 2.5 3.5];
-%! zi = [2.5 3.5 4.0 5.0 5.5];
+%! xi = [0.5 1.0 1.5];  yi = [1.5 2.0 2.5 3.5];  zi = [2.5 3.5 4.0 5.0 5.5];
 %! fi = interpn (x, y, z, f, xi, yi, zi);
 %! [xi, yi, zi] = ndgrid (xi, yi, zi);
-%! assert (fi, xi + yi + zi)
+%! assert (fi, xi + yi + zi);
 
 %!test
-%! xi = 0:2;
-%! yi = 1:4;
-%! zi = 2:6;
+%! xi = 0:2;  yi = 1:4;  zi = 2:6;
 %! [x, y, z] = ndgrid (xi, yi, zi);
 %! f = x + y + z;
 %! fi = interpn (x, y, z, f, xi, yi, zi, "nearest");
-%! assert (fi, x + y + z)
+%! assert (fi, x + y + z);
 
 %!test
-%! [x,y,z] = ndgrid(0:2);
-%! f = x.^2+y.^2+z.^2;
-%! assert (interpn(x,y,-z,f,1.5,1.5,-1.5), 7.5)
+%! [x,y,z] = ndgrid (0:2);
+%! f = x.^2 + y.^2 + z.^2;
+%! assert (interpn (x,y,-z,f,1.5,1.5,-1.5), 7.5);
 
-%!test % for Matlab-compatible rounding for 'nearest'
-%! X = meshgrid (1:4);
-%! assert (interpn (X, 2.5, 2.5, 'nearest'), 3);
+%!test  # for Matlab-compatible rounding for "nearest"
+%! x = meshgrid (1:4);
+%! assert (interpn (x, 2.5, 2.5, "nearest"), 3);
 
-%!shared z, zout, tol
+%!test
 %! z = zeros (3, 3, 3);
 %! zout = zeros (5, 5, 5);
 %! z(:,:,1) = [1 3 5; 3 5 7; 5 7 9];
 %! z(:,:,2) = z(:,:,1) + 2;
 %! z(:,:,3) = z(:,:,2) + 2;
 %! for n = 1:5
 %!   zout(:,:,n) = [1 2 3 4 5;
-%!                  2 3 4 5 6; 
+%!                  2 3 4 5 6;
 %!                  3 4 5 6 7;
 %!                  4 5 6 7 8;
 %!                  5 6 7 8 9] + (n-1);
-%! end
-%! tol = 10 * eps;
-%!assert (interpn (z), zout, tol)
-%!assert (interpn (z, "linear"), zout, tol)
-%!assert (interpn (z, "spline"), zout, tol)
+%! endfor
+%! tol = 10*eps;
+%! assert (interpn (z), zout, tol);
+%! assert (interpn (z, "linear"), zout, tol);
+%! assert (interpn (z, "spline"), zout, tol);
+
diff --git a/scripts/general/profile.m b/scripts/general/profile.m
--- a/scripts/general/profile.m
+++ b/scripts/general/profile.m
@@ -64,88 +64,91 @@
 
 function retval = profile (option)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   switch (option)
-    case 'on'
+    case "on"
       __profiler_reset__ ();
       __profiler_enable__ (true);
 
-    case 'off'
+    case "off"
       __profiler_enable__ (false);
 
-    case 'clear'
+    case "clear"
       __profiler_reset__ ();
 
-    case 'resume'
+    case "resume"
       __profiler_enable__ (true);
 
-    case 'status'
+    case "status"
       enabled = __profiler_enable__ ();
       if (enabled)
-        enabled = 'on';
+        enabled = "on";
       else
-        enabled = 'off';
+        enabled = "off";
       endif
-      retval = struct ('ProfilerStatus', enabled);
+      retval = struct ("ProfilerStatus", enabled);
 
-    case 'info'
+    case "info"
       [flat, tree] = __profiler_data__ ();
-      retval = struct ('FunctionTable', flat, 'Hierarchical', tree);
+      retval = struct ("FunctionTable", flat, "Hierarchical", tree);
 
     otherwise
       warning ("profile: Unrecognized option '%s'", option);
       print_usage ();
 
   endswitch
 
 endfunction
 
 
 %!demo
-%! profile ('on');
+%! profile on;
 %! A = rand (100);
 %! B = expm (A);
-%! profile ('off');
-%! profile ('resume');
+%! profile off;
+%! profile resume;
 %! C = sqrtm (A);
-%! profile ('off');
-%! T = profile ('info');
+%! profile off;
+%! T = profile ("info");
 %! profshow (T);
 
-%!error profile ();
-%!error profile ('on', 2);
-
 %!test
 %! on_struct.ProfilerStatus = "on";
 %! off_struct.ProfilerStatus = "off";
-%! profile ('on');
+%! profile ("on");
 %! result = logm (rand (200) + 10 * eye (200));
-%! assert (profile ('status'), on_struct);
-%! profile ('off');
-%! assert (profile ('status'), off_struct);
-%! profile ('resume');
+%! assert (profile ("status"), on_struct);
+%! profile ("off");
+%! assert (profile ("status"), off_struct);
+%! profile ("resume");
 %! result = logm (rand (200) + 10 * eye (200));
-%! profile ('off');
-%! assert (profile ('status'), off_struct);
-%! info = profile ('info');
+%! profile ("off");
+%! assert (profile ("status"), off_struct);
+%! info = profile ("info");
 %! assert (isstruct (info));
 %! assert (size (info), [1, 1]);
-%! assert (fieldnames (info), {'FunctionTable'; 'Hierarchical'});
+%! assert (fieldnames (info), {"FunctionTable"; "Hierarchical"});
 %! ftbl = info.FunctionTable;
-%! assert (fieldnames (ftbl), {'FunctionName'; 'TotalTime'; 'NumCalls'; 'IsRecursive'; 'Parents'; 'Children'});
+%! assert (fieldnames (ftbl), {"FunctionName"; "TotalTime"; "NumCalls"; "IsRecursive"; "Parents"; "Children"});
 %! hier = info.Hierarchical;
-%! assert (fieldnames (hier), {'Index'; 'SelfTime'; 'TotalTime'; 'NumCalls'; 'Children'});
-%! profile ('clear');
-%! info = profile ('info');
+%! assert (fieldnames (hier), {"Index"; "SelfTime"; "TotalTime"; "NumCalls"; "Children"});
+%! profile ("clear");
+%! info = profile ("info");
 %! assert (isstruct (info));
 %! assert (size (info), [1, 1]);
-%! assert (fieldnames (info), {'FunctionTable'; 'Hierarchical'});
+%! assert (fieldnames (info), {"FunctionTable"; "Hierarchical"});
 %! ftbl = info.FunctionTable;
 %! assert (size (ftbl), [0, 1]);
-%! assert (fieldnames (ftbl), {'FunctionName'; 'TotalTime'; 'NumCalls'; 'IsRecursive'; 'Parents'; 'Children'});
+%! assert (fieldnames (ftbl), {"FunctionName"; "TotalTime"; "NumCalls"; "IsRecursive"; "Parents"; "Children"});
 %! hier = info.Hierarchical;
 %! assert (size (hier), [0, 1]);
-%! assert (fieldnames (hier), {'Index'; 'SelfTime'; 'NumCalls'; 'Children'});
+%! assert (fieldnames (hier), {"Index"; "SelfTime"; "NumCalls"; "Children"});
+
+%% Test input validation
+%!error profile ()
+%!error profile ("on", 2)
+%!error profile ("INVALID_OPTION");
+
diff --git a/scripts/general/profshow.m b/scripts/general/profshow.m
--- a/scripts/general/profshow.m
+++ b/scripts/general/profshow.m
@@ -76,25 +76,27 @@ function profshow (data, n = 20)
       attr = "R";
     endif
     printf (rowFormat, p(i), row.FunctionName, attr, ...
             row.TotalTime, row.NumCalls);
   endfor
 
 endfunction
 
+
 %!demo
-%! profile ("on");
+%! profile on;
 %! A = rand (100);
 %! B = expm (A);
-%! profile ("off");
+%! profile off;
 %! T = profile ("info");
 %! profshow (T, 10);
 
 %!demo
-%! profile ("on");
+%! profile on;
 %! expm (rand (500) + eye (500));
-%! profile ("off");
+%! profile off;
 %! profshow (profile ("info"), 5);
 
 %!error profshow ();
 %!error profshow (1, 2, 3);
 %!error profshow (struct (), 1.2);
+
diff --git a/scripts/geometry/convhull.m b/scripts/geometry/convhull.m
--- a/scripts/geometry/convhull.m
+++ b/scripts/geometry/convhull.m
@@ -80,16 +80,17 @@ function H = convhull (x, y, options)
   endfor
 
   H(n + 1) = H(1);
 
 endfunction
 
 
 %!demo
+%! clf;
 %! x = -3:0.05:3;
 %! y = abs (sin (x));
 %! k = convhull (x, y);
 %! plot (x(k),y(k),"r-;convex hull;", x,y,"b+;points;");
 %! axis ([-3.05, 3.05, -0.05, 1.05]);
 
 %!testif HAVE_QHULL
 %! x = -3:0.5:3;
diff --git a/scripts/geometry/delaunay.m b/scripts/geometry/delaunay.m
--- a/scripts/geometry/delaunay.m
+++ b/scripts/geometry/delaunay.m
@@ -97,18 +97,19 @@ endfunction
 %! old_state = rand ("state");
 %! restore_state = onCleanup (@() rand ("state", old_state));
 %! rand ("state", 1);
 %! x = rand (1,10);
 %! y = rand (1,10);
 %! T = delaunay (x,y);
 %! VX = [ x(T(:,1)); x(T(:,2)); x(T(:,3)); x(T(:,1)) ];
 %! VY = [ y(T(:,1)); y(T(:,2)); y(T(:,3)); y(T(:,1)) ];
+%! clf;
+%! plot (VX,VY,"b", x,y,"r*");
 %! axis ([0,1,0,1]);
-%! plot (VX,VY,"b", x,y,"r*");
 
 %!testif HAVE_QHULL
 %! x = [-1, 0, 1, 0];
 %! y = [0, 1, 0, -1];
 %! assert (sortrows (sort (delaunay (x, y), 2)), [1,2,4;2,3,4]);
 
 %!testif HAVE_QHULL
 %! x = [-1, 0, 1, 0, 0];
diff --git a/scripts/geometry/griddata.m b/scripts/geometry/griddata.m
--- a/scripts/geometry/griddata.m
+++ b/scripts/geometry/griddata.m
@@ -135,43 +135,48 @@ function [rx, ry, rz] = griddata (x, y, 
     rz = zi;
   elseif (nargout == 1)
     rx = zi;
   elseif (nargout == 0)
     mesh (xi, yi, zi);
   endif
 endfunction
 
-%!testif HAVE_QHULL
-%! [xx,yy]=meshgrid(linspace(-1,1,32));
-%! x = xx(:);
-%! x = x + 10 * (2 * round(rand(size(x))) - 1) * eps;
-%! y = yy(:);
-%! y = y + 10 * (2 * round(rand(size(y))) - 1) * eps;
-%! z = sin(2*(x.^2+y.^2));
-%! zz = griddata(x,y,z,xx,yy,'linear');
-%! zz2 = sin(2*(xx.^2+yy.^2));
-%! zz2(isnan(zz)) = NaN;
-%! assert (zz, zz2, 100 * eps)
+
+%!demo
+%! clf;
+%! x = 2*rand (100,1) - 1;
+%! y = 2*rand (size (x)) - 1;
+%! z = sin (2*(x.^2 + y.^2));
+%! [xx,yy] = meshgrid (linspace (-1,1,32));
+%! griddata (x,y,z,xx,yy);
+%! title ("nonuniform grid sampled at 100 points");
+
+%!demo
+%! clf;
+%! x = 2*rand (1000,1) - 1;
+%! y = 2*rand (size (x)) - 1;
+%! z = sin (2*(x.^2 + y.^2));
+%! [xx,yy] = meshgrid (linspace (-1,1,32));
+%! griddata (x,y,z,xx,yy);
+%! title ("nonuniform grid sampled at 1000 points");
 
 %!demo
-%! x=2*rand(100,1)-1;
-%! y=2*rand(size(x))-1;
-%! z=sin(2*(x.^2+y.^2));
-%! [xx,yy]=meshgrid(linspace(-1,1,32));
-%! griddata(x,y,z,xx,yy);
-%! title('nonuniform grid sampled at 100 points');
+%! clf;
+%! x = 2*rand (1000,1) - 1;
+%! y = 2*rand (size (x)) - 1;
+%! z = sin (2*(x.^2 + y.^2));
+%! [xx,yy] = meshgrid (linspace (-1, 1, 32));
+%! griddata (x,y,z,xx,yy,"nearest");
+%! title ("nonuniform grid sampled at 1000 points with nearest neighbor");
 
-%!demo
-%! x=2*rand(1000,1)-1;
-%! y=2*rand(size(x))-1;
-%! z=sin(2*(x.^2+y.^2));
-%! [xx,yy]=meshgrid(linspace(-1,1,32));
-%! griddata(x,y,z,xx,yy);
-%! title('nonuniform grid sampled at 1000 points');
+%!testif HAVE_QHULL
+%! [xx,yy] = meshgrid (linspace (-1,1,32));
+%! x = xx(:);
+%! x = x + 10*(2*round (rand (size(x))) - 1) * eps;
+%! y = yy(:);
+%! y = y + 10*(2*round (rand (size(y))) - 1) * eps;
+%! z = sin (2*(x.^2 + y.^2));
+%! zz = griddata (x,y,z,xx,yy,"linear");
+%! zz2 = sin (2*(xx.^2 + yy.^2));
+%! zz2(isnan (zz)) = NaN;
+%! assert (zz, zz2, 100*eps);
 
-%!demo
-%! x=2*rand(1000,1)-1;
-%! y=2*rand(size(x))-1;
-%! z=sin(2*(x.^2+y.^2));
-%! [xx,yy]=meshgrid(linspace(-1,1,32));
-%! griddata(x,y,z,xx,yy,'nearest');
-%! title('nonuniform grid sampled at 1000 points with nearest neighbor');
diff --git a/scripts/geometry/inpolygon.m b/scripts/geometry/inpolygon.m
--- a/scripts/geometry/inpolygon.m
+++ b/scripts/geometry/inpolygon.m
@@ -79,65 +79,69 @@ function [in, on] = inpolygon (x, y, xv,
                & (0 == distance | !delta_xv));
        on (idx2) = true;
     endif
     j = i;
   endfor
 
 endfunction
 
-%!demo
-%!  xv=[ 0.05840, 0.48375, 0.69356, 1.47478, 1.32158, \
-%!       1.94545, 2.16477, 1.87639, 1.18218, 0.27615, \
-%!       0.05840 ];
-%!  yv=[ 0.60628, 0.04728, 0.50000, 0.50000, 0.02015, \
-%!       0.18161, 0.78850, 1.13589, 1.33781, 1.04650, \
-%!       0.60628 ];
-%! xa=[0:0.1:2.3];
-%! ya=[0:0.1:1.4];
-%! [x,y]=meshgrid(xa,ya);
-%! [in,on]=inpolygon(x,y,xv,yv);
-%!
-%! inside=in & !on;
-%! plot(xv,yv)
-%! hold on
-%! plot(x(inside),y(inside),"@g")
-%! plot(x(!in),y(!in),"@m")
-%! plot(x(on),y(on),"@b")
-%! hold off
-%! disp("Green points are inside polygon, magenta are outside,");
-%! disp("and blue are on boundary.");
 
 %!demo
-%!  xv=[ 0.05840, 0.48375, 0.69356, 1.47478, 1.32158, \
-%!       1.94545, 2.16477, 1.87639, 1.18218, 0.27615, \
-%!       0.05840, 0.73295, 1.28913, 1.74221, 1.16023, \
-%!       0.73295, 0.05840 ];
-%!  yv=[ 0.60628, 0.04728, 0.50000, 0.50000, 0.02015, \
-%!       0.18161, 0.78850, 1.13589, 1.33781, 1.04650, \
-%!       0.60628, 0.82096, 0.67155, 0.96114, 1.14833, \
-%!       0.82096, 0.60628];
-%! xa=[0:0.1:2.3];
-%! ya=[0:0.1:1.4];
-%! [x,y]=meshgrid(xa,ya);
-%! [in,on]=inpolygon(x,y,xv,yv);
+%! xv = [ 0.05840, 0.48375, 0.69356, 1.47478, 1.32158, ...
+%!        1.94545, 2.16477, 1.87639, 1.18218, 0.27615, ...
+%!        0.05840 ];
+%! yv = [ 0.60628, 0.04728, 0.50000, 0.50000, 0.02015, ...
+%!        0.18161, 0.78850, 1.13589, 1.33781, 1.04650, ...
+%!        0.60628 ];
+%! xa = [0:0.1:2.3];
+%! ya = [0:0.1:1.4];
+%! [x,y] = meshgrid (xa, ya);
+%! [in,on] = inpolygon (x, y, xv, yv);
+%! inside = in & !on;
 %!
-%! inside=in & !on;
-%! plot(xv,yv)
-%! hold on
-%! plot(x(inside),y(inside),"@g")
-%! plot(x(!in),y(!in),"@m")
-%! plot(x(on),y(on),"@b")
-%! hold off
-%! disp("Green points are inside polygon, magenta are outside,");
-%! disp("and blue are on boundary.");
+%! clf;
+%! plot (xv, yv);
+%! hold on;
+%! plot (x(inside), y(inside), "@g")
+%! plot (x(!in), y(!in), "@m");
+%! plot (x(on), y(on), "@b");
+%! hold off;
+%! disp ("Green points are inside polygon, magenta are outside,");
+%! disp ("and blue are on boundary.");
 
-%!error inpolygon ();
-%!error inpolygon (1, 2);
-%!error inpolygon (1, 2, 3);
-
-%!error inpolygon (1, [1,2], [3, 4], [5, 6]);
-%!error inpolygon ([1,2], [3, 4], [5, 6], 1);
+%!demo
+%!  xv = [ 0.05840, 0.48375, 0.69356, 1.47478, 1.32158, ...
+%!         1.94545, 2.16477, 1.87639, 1.18218, 0.27615, ...
+%!         0.05840, 0.73295, 1.28913, 1.74221, 1.16023, ...
+%!         0.73295, 0.05840 ];
+%!  yv = [ 0.60628, 0.04728, 0.50000, 0.50000, 0.02015, ...
+%!         0.18161, 0.78850, 1.13589, 1.33781, 1.04650, ...
+%!         0.60628, 0.82096, 0.67155, 0.96114, 1.14833, ...
+%!         0.82096, 0.60628];
+%! xa = [0:0.1:2.3];
+%! ya = [0:0.1:1.4];
+%! [x,y] = meshgrid (xa, ya);
+%! [in,on] = inpolygon (x, y, xv, yv);
+%! inside = in & !on;
+%!
+%! clf;
+%! plot (xv, yv);
+%! hold on;
+%! plot (x(inside), y(inside), "@g");
+%! plot (x(!in), y(!in), "@m");
+%! plot (x(on), y(on), "@b");
+%! hold off;
+%! disp ("Green points are inside polygon, magenta are outside,");
+%! disp ("and blue are on boundary.");
 
 %!test
 %! [in, on] = inpolygon ([1, 0], [1, 0], [-1, -1, 1, 1], [-1, 1, 1, -1]);
 %! assert (in, [false, true]);
 %! assert (on, [true, false]);
+
+%% Test input validation
+%!error inpolygon ()
+%!error inpolygon (1, 2)
+%!error inpolygon (1, 2, 3)
+%!error inpolygon (1, [1,2], [3, 4], [5, 6])
+%!error inpolygon ([1,2], [3, 4], [5, 6], 1)
+
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -169,17 +169,17 @@ function [vx, vy] = voronoi (varargin)
     vx = Vvx;
     vy = Vvy;
   endif
 
 endfunction
 
 
 %!demo
-%! voronoi (rand(10,1), rand(10,1));
+%! voronoi (rand (10,1), rand (10,1));
 
 %!testif HAVE_QHULL
 %! phi = linspace (-pi, 3/4*pi, 8);
 %! [x,y] = pol2cart (phi, 1);
 %! [vx,vy] = voronoi (x,y);
 %! assert(vx(2,:), zeros (1, columns (vx)), eps);
 %! assert(vy(2,:), zeros (1, columns (vy)), eps);
 
diff --git a/scripts/image/autumn.m b/scripts/image/autumn.m
--- a/scripts/image/autumn.m
+++ b/scripts/image/autumn.m
@@ -48,14 +48,15 @@ function map = autumn (n)
     b = zeros (n, 1);
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'autumn' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (autumn (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (autumn (64));
 
diff --git a/scripts/image/bone.m b/scripts/image/bone.m
--- a/scripts/image/bone.m
+++ b/scripts/image/bone.m
@@ -51,14 +51,15 @@ function map = bone (n)
       + (x >= 3/4) .* (7/8 * x + 1/8);
     b = (x < 3/8) .* (29/24 * x) + (x >= 3/8) .* (7/8 * x + 1/8);
     map = [r, g, b];
   else
     map = [];
   endif
 endfunction
 
+
 %!demo
 %! ## Show the 'bone' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (bone (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (bone (64));
 
diff --git a/scripts/image/contrast.m b/scripts/image/contrast.m
--- a/scripts/image/contrast.m
+++ b/scripts/image/contrast.m
@@ -39,12 +39,15 @@ function map = contrast (x, n)
   x = x(:);
   minx = min (x);
   map = find (diff (sort ([round(n * ((x - minx) ./ (max(x) - minx))); [0:n]'])));
   minm = min (map);
   map = (map - minm) ./ (max (map) - minm);
   map = [map, map, map];
 endfunction
 
-%!assert (contrast(1:100,10),[([0:9]/9)',([0:9]/9)',([0:9]/9)'],1e-10)
+
 %!demo
-%! image (reshape (1:100, 10, 10))
-%! colormap (contrast (1:100,10))
+%! image (reshape (1:100, 10, 10));
+%! colormap (contrast (1:100, 10));
+
+%!assert (contrast (1:100,10), [([0:9]/9)',([0:9]/9)',([0:9]/9)'], 1e-10)
+
diff --git a/scripts/image/cool.m b/scripts/image/cool.m
--- a/scripts/image/cool.m
+++ b/scripts/image/cool.m
@@ -47,14 +47,15 @@ function map = cool (n)
     b = ones (n, 1);
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'cool' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (cool (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (cool (64));
 
diff --git a/scripts/image/copper.m b/scripts/image/copper.m
--- a/scripts/image/copper.m
+++ b/scripts/image/copper.m
@@ -49,14 +49,15 @@ function map = copper (n)
     b = 1/2 * x;
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'copper' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (copper (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (copper (64));
 
diff --git a/scripts/image/flag.m b/scripts/image/flag.m
--- a/scripts/image/flag.m
+++ b/scripts/image/flag.m
@@ -46,14 +46,15 @@ function map = flag (n)
   else
     m1 = kron (ones (fix (n / 4), 1), p);
     m2 = p(1:rem (n, 4), :);
     map = [m1; m2];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'flag' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (flag (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (flag (64));
 
diff --git a/scripts/image/gmap40.m b/scripts/image/gmap40.m
--- a/scripts/image/gmap40.m
+++ b/scripts/image/gmap40.m
@@ -44,14 +44,15 @@ function map = gmap40 (n)
     map = repmat ([1, 0, 0; 0, 1, 0; 0, 0, 1; 1, 1, 0; 1, 0, 1; 0, 1, 1],
           ceil (n / 6), 1) (1:n, :);
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'gmap40' colormap as an image
-%! image (1:6, linspace (0, 1, 6), repmat (1:6, 6, 1)')
-%! axis ([1, 6, 0, 1], "ticy", "xy")
-%! colormap (gmap40 (6))
+%! image (1:6, linspace (0, 1, 6), repmat ((1:6)', 1, 6));
+%! axis ([1, 6, 0, 1], "ticy", "xy");
+%! colormap (gmap40 (6));
 
diff --git a/scripts/image/gray.m b/scripts/image/gray.m
--- a/scripts/image/gray.m
+++ b/scripts/image/gray.m
@@ -42,14 +42,15 @@ function map = gray (n)
   endif
 
   gr = [0:(n-1)]';
 
   map = [ gr, gr, gr ] / (n - 1);
 
 endfunction
 
+
 %!demo
 %! ## Show the 'gray' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (gray (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (gray (64));
 
diff --git a/scripts/image/hot.m b/scripts/image/hot.m
--- a/scripts/image/hot.m
+++ b/scripts/image/hot.m
@@ -49,14 +49,15 @@ function map = hot (n)
     b = (x >= 4/5) .* (5*x - 4);
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'hot' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (hot (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (hot (64));
 
diff --git a/scripts/image/hsv.m b/scripts/image/hsv.m
--- a/scripts/image/hsv.m
+++ b/scripts/image/hsv.m
@@ -50,14 +50,15 @@ function map = hsv (n)
     h = linspace (0, 1, n)';
     map = hsv2rgb ([h, ones(n, 1), ones(n, 1)]);
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'hsv' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (hsv (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (hsv (64));
 
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -170,69 +170,70 @@ function h = __img__ (x, y, img, varargi
   endif
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! img = 1 ./ hilb (11);
 %! x = -5:5;
 %! y = x;
-%! subplot (2,2,1)
-%! h = image (abs(x), abs(y), img);
-%! set (h, "cdatamapping", "scaled")
-%! ylabel ("limits = [4.5, 15.5]")
-%! title ('image (abs(x), abs(y), img)')
-%! subplot (2,2,2)
-%! h = image (-x, y, img);
-%! set (h, "cdatamapping", "scaled")
-%! title ('image (-x, y, img)')
-%! subplot (2,2,3)
-%! h = image (x, -y, img);
-%! set (h, "cdatamapping", "scaled")
-%! title ('image (x, -y, img)')
-%! ylabel ("limits = [-5.5, 5.5]")
-%! subplot (2,2,4)
-%! h = image (-x, -y, img);
-%! set (h, "cdatamapping", "scaled")
-%! title ('image (-x, -y, img)')
+%! subplot (2,2,1);
+%!  h = image (abs(x), abs(y), img);
+%!  set (h, "cdatamapping", "scaled");
+%!  ylabel ("limits = [4.5, 15.5]");
+%!  title ("image (abs(x), abs(y), img)");
+%! subplot (2,2,2);
+%!  h = image (-x, y, img);
+%!  set (h, "cdatamapping", "scaled");
+%!  title ("image (-x, y, img)");
+%! subplot (2,2,3);
+%!  h = image (x, -y, img);
+%!  set (h, "cdatamapping", "scaled");
+%!  title ("image (x, -y, img)");
+%!  ylabel ("limits = [-5.5, 5.5]");
+%! subplot (2,2,4);
+%!  h = image (-x, -y, img);
+%!  set (h, "cdatamapping", "scaled");
+%!  title ("image (-x, -y, img)");
 
 %!demo
-%! clf
+%! clf;
 %! g = 0.1:0.1:10;
 %! h = g'*g;
 %! imagesc (g, g, sin (h));
-%! hold on
+%! hold on;
 %! imagesc (g, g+12, cos (h/2));
-%! axis ([0 10 0 22])
-%! hold off
-%! title ("two consecutive images")
+%! axis ([0 10 0 22]);
+%! hold off;
+%! title ("two consecutive images");
 
 %!demo
-%! clf
+%! clf;
 %! g = 0.1:0.1:10;
 %! h = g'*g;
 %! imagesc (g, g, sin (h));
-%! hold all
-%! plot (g, 11.0 * ones (size (g)))
+%! hold all;
+%! plot (g, 11.0 * ones (size (g)));
 %! imagesc (g, g+12, cos (h/2));
-%! axis ([0 10 0 22])
-%! hold off
-%! title ("image, line, image")
+%! axis ([0 10 0 22]);
+%! hold off;
+%! title ("image, line, image");
 
 %!demo
-%! clf
+%! clf;
 %! g = 0.1:0.1:10;
 %! h = g'*g;
-%! plot (g, 10.5 * ones (size (g)))
-%! hold all
+%! plot (g, 10.5 * ones (size (g)));
+%! hold all;
 %! imagesc (g, g, sin (h));
-%! plot (g, 11.0 * ones (size (g)))
+%! plot (g, 11.0 * ones (size (g)));
 %! imagesc (g, g+12, cos (h/2));
-%! plot (g, 11.5 * ones (size (g)))
-%! axis ([0 10 0 22])
-%! hold off
-%! title ("line, image, line, image, line")
+%! plot (g, 11.5 * ones (size (g)));
+%! axis ([0 10 0 22]);
+%! hold off;
+%! title ("line, image, line, image, line");
 
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -171,40 +171,51 @@ function h = imshow (im, varargin)
   axis ("image");
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
-%!error imshow ()                           # no arguments
-%!error imshow ({"cell"})                   # No image or filename given
-%!error imshow (ones(4,4,4))                # Too many dimensions in image
+
+%!demo
+%! clf;
+%! imshow ("default.img");
 
 %!demo
-%!  imshow ("default.img");
+%! clf;
+%! imshow ("default.img");
+%! colormap (autumn (64));
 
 %!demo
-%!  imshow ("default.img");
-%!  colormap ("autumn");
+%! clf;
+%! [I, M] = imread ("default.img");
+%! imshow (I, M);
 
 %!demo
-%!  [I, M] = imread ("default.img");
-%!  imshow (I, M);
+%! clf;
+%! [I, M] = imread ("default.img");
+%! [R, G, B] = ind2rgb (I, M);
+%! imshow (cat (3, R, G*0.5, B*0.8));
 
 %!demo
-%!  [I, M] = imread ("default.img");
-%!  [R, G, B] = ind2rgb (I, M);
-%!  imshow (cat(3, R, G*0.5, B*0.8));
+%! clf;
+%! imshow (rand (100, 100));
 
 %!demo
-%!  imshow (rand (100, 100));
+%! clf;
+%! imshow (rand (100, 100, 3));
 
 %!demo
-%!  imshow (rand (100, 100, 3));
+%! clf;
+%! imshow (100*rand (100, 100, 3));
 
 %!demo
-%!  imshow (100*rand (100, 100, 3));
+%! clf;
+%! imshow (rand (100, 100));
+%! colormap (jet (64));
 
-%!demo
-%!  imshow (rand (100, 100));
-%!  colormap (jet);
+%% Test input validation
+%!error imshow ()
+%!error <IM must be an image> imshow ({"cell"})
+%!error <expecting MxN or MxNx3 matrix> imshow (ones (4,4,4))
+
diff --git a/scripts/image/jet.m b/scripts/image/jet.m
--- a/scripts/image/jet.m
+++ b/scripts/image/jet.m
@@ -52,14 +52,15 @@ function map = jet (n)
       + (x >= 3/8 & x < 5/8) .* (-4 * x + 5/2);
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'jet' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (jet (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (jet (64));
 
diff --git a/scripts/image/ocean.m b/scripts/image/ocean.m
--- a/scripts/image/ocean.m
+++ b/scripts/image/ocean.m
@@ -52,14 +52,15 @@ function map = ocean (n)
   g = prepad([0:dg:(n-1)], n)';
 
   b = [0:(n-1)]';
 
   map = [ r, g, b ] / (n - 1);
 
 endfunction
 
+
 %!demo
 %! ## Show the 'ocean' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (ocean (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (ocean (64));
 
diff --git a/scripts/image/pink.m b/scripts/image/pink.m
--- a/scripts/image/pink.m
+++ b/scripts/image/pink.m
@@ -52,14 +52,15 @@ function map = pink (n)
 
     map = sqrt ([r, g, b]);
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'pink' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (pink (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (pink (64));
 
diff --git a/scripts/image/prism.m b/scripts/image/prism.m
--- a/scripts/image/prism.m
+++ b/scripts/image/prism.m
@@ -45,14 +45,15 @@ function map = prism (n)
   if (rem (n, 6) == 0)
     map = kron(ones (fix (n / 6), 1), p);
   else
     map = [kron(ones (fix (n / 6), 1), p); p(1:rem (n, 6), :)];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'prism' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (prism (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (prism (64));
 
diff --git a/scripts/image/rainbow.m b/scripts/image/rainbow.m
--- a/scripts/image/rainbow.m
+++ b/scripts/image/rainbow.m
@@ -54,14 +54,15 @@ function map = rainbow (n)
     b = (x >= 3/5 & x < 4/5) .* (5 * x - 3) + (x >= 4/5);
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'rainbow' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (rainbow (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (rainbow (64));
 
diff --git a/scripts/image/spring.m b/scripts/image/spring.m
--- a/scripts/image/spring.m
+++ b/scripts/image/spring.m
@@ -47,14 +47,15 @@ function map = spring (n)
     b = 1 - g;
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'spring' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (spring (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (spring (64));
 
diff --git a/scripts/image/summer.m b/scripts/image/summer.m
--- a/scripts/image/summer.m
+++ b/scripts/image/summer.m
@@ -48,14 +48,15 @@ function map = summer (n)
 
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'summer' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (summer (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (summer (64));
 
diff --git a/scripts/image/white.m b/scripts/image/white.m
--- a/scripts/image/white.m
+++ b/scripts/image/white.m
@@ -42,14 +42,15 @@ function map = white (n)
   if (n > 0)
     map = ones (n, 3);
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'white' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (white (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (white (64));
 
diff --git a/scripts/image/winter.m b/scripts/image/winter.m
--- a/scripts/image/winter.m
+++ b/scripts/image/winter.m
@@ -48,14 +48,15 @@ function map = winter (n)
 
     map = [r, g, b];
   else
     map = [];
   endif
 
 endfunction
 
+
 %!demo
 %! ## Show the 'winter' colormap as an image
-%! image (1:64, linspace (0, 1, 64), repmat (1:64, 64, 1)')
-%! axis ([1, 64, 0, 1], "ticy", "xy")
-%! colormap (winter (64))
+%! image (1:64, linspace (0, 1, 64), repmat ((1:64)', 1, 64));
+%! axis ([1, 64, 0, 1], "ticy", "xy");
+%! colormap (winter (64));
 
diff --git a/scripts/linear-algebra/condest.m b/scripts/linear-algebra/condest.m
--- a/scripts/linear-algebra/condest.m
+++ b/scripts/linear-algebra/condest.m
@@ -189,50 +189,51 @@ function [est, v] = condest (varargin)
 
   [Ainv_norm, v, w] = onenormest (solve, solve_t, n, t);
 
   est = Anorm * Ainv_norm;
   v = w / norm (w, 1);
 
 endfunction
 
+
 %!demo
-%!  N = 100;
-%!  A = randn (N) + eye (N);
-%!  condest (A)
-%!  [L,U,P] = lu (A);
-%!  condest (A, @(x) U\ (L\ (P*x)), @(x) P'*(L'\ (U'\x)))
-%!  condest (@(x) A*x, @(x) A'*x, @(x) U\ (L\ (P*x)), @(x) P'*(L'\ (U'\x)), N)
-%!  norm (inv (A), 1) * norm (A, 1)
+%! N = 100;
+%! A = randn (N) + eye (N);
+%! condest (A)
+%! [L,U,P] = lu (A);
+%! condest (A, @(x) U \ (L \ (P*x)), @(x) P'*(L' \ (U'\x)))
+%! condest (@(x) A*x, @(x) A'*x, @(x) U \ (L \ (P*x)), @(x) P'*(L' \ (U'\x)), N)
+%! norm (inv (A), 1) * norm (A, 1)
 
 ## Yes, these test bounds are really loose.  There's
 ## enough randomization to trigger odd cases with hilb().
 
 %!test
-%!  N = 6;
-%!  A = hilb (N);
-%!  cA = condest (A);
-%!  cA_test = norm (inv (A), 1) * norm (A, 1);
-%!  assert (cA, cA_test, -2^-8);
+%! N = 6;
+%! A = hilb (N);
+%! cA = condest (A);
+%! cA_test = norm (inv (A), 1) * norm (A, 1);
+%! assert (cA, cA_test, -2^-8);
 
 %!test
-%!  N = 6;
-%!  A = hilb (N);
-%!  solve = @(x) A\x; solve_t = @(x) A'\x;
-%!  cA = condest (A, solve, solve_t);
-%!  cA_test = norm (inv (A), 1) * norm (A, 1);
-%!  assert (cA, cA_test, -2^-8);
+%! N = 6;
+%! A = hilb (N);
+%! solve = @(x) A\x; solve_t = @(x) A'\x;
+%! cA = condest (A, solve, solve_t);
+%! cA_test = norm (inv (A), 1) * norm (A, 1);
+%! assert (cA, cA_test, -2^-8);
 
 %!test
-%!  N = 6;
-%!  A = hilb (N);
-%!  apply = @(x) A*x; apply_t = @(x) A'*x;
-%!  solve = @(x) A\x; solve_t = @(x) A'\x;
-%!  cA = condest (apply, apply_t, solve, solve_t, N);
-%!  cA_test = norm (inv (A), 1) * norm (A, 1);
-%!  assert (cA, cA_test, -2^-6);
+%! N = 6;
+%! A = hilb (N);
+%! apply = @(x) A*x; apply_t = @(x) A'*x;
+%! solve = @(x) A\x; solve_t = @(x) A'\x;
+%! cA = condest (apply, apply_t, solve, solve_t, N);
+%! cA_test = norm (inv (A), 1) * norm (A, 1);
+%! assert (cA, cA_test, -2^-6);
 
 %!test
-%!  N = 12;
-%!  A = hilb (N);
-%!  [rcondA, v] = condest (A);
-%!  x = A*v;
-%!  assert (norm(x, inf), 0, eps);
+%! N = 12;
+%! A = hilb (N);
+%! [rcondA, v] = condest (A);
+%! x = A*v;
+%! assert (norm(x, inf), 0, eps);
diff --git a/scripts/linear-algebra/onenormest.m b/scripts/linear-algebra/onenormest.m
--- a/scripts/linear-algebra/onenormest.m
+++ b/scripts/linear-algebra/onenormest.m
@@ -233,58 +233,59 @@ function [est, v, w, iter] = onenormest 
   endfor
 
   ## The estimate est and vector w are set in the loop above. The
   ## vector v selects the ind_best column of A.
   v = zeros (n, 1);
   v(ind_best) = 1;
 endfunction
 
+
 %!demo
-%!  N = 100;
-%!  A = randn(N) + eye(N);
-%!  [L,U,P] = lu(A);
-%!  nm1inv = onenormest(@(x) U\(L\(P*x)), @(x) P'*(L'\(U'\x)), N, 30)
-%!  norm(inv(A), 1)
+%! N = 100;
+%! A = randn (N) + eye (N);
+%! [L,U,P] = lu (A);
+%! nm1inv = onenormest (@(x) U\(L\(P*x)), @(x) P'*(L'\(U'\x)), N, 30)
+%! norm (inv (A), 1)
 
 %!test
-%!  N = 10;
-%!  A = ones (N);
-%!  [nm1, v1, w1] = onenormest (A);
-%!  [nminf, vinf, winf] = onenormest (A', 6);
-%!  assert (nm1, N, -2*eps);
-%!  assert (nminf, N, -2*eps);
-%!  assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
-%!  assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
+%! N = 10;
+%! A = ones (N);
+%! [nm1, v1, w1] = onenormest (A);
+%! [nminf, vinf, winf] = onenormest (A', 6);
+%! assert (nm1, N, -2*eps);
+%! assert (nminf, N, -2*eps);
+%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
+%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
 
 %!test
-%!  N = 10;
-%!  A = ones (N);
-%!  [nm1, v1, w1] = onenormest (@(x) A*x, @(x) A'*x, N, 3);
-%!  [nminf, vinf, winf] = onenormest (@(x) A'*x, @(x) A*x, N, 3);
-%!  assert (nm1, N, -2*eps);
-%!  assert (nminf, N, -2*eps);
-%!  assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
-%!  assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
+%! N = 10;
+%! A = ones (N);
+%! [nm1, v1, w1] = onenormest (@(x) A*x, @(x) A'*x, N, 3);
+%! [nminf, vinf, winf] = onenormest (@(x) A'*x, @(x) A*x, N, 3);
+%! assert (nm1, N, -2*eps);
+%! assert (nminf, N, -2*eps);
+%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
+%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
 
 %!test
-%!  N = 5;
-%!  A = hilb (N);
-%!  [nm1, v1, w1] = onenormest (A);
-%!  [nminf, vinf, winf] = onenormest (A', 6);
-%!  assert (nm1, norm (A, 1), -2*eps);
-%!  assert (nminf, norm (A, inf), -2*eps);
-%!  assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
-%!  assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
+%! N = 5;
+%! A = hilb (N);
+%! [nm1, v1, w1] = onenormest (A);
+%! [nminf, vinf, winf] = onenormest (A', 6);
+%! assert (nm1, norm (A, 1), -2*eps);
+%! assert (nminf, norm (A, inf), -2*eps);
+%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
+%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
 
 ## Only likely to be within a factor of 10.
 %!test
-%!  old_state = rand ("state");
-%!  restore_state = onCleanup (@() rand ("state", old_state));
-%!  rand ('state', 42);  % Initialize to guarantee reproducible results
-%!  N = 100;
-%!  A = rand (N);
-%!  [nm1, v1, w1] = onenormest (A);
-%!  [nminf, vinf, winf] = onenormest (A', 6);
-%!  assert (nm1, norm (A, 1), -.1);
-%!  assert (nminf, norm (A, inf), -.1);
-%!  assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
-%!  assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
+%! old_state = rand ("state");
+%! restore_state = onCleanup (@() rand ("state", old_state));
+%! rand ('state', 42);  % Initialize to guarantee reproducible results
+%! N = 100;
+%! A = rand (N);
+%! [nm1, v1, w1] = onenormest (A);
+%! [nminf, vinf, winf] = onenormest (A', 6);
+%! assert (nm1, norm (A, 1), -.1);
+%! assert (nminf, norm (A, inf), -.1);
+%! assert (norm (w1, 1), nm1 * norm (v1, 1), -2*eps)
+%! assert (norm (winf, 1), nminf * norm (vinf, 1), -2*eps)
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -347,218 +347,224 @@ function __do_tight_option__ (ca)
        "xlim", __get_tight_lims__ (ca, "x"),
        "ylim", __get_tight_lims__ (ca, "y"));
   if __calc_dimensions__ (ca) > 2
     set (ca, "zlim", __get_tight_lims__ (ca, "z"));
   endif
 
 endfunction
 
-%!demo
-%! clf
-%! t=0:0.01:2*pi; x=sin(t);
-%!
-%! subplot(221);
-%! plot(t, x);
-%! title("normal plot");
-%!
-%! subplot(222);
-%! plot(t, x);
-%! title("square plot");
-%! axis("square");
-%!
-%! subplot(223);
-%! plot(t, x);
-%! title("equal plot");
-%! axis("equal");
-%!
-%! subplot(224);
-%! plot(t, x);
-%! title("normal plot again");
-%! axis("normal");
 
 %!demo
-%! clf
-%! t=0:0.01:2*pi; x=sin(t);
+%! clf;
+%! t = 0:0.01:2*pi;
+%! x = sin (t);
+%!
+%! subplot (221);
+%!  plot (t, x);
+%!  title ("normal plot");
+%!
+%! subplot (222);
+%!  plot (t, x);
+%!  title ("square plot");
+%!  axis ("square");
+%!
+%! subplot (223);
+%!  plot (t, x);
+%!  title ("equal plot");
+%!  axis ("equal");
 %!
-%! subplot(121);
-%! plot(t, x);
-%! title("ij plot");
-%! axis("ij");
+%! subplot (224);
+%!  plot (t, x);
+%!  title ("normal plot again");
+%!  axis ("normal");
+
+%!demo
+%! clf;
+%! t = 0:0.01:2*pi;
+%! x = sin (t);
 %!
-%! subplot(122);
-%! plot(t, x);
-%! title("xy plot");
-%! axis("xy");
+%! subplot (121);
+%!  plot (t, x);
+%!  title ("ij plot");
+%!  axis ("ij");
+%!
+%! subplot (122);
+%!  plot (t, x);
+%!  title ("xy plot");
+%!  axis ("xy");
 
 %!demo
-%! clf
-%! t=0:0.01:2*pi; x=sin(t);
+%! clf;
+%! t = 0:0.01:2*pi;
+%! x = sin (t);
 %!
-%! subplot(331);
-%! plot(t, x);
-%! title("x tics and labels");
-%! axis("ticx");
+%! subplot (331);
+%!  plot (t, x);
+%!  title ("x tics and labels");
+%!  axis ("ticx");
 %!
-%! subplot(332);
-%! plot(t, x);
-%! title("y tics and labels");
-%! axis("ticy");
+%! subplot (332);
+%!  plot (t, x);
+%!  title ("y tics and labels");
+%!  axis ("ticy");
 %!
-%! subplot(333);
-%! plot(t, x);
-%! title("axis off");
-%! axis("off");
+%! subplot (333);
+%!  plot (t, x);
+%!  title ("axis off");
+%!  axis ("off");
 %!
-%! subplot(334);
-%! plot(t, x);
-%! title("x and y tics, x labels");
-%! axis("labelx","tic");
+%! subplot (334);
+%!  plot (t, x);
+%!  title ("x and y tics, x labels");
+%!  axis ("labelx","tic");
 %!
-%! subplot(335);
-%! plot(t, x);
-%! title("x and y tics, y labels");
-%! axis("labely","tic");
+%! subplot (335);
+%!  plot (t, x);
+%!  title ("x and y tics, y labels");
+%!  axis ("labely","tic");
 %!
-%! subplot(336);
-%! plot(t, x);
-%! title("all tics but no labels");
-%! axis("nolabel","tic");
+%! subplot (336);
+%!  plot (t, x);
+%!  title ("all tics but no labels");
+%!  axis ("nolabel","tic");
 %!
-%! subplot(337);
-%! plot(t, x);
-%! title("x tics, no labels");
-%! axis("nolabel","ticx");
+%! subplot (337);
+%!  plot (t, x);
+%!  title ("x tics, no labels");
+%!  axis ("nolabel","ticx");
 %!
-%! subplot(338);
-%! plot(t, x);
-%! title("y tics, no labels");
-%! axis("nolabel","ticy");
+%! subplot (338);
+%!  plot (t, x);
+%!  title ("y tics, no labels");
+%!  axis ("nolabel","ticy");
 %!
-%! subplot(339);
-%! plot(t, x);
-%! title("all tics and labels");
-%! axis("on");
+%! subplot (339);
+%!  plot (t, x);
+%!  title ("all tics and labels");
+%!  axis ("on");
 
 %!demo
-%! clf
-%! t=0:0.01:2*pi; x=sin(t);
+%! clf;
+%! t = 0:0.01:2*pi;
+%! x = sin (t);
 %!
-%! subplot(321);
-%! plot(t, x);
-%! title("axes at [0 3 0 1]")
-%! axis([0,3,0,1]);
+%! subplot (321);
+%!  plot (t, x);
+%!  title ("axes at [0 3 0 1]");
+%!  axis ([0,3,0,1]);
 %!
-%! subplot(322);
-%! plot(t, x);
-%! title("auto");
-%! axis("auto");
+%! subplot (322);
+%!  plot (t, x);
+%!  title ("auto");
+%!  axis ("auto");
 %!
-%! subplot(323);
-%! plot(t, x, ";sine [0:2pi];"); hold on;
-%! plot(-3:3,-3:3, ";line (-3,-3)->(3,3);"); hold off;
-%! title("manual");
-%! axis("manual");
+%! subplot (323);
+%!  plot (t, x, ";sine [0:2pi];"); hold on;
+%!  plot (-3:3,-3:3, ";line (-3,-3)->(3,3);"); hold off;
+%!  title ("manual");
+%!  axis ("manual");
 %!
-%! subplot(324);
-%! plot(t, x, ";sine [0:2pi];");
-%! title("axes at [0 3 0 1], then autox");
-%! axis([0,3,0,1]); axis("autox");
+%! subplot (324);
+%!  plot (t, x, ";sine [0:2pi];");
+%!  title ("axes at [0 3 0 1], then autox");
+%!  axis ([0,3,0,1]);
+%!  axis ("autox");
 %!
-%! subplot(325);
-%! plot(t, x, ";sine [0:2p];");
-%! axis([3,6,0,1]); axis("autoy");
-%! title("axes at [3 6 0 1], then autoy");
+%! subplot (325);
+%!  plot (t, x, ";sine [0:2p];");
+%!  title ("axes at [3 6 0 1], then autoy");
+%!  axis ([3,6,0,1]);
+%!  axis ("autoy");
 %!
-%! subplot(326);
-%! plot(t, sin(t), t, -2*sin(t/2))
-%! axis("tight");
-%! title("tight");
+%! subplot (326);
+%!  plot (t, sin(t), t, -2*sin(t/2));
+%!  axis ("tight");
+%!  title ("tight");
 
 %!demo
-%! clf
-%! axis image
-%! x=0:0.1:10;
-%! plot(x,sin(x))
-%! axis image
-%! title("image")
+%! clf;
+%! x = 0:0.1:10;
+%! plot (x, sin(x));
+%! axis image;
+%! title ("image");
 
 %!demo
-%! clf
-%! [x,y,z] = peaks(50);
-%! x1 = max(x(:));
-%! pcolor(x-x1,y-x1/2,z)
-%! hold on
-%! [x,y,z] = sombrero;
-%! s = x1/max(x(:));
-%! pcolor(s*x+x1,s*y+x1/2,5*z)
-%! axis tight
+%! clf;
+%! [x,y,z] = peaks (50);
+%! x1 = max (x(:));
+%! pcolor (x-x1, y-x1/2, z);
+%! hold on;
+%! [x,y,z] = sombrero ();
+%! s = x1 / max (x(:));
+%! pcolor (s*x+x1, s*y+x1/2, 5*z);
+%! axis tight;
 
 %!demo
-%! clf
+%! clf;
 %! x = -10:10;
-%! plot (x, x, x, -x)
-%! set (gca, "yscale", "log")
-%! legend ({"x >= 1", "x <= 1"}, "location", "north")
-%! title ("ylim = [1, 10]")
+%! plot (x,x, x,-x);
+%! set (gca, "yscale", "log");
+%! legend ({"x >= 1", "x <= 1"}, "location", "north");
+%! title ("ylim = [1, 10]");
 
 %!demo
-%! clf
-%! loglog (1:20, "-s")
-%! axis tight
+%! clf;
+%! loglog (1:20, "-s");
+%! axis tight;
 
 %!demo
-%! clf
+%! clf;
 %! x = -10:0.1:10;
-%! y = sin(x)./(1+abs(x)) + x*0.1 - .4;
-%! plot (x, y)
-%! title ("no plot box")
-%! set (gca, "xaxislocation", "zero")
-%! set (gca, "yaxislocation", "zero")
-%! box off
+%! y = sin (x)./(1 + abs (x)) + 0.1*x - 0.4;
+%! plot (x, y);
+%! title ("no plot box");
+%! set (gca, "xaxislocation", "zero");
+%! set (gca, "yaxislocation", "zero");
+%! box off;
 
 %!demo
-%! clf
+%! clf;
 %! x = -10:0.1:10;
-%! y = sin(x)./(1+abs(x)) + x*0.1 - .4;
-%! plot (x, y)
-%! title ("no plot box")
-%! set (gca, "xaxislocation", "zero")
-%! set (gca, "yaxislocation", "left")
-%! box off
+%! y = sin (x)./(1+abs (x)) + 0.1*x - 0.4;
+%! plot (x, y);
+%! title ("no plot box");
+%! set (gca, "xaxislocation", "zero");
+%! set (gca, "yaxislocation", "left");
+%! box off;
 
 %!demo
-%! clf
+%! clf;
 %! x = -10:0.1:10;
-%! y = sin(x)./(1+abs(x)) + x*0.1 - .4;
-%! plot (x, y)
-%! title ("no plot box")
-%! set (gca, "xaxislocation", "zero")
-%! set (gca, "yaxislocation", "right")
-%! box off
+%! y = sin (x)./(1+abs (x)) + 0.1*x - 0.4;
+%! plot (x, y);
+%! title ("no plot box");
+%! set (gca, "xaxislocation", "zero");
+%! set (gca, "yaxislocation", "right");
+%! box off;
 
 %!demo
-%! clf
+%! clf;
 %! x = -10:0.1:10;
-%! y = sin(x)./(1+abs(x)) + x*0.1 - .4;
-%! plot (x, y)
-%! title ("no plot box")
-%! set (gca, "xaxislocation", "bottom")
-%! set (gca, "yaxislocation", "zero")
-%! box off
+%! y = sin (x)./(1+abs (x)) + 0.1*x - 0.4;
+%! plot (x, y);
+%! title ("no plot box");
+%! set (gca, "xaxislocation", "bottom");
+%! set (gca, "yaxislocation", "zero");
+%! box off;
 
 %!demo
-%! clf
+%! clf;
 %! x = -10:0.1:10;
-%! y = sin(x)./(1+abs(x)) + x*0.1 - .4;
-%! plot (x, y)
-%! title ("no plot box")
-%! set (gca, "xaxislocation", "top")
-%! set (gca, "yaxislocation", "zero")
-%! box off
+%! y = sin (x)./(1+abs (x)) + 0.1*x - 0.4;
+%! plot (x, y);
+%! title ("no plot box");
+%! set (gca, "xaxislocation", "top");
+%! set (gca, "yaxislocation", "zero");
+%! box off;
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot (11:20, [21:24, NaN, -Inf, 27:30]);
 %!   hold all;
 %!   plot (11:20, 25.5 + rand (10));
 %!   axis tight;
@@ -566,15 +572,15 @@ endfunction
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
-%!   loglog (a, -a)
+%!   loglog (a, -a);
 %!   axis tight;
-%!   assert (axis (), [1e-5, 10, -10, -1e-5])
+%!   assert (axis (), [1e-5, 10, -10, -1e-5]);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/clabel.m b/scripts/plot/clabel.m
--- a/scripts/plot/clabel.m
+++ b/scripts/plot/clabel.m
@@ -122,21 +122,22 @@ function retval = clabel (c, varargin)
     endif
     retval = findobj (hg, "type", "text");
     if (! isempty (varargin))
       set (retval, varargin {:});
     endif
   else
     retval =  __clabel__ (c, v, hparent, label_spacing, [], varargin{:});
   endif
+
 endfunction
 
 
 %!demo
-%! clf
-%! [c, h] = contour (peaks(), -4:6);
+%! clf;
+%! [c, h] = contour (peaks (), -4:6);
 %! clabel (c, h, -4:2:6, "fontsize", 12);
 
 %!demo
-%! clf
-%! [c, h] = contourf (peaks(), -7:6);
+%! clf;
+%! [c, h] = contourf (peaks (), -7:6);
 %! clabel (c, h, -6:2:6, "fontsize", 12);
 
diff --git a/scripts/plot/colorbar.m b/scripts/plot/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/colorbar.m
@@ -357,257 +357,264 @@ function [pos, cpos, vertical, mirr] = _
       dy = (1-scale)*actual_pos(4);
       cpos(2) = actual_pos(2) + dy/2;
       cpos(4) = actual_pos(4) - dy;
     endif
   endif
 
 endfunction
 
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! imagesc(x)
-%! colorbar();
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! imagesc(x)
-%! colorbar("westoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! imagesc(x)
-%! colorbar("peer", gca (), "northoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! imagesc(x)
-%! colorbar("southoutside");
-
-%!demo
-%! clf
-%! contour(peaks())
-%! colorbar("west");
-
-%!demo
-%! clf
-%! subplot(2,2,1)
-%! contour(peaks())
-%! colorbar("east");
-%! subplot(2,2,2)
-%! contour(peaks())
-%! colorbar("west");
-%! subplot(2,2,3)
-%! contour(peaks())
-%! colorbar("north");
-%! subplot(2,2,4)
-%! contour(peaks())
-%! colorbar("south");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(2,2,1)
-%! imagesc(x)
-%! colorbar();
-%! subplot(2,2,2)
-%! imagesc(x)
-%! colorbar("westoutside");
-%! subplot(2,2,3)
-%! imagesc(x)
-%! colorbar("northoutside");
-%! subplot(2,2,4)
-%! imagesc(x)
-%! colorbar("southoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(1,2,1)
-%! imagesc(x)
-%! axis square;
-%! colorbar();
-%! subplot(1,2,2)
-%! imagesc(x)
-%! axis square;
-%! colorbar("westoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(1,2,1)
-%! imagesc(x)
-%! axis square;
-%! colorbar("northoutside");
-%! subplot(1,2,2)
-%! imagesc(x)
-%! axis square;
-%! colorbar("southoutside");
 
 %!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(2,1,1)
-%! imagesc(x)
-%! axis square;
-%! colorbar();
-%! subplot(2,1,2)
-%! imagesc(x)
-%! axis square;
-%! colorbar("westoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(2,1,1)
-%! imagesc(x)
-%! axis square;
-%! colorbar("northoutside");
-%! subplot(2,1,2)
-%! imagesc(x)
-%! axis square;
-%! colorbar("southoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(1,2,1)
-%! imagesc(x)
-%! colorbar();
-%! subplot(1,2,2)
-%! imagesc(x)
-%! colorbar("westoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(1,2,1)
-%! imagesc(x)
-%! colorbar("northoutside");
-%! subplot(1,2,2)
-%! imagesc(x)
-%! colorbar("southoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(2,1,1)
-%! imagesc(x)
-%! colorbar();
-%! subplot(2,1,2)
-%! imagesc(x)
-%! colorbar("westoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(2,1,1)
-%! imagesc(x)
-%! colorbar("northoutside");
-%! subplot(2,1,2)
-%! imagesc(x)
-%! colorbar("southoutside");
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! subplot(1,2,1)
-%! contour(x)
-%! axis square;
-%! colorbar("east");
-%! xlim ([1, 64])
-%! ylim ([1, 64])
-%! subplot(1,2,2)
-%! contour(x)
-%! colorbar("west");
-%! xlim ([1, 64])
-%! ylim ([1, 64])
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! contour (x)
-%! xlim ([1, 64])
-%! ylim ([1, 64])
-%! colorbar ();
-%! colorbar off
-
-%!demo
-%! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
-%! contour (x)
-%! xlim ([1, 64])
-%! ylim ([1, 64])
-%! colorbar ();
+%! clf;
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! imagesc (x);
 %! colorbar ();
 
 %!demo
-%! clf
-%! imagesc (1./hilb(99));
-%! h = colorbar;
-%! set (h, 'yscale', 'log');
+%! clf;
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! imagesc (x);
+%! colorbar ("westoutside");
+
+%!demo
+%! clf;
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! imagesc (x);
+%! colorbar ("peer", gca (), "northoutside");
+
+%!demo
+%! clf;
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! imagesc (x);
+%! colorbar ("southoutside");
+
+%!demo
+%! clf;
+%! contour (peaks ());
+%! colorbar ("west");
 
 %!demo
-%! clf
-%! imagesc (log10 (1 ./ hilb (99)));
-%! h = colorbar;
-%! ytick = get(h, "ytick");
-%! set (h, "yticklabel", sprintf ('10^{%g}|', ytick));
+%! clf;
+%! subplot (2,2,1);
+%!  contour (peaks ());
+%!  colorbar ("east");
+%! subplot (2,2,2);
+%!  contour (peaks ());
+%!  colorbar ("west");
+%! subplot (2,2,3);
+%!  contour (peaks ());
+%!  colorbar ("north");
+%! subplot (2,2,4);
+%!  contour (peaks ());
+%!  colorbar ("south");
+
+%!demo
+%! clf;
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (2,2,1);
+%!  imagesc (x);
+%!  colorbar ();
+%! subplot (2,2,2);
+%!  imagesc (x);
+%!  colorbar ("westoutside");
+%! subplot (2,2,3);
+%!  imagesc (x);
+%!  colorbar ("northoutside");
+%! subplot (2,2,4);
+%!  imagesc (x);
+%!  colorbar ("southoutside");
 
 %!demo
-%! clf
-%! n=5;x=linspace(0,5,n);y=linspace(0,1,n);
-%! imagesc(1./hilb(n)); axis equal; colorbar
+%! clf;
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (1,2,1);
+%!  imagesc (x);
+%!  axis square;
+%!  colorbar ();
+%! subplot (1,2,2);
+%!  imagesc (x);
+%!  axis square;
+%!  colorbar ("westoutside");
+
+%!demo
+%! clf;
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (1,2,1);
+%!  imagesc (x);
+%!  axis square;
+%!  colorbar ("northoutside");
+%! subplot (1,2,2);
+%!  imagesc (x);
+%!  axis square;
+%!  colorbar ("southoutside");
 
 %!demo
-%! clf
-%! n=5;x=linspace(0,5,n);y=linspace(0,1,n);
-%! imagesc(x,y,1./hilb(n)); axis equal; colorbar
+%! clf;
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (2,1,1);
+%!  imagesc (x);
+%!  axis square;
+%!  colorbar ();
+%! subplot (2,1,2);
+%!  imagesc (x);
+%!  axis square;
+%!  colorbar ("westoutside");
 
 %!demo
-%! clf
-%! n=5;x=linspace(0,5,n);y=linspace(0,1,n);
-%! imagesc(y,x,1./hilb(n)); axis equal; colorbar
-## This requires that the axes position be properly determined for "axes equal"
+%! clf;
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (2,1,1);
+%!  imagesc (x);
+%!  axis square;
+%!  colorbar ("northoutside");
+%! subplot (2,1,2);
+%!  imagesc (x);
+%!  axis square;
+%!  colorbar ("southoutside");
+
+%!demo
+%! clf;
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (1,2,1);
+%!  imagesc (x);
+%!  colorbar ();
+%! subplot (1,2,2);
+%!  imagesc (x);
+%!  colorbar ("westoutside");
+
+%!demo
+%! clf;
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (1,2,1);
+%!  imagesc (x);
+%!  colorbar ("northoutside");
+%! subplot (1,2,2);
+%!  imagesc (x);
+%!  colorbar ("southoutside");
 
 %!demo
-%! clf
-%! axes
-%! colorbar
-%! hold on
-%! contour(peaks)
-%! hold off
+%! clf;
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (2,1,1);
+%!  imagesc (x);
+%!  colorbar ();
+%! subplot (2,1,2);
+%!  imagesc (x);
+%!  colorbar ("westoutside");
+
+%!demo
+%! clf;
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (2,1,1);
+%!  imagesc (x);
+%!  colorbar ("northoutside");
+%! subplot (2,1,2);
+%!  imagesc (x);
+%!  colorbar ("southoutside");
 
 %!demo
-%! clf
-%! plot([0, 2])
-%! colorbar ("east")
-%! axis square
+%! clf;
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! subplot (1,2,1);
+%!  contour (x);
+%!  axis square;
+%!  colorbar ("east");
+%!  xlim ([1, 64]);
+%!  ylim ([1, 64]);
+%! subplot (1,2,2);
+%!  contour (x);
+%!  colorbar ("west");
+%!  xlim ([1, 64]);
+%!  ylim ([1, 64]);
+
+%!demo
+%! clf;
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! contour (x);
+%! xlim ([1, 64]);
+%! ylim ([1, 64]);
+%! colorbar ();
+%! colorbar off;
+
+%!demo
+%! clf;
+%! n = 64; x = kron (1:n, ones (n,1)); x = abs (x - x.');
+%! contour (x);
+%! xlim ([1, 64]);
+%! ylim ([1, 64]);
+%! colorbar ();
+
+%!demo
+%! clf;
+%! imagesc (1 ./ hilb (99));
+%! h = colorbar ();
+%! set (h, "yscale", "log");
 
 %!demo
-%! clf
-%! plot([0, 2])
-%! colorbar ("eastoutside")
-%! axis square
+%! clf;
+%! imagesc (log10 (1 ./ hilb (99)));
+%! h = colorbar ();
+%! ytick = get (h, "ytick");
+%! set (h, "yticklabel", sprintf ("10^{%g}|", ytick));
+
+%!demo
+%! clf;
+%! n = 5; x = linspace (0,5,n); y = linspace (0,1,n);
+%! imagesc (1 ./ hilb (n));
+%! axis equal;
+%! colorbar ();
+
+%!demo
+%! clf;
+%! n = 5; x = linspace (0,5,n); y = linspace (0,1,n);
+%! imagesc (x, y, 1 ./ hilb (n));
+%! axis equal;
+%! colorbar ();
 
 %!demo
-%! clf
-%! pcolor (peaks (20))
-%! shading ("interp")
-%! axis ("tight", "square")
-%! colorbar ()
-#%! axes('color','none','box','on','activepositionproperty','position')
+%! clf;
+%! n = 5; x = linspace (0,5,n); y = linspace (0,1,n);
+%! imagesc (y, x, 1 ./ hilb (n));
+%! axis equal;
+%! colorbar ();
+
+## This requires that the axes position be properly determined for "axis equal"
+%!demo
+%! clf;
+%! axes;
+%! colorbar ();
+%! hold on;
+%! contour (peaks ());
+%! hold off;
+
+%!demo
+%! clf;
+%! plot ([0, 2]);
+%! colorbar ("east");
+%! axis square;
 
 %!demo
-%! clf
-%! plot([0, 2])
-%! colorbar ("east")
-%! axis equal
+%! clf;
+%! plot ([0, 2]);
+%! colorbar ("eastoutside");
+%! axis square;
 
 %!demo
-%! clf
-%! plot([0, 2])
-%! colorbar ("eastoutside")
-%! axis equal
+%! clf;
+%! pcolor (peaks (20));
+%! shading interp;
+%! axis ("tight", "square");
+%! colorbar ();
+#%! axes ("color","none","box","on","activepositionproperty","position");
+
+%!demo
+%! clf;
+%! plot ([0, 2]);
+%! colorbar ("east");
+%! axis equal;
+
+%!demo
+%! clf;
+%! plot ([0, 2]);
+%! colorbar ("eastoutside");
+%! axis equal;
+
diff --git a/scripts/plot/comet.m b/scripts/plot/comet.m
--- a/scripts/plot/comet.m
+++ b/scripts/plot/comet.m
@@ -73,16 +73,16 @@ function comet (varargin)
       pause (p);
     endfor
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! t = 0:.1:2*pi;
-%! x = cos(2*t).*(cos(t).^2);
-%! y = sin(2*t).*(sin(t).^2);
-%! comet(x,y)
+%! x = cos (2*t) .* (cos (t).^2);
+%! y = sin (2*t) .* (sin (t).^2);
+%! comet (x,y);
 
-
diff --git a/scripts/plot/comet3.m b/scripts/plot/comet3.m
--- a/scripts/plot/comet3.m
+++ b/scripts/plot/comet3.m
@@ -75,12 +75,14 @@ function comet3 (varargin)
       pause (p);
     endfor
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! t = 0:pi/20:5*pi;
 %! comet3 (cos(t), sin(t), t, 0.01);
+
diff --git a/scripts/plot/compass.m b/scripts/plot/compass.m
--- a/scripts/plot/compass.m
+++ b/scripts/plot/compass.m
@@ -107,14 +107,14 @@ function retval = compass (varargin)
   if (nargout > 0)
     retval = hlist;
   endif
 
 endfunction
 
 
 %!demo
-%! clf
+%! clf;
 %! randn_9x1_data = [-2.555884; 0.394974; -0.191871; -1.147024; 1.355425; -0.437335; -0.014370; -0.941312; 1.240300];
 %! randn_1x9_data = [1.42934, -1.10821, -1.70404, 0.63357, -0.68337, -1.19771, -0.96502, -1.12810, 0.22457];
 %! a = toeplitz ([1;randn_9x1_data], [1,randn_1x9_data]);
 %! compass (eig (a));
 
diff --git a/scripts/plot/contour.m b/scripts/plot/contour.m
--- a/scripts/plot/contour.m
+++ b/scripts/plot/contour.m
@@ -65,28 +65,29 @@ function [c, h] = contour (varargin)
 
   if (nargout > 0)
     c = ctmp;
     h = htmp;
   endif
 
 endfunction
 
+
 %!demo
-%! clf ()
+%! clf;
 %! [x, y, z] = peaks ();
 %! contour (x, y, z);
 
 %!demo
-%! clf ()
-%! [theta, r] = meshgrid (linspace (0, 2*pi, 64), linspace(0,1,64));
+%! clf;
+%! [theta, r] = meshgrid (linspace (0,2*pi,64), linspace (0,1,64));
 %! [X, Y] = pol2cart (theta, r);
-%! Z = sin(2*theta).*(1-r);
-%! contour(X, Y, abs(Z), 10)
+%! Z = sin (2*theta) .* (1-r);
+%! contour (X, Y, abs(Z), 10);
 
 %!demo
-%! clf ()
+%! clf;
 %! x = linspace (-2, 2);
 %! [x, y] = meshgrid (x);
-%! z = sqrt (x.^2 + y.^2) ./ (x.^2 + y.^2+1);
-%! contourf (x, y, z, [0.4, 0.4])
-%! title ("The hole should be filled with the background color")
+%! z = sqrt (x.^2 + y.^2) ./ (x.^2 + y.^2 + 1);
+%! contourf (x, y, z, [0.4, 0.4]);
+%! title ("The hole should be filled with the background color");
 
diff --git a/scripts/plot/contour3.m b/scripts/plot/contour3.m
--- a/scripts/plot/contour3.m
+++ b/scripts/plot/contour3.m
@@ -69,18 +69,20 @@ function [c, h] = contour3 (varargin)
 
   if (nargout > 0)
     c = ctmp;
     h = htmp;
   endif
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! contour3 (peaks (19));
-%! hold on
-%! surface (peaks (19), "facecolor", "none", "edgecolor", "black")
-%! colormap hot
-%! axis tight
-%! zlim auto
-%! hold off
-%! box off
+%! hold on;
+%! surface (peaks (19), "facecolor", "none", "edgecolor", "black");
+%! colormap (hot (64));
+%! axis tight;
+%! zlim auto;
+%! box off;
+%! hold off;
+
diff --git a/scripts/plot/contourf.m b/scripts/plot/contourf.m
--- a/scripts/plot/contourf.m
+++ b/scripts/plot/contourf.m
@@ -73,21 +73,24 @@ function [c, h] = contourf (varargin)
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
   if (nargout > 0)
     c = ctmp;
     h = htmp;
   endif
+
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! [x, y, z] = peaks (50);
-%! contourf (x, y, z, -7:9)
+%! contourf (x, y, z, -7:9);
 
 %!demo
-%! clf
-%! [theta, r] = meshgrid (linspace (0, 2*pi, 64), linspace(0,1,64));
+%! clf;
+%! [theta, r] = meshgrid (linspace (0,2*pi,64), linspace (0,1,64));
 %! [X, Y] = pol2cart (theta, r);
-%! Z = sin(2*theta).*(1-r);
-%! contourf(X, Y, abs(Z), 10)
+%! Z = sin (2*theta) .* (1-r);
+%! contourf (X, Y, abs (Z), 10);
+
diff --git a/scripts/plot/cylinder.m b/scripts/plot/cylinder.m
--- a/scripts/plot/cylinder.m
+++ b/scripts/plot/cylinder.m
@@ -80,13 +80,15 @@ function [xx, yy, zz] = cylinder (vararg
     yy = y;
     zz = z;
   else
     surf (ax, x, y, z);
   endif
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! [x, y, z] = cylinder (10:-1:0,50);
 %! surf (x, y, z);
-%! title ("a cone")
+%! title ("a cone");
+
diff --git a/scripts/plot/daspect.m b/scripts/plot/daspect.m
--- a/scripts/plot/daspect.m
+++ b/scripts/plot/daspect.m
@@ -84,50 +84,51 @@ function varargout = daspect (varargin)
   if (nargout == 1)
     varargout{1} = get (hax, "dataaspectratio");
   elseif (nargout > 1)
     error ("daspect: only one output is allowed");
   endif
 
 endfunction
 
-%!demo
-%! x = 0:0.01:4;
-%! clf
-%! plot (x, cos (x), x, sin (x))
-%! axis square
-%! daspect ([1 1 1])
-%! title ("square plot-box with axis limits [0, 4, -2, 2]")
 
 %!demo
+%! clf;
 %! x = 0:0.01:4;
-%! clf
-%! plot (x, cos (x), x, sin (x))
-%! axis ([0 4 -1 1])
-%! daspect ([2 1 1])
-%! title ("square plot-box with axis limits [0, 4, -1, 1]")
+%! plot (x,cos(x), x,sin(x));
+%! axis square;
+%! daspect ([1 1 1]);
+%! title ("square plot-box with axis limits [0, 4, -2, 2]");
+
+%!demo
+%! clf;
+%! x = 0:0.01:4;
+%! plot (x,cos (x), x,sin (x));
+%! axis ([0 4 -1 1]);
+%! daspect ([2 1 1]);
+%! title ("square plot-box with axis limits [0, 4, -1, 1]");
 
 %!demo
+%! clf;
 %! x = 0:0.01:4;
-%! clf
-%! plot (x, cos (x), x, sin (x))
-%! daspect ([1 2 1])
-%! pbaspect ([2 1 1])
-%! title ("2x1 plot box with axis limits [0, 4, -2, 2]")
+%! plot (x,cos(x), x,sin(x));
+%! daspect ([1 2 1]);
+%! pbaspect ([2 1 1]);
+%! title ("2x1 plot box with axis limits [0, 4, -2, 2]");
 
 %!demo
+%! clf;
 %! x = 0:0.01:4;
-%! clf
-%! plot (x, cos (x), x, sin (x))
-%! axis square
-%! set (gca, "activepositionproperty", "position")
-%! daspect ([1 1 1])
-%! title ("square plot-box with axis limits [0, 4, -2, 2]")
+%! plot (x,cos(x), x, sin(x));
+%! axis square;
+%! set (gca, "activepositionproperty", "position");
+%! daspect ([1 1 1]);
+%! title ("square plot-box with axis limits [0, 4, -2, 2]");
 
 %!demo
+%! clf;
 %! x = 0:0.01:4;
-%! clf
-%! plot (x, cos (x), x, sin (x))
-%! axis ([0 4 -1 1])
-%! set (gca, "activepositionproperty", "position")
-%! daspect ([2 1 1])
-%! title ("square plot-box with axis limits [0, 4, -1, 1]")
+%! plot (x,cos(x), x,sin(x));
+%! axis ([0 4 -1 1]);
+%! set (gca, "activepositionproperty", "position");
+%! daspect ([2 1 1]);
+%! title ("square plot-box with axis limits [0, 4, -1, 1]");
 
diff --git a/scripts/plot/ellipsoid.m b/scripts/plot/ellipsoid.m
--- a/scripts/plot/ellipsoid.m
+++ b/scripts/plot/ellipsoid.m
@@ -64,11 +64,13 @@ function [xx, yy, zz] = ellipsoid (varar
     yy = y;
     zz = z;
   else
     surf (h, x, y, z);
   endif
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! ellipsoid (0, 0, 1, 2, 3, 4, 20);
+
diff --git a/scripts/plot/errorbar.m b/scripts/plot/errorbar.m
--- a/scripts/plot/errorbar.m
+++ b/scripts/plot/errorbar.m
@@ -133,44 +133,44 @@ function retval = errorbar (varargin)
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
 
 %!demo
-%! clf
+%! clf;
 %! rand_1x11_data1 = [0.82712, 0.50325, 0.35613, 0.77089, 0.20474, 0.69160, 0.30858, 0.88225, 0.35187, 0.14168, 0.54270];
 %! rand_1x11_data2 = [0.506375, 0.330106, 0.017982, 0.859270, 0.140641, 0.327839, 0.275886, 0.162453, 0.807592, 0.318509, 0.921112];
 %! errorbar (0:10, rand_1x11_data1, 0.25*rand_1x11_data2);
 
 %!demo
-%! clf
+%! clf;
 %! rand_1x11_data3 = [0.423650, 0.142331, 0.213195, 0.129301, 0.975891, 0.012872, 0.635327, 0.338829, 0.764997, 0.401798, 0.551850];
 %! rand_1x11_data4 = [0.682566, 0.456342, 0.132390, 0.341292, 0.108633, 0.601553, 0.040455, 0.146665, 0.309187, 0.586291, 0.540149];
-%! errorbar(0:10, rand_1x11_data3, rand_1x11_data4, ">");
+%! errorbar (0:10, rand_1x11_data3, rand_1x11_data4, ">");
 
 %!demo
-%! clf
+%! clf;
 %! x = 0:0.5:2*pi;
 %! err = x/100;
 %! y1 = sin (x);
 %! y2 = cos (x);
 %! hg = errorbar (x, y1, err, "~", x, y2, err, ">");
 
 %!demo
-%! clf
+%! clf;
 %! x = 0:0.5:2*pi;
 %! err = x/100;
 %! y1 = sin (x);
 %! y2 = cos (x);
 %! hg = errorbar (x, y1, err, err, "#r", x, y2, err, err, "#~");
 
 %!demo
-%! clf
+%! clf;
 %! x = 0:0.5:2*pi;
 %! err = x/100;
 %! y1 = sin (x);
 %! y2 = cos (x);
 %! hg = errorbar (x, y1, err, err, err, err, "~>", ...
 %!                x, y2, err, err, err, err, "#~>-*");
 
diff --git a/scripts/plot/ezcontour.m b/scripts/plot/ezcontour.m
--- a/scripts/plot/ezcontour.m
+++ b/scripts/plot/ezcontour.m
@@ -53,16 +53,17 @@ function retval = ezcontour (varargin)
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
+
 endfunction
 
 
 %!demo
-%! clf
-%! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+%! clf;
+%! f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezcontour (f, [-3, 3]);
 
diff --git a/scripts/plot/ezcontourf.m b/scripts/plot/ezcontourf.m
--- a/scripts/plot/ezcontourf.m
+++ b/scripts/plot/ezcontourf.m
@@ -53,15 +53,17 @@ function retval = ezcontourf (varargin)
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
+
 endfunction
 
 
 %!demo
-%! clf
-%! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+%! clf;
+%! f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezcontourf (f, [-3, 3]);
+
diff --git a/scripts/plot/ezmesh.m b/scripts/plot/ezmesh.m
--- a/scripts/plot/ezmesh.m
+++ b/scripts/plot/ezmesh.m
@@ -74,23 +74,24 @@ function retval = ezmesh (varargin)
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
+
 endfunction
 
 
 %!demo
-%! clf
-%! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+%! clf;
+%! f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezmesh (f, [-3, 3]);
 
 %!demo
-%! clf
+%! clf;
 %! fx = @(s,t) cos (s) .* cos(t);
 %! fy = @(s,t) sin (s) .* cos(t);
 %! fz = @(s,t) sin (t);
 %! ezmesh (fx, fy, fz, [-pi,pi,-pi/2,pi/2], 20);
 
diff --git a/scripts/plot/ezmeshc.m b/scripts/plot/ezmeshc.m
--- a/scripts/plot/ezmeshc.m
+++ b/scripts/plot/ezmeshc.m
@@ -64,16 +64,17 @@ function retval = ezmeshc (varargin)
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
+
 endfunction
 
 
 %!demo
-%! clf
-%! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+%! clf;
+%! f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezmeshc (f, [-3, 3]);
 
diff --git a/scripts/plot/ezplot.m b/scripts/plot/ezplot.m
--- a/scripts/plot/ezplot.m
+++ b/scripts/plot/ezplot.m
@@ -72,23 +72,24 @@ function retval = ezplot (varargin)
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
+
 endfunction
 
 
 %!demo
-%! clf
-%! ezplot (@cos, @sin)
+%! clf;
+%! ezplot (@cos, @sin);
 
 %!demo
-%! clf
-%! ezplot ("1/x")
+%! clf;
+%! ezplot ("1/x");
 
 %!demo
-%! clf
-%! ezplot (inline ("x^2 - y^2 = 1"))
+%! clf;
+%! ezplot (inline ("x^2 - y^2 = 1"));
 
diff --git a/scripts/plot/ezplot3.m b/scripts/plot/ezplot3.m
--- a/scripts/plot/ezplot3.m
+++ b/scripts/plot/ezplot3.m
@@ -52,18 +52,19 @@ function retval = ezplot3 (varargin)
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
+
 endfunction
 
 
 %!demo
-%! clf
+%! clf;
 %! fx = @(t) cos (t);
 %! fy = @(t) sin (t);
 %! fz = @(t) t;
 %! ezplot3 (fx, fy, fz, [0, 10*pi], 100);
 
diff --git a/scripts/plot/ezpolar.m b/scripts/plot/ezpolar.m
--- a/scripts/plot/ezpolar.m
+++ b/scripts/plot/ezpolar.m
@@ -47,15 +47,16 @@ function retval = ezpolar (varargin)
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
+
 endfunction
 
 
 %!demo
-%! clf
+%! clf;
 %! ezpolar (@(t) 1 + sin (t));
 
diff --git a/scripts/plot/ezsurf.m b/scripts/plot/ezsurf.m
--- a/scripts/plot/ezsurf.m
+++ b/scripts/plot/ezsurf.m
@@ -74,23 +74,24 @@ function retval = ezsurf (varargin)
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
+
 endfunction
 
 
 %!demo
-%! clf
-%! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+%! clf;
+%! f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezsurf (f, [-3, 3]);
 
 %!demo
-%! clf
+%! clf;
 %! fx = @(s,t) cos (s) .* cos(t);
 %! fy = @(s,t) sin (s) .* cos(t);
 %! fz = @(s,t) sin (t);
 %! ezsurf (fx, fy, fz, [-pi,pi,-pi/2,pi/2], 20);
 
diff --git a/scripts/plot/ezsurfc.m b/scripts/plot/ezsurfc.m
--- a/scripts/plot/ezsurfc.m
+++ b/scripts/plot/ezsurfc.m
@@ -64,16 +64,17 @@ function retval = ezsurfc (varargin)
 
   if (needusage)
     print_usage ();
   endif
 
   if (nargout > 0)
     retval = h;
   endif
+
 endfunction
 
 
 %!demo
-%! clf
-%! f = @(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
+%! clf;
+%! f = @(x,y) sqrt (abs (x .* y)) ./ (1 + x.^2 + y.^2);
 %! ezsurfc (f, [-3, 3]);
 
diff --git a/scripts/plot/feather.m b/scripts/plot/feather.m
--- a/scripts/plot/feather.m
+++ b/scripts/plot/feather.m
@@ -106,12 +106,12 @@ function retval = feather (varargin)
   if (nargout > 0)
     retval = hlist;
   endif
 
 endfunction
 
 
 %!demo
-%! clf
-%! phi = [0 : 15 : 360] * pi / 180;
-%! feather (sin (phi), cos (phi))
+%! clf;
+%! phi = [0 : 15 : 360] * pi/180;
+%! feather (sin (phi), cos (phi));
 
diff --git a/scripts/plot/fill.m b/scripts/plot/fill.m
--- a/scripts/plot/fill.m
+++ b/scripts/plot/fill.m
@@ -104,21 +104,22 @@ function iargs = __find_patches__ (varar
             break;
           endif
         else
           i += 2;
         endif
       endwhile
     endif
   endwhile
+
 endfunction
 
 
 %!demo
-%! clf
-%! t1 = (1/16:1/8:1)*2*pi;
-%! t2 = ((1/16:1/8:1) + 1/32)*2*pi;
+%! clf;
+%! t1 = (1/16:1/8:1) * 2*pi;
+%! t2 = ((1/16:1/8:1) + 1/32) * 2*pi;
 %! x1 = sin (t1) - 0.8;
 %! y1 = cos (t1);
 %! x2 = sin (t2) + 0.8;
 %! y2 = cos (t2);
 %! h = fill (x1,y1,'r', x2,y2,'g');
 
diff --git a/scripts/plot/fplot.m b/scripts/plot/fplot.m
--- a/scripts/plot/fplot.m
+++ b/scripts/plot/fplot.m
@@ -122,15 +122,17 @@ function fplot (fn, limits, n, fmt)
   else
     for i = 1:columns (y)
       nams{i} = sprintf ("%s(:,%i)", nam, i);
     endfor
     legend (nams{:});
   endif
 endfunction
 
-%!demo
-%! clf
-%! fplot ("cos", [0, 2*pi])
 
 %!demo
-%! clf
-%! fplot ("[cos(x), sin(x)]", [0, 2*pi])
+%! clf;
+%! fplot ("cos", [0, 2*pi]);
+
+%!demo
+%! clf;
+%! fplot ("[cos(x), sin(x)]", [0, 2*pi]);
+
diff --git a/scripts/plot/grid.m b/scripts/plot/grid.m
--- a/scripts/plot/grid.m
+++ b/scripts/plot/grid.m
@@ -93,29 +93,28 @@ function grid (varargin)
     endif
   else
     set (ax, "xgrid", "off", "ygrid", "off", "zgrid", "off");
     set (ax, "xminorgrid", "off", "yminorgrid", "off", "zminorgrid", "off");
   endif
 
 endfunction
 
+
 %!demo
-%! clf
-%! subplot (2,2,1)
-%! plot (1:100)
-%! grid minor
-%! grid minor
-%! grid
-%! title ("no grid")
-%! subplot (2,2,2)
-%! plot (1:100)
-%! grid
-%! title ("grid on")
-%! subplot (2,2,3)
-%! plot (1:100)
-%! grid minor
-%! title ("grid minor")
-%! subplot (2,2,4)
-%! semilogy (1:100)
-%! grid minor
-%! title ("grid minor")
+%! clf;
+%! subplot (2,2,1);
+%!  plot (1:100);
+%!  grid off;
+%!  title ("no grid");
+%! subplot (2,2,2);
+%!  plot (1:100);
+%!  grid on;
+%!  title ("grid on");
+%! subplot (2,2,3);
+%!  plot (1:100);
+%!  grid minor;
+%!  title ("grid minor");
+%! subplot (2,2,4);
+%!  semilogy (1:100);
+%!  grid minor;
+%!  title ("grid minor");
 
diff --git a/scripts/plot/hold.m b/scripts/plot/hold.m
--- a/scripts/plot/hold.m
+++ b/scripts/plot/hold.m
@@ -89,85 +89,87 @@ function hold (varargin)
   else
     set (ax, "nextplot", "add");
     set (fig, "nextplot", "add");
   endif
   set (ax, "__hold_all__", hold_all);
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! A = rand (100);
 %! [X, Y] = find (A > 0.9);
-%! imshow (A)
-%! hold on
-%! plot (X, Y, 'o')
-%! hold off
-
-%!demo
-%! clf
-%! hold on
-%! imagesc(1./hilb(4));
-%! plot (1:4, "-s")
-%! hold off
+%! imshow (A);
+%! hold on;
+%! plot (X, Y, 'o');
+%! hold off;
 
 %!demo
-%! clf
-%! hold on
-%! imagesc(1./hilb(2));
-%! imagesc(1./hilb(4));
-%! hold off
+%! clf;
+%! hold on;
+%! imagesc (1 ./ hilb (4));
+%! plot (1:4, "-s");
+%! hold off;
 
 %!demo
-%! clf
-%! hold on
-%! plot (1:4, "-s")
-%! imagesc(1./hilb(4));
-%! hold off
+%! clf;
+%! hold on;
+%! imagesc (1 ./ hilb (2));
+%! imagesc (1 ./ hilb (4));
+%! hold off;
 
 %!demo
-%! clf
-%! colormap (jet)
+%! clf;
+%! hold on;
+%! plot (1:4, "-s");
+%! imagesc (1 ./ hilb (4));
+%! hold off;
+
+%!demo
+%! clf;
+%! colormap (jet (64));
 %! t = linspace (-3, 3, 50);
 %! [x, y] = meshgrid (t, t);
 %! z = peaks (x, y);
 %! contourf (x, y, z, 10);
-%! hold ("on");
+%! hold on;
 %! plot (vec (x), vec (y), "^");
 %! patch ([-1.0 1.0 1.0 -1.0 -1.0], [-1.0 -1.0 1.0 1.0 -1.0], "red");
 %! xlim ([-2.0 2.0]);
 %! ylim ([-2.0 2.0]);
 %! colorbar ("SouthOutside");
 %! title ("Test script for some plot functions");
 
 ##hold on
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   p = plot ([0 1]);
-%!   assert (!ishold);
+%!   assert (! ishold);
 %!   hold on;
 %!   assert (ishold);
 %!   p1 = fill ([0 1 1], [0 0 1],"black");
 %!   p2 = fill ([0 1 0], [0 1 1], "red");
 %!   assert (length (get (hf, "children")), 1);
 %!   assert (length (get (gca, "children")), 3);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 ##hold off
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   p = plot ([0 1]);
-%!   assert (!ishold);
+%!   assert (! ishold);
 %!   hold on;
 %!   assert (ishold);
 %!   p1 = fill ([0 1 1], [0 0 1],"black");
-%!   hold off
+%!   hold off;
 %!   p2 = fill ([0 1 0], [0 1 1], "red");
 %!   assert (length (get (hf, "children")), 1);
 %!   assert (length (get (gca, "children")), 1);
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/isosurface.m b/scripts/plot/isosurface.m
--- a/scripts/plot/isosurface.m
+++ b/scripts/plot/isosurface.m
@@ -185,19 +185,25 @@ function varargout = isosurface(varargin
       varargout = {fvc.faces, fvc.vertices, fvc.facevertexcdata};
     otherwise
       print_usage ();
   endswitch
 
 endfunction
 
 
+%!demo
+%! clf;
+%! [x,y,z] = meshgrid (-2:0.5:2, -2:0.5:2, -2:0.5:2);
+%! v = x.^2 + y.^2 + z.^2;
+%! isosurface (x, y, z, v, 1);
+
 %!shared x, y, z, val
 %!  [x, y, z]  = meshgrid (0:1, 0:1, 0:1); ## Points for single
-%!  val        = [0, 0; 0, 0];             ## cube and a 3--dim
+%!  val        = [0, 0; 0, 0];             ## cube and a 3-D
 %!  val(:,:,2) = [0, 0; 1, 0];             ## array of values
 %!test
 %!  fv = isosurface (x, y, z, val, 0.3);
 %!  assert (isfield (fv, "vertices"), true);
 %!  assert (isfield (fv, "faces"), true);
 %!  assert (size (fv.vertices), [3 3]);
 %!  assert (size (fv.faces), [1 3]);
 %!test
@@ -213,13 +219,8 @@ endfunction
 %!  assert (size (f), [1 3]);
 %!  assert (size (v), [3 3]);
 %!test
 %!  [f, v, c] = isosurface (x, y, z, val, .3, y);
 %!  assert (size (f), [1 3]);
 %!  assert (size (v), [3 3]);
 %!  assert (size (c), [3 1]);
 
-%!demo
-%! clf
-%! [x,y,z] = meshgrid(-2:0.5:2, -2:0.5:2, -2:0.5:2);
-%! v = x.^2 + y.^2 + z.^2;
-%! isosurface (x, y, z, v, 1)
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -967,209 +967,207 @@ function updateline (h, d, hlegend, line
             "marker", marker, "markeredgecolor", get (h, "markeredgecolor"),
             "markerfacecolor", get (h, "markerfacecolor"),
             "markersize", get (h, "markersize"), "linestyle", "none",
             "userdata", h, "parent", hlegend);
     endif
   endif
 endfunction
 
-%!demo
-%! clf
-%! x = 0:1;
-%! plot (x, x, ";I am Blue;", x, 2*x, ";I am Green;", x, 3*x, ";I am Red;")
 
 %!demo
-%! clf
+%! clf;
+%! x = 0:1;
+%! plot (x,x,";I am Blue;", x,2*x,";I am Green;", x,3*x,";I am Red;");
+
+%!demo
+%! clf;
 %! x = 0:1;
 %! plot (x, x, ";\alpha;",
 %!       x, 2*x, ";\beta=2\alpha;",
-%!       x, 3*x, ";\gamma=3\alpha;")
+%!       x, 3*x, ";\gamma=3\alpha;");
 
 %!demo
-%! clf
+%! clf;
 %! x = 0:1;
-%! plot (x, x, ";I am Blue;", x, 2*x, x, 3*x, ";I am Red;")
-%! title ("Blue and Green keys, with Green mising")
+%! plot (x,x,";I am Blue;", x,2*x, x,3*x,";I am Red;");
+%! title ("Blue and Green keys, with Green missing");
 
 %!demo
-%! clf
-%! plot(1:10, 1:10, 1:10, fliplr(1:10));
-%! title("incline is blue and decline is green");
-%! legend({"I am blue", "I am green"}, "location", "east");
-%! legend({"I am blue", "I am green"}, "location", "east");
-%! legend hide
-%! legend show
+%! clf;
+%! plot (1:10, 1:10, 1:10, fliplr (1:10));
+%! title ("incline is blue and decline is green");
+%! legend ({"I am blue", "I am green"}, "location", "east");
 
 %!demo
-%! clf
-%! plot(1:10, 1:10, 1:10, fliplr(1:10));
-%! title("Legend is hidden")
-%! legend({"I am blue", "I am green"}, "location", "east");
-%! legend hide
+%! clf;
+%! plot (1:10, 1:10, 1:10, fliplr (1:10));
+%! title ("Legend is hidden")
+%! legend ({"I am blue", "I am green"}, "location", "east");
+%! legend hide;
 
 %!demo
-%! clf
-%! plot(1:10, 1:10, 1:10, fliplr(1:10));
-%! title("Legend with box on")
-%! legend({"I am blue", "I am green"}, "location", "east");
-%! legend boxon
+%! clf;
+%! plot (1:10, 1:10, 1:10, fliplr (1:10));
+%! title ("Legend with box on");
+%! legend ({"I am blue", "I am green"}, "location", "east");
+%! legend boxon;
 
 %!demo
-%! clf
-%! plot(1:10, 1:10, 1:10, fliplr(1:10));
-%! title("Legend with text to the right")
-%! legend({"I am blue", "I am green"}, "location", "east");
-%! legend right
+%! clf;
+%! plot (1:10, 1:10, 1:10, fliplr (1:10));
+%! title ("Legend with text to the right");
+%! legend ({"I am blue", "I am green"}, "location", "east");
+%! legend right;
 
 %!demo
-%! clf
-%! plot(1:10, 1:10);
-%! title("a very long label can sometimes cause problems");
-%! legend({"hello world"}, "location", "northeastoutside");
+%! clf;
+%! plot (1:10, 1:10);
+%! title ("a very long label can sometimes cause problems");
+%! legend ({"hello world"}, "location", "northeastoutside");
 
 %!demo
-%! clf
-%! plot(1:10, 1:10);
-%! title("a very long label can sometimes cause problems");
-%! legend("hello world", "location", "northeastoutside");
+%! clf;
+%! plot (1:10, 1:10);
+%! title ("a very long label can sometimes cause problems");
+%! legend ("hello world", "location", "northeastoutside");
 
 %!demo
-%! clf
+%! clf;
 %! labels = {};
 %! colororder = get (gca, "colororder");
 %! for i = 1:5
-%!   h = plot(1:100, i + rand(100,1)); hold on;
-%!   set (h, "color", colororder(i,:))
-%!   labels = {labels{:}, cstrcat("Signal ", num2str(i))};
+%!   h = plot (1:100, i + rand(100,1)); hold on;
+%!   set (h, "color", colororder(i,:));
+%!   labels = {labels{:}, cstrcat("Signal ", num2str (i))};
 %! endfor
 %! hold off;
-%! title("Signals with random offset and uniform noise")
-%! xlabel("Sample Nr [k]"); ylabel("Amplitude [V]");
-%! legend(labels, "location", "southoutside");
-%! legend("boxon");
+%! title ("Signals with random offset and uniform noise");
+%! xlabel ("Sample Nr [k]"); ylabel ("Amplitude [V]");
+%! legend (labels, "location", "southoutside");
+%! legend ("boxon");
 
 %!demo
-%! clf
+%! clf;
 %! labels = {};
 %! colororder = get (gca, "colororder");
 %! for i = 1:5
-%!   h = plot(1:100, i + rand(100,1)); hold on;
-%!   set (h, "color", colororder(i,:))
-%!   labels = {labels{:}, cstrcat("Signal ", num2str(i))};
+%!   h = plot (1:100, i + rand (100,1)); hold on;
+%!   set (h, "color", colororder(i,:));
+%!   labels = {labels{:}, cstrcat("Signal ", num2str (i))};
 %! endfor
 %! hold off;
-%! title("Signals with random offset and uniform noise")
-%! xlabel("Sample Nr [k]"); ylabel("Amplitude [V]");
-%! legend(labels{:}, "location", "southoutside")
-%! legend("boxon")
+%! title ("Signals with random offset and uniform noise");
+%! xlabel ("Sample Nr [k]"); ylabel ("Amplitude [V]");
+%! legend (labels{:}, "location", "southoutside");
+%! legend ("boxon");
 
 %!demo
-%! clf
+%! clf;
 %! x = linspace (0, 10);
 %! plot (x, x);
-%! hold ("on");
-%! stem (x, x.^2, 'g')
+%! hold on;
+%! stem (x, x.^2, 'g');
 %! legend ("linear");
-%! hold ("off");
+%! hold off;
 
 %!demo
-%! clf
+%! clf;
 %! x = linspace (0, 10);
 %! plot (x, x, x, x.^2);
 %! legend ("linear");
 
 %!demo
-%! clf
+%! clf;
 %! x = linspace (0, 10);
 %! plot (x, x, x, x.^2);
 %! legend ("linear", "quadratic");
 
 %!demo
-%! clf
+%! clf;
 %! rand_2x3_data1 = [0.341447, 0.171220, 0.284370; 0.039773, 0.731725, 0.779382];
 %! bar (rand_2x3_data1);
 %! ylim ([0 1.0]);
 %! legend ({"1st Bar", "2nd Bar", "3rd Bar"});
 
 %!demo
-%! clf
+%! clf;
 %! rand_2x3_data2 = [0.44804, 0.84368, 0.23012; 0.72311, 0.58335, 0.90531];
 %! bar (rand_2x3_data2);
 %! ylim ([0 1.2]);
 %! legend ("1st Bar", "2nd Bar", "3rd Bar");
-%! legend right
+%! legend right;
 
 %!demo
-%! clf
+%! clf;
 %! x = 0:0.1:7;
-%! h = plot (x, sin(x), x, cos(x), x, sin(x.^2/10), x, cos(x.^2/10));
+%! h = plot (x,sin(x), x,cos(x), x,sin(x.^2/10), x,cos(x.^2/10));
 %! title ("Only the sin() objects have keylabels");
 %! legend (h([1, 3]), {"sin(x)", "sin(x^2/10)"}, "location", "southwest");
 
 %!demo
-%! clf
+%! clf;
 %! x = 0:0.1:10;
-%! plot (x, sin(x), ";sin(x);")
-%! hold all
-%! plot (x, cos(x), ";cos(x);")
-%! hold off
+%! plot (x, sin(x), ";sin(x);");
+%! hold all;
+%! plot (x, cos(x), ";cos(x);");
+%! hold off;
 
 %!demo
-%! clf
+%! clf;
 %! x = 0:0.1:10;
-%! plot (x, sin(x), ";sin(x);")
-%! hold all
-%! plot (x, cos(x), ";cos(x);")
-%! hold off
-%! legend ({"sin(x)", "cos(x)"}, "location", "northeastoutside")
+%! plot (x, sin(x), ";sin(x);");
+%! hold all;
+%! plot (x, cos(x), ";cos(x);");
+%! hold off;
+%! legend ({"sin(x)", "cos(x)"}, "location", "northeastoutside");
 
 %!demo
-%! clf
+%! clf;
 %! x = 0:10;
 %! plot (x, rand (11));
-%! xlabel ("Indices")
-%! ylabel ("Random Values")
-%! title ("Legend ""off"" should delete the legend")
-%! legend (cellstr (num2str ((1:10)')), "location", "northeastoutside")
-%! legend off
-%! axis ([0, 10, 0 1])
+%! xlabel ("Indices");
+%! ylabel ("Random Values");
+%! title ('Legend "off" should delete the legend');
+%! legend (cellstr (num2str ((1:10)')), "location", "northeastoutside");
+%! legend off;
+%! axis ([0, 10, 0 1]);
 
 %!demo
-%! clf
-%! x = 1:5;
-%! subplot (2, 2, 1)
-%! plot (x, rand (numel (x)));
-%! legend (cellstr (num2str (x')), "location", "northwestoutside")
-%! legend boxon
-%! subplot (2, 2, 2)
-%! plot (x, rand (numel (x)));
-%! legend (cellstr (num2str (x')), "location", "northeastoutside")
-%! legend boxon
+%! clf;
+%! x = (1:5)';
+%! subplot (2, 2, 1);
+%!  plot (x, rand (numel (x)));
+%!  legend (cellstr (num2str (x)), "location", "northwestoutside");
+%!  legend boxon;
+%! subplot (2, 2, 2);
+%!  plot (x, rand (numel (x)));
+%!  legend (cellstr (num2str (x)), "location", "northeastoutside");
+%!  legend boxon;
 %! subplot (2, 2, 3);
-%! plot (x, rand (numel (x)));
-%! legend (cellstr (num2str (x')), "location", "southwestoutside")
-%! legend boxon
-%! subplot (2, 2, 4)
-%! plot (x, rand (numel (x)));
-%! legend (cellstr (num2str (x')), "location", "southeastoutside")
-%! legend boxon
+%!  plot (x, rand (numel (x)));
+%!  legend (cellstr (num2str (x)), "location", "southwestoutside");
+%!  legend boxon;
+%! subplot (2, 2, 4);
+%!  plot (x, rand (numel (x)));
+%!  legend (cellstr (num2str (x)), "location", "southeastoutside");
+%!  legend boxon;
 
 %!demo
-%! clf
-%! plot (rand (2))
-%! title ("Warn of extra labels")
-%! legend ("Hello", "World", "interpreter", "foobar")
+%! clf;
+%! plot (rand (2));
+%! title ("Warn of extra labels");
+%! legend ("Hello", "World", "interpreter", "foobar");
 
 %!demo
-%! clf
-%! plot (rand (2))
-%! title ("Turn off TeX interpreter")
+%! clf;
+%! plot (rand (2));
+%! title ("Turn off TeX interpreter");
 %! h = legend ("Hello_World", "foo^bar");
-%! set (h, "interpreter", "none")
+%! set (h, "interpreter", "none");
 
 %!demo
 %! x = 0:10;
 %! y1 = rand (size (x));
 %! y2 = rand (size (x));
 %! [ax, h1, h2] = plotyy (x, y1, x, y2);
 %! legend ([h1, h2], {"Blue", "Green"}, "location", "south");
 
@@ -1182,25 +1180,8 @@ endfunction
 
 %!demo
 %! x = 0:10;
 %! y1 = rand (size (x));
 %! y2 = rand (size (x));
 %! [ax, h1, h2] = plotyy (x, y1, x, y2);
 %! legend ("Blue", "Green", "location", "south");
 
-%!test
-%! x = 0:10;
-%! y = rand (size (x));
-%! displayname = '\alpha_\beta \delta^\theta';
-%! displayname1 = "";
-%! displayname2 = "";
-%! figure (1, "visible", false)
-%! unwind_protect
-%!   h = plot (x, y, sprintf (";%s;", displayname));
-%!   displayname1 = get (h, "displayname")
-%!   hlegend = legend (h, displayname, "location", "south");
-%!   displayname2 = get (h, "displayname")
-%! unwind_protect_cleanup
-%!   close (gcf;
-%! end_unwind_protect
-%! assert (displayname1, displayname)
-%! assert (displayname2, displayname)
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -57,53 +57,54 @@ function retval = loglog (varargin)
       retval = tmp;
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
+
 %!demo
-%! clf ();
+%! clf;
 %! t = 1:0.01:10;
 %! x = sort ((t .* (1 + rand (size (t)))) .^ 2);
 %! y = ((t .* (1 + rand (size (t)))) .^ 2);
 %! loglog (x, y);
 
 %!demo
-%! clf ();
+%! clf;
 %! a = logspace (-5, 1, 10);
 %! b =-logspace (-5, 1, 10);
 %!
-%! subplot (1, 2, 1)
-%! loglog (a, b)
-%! xlabel ('loglog (a, b)')
+%! subplot (1,2,1);
+%!  loglog (a, b);
+%!  xlabel ("loglog (a, b)");
 %!
-%! subplot (1, 2, 2)
-%! loglog (a, abs (b))
-%! set (gca, 'ydir', 'reverse')
-%! xlabel ('loglog (a, abs (b))')
+%! subplot (1,2,2);
+%!  loglog (a, abs (b));
+%!  set (gca, "ydir", "reverse");
+%!  xlabel ("loglog (a, abs (b))");
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b = logspace (-5, 1, 10);
-%!   loglog (a, b)
+%!   loglog (a, b);
 %!   assert (get (gca, "yscale"), "log");
 %!   assert (get (gca, "xscale"), "log");
 %! unwind_protect_cleanup
-%! close (hf);
+%!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b =-logspace (-5, 1, 10);
-%!   loglog (a, b)
-%!   axis tight
+%!   loglog (a, b);
+%!   axis tight;
 %!   assert (all (get (gca, "ytick") < 0));
 %! unwind_protect_cleanup
-%! close (hf);
+%!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/loglogerr.m b/scripts/plot/loglogerr.m
--- a/scripts/plot/loglogerr.m
+++ b/scripts/plot/loglogerr.m
@@ -55,17 +55,18 @@ function retval = loglogerr (varargin)
       retval = tmp;
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! x = exp (log(0.01):0.2:log(10));
 %! y = wblpdf (x, 3, 2);
 %! eyu = 2*rand (size (y)) .* y;
 %! eyl = 0.5*rand (size (y)) .* y;
-%! loglogerr (x, y, eyl, eyu, "#~x-")
-%! xlim (x([1, end]))
+%! loglogerr (x, y, eyl, eyu, "#~x-");
+%! xlim (x([1, end]));
 
diff --git a/scripts/plot/pareto.m b/scripts/plot/pareto.m
--- a/scripts/plot/pareto.m
+++ b/scripts/plot/pareto.m
@@ -100,23 +100,23 @@ function h = pareto (varargin)
   if (nargout > 0)
     h = [hbar; hline];
   endif
 
 endfunction
 
 
 %!demo
-%! clf
+%! clf;
 %! colormap (jet (64));
 %! Cheese = {"Cheddar", "Swiss", "Camembert", "Munster", "Stilton", "Blue"};
 %! Sold = [105, 30, 70, 10, 15, 20];
 %! pareto (Sold, Cheese);
 
 %!demo
-%! clf
-%! % Suppose that we want establish which products makes 80 % of turnover.
+%! clf;
+%! % Suppose that we want establish which products makes 80% of turnover.
 %! Codes = {"AB4","BD7","CF8","CC5","AD11","BB5","BB3","AD8","DF3","DE7"};
 %! Value = [2.35 7.9 2.45 1.1 0.15 13.45 5.4 2.05 0.85  1.65]';
 %! SoldUnits = [54723 41114 16939 1576091 168000 687197 120222 168195, ...
 %!              1084118 55576]';
 %! pareto (Value.*SoldUnits, Codes);
 
diff --git a/scripts/plot/patch.m b/scripts/plot/patch.m
--- a/scripts/plot/patch.m
+++ b/scripts/plot/patch.m
@@ -54,161 +54,162 @@ function retval = patch (varargin)
   endif
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
+
 %!demo
 %! ## Patches with same number of vertices
-%! clf
-%! t1 = (1/16:1/8:1)'*2*pi;
-%! t2 = ((1/16:1/8:1)' + 1/32)*2*pi;
+%! clf;
+%! t1 = (1/16:1/8:1)' * 2*pi;
+%! t2 = ((1/16:1/8:1)' + 1/32) * 2*pi;
 %! x1 = sin (t1) - 0.8;
 %! y1 = cos (t1);
 %! x2 = sin (t2) + 0.8;
 %! y2 = cos (t2);
-%! patch([x1,x2],[y1,y2],'r');
+%! patch ([x1,x2], [y1,y2], 'r');
 
 %!demo
 %! ## Unclosed patch
-%! clf
-%! t1 = (1/16:1/8:1)'*2*pi;
-%! t2 = ((1/16:1/16:1)' + 1/32)*2*pi;
+%! clf;
+%! t1 = (1/16:1/8:1)' * 2*pi;
+%! t2 = ((1/16:1/16:1)' + 1/32) * 2*pi;
 %! x1 = sin (t1) - 0.8;
 %! y1 = cos (t1);
 %! x2 = sin (t2) + 0.8;
 %! y2 = cos (t2);
-%! patch([[x1;NaN(8,1)],x2],[[y1;NaN(8,1)],y2],'r');
+%! patch ([[x1;NaN(8,1)],x2], [[y1;NaN(8,1)],y2], 'r');
 
 %!demo
 %! ## Specify vertices and faces separately
-%! clf
-%! t1 = (1/16:1/8:1)'*2*pi;
-%! t2 = ((1/16:1/16:1)' + 1/32)*2*pi;
+%! clf;
+%! t1 = (1/16:1/8:1)' * 2*pi;
+%! t2 = ((1/16:1/16:1)' + 1/32) * 2*pi;
 %! x1 = sin (t1) - 0.8;
 %! y1 = cos (t1);
 %! x2 = sin (t2) + 0.8;
 %! y2 = cos (t2);
 %! vert = [x1, y1; x2, y2];
 %! fac = [1:8,NaN(1,8);9:24];
-%! patch('Faces',fac,'Vertices',vert,'FaceColor','r');
+%! patch ("Faces",fac, "Vertices",vert, "FaceColor","r");
 
 %!demo
 %! ## Specify vertices and faces separately
-%! clf
-%! t1 = (1/16:1/8:1)'*2*pi;
-%! t2 = ((1/16:1/16:1)' + 1/32)*2*pi;
+%! clf;
+%! t1 = (1/16:1/8:1)' * 2*pi;
+%! t2 = ((1/16:1/16:1)' + 1/32) * 2*pi;
 %! x1 = sin (t1) - 0.8;
 %! y1 = cos (t1);
 %! x2 = sin (t2) + 0.8;
 %! y2 = cos (t2);
 %! vert = [x1, y1; x2, y2];
 %! fac = [1:8,NaN(1,8);9:24];
-%! patch('Faces',fac,'Vertices',vert,'FaceVertexCData', [0, 1, 0; 0, 0, 1]);
+%! patch ("Faces",fac, "Vertices",vert, "FaceVertexCData", [0, 1, 0; 0, 0, 1]);
 
 %!demo
 %! ## Property change on multiple patches
-%! clf
-%! t1 = (1/16:1/8:1)'*2*pi;
-%! t2 = ((1/16:1/8:1)' + 1/32)*2*pi;
+%! clf;
+%! t1 = (1/16:1/8:1)' * 2*pi;
+%! t2 = ((1/16:1/8:1)' + 1/32) * 2*pi;
 %! x1 = sin (t1) - 0.8;
 %! y1 = cos (t1);
 %! x2 = sin (t2) + 0.8;
 %! y2 = cos (t2);
-%! h = patch([x1,x2],[y1,y2],cat (3,[0,0],[1,0],[0,1]));
+%! h = patch ([x1,x2], [y1,y2], cat (3,[0,0],[1,0],[0,1]));
 %! pause (1);
-%! set (h, 'FaceColor', 'r');
+%! set (h, "FaceColor", 'r');
 
 %!demo
-%! clf
+%! clf;
 %! vertices = [0, 0, 0;
 %!             1, 0, 0;
 %!             1, 1, 0;
 %!             0, 1, 0;
 %!             0.5, 0.5, 1];
 %! faces = [1, 2, 5;
 %!          2, 3, 5;
 %!          3, 4, 5;
 %!          4, 1, 5];
-%! patch ('Vertices', vertices, 'Faces', faces, ...
-%!        'FaceVertexCData', jet(4), 'FaceColor', 'flat');
+%! patch ("Vertices", vertices, "Faces", faces, ...
+%!        "FaceVertexCData", jet (4), "FaceColor", "flat");
 %! view (-37.5, 30);
 
 %!demo
-%! clf
+%! clf;
 %! vertices = [0, 0, 0;
 %!             1, 0, 0;
 %!             1, 1, 0;
 %!             0, 1, 0;
 %!             0.5, 0.5, 1];
 %! faces = [1, 2, 5;
 %!          2, 3, 5;
 %!          3, 4, 5;
 %!          4, 1, 5];
-%! patch ('Vertices', vertices, 'Faces', faces, ...
-%!        'FaceVertexCData', jet(5), 'FaceColor', 'interp');
+%! patch  ("Vertices", vertices, "Faces", faces, ...
+%!        "FaceVertexCData", jet (5), "FaceColor", "interp");
 %! view (-37.5, 30);
 
 %!demo
-%! clf
-%! colormap (jet);
+%! clf;
+%! colormap (jet (64));
 %! x = [0 1 1 0];
 %! y = [0 0 1 1];
 %! subplot (2, 1, 1);
-%! title ("Blue, Light-Green, and Red Horizontal Bars");
-%! patch (x, y + 0, 1);
-%! patch (x, y + 1, 2);
-%! patch (x, y + 2, 3);
+%!  title ("Blue, Light-Green, and Red Horizontal Bars");
+%!  patch (x, y + 0, 1);
+%!  patch (x, y + 1, 2);
+%!  patch (x, y + 2, 3);
 %! subplot (2, 1, 2);
-%! title ("Blue, Light-Green, and Red Vertical Bars");
-%! patch (x + 0, y, 1 * ones (size (x)));
-%! patch (x + 1, y, 2 * ones (size (x)));
-%! patch (x + 2, y, 3 * ones (size (x)));
+%!  title ("Blue, Light-Green, and Red Vertical Bars");
+%!  patch (x + 0, y, 1 * ones (size (x)));
+%!  patch (x + 1, y, 2 * ones (size (x)));
+%!  patch (x + 2, y, 3 * ones (size (x)));
 
 %!demo
-%! clf
-%! colormap (jet);
+%! clf;
+%! colormap (jet (64));
 %! x = [0 1 1 0];
 %! y = [0 0 1 1];
 %! subplot (2, 1, 1);
-%! title ("Blue horizontal bars: Dark to Light");
-%! patch (x, y + 0, 1, "cdatamapping", "direct");
-%! patch (x, y + 1, 9, "cdatamapping", "direct");
-%! patch (x, y + 2, 17, "cdatamapping", "direct");
+%!  title ("Blue horizontal bars: Dark to Light");
+%!  patch (x, y + 0, 1, "cdatamapping", "direct");
+%!  patch (x, y + 1, 9, "cdatamapping", "direct");
+%!  patch (x, y + 2, 17, "cdatamapping", "direct");
 %! subplot (2, 1, 2);
-%! title ("Blue vertical bars: Dark to Light")
-%! patch (x + 0, y, 1 * ones (size (x)), "cdatamapping", "direct");
-%! patch (x + 1, y, 9 * ones (size (x)), "cdatamapping", "direct");
-%! patch (x + 2, y, 17 * ones (size (x)), "cdatamapping", "direct");
+%!  title ("Blue vertical bars: Dark to Light");
+%!  patch (x + 0, y, 1 * ones (size (x)), "cdatamapping", "direct");
+%!  patch (x + 1, y, 9 * ones (size (x)), "cdatamapping", "direct");
+%!  patch (x + 2, y, 17 * ones (size (x)), "cdatamapping", "direct");
 
 %!demo
 %! clf;
-%! colormap (jet);
+%! colormap (jet (64));
 %! x = [ 0 0; 1 1; 1 0 ];
 %! y = [ 0 0; 0 1; 1 1 ];
 %! p = patch (x, y, "facecolor", "b");
 %! title ("Two blue triangles");
 %! set (p, "cdatamapping", "direct", "facecolor", "flat", "cdata", [1 32]);
 %! title ("Direct mapping of colors: Light-Green UL and Blue LR triangles");
 
 %!demo
 %! clf;
-%! colormap (jet);
+%! colormap (jet (64));
 %! x = [ 0 0; 1 1; 1 0 ];
 %! y = [ 0 0; 0 1; 1 1 ];
 %! p = patch (x, y, [1 32]);
 %! title ("Autoscaling of colors: Red UL and Blue LR triangles");
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
-%!   h = patch;
+%!   h = patch ();
 %!   assert (findobj (hf, "type", "patch"), h);
 %!   assert (get (h, "xdata"), [0; 1; 0], eps);
 %!   assert (get (h, "ydata"), [1; 1; 0], eps);
 %!   assert (isempty (get (h, "zdata")));
 %!   assert (isempty (get (h, "cdata")));
 %!   assert (get (h, "faces"), [1, 2, 3], eps);
 %!   assert (get (h, "vertices"), [0 1; 1 1; 0 0], eps);
 %!   assert (get (h, "type"), "patch");
diff --git a/scripts/plot/pbaspect.m b/scripts/plot/pbaspect.m
--- a/scripts/plot/pbaspect.m
+++ b/scripts/plot/pbaspect.m
@@ -84,30 +84,31 @@ function varargout = pbaspect (varargin)
   if (nargout == 1)
     varargout{1} = get (hax, "plotboxaspectratio");
   elseif (nargout > 1)
     error ("pbaspect: only one output is allowed");
   endif
 
 endfunction
 
+
 %!demo
+%! clf;
 %! x = 0:0.01:4;
-%! clf
-%! plot (x, cos (x), x, sin (x))
-%! pbaspect ([1 1 1])
-%! title ("plot box should be square")
+%! plot (x,cos(x), x,sin(x));
+%! pbaspect ([1 1 1]);
+%! title ("plot box is square");
 
 %!demo
-%! x = 0:0.01:4;
-%! clf
-%! plot (x, cos (x), x, sin (x))
-%! pbaspect ([2 1 1])
-%! title ("plot box aspect ratio should be 2x1")
+%! clf;
+%! x = 0:0.01:4;;
+%! plot (x,cos(x), x,sin(x));
+%! pbaspect ([2 1 1]);
+%! title ("plot box aspect ratio is 2x1");
 
 %!demo
+%! clf;
 %! x = 0:0.01:4;
-%! clf
-%! plot (x, cos (x), x, sin (x))
-%! daspect ([1 1 1])
-%! pbaspect ([2 1 1])
-%! title ("plot box should be 2x1, and axes [0 4 -1 1]")
+%! plot (x,cos(x), x,sin(x));
+%! daspect ([1 1 1]);
+%! pbaspect ([2 1 1]);
+%! title ("plot box is 2x1, and axes [0 4 -1 1]");
 
diff --git a/scripts/plot/pcolor.m b/scripts/plot/pcolor.m
--- a/scripts/plot/pcolor.m
+++ b/scripts/plot/pcolor.m
@@ -76,19 +76,21 @@ function h = pcolor (x, y, c)
   endif
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
+
 %!demo
-%! clf
-%! [~,~,Z]=peaks;
-%! pcolor(Z);
+%! clf;
+%! [~,~,Z] = peaks ();
+%! pcolor (Z);
 
 %!demo
-%! clf
-%! [X,Y,Z]=sombrero;
-%! [Fx,Fy] = gradient(Z);
-%! pcolor(X,Y,Fx+Fy);
+%! clf;
+%! [X,Y,Z] = sombrero ();
+%! [Fx,Fy] = gradient (Z);
+%! pcolor (X,Y,Fx+Fy);
 %! shading interp;
+
diff --git a/scripts/plot/pie.m b/scripts/plot/pie.m
--- a/scripts/plot/pie.m
+++ b/scripts/plot/pie.m
@@ -63,25 +63,25 @@ function retval = pie (varargin)
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 
 %!demo
-%! clf
+%! clf;
 %! pie ([3, 2, 1], [0, 0, 1]);
 %! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 
 %!demo
-%! clf
+%! clf;
 %! pie ([3, 2, 1], [0, 0, 1], {"Cheddar", "Swiss", "Camembert"});
 %! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
 
 %!demo
-%! clf
+%! clf;
 %! pie ([0.17, 0.34, 0.41], {"Cheddar", "Swiss", "Camembert"});
 %! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
 %! title ("missing slice");
 
diff --git a/scripts/plot/pie3.m b/scripts/plot/pie3.m
--- a/scripts/plot/pie3.m
+++ b/scripts/plot/pie3.m
@@ -64,25 +64,25 @@ function retval = pie3 (varargin)
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 
 %!demo
-%! clf
+%! clf;
 %! pie3 ([5:-1:1], [0, 0, 1, 0, 0]);
 %! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 
 %!demo
-%! clf
+%! clf;
 %! pie3 ([3, 2, 1], [0, 0, 1], {"Cheddar", "Swiss", "Camembert"});
 %! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
 
 %!demo
-%! clf
+%! clf;
 %! pie3 ([0.17, 0.34, 0.41], {"Cheddar", "Swiss", "Camembert"});
 %! colormap ([1,0,0;0,1,0;0,0,1;1,1,0;1,0,1;0,1,1]);
 %! axis ([-2,2,-2,2]);
 %! title ("missing slice");
 
diff --git a/scripts/plot/plot3.m b/scripts/plot/plot3.m
--- a/scripts/plot/plot3.m
+++ b/scripts/plot/plot3.m
@@ -333,13 +333,15 @@ function retval = plot3 (varargin)
   set (gca (), "view", [-37.5, 30]);
 
   if (nargout > 0 && idx > 0)
     retval = tmp;
   endif
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! z = [0:0.05:5];
 %! plot3 (cos(2*pi*z), sin(2*pi*z), z, ";helix;");
 %! plot3 (z, exp(2i*pi*z), ";complex sinusoid;");
+
diff --git a/scripts/plot/plotmatrix.m b/scripts/plot/plotmatrix.m
--- a/scripts/plot/plotmatrix.m
+++ b/scripts/plot/plotmatrix.m
@@ -91,18 +91,18 @@ function [h, ax, bigax, p, pax] = plotma
       set (bigax2, "visible", "off");
     unwind_protect_cleanup
       axes (oldh);
     end_unwind_protect
   endif
 endfunction
 
 %!demo
-%! clf
-%! plotmatrix (randn (100, 3), 'g+')
+%! clf;
+%! plotmatrix (randn (100, 3), "g+");
 
 function plotmatrixdelete (h, d, ax)
   for i = 1 : numel (ax)
     hc = ax(i);
     if (ishandle (hc) && strcmp (get (hc, "type"), "axes")
         && strcmpi (get (hc, "beingdeleted"), "off"))
       parent = get (hc, "parent");
       ## If the parent is invalid or being deleted, then do nothing
diff --git a/scripts/plot/plotyy.m b/scripts/plot/plotyy.m
--- a/scripts/plot/plotyy.m
+++ b/scripts/plot/plotyy.m
@@ -221,53 +221,53 @@ function [ax, h1, h2] = __plotyy__ (ax, 
     addproperty ("__plotyy_axes__", ax(2), "data", ax);
   elseif (ishandle (ax(2)))
     set (ax(2), "__plotyy_axes__", ax);
   else
     error ("plotyy.m: This shouldn't happen. File a bug report.")
   endif
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! x = 0:0.1:2*pi;
 %! y1 = sin (x);
 %! y2 = exp (x - 1);
-%! ax = plotyy (x, y1, x - 1, y2, @plot, @semilogy);
+%! ax = plotyy (x,y1, x-1,y2, @plot, @semilogy);
 %! xlabel ("X");
 %! ylabel (ax(1), "Axis 1");
 %! ylabel (ax(2), "Axis 2");
-%! axes (ax(1))
+%! axes (ax(1));
 %! text (0.5, 0.5, "Left Axis", ...
-%!       "color", [0 0 1], "horizontalalignment", "center")
-%! axes (ax(2))
+%!       "color", [0 0 1], "horizontalalignment", "center");
+%! axes (ax(2));
 %! text (4.5, 80, "Right Axis", ...
-%!       "color", [0 0.5 0], "horizontalalignment", "center")
+%!       "color", [0 0.5 0], "horizontalalignment", "center");
 
 %!demo
-%! clf
+%! clf;
 %! x = linspace (-1, 1, 201);
-%! subplot (2, 2, 1)
-%! plotyy (x, sin(pi*x), x, 10*cos(pi*x))
-%! subplot (2, 2, 2)
-%! surf (peaks (25))
-%! subplot (2, 2, 3)
-%! contour (peaks (25))
-%! subplot (2, 2, 4)
-%! plotyy (x, 10*sin(2*pi*x), x, cos(2*pi*x))
-%! axis square
+%! subplot (2,2,1);
+%!  plotyy (x,sin(pi*x), x,10*cos(pi*x));
+%! subplot (2,2,2);
+%!  surf (peaks (25));
+%! subplot (2,2,3);
+%!  contour (peaks (25));
+%! subplot (2,2,4);
+%!  plotyy (x,10*sin(2*pi*x), x,cos(2*pi*x));
+%! axis square;
 
 %!demo
-%! clf
+%! clf;
 %! x = linspace (-1, 1, 201);
-%! subplot (1, 1, 1);
 %! hax = plotyy (x, sin(pi*x), x, cos(pi*x));
-%! ylabel ("Blue and on the Left")
-%! ylabel (hax(2), "Green and on the Right")
-%! xlabel ("xlabel")
+%! ylabel ("Blue on the Left");
+%! ylabel (hax(2), "Green on the Right");
+%! xlabel ("xlabel");
 
 function deleteplotyy (h, d, ax2, t2)
   if (ishandle (ax2) && strcmp (get (ax2, "type"), "axes")
       && (isempty (gcbf()) || strcmp (get (gcbf(), "beingdeleted"),"off"))
       && strcmp (get (ax2, "beingdeleted"), "off"))
     set (t2, "deletefcn", []);
     delete (ax2);
   endif
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -212,19 +212,19 @@ function retval = __plr2__ (h, theta, rh
   else
     error ("__plr2__: invalid data for plotting");
   endif
 
 endfunction
 
 
 %!demo
-%! clf
-%! theta = linspace (0, 2*pi, 1000);
+%! clf;
+%! theta = linspace (0,2*pi,1000);
 %! rho = sin (7*theta);
 %! polar (theta, rho);
 
 %!demo
-%! clf
-%! theta = linspace (0, 10*pi, 1000);
+%! clf;
+%! theta = linspace (0,10*pi,1000);
 %! rho = sin (5/4*theta);
 %! polar (theta, rho);
 
diff --git a/scripts/plot/quiver.m b/scripts/plot/quiver.m
--- a/scripts/plot/quiver.m
+++ b/scripts/plot/quiver.m
@@ -78,22 +78,22 @@ function retval = quiver (varargin)
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 
 %!demo
-%! clf
+%! clf;
 %! [x,y] = meshgrid (1:2:20);
 %! h = quiver (x,y, sin (2*pi*x/10), sin (2*pi*y/10));
 %! set (h, "maxheadsize", 0.33);
 
 %!demo
-%! clf
+%! clf;
 %! axis ("equal");
-%! x = linspace (0,3,80);
+%! x = linspace (0, 3, 80);
 %! y = sin (2*pi*x);
 %! theta = 2*pi*x + pi/2;
 %! quiver (x, y, sin (theta)/10, cos (theta)/10);
-%! hold on; plot(x,y,"r"); hold off;
+%! hold on; plot (x,y,"r"); hold off;
 
diff --git a/scripts/plot/quiver3.m b/scripts/plot/quiver3.m
--- a/scripts/plot/quiver3.m
+++ b/scripts/plot/quiver3.m
@@ -79,40 +79,41 @@ function retval = quiver3 (varargin)
   endif
 
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! colormap (jet (64));
 %! [x,y] = meshgrid (-1:0.1:1);
-%! z = sin (2*pi * sqrt (x.^2+y.^2));
-%! theta = 2*pi * sqrt (x.^2+y.^2) + pi/2;
+%! z = sin (2*pi * sqrt (x.^2 + y.^2));
+%! theta = 2*pi * sqrt (x.^2 + y.^2) + pi/2;
 %! quiver3 (x, y, z, sin (theta), cos (theta), ones (size (z)));
 %! hold on;
 %! mesh (x,y,z);
 %! hold off;
 
 %!demo
-%! clf
+%! clf;
 %! [x, y, z] = peaks (25);
 %! surf (x, y, z);
 %! hold on;
 %! [u, v, w] = surfnorm (x, y, z / 10);
 %! h = quiver3 (x, y, z, u, v, w);
 %! set (h, "maxheadsize", 0.33);
 %! hold off;
 
 %!demo
-%! clf
+%! clf;
 %! [x, y, z] = peaks (25);
 %! surf (x, y, z);
 %! hold on;
 %! [u, v, w] = surfnorm (x, y, z / 10);
 %! h = quiver3 (x, y, z, u, v, w);
 %! set (h, "maxheadsize", 0.33);
 %! hold off;
-%! shading interp
+%! shading interp;
 
diff --git a/scripts/plot/rectangle.m b/scripts/plot/rectangle.m
--- a/scripts/plot/rectangle.m
+++ b/scripts/plot/rectangle.m
@@ -200,23 +200,23 @@ function update_props (h, d)
   set (kids, "edgecolor", get (h, "edgecolor"),
        "linewidth", get (h, "linewidth"),
        "linestyle", get (h, "linestyle"),
        "facecolor", get (h, "facecolor"));
 endfunction
 
 
 %!demo
-%! clf
-%! axis equal
+%! clf;
+%! axis equal;
 %! rectangle ("Position", [0.05, 0.05, 0.9, 0.9], "Curvature", [0.5, 0.5]);
 
 %!demo
-%! clf
-%! axis equal
+%! clf;
+%! axis equal;
 %! rectangle ("Position", [0.05, 0.05, 0.9, 0.4], "Curvature", 1.0);
 
 %!demo
-%! clf
-%! axis equal
+%! clf;
+%! axis equal;
 %! h = rectangle ("Position", [0.05, 0.05, 0.9, 0.4], "Curvature",  1.0);
 %! set (h, "FaceColor", [0, 1, 0]);
 
diff --git a/scripts/plot/refreshdata.m b/scripts/plot/refreshdata.m
--- a/scripts/plot/refreshdata.m
+++ b/scripts/plot/refreshdata.m
@@ -37,19 +37,19 @@
 ## An example of the use of @code{refreshdata} is:
 ##
 ## @example
 ## @group
 ## x = 0:0.1:10;
 ## y = sin (x);
 ## plot (x, y, "ydatasource", "y");
 ## for i = 1 : 100
-##   pause(0.1)
+##   pause (0.1)
 ##   y = sin (x + 0.1 * i);
-##   refreshdata();
+##   refreshdata ();
 ## endfor
 ## @end group
 ## @end example
 ## @end deftypefn
 
 function refreshdata (h, workspace)
 
   if (nargin == 0)
@@ -98,20 +98,23 @@ function refreshdata (h, workspace)
         val = evalin (workspace, expr);
         prop =  props{i}{j}(1:end-6);
         if (! isequal (get (objs(i), prop), val))
           set (objs(i), props{i}{j}(1:end-6), val);
         endif
       endif
     endfor
   endfor
+
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! x = 0:0.1:10;
 %! y = sin (x);
 %! plot (x, y, "ydatasource", "y");
 %! for i = 1 : 100
-%!   pause(0.1)
+%!   pause (0.1);
 %!   y = sin (x + 0.1 * i);
-%!   refreshdata(gcf(), "caller");
+%!   refreshdata (gcf (), "caller");
 %! endfor
+
diff --git a/scripts/plot/ribbon.m b/scripts/plot/ribbon.m
--- a/scripts/plot/ribbon.m
+++ b/scripts/plot/ribbon.m
@@ -81,14 +81,14 @@ function h = ribbon (x, y, width = 0.75)
   if (nargout > 0)
     h = htmp;
   endif
 
 endfunction
 
 
 %!demo
-%! clf
+%! clf;
 %! [x, y, z] = sombrero ();
 %! [x, y] = meshgrid (x, y);
 %! ribbon (y, z);
 
 %!FIXME: Could have some input validation tests here
diff --git a/scripts/plot/rose.m b/scripts/plot/rose.m
--- a/scripts/plot/rose.m
+++ b/scripts/plot/rose.m
@@ -101,11 +101,11 @@ function [thout, rout] = rose (varargin)
     thout = th;
     rout = r;
   endif
 
 endfunction
 
 
 %!demo
-%! clf
+%! clf;
 %! rose ([2*randn(1e5, 1), pi + 2*randn(1e5, 1)]);
 
diff --git a/scripts/plot/scatter.m b/scripts/plot/scatter.m
--- a/scripts/plot/scatter.m
+++ b/scripts/plot/scatter.m
@@ -77,107 +77,112 @@ function retval = scatter (varargin)
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 
 %!demo
-%! clf
+%! clf;
 %! x = randn (100, 1);
 %! y = randn (100, 1);
 %! scatter (x, y, "r");
+%! title ("Scatter plot with red bubbles");
 
 %!demo
-%! clf
+%! clf;
 %! x = randn (100, 1);
 %! y = randn (100, 1);
 %! scatter (x, y, [], sqrt (x.^2 + y.^2));
+%! title ("Scatter plot with bubble color determined by distance from origin");
 
 %!demo
-%! clf
+%! clf;
 %! rand_10x1_data1 = [0.171577, 0.404796, 0.025469, 0.335309, 0.047814, 0.898480, 0.639599, 0.700247, 0.497798, 0.737940];
 %! rand_10x1_data2 = [0.75495, 0.83991, 0.80850, 0.73603, 0.19360, 0.72573, 0.69371, 0.74388, 0.13837, 0.54143];
 %! x = rand_10x1_data1;
 %! y = rand_10x1_data2;
 %! s = 10 - 10*log (x.^2 + y.^2);
 %! h = scatter (x, y, s, s, "s", "filled");
+%! title ({"Scatter plot with filled square markers", ...
+%!         "size and color of markers determined by algorithm"});
 
 %!demo
-%! clf
+%! clf;
 %! rand_10x1_data3 = [0.42262, 0.51623, 0.65992, 0.14999, 0.68385, 0.55929, 0.52251, 0.92204, 0.19762, 0.93726];
 %! rand_10x1_data4 = [0.020207, 0.527193, 0.443472, 0.061683, 0.370277, 0.947349, 0.249591, 0.666304, 0.134247, 0.920356];
 %! x = rand_10x1_data3;
 %! y = rand_10x1_data4;
 %! s = 10 - 10*log (x.^2 + y.^2);
 %! h = scatter (x, y, [], "r", "s", "filled");
 
 %!demo
-%! clf
+%! clf;
 %! rand_10x1_data5 = [0.777753, 0.093848, 0.183162, 0.399499, 0.337997, 0.686724, 0.073906, 0.651808, 0.869273, 0.137949];
 %! rand_10x1_data6 = [0.37460, 0.25027, 0.19510, 0.51182, 0.54704, 0.56087, 0.24853, 0.75443, 0.42712, 0.44273];
 %! x = rand_10x1_data5;
 %! y = rand_10x1_data6;
 %! s = 10 - 10*log (x.^2 + y.^2);
 %! h = scatter (x, y, [], "r", "s");
 
 %!demo
+%! clf;
 %! k = 1;
-%! clf
 %! for m = [1, 3]
 %!   for n = [101, 50, 1]
 %!     x = rand (n, 1);
 %!     y = rand (n, 1);
 %!     if (m > 1)
 %!       str = "Three Colors";
 %!       idx = ceil (rand (n, 1) * 3);
-%!       colors = eye(3);
+%!       colors = eye (3);
 %!       colors = colors(idx, :);
 %!     else
 %!       str = "Random Colors";
 %!       colors = rand (n, m);
 %!     endif
 %!     if (n == 1)
 %!       str = sprintf ("%s: 1 point", str);
 %!     elseif (n < 100)
 %!       str = sprintf ("%s: < 100 points", str);
 %!     else
 %!       str = sprintf ("%s: > 100 points", str);
 %!     endif
-%!     subplot (2, 3, k)
+%!     subplot (2,3,k);
 %!     k = k + 1;
-%!     scatter (x, y, 15, colors, "filled")
-%!     axis ([0 1 0 1])
-%!     title (str)
+%!     scatter (x, y, 15, colors, "filled");
+%!     axis ([0 1 0 1]);
+%!     title (str);
 %!   endfor
 %! endfor
 
 %!demo
+%! clf;
 %! k = 1;
-%! clf
 %! for m = [1, 3]
 %!   for n = [101, 50, 1]
 %!     x = rand (n, 1);
 %!     y = rand (n, 1);
 %!     if (m > 1)
 %!       str = "Three Colors";
 %!       idx = ceil (rand (n, 1) * 3);
-%!       colors = eye(3);
+%!       colors = eye (3);
 %!       colors = colors(idx, :);
 %!     else
 %!       str = "Random Colors";
 %!       colors = rand (n, m);
 %!     endif
 %!     if (n == 1)
 %!       str = sprintf ("%s: 1 point", str);
 %!     elseif (n < 100)
 %!       str = sprintf ("%s: < 100 points", str);
 %!     else
 %!       str = sprintf ("%s: > 100 points", str);
 %!     endif
-%!     subplot (2, 3, k)
+%!     subplot (2,3,k);
 %!     k = k + 1;
-%!     scatter (x, y, 15, colors)
-%!     axis ([0 1 0 1])
-%!     title (str)
+%!     scatter (x, y, 15, colors);
+%!     axis ([0 1 0 1]);
+%!     title (str);
 %!   endfor
 %! endfor
+
diff --git a/scripts/plot/scatter3.m b/scripts/plot/scatter3.m
--- a/scripts/plot/scatter3.m
+++ b/scripts/plot/scatter3.m
@@ -79,33 +79,32 @@ function retval = scatter3 (varargin)
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 
 %!demo
-%! clf
+%! clf;
 %! [x, y, z] = peaks (20);
 %! scatter3 (x(:), y(:), z(:), [], z(:));
+%! ## Default scatter3 with constant size bubbles and color determined by Z
 
 %!demo
-%! clf
-%! x = rand (20,1);
-%! y = rand (20,1);
-%! z = rand (20,1);
+%! clf;
+%! x = rand (20,1);  y = rand (20,1);  z = rand (20,1);
 %! scatter3 (x(:), y(:), z(:), 10, z(:), "s");
+%! ## scatter3 using a square marker of size 10 and color determined by Z
 
 %!demo
-%! clf
-%! x = rand (20,1);
-%! y = rand (20,1);
-%! z = rand (20,1);
-%! scatter3 (x(:), y(:), z(:), 20*z(:), z(:), "s");
+%! clf;
+%! x = rand (20,1);  y = rand (20,1);  z = rand (20,1);
+%! scatter3 (x(:), y(:), z(:), 20*z(:), [], "s");
+%! ## scatter3 using a square marker whose size is determined by Z
 
 %!demo
-%! clf
-%! x = rand (20,1);
-%! y = rand (20,1);
-%! z = rand (20,1);
-%! scatter3 (x(:), y(:), z(:), 20*z(:), [], "s");
+%! clf;
+%! x = rand (20,1);  y = rand (20,1);  z = rand (20,1);
+%! scatter3 (x(:), y(:), z(:), 20*z(:), z(:), "s");
+%! ## scatter3 using a square marker.
+%! ## Size and color of marker are determined by Z
 
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -59,48 +59,48 @@ function retval = semilogx (varargin)
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
 
 %!demo
-%! clf ();
+%! clf;
 %! x = 1:0.01:10;
 %! y = (x .* (1 + rand (size (x)))) .^ 2;
 %! semilogx (y, x);
 
 %!demo
-%! clf ();
+%! clf;
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
 %!
-%! subplot (1, 2, 1);
-%! semilogx (x, y);
-%! xlabel ("semilogx (x, y)");
+%! subplot (1,2,1);
+%!  semilogx (x, y);
+%!  xlabel ("semilogx (x, y)");
 %!
-%! subplot (1, 2, 2);
-%! semilogx (-x, y);
-%! xlabel ("semilogx (-x, y)");
+%! subplot (1,2,2);
+%!  semilogx (-x, y);
+%!  xlabel ("semilogx (-x, y)");
 
 %!demo
-%! clf ();
+%! clf;
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
 %!
-%! subplot (1, 2, 1);
-%! semilogx (x, y);
-%! set (gca, "xdir", "reverse", "activepositionproperty", "outerposition")
-%! xlabel ({"semilogx (x, y)", "xdir = reversed"})
+%! subplot (1,2,1);
+%!  semilogx (x, y);
+%!  set (gca, "xdir", "reverse", "activepositionproperty", "outerposition");
+%!  xlabel ({"semilogx (x, y)", "xdir = reversed"});
 %!
-%! subplot (1, 2, 2);
-%! semilogx (-x, y);
-%! set (gca, "xdir", "reverse", "activepositionproperty", "outerposition");
-%! xlabel ({"semilogx (-x, y)", "xdir = reversed"});
+%! subplot (1,2,2);
+%!  semilogx (-x, y);
+%!  set (gca, "xdir", "reverse", "activepositionproperty", "outerposition");
+%!  xlabel ({"semilogx (-x, y)", "xdir = reversed"});
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   a = logspace (-5, 1, 10);
 %!   b = logspace (-5, 1, 10);
 %!   semilogx (a, b)
 %!   assert (get (gca, "xscale"), "log");
diff --git a/scripts/plot/semilogxerr.m b/scripts/plot/semilogxerr.m
--- a/scripts/plot/semilogxerr.m
+++ b/scripts/plot/semilogxerr.m
@@ -55,15 +55,17 @@ function retval = semilogxerr (varargin)
       retval = tmp;
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! x = exp (log(0.01):0.2:log(10));
 %! y = wblpdf (x, 2, 2);
 %! ey = 0.5*rand (size (y)) .* y;
-%! semilogxerr (x, y, ey, "#~x-")
-%! xlim (x([1, end]))
+%! semilogxerr (x, y, ey, "#~x-");
+%! xlim (x([1, end]));
+
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -58,37 +58,38 @@ function retval = semilogy (varargin)
     endif
 
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
+
 %!demo
-%! clf ();
+%! clf;
 %! x = 1:0.01:10;
 %! y = (x .* (1 + rand (size (x)))) .^ 2;
 %! semilogy (x, y);
 
 %!demo
-%! clf ();
+%! clf;
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
 %!
 %! subplot (2, 1, 1);
 %! semilogy (x, y);
 %! ylabel ("semilogy (x, y)");
 %!
 %! subplot (2, 1, 2);
 %! semilogy (x, -y);
 %! ylabel ("semilogy (x, -y)");
 
 %!demo
-%! clf ();
+%! clf;
 %! x = logspace (-5, 1, 10);
 %! y = logspace (-5, 1, 10);
 %!
 %! subplot (2, 1, 1);
 %! semilogy (x, y);
 %! set (gca, "ydir", "reverse", "activepositionproperty", "outerposition");
 %! ylabel ({"semilogy (x, y)", "ydir = reversed"});
 %!
diff --git a/scripts/plot/semilogyerr.m b/scripts/plot/semilogyerr.m
--- a/scripts/plot/semilogyerr.m
+++ b/scripts/plot/semilogyerr.m
@@ -55,17 +55,18 @@ function retval = semilogyerr (varargin)
       retval = tmp;
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! x = 0.25:0.25:10;
 %! y = wblpdf (x, 4, 2);
 %! eyu = rand (size (y));
 %! eyl = 1.0 - 1./(1+eyu);
-%! semilogyerr (x, y, eyl.*y, eyu.*y, "~-d")
-%! xlim ([0 10])
+%! semilogyerr (x, y, eyl.*y, eyu.*y, "~-d");
+%! xlim ([0 10]);
 
diff --git a/scripts/plot/shading.m b/scripts/plot/shading.m
--- a/scripts/plot/shading.m
+++ b/scripts/plot/shading.m
@@ -70,44 +70,44 @@ function shading (varargin)
       error ("shading: unknown argument");
     endif
   endfor
 
 endfunction
 
 
 %!demo
-%! clf
-%! colormap (jet)
-%! sombrero
-%! shading faceted
-%! title ('shading "faceted"')
+%! clf;
+%! colormap (jet (64));
+%! sombrero ();
+%! shading faceted;
+%! title ('shading "faceted"');
 
 %!demo
-%! clf
-%! sombrero
-%! shading flat
-%! title ('shading "flat"')
+%! clf;
+%! sombrero ();
+%! shading flat;
+%! title ('shading "flat"');
 
 %!demo
-%! clf
-%! sombrero
-%! shading interp
-%! title ('shading "interp"')
+%! clf;
+%! sombrero ();
+%! shading interp;
+%! title ('shading "interp"');
 
 %!demo
-%! clf
-%! pcolor (peaks ())
-%! shading faceted
-%! title ('shading "faceted"')
+%! clf;
+%! pcolor (peaks ());
+%! shading faceted;
+%! title ('shading "faceted"');
 
 %!demo
-%! clf
-%! pcolor (peaks ())
-%! shading flat
-%! title ('shading "flat"')
+%! clf;
+%! pcolor (peaks ());
+%! shading flat;
+%! title ('shading "flat"');
 
 %!demo
-%! clf
-%! pcolor (peaks ())
-%! shading interp
-%! title ('shading "interp"')
+%! clf;
+%! pcolor (peaks ());
+%! shading interp;
+%! title ('shading "interp"');
 
diff --git a/scripts/plot/slice.m b/scripts/plot/slice.m
--- a/scripts/plot/slice.m
+++ b/scripts/plot/slice.m
@@ -177,21 +177,21 @@ function h = slice (varargin)
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
 
 %!demo
-%! clf
+%! clf;
 %! [x, y, z] = meshgrid (linspace (-8, 8, 32));
 %! v = sin (sqrt (x.^2 + y.^2 + z.^2)) ./ (sqrt (x.^2 + y.^2 + z.^2));
 %! slice (x, y, z, v, [], 0, []);
 
 %!demo
-%! clf
+%! clf;
 %! [x, y, z] = meshgrid (linspace (-8, 8, 32));
 %! v = sin (sqrt (x.^2 + y.^2 + z.^2)) ./ (sqrt (x.^2 + y.^2 + z.^2));
 %! [xi, yi] = meshgrid (linspace (-7, 7));
 %! zi = xi + yi;
 %! slice (x, y, z, v, xi, yi, zi);
 
diff --git a/scripts/plot/sombrero.m b/scripts/plot/sombrero.m
--- a/scripts/plot/sombrero.m
+++ b/scripts/plot/sombrero.m
@@ -56,11 +56,13 @@ function [x, y, z] = sombrero (n)
       error ("sombrero: number of grid lines must be greater than 1");
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! sombrero ();
+
diff --git a/scripts/plot/stairs.m b/scripts/plot/stairs.m
--- a/scripts/plot/stairs.m
+++ b/scripts/plot/stairs.m
@@ -205,36 +205,36 @@ function [h, xs, ys] = __stairs__ (doplo
   else
     h = 0;
   endif
 
 endfunction
 
 
 %!demo
-%! clf
+%! clf;
 %! x = 1:10;
 %! rand_1x10_data1 = [0.073, 0.455, 0.837, 0.124, 0.426, 0.781, 0.004, 0.024, 0.519, 0.698];
 %! y = rand_1x10_data1;
 %! stairs (x, y);
 
 %!demo
-%! clf
+%! clf;
 %! x = 1:10;
 %! rand_1x10_data2 = [0.014, 0.460, 0.622, 0.394, 0.531, 0.378, 0.466, 0.788, 0.342, 0.893];
 %! y = rand_1x10_data2;
 %! [xs, ys] = stairs (x, y);
 %! plot (xs, ys);
 
 %!demo
-%! clf
+%! clf;
 %! stairs (1:9);
 
 %!demo
-%! clf
+%! clf;
 %! [xs, ys] = stairs (9:-1:1);
 %! plot (xs, ys);
 
 
 function update_props (h, d)
   set (get (h, "children"), "color", get (h, "color"),
        "linewidth", get (h, "linewidth"),
        "linestyle", get (h, "linestyle"),
diff --git a/scripts/plot/stem.m b/scripts/plot/stem.m
--- a/scripts/plot/stem.m
+++ b/scripts/plot/stem.m
@@ -83,50 +83,50 @@ function h = stem (varargin)
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
 
 %!demo
-%! clf
+%! clf;
 %! x = 1:10;
 %! stem (x);
 
 %!demo
-%! clf
+%! clf;
 %! x = 1:10;
 %! y = 2*x;
 %! stem (x, y);
 
 %!demo
-%! clf
+%! clf;
 %! x = 1:10;
 %! y = 2*x;
 %! h = stem (x, y, "r");
 
 %!demo
-%! clf
+%! clf;
 %! x = 1:10;
 %! y = 2*x;
 %! h = stem (x, y, "-.k");
 
 %!demo
-%! clf
+%! clf;
 %! x = 1:10;
 %! y = 2*x;
 %! h = stem (x, y, "-.k.");
 
 %!demo
-%! clf
+%! clf;
 %! x = 1:10;
 %! y = 2*x;
 %! h = stem (x, y, "filled");
 
 %!demo
-%! clf
-%! x = [0 : 10]';
+%! clf;
+%! x = (0 : 10)';
 %! y = [sin(x), cos(x)];
 %! h = stem (x, y);
 %! set (h(2), "color", "g");
 %! set (h(1), "basevalue", -1)
 
diff --git a/scripts/plot/stem3.m b/scripts/plot/stem3.m
--- a/scripts/plot/stem3.m
+++ b/scripts/plot/stem3.m
@@ -47,12 +47,14 @@ function h = stem3 (varargin)
   tmp = __stem__ (true, varargin{:});
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! theta = 0:0.2:6;
-%! stem3 (cos (theta), sin (theta), theta)
+%! stem3 (cos(theta), sin(theta), theta);
+
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -323,43 +323,43 @@ function pos = subplot_position (rows, c
   else
     ## subplot (row, col, num)
     pos = [x0, y0, width, height];
   endif
 
 endfunction
 
 %!demo
-%! clf
+%! clf;
 %! r = 3;
 %! c = 3;
-%! fmt = {'horizontalalignment', 'center', 'verticalalignment', 'middle'};
-%! for n = 1:(r*c)
-%!   subplot (r, c, n)
-%!   xlabel (sprintf ("xlabel #%d", n))
-%!   ylabel (sprintf ("ylabel #%d", n))
-%!   title (sprintf ("title #%d", n))
-%!   text (0.5, 0.5, sprintf('subplot(%d,%d,%d)', r, c, n), fmt{:})
-%!   axis ([0 1 0 1])
+%! fmt = {"horizontalalignment", "center", "verticalalignment", "middle"};
+%! for n = 1 : r*c
+%!   subplot (r, c, n);
+%!   xlabel (sprintf ("xlabel #%d", n));
+%!   ylabel (sprintf ("ylabel #%d", n));
+%!   title (sprintf ("title #%d", n));
+%!   text (0.5, 0.5, sprintf("subplot(%d,%d,%d)", r, c, n), fmt{:});
+%!   axis ([0 1 0 1]);
 %! endfor
-%! subplot (r, c, 1:3)
-%! xlabel (sprintf ("xlabel #%d:%d", 1, 3))
-%! ylabel (sprintf ("ylabel #%d:%d", 1, 3))
-%! title (sprintf ("title #%d:%d", 1, 3))
-%! text (0.5, 0.5, sprintf('subplot(%d,%d,%d:%d)', r, c, 1, 3), fmt{:})
-%! axis ([0 1 0 1])
+%! subplot (r, c, 1:3);
+%! xlabel (sprintf ("xlabel #%d:%d", 1, 3));
+%! ylabel (sprintf ("ylabel #%d:%d", 1, 3));
+%! title (sprintf ("title #%d:%d", 1, 3));
+%! text (0.5, 0.5, sprintf("subplot(%d,%d,%d:%d)", r, c, 1, 3), fmt{:});
+%! axis ([0 1 0 1]);
 
 %!demo
-%! clf
+%! clf;
 %! x = 0:1;
 %! for n = 1:4
-%!   subplot (2, 2, n, "align")
-%!   plot (x, x)
-%!   xlabel (sprintf ("xlabel (2,2,%d)", n))
-%!   ylabel (sprintf ("ylabel (2,2,%d)", n))
-%!   title (sprintf ("title (2,2,%d)", n))
+%!   subplot (2, 2, n, "align");
+%!   plot (x, x);
+%!   xlabel (sprintf ("xlabel (2,2,%d)", n));
+%!   ylabel (sprintf ("ylabel (2,2,%d)", n));
+%!   title (sprintf ("title (2,2,%d)", n));
 %! endfor
-%! subplot (1, 2, 1, "align")
-%! plot (x, x)
-%! xlabel ("xlabel (1,2,1)")
-%! ylabel ("ylabel (1,2,1)")
-%! title ("title (1,2,1)")
+%! subplot (1, 2, 1, "align");
+%! plot (x, x);
+%! xlabel ("xlabel (1,2,1)");
+%! ylabel ("ylabel (1,2,1)");
+%! title ("title (1,2,1)");
 
diff --git a/scripts/plot/surf.m b/scripts/plot/surf.m
--- a/scripts/plot/surf.m
+++ b/scripts/plot/surf.m
@@ -61,26 +61,26 @@ function retval = surf (varargin)
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 
 %!demo
-%! clf
-%! [~,~,Z] = peaks;
+%! clf;
+%! [~,~,Z] = peaks ();
 %! surf (Z);
 
 %!demo
-%! clf
-%! [~,~,Z] = sombrero;
+%! clf;
+%! [~,~,Z] = sombrero ();
 %! [Fx,Fy] = gradient (Z);
 %! surf (Z, Fx+Fy);
 %! shading interp;
 
 %!demo
-%! clf
-%! [X,Y,Z] = sombrero;
+%! clf;
+%! [X,Y,Z] = sombrero ();
 %! [~,Fy] = gradient (Z);
 %! surf (X, Y, Z, Fy);
 %! shading interp;
 
diff --git a/scripts/plot/surfc.m b/scripts/plot/surfc.m
--- a/scripts/plot/surfc.m
+++ b/scripts/plot/surfc.m
@@ -71,25 +71,26 @@ function h = surfc (varargin)
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
 
 %!demo
-%! clf
-%! [~,~,Z] = peaks;
+%! clf;
+%! [~,~,Z] = peaks ();
 %! surfc (Z);
 
 %!demo
-%! clf
-%! [~,~,Z] = sombrero;
-%! [Fx,Fy] = gradient(Z);
+%! clf;
+%! [~,~,Z] = sombrero ();
+%! [Fx,Fy] = gradient (Z);
 %! surfc (Z, Fx+Fy);
 %! shading interp;
 
 %!demo
-%! clf
-%! [X,Y,Z] = sombrero;
-%! [~,Fy] = gradient(Z);
+%! clf;
+%! [X,Y,Z] = sombrero ();
+%! [~,Fy] = gradient (Z);
 %! surfc (X,Y,Z,Fy);
 %! shading interp;
+
diff --git a/scripts/plot/surfl.m b/scripts/plot/surfl.m
--- a/scripts/plot/surfl.m
+++ b/scripts/plot/surfl.m
@@ -168,22 +168,22 @@ function retval = surfl (varargin)
   if (nargout > 0)
     retval = htmp;
   endif
 
 endfunction
 
 
 %!demo
-%! clf
-%! [X,Y,Z] = sombrero;
-%! colormap (copper);
+%! clf;
+%! [X,Y,Z] = sombrero ();
+%! colormap (copper (64));
 %! surfl (X,Y,Z);
 %! shading interp;
 
 %!demo
-%! clf
-%! [X,Y,Z] = sombrero;
-%! colormap (copper);
-%! [az, el] = view;
+%! clf;
+%! [X,Y,Z] = sombrero ();
+%! colormap (copper (64));
+%! [az, el] = view ();
 %! surfl (X,Y,Z, [az+225,el], [0.2 0.6 0.4 25]);
 %! shading interp;
 
diff --git a/scripts/plot/surfnorm.m b/scripts/plot/surfnorm.m
--- a/scripts/plot/surfnorm.m
+++ b/scripts/plot/surfnorm.m
@@ -138,21 +138,22 @@ function [Nx, Ny, Nz] = surfnorm (vararg
     Ny = ny;
     Nz = nz;
   endif
 
 endfunction
 
 
 %!demo
-%! clf
-%! colormap (jet (64))
+%! clf;
+%! colormap (jet (64));
 %! [x, y, z] = peaks (10);
 %! surfnorm (x, y, z);
 
 %!demo
-%! clf
+%! clf;
 %! surfnorm (peaks (10));
 
 %!demo
-%! clf
+%! clf;
 %! surfnorm (peaks (32));
-%! shading interp
+%! shading interp;
+
diff --git a/scripts/plot/text.m b/scripts/plot/text.m
--- a/scripts/plot/text.m
+++ b/scripts/plot/text.m
@@ -121,22 +121,22 @@ function h = text (varargin)
     endif
 
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! ha = {"left", "center", "right"};
 %! va = {"bottom", "middle", "top"};
-%! x = [0.25 0.5 0.75];
-%! y = [0.25 0.5 0.75];
+%! x = y = [0.25 0.5 0.75];
 %! for t = 0:30:359;
 %!   for nh = 1:numel(ha)
 %!     for nv = 1:numel(va)
 %!       text (x(nh), y(nv), "Hello World", ...
 %!             "rotation", t, ...
 %!             "horizontalalignment", ha{nh}, ...
 %!             "verticalalignment", va{nv});
 %!     endfor
@@ -144,60 +144,60 @@ endfunction
 %! endfor
 %! set (gca, "xtick", [0.25, 0.5, 0.75], ...
 %!           "xticklabel", ha, ...
 %!           "ytick", [0.25, 0.5, 0.75], ...
 %!           "yticklabel", va);
 %! axis ([0 1 0 1]);
 %! xlabel ("horizontal alignment");
 %! ylabel ("vertical alignment");
-%! title ("text alignment and rotation (0:30:360 degrees)")
+%! title ("text alignment and rotation (0:30:360 degrees)");
 
 %!demo
-%! clf
+%! clf;
 %! h = mesh (peaks, "edgecolor", 0.7 * [1 1 1], ...
 %!                  "facecolor", "none", ...
 %!                  "facealpha", 0);
 %! for t = 0:45:359;
 %!   text (25, 25, 0, "Vertical Alignment = Bottom", ...
 %!                    "rotation", t, ...
 %!                    "horizontalalignment", "left", ...
 %!                    "verticalalignment", "bottom");
 %! endfor
 %! caxis ([-100 100]);
 %! title ("Vertically Aligned at Bottom");
 
 %!demo
-%! clf
+%! clf;
 %! axis ([0 8 0 8]);
 %! title (["1st title";"2nd title"]);
 %! xlabel (["1st xlabel";"2nd xlabel"]);
 %! ylabel (["1st ylabel";"2nd ylabel"]);
 %! text (4, 4, {"Hello", "World"}, ...
 %!       "horizontalalignment", "center", ...
 %!       "verticalalignment", "middle");
-%! grid on
+%! grid on;
 
 %!demo
-%! clf
-%! h = mesh (peaks, "edgecolor", 0.7 * [1 1 1], ...
-%!                  "facecolor", "none", ...
-%!                  "facealpha", 0);
+%! clf;
+%! h = mesh (peaks (), "edgecolor", 0.7 * [1 1 1], ...
+%!                     "facecolor", "none", ...
+%!                     "facealpha", 0);
 %! title (["1st title";"2nd title"]);
 %! xlabel (["1st xlabel";"2nd xlabel"]);
 %! ylabel (["1st ylabel";"2nd ylabel"]);
 %! zlabel (["1st zlabel";"2nd zlabel"]);
 %! text (0, 0, 5, {"Hello", "World"}, ...
 %!       "horizontalalignment", "center", ...
 %!       "verticalalignment", "middle");
 %! hold on;
 %! plot3 (0, 0, 5, "+k");
 
 %!demo
-%! clf
+%! clf;
 %! h = text (0.5, 0.3, "char");
 %! assert ("char", class (get (h, "string")));
 %! h = text (0.5, 0.4, ["char row 1"; "char row 2"]);
 %! assert ("char", class (get (h, "string")));
 %! h = text (0.5, 0.6, {"cell2str (1,1)", "cell2str (1,2)"; "cell2str (2,1)", "cell2str (2,2)"});
 %! assert ("cell", class (get (h, "string")));
 %! h = text (0.5, 0.8, "foobar");
 %! set (h, "string", 1:3);
diff --git a/scripts/plot/title.m b/scripts/plot/title.m
--- a/scripts/plot/title.m
+++ b/scripts/plot/title.m
@@ -41,43 +41,43 @@ function retval = title (varargin)
   if (nargout > 0)
     retval = tmp;
   endif
 
 endfunction
 
 
 %!demo
-%! clf ();
-%! ax = axes();
+%! clf;
+%! ax = axes ();
 %! xl = get (ax,"title");
 %! title ("Testing title");
-%! assert (get (xl,"string"), "Testing title");
+%! assert (get (xl, "string"), "Testing title");
 
 %!demo
-%! clf ();
+%! clf;
 %! plot3 ([0,1], [0,1], [0,1]);
-%! xl = get(gca (), "title");
+%! xl = get (gca (), "title");
 %! title ("Testing title");
-%! assert (get (xl,"string"),"Testing title");
+%! assert (get (xl, "string"), "Testing title");
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   ax = axes();
 %!   xl = get (ax,"title");
 %!   title ("Testing title");
-%!   assert (get (xl,"string"), "Testing title");
+%!   assert (get (xl, "string"), "Testing title");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot3 ([0,1], [0,1], [0,1]);
 %!   xl = get (gca (), "title");
-%!   title("Testing title");
-%!   assert (get (xl,"string"), "Testing title");
+%!   title ("Testing title");
+%!   assert (get (xl, "string"), "Testing title");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
 
diff --git a/scripts/plot/trimesh.m b/scripts/plot/trimesh.m
--- a/scripts/plot/trimesh.m
+++ b/scripts/plot/trimesh.m
@@ -51,17 +51,17 @@ function h = trimesh (tri, x, y, z, vara
       h = handle;
     endif
   endif
 
 endfunction
 
 
 %!demo
-%! clf
+%! clf;
 %! old_state = rand ("state");
 %! restore_state = onCleanup (@() rand ("state", old_state));
 %! rand ("state", 10);
 %! N = 10;
 %! x = 3 - 6 * rand (N, N);
 %! y = 3 - 6 * rand (N, N);
 %! z = peaks (x, y);
 %! tri = delaunay (x(:), y(:));
diff --git a/scripts/plot/triplot.m b/scripts/plot/triplot.m
--- a/scripts/plot/triplot.m
+++ b/scripts/plot/triplot.m
@@ -43,17 +43,17 @@ function h = triplot (tri, x, y, varargi
   if (nargout > 0)
     h = handle;
   endif
 
 endfunction
 
 
 %!demo
-%! clf
+%! clf;
 %! old_state = rand ("state");
 %! restore_state = onCleanup (@() rand ("state", old_state));
 %! rand ("state", 2);
 %! N = 20;
 %! x = rand (N, 1);
 %! y = rand (N, 1);
 %! tri = delaunay (x, y);
 %! triplot (tri, x, y);
diff --git a/scripts/plot/trisurf.m b/scripts/plot/trisurf.m
--- a/scripts/plot/trisurf.m
+++ b/scripts/plot/trisurf.m
@@ -66,66 +66,67 @@ function h = trisurf (tri, x, y, z, vara
     if (! ishold ())
       set (gca(), "view", [-37.5, 30],
            "xgrid", "on", "ygrid", "on", "zgrid", "on");
     endif
   endif
 
 endfunction
 
+
 %!demo
-%! clf
+%! clf;
 %! N = 31;
 %! [x, y] = meshgrid (1:N);
 %! tri = delaunay (x, y);
 %! z = peaks (N);
 %! h = trisurf (tri, x, y, z, "facecolor", "interp");
-%! axis tight
-%! zlim auto
-%! title (sprintf ("facecolor = %s", get (h, "facecolor")))
+%! axis tight;
+%! zlim auto;
+%! title (sprintf ("facecolor = %s", get (h, "facecolor")));
 
 %!demo
-%! clf
+%! clf;
 %! N = 31;
 %! [x, y] = meshgrid (1:N);
 %! tri = delaunay (x, y);
 %! z = peaks (N);
 %! h = trisurf (tri, x, y, z, "facecolor", "flat");
-%! axis tight
-%! zlim auto
-%! title (sprintf ("facecolor = %s", get (h, "facecolor")))
+%! axis tight;
+%! zlim auto;
+%! title (sprintf ("facecolor = %s", get (h, "facecolor")));
 
 %!demo
-%! clf
+%! clf;
 %! old_state = rand ("state");
 %! restore_state = onCleanup (@() rand ("state", old_state));
 %! rand ("state", 10);
 %! N = 10;
 %! x = 3 - 6 * rand (N, N);
 %! y = 3 - 6 * rand (N, N);
 %! z = peaks (x, y);
 %! tri = delaunay (x(:), y(:));
 %! trisurf (tri, x(:), y(:), z(:));
 
 %!demo
-%! clf
+%! clf;
 %! x = rand (100, 1);
 %! y = rand (100, 1);
 %! z = x.^2 + y.^2;
 %! tri = delaunay (x, y);
 %! trisurf (tri, x, y, z);
 
 %!demo
-%! clf
+%! clf;
 %! x = rand (100, 1);
 %! y = rand (100, 1);
 %! z = x.^2 + y.^2;
 %! tri = delaunay (x, y);
 %! trisurf (tri, x, y, z, "facecolor", "interp");
 
 %!demo
-%! clf
+%! clf;
 %! x = rand (100, 1);
 %! y = rand (100, 1);
 %! z = x.^2 + y.^2;
 %! tri = delaunay (x, y);
 %! trisurf (tri, x, y, z, "facecolor", "interp", "edgecolor", "k");
 
diff --git a/scripts/plot/uigetdir.m b/scripts/plot/uigetdir.m
--- a/scripts/plot/uigetdir.m
+++ b/scripts/plot/uigetdir.m
@@ -53,14 +53,15 @@ function dirname = uigetdir (init_path =
 
   if (!isdir (init_path))
     init_path = fileparts (init_path);
   endif
   dirname = feval (funcname, init_path, dialog_name);
 
 endfunction
 
+
 %!demo
-%! uigetdir(pwd, "Select Directory")
+%! uigetdir (pwd, "Select Directory");
 
 ## Remove from test statistics.  No real tests possible.
-%!test
-%! assert (1);
+%!assert (1)
+
diff --git a/scripts/plot/uigetfile.m b/scripts/plot/uigetfile.m
--- a/scripts/plot/uigetfile.m
+++ b/scripts/plot/uigetfile.m
@@ -181,14 +181,15 @@ function [retfile, retpath, retindex] = 
       endif
     endfor
   endif
 
   [retfile, retpath, retindex] = feval (funcname, outargs{:});
 
 endfunction
 
+
 %!demo
-%! uigetfile({"*.gif;*.png;*.jpg", "Supported Picture Formats"})
+%! uigetfile ({"*.gif;*.png;*.jpg", "Supported Picture Formats"});
 
 ## Remove from test statistics.  No real tests possible.
-%!test
-%! assert (1);
+%!assert (1);
+
diff --git a/scripts/plot/uimenu.m b/scripts/plot/uimenu.m
--- a/scripts/plot/uimenu.m
+++ b/scripts/plot/uimenu.m
@@ -86,19 +86,19 @@ function hui = uimenu (varargin)
   if (nargout > 0)
     hui = tmp;
   endif
 
 endfunction
 
 
 %!demo
-%! clf
+%! clf;
 %! surfl (peaks);
-%! colormap (copper);
+%! colormap (copper (64));
 %! shading ("interp");
 %! f = uimenu ("label", "&File", "accelerator", "f");
 %! e = uimenu ("label", "&Edit", "accelerator", "e");
 %! uimenu (f, "label", "Close", "accelerator", "q", "callback", "close (gcf)");
 %! uimenu (e, "label", "Toggle &Grid", "accelerator", "g", "callback", "grid (gca)");
 
 %!testif HAVE_FLTK
 %! toolkit = graphics_toolkit ();
@@ -119,31 +119,31 @@ endfunction
 
 %% check for top level menus file, edit, and help
 %!testif HAVE_FLTK
 %! toolkit = graphics_toolkit ();
 %! graphics_toolkit ("fltk");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   uif = findall (hf, "label", "&file");
-%!   assert (ishghandle (uif))
+%!   assert (ishghandle (uif));
 %!   uie = findall (hf, "label", "&edit");
-%!   assert (ishghandle (uie))
+%!   assert (ishghandle (uie));
 %!   uih = findall (hf, "label", "&help");
-%!   assert (ishghandle (uih))
+%!   assert (ishghandle (uih));
 %! unwind_protect_cleanup
 %!   close (hf);
 %!   graphics_toolkit (toolkit);
 %! end_unwind_protect
 
 %!testif HAVE_FLTK
 %! toolkit = graphics_toolkit ();
 %! graphics_toolkit ("fltk");
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   uie = findall (hf, "label", "&edit");
 %!   myui = uimenu (uie, "label", "mylabel");
-%!   assert (ancestor (myui, "uimenu", "toplevel"), uie)
+%!   assert (ancestor (myui, "uimenu", "toplevel"), uie);
 %! unwind_protect_cleanup
 %!   close (hf);
 %!   graphics_toolkit (toolkit);
 %! end_unwind_protect
 
diff --git a/scripts/plot/uiputfile.m b/scripts/plot/uiputfile.m
--- a/scripts/plot/uiputfile.m
+++ b/scripts/plot/uiputfile.m
@@ -115,14 +115,15 @@ function [retfile, retpath, retindex] = 
       print_usage ();
     endif
   endif
 
   [retfile, retpath, retindex] = feval (funcname, outargs{:});
 
 endfunction
 
+
 %!demo
-%! uiputfile({"*.gif;*.png;*.jpg", "Supported Picture Formats"})
+%! uiputfile ({"*.gif;*.png;*.jpg", "Supported Picture Formats"});
 
 ## Remove from test statistics.  No real tests possible.
-%!test
-%! assert (1);
+%!assert (1)
+
diff --git a/scripts/plot/waitbar.m b/scripts/plot/waitbar.m
--- a/scripts/plot/waitbar.m
+++ b/scripts/plot/waitbar.m
@@ -21,17 +21,17 @@
 ## @deftypefnx {Function File} {@var{h} =} waitbar (@var{frac}, @var{msg})
 ## @deftypefnx {Function File} {@var{h} =} waitbar (@dots{}, "FigureProperty", "Value", @dots{})
 ## @deftypefnx {Function File} {} waitbar (@var{frac})
 ## @deftypefnx {Function File} {} waitbar (@var{frac}, @var{hwbar})
 ## @deftypefnx {Function File} {} waitbar (@var{frac}, @var{hwbar}, @var{msg})
 ## Return a handle @var{h} to a new waitbar object.  The waitbar is
 ## filled to fraction @var{frac} which must be in the range [0, 1].  The
 ## optional message @var{msg} is centered and displayed above the waitbar.
-## The appearance of the waitbar figure window can be configured by passing 
+## The appearance of the waitbar figure window can be configured by passing
 ## property/value pairs to the function.
 ## 
 ## When called with a single input the current waitbar, if it exists, is
 ## updated to the new value @var{frac}.  If there are multiple outstanding
 ## waitbars they can be updated individually by passing the handle @var{hwbar}
 ## of the specific waitbar to modify.
 ## @end deftypefn
 
@@ -139,36 +139,36 @@ endfunction
 %! close (h);
 
 %!demo
 %! h = waitbar (0, "please wait...");
 %! for i = 0:0.01:0.6
 %!   waitbar (i);
 %! endfor
 %! i = 0.3;
-%! waitbar (i, h, "don't you hate taking a step backward?")
+%! waitbar (i, h, "don't you hate taking a step backward?");
 %! pause (0.5);
 %! for i = i:0.005:0.7
 %!   waitbar (i, h);
 %! endfor
-%! waitbar (i, h, "or stalling?")
+%! waitbar (i, h, "or stalling?");
 %! pause (1);
 %! for i = i:0.003:0.8
-%!   waitbar (i, h, "just a little longer now")
+%!   waitbar (i, h, "just a little longer now");
 %! endfor
 %! for i = i:0.001:1
-%!   waitbar (i, h, "please don't be impatient")
+%!   waitbar (i, h, "please don't be impatient");
 %! endfor
 %! close (h);
 
 %!demo
 %! h1 = waitbar (0, "Waitbar #1");
 %! h2 = waitbar (0, "Waitbar #2");
 %! h2pos = get (h2, "position");
-%! h2pos(1) += h2pos(3) + 50;
+%! h2pos(1) += (h2pos(3) + 50);
 %! set (h2, "position", h2pos);
 %! pause (0.5);
 %! for i = 1:4
 %!   waitbar (i/4, h1);
 %!   pause (0.5);
 %!   waitbar (i/4, h2);
 %!   pause (0.5);
 %! endfor
diff --git a/scripts/plot/xlim.m b/scripts/plot/xlim.m
--- a/scripts/plot/xlim.m
+++ b/scripts/plot/xlim.m
@@ -44,41 +44,42 @@
 function retval = xlim (varargin)
   ret = __axes_limits__ ("xlim", varargin{:});
 
   if (! isempty (ret))
     retval = ret;
   endif
 endfunction
 
+
 %!demo
-%! clf ();
+%! clf;
 %! line ();
 %! xlim ([0.2, 0.8]);
 %! title ("xlim is [0.2, 0.8]");
 %! assert (xlim (), [0.2, 0.8]);
 
 %!demo
-%! clf ();
+%! clf;
 %! line ();
-%! xlim ('auto');
+%! xlim ("auto");
 %! title ("xlim is auto");
 %! assert (xlim ("mode"), "auto");
 
 %!demo
-%! clf ();
+%! clf;
 %! plot3 ([0,1], [0,1], [0,1]);
 %! xlim ([0.2, 0.8]);
 %! title ("xlim is [0.2, 0.8]");
 %! assert (xlim (), [0.2, 0.8]);
 
 %!demo
-%! clf ();
+%! clf;
 %! plot3 ([0,1], [0,1], [0,1]);
-%! xlim ('auto');
+%! xlim ("auto");
 %! title ("xlim is auto");
 %! assert (xlim ("mode"), "auto");
 
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot3 ([0,1], [0,1], [0,1]);
@@ -93,8 +94,9 @@ endfunction
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   h = plot3 ([0,1.1], [0,1], [0, 1]);
 %!   assert (get (gca, "xlim"), [0, 1.4], eps);
 %!   assert (xlim ("mode"), "auto");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/ylim.m b/scripts/plot/ylim.m
--- a/scripts/plot/ylim.m
+++ b/scripts/plot/ylim.m
@@ -40,41 +40,42 @@
 function retval = ylim (varargin)
   ret = __axes_limits__ ("ylim", varargin{:});
 
   if (! isempty (ret))
     retval = ret;
   endif
 endfunction
 
+
 %!demo
-%! clf ();
+%! clf;
 %! line ();
 %! ylim ([0.2, 0.8]);
 %! title ("ylim is [0.2, 0.8]");
 %! assert (ylim (), [0.2, 0.8]);
 
 %!demo
-%! clf ();
+%! clf;
 %! line ();
-%! ylim ('auto');
+%! ylim ("auto");
 %! title ("ylim is auto");
 %! assert (ylim ("mode"), "auto");
 
 %!demo
-%! clf ();
+%! clf;
 %! plot3 ([0,1], [0,1], [0,1]);
 %! ylim ([0.2, 0.8]);
 %! title ("ylim is [0.2, 0.8]");
 %! assert (ylim (), [0.2, 0.8]);
 
 %!demo
-%! clf ();
+%! clf;
 %! plot3 ([0,1], [0,1], [0,1]);
-%! ylim ('auto');
+%! ylim ("auto");
 %! title ("ylim is auto");
 %! assert (ylim ("mode"), "auto");
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   limy = [0, 1.1];
 %!   plot3 ([0,1], [0,1], [0,1]);
@@ -89,8 +90,9 @@ endfunction
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot3 ([0,1], [0,1.1], [0, 1]);
 %!   assert (get (gca, "ylim"), [0, 1.4], eps);
 %!   assert (ylim ("mode"), "auto");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/plot/zlim.m b/scripts/plot/zlim.m
--- a/scripts/plot/zlim.m
+++ b/scripts/plot/zlim.m
@@ -40,41 +40,42 @@
 function retval = zlim (varargin)
   ret = __axes_limits__ ("zlim", varargin{:});
 
   if (! isempty (ret))
     retval = ret;
   endif
 endfunction
 
+
 %!demo
-%! clf ();
+%! clf;
 %! line ();
 %! zlim ([0.2, 0.8]);
 %! title ("zlim is [0.2, 0.8]");
 %! assert (zlim (), [0.2, 0.8]);
 
 %!demo
-%! clf ();
+%! clf;
 %! line ();
-%! zlim ('auto');
+%! zlim ("auto");
 %! title ("zlim is auto");
 %! assert (zlim ("mode"), "auto");
 
 %!demo
-%! clf ();
+%! clf;
 %! plot3 ([0,1], [0,1], [0,1]);
 %! zlim ([0.2, 0.8]);
 %! title ("zlim is [0.2, 0.8]");
 %! assert (zlim (), [0.2, 0.8]);
 
 %!demo
-%! clf ();
+%! clf;
 %! plot3 ([0,1], [0,1], [0,1]);
-%! zlim ('auto');
+%! zlim ("auto");
 %! title ("zlim is auto");
 %! assert (zlim ("mode"), "auto");
 
 %!test
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   limz = [0, 1.1];
 %!   plot3 ([0,1], [0,1], [0,1]);
@@ -89,8 +90,9 @@ endfunction
 %! hf = figure ("visible", "off");
 %! unwind_protect
 %!   plot3 ([0,1], [0,1], [0, 1.1]);
 %!   assert (get (gca, "zlim"), [0, 1.4], eps);
 %!   assert (zlim ("mode"), "auto");
 %! unwind_protect_cleanup
 %!   close (hf);
 %! end_unwind_protect
+
diff --git a/scripts/polynomial/mkpp.m b/scripts/polynomial/mkpp.m
--- a/scripts/polynomial/mkpp.m
+++ b/scripts/polynomial/mkpp.m
@@ -74,39 +74,41 @@ function pp = mkpp (x, P, d)
     pp.order /= prod (d);
   endif
 
   dim_vec = [pp.pieces * prod(pp.dim), pp.order];
   pp.coefs = reshape (P, dim_vec);
 
 endfunction
 
+
 %!demo # linear interpolation
-%! x=linspace(0,pi,5)';
-%! t=[sin(x),cos(x)];
-%! m=diff(t)./(x(2)-x(1));
-%! b=t(1:4,:);
-%! pp = mkpp(x, [m(:),b(:)]);
-%! xi=linspace(0,pi,50);
-%! plot(x,t,"x",xi,ppval(pp,xi));
-%! legend("control","interp");
+%! x = linspace (0,pi,5)';
+%! t = [sin(x), cos(x)];
+%! m = diff (t) ./ (x(2)-x(1));
+%! b = t(1:4,:);
+%! pp = mkpp (x, [m(:),b(:)]);
+%! xi = linspace (0,pi,50);
+%! plot (x,t,"x", xi,ppval (pp,xi));
+%! legend ("control","interp");
 
 %!shared b,c,pp
-%! b = 1:3; c = 1:24; pp=mkpp(b,c);
-%!assert (pp.pieces,2);
-%!assert (pp.order,12);
-%!assert (pp.dim,1);
-%!assert (size(pp.coefs),[2,12]);
-%! pp=mkpp(b,c,2);
-%!assert (pp.pieces,2);
-%!assert (pp.order,6);
-%!assert (pp.dim,2);
-%!assert (size(pp.coefs),[4,6]);
-%! pp=mkpp(b,c,3);
-%!assert (pp.pieces,2);
-%!assert (pp.order,4);
-%!assert (pp.dim,3);
-%!assert (size(pp.coefs),[6,4]);
-%! pp=mkpp(b,c,[2,3]);
-%!assert (pp.pieces,2);
-%!assert (pp.order,2);
-%!assert (pp.dim,[2,3]);
-%!assert (size(pp.coefs),[12,2]);
+%! b = 1:3; c = 1:24; pp = mkpp (b,c);
+%!assert (pp.pieces, 2);
+%!assert (pp.order, 12);
+%!assert (pp.dim, 1);
+%!assert (size (pp.coefs), [2,12]);
+%! pp = mkpp(b,c,2);
+%!assert (pp.pieces, 2);
+%!assert (pp.order, 6);
+%!assert (pp.dim, 2);
+%!assert (size (pp.coefs), [4,6]);
+%! pp = mkpp(b,c,3);
+%!assert (pp.pieces, 2);
+%!assert (pp.order, 4);
+%!assert (pp.dim, 3);
+%!assert (size (pp.coefs), [6,4]);
+%! pp = mkpp(b,c,[2,3]);
+%!assert (pp.pieces, 2);
+%!assert (pp.order, 2);
+%!assert (pp.dim, [2,3]);
+%!assert (size (pp.coefs), [12,2]);
+
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -120,50 +120,52 @@ function ret = pchip (x, y, xi)
   ret = mkpp (x, coeffs, szy(1:end-1));
 
   if (nargin == 3)
     ret = ppval (ret, xi);
   endif
 
 endfunction
 
+
 %!demo
 %! x = 0:8;
 %! y = [1, 1, 1, 1, 0.5, 0, 0, 0, 0];
 %! xi = 0:0.01:8;
-%! yspline = spline(x,y,xi);
-%! ypchip = pchip(x,y,xi);
-%! title("pchip and spline fit to discontinuous function");
-%! plot(xi,yspline,xi,ypchip,"-",x,y,"+");
-%! legend ("spline","pchip","data");
+%! yspline = spline (x,y,xi);
+%! ypchip = pchip (x,y,xi);
+%! title ("pchip and spline fit to discontinuous function");
+%! plot (xi,yspline, xi,ypchip,"-", x,y,"+");
+%! legend ("spline", "pchip", "data");
 %! %-------------------------------------------------------------------
 %! % confirm that pchip agreed better to discontinuous data than spline
 
 %!shared x,y,y2,pp,yi1,yi2,yi3
 %! x = 0:8;
 %! y = [1, 1, 1, 1, 0.5, 0, 0, 0, 0];
-%!assert (pchip(x,y,x), y);
-%!assert (pchip(x,y,x'), y');
-%!assert (pchip(x',y',x'), y');
-%!assert (pchip(x',y',x), y);
-%!assert (isempty(pchip(x',y',[])));
-%!assert (isempty(pchip(x,y,[])));
-%!assert (pchip(x,[y;y],x), [pchip(x,y,x);pchip(x,y,x)])
-%!assert (pchip(x,[y;y],x'), [pchip(x,y,x);pchip(x,y,x)])
-%!assert (pchip(x',[y;y],x), [pchip(x,y,x);pchip(x,y,x)])
-%!assert (pchip(x',[y;y],x'), [pchip(x,y,x);pchip(x,y,x)])
+%!assert (pchip (x,y,x), y)
+%!assert (pchip (x,y,x'), y')
+%!assert (pchip (x',y',x'), y')
+%!assert (pchip (x',y',x), y)
+%!assert (isempty (pchip(x',y',[])))
+%!assert (isempty (pchip(x,y,[])))
+%!assert (pchip (x,[y;y],x), [pchip(x,y,x);pchip(x,y,x)])
+%!assert (pchip (x,[y;y],x'), [pchip(x,y,x);pchip(x,y,x)])
+%!assert (pchip (x',[y;y],x), [pchip(x,y,x);pchip(x,y,x)])
+%!assert (pchip (x',[y;y],x'), [pchip(x,y,x);pchip(x,y,x)])
 %!test
-%! x=(0:8)*pi/4;y=[sin(x);cos(x)];
-%! y2(:,:,1)=y;y2(:,:,2)=y+1;y2(:,:,3)=y-1;
-%! pp=pchip(x,shiftdim(y2,2));
-%! yi1=ppval(pp,(1:4)*pi/4);
-%! yi2=ppval(pp,repmat((1:4)*pi/4,[5,1]));
-%! yi3=ppval(pp,[pi/2,pi]);
-%!assert(size(pp.coefs),[48,4]);
-%!assert(pp.pieces,8);
-%!assert(pp.order,4);
-%!assert(pp.dim,[3,2]);
-%!assert(ppval(pp,pi),[0,-1;1,0;-1,-2],1e-14);
-%!assert(yi3(:,:,2),ppval(pp,pi),1e-14);
-%!assert(yi3(:,:,1),[1,0;2,1;0,-1],1e-14);
-%!assert(squeeze(yi1(1,2,:)),[1/sqrt(2); 0; -1/sqrt(2);-1],1e-14);
-%!assert(size(yi2),[3,2,5,4]);
-%!assert(squeeze(yi2(1,2,3,:)),[1/sqrt(2); 0; -1/sqrt(2);-1],1e-14);
+%! x = (0:8)*pi/4; y = [sin(x);cos(x)];
+%! y2(:,:,1) = y; y2(:,:,2) = y+1; y2(:,:,3) = y-1;
+%! pp = pchip (x, shiftdim (y2,2));
+%! yi1 = ppval (pp, (1:4)*pi/4);
+%! yi2 = ppval (pp, repmat ((1:4)*pi/4, [5,1]));
+%! yi3 = ppval (pp, [pi/2,pi]);
+%!assert (size (pp.coefs), [48,4])
+%!assert (pp.pieces, 8)
+%!assert (pp.order, 4)
+%!assert (pp.dim, [3,2])
+%!assert (ppval (pp,pi), [0,-1;1,0;-1,-2], 1e-14)
+%!assert (yi3(:,:,2), ppval(pp,pi), 1e-14)
+%!assert (yi3(:,:,1), [1,0;2,1;0,-1], 1e-14)
+%!assert (squeeze (yi1(1,2,:)), [1/sqrt(2); 0; -1/sqrt(2);-1], 1e-14)
+%!assert (size (yi2), [3,2,5,4])
+%!assert (squeeze (yi2(1,2,3,:)), [1/sqrt(2); 0; -1/sqrt(2);-1], 1e-14)
+
diff --git a/scripts/polynomial/polyaffine.m b/scripts/polynomial/polyaffine.m
--- a/scripts/polynomial/polyaffine.m
+++ b/scripts/polynomial/polyaffine.m
@@ -68,21 +68,21 @@ function g = polyaffine (f, mu)
    endif
 
 endfunction
 
 
 %!demo
 %! f = [1/5 4/5 -7/5 -2];
 %! g = polyaffine (f, [1, 1.2]);
-%! x = linspace (-4, 4, 100);
-%! plot(x, polyval (f, x), x, polyval (g, x));
+%! x = linspace (-4,4,100);
+%! plot (x,polyval(f, x), x,polyval(g, x));
 %! legend ("original", "affine");
 %! axis ([-4 4 -3 5]);
-%! grid ("on");
+%! grid on;
 
 %!test
 %! f = [1/5 4/5 -7/5 -2];
 %! mu = [1, 1.2];
 %! g = polyaffine (f, mu);
-%! x = linspace (-4, 4, 100);
+%! x = linspace (-4,4,100);
 %! assert (polyval (f, x, [], mu), polyval (g, x), 1e-10);
 
diff --git a/scripts/polynomial/spline.m b/scripts/polynomial/spline.m
--- a/scripts/polynomial/spline.m
+++ b/scripts/polynomial/spline.m
@@ -239,47 +239,48 @@ function ret = spline (x, y, xi)
   ret = mkpp (x, cat (2, d, c, b, a), szy(1:end-1));
 
   if (nargin == 3)
     ret = ppval (ret, xi);
   endif
 
 endfunction
 
+
 %!demo
-%! x = 0:10; y = sin(x);
-%! xspline = 0:0.1:10; yspline = spline(x,y,xspline);
-%! title("spline fit to points from sin(x)");
-%! plot(xspline,sin(xspline),"r",xspline,yspline,"g-",x,y,"b+");
-%! legend("original","interpolation","interpolation points");
+%! x = 0:10; y = sin (x);
+%! xspline = 0:0.1:10; yspline = spline (x,y,xspline);
+%! title ("spline fit to points from sin(x)");
+%! plot (xspline,sin(xspline),"r", xspline,yspline,"g-", x,y,"b+");
+%! legend ("original", "interpolation", "interpolation points");
 %! %--------------------------------------------------------
 %! % confirm that interpolated function matches the original
 
 %!shared x,y,abserr
-%! x = [0:10]; y = sin(x); abserr = 1e-14;
-%!assert (spline(x,y,x), y, abserr);
-%!assert (spline(x,y,x'), y', abserr);
-%!assert (spline(x',y',x'), y', abserr);
-%!assert (spline(x',y',x), y, abserr);
-%!assert (isempty(spline(x',y',[])));
-%!assert (isempty(spline(x,y,[])));
-%!assert (spline(x,[y;y],x), [spline(x,y,x);spline(x,y,x)],abserr)
-%!assert (spline(x,[y;y],x'), [spline(x,y,x);spline(x,y,x)],abserr)
-%!assert (spline(x',[y;y],x), [spline(x,y,x);spline(x,y,x)],abserr)
-%!assert (spline(x',[y;y],x'), [spline(x,y,x);spline(x,y,x)],abserr)
+%! x = [0:10]; y = sin (x); abserr = 1e-14;
+%!assert (spline (x,y,x), y, abserr)
+%!assert (spline (x,y,x'), y', abserr)
+%!assert (spline (x',y',x'), y', abserr)
+%!assert (spline (x',y',x), y, abserr)
+%!assert (isempty (spline (x',y',[])))
+%!assert (isempty (spline (x,y,[])))
+%!assert (spline (x,[y;y],x), [spline(x,y,x);spline(x,y,x)], abserr)
+%!assert (spline (x,[y;y],x'), [spline(x,y,x);spline(x,y,x)], abserr)
+%!assert (spline (x',[y;y],x), [spline(x,y,x);spline(x,y,x)], abserr)
+%!assert (spline (x',[y;y],x'), [spline(x,y,x);spline(x,y,x)], abserr)
 %! y = cos(x) + i*sin(x);
-%!assert (spline(x,y,x), y, abserr)
-%!assert (real(spline(x,y,x)), real(y), abserr);
-%!assert (real(spline(x,y,x.')), real(y).', abserr);
-%!assert (real(spline(x.',y.',x.')), real(y).', abserr);
-%!assert (real(spline(x.',y,x)), real(y), abserr);
-%!assert (imag(spline(x,y,x)), imag(y), abserr);
-%!assert (imag(spline(x,y,x.')), imag(y).', abserr);
-%!assert (imag(spline(x.',y.',x.')), imag(y).', abserr);
-%!assert (imag(spline(x.',y,x)), imag(y), abserr);
+%!assert (spline (x,y,x), y, abserr)
+%!assert (real (spline (x,y,x)), real (y), abserr)
+%!assert (real (spline (x,y,x.')), real (y).', abserr)
+%!assert (real (spline (x.',y.',x.')), real (y).', abserr)
+%!assert (real (spline (x.',y,x)), real (y), abserr)
+%!assert (imag (spline (x,y,x)), imag (y), abserr)
+%!assert (imag (spline (x,y,x.')), imag (y).', abserr)
+%!assert (imag (spline (x.',y.',x.')), imag (y).', abserr)
+%!assert (imag (spline (x.',y,x)), imag (y), abserr)
 %!test
 %! xnan = 5;
 %! y(x==xnan) = NaN;
 %! ok = ! isnan (y);
 %! assert (spline (x, y, x(ok)), y(ok), abserr);
 %!test
 %! ok = ! isnan (y);
 %! assert (! isnan (spline (x, y, x(!ok))));
@@ -298,8 +299,9 @@ endfunction
 %! [x,P] = unmkpp (pp);
 %! assert (norm (P-[3,-3,1,2]), 0, abserr);
 %!test
 %! x = [2,1];
 %! y = [1,2,3,4];
 %! pp = spline (x,y);
 %! [x,P] = unmkpp (pp);
 %! assert (norm (P-[7,-9,1,3]), 0, abserr);
+
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -201,21 +201,22 @@ function [x, flag, relres, iter, resvec]
     endif
 
   else
     print_usage ();
   endif
 
 endfunction
 
+
 %!demo
 %! % Solve system of A*x=b
-%! A = [5 -1 3;-1 2 -2;3 -2 3]
-%! b = [7;-1;4]
-%! [x, flag, relres, iter, resvec] = bicgstab(A, b)
+%! A = [5 -1 3;-1 2 -2;3 -2 3];
+%! b = [7;-1;4];
+%! [x, flag, relres, iter, resvec] = bicgstab (A, b)
 
 %!shared A, b, n, M1, M2
 %!
 %!test
 %! n = 100;
 %! A = spdiags ([-2*ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
 %! b = sum (A, 2);
 %! tol = 1e-8;
diff --git a/scripts/sparse/cgs.m b/scripts/sparse/cgs.m
--- a/scripts/sparse/cgs.m
+++ b/scripts/sparse/cgs.m
@@ -184,22 +184,21 @@ function [x, flag, relres, iter, resvec]
 
   else
     print_usage ();
   endif
 
 endfunction
 
 
-
 %!demo
 %! % Solve system of A*x=b
-%! A=[5 -1 3;-1 2 -2;3 -2 3]
-%! b=[7;-1;4]
-%! [a,b,c,d,e]=cgs(A,b)
+%! A = [5 -1 3;-1 2 -2;3 -2 3];
+%! b = [7;-1;4];
+%! [a,b,c,d,e] = cgs (A,b)
 
 %!shared A, b, n, M
 %!
 %!test
 %! n = 100;
 %! A = spdiags ([-ones(n,1) 4*ones(n,1) -ones(n,1)], -1:1, n, n);
 %! b = sum (A, 2);
 %! tol = 1e-8;
@@ -218,8 +217,9 @@ endfunction
 %!test
 %! n = 100;
 %! tol = 1e-8;
 %! a = sprand (n, n, .1);
 %! A = a'*a + 100 * eye (n);
 %! b = sum (A, 2);
 %! [x, flag, relres, iter, resvec] = cgs (A, b, tol, [], diag (diag (A)));
 %! assert (x, ones (size (b)), 1e-7);
+
diff --git a/scripts/sparse/gplot.m b/scripts/sparse/gplot.m
--- a/scripts/sparse/gplot.m
+++ b/scripts/sparse/gplot.m
@@ -61,23 +61,23 @@ endfunction
 %! A = [0 1 0 0 0 0 0
 %!      1 0 1 1 0 0 0
 %!      0 1 0 0 0 0 0
 %!      0 1 0 0 1 0 0
 %!      0 0 0 1 0 1 1
 %!      0 0 0 0 1 0 0
 %!      0 0 0 0 1 0 0];
 %!
-%! xy = [1, 0
+%! xy = [1  , 0
 %!       1.5, 1
-%!       2, 0
+%!       2  , 0
 %!       2.5, 2
 %!       3.5, 1
-%!       3, 0
-%!       4, 0];
+%!       3  , 0
+%!       4  , 0];
 %!
 %! clf;
 %! gplot (A, xy, "o-");
 %! set (get (gca, ("children")), "markersize", 12);
 %! title ("gplot() of Binary Tree Adjacency matrix");
 
 %% Mark graphical function as tested by demo block
 %!assert (1);
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -384,150 +384,159 @@ function [x, flag, relres, iter, resvec,
   if (! matrix_positive_definite)
     flag = 3;
     if (nargout < 2)
       warning ("pcg: matrix not positive definite?\n");
     endif
   endif
 endfunction
 
+
 %!demo
-%!
-%!      # Simplest usage of pcg (see also 'help pcg')
-%!
-%!      N = 10;
-%!      A = diag ([1:N]); b = rand (N, 1); y =  A \ b; #y is the true solution
-%!      x = pcg (A, b);
-%!      printf('The solution relative error is %g\n', norm (x - y) / norm (y));
-%!
-%!      # You shouldn't be afraid if pcg issues some warning messages in this
-%!      # example: watch out in the second example, why it takes N iterations
-%!      # of pcg to converge to (a very accurate, by the way) solution
+%!  # Simplest usage of pcg (see also 'help pcg')
+%! 
+%!  N = 10;
+%!  A = diag ([1:N]); b = rand (N, 1);
+%!  y = A \ b;  # y is the true solution
+%!  x = pcg (A, b);
+%!  printf ("The solution relative error is %g\n", norm (x - y) / norm (y));
+%! 
+%!  # You shouldn't be afraid if pcg issues some warning messages in this
+%!  # example: watch out in the second example, why it takes N iterations
+%!  # of pcg to converge to (a very accurate, by the way) solution
+
 %!demo
-%!
-%!      # Full output from pcg, except for the eigenvalue estimates
-%!      # We use this output to plot the convergence history
-%!
-%!      N = 10;
-%!      A = diag ([1:N]); b = rand (N, 1); X =  A \ b; #X is the true solution
-%!      [x, flag, relres, iter, resvec] = pcg (A, b);
-%!      printf('The solution relative error is %g\n', norm (x - X) / norm (X));
-%!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||/||b||)');
-%!      semilogy([0:iter], resvec / resvec(1),'o-g');
-%!      legend('relative residual');
+%!  # Full output from pcg, except for the eigenvalue estimates
+%!  # We use this output to plot the convergence history
+%! 
+%!  N = 10;
+%!  A = diag ([1:N]); b = rand (N, 1);
+%!  X = A \ b;  # X is the true solution
+%!  [x, flag, relres, iter, resvec] = pcg (A, b);
+%!  printf ("The solution relative error is %g\n", norm (x - X) / norm (X));
+%!  title ("Convergence history");
+%!  semilogy ([0:iter], resvec / resvec(1), "o-g");
+%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||/||b||)");
+%!  legend ("relative residual");
+
 %!demo
-%!
-%!      # Full output from pcg, including the eigenvalue estimates
-%!      # Hilbert matrix is extremely ill conditioned, so pcg WILL have problems
-%!
-%!      N = 10;
-%!      A = hilb (N); b = rand (N, 1); X = A \ b; #X is the true solution
-%!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], 200);
-%!      printf('The solution relative error is %g\n', norm (x - X) / norm (X));
-%!      printf('Condition number estimate is %g\n', eigest(2) / eigest (1));
-%!      printf('Actual condition number is   %g\n', cond (A));
-%!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||)');
-%!      semilogy([0:iter], resvec,['o-g';'+-r']);
-%!      legend('absolute residual','absolute preconditioned residual');
+%!  # Full output from pcg, including the eigenvalue estimates
+%!  # Hilbert matrix is extremely ill-conditioned, so pcg WILL have problems
+%! 
+%!  N = 10;
+%!  A = hilb (N); b = rand (N, 1);
+%!  X = A \ b;  # X is the true solution
+%!  [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], 200);
+%!  printf ("The solution relative error is %g\n", norm (x - X) / norm (X));
+%!  printf ("Condition number estimate is %g\n", eigest(2) / eigest(1));
+%!  printf ("Actual condition number is   %g\n", cond (A));
+%!  title ("Convergence history");
+%!  semilogy ([0:iter], resvec, ["o-g";"+-r"]);
+%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
+%!  legend ("absolute residual", "absolute preconditioned residual");
+
 %!demo
 %!
-%!      # Full output from pcg, including the eigenvalue estimates
-%!      # We use the 1-D Laplacian matrix for A, and cond(A) = O(N^2)
-%!      # and that's the reasone we need some preconditioner; here we take
-%!      # a very simple and not powerful Jacobi preconditioner,
-%!      # which is the diagonal of A
+%!  # Full output from pcg, including the eigenvalue estimates
+%!  # We use the 1-D Laplacian matrix for A, and cond(A) = O(N^2)
+%!  # and that's the reason we need some preconditioner; here we take
+%!  # a very simple and not powerful Jacobi preconditioner,
+%!  # which is the diagonal of A
 %!
-%!      N = 100;
-%!      A = zeros (N, N);
-%!      for i=1 : N - 1 # form 1-D Laplacian matrix
-%!              A (i:i+1, i:i+1) = [2 -1; -1 2];
-%!      endfor
-%!      b = rand (N, 1); X = A \ b; #X is the true solution
-%!      maxit = 80;
-%!      printf('System condition number is %g\n', cond (A));
-%!      # No preconditioner: the convergence is very slow!
+%!  N = 100;
+%!  A = zeros (N, N);
+%!  for i = 1 : N - 1 # form 1-D Laplacian matrix
+%!    A(i:i+1, i:i+1) = [2 -1; -1 2];
+%!  endfor
+%!  b = rand (N, 1);
+%!  X = A \ b;  # X is the true solution
+%!  maxit = 80;
+%!  printf ("System condition number is %g\n", cond (A));
+%!  # No preconditioner: the convergence is very slow!
 %!
-%!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit);
-%!      printf('System condition number estimate is %g\n', eigest(2) / eigest(1));
-%!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||)');
-%!      semilogy([0:iter], resvec(:,1), 'o-g');
-%!      legend('NO preconditioning: absolute residual');
-%!
-%!      pause(1);
-%!      # Test Jacobi preconditioner: it will not help much!!!
+%!  [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit);
+%!  printf ("System condition number estimate is %g\n", eigest(2) / eigest(1));
+%!  title ("Convergence history");
+%!  semilogy ([0:iter], resvec(:,1), "o-g");
+%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
+%!  legend ("NO preconditioning: absolute residual");
 %!
-%!      M = diag (diag (A)); # Jacobi preconditioner
-%!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
-%!      printf('JACOBI preconditioned system condition number estimate is %g\n', eigest(2) / eigest(1));
-%!      hold on;
-%!      semilogy([0:iter], resvec(:,1), 'o-r');
-%!      legend('NO preconditioning: absolute residual', ...
-%!             'JACOBI preconditioner: absolute residual');
+%!  pause (1);
+%!  # Test Jacobi preconditioner: it will not help much!!!
 %!
-%!      pause(1);
-%!      # Test nonoverlapping block Jacobi preconditioner: it will help much!
+%!  M = diag (diag (A)); # Jacobi preconditioner
+%!  [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
+%!  printf ("JACOBI preconditioned system condition number estimate is %g\n", eigest(2) / eigest(1));
+%!  hold on;
+%!  semilogy ([0:iter], resvec(:,1), "o-r");
+%!  legend ("NO preconditioning: absolute residual", ...
+%!          "JACOBI preconditioner: absolute residual");
+%!
+%!  pause (1);
+%!  # Test nonoverlapping block Jacobi preconditioner: it will help much!
 %!
-%!      M = zeros (N, N); k = 4;
-%!      for i = 1 : k : N # form 1-D Laplacian matrix
-%!              M (i:i+k-1, i:i+k-1) = A (i:i+k-1, i:i+k-1);
-%!      endfor
-%!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
-%!      printf('BLOCK JACOBI preconditioned system condition number estimate is %g\n', eigest(2) / eigest(1));
-%!      semilogy ([0:iter], resvec(:,1),'o-b');
-%!      legend('NO preconditioning: absolute residual', ...
-%!             'JACOBI preconditioner: absolute residual', ...
-%!             'BLOCK JACOBI preconditioner: absolute residual');
-%!      hold off;
+%!  M = zeros (N, N); k = 4;
+%!  for i = 1 : k : N # form 1-D Laplacian matrix
+%!    M(i:i+k-1, i:i+k-1) = A(i:i+k-1, i:i+k-1);
+%!  endfor
+%!  [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], maxit, M);
+%!  printf ("BLOCK JACOBI preconditioned system condition number estimate is %g\n", eigest(2) / eigest(1));
+%!  semilogy ([0:iter], resvec(:,1), "o-b");
+%!  legend ("NO preconditioning: absolute residual", ...
+%!          "JACOBI preconditioner: absolute residual", ...
+%!          "BLOCK JACOBI preconditioner: absolute residual");
+%!  hold off;
+
 %!test
-%!
-%!      #solve small diagonal system
+%! # solve small diagonal system
 %!
-%!      N = 10;
-%!      A = diag ([1:N]); b = rand (N, 1); X = A \ b; #X is the true solution
-%!      [x, flag] = pcg (A, b, [], N+1);
-%!      assert(norm (x - X) / norm (X), 0, 1e-10);
-%!      assert(flag, 0);
-%!
+%! N = 10;
+%! A = diag ([1:N]); b = rand (N, 1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag] = pcg (A, b, [], N+1);
+%! assert (norm (x - X) / norm (X), 0, 1e-10);
+%! assert (flag, 0);
+
 %!test
+%! # solve small indefinite diagonal system
+%! # despite A is indefinite, the iteration continues and converges
+%! # indefiniteness of A is detected
 %!
-%!      #solve small indefinite diagonal system
-%!      #despite A is indefinite, the iteration continues and converges
-%!      #indefiniteness of A is detected
-%!
-%!      N = 10;
-%!      A = diag([1:N] .* (-ones(1, N) .^ 2)); b = rand (N, 1); X = A \ b; #X is the true solution
-%!      [x, flag] = pcg (A, b, [], N+1);
-%!      assert(norm (x - X) / norm (X), 0, 1e-10);
-%!      assert(flag, 3);
-%!
+%! N = 10;
+%! A = diag([1:N] .* (-ones(1, N) .^ 2)); b = rand (N, 1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag] = pcg (A, b, [], N+1);
+%! assert (norm (x - X) / norm (X), 0, 1e-10);
+%! assert (flag, 3);
+
 %!test
-%!
-%!      #solve tridiagonal system, do not converge in default 20 iterations
+%! # solve tridiagonal system, do not converge in default 20 iterations
 %!
-%!      N = 100;
-%!      A = zeros (N, N);
-%!      for i = 1 : N - 1 # form 1-D Laplacian matrix
-%!              A (i:i+1, i:i+1) = [2 -1; -1 2];
-%!      endfor
-%!      b = ones (N, 1); X = A \ b; #X is the true solution
-%!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, 1e-12);
-%!      assert(flag);
-%!      assert(relres > 1.0);
-%!      assert(iter, 20); #should perform max allowable default number of iterations
-%!
+%! N = 100;
+%! A = zeros (N, N);
+%! for i = 1 : N - 1 # form 1-D Laplacian matrix
+%!   A(i:i+1, i:i+1) = [2 -1; -1 2];
+%! endfor
+%! b = ones (N, 1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, 1e-12);
+%! assert (flag);
+%! assert (relres > 1.0);
+%! assert (iter, 20); # should perform max allowable default number of iterations
+
 %!test
+%! # solve tridiagonal system with 'perfect' preconditioner
+%! # which converges in one iteration, so the eigest does not
+%! # work and issues a warning
 %!
-%!      #solve tridiagonal system with 'prefect' preconditioner
-%!      #converges in one iteration, so the eigest does not work
-%!      #and issues a warning
-%!
-%!      N = 100;
-%!      A = zeros (N, N);
-%!      for i = 1 : N - 1 # form 1-D Laplacian matrix
-%!              A (i:i+1, i:i+1) = [2 -1; -1 2];
-%!      endfor
-%!      b = ones (N, 1); X = A \ b; #X is the true solution
-%!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], [], A, [], b);
-%!      assert(norm (x - X) / norm (X), 0, 1e-6);
-%!      assert(flag, 0);
-%!      assert(iter, 1); #should converge in one iteration
-%!      assert(isnan (eigest), isnan ([NaN, NaN]));
-%!
+%! N = 100;
+%! A = zeros (N, N);
+%! for i = 1 : N - 1 # form 1-D Laplacian matrix
+%!         A (i:i+1, i:i+1) = [2 -1; -1 2];
+%! endfor
+%! b = ones (N, 1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], [], A, [], b);
+%! assert (norm (x - X) / norm (X), 0, 1e-6);
+%! assert (flag, 0);
+%! assert (iter, 1); # should converge in one iteration
+%! assert (isnan (eigest), isnan ([NaN, NaN]));
+
diff --git a/scripts/sparse/pcr.m b/scripts/sparse/pcr.m
--- a/scripts/sparse/pcr.m
+++ b/scripts/sparse/pcr.m
@@ -105,17 +105,17 @@
 ##      A = sparse (diag (1:n));
 ##      b = rand (N, 1);
 ## @end group
 ## @end example
 ##
 ## @sc{Example 1:} Simplest use of @code{pcr}
 ##
 ## @example
-##   x = pcr(A, b)
+##   x = pcr (A, b)
 ## @end example
 ##
 ## @sc{Example 2:} @code{pcr} with a function which computes
 ## @code{@var{A} * @var{x}}.
 ##
 ## @example
 ## @group
 ##   function y = apply_a (x)
@@ -295,137 +295,148 @@ function [x, flag, relres, iter, resvec]
     if (nargout < 2)
       warning ("pcr: breakdown occurred:\n");
       warning ("system matrix singular or preconditioner indefinite?\n");
     endif
   endif
 
 endfunction
 
+
 %!demo
-%!
-%!      # Simplest usage of PCR (see also 'help pcr')
+%!  # Simplest usage of PCR (see also 'help pcr')
 %!
-%!      N = 20;
-%!      A = diag(linspace(-3.1,3,N)); b = rand(N,1); y = A\b; #y is the true solution
-%!      x = pcr(A,b);
-%!      printf('The solution relative error is %g\n', norm(x-y)/norm(y));
-%!
-%!      # You shouldn't be afraid if PCR issues some warning messages in this
-%!      # example: watch out in the second example, why it takes N iterations
-%!      # of PCR to converge to (a very accurate, by the way) solution
-%!demo
+%!  N = 20;
+%!  A = diag (linspace (-3.1,3,N)); b = rand (N,1);
+%!  y = A \ b;  # y is the true solution
+%!  x = pcr (A,b);
+%!  printf ("The solution relative error is %g\n", norm (x-y) / norm (y));
 %!
-%!      # Full output from PCR
-%!      # We use this output to plot the convergence history
+%!  # You shouldn't be afraid if PCR issues some warning messages in this
+%!  # example: watch out in the second example, why it takes N iterations
+%!  # of PCR to converge to (a very accurate, by the way) solution
+
+%!demo
+%!  # Full output from PCR
+%!  # We use this output to plot the convergence history
 %!
-%!      N = 20;
-%!      A = diag(linspace(-3.1,30,N)); b = rand(N,1); X = A\b; #X is the true solution
-%!      [x, flag, relres, iter, resvec] = pcr(A,b);
-%!      printf('The solution relative error is %g\n', norm(x-X)/norm(X));
-%!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||/||b||)');
-%!      semilogy([0:iter],resvec/resvec(1),'o-g;relative residual;');
+%!  N = 20;
+%!  A = diag (linspace(-3.1,30,N)); b = rand (N,1);
+%!  X = A \ b;  # X is the true solution
+%!  [x, flag, relres, iter, resvec] = pcr (A,b);
+%!  printf ("The solution relative error is %g\n", norm (x-X) / norm (X));
+%!  clf;
+%!  title ("Convergence history");
+%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||/||b||)");
+%!  semilogy ([0:iter], resvec/resvec(1), "o-g;relative residual;");
+
 %!demo
-%!
-%!      # Full output from PCR
-%!      # We use indefinite matrix based on the Hilbert matrix, with one
-%!      # strongly negative eigenvalue
-%!      # Hilbert matrix is extremely ill conditioned, so is ours,
-%!      # and that's why PCR WILL have problems
+%!  # Full output from PCR
+%!  # We use indefinite matrix based on the Hilbert matrix, with one
+%!  # strongly negative eigenvalue
+%!  # Hilbert matrix is extremely ill conditioned, so is ours,
+%!  # and that's why PCR WILL have problems
 %!
-%!      N = 10;
-%!      A = hilb(N); A(1,1)=-A(1,1); b = rand(N,1); X = A\b; #X is the true solution
-%!      printf('Condition number of A is   %g\n', cond(A));
-%!      [x, flag, relres, iter, resvec] = pcr(A,b,[],200);
-%!      if (flag == 3)
-%!        printf('PCR breakdown. System matrix is [close to] singular\n');
-%!      end
-%!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||)');
-%!      semilogy([0:iter],resvec,'o-g;absolute residual;');
+%!  N = 10;
+%!  A = hilb (N); A(1,1) = -A(1,1); b = rand (N,1);
+%!  X = A \ b;  # X is the true solution
+%!  printf ("Condition number of A is   %g\n", cond (A));
+%!  [x, flag, relres, iter, resvec] = pcr (A,b,[],200);
+%!  if (flag == 3)
+%!    printf ("PCR breakdown.  System matrix is [close to] singular\n");
+%!  end
+%!  clf;
+%!  title ("Convergence history");
+%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
+%!  semilogy ([0:iter], resvec, "o-g;absolute residual;");
+
 %!demo
+%!  # Full output from PCR
+%!  # We use an indefinite matrix based on the 1-D Laplacian matrix for A,
+%!  # and here we have cond(A) = O(N^2)
+%!  # That's the reason we need some preconditioner; here we take
+%!  # a very simple and not powerful Jacobi preconditioner,
+%!  # which is the diagonal of A
 %!
-%!      # Full output from PCR
-%!      # We use an indefinite matrix based on the 1-D Laplacian matrix for A,
-%!      # and here we have cond(A) = O(N^2)
-%!      # That's the reason we need some preconditioner; here we take
-%!      # a very simple and not powerful Jacobi preconditioner,
-%!      # which is the diagonal of A
-%!
-%!      # Note that we use here indefinite preconditioners!
+%!  # Note that we use here indefinite preconditioners!
 %!
-%!      N = 100;
-%!      A = zeros(N,N);
-%!      for i=1:N-1 # form 1-D Laplacian matrix
-%!              A(i:i+1,i:i+1) = [2 -1; -1 2];
-%!      endfor
-%!      A = [A, zeros(size(A)); zeros(size(A)), -A];
-%!      b = rand(2*N,1); X = A\b; #X is the true solution
-%!      maxit = 80;
-%!      printf('System condition number is %g\n',cond(A));
-%!      # No preconditioner: the convergence is very slow!
+%!  N = 100;
+%!  A = zeros (N,N);
+%!  for i=1:N-1 # form 1-D Laplacian matrix
+%!    A(i:i+1,i:i+1) = [2 -1; -1 2];
+%!  endfor
+%!  A = [A, zeros(size(A)); zeros(size(A)), -A];
+%!  b = rand (2*N,1);
+%!  X = A \ b;  # X is the true solution
+%!  maxit = 80;
+%!  printf ("System condition number is %g\n", cond (A));
+%!  # No preconditioner: the convergence is very slow!
 %!
-%!      [x, flag, relres, iter, resvec] = pcr(A,b,[],maxit);
-%!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||)');
-%!      semilogy([0:iter],resvec,'o-g;NO preconditioning: absolute residual;');
-%!
-%!      pause(1);
-%!      # Test Jacobi preconditioner: it will not help much!!!
+%!  [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit);
+%!  clf;
+%!  title ("Convergence history");
+%!  xlabel ("Iteration"); ylabel ("log(||b-Ax||)");
+%!  semilogy ([0:iter], resvec, "o-g;NO preconditioning: absolute residual;");
 %!
-%!      M = diag(diag(A)); # Jacobi preconditioner
-%!      [x, flag, relres, iter, resvec] = pcr(A,b,[],maxit,M);
-%!      hold on;
-%!      semilogy([0:iter],resvec,'o-r;JACOBI preconditioner: absolute residual;');
+%!  pause (1);
+%!  # Test Jacobi preconditioner: it will not help much!!!
 %!
-%!      pause(1);
-%!      # Test nonoverlapping block Jacobi preconditioner: this one should give
-%!      # some convergence speedup!
+%!  M = diag (diag (A)); # Jacobi preconditioner
+%!  [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit,M);
+%!  hold on;
+%!  semilogy ([0:iter],resvec,"o-r;JACOBI preconditioner: absolute residual;");
 %!
-%!      M = zeros(N,N);k=4;
-%!      for i=1:k:N # get k x k diagonal blocks of A
-%!              M(i:i+k-1,i:i+k-1) = A(i:i+k-1,i:i+k-1);
-%!      endfor
-%!      M = [M, zeros(size(M)); zeros(size(M)), -M];
-%!      [x, flag, relres, iter, resvec] = pcr(A,b,[],maxit,M);
-%!      semilogy([0:iter],resvec,'o-b;BLOCK JACOBI preconditioner: absolute residual;');
-%!      hold off;
+%!  pause (1);
+%!  # Test nonoverlapping block Jacobi preconditioner: this one should give
+%!  # some convergence speedup!
+%!
+%!  M = zeros (N,N); k = 4;
+%!  for i=1:k:N # get k x k diagonal blocks of A
+%!    M(i:i+k-1,i:i+k-1) = A(i:i+k-1,i:i+k-1);
+%!  endfor
+%!  M = [M, zeros(size (M)); zeros(size(M)), -M];
+%!  [x, flag, relres, iter, resvec] = pcr (A,b,[],maxit,M);
+%!  semilogy ([0:iter], resvec, "o-b;BLOCK JACOBI preconditioner: absolute residual;");
+%!  hold off;
+
 %!test
-%!
-%!      #solve small indefinite diagonal system
-%!
-%!      N = 10;
-%!      A = diag(linspace(-10.1,10,N)); b = ones(N,1); X = A\b; #X is the true solution
-%!      [x, flag] = pcr(A,b,[],N+1);
-%!      assert(norm(x-X)/norm(X)<1e-10);
-%!      assert(flag,0);
+%! # solve small indefinite diagonal system
 %!
-%!test
-%!
-%!      #solve tridiagonal system, do not converge in default 20 iterations
-%!      #should perform max allowable default number of iterations
-%!
-%!      N = 100;
-%!      A = zeros(N,N);
-%!      for i=1:N-1 # form 1-D Laplacian matrix
-%!              A(i:i+1,i:i+1) = [2 -1; -1 2];
-%!      endfor
-%!      b = ones(N,1); X = A\b; #X is the true solution
-%!      [x, flag, relres, iter, resvec] = pcr(A,b,1e-12);
-%!      assert(flag,1);
-%!      assert(relres>0.6);
-%!      assert(iter,20);
-%!
+%! N = 10;
+%! A = diag (linspace (-10.1,10,N)); b = ones (N,1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag] = pcr (A,b,[],N+1);
+%! assert (norm (x-X) / norm (X) < 1e-10);
+%! assert (flag, 0);
+
 %!test
-%!
-%!      #solve tridiagonal system with 'prefect' preconditioner
-%!      #converges in one iteration
+%! # solve tridiagonal system, do not converge in default 20 iterations
+%! # should perform max allowable default number of iterations
 %!
-%!      N = 100;
-%!      A = zeros(N,N);
-%!      for i=1:N-1 # form 1-D Laplacian matrix
-%!              A(i:i+1,i:i+1) = [2 -1; -1 2];
-%!      endfor
-%!      b = ones(N,1); X = A\b; #X is the true solution
-%!      [x, flag, relres, iter] = pcr(A,b,[],[],A,b);
-%!      assert(norm(x-X)/norm(X)<1e-6);
-%!      assert(relres<1e-6);
-%!      assert(flag,0);
-%!      assert(iter,1); #should converge in one iteration
+%! N = 100;
+%! A = zeros (N,N);
+%! for i=1:N-1 # form 1-D Laplacian matrix
+%!   A(i:i+1,i:i+1) = [2 -1; -1 2];
+%! endfor
+%! b = ones (N,1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag, relres, iter, resvec] = pcr (A,b,1e-12);
+%! assert (flag, 1);
+%! assert (relres > 0.6);
+%! assert (iter, 20);
+
+%!test
+%! # solve tridiagonal system with "perfect" preconditioner
+%! # converges in one iteration
 %!
+%! N = 100;
+%! A = zeros (N,N);
+%! for i=1:N-1 # form 1-D Laplacian matrix
+%!   A(i:i+1,i:i+1) = [2 -1; -1 2];
+%! endfor
+%! b = ones (N,1);
+%! X = A \ b;  # X is the true solution
+%! [x, flag, relres, iter] = pcr (A,b,[],[],A,b);
+%! assert (norm (x-X) / norm(X) < 1e-6);
+%! assert (relres < 1e-6);
+%! assert (flag, 0);
+%! assert (iter, 1); # should converge in one iteration
+
diff --git a/scripts/sparse/treeplot.m b/scripts/sparse/treeplot.m
--- a/scripts/sparse/treeplot.m
+++ b/scripts/sparse/treeplot.m
@@ -191,15 +191,19 @@ function treeplot (tree, node_style = "k
   unwind_protect_cleanup
     if (! hold_is_on)
       hold ("off");
     endif
   end_unwind_protect
 
 endfunction
 
-%!demo
-%! % Plot a simple tree plot
-%! treeplot([2 4 2 0 6 4 6])
 
 %!demo
+%! clf;
+%! treeplot ([2 4 2 0 6 4 6]);
+%! % Plot a simple tree plot
+
+%!demo
+%! clf;
+%! treeplot ([2 4 2 0 6 4 6], "b+", "g");
 %! % Plot a simple tree plot defining the edge and node styles
-%! treeplot([2 4 2 0 6 4 6], "b+", "g")
+
diff --git a/scripts/strings/strtok.m b/scripts/strings/strtok.m
--- a/scripts/strings/strtok.m
+++ b/scripts/strings/strtok.m
@@ -128,17 +128,17 @@ function [tok, rem] = strtok (str, delim
       rem(midx) = tmp(2:2:end);
     endif
   endif
 
 endfunction
 
 
 %!demo
-%! strtok("this is the life")
+%! strtok ("this is the life")
 %! % split at the first space, returning "this"
 
 %!demo
 %! s = "14*27+31"
 %! while (1)
 %!   [t, s] = strtok (s, "+-*/");
 %!   printf ("<%s>", t);
 %!   if (isempty (s))
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -30,18 +30,19 @@
 ## separate from regular script code, all lines are prefixed by @code{%!}.  Each
 ## example must also be introduced by the keyword 'demo' flush left to the
 ## prefix with no intervening spaces.  The remainder of the example can
 ## contain arbitrary Octave code.  For example:
 ##
 ## @example
 ## @group
 ##   %!demo
-##   %! t=0:0.01:2*pi; x = sin(t);
-##   %! plot (t,x)
+##   %! t = 0:0.01:2*pi;
+##   %! x = sin (t);
+##   %! plot (t,x);
 ##   %! %-------------------------------------------------
 ##   %! % the figure window shows one cycle of a sine wave
 ## @end group
 ## @end example
 ##
 ## Note that the code is displayed before it is executed, so a simple
 ## comment at the end suffices for labeling what is being shown.  It is
 ## generally not necessary to use @code{disp} or @code{printf} within the demo.
@@ -139,16 +140,18 @@ function demo (name, n)
       ## Let the programmer know which demo failed.
       printf ("%s example %d: failed\n%s\n", name, doidx(i), lasterr ());
     end_try_catch
     clear __demo__;
   endfor
 
 endfunction
 
+
 %!demo
-%! t=0:0.01:2*pi; x = sin(t);
-%! plot (t,x)
+%! t = 0:0.01:2*pi;
+%! x = sin (t);
+%! plot (t,x);
 %! %-------------------------------------------------
 %! % the figure window shows one cycle of a sine wave
 
 %!error demo ();
 %!error demo (1, 2, 3);
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -79,26 +79,28 @@ function [code_r, idx_r] = example (name
       block = code(idx(doidx(i)):idx(doidx(i)+1)-1);
       printf ("%s example %d:%s\n\n", name, doidx(i), block);
     endfor
   endif
 
 endfunction
 
 
-%!## warning: don't modify the demos without modifying the tests!
+## WARNING: don't modify the demos without modifying the tests!
 %!demo
 %! example ('example');
+
 %!demo
+%! clf;
 %! t=0:0.01:2*pi; x = sin(t);
 %! plot (t,x)
 
 %!assert (example('example',1), "\n example ('example');");
 %!test
 %! [code, idx] = example ('example');
 %! assert (code, ...
-%!         "\n example ('example');\n t=0:0.01:2*pi; x = sin(t);\n plot (t,x)")
-%! assert (idx, [1, 23, 63]);
+%!         "\n example ('example');\n clf;\n t=0:0.01:2*pi; x = sin(t);\n plot (t,x)")
+%! assert (idx, [1, 23, 69]);
 
 %% Test input validation
 %!error example
 %!error example ('example', 3, 5)
 
diff --git a/scripts/testfun/rundemos.m b/scripts/testfun/rundemos.m
--- a/scripts/testfun/rundemos.m
+++ b/scripts/testfun/rundemos.m
@@ -82,9 +82,11 @@ function retval = has_demos (f)
   else
     str = fscanf (fid, "%s");
     fclose (fid);
     retval = strfind (str, "%!demo");
   endif
 endfunction
 
 
-%!error rundemos ("foo", 1);
+%!error rundemos ("foo", 1)
+%!error <DIRECTORY argument> rundemos ("#_TOTALLY_/_INVALID_/_PATHNAME_#")
+
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -352,54 +352,55 @@ endfunction
 
 %% FIXME: Demos with declared functions do not work.  See bug #31815.
 %%        A workaround has been hacked by not declaring the functions
 %%        but using eval to create them in the proper context.
 %%        Unfortunately, we can't remove them from the user's workspace
 %%        because of another bug (#34497).
 %!demo
 %!  fstr_build_orig = cstrcat (
-%!  "function x = build_orig (n)\n",
-%!  "  ## extend the target vector on the fly\n",
-%!  "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
-%!  "endfunction");
+%!    "function x = build_orig (n)\n",
+%!    "  ## extend the target vector on the fly\n",
+%!    "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
+%!    "endfunction");
 %!  fstr_build = cstrcat (
-%!  "function x = build (n)\n",
-%!  "  ## preallocate the target vector\n",
-%!  "  x = zeros (1, n*100);\n",
-%!  "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
-%!  "endfunction");
+%!    "function x = build (n)\n",
+%!    "  ## preallocate the target vector\n",
+%!    "  x = zeros (1, n*100);\n",
+%!    "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
+%!    "endfunction");
 %!
 %!  disp ("-----------------------");
 %!  disp (fstr_build_orig);
 %!  disp ("-----------------------");
 %!  disp (fstr_build);
 %!  disp ("-----------------------");
 %!
 %!  ## Eval functions strings to create them in the current context
 %!  eval (fstr_build_orig);
 %!  eval (fstr_build);
 %!
 %!  disp ("Preallocated vector test.\nThis takes a little while...");
 %!  speed("build (n)", "", 1000, "build_orig (n)");
 %!  clear -f build build_orig
+%!  disp ("-----------------------");
 %!  disp ("Note how much faster it is to pre-allocate a vector.");
 %!  disp ("Notice the peak speedup ratio.");
 
 %!demo
 %!  fstr_build_orig = cstrcat (
-%!  "function x = build_orig (n)\n",
-%!  "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
-%!  "endfunction");
+%!    "function x = build_orig (n)\n",
+%!    "  for i=0:n-1, x([1:100]+i*100) = 1:100; endfor\n",
+%!    "endfunction");
 %!  fstr_build = cstrcat (
-%!  "function x = build (n)\n",
-%!  "  idx = [1:100]';\n",
-%!  "  x = idx(:,ones(1,n));\n",
-%!  "  x = reshape (x, 1, n*100);\n",
-%!  "endfunction");
+%!    "function x = build (n)\n",
+%!    "  idx = [1:100]';\n",
+%!    "  x = idx(:,ones(1,n));\n",
+%!    "  x = reshape (x, 1, n*100);\n",
+%!    "endfunction");
 %!
 %!  disp ("-----------------------");
 %!  disp (fstr_build_orig);
 %!  disp ("-----------------------");
 %!  disp (fstr_build);
 %!  disp ("-----------------------");
 %!
 %!  ## Eval functions strings to create them in the current context
@@ -420,17 +421,18 @@ endfunction
 %! assert (fieldnames (order), {"p"; "a"});
 %! assert (isnumeric (n));
 %! assert (length (n) > 10);
 %! assert (isnumeric (T_f1));
 %! assert (size (T_f1), size (n));
 %! assert (isnumeric (T_f2));
 %! assert (length (T_f2) > 10);
 
-%% This test is known to fail on operating systems with low resolution timers such as MinGW
+%% This test is known to fail on operating systems with low resolution timers
+%% such as MinGW
 %!xtest
 %! [order, n, T_f1, T_f2] = speed ("sum (x)", "", [100, 1000], "v = 0; for i = 1:length (x), v += x(i); endfor");
 %! assert (isstruct (order));
 %! assert (size (order), [1, 1]);
 %! assert (fieldnames (order), {"p"; "a"});
 %! assert (isnumeric (n));
 %! assert (length (n) > 10);
 %! assert (isnumeric (T_f1));
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -800,25 +800,25 @@ endfunction
 %! assert(x,6);
 %! assert(z,9);
 
 %!## test of assert block
 %!assert (isempty([]))      # support for test assert shorthand
 
 %!## demo blocks
 %!demo                   # multiline demo block
-%! t=[0:0.01:2*pi]; x=sin(t);
-%! plot(t,x);
+%! t = [0:0.01:2*pi]; x = sin (t);
+%! plot (t,x);
 %! % you should now see a sine wave in your figure window
 %!demo a=3               # single line demo blocks work too
 
 %!## this is a comment block. it can contain anything.
 %!##
 %! it is the "#" as the block type that makes it a comment
-%! and it  stays as a comment even through continuation lines
+%! and it stays as a comment even through continuation lines
 %! which means that it works well with commenting out whole tests
 
 % !# failure tests.  All the following should fail. These tests should
 % !# be disabled unless you are developing test() since users don't
 % !# like to be presented with expected failures.  I use % ! to disable.
 % !test   error("---------Failure tests.  Use test('test','verbose',1)");
 % !test   assert([a,b,c],[1,3,6]);   # variables have wrong values
 % !bogus                     # unknown block type
@@ -833,8 +833,9 @@ endfunction
 % !demo                      # shared variables not available in demo
 % ! assert(exist("a"))
 % !error
 % ! test('/etc/passwd');
 % ! test("nonexistent file");
 % ! ## These don't signal an error, so the test for an error fails. Note
 % ! ## that the call doesn't reference the current fid (it is unavailable),
 % ! ## so of course the informational message is not printed in the log.
+
diff --git a/scripts/time/calendar.m b/scripts/time/calendar.m
--- a/scripts/time/calendar.m
+++ b/scripts/time/calendar.m
@@ -83,22 +83,22 @@ function varargout = calendar (varargin)
     puts (strftime ("                    %b %Y\n", s));
     puts ("     S     M    Tu     W    Th     F     S\n");
     puts (str);
   endif
 
 endfunction
 
 
-## demos
 %!demo
 %! ## Calendar for current month
 %! calendar ()
+
 %!demo
+%! ## Calendar for October, 1957
 %! calendar (1957, 10)
 
-## tests
 %!assert ((calendar(2000,2))'(2:31), [0:29])
 %!assert ((calendar(1957,10))'(2:33), [0:31])
 
 %% Test input validation
 %!error calendar (1,2,3)
 
diff --git a/scripts/time/datestr.m b/scripts/time/datestr.m
--- a/scripts/time/datestr.m
+++ b/scripts/time/datestr.m
@@ -276,23 +276,24 @@ function retval = datestr (date, f = [],
 
     retval = [retval; str];
 
   endfor
 
 endfunction
 
 
-## demos
 %!demo
 %! ## Current date and time in default format
 %! datestr (now ())
+
 %!demo
 %! ## Current date (integer portion of datenum)
 %! datestr (fix (now ()))
+
 %!demo
 %! ## Current time (fractional portion of datenum)
 %! datestr (rem (now (), 1))
 
 %!shared testtime
 %! testtime = [2005.0000, 12.0000, 18.0000, 2.0000, 33.0000, 17.3822];
 %!assert (datestr (testtime,0), "18-Dec-2005 02:33:17")
 %!assert (datestr (testtime,1), "18-Dec-2005")
@@ -330,8 +331,9 @@ endfunction
 ## Test possible bug where input is a vector of datenums that is exactly 6 wide
 %!assert (datestr ([1944, 6, 6, 6, 30, 0], 0), "06-Jun-1944 06:30:00")
 ## Test fractional millisecond time extension
 %!assert (datestr (testtime, "HH:MM:SS:FFF"), "02:33:17:382")
 
 %% Test input validation
 %!error datestr ()
 %!error datestr (1, 2, 3, 4)
+
diff --git a/scripts/time/datetick.m b/scripts/time/datetick.m
--- a/scripts/time/datetick.m
+++ b/scripts/time/datetick.m
@@ -41,36 +41,39 @@ function datetick (varargin)
     axes (h);
     __datetick__ (varargin{:});
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
 endfunction
 
+
 %!demo
+%! clf;
 %! yr = 1900:10:2000;
 %! pop = [76.094, 92.407, 106.461, 123.077 131.954, 151.868, 179.979, ...
 %!        203.984, 227.225, 249.623, 282.224];
 %! plot (datenum (yr, 1, 1), pop);
 %! title ("US population (millions)");
 %! xlabel ("Year");
 %! datetick ("x", "YYYY");
 
 %!demo
-%! yr =1988:2:2002;
-%! yr =datenum(yr,1,1);
+%! clf;
+%! yr = 1988:2:2002;
+%! yr = datenum (yr,1,1);
 %! pr = [12.1 13.3 12.6 13.1 13.3 14.1 14.4 15.2];
-%! plot(yr,pr);
-%! xlabel('year')
-%! ylabel('average price')
-%! ax=gca;
-%! set(ax,'xtick',datenum(1990:5:2005,1,1))
-%! datetick(2,'keepticks')
-%! set(ax,'ytick',12:16)
+%! plot (yr, pr);
+%! xlabel ("year");
+%! ylabel ("average price");
+%! ax = gca ();
+%! set (ax, "xtick", datenum (1990:5:2005,1,1));
+%! datetick (2, "keepticks");
+%! set (ax, "ytick", 12:16);
 
 ## Remove from test statistics.  No real tests possible.
 %!assert (1)
 
 function __datetick__ (varargin)
 
   keeplimits = false;
   keepticks = false;
diff --git a/scripts/time/weekday.m b/scripts/time/weekday.m
--- a/scripts/time/weekday.m
+++ b/scripts/time/weekday.m
@@ -79,22 +79,24 @@ function [d, s] = weekday (d, format = "
   endif
 
 endfunction
 
 
 %!demo
 %! ## Current weekday
 %! [n, s] = weekday (now ())
+
 %!demo
 %! ## Weekday from datenum input
 %! [n, s] = weekday (728647)
+
 %!demo
 %! ## Weekday of new millennium from datestr input
-%! [n, s] = weekday ('1-Jan-2000')
+%! [n, s] = weekday ("1-Jan-2000")
 
 # tests
 %!assert (weekday (728647), 2)
 ## Test vector inputs for both directions
 %!assert (weekday ([728647 728648]), [2 3])
 %!assert (weekday ([728647;728648]), [2;3])
 ## Test a full week before our reference day
 %!assert (weekday ("19-Dec-1994"), 2)
