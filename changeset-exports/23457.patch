# HG changeset patch
# User Rik <rik@octave.org>
# Date 1493410752 25200
#      Fri Apr 28 13:19:12 2017 -0700
# Node ID 21baad6b35c4b4ea4dee7ebde6b89640c1b056f5
# Parent  a62ffdf1f432f1c2ec3ce21f23e95207fd49ea36
maint: Use C++11 nullptr rather than 0 or NULL when possible.

* FigureWindow.h, Logger.cc, Menu.cc, MouseModeActionGroup.h, Object.h,
ObjectFactory.cc, ObjectProxy.h, color-picker.h, documentation-dock-widget.h,
files-dock-widget.h, find-files-dialog.h, history-dock-widget.h,
file-editor-tab.cc, file-editor.cc, file-editor.h, find-dialog.h,
main-window.cc, main-window.h, octave-dock-widget.h, parser.cc, parser.h,
webinfo.h, resource-manager.cc, shortcut-manager.cc, shortcut-manager.h,
terminal-dock-widget.h, welcome-wizard.cc, welcome-wizard.h, workspace-model.h,
workspace-view.h, __magick_read__.cc, call-stack.cc, call-stack.h, cdisplay.c,
display.cc, dlmread.cc, dynamic-ld.cc, ft-text-renderer.cc, gl2ps-print.cc,
graphics.cc, graphics.in.h, input.h, interpreter.cc, interpreter.h, ls-hdf5.cc,
mex.cc, mxarray.in.h, oct-errno.in.cc, oct-fstrm.cc, oct-iostrm.h,
oct-procbuf.cc, oct-stdstrm.h, oct-stream.cc, oct-stream.h, octave-link.cc,
pager.cc, pr-output.cc, profiler.h, qz.cc, sighandlers.cc, strfns.cc,
symtab.cc, symtab.h, typecast.cc, urlwrite.cc, variables.cc, __eigs__.cc,
__init_fltk__.cc, __ode15__.cc, colamd.cc, ov-base-int.cc, ov-base.cc,
ov-bool-mat.cc, ov-bool-sparse.cc, ov-builtin.cc, ov-class.cc, ov-classdef.cc,
ov-complex.cc, ov-cx-diag.cc, ov-cx-mat.cc, ov-cx-sparse.cc, ov-fcn-handle.cc,
ov-fcn-inline.cc, ov-flt-complex.cc, ov-flt-cx-diag.cc, ov-flt-cx-mat.cc,
ov-flt-re-diag.cc, ov-flt-re-mat.cc, ov-java.cc, ov-java.h, ov-lazy-idx.cc,
ov-perm.cc, ov-range.cc, ov-re-diag.cc, ov-re-mat.cc, ov-re-sparse.cc,
ov-str-mat.cc, ov-struct.cc, ov-usr-fcn.h, octave.cc, octave.h, bp-table.cc,
jit-ir.cc, jit-ir.h, jit-typeinfo.cc, jit-typeinfo.h, lex.h, pt-arg-list.cc,
pt-arg-list.h, pt-array-list.h, pt-cell.h, pt-classdef.h, pt-colon.cc,
pt-decl.h, pt-eval.cc, pt-eval.h, pt-except.h, pt-idx.h, pt-jit.cc, pt-jit.h,
pt-loop.h, pt-mat.h, pt-select.h, pt.h, CSparse.cc, dSparse.cc, DASPK.cc,
DASRT.cc, DASSL.cc, oct-fftw.cc, oct-rand.cc, oct-spparms.cc, child-list.cc,
file-ops.cc, mach-info.cc, oct-env.cc, oct-time.cc, cmd-edit.cc, cmd-hist.cc,
oct-locbuf.cc, oct-shlib.cc, pathsearch.cc, singleton-cleanup.cc,
unwind-prot.h, url-transfer.cc:
Use C++11 nullptr rather than 0 or NULL when possible.

diff --git a/libgui/graphics/FigureWindow.h b/libgui/graphics/FigureWindow.h
--- a/libgui/graphics/FigureWindow.h
+++ b/libgui/graphics/FigureWindow.h
@@ -32,17 +32,17 @@ namespace QtHandles
 
   DECLARE_GENERICEVENTNOTIFY_SENDER(FigureWindowBase, QMainWindow);
 
   class FigureWindow : public FigureWindowBase
   {
     Q_OBJECT
 
   public:
-    FigureWindow (QWidget *parent = 0);
+    FigureWindow (QWidget *parent = nullptr);
     ~FigureWindow (void);
 
     QMenu * createPopupMenu (void);
   };
 
 }
 
 #endif
diff --git a/libgui/graphics/Logger.cc b/libgui/graphics/Logger.cc
--- a/libgui/graphics/Logger.cc
+++ b/libgui/graphics/Logger.cc
@@ -30,18 +30,18 @@ along with Octave; see the file COPYING.
 
 #include <cstdio>
 
 #include "Logger.h"
 
 namespace QtHandles
 {
 
-  Logger *Logger::s_instance = 0;
-  QMutex *Logger::s_mutex = 0;
+  Logger *Logger::s_instance = nullptr;
+  QMutex *Logger::s_mutex = nullptr;
 
   Logger::Logger (void)
     : m_debugEnabled (false)
   {
     QProcessEnvironment pe (QProcessEnvironment::systemEnvironment ());
 
     if (pe.value ("QTHANDLES_DEBUG", "0") != "0")
       m_debugEnabled = true;
diff --git a/libgui/graphics/Menu.cc b/libgui/graphics/Menu.cc
--- a/libgui/graphics/Menu.cc
+++ b/libgui/graphics/Menu.cc
@@ -120,17 +120,17 @@ namespace QtHandles
 
             up.get_property ("position").set
             (octave_value (static_cast<double> (count)), true, false);
           }
         else
           {
 
             int count = 0;
-            QAction *before = 0;
+            QAction *before = nullptr;
 
             foreach (QAction *a, m_parent->actions ())
               {
                 if (! a->isSeparator ())
                   {
                     count++;
                     if (pos <= count)
                       {
@@ -221,17 +221,17 @@ namespace QtHandles
       case uimenu::properties::ID_POSITION:
         {
           if (m_separator)
             m_parent->removeAction (m_separator);
 
           m_parent->removeAction (action);
 
           int pos = static_cast<int> (up.get_position ());
-          QAction *before = 0;
+          QAction *before = nullptr;
 
           if (pos > 0)
             {
               int count = 0;
 
               foreach (QAction *a, m_parent->actions ())
                 {
                   if (! a->isSeparator ())
diff --git a/libgui/graphics/MouseModeActionGroup.h b/libgui/graphics/MouseModeActionGroup.h
--- a/libgui/graphics/MouseModeActionGroup.h
+++ b/libgui/graphics/MouseModeActionGroup.h
@@ -33,17 +33,17 @@ class QAction;
 namespace QtHandles
 {
 
   class MouseModeActionGroup : public QObject
   {
     Q_OBJECT
 
   public:
-    MouseModeActionGroup (QObject *parent = 0);
+    MouseModeActionGroup (QObject *parent = nullptr);
     ~MouseModeActionGroup (void);
 
     QList<QAction*> actions (void) const { return m_actions; }
 
     void setMode (MouseMode mode);
 
   signals:
     void modeChanged (MouseMode mode);
diff --git a/libgui/graphics/Object.h b/libgui/graphics/Object.h
--- a/libgui/graphics/Object.h
+++ b/libgui/graphics/Object.h
@@ -37,17 +37,17 @@ namespace QtHandles
   class Container;
   class ObjectProxy;
 
   class Object : public QObject
   {
     Q_OBJECT
 
   public:
-    Object (const graphics_object& go, QObject *obj = 0);
+    Object (const graphics_object& go, QObject *obj = nullptr);
 
     virtual ~Object (void);
 
     base_properties& properties (void)
     { return object ().get_properties (); }
 
     const base_properties& properties (void) const
     { return object ().get_properties (); }
@@ -78,17 +78,17 @@ namespace QtHandles
     static Object * fromQObject (QObject *obj);
 
   public slots:
     void slotUpdate (int pId);
     void slotFinalize (void);
     void slotRedraw (void);
     void slotPrint (const QString& file_cmd, const QString& term);
 
-    void objectDestroyed (QObject *obj = 0);
+    void objectDestroyed (QObject *obj = nullptr);
 
   protected:
     static Object * parentObject (const graphics_object& go);
     void init (QObject *obj, bool callBase = false);
 
     virtual void update (int pId);
     virtual void finalize (void);
     virtual void redraw (void);
diff --git a/libgui/graphics/ObjectFactory.cc b/libgui/graphics/ObjectFactory.cc
--- a/libgui/graphics/ObjectFactory.cc
+++ b/libgui/graphics/ObjectFactory.cc
@@ -87,17 +87,17 @@ namespace QtHandles
             ObjectProxy *proxy = Backend::toolkitObjectProxy (go);
 
             if (proxy)
               {
                 Logger::debug ("ObjectFactory::createObject: "
                                "create %s from thread %08x",
                                go.type ().c_str (), QThread::currentThreadId ());
 
-                Object *obj = 0;
+                Object *obj = nullptr;
 
                 if (go.isa ("figure"))
                   obj = Figure::create (go);
                 else if (go.isa ("uicontrol"))
                   {
                     uicontrol::properties& up =
                       Utils::properties<uicontrol> (go);
 
diff --git a/libgui/graphics/ObjectProxy.h b/libgui/graphics/ObjectProxy.h
--- a/libgui/graphics/ObjectProxy.h
+++ b/libgui/graphics/ObjectProxy.h
@@ -32,17 +32,17 @@ namespace QtHandles
 
   class Object;
 
   class ObjectProxy : public QObject
   {
     Q_OBJECT
 
   public:
-    ObjectProxy (Object *obj = 0);
+    ObjectProxy (Object *obj = nullptr);
 
     void update (int pId);
     void finalize (void);
     void redraw (void);
     void print (const QString& file_cmd, const QString& term);
 
     Object * object (void) { return m_object; }
     void setObject (Object *obj);
diff --git a/libgui/src/color-picker.h b/libgui/src/color-picker.h
--- a/libgui/src/color-picker.h
+++ b/libgui/src/color-picker.h
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include <QPushButton>
 #include <QColorDialog>
 
 class color_picker: public QPushButton
 {
   Q_OBJECT
 
 public:
-  color_picker (QColor color = QColor (0,0,0), QWidget *parent = 0);
+  color_picker (QColor color = QColor (0,0,0), QWidget *parent = nullptr);
   QColor color () const { return _color; }
 
 private slots:
   void select_color ();
 
 private:
   virtual void update_button ();
   QColor _color;
diff --git a/libgui/src/documentation-dock-widget.h b/libgui/src/documentation-dock-widget.h
--- a/libgui/src/documentation-dock-widget.h
+++ b/libgui/src/documentation-dock-widget.h
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include "webinfo.h"
 
 class documentation_dock_widget : public octave_dock_widget
 {
   Q_OBJECT
 
 public:
 
-  documentation_dock_widget (QWidget *parent = 0);
+  documentation_dock_widget (QWidget *parent = nullptr);
 
 public slots:
 
   void notice_settings (const QSettings *settings);
 
 protected slots:
   void copyClipboard ();
   void pasteClipboard ();
diff --git a/libgui/src/files-dock-widget.h b/libgui/src/files-dock-widget.h
--- a/libgui/src/files-dock-widget.h
+++ b/libgui/src/files-dock-widget.h
@@ -45,17 +45,17 @@ along with Octave; see the file COPYING.
    @brief Dock widget to display files in the current directory.
 */
 class files_dock_widget : public octave_dock_widget
 {
   Q_OBJECT
 
 public:
 
-  files_dock_widget (QWidget *parent = 0);
+  files_dock_widget (QWidget *parent = nullptr);
 
   ~files_dock_widget (void) = default;
 
 public slots:
 
   /** Slot for handling a change in directory via double click. */
   void item_double_clicked (const QModelIndex & index);
 
diff --git a/libgui/src/find-files-dialog.h b/libgui/src/find-files-dialog.h
--- a/libgui/src/find-files-dialog.h
+++ b/libgui/src/find-files-dialog.h
@@ -33,17 +33,17 @@ class QTimer;
 class QDirIterator;
 class QCheckBox;
 class QStatusBar;
 
 class find_files_dialog : public QDialog
 {
   Q_OBJECT
 public:
-  find_files_dialog (QWidget *parent = 0);
+  find_files_dialog (QWidget *parent = nullptr);
   virtual ~find_files_dialog ();
   void save_settings (void);
 
 signals:
   void file_selected (const QString& fileName);
   void dir_selected (const QString& fileName);
 
 public slots:
diff --git a/libgui/src/history-dock-widget.h b/libgui/src/history-dock-widget.h
--- a/libgui/src/history-dock-widget.h
+++ b/libgui/src/history-dock-widget.h
@@ -33,17 +33,17 @@ along with Octave; see the file COPYING.
 #include "octave-dock-widget.h"
 
 class history_dock_widget : public octave_dock_widget
 {
   Q_OBJECT
 
 public:
 
-  history_dock_widget (QWidget *parent = 0);
+  history_dock_widget (QWidget *parent = nullptr);
   ~history_dock_widget (void) = default;
 
 public slots:
 
   void set_history (const QStringList& hist);
   void append_history (const QString& hist_entry);
   void clear_history (void);
   void save_settings (void);
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -2563,17 +2563,17 @@ file_editor_tab::do_breakpoint_marker (b
   if (ID != this || ID == 0)
     return;
 
   if (line > 0)
     {
       if (insert)
         {
           int editor_linenr = -1;
-          marker *bp = 0;
+          marker *bp = nullptr;
 
           // If comes back indicating a non-zero breakpoint marker,
           // reuse it if possible
           emit find_translated_line_number (line, editor_linenr, bp);
           if (bp != 0)
             {
               if ((cond == "") != (bp->get_cond () == ""))
                 {       // can only reuse conditional bp as conditional
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -224,17 +224,17 @@ file_editor::request_new_file (const QSt
       focus ();                                 // focus editor and new tab
     }
 }
 
 // Check whether this file is already open in the editor.
 QWidget *
 file_editor::find_tab_widget (const QString& file) const
 {
-  QWidget *retval = 0;
+  QWidget *retval = nullptr;
 
   for (editor_tab_map_const_iterator p = editor_tab_map.begin ();
        p != editor_tab_map.end (); p++)
     {
       QString tab_file = p->first;
 
       if (same_file (file.toStdString (), tab_file.toStdString ())
           || file == tab_file)     // needed as same_file ("","") is false.
@@ -330,17 +330,17 @@ file_editor::request_open_file (const QS
           if (! ((breakpoint_marker || debug_pointer) && is_editor_console_tabbed ()))
             {
               emit fetab_set_focus (tab);
               focus ();
             }
         }
       else
         {
-          file_editor_tab *fileEditorTab = 0;
+          file_editor_tab *fileEditorTab = nullptr;
           // Reuse <unnamed> tab if it hasn't yet been modified.
           bool reusing = false;
           tab = find_tab_widget ("");
           if (tab)
             {
               fileEditorTab = static_cast<file_editor_tab *>(tab);
               if (fileEditorTab->qsci_edit_area ()->isModified ())
                 fileEditorTab = 0;
@@ -505,17 +505,17 @@ file_editor::check_conflict_save (const 
       msgBox->setWindowModality (Qt::NonModal);
       msgBox->setAttribute (Qt::WA_DeleteOnClose);
       msgBox->show ();
 
       return;
     }
 
   QObject *saveFileObject = sender ();
-  QWidget *saveFileWidget = 0;
+  QWidget *saveFileWidget = nullptr;
 
   for (int i = 0; i < _tab_widget->count (); i++)
     {
       if (_tab_widget->widget (i) == saveFileObject)
         {
           saveFileWidget = _tab_widget->widget (i);
           break;
         }
diff --git a/libgui/src/m-editor/file-editor.h b/libgui/src/m-editor/file-editor.h
--- a/libgui/src/m-editor/file-editor.h
+++ b/libgui/src/m-editor/file-editor.h
@@ -332,17 +332,17 @@ protected:
   void dragEnterEvent (QDragEnterEvent *event);
   void dropEvent (QDropEvent *event);
 
 private:
 
   bool is_editor_console_tabbed ();
   void construct (void);
   void add_file_editor_tab (file_editor_tab *f, const QString& fn);
-  void save_file_as (QWidget *fetabID = 0);
+  void save_file_as (QWidget *fetabID = nullptr);
   void mru_menu_update (void);
   bool call_custom_editor (const QString& file_name = QString (), int line = -1);
 
   void toggle_preference (const QString& preference, bool def);
 
   void switch_tab (int direction, bool movetab = false);
 
   void restore_session (QSettings *settings);
diff --git a/libgui/src/m-editor/find-dialog.h b/libgui/src/m-editor/find-dialog.h
--- a/libgui/src/m-editor/find-dialog.h
+++ b/libgui/src/m-editor/find-dialog.h
@@ -72,17 +72,17 @@ class QLabel;
 class QLineEdit;
 class QPushButton;
 
 class find_dialog : public QDialog
 {
   Q_OBJECT
 public:
   find_dialog (QsciScintilla *edit_area, QList<QAction *> find_actions,
-               QWidget *parent = 0);
+               QWidget *parent = nullptr);
   void init_search_text ();
 
 private slots:
   void handle_sel_search_changed (int);
   void handle_selection_changed (bool has_selected);
 
   void handle_backward_search_changed (int);
   void handle_search_text_changed (QString new_search_text);
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -240,17 +240,17 @@ main_window::~main_window (void)
       community_news_window = 0;
     }
 }
 
 // catch focus changes and determine the active dock widget
 void
 main_window::focus_changed (QWidget *, QWidget *new_widget)
 {
-  octave_dock_widget *dock = 0;
+  octave_dock_widget *dock = nullptr;
   QWidget *w_new = new_widget;  // get a copy of new focus widget
   QWidget *start = w_new;       // Save it as start of our search
   int count = 0;                // fallback to prevent endless loop
 
   while (w_new && w_new != _main_tool_bar && count < 100)
     {
       dock = qobject_cast<octave_dock_widget *> (w_new);
       if (dock)
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -277,17 +277,17 @@ protected:
 
 private:
 
   void construct (void);
 
   void construct_octave_qt_link (void);
 
   QAction * add_action (QMenu *menu, const QIcon& icon, const QString& text,
-                        const char *member, const QWidget *receiver = 0);
+                        const char *member, const QWidget *receiver = nullptr);
 
   QMenu * m_add_menu (QMenuBar *p, QString text);
   void construct_menu_bar (void);
   void construct_file_menu (QMenuBar *p);
   void construct_new_menu (QMenu *p);
   void construct_edit_menu (QMenuBar *p);
   QAction * construct_debug_menu_item (const char *icon, const QString& item,
                                        const char *member);
diff --git a/libgui/src/octave-dock-widget.h b/libgui/src/octave-dock-widget.h
--- a/libgui/src/octave-dock-widget.h
+++ b/libgui/src/octave-dock-widget.h
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 #include <QMouseEvent>
 
 class octave_dock_widget : public QDockWidget
 {
   Q_OBJECT
 
 public:
 
-  octave_dock_widget (QWidget *p = 0);
+  octave_dock_widget (QWidget *p = nullptr);
   virtual ~octave_dock_widget (void) = default;
 
   virtual void connect_visibility_changed (void);
   void make_window (void);
   void make_widget (bool dock=true);
   void set_title (const QString&);
   void set_predecessor_widget (octave_dock_widget *prev_widget);
 signals:
diff --git a/libgui/src/qtinfo/parser.cc b/libgui/src/qtinfo/parser.cc
--- a/libgui/src/qtinfo/parser.cc
+++ b/libgui/src/qtinfo/parser.cc
@@ -89,17 +89,17 @@ QString
 parser::get_info_path ()
 {
   return _info_path;
 }
 
 QIODevice *
 parser::open_file (QFileInfo & file_info)
 {
-  QIODevice *iodevice = 0;
+  QIODevice *iodevice = nullptr;
   if (_compressors_map.contains (file_info.suffix ()))
     {
       QString command = _compressors_map.value (file_info.suffix ()).arg (
                           file_info.absoluteFilePath ());
       iprocstream ips (command.toStdString ());
 
       if (ips.bad ())
         return 0;
diff --git a/libgui/src/qtinfo/parser.h b/libgui/src/qtinfo/parser.h
--- a/libgui/src/qtinfo/parser.h
+++ b/libgui/src/qtinfo/parser.h
@@ -50,17 +50,17 @@ along with Octave; see the file COPYING.
  * </p>
  */
 class parser
   : public QObject
 {
   Q_OBJECT
 
 public:
-  parser (QObject *parent = 0);
+  parser (QObject *parent = nullptr);
   bool set_info_path (const QString& _info_path);
   QString get_info_path ();
   QString search_node (const QString& node);
   QString global_search (const QString& text, int maxFounds);
 
   QString find_ref (const QString& name);
 
   /** Checks if this node is reference. If node is reference, it will be
diff --git a/libgui/src/qtinfo/webinfo.h b/libgui/src/qtinfo/webinfo.h
--- a/libgui/src/qtinfo/webinfo.h
+++ b/libgui/src/qtinfo/webinfo.h
@@ -66,17 +66,17 @@ private:
 
 // The webinfo class
 class webinfo : public QWidget
 {
   Q_OBJECT
 
 public:
 
-  webinfo (QWidget *parent = 0);
+  webinfo (QWidget *parent = nullptr);
   bool set_info_path (const QString& info_path);
   void load_node (const QString& node_name);
   void load_ref (const QString& ref_name);
   void notice_settings (const QSettings *settings);
 
 public slots:
 
   void link_clicked (const QUrl& link);
diff --git a/libgui/src/resource-manager.cc b/libgui/src/resource-manager.cc
--- a/libgui/src/resource-manager.cc
+++ b/libgui/src/resource-manager.cc
@@ -42,17 +42,17 @@ along with Octave; see the file COPYING.
 #include "oct-env.h"
 
 #include "defaults.h"
 
 #include "QTerminal.h"
 #include "workspace-model.h"
 #include "resource-manager.h"
 
-resource_manager *resource_manager::instance = 0;
+resource_manager *resource_manager::instance = nullptr;
 
 static QString
 default_qt_settings_file (void)
 {
   std::string dsf = octave::sys::env::getenv ("OCTAVE_DEFAULT_QT_SETTINGS");
 
   if (dsf.empty ())
     dsf = Voct_etc_dir + octave::sys::file_ops::dir_sep_str () +
diff --git a/libgui/src/shortcut-manager.cc b/libgui/src/shortcut-manager.cc
--- a/libgui/src/shortcut-manager.cc
+++ b/libgui/src/shortcut-manager.cc
@@ -37,17 +37,17 @@ along with Octave; see the file COPYING.
 #include <QHeaderView>
 #include <QAction>
 #include <QFileDialog>
 
 #include "error.h"
 #include "resource-manager.h"
 #include "shortcut-manager.h"
 
-shortcut_manager *shortcut_manager::instance = 0;
+shortcut_manager *shortcut_manager::instance = nullptr;
 
 shortcut_manager::shortcut_manager ()
 {
   setObjectName ("Shortcut_Manager");
 
   // Mac: don't let Qt interpret CMD key ("Meta" in Qt terminology) as Ctrl
 #if defined (Q_OS_MAC)
   QCoreApplication::setAttribute (Qt::AA_MacDontSwapCtrlAndMeta, true);
diff --git a/libgui/src/shortcut-manager.h b/libgui/src/shortcut-manager.h
--- a/libgui/src/shortcut-manager.h
+++ b/libgui/src/shortcut-manager.h
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include <QLabel>
 #include <QSettings>
 
 class enter_shortcut : public QLineEdit
 {
   Q_OBJECT
 
 public:
-  enter_shortcut (QWidget *p = 0);
+  enter_shortcut (QWidget *p = nullptr);
   ~enter_shortcut ();
 
   virtual void keyPressEvent (QKeyEvent *e);
 
 public slots:
   void handle_direct_shortcut (int);
 
 private:
diff --git a/libgui/src/terminal-dock-widget.h b/libgui/src/terminal-dock-widget.h
--- a/libgui/src/terminal-dock-widget.h
+++ b/libgui/src/terminal-dock-widget.h
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include "octave-dock-widget.h"
 
 class terminal_dock_widget : public octave_dock_widget
 {
   Q_OBJECT
 
 public:
 
-  terminal_dock_widget (QWidget *parent = 0);
+  terminal_dock_widget (QWidget *parent = nullptr);
 
   ~terminal_dock_widget (void);
 
   bool has_focus (void) const;
 
   void focus (void);
 
 signals:
diff --git a/libgui/src/welcome-wizard.cc b/libgui/src/welcome-wizard.cc
--- a/libgui/src/welcome-wizard.cc
+++ b/libgui/src/welcome-wizard.cc
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
   #define WIN32_LEAN_AND_MEAN
   #include <windows.h>
 #endif
 
 #include "welcome-wizard.h"
 #include "resource-manager.h"
 
 static QLabel *
-make_octave_logo (QWidget *p = 0, int height = 100)
+make_octave_logo (QWidget *p = nullptr, int height = 100)
 {
   QLabel *logo = new QLabel (p);
   QPixmap logo_pixmap (":/actions/icons/logo.png");
   logo->setPixmap (logo_pixmap.scaledToHeight (height));
   return logo;
 };
 
 
diff --git a/libgui/src/welcome-wizard.h b/libgui/src/welcome-wizard.h
--- a/libgui/src/welcome-wizard.h
+++ b/libgui/src/welcome-wizard.h
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 class welcome_wizard : public QDialog
 {
   Q_OBJECT
 
 public:
 
   typedef QWidget *(*page_creator_fptr) (welcome_wizard *wizard);
 
-  welcome_wizard (QWidget *parent = 0);
+  welcome_wizard (QWidget *parent = nullptr);
 
   ~welcome_wizard (void) = default;
 
 private:
 
   QList<page_creator_fptr> page_ctor_list;
   QList<page_creator_fptr>::iterator page_list_iterator;
   QWidget *current_page;
diff --git a/libgui/src/workspace-model.h b/libgui/src/workspace-model.h
--- a/libgui/src/workspace-model.h
+++ b/libgui/src/workspace-model.h
@@ -38,17 +38,17 @@ typedef QList<int> QIntList;
 
 class workspace_model
   : public QAbstractTableModel
 {
   Q_OBJECT
 
 public:
 
-  workspace_model (QObject *parent = 0);
+  workspace_model (QObject *parent = nullptr);
 
   ~workspace_model (void) = default;
 
   static QList<QColor> storage_class_default_colors (void);
 
   static QStringList storage_class_names (void);
 
   QVariant data (const QModelIndex& index, int role) const;
diff --git a/libgui/src/workspace-view.h b/libgui/src/workspace-view.h
--- a/libgui/src/workspace-view.h
+++ b/libgui/src/workspace-view.h
@@ -36,17 +36,17 @@ along with Octave; see the file COPYING.
 #include "workspace-model.h"
 
 class workspace_view : public octave_dock_widget
 {
   Q_OBJECT
 
 public:
 
-  workspace_view (QWidget *parent = 0);
+  workspace_view (QWidget *parent = nullptr);
 
   ~workspace_view (void) = default;
 
 public slots:
 
   void notice_settings (const QSettings *);
 
   void setModel (workspace_model *model);
diff --git a/libinterp/corefcn/__magick_read__.cc b/libinterp/corefcn/__magick_read__.cc
--- a/libinterp/corefcn/__magick_read__.cc
+++ b/libinterp/corefcn/__magick_read__.cc
@@ -763,17 +763,17 @@ static void
 maybe_initialize_magick (void)
 {
   static bool initialized = false;
 
   if (! initialized)
     {
       // Save locale as GraphicsMagick might change this (fixed in
       // GraphicsMagick since version 1.3.13 released on December 24, 2011)
-      const char *static_locale = setlocale (LC_ALL, NULL);
+      const char *static_locale = setlocale (LC_ALL, nullptr);
       const std::string locale (static_locale);
 
       const std::string program_name
         = octave::sys::env::get_program_invocation_name ();
       Magick::InitializeMagick (program_name.c_str ());
 
       // Restore locale from before GraphicsMagick initialisation
       setlocale (LC_ALL, locale.c_str ());
diff --git a/libinterp/corefcn/call-stack.cc b/libinterp/corefcn/call-stack.cc
--- a/libinterp/corefcn/call-stack.cc
+++ b/libinterp/corefcn/call-stack.cc
@@ -36,17 +36,17 @@ along with Octave; see the file COPYING.
 // Use static fields for the best efficiency.
 // NOTE: C++0x will allow these two to be merged into one.
 static const char *bt_fieldnames[] =
   { "file", "name", "line", "column", "scope", "context", 0 };
 static const octave_fields bt_fields (bt_fieldnames);
 
 namespace octave
 {
-  call_stack *call_stack::instance = 0;
+  call_stack *call_stack::instance = nullptr;
 
   std::string
   call_stack::stack_frame::fcn_file_name (void) const
   {
     return m_fcn ? m_fcn->fcn_file_name () : "";
   }
 
   std::string
@@ -164,17 +164,17 @@ namespace octave
     curr_user_frame = retval - curr_user_frame - 1;
 
     return retval;
   }
 
   octave_user_code *
   call_stack::do_caller_user_code (size_t nskip) const
   {
-    octave_user_code *retval = 0;
+    octave_user_code *retval = nullptr;
 
     const_iterator p = cs.end ();
 
     while (p != cs.begin ())
       {
         const stack_frame& elt = *(--p);
 
         octave_function *f = elt.m_fcn;
@@ -244,17 +244,17 @@ namespace octave
       }
 
     return retval;
   }
 
   octave_user_code *
   call_stack::do_debug_user_code (void) const
   {
-    octave_user_code *retval = 0;
+    octave_user_code *retval = nullptr;
 
     // This should never happen...
     if (curr_frame == 0)
       return retval;
 
     // Start looking with the caller of the calling debug function.
     size_t i = cs[curr_frame].m_prev;
 
diff --git a/libinterp/corefcn/call-stack.h b/libinterp/corefcn/call-stack.h
--- a/libinterp/corefcn/call-stack.h
+++ b/libinterp/corefcn/call-stack.h
@@ -49,17 +49,17 @@ namespace octave
   public:
 
     class stack_frame
     {
     public:
 
       friend class call_stack;
 
-      stack_frame (octave_function *fcn = 0, symbol_table::scope_id scope = 0,
+      stack_frame (octave_function *fcn = nullptr, symbol_table::scope_id scope = 0,
                    symbol_table::context_id context = 0, size_t prev = 0)
         : m_fcn (fcn), m_line (-1), m_column (-1), m_scope (scope),
           m_context (context), m_prev (prev)
       { }
 
       stack_frame (const stack_frame& elt)
         : m_fcn (elt.m_fcn), m_line (elt.m_line), m_column (elt.m_column),
           m_scope (elt.m_scope), m_context (elt.m_context), m_prev (elt.m_prev)
@@ -368,17 +368,17 @@ namespace octave
       static stack_frame foobar;
 
       return idx < cs.size () ? cs[idx] : foobar;
     }
 #endif
 
     octave_function * do_element (size_t n)
     {
-      octave_function *retval = 0;
+      octave_function *retval = nullptr;
 
       if (cs.size () > n)
         {
           stack_frame& elt = cs[n];
           retval = elt.m_fcn;
         }
 
       return retval;
@@ -400,17 +400,17 @@ namespace octave
       size_t prev_frame = curr_frame;
       curr_frame = cs.size ();
       cs.push_back (stack_frame (fcn, scope, context, prev_frame));
       symbol_table::set_scope_and_context (scope, context);
     }
 
     octave_function * do_current (void) const
     {
-      octave_function *retval = 0;
+      octave_function *retval = nullptr;
 
       if (! cs.empty ())
         {
           const stack_frame& elt = cs[curr_frame];
           retval = elt.m_fcn;
         }
 
       return retval;
diff --git a/libinterp/corefcn/cdisplay.c b/libinterp/corefcn/cdisplay.c
--- a/libinterp/corefcn/cdisplay.c
+++ b/libinterp/corefcn/cdisplay.c
@@ -46,17 +46,17 @@ along with Octave; see the file COPYING.
 
 // Please do NOT eliminate this file and move code from here to
 // display.cc.
 
 const char *
 octave_get_display_info (int *ht, int *wd, int *dp, double *rx, double *ry,
                          int *dpy_avail)
 {
-  const char *msg = 0;
+  const char *msg = NULL;
 
   *dpy_avail = 0;
 
 #if defined (OCTAVE_USE_WINDOWS_API)
 
   HDC hdc = GetDC (0);
 
   if (hdc)
diff --git a/libinterp/corefcn/display.cc b/libinterp/corefcn/display.cc
--- a/libinterp/corefcn/display.cc
+++ b/libinterp/corefcn/display.cc
@@ -25,17 +25,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include "singleton-cleanup.h"
 
 #include "cdisplay.h"
 #include "display.h"
 #include "error.h"
 
-display_info *display_info::instance = 0;
+display_info *display_info::instance = nullptr;
 
 void
 display_info::init (bool query)
 {
   if (query)
     {
       int avail = 0;
 
diff --git a/libinterp/corefcn/dlmread.cc b/libinterp/corefcn/dlmread.cc
--- a/libinterp/corefcn/dlmread.cc
+++ b/libinterp/corefcn/dlmread.cc
@@ -202,17 +202,17 @@ such as text, are also replaced by the @
       empty_value = args(nargin-1).double_value ();
 
       nargin -= 2;
     }
 
   if (nargin < 1 || nargin > 4)
     print_usage ();
 
-  std::istream *input = 0;
+  std::istream *input = nullptr;
   std::ifstream input_file;
 
   if (args(0).is_string ())
     {
       // Filename.
       std::string fname (args(0).string_value ());
 
       std::string tname = octave::sys::file_ops::tilde_expand (fname);
diff --git a/libinterp/corefcn/dynamic-ld.cc b/libinterp/corefcn/dynamic-ld.cc
--- a/libinterp/corefcn/dynamic-ld.cc
+++ b/libinterp/corefcn/dynamic-ld.cc
@@ -94,17 +94,17 @@ namespace octave
   void
   dynamic_loader::shlibs_list::display (void) const
   {
     std::cerr << "current shared libraries:" << std::endl;
     for (const auto& lib : lib_list)
       std::cerr << "  " << lib.file_name () << std::endl;
   }
 
-  dynamic_loader *dynamic_loader::instance = 0;
+  dynamic_loader *dynamic_loader::instance = nullptr;
 
   bool dynamic_loader::doing_load = false;
 
   bool
   dynamic_loader::instance_ok (void)
   {
     bool retval = true;
 
@@ -145,17 +145,17 @@ namespace octave
       loaded_shlibs.remove (oct_file, symbol_table::clear_dld_function);
   }
 
   octave_function *
   dynamic_loader::do_load_oct (const std::string& fcn_name,
                                const std::string& file_name,
                                bool relative)
   {
-    octave_function *retval = 0;
+    octave_function *retval = nullptr;
 
     unwind_protect frame;
 
     frame.protect_var (dynamic_loader::doing_load);
 
     doing_load = true;
 
     dynamic_library oct_file = loaded_shlibs.find_file (file_name);
@@ -199,17 +199,17 @@ namespace octave
     return retval;
   }
 
   octave_function *
   dynamic_loader::do_load_mex (const std::string& fcn_name,
                                const std::string& file_name,
                                bool /*relative*/)
   {
-    octave_function *retval = 0;
+    octave_function *retval = nullptr;
 
     unwind_protect frame;
 
     frame.protect_var (dynamic_loader::doing_load);
 
     doing_load = true;
 
     dynamic_library mex_file = loaded_shlibs.find_file (file_name);
@@ -223,17 +223,17 @@ namespace octave
 
         if (mex_file)
           loaded_shlibs.append (mex_file);
       }
 
     if (! mex_file)
       error ("%s is not a valid shared library", file_name.c_str ());
 
-    void *function = 0;
+    void *function = nullptr;
 
     bool have_fmex = false;
 
     function = mex_file.search (fcn_name, mex_mangler);
 
     if (! function)
       {
         // FIXME: can we determine this C mangling scheme
diff --git a/libinterp/corefcn/ft-text-renderer.cc b/libinterp/corefcn/ft-text-renderer.cc
--- a/libinterp/corefcn/ft-text-renderer.cc
+++ b/libinterp/corefcn/ft-text-renderer.cc
@@ -311,17 +311,17 @@ namespace octave
     }
 
   private:
     FT_Library library;
     bool freetype_initialized;
     bool fontconfig_initialized;
   };
 
-  ft_manager *ft_manager::instance = 0;
+  ft_manager *ft_manager::instance = nullptr;
 
 }
 
 static void
 ft_face_destroyed (void *object)
 {
   octave::ft_manager::font_destroyed (reinterpret_cast<FT_Face> (object));
 }
diff --git a/libinterp/corefcn/gl2ps-print.cc b/libinterp/corefcn/gl2ps-print.cc
--- a/libinterp/corefcn/gl2ps-print.cc
+++ b/libinterp/corefcn/gl2ps-print.cc
@@ -838,17 +838,17 @@ namespace octave
   {
 #if defined (HAVE_GL2PS_H) && defined (HAVE_OPENGL)
 
     // FIXME: should we have a way to create a file that begins with the
     // character '|'?
 
     bool have_cmd = stream.length () > 1 && stream[0] == '|';
 
-    FILE *fp = 0;
+    FILE *fp = nullptr;
 
     octave::unwind_protect frame;
 
     if (have_cmd)
       {
         // Create process and pipe gl2ps output to it.
 
         std::string cmd = stream.substr (1);
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1101,17 +1101,17 @@ lookup_object_name (const caseless_str& 
   return result;
 }
 
 static base_graphics_object*
 make_graphics_object_from_type (const caseless_str& type,
                                 const graphics_handle& h = graphics_handle (),
                                 const graphics_handle& p = graphics_handle ())
 {
-  base_graphics_object *go = 0;
+  base_graphics_object *go = nullptr;
 
   if (type.compare ("figure"))
     go = new figure (h, p);
   else if (type.compare ("axes"))
     go = new axes (h, p);
   else if (type.compare ("line"))
     go = new line (h, p);
   else if (type.compare ("text"))
@@ -2652,17 +2652,17 @@ gh_manager::do_renumber_figure (const gr
       if (hfig == old_gh)
         {
           hfig = new_gh;
           break;
         }
     }
 }
 
-gh_manager *gh_manager::instance = 0;
+gh_manager *gh_manager::instance = nullptr;
 
 static void
 xset (const graphics_handle& h, const caseless_str& pname,
       const octave_value& val)
 {
   graphics_object go = gh_manager::get_object (h);
   go.set (pname, val);
 }
@@ -9558,17 +9558,17 @@ graphics_handle
 gh_manager::do_make_graphics_handle (const std::string& go_name,
                                      const graphics_handle& p,
                                      bool integer_figure_handle,
                                      bool do_createfcn,
                                      bool do_notify_toolkit)
 {
   graphics_handle h = get_handle (integer_figure_handle);
 
-  base_graphics_object *bgo = 0;
+  base_graphics_object *bgo = nullptr;
 
   bgo = make_graphics_object_from_type (go_name, h, p);
 
   if (! bgo)
     error ("gh_manager::do_make_graphics_handle: invalid object type '%s'",
            go_name.c_str ());
 
   graphics_object go (bgo);
@@ -9691,17 +9691,17 @@ class
 function_event : public base_graphics_event
 {
 public:
 
   // function_event objects must be created with at least a function.
 
   function_event (void) = delete;
 
-  function_event (graphics_event::event_fcn fcn, void *data = 0)
+  function_event (graphics_event::event_fcn fcn, void *data = nullptr)
     : base_graphics_event (), function (fcn), function_data (data)
   { }
 
   // No copying!
 
   function_event (const function_event&) = delete;
 
   function_event & operator = (const function_event&) = delete;
@@ -9840,17 +9840,17 @@ gh_manager::do_execute_listener (const g
 void
 gh_manager::do_execute_callback (const graphics_handle& h,
                                  const octave_value& cb_arg,
                                  const octave_value& data)
 {
   if (cb_arg.is_defined () && ! cb_arg.is_empty ())
     {
       octave_value_list args;
-      octave_function *fcn = 0;
+      octave_function *fcn = nullptr;
 
       args(0) = h.as_octave_value ();
       if (data.is_defined ())
         args(1) = data;
       else
         args(1) = Matrix ();
 
       octave::unwind_protect_safe frame;
@@ -11142,17 +11142,17 @@ Internal function: returns the pixel siz
     dynamic_cast<image::properties&> (go.get_properties ());
 
   Matrix dp = Matrix (1, 2);
   dp(0) = ip.pixel_xsize ();
   dp(1) = ip.pixel_ysize ();
   return ovl (dp);
 }
 
-gtk_manager *gtk_manager::instance = 0;
+gtk_manager *gtk_manager::instance = nullptr;
 
 void
 gtk_manager::create_instance (void)
 {
   instance = new gtk_manager ();
 
   if (instance)
     singleton_cleanup_list::add (cleanup_instance);
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -6333,17 +6333,17 @@ public:
                          const octave_value& data = Matrix ());
 
   static graphics_event
   create_callback_event (const graphics_handle& h,
                          const octave_value& cb,
                          const octave_value& data = Matrix ());
 
   static graphics_event
-  create_function_event (event_fcn fcn, void *data = 0);
+  create_function_event (event_fcn fcn, void *data = nullptr);
 
   static graphics_event
   create_set_event (const graphics_handle& h, const std::string& name,
                     const octave_value& value,
                     bool notify_toolkit = true);
 private:
   base_graphics_event *rep;
 };
@@ -6523,17 +6523,17 @@ public:
   static void post_callback (const graphics_handle& h,
                              const std::string& name,
                              const octave_value& data = Matrix ())
   {
     if (instance_ok ())
       instance->do_post_callback (h, name, data);
   }
 
-  static void post_function (graphics_event::event_fcn fcn, void *data = 0)
+  static void post_function (graphics_event::event_fcn fcn, void *data = nullptr)
   {
     if (instance_ok ())
       instance->do_post_function (fcn, data);
   }
 
   static void post_set (const graphics_handle& h, const std::string& name,
                         const octave_value& value, bool notify_toolkit = true)
   {
diff --git a/libinterp/corefcn/input.h b/libinterp/corefcn/input.h
--- a/libinterp/corefcn/input.h
+++ b/libinterp/corefcn/input.h
@@ -151,17 +151,17 @@ namespace octave
     static const std::string in_src;
   };
 
   class
   terminal_reader : public base_reader
   {
   public:
 
-    terminal_reader (octave::base_lexer *lxr = 0)
+    terminal_reader (octave::base_lexer *lxr = nullptr)
       : base_reader (lxr)
     { }
 
     std::string get_input (bool& eof);
 
     std::string input_source (void) const { return in_src; }
 
     bool input_from_terminal (void) const { return true; }
@@ -171,17 +171,17 @@ namespace octave
     static const std::string in_src;
   };
 
   class
   file_reader : public base_reader
   {
   public:
 
-    file_reader (FILE *f_arg, octave::base_lexer *lxr = 0)
+    file_reader (FILE *f_arg, octave::base_lexer *lxr = nullptr)
       : base_reader (lxr), file (f_arg) { }
 
     std::string get_input (bool& eof);
 
     std::string input_source (void) const { return in_src; }
 
     bool input_from_file (void) const { return true; }
 
@@ -193,17 +193,17 @@ namespace octave
   };
 
   class
   eval_string_reader : public base_reader
   {
   public:
 
     eval_string_reader (const std::string& str,
-                               octave::base_lexer *lxr = 0)
+                               octave::base_lexer *lxr = nullptr)
       : base_reader (lxr), eval_string (str)
     { }
 
     std::string get_input (bool& eof);
 
     std::string input_source (void) const { return in_src; }
 
     bool input_from_eval_string (void) const { return true; }
@@ -214,25 +214,25 @@ namespace octave
 
     static const std::string in_src;
   };
 
   class
   input_reader
   {
   public:
-    input_reader (octave::base_lexer *lxr = 0)
+    input_reader (octave::base_lexer *lxr = nullptr)
       : rep (new terminal_reader (lxr))
     { }
 
-    input_reader (FILE *file, octave::base_lexer *lxr = 0)
+    input_reader (FILE *file, octave::base_lexer *lxr = nullptr)
       : rep (new file_reader (file, lxr))
     { }
 
-    input_reader (const std::string& str, octave::base_lexer *lxr = 0)
+    input_reader (const std::string& str, octave::base_lexer *lxr = nullptr)
       : rep (new eval_string_reader (str, lxr))
     { }
 
     input_reader (const input_reader& ir)
     {
       rep = ir.rep;
       rep->count++;
     }
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -356,17 +356,17 @@ execute_pkg_add (const std::string& dir)
   catch (const octave::execution_exception&)
     {
       octave::interpreter::recover_from_exception ();
     }
 }
 
 namespace octave
 {
-  tree_evaluator *current_evaluator = 0;
+  tree_evaluator *current_evaluator = nullptr;
 
   // Create an interpreter object and perform initialization up to the
   // point of setting reading command history and setting the load
   // path.
 
   interpreter::interpreter (application *app_context)
     : m_app_context (app_context), m_evaluator (new tree_evaluator (this)),
       m_load_path (), m_interactive (false), m_read_site_files (true),
diff --git a/libinterp/corefcn/interpreter.h b/libinterp/corefcn/interpreter.h
--- a/libinterp/corefcn/interpreter.h
+++ b/libinterp/corefcn/interpreter.h
@@ -56,17 +56,17 @@ namespace octave
 
   class OCTINTERP_API interpreter
   {
   public:
 
     // Create an interpreter object and perform basic initialization
     // up to the point of reading history and setting the load path.
 
-    interpreter (application *app_context = 0);
+    interpreter (application *app_context = nullptr);
 
     // No copying, at least not yet...
 
     interpreter (const interpreter&) = delete;
 
     interpreter& operator = (const interpreter&) = delete;
 
     // Clean up the interpreter object.
diff --git a/libinterp/corefcn/ls-hdf5.cc b/libinterp/corefcn/ls-hdf5.cc
--- a/libinterp/corefcn/ls-hdf5.cc
+++ b/libinterp/corefcn/ls-hdf5.cc
@@ -710,21 +710,20 @@ hdf5_h5g_iterate (octave_hdf5_id loc_id,
   return H5Giterate (new_id, name, idx, hdf5_read_next_data_internal,
                      operator_data);
 
 #else
   err_disabled_feature ("hdf5_h5g_iterate", "HDF5");
 #endif
 }
 
-// Read the next Octave variable from the stream IS, which must really be
-// an hdf5_ifstream.  Return the variable value in tc, its doc string
-// in doc, and whether it is global in global.  The return value is
-// the name of the variable, or NULL if none were found or there was
-// and error.
+// Read the next Octave variable from the stream IS, which must really be an
+// hdf5_ifstream.  Return the variable value in tc, its doc string in doc, and
+// whether it is global in global.  The return value is the name of the
+// variable, or NULL if none were found or there was an error.
 std::string
 read_hdf5_data (std::istream& is, const std::string& /* filename */,
                 bool& global, octave_value& tc, std::string& doc,
                 const string_vector& argv, int argv_idx, int argc)
 {
 #if defined (HAVE_HDF5)
 
   check_hdf5_types ();
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -386,17 +386,17 @@ public:
   void set_cell (mwIndex /*idx*/, mxArray * /*val*/) { request_mutation (); }
 
   double get_scalar (void) const
   {
     if (val.is_sparse_type ())
       {
         // For sparse arrays, return the first non-zero value.
         void *data = val.mex_get_data ();
-        if (data == NULL)
+        if (data == nullptr)
           return 0.0;
 
         if (val.is_bool_type ())
           return *static_cast<bool *> (data);
         else if (val.is_real_type ())
           return *static_cast<double *> (data);
         else  // Complex type, only return real part
           return *static_cast<double *> (data);
@@ -414,17 +414,17 @@ public:
     else
       request_mutation ();
 
     return retval;
   }
 
   void * get_imag_data (void) const
   {
-    void *retval = 0;
+    void *retval = nullptr;
 
     if (is_numeric () && is_real_type ())
       retval = 0;
     else
       request_mutation ();
 
     return retval;
   }
@@ -515,17 +515,17 @@ public:
 
     return retval;
   }
 
   char * array_to_string (void) const
   {
     // FIXME: this is supposed to handle multi-byte character strings.
 
-    char *buf = 0;
+    char *buf = nullptr;
 
     if (val.is_string ())
       {
         mwSize nel = get_number_of_elements ();
 
         buf = static_cast<char *> (mxArray::malloc (nel + 1));
 
         if (buf)
@@ -788,17 +788,17 @@ public:
 
     mxFree (dims);
 
     if (ndims > 0)
       {
         dims
           = static_cast<mwSize *> (mxArray::malloc (ndims * sizeof (mwSize)));
 
-        if (dims == NULL)
+        if (dims == nullptr)
           return 1;
 
         for (int i = 0; i < ndims; i++)
           dims[i] = dims_arg[i];
 
         return 0;
       }
     else
@@ -2386,17 +2386,17 @@ private:
 
   }
 };
 
 // List of memory resources we allocated.
 std::set<void *> mex::global_memlist;
 
 // Current context.
-mex *mex_context = 0;
+mex *mex_context = nullptr;
 
 void *
 mxArray::malloc (size_t n)
 {
   return mex_context ? mex_context->malloc_unmarked (n) : std::malloc (n);
 }
 
 void *
@@ -2876,17 +2876,17 @@ mxGetScalar (const mxArray *ptr)
 }
 
 mxChar *
 mxGetChars (const mxArray *ptr)
 {
   if (mxIsChar (ptr))
     return static_cast<mxChar *> (ptr->get_data ());
   else
-    return NULL;
+    return nullptr;
 }
 
 mxLogical *
 mxGetLogicals (const mxArray *ptr)
 {
   return static_cast<mxLogical *> (ptr->get_data ());
 }
 
@@ -3220,30 +3220,30 @@ mexCallMATLAB (int nargout, mxArray *arg
 
   return execution_error ? 1 : 0;
 }
 
 mxArray *
 mexCallMATLABWithTrap (int nargout, mxArray *argout[], int nargin,
                        mxArray *argin[], const char *fname)
 {
-  mxArray *mx = NULL;
+  mxArray *mx = nullptr;
 
   int old_flag = (mex_context ? mex_context->trap_feval_error : 0);
   mexSetTrapFlag (1);
   if (mexCallMATLAB (nargout, argout, nargin, argin, fname))
     {
       const char *field_names[] = {"identifier", "message", "case", "stack"};
       mx = mxCreateStructMatrix (1, 1, 4, field_names);
       mxSetFieldByNumber (mx, 0, 0, mxCreateString ("Octave:MEX"));
       std::string msg = "mexCallMATLABWithTrap: function call <"
                         + std::string (fname) + "> failed";
       mxSetFieldByNumber (mx, 0, 1, mxCreateString (msg.c_str ()));
       mxSetFieldByNumber (mx, 0, 2, mxCreateCellMatrix (0, 0));
-      mxSetFieldByNumber (mx, 0, 3, mxCreateStructMatrix (0, 1, 0, NULL));
+      mxSetFieldByNumber (mx, 0, 3, mxCreateStructMatrix (0, 1, 0, nullptr));
     }
   mexSetTrapFlag (old_flag);
 
   return mx;
 }
 
 void
 mexSetTrapFlag (int flag)
@@ -3277,17 +3277,17 @@ mexEvalString (const char *s)
     retval = 1;
 
   return retval;
 }
 
 mxArray *
 mexEvalStringWithTrap (const char *s)
 {
-  mxArray *mx = NULL;
+  mxArray *mx = nullptr;
 
   int parse_status;
   bool execution_error = false;
 
   octave_value_list ret;
 
   try
     {
@@ -3304,17 +3304,17 @@ mexEvalStringWithTrap (const char *s)
     {
       const char *field_names[] = {"identifier", "message", "case", "stack"};
       mx = mxCreateStructMatrix (1, 1, 4, field_names);
       mxSetFieldByNumber (mx, 0, 0, mxCreateString ("Octave:MEX"));
       std::string msg = "mexEvalStringWithTrap: eval of <"
                         + std::string (s) + "> failed";
       mxSetFieldByNumber (mx, 0, 1, mxCreateString (msg.c_str ()));
       mxSetFieldByNumber (mx, 0, 2, mxCreateCellMatrix (0, 0));
-      mxSetFieldByNumber (mx, 0, 3, mxCreateStructMatrix (0, 1, 0, NULL));
+      mxSetFieldByNumber (mx, 0, 3, mxCreateStructMatrix (0, 1, 0, nullptr));
     }
 
   return mx;
 }
 
 void
 mexErrMsgTxt (const char *s)
 {
@@ -3384,17 +3384,17 @@ mexPrintf (const char *fmt, ...)
   retval = octave_vformat (octave_stdout, fmt, args);
   va_end (args);
   return retval;
 }
 
 mxArray *
 mexGetVariable (const char *space, const char *name)
 {
-  mxArray *retval = 0;
+  mxArray *retval = nullptr;
 
   octave_value val;
 
   if (! strcmp (space, "global"))
     val = get_global_value (name);
   else
     {
       // FIXME: should this be in variables.cc?
@@ -3510,17 +3510,17 @@ mexAtExit (void (*f) (void))
     }
 
   return 0;
 }
 
 const mxArray *
 mexGet (double handle, const char *property)
 {
-  mxArray *m = 0;
+  mxArray *m = nullptr;
 
   octave_value ret = get_property_from_handle (handle, property, "mexGet");
 
   if (ret.is_defined ())
     m = ret.as_mxArray ();
 
   return m;
 }
diff --git a/libinterp/corefcn/mxarray.in.h b/libinterp/corefcn/mxarray.in.h
--- a/libinterp/corefcn/mxarray.in.h
+++ b/libinterp/corefcn/mxarray.in.h
@@ -508,17 +508,17 @@ public:
   mxArray * mutate (void) const { return rep->mutate (); }
 
   static void * malloc (size_t n);
 
   static void * calloc (size_t n, size_t t);
 
   static char * strsave (const char *str)
   {
-    char *retval = 0;
+    char *retval = nullptr;
 
     if (str)
       {
         mwSize sz = sizeof (mxChar) * (strlen (str) + 1);
         retval = static_cast<char *> (mxArray::malloc (sz));
         strcpy (retval, str);
       }
 
diff --git a/libinterp/corefcn/oct-errno.in.cc b/libinterp/corefcn/oct-errno.in.cc
--- a/libinterp/corefcn/oct-errno.in.cc
+++ b/libinterp/corefcn/oct-errno.in.cc
@@ -28,17 +28,17 @@ along with Octave; see the file COPYING.
 #include <cerrno>
 
 #include "singleton-cleanup.h"
 
 #include "oct-errno.h"
 #include "oct-map.h"
 #include "error.h"
 
-octave_errno *octave_errno::instance = 0;
+octave_errno *octave_errno::instance = nullptr;
 
 octave_errno::octave_errno (void)
 {
   struct errno_struct
   {
     const char *name;
     int value;
   };
diff --git a/libinterp/corefcn/oct-fstrm.cc b/libinterp/corefcn/oct-fstrm.cc
--- a/libinterp/corefcn/oct-fstrm.cc
+++ b/libinterp/corefcn/oct-fstrm.cc
@@ -83,26 +83,26 @@ void
 octave_fstream::do_close (void)
 {
   fs.close ();
 }
 
 std::istream *
 octave_fstream::input_stream (void)
 {
-  std::istream *retval = 0;
+  std::istream *retval = nullptr;
 
   if (mode () & std::ios::in)
     retval = &fs;
 
   return retval;
 }
 
 std::ostream *
 octave_fstream::output_stream (void)
 {
-  std::ostream *retval = 0;
+  std::ostream *retval = nullptr;
 
   if (mode () & std::ios::out)
     retval = &fs;
 
   return retval;
 }
diff --git a/libinterp/corefcn/oct-iostrm.h b/libinterp/corefcn/oct-iostrm.h
--- a/libinterp/corefcn/oct-iostrm.h
+++ b/libinterp/corefcn/oct-iostrm.h
@@ -79,24 +79,24 @@ private:
   virtual const char * stream_type (void) const = 0;
 };
 
 class
 octave_istream : public octave_base_iostream
 {
 public:
 
-  octave_istream (std::istream *arg = 0, const std::string& n = "")
+  octave_istream (std::istream *arg = nullptr, const std::string& n = "")
     : octave_base_iostream (n, std::ios::in,
                             octave::mach_info::native_float_format ()),
       is (arg)
   { }
 
   static octave::stream
-  create (std::istream *arg = 0, const std::string& n = "");
+  create (std::istream *arg = nullptr, const std::string& n = "");
 
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
   std::istream * input_stream (void) { return is; }
 
   std::ostream * output_stream (void) { return 0; }
diff --git a/libinterp/corefcn/oct-procbuf.cc b/libinterp/corefcn/oct-procbuf.cc
--- a/libinterp/corefcn/oct-procbuf.cc
+++ b/libinterp/corefcn/oct-procbuf.cc
@@ -54,17 +54,17 @@ along with Octave; see the file COPYING.
 
 #if ! defined (SHELL_PATH)
 #  define SHELL_PATH "/bin/sh"
 #endif
 
 // This class is based on the procbuf class from libg++, written by
 // Per Bothner, Copyright (C) 1993 Free Software Foundation.
 
-static octave_procbuf *octave_procbuf_list = 0;
+static octave_procbuf *octave_procbuf_list = nullptr;
 
 #if ! defined (BUFSIZ)
 #  define BUFSIZ 1024
 #endif
 
 octave_procbuf *
 octave_procbuf::open (const char *command, int mode)
 {
diff --git a/libinterp/corefcn/oct-stdstrm.h b/libinterp/corefcn/oct-stdstrm.h
--- a/libinterp/corefcn/oct-stdstrm.h
+++ b/libinterp/corefcn/oct-stdstrm.h
@@ -97,26 +97,26 @@ protected:
 };
 
 class
 octave_stdiostream
   : public octave_tstdiostream<c_file_ptr_buf, io_c_file_ptr_stream, FILE *>
 {
 public:
 
-  octave_stdiostream (const std::string& n, FILE *f = 0,
+  octave_stdiostream (const std::string& n, FILE *f = nullptr,
                       std::ios::openmode m = std::ios::in | std::ios::out,
                       octave::mach_info::float_format ff
                         = octave::mach_info::native_float_format (),
                       c_file_ptr_buf::close_fcn cf = c_file_ptr_buf::file_close)
     : octave_tstdiostream<c_file_ptr_buf, io_c_file_ptr_stream, FILE *>
        (n, f, f ? fileno (f) : -1, m, ff, cf) { }
 
   static octave::stream
-  create (const std::string& n, FILE *f = 0,
+  create (const std::string& n, FILE *f = nullptr,
           std::ios::openmode m = std::ios::in | std::ios::out,
           octave::mach_info::float_format ff
             = octave::mach_info::native_float_format (),
           c_file_ptr_buf::close_fcn cf = c_file_ptr_buf::file_close)
   {
     return octave::stream (new octave_stdiostream (n, f, m, ff, cf));
   }
 
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -224,17 +224,17 @@ namespace octave
 
     enum special_conversion
       {
         whitespace_conversion = 1,
         literal_conversion = 2,
         null = 3
       };
 
-    scanf_format_elt (const char *txt = 0, int w = 0, bool d = false,
+    scanf_format_elt (const char *txt = nullptr, int w = 0, bool d = false,
                       char typ = '\0', char mod = '\0',
                       const std::string& ch_class = "")
       : text (strsave (txt)), width (w), discard (d), type (typ),
         modifier (mod), char_class (ch_class)
     { }
 
     scanf_format_elt (const scanf_format_elt& e)
       : text (strsave (e.text)), width (e.width), discard (e.discard),
@@ -736,17 +736,17 @@ namespace octave
       return false;
   }
 
   class
   printf_format_elt
   {
   public:
 
-    printf_format_elt (const char *txt = 0, int n = 0, int w = -1,
+    printf_format_elt (const char *txt = nullptr, int n = 0, int w = -1,
                        int p = -1, const std::string& f = "",
                        char typ = '\0', char mod = '\0')
       : text (strsave (txt)), args (n), fw (w), prec (p), flags (f),
         type (typ), modifier (mod)
     { }
 
     printf_format_elt (const printf_format_elt& e)
       : text (strsave (e.text)), args (e.args), fw (e.fw), prec (e.prec),
@@ -4607,17 +4607,17 @@ namespace octave
         return Matrix (nr, nc, 0.0);
       }
 
     std::istream *isp = input_stream ();
 
     bool all_char_conv = fmt_list.all_character_conversions ();
 
     Matrix mval;
-    double *data = 0;
+    double *data = nullptr;
     octave_idx_type max_size = 0;
     octave_idx_type max_conv = 0;
 
     octave_idx_type final_nr = 0;
     octave_idx_type final_nc = 0;
 
     if (all_char_conv)
       {
@@ -7238,17 +7238,17 @@ namespace octave
       retval = "w+b";
     else if (in_mode == (std::ios::in | std::ios::out | std::ios::ate
                          | std::ios::binary))
       retval = "a+b";
 
     return retval;
   }
 
-  stream_list *stream_list::instance = 0;
+  stream_list *stream_list::instance = nullptr;
 
   bool
   stream_list::instance_ok (void)
   {
     bool retval = true;
 
     if (! instance)
       {
diff --git a/libinterp/corefcn/oct-stream.h b/libinterp/corefcn/oct-stream.h
--- a/libinterp/corefcn/oct-stream.h
+++ b/libinterp/corefcn/oct-stream.h
@@ -239,17 +239,17 @@ namespace octave
   };
 
   class
   OCTINTERP_API
   stream
   {
   public:
 
-    stream (base_stream *bs = 0);
+    stream (base_stream *bs = nullptr);
 
     ~stream (void);
 
     stream (const stream&);
 
     stream& operator = (const stream&);
 
     int flush (void);
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -42,17 +42,17 @@ octave_readline_hook (void)
   octave_link::entered_readline_hook ();
   octave_link::generate_events ();
   octave_link::process_events ();
   octave_link::finished_readline_hook ();
 
   return 0;
 }
 
-octave_link *octave_link::instance = 0;
+octave_link *octave_link::instance = nullptr;
 
 octave_link::octave_link (void)
   : event_queue_mutex (new octave::mutex ()), gui_event_queue (),
     debugging (false), link_enabled (true)
 {
   octave::command_editor::add_event_hook (octave_readline_hook);
 }
 
diff --git a/libinterp/corefcn/pager.cc b/libinterp/corefcn/pager.cc
--- a/libinterp/corefcn/pager.cc
+++ b/libinterp/corefcn/pager.cc
@@ -43,17 +43,17 @@ along with Octave; see the file COPYING.
 #include "pager.h"
 #include "procstream.h"
 #include "sighandlers.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "variables.h"
 
 // Our actual connection to the external pager.
-static oprocstream *external_pager = 0;
+static oprocstream *external_pager = nullptr;
 
 // TRUE means we write to the diary file.
 static bool write_to_diary_file = false;
 
 // The name of the current diary file.
 static std::string diary_file ("diary");
 
 // The diary file.
@@ -297,17 +297,17 @@ namespace octave
           external_diary_file.write (buf, len);
       }
 
     seekoff (0, std::ios::beg);
 
     return 0;
   }
 
-  pager_stream *pager_stream::instance = 0;
+  pager_stream *pager_stream::instance = nullptr;
 
   pager_stream::pager_stream (void) : std::ostream (0), pb (0)
   {
     pb = new pager_buf ();
     rdbuf (pb);
     setf (unitbuf);
   }
 
@@ -386,17 +386,17 @@ namespace octave
       }
 
     if (! instance)
       error ("unable to create pager_stream object!");
 
     return retval;
   }
 
-  diary_stream *diary_stream::instance = 0;
+  diary_stream *diary_stream::instance = nullptr;
 
   diary_stream::diary_stream (void) : std::ostream (0), db (0)
   {
     db = new diary_buf ();
     rdbuf (db);
     setf (unitbuf);
   }
 
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -484,20 +484,20 @@ operator << (std::ostream& os, const pr_
   else
     os << s;
 
   return os;
 }
 
 // Current format for real numbers and the real part of complex
 // numbers.
-static float_format *curr_real_fmt = 0;
+static float_format *curr_real_fmt = nullptr;
 
 // Current format for the imaginary part of complex numbers.
-static float_format *curr_imag_fmt = 0;
+static float_format *curr_imag_fmt = nullptr;
 
 static double
 pr_max_internal (const Matrix& m)
 {
   octave_idx_type nr = m.rows ();
   octave_idx_type nc = m.columns ();
 
   double result = -std::numeric_limits<double>::max ();
diff --git a/libinterp/corefcn/profiler.h b/libinterp/corefcn/profiler.h
--- a/libinterp/corefcn/profiler.h
+++ b/libinterp/corefcn/profiler.h
@@ -153,17 +153,17 @@ private:
     // then-active node, which is our parent.
     tree_node *exit (octave_idx_type);
 
     void build_flat (flat_profile&) const;
 
     // Get the hierarchical profile for this node and its children.  If total
     // is set, accumulate total time of the subtree in that variable as
     // additional return value.
-    octave_value get_hierarchical (double *total = 0) const;
+    octave_value get_hierarchical (double *total = nullptr) const;
 
   private:
 
     tree_node *parent;
     octave_idx_type fcn_id;
 
     typedef std::map<octave_idx_type, tree_node*> child_map;
     child_map children;
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -890,17 +890,17 @@ Note: @code{qz} performs permutation bal
   // Right, left eigenvector matrices.
   if (nargout >= 5)
     {
       // Which side to compute?
       char side = (nargout == 5 ? 'R' : 'B');
       // Compute all of them and backtransform
       char howmany = 'B';
       // Dummy pointer; select is not used.
-      F77_INT *select = 0;
+      F77_INT *select = nullptr;
 
       if (complex_case)
         {
           CVL = CQ;
           CVR = CZ;
           ComplexRowVector cwork2 (2 * nn);
           RowVector rwork2 (8 * nn);
           F77_INT m;
diff --git a/libinterp/corefcn/sighandlers.cc b/libinterp/corefcn/sighandlers.cc
--- a/libinterp/corefcn/sighandlers.cc
+++ b/libinterp/corefcn/sighandlers.cc
@@ -73,17 +73,17 @@ namespace octave
   // closing gnome-terminal, for example).  Note that this variable has
   // no effect if Vcrash_dumps_octave_core is FALSE.
   static bool Vsighup_dumps_octave_core = true;
 
   // Similar to Vsighup_dumps_octave_core, but for SIGTERM signal.
   static bool Vsigterm_dumps_octave_core = true;
 
   // List of signals we have caught since last call to octave::signal_handler.
-  static bool *signals_caught = 0;
+  static bool *signals_caught = nullptr;
 
   // Forward declarations.
   static void user_terminate (int sig_number);
   static void user_abort (int sig_number);
 
   class
   base_interrupt_manager
   {
@@ -330,17 +330,17 @@ namespace octave
 #endif
     }
 
     static void cleanup_instance (void) { delete instance; instance = 0; }
 
     static base_interrupt_manager *instance;
   };
 
-  base_interrupt_manager *interrupt_manager::instance = 0;
+  base_interrupt_manager *interrupt_manager::instance = nullptr;
 
   static void
   my_friendly_exit (int sig, bool save_vars = true)
   {
     std::cerr << "fatal: caught signal "
               << octave_strsignal_wrapper (sig)
               << " -- stopping myself..." << std::endl;
 
diff --git a/libinterp/corefcn/strfns.cc b/libinterp/corefcn/strfns.cc
--- a/libinterp/corefcn/strfns.cc
+++ b/libinterp/corefcn/strfns.cc
@@ -753,17 +753,17 @@ Convert byte stream @var{native_bytes} t
     = (tmp.empty () ? octave_locale_charset_wrapper () : tmp.c_str ());
 
   charNDArray native_bytes = args(0).char_array_value ();
 
   const char *src = native_bytes.data ();
   size_t srclen = native_bytes.numel ();
 
   size_t length;
-  uint8_t *utf8_str = 0;
+  uint8_t *utf8_str = nullptr;
 
   octave::unwind_protect frame;
 
   frame.add_fcn (::free, static_cast<void *> (utf8_str));
 
   utf8_str = octave_u8_conv_from_encoding (codepage, src, srclen, &length);
 
   if (! utf8_str)
@@ -799,17 +799,17 @@ Convert UTF-8 string @var{utf8_str} to b
     = (tmp.empty () ? octave_locale_charset_wrapper () : tmp.c_str ());
 
   charNDArray utf8_str = args(0).xchar_array_value ("UTF8_STR must be a string");
 
   const uint8_t *src = reinterpret_cast<const uint8_t *> (utf8_str.data ());
   size_t srclen = utf8_str.numel ();
 
   size_t length;
-  char *native_bytes = 0;
+  char *native_bytes = nullptr;
 
   octave::unwind_protect frame;
 
   frame.add_fcn (::free, static_cast<void *> (native_bytes));
 
   native_bytes = octave_u8_conv_to_encoding (codepage, src, srclen, &length);
 
   if (! native_bytes)
diff --git a/libinterp/corefcn/symtab.cc b/libinterp/corefcn/symtab.cc
--- a/libinterp/corefcn/symtab.cc
+++ b/libinterp/corefcn/symtab.cc
@@ -46,19 +46,19 @@ along with Octave; see the file COPYING.
 #include "parse.h"
 #include "pt-pr-code.h"
 #include "symtab.h"
 #include "unwind-prot.h"
 #include "utils.h"
 
 octave_value symbol_table::dummy_octave_value;
 
-symbol_table *symbol_table::instance = 0;
+symbol_table *symbol_table::instance = nullptr;
 
-symbol_table::scope_id_cache *symbol_table::scope_id_cache::instance = 0;
+symbol_table::scope_id_cache *symbol_table::scope_id_cache::instance = nullptr;
 
 std::map<symbol_table::scope_id, symbol_table*> symbol_table::all_instances;
 
 std::map<std::string, octave_value> symbol_table::global_table;
 
 std::map<std::string, symbol_table::fcn_info> symbol_table::fcn_table;
 
 std::map<std::string, std::set<std::string> >
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -2355,17 +2355,17 @@ private:
   symbol_table (const symbol_table&) = delete;
 
   symbol_table& operator = (const symbol_table&) = delete;
 
   ~symbol_table (void) = default;
 
   static symbol_table * get_instance (scope_id scope, bool create = true)
   {
-    symbol_table *retval = 0;
+    symbol_table *retval = nullptr;
 
     bool ok = true;
 
     if (scope != xglobal_scope)
       {
         if (scope == xcurrent_scope)
           {
             if (! instance && create)
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -139,17 +139,17 @@ typecast (@var{x}, "uint8")
 {
   if (args.length () != 2)
     print_usage ();
 
   octave_value retval;
 
   octave::unwind_protect frame;
 
-  const void *data = 0;
+  const void *data = nullptr;
   octave_idx_type byte_size = 0;
   dim_vector old_dims;
 
   octave_value array = args(0);
 
   if (array.is_bool_type ())
     get_data_and_bytesize (array.bool_array_value (), data, byte_size,
                            old_dims, frame);
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -270,17 +270,17 @@ ch_manager::do_free (const curl_handle& 
       handle_map.erase (p);
 
       if (h.value () < 0)
         handle_free_list.insert
           (std::ceil (h.value ()) - make_handle_fraction ());
     }
 }
 
-ch_manager *ch_manager::instance = 0;
+ch_manager *ch_manager::instance = nullptr;
 
 DEFUN (urlwrite, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} urlwrite (@var{url}, @var{localfile})
 @deftypefnx {} {@var{f} =} urlwrite (@var{url}, @var{localfile})
 @deftypefnx {} {[@var{f}, @var{success}] =} urlwrite (@var{url}, @var{localfile})
 @deftypefnx {} {[@var{f}, @var{success}, @var{message}] =} urlwrite (@var{url}, @var{localfile})
 Download a remote file specified by its @var{url} and save it as
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -97,17 +97,17 @@ clear_symbol (const std::string& nm)
 // Attributes of variables and functions.
 
 // Is this octave_value a valid function?
 
 octave_function *
 is_valid_function (const std::string& fcn_name,
                    const std::string& warn_for, bool warn)
 {
-  octave_function *ans = 0;
+  octave_function *ans = nullptr;
 
   if (! fcn_name.empty ())
     {
       octave_value val = symbol_table::find_function (fcn_name);
 
       if (val.is_defined ())
         ans = val.function_value (true);
     }
@@ -119,17 +119,17 @@ is_valid_function (const std::string& fc
 
   return ans;
 }
 
 octave_function *
 is_valid_function (const octave_value& arg,
                    const std::string& warn_for, bool warn)
 {
-  octave_function *ans = 0;
+  octave_function *ans = nullptr;
 
   std::string fcn_name;
 
   if (arg.is_string ())
     {
       fcn_name = arg.string_value ();
 
       ans = is_valid_function (fcn_name, warn_for, warn);
@@ -142,17 +142,17 @@ is_valid_function (const octave_value& a
   return ans;
 }
 
 octave_function *
 extract_function (const octave_value& arg, const std::string& warn_for,
                   const std::string& fname, const std::string& header,
                   const std::string& trailer)
 {
-  octave_function *retval = 0;
+  octave_function *retval = nullptr;
 
   retval = is_valid_function (arg, warn_for, 0);
 
   if (! retval)
     {
       std::string s = arg.xstring_value ("%s: first argument must be a string",
                                          warn_for.c_str ());
 
@@ -736,17 +736,17 @@ wants_local_change (const octave_value_l
 
   return retval;
 }
 
 template <typename T>
 bool try_local_protect (T& var)
 {
   octave_user_code *curr_usr_code = octave::call_stack::caller_user_code ();
-  octave_user_function *curr_usr_fcn = 0;
+  octave_user_function *curr_usr_fcn = nullptr;
   if (curr_usr_code && curr_usr_code->is_user_function ())
     curr_usr_fcn = dynamic_cast<octave_user_function *> (curr_usr_code);
 
   if (curr_usr_fcn && curr_usr_fcn->local_protect (var))
     return true;
   else
     return false;
 }
diff --git a/libinterp/dldfcn/__eigs__.cc b/libinterp/dldfcn/__eigs__.cc
--- a/libinterp/dldfcn/__eigs__.cc
+++ b/libinterp/dldfcn/__eigs__.cc
@@ -38,17 +38,17 @@ along with Octave; see the file COPYING.
 #include "ov.h"
 #include "ovl.h"
 #include "pager.h"
 #include "variables.h"
 
 #if defined (HAVE_ARPACK)
 
 // Global pointer for user defined function.
-static octave_function *eigs_fcn = 0;
+static octave_function *eigs_fcn = nullptr;
 
 // Have we warned about imaginary values returned from user function?
 static bool warned_imaginary = false;
 
 // Is this a recursive call?
 static int call_depth = 0;
 
 ColumnVector
diff --git a/libinterp/dldfcn/__init_fltk__.cc b/libinterp/dldfcn/__init_fltk__.cc
--- a/libinterp/dldfcn/__init_fltk__.cc
+++ b/libinterp/dldfcn/__init_fltk__.cc
@@ -2201,17 +2201,17 @@ private:
   }
 
   static int hnd2idx (const graphics_handle& fh)
   {
     return hnd2idx (fh.value ());
   }
 };
 
-figure_manager *figure_manager::instance = 0;
+figure_manager *figure_manager::instance = nullptr;
 
 std::string figure_manager::fltk_idx_header="fltk index=";
 int figure_manager::curr_index = 1;
 
 static bool toolkit_loaded = false;
 
 class fltk_graphics_toolkit : public base_graphics_toolkit
 {
diff --git a/libinterp/dldfcn/__ode15__.cc b/libinterp/dldfcn/__ode15__.cc
--- a/libinterp/dldfcn/__ode15__.cc
+++ b/libinterp/dldfcn/__ode15__.cc
@@ -1060,33 +1060,33 @@ namespace octave
 
     dae.set_maxorder (maxorder);
 
     //Set Refine
     const int refine = options.getfield("Refine").int_value ();
 
     bool haverefine = (refine > 1);
 
-    octave_function *output_fcn = 0;
+    octave_function *output_fcn = nullptr;
     ColumnVector outputsel;
 
     // OutputFcn
     bool haveoutputfunction
       = options.getfield("haveoutputfunction").bool_value ();
 
     if (haveoutputfunction)
       output_fcn = options.getfield("OutputFcn").function_value ();
 
     // OutputSel
     bool haveoutputsel = options.getfield("haveoutputselection").bool_value ();
 
     if (haveoutputsel)
       outputsel = options.getfield("OutputSel").vector_value ();
 
-    octave_function *event_fcn = 0;
+    octave_function *event_fcn = nullptr;
 
     // Events
     bool haveeventfunction
       = options.getfield("haveeventfunction").bool_value ();
 
     if (haveeventfunction)
       event_fcn = options.getfield("Events").function_value ();
 
@@ -1122,17 +1122,17 @@ Undocumented internal function.
 
   // Check number of parameters
   int nargin = args.length ();
 
   if (nargin != 5)
     print_usage ();
 
   // Check odefun
-  octave_function *ida_fcn = 0;
+  octave_function *ida_fcn = nullptr;
 
   octave_value f_arg = args(0);
 
   if (! f_arg.is_function_handle ())
     error ("__ode15__: odefun must be a function handle");
 
   ida_fcn = f_arg.function_value ();
 
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -659,18 +659,18 @@ permutations on the tree.
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   octave_value_list retval (nargout == 2 ? 2 : 1);
 
   octave_idx_type n_row = 0;
   octave_idx_type n_col = 0;
-  octave_idx_type *ridx = 0;
-  octave_idx_type *cidx = 0;
+  octave_idx_type *ridx = nullptr;
+  octave_idx_type *cidx = nullptr;
 
   if (args(0).is_sparse_type ())
     error ("etree: S must be a sparse matrix");
 
   if (args(0).is_complex_type ())
     {
       SparseComplexMatrix scm = args(0).sparse_complex_matrix_value ();
 
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -132,17 +132,17 @@ struct octave_base_int_helper_traits<uns
 {
   static const bool can_be_larger_than_uchar_max = false;
 };
 
 template <typename T>
 octave_base_value *
 octave_base_int_matrix<T>::try_narrowing_conversion (void)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   if (this->matrix.numel () == 1)
     retval = new typename octave_value_int_traits<T>::scalar_type
                (this->matrix (0));
 
   return retval;
 }
 
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -906,72 +906,72 @@ string_vector
 octave_base_value::parent_class_names (void) const
 {
   err_wrong_type_arg ("octave_base_value::parent_class_names()", type_name ());
 }
 
 octave_function *
 octave_base_value::function_value (bool silent)
 {
-  octave_function *retval = 0;
+  octave_function *retval = nullptr;
 
   if (! silent)
     err_wrong_type_arg ("octave_base_value::function_value()", type_name ());
 
   return retval;
 }
 
 octave_user_function *
 octave_base_value::user_function_value (bool silent)
 {
-  octave_user_function *retval = 0;
+  octave_user_function *retval = nullptr;
 
   if (! silent)
     err_wrong_type_arg ("octave_base_value::user_function_value()",
                         type_name ());
   return retval;
 }
 
 octave_user_script *
 octave_base_value::user_script_value (bool silent)
 {
-  octave_user_script *retval = 0;
+  octave_user_script *retval = nullptr;
 
   if (! silent)
     err_wrong_type_arg ("octave_base_value::user_script_value()", type_name ());
 
   return retval;
 }
 
 octave_user_code *
 octave_base_value::user_code_value (bool silent)
 {
-  octave_user_code *retval = 0;
+  octave_user_code *retval = nullptr;
 
   if (! silent)
     err_wrong_type_arg ("octave_base_value::user_code_value()", type_name ());
 
   return retval;
 }
 
 octave_fcn_handle *
 octave_base_value::fcn_handle_value (bool silent)
 {
-  octave_fcn_handle *retval = 0;
+  octave_fcn_handle *retval = nullptr;
 
   if (! silent)
     err_wrong_type_arg ("octave_base_value::fcn_handle_value()", type_name ());
 
   return retval;
 }
 
 octave_fcn_inline *
 octave_base_value::fcn_inline_value (bool silent)
 {
-  octave_fcn_inline *retval = 0;
+  octave_fcn_inline *retval = nullptr;
 
   if (! silent)
     err_wrong_type_arg ("octave_base_value::fcn_inline_value()", type_name ());
 
   return retval;
 }
 
 octave_value_list
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -80,17 +80,17 @@ octave_bool_matrix::numeric_conversion_f
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
                                             octave_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_bool_matrix::try_narrowing_conversion (void)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   if (matrix.ndims () == 2)
     {
       boolMatrix bm (matrix);
 
       octave_idx_type nr = bm.rows ();
       octave_idx_type nc = bm.cols ();
 
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -69,17 +69,17 @@ octave_sparse_bool_matrix::numeric_conve
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
                                             octave_sparse_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_sparse_bool_matrix::try_narrowing_conversion (void)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   if (Vsparse_auto_mutate)
     {
       // Don't use numel, since it can overflow for very large matrices
       // Note that for the second test, this means it becomes approximative
       // since it involves a cast to double to avoid issues of overflow
       if (matrix.rows () == 1 && matrix.cols () == 1)
         {
diff --git a/libinterp/octave-value/ov-builtin.cc b/libinterp/octave-value/ov-builtin.cc
--- a/libinterp/octave-value/ov-builtin.cc
+++ b/libinterp/octave-value/ov-builtin.cc
@@ -172,9 +172,9 @@ octave_builtin::push_dispatch_class (con
 }
 
 bool
 octave_builtin::handles_dispatch_class (const std::string& dispatch_type) const
 {
   return dispatch_classes.find (dispatch_type) != dispatch_classes.end ();
 }
 
-const std::list<octave_lvalue> *octave_builtin::curr_lvalue_list = 0;
+const std::list<octave_lvalue> *octave_builtin::curr_lvalue_list = nullptr;
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -859,17 +859,17 @@ string_vector
 octave_class::map_keys (void) const
 {
   err_wrong_type_arg ("octave_class::map_keys()", type_name ());
 }
 
 octave_base_value *
 octave_class::find_parent_class (const std::string& parent_class_name)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   if (parent_class_name == class_name ())
     retval = this;
   else
     {
       for (auto& par : parent_list)
         {
           octave_map::const_iterator smap = map.seek (par);
@@ -888,17 +888,17 @@ octave_class::find_parent_class (const s
     }
 
   return retval;
 }
 
 octave_base_value *
 octave_class::unique_parent_class (const std::string& parent_class_name)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   if (parent_class_name == class_name ())
     retval = this;
   else
     {
       for (auto& par : parent_list)
         {
           octave_map::iterator smap = map.seek (par);
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -3528,17 +3528,17 @@ install_classdef (octave::tree_evaluator
   symbol_table::install_built_in_function
     ("meta.event", octave_value (meta_event.get_constructor_function ()));
   symbol_table::install_built_in_function
     ("meta.dynproperty", octave_value (meta_dynproperty.get_constructor_function ()));
 }
 
 //----------------------------------------------------------------------------
 
-cdef_manager *cdef_manager::instance = 0;
+cdef_manager *cdef_manager::instance = nullptr;
 
 void
 cdef_manager::create_instance (void)
 {
   instance = new cdef_manager ();
 
   if (instance)
     singleton_cleanup_list::add (cleanup_instance);
@@ -3595,17 +3595,17 @@ cdef_manager::do_find_class (const std::
 
   return cdef_class ();
 }
 
 octave_function*
 cdef_manager::do_find_method_symbol (const std::string& method_name,
                                      const std::string& class_name)
 {
-  octave_function *retval = 0;
+  octave_function *retval = nullptr;
 
   cdef_class cls = find_class (class_name, false, false);
 
   if (cls.ok ())
     {
       cdef_method meth = cls.find_method (method_name);
 
       if (meth.ok ())
@@ -3655,17 +3655,17 @@ cdef_manager::do_find_package (const std
     }
 
   return retval;
 }
 
 octave_function*
 cdef_manager::do_find_package_symbol (const std::string& pack_name)
 {
-  octave_function *retval = 0;
+  octave_function *retval = nullptr;
 
   cdef_package pack = find_package (pack_name, false);
 
   if (pack.ok ())
     retval = new octave_classdef_meta (pack);
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -101,17 +101,17 @@ octave_complex::numeric_demotion_functio
   return
     octave_base_value::type_conv_info (default_numeric_demotion_function,
                                        octave_float_complex::static_type_id ());
 }
 
 octave_base_value *
 octave_complex::try_narrowing_conversion (void)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   double im = scalar.imag ();
 
   if (im == 0.0)
     retval = new octave_scalar (scalar.real ());
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov-cx-diag.cc b/libinterp/octave-value/ov-cx-diag.cc
--- a/libinterp/octave-value/ov-cx-diag.cc
+++ b/libinterp/octave-value/ov-cx-diag.cc
@@ -73,17 +73,17 @@ octave_complex_diag_matrix::numeric_demo
   return
     octave_base_value::type_conv_info (default_numeric_demotion_function,
                                        octave_float_complex_diag_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_complex_diag_matrix::try_narrowing_conversion (void)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   if (matrix.nelem () == 1)
     {
       retval = new octave_complex (matrix (0, 0));
       octave_base_value *rv2 = retval->try_narrowing_conversion ();
       if (rv2)
         {
           delete retval;
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -80,17 +80,17 @@ octave_complex_matrix::numeric_demotion_
   return octave_base_value::type_conv_info
            (default_numeric_demotion_function,
             octave_float_complex_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_complex_matrix::try_narrowing_conversion (void)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   if (matrix.numel () == 1)
     {
       Complex c = matrix (0);
 
       if (c.imag () == 0.0)
         retval = new octave_scalar (c.real ());
       else
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -53,17 +53,17 @@ along with Octave; see the file COPYING.
 template class OCTINTERP_API octave_base_sparse<SparseComplexMatrix>;
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_sparse_complex_matrix,
                                      "sparse complex matrix", "double");
 
 octave_base_value *
 octave_sparse_complex_matrix::try_narrowing_conversion (void)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   if (Vsparse_auto_mutate)
     {
       int nr = matrix.rows ();
       int nc = matrix.cols ();
 
       // Don't use numel, since it can overflow for very large matrices
       // Note that for the tests on matrix size, they become approximative
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -1921,23 +1921,23 @@ octave_fcn_binder::octave_fcn_binder (co
   : octave_fcn_handle (f), root_handle (root), arg_template (templ),
     arg_mask (mask), expected_nargin (exp_nargin)
 { }
 
 octave_fcn_handle *
 octave_fcn_binder::maybe_binder (const octave_value& f,
                                  octave::tree_evaluator *tw)
 {
-  octave_fcn_handle *retval = 0;
+  octave_fcn_handle *retval = nullptr;
 
   octave_user_function *usr_fcn = f.user_function_value (false);
   octave::tree_parameter_list *param_list = (usr_fcn ? usr_fcn->parameter_list () : 0);
 
-  octave::tree_statement_list *cmd_list = 0;
-  octave::tree_expression *body_expr = 0;
+  octave::tree_statement_list *cmd_list = nullptr;
+  octave::tree_expression *body_expr = nullptr;
 
   if (usr_fcn)
     {
       cmd_list = usr_fcn->body ();
       if (cmd_list)
         {
           // Verify that body is a single expression (always true in theory).
           body_expr = (cmd_list->length () == 1
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -927,17 +927,17 @@ quadv (fcn, 0, 3)
 @end example
 @seealso{inline, formula, argnames}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string old_func;
-  octave_fcn_inline *old = 0;
+  octave_fcn_inline *old = nullptr;
   bool func_is_string = true;
 
   if (args(0).is_string ())
     old_func = args(0).string_value ();
   else
     {
       old = args(0).fcn_inline_value (true);
       func_is_string = false;
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -57,17 +57,17 @@ extern template class OCTINTERP_API octa
 template class octave_base_scalar<FloatComplex>;
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_complex,
                                      "float complex scalar", "single");
 
 octave_base_value *
 octave_float_complex::try_narrowing_conversion (void)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   float im = scalar.imag ();
 
   if (im == 0.0)
     retval = new octave_float_scalar (scalar.real ());
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov-flt-cx-diag.cc b/libinterp/octave-value/ov-flt-cx-diag.cc
--- a/libinterp/octave-value/ov-flt-cx-diag.cc
+++ b/libinterp/octave-value/ov-flt-cx-diag.cc
@@ -53,17 +53,17 @@ octave_float_complex_diag_matrix::numeri
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
                                             octave_float_complex_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_float_complex_diag_matrix::try_narrowing_conversion (void)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   if (matrix.nelem () == 1)
     {
       retval = new octave_float_complex (matrix (0, 0));
       octave_base_value *rv2 = retval->try_narrowing_conversion ();
       if (rv2)
         {
           delete retval;
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -68,17 +68,17 @@ along with Octave; see the file COPYING.
 template class octave_base_matrix<FloatComplexNDArray>;
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_complex_matrix,
                                      "float complex matrix", "single");
 
 octave_base_value *
 octave_float_complex_matrix::try_narrowing_conversion (void)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   if (matrix.numel () == 1)
     {
       FloatComplex c = matrix (0);
 
       if (c.imag () == 0.0)
         retval = new octave_float_scalar (c.real ());
       else
diff --git a/libinterp/octave-value/ov-flt-re-diag.cc b/libinterp/octave-value/ov-flt-re-diag.cc
--- a/libinterp/octave-value/ov-flt-re-diag.cc
+++ b/libinterp/octave-value/ov-flt-re-diag.cc
@@ -52,17 +52,17 @@ octave_float_diag_matrix::numeric_conver
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
                                             octave_float_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_float_diag_matrix::try_narrowing_conversion (void)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   if (matrix.nelem () == 1)
     retval = new octave_float_scalar (matrix (0, 0));
 
   return retval;
 }
 
 DiagMatrix
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -83,17 +83,17 @@ along with Octave; see the file COPYING.
 template class octave_base_matrix<FloatNDArray>;
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_float_matrix, "float matrix",
                                      "single");
 
 octave_base_value *
 octave_float_matrix::try_narrowing_conversion (void)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   if (matrix.numel () == 1)
     retval = new octave_float_scalar (matrix (0));
 
   return retval;
 }
 
 double
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -131,20 +131,20 @@ typedef java_local_ref<jthrowable> jthro
 
 static std::string
 jstring_to_string (JNIEnv *jni_env, jstring s);
 
 static std::string
 jstring_to_string (JNIEnv *jni_env, jobject obj);
 
 static octave_value
-box (JNIEnv *jni_env, void *jobj, void *jcls_arg = 0);
+box (JNIEnv *jni_env, void *jobj, void *jcls_arg = nullptr);
 
 static octave_value
-box_more (JNIEnv *jni_env, void *jobj_arg, void *jcls_arg = 0);
+box_more (JNIEnv *jni_env, void *jobj_arg, void *jcls_arg = nullptr);
 
 static bool
 unbox (JNIEnv *jni_env, const octave_value& val, jobject_ref& jobj,
        jclass_ref& jcls);
 
 static bool
 unbox (JNIEnv *jni_env, const octave_value_list& args,
        jobjectArray_ref& jobjs, jobjectArray_ref& jclss);
@@ -163,17 +163,17 @@ extern "C"
 
   JNIEXPORT void JNICALL
   Java_org_octave_Octave_doEvalString (JNIEnv *, jclass, jstring);
 
   JNIEXPORT jboolean JNICALL
   Java_org_octave_Octave_needThreadedInvokation (JNIEnv *, jclass);
 }
 
-static JavaVM *jvm = 0;
+static JavaVM *jvm = nullptr;
 static bool jvm_attached = false;
 
 // Need to keep hold of the shared library handle until exit.
 static octave::dynamic_library jvm_lib;
 
 static std::map<int,octave_value> listener_map;
 static std::map<int,octave_value> octave_ref_map;
 static int octave_java_refcount = 0;
@@ -701,17 +701,17 @@ jstring_to_string (JNIEnv *jni_env, jobj
     }
 
   return retval;
 }
 
 static inline JNIEnv *
 thread_jni_env (void)
 {
-  JNIEnv *env = 0;
+  JNIEnv *env = nullptr;
 
   if (jvm)
     jvm->GetEnv (reinterpret_cast<void **> (&env), JNI_VERSION_1_2);
 
   return env;
 }
 
 #endif
diff --git a/libinterp/octave-value/ov-java.h b/libinterp/octave-value/ov-java.h
--- a/libinterp/octave-value/ov-java.h
+++ b/libinterp/octave-value/ov-java.h
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 typedef void *voidptr;
 
 class OCTINTERP_API octave_java : public octave_base_value
 {
 public:
 
   octave_java (void);
 
-  octave_java (const voidptr& obj, void *cls = 0);
+  octave_java (const voidptr& obj, void *cls = nullptr);
 
   octave_java (const octave_java& jobj)
     : octave_base_value (jobj), java_object (0), java_class (0)
   {
     init (jobj.java_object, jobj.java_class);
   }
 
   ~octave_java (void) { release (); }
diff --git a/libinterp/octave-value/ov-lazy-idx.cc b/libinterp/octave-value/ov-lazy-idx.cc
--- a/libinterp/octave-value/ov-lazy-idx.cc
+++ b/libinterp/octave-value/ov-lazy-idx.cc
@@ -45,17 +45,17 @@ octave_lazy_index::numeric_conversion_fu
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
                                             octave_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_lazy_index::try_narrowing_conversion (void)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   switch (index.length (0))
     {
     case 1:
       retval = new octave_scalar (static_cast<double> (index(0) + 1));
       break;
 
     case 0:
diff --git a/libinterp/octave-value/ov-perm.cc b/libinterp/octave-value/ov-perm.cc
--- a/libinterp/octave-value/ov-perm.cc
+++ b/libinterp/octave-value/ov-perm.cc
@@ -475,17 +475,17 @@ octave_perm_matrix::numeric_conversion_f
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
                                             octave_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_perm_matrix::try_narrowing_conversion (void)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   if (matrix.numel () == 1)
     retval = new octave_scalar (matrix (0, 0));
 
   return retval;
 }
 
 octave_value
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -73,17 +73,17 @@ octave_range::numeric_conversion_functio
 {
   return octave_base_value::type_conv_info (default_numeric_conversion_function,
                                             octave_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_range::try_narrowing_conversion (void)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   switch (range.numel ())
     {
     case 1:
       retval = new octave_scalar (range.base ());
       break;
 
     case 0:
diff --git a/libinterp/octave-value/ov-re-diag.cc b/libinterp/octave-value/ov-re-diag.cc
--- a/libinterp/octave-value/ov-re-diag.cc
+++ b/libinterp/octave-value/ov-re-diag.cc
@@ -68,17 +68,17 @@ octave_diag_matrix::numeric_demotion_fun
   return octave_base_value::type_conv_info
            (default_numeric_demotion_function,
             octave_float_diag_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_diag_matrix::try_narrowing_conversion (void)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   if (matrix.nelem () == 1)
     retval = new octave_scalar (matrix (0, 0));
 
   return retval;
 }
 
 octave_value
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -98,17 +98,17 @@ octave_matrix::numeric_demotion_function
   return octave_base_value::type_conv_info
            (default_numeric_demotion_function,
             octave_float_matrix::static_type_id ());
 }
 
 octave_base_value *
 octave_matrix::try_narrowing_conversion (void)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   if (matrix.numel () == 1)
     retval = new octave_scalar (matrix (0));
 
   return retval;
 }
 
 double
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -64,17 +64,17 @@ octave_sparse_matrix::index_vector (bool
       std::string nm = "<" + type_name () + ">";
       octave::err_invalid_index (nm.c_str ());
     }
 }
 
 octave_base_value *
 octave_sparse_matrix::try_narrowing_conversion (void)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   if (Vsparse_auto_mutate)
     {
       // Don't use numel, since it can overflow for very large matrices
       // Note that for the second test, this means it becomes approximative
       // since it involves a cast to double to avoid issues of overflow
       if (matrix.rows () == 1 && matrix.cols () == 1)
         {
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -57,17 +57,17 @@ along with Octave; see the file COPYING.
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_char_matrix_str, "string", "char");
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_char_matrix_sq_str, "sq_string",
                                      "char");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   const octave_char_matrix_str& v
     = dynamic_cast<const octave_char_matrix_str&> (a);
 
   NDArray nda = v.array_value (true);
 
   if (nda.numel () == 1)
     retval = new octave_scalar (nda(0));
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -57,17 +57,17 @@ static int Vstruct_levels_to_print = 2;
 
 // TRUE means print struct array contents, up to the number of levels
 // specified by struct_levels_to_print.
 static bool Vprint_struct_array_contents = false;
 
 octave_base_value *
 octave_struct::try_narrowing_conversion (void)
 {
-  octave_base_value *retval = 0;
+  octave_base_value *retval = nullptr;
 
   if (numel () == 1)
     retval = new octave_scalar_struct (map.checkelem (0));
 
   return retval;
 }
 
 Cell
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -175,19 +175,19 @@ private:
 // User-defined functions.
 
 class
 octave_user_function : public octave_user_code
 {
 public:
 
   octave_user_function (symbol_table::scope_id sid = -1,
-                        octave::tree_parameter_list *pl = 0,
-                        octave::tree_parameter_list *rl = 0,
-                        octave::tree_statement_list *cl = 0);
+                        octave::tree_parameter_list *pl = nullptr,
+                        octave::tree_parameter_list *rl = nullptr,
+                        octave::tree_statement_list *cl = nullptr);
 
   // No copying!
 
   octave_user_function (const octave_user_function& fn) = delete;
 
   octave_user_function& operator = (const octave_user_function& fn) = delete;
 
   ~octave_user_function (void);
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -293,17 +293,17 @@ namespace octave
         m_image_path = opts.m_image_path;
         m_all_args = opts.m_all_args;
         m_remaining_args = opts.m_remaining_args;
       }
 
     return *this;
   }
 
-  application *application::instance = 0;
+  application *application::instance = nullptr;
 
   application::application (int argc, char **argv)
     : m_options (argc, argv)
   {
     init ();
   }
 
   application::application (const cmdline_options& opts)
diff --git a/libinterp/octave.h b/libinterp/octave.h
--- a/libinterp/octave.h
+++ b/libinterp/octave.h
@@ -296,17 +296,17 @@ namespace octave
     // TRUE if this is a program and no interpreter and interaction is
     // needed.  For example, an octave program with shebang line, or code
     // from eval without persist.
     bool m_is_octave_program = false;
 
     // If TRUE, the GUI should be started.
     bool m_gui_running = false;
 
-    interpreter *m_interpreter = 0;
+    interpreter *m_interpreter = nullptr;
   };
 
   class OCTINTERP_API cli_application : public application
   {
   public:
 
     cli_application (const cmdline_options& opts = cmdline_options ())
       : application (opts)
diff --git a/libinterp/parse-tree/bp-table.cc b/libinterp/parse-tree/bp-table.cc
--- a/libinterp/parse-tree/bp-table.cc
+++ b/libinterp/parse-tree/bp-table.cc
@@ -52,17 +52,17 @@ along with Octave; see the file COPYING.
 #include "parse.h"
 #include "pt-eval.h"
 #include "pt-exp.h"
 #include "pt-stmt.h"
 #include "sighandlers.h"
 #include "symtab.h"
 
 // Initialize the singleton object
-bp_table *bp_table::instance = 0;
+bp_table *bp_table::instance = nullptr;
 
 std::set<std::string> bp_table::errors_that_stop;
 std::set<std::string> bp_table::caught_that_stop;
 std::set<std::string> bp_table::warnings_that_stop;
 
 // Read entire file called fname and return the contents as a string
 static std::string
 snarf_file (const std::string& fname)
@@ -164,17 +164,17 @@ get_file_line (const std::string& fname,
 
 // Return a pointer to the user-defined function FNAME.  If FNAME is
 // empty, search backward for the first user-defined function in the
 // current call stack.
 
 octave_user_code *
 get_user_code (const std::string& fname)
 {
-  octave_user_code *dbg_fcn = 0;
+  octave_user_code *dbg_fcn = nullptr;
 
   if (fname.empty ())
     dbg_fcn = octave::call_stack::debug_user_code ();
   else
     {
       std::string name = fname;
 
       if (octave::sys::file_ops::dir_sep_char () != '/' && name[0] == '@')
@@ -374,17 +374,17 @@ bp_table::condition_valid (const std::st
     {
       octave::parser parser (cond + " ;"); // ; to reject partial expr like "y=="
       parser.reset ();
       int parse_status = parser.run ();
       if (parse_status)
         error ("dbstop: Cannot parse condition '%s'", cond.c_str ());
       else
         {
-          octave::tree_statement *stmt = 0;
+          octave::tree_statement *stmt = nullptr;
           if (! parser.stmt_list)
             error ("dbstop: "
                    "condition is not empty, but has nothing to evaluate");
           else
             {
               if (parser.stmt_list->length () == 1
                   && (stmt = parser.stmt_list->front ())
                   && stmt->is_expression ())
@@ -540,18 +540,18 @@ bp_table::parse_dbfunction_params (const
               cond = cond.substr (1);   // omit initial space
             }
           else    // stop on event (error, warning, interrupt, NaN/inf)
             {
               std::string condition = args(pos).string_value ();
               int on_off = ! strcmp(who, "dbstop");
 
               // list of error/warning IDs to update
-              std::set<std::string> *id_list = NULL;
-              bool *stop_flag = NULL;         // Vdebug_on_... flag
+              std::set<std::string> *id_list = nullptr;
+              bool *stop_flag = nullptr;         // Vdebug_on_... flag
 
               if (condition == "error")
                 {
                   id_list = &bp_table::errors_that_stop;
                   stop_flag = &Vdebug_on_error;
                 }
               else if (condition == "warning")
                 {
@@ -579,33 +579,33 @@ bp_table::parse_dbfunction_params (const
                            who, condition.c_str ());
 #endif
                 }
               else
                 error ("%s: invalid condition %s",
                        who, condition.c_str ());
 
               // process ID list for "dbstop if error <error_ID>" etc
-              if (id_list != NULL)
+              if (id_list != nullptr)
                 {
                   pos++;
                   if (pos < nargin)       // only affect a single error ID
                     {
                       if (! args(pos).is_string () || nargin > pos+1)
                         error ("%s: ID must be a single string", who);
                       else if (on_off == 1)
                         {
                           id_list->insert (args(pos).string_value ());
-                          *stop_flag = 1;
+                          *stop_flag = true;
                         }
                       else
                         {
                           id_list->erase (args(pos).string_value ());
                           if (id_list->empty ())
-                            *stop_flag = 0;
+                            *stop_flag = false;
                         }
                     }
                   else   // unqualified.  Turn all on or off
                     {
                       id_list->clear ();
                       *stop_flag = on_off;
                       if (stop_flag == &Vdebug_on_error)
                         {
@@ -640,20 +640,20 @@ bp_table::parse_dbfunction_params (const
 %! assert ([s.bkpt(:).line], [48, 100, 201, 58, 100]);
 %! assert (s.errs, {"Octave:undefined-function"});
 */
 
 // Return the sub/nested/main function of MAIN_FCN that contains
 // line number LINENO of the source file.
 // If END_LINE != 0, *END_LINE is set to last line of the returned function.
 static octave_user_code*
-find_fcn_by_line (octave_user_code *main_fcn, int lineno, int *end_line = 0)
+find_fcn_by_line (octave_user_code *main_fcn, int lineno, int *end_line = nullptr)
 {
-  octave_user_code *retval = 0;
-  octave_user_code *next_fcn = 0;  // 1st function starting after lineno
+  octave_user_code *retval = nullptr;
+  octave_user_code *next_fcn = nullptr;  // 1st function starting after lineno
 
   // Find innermost nested (or parent) function containing lineno.
   int earliest_end = std::numeric_limits<int>::max ();
 
   std::map<std::string, octave_value> subfcns = main_fcn->subfunctions ();
   for (const auto& str_val_p : subfcns)
     {
       if (str_val_p.second.is_user_function ())
diff --git a/libinterp/parse-tree/jit-ir.cc b/libinterp/parse-tree/jit-ir.cc
--- a/libinterp/parse-tree/jit-ir.cc
+++ b/libinterp/parse-tree/jit-ir.cc
@@ -639,17 +639,17 @@ jit_phi::prune (void)
 
 bool
 jit_phi::infer (void)
 {
   jit_block *p = parent ();
   if (! p->alive ())
     return false;
 
-  jit_type *infered = 0;
+  jit_type *infered = nullptr;
   for (size_t i = 0; i < argument_count (); ++i)
     {
       jit_block *inc = incomming (i);
       if (inc->branch_alive (p))
         infered = jit_typeinfo::join (infered, argument_type (i));
     }
 
   if (infered != type ())
diff --git a/libinterp/parse-tree/jit-ir.h b/libinterp/parse-tree/jit-ir.h
--- a/libinterp/parse-tree/jit-ir.h
+++ b/libinterp/parse-tree/jit-ir.h
@@ -313,17 +313,17 @@ public:
   size_t index (void) const { return mindex; }
 
   jit_instruction * user (void) const { return muser; }
 
   jit_block * user_parent (void) const;
 
   std::list<jit_block *> user_parent_location (void) const;
 
-  void stash_value (jit_value *avalue, jit_instruction *auser = 0,
+  void stash_value (jit_value *avalue, jit_instruction *auser = nullptr,
                     size_t aindex = -1)
   {
     PARENT_T::stash_value (avalue);
     mindex = aindex;
     muser = auser;
   }
 private:
   jit_instruction *muser;
@@ -416,17 +416,17 @@ public:
     already_infered.push_back (0);
   }
 
   size_t argument_count (void) const
   {
     return marguments.size ();
   }
 
-  void resize_arguments (size_t acount, jit_value *adefault = 0)
+  void resize_arguments (size_t acount, jit_value *adefault = nullptr)
   {
     size_t old = marguments.size ();
     marguments.resize (acount);
     already_infered.resize (acount);
 
     if (adefault)
       for (size_t i = old; i < acount; ++i)
         stash_argument (i, adefault);
diff --git a/libinterp/parse-tree/jit-typeinfo.cc b/libinterp/parse-tree/jit-typeinfo.cc
--- a/libinterp/parse-tree/jit-typeinfo.cc
+++ b/libinterp/parse-tree/jit-typeinfo.cc
@@ -70,17 +70,17 @@ along with Octave; see the file COPYING.
 #include "ov.h"
 #include "ov-builtin.h"
 #include "ov-complex.h"
 #include "ov-scalar.h"
 #include "pager.h"
 
 static llvm::LLVMContext& context = llvm::getGlobalContext ();
 
-jit_typeinfo *jit_typeinfo::instance = 0;
+jit_typeinfo *jit_typeinfo::instance = nullptr;
 
 std::ostream& jit_print (std::ostream& os, jit_type *atype)
 {
   if (! atype)
     return os << "null";
   return os << atype->name ();
 }
 
@@ -650,17 +650,17 @@ jit_function::call (llvm::IRBuilderD& bu
   llvm::BasicBlock *insert_block = builder.GetInsertBlock ();
   llvm::Function *parent = insert_block->getParent ();
   assert (parent);
 
   // we insert allocas inside the prelude block to prevent stack overflows
   llvm::BasicBlock& prelude = parent->getEntryBlock ();
   llvm::IRBuilder<> pre_builder (&prelude, prelude.begin ());
 
-  llvm::AllocaInst *sret_mem = 0;
+  llvm::AllocaInst *sret_mem = nullptr;
   if (sret ())
     {
       sret_mem = pre_builder.CreateAlloca (mresult->packed_type (call_conv));
       llvm_args.push_back (sret_mem);
     }
 
   for (size_t i = 0; i < in_args.size (); ++i)
     {
diff --git a/libinterp/parse-tree/jit-typeinfo.h b/libinterp/parse-tree/jit-typeinfo.h
--- a/libinterp/parse-tree/jit-typeinfo.h
+++ b/libinterp/parse-tree/jit-typeinfo.h
@@ -248,17 +248,17 @@ public:
     do_add_mapping (engine, reinterpret_cast<void *> (fn));
   }
 
   bool valid (void) const { return llvm_function; }
 
   std::string name (void) const;
 
   llvm::BasicBlock * new_block (const std::string& aname = "body",
-                                llvm::BasicBlock *insert_before = 0);
+                                llvm::BasicBlock *insert_before = nullptr);
 
   llvm::Value * call (llvm::IRBuilderD& builder,
                       const std::vector<jit_value *>& in_args) const;
 
   llvm::Value * call (llvm::IRBuilderD& builder,
                       const std::vector<llvm::Value *>& in_args
                       = std::vector<llvm::Value *> ()) const;
 
@@ -281,17 +281,17 @@ public:
   JIT_CALL (3);
 
 #undef JIT_CALL
 #undef JIT_PARAMS
 #undef JIT_PARAM_ARGS
 
   llvm::Value * argument (llvm::IRBuilderD& builder, size_t idx) const;
 
-  void do_return (llvm::IRBuilderD& builder, llvm::Value *rval = 0,
+  void do_return (llvm::IRBuilderD& builder, llvm::Value *rval = nullptr,
                   bool verify = true);
 
   llvm::Function * to_llvm (void) const { return llvm_function; }
 
   // If true, then the return value is passed as a pointer in the first argument
   bool sret (void) const { return mresult && mresult->sret (call_conv); }
 
   bool can_error (void) const { return mcan_error; }
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -541,17 +541,17 @@ namespace octave
         comment_list = 0;
       }
 
     private:
 
       octave_comment_list *comment_list;
     };
 
-    base_lexer (interpreter *interp_context = 0)
+    base_lexer (interpreter *interp_context = nullptr)
       : lexical_feedback (), scanner (0), input_buf (), comment_buf (),
         m_interp_context (interp_context)
     {
       init ();
     }
 
     // No copying!
 
@@ -695,17 +695,17 @@ namespace octave
     int handle_assign_op (const char *pattern, int tok);
 
     int handle_language_extension_assign_op (const char *pattern, int tok);
 
     int handle_op_internal (int tok, bool bos, bool compat);
 
     int handle_token (const std::string& name, int tok);
 
-    int handle_token (int tok, token *tok_val = 0);
+    int handle_token (int tok, token *tok_val = nullptr);
 
     int count_token (int tok);
 
     int count_token_internal (int tok);
 
     int show_token (int tok);
 
     void enable_fq_identifier (void);
@@ -715,26 +715,26 @@ namespace octave
     std::stack<int> start_state_stack;
   };
 
   class
   lexer : public base_lexer
   {
   public:
 
-    lexer (interpreter *interp_context = 0)
+    lexer (interpreter *interp_context = nullptr)
       : base_lexer (interp_context), reader (this)
     { }
 
-    lexer (FILE *file, interpreter *interp_context = 0)
+    lexer (FILE *file, interpreter *interp_context = nullptr)
       : base_lexer (interp_context), reader (file, this)
     { }
 
     lexer (const std::string& eval_string,
-           interpreter *interp_context = 0)
+           interpreter *interp_context = nullptr)
       : base_lexer (interp_context), reader (eval_string, this)
     { }
 
     // No copying!
 
     lexer (const lexer&) = delete;
 
     lexer& operator = (const lexer&) = delete;
@@ -779,37 +779,37 @@ namespace octave
     input_reader reader;
   };
 
   class
   push_lexer : public base_lexer
   {
   public:
 
-    push_lexer (interpreter *interp_context = 0)
+    push_lexer (interpreter *interp_context = nullptr)
       : base_lexer (interp_context), pflag (1)
     {
       append_input ("", false);
     }
 
     push_lexer (const std::string& input,
-                interpreter *interp_context = 0)
+                interpreter *interp_context = nullptr)
       : base_lexer (interp_context), pflag (1)
     {
       append_input (input, false);
     }
 
-    push_lexer (bool eof, interpreter *interp_context = 0)
+    push_lexer (bool eof, interpreter *interp_context = nullptr)
       : base_lexer (interp_context), pflag (1)
     {
       append_input ("", eof);
     }
 
     push_lexer (const std::string& input, bool eof,
-                interpreter *interp_context = 0)
+                interpreter *interp_context = nullptr)
       : base_lexer (interp_context), pflag (1)
     {
       append_input (input, eof);
     }
 
     // No copying!
 
     push_lexer (const push_lexer&) = delete;
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -115,17 +115,17 @@ namespace octave
             break;
           }
       }
 
     return retval;
   }
 }
 
-static const octave_value *indexed_object = 0;
+static const octave_value *indexed_object = nullptr;
 static int index_position = 0;
 static int num_indices = 0;
 
 // END is documented in op-kw-docs.
 DEFCONSTFUN (end, , ,
              doc: /* -*- texinfo -*-
                      @deftypefn {} {} end
                      Last element of an array or the end of any @code{for}, @code{parfor},
diff --git a/libinterp/parse-tree/pt-arg-list.h b/libinterp/parse-tree/pt-arg-list.h
--- a/libinterp/parse-tree/pt-arg-list.h
+++ b/libinterp/parse-tree/pt-arg-list.h
@@ -86,17 +86,17 @@ namespace octave
 
     bool is_simple_assign_lhs (void) { return simple_assign_lhs; }
 
     bool all_elements_are_constant (void) const;
 
     bool is_valid_lvalue_list (void) const;
 
     octave_value_list convert_to_const_vector (tree_evaluator *tw,
-                                               const octave_value *object = 0);
+                                               const octave_value *object = nullptr);
 
     std::list<octave_lvalue> lvalue_list (tree_evaluator *tw);
 
     string_vector get_arg_names (void) const;
 
     std::list<std::string> variable_names (void) const;
 
     tree_argument_list * dup (symbol_table::scope_id scope,
diff --git a/libinterp/parse-tree/pt-array-list.h b/libinterp/parse-tree/pt-array-list.h
--- a/libinterp/parse-tree/pt-array-list.h
+++ b/libinterp/parse-tree/pt-array-list.h
@@ -41,17 +41,17 @@ namespace octave
   {
   public:
 
     typedef octave::base_list<tree_argument_list *>::iterator iterator;
     typedef octave::base_list<tree_argument_list *>::const_iterator const_iterator;
 
   protected:
 
-    tree_array_list (tree_argument_list *row = 0, int l = -1, int c = -1)
+    tree_array_list (tree_argument_list *row = nullptr, int l = -1, int c = -1)
       : tree_expression (l, c), octave::base_list<tree_argument_list *> ()
     {
       if (row)
         append (row);
     }
 
   public:
 
diff --git a/libinterp/parse-tree/pt-cell.h b/libinterp/parse-tree/pt-cell.h
--- a/libinterp/parse-tree/pt-cell.h
+++ b/libinterp/parse-tree/pt-cell.h
@@ -39,17 +39,17 @@ namespace octave
   class tree_argument_list;
 
   // General cells.
 
   class tree_cell : public tree_array_list
   {
   public:
 
-    tree_cell (tree_argument_list *row = 0, int l = -1, int c = -1)
+    tree_cell (tree_argument_list *row = nullptr, int l = -1, int c = -1)
       : tree_array_list (row, l, c)
     { }
 
     // No copying!
 
     tree_cell (const tree_cell&) = delete;
 
     tree_cell& operator = (const tree_cell&) = delete;
diff --git a/libinterp/parse-tree/pt-classdef.h b/libinterp/parse-tree/pt-classdef.h
--- a/libinterp/parse-tree/pt-classdef.h
+++ b/libinterp/parse-tree/pt-classdef.h
@@ -37,17 +37,18 @@ class octave_value;
 #include <list>
 
 namespace octave
 {
   class tree_classdef_attribute
   {
   public:
 
-    tree_classdef_attribute (tree_identifier *i = 0, tree_expression *e = 0)
+    tree_classdef_attribute (tree_identifier *i = nullptr,
+                             tree_expression *e = nullptr)
       : id (i), expr (e), neg (false) { }
 
     tree_classdef_attribute (tree_identifier *i, bool b)
       : id (i), expr (0), neg (b) { }
 
     // No copying!
 
     tree_classdef_attribute (const tree_classdef_attribute&) = delete;
@@ -209,17 +210,17 @@ namespace octave
     // Comment preceding END token.
     octave_comment_list *trail_comm;
   };
 
   class tree_classdef_property
   {
   public:
 
-    tree_classdef_property (tree_identifier *i = 0, tree_expression *e = 0)
+    tree_classdef_property (tree_identifier *i = nullptr, tree_expression *e = nullptr)
       : id (i), expr (e) { }
 
     // No copying!
 
     tree_classdef_property (const tree_classdef_property&) = delete;
 
     tree_classdef_property& operator = (const tree_classdef_property&) = delete;
 
@@ -347,17 +348,17 @@ namespace octave
       tw.visit_classdef_methods_block (*this);
     }
   };
 
   class tree_classdef_event
   {
   public:
 
-    tree_classdef_event (tree_identifier *i = 0) : id (i) { }
+    tree_classdef_event (tree_identifier *i = nullptr) : id (i) { }
 
     // No copying!
 
     tree_classdef_event (const tree_classdef_event&) = delete;
 
     tree_classdef_event& operator = (const tree_classdef_event&) = delete;
 
     ~tree_classdef_event (void)
diff --git a/libinterp/parse-tree/pt-colon.cc b/libinterp/parse-tree/pt-colon.cc
--- a/libinterp/parse-tree/pt-colon.cc
+++ b/libinterp/parse-tree/pt-colon.cc
@@ -34,17 +34,17 @@ along with Octave; see the file COPYING.
 
 namespace octave
 {
   // Colon expressions.
 
   tree_colon_expression *
   tree_colon_expression::append (tree_expression *t)
   {
-    tree_colon_expression *retval = 0;
+    tree_colon_expression *retval = nullptr;
 
     if (! op_base)
       error ("invalid colon expression");
 
     if (op_limit)
       {
         if (op_increment)
           error ("invalid colon expression");
diff --git a/libinterp/parse-tree/pt-decl.h b/libinterp/parse-tree/pt-decl.h
--- a/libinterp/parse-tree/pt-decl.h
+++ b/libinterp/parse-tree/pt-decl.h
@@ -41,17 +41,17 @@ namespace octave
   class tree_identifier;
 
   // List of expressions that make up a declaration statement.
 
   class tree_decl_elt
   {
   public:
 
-    tree_decl_elt (tree_identifier *i = 0, tree_expression *e = 0)
+    tree_decl_elt (tree_identifier *i = nullptr, tree_expression *e = nullptr)
       : id (i), expr (e) { }
 
     // No copying!
 
     tree_decl_elt (const tree_decl_elt&) = delete;
 
     tree_decl_elt& operator = (const tree_decl_elt&) = delete;
 
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -980,17 +980,17 @@ namespace octave
         // If this identifier refers to a function, we need to know
         // whether it is indexed so that we can do the same thing
         // for 'f' and 'f()'.  If the index is present and the function
         // object declares it can handle it, return the function object
         // and let tree_index_expression::rvalue handle indexing.
         // Otherwise, arrange to call the function here, so that we don't
         // return the function definition as a value.
 
-        octave_function *fcn = 0;
+        octave_function *fcn = nullptr;
 
         if (val.is_function ())
           fcn = val.function_value (true);
 
         int nargout = m_nargout_stack.top ();
 
         if (fcn && ! (expr.is_postfix_indexed ()
                       && fcn->is_postfix_index_handled (expr.postfix_index ())))
diff --git a/libinterp/parse-tree/pt-eval.h b/libinterp/parse-tree/pt-eval.h
--- a/libinterp/parse-tree/pt-eval.h
+++ b/libinterp/parse-tree/pt-eval.h
@@ -223,34 +223,34 @@ namespace octave
 
     // The context for the current evaluation.
     static stmt_list_type statement_context;
 
     // TRUE means we are evaluating some kind of looping construct.
     static bool in_loop_command;
 
     octave_value evaluate (tree_expression *expr, int nargout = 1,
-                           const std::list<octave_lvalue> *lvalue_list = 0)
+                           const std::list<octave_lvalue> *lvalue_list = nullptr)
     {
       m_nargout_stack.push (nargout);
       m_lvalue_list_stack.push (lvalue_list);
 
       expr->accept (*this);
 
       m_nargout_stack.pop ();
       m_lvalue_list_stack.pop ();
 
       octave_value_list tmp = m_value_stack.pop ();
 
       return tmp.empty () ? octave_value () : tmp(0);
     }
 
     octave_value_list
     evaluate_n (tree_expression *expr, int nargout = 1,
-                const std::list<octave_lvalue> *lvalue_list = 0)
+                const std::list<octave_lvalue> *lvalue_list = nullptr)
     {
       m_nargout_stack.push (nargout);
       m_lvalue_list_stack.push (lvalue_list);
 
       expr->accept (*this);
 
       m_nargout_stack.pop ();
       m_lvalue_list_stack.pop ();
diff --git a/libinterp/parse-tree/pt-except.h b/libinterp/parse-tree/pt-except.h
--- a/libinterp/parse-tree/pt-except.h
+++ b/libinterp/parse-tree/pt-except.h
@@ -42,19 +42,19 @@ namespace octave
   public:
 
     tree_try_catch_command (int l = -1, int c = -1)
       : tree_command (l, c), try_code (0), catch_code (0), expr_id (0),
         lead_comm (0), mid_comm (0), trail_comm (0) { }
 
     tree_try_catch_command (tree_statement_list *tc, tree_statement_list *cc,
                             tree_identifier *id,
-                            octave_comment_list *cl = 0,
-                            octave_comment_list *cm = 0,
-                            octave_comment_list *ct = 0,
+                            octave_comment_list *cl = nullptr,
+                            octave_comment_list *cm = nullptr,
+                            octave_comment_list *ct = nullptr,
                             int l = -1, int c = -1)
       : tree_command (l, c), try_code (tc), catch_code (cc), expr_id (id),
         lead_comm (cl), mid_comm (cm), trail_comm (ct) { }
 
     // No copying!
 
     tree_try_catch_command (const tree_try_catch_command&) = delete;
 
@@ -110,19 +110,19 @@ namespace octave
   public:
 
     tree_unwind_protect_command (int l = -1, int c = -1)
       : tree_command (l, c), unwind_protect_code (0), cleanup_code (0),
         lead_comm (0), mid_comm (0), trail_comm (0) { }
 
     tree_unwind_protect_command (tree_statement_list *tc,
                                  tree_statement_list *cc,
-                                 octave_comment_list *cl = 0,
-                                 octave_comment_list *cm = 0,
-                                 octave_comment_list *ct = 0,
+                                 octave_comment_list *cl = nullptr,
+                                 octave_comment_list *cm = nullptr,
+                                 octave_comment_list *ct = nullptr,
                                  int l = -1, int c = -1)
       : tree_command (l, c), unwind_protect_code (tc), cleanup_code (cc),
         lead_comm (cl), mid_comm (cm), trail_comm (ct) { }
 
     // No copying!
 
     tree_unwind_protect_command (const tree_unwind_protect_command&) = delete;
 
diff --git a/libinterp/parse-tree/pt-idx.h b/libinterp/parse-tree/pt-idx.h
--- a/libinterp/parse-tree/pt-idx.h
+++ b/libinterp/parse-tree/pt-idx.h
@@ -44,17 +44,17 @@ namespace octave
   class tree_evaluator;
 
   // Index expressions.
 
   class tree_index_expression : public tree_expression
   {
   public:
 
-    tree_index_expression (tree_expression *e = 0, tree_argument_list *lst = 0,
+    tree_index_expression (tree_expression *e = nullptr, tree_argument_list *lst = nullptr,
                            int l = -1, int c = -1, char t = '(');
 
     tree_index_expression (tree_expression *e, const std::string& n,
                            int l = -1, int c = -1);
 
     tree_index_expression (tree_expression *e, tree_expression *df,
                            int l = -1, int c = -1);
 
@@ -63,17 +63,17 @@ namespace octave
     tree_index_expression (const tree_index_expression&) = delete;
 
     tree_index_expression& operator = (const tree_index_expression&) = delete;
 
     ~tree_index_expression (void);
 
     bool has_magic_end (void) const;
 
-    void append (tree_argument_list *lst = 0, char t = '(');
+    void append (tree_argument_list *lst = nullptr, char t = '(');
 
     void append (const std::string& n);
 
     void append (tree_expression *df);
 
     bool is_index_expression (void) const { return true; }
 
     std::string name (void) const;
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -171,25 +171,25 @@ jit_convert::jit_convert (octave_user_fu
             throw jit_fail_exception ("Too many parameter to function");
 
           tree_decl_elt *elt = *piter;
           std::string name = elt->name ();
           create_variable (name, args[i]);
         }
     }
 
-  jit_value *return_value = 0;
+  jit_value *return_value = nullptr;
   bool all_breaking = false;
   if (fcn.is_special_expr ())
     {
       tree_expression *expr = fcn.special_expr ();
       if (expr)
         {
           jit_variable *retvar = get_variable ("#return");
-          jit_value *retval = 0;
+          jit_value *retval = nullptr;
           try
             {
               retval = visit (expr);
             }
           catch (const jit_break_exception&)
             { }
 
           if (breaks.size () || continues.size ())
diff --git a/libinterp/parse-tree/pt-jit.h b/libinterp/parse-tree/pt-jit.h
--- a/libinterp/parse-tree/pt-jit.h
+++ b/libinterp/parse-tree/pt-jit.h
@@ -39,17 +39,17 @@ class octave_value_list;
 class
 jit_convert : public tree_walker
 {
 public:
   typedef std::pair<jit_type *, std::string> type_bound;
   typedef std::vector<type_bound> type_bound_vector;
   typedef std::map<std::string, jit_variable *> variable_map;
 
-  jit_convert (tree& tee, jit_type *for_bounds = 0);
+  jit_convert (tree& tee, jit_type *for_bounds = nullptr);
 
   jit_convert (octave_user_function& fcn, const std::vector<jit_type *>& args);
 
 #define DECL_ARG(n) const ARG ## n& arg ## n
 #define JIT_CREATE_CHECKED(N)                                           \
   template <OCT_MAKE_DECL_LIST (typename, ARG, N)>                      \
   jit_call * create_checked (OCT_MAKE_LIST (DECL_ARG, N))               \
   {                                                                     \
@@ -222,17 +222,17 @@ private:
   { return next_name ("#for_bounds", for_bounds_count, inc); }
 
   std::string next_shortcircut_result (bool inc = true)
   { return next_name ("#shortcircut_result", short_count, inc); }
 
   std::string next_name (const char *prefix, size_t& count, bool inc);
 
   jit_instruction * resolve (tree_index_expression& exp,
-                             jit_value *extra_arg = 0, bool lhs = false);
+                             jit_value *extra_arg = nullptr, bool lhs = false);
 
   jit_value * do_assign (tree_expression *exp, jit_value *rhs,
                          bool artificial = false);
 
   jit_value * do_assign (const std::string& lhs, jit_value *rhs, bool print,
                          bool artificial = false);
 
   jit_value * visit (tree *tee) { return visit (*tee); }
@@ -434,17 +434,17 @@ public:
   bool execute (const vmap& extra_vars = vmap ()) const;
 
   bool match (const vmap& extra_vars = vmap ()) const;
 private:
   typedef jit_convert::type_bound type_bound;
   typedef jit_convert::type_bound_vector type_bound_vector;
   typedef void (*jited_function)(octave_base_value**);
 
-  void compile (tree_jit& tjit, tree& tee, jit_type *for_bounds = 0);
+  void compile (tree_jit& tjit, tree& tee, jit_type *for_bounds = nullptr);
 
   octave_value find (const vmap& extra_vars, const std::string& vname) const;
 
   llvm::ExecutionEngine *engine;
   jited_function function;
   llvm::Function *llvm_function;
 
   std::vector<std::pair<std::string, bool> > arguments;
diff --git a/libinterp/parse-tree/pt-loop.h b/libinterp/parse-tree/pt-loop.h
--- a/libinterp/parse-tree/pt-loop.h
+++ b/libinterp/parse-tree/pt-loop.h
@@ -50,29 +50,29 @@ namespace octave
       : tree_command (l, c), expr (0), list (0), lead_comm (0),
         trail_comm (0)
 #if defined (HAVE_LLVM)
       , compiled (0)
 #endif
     { }
 
     tree_while_command (tree_expression *e,
-                        octave_comment_list *lc = 0,
-                        octave_comment_list *tc = 0,
+                        octave_comment_list *lc = nullptr,
+                        octave_comment_list *tc = nullptr,
                         int l = -1, int c = -1)
       : tree_command (l, c), expr (e), list (0), lead_comm (lc),
         trail_comm (tc)
 #if defined (HAVE_LLVM)
       , compiled (0)
 #endif
     { }
 
     tree_while_command (tree_expression *e, tree_statement_list *lst,
-                        octave_comment_list *lc = 0,
-                        octave_comment_list *tc = 0,
+                        octave_comment_list *lc = nullptr,
+                        octave_comment_list *tc = nullptr,
                         int l = -1, int c = -1)
       : tree_command (l, c), expr (e), list (lst), lead_comm (lc),
         trail_comm (tc)
 #if defined (HAVE_LLVM)
       , compiled (0)
 #endif
     { }
 
@@ -140,24 +140,24 @@ namespace octave
   class tree_do_until_command : public tree_while_command
   {
   public:
 
     tree_do_until_command (int l = -1, int c = -1)
       : tree_while_command (l, c) { }
 
     tree_do_until_command (tree_expression *e,
-                           octave_comment_list *lc = 0,
-                           octave_comment_list *tc = 0,
+                           octave_comment_list *lc = nullptr,
+                           octave_comment_list *tc = nullptr,
                            int l = -1, int c = -1)
       : tree_while_command (e, lc, tc, l, c) { }
 
     tree_do_until_command (tree_expression *e, tree_statement_list *lst,
-                           octave_comment_list *lc = 0,
-                           octave_comment_list *tc = 0,
+                           octave_comment_list *lc = nullptr,
+                           octave_comment_list *tc = nullptr,
                            int l = -1, int c = -1)
       : tree_while_command (e, lst, lc, tc, l, c) { }
 
     // No copying!
 
     tree_do_until_command (const tree_do_until_command&) = delete;
 
     tree_do_until_command& operator = (const tree_do_until_command&) = delete;
@@ -186,18 +186,18 @@ namespace octave
       , compiled (0)
 #endif
     { }
 
     tree_simple_for_command (bool parallel_arg, tree_expression *le,
                              tree_expression *re,
                              tree_expression *maxproc_arg,
                              tree_statement_list *lst,
-                             octave_comment_list *lc = 0,
-                             octave_comment_list *tc = 0,
+                             octave_comment_list *lc = nullptr,
+                             octave_comment_list *tc = nullptr,
                              int l = -1, int c = -1)
       : tree_command (l, c), parallel (parallel_arg), lhs (le),
         expr (re), maxproc (maxproc_arg), list (lst),
         lead_comm (lc), trail_comm (tc)
 #if defined (HAVE_LLVM)
       , compiled (0)
 #endif
     { }
@@ -280,18 +280,18 @@ namespace octave
   public:
 
     tree_complex_for_command (int l = -1, int c = -1)
       : tree_command (l, c), lhs (0), expr (0), list (0), lead_comm (0),
         trail_comm (0) { }
 
     tree_complex_for_command (tree_argument_list *le, tree_expression *re,
                               tree_statement_list *lst,
-                              octave_comment_list *lc = 0,
-                              octave_comment_list *tc = 0,
+                              octave_comment_list *lc = nullptr,
+                              octave_comment_list *tc = nullptr,
                               int l = -1, int c = -1)
       : tree_command (l, c), lhs (le), expr (re), list (lst),
         lead_comm (lc), trail_comm (tc) { }
 
     // No copying!
 
     tree_complex_for_command (const tree_complex_for_command&) = delete;
 
diff --git a/libinterp/parse-tree/pt-mat.h b/libinterp/parse-tree/pt-mat.h
--- a/libinterp/parse-tree/pt-mat.h
+++ b/libinterp/parse-tree/pt-mat.h
@@ -45,17 +45,17 @@ namespace octave
 
   // General matrices.  This allows us to construct matrices from
   // other matrices, variables, and functions.
 
   class tree_matrix : public tree_array_list
   {
   public:
 
-    tree_matrix (tree_argument_list *row = 0, int l = -1, int c = -1)
+    tree_matrix (tree_argument_list *row = nullptr, int l = -1, int c = -1)
       : tree_array_list (row, l, c)
     { }
 
     // No copying!
 
     tree_matrix (const tree_matrix&) = delete;
 
     tree_matrix& operator = (const tree_matrix&) = delete;
diff --git a/libinterp/parse-tree/pt-select.h b/libinterp/parse-tree/pt-select.h
--- a/libinterp/parse-tree/pt-select.h
+++ b/libinterp/parse-tree/pt-select.h
@@ -40,22 +40,22 @@ namespace octave
 
   class tree_if_clause : public tree
   {
   public:
 
     tree_if_clause (int l = -1, int c = -1)
       : tree (l, c), expr (0), list (0), lead_comm (0) { }
 
-    tree_if_clause (tree_statement_list *sl, octave_comment_list *lc = 0,
+    tree_if_clause (tree_statement_list *sl, octave_comment_list *lc = nullptr,
                     int l = -1, int c = -1)
       : tree (l, c), expr (0), list (sl), lead_comm (lc) { }
 
     tree_if_clause (tree_expression *e, tree_statement_list *sl,
-                    octave_comment_list *lc = 0,
+                    octave_comment_list *lc = nullptr,
                     int l = -1, int c = -1)
       : tree (l, c), expr (e), list (sl), lead_comm (lc) { }
 
     // No copying!
 
     tree_if_clause (const tree_if_clause&) = delete;
 
     tree_if_clause& operator = (const tree_if_clause&) = delete;
@@ -172,22 +172,22 @@ namespace octave
 
   class tree_switch_case : public tree
   {
   public:
 
     tree_switch_case (int l = -1, int c = -1)
       : tree (l, c), label (0), list (0), lead_comm (0) { }
 
-    tree_switch_case (tree_statement_list *sl, octave_comment_list *lc = 0,
+    tree_switch_case (tree_statement_list *sl, octave_comment_list *lc = nullptr,
                       int l = -1, int c = -1)
       : tree (l, c), label (0), list (sl), lead_comm (lc) { }
 
     tree_switch_case (tree_expression *e, tree_statement_list *sl,
-                      octave_comment_list *lc = 0,
+                      octave_comment_list *lc = nullptr,
                       int l = -1, int c = -1)
       : tree (l, c), label (e), list (sl), lead_comm (lc) { }
 
     // No copying!
 
     tree_switch_case (const tree_switch_case&) = delete;
 
     tree_switch_case& operator = (const tree_switch_case&) = delete;
diff --git a/libinterp/parse-tree/pt.h b/libinterp/parse-tree/pt.h
--- a/libinterp/parse-tree/pt.h
+++ b/libinterp/parse-tree/pt.h
@@ -37,17 +37,17 @@ namespace octave
 
   // Base class for the parse tree.
 
   class tree
   {
   public:
 
     tree (int l = -1, int c = -1)
-      : line_num (l), column_num (c), bp (NULL) { }
+      : line_num (l), column_num (c), bp (nullptr) { }
 
     // No copying!
 
     tree (const tree&) = delete;
 
     tree& operator = (const tree&) = delete;
 
     virtual ~tree (void) = default;
@@ -69,17 +69,17 @@ namespace octave
     virtual void set_breakpoint (const std::string& condition)
     {
       if (bp)
         *bp = condition;
       else
         bp = new std::string(condition);
     }
 
-    virtual void delete_breakpoint (void) { if (bp) delete bp; bp = NULL; }
+    virtual void delete_breakpoint (void) { if (bp) delete bp; bp = nullptr; }
 
     bool meets_bp_condition (void) const;
 
     bool is_breakpoint (bool check_active = false) const
     { return bp && (! check_active || meets_bp_condition ()); }
 
     // breakpoint condition, or "0" (i.e., "false") if no breakpoint.
     // To distinguish "0" from a disabled breakpoint, test "is_breakpoint" too.
diff --git a/liboctave/array/CSparse.cc b/liboctave/array/CSparse.cc
--- a/liboctave/array/CSparse.cc
+++ b/liboctave/array/CSparse.cc
@@ -5512,17 +5512,17 @@ SparseComplexMatrix::bsolve (MatrixType&
 
 void *
 SparseComplexMatrix::factorize (octave_idx_type& err, double& rcond,
                                 Matrix& Control, Matrix& Info,
                                 solve_singularity_handler sing_handler,
                                 bool calc_cond) const
 {
   // The return values
-  void *Numeric = 0;
+  void *Numeric = nullptr;
   err = 0;
 
 #if defined (HAVE_UMFPACK)
 
   // Setup the control parameters
   Control = Matrix (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   UMFPACK_ZNAME (defaults) (control);
diff --git a/liboctave/array/dSparse.cc b/liboctave/array/dSparse.cc
--- a/liboctave/array/dSparse.cc
+++ b/liboctave/array/dSparse.cc
@@ -5700,17 +5700,17 @@ SparseMatrix::bsolve (MatrixType& mattyp
 }
 
 void *
 SparseMatrix::factorize (octave_idx_type& err, double& rcond, Matrix& Control,
                          Matrix& Info, solve_singularity_handler sing_handler,
                          bool calc_cond) const
 {
   // The return values
-  void *Numeric = 0;
+  void *Numeric = nullptr;
   err = 0;
 
 #if defined (HAVE_UMFPACK)
 
   // Setup the control parameters
   Control = Matrix (UMFPACK_CONTROL, 1);
   double *control = Control.fortran_vec ();
   UMFPACK_DNAME (defaults) (control);
diff --git a/liboctave/numeric/DASPK.cc b/liboctave/numeric/DASPK.cc
--- a/liboctave/numeric/DASPK.cc
+++ b/liboctave/numeric/DASPK.cc
@@ -468,18 +468,18 @@ DASPK::do_integrate (double tout)
   F77_INT *pinfo = info.fortran_vec ();
 
   double *prel_tol = rel_tol.fortran_vec ();
   double *pabs_tol = abs_tol.fortran_vec ();
 
   double *prwork = rwork.fortran_vec ();
   F77_INT *piwork = iwork.fortran_vec ();
 
-  double *dummy = 0;
-  F77_INT *idummy = 0;
+  double *dummy = nullptr;
+  F77_INT *idummy = nullptr;
 
   F77_INT tmp_istate = octave::to_f77_int (istate);
 
   F77_XFCN (ddaspk, DDASPK, (ddaspk_f, nn, t, px, pxdot, tout, pinfo,
                              prel_tol, pabs_tol, tmp_istate, prwork, lrw,
                              piwork, liw, dummy, idummy, ddaspk_j,
                              ddaspk_psol));
 
diff --git a/liboctave/numeric/DASRT.cc b/liboctave/numeric/DASRT.cc
--- a/liboctave/numeric/DASRT.cc
+++ b/liboctave/numeric/DASRT.cc
@@ -314,18 +314,18 @@ DASRT::integrate (double tout)
   double *prel_tol = rel_tol.fortran_vec ();
   double *pabs_tol = abs_tol.fortran_vec ();
 
   double *prwork = rwork.fortran_vec ();
   F77_INT *piwork = iwork.fortran_vec ();
 
   F77_INT *pjroot = jroot.fortran_vec ();
 
-  double *dummy = 0;
-  F77_INT *idummy = 0;
+  double *dummy = nullptr;
+  F77_INT *idummy = nullptr;
 
   F77_INT tmp_istate = octave::to_f77_int (istate);
 
   F77_XFCN (ddasrt, DDASRT, (ddasrt_f, nn, t, px, pxdot, tout, pinfo,
                              prel_tol, pabs_tol, tmp_istate, prwork, lrw,
                              piwork, liw, dummy, idummy, ddasrt_j,
                              ddasrt_g, ng, pjroot));
 
diff --git a/liboctave/numeric/DASSL.cc b/liboctave/numeric/DASSL.cc
--- a/liboctave/numeric/DASSL.cc
+++ b/liboctave/numeric/DASSL.cc
@@ -280,18 +280,18 @@ DASSL::do_integrate (double tout)
   F77_INT *pinfo = info.fortran_vec ();
 
   double *prel_tol = rel_tol.fortran_vec ();
   double *pabs_tol = abs_tol.fortran_vec ();
 
   double *prwork = rwork.fortran_vec ();
   F77_INT *piwork = iwork.fortran_vec ();
 
-  double *dummy = 0;
-  F77_INT *idummy = 0;
+  double *dummy = nullptr;
+  F77_INT *idummy = nullptr;
 
   F77_INT tmp_istate = octave::to_f77_int (istate);
 
   F77_XFCN (ddassl, DDASSL, (ddassl_f, nn, t, px, pxdot, tout, pinfo,
                              prel_tol, pabs_tol, tmp_istate, prwork, lrw,
                              piwork, liw, dummy, idummy, ddassl_j));
 
   istate = tmp_istate;
diff --git a/liboctave/numeric/oct-fftw.cc b/liboctave/numeric/oct-fftw.cc
--- a/liboctave/numeric/oct-fftw.cc
+++ b/liboctave/numeric/oct-fftw.cc
@@ -41,17 +41,17 @@ along with Octave; see the file COPYING.
 #if defined (HAVE_FFTW3_THREADS) || defined (HAVE_FFTW3F_THREADS)
 #  include "nproc-wrapper.h"
 #endif
 
 namespace octave
 {
 #if defined (HAVE_FFTW)
 
-  fftw_planner *fftw_planner::instance = 0;
+  fftw_planner *fftw_planner::instance = nullptr;
 
   // Helper class to create and cache FFTW plans for both 1D and
   // 2D.  This implementation defaults to using FFTW_ESTIMATE to create
   // the plans, which in theory is suboptimal, but provides quite
   // reasonable performance in practice.
 
   // Also note that if FFTW_ESTIMATE is not used then the planner in FFTW3
   // will destroy the input and output arrays.  We must, therefore, create a
@@ -417,17 +417,17 @@ namespace octave
             rplan = plan[0] = plan[1] = 0;
           }
       }
     else
       ret = UNKNOWN;
     return ret;
   }
 
-  float_fftw_planner *float_fftw_planner::instance = 0;
+  float_fftw_planner *float_fftw_planner::instance = nullptr;
 
   float_fftw_planner::float_fftw_planner (void)
     : meth (ESTIMATE), rplan (0), rd (0), rs (0), rr (0), rh (0), rn (),
       rsimd_align (false), nthreads (1)
   {
     plan[0] = plan[1] = 0;
     d[0] = d[1] = s[0] = s[1] = r[0] = r[1] = h[0] = h[1] = 0;
     simd_align[0] = simd_align[1] = false;
diff --git a/liboctave/numeric/oct-rand.cc b/liboctave/numeric/oct-rand.cc
--- a/liboctave/numeric/oct-rand.cc
+++ b/liboctave/numeric/oct-rand.cc
@@ -39,17 +39,17 @@ along with Octave; see the file COPYING.
 #include "oct-locbuf.h"
 #include "oct-rand.h"
 #include "oct-time.h"
 #include "randgamma.h"
 #include "randmtzig.h"
 #include "randpoisson.h"
 #include "singleton-cleanup.h"
 
-octave_rand *octave_rand::instance = 0;
+octave_rand *octave_rand::instance = nullptr;
 
 octave_rand::octave_rand (void)
   : current_distribution (uniform_dist), use_old_generators (false),
     rand_states ()
 {
   initialize_ranlib_generators ();
 
   initialize_mersenne_twister ();
diff --git a/liboctave/numeric/oct-spparms.cc b/liboctave/numeric/oct-spparms.cc
--- a/liboctave/numeric/oct-spparms.cc
+++ b/liboctave/numeric/oct-spparms.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 #endif
 
 #include "lo-error.h"
 #include "lo-ieee.h"
 
 #include "oct-spparms.h"
 #include "singleton-cleanup.h"
 
-octave_sparse_params *octave_sparse_params::instance = 0;
+octave_sparse_params *octave_sparse_params::instance = nullptr;
 
 bool
 octave_sparse_params::instance_ok (void)
 {
   bool retval = true;
 
   if (! instance)
     {
diff --git a/liboctave/system/child-list.cc b/liboctave/system/child-list.cc
--- a/liboctave/system/child-list.cc
+++ b/liboctave/system/child-list.cc
@@ -27,17 +27,17 @@ along with Octave; see the file COPYING.
 #include "child-list.h"
 #include "lo-error.h"
 #include "oct-syscalls.h"
 #include "signal-wrappers.h"
 #include "singleton-cleanup.h"
 
 namespace octave
 {
-  child_list::child_list_rep *child_list::instance = 0;
+  child_list::child_list_rep *child_list::instance = nullptr;
 
   bool
   child_list::instance_ok (void)
   {
     bool retval = true;
 
     if (! instance)
       {
diff --git a/liboctave/system/file-ops.cc b/liboctave/system/file-ops.cc
--- a/liboctave/system/file-ops.cc
+++ b/liboctave/system/file-ops.cc
@@ -50,17 +50,17 @@ along with Octave; see the file COPYING.
 #include "stat-wrappers.h"
 #include "str-vec.h"
 #include "unistd-wrappers.h"
 
 namespace octave
 {
   namespace sys
   {
-    file_ops *octave::sys::file_ops::instance = 0;
+    file_ops *octave::sys::file_ops::instance = nullptr;
 
     bool
     octave::sys::file_ops::instance_ok (void)
     {
       bool retval = true;
 
       if (! instance)
         {
diff --git a/liboctave/system/mach-info.cc b/liboctave/system/mach-info.cc
--- a/liboctave/system/mach-info.cc
+++ b/liboctave/system/mach-info.cc
@@ -31,17 +31,17 @@ along with Octave; see the file COPYING.
 
 extern "C"
 {
   double F77_FUNC (d1mach, D1MACH) (const F77_INT&);
 }
 
 namespace octave
 {
-  mach_info *mach_info::instance = 0;
+  mach_info *mach_info::instance = nullptr;
 
   union equiv
   {
     double d;
     int i[2];
   };
 
   struct
diff --git a/liboctave/system/oct-env.cc b/liboctave/system/oct-env.cc
--- a/liboctave/system/oct-env.cc
+++ b/liboctave/system/oct-env.cc
@@ -70,17 +70,17 @@ namespace octave
       do_getcwd ();
 
       // Etc.
       do_get_user_name ();
 
       do_get_host_name ();
     }
 
-    env *env::instance = 0;
+    env *env::instance = nullptr;
 
     bool
     env::instance_ok (void)
     {
       bool retval = true;
 
       if (! instance)
         {
diff --git a/liboctave/system/oct-time.cc b/liboctave/system/oct-time.cc
--- a/liboctave/system/oct-time.cc
+++ b/liboctave/system/oct-time.cc
@@ -168,17 +168,17 @@ namespace octave
 
 #if defined (HAVE_STRUCT_TM_TM_ZONE)
           char *ps = strsave (m_zone.c_str ());
           t.tm_zone = ps;
 #endif
 
           const char *fmt_str = fmt.c_str ();
 
-          char *buf = 0;
+          char *buf = nullptr;
           size_t bufsize = STRFTIME_BUF_INITIAL_SIZE;
           size_t chars_written = 0;
 
           while (chars_written == 0)
             {
               delete [] buf;
               buf = new char [bufsize];
               buf[0] = '\0';
diff --git a/liboctave/util/cmd-edit.cc b/liboctave/util/cmd-edit.cc
--- a/liboctave/util/cmd-edit.cc
+++ b/liboctave/util/cmd-edit.cc
@@ -48,17 +48,17 @@ along with Octave; see the file COPYING.
 
 #include "oct-rl-edit.h"
 #endif
 
 namespace octave
 {
   char * do_completer_word_break_hook ();
 
-  command_editor *command_editor::instance = 0;
+  command_editor *command_editor::instance = nullptr;
 
   std::set<command_editor::startup_hook_fcn> command_editor::startup_hook_set;
 
   std::set<command_editor::pre_input_hook_fcn> command_editor::pre_input_hook_set;
 
   std::set<command_editor::event_hook_fcn> command_editor::event_hook_set;
 
   static octave::mutex event_hook_lock;
@@ -598,17 +598,17 @@ namespace octave
   string_vector
   gnu_readline::do_generate_filename_completions (const std::string& text)
   {
     string_vector retval;
 
     int n = 0;
     int count = 0;
 
-    char *fn = 0;
+    char *fn = nullptr;
 
     while (1)
       {
         fn = ::octave_rl_filename_completion_function (text.c_str (), count);
 
         if (fn)
           {
             if (count == n)
@@ -818,17 +818,17 @@ namespace octave
   gnu_readline::history_search_forward (int count, int c)
   {
     return octave_rl_history_search_forward (count, c);
   }
 
   char *
   gnu_readline::command_generator (const char *text, int state)
   {
-    char *retval = 0;
+    char *retval = nullptr;
 
     completion_fcn f = command_editor::get_completion_function ();
 
     std::string tmp = f (text, state);
 
     size_t len = tmp.length ();
 
     if (len > 0)
@@ -839,17 +839,17 @@ namespace octave
       }
 
     return retval;
   }
 
   char *
   gnu_readline::command_quoter (char *text, int matches, char *qcp)
   {
-    char *retval = 0;
+    char *retval = nullptr;
 
     quoting_fcn f = command_editor::get_quoting_function ();
 
     std::string tmp = f (text, matches, *qcp);
 
     size_t len = tmp.length ();
 
     if (len > 0)
@@ -860,17 +860,17 @@ namespace octave
       }
 
     return retval;
   }
 
   char *
   gnu_readline::command_dequoter (char *text, int quote)
   {
-    char *retval = 0;
+    char *retval = nullptr;
 
     dequoting_fcn f = command_editor::get_dequoting_function ();
 
     std::string tmp = f (text, quote);
 
     size_t len = tmp.length ();
 
     if (len > 0)
diff --git a/liboctave/util/cmd-hist.cc b/liboctave/util/cmd-hist.cc
--- a/liboctave/util/cmd-hist.cc
+++ b/liboctave/util/cmd-hist.cc
@@ -43,17 +43,17 @@ along with Octave; see the file COPYING.
 
 #include "oct-rl-hist.h"
 
 #include "file-stat.h"
 #endif
 
 namespace octave
 {
-  command_history *command_history::instance = 0;
+  command_history *command_history::instance = nullptr;
 
 #if defined (USE_READLINE)
 
   class
   gnu_history : public command_history
   {
   public:
 
diff --git a/liboctave/util/oct-locbuf.cc b/liboctave/util/oct-locbuf.cc
--- a/liboctave/util/oct-locbuf.cc
+++ b/liboctave/util/oct-locbuf.cc
@@ -37,18 +37,18 @@ along with Octave; see the file COPYING.
 
 namespace octave
 {
 // Each chunk will be at least this big.
 
   const size_t octave::chunk_buffer::chunk_size =
     static_cast<size_t> (OCTAVE_LOCBUF_CHUNKSIZE_MB) << 20;
 
-  char *chunk_buffer::top = 0;
-  char *chunk_buffer::chunk = 0;
+  char *chunk_buffer::top = nullptr;
+  char *chunk_buffer::chunk = nullptr;
   size_t chunk_buffer::left = 0;
   size_t chunk_buffer::active = 0;
 
   chunk_buffer::chunk_buffer (size_t size) : cnk (0), dat (0)
   {
     // Alignment mask.  The size of double or long int, whichever is
     // greater.  All data will be aligned to this size.  If it's not
     // enough for a type, that type should not be declared as POD.
diff --git a/liboctave/util/oct-shlib.cc b/liboctave/util/oct-shlib.cc
--- a/liboctave/util/oct-shlib.cc
+++ b/liboctave/util/oct-shlib.cc
@@ -94,17 +94,17 @@ namespace octave
           ("Octave:library-reload",
            "library %s not reloaded due to existing references", file.c_str ());
       }
   }
 
   dynamic_library::dynlib_rep *
   dynamic_library::dynlib_rep::get_instance (const std::string& f, bool fake)
   {
-    dynlib_rep *retval = 0;
+    dynlib_rep *retval = nullptr;
     std::map<std::string, dynlib_rep *>::iterator p = instances.find (f);
     if (p != instances.end ())
       {
         retval = p->second;
         retval->count++;
         if (fake)
           retval->fake_reload ();
       }
@@ -225,17 +225,17 @@ namespace octave
     if (library)
       dlclose (library);
   }
 
   void *
   octave_dlopen_shlib::search (const std::string& name,
                                dynamic_library::name_mangler mangler)
   {
-    void *function = 0;
+    void *function = nullptr;
 
     if (! is_open ())
       (*current_liboctave_error_handler)
         ("shared library %s is not open", file.c_str ());
 
     std::string sym_name = name;
 
     if (mangler)
@@ -292,17 +292,17 @@ namespace octave
     if (library)
       shl_unload (library);
   }
 
   void *
   octave_shl_load_shlib::search (const std::string& name,
                                  dynamic_library::name_mangler mangler)
   {
-    void *function = 0;
+    void *function = nullptr;
 
     if (! is_open ())
       (*current_liboctave_error_handler)
         ("shared library %s is not open", file.c_str ());
 
     std::string sym_name = name;
 
     if (mangler)
@@ -391,17 +391,17 @@ namespace octave
     if (handle)
       FreeLibrary (handle);
   }
 
   void *
   octave_w32_shlib::search (const std::string& name,
                             dynamic_library::name_mangler mangler)
   {
-    void *function = 0;
+    void *function = nullptr;
 
     if (! is_open ())
       (*current_liboctave_error_handler)
         ("shared library %s is not open", file.c_str ());
 
     std::string sym_name = name;
 
     if (mangler)
@@ -462,17 +462,17 @@ namespace octave
     handle = NSLinkModule (img, file.c_str (),
                            (NSLINKMODULE_OPTION_RETURN_ON_ERROR
                             | NSLINKMODULE_OPTION_PRIVATE));
     if (! handle)
       {
         NSLinkEditErrors ler;
         int lerno;
         const char *file2;
-        const char *errstr = 0;
+        const char *errstr = nullptr;
 
         NSLinkEditError (&ler, &lerno, &file2, &errstr);
 
         if (! errstr)
           errstr = "unspecified error";
 
         (*current_liboctave_error_handler) ("%s: %s", file.c_str (), errstr);
       }
@@ -485,17 +485,17 @@ namespace octave
 
     NSDestroyObjectFileImage (img);
   }
 
   void *
   octave_dyld_shlib::search (const std::string& name,
                              dynamic_library::name_mangler mangler)
   {
-    void *function = 0;
+    void *function = nullptr;
 
     if (! is_open ())
       (*current_liboctave_error_handler)
         ("bundle %s is not open", file.c_str ());
 
     std::string sym_name = name;
 
     if (mangler)
diff --git a/liboctave/util/pathsearch.cc b/liboctave/util/pathsearch.cc
--- a/liboctave/util/pathsearch.cc
+++ b/liboctave/util/pathsearch.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "lo-error.h"
 #include "lo-utils.h"
 #include "oct-env.h"
 #include "pathsearch.h"
 #include "singleton-cleanup.h"
 
 namespace octave
 {
-  directory_path::static_members *directory_path::static_members::instance = 0;
+  directory_path::static_members *directory_path::static_members::instance = nullptr;
 
   directory_path::static_members::static_members (void)
     : xpath_sep_char (SEPCHAR), xpath_sep_str (SEPCHAR_STR) { }
 
   bool
   directory_path::static_members::instance_ok (void)
   {
     bool retval = true;
diff --git a/liboctave/util/singleton-cleanup.cc b/liboctave/util/singleton-cleanup.cc
--- a/liboctave/util/singleton-cleanup.cc
+++ b/liboctave/util/singleton-cleanup.cc
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <lo-error.h>
 #include <singleton-cleanup.h>
 
-singleton_cleanup_list *singleton_cleanup_list::instance = 0;
+singleton_cleanup_list *singleton_cleanup_list::instance = nullptr;
 
 singleton_cleanup_list::~singleton_cleanup_list (void)
 {
   for (fptr fcn : fcn_list)
     {
       fcn ();
     }
 }
diff --git a/liboctave/util/unwind-prot.h b/liboctave/util/unwind-prot.h
--- a/liboctave/util/unwind-prot.h
+++ b/liboctave/util/unwind-prot.h
@@ -56,17 +56,17 @@ namespace octave
     ~unwind_protect (void) { run (); }
 
     virtual void add (elem *new_elem)
     {
       lifo.push (new_elem);
     }
 
     OCTAVE_DEPRECATED ("use 'add (new fcn_arg_elem<void *> (fcn, ptr))' instead")
-    void add (void (*fcn) (void *), void *ptr = 0)
+    void add (void (*fcn) (void *), void *ptr = nullptr)
     {
       add (new fcn_arg_elem<void *> (fcn, ptr));
     }
 
     operator bool (void) const { return ! empty (); }
 
     OCTAVE_DEPRECATED ("use 'run_first' instead")
     void run_top (void) { run_first (); }
diff --git a/liboctave/util/url-transfer.cc b/liboctave/util/url-transfer.cc
--- a/liboctave/util/url-transfer.cc
+++ b/liboctave/util/url-transfer.cc
@@ -409,17 +409,17 @@ namespace octave
 
     void mkdir (const std::string& path)
     {
       ftp_file_or_dir_action (path, "mkd");
     }
 
     void rename (const std::string& oldname, const std::string& newname)
     {
-      struct curl_slist *slist = 0;
+      struct curl_slist *slist = nullptr;
 
       octave::unwind_protect frame;
       frame.add_fcn (curl_slist_free_all, slist);
 
       std::string cmd = "rnfr " + oldname;
       slist = curl_slist_append (slist, cmd.c_str ());
       cmd = "rnto " + newname;
       slist = curl_slist_append (slist, cmd.c_str ());
@@ -577,17 +577,17 @@ namespace octave
       // don't end up in the root after an MDTM command.
       cwd ("/" + path);
     }
 
     std::string pwd (void)
     {
       std::string retval;
 
-      struct curl_slist *slist = 0;
+      struct curl_slist *slist = nullptr;
 
       octave::unwind_protect frame;
       frame.add_fcn (curl_slist_free_all, slist);
 
       slist = curl_slist_append (slist, "pwd");
       SETOPTR (CURLOPT_POSTQUOTE, slist);
       SETOPTR (CURLOPT_HEADERFUNCTION, write_data);
 
@@ -741,17 +741,17 @@ namespace octave
       query.flush ();
 
       return query.str ();
     }
 
     void ftp_file_or_dir_action (const std::string& file_or_dir,
                                  const std::string& action)
     {
-      struct curl_slist *slist = 0;
+      struct curl_slist *slist = nullptr;
 
       octave::unwind_protect frame;
 
       frame.add_fcn (curl_slist_free_all, slist);
 
       std::string cmd = action + " " + file_or_dir;
 
       slist = curl_slist_append (slist, cmd.c_str ());
