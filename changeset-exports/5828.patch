# HG changeset patch
# User jwe
# Date 1148364314 0
#      Tue May 23 06:05:14 2006 +0000
# Node ID 22e23bee74c8a6d68c6dafa94b8dd804f3ebe3b4
# Parent  1fe78adb91bc2ca891e8b9b620a5672b31474da4
[project @ 2006-05-23 06:05:14 by jwe]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,12 @@
+2006-05-23  John W. Eaton  <jwe@octave.org>
+
+	* configure.in: Check for inttypes.h and stdint.h.
+
 2006-05-19  John W. Eaton  <jwe@octave.org>
 
 	* mk-opts.pl (emit_print_function, emit_options_function):
 	Generate print_usage calls with no args.
 
 2006-05-11  John W. Eaton  <jwe@octave.org>
 
 	* configure.in (localfcnfilepath, localoctfilepath, fcnfilepath,
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -24,17 +24,17 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### Preserve CFLAGS and CXXFLAGS from the environment before doing
 ### anything else because we don't know which macros might call
 ### AC_PROG_CC or AC_PROG_CXX.
 
 EXTERN_CFLAGS="$CFLAGS"
 EXTERN_CXXFLAGS="$CXXFLAGS"
 
 AC_INIT
-AC_REVISION($Revision: 1.510 $)
+AC_REVISION($Revision: 1.511 $)
 AC_PREREQ(2.57)
 AC_CONFIG_SRCDIR([src/octave.cc])
 AC_CONFIG_HEADER(config.h)
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define if this is Octave.])
   
 OCTAVE_HOST_TYPE
 
@@ -1164,18 +1164,18 @@ OCTAVE_DYNAMIC_AUTO_ARRAYS
 AC_HEADER_STDC
 AC_HEADER_DIRENT
 AC_HEADER_TIME
 AC_HEADER_SYS_WAIT
 
 ### C headers
 
 AC_CHECK_HEADERS(assert.h curses.h direct.h dlfcn.h fcntl.h float.h \
-  floatingpoint.h grp.h ieeefp.h limits.h memory.h nan.h \
-  ncurses.h poll.h pwd.h stdlib.h string.h sys/ioctl.h \
+  floatingpoint.h grp.h ieeefp.h inttypes.h limits.h memory.h nan.h \
+  ncurses.h poll.h pwd.h stdint.h stdlib.h string.h sys/ioctl.h \
   sys/param.h sys/poll.h sys/resource.h sys/select.h sys/stat.h \
   sys/time.h sys/times.h sys/types.h sys/utsname.h termcap.h \
   unistd.h varargs.h)
 
 ### C++ headers
 
 AC_LANG_PUSH(C++)
 AC_CHECK_HEADERS(sstream)
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,21 @@
+2006-05-23  John W. Eaton  <jwe@octave.org>
+
+	* oct-types.h.in: Include stdint.h or inttypes.h for integer
+	typedefs, or define them if those files are not available.
+	* oct-inttypes.h (octave_int8_t, octave_int16_t, octave_int32_t,
+	octave_int64_t, octave_uint8_t, octave_uint16_t, octave_uint32_t,
+	octave_uint64_t): Delete typedefs.  Replace all uses of these
+	types with int8_t, int16_t, etc.
+	* data-conv.h (TWO_BYTE_INT, FOUR_BYTE_INT, EIGHT_BYTE_INT):
+	Delete definitions.  Replace all uses of these macros with int8_t,
+	int16_t, etc.
+	* randmtzig.h: Delete integer typedefs.
+
 2006-05-18  John W. Eaton  <jwe@octave.org>
 
 	* EIG.cc (EIG::init): Trap Inf and NaN values here.
 	From Keith Goodman <kwgoodman@gmail.com>.
 
 2006-05-08  David Bateman  <dbateman@free.fr>
 
 	* Sparse-op-defs.h (SPARSE_SPARSE_MUL): fix bug in previous
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -2006,26 +2006,26 @@ assign1 (Sparse<LT>& lhs, const Sparse<R
 
   idx_vector *idx_tmp = lhs.get_idx ();
 
   idx_vector lhs_idx = idx_tmp[0];
 
   octave_idx_type lhs_len = lhs.numel ();
   octave_idx_type rhs_len = rhs.numel ();
 
-  unsigned EIGHT_BYTE_INT long_lhs_len = 
-    static_cast<unsigned EIGHT_BYTE_INT> (lhs.rows ()) *
-    static_cast<unsigned EIGHT_BYTE_INT> (lhs.cols ());
-
-  unsigned EIGHT_BYTE_INT long_rhs_len = 
-    static_cast<unsigned EIGHT_BYTE_INT> (rhs.rows ()) *
-    static_cast<unsigned EIGHT_BYTE_INT> (rhs.cols ());
-
-  if (long_rhs_len != static_cast<unsigned EIGHT_BYTE_INT>(rhs_len) ||
-      long_lhs_len != static_cast<unsigned EIGHT_BYTE_INT>(lhs_len))
+  uint64_t long_lhs_len = 
+    static_cast<uint64_t> (lhs.rows ()) *
+    static_cast<uint64_t> (lhs.cols ());
+
+  uint64_t long_rhs_len = 
+    static_cast<uint64_t> (rhs.rows ()) *
+    static_cast<uint64_t> (rhs.cols ());
+
+  if (long_rhs_len != static_cast<uint64_t>(rhs_len) ||
+      long_lhs_len != static_cast<uint64_t>(lhs_len))
     {
       (*current_liboctave_error_handler)
 	("A(I) = X: Matrix dimensions too large to ensure correct\n",
 	 "operation. This is an limitation that should be removed\n",
 	 "in the future.");
 
       lhs.clear_index ();
       return 0;
diff --git a/liboctave/data-conv.cc b/liboctave/data-conv.cc
--- a/liboctave/data-conv.cc
+++ b/liboctave/data-conv.cc
@@ -995,37 +995,37 @@ do_float_format_conversion (void *data, 
 
 void
 read_doubles (std::istream& is, double *data, save_type type, int len,
 	      bool swap, oct_mach_info::float_format fmt)
 {
   switch (type)
     {
     case LS_U_CHAR:
-      LS_DO_READ (unsigned char, swap, data, 1, len, is);
+      LS_DO_READ (uint8_t, swap, data, 1, len, is);
       break;
 
     case LS_U_SHORT:
-      LS_DO_READ (unsigned TWO_BYTE_INT, swap, data, 2, len, is);
+      LS_DO_READ (uint16_t, swap, data, 2, len, is);
       break;
 
     case LS_U_INT:
-      LS_DO_READ (unsigned FOUR_BYTE_INT, swap, data, 4, len, is);
+      LS_DO_READ (uint32_t, swap, data, 4, len, is);
       break;
 
     case LS_CHAR:
-      LS_DO_READ (signed char, swap, data, 1, len, is);
+      LS_DO_READ (int8_t, swap, data, 1, len, is);
       break;
 
     case LS_SHORT:
-      LS_DO_READ (TWO_BYTE_INT, swap, data, 2, len, is);
+      LS_DO_READ (int16_t, swap, data, 2, len, is);
       break;
 
     case LS_INT:
-      LS_DO_READ (FOUR_BYTE_INT, swap, data, 4, len, is);
+      LS_DO_READ (int32_t, swap, data, 4, len, is);
       break;
 
     case LS_FLOAT:
       {
 	OCTAVE_LOCAL_BUFFER (float, ptr, len);
 	is.read (reinterpret_cast<char *> (ptr), 4 * len);
 	do_float_format_conversion (ptr, len, fmt);
 	for (int i = 0; i < len; i++)
@@ -1045,37 +1045,37 @@ read_doubles (std::istream& is, double *
 }
 
 void
 write_doubles (std::ostream& os, const double *data, save_type type, int len)
 {
   switch (type)
     {
     case LS_U_CHAR:
-      LS_DO_WRITE (unsigned char, data, 1, len, os);
+      LS_DO_WRITE (uint8_t, data, 1, len, os);
       break;
 
     case LS_U_SHORT:
-      LS_DO_WRITE (unsigned TWO_BYTE_INT, data, 2, len, os);
+      LS_DO_WRITE (uint16_t, data, 2, len, os);
       break;
 
     case LS_U_INT:
-      LS_DO_WRITE (unsigned FOUR_BYTE_INT, data, 4, len, os);
+      LS_DO_WRITE (uint32_t, data, 4, len, os);
       break;
 
     case LS_CHAR:
-      LS_DO_WRITE (signed char, data, 1, len, os);
+      LS_DO_WRITE (int8_t, data, 1, len, os);
       break;
 
     case LS_SHORT:
-      LS_DO_WRITE (TWO_BYTE_INT, data, 2, len, os);
+      LS_DO_WRITE (int16_t, data, 2, len, os);
       break;
 
     case LS_INT:
-      LS_DO_WRITE (FOUR_BYTE_INT, data, 4, len, os);
+      LS_DO_WRITE (int32_t, data, 4, len, os);
       break;
 
     case LS_FLOAT:
       LS_DO_WRITE (float, data, 4, len, os);
       break;
 
     case LS_DOUBLE: // No conversion necessary.
       {
diff --git a/liboctave/data-conv.h b/liboctave/data-conv.h
--- a/liboctave/data-conv.h
+++ b/liboctave/data-conv.h
@@ -23,48 +23,16 @@ 02110-1301, USA.
 
 #if !defined (octave_data_conv_h)
 #define octave_data_conv_h 1
 
 #include <climits>
 
 #include "mach-info.h"
 
-// Not all of the following are currently used.
-
-#if CHAR_BIT != 8
-#error "CHAR_BIT is not 8!"
-#endif
-
-#if SIZEOF_SHORT == 2
-#define TWO_BYTE_INT short
-#elif SIZEOF_INT == 2
-#define TWO_BYTE_INT int
-#else
-#error "No 2 byte integer type found!"
-#endif
-
-#if SIZEOF_INT == 4
-#define FOUR_BYTE_INT int
-#elif SIZEOF_LONG == 4
-#define FOUR_BYTE_INT long
-#else
-#error "No 4 byte integer type found!"
-#endif
-
-#if SIZEOF_LONG == 8
-#define EIGHT_BYTE_INT long
-#else
-#if SIZEOF_LONG_LONG == 8
-// if `long long' is not implemented, then SIZEOF_LONG_LONG will be 0
-#define EIGHT_BYTE_INT long long
-// if no 8 byte integer type is found, then EIGHT_BYTE_INT is not defined
-#endif
-#endif
-
 class
 oct_data_conv
 {
 public:
 
   enum data_type
     {
       dt_int8      =  0,
diff --git a/liboctave/oct-inttypes.cc b/liboctave/oct-inttypes.cc
--- a/liboctave/oct-inttypes.cc
+++ b/liboctave/oct-inttypes.cc
@@ -86,206 +86,206 @@ 02110-1301, USA.
   template octave_int<T> \
   bitshift (const octave_int<T>&, int, const octave_int<T>&); \
   INSTANTIATE_INT_DOUBLE_BIN_OPS (T); \
   INSTANTIATE_DOUBLE_INT_BIN_OPS (T); \
   INSTANTIATE_INT_DOUBLE_CMP_OPS (T); \
   INSTANTIATE_DOUBLE_INT_CMP_OPS (T); \
   INSTANTIATE_INT_BITCMP_OPS (T)
 
-INSTANTIATE_INTTYPE (octave_int8_t);
-INSTANTIATE_INTTYPE (octave_int16_t);
-INSTANTIATE_INTTYPE (octave_int32_t);
-INSTANTIATE_INTTYPE (octave_int64_t);
+INSTANTIATE_INTTYPE (int8_t);
+INSTANTIATE_INTTYPE (int16_t);
+INSTANTIATE_INTTYPE (int32_t);
+INSTANTIATE_INTTYPE (int64_t);
 
-INSTANTIATE_INTTYPE (octave_uint8_t);
-INSTANTIATE_INTTYPE (octave_uint16_t);
-INSTANTIATE_INTTYPE (octave_uint32_t);
-INSTANTIATE_INTTYPE (octave_uint64_t);
+INSTANTIATE_INTTYPE (uint8_t);
+INSTANTIATE_INTTYPE (uint16_t);
+INSTANTIATE_INTTYPE (uint32_t);
+INSTANTIATE_INTTYPE (uint64_t);
 
 #define INSTANTIATE_INTTYPE_BIN_OP(T1, T2, OP) \
   template octave_int<octave_int_binop_traits<T1, T2>::TR> \
   operator OP (const octave_int<T1>&, const octave_int<T2>&)
 
 #define INSTANTIATE_INTTYPE_BIN_OPS(T1, T2) \
   INSTANTIATE_INTTYPE_BIN_OP (T1, T2, +); \
   INSTANTIATE_INTTYPE_BIN_OP (T1, T2, -); \
   INSTANTIATE_INTTYPE_BIN_OP (T1, T2, *); \
   INSTANTIATE_INTTYPE_BIN_OP (T1, T2, /)
 
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int8_t, octave_int8_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int8_t, octave_int16_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int8_t, octave_int32_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int8_t, octave_int64_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int8_t, octave_uint8_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int8_t, octave_uint16_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int8_t, octave_uint32_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int8_t, octave_uint64_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int8_t, int8_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int8_t, int16_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int8_t, int32_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int8_t, int64_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int8_t, uint8_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int8_t, uint16_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int8_t, uint32_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int8_t, uint64_t);
 
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int16_t, octave_int8_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int16_t, octave_int16_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int16_t, octave_int32_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int16_t, octave_int64_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int16_t, octave_uint8_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int16_t, octave_uint16_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int16_t, octave_uint32_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int16_t, octave_uint64_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int16_t, int8_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int16_t, int16_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int16_t, int32_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int16_t, int64_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int16_t, uint8_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int16_t, uint16_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int16_t, uint32_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int16_t, uint64_t);
 
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int32_t, octave_int8_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int32_t, octave_int16_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int32_t, octave_int32_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int32_t, octave_int64_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int32_t, octave_uint8_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int32_t, octave_uint16_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int32_t, octave_uint32_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int32_t, octave_uint64_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int32_t, int8_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int32_t, int16_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int32_t, int32_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int32_t, int64_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int32_t, uint8_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int32_t, uint16_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int32_t, uint32_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int32_t, uint64_t);
 
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int64_t, octave_int8_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int64_t, octave_int16_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int64_t, octave_int32_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int64_t, octave_int64_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int64_t, octave_uint8_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int64_t, octave_uint16_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int64_t, octave_uint32_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_int64_t, octave_uint64_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int64_t, int8_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int64_t, int16_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int64_t, int32_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int64_t, int64_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int64_t, uint8_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int64_t, uint16_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int64_t, uint32_t);
+INSTANTIATE_INTTYPE_BIN_OPS (int64_t, uint64_t);
 
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint8_t, octave_int8_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint8_t, octave_int16_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint8_t, octave_int32_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint8_t, octave_int64_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint8_t, octave_uint8_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint8_t, octave_uint16_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint8_t, octave_uint32_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint8_t, octave_uint64_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint8_t, int8_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint8_t, int16_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint8_t, int32_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint8_t, int64_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint8_t, uint8_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint8_t, uint16_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint8_t, uint32_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint8_t, uint64_t);
 
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint16_t, octave_int8_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint16_t, octave_int16_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint16_t, octave_int32_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint16_t, octave_int64_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint16_t, octave_uint8_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint16_t, octave_uint16_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint16_t, octave_uint32_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint16_t, octave_uint64_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint16_t, int8_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint16_t, int16_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint16_t, int32_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint16_t, int64_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint16_t, uint8_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint16_t, uint16_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint16_t, uint32_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint16_t, uint64_t);
 
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint32_t, octave_int8_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint32_t, octave_int16_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint32_t, octave_int32_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint32_t, octave_int64_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint32_t, octave_uint8_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint32_t, octave_uint16_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint32_t, octave_uint32_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint32_t, octave_uint64_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint32_t, int8_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint32_t, int16_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint32_t, int32_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint32_t, int64_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint32_t, uint8_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint32_t, uint16_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint32_t, uint32_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint32_t, uint64_t);
 
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint64_t, octave_int8_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint64_t, octave_int16_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint64_t, octave_int32_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint64_t, octave_int64_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint64_t, octave_uint8_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint64_t, octave_uint16_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint64_t, octave_uint32_t);
-INSTANTIATE_INTTYPE_BIN_OPS (octave_uint64_t, octave_uint64_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint64_t, int8_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint64_t, int16_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint64_t, int32_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint64_t, int64_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint64_t, uint8_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint64_t, uint16_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint64_t, uint32_t);
+INSTANTIATE_INTTYPE_BIN_OPS (uint64_t, uint64_t);
 
 #define INSTANTIATE_INTTYPE_SHIFT_OP(T, OP) \
   template octave_int<T> operator OP (const octave_int<T>&, const int&)
 
 #define INSTANTIATE_INTTYPE_SHIFT_OPS(T) \
   INSTANTIATE_INTTYPE_SHIFT_OP (T, <<); \
   INSTANTIATE_INTTYPE_SHIFT_OP (T, >>)
 
-INSTANTIATE_INTTYPE_SHIFT_OPS (octave_int8_t);
-INSTANTIATE_INTTYPE_SHIFT_OPS (octave_int16_t);
-INSTANTIATE_INTTYPE_SHIFT_OPS (octave_int32_t);
-INSTANTIATE_INTTYPE_SHIFT_OPS (octave_int64_t);
-INSTANTIATE_INTTYPE_SHIFT_OPS (octave_uint8_t);
-INSTANTIATE_INTTYPE_SHIFT_OPS (octave_uint16_t);
-INSTANTIATE_INTTYPE_SHIFT_OPS (octave_uint32_t);
-INSTANTIATE_INTTYPE_SHIFT_OPS (octave_uint64_t);
+INSTANTIATE_INTTYPE_SHIFT_OPS (int8_t);
+INSTANTIATE_INTTYPE_SHIFT_OPS (int16_t);
+INSTANTIATE_INTTYPE_SHIFT_OPS (int32_t);
+INSTANTIATE_INTTYPE_SHIFT_OPS (int64_t);
+INSTANTIATE_INTTYPE_SHIFT_OPS (uint8_t);
+INSTANTIATE_INTTYPE_SHIFT_OPS (uint16_t);
+INSTANTIATE_INTTYPE_SHIFT_OPS (uint32_t);
+INSTANTIATE_INTTYPE_SHIFT_OPS (uint64_t);
 
 #define INSTANTIATE_OCTAVE_INT_CMP_OP(OP, T1, T2) \
   template bool operator OP (const octave_int<T1>&, const octave_int<T2>&)
 
 #define INSTANTIATE_OCTAVE_INT_CMP_OPS(T1, T2) \
   INSTANTIATE_OCTAVE_INT_CMP_OP (<, T1, T2); \
   INSTANTIATE_OCTAVE_INT_CMP_OP (<=, T1, T2); \
   INSTANTIATE_OCTAVE_INT_CMP_OP (>=, T1, T2); \
   INSTANTIATE_OCTAVE_INT_CMP_OP (>, T1, T2); \
   INSTANTIATE_OCTAVE_INT_CMP_OP (==, T1, T2); \
   INSTANTIATE_OCTAVE_INT_CMP_OP (!=, T1, T2)
 
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int8_t, octave_int8_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int8_t, octave_int16_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int8_t, octave_int32_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int8_t, octave_int64_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int8_t, octave_uint8_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int8_t, octave_uint16_t);
-// INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int8_t, octave_uint32_t);
-// INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int8_t, octave_uint64_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int8_t, int8_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int8_t, int16_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int8_t, int32_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int8_t, int64_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int8_t, uint8_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int8_t, uint16_t);
+// INSTANTIATE_OCTAVE_INT_CMP_OPS (int8_t, uint32_t);
+// INSTANTIATE_OCTAVE_INT_CMP_OPS (int8_t, uint64_t);
 
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int16_t, octave_int8_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int16_t, octave_int16_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int16_t, octave_int32_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int16_t, octave_int64_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int16_t, octave_uint8_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int16_t, octave_uint16_t);
-// INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int16_t, octave_uint32_t);
-// INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int16_t, octave_uint64_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int16_t, int8_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int16_t, int16_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int16_t, int32_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int16_t, int64_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int16_t, uint8_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int16_t, uint16_t);
+// INSTANTIATE_OCTAVE_INT_CMP_OPS (int16_t, uint32_t);
+// INSTANTIATE_OCTAVE_INT_CMP_OPS (int16_t, uint64_t);
 
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int32_t, octave_int8_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int32_t, octave_int16_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int32_t, octave_int32_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int32_t, octave_int64_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int32_t, octave_uint8_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int32_t, octave_uint16_t);
-// INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int32_t, octave_uint32_t);
-// INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int32_t, octave_uint64_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int32_t, int8_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int32_t, int16_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int32_t, int32_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int32_t, int64_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int32_t, uint8_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int32_t, uint16_t);
+// INSTANTIATE_OCTAVE_INT_CMP_OPS (int32_t, uint32_t);
+// INSTANTIATE_OCTAVE_INT_CMP_OPS (int32_t, uint64_t);
 
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int64_t, octave_int8_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int64_t, octave_int16_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int64_t, octave_int32_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int64_t, octave_int64_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int64_t, octave_uint8_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int64_t, octave_uint16_t);
-// INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int64_t, octave_uint32_t);
-// INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_int64_t, octave_uint64_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int64_t, int8_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int64_t, int16_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int64_t, int32_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int64_t, int64_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int64_t, uint8_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (int64_t, uint16_t);
+// INSTANTIATE_OCTAVE_INT_CMP_OPS (int64_t, uint32_t);
+// INSTANTIATE_OCTAVE_INT_CMP_OPS (int64_t, uint64_t);
 
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint8_t, octave_int8_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint8_t, octave_int16_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint8_t, octave_int32_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint8_t, octave_int64_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint8_t, octave_uint8_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint8_t, octave_uint16_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint8_t, octave_uint32_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint8_t, octave_uint64_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint8_t, int8_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint8_t, int16_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint8_t, int32_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint8_t, int64_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint8_t, uint8_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint8_t, uint16_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint8_t, uint32_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint8_t, uint64_t);
 
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint16_t, octave_int8_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint16_t, octave_int16_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint16_t, octave_int32_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint16_t, octave_int64_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint16_t, octave_uint8_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint16_t, octave_uint16_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint16_t, octave_uint32_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint16_t, octave_uint64_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint16_t, int8_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint16_t, int16_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint16_t, int32_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint16_t, int64_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint16_t, uint8_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint16_t, uint16_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint16_t, uint32_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint16_t, uint64_t);
 
-// INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint32_t, octave_int8_t);
-// INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint32_t, octave_int16_t);
-// INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint32_t, octave_int32_t);
-// INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint32_t, octave_int64_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint32_t, octave_uint8_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint32_t, octave_uint16_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint32_t, octave_uint32_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint32_t, octave_uint64_t);
+// INSTANTIATE_OCTAVE_INT_CMP_OPS (uint32_t, int8_t);
+// INSTANTIATE_OCTAVE_INT_CMP_OPS (uint32_t, int16_t);
+// INSTANTIATE_OCTAVE_INT_CMP_OPS (uint32_t, int32_t);
+// INSTANTIATE_OCTAVE_INT_CMP_OPS (uint32_t, int64_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint32_t, uint8_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint32_t, uint16_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint32_t, uint32_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint32_t, uint64_t);
 
-// INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint64_t, octave_int8_t);
-// INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint64_t, octave_int16_t);
-// INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint64_t, octave_int32_t);
-// INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint64_t, octave_int64_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint64_t, octave_uint8_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint64_t, octave_uint16_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint64_t, octave_uint32_t);
-INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_uint64_t, octave_uint64_t);
+// INSTANTIATE_OCTAVE_INT_CMP_OPS (uint64_t, int8_t);
+// INSTANTIATE_OCTAVE_INT_CMP_OPS (uint64_t, int16_t);
+// INSTANTIATE_OCTAVE_INT_CMP_OPS (uint64_t, int32_t);
+// INSTANTIATE_OCTAVE_INT_CMP_OPS (uint64_t, int64_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint64_t, uint8_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint64_t, uint16_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint64_t, uint32_t);
+INSTANTIATE_OCTAVE_INT_CMP_OPS (uint64_t, uint64_t);
 
 // The following apply if the unsigned type is at least as wide as the
 // signed type (then we can cast postive signed values to the unsigned
 // type and compare).
 
 #define OCTAVE_US_TYPE1_CMP_OP(OP, LTZ_VAL, UT, ST) \
   bool \
   operator OP (const octave_int<UT>& lhs, const octave_int<ST>& rhs) \
@@ -317,24 +317,24 @@ INSTANTIATE_OCTAVE_INT_CMP_OPS (octave_u
   OCTAVE_SU_TYPE1_CMP_OP (>, false, ST, UT) \
   OCTAVE_SU_TYPE1_CMP_OP (==, false, ST, UT) \
   OCTAVE_SU_TYPE1_CMP_OP (!=, true, ST, UT)
 
 #define OCTAVE_TYPE1_CMP_OPS(UT, ST) \
   OCTAVE_US_TYPE1_CMP_OPS (UT, ST) \
   OCTAVE_SU_TYPE1_CMP_OPS (ST, UT)
 
-OCTAVE_TYPE1_CMP_OPS (octave_uint32_t, octave_int8_t)
-OCTAVE_TYPE1_CMP_OPS (octave_uint32_t, octave_int16_t)
-OCTAVE_TYPE1_CMP_OPS (octave_uint32_t, octave_int32_t)
+OCTAVE_TYPE1_CMP_OPS (uint32_t, int8_t)
+OCTAVE_TYPE1_CMP_OPS (uint32_t, int16_t)
+OCTAVE_TYPE1_CMP_OPS (uint32_t, int32_t)
 
-OCTAVE_TYPE1_CMP_OPS (octave_uint64_t, octave_int8_t)
-OCTAVE_TYPE1_CMP_OPS (octave_uint64_t, octave_int16_t)
-OCTAVE_TYPE1_CMP_OPS (octave_uint64_t, octave_int32_t)
-OCTAVE_TYPE1_CMP_OPS (octave_uint64_t, octave_int64_t)
+OCTAVE_TYPE1_CMP_OPS (uint64_t, int8_t)
+OCTAVE_TYPE1_CMP_OPS (uint64_t, int16_t)
+OCTAVE_TYPE1_CMP_OPS (uint64_t, int32_t)
+OCTAVE_TYPE1_CMP_OPS (uint64_t, int64_t)
 
 // The following apply if the signed type is wider than the unsigned
 // type (then we can cast unsigned values to the signed type and
 // compare if the signed value is positive).
 
 #define OCTAVE_US_TYPE2_CMP_OP(OP, LTZ_VAL, UT, ST) \
   bool \
   operator OP (const octave_int<UT>& lhs, const octave_int<ST>& rhs) \
@@ -366,17 +366,17 @@ OCTAVE_TYPE1_CMP_OPS (octave_uint64_t, o
   OCTAVE_SU_TYPE2_CMP_OP (>, false, ST, UT) \
   OCTAVE_SU_TYPE2_CMP_OP (==, false, ST, UT) \
   OCTAVE_SU_TYPE2_CMP_OP (!=, true, ST, UT)
 
 #define OCTAVE_TYPE2_CMP_OPS(UT, ST) \
   OCTAVE_US_TYPE2_CMP_OPS (UT, ST) \
   OCTAVE_SU_TYPE2_CMP_OPS (ST, UT)
 
-OCTAVE_TYPE2_CMP_OPS (octave_uint32_t, octave_int64_t)
+OCTAVE_TYPE2_CMP_OPS (uint32_t, int64_t)
 
 
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/oct-inttypes.h b/liboctave/oct-inttypes.h
--- a/liboctave/oct-inttypes.h
+++ b/liboctave/oct-inttypes.h
@@ -22,30 +22,20 @@ 02110-1301, USA.
 */
 
 #if !defined (octave_inttypes_h)
 #define octave_inttypes_h 1
 
 #include <limits>
 #include <iostream>
 
-#include "data-conv.h"
+#include "oct-types.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 
-typedef signed char octave_int8_t;
-typedef TWO_BYTE_INT octave_int16_t;
-typedef FOUR_BYTE_INT octave_int32_t;
-typedef EIGHT_BYTE_INT octave_int64_t;
-
-typedef unsigned char octave_uint8_t;
-typedef unsigned TWO_BYTE_INT octave_uint16_t;
-typedef unsigned FOUR_BYTE_INT octave_uint32_t;
-typedef unsigned EIGHT_BYTE_INT octave_uint64_t;
-
 template <class T1, class T2>
 class
 octave_int_binop_traits
 {
 public:
   // The return type for a T1 by T2 binary operation.
   typedef T1 TR;
 };
@@ -53,87 +43,87 @@ public:
 #define OCTAVE_INT_BINOP_TRAIT(T1, T2, T3) \
   template<> \
   class octave_int_binop_traits <T1, T2> \
   { \
   public: \
     typedef T3 TR; \
   }
 
-OCTAVE_INT_BINOP_TRAIT (octave_int8_t, octave_int8_t, octave_int8_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int8_t, octave_int16_t, octave_int8_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int8_t, octave_int32_t, octave_int8_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int8_t, octave_int64_t, octave_int8_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int8_t, octave_uint8_t, octave_int8_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int8_t, octave_uint16_t, octave_int8_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int8_t, octave_uint32_t, octave_int8_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int8_t, octave_uint64_t, octave_int8_t);
+OCTAVE_INT_BINOP_TRAIT (int8_t, int8_t, int8_t);
+OCTAVE_INT_BINOP_TRAIT (int8_t, int16_t, int8_t);
+OCTAVE_INT_BINOP_TRAIT (int8_t, int32_t, int8_t);
+OCTAVE_INT_BINOP_TRAIT (int8_t, int64_t, int8_t);
+OCTAVE_INT_BINOP_TRAIT (int8_t, uint8_t, int8_t);
+OCTAVE_INT_BINOP_TRAIT (int8_t, uint16_t, int8_t);
+OCTAVE_INT_BINOP_TRAIT (int8_t, uint32_t, int8_t);
+OCTAVE_INT_BINOP_TRAIT (int8_t, uint64_t, int8_t);
 
-OCTAVE_INT_BINOP_TRAIT (octave_int16_t, octave_int8_t, octave_int16_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int16_t, octave_int16_t, octave_int16_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int16_t, octave_int32_t, octave_int16_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int16_t, octave_int64_t, octave_int16_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int16_t, octave_uint8_t, octave_int16_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int16_t, octave_uint16_t, octave_int16_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int16_t, octave_uint32_t, octave_int16_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int16_t, octave_uint64_t, octave_int16_t);
+OCTAVE_INT_BINOP_TRAIT (int16_t, int8_t, int16_t);
+OCTAVE_INT_BINOP_TRAIT (int16_t, int16_t, int16_t);
+OCTAVE_INT_BINOP_TRAIT (int16_t, int32_t, int16_t);
+OCTAVE_INT_BINOP_TRAIT (int16_t, int64_t, int16_t);
+OCTAVE_INT_BINOP_TRAIT (int16_t, uint8_t, int16_t);
+OCTAVE_INT_BINOP_TRAIT (int16_t, uint16_t, int16_t);
+OCTAVE_INT_BINOP_TRAIT (int16_t, uint32_t, int16_t);
+OCTAVE_INT_BINOP_TRAIT (int16_t, uint64_t, int16_t);
 
-OCTAVE_INT_BINOP_TRAIT (octave_int32_t, octave_int8_t, octave_int32_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int32_t, octave_int16_t, octave_int32_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int32_t, octave_int32_t, octave_int32_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int32_t, octave_int64_t, octave_int32_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int32_t, octave_uint8_t, octave_int32_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int32_t, octave_uint16_t, octave_int32_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int32_t, octave_uint32_t, octave_int32_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int32_t, octave_uint64_t, octave_int32_t);
+OCTAVE_INT_BINOP_TRAIT (int32_t, int8_t, int32_t);
+OCTAVE_INT_BINOP_TRAIT (int32_t, int16_t, int32_t);
+OCTAVE_INT_BINOP_TRAIT (int32_t, int32_t, int32_t);
+OCTAVE_INT_BINOP_TRAIT (int32_t, int64_t, int32_t);
+OCTAVE_INT_BINOP_TRAIT (int32_t, uint8_t, int32_t);
+OCTAVE_INT_BINOP_TRAIT (int32_t, uint16_t, int32_t);
+OCTAVE_INT_BINOP_TRAIT (int32_t, uint32_t, int32_t);
+OCTAVE_INT_BINOP_TRAIT (int32_t, uint64_t, int32_t);
 
-OCTAVE_INT_BINOP_TRAIT (octave_int64_t, octave_int8_t, octave_int64_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int64_t, octave_int16_t, octave_int64_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int64_t, octave_int32_t, octave_int64_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int64_t, octave_int64_t, octave_int64_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int64_t, octave_uint8_t, octave_int64_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int64_t, octave_uint16_t, octave_int64_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int64_t, octave_uint32_t, octave_int64_t);
-OCTAVE_INT_BINOP_TRAIT (octave_int64_t, octave_uint64_t, octave_int64_t);
+OCTAVE_INT_BINOP_TRAIT (int64_t, int8_t, int64_t);
+OCTAVE_INT_BINOP_TRAIT (int64_t, int16_t, int64_t);
+OCTAVE_INT_BINOP_TRAIT (int64_t, int32_t, int64_t);
+OCTAVE_INT_BINOP_TRAIT (int64_t, int64_t, int64_t);
+OCTAVE_INT_BINOP_TRAIT (int64_t, uint8_t, int64_t);
+OCTAVE_INT_BINOP_TRAIT (int64_t, uint16_t, int64_t);
+OCTAVE_INT_BINOP_TRAIT (int64_t, uint32_t, int64_t);
+OCTAVE_INT_BINOP_TRAIT (int64_t, uint64_t, int64_t);
 
-OCTAVE_INT_BINOP_TRAIT (octave_uint8_t, octave_int8_t, octave_int8_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint8_t, octave_int16_t, octave_int8_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint8_t, octave_int32_t, octave_int8_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint8_t, octave_int64_t, octave_int8_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint8_t, octave_uint8_t, octave_uint8_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint8_t, octave_uint16_t, octave_uint8_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint8_t, octave_uint32_t, octave_uint8_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint8_t, octave_uint64_t, octave_uint8_t);
+OCTAVE_INT_BINOP_TRAIT (uint8_t, int8_t, int8_t);
+OCTAVE_INT_BINOP_TRAIT (uint8_t, int16_t, int8_t);
+OCTAVE_INT_BINOP_TRAIT (uint8_t, int32_t, int8_t);
+OCTAVE_INT_BINOP_TRAIT (uint8_t, int64_t, int8_t);
+OCTAVE_INT_BINOP_TRAIT (uint8_t, uint8_t, uint8_t);
+OCTAVE_INT_BINOP_TRAIT (uint8_t, uint16_t, uint8_t);
+OCTAVE_INT_BINOP_TRAIT (uint8_t, uint32_t, uint8_t);
+OCTAVE_INT_BINOP_TRAIT (uint8_t, uint64_t, uint8_t);
 
-OCTAVE_INT_BINOP_TRAIT (octave_uint16_t, octave_int8_t, octave_int16_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint16_t, octave_int16_t, octave_int16_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint16_t, octave_int32_t, octave_int16_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint16_t, octave_int64_t, octave_int16_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint16_t, octave_uint8_t, octave_uint16_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint16_t, octave_uint16_t, octave_uint16_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint16_t, octave_uint32_t, octave_uint16_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint16_t, octave_uint64_t, octave_uint16_t);
+OCTAVE_INT_BINOP_TRAIT (uint16_t, int8_t, int16_t);
+OCTAVE_INT_BINOP_TRAIT (uint16_t, int16_t, int16_t);
+OCTAVE_INT_BINOP_TRAIT (uint16_t, int32_t, int16_t);
+OCTAVE_INT_BINOP_TRAIT (uint16_t, int64_t, int16_t);
+OCTAVE_INT_BINOP_TRAIT (uint16_t, uint8_t, uint16_t);
+OCTAVE_INT_BINOP_TRAIT (uint16_t, uint16_t, uint16_t);
+OCTAVE_INT_BINOP_TRAIT (uint16_t, uint32_t, uint16_t);
+OCTAVE_INT_BINOP_TRAIT (uint16_t, uint64_t, uint16_t);
 
-OCTAVE_INT_BINOP_TRAIT (octave_uint32_t, octave_int8_t, octave_int32_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint32_t, octave_int16_t, octave_int32_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint32_t, octave_int32_t, octave_int32_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint32_t, octave_int64_t, octave_int32_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint32_t, octave_uint8_t, octave_uint32_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint32_t, octave_uint16_t, octave_uint32_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint32_t, octave_uint32_t, octave_uint32_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint32_t, octave_uint64_t, octave_uint32_t);
+OCTAVE_INT_BINOP_TRAIT (uint32_t, int8_t, int32_t);
+OCTAVE_INT_BINOP_TRAIT (uint32_t, int16_t, int32_t);
+OCTAVE_INT_BINOP_TRAIT (uint32_t, int32_t, int32_t);
+OCTAVE_INT_BINOP_TRAIT (uint32_t, int64_t, int32_t);
+OCTAVE_INT_BINOP_TRAIT (uint32_t, uint8_t, uint32_t);
+OCTAVE_INT_BINOP_TRAIT (uint32_t, uint16_t, uint32_t);
+OCTAVE_INT_BINOP_TRAIT (uint32_t, uint32_t, uint32_t);
+OCTAVE_INT_BINOP_TRAIT (uint32_t, uint64_t, uint32_t);
 
-OCTAVE_INT_BINOP_TRAIT (octave_uint64_t, octave_int8_t, octave_int64_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint64_t, octave_int16_t, octave_int64_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint64_t, octave_int32_t, octave_int64_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint64_t, octave_int64_t, octave_int64_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint64_t, octave_uint8_t, octave_uint64_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint64_t, octave_uint16_t, octave_uint64_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint64_t, octave_uint32_t, octave_uint64_t);
-OCTAVE_INT_BINOP_TRAIT (octave_uint64_t, octave_uint64_t, octave_uint64_t);
+OCTAVE_INT_BINOP_TRAIT (uint64_t, int8_t, int64_t);
+OCTAVE_INT_BINOP_TRAIT (uint64_t, int16_t, int64_t);
+OCTAVE_INT_BINOP_TRAIT (uint64_t, int32_t, int64_t);
+OCTAVE_INT_BINOP_TRAIT (uint64_t, int64_t, int64_t);
+OCTAVE_INT_BINOP_TRAIT (uint64_t, uint8_t, uint64_t);
+OCTAVE_INT_BINOP_TRAIT (uint64_t, uint16_t, uint64_t);
+OCTAVE_INT_BINOP_TRAIT (uint64_t, uint32_t, uint64_t);
+OCTAVE_INT_BINOP_TRAIT (uint64_t, uint64_t, uint64_t);
 
 template <class T1, class T2>
 inline T2
 octave_int_fit_to_range (const T1& x, const T2& mn, const T2& mx)
 {
   return (x > mx ? mx : (x < mn ? mn : T2 (x)));
 }
 
@@ -392,25 +382,25 @@ std::istream&
 operator >> (std::istream& is, octave_int<T>& ival)
 {
   T tmp = 0;
   is >> tmp;
   ival = tmp;
   return is;
 }
 
-typedef octave_int<octave_int8_t> octave_int8;
-typedef octave_int<octave_int16_t> octave_int16;
-typedef octave_int<octave_int32_t> octave_int32;
-typedef octave_int<octave_int64_t> octave_int64;
+typedef octave_int<int8_t> octave_int8;
+typedef octave_int<int16_t> octave_int16;
+typedef octave_int<int32_t> octave_int32;
+typedef octave_int<int64_t> octave_int64;
 
-typedef octave_int<octave_uint8_t> octave_uint8;
-typedef octave_int<octave_uint16_t> octave_uint16;
-typedef octave_int<octave_uint32_t> octave_uint32;
-typedef octave_int<octave_uint64_t> octave_uint64;
+typedef octave_int<uint8_t> octave_uint8;
+typedef octave_int<uint16_t> octave_uint16;
+typedef octave_int<uint32_t> octave_uint32;
+typedef octave_int<uint64_t> octave_uint64;
 
 #define OCTAVE_INT_BIN_OP(OP) \
   template <class T1, class T2> \
   octave_int<typename octave_int_binop_traits<T1, T2>::TR> \
   operator OP (const octave_int<T1>& x, const octave_int<T2>& y) \
   { \
     double tx = static_cast<double> (x.value ()); \
     double ty = static_cast<double> (y.value ()); \
@@ -577,24 +567,24 @@ OCTAVE_INT_CMP_OP (!=)
   OCTAVE_SU_TYPE1_CMP_OP_DECL (>, false, ST, UT) \
   OCTAVE_SU_TYPE1_CMP_OP_DECL (==, false, ST, UT) \
   OCTAVE_SU_TYPE1_CMP_OP_DECL (!=, true, ST, UT)
 
 #define OCTAVE_TYPE1_CMP_OP_DECLS(UT, ST) \
   OCTAVE_US_TYPE1_CMP_OP_DECLS (UT, ST) \
   OCTAVE_SU_TYPE1_CMP_OP_DECLS (ST, UT)
 
-OCTAVE_TYPE1_CMP_OP_DECLS (octave_uint32_t, octave_int8_t)
-OCTAVE_TYPE1_CMP_OP_DECLS (octave_uint32_t, octave_int16_t)
-OCTAVE_TYPE1_CMP_OP_DECLS (octave_uint32_t, octave_int32_t)
+OCTAVE_TYPE1_CMP_OP_DECLS (uint32_t, int8_t)
+OCTAVE_TYPE1_CMP_OP_DECLS (uint32_t, int16_t)
+OCTAVE_TYPE1_CMP_OP_DECLS (uint32_t, int32_t)
 
-OCTAVE_TYPE1_CMP_OP_DECLS (octave_uint64_t, octave_int8_t)
-OCTAVE_TYPE1_CMP_OP_DECLS (octave_uint64_t, octave_int16_t)
-OCTAVE_TYPE1_CMP_OP_DECLS (octave_uint64_t, octave_int32_t)
-OCTAVE_TYPE1_CMP_OP_DECLS (octave_uint64_t, octave_int64_t)
+OCTAVE_TYPE1_CMP_OP_DECLS (uint64_t, int8_t)
+OCTAVE_TYPE1_CMP_OP_DECLS (uint64_t, int16_t)
+OCTAVE_TYPE1_CMP_OP_DECLS (uint64_t, int32_t)
+OCTAVE_TYPE1_CMP_OP_DECLS (uint64_t, int64_t)
 
 // The following apply if the signed type is wider than the unsigned
 // type (then we can cast unsigned values to the signed type and
 // compare if the signed value is positive).
 
 #define OCTAVE_US_TYPE2_CMP_OP_DECL(OP, LTZ_VAL, UT, ST) \
   bool operator OP (const octave_int<UT>& lhs, const octave_int<ST>& rhs);
 
@@ -616,17 +606,17 @@ OCTAVE_TYPE1_CMP_OP_DECLS (octave_uint64
   OCTAVE_SU_TYPE2_CMP_OP_DECL (>, false, ST, UT) \
   OCTAVE_SU_TYPE2_CMP_OP_DECL (==, false, ST, UT) \
   OCTAVE_SU_TYPE2_CMP_OP_DECL (!=, true, ST, UT)
 
 #define OCTAVE_TYPE2_CMP_OP_DECLS(UT, ST) \
   OCTAVE_US_TYPE2_CMP_OP_DECLS (UT, ST) \
   OCTAVE_SU_TYPE2_CMP_OP_DECLS (ST, UT)
 
-OCTAVE_TYPE2_CMP_OP_DECLS (octave_uint32_t, octave_int64_t)
+OCTAVE_TYPE2_CMP_OP_DECLS (uint32_t, int64_t)
 
 #undef OCTAVE_INT_BINOP_TRAIT
 #undef OCTAVE_US_S_FTR
 #undef OCTAVE_US_S_FTR_FCNS
 #undef OCTAVE_S_US_FTR
 #undef OCTAVE_S_US_FTR_FCNS
 #undef OCTAVE_INT_FIT_TO_RANGE
 #undef OCTAVE_INT_MIN_VAL2
diff --git a/liboctave/oct-rand.cc b/liboctave/oct-rand.cc
--- a/liboctave/oct-rand.cc
+++ b/liboctave/oct-rand.cc
@@ -172,34 +172,34 @@ octave_rand::state (void)
 {
   ColumnVector s (MT_N + 1);
   if (! new_initialized)
     {
       oct_init_by_entropy ();
       new_initialized = true;
     }
 
-  OCTAVE_LOCAL_BUFFER (unsigned FOUR_BYTE_INT, tmp, MT_N + 1);
+  OCTAVE_LOCAL_BUFFER (uint32_t, tmp, MT_N + 1);
   oct_get_state (tmp);
   for (octave_idx_type i = 0; i <= MT_N; i++)
     s.elem (i) = static_cast<double>(tmp [i]);
   return s;
 }
 
 void
 octave_rand::state (const ColumnVector &s)
 {
   use_old_generators = false;
   maybe_initialize ();
 
   octave_idx_type len = s.length();
   octave_idx_type n = len < MT_N + 1 ? len : MT_N + 1;
-  OCTAVE_LOCAL_BUFFER (unsigned FOUR_BYTE_INT, tmp, MT_N + 1);
+  OCTAVE_LOCAL_BUFFER (uint32_t, tmp, MT_N + 1);
   for (octave_idx_type i = 0; i < n; i++)
-    tmp[i] = static_cast<unsigned FOUR_BYTE_INT> (s.elem(i));
+    tmp[i] = static_cast<uint32_t> (s.elem(i));
 
   if (len == MT_N + 1 && tmp[MT_N] <= MT_N && tmp[MT_N] > 0)
     oct_set_state (tmp);
   else
     oct_init_by_array (tmp, len);
 }
 
 std::string
diff --git a/liboctave/oct-types.h.in b/liboctave/oct-types.h.in
--- a/liboctave/oct-types.h.in
+++ b/liboctave/oct-types.h.in
@@ -21,15 +21,58 @@ 02110-1301, USA.
 
 */
 
 #if !defined (octave_oct_types_h)
 #define octave_oct_types_h 1
 
 typedef @OCTAVE_IDX_TYPE@ octave_idx_type;
 
+#if defined (HAVE_STDINT_H)
+#include <stdint.h>
+#elif defined (HAVE_INTTYPES_H)
+#include <inttypes.h>
+#else
+
+#if CHAR_BIT == 8
+typedef signed char int8_t;
+typedef unsigned char uint8_t;
+#else
+#error "CHAR_BIT is not 8!"
+#endif
+
+#if SIZEOF_SHORT == 2
+typedef short int16_t;
+typedef unsigned short uint16_t;
+#elif SIZEOF_INT == 2
+typedef long int16_t;
+typedef unsigned long uint16_t;
+#else
+#error "No 2 byte integer type found!"
+#endif
+
+#if SIZEOF_INT == 4
+typedef int int32_t;
+typedef unsigned int uint32_t;
+#elif SIZEOF_LONG == 4
+typedef long int32_t;
+typedef unsigned long uint32_t;
+#else
+#error "No 4 byte integer type found!"
+#endif
+
+#if SIZEOF_LONG == 8
+typedef long int64_t;
+typedef unsigned long uint64_t;
+#elif SIZEOF_LONG_LONG == 8
+typedef long long int64_t;
+typedef unsigned long long uint64_t;
+#endif
+
+#endif
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/randmtzig.h b/liboctave/randmtzig.h
--- a/liboctave/randmtzig.h
+++ b/liboctave/randmtzig.h
@@ -49,36 +49,16 @@
 #include "oct-types.h"
 
 #define MT_N 624
 
 #ifdef  __cplusplus
 extern "C" {
 #endif
 
-#ifdef HAVE_INTTYPES_H
-#include <inttypes.h>
-#else
-#if SIZEOF_INT == 4
-typedef unsigned int uint32_t;
-#elif SIZEOF_LONG == 4
-typedef unsigned long uint32_t;
-#else
-#error "No 4 byte integer type found!"
-#endif
-
-#if SIZEOF_LONG == 8
-typedef unsigned long uint64_t;
-#else
-#if SIZEOF_LONG_LONG == 8
-typedef unsigned long long uint64_t;
-#endif
-#endif
-#endif
-
 /* === Mersenne Twister === */
 extern void oct_init_by_int (uint32_t s);
 extern void oct_init_by_array (uint32_t init_key[], int key_length);
 extern void oct_init_by_entropy (void);
 extern void oct_set_state (uint32_t save[]);
 extern void oct_get_state (uint32_t save[]);
 
 /* === Array generators === */
diff --git a/src/DLD-FUNCTIONS/getrusage.cc b/src/DLD-FUNCTIONS/getrusage.cc
--- a/src/DLD-FUNCTIONS/getrusage.cc
+++ b/src/DLD-FUNCTIONS/getrusage.cc
@@ -196,22 +196,22 @@ elements @code{sec} (seconds) @code{usec
   tv_tmp.assign ("usec", static_cast<double> (fraction * 1e6 / HZ));
   m.assign ("stime", octave_value (tv_tmp));
 
 #elif defined (__MINGW32__)
   HANDLE hProcess = GetCurrentProcess ();
   FILETIME ftCreation, ftExit, ftUser, ftKernel;
   GetProcessTimes (hProcess, &ftCreation, &ftExit, &ftKernel, &ftUser);
 
-  EIGHT_BYTE_INT itmp = *(reinterpret_cast<EIGHT_BYTE_INT *> (&ftUser));
+  int64_t itmp = *(reinterpret_cast<int64_t *> (&ftUser));
   tv_tmp.assign ("sec", static_cast<double> (itmp / 10000000U));
   tv_tmp.assign ("usec", static_cast<double> (itmp % 10000000U) / 10.);
   m.assign ("utime", octave_value (tv_tmp));
 
-  itmp = *(reinterpret_cast<EIGHT_BYTE_INT *> (&ftKernel));
+  itmp = *(reinterpret_cast<int64_t *> (&ftKernel));
   tv_tmp.assign ("sec", static_cast<double> (itmp / 10000000U));
   tv_tmp.assign ("usec", static_cast<double> (itmp % 10000000U) / 10.);
   m.assign ("stime", octave_value (tv_tmp));
 #else
 
   tv_tmp.assign ("sec", 0);
   tv_tmp.assign ("usec", 0);
   m.assign ("utime", octave_value (tv_tmp));
diff --git a/src/DLD-FUNCTIONS/sort.cc b/src/DLD-FUNCTIONS/sort.cc
--- a/src/DLD-FUNCTIONS/sort.cc
+++ b/src/DLD-FUNCTIONS/sort.cc
@@ -235,70 +235,70 @@ mx_sort_indexed (ArrayN<T> &m, int dim, 
 
   return retval;
 }
 
 // If we have IEEE 754 data format, then we can use the trick of
 // casting doubles as unsigned eight byte integers, and with a little
 // bit of magic we can automatically sort the NaN's correctly.
 
-#if defined (HAVE_IEEE754_DATA_FORMAT) && defined (EIGHT_BYTE_INT)
+#if defined (HAVE_IEEE754_DATA_FORMAT)
 
-static inline unsigned EIGHT_BYTE_INT
-FloatFlip (unsigned EIGHT_BYTE_INT f)
+static inline uint64_t
+FloatFlip (uint64_t f)
 {
-  unsigned EIGHT_BYTE_INT mask
-    = -static_cast<EIGHT_BYTE_INT>(f >> 63) | 0x8000000000000000ULL;
+  uint64_t mask
+    = -static_cast<int64_t>(f >> 63) | 0x8000000000000000ULL;
 
   return f ^ mask;
 }
 
-static inline unsigned EIGHT_BYTE_INT
-IFloatFlip (unsigned EIGHT_BYTE_INT f)
+static inline uint64_t
+IFloatFlip (uint64_t f)
 {
-  unsigned EIGHT_BYTE_INT mask = ((f >> 63) - 1) | 0x8000000000000000ULL;
+  uint64_t mask = ((f >> 63) - 1) | 0x8000000000000000ULL;
 
   return f ^ mask;
 }
 
 template <>
 bool
-ascending_compare (unsigned EIGHT_BYTE_INT a, 
-		   unsigned EIGHT_BYTE_INT b)
+ascending_compare (uint64_t a, 
+		   uint64_t b)
 {
   return (a < b);
 }
 
 template <>
 bool
-ascending_compare (vec_index<unsigned EIGHT_BYTE_INT> *a, 
-		   vec_index<unsigned EIGHT_BYTE_INT> *b)
+ascending_compare (vec_index<uint64_t> *a, 
+		   vec_index<uint64_t> *b)
 {
   return (a->vec < b->vec);
 }
 
 template <>
 bool
-descending_compare (unsigned EIGHT_BYTE_INT a, 
-		    unsigned EIGHT_BYTE_INT b)
+descending_compare (uint64_t a, 
+		    uint64_t b)
 {
   return (a > b);
 }
 
 template <>
 bool
-descending_compare (vec_index<unsigned EIGHT_BYTE_INT> *a, 
-		    vec_index<unsigned EIGHT_BYTE_INT> *b)
+descending_compare (vec_index<uint64_t> *a, 
+		    vec_index<uint64_t> *b)
 {
   return (a->vec > b->vec);
 }
 
-template class octave_sort<unsigned EIGHT_BYTE_INT>;
-template class vec_index<unsigned EIGHT_BYTE_INT>;
-template class octave_sort<vec_index<unsigned EIGHT_BYTE_INT> *>;
+template class octave_sort<uint64_t>;
+template class vec_index<uint64_t>;
+template class octave_sort<vec_index<uint64_t> *>;
 
 template <>
 octave_value
 mx_sort (ArrayN<double> &m, int dim, sortmode mode)
 {
   octave_value retval;
 
   dim_vector dv = m.dims ();
@@ -309,19 +309,19 @@ mx_sort (ArrayN<double> &m, int dim, sor
   octave_idx_type ns = dv(dim);
   octave_idx_type iter = dv.numel () / ns;
   octave_idx_type stride = 1;
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
   double *v = m.fortran_vec ();
 
-  unsigned EIGHT_BYTE_INT *p = reinterpret_cast<unsigned EIGHT_BYTE_INT *> (v);
+  uint64_t *p = reinterpret_cast<uint64_t *> (v);
 
-  octave_sort<unsigned EIGHT_BYTE_INT> sort;
+  octave_sort<uint64_t> sort;
 
   if (mode == ASCENDING)
     sort.set_compare (ascending_compare);
   else if (mode == DESCENDING)
     sort.set_compare (descending_compare);
 
   if (stride == 1)
     {
@@ -368,17 +368,17 @@ mx_sort (ArrayN<double> &m, int dim, sor
 		  vtmp[l] = octave_NaN;
 	      }
 
 	  p += ns;
 	}
     }
   else
     {
-      OCTAVE_LOCAL_BUFFER (unsigned EIGHT_BYTE_INT, vi, ns);
+      OCTAVE_LOCAL_BUFFER (uint64_t, vi, ns);
 
       for (octave_idx_type j = 0; j < iter; j++)
 	{
 	  octave_idx_type offset = j;
 	  octave_idx_type offset2 = 0;
 	  while (offset >= stride)
 	    {
 	      offset -= stride;
@@ -451,27 +451,27 @@ mx_sort_indexed (ArrayN<double> &m, int 
   octave_idx_type ns = dv(dim);
   octave_idx_type iter = dv.numel () / ns;
   octave_idx_type stride = 1;
   for (int i = 0; i < dim; i++)
     stride *= dv(i);
 
   double *v = m.fortran_vec ();
 
-  unsigned EIGHT_BYTE_INT *p = reinterpret_cast<unsigned EIGHT_BYTE_INT *> (v);
+  uint64_t *p = reinterpret_cast<uint64_t *> (v);
 
-  octave_sort<vec_index<unsigned EIGHT_BYTE_INT> *> indexed_sort;
+  octave_sort<vec_index<uint64_t> *> indexed_sort;
 
   if (mode == ASCENDING)
     indexed_sort.set_compare (ascending_compare);
   else if (mode == DESCENDING)
     indexed_sort.set_compare (descending_compare);
 
-  OCTAVE_LOCAL_BUFFER (vec_index<unsigned EIGHT_BYTE_INT> *, vi, ns);
-  OCTAVE_LOCAL_BUFFER (vec_index<unsigned EIGHT_BYTE_INT>, vix, ns);
+  OCTAVE_LOCAL_BUFFER (vec_index<uint64_t> *, vi, ns);
+  OCTAVE_LOCAL_BUFFER (vec_index<uint64_t>, vix, ns);
   
   for (octave_idx_type i = 0; i < ns; i++)
     vi[i] = &vix[i];
 
   NDArray idx (dv);
       
   for (octave_idx_type j = 0; j < iter; j++)
     {
diff --git a/src/bitfcns.cc b/src/bitfcns.cc
--- a/src/bitfcns.cc
+++ b/src/bitfcns.cc
@@ -283,25 +283,25 @@ DEFUN (bitxor, args, ,
 Return the bitwise XOR of nonnegative integers.\n\
 @var{x}, @var{y} must be in range [0..bitmax]\n\
 @seealso{bitand, bitor, bitset, bitget, bitcmp, bitshift, bitmax}\n\
 @end deftypefn")
 {
   BITOP (^, "bitxor");
 }
 
-static EIGHT_BYTE_INT
-bitshift (double a, int n, EIGHT_BYTE_INT mask)
+static int64_t
+bitshift (double a, int n, int64_t mask)
 {
   if (n > 0)
-    return (static_cast<EIGHT_BYTE_INT> (a) << n) & mask;
+    return (static_cast<int64_t> (a) << n) & mask;
   else if (n < 0)
-    return (static_cast<EIGHT_BYTE_INT> (a) >> -n) & mask;
+    return (static_cast<int64_t> (a) >> -n) & mask;
   else
-    return static_cast<EIGHT_BYTE_INT> (a) & mask;
+    return static_cast<int64_t> (a) & mask;
 }
 
 // Note that the bitshift operators are undefined if shifted by more
 // bits than in the type, so we need to test for the size of the
 // shift.
 
 #define DO_BITSHIFT(T) \
   if (! error_state) \
@@ -452,17 +452,17 @@ bitshift ([1, 10], 2, [3,4])\n\
 	DO_SBITSHIFT (int16, nbits < 16 ? nbits : 16);
       else if (cname == "int32")
 	DO_SBITSHIFT (int32, nbits < 32 ? nbits : 32);
       else if (cname == "int64")
 	DO_SBITSHIFT (int64, nbits < 64 ? nbits : 64);
       else if (cname == "double")
 	{
 	  nbits = (nbits < 53 ? nbits : 53);
-	  EIGHT_BYTE_INT mask = 0x1FFFFFFFFFFFFFLL;
+	  int64_t mask = 0x1FFFFFFFFFFFFFLL;
 	  if (nbits < 53)
 	    mask = mask >> (53 - nbits);
 	  else if (nbits < 1)
 	    mask = 0;
 	  int bits_in_type = 64;
 	  NDArray m = m_arg.array_value ();
 	  DO_BITSHIFT ( );
 	}
@@ -527,31 +527,31 @@ The default for @var{type} is @code{uint
     cname = args(0).string_value ();
   else if (nargin != 0)
     {
       print_usage ();
       return retval;
     }
 
   if (cname == "uint8")
-    retval = octave_uint8 (std::numeric_limits<octave_uint8_t>::max ());
+    retval = octave_uint8 (std::numeric_limits<uint8_t>::max ());
   else if (cname == "uint16")
-    retval = octave_uint16 (std::numeric_limits<octave_uint16_t>::max ());
+    retval = octave_uint16 (std::numeric_limits<uint16_t>::max ());
   else if (cname == "uint32")
-    retval = octave_uint32 (std::numeric_limits<octave_uint32_t>::max ());
+    retval = octave_uint32 (std::numeric_limits<uint32_t>::max ());
   else if (cname == "uint64")
-    retval = octave_uint64 (std::numeric_limits<octave_uint64_t>::max ());
+    retval = octave_uint64 (std::numeric_limits<uint64_t>::max ());
   else if (cname == "int8")
-    retval = octave_int8 (std::numeric_limits<octave_int8_t>::max ());
+    retval = octave_int8 (std::numeric_limits<int8_t>::max ());
   else if (cname == "int16")
-    retval = octave_int16 (std::numeric_limits<octave_int16_t>::max ());
+    retval = octave_int16 (std::numeric_limits<int16_t>::max ());
   else if (cname == "int32")
-    retval = octave_int32 (std::numeric_limits<octave_int32_t>::max ());
+    retval = octave_int32 (std::numeric_limits<int32_t>::max ());
   else if (cname == "int64")
-    retval = octave_int64 (std::numeric_limits<octave_int64_t>::max ());
+    retval = octave_int64 (std::numeric_limits<int64_t>::max ());
   else
     error ("intmax: not defined for '%s' objects", cname.c_str ());
 
   return retval;
 }
 
 DEFUN (intmin, args, ,
   "-*- texinfo -*-\n\
@@ -590,31 +590,31 @@ The default for @var{type} is @code{uint
     cname = args(0).string_value ();
   else if (nargin != 0)
     {
       print_usage ();
       return retval;
     }
 
   if (cname == "uint8")
-    retval = octave_uint8 (std::numeric_limits<octave_uint8_t>::min ());
+    retval = octave_uint8 (std::numeric_limits<uint8_t>::min ());
   else if (cname == "uint16")
-    retval = octave_uint16 (std::numeric_limits<octave_uint16_t>::min());
+    retval = octave_uint16 (std::numeric_limits<uint16_t>::min());
   else if (cname == "uint32")
-    retval = octave_uint32 (std::numeric_limits<octave_uint32_t>::min ());
+    retval = octave_uint32 (std::numeric_limits<uint32_t>::min ());
   else if (cname == "uint64")
-    retval = octave_uint64 (std::numeric_limits<octave_uint64_t>::min ());
+    retval = octave_uint64 (std::numeric_limits<uint64_t>::min ());
   else if (cname == "int8")
-    retval = octave_int8 (std::numeric_limits<octave_int8_t>::min ());
+    retval = octave_int8 (std::numeric_limits<int8_t>::min ());
   else if (cname == "int16")
-    retval = octave_int16 (std::numeric_limits<octave_int16_t>::min ());
+    retval = octave_int16 (std::numeric_limits<int16_t>::min ());
   else if (cname == "int32")
-    retval = octave_int32 (std::numeric_limits<octave_int32_t>::min ());
+    retval = octave_int32 (std::numeric_limits<int32_t>::min ());
   else if (cname == "int64")
-    retval = octave_int64 (std::numeric_limits<octave_int64_t>::min ());
+    retval = octave_int64 (std::numeric_limits<int64_t>::min ());
   else
     error ("intmin: not defined for '%s' objects", cname.c_str ());
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -355,17 +355,17 @@ get_file_format (std::istream& file)
   bool swap = false;
 
   if (read_binary_file_header (file, swap, flt_fmt, true) == 0)
     retval = LS_BINARY;
   else
     {
       file.seekg (0, std::ios::beg);
 
-      FOUR_BYTE_INT mopt, nr, nc, imag, len;
+      int32_t mopt, nr, nc, imag, len;
 
       int err = read_mat_file_header (file, swap, mopt, nr, nc, imag, len, 1);
 
       if (! err)
 	retval = LS_MAT_BINARY;
       else
 	{
 	  file.clear ();
@@ -1203,17 +1203,17 @@ write_header (std::ostream& os, load_sav
 	os.write (&tmp, 1);
       }
       break;
 
     case LS_MAT5_BINARY:
     case LS_MAT7_BINARY:
       {
 	char const * versionmagic;
-	TWO_BYTE_INT number = *(TWO_BYTE_INT *)"\x00\x01";
+	int16_t number = *(int16_t *)"\x00\x01";
 	struct tm bdt;
 	time_t now;
 	char headertext[128];
 
 	time (&now);
 	bdt = *gmtime (&now);
 	memset (headertext, ' ', 124);
 	// ISO 8601 format date
diff --git a/src/ls-mat4.cc b/src/ls-mat4.cc
--- a/src/ls-mat4.cc
+++ b/src/ls-mat4.cc
@@ -104,19 +104,19 @@ read_mat_binary_data (std::istream& is, 
       break;
 
     default:
       break;
     }
 }
 
 int
-read_mat_file_header (std::istream& is, bool& swap, FOUR_BYTE_INT& mopt, 
-		      FOUR_BYTE_INT& nr, FOUR_BYTE_INT& nc,
-		      FOUR_BYTE_INT& imag, FOUR_BYTE_INT& len,
+read_mat_file_header (std::istream& is, bool& swap, int32_t& mopt, 
+		      int32_t& nr, int32_t& nc,
+		      int32_t& imag, int32_t& len,
 		      int quiet)
 {
   swap = false;
 
   // We expect to fail here, at the beginning of a record, so not
   // being able to read another mopt value should not result in an
   // error.
 
@@ -271,17 +271,17 @@ read_mat_binary_data (std::istream& is, 
   oct_mach_info::float_format flt_fmt = oct_mach_info::flt_fmt_unknown;
   bool swap = false;
   int type = 0;
   int prec = 0;
   int order = 0;
   int mach = 0;
   int dlen = 0;
 
-  FOUR_BYTE_INT mopt, nr, nc, imag, len;
+  int32_t mopt, nr, nc, imag, len;
 
   int err = read_mat_file_header (is, swap, mopt, nr, nc, imag, len);
   if (err)
     {
       if (err < 0)
 	goto data_read_error;
       else
 	return retval;
@@ -384,42 +384,42 @@ read_mat_binary_data (std::istream& is, 
 
 // Save the data from TC along with the corresponding NAME on stream OS 
 // in the MatLab version 4 binary format.
 
 bool
 save_mat_binary_data (std::ostream& os, const octave_value& tc,
 		      const std::string& name) 
 {
-  FOUR_BYTE_INT mopt = 0;
+  int32_t mopt = 0;
 
   mopt += tc.is_string () ? 1 : 0;
 
   oct_mach_info::float_format flt_fmt =
     oct_mach_info::native_float_format ();;
 
   mopt += 1000 * float_format_to_mopt_digit (flt_fmt);
 
   os.write (reinterpret_cast<char *> (&mopt), 4);
   
-  FOUR_BYTE_INT nr = tc.rows ();
+  int32_t nr = tc.rows ();
   os.write (reinterpret_cast<char *> (&nr), 4);
 
-  FOUR_BYTE_INT nc = tc.columns ();
+  int32_t nc = tc.columns ();
   os.write (reinterpret_cast<char *> (&nc), 4);
 
   octave_idx_type len = nr * nc;
 
-  FOUR_BYTE_INT imag = tc.is_complex_type () ? 1 : 0;
+  int32_t imag = tc.is_complex_type () ? 1 : 0;
   os.write (reinterpret_cast<char *> (&imag), 4);
 
   // LEN includes the terminating character, and the file is also
   // supposed to include it.
 
-  FOUR_BYTE_INT name_len = name.length () + 1;
+  int32_t name_len = name.length () + 1;
 
   os.write (reinterpret_cast<char *> (&name_len), 4);
   os << name << '\0';
 
   if (tc.is_string ())
     {
       unwind_protect::begin_frame ("save_mat_binary_data");
 
diff --git a/src/ls-mat4.h b/src/ls-mat4.h
--- a/src/ls-mat4.h
+++ b/src/ls-mat4.h
@@ -26,20 +26,19 @@ 02110-1301, USA.
 
 extern oct_mach_info::float_format
 mopt_digit_to_float_format (int mach);
 
 extern int
 float_format_to_mopt_digit (oct_mach_info::float_format flt_fmt);
 
 extern int
-read_mat_file_header (std::istream& is, bool& swap, FOUR_BYTE_INT& mopt, 
-		      FOUR_BYTE_INT& nr, FOUR_BYTE_INT& nc,
-		      FOUR_BYTE_INT& imag, FOUR_BYTE_INT& len,
-		      int quiet = 0);
+read_mat_file_header (std::istream& is, bool& swap, int32_t& mopt, 
+		      int32_t& nr, int32_t& nc, int32_t& imag,
+		      int32_t& len, int quiet = 0);
 
 extern std::string
 read_mat_binary_data (std::istream& is, const std::string& filename,
 		      octave_value& tc);
 
 extern bool
 save_mat_binary_data (std::ostream& os, const octave_value& tc,
 		      const std::string& name) ;
diff --git a/src/ls-mat5.cc b/src/ls-mat5.cc
--- a/src/ls-mat5.cc
+++ b/src/ls-mat5.cc
@@ -146,23 +146,23 @@ read_mat5_binary_data (std::istream& is,
       read_doubles (is, data, LS_DOUBLE, count, swap, flt_fmt);
       break;
 
     case miRESERVE2:
     case miRESERVE3:
       break;
 
     case miINT64:
-#ifdef EIGHT_BYTE_INT
+#ifdef int64_t
       read_doubles (is, data, LS_LONG, count, swap, flt_fmt);
 #endif
       break;
 
     case miUINT64:
-#ifdef EIGHT_BYTE_INT
+#ifdef int64_t
       read_doubles (is, data, LS_U_LONG, count, swap, flt_fmt);
 #endif
       break;
 
     case miMATRIX:
     default:
       break;
     }
@@ -187,55 +187,55 @@ read_mat5_integer_data (std::istream& is
 	    data[i] = ptr[i]; \
 	} \
     } \
   while (0)
 
   switch (type)
     {
     case miINT8:
-      READ_INTEGER_DATA (signed char, swap, m, 1, count, is);
+      READ_INTEGER_DATA (int8_t, swap, m, 1, count, is);
       break;
 
     case miUINT8:
-      READ_INTEGER_DATA (unsigned char, swap, m, 1, count, is);
+      READ_INTEGER_DATA (uint8_t, swap, m, 1, count, is);
       break;
 
     case miINT16:
-      READ_INTEGER_DATA (signed TWO_BYTE_INT, swap, m, 2, count, is);
+      READ_INTEGER_DATA (int16_t, swap, m, 2, count, is);
       break;
 
     case miUINT16:
-      READ_INTEGER_DATA (unsigned TWO_BYTE_INT, swap, m, 2, count, is);
+      READ_INTEGER_DATA (uint16_t, swap, m, 2, count, is);
       break;
 
     case miINT32:
-      READ_INTEGER_DATA (signed FOUR_BYTE_INT, swap, m, 4, count, is);
+      READ_INTEGER_DATA (int32_t, swap, m, 4, count, is);
       break;
 
     case miUINT32:
-      READ_INTEGER_DATA (unsigned FOUR_BYTE_INT, swap, m, 4, count, is);
+      READ_INTEGER_DATA (uint32_t, swap, m, 4, count, is);
       break;
 
     case miSINGLE:
     case miRESERVE1:
     case miDOUBLE:
     case miRESERVE2:
     case miRESERVE3:
       break;
 
     case miINT64:
-#ifdef EIGHT_BYTE_INT
-      READ_INTEGER_DATA (signed EIGHT_BYTE_INT, swap, m, 8, count, is);
+#ifdef int64_t
+      READ_INTEGER_DATA (int64_t, swap, m, 8, count, is);
 #endif
       break;
 
     case miUINT64:
-#ifdef EIGHT_BYTE_INT
-      READ_INTEGER_DATA (unsigned EIGHT_BYTE_INT, swap, m, 8, count, is);
+#ifdef int64_t
+      READ_INTEGER_DATA (uint64_t, swap, m, 8, count, is);
 #endif
       break;
 
     case miMATRIX:
     default:
       break;
     }
 
@@ -333,17 +333,17 @@ template void read_mat5_integer_data (st
   
 // Read one element tag from stream IS, 
 // place the type code in TYPE and the byte count in BYTES
 // return nonzero on error
 static int
 read_mat5_tag (std::istream& is, bool swap, int& type, int& bytes)
 {
   unsigned int upper;
-  FOUR_BYTE_INT temp;
+  int32_t temp;
 
   if (! is.read (reinterpret_cast<char *> (&temp), 4 ))
     goto data_read_error;
 
   if (swap)
     swap_bytes<4> (&temp);
 
   upper = (temp >> 16) & 0xffff;
@@ -365,17 +365,17 @@ read_mat5_tag (std::istream& is, bool sw
 
   return 0;
 
  data_read_error:
   return 1;
 }
 
 static void
-read_int (std::istream& is, bool swap, FOUR_BYTE_INT& val)
+read_int (std::istream& is, bool swap, int32_t& val)
 {
   is.read (reinterpret_cast<char *> (&val), 4);
 
   if (swap)
     swap_bytes<4> (&val);
 }
 
 // Extract one data element (scalar, matrix, string, etc.) from stream
@@ -396,24 +396,24 @@ read_mat5_binary_element (std::istream& 
   // first used to avoid errors from gcc about goto crossing
   // initialization of variable.
 
   oct_mach_info::float_format flt_fmt = oct_mach_info::flt_fmt_unknown;
   int type = 0;
   bool imag;
   bool logicalvar;
   enum arrayclasstype arrayclass;
-  FOUR_BYTE_INT nzmax;
-  FOUR_BYTE_INT flags;
+  int32_t nzmax;
+  int32_t flags;
   dim_vector dims;
   int len;
   int element_length;
   std::streampos pos;
-  TWO_BYTE_INT number;
-  number = *(TWO_BYTE_INT *)"\x00\x01";
+  int16_t number;
+  number = *(int16_t *)"\x00\x01";
 
   global = false;
 
   // MAT files always use IEEE floating point
   if ((number == 1) ^ swap)
     flt_fmt = oct_mach_info::flt_fmt_ieee_big_endian;
   else
     flt_fmt = oct_mach_info::flt_fmt_ieee_little_endian;
@@ -493,29 +493,29 @@ read_mat5_binary_element (std::istream& 
   imag = (flags & 0x0800) != 0;	// has an imaginary part?
   global = (flags & 0x0400) != 0; // global variable?
   logicalvar = (flags & 0x0200) != 0; // boolean ?
   arrayclass = static_cast<arrayclasstype> (flags & 0xff);
   read_int (is, swap, nzmax);	// max number of non-zero in sparse
   
   // dimensions array subelement
   {
-    FOUR_BYTE_INT dim_len;
+    int32_t dim_len;
 
     if (read_mat5_tag (is, swap, type, dim_len) || type != miINT32)
       {
 	error ("load: invalid dimensions array subelement");
 	goto early_read_error;
       }
 
     int ndims = dim_len / 4;
     dims.resize (ndims);
     for (int i = 0; i < ndims; i++)
       {
-	FOUR_BYTE_INT n;
+	int32_t n;
 	read_int (is, swap, n);
 	dims(i) = n;
       }
 
     std::streampos tmp_pos = is.tellg ();
     is.seekg (tmp_pos + static_cast<std::streamoff> (PAD (dim_len) - dim_len));
   }
 
@@ -654,17 +654,17 @@ read_mat5_binary_element (std::istream& 
 
 	// real data subelement
 	if (read_mat5_tag (is, swap, type, len))
 	  {
 	    error ("load: reading sparse matrix data for `%s'", retval.c_str ());
 	    goto data_read_error;
 	  }
 
-	FOUR_BYTE_INT nnz = cidx[nc];
+	int32_t nnz = cidx[nc];
 	NDArray re;
 	if (imag)
 	  {
 	    re = NDArray (dim_vector (static_cast<int> (nnz)));
 	    data = re.fortran_vec ();
 	  }
 
 	tmp_pos = is.tellg ();
@@ -713,19 +713,19 @@ read_mat5_binary_element (std::istream& 
 
     case mxFUNCTION_CLASS:
       warning ("load: function handles are not implemented");
       goto skip_ahead;
 
     case mxSTRUCT_CLASS:
       {
 	Octave_map m;
-	FOUR_BYTE_INT fn_type;
-	FOUR_BYTE_INT fn_len;
-	FOUR_BYTE_INT field_name_length;
+	int32_t fn_type;
+	int32_t fn_len;
+	int32_t field_name_length;
 
 	// field name length subelement -- actually the maximum length
 	// of a field name.  The Matlab docs promise this will always
 	// be 32.  We read and use the actual value, on the theory
 	// that eventually someone will recognize that's a waste of
 	// space.
 	if (read_mat5_tag (is, swap, fn_type, fn_len) || fn_type != miINT32)
 	  {
@@ -968,17 +968,17 @@ read_mat5_binary_element (std::istream& 
   warning ("skipping over `%s'", retval.c_str ());
   is.seekg (pos + static_cast<std::streamoff> (element_length));
   return read_mat5_binary_element (is, filename, swap, global, tc);
 }
 
 int
 read_mat5_binary_file_header (std::istream& is, bool& swap, bool quiet)
 {
-  TWO_BYTE_INT version=0, magic=0;
+  int16_t version=0, magic=0;
 
   is.seekg (124, std::ios::beg);
   is.read (reinterpret_cast<char *> (&version), 2);
   is.read (reinterpret_cast<char *> (&magic), 2);
 
   if (magic == 0x4d49)
     swap = 0;
   else if (magic == 0x494d)
@@ -998,17 +998,17 @@ read_mat5_binary_file_header (std::istre
 	     "but only prepared for version 1", version);
 
   return 0;
 }
 
 static int 
 write_mat5_tag (std::ostream& is, int type, int bytes)
 {
-  FOUR_BYTE_INT temp;
+  int32_t temp;
 
   if (bytes <= 4)
     temp = (bytes << 16) + type;
   else
     {
       temp = type;
       if (! is.write (reinterpret_cast<char *> (&temp), 4))
 	goto data_write_error;
@@ -1079,50 +1079,50 @@ write_mat5_array (std::ostream& os, cons
 
   len = nel*size;
   write_mat5_tag (os, mst, len);
 
   {
     switch (st)
       {
       case LS_U_CHAR:
-	MAT5_DO_WRITE (unsigned char, data, nel, os);
+	MAT5_DO_WRITE (uint8_t, data, nel, os);
 	break;
 	
       case LS_U_SHORT:
-	MAT5_DO_WRITE (unsigned TWO_BYTE_INT, data, nel, os);
+	MAT5_DO_WRITE (uint16_t, data, nel, os);
 	break;
 	
       case LS_U_INT:
-	MAT5_DO_WRITE (unsigned FOUR_BYTE_INT, data, nel, os);
+	MAT5_DO_WRITE (uint32_t, data, nel, os);
 	break;
 	
 	// provide for 64 bit ints, even though get_save_type does
 	// not yet implement them
-#ifdef EIGHT_BYTE_INT
+#ifdef int64_t
       case LS_U_LONG:
-	MAT5_DO_WRITE (unsigned EIGHT_BYTE_INT, data, nel, os);
+	MAT5_DO_WRITE (uint64_t, data, nel, os);
 	break;
 #endif
 
       case LS_CHAR:
-	MAT5_DO_WRITE (signed char, data, nel, os);
+	MAT5_DO_WRITE (int8_t, data, nel, os);
 	break;
 	
       case LS_SHORT:
-	MAT5_DO_WRITE (TWO_BYTE_INT, data, nel, os);
+	MAT5_DO_WRITE (int16_t, data, nel, os);
 	break;
 
       case LS_INT:
-	MAT5_DO_WRITE (FOUR_BYTE_INT, data, nel, os);
+	MAT5_DO_WRITE (int32_t, data, nel, os);
 	break;
 
-#ifdef EIGHT_BYTE_INT
+#ifdef int64_t
       case LS_LONG:
-	MAT5_DO_WRITE (EIGHT_BYTE_INT, data, nel, os);
+	MAT5_DO_WRITE (int64_t, data, nel, os);
 	break;
 #endif
 
       case LS_FLOAT:
 	MAT5_DO_WRITE (float, data, nel, os);
 	break;
 
       case LS_DOUBLE: // No conversion necessary.
@@ -1451,18 +1451,18 @@ save_mat5_element_length (const octave_v
 // OS in the MatLab version 5 binary format.  Return true on success.
 
 bool
 save_mat5_binary_element (std::ostream& os,
 			  const octave_value& tc, const std::string& name,
 			  bool mark_as_global, bool mat7_format,
 			  bool save_as_floats, bool compressing) 
 {
-  FOUR_BYTE_INT flags=0;
-  FOUR_BYTE_INT nnz=0;
+  int32_t flags=0;
+  int32_t nnz=0;
   std::streampos fixup, contin;
   std::string cname = tc.class_name ();
   int max_namelen = (mat7_format ? 63 : 31);
 
 #ifdef HAVE_ZLIB
   if (mat7_format && !compressing)
     {
       bool ret = false;
@@ -1574,17 +1574,17 @@ save_mat5_binary_element (std::ostream& 
     dim_vector dv = tc.dims ();
     int nd = tc.ndims ();
     int dim_len = 4*nd;
 
     write_mat5_tag (os, miINT32, dim_len);
 
     for (int i = 0; i < nd; i++)
       {
-	FOUR_BYTE_INT n = dv(i);
+	int32_t n = dv(i);
 	os.write (reinterpret_cast<char *> (&n), 4);
       }
 
     if (PAD (dim_len) > dim_len)
       {
 	static char buf[9]="\x00\x00\x00\x00\x00\x00\x00\x00";
 	os.write (buf, PAD (dim_len) - dim_len);
       }
@@ -1610,17 +1610,17 @@ save_mat5_binary_element (std::ostream& 
   if (tc.is_string ())
     {
       charMatrix chm = tc.char_matrix_value ();
       int nr = chm.rows ();
       int nc = chm.cols ();
       int len = nr*nc*2;
       int paddedlength = PAD (nr*nc*2);
 
-      OCTAVE_LOCAL_BUFFER (TWO_BYTE_INT, buf, nc*nr+3);
+      OCTAVE_LOCAL_BUFFER (int16_t, buf, nc*nr+3);
       write_mat5_tag (os, miUINT16, len);
 
       for (int i = 0; i < nr; i++)
 	{
 	  std::string tstr = chm.row_as_string (i);
 	  const char *s = tstr.data ();
 
 	  for (int j = 0; j < nc; j++)
@@ -1748,17 +1748,17 @@ save_mat5_binary_element (std::ostream& 
   else if (tc.is_map ()) 
     {
       // an Octave structure */
       // recursively write each element of the structure
       const Octave_map m = tc.map_value ();
 
       {
 	char buf[64];
-	FOUR_BYTE_INT maxfieldnamelength = max_namelen + 1;
+	int32_t maxfieldnamelength = max_namelen + 1;
 	int fieldcnt = 0;
 
 	for (Octave_map::const_iterator i = m.begin (); i != m.end (); i++)
 	  fieldcnt++;
 
 	write_mat5_tag (os, miINT32, 4);
 	os.write (reinterpret_cast<char *> (&maxfieldnamelength), 4);
 	write_mat5_tag (os, miINT8, fieldcnt*maxfieldnamelength);
diff --git a/src/ls-oct-binary.cc b/src/ls-oct-binary.cc
--- a/src/ls-oct-binary.cc
+++ b/src/ls-oct-binary.cc
@@ -136,18 +136,18 @@ read_binary_data (std::istream& is, bool
 		  oct_mach_info::float_format fmt,
 		  const std::string& filename, bool& global,
 		  octave_value& tc, std::string& doc)
 {
   std::string retval;
 
   char tmp = 0;
 
-  FOUR_BYTE_INT name_len = 0;
-  FOUR_BYTE_INT doc_len = 0;
+  int32_t name_len = 0;
+  int32_t doc_len = 0;
 
   doc.resize (0);
 
   // We expect to fail here, at the beginning of a record, so not
   // being able to read another name should not result in an error.
 
   is.read (reinterpret_cast<char *> (&name_len), 4);
   if (! is)
@@ -204,17 +204,17 @@ read_binary_data (std::istream& is, bool
       tc = octave_value_typeinfo::lookup_type ("complex matrix");
       break;
 
     case 5:
       {
 	// FIXMEX
 	// This is cruft, since its for a save type that is old. Maybe
 	// this is taking backward compatability too far!!
-	FOUR_BYTE_INT len;
+	int32_t len;
 	if (! is.read (reinterpret_cast<char *> (&len), 4))
 	  goto data_read_error;
 	if (swap)
 	  swap_bytes<4> (&len);
 	OCTAVE_LOCAL_BUFFER (char, s, len+1);
 	if (! is.read (reinterpret_cast<char *> (s), len))
 	  goto data_read_error;
 	s[len] = '\0';
@@ -231,17 +231,17 @@ read_binary_data (std::istream& is, bool
 
     case 7:
       tc = octave_value_typeinfo::lookup_type ("string");
       break;
 
     case 255:
       {
 	// Read the saved variable type
-	FOUR_BYTE_INT len;
+	int32_t len;
 	if (! is.read (reinterpret_cast<char *> (&len), 4))
 	  goto data_read_error;
 	if (swap)
 	  swap_bytes<4> (&len);
 	OCTAVE_LOCAL_BUFFER (char, s, len+1);
 	if (! is.read (s, len))
 	  goto data_read_error;
 	s[len] = '\0';
@@ -267,38 +267,38 @@ read_binary_data (std::istream& is, bool
 // string DOC, and global flag MARK_AS_GLOBAL on stream OS in the
 // binary format described above for read_binary_data.
 
 bool
 save_binary_data (std::ostream& os, const octave_value& tc,
 		  const std::string& name, const std::string& doc,
 		  bool mark_as_global, bool save_as_floats) 
 {
-  FOUR_BYTE_INT name_len = name.length ();
+  int32_t name_len = name.length ();
 
   os.write (reinterpret_cast<char *> (&name_len), 4);
   os << name;
 
-  FOUR_BYTE_INT doc_len = doc.length ();
+  int32_t doc_len = doc.length ();
 
   os.write (reinterpret_cast<char *> (&doc_len), 4);
   os << doc;
 
   unsigned char tmp;
 
   tmp = mark_as_global;
   os.write (reinterpret_cast<char *> (&tmp), 1);
 
   // 255 flags the new binary format
   tmp = 255;
   os.write (reinterpret_cast<char *> (&tmp), 1);
 
   // Write the string corresponding to the octave_value type
   std::string typ = tc.type_name ();
-  FOUR_BYTE_INT len = typ.length ();
+  int32_t len = typ.length ();
   os.write (reinterpret_cast<char *> (&len), 4);
   const char *btmp = typ.data ();
   os.write (btmp, len);
       
   // The octave_value of tc is const. Make a copy...
   octave_value val = tc;
 
   // Call specific save function
diff --git a/src/ov-base-int.cc b/src/ov-base-int.cc
--- a/src/ov-base-int.cc
+++ b/src/ov-base-int.cc
@@ -129,17 +129,17 @@ template <class T>
 bool 
 octave_base_int_matrix<T>::save_binary (std::ostream& os, bool&)
 {
   dim_vector d = this->dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  FOUR_BYTE_INT tmp = - d.length();
+  int32_t tmp = - d.length();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i=0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   os.write (reinterpret_cast<const char *> (this->matrix.data()), this->byte_size());
@@ -147,26 +147,26 @@ octave_base_int_matrix<T>::save_binary (
   return true;
 }
 
 template <class T>
 bool
 octave_base_int_matrix<T>::load_binary (std::istream& is, bool swap,
 					oct_mach_info::float_format )
 {
-  FOUR_BYTE_INT mdims;
+  int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims >= 0)
     return false;
 
   mdims = - mdims;
-  FOUR_BYTE_INT di;
+  int32_t di;
   dim_vector dv;
   dv.resize (mdims);
 
   for (int i = 0; i < mdims; i++)
     {
       if (! is.read (reinterpret_cast<char *> (&di), 4))
 	return false;
       if (swap)
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -30,16 +30,17 @@ 02110-1301, USA.
 #include <list>
 #include <string>
 
 #if defined (HAVE_HDF5)
 #include <hdf5.h>
 #endif
 
 #include "Range.h"
+#include "data-conv.h"
 #include "mx-base.h"
 #include "str-vec.h"
 
 #include "error.h"
 
 class Cell;
 class streamoff_array;
 class Octave_map;
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -277,17 +277,17 @@ bool
 octave_bool_matrix::save_binary (std::ostream& os, bool& /* save_as_floats */)
 {
 
   dim_vector d = dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  FOUR_BYTE_INT tmp = - d.length();
+  int32_t tmp = - d.length();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   boolNDArray m = bool_array_value ();
@@ -302,29 +302,29 @@ octave_bool_matrix::save_binary (std::os
 
   return true;
 }
 
 bool 
 octave_bool_matrix::load_binary (std::istream& is, bool swap,
 				 oct_mach_info::float_format /* fmt */)
 {
-  FOUR_BYTE_INT mdims;
+  int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims >= 0)
     return false;
 
   // mdims is negative for consistency with other matrices, where it is
   // negative to allow the positive value to be used for rows/cols for
   // backward compatibility
   mdims = - mdims;
-  FOUR_BYTE_INT di;
+  int32_t di;
   dim_vector dv;
   dv.resize (mdims);
 
   for (int i = 0; i < mdims; i++)
     {
       if (! is.read (reinterpret_cast<char *> (&di), 4))
 	return false;
       if (swap)
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -199,17 +199,17 @@ octave_sparse_bool_matrix::save_binary (
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
   int nr = d(0);
   int nc = d(1);
   int nz = nzmax ();
 
-  FOUR_BYTE_INT itmp;
+  int32_t itmp;
   // Use negative value for ndims to be consistent with other formats
   itmp= -2;        
   os.write (reinterpret_cast<char *> (&itmp), 4);
   
   itmp= nr;    
   os.write (reinterpret_cast<char *> (&itmp), 4);
   
   itmp= nc;
@@ -243,17 +243,17 @@ octave_sparse_bool_matrix::save_binary (
 
   return true;
 }
 
 bool
 octave_sparse_bool_matrix::load_binary (std::istream& is, bool swap,
 					oct_mach_info::float_format /* fmt */)
 {
-  FOUR_BYTE_INT nz, nc, nr, tmp;
+  int32_t nz, nc, nr, tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
   if (tmp != -2) {
     error("load: only 2D sparse matrices are supported");
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -615,17 +615,17 @@ octave_cell::load_ascii (std::istream& i
 bool 
 octave_cell::save_binary (std::ostream& os, bool& save_as_floats)
 {
   dim_vector d = dims ();
   if (d.length () < 1)
     return false;
 
   // Use negative value for ndims
-  FOUR_BYTE_INT di = - d.length();
+  int32_t di = - d.length();
   os.write (reinterpret_cast<char *> (&di), 4);
   for (int i = 0; i < d.length (); i++)
     {
       di = d(i);
       os.write (reinterpret_cast<char *> (&di), 4);
     }
   
   Cell tmp = cell_value ();
@@ -645,26 +645,26 @@ octave_cell::save_binary (std::ostream& 
   return true;
 }
 
 bool 
 octave_cell::load_binary (std::istream& is, bool swap,
 				 oct_mach_info::float_format fmt)
 {
   bool success = true;
-  FOUR_BYTE_INT mdims;
+  int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims >= 0)
     return false;
 
   mdims = -mdims;
-  FOUR_BYTE_INT di;
+  int32_t di;
   dim_vector dv;
   dv.resize (mdims);
 
   for (int i = 0; i < mdims; i++)
     {
       if (! is.read (reinterpret_cast<char *> (&di), 4))
 	return false;
       if (swap)
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -377,17 +377,17 @@ octave_complex_matrix::load_ascii (std::
 bool 
 octave_complex_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
   dim_vector d = dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  FOUR_BYTE_INT tmp = - d.length();
+  int32_t tmp = - d.length();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   ComplexNDArray m = complex_array_value ();
@@ -416,25 +416,25 @@ octave_complex_matrix::save_binary (std:
   return true;
 }
 
 bool 
 octave_complex_matrix::load_binary (std::istream& is, bool swap,
 				 oct_mach_info::float_format fmt)
 {
   char tmp;
-  FOUR_BYTE_INT mdims;
+  int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims < 0)
     {
       mdims = - mdims;
-      FOUR_BYTE_INT di;
+      int32_t di;
       dim_vector dv;
       dv.resize (mdims);
 
       for (int i = 0; i < mdims; i++)
 	{
 	  if (! is.read (reinterpret_cast<char *> (&di), 4))
 	    return false;
 	  if (swap)
@@ -462,17 +462,17 @@ octave_complex_matrix::load_binary (std:
       read_doubles (is, reinterpret_cast<double *> (im),
 		    static_cast<save_type> (tmp), 2 * dv.numel (), swap, fmt);
       if (error_state || ! is)
 	return false;
       matrix = m;
     }
   else
     {
-      FOUR_BYTE_INT nr, nc;
+      int32_t nr, nc;
       nr = mdims;
       if (! is.read (reinterpret_cast<char *> (&nc), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&nc);
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
 	return false;
       ComplexMatrix m (nr, nc);
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -209,17 +209,17 @@ octave_sparse_complex_matrix::save_binar
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
   int nr = d(0);
   int nc = d(1);
   int nz = nzmax ();
 
-  FOUR_BYTE_INT itmp;
+  int32_t itmp;
   // Use negative value for ndims to be consistent with other formats
   itmp= -2;        
   os.write (reinterpret_cast<char *> (&itmp), 4);
   
   itmp= nr;    
   os.write (reinterpret_cast<char *> (&itmp), 4);
   
   itmp= nc;
@@ -266,17 +266,17 @@ octave_sparse_complex_matrix::save_binar
 
   return true;
 }
 
 bool
 octave_sparse_complex_matrix::load_binary (std::istream& is, bool swap,
 				   oct_mach_info::float_format fmt)
 {
-  FOUR_BYTE_INT nz, nc, nr, tmp;
+  int32_t nz, nc, nr, tmp;
   char ctmp;
 
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -210,17 +210,17 @@ octave_fcn_handle::load_ascii (std::istr
     }
 
   return true;
 }
 
 bool
 octave_fcn_handle::save_binary (std::ostream& os, bool&)
 {
-  FOUR_BYTE_INT tmp = nm.length ();
+  int32_t tmp = nm.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   os.write (nm.c_str (), nm.length ());
   if (nm == "@<anonymous>")
     {
       std::ostringstream buf;
       print_raw (buf, true);
       std::string stmp = buf.str ();
       tmp = stmp.length ();
@@ -229,17 +229,17 @@ octave_fcn_handle::save_binary (std::ost
     }
   return true;
 }
 
 bool
 octave_fcn_handle::load_binary (std::istream& is, bool swap,
 				oct_mach_info::float_format)
 {
-  FOUR_BYTE_INT tmp;
+  int32_t tmp;
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
   if (swap)
     swap_bytes<4> (&tmp);
 
   OCTAVE_LOCAL_BUFFER (char, ctmp1, tmp+1);
   is.read (ctmp1, tmp);
   nm = std::string (ctmp1);
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -147,17 +147,17 @@ octave_fcn_inline::load_ascii (std::istr
     }
   else
     return false;
 }
 
 bool
 octave_fcn_inline::save_binary (std::ostream& os, bool&)
 {
-  FOUR_BYTE_INT tmp = ifargs.length ();
+  int32_t tmp = ifargs.length ();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i = 0; i < ifargs.length (); i++)
     {
       tmp = ifargs(i).length ();
       os.write (reinterpret_cast<char *> (&tmp), 4);
       os.write (ifargs(i).c_str (), ifargs(i).length ());
     }
   tmp = nm.length ();
@@ -168,27 +168,27 @@ octave_fcn_inline::save_binary (std::ost
   os.write (iftext.c_str (), iftext.length ());
   return true;
 }
 
 bool
 octave_fcn_inline::load_binary (std::istream& is, bool swap,
 				oct_mach_info::float_format)
 {
-  FOUR_BYTE_INT nargs;
+  int32_t nargs;
   if (! is.read (reinterpret_cast<char *> (&nargs), 4))
     return false;
   if (swap)
     swap_bytes<4> (&nargs);
 
   if (nargs < 1)
     return false;
   else
     {
-      FOUR_BYTE_INT tmp;
+      int32_t tmp;
       ifargs.resize (nargs);
       for (int i = 0; i < nargs; i++)
 	{
 	  if (! is.read (reinterpret_cast<char *> (&tmp), 4))
 	    return false;
 	  if (swap)
 	    swap_bytes<4> (&tmp);
 
diff --git a/src/ov-list.cc b/src/ov-list.cc
--- a/src/ov-list.cc
+++ b/src/ov-list.cc
@@ -610,17 +610,17 @@ octave_list::load_ascii (std::istream& i
   return success;
 }
 
 bool 
 octave_list::save_binary (std::ostream& os, bool& save_as_floats)
 {
   octave_value_list lst = list_value ();
 
-  FOUR_BYTE_INT len = lst.length();
+  int32_t len = lst.length();
   os.write (reinterpret_cast<char *> (&len), 4);
   
   for (int i = 0; i < lst.length (); i++)
     {
       // should we use lst.name_tags () to label the elements?
 
       std::ostringstream buf;
       buf << "_" << i;
@@ -636,17 +636,17 @@ octave_list::save_binary (std::ostream& 
   
   return true;
 }
 
 bool 
 octave_list::load_binary (std::istream& is, bool swap,
 			  oct_mach_info::float_format fmt)
 {
-  FOUR_BYTE_INT len;
+  int32_t len;
   if (! is.read (reinterpret_cast<char *> (&len), 4))
     return false;
   if (swap)
     swap_bytes<4> (&len);
 
   if (len > 0)
     {
       octave_value_list lst;
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -424,17 +424,17 @@ bool
 octave_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
 
   dim_vector d = dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  FOUR_BYTE_INT tmp = - d.length();
+  int32_t tmp = - d.length();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i = 0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   NDArray m = array_value ();
@@ -462,25 +462,25 @@ octave_matrix::save_binary (std::ostream
   return true;
 }
 
 bool 
 octave_matrix::load_binary (std::istream& is, bool swap,
 				 oct_mach_info::float_format fmt)
 {
   char tmp;
-  FOUR_BYTE_INT mdims;
+  int32_t mdims;
   if (! is.read (reinterpret_cast<char *> (&mdims), 4))
     return false;
   if (swap)
     swap_bytes<4> (&mdims);
   if (mdims < 0)
     {
       mdims = - mdims;
-      FOUR_BYTE_INT di;
+      int32_t di;
       dim_vector dv;
       dv.resize (mdims);
 
       for (int i = 0; i < mdims; i++)
 	{
 	  if (! is.read (reinterpret_cast<char *> (&di), 4))
 	    return false;
 	  if (swap)
@@ -507,17 +507,17 @@ octave_matrix::load_binary (std::istream
       double *re = m.fortran_vec ();
       read_doubles (is, re, static_cast<save_type> (tmp), dv.numel (), swap, fmt);
       if (error_state || ! is)
 	return false;
       matrix = m;
     }
   else
     {
-      FOUR_BYTE_INT nr, nc;
+      int32_t nr, nc;
       nr = mdims;
       if (! is.read (reinterpret_cast<char *> (&nc), 4))
 	return false;
       if (swap)
 	swap_bytes<4> (&nc);
       if (! is.read (reinterpret_cast<char *> (&tmp), 1))
 	return false;
       Matrix m (nr, nc);
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -251,17 +251,17 @@ octave_sparse_matrix::save_binary (std::
 
   // Ensure that additional memory is deallocated
   matrix.maybe_compress ();
 
   int nr = d(0);
   int nc = d(1);
   int nz = nzmax ();
 
-  FOUR_BYTE_INT itmp;
+  int32_t itmp;
   // Use negative value for ndims to be consistent with other formats
   itmp= -2;        
   os.write (reinterpret_cast<char *> (&itmp), 4);
   
   itmp= nr;    
   os.write (reinterpret_cast<char *> (&itmp), 4);
   
   itmp= nc;
@@ -308,17 +308,17 @@ octave_sparse_matrix::save_binary (std::
 
   return true;
 }
 
 bool
 octave_sparse_matrix::load_binary (std::istream& is, bool swap,
 				   oct_mach_info::float_format fmt)
 {
-  FOUR_BYTE_INT nz, nc, nr, tmp;
+  int32_t nz, nc, nr, tmp;
   char ctmp;
 
   if (! is.read (reinterpret_cast<char *> (&tmp), 4))
     return false;
 
   if (swap)
     swap_bytes<4> (&tmp);
 
diff --git a/src/ov-str-mat.cc b/src/ov-str-mat.cc
--- a/src/ov-str-mat.cc
+++ b/src/ov-str-mat.cc
@@ -451,43 +451,43 @@ bool
 octave_char_matrix_str::save_binary (std::ostream& os,
 				     bool& /* save_as_floats */)
 {
   dim_vector d = dims ();
   if (d.length() < 1)
     return false;
 
   // Use negative value for ndims to differentiate with old format!!
-  FOUR_BYTE_INT tmp = - d.length();
+  int32_t tmp = - d.length();
   os.write (reinterpret_cast<char *> (&tmp), 4);
   for (int i=0; i < d.length (); i++)
     {
       tmp = d(i);
       os.write (reinterpret_cast<char *> (&tmp), 4);
     }
 
   charNDArray m = char_array_value ();
   os.write (m.fortran_vec (), d.numel ());
   return true;
 }
 
 bool 
 octave_char_matrix_str::load_binary (std::istream& is, bool swap,
 				     oct_mach_info::float_format /* fmt */)
 {
-  FOUR_BYTE_INT elements;
+  int32_t elements;
   if (! is.read (reinterpret_cast<char *> (&elements), 4))
     return false;
   if (swap)
     swap_bytes<4> (&elements);
 
   if (elements < 0)
     {
-      FOUR_BYTE_INT mdims = - elements;
-      FOUR_BYTE_INT di;
+      int32_t mdims = - elements;
+      int32_t di;
       dim_vector dv;
       dv.resize (mdims);
 
       for (int i = 0; i < mdims; i++)
 	{
 	  if (! is.read (reinterpret_cast<char *> (&di), 4))
 	    return false;
 	  if (swap)
@@ -516,17 +516,17 @@ octave_char_matrix_str::load_binary (std
       matrix = m;
     }
   else
     {
       charMatrix chm (elements, 0);
       int max_len = 0;
       for (int i = 0; i < elements; i++)
 	{
-	  FOUR_BYTE_INT len;
+	  int32_t len;
 	  if (! is.read (reinterpret_cast<char *> (&len), 4))
 	    return false;
 	  if (swap)
 	    swap_bytes<4> (&len);
 	  OCTAVE_LOCAL_BUFFER (char, btmp, len+1);
 	  if (! is.read (reinterpret_cast<char *> (btmp), len))
 	    return false;
 	  if (len > max_len)
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -1102,17 +1102,17 @@ octave_struct::load_ascii (std::istream&
   return success;
 }
 
 bool 
 octave_struct::save_binary (std::ostream& os, bool& save_as_floats)
 {
   Octave_map m = map_value ();
 
-  FOUR_BYTE_INT len = m.length();
+  int32_t len = m.length();
   os.write (reinterpret_cast<char *> (&len), 4);
   
   Octave_map::iterator i = m.begin ();
   while (i != m.end ())
     {
       octave_value val = map.contents (i);
 
       bool b = save_binary_data (os, val, m.key (i), "", 0, save_as_floats);
@@ -1126,17 +1126,17 @@ octave_struct::save_binary (std::ostream
   return true;
 }
 
 bool 
 octave_struct::load_binary (std::istream& is, bool swap,
 			    oct_mach_info::float_format fmt)
 {
   bool success = true;
-  FOUR_BYTE_INT len;
+  int32_t len;
   if (! is.read (reinterpret_cast<char *> (&len), 4))
     return false;
   if (swap)
     swap_bytes<4> (&len);
 
   if (len > 0)
     {
       Octave_map m (map);
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -30,17 +30,19 @@ 02110-1301, USA.
 #include <string>
 #include <list>
 
 #if defined (HAVE_HDF5)
 #include <hdf5.h>
 #endif
 
 #include "Range.h"
+#include "data-conv.h"
 #include "idx-vector.h"
+#include "mach-info.h"
 #include "mx-base.h"
 #include "oct-alloc.h"
 #include "oct-time.h"
 #include "str-vec.h"
 
 class Cell;
 class streamoff_array;
 class Octave_map;
