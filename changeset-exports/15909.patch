# HG changeset patch
# User Michael Goffioul <michael.goffioul@gmail.com>
# Date 1357492756 18000
#      Sun Jan 06 12:19:16 2013 -0500
# Branch classdef
# Node ID b8bff84022d6ae102ac60dfc262ccf9357f3bdfe
# Parent  a413c6fe1726bcdac03cc71ec2e8558c3bd4da04
Use strong reference between objects and their class.

* libinterp/octave-value/ov-classdef.h (cdef_object_rep::cname): Remove member.
(cdef_object_rep::cdef_object_rep (void),
cdef_object_rep::cdef_object_rep (cdef_object_rep)): Do not initialize it.
(cdef_object_rep::cdef_object_rep (std::string)): Remove constructor.
(cdef_object_rep::set_class_name): Remove method.
(cdef_object_rep::grip_invalid_object): New private method.
(cdef_object_rep::set_class, cdef_object_rep::is_class,
cdef_object_rep::is_property, cdef_object_rep::is_method,
cdef_object_rep::is_package): New methods.
(cdef_object_rep::map, cdef_object_rep::ctor_list): Move members to
cdef_object_scalar.
(cdef_object_rep::put, cdef_object_rep::get, cdef_object_rep::subsref,
cdef_object_rep::subsasgn, cdef_object_rep::mark_for_construction,
cdef_object_rep::is_constructed_for, cdef_object_rep::mark_as_constructed,
cdef_object_rep::is_partially_constructed_for, cdef_object_rep::is_constructed):
Move implementation to cdef_object_scalar.
(cdef_object_rep::is_constructed_for, cdef_object_rep::mark_as_constructed,
cdef_object_rep::is_partially_constructed_for): Change signature, use cdef_class
argument instead of std::string.
(cdef_object_rep::class_name): Use get_class () and move inline definition
after cdef_class declaration.
(cdef_object::set_class_name): Remove method.
(cdef_object::is_class, cdef_object::is_property, cdef_object::is_method,
cdef_object::is_package): New methods.
(cdef_object::is_constructed_for, cdef_object::mark_as_constructed,
cdef_object::is_partially_constructed_for): Change signature, use cdef_class
instead of std::string.
(class cdef_object_base, class cdef_object_scalar): New classes.
(class handle_cdef_object, class value_cdef_object): Inherits from
cdef_object_scalar.
(handle_cdef_object::handle_cdef_object (std::string)): Remove constructor.
(value_cdef_object::value_cdef_object (std::string)): Likewise.
(value_cdef_object::value_cdef_object (value_cdef_object)): Implement copy
constructor.
(value_cdef_object::clone): Use it.
(cdef_class::cdef_class_rep::cdef_class_rep): Remove first string argument.
(cdef_class::cdef_class_rep::is_class, cdef_class::cdef_class_rep::set_name,
cdef_class::cdef_class_rep::wrap): New methods.
(cdef_class::cdef_class_rep::implicit_ctor_list): Change type to
std::list<cdef_class>.
(cdef_class::cdef_class (std::string): Remove constructor.
(cdef_class::cdef_class (std::list<cdef_class>)): Use string argument as
the class name.
(cdef_class::cdef_class (cdef_object), cdef_class::operator= (cdef_object)):
Use is_class method.
(cdef_class::_meta_class, cdef_class::_meta_property, cdef_class::_meta_method,
cdef_class::_meta_package): New static members.
(cdef_class::meta_class, cdef_class::meta_property, cdef_class::meta_method,
cdef_class::meta_package): New static methods.
(operator< (cdef_cass, cdef_class)): New function.
(cdef_property::cdef_property_rep::cdef_property_rep): Remove first argument
string.
(cdef_property::cdef_property_rep::is_property,
cdef_property::cdef_property_rep::get_name,
cdef_property::cdef_property_rep::set_name,
cdef_property::cdef_property_rep::is_constant): New methods.
(cdef_property::get_name, cdef_property::is_constant): Use them.
(cdef_property::cdef_property (std::string)): Use string argument as property
name.
(cdef_property::cdef_property (cdef_object)): Use is_property method.
(cdef_method::cdef_method_rep::cdef_method_rep): Remove first argument
string.
(cdef_method::cdef_method_rep::is_method,
cdef_method::cdef_method_rep::get_name, cdef_method::cdef_method_rep::set_name,
cdef_method::cdef_method_rep::is_static): New methods.
(cdef_method::get_name, cdef_method::is_static): Use them.
(cdef_method::cdef_method (std::string)): Use string argument as method name.
(cdef_method::cdef_method (cdef_object)): Use is_method method.
(cdef_package::cdef_package_rep::cdef_package_rep): Remove first argument
string.
(cdef_package::cdef_package_rep::is_package,
cdef_package::cdef_package_rep::get_name,
cdef_package::cdef_package_rep::set_name): New methods.
(cdef_package::get_name): Likewise.
(cdef_package::cdef_package (std::string)): Use string argument as package name.
(cdef_package::cdef_package (cdef_object)): Use is_package method.
(cdef_package::_meta): New static member.
(cdef_package::meta): New static method.

* libinterp/octave-value/ov-classdef.cc (lookup_class (cdef_class),
lookup_class (octave_value)): New static function overloads.
(lookup_classes): Change argument name to reflect the fact we're using now a
list of cdef_class objects, not a list of names.
(make_class, make_property, make_method, make_package): Use name as constructor
argument. Set object class.
(cdef_object_rep::get_class): Move implementation to header.
(cdef_object_rep::subsref, cdef_object_rep::subsasgn,
cdef_object_rep::mark_for_construction): Move implementation to
cdef_object_scalar.
(cdef_object_scalar::is_constructed_for,
cdef_object_scalar::is_partially_constructed_for): Moved from cdef_object_rep.
(handle_cdef_object::~handle_cdef_object,
value_cdef_object::~value_cdef_object): Do not use cname.
(cdef_class::cdef_class_rep::cdef_class_rep (std::list<cdef_class>)):
Remove first string argument. Keep strong references to cdef_class superclass
objects.
(cdef_class::cdef_class_rep::find_method,
cdef_class::cdef_class_rep::find_methods,
cdef_class::cdef_class_rep::find_property,
cdef_class::cdef_class_rep::find_properties,
cdef_class::cdef_class_rep::find_names,
cdef_class::cdef_class_rep::delete_object): Superclasses are now strong
references for cdef_class objects.
(ctor_analyzer::available_ctor_list): Remove member.
(ctor_analyzer::ctor_analyzer): Do not use it.
(ctor_analyzer::ctor_list): Change type to std::list<cdef_class>.
(ctor_analyzer::visit_funcall): Use it. Do not produce any error.
(cdef_class::cdef_class_rep::install_method): Use strong references to cdef_class
superclass objects.
(cdef_class::cdef_class_rep::run_constructor): Likewise.
(cdef_class::cdef_class_rep::construct): Use strong reference to cdef_class
object.
(cdef_property::cdef_property_rep::get_value,
cdef_property::cdef_property_rep::set_value): Likewise.
(cdef_class::_meta_class, cdef_class::_meta_property,
cdef_class::_meta_method, cdef_class::_meta_package): Initialize static members.
(cdef_package::_meta): Likewise.
(install_classdef): Bootstrap meta classes with strong references to cdef_class.
Assign cdef_class and cdef_package static members.

diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -174,24 +174,49 @@ lookup_class (const std::string& name, b
 	return cls;
       else
 	all_classes.erase (it);
     }
 
   return cdef_class ();
 }
 
+static cdef_class
+lookup_class (const cdef_class& cls)
+{
+  // FIXME: placeholder for the time being, the purpose
+  //        is to centralized any class update activity here.
+
+  return cls;
+}
+
+static cdef_class
+lookup_class (const octave_value& ov)
+{
+  if (ov.is_string())
+    return lookup_class (ov.string_value ());
+  else
+    {
+      cdef_class cls (to_cdef (ov));
+
+      if (! error_state)
+        return lookup_class (cls);
+    }
+
+  return cdef_class ();
+}
+
 static std::list<cdef_class>
-lookup_classes (const Cell& cls_names)
+lookup_classes (const Cell& cls_list)
 {
   std::list<cdef_class> retval;
 
-  for (int i = 0; i < cls_names.numel (); i++)
+  for (int i = 0; i < cls_list.numel (); i++)
     {
-      cdef_class c = lookup_class (cls_names(i).string_value ());
+      cdef_class c = lookup_class (cls_list(i));
 
       if (! error_state)
         retval.push_back (c);
       else
         {
           retval.clear ();
           break;
         }
@@ -222,17 +247,17 @@ is_superclass (const cdef_class& clsa, c
   if (allow_equal && clsa == clsb)
     retval = true;
   else if (max_depth != 0)
     {
       Cell c = clsb.get ("SuperClasses").cell_value ();
 
       for (int i = 0; ! error_state && ! retval && i < c.numel (); i++)
 	{
-	  cdef_class cls = lookup_class (c(i).string_value ());
+	  cdef_class cls = lookup_class (c(i));
 
 	  if (! error_state)
 	    retval = is_superclass (clsa, cls, true,
                                     max_depth < 0 ? max_depth : max_depth-1);
 	}
     }
 
   return retval;
@@ -578,27 +603,27 @@ handle_delete (const octave_value_list& 
 
   return retval;
 }
 
 static cdef_class
 make_class (const std::string& name,
             const std::list<cdef_class>& super_list = std::list<cdef_class> ())
 {
-  cdef_class cls ("meta.class", super_list);
-
+  cdef_class cls (name, super_list);
+
+  cls.set_class (cdef_class::meta_class ());
   cls.put ("ConstructOnLoad", false);
   cls.put ("ContainingPackage", Matrix ());
   cls.put ("Description", std::string ());
   cls.put ("DetailedDescription", std::string ());
   cls.put ("Events", Cell ());
   cls.put ("Hidden", false);
   cls.put ("InferiorClasses", Cell ());
   cls.put ("Methods", Cell ());
-  cls.put ("Name", name);
   cls.put ("Properties", Cell ());
   cls.put ("Sealed", false);
 
   if (name == "handle")
     {
       cls.put ("HandleCompatible", true);
       cls.mark_as_handle_class ();
     }
@@ -647,19 +672,19 @@ static cdef_property
 make_property (const cdef_class& cls, const std::string& name,
 	       const octave_value& get_method = Matrix (),
 	       const std::string& get_access = "public",
 	       const octave_value& set_method = Matrix (),
 	       const std::string& set_access = "public")
 {
   // FIXME: what about default value?
 
-  cdef_property prop ("meta.property");
-
-  prop.put ("Name", name);
+  cdef_property prop (name);
+
+  prop.set_class (cdef_class::meta_property ());
   prop.put ("Description", std::string ());
   prop.put ("DetailedDescription", std::string ());
   prop.put ("Abstract", false);
   prop.put ("Constant", false);
   prop.put ("GetAccess", get_access);
   prop.put ("SetAccess", set_access);
   prop.put ("Dependent", false);
   prop.put ("Transient", false);
@@ -688,25 +713,25 @@ make_attribute (const cdef_class& cls, c
   return make_property (cls, name, Matrix (), "public", Matrix (), "private");
 }
 
 static cdef_method
 make_method (const cdef_class& cls, const std::string& name,
              const octave_value& fcn,const std::string& m_access = "public",
              bool is_static = false)
 {
-  cdef_method meth ("meta.method");
-
+  cdef_method meth (name);
+
+  meth.set_class (cdef_class::meta_method ());
   meth.put ("Abstract", false);
   meth.put ("Access", m_access);
   meth.put ("DefiningClass", to_ov (cls));
   meth.put ("Description", std::string ());
   meth.put ("DetailedDescription", std::string ());
   meth.put ("Hidden", false);
-  meth.put ("Name", name);
   meth.put ("Sealed", true);
   meth.put ("Static", is_static);
 
   make_function_of_class (cls, fcn);
 
   meth.set_function (fcn);
 
   return meth;
@@ -723,20 +748,22 @@ make_method (const cdef_class& cls, cons
 }
 
 static cdef_package
 make_package (const std::string& nm,
               const std::string& parent = std::string ())
 {
   cdef_package pack ("meta.package");
 
-  all_packages[nm] = pack;
+  pack.set_class (cdef_class::meta_package ());
   pack.put ("Name", nm);
   pack.put ("ContainingPackage", to_ov (all_packages[parent]));
 
+  all_packages[nm] = pack;
+
   return pack;
 }
 
 //----------------------------------------------------------------------------
 
 DEFINE_OCTAVE_ALLOCATOR (octave_classdef);
 
 int octave_classdef::t_id (-1);
@@ -976,40 +1003,32 @@ private:
     }
 
 private:
   octave_value_list args;
 };
 
 //----------------------------------------------------------------------------
 
-cdef_class
-cdef_object_rep::get_class (void) const
-{
-  cdef_class cls = lookup_class (class_name ());
-
-  return cls;
-}
-
 string_vector
 cdef_object_rep::map_keys (void) const
 {
   cdef_class cls = get_class ();
 
   if (cls.ok ())
     return cls.get_names ();
   
   return string_vector ();
 }
 
 octave_value_list
-cdef_object_rep::subsref (const std::string& type,
-                          const std::list<octave_value_list>& idx,
-                          int nargout, size_t& skip,
-                          const cdef_class& context)
+cdef_object_scalar::subsref (const std::string& type,
+                             const std::list<octave_value_list>& idx,
+                             int nargout, size_t& skip,
+                             const cdef_class& context)
 {
   skip = 0;
 
   cdef_class cls = (context.ok () ? context : get_class ());
 
   octave_value_list retval;
 
   if (! cls.ok ())
@@ -1079,19 +1098,19 @@ cdef_object_rep::subsref (const std::str
       error ("object cannot be indexed with `%c'", type[0]);
       break;
     }
 
   return retval;
 }
 
 octave_value
-cdef_object_rep::subsasgn (const std::string& type,
-                           const std::list<octave_value_list>& idx,
-                           const octave_value& rhs)
+cdef_object_scalar::subsasgn (const std::string& type,
+                              const std::list<octave_value_list>& idx,
+                              const octave_value& rhs)
 {
   octave_value retval;
 
   cdef_class cls = get_class ();
 
   switch (type[0])
     {
     case '.':
@@ -1138,53 +1157,72 @@ cdef_object_rep::subsasgn (const std::st
       panic_impossible ();
       break;
     }
 
   return retval;
 }
 
 void
-cdef_object_rep::mark_for_construction (const cdef_class& cls)
+cdef_object_scalar::mark_for_construction (const cdef_class& cls)
 {
   std::string cls_name = cls.get_name ();
 
   Cell supcls = cls.get ("SuperClasses").cell_value ();
 
   if (! error_state)
     {
-      std::list<std::string> supcls_names;
-
-      for (int i = 0; ! error_state && i < supcls.numel (); i++)
-        supcls_names.push_back (supcls(i).string_value ());
+      std::list<cdef_class> supcls_list = lookup_classes (supcls);
 
       if (! error_state)
-        ctor_list[cls_name] = supcls_names;
+        ctor_list[cls] = supcls_list;
     }
 }
+  
+bool cdef_object_scalar::is_constructed_for (const cdef_class& cls) const
+{
+  return (is_constructed ()
+          || ctor_list.find (cls) == ctor_list.end ());
+}
+
+bool cdef_object_scalar::is_partially_constructed_for (const cdef_class& cls) const
+{
+  std::map< cdef_class, std::list<cdef_class> >::const_iterator it;
+
+  if (is_constructed ())
+    return true;
+  else if ((it = ctor_list.find (cls)) == ctor_list.end ()
+           || it->second.empty ())
+    return true;
+
+  for (std::list<cdef_class>::const_iterator lit = it->second.begin ();
+       lit != it->second.end (); ++lit)
+    if (! is_constructed_for (*lit))
+      return false;
+
+  return true;
+}
 
 handle_cdef_object::~handle_cdef_object (void)
 {
-  gnulib::printf ("deleting %s object (handle)\n", cname.c_str ());
+  gnulib::printf ("deleting %s object (handle)\n",
+                  get_class ().get_name ().c_str ());
 }
 
 value_cdef_object::~value_cdef_object (void)
 {
-  gnulib::printf ("deleting %s object (value)\n", cname.c_str ());
+  gnulib::printf ("deleting %s object (value)\n",
+                  get_class ().get_name ().c_str ());
 }
 
-cdef_class::cdef_class_rep::cdef_class_rep (const std::string& nm,
-                                            const std::list<cdef_class>& superclasses)
-     : handle_cdef_object (nm), handle_class (false)
+cdef_class::cdef_class_rep::cdef_class_rep (const std::list<cdef_class>& superclasses)
+     : handle_cdef_object (), handle_class (false)
 {
-  for (std::list<cdef_class>::const_iterator it = superclasses.begin ();
-       it != superclasses.end (); ++it)
-    implicit_ctor_list.push_back (it->get_name ());
-
-  put ("SuperClasses", Cell (implicit_ctor_list));
+  put ("SuperClasses", to_ov (superclasses));
+  implicit_ctor_list = superclasses;
 }
 
 cdef_method
 cdef_class::cdef_class_rep::find_method (const std::string& nm, bool local)
 {
   method_iterator it = method_map.find (nm);
 
   if (it == method_map.end ())
@@ -1204,17 +1242,17 @@ cdef_class::cdef_class_rep::find_method 
   if (! local)
     {
       // Look into superclasses
 
       Cell super_classes = get ("SuperClasses").cell_value ();
 
       for (int i = 0; i < super_classes.numel (); i++)
         {
-          cdef_class cls = lookup_class (super_classes(i).string_value ());
+          cdef_class cls = lookup_class (super_classes(i));
 
           if (! error_state)
             {
               cdef_method meth = cls.find_method (nm);
 
               if (meth.ok ())
                 return meth;
             }
@@ -1222,19 +1260,18 @@ cdef_class::cdef_class_rep::find_method 
     }
 
   return cdef_method ();
 }
 
 class ctor_analyzer : public tree_walker
 {
 public:
-  ctor_analyzer (const std::string& ctor, const std::string& obj,
-                 const std::list<std::string>& l)
-    : tree_walker (), who (ctor), obj_name (obj), available_ctor_list (l) { }
+  ctor_analyzer (const std::string& ctor, const std::string& obj)
+    : tree_walker (), who (ctor), obj_name (obj) { }
 
   void visit_statement_list (tree_statement_list& t)
     {
       for (tree_statement_list::const_iterator it = t.begin ();
            ! error_state && it != t.end (); ++it)
         (*it)->accept (*this);
     }
 
@@ -1277,34 +1314,27 @@ public:
                     {
                       std::string package_name = args(1).string_value ();
                       std::string class_name = args(2).string_value ();
 
                       std::string ctor_name = (package_name.empty ()
                                                ? class_name
                                                : package_name + "." + class_name);
 
-                      if (std::find (available_ctor_list.begin (),
-                                     available_ctor_list.end (), ctor_name)
-                          == available_ctor_list.end ())
-                        ::error ("`%s' is not a direct superclass of `%s'",
-                                 ctor_name.c_str (), who.c_str ());
-                      else if (std::find (ctor_list.begin (), ctor_list.end (),
-                                          ctor_name) != ctor_list.end ())
-                        ::error ("calling constructor `%s' more than once",
-                                 ctor_name.c_str ());
-
-                      ctor_list.push_back (ctor_name);
+                      cdef_class cls = lookup_class (ctor_name, false);
+
+                      if (cls.ok ())
+                        ctor_list.push_back (cls);
                     }
                 }
             }
         }
     }
 
-  std::list<std::string> get_constructor_list (void) const
+  std::list<cdef_class> get_constructor_list (void) const
     { return ctor_list; }
 
   // NO-OP
   void visit_anon_fcn_handle (tree_anon_fcn_handle&) { }
   void visit_argument_list (tree_argument_list&) { }
   void visit_binary_expression (tree_binary_expression&) { }
   void visit_break_command (tree_break_command&) { }
   void visit_colon_expression (tree_colon_expression&) { }
@@ -1343,20 +1373,17 @@ public:
 private:
   /* The name of the constructor being analyzed */
   std::string who;
 
   /* The name of the first output argument of the constructor */
   std::string obj_name;
 
   /* The list of superclass constructors that are explicitly called */
-  std::list<std::string> ctor_list;
-
-  /* The list of possible superclass constructors */
-  std::list<std::string> available_ctor_list;
+  std::list<cdef_class> ctor_list;
 };
 
 void
 cdef_class::cdef_class_rep::install_method (const cdef_method& meth)
 {
   method_map[meth.get_name ()] = meth;
 
   if (meth.is_constructor ())
@@ -1373,30 +1400,29 @@ cdef_class::cdef_class_rep::install_meth
           if (uf)
             {
               tree_parameter_list *ret_list = uf->return_list ();
               tree_statement_list *body = uf->body ();
 
               if (ret_list && ret_list->size () == 1)
                 {
                   std::string obj_name = ret_list->front ()->name ();
-                  ctor_analyzer a (meth.get_name (), obj_name,
-                                   implicit_ctor_list);
+                  ctor_analyzer a (meth.get_name (), obj_name);
 
                   body->accept (a);
                   if (! error_state)
                     {
-                      std::list<std::string> explicit_ctor_list
+                      std::list<cdef_class> explicit_ctor_list
                         = a.get_constructor_list ();
 
-                      for (std::list<std::string>::const_iterator it = explicit_ctor_list.begin ();
+                      for (std::list<cdef_class>::const_iterator it = explicit_ctor_list.begin ();
                            ! error_state && it != explicit_ctor_list.end (); ++it)
                         {
                           gnulib::printf ("explicit superclass constructor: %s\n",
-                                  it->c_str ());
+                                          it->get_name ().c_str ());
                           implicit_ctor_list.remove (*it);
                         }
                     }
                 }
               else
                 ::error ("%s: invalid constructor output arguments",
                          meth.get_name ().c_str ());
             }
@@ -1466,17 +1492,17 @@ cdef_class::cdef_class_rep::find_methods
     }
 
   // Look into superclasses
 
   Cell super_classes = get ("SuperClasses").cell_value ();
 
   for (int i = 0; i < super_classes.numel (); i++)
     {
-      cdef_class cls = lookup_class (super_classes(i).string_value ());
+      cdef_class cls = lookup_class (super_classes(i));
 
       if (! error_state)
 	cls.get_rep ()->find_methods (meths, true);
       else
 	break;
     }
 }
 
@@ -1494,17 +1520,17 @@ cdef_class::cdef_class_rep::find_propert
     }
 
   // Look into superclasses
 
   Cell super_classes = get ("SuperClasses").cell_value ();
 
   for (int i = 0; i < super_classes.numel (); i++)
     {
-      cdef_class cls = lookup_class (super_classes(i).string_value ());
+      cdef_class cls = lookup_class (super_classes(i));
 
       if (! error_state)
 	{
 	  cdef_property prop = cls.find_property (nm);
 
 	  if (prop.ok ())
 	    return prop;
 	}
@@ -1569,17 +1595,17 @@ cdef_class::cdef_class_rep::find_propert
     }
 
   // Look into superclasses
 
   Cell super_classes = get ("SuperClasses").cell_value ();
 
   for (int i = 0; ! error_state && i < super_classes.numel (); i++)
     {
-      cdef_class cls = lookup_class (super_classes(i).string_value ());
+      cdef_class cls = lookup_class (super_classes(i));
 
       if (! error_state)
 	cls.get_rep ()->find_properties (props, true);
       else
 	break;
     }
 }
 
@@ -1629,17 +1655,17 @@ cdef_class::cdef_class_rep::find_names (
     }
 
   // Look into superclasses
 
   Cell super_classes = get ("SuperClasses").cell_value ();
 
   for (int i = 0; ! error_state && i < super_classes.numel (); i++)
     {
-      cdef_class cls = lookup_class (super_classes(i).string_value ());
+      cdef_class cls = lookup_class (super_classes(i));
 
       if (! error_state)
 	cls.get_rep ()->find_names (names, all);
       else
 	break;
     }
 }
 
@@ -1667,34 +1693,34 @@ cdef_class::cdef_class_rep::get_names (v
 
 void
 cdef_class::cdef_class_rep::delete_object (cdef_object obj)
 {
   method_iterator it = method_map.find ("delete");
 
   if (it != method_map.end ())
     {
-      std::string cls_name = obj.class_name ();
-
-      obj.set_class_name (get ("Name").string_value ());
+      cdef_class cls = obj.get_class ();
+
+      obj.set_class (wrap ());
 
       it->second.execute (obj, octave_value_list (), 0);
 
-      obj.set_class_name (cls_name);
+      obj.set_class (cls);
     }
 
   // FIXME: should we destroy corresponding properties here?
 
   // Call "delete" in super classes
 
   Cell super_classes = get ("SuperClasses").cell_value ();
 
   for (int i = 0; i < super_classes.numel (); i++)
     {
-      cdef_class cls = lookup_class (super_classes(i).string_value ());
+      cdef_class cls = lookup_class (super_classes(i));
 
       if (!error_state)
 	cls.delete_object (obj);
     }
 }
 
 octave_value_list
 cdef_class::cdef_class_rep::subsref_meta (const std::string& type,
@@ -1764,17 +1790,17 @@ cdef_class::cdef_class_rep::initialize_o
 }
 
 void
 cdef_class::cdef_class_rep::run_constructor (cdef_object& obj,
                                              const octave_value_list& args)
 {
   octave_value_list empty_args;
 
-  for (std::list<std::string>::const_iterator it = implicit_ctor_list.begin ();
+  for (std::list<cdef_class>::const_iterator it = implicit_ctor_list.begin ();
        ! error_state && it != implicit_ctor_list.end (); ++it)
     {
       cdef_class supcls = lookup_class (*it);
 
       if (! error_state)
         supcls.run_constructor (obj, empty_args);
     }
 
@@ -1802,28 +1828,29 @@ cdef_class::cdef_class_rep::run_construc
             {
               ::error ("%s: invalid number of output arguments for classdef constructor",
                        ctor_name.c_str ());
               return;
             }
         }
     }
 
-  obj.mark_as_constructed (cls_name);
+  obj.mark_as_constructed (wrap ());
 }
 
 octave_value
 cdef_class::cdef_class_rep::construct (const octave_value_list& args)
 {
   cdef_object_rep *r;
 
   if (is_handle_class ())
-    r = new handle_cdef_object (get_name ());
+    r = new handle_cdef_object ();
   else
-    r = new value_cdef_object (get_name ());
+    r = new value_cdef_object ();
+  r->set_class (wrap ());
 
   cdef_object obj (r);
 
   initialize_object (obj);
 
   if (! error_state)
     {
       run_constructor (obj, args);
@@ -2066,17 +2093,17 @@ octave_value
 cdef_property::cdef_property_rep::get_value (const cdef_object& obj)
 {
   octave_value retval;
 
   if (! obj.is_constructed ())
     {
       cdef_class cls (to_cdef (get ("DefiningClass")));
 
-      if (! obj.is_partially_constructed_for (cls.get_name ()))
+      if (! obj.is_partially_constructed_for (cls))
         {
           ::error ("cannot reference properties of class `%s' for non-constructed object",
                    cls.get_name ().c_str ());
           return retval;
         }
     }
  
   octave_value get_fcn = get ("GetMethod");
@@ -2110,17 +2137,17 @@ cdef_property::cdef_property_rep::is_rec
 void
 cdef_property::cdef_property_rep::set_value (cdef_object& obj,
                                              const octave_value& val)
 {
   if (! obj.is_constructed ())
     {
       cdef_class cls (to_cdef (get ("DefiningClass")));
 
-      if (! obj.is_partially_constructed_for (cls.get_name ()))
+      if (! obj.is_partially_constructed_for (cls))
         {
           ::error ("cannot reference properties of class `%s' for non-constructed object",
                    cls.get_name ().c_str ());
           return;
         }
     }
  
   octave_value set_fcn = get ("SetMethod");
@@ -2384,36 +2411,48 @@ cdef_package::cdef_package_rep::get_clas
 Cell
 cdef_package::cdef_package_rep::get_functions (void) const
 { return map2Cell (function_map); }
 
 Cell
 cdef_package::cdef_package_rep::get_packages (void) const
 { return map2Cell (package_map); }
 
+cdef_class cdef_class::_meta_class = cdef_class ();
+cdef_class cdef_class::_meta_property = cdef_class ();
+cdef_class cdef_class::_meta_method = cdef_class ();
+cdef_class cdef_class::_meta_package = cdef_class ();
+
+cdef_package cdef_package::_meta = cdef_package ();
+
 void
 install_classdef (void)
 {
   octave_classdef::register_type ();
 
-  /* meta classes */
+  /* bootstrap */
   cdef_class handle = make_class ("handle");
-  cdef_class meta_class = make_class ("meta.class", handle);
-  cdef_class meta_property = make_class ("meta.property", handle);
-  cdef_class meta_method = make_class ("meta.method", handle);
+  cdef_class meta_class = cdef_class::_meta_class = make_class ("meta.class", handle);
+  handle.set_class (meta_class);
+  meta_class.set_class (meta_class);
+
+  /* meta classes */
+  cdef_class meta_property = cdef_class::_meta_property = make_class ("meta.property", handle);
+  cdef_class meta_method = cdef_class::_meta_method = make_class ("meta.method", handle);
+  cdef_class meta_package = cdef_class::_meta_package = make_class ("meta.package", handle);
+
   cdef_class meta_event = make_class ("meta.event", handle);
-  cdef_class meta_package = make_class ("meta.package", handle);
   cdef_class meta_dynproperty = make_class ("meta.dynamicproperty", handle);
 
   /* meta classes are all sealed */
   meta_class.put ("Sealed", true);
   meta_property.put ("Sealed", true);
   meta_method.put ("Sealed", true);
+  meta_package.put ("Sealed", true);
   meta_event.put ("Sealed", true);
-  meta_package.put ("Sealed", true);
   meta_dynproperty.put ("Sealed", true);
 
   /* meta.class properties */
   meta_class.install_property (make_attribute (meta_class, "ConstructOnLoad"));
   meta_class.install_property (make_property  (meta_class, "ContainingPackage"));
   meta_class.install_property (make_property  (meta_class, "Description"));
   meta_class.install_property (make_property  (meta_class, "DetailedDescription"));
   meta_class.install_property (make_property  (meta_class, "Events"));
@@ -2527,17 +2566,17 @@ install_classdef (void)
   meta_package.install_property
       (make_property (meta_package, "Packages",
 		      make_fcn_handle (package_get_packages, "meta.package>get.Packages"),
 		      "public", Matrix (), "private"));
   meta_package.install_method (make_method (meta_package, "fromName", package_fromName,
                                             "public", true));
 
   /* create "meta" package */
-  cdef_package package_meta = make_package ("meta");
+  cdef_package package_meta = cdef_package::_meta = make_package ("meta");
   package_meta.install_class (meta_class,       "class");
   package_meta.install_class (meta_property,    "property");
   package_meta.install_class (meta_method,      "method");
   package_meta.install_class (meta_package,     "package");
   package_meta.install_class (meta_event,       "event");
   package_meta.install_class (meta_dynproperty, "dynproperty");
 }
 
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -33,127 +33,122 @@ along with Octave; see the file COPYING.
 class cdef_object;
 class cdef_class;
 class cdef_property;
 class cdef_method;
 class cdef_package;
 
 class tree_classdef;
 
+// This is mainly a boostrap class to declare the expected interface.
+// The actual base class is cdef_class_base, which is declared after
+// cdef_object, such that it can contain cdef_object objects.
 class
 cdef_object_rep
 {
 public:
   friend class cdef_object;
 
 public:
-  cdef_object_rep (void)
-      : refcount (1), cname () { }
-
-  cdef_object_rep (const std::string& nm)
-      : refcount (1), cname (nm) { }
+  cdef_object_rep (void) : refcount (1) { }
 
   virtual ~cdef_object_rep (void) { }
 
   virtual cdef_class get_class (void) const;
 
+  virtual void set_class (const cdef_class&)
+    { gripe_invalid_object ("set_class"); }
+
   virtual cdef_object_rep* clone (void) const
     {
-      error ("clone: invalid object");
+      gripe_invalid_object ("clone");
       return new cdef_object_rep ();
     }
 
-  virtual void put (const std::string& pname, const octave_value& val)
-    { map.assign (pname, val); }
+  virtual bool is_class (void) const { return false; }
+
+  virtual bool is_property (void) const { return false; }
 
-  virtual octave_value get (const std::string& pname) const
-    {
-      Cell val = map.contents (pname);
+  virtual bool is_method (void) const { return false; }
+
+  virtual bool is_package (void) const { return false; }
 
-      if (val.numel () > 0)
-	return val(0, 0);
-      else
-	{
-	  error ("get: unknown slot: %s", pname.c_str ());
-	  return octave_value ();
-	}
+  virtual void put (const std::string&, const octave_value&)
+    { gripe_invalid_object ("put"); }
+
+  virtual octave_value get (const std::string&) const
+    {
+      gripe_invalid_object ("get");
+      return octave_value ();
     }
 
   virtual octave_value_list
-  subsref (const std::string& type, const std::list<octave_value_list>& idx,
-           int nargout, size_t& skip, const cdef_class& context);
+  subsref (const std::string&, const std::list<octave_value_list>&,
+           int, size_t&, const cdef_class&)
+    {
+      gripe_invalid_object ("subsref");
+      return octave_value_list ();
+    }
 
   virtual octave_value
-  subsasgn (const std::string& type, const std::list<octave_value_list>& idx,
-            const octave_value& rhs);
+  subsasgn (const std::string&, const std::list<octave_value_list>&,
+            const octave_value&)
+    {
+      gripe_invalid_object ("subsasgn");
+      return octave_value ();
+    }
 
   virtual string_vector map_keys(void) const;
 
   virtual bool is_valid (void) const { return false; }
 
-  std::string class_name (void) const { return cname; }
+  std::string class_name (void) const;
 
-  void set_class_name (const std::string& nm) { cname = nm; }
-
-  void mark_for_construction (const cdef_class&);
+  virtual void mark_for_construction (const cdef_class&)
+    { gripe_invalid_object ("mark_for_construction"); }
 
-  //bool is_constructed_for (const cdef_class&) const;
-
-  bool is_constructed_for (const std::string& nm) const
+  virtual bool is_constructed_for (const cdef_class&) const
     {
-      return (is_constructed ()
-              || ctor_list.find (nm) == ctor_list.end ());
+      gripe_invalid_object ("is_constructed_for");
+      return false;
     }
 
-  bool is_partially_constructed_for (const std::string& nm) const
+  virtual bool is_partially_constructed_for (const cdef_class&) const
     {
-      std::map< std::string, std::list<std::string> >::const_iterator it;
-
-      if (is_constructed ())
-        return true;
-      else if ((it = ctor_list.find (nm)) == ctor_list.end ()
-               || it->second.empty ())
-        return true;
-
-      for (std::list<std::string>::const_iterator lit = it->second.begin ();
-           lit != it->second.end (); ++lit)
-        if (! is_constructed_for (*lit))
-          return false;
-
-      return true;
+      gripe_invalid_object ("is_partially_constructed_for");
+      return false;
     }
 
-  void mark_as_constructed (void) { ctor_list.clear (); }
+  virtual void mark_as_constructed (void)
+    { gripe_invalid_object ("mark_as_constructed"); }
+
+  virtual void mark_as_constructed (const cdef_class&)
+    { gripe_invalid_object ("mark_as_constructed"); }
 
-  void mark_as_constructed (const std::string& nm) { ctor_list.erase (nm); }
-
-  bool is_constructed (void) const { return ctor_list.empty (); }
+  virtual bool is_constructed (void) const
+    {
+      gripe_invalid_object ("is_constructed");
+      return false;
+    }
 
 protected:
   /* reference count */
   octave_refcount<int> refcount;
 
-  /* class name */
-  std::string cname;
-
-  /* object property values */
-  Octave_map map;
-
-  /* Internal/temporary structure used during object construction */
-  std::map< std::string, std::list<std::string> > ctor_list;
-
 protected:
   /* Restricted copying */
-  cdef_object_rep (const cdef_object_rep& r)
-    : refcount (1), cname (r.cname), map (r.map),
-      ctor_list (r.ctor_list) { }
+  cdef_object_rep (const cdef_object_rep&)
+    : refcount (1) { }
 
 private:
   /* No assignment */
   cdef_object_rep& operator = (const cdef_object_rep& );
+
+  void gripe_invalid_object (const char *who) const
+    { error ("%s: invalid object", who); }
 };
 
 class
 cdef_object
 {
 public:
   /* FIXME: use a null object */
   cdef_object (void)
@@ -185,25 +180,32 @@ public:
 	  rep->refcount++;
 	}
 
       return *this;
     }
 
   cdef_class get_class (void) const;
 
-  void set_class_name (const std::string& nm)
-    { rep->set_class_name (nm); }
+  void set_class (const cdef_class& cls) { rep->set_class (cls); }
 
   std::string class_name (void) const
     { return rep->class_name (); }
 
   cdef_object clone (void) const
     { return cdef_object (rep->clone ()); }
 
+  bool is_class (void) const { return rep->is_class (); }
+
+  bool is_property (void) const { return rep->is_property (); }
+
+  bool is_method (void) const { return rep->is_method (); }
+
+  bool is_package (void) const { return rep->is_package (); }
+
   void put (const std::string& pname, const octave_value& val)
     { rep->put (pname, val); }
 
   octave_value get (const std::string& pname) const
     { return rep->get (pname); }
 
   octave_value_list
   subsref (const std::string& type, const std::list<octave_value_list>& idx,
@@ -221,43 +223,139 @@ public:
 
   bool ok (void) const { return rep->is_valid (); }
 
   void mark_for_construction (const cdef_class& cls)
     { rep->mark_for_construction (cls); }
 
   bool is_constructed (void) const { return rep->is_constructed (); }
 
-  bool is_constructed_for (const std::string& nm) const
-    { return rep->is_constructed_for (nm); }
+  bool is_constructed_for (const cdef_class& cls) const
+    { return rep->is_constructed_for (cls); }
 
-  bool is_partially_constructed_for (const std::string& nm) const
-    { return rep->is_partially_constructed_for (nm); }
+  bool is_partially_constructed_for (const cdef_class& cls) const
+    { return rep->is_partially_constructed_for (cls); }
 
   void mark_as_constructed (void) { rep->mark_as_constructed (); }
 
-  void mark_as_constructed (const std::string& nm)
-    { rep->mark_as_constructed (nm); }
+  void mark_as_constructed (const cdef_class& cls)
+    { rep->mark_as_constructed (cls); }
 
 protected:
   cdef_object_rep* get_rep (void) { return rep; }
 
 private:
   cdef_object_rep *rep;
 };
 
 class
-handle_cdef_object : public cdef_object_rep
+cdef_object_base : public cdef_object_rep
+{
+public:
+  cdef_object_base (void)
+    : cdef_object_rep (), klass ()
+    {
+      register_object ();
+    }
+
+  ~cdef_object_base (void) { unregister_object (); }
+
+  cdef_class get_class (void) const;
+
+  void set_class (const cdef_class& cls);
+
+protected:
+  // Restricted copying!
+  cdef_object_base (const cdef_object_base& obj)
+    : cdef_object_rep (obj), klass (obj.klass)
+    {
+      register_object ();
+    }
+
+private:
+  void register_object (void);
+
+  void unregister_object (void);
+
+private:
+  // The class of the object
+  cdef_object klass;
+
+private:
+  // No assignment!
+  cdef_object_base& operator = (const cdef_object_base&);
+};
+
+class
+cdef_object_scalar : public cdef_object_base
+{
+public:
+  cdef_object_scalar (void) : cdef_object_base () { }
+
+  ~cdef_object_scalar (void) { }
+
+  void put (const std::string& pname, const octave_value& val)
+    { map.assign (pname, val); }
+
+  octave_value get (const std::string& pname) const
+    {
+      Cell val = map.contents (pname);
+
+      if (val.numel () > 0)
+	return val(0, 0);
+      else
+	{
+	  error ("get: unknown slot: %s", pname.c_str ());
+	  return octave_value ();
+	}
+    }
+
+  octave_value_list
+  subsref (const std::string& type, const std::list<octave_value_list>& idx,
+           int nargout, size_t& skip, const cdef_class& context);
+
+  octave_value
+  subsasgn (const std::string& type, const std::list<octave_value_list>& idx,
+            const octave_value& rhs);
+
+  void mark_for_construction (const cdef_class&);
+
+  bool is_constructed_for (const cdef_class& cls) const;
+
+  bool is_partially_constructed_for (const cdef_class& cls) const;
+
+  void mark_as_constructed (void) { ctor_list.clear (); }
+
+  void mark_as_constructed (const cdef_class& cls) { ctor_list.erase (cls); }
+
+  bool is_constructed (void) const { return ctor_list.empty (); }
+
+protected:
+  // Object property values
+  Octave_map map;
+
+  // Internal/temporary structure used during object construction
+  std::map< cdef_class, std::list<cdef_class> > ctor_list;
+
+protected:
+  // Restricted object copying!
+  cdef_object_scalar (const cdef_object_scalar& obj)
+    : cdef_object_base (obj), map (obj.map), ctor_list (obj.ctor_list) { }
+
+private:
+  // No assignment!
+  cdef_object_scalar& operator = (const cdef_object_scalar&);
+};
+
+class
+handle_cdef_object : public cdef_object_scalar
 {
 public:
   handle_cdef_object (void)
-      : cdef_object_rep () { }
-
-  handle_cdef_object (const std::string& nm)
-      : cdef_object_rep (nm) { }
+      : cdef_object_scalar () { }
 
   ~handle_cdef_object (void);
 
   cdef_object_rep* clone (void) const
     {
       handle_cdef_object *obj = const_cast<handle_cdef_object *> (this);
       obj->refcount++;
       return obj;
@@ -267,60 +365,62 @@ public:
 
 private:
   // No copying
   handle_cdef_object (const handle_cdef_object&);
   handle_cdef_object& operator = (const handle_cdef_object&);
 };
 
 class
-value_cdef_object : public cdef_object_rep
+value_cdef_object : public cdef_object_scalar
 {
 public:
   value_cdef_object (void)
-      : cdef_object_rep () { }
-
-  value_cdef_object (const std::string& nm)
-      : cdef_object_rep (nm) { }
+      : cdef_object_scalar () { }
 
   ~value_cdef_object (void);
 
   cdef_object_rep* clone (void) const
     {
-      value_cdef_object* obj = new value_cdef_object (cname);
-      obj->map = map;
+      value_cdef_object* obj = new value_cdef_object (*this);
       return obj;
     }
 
   bool is_valid (void) const { return true; }
 
 private:
-  // No copying
-  value_cdef_object (const value_cdef_object&);
+  // Private copying!
+  value_cdef_object (const value_cdef_object& obj)
+    : cdef_object_scalar (obj) { }
+
+  // No assignment!
   value_cdef_object& operator = (const value_cdef_object&);
 };
 
 class
 cdef_class : public cdef_object
 {
 private:
 
   class
   cdef_class_rep : public handle_cdef_object
   {
   public:
-    cdef_class_rep (const std::string& nm)
-	: handle_cdef_object (nm), handle_class (false) { }
+    cdef_class_rep (void)
+	: handle_cdef_object (), handle_class (false) { }
 
-    cdef_class_rep (const std::string& nm,
-                    const std::list<cdef_class>& superclasses);
+    cdef_class_rep (const std::list<cdef_class>& superclasses);
+
+    bool is_class (void) const { return true; }
 
     std::string get_name (void) const
       { return get ("Name").string_value (); }
 
+    void set_name (const std::string& nm) { put ("Name", nm); }
+
     cdef_method find_method (const std::string& nm, bool local = false);
 
     void install_method (const cdef_method& meth);
 
     Cell get_methods (void);
 
     cdef_property find_property (const std::string& nm);
 
@@ -356,16 +456,22 @@ private:
     void find_names (std::set<std::string>& names, bool all);
     
     void find_properties (std::map<std::string,cdef_property>& props,
                           bool only_inherited);
 
     void find_methods (std::map<std::string, cdef_method>& meths,
                        bool only_inherited);
 
+    cdef_class wrap (void)
+      {
+        refcount++;
+        return cdef_class (this);
+      }
+
   private:
     // The @-directory were this class is loaded from.
     // (not used yet)
     std::string directory;
 
     // The methods defined by this class.
     std::map<std::string,cdef_method> method_map;
 
@@ -374,59 +480,57 @@ private:
 
     // TRUE if this class is a handle class. A class is a handle
     // class when the abstract "handle" class is one of its superclasses.
     bool handle_class;
 
     // The list of super-class constructors that are called implicitly by the
     // the classdef engine when creating an object. These constructors are not
     // called explicitly by the class constructor.
-    std::list<std::string> implicit_ctor_list;
+    std::list<cdef_class> implicit_ctor_list;
 
     // Utility iterator typedef's.
     typedef std::map<std::string,cdef_method>::iterator method_iterator;
     typedef std::map<std::string,cdef_method>::const_iterator method_const_iterator;
     typedef std::map<std::string,cdef_property>::iterator property_iterator;
     typedef std::map<std::string,cdef_property>::const_iterator property_const_iterator;
   };
 
 public:
   // Create and invalid class object
   cdef_class (void)
       : cdef_object () { }
 
-  cdef_class (const std::string& nm)
-      : cdef_object (new cdef_class_rep (nm)) { }
-
   cdef_class (const std::string& nm,
               const std::list<cdef_class>& superclasses)
-      : cdef_object (new cdef_class_rep (nm, superclasses)) { }
+      : cdef_object (new cdef_class_rep (superclasses))
+    { get_rep ()->set_name (nm); }
 
   cdef_class (const cdef_class& cls)
       : cdef_object (cls) { }
 
   cdef_class (const cdef_object& obj)
       : cdef_object (obj)
     {
       // This should never happen...
-      if (class_name () != "meta.class")
+      if (! is_class ())
 	error ("internal error: invalid assignment from %s to meta.class object",
 	       class_name ().c_str ());
     }
 
   cdef_class& operator = (const cdef_class& cls)
     {
       cdef_object::operator= (cls);
 
       return *this;
     }
 
   cdef_class& operator = (const cdef_object& obj)
     {
-      if (obj.class_name () == "meta.class")
+      if (obj.is_class ())
 	cdef_object::operator= (obj);
       else
 	error ("internal error: invalid assignment from %s to meta.class object",
 	       class_name ().c_str ());
 
       return *this;
     }
 
@@ -483,47 +587,74 @@ public:
     { get_rep ()->run_constructor (obj, args); }
 
   void mark_as_handle_class (void)
     { get_rep ()->mark_as_handle_class (); }
 
   bool is_handle_class (void) const
     { return get_rep ()->is_handle_class (); }
 
+  static const cdef_class& meta_class (void) { return _meta_class; }
+  static const cdef_class& meta_property (void) { return _meta_property; }
+  static const cdef_class& meta_method (void) { return _meta_method; }
+  static const cdef_class& meta_package (void) { return _meta_package; }
+
 private:
   cdef_class_rep* get_rep (void)
     { return dynamic_cast<cdef_class_rep *> (cdef_object::get_rep ()); }
   
   const cdef_class_rep* get_rep (void) const
     { return dynamic_cast<const cdef_class_rep *> (cdef_object::get_rep ()); }
 
   friend bool operator == (const cdef_class&, const cdef_class&);
   friend bool operator != (const cdef_class&, const cdef_class&);
+  friend bool operator < (const cdef_class&, const cdef_class&);
+
+private:
+  static cdef_class _meta_class;
+  static cdef_class _meta_property;
+  static cdef_class _meta_method;
+  static cdef_class _meta_package;
+
+  friend void install_classdef (void);
 };
 
 inline bool
 operator == (const cdef_class& clsa, const cdef_class& clsb)
 // FIXME: is this really the right way to check class equality?
 { return (clsa.get_rep () == clsb.get_rep ()); }
 
 inline bool
 operator != (const cdef_class& clsa, const cdef_class& clsb)
 { return ! (clsa == clsb); }
 
+// This is only to be able to use cdef_class as map keys.
+inline bool
+operator < (const cdef_class& clsa, const cdef_class& clsb)
+{ return clsa.get_rep () < clsb.get_rep (); }
+
 class
 cdef_property : public cdef_object
 {
 private:
 
   class
   cdef_property_rep : public handle_cdef_object
   {
   public:
-    cdef_property_rep (const std::string& nm)
-	: handle_cdef_object (nm) { }
+    cdef_property_rep (void)
+	: handle_cdef_object () { }
+
+    bool is_property (void) const { return true; }
+
+    std::string get_name (void) const { return get("Name").string_value (); }
+
+    void set_name (const std::string& nm) { put ("Name", nm); }
+
+    bool is_constant (void) const { return get("Constant").bool_value (); }
 
     octave_value get_value (void) const { return default_value; }
 
     octave_value get_value (const cdef_object& obj);
 
     void set_value (const octave_value& val) { default_value = val; }
 
     void set_value (cdef_object& obj, const octave_value& val);
@@ -534,26 +665,27 @@ private:
   private:
     octave_value default_value;
   };
 
 public:
   cdef_property (void) : cdef_object () { }
 
   cdef_property (const std::string& nm)
-      : cdef_object (new cdef_property_rep (nm)) { }
+      : cdef_object (new cdef_property_rep ())
+    { get_rep ()->set_name (nm); }
 
   cdef_property (const cdef_property& prop)
       : cdef_object (prop) { }
 
   cdef_property (const cdef_object& obj)
       : cdef_object (obj)
     {
       // This should never happen...
-      if (class_name () != "meta.property")
+      if (! is_property ())
 	error ("internal error: invalid assignment from %s to meta.property object",
 	       class_name ().c_str ());
     }
 
   cdef_property& operator = (const cdef_property& prop)
     {
       cdef_object::operator= (prop);
 
@@ -569,21 +701,19 @@ public:
     { get_rep ()->set_value (obj, val); }
 
   void set_value (const octave_value& val) { get_rep ()->set_value (val); }
  
   bool check_get_access (void) const;
   
   bool check_set_access (void) const;
 
-  std::string get_name (void) const
-    { return get ("Name").string_value (); }
+  std::string get_name (void) const { return get_rep ()->get_name (); }
 
-  bool is_constant (void) const
-    { return get ("Constant").bool_value (); }
+  bool is_constant (void) const { return get_rep ()->is_constant (); }
 
 private:
   cdef_property_rep* get_rep (void)
     { return dynamic_cast<cdef_property_rep *> (cdef_object::get_rep ()); }
   
   const cdef_property_rep* get_rep (void) const
     { return dynamic_cast<const cdef_property_rep *> (cdef_object::get_rep ()); }
 };
@@ -592,18 +722,25 @@ class
 cdef_method : public cdef_object
 {
 private:
 
   class
   cdef_method_rep : public handle_cdef_object
   {
   public:
-    cdef_method_rep (const std::string& nm)
-	: handle_cdef_object (nm) { }
+    cdef_method_rep (void) : handle_cdef_object () { }
+
+    bool is_method (void) const { return true; }
+
+    std::string get_name (void) const { return get("Name").string_value (); }
+
+    void set_name (const std::string& nm) { put ("Name", nm); }
+
+    bool is_static (void) const { return get("Static").bool_value (); }
 
     octave_value get_function (void) const { return function; }
 
     void set_function (const octave_value& fcn) { function = fcn; }
 
     octave_value_list execute (const octave_value_list& args, int nargout);
 
     octave_value_list execute (const cdef_object& obj,
@@ -617,26 +754,27 @@ private:
   private:
     octave_value function;
   };
 
 public:
   cdef_method (void) : cdef_object () { }
 
   cdef_method (const std::string& nm)
-      : cdef_object (new cdef_method_rep (nm)) { }
+      : cdef_object (new cdef_method_rep ())
+    { get_rep ()->set_name (nm); }
 
   cdef_method (const cdef_property& prop)
       : cdef_object (prop) { }
 
   cdef_method (const cdef_object& obj)
       : cdef_object (obj)
     {
       // This should never happen...
-      if (class_name () != "meta.method")
+      if (! is_method ())
 	error ("internal error: invalid assignment from %s to meta.method object",
 	       class_name ().c_str ());
     }
 
   cdef_method& operator = (const cdef_method& meth)
     {
       cdef_object::operator= (meth);
 
@@ -649,21 +787,19 @@ public:
 
   /* dot-invokation: object is pushed as 1st argument */
   octave_value_list execute (const cdef_object& obj,
 			     const octave_value_list& args, int nargout)
     { return get_rep ()->execute (obj, args, nargout); }
 
   bool check_access (void) const;
   
-  std::string get_name (void) const
-    { return get ("Name").string_value (); }
+  std::string get_name (void) const { return get_rep ()->get_name (); }
 
-  bool is_static (void) const
-    { return get ("Static").bool_value (); }
+  bool is_static (void) const { return get_rep ()->is_static (); }
 
   void set_function (const octave_value& fcn)
     { get_rep ()->set_function (fcn); }
 
   octave_value get_function (void) const
     { return get_rep ()->get_function (); }
 
   bool is_constructor (void) const
@@ -673,19 +809,52 @@ private:
   cdef_method_rep* get_rep (void)
     { return dynamic_cast<cdef_method_rep *> (cdef_object::get_rep ()); }
   
   const cdef_method_rep* get_rep (void) const
     { return dynamic_cast<const cdef_method_rep *> (cdef_object::get_rep ()); }
 };
 
 inline cdef_class
+cdef_object_rep::get_class (void) const
+{
+  gripe_invalid_object ("get_class");
+  return cdef_class ();
+}
+
+inline std::string
+cdef_object_rep::class_name (void) const
+{ return get_class ().get_name (); }
+
+inline cdef_class
 cdef_object::get_class (void) const
 { return rep->get_class (); }
 
+inline cdef_class
+cdef_object_base::get_class (void) const
+{ return cdef_class (klass); }
+
+inline void
+cdef_object_base::set_class (const cdef_class& cls)
+{
+  klass = cls;
+}
+
+inline void
+cdef_object_base::register_object (void)
+{
+  // FIXME: implement this
+}
+
+inline void
+cdef_object_base::unregister_object (void)
+{
+  // FIXME: implement this
+}
+
 inline cdef_method
 cdef_class::find_method (const std::string& nm, bool local)
 { return get_rep ()->find_method (nm, local); }
 
 inline cdef_property
 cdef_class::find_property (const std::string& nm)
 { return get_rep ()->find_property (nm); }
 
@@ -693,18 +862,23 @@ class
 cdef_package : public cdef_object
 {
 private:
 
   class
   cdef_package_rep : public handle_cdef_object
   {
   public:
-    cdef_package_rep (const std::string& nm)
-      : handle_cdef_object (nm) { }
+    cdef_package_rep (void) : handle_cdef_object () { }
+
+    bool is_package (void) const { return true; }
+
+    std::string get_name (void) const { return get("Name").string_value (); }
+
+    void set_name (const std::string& nm) { put ("Name", nm); }
 
     void install_class (const cdef_class& cls, const std::string& nm);
 
     void install_function (const octave_value& fcn, const std::string& nm);
 
     void install_package (const cdef_package& pack, const std::string& nm);
 
     Cell get_classes (void) const;
@@ -725,23 +899,24 @@ private:
     typedef std::map<std::string, cdef_package>::iterator package_iterator;
     typedef std::map<std::string, cdef_package>::const_iterator package_const_iterator;
   };
 
 public:
   cdef_package (void) : cdef_object () { }
 
   cdef_package (const std::string& nm)
-      : cdef_object (new cdef_package_rep (nm)) { }
+      : cdef_object (new cdef_package_rep ())
+    { get_rep ()->set_name (nm); }
 
   cdef_package (const cdef_object& obj)
       : cdef_object (obj)
     {
       // This should never happen...
-      if (class_name () != "meta.package")
+      if (! is_package ())
 	error ("internal error: invalid assignment from %s to meta.package object",
 	       class_name ().c_str ());
     }
 
   cdef_package& operator = (const cdef_package& pack)
     {
       cdef_object::operator= (pack);
 
@@ -761,22 +936,31 @@ public:
     { return get_rep ()->get_classes (); }
 
   Cell get_functions (void) const
     { return get_rep ()->get_functions (); }
 
   Cell get_packages (void) const
     { return get_rep ()->get_packages (); }
 
+  std::string get_name (void) const { return get_rep ()->get_name (); }
+
+  static const cdef_package& meta (void) { return _meta; }
+
 private:
   cdef_package_rep* get_rep (void)
     { return dynamic_cast<cdef_package_rep *> (cdef_object::get_rep ()); }
   
   const cdef_package_rep* get_rep (void) const
     { return dynamic_cast<const cdef_package_rep *> (cdef_object::get_rep ()); }
+
+private:
+  static cdef_package _meta;
+
+  friend void install_classdef (void);
 };
 
 class
 octave_classdef : public octave_base_value
 {
 public:
   octave_classdef (void)
       : octave_base_value (), object () { }
