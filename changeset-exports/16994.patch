# HG changeset patch
# User Rik <rik@octave.org>
# Date 1374094952 25200
#      Wed Jul 17 14:02:32 2013 -0700
# Node ID 333243133364de71886f9bd81b3d38480dbeae26
# Parent  78f57b14535c12f9a4c528ffcc2cf6919543f4d8
Use matrix concatenation for strings, rather than cstrcat(), for clarity and performance.
matrix concatenation is ~80% faster than cstrcat().

* doc/interpreter/strings.txi: Document preference for matrix concatenation
as opposed to alternatives.

* doc/interpreter/geometryimages.m, doc/interpreter/interpimages.m,
doc/interpreter/plotimages.m, doc/interpreter/sparseimages.m,
doc/interpreter/splineimages.m, scripts/general/genvarname.m,
scripts/general/int2str.m, scripts/general/num2str.m,
scripts/help/__makeinfo__.m, scripts/help/help.m,
scripts/miscellaneous/copyfile.m, scripts/miscellaneous/dir.m,
scripts/miscellaneous/edit.m, scripts/miscellaneous/fact.m,
scripts/miscellaneous/fullfile.m, scripts/miscellaneous/mkoctfile.m,
scripts/miscellaneous/movefile.m, scripts/miscellaneous/perl.m,
scripts/miscellaneous/python.m, scripts/miscellaneous/run.m,
scripts/miscellaneous/tempdir.m, scripts/miscellaneous/unpack.m,
scripts/pkg/private/configure_make.m, scripts/pkg/private/create_pkgadddel.m,
scripts/pkg/private/extract_pkg.m, scripts/pkg/private/get_description.m,
scripts/pkg/private/get_forge_pkg.m, scripts/pkg/private/getarch.m,
scripts/pkg/private/getarchprefix.m, scripts/pkg/private/install.m,
scripts/pkg/private/installed_packages.m,
scripts/pkg/private/load_packages_and_dependencies.m,
scripts/pkg/private/rebuild.m, scripts/pkg/private/repackage.m,
scripts/pkg/private/shell.m, scripts/pkg/private/uninstall.m,
scripts/plot/private/__go_draw_axes__.m, scripts/signal/spectral_adf.m,
scripts/signal/spectral_xdf.m, scripts/statistics/tests/z_test.m,
scripts/statistics/tests/z_test_2.m, scripts/strings/mat2str.m,
scripts/strings/strtok.m, scripts/testfun/__run_test_suite__.m,
scripts/testfun/assert.m, scripts/testfun/demo.m, scripts/testfun/speed.m,
scripts/testfun/test.m, test/eval-catch.tst, test/io.tst, test/try.tst: Replace
cstrcat() with matrix concatenation where possible.

diff --git a/doc/interpreter/geometryimages.m b/doc/interpreter/geometryimages.m
--- a/doc/interpreter/geometryimages.m
+++ b/doc/interpreter/geometryimages.m
@@ -21,17 +21,17 @@ function geometryimages (nm, typ)
   set_print_size ();
   hide_output ();
   if (strcmp (typ, "png"))
     set (0, "defaulttextfontname", "*");
   endif
   if (strcmp (typ, "eps"))
     d_typ = "-depsc2";
   else
-    d_typ = cstrcat ("-d", typ);
+    d_typ = ["-d" typ];
   endif
 
   if (! __have_feature__ ("QHULL")
       && (strcmp (nm, "voronoi") || strcmp (nm, "griddata")
           || strcmp (nm, "convhull") || strcmp (nm, "delaunay")
           || strcmp (nm, "triplot")))
     sombreroimage (nm, typ);
   elseif (strcmp (typ, "txt"))
@@ -47,59 +47,59 @@ function geometryimages (nm, typ)
     plot (vx, vy, "r");
     [r, c] = tri2circ (tri(end,:), x, y);
     pc = [-1:0.01:1];
     xc = r * sin(pi*pc) + c(1);
     yc = r * cos(pi*pc) + c(2);
     plot (xc, yc, "g-", "LineWidth", 3);
     axis([0, 1, 0, 1]);
     legend ("Delaunay Triangulation", "Voronoi Diagram");
-    print (cstrcat (nm, ".", typ), d_typ)    
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "triplot"))
     rand ("state", 2)
     x = rand (20, 1);
     y = rand (20, 1);
     tri = delaunay (x, y);
     triplot (tri, x, y);
-    print (cstrcat (nm, ".", typ), d_typ)    
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "griddata"))
     rand("state",1);
     x=2*rand(1000,1)-1;
     y=2*rand(size(x))-1;
     z=sin(2*(x.^2+y.^2));
     [xx,yy]=meshgrid(linspace(-1,1,32));
     griddata(x,y,z,xx,yy);
-    print (cstrcat (nm, ".", typ), d_typ)    
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "convhull"))
     x = -3:0.05:3;
     y = abs (sin (x));
     k = convhull (x, y);
     plot (x(k),y(k),'r-',x,y,'b+');
     axis ([-3.05, 3.05, -0.05, 1.05]);
-    print (cstrcat (nm, ".", typ), d_typ) 
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "delaunay"))
     rand ("state", 1);
     x = rand (1, 10);
     y = rand (1, 10);
     T = delaunay (x, y);
     X = [ x(T(:,1)); x(T(:,2)); x(T(:,3)); x(T(:,1)) ];
     Y = [ y(T(:,1)); y(T(:,2)); y(T(:,3)); y(T(:,1)) ];
     axis ([0, 1, 0, 1]);
     plot(X, Y, "b", x, y, "r*");
-    print (cstrcat (nm, ".", typ), d_typ) 
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "inpolygon"))
     randn ("state", 2);
     x = randn (100, 1);
     y = randn (100, 1);
     vx = cos (pi * [-1 : 0.1: 1]);
     vy = sin (pi * [-1 : 0.1 : 1]);
     in = inpolygon (x, y, vx, vy);
     plot(vx, vy, x(in), y(in), "r+", x(!in), y(!in), "bo");
     axis ([-2, 2, -2, 2]);
-    print (cstrcat (nm, ".", typ), d_typ) 
+    print ([nm "." typ], d_typ);
   else
     error ("unrecognized plot requested");
   endif
   hide_output ();
 endfunction
 
 function [r, c] = tri2circ (tri, xx, yy)
   x = xx(tri);
@@ -139,28 +139,28 @@ function sombreroimage (nm, typ)
     fclose (fid);
     return;
   else ## if (!strcmp (typ, "txt"))
 
     hide_output ();
     if (strcmp (typ, "eps"))
       d_typ = "-depsc2";
     else
-      d_typ = cstrcat ("-d", typ);
+      d_typ = ["-d" typ];
     endif
 
     x = y = linspace (-8, 8, 41)';
     [xx, yy] = meshgrid (x, y);
     r = sqrt (xx .^ 2 + yy .^ 2) + eps;
     z = sin (r) ./ r;
     unwind_protect
       mesh (x, y, z);
       title ("Sorry, graphics not available because octave was\\ncompiled without the QHULL library.");
     unwind_protect_cleanup
-      print (cstrcat (nm, ".", typ), d_typ);
+      print ([nm "." typ], d_typ);
       hide_output ();
     end_unwind_protect
   endif
 endfunction
 
 ## generate something for the texinfo @image command to process
 function image_as_txt(nm)
   fid = fopen (sprintf ("%s.txt", nm), "wt");
diff --git a/doc/interpreter/interpimages.m b/doc/interpreter/interpimages.m
--- a/doc/interpreter/interpimages.m
+++ b/doc/interpreter/interpimages.m
@@ -21,63 +21,63 @@ function interpimages (nm, typ)
   set_print_size ();
   hide_output ();
   if (strcmp (typ, "png"))
     set (0, "defaulttextfontname", "*");
   endif
   if (strcmp (typ, "eps"))
     d_typ = "-depsc2";
   else
-    d_typ = cstrcat ("-d", typ);
+    d_typ = ["-d", typ];
   endif
 
   if (strcmp (typ, "txt"))
     image_as_txt (nm);
   elseif (strcmp (nm, "interpft"))
     t = 0 : 0.3 : pi; dt = t(2)-t(1);
     n = length (t); k = 100;
     ti = t(1) + [0 : k-1]*dt*n/k;
     y = sin (4*t + 0.3) .* cos (3*t - 0.1);
     yp = sin (4*ti + 0.3) .* cos (3*ti - 0.1);
     plot (ti, yp, 'g', ti, interp1(t, y, ti, 'spline'), 'b', ...
           ti, interpft (y, k), 'c', t, y, 'r+');
     legend ('sin(4t+0.3)cos(3t-0.1)','spline','interpft','data');
-    print (cstrcat (nm, ".", typ), d_typ)
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "interpn"))
     x = y = z = -1:1;
     f = @(x,y,z) x.^2 - y - z.^2;
     [xx, yy, zz] = meshgrid (x, y, z);
     v = f (xx,yy,zz);
     xi = yi = zi = -1:0.1:1;
     [xxi, yyi, zzi] = ndgrid (xi, yi, zi);
     vi = interpn(x, y, z, v, xxi, yyi, zzi, 'spline');
     mesh (zi, yi, squeeze (vi(1,:,:)));
-    print (cstrcat (nm, ".", typ), d_typ)
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "interpderiv1"))
     t = -2:2;
     dt = 1;
     ti =-2:0.025:2;
     dti = 0.025;
     y = sign(t);
     ys = interp1(t,y,ti,'spline');
     yp = interp1(t,y,ti,'pchip');
     plot (ti, ys,'r-', ti, yp,'g-');
     legend('spline','pchip', 4);
-    print (cstrcat (nm, ".", typ), d_typ)
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "interpderiv2"))
     t = -2:2;
     dt = 1;
     ti =-2:0.025:2;
     dti = 0.025;
     y = sign(t);
     ddys = diff(diff(interp1(t,y,ti,'spline'))./dti)./dti;
     ddyp = diff(diff(interp1(t,y,ti,'pchip'))./dti)./dti;
     plot (ti(2:end-1),ddys,'r*', ti(2:end-1),ddyp,'g+');
     legend('spline','pchip');
-    print (cstrcat (nm, ".", typ), d_typ)
+    print ([nm "." typ], d_typ);
   endif
   hide_output ();  
 endfunction
 
 function set_print_size ()
   image_size = [5.0, 3.5]; # in inches, 16:9 format
   border = 0;              # For postscript use 50/72
   set (0, "defaultfigurepapertype", "<custom>");
diff --git a/doc/interpreter/plotimages.m b/doc/interpreter/plotimages.m
--- a/doc/interpreter/plotimages.m
+++ b/doc/interpreter/plotimages.m
@@ -21,63 +21,63 @@ function plotimages (nm, typ)
   set_print_size ();
   hide_output ();
   if (strcmp (typ, "png"))
     set (0, "defaulttextfontname", "*");
   endif
   if (strcmp (typ, "eps"))
     d_typ = "-depsc2";
   else
-    d_typ = cstrcat ("-d", typ);
+    d_typ = ["-d", typ];
   endif
 
   if (strcmp(typ , "txt"))
     image_as_txt(nm);
   elseif (strcmp (nm, "plot"))
     x = -10:0.1:10;
     plot (x, sin (x));
-    print (cstrcat (nm, ".", typ), d_typ)    
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "hist"))
     rand ("state", 2);
     hist (randn (10000, 1), 30);
-    print (cstrcat (nm, ".", typ), d_typ)    
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "errorbar"))
     rand ("state", 2);
     x = 0:0.1:10;
     y = sin (x);
     yl = 0.1 .* rand (size (x));
     yu = 0.1 .* rand (size (x));
     errorbar (x, sin (x), yl, yu);
     axis ([0, 10, -1.1, 1.1]);
-    print (cstrcat (nm, ".", typ), d_typ)    
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "polar"))
     polar (0:0.1:10*pi, 0:0.1:10*pi);
-    print (cstrcat (nm, ".", typ), d_typ)    
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "mesh"))
     tx = ty = linspace (-8, 8, 41)';
     [xx, yy] = meshgrid (tx, ty);
     r = sqrt (xx .^ 2 + yy .^ 2) + eps;
     tz = sin (r) ./ r;
     mesh (tx, ty, tz);
-    print (cstrcat (nm, ".", typ), d_typ)    
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "plot3"))
     t = 0:0.1:10*pi;
     r = linspace (0, 1, numel (t));
     z = linspace (0, 1, numel (t));
     plot3 (r.*sin(t), r.*cos(t), z);
-    print (cstrcat (nm, ".", typ), d_typ)    
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "extended"))
     x = 0:0.01:3;
     plot(x,erf(x));
     hold on;
     plot(x,x,"r");
     axis([0, 3, 0, 1]);
-    text(0.65, 0.6175, cstrcat('\leftarrow x = {2/\surd\pi {\fontsize{16}',
-      '\int_{\fontsize{8}0}^{\fontsize{8}x}} e^{-t^2} dt} = 0.6175'))
-    print (cstrcat (nm, ".", typ), d_typ)
+    text(0.65, 0.6175, ['\leftarrow x = {2/\surd\pi {\fontsize{16}', ...
+      '\int_{\fontsize{8}0}^{\fontsize{8}x}} e^{-t^2} dt} = 0.6175']);
+    print ([nm "." typ], d_typ);
   else
     error ("unrecognized plot requested");
   endif
   hide_output ();
 endfunction
 
 function set_print_size ()
   image_size = [5.0, 3.5]; # in inches, 16:9 format
diff --git a/doc/interpreter/sparseimages.m b/doc/interpreter/sparseimages.m
--- a/doc/interpreter/sparseimages.m
+++ b/doc/interpreter/sparseimages.m
@@ -21,17 +21,17 @@ function sparseimages (nm, typ)
   set_print_size ();
   if (strcmp (typ, "png"))
     set (0, "defaulttextfontname", "*");
   endif
 
   if (__have_feature__ ("COLAMD")
       && __have_feature__ ("CHOLMOD")
       && __have_feature__ ("UMFPACK"))
-    if (strcmp(typ,"txt"))
+    if (strcmp (typ,"txt"))
       txtimages (nm, 15, typ);
     else
       if (strcmp (nm, "gplot"))
         gplotimages ("gplot", typ);
       elseif (strcmp (nm, "grid"))
         femimages ("grid", typ);
       else
         otherimages (nm, 200, typ);
@@ -57,212 +57,212 @@ function hide_output ()
   set (f, "visible", "off");
 endfunction
 
 function gplotimages (nm, typ)
   hide_output ();
   if (strcmp (typ, "eps"))
     d_typ = "-depsc2";
   else
-    d_typ = cstrcat ("-d", typ);
+    d_typ = ["-d" typ];
   endif
 
   A = sparse ([2,6,1,3,2,4,3,5,4,6,1,5],
               [1,1,2,2,3,3,4,4,5,5,6,6], 1, 6, 6);
   xy = [0,4,8,6,4,2;5,0,5,7,5,7]';
-  gplot (A, xy)
-  print (cstrcat (nm, ".", typ), d_typ)
+  gplot (A, xy);
+  print ([nm "." typ], d_typ);
   hide_output ();
 endfunction
 
 function txtimages(nm, n, typ)
   a = 10*speye(n) + sparse(1:n,ceil([1:n]/2),1,n,n) + ...
       sparse(ceil([1:n]/2),1:n,1,n,n);
   if (strcmp (nm, "gplot") || strcmp (nm, "grid"))
     fid = fopen (sprintf ("%s.txt", nm), "wt");
     fputs (fid, "\n");
     fputs (fid, "+---------------------------------+\n");
     fputs (fid, "| Image unavailable in text mode. |\n");
     fputs (fid, "+---------------------------------+\n");
     fclose (fid);
   elseif (strcmp (nm, "spmatrix"))
-    printsparse(a,cstrcat("spmatrix.",typ));
+    printsparse (a, ["spmatrix." typ]);
   else
     if (__have_feature__ ("COLAMD")
         && __have_feature__ ("CHOLMOD"))
       if (strcmp (nm, "spchol"))
-        r1 = chol(a);
-        printsparse(r1,cstrcat("spchol.",typ));
+        r1 = chol (a);
+        printsparse (r1, ["spchol." typ]);
       elseif (strcmp (nm, "spcholperm"))
-        [r2,p2,q2]=chol(a);
-        printsparse(r2,cstrcat("spcholperm.",typ));
+        [r2,p2,q2] = chol (a);
+        printsparse(r2, ["spcholperm." typ]);
       endif
       ## printf("Text NNZ: Matrix %d, Chol %d, PermChol %d\n",nnz(a),nnz(r1),nnz(r2));
     endif
   endif
 endfunction
 
 function otherimages(nm, n, typ)
   hide_output ();
   if (strcmp (typ, "eps"))
     d_typ = "-depsc2";
   else
-    d_typ = cstrcat ("-d", typ);
+    d_typ = ["-d" typ];
   endif
 
   a = 10*speye(n) + sparse(1:n,ceil([1:n]/2),1,n,n) + ...
       sparse(ceil([1:n]/2),1:n,1,n,n);
   if (strcmp (nm, "spmatrix"))
-    spy(a);
-    axis("ij")
-    print(cstrcat("spmatrix.",typ), d_typ)
+    spy (a);
+    axis ("ij");
+    print (["spmatrix." typ], d_typ);
     hide_output ();
   else
     if (__have_feature__ ("COLAMD")
         && __have_feature__ ("CHOLMOD"))
       if (strcmp (nm, "spchol"))
-        r1 = chol(a);
-        spy(r1);
-        axis("ij")
-        print(cstrcat("spchol.",typ), d_typ)
+        r1 = chol (a);
+        spy (r1);
+        axis ("ij");
+        print (["spchol." typ], d_typ);
         hide_output ();
       elseif (strcmp (nm, "spcholperm"))
-        [r2,p2,q2]=chol(a);
-        spy(r2);
-        axis("ij")
-        print(cstrcat("spcholperm.",typ), d_typ)
+        [r2,p2,q2] = chol (a);
+        spy (r2);
+        axis ("ij");
+        print (["spcholperm." typ], d_typ);
         hide_output ();
       endif
       ## printf("Image NNZ: Matrix %d, Chol %d, PermChol %d\n",nnz(a),nnz(r1),nnz(r2));
     endif
   endif
 endfunction
 
-function printsparse(a, nm)
+function printsparse (a, nm)
   fid = fopen (nm,"wt");
   fputs (fid, "\n");
-  for i = 1:size(a,1)
-    if (rem(i,5) == 0)
+  for i = 1:rows (a)
+    if (rem (i,5) == 0)
       fprintf (fid,"         %2d - ", i);
     else
       fprintf (fid,"            | ");
     endif
-    for j = 1:size(a,2)
+    for j = 1:columns (a)
       if (a(i,j) == 0)
-        fprintf(fid,"  ")
+        fprintf (fid,"  ");
       else
-        fprintf(fid," *")
+        fprintf (fid," *");
       endif
     endfor
-    fprintf(fid,"\n")
+    fprintf (fid,"\n");
   endfor
-  fprintf(fid,"            |-");
-  for j=1:size(a,2)
-    if (rem(j,5)==0)
-      fprintf(fid,"-|");
+  fprintf (fid,"            |-");
+  for j=1:columns (a)
+    if (rem (j,5) == 0)
+      fprintf (fid,"-|");
     else
-      fprintf(fid,"--");
+      fprintf (fid,"--");
     endif
   endfor
-  fprintf(fid,"\n")
-  fprintf(fid,"              ");
-  for j=1:size(a,2)
-    if (rem(j,5)==0)
-      fprintf(fid,"%2d",j);
+  fprintf (fid,"\n");
+  fprintf (fid,"              ");
+  for j=1:columns (a)
+    if (rem (j,5) == 0)
+      fprintf (fid,"%2d",j);
     else
-      fprintf(fid,"  ");
+      fprintf (fid,"  ");
     endif
   endfor
-  fclose(fid);
+  fclose (fid);
 endfunction
 
 function femimages (nm, typ)
   hide_output ();
   if (strcmp (typ, "eps"))
     d_typ = "-depsc2";
   else
-    d_typ = cstrcat ("-d", typ);
+    d_typ = ["-d" typ];
   endif
 
   if (__have_feature__ ("COLAMD")
       && __have_feature__ ("CHOLMOD")
       && __have_feature__ ("UMFPACK"))
     ## build a rectangle
     node_y = [1;1.2;1.5;1.8;2]*ones(1,11);
     node_x = ones(5,1)*[1,1.05,1.1,1.2,1.3,1.5,1.7,1.8,1.9,1.95,2];
     nodes = [node_x(:), node_y(:)];
 
-    [h,w] = size(node_x);
+    [h,w] = size (node_x);
     elems = [];
     for idx = 1:w-1
       widx = (idx-1)*h;
       elems = [elems; widx+[(1:h-1);(2:h);h+(1:h-1)]']; 
       elems = [elems; widx+[(2:h);h+(2:h);h+(1:h-1)]']; 
     endfor
 
-    E = size(elems,1);  #No. of elements
-    N = size(nodes,1);  #No. of elements
-    D = size(elems,2);  #dimensions+1
+    E = size (elems,1);  #No. of elements
+    N = size (nodes,1);  #No. of elements
+    D = size (elems,2);  #dimensions+1
 
     ## Plot FEM Geometry
     elemx = elems(:,[1,2,3,1])';
-    xelems = reshape( nodes(elemx, 1), 4, E);
-    yelems = reshape( nodes(elemx, 2), 4, E);
+    xelems = reshape (nodes(elemx, 1), 4, E);
+    yelems = reshape (nodes(elemx, 2), 4, E);
 
     ## Set element conductivity
     conductivity = [1*ones(1,16),2*ones(1,48),1*ones(1,16)];
 
     ## Dirichlet boundary conditions
     D_nodes = [1:5, 51:55]; 
     D_value = [10*ones(1,5), 20*ones(1,5)]; 
   
     ## Neumann boundary conditions
     ## Note that N_value must be normalized by the boundary
     ##   length and element conductivity
     N_nodes = [];
     N_value = [];
 
     ## Calculate connectivity matrix
-    C = sparse((1:D*E), reshape(elems',D*E,1),1, D*E, N);
+    C = sparse ((1:D*E), reshape (elems',D*E,1),1, D*E, N);
 
     ## Calculate stiffness matrix
-    Siidx = floor([0:D*E-1]'/D)*D*ones(1,D) + ones(D*E,1)*(1:D) ;
-    Sjidx = [1:D*E]'*ones(1,D);
-    Sdata = zeros(D*E,D);
-    dfact = prod(2:(D-1));
+    Siidx = floor ([0:D*E-1]'/D)*D*ones(1,D) + ones(D*E,1)*(1:D) ;
+    Sjidx = [1:D*E]'*ones (1,D);
+    Sdata = zeros (D*E,D);
+    dfact = prod (2:(D-1));
     for j = 1:E
-      a = inv([ ones(D,1), nodes( elems(j,:), : ) ]);
+      a = inv ([ ones(D,1), nodes( elems(j,:), : ) ]);
       const = conductivity(j)*2/dfact/abs(det(a));
       Sdata(D*(j-1)+(1:D),:)= const * a(2:D,:)'*a(2:D,:);
     endfor
 
     ## Element-wise system matrix
-    SE = sparse(Siidx,Sjidx,Sdata);
+    SE = sparse (Siidx,Sjidx,Sdata);
     ## Global system matrix
     S = C'* SE *C;
 
     ## Set Dirichlet boundary
-    V = zeros(N,1);
+    V = zeros (N,1);
     V(D_nodes) = D_value;
     idx = 1:N;
     idx(D_nodes) = [];
 
     ## Set Neumann boundary
-    Q = zeros(N,1);
+    Q = zeros (N,1);
     Q(N_nodes) = N_value; # FIXME
 
     V(idx) = S(idx,idx)\( Q(idx) - S(idx,D_nodes)*V(D_nodes) );
 
-    velems = reshape( V(elemx), 4, E);
+    velems = reshape ( V(elemx), 4, E);
 
-    sz = size(xelems,2);
+    sz = size (xelems,2);
 
     plot3 (xelems, yelems, velems);
     view (10, 10);
-    print(cstrcat(nm,".",typ), d_typ)
+    print ([nm "." typ], d_typ);
     hide_output ();
   endif
 endfunction
 
 ## There is no sparse matrix implementation available because of missing
 ## libraries, plot sombreros instead. Also plot a nice title that we are
 ## sorry about that.
 function sombreroimage (nm, typ)
@@ -276,28 +276,28 @@ function sombreroimage (nm, typ)
     fclose (fid);
     return;
   else ## if (!strcmp (typ, "txt"))
 
     hide_output ();
     if (strcmp (typ, "eps"))
       d_typ = "-depsc2";
     else
-      d_typ = cstrcat ("-d", typ);
+      d_typ = ["-d" typ];
     endif
 
     x = y = linspace (-8, 8, 41)';
     [xx, yy] = meshgrid (x, y);
     r = sqrt (xx .^ 2 + yy .^ 2) + eps;
     z = sin (r) ./ r;
     unwind_protect
       mesh (x, y, z);
       title ("Sorry, graphics are unavailable because Octave was\ncompiled without a sparse matrix implementation.");
     unwind_protect_cleanup
-      print (cstrcat (nm, ".", typ), d_typ);
+      print ([nm "." typ], d_typ);
       hide_output ();
     end_unwind_protect
   endif
 endfunction
 
 ## generate something for the texinfo @image command to process
 function image_as_txt(nm)
   fid = fopen (sprintf ("%s.txt", nm), "wt");
diff --git a/doc/interpreter/splineimages.m b/doc/interpreter/splineimages.m
--- a/doc/interpreter/splineimages.m
+++ b/doc/interpreter/splineimages.m
@@ -21,17 +21,17 @@ function splineimages (nm, typ)
   set_print_size ();
   hide_output ();
   if (strcmp (typ, "png"))
     set (0, "defaulttextfontname", "*");
   endif
   if (strcmp (typ, "eps"))
     d_typ = "-depsc2";
   else
-    d_typ = cstrcat ("-d", typ);
+    d_typ = ["-d" typ];
   endif
 
   if (strcmp (typ, "txt"))
     image_as_txt (nm);
   elseif (strcmp (nm, "splinefit1")) ## Breaks and Pieces
     x = 2 * pi * rand (1, 200);
     y = sin (x) + sin (2 * x) + 0.2 * randn (size (x));
     ## Uniform breaks
@@ -42,17 +42,17 @@ function splineimages (nm, typ)
     ## Plot
     xx = linspace (0, 2 * pi, 400);
     y1 = ppval (pp1, xx);
     y2 = ppval (pp2, xx);
     plot (x, y, ".", xx, [y1; y2])
     axis tight
     ylim ([-2.5 2.5])
     legend ("data", "41 breaks, 40 pieces", "11 breaks, 10 pieces")
-    print (cstrcat (nm, ".", typ), d_typ)
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "splinefit2")) ## Spline orders
     ## Data (200 points)
     x = 2 * pi * rand (1, 200);
     y = sin (x) + sin (2 * x) + 0.1 * randn (size (x));
     ## Splines
     pp1 = splinefit (x, y, 8, "order", 0);  ## Piecewise constant
     pp2 = splinefit (x, y, 8, "order", 1);  ## Piecewise linear
     pp3 = splinefit (x, y, 8, "order", 2);  ## Piecewise quadratic
@@ -64,34 +64,34 @@ function splineimages (nm, typ)
     y2 = ppval (pp2, xx);
     y3 = ppval (pp3, xx);
     y4 = ppval (pp4, xx);
     y5 = ppval (pp5, xx);
     plot (x, y, ".", xx, [y1; y2; y3; y4; y5])
     axis tight
     ylim ([-2.5 2.5])
     legend ({"data", "order 0", "order 1", "order 2", "order 3", "order 4"})
-    print (cstrcat (nm, ".", typ), d_typ)
+    print ([nm, "." typ], d_typ);
   elseif (strcmp (nm, "splinefit3"))
     ## Data (100 points)
     x = 2 * pi * [0, (rand (1, 98)), 1];
     y = sin (x) - cos (2 * x) + 0.2 * randn (size (x));
     ## No constraints
     pp1 = splinefit (x, y, 10, "order", 5);
     ## Periodic boundaries
     pp2 = splinefit (x, y, 10, "order", 5, "periodic", true);
     ## Plot
     xx = linspace (0, 2 * pi, 400);
     y1 = ppval (pp1, xx);
     y2 = ppval (pp2, xx);
     plot (x, y, ".", xx, [y1; y2])
     axis tight
     ylim ([-2 3])
     legend ({"data", "no constraints", "periodic"})
-    print (cstrcat (nm, ".", typ), d_typ)
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "splinefit4"))
     ## Data (200 points)
     x = 2 * pi * rand (1, 200);
     y = sin (2 * x) + 0.1 * randn (size (x));
     ## Breaks
     breaks = linspace (0, 2 * pi, 10);
     ## Clamped endpoints, y = y" = 0
     xc = [0, 0, 2*pi, 2*pi];
@@ -104,17 +104,17 @@ function splineimages (nm, typ)
     ## Plot
     xx = linspace (0, 2 * pi, 400);
     y1 = ppval (pp1, xx);
     y2 = ppval (pp2, xx);
     plot (x, y, ".", xx, [y1; y2])
     axis tight
     ylim ([-1.5 1.5])
     legend({"data", "clamped", "hinged periodic"})
-    print (cstrcat (nm, ".", typ), d_typ)
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "splinefit5"))
     ## Truncated data
     x = [0,  1,  2,  4,  8, 16, 24, 40, 56, 72, 80] / 80;
     y = [0, 28, 39, 53, 70, 86, 90, 79, 55, 22,  2] / 1000;
     xy = [x; y];
     ## Curve length parameter
     ds = sqrt (diff (x).^2 + diff (y).^2);
     s = [0, cumsum(ds)];
@@ -125,17 +125,17 @@ function splineimages (nm, typ)
     ## Plot
     ss = linspace (0, s(end), 400);
     xyfit = ppval (pp, ss);
     xyb = ppval(pp, pp.breaks);
     plot (x, y, ".", xyfit(1,:), xyfit(2,:), "r", xyb(1,:), xyb(2,:), "ro")
     legend ({"data", "spline", "breaks"})
     axis tight
     ylim ([0 0.1])
-    print (cstrcat (nm, ".", typ), d_typ)
+    print ([nm "." typ], d_typ);
   elseif (strcmp (nm, "splinefit6"))
     ## Data
     x = linspace (0, 2*pi, 200);
     y = sin (x) + sin (2 * x) + 0.05 * randn (size (x));
     ## Add outliers
     x = [x, linspace(0,2*pi,60)];
     y = [y, -ones(1,60)];
     ## Fit splines with hinged conditions
@@ -148,17 +148,17 @@ function splineimages (nm, typ)
     y1 = ppval (pp1, xx);
     y2 = ppval (pp2, xx);
     y3 = ppval (pp3, xx);
     plot (x, y, ".", xx, [y1; y2; y3])
     legend({"data with outliers","robust, beta = 0.25", ...
             "robust, beta = 0.75", "no robust fitting"})
     axis tight
     ylim ([-2 2])
-    print (cstrcat (nm, ".", typ), d_typ)
+    print ([nm "." typ], d_typ);
   endif
   hide_output ();  
 endfunction
 
 function set_print_size ()
   image_size = [5.0, 3.5]; # in inches, 16:9 format
   border = 0;              # For postscript use 50/72
   set (0, "defaultfigurepapertype", "<custom>");
diff --git a/doc/interpreter/strings.txi b/doc/interpreter/strings.txi
--- a/doc/interpreter/strings.txi
+++ b/doc/interpreter/strings.txi
@@ -224,20 +224,37 @@ only of blank characters (ASCII code 32)
 @menu
 * Concatenating Strings:: 
 * Conversion of Numerical Data to Strings::
 @end menu
 
 @node Concatenating Strings
 @subsection Concatenating Strings
 
-It has been shown above that strings can be concatenated using matrix notation
-(@pxref{Strings}, @ref{Character Arrays}).  Apart from that, there are several
-functions to concatenate string objects: @code{char},
-@code{strvcat}, @code{strcat} and @code{cstrcat}.  In addition, the general
+Strings can be concatenated using matrix notation
+(@pxref{Strings}, @ref{Character Arrays}) which is often the most natural
+method.  For example:
+
+@example
+@group
+fullname = [fname ".txt"];
+email = ["<" user "@" domain ">"];
+@end group
+@end example
+
+@noindent
+In each case it is easy to see what the final string will look like.  This
+method is also the most efficient.  When using matrix concatenation the parser
+immediately begins joining the strings without having to process
+the overhead of a function call and the input validation of the associated
+function.
+
+Nevertheless, there are several other functions for concatenating string
+objects which can be useful in specific circumstances: @code{char},
+@code{strvcat}, @code{strcat} and @code{cstrcat}.  Finally, the general
 purpose concatenation functions can be used: see @ref{docXcat,,cat},
 @ref{docXhorzcat,,horzcat} and @ref{docXvertcat,,vertcat}.
 
 @itemize @bullet
 @item All string concatenation functions except @code{cstrcat}
 convert numerical input into character data by taking the corresponding ASCII
 character for each element, as in the following example:
 
diff --git a/scripts/general/genvarname.m b/scripts/general/genvarname.m
--- a/scripts/general/genvarname.m
+++ b/scripts/general/genvarname.m
@@ -114,43 +114,43 @@ function varname = genvarname (str, excl
     if (rows (str) != 1)
       error ("genvarname: if more than one STR is given, it must be a cellstr");
     endif
     str = {str};
   elseif (! iscellstr (str))
     error ("genvarname: STR must be a string or a cellstr");
   endif
 
-  validchars = cstrcat ("A":"Z", "a":"z", "0":"9", "_");
+  validchars = ["A":"Z", "a":"z", "0":"9", "_"];
 
   varname = cell (size (str));
   for i = 1:numel (str)
     ## Perform any modifications to the varname to make sure that it is
     ## a valid variable name.
 
     ## remove invalid characters
     str{i}(! ismember (str{i}, validchars)) = "_";
     ## do not use keywords
     if (iskeyword (str{i}))
-      str{i} = cstrcat ("_", str{i});
+      str{i} = ["_" str{i}];
     endif
     ## double underscores at the beginning and end are reserved variables
     underscores = (str{i} == "_");
     if (any (underscores))
       firstnon = find (!underscores, 1);
       lastnon = find (!underscores, 1, "last");
       str{i}([1:firstnon-2, lastnon+2:end]) = [];
     endif
     ## The variable cannot be empty
     if (isempty (str{i}))
       str{i} = "x";
     endif
     ## it cannot start with a number
     if (ismember (str{i}(1), "0":"9"))
-      str{i} = cstrcat ("_", str{i});
+      str{i} = ["_" str{i}];
     endif
 
     ## make sure that the variable is unique relative to other variables
     ## and the exclusions list
     excluded = any (strcmp (str{i}, exclusions));
     if (excluded && ismember (str{i}(end), "0":"9"))
       ## if it is not unique and ends with a digit, add an underscore to
       ## make the variable name more readable ("x1_1" instead of "x11")
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -62,19 +62,19 @@ function retval = int2str (n)
   nd = ndims (n);
   nc = columns (n);
   if (nc > 1)
     idx = repmat ({':'}, nd, 1);
     idx(2) = 1;
     ifmt = get_fmt (n(idx{:}), 0);
     idx(2) = 2:sz(2);
     rfmt = get_fmt (n(idx{:}), 2);
-    fmt = cstrcat (ifmt, repmat (rfmt, 1, nc-1), "\n");
+    fmt = [ifmt repmat(rfmt,1,nc-1) "\n"];
   else
-    fmt = cstrcat (get_fmt (n, 0), "\n");
+    fmt = [get_fmt(n, 0) "\n"];
   endif
   tmp = sprintf (fmt, permute (n, [2, 1, 3 : nd]));
   tmp(end) = "";
   retval = char (ostrsplit (tmp, "\n"));
 
 endfunction
 
 function fmt = get_fmt (x, sep)
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -110,24 +110,24 @@ function retval = num2str (x, arg)
           ##        See %!xtest below
           fmt = sprintf ("%%%d.%dg", dgt+2+any (x(:) < 0), dgt);
         endif
       else
         ## Logical input
         fmt = "%3d";
       endif
     endif
-    fmt = cstrcat (deblank (repmat (fmt, 1, columns (x))), "\n");
+    fmt = [deblank(repmat(fmt, 1, columns(x))), "\n"];
     nd = ndims (x);
     tmp = sprintf (fmt, permute (x, [2, 1, 3:nd]));
     retval = strtrim (char (ostrsplit (tmp(1:end-1), "\n")));
   else   # Complex matrix input
     if (nargin == 2)
       if (ischar (arg))
-        fmt = cstrcat (arg, "%-+", arg(2:end), "i");
+        fmt = [arg "%-+" arg(2:end) "i"];
       elseif (isnumeric (arg) && isscalar (arg) && arg >= 0)
         fmt = sprintf ("%%%d.%dg%%-+%d.%dgi", arg+7, arg, arg+7, arg);
       else
         error ("num2str: PRECISION must be a scalar integer >= 0");
       endif
     else
       ## Setup a suitable format string
       dgt = floor (log10 (max (max (abs (real (x(:)))),
@@ -152,17 +152,17 @@ function retval = num2str (x, arg)
     nd = ndims (x);
     idx = repmat ({':'}, nd, 1);
     perm(1:2:2*nc) = 1:nc;
     perm(2:2:2*nc) = nc + (1:nc);
     idx{2} = perm;
     x = horzcat (real (x), imag (x));
     x = x(idx{:});
 
-    fmt = cstrcat (deblank (repmat (fmt, 1, nc)), "\n");
+    fmt = [deblank(repmat(fmt, 1, nc)), "\n"];
     tmp = sprintf (fmt, permute (x, [2, 1, 3:nd]));
 
     ## Put the "i"'s where they are supposed to be.
     tmp = regexprep (tmp, " +i\n", "i\n");
     tmp = regexprep (tmp, "( +)i", "i$1");
 
     retval = strtrim (char (ostrsplit (tmp(1:end-1), "\n")));
   endif
diff --git a/scripts/help/__makeinfo__.m b/scripts/help/__makeinfo__.m
--- a/scripts/help/__makeinfo__.m
+++ b/scripts/help/__makeinfo__.m
@@ -95,17 +95,17 @@ function [retval, status] = __makeinfo__
   text = regexprep (text, '^ +@end tex', '@end tex', 'lineanchors');
 
   file = texi_macros_file ();
   fid = fopen (file, "r");
   if (fid < 0)
     error ("unable to open %s for reading", file);
   else
     macros_text = fread (fid, Inf, "*char")';
-    text = cstrcat (macros_text, text);
+    text = [macros_text text];
   endif
   fclose (fid);
 
   if (strcmpi (output_type, "texinfo"))
     status = 0;
     retval = text;
     return;
   endif
diff --git a/scripts/help/help.m b/scripts/help/help.m
--- a/scripts/help/help.m
+++ b/scripts/help/help.m
@@ -150,17 +150,17 @@ function retval = do_list_functions ()
                    dir(fullfile (dirs{i}, "*.mex")).name});
 
     if (! isempty (files))
       flist = sprintf ("%s*** functions in %s:\n\n%s\n\n",
                        flist, dirs{i}, list_in_columns (files));
     endif
   endfor
 
-  retval = cstrcat (operators, keywords, builtins, flist);
+  retval = [operators, keywords, builtins, flist];
 
 endfunction
 
 function do_contents (name)
 
   found = false;
 
   dlist = find_dir_in_path (name, "all");
diff --git a/scripts/miscellaneous/copyfile.m b/scripts/miscellaneous/copyfile.m
--- a/scripts/miscellaneous/copyfile.m
+++ b/scripts/miscellaneous/copyfile.m
@@ -57,17 +57,17 @@ function [status, msg, msgid] = copyfile
       error ("copyfile: first argument must be a character string or a cell array of character strings");
     endif
 
     if (! ischar (f2))
       error ("copyfile: second argument must be a character string");
     endif
 
     if (nargin == 3 && strcmp (force, "f"))
-      cmd = cstrcat (cmd, " ", cmd_force_flag);
+      cmd = [cmd " " cmd_force_flag];
     endif
 
     ## If f1 isn't a cellstr convert it to one.
     if (ischar (f1))
       f1 = cellstr (f1);
     endif
 
     ## If f1 has more than 1 element f2 must be a directory
diff --git a/scripts/miscellaneous/dir.m b/scripts/miscellaneous/dir.m
--- a/scripts/miscellaneous/dir.m
+++ b/scripts/miscellaneous/dir.m
@@ -106,17 +106,17 @@ function retval = dir (directory)
           ## info about the link itself.
           if (S_ISLNK (st.mode))
             [xst, err, msg] = stat (fn);
             if (! err)
               st = xst;
             endif
           endif
           [dummy, fn, ext] = fileparts (fn);
-          fn = cstrcat (fn, ext);
+          fn = [fn ext];
           info(i,1).name = fn;
           lt = localtime (st.mtime);
           info(i,1).date = strftime ("%d-%b-%Y %T", lt);
           info(i,1).bytes = st.size;
           info(i,1).isdir = S_ISDIR (st.mode);
           info(i,1).datenum = datenum (lt.year + 1900, lt.mon + 1, lt.mday,
                                        lt.hour, lt.min, lt.sec);
           info(i,1).statinfo = st;
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -145,17 +145,17 @@
 
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
 
 function ret = edit (varargin)
 
   ## Pick up globals or default them.
 
-  persistent FUNCTION = struct ("EDITOR", cstrcat (EDITOR (), " %s"),
+  persistent FUNCTION = struct ("EDITOR", [EDITOR() " %s"],
                                 "HOME", fullfile (default_home, "octave"),
                                 "AUTHOR", default_user(1),
                                 "EMAIL",  [],
                                 "LICENSE",  "GPL",
                                 "MODE", "async",
                                 "EDITINPLACE", false);
   ## Make sure the stateval variables survive "clear functions".
   mlock;
@@ -335,17 +335,17 @@ function ret = edit (varargin)
         do_edit (FUNCTION.EDITOR, fileandpath, FUNCTION.MODE);
         return;
       else
         ## If the file is modifiable in place then edit it, otherwise make
         ## a copy in HOME and then edit it.
         fid = fopen (fileandpath, "r+t");
         if (fid < 0)
           from = fileandpath;
-          fileandpath = cstrcat (FUNCTION.HOME, from (rindex (from, filesep):end));
+          fileandpath = [FUNCTION.HOME, from(rindex(from, filesep):end)];
           [status, msg] = copyfile (from, fileandpath, 1);
           if (status == 0)
             error (msg);
           endif
         else
           fclose (fid);
         endif
         do_edit (FUNCTION.EDITOR, fileandpath, FUNCTION.MODE);
@@ -381,29 +381,29 @@ function ret = edit (varargin)
         ## trim newline from end of hostname
         if (! isempty (host))
           host = host(1:end-1);
         endif
       endif
       if (isempty (host))
         FUNCTION.EMAIL = " ";
       else
-        FUNCTION.EMAIL = cstrcat ("<", default_user(0), "@", host, ">");
+        FUNCTION.EMAIL = ["<" default_user(0) "@" host ">"];
       endif
     endif
 
     ## Fill in the revision string.
     now = localtime (time);
-    revs = cstrcat ("Created: ", strftime ("%Y-%m-%d", now));
+    revs = ["Created: " strftime("%Y-%m-%d",now)];
 
     ## Fill in the copyright string.
-    copyright = cstrcat (strftime ("Copyright (C) %Y ", now), FUNCTION.AUTHOR);
+    copyright = [strftime("Copyright (C) %Y ",now) FUNCTION.AUTHOR];
 
     ## Fill in the author tag field.
-    author = cstrcat ("Author: ", FUNCTION.AUTHOR, " ", FUNCTION.EMAIL);
+    author = ["Author: " FUNCTION.AUTHOR " " FUNCTION.EMAIL];
 
     ## Fill in the header.
     uclicense = toupper (FUNCTION.LICENSE);
     switch (uclicense)
       case "GPL"
         head = cstrcat (copyright, "\n\n", "\
   This program is free software; you can redistribute it and/or modify\n\
   it under the terms of the GNU General Public License as published by\n\
@@ -414,17 +414,17 @@ function ret = edit (varargin)
   but WITHOUT ANY WARRANTY; without even the implied warranty of\n\
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n\
   GNU General Public License for more details.\n\
   \n\
   You should have received a copy of the GNU General Public License\n\
   along with Octave; see the file COPYING.  If not, see\n\
   <http://www.gnu.org/licenses/>.\
   ");
-        tail = cstrcat (author, "\n", revs);
+        tail = [author, "\n", revs];
 
       case "BSD"
         head = cstrcat (copyright, "\n\n", "\
   This program is free software; redistribution and use in source and\n\
   binary forms, with or without modification, are permitted provided that\n\
   the following conditions are met:\n\
   \n\
      1.Redistributions of source code must retain the above copyright\n\
@@ -440,73 +440,72 @@ function ret = edit (varargin)
   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n\
   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n\
   OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n\
   HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n\
   LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n\
   OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n\
   SUCH DAMAGE.\
   ");
-        tail = cstrcat (author, "\n", revs);
+        tail = [author, "\n", revs];
 
       case "PD"
         head = "";
-        tail = cstrcat (author, "\n", revs, "\n\n",
-                       "This program is granted to the public domain.");
+        tail = [author, "\n", revs, "\n\n", ...
+                "This program is granted to the public domain."];
 
       otherwise
         head = "";
-        tail = cstrcat (copyright, "\n\n", FUNCTION.LICENSE, "\n",
-                       author, "\n", revs);
+        tail = [copyright, "\n\n", FUNCTION.LICENSE, "\n", author, "\n", revs];
     endswitch
 
     ## Generate the function template.
     exists = exist (name);
     switch (ext)
       case {"cc", "C", "cpp"}
         if (isempty (head))
-          comment = cstrcat ("/*\n", tail, "\n\n*/\n\n");
+          comment = ["/*\n", tail, "\n\n*/\n\n"];
         else
-          comment = cstrcat ("/*\n", head, "\n\n", tail, "\n\n*/\n\n");
+          comment = ["/*\n", head, "\n\n", tail, "\n\n*/\n\n"];
         endif
         ## If we are shadowing an m-file, paste the code for the m-file.
         if (any (exists == [2, 103]))
-          code = cstrcat ("\\ ", strrep (type (name){1}, "\n", "\n// "));
+          code = ['\ ', strrep(type(name){1}, "\n", "\n// ")];
         else
           code = " ";
         endif
         body = cstrcat ("#include <octave/oct.h>\n\n",
-                       "DEFUN_DLD(", name, ",args,nargout,\"\\\n",
-                       name, "\\n\\\n\")\n{\n",
-                       "  octave_value_list retval;\n",
-                       "  int nargin = args.length ();\n\n",
-                       code, "\n  return retval;\n}\n");
+                        "DEFUN_DLD(", name, ",args,nargout,\"\\\n",
+                        name, "\\n\\\n\")\n{\n",
+                        "  octave_value_list retval;\n",
+                        "  int nargin = args.length ();\n\n",
+                        code, "\n  return retval;\n}\n");
 
-        text = cstrcat (comment, body);
+        text = [comment, body];
       case "m"
         ## If we are editing a function defined on the fly, paste the
         ## code.
         if (any (exists == [2, 103]))
           body = type (name){1};
         else
-          body = cstrcat ("function [ret] = ", name, " ()\n\nendfunction\n");
+          body = ["function [ret] = " name " ()\n\nendfunction\n"];
         endif
         if (isempty (head))
-          comment = cstrcat ("## -*- texinfo -*- \n## @deftypefn {Function File}", 
-                             "{@var{ret} =}", name, "(@var{x}, @var{y})\n##\n",
-                             "## @seealso{}\n## @end deftypefn\n\n",
-                             "## ", strrep (tail, "\n", "\n## "), "\n\n");
+          comment = ["## -*- texinfo -*- \n## @deftypefn {Function File}" \
+                     "{@var{ret} =}" name "(@var{x}, @var{y})\n##\n"      \
+                     "## @seealso{}\n## @end deftypefn\n\n"               \
+                     "## " strrep(tail, "\n", "\n## ") "\n\n"];
         else
-          comment = cstrcat ("## ", strrep (head,"\n","\n## "), "\n\n", ...
-                             "## -*- texinfo -*- \n## @deftypefn {Function File}", 
-                             "{@var{ret} =}", name, "(@var{x}, @var{y})\n##\n",
-                             "## @seealso{}\n## @end deftypefn\n\n",
-                             "## ", strrep (tail, "\n", "\n## "), "\n\n");
+          comment = ["## " strrep(head,"\n","\n## ") "\n\n"               \
+                     "## -*- texinfo -*- \n## @deftypefn {Function File}" \
+                     "{@var{ret} =}" name "(@var{x} @var{y})\n##\n"       \
+                     "## @seealso{}\n## @end deftypefn\n\n"               \
+                     "## " strrep(tail, "\n", "\n## ") "\n\n"];
         endif
-        text = cstrcat (comment, body);
+        text = [comment, body];
     endswitch
 
     ## Write the initial file (if there is anything to write)
     fid = fopen (fileandpath, "wt");
     if (fid < 0)
       error ("edit: could not create %s", fileandpath);
     endif
     fputs (fid, text);
@@ -561,19 +560,17 @@ endfunction
 function do_edit (editor, file, mode)
 
   ## Give the hook function a chance.  If that fails, fall back
   ## on running an editor with the system function.
 
   status = __octave_link_edit_file__ (file);
 
   if (! status)
-    system (sprintf (undo_string_escapes (editor),
-                     cstrcat ("\"", file, "\"")),
-            [], mode);
+    system (sprintf (undo_string_escapes (editor), ['"' file '"']), [], mode);
   endif
 
 endfunction
 
 
 %!test
 %! s.editor = edit ("get", "editor");
 %! s.home = edit ("get", "home");
diff --git a/scripts/miscellaneous/fact.m b/scripts/miscellaneous/fact.m
--- a/scripts/miscellaneous/fact.m
+++ b/scripts/miscellaneous/fact.m
@@ -252,17 +252,18 @@ function out = wordwrap (w)
   cols = terminal_size ()(2);
   wc = ostrsplit (w, " ");
   out = "\n";
   i = 1;
   numwords = numel (wc);
   while (i <= numwords);
     line = wc{i};
     while (i < numwords
-           && length (newline = cstrcat (line, " ", wc{i+1})) < cols)
+           && length (newline = [line " " wc{i+1}]) < cols)
       line = newline;
       i++;
     endwhile
-    out = cstrcat (out, line, "\n");
+    out = [out, line, "\n"];
     i++;
   endwhile
-  out = cstrcat (out, "\n");
+  out = [out, "\n"];
 endfunction
+
diff --git a/scripts/miscellaneous/fullfile.m b/scripts/miscellaneous/fullfile.m
--- a/scripts/miscellaneous/fullfile.m
+++ b/scripts/miscellaneous/fullfile.m
@@ -35,36 +35,36 @@ function filename = fullfile (varargin)
       endif
       for i = 2:nargs
         tmp = varargin{i};
         if (i < nargs && strcmp (tmp(end), filesep))
           tmp(end) = "";
         elseif (i == nargs && strcmp (tmp, filesep))
           tmp = "";
         endif
-        filename = cstrcat (filename, filesep, tmp);
+        filename = [filename filesep tmp];
       endfor
     elseif (nargs == 1)
       filename = varargin{1};
     else
       filename = "";
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 
 %!shared fs, fsx, xfs, fsxfs, xfsy
 %! fs = filesep ();
-%! fsx = cstrcat (fs, "x");
-%! xfs = cstrcat ("x", fs);
-%! fsxfs = cstrcat (fs, "x", fs);
-%! xfsy = cstrcat ("x", fs, "y");
+%! fsx = [fs "x"];
+%! xfs = ["x" fs];
+%! fsxfs = [fs "x" fs];
+%! xfsy = ["x" fs "y"];
 %!assert (fullfile (""), "")
 %!assert (fullfile (fs), fs)
 %!assert (fullfile ("", fs), fs)
 %!assert (fullfile (fs, ""), fs)
 %!assert (fullfile ("", fs), fs)
 %!assert (fullfile ("x"), "x")
 %!assert (fullfile ("", "x"), "x")
 %!assert (fullfile ("x", ""), "x")
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -141,19 +141,19 @@
 ## @end deftypefn
 
 function [output, status] = mkoctfile (varargin)
 
   bindir = octave_config_info ("bindir");
 
   shell_script = fullfile (bindir, sprintf ("mkoctfile-%s", OCTAVE_VERSION));
 
-  cmd = cstrcat ("\"", shell_script, "\"");
+  cmd = ['"' shell_script '"'];
   for i = 1:nargin
-    cmd = cstrcat (cmd, " \"", varargin{i}, "\"");
+    cmd = [cmd ' "' varargin{i} '"'];
   endfor
 
   [sys, out] = system (cmd);
 
   if (nargout > 0)
     [output, status] = deal (out, sys);
   else
     printf ("%s", out);
diff --git a/scripts/miscellaneous/movefile.m b/scripts/miscellaneous/movefile.m
--- a/scripts/miscellaneous/movefile.m
+++ b/scripts/miscellaneous/movefile.m
@@ -57,17 +57,17 @@ function [status, msg, msgid] = movefile
       error ("movefile: first argument must be a character string or a cell array of character strings");
     endif
 
     if (! ischar (f2))
       error ("movefile: second argument must be a character string");
     endif
 
     if (nargin == 3 && strcmp (force, "f"))
-      cmd = cstrcat (cmd, " ", cmd_force_flag);
+      cmd = [cmd " " cmd_force_flag];
     endif
 
     ## If f1 isn't a cellstr convert it to one.
     if (ischar (f1))
       f1 = cellstr (f1);
     endif
 
     ## If f1 has more than 1 element f2 must be a directory
diff --git a/scripts/miscellaneous/perl.m b/scripts/miscellaneous/perl.m
--- a/scripts/miscellaneous/perl.m
+++ b/scripts/miscellaneous/perl.m
@@ -36,15 +36,15 @@ function [output, status] = perl (script
   if (ischar (scriptfile)
       && (   (nargin == 1 && ! isempty (scriptfile))
           || (nargin != 1 && iscellstr (varargin))))
     if (! strcmp (scriptfile(1:2), "-e"))
       ## Attempt to find file in loadpath.  No effect for absolute filenames.
       scriptfile = file_in_loadpath (scriptfile);
     endif
 
-    [status, output] = system (cstrcat ("perl ", scriptfile,
-                                        sprintf (" %s", varargin{:})));
+    [status, output] = system (["perl " scriptfile ...
+                                sprintf(" %s", varargin{:})]);
   else
     error ("perl: invalid arguments");
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/python.m b/scripts/miscellaneous/python.m
--- a/scripts/miscellaneous/python.m
+++ b/scripts/miscellaneous/python.m
@@ -35,15 +35,15 @@ function [output, status] = python (scri
   if (ischar (scriptfile)
       && (   (nargin == 1 && ! isempty (scriptfile))
           || (nargin != 1 && iscellstr (varargin))))
     if (! strcmp (scriptfile(1:2), "-c"))
       ## Attempt to find file in loadpath.  No effect for absolute filenames.
       scriptfile = file_in_loadpath (scriptfile);
     endif
 
-    [status, output] = system (cstrcat ("python ", scriptfile,
-                                        sprintf (" %s", varargin{:})));
+    [status, output] = system (["python ", scriptfile, ...
+                                sprintf(" %s", varargin{:})]);
   else
     error ("python: invalid arguments");
   endif
 
 endfunction
diff --git a/scripts/miscellaneous/run.m b/scripts/miscellaneous/run.m
--- a/scripts/miscellaneous/run.m
+++ b/scripts/miscellaneous/run.m
@@ -34,17 +34,17 @@ function run (script)
   endif
 
   [d, f, ext] = fileparts (script);
   if (! isempty (d))
     if (exist (d, "dir"))
       wd = pwd ();
       unwind_protect
         cd (d);
-        if (! exist (cstrcat (f, ext), "file"))
+        if (! exist ([f ext], "file"))
           error ("run: file SCRIPT must exist and be a valid Octave scriptfile");
         endif
         evalin ("caller", sprintf ("source (\"%s%s\");", f, ext),
                 "rethrow (lasterror ())");
       unwind_protect_cleanup
         cd (wd);
       end_unwind_protect
     else
diff --git a/scripts/miscellaneous/tempdir.m b/scripts/miscellaneous/tempdir.m
--- a/scripts/miscellaneous/tempdir.m
+++ b/scripts/miscellaneous/tempdir.m
@@ -24,17 +24,17 @@
 function dirname = tempdir ()
 
   dirname = getenv ("TMPDIR");
   if (isempty (dirname))
     dirname = P_tmpdir;
   endif
 
   if (! strcmp (dirname(end), filesep))
-    dirname = cstrcat (dirname, filesep);
+    dirname = [dirname filesep];
   endif
 
   if (! isdir (dirname))
     warning ("tempdir: '%s' does not exist or is not a directory", dirname);
   endif
 
 endfunction
 
diff --git a/scripts/miscellaneous/unpack.m b/scripts/miscellaneous/unpack.m
--- a/scripts/miscellaneous/unpack.m
+++ b/scripts/miscellaneous/unpack.m
@@ -73,27 +73,27 @@ function filelist = unpack (file, dir = 
   else
     [pathstr, name, ext] = fileparts (file);
 
     ## Check to see if it's .tar.gz, .tar.Z, etc.
     if (any (strcmpi ({".gz" ".Z" ".bz2" ".bz"}, ext)))
       [tmppathstr, tmpname, tmpext] = fileparts (name);
       if (strcmpi (tmpext, ".tar"))
         name = tmpname;
-        ext = cstrcat (tmpext, ext);
+        ext = [tmpext ext];
       endif
     endif
 
     ## If the file is a URL, download it and then work with that file.
     if (! isempty (strfind (file, "://")))
       ## FIXME -- the above is not a perfect test for a URL
       urlfile = file;
       ## FIXME -- should we name the file that we download with the
       ## same file name as the URL requests?
-      tmpfile = cstrcat (tmpnam (), ext);
+      tmpfile = [tmpnam() ext];
       [file, success, msg] = urlwrite (urlfile, tmpfile);
       if (! success)
         error ("unpack: could not get \"%s\": %s", urlfile, msg);
       endif
     endif
 
   endif
 
@@ -173,17 +173,17 @@ function filelist = unpack (file, dir = 
       error ("unpack: mkdir failed to create %s: %s", dir, msg);
     endif
   elseif (! S_ISDIR (s.mode))
     error ("unpack: %s: not a directory", dir);
   endif
 
   unwind_protect
     cd (dir);
-    [status, output] = system (sprintf (cstrcat (command, " 2>&1"), file));
+    [status, output] = system (sprintf ([command " 2>&1"], file));
   unwind_protect_cleanup
     cd (origdir);
   end_unwind_protect
 
   if (status)
     error ("unpack: unarchiving program exited with status: %d\n%s",
            status, output);
   endif
diff --git a/scripts/pkg/private/configure_make.m b/scripts/pkg/private/configure_make.m
--- a/scripts/pkg/private/configure_make.m
+++ b/scripts/pkg/private/configure_make.m
@@ -36,42 +36,40 @@ function configure_make (desc, packdir, 
             "OCTAVE"; octave_binary;
             "INSTALLDIR"; desc.dir};
     scenv = sprintf ("%s=\"%s\" ", cenv{:});
 
     ## Configure.
     if (exist (fullfile (src, "configure"), "file"))
       flags = "";
       if (isempty (getenv ("CC")))
-        flags = cstrcat (flags, " CC=\"", mkoctfile ("-p", "CC"), "\"");
+        flags = [flags ' CC="' mkoctfile("-p", "CC") '"'];
       endif
       if (isempty (getenv ("CXX")))
-        flags = cstrcat (flags, " CXX=\"", mkoctfile ("-p", "CXX"), "\"");
+        flags = [flags ' CXX="' mkoctfile("-p", "CXX") '"'];
       endif
       if (isempty (getenv ("AR")))
-        flags = cstrcat (flags, " AR=\"", mkoctfile ("-p", "AR"), "\"");
+        flags = [flags ' AR="' mkoctfile("-p" "AR") '"'];
       endif
       if (isempty (getenv ("RANLIB")))
-        flags = cstrcat (flags, " RANLIB=\"", mkoctfile ("-p", "RANLIB"), "\"");
+        flags = [flags ' RANLIB="' mkoctfile("-p" "RANLIB") '"'];
       endif
-      [status, output] = shell (cstrcat ("cd '", src, "'; ", scenv,
-                                         "./configure --prefix=\"",
-                                         desc.dir, "\"", flags),
-                                verbose);
+      cmd = ["cd '" src "'; " ...
+             scenv "./configure --prefix=\"" desc.dir "\"" flags];
+      [status, output] = shell (cmd, verbose);
       if (status != 0)
         rmdir (desc.dir, "s");
         disp (output);
         error ("pkg: error running the configure script for %s.", desc.name);
       endif
     endif
 
     ## Make.
     if (exist (fullfile (src, "Makefile"), "file"))
-      [status, output] = shell (cstrcat (scenv, "make -C '", src, "'"),
-                                verbose);
+      [status, output] = shell ([scenv "make -C '" src "'"], verbose);
       if (status != 0)
         rmdir (desc.dir, "s");
         disp (output);
         error ("pkg: error running `make' for the %s package.", desc.name);
       endif
     endif
 
     ## Copy files to "inst" and "inst/arch" (this is instead of 'make
diff --git a/scripts/pkg/private/create_pkgadddel.m b/scripts/pkg/private/create_pkgadddel.m
--- a/scripts/pkg/private/create_pkgadddel.m
+++ b/scripts/pkg/private/create_pkgadddel.m
@@ -24,18 +24,18 @@
 
 function create_pkgadddel (desc, packdir, nm, global_install)
   instpkg = fullfile (desc.dir, nm);
   instfid = fopen (instpkg, "wt");
   ## If it is exists, most of the  PKG_* file should go into the
   ## architecture dependent directory so that the autoload/mfilename
   ## commands work as expected. The only part that doesn't is the
   ## part in the main directory.
-  archdir = fullfile (getarchprefix (desc, global_install), cstrcat (desc.name,
-                      "-", desc.version), getarch ());
+  archdir = fullfile (getarchprefix (desc, global_install), 
+                      [desc.name "-" desc.version], getarch ());
   if (exist (getarchdir (desc, global_install), "dir"))
     archpkg = fullfile (getarchdir (desc, global_install), nm);
     archfid = fopen (archpkg, "at");
   else
     archpkg = instpkg;
     archfid = instfid;
   endif
 
diff --git a/scripts/pkg/private/extract_pkg.m b/scripts/pkg/private/extract_pkg.m
--- a/scripts/pkg/private/extract_pkg.m
+++ b/scripts/pkg/private/extract_pkg.m
@@ -26,19 +26,19 @@ function pkg = extract_pkg (nm, pat)
   fid = fopen (nm, "rt");
   pkg = "";
   if (fid >= 0)
     while (! feof (fid))
       ln = fgetl (fid);
       if (ln > 0)
         t = regexp (ln, pat, "tokens");
         if (! isempty (t))
-          pkg = cstrcat (pkg, "\n", t{1}{1});
+          pkg = [pkg "\n" t{1}{1}];
         endif
       endif
     endwhile
     if (! isempty (pkg))
-      pkg = cstrcat (pkg, "\n");
+      pkg = [pkg "\n"];
     endif
     fclose (fid);
   endif
 endfunction
 
diff --git a/scripts/pkg/private/get_description.m b/scripts/pkg/private/get_description.m
--- a/scripts/pkg/private/get_description.m
+++ b/scripts/pkg/private/get_description.m
@@ -33,17 +33,17 @@ function desc = get_description (filenam
 
   line = fgetl (fid);
   while (line != -1)
     if (line(1) == "#")
       ## Comments, do nothing.
     elseif (isspace (line(1)))
       ## Continuation lines
       if (exist ("keyword", "var") && isfield (desc, keyword))
-        desc.(keyword) = cstrcat (desc.(keyword), " ", deblank (line));
+        desc.(keyword) = [desc.(keyword) " " deblank(line)];
       endif
     else
       ## Keyword/value pair
       colon = find (line == ":");
       if (length (colon) == 0)
         disp ("skipping line");
       else
         colon = colon(1);
diff --git a/scripts/pkg/private/get_forge_pkg.m b/scripts/pkg/private/get_forge_pkg.m
--- a/scripts/pkg/private/get_forge_pkg.m
+++ b/scripts/pkg/private/get_forge_pkg.m
@@ -48,17 +48,17 @@ function [ver, url] = get_forge_pkg (nam
     t = regexp (html, pat, "tokens");
     if (isempty (t) || isempty (t{1}))
       error ("get_forge_pkg: could not read version number from package's page");
     else
       ver = t{1}{1};
       if (nargout > 1)
         # Build download string.
         pkg_file = sprintf ("%s-%s.tar.gz", name, ver);
-        url = cstrcat ("http://packages.octave.org/download/", pkg_file);
+        url = ["http://packages.octave.org/download/" pkg_file];
         ## Verify that the package string exists on the page.
         if (isempty (strfind (html, pkg_file)))
           warning ("get_forge_pkg: download URL not verified");
         endif
       endif
     endif
   else
     ## Try get the list of all packages.
diff --git a/scripts/pkg/private/getarch.m b/scripts/pkg/private/getarch.m
--- a/scripts/pkg/private/getarch.m
+++ b/scripts/pkg/private/getarch.m
@@ -18,13 +18,13 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{arch} =} getarch ()
 ## Undocumented internal function.
 ## @end deftypefn
 
 function arch = getarch ()
-  persistent _arch = cstrcat (octave_config_info ("canonical_host_type"),
-                              "-", octave_config_info ("api_version"));
+  persistent _arch = [octave_config_info("canonical_host_type"), "-", ...
+                      octave_config_info("api_version")];
   arch = _arch;
 endfunction
 
diff --git a/scripts/pkg/private/getarchprefix.m b/scripts/pkg/private/getarchprefix.m
--- a/scripts/pkg/private/getarchprefix.m
+++ b/scripts/pkg/private/getarchprefix.m
@@ -20,14 +20,14 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{archprefix} =} getarchprefix (@var{desc}, @var{global_install})
 ## Undocumented internal function.
 ## @end deftypefn
 
 function archprefix = getarchprefix (desc, global_install)
   if (global_install)
     archprefix = fullfile (octave_config_info ("libdir"), "octave",
-                           "packages", cstrcat (desc.name, "-", desc.version));
+                           "packages", [desc.name "-" desc.version]);
   else
     archprefix = desc.dir;
   endif
 endfunction
 
diff --git a/scripts/pkg/private/install.m b/scripts/pkg/private/install.m
--- a/scripts/pkg/private/install.m
+++ b/scripts/pkg/private/install.m
@@ -116,21 +116,20 @@ function install (files, handle_deps, au
         [dummy, nm] = fileparts (tgz);
         if ((length (nm) >= length (desc.name))
             && ! strcmp (desc.name, nm(1:length (desc.name))))
           error ("package name '%s' doesn't correspond to its filename '%s'",
                  desc.name, nm);
         endif
 
         ## Set default installation directory.
-        desc.dir = fullfile (prefix, cstrcat (desc.name, "-", desc.version));
+        desc.dir = fullfile (prefix, [desc.name "-" desc.version]);
 
         ## Set default architectire dependent installation directory.
-        desc.archprefix = fullfile (archprefix, cstrcat (desc.name, "-",
-                                                         desc.version));
+        desc.archprefix = fullfile (archprefix, [desc.name "-" desc.version]);
 
         ## Save desc.
         descriptions{end+1} = desc;
 
         ## Are any of the new packages already installed?
         ## If so we'll remove the old version.
         for j = 1:length (packages)
           if (strcmp (packages{j}.name, desc.name))
@@ -167,19 +166,18 @@ function install (files, handle_deps, au
                                      descriptions{idx2}};
       endif
       bad_deps = get_unsatisfied_deps (desc, pseudo_installed_packages);
       ## Are there any unsatisfied dependencies?
       if (! isempty (bad_deps))
         ok = false;
         for i = 1:length (bad_deps)
           dep = bad_deps{i};
-          error_text = cstrcat (error_text, " ", desc.name, " needs ",
-                               dep.package, " ", dep.operator, " ",
-                               dep.version, "\n");
+          error_text = [error_text " " desc.name " needs " ...
+                        dep.package " " dep.operator " " dep.version "\n"]);
         endfor
       endif
     endfor
 
     ## Did we find any unsatisfied dependencies?
     if (! ok)
       error ("the following dependencies were unsatisfied:\n  %s", error_text);
     endif
diff --git a/scripts/pkg/private/installed_packages.m b/scripts/pkg/private/installed_packages.m
--- a/scripts/pkg/private/installed_packages.m
+++ b/scripts/pkg/private/installed_packages.m
@@ -135,20 +135,19 @@ function [out1, out2] = installed_packag
   for i = 1:num_packages
     cur_name = installed_pkgs_lst{idx(i)}.name;
     cur_version = installed_pkgs_lst{idx(i)}.version;
     cur_dir = installed_pkgs_lst{idx(i)}.dir;
     if (length (cur_dir) > max_dir_length)
       first_char = length (cur_dir) - max_dir_length + 4;
       first_filesep = strfind (cur_dir(first_char:end), filesep ());
       if (! isempty (first_filesep))
-        cur_dir = cstrcat ("...",
-                          cur_dir((first_char + first_filesep(1) - 1):end));
+        cur_dir = ["..." cur_dir((first_char + first_filesep(1) - 1):end)];
       else
-        cur_dir = cstrcat ("...", cur_dir(first_char:end));
+        cur_dir = ["..." cur_dir(first_char:end)];
       endif
     endif
     if (installed_pkgs_lst{idx(i)}.loaded)
       cur_loaded = "*";
     else
       cur_loaded = " ";
     endif
     printf (format, cur_name, cur_loaded, cur_version, cur_dir);
diff --git a/scripts/pkg/private/load_packages_and_dependencies.m b/scripts/pkg/private/load_packages_and_dependencies.m
--- a/scripts/pkg/private/load_packages_and_dependencies.m
+++ b/scripts/pkg/private/load_packages_and_dependencies.m
@@ -26,23 +26,23 @@ function load_packages_and_dependencies 
                                          global_install)
   idx = load_package_dirs (idx, [], handle_deps, installed_pkgs_lst);
   dirs = {};
   execpath = EXEC_PATH ();
   for i = idx;
     ndir = installed_pkgs_lst{i}.dir;
     dirs{end+1} = ndir;
     if (exist (fullfile (dirs{end}, "bin"), "dir"))
-      execpath = cstrcat (execpath, pathsep (), fullfile (dirs{end}, "bin"));
+      execpath = [execpath pathsep() fullfile(dirs{end}, "bin")];
     endif
     tmpdir = getarchdir (installed_pkgs_lst{i});
     if (exist (tmpdir, "dir"))
       dirs{end + 1} = tmpdir;
       if (exist (fullfile (dirs{end}, "bin"), "dir"))
-        execpath = cstrcat (execpath, pathsep (), fullfile (dirs{end}, "bin"));
+        execpath = [execpath pathsep() fullfile(dirs{end}, "bin")];
       endif
     endif
   endfor
 
   ## Load the packages.
   if (length (dirs) > 0)
     addpath (dirs{:});
   endif
diff --git a/scripts/pkg/private/rebuild.m b/scripts/pkg/private/rebuild.m
--- a/scripts/pkg/private/rebuild.m
+++ b/scripts/pkg/private/rebuild.m
@@ -30,32 +30,31 @@ function descriptions = rebuild (prefix,
     endif
     ## the two first entries of dirlist are "." and ".."
     dirlist([1,2]) = [];
   else
     old_descriptions = installed_packages (list, list);
     wd = pwd ();
     unwind_protect
       cd (prefix);
-      dirlist = glob (cellfun(@(x) cstrcat (x, '-*'), files, 'uniformoutput', 0));
+      dirlist = glob (cellfun(@(x) [x '-*'], files, 'uniformoutput', 0));
     unwind_protect_cleanup
       cd (wd);
     end_unwind_protect
   endif
   descriptions = {};
   for k = 1:length (dirlist)
     descfile = fullfile (prefix, dirlist{k}, "packinfo", "DESCRIPTION");
     if (verbose)
       printf ("recreating package description from %s\n", dirlist{k});
     endif
     if (exist (descfile, "file"))
       desc = get_description (descfile);
       desc.dir = fullfile (prefix, dirlist{k});
-      desc.archprefix = fullfile (archprefix, cstrcat (desc.name, "-",
-                                  desc.version));
+      desc.archprefix = fullfile (archprefix, [desc.name "-" desc.version]);
       if (auto != 0)
         if (exist (fullfile (desc.dir, "packinfo", ".autoload"), "file"))
           unlink (fullfile (desc.dir, "packinfo", ".autoload"));
         endif
         if (auto < 0)
           desc.autoload = 0;
         elseif (auto > 0)
           desc.autoload = 1;
diff --git a/scripts/pkg/private/repackage.m b/scripts/pkg/private/repackage.m
--- a/scripts/pkg/private/repackage.m
+++ b/scripts/pkg/private/repackage.m
@@ -39,18 +39,18 @@ function repackage (builddir, buildlist)
       endif
       rmdir (fullfile (pack.name, "inst", "packinfo"));
       if (exist (fullfile (pack.name, "inst", "doc"), "dir"))
         movefile (fullfile (pack.name, "inst", "doc"), pack.name);
       endif
       if (exist (fullfile (pack.name, "inst", "bin"), "dir"))
         movefile (fullfile (pack.name, "inst", "bin"), pack.name);
       endif
-      archdir = fullfile (pack.archprefix, cstrcat (pack.name, "-",
-                          pack.version), getarch ());
+      archdir = fullfile (pack.archprefix, [pack.name "-" pack.version],
+                          getarch ());
       if (exist (archdir, "dir"))
         if (exist (fullfile (pack.name, "inst", "PKG_ADD"), "file"))
           unlink (fullfile (pack.name, "inst", "PKG_ADD"));
         endif
         if (exist (fullfile (pack.name, "inst", "PKG_DEL"), "file"))
           unlink (fullfile (pack.name, "inst", "PKG_DEL"));
         endif
         if (exist (fullfile (archdir, "PKG_ADD"), "file"))
@@ -66,17 +66,17 @@ function repackage (builddir, buildlist)
           movefile (fullfile (pack.name, "inst", "PKG_ADD"),
                     fullfile (pack.name, "PKG_ADD"));
         endif
         if (exist (fullfile (pack.name, "inst", "PKG_DEL"), "file"))
           movefile (fullfile (pack.name, "inst", "PKG_DEL"),
                     fullfile (pack.name, "PKG_DEL"));
         endif
       endif
-      tfile = cstrcat (pack.name, "-", pack.version, ".tar");
+      tfile = [pack.name "-" pack.version ".tar"];
       tar (tfile, pack.name);
       try
         gzip (tfile);
         unlink (tfile);
       catch
         warning ("failed to compress %s", tfile);
       end_try_catch
     unwind_protect_cleanup
diff --git a/scripts/pkg/private/shell.m b/scripts/pkg/private/shell.m
--- a/scripts/pkg/private/shell.m
+++ b/scripts/pkg/private/shell.m
@@ -25,24 +25,24 @@
 ## contain the output of the execeuted command.
 
 function [status, output] = shell (cmd, verbose)
   persistent have_sh;
 
   cmd = strrep (cmd, "\\", "/");
   if (ispc () && ! isunix ())
     if (isempty (have_sh))
-      if (system ("sh.exe -c \"exit\""))
+      if (system ('sh.exe -c "exit"'))
         have_sh = false;
       else
         have_sh = true;
       endif
     endif
     if (have_sh)
-      cmd = cstrcat ("sh.exe -c \"", cmd, "\"");
+      cmd = ['sh.exe -c "' cmd '"'];
     else
       error ("pkg: unable to find the command shell.");
     endif
   endif
   ## if verbose, we want to display the output in real time. To do this, we
   ## must call system with 1 output argument. But then the variable `output'
   ## won't exist. So we initialize it empty. If an error does occur, and we
   ## are verbose we will return an empty string but it's all fine since
diff --git a/scripts/pkg/private/uninstall.m b/scripts/pkg/private/uninstall.m
--- a/scripts/pkg/private/uninstall.m
+++ b/scripts/pkg/private/uninstall.m
@@ -76,19 +76,18 @@ function uninstall (pkgnames, handle_dep
     for i = 1:length (remaining_packages)
       desc = remaining_packages{i};
       bad_deps = get_unsatisfied_deps (desc, remaining_packages);
 
       ## Will the uninstallation break any dependencies?
       if (! isempty (bad_deps))
         for i = 1:length (bad_deps)
           dep = bad_deps{i};
-          error_text = cstrcat (error_text, " ", desc.name, " needs ",
-                               dep.package, " ", dep.operator, " ",
-                               dep.version, "\n");
+          error_text = [error_text " " desc.name " needs " ...
+                        dep.package " " dep.operator " " dep.version "\n"];
         endfor
       endif
     endfor
 
     if (! isempty (error_text))
       error ("the following dependencies where unsatisfied:\n  %s", error_text);
     endif
   endif
diff --git a/scripts/plot/private/__go_draw_axes__.m b/scripts/plot/private/__go_draw_axes__.m
--- a/scripts/plot/private/__go_draw_axes__.m
+++ b/scripts/plot/private/__go_draw_axes__.m
@@ -559,17 +559,17 @@ function __go_draw_axes__ (h, plot_strea
           is_image_data(data_idx) = false;
           parametric(data_idx) = true;
           have_cdata(data_idx) = false;
           have_3d_patch(data_idx) = false;
           if (isempty (obj.displayname))
             titlespec{data_idx} = "title \"\"";
           else
             tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "displayname"));
-            titlespec{data_idx} = cstrcat ("title \"", tmp, "\"");
+            titlespec{data_idx} = ['title "' tmp '"'];
           endif
           usingclause{data_idx} = sprintf ("record=%d", numel (obj.xdata));
           errbars = "";
           if (nd == 3)
             xdat = obj.xdata(:);
             ydat = obj.ydata(:);
             if (! isempty (obj.zdata))
               zdat = obj.zdata(:);
@@ -678,17 +678,17 @@ function __go_draw_axes__ (h, plot_strea
                  have_cdata(data_idx) = false;
                  have_3d_patch(data_idx) = false;
                endif
 
                if (i > 1 || isempty (obj.displayname))
                  titlespec{local_idx} = "title \"\"";
                else
                  tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "displayname"));
-                 titlespec{local_idx} = cstrcat ("title \"", tmp, "\"");
+                 titlespec{local_idx} = ['title "' tmp '"'];
                endif
                if (isfield (obj, "facecolor"))
                  if ((strncmp (obj.facecolor, "flat", 4)
                      || strncmp (obj.facecolor, "interp", 6))
                      && isfield (obj, "cdata"))
                    if (ndims (obj.cdata) == 2
                        && (columns (obj.cdata) == nc
                            && (rows (obj.cdata) == 1
@@ -1114,17 +1114,17 @@ function __go_draw_axes__ (h, plot_strea
             style = do_linestyle_command (obj, obj.edgecolor,
                                           data_idx, mono,
                                           plot_stream);
 
             if (isempty (obj.displayname))
               titlespec{data_idx} = "title \"\"";
             else
               tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "displayname"));
-              titlespec{data_idx} = cstrcat ("title \"", tmp, "\"");
+              titlespec{data_idx} = ['title "' tmp '"'];
             endif
             withclause{data_idx} = sprintf ("with pm3d linestyle %d",
                                             data_idx);
             withpm3d = true;
             pm3didx = data_idx;
 
             xdat = obj.xdata;
             ydat = obj.ydata;
@@ -2257,27 +2257,27 @@ function [f, s, fnt, it, bld] = get_font
   endif
   f = fnt;
   it = false;
   bld = false;
   if (! isempty (t.fontweight) && strcmpi (t.fontweight, "bold"))
     if (! isempty (t.fontangle)
         && (strcmpi (t.fontangle, "italic")
             || strcmpi (t.fontangle, "oblique")))
-      f = cstrcat (f, "-bolditalic");
+      f = [f "-bolditalic"];
       it = true;
       bld = true;
     else
-      f = cstrcat (f, "-bold");
+      f = [f "-bold"];
       bld = true;
     endif
   elseif (! isempty (t.fontangle)
           && (strcmpi (t.fontangle, "italic")
               || strcmpi (t.fontangle, "oblique")))
-    f = cstrcat (f, "-italic");
+    f = [f "-italic"];
     it = true;
   endif
   if (isempty (t.fontsize))
     s = 10;
   else
     s = t.fontsize;
   endif
 endfunction
@@ -2362,81 +2362,75 @@ function str = __tex2enhanced__ (str, fn
   persistent sym = __setup_sym_table__ ();
   persistent flds = fieldnames (sym);
 
   [s, e, m] = regexp (str, "\\\\([a-zA-Z]+|0)", "start", "end", "matches");
 
   for i = length (s) : -1 : 1
     ## special case for "\0"  and replace with "{/Symbol \306}'
     if (strncmp (m{i}, '\0', 2))
-      str = cstrcat (str(1:s(i) - 1), '{/Symbol \306}', str(s(i) + 2:end));
+      str = [str(1:s(i) - 1) '{/Symbol \306}' str(s(i) + 2:end)];
     else
       f = m{i}(2:end);
       if (isfield (sym, f))
         g = getfield (sym, f);
         ## FIXME The symbol font doesn't seem to support bold or italic
         ##if (bld)
         ##  if (it)
         ##    g = regexprep (g, '/Symbol', '/Symbol-bolditalic');
         ##  else
         ##    g = regexprep (g, '/Symbol', '/Symbol-bold');
         ##  endif
         ##elseif (it)
         ##  g = regexprep (g, '/Symbol', '/Symbol-italic');
         ##endif
-        str = cstrcat (str(1:s(i) - 1), g, str(e(i) + 1:end));
+        str = [str(1:s(i) - 1) g str(e(i) + 1:end)];
       elseif (strncmp (f, "rm", 2))
         bld = false;
         it = false;
-        str = cstrcat (str(1:s(i) - 1), '/', fnt, ' ', str(s(i) + 3:end));
+        str = [str(1:s(i) - 1) '/' fnt ' ' str(s(i) + 3:end)];
       elseif (strncmp (f, "it", 2) || strncmp (f, "sl", 2))
         it = true;
         if (bld)
-          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bolditalic ',
-                         str(s(i) + 3:end));
+          str = [str(1:s(i) - 1) '/' fnt '-bolditalic ' str(s(i) + 3:end)];
         else
-          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-italic ',
-                         str(s(i) + 3:end));
+          str = [str(1:s(i) - 1) '/' fnt '-italic ' str(s(i) + 3:end)];
         endif
       elseif (strncmp (f, "bf", 2))
         bld = true;
         if (it)
-          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bolditalic ',
-                         str(2(i) + 3:end));
+          str = [str(1:s(i) - 1) '/' fnt '-bolditalic ' str(s(i) + 3:end)];
         else
-          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bold ',
-                         str(s(i) + 3:end));
+          str = [str(1:s(i) - 1) '/' fnt '-bold ' str(s(i) + 3:end)];
         endif
       elseif (strcmpi (f, "color"))
         ## FIXME Ignore \color but remove trailing {} block as well
         d = strfind (str(e(i) + 1:end),'}');
         if (isempty (d))
           warning ('syntax error in \color argument');
         else
-          str = cstrcat (str(1:s(i) - 1), str(e(i) + d + 1:end));
+          str = [str(1:s(i) - 1) str(e(i) + d + 1:end)];
         endif
       elseif (strcmpi (f, "fontname"))
         b1 = strfind (str(e(i) + 1:end),'{');
         b2 = strfind (str(e(i) + 1:end),'}');
         if (isempty (b1) || isempty (b2))
           warning ('syntax error in \fontname argument');
         else
-          str = cstrcat (str(1:s(i) - 1), '/',
-                         str(e(i)+b1(1) + 1:e(i)+b2(1)-1), '{}',
-                         str(e(i) + b2(1) + 1:end));
+          str = [str(1:s(i) - 1), '/', str(e(i)+b1(1) + 1:e(i)+b2(1)-1), ...
+                 '{}', str(e(i) + b2(1) + 1:end)];
         endif
       elseif (strcmpi (f, "fontsize"))
         b1 = strfind (str(e(i) + 1:end),'{');
         b2 = strfind (str(e(i) + 1:end),'}');
         if (isempty (b1) || isempty (b2))
           warning ('syntax error in \fontname argument');
         else
-          str = cstrcat (str(1:s(i) - 1), '/=',
-                         str(e(i)+b1(1) + 1:e(i)+b2(1)-1), '{}',
-                         str(e(i) + b2(1) + 1:end));
+          str = [str(1:s(i) - 1), '/=', str(e(i)+b1(1) + 1:e(i)+b2(1)-1), ...
+                 '{}', str(e(i) + b2(1) + 1:end)];
         endif
       else
         ## Last desperate attempt to treat the symbol. Look for things
         ## like \pix, that should be translated to the symbol Pi and x
         for j = 1 : length (flds)
           if (strncmp (flds{j}, f, length (flds{j})))
             g = getfield (sym, flds{j});
             ## FIXME The symbol font doesn't seem to support bold or italic
@@ -2444,18 +2438,17 @@ function str = __tex2enhanced__ (str, fn
             ##  if (it)
             ##    g = regexprep (g, '/Symbol', '/Symbol-bolditalic');
             ##  else
             ##    g = regexprep (g, '/Symbol', '/Symbol-bold');
             ##  endif
             ##elseif (it)
             ##  g = regexprep (g, '/Symbol', '/Symbol-italic');
             ##endif
-            str = cstrcat (str(1:s(i) - 1), g,
-                           str(s(i) + length (flds{j}) + 1:end));
+            str = [str(1:s(i) - 1) g str(s(i) + length (flds{j}) + 1:end)];
             break;
           endif
         endfor
       endif
     endif
   endfor
 
   ## Prepend @ to things  things like _0^x or _{-100}^{100} for
@@ -2502,36 +2495,36 @@ function str = __tex2enhanced__ (str, fn
               else
                 si++;
               endif
             endwhile
             l2 = l2 (min (length (l2), si));
             if (length_string (str(s(i)+p+2:s(i)+p+l1-1)) <=
                 length_string (str(s(i+1)+p+2:s(i+1)+p+l2-1)))
               ## Shortest already first!
-              str = cstrcat (str(1:s(i)+p-1), "@", str(s(i)+p:end));
+              str = [str(1:s(i)+p-1) "@" str(s(i)+p:end)];
             else
               ## Have to swap sub/super-script to get shortest first.
-              str = cstrcat (str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+l2),
-                             str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+l2+1:end));
+              str = [str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+l2), ...
+                     str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+l2+1:end)];
             endif
           else
             ## Have to swap sub/super-script to get shortest first.
-            str = cstrcat (str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+1),
-                           str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+2:end));
+            str = [str(1:s(i)+p-1), "@", str(s(i+1)+p:s(i+1)+p+1), ...
+                   str(s(i)+p:s(i)+p+l1), str(s(i+1)+p+2:end)];
           endif
           i += 2;
           p ++;
         else
           i++;
         endif
       else
         if (s(i+1) == s(i) + 2)
           ## Shortest already first!
-          str = cstrcat (str(1:s(i)+p-1), "@", str(s(i)+p:end));
+          str = [str(1:s(i)+p-1) "@" str(s(i)+p:end)];
           p ++;
           i += 2;
         else
           i ++;
         endif
       endif
     else
       i ++;
diff --git a/scripts/signal/spectral_adf.m b/scripts/signal/spectral_adf.m
--- a/scripts/signal/spectral_adf.m
+++ b/scripts/signal/spectral_adf.m
@@ -42,17 +42,17 @@ function retval = spectral_adf (c, win, 
 
   if (nargin < 3)
     b = 1 / ceil (sqrt (cr));
   endif
 
   if (nargin == 1)
     w = triangle_lw (cr, b);
   else
-    win = str2func (cstrcat (win, "_lw"));
+    win = str2func ([win "_lw")];
     w = feval (win, cr, b);
   endif
 
   c = c .* w;
 
   retval = 2 * real (fft (c)) - c(1);
   retval = [(zeros (cr, 1)), retval];
   retval(:, 1) = (0 : cr-1)' / cr;
diff --git a/scripts/signal/spectral_xdf.m b/scripts/signal/spectral_xdf.m
--- a/scripts/signal/spectral_xdf.m
+++ b/scripts/signal/spectral_xdf.m
@@ -41,17 +41,17 @@ function retval = spectral_xdf (x, win, 
 
   if (nargin < 3)
     b = 1 / ceil (sqrt (xr));
   endif
 
   if (nargin == 1)
     w = triangle_sw (xr, b);
   else
-    win = str2func (cstrcat (win, "_sw"));
+    win = str2func ([win "_sw")];
     w = feval (win, xr, b);
   endif
 
   x = x - sum (x) / xr;
 
   retval = (abs (fft (x)) / xr).^2;
   retval = real (ifft (fft (retval) .* fft (w)));
 
diff --git a/scripts/statistics/tests/z_test.m b/scripts/statistics/tests/z_test.m
--- a/scripts/statistics/tests/z_test.m
+++ b/scripts/statistics/tests/z_test.m
@@ -73,15 +73,15 @@ function [pval, z] = z_test (x, m, v, al
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("z_test: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    s = cstrcat ("Z-test of mean(x) == %g against mean(x) %s %g,\n",
-                 "with known var(x) == %g:\n",
-                 "  pval = %g\n");
+    s = ["Z-test of mean(x) == %g against mean(x) %s %g,\n", \
+         "with known var(x) == %g:\n",                       \
+         "  pval = %g\n");
     printf (s, m, alt, m, v, pval);
   endif
 
 endfunction
diff --git a/scripts/statistics/tests/z_test_2.m b/scripts/statistics/tests/z_test_2.m
--- a/scripts/statistics/tests/z_test_2.m
+++ b/scripts/statistics/tests/z_test_2.m
@@ -73,16 +73,16 @@ function [pval, z] = z_test_2 (x, y, v_x
     pval = 1 - cdf;
   elseif (strcmp (alt, "<"))
     pval = cdf;
   else
     error ("z_test_2: option %s not recognized", alt);
   endif
 
   if (nargout == 0)
-    s = cstrcat ("Two-sample Z-test of mean(x) == mean(y) against ",
-                 "mean(x) %s mean(y),\n",
-                 "with known var(x) == %g and var(y) == %g:\n",
-                 "  pval = %g\n");
+    s = ["Two-sample Z-test of mean(x) == mean(y) against ", \
+         "mean(x) %s mean(y),\n",                            \
+         "with known var(x) == %g and var(y) == %g:\n",      \
+         "  pval = %g\n"];
     printf (s, alt, v_x, v_y, pval);
   endif
 
 endfunction
diff --git a/scripts/strings/mat2str.m b/scripts/strings/mat2str.m
--- a/scripts/strings/mat2str.m
+++ b/scripts/strings/mat2str.m
@@ -98,36 +98,36 @@ function s = mat2str (x, n = 15, cls = "
       s = sprintf (fmt, real (x), imag (x));
     elseif (x_islogical)
       s = v{x+1};
     else
       s = sprintf (fmt, x);
     endif
   else
     ## Non-scalar X, print brackets
-    fmt = cstrcat (fmt, " ");
+    fmt = [fmt " "];
     if (x_iscomplex)
       t = x.';
       s = sprintf (fmt, [real(t(:))'; imag(t(:))']);
     elseif (x_islogical)
       t = v(x+1);
       s = cstrcat (sprintf (fmt, t{:}));
     else
       s = sprintf (fmt, x.');
     endif
 
-    s = cstrcat ("[", s);
+    s = ["[" s];
     s(end) = "]";
     idx = strfind (s, " ");
     nc = columns (x);
     s(idx(nc:nc:end)) = ";";
   endif
 
   if (strcmp ("class", cls))
-    s = cstrcat (class (x), "(", s, ")");
+    s = [class(x) "(" s ")"];
   endif
 
 endfunction
 
 
 %!assert (mat2str (0.7), "0.7")
 %!assert (mat2str (pi), "3.14159265358979")
 %!assert (mat2str (pi, 5), "3.1416")
diff --git a/scripts/strings/strtok.m b/scripts/strings/strtok.m
--- a/scripts/strings/strtok.m
+++ b/scripts/strings/strtok.m
@@ -206,19 +206,19 @@ endfunction
 
 %% Test 'bad' string orientations
 %!assert (strtok (" this ".'), "this".');   # delimiter at start and end
 %!assert (strtok (" this ".',"jkl "), "this".');
 
 %% Test with TAB, LF, VT, FF, and CR
 %!test
 %! for ch = "\t\n\v\f\r"
-%!   [t, r] = strtok (cstrcat ("beg", ch, "end"));
+%!   [t, r] = strtok (["beg", ch, "end"]);
 %!   assert (t, "beg");
-%!   assert (r, cstrcat (ch, "end"));
+%!   assert (r, [ch, "end"]);
 %! endfor
 
 %% Test input validation
 %!error strtok ()
 %!error strtok ("a", "b", "c")
 %!error <STR must be a string> strtok (1, "b")
 %!error <STR cannot be a 2-D> strtok (char ("hello", "world"), "l")
 
diff --git a/scripts/testfun/__run_test_suite__.m b/scripts/testfun/__run_test_suite__.m
--- a/scripts/testfun/__run_test_suite__.m
+++ b/scripts/testfun/__run_test_suite__.m
@@ -272,14 +272,14 @@ function [dp, dn, dxf, dsk] = run_test_s
   ##  printf("%s%s -> passes %d of %d tests\n", ident, d, dp, dn);
 endfunction
 
 function n = num_elts_matching_pattern (lst, pat)
   n = sum (cellfun (@(x) !isempty (x), regexp (lst, pat, 'once')));
 endfunction
 
 function report_files_with_no_tests (with, without, typ)
-  pat = cstrcat ('\', typ, "$");
+  pat = ['\' typ "$"];
   n_with = num_elts_matching_pattern (with, pat);
   n_without = num_elts_matching_pattern (without, pat);
   n_tot = n_with + n_without;
   printf ("\n%d (of %d) %s files have no tests.\n", n_without, n_tot, typ);
 endfunction
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -56,19 +56,19 @@
 ## but instead give a summary; don't print out the whole list, just
 ## say what the first different element is, etc.  To do this, make
 ## the message generation type specific.
 
 function assert (cond, varargin)
 
   in = deblank (argn(1,:));
   for i = 2:rows (argn)
-    in = cstrcat (in, ",", deblank (argn(i,:)));
+    in = [in "," deblank(argn(i,:))];
   endfor
-  in = cstrcat ("(", in, ")");
+  in = ["(" in ")"];
 
   if (nargin == 1 || (nargin > 1 && islogical (cond) && ischar (varargin{1})))
     if ((! isnumeric (cond) && ! islogical (cond)) || ! all (cond(:)))
       if (nargin == 1)
         ## Say which elements failed?
         error ("assert %s failed", in);
       else
         error (varargin{:});
@@ -142,17 +142,17 @@ function assert (cond, varargin)
       iserror = 1;
       coda = "Dimensions don't match";
 
     else
       if (nargin < 3)
         ## Without explicit tolerance, be more strict.
         if (! strcmp (class (cond), class (expected)))
           iserror = 1;
-          coda = cstrcat ("Class ", class (cond), " != ", class (expected));
+          coda = ["Class " class (cond) " != " class(expected)];
         elseif (isnumeric (cond))
           if (issparse (cond) != issparse (expected))
             if (issparse (cond))
               iserror = 1;
               coda = "sparse != non-sparse";
             else
               iserror = 1;
               coda = "non-sparse != sparse";
@@ -223,19 +223,19 @@ function assert (cond, varargin)
     if (! isempty (idx))
       str = str(idx(1):idx(end));
     endif
     str2 = disp (cond);
     idx = find (str2 != "\n");
     if (! isempty (idx))
       str2 = str2 (idx(1):idx(end));
     endif
-    msg = cstrcat ("assert ", in, " expected\n", str, "\nbut got\n", str2);
+    msg = ["assert " in " expected\n" str "\nbut got\n" str2];
     if (! isempty (coda))
-      msg = cstrcat (msg, "\n", coda);
+      msg = [msg, "\n", coda];
     endif
     error ("%s", msg);
   endif
 
 endfunction
 
 
 ## empty input
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -123,17 +123,17 @@ function demo (name, n)
     if (i > 1)
       input ("Press <enter> to continue: ", "s");
     endif
 
     ## Process each demo without failing
     try
       block = code(idx(doidx(i)):idx(doidx(i)+1)-1);
       ## Use an environment without variables
-      eval (cstrcat ("function __demo__ ()\n", block, "\nendfunction"));
+      eval (["function __demo__()\n" block "\nendfunction"]);
       ## Display the code that will be executed before executing it
       printf ("%s example %d:%s\n\n", name, doidx(i), block);
       __demo__;
     catch
       ## Let the programmer know which demo failed.
       printf ("%s example %d: failed\n%s\n", name, doidx(i), lasterr ());
     end_try_catch
     clear __demo__;
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -182,24 +182,24 @@ function [__order, __test_n, __tnew, __t
   assert (__test_n >= 1);
 
   __torig = __tnew = zeros (size (__test_n));
 
   ## Print and plot the data if no output is requested.
   do_display = (nargout == 0);
 
   if (do_display)
-    disp (cstrcat ("testing ", __f1, "\ninit: ", __init));
+    disp (["testing " __f1 "\ninit: " __init]);
   endif
 
   ## Add semicolon closure to all code fragments in case user has not done so.
-  __init = cstrcat (__init, ";");
-  __f1 = cstrcat (__f1, ";");
+  __init(end+1) = ";";
+  __f1(end+1) = ";";
   if (! isempty (__f2))
-    __f2 = cstrcat (__f2, ";");
+    __f2(end+1) = ";";
   endif
 
   ## Make sure the functions are freshly loaded by evaluating them at
   ## test_n(1); first have to initialize the args though.
   n = 1;
   k = 0;
   eval (__init);
   eval (__f1);
@@ -212,29 +212,29 @@ function [__order, __test_n, __tnew, __t
     n = __test_n(k);
     eval (__init);
 
     if (do_display)
       printf ("n%i = %i  ", k, n);
       fflush (stdout);
     endif
 
-    eval (cstrcat ("__t = time();", __f1, "__v1=ans; __t = time()-__t;"));
+    eval (["__t = time();" __f1 "__v1=ans; __t = time()-__t;"]);
     if (__t < 0.25)
-      eval (cstrcat ("__t2 = time();", __f1, "__t2 = time()-__t2;"));
-      eval (cstrcat ("__t3 = time();", __f1, "__t3 = time()-__t3;"));
+      eval (["__t2 = time();" __f1 "__t2 = time()-__t2;"]);
+      eval (["__t3 = time();" __f1 "__t3 = time()-__t3;"]);
       __t = min ([__t, __t2, __t3]);
     endif
     __tnew(k) = __t;
 
     if (! isempty (__f2))
-      eval (cstrcat ("__t = time();", __f2, "__v2=ans; __t = time()-__t;"));
+      eval (["__t = time();" __f2 "__v2=ans; __t = time()-__t;"]);
       if (__t < 0.25)
-        eval (cstrcat ("__t2 = time();", __f2, "__t2 = time()-__t2;"));
-        eval (cstrcat ("__t3 = time();", __f2, "__t3 = time()-__t3;"));
+        eval (["__t2 = time();" __f2 "__t2 = time()-__t2;"]);
+        eval (["__t3 = time();" __f2 "__t3 = time()-__t3;"]);
         __t = min ([__t, __t2, __t3]);
       endif
       __torig(k) = __t;
       if (! isinf(__tol))
         assert (__v1, __v2, __tol);
       endif
     endif
 
@@ -275,37 +275,35 @@ function [__order, __test_n, __tnew, __t
     endif
   endif
 
   if (do_display && isempty (__f2))
 
     loglog (__test_n, __tnew*1000, "*-g;execution time;");
     xlabel ("test length");
     ylabel ("best execution time (ms)");
-    title ({__f1, cstrcat("init: ", __init)});
+    title ({__f1, ["init: " __init]});
 
   elseif (do_display)
 
     subplot (1, 2, 1);
     semilogx (__test_n, __torig./__tnew,
-              cstrcat ("-*r;", strrep (__f1, ";", "."), " / ",
-                       strrep (__f2, ";", "."), ";"),
-               __test_n, __tnew./__torig,
-              cstrcat ("-*g;", strrep (__f2, ";", "."), " / ",
-                       strrep (__f1, ";", "."), ";"));
+             ["-*r;" strrep(__f1, ";", ".") " / " strrep(__f2, ";", ".") ";"],
+              __test_n, __tnew./__torig,
+             ["-*g;", strrep(__f2, ";", ".") " / " strrep(__f1, ";", ".") ";"]);
     title ("Speedup Ratio");
     xlabel ("test length");
     ylabel ("speedup ratio");
 
     subplot (1, 2, 2);
     loglog (__test_n, __tnew*1000,
-            cstrcat ("*-g;", strrep (__f1, ";", "."), ";"),
+            ["*-g;" strrep(__f1,";",".") ";"],
             __test_n, __torig*1000,
-            cstrcat ("*-r;", strrep (__f2,";","."), ";"));
-    title ({"Execution Times", cstrcat("init: ", __init)});
+            ["*-r;" strrep(__f2,";",".") ";"]);
+    title ({"Execution Times", ["init: " __init]});
     xlabel ("test length");
     ylabel ("best execution time (ms)");
 
     ratio = mean (__torig ./ __tnew);
     printf ("\n\nMean runtime ratio = %.3g for '%s' vs '%s'\n",
             ratio, __f2, __f1);
 
   endif
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -150,20 +150,20 @@ function [__ret1, __ret2, __ret3, __ret4
     return;
   else
     error ("test: unknown flag '%s'", __flag);
   endif
 
   ## Locate the file to test.
   __file = file_in_loadpath (__name, "all");
   if (isempty (__file))
-    __file = file_in_loadpath (cstrcat (__name, ".m"), "all");
+    __file = file_in_loadpath ([__name ".m"], "all");
   endif
   if (isempty (__file))
-    __file = file_in_loadpath (cstrcat (__name, ".cc"), "all");
+    __file = file_in_loadpath ([__name ".cc"], "all");
   endif
   if (iscell (__file))
       ## If repeats, return first in path.
     if (isempty (__file))
       __file = "";
     else
       __file = __file{1};
     endif
@@ -224,17 +224,17 @@ function [__ret1, __ret2, __ret3, __ret4
   endif
 
   ## Chop it up into blocks for evaluation.
   __lineidx = find (__body == "\n");
   __blockidx = __lineidx(find (! isspace (__body(__lineidx+1))))+1;
 
   ## Ready to start tests ... if in batch mode, tell us what is happening.
   if (__verbose)
-    disp (cstrcat (__signal_file, __file));
+    disp ([__signal_file, __file]);
   endif
 
   ## Assume all tests will pass.
   __all_success = 1;
 
   ## Process each block separately, initially with no shared variables.
   __tests = __successes = 0;
   __shared = " ";
@@ -276,17 +276,17 @@ function [__ret1, __ret2, __ret3, __ret4
     if (__grabdemo || __isdemo)
       __istest = 0;
 
       if (__grabdemo && __isdemo)
         if (isempty (__demo_code))
           __demo_code = __code;
           __demo_idx = [1, length(__demo_code)+1];
         else
-          __demo_code = cstrcat (__demo_code, __code);
+          __demo_code = [__demo_code, __code];
           __demo_idx = [__demo_idx, length(__demo_code)+1];
         endif
 
       elseif (__rundemo && __isdemo)
         try
           ## process the code in an environment without variables
           eval (sprintf ("function __test__ ()\n%s\nendfunction", __code));
           __test__;
@@ -321,19 +321,19 @@ function [__ret1, __ret2, __ret3, __ret4
       if (! isempty (__idx))
         __vars = __vars(1:__idx(1)-1);
       endif
 
       ## Assign default values to variables.
       try
         __vars = deblank (__vars);
         if (! isempty (__vars))
-          eval (cstrcat (strrep (__vars, ",", "=[];"), "=[];"));
+          eval ([strrep(__vars, ",", "=[];"), "=[];"]);
           __shared = __vars;
-          __shared_r = cstrcat ("[ ", __vars, "] = ");
+          __shared_r = ["[ ", __vars, "] = "];
         else
           __shared = " ";
           __shared_r = " ";
         endif
       catch
         ## Couldn't declare, so don't initialize.
         __code = "";
         __success = 0;
@@ -681,17 +681,17 @@ function body = __extract_test_code (nm)
   fid = fopen (nm, "rt");
   body = [];
   if (fid >= 0)
     while (! feof (fid))
       ln = fgetl (fid);
       if (length (ln) >= 2 && strcmp (ln(1:2), "%!"))
         body = [body, "\n"];
         if (length (ln) > 2)
-          body = cstrcat (body, ln(3:end));
+          body = [body, ln(3:end)];
         endif
       endif
     endwhile
     fclose (fid);
   endif
 endfunction
 
 
diff --git a/test/eval-catch.tst b/test/eval-catch.tst
--- a/test/eval-catch.tst
+++ b/test/eval-catch.tst
@@ -33,17 +33,17 @@
 
 %!test
 %! eval ("error ('user-defined error'); str = '';", "str = lasterr;");
 %! assert (lasterr()(1:18), "user-defined error");
 %! assert (str(1:18), "user-defined error");
 
 %!function ms = mangle (s)
 %!  ## Wrap angle brackets around S.
-%!  ms = cstrcat ("<", s, ">");
+%!  ms = ["<" s ">"];
 %!endfunction
 %!test
 %! eval ("clear a; a; str='';", "str = mangle (lasterr);");
 %! assert (mangle (lasterr)(1:14), "<'a' undefined");
 %! assert (str(1:14), "<'a' undefined");
 
 %!test
 %! eval ("eval (\"clear a; a;str1='';\", \"str1=lasterr;\"); clear b; b; str2='';",
diff --git a/test/io.tst b/test/io.tst
--- a/test/io.tst
+++ b/test/io.tst
@@ -340,26 +340,26 @@
 %!       [id, err] = fopen (nm, mode, arch);
 %!       if (id < 0)
 %!         __printf_assert__ ("open failed: %s (%s, %s): %s\n", nm, mode, arch, err);
 %!         status = 0;
 %!         break;
 %!       else
 %!         fclose (id);
 %!       endif
-%!       tmp_mode = cstrcat (mode, "b");
+%!       tmp_mode = [mode, "b"];
 %!       [id, err] = fopen (nm, tmp_mode, arch);
 %!       if (id < 0)
 %!         __printf_assert__ ("open failed: %s (%s, %s): %s\n", nm, tmp_mode, arch, err);
 %!         status = 0;
 %!         break;
 %!       else
 %!         fclose (id);
 %!       endif
-%!       tmp_mode = cstrcat (mode, "t");
+%!       tmp_mode = [mode, "t"];
 %!       [id, err] = fopen (nm, tmp_mode, arch);
 %!       if (id < 0)
 %!         __printf_assert__ ("open failed: %s (%s, %s): %s\n", nm, tmp_mode, arch, err);
 %!         status = 0;
 %!         break;
 %!       else
 %!         fclose (id);
 %!       endif
diff --git a/test/try.tst b/test/try.tst
--- a/test/try.tst
+++ b/test/try.tst
@@ -66,17 +66,17 @@
 %! try
 %!   error ("user-defined error");
 %! catch
 %!   assert (lasterr, "user-defined error");
 %! end_try_catch
 
 %!function ms = mangle (s)
 %!  ## Wrap angle brackets around S.
-%!  ms = cstrcat ("<", s, ">");
+%!  ms = ["<" s ">"];
 %!endfunction
 %!test
 %! try
 %!   clear a;
 %!   a;
 %!   error ("Shoudn't get here");
 %! catch
 %!   assert (mangle (lasterr)(1:14), "<'a' undefined");
@@ -116,14 +116,14 @@
 
 %!test
 %! try
 %!   try
 %!     clear a;
 %!     a;
 %!     error ("Shoudn't get here");
 %!   catch
-%!     error (cstrcat ("rethrow: ", lasterr));
+%!     error (["rethrow: " lasterr]);
 %!   end_try_catch
 %! catch
 %!   assert (lasterr()(1:22), "rethrow: 'a' undefined");
 %! end_try_catch
 
