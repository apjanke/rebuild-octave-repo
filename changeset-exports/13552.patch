# HG changeset patch
# User Jacob Dawid <jacob.dawid@googlemail.com>
# Date 1311958415 -7200
#      Fri Jul 29 18:53:35 2011 +0200
# Node ID 324adf6109e73cde58de09267a9d000d7e3ee89f
# Parent  ad905cd33563ba2c473e6895ec96fa46bb417a7b
Isolated and eliminated class ProcessInfo.

diff --git a/gui/octave-gui.pro b/gui/octave-gui.pro
--- a/gui/octave-gui.pro
+++ b/gui/octave-gui.pro
@@ -66,17 +66,16 @@ SOURCES +=\
         src/terminal/kpty.cpp \
         src/terminal/kptyprocess.cpp \
         src/terminal/kprocess.cpp \
         src/terminal/kptydevice.cpp \
         src/terminal/Session.cpp \
         src/terminal/ShellCommand.cpp \
         src/terminal/QTerminalWidget.cpp \
         src/MainWindow.cpp \
-        src/terminal/ProcessInfo.cpp \
     	  src/OctaveTerminal.cpp \
     	  src/VariablesDockWidget.cpp \
     	  src/HistoryDockWidget.cpp \
     	  src/FilesDockWidget.cpp \
     	  src/FileEditorMdiSubWindow.cpp \
     	  src/BrowserWidget.cpp \
     	  src/ImageViewerMdiSubWindow.cpp \
     src/IRCWidget.cpp \
@@ -112,17 +111,16 @@ HEADERS += \
         src/terminal/kptyprocess.h \
         src/terminal/kprocess.h \
         src/terminal/kprocess_p.h \
         src/terminal/kptydevice.h \
         src/terminal/Session.h \
         src/terminal/ShellCommand.h \
         src/terminal/QTerminalWidget.h \
     	  src/MainWindow.h \
-        src/terminal/ProcessInfo.h \
     	  src/OctaveTerminal.h \
     	  src/VariablesDockWidget.h \
     	  src/HistoryDockWidget.h \
     	  src/FilesDockWidget.h \
     	  src/FileEditorMdiSubWindow.h \
     	  src/BrowserWidget.h \
     	  src/ImageViewerMdiSubWindow.h \
     src/IRCWidget.h \
diff --git a/gui/src/backend/OctaveMainThread.cpp b/gui/src/backend/OctaveMainThread.cpp
--- a/gui/src/backend/OctaveMainThread.cpp
+++ b/gui/src/backend/OctaveMainThread.cpp
@@ -22,14 +22,14 @@
 OctaveMainThread::OctaveMainThread (QObject * parent):QThread (parent)
 {
 }
 
 void
 OctaveMainThread::run ()
 {
   int argc = 3;
-  const char *argv[] = { "octave", "--interactive", "--line-editing" };
+  const char *argv[] = { "OctaveGUI", "--interactive", "--line-editing" };
   octave_main (argc, (char **) argv, 1);
   emit ready();
   main_loop ();
   clean_up_and_exit (0);
 }
diff --git a/gui/src/terminal/ProcessInfo.cpp b/gui/src/terminal/ProcessInfo.cpp
deleted file mode 100644
--- a/gui/src/terminal/ProcessInfo.cpp
+++ /dev/null
@@ -1,1130 +0,0 @@
-/*
-    Copyright 2007-2008 by Robert Knight <robertknight@gmail.countm>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA.
-*/
-
-// Own
-#include "ProcessInfo.h"
-
-// Unix
-#include <sys/socket.h>
-#include <netinet/in.h>
-#include <arpa/inet.h>
-#include <unistd.h>
-#include <pwd.h>
-
-// Qt
-#include <QtCore/QDir>
-#include <QtCore/QFileInfo>
-#include <QtCore/QRegExp>
-#include <QtCore/QTextStream>
-#include <QtCore/QStringList>
-#include <QtCore/QSet>
-
-// KDE
-#include "konsole_export.h"
-
-#if defined(Q_OS_MAC)
-#include <sys/sysctl.h>
-#include <libproc.h>
-#ifdef HAVE_SYS_PROC_INFO_H
-#include <sys/proc_info.h>
-#endif
-#ifdef HAVE_SYS_PROC_H
-#include <sys/proc.h>
-#endif
-//#include <kde_file.h>
-#define KDE_struct_stat struct stat
-#define KDE_stat ::stat
-#endif
-
-#if defined(Q_OS_FREEBSD)
-#include <sys/sysctl.h>		//krazy:exclude=includes
-#include <sys/types.h>
-#include <sys/user.h>
-#include <sys/syslimits.h>
-#include <libutil.h>
-#endif
-
-ProcessInfo::ProcessInfo (int pid, bool enableEnvironmentRead):
-_fields (ARGUMENTS | ENVIRONMENT)	// arguments and environments
-					 // are currently always valid,
-					 // they just return an empty
-					 // vector / map respectively
-					 // if no arguments
-					 // or environment bindings
-					 // have been explicitly set
-,
-_enableEnvironmentRead (enableEnvironmentRead),
-_pid (pid),
-_parentPid (0),
-_foregroundPid (0),
-_userId (0),
-_lastError (NoError),
-_userName (QString ()),
-_userHomeDir (QString ())
-{
-}
-
-ProcessInfo::Error ProcessInfo::error () const
-{
-  return _lastError;
-}
-
-void
-ProcessInfo::setError (Error error)
-{
-  _lastError = error;
-}
-
-void
-ProcessInfo::update ()
-{
-  readProcessInfo (_pid, _enableEnvironmentRead);
-}
-
-QString
-ProcessInfo::validCurrentDir () const
-{
-  bool ok = false;
-
-  // read current dir, if an error occurs try the parent as the next
-  // best option
-  int currentPid = parentPid (&ok);
-  QString dir = currentDir (&ok);
-  while (!ok && currentPid != 0)
-    {
-      ProcessInfo *current = ProcessInfo::newInstance (currentPid);
-      current->update ();
-      currentPid = current->parentPid (&ok);
-      dir = current->currentDir (&ok);
-      delete current;
-    }
-
-  return dir;
-}
-
-QString
-ProcessInfo::format (const QString & input) const
-{
-  bool ok = false;
-
-  QString output (input);
-
-  // search for and replace known marker
-  output.replace ("%u", userName ());
-  output.replace ("%n", name (&ok));
-  output.replace ("%c",
-		  formatCommand (name (&ok), arguments (&ok),
-				 ShortCommandFormat));
-  output.replace ("%C",
-		  formatCommand (name (&ok), arguments (&ok),
-				 LongCommandFormat));
-
-  QString dir = validCurrentDir ();
-  if (output.contains ("%D"))
-    {
-      QString homeDir = userHomeDir ();
-      QString tempDir = dir;
-      // Change User's Home Dir w/ ~ only at the beginning
-      if (tempDir.startsWith (homeDir))
-	{
-	  tempDir.remove (0, homeDir.length ());
-	  tempDir.prepend ('~');
-	}
-      output.replace ("%D", tempDir);
-    }
-  output.replace ("%d", dir);
-
-  // remove any remaining %[LETTER] sequences
-  // output.replace(QRegExp("%\\w"), QString());
-
-  return output;
-}
-
-QString
-ProcessInfo::formatCommand (const QString & name,
-			    const QVector < QString > &arguments,
-			    CommandFormat format) const
-{
-  Q_UNUSED (name);
-  Q_UNUSED (format);
-
-  // TODO Implement me
-  return QStringList (QList < QString >::fromVector (arguments)).join (" ");
-}
-
-QVector < QString > ProcessInfo::arguments (bool * ok) const
-{
-  *ok = _fields & ARGUMENTS;
-
-  return _arguments;
-}
-
-QMap < QString, QString > ProcessInfo::environment (bool * ok) const
-{
-  *ok = _fields & ENVIRONMENT;
-
-  return _environment;
-}
-
-bool
-ProcessInfo::isValid () const
-{
-  return _fields & PROCESS_ID;
-}
-
-int
-ProcessInfo::pid (bool * ok) const
-{
-  *ok = _fields & PROCESS_ID;
-
-  return _pid;
-}
-
-int
-ProcessInfo::parentPid (bool * ok) const
-{
-  *ok = _fields & PARENT_PID;
-
-  return _parentPid;
-}
-
-int
-ProcessInfo::foregroundPid (bool * ok) const
-{
-  *ok = _fields & FOREGROUND_PID;
-
-  return _foregroundPid;
-}
-
-QString
-ProcessInfo::name (bool * ok) const
-{
-  *ok = _fields & NAME;
-
-  return _name;
-}
-
-int
-ProcessInfo::userId (bool * ok) const
-{
-  *ok = _fields & UID;
-
-  return _userId;
-}
-
-QString
-ProcessInfo::userName () const
-{
-  return _userName;
-}
-
-QString
-ProcessInfo::userHomeDir () const
-{
-  return _userHomeDir;
-}
-
-void
-ProcessInfo::setPid (int pid)
-{
-  _pid = pid;
-  _fields |= PROCESS_ID;
-}
-
-void
-ProcessInfo::setUserId (int uid)
-{
-  _userId = uid;
-  _fields |= UID;
-}
-
-void
-ProcessInfo::setUserName (const QString & name)
-{
-  _userName = name;
-  setUserHomeDir ();
-}
-
-void
-ProcessInfo::setUserHomeDir ()
-{
-  QString usersName = userName ();
-  // JPS: I don't know a good QT replacement
-  //if (!usersName.isEmpty())
-  //    _userHomeDir = KUser(usersName).homeDir();
-  //else
-  _userHomeDir = QDir::homePath ();
-}
-
-void
-ProcessInfo::setParentPid (int pid)
-{
-  _parentPid = pid;
-  _fields |= PARENT_PID;
-}
-
-void
-ProcessInfo::setForegroundPid (int pid)
-{
-  _foregroundPid = pid;
-  _fields |= FOREGROUND_PID;
-}
-
-QString
-ProcessInfo::currentDir (bool * ok) const
-{
-  if (ok)
-    *ok = _fields & CURRENT_DIR;
-
-  return _currentDir;
-}
-
-void
-ProcessInfo::setCurrentDir (const QString & dir)
-{
-  _fields |= CURRENT_DIR;
-  _currentDir = dir;
-}
-
-void
-ProcessInfo::setName (const QString & name)
-{
-  _name = name;
-  _fields |= NAME;
-}
-
-void
-ProcessInfo::addArgument (const QString & argument)
-{
-  _arguments << argument;
-}
-
-void
-ProcessInfo::addEnvironmentBinding (const QString & name,
-				    const QString & value)
-{
-  _environment.insert (name, value);
-}
-
-void
-ProcessInfo::setFileError (QFile::FileError error)
-{
-  switch (error)
-    {
-    case PermissionsError:
-      setError (PermissionsError);
-      break;
-    case NoError:
-      setError (NoError);
-      break;
-    default:
-      setError (UnknownError);
-    }
-}
-
-//
-// ProcessInfo::newInstance() is way at the bottom so it can see all of the
-// implementations of the UnixProcessInfo abstract class.
-//
-
-NullProcessInfo::NullProcessInfo (int pid, bool enableEnvironmentRead):
-ProcessInfo (pid, enableEnvironmentRead)
-{
-}
-
-bool
-NullProcessInfo::readProcessInfo (int /*pid */ ,
-				  bool /*enableEnvironmentRead */ )
-{
-  return false;
-}
-
-void
-NullProcessInfo::readUserName ()
-{
-}
-
-UnixProcessInfo::UnixProcessInfo (int pid, bool enableEnvironmentRead):
-ProcessInfo (pid, enableEnvironmentRead)
-{
-}
-
-bool
-UnixProcessInfo::readProcessInfo (int pid, bool enableEnvironmentRead)
-{
-  bool ok = readProcInfo (pid);
-  if (ok)
-    {
-      ok |= readArguments (pid);
-      ok |= readCurrentDir (pid);
-      if (enableEnvironmentRead)
-	{
-	  ok |= readEnvironment (pid);
-	}
-    }
-  return ok;
-}
-
-void
-UnixProcessInfo::readUserName ()
-{
-  bool ok = false;
-  int uid = userId (&ok);
-  if (!ok)
-    return;
-
-  struct passwd passwdStruct;
-  struct passwd *getpwResult;
-  char *getpwBuffer;
-  long getpwBufferSize;
-  int getpwStatus;
-
-  getpwBufferSize = sysconf (_SC_GETPW_R_SIZE_MAX);
-  if (getpwBufferSize == -1)
-    getpwBufferSize = 16384;
-
-  getpwBuffer = new char[getpwBufferSize];
-  if (getpwBuffer == NULL)
-    return;
-  getpwStatus =
-    getpwuid_r (uid, &passwdStruct, getpwBuffer, getpwBufferSize,
-		&getpwResult);
-  if (getpwResult != NULL)
-    setUserName (QString (passwdStruct.pw_name));
-  else
-    setUserName (QString ());
-  delete[]getpwBuffer;
-}
-
-
-class LinuxProcessInfo:public UnixProcessInfo
-{
-public:
-  LinuxProcessInfo (int pid, bool env):UnixProcessInfo (pid, env)
-  {
-  }
-
-private:
-    virtual bool readProcInfo (int pid)
-  {
-    // indicies of various fields within the process status file which
-    // contain various information about the process
-    const int PARENT_PID_FIELD = 3;
-    const int PROCESS_NAME_FIELD = 1;
-    const int GROUP_PROCESS_FIELD = 7;
-
-    QString parentPidString;
-    QString processNameString;
-    QString foregroundPidString;
-    QString uidLine;
-    QString uidString;
-    QStringList uidStrings;
-
-    // For user id read process status file ( /proc/<pid>/status )
-    //  Can not use getuid() due to it does not work for 'su'
-    QFile statusInfo (QString ("/proc/%1/status").arg (pid));
-    if (statusInfo.open (QIODevice::ReadOnly))
-      {
-	QTextStream stream (&statusInfo);
-	QString statusLine;
-	do
-	  {
-	    statusLine = stream.readLine (0);
-	    if (statusLine.startsWith (QLatin1String ("Uid:")))
-	      uidLine = statusLine;
-	  }
-	while (!statusLine.isNull () && uidLine.isNull ());
-
-	uidStrings << uidLine.split ('\t', QString::SkipEmptyParts);
-	// Must be 5 entries: 'Uid: %d %d %d %d' and
-	// uid string must be less than 5 chars (uint)
-	if (uidStrings.size () == 5)
-	  uidString = uidStrings[1];
-	if (uidString.size () > 5)
-	  uidString.clear ();
-
-	bool ok = false;
-	int uid = uidString.toInt (&ok);
-	if (ok)
-	  setUserId (uid);
-	readUserName ();
-      }
-    else
-      {
-	setFileError (statusInfo.error ());
-	return false;
-      }
-
-
-    // read process status file ( /proc/<pid/stat )
-    //
-    // the expected file format is a list of fields separated by spaces, using
-    // parenthesies to escape fields such as the process name which may itself contain
-    // spaces:
-    //
-    // FIELD FIELD (FIELD WITH SPACES) FIELD FIELD
-    //
-    QFile processInfo (QString ("/proc/%1/stat").arg (pid));
-    if (processInfo.open (QIODevice::ReadOnly))
-      {
-	QTextStream stream (&processInfo);
-	QString data = stream.readAll ();
-
-	int stack = 0;
-	int field = 0;
-	int pos = 0;
-
-	while (pos < data.count ())
-	  {
-	    QChar c = data[pos];
-
-	    if (c == '(')
-	      stack++;
-	    else if (c == ')')
-	      stack--;
-	    else if (stack == 0 && c == ' ')
-	      field++;
-	    else
-	      {
-		switch (field)
-		  {
-		  case PARENT_PID_FIELD:
-		    parentPidString.append (c);
-		    break;
-		  case PROCESS_NAME_FIELD:
-		    processNameString.append (c);
-		    break;
-		  case GROUP_PROCESS_FIELD:
-		    foregroundPidString.append (c);
-		    break;
-		  }
-	      }
-
-	    pos++;
-	  }
-      }
-    else
-      {
-	setFileError (processInfo.error ());
-	return false;
-      }
-
-    // check that data was read successfully
-    bool ok = false;
-    int foregroundPid = foregroundPidString.toInt (&ok);
-    if (ok)
-      setForegroundPid (foregroundPid);
-
-    int parentPid = parentPidString.toInt (&ok);
-    if (ok)
-      setParentPid (parentPid);
-
-    if (!processNameString.isEmpty ())
-      setName (processNameString);
-
-    // update object state
-    setPid (pid);
-
-    return ok;
-  }
-
-  virtual bool readArguments (int pid)
-  {
-    // read command-line arguments file found at /proc/<pid>/cmdline
-    // the expected format is a list of strings delimited by null characters,
-    // and ending in a double null character pair.
-
-    QFile argumentsFile (QString ("/proc/%1/cmdline").arg (pid));
-    if (argumentsFile.open (QIODevice::ReadOnly))
-      {
-	QTextStream stream (&argumentsFile);
-	QString data = stream.readAll ();
-
-	QStringList argList = data.split (QChar ('\0'));
-
-	foreach (const QString & entry, argList)
-	{
-	  if (!entry.isEmpty ())
-	    addArgument (entry);
-	}
-      }
-    else
-      {
-	setFileError (argumentsFile.error ());
-      }
-
-    return true;
-  }
-
-  virtual bool readCurrentDir (int pid)
-  {
-    QFileInfo info (QString ("/proc/%1/cwd").arg (pid));
-
-    const bool readable = info.isReadable ();
-
-    if (readable && info.isSymLink ())
-      {
-	setCurrentDir (info.symLinkTarget ());
-	return true;
-      }
-    else
-      {
-	if (!readable)
-	  setError (PermissionsError);
-	else
-	  setError (UnknownError);
-
-	return false;
-      }
-  }
-
-  virtual bool readEnvironment (int pid)
-  {
-    // read environment bindings file found at /proc/<pid>/environ
-    // the expected format is a list of KEY=VALUE strings delimited by null
-    // characters and ending in a double null character pair.
-
-    QFile environmentFile (QString ("/proc/%1/environ").arg (pid));
-    if (environmentFile.open (QIODevice::ReadOnly))
-      {
-	QTextStream stream (&environmentFile);
-	QString data = stream.readAll ();
-
-	QStringList bindingList = data.split (QChar ('\0'));
-
-	foreach (const QString & entry, bindingList)
-	{
-	  QString name;
-	  QString value;
-
-	  int splitPos = entry.indexOf ('=');
-
-	  if (splitPos != -1)
-	    {
-	      name = entry.mid (0, splitPos);
-	      value = entry.mid (splitPos + 1, -1);
-
-	      addEnvironmentBinding (name, value);
-	    }
-	}
-      }
-    else
-      {
-	setFileError (environmentFile.error ());
-      }
-
-    return true;
-  }
-};
-
-#if defined(Q_OS_FREEBSD)
-class FreeBSDProcessInfo:public UnixProcessInfo
-{
-public:
-  FreeBSDProcessInfo (int pid, bool readEnvironment):UnixProcessInfo (pid,
-								      readEnvironment)
-  {
-  }
-
-private:
-    virtual bool readProcInfo (int pid)
-  {
-    int managementInfoBase[4];
-    size_t mibLength;
-    struct kinfo_proc *kInfoProc;
-
-    managementInfoBase[0] = CTL_KERN;
-    managementInfoBase[1] = KERN_PROC;
-    managementInfoBase[2] = KERN_PROC_PID;
-    managementInfoBase[3] = pid;
-
-    if (sysctl (managementInfoBase, 4, NULL, &mibLength, NULL, 0) == -1)
-      return false;
-
-    kInfoProc = new struct kinfo_proc[mibLength];
-
-    if (sysctl (managementInfoBase, 4, kInfoProc, &mibLength, NULL, 0) == -1)
-      {
-	delete[]kInfoProc;
-	return false;
-      }
-
-#if defined(__DragonFly__)
-    setName (kInfoProc->kp_comm);
-    setPid (kInfoProc->kp_pid);
-    setParentPid (kInfoProc->kp_ppid);
-    setForegroundPid (kInfoProc->kp_pgid);
-    setUserId (kInfoProc->kp_uid);
-#else
-    setName (kInfoProc->ki_comm);
-    setPid (kInfoProc->ki_pid);
-    setParentPid (kInfoProc->ki_ppid);
-    setForegroundPid (kInfoProc->ki_pgid);
-    setUserId (kInfoProc->ki_uid);
-#endif
-
-    readUserName ();
-
-    delete[]kInfoProc;
-    return true;
-  }
-
-  virtual bool readArguments (int pid)
-  {
-    char args[ARG_MAX];
-    int managementInfoBase[4];
-    size_t len;
-
-    managementInfoBase[0] = CTL_KERN;
-    managementInfoBase[1] = KERN_PROC;
-    managementInfoBase[2] = KERN_PROC_PID;
-    managementInfoBase[3] = pid;
-
-    len = sizeof (args);
-    if (sysctl (managementInfoBase, 4, args, &len, NULL, 0) == -1)
-      return false;
-
-    const QStringList argumentList = QString (args).split (QChar ('\0'));
-
-    for (QStringList::const_iterator it = argumentList.begin ();
-	 it != argumentList.end (); ++it)
-      {
-	addArgument (*it);
-      }
-
-    return true;
-  }
-
-  virtual bool readEnvironment (int pid)
-  {
-    // Not supported in FreeBSD?
-    return false;
-  }
-
-  virtual bool readCurrentDir (int pid)
-  {
-#if defined(__DragonFly__)
-    char buf[PATH_MAX];
-    int managementInfoBase[4];
-    size_t len;
-
-    managementInfoBase[0] = CTL_KERN;
-    managementInfoBase[1] = KERN_PROC;
-    managementInfoBase[2] = KERN_PROC_CWD;
-    managementInfoBase[3] = pid;
-
-    len = sizeof (buf);
-    if (sysctl (managementInfoBase, 4, buf, &len, NULL, 0) == -1)
-      return false;
-
-    setCurrentDir (buf);
-
-    return true;
-#else
-    int numrecords;
-    struct kinfo_file *info = 0;
-
-    info = kinfo_getfile (pid, &numrecords);
-
-    if (!info)
-      return false;
-
-    for (int i = 0; i < numrecords; ++i)
-      {
-	if (info[i].kf_fd == KF_FD_TYPE_CWD)
-	  {
-	    setCurrentDir (info[i].kf_path);
-
-	    free (info);
-	    return true;
-	  }
-      }
-
-    free (info);
-    return false;
-#endif
-  }
-};
-#endif
-
-#if defined(Q_OS_MAC)
-class MacProcessInfo:public UnixProcessInfo
-{
-public:
-  MacProcessInfo (int pid, bool env):UnixProcessInfo (pid, env)
-  {
-  }
-
-private:
-    virtual bool readProcInfo (int pid)
-  {
-    int managementInfoBase[4];
-    size_t mibLength;
-    struct kinfo_proc *kInfoProc;
-    KDE_struct_stat statInfo;
-
-    // Find the tty device of 'pid' (Example: /dev/ttys001)
-    managementInfoBase[0] = CTL_KERN;
-    managementInfoBase[1] = KERN_PROC;
-    managementInfoBase[2] = KERN_PROC_PID;
-    managementInfoBase[3] = pid;
-
-    if (sysctl (managementInfoBase, 4, NULL, &mibLength, NULL, 0) == -1)
-      {
-	return false;
-      }
-    else
-      {
-	kInfoProc = new struct kinfo_proc[mibLength];
-	if (sysctl (managementInfoBase, 4, kInfoProc, &mibLength, NULL, 0) ==
-	    -1)
-	  {
-	    delete[]kInfoProc;
-	    return false;
-	  }
-	else
-	  {
-	    QString deviceNumber =
-	      QString (devname (((&kInfoProc->kp_eproc)->e_tdev), S_IFCHR));
-	    QString fullDeviceName =
-	      QString ("/dev/") + deviceNumber.rightJustified (3, '0');
-	    delete[]kInfoProc;
-
-	    QByteArray deviceName = fullDeviceName.toLatin1 ();
-	    const char *ttyName = deviceName.data ();
-
-	    if (KDE_stat (ttyName, &statInfo) != 0)
-	      return false;
-
-	    // Find all processes attached to ttyName
-	    managementInfoBase[0] = CTL_KERN;
-	    managementInfoBase[1] = KERN_PROC;
-	    managementInfoBase[2] = KERN_PROC_TTY;
-	    managementInfoBase[3] = statInfo.st_rdev;
-
-	    mibLength = 0;
-	    if (sysctl
-		(managementInfoBase,
-		 sizeof (managementInfoBase) / sizeof (int), NULL, &mibLength,
-		 NULL, 0) == -1)
-	      return false;
-
-	    kInfoProc = new struct kinfo_proc[mibLength];
-	    if (sysctl
-		(managementInfoBase,
-		 sizeof (managementInfoBase) / sizeof (int), kInfoProc,
-		 &mibLength, NULL, 0) == -1)
-	      return false;
-
-	    // The foreground program is the first one
-	    setName (QString (kInfoProc->kp_proc.p_comm));
-
-	    delete[]kInfoProc;
-	  }
-      }
-    return true;
-  }
-
-  virtual bool readArguments (int pid)
-  {
-    Q_UNUSED (pid);
-    return false;
-  }
-  virtual bool readCurrentDir (int pid)
-  {
-    struct proc_vnodepathinfo vpi;
-    int nb = proc_pidinfo (pid, PROC_PIDVNODEPATHINFO, 0, &vpi, sizeof (vpi));
-    if (nb == sizeof (vpi))
-      {
-	setCurrentDir (QString (vpi.pvi_cdir.vip_path));
-	return true;
-      }
-    return false;
-  }
-  virtual bool readEnvironment (int pid)
-  {
-    Q_UNUSED (pid);
-    return false;
-  }
-};
-#endif
-
-#ifdef Q_OS_SOLARIS
-    // The procfs structure definition requires off_t to be
-    // 32 bits, which only applies if FILE_OFFSET_BITS=32.
-    // Futz around here to get it to compile regardless,
-    // although some of the structure sizes might be wrong.
-    // Fortunately, the structures we actually use don't use
-    // off_t, and we're safe.
-#if defined(_FILE_OFFSET_BITS) && (_FILE_OFFSET_BITS==64)
-#undef _FILE_OFFSET_BITS
-#endif
-#include <procfs.h>
-#else
-    // On non-Solaris platforms, define a fake psinfo structure
-    // so that the SolarisProcessInfo class can be compiled
-    //
-    // That avoids the trap where you change the API and
-    // don't notice it in #ifdeffed platform-specific parts
-    // of the code.
-struct psinfo
-{
-  int pr_ppid;
-  int pr_pgid;
-  char *pr_fname;
-  char *pr_psargs;
-};
-static const int PRARGSZ = 1;
-#endif
-
-class SolarisProcessInfo:public UnixProcessInfo
-{
-public:
-  SolarisProcessInfo (int pid, bool readEnvironment):UnixProcessInfo (pid,
-								      readEnvironment)
-  {
-  }
-private:
-    virtual bool readProcInfo (int pid)
-  {
-    QFile psinfo (QString ("/proc/%1/psinfo").arg (pid));
-    if (psinfo.open (QIODevice::ReadOnly))
-      {
-	struct psinfo info;
-	if (psinfo.read ((char *) &info, sizeof (info)) != sizeof (info))
-	  {
-	    return false;
-	  }
-
-	setParentPid (info.pr_ppid);
-	setForegroundPid (info.pr_pgid);
-	setName (info.pr_fname);
-	setPid (pid);
-
-	// Bogus, because we're treating the arguments as one single string
-	info.pr_psargs[PRARGSZ - 1] = 0;
-	addArgument (info.pr_psargs);
-      }
-    return true;
-  }
-
-  virtual bool readArguments (int /*pid */ )
-  {
-    // Handled in readProcInfo()
-    return false;
-  }
-
-  virtual bool readEnvironment (int /*pid */ )
-  {
-    // Not supported in Solaris
-    return false;
-  }
-
-  virtual bool readCurrentDir (int pid)
-  {
-    QFileInfo info (QString ("/proc/%1/path/cwd").arg (pid));
-    const bool readable = info.isReadable ();
-
-    if (readable && info.isSymLink ())
-      {
-	setCurrentDir (info.symLinkTarget ());
-	return true;
-      }
-    else
-      {
-	if (!readable)
-	  setError (PermissionsError);
-	else
-	  setError (UnknownError);
-
-	return false;
-      }
-  }
-};
-
-SSHProcessInfo::SSHProcessInfo (const ProcessInfo & process):_process (process)
-{
-  bool
-    ok = false;
-
-  // check that this is a SSH process
-  const
-    QString &
-    name = _process.name (&ok);
-
-  if (!ok || name != "ssh")
-    {
-      //if ( !ok )
-      //    kWarning() << "Could not read process info";
-      //else
-      //    kWarning() << "Process is not a SSH process";
-
-      return;
-    }
-
-  // read arguments
-  const
-    QVector <
-  QString > &
-    args = _process.arguments (&ok);
-
-  // SSH options
-  // these are taken from the SSH manual ( accessed via 'man ssh' )
-
-  // options which take no arguments
-  static const QString
-  noOptionsArguments ("1246AaCfgkMNnqsTtVvXxY");
-  // options which take one argument
-  static const QString
-  singleOptionArguments ("bcDeFiLlmOopRSw");
-
-  if (ok)
-    {
-      // find the username, host and command arguments
-      //
-      // the username/host is assumed to be the first argument 
-      // which is not an option
-      // ( ie. does not start with a dash '-' character )
-      // or an argument to a previous option.
-      //
-      // the command, if specified, is assumed to be the argument following
-      // the username and host
-      //
-      // note that we skip the argument at index 0 because that is the
-      // program name ( expected to be 'ssh' in this case )
-      for (int i = 1; i < args.count (); i++)
-	{
-	  // if this argument is an option then skip it, plus any 
-	  // following arguments which refer to this option
-	  if (args[i].startsWith ('-'))
-	    {
-	      QChar
-		argChar = (args[i].length () > 1) ? args[i][1] : '\0';
-
-	      if (noOptionsArguments.contains (argChar))
-		continue;
-	      else if (singleOptionArguments.contains (argChar))
-		{
-		  i++;
-		  continue;
-		}
-	    }
-
-	  // check whether the host has been found yet
-	  // if not, this must be the username/host argument 
-	  if (_host.isEmpty ())
-	    {
-	      // check to see if only a hostname is specified, or whether
-	      // both a username and host are specified ( in which case they
-	      // are separated by an '@' character:  username@host )
-
-	      int
-		separatorPosition = args[i].indexOf ('@');
-	      if (separatorPosition != -1)
-		{
-		  // username and host specified
-		  _user = args[i].left (separatorPosition);
-		  _host = args[i].mid (separatorPosition + 1);
-		}
-	      else
-		{
-		  // just the host specified
-		  _host = args[i];
-		}
-	    }
-	  else
-	    {
-	      // host has already been found, this must be the command argument
-	      _command = args[i];
-	    }
-
-	}
-    }
-  else
-    {
-      //kWarning() << "Could not read arguments";
-
-      return;
-    }
-}
-
-QString
-SSHProcessInfo::userName () const
-{
-  return _user;
-}
-
-QString
-SSHProcessInfo::host () const
-{
-  return _host;
-}
-
-QString
-SSHProcessInfo::command () const
-{
-  return _command;
-}
-
-QString
-SSHProcessInfo::format (const QString & input) const
-{
-  QString output (input);
-
-  // test whether host is an ip address
-  // in which case 'short host' and 'full host'
-  // markers in the input string are replaced with
-  // the full address
-  bool isIpAddress = false;
-
-  struct in_addr address;
-  if (inet_aton (_host.toLocal8Bit ().constData (), &address) != 0)
-    isIpAddress = true;
-  else
-    isIpAddress = false;
-
-  // search for and replace known markers
-  output.replace ("%u", _user);
-
-  if (isIpAddress)
-    output.replace ("%h", _host);
-  else
-    output.replace ("%h", _host.left (_host.indexOf ('.')));
-
-  output.replace ("%H", _host);
-  output.replace ("%c", _command);
-
-  return output;
-}
-
-ProcessInfo *
-ProcessInfo::newInstance (int pid, bool enableEnvironmentRead)
-{
-#ifdef Q_OS_LINUX
-  return new LinuxProcessInfo (pid, enableEnvironmentRead);
-#elif defined(Q_OS_SOLARIS)
-  return new SolarisProcessInfo (pid, enableEnvironmentRead);
-#elif defined(Q_OS_MAC)
-  return new MacProcessInfo (pid, enableEnvironmentRead);
-#elif defined(Q_OS_FREEBSD)
-  return new FreeBSDProcessInfo (pid, enableEnvironmentRead);
-#else
-  return new NullProcessInfo (pid, enableEnvironmentRead);
-#endif
-}
diff --git a/gui/src/terminal/ProcessInfo.h b/gui/src/terminal/ProcessInfo.h
deleted file mode 100644
--- a/gui/src/terminal/ProcessInfo.h
+++ /dev/null
@@ -1,457 +0,0 @@
-/*
-    Copyright 2007-2008 by Robert Knight <robertknight@gmail.com>
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-    02110-1301  USA.
-*/
-
-#ifndef PROCESSINFO_H
-#define PROCESSINFO_H
-
-// Qt
-#include <QtCore/QFile>
-#include <QtCore/QMap>
-#include <QtCore/QString>
-#include <QtCore/QVector>
-
-/**
- * Takes a snapshot of the state of a process and provides access to 
- * information such as the process name, parent process,
- * the foreground process in the controlling terminal,
- * the arguments with which the process was started and the 
- * environment.
- *
- * To create a new snapshot, construct a new ProcessInfo instance,
- * using ProcessInfo::newInstance(),
- * passing the process identifier of the process you are interested in.
- *
- * After creating a new instance, call the update() method to take a 
- * snapshot of the current state of the process.
- *
- * Before calling any additional methods, check that the process state
- * was read successfully using the isValid() method.
- *
- * Each accessor method which provides information about the process state ( such as pid(), 
- * currentDir(), name() ) takes a pointer to a boolean as an argument.  If the information
- * requested was read successfully then the boolean is set to true, otherwise it is set
- * to false, in which case the return value from the function should be ignored.
- * If this boolean is set to false, it may indicate an error reading the process information,
- * or it may indicate that the information is not available on the current platform. 
- *
- * eg.
- *
- * @code
- *   ProcessInfo* info = ProcessInfo::newInstance(pid);
- *   info->update();
- *
- *   if ( info->isValid() )
- *   {
- *      bool ok;
- *      QString value = info->name(&ok);
- *
- *      if ( ok ) kDebug() << "process name - " << name;
- *      int parentPid = info->parentPid(&ok);
- *      if ( ok ) kDebug() << "parent process - " << parentPid;
- *      int foregroundPid = info->foregroundColororegroundPid(&ok);
- *      if ( ok ) kDebug() << "foreground process - " << foregroundPid;
- *   }
- * @endcode
- */
-class ProcessInfo
-{
-public:
-    /**
-     * Constructs a new instance of a suitable ProcessInfo sub-class for 
-     * the current platform which provides information about a given process.
-     *
-     * @param pid The pid of the process to examine
-     * @param readEnvironment Specifies whether environment bindings should
-     * be read.  If this is false, then environment() calls will
-     * always fail.  This is an optimization to avoid the overhead
-     * of reading the (potentially large) environment data when it
-     * is not required. 
-     */
-  static ProcessInfo *newInstance (int pid, bool readEnvironment = false);
-
-    virtual ~ ProcessInfo ()
-  {
-  }
-
-    /** 
-     * Updates the information about the process.  This must
-     * be called before attempting to use any of the accessor methods.
-     */
-  void update ();
-
-    /** Returns true if the process state was read successfully. */
-  bool isValid () const;
-    /** 
-     * Returns the process id.  
-     *
-     * @param ok Set to true if the process id was read successfully or false otherwise 
-     */
-  int pid (bool * ok) const;
-    /** 
-     * Returns the id of the parent process id was read successfully or false otherwise
-     * 
-     * @param ok Set to true if the parent process id
-     */
-  int parentPid (bool * ok) const;
-
-    /** 
-     * Returns the id of the current foreground process 
-     *
-     * NOTE:  Using the foregroundProcessGroup() method of the Pty
-     * instance associated with the terminal of interest is preferred
-     * over using this method.
-     *
-     * @param ok Set to true if the foreground process id was read successfully or false otherwise
-     */
-  int foregroundPid (bool * ok) const;
-
-  /* Returns the user id of the process */
-  int userId (bool * ok) const;
-
-    /** Returns the user's name of the process */
-  QString userName () const;
-
-    /** Returns the user's home directory of the process */
-  QString userHomeDir () const;
-
-    /** Returns the name of the current process */
-  QString name (bool * ok) const;
-
-    /** 
-     * Returns the command-line arguments which the process
-     * was started with.
-     *
-     * The first argument is the name used to launch the process.
-     *
-     * @param ok Set to true if the arguments were read successfully or false otherwise.
-     */
-  QVector < QString > arguments (bool * ok) const;
-    /**
-     * Returns the environment bindings which the process
-     * was started with.
-     * In the returned map, the key is the name of the environment variable,
-     * and the value is the corresponding value.
-     *
-     * @param ok Set to true if the environment bindings were read successfully or false otherwise
-     */
-  QMap < QString, QString > environment (bool * ok) const;
-
-    /**
-     * Returns the current working directory of the process
-     *
-     * @param ok Set to true if the current working directory was read successfully or false otherwise
-     */
-  QString currentDir (bool * ok) const;
-
-    /**
-     * Returns the current working directory of the process (or its parent)
-     */
-  QString validCurrentDir () const;
-
-    /** Forces the user home directory to be calculated */
-  void setUserHomeDir ();
-
-    /**
-     * Parses an input string, looking for markers beginning with a '%' 
-     * character and returns a string with the markers replaced
-     * with information from this process description.
-     * <br>
-     * The markers recognised are:
-     * <ul>
-     * <li> %u - Name of the user which owns the process. </li>
-     * <li> %n - Replaced with the name of the process.   </li>
-     * <li> %d - Replaced with the last part of the path name of the 
-     *      process' current working directory.
-     *      
-     *      (eg. if the current directory is '/home/bob' then
-     *      'bob' would be returned)
-     * </li>
-     * <li> %D - Replaced with the current working directory of the process. </li>
-     * </ul>
-     */
-  QString format (const QString & text) const;
-
-    /** 
-     * This enum describes the errors which can occur when trying to read 
-     * a process's information.
-     */
-  enum Error
-  {
-	/** No error occurred. */
-    NoError,
-	/** The nature of the error is unknown. */
-    UnknownError,
-	/** Konsole does not have permission to obtain the process information. */
-    PermissionsError
-  };
-
-    /**
-     * Returns the last error which occurred.
-     */
-  Error error () const;
-
-protected:
-    /**
-     * Constructs a new process instance.  You should not call the constructor
-     * of ProcessInfo or its subclasses directly.  Instead use the 
-     * static ProcessInfo::newInstance() method which will return
-     * a suitable ProcessInfo instance for the current platform.
-     */
-  explicit ProcessInfo (int pid, bool readEnvironment = false);
-
-    /** 
-     * This is called on construction to read the process state 
-     * Subclasses should reimplement this function to provide
-     * platform-specific process state reading functionality.
-     *
-     * When called, readProcessInfo() should attempt to read all
-     * of the necessary state information.  If the attempt is successful,
-     * it should set the process id using setPid(), and update
-     * the other relevant information using setParentPid(), setName(),
-     * setArguments() etc.
-     *
-     * Calls to isValid() will return true only if the process id
-     * has been set using setPid()
-     *
-     * @param pid The process id of the process to read
-     * @param readEnvironment Specifies whether the environment bindings
-     *                        for the process should be read
-     */
-  virtual bool readProcessInfo (int pid, bool readEnvironment) = 0;
-
-  /* Read the user name */
-  virtual void readUserName (void) = 0;
-
-    /** Sets the process id associated with this ProcessInfo instance */
-  void setPid (int pid);
-    /** Sets the parent process id as returned by parentPid() */
-  void setParentPid (int pid);
-    /** Sets the foreground process id as returend by foregroundPid() */
-  void setForegroundPid (int pid);
-    /** Sets the user id associated with this ProcessInfo instance */
-  void setUserId (int uid);
-    /** Sets the user name of the process as set by readUserName() */
-  void setUserName (const QString & name);
-    /** Sets the name of the process as returned by name() */
-  void setName (const QString & name);
-    /** Sets the current working directory for the process */
-  void setCurrentDir (const QString & dir);
-
-    /** Sets the error */
-  void setError (Error error);
-
-    /** Convenience method.  Sets the error based on a QFile error code. */
-  void setFileError (QFile::FileError error);
-
-    /** 
-     * Adds a commandline argument for the process, as returned
-     * by arguments()
-     */
-  void addArgument (const QString & argument);
-    /**
-     * Adds an environment binding for the process, as returned by
-     * environment()
-     *
-     * @param name The name of the environment variable, eg. "PATH"
-     * @param value The value of the environment variable, eg. "/bin"
-     */
-  void addEnvironmentBinding (const QString & name, const QString & value);
-
-private:
-  enum CommandFormat
-  {
-    ShortCommandFormat,
-    LongCommandFormat
-  };
-  // takes a process name and its arguments and produces formatted output
-  QString formatCommand (const QString & name,
-			 const QVector < QString > &arguments,
-			 CommandFormat format) const;
-
-  // valid bits for _fields variable, ensure that
-  // _fields is changed to an int if more than 8 fields are added
-  enum FIELD_BITS
-  {
-    PROCESS_ID = 1,
-    PARENT_PID = 2,
-    FOREGROUND_PID = 4,
-    ARGUMENTS = 8,
-    ENVIRONMENT = 16,
-    NAME = 32,
-    CURRENT_DIR = 64,
-    UID = 128
-  };
-
-  char _fields;			// a bitmap indicating which fields are valid
-  // used to set the "ok" parameters for the public
-  // accessor functions
-
-  bool _enableEnvironmentRead;	// specifies whether to read the environment
-  // bindings when update() is called
-  int _pid;
-  int _parentPid;
-  int _foregroundPid;
-  int _userId;
-
-  Error _lastError;
-
-  QString _name;
-  QString _userName;
-  QString _userHomeDir;
-  QString _currentDir;
-
-  QVector < QString > _arguments;
-  QMap < QString, QString > _environment;
-};
-
-/** 
- * Implementation of ProcessInfo which does nothing.
- * Used on platforms where a suitable ProcessInfo subclass is not 
- * available.
- *
- * isValid() will always return false for instances of NullProcessInfo
- */
-class NullProcessInfo:public ProcessInfo
-{
-public:
-    /** 
-     * Constructs a new NullProcessInfo instance.
-     * See ProcessInfo::newInstance()
-     */
-  explicit NullProcessInfo (int pid, bool readEnvironment = false);
-protected:
-    virtual bool readProcessInfo (int pid, bool readEnvironment);
-  virtual void readUserName (void);
-};
-
-/**
- * Implementation of ProcessInfo for Unix platforms which uses
- * the /proc filesystem
- */
-class UnixProcessInfo:public ProcessInfo
-{
-public:
-    /** 
-     * Constructs a new instance of UnixProcessInfo.
-     * See ProcessInfo::newInstance()
-     */
-  explicit UnixProcessInfo (int pid, bool readEnvironment = false);
-
-protected:
-    /** 
-     * Implementation of ProcessInfo::readProcessInfo(); calls the
-     * four private methods below in turn.
-     */
-    virtual bool readProcessInfo (int pid, bool readEnvironment);
-
-  virtual void readUserName (void);
-
-private:
-    /**
-     * Read the standard process information -- PID, parent PID, foreground PID.
-     * @param pid process ID to use
-     * @return true on success
-     */
-    virtual bool readProcInfo (int pid) = 0;
-
-    /**
-     * Read the environment of the process. Sets _environment.
-     * @param pid process ID to use
-     * @return true on success
-     */
-  virtual bool readEnvironment (int pid) = 0;
-
-    /**
-     * Determine what arguments were passed to the process. Sets _arguments.
-     * @param pid process ID to use
-     * @return true on success
-     */
-  virtual bool readArguments (int pid) = 0;
-
-    /**
-     * Determine the current directory of the process.
-     * @param pid process ID to use
-     * @return true on success
-     */
-  virtual bool readCurrentDir (int pid) = 0;
-};
-
-/** 
- * Lightweight class which provides additional information about SSH processes.
- */
-class SSHProcessInfo
-{
-public:
-    /** 
-     * Constructs a new SSHProcessInfo instance which provides additional
-     * information about the specified SSH process.
-     *
-     * @param process A ProcessInfo instance for a SSH process.
-     */
-  SSHProcessInfo (const ProcessInfo & process);
-
-    /** 
-     * Returns the user name which the user initially logged into on
-     * the remote computer.
-     */
-  QString userName () const;
-
-    /**
-     * Returns the host which the user has connected to.
-     */
-  QString host () const;
-
-    /** 
-     * Returns the command which the user specified to execute on the 
-     * remote computer when starting the SSH process.
-     */
-  QString command () const;
-
-    /**
-     * Operates in the same way as ProcessInfo::format(), except
-     * that the set of markers understood is different:
-     *
-     * %u - Replaced with user name which the user initially logged
-     *      into on the remote computer.
-     * %h - Replaced with the first part of the host name which
-     *      is connected to.
-     * %H - Replaced with the full host name of the computer which
-     *      is connected to.
-     * %c - Replaced with the command which the user specified
-     *      to execute when starting the SSH process.
-     */
-  QString format (const QString & input) const;
-
-private:
-  const ProcessInfo & _process;
-  QString _user;
-  QString _host;
-  QString _command;
-};
-
-#endif //PROCESSINFO_H
-
-/*
-  Local Variables:
-  mode: c++
-  c-file-style: "stroustrup"
-  indent-tabs-mode: nil
-  tab-width: 4
-  End:
-*/
diff --git a/gui/src/terminal/Pty.cpp b/gui/src/terminal/Pty.cpp
--- a/gui/src/terminal/Pty.cpp
+++ b/gui/src/terminal/Pty.cpp
@@ -62,66 +62,62 @@ Pty::setFlowControlEnabled (bool enable)
   if (pty ()->masterFd () >= 0)
     {
       struct::termios ttmode;
       pty ()->tcGetAttr (&ttmode);
       if (!enable)
 	ttmode.c_iflag &= ~(IXOFF | IXON);
       else
 	ttmode.c_iflag |= (IXOFF | IXON);
-      //if (!pty()->tcSetAttr(&ttmode))
-      //  kWarning() << "Unable to set terminal attributes.";
+      pty()->tcSetAttr(&ttmode);
     }
 }
 
 bool
 Pty::flowControlEnabled () const
 {
   if (pty ()->masterFd () >= 0)
     {
       struct::termios ttmode;
       pty ()->tcGetAttr (&ttmode);
       return ttmode.c_iflag & IXOFF && ttmode.c_iflag & IXON;
     }
-  //kWarning() << "Unable to get flow control status, terminal not connected.";
   return false;
 }
 
 void
 Pty::setUtf8Mode (bool enable)
 {
-#ifdef IUTF8			// XXX not a reasonable place to check it.
+#ifdef IUTF8
   _utf8 = enable;
 
   if (pty ()->masterFd () >= 0)
     {
       struct::termios ttmode;
       pty ()->tcGetAttr (&ttmode);
       if (!enable)
 	ttmode.c_iflag &= ~IUTF8;
       else
 	ttmode.c_iflag |= IUTF8;
-      // if (!pty()->tcSetAttr(&ttmode))
-      //  kWarning() << "Unable to set terminal attributes.";
+      pty()->tcSetAttr(&ttmode);
     }
 #endif
 }
 
 void
 Pty::setErase (char erase)
 {
   _eraseChar = erase;
 
   if (pty ()->masterFd () >= 0)
     {
       struct::termios ttmode;
       pty ()->tcGetAttr (&ttmode);
       ttmode.c_cc[VERASE] = erase;
-      //if (!pty()->tcSetAttr(&ttmode))
-      //  kWarning() << "Unable to set terminal attributes.";
+      pty()->tcSetAttr(&ttmode);
     }
 }
 
 char
 Pty::erase () const
 {
   if (pty ()->masterFd () >= 0)
     {
@@ -144,61 +140,64 @@ Pty::addEnvironmentVariables (const QStr
       // split on the first '=' character
       int pos = pair.indexOf ('=');
 
       if (pos >= 0)
 	{
 	  QString variable = pair.left (pos);
 	  QString value = pair.mid (pos + 1);
 
-	  setEnv (variable, value);
+          setEnvironmentVariable (variable, value);
 	}
     }
 }
 
 int
 Pty::start (const QString & program,
 	    const QStringList & programArguments,
 	    const QStringList & environment,
 	    ulong winid,
 	    bool addToUtmp,
 	    const QString & dbusService, const QString & dbusSession)
 {
+  Q_UNUSED(dbusService);
+  Q_UNUSED(dbusSession);
+  Q_UNUSED(winid);
   clearProgram ();
 
   // For historical reasons, the first argument in programArguments is the 
   // name of the program to execute, so create a list consisting of all
   // but the first argument to pass to setProgram()
   Q_ASSERT (programArguments.count () >= 1);
   setProgram (program.toLatin1 (), programArguments.mid (1));
 
   addEnvironmentVariables (environment);
 
-  if (!dbusService.isEmpty ())
-    setEnv ("KONSOLE_DBUS_SERVICE", dbusService);
-  if (!dbusSession.isEmpty ())
-    setEnv ("KONSOLE_DBUS_SESSION", dbusSession);
+  //if (!dbusService.isEmpty ())
+  //  setEnv ("KONSOLE_DBUS_SERVICE", dbusService);
+  //if (!dbusSession.isEmpty ())
+  //  setEnv ("KONSOLE_DBUS_SESSION", dbusSession);
 
-  setEnv ("WINDOWID", QString::number (winid));
+  //setEnv ("WINDOWID", QString::number (winid));
 
   // unless the LANGUAGE environment variable has been set explicitly
   // set it to a null string
   // this fixes the problem where KCatalog sets the LANGUAGE environment
   // variable during the application's startup to something which
   // differs from LANG,LC_* etc. and causes programs run from
   // the terminal to display messages in the wrong language
   //
   // this can happen if LANG contains a language which KDE
   // does not have a translation for
   //
   // BR:149300
-  setEnv ("LANGUAGE", QString (),
-	  false /* do not overwrite existing value if any */ );
+  setEnvironmentVariable ("LANGUAGE", QString (),
+          false /* do not overwrite existing value if any */ );
+  setUseUtmp (addToUtmp);
 
-  setUseUtmp (addToUtmp);
 
   struct::termios ttmode;
   pty ()->tcGetAttr (&ttmode);
   if (!_xonXoff)
     ttmode.c_iflag &= ~(IXOFF | IXON);
   else
     ttmode.c_iflag |= (IXOFF | IXON);
 #ifdef IUTF8			// XXX not a reasonable place to check it.
@@ -206,35 +205,30 @@ Pty::start (const QString & program,
     ttmode.c_iflag &= ~IUTF8;
   else
     ttmode.c_iflag |= IUTF8;
 #endif
 
   if (_eraseChar != 0)
     ttmode.c_cc[VERASE] = _eraseChar;
 
-  //if (!pty()->tcSetAttr(&ttmode))
-  //  kWarning() << "Unable to set terminal attributes.";
-
+  pty()->tcSetAttr(&ttmode);
   pty ()->setWinSize (_windowLines, _windowColumns);
 
   KProcess::start ();
 
   if (!waitForStarted ())
     return -1;
-
   return 0;
 }
 
 void
 Pty::setWriteable (bool writeable)
 {
-  //KDE_struct_stat sbuf;
   struct stat sbuf;
-  //KDE_stat(pty()->ttyName(), &sbuf);
   ::stat (pty ()->ttyName (), &sbuf);
   if (writeable)
     chmod (pty ()->ttyName (), sbuf.st_mode | S_IWGRP);
   else
     chmod (pty ()->ttyName (), sbuf.st_mode & ~(S_IWGRP | S_IWOTH));
 }
 
 Pty::Pty (int masterFd, QObject * parent):
@@ -265,43 +259,26 @@ Pty::~Pty ()
 {
 }
 
 void
 Pty::sendData (const char *data, int length)
 {
   if (!length)
     return;
-
-  if (!pty ()->write (data, length))
-    {
-      //kWarning() << "Pty::doSendJobs - Could not send input data to terminal process.";
-      return;
-    }
+  pty ()->write (data, length);
 }
 
 void
 Pty::dataReceived ()
 {
   QByteArray data = pty ()->readAll ();
   emit receivedData (data.constData (), data.count ());
 }
 
-void
-Pty::lockPty (bool lock)
-{
-  Q_UNUSED (lock);
-
-// TODO: Support for locking the Pty
-  //if (lock)
-  //suspend();
-  //else
-  //resume();
-}
-
 int
 Pty::foregroundProcessGroup () const
 {
   int pid = tcgetpgrp (pty ()->masterFd ());
 
   if (pid != -1)
     {
       return pid;
diff --git a/gui/src/terminal/Pty.h b/gui/src/terminal/Pty.h
--- a/gui/src/terminal/Pty.h
+++ b/gui/src/terminal/Pty.h
@@ -136,27 +136,16 @@ Q_OBJECT public:
   int foregroundProcessGroup () const;
 
   public slots:
     /**
      * Put the pty into UTF-8 mode on systems which support it.
      */
   void setUtf8Mode (bool on);
 
-    /**
-     * Suspend or resume processing of data from the standard 
-     * output of the terminal process.
-     *
-     * See K3Process::suspend() and K3Process::resume()
-     *
-     * @param lock If true, processing of output is suspended,
-     * otherwise processing is resumed.
-     */
-  void lockPty (bool lock);
-
     /** 
      * Sends data to the process currently controlling the 
      * teletype ( whose id is returned by foregroundProcessGroup() )
      *
      * @param buffer Pointer to the data to send.
      * @param length Length of @p buffer.
      */
   void sendData (const char *buffer, int length);
diff --git a/gui/src/terminal/Session.cpp b/gui/src/terminal/Session.cpp
--- a/gui/src/terminal/Session.cpp
+++ b/gui/src/terminal/Session.cpp
@@ -36,17 +36,17 @@
 #include <QtCore/QFile>
 #include <QtCore/QRegExp>
 #include <QtCore/QStringList>
 #include <QtCore/QDate>
 
 #include "kprocess.h"
 #include "kptydevice.h"
 
-#include "ProcessInfo.h"
+//#include "ProcessInfo.h"
 #include "Pty.h"
 #include "TerminalDisplay.h"
 #include "ShellCommand.h"
 #include "Vt102Emulation.h"
 
 int
   Session::lastSessionId = 0;
 
@@ -95,17 +95,17 @@ createUuid ()
   return result;
 }
 
 Session::Session (QObject * parent):
 QObject (parent), _shellProcess (0), _emulation (0), _monitorActivity (false),
 _monitorSilence (false), _notifiedActivity (false), _autoClose (true),
 _wantedClose (false), _silenceSeconds (10), _addToUtmp (true),
 _flowControl (true), _fullScripting (false), _sessionId (0),
-_sessionProcessInfo (0), _foregroundProcessInfo (0), _foregroundPid (0)
+/*_sessionProcessInfo (0), _foregroundProcessInfo (0),*/ _foregroundPid (0)
   //, _zmodemBusy(false)
   //, _zmodemProc(0)
   //, _zmodemProgress(0)
   , _hasDarkBackground (false)
 {
   _uniqueIdentifier = createUuid ();
 
   //prepare DBus communication
@@ -158,18 +158,16 @@ Session::openTeletype (int fd)
 
   _shellProcess->setUtf8Mode (_emulation->utf8 ());
 
   //connect teletype to emulation backend
   connect (_shellProcess, SIGNAL (receivedData (const char *, int)), this,
 	   SLOT (onReceiveBlock (const char *, int)));
   connect (_emulation, SIGNAL (sendData (const char *, int)), _shellProcess,
 	   SLOT (sendData (const char *, int)));
-  connect (_emulation, SIGNAL (lockPtyRequest (bool)), _shellProcess,
-	   SLOT (lockPty (bool)));
   connect (_emulation, SIGNAL (useUtf8Request (bool)), _shellProcess,
 	   SLOT (setUtf8Mode (bool)));
   connect (_shellProcess, SIGNAL (finished (int, QProcess::ExitStatus)), this,
 	   SLOT (done (int)));
   connect (_emulation, SIGNAL (imageSizeChanged (int, int)), this,
 	   SLOT (updateWindowSize (int, int)));
 }
 
@@ -259,32 +257,34 @@ Session::setInitialWorkingDirectory (con
 }
 
 void
 Session::setArguments (const QStringList & arguments)
 {
   _arguments = ShellCommand::expand (arguments);
 }
 
+/*
 QString
 Session::currentWorkingDirectory ()
 {
   // only returned cached value
-  if (_currentWorkingDir.isEmpty ())
-    updateWorkingDirectory ();
+  //if (_currentWorkingDir.isEmpty ())
+  //  updateWorkingDirectory ();
   return _currentWorkingDir;
 }
-
+*/
+/*
 ProcessInfo *
 Session::updateWorkingDirectory ()
 {
   ProcessInfo *process = getProcessInfo ();
   _currentWorkingDir = process->validCurrentDir ();
   return process;
-}
+}*/
 
 QList < TerminalDisplay * >Session::views () const
 {
   return _views;
 }
 
 void
 Session::addView (TerminalDisplay * widget)
@@ -813,20 +813,20 @@ Session::sendText (const QString & text)
 void
 Session::sendMouseEvent (int buttons, int column, int line, int eventType)
 {
   _emulation->sendMouseEvent (buttons, column, line, eventType);
 }
 
 Session::~Session ()
 {
-  if (_foregroundProcessInfo)
-    delete _foregroundProcessInfo;
-  if (_sessionProcessInfo)
-    delete _sessionProcessInfo;
+  //if (_foregroundProcessInfo)
+  //  delete _foregroundProcessInfo;
+  //if (_sessionProcessInfo)
+  //  delete _sessionProcessInfo;
   delete _emulation;
   delete _shellProcess;
   //delete _zmodemProc;
 }
 
 void
 Session::done (int exitStatus)
 {
@@ -923,47 +923,51 @@ Session::title (TitleRole role) const
   if (role == NameRole)
     return _nameTitle;
   else if (role == DisplayedTitleRole)
     return _displayTitle;
   else
     return QString ();
 }
 
+/*
 ProcessInfo *
 Session::getProcessInfo ()
 {
   ProcessInfo *process;
 
   if (isForegroundProcessActive ())
     process = _foregroundProcessInfo;
   else
     {
       updateSessionProcessInfo ();
       process = _sessionProcessInfo;
     }
 
   return process;
-}
+}*/
+
 
 void
 Session::updateSessionProcessInfo ()
 {
+  /*
   Q_ASSERT (_shellProcess);
   if (!_sessionProcessInfo)
     {
       _sessionProcessInfo = ProcessInfo::newInstance (processId ());
       _sessionProcessInfo->setUserHomeDir ();
     }
-  _sessionProcessInfo->update ();
+  _sessionProcessInfo->update ();*/
 }
 
 bool
 Session::updateForegroundProcessInfo ()
 {
+  /*
   bool valid = (_foregroundProcessInfo != 0);
 
   // has foreground process changed?
   Q_ASSERT (_shellProcess);
   int pid = _shellProcess->foregroundProcessGroup ();
   if (pid != _foregroundPid)
     {
       if (valid)
@@ -974,46 +978,50 @@ Session::updateForegroundProcessInfo ()
     }
 
   if (valid)
     {
       _foregroundProcessInfo->update ();
       valid = _foregroundProcessInfo->isValid ();
     }
 
-  return valid;
+  return valid;*/
+  return true;
 }
 
 bool
 Session::isRemote ()
-{
+{/*
   ProcessInfo *process = getProcessInfo ();
 
   bool ok = false;
   return (process->name (&ok) == "ssh" && ok);
+  */
+  return false;
 }
 
 QString
 Session::getDynamicTitle ()
-{
+{/*
   // update current directory from process
   ProcessInfo *process = updateWorkingDirectory ();
 
   // format tab titles using process info
   bool ok = false;
   QString title;
   if (process->name (&ok) == "ssh" && ok)
     {
       SSHProcessInfo sshInfo (*process);
       title = sshInfo.format (tabTitleFormat (Session::RemoteTabTitle));
     }
   else
     title = process->format (tabTitleFormat (Session::LocalTabTitle));
 
-  return title;
+  return title;*/
+  return "";
 }
 
 void
 Session::setIconName (const QString & iconName)
 {
   if (iconName != _iconName)
     {
       _iconName = iconName;
@@ -1223,51 +1231,53 @@ Session::tabTitleFormat (int context) co
       return this->tabTitleFormat (Session::LocalTabTitle);
     case (1):
       return this->tabTitleFormat (Session::RemoteTabTitle);
     default:
       return QString ();
     }
 }
 
+/*
 int
 Session::foregroundProcessId ()
 {
   int pid;
 
   bool ok = false;
   pid = getProcessInfo ()->pid (&ok);
   if (!ok)
     pid = -1;
 
   return pid;
-}
+}*/
 
 bool
 Session::isForegroundProcessActive ()
 {
   // foreground process info is always updated after this
   return updateForegroundProcessInfo () && (processId () != _foregroundPid);
 }
 
+/*
 QString
 Session::foregroundProcessName ()
 {
   QString name;
 
   if (updateForegroundProcessInfo ())
     {
       bool ok = false;
       name = _foregroundProcessInfo->name (&ok);
       if (!ok)
 	name.clear ();
     }
 
   return name;
-}
+}*/
 
 SessionGroup::SessionGroup (QObject * parent):QObject (parent), _masterMode (0)
 {
 }
 
 SessionGroup::~SessionGroup ()
 {
 }
diff --git a/gui/src/terminal/Session.h b/gui/src/terminal/Session.h
--- a/gui/src/terminal/Session.h
+++ b/gui/src/terminal/Session.h
@@ -33,17 +33,17 @@
 
 // Konsole
 #include "History.h"
 
 class KProcess;
 class KUrl;
 class Emulation;
 class Pty;
-class ProcessInfo;
+//class ProcessInfo;
 class TerminalDisplay;
   //class ZModemDialog;
 /**
  * Represents a terminal session consisting of a pseudo-teletype and a terminal emulation.
  * The pseudo-teletype (or PTY) handles I/O between the terminal process and Konsole.
  * The terminal emulation ( Emulation and subclasses ) processes the output stream from the
  * PTY and produces a character image which is then shown on views connected to the session.
  *
@@ -183,17 +183,17 @@ Q_OBJECT Q_CLASSINFO ("D-Bus Interface",
    * Sets the initial working directory for the session when it is run
    * This has no effect once the session has been started.
    */
   void setInitialWorkingDirectory (const QString & dir);
 
   /**
    * Returns the current directory of the foreground process in the session
    */
-  QString currentWorkingDirectory ();
+  //QString currentWorkingDirectory ();
 
   /**
    * Sets the type of history store used by this session.
    * Lines of output produced by the terminal are added
    * to the history store.  The type of history store
    * used affects the number of lines which can be
    * remembered before they are lost and the storage
    * (in memory, on-disk etc.) used.
@@ -279,17 +279,17 @@ Q_OBJECT Q_CLASSINFO ("D-Bus Interface",
   {
     _autoClose = b;
   }
 
   /** Returns true if the user has started a program in the session. */
   bool isForegroundProcessActive ();
 
   /** Returns the name of the current foreground process. */
-  QString foregroundProcessName ();
+  //QString foregroundProcessName ();
 
   /** Returns the terminal session's window size in lines and columns. */
   QSize size ();
   /**
    * Emits a request to resize the session to accommodate
    * the specified window size.
    *
    * @param size The size in lines and columns to request.
@@ -441,17 +441,17 @@ Q_OBJECT Q_CLASSINFO ("D-Bus Interface",
    */
   Q_SCRIPTABLE int processId () const;
 
   /**
    * Returns the process id of the terminal's foreground process.
    * This is initially the same as processId() but can change
    * as the user starts other programs inside the terminal.
    */
-  Q_SCRIPTABLE int foregroundProcessId ();
+  //Q_SCRIPTABLE int foregroundProcessId ();
 
   /** Sets the text codec used by this sessions terminal emulation.
     * Overloaded to accept a QByteArray for convenience since DBus
     * does not accept QTextCodec directky.
     */
   Q_SCRIPTABLE bool setCodec (QByteArray codec);
 
   /** Returns the codec used to decode incoming characters in this
@@ -597,20 +597,20 @@ private:
   bool kill (int signal);
   // print a warning message in the terminal.  This is used
   // if the program fails to start, or if the shell exits in 
   // an unsuccessful manner
   void terminalWarning (const QString & message);
   // checks that the binary 'program' is available and can be executed
   // returns the binary name if available or an empty string otherwise
   QString checkProgram (const QString & program) const;
-  ProcessInfo *getProcessInfo ();
+  //ProcessInfo *getProcessInfo ();
   void updateSessionProcessInfo ();
   bool updateForegroundProcessInfo ();
-  ProcessInfo *updateWorkingDirectory ();
+  //ProcessInfo *updateWorkingDirectory ();
 
   QUuid _uniqueIdentifier;	// SHELL_SESSION_ID
 
   Pty *_shellProcess;
   Emulation *_emulation;
 
   QList < TerminalDisplay * >_views;
 
@@ -641,18 +641,18 @@ private:
   QStringList _arguments;
 
   QStringList _environment;
   int _sessionId;
 
   QString _initialWorkingDir;
   QString _currentWorkingDir;
 
-  ProcessInfo *_sessionProcessInfo;
-  ProcessInfo *_foregroundProcessInfo;
+  //ProcessInfo *_sessionProcessInfo;
+  //ProcessInfo *_foregroundProcessInfo;
   int _foregroundPid;
 
   // ZModem
   //  bool           _zmodemBusy;
   //  KProcess*      _zmodemProc;
   //  ZModemDialog*  _zmodemProgress;
 
   // Color/Font Changes by ESC Sequences
diff --git a/gui/src/terminal/kprocess.cpp b/gui/src/terminal/kprocess.cpp
--- a/gui/src/terminal/kprocess.cpp
+++ b/gui/src/terminal/kprocess.cpp
@@ -156,17 +156,17 @@ KProcess::OutputChannelMode KProcess::ou
   Q_D (const KProcess);
 
   return d->outputChannelMode;
 }
 
 #define DUMMYENV "_KPROCESS_DUMMY_="
 
 void
-KProcess::setEnv (const QString & name, const QString & value, bool overwrite)
+KProcess::setEnvironmentVariable (const QString & name, const QString & value, bool overwrite)
 {
   QStringList env = environment ();
   if (env.isEmpty ())
     {
       env = systemEnvironment ();
       env.removeAll (QString::fromLatin1 (DUMMYENV));
     }
   QString fname (name);
@@ -181,17 +181,17 @@ KProcess::setEnv (const QString & name, 
 	  }
 	return;
       }
   env.append (fname.append (value));
   setEnvironment (env);
 }
 
 void
-KProcess::unsetEnv (const QString & name)
+KProcess::unsetEnvironmentVariable (const QString & name)
 {
   QStringList env = environment ();
   if (env.isEmpty ())
     {
       env = systemEnvironment ();
       env.removeAll (QString::fromLatin1 (DUMMYENV));
     }
   QString fname (name);
diff --git a/gui/src/terminal/kprocess.h b/gui/src/terminal/kprocess.h
--- a/gui/src/terminal/kprocess.h
+++ b/gui/src/terminal/kprocess.h
@@ -98,27 +98,27 @@ Q_OBJECT Q_DECLARE_PRIVATE (KProcess) pu
      *
      * This function must be called before starting the process.
      *
      * @param name the name of the environment variable
      * @param value the new value for the environment variable
      * @param overwrite if @c false and the environment variable is already
      *   set, the old value will be preserved
      */
-  void setEnv (const QString & name, const QString & value, bool overwrite =
+  void setEnvironmentVariable (const QString & name, const QString & value, bool overwrite =
 	       true);
 
     /**
      * Removes the variable @p name from the process' environment.
      *
      * This function must be called before starting the process.
      *
      * @param name the name of the environment variable
      */
-  void unsetEnv (const QString & name);
+  void unsetEnvironmentVariable (const QString & name);
 
     /**
      * Set the program and the command line arguments.
      *
      * This function must be called before starting the process, obviously.
      *
      * @param exe the program to execute
      * @param args the command line arguments for the program,
