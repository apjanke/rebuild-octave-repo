# HG changeset patch
# User Rik <rik@octave.org>
# Date 1451685525 28800
#      Fri Jan 01 13:58:45 2016 -0800
# Node ID 6176560b03d919eed65f3f6553ab567c5170141a
# Parent  ec532a439c6ffc08d0149e610c9cbba1d7049b56
maint: Remove return stmts after gripe function calls.


* gripes.h: Mark gripe functions which call error() wwith GCC_ATTR_NORETURN.

* jit-typeinfo.cc (gripe_bad_result): Mark function with GCC_ATTR_NORETURN.

* load-save.cc (gripe_file_open): Mark function with GCC_ATTR_NORETURN.

* ov-base.cc (gripe_indexed_assignment, gripe_assign_conversion_failed,
gripe_no_conversion): Mark functions with GCC_ATTR_NORETURN.

* ov-class.cc (gripe_invalid_index1, gripe_invalid_index_for_assignment,
gripe_invalid_index_type): Mark functions with GCC_ATTR_NORETURN.

* ov-classdef.h (gripe_invalid_object): Mark function with GCC_ATTR_NORETURN.

* ov.cc (gripe_cat_op, gripe_cat_op_conv): Mark functions with
GCC_ATTR_NORETURN.

* balance.cc, det.cc, eig.cc, hess.cc, inv.cc, jit-typeinfo.cc, load-save.cc,
qz.cc, schur.cc, sparse-xdiv.cc, sparse-xpow.cc, sylvester.cc, xdiv.cc,
xpow.cc, symrcm.cc, ov-base.cc, ov-classdef.h, ov-cs-list.cc, ov-flt-re-mat.cc,
ov-re-mat.cc, ov-re-sparse.cc, ov.cc, op-int.h, op-fs-fs.cc, ops.h:
Remove statements that occur after a gripe function which does not return.

* op-cs-cs.cc, op-dms-template.cc, op-fcs-fcs.cc, op-s-s.cc : Add newline
between gripe and return statement for readability.

diff --git a/libinterp/corefcn/balance.cc b/libinterp/corefcn/balance.cc
--- a/libinterp/corefcn/balance.cc
+++ b/libinterp/corefcn/balance.cc
@@ -100,20 +100,17 @@ Generalized eigenvalue problem balancing
 
   // determine if it's AEP or GEP
   bool AEPcase = nargin == 1 || args(1).is_string ();
 
   // problem dimension
   octave_idx_type nn = args(0).rows ();
 
   if (nn != args(0).columns ())
-    {
-      gripe_square_matrix_required ("balance");
-      return retval;
-    }
+    gripe_square_matrix_required ("balance");
 
   bool isfloat = args(0).is_single_type ()
                  || (! AEPcase && args(1).is_single_type ());
 
   bool complex_case = args(0).is_complex_type ()
                       || (! AEPcase && args(1).is_complex_type ());
 
   // Extract argument 1 parameter for both AEP and GEP.
@@ -222,20 +219,17 @@ Generalized eigenvalue problem balancing
 
       // Generalized eigenvalue problem.
       if (nargin == 2)
         bal_job = "B";
       else
         bal_job = args(2).xstring_value ("balance: OPT argument must be a string");
 
       if ((nn != args(1).columns ()) || (nn != args(1).rows ()))
-        {
-          gripe_nonconformant ();
-          return retval;
-        }
+        gripe_nonconformant ();
 
       Matrix bb;
       ComplexMatrix cbb;
       FloatMatrix fbb;
       FloatComplexMatrix fcbb;
 
       if (isfloat)
         {
diff --git a/libinterp/corefcn/det.cc b/libinterp/corefcn/det.cc
--- a/libinterp/corefcn/det.cc
+++ b/libinterp/corefcn/det.cc
@@ -77,20 +77,17 @@ For that, use any of the condition numbe
 
   int arg_is_empty = empty_arg ("det", nr, nc);
   if (arg_is_empty < 0)
     return ovl ();
   if (arg_is_empty > 0)
     return octave_value (1.0);
 
   if (nr != nc)
-    {
-      gripe_square_matrix_required ("det");
-      return ovl ();
-    }
+    gripe_square_matrix_required ("det");
 
   octave_value_list retval (2);
 
   bool isfloat = arg.is_single_type ();
 
   if (arg.is_diag_matrix ())
     {
       if (nargout <= 1)
diff --git a/libinterp/corefcn/eig.cc b/libinterp/corefcn/eig.cc
--- a/libinterp/corefcn/eig.cc
+++ b/libinterp/corefcn/eig.cc
@@ -93,26 +93,20 @@ The eigenvalues returned by @code{eig} a
       if (!(arg_b.is_single_type () || arg_b.is_double_type ()))
         {
           gripe_wrong_type_arg ("eig", arg_b);
           return retval;
         }
     }
 
   if (nr_a != nc_a)
-    {
-      gripe_square_matrix_required ("eig");
-      return retval;
-    }
+    gripe_square_matrix_required ("eig");
 
   if (nargin == 2 && nr_b != nc_b)
-    {
-      gripe_square_matrix_required ("eig");
-      return retval;
-    }
+    gripe_square_matrix_required ("eig");
 
   Matrix tmp_a, tmp_b;
   ComplexMatrix ctmp_a, ctmp_b;
   FloatMatrix ftmp_a, ftmp_b;
   FloatComplexMatrix fctmp_a, fctmp_b;
 
   if (arg_a.is_single_type ())
     {
diff --git a/libinterp/corefcn/gripes.h b/libinterp/corefcn/gripes.h
--- a/libinterp/corefcn/gripes.h
+++ b/libinterp/corefcn/gripes.h
@@ -25,69 +25,67 @@ along with Octave; see the file COPYING.
 
 #include <string>
 
 #include "lo-array-gripes.h"
 
 class octave_value;
 class octave_execution_exception;
 
-extern OCTINTERP_API void
-gripe_not_supported (const char *) GCC_ATTR_NORETURN;
+extern OCTINTERP_API void GCC_ATTR_NORETURN
+gripe_not_supported (const char *);
 
-extern OCTINTERP_API void
-gripe_not_implemented (const char *) GCC_ATTR_NORETURN;
+extern OCTINTERP_API void GCC_ATTR_NORETURN
+gripe_not_implemented (const char *);
 
-extern OCTINTERP_API void
-gripe_string_invalid (void) GCC_ATTR_NORETURN;
+extern OCTINTERP_API void GCC_ATTR_NORETURN
+gripe_string_invalid (void);
 
-extern OCTINTERP_API void
-gripe_range_invalid (void) GCC_ATTR_NORETURN;
+extern OCTINTERP_API void GCC_ATTR_NORETURN
+gripe_range_invalid (void);
 
-extern OCTINTERP_API void
-gripe_nonconformant (void) GCC_ATTR_NORETURN;
+extern OCTINTERP_API void GCC_ATTR_NORETURN
+gripe_nonconformant (void);
 
-extern OCTINTERP_API void
+extern OCTINTERP_API void GCC_ATTR_NORETURN
 gripe_nonconformant (octave_idx_type r1, octave_idx_type c1,
-                     octave_idx_type r2, octave_idx_type c2) GCC_ATTR_NORETURN;
+                     octave_idx_type r2, octave_idx_type c2);
 
 extern OCTINTERP_API void
 gripe_empty_arg (const char *name, bool is_error);
 
-extern OCTINTERP_API void
-gripe_square_matrix_required (const char *name) GCC_ATTR_NORETURN;
-
-extern OCTINTERP_API void
-gripe_user_supplied_eval (const char *name) GCC_ATTR_NORETURN;
+extern OCTINTERP_API void GCC_ATTR_NORETURN
+gripe_square_matrix_required (const char *name);
 
-extern OCTINTERP_API void
-gripe_user_supplied_eval (octave_execution_exception& e,
-                          const char *name) GCC_ATTR_NORETURN;
+extern OCTINTERP_API void GCC_ATTR_NORETURN
+gripe_user_supplied_eval (const char *name);
 
-extern OCTINTERP_API void
+extern OCTINTERP_API void GCC_ATTR_NORETURN
+gripe_user_supplied_eval (octave_execution_exception& e, const char *name);
+
+extern OCTINTERP_API void GCC_ATTR_NORETURN
 gripe_user_returned_invalid (const char *name);
 
-extern OCTINTERP_API void
-gripe_invalid_conversion (const std::string& from,
-                          const std::string& to) GCC_ATTR_NORETURN;
+extern OCTINTERP_API void GCC_ATTR_NORETURN
+gripe_invalid_conversion (const std::string& from, const std::string& to);
 
 extern OCTINTERP_API void
 gripe_invalid_value_specified (const char *name);
 
-extern OCTINTERP_API void
-gripe_2_or_3_dim_plot (void) GCC_ATTR_NORETURN;
+extern OCTINTERP_API void GCC_ATTR_NORETURN
+gripe_2_or_3_dim_plot (void);
 
-extern OCTINTERP_API void
-gripe_unrecognized_float_fmt (void) GCC_ATTR_NORETURN;
+extern OCTINTERP_API void GCC_ATTR_NORETURN
+gripe_unrecognized_float_fmt (void);
 
-extern OCTINTERP_API void
-gripe_unrecognized_data_fmt (const char *warn_for) GCC_ATTR_NORETURN;
+extern OCTINTERP_API void GCC_ATTR_NORETURN
+gripe_unrecognized_data_fmt (const char *warn_for);
 
-extern OCTINTERP_API void
-gripe_data_conversion (const char *from, const char *to) GCC_ATTR_NORETURN;
+extern OCTINTERP_API void GCC_ATTR_NORETURN
+gripe_data_conversion (const char *from, const char *to);
 
 extern OCTINTERP_API void
 gripe_wrong_type_arg (const char *name, const char *s,
                       bool is_error = true);
 
 extern OCTINTERP_API void
 gripe_wrong_type_arg (octave_execution_exception& e,
                       const char *name, const char *s,
@@ -116,67 +114,73 @@ gripe_wrong_type_arg (const std::string&
                       bool is_error = true);
 
 extern OCTINTERP_API void
 gripe_wrong_type_arg (octave_execution_exception& e,
                       const std::string& name, const octave_value& tc,
                       bool is_error = true);
 
 extern OCTINTERP_API void
-gripe_wrong_type_arg (const char *s, bool is_error = true);
+gripe_wrong_type_arg (const char *s,
+                      bool is_error = true);
 
 extern OCTINTERP_API void
 gripe_wrong_type_arg (octave_execution_exception& e,
-                      const char *s, bool is_error = true);
+                      const char *s,
+                      bool is_error = true);
 
 extern OCTINTERP_API void
-gripe_wrong_type_arg (const std::string& s, bool is_error = true);
+gripe_wrong_type_arg (const std::string& s,
+                      bool is_error = true);
 
 extern OCTINTERP_API void
 gripe_wrong_type_arg (octave_execution_exception& e,
-                      const std::string& s, bool is_error = true);
+                      const std::string& s,
+                      bool is_error = true);
 
 extern OCTINTERP_API void
-gripe_wrong_type_arg (const octave_value& tc, bool is_error = true);
+gripe_wrong_type_arg (const octave_value& tc,
+                      bool is_error = true);
 
 extern OCTINTERP_API void
 gripe_wrong_type_arg (octave_execution_exception& e,
-                      const octave_value& tc, bool is_error = true);
+                      const octave_value& tc,
+                      bool is_error = true);
 
-extern OCTINTERP_API void
-gripe_wrong_type_arg_for_unary_op (const octave_value& op) GCC_ATTR_NORETURN;
+extern OCTINTERP_API void GCC_ATTR_NORETURN
+gripe_wrong_type_arg_for_unary_op (const octave_value& op);
 
-extern OCTINTERP_API void
-gripe_wrong_type_arg_for_binary_op (const octave_value& op) GCC_ATTR_NORETURN;
+extern OCTINTERP_API void GCC_ATTR_NORETURN
+gripe_wrong_type_arg_for_binary_op (const octave_value& op);
 
 extern OCTINTERP_API void
 gripe_implicit_conversion (const char *id, const char *from, const char *to);
 
 extern OCTINTERP_API void
 gripe_implicit_conversion (const std::string& id, const std::string& from,
                            const std::string& to);
 
 extern OCTINTERP_API void
 gripe_divide_by_zero (void);
 
 extern OCTINTERP_API void
 gripe_logical_conversion (void);
 
-extern OCTINTERP_API void
-gripe_invalid_inquiry_subscript (void) GCC_ATTR_NORETURN;
+extern OCTINTERP_API void GCC_ATTR_NORETURN
+gripe_invalid_inquiry_subscript (void);
 
-extern OCTINTERP_API void
-gripe_indexed_cs_list (void) GCC_ATTR_NORETURN;
+extern OCTINTERP_API void GCC_ATTR_NORETURN
+gripe_indexed_cs_list (void);
 
-extern OCTINTERP_API void
-gripe_nonbraced_cs_list_assignment (void) GCC_ATTR_NORETURN;
+extern OCTINTERP_API void GCC_ATTR_NORETURN
+gripe_nonbraced_cs_list_assignment (void);
 
 extern OCTINTERP_API void
 gripe_warn_complex_cmp (void);
 
-extern OCTINTERP_API void
+extern OCTINTERP_API void GCC_ATTR_NORETURN
 gripe_disabled_feature (const std::string& func, const std::string& feature,
-                        const std::string& pkg="Octave") GCC_ATTR_NORETURN;
+                        const std::string& pkg="Octave");
 
 extern OCTINTERP_API void
 gripe_data_file_in_path (const std::string& fcn, const std::string& file);
 
 #endif
diff --git a/libinterp/corefcn/hess.cc b/libinterp/corefcn/hess.cc
--- a/libinterp/corefcn/hess.cc
+++ b/libinterp/corefcn/hess.cc
@@ -75,20 +75,17 @@ IEEE Transactions on Automatic Control, 
   int arg_is_empty = empty_arg ("hess", nr, nc);
 
   if (arg_is_empty < 0)
     return ovl ();
   else if (arg_is_empty > 0)
     return octave_value_list (2, Matrix ());
 
   if (nr != nc)
-    {
-      gripe_square_matrix_required ("hess");
-      return ovl ();
-    }
+    gripe_square_matrix_required ("hess");
 
   octave_value_list retval;
 
   if (arg.is_single_type ())
     {
       if (arg.is_real_type ())
         {
           FloatMatrix tmp = arg.float_matrix_value ();
diff --git a/libinterp/corefcn/inv.cc b/libinterp/corefcn/inv.cc
--- a/libinterp/corefcn/inv.cc
+++ b/libinterp/corefcn/inv.cc
@@ -69,20 +69,17 @@ sparse matrix if possible.\n\
   int arg_is_empty = empty_arg ("inverse", nr, nc);
 
   if (arg_is_empty < 0)
     return ovl ();
   else if (arg_is_empty > 0)
     return octave_value (Matrix ());
 
   if (nr != nc)
-    {
-      gripe_square_matrix_required ("inverse");
-      return ovl ();
-    }
+    gripe_square_matrix_required ("inverse");
 
   octave_value result;
   octave_idx_type info;
   double rcond = 0.0;
   float frcond = 0.0;
   bool isfloat = arg.is_single_type ();
 
   if (arg.is_diag_matrix ())
diff --git a/libinterp/corefcn/jit-typeinfo.cc b/libinterp/corefcn/jit-typeinfo.cc
--- a/libinterp/corefcn/jit-typeinfo.cc
+++ b/libinterp/corefcn/jit-typeinfo.cc
@@ -434,17 +434,17 @@ octave_jit_pow_scalar_complex (double lh
 }
 
 extern "C" void
 octave_jit_print_matrix (jit_matrix *m)
 {
   std::cout << *m << std::endl;
 }
 
-static void
+static void GCC_ATTR_NORETURN
 gripe_bad_result (void)
 {
   error ("incorrect type information given to the JIT compiler");
 }
 
 // FIXME: Add support for multiple outputs
 extern "C" octave_base_value *
 octave_jit_call (octave_builtin::fcn fn, size_t nargin,
@@ -455,20 +455,17 @@ octave_jit_call (octave_builtin::fcn fn,
     ovl.xelem (i) = octave_value (argin[i]);
 
   ovl = fn (ovl, 1);
 
   // FIXME: Check result_type somehow
   if (result_type)
     {
       if (ovl.length () < 1)
-        {
-          gripe_bad_result ();
-          return 0;
-        }
+        gripe_bad_result ();
 
       octave_value result = ovl.xelem(0);
       octave_base_value *ret = result.internal_rep ();
       ret->grab ();
       return ret;
     }
 
   if (! (ovl.length () == 0
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -121,17 +121,17 @@ default_save_header_format (void)
     + std::string (">");
 }
 
 // The format string for the comment line at the top of text-format
 // save files.  Passed to strftime.  Should begin with '#' and contain
 // no newline characters.
 static std::string Vsave_header_format_string = default_save_header_format ();
 
-static void
+static void GCC_ATTR_NORETURN
 gripe_file_open (const std::string& fcn, const std::string& file)
 {
   if (fcn == "load")
     error ("%s: unable to open input file '%s'", fcn.c_str (), file.c_str ());
   else if (fcn == "save")
     error ("%s: unable to open output file '%s'", fcn.c_str (), file.c_str ());
   else
     error ("%s: unable to open file '%s'", fcn.c_str (), file.c_str ());
@@ -1668,20 +1668,17 @@ the file @file{data} in Octave's binary 
           if (hdf5_file.file_id != -1)
             {
               save_vars (argv, i, argc, hdf5_file, format,
                          save_as_floats, write_header_info);
 
               hdf5_file.close ();
             }
           else
-            {
-              gripe_file_open ("save", fname);
-              return retval;
-            }
+            gripe_file_open ("save", fname);
         }
       else
 #endif
         // don't insert any statements here!  The brace below must go
         // with the "else" above!
         {
 #ifdef HAVE_ZLIB
           if (use_zlib)
@@ -1693,40 +1690,34 @@ the file @file{data} in Octave's binary 
                   bool write_header_info = ! file.tellp ();
 
                   save_vars (argv, i, argc, file, format,
                              save_as_floats, write_header_info);
 
                   file.close ();
                 }
               else
-                {
-                  gripe_file_open ("save", fname);
-                  return retval;
-                }
+                gripe_file_open ("save", fname);
             }
           else
 #endif
             {
               std::ofstream file (fname.c_str (), mode);
 
               if (file)
                 {
                   bool write_header_info = ! file.tellp ();
 
                   save_vars (argv, i, argc, file, format,
                              save_as_floats, write_header_info);
 
                   file.close ();
                 }
               else
-                {
-                  gripe_file_open ("save", fname);
-                  return retval;
-                }
+                gripe_file_open ("save", fname);
             }
         }
     }
 
   return retval;
 }
 
 DEFUN (crash_dumps_octave_core, args, nargout,
diff --git a/libinterp/corefcn/qz.cc b/libinterp/corefcn/qz.cc
--- a/libinterp/corefcn/qz.cc
+++ b/libinterp/corefcn/qz.cc
@@ -464,40 +464,34 @@ compatibility with @sc{matlab}.\n\
       return retval;
     }
   else if (arg_is_empty > 0)
     {
       gripe_empty_arg ("qz: parameter 1; continuing", 0);
       return octave_value_list (2, Matrix ());
     }
   else if (args(0).columns () != nn)
-    {
-      gripe_square_matrix_required ("qz");
-      return retval;
-    }
+    gripe_square_matrix_required ("qz");
 
   // Argument 1: dimensions look good; get the value.
   Matrix aa;
   ComplexMatrix caa;
 
   if (args(0).is_complex_type ())
     caa = args(0).complex_matrix_value ();
   else
     aa = args(0).matrix_value ();
 
 #ifdef DEBUG
   std::cout << "qz: check argument 2" << std::endl;
 #endif
 
   // Extract argument 2 (bb, or cbb if complex).
   if ((nn != args(1).columns ()) || (nn != args(1).rows ()))
-    {
-      gripe_nonconformant ();
-      return retval;
-    }
+    gripe_nonconformant ();
 
   Matrix bb;
   ComplexMatrix cbb;
 
   if (args(1).is_complex_type ())
     cbb = args(1).complex_matrix_value ();
   else
     bb = args(1).matrix_value ();
diff --git a/libinterp/corefcn/schur.cc b/libinterp/corefcn/schur.cc
--- a/libinterp/corefcn/schur.cc
+++ b/libinterp/corefcn/schur.cc
@@ -162,20 +162,17 @@ in control (see @code{are} and @code{dar
           return ovl ();
         }
     }
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (nr != nc)
-    {
-      gripe_square_matrix_required ("schur");
-      return ovl ();
-    }
+    gripe_square_matrix_required ("schur");
 
   octave_value_list retval;
 
   if (! arg.is_numeric_type ())
     gripe_wrong_type_arg ("schur", arg);
   else if (arg.is_single_type ())
     {
       if (! force_complex && arg.is_real_type ())
diff --git a/libinterp/corefcn/sparse-xdiv.cc b/libinterp/corefcn/sparse-xdiv.cc
--- a/libinterp/corefcn/sparse-xdiv.cc
+++ b/libinterp/corefcn/sparse-xdiv.cc
@@ -55,17 +55,16 @@ mx_leftdiv_conform (const T1& a, const T
   octave_idx_type b_nr = b.rows ();
 
   if (a_nr != b_nr)
     {
       octave_idx_type a_nc = a.cols ();
       octave_idx_type b_nc = b.cols ();
 
       gripe_nonconformant ("operator \\", a_nr, a_nc, b_nr, b_nc);
-      return false;
     }
 
   return true;
 }
 
 #define INSTANTIATE_MX_LEFTDIV_CONFORM(T1, T2) \
   template bool mx_leftdiv_conform (const T1&, const T2&)
 
@@ -90,17 +89,16 @@ mx_div_conform (const T1& a, const T2& b
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nc)
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type b_nr = b.rows ();
 
       gripe_nonconformant ("operator /", a_nr, a_nc, b_nr, b_nc);
-      return false;
     }
 
   return true;
 }
 
 #define INSTANTIATE_MX_DIV_CONFORM(T1, T2) \
   template bool mx_div_conform (const T1&, const T2&)
 
diff --git a/libinterp/corefcn/sparse-xpow.cc b/libinterp/corefcn/sparse-xpow.cc
--- a/libinterp/corefcn/sparse-xpow.cc
+++ b/libinterp/corefcn/sparse-xpow.cc
@@ -414,20 +414,17 @@ elem_xpow (const SparseMatrix& a, const 
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a.numel () == 1 && b.numel () > 1)
     return scalar_xpow (a(0), b);
 
   if (nr != b_nr || nc != b_nc)
-    {
-      gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
-      return octave_value ();
-    }
+    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   int convert_to_complex = 0;
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
       {
         if (a.data(i) < 0.0)
           {
             double btmp = b (a.ridx (i), j);
@@ -519,20 +516,17 @@ elem_xpow (const SparseMatrix& a, const 
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a.numel () == 1 && b.numel () > 1)
     return scalar_xpow (a(0), b);
 
   if (nr != b_nr || nc != b_nc)
-    {
-      gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
-      return octave_value ();
-    }
+    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   SparseComplexMatrix result (nr, nc, Complex (1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
         {
           octave_quit ();
           result.xelem (a.ridx(i), j) = std::pow (a.data (i), b(a.ridx (i), j));
@@ -662,20 +656,17 @@ elem_xpow (const SparseComplexMatrix& a,
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a.numel () == 1 && b.numel () > 1)
     return scalar_xpow (a(0), b);
 
   if (nr != b_nr || nc != b_nc)
-    {
-      gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
-      return octave_value ();
-    }
+    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   SparseComplexMatrix result (nr, nc, Complex (1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
         {
           octave_quit ();
           double btmp = b(a.ridx (i), j);
@@ -733,20 +724,17 @@ elem_xpow (const SparseComplexMatrix& a,
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (a.numel () == 1 && b.numel () > 1)
     return scalar_xpow (a(0), b);
 
   if (nr != b_nr || nc != b_nc)
-    {
-      gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
-      return octave_value ();
-    }
+    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   SparseComplexMatrix result (nr, nc, Complex (1.0, 0.0));
   for (octave_idx_type j = 0; j < nc; j++)
     {
       for (octave_idx_type i = a.cidx (j); i < a.cidx (j+1); i++)
         {
           octave_quit ();
           result.xelem (a.ridx (i), j) = std::pow (a.data (i),
diff --git a/libinterp/corefcn/sylvester.cc b/libinterp/corefcn/sylvester.cc
--- a/libinterp/corefcn/sylvester.cc
+++ b/libinterp/corefcn/sylvester.cc
@@ -92,30 +92,21 @@ sylvester ([1, 2; 3, 4], [5, 6; 7, 8], [
     else
       return ovl (Matrix ());
   else if (arg_a_is_empty || arg_b_is_empty || arg_c_is_empty)
     return retval;
 
   // Arguments are not empty, so check for correct dimensions.
 
   if (a_nr != a_nc)
-    {
-      gripe_square_matrix_required ("sylvester: input A");
-      return retval;
-    }
+    gripe_square_matrix_required ("sylvester: input A");
   else if (b_nr != b_nc)
-    {
-      gripe_square_matrix_required ("sylvester: input B");
-      return retval;
-    }
+    gripe_square_matrix_required ("sylvester: input B");
   else if (a_nr != c_nr || b_nr != c_nc)
-    {
-      gripe_nonconformant ();
-      return retval;
-    }
+    gripe_nonconformant ();
 
   if (isfloat)
     {
       if (arg_a.is_complex_type ()
           || arg_b.is_complex_type ()
           || arg_c.is_complex_type ())
         {
           // Do everything in complex arithmetic;
diff --git a/libinterp/corefcn/xdiv.cc b/libinterp/corefcn/xdiv.cc
--- a/libinterp/corefcn/xdiv.cc
+++ b/libinterp/corefcn/xdiv.cc
@@ -71,17 +71,16 @@ mx_leftdiv_conform (const T1& a, const T
 
   if (a_nr != b_nr)
     {
       octave_idx_type a_nc = blas_trans == blas_no_trans ? a.cols ()
                                                          : a.rows ();
       octave_idx_type b_nc = b.cols ();
 
       gripe_nonconformant ("operator \\", a_nr, a_nc, b_nr, b_nc);
-      return false;
     }
 
   return true;
 }
 
 #define INSTANTIATE_MX_LEFTDIV_CONFORM(T1, T2) \
   template bool mx_leftdiv_conform (const T1&, const T2&, blas_trans_type)
 
@@ -98,17 +97,16 @@ mx_div_conform (const T1& a, const T2& b
   octave_idx_type b_nc = b.cols ();
 
   if (a_nc != b_nc)
     {
       octave_idx_type a_nr = a.rows ();
       octave_idx_type b_nr = b.rows ();
 
       gripe_nonconformant ("operator /", a_nr, a_nc, b_nr, b_nc);
-      return false;
     }
 
   return true;
 }
 
 #define INSTANTIATE_MX_DIV_CONFORM(T1, T2) \
   template bool mx_div_conform (const T1&, const T2&)
 
diff --git a/libinterp/corefcn/xpow.cc b/libinterp/corefcn/xpow.cc
--- a/libinterp/corefcn/xpow.cc
+++ b/libinterp/corefcn/xpow.cc
@@ -808,20 +808,17 @@ elem_xpow (const Matrix& a, const Matrix
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    {
-      gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
-      return octave_value ();
-    }
+    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   int convert_to_complex = 0;
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         double atmp = a (i, j);
         double btmp = b (i, j);
@@ -891,20 +888,17 @@ elem_xpow (const Matrix& a, const Comple
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    {
-      gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
-      return octave_value ();
-    }
+    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         result (i, j) = std::pow (Complex (a (i, j)), b (i, j));
@@ -1032,20 +1026,17 @@ elem_xpow (const ComplexMatrix& a, const
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    {
-      gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
-      return octave_value ();
-    }
+    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         double btmp = b (i, j);
@@ -1083,20 +1074,17 @@ elem_xpow (const ComplexMatrix& a, const
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    {
-      gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
-      return octave_value ();
-    }
+    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   ComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         result (i, j) = std::pow (a (i, j), b (i, j));
@@ -1268,20 +1256,17 @@ elem_xpow (const NDArray& a, const NDArr
           NDArray xa = octave_value_extract<NDArray> (a);
           NDArray xb = octave_value_extract<NDArray> (b);
           if (! xb.all_integers () && xa.any_element_is_negative ())
             return octave_value (bsxfun_pow (ComplexNDArray (xa), xb));
           else
             return octave_value (bsxfun_pow (xa, xb));
         }
       else
-        {
-          gripe_nonconformant ("operator .^", a_dims, b_dims);
-          return octave_value ();
-        }
+        gripe_nonconformant ("operator .^", a_dims, b_dims);
     }
 
   int len = a.numel ();
 
   bool convert_to_complex = false;
 
   for (octave_idx_type i = 0; i < len; i++)
     {
@@ -1350,20 +1335,17 @@ elem_xpow (const NDArray& a, const Compl
 
   if (a_dims != b_dims)
     {
       if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           return bsxfun_pow (a, b);
         }
       else
-        {
-          gripe_nonconformant ("operator .^", a_dims, b_dims);
-          return octave_value ();
-        }
+        gripe_nonconformant ("operator .^", a_dims, b_dims);
     }
 
   ComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
@@ -1449,20 +1431,17 @@ elem_xpow (const ComplexNDArray& a, cons
 
   if (a_dims != b_dims)
     {
       if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           return bsxfun_pow (a, b);
         }
       else
-        {
-          gripe_nonconformant ("operator .^", a_dims, b_dims);
-          return octave_value ();
-        }
+        gripe_nonconformant ("operator .^", a_dims, b_dims);
     }
 
   ComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       double btmp = b(i);
@@ -1499,20 +1478,17 @@ elem_xpow (const ComplexNDArray& a, cons
 
   if (a_dims != b_dims)
     {
       if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           return bsxfun_pow (a, b);
         }
       else
-        {
-          gripe_nonconformant ("operator .^", a_dims, b_dims);
-          return octave_value ();
-        }
+        gripe_nonconformant ("operator .^", a_dims, b_dims);
     }
 
   ComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
@@ -2214,20 +2190,17 @@ elem_xpow (const FloatMatrix& a, const F
 
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    {
-      gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
-      return octave_value ();
-    }
+    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   int convert_to_complex = 0;
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         float atmp = a (i, j);
         float btmp = b (i, j);
@@ -2297,20 +2270,17 @@ elem_xpow (const FloatMatrix& a, const F
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    {
-      gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
-      return octave_value ();
-    }
+    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         result (i, j) = std::pow (FloatComplex (a (i, j)), b (i, j));
@@ -2398,20 +2368,17 @@ elem_xpow (const FloatComplexMatrix& a, 
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    {
-      gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
-      return octave_value ();
-    }
+    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         float btmp = b (i, j);
@@ -2449,20 +2416,17 @@ elem_xpow (const FloatComplexMatrix& a, 
 {
   octave_idx_type nr = a.rows ();
   octave_idx_type nc = a.cols ();
 
   octave_idx_type b_nr = b.rows ();
   octave_idx_type b_nc = b.cols ();
 
   if (nr != b_nr || nc != b_nc)
-    {
-      gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
-      return octave_value ();
-    }
+    gripe_nonconformant ("operator .^", nr, nc, b_nr, b_nc);
 
   FloatComplexMatrix result (nr, nc);
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
       {
         octave_quit ();
         result (i, j) = std::pow (a (i, j), b (i, j));
@@ -2634,20 +2598,17 @@ elem_xpow (const FloatNDArray& a, const 
           FloatNDArray xa = octave_value_extract<FloatNDArray> (a);
           FloatNDArray xb = octave_value_extract<FloatNDArray> (b);
           if (! xb.all_integers () && xa.any_element_is_negative ())
             return octave_value (bsxfun_pow (FloatComplexNDArray (xa), xb));
           else
             return octave_value (bsxfun_pow (xa, xb));
         }
       else
-        {
-          gripe_nonconformant ("operator .^", a_dims, b_dims);
-          return octave_value ();
-        }
+        gripe_nonconformant ("operator .^", a_dims, b_dims);
     }
 
   int len = a.numel ();
 
   bool convert_to_complex = false;
 
   for (octave_idx_type i = 0; i < len; i++)
     {
@@ -2716,20 +2677,17 @@ elem_xpow (const FloatNDArray& a, const 
 
   if (a_dims != b_dims)
     {
       if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           return bsxfun_pow (a, b);
         }
       else
-        {
-          gripe_nonconformant ("operator .^", a_dims, b_dims);
-          return octave_value ();
-        }
+        gripe_nonconformant ("operator .^", a_dims, b_dims);
     }
 
   FloatComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
@@ -2815,20 +2773,17 @@ elem_xpow (const FloatComplexNDArray& a,
 
   if (a_dims != b_dims)
     {
       if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           return bsxfun_pow (a, b);
         }
       else
-        {
-          gripe_nonconformant ("operator .^", a_dims, b_dims);
-          return octave_value ();
-        }
+        gripe_nonconformant ("operator .^", a_dims, b_dims);
     }
 
   FloatComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       float btmp = b(i);
@@ -2865,20 +2820,17 @@ elem_xpow (const FloatComplexNDArray& a,
 
   if (a_dims != b_dims)
     {
       if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
         {
           return bsxfun_pow (a, b);
         }
       else
-        {
-          gripe_nonconformant ("operator .^", a_dims, b_dims);
-          return octave_value ();
-        }
+        gripe_nonconformant ("operator .^", a_dims, b_dims);
     }
 
   FloatComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
diff --git a/libinterp/dldfcn/symrcm.cc b/libinterp/dldfcn/symrcm.cc
--- a/libinterp/dldfcn/symrcm.cc
+++ b/libinterp/dldfcn/symrcm.cc
@@ -464,20 +464,17 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
       cidx = Ac.xcidx ();
       ridx = Ac.xridx ();
     }
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (nr != nc)
-    {
-      gripe_square_matrix_required ("symrcm");
-      return retval;
-    }
+    gripe_square_matrix_required ("symrcm");
 
   if (nr == 0 && nc == 0)
     return ovl (NDArray (dim_vector (1, 0)));
 
   // sizes of the heaps
   octave_idx_type s = 0;
 
   // head- and tail-indices for the queue
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -210,17 +210,16 @@ octave_base_value::do_multi_index_op (in
   return do_multi_index_op (nargout, idx);
 }
 
 idx_vector
 octave_base_value::index_vector (bool /* require_integers */) const
 {
   std::string nm = "<" + type_name () + ">";
   gripe_invalid_index (nm.c_str ());
-  return idx_vector ();
 }
 
 octave_value
 octave_base_value::subsasgn (const std::string& type,
                              const std::list<octave_value_list>& idx,
                              const octave_value& rhs)
 {
   octave_value retval;
@@ -381,18 +380,17 @@ octave_base_value::convert_to_str_intern
                         type_name ());
   return octave_value ();
 }
 
 void
 octave_base_value::convert_to_row_or_column_vector (void)
 {
   gripe_wrong_type_arg
-    ("octave_base_value::convert_to_row_or_column_vector ()",
-     type_name ());
+    ("octave_base_value::convert_to_row_or_column_vector ()", type_name ());
 }
 
 void
 octave_base_value::print (std::ostream&, bool)
 {
   gripe_wrong_type_arg ("octave_base_value::print ()", type_name ());
 }
 
@@ -1294,32 +1292,31 @@ octave_base_value::dump (std::ostream& o
 {
   dim_vector dv = this->dims ();
 
   os << "class: " << this->class_name ()
      << " type: " << this->type_name ()
      << " dims: " << dv.str ();
 }
 
-static void
+static void GCC_ATTR_NORETURN
 gripe_indexed_assignment (const std::string& tn1, const std::string& tn2)
 {
   error ("assignment of '%s' to indexed '%s' not implemented",
          tn2.c_str (), tn1.c_str ());
 }
 
-static void
-gripe_assign_conversion_failed (const std::string& tn1,
-                                const std::string& tn2)
+static void GCC_ATTR_NORETURN
+gripe_assign_conversion_failed (const std::string& tn1, const std::string& tn2)
 {
   error ("type conversion for assignment of '%s' to indexed '%s' failed",
          tn2.c_str (), tn1.c_str ());
 }
 
-static void
+static void GCC_ATTR_NORETURN
 gripe_no_conversion (const std::string& on, const std::string& tn1,
                      const std::string& tn2)
 {
   error ("operator %s: no conversion for assignment of '%s' to indexed '%s'",
          on.c_str (), tn2.c_str (), tn1.c_str ());
 }
 
 octave_value
@@ -1410,40 +1407,34 @@ octave_base_value::numeric_assign (const
 
           if (cf_rhs)
             {
               octave_base_value *tmp = cf_rhs (rhs.get_rep ());
 
               if (tmp)
                 tmp_rhs = octave_value (tmp);
               else
-                {
-                  gripe_assign_conversion_failed (type_name (),
-                                                  rhs.type_name ());
-                  return octave_value ();
-                }
+                gripe_assign_conversion_failed (type_name (),
+                                                rhs.type_name ());
             }
           else
             tmp_rhs = rhs;
 
           count++;
           octave_value tmp_lhs = octave_value (this);
 
           if (cf_this)
             {
               octave_base_value *tmp = cf_this (*this);
 
               if (tmp)
                 tmp_lhs = octave_value (tmp);
               else
-                {
-                  gripe_assign_conversion_failed (type_name (),
-                                                  rhs.type_name ());
-                  return octave_value ();
-                }
+                gripe_assign_conversion_failed (type_name (),
+                                                rhs.type_name ());
             }
 
           if (cf_this || cf_rhs)
             {
               retval = tmp_lhs.subsasgn (type, idx, tmp_rhs);
 
               done = true;
             }
@@ -1494,17 +1485,17 @@ octave_base_value::indent (std::ostream&
 void
 octave_base_value::newline (std::ostream& os) const
 {
   os << "\n";
 
   beginning_of_line = true;
 }
 
-// For ressetting print state.
+// For resetting print state.
 
 void
 octave_base_value::reset (void) const
 {
   beginning_of_line = true;
   curr_print_indent_level = 0;
 }
 
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -233,29 +233,29 @@ octave_class::get_current_method_class (
       // for any class, not specifically this one.
       if (fcn && (fcn->is_class_method () || fcn->is_class_constructor ()))
         retval = fcn->dispatch_class ();
     }
 
   return retval;
 }
 
-static void
+static void GCC_ATTR_NORETURN
 gripe_invalid_index1 (void)
 {
   error ("invalid index for class");
 }
 
-static void
+static void GCC_ATTR_NORETURN
 gripe_invalid_index_for_assignment (void)
 {
   error ("invalid index for class assignment");
 }
 
-static void
+static void GCC_ATTR_NORETURN 
 gripe_invalid_index_type (const std::string& nm, char t)
 {
   error ("%s cannot be indexed with %c", nm.c_str (), t);
 }
 
 Cell
 octave_class::dotref (const octave_value_list& idx)
 {
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -57,107 +57,102 @@ public:
   virtual cdef_class get_class (void) const;
 
   virtual void set_class (const cdef_class&)
   { gripe_invalid_object ("set_class"); }
 
   virtual cdef_object_rep* clone (void) const
   {
     gripe_invalid_object ("clone");
-    return new cdef_object_rep ();
   }
 
   virtual cdef_object_rep* empty_clone (void) const
   {
     gripe_invalid_object ("empty_clone");
-    return new cdef_object_rep ();
   }
 
   virtual cdef_object_rep* copy (void) const
   {
     gripe_invalid_object ("copy");
-    return new cdef_object_rep ();
   }
 
   virtual cdef_object_rep* make_array (void) const
   {
     gripe_invalid_object ("make_array");
-    return new cdef_object_rep ();
   }
 
   virtual bool is_array (void) const { return false; }
 
   virtual bool is_value_object (void) const { return false; }
 
   virtual bool is_handle_object (void) const { return false; }
 
   virtual bool is_meta_object (void) const { return false; }
 
   virtual Array<cdef_object> array_value (void) const
   {
     gripe_invalid_object ("array_value");
-    return Array<cdef_object> ();
   }
 
   virtual void put (const std::string&, const octave_value&)
   { gripe_invalid_object ("put"); }
 
   virtual octave_value get (const std::string&) const
   {
     gripe_invalid_object ("get");
-    return octave_value ();
   }
 
   virtual octave_value_list
   subsref (const std::string&, const std::list<octave_value_list>&,
            int, size_t&, const cdef_class&, bool)
   {
     gripe_invalid_object ("subsref");
-    return ovl ();
   }
 
   virtual octave_value
   subsasgn (const std::string&, const std::list<octave_value_list>&,
             const octave_value&)
   {
     gripe_invalid_object ("subsasgn");
-    return octave_value ();
   }
 
   virtual string_vector map_keys (void) const;
 
   virtual bool is_valid (void) const { return false; }
 
   std::string class_name (void) const;
 
   virtual void mark_for_construction (const cdef_class&)
-  { gripe_invalid_object ("mark_for_construction"); }
+  {
+    gripe_invalid_object ("mark_for_construction");
+  }
 
   virtual bool is_constructed_for (const cdef_class&) const
   {
     gripe_invalid_object ("is_constructed_for");
-    return false;
   }
 
   virtual bool is_partially_constructed_for (const cdef_class&) const
   {
     gripe_invalid_object ("is_partially_constructed_for");
-    return false;
   }
 
   virtual void mark_as_constructed (void)
-  { gripe_invalid_object ("mark_as_constructed"); }
+  {
+    gripe_invalid_object ("mark_as_constructed");
+  }
 
   virtual void mark_as_constructed (const cdef_class&)
-  { gripe_invalid_object ("mark_as_constructed"); }
+  {
+    gripe_invalid_object ("mark_as_constructed");
+  }
 
   virtual bool is_constructed (void) const
   {
     gripe_invalid_object ("is_constructed");
-    return false;
   }
 
   virtual octave_idx_type static_count (void) const { return 0; }
 
   virtual void destroy (void) { delete this; }
 
   void release (void)
   {
@@ -175,17 +170,17 @@ protected:
   // Restricted copying
   cdef_object_rep (const cdef_object_rep&)
     : refcount (1) { }
 
 private:
   // No assignment
   cdef_object_rep& operator = (const cdef_object_rep& );
 
-  void gripe_invalid_object (const char *who) const
+  void GCC_ATTR_NORETURN gripe_invalid_object (const char *who) const
   { error ("%s: invalid object", who); }
 };
 
 class
 cdef_object
 {
 public:
   // FIXME: use a null object
@@ -1164,17 +1159,16 @@ private:
   const cdef_method_rep* get_rep (void) const
   { return dynamic_cast<const cdef_method_rep *> (cdef_object::get_rep ()); }
 };
 
 inline cdef_class
 cdef_object_rep::get_class (void) const
 {
   gripe_invalid_object ("get_class");
-  return cdef_class ();
 }
 
 inline std::string
 cdef_object_rep::class_name (void) const
 { return get_class ().get_name (); }
 
 inline cdef_class
 cdef_object::get_class (void) const
diff --git a/libinterp/octave-value/ov-cs-list.cc b/libinterp/octave-value/ov-cs-list.cc
--- a/libinterp/octave-value/ov-cs-list.cc
+++ b/libinterp/octave-value/ov-cs-list.cc
@@ -43,19 +43,17 @@ octave_cs_list::octave_cs_list (const Ce
 {
 }
 
 octave_value
 octave_cs_list::subsref (const std::string&,
                          const std::list<octave_value_list>&)
 {
   gripe_indexed_cs_list ();
-  return octave_value ();
 }
 
 octave_value_list
 octave_cs_list::subsref (const std::string&,
                          const std::list<octave_value_list>&, int)
 {
   gripe_indexed_cs_list ();
-  return ovl ();
 }
 
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -285,20 +285,17 @@ octave_float_matrix::convert_to_str_inte
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       octave_quit ();
 
       float d = matrix (i);
 
       if (xisnan (d))
-        {
-          gripe_nan_to_character_conversion ();
-          return retval;
-        }
+        gripe_nan_to_character_conversion ();
       else
         {
           int ival = NINT (d);
 
           if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
             {
               // FIXME: is there something better we could do?
 
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -387,20 +387,17 @@ octave_matrix::convert_to_str_internal (
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       octave_quit ();
 
       double d = matrix (i);
 
       if (xisnan (d))
-        {
-          gripe_nan_to_character_conversion ();
-          return retval;
-        }
+        gripe_nan_to_character_conversion ();
       else
         {
           int ival = NINT (d);
 
           if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
             {
               // FIXME: is there something better we could do?
 
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -58,17 +58,16 @@ idx_vector
 octave_sparse_matrix::index_vector (bool /* require_integers */) const
 {
   if (matrix.numel () == matrix.nnz ())
     return idx_vector (array_value ());
   else
     {
       std::string nm = "<" + type_name () + ">";
       gripe_invalid_index (nm.c_str ());
-      return idx_vector ();
     }
 }
 
 octave_base_value *
 octave_sparse_matrix::try_narrowing_conversion (void)
 {
   octave_base_value *retval = 0;
 
@@ -220,20 +219,17 @@ octave_sparse_matrix::convert_to_str_int
         for (octave_idx_type i = matrix.cidx (j);
              i < matrix.cidx (j+1); i++)
           {
             octave_quit ();
 
             double d = matrix.data (i);
 
             if (xisnan (d))
-              {
-                gripe_nan_to_character_conversion ();
-                return retval;
-              }
+              gripe_nan_to_character_conversion ();
             else
               {
                 int ival = NINT (d);
 
                 if (ival < 0
                     || ival > std::numeric_limits<unsigned char>::max ())
                   {
                     // FIXME: is there something better we could do?
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2118,38 +2118,32 @@ do_binary_op (octave_value::binary_op op
               octave_base_value *tmp = cf1 (*v1.rep);
 
               if (tmp)
                 {
                   tv1 = octave_value (tmp);
                   t1 = tv1.type_id ();
                 }
               else
-                {
-                  gripe_binary_op_conv (octave_value::binary_op_as_string (op));
-                  return retval;
-                }
+                gripe_binary_op_conv (octave_value::binary_op_as_string (op));
             }
           else
             tv1 = v1;
 
           if (cf2)
             {
               octave_base_value *tmp = cf2 (*v2.rep);
 
               if (tmp)
                 {
                   tv2 = octave_value (tmp);
                   t2 = tv2.type_id ();
                 }
               else
-                {
-                  gripe_binary_op_conv (octave_value::binary_op_as_string (op));
-                  return retval;
-                }
+                gripe_binary_op_conv (octave_value::binary_op_as_string (op));
             }
           else
             tv2 = v2;
 
           if (cf1 || cf2)
             {
               retval = do_binary_op (op, tv1, tv2);
             }
@@ -2176,38 +2170,32 @@ do_binary_op (octave_value::binary_op op
                   octave_base_value *tmp = cf1 (*tv1.rep);
 
                   if (tmp)
                     {
                       tv1 = octave_value (tmp);
                       t1 = tv1.type_id ();
                     }
                   else
-                    {
-                      gripe_binary_op_conv
-                        (octave_value::binary_op_as_string (op));
-                      return retval;
-                    }
+                    gripe_binary_op_conv
+                      (octave_value::binary_op_as_string (op));
                 }
 
               if (cf2)
                 {
                   octave_base_value *tmp = cf2 (*tv2.rep);
 
                   if (tmp)
                     {
                       tv2 = octave_value (tmp);
                       t2 = tv2.type_id ();
                     }
                   else
-                    {
-                      gripe_binary_op_conv
-                        (octave_value::binary_op_as_string (op));
-                      return retval;
-                    }
+                    gripe_binary_op_conv
+                      (octave_value::binary_op_as_string (op));
                 }
 
               if (cf1 || cf2)
                 {
                   f = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
 
                   if (f)
                     retval = f (*tv1.rep, *tv2.rep);
@@ -2322,24 +2310,24 @@ do_binary_op (octave_value::compound_bin
         retval = f (*v1.rep, *v2.rep);
       else
         retval = decompose_binary_op (op, v1, v2);
     }
 
   return retval;
 }
 
-static void
+static void GCC_ATTR_NORETURN
 gripe_cat_op (const std::string& tn1, const std::string& tn2)
 {
   error ("concatenation operator not implemented for '%s' by '%s' operations",
          tn1.c_str (), tn2.c_str ());
 }
 
-static void
+static void GCC_ATTR_NORETURN
 gripe_cat_op_conv (void)
 {
   error ("type conversion failed for concatenation operator");
 }
 
 octave_value
 do_cat_op (const octave_value& v1, const octave_value& v2,
            const Array<octave_idx_type>& ra_idx)
@@ -2378,38 +2366,32 @@ do_cat_op (const octave_value& v1, const
           octave_base_value *tmp = cf1 (*v1.rep);
 
           if (tmp)
             {
               tv1 = octave_value (tmp);
               t1 = tv1.type_id ();
             }
           else
-            {
-              gripe_cat_op_conv ();
-              return retval;
-            }
+            gripe_cat_op_conv ();
         }
       else
         tv1 = v1;
 
       if (cf2)
         {
           octave_base_value *tmp = cf2 (*v2.rep);
 
           if (tmp)
             {
               tv2 = octave_value (tmp);
               t2 = tv2.type_id ();
             }
           else
-            {
-              gripe_cat_op_conv ();
-              return retval;
-            }
+            gripe_cat_op_conv ();
         }
       else
         tv2 = v2;
 
       if (cf1 || cf2)
         {
           retval = do_cat_op (tv1, tv2, ra_idx);
         }
diff --git a/libinterp/operators/op-cs-cs.cc b/libinterp/operators/op-cs-cs.cc
--- a/libinterp/operators/op-cs-cs.cc
+++ b/libinterp/operators/op-cs-cs.cc
@@ -41,16 +41,17 @@ along with Octave; see the file COPYING.
 // unary complex scalar ops.
 
 DEFUNOP (not, complex)
 {
   CAST_UNOP_ARG (const octave_complex&);
   Complex x = v.complex_value ();
   if (xisnan (x))
     gripe_nan_to_logical_conversion ();
+
   return octave_value (x == 0.0);
 }
 
 DEFUNOP_OP (uplus, complex, /* no-op */)
 DEFUNOP_OP (uminus, complex, -)
 DEFUNOP_OP (transpose, complex, /* no-op */)
 
 DEFUNOP (hermitian, complex)
diff --git a/libinterp/operators/op-dms-template.cc b/libinterp/operators/op-dms-template.cc
--- a/libinterp/operators/op-dms-template.cc
+++ b/libinterp/operators/op-dms-template.cc
@@ -49,16 +49,17 @@ DEFNDBINOP_OP (dmsmul, MATRIX, SCALAR, M
 #define SCALAR_VALUE CONCAT2(SCALARV, _value)
 
 template <class T>
 static T
 gripe_if_zero (T x)
 {
   if (x == T ())
     gripe_divide_by_zero ();
+
   return x;
 }
 
 DEFBINOP (dmsdiv, MATRIX, SCALAR)
 {
   CAST_BINOP_ARGS (const OCTAVE_MATRIX&, const OCTAVE_SCALAR&);
 
   return v1.MATRIX_VALUE () / gripe_if_zero (v2.SCALAR_VALUE ());
diff --git a/libinterp/operators/op-fcs-fcs.cc b/libinterp/operators/op-fcs-fcs.cc
--- a/libinterp/operators/op-fcs-fcs.cc
+++ b/libinterp/operators/op-fcs-fcs.cc
@@ -39,16 +39,17 @@ along with Octave; see the file COPYING.
 // unary complex scalar ops.
 
 DEFUNOP (not, float_complex)
 {
   CAST_UNOP_ARG (const octave_float_complex&);
   FloatComplex x = v.float_complex_value ();
   if (xisnan (x))
     gripe_nan_to_logical_conversion ();
+
   return octave_value (x == 0.0f);
 }
 
 DEFUNOP_OP (uplus, float_complex, /* no-op */)
 DEFUNOP_OP (uminus, float_complex, -)
 DEFUNOP_OP (transpose, float_complex, /* no-op */)
 
 DEFUNOP (hermitian, float_complex)
diff --git a/libinterp/operators/op-fs-fs.cc b/libinterp/operators/op-fs-fs.cc
--- a/libinterp/operators/op-fs-fs.cc
+++ b/libinterp/operators/op-fs-fs.cc
@@ -41,16 +41,17 @@ along with Octave; see the file COPYING.
 // scalar unary ops.
 
 DEFUNOP (not, float_scalar)
 {
   CAST_UNOP_ARG (const octave_float_scalar&);
   float x = v.float_value ();
   if (xisnan (x))
     gripe_nan_to_logical_conversion ();
+
   return octave_value (x == 0.0f);
 }
 
 DEFUNOP_OP (uplus, float_scalar, /* no-op */)
 DEFUNOP_OP (uminus, float_scalar, -)
 DEFUNOP_OP (transpose, float_scalar, /* no-op */)
 DEFUNOP_OP (hermitian, float_scalar, /* no-op */)
 
diff --git a/libinterp/operators/op-int.h b/libinterp/operators/op-int.h
--- a/libinterp/operators/op-int.h
+++ b/libinterp/operators/op-int.h
@@ -696,24 +696,19 @@ octave_value elem_xpow (FloatNDArray a, 
   octave_value \
   elem_xpow (const T1 ## NDArray& a, const T2 ## NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
         if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
-          { \
-            return bsxfun_pow (a, b); \
-          } \
+          return bsxfun_pow (a, b); \
         else \
-          { \
-            gripe_nonconformant ("operator .^", a_dims, b_dims);  \
-            return octave_value (); \
-          } \
+          gripe_nonconformant ("operator .^", a_dims, b_dims);  \
       } \
     T1 ## NDArray result (a_dims); \
     for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = pow (a(i), b(i)); \
       } \
     return octave_value (result); \
@@ -722,24 +717,19 @@ octave_value elem_xpow (FloatNDArray a, 
   octave_value \
   elem_xpow (const T1 ## NDArray& a, const NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
         if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
-          { \
-            return bsxfun_pow (a, b); \
-          } \
+          return bsxfun_pow (a, b); \
         else \
-          { \
-            gripe_nonconformant ("operator .^", a_dims, b_dims);  \
-            return octave_value (); \
-          } \
+          gripe_nonconformant ("operator .^", a_dims, b_dims);  \
       } \
     T1 ## NDArray result (a_dims); \
     for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = pow (a(i), b(i)); \
       } \
     return octave_value (result); \
@@ -748,24 +738,19 @@ octave_value elem_xpow (FloatNDArray a, 
   octave_value \
   elem_xpow (const NDArray& a, const T2 ## NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
         if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
-          { \
-            return bsxfun_pow (a, b); \
-          } \
+          return bsxfun_pow (a, b); \
         else \
-          { \
-            gripe_nonconformant ("operator .^", a_dims, b_dims);  \
-            return octave_value (); \
-          } \
+          gripe_nonconformant ("operator .^", a_dims, b_dims);  \
       } \
     T2 ## NDArray result (a_dims); \
     for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = pow (a(i), b(i)); \
       } \
     return octave_value (result); \
@@ -774,24 +759,19 @@ octave_value elem_xpow (FloatNDArray a, 
   octave_value \
   elem_xpow (const T1 ## NDArray& a, const FloatNDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
         if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
-          { \
-            return bsxfun_pow (a, b); \
-          } \
+          return bsxfun_pow (a, b); \
         else \
-          { \
-            gripe_nonconformant ("operator .^", a_dims, b_dims);  \
-            return octave_value (); \
-          } \
+          gripe_nonconformant ("operator .^", a_dims, b_dims);  \
       } \
     T1 ## NDArray result (a_dims); \
     for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = powf (a(i), b(i)); \
       } \
     return octave_value (result); \
@@ -800,24 +780,19 @@ octave_value elem_xpow (FloatNDArray a, 
   octave_value \
   elem_xpow (const FloatNDArray& a, const T2 ## NDArray& b) \
   { \
     dim_vector a_dims = a.dims (); \
     dim_vector b_dims = b.dims (); \
     if (a_dims != b_dims) \
       { \
         if (is_valid_bsxfun ("operator .^", a_dims, b_dims))     \
-          { \
-            return bsxfun_pow (a, b); \
-          } \
+          return bsxfun_pow (a, b); \
         else \
-          { \
-            gripe_nonconformant ("operator .^", a_dims, b_dims);  \
-            return octave_value (); \
-          } \
+          gripe_nonconformant ("operator .^", a_dims, b_dims);  \
       } \
     T2 ## NDArray result (a_dims); \
     for (int i = 0; i < a.numel (); i++) \
       { \
         OCTAVE_QUIT; \
         result (i) = powf (a(i), b(i)); \
       } \
     return octave_value (result); \
diff --git a/libinterp/operators/op-s-s.cc b/libinterp/operators/op-s-s.cc
--- a/libinterp/operators/op-s-s.cc
+++ b/libinterp/operators/op-s-s.cc
@@ -42,16 +42,17 @@ along with Octave; see the file COPYING.
 // scalar unary ops.
 
 DEFUNOP (not, scalar)
 {
   CAST_UNOP_ARG (const octave_scalar&);
   double x = v.scalar_value ();
   if (xisnan (x))
     gripe_nan_to_logical_conversion ();
+
   return octave_value (x == 0.0);
 }
 
 DEFUNOP_OP (uplus, scalar, /* no-op */)
 DEFUNOP_OP (uminus, scalar, -)
 DEFUNOP_OP (transpose, scalar, /* no-op */)
 DEFUNOP_OP (hermitian, scalar, /* no-op */)
 
diff --git a/libinterp/operators/ops.h b/libinterp/operators/ops.h
--- a/libinterp/operators/ops.h
+++ b/libinterp/operators/ops.h
@@ -296,20 +296,17 @@ extern void install_ops (void);
       (v1.CONCAT2(t1, _value) () op v2.CONCAT2(t2, _value) ()); \
   }
 
 #define DEFSCALARBOOLOP_OP(name, t1, t2, op) \
   BINOPDECL (name, a1, a2) \
   { \
     CAST_BINOP_ARGS (const CONCAT2(octave_, t1)&, const CONCAT2(octave_, t2)&); \
     if (xisnan (v1.CONCAT2(t1, _value) ()) || xisnan (v2.CONCAT2(t2, _value) ())) \
-      { \
-        gripe_nan_to_logical_conversion (); \
-        return octave_value (); \
-      } \
+      gripe_nan_to_logical_conversion (); \
     else \
       return octave_value \
         (v1.CONCAT2(t1, _value) () op v2.CONCAT2(t2, _value) ()); \
   }
 
 #define DEFNDBINOP_OP(name, t1, t2, e1, e2, op) \
   BINOPDECL (name, a1, a2) \
   { \
