# HG changeset patch
# User Ryan Rusaw
# Date 1248985599 14400
#      Thu Jul 30 16:26:39 2009 -0400
# Node ID d9b25c5b8ee5feab79371c502ac3895b1b56000f
# Parent  983de84e4bf32b4bcd8bd70417e9d6403db28396
handle classdef syntax in lexer and parser

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,12 +1,63 @@
-2009-07-30  Jaroslav Hajek  <highegg@gmail.com>
-
-	* data.cc (Fmerge): Rename to Fifelse.
-
+2009-07-30  Ryan Rusaw  <rrusaw@gmail.com>
+
+	* input.cc (reading_classdef_file): New file-scope variable.
+	(gnu_readline): Also set curr_stream if reading_classdef_file.
+	(octave_gets, get_input_from_file):
+	Handle classdef files like other input files.
+	* input.h (reading_classdef_file): Provide decl.
+
+	* octave.gperf (classdef, endclassdef, endevents, endmethods,
+	endproperties, events, get, methods, properties, set): New keywords.
+
+	* lex.l: Handle classdef filees like other input files.
+	Recognize superclass method identifiers and metaclass query constructs.
+	(is_keyword_token): Recognize endclassdef, endevents, endmethods,
+	endproperties, get, set, properties, methods, and events keywords.
+	(maybe_classdef_get_set_method, parsing_classdef): New variables.
+	(handle_superclass_identifier, handle_meta_identifier):
+	New static functions.
+	(lexical_feedback::init): Initialize parsing_classdef and
+	maybe_classdef_get_set_method.
+	(display_token): Handle SUPERCLASSREF, METAQUERY, GET, SET,
+	PROPERTIES, METHODS, EVENTS, and  CLASSDEF tokens.
+	* lex.h (maybe_classdef_get_set_method, parsing_classdef):
+	Provide decls.
+	* parse.y (%union): New placeholder type, dummy_type.
+	(SUPERCLASSREF, METAQUERY, GET, SET, PROPERTIES, METHODS, EVENTS,
+	CLASSDEF): New tokens.
+	(superclass_identifier, meta_identifier, classdef_beg,
+	classdef_end, classdef1, classdef, opt_attr_list, attr_list, attr,
+	opt_superclasses, superclasses, class_body, properties_beg,
+	properties_block, properties_list, class_property, methods_beg,
+	methods_block, methods_list, events_beg, events_block,
+	events_list, class_event): New non-terminals.
+	(primary_expr): Include superclass_identifier and meta_identifier
+	as possible primary_exprs.
+	(function_beg): If parsing classdef file, set
+	lexer_flags.maybe_classdef_get_set_method to true.
+	be recognized.
+	(fcn_name): Accept GET '.' identifier or SET '.' identifier.
+	(end_error): Handle endclassdef.
+	(looking_at_classdef_keyword): New function.
+	(gobble_leading_whitespace): Handle classdef.
+	* token.h, token.cc (sc, mc):
+	New union fields for symbol classdef symbol_record info.
+	(token::token (symbol_table::symbol_record *,
+	symbol_table::symbol_record *, int, int),
+	token::token (symbol_table::symbol_record *,
+	symbol_table::symbol_record *, symbol_table::symbol_record *, int,
+	int)): New constructors.
+	(token::method_rec, token::class_rec, token::package_rec,
+	token::meta_class_rec, token::meta_package_rec): New methods.
+	(token_type): New enum values: scls_rec_token, meta_rec_token.
+	(end_tok_type): New enum values: classdef_end, events_end,
+	methods_end, properties_end.
+	
 2009-07-30  David Grundberg  <individ@acc.umu.se>
 
 	* symtab.h (symbol_table::parent_scope): Remove.
 	(symbol_table::set_parent_scope): Remove.
 	(symbol_table::reset_parent_scope): Remove.
 	(symbol_table::install_subfunction): Require scope parameter
 	instead of xparent_scope default.
 	* symtab.cc: Remove symbol_table::xparent_scope
@@ -44,16 +95,20 @@ 2009-07-30  David Grundberg  <individ@ac
 	(make_break_command, make_decl_command, maybe_warn_missing_semi):
 	Ditto
 	(parse_fcn_file): Warn when nested functions have been
 	declared. Remove superfluous local variables. Parse function files
 	using function_file rule.
 
 2009-07-30  Jaroslav Hajek  <highegg@gmail.com>
 
+	* data.cc (Fmerge): Rename to Fifelse.
+
+2009-07-30  Jaroslav Hajek  <highegg@gmail.com>
+
 	* data.cc (Fmerge): New DEFUN.
 	(do_merge): New helper function.
 
 2009-07-29  John W. Eaton  <jwe@octave.org>
 
 	* parse.y (param_list_end): Also set
 	lexer_flags.looking_for_object_index to false.
 
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -110,16 +110,19 @@ bool input_from_eval_string_pending = fa
 
 // TRUE means that input is coming from a file that was named on
 // the command line.
 bool input_from_command_line_file = false;
 
 // TRUE means we're parsing a function file.
 bool reading_fcn_file = false;
 
+// TRUE means we're parsing a classdef file.
+bool reading_classdef_file = false;
+
 // Simple name of function file we are reading.
 std::string curr_fcn_file_name;
 
 // Full name of file we are reading.
 std::string curr_fcn_file_full_name;
 
 // TRUE means we're parsing a script file.
 bool reading_script_file = false;
@@ -211,17 +214,17 @@ gnu_readline (const std::string& s, bool
 	  FILE *stream = command_editor::get_output_stream ();
 
 	  fputs (s.c_str (), stream);
 	  fflush (stream);
 	}
 
       FILE *curr_stream = command_editor::get_input_stream ();
 
-      if (reading_fcn_file || reading_script_file)
+      if (reading_fcn_file || reading_script_file || reading_classdef_file)
 	curr_stream = ff_instream;
 
       retval = octave_fgets (curr_stream);
     }
 
   return retval;
 }
 
@@ -254,16 +257,17 @@ octave_gets (void)
   OCTAVE_QUIT;
 
   std::string retval;
 
   bool history_skip_auto_repeated_debugging_command = false;
 
   if ((interactive || forced_interactive)
       && (! (reading_fcn_file
+	     || reading_classdef_file
 	     || reading_script_file
 	     || input_from_startup_file
 	     || input_from_command_line_file)))
     {
       std::string ps = (promptflag > 0) ? VPS1 : VPS2;
 
       std::string prompt = command_editor::decode_prompt_string (ps);
 
@@ -299,29 +303,29 @@ octave_gets (void)
   current_input_line = retval;
 
   if (! current_input_line.empty ())
     {
       if (! (input_from_startup_file || input_from_command_line_file
 	     || history_skip_auto_repeated_debugging_command))
 	command_history::add (current_input_line);
 
-      if (! (reading_fcn_file || reading_script_file))
+      if (! (reading_fcn_file || reading_script_file || reading_classdef_file))
 	{
 	  octave_diary << current_input_line;
 
 	  if (current_input_line[current_input_line.length () - 1] != '\n')
 	    octave_diary << "\n";
 	}
 
       do_input_echo (current_input_line);
     }
-  else if (! (reading_fcn_file || reading_script_file))
+  else if (! (reading_fcn_file || reading_script_file || reading_classdef_file))
     octave_diary << "\n";
-  
+
   return retval;
 }
 
 // Read a line from the input stream.
 
 static std::string
 get_user_input (void)
 {
@@ -381,17 +385,17 @@ octave_read (char *buf, unsigned max_siz
       memcpy (buf, pos, len);
 
       chars_left -= len;
       pos += len;
 
       // Make sure input ends with a new line character.
       if (chars_left == 0 && buf[len-1] != '\n')
 	{
-	  if (len < max_size) 
+	  if (len < max_size)
 	    {
 	      // There is enough room to plug the newline character in
 	      // the buffer.
 	      buf[len++] = '\n';
 	    }
 	  else
 	    {
 	      // There isn't enough room to plug the newline character
@@ -404,17 +408,17 @@ octave_read (char *buf, unsigned max_siz
 
       status = len;
 
     }
   else if (chars_left == 0)
     {
       status = 0;
     }
-  else    
+  else
     status = -1;
 
   return status;
 }
 
 // Fix things up so that input can come from file `name', printing a
 // warning if the file doesn't exist.
 
@@ -424,17 +428,17 @@ get_input_from_file (const std::string& 
   FILE *instream = 0;
 
   if (name.length () > 0)
     instream = fopen (name.c_str (), "rb");
 
   if (! instream && warn)
     warning ("%s: no such file or directory", name.c_str ());
 
-  if (reading_fcn_file || reading_script_file)
+  if (reading_fcn_file || reading_script_file || reading_classdef_file)
     ff_instream = instream;
   else
     command_editor::set_input_stream (instream);
 
   return instream;
 }
 
 // Fix things up so that input can come from the standard input.  This
@@ -684,17 +688,17 @@ get_debug_input (const std::string& prom
 	  // (dbstep, for example). It's not clear to me why that
 	  // happens.
 	  //
 	  // delete global_command;
 	  //
 	  // global_command = 0;
 
 	  if (octave_completion_matches_called)
-	    octave_completion_matches_called = false;	    
+	    octave_completion_matches_called = false;
 	}
 
       // Unmark forced variables.
       unwind_protect::run ();
 
       // Restore previous value of global_command.
       unwind_protect::run ();
 
diff --git a/src/input.h b/src/input.h
--- a/src/input.h
+++ b/src/input.h
@@ -61,16 +61,19 @@ extern bool reading_fcn_file;
 extern std::string curr_fcn_file_name;
 
 // Full name of file we are reading.
 extern std::string curr_fcn_file_full_name;
 
 // TRUE means we're parsing a script file.
 extern bool reading_script_file;
 
+// TRUE means we're parsing a classdef file.
+extern bool reading_classdef_file;
+
 // If we are reading from an M-file, this is it.
 extern FILE *ff_instream;
 
 // TRUE means this is an interactive shell.
 extern bool interactive;
 
 // TRUE means the user forced this shell to be interactive (-i).
 extern bool forced_interactive;
diff --git a/src/lex.h b/src/lex.h
--- a/src/lex.h
+++ b/src/lex.h
@@ -116,19 +116,27 @@ public:
   // TRUE means we're looking at an indirect reference to a
   // structure element.
   bool looking_at_indirect_ref;
 
   // TRUE means that we've already seen the name of this function.
   // Should only matter if current_function_level > 0
   bool parsed_function_name;
 
-  // TRUE means we are parsing a class method.
+  // TRUE means we are parsing a class method in function or classdef file.
   bool parsing_class_method;
 
+  // TRUE means we are parsing a class method declaration line in a
+  // classdef file and can accept a property get or set method name.
+  // For example, "get.PropertyName" is recognized as a function name.
+  bool maybe_classdef_get_set_method;
+
+  // TRUE means we are parsing a classdef file
+  bool parsing_classdef;
+
   // Return transpose or start a string?
   bool quote_is_transpose;
 
   // Set of identifiers that might be local variable names.
   std::set<std::string> pending_local_variables;
 
 private:
 
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -284,16 +284,18 @@ static int process_comment (bool start_i
 static bool match_any (char c, const char *s);
 static bool next_token_is_sep_op (void);
 static bool next_token_is_bin_op (bool spc_prev);
 static bool next_token_is_postfix_unary_op (bool spc_prev);
 static std::string strip_trailing_whitespace (char *s);
 static void handle_number (void);
 static int handle_string (char delim);
 static int handle_close_bracket (bool spc_gobbled, int bracket_type);
+static int handle_superclass_identifier (void);
+static int handle_meta_identifier (void);
 static int handle_identifier (void);
 static bool have_continuation (bool trailing_comments_ok = true);
 static bool have_ellipsis_continuation (bool trailing_comments_ok = true);
 static void scan_for_comments (const char *);
 static yum_yum eat_whitespace (void);
 static yum_yum eat_continuation (void);
 static void maybe_warn_separator_insert (char sep);
 static void gripe_single_quote_string (void);
@@ -685,17 +687,17 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 
 <<EOF>> {
     LEXER_DEBUG ("<<EOF>>");
 
     if (block_comment_nesting_level != 0)
       {
 	warning ("block comment open at end of input");
 
-	if ((reading_fcn_file || reading_script_file)
+	if ((reading_fcn_file || reading_script_file || reading_classdef_file)
 	    && ! curr_fcn_file_name.empty ())
 	  warning ("near line %d of file `%s.m'",
 		   input_line_number, curr_fcn_file_name.c_str ());
       }
 
     TOK_RETURN (END_OF_INPUT);
   }
 
@@ -709,31 +711,68 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 
     int id_tok = handle_identifier ();
 
     if (id_tok >= 0)
       COUNT_TOK_AND_RETURN (id_tok);
   }
 
 %{
-// Function handles.
+// Superclass method identifiers. 
+%}
+
+{IDENT}@{IDENT}{S}* |
+{IDENT}@{IDENT}.{IDENT}{S}* {
+    LEXER_DEBUG ("{IDENT}@{IDENT}{S}*|{IDENT}@{IDENT}.{IDENT}{S}*");
+
+    int id_tok = handle_superclass_identifier ();
+
+    if (id_tok >= 0)
+      {
+        lexer_flags.looking_for_object_index = true;
+
+        COUNT_TOK_AND_RETURN (SUPERCLASSREF);
+      }
+  }
+  
+%{
+// Metaclass query
+%}  
+  
+\?{IDENT}{S}* | 
+\?{IDENT}.{IDENT}{S}* {
+    LEXER_DEBUG ("\?{IDENT}{S}* | \?{IDENT}.{IDENT}{S}*");
+    
+    int id_tok = handle_meta_identifier ();
+
+    if (id_tok >= 0)
+      {
+        lexer_flags.looking_for_object_index = true;
+
+        COUNT_TOK_AND_RETURN (METAQUERY);
+      }
+  }  
+
+%{
+// Function handles and superclass references
 %}
 
 "@" {
     LEXER_DEBUG ("@");
 
     current_input_column++;
 
     lexer_flags.quote_is_transpose = false;
     lexer_flags.convert_spaces_to_comma = false;
     lexer_flags.looking_at_function_handle++;
     lexer_flags.looking_for_object_index = false;
     lexer_flags.at_beginning_of_statement = false;
 
     COUNT_TOK_AND_RETURN ('@');
+      
   }
 
 %{
 // A new line character.  New line characters inside matrix constants
 // are handled by the <MATRIX_START> start state code above.  If closest
 // nesting is inside parentheses, don't return a row separator.
 %}
 
@@ -869,17 +908,16 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 "^"	{ LEXER_DEBUG ("^"); BIN_OP_RETURN (POW, false, false); }
 "**"	{ LEXER_DEBUG ("**"); XBIN_OP_RETURN (POW, false, false); }
 "="	{ LEXER_DEBUG ("="); BIN_OP_RETURN ('=', true, false); }
 "&&"	{ LEXER_DEBUG ("&&"); BIN_OP_RETURN (EXPR_AND_AND, false, false); }
 "||"	{ LEXER_DEBUG ("||"); BIN_OP_RETURN (EXPR_OR_OR, false, false); }
 "<<"	{ LEXER_DEBUG ("<<"); XBIN_OP_RETURN (LSHIFT, false, false); }
 ">>"	{ LEXER_DEBUG (">>"); XBIN_OP_RETURN (RSHIFT, false, false); }
 
-
 {NOT} {
     LEXER_DEBUG ("{NOT}");
 
     if (yytext[0] == '~')
       BIN_OP_RETURN (EXPR_NOT, false, false);
     else
       XBIN_OP_RETURN (EXPR_NOT, false, false);
   }
@@ -1060,26 +1098,27 @@ reset_parser (void)
   // numbers.
   while (! token_stack.empty ())
     {
       delete token_stack.top ();
       token_stack.pop ();
     }
 
   // Can be reset by defining a function.
-  if (! (reading_script_file || reading_fcn_file))
+  if (! (reading_script_file || reading_fcn_file || reading_classdef_file))
     {
       current_input_column = 1;
       input_line_number = command_editor::current_command_number ();
     }
 
   // Only ask for input from stdin if we are expecting interactive
   // input.
   if ((interactive || forced_interactive)
       && ! (reading_fcn_file
+        || reading_classdef_file
 	    || reading_script_file
 	    || get_input_from_eval_string
 	    || input_from_startup_file))
     yyrestart (stdin);
 
   // Clear the buffer for help text.
   while (! help_buf.empty ())
     help_buf.pop ();
@@ -1412,20 +1451,21 @@ is_keyword_token (const std::string& s)
 	case case_kw:
 	case elseif_kw:
 	case global_kw:
 	case static_kw:
 	case until_kw:
 	  break;
 
 	case end_kw:
-	  if (inside_any_object_index ()
-	      || (lexer_flags.defining_func
-		  && ! (lexer_flags.looking_at_return_list
-			|| lexer_flags.parsed_function_name)))
+	  if (! reading_classdef_file
+	      && (inside_any_object_index ()
+		  || (lexer_flags.defining_func
+		      && ! (lexer_flags.looking_at_return_list
+			    || lexer_flags.parsed_function_name))))
 	    return 0;
 
 	  yylval.tok_val = new token (token::simple_end, l, c);
 	  lexer_flags.at_beginning_of_statement = true;
 	  break;
 
 	case end_try_catch_kw:
 	  yylval.tok_val = new token (token::try_catch_end, l, c);
@@ -1456,16 +1496,36 @@ is_keyword_token (const std::string& s)
 	  yylval.tok_val = new token (token::switch_end, l, c);
 	  lexer_flags.at_beginning_of_statement = true;
 	  break;
 
 	case endwhile_kw:
 	  yylval.tok_val = new token (token::while_end, l, c);
 	  lexer_flags.at_beginning_of_statement = true;
 	  break;
+	  
+	case endclassdef_kw:
+	  yylval.tok_val = new token (token::classdef_end, l, c);
+	  lexer_flags.at_beginning_of_statement = true;
+	  break;
+	  
+	case endevents_kw:
+	  yylval.tok_val = new token (token::events_end, l, c);
+	  lexer_flags.at_beginning_of_statement = true;
+	  break;
+	  
+	case endmethods_kw:
+	  yylval.tok_val = new token (token::methods_end, l, c);
+	  lexer_flags.at_beginning_of_statement = true;
+	  break;
+	  
+	case endproperties_kw:
+	  yylval.tok_val = new token (token::properties_end, l, c);
+	  lexer_flags.at_beginning_of_statement = true;
+	  break;
 
 	case for_kw:
 	case while_kw:
 	  promptflag--;
 	  lexer_flags.looping++;
 	  break;
 
 	case do_kw:
@@ -1480,29 +1540,53 @@ is_keyword_token (const std::string& s)
 	  promptflag--;
 	  break;
 
 	case if_kw:
 	case switch_kw:
 	  promptflag--;
 	  break;
 
+	case get_kw:
+	case set_kw:  
+	  // 'get' and 'set' are keywords in classdef method
+	  // declarations.
+	  if (! lexer_flags.maybe_classdef_get_set_method)
+	    return 0;
+	  break;
+
+	case properties_kw:
+	case methods_kw:
+	case events_kw:
+	  // 'properties', 'methods' and 'events' are keywords for
+	  // classdef blocks.
+	  if (! lexer_flags.parsing_classdef)
+	    return 0;
+	  // fall through ...
+
+	case classdef_kw:
+	  // 'classdef' is always a keyword.
+	  promptflag--;
+	  break;	  
+
 	case function_kw:
 	  promptflag--;
 
 	  lexer_flags.defining_func = true;
 	  lexer_flags.parsed_function_name = false;
 
-	  if (! (reading_fcn_file || reading_script_file))
+	  if (! (reading_fcn_file || reading_script_file
+		 || reading_classdef_file))
 	    input_line_number = 1;
 	  break;
 
         case magic_file_kw:
 	  {
-	    if ((reading_fcn_file || reading_script_file)
+	    if ((reading_fcn_file || reading_script_file
+		 || reading_classdef_file)
 		&& ! curr_fcn_file_full_name.empty ())
 	      yylval.tok_val = new token (curr_fcn_file_full_name, l, c);
 	    else
 	      yylval.tok_val = new token ("stdin", l, c);
 	  }
 	  break;
 
         case magic_line_kw:
@@ -2958,16 +3042,90 @@ looks_like_command_arg (void)
       break;
     }
 
   xunput (c0, yytext);
 
   return retval;
 }
 
+static int
+handle_superclass_identifier (void)
+{
+  eat_continuation ();
+
+  std::string pkg;  
+  std::string meth = strip_trailing_whitespace (yytext); 
+  size_t pos = meth.find ("@");
+  std::string cls = meth.substr (pos).substr (1);
+  meth = meth.substr (0, pos - 1);  
+  
+  pos = cls.find (".");
+  if (pos != std::string::npos)
+    {	 
+      pkg = cls.substr (pos).substr (1);
+      cls = cls.substr (0, pos - 1);
+    }
+    
+  int kw_token = (is_keyword_token (meth) || is_keyword_token (cls)
+		  || is_keyword_token (pkg));
+  if (kw_token)
+    {
+      error ("method, class and package names may not be keywords");
+      return LEXICAL_ERROR;
+    }
+ 
+  yylval.tok_val
+    = new token (meth.empty () ? 0 : &(symbol_table::insert (meth)),
+                 cls.empty () ? 0 : &(symbol_table::insert (cls)),
+                 pkg.empty () ? 0 : &(symbol_table::insert (pkg)),
+		 input_line_number, current_input_column);				   
+  token_stack.push (yylval.tok_val);
+  
+  lexer_flags.convert_spaces_to_comma = true;
+  current_input_column += yyleng;
+  
+  return SUPERCLASSREF;
+}
+
+static int
+handle_meta_identifier (void)
+{
+  eat_continuation ();
+
+  std::string pkg;
+  std::string cls = strip_trailing_whitespace (yytext).substr (1);
+  size_t pos = cls.find (".");
+  
+  if (pos != std::string::npos)
+    {	 
+      pkg = cls.substr (pos).substr (1);
+      cls = cls.substr (0, pos - 1);
+    }
+  
+  int kw_token = is_keyword_token (cls) || is_keyword_token (pkg);
+  if (kw_token)
+    {
+       error ("class and package names may not be keywords");
+      return LEXICAL_ERROR;
+    }
+  
+  yylval.tok_val
+    = new token (cls.empty () ? 0 : &(symbol_table::insert (cls)),
+		 pkg.empty () ? 0 : &(symbol_table::insert (pkg)),
+		 input_line_number, current_input_column);
+
+  token_stack.push (yylval.tok_val);
+                   
+  lexer_flags.convert_spaces_to_comma = true;
+  current_input_column += yyleng;
+  
+  return METAQUERY;
+}
+
 // Figure out exactly what kind of token to return when we have seen
 // an identifier.  Handles keywords.  Return -1 if the identifier
 // should be ignored.
 
 static int
 handle_identifier (void)
 {
   bool at_bos = lexer_flags.at_beginning_of_statement;
@@ -3148,16 +3306,20 @@ lexical_feedback::init (void)
 
   // Not initially inside a loop or if statement.
   looping = 0;
 
   // Not initially defining a function.
   defining_func = false;
   parsed_function_name = false;
   parsing_class_method = false;
+  
+  // Not initially defining a class with classdef.
+  maybe_classdef_get_set_method = false;
+  parsing_classdef = false;
 
   // Not initiallly looking at a function handle.
   looking_at_function_handle = 0;
 
   // Not parsing a function return, parameter, or declaration list.
   looking_at_return_list = false;
   looking_at_parameter_list = false;
   looking_at_decl_list = false;
@@ -3395,16 +3557,24 @@ display_token (int tok)
     case STATIC: std::cerr << "STATIC\n"; break;
     case FCN_HANDLE: std::cerr << "FCN_HANDLE\n"; break;
     case END_OF_INPUT: std::cerr << "END_OF_INPUT\n\n"; break;
     case LEXICAL_ERROR: std::cerr << "LEXICAL_ERROR\n\n"; break;
     case FCN: std::cerr << "FCN\n"; break;
     case CLOSE_BRACE: std::cerr << "CLOSE_BRACE\n"; break;
     case SCRIPT_FILE: std::cerr << "SCRIPT_FILE\n"; break;
     case FUNCTION_FILE: std::cerr << "FUNCTION_FILE\n"; break;
+    case SUPERCLASSREF: std::cerr << "SUPERCLASSREF\n"; break;
+    case METAQUERY: std::cerr << "METAQUERY\n"; break;
+    case GET: std::cerr << "GET\n"; break;
+    case SET: std::cerr << "SET\n"; break;
+    case PROPERTIES: std::cerr << "PROPERTIES\n"; break;
+    case METHODS: std::cerr << "METHODS\n"; break;
+    case EVENTS: std::cerr << "EVENTS\n"; break;
+    case CLASSDEF: std::cerr << "CLASSDEF\n"; break;
     case '\n': std::cerr << "\\n\n"; break;
     case '\r': std::cerr << "\\r\n"; break;
     case '\t': std::cerr << "TAB\n"; break;
     default:
       {
         if (tok < 256)
 	  std::cerr << static_cast<char> (tok) << "\n";
 	else
diff --git a/src/octave.gperf b/src/octave.gperf
--- a/src/octave.gperf
+++ b/src/octave.gperf
@@ -25,69 +25,89 @@ lines following the "%{" marker above.  
 handled correctly.
 
 */
 enum octave_kw_id
 {
   break_kw,
   case_kw,
   catch_kw,
+  classdef_kw,
   continue_kw,
   do_kw,
   else_kw,
   elseif_kw,
   end_kw,
   end_try_catch_kw,
   end_unwind_protect_kw,
+  endclassdef_kw,
+  endevents_kw,
   endfor_kw,
   endfunction_kw,
   endif_kw,
+  endmethods_kw,
+  endproperties_kw,
   endswitch_kw,
   endwhile_kw,
+  events_kw,
   for_kw,
   function_kw,
+  get_kw,
   global_kw,
   if_kw,
   magic_file_kw,
   magic_line_kw,
+  methods_kw,
   otherwise_kw,
+  properties_kw,
   return_kw,
+  set_kw,
   static_kw,
   switch_kw,
   try_kw,
   until_kw,
   unwind_protect_kw,
   unwind_protect_cleanup_kw,
   while_kw
 };
 %}
 struct octave_kw { const char *name; int tok; octave_kw_id kw_id; };
 %%
 break, BREAK, break_kw
 case, CASE, case_kw
 catch, CATCH, catch_kw
+classdef, CLASSDEF, classdef_kw
 continue, CONTINUE, continue_kw
 do, DO, do_kw
 else, ELSE, else_kw
 elseif, ELSEIF, elseif_kw
 end, END, end_kw
 end_try_catch, END, end_try_catch_kw
 end_unwind_protect, END, end_unwind_protect_kw
+endclassdef, END, endclassdef_kw 
+endevents, END, endevents_kw
 endfor, END, endfor_kw
 endfunction, END, endfunction_kw
 endif, END, endif_kw
+endmethods, END, endmethods_kw
+endproperties, END, endproperties_kw
 endswitch, END, endswitch_kw
 endwhile, END, endwhile_kw
+events, EVENTS, events_kw
 for, FOR, for_kw
 function, FCN, function_kw
+get, GET, get_kw
 global, GLOBAL, global_kw
 if, IF, if_kw
+methods, METHODS, methods_kw
 otherwise, OTHERWISE, otherwise_kw
 persistent, STATIC, static_kw
+properties, PROPERTIES, properties_kw
 return, FUNC_RET, return_kw
+set, SET, set_kw
 static, STATIC, static_kw
 switch, SWITCH, switch_kw
 try, TRY, try_kw
 until, UNTIL, until_kw
 unwind_protect, UNWIND, unwind_protect_kw
 unwind_protect_cleanup, CLEANUP, unwind_protect_cleanup_kw
 while, WHILE, while_kw
 __FILE__, DQ_STRING, magic_file_kw
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -405,16 +405,17 @@ make_statement (T *arg)
   tree_switch_case *tree_switch_case_type;
   tree_switch_case_list *tree_switch_case_list_type;
   tree_decl_elt *tree_decl_elt_type;
   tree_decl_init_list *tree_decl_init_list_type;
   tree_decl_command *tree_decl_command_type;
   tree_statement *tree_statement_type;
   tree_statement_list *tree_statement_list_type;
   octave_user_function *octave_user_function_type;
+  void *dummy_type;
 }
 
 // Tokens with line and column information.
 %token <tok_val> '=' ':' '-' '+' '*' '/'
 %token <tok_val> ADD_EQ SUB_EQ MUL_EQ DIV_EQ LEFTDIV_EQ POW_EQ
 %token <tok_val> EMUL_EQ EDIV_EQ ELEFTDIV_EQ EPOW_EQ AND_EQ OR_EQ
 %token <tok_val> LSHIFT_EQ RSHIFT_EQ LSHIFT RSHIFT
 %token <tok_val> EXPR_AND_AND EXPR_OR_OR
@@ -431,58 +432,81 @@ make_statement (T *arg)
 %token <tok_val> FOR WHILE DO UNTIL
 %token <tok_val> IF ELSEIF ELSE
 %token <tok_val> SWITCH CASE OTHERWISE
 %token <tok_val> BREAK CONTINUE FUNC_RET
 %token <tok_val> UNWIND CLEANUP
 %token <tok_val> TRY CATCH
 %token <tok_val> GLOBAL STATIC
 %token <tok_val> FCN_HANDLE
+%token <tok_val> PROPERTIES
+%token <tok_val> METHODS
+%token <tok_val> EVENTS
+%token <tok_val> METAQUERY
+%token <tok_val> SUPERCLASSREF
+%token <tok_val> GET SET
 
 // Other tokens.
 %token END_OF_INPUT LEXICAL_ERROR
-%token FCN SCRIPT_FILE FUNCTION_FILE
+%token FCN SCRIPT_FILE FUNCTION_FILE CLASSDEF
 // %token VARARGIN VARARGOUT
 %token CLOSE_BRACE
 
 // Nonterminals we construct.
-%type <comment_type> stash_comment function_beg
+%type <comment_type> stash_comment function_beg classdef_beg
+%type <comment_type> properties_beg methods_beg events_beg
 %type <sep_type> sep_no_nl opt_sep_no_nl sep opt_sep
 %type <tree_type> input
 %type <tree_constant_type> string constant magic_colon
 %type <tree_anon_fcn_handle_type> anon_fcn_handle
 %type <tree_fcn_handle_type> fcn_handle
 %type <tree_matrix_type> matrix_rows matrix_rows1
 %type <tree_cell_type> cell_rows cell_rows1
 %type <tree_expression_type> matrix cell
 %type <tree_expression_type> primary_expr postfix_expr prefix_expr binary_expr
 %type <tree_expression_type> simple_expr colon_expr assign_expr expression
 %type <tree_identifier_type> identifier fcn_name
-%type <octave_user_function_type> function1 function2
+%type <tree_identifier_type> superclass_identifier meta_identifier
+%type <octave_user_function_type> function1 function2 classdef1
 %type <tree_index_expression_type> word_list_cmd
 %type <tree_colon_expression_type> colon_expr1
 %type <tree_argument_list_type> arg_list word_list assign_lhs
 %type <tree_argument_list_type> cell_or_matrix_row
 %type <tree_parameter_list_type> param_list param_list1 param_list2
 %type <tree_parameter_list_type> return_list return_list1
+%type <tree_parameter_list_type> superclasses opt_superclasses
 %type <tree_command_type> command select_command loop_command
-%type <tree_command_type> jump_command except_command function script_file
+%type <tree_command_type> jump_command except_command function
+%type <tree_command_type> script_file classdef
 %type <tree_command_type> function_file function_list
 %type <tree_if_command_type> if_command
 %type <tree_if_clause_type> elseif_clause else_clause
 %type <tree_if_command_list_type> if_cmd_list1 if_cmd_list
 %type <tree_switch_command_type> switch_command
 %type <tree_switch_case_type> switch_case default_case
 %type <tree_switch_case_list_type> case_list1 case_list
 %type <tree_decl_elt_type> decl2
 %type <tree_decl_init_list_type> decl1
 %type <tree_decl_command_type> declaration
-%type <tree_statement_type> statement function_end
+%type <tree_statement_type> statement function_end classdef_end
 %type <tree_statement_list_type> simple_list simple_list1 list list1
 %type <tree_statement_list_type> opt_list input1
+// These types need to be specified.
+%type <dummy_type> attr
+%type <dummy_type> class_event
+%type <dummy_type> class_property
+%type <dummy_type> properties_list
+%type <dummy_type> properties_block
+%type <dummy_type> methods_list
+%type <dummy_type> methods_block
+%type <dummy_type> opt_attr_list
+%type <dummy_type> attr_list
+%type <dummy_type> events_list
+%type <dummy_type> events_block
+%type <dummy_type> class_body
 
 // Precedence and associativity.
 %left ';' ',' '\n'
 %right '=' ADD_EQ SUB_EQ MUL_EQ DIV_EQ LEFTDIV_EQ POW_EQ EMUL_EQ EDIV_EQ ELEFTDIV_EQ EPOW_EQ OR_EQ AND_EQ LSHIFT_EQ RSHIFT_EQ
 %left EXPR_OR_OR
 %left EXPR_AND_AND
 %left EXPR_OR
 %left EXPR_AND
@@ -596,16 +620,25 @@ word_list	: string
 
 identifier	: NAME
 		  {
 		    symbol_table::symbol_record *sr = $1->sym_rec ();
 		    $$ = new tree_identifier (*sr, $1->line (), $1->column ());
 		  }
 		;
 
+superclass_identifier
+		: SUPERCLASSREF
+		  { $$ = new tree_identifier ($1->line (), $1->column ()); }
+		;
+	    
+meta_identifier	: METAQUERY
+		  { $$ = new tree_identifier ($1->line (), $1->column ()); }
+		;	    
+
 string		: DQ_STRING
 		  { $$ = make_constant (DQ_STRING, $1); }
 		| SQ_STRING
 		  { $$ = make_constant (SQ_STRING, $1); }
 		;
 
 constant	: NUM
 		  { $$ = make_constant (NUM, $1); }
@@ -691,27 +724,31 @@ fcn_handle	: '@' FCN_HANDLE
 		    $$ = make_fcn_handle ($2);
 		    lexer_flags.looking_at_function_handle--;
 		  }
 		;
 
 anon_fcn_handle	: '@' param_list statement
 		  { $$ = make_anon_fcn_handle ($2, $3); }
 		;
-
+	
 primary_expr	: identifier
 		  { $$ = $1; }
 		| constant
 		  { $$ = $1; }
 		| fcn_handle
 		  { $$ = $1; }
 		| matrix
 		  { $$ = $1; }
 		| cell
 		  { $$ = $1; }
+		| meta_identifier
+		  { $$ = $1; }
+		| superclass_identifier
+		  { $$ = $1; }
 		| '(' expression ')'
 		  { $$ = $2->mark_in_parens (); }
 		;
 
 magic_colon	: ':'
 		  {
 		    octave_value tmp (octave_value::magic_colon_t);
 		    $$ = new tree_constant (tmp);
@@ -920,16 +957,18 @@ command		: declaration
 		| jump_command
 		  { $$ = $1; }
 		| except_command
 		  { $$ = $1; }
 		| function
 		  { $$ = $1; }
 		| script_file
 		  { $$ = $1; }
+		| classdef
+		  { $$ = $1; }
 		;
 
 // =====================
 // Declaration statemnts
 // =====================
 
 parsing_decl_list
 		: // empty
@@ -1259,28 +1298,34 @@ script_file	: SCRIPT_FILE opt_list END_O
 		  }
 		;
 
 // =============
 // Function file
 // =============
 
 function_file   : FUNCTION_FILE function_list opt_sep END_OF_INPUT
+		  { $$ = 0; }
 		;
 
 function_list   : function
 		| function_list sep function
 		;
 
 // ===================
 // Function definition
 // ===================
 
 function_beg	: push_fcn_symtab FCN stash_comment
-		  { $$ = $3; }
+		  {
+		    $$ = $3;
+
+		    if (reading_classdef_file || lexer_flags.parsing_classdef) 
+		      lexer_flags.maybe_classdef_get_set_method = true; 
+		  }
 		;
 
 function	: function_beg function1
 		  {
 		    $$ = finish_function (0, $2, $1);
 		    recover_from_parsing_function ();
 		  }
 		| function_beg return_list '=' function1
@@ -1291,19 +1336,30 @@ function	: function_beg function1
 		;
 
 fcn_name	: identifier
 		  {
 		    std::string id_name = $1->name ();
 
 		    lexer_flags.parsed_function_name = true;
 		    lexer_flags.defining_func = false;
-
+		    lexer_flags.maybe_classdef_get_set_method = false;
+            
 		    $$ = $1;
 		  }
+		| GET '.' identifier
+		  {
+		    lexer_flags.maybe_classdef_get_set_method = false;
+		    $$ = $3;
+		  }
+		| SET '.' identifier
+		  {
+		    lexer_flags.maybe_classdef_get_set_method = false;
+		    $$ = $3;
+		  }
 		;
 
 function1	: fcn_name function2
 		  {
 		    std::string fname = $1->name ();
 
 		    delete $1;
 
@@ -1344,21 +1400,162 @@ function_end	: END
 		      }
 
 		    if (! reading_fcn_file && ! reading_script_file)
 		      {
 			yyerror ("function body open at end of input");
 			YYABORT;
 		      }
 
+		    if (reading_classdef_file)
+		      {
+		        yyerror ("classdef body open at end of input");
+		        YYABORT;
+		      }
+
 		    $$ = make_end ("endfunction", input_line_number,
 				   current_input_column);
 		  }
 		;
 
+// ========
+// Classdef
+// ========
+
+classdef_beg	: CLASSDEF stash_comment
+		  {
+		    $$ = 0;
+		    lexer_flags.parsing_classdef = true;
+		  }
+		;
+
+classdef_end	: END
+		  {
+		    lexer_flags.parsing_classdef = false;
+
+		    if (end_token_ok ($1, token::classdef_end))
+		      $$ = make_end ("endclassdef", $1->line (), $1->column ());
+		    else
+		      ABORT_PARSE;
+		  }
+		;
+
+classdef1	: classdef_beg opt_attr_list identifier opt_superclasses
+		  { $$ = 0; }
+		;
+
+classdef	: classdef1 '\n' class_body '\n' stash_comment classdef_end
+		  { $$ = 0; }
+		;
+
+opt_attr_list	: // empty
+		  { $$ = 0; }
+		| '(' attr_list ')'
+		  { $$ = 0; }
+		;
+
+attr_list	: attr
+		  { $$ = 0; }
+		| attr_list ',' attr
+		  { $$ = 0; }
+		;
+
+attr		: identifier
+		  { $$ = 0; }
+		| identifier '=' decl_param_init expression
+		  { $$ = 0; }
+		| EXPR_NOT identifier
+		  { $$ = 0; }
+		;
+
+opt_superclasses
+		: // empty
+		  { $$ = 0; }
+		| superclasses
+		  { $$ = 0; }
+		;
+
+superclasses	: EXPR_LT identifier '.' identifier
+		  { $$ = 0; }
+		| EXPR_LT identifier
+		  { $$ = 0; }
+		| superclasses EXPR_AND identifier '.' identifier
+		  { $$ = 0; }
+		| superclasses EXPR_AND identifier
+		  { $$ = 0; }
+		;
+
+class_body	: properties_block
+		  { $$ = 0; }
+		| methods_block
+		  { $$ = 0; }
+		| events_block
+		  { $$ = 0; }
+		| class_body '\n' properties_block
+		  { $$ = 0; }
+		| class_body '\n' methods_block
+		  { $$ = 0; }
+		| class_body '\n' events_block
+		  { $$ = 0; }
+		;
+
+properties_beg	: PROPERTIES stash_comment
+		  { $$ = 0; }
+		;
+
+properties_block
+		: properties_beg opt_attr_list '\n' properties_list '\n' END
+		  { $$ = 0; }
+		;
+
+properties_list
+		: class_property
+		  { $$ = 0; }
+		| properties_list '\n' class_property
+		  { $$ = 0; }
+		;
+
+class_property	: identifier
+		  { $$ = 0; }
+		| identifier '=' decl_param_init expression ';'
+		  { $$ = 0; }
+		;
+
+methods_beg	: METHODS stash_comment
+		  { $$ = 0; }
+		;
+
+methods_block	: methods_beg opt_attr_list '\n' methods_list '\n' END
+		  { $$ = 0; }
+		;
+
+methods_list	: function
+		  { $$ = 0; }
+		| methods_list '\n' function
+		  { $$ = 0; }
+		;
+
+events_beg	: EVENTS stash_comment
+		  { $$ = 0; }
+		;
+
+events_block	: events_beg opt_attr_list '\n' events_list '\n' END
+		  { $$ = 0; }
+		;
+
+events_list	: class_event
+		  { $$ = 0; }
+		| events_list '\n' class_event
+		  { $$ = 0; }
+		;
+
+class_event	: identifier
+		  { $$ = 0; }
+		;
+ 
 // =============
 // Miscellaneous
 // =============
 
 stash_comment	: // empty
 		  { $$ = octave_comment_buffer::get_comment (); }
 		;
 
@@ -1409,17 +1606,17 @@ opt_sep		: // empty
 
 static void
 yyerror (const char *s)
 {
   int err_col = current_input_column - 1;
 
   std::ostringstream output_buf;
 
-  if (reading_fcn_file || reading_script_file)
+  if (reading_fcn_file || reading_script_file || reading_classdef_file)
     output_buf << "parse error near line " << input_line_number
 	       << " of file " << curr_fcn_file_full_name;
   else
     output_buf << "parse error:";
 
   if (s && strcmp (s, "parse error") != 0)
     output_buf << "\n\n  " << s;
 
@@ -1469,16 +1666,20 @@ end_error (const char *type, token::end_
     case token::for_end:
       error (fmt, type, "endfor", l, c);
       break;
 
     case token::function_end:
       error (fmt, type, "endfunction", l, c);
       break;
 
+    case token::classdef_end:
+      error (fmt, type, "endclassdef", l, c);
+      break;
+
     case token::if_end:
       error (fmt, type, "endif", l, c);
       break;
 
     case token::switch_end:
       error (fmt, type, "endswitch", l, c); 
       break;
 
@@ -1515,16 +1716,20 @@ end_token_ok (token *tok, token::end_tok
 
       yyerror ("parse error");
 
       int l = tok->line ();
       int c = tok->column ();
 
       switch (expected)
 	{
+	case token::classdef_end:
+	  end_error ("classdef", ettype, l, c);
+	  break;
+
 	case token::for_end:
 	  end_error ("for", ettype, l, c);
 	  break;
 
 	case token::function_end:
 	  end_error ("function", ettype, l, c);
 	  break;
 
@@ -2653,17 +2858,17 @@ frob_function (const std::string& fname,
 	  ("Octave:function-name-clash",
 	   "function name `%s' does not agree with function file name `%s'",
 	   id_name.c_str (), curr_fcn_file_full_name.c_str ());
 
 	id_name = nm;
       }
   }
 
-  if (reading_fcn_file || autoloading)
+  if (reading_fcn_file || reading_classdef_file || autoloading)
     {
       octave_time now;
 
       fcn->stash_fcn_file_name (curr_fcn_file_full_name);
       fcn->stash_fcn_file_time (now);
       fcn->mark_as_system_fcn_file ();
 
       if (fcn_file_from_relative_lookup)
@@ -3130,16 +3335,35 @@ skip_white_space (stream_reader& reader)
 	}
     }
 
  done:
 
   return (c == EOF);
 }
 
+static bool
+looking_at_classdef_keyword (FILE *ffile)
+{
+  bool status = false;
+
+  long pos = ftell (ffile);
+
+  char buf [10];
+  fgets (buf, 10, ffile);
+  size_t len = strlen (buf);
+  if (len > 8 && strncmp (buf, "classdef", 8) == 0
+      && ! (isalnum (buf[8]) || buf[8] == '_'))
+    status = true;
+
+  fseek (ffile, pos, SEEK_SET);
+
+  return status;
+ }
+
 static std::string
 gobble_leading_white_space (FILE *ffile, bool& eof)
 {
   std::string help_txt;
 
   eof = false;
 
   // TRUE means we have already cached the help text.
@@ -3258,38 +3482,54 @@ parse_fcn_file (const std::string& ff, c
       if (! eof)
 	{
 	  std::string file_type;
 
 	  unwind_protect::protect_var (get_input_from_eval_string);
 	  unwind_protect::protect_var (parser_end_of_input);
 	  unwind_protect::protect_var (reading_fcn_file);
 	  unwind_protect::protect_var (reading_script_file);
+	  unwind_protect::protect_var (reading_classdef_file);
+	  unwind_protect::protect_var (Vecho_executing_commands);
+
 
 	  get_input_from_eval_string = false;
 	  parser_end_of_input = false;
 
 	  if (! force_script && looking_at_function_keyword (ffile))
 	    {
 	      file_type = "function";
 
-	      unwind_protect::protect_var (Vecho_executing_commands);
+	      Vecho_executing_commands = ECHO_OFF;
+
+	      reading_classdef_file = false;
+	      reading_fcn_file = true;
+	      reading_script_file = false;
+	    }
+	  else if (! force_script && looking_at_classdef_keyword (ffile))
+	    {
+	      file_type = "classdef";
 
 	      Vecho_executing_commands = ECHO_OFF;
-	      reading_fcn_file = true;
+
+	      reading_classdef_file = true;
+	      reading_fcn_file = false;
+	      reading_script_file = false;
 	    }
 	  else
 	    {
 	      file_type = "script";
 
+	      Vecho_executing_commands = ECHO_OFF;
+
+	      reading_classdef_file = false;
 	      reading_fcn_file = false;
+	      reading_script_file = true;
 	    }
 
-	  reading_script_file = ! reading_fcn_file;
-	  
 	  YY_BUFFER_STATE old_buf = current_buffer ();
 	  YY_BUFFER_STATE new_buf = create_buffer (ffile);
 
 	  unwind_protect::add_fcn (switch_to_buffer, old_buf);
 	  unwind_protect::add_fcn (delete_buffer, new_buf);
 
 	  switch_to_buffer (new_buf);
 
diff --git a/src/token.cc b/src/token.cc
--- a/src/token.cc
+++ b/src/token.cc
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1993, 1994, 1995, 1996, 1997, 2000, 2002, 2004, 2005,
-              2007 John W. Eaton
+              2007, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -76,16 +76,38 @@ token::token (plot_tok_type t, int l, in
 token::token (symbol_table::symbol_record *s, int l, int c)
 {
   line_num = l;
   column_num = c;
   type_tag = sym_rec_token;
   sr = s;
 }
 
+token::token (symbol_table::symbol_record *cls,
+              symbol_table::symbol_record *pkg, int l, int c)
+{
+  line_num = l;
+  column_num = c;
+  type_tag = meta_rec_token;
+  mc.cr = cls;
+  mc.pr = pkg;
+}
+
+token::token (symbol_table::symbol_record *mth,
+              symbol_table::symbol_record *cls,
+              symbol_table::symbol_record *pkg, int l, int c)
+{
+  line_num = l;
+  column_num = c;
+  type_tag = scls_rec_token;
+  sc.mr = mth;
+  sc.cr = cls;
+  sc.pr = pkg;
+}
+
 token::~token (void)
 {
   if (type_tag == string_token)
     delete str;
 }
 
 std::string
 token::text (void)
@@ -117,16 +139,51 @@ token::pttype (void)
 
 symbol_table::symbol_record *
 token::sym_rec (void)
 {
   assert (type_tag == sym_rec_token);
   return sr;
 }
 
+symbol_table::symbol_record *
+token::method_rec (void)
+{
+  assert (type_tag == scls_rec_token);
+  return sc.mr;
+}
+
+symbol_table::symbol_record *
+token::class_rec (void)
+{
+  assert (type_tag == scls_rec_token);
+  return sc.cr;
+}
+
+symbol_table::symbol_record *
+token::package_rec (void)
+{
+  assert (type_tag == scls_rec_token);
+  return sc.pr;
+}
+
+symbol_table::symbol_record *
+token::meta_class_rec (void)
+{
+  assert (type_tag == meta_rec_token);
+  return mc.cr;
+}
+
+symbol_table::symbol_record *
+token::meta_package_rec (void)
+{
+  assert (type_tag == meta_rec_token);
+  return mc.pr;
+}
+
 std::string
 token::text_rep (void)
 {
   return orig_text;
 }
 
 /*
 ;;; Local Variables: ***
diff --git a/src/token.h b/src/token.h
--- a/src/token.h
+++ b/src/token.h
@@ -1,12 +1,12 @@
 /*
 
 Copyright (C) 1993, 1994, 1995, 1996, 1997, 2000, 2002, 2004, 2005,
-              2007, 2008 John W. Eaton
+              2007, 2008, 2009 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
 Free Software Foundation; either version 3 of the License, or (at your
 option) any later version.
 
@@ -33,25 +33,31 @@ public:
 
   enum token_type
     {
       generic_token,
       string_token,
       double_token,
       ettype_token,
       pttype_token,
-      sym_rec_token
+      sym_rec_token,
+      scls_rec_token,
+      meta_rec_token
     };
 
   enum end_tok_type
     {
       simple_end,
+      classdef_end,
+      events_end,
       for_end,
       function_end,
       if_end,
+      methods_end,
+      properties_end,
       switch_end,
       while_end,
       try_catch_end,
       unwind_protect_end
     };
 
   enum plot_tok_type
     {
@@ -62,28 +68,40 @@ public:
 
   token (int l = -1, int c = -1);
   token (const std::string& s, int l = -1, int c = -1);
   token (double d, const std::string& s = std::string (),
 	 int l = -1, int c = -1);
   token (end_tok_type t, int l = -1, int c = -1);
   token (plot_tok_type t, int l = -1, int c = -1);
   token (symbol_table::symbol_record *s, int l = -1, int c = -1);
+  token (symbol_table::symbol_record *cls,
+         symbol_table::symbol_record *pkg, int l = -1, int c = -1);
+  token (symbol_table::symbol_record *mth,
+         symbol_table::symbol_record *cls,
+         symbol_table::symbol_record *pkg, int l = -1, int c = -1);
 
   ~token (void);
 
   int line (void) { return line_num; }
   int column (void) { return column_num; }
 
   std::string text (void);
   double number (void);
   end_tok_type ettype (void);
   plot_tok_type pttype (void);
   symbol_table::symbol_record *sym_rec (void);
 
+  symbol_table::symbol_record *method_rec (void);
+  symbol_table::symbol_record *class_rec (void);
+  symbol_table::symbol_record *package_rec (void);
+
+  symbol_table::symbol_record *meta_class_rec (void);
+  symbol_table::symbol_record *meta_package_rec (void);
+
   std::string text_rep (void);
 
 private:
 
   // No copying!
 
   token (const token& tok);
 
@@ -94,16 +112,27 @@ private:
   token_type type_tag;
   union
     {
       std::string *str;
       double num;
       end_tok_type et;
       plot_tok_type pt;
       symbol_table::symbol_record *sr;
+      struct
+        {
+          symbol_table::symbol_record *mr;
+          symbol_table::symbol_record *cr;
+          symbol_table::symbol_record *pr;
+        } sc;
+      struct
+        {
+          symbol_table::symbol_record *cr;
+          symbol_table::symbol_record *pr;
+        } mc;
     };
   std::string orig_text;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
