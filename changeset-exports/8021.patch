# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1218137477 14400
#      Thu Aug 07 15:31:17 2008 -0400
# Node ID 85184151822e2d6955e8c82fbb7c8f68077de617
# Parent  1d2bcc163c4df334badbde6cf1a95bb004adf295
fix typo in NPOS change

diff --git a/liboctave/cmd-edit.cc b/liboctave/cmd-edit.cc
--- a/liboctave/cmd-edit.cc
+++ b/liboctave/cmd-edit.cc
@@ -1366,17 +1366,17 @@ command_editor::do_decode_prompt_string 
 		std::string home_dir = octave_env::get_home_directory ();
 
 		if (c == 'W' && (home_dir.empty () || temp != home_dir))
 		  {
 		    if (temp != "/" && temp != "//")
 		      {
 			size_t pos = temp.rfind ('/');
 
-			if (pos != std::string:npos && pos != 0)
+			if (pos != std::string::npos && pos != 0)
 			  temp = temp.substr (pos + 1);
 		      }
 		  }
 		else
 		  temp = octave_env::polite_directory_format (temp);
 
 		goto add_string;
 	      }
@@ -1396,17 +1396,17 @@ command_editor::do_decode_prompt_string 
 	      }
 
 	    case 'h':
 	      {
 		temp = octave_env::get_host_name ();
 
 		size_t pos = temp.find ('.');
 
-		if (pos != std::string:npos)
+		if (pos != std::string::npos)
 		  temp.resize (pos);
 		
 		goto add_string;
 	      }
 
 	    case '#':
 	      {
 		char number_buffer[128];
diff --git a/liboctave/kpse.cc b/liboctave/kpse.cc
--- a/liboctave/kpse.cc
+++ b/liboctave/kpse.cc
@@ -444,17 +444,17 @@ private:
 
   void set_end (void)
     {
       e = b + 1;
 
       if (e == len)
 	; /* OK, we have found the last element.  */
       else if (e > len)
-	b = e = std::string:npos;
+	b = e = std::string::npos;
       else
 	{
 	  /* Find the next colon not enclosed by braces (or the end of
 	     the path).  */
 
 	  int brace_level = 0;
 	  while (e < len && ! (brace_level == 0 && kpse_is_env_sep (path[e])))
 	    e++;
@@ -465,17 +465,17 @@ private:
     {
       b = e + 1;
 
       /* Skip any consecutive colons.  */
       while (b < len && kpse_is_env_sep (path[b]))
 	b++;
 
       if (b >= len)
-	b = e = std::string:npos;
+	b = e = std::string::npos;
       else
 	set_end ();
     }
 
   // No assignment.
   kpse_path_iterator& operator = (const kpse_path_iterator&);
 };
 
@@ -753,17 +753,17 @@ absolute_search (const std::string& name
 
 static string_vector
 path_search (const std::string& path, const std::string& name,
 	     bool /* must_exist */, bool all)
 {
   string_vector ret_list;
   bool done = false;
 
-  for (kpse_path_iterator pi (path); ! done && pi != std::string:npos; pi++)
+  for (kpse_path_iterator pi (path); ! done && pi != std::string::npos; pi++)
     {
       std::string elt = *pi;
 
       string_vector found;
       bool allow_disk_search = true;
 
       if (elt.length () > 1 && elt[0] == '!' && elt[1] == '!')
 	{
@@ -930,17 +930,17 @@ kpse_all_path_search (const std::string&
 
 static string_vector
 path_find_first_of (const std::string& path, const string_vector& names,
 		    bool /* must_exist */, bool all)
 {
   string_vector ret_list;
   bool done = false;
 
-  for (kpse_path_iterator pi (path); ! done && pi != std::string:npos; pi++)
+  for (kpse_path_iterator pi (path); ! done && pi != std::string::npos; pi++)
     {
       std::string elt = *pi;
 
       str_llist_type *dirs;
       str_llist_elt_type *dirs_elt;
       string_vector found;
       bool allow_disk_search = true;
 
@@ -1262,17 +1262,17 @@ static std::string
 kpse_expand_kpse_dot (const std::string& path)
 {
   std::string ret;
   std::string kpse_dot = octave_env::getenv ("KPSE_DOT");
 
   if (kpse_dot.empty ())
     return path;
 
-  for (kpse_path_iterator pi (path); pi != std::string:npos; pi++)
+  for (kpse_path_iterator pi (path); pi != std::string::npos; pi++)
     {
       std::string elt = *pi;
 
       /* We assume that the !! magic is only used on absolute components.
 	 Single "." get special treatment, as does "./" or its  equivalent.  */
 
       size_t elt_len = elt.length ();
 
@@ -1342,17 +1342,17 @@ kpse_brace_expand (const std::string& pa
        TEXINPUTS = $foo
      we want to end up with TEXINPUTS = .:/home/karl.
      Since kpse_path_element is not reentrant, we must get all
      the path elements before we start the loop.  */
   std::string tmp = kpse_var_expand (path);
 
   std::string ret;
 
-  for (kpse_path_iterator pi (tmp); pi != std::string:npos; pi++)
+  for (kpse_path_iterator pi (tmp); pi != std::string::npos; pi++)
     {
       std::string elt = *pi;
 
       /* Do brace expansion first, so tilde expansion happens in {~ka,~kb}.  */
       std::string expansion = kpse_brace_expand_element (elt);
       ret += expansion + ENV_SEP_STRING;
     }
 
@@ -1378,17 +1378,17 @@ kpse_path_expand (const std::string& pat
   unsigned len;
 
   len = 0;
 
   /* Expand variables and braces first.  */
   std::string tmp = kpse_brace_expand (path);
 
   /* Now expand each of the path elements, printing the results */
-  for (kpse_path_iterator pi (tmp); pi != std::string:npos; pi++)
+  for (kpse_path_iterator pi (tmp); pi != std::string::npos; pi++)
     {
       std::string elt = *pi;
 
       str_llist_type *dirs;
 
       /* Skip and ignore magic leading chars.  */
       if (elt.length () > 1 && elt[0] == '!' && elt[1] == '!')
 	elt = elt.substr (2);
@@ -1841,17 +1841,17 @@ kpse_db_search (const std::string& name_
   /* When tex-glyph.c calls us looking for, e.g., dpi600/cmr10.pk, we
      won't find it unless we change NAME to just `cmr10.pk' and append
      `/dpi600' to PATH_ELT.  We are justified in using a literal `/'
      here, since that's what tex-glyph.c unconditionally uses in
      DPI_BITMAP_SPEC.  But don't do anything if the / begins NAME; that
      should never happen.  */
   std::string path_elt;
   size_t last_slash = name.rfind ('/');
-  if (last_slash != std::string:npos && last_slash != 0)
+  if (last_slash != std::string::npos && last_slash != 0)
     {
       std::string dir_part = name.substr (0, last_slash);
       name = name.substr (last_slash + 1);
     }
   else
     path_elt = orig_path_elt;
 
   /* Don't bother doing any lookups if this `path_elt' isn't covered by
diff --git a/liboctave/oct-env.cc b/liboctave/oct-env.cc
--- a/liboctave/oct-env.cc
+++ b/liboctave/oct-env.cc
@@ -216,17 +216,17 @@ octave_env::chdir (const std::string& ne
 void
 octave_env::do_set_program_name (const std::string& s) const
 {
   program_invocation_name = s;
 
   size_t pos
     = program_invocation_name.find_last_of (file_ops::dir_sep_chars ());
 
-  program_name = (pos == std::string:npos)
+  program_name = (pos == std::string::npos)
     ? program_invocation_name : program_invocation_name.substr (pos+1);
 }
 
 // Return a pretty pathname.  If the first part of the pathname is the
 // same as $HOME, then replace that with `~'.
 
 std::string
 octave_env::do_polite_directory_format (const std::string& name) const
@@ -300,17 +300,17 @@ octave_env::do_rooted_relative_pathname 
 std::string
 octave_env::do_base_pathname (const std::string& s) const
 {
   if (! (do_absolute_pathname (s) || do_rooted_relative_pathname (s)))
     return s;
 
   size_t pos = s.find_last_of (file_ops::dir_sep_chars ());
 
-  if (pos == std::string:npos)
+  if (pos == std::string::npos)
     return s;
   else
     return s.substr (pos+1);
 }
 
 // Turn STRING (a pathname) into an absolute pathname, assuming that
 // DOT_PATH contains the symbolic location of the current directory.
 
@@ -365,17 +365,17 @@ octave_env::do_make_absolute (const std:
 	      pathname_backup (current_dir, 1);
 
 	      continue;
 	    }
 	}
 
       size_t tmp = s.find_first_of (file_ops::dir_sep_chars (), i);
 
-      if (tmp == std::string:npos)
+      if (tmp == std::string::npos)
 	{
 	  current_dir.append (s, i, tmp-i);
 	  break;
 	}
       else
 	{
 	  current_dir.append (s, i, tmp-i+1);
 	  i = tmp + 1;
diff --git a/liboctave/pathsearch.cc b/liboctave/pathsearch.cc
--- a/liboctave/pathsearch.cc
+++ b/liboctave/pathsearch.cc
@@ -152,17 +152,17 @@ dir_path::init (void)
 
       octave_kpathsea_initialized = true;
     }
 
   p = kpse_path_expand (p_default.empty ()
 			? p_orig : kpse_expand_default (p_orig, p_default));
 
   int count = 0;
-  for (kpse_path_iterator pi (p); pi != std::string:npos; pi++)
+  for (kpse_path_iterator pi (p); pi != std::string::npos; pi++)
     count++;
 
   pv.resize (count);
 
   kpse_path_iterator pi (p);
 
   for (int i = 0; i < count; i++)
     pv[i] = *pi++;
diff --git a/src/Cell.cc b/src/Cell.cc
--- a/src/Cell.cc
+++ b/src/Cell.cc
@@ -42,17 +42,17 @@ Cell::Cell (const string_vector& sv, boo
       for (octave_idx_type i = 0; i < n; i++)
 	{
 	  std::string s = sv[i];
 
 	  if (trim)
 	    {
 	      size_t pos = s.find_last_not_of (' ');
 
-	      s = (pos == std::string:npos) ? "" : s.substr (0, pos+1);
+	      s = (pos == std::string::npos) ? "" : s.substr (0, pos+1);
 	    }
 
 	  elem(i,0) = s;
 	}
     }
 }
 
 // Set size to DV, filling with [].  Then fill with as many elements of
@@ -72,17 +72,17 @@ Cell::Cell (const dim_vector& dv, const 
       for (octave_idx_type i = 0; i < len; i++)
 	{
 	  std::string s = sv[i];
 
 	  if (trim)
 	    {
 	      size_t pos = s.find_last_not_of (' ');
 
-	      s = (pos == std::string:npos) ? "" : s.substr (0, pos+1);
+	      s = (pos == std::string::npos) ? "" : s.substr (0, pos+1);
 	    }
 
 	  elem(i) = s;
 	}
     }
 }
 
 bool
diff --git a/src/DLD-FUNCTIONS/dlmread.cc b/src/DLD-FUNCTIONS/dlmread.cc
--- a/src/DLD-FUNCTIONS/dlmread.cc
+++ b/src/DLD-FUNCTIONS/dlmread.cc
@@ -245,26 +245,26 @@ a spreadsheet style range such as 'A2..Q
 	getline (file, line);
       r1 -= r0;
 
       // Read in the data one field at a time, growing the data matrix
       // as needed.
       while (getline (file, line))
 	{
 	  // Skip blank lines for compatibility.
-	  if (line.find_first_not_of (" \t") == std::string:npos)
+	  if (line.find_first_not_of (" \t") == std::string::npos)
 	    continue;
 
 	  // To be compatible with matlab, blank separator should
 	  // correspond to whitespace as delimter.
 	  if (!sep.length ())
 	    {
 	      size_t n = line.find_first_of (",:; \t", 
 					     line.find_first_of ("0123456789"));
-	      if (n == std::string:npos)
+	      if (n == std::string::npos)
 		{
 		  sep = " \t";
 		  sepflag = true;
 		}
 	      else
 		{
 		  char ch = line.at (n);
 
@@ -286,17 +286,17 @@ a spreadsheet style range such as 'A2..Q
 	  r = (r > i + 1 ? r : i + 1);
 	  j = 0;
 	  size_t pos1 = 0;
 	  do
 	    {
 	      size_t pos2 = line.find_first_of (sep, pos1);
 	      std::string str = line.substr (pos1, pos2 - pos1);
 
-	      if (sepflag && pos2 != std::string:npos)
+	      if (sepflag && pos2 != std::string::npos)
 		// Treat consecutive separators as one.
 		pos2 = line.find_first_not_of (sep, pos2) - 1;
 
 	      c = (c > j + 1 ? c : j + 1);
 	      if (r > rmax || c > cmax)
 		{ 
 		  // Use resize_and_fill for the case of not-equal
 		  // length rows.
@@ -333,23 +333,23 @@ a spreadsheet style range such as 'A2..Q
 			rdata(i,j++) = x;
 		    }
 		}
 	      else if (iscmplx)
 		cdata(i,j++) = 0.;
 	      else
 		rdata(i,j++) = 0.;
 
-	      if (pos2 != std::string:npos)
+	      if (pos2 != std::string::npos)
 		pos1 = pos2 + 1;
 	      else
-		pos1 = std::string:npos;
+		pos1 = std::string::npos;
 
 	    }
-	  while (pos1 != std::string:npos);
+	  while (pos1 != std::string::npos);
 
 	  if (nargin == 3 && i == maxrows)
 	    break;
 
 	  i++;
 	}
  
       if (nargin > 2)
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -199,21 +199,21 @@ octregexp_list (const octave_value_list 
       
       size_t pos = 0;
       size_t new_pos;
       int nnames = 0;
       int inames = 0;
       std::ostringstream buf;
       Array<int> named_idx;
 
-      while ((new_pos = pattern.find ("(?<",pos)) != std::string:npos)
+      while ((new_pos = pattern.find ("(?<",pos)) != std::string::npos)
 	{
 	  size_t tmp_pos = pattern.find_first_of ('>',new_pos);
 
-	  if (tmp_pos == std::string:npos)
+	  if (tmp_pos == std::string::npos)
 	    {
 	      error ("syntax error in pattern");
 	      break;
 	    }
 
 	  std::string tmp_name = pattern.substr(new_pos+3,tmp_pos-new_pos-3);
 	  bool found = false;
 
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -625,17 +625,17 @@ List script file with line numbers.\n\
 	      dbg_fcn = get_user_code ();
 
 	      if (dbg_fcn)
 		{
 		  std::string arg = argv[1];
 
 		  size_t ind = arg.find (':');
 
-		  if (ind != std::string:npos)
+		  if (ind != std::string::npos)
 		    {
 		      std::string start_str = arg.substr (0, ind);
 		      std::string end_str = arg.substr (ind + 1);
 
 		      int start = atoi (start_str.c_str ());
 		      int end = atoi (end_str.c_str ());
 		
 		      if (std::min (start, end) <= 0)
@@ -657,17 +657,17 @@ List script file with line numbers.\n\
 
 	  if (dbg_fcn)
 	    {
 	      std::string arg = argv[2];
 	      int start = 0;
 	      int end = 0;
 	      size_t ind = arg.find (':');
 
-	      if (ind != std::string:npos)
+	      if (ind != std::string::npos)
 		{
 		  std::string start_str = arg.substr (0, ind);
 		  std::string end_str = arg.substr (ind + 1);
 
 		  start = atoi (start_str.c_str ());
 		  end = atoi (end_str.c_str ());
 		  
 		}
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -1009,17 +1009,17 @@ error: nargin != 1\n\
   std::string id;
 
   if (nargin > 1)
     {
       std::string arg1 = args(0).string_value ();
 
       if (! error_state)
 	{
-	  if (arg1.find ('%') == std::string:npos)
+	  if (arg1.find ('%') == std::string::npos)
 	    {
 	      id = arg1;
 
 	      nargs.resize (nargin-1);
 
 	      for (int i = 1; i < nargin; i++)
 		nargs(i-1) = args(i);
 	    }
@@ -1333,17 +1333,17 @@ warning named by @var{id} is handled as 
       std::string id;
 
       if (nargin > 1)
 	{
 	  std::string arg1 = args(0).string_value ();
 
 	  if (! error_state)
 	    {
-	      if (arg1.find ('%') == std::string:npos)
+	      if (arg1.find ('%') == std::string::npos)
 		{
 		  id = arg1;
 
 		  nargs.resize (nargin-1);
 
 		  for (int i = 1; i < nargin; i++)
 		    nargs(i-1) = args(i);
 		}
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -145,33 +145,33 @@ fopen_mode_to_ios_mode (const std::strin
       std::string mode = mode_arg;
 
       // 'W' and 'R' are accepted as 'w' and 'r', but we warn about
       // them because Matlab says they perform "automatic flushing"
       // but we don't know precisely what action that implies.
 
       size_t pos = mode.find ('W');
 
-      if (pos != std::string:npos)
+      if (pos != std::string::npos)
 	{
 	  warning ("fopen: treating mode \"W\" as equivalent to \"w\"");
 	  mode[pos] = 'w';
 	}
 
       pos = mode.find ('R');
 
-      if (pos != std::string:npos)
+      if (pos != std::string::npos)
 	{
 	  warning ("fopen: treating mode \"R\" as equivalent to \"r\"");
 	  mode[pos] = 'r';
 	}
 
       pos = mode.find ('z');
 
-      if (pos != std::string:npos)
+      if (pos != std::string::npos)
 	{
 #if defined (HAVE_ZLIB)
 	  mode.erase (pos, 1);
 #else
 	  error ("this version of Octave does not support gzipped files");
 #endif
 	}
 
@@ -439,23 +439,23 @@ do_stream_open (const std::string& name,
 	      std::string tmode = mode;
 
 	      // Use binary mode if 't' is not specified, but don't add
 	      // 'b' if it is already present.
 
 	      size_t bpos = tmode.find ('b');
 	      size_t tpos = tmode.find ('t');
 
-	      if (bpos == std::string:npos && tpos == std::string:npos)
+	      if (bpos == std::string::npos && tpos == std::string::npos)
 		tmode += 'b';
 
 #if defined (HAVE_ZLIB)
 	      size_t pos = tmode.find ('z');
 
-	      if (pos != std::string:npos)
+	      if (pos != std::string::npos)
 		{
 		  tmode.erase (pos, 1);
 
 		  gzFile fptr = ::gzopen (fname.c_str (), tmode.c_str ());
 
 		  if (fptr)
 		    retval = octave_zstdiostream::create (fname, fptr, md, flt_fmt);
 		  else
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -4571,17 +4571,17 @@ Undocumented internal function.\n\
 	  if (! error_state)
 	    {
 	      file = args(1).string_value ();
 
 	      if (! error_state)
 		{
 		  size_t pos = file.find_last_of (file_ops::dir_sep_chars ());
 
-		  if (pos != std::string:npos)
+		  if (pos != std::string::npos)
 		    {
 		      file_stat fs (file.substr (0, pos));
 
 		      if (! (fs && fs.is_dir ()))
 			error ("drawnow: nonexistent directory `%s'",
 			       file.substr (0, pos).c_str ());
 		    }
 
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -738,22 +738,22 @@ help_from_info (const string_vector& arg
 
 static bool
 looks_like_texinfo (const std::string& msg, size_t& p1)
 {
   p1 = msg.find ('\n');
 
   std::string t = msg.substr (0, p1);
 
-  if (p1 == std::string:npos)
+  if (p1 == std::string::npos)
     p1 = 0;
 
   size_t p2 = t.find ("-*- texinfo -*-");
 
-  return (p2 != std::string:npos);
+  return (p2 != std::string::npos);
 }
 
 void
 display_help_text (std::ostream& os, const std::string& msg)
 {
   // Look for "-*- texinfo -*-" in first line of help message.  If it
   // is present, use makeinfo to format the rest of the message before
   // sending it to the output stream.  Otherwise, just print the
@@ -850,17 +850,17 @@ display_usage_text (std::ostream& os, co
       bool found_def = false;
 
       size_t msg_len = msg.length ();
 
       while (pos < msg_len)
 	{
 	  size_t new_pos = msg.find_first_of ('\n', pos);
 
-	  if (new_pos == std::string:npos)
+	  if (new_pos == std::string::npos)
 	    new_pos = msg_len-1;
 
 	  std::string line = msg.substr (pos, new_pos-pos+1);
 
 	  if (line.substr (0, 4) == "@def"
 	      || line.substr (0, 8) == "@end def")
 	    {
 	      found_def = true;
@@ -1420,67 +1420,67 @@ first_help_sentence (const std::string& 
       display_help_text (os, h);
       std::string h2 = os.str ();
 
       while (1)
 	{
 	  // Skip leading whitespace and get new line
 	  pos = h2.find_first_not_of ("\n\t ", pos);
 
-	  if (pos == std::string:npos)
+	  if (pos == std::string::npos)
 	    break;
 
 	  size_t new_pos = h2.find_first_of ('\n', pos);
 	  std::string line = h2.substr (pos, new_pos-pos);
 
 	  // Skip lines starting in "-"
 	  if (line.find_first_of ('-') == 0)
 	    {
 	      pos = new_pos + 1;
 	      continue;
 	    }
 
 	  break;
 	}
 
-      if (pos == std::string:npos)
+      if (pos == std::string::npos)
 	return retval;
 
       // At start of real text. Get first line with the sentence
       size_t new_pos = h2.find_first_of ('\n', pos);
       std::string line = h2.substr (pos, new_pos-pos);
       size_t dot_pos;
 
-      while ((dot_pos = line.find_first_of ('.')) == std::string:npos)
+      while ((dot_pos = line.find_first_of ('.')) == std::string::npos)
 	{
 	  // Trim trailing blanks on line
 	  line.substr (0, line.find_last_not_of ("\n\t ") + 1);
 
 	  // Append next line
 	  size_t tmp_pos = h2.find_first_not_of ("\n\t ", new_pos + 1);
-	  if (tmp_pos == std::string:npos || h2.substr (tmp_pos, 1) == "\n")
+	  if (tmp_pos == std::string::npos || h2.substr (tmp_pos, 1) == "\n")
 	    break;
 
 	  new_pos = h2.find_first_of ('\n', tmp_pos);
 	  std::string next = h2.substr (tmp_pos, new_pos-tmp_pos);
 
 	  if (short_sentence)
 	    {
-	      if ((tmp_pos = next.find_first_of ('.')) != std::string:npos)
+	      if ((tmp_pos = next.find_first_of ('.')) != std::string::npos)
 		{
 		  line = line + " " + next;
 		  dot_pos = line.find_first_of ('.');
 		}
 	      break;
 	    }
 	  else
 	    line = line + " " + next;
 	}
 
-      if (dot_pos == std::string:npos)
+      if (dot_pos == std::string::npos)
 	retval = line;
       else
 	retval = line.substr (0, dot_pos + 1);
     }
   else
     {
       std::string _upper = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
       std::string _lower = "abcdefghijklmnopqrstuvwxyz";
@@ -1488,235 +1488,235 @@ first_help_sentence (const std::string& 
       std::string _alphanum = _alpha + "1234567890";
       pos = 0;
 
       while (1)
 	{
 	  // Skip leading whitespace and get new line
 	  pos = h.find_first_not_of ("\n\t ", pos);
 
-	  if (pos == std::string:npos)
+	  if (pos == std::string::npos)
 	    break;
 
 	  size_t new_pos = h.find_first_of ('\n', pos);
 	  std::string line = h.substr (pos, new_pos-pos);
 
 	  // Make a lower case copy to simplify some tests
 	  std::string lower = line;
 	  std::transform (lower.begin (), lower.end (), lower.begin (), tolower);
 
 	  // Skip lines starting in "-" or "Usage"
 	  if (lower.find_first_of ('-') == 0
 	      || lower.substr (0, 5) == "usage")
 	    {
-	      pos = (new_pos == std::string:npos ? std::string:npos : new_pos + 1);
+	      pos = (new_pos == std::string::npos ? std::string::npos : new_pos + 1);
 	      continue;
 	    }
 
 	  size_t line_pos = 0;
 	  size_t tmp_pos = 0;
 
 	  // chop " blah : "
 	  tmp_pos = line.find_first_not_of ("\t ", line.find_first_not_of 
 					     (_alphanum, line_pos));
-	  if (tmp_pos != std::string:npos && line.substr (tmp_pos, 1) == ":")
+	  if (tmp_pos != std::string::npos && line.substr (tmp_pos, 1) == ":")
 	    line_pos = line.find_first_not_of ("\t ", tmp_pos + 1);
 
-	  if (line_pos == std::string:npos)
+	  if (line_pos == std::string::npos)
 	    {
-	      pos = (new_pos == std::string:npos ? std::string:npos : new_pos + 1);
+	      pos = (new_pos == std::string::npos ? std::string::npos : new_pos + 1);
 	      continue;
 	    }
 
 	  // chop " function "
 	  if (lower.substr (line_pos, 8) == "function")
 	    line_pos =  line.find_first_not_of ("\t ", line_pos + 8);
 	  
-	  if (line_pos == std::string:npos)
+	  if (line_pos == std::string::npos)
 	    {
-	      pos = (new_pos == std::string:npos ? std::string:npos : new_pos + 1);
+	      pos = (new_pos == std::string::npos ? std::string::npos : new_pos + 1);
 	      continue;
 	    }
 
 	  // chop " [a,b] = "
 	  if (line.substr (line_pos, 1) == "[")
 	    {
 	      tmp_pos = line.find_first_not_of 
 		("\t ", line.find_first_of ("]", line_pos) + 1);
 
-	      if (tmp_pos != std::string:npos && line.substr (tmp_pos, 1) == "=")
+	      if (tmp_pos != std::string::npos && line.substr (tmp_pos, 1) == "=")
 		line_pos = line.find_first_not_of ("\t ",tmp_pos + 1);
 	    }
 
-	  if (line_pos == std::string:npos)
+	  if (line_pos == std::string::npos)
 	    {
-	      pos = (new_pos == std::string:npos ? std::string:npos : new_pos + 1);
+	      pos = (new_pos == std::string::npos ? std::string::npos : new_pos + 1);
 	      continue;
 	    }
 
 	  // chop " a = "
 	  if (line.find_first_not_of (_alpha, line_pos) != line_pos)
 	    {
 	      tmp_pos = line.find_first_not_of ("\t ", line.find_first_not_of 
 						(_alphanum, line_pos));
-	      if (tmp_pos != std::string:npos && line.substr (tmp_pos, 1) == "=")
+	      if (tmp_pos != std::string::npos && line.substr (tmp_pos, 1) == "=")
 		line_pos = line.find_first_not_of ("\t ", tmp_pos + 1);
 	    }
 
-	  if (line_pos == std::string:npos)
+	  if (line_pos == std::string::npos)
 	    {
 	      pos = new_pos + 1;
 	      continue;
 	    }
 
 	  // chop " f(x) "
 	  if (line.find_first_not_of (_alpha, line_pos) != line_pos)
 	    {
 	      tmp_pos = line.find_first_not_of ("\t ", line.find_first_not_of 
 						(_alphanum, line_pos));
-	      if (tmp_pos != std::string:npos && line.substr (tmp_pos, 1) == "(")
+	      if (tmp_pos != std::string::npos && line.substr (tmp_pos, 1) == "(")
 		line_pos = line.find_first_not_of ("\t ", line.find_first_of 
 						   (")", tmp_pos) + 1);
 	    }
 
-	  if (line_pos == std::string:npos)
+	  if (line_pos == std::string::npos)
 	    {
-	      pos = (new_pos == std::string:npos ? std::string:npos : new_pos + 1);
+	      pos = (new_pos == std::string::npos ? std::string::npos : new_pos + 1);
 	      continue;
 	    }
 
 	  // chop " ; "
 	  if (line.substr (line_pos, 1) == ":"
 	      || line.substr (line_pos, 1) == ";")
 	    line_pos = line.find_first_not_of ("\t ", line_pos + 1);
 
-	  if (line_pos == std::string:npos)
+	  if (line_pos == std::string::npos)
 	    {
-	      pos = (new_pos == std::string:npos ? std::string:npos : new_pos + 1);
+	      pos = (new_pos == std::string::npos ? std::string::npos : new_pos + 1);
 	      continue;
 	    }
 
 	  // chop " BLAH "
 	  if (line.length () > line_pos + 2
 	      && line.find_first_of (_upper, line_pos) == line_pos
 	      && line.find_first_of (_upper, line_pos+1) == line_pos + 1)
 	    line_pos = line.find_first_not_of ("\t ", line.find_first_not_of 
 			(_upper + "0123456789_", line_pos));
 
-	  if (line_pos == std::string:npos)
+	  if (line_pos == std::string::npos)
 	    {
-	      pos = (new_pos == std::string:npos ? std::string:npos : new_pos + 1);
+	      pos = (new_pos == std::string::npos ? std::string::npos : new_pos + 1);
 	      continue;
 	    }
 
 	  // chop " blah --- "
 	  tmp_pos = line.find_first_not_of ("\t ", line.find_first_not_of 
 					     (_alphanum, line_pos));
-	  if (tmp_pos != std::string:npos && line.substr (tmp_pos, 1) == "-")
+	  if (tmp_pos != std::string::npos && line.substr (tmp_pos, 1) == "-")
 	    {
 	      tmp_pos = line.find_first_not_of ("-", tmp_pos);
 	      if (line.substr (tmp_pos, 1) == " "
 		  || line.substr (tmp_pos, 1) == "\t")
 		line_pos = line.find_first_not_of ("\t ", tmp_pos);
 	    }
 
-	  if (line_pos == std::string:npos)
+	  if (line_pos == std::string::npos)
 	    {
-	      pos = (new_pos == std::string:npos ? std::string:npos : new_pos + 1);
+	      pos = (new_pos == std::string::npos ? std::string::npos : new_pos + 1);
 	      continue;
 	    }
 
 	  // chop " blah <TAB> "
 	  if (line.find_first_not_of (_alpha, line_pos) != line_pos)
 	    {
 	      tmp_pos = line.find_first_not_of (" ", line.find_first_not_of 
 						(_alphanum, line_pos));
-	      if (tmp_pos != std::string:npos && line.substr (tmp_pos, 1) == "\t")
+	      if (tmp_pos != std::string::npos && line.substr (tmp_pos, 1) == "\t")
 		line_pos = line.find_first_not_of ("\t ", line.find_first_of 
 						   (")", tmp_pos) + 1);
 	    }
 
-	  if (line_pos == std::string:npos)
+	  if (line_pos == std::string::npos)
 	    {
-	      pos = (new_pos == std::string:npos ? std::string:npos : new_pos + 1);
+	      pos = (new_pos == std::string::npos ? std::string::npos : new_pos + 1);
 	      continue;
 	    }
 
 	  // chop " blah  "
 	  if (line.find_first_not_of (_alpha, line_pos) != line_pos)
 	    {
 	      tmp_pos = line.find_first_not_of (_alphanum, line_pos);
 
-	      if (tmp_pos != std::string:npos
+	      if (tmp_pos != std::string::npos
 		  && (line.substr (tmp_pos, 2) == "\t\t"
 		      || line.substr (tmp_pos, 2) == "\t "
 		      || line.substr (tmp_pos, 2) == " \t"
 		      || line.substr (tmp_pos, 2) == " "))
 		line_pos = line.find_first_not_of ("\t ", tmp_pos);
 	    }
 
-	  if (line_pos == std::string:npos)
+	  if (line_pos == std::string::npos)
 	    {
-	      pos = (new_pos == std::string:npos ? std::string:npos : new_pos + 1);
+	      pos = (new_pos == std::string::npos ? std::string::npos : new_pos + 1);
 	      continue;
 	    }
 
 	  // skip blah \n or \n blah
 	  // skip blank line
 	  // skip "# !/usr/bin/octave"
 	  if ((line.substr (line_pos , 2) == "or"
-	       && line.find_first_not_of ("\n\t ", line_pos + 2) == std::string:npos)
-	      || line.find_first_not_of ("\n\t ", line_pos) == std::string:npos
+	       && line.find_first_not_of ("\n\t ", line_pos + 2) == std::string::npos)
+	      || line.find_first_not_of ("\n\t ", line_pos) == std::string::npos
 	      || line.substr (line_pos, 2) == "!/")
 	    {
-	      pos = (new_pos == std::string:npos ? std::string:npos : new_pos + 1);
+	      pos = (new_pos == std::string::npos ? std::string::npos : new_pos + 1);
 	      continue;
 	    }
 
 	  // Got the start of first sentence, break.
 	  pos = pos + line_pos;
 	  break;
 	}
 
-      if (pos == std::string:npos)
+      if (pos == std::string::npos)
 	return retval;
 
       // At start of real text. Get first line with the sentence
       size_t new_pos = h.find_first_of ('\n', pos);
       std::string line = h.substr (pos, new_pos-pos);
       size_t dot_pos;
 
-      while ((dot_pos = line.find_first_of ('.')) == std::string:npos)
+      while ((dot_pos = line.find_first_of ('.')) == std::string::npos)
 	{
 	  // Trim trailing blanks on line
 	  line = line.substr (0, line.find_last_not_of ("\n\t ") + 1);
 
 	  // Append next line
 	  size_t tmp_pos = h.find_first_not_of ("\t ", new_pos + 1);
-	  if (tmp_pos == std::string:npos || h.substr (tmp_pos, 1) == "\n")
+	  if (tmp_pos == std::string::npos || h.substr (tmp_pos, 1) == "\n")
 	    break;
 
 	  new_pos = h.find_first_of ('\n', tmp_pos);
 	  std::string next = h.substr (tmp_pos, new_pos-tmp_pos);
 
 	  if (short_sentence)
 	    {
 	      // Only add the next line if it terminates the sentence, then break
-	      if ((tmp_pos = next.find_first_of ('.')) != std::string:npos)
+	      if ((tmp_pos = next.find_first_of ('.')) != std::string::npos)
 		{
 		  line = line + " " + next;
 		  dot_pos = line.find_first_of ('.');
 		}
 	      break;
 	    }
 	  else
 	    line = line + " " + next;
 	}
 
-      if (dot_pos == std::string:npos)
+      if (dot_pos == std::string::npos)
 	retval = line;
       else
 	retval = line.substr (0, dot_pos + 1);
     }
 
   return retval;
 }
 
@@ -1745,27 +1745,27 @@ print_lookfor (const std::string& name, 
   size_t pos = 0;
 
   while (1)
     {
       size_t new_pos = line.find_first_of ("\n\t ", pos);
       size_t end_pos = new_pos;
 
       if (line.length () - pos < width)
-	new_pos = end_pos = std::string:npos;
+	new_pos = end_pos = std::string::npos;
       else
-	while (new_pos != std::string:npos && new_pos - pos < width)
+	while (new_pos != std::string::npos && new_pos - pos < width)
 	  {
 	    end_pos = new_pos;
 	    new_pos = line.find_first_of ("\n\t ", new_pos + 1);
 	  }
 
       octave_stdout << line.substr (pos, end_pos-pos) << std::endl;
 		  
-      if (end_pos == std::string:npos)
+      if (end_pos == std::string::npos)
 	break;
 
       pos = end_pos + 1;
       width = max_width;
       octave_stdout << std::string (deflen + 1, ' ');
     }
 }
 
@@ -1844,17 +1844,17 @@ to find related functions that are not p
       std::transform (txt.begin (), txt.end (), txt.begin (), tolower);
 
       help_list *ptr = keyword_help ();
       while (ptr->name)
 	{
 	  std::string name = ptr->name;
 	  std::string h = ptr->help;
 
-	  if (name.find (txt) != std::string:npos)
+	  if (name.find (txt) != std::string::npos)
 	    {
 	      if (nargout)
 		{
 		  ret[0].append (name);
 		  ret[1].append (first_help_sentence (h));
 		}
 	      else
 		print_lookfor (name, first_help_sentence (h));
@@ -1865,17 +1865,17 @@ to find related functions that are not p
 
 	      if (first_sentence_only)
 		s = first_help_sentence (h);
 	      else
 		s = h;
 	      
 	      std::transform (s.begin (), s.end (), s.begin (), tolower);
 
-	      if (s.length () > 0 && s.find (txt) != std::string:npos)
+	      if (s.length () > 0 && s.find (txt) != std::string::npos)
 		{
 		  if (nargout)
 		    {
 		      ret[0].append (name);
 		      ret[1].append (first_help_sentence (h));
 		    }
 		  else
 		    print_lookfor (name, first_help_sentence (h));
@@ -1888,17 +1888,17 @@ to find related functions that are not p
 	}
 
       ptr = operator_help ();
       while (ptr->name)
 	{
 	  std::string name = ptr->name;
 	  std::string h = ptr->help;
 
-	  if (name.find (txt) != std::string:npos)
+	  if (name.find (txt) != std::string::npos)
 	    {
 	      if (nargout)
 		{
 		  ret[0].append (name);
 		  ret[1].append (first_help_sentence (h));
 		}
 	      else
 		print_lookfor (name, first_help_sentence (h));
@@ -1908,17 +1908,17 @@ to find related functions that are not p
 	      std::string s;
 	      if (first_sentence_only)
 		s = first_help_sentence (h);
 	      else
 		s = h;
 	      
 	      std::transform (s.begin (), s.end (), s.begin (), tolower);
 
-	      if (s.length () > 0 && s.find (txt) != std::string:npos)
+	      if (s.length () > 0 && s.find (txt) != std::string::npos)
 		{
 		  if (nargout)
 		    {
 		      ret[0].append (name);
 		      ret[1].append (first_help_sentence (h));
 		    }
 		  else
 		    print_lookfor (name, first_help_sentence (h));
@@ -1943,17 +1943,17 @@ to find related functions that are not p
 	  OCTAVE_QUIT;
 
 	  symbol_record *sr = lookup_by_name (name, 0);
 	  if (sr && sr->is_defined ()
 	      && sr->type_name () != "overloaded function")
 	    {
 	      std::string h = sr->help ();
 
-	      if (name.find (txt) != std::string:npos)
+	      if (name.find (txt) != std::string::npos)
 		{
 		  if (nargout)
 		    {
 		      ret[0].append (name);
 		      ret[1].append (first_help_sentence (h));
 		    }
 		  else
 		    print_lookfor (name, first_help_sentence (h));
@@ -1964,17 +1964,17 @@ to find related functions that are not p
 
 		  if (first_sentence_only)
 		    s = first_help_sentence (h);
 		  else
 		    s = h;
 	      
 		  std::transform (s.begin (), s.end (), s.begin (), tolower);
 
-		  if (s.length () > 0 && s.find (txt) != std::string:npos)
+		  if (s.length () > 0 && s.find (txt) != std::string::npos)
 		    {
 		      if (nargout)
 			{
 			  ret[0].append (name);
 			  ret[1].append (first_help_sentence (h));
 			}
 		      else
 			print_lookfor (name, first_help_sentence (h));
@@ -2036,17 +2036,17 @@ to find related functions that are not p
 			      sr = lookup_by_name (name, false);
 
 			      if (sr && sr->is_defined ())
 				h = sr->help ();
 			    }
 			  else
 			    h = get_help_from_file (file_name, symbol_found);
 
-			  if (name.find (txt) != std::string:npos)
+			  if (name.find (txt) != std::string::npos)
 			    {
 			      if (nargout)
 				{
 				  ret[0].append (name);
 				  ret[1].append (first_help_sentence (h));
 				}
 			      else
 				print_lookfor (name, first_help_sentence (h));
@@ -2056,17 +2056,17 @@ to find related functions that are not p
 			      std::string s;
 			      if (first_sentence_only)
 				s = first_help_sentence (h);
 			      else
 				s = h;
 
 			      std::transform (s.begin (), s.end (), s.begin (), tolower);
 
-			      if (s.length () > 0 && s.find (txt) != std::string:npos)
+			      if (s.length () > 0 && s.find (txt) != std::string::npos)
 				{
 				  if (nargout)
 				    {
 				      ret[0].append (name);
 				      ret[1].append (first_help_sentence (h));
 				    }
 				  else
 				    print_lookfor (name, first_help_sentence (h));
@@ -2095,17 +2095,17 @@ to find related functions that are not p
 			    {
 			      // Must load to get help
 			      sr = lookup_by_name (aname, false);
 
 			      std::string h;
 			      if (sr && sr->is_defined ())
 				h = sr->help ();
 
-			      if (aname.find (txt) != std::string:npos)
+			      if (aname.find (txt) != std::string::npos)
 				{
 				  if (nargout)
 				    {
 				      ret[0].append (aname);
 				      ret[1].append (first_help_sentence (h));
 				    }
 				  else
 				    print_lookfor (aname, first_help_sentence (h));
@@ -2116,17 +2116,17 @@ to find related functions that are not p
 				  if (first_sentence_only)
 				    s = first_help_sentence (h);
 				  else
 				    s = h;
 
 				  std::transform (s.begin (), s.end (), s.begin (), 
 					     tolower);
 
-				  if (s.length () > 0 && s.find (txt) != std::string:npos)
+				  if (s.length () > 0 && s.find (txt) != std::string::npos)
 				    {
 				      if (nargout)
 					{
 					  ret[0].append (aname);
 					  ret[1].append (first_help_sentence (h));
 					}
 				      else
 					print_lookfor (aname, first_help_sentence (h));
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -268,17 +268,17 @@ octave_gets (void)
 
       octave_diary << prompt;
 
       retval = interactive_input (prompt);
 
       // There is no need to update the load_path cache if there is no
       // user input.
       if (! retval.empty ()
-	  && retval.find_first_not_of (" \t\n\r") != std::string:npos)
+	  && retval.find_first_not_of (" \t\n\r") != std::string::npos)
 	load_path::update ();
     }
   else
     retval = gnu_readline ("");
 
   current_input_line = retval;
 
   if (! current_input_line.empty ())
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -1711,17 +1711,17 @@ next_token_is_bin_op (bool spc_prev)
 
 static std::string
 strip_trailing_whitespace (char *s)
 {
   std::string retval = s;
 
   size_t pos = retval.find_first_of (" \t");
 
-  if (pos != std::string:npos)
+  if (pos != std::string::npos)
     retval.resize (pos);
 
   return retval;
 }
 
 // FIXME -- we need to handle block comments here.
 
 static void
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -125,17 +125,17 @@ load_path::dir_info::get_file_list (cons
 		    get_method_file_map (full_name, fname.substr (1));
 		}
 	      else
 		{
 		  all_files[all_files_count++] = fname;
 
 		  size_t pos = fname.rfind ('.');
 
-		  if (pos != std::string:npos)
+		  if (pos != std::string::npos)
 		    {
 		      std::string ext = fname.substr (pos);
 
 		      if (ext == ".m" || ext == ".oct" || ext == ".mex")
 			{
 			  std::string base = fname.substr (0, pos);
 
 			  if (valid_identifier (base))
@@ -173,17 +173,17 @@ get_fcn_files (const std::string& d)
 	{
 	  std::string fname = flist[i];
 
 	  std::string ext;
 	  std::string base = fname;
 
 	  size_t pos = fname.rfind ('.');
 
-	  if (pos != std::string:npos)
+	  if (pos != std::string::npos)
 	    {
 	      base = fname.substr (0, pos);
 	      ext = fname.substr (pos);
 
 	      if (valid_identifier (base))
 		{
 		  int t = 0;
 
@@ -301,17 +301,17 @@ load_path::move_fcn_map (const std::stri
     {
       std::string fname = fcn_files[k];
 
       std::string ext;
       std::string base = fname;
 
       size_t pos = fname.rfind ('.');
 
-      if (pos != std::string:npos)
+      if (pos != std::string::npos)
 	{
 	  base = fname.substr (0, pos);
 	  ext = fname.substr (pos);
 	}
 
       file_info_list_type& file_info_list = fcn_map[base];
 
       if (file_info_list.size () == 1)
@@ -472,17 +472,17 @@ split_path (const std::string& p)
 {
   std::list<std::string> retval;
 
   size_t beg = 0;
   size_t end = p.find (dir_path::path_sep_char ());
 
   size_t len = p.length ();
 
-  while (end != std::string:npos)
+  while (end != std::string::npos)
     {
       std::string elt = p.substr (beg, end-beg);
 
       if (! elt.empty ())
 	retval.push_back (elt);
 
       beg = end + 1;
 
@@ -617,17 +617,17 @@ load_path::remove_fcn_map (const std::st
     {
       std::string fname = fcn_files[k];
 
       std::string ext;
       std::string base = fname;
 
       size_t pos = fname.rfind ('.');
 
-      if (pos != std::string:npos)
+      if (pos != std::string::npos)
 	{
 	  base = fname.substr (0, pos);
 	  ext = fname.substr (pos);
 	}
 
       file_info_list_type& file_info_list = fcn_map[base];
 
       for (file_info_list_iterator p = file_info_list.begin ();
@@ -1002,17 +1002,17 @@ load_path::do_methods (const std::string
   return retval;
 }
 
 std::string
 load_path::do_find_file (const std::string& file) const
 {
   std::string retval;
 
-  if (file.find_first_of (file_ops::dir_sep_chars ()) != std::string:npos)
+  if (file.find_first_of (file_ops::dir_sep_chars ()) != std::string::npos)
     {
       if (octave_env::absolute_pathname (file)
 	  || octave_env::rooted_relative_pathname (file))
 	{
 	  file_stat fs (file);
 
 	  if (fs.exists ())
 	    return file;
@@ -1440,17 +1440,17 @@ load_path::add_to_fcn_map (const dir_inf
     {
       std::string fname = fcn_files[i];
 
       std::string ext;
       std::string base = fname;
 
       size_t pos = fname.rfind ('.');
 
-      if (pos != std::string:npos)
+      if (pos != std::string::npos)
 	{
 	  base = fname.substr (0, pos);
 	  ext = fname.substr (pos);
 	}
 
       file_info_list_type& file_info_list = fcn_map[base];
 
       file_info_list_iterator p = file_info_list.begin ();
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -502,18 +502,18 @@ find_file_to_load (const std::string& na
 	      fname = tmp;
 	    }
 	}
     }
 
   size_t dot_pos = fname.rfind (".");
   size_t sep_pos = fname.find_last_of (file_ops::dir_sep_chars ());
     
-  if (dot_pos == std::string:npos
-      || (sep_pos != std::string:npos && dot_pos < sep_pos))
+  if (dot_pos == std::string::npos
+      || (sep_pos != std::string::npos && dot_pos < sep_pos))
     {
       // Either no '.' in name or no '.' appears after last directory
       // separator.
 
       file_stat fs (fname);
 
       if (! (fs.exists () && fs.is_reg ()))
 	fname = find_file_to_load (fname + ".mat", orig_name);
diff --git a/src/ls-mat-ascii.cc b/src/ls-mat-ascii.cc
--- a/src/ls-mat-ascii.cc
+++ b/src/ls-mat-ascii.cc
@@ -125,36 +125,36 @@ get_lines_and_columns (std::istream& is,
       file_line_number++;
 
       size_t beg = buf.find_first_not_of (", \t");
 
       // If we see a CR as the last character in the buffer, we had a
       // CRLF pair as the line separator.  Any other CR in the text
       // will not be considered as whitespace.
 
-      if (beg != std::string:npos && buf[beg] == '\r' && beg == buf.length () - 1)
+      if (beg != std::string::npos && buf[beg] == '\r' && beg == buf.length () - 1)
 	{
 	  // We had a blank line ending with a CRLF.  Handle it the
 	  // same as an empty line.
-	  beg = std::string:npos;
+	  beg = std::string::npos;
 	}
 
       octave_idx_type tmp_nc = 0;
 
-      while (beg != std::string:npos)
+      while (beg != std::string::npos)
 	{
 	  tmp_nc++;
 
 	  size_t end = buf.find_first_of (", \t", beg);
 
-	  if (end != std::string:npos)
+	  if (end != std::string::npos)
 	    {
 	      beg = buf.find_first_not_of (", \t", end);
 
-	      if (beg == std::string:npos || (buf[beg] == '\r' && 
+	      if (beg == std::string::npos || (buf[beg] == '\r' && 
 				  beg == buf.length () - 1))
 		{
 		  // We had a line with trailing spaces and
 		  // ending with a CRLF, so this should look like EOL,
 		  // not a new colum.
 		  break;
 		}
 	    }
@@ -200,24 +200,24 @@ read_mat_ascii_data (std::istream& is, c
 		     octave_value& tc)
 {
   std::string retval;
 
   std::string varname;
 
   size_t pos = filename.rfind ('/');
 
-  if (pos != std::string:npos)
+  if (pos != std::string::npos)
     varname = filename.substr (pos+1);
   else
     varname = filename;
 
   pos = varname.rfind ('.');
 
-  if (pos != std::string:npos)
+  if (pos != std::string::npos)
     varname = varname.substr (0, pos);
 
   size_t len = varname.length ();
   for (size_t i = 0; i < len; i++)
     {
       char c = varname[i];
       if (! (isalnum (c) || c == '_'))
 	varname[i] = '_';
diff --git a/src/ls-oct-ascii.cc b/src/ls-oct-ascii.cc
--- a/src/ls-oct-ascii.cc
+++ b/src/ls-oct-ascii.cc
@@ -271,17 +271,17 @@ read_ascii_data (std::istream& is, const
 
   std::string tag = extract_keyword (is, "type");
 
   if (! tag.empty ())
     {
       std::string typ;
       size_t pos = tag.rfind (' ');
 
-      if (pos != std::string:npos)
+      if (pos != std::string::npos)
 	{
 	  global = SUBSTRING_COMPARE_EQ (tag, 0, 6, "global");
 
 	  typ = global ? tag.substr (7) : tag;
 	}
       else
 	typ = tag;
 
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -1553,24 +1553,24 @@ do_scanf_conv (std::istream&, const scan
       std::string char_class = elt->char_class; \
  \
       int c = EOF; \
  \
       if (elt->type == '[') \
         { \
 	  int chars_read = 0; \
 	  while (is && chars_read++ < width && (c = is.get ()) != EOF \
-	         && char_class.find (c) != std::string:npos) \
+	         && char_class.find (c) != std::string::npos) \
 	    buf << static_cast<char> (c); \
 	} \
       else \
 	{ \
 	  int chars_read = 0; \
 	  while (is && chars_read++ < width && (c = is.get ()) != EOF \
-	         && char_class.find (c) == std::string:npos) \
+	         && char_class.find (c) == std::string::npos) \
 	    buf << static_cast<char> (c); \
 	} \
  \
       if (width == INT_MAX && c != EOF) \
 	is.putback (c); \
  \
       tmp = buf.str (); \
  \
@@ -2597,17 +2597,17 @@ octave_base_stream::do_printf (printf_fo
 		      if (lo_ieee_isnan (val) || xisinf (val))
 			{
 			  std::string tfmt = fmt;
 			  std::string::size_type i1, i2;
 
 			  tfmt.replace ((i1 = tfmt.rfind (elt->type)),
 					1, 1, 's');
 
-			  if ((i2 = tfmt.rfind ('.')) != std::string:npos && i2 < i1)
+			  if ((i2 = tfmt.rfind ('.')) != std::string::npos && i2 < i1)
 			    {
 			      tfmt.erase (i2, i1-i2);
 			      if (elt->prec < 0)
 				nsa--;
 			    }
 
 			  const char *tval = xisinf (val)
 			    ? (val < 0 ? "-Inf" : "Inf")
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -441,17 +441,17 @@ execute_command_line_file (const std::st
 
   curr_fcn_file_name = fname;
   curr_fcn_file_full_name = curr_fcn_file_name;
 
   octave_program_invocation_name = curr_fcn_file_name;
 
   size_t pos = curr_fcn_file_name.find_last_of (file_ops::dir_sep_chars ());
   
-  std::string tmp = (pos != std::string:npos)
+  std::string tmp = (pos != std::string::npos)
     ? curr_fcn_file_name.substr (pos+1) : curr_fcn_file_name;
 
   octave_program_name = tmp;
 
   try
     {
       std::string context;
       bool verbose = false;
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -558,17 +558,17 @@ octave_fcn_handle::load_binary (std::ist
 
       symbol_table::erase_scope (local_scope);
     }
   else
     {
       std::string octaveroot;
       std::string fpath;
 
-      if (nm.find_first_of ("\n") != std::string:npos)
+      if (nm.find_first_of ("\n") != std::string::npos)
 	{
 	  size_t pos1 = nm.find_first_of ("\n");
 	  size_t pos2 = nm.find_first_of ("\n", pos1 + 1);
 	  octaveroot = nm.substr (pos1 + 1, pos2 - pos1 - 1);
 	  fpath = nm.substr (pos2 + 1);
 	  nm = nm.substr (0, pos1);
 	}
 
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -2481,17 +2481,17 @@ frob_function (const std::string& fname,
 	  // FIXME -- should curr_fcn_file_name already be
 	  // preprocessed when we get here?  It seems to only be a
 	  // problem with relative file names.
 
 	  std::string nm = curr_fcn_file_name;
 
 	  size_t pos = nm.find_last_of (file_ops::dir_sep_chars ());
 
-	  if (pos != std::string:npos)
+	  if (pos != std::string::npos)
 	    nm = curr_fcn_file_name.substr (pos+1);
 
 	  if (nm != id_name)
 	    {
 	      warning_with_id
 		("Octave:function-name-clash",
 		 "function name `%s' does not agree with function file name `%s'",
 		 id_name.c_str (), curr_fcn_file_full_name.c_str ());
@@ -3513,24 +3513,24 @@ of the file name and the extension.\n\
   if (arg == "fullpathext")
     retval = fname;
   else
     {
       size_t dpos = fname.rfind (file_ops::dir_sep_char ());
       size_t epos = fname.rfind ('.');
 
       if (epos <= dpos)
-        epos = std::string:npos;
-
-      fname = (epos != std::string:npos) ? fname.substr (0, epos) : fname;
+        epos = std::string::npos;
+
+      fname = (epos != std::string::npos) ? fname.substr (0, epos) : fname;
 
       if (arg == "fullpath")
 	retval = fname;
       else
-        retval = (dpos != std::string:npos) ? fname.substr (dpos+1) : fname;
+        retval = (dpos != std::string::npos) ? fname.substr (dpos+1) : fname;
     }
 
   return retval;
 }
 
 
 DEFUN (source, args, ,
   "-*- texinfo -*-\n\
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -2797,17 +2797,17 @@ representing the elements of @var{x}. By
 
 	      size_t n = 0;
 	      size_t s_len = s.length ();
 
 	      while (n < s_len)
 		{
 		  size_t m = s.find ('\n',  n);
 
-		  if (m == std::string:npos)
+		  if (m == std::string::npos)
 		    {
 		      lst.push_back (s.substr (n));
 		      break;
 		    }
 		  else
 		    {
 		      lst.push_back (s.substr (n, m - n));
 		      n = m + 1;
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -904,17 +904,17 @@ octave_value
 symbol_table::find_function (const std::string& name, tree_argument_list *args,
 			     const string_vector& arg_names,
 			     octave_value_list& evaluated_args,
 			     bool& args_evaluated)
 {
   octave_value retval;
   size_t pos = name.find_first_of (Vfilemarker);
 
-  if (pos == std::string:npos)
+  if (pos == std::string::npos)
     retval = find (name, args, arg_names, evaluated_args, args_evaluated, true);
   else
     {
       std::string fcn_scope = name.substr(0, pos);
       scope_id stored_scope = xcurrent_scope;
       xcurrent_scope = xtop_scope;
       octave_value parent = find_function (name.substr(0, pos));
       if (parent.is_defined ())
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -133,17 +133,17 @@ w32_set_octave_home (void)
 	  bin_dir.resize (n);
 	}
     }
 
   if (! bin_dir.empty ())
     {
       size_t pos = bin_dir.rfind ("\\bin\\");
 
-      if (pos != std::string:npos)
+      if (pos != std::string::npos)
 	octave_env::putenv ("OCTAVE_HOME", bin_dir.substr (0, pos));
     }
 }
 
 void
 w32_set_quiet_shutdown (void)
 {
   // Let the user close the console window or shutdown without the
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -433,17 +433,17 @@ fcn_file_in_path (const std::string& nam
 	    retval = name;
 	}
       else if (len > 2 && name [len - 2] == '.' && name [len - 1] == 'm')
 	retval = load_path::find_fcn_file (name.substr (0, len-2));
       else
 	{
 	  std::string fname = name;
 	  size_t pos = name.find_first_of (Vfilemarker);
-	  if (pos != std::string:npos)
+	  if (pos != std::string::npos)
 	    fname = name.substr (0, pos);
 
 	  retval = load_path::find_fcn_file (fname);
 	}
     }
 
   return retval;
 }
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -463,38 +463,38 @@ string_vector
 get_struct_elts (const std::string& text)
 {
   int n = 1;
 
   size_t pos = 0;
 
   size_t len = text.length ();
 
-  while ((pos = text.find ('.', pos)) != std::string:npos)
+  while ((pos = text.find ('.', pos)) != std::string::npos)
     {
       if (++pos == len)
 	break;
 
       n++;
     }
 
   string_vector retval (n);
 
   pos = 0;
 
   for (int i = 0; i < n; i++)
     {
       len = text.find ('.', pos);
 
-      if (len != std::string:npos)
+      if (len != std::string::npos)
 	len -= pos;
 
       retval[i] = text.substr (pos, len);
 
-      if (len != std::string:npos)
+      if (len != std::string::npos)
 	pos += len + 1;
     }
 
   return retval;
 }
 
 static inline bool
 is_variable (const std::string& name)
@@ -514,30 +514,30 @@ is_variable (const std::string& name)
 string_vector
 generate_struct_completions (const std::string& text,
 			     std::string& prefix, std::string& hint)
 {
   string_vector names;
 
   size_t pos = text.rfind ('.');
 
-  if (pos != std::string:npos)
+  if (pos != std::string::npos)
     {
       if (pos == text.length ())
 	hint = "";
       else
 	hint = text.substr (pos+1);
 
       prefix = text.substr (0, pos);
 
       std::string base_name = prefix;
 
       pos = base_name.find_first_of ("{(.");
 
-      if (pos != std::string:npos)
+      if (pos != std::string::npos)
 	base_name = base_name.substr (0, pos);
 
       if (is_variable (base_name))
 	{
 	  int parse_status;
 
 	  unwind_protect::begin_frame ("generate_struct_completions");
 
@@ -565,19 +565,19 @@ generate_struct_completions (const std::
 // FIXME -- this will have to be much smarter to work
 // "correctly".
 
 bool
 looks_like_struct (const std::string& text)
 {
   bool retval = (! text.empty ()
 		 && text != "."
-		 && text.find_first_of (file_ops::dir_sep_chars ()) == std::string:npos
-		 && text.find ("..") == std::string:npos
-		 && text.rfind ('.') != std::string:npos);
+		 && text.find_first_of (file_ops::dir_sep_chars ()) == std::string::npos
+		 && text.find ("..") == std::string::npos
+		 && text.rfind ('.') != std::string::npos);
 
 #if 0
   symbol_record *sr = curr_sym_tab->lookup (text);
 
   if (sr && ! sr->is_function ())
     {
       int parse_status;
 
@@ -655,17 +655,17 @@ symbol_exist (const std::string& name, c
 {
   int retval = 0;
 
   std::string struct_elts;
   std::string symbol_name = name;
 
   size_t pos = name.find ('.');
 
-  if (pos != std::string:npos && pos > 0)
+  if (pos != std::string::npos && pos > 0)
     {
       struct_elts = name.substr (pos+1);
       symbol_name = name.substr (0, pos);
     }
 
   // We shouldn't need to look in the global symbol table, since any
   // name that is visible in the current scope will be in the local
   // symbol table.
@@ -1488,17 +1488,17 @@ public:
 	    int a = 0, b = -1, balance = 1;
 	    unsigned int items;
 	    size_t pos;
 	    std::string cmd;
 
 	    // Parse one command from whos_line_format
 	    cmd = Vwhos_line_format.substr (idx, Vwhos_line_format.length ());
 	    pos = cmd.find (';');
-	    if (pos != std::string:npos)
+	    if (pos != std::string::npos)
 	      cmd = cmd.substr (0, pos+1);
 	    else
 	      error ("parameter without ; in whos_line_format");
 
 	    idx += cmd.length ();
 
 	    // FIXME -- use iostream functions instead of sscanf!
 
@@ -1514,17 +1514,17 @@ public:
 	      {
 		error ("whos_line_format: parameter structure without command in whos_line_format");
 		error_encountered = true;
 	      }
 
 	    // Insert data into parameter
 	    param.first_parameter_length = 0;
 	    pos = param_string.find (param.command);
-	    if (pos != std::string:npos)
+	    if (pos != std::string::npos)
 	      {
 		param.parameter_length = param_length(pos);
 		param.text = param_names(pos);
 		param.line.assign (param_names(pos).length (), '=');
 
 		param.parameter_length = (a > param.parameter_length
 					  ? a : param.parameter_length);
 		if (param.command == 's' && param.modifier == 'c' && b > 0)
@@ -1605,17 +1605,17 @@ public:
 	  }
 	else
 	  {
 	    // Text string, to be printed as it is ...
 	    std::string text;
 	    size_t pos;
 	    text = Vwhos_line_format.substr (idx, Vwhos_line_format.length ());
 	    pos = text.find ('%');
-	    if (pos != std::string:npos)
+	    if (pos != std::string::npos)
 	      text = text.substr (0, pos);
 
 	    // Push parameter into list ...
 	    idx += text.length ();
 	    param.text=text;
 	    param.line.assign (text.length(), ' ');
 	    params.push_back (param);
 	  }
@@ -1691,17 +1691,17 @@ do_who (int argc, const string_vector& a
 	      else
 		symbol_names.push_back (p->name ());
 	    }
 	}
       else
 	{
 	  size_t pos = pat.find_first_of (".({");
 
-	  if (pos != std::string:npos && pos > 0)
+	  if (pos != std::string::npos && pos > 0)
 	    {
 	      if (verbose)
 		{
 		  // NOTE: we can only display information for
 		  // expressions based on global values if the variable is
 		  // global in the current scope because we currently have
 		  // no way of looking up the base value in the global
 		  // scope and then evaluating the arguments in the
