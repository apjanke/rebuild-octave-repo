# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1484679376 18000
#      Tue Jan 17 13:56:16 2017 -0500
# Node ID b98ebcd7f11cf892ef563dd02fd3a35e2ce86d7a
# Parent  5839d16828cbedb78f8b572cbe0786d681b77126
move some octave stream classes into octave namespace

* oct-stream.h, oct-stream.cc (base_stream, stream, stream_list):
Move inside octave namespace and rename without octave_ prefix.
Change all uses.

diff --git a/libinterp/corefcn/c-file-ptr-stream.h b/libinterp/corefcn/c-file-ptr-stream.h
--- a/libinterp/corefcn/c-file-ptr-stream.h
+++ b/libinterp/corefcn/c-file-ptr-stream.h
@@ -22,16 +22,17 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_c_file_ptr_stream_h)
 #define octave_c_file_ptr_stream_h 1
 
 #include "octave-config.h"
 
 #include <cstdio>
 
+#include <iostream>
 #include <streambuf>
 
 class
 c_file_ptr_buf : public std::streambuf
 {
 public:
 
   typedef std::streambuf::int_type int_type;
diff --git a/libinterp/corefcn/dlmread.cc b/libinterp/corefcn/dlmread.cc
--- a/libinterp/corefcn/dlmread.cc
+++ b/libinterp/corefcn/dlmread.cc
@@ -221,17 +221,17 @@ such as text, are also replaced by the @
 
       if (! input_file)
         error ("dlmread: unable to open file '%s'", fname.c_str ());
 
       input = &input_file;
     }
   else if (args(0).is_scalar_type ())
     {
-      octave_stream is = octave_stream_list::lookup (args(0), "dlmread");
+      octave::stream is = octave::stream_list::lookup (args(0), "dlmread");
 
       input = is.input_stream ();
 
       if (! input)
         error ("dlmread: stream FILE not open for input");
     }
   else
     error ("dlmread: FILE argument must be a string or file id");
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -77,41 +77,41 @@ along with Octave; see the file COPYING.
 #include "sysdep.h"
 #include "utils.h"
 #include "variables.h"
 
 static octave_value stdin_file;
 static octave_value stdout_file;
 static octave_value stderr_file;
 
-static octave_stream stdin_stream;
-static octave_stream stdout_stream;
-static octave_stream stderr_stream;
+static octave::stream stdin_stream;
+static octave::stream stdout_stream;
+static octave::stream stderr_stream;
 
 void
 initialize_file_io (void)
 {
   stdin_stream = octave_istream::create (&std::cin, "stdin");
 
   // This uses octave_stdout (see pager.h), not std::cout so that Octave's
   // standard output stream will pass through the pager.
 
   stdout_stream = octave_ostream::create (&octave_stdout, "stdout");
 
   stderr_stream = octave_ostream::create (&std::cerr, "stderr");
 
-  stdin_file = octave_stream_list::insert (stdin_stream);
-  stdout_file = octave_stream_list::insert (stdout_stream);
-  stderr_file = octave_stream_list::insert (stderr_stream);
+  stdin_file = octave::stream_list::insert (stdin_stream);
+  stdout_file = octave::stream_list::insert (stdout_stream);
+  stderr_file = octave::stream_list::insert (stderr_stream);
 }
 
 void
 close_files (void)
 {
-  octave_stream_list::clear ();
+  octave::stream_list::clear ();
 }
 
 // List of files to delete when we exit or crash.
 //
 // FIXME: this should really be static,
 //        but that causes problems on some systems.
 std::stack <std::string> tmp_files;
 
@@ -244,33 +244,33 @@ second form of the @code{fclose} call cl
 @code{stdin}, @code{stdout}, @code{stderr}, and any FIDs associated
 with gnuplot.
 @seealso{fopen, fflush, freport}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
-  return ovl (octave_stream_list::remove (args(0), "fclose"));
+  return ovl (octave::stream_list::remove (args(0), "fclose"));
 }
 
 DEFUN (fclear, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn {} {} fclear (@var{fid})
 Clear the stream state for the file specified by the file descriptor
 @var{fid}.
 @seealso{ferror, fopen}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
-  int fid = octave_stream_list::get_file_number (args(0));
-
-  octave_stream os = octave_stream_list::lookup (fid, "fclear");
+  int fid = octave::stream_list::get_file_number (args(0));
+
+  octave::stream os = octave::stream_list::lookup (fid, "fclear");
 
   os.clearerr ();
 
   return ovl ();
 }
 
 DEFUN (fflush, args, ,
        doc: /* -*- texinfo -*-
@@ -288,27 +288,27 @@ always a good idea to flush the standard
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   octave_value retval = -1;
 
   // FIXME: any way to avoid special case for stdout?
-  int fid = octave_stream_list::get_file_number (args(0));
+  int fid = octave::stream_list::get_file_number (args(0));
 
   if (fid == 1)
     {
       flush_octave_stdout ();
 
       retval = 0;
     }
   else
     {
-      octave_stream os = octave_stream_list::lookup (fid, "fflush");
+      octave::stream os = octave::stream_list::lookup (fid, "fflush");
 
       retval = os.flush ();
     }
 
   return retval;
 }
 
 DEFUN (fgetl, args, ,
@@ -332,17 +332,17 @@ To read a line and return the terminatin
 {
   static std::string who = "fgetl";
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
-  octave_stream os = octave_stream_list::lookup (args(0), who);
+  octave::stream os = octave::stream_list::lookup (args(0), who);
 
   octave_value len_arg = (nargin == 2) ? args(1) : octave_value ();
 
   bool err = false;
 
   std::string tmp = os.getl (len_arg, err, who);
 
   if (! err)
@@ -372,17 +372,17 @@ To read a line and discard the terminati
 {
   static std::string who = "fgets";
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
-  octave_stream os = octave_stream_list::lookup (args(0), who);
+  octave::stream os = octave::stream_list::lookup (args(0), who);
 
   octave_value len_arg = (nargin == 2) ? args(1) : octave_value ();
 
   bool err = false;
 
   std::string tmp = os.gets (len_arg, err, who);
 
   if (! err)
@@ -412,35 +412,35 @@ Returns the number of lines skipped (end
 {
   static std::string who = "fskipl";
 
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
-  octave_stream os = octave_stream_list::lookup (args(0), who);
+  octave::stream os = octave::stream_list::lookup (args(0), who);
 
   octave_value count_arg = (nargin == 2) ? args(1) : octave_value ();
 
   bool err = false;
 
   off_t tmp = os.skipl (count_arg, err, who);
 
   if (! err)
     return ovl (tmp);
   else
     return ovl ();
 }
 
-static octave_stream
+static octave::stream
 do_stream_open (const std::string& name, const std::string& mode_arg,
                 const std::string& arch, int& fid)
 {
-  octave_stream retval;
+  octave::stream retval;
 
   fid = -1;
 
   std::string mode = mode_arg;
   bool use_zlib = false;
   normalize_fopen_mode (mode, use_zlib);
 
   std::ios::openmode md = fopen_mode_to_ios_mode (mode);
@@ -484,21 +484,21 @@ do_stream_open (const std::string& name,
             retval.error (std::strerror (errno));
         }
 
     }
 
   return retval;
 }
 
-static octave_stream
+static octave::stream
 do_stream_open (const octave_value& tc_name, const octave_value& tc_mode,
                 const octave_value& tc_arch, const char *fcn, int& fid)
 {
-  octave_stream retval;
+  octave::stream retval;
 
   fid = -1;
 
   std::string name = tc_name.xstring_value ("%s: filename must be a string", fcn);
   std::string mode = tc_mode.xstring_value ("%s: file mode must be a string", fcn);
   std::string arch = tc_arch.xstring_value ("%s: architecture type must be a string", fcn);
 
   retval = do_stream_open (name, mode, arch, fid);
@@ -618,40 +618,40 @@ When opening a new file that does not ye
     {
       if (args(0).is_string ())
         {
           // If there is only one argument and it is a string but it
           // is not the string "all", we assume it is a file to open
           // with MODE = "r".  To open a file called "all", you have
           // to supply more than one argument.
           if (nargout < 2 && args(0).string_value () == "all")
-            return octave_stream_list::open_file_numbers ();
+            return octave::stream_list::open_file_numbers ();
         }
       else
         {
-          string_vector tmp = octave_stream_list::get_info (args(0));
+          string_vector tmp = octave::stream_list::get_info (args(0));
 
           retval = ovl (tmp(0), tmp(1), tmp(2));
 
           return retval;
         }
     }
 
   octave_value mode = (nargin == 2 || nargin == 3)
                       ? args(1) : octave_value ("r");
 
   octave_value arch = (nargin == 3)
                       ? args(2) : octave_value ("native");
 
   int fid = -1;
 
-  octave_stream os = do_stream_open (args(0), mode, arch, "fopen", fid);
+  octave::stream os = do_stream_open (args(0), mode, arch, "fopen", fid);
 
   if (os)
-    retval = ovl (octave_stream_list::insert (os), "");
+    retval = ovl (octave::stream_list::insert (os), "");
   else
     {
       int error_number = 0;
 
       retval = ovl (-1.0, os.error (false, error_number));
     }
 
   return retval;
@@ -692,17 +692,17 @@ freport ()
 @end group
 @end example
 @seealso{fopen, fclose, is_valid_file_id}
 @end deftypefn */)
 {
   if (args.length () > 0)
     warning ("freport: ignoring extra arguments");
 
-  octave_stdout << octave_stream_list::list_open_files ();
+  octave_stdout << octave::stream_list::list_open_files ();
 
   return ovl ();
 }
 
 DEFUN (frewind, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} frewind (@var{fid})
 @deftypefnx {} {@var{status} =} frewind (@var{fid})
@@ -714,17 +714,17 @@ is equivalent to @code{fseek (@var{fid},
 @seealso{fseek, ftell, fopen}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   int result = -1;
 
-  octave_stream os = octave_stream_list::lookup (args(0), "frewind");
+  octave::stream os = octave::stream_list::lookup (args(0), "frewind");
 
   result = os.rewind ();
 
   if (nargout > 0)
     return ovl (result);
   else
     return ovl ();
 }
@@ -748,17 +748,17 @@ be positive, negative, or zero but not a
 @seealso{fskipl, frewind, ftell, fopen}
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
-  octave_stream os = octave_stream_list::lookup (args(0), "fseek");
+  octave::stream os = octave::stream_list::lookup (args(0), "fseek");
 
   octave_value origin_arg = (nargin == 3) ? args(2) : octave_value (-1.0);
 
   return ovl (os.seek (args(1), origin_arg));
 }
 
 DEFUN (ftell, args, ,
        doc: /* -*- texinfo -*-
@@ -766,17 +766,17 @@ DEFUN (ftell, args, ,
 Return the position of the file pointer as the number of characters from the
 beginning of the file specified by file descriptor @var{fid}.
 @seealso{fseek, frewind, feof, fopen}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
-  octave_stream os = octave_stream_list::lookup (args(0), "ftell");
+  octave::stream os = octave::stream_list::lookup (args(0), "ftell");
 
   return ovl (os.tell ());
 }
 
 DEFUN (fprintf, args, nargout,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} fprintf (@var{fid}, @var{template}, @dots{})
 @deftypefnx {} {} fprintf (@var{template}, @dots{})
@@ -799,25 +799,25 @@ expanded even when the template string i
 
   int nargin = args.length ();
 
   if (! (nargin > 1 || (nargin > 0 && args(0).is_string ())))
     print_usage ();
 
   int result;
 
-  octave_stream os;
+  octave::stream os;
   int fmt_n = 0;
 
   if (args(0).is_string ())
-    os = octave_stream_list::lookup (1, who);
+    os = octave::stream_list::lookup (1, who);
   else
     {
       fmt_n = 1;
-      os = octave_stream_list::lookup (args(0), who);
+      os = octave::stream_list::lookup (args(0), who);
     }
 
   if (! args(fmt_n).is_string ())
     error ("%s: format TEMPLATE must be a string", who.c_str ());
 
   octave_value_list tmp_args;
 
   if (nargin > 1 + fmt_n)
@@ -898,17 +898,17 @@ Return a non-negative number on success 
 @seealso{fdisp, fprintf, fwrite, fopen}
 @end deftypefn */)
 {
   static std::string who = "fputs";
 
   if (args.length () != 2)
     print_usage ();
 
-  octave_stream os = octave_stream_list::lookup (args(0), who);
+  octave::stream os = octave::stream_list::lookup (args(0), who);
 
   return ovl (os.puts (args(1), who));
 }
 
 DEFUN (puts, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {} puts (@var{string})
 @deftypefnx {} {@var{status} =} puts (@var{string})
@@ -952,18 +952,18 @@ expanded even when the template string i
   if (nargin == 0)
     print_usage ();
 
   // We don't use octave_ostrstream::create here because need direct
   // access to the OSTR object so that we can extract a string object
   // from it to return.
   octave_ostrstream *ostr = new octave_ostrstream ();
 
-  // The octave_stream destructor will delete OSTR for us.
-  octave_stream os (ostr);
+  // The octave::stream destructor will delete OSTR for us.
+  octave::stream os (ostr);
 
   if (! os.is_valid ())
     error ("%s: unable to create output buffer", who.c_str ());
 
   octave_value fmt_arg = args(0);
 
   if (! fmt_arg.is_string ())
     error ("%s: format TEMPLATE must be a string", who.c_str ());
@@ -1046,17 +1046,17 @@ complete description of the syntax of th
 
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
   octave_value_list retval;
 
-  octave_stream os = octave_stream_list::lookup (args(0), who);
+  octave::stream os = octave::stream_list::lookup (args(0), who);
 
   if (! args(1).is_string ())
     error ("%s: format TEMPLATE must be a string", who.c_str ());
 
   if (nargin == 3 && args(2).is_string ())
     {
       retval = ovl (os.oscanf (args(1), who));
     }
@@ -1111,17 +1111,17 @@ character to be read is returned in @var
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
 
   octave_value_list retval;
 
   std::string data = get_scan_string_data (args(0), who);
 
-  octave_stream os = octave_istrstream::create (data);
+  octave::stream os = octave_istrstream::create (data);
 
   if (! os.is_valid ())
     error ("%s: unable to create temporary input buffer", who.c_str ());
 
   if (! args(1).is_string ())
     error ("%s: format TEMPLATE must be a string", who.c_str ());
 
   if (nargin == 3 && args(2).is_string ())
@@ -1172,29 +1172,29 @@ It is currently not useful to call @code
 }
 
 static octave_value_list
 textscan_internal (const std::string& who, const octave_value_list& args)
 {
   if (args.length () < 1)
     print_usage (who);
 
-  octave_stream os;
+  octave::stream os;
 
   if (args(0).is_string ())
     {
       std::string data = get_scan_string_data (args(0), who);
 
       os = octave_istrstream::create (data);
 
       if (! os.is_valid ())
         error ("%s: unable to create temporary input buffer", who.c_str ());
     }
   else
-    os =octave_stream_list::lookup (args(0), who);
+    os =octave::stream_list::lookup (args(0), who);
 
   int nskip = 1;
 
   std::string fmt;
 
   if (args.length () == 1)
     {
       // ommited format = %f.  explicit "" = width from file
@@ -2244,17 +2244,17 @@ as the name of the function when reporti
 %!error <must be a string> textscan ("Hello World", 2)
 %!error <at most one character or>
 %! textscan ("Hello World", "%s", "EndOfLine", 3);
 %!error <'%z' is not a valid format specifier> textscan ("1.0", "%z")
 %!error <no valid format conversion specifiers> textscan ("1.0", "foo")
 */
 
 static octave_value
-do_fread (octave_stream& os, const octave_value& size_arg,
+do_fread (octave::stream& os, const octave_value& size_arg,
           const octave_value& prec_arg, const octave_value& skip_arg,
           const octave_value& arch_arg, octave_idx_type& count)
 {
   count = -1;
 
   Array<double> size = size_arg.xvector_value ("fread: invalid SIZE specified");
 
   std::string prec = prec_arg.xstring_value ("fread: PRECISION must be a string");
@@ -2464,17 +2464,17 @@ The optional return value @var{count} co
 @seealso{fwrite, fgets, fgetl, fscanf, fopen}
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 5)
     print_usage ();
 
-  octave_stream os = octave_stream_list::lookup (args(0), "fread");
+  octave::stream os = octave::stream_list::lookup (args(0), "fread");
 
   octave_value size = lo_ieee_inf_value ();
   octave_value prec = "uchar";
   octave_value skip = 0;
   octave_value arch = "unknown";
 
   int idx = 1;
 
@@ -2498,17 +2498,17 @@ The optional return value @var{count} co
   octave_idx_type count = -1;
 
   octave_value tmp = do_fread (os, size, prec, skip, arch, count);
 
   return ovl (tmp, count);
 }
 
 static int
-do_fwrite (octave_stream& os, const octave_value& data,
+do_fwrite (octave::stream& os, const octave_value& data,
            const octave_value& prec_arg, const octave_value& skip_arg,
            const octave_value& arch_arg)
 {
   std::string prec = prec_arg.xstring_value ("fwrite: PRECISION must be a string");
 
   int block_size = 1;
   oct_data_conv::data_type output_type;
 
@@ -2562,17 +2562,17 @@ are too large to fit in the specified pr
 @seealso{fread, fputs, fprintf, fopen}
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   if (nargin < 2 || nargin > 5)
     print_usage ();
 
-  octave_stream os = octave_stream_list::lookup (args(0), "fwrite");
+  octave::stream os = octave::stream_list::lookup (args(0), "fwrite");
 
   octave_value prec = "uchar";
   octave_value skip = 0;
   octave_value arch = "unknown";
 
   int idx = 1;
 
   octave_value data = args(idx++);
@@ -2604,17 +2604,17 @@ Note that @code{feof} will only return 1
 been encountered, not if the next read operation will result in an
 end-of-file condition.
 @seealso{fread, frewind, fseek, fclear, fopen}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
-  octave_stream os = octave_stream_list::lookup (args(0), "feof");
+  octave::stream os = octave::stream_list::lookup (args(0), "feof");
 
   return ovl (os.eof () ? 1.0 : 0.0);
 }
 
 DEFUNX ("ferror", Fferror, args, ,
         doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{msg} =} ferror (@var{fid})
 @deftypefnx {} {[@var{msg}, @var{err}] =} ferror (@var{fid})
@@ -2635,17 +2635,17 @@ whether the next operation will result i
 @seealso{fclear, fopen}
 @end deftypefn */)
 {
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
-  octave_stream os = octave_stream_list::lookup (args(0), "ferror");
+  octave::stream os = octave::stream_list::lookup (args(0), "ferror");
 
   bool clear = false;
 
   if (nargin == 2)
     {
       std::string opt = args(1).string_value ();
 
       clear = (opt == "clear");
@@ -2701,25 +2701,25 @@ endwhile
 
   std::string name = args(0).xstring_value ("popen: COMMAND must be a string");
   std::string mode = args(1).xstring_value ("popen: MODE must be a string");
 
   octave_value retval;
 
   if (mode == "r")
     {
-      octave_stream ips = octave_iprocstream::create (name);
-
-      retval = octave_stream_list::insert (ips);
+      octave::stream ips = octave_iprocstream::create (name);
+
+      retval = octave::stream_list::insert (ips);
     }
   else if (mode == "w")
     {
-      octave_stream ops = octave_oprocstream::create (name);
-
-      retval = octave_stream_list::insert (ops);
+      octave::stream ops = octave_oprocstream::create (name);
+
+      retval = octave::stream_list::insert (ops);
     }
   else
     error ("popen: invalid MODE specified");
 
   return retval;
 }
 
 DEFUNX ("pclose", Fpclose, args, ,
@@ -2729,17 +2729,17 @@ Close a file identifier that was opened 
 
 The function @code{fclose} may also be used for the same purpose.
 @seealso{fclose, popen}
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
-  return ovl (octave_stream_list::remove (args(0), "pclose"));
+  return ovl (octave::stream_list::remove (args(0), "pclose"));
 }
 
 DEFUN (tempname, args, ,
        doc: /* -*- texinfo -*-
 @deftypefn  {} {@var{fname} =} tempname ()
 @deftypefnx {} {@var{fname} =} tempname (@var{dir})
 @deftypefnx {} {@var{fname} =} tempname (@var{dir}, @var{prefix})
 Return a unique temporary filename as a string.
@@ -2853,22 +2853,22 @@ system-dependent error message.
   FILE *fid = octave_tmpfile_wrapper ();
 
   if (fid)
     {
       std::string nm;
 
       std::ios::openmode md = fopen_mode_to_ios_mode ("w+b");
 
-      octave_stream s = octave_stdiostream::create (nm, fid, md);
+      octave::stream s = octave_stdiostream::create (nm, fid, md);
 
       if (! s)
         error ("tmpfile: failed to create octave_stdiostream object");
 
-      retval = ovl (octave_stream_list::insert (s), "");
+      retval = ovl (octave::stream_list::insert (s), "");
     }
   else
     {
       retval = ovl (-1, std::strerror (errno));
     }
 
   return retval;
 }
@@ -2928,22 +2928,22 @@ message.
           retval(2) = std::strerror (errno);
         }
       else
         {
           std::string nm = tmp;
 
           std::ios::openmode md = fopen_mode_to_ios_mode (fopen_mode);
 
-          octave_stream s = octave_stdiostream::create (nm, fid, md);
+          octave::stream s = octave_stdiostream::create (nm, fid, md);
 
           if (! s)
             error ("mkstemp: failed to create octave_stdiostream object");
 
-          retval(0) = octave_stream_list::insert (s);
+          retval(0) = octave::stream_list::insert (s);
           retval(1) = nm;
 
           if (nargin == 2 && args(1).is_true ())
             mark_for_deletion (nm);
         }
     }
 
   return retval;
diff --git a/libinterp/corefcn/oct-fstrm.cc b/libinterp/corefcn/oct-fstrm.cc
--- a/libinterp/corefcn/oct-fstrm.cc
+++ b/libinterp/corefcn/oct-fstrm.cc
@@ -25,52 +25,52 @@ along with Octave; see the file COPYING.
 #endif
 
 #include <cerrno>
 #include <cstring>
 
 #include "error.h"
 #include "oct-fstrm.h"
 
-octave_stream
+octave::stream
 octave_fstream::create (const std::string& nm_arg, std::ios::openmode arg_md,
                         octave::mach_info::float_format ff)
 {
-  return octave_stream (new octave_fstream (nm_arg, arg_md, ff));
+  return octave::stream (new octave_fstream (nm_arg, arg_md, ff));
 }
 
 octave_fstream::octave_fstream (const std::string& nm_arg,
                                 std::ios::openmode arg_md,
                                 octave::mach_info::float_format ff)
-  : octave_base_stream (arg_md, ff), nm (nm_arg)
+  : octave::base_stream (arg_md, ff), nm (nm_arg)
 {
   fs.open (nm.c_str (), arg_md);
 
   if (! fs)
-    // Note: error is inherited from octave_base_stream, not ::error.
+    // Note: error is inherited from octave::base_stream, not ::error.
     error (std::strerror (errno));
 }
 
 // Position a stream at OFFSET relative to ORIGIN.
 
 int
 octave_fstream::seek (off_t, int)
 {
-  // Note: error is inherited from octave_base_stream, not ::error.
+  // Note: error is inherited from octave::base_stream, not ::error.
   // This error function does not halt execution so "return ..." must exist.
   error ("fseek: invalid_operation");
   return -1;
 }
 
 // Return current stream position.
 
 off_t
 octave_fstream::tell (void)
 {
-  // Note: error is inherited from octave_base_stream, not ::error.
+  // Note: error is inherited from octave::base_stream, not ::error.
   // This error function does not halt execution so "return ..." must exist.
   error ("ftell: invalid_operation");
   return -1;
 }
 
 // Return nonzero if EOF has been reached on this stream.
 
 bool
diff --git a/libinterp/corefcn/oct-fstrm.h b/libinterp/corefcn/oct-fstrm.h
--- a/libinterp/corefcn/oct-fstrm.h
+++ b/libinterp/corefcn/oct-fstrm.h
@@ -26,32 +26,32 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 #include <fstream>
 #include <string>
 
 #include "oct-stream.h"
 
 class
-octave_fstream : public octave_base_stream
+octave_fstream : public octave::base_stream
 {
 public:
 
   octave_fstream (const std::string& nm_arg,
                   std::ios::openmode arg_md = std::ios::in | std::ios::out,
                   octave::mach_info::float_format flt_fmt
                     = octave::mach_info::native_float_format ());
 
   // No copying!
 
   octave_fstream (const octave_fstream&) = delete;
 
   octave_fstream& operator = (const octave_fstream&) = delete;
 
-  static octave_stream
+  static octave::stream
   create (const std::string& nm_arg,
           std::ios::openmode arg_md = std::ios::in | std::ios::out,
           octave::mach_info::float_format flt_fmt
             = octave::mach_info::native_float_format ());
 
   // Position a stream at OFFSET relative to ORIGIN.
 
   int seek (off_t offset, int origin);
diff --git a/libinterp/corefcn/oct-iostrm.cc b/libinterp/corefcn/oct-iostrm.cc
--- a/libinterp/corefcn/oct-iostrm.cc
+++ b/libinterp/corefcn/oct-iostrm.cc
@@ -19,16 +19,18 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
+#include <iostream>
+
 #include "error.h"
 #include "oct-iostrm.h"
 
 // Position a stream at OFFSET relative to ORIGIN.
 
 int
 octave_base_iostream::seek (off_t, int)
 {
@@ -64,28 +66,28 @@ octave_base_iostream::invalid_operation 
 // Return nonzero if EOF has been reached on this stream.
 
 bool
 octave_istream::eof (void) const
 {
   return is && is->eof ();
 }
 
-octave_stream
+octave::stream
 octave_istream::create (std::istream *arg, const std::string& n)
 {
-  return octave_stream (new octave_istream (arg, n));
+  return octave::stream (new octave_istream (arg, n));
 }
 
 // Return nonzero if EOF has been reached on this stream.
 
 bool
 octave_ostream::eof (void) const
 {
   return os && os->eof ();
 }
 
-octave_stream
+octave::stream
 octave_ostream::create (std::ostream *arg, const std::string& n)
 {
-  return octave_stream (new octave_ostream (arg, n));
+  return octave::stream (new octave_ostream (arg, n));
 }
 
diff --git a/libinterp/corefcn/oct-iostrm.h b/libinterp/corefcn/oct-iostrm.h
--- a/libinterp/corefcn/oct-iostrm.h
+++ b/libinterp/corefcn/oct-iostrm.h
@@ -25,25 +25,25 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 #include <iosfwd>
 
 #include "oct-stream.h"
 
 class
-octave_base_iostream : public octave_base_stream
+octave_base_iostream : public octave::base_stream
 {
 public:
 
   octave_base_iostream (const std::string& n = "",
                         std::ios::openmode m = std::ios::in | std::ios::out,
                         octave::mach_info::float_format ff
                           = octave::mach_info::native_float_format ())
-    : octave_base_stream (m, ff), nm (n) { }
+    : octave::base_stream (m, ff), nm (n) { }
 
   // No copying!
 
   octave_base_iostream (const octave_base_iostream&) = delete;
 
   octave_base_iostream& operator = (const octave_base_iostream&) = delete;
 
 protected:
@@ -85,17 +85,17 @@ octave_istream : public octave_base_iost
 public:
 
   octave_istream (std::istream *arg = 0, const std::string& n = "")
     : octave_base_iostream (n, std::ios::in,
                             octave::mach_info::native_float_format ()),
       is (arg)
   { }
 
-  static octave_stream
+  static octave::stream
   create (std::istream *arg = 0, const std::string& n = "");
 
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
   std::istream *input_stream (void) { return is; }
 
@@ -124,17 +124,17 @@ octave_ostream : public octave_base_iost
 public:
 
   octave_ostream (std::ostream *arg, const std::string& n = "")
     : octave_base_iostream (n, std::ios::out,
                             octave::mach_info::native_float_format ()),
       os (arg)
   { }
 
-  static octave_stream
+  static octave::stream
   create (std::ostream *arg, const std::string& n = "");
 
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const;
 
   std::istream *input_stream (void) { return 0; }
 
diff --git a/libinterp/corefcn/oct-prcstrm.cc b/libinterp/corefcn/oct-prcstrm.cc
--- a/libinterp/corefcn/oct-prcstrm.cc
+++ b/libinterp/corefcn/oct-prcstrm.cc
@@ -24,40 +24,40 @@ along with Octave; see the file COPYING.
 #  include "config.h"
 #endif
 
 #include <cstdio>
 
 #include "oct-prcstrm.h"
 #include "sysdep.h"
 
-octave_stream
+octave::stream
 octave_iprocstream::create (const std::string& n, std::ios::openmode arg_md,
                             octave::mach_info::float_format ff)
 {
-  return octave_stream (new octave_iprocstream (n, arg_md, ff));
+  return octave::stream (new octave_iprocstream (n, arg_md, ff));
 }
 
 octave_iprocstream::octave_iprocstream (const std::string& n,
                                         std::ios::openmode arg_md,
                                         octave::mach_info::float_format ff)
   : octave_stdiostream (n, octave_popen (n.c_str (), "r"),
                         arg_md, ff, octave_pclose)
 { }
 
 octave_iprocstream::~octave_iprocstream (void)
 {
   do_close ();
 }
 
-octave_stream
+octave::stream
 octave_oprocstream::create (const std::string& n, std::ios::openmode arg_md,
                             octave::mach_info::float_format ff)
 {
-  return octave_stream (new octave_oprocstream (n, arg_md, ff));
+  return octave::stream (new octave_oprocstream (n, arg_md, ff));
 }
 
 octave_oprocstream::octave_oprocstream (const std::string& n,
                                         std::ios::openmode arg_md,
                                         octave::mach_info::float_format ff)
   : octave_stdiostream (n, octave_popen (n.c_str (), "w"),
                         arg_md, ff, octave_pclose)
 { }
diff --git a/libinterp/corefcn/oct-prcstrm.h b/libinterp/corefcn/oct-prcstrm.h
--- a/libinterp/corefcn/oct-prcstrm.h
+++ b/libinterp/corefcn/oct-prcstrm.h
@@ -41,17 +41,17 @@ public:
                         = octave::mach_info::native_float_format ());
 
   // No copying!
 
   octave_iprocstream (const octave_iprocstream&) = delete;
 
   octave_iprocstream& operator = (const octave_iprocstream&) = delete;
 
-  static octave_stream
+  static octave::stream
   create (const std::string& n, std::ios::openmode arg_md = std::ios::in,
           octave::mach_info::float_format flt_fmt
             = octave::mach_info::native_float_format ());
 
 protected:
 
   ~octave_iprocstream (void);
 };
@@ -67,17 +67,17 @@ public:
                         = octave::mach_info::native_float_format ());
 
   // No copying!
 
   octave_oprocstream (const octave_oprocstream&) = delete;
 
   octave_oprocstream& operator = (const octave_oprocstream&) = delete;
 
-  static octave_stream
+  static octave::stream
   create (const std::string& n, std::ios::openmode arg_md = std::ios::out,
           octave::mach_info::float_format flt_fmt
             = octave::mach_info::native_float_format ());
 
 protected:
 
   ~octave_oprocstream (void);
 };
diff --git a/libinterp/corefcn/oct-stdstrm.h b/libinterp/corefcn/oct-stdstrm.h
--- a/libinterp/corefcn/oct-stdstrm.h
+++ b/libinterp/corefcn/oct-stdstrm.h
@@ -25,26 +25,26 @@ along with Octave; see the file COPYING.
 
 #include "octave-config.h"
 
 #include "oct-stream.h"
 #include "c-file-ptr-stream.h"
 
 template <typename BUF_T, typename STREAM_T, typename FILE_T>
 class
-octave_tstdiostream : public octave_base_stream
+octave_tstdiostream : public octave::base_stream
 {
 public:
 
   octave_tstdiostream (const std::string& n, FILE_T f = 0, int fid = 0,
                        std::ios::openmode m = std::ios::in | std::ios::out,
                        octave::mach_info::float_format ff
                          = octave::mach_info::native_float_format (),
                        typename BUF_T::close_fcn cf = BUF_T::file_close)
-    : octave_base_stream (m, ff), nm (n), md (m),
+    : octave::base_stream (m, ff), nm (n), md (m),
       s (f ? new STREAM_T (f, cf) : 0), fnum (fid)
   { }
 
   // No copying!
 
   octave_tstdiostream (const octave_tstdiostream&) = delete;
 
   octave_tstdiostream& operator = (const octave_tstdiostream&) = delete;
@@ -105,24 +105,24 @@ public:
   octave_stdiostream (const std::string& n, FILE *f = 0,
                       std::ios::openmode m = std::ios::in | std::ios::out,
                       octave::mach_info::float_format ff
                         = octave::mach_info::native_float_format (),
                       c_file_ptr_buf::close_fcn cf = c_file_ptr_buf::file_close)
     : octave_tstdiostream<c_file_ptr_buf, io_c_file_ptr_stream, FILE *>
        (n, f, f ? fileno (f) : -1, m, ff, cf) { }
 
-  static octave_stream
+  static octave::stream
   create (const std::string& n, FILE *f = 0,
           std::ios::openmode m = std::ios::in | std::ios::out,
           octave::mach_info::float_format ff
             = octave::mach_info::native_float_format (),
           c_file_ptr_buf::close_fcn cf = c_file_ptr_buf::file_close)
   {
-    return octave_stream (new octave_stdiostream (n, f, m, ff, cf));
+    return octave::stream (new octave_stdiostream (n, f, m, ff, cf));
   }
 
   // No copying!
 
   octave_stdiostream (const octave_stdiostream&) = delete;
 
   octave_stdiostream& operator = (const octave_stdiostream&) = delete;
 
@@ -143,24 +143,24 @@ public:
                        std::ios::openmode m = std::ios::in | std::ios::out,
                        octave::mach_info::float_format ff
                          = octave::mach_info::native_float_format (),
                        c_zfile_ptr_buf::close_fcn cf
                          = c_zfile_ptr_buf::file_close)
     : octave_tstdiostream<c_zfile_ptr_buf, io_c_zfile_ptr_stream, gzFile>
        (n, f, fid, m, ff, cf) { }
 
-  static octave_stream
+  static octave::stream
   create (const std::string& n, gzFile f = 0, int fid = 0,
           std::ios::openmode m = std::ios::in | std::ios::out,
           octave::mach_info::float_format ff
             = octave::mach_info::native_float_format (),
           c_zfile_ptr_buf::close_fcn cf = c_zfile_ptr_buf::file_close)
   {
-    return octave_stream (new octave_zstdiostream (n, f, fid, m, ff, cf));
+    return octave::stream (new octave_zstdiostream (n, f, fid, m, ff, cf));
   }
 
   // No copying!
 
   octave_zstdiostream (const octave_zstdiostream&) = delete;
 
   octave_zstdiostream& operator = (const octave_zstdiostream&) = delete;
 
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -55,17 +55,17 @@ along with Octave; see the file COPYING.
 #include "oct-stdstrm.h"
 #include "oct-stream.h"
 #include "ov.h"
 #include "ovl.h"
 #include "utils.h"
 
 // Programming Note: There are two very different error functions used
 // in the stream code.  When invoked with "error (...)" the member
-// function from octave_stream or octave_base_stream is called.  This
+// function from octave::stream or octave::base_stream is called.  This
 // function sets the error state on the stream AND returns control to
 // the caller.  The caller must then return a value at the end of the
 // function.  When invoked with "::error (...)" the exception-based
 // error function from error.h is used.  This function will throw an
 // exception and not return control to the caller.  BE CAREFUL and
 // invoke the correct error function!
 
 // Possible values for conv_err:
@@ -173,269 +173,16 @@ get_size (const Array<double>& size, oct
     ::error ("%s: invalid size specification", who.c_str ());
 
   nr = get_size (dnr, who);
 
   if (dnc >= 0.0)
     nc = get_size (dnc, who);
 }
 
-class
-scanf_format_elt
-{
-public:
-
-  enum special_conversion
-  {
-    whitespace_conversion = 1,
-    literal_conversion = 2,
-    null = 3
-  };
-
-  scanf_format_elt (const char *txt = 0, int w = 0, bool d = false,
-                    char typ = '\0', char mod = '\0',
-                    const std::string& ch_class = "")
-    : text (strsave (txt)), width (w), discard (d), type (typ),
-      modifier (mod), char_class (ch_class)
-  { }
-
-  scanf_format_elt (const scanf_format_elt& e)
-    : text (strsave (e.text)), width (e.width), discard (e.discard),
-      type (e.type), modifier (e.modifier), char_class (e.char_class)
-  { }
-
-  scanf_format_elt& operator = (const scanf_format_elt& e)
-  {
-    if (this != &e)
-      {
-        text = strsave (e.text);
-        width = e.width;
-        discard = e.discard;
-        type = e.type;
-        modifier = e.modifier;
-        char_class = e.char_class;
-      }
-
-    return *this;
-  }
-
-  ~scanf_format_elt (void) { delete [] text; }
-
-  // The C-style format string.
-  const char *text;
-
-  // The maximum field width.
-  int width;
-
-  // TRUE if we are not storing the result of this conversion.
-  bool discard;
-
-  // Type of conversion -- 'd', 'i', 'o', 'u', 'x', 'e', 'f', 'g',
-  // 'c', 's', 'p', '%', or '['.
-  char type;
-
-  // A length modifier -- 'h', 'l', or 'L'.
-  char modifier;
-
-  // The class of characters in a '[' format.
-  std::string char_class;
-};
-
-class
-scanf_format_list
-{
-public:
-
-  scanf_format_list (const std::string& fmt = "");
-
-  // No copying!
-
-  scanf_format_list (const scanf_format_list&) = delete;
-
-  scanf_format_list& operator = (const scanf_format_list&) = delete;
-
-  ~scanf_format_list (void);
-
-  octave_idx_type num_conversions (void) { return nconv; }
-
-  // The length can be different than the number of conversions.
-  // For example, "x %d y %d z" has 2 conversions but the length of
-  // the list is 3 because of the characters that appear after the
-  // last conversion.
-
-  size_t length (void) const { return fmt_elts.size (); }
-
-  const scanf_format_elt *first (void)
-  {
-    curr_idx = 0;
-    return current ();
-  }
-
-  const scanf_format_elt *current (void) const
-  {
-    return length () > 0 ? fmt_elts[curr_idx] : 0;
-  }
-
-  const scanf_format_elt *next (bool cycle = true)
-  {
-    static scanf_format_elt dummy
-      (0, 0, false, scanf_format_elt::null, '\0', "");
-
-    curr_idx++;
-
-    if (curr_idx >= length ())
-      {
-        if (cycle)
-          curr_idx = 0;
-        else
-          return &dummy;
-      }
-
-    return current ();
-  }
-
-  void printme (void) const;
-
-  bool ok (void) const { return (nconv >= 0); }
-
-  operator bool () const { return ok (); }
-
-  bool all_character_conversions (void);
-
-  bool all_numeric_conversions (void);
-
-private:
-
-  // Number of conversions specified by this format string, or -1 if
-  // invalid conversions have been found.
-  octave_idx_type nconv;
-
-  // Index to current element;
-  size_t curr_idx;
-
-  // List of format elements.
-  std::deque<scanf_format_elt*> fmt_elts;
-
-  // Temporary buffer.
-  std::ostringstream buf;
-
-  void add_elt_to_list (int width, bool discard, char type, char modifier,
-                        const std::string& char_class = "");
-
-  void process_conversion (const std::string& s, size_t& i, size_t n,
-                           int& width, bool& discard, char& type,
-                           char& modifier);
-
-  int finish_conversion (const std::string& s, size_t& i, size_t n,
-                         int& width, bool discard, char& type,
-                         char modifier);
-};
-
-scanf_format_list::scanf_format_list (const std::string& s)
-  : nconv (0), curr_idx (0), fmt_elts (), buf ()
-{
-  size_t n = s.length ();
-
-  size_t i = 0;
-
-  int width = 0;
-  bool discard = false;
-  char modifier = '\0';
-  char type = '\0';
-
-  bool have_more = true;
-
-  while (i < n)
-    {
-      have_more = true;
-
-      if (s[i] == '%')
-        {
-          // Process percent-escape conversion type.
-
-          process_conversion (s, i, n, width, discard, type, modifier);
-
-          have_more = (buf.tellp () != 0);
-        }
-      else if (isspace (s[i]))
-        {
-          type = scanf_format_elt::whitespace_conversion;
-
-          width = 0;
-          discard = false;
-          modifier = '\0';
-          buf << " ";
-
-          while (++i < n && isspace (s[i]))
-            ; // skip whitespace
-
-          add_elt_to_list (width, discard, type, modifier);
-
-          have_more = false;
-        }
-      else
-        {
-          type = scanf_format_elt::literal_conversion;
-
-          width = 0;
-          discard = false;
-          modifier = '\0';
-
-          while (i < n && ! isspace (s[i]) && s[i] != '%')
-            buf << s[i++];
-
-          add_elt_to_list (width, discard, type, modifier);
-
-          have_more = false;
-        }
-
-      if (nconv < 0)
-        {
-          have_more = false;
-          break;
-        }
-    }
-
-  if (have_more)
-    add_elt_to_list (width, discard, type, modifier);
-
-  buf.clear ();
-  buf.str ("");
-}
-
-scanf_format_list::~scanf_format_list (void)
-{
-  size_t n = fmt_elts.size ();
-
-  for (size_t i = 0; i < n; i++)
-    {
-      scanf_format_elt *elt = fmt_elts[i];
-      delete elt;
-    }
-}
-
-void
-scanf_format_list::add_elt_to_list (int width, bool discard, char type,
-                                    char modifier,
-                                    const std::string& char_class)
-{
-  std::string text = buf.str ();
-
-  if (! text.empty ())
-    {
-      scanf_format_elt *elt
-        = new scanf_format_elt (text.c_str (), width, discard, type,
-                                modifier, char_class);
-
-      fmt_elts.push_back (elt);
-    }
-
-  buf.clear ();
-  buf.str ("");
-}
 
 static std::string
 expand_char_class (const std::string& s)
 {
   std::string retval;
 
   size_t len = s.length ();
 
@@ -463,721 +210,978 @@ expand_char_class (const std::string& s)
           if (c != '-' || i == len)
             retval += c;
         }
     }
 
   return retval;
 }
 
-void
-scanf_format_list::process_conversion (const std::string& s, size_t& i,
-                                       size_t n, int& width, bool& discard,
-                                       char& type, char& modifier)
-{
-  width = 0;
-  discard = false;
-  modifier = '\0';
-  type = '\0';
-
-  buf << s[i++];
-
-  bool have_width = false;
-
-  while (i < n)
-    {
-      switch (s[i])
-        {
-        case '*':
-          if (discard)
-            nconv = -1;
-          else
-            {
-              discard = true;
-              buf << s[i++];
-            }
-          break;
-
-        case '0': case '1': case '2': case '3': case '4':
-        case '5': case '6': case '7': case '8': case '9':
-          if (have_width)
-            nconv = -1;
-          else
-            {
-              char c = s[i++];
-              width = 10 * width + c - '0';
-              have_width = true;
-              buf << c;
-              while (i < n && isdigit (s[i]))
-                {
-                  c = s[i++];
-                  width = 10 * width + c - '0';
-                  buf << c;
-                }
-            }
-          break;
-
-        case 'h': case 'l': case 'L':
-          if (modifier != '\0')
-            nconv = -1;
-          else
-            modifier = s[i++];
-          break;
-
-        case 'd': case 'i': case 'o': case 'u': case 'x':
-          if (modifier == 'L')
-            {
-              nconv = -1;
-              break;
-            }
-          goto fini;
-
-        case 'e': case 'f': case 'g':
-          if (modifier == 'h')
-            {
-              nconv = -1;
-              break;
-            }
-
-          // No float or long double conversions, thanks.
-          buf << 'l';
-
-          goto fini;
-
-        case 'c': case 's': case 'p': case '%': case '[':
-          if (modifier != '\0')
-            {
-              nconv = -1;
-              break;
-            }
-          goto fini;
-
-        fini:
-          {
-            if (finish_conversion (s, i, n, width, discard,
-                                   type, modifier) == 0)
-              return;
-          }
-          break;
-
-        default:
-          nconv = -1;
-          break;
-        }
-
-      if (nconv < 0)
-        break;
-    }
-
-  nconv = -1;
-}
-
-int
-scanf_format_list::finish_conversion (const std::string& s, size_t& i,
-                                      size_t n, int& width, bool discard,
-                                      char& type, char modifier)
-{
-  int retval = 0;
-
-  std::string char_class;
-
-  size_t beg_idx = std::string::npos;
-  size_t end_idx = std::string::npos;
-
-  if (s[i] == '%')
-    {
-      type = '%';
-      buf << s[i++];
-    }
-  else
-    {
-      type = s[i];
-
-      if (s[i] == '[')
-        {
-          buf << s[i++];
-
-          if (i < n)
-            {
-              beg_idx = i;
-
-              if (s[i] == '^')
-                {
-                  type = '^';
-                  buf << s[i++];
-
-                  if (i < n)
-                    {
-                      beg_idx = i;
-
-                      if (s[i] == ']')
-                        buf << s[i++];
-                    }
-                }
-              else if (s[i] == ']')
-                buf << s[i++];
-            }
-
-          while (i < n && s[i] != ']')
-            buf << s[i++];
-
-          if (i < n && s[i] == ']')
-            {
-              end_idx = i-1;
-              buf << s[i++];
-            }
-
-          if (s[i-1] != ']')
-            retval = nconv = -1;
-        }
-      else
-        buf << s[i++];
-
-      nconv++;
-    }
-
-  if (nconv >= 0)
-    {
-      if (beg_idx != std::string::npos && end_idx != std::string::npos)
-        char_class = expand_char_class (s.substr (beg_idx,
-                                        end_idx - beg_idx + 1));
-
-      add_elt_to_list (width, discard, type, modifier, char_class);
-    }
-
-  return retval;
-}
-
-void
-scanf_format_list::printme (void) const
-{
-  size_t n = fmt_elts.size ();
-
-  for (size_t i = 0; i < n; i++)
-    {
-      scanf_format_elt *elt = fmt_elts[i];
-
-      std::cerr
-        << "width:      " << elt->width << "\n"
-        << "discard:    " << elt->discard << "\n"
-        << "type:       ";
-
-      if (elt->type == scanf_format_elt::literal_conversion)
-        std::cerr << "literal text\n";
-      else if (elt->type == scanf_format_elt::whitespace_conversion)
-        std::cerr << "whitespace\n";
-      else
-        std::cerr << elt->type << "\n";
-
-      std::cerr
-        << "modifier:   " << elt->modifier << "\n"
-        << "char_class: '" << undo_string_escapes (elt->char_class) << "'\n"
-        << "text:       '" << undo_string_escapes (elt->text) << "'\n\n";
-    }
-}
-
-bool
-scanf_format_list::all_character_conversions (void)
-{
-  size_t n = fmt_elts.size ();
-
-  if (n > 0)
-    {
-      for (size_t i = 0; i < n; i++)
-        {
-          scanf_format_elt *elt = fmt_elts[i];
-
-          switch (elt->type)
-            {
-            case 'c': case 's': case '%': case '[': case '^':
-            case scanf_format_elt::literal_conversion:
-            case scanf_format_elt::whitespace_conversion:
-              break;
-
-            default:
-              return false;
-              break;
-            }
-        }
-
-      return true;
-    }
-  else
-    return false;
-}
-
-bool
-scanf_format_list::all_numeric_conversions (void)
-{
-  size_t n = fmt_elts.size ();
-
-  if (n > 0)
-    {
-      for (size_t i = 0; i < n; i++)
-        {
-          scanf_format_elt *elt = fmt_elts[i];
-
-          switch (elt->type)
-            {
-            case 'd': case 'i': case 'o': case 'u': case 'x':
-            case 'e': case 'f': case 'g':
-              break;
-
-            default:
-              return false;
-              break;
-            }
-        }
-
-      return true;
-    }
-  else
-    return false;
-}
-
-class
-printf_format_elt
-{
-public:
-
-  printf_format_elt (const char *txt = 0, int n = 0, int w = -1,
-                     int p = -1, const std::string& f = "",
-                     char typ = '\0', char mod = '\0')
-    : text (strsave (txt)), args (n), fw (w), prec (p), flags (f),
-      type (typ), modifier (mod)
-  { }
-
-  printf_format_elt (const printf_format_elt& e)
-    : text (strsave (e.text)), args (e.args), fw (e.fw), prec (e.prec),
-      flags (e.flags), type (e.type), modifier (e.modifier)
-  { }
-
-  printf_format_elt& operator = (const printf_format_elt& e)
-  {
-    if (this != &e)
-      {
-        text = strsave (e.text);
-        args = e.args;
-        fw = e.fw;
-        prec = e.prec;
-        flags = e.flags;
-        type = e.type;
-        modifier = e.modifier;
-      }
-
-    return *this;
-  }
-
-  ~printf_format_elt (void) { delete [] text; }
-
-  // The C-style format string.
-  const char *text;
-
-  // How many args do we expect to consume?
-  int args;
-
-  // Field width.
-  int fw;
-
-  // Precision.
-  int prec;
-
-  // Flags -- '-', '+', ' ', '0', or '#'.
-  std::string flags;
-
-  // Type of conversion -- 'd', 'i', 'o', 'x', 'X', 'u', 'c', 's',
-  // 'f', 'e', 'E', 'g', 'G', 'p', or '%'
-  char type;
-
-  // A length modifier -- 'h', 'l', or 'L'.
-  char modifier;
-};
-
-class
-printf_format_list
+namespace octave
 {
-public:
-
-  printf_format_list (const std::string& fmt = "");
-
-  // No copying!
-
-  printf_format_list (const printf_format_list&) = delete;
-
-  printf_format_list& operator = (const printf_format_list&) = delete;
-
-  ~printf_format_list (void);
-
-  octave_idx_type num_conversions (void) { return nconv; }
-
-  const printf_format_elt *first (void)
-  {
-    curr_idx = 0;
-    return current ();
-  }
-
-  const printf_format_elt *current (void) const
-  {
-    return length () > 0 ? fmt_elts[curr_idx] : 0;
-  }
-
-  size_t length (void) const { return fmt_elts.size (); }
-
-  const printf_format_elt *next (bool cycle = true)
-  {
-    curr_idx++;
-
-    if (curr_idx >= length ())
-      {
-        if (cycle)
-          curr_idx = 0;
-        else
-          return 0;
-      }
-
-    return current ();
-  }
-
-  bool last_elt_p (void) { return (curr_idx + 1 == length ()); }
-
-  void printme (void) const;
-
-  bool ok (void) const { return (nconv >= 0); }
-
-  operator bool () const { return ok (); }
-
-private:
-
-  // Number of conversions specified by this format string, or -1 if
-  // invalid conversions have been found.
-  octave_idx_type nconv;
-
-  // Index to current element;
-  size_t curr_idx;
-
-  // List of format elements.
-  std::deque<printf_format_elt*> fmt_elts;
-
-  // Temporary buffer.
-  std::ostringstream buf;
-
-  void add_elt_to_list (int args, const std::string& flags, int fw,
-                        int prec, char type, char modifier);
-
-  void process_conversion (const std::string& s, size_t& i, size_t n,
-                           int& args, std::string& flags, int& fw,
-                           int& prec, char& modifier, char& type);
-
-  void finish_conversion (const std::string& s, size_t& i, int args,
-                          const std::string& flags, int fw, int prec,
-                          char modifier, char& type);
-};
-
-printf_format_list::printf_format_list (const std::string& s)
-  : nconv (0), curr_idx (0), fmt_elts (), buf ()
-{
-  size_t n = s.length ();
-
-  size_t i = 0;
-
-  int args = 0;
-  std::string flags;
-  int fw = -1;
-  int prec = -1;
-  char modifier = '\0';
-  char type = '\0';
-
-  bool have_more = true;
-  bool empty_buf = true;
-
-  if (n == 0)
+  class
+  scanf_format_elt
+  {
+  public:
+
+    enum special_conversion
+      {
+        whitespace_conversion = 1,
+        literal_conversion = 2,
+        null = 3
+      };
+
+    scanf_format_elt (const char *txt = 0, int w = 0, bool d = false,
+                      char typ = '\0', char mod = '\0',
+                      const std::string& ch_class = "")
+      : text (strsave (txt)), width (w), discard (d), type (typ),
+        modifier (mod), char_class (ch_class)
+    { }
+
+    scanf_format_elt (const scanf_format_elt& e)
+      : text (strsave (e.text)), width (e.width), discard (e.discard),
+        type (e.type), modifier (e.modifier), char_class (e.char_class)
+    { }
+
+    scanf_format_elt& operator = (const scanf_format_elt& e)
     {
-      printf_format_elt *elt
-        = new printf_format_elt ("", args, fw, prec, flags, type, modifier);
-
-      fmt_elts.push_back (elt);
-    }
-  else
-    {
-      while (i < n)
+      if (this != &e)
         {
-          have_more = true;
-
-          empty_buf = (buf.tellp () == 0);
-
-          switch (s[i])
-            {
-            case '%':
-              {
-                if (empty_buf)
-                  {
-                    process_conversion (s, i, n, args, flags, fw, prec,
-                                        type, modifier);
-
-                    // If there is nothing in the buffer, then
-                    // add_elt_to_list must have just been called, so we
-                    // are already done with the current element and we
-                    // don't need to call add_elt_to_list if this is our
-                    // last trip through the loop.
-
-                    have_more = (buf.tellp () != 0);
-                  }
-                else
-                  add_elt_to_list (args, flags, fw, prec, type, modifier);
-              }
-              break;
-
-            default:
-              {
-                args = 0;
-                flags = "";
-                fw = -1;
-                prec = -1;
-                modifier = '\0';
-                type = '\0';
-                buf << s[i++];
-                empty_buf = false;
-              }
-              break;
-            }
-
-          if (nconv < 0)
-            {
-              have_more = false;
-              break;
-            }
+          text = strsave (e.text);
+          width = e.width;
+          discard = e.discard;
+          type = e.type;
+          modifier = e.modifier;
+          char_class = e.char_class;
         }
 
-      if (have_more)
-        add_elt_to_list (args, flags, fw, prec, type, modifier);
-
-      buf.clear ();
-      buf.str ("");
-    }
-}
-
-printf_format_list::~printf_format_list (void)
-{
-  size_t n = fmt_elts.size ();
-
-  for (size_t i = 0; i < n; i++)
-    {
-      printf_format_elt *elt = fmt_elts[i];
-      delete elt;
+      return *this;
     }
-}
-
-void
-printf_format_list::add_elt_to_list (int args, const std::string& flags,
-                                     int fw, int prec, char type,
-                                     char modifier)
-{
-  std::string text = buf.str ();
-
-  if (! text.empty ())
+
+    ~scanf_format_elt (void) { delete [] text; }
+
+    // The C-style format string.
+    const char *text;
+
+    // The maximum field width.
+    int width;
+
+    // TRUE if we are not storing the result of this conversion.
+    bool discard;
+
+    // Type of conversion -- 'd', 'i', 'o', 'u', 'x', 'e', 'f', 'g',
+    // 'c', 's', 'p', '%', or '['.
+    char type;
+
+    // A length modifier -- 'h', 'l', or 'L'.
+    char modifier;
+
+    // The class of characters in a '[' format.
+    std::string char_class;
+  };
+
+  class
+  scanf_format_list
+  {
+  public:
+
+    scanf_format_list (const std::string& fmt = "");
+
+    // No copying!
+
+    scanf_format_list (const scanf_format_list&) = delete;
+
+    scanf_format_list& operator = (const scanf_format_list&) = delete;
+
+    ~scanf_format_list (void);
+
+    octave_idx_type num_conversions (void) { return nconv; }
+
+    // The length can be different than the number of conversions.
+    // For example, "x %d y %d z" has 2 conversions but the length of
+    // the list is 3 because of the characters that appear after the
+    // last conversion.
+
+    size_t length (void) const { return fmt_elts.size (); }
+
+    const scanf_format_elt *first (void)
     {
-      printf_format_elt *elt
-        = new printf_format_elt (text.c_str (), args, fw, prec, flags,
-                                 type, modifier);
-
-      fmt_elts.push_back (elt);
+      curr_idx = 0;
+      return current ();
+    }
+
+    const scanf_format_elt *current (void) const
+    {
+      return length () > 0 ? fmt_elts[curr_idx] : 0;
+    }
+
+    const scanf_format_elt *next (bool cycle = true)
+    {
+      static scanf_format_elt dummy
+        (0, 0, false, scanf_format_elt::null, '\0', "");
+
+      curr_idx++;
+
+      if (curr_idx >= length ())
+        {
+          if (cycle)
+            curr_idx = 0;
+          else
+            return &dummy;
+        }
+
+      return current ();
     }
 
-  buf.clear ();
-  buf.str ("");
-}
-
-void
-printf_format_list::process_conversion (const std::string& s, size_t& i,
-                                        size_t n, int& args,
-                                        std::string& flags, int& fw,
-                                        int& prec, char& modifier,
-                                        char& type)
-{
-  args = 0;
-  flags = "";
-  fw = -1;
-  prec = -1;
-  modifier = '\0';
-  type = '\0';
-
-  buf << s[i++];
-
-  bool nxt = false;
-
-  while (i < n)
-    {
-      switch (s[i])
-        {
-        case '-': case '+': case ' ': case '0': case '#':
-          flags += s[i];
-          buf << s[i++];
+    void printme (void) const;
+
+    bool ok (void) const { return (nconv >= 0); }
+
+    operator bool () const { return ok (); }
+
+    bool all_character_conversions (void);
+
+    bool all_numeric_conversions (void);
+
+  private:
+
+    // Number of conversions specified by this format string, or -1 if
+    // invalid conversions have been found.
+    octave_idx_type nconv;
+
+    // Index to current element;
+    size_t curr_idx;
+
+    // List of format elements.
+    std::deque<scanf_format_elt*> fmt_elts;
+
+    // Temporary buffer.
+    std::ostringstream buf;
+
+    void add_elt_to_list (int width, bool discard, char type, char modifier,
+                          const std::string& char_class = "");
+
+    void process_conversion (const std::string& s, size_t& i, size_t n,
+                             int& width, bool& discard, char& type,
+                             char& modifier);
+
+    int finish_conversion (const std::string& s, size_t& i, size_t n,
+                           int& width, bool discard, char& type,
+                           char modifier);
+  };
+
+  scanf_format_list::scanf_format_list (const std::string& s)
+    : nconv (0), curr_idx (0), fmt_elts (), buf ()
+  {
+    size_t n = s.length ();
+
+    size_t i = 0;
+
+    int width = 0;
+    bool discard = false;
+    char modifier = '\0';
+    char type = '\0';
+
+    bool have_more = true;
+
+    while (i < n)
+      {
+        have_more = true;
+
+        if (s[i] == '%')
+          {
+            // Process percent-escape conversion type.
+
+            process_conversion (s, i, n, width, discard, type, modifier);
+
+            have_more = (buf.tellp () != 0);
+          }
+        else if (isspace (s[i]))
+          {
+            type = scanf_format_elt::whitespace_conversion;
+
+            width = 0;
+            discard = false;
+            modifier = '\0';
+            buf << " ";
+
+            while (++i < n && isspace (s[i]))
+              ; // skip whitespace
+
+            add_elt_to_list (width, discard, type, modifier);
+
+            have_more = false;
+          }
+        else
+          {
+            type = scanf_format_elt::literal_conversion;
+
+            width = 0;
+            discard = false;
+            modifier = '\0';
+
+            while (i < n && ! isspace (s[i]) && s[i] != '%')
+              buf << s[i++];
+
+            add_elt_to_list (width, discard, type, modifier);
+
+            have_more = false;
+          }
+
+        if (nconv < 0)
+          {
+            have_more = false;
+            break;
+          }
+      }
+
+    if (have_more)
+      add_elt_to_list (width, discard, type, modifier);
+
+    buf.clear ();
+    buf.str ("");
+  }
+
+  scanf_format_list::~scanf_format_list (void)
+  {
+    size_t n = fmt_elts.size ();
+
+    for (size_t i = 0; i < n; i++)
+      {
+        scanf_format_elt *elt = fmt_elts[i];
+        delete elt;
+      }
+  }
+
+  void
+  scanf_format_list::add_elt_to_list (int width, bool discard, char type,
+                                      char modifier,
+                                      const std::string& char_class)
+  {
+    std::string text = buf.str ();
+
+    if (! text.empty ())
+      {
+        scanf_format_elt *elt
+          = new scanf_format_elt (text.c_str (), width, discard, type,
+                                  modifier, char_class);
+
+        fmt_elts.push_back (elt);
+      }
+
+    buf.clear ();
+    buf.str ("");
+  }
+
+  void
+  scanf_format_list::process_conversion (const std::string& s, size_t& i,
+                                         size_t n, int& width, bool& discard,
+                                         char& type, char& modifier)
+  {
+    width = 0;
+    discard = false;
+    modifier = '\0';
+    type = '\0';
+
+    buf << s[i++];
+
+    bool have_width = false;
+
+    while (i < n)
+      {
+        switch (s[i])
+          {
+          case '*':
+            if (discard)
+              nconv = -1;
+            else
+              {
+                discard = true;
+                buf << s[i++];
+              }
+            break;
+
+          case '0': case '1': case '2': case '3': case '4':
+          case '5': case '6': case '7': case '8': case '9':
+            if (have_width)
+              nconv = -1;
+            else
+              {
+                char c = s[i++];
+                width = 10 * width + c - '0';
+                have_width = true;
+                buf << c;
+                while (i < n && isdigit (s[i]))
+                  {
+                    c = s[i++];
+                    width = 10 * width + c - '0';
+                    buf << c;
+                  }
+              }
+            break;
+
+          case 'h': case 'l': case 'L':
+            if (modifier != '\0')
+              nconv = -1;
+            else
+              modifier = s[i++];
+            break;
+
+          case 'd': case 'i': case 'o': case 'u': case 'x':
+            if (modifier == 'L')
+              {
+                nconv = -1;
+                break;
+              }
+            goto fini;
+
+          case 'e': case 'f': case 'g':
+            if (modifier == 'h')
+              {
+                nconv = -1;
+                break;
+              }
+
+            // No float or long double conversions, thanks.
+            buf << 'l';
+
+            goto fini;
+
+          case 'c': case 's': case 'p': case '%': case '[':
+            if (modifier != '\0')
+              {
+                nconv = -1;
+                break;
+              }
+            goto fini;
+
+          fini:
+            {
+              if (finish_conversion (s, i, n, width, discard,
+                                     type, modifier) == 0)
+                return;
+            }
+            break;
+
+          default:
+            nconv = -1;
+            break;
+          }
+
+        if (nconv < 0)
           break;
-
-        default:
-          nxt = true;
-          break;
-        }
-
-      if (nxt)
-        break;
-    }
-
-  if (i < n)
-    {
-      if (s[i] == '*')
-        {
-          fw = -2;
-          args++;
+      }
+
+    nconv = -1;
+  }
+
+  int
+  scanf_format_list::finish_conversion (const std::string& s, size_t& i,
+                                        size_t n, int& width, bool discard,
+                                        char& type, char modifier)
+  {
+    int retval = 0;
+
+    std::string char_class;
+
+    size_t beg_idx = std::string::npos;
+    size_t end_idx = std::string::npos;
+
+    if (s[i] == '%')
+      {
+        type = '%';
+        buf << s[i++];
+      }
+    else
+      {
+        type = s[i];
+
+        if (s[i] == '[')
+          {
+            buf << s[i++];
+
+            if (i < n)
+              {
+                beg_idx = i;
+
+                if (s[i] == '^')
+                  {
+                    type = '^';
+                    buf << s[i++];
+
+                    if (i < n)
+                      {
+                        beg_idx = i;
+
+                        if (s[i] == ']')
+                          buf << s[i++];
+                      }
+                  }
+                else if (s[i] == ']')
+                  buf << s[i++];
+              }
+
+            while (i < n && s[i] != ']')
+              buf << s[i++];
+
+            if (i < n && s[i] == ']')
+              {
+                end_idx = i-1;
+                buf << s[i++];
+              }
+
+            if (s[i-1] != ']')
+              retval = nconv = -1;
+          }
+        else
           buf << s[i++];
-        }
-      else
-        {
-          if (isdigit (s[i]))
-            {
-              int nn = 0;
-              std::string tmp = s.substr (i);
-              sscanf (tmp.c_str (), "%d%n", &fw, &nn);
-            }
-
-          while (i < n && isdigit (s[i]))
-            buf << s[i++];
-        }
-    }
-
-  if (i < n && s[i] == '.')
+
+        nconv++;
+      }
+
+    if (nconv >= 0)
+      {
+        if (beg_idx != std::string::npos && end_idx != std::string::npos)
+          char_class = expand_char_class (s.substr (beg_idx,
+                                                    end_idx - beg_idx + 1));
+
+        add_elt_to_list (width, discard, type, modifier, char_class);
+      }
+
+    return retval;
+  }
+
+  void
+  scanf_format_list::printme (void) const
+  {
+    size_t n = fmt_elts.size ();
+
+    for (size_t i = 0; i < n; i++)
+      {
+        scanf_format_elt *elt = fmt_elts[i];
+
+        std::cerr
+          << "width:      " << elt->width << "\n"
+          << "discard:    " << elt->discard << "\n"
+          << "type:       ";
+
+        if (elt->type == scanf_format_elt::literal_conversion)
+          std::cerr << "literal text\n";
+        else if (elt->type == scanf_format_elt::whitespace_conversion)
+          std::cerr << "whitespace\n";
+        else
+          std::cerr << elt->type << "\n";
+
+        std::cerr
+          << "modifier:   " << elt->modifier << "\n"
+          << "char_class: '" << undo_string_escapes (elt->char_class) << "'\n"
+          << "text:       '" << undo_string_escapes (elt->text) << "'\n\n";
+      }
+  }
+
+  bool
+  scanf_format_list::all_character_conversions (void)
+  {
+    size_t n = fmt_elts.size ();
+
+    if (n > 0)
+      {
+        for (size_t i = 0; i < n; i++)
+          {
+            scanf_format_elt *elt = fmt_elts[i];
+
+            switch (elt->type)
+              {
+              case 'c': case 's': case '%': case '[': case '^':
+              case scanf_format_elt::literal_conversion:
+              case scanf_format_elt::whitespace_conversion:
+                break;
+
+              default:
+                return false;
+                break;
+              }
+          }
+
+        return true;
+      }
+    else
+      return false;
+  }
+
+  bool
+  scanf_format_list::all_numeric_conversions (void)
+  {
+    size_t n = fmt_elts.size ();
+
+    if (n > 0)
+      {
+        for (size_t i = 0; i < n; i++)
+          {
+            scanf_format_elt *elt = fmt_elts[i];
+
+            switch (elt->type)
+              {
+              case 'd': case 'i': case 'o': case 'u': case 'x':
+              case 'e': case 'f': case 'g':
+                break;
+
+              default:
+                return false;
+                break;
+              }
+          }
+
+        return true;
+      }
+    else
+      return false;
+  }
+
+  class
+  printf_format_elt
+  {
+  public:
+
+    printf_format_elt (const char *txt = 0, int n = 0, int w = -1,
+                       int p = -1, const std::string& f = "",
+                       char typ = '\0', char mod = '\0')
+      : text (strsave (txt)), args (n), fw (w), prec (p), flags (f),
+        type (typ), modifier (mod)
+    { }
+
+    printf_format_elt (const printf_format_elt& e)
+      : text (strsave (e.text)), args (e.args), fw (e.fw), prec (e.prec),
+        flags (e.flags), type (e.type), modifier (e.modifier)
+    { }
+
+    printf_format_elt& operator = (const printf_format_elt& e)
     {
-      // nothing before the . means 0.
-      if (fw == -1)
-        fw = 0;
-
-      // . followed by nothing is 0.
-      prec = 0;
-
-      buf << s[i++];
-
-      if (i < n)
+      if (this != &e)
         {
-          if (s[i] == '*')
-            {
-              prec = -2;
-              args++;
-              buf << s[i++];
-            }
-          else
-            {
-              if (isdigit (s[i]))
-                {
-                  int nn = 0;
-                  std::string tmp = s.substr (i);
-                  sscanf (tmp.c_str (), "%d%n", &prec, &nn);
-                }
-
-              while (i < n && isdigit (s[i]))
-                buf << s[i++];
-            }
+          text = strsave (e.text);
+          args = e.args;
+          fw = e.fw;
+          prec = e.prec;
+          flags = e.flags;
+          type = e.type;
+          modifier = e.modifier;
         }
+
+      return *this;
     }
 
-  if (i < n)
+    ~printf_format_elt (void) { delete [] text; }
+
+    // The C-style format string.
+    const char *text;
+
+    // How many args do we expect to consume?
+    int args;
+
+    // Field width.
+    int fw;
+
+    // Precision.
+    int prec;
+
+    // Flags -- '-', '+', ' ', '0', or '#'.
+    std::string flags;
+
+    // Type of conversion -- 'd', 'i', 'o', 'x', 'X', 'u', 'c', 's',
+    // 'f', 'e', 'E', 'g', 'G', 'p', or '%'
+    char type;
+
+    // A length modifier -- 'h', 'l', or 'L'.
+    char modifier;
+  };
+
+  class
+  printf_format_list
+  {
+  public:
+
+    printf_format_list (const std::string& fmt = "");
+
+    // No copying!
+
+    printf_format_list (const printf_format_list&) = delete;
+
+    printf_format_list& operator = (const printf_format_list&) = delete;
+
+    ~printf_format_list (void);
+
+    octave_idx_type num_conversions (void) { return nconv; }
+
+    const printf_format_elt *first (void)
     {
-      // Accept and record modifier, but don't place it in the format
-      // item text.  All integer conversions are handled as 64-bit
-      // integers.
-
-      switch (s[i])
-        {
-        case 'h': case 'l': case 'L':
-          modifier = s[i++];
-          break;
-
-        default:
-          break;
-        }
+      curr_idx = 0;
+      return current ();
     }
 
-  if (i < n)
-    finish_conversion (s, i, args, flags, fw, prec, modifier, type);
-  else
-    nconv = -1;
-}
-
-void
-printf_format_list::finish_conversion (const std::string& s, size_t& i,
-                                       int args, const std::string& flags,
-                                       int fw, int prec, char modifier,
-                                       char& type)
-{
-  switch (s[i])
+    const printf_format_elt *current (void) const
+    {
+      return length () > 0 ? fmt_elts[curr_idx] : 0;
+    }
+
+    size_t length (void) const { return fmt_elts.size (); }
+
+    const printf_format_elt *next (bool cycle = true)
     {
-    case 'd': case 'i': case 'o': case 'x': case 'X':
-    case 'u': case 'c':
-      if (modifier == 'L')
+      curr_idx++;
+
+      if (curr_idx >= length ())
         {
-          nconv = -1;
-          break;
-        }
-      goto fini;
-
-    case 'f': case 'e': case 'E': case 'g': case 'G':
-      if (modifier == 'h' || modifier == 'l')
-        {
-          nconv = -1;
-          break;
+          if (cycle)
+            curr_idx = 0;
+          else
+            return 0;
         }
-      goto fini;
-
-    case 's': case 'p': case '%':
-      if (modifier != '\0')
-        {
-          nconv = -1;
+
+      return current ();
+    }
+
+    bool last_elt_p (void) { return (curr_idx + 1 == length ()); }
+
+    void printme (void) const;
+
+    bool ok (void) const { return (nconv >= 0); }
+
+    operator bool () const { return ok (); }
+
+  private:
+
+    // Number of conversions specified by this format string, or -1 if
+    // invalid conversions have been found.
+    octave_idx_type nconv;
+
+    // Index to current element;
+    size_t curr_idx;
+
+    // List of format elements.
+    std::deque<printf_format_elt*> fmt_elts;
+
+    // Temporary buffer.
+    std::ostringstream buf;
+
+    void add_elt_to_list (int args, const std::string& flags, int fw,
+                          int prec, char type, char modifier);
+
+    void process_conversion (const std::string& s, size_t& i, size_t n,
+                             int& args, std::string& flags, int& fw,
+                             int& prec, char& modifier, char& type);
+
+    void finish_conversion (const std::string& s, size_t& i, int args,
+                            const std::string& flags, int fw, int prec,
+                            char modifier, char& type);
+  };
+
+  printf_format_list::printf_format_list (const std::string& s)
+    : nconv (0), curr_idx (0), fmt_elts (), buf ()
+  {
+    size_t n = s.length ();
+
+    size_t i = 0;
+
+    int args = 0;
+    std::string flags;
+    int fw = -1;
+    int prec = -1;
+    char modifier = '\0';
+    char type = '\0';
+
+    bool have_more = true;
+    bool empty_buf = true;
+
+    if (n == 0)
+      {
+        printf_format_elt *elt
+          = new printf_format_elt ("", args, fw, prec, flags, type, modifier);
+
+        fmt_elts.push_back (elt);
+      }
+    else
+      {
+        while (i < n)
+          {
+            have_more = true;
+
+            empty_buf = (buf.tellp () == 0);
+
+            switch (s[i])
+              {
+              case '%':
+                {
+                  if (empty_buf)
+                    {
+                      process_conversion (s, i, n, args, flags, fw, prec,
+                                          type, modifier);
+
+                      // If there is nothing in the buffer, then
+                      // add_elt_to_list must have just been called, so we
+                      // are already done with the current element and we
+                      // don't need to call add_elt_to_list if this is our
+                      // last trip through the loop.
+
+                      have_more = (buf.tellp () != 0);
+                    }
+                  else
+                    add_elt_to_list (args, flags, fw, prec, type, modifier);
+                }
+                break;
+
+              default:
+                {
+                  args = 0;
+                  flags = "";
+                  fw = -1;
+                  prec = -1;
+                  modifier = '\0';
+                  type = '\0';
+                  buf << s[i++];
+                  empty_buf = false;
+                }
+                break;
+              }
+
+            if (nconv < 0)
+              {
+                have_more = false;
+                break;
+              }
+          }
+
+        if (have_more)
+          add_elt_to_list (args, flags, fw, prec, type, modifier);
+
+        buf.clear ();
+        buf.str ("");
+      }
+  }
+
+  printf_format_list::~printf_format_list (void)
+  {
+    size_t n = fmt_elts.size ();
+
+    for (size_t i = 0; i < n; i++)
+      {
+        printf_format_elt *elt = fmt_elts[i];
+        delete elt;
+      }
+  }
+
+  void
+  printf_format_list::add_elt_to_list (int args, const std::string& flags,
+                                       int fw, int prec, char type,
+                                       char modifier)
+  {
+    std::string text = buf.str ();
+
+    if (! text.empty ())
+      {
+        printf_format_elt *elt
+          = new printf_format_elt (text.c_str (), args, fw, prec, flags,
+                                   type, modifier);
+
+        fmt_elts.push_back (elt);
+      }
+
+    buf.clear ();
+    buf.str ("");
+  }
+
+  void
+  printf_format_list::process_conversion (const std::string& s, size_t& i,
+                                          size_t n, int& args,
+                                          std::string& flags, int& fw,
+                                          int& prec, char& modifier,
+                                          char& type)
+  {
+    args = 0;
+    flags = "";
+    fw = -1;
+    prec = -1;
+    modifier = '\0';
+    type = '\0';
+
+    buf << s[i++];
+
+    bool nxt = false;
+
+    while (i < n)
+      {
+        switch (s[i])
+          {
+          case '-': case '+': case ' ': case '0': case '#':
+            flags += s[i];
+            buf << s[i++];
+            break;
+
+          default:
+            nxt = true;
+            break;
+          }
+
+        if (nxt)
           break;
-        }
-      goto fini;
-
-    fini:
-
-      type = s[i];
-
-      buf << s[i++];
-
-      if (type != '%' || args != 0)
-        nconv++;
-
-      if (type != '%')
-        args++;
-
-      add_elt_to_list (args, flags, fw, prec, type, modifier);
-
-      break;
-
-    default:
+      }
+
+    if (i < n)
+      {
+        if (s[i] == '*')
+          {
+            fw = -2;
+            args++;
+            buf << s[i++];
+          }
+        else
+          {
+            if (isdigit (s[i]))
+              {
+                int nn = 0;
+                std::string tmp = s.substr (i);
+                sscanf (tmp.c_str (), "%d%n", &fw, &nn);
+              }
+
+            while (i < n && isdigit (s[i]))
+              buf << s[i++];
+          }
+      }
+
+    if (i < n && s[i] == '.')
+      {
+        // nothing before the . means 0.
+        if (fw == -1)
+          fw = 0;
+
+        // . followed by nothing is 0.
+        prec = 0;
+
+        buf << s[i++];
+
+        if (i < n)
+          {
+            if (s[i] == '*')
+              {
+                prec = -2;
+                args++;
+                buf << s[i++];
+              }
+            else
+              {
+                if (isdigit (s[i]))
+                  {
+                    int nn = 0;
+                    std::string tmp = s.substr (i);
+                    sscanf (tmp.c_str (), "%d%n", &prec, &nn);
+                  }
+
+                while (i < n && isdigit (s[i]))
+                  buf << s[i++];
+              }
+          }
+      }
+
+    if (i < n)
+      {
+        // Accept and record modifier, but don't place it in the format
+        // item text.  All integer conversions are handled as 64-bit
+        // integers.
+
+        switch (s[i])
+          {
+          case 'h': case 'l': case 'L':
+            modifier = s[i++];
+            break;
+
+          default:
+            break;
+          }
+      }
+
+    if (i < n)
+      finish_conversion (s, i, args, flags, fw, prec, modifier, type);
+    else
       nconv = -1;
-      break;
-    }
-}
-
-void
-printf_format_list::printme (void) const
-{
-  size_t n = fmt_elts.size ();
-
-  for (size_t i = 0; i < n; i++)
-    {
-      printf_format_elt *elt = fmt_elts[i];
-
-      std::cerr
-        << "args:     " << elt->args << "\n"
-        << "flags:    '" << elt->flags << "'\n"
-        << "width:    " << elt->fw << "\n"
-        << "prec:     " << elt->prec << "\n"
-        << "type:     '" << elt->type << "'\n"
-        << "modifier: '" << elt->modifier << "'\n"
-        << "text:     '" << undo_string_escapes (elt->text) << "'\n\n";
-    }
+  }
+
+  void
+  printf_format_list::finish_conversion (const std::string& s, size_t& i,
+                                         int args, const std::string& flags,
+                                         int fw, int prec, char modifier,
+                                         char& type)
+  {
+    switch (s[i])
+      {
+      case 'd': case 'i': case 'o': case 'x': case 'X':
+      case 'u': case 'c':
+        if (modifier == 'L')
+          {
+            nconv = -1;
+            break;
+          }
+        goto fini;
+
+      case 'f': case 'e': case 'E': case 'g': case 'G':
+        if (modifier == 'h' || modifier == 'l')
+          {
+            nconv = -1;
+            break;
+          }
+        goto fini;
+
+      case 's': case 'p': case '%':
+        if (modifier != '\0')
+          {
+            nconv = -1;
+            break;
+          }
+        goto fini;
+
+      fini:
+
+        type = s[i];
+
+        buf << s[i++];
+
+        if (type != '%' || args != 0)
+          nconv++;
+
+        if (type != '%')
+          args++;
+
+        add_elt_to_list (args, flags, fw, prec, type, modifier);
+
+        break;
+
+      default:
+        nconv = -1;
+        break;
+      }
+  }
+
+  void
+  printf_format_list::printme (void) const
+  {
+    size_t n = fmt_elts.size ();
+
+    for (size_t i = 0; i < n; i++)
+      {
+        printf_format_elt *elt = fmt_elts[i];
+
+        std::cerr
+          << "args:     " << elt->args << "\n"
+          << "flags:    '" << elt->flags << "'\n"
+          << "width:    " << elt->fw << "\n"
+          << "prec:     " << elt->prec << "\n"
+          << "type:     '" << elt->type << "'\n"
+          << "modifier: '" << elt->modifier << "'\n"
+          << "text:     '" << undo_string_escapes (elt->text) << "'\n\n";
+      }
+  }
 }
 
 // Calculate x^n.  Used for ...e+nn so that, for example, 1e2 is
 // exactly 100 and 5e-1 is 1/2
 
 static double
 pown (double x, unsigned int n)
 {
@@ -1615,20 +1619,20 @@ namespace octave
   // A single conversion specifier, such as %f or %c.
 
   class
   textscan_format_elt
   {
   public:
 
     enum special_conversion
-    {
-      whitespace_conversion = 1,
-      literal_conversion = 2
-    };
+      {
+        whitespace_conversion = 1,
+        literal_conversion = 2
+      };
 
     textscan_format_elt (const std::string& txt, int w = 0, int p = -1,
                          int bw = 0, bool dis = false, char typ = '\0',
                          const std::string& ch_class = std::string ())
       : text (txt), width (w), prec (p), bitwidth (bw),
         char_class (ch_class), type (typ), discard (dis),
         numeric (typ == 'd' || typ == 'u' || type == 'f' || type == 'n')
     { }
@@ -2709,17 +2713,17 @@ namespace octave
     Array<octave_idx_type> ra_idx (dim_vector (1,2));
 
     // (err & 1) means "error, and no columns read this row
     // FIXME: This may redundant now that done_after=0 says the same
     if (err & 1)
       done_after = out.size () + 1;
 
     int valid_rows = (row == ntimes) ? ntimes
-                                     : (((err & 1) && (err & 8)) ? row : row+1);
+      : (((err & 1) && (err & 8)) ? row : row+1);
     dim_vector dv (valid_rows, 1);
 
     ra_idx(0) = 0;
     int i = 0;
     if (! collect_output)
       {
         retval = Cell (dim_vector (1, out.size ()));
         for (auto& col : out)
@@ -2969,17 +2973,17 @@ namespace octave
                 std::ios::iostate state = is.rdstate ();
 
                 is.get ();
                 ch2 = is.get ();
                 if (ch2 == 'f')
                   {
                     inf = true;
                     re = (ch == '+') ? octave::numeric_limits<double>::Inf ()
-                                     : -octave::numeric_limits<double>::Inf ();
+                      : -octave::numeric_limits<double>::Inf ();
                     value = 0;
                   }
                 else
                   {
                     is.clear (state);
                     is.seekg (pos);   // reset to position before look-ahead
                   }
               }
@@ -3496,17 +3500,17 @@ namespace octave
 
         elem = fmt_list.next ();
         char *pos = is.tellg ();
 
         // FIXME: these conversions "ignore delimiters".  Should they include
         // delimiters at the start of the conversion, or can those be skipped?
         if (elem->type != textscan_format_elt::literal_conversion
             // && elem->type != '[' && elem->type != '^' && elem->type != 'c'
-           )
+            )
           skip_delim (is);
 
         if (is.eof ())
           {
             if (! done)
               done_after = i+1;
 
             // note EOF, but process others to get empty_val.
@@ -3527,19 +3531,19 @@ namespace octave
         else if (! done && ! conversion_failed)
           nothing_worked = false;
       }
 
     if (done)
       is.setstate (std::ios::eofbit);
 
     return no_conversions
-           + (is.eof () ? 2 : 0)
-           + (conversion_failed ? 4 : 0)
-           + (nothing_worked ? 8 : 0);
+      + (is.eof () ? 2 : 0)
+      + (conversion_failed ? 4 : 0)
+      + (nothing_worked ? 8 : 0);
 
   }
 
   void
   textscan::parse_options (const octave_value_list& args,
                            textscan_format_list& fmt_list)
   {
     int last = args.length ();
@@ -3955,413 +3959,413 @@ namespace octave
             if (ch != std::istream::traits_type::eof ())
               is.putback (ch);
             is.setstate (std::ios::failbit);
             return false;
           }
       }
     return true;
   }
-}
-
-void
-octave_base_stream::error (const std::string& msg)
-{
-  fail = true;
-  errmsg = msg;
-}
-
-void
-octave_base_stream::error (const std::string& who, const std::string& msg)
-{
-  fail = true;
-  errmsg = who + ": " + msg;
-}
-
-void
-octave_base_stream::clear (void)
-{
-  fail = false;
-  errmsg = "";
-}
-
-void
-octave_base_stream::clearerr (void)
-{
-  std::istream *is = input_stream ();
-  std::ostream *os = output_stream ();
-
-  if (is)
-    is->clear ();
-
-  if (os)
-    os->clear ();
-}
-
-// Functions that are defined for all input streams (input streams
-// are those that define is).
-
-std::string
-octave_base_stream::do_gets (octave_idx_type max_len, bool& err,
-                             bool strip_newline, const std::string& who)
-{
-  if (octave::application::interactive () && file_number () == 0)
-    ::error ("%s: unable to read from stdin while running interactively",
-             who.c_str ());
-
-  std::string retval;
-
-  err = false;
-
-  std::istream *isp = input_stream ();
-
-  if (! isp)
-    {
-      err = true;
-      invalid_operation (who, "reading");
-    }
-  else
-    {
-      std::istream& is = *isp;
-
-      std::ostringstream buf;
-
-      int c = 0;
-      int char_count = 0;
-
-      if (max_len != 0)
+
+  void
+  base_stream::error (const std::string& msg)
+  {
+    fail = true;
+    errmsg = msg;
+  }
+
+  void
+  base_stream::error (const std::string& who, const std::string& msg)
+  {
+    fail = true;
+    errmsg = who + ": " + msg;
+  }
+
+  void
+  base_stream::clear (void)
+  {
+    fail = false;
+    errmsg = "";
+  }
+
+  void
+  base_stream::clearerr (void)
+  {
+    std::istream *is = input_stream ();
+    std::ostream *os = output_stream ();
+
+    if (is)
+      is->clear ();
+
+    if (os)
+      os->clear ();
+  }
+
+  // Functions that are defined for all input streams (input streams
+  // are those that define is).
+
+  std::string
+  base_stream::do_gets (octave_idx_type max_len, bool& err,
+                        bool strip_newline, const std::string& who)
+  {
+    if (octave::application::interactive () && file_number () == 0)
+      ::error ("%s: unable to read from stdin while running interactively",
+               who.c_str ());
+
+    std::string retval;
+
+    err = false;
+
+    std::istream *isp = input_stream ();
+
+    if (! isp)
+      {
+        err = true;
+        invalid_operation (who, "reading");
+      }
+    else
+      {
+        std::istream& is = *isp;
+
+        std::ostringstream buf;
+
+        int c = 0;
+        int char_count = 0;
+
+        if (max_len != 0)
+          {
+            while (is && (c = is.get ()) != std::istream::traits_type::eof ())
+              {
+                char_count++;
+
+                // Handle CRLF, CR, or LF as line ending.
+                if (c == '\r')
+                  {
+                    if (! strip_newline)
+                      buf << static_cast<char> (c);
+
+                    c = is.get ();
+
+                    if (c != std::istream::traits_type::eof ())
+                      {
+                        if (c == '\n')
+                          {
+                            char_count++;
+
+                            if (! strip_newline)
+                              buf << static_cast<char> (c);
+                          }
+                        else
+                          is.putback (c);
+                      }
+
+                    break;
+                  }
+                else if (c == '\n')
+                  {
+                    if (! strip_newline)
+                      buf << static_cast<char> (c);
+
+                    break;
+                  }
+                else
+                  buf << static_cast<char> (c);
+
+                if (max_len > 0 && char_count == max_len)
+                  break;
+              }
+          }
+
+        if (! is.eof () && char_count > 0)
+          {
+            // GAGME.  Matlab seems to check for EOF even if the last character
+            // in a file is a newline character.  This is NOT what the
+            // corresponding C-library functions do.
+            int disgusting_compatibility_hack = is.get ();
+            if (! is.eof ())
+              is.putback (disgusting_compatibility_hack);
+          }
+
+        if (is.good () || (is.eof () && char_count > 0))
+          retval = buf.str ();
+        else
+          {
+            err = true;
+
+            if (is.eof () && char_count == 0)
+              error (who, "at end of file");
+            else
+              error (who, "read error");
+          }
+      }
+
+    return retval;
+  }
+
+  std::string
+  base_stream::getl (octave_idx_type max_len, bool& err,
+                     const std::string& who)
+  {
+    return do_gets (max_len, err, true, who);
+  }
+
+  std::string
+  base_stream::gets (octave_idx_type max_len, bool& err,
+                     const std::string& who)
+  {
+    return do_gets (max_len, err, false, who);
+  }
+
+  off_t
+  base_stream::skipl (off_t num, bool& err, const std::string& who)
+  {
+    if (octave::application::interactive () && file_number () == 0)
+      ::error ("%s: unable to read from stdin while running interactively",
+               who.c_str ());
+
+    off_t cnt = -1;
+
+    err = false;
+
+    std::istream *isp = input_stream ();
+
+    if (! isp)
+      {
+        err = true;
+        invalid_operation (who, "reading");
+      }
+    else
+      {
+        std::istream& is = *isp;
+
+        int c = 0;
+        int lastc = -1;
+        cnt = 0;
+
+        while (is && (c = is.get ()) != std::istream::traits_type::eof ())
+          {
+            // Handle CRLF, CR, or LF as line ending.
+            if (c == '\r' || (c == '\n' && lastc != '\r'))
+              {
+                if (++cnt == num)
+                  break;
+              }
+
+            lastc = c;
+          }
+
+        // Maybe eat the following \n if \r was just met.
+        if (c == '\r' && is.peek () == '\n')
+          is.get ();
+
+        if (is.bad ())
+          {
+            err = true;
+            error (who, "read error");
+          }
+
+        if (err)
+          cnt = -1;
+      }
+
+    return cnt;
+  }
+
+  template <typename T>
+  std::istream&
+  octave_scan_1 (std::istream& is, const scanf_format_elt& fmt,
+                 T* valptr)
+  {
+    T value = T ();
+
+    switch (fmt.type)
+      {
+      case 'o':
+        is >> std::oct >> value >> std::dec;
+        break;
+
+      case 'x':
+        is >> std::hex >> value >> std::dec;
+        break;
+
+      case 'i':
         {
-          while (is && (c = is.get ()) != std::istream::traits_type::eof ())
+          int c1 = std::istream::traits_type::eof ();
+
+          while (is && (c1 = is.get ()) != std::istream::traits_type::eof ()
+                 && isspace (c1))
+            ; // skip whitespace
+
+          if (c1 != std::istream::traits_type::eof ())
             {
-              char_count++;
-
-              // Handle CRLF, CR, or LF as line ending.
-              if (c == '\r')
+              if (c1 == '0')
                 {
-                  if (! strip_newline)
-                    buf << static_cast<char> (c);
-
-                  c = is.get ();
-
-                  if (c != std::istream::traits_type::eof ())
+                  int c2 = is.peek ();
+
+                  if (c2 == 'x' || c2 == 'X')
+                    {
+                      is.ignore ();
+                      if (std::isxdigit (is.peek ()))
+                        is >> std::hex >> value >> std::dec;
+                      else
+                        value = 0;
+                    }
+                  else
                     {
-                      if (c == '\n')
+                      if (c2 == '0' || c2 == '1' || c2 == '2'
+                          || c2 == '3' || c2 == '4' || c2 == '5'
+                          || c2 == '6' || c2 == '7')
+                        is >> std::oct >> value >> std::dec;
+                      else if (c2 == '8' || c2 == '9')
                         {
-                          char_count++;
-
-                          if (! strip_newline)
-                            buf << static_cast<char> (c);
+                          // FIXME: Would like to set error state on octave
+                          // stream.  See bug #46493.  But only std::istream is
+                          // input to fcn.
+                          // error ("internal failure to match octal format");
+                          value = 0;
                         }
                       else
-                        is.putback (c);
+                        value = 0;
                     }
-
-                  break;
-                }
-              else if (c == '\n')
-                {
-                  if (! strip_newline)
-                    buf << static_cast<char> (c);
-
-                  break;
                 }
               else
-                buf << static_cast<char> (c);
-
-              if (max_len > 0 && char_count == max_len)
-                break;
+                {
+                  is.putback (c1);
+
+                  is >> value;
+                }
             }
         }
-
-      if (! is.eof () && char_count > 0)
-        {
-          // GAGME.  Matlab seems to check for EOF even if the last character
-          // in a file is a newline character.  This is NOT what the
-          // corresponding C-library functions do.
-          int disgusting_compatibility_hack = is.get ();
-          if (! is.eof ())
-            is.putback (disgusting_compatibility_hack);
-        }
-
-      if (is.good () || (is.eof () && char_count > 0))
-        retval = buf.str ();
-      else
+        break;
+
+      default:
+        is >> value;
+        break;
+      }
+
+    // If conversion produces an integer that overflows, failbit is set but
+    // value is non-zero.  We want to treat this case as success, so clear
+    // failbit from the stream state to keep going.
+    // FIXME: Maybe set error state on octave stream as above? Matlab does
+    // *not* indicate an error message on overflow.
+    if ((is.rdstate () & std::ios::failbit) && value != T ())
+      is.clear (is.rdstate () & ~std::ios::failbit);
+
+    // Only copy the converted value if the stream is in a state where we
+    // want to continue reading.
+    if (! (is.rdstate () & std::ios::failbit))
+      *valptr = value;
+
+    return is;
+  }
+
+  template <typename T>
+  std::istream&
+  octave_scan (std::istream& is, const scanf_format_elt& fmt, T* valptr)
+  {
+    if (fmt.width)
+      {
+        // Limit input to fmt.width characters by reading into a
+        // temporary stringstream buffer.
+        std::string tmp;
+
+        is.width (fmt.width);
+        is >> tmp;
+
+        std::istringstream ss (tmp);
+
+        octave_scan_1 (ss, fmt, valptr);
+      }
+    else
+      octave_scan_1 (is, fmt, valptr);
+
+    return is;
+  }
+
+  // Note that this specialization is only used for reading characters, not
+  // character strings.  See BEGIN_S_CONVERSION for details.
+
+  template <>
+  std::istream&
+  octave_scan<> (std::istream& is, const scanf_format_elt& /* fmt */,
+                 char* valptr)
+  {
+    return is >> valptr;
+  }
+
+  template <>
+  std::istream&
+  octave_scan<> (std::istream& is, const scanf_format_elt& fmt, double* valptr)
+  {
+    double& ref = *valptr;
+
+    switch (fmt.type)
+      {
+      case 'e':
+      case 'f':
+      case 'g':
         {
-          err = true;
-
-          if (is.eof () && char_count == 0)
-            error (who, "at end of file");
-          else
-            error (who, "read error");
-        }
-    }
-
-  return retval;
-}
-
-std::string
-octave_base_stream::getl (octave_idx_type max_len, bool& err,
-                          const std::string& who)
-{
-  return do_gets (max_len, err, true, who);
-}
-
-std::string
-octave_base_stream::gets (octave_idx_type max_len, bool& err,
-                          const std::string& who)
-{
-  return do_gets (max_len, err, false, who);
-}
-
-off_t
-octave_base_stream::skipl (off_t num, bool& err, const std::string& who)
-{
-  if (octave::application::interactive () && file_number () == 0)
-    ::error ("%s: unable to read from stdin while running interactively",
-             who.c_str ());
-
-  off_t cnt = -1;
-
-  err = false;
-
-  std::istream *isp = input_stream ();
-
-  if (! isp)
-    {
-      err = true;
-      invalid_operation (who, "reading");
-    }
-  else
-    {
-      std::istream& is = *isp;
-
-      int c = 0;
-      int lastc = -1;
-      cnt = 0;
-
-      while (is && (c = is.get ()) != std::istream::traits_type::eof ())
-        {
-          // Handle CRLF, CR, or LF as line ending.
-          if (c == '\r' || (c == '\n' && lastc != '\r'))
+          int c1 = std::istream::traits_type::eof ();
+
+          while (is && (c1 = is.get ()) != std::istream::traits_type::eof ()
+                 && isspace (c1))
+            ; // skip whitespace
+
+          if (c1 != std::istream::traits_type::eof ())
             {
-              if (++cnt == num)
-                break;
+              is.putback (c1);
+
+              ref = octave_read_value<double> (is);
             }
-
-          lastc = c;
-        }
-
-      // Maybe eat the following \n if \r was just met.
-      if (c == '\r' && is.peek () == '\n')
-        is.get ();
-
-      if (is.bad ())
-        {
-          err = true;
-          error (who, "read error");
         }
-
-      if (err)
-        cnt = -1;
-    }
-
-  return cnt;
-}
-
-template <typename T>
-std::istream&
-octave_scan_1 (std::istream& is, const scanf_format_elt& fmt, T* valptr)
-{
-  T value = T ();
-
-  switch (fmt.type)
-    {
-    case 'o':
-      is >> std::oct >> value >> std::dec;
-      break;
-
-    case 'x':
-      is >> std::hex >> value >> std::dec;
-      break;
-
-    case 'i':
-      {
-        int c1 = std::istream::traits_type::eof ();
-
-        while (is && (c1 = is.get ()) != std::istream::traits_type::eof ()
-               && isspace (c1))
-          ; // skip whitespace
-
-        if (c1 != std::istream::traits_type::eof ())
-          {
-            if (c1 == '0')
-              {
-                int c2 = is.peek ();
-
-                if (c2 == 'x' || c2 == 'X')
-                  {
-                    is.ignore ();
-                    if (std::isxdigit (is.peek ()))
-                      is >> std::hex >> value >> std::dec;
-                    else
-                      value = 0;
-                  }
-                else
-                  {
-                    if (c2 == '0' || c2 == '1' || c2 == '2'
-                        || c2 == '3' || c2 == '4' || c2 == '5'
-                        || c2 == '6' || c2 == '7')
-                      is >> std::oct >> value >> std::dec;
-                    else if (c2 == '8' || c2 == '9')
-                      {
-                        // FIXME: Would like to set error state on octave
-                        // stream.  See bug #46493.  But only std::istream is
-                        // input to fcn.
-                        // error ("internal failure to match octal format");
-                        value = 0;
-                      }
-                    else
-                      value = 0;
-                  }
-              }
-            else
-              {
-                is.putback (c1);
-
-                is >> value;
-              }
-          }
-      }
-      break;
-
-    default:
-      is >> value;
-      break;
-    }
-
-  // If conversion produces an integer that overflows, failbit is set but
-  // value is non-zero.  We want to treat this case as success, so clear
-  // failbit from the stream state to keep going.
-  // FIXME: Maybe set error state on octave stream as above? Matlab does
-  // *not* indicate an error message on overflow.
-  if ((is.rdstate () & std::ios::failbit) && value != T ())
-    is.clear (is.rdstate () & ~std::ios::failbit);
-
-  // Only copy the converted value if the stream is in a state where we
-  // want to continue reading.
-  if (! (is.rdstate () & std::ios::failbit))
-    *valptr = value;
-
-  return is;
-}
-
-template <typename T>
-std::istream&
-octave_scan (std::istream& is, const scanf_format_elt& fmt, T* valptr)
-{
-  if (fmt.width)
-    {
-      // Limit input to fmt.width characters by reading into a
-      // temporary stringstream buffer.
-      std::string tmp;
-
-      is.width (fmt.width);
-      is >> tmp;
-
-      std::istringstream ss (tmp);
-
-      octave_scan_1 (ss, fmt, valptr);
-    }
-  else
-    octave_scan_1 (is, fmt, valptr);
-
-  return is;
-}
-
-// Note that this specialization is only used for reading characters, not
-// character strings.  See BEGIN_S_CONVERSION for details.
-
-template <>
-std::istream&
-octave_scan<> (std::istream& is, const scanf_format_elt& /* fmt */,
-               char* valptr)
-{
-  return is >> valptr;
-}
-
-template <>
-std::istream&
-octave_scan<> (std::istream& is, const scanf_format_elt& fmt, double* valptr)
-{
-  double& ref = *valptr;
-
-  switch (fmt.type)
-    {
-    case 'e':
-    case 'f':
-    case 'g':
-      {
-        int c1 = std::istream::traits_type::eof ();
-
-        while (is && (c1 = is.get ()) != std::istream::traits_type::eof ()
-               && isspace (c1))
-          ; // skip whitespace
-
-        if (c1 != std::istream::traits_type::eof ())
-          {
-            is.putback (c1);
-
-            ref = octave_read_value<double> (is);
-          }
-      }
-      break;
-
-    default:
-      panic_impossible ();
-      break;
-    }
-
-  return is;
-}
-
-template <typename T>
-void
-do_scanf_conv (std::istream& is, const scanf_format_elt& fmt,
-               T valptr, Matrix& mval, double *data, octave_idx_type& idx,
-               octave_idx_type& conversion_count, octave_idx_type nr,
-               octave_idx_type max_size, bool discard)
-{
-  octave_scan (is, fmt, valptr);
-
-  if (! is)
-    return;
-
-  if (idx == max_size && ! discard)
-    {
-      max_size *= 2;
-
-      if (nr > 0)
-        mval.resize (nr, max_size / nr, 0.0);
-      else
-        mval.resize (max_size, 1, 0.0);
-
-      data = mval.fortran_vec ();
-    }
-
-  if (! discard)
-    {
-      conversion_count++;
-      data[idx++] = *(valptr);
-    }
-}
-
-template void
-do_scanf_conv (std::istream&, const scanf_format_elt&, double*,
-               Matrix&, double*, octave_idx_type&, octave_idx_type&,
-               octave_idx_type, octave_idx_type, bool);
+        break;
+
+      default:
+        panic_impossible ();
+        break;
+      }
+
+    return is;
+  }
+
+  template <typename T>
+  void
+  do_scanf_conv (std::istream& is, const scanf_format_elt& fmt,
+                 T valptr, Matrix& mval, double *data, octave_idx_type& idx,
+                 octave_idx_type& conversion_count, octave_idx_type nr,
+                 octave_idx_type max_size, bool discard)
+  {
+    octave_scan (is, fmt, valptr);
+
+    if (! is)
+      return;
+
+    if (idx == max_size && ! discard)
+      {
+        max_size *= 2;
+
+        if (nr > 0)
+          mval.resize (nr, max_size / nr, 0.0);
+        else
+          mval.resize (max_size, 1, 0.0);
+
+        data = mval.fortran_vec ();
+      }
+
+    if (! discard)
+      {
+        conversion_count++;
+        data[idx++] = *(valptr);
+      }
+  }
+
+  template void
+  do_scanf_conv (std::istream&, const scanf_format_elt&, double*,
+                 Matrix&, double*, octave_idx_type&, octave_idx_type&,
+                 octave_idx_type, octave_idx_type, bool);
 
 #define DO_WHITESPACE_CONVERSION()                                      \
   do                                                                    \
     {                                                                   \
       int c = std::istream::traits_type::eof ();                        \
                                                                         \
       while (is && (c = is.get ()) != std::istream::traits_type::eof () \
              && isspace (c))                                            \
@@ -4370,56 +4374,56 @@ do_scanf_conv (std::istream&, const scan
       if (c != std::istream::traits_type::eof ())                       \
         is.putback (c);                                                 \
     }                                                                   \
   while (0)
 
 #define DO_LITERAL_CONVERSION()                                         \
   do                                                                    \
     {                                                                   \
-     int c = std::istream::traits_type::eof ();                         \
+      int c = std::istream::traits_type::eof ();                        \
                                                                         \
-     int n = strlen (fmt);                                              \
-     int i = 0;                                                         \
+      int n = strlen (fmt);                                             \
+      int i = 0;                                                        \
                                                                         \
-     while (i < n && is && (c = is.get ()) != std::istream::traits_type::eof ()) \
-       {                                                                \
-        if (c == static_cast<unsigned char> (fmt[i]))                   \
-          {                                                             \
-           i++;                                                         \
-           continue;                                                    \
-           }                                                            \
-        else                                                            \
-          {                                                             \
-           is.putback (c);                                              \
-           break;                                                       \
-           }                                                            \
+      while (i < n && is && (c = is.get ()) != std::istream::traits_type::eof ()) \
+        {                                                               \
+          if (c == static_cast<unsigned char> (fmt[i]))                 \
+            {                                                           \
+              i++;                                                      \
+              continue;                                                 \
+            }                                                           \
+          else                                                          \
+            {                                                           \
+              is.putback (c);                                           \
+              break;                                                    \
+            }                                                           \
         }                                                               \
                                                                         \
-     if (i != n)                                                        \
-       is.setstate (std::ios::failbit);                                 \
-     }                                                                  \
+      if (i != n)                                                       \
+        is.setstate (std::ios::failbit);                                \
+    }                                                                   \
   while (0)
 
-#define DO_PCT_CONVERSION()                             \
-  do                                                    \
-    {                                                   \
-      int c = is.get ();                                \
-                                                        \
-      if (c != std::istream::traits_type::eof ())       \
-        {                                               \
-          if (c != '%')                                 \
-            {                                           \
-              is.putback (c);                           \
-              is.setstate (std::ios::failbit);          \
-            }                                           \
-        }                                               \
-      else                                              \
-        is.setstate (std::ios::failbit);                \
-    }                                                   \
+#define DO_PCT_CONVERSION()                     \
+  do                                            \
+    {                                           \
+  int c = is.get ();                            \
+                                                \
+  if (c != std::istream::traits_type::eof ())   \
+    {                                           \
+  if (c != '%')                                 \
+    {                                           \
+  is.putback (c);                               \
+  is.setstate (std::ios::failbit);              \
+}                                               \
+}                                               \
+  else                                          \
+    is.setstate (std::ios::failbit);            \
+}                                               \
   while (0)
 
 #define BEGIN_C_CONVERSION()                                            \
   is.unsetf (std::ios::skipws);                                         \
                                                                         \
   int width = elt->width ? elt->width : 1;                              \
                                                                         \
   std::string tmp (width, '\0');                                        \
@@ -4431,18 +4435,18 @@ do_scanf_conv (std::istream&, const scan
          && (c = is.get ()) != std::istream::traits_type::eof ())       \
     tmp[n++] = static_cast<char> (c);                                   \
                                                                         \
   if (n > 0 && c == std::istream::traits_type::eof ())                  \
     is.clear ();                                                        \
                                                                         \
   tmp.resize (n)
 
-// For a '%s' format, skip initial whitespace and then read until the
-// next whitespace character or until WIDTH characters have been read.
+  // For a '%s' format, skip initial whitespace and then read until the
+  // next whitespace character or until WIDTH characters have been read.
 #define BEGIN_S_CONVERSION()                                            \
   int width = elt->width;                                               \
                                                                         \
   std::string tmp;                                                      \
                                                                         \
   do                                                                    \
     {                                                                   \
       if (width)                                                        \
@@ -4481,60 +4485,60 @@ do_scanf_conv (std::istream&, const scan
         }                                                               \
       else                                                              \
         {                                                               \
           is >> std::ws >> tmp;                                         \
         }                                                               \
     }                                                                   \
   while (0)
 
-// This format must match a nonempty sequence of characters.
+  // This format must match a nonempty sequence of characters.
 #define BEGIN_CHAR_CLASS_CONVERSION()                                   \
   int width = elt->width;                                               \
                                                                         \
   std::string tmp;                                                      \
                                                                         \
   do                                                                    \
     {                                                                   \
-     if (! width)                                                       \
-       width = std::numeric_limits<int>::max ();                        \
+      if (! width)                                                      \
+        width = std::numeric_limits<int>::max ();                       \
                                                                         \
-     std::ostringstream buf;                                            \
+      std::ostringstream buf;                                           \
                                                                         \
-     std::string char_class = elt->char_class;                          \
+      std::string char_class = elt->char_class;                         \
                                                                         \
-     int c = std::istream::traits_type::eof ();                         \
+      int c = std::istream::traits_type::eof ();                        \
                                                                         \
-     if (elt->type == '[')                                              \
-       {                                                                \
-        int chars_read = 0;                                             \
-        while (is && chars_read++ < width                               \
-               && (c = is.get ()) != std::istream::traits_type::eof ()  \
-                                    && char_class.find (c) != std::string::npos) \
-          buf << static_cast<char> (c);                                 \
+      if (elt->type == '[')                                             \
+        {                                                               \
+          int chars_read = 0;                                           \
+          while (is && chars_read++ < width                             \
+                 && (c = is.get ()) != std::istream::traits_type::eof () \
+                 && char_class.find (c) != std::string::npos)           \
+            buf << static_cast<char> (c);                               \
         }                                                               \
-     else                                                               \
-       {                                                                \
-         int chars_read = 0;                                            \
-         while (is && chars_read++ < width                              \
-                && (c = is.get ()) != std::istream::traits_type::eof () \
-                && char_class.find (c) == std::string::npos)            \
-           buf << static_cast<char> (c);                                \
-       }                                                                \
+      else                                                              \
+        {                                                               \
+          int chars_read = 0;                                           \
+          while (is && chars_read++ < width                             \
+                 && (c = is.get ()) != std::istream::traits_type::eof () \
+                 && char_class.find (c) == std::string::npos)           \
+            buf << static_cast<char> (c);                               \
+        }                                                               \
                                                                         \
-     if (width == std::numeric_limits<int>::max ()                      \
-         && c != std::istream::traits_type::eof ())                     \
-       is.putback (c);                                                  \
+      if (width == std::numeric_limits<int>::max ()                     \
+          && c != std::istream::traits_type::eof ())                    \
+        is.putback (c);                                                 \
                                                                         \
-     tmp = buf.str ();                                                  \
+      tmp = buf.str ();                                                 \
                                                                         \
-     if (tmp.empty ())                                                  \
-       is.setstate (std::ios::failbit);                                 \
-     else if (c == std::istream::traits_type::eof ())                   \
-       is.clear ();                                                     \
+      if (tmp.empty ())                                                 \
+        is.setstate (std::ios::failbit);                                \
+      else if (c == std::istream::traits_type::eof ())                  \
+        is.clear ();                                                    \
                                                                         \
     }                                                                   \
   while (0)
 
 #define FINISH_CHARACTER_CONVERSION()                                   \
   do                                                                    \
     {                                                                   \
       width = tmp.length ();                                            \
@@ -4572,939 +4576,940 @@ do_scanf_conv (std::istream&, const scan
                                                                         \
                   data[data_index++] = tmp[i++];                        \
                 }                                                       \
             }                                                           \
         }                                                               \
     }                                                                   \
   while (0)
 
-octave_value
-octave_base_stream::do_scanf (scanf_format_list& fmt_list,
-                              octave_idx_type nr, octave_idx_type nc,
-                              bool one_elt_size_spec,
-                              octave_idx_type& conversion_count,
-                              const std::string& who)
-{
-  if (octave::application::interactive () && file_number () == 0)
-    ::error ("%s: unable to read from stdin while running interactively",
-             who.c_str ());
-
-  octave_value retval = Matrix ();
-
-  conversion_count = 0;
-
-  octave_idx_type nconv = fmt_list.num_conversions ();
-
-  octave_idx_type data_index = 0;
-
-  if (nr == 0 || nc == 0)
-    {
-      if (one_elt_size_spec)
-        nc = 0;
-
-      return Matrix (nr, nc, 0.0);
-    }
-
-  std::istream *isp = input_stream ();
-
-  bool all_char_conv = fmt_list.all_character_conversions ();
-
-  Matrix mval;
-  double *data = 0;
-  octave_idx_type max_size = 0;
-  octave_idx_type max_conv = 0;
-
-  octave_idx_type final_nr = 0;
-  octave_idx_type final_nc = 0;
-
-  if (all_char_conv)
-    {
-      // Any of these could be resized later (if we have %s conversions,
-      // we may read more than one element for each conversion).
-      if (one_elt_size_spec)
-        {
-          max_size = 512;
-          mval.resize (1, max_size, 0.0);
-
-          if (nr > 0)
-            max_conv = nr;
-        }
-      else if (nr > 0)
-        {
-          if (nc > 0)
-            {
-              mval.resize (nr, nc, 0.0);
-              max_size = max_conv = nr * nc;
-            }
-          else
-            {
-              mval.resize (nr, 32, 0.0);
-              max_size = nr * 32;
-            }
-        }
-      else
-        panic_impossible ();
-    }
-  else if (nr > 0)
-    {
-      if (nc > 0)
-        {
-          // Will not resize later.
-          mval.resize (nr, nc, 0.0);
-          max_size = nr * nc;
-          max_conv = max_size;
-        }
-      else
-        {
-          // Maybe resize later.
-          mval.resize (nr, 32, 0.0);
-          max_size = nr * 32;
-        }
-    }
-  else
-    {
-      // Maybe resize later.
-      mval.resize (32, 1, 0.0);
-      max_size = 32;
-    }
-
-  data = mval.fortran_vec ();
-
-  if (isp)
-    {
-      std::istream& is = *isp;
-
-      const scanf_format_elt *elt = fmt_list.first ();
-
-      std::ios::fmtflags flags = is.flags ();
-
-      octave_idx_type trips = 0;
-
-      octave_idx_type num_fmt_elts = fmt_list.length ();
-
-      for (;;)
-        {
-          octave_quit ();
-
-          if (elt)
-            {
-              if (elt->type == scanf_format_elt::null
-                  || (! (elt->type == scanf_format_elt::whitespace_conversion
-                         || elt->type == scanf_format_elt::literal_conversion
-                         || elt->type == '%')
-                      && max_conv > 0 && conversion_count == max_conv))
-                {
-                  // We are done, either because we have reached the end of the
-                  // format string and are not cycling through the format again
-                  // or because we've converted all the values that have been
-                  // requested and the next format element is a conversion.
-                  // Determine final array size and exit.
-                  if (all_char_conv && one_elt_size_spec)
+  octave_value
+  base_stream::do_scanf (scanf_format_list& fmt_list,
+                         octave_idx_type nr, octave_idx_type nc,
+                         bool one_elt_size_spec,
+                         octave_idx_type& conversion_count,
+                         const std::string& who)
+  {
+    if (octave::application::interactive () && file_number () == 0)
+      ::error ("%s: unable to read from stdin while running interactively",
+               who.c_str ());
+
+    octave_value retval = Matrix ();
+
+    conversion_count = 0;
+
+    octave_idx_type nconv = fmt_list.num_conversions ();
+
+    octave_idx_type data_index = 0;
+
+    if (nr == 0 || nc == 0)
+      {
+        if (one_elt_size_spec)
+          nc = 0;
+
+        return Matrix (nr, nc, 0.0);
+      }
+
+    std::istream *isp = input_stream ();
+
+    bool all_char_conv = fmt_list.all_character_conversions ();
+
+    Matrix mval;
+    double *data = 0;
+    octave_idx_type max_size = 0;
+    octave_idx_type max_conv = 0;
+
+    octave_idx_type final_nr = 0;
+    octave_idx_type final_nc = 0;
+
+    if (all_char_conv)
+      {
+        // Any of these could be resized later (if we have %s conversions,
+        // we may read more than one element for each conversion).
+        if (one_elt_size_spec)
+          {
+            max_size = 512;
+            mval.resize (1, max_size, 0.0);
+
+            if (nr > 0)
+              max_conv = nr;
+          }
+        else if (nr > 0)
+          {
+            if (nc > 0)
+              {
+                mval.resize (nr, nc, 0.0);
+                max_size = max_conv = nr * nc;
+              }
+            else
+              {
+                mval.resize (nr, 32, 0.0);
+                max_size = nr * 32;
+              }
+          }
+        else
+          panic_impossible ();
+      }
+    else if (nr > 0)
+      {
+        if (nc > 0)
+          {
+            // Will not resize later.
+            mval.resize (nr, nc, 0.0);
+            max_size = nr * nc;
+            max_conv = max_size;
+          }
+        else
+          {
+            // Maybe resize later.
+            mval.resize (nr, 32, 0.0);
+            max_size = nr * 32;
+          }
+      }
+    else
+      {
+        // Maybe resize later.
+        mval.resize (32, 1, 0.0);
+        max_size = 32;
+      }
+
+    data = mval.fortran_vec ();
+
+    if (isp)
+      {
+        std::istream& is = *isp;
+
+        const scanf_format_elt *elt = fmt_list.first ();
+
+        std::ios::fmtflags flags = is.flags ();
+
+        octave_idx_type trips = 0;
+
+        octave_idx_type num_fmt_elts = fmt_list.length ();
+
+        for (;;)
+          {
+            octave_quit ();
+
+            if (elt)
+              {
+                if (elt->type == scanf_format_elt::null
+                    || (! (elt->type == scanf_format_elt::whitespace_conversion
+                           || elt->type == scanf_format_elt::literal_conversion
+                           || elt->type == '%')
+                        && max_conv > 0 && conversion_count == max_conv))
+                  {
+                    // We are done, either because we have reached the end of the
+                    // format string and are not cycling through the format again
+                    // or because we've converted all the values that have been
+                    // requested and the next format element is a conversion.
+                    // Determine final array size and exit.
+                    if (all_char_conv && one_elt_size_spec)
+                      {
+                        final_nr = 1;
+                        final_nc = data_index;
+                      }
+                    else
+                      {
+                        final_nr = nr;
+                        final_nc = (data_index - 1) / nr + 1;
+                      }
+
+                    break;
+                  }
+                else if (data_index == max_size)
+                  {
+                    max_size *= 2;
+
+                    if (all_char_conv)
+                      {
+                        if (one_elt_size_spec)
+                          mval.resize (1, max_size, 0.0);
+                        else if (nr > 0)
+                          mval.resize (nr, max_size / nr, 0.0);
+                        else
+                          panic_impossible ();
+                      }
+                    else if (nr > 0)
+                      mval.resize (nr, max_size / nr, 0.0);
+                    else
+                      mval.resize (max_size, 1, 0.0);
+
+                    data = mval.fortran_vec ();
+                  }
+
+                const char *fmt = elt->text;
+
+                bool discard = elt->discard;
+
+                switch (elt->type)
+                  {
+                  case scanf_format_elt::whitespace_conversion:
+                    DO_WHITESPACE_CONVERSION ();
+                    break;
+
+                  case scanf_format_elt::literal_conversion:
+                    DO_LITERAL_CONVERSION ();
+                    break;
+
+                  case '%':
+                    DO_PCT_CONVERSION ();
+                    break;
+
+                  case 'd': case 'i':
                     {
-                      final_nr = 1;
-                      final_nc = data_index;
-                    }
-                  else
-                    {
-                      final_nr = nr;
-                      final_nc = (data_index - 1) / nr + 1;
-                    }
-
-                  break;
-                }
-              else if (data_index == max_size)
-                {
-                  max_size *= 2;
-
-                  if (all_char_conv)
-                    {
-                      if (one_elt_size_spec)
-                        mval.resize (1, max_size, 0.0);
-                      else if (nr > 0)
-                        mval.resize (nr, max_size / nr, 0.0);
-                      else
-                        panic_impossible ();
+                      switch (elt->modifier)
+                        {
+                        case 'h':
+                          {
+                            int16_t tmp;
+                            do_scanf_conv (is, *elt, &tmp, mval, data,
+                                           data_index, conversion_count,
+                                           nr, max_size, discard);
+                          }
+                          break;
+
+                        case 'l':
+                          {
+                            int64_t tmp;
+                            do_scanf_conv (is, *elt, &tmp, mval, data,
+                                           data_index, conversion_count,
+                                           nr, max_size, discard);
+                          }
+                          break;
+
+                        default:
+                          {
+                            int32_t tmp;
+                            do_scanf_conv (is, *elt, &tmp, mval, data,
+                                           data_index, conversion_count,
+                                           nr, max_size, discard);
+                          }
+                          break;
+                        }
                     }
-                  else if (nr > 0)
-                    mval.resize (nr, max_size / nr, 0.0);
-                  else
-                    mval.resize (max_size, 1, 0.0);
-
-                  data = mval.fortran_vec ();
-                }
-
-              const char *fmt = elt->text;
-
-              bool discard = elt->discard;
-
-              switch (elt->type)
-                {
-                case scanf_format_elt::whitespace_conversion:
-                  DO_WHITESPACE_CONVERSION ();
-                  break;
-
-                case scanf_format_elt::literal_conversion:
-                  DO_LITERAL_CONVERSION ();
-                  break;
-
-                case '%':
-                  DO_PCT_CONVERSION ();
-                  break;
-
-                case 'd': case 'i':
-                  {
-                    switch (elt->modifier)
-                      {
-                      case 'h':
-                        {
-                          int16_t tmp;
-                          do_scanf_conv (is, *elt, &tmp, mval, data,
-                                         data_index, conversion_count,
-                                         nr, max_size, discard);
-                        }
-                        break;
-
-                      case 'l':
-                        {
-                          int64_t tmp;
-                          do_scanf_conv (is, *elt, &tmp, mval, data,
-                                         data_index, conversion_count,
-                                         nr, max_size, discard);
-                        }
-                        break;
-
-                      default:
-                        {
-                          int32_t tmp;
-                          do_scanf_conv (is, *elt, &tmp, mval, data,
-                                         data_index, conversion_count,
-                                         nr, max_size, discard);
-                        }
-                        break;
-                      }
-                  }
-                  break;
-
-                case 'o': case 'u': case 'x':
-                  {
-                    switch (elt->modifier)
-                      {
-                      case 'h':
-                        {
-                          uint16_t tmp;
-                          do_scanf_conv (is, *elt, &tmp, mval, data,
-                                         data_index, conversion_count,
-                                         nr, max_size, discard);
-                        }
-                        break;
-
-                      case 'l':
+                    break;
+
+                  case 'o': case 'u': case 'x':
+                    {
+                      switch (elt->modifier)
                         {
-                          uint64_t tmp;
-                          do_scanf_conv (is, *elt, &tmp, mval, data,
-                                         data_index, conversion_count,
-                                         nr, max_size, discard);
-                        }
-                        break;
-
-                      default:
-                        {
-                          uint32_t tmp;
-                          do_scanf_conv (is, *elt, &tmp, mval, data,
-                                         data_index, conversion_count,
-                                         nr, max_size, discard);
-                        }
-                        break;
-                      }
-                  }
-                  break;
-
-                case 'e': case 'f': case 'g':
-                  {
-                    double tmp;
-
-                    do_scanf_conv (is, *elt, &tmp, mval, data,
-                                   data_index, conversion_count,
-                                   nr, max_size, discard);
-                  }
-                  break;
-
-                case 'c':
-                  {
-                    BEGIN_C_CONVERSION ();
-
-                    FINISH_CHARACTER_CONVERSION ();
-
-                    is.setf (flags);
-                  }
-                  break;
-
-                case 's':
-                  {
-                    BEGIN_S_CONVERSION ();
-
-                    FINISH_CHARACTER_CONVERSION ();
-                  }
-                  break;
-
-                case '[': case '^':
-                  {
-                    BEGIN_CHAR_CLASS_CONVERSION ();
-
-                    FINISH_CHARACTER_CONVERSION ();
-                  }
-                  break;
-
-                case 'p':
-                  error ("%s: unsupported format specifier", who.c_str ());
-                  break;
-
-                default:
-                  error ("%s: internal format error", who.c_str ());
-                  break;
-                }
-
-              if (! ok ())
-                {
-                  break;
-                }
-              else if (! is)
-                {
-                  if (all_char_conv)
-                    {
-                      if (one_elt_size_spec)
-                        {
-                          final_nr = 1;
-                          final_nc = data_index;
-                        }
-                      else if (data_index > nr)
-                        {
-                          final_nr = nr;
-                          final_nc = (data_index - 1) / nr + 1;
-                        }
-                      else
-                        {
-                          final_nr = data_index;
-                          final_nc = 1;
+                        case 'h':
+                          {
+                            uint16_t tmp;
+                            do_scanf_conv (is, *elt, &tmp, mval, data,
+                                           data_index, conversion_count,
+                                           nr, max_size, discard);
+                          }
+                          break;
+
+                        case 'l':
+                          {
+                            uint64_t tmp;
+                            do_scanf_conv (is, *elt, &tmp, mval, data,
+                                           data_index, conversion_count,
+                                           nr, max_size, discard);
+                          }
+                          break;
+
+                        default:
+                          {
+                            uint32_t tmp;
+                            do_scanf_conv (is, *elt, &tmp, mval, data,
+                                           data_index, conversion_count,
+                                           nr, max_size, discard);
+                          }
+                          break;
                         }
                     }
-                  else if (nr > 0)
+                    break;
+
+                  case 'e': case 'f': case 'g':
+                    {
+                      double tmp;
+
+                      do_scanf_conv (is, *elt, &tmp, mval, data,
+                                     data_index, conversion_count,
+                                     nr, max_size, discard);
+                    }
+                    break;
+
+                  case 'c':
                     {
-                      if (data_index > nr)
-                        {
-                          final_nr = nr;
-                          final_nc = (data_index - 1) / nr + 1;
-                        }
-                      else
-                        {
-                          final_nr = data_index;
-                          final_nc = 1;
-                        }
+                      BEGIN_C_CONVERSION ();
+
+                      FINISH_CHARACTER_CONVERSION ();
+
+                      is.setf (flags);
                     }
-                  else
+                    break;
+
+                  case 's':
                     {
-                      final_nr = data_index;
-                      final_nc = 1;
+                      BEGIN_S_CONVERSION ();
+
+                      FINISH_CHARACTER_CONVERSION ();
+                    }
+                    break;
+
+                  case '[': case '^':
+                    {
+                      BEGIN_CHAR_CLASS_CONVERSION ();
+
+                      FINISH_CHARACTER_CONVERSION ();
                     }
-
-                  // If it looks like we have a matching failure, then
-                  // reset the failbit in the stream state.
-                  if (is.rdstate () & std::ios::failbit)
-                    is.clear (is.rdstate () & (~std::ios::failbit));
-
-                  // FIXME: is this the right thing to do?
-                  if (octave::application::interactive ()
-                      && ! octave::application::forced_interactive ()
-                      && name () == "stdin")
-                    {
-                      is.clear ();
-
-                      // Skip to end of line.
-                      bool err;
-                      do_gets (-1, err, false, who);
-                    }
-
-                  break;
-                }
+                    break;
+
+                  case 'p':
+                    error ("%s: unsupported format specifier", who.c_str ());
+                    break;
+
+                  default:
+                    error ("%s: internal format error", who.c_str ());
+                    break;
+                  }
+
+                if (! ok ())
+                  {
+                    break;
+                  }
+                else if (! is)
+                  {
+                    if (all_char_conv)
+                      {
+                        if (one_elt_size_spec)
+                          {
+                            final_nr = 1;
+                            final_nc = data_index;
+                          }
+                        else if (data_index > nr)
+                          {
+                            final_nr = nr;
+                            final_nc = (data_index - 1) / nr + 1;
+                          }
+                        else
+                          {
+                            final_nr = data_index;
+                            final_nc = 1;
+                          }
+                      }
+                    else if (nr > 0)
+                      {
+                        if (data_index > nr)
+                          {
+                            final_nr = nr;
+                            final_nc = (data_index - 1) / nr + 1;
+                          }
+                        else
+                          {
+                            final_nr = data_index;
+                            final_nc = 1;
+                          }
+                      }
+                    else
+                      {
+                        final_nr = data_index;
+                        final_nc = 1;
+                      }
+
+                    // If it looks like we have a matching failure, then
+                    // reset the failbit in the stream state.
+                    if (is.rdstate () & std::ios::failbit)
+                      is.clear (is.rdstate () & (~std::ios::failbit));
+
+                    // FIXME: is this the right thing to do?
+                    if (octave::application::interactive ()
+                        && ! octave::application::forced_interactive ()
+                        && name () == "stdin")
+                      {
+                        is.clear ();
+
+                        // Skip to end of line.
+                        bool err;
+                        do_gets (-1, err, false, who);
+                      }
+
+                    break;
+                  }
+              }
+            else
+              {
+                error ("%s: internal format error", who.c_str ());
+                break;
+              }
+
+            if (nconv == 0 && ++trips == num_fmt_elts)
+              {
+                if (all_char_conv && one_elt_size_spec)
+                  {
+                    final_nr = 1;
+                    final_nc = data_index;
+                  }
+                else
+                  {
+                    final_nr = nr;
+                    final_nc = (data_index - 1) / nr + 1;
+                  }
+
+                break;
+              }
+            else
+              {
+                // Cycle through the format list more than once if we have some
+                // conversions to make and we haven't reached the limit on the
+                // number of values to convert (possibly because there is no
+                // specified limit).
+                elt = fmt_list.next (nconv > 0
+                                     && (max_conv == 0
+                                         || conversion_count < max_conv));
+              }
+          }
+      }
+
+    if (ok ())
+      {
+        mval.resize (final_nr, final_nc, 0.0);
+
+        retval = mval;
+
+        if (all_char_conv)
+          retval = retval.convert_to_str (false, true);
+      }
+
+    return retval;
+  }
+
+  octave_value
+  base_stream::scanf (const std::string& fmt, const Array<double>& size,
+                      octave_idx_type& conversion_count,
+                      const std::string& who)
+  {
+    octave_value retval = Matrix ();
+
+    conversion_count = 0;
+
+    std::istream *isp = input_stream ();
+
+    if (! isp)
+      invalid_operation (who, "reading");
+    else
+      {
+        scanf_format_list fmt_list (fmt);
+
+        if (fmt_list.num_conversions () == -1)
+          ::error ("%s: invalid format specified", who.c_str ());
+
+        octave_idx_type nr = -1;
+        octave_idx_type nc = -1;
+
+        bool one_elt_size_spec;
+
+        get_size (size, nr, nc, one_elt_size_spec, who);
+
+        retval = do_scanf (fmt_list, nr, nc, one_elt_size_spec,
+                           conversion_count, who);
+      }
+
+    return retval;
+  }
+
+  bool
+  base_stream::do_oscanf (const scanf_format_elt *elt,
+                          octave_value& retval, const std::string& who)
+  {
+    std::istream *isp = input_stream ();
+
+    if (! isp)
+      return false;
+
+    bool quit = false;
+
+    std::istream& is = *isp;
+
+    std::ios::fmtflags flags = is.flags ();
+
+    if (elt)
+      {
+        const char *fmt = elt->text;
+
+        bool discard = elt->discard;
+
+        switch (elt->type)
+          {
+          case scanf_format_elt::whitespace_conversion:
+            DO_WHITESPACE_CONVERSION ();
+            break;
+
+          case scanf_format_elt::literal_conversion:
+            DO_LITERAL_CONVERSION ();
+            break;
+
+          case '%':
+            {
+              DO_PCT_CONVERSION ();
+
+              if (! is)
+                quit = true;
             }
-          else
+            break;
+
+          case 'd': case 'i':
             {
-              error ("%s: internal format error", who.c_str ());
-              break;
-            }
-
-          if (nconv == 0 && ++trips == num_fmt_elts)
-            {
-              if (all_char_conv && one_elt_size_spec)
+              int tmp;
+
+              if (octave_scan (is, *elt, &tmp))
                 {
-                  final_nr = 1;
-                  final_nc = data_index;
+                  if (! discard)
+                    retval = tmp;
                 }
               else
+                quit = true;
+            }
+            break;
+
+          case 'o': case 'u': case 'x':
+            {
+              long int tmp;
+
+              if (octave_scan (is, *elt, &tmp))
                 {
-                  final_nr = nr;
-                  final_nc = (data_index - 1) / nr + 1;
+                  if (! discard)
+                    retval = tmp;
+                }
+              else
+                quit = true;
+            }
+            break;
+
+          case 'e': case 'f': case 'g':
+            {
+              double tmp;
+
+              if (octave_scan (is, *elt, &tmp))
+                {
+                  if (! discard)
+                    retval = tmp;
                 }
-
-              break;
+              else
+                quit = true;
+            }
+            break;
+
+          case 'c':
+            {
+              BEGIN_C_CONVERSION ();
+
+              if (! discard)
+                retval = tmp;
+
+              if (! is)
+                quit = true;
+
+              is.setf (flags);
             }
-          else
+            break;
+
+          case 's':
+            {
+              BEGIN_S_CONVERSION ();
+
+              if (! discard)
+                retval = tmp;
+
+              if (! is)
+                quit = true;
+            }
+            break;
+
+          case '[':
+          case '^':
             {
-              // Cycle through the format list more than once if we have some
-              // conversions to make and we haven't reached the limit on the
-              // number of values to convert (possibly because there is no
-              // specified limit).
-              elt = fmt_list.next (nconv > 0
-                                   && (max_conv == 0
-                                       || conversion_count < max_conv));
+              BEGIN_CHAR_CLASS_CONVERSION ();
+
+              if (! discard)
+                retval = tmp;
+
+              if (! is)
+                quit = true;
             }
+            break;
+
+          case 'p':
+            error ("%s: unsupported format specifier", who.c_str ());
+            break;
+
+          default:
+            error ("%s: internal format error", who.c_str ());
+            break;
+          }
+      }
+
+    if (ok () && is.fail ())
+      {
+        error ("%s: read error", who.c_str ());
+
+        // FIXME: is this the right thing to do?
+
+        if (octave::application::interactive ()
+            && ! octave::application::forced_interactive ()
+            && name () == "stdin")
+          {
+            // Skip to end of line.
+            bool err;
+            do_gets (-1, err, false, who);
+          }
+      }
+
+    return quit;
+  }
+
+  octave_value_list
+  base_stream::oscanf (const std::string& fmt, const std::string& who)
+  {
+    octave_value_list retval;
+
+    std::istream *isp = input_stream ();
+
+    if (! isp)
+      invalid_operation (who, "reading");
+    else
+      {
+        std::istream& is = *isp;
+
+        scanf_format_list fmt_list (fmt);
+
+        octave_idx_type nconv = fmt_list.num_conversions ();
+
+        if (nconv == -1)
+          ::error ("%s: invalid format specified", who.c_str ());
+
+        is.clear ();
+
+        octave_idx_type len = fmt_list.length ();
+
+        retval.resize (nconv+2, Matrix ());
+
+        const scanf_format_elt *elt = fmt_list.first ();
+
+        int num_values = 0;
+
+        bool quit = false;
+
+        for (octave_idx_type i = 0; i < len; i++)
+          {
+            octave_value tmp;
+
+            quit = do_oscanf (elt, tmp, who);
+
+            if (quit)
+              break;
+            else
+              {
+                if (tmp.is_defined ())
+                  retval(num_values++) = tmp;
+
+                if (! ok ())
+                  break;
+
+                elt = fmt_list.next (nconv > 0);
+              }
+          }
+
+        retval(nconv) = num_values;
+
+        int err_num;
+        retval(nconv+1) = error (false, err_num);
+
+        if (! quit)
+          {
+            // Pick up any trailing stuff.
+            if (ok () && len > nconv)
+              {
+                octave_value tmp;
+
+                elt = fmt_list.next ();
+
+                do_oscanf (elt, tmp, who);
+              }
+          }
+      }
+
+    return retval;
+  }
+
+  octave_value
+  base_stream::do_textscan (const std::string& fmt,
+                            octave_idx_type ntimes,
+                            const octave_value_list& options,
+                            const std::string& who,
+                            octave_idx_type& read_count)
+  {
+    if (octave::application::interactive () && file_number () == 0)
+      ::error ("%s: unable to read from stdin while running interactively",
+               who.c_str ());
+
+    octave_value retval = Cell (dim_vector (1, 1), Matrix (0, 1));
+
+    std::istream *isp = input_stream ();
+
+    if (! isp)
+      invalid_operation (who, "reading");
+    else
+      {
+        octave::textscan scanner (who);
+
+        retval = scanner.scan (*isp, fmt, ntimes, options, read_count);
+      }
+
+    return retval;
+  }
+
+  // Functions that are defined for all output streams
+  // (output streams are those that define os).
+
+  int
+  base_stream::flush (void)
+  {
+    int retval = -1;
+
+    std::ostream *os = output_stream ();
+
+    if (! os)
+      invalid_operation ("fflush", "writing");
+    else
+      {
+        os->flush ();
+
+        if (os->good ())
+          retval = 0;
+      }
+
+    return retval;
+  }
+
+  class
+  printf_value_cache
+  {
+  public:
+
+    enum state { ok, conversion_error };
+
+    printf_value_cache (const octave_value_list& args, const std::string& who)
+      : values (args), val_idx (0), elt_idx (0),
+        n_vals (values.length ()), n_elts (0), have_data (false),
+        curr_state (ok)
+    {
+      for (octave_idx_type i = 0; i < values.length (); i++)
+        {
+          octave_value val = values(i);
+
+          if (val.is_map () || val.is_cell () || val.is_object ())
+            err_wrong_type_arg (who, val);
         }
     }
 
-  if (ok ())
-    {
-      mval.resize (final_nr, final_nc, 0.0);
-
-      retval = mval;
-
-      if (all_char_conv)
-        retval = retval.convert_to_str (false, true);
-    }
-
-  return retval;
-}
-
-octave_value
-octave_base_stream::scanf (const std::string& fmt, const Array<double>& size,
-                           octave_idx_type& conversion_count,
-                           const std::string& who)
-{
-  octave_value retval = Matrix ();
-
-  conversion_count = 0;
-
-  std::istream *isp = input_stream ();
-
-  if (! isp)
-    invalid_operation (who, "reading");
-  else
-    {
-      scanf_format_list fmt_list (fmt);
-
-      if (fmt_list.num_conversions () == -1)
-        ::error ("%s: invalid format specified", who.c_str ());
-
-      octave_idx_type nr = -1;
-      octave_idx_type nc = -1;
-
-      bool one_elt_size_spec;
-
-      get_size (size, nr, nc, one_elt_size_spec, who);
-
-      retval = do_scanf (fmt_list, nr, nc, one_elt_size_spec,
-                         conversion_count, who);
-    }
-
-  return retval;
-}
-
-bool
-octave_base_stream::do_oscanf (const scanf_format_elt *elt,
-                               octave_value& retval, const std::string& who)
-{
-  std::istream *isp = input_stream ();
-
-  if (! isp)
-    return false;
-
-  bool quit = false;
-
-  std::istream& is = *isp;
-
-  std::ios::fmtflags flags = is.flags ();
-
-  if (elt)
-    {
-      const char *fmt = elt->text;
-
-      bool discard = elt->discard;
-
-      switch (elt->type)
-        {
-        case scanf_format_elt::whitespace_conversion:
-          DO_WHITESPACE_CONVERSION ();
-          break;
-
-        case scanf_format_elt::literal_conversion:
-          DO_LITERAL_CONVERSION ();
-          break;
-
-        case '%':
+    // No copying!
+
+    printf_value_cache (const printf_value_cache&) = delete;
+
+    printf_value_cache& operator = (const printf_value_cache&) = delete;
+
+    ~printf_value_cache (void) = default;
+
+    // Get the current value as a double and advance the internal pointer.
+    octave_value get_next_value (char type = 0);
+
+    // Get the current value as an int and advance the internal pointer.
+    int int_value (void);
+
+    operator bool () const { return (curr_state == ok); }
+
+    bool exhausted (void) { return (val_idx >= n_vals); }
+
+  private:
+
+    const octave_value_list values;
+    int val_idx;
+    int elt_idx;
+    int n_vals;
+    int n_elts;
+    bool have_data;
+    octave_value curr_val;
+    state curr_state;
+
+    // Must create value cache with values!
+
+    printf_value_cache (void);
+  };
+
+  octave_value
+  printf_value_cache::get_next_value (char type)
+  {
+    octave_value retval;
+
+    if (exhausted ())
+      curr_state = conversion_error;
+
+    while (! exhausted ())
+      {
+        if (! have_data)
           {
-            DO_PCT_CONVERSION ();
-
-            if (! is)
-              quit = true;
-          }
-          break;
-
-        case 'd': case 'i':
-          {
-            int tmp;
-
-            if (octave_scan (is, *elt, &tmp))
-              {
-                if (! discard)
-                  retval = tmp;
-              }
-            else
-              quit = true;
+            curr_val = values (val_idx);
+
+            elt_idx = 0;
+            n_elts = curr_val.numel ();
+            have_data = true;
           }
-          break;
-
-        case 'o': case 'u': case 'x':
+
+        if (elt_idx < n_elts)
           {
-            long int tmp;
-
-            if (octave_scan (is, *elt, &tmp))
+            if (type == 's')
               {
-                if (! discard)
-                  retval = tmp;
-              }
-            else
-              quit = true;
-          }
-          break;
-
-        case 'e': case 'f': case 'g':
-          {
-            double tmp;
-
-            if (octave_scan (is, *elt, &tmp))
-              {
-                if (! discard)
-                  retval = tmp;
+                if (curr_val.is_string ())
+                  {
+                    dim_vector dv (1, curr_val.numel ());
+                    octave_value tmp = curr_val.reshape (dv);
+
+                    std::string sval = tmp.string_value ();
+
+                    retval = sval.substr (elt_idx);
+
+                    // We've consumed the rest of the value.
+                    elt_idx = n_elts;
+                  }
+                else
+                  {
+                    // Convert to character string while values are
+                    // integers in the range [0 : char max]
+                    const NDArray val = curr_val.array_value ();
+
+                    octave_idx_type idx = elt_idx;
+
+                    for (; idx < n_elts; idx++)
+                      {
+                        double dval = val(idx);
+
+                        if (octave::math::x_nint (dval) != dval || dval < 0 || dval > 255)
+                          break;
+                      }
+
+                    octave_idx_type n = idx - elt_idx;
+
+                    if (n > 0)
+                      {
+                        std::string sval (n, '\0');
+
+                        for (octave_idx_type i = 0; i < n; i++)
+                          sval[i] = val(elt_idx++);
+
+                        retval = sval;
+                      }
+                    else
+                      retval = curr_val.fast_elem_extract (elt_idx++);
+                  }
               }
             else
-              quit = true;
-          }
-          break;
-
-        case 'c':
-          {
-            BEGIN_C_CONVERSION ();
-
-            if (! discard)
-              retval = tmp;
-
-            if (! is)
-              quit = true;
-
-            is.setf (flags);
-          }
-          break;
-
-        case 's':
-          {
-            BEGIN_S_CONVERSION ();
-
-            if (! discard)
-              retval = tmp;
-
-            if (! is)
-              quit = true;
-          }
-          break;
-
-        case '[':
-        case '^':
-          {
-            BEGIN_CHAR_CLASS_CONVERSION ();
-
-            if (! discard)
-              retval = tmp;
-
-            if (! is)
-              quit = true;
-          }
-          break;
-
-        case 'p':
-          error ("%s: unsupported format specifier", who.c_str ());
-          break;
-
-        default:
-          error ("%s: internal format error", who.c_str ());
-          break;
-        }
-    }
-
-  if (ok () && is.fail ())
-    {
-      error ("%s: read error", who.c_str ());
-
-      // FIXME: is this the right thing to do?
-
-      if (octave::application::interactive ()
-          && ! octave::application::forced_interactive ()
-          && name () == "stdin")
-        {
-          // Skip to end of line.
-          bool err;
-          do_gets (-1, err, false, who);
-        }
-    }
-
-  return quit;
-}
-
-octave_value_list
-octave_base_stream::oscanf (const std::string& fmt, const std::string& who)
-{
-  octave_value_list retval;
-
-  std::istream *isp = input_stream ();
-
-  if (! isp)
-    invalid_operation (who, "reading");
-  else
-    {
-      std::istream& is = *isp;
-
-      scanf_format_list fmt_list (fmt);
-
-      octave_idx_type nconv = fmt_list.num_conversions ();
-
-      if (nconv == -1)
-        ::error ("%s: invalid format specified", who.c_str ());
-
-      is.clear ();
-
-      octave_idx_type len = fmt_list.length ();
-
-      retval.resize (nconv+2, Matrix ());
-
-      const scanf_format_elt *elt = fmt_list.first ();
-
-      int num_values = 0;
-
-      bool quit = false;
-
-      for (octave_idx_type i = 0; i < len; i++)
-        {
-          octave_value tmp;
-
-          quit = do_oscanf (elt, tmp, who);
-
-          if (quit)
+              {
+                retval = curr_val.fast_elem_extract (elt_idx++);
+
+                if (type == 'c' && ! retval.is_string ())
+                  {
+                    double dval = retval.double_value ();
+
+                    if (octave::math::x_nint (dval) == dval && dval >= 0 && dval < 256)
+                      retval = static_cast<char> (dval);
+                  }
+              }
+
+            if (elt_idx >= n_elts)
+              {
+                elt_idx = 0;
+                val_idx++;
+                have_data = false;
+              }
+
             break;
-          else
-            {
-              if (tmp.is_defined ())
-                retval(num_values++) = tmp;
-
-              if (! ok ())
-                break;
-
-              elt = fmt_list.next (nconv > 0);
-            }
-        }
-
-      retval(nconv) = num_values;
-
-      int err_num;
-      retval(nconv+1) = error (false, err_num);
-
-      if (! quit)
-        {
-          // Pick up any trailing stuff.
-          if (ok () && len > nconv)
-            {
-              octave_value tmp;
-
-              elt = fmt_list.next ();
-
-              do_oscanf (elt, tmp, who);
-            }
-        }
-    }
-
-  return retval;
-}
-
-octave_value
-octave_base_stream::do_textscan (const std::string& fmt,
-                                 octave_idx_type ntimes,
-                                 const octave_value_list& options,
-                                 const std::string& who,
-                                 octave_idx_type& read_count)
-{
-  if (octave::application::interactive () && file_number () == 0)
-    ::error ("%s: unable to read from stdin while running interactively",
-             who.c_str ());
-
-  octave_value retval = Cell (dim_vector (1, 1), Matrix (0, 1));
-
-  std::istream *isp = input_stream ();
-
-  if (! isp)
-    invalid_operation (who, "reading");
-  else
-    {
-      octave::textscan scanner (who);
-
-      retval = scanner.scan (*isp, fmt, ntimes, options, read_count);
-    }
-
-  return retval;
-}
-
-// Functions that are defined for all output streams
-// (output streams are those that define os).
-
-int
-octave_base_stream::flush (void)
-{
-  int retval = -1;
-
-  std::ostream *os = output_stream ();
-
-  if (! os)
-    invalid_operation ("fflush", "writing");
-  else
-    {
-      os->flush ();
-
-      if (os->good ())
-        retval = 0;
-    }
-
-  return retval;
-}
-
-class
-printf_value_cache
-{
-public:
-
-  enum state { ok, conversion_error };
-
-  printf_value_cache (const octave_value_list& args, const std::string& who)
-    : values (args), val_idx (0), elt_idx (0),
-      n_vals (values.length ()), n_elts (0), have_data (false),
-      curr_state (ok)
-  {
-    for (octave_idx_type i = 0; i < values.length (); i++)
-      {
-        octave_value val = values(i);
-
-        if (val.is_map () || val.is_cell () || val.is_object ())
-          err_wrong_type_arg (who, val);
-      }
-  }
-
-  // No copying!
-
-  printf_value_cache (const printf_value_cache&) = delete;
-
-  printf_value_cache& operator = (const printf_value_cache&) = delete;
-
-  ~printf_value_cache (void) = default;
-
-  // Get the current value as a double and advance the internal pointer.
-  octave_value get_next_value (char type = 0);
-
-  // Get the current value as an int and advance the internal pointer.
-  int int_value (void);
-
-  operator bool () const { return (curr_state == ok); }
-
-  bool exhausted (void) { return (val_idx >= n_vals); }
-
-private:
-
-  const octave_value_list values;
-  int val_idx;
-  int elt_idx;
-  int n_vals;
-  int n_elts;
-  bool have_data;
-  octave_value curr_val;
-  state curr_state;
-
-  // Must create value cache with values!
-
-  printf_value_cache (void);
-};
-
-octave_value
-printf_value_cache::get_next_value (char type)
-{
-  octave_value retval;
-
-  if (exhausted ())
-    curr_state = conversion_error;
-
-  while (! exhausted ())
-    {
-      if (! have_data)
-        {
-          curr_val = values (val_idx);
-
-          elt_idx = 0;
-          n_elts = curr_val.numel ();
-          have_data = true;
-        }
-
-      if (elt_idx < n_elts)
-        {
-          if (type == 's')
-            {
-              if (curr_val.is_string ())
-                {
-                  dim_vector dv (1, curr_val.numel ());
-                  octave_value tmp = curr_val.reshape (dv);
-
-                  std::string sval = tmp.string_value ();
-
-                  retval = sval.substr (elt_idx);
-
-                  // We've consumed the rest of the value.
-                  elt_idx = n_elts;
-                }
-              else
-                {
-                  // Convert to character string while values are
-                  // integers in the range [0 : char max]
-                  const NDArray val = curr_val.array_value ();
-
-                  octave_idx_type idx = elt_idx;
-
-                  for (; idx < n_elts; idx++)
-                    {
-                      double dval = val(idx);
-
-                      if (octave::math::x_nint (dval) != dval || dval < 0 || dval > 255)
-                        break;
-                    }
-
-                  octave_idx_type n = idx - elt_idx;
-
-                  if (n > 0)
-                    {
-                      std::string sval (n, '\0');
-
-                      for (octave_idx_type i = 0; i < n; i++)
-                        sval[i] = val(elt_idx++);
-
-                      retval = sval;
-                    }
-                  else
-                    retval = curr_val.fast_elem_extract (elt_idx++);
-                }
-            }
-          else
-            {
-              retval = curr_val.fast_elem_extract (elt_idx++);
-
-              if (type == 'c' && ! retval.is_string ())
-                {
-                  double dval = retval.double_value ();
-
-                  if (octave::math::x_nint (dval) == dval && dval >= 0 && dval < 256)
-                    retval = static_cast<char> (dval);
-                }
-            }
-
-          if (elt_idx >= n_elts)
-            {
-              elt_idx = 0;
-              val_idx++;
-              have_data = false;
-            }
-
-          break;
-        }
-      else
-        {
-          val_idx++;
-          have_data = false;
-
-          if (n_elts == 0)
-            {
-              if (elt_idx == 0)
-                {
-                  if (type == 's' || type == 'c')
-                    retval = "";
-                  else
-                    retval = Matrix ();
-
-                  break;
-                }
-
-              if (exhausted ())
-                curr_state = conversion_error;
-            }
-        }
-    }
-
-  return retval;
-}
-
-int
-printf_value_cache::int_value (void)
-{
-  int retval = 0;
-
-  octave_value val = get_next_value ();
-
-  double dval = val.double_value (true);
-
-  if (octave::math::x_nint (dval) == dval)
-    retval = octave::math::nint (dval);
-  else
-    curr_state = conversion_error;
-
-  return retval;
-}
-
-// Ugh again and again.
-
-template <typename T>
-int
-do_printf_conv (std::ostream& os, const char *fmt, int nsa, int sa_1,
-                int sa_2, T arg, const std::string& who)
-{
-  int retval = 0;
-
-  switch (nsa)
-    {
-    case 2:
-      retval = octave_format (os, fmt, sa_1, sa_2, arg);
-      break;
-
-    case 1:
-      retval = octave_format (os, fmt, sa_1, arg);
-      break;
-
-    case 0:
-      retval = octave_format (os, fmt, arg);
-      break;
-
-    default:
-      ::error ("%s: internal error handling format", who.c_str ());
-      break;
-    }
-
-  return retval;
+          }
+        else
+          {
+            val_idx++;
+            have_data = false;
+
+            if (n_elts == 0)
+              {
+                if (elt_idx == 0)
+                  {
+                    if (type == 's' || type == 'c')
+                      retval = "";
+                    else
+                      retval = Matrix ();
+
+                    break;
+                  }
+
+                if (exhausted ())
+                  curr_state = conversion_error;
+              }
+          }
+      }
+
+    return retval;
+  }
+
+  int
+  printf_value_cache::int_value (void)
+  {
+    int retval = 0;
+
+    octave_value val = get_next_value ();
+
+    double dval = val.double_value (true);
+
+    if (octave::math::x_nint (dval) == dval)
+      retval = octave::math::nint (dval);
+    else
+      curr_state = conversion_error;
+
+    return retval;
+  }
+
+  // Ugh again and again.
+
+  template <typename T>
+  int
+  do_printf_conv (std::ostream& os, const char *fmt, int nsa, int sa_1,
+                  int sa_2, T arg, const std::string& who)
+  {
+    int retval = 0;
+
+    switch (nsa)
+      {
+      case 2:
+        retval = octave_format (os, fmt, sa_1, sa_2, arg);
+        break;
+
+      case 1:
+        retval = octave_format (os, fmt, sa_1, arg);
+        break;
+
+      case 0:
+        retval = octave_format (os, fmt, arg);
+        break;
+
+      default:
+        ::error ("%s: internal error handling format", who.c_str ());
+        break;
+      }
+
+    return retval;
+  }
 }
 
 static size_t
-do_printf_string (std::ostream& os, const printf_format_elt *elt,
+do_printf_string (std::ostream& os, const octave::printf_format_elt *elt,
                   int nsa, int sa_1, int sa_2, const std::string& arg,
                   const std::string& who)
 {
   if (nsa > 2)
     ::error ("%s: internal error handling format", who.c_str ());
 
   std::string flags = elt->flags;
 
@@ -5584,639 +5589,642 @@ ok_for_unsigned_int_conv (const octave_v
       if (dval == octave::math::round (dval) && dval >= 0 && dval <= limit)
         return true;
     }
 
   return false;
 }
 
 static std::string
-switch_to_g_format (const printf_format_elt *elt)
+switch_to_g_format (const octave::printf_format_elt *elt)
 {
   std::string tfmt = elt->text;
 
   tfmt.replace (tfmt.rfind (elt->type), 1, "g");
 
   return tfmt;
 }
 
-int
-octave_base_stream::do_numeric_printf_conv (std::ostream& os,
-                                            const printf_format_elt *elt,
-                                            int nsa, int sa_1, int sa_2,
-                                            const octave_value& val,
-                                            const std::string& who)
-{
-  int retval = 0;
-
-  const char *fmt = elt->text;
-
-  if (is_nan_or_inf (val))
-    {
-      double dval = val.double_value ();
-
-      std::string tfmt = fmt;
-      std::string::size_type i1, i2;
-
-      tfmt.replace ((i1 = tfmt.rfind (elt->type)), 1, 1, 's');
-
-      if ((i2 = tfmt.rfind ('.')) != std::string::npos && i2 < i1)
-        {
-          tfmt.erase (i2, i1-i2);
-          if (elt->prec == -2)
-            nsa--;
-        }
-
-      const char *tval;
-      if (lo_ieee_isinf (dval))
-        {
-          if (elt->flags.find ('+') != std::string::npos)
-            tval = (dval < 0 ? "-Inf" : "+Inf");
-          else
-            tval = (dval < 0 ? "-Inf" : "Inf");
-        }
-      else
-        {
-          if (elt->flags.find ('+') != std::string::npos)
-            tval = (lo_ieee_is_NA (dval) ? "+NA" : "+NaN");
-          else
-            tval = (lo_ieee_is_NA (dval) ? "NA" : "NaN");
-        }
-
-      retval += do_printf_conv (os, tfmt.c_str (), nsa, sa_1, sa_2, tval, who);
-    }
-  else
-    {
-      static std::string llmod
-        = sizeof (long) == sizeof (int64_t) ? "l" : "ll";
-
-      char type = elt->type;
-
-      switch (type)
-        {
-        case 'd': case 'i': case 'c':
-          if (ok_for_signed_int_conv (val))
-            {
-              octave_int64 tval = val.int64_scalar_value ();
-
-              // Insert "long" modifier.
-              std::string tfmt = fmt;
-              tfmt.replace (tfmt.rfind (type), 1, llmod + type);
-
-              retval += do_printf_conv (os, tfmt.c_str (), nsa, sa_1, sa_2,
-                                        tval.value (), who);
-            }
-          else
-            {
-              std::string tfmt = switch_to_g_format (elt);
-
-              double dval = val.double_value (true);
-
-              retval += do_printf_conv (os, tfmt.c_str (), nsa,
-                                        sa_1, sa_2, dval, who);
-            }
-          break;
-
-        case 'o': case 'x': case 'X': case 'u':
-          if (ok_for_unsigned_int_conv (val))
-            {
-              octave_uint64 tval = val.uint64_scalar_value ();
-
-              // Insert "long" modifier.
-              std::string tfmt = fmt;
-              tfmt.replace (tfmt.rfind (type), 1, llmod + type);
-
-              retval += do_printf_conv (os, tfmt.c_str (), nsa, sa_1, sa_2,
-                                        tval.value (), who);
-            }
-          else
-            {
-              std::string tfmt = switch_to_g_format (elt);
-
-              double dval = val.double_value (true);
-
-              retval += do_printf_conv (os, tfmt.c_str (), nsa,
-                                        sa_1, sa_2, dval, who);
-            }
-          break;
-
-        case 'f': case 'e': case 'E':
-        case 'g': case 'G':
-          {
-            double dval = val.double_value (true);
-
-            retval += do_printf_conv (os, fmt, nsa, sa_1, sa_2, dval, who);
-          }
-          break;
-
-        default:
-          // Note: error is member fcn from octave_base_stream, not ::error.
-          // This error does not halt execution so "return ..." must exist.
-          error ("%s: invalid format specifier", who.c_str ());
-          return -1;
-          break;
-        }
-    }
-
-  return retval;
-}
-
-int
-octave_base_stream::do_printf (printf_format_list& fmt_list,
-                               const octave_value_list& args,
-                               const std::string& who)
-{
-  int retval = 0;
-
-  octave_idx_type nconv = fmt_list.num_conversions ();
-
-  std::ostream *osp = output_stream ();
-
-  if (! osp)
-    invalid_operation (who, "writing");
-  else
-    {
-      std::ostream& os = *osp;
-
-      const printf_format_elt *elt = fmt_list.first ();
-
-      printf_value_cache val_cache (args, who);
-
-      for (;;)
-        {
-          octave_quit ();
-
-          if (! elt)
-            ::error ("%s: internal error handling format", who.c_str ());
-
-          // NSA is the number of 'star' args to convert.
-          int nsa = (elt->fw == -2) + (elt->prec == -2);
-
-          int sa_1 = 0;
-          int sa_2 = 0;
-
-          if (nsa > 0)
-            {
-              sa_1 = val_cache.int_value ();
-
-              if (! val_cache)
-                break;
-              else
-                {
-                  if (nsa > 1)
-                    {
-                      sa_2 = val_cache.int_value ();
-
-                      if (! val_cache)
-                        break;
-                    }
-                }
-            }
-
-          if (elt->type == '%')
-            {
-              os << "%";
-              retval++;
-            }
-          else if (elt->args == 0 && elt->text)
-            {
-              os << elt->text;
-              retval += strlen (elt->text);
-            }
-          else if (elt->type == 's' || elt->type == 'c')
-            {
-              octave_value val = val_cache.get_next_value (elt->type);
-
-              if (val_cache)
-                {
-                  if (val.is_string ())
-                    {
-                      std::string sval = val.string_value ();
-
-                      retval += do_printf_string (os, elt, nsa, sa_1,
-                                                  sa_2, sval, who);
-                    }
-                  else
-                    retval += do_numeric_printf_conv (os, elt, nsa, sa_1,
-                                                      sa_2, val, who);
-                }
-              else
-                break;
-            }
-          else
-            {
-              octave_value val = val_cache.get_next_value ();
-
-              if (val_cache)
-                {
-                  if (! val.is_empty ())
-                    retval += do_numeric_printf_conv (os, elt, nsa, sa_1,
-                                                      sa_2, val, who);
-                }
-              else
-                break;
-            }
-
-          if (! os)
-            {
-              error ("%s: write error", who.c_str ());
-              break;
-            }
-
-          elt = fmt_list.next (nconv > 0 && ! val_cache.exhausted ());
-
-          if (! elt || (val_cache.exhausted () && elt->args > 0))
-            break;
-        }
-    }
-
-  return retval;
-}
-
-int
-octave_base_stream::printf (const std::string& fmt,
-                            const octave_value_list& args,
-                            const std::string& who)
-{
-  printf_format_list fmt_list (fmt);
-
-  if (fmt_list.num_conversions () == -1)
-    ::error ("%s: invalid format specified", who.c_str ());
-
-  return do_printf (fmt_list, args, who);
-}
-
-int
-octave_base_stream::puts (const std::string& s, const std::string& who)
-{
-  int retval = -1;
-
-  std::ostream *osp = output_stream ();
-
-  if (! osp)
-    invalid_operation (who, "writing");
-  else
-    {
-      std::ostream& os = *osp;
-
-      os << s;
-
-      if (! os)
-        error ("%s: write error", who.c_str ());
-      else
-        {
-          // FIXME: why does this seem to be necessary?
-          // Without it, output from a loop like
-          //
-          //   for i = 1:100, fputs (stdout, "foo\n"); endfor
-          //
-          // doesn't seem to go to the pager immediately.
-          os.flush ();
-
-          if (os)
-            retval = 0;
-          else
-            error ("%s: write error", who.c_str ());
-        }
-    }
-
-  return retval;
-}
-
-// Return current error message for this stream.
-
-std::string
-octave_base_stream::error (bool clear_err, int& err_num)
-{
-  err_num = fail ? -1 : 0;
-
-  std::string tmp = errmsg;
-
-  if (clear_err)
-    clear ();
-
-  return tmp;
-}
-
-void
-octave_base_stream::invalid_operation (const std::string& who, const char *rw)
+namespace octave
 {
-  // Note: This calls the member fcn error, not ::error from error.h.
-  error (who, std::string ("stream not open for ") + rw);
-}
-
-octave_stream::octave_stream (octave_base_stream *bs)
-  : rep (bs)
-{
-  if (rep)
-    rep->count = 1;
-}
-
-octave_stream::~octave_stream (void)
-{
-  if (rep && --rep->count == 0)
-    delete rep;
-}
-
-octave_stream::octave_stream (const octave_stream& s)
-  : rep (s.rep)
-{
-  if (rep)
-    rep->count++;
-}
-
-octave_stream&
-octave_stream::operator = (const octave_stream& s)
-{
-  if (rep != s.rep)
-    {
-      if (rep && --rep->count == 0)
-        delete rep;
-
-      rep = s.rep;
-
-      if (rep)
-        rep->count++;
-    }
-
-  return *this;
-}
-
-int
-octave_stream::flush (void)
-{
-  int retval = -1;
-
-  if (stream_ok ())
-    retval = rep->flush ();
-
-  return retval;
-}
-
-std::string
-octave_stream::getl (octave_idx_type max_len, bool& err, const std::string& who)
-{
-  std::string retval;
-
-  if (stream_ok ())
-    retval = rep->getl (max_len, err, who);
-
-  return retval;
-}
-
-std::string
-octave_stream::getl (const octave_value& tc_max_len, bool& err,
-                     const std::string& who)
-{
-  err = false;
-
-  int conv_err = 0;
-
-  int max_len = -1;
-
-  if (tc_max_len.is_defined ())
-    {
-      max_len = convert_to_valid_int (tc_max_len, conv_err);
-
-      if (conv_err || max_len < 0)
-        {
-          err = true;
-          ::error ("%s: invalid maximum length specified", who.c_str ());
-        }
-    }
-
-  return getl (max_len, err, who);
-}
-
-std::string
-octave_stream::gets (octave_idx_type max_len, bool& err, const std::string& who)
-{
-  std::string retval;
-
-  if (stream_ok ())
-    retval = rep->gets (max_len, err, who);
-
-  return retval;
-}
-
-std::string
-octave_stream::gets (const octave_value& tc_max_len, bool& err,
-                     const std::string& who)
-{
-  err = false;
-
-  int conv_err = 0;
-
-  int max_len = -1;
-
-  if (tc_max_len.is_defined ())
-    {
-      max_len = convert_to_valid_int (tc_max_len, conv_err);
-
-      if (conv_err || max_len < 0)
-        {
-          err = true;
-          ::error ("%s: invalid maximum length specified", who.c_str ());
-        }
-    }
-
-  return gets (max_len, err, who);
-}
-
-off_t
-octave_stream::skipl (off_t count, bool& err, const std::string& who)
-{
-  off_t retval = -1;
-
-  if (stream_ok ())
-    retval = rep->skipl (count, err, who);
-
-  return retval;
-}
-
-off_t
-octave_stream::skipl (const octave_value& tc_count, bool& err,
-                      const std::string& who)
-{
-  err = false;
-
-  int conv_err = 0;
-
-  int count = 1;
-
-  if (tc_count.is_defined ())
-    {
-      if (tc_count.is_scalar_type ()
-          && octave::math::isinf (tc_count.scalar_value ()))
-        count = -1;
-      else
-        {
-          count = convert_to_valid_int (tc_count, conv_err);
-
-          if (conv_err || count < 0)
+  int
+  base_stream::do_numeric_printf_conv (std::ostream& os,
+                                       const printf_format_elt *elt,
+                                       int nsa, int sa_1, int sa_2,
+                                       const octave_value& val,
+                                       const std::string& who)
+  {
+    int retval = 0;
+
+    const char *fmt = elt->text;
+
+    if (is_nan_or_inf (val))
+      {
+        double dval = val.double_value ();
+
+        std::string tfmt = fmt;
+        std::string::size_type i1, i2;
+
+        tfmt.replace ((i1 = tfmt.rfind (elt->type)), 1, 1, 's');
+
+        if ((i2 = tfmt.rfind ('.')) != std::string::npos && i2 < i1)
+          {
+            tfmt.erase (i2, i1-i2);
+            if (elt->prec == -2)
+              nsa--;
+          }
+
+        const char *tval;
+        if (lo_ieee_isinf (dval))
+          {
+            if (elt->flags.find ('+') != std::string::npos)
+              tval = (dval < 0 ? "-Inf" : "+Inf");
+            else
+              tval = (dval < 0 ? "-Inf" : "Inf");
+          }
+        else
+          {
+            if (elt->flags.find ('+') != std::string::npos)
+              tval = (lo_ieee_is_NA (dval) ? "+NA" : "+NaN");
+            else
+              tval = (lo_ieee_is_NA (dval) ? "NA" : "NaN");
+          }
+
+        retval += do_printf_conv (os, tfmt.c_str (), nsa, sa_1, sa_2, tval, who);
+      }
+    else
+      {
+        static std::string llmod
+          = sizeof (long) == sizeof (int64_t) ? "l" : "ll";
+
+        char type = elt->type;
+
+        switch (type)
+          {
+          case 'd': case 'i': case 'c':
+            if (ok_for_signed_int_conv (val))
+              {
+                octave_int64 tval = val.int64_scalar_value ();
+
+                // Insert "long" modifier.
+                std::string tfmt = fmt;
+                tfmt.replace (tfmt.rfind (type), 1, llmod + type);
+
+                retval += do_printf_conv (os, tfmt.c_str (), nsa, sa_1, sa_2,
+                                          tval.value (), who);
+              }
+            else
+              {
+                std::string tfmt = switch_to_g_format (elt);
+
+                double dval = val.double_value (true);
+
+                retval += do_printf_conv (os, tfmt.c_str (), nsa,
+                                          sa_1, sa_2, dval, who);
+              }
+            break;
+
+          case 'o': case 'x': case 'X': case 'u':
+            if (ok_for_unsigned_int_conv (val))
+              {
+                octave_uint64 tval = val.uint64_scalar_value ();
+
+                // Insert "long" modifier.
+                std::string tfmt = fmt;
+                tfmt.replace (tfmt.rfind (type), 1, llmod + type);
+
+                retval += do_printf_conv (os, tfmt.c_str (), nsa, sa_1, sa_2,
+                                          tval.value (), who);
+              }
+            else
+              {
+                std::string tfmt = switch_to_g_format (elt);
+
+                double dval = val.double_value (true);
+
+                retval += do_printf_conv (os, tfmt.c_str (), nsa,
+                                          sa_1, sa_2, dval, who);
+              }
+            break;
+
+          case 'f': case 'e': case 'E':
+          case 'g': case 'G':
             {
-              err = true;
-              ::error ("%s: invalid number of lines specified", who.c_str ());
+              double dval = val.double_value (true);
+
+              retval += do_printf_conv (os, fmt, nsa, sa_1, sa_2, dval, who);
             }
-        }
-    }
-
-  return skipl (count, err, who);
-}
-
-int
-octave_stream::seek (off_t offset, int origin)
-{
-  int status = -1;
-
-  if (stream_ok ())
-    {
-      clearerr ();
-
-      // Find current position so we can return to it if needed.
-      off_t orig_pos = rep->tell ();
-
-      // Move to end of file.  If successful, find the offset of the end.
-      status = rep->seek (0, SEEK_END);
-
-      if (status == 0)
-        {
-          off_t eof_pos = rep->tell ();
-
-          if (origin == SEEK_CUR)
-            {
-              // Move back to original position, otherwise we will be seeking
-              // from the end of file which is probably not the original
-              // location.
-              rep->seek (orig_pos, SEEK_SET);
-            }
-
-          // Attempt to move to desired position; may be outside bounds of
-          // existing file.
-          status = rep->seek (offset, origin);
-
-          if (status == 0)
-            {
-              // Where are we after moving to desired position?
-              off_t desired_pos = rep->tell ();
-
-              // I don't think save_pos can be less than zero,
-              // but we'll check anyway...
-              if (desired_pos > eof_pos || desired_pos < 0)
-                {
-                  // Seek outside bounds of file.
-                  // Failure should leave position unchanged.
-                  rep->seek (orig_pos, SEEK_SET);
-
-                  status = -1;
-                }
-            }
-          else
-            {
-              // Seeking to the desired position failed.
-              // Move back to original position and return failure status.
-              rep->seek (orig_pos, SEEK_SET);
-
-              status = -1;
-            }
-        }
-    }
-
-  return status;
-}
-
-int
-octave_stream::seek (const octave_value& tc_offset,
-                     const octave_value& tc_origin)
-{
-  int retval = -1;
-
-  // FIXME: should we have octave_value methods that handle off_t explicitly?
-  octave_int64 val = tc_offset.xint64_scalar_value ("fseek: invalid value for offset");
-  off_t xoffset = val.value ();
-
-  int conv_err = 0;
-
-  int origin = SEEK_SET;
-
-  if (tc_origin.is_string ())
-    {
-      std::string xorigin = tc_origin.string_value ("fseek: invalid value for origin");
-
-      if (xorigin == "bof")
-        origin = SEEK_SET;
-      else if (xorigin == "cof")
-        origin = SEEK_CUR;
-      else if (xorigin == "eof")
-        origin = SEEK_END;
-      else
-        conv_err = -1;
-    }
-  else
-    {
-      int xorigin = convert_to_valid_int (tc_origin, conv_err);
-
-      if (! conv_err)
-        {
-          if (xorigin == -1)
-            origin = SEEK_SET;
-          else if (xorigin == 0)
-            origin = SEEK_CUR;
-          else if (xorigin == 1)
-            origin = SEEK_END;
-          else
-            conv_err = -1;
-        }
-    }
-
-  if (conv_err)
-    ::error ("fseek: invalid value for origin");
-
-  retval = seek (xoffset, origin);
-
-  if (retval != 0)
-    // Note: error is member fcn from octave_stream, not ::error.
-    error ("fseek: failed to seek to requested position");
-
-  return retval;
-}
-
-off_t
-octave_stream::tell (void)
-{
-  off_t retval = -1;
-
-  if (stream_ok ())
-    retval = rep->tell ();
-
-  return retval;
-}
-
-int
-octave_stream::rewind (void)
-{
-  return seek (0, SEEK_SET);
-}
-
-bool
-octave_stream::is_open (void) const
-{
-  bool retval = false;
-
-  if (stream_ok ())
-    retval = rep->is_open ();
-
-  return retval;
-}
-
-void
-octave_stream::close (void)
-{
-  if (stream_ok ())
-    rep->close ();
+            break;
+
+          default:
+            // Note: error is member fcn from octave::base_stream, not ::error.
+            // This error does not halt execution so "return ..." must exist.
+            error ("%s: invalid format specifier", who.c_str ());
+            return -1;
+            break;
+          }
+      }
+
+    return retval;
+  }
+
+  int
+  base_stream::do_printf (printf_format_list& fmt_list,
+                          const octave_value_list& args,
+                          const std::string& who)
+  {
+    int retval = 0;
+
+    octave_idx_type nconv = fmt_list.num_conversions ();
+
+    std::ostream *osp = output_stream ();
+
+    if (! osp)
+      invalid_operation (who, "writing");
+    else
+      {
+        std::ostream& os = *osp;
+
+        const printf_format_elt *elt = fmt_list.first ();
+
+        printf_value_cache val_cache (args, who);
+
+        for (;;)
+          {
+            octave_quit ();
+
+            if (! elt)
+              ::error ("%s: internal error handling format", who.c_str ());
+
+            // NSA is the number of 'star' args to convert.
+            int nsa = (elt->fw == -2) + (elt->prec == -2);
+
+            int sa_1 = 0;
+            int sa_2 = 0;
+
+            if (nsa > 0)
+              {
+                sa_1 = val_cache.int_value ();
+
+                if (! val_cache)
+                  break;
+                else
+                  {
+                    if (nsa > 1)
+                      {
+                        sa_2 = val_cache.int_value ();
+
+                        if (! val_cache)
+                          break;
+                      }
+                  }
+              }
+
+            if (elt->type == '%')
+              {
+                os << "%";
+                retval++;
+              }
+            else if (elt->args == 0 && elt->text)
+              {
+                os << elt->text;
+                retval += strlen (elt->text);
+              }
+            else if (elt->type == 's' || elt->type == 'c')
+              {
+                octave_value val = val_cache.get_next_value (elt->type);
+
+                if (val_cache)
+                  {
+                    if (val.is_string ())
+                      {
+                        std::string sval = val.string_value ();
+
+                        retval += do_printf_string (os, elt, nsa, sa_1,
+                                                    sa_2, sval, who);
+                      }
+                    else
+                      retval += do_numeric_printf_conv (os, elt, nsa, sa_1,
+                                                        sa_2, val, who);
+                  }
+                else
+                  break;
+              }
+            else
+              {
+                octave_value val = val_cache.get_next_value ();
+
+                if (val_cache)
+                  {
+                    if (! val.is_empty ())
+                      retval += do_numeric_printf_conv (os, elt, nsa, sa_1,
+                                                        sa_2, val, who);
+                  }
+                else
+                  break;
+              }
+
+            if (! os)
+              {
+                error ("%s: write error", who.c_str ());
+                break;
+              }
+
+            elt = fmt_list.next (nconv > 0 && ! val_cache.exhausted ());
+
+            if (! elt || (val_cache.exhausted () && elt->args > 0))
+              break;
+          }
+      }
+
+    return retval;
+  }
+
+  int
+  base_stream::printf (const std::string& fmt,
+                       const octave_value_list& args,
+                       const std::string& who)
+  {
+    printf_format_list fmt_list (fmt);
+
+    if (fmt_list.num_conversions () == -1)
+      ::error ("%s: invalid format specified", who.c_str ());
+
+    return do_printf (fmt_list, args, who);
+  }
+
+  int
+  base_stream::puts (const std::string& s, const std::string& who)
+  {
+    int retval = -1;
+
+    std::ostream *osp = output_stream ();
+
+    if (! osp)
+      invalid_operation (who, "writing");
+    else
+      {
+        std::ostream& os = *osp;
+
+        os << s;
+
+        if (! os)
+          error ("%s: write error", who.c_str ());
+        else
+          {
+            // FIXME: why does this seem to be necessary?
+            // Without it, output from a loop like
+            //
+            //   for i = 1:100, fputs (stdout, "foo\n"); endfor
+            //
+            // doesn't seem to go to the pager immediately.
+            os.flush ();
+
+            if (os)
+              retval = 0;
+            else
+              error ("%s: write error", who.c_str ());
+          }
+      }
+
+    return retval;
+  }
+
+  // Return current error message for this stream.
+
+  std::string
+  base_stream::error (bool clear_err, int& err_num)
+  {
+    err_num = fail ? -1 : 0;
+
+    std::string tmp = errmsg;
+
+    if (clear_err)
+      clear ();
+
+    return tmp;
+  }
+
+  void
+  base_stream::invalid_operation (const std::string& who, const char *rw)
+  {
+    // Note: This calls the member fcn error, not ::error from error.h.
+    error (who, std::string ("stream not open for ") + rw);
+  }
+
+  stream::stream (base_stream *bs)
+    : rep (bs)
+  {
+    if (rep)
+      rep->count = 1;
+  }
+
+  stream::~stream (void)
+  {
+    if (rep && --rep->count == 0)
+      delete rep;
+  }
+
+  stream::stream (const stream& s)
+    : rep (s.rep)
+  {
+    if (rep)
+      rep->count++;
+  }
+
+  stream&
+  stream::operator = (const stream& s)
+  {
+    if (rep != s.rep)
+      {
+        if (rep && --rep->count == 0)
+          delete rep;
+
+        rep = s.rep;
+
+        if (rep)
+          rep->count++;
+      }
+
+    return *this;
+  }
+
+  int
+  stream::flush (void)
+  {
+    int retval = -1;
+
+    if (stream_ok ())
+      retval = rep->flush ();
+
+    return retval;
+  }
+
+  std::string
+  stream::getl (octave_idx_type max_len, bool& err, const std::string& who)
+  {
+    std::string retval;
+
+    if (stream_ok ())
+      retval = rep->getl (max_len, err, who);
+
+    return retval;
+  }
+
+  std::string
+  stream::getl (const octave_value& tc_max_len, bool& err,
+                const std::string& who)
+  {
+    err = false;
+
+    int conv_err = 0;
+
+    int max_len = -1;
+
+    if (tc_max_len.is_defined ())
+      {
+        max_len = convert_to_valid_int (tc_max_len, conv_err);
+
+        if (conv_err || max_len < 0)
+          {
+            err = true;
+            ::error ("%s: invalid maximum length specified", who.c_str ());
+          }
+      }
+
+    return getl (max_len, err, who);
+  }
+
+  std::string
+  stream::gets (octave_idx_type max_len, bool& err, const std::string& who)
+  {
+    std::string retval;
+
+    if (stream_ok ())
+      retval = rep->gets (max_len, err, who);
+
+    return retval;
+  }
+
+  std::string
+  stream::gets (const octave_value& tc_max_len, bool& err,
+                const std::string& who)
+  {
+    err = false;
+
+    int conv_err = 0;
+
+    int max_len = -1;
+
+    if (tc_max_len.is_defined ())
+      {
+        max_len = convert_to_valid_int (tc_max_len, conv_err);
+
+        if (conv_err || max_len < 0)
+          {
+            err = true;
+            ::error ("%s: invalid maximum length specified", who.c_str ());
+          }
+      }
+
+    return gets (max_len, err, who);
+  }
+
+  off_t
+  stream::skipl (off_t count, bool& err, const std::string& who)
+  {
+    off_t retval = -1;
+
+    if (stream_ok ())
+      retval = rep->skipl (count, err, who);
+
+    return retval;
+  }
+
+  off_t
+  stream::skipl (const octave_value& tc_count, bool& err,
+                 const std::string& who)
+  {
+    err = false;
+
+    int conv_err = 0;
+
+    int count = 1;
+
+    if (tc_count.is_defined ())
+      {
+        if (tc_count.is_scalar_type ()
+            && octave::math::isinf (tc_count.scalar_value ()))
+          count = -1;
+        else
+          {
+            count = convert_to_valid_int (tc_count, conv_err);
+
+            if (conv_err || count < 0)
+              {
+                err = true;
+                ::error ("%s: invalid number of lines specified", who.c_str ());
+              }
+          }
+      }
+
+    return skipl (count, err, who);
+  }
+
+  int
+  stream::seek (off_t offset, int origin)
+  {
+    int status = -1;
+
+    if (stream_ok ())
+      {
+        clearerr ();
+
+        // Find current position so we can return to it if needed.
+        off_t orig_pos = rep->tell ();
+
+        // Move to end of file.  If successful, find the offset of the end.
+        status = rep->seek (0, SEEK_END);
+
+        if (status == 0)
+          {
+            off_t eof_pos = rep->tell ();
+
+            if (origin == SEEK_CUR)
+              {
+                // Move back to original position, otherwise we will be seeking
+                // from the end of file which is probably not the original
+                // location.
+                rep->seek (orig_pos, SEEK_SET);
+              }
+
+            // Attempt to move to desired position; may be outside bounds of
+            // existing file.
+            status = rep->seek (offset, origin);
+
+            if (status == 0)
+              {
+                // Where are we after moving to desired position?
+                off_t desired_pos = rep->tell ();
+
+                // I don't think save_pos can be less than zero,
+                // but we'll check anyway...
+                if (desired_pos > eof_pos || desired_pos < 0)
+                  {
+                    // Seek outside bounds of file.
+                    // Failure should leave position unchanged.
+                    rep->seek (orig_pos, SEEK_SET);
+
+                    status = -1;
+                  }
+              }
+            else
+              {
+                // Seeking to the desired position failed.
+                // Move back to original position and return failure status.
+                rep->seek (orig_pos, SEEK_SET);
+
+                status = -1;
+              }
+          }
+      }
+
+    return status;
+  }
+
+  int
+  stream::seek (const octave_value& tc_offset,
+                const octave_value& tc_origin)
+  {
+    int retval = -1;
+
+    // FIXME: should we have octave_value methods that handle off_t explicitly?
+    octave_int64 val = tc_offset.xint64_scalar_value ("fseek: invalid value for offset");
+    off_t xoffset = val.value ();
+
+    int conv_err = 0;
+
+    int origin = SEEK_SET;
+
+    if (tc_origin.is_string ())
+      {
+        std::string xorigin = tc_origin.string_value ("fseek: invalid value for origin");
+
+        if (xorigin == "bof")
+          origin = SEEK_SET;
+        else if (xorigin == "cof")
+          origin = SEEK_CUR;
+        else if (xorigin == "eof")
+          origin = SEEK_END;
+        else
+          conv_err = -1;
+      }
+    else
+      {
+        int xorigin = convert_to_valid_int (tc_origin, conv_err);
+
+        if (! conv_err)
+          {
+            if (xorigin == -1)
+              origin = SEEK_SET;
+            else if (xorigin == 0)
+              origin = SEEK_CUR;
+            else if (xorigin == 1)
+              origin = SEEK_END;
+            else
+              conv_err = -1;
+          }
+      }
+
+    if (conv_err)
+      ::error ("fseek: invalid value for origin");
+
+    retval = seek (xoffset, origin);
+
+    if (retval != 0)
+      // Note: error is member fcn from stream, not ::error.
+      error ("fseek: failed to seek to requested position");
+
+    return retval;
+  }
+
+  off_t
+  stream::tell (void)
+  {
+    off_t retval = -1;
+
+    if (stream_ok ())
+      retval = rep->tell ();
+
+    return retval;
+  }
+
+  int
+  stream::rewind (void)
+  {
+    return seek (0, SEEK_SET);
+  }
+
+  bool
+  stream::is_open (void) const
+  {
+    bool retval = false;
+
+    if (stream_ok ())
+      retval = rep->is_open ();
+
+    return retval;
+  }
+
+  void
+  stream::close (void)
+  {
+    if (stream_ok ())
+      rep->close ();
+  }
 }
 
 // FIXME: maybe these should be defined in lo-ieee.h?
 
 template <typename T>
 static inline bool
 is_old_NA (T)
 {
@@ -6358,325 +6366,328 @@ typedef octave_value (*conv_fptr)
   TABLE_ELT (T, dt_uint64, V, uint64NDArray);   \
   TABLE_ELT (T, dt_single, V, FloatNDArray);    \
   TABLE_ELT (T, dt_double, V, NDArray);         \
   TABLE_ELT (T, dt_char, V, charNDArray);       \
   TABLE_ELT (T, dt_schar, V, charNDArray);      \
   TABLE_ELT (T, dt_uchar, V, charNDArray);      \
   TABLE_ELT (T, dt_logical, V, boolNDArray);
 
-octave_value
-octave_stream::finalize_read (std::list<void *>& input_buf_list,
-                              octave_idx_type input_buf_elts,
-                              octave_idx_type elts_read,
-                              octave_idx_type nr, octave_idx_type nc,
-                              oct_data_conv::data_type input_type,
-                              oct_data_conv::data_type output_type,
-                              octave::mach_info::float_format ffmt)
+namespace octave
 {
-  octave_value retval;
-
-  static bool initialized = false;
-
-  // Table function pointers for return types x read types.
-
-  static conv_fptr conv_fptr_table[oct_data_conv::dt_unknown][14];
-
-  if (! initialized)
-    {
-      for (int i = 0; i < oct_data_conv::dt_unknown; i++)
-        for (int j = 0; j < 14; j++)
-          conv_fptr_table[i][j] = 0;
-
-      FILL_TABLE_ROW (dt_int8, int8_t);
-      FILL_TABLE_ROW (dt_uint8, uint8_t);
-      FILL_TABLE_ROW (dt_int16, int16_t);
-      FILL_TABLE_ROW (dt_uint16, uint16_t);
-      FILL_TABLE_ROW (dt_int32, int32_t);
-      FILL_TABLE_ROW (dt_uint32, uint32_t);
-      FILL_TABLE_ROW (dt_int64, int64_t);
-      FILL_TABLE_ROW (dt_uint64, uint64_t);
-      FILL_TABLE_ROW (dt_single, float);
-      FILL_TABLE_ROW (dt_double, double);
-      FILL_TABLE_ROW (dt_char, char);
-      FILL_TABLE_ROW (dt_schar, signed char);
-      FILL_TABLE_ROW (dt_uchar, unsigned char);
-      FILL_TABLE_ROW (dt_logical, bool);
-
-      initialized = true;
-    }
-
-  bool swap = false;
-
-  if (ffmt == octave::mach_info::flt_fmt_unknown)
-    ffmt = float_format ();
-
-  if (octave::mach_info::words_big_endian ())
-    swap = (ffmt == octave::mach_info::flt_fmt_ieee_little_endian);
-  else
-    swap = (ffmt == octave::mach_info::flt_fmt_ieee_big_endian);
-
-  bool do_float_fmt_conv = ((input_type == oct_data_conv::dt_double
-                             || input_type == oct_data_conv::dt_single)
-                            && ffmt != float_format ());
-
-  bool do_NA_conv = (output_type == oct_data_conv::dt_double);
-
-  switch (output_type)
-    {
-    case oct_data_conv::dt_int8:
-    case oct_data_conv::dt_uint8:
-    case oct_data_conv::dt_int16:
-    case oct_data_conv::dt_uint16:
-    case oct_data_conv::dt_int32:
-    case oct_data_conv::dt_uint32:
-    case oct_data_conv::dt_int64:
-    case oct_data_conv::dt_uint64:
-    case oct_data_conv::dt_single:
-    case oct_data_conv::dt_double:
-    case oct_data_conv::dt_char:
-    case oct_data_conv::dt_schar:
-    case oct_data_conv::dt_uchar:
-    case oct_data_conv::dt_logical:
-      {
-        conv_fptr fptr = conv_fptr_table[input_type][output_type];
-
-        retval = fptr (input_buf_list, input_buf_elts, elts_read,
-                       nr, nc, swap, do_float_fmt_conv, do_NA_conv, ffmt);
-      }
-      break;
-
-    default:
-      ::error ("read: invalid type specification");
-    }
-
-  return retval;
-}
-
-octave_value
-octave_stream::read (const Array<double>& size, octave_idx_type block_size,
-                     oct_data_conv::data_type input_type,
-                     oct_data_conv::data_type output_type,
-                     octave_idx_type skip, octave::mach_info::float_format ffmt,
-                     octave_idx_type& count)
-{
-  octave_value retval;
-
-  octave_idx_type nr = -1;
-  octave_idx_type nc = -1;
-
-  bool one_elt_size_spec = false;
-
-  if (! stream_ok ())
+  octave_value
+  stream::finalize_read (std::list<void *>& input_buf_list,
+                         octave_idx_type input_buf_elts,
+                         octave_idx_type elts_read,
+                         octave_idx_type nr, octave_idx_type nc,
+                         oct_data_conv::data_type input_type,
+                         oct_data_conv::data_type output_type,
+                         octave::mach_info::float_format ffmt)
+  {
+    octave_value retval;
+
+    static bool initialized = false;
+
+    // Table function pointers for return types x read types.
+
+    static conv_fptr conv_fptr_table[oct_data_conv::dt_unknown][14];
+
+    if (! initialized)
+      {
+        for (int i = 0; i < oct_data_conv::dt_unknown; i++)
+          for (int j = 0; j < 14; j++)
+            conv_fptr_table[i][j] = 0;
+
+        FILL_TABLE_ROW (dt_int8, int8_t);
+        FILL_TABLE_ROW (dt_uint8, uint8_t);
+        FILL_TABLE_ROW (dt_int16, int16_t);
+        FILL_TABLE_ROW (dt_uint16, uint16_t);
+        FILL_TABLE_ROW (dt_int32, int32_t);
+        FILL_TABLE_ROW (dt_uint32, uint32_t);
+        FILL_TABLE_ROW (dt_int64, int64_t);
+        FILL_TABLE_ROW (dt_uint64, uint64_t);
+        FILL_TABLE_ROW (dt_single, float);
+        FILL_TABLE_ROW (dt_double, double);
+        FILL_TABLE_ROW (dt_char, char);
+        FILL_TABLE_ROW (dt_schar, signed char);
+        FILL_TABLE_ROW (dt_uchar, unsigned char);
+        FILL_TABLE_ROW (dt_logical, bool);
+
+        initialized = true;
+      }
+
+    bool swap = false;
+
+    if (ffmt == octave::mach_info::flt_fmt_unknown)
+      ffmt = float_format ();
+
+    if (octave::mach_info::words_big_endian ())
+      swap = (ffmt == octave::mach_info::flt_fmt_ieee_little_endian);
+    else
+      swap = (ffmt == octave::mach_info::flt_fmt_ieee_big_endian);
+
+    bool do_float_fmt_conv = ((input_type == oct_data_conv::dt_double
+                               || input_type == oct_data_conv::dt_single)
+                              && ffmt != float_format ());
+
+    bool do_NA_conv = (output_type == oct_data_conv::dt_double);
+
+    switch (output_type)
+      {
+      case oct_data_conv::dt_int8:
+      case oct_data_conv::dt_uint8:
+      case oct_data_conv::dt_int16:
+      case oct_data_conv::dt_uint16:
+      case oct_data_conv::dt_int32:
+      case oct_data_conv::dt_uint32:
+      case oct_data_conv::dt_int64:
+      case oct_data_conv::dt_uint64:
+      case oct_data_conv::dt_single:
+      case oct_data_conv::dt_double:
+      case oct_data_conv::dt_char:
+      case oct_data_conv::dt_schar:
+      case oct_data_conv::dt_uchar:
+      case oct_data_conv::dt_logical:
+        {
+          conv_fptr fptr = conv_fptr_table[input_type][output_type];
+
+          retval = fptr (input_buf_list, input_buf_elts, elts_read,
+                         nr, nc, swap, do_float_fmt_conv, do_NA_conv, ffmt);
+        }
+        break;
+
+      default:
+        ::error ("read: invalid type specification");
+      }
+
     return retval;
-
-  // FIXME: we may eventually want to make this extensible.
-
-  // FIXME: we need a better way to ensure that this
-  // numbering stays consistent with the order of the elements in the
-  // data_type enum in the oct_data_conv class.
-
-  // Expose this in a future version?
-  size_t char_count = 0;
-
-  ptrdiff_t tmp_count = 0;
-
-  try
-    {
-      get_size (size, nr, nc, one_elt_size_spec, "fread");
-    }
-  catch (const octave::execution_exception&)
-    {
-      invalid_operation ("fread", "reading");
-
+  }
+
+  octave_value
+  stream::read (const Array<double>& size, octave_idx_type block_size,
+                oct_data_conv::data_type input_type,
+                oct_data_conv::data_type output_type,
+                octave_idx_type skip, octave::mach_info::float_format ffmt,
+                octave_idx_type& count)
+  {
+    octave_value retval;
+
+    octave_idx_type nr = -1;
+    octave_idx_type nc = -1;
+
+    bool one_elt_size_spec = false;
+
+    if (! stream_ok ())
       return retval;
-    }
-
-  if (one_elt_size_spec)
-    {
-      // If NR == 0, Matlab returns [](0x0).
-
-      // If NR > 0, the result will be a column vector with the given
-      // number of rows.
-
-      // If NR < 0, then we have Inf and the result will be a column
-      // vector but we have to wait to see how big NR will be.
-
-      if (nr == 0)
-        nr = nc = 0;
-      else
-        nc = 1;
-    }
-  else
-    {
-      // Matlab returns [] even if there are two elements in the size
-      // specification and one is nonzero.
-
-      // If NC < 0 we have [NR, Inf] and we'll wait to decide how big NC
-      // should be.
-
-      if (nr == 0 || nc == 0)
-        nr = nc = 0;
-    }
-
-  // FIXME: Ensure that this does not overflow.
-  //        Maybe try comparing nr * nc computed in double with
-  //        std::numeric_limits<octave_idx_type>::max ();
-  octave_idx_type elts_to_read = nr * nc;
-
-  bool read_to_eof = elts_to_read < 0;
-
-  octave_idx_type input_buf_elts = -1;
-
-  if (skip == 0)
-    {
-      if (read_to_eof)
-        input_buf_elts = 1024 * 1024;
-      else
-        input_buf_elts = elts_to_read;
-    }
-  else
-    input_buf_elts = block_size;
-
-  octave_idx_type input_elt_size
-    = oct_data_conv::data_type_size (input_type);
-
-  ptrdiff_t input_buf_size
-    = static_cast<ptrdiff_t> (input_buf_elts) * input_elt_size;
-
-  assert (input_buf_size >= 0);
-
-  // Must also work and return correct type object
-  // for 0 elements to read.
-  std::istream *isp = input_stream ();
-
-  if (! isp)
-    error ("fread: invalid input stream");
-  else
-    {
-      std::istream& is = *isp;
-
-      std::list <void *> input_buf_list;
-
-      while (is && ! is.eof ()
-             && (read_to_eof || tmp_count < elts_to_read))
-        {
-          if (! read_to_eof)
-            {
-              octave_idx_type remaining_elts = elts_to_read - tmp_count;
-
-              if (remaining_elts < input_buf_elts)
-                input_buf_size = remaining_elts * input_elt_size;
-            }
-
-          char *input_buf = new char [input_buf_size];
-
-          is.read (input_buf, input_buf_size);
-
-          size_t gcount = is.gcount ();
-
-          char_count += gcount;
-
-          octave_idx_type nel = gcount / input_elt_size;
-
-          tmp_count += nel;
-
-          input_buf_list.push_back (input_buf);
-
-          if (is && skip != 0 && nel == block_size)
-            {
-              // Seek to skip.
-              // If skip would move past EOF, position at EOF.
-
-              off_t orig_pos = tell ();
-
-              seek (0, SEEK_END);
-
-              off_t eof_pos = tell ();
-
-              // Is it possible for this to fail to return us to
-              // the original position?
-              seek (orig_pos, SEEK_SET);
-
-              off_t remaining = eof_pos - orig_pos;
-
-              if (remaining < skip)
+
+    // FIXME: we may eventually want to make this extensible.
+
+    // FIXME: we need a better way to ensure that this
+    // numbering stays consistent with the order of the elements in the
+    // data_type enum in the oct_data_conv class.
+
+    // Expose this in a future version?
+    size_t char_count = 0;
+
+    ptrdiff_t tmp_count = 0;
+
+    try
+      {
+        get_size (size, nr, nc, one_elt_size_spec, "fread");
+      }
+    catch (const octave::execution_exception&)
+      {
+        invalid_operation ("fread", "reading");
+
+        return retval;
+      }
+
+    if (one_elt_size_spec)
+      {
+        // If NR == 0, Matlab returns [](0x0).
+
+        // If NR > 0, the result will be a column vector with the given
+        // number of rows.
+
+        // If NR < 0, then we have Inf and the result will be a column
+        // vector but we have to wait to see how big NR will be.
+
+        if (nr == 0)
+          nr = nc = 0;
+        else
+          nc = 1;
+      }
+    else
+      {
+        // Matlab returns [] even if there are two elements in the size
+        // specification and one is nonzero.
+
+        // If NC < 0 we have [NR, Inf] and we'll wait to decide how big NC
+        // should be.
+
+        if (nr == 0 || nc == 0)
+          nr = nc = 0;
+      }
+
+    // FIXME: Ensure that this does not overflow.
+    //        Maybe try comparing nr * nc computed in double with
+    //        std::numeric_limits<octave_idx_type>::max ();
+    octave_idx_type elts_to_read = nr * nc;
+
+    bool read_to_eof = elts_to_read < 0;
+
+    octave_idx_type input_buf_elts = -1;
+
+    if (skip == 0)
+      {
+        if (read_to_eof)
+          input_buf_elts = 1024 * 1024;
+        else
+          input_buf_elts = elts_to_read;
+      }
+    else
+      input_buf_elts = block_size;
+
+    octave_idx_type input_elt_size
+                                      = oct_data_conv::data_type_size (input_type);
+
+    ptrdiff_t input_buf_size
+                                      = static_cast<ptrdiff_t> (input_buf_elts) * input_elt_size;
+
+    assert (input_buf_size >= 0);
+
+    // Must also work and return correct type object
+    // for 0 elements to read.
+    std::istream *isp = input_stream ();
+
+    if (! isp)
+      error ("fread: invalid input stream");
+    else
+      {
+        std::istream& is = *isp;
+
+        std::list <void *> input_buf_list;
+
+        while (is && ! is.eof ()
+               && (read_to_eof || tmp_count < elts_to_read))
+          {
+            if (! read_to_eof)
+              {
+                octave_idx_type remaining_elts = elts_to_read - tmp_count;
+
+                if (remaining_elts < input_buf_elts)
+                  input_buf_size = remaining_elts * input_elt_size;
+              }
+
+            char *input_buf = new char [input_buf_size];
+
+            is.read (input_buf, input_buf_size);
+
+            size_t gcount = is.gcount ();
+
+            char_count += gcount;
+
+            octave_idx_type nel = gcount / input_elt_size;
+
+            tmp_count += nel;
+
+            input_buf_list.push_back (input_buf);
+
+            if (is && skip != 0 && nel == block_size)
+              {
+                // Seek to skip.
+                // If skip would move past EOF, position at EOF.
+
+                off_t orig_pos = tell ();
+
                 seek (0, SEEK_END);
-              else
-                seek (skip, SEEK_CUR);
-
-              if (! is)
-                break;
-            }
-        }
-
-      if (read_to_eof)
-        {
-          if (nc < 0)
-            {
+
+                off_t eof_pos = tell ();
+
+                // Is it possible for this to fail to return us to
+                // the original position?
+                seek (orig_pos, SEEK_SET);
+
+                off_t remaining = eof_pos - orig_pos;
+
+                if (remaining < skip)
+                  seek (0, SEEK_END);
+                else
+                  seek (skip, SEEK_CUR);
+
+                if (! is)
+                  break;
+              }
+          }
+
+        if (read_to_eof)
+          {
+            if (nc < 0)
+              {
+                nc = tmp_count / nr;
+
+                if (tmp_count % nr != 0)
+                  nc++;
+              }
+            else
+              nr = tmp_count;
+          }
+        else if (tmp_count == 0)
+          {
+            nr = 0;
+            nc = 0;
+          }
+        else if (tmp_count != nr * nc)
+          {
+            if (tmp_count % nr != 0)
+              nc = tmp_count / nr + 1;
+            else
               nc = tmp_count / nr;
 
-              if (tmp_count % nr != 0)
-                nc++;
-            }
-          else
-            nr = tmp_count;
-        }
-      else if (tmp_count == 0)
-        {
-          nr = 0;
-          nc = 0;
-        }
-      else if (tmp_count != nr * nc)
-        {
-          if (tmp_count % nr != 0)
-            nc = tmp_count / nr + 1;
-          else
-            nc = tmp_count / nr;
-
-          if (tmp_count < nr)
-            nr = tmp_count;
-        }
-
-      if (tmp_count > std::numeric_limits<octave_idx_type>::max ())
-        error ("fread: number of elements read exceeds max index size");
-      else
-        count = static_cast<octave_idx_type> (tmp_count);
-
-      retval = finalize_read (input_buf_list, input_buf_elts, count,
-                              nr, nc, input_type, output_type, ffmt);
-    }
-
-  return retval;
-}
-
-octave_idx_type
-octave_stream::write (const octave_value& data, octave_idx_type block_size,
-                      oct_data_conv::data_type output_type,
-                      octave_idx_type skip, octave::mach_info::float_format flt_fmt)
-{
-  octave_idx_type retval = -1;
-
-  if (! stream_ok ())
-    invalid_operation ("fwrite", "writing");
-  else
-    {
-      if (flt_fmt == octave::mach_info::flt_fmt_unknown)
-        flt_fmt = float_format ();
-
-      octave_idx_type status = data.write (*this, block_size, output_type,
-                                           skip, flt_fmt);
-
-      if (status < 0)
-        error ("fwrite: write error");
-      else
-        retval = status;
-    }
-
-  return retval;
+            if (tmp_count < nr)
+              nr = tmp_count;
+          }
+
+        if (tmp_count > std::numeric_limits<octave_idx_type>::max ())
+          error ("fread: number of elements read exceeds max index size");
+        else
+          count = static_cast<octave_idx_type> (tmp_count);
+
+        retval = finalize_read (input_buf_list, input_buf_elts, count,
+                                nr, nc, input_type, output_type, ffmt);
+      }
+
+    return retval;
+  }
+
+  octave_idx_type
+  stream::write (const octave_value& data, octave_idx_type block_size,
+                 oct_data_conv::data_type output_type,
+                 octave_idx_type skip, octave::mach_info::float_format flt_fmt)
+  {
+    octave_idx_type retval = -1;
+
+    if (! stream_ok ())
+      invalid_operation ("fwrite", "writing");
+    else
+      {
+        if (flt_fmt == octave::mach_info::flt_fmt_unknown)
+          flt_fmt = float_format ();
+
+        octave_idx_type status = data.write (*this, block_size, output_type,
+                                             skip, flt_fmt);
+
+        if (status < 0)
+          error ("fwrite: write error");
+        else
+          retval = status;
+      }
+
+    return retval;
+  }
 }
 
 template <typename T, typename V>
 static void
 convert_chars (const void *data, void *conv_data, octave_idx_type n_elts)
 {
   const T *tt_data = static_cast<const T *> (data);
 
@@ -6816,805 +6827,810 @@ convert_data (const T *data, void *conv_
 
     default:
       ::error ("write: invalid type specification");
     }
 
   return retval;
 }
 
-bool
-octave_stream::write_bytes (const void *data, size_t nbytes)
-{
-  bool status = false;
-
-  std::ostream *osp = output_stream ();
-
-  if (osp)
-    {
-      std::ostream& os = *osp;
-
-      if (os)
-        {
-          os.write (static_cast<const char *> (data), nbytes);
-
-          if (os)
-            status = true;
-        }
-    }
-
-  return status;
-}
-
-bool
-octave_stream::skip_bytes (size_t skip)
+namespace octave
 {
-  bool status = false;
-
-  std::ostream *osp = output_stream ();
-
-  if (! osp)
-    return false;
-
-  std::ostream& os = *osp;
-
-  // Seek to skip when inside bounds of existing file.
-  // Otherwise, write NUL to skip.
-  off_t orig_pos = tell ();
-
-  seek (0, SEEK_END);
-
-  off_t eof_pos = tell ();
-
-  // Is it possible for this to fail to return us to the original position?
-  seek (orig_pos, SEEK_SET);
-
-  size_t remaining = eof_pos - orig_pos;
-
-  if (remaining < skip)
-    {
-      seek (0, SEEK_END);
-
-      // FIXME: probably should try to write larger blocks...
-      unsigned char zero = 0;
-      for (size_t j = 0; j < skip - remaining; j++)
-        os.write (reinterpret_cast<const char *> (&zero), 1);
-    }
-  else
-    seek (skip, SEEK_CUR);
-
-  if (os)
-    status = true;
-
-  return status;
-}
-
-template <typename T>
-octave_idx_type
-octave_stream::write (const Array<T>& data, octave_idx_type block_size,
-                      oct_data_conv::data_type output_type,
-                      octave_idx_type skip,
-                      octave::mach_info::float_format flt_fmt)
-{
-  bool swap = false;
-
-  if (octave::mach_info::words_big_endian ())
-    swap = (flt_fmt == octave::mach_info::flt_fmt_ieee_little_endian);
-  else
-    swap = (flt_fmt == octave::mach_info::flt_fmt_ieee_big_endian);
-
-  bool do_data_conversion = (swap || ! is_equivalent_type<T> (output_type)
-                             || flt_fmt != octave::mach_info::float_format ());
-
-  octave_idx_type nel = data.numel ();
-
-  octave_idx_type chunk_size;
-
-  if (skip != 0)
-    chunk_size = block_size;
-  else if (do_data_conversion)
-    chunk_size = 1024 * 1024;
-  else
-    chunk_size = nel;
-
-  octave_idx_type i = 0;
-
-  const T *pdata = data.data ();
-
-  while (i < nel)
-    {
-      if (skip != 0)
-        {
-          if (! skip_bytes (skip))
-            return -1;
-        }
-
-      octave_idx_type remaining_nel = nel - i;
-
-      if (chunk_size > remaining_nel)
-        chunk_size = remaining_nel;
-
-      bool status = false;
-
-      if (do_data_conversion)
-        {
-          size_t output_size
-            = chunk_size * oct_data_conv::data_type_size (output_type);
-
-          OCTAVE_LOCAL_BUFFER (unsigned char, conv_data, output_size);
-
-          status = convert_data (&pdata[i], conv_data, chunk_size,
-                                 output_type, flt_fmt);
-
-          if (status)
-            status = write_bytes (conv_data, output_size);
-        }
-      else
-        status = write_bytes (pdata, sizeof (T) * chunk_size);
-
-      if (! status)
-        return -1;
-
-      i += chunk_size;
-    }
-
-  return nel;
-}
+  bool
+  stream::write_bytes (const void *data, size_t nbytes)
+  {
+    bool status = false;
+
+    std::ostream *osp = output_stream ();
+
+    if (osp)
+      {
+        std::ostream& os = *osp;
+
+        if (os)
+          {
+            os.write (static_cast<const char *> (data), nbytes);
+
+            if (os)
+              status = true;
+          }
+      }
+
+    return status;
+  }
+
+  bool
+  stream::skip_bytes (size_t skip)
+  {
+    bool status = false;
+
+    std::ostream *osp = output_stream ();
+
+    if (! osp)
+      return false;
+
+    std::ostream& os = *osp;
+
+    // Seek to skip when inside bounds of existing file.
+    // Otherwise, write NUL to skip.
+    off_t orig_pos = tell ();
+
+    seek (0, SEEK_END);
+
+    off_t eof_pos = tell ();
+
+    // Is it possible for this to fail to return us to the original position?
+    seek (orig_pos, SEEK_SET);
+
+    size_t remaining = eof_pos - orig_pos;
+
+    if (remaining < skip)
+      {
+        seek (0, SEEK_END);
+
+        // FIXME: probably should try to write larger blocks...
+        unsigned char zero = 0;
+        for (size_t j = 0; j < skip - remaining; j++)
+          os.write (reinterpret_cast<const char *> (&zero), 1);
+      }
+    else
+      seek (skip, SEEK_CUR);
+
+    if (os)
+      status = true;
+
+    return status;
+  }
+
+  template <typename T>
+  octave_idx_type
+  stream::write (const Array<T>& data, octave_idx_type block_size,
+                 oct_data_conv::data_type output_type,
+                 octave_idx_type skip,
+                 octave::mach_info::float_format flt_fmt)
+  {
+    bool swap = false;
+
+    if (octave::mach_info::words_big_endian ())
+      swap = (flt_fmt == octave::mach_info::flt_fmt_ieee_little_endian);
+    else
+      swap = (flt_fmt == octave::mach_info::flt_fmt_ieee_big_endian);
+
+    bool do_data_conversion = (swap || ! is_equivalent_type<T> (output_type)
+                               || flt_fmt != octave::mach_info::float_format ());
+
+    octave_idx_type nel = data.numel ();
+
+    octave_idx_type chunk_size;
+
+    if (skip != 0)
+      chunk_size = block_size;
+    else if (do_data_conversion)
+      chunk_size = 1024 * 1024;
+    else
+      chunk_size = nel;
+
+    octave_idx_type i = 0;
+
+    const T *pdata = data.data ();
+
+    while (i < nel)
+      {
+        if (skip != 0)
+          {
+            if (! skip_bytes (skip))
+              return -1;
+          }
+
+        octave_idx_type remaining_nel = nel - i;
+
+        if (chunk_size > remaining_nel)
+          chunk_size = remaining_nel;
+
+        bool status = false;
+
+        if (do_data_conversion)
+          {
+            size_t output_size
+              = chunk_size * oct_data_conv::data_type_size (output_type);
+
+            OCTAVE_LOCAL_BUFFER (unsigned char, conv_data, output_size);
+
+            status = convert_data (&pdata[i], conv_data, chunk_size,
+                                   output_type, flt_fmt);
+
+            if (status)
+              status = write_bytes (conv_data, output_size);
+          }
+        else
+          status = write_bytes (pdata, sizeof (T) * chunk_size);
+
+        if (! status)
+          return -1;
+
+        i += chunk_size;
+      }
+
+    return nel;
+  }
 
 #define INSTANTIATE_WRITE(T)                                            \
   template                                                              \
   octave_idx_type                                                       \
-  octave_stream::write (const Array<T>& data, octave_idx_type block_size, \
-                        oct_data_conv::data_type output_type,           \
-                        octave_idx_type skip,                           \
-                        octave::mach_info::float_format flt_fmt)
-
-INSTANTIATE_WRITE (octave_int8);
-INSTANTIATE_WRITE (octave_uint8);
-INSTANTIATE_WRITE (octave_int16);
-INSTANTIATE_WRITE (octave_uint16);
-INSTANTIATE_WRITE (octave_int32);
-INSTANTIATE_WRITE (octave_uint32);
-INSTANTIATE_WRITE (octave_int64);
-INSTANTIATE_WRITE (octave_uint64);
-INSTANTIATE_WRITE (int8_t);
-INSTANTIATE_WRITE (uint8_t);
-INSTANTIATE_WRITE (int16_t);
-INSTANTIATE_WRITE (uint16_t);
-INSTANTIATE_WRITE (int32_t);
-INSTANTIATE_WRITE (uint32_t);
-INSTANTIATE_WRITE (int64_t);
-INSTANTIATE_WRITE (uint64_t);
-INSTANTIATE_WRITE (bool);
+  stream::write (const Array<T>& data, octave_idx_type block_size,      \
+                 oct_data_conv::data_type output_type,                  \
+                 octave_idx_type skip,                                  \
+                 octave::mach_info::float_format flt_fmt)
+
+    INSTANTIATE_WRITE (octave_int8);
+  INSTANTIATE_WRITE (octave_uint8);
+  INSTANTIATE_WRITE (octave_int16);
+  INSTANTIATE_WRITE (octave_uint16);
+  INSTANTIATE_WRITE (octave_int32);
+  INSTANTIATE_WRITE (octave_uint32);
+  INSTANTIATE_WRITE (octave_int64);
+  INSTANTIATE_WRITE (octave_uint64);
+  INSTANTIATE_WRITE (int8_t);
+  INSTANTIATE_WRITE (uint8_t);
+  INSTANTIATE_WRITE (int16_t);
+  INSTANTIATE_WRITE (uint16_t);
+  INSTANTIATE_WRITE (int32_t);
+  INSTANTIATE_WRITE (uint32_t);
+  INSTANTIATE_WRITE (int64_t);
+  INSTANTIATE_WRITE (uint64_t);
+  INSTANTIATE_WRITE (bool);
 #if defined (OCTAVE_HAVE_OVERLOAD_CHAR_INT8_TYPES)
-INSTANTIATE_WRITE (char);
+  INSTANTIATE_WRITE (char);
 #endif
-INSTANTIATE_WRITE (float);
-INSTANTIATE_WRITE (double);
-
-octave_value
-octave_stream::scanf (const std::string& fmt, const Array<double>& size,
-                      octave_idx_type& count, const std::string& who)
-{
-  octave_value retval;
-
-  if (stream_ok ())
-    retval = rep->scanf (fmt, size, count, who);
-
-  return retval;
-}
-
-octave_value
-octave_stream::scanf (const octave_value& fmt, const Array<double>& size,
-                      octave_idx_type& count, const std::string& who)
-{
-  octave_value retval = Matrix ();
-
-  if (fmt.is_string ())
-    {
-      std::string sfmt = fmt.string_value ();
-
-      if (fmt.is_sq_string ())
-        sfmt = do_string_escapes (sfmt);
-
-      retval = scanf (sfmt, size, count, who);
-    }
-  else
-    {
-      // Note: error is member fcn from octave_stream, not ::error.
-      error (who + ": format must be a string");
-    }
-
-  return retval;
-}
-
-octave_value_list
-octave_stream::oscanf (const std::string& fmt, const std::string& who)
-{
-  octave_value_list retval;
-
-  if (stream_ok ())
-    retval = rep->oscanf (fmt, who);
-
-  return retval;
-}
-
-octave_value_list
-octave_stream::oscanf (const octave_value& fmt, const std::string& who)
-{
-  octave_value_list retval;
-
-  if (fmt.is_string ())
-    {
-      std::string sfmt = fmt.string_value ();
-
-      if (fmt.is_sq_string ())
-        sfmt = do_string_escapes (sfmt);
-
-      retval = oscanf (sfmt, who);
-    }
-  else
-    {
-      // Note: error is member fcn from octave_stream, not ::error.
-      error (who + ": format must be a string");
-    }
-
-  return retval;
-}
-
-octave_value
-octave_stream::textscan (const std::string& fmt, octave_idx_type ntimes,
-                         const octave_value_list& options,
-                         const std::string& who, octave_idx_type& count)
-{
-  return (stream_ok ()
-          ? rep->do_textscan (fmt, ntimes, options, who, count)
-          : octave_value ());
-}
-
-int
-octave_stream::printf (const std::string& fmt, const octave_value_list& args,
-                       const std::string& who)
-{
-  int retval = -1;
-
-  if (stream_ok ())
-    retval = rep->printf (fmt, args, who);
-
-  return retval;
-}
-
-int
-octave_stream::printf (const octave_value& fmt, const octave_value_list& args,
-                       const std::string& who)
-{
-  int retval = 0;
-
-  if (fmt.is_string ())
-    {
-      std::string sfmt = fmt.string_value ();
-
-      if (fmt.is_sq_string ())
-        sfmt = do_string_escapes (sfmt);
-
-      retval = printf (sfmt, args, who);
-    }
-  else
-    {
-      // Note: error is member fcn from octave_stream, not ::error.
-      error (who + ": format must be a string");
-    }
-
-  return retval;
-}
-
-int
-octave_stream::puts (const std::string& s, const std::string& who)
-{
-  int retval = -1;
-
-  if (stream_ok ())
-    retval = rep->puts (s, who);
-
-  return retval;
-}
-
-// FIXME: maybe this should work for string arrays too.
-
-int
-octave_stream::puts (const octave_value& tc_s, const std::string& who)
-{
-  int retval = -1;
-
-  if (tc_s.is_string ())
-    {
-      std::string s = tc_s.string_value ();
-      retval = puts (s, who);
-    }
-  else
-    {
-      // Note: error is member fcn from octave_stream, not ::error.
-      error (who + ": argument must be a string");
-    }
-
-  return retval;
-}
-
-bool
-octave_stream::eof (void) const
-{
-  int retval = -1;
-
-  if (stream_ok ())
-    retval = rep->eof ();
-
-  return retval;
-}
-
-std::string
-octave_stream::error (bool clear, int& err_num)
-{
-  std::string retval = "invalid stream object";
-
-  if (stream_ok (false))
-    retval = rep->error (clear, err_num);
-
-  return retval;
-}
-
-std::string
-octave_stream::name (void) const
-{
-  std::string retval;
-
-  if (stream_ok ())
-    retval = rep->name ();
-
-  return retval;
-}
-
-int
-octave_stream::mode (void) const
-{
-  int retval = 0;
-
-  if (stream_ok ())
-    retval = rep->mode ();
-
-  return retval;
-}
-
-octave::mach_info::float_format
-octave_stream::float_format (void) const
-{
-  octave::mach_info::float_format retval = octave::mach_info::flt_fmt_unknown;
-
-  if (stream_ok ())
-    retval = rep->float_format ();
-
-  return retval;
-}
-
-std::string
-octave_stream::mode_as_string (int mode)
-{
-  std::string retval = "???";
-  std::ios::openmode in_mode = static_cast<std::ios::openmode> (mode);
-
-  if (in_mode == std::ios::in)
-    retval = "r";
-  else if (in_mode == std::ios::out
-           || in_mode == (std::ios::out | std::ios::trunc))
-    retval = "w";
-  else if (in_mode == (std::ios::out | std::ios::app))
-    retval = "a";
-  else if (in_mode == (std::ios::in | std::ios::out))
-    retval = "r+";
-  else if (in_mode == (std::ios::in | std::ios::out | std::ios::trunc))
-    retval = "w+";
-  else if (in_mode == (std::ios::in | std::ios::out | std::ios::ate))
-    retval = "a+";
-  else if (in_mode == (std::ios::in | std::ios::binary))
-    retval = "rb";
-  else if (in_mode == (std::ios::out | std::ios::binary)
-           || in_mode == (std::ios::out | std::ios::trunc | std::ios::binary))
-    retval = "wb";
-  else if (in_mode == (std::ios::out | std::ios::app | std::ios::binary))
-    retval = "ab";
-  else if (in_mode == (std::ios::in | std::ios::out | std::ios::binary))
-    retval = "r+b";
-  else if (in_mode == (std::ios::in | std::ios::out | std::ios::trunc
-                       | std::ios::binary))
-    retval = "w+b";
-  else if (in_mode == (std::ios::in | std::ios::out | std::ios::ate
-                       | std::ios::binary))
-    retval = "a+b";
-
-  return retval;
-}
-
-octave_stream_list *octave_stream_list::instance = 0;
-
-bool
-octave_stream_list::instance_ok (void)
-{
-  bool retval = true;
-
-  if (! instance)
-    {
-      instance = new octave_stream_list ();
-
-      if (instance)
-        singleton_cleanup_list::add (cleanup_instance);
-    }
-
-  if (! instance)
-    ::error ("unable to create stream list object!");
-
-  return retval;
-}
-
-int
-octave_stream_list::insert (octave_stream& os)
-{
-  return (instance_ok ()) ? instance->do_insert (os) : -1;
-}
-
-octave_stream
-octave_stream_list::lookup (int fid, const std::string& who)
-{
-  return (instance_ok ()) ? instance->do_lookup (fid, who) : octave_stream ();
-}
-
-octave_stream
-octave_stream_list::lookup (const octave_value& fid, const std::string& who)
-{
-  return (instance_ok ()) ? instance->do_lookup (fid, who) : octave_stream ();
-}
-
-int
-octave_stream_list::remove (int fid, const std::string& who)
-{
-  return (instance_ok ()) ? instance->do_remove (fid, who) : -1;
-}
-
-int
-octave_stream_list::remove (const octave_value& fid, const std::string& who)
-{
-  return (instance_ok ()) ? instance->do_remove (fid, who) : -1;
-}
-
-void
-octave_stream_list::clear (bool flush)
-{
-  if (instance)
-    instance->do_clear (flush);
-}
-
-string_vector
-octave_stream_list::get_info (int fid)
-{
-  return (instance_ok ()) ? instance->do_get_info (fid) : string_vector ();
-}
-
-string_vector
-octave_stream_list::get_info (const octave_value& fid)
-{
-  return (instance_ok ()) ? instance->do_get_info (fid) : string_vector ();
-}
-
-std::string
-octave_stream_list::list_open_files (void)
-{
-  return (instance_ok ()) ? instance->do_list_open_files () : "";
-}
-
-octave_value
-octave_stream_list::open_file_numbers (void)
-{
-  return (instance_ok ())
-         ? instance->do_open_file_numbers () : octave_value ();
-}
-
-int
-octave_stream_list::get_file_number (const octave_value& fid)
-{
-  return (instance_ok ()) ? instance->do_get_file_number (fid) : -1;
-}
-
-int
-octave_stream_list::do_insert (octave_stream& os)
-{
-  // Insert item with key corresponding to file-descriptor.
-
-  int stream_number = os.file_number ();
-
-  if (stream_number == -1)
+  INSTANTIATE_WRITE (float);
+  INSTANTIATE_WRITE (double);
+
+  octave_value
+  stream::scanf (const std::string& fmt, const Array<double>& size,
+                 octave_idx_type& count, const std::string& who)
+  {
+    octave_value retval;
+
+    if (stream_ok ())
+      retval = rep->scanf (fmt, size, count, who);
+
+    return retval;
+  }
+
+  octave_value
+  stream::scanf (const octave_value& fmt, const Array<double>& size,
+                 octave_idx_type& count, const std::string& who)
+  {
+    octave_value retval = Matrix ();
+
+    if (fmt.is_string ())
+      {
+        std::string sfmt = fmt.string_value ();
+
+        if (fmt.is_sq_string ())
+          sfmt = do_string_escapes (sfmt);
+
+        retval = scanf (sfmt, size, count, who);
+      }
+    else
+      {
+        // Note: error is member fcn from stream, not ::error.
+        error (who + ": format must be a string");
+      }
+
+    return retval;
+  }
+
+  octave_value_list
+  stream::oscanf (const std::string& fmt, const std::string& who)
+  {
+    octave_value_list retval;
+
+    if (stream_ok ())
+      retval = rep->oscanf (fmt, who);
+
+    return retval;
+  }
+
+  octave_value_list
+  stream::oscanf (const octave_value& fmt, const std::string& who)
+  {
+    octave_value_list retval;
+
+    if (fmt.is_string ())
+      {
+        std::string sfmt = fmt.string_value ();
+
+        if (fmt.is_sq_string ())
+          sfmt = do_string_escapes (sfmt);
+
+        retval = oscanf (sfmt, who);
+      }
+    else
+      {
+        // Note: error is member fcn from stream, not ::error.
+        error (who + ": format must be a string");
+      }
+
+    return retval;
+  }
+
+  octave_value
+  stream::textscan (const std::string& fmt, octave_idx_type ntimes,
+                    const octave_value_list& options,
+                    const std::string& who, octave_idx_type& count)
+  {
+    return (stream_ok ()
+            ? rep->do_textscan (fmt, ntimes, options, who, count)
+            : octave_value ());
+  }
+
+  int
+  stream::printf (const std::string& fmt, const octave_value_list& args,
+                  const std::string& who)
+  {
+    int retval = -1;
+
+    if (stream_ok ())
+      retval = rep->printf (fmt, args, who);
+
+    return retval;
+  }
+
+  int
+  stream::printf (const octave_value& fmt, const octave_value_list& args,
+                  const std::string& who)
+  {
+    int retval = 0;
+
+    if (fmt.is_string ())
+      {
+        std::string sfmt = fmt.string_value ();
+
+        if (fmt.is_sq_string ())
+          sfmt = do_string_escapes (sfmt);
+
+        retval = printf (sfmt, args, who);
+      }
+    else
+      {
+        // Note: error is member fcn from stream, not ::error.
+        error (who + ": format must be a string");
+      }
+
+    return retval;
+  }
+
+  int
+  stream::puts (const std::string& s, const std::string& who)
+  {
+    int retval = -1;
+
+    if (stream_ok ())
+      retval = rep->puts (s, who);
+
+    return retval;
+  }
+
+  // FIXME: maybe this should work for string arrays too.
+
+  int
+  stream::puts (const octave_value& tc_s, const std::string& who)
+  {
+    int retval = -1;
+
+    if (tc_s.is_string ())
+      {
+        std::string s = tc_s.string_value ();
+        retval = puts (s, who);
+      }
+    else
+      {
+        // Note: error is member fcn from stream, not ::error.
+        error (who + ": argument must be a string");
+      }
+
+    return retval;
+  }
+
+  bool
+  stream::eof (void) const
+  {
+    int retval = -1;
+
+    if (stream_ok ())
+      retval = rep->eof ();
+
+    return retval;
+  }
+
+  std::string
+  stream::error (bool clear, int& err_num)
+  {
+    std::string retval = "invalid stream object";
+
+    if (stream_ok (false))
+      retval = rep->error (clear, err_num);
+
+    return retval;
+  }
+
+  std::string
+  stream::name (void) const
+  {
+    std::string retval;
+
+    if (stream_ok ())
+      retval = rep->name ();
+
+    return retval;
+  }
+
+  int
+  stream::mode (void) const
+  {
+    int retval = 0;
+
+    if (stream_ok ())
+      retval = rep->mode ();
+
+    return retval;
+  }
+
+  octave::mach_info::float_format
+  stream::float_format (void) const
+  {
+    octave::mach_info::float_format retval = octave::mach_info::flt_fmt_unknown;
+
+    if (stream_ok ())
+      retval = rep->float_format ();
+
+    return retval;
+  }
+
+  std::string
+  stream::mode_as_string (int mode)
+  {
+    std::string retval = "???";
+    std::ios::openmode in_mode = static_cast<std::ios::openmode> (mode);
+
+    if (in_mode == std::ios::in)
+      retval = "r";
+    else if (in_mode == std::ios::out
+             || in_mode == (std::ios::out | std::ios::trunc))
+      retval = "w";
+    else if (in_mode == (std::ios::out | std::ios::app))
+      retval = "a";
+    else if (in_mode == (std::ios::in | std::ios::out))
+      retval = "r+";
+    else if (in_mode == (std::ios::in | std::ios::out | std::ios::trunc))
+      retval = "w+";
+    else if (in_mode == (std::ios::in | std::ios::out | std::ios::ate))
+      retval = "a+";
+    else if (in_mode == (std::ios::in | std::ios::binary))
+      retval = "rb";
+    else if (in_mode == (std::ios::out | std::ios::binary)
+             || in_mode == (std::ios::out | std::ios::trunc | std::ios::binary))
+      retval = "wb";
+    else if (in_mode == (std::ios::out | std::ios::app | std::ios::binary))
+      retval = "ab";
+    else if (in_mode == (std::ios::in | std::ios::out | std::ios::binary))
+      retval = "r+b";
+    else if (in_mode == (std::ios::in | std::ios::out | std::ios::trunc
+                         | std::ios::binary))
+      retval = "w+b";
+    else if (in_mode == (std::ios::in | std::ios::out | std::ios::ate
+                         | std::ios::binary))
+      retval = "a+b";
+
+    return retval;
+  }
+
+  stream_list *stream_list::instance = 0;
+
+  bool
+  stream_list::instance_ok (void)
+  {
+    bool retval = true;
+
+    if (! instance)
+      {
+        instance = new stream_list ();
+
+        if (instance)
+          singleton_cleanup_list::add (cleanup_instance);
+      }
+
+    if (! instance)
+      ::error ("unable to create stream list object!");
+
+    return retval;
+  }
+
+  int
+  stream_list::insert (stream& os)
+  {
+    return (instance_ok ()) ? instance->do_insert (os) : -1;
+  }
+
+  stream
+  stream_list::lookup (int fid, const std::string& who)
+  {
+    return (instance_ok ()) ? instance->do_lookup (fid, who) : stream ();
+  }
+
+  stream
+  stream_list::lookup (const octave_value& fid, const std::string& who)
+  {
+    return (instance_ok ()) ? instance->do_lookup (fid, who) : stream ();
+  }
+
+  int
+  stream_list::remove (int fid, const std::string& who)
+  {
+    return (instance_ok ()) ? instance->do_remove (fid, who) : -1;
+  }
+
+  int
+  stream_list::remove (const octave_value& fid, const std::string& who)
+  {
+    return (instance_ok ()) ? instance->do_remove (fid, who) : -1;
+  }
+
+  void
+  stream_list::clear (bool flush)
+  {
+    if (instance)
+      instance->do_clear (flush);
+  }
+
+  string_vector
+  stream_list::get_info (int fid)
+  {
+    return (instance_ok ()) ? instance->do_get_info (fid) : string_vector ();
+  }
+
+  string_vector
+  stream_list::get_info (const octave_value& fid)
+  {
+    return (instance_ok ()) ? instance->do_get_info (fid) : string_vector ();
+  }
+
+  std::string
+  stream_list::list_open_files (void)
+  {
+    return (instance_ok ()) ? instance->do_list_open_files () : "";
+  }
+
+  octave_value
+  stream_list::open_file_numbers (void)
+  {
+    return (instance_ok ())
+      ? instance->do_open_file_numbers () : octave_value ();
+  }
+
+  int
+  stream_list::get_file_number (const octave_value& fid)
+  {
+    return (instance_ok ()) ? instance->do_get_file_number (fid) : -1;
+  }
+
+  int
+  stream_list::do_insert (stream& os)
+  {
+    // Insert item with key corresponding to file-descriptor.
+
+    int stream_number = os.file_number ();
+
+    if (stream_number == -1)
+      return stream_number;
+
+    // Should we test for
+    //
+    //  (list.find (stream_number) != list.end ()
+    //   && list[stream_number].is_open ())
+    //
+    // and respond with "error ("internal error: ...")"?  It should not
+    // happen except for some bug or if the user has opened a stream with
+    // an interpreted command, but closed it directly with a system call
+    // in an oct-file; then the kernel knows the fd is free, but Octave
+    // does not know.  If it happens, it should not do harm here to simply
+    // overwrite this entry, although the wrong entry might have done harm
+    // before.
+
+    if (list.size () >= list.max_size ())
+      ::error ("could not create file id");
+
+    list[stream_number] = os;
+
     return stream_number;
-
-  // Should we test for
-  //
-  //  (list.find (stream_number) != list.end ()
-  //   && list[stream_number].is_open ())
-  //
-  // and respond with "error ("internal error: ...")"?  It should not
-  // happen except for some bug or if the user has opened a stream with
-  // an interpreted command, but closed it directly with a system call
-  // in an oct-file; then the kernel knows the fd is free, but Octave
-  // does not know.  If it happens, it should not do harm here to simply
-  // overwrite this entry, although the wrong entry might have done harm
-  // before.
-
-  if (list.size () >= list.max_size ())
-    ::error ("could not create file id");
-
-  list[stream_number] = os;
-
-  return stream_number;
+  }
 }
 
 OCTAVE_NORETURN static
 void
 err_invalid_file_id (int fid, const std::string& who)
 {
   if (who.empty ())
     ::error ("invalid stream number = %d", fid);
   else
     ::error ("%s: invalid stream number = %d", who.c_str (), fid);
 }
 
-octave_stream
-octave_stream_list::do_lookup (int fid, const std::string& who) const
-{
-  octave_stream retval;
-
-  if (fid < 0)
-    err_invalid_file_id (fid, who);
-
-  if (lookup_cache != list.end () && lookup_cache->first == fid)
-    retval = lookup_cache->second;
-  else
-    {
-      ostrl_map::const_iterator iter = list.find (fid);
-
-      if (iter == list.end ())
-        err_invalid_file_id (fid, who);
-
-      retval = iter->second;
-      lookup_cache = iter;
-    }
-
-  return retval;
-}
-
-octave_stream
-octave_stream_list::do_lookup (const octave_value& fid,
-                               const std::string& who) const
-{
-  int i = get_file_number (fid);
-
-  return do_lookup (i, who);
-}
-
-int
-octave_stream_list::do_remove (int fid, const std::string& who)
-{
-  // Can't remove stdin (std::cin), stdout (std::cout), or stderr (std::cerr).
-  if (fid < 3)
-    err_invalid_file_id (fid, who);
-
-  ostrl_map::iterator iter = list.find (fid);
-
-  if (iter == list.end ())
-    err_invalid_file_id (fid, who);
-
-  octave_stream os = iter->second;
-  list.erase (iter);
-  lookup_cache = list.end ();
-
-  // FIXME: is this check redundant?
-  if (! os.is_valid ())
-    err_invalid_file_id (fid, who);
-
-  os.close ();
-
-  return 0;
-}
-
-int
-octave_stream_list::do_remove (const octave_value& fid, const std::string& who)
+namespace octave
 {
-  int retval = -1;
-
-  if (fid.is_string () && fid.string_value () == "all")
-    {
-      do_clear (false);
-
-      retval = 0;
-    }
-  else
-    {
-      int i = get_file_number (fid);
-
-      retval = do_remove (i, who);
-    }
-
-  return retval;
-}
-
-void
-octave_stream_list::do_clear (bool flush)
-{
-  if (flush)
-    {
-      // Flush stdout and stderr.
-      list[1].flush ();
-      list[2].flush ();
-    }
-
-  for (ostrl_map::iterator iter = list.begin (); iter != list.end (); )
-    {
-      int fid = iter->first;
-      if (fid < 3)  // Don't delete stdin, stdout, stderr
-        {
-          iter++;
-          continue;
-        }
-
-      octave_stream os = iter->second;
-
-      std::string name = os.name ();
-      std::transform (name.begin (), name.end (), name.begin (), tolower);
-
-      // FIXME: This test for gnuplot is hardly foolproof.
-      if (name.find ("gnuplot") != std::string::npos)
-        {
-          // Don't close down pipes to gnuplot
-          iter++;
-          continue;
-        }
-
-      // Normal file handle.  Close and delete from list.
-      if (os.is_valid ())
-        os.close ();
-
-      list.erase (iter++);
-    }
-
-  lookup_cache = list.end ();
-}
-
-string_vector
-octave_stream_list::do_get_info (int fid) const
-{
-  string_vector retval (3);
-
-  if (fid < 0)
+  stream
+  stream_list::do_lookup (int fid, const std::string& who) const
+  {
+    stream retval;
+
+    if (fid < 0)
+      err_invalid_file_id (fid, who);
+
+    if (lookup_cache != list.end () && lookup_cache->first == fid)
+      retval = lookup_cache->second;
+    else
+      {
+        ostrl_map::const_iterator iter = list.find (fid);
+
+        if (iter == list.end ())
+          err_invalid_file_id (fid, who);
+
+        retval = iter->second;
+        lookup_cache = iter;
+      }
+
+    return retval;
+  }
+
+  stream
+  stream_list::do_lookup (const octave_value& fid,
+                          const std::string& who) const
+  {
+    int i = get_file_number (fid);
+
+    return do_lookup (i, who);
+  }
+
+  int
+  stream_list::do_remove (int fid, const std::string& who)
+  {
+    // Can't remove stdin (std::cin), stdout (std::cout), or stderr (std::cerr).
+    if (fid < 3)
+      err_invalid_file_id (fid, who);
+
+    ostrl_map::iterator iter = list.find (fid);
+
+    if (iter == list.end ())
+      err_invalid_file_id (fid, who);
+
+    stream os = iter->second;
+    list.erase (iter);
+    lookup_cache = list.end ();
+
+    // FIXME: is this check redundant?
+    if (! os.is_valid ())
+      err_invalid_file_id (fid, who);
+
+    os.close ();
+
+    return 0;
+  }
+
+  int
+  stream_list::do_remove (const octave_value& fid, const std::string& who)
+  {
+    int retval = -1;
+
+    if (fid.is_string () && fid.string_value () == "all")
+      {
+        do_clear (false);
+
+        retval = 0;
+      }
+    else
+      {
+        int i = get_file_number (fid);
+
+        retval = do_remove (i, who);
+      }
+
     return retval;
-
-  octave_stream os;
-  if (lookup_cache != list.end () && lookup_cache->first == fid)
-    os = lookup_cache->second;
-  else
-    {
-      ostrl_map::const_iterator iter = list.find (fid);
-
-      if (iter == list.end ())
-        return retval;
-
-      os = iter->second;
-      lookup_cache = iter;
-    }
-
-  if (! os.is_valid ())
+  }
+
+  void
+  stream_list::do_clear (bool flush)
+  {
+    if (flush)
+      {
+        // Flush stdout and stderr.
+        list[1].flush ();
+        list[2].flush ();
+      }
+
+    for (ostrl_map::iterator iter = list.begin (); iter != list.end (); )
+      {
+        int fid = iter->first;
+        if (fid < 3)  // Don't delete stdin, stdout, stderr
+          {
+            iter++;
+            continue;
+          }
+
+        stream os = iter->second;
+
+        std::string name = os.name ();
+        std::transform (name.begin (), name.end (), name.begin (), tolower);
+
+        // FIXME: This test for gnuplot is hardly foolproof.
+        if (name.find ("gnuplot") != std::string::npos)
+          {
+            // Don't close down pipes to gnuplot
+            iter++;
+            continue;
+          }
+
+        // Normal file handle.  Close and delete from list.
+        if (os.is_valid ())
+          os.close ();
+
+        list.erase (iter++);
+      }
+
+    lookup_cache = list.end ();
+  }
+
+  string_vector
+  stream_list::do_get_info (int fid) const
+  {
+    string_vector retval (3);
+
+    if (fid < 0)
+      return retval;
+
+    stream os;
+    if (lookup_cache != list.end () && lookup_cache->first == fid)
+      os = lookup_cache->second;
+    else
+      {
+        ostrl_map::const_iterator iter = list.find (fid);
+
+        if (iter == list.end ())
+          return retval;
+
+        os = iter->second;
+        lookup_cache = iter;
+      }
+
+    if (! os.is_valid ())
+      return retval;
+
+    retval(0) = os.name ();
+    retval(1) = stream::mode_as_string (os.mode ());
+    retval(2) = octave::mach_info::float_format_as_string (os.float_format ());
+
     return retval;
-
-  retval(0) = os.name ();
-  retval(1) = octave_stream::mode_as_string (os.mode ());
-  retval(2) = octave::mach_info::float_format_as_string (os.float_format ());
-
-  return retval;
-}
-
-string_vector
-octave_stream_list::do_get_info (const octave_value& fid) const
-{
-  int conv_err = 0;
-
-  int int_fid = convert_to_valid_int (fid, conv_err);
-
-  if (conv_err)
-    ::error ("file id must be a file object or integer value");
-
-  return do_get_info (int_fid);
-}
-
-std::string
-octave_stream_list::do_list_open_files (void) const
-{
-  std::ostringstream buf;
-
-  buf << "\n"
-      << "  number  mode  arch       name\n"
-      << "  ------  ----  ----       ----\n";
-
-  for (const auto& fid_strm : list)
-    {
-      octave_stream os = fid_strm.second;
-
-      buf << "  "
-          << std::setiosflags (std::ios::right)
-          << std::setw (4) << fid_strm.first << "     "
+  }
+
+  string_vector
+  stream_list::do_get_info (const octave_value& fid) const
+  {
+    int conv_err = 0;
+
+    int int_fid = convert_to_valid_int (fid, conv_err);
+
+    if (conv_err)
+      ::error ("file id must be a file object or integer value");
+
+    return do_get_info (int_fid);
+  }
+
+  std::string
+  stream_list::do_list_open_files (void) const
+  {
+    std::ostringstream buf;
+
+    buf << "\n"
+        << "  number  mode  arch       name\n"
+        << "  ------  ----  ----       ----\n";
+
+    for (const auto& fid_strm : list)
+      {
+        stream os = fid_strm.second;
+
+        buf << "  "
+            << std::setiosflags (std::ios::right)
+            << std::setw (4) << fid_strm.first << "     "
           // reset necessary in addition to setiosflags since this is one stmt.
-          << std::resetiosflags (std::ios::adjustfield)
-          << std::setiosflags (std::ios::left)
-          << std::setw (3)
-          << octave_stream::mode_as_string (os.mode ())
-          << "  "
-          << std::setw (9)
-          << octave::mach_info::float_format_as_string (os.float_format ())
-          << "  "
-          << os.name () << "\n";
-    }
-
-  buf << "\n";
-
-  return buf.str ();
-}
-
-octave_value
-octave_stream_list::do_open_file_numbers (void) const
-{
-  Matrix retval (1, list.size (), 0.0);
-
-  int num_open = 0;
-
-  for (const auto& fid_strm : list)
-    {
-      // Skip stdin, stdout, and stderr.
-      if (fid_strm.first > 2 && fid_strm.second)
-        retval(0, num_open++) = fid_strm.first;
-    }
-
-  retval.resize ((num_open > 0), num_open);
-
-  return retval;
+            << std::resetiosflags (std::ios::adjustfield)
+            << std::setiosflags (std::ios::left)
+            << std::setw (3)
+            << stream::mode_as_string (os.mode ())
+            << "  "
+            << std::setw (9)
+            << octave::mach_info::float_format_as_string (os.float_format ())
+            << "  "
+            << os.name () << "\n";
+      }
+
+    buf << "\n";
+
+    return buf.str ();
+  }
+
+  octave_value
+  stream_list::do_open_file_numbers (void) const
+  {
+    Matrix retval (1, list.size (), 0.0);
+
+    int num_open = 0;
+
+    for (const auto& fid_strm : list)
+      {
+        // Skip stdin, stdout, and stderr.
+        if (fid_strm.first > 2 && fid_strm.second)
+          retval(0, num_open++) = fid_strm.first;
+      }
+
+    retval.resize ((num_open > 0), num_open);
+
+    return retval;
+  }
+
+  int
+  stream_list::do_get_file_number (const octave_value& fid) const
+  {
+    int retval = -1;
+
+    if (fid.is_string ())
+      {
+        std::string nm = fid.string_value ();
+
+        for (const auto& fid_strm : list)
+          {
+            // stdin, stdout, and stderr are unnamed.
+            if (fid_strm.first > 2)
+              {
+                stream os = fid_strm.second;
+
+                if (os && os.name () == nm)
+                  {
+                    retval = fid_strm.first;
+                    break;
+                  }
+              }
+          }
+      }
+    else
+      {
+        int conv_err = 0;
+
+        int int_fid = convert_to_valid_int (fid, conv_err);
+
+        if (conv_err)
+          ::error ("file id must be a file object, std::string, or integer value");
+
+        retval = int_fid;
+      }
+
+    return retval;
+  }
 }
-
-int
-octave_stream_list::do_get_file_number (const octave_value& fid) const
-{
-  int retval = -1;
-
-  if (fid.is_string ())
-    {
-      std::string nm = fid.string_value ();
-
-      for (const auto& fid_strm : list)
-        {
-          // stdin, stdout, and stderr are unnamed.
-          if (fid_strm.first > 2)
-            {
-              octave_stream os = fid_strm.second;
-
-              if (os && os.name () == nm)
-                {
-                  retval = fid_strm.first;
-                  break;
-                }
-            }
-        }
-    }
-  else
-    {
-      int conv_err = 0;
-
-      int int_fid = convert_to_valid_int (fid, conv_err);
-
-      if (conv_err)
-        ::error ("file id must be a file object, std::string, or integer value");
-
-      retval = int_fid;
-    }
-
-  return retval;
-}
-
diff --git a/libinterp/corefcn/oct-stream.h b/libinterp/corefcn/oct-stream.h
--- a/libinterp/corefcn/oct-stream.h
+++ b/libinterp/corefcn/oct-stream.h
@@ -20,465 +20,474 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_oct_stream_h)
 #define octave_oct_stream_h 1
 
 #include "octave-config.h"
 
+#include <ios>
 #include <iosfwd>
 #include <list>
 #include <map>
 #include <string>
 
-// These are only needed as arguments to private functions, so they
-// are also treated as private.
-
-class scanf_format_elt;
-class scanf_format_list;
-
-class printf_format_elt;
-class printf_format_list;
-
 // These only appear as reference arguments or return values.
 
 template <typename T> class Array;
 class Cell;
+class octave_value;
 class octave_value_list;
 class string_vector;
 
 #include "data-conv.h"
 #include "mach-info.h"
 #include "oct-refcount.h"
 
-#include "ov.h"
-
-// Provide an interface for Octave streams.
+namespace octave
+{
+  // These are only needed as arguments to private functions, so they
+  // are also treated as private.
 
-class
-OCTINTERP_API
-octave_base_stream
-{
-  friend class octave_stream;
+  class scanf_format_elt;
+  class scanf_format_list;
 
-public:
+  class printf_format_elt;
+  class printf_format_list;
+
+  // Provide an interface for Octave streams.
 
-  octave_base_stream (std::ios::openmode arg_md = std::ios::in | std::ios::out,
-                      octave::mach_info::float_format ff
-                        = octave::mach_info::native_float_format ())
-    : count (0), md (arg_md), flt_fmt (ff), fail (false), open_state (true),
+  class
+  OCTINTERP_API
+  base_stream
+  {
+    friend class stream;
+
+  public:
+
+    base_stream (std::ios::openmode arg_md = std::ios::in | std::ios::out,
+                 mach_info::float_format ff = mach_info::native_float_format ())
+      : count (0), md (arg_md), flt_fmt (ff), fail (false), open_state (true),
       errmsg ()
-  { }
-
-  // No copying!
-
-  octave_base_stream (const octave_base_stream&) = delete;
-
-  octave_base_stream& operator = (const octave_base_stream&) = delete;
+    { }
 
-  virtual ~octave_base_stream (void) = default;
+    // No copying!
 
-  // The remaining functions are not specific to input or output only,
-  // and must be provided by the derived classes.
+    base_stream (const base_stream&) = delete;
+
+    base_stream& operator = (const base_stream&) = delete;
 
-  // Position a stream at OFFSET relative to ORIGIN.
-
-  virtual int seek (off_t offset, int origin) = 0;
+    virtual ~base_stream (void) = default;
 
-  // Return current stream position.
+    // The remaining functions are not specific to input or output only,
+    // and must be provided by the derived classes.
 
-  virtual off_t tell (void) = 0;
+    // Position a stream at OFFSET relative to ORIGIN.
 
-  // Return TRUE if EOF has been reached on this stream.
+    virtual int seek (off_t offset, int origin) = 0;
 
-  virtual bool eof (void) const = 0;
+    // Return current stream position.
 
-  // The name of the file.
+    virtual off_t tell (void) = 0;
 
-  virtual std::string name (void) const = 0;
+    // Return TRUE if EOF has been reached on this stream.
+
+    virtual bool eof (void) const = 0;
 
-  // If the derived class provides this function and it returns a
-  // pointer to a valid istream, scanf(), read(), getl(), and gets()
-  // will automatically work for this stream.
+    // The name of the file.
 
-  virtual std::istream *input_stream (void) { return 0; }
+    virtual std::string name (void) const = 0;
 
-  // If the derived class provides this function and it returns a
-  // pointer to a valid ostream, flush(), write(), and printf() will
-  // automatically work for this stream.
+    // If the derived class provides this function and it returns a
+    // pointer to a valid istream, scanf(), read(), getl(), and gets()
+    // will automatically work for this stream.
 
-  virtual std::ostream *output_stream (void) { return 0; }
+    virtual std::istream *input_stream (void) { return 0; }
 
-  // Return TRUE if this stream is open.
+    // If the derived class provides this function and it returns a
+    // pointer to a valid ostream, flush(), write(), and printf() will
+    // automatically work for this stream.
 
-  bool is_open (void) const { return open_state; }
-
-  virtual void do_close (void) { }
+    virtual std::ostream *output_stream (void) { return 0; }
 
-  void close (void)
-  {
-    if (is_open ())
-      {
-        open_state = false;
-        do_close ();
-      }
-  }
+    // Return TRUE if this stream is open.
+
+    bool is_open (void) const { return open_state; }
+
+    virtual void do_close (void) { }
 
-  virtual int file_number (void) const
-  {
-    // Kluge alert!
+    void close (void)
+    {
+      if (is_open ())
+        {
+          open_state = false;
+          do_close ();
+        }
+    }
 
-    if (name () == "stdin")
-      return 0;
-    else if (name () == "stdout")
-      return 1;
-    else if (name () == "stderr")
-      return 2;
-    else
-      return -1;
-  }
+    virtual int file_number (void) const
+    {
+      // Kluge alert!
 
-  bool ok (void) const { return ! fail; }
-
-  // Return current error message for this stream.
+      if (name () == "stdin")
+        return 0;
+      else if (name () == "stdout")
+        return 1;
+      else if (name () == "stderr")
+        return 2;
+      else
+        return -1;
+    }
 
-  std::string error (bool clear, int& err_num);
+    bool ok (void) const { return ! fail; }
 
-protected:
+    // Return current error message for this stream.
 
-  int mode (void) const { return md; }
+    std::string error (bool clear, int& err_num);
 
-  octave::mach_info::float_format float_format (void) const { return flt_fmt; }
+  protected:
 
-  // Set current error state and set fail to TRUE.
+    int mode (void) const { return md; }
 
-  void error (const std::string& msg);
-  void error (const std::string& who, const std::string& msg);
+    mach_info::float_format float_format (void) const { return flt_fmt; }
 
-  // Clear any error message and set fail to FALSE.
+    // Set current error state and set fail to TRUE.
 
-  void clear (void);
+    void error (const std::string& msg);
+    void error (const std::string& who, const std::string& msg);
 
-  // Clear stream state.
+    // Clear any error message and set fail to FALSE.
 
-  void clearerr (void);
+    void clear (void);
+
+    // Clear stream state.
 
-private:
+    void clearerr (void);
 
-  // A reference count.
-  octave::refcount<octave_idx_type> count;
+  private:
 
-  // The permission bits for the file.  Should be some combination of
-  // std::ios::open_mode bits.
-  int md;
+    // A reference count.
+    refcount<octave_idx_type> count;
 
-  // Data format.
-  octave::mach_info::float_format flt_fmt;
+    // The permission bits for the file.  Should be some combination of
+    // std::ios::open_mode bits.
+    int md;
 
-  // TRUE if an error has occurred.
-  bool fail;
+    // Data format.
+    mach_info::float_format flt_fmt;
 
-  // TRUE if this stream is open.
-  bool open_state;
+    // TRUE if an error has occurred.
+    bool fail;
 
-  // Should contain error message if fail is TRUE.
-  std::string errmsg;
+    // TRUE if this stream is open.
+    bool open_state;
+
+    // Should contain error message if fail is TRUE.
+    std::string errmsg;
 
-  // Functions that are defined for all input streams (input streams
-  // are those that define is).
+    // Functions that are defined for all input streams (input streams
+    // are those that define is).
 
-  std::string do_gets (octave_idx_type max_len, bool& err, bool strip_newline,
-                       const std::string& who /* = "gets" */);
+    std::string do_gets (octave_idx_type max_len, bool& err, bool strip_newline,
+                         const std::string& who /* = "gets" */);
 
-  std::string getl (octave_idx_type max_len, bool& err,
-                    const std::string& who /* = "getl" */);
-  std::string gets (octave_idx_type max_len, bool& err,
-                    const std::string& who /* = "gets" */);
-  off_t skipl (off_t count, bool& err, const std::string& who /* = "skipl" */);
+    std::string getl (octave_idx_type max_len, bool& err,
+                      const std::string& who /* = "getl" */);
+    std::string gets (octave_idx_type max_len, bool& err,
+                      const std::string& who /* = "gets" */);
+    off_t skipl (off_t count, bool& err, const std::string& who /* = "skipl" */);
 
-  octave_value do_scanf (scanf_format_list& fmt_list, octave_idx_type nr,
-                         octave_idx_type nc,
-                         bool one_elt_size_spec, octave_idx_type& count,
-                         const std::string& who /* = "scanf" */);
+    octave_value do_scanf (scanf_format_list& fmt_list, octave_idx_type nr,
+                           octave_idx_type nc,
+                           bool one_elt_size_spec, octave_idx_type& count,
+                           const std::string& who /* = "scanf" */);
 
-  octave_value scanf (const std::string& fmt, const Array<double>& size,
-                      octave_idx_type& count, const std::string& who /* = "scanf" */);
+    octave_value scanf (const std::string& fmt, const Array<double>& size,
+                        octave_idx_type& count, const std::string& who /* = "scanf" */);
 
-  bool do_oscanf (const scanf_format_elt *elt, octave_value&,
-                  const std::string& who /* = "scanf" */);
-
-  octave_value_list oscanf (const std::string& fmt,
-                            const std::string& who /* = "scanf" */);
+    bool do_oscanf (const scanf_format_elt *elt, octave_value&,
+                    const std::string& who /* = "scanf" */);
 
-  octave_value do_textscan (const std::string& fmt, octave_idx_type ntimes,
-                            const octave_value_list& options,
-                            const std::string& who, octave_idx_type& count);
+    octave_value_list oscanf (const std::string& fmt,
+                              const std::string& who /* = "scanf" */);
 
-  // Functions that are defined for all output streams (output streams
-  // are those that define os).
+    octave_value do_textscan (const std::string& fmt, octave_idx_type ntimes,
+                              const octave_value_list& options,
+                              const std::string& who, octave_idx_type& count);
 
-  int flush (void);
+    // Functions that are defined for all output streams (output streams
+    // are those that define os).
+
+    int flush (void);
 
-  int do_numeric_printf_conv (std::ostream& os, const printf_format_elt *elt,
-                              int nsa, int sa_1, int sa_2,
-                              const octave_value& val,
-                              const std::string& who);
+    int do_numeric_printf_conv (std::ostream& os, const printf_format_elt *elt,
+                                int nsa, int sa_1, int sa_2,
+                                const octave_value& val,
+                                const std::string& who);
 
-  int do_printf (printf_format_list& fmt_list, const octave_value_list& args,
-                 const std::string& who /* = "printf" */);
+    int do_printf (printf_format_list& fmt_list, const octave_value_list& args,
+                   const std::string& who /* = "printf" */);
 
-  int printf (const std::string& fmt, const octave_value_list& args,
-              const std::string& who /* = "printf" */);
+    int printf (const std::string& fmt, const octave_value_list& args,
+                const std::string& who /* = "printf" */);
 
-  int puts (const std::string& s, const std::string& who /* = "puts" */);
+    int puts (const std::string& s, const std::string& who /* = "puts" */);
 
-  // We can always do this in terms of seek(), so the derived class
-  // only has to provide that.
+    // We can always do this in terms of seek(), so the derived class
+    // only has to provide that.
 
-  void invalid_operation (const std::string& who, const char *rw);
-};
+    void invalid_operation (const std::string& who, const char *rw);
+  };
 
-class
-OCTINTERP_API
-octave_stream
-{
-public:
+  class
+  OCTINTERP_API
+  stream
+  {
+  public:
 
-  octave_stream (octave_base_stream *bs = 0);
+    stream (base_stream *bs = 0);
 
-  ~octave_stream (void);
+    ~stream (void);
 
-  octave_stream (const octave_stream&);
+    stream (const stream&);
 
-  octave_stream& operator = (const octave_stream&);
+    stream& operator = (const stream&);
 
-  int flush (void);
+    int flush (void);
 
-  std::string getl (octave_idx_type max_len, bool& err,
-                    const std::string& who /* = "getl" */);
-  std::string getl (const octave_value& max_len, bool& err,
-                    const std::string& who /* = "getl" */);
+    std::string getl (octave_idx_type max_len, bool& err,
+                      const std::string& who /* = "getl" */);
+    std::string getl (const octave_value& max_len, bool& err,
+                      const std::string& who /* = "getl" */);
 
-  std::string gets (octave_idx_type max_len, bool& err,
-                    const std::string& who /* = "gets" */);
-  std::string gets (const octave_value& max_len, bool& err,
-                    const std::string& who /* = "gets" */);
+    std::string gets (octave_idx_type max_len, bool& err,
+                      const std::string& who /* = "gets" */);
+    std::string gets (const octave_value& max_len, bool& err,
+                      const std::string& who /* = "gets" */);
 
-  off_t skipl (off_t count, bool& err, const std::string& who /* = "skipl" */);
-  off_t skipl (const octave_value& count, bool& err,
-               const std::string& who /* = "skipl" */);
+    off_t skipl (off_t count, bool& err, const std::string& who /* = "skipl" */);
+    off_t skipl (const octave_value& count, bool& err,
+                 const std::string& who /* = "skipl" */);
 
-  int seek (off_t offset, int origin);
-  int seek (const octave_value& offset, const octave_value& origin);
+    int seek (off_t offset, int origin);
+    int seek (const octave_value& offset, const octave_value& origin);
 
-  off_t tell (void);
+    off_t tell (void);
 
-  int rewind (void);
+    int rewind (void);
 
-  bool is_open (void) const;
+    bool is_open (void) const;
 
-  void close (void);
+    void close (void);
 
-  octave_value read (const Array<double>& size, octave_idx_type block_size,
-                     oct_data_conv::data_type input_type,
-                     oct_data_conv::data_type output_type,
-                     octave_idx_type skip, octave::mach_info::float_format flt_fmt,
-                     octave_idx_type& count);
+    octave_value read (const Array<double>& size, octave_idx_type block_size,
+                       oct_data_conv::data_type input_type,
+                       oct_data_conv::data_type output_type,
+                       octave_idx_type skip, mach_info::float_format flt_fmt,
+                       octave_idx_type& count);
 
-  octave_idx_type write (const octave_value& data, octave_idx_type block_size,
-                         oct_data_conv::data_type output_type,
-                         octave_idx_type skip,
-                         octave::mach_info::float_format flt_fmt);
+    octave_idx_type write (const octave_value& data, octave_idx_type block_size,
+                           oct_data_conv::data_type output_type,
+                           octave_idx_type skip,
+                           mach_info::float_format flt_fmt);
 
-  bool write_bytes (const void *data, size_t n_elts);
+    bool write_bytes (const void *data, size_t n_elts);
 
-  bool skip_bytes (size_t n_elts);
+    bool skip_bytes (size_t n_elts);
 
-  template <typename T>
-  octave_idx_type write (const Array<T>& data, octave_idx_type block_size,
-                         oct_data_conv::data_type output_type,
-                         octave_idx_type skip,
-                         octave::mach_info::float_format flt_fmt);
+    template <typename T>
+      octave_idx_type write (const Array<T>& data, octave_idx_type block_size,
+                             oct_data_conv::data_type output_type,
+                             octave_idx_type skip,
+                             mach_info::float_format flt_fmt);
 
-  octave_value scanf (const std::string& fmt, const Array<double>& size,
-                      octave_idx_type& count, const std::string& who /* = "scanf" */);
+    octave_value scanf (const std::string& fmt, const Array<double>& size,
+                        octave_idx_type& count, const std::string& who /* = "scanf" */);
 
-  octave_value scanf (const octave_value& fmt, const Array<double>& size,
-                      octave_idx_type& count, const std::string& who /* = "scanf" */);
+    octave_value scanf (const octave_value& fmt, const Array<double>& size,
+                        octave_idx_type& count, const std::string& who /* = "scanf" */);
 
-  octave_value_list oscanf (const std::string& fmt,
-                            const std::string& who /* = "scanf" */);
+    octave_value_list oscanf (const std::string& fmt,
+                              const std::string& who /* = "scanf" */);
 
-  octave_value_list oscanf (const octave_value& fmt,
-                            const std::string& who /* = "scanf" */);
+    octave_value_list oscanf (const octave_value& fmt,
+                              const std::string& who /* = "scanf" */);
 
-  octave_value textscan (const std::string& fmt, octave_idx_type ntimes,
-                         const octave_value_list& options,
-                         const std::string& who, octave_idx_type& count);
+    octave_value textscan (const std::string& fmt, octave_idx_type ntimes,
+                           const octave_value_list& options,
+                           const std::string& who, octave_idx_type& count);
+
+    int printf (const std::string& fmt, const octave_value_list& args,
+                const std::string& who /* = "printf" */);
 
-  int printf (const std::string& fmt, const octave_value_list& args,
-              const std::string& who /* = "printf" */);
-
-  int printf (const octave_value& fmt, const octave_value_list& args,
-              const std::string& who /* = "printf" */);
+    int printf (const octave_value& fmt, const octave_value_list& args,
+                const std::string& who /* = "printf" */);
 
-  int puts (const std::string& s, const std::string& who /* = "puts" */);
-  int puts (const octave_value& s, const std::string& who /* = "puts" */);
+    int puts (const std::string& s, const std::string& who /* = "puts" */);
+    int puts (const octave_value& s, const std::string& who /* = "puts" */);
 
-  bool eof (void) const;
+    bool eof (void) const;
 
-  std::string error (bool clear, int& err_num);
+    std::string error (bool clear, int& err_num);
 
-  std::string error (bool clear = false)
-  {
-    int err_num;
-    return error (clear, err_num);
-  }
+    std::string error (bool clear = false)
+    {
+      int err_num;
+      return error (clear, err_num);
+    }
+
+    // Set the error message and state.
 
-  // Set the error message and state.
+    void error (const std::string& msg)
+    {
+      if (rep)
+        rep->error (msg);
+    }
 
-  void error (const std::string& msg)
-  {
-    if (rep)
-      rep->error (msg);
-  }
+    void error (const char *msg) { error (std::string (msg)); }
+
+    int file_number (void) { return rep ? rep->file_number () : -1; }
 
-  void error (const char *msg) { error (std::string (msg)); }
+    bool is_valid (void) const { return (rep != 0); }
 
-  int file_number (void) { return rep ? rep->file_number () : -1; }
+    bool ok (void) const { return rep && rep->ok (); }
 
-  bool is_valid (void) const { return (rep != 0); }
+    operator bool () const { return ok (); }
 
-  bool ok (void) const { return rep && rep->ok (); }
+    std::string name (void) const;
 
-  operator bool () const { return ok (); }
+    int mode (void) const;
 
-  std::string name (void) const;
+    mach_info::float_format float_format (void) const;
 
-  int mode (void) const;
+    static std::string mode_as_string (int mode);
 
-  octave::mach_info::float_format float_format (void) const;
-
-  static std::string mode_as_string (int mode);
+    std::istream *input_stream (void)
+    {
+      return rep ? rep->input_stream () : 0;
+    }
 
-  std::istream *input_stream (void)
-  {
-    return rep ? rep->input_stream () : 0;
-  }
+    std::ostream *output_stream (void)
+    {
+      return rep ? rep->output_stream () : 0;
+    }
 
-  std::ostream *output_stream (void)
-  {
-    return rep ? rep->output_stream () : 0;
-  }
+    void clearerr (void) { if (rep) rep->clearerr (); }
+
+  private:
 
-  void clearerr (void) { if (rep) rep->clearerr (); }
+    // The actual representation of this stream.
+    base_stream *rep;
 
-private:
+    bool stream_ok (bool clear = true) const
+    {
+      bool retval = true;
 
-  // The actual representation of this stream.
-  octave_base_stream *rep;
+      if (rep)
+        {
+          if (clear)
+            rep->clear ();
+        }
+      else
+        retval = false;
 
-  bool stream_ok (bool clear = true) const
-  {
-    bool retval = true;
+      return retval;
+    }
 
-    if (rep)
-      {
-        if (clear)
-          rep->clear ();
-      }
-    else
-      retval = false;
+    void invalid_operation (const std::string& who, const char *rw)
+    {
+      if (rep)
+        rep->invalid_operation (who, rw);
+    }
 
-    return retval;
-  }
+    octave_value
+    finalize_read (std::list<void *>& input_buf_list,
+                   octave_idx_type input_buf_elts,
+                   octave_idx_type elts_read,
+                   octave_idx_type nr, octave_idx_type nc,
+                   oct_data_conv::data_type input_type,
+                   oct_data_conv::data_type output_type,
+                   mach_info::float_format ffmt);
+  };
 
-  void invalid_operation (const std::string& who, const char *rw)
+  class
+  OCTINTERP_API
+  stream_list
   {
-    if (rep)
-      rep->invalid_operation (who, rw);
-  }
+  protected:
+
+    stream_list (void) : list (), lookup_cache (list.end ()) { }
 
-  octave_value
-  finalize_read (std::list<void *>& input_buf_list,
-                 octave_idx_type input_buf_elts,
-                 octave_idx_type elts_read,
-                 octave_idx_type nr, octave_idx_type nc,
-                 oct_data_conv::data_type input_type,
-                 oct_data_conv::data_type output_type,
-                 octave::mach_info::float_format ffmt);
-};
+  public:
+
+    ~stream_list (void) = default;
 
-class
-OCTINTERP_API
-octave_stream_list
-{
-protected:
+    static bool instance_ok (void);
 
-  octave_stream_list (void) : list (), lookup_cache (list.end ()) { }
+    static int insert (stream& os);
 
-public:
-
-  ~octave_stream_list (void) = default;
+    static stream lookup (int fid, const std::string& who = "");
 
-  static bool instance_ok (void);
-
-  static int insert (octave_stream& os);
+    static stream lookup (const octave_value& fid, const std::string& who = "");
 
-  static octave_stream
-  lookup (int fid, const std::string& who = "");
+    static int remove (int fid, const std::string& who = "");
+    static int remove (const octave_value& fid, const std::string& who = "");
 
-  static octave_stream
-  lookup (const octave_value& fid, const std::string& who = "");
+    static void clear (bool flush = true);
 
-  static int remove (int fid, const std::string& who = "");
-  static int remove (const octave_value& fid,
-                     const std::string& who = "");
+    static string_vector get_info (int fid);
+    static string_vector get_info (const octave_value& fid);
 
-  static void clear (bool flush = true);
+    static std::string list_open_files (void);
+
+    static octave_value open_file_numbers (void);
+
+    static int get_file_number (const octave_value& fid);
 
-  static string_vector get_info (int fid);
-  static string_vector get_info (const octave_value& fid);
+  private:
 
-  static std::string list_open_files (void);
+    typedef std::map<int, stream> ostrl_map;
 
-  static octave_value open_file_numbers (void);
+    ostrl_map list;
 
-  static int get_file_number (const octave_value& fid);
+    mutable ostrl_map::const_iterator lookup_cache;
 
-private:
+    static stream_list *instance;
 
-  typedef std::map<int, octave_stream> ostrl_map;
+    static void cleanup_instance (void) { delete instance; instance = 0; }
 
-  ostrl_map list;
+    int do_insert (stream& os);
 
-  mutable ostrl_map::const_iterator lookup_cache;
+    stream do_lookup (int fid, const std::string& who = "") const;
+    stream do_lookup (const octave_value& fid,
+                      const std::string& who = "") const;
 
-  static octave_stream_list *instance;
-
-  static void cleanup_instance (void) { delete instance; instance = 0; }
+    int do_remove (int fid, const std::string& who = "");
+    int do_remove (const octave_value& fid, const std::string& who = "");
 
-  int do_insert (octave_stream& os);
+    void do_clear (bool flush = true);
 
-  octave_stream do_lookup (int fid,
-                           const std::string& who = "") const;
-  octave_stream do_lookup (const octave_value& fid,
-                           const std::string& who = "") const;
+    string_vector do_get_info (int fid) const;
+    string_vector do_get_info (const octave_value& fid) const;
+
+    std::string do_list_open_files (void) const;
 
-  int do_remove (int fid, const std::string& who = "");
-  int do_remove (const octave_value& fid,
-                 const std::string& who = "");
+    octave_value do_open_file_numbers (void) const;
 
-  void do_clear (bool flush = true);
+    int do_get_file_number (const octave_value& fid) const;
+  };
+}
+
+#if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
-  string_vector do_get_info (int fid) const;
-  string_vector do_get_info (const octave_value& fid) const;
-
-  std::string do_list_open_files (void) const;
+OCTAVE_DEPRECATED ("use 'octave::base_stream' instead")
+typedef octave::base_stream octave_base_stream;
 
-  octave_value do_open_file_numbers (void) const;
+OCTAVE_DEPRECATED ("use 'octave::stream' instead")
+typedef octave::stream octave_stream;
 
-  int do_get_file_number (const octave_value& fid) const;
-};
+OCTAVE_DEPRECATED ("use 'octave::stream_list' instead")
+typedef octave::stream_list octave_stream_list;
 
 #endif
 
+#endif
diff --git a/libinterp/corefcn/oct-strstrm.cc b/libinterp/corefcn/oct-strstrm.cc
--- a/libinterp/corefcn/oct-strstrm.cc
+++ b/libinterp/corefcn/oct-strstrm.cc
@@ -26,46 +26,46 @@ along with Octave; see the file COPYING.
 
 #include "oct-strstrm.h"
 
 // Position a stream at OFFSET relative to ORIGIN.
 
 int
 octave_base_strstream::seek (off_t, int)
 {
-  // Note: error is inherited from octave_base_stream, not ::error.
+  // Note: error is inherited from octave::base_stream, not ::error.
   // This error function does not halt execution so "return ..." must exist.
   error ("fseek: invalid operation");
   return -1;
 }
 
 // Return current stream position.
 
 off_t
 octave_base_strstream::tell (void)
 {
-  // Note: error is inherited from octave_base_stream, not ::error.
+  // Note: error is inherited from octave::base_stream, not ::error.
   // This error function does not halt execution so "return ..." must exist.
   error ("ftell: invalid operation");
   return -1;
 }
 
-octave_stream
+octave::stream
 octave_istrstream::create (const char *data, std::ios::openmode arg_md,
                            octave::mach_info::float_format flt_fmt)
 {
-  return octave_stream (new octave_istrstream (data, arg_md, flt_fmt));
+  return octave::stream (new octave_istrstream (data, arg_md, flt_fmt));
 }
 
-octave_stream
+octave::stream
 octave_istrstream::create (const std::string& data, std::ios::openmode arg_md,
                            octave::mach_info::float_format flt_fmt)
 {
-  return octave_stream (new octave_istrstream (data, arg_md, flt_fmt));
+  return octave::stream (new octave_istrstream (data, arg_md, flt_fmt));
 }
 
-octave_stream
+octave::stream
 octave_ostrstream::create (std::ios::openmode arg_md,
                            octave::mach_info::float_format flt_fmt)
 {
-  return octave_stream (new octave_ostrstream (arg_md, flt_fmt));
+  return octave::stream (new octave_ostrstream (arg_md, flt_fmt));
 }
 
diff --git a/libinterp/corefcn/oct-strstrm.h b/libinterp/corefcn/oct-strstrm.h
--- a/libinterp/corefcn/oct-strstrm.h
+++ b/libinterp/corefcn/oct-strstrm.h
@@ -26,24 +26,24 @@ along with Octave; see the file COPYING.
 #include "octave-config.h"
 
 #include <string>
 #include <sstream>
 
 #include "oct-stream.h"
 
 class
-octave_base_strstream : public octave_base_stream
+octave_base_strstream : public octave::base_stream
 {
 public:
 
   octave_base_strstream (std::ios::openmode m = std::ios::out,
                          octave::mach_info::float_format ff
                            = octave::mach_info::native_float_format ())
-    : octave_base_stream (m, ff) { }
+    : octave::base_stream (m, ff) { }
 
   // No copying!
 
   octave_base_strstream (const octave_base_strstream&) = delete;
 
   octave_base_strstream& operator = (const octave_base_strstream&) = delete;
 
 protected:
@@ -96,22 +96,22 @@ public:
 
 protected:
 
   ~octave_istrstream (void) = default;
 
 public:
 
 
-  static octave_stream
+  static octave::stream
   create (const char *data, std::ios::openmode arg_md = std::ios::out,
           octave::mach_info::float_format ff
             = octave::mach_info::native_float_format ());
 
-  static octave_stream
+  static octave::stream
   create (const std::string& data, std::ios::openmode arg_md = std::ios::out,
           octave::mach_info::float_format ff
             = octave::mach_info::native_float_format ());
 
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const { return is.eof (); }
 
@@ -149,17 +149,17 @@ public:
   octave_ostrstream& operator = (const octave_ostrstream&) = delete;
 
 protected:
 
   ~octave_ostrstream (void) = default;
 
 public:
 
-  static octave_stream
+  static octave::stream
   create (std::ios::openmode arg_md = std::ios::out,
           octave::mach_info::float_format ff
             = octave::mach_info::native_float_format ());
 
   // Return nonzero if EOF has been reached on this stream.
 
   bool eof (void) const { return os.eof (); }
 
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -3547,19 +3547,19 @@ fdisp (stdout, "The value of pi is:"), f
 @noindent
 Note that the output from @code{fdisp} always ends with a newline.
 @seealso{disp}
 @end deftypefn */)
 {
   if (args.length () != 2)
     print_usage ();
 
-  int fid = octave_stream_list::get_file_number (args(0));
-
-  octave_stream os = octave_stream_list::lookup (fid, "fdisp");
+  int fid = octave::stream_list::get_file_number (args(0));
+
+  octave::stream os = octave::stream_list::lookup (fid, "fdisp");
 
   std::ostream *osp = os.output_stream ();
 
   octave_value arg = args(1);
 
   if (osp)
     arg.print (*osp);
   else
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -114,19 +114,19 @@ If successful, @var{fid} is greater than
 Otherwise, @var{fid} is negative and @var{msg} contains a system-dependent
 error message.
 @seealso{fopen, fclose, fcntl}
 @end deftypefn */)
 {
   if (args.length () != 2)
     print_usage ();
 
-  octave_stream old_stream = octave_stream_list::lookup (args(0), "dup2");
+  octave::stream old_stream = octave::stream_list::lookup (args(0), "dup2");
 
-  octave_stream new_stream = octave_stream_list::lookup (args(1), "dup2");
+  octave::stream new_stream = octave::stream_list::lookup (args(1), "dup2");
 
   int i_old = old_stream.file_number ();
   int i_new = new_stream.file_number ();
 
   if (i_old >= 0 && i_new >= 0)
     {
       std::string msg;
 
@@ -285,26 +285,24 @@ exit status, it will linger until Octave
   pid = octave::sys::popen2 (exec_file, arg_list, sync_mode, filedesc, msg);
 
   if (pid < 0)
     error (msg.c_str ());
 
   FILE *ifile = fdopen (filedesc[1], "r");
   FILE *ofile = fdopen (filedesc[0], "w");
 
-  octave_stream is = octave_stdiostream::create (exec_file + "-in",
-                                                 ifile,
-                                                 std::ios::in);
+  octave::stream is
+    = octave_stdiostream::create (exec_file + "-in", ifile, std::ios::in);
 
-  octave_stream os = octave_stdiostream::create (exec_file + "-out",
-                                                 ofile,
-                                                 std::ios::out);
+  octave::stream os
+    = octave_stdiostream::create (exec_file + "-out", ofile, std::ios::out);
 
-  return ovl (octave_stream_list::insert (os),
-              octave_stream_list::insert (is),
+  return ovl (octave::stream_list::insert (os),
+              octave::stream_list::insert (is),
               pid);
 }
 
 /*
 
 %!test  # UNIX-style test
 %! if (isunix () || ismac ())
 %!   [in, out, pid] = popen2 ("sort", "-r");
@@ -428,17 +426,17 @@ If successful, @var{err} is 0 and @var{m
 @var{err} is nonzero and @var{msg} contains a system-dependent error
 message.
 @seealso{fopen, dup2}
 @end deftypefn */)
 {
   if (args.length () != 3)
     print_usage ();
 
-  octave_stream strm = octave_stream_list::lookup (args(0), "fcntl");
+  octave::stream strm = octave::stream_list::lookup (args(0), "fcntl");
 
   int fid = strm.file_number ();
 
   // FIXME: Do we want to use xint_value and throw a warning message
   //        if input validation fails?
   int req = args(1).int_value (true);
   int arg = args(2).int_value (true);
 
@@ -737,24 +735,24 @@ error message.
 
   if (status < 0)
     return ovl (-1, -1, -1, msg);
   else
     {
       FILE *ifile = fdopen (fid[0], "r");
       FILE *ofile = fdopen (fid[1], "w");
 
-      octave_stream is
+      octave::stream is
         = octave_stdiostream::create ("pipe-in", ifile, std::ios::in);
 
-      octave_stream os
+      octave::stream os
         = octave_stdiostream::create ("pipe-out", ofile, std::ios::out);
 
-      return ovl (octave_stream_list::insert (is),
-                  octave_stream_list::insert (os),
+      return ovl (octave::stream_list::insert (is),
+                  octave::stream_list::insert (os),
                   status,
                   msg);
     }
 }
 
 DEFUNX ("stat", Fstat, args, ,
         doc: /* -*- texinfo -*-
 @deftypefn  {} {[@var{info}, @var{err}, @var{msg}] =} stat (@var{file})
@@ -853,17 +851,17 @@ For example:
 {
   if (args.length () != 1)
     print_usage ();
 
   octave_value_list retval;
 
   if (args(0).is_scalar_type ())
     {
-      int fid = octave_stream_list::get_file_number (args(0));
+      int fid = octave::stream_list::get_file_number (args(0));
 
       octave::sys::file_fstat fs (fid);
 
       retval = mk_stat_result (fs);
     }
   else
     {
       std::string fname = args(0).xstring_value ("stat: NAME must be a string");
diff --git a/libinterp/octave-value/ov-base-diag.cc b/libinterp/octave-value/ov-base-diag.cc
--- a/libinterp/octave-value/ov-base-diag.cc
+++ b/libinterp/octave-value/ov-base-diag.cc
@@ -537,17 +537,17 @@ template <typename DMT, typename MT>
 void
 octave_base_diag<DMT, MT>::print (std::ostream& os, bool pr_as_read_syntax)
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 template <typename DMT, typename MT>
 int
-octave_base_diag<DMT, MT>::write (octave_stream& os, int block_size,
+octave_base_diag<DMT, MT>::write (octave::stream& os, int block_size,
                                   oct_data_conv::data_type output_type,
                                   int skip,
                                   octave::mach_info::float_format flt_fmt) const
 {
   return to_dense ().write (os, block_size, output_type, skip, flt_fmt);
 }
 
 template <typename DMT, typename MT>
diff --git a/libinterp/octave-value/ov-base-diag.h b/libinterp/octave-value/ov-base-diag.h
--- a/libinterp/octave-value/ov-base-diag.h
+++ b/libinterp/octave-value/ov-base-diag.h
@@ -199,17 +199,17 @@ public:
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const;
 
   mxArray *as_mxArray (void) const;
 
   bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false);
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -1013,17 +1013,17 @@ octave_base_value::save_hdf5 (octave_hdf
 
 bool
 octave_base_value::load_hdf5 (octave_hdf5_id, const char *)
 {
   err_wrong_type_arg ("octave_base_value::load_binary()", type_name ());
 }
 
 int
-octave_base_value::write (octave_stream&, int, oct_data_conv::data_type,
+octave_base_value::write (octave::stream&, int, oct_data_conv::data_type,
                           int, octave::mach_info::float_format) const
 {
   err_wrong_type_arg ("octave_base_value::write()", type_name ());
 }
 
 mxArray *
 octave_base_value::as_mxArray (void) const
 {
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -34,24 +34,24 @@ along with Octave; see the file COPYING.
 
 #include "Range.h"
 #include "data-conv.h"
 #include "mx-base.h"
 #include "str-vec.h"
 
 #include "error.h"
 #include "oct-hdf5-types.h"
+#include "oct-stream.h"
 
 class Cell;
 class mxArray;
 class octave_map;
 class octave_scalar_map;
 class octave_value;
 class octave_value_list;
-class octave_stream;
 class octave_function;
 class octave_user_function;
 class octave_user_script;
 class octave_user_code;
 class octave_fcn_handle;
 class octave_fcn_inline;
 class octave_value_list;
 class octave_lvalue;
@@ -663,17 +663,17 @@ public:
 
   virtual bool
   save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   virtual bool
   load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
   virtual int
-  write (octave_stream& os, int block_size,
+  write (octave::stream& os, int block_size,
          oct_data_conv::data_type output_type, int skip,
          octave::mach_info::float_format flt_fmt) const;
 
   virtual void *mex_get_data (void) const { return 0; }
 
   virtual octave_idx_type *mex_get_ir (void) const { return 0; }
 
   virtual octave_idx_type *mex_get_jc (void) const { return 0; }
diff --git a/libinterp/octave-value/ov-bool-mat.h b/libinterp/octave-value/ov-bool-mat.h
--- a/libinterp/octave-value/ov-bool-mat.h
+++ b/libinterp/octave-value/ov-bool-mat.h
@@ -219,17 +219,17 @@ public:
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
diff --git a/libinterp/octave-value/ov-bool.h b/libinterp/octave-value/ov-bool.h
--- a/libinterp/octave-value/ov-bool.h
+++ b/libinterp/octave-value/ov-bool.h
@@ -232,17 +232,17 @@ public:
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   {
     return os.write (bool_array_value (), block_size, output_type,
                      skip, flt_fmt);
   }
 
   mxArray *as_mxArray (void) const;
diff --git a/libinterp/octave-value/ov-complex.h b/libinterp/octave-value/ov-complex.h
--- a/libinterp/octave-value/ov-complex.h
+++ b/libinterp/octave-value/ov-complex.h
@@ -175,17 +175,17 @@ public:
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   {
     // Yes, for compatibility, we drop the imaginary part here.
     return os.write (array_value (true), block_size, output_type,
                      skip, flt_fmt);
   }
 
diff --git a/libinterp/octave-value/ov-cx-mat.h b/libinterp/octave-value/ov-cx-mat.h
--- a/libinterp/octave-value/ov-cx-mat.h
+++ b/libinterp/octave-value/ov-cx-mat.h
@@ -159,17 +159,17 @@ public:
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   {
     // Yes, for compatibility, we drop the imaginary part here.
     return os.write (matrix_value (true), block_size, output_type,
                      skip, flt_fmt);
   }
 
diff --git a/libinterp/octave-value/ov-cx-sparse.h b/libinterp/octave-value/ov-cx-sparse.h
--- a/libinterp/octave-value/ov-cx-sparse.h
+++ b/libinterp/octave-value/ov-cx-sparse.h
@@ -125,17 +125,17 @@ public:
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const
   { return matrix; }
 
   SparseBoolMatrix sparse_bool_matrix_value (bool warn = false) const;
 
   octave_value as_double (void) const;
 
 #if 0
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   {
     // Yes, for compatibility, we drop the imaginary part here.
     return os.write (matrix_value (true), block_size, output_type,
                      skip, flt_fmt);
   }
 #endif
diff --git a/libinterp/octave-value/ov-float.h b/libinterp/octave-value/ov-float.h
--- a/libinterp/octave-value/ov-float.h
+++ b/libinterp/octave-value/ov-float.h
@@ -247,17 +247,17 @@ public:
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   {
     return os.write (array_value (), block_size, output_type,
                      skip, flt_fmt);
   }
 
   mxArray *as_mxArray (void) const;
diff --git a/libinterp/octave-value/ov-flt-complex.h b/libinterp/octave-value/ov-flt-complex.h
--- a/libinterp/octave-value/ov-flt-complex.h
+++ b/libinterp/octave-value/ov-flt-complex.h
@@ -171,17 +171,17 @@ public:
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   {
     // Yes, for compatibility, we drop the imaginary part here.
     return os.write (array_value (true), block_size, output_type,
                      skip, flt_fmt);
   }
 
diff --git a/libinterp/octave-value/ov-flt-cx-mat.h b/libinterp/octave-value/ov-flt-cx-mat.h
--- a/libinterp/octave-value/ov-flt-cx-mat.h
+++ b/libinterp/octave-value/ov-flt-cx-mat.h
@@ -155,17 +155,17 @@ public:
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   {
     // Yes, for compatibility, we drop the imaginary part here.
     return os.write (matrix_value (true), block_size, output_type,
                      skip, flt_fmt);
   }
 
diff --git a/libinterp/octave-value/ov-flt-re-mat.h b/libinterp/octave-value/ov-flt-re-mat.h
--- a/libinterp/octave-value/ov-flt-re-mat.h
+++ b/libinterp/octave-value/ov-flt-re-mat.h
@@ -203,17 +203,17 @@ public:
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
diff --git a/libinterp/octave-value/ov-intx.h b/libinterp/octave-value/ov-intx.h
--- a/libinterp/octave-value/ov-intx.h
+++ b/libinterp/octave-value/ov-intx.h
@@ -299,17 +299,17 @@ public:
     matrix_ref ().changesign ();
   }
 
   idx_vector index_vector (bool /* require_integers */ = false) const
   {
     return idx_cache ? *idx_cache : set_idx_cache (idx_vector (matrix));
   }
 
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
@@ -606,17 +606,17 @@ public:
 
   void decrement (void)
   {
     scalar -= OCTAVE_INT_T (1);
   }
 
   idx_vector index_vector (bool /* require_integers */ = false) const { return idx_vector (scalar); }
 
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, octave_idx_type skip,
              octave::mach_info::float_format flt_fmt) const
   {
     return os.write (OCTAVE_VALUE_INT_NDARRAY_EXTRACTOR_FUNCTION (),
                      block_size, output_type, skip, flt_fmt);
   }
 
   // Unsafe.  This function exists to support the MEX interface.
diff --git a/libinterp/octave-value/ov-lazy-idx.h b/libinterp/octave-value/ov-lazy-idx.h
--- a/libinterp/octave-value/ov-lazy-idx.h
+++ b/libinterp/octave-value/ov-lazy-idx.h
@@ -196,17 +196,17 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   {
     return make_value ().write (os, block_size, output_type, skip, flt_fmt);
   }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
diff --git a/libinterp/octave-value/ov-perm.cc b/libinterp/octave-value/ov-perm.cc
--- a/libinterp/octave-value/ov-perm.cc
+++ b/libinterp/octave-value/ov-perm.cc
@@ -431,17 +431,17 @@ octave_perm_matrix::print_as_scalar (voi
 void
 octave_perm_matrix::print (std::ostream& os, bool pr_as_read_syntax)
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
 }
 
 int
-octave_perm_matrix::write (octave_stream& os, int block_size,
+octave_perm_matrix::write (octave::stream& os, int block_size,
                            oct_data_conv::data_type output_type, int skip,
                            octave::mach_info::float_format flt_fmt) const
 {
   return to_dense ().write (os, block_size, output_type, skip, flt_fmt);
 }
 
 void
 octave_perm_matrix::print_info (std::ostream& os,
diff --git a/libinterp/octave-value/ov-perm.h b/libinterp/octave-value/ov-perm.h
--- a/libinterp/octave-value/ov-perm.h
+++ b/libinterp/octave-value/ov-perm.h
@@ -213,17 +213,17 @@ public:
 
   bool load_ascii (std::istream& is);
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const;
 
   mxArray *as_mxArray (void) const;
 
   bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false);
diff --git a/libinterp/octave-value/ov-range.h b/libinterp/octave-value/ov-range.h
--- a/libinterp/octave-value/ov-range.h
+++ b/libinterp/octave-value/ov-range.h
@@ -278,22 +278,22 @@ public:
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   {
     // FIXME: could be more memory efficient by having a
-    // special case of the octave_stream::write method for ranges.
+    // special case of the octave::stream::write method for ranges.
 
     return os.write (matrix_value (), block_size, output_type, skip, flt_fmt);
   }
 
   mxArray *as_mxArray (void) const;
 
   octave_value map (unary_mapper_t umap) const
   {
diff --git a/libinterp/octave-value/ov-re-mat.h b/libinterp/octave-value/ov-re-mat.h
--- a/libinterp/octave-value/ov-re-mat.h
+++ b/libinterp/octave-value/ov-re-mat.h
@@ -227,17 +227,17 @@ public:
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
diff --git a/libinterp/octave-value/ov-re-sparse.h b/libinterp/octave-value/ov-re-sparse.h
--- a/libinterp/octave-value/ov-re-sparse.h
+++ b/libinterp/octave-value/ov-re-sparse.h
@@ -132,17 +132,17 @@ public:
 
   SparseBoolMatrix sparse_bool_matrix_value (bool warn = false) const;
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   octave_value as_double (void) const;
 
 #if 0
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 #endif
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap,
diff --git a/libinterp/octave-value/ov-scalar.h b/libinterp/octave-value/ov-scalar.h
--- a/libinterp/octave-value/ov-scalar.h
+++ b/libinterp/octave-value/ov-scalar.h
@@ -250,17 +250,17 @@ public:
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   {
     return os.write (array_value (), block_size, output_type,
                      skip, flt_fmt);
   }
 
   mxArray *as_mxArray (void) const;
diff --git a/libinterp/octave-value/ov-str-mat.h b/libinterp/octave-value/ov-str-mat.h
--- a/libinterp/octave-value/ov-str-mat.h
+++ b/libinterp/octave-value/ov-str-mat.h
@@ -156,17 +156,17 @@ public:
 
   bool load_binary (std::istream& is, bool swap,
                     octave::mach_info::float_format fmt);
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name);
 
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const
   { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
 protected:
 
   octave_value do_index_op_internal (const octave_value_list& idx,
                                      bool resize_ok, char type = '"');
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2184,17 +2184,17 @@ octave_value::make_storable_value (void)
         delete rep;
       rep = rc;
     }
   else
     maybe_economize ();
 }
 
 int
-octave_value::write (octave_stream& os, int block_size,
+octave_value::write (octave::stream& os, int block_size,
                      oct_data_conv::data_type output_type, int skip,
                      octave::mach_info::float_format flt_fmt) const
 {
   return rep->write (os, block_size, output_type, skip, flt_fmt);
 }
 
 OCTAVE_NORETURN static void
 err_binary_op (const std::string& on, const std::string& tn1,
diff --git a/libinterp/octave-value/ov.h b/libinterp/octave-value/ov.h
--- a/libinterp/octave-value/ov.h
+++ b/libinterp/octave-value/ov.h
@@ -32,33 +32,32 @@ along with Octave; see the file COPYING.
 #include <string>
 #include <list>
 
 #include "Range.h"
 #include "data-conv.h"
 #include "idx-vector.h"
 #include "mach-info.h"
 #include "mx-base.h"
+#include "oct-sort.h"
 #include "oct-time.h"
 #include "str-vec.h"
 
-#include "oct-sort.h"
-
 class Cell;
 class mxArray;
 class octave_map;
 class octave_scalar_map;
-class octave_stream;
 class octave_function;
 class octave_user_function;
 class octave_fcn_handle;
 class octave_fcn_inline;
 class octave_value_list;
 class octave_lvalue;
 
+#include "oct-stream.h"
 #include "ov-base.h"
 
 // Forward declarations of friend functions that have default arguments.
 
 OCTINTERP_API octave_value do_colon_op (const octave_value& base,
                                         const octave_value& limit,
                                         bool is_for_cmd_expr = false);
 
@@ -1287,17 +1286,17 @@ public:
 
   bool save_hdf5 (octave_hdf5_id loc_id, const char *name,
                   bool save_as_floats)
   { return rep->save_hdf5 (loc_id, name, save_as_floats); }
 
   bool load_hdf5 (octave_hdf5_id loc_id, const char *name)
   { return rep->load_hdf5 (loc_id, name); }
 
-  int write (octave_stream& os, int block_size,
+  int write (octave::stream& os, int block_size,
              oct_data_conv::data_type output_type, int skip,
              octave::mach_info::float_format flt_fmt) const;
 
   octave_base_value *internal_rep (void) const { return rep; }
 
   // Unsafe.  These functions exist to support the MEX interface.
   // You should not use them anywhere else.
   void *mex_get_data (void) const { return rep->mex_get_data (); }
