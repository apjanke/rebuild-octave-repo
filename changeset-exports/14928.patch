# HG changeset patch
# User Max Brister <max@2bass.com>
# Date 1338595723 18000
#      Fri Jun 01 19:08:43 2012 -0500
# Node ID 39d52aa37a087e525a19739b93d4c5c64891317f
# Parent  3b40dbc145722de93c348cd8e050dff6ea4b42e5
Use standard SSA construction algorithm, and support break/continue

diff --git a/build-aux/mkinstalldirs b/build-aux/mkinstalldirs
--- a/build-aux/mkinstalldirs
+++ b/build-aux/mkinstalldirs
@@ -1,12 +1,12 @@
 #! /bin/sh
 # mkinstalldirs --- make directory hierarchy
 
-scriptversion=2012-05-25.20; # UTC
+scriptversion=2009-04-28.21; # UTC
 
 # Original author: Noah Friedman <friedman@prep.ai.mit.edu>
 # Created: 1993-05-16
 # Public domain.
 #
 # This file is maintained in Automake, please report
 # bugs to <bug-automake@gnu.org> or send patches to
 # <automake-patches@gnu.org>.
@@ -76,19 +76,19 @@ esac
 # from a parallel make.  We use --version in the probe to restrict
 # ourselves to GNU mkdir, which is thread-safe.
 case $dirmode in
   '')
     if mkdir -p --version . >/dev/null 2>&1 && test ! -d ./--version; then
       echo "mkdir -p -- $*"
       exec mkdir -p -- "$@"
     else
-      # On NextStep and OpenStep, the `mkdir' command does not
+      # On NextStep and OpenStep, the 'mkdir' command does not
       # recognize any option.  It will interpret all options as
-      # directories to create, and then abort because `.' already
+      # directories to create, and then abort because '.' already
       # exists.
       test -d ./-p && rmdir ./-p
       test -d ./--version && rmdir ./--version
     fi
     ;;
   *)
     if mkdir -m "$dirmode" -p --version . >/dev/null 2>&1 &&
        test ! -d ./--version; then
diff --git a/src/pt-jit.cc b/src/pt-jit.cc
--- a/src/pt-jit.cc
+++ b/src/pt-jit.cc
@@ -85,16 +85,23 @@ fail (void)
 }
 
 static void
 fail (const std::string& reason)
 {
   throw jit_fail_exception (reason);
 }
 
+std::ostream& jit_print (std::ostream& os, jit_type *atype)
+{
+  if (! atype)
+    return os << "null";
+  return os << atype->name ();
+}
+
 // function that jit code calls
 extern "C" void
 octave_jit_print_any (const char *name, octave_base_value *obv)
 {
   obv->print_with_name (octave_stdout, name, true);
 }
 
 extern "C" void
@@ -613,41 +620,95 @@ jit_block *
 jit_use::user_parent (void) const
 {
   return muser->parent ();
 }
 
 // -------------------- jit_value --------------------
 jit_value::~jit_value (void)
 {
+  replace_with (0);
+}
+
+void
+jit_value::replace_with (jit_value *value)
+{
   while (use_head)
     {
       jit_instruction *user = use_head->user ();
       size_t idx = use_head->index ();
-      user->stash_argument (idx, 0);
+      if (idx < user->argument_count ())
+        user->stash_argument (idx, value);
+      else
+        user->stash_tag (0);
     }
 }
 
 #define JIT_METH(clname)                                \
   void                                                  \
   jit_ ## clname::accept (jit_ir_walker& walker)        \
   {                                                     \
     walker.visit (*this);                               \
   }
 
 JIT_VISIT_IR_NOTEMPLATE
 #undef JIT_METH
 
+std::ostream&
+operator<< (std::ostream& os, const jit_value& value)
+{
+  return value.short_print (os);
+}
+
 // -------------------- jit_instruction --------------------
+void
+jit_instruction::push_variable (void)
+{
+  if (tag ())
+    tag ()->push (this);
+}
+
+void
+jit_instruction::pop_variable (void)
+{
+  if (tag ())
+    tag ()->pop ();
+}
+
 llvm::BasicBlock *
 jit_instruction::parent_llvm (void) const
 {
   return mparent->to_llvm ();
 }
 
+std::ostream&
+jit_instruction::short_print (std::ostream& os) const
+{
+  if (type ())
+    jit_print (os, type ()) << ": ";
+
+  if (tag ())
+    os << tag ()->name () << "." << id;
+  else
+    os << "#" << id;
+  return os;
+}
+
+jit_variable *
+jit_instruction::tag (void) const
+{
+  return reinterpret_cast<jit_variable *> (mtag.value ());
+}
+
+void
+jit_instruction::stash_tag (jit_variable *atag)
+{
+  mtag.stash_value (atag, this);
+}
+
 // -------------------- jit_block --------------------
 jit_instruction *
 jit_block::prepend (jit_instruction *instr)
 {
   instructions.push_front (instr);
   instr->stash_parent (this);
   return instr;
 }
@@ -655,16 +716,33 @@ jit_block::prepend (jit_instruction *ins
 jit_instruction *
 jit_block::append (jit_instruction *instr)
 {
   instructions.push_back (instr);
   instr->stash_parent (this);
   return instr;
 }
 
+jit_instruction *
+jit_block::insert_before (iterator loc, jit_instruction *instr)
+{
+  instructions.insert (loc, instr);
+  instr->stash_parent (this);
+  return instr;
+}
+
+jit_instruction *
+jit_block::insert_after (iterator loc, jit_instruction *instr)
+{
+  ++loc;
+  instructions.insert (loc, instr);
+  instr->stash_parent (this);
+  return instr;
+}
+
 jit_terminator *
 jit_block::terminator (void) const
 {
   if (instructions.empty ())
     return 0;
 
   jit_instruction *last = instructions.back ();
   return dynamic_cast<jit_terminator *> (last);
@@ -682,23 +760,16 @@ jit_block::pred (size_t idx) const
   size_t real_idx = use_count () - idx - 1;
   size_t i;
   for (use = first_use (), i = 0; use && i < real_idx; ++i,
          use = use->next ());
     
   return use->user_parent ();
 }
 
-llvm::Value *
-jit_block::pred_terminator_llvm (size_t idx) const
-{
-  jit_terminator *term = pred_terminator (idx);
-  return term ? term->to_llvm () : 0;
-}
-
 size_t
 jit_block::pred_index (jit_block *apred) const
 {
   for (size_t i = 0; i < pred_count (); ++i)
     if (pred (i) == apred)
       return i;
 
   fail ("No such predecessor");
@@ -713,58 +784,240 @@ jit_block::create_merge (llvm::Function 
   jit_block *ipred = pred (pred_idx);
   if (! mpred_llvm[pred_idx] && ipred->pred_count () > 1)
     {
       llvm::BasicBlock *merge;
       merge = llvm::BasicBlock::Create (context, "phi_merge", inside,
                                         to_llvm ());
           
       // fix the predecessor jump if it has been created
-      llvm::Value *term = pred_terminator_llvm (pred_idx);
-      if (term)
+      jit_terminator *jterm = pred_terminator (pred_idx);
+      if (jterm->has_llvm ())
         {
+          llvm::Value *term = jterm->to_llvm ();
           llvm::TerminatorInst *branch = llvm::cast<llvm::TerminatorInst> (term);
           for (size_t i = 0; i < branch->getNumSuccessors (); ++i)
             {
               if (branch->getSuccessor (i) == to_llvm ())
                 branch->setSuccessor (i, merge);
             }
         }
 
       llvm::IRBuilder<> temp (merge);
       temp.CreateBr (to_llvm ());
       mpred_llvm[pred_idx] = merge;
     }
 }
 
+jit_block *
+jit_block::succ (size_t i) const
+{
+  jit_terminator *term = terminator ();
+  return term->sucessor (i);
+}
+
 size_t
 jit_block::succ_count (void) const
 {
   jit_terminator *term = terminator ();
   return term ? term->sucessor_count () : 0;
 }
 
-jit_phi *
-jit_block::search_phi (const std::string& tag_name)
-{
-  jit_phi *ret = 0;
-  for (iterator iter = begin (); iter != end ()
-         && (ret = dynamic_cast<jit_phi *> (*iter)); ++iter)
-    if (ret->tag () == tag_name)
-      return ret;
-
-  return 0;
-}
-
 llvm::BasicBlock *
 jit_block::to_llvm (void) const
 {
   return llvm::cast<llvm::BasicBlock> (llvm_value);
 }
 
+std::ostream&
+jit_block::print_dom (std::ostream& os) const
+{
+  short_print (os);
+  os << ":\n";
+  os << "  mid: " << mid << std::endl;
+  os << "  pred: ";
+  for (size_t i = 0; i < pred_count (); ++i)
+    os << *pred (i) << " ";
+  os << std::endl;
+
+  os << "  succ: ";
+  for (size_t i = 0; i < succ_count (); ++i)
+    os << *succ (i) << " ";
+  os << std::endl;
+
+  os << "  idom: ";
+  if (idom)
+    os << *idom;
+  else
+    os << "NULL";
+  os << std::endl;
+  os << "  df: ";
+  for (df_iterator iter = df_begin (); iter != df_end (); ++iter)
+    os << **iter << " ";
+  os << std::endl;
+
+  os << "  dom_succ: ";
+  for (size_t i = 0; i < dom_succ.size (); ++i)
+    os << *dom_succ[i] << " ";
+
+  return os << std::endl;
+}
+
+void
+jit_block::compute_df (size_t visit_count)
+{
+  if (mvisit_count > visit_count)
+    return;
+  ++mvisit_count;
+
+  if (pred_count () >= 2)
+    {
+      for (size_t i = 0; i < pred_count (); ++i)
+        {
+          jit_block *runner = pred (i);
+          while (runner != idom)
+            {
+              runner->mdf.insert (this);
+              runner = runner->idom;
+            }
+        }
+    }
+
+  for (size_t i = 0; i < succ_count (); ++i)
+    succ (i)->compute_df (visit_count);
+}
+
+bool
+jit_block::update_idom (size_t visit_count)
+{
+  if (mvisit_count > visit_count)
+    return false;
+  ++mvisit_count;
+
+  if (! pred_count ())
+    return false;
+
+  bool changed = false;
+  for (size_t i = 0; i < pred_count (); ++i)
+    changed = pred (i)->update_idom (visit_count) || changed;
+
+  jit_block *new_idom = pred (0);
+  for (size_t i = 1; i < pred_count (); ++i)
+    {
+      jit_block *pidom = pred (i)->idom;
+      if (! new_idom)
+        new_idom = pidom;
+      else if (pidom)
+        new_idom = pidom->idom_intersect (new_idom);
+    }
+
+  if (idom != new_idom)
+    {
+      idom = new_idom;
+      return true;
+    }
+
+  return changed;
+}
+
+void
+jit_block::finish_phi (jit_block *apred)
+{
+  size_t pred_idx = pred_index (apred);
+  for (iterator iter = begin (); iter != end ()
+         && dynamic_cast<jit_phi *> (*iter); ++iter)
+    {
+      jit_instruction *phi = *iter;
+      jit_variable *var = phi->tag ();
+      phi->stash_argument (pred_idx, var->top ());
+    }
+}
+
+void
+jit_block::do_construct_ssa (jit_convert& convert, size_t visit_count)
+{
+  if (mvisit_count > visit_count)
+    return;
+  ++mvisit_count;
+
+  for (iterator iter = begin (); iter != end (); ++iter)
+    {
+      jit_instruction *instr = *iter;
+      bool isphi = dynamic_cast<jit_phi *> (instr);
+
+      if (! isphi)
+        {
+          for (size_t i = 0; i < instr->argument_count (); ++i)
+            {
+              jit_variable *var;
+              var = dynamic_cast<jit_variable *> (instr->argument (i));
+              if (var)
+                instr->stash_argument (i, var->top ());
+            }
+
+          // FIXME: Remove need for jit_store_argument dynamic cast
+          jit_variable *tag = instr->tag ();
+          if (tag && tag->has_top ()
+              && ! dynamic_cast<jit_store_argument *> (instr))
+            {
+              jit_call *rel = convert.create<jit_call> (jit_typeinfo::release,
+                                                        tag->top ());
+              insert_after (iter, rel);
+              ++iter;
+            }
+        }
+
+      instr->push_variable ();
+    }
+
+  for (size_t i = 0; i < succ_count (); ++i)
+    succ (i)->finish_phi (this);
+
+  for (size_t i = 0; i < dom_succ.size (); ++i)
+    dom_succ[i]->do_construct_ssa (convert, visit_count);
+
+  for (iterator iter = begin (); iter != end (); ++iter)
+    {
+      jit_instruction *instr = *iter;
+      instr->pop_variable ();
+    }
+}
+
+void
+jit_block::create_dom_tree (size_t visit_count)
+{
+  if (mvisit_count > visit_count)
+    return;
+  ++mvisit_count;
+
+  if (idom != this)
+    idom->dom_succ.push_back (this);
+
+  for (size_t i = 0; i < succ_count (); ++i)
+    succ (i)->create_dom_tree (visit_count);
+}
+
+jit_block *
+jit_block::idom_intersect (jit_block *b)
+{
+  jit_block *i = this;
+  jit_block *j = b;
+
+  while (i != j)
+    {
+      while (i->id () > j->id ())
+        i = i->idom;
+
+      while (j->id () > i->id ())
+        j = j->idom;
+    }
+
+  return i;
+}
+
 // -------------------- jit_call --------------------
 bool
 jit_call::infer (void)
 {
   // FIXME: explain algorithm
   for (size_t i = 0; i < argument_count (); ++i)
     {
       already_infered[i] = argument_type (i);
@@ -787,88 +1040,78 @@ jit_call::infer (void)
       return true;
     }
 
   return false;
 }
 
 // -------------------- jit_convert --------------------
 jit_convert::jit_convert (llvm::Module *module, tree &tee)
+  : iterator_count (0), breaking (false)
 {
   jit_instruction::reset_ids ();
 
-  jit_block *entry_block = create<jit_block> ("body");
+  entry_block = create<jit_block> ("body");
+  blocks.push_back (entry_block);
   block = entry_block;
-  blocks.push_back (block);
-
-  toplevel_map tlevel (*this, block);
-  variables = &tlevel;
-  final_block = create<jit_block> ("final");
   visit (tee);
 
-  blocks.push_back (final_block);
-  block->append (create<jit_break> (final_block));
+  // FIXME: Remove if we no longer only compile loops
+  assert (! breaking);
+  assert (breaks.empty ());
+  assert (continues.empty ());
 
-  for (variable_map::iterator iter = variables->begin ();
-       iter != variables->end (); ++iter)
-    final_block->append (create<jit_store_argument> (iter->first, iter->second));
+  jit_block *final_block = block;
+  for (vmap_t::iterator iter = vmap.begin (); iter != vmap.end (); ++iter)
+       
+    {
+      jit_variable *var = iter->second;
+      const std::string& name = var->name ();
+      if (name.size () && name[0] != '#')
+        final_block->append (create<jit_store_argument> (var));
+    }
 
-  // FIXME: Maybe we should remove dead code here?
+  construct_ssa (final_block);
 
   // initialize the worklist to instructions derived from constants
   for (std::list<jit_value *>::iterator iter = constants.begin ();
        iter != constants.end (); ++iter)
     append_users (*iter);
 
-  // also get anything from jit_extract_argument, as these have constant types
-  for (jit_block::iterator iter = entry_block->begin ();
-       iter != entry_block->end (); ++iter)
-    {
-      jit_instruction *instr = *iter;
-      if (jit_extract_argument *extract = dynamic_cast<jit_extract_argument *>(instr))
-        {
-          if (! extract->type ())
-            // we depend on an unknown type
-            fail ("Unknown initial type: \"" + extract->tag () + "\""); 
-          append_users (extract);
-        }
-    }
+  if (debug_print)
+      print_blocks ("octave jit ir");
 
   // FIXME: Describe algorithm here
   while (worklist.size ())
     {
       jit_instruction *next = worklist.front ();
       worklist.pop_front ();
 
       if (next->infer ())
         append_users (next);
     }
 
   if (debug_print)
     {
       std::cout << "-------------------- Compiling tree --------------------\n";
       std::cout << tee.str_print_code () << std::endl;
-      std::cout << "-------------------- octave jit ir --------------------\n";
-      for (std::list<jit_block *>::iterator iter = blocks.begin ();
-           iter != blocks.end (); ++iter)
-        (*iter)->print (std::cout, 0);
-      std::cout << std::endl;
+      print_blocks ("octave jit ir");
     }
 
   // for now just init arguments from entry, later we will have to do something
   // more interesting
   for (jit_block::iterator iter = entry_block->begin ();
        iter != entry_block->end (); ++iter)
     {
       if (jit_extract_argument *extract = dynamic_cast<jit_extract_argument *> (*iter))
-        arguments.push_back (std::make_pair (extract->tag (), true));
+        arguments.push_back (std::make_pair (extract->name (), true));
     }
 
   convert_llvm to_llvm;
-  function = to_llvm.convert (module, arguments, blocks, constants);
+  function = to_llvm.convert (module, arguments, blocks);
 
   if (debug_print)
     {
       std::cout << "-------------------- llvm ir --------------------";
       llvm::raw_os_ostream llvm_cout (std::cout);
       function->print (llvm_cout);
       std::cout << std::endl;
       llvm::verifyFunction (*function);
@@ -909,29 +1152,31 @@ jit_convert::visit_binary_expression (tr
 
   const jit_function& fn = jit_typeinfo::binary_op (be.op_type ());
   result = block->append (create<jit_call> (fn, lhsv, rhsv));
 }
 
 void
 jit_convert::visit_break_command (tree_break_command&)
 {
-  fail ();
+  breaks.push_back (block);
+  breaking = true;
 }
 
 void
 jit_convert::visit_colon_expression (tree_colon_expression&)
 {
   fail ();
 }
 
 void
 jit_convert::visit_continue_command (tree_continue_command&)
 {
-  fail ();
+  continues.push_back (block);
+  breaking = true;
 }
 
 void
 jit_convert::visit_global_command (tree_global_command&)
 {
   fail ();
 }
 
@@ -956,103 +1201,96 @@ jit_convert::visit_decl_init_list (tree_
 void
 jit_convert::visit_simple_for_command (tree_simple_for_command& cmd)
 {
   // how a for statement is compiled. Note we do an initial check
   // to see if the loop will run atleast once. This allows us to get
   // better type inference bounds on variables defined and used only
   // inside the for loop (e.g. the index variable)
 
-  // prev_block: % pred = ?
-  //  #control.0 = % compute_control (note this will just be a temp)
-  //  #iter.0 = call for_init (#control.0) % Let type of control decide iter
-  //                                       % initial value and type
-  //  #temp.0 = call for_check (control.0, #iter.0)
-  //  cond_break #temp.0, for_body, for_tail
-  // for_body: % pred = for_init, for_cond
-  //  idxvar.2 = phi | for_init -> idxvar.1
-  //                 | for_body -> idxvar.3
-  //  #iter.1 = phi | for_init -> #iter.0
-  //                | for_body -> #iter.2
-  //  idxvar.3 = call for_index (#control.0, #iter.1)
-  //  % do loop body
-  //  #iter.2 = #iter.1 + 1 % release is implicit in iter reuse
-  //  #check = call for_check (#control.0, iter.2)
-  //  cond_break #check for_body, for_tail
-  // for_tail: % pred = prev_block, for_body
-  //  #iter.3 = phi | prev_block -> #iter.0
-  //                | for_body -> #iter.2
-  //  idxvar.4 = phi | prev_block -> idxvar.0
-  //                 | for_body -> idxvar.3
-  //  call release (#iter.3)
-  //  % rest of code
+  // If we are a nested for loop we need to store the previous breaks
+  assert (! breaking);
+  unwind_protect prot;
+  prot.protect_var (breaks);
+  prot.protect_var (continues);
+  prot.protect_var (breaking);
+  breaks.clear ();
 
   // FIXME: one of these days we will introduce proper lvalues...
   tree_identifier *lhs = dynamic_cast<tree_identifier *>(cmd.left_hand_side ());
   if (! lhs)
     fail ();
   std::string lhs_name = lhs->name ();
 
+  // we need a variable for our iterator, because it is used in multiple blocks
+  std::stringstream ss;
+  ss << "#iter" << iterator_count++;
+  std::string iter_name = ss.str ();
+  jit_variable *iterator = create<jit_variable> (iter_name);
+  vmap[iter_name] = iterator;
+
   jit_block *body = create<jit_block> ("for_body");
   blocks.push_back (body);
 
   jit_block *tail = create<jit_block> ("for_tail");
 
   // do control expression, iter init, and condition check in prev_block (block)
   jit_value *control = visit (cmd.control_expr ());
   jit_call *init_iter = create<jit_call> (jit_typeinfo::for_init, control);
-  init_iter->stash_tag ("#iter");
+  init_iter->stash_tag (iterator);
   block->append (init_iter);
+  
   jit_value *check = block->append (create<jit_call> (jit_typeinfo::for_check,
-                                                      control, init_iter));
+                                                      control, iterator));
   block->append (create<jit_cond_break> (check, body, tail));
-
-  // we need to do iter phi manually, for_map handles the rest
-  jit_phi *iter_phi = create<jit_phi> (2);
-  iter_phi->stash_tag ("#iter");
-  iter_phi->stash_argument (0, init_iter);
-  body->append (iter_phi);
-
-  variable_map *merge_vars = variables;
-  for_map body_vars (variables, body);
-  variables = &body_vars;
   block = body;
 
-  // first thing we do in the for loop is bind our index from our itertor
-  jit_call *idx_rhs = create<jit_call> (jit_typeinfo::for_index, control, iter_phi);
+  // compute the syntactical iterator
+  jit_call *idx_rhs = create<jit_call> (jit_typeinfo::for_index, control, iterator);
   block->append (idx_rhs);
-  idx_rhs->stash_tag (lhs_name);
   do_assign (lhs_name, idx_rhs, false);
   
+  // do loop
   tree_statement_list *pt_body = cmd.body ();
   pt_body->accept (*this);
 
-  // increment iterator, check conditional, and repeat
+  if (breaking && continues.empty ())
+    {
+      // WTF are you doing user? Every branch was a continue, why did you have
+      // a loop??? Users are silly people...
+      finish_breaks (tail, breaks);
+      blocks.push_back (tail);
+      block = tail;
+      return;
+    }
+
+  // check our condition, continues jump to this block
+  jit_block *check_block = create<jit_block> ("for_check");
+  blocks.push_back (check_block);
+
+  if (! breaking)
+    block->append (create<jit_break> (check_block));
+  finish_breaks (check_block, continues);
+
+  block = check_block;
   const jit_function& add_fn = jit_typeinfo::binary_op (octave_value::op_add);
-  jit_call *iter_inc = create<jit_call> (add_fn, iter_phi,
-                                         create<jit_const_index> (1));
-  iter_inc->stash_tag ("#iter");
+  jit_instruction *one = create<jit_const_index> (1);
+  block->append (one);
+
+  jit_call *iter_inc = create<jit_call> (add_fn, iterator, one);
+  iter_inc->stash_tag (iterator);
   block->append (iter_inc);
   check = block->append (create<jit_call> (jit_typeinfo::for_check, control,
-                                           iter_inc));
+                                           iterator));
   block->append (create<jit_cond_break> (check, body, tail));
-  iter_phi->stash_argument (1, iter_inc);
-  body_vars.finish_phi (*variables);
-  merge (tail, *merge_vars, block, body_vars);
 
+  // breaks will go to our tail
   blocks.push_back (tail);
+  finish_breaks (tail, breaks);
   block = tail;
-  variables = merge_vars;
-
-  iter_phi = create<jit_phi> (2);
-  iter_phi->stash_tag ("#iter");
-  iter_phi->stash_argument (0, init_iter);
-  iter_phi->stash_argument (1, iter_inc);
-  block->append (iter_phi);
-  block->append (create<jit_call> (jit_typeinfo::release, iter_phi));
 }
 
 void
 jit_convert::visit_complex_for_command (tree_complex_for_command&)
 {
   fail ();
 }
 
@@ -1085,18 +1323,18 @@ jit_convert::visit_function_def (tree_fu
 {
   fail ();
 }
 
 void
 jit_convert::visit_identifier (tree_identifier& ti)
 {
   const jit_function& fn = jit_typeinfo::grab ();
-  jit_value *var = variables->get (ti.name ());
-  result = block->append (create<jit_call> (fn, var));
+  jit_value *decl = get_variable (ti.name ());
+  result = block->append (create<jit_call> (fn, decl));
 }
 
 void
 jit_convert::visit_if_clause (tree_if_clause&)
 {
   fail ();
 }
 
@@ -1115,16 +1353,20 @@ jit_convert::visit_if_command_list (tree
   // if a == 1
   //  c = c + 1;
   // elseif b == 1
   //  c = c + 2;
   // else
   //  c = c + 3;
   // endif
 
+  // ********************
+  // FIXME: Documentation no longer reflects current version
+  // ********************
+
   // Generates:
   // prev_block0: % pred - ?
   //   #temp.0 = call binary== (a.0, 1)
   //   cond_break #temp.0, if_body1, ifelse_cond2
   // if_body1:
   //   c.1 = call binary+ (c.0, 1)
   //   break if_tail5
   // ifelse_cond2:
@@ -1144,17 +1386,16 @@ jit_convert::visit_if_command_list (tree
 
   tree_if_clause *last = lst.back ();
   size_t last_else = static_cast<size_t> (last->is_else_clause ());
 
   // entry_blocks represents the block you need to enter in order to execute
   // the condition check for the ith clause. For the else, it is simple the
   // else body. If there is no else body, then it is padded with the tail
   std::vector<jit_block *> entry_blocks (lst.size () + 1 - last_else);
-  std::vector<variable_map *> branch_variables (lst.size (), 0);
   std::vector<jit_block *> branch_blocks (lst.size (), 0); // final blocks
   entry_blocks[0] = block;
 
   // we need to construct blocks first, because they have jumps to eachother
   tree_if_command_list::iterator iter = lst.begin ();
   ++iter;
   for (size_t i = 1; iter != lst.end (); ++iter, ++i)
     {
@@ -1164,67 +1405,62 @@ jit_convert::visit_if_command_list (tree
       else
         entry_blocks[i] = create<jit_block> ("ifelse_cond");
     }
 
   jit_block *tail = create<jit_block> ("if_tail");
   if (! last_else)
     entry_blocks[entry_blocks.size () - 1] = tail;
 
-  // actually fill out the contents of our blocks. We store the variable maps
-  // at the end of each branch, this allows us to merge them in the tail
-  variable_map *prev_map = variables;
+  size_t num_incomming = 0; // number of incomming blocks to our tail
   iter = lst.begin ();
   for (size_t i = 0; iter != lst.end (); ++iter, ++i)
     {
       tree_if_clause *tic = *iter;
       block = entry_blocks[i];
       assert (block);
-      variables = prev_map;
 
       if (i) // the first block is prev_block, so it has already been added
         blocks.push_back (entry_blocks[i]);
 
       if (! tic->is_else_clause ())
         {
           tree_expression *expr = tic->condition ();
           jit_value *cond = visit (expr);
 
           jit_block *body = create<jit_block> (i == 0 ? "if_body" : "ifelse_body");
           blocks.push_back (body);
 
           jit_instruction *br = create<jit_cond_break> (cond, body,
                                                         entry_blocks[i + 1]);
           block->append (br);
           block = body;
-
-          variables = new compound_map (variables);
-          branch_variables[i] = variables;
         }
 
       tree_statement_list *stmt_lst = tic->commands ();
       assert (stmt_lst); // jwe: Can this be null?
       stmt_lst->accept (*this);
 
-      branch_variables[i] = variables;
-      branch_blocks[i] = block;
-      block->append (create<jit_break> (tail));
+      if (breaking)
+        breaking = false;
+      else
+        {
+          ++num_incomming;
+          block->append (create<jit_break> (tail));
+        }
     }
 
-  blocks.push_back (tail);
-
-  // We create phi nodes in the tail to merge blocks
-  for (size_t i = 0; i < branch_variables.size () - last_else; ++i)
+  if (num_incomming || ! last_else)
     {
-      merge (tail, *prev_map, branch_blocks[i], *branch_variables[i]);
-      delete branch_variables[i];
+      blocks.push_back (tail);
+      block = tail;
     }
-
-  variables = prev_map;
-  block = tail;
+  else
+    // every branch broke, so we don't have a tail
+    breaking = true;
 }
 
 void
 jit_convert::visit_index_expression (tree_index_expression&)
 {
   fail ();
 }
 
@@ -1262,17 +1498,19 @@ jit_convert::visit_constant (tree_consta
       result = create<jit_const_scalar> (dv);
     }
   else if (v.is_range ())
     {
       Range rv = v.range_value ();
       result = create<jit_const_range> (rv);
     }
   else
-    fail ();
+    fail ("Unknown constant");
+
+  block->append (result);
 }
 
 void
 jit_convert::visit_fcn_handle (tree_fcn_handle&)
 {
   fail ();
 }
 
@@ -1306,29 +1544,25 @@ jit_convert::visit_return_list (tree_ret
   fail ();
 }
 
 void
 jit_convert::visit_simple_assignment (tree_simple_assignment& tsa)
 {
   // resolve rhs
   tree_expression *rhs = tsa.right_hand_side ();
-  jit_value *rhsv = visit (rhs);
+  jit_instruction *rhsv = visit (rhs);
 
   // resolve lhs
   tree_expression *lhs = tsa.left_hand_side ();
   if (! lhs->is_identifier ())
     fail ();
 
   std::string lhs_name = lhs->name ();
-  do_assign (lhs_name, rhsv, tsa.print_result ());
-  result = rhsv;
-
-  if (jit_instruction *instr = dynamic_cast<jit_instruction *>(rhsv))
-    instr->stash_tag (lhs_name);
+  result = do_assign (lhs_name, rhsv, tsa.print_result ());
 }
 
 void
 jit_convert::visit_statement (tree_statement& stmt)
 {
   tree_command *cmd = stmt.command ();
   tree_expression *expr = stmt.expression ();
 
@@ -1343,17 +1577,17 @@ jit_convert::visit_statement (tree_state
         {
           tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
 
           do_bind_ans = (! id->is_variable ());
         }
       else
         do_bind_ans = (! expr->is_assignment_expression ());
 
-      jit_value *expr_result = visit (expr);
+      jit_instruction *expr_result = visit (expr);
 
       if (do_bind_ans)
         do_assign ("ans", expr_result, expr->print_result ());
       else if (expr->is_identifier () && expr->print_result ())
         {
           // FIXME: ugly hack, we need to come up with a way to pass
           // nargout to visit_identifier
           const jit_function& fn = jit_typeinfo::print_value ();
@@ -1368,16 +1602,19 @@ jit_convert::visit_statement_list (tree_
 {
   for (tree_statement_list::iterator iter = lst.begin (); iter != lst.end();
        ++iter)
     {
       tree_statement *elt = *iter;
       // jwe: Can this ever be null?
       assert (elt);
       elt->accept (*this);
+
+      if (breaking)
+        break;
     }
 }
 
 void
 jit_convert::visit_switch_case (tree_switch_case&)
 {
   fail ();
 }
@@ -1413,96 +1650,123 @@ jit_convert::visit_while_command (tree_w
 }
 
 void
 jit_convert::visit_do_until_command (tree_do_until_command&)
 {
   fail ();
 }
 
-void
-jit_convert::do_assign (const std::string& lhs, jit_value *rhs, bool print)
+jit_variable *
+jit_convert::get_variable (const std::string& vname)
 {
-  const jit_function& release = jit_typeinfo::release ();
-  jit_value *current = variables->get (lhs);
-  block->append (create<jit_call> (release, current));
-  variables->set (lhs, rhs);
+  vmap_t::iterator iter;
+  iter = vmap.find (vname);
+  if (iter != vmap.end ())
+    return iter->second;
+
+  jit_variable *var = create<jit_variable> (vname);
+  octave_value val = symbol_table::find (vname);
+  jit_type *type = jit_typeinfo::type_of (val);
+  jit_extract_argument *extract;
+  extract = create<jit_extract_argument> (type, var);
+  entry_block->prepend (extract);
+
+  return vmap[vname] = var;
+}
+
+jit_instruction *
+jit_convert::do_assign (const std::string& lhs, jit_instruction *rhs,
+                        bool print)
+{
+  jit_variable *var = get_variable (lhs);
+  rhs->stash_tag (var);
 
   if (print)
     {
       const jit_function& print_fn = jit_typeinfo::print_value ();
       jit_const_string *name = create<jit_const_string> (lhs);
-      block->append (create<jit_call> (print_fn, name, rhs));
+      block->append (create<jit_call> (print_fn, name, var));
     }
+
+  return rhs;
 }
 
-jit_value *
+jit_instruction *
 jit_convert::visit (tree& tee)
 {
   result = 0;
   tee.accept (*this);
 
-  jit_value *ret = result;
+  jit_instruction *ret = result;
   result = 0;
   return ret;
 }
 
 void
-jit_convert::merge (jit_block *merge_block, variable_map& merge_vars,
-                    jit_block *incomming_block,
-                    const variable_map& incomming_vars)
+jit_convert::construct_ssa (jit_block *final_block)
 {
-  size_t pred_count = merge_block->pred_count ();
-  size_t merge_idx = merge_block->pred_index (incomming_block);
-  for (variable_map::const_iterator iter = incomming_vars.begin ();
-       iter != incomming_vars.end (); ++iter)
+  final_block->label ();
+  entry_block->compute_idom (final_block);
+  entry_block->compute_df ();
+  entry_block->create_dom_tree ();
+
+  // insert phi nodes where needed
+  for (vmap_t::iterator iter = vmap.begin (); iter != vmap.end (); ++iter)
     {
-      const std::string& vname = iter->first;
-      jit_value *merge_val = merge_vars.get (vname);
-      jit_value *inc_val = iter->second;
+      jit_block::df_set visited, added_phi;
+      std::list<jit_block *> ssa_worklist;
+      iter->second->use_blocks (visited);
+      ssa_worklist.insert (ssa_worklist.begin (), visited.begin (), visited.end ());
 
-      if (merge_val != inc_val)
+      while (ssa_worklist.size ())
         {
-          jit_phi *phi = dynamic_cast<jit_phi *> (merge_val);
-          if (! (phi && phi->parent () == merge_block))
+          jit_block *b = ssa_worklist.front ();
+          ssa_worklist.pop_front ();
+
+          for (jit_block::df_iterator diter = b->df_begin ();
+               diter != b->df_end (); ++diter)
             {
-              phi = merge_block->search_phi (vname);
-              if (! phi)
+              jit_block *dblock = *diter;
+              if (! added_phi.count (dblock))
                 {
-                  phi = create<jit_phi> (pred_count, merge_val);
-                  merge_block->prepend (phi);
+                  jit_phi *phi = create<jit_phi> (iter->second,
+                                                  dblock->pred_count ());
+                  dblock->prepend (phi);
+                  added_phi.insert (dblock);
                 }
 
-              merge_vars.set (vname, phi);
+              if (! visited.count (dblock))
+                {
+                  ssa_worklist.push_back (dblock);
+                  visited.insert (dblock);
+                }
             }
-
-          phi->stash_argument (merge_idx, inc_val);
         }
     }
+
+  entry_block->construct_ssa (*this);
 }
 
-// -------------------- jit_convert::toplevel_map --------------------
-jit_value *
-jit_convert::toplevel_map::insert (const std::string& name, jit_value *pval)
+void
+jit_convert::finish_breaks (jit_block *dest, const break_list& lst)
 {
-  assert (pval == 0); // we have no parent
-
-  jit_block *entry = block ();
-  octave_value val = symbol_table::find (name);
-  jit_type *type = jit_typeinfo::type_of (val);
-  jit_instruction *ret = convert.create<jit_extract_argument> (type, name);
-  return vars[name] = entry->prepend (ret);
+  for (break_list::const_iterator iter = lst.begin (); iter != lst.end ();
+       ++iter)
+    {
+      jit_block *b = *iter;
+      b->append (create<jit_break> (dest));
+    }
 }
 
 // -------------------- jit_convert::convert_llvm --------------------
 llvm::Function *
 jit_convert::convert_llvm::convert (llvm::Module *module,
                                     const std::vector<std::pair< std::string, bool> >& args,
-                                    const std::list<jit_block *>& blocks,
-                                    const std::list<jit_value *>& constants)
+                                    const std::list<jit_block *>& blocks)
 {
   jit_type *any = jit_typeinfo::get_any ();
 
   // argument is an array of octave_base_value*, or octave_base_value**
   llvm::Type *arg_type = any->to_llvm (); // this is octave_base_value*
   arg_type = arg_type->getPointerTo ();
   llvm::FunctionType *ft = llvm::FunctionType::get (llvm::Type::getVoidTy (context),
                                                     arg_type, false);
@@ -1517,22 +1781,16 @@ jit_convert::convert_llvm::convert (llvm
 
       llvm::Value *arg = function->arg_begin ();
       for (size_t i = 0; i < args.size (); ++i)
         {
           llvm::Value *loaded_arg = builder.CreateConstInBoundsGEP1_32 (arg, i);
           arguments[args[i].first] = loaded_arg;
         }
 
-      // we need to generate llvm values for constants, as these don't appear in
-      // a block
-      for (std::list<jit_value *>::const_iterator iter = constants.begin ();
-           iter != constants.end (); ++iter)
-        visit (*iter);
-
       std::list<jit_block *>::const_iterator biter;
       for (biter = blocks.begin (); biter != blocks.end (); ++biter)
         {
           jit_block *jblock = *biter;
           llvm::BasicBlock *block = llvm::BasicBlock::Create (context, jblock->name (),
                                                               function);
           jblock->stash_llvm (block);
         }
@@ -1662,68 +1920,73 @@ jit_convert::convert_llvm::visit (jit_co
 }
 
 void
 jit_convert::convert_llvm::visit (jit_call& call)
 {
   const jit_function::overload& ol = call.overload ();
   if (! ol.function)
     fail ("No overload for: " + call.print_string ());
-  
+
   std::vector<llvm::Value *> args (call.argument_count ());
   for (size_t i = 0; i < call.argument_count (); ++i)
     args[i] = call.argument_llvm (i);
 
-  call.stash_llvm (builder.CreateCall (ol.function, args, call.tag ()));
+  call.stash_llvm (builder.CreateCall (ol.function, args));
 }
 
 void
 jit_convert::convert_llvm::visit (jit_extract_argument& extract)
 {
   const jit_function::overload& ol = extract.overload ();
   if (! ol.function)
     fail ();
 
-  llvm::Value *arg = arguments[extract.tag ()];
+  llvm::Value *arg = arguments[extract.name ()];
   assert (arg);
   arg = builder.CreateLoad (arg);
-  extract.stash_llvm (builder.CreateCall (ol.function, arg, extract.tag ()));
+  extract.stash_llvm (builder.CreateCall (ol.function, arg, extract.name ()));
 }
 
 void
 jit_convert::convert_llvm::visit (jit_store_argument& store)
 {
   llvm::Value *arg_value = store.result_llvm ();
   const jit_function::overload& ol = store.overload ();
   if (! ol.function)
     fail ();
 
   arg_value = builder.CreateCall (ol.function, arg_value);
 
-  llvm::Value *arg = arguments[store.tag ()];
+  llvm::Value *arg = arguments[store.name ()];
   store.stash_llvm (builder.CreateStore (arg_value, arg));
 }
 
 void
 jit_convert::convert_llvm::visit (jit_phi& phi)
 {
   // we might not have converted all incoming branches, so we don't
   // set incomming branches now
   llvm::PHINode *node = llvm::PHINode::Create (phi.type_llvm (),
-                                               phi.argument_count (),
-                                               phi.tag ());
+                                               phi.argument_count ());
   builder.Insert (node);
   phi.stash_llvm (node);
 
   jit_block *parent = phi.parent ();
   for (size_t i = 0; i < phi.argument_count (); ++i)
     if (phi.argument_type (i) != phi.type ())
       parent->create_merge (function, i);
 }
 
+void
+jit_convert::convert_llvm::visit (jit_variable&)
+{
+  fail ("ERROR: SSA construction should remove all variables");
+}
+
 // -------------------- tree_jit --------------------
 
 tree_jit::tree_jit (void) : module (0), engine (0)
 {
 }
 
 tree_jit::~tree_jit (void)
 {}
diff --git a/src/pt-jit.h b/src/pt-jit.h
--- a/src/pt-jit.h
+++ b/src/pt-jit.h
@@ -23,16 +23,17 @@ along with Octave; see the file COPYING.
 #if !defined (octave_tree_jit_h)
 #define octave_tree_jit_h 1
 
 #include <list>
 #include <map>
 #include <set>
 #include <stdexcept>
 #include <vector>
+#include <stack>
 
 #include "Array.h"
 #include "Range.h"
 #include "pt-walk.h"
 #include "symtab.h"
 
 // -------------------- Current status --------------------
 // Simple binary operations (+-*/) on octave_scalar's (doubles) are optimized.
@@ -43,31 +44,33 @@ along with Octave; see the file COPYING.
 // For other types all binary operations are compiled but not optimized. For
 // example,
 // a = [1 2 3]
 // b = a + a;
 // will compile to do_binary_op (a, a).
 //
 // For loops are compiled again!
 // if, elseif, and else statements compile again!
+// break and continue now work!
 // Additionally, make check passes using jit.
 //
 // The octave low level IR is a linear IR, it works by converting everything to
 // calls to jit_functions. This turns expressions like c = a + b into
 // c = call binary+ (a, b)
 // The jit_functions contain information about overloads for differnt types. For
 // example, if we know a and b are scalars, then c must also be a scalar.
 //
 //
 // TODO:
-// 1. Support error cases
-// 2. Support break/continue
-// 3. Fix memory leaks in JIT
-// 4. Cleanup/documentation
-// 5. ...
+// 1. Rename symbol_table::symbol_record_ref -> symbol_table::symbol_reference
+// 2. Support some simple matrix case (and cleanup Octave low level IR)
+// 3. Support error cases
+// 4. Fix memory leaks in JIT
+// 5. Cleanup/documentation
+// 6. ...
 // ---------------------------------------------------------
 
 
 // we don't want to include llvm headers here, as they require __STDC_LIMIT_MACROS
 // and __STDC_CONSTANT_MACROS be defined in the entire compilation unit
 namespace llvm
 {
   class Value;
@@ -145,22 +148,17 @@ private:
   std::string mname;
   jit_type *mparent;
   llvm::Type *llvm_type;
   int mid;
   size_t mdepth;
 };
 
 // seperate print function to allow easy printing if type is null
-static std::ostream& jit_print (std::ostream& os, jit_type *atype)
-{
-  if (! atype)
-    return os << "null";
-  return os << atype->name ();
-}
+std::ostream& jit_print (std::ostream& os, jit_type *atype);
 
 // Keeps track of overloads for a builtin function. Used for both type inference
 // and code generation.
 class
 jit_function
 {
 public:
   struct overload
@@ -491,17 +489,18 @@ private:
 
 #define JIT_VISIT_IR_NOTEMPLATE                 \
   JIT_METH(block);                              \
   JIT_METH(break);                              \
   JIT_METH(cond_break);                         \
   JIT_METH(call);                               \
   JIT_METH(extract_argument);                   \
   JIT_METH(store_argument);                     \
-  JIT_METH(phi)
+  JIT_METH(phi);                                \
+  JIT_METH(variable)
 
 #define JIT_VISIT_IR_CLASSES                    \
   JIT_VISIT_IR_NOTEMPLATE;                      \
   JIT_VISIT_IR_CONST
 
 
 class jit_ir_walker;
 class jit_use;
@@ -510,16 +509,19 @@ class
 jit_value
 {
   friend class jit_use;
 public:
   jit_value (void) : llvm_value (0), ty (0), use_head (0), myuse_count (0) {}
 
   virtual ~jit_value (void);
 
+  // replace all uses with
+  void replace_with (jit_value *value);
+
   jit_type *type (void) const { return ty; }
 
   llvm::Type *type_llvm (void) const
   {
     return ty ? ty->to_llvm () : 0;
   }
 
   const std::string& type_name (void) const
@@ -535,95 +537,54 @@ public:
 
   std::string print_string (void)
   {
     std::stringstream ss;
     print (ss);
     return ss.str ();
   }
 
-  virtual std::ostream& print (std::ostream& os, size_t indent = 0) = 0;
+  virtual std::ostream& print (std::ostream& os, size_t indent = 0) const = 0;
 
-  virtual std::ostream& short_print (std::ostream& os)
+  virtual std::ostream& short_print (std::ostream& os) const
   { return print (os); }
 
   virtual void accept (jit_ir_walker& walker) = 0;
 
+  bool has_llvm (void) const
+  {
+    return llvm_value;
+  }
+
   llvm::Value *to_llvm (void) const
   {
+    assert (llvm_value);
     return llvm_value;
   }
 
   void stash_llvm (llvm::Value *compiled)
   {
     llvm_value = compiled;
   }
 protected:
-  std::ostream& print_indent (std::ostream& os, size_t indent)
+  std::ostream& print_indent (std::ostream& os, size_t indent) const
   {
-    for (size_t i = 0; i < indent; ++i)
-      os << "\t";
+    for (size_t i = 0; i < indent * 8; ++i)
+      os << " ";
     return os;
   }
 
   llvm::Value *llvm_value;
 private:
   jit_type *ty;
   jit_use *use_head;
   size_t myuse_count;
 };
 
-// defnie accept methods for subclasses
-#define JIT_VALUE_ACCEPT(clname)                \
-  virtual void accept (jit_ir_walker& walker);
-
-template <typename T, jit_type *(*EXTRACT_T)(void), typename PASS_T = T,
-          bool QUOTE=false>
-class
-jit_const : public jit_value
-{
-public:
-  typedef PASS_T pass_t;
-
-  jit_const (PASS_T avalue) : mvalue (avalue)
-  {
-    stash_type (EXTRACT_T ());
-  }
-
-  PASS_T value (void) const { return mvalue; }
-
-  virtual std::ostream& print (std::ostream& os, size_t indent)
-  {
-    print_indent (os, indent) << type_name () << ": ";
-    if (QUOTE)
-      os << "\"";
-    os << mvalue;
-    if (QUOTE)
-      os << "\"";
-    return os;
-  }
-
-  JIT_VALUE_ACCEPT (jit_const);
-private:
-  T mvalue;
-};
-
-typedef jit_const<double, jit_typeinfo::get_scalar> jit_const_scalar;
-typedef jit_const<octave_idx_type, jit_typeinfo::get_index> jit_const_index;
-
-typedef jit_const<std::string, jit_typeinfo::get_string, const std::string&, true>
-jit_const_string;
-typedef jit_const<jit_range, jit_typeinfo::get_range, const jit_range&>
-jit_const_range;
-
-#define JIT_VISIT_IR_CONST                      \
-  JIT_METH(const_scalar);                       \
-  JIT_METH(const_index);                        \
-  JIT_METH(const_string);                       \
-  JIT_METH(const_range)
+std::ostream& operator<< (std::ostream& os, const jit_value& value);
 
 class jit_instruction;
 class jit_block;
 
 class
 jit_use
 {
 public:
@@ -700,16 +661,18 @@ private:
 
   jit_value *mvalue;
   jit_use *mnext;
   jit_use *mprev;
   jit_instruction *muser;
   size_t mindex;
 };
 
+class jit_variable;
+
 class
 jit_instruction : public jit_value
 {
 public:
   // FIXME: this code could be so much pretier with varadic templates...
   jit_instruction (void) : id (next_id ()), mparent (0)
   {}
 
@@ -759,17 +722,16 @@ public:
   llvm::Value *argument_llvm (size_t i) const
   {
     assert (argument (i));
     return argument (i)->to_llvm ();
   }
 
   jit_type *argument_type (size_t i) const
   {
-    assert (argument (i));
     return argument (i)->type ();
   }
 
   llvm::Type *argument_type_llvm (size_t i) const
   {
     assert (argument (i));
     return argument_type (i)->to_llvm ();
   }
@@ -803,90 +765,149 @@ public:
   }
 
   // argument types which have been infered already
   const std::vector<jit_type *>& argument_types (void) const
   { return already_infered; }
 
   virtual bool infer (void) { return false; }
 
-  virtual std::ostream& short_print (std::ostream& os)
-  {
-    if (mtag.empty ())
-      jit_print (os, type ()) << ": #" << id;
-    else
-      jit_print (os, type ()) << ": " << mtag << "." << id;
+  void push_variable (void);
 
-    return os;
-  }
+  void pop_variable (void);
 
-  const std::string& tag (void) const { return mtag; }
-
-  void stash_tag (const std::string& atag) { mtag = atag; }
+  virtual std::ostream& short_print (std::ostream& os) const;
 
   jit_block *parent (void) const { return mparent; }
 
   llvm::BasicBlock *parent_llvm (void) const;
 
   void stash_parent (jit_block *aparent)
   {
     assert (! mparent);
     mparent = aparent;
   }
+
+  jit_variable *tag (void) const;
+
+  void stash_tag (jit_variable *atag);
 protected:
   std::vector<jit_type *> already_infered;
 private:
   static size_t next_id (bool reset = false)
   {
     static size_t ret = 0;
     if (reset)
       return ret = 0;
 
     return ret++;
   }
 
   std::vector<jit_use> arguments;
 
-  std::string mtag;
+  jit_use mtag;
+
   size_t id;
   jit_block *mparent;
 };
 
+// defnie accept methods for subclasses
+#define JIT_VALUE_ACCEPT(clname)                \
+  virtual void accept (jit_ir_walker& walker);
+
+template <typename T, jit_type *(*EXTRACT_T)(void), typename PASS_T = T,
+          bool QUOTE=false>
+class
+jit_const : public jit_instruction
+{
+public:
+  typedef PASS_T pass_t;
+
+  jit_const (PASS_T avalue) : mvalue (avalue)
+  {
+    stash_type (EXTRACT_T ());
+  }
+
+  PASS_T value (void) const { return mvalue; }
+
+  virtual std::ostream& print (std::ostream& os, size_t indent) const
+  {
+    print_indent (os, indent);
+    short_print (os) << " = ";
+    if (QUOTE)
+      os << "\"";
+    os << mvalue;
+    if (QUOTE)
+      os << "\"";
+    return os;
+  }
+
+  JIT_VALUE_ACCEPT (jit_const);
+private:
+  T mvalue;
+};
+
+typedef jit_const<double, jit_typeinfo::get_scalar> jit_const_scalar;
+typedef jit_const<octave_idx_type, jit_typeinfo::get_index> jit_const_index;
+
+typedef jit_const<std::string, jit_typeinfo::get_string, const std::string&, true>
+jit_const_string;
+typedef jit_const<jit_range, jit_typeinfo::get_range, const jit_range&>
+jit_const_range;
+
+#define JIT_VISIT_IR_CONST                      \
+  JIT_METH(const_scalar);                       \
+  JIT_METH(const_index);                        \
+  JIT_METH(const_string);                       \
+  JIT_METH(const_range)
+
 class jit_terminator;
 class jit_phi;
+class jit_convert;
 
 class
 jit_block : public jit_value
 {
 public:
   typedef std::list<jit_instruction *> instruction_list;
   typedef instruction_list::iterator iterator;
   typedef instruction_list::const_iterator const_iterator;
 
-  jit_block (const std::string& aname) : mname (aname)
+  typedef std::set<jit_block *> df_set;
+  typedef df_set::const_iterator df_iterator;
+
+  jit_block (const std::string& aname) : mvisit_count (0), mid (NO_ID), idom (0),
+                                         mname (aname)
   {}
 
   const std::string& name (void) const { return mname; }
 
   jit_instruction *prepend (jit_instruction *instr);
 
   jit_instruction *append (jit_instruction *instr);
 
+  jit_instruction *insert_before (iterator loc, jit_instruction *instr);
+
+  jit_instruction *insert_after (iterator loc, jit_instruction *instr);
+
+  void remove (jit_block::iterator iter)
+  {
+    instructions.erase (iter);
+  }
+
   jit_terminator *terminator (void) const;
 
   jit_block *pred (size_t idx) const;
 
   jit_terminator *pred_terminator (size_t idx) const
   {
     return pred (idx)->terminator ();
   }
 
-  llvm::Value *pred_terminator_llvm (size_t idx) const;
-
-  std::ostream& print_pred (std::ostream& os, size_t idx)
+  std::ostream& print_pred (std::ostream& os, size_t idx) const
   {
     return pred (idx)->short_print (os);
   }
 
   // takes into account for the addition of phi merges
   llvm::BasicBlock *pred_llvm (size_t idx) const
   {
     if (mpred_llvm.size () < pred_count ())
@@ -902,93 +923,233 @@ public:
 
   size_t pred_index (jit_block *apred) const;
 
   // create llvm phi merge blocks for all predecessors (if required)
   void create_merge (llvm::Function *inside, size_t pred_idx);
 
   size_t pred_count (void) const { return use_count (); }
 
+  jit_block *succ (size_t i) const;
+
   size_t succ_count (void) const;
 
   iterator begin (void) { return instructions.begin (); }
 
   const_iterator begin (void) const { return instructions.begin (); }
 
   iterator end (void) { return instructions.end (); }
 
-  const_iterator end (void) const { return instructions.begin (); }
+  const_iterator end (void) const { return instructions.end (); }
+
+  iterator phi_begin (void);
+
+  iterator phi_end (void);
+
+  iterator nonphi_begin (void);
+
+  // must label before id is valid
+  size_t id (void) const { return mid; }
+
+  // dominance frontier
+  const df_set& df (void) const { return mdf; }
+
+  df_iterator df_begin (void) const { return mdf.begin (); }
+
+  df_iterator df_end (void) const { return mdf.end (); }
+
+  // label with a RPO walk
+  void label (void)
+  {
+    size_t number = 0;
+    label (mvisit_count, number);
+  }
+
+  void label (size_t visit_count, size_t& number)
+  {
+    if (mvisit_count > visit_count)
+      return;
+    ++mvisit_count;
+
+    for (size_t i = 0; i < pred_count (); ++i)
+      pred (i)->label (visit_count, number);
 
-  // search for the phi function with the given tag_name, if no function
-  // exists then null is returned
-  jit_phi *search_phi (const std::string& tag_name);
+    mid = number;
+    ++number;
+  }
+
+  // See for idom computation algorithm
+  // Cooper, Keith D.; Harvey, Timothy J; and Kennedy, Ken (2001).
+  // "A Simple, Fast Dominance Algorithm"
+  void compute_idom (jit_block *final)
+  {
+    bool changed;
+    idom = this;
+    do
+      changed = final->update_idom (mvisit_count);
+    while (changed);
+  }
 
-  virtual std::ostream& print (std::ostream& os, size_t indent)
+  // compute dominance frontier
+  void compute_df (void)
+  {
+    compute_df (mvisit_count);
+  }
+
+  void create_dom_tree (void)
   {
-    print_indent (os, indent) << mname << ":\tpred = ";
+    create_dom_tree (mvisit_count);
+  }
+
+  void construct_ssa (jit_convert& convert)
+  {
+    do_construct_ssa (convert, mvisit_count);
+  }
+
+  virtual std::ostream& print (std::ostream& os, size_t indent) const
+  {
+    print_indent (os, indent) << mname << ":        %pred = ";
     for (size_t i = 0; i < pred_count (); ++i)
       {
         print_pred (os, i);
         if (i + 1 < pred_count ())
           os << ", ";
       }
     os << std::endl;
 
-    for (iterator iter = begin (); iter != end (); ++iter)
+    for (const_iterator iter = begin (); iter != end (); ++iter)
       {
         jit_instruction *instr = *iter;
         instr->print (os, indent + 1) << std::endl;
       }
     return os;
   }
 
-  virtual std::ostream& short_print (std::ostream& os)
+  // print dominator infomration
+  std::ostream& print_dom (std::ostream& os) const;
+
+  virtual std::ostream& short_print (std::ostream& os) const
   {
     return os << mname;
   }
 
   llvm::BasicBlock *to_llvm (void) const;
 
   JIT_VALUE_ACCEPT (block)
 private:
+  void compute_df (size_t visit_count);
+
+  bool update_idom (size_t visit_count);
+
+  void finish_phi (jit_block *pred);
+
+  void do_construct_ssa (jit_convert& convert, size_t visit_count);
+
+  void create_dom_tree (size_t visit_count);
+
+  jit_block *idom_intersect (jit_block *b);
+
+  static const size_t NO_ID = static_cast<size_t> (-1);
+  size_t mvisit_count;
+  size_t mid;
+  jit_block *idom;
+  df_set mdf;
+  std::vector<jit_block *> dom_succ;
   std::string mname;
   instruction_list instructions;
   mutable std::vector<llvm::BasicBlock *> mpred_llvm;
 };
 
+
+
+// A non-ssa variable
+class
+jit_variable : public jit_value
+{
+public:
+  jit_variable (const std::string& aname) : mname (aname) {}
+
+  const std::string &name (void) const { return mname; }
+
+  // manipulate the value_stack, for use during SSA construction. The top of the
+  // value stack represents the current value for this variable
+  bool has_top (void) const
+  {
+    return ! value_stack.empty ();
+  }
+
+  jit_value *top (void) const
+  {
+    return value_stack.top ();
+  }
+
+  void push (jit_value *v)
+  {
+    value_stack.push (v);
+  }
+
+  void pop (void)
+  {
+    value_stack.pop ();
+  }
+
+  // blocks in which we are used
+  void use_blocks (jit_block::df_set& result)
+  {
+    jit_use *use = first_use ();
+    while (use)
+      {
+        result.insert (use->user_parent ());
+        use = use->next ();
+      }
+  }
+
+  virtual std::ostream& print (std::ostream& os, size_t indent) const
+  {
+    return print_indent (os, indent) << mname;
+  }
+
+  JIT_VALUE_ACCEPT (variable)
+private:
+  std::string mname;
+  std::stack<jit_value *> value_stack;
+};
+
 class
 jit_phi : public jit_instruction
 {
 public:
-  jit_phi (size_t npred, jit_value *adefault = 0)
-    : jit_instruction (npred, adefault)
-  {}
+  jit_phi (jit_variable *avariable, size_t npred)
+    : jit_instruction (npred)
+  {
+    stash_tag (avariable);
+  }
 
   virtual bool infer (void)
   {
     jit_type *infered = 0;
     for (size_t i = 0; i < argument_count (); ++i)
       infered = jit_typeinfo::join (infered, argument_type (i));
 
     if (infered != type ())
       {
         stash_type (infered);
         return true;
       }
 
     return false;
   }
 
-  virtual std::ostream& print (std::ostream& os, size_t indent)
+  virtual std::ostream& print (std::ostream& os, size_t indent) const
   {
     std::stringstream ss;
     print_indent (ss, indent);
     short_print (ss) << " phi ";
     std::string ss_str = ss.str ();
-    std::string indent_str (ss_str.size () + 7, ' ');
+    std::string indent_str (ss_str.size (), ' ');
     os << ss_str;
 
     jit_block *pblock = parent ();
     for (size_t i = 0; i < argument_count (); ++i)
       {
         if (i > 0)
           os << indent_str;
         os << "| ";
@@ -1023,17 +1184,17 @@ public:
   {
     jit_block *succ = sucessor (idx);
     llvm::BasicBlock *pllvm = parent_llvm ();
     llvm::BasicBlock *spred_llvm = succ->pred_llvm (parent ());
     llvm::BasicBlock *succ_llvm = succ->to_llvm ();
     return pllvm == spred_llvm ? succ_llvm : spred_llvm;
   }
 
-  std::ostream& print_sucessor (std::ostream& os, size_t idx = 0)
+  std::ostream& print_sucessor (std::ostream& os, size_t idx = 0) const
   {
     return sucessor (idx)->short_print (os);
   }
 
   virtual size_t sucessor_count (void) const = 0;
 };
 
 class
@@ -1045,17 +1206,17 @@ public:
   jit_block *sucessor (size_t idx = 0) const
   {
     jit_value *arg = argument (idx);
     return static_cast<jit_block *> (arg);
   }
 
   size_t sucessor_count (void) const { return 1; }
 
-  virtual std::ostream& print (std::ostream& os, size_t indent)
+  virtual std::ostream& print (std::ostream& os, size_t indent) const
   {
     print_indent (os, indent) << "break: ";
     return print_sucessor (os);
   }
 
   JIT_VALUE_ACCEPT (break)
 };
 
@@ -1063,17 +1224,17 @@ class
 jit_cond_break : public jit_terminator
 {
 public:
   jit_cond_break (jit_value *c, jit_block *ctrue, jit_block *cfalse)
     : jit_terminator (c, ctrue, cfalse) {}
 
   jit_value *cond (void) const { return argument (0); }
 
-  std::ostream& print_cond (std::ostream& os)
+  std::ostream& print_cond (std::ostream& os) const
   {
     return cond ()->short_print (os);
   }
 
   llvm::Value *cond_llvm (void) const
   {
     return cond ()->to_llvm ();
   }
@@ -1081,17 +1242,17 @@ public:
   jit_block *sucessor (size_t idx) const
   {
     jit_value *arg = argument (idx + 1);
     return static_cast<jit_block *> (arg);
   }
 
   size_t sucessor_count (void) const { return 2; }
 
-  virtual std::ostream& print (std::ostream& os, size_t indent)
+  virtual std::ostream& print (std::ostream& os, size_t indent) const
   {
     print_indent (os, indent) << "cond_break: ";
     print_cond (os) << ", ";
     print_sucessor (os, 0) << ", ";
     return print_sucessor (os, 1);
   }
 
   JIT_VALUE_ACCEPT (cond_break)
@@ -1117,21 +1278,21 @@ public:
 
   const jit_function& function (void) const { return mfunction; }
 
   const jit_function::overload& overload (void) const
   {
     return mfunction.get_overload (argument_types ());
   }
 
-  virtual std::ostream& print (std::ostream& os, size_t indent)
+  virtual std::ostream& print (std::ostream& os, size_t indent) const
   {
     print_indent (os, indent);
 
-    if (use_count ())
+    if (use_count () || tag ())
       short_print (os) << " = ";
     os << "call " << mfunction.name () << " (";
 
     for (size_t i = 0; i < argument_count (); ++i)
       {
         print_argument (os, i);
         if (i + 1 < argument_count ())
           os << ", ";
@@ -1145,45 +1306,57 @@ public:
 private:
   const jit_function& mfunction;
 };
 
 class
 jit_extract_argument : public jit_instruction
 {
 public:
-  jit_extract_argument (jit_type *atype, const std::string& aname)
+  jit_extract_argument (jit_type *atype, jit_variable *var)
     : jit_instruction ()
   {
     stash_type (atype);
-    stash_tag (aname);
+    stash_tag (var);
+  }
+
+  const std::string& name (void) const
+  {
+    return tag ()->name ();
   }
 
   const jit_function::overload& overload (void) const
   {
     return jit_typeinfo::cast (type (), jit_typeinfo::get_any ());
   }
 
-  virtual std::ostream& print (std::ostream& os, size_t indent)
+  virtual std::ostream& print (std::ostream& os, size_t indent) const
   {
     print_indent (os, indent);
-    return short_print (os) << " = extract: " << tag ();
+    os << "exract ";
+    short_print (os);
+    return os;
   }
 
   JIT_VALUE_ACCEPT (extract_argument)
 };
 
 class
 jit_store_argument : public jit_instruction
 {
 public:
-  jit_store_argument (const std::string& aname, jit_value *aresult)
-    : jit_instruction (aresult)
+  jit_store_argument (jit_variable *var)
+    : jit_instruction (var)
   {
-    stash_tag (aname);
+    stash_tag (var);
+  }
+
+  const std::string& name (void) const
+  {
+    return tag ()->name ();
   }
 
   const jit_function::overload& overload (void) const
   {
     return jit_typeinfo::cast (jit_typeinfo::get_any (), result_type ());
   }
 
   jit_value *result (void) const
@@ -1196,20 +1369,21 @@ public:
     return result ()->type ();
   }
 
   llvm::Value *result_llvm (void) const
   {
     return result ()->to_llvm ();
   }
 
-  virtual std::ostream& print (std::ostream& os, size_t indent)
+  virtual std::ostream& print (std::ostream& os, size_t indent) const
   {
     jit_value *res = result ();
-    print_indent (os, indent) << tag () << " <- ";
+    print_indent (os, indent) << "store ";
+    short_print (os) << " = ";
     return res->short_print (os);
   }
 
   JIT_VALUE_ACCEPT (store_argument)
 };
 
 class
 jit_ir_walker
@@ -1333,168 +1507,16 @@ public:
 
   void visit_try_catch_command (tree_try_catch_command&);
 
   void visit_unwind_protect_command (tree_unwind_protect_command&);
 
   void visit_while_command (tree_while_command&);
 
   void visit_do_until_command (tree_do_until_command&);
-private:
-  std::vector<std::pair<std::string, bool> > arguments;
-  type_bound_vector bounds;
-
-  class
-  variable_map
-  {
-    // internal variable map
-    typedef std::map<std::string, jit_value *> ivar_map;
-  public:
-    typedef ivar_map::iterator iterator;
-    typedef ivar_map::const_iterator const_iterator;
-
-    variable_map (variable_map *aparent, jit_block *ablock) : mparent (aparent),
-                                                              mblock (ablock)
-    {}
-
-    virtual ~variable_map () {}
-
-    variable_map *parent (void) const { return mparent; }
-
-    jit_block *block (void) const { return mblock; }
-
-    jit_value *get (const std::string& name)
-    {
-      ivar_map::iterator iter = vars.find (name);
-      if (iter != vars.end ())
-        return iter->second;
-
-      if (mparent)
-        {
-          jit_value *pval = mparent->get (name);
-          return insert (name, pval);
-        }
-
-      return insert (name, 0);
-    }
-
-    jit_value *set (const std::string& name, jit_value *val)
-    {
-      get (name); // force insertion
-      return vars[name] = val;
-    }
-
-    iterator begin (void) { return vars.begin (); }
-    const_iterator begin (void) const { return vars.begin (); }
-
-    iterator end (void) { return vars.end (); }
-    const_iterator end (void) const { return vars.end (); }
-
-    size_t size (void) const { return vars.size (); }
-  protected:
-    virtual jit_value *insert (const std::string& name, jit_value *pval) = 0;
-
-    ivar_map vars;
-  private:
-    variable_map *mparent;
-    jit_block *mblock;
-  };
-
-  class
-  toplevel_map : public variable_map
-  {
-  public:
-    toplevel_map (jit_convert& aconvert, jit_block *aentry)
-      : variable_map (0, aentry), convert (aconvert) {}
-  protected:
-    virtual jit_value *insert (const std::string& name, jit_value *pval);
-  private:
-    jit_convert& convert;
-  };
-
-  class
-  for_map : public variable_map
-  {
-  public:
-    typedef variable_map::iterator iterator;
-    typedef variable_map::const_iterator const_iterator;
-
-    for_map (variable_map *aparent, jit_block *ablock)
-      : variable_map (aparent, ablock)
-    {
-      // force insertion of all phi nodes
-      for (iterator iter = aparent->begin (); iter != aparent->end (); ++iter)
-        get (iter->first);
-    }
-
-    void finish_phi (variable_map& from)
-    {
-      jit_block *for_body = block ();
-      for (jit_block::iterator iter = for_body->begin ();
-           iter != for_body->end () && dynamic_cast<jit_phi *> (*iter); ++iter)
-        {
-          jit_instruction *node = *iter;
-          if (! node->argument (1))
-            node->stash_argument (1, from.get (node->tag ()));
-        }
-    }
-  protected:
-    virtual jit_value *insert (const std::string& name, jit_value *pval)
-    {
-      jit_phi *ret = new jit_phi (2);
-      ret->stash_tag (name);
-      block ()->prepend (ret);
-      ret->stash_argument (0, pval);
-      return vars[name] = ret;
-    }
-  };
-
-  class
-  compound_map : public variable_map
-  {
-  public:
-    compound_map (variable_map *aparent) : variable_map (aparent, 0)
-    {}
-  protected:
-    virtual jit_value *insert (const std::string&, jit_value *pval)
-    {
-      return pval;
-    }
-  };
-
-
-  variable_map *variables;
-
-  // used instead of return values from visit_* functions
-  jit_value *result;
-
-  jit_block *block;
-  jit_block *final_block;
-
-  llvm::Function *function;
-
-  std::list<jit_block *> blocks;
-
-  std::list<jit_instruction *> worklist;
-
-  std::list<jit_value *> constants;
-
-  std::list<jit_value *> all_values;
-
-  void do_assign (const std::string& lhs, jit_value *rhs, bool print);
-
-  jit_value *visit (tree *tee) { return visit (*tee); }
-
-  jit_value *visit (tree& tee);
-
-  void append_users (jit_value *v)
-  {
-    for (jit_use *use = v->first_use (); use; use = use->next ())
-      worklist.push_back (use->user ());
-  }
 
   // this would be easier with variadic templates
   template <typename T>
   T *create (void)
   {
     T *ret = new T();
     track_value (ret);
     return ret;
@@ -1518,39 +1540,106 @@ private:
 
   template <typename T, typename ARG0, typename ARG1, typename ARG2>
   T *create (const ARG0& arg0, const ARG1& arg1, const ARG2& arg2)
   {
     T *ret = new T(arg0, arg1, arg2);
     track_value (ret);
     return ret;
   }
+private:
+  std::vector<std::pair<std::string, bool> > arguments;
+  type_bound_vector bounds;
+
+  // used instead of return values from visit_* functions
+  jit_instruction *result;
+
+  jit_block *entry_block;
+
+  jit_block *block;
+
+  llvm::Function *function;
+
+  std::list<jit_block *> blocks;
+
+  std::list<jit_instruction *> worklist;
+
+  std::list<jit_value *> constants;
+
+  std::list<jit_value *> all_values;
+
+  size_t iterator_count;
+
+  typedef std::map<std::string, jit_variable *> vmap_t;
+  vmap_t vmap;
+
+  jit_variable *get_variable (const std::string& vname);
+
+  jit_instruction *do_assign (const std::string& lhs, jit_instruction *rhs,
+                              bool print);
+
+  jit_instruction *visit (tree *tee) { return visit (*tee); }
+
+  jit_instruction *visit (tree& tee);
+
+  void append_users (jit_value *v)
+  {
+    for (jit_use *use = v->first_use (); use; use = use->next ())
+      worklist.push_back (use->user ());
+  }
 
   void track_value (jit_value *value)
   {
-    if (value->type () && ! dynamic_cast<jit_instruction *>(value))
+    if (value->type ())
       constants.push_back (value);
     all_values.push_back (value);
   }
 
-  // place phi nodes in the current block to merge ref with variables
-  // we assume the same number of deffinitions
-  void merge (jit_block *merge_block, variable_map& merge_vars,
-              jit_block *incomming_block,
-              const variable_map& incomming_vars);
+  void construct_ssa (jit_block *final_block);
+
+  void print_blocks (const std::string& header)
+  {
+    std::cout << "-------------------- " << header << " --------------------\n";
+    for (std::list<jit_block *>::iterator iter = blocks.begin ();
+         iter != blocks.end (); ++iter)
+      {
+        assert (*iter);
+        (*iter)->print (std::cout, 0);
+      }
+    std::cout << std::endl;
+  }
+
+  void print_dom (void)
+  {
+    std::cout << "-------------------- dom info --------------------\n";
+    for (std::list<jit_block *>::iterator iter = blocks.begin ();
+         iter != blocks.end (); ++iter)
+      {
+        assert (*iter);
+        (*iter)->print_dom (std::cout);
+      }
+    std::cout << std::endl;
+  }
+
+  typedef std::list<jit_block *> break_list;
+
+  bool breaking; // true if we are breaking OR continuing
+  break_list breaks;
+  break_list continues;
+
+  void finish_breaks (jit_block *dest, const break_list& lst);
 
   // this case is much simpler, just convert from the jit ir to llvm
   class
   convert_llvm : public jit_ir_walker
   {
   public:
     llvm::Function *convert (llvm::Module *module,
                              const std::vector<std::pair<std::string, bool> >& args,
-                             const std::list<jit_block *>& blocks,
-                             const std::list<jit_value *>& constants);
+                             const std::list<jit_block *>& blocks);
 
 #define JIT_METH(clname)                        \
     virtual void visit (jit_ ## clname&);
 
     JIT_VISIT_IR_CLASSES;
 
 #undef JIT_METH
   private:
