# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1449185580 18000
#      Thu Dec 03 18:33:00 2015 -0500
# Node ID fb128aafc32239b971e2cef5d3e1441e8b7dc1ec
# Parent  c349d4c91ce286482cdbe1947d09ac4f4699020b
eliminate return statements after calls to print_usage

* syscalls.cc, time.cc, tril.cc, typecast.cc, utils.cc:
Eliminate return statements after calls to print_usage.

diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -122,39 +122,37 @@ error message.\n\
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
-  if (nargin == 2)
-    {
-      octave_stream old_stream
-        = octave_stream_list::lookup (args(0), "dup2");
+  if (nargin != 2)
+    print_usage ();
 
-      octave_stream new_stream
-        = octave_stream_list::lookup (args(1), "dup2");
+  octave_stream old_stream
+    = octave_stream_list::lookup (args(0), "dup2");
 
-      int i_old = old_stream.file_number ();
-      int i_new = new_stream.file_number ();
+  octave_stream new_stream
+    = octave_stream_list::lookup (args(1), "dup2");
 
-      if (i_old >= 0 && i_new >= 0)
-        {
-          std::string msg;
-
-          int status = octave_syscalls::dup2 (i_old, i_new, msg);
+  int i_old = old_stream.file_number ();
+  int i_new = new_stream.file_number ();
 
-          retval(1) = msg;
-          retval(0) = status;
-        }
+  if (i_old >= 0 && i_new >= 0)
+    {
+      std::string msg;
+
+      int status = octave_syscalls::dup2 (i_old, i_new, msg);
+
+      retval(1) = msg;
+      retval(0) = status;
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("exec", Fexec, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{err}, @var{msg}] =} exec (@var{file}, @var{args})\n\
 Replace current process with a new process.\n\
@@ -177,56 +175,54 @@ error message.\n\
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
-  if (nargin == 1 || nargin == 2)
-    {
-      std::string exec_file = args(0).xstring_value ("exec: FILE must be a string");
-
-      string_vector exec_args;
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
 
-      if (nargin == 2)
-        {
-          string_vector tmp = args(1).xall_strings ("exec: all arguments must be strings");
+  std::string exec_file = args(0).xstring_value ("exec: FILE must be a string");
 
-          int len = tmp.numel ();
-
-          exec_args.resize (len + 1);
-
-          exec_args[0] = exec_file;
+  string_vector exec_args;
 
-          for (int i = 0; i < len; i++)
-            exec_args[i+1] = tmp[i];
-        }
-      else
-        {
-          exec_args.resize (1);
+  if (nargin == 2)
+    {
+      string_vector tmp = args(1).xall_strings ("exec: all arguments must be strings");
 
-          exec_args[0] = exec_file;
-        }
+      int len = tmp.numel ();
 
-      octave_history_write_timestamp ();
-
-      if (! command_history::ignoring_entries ())
-        command_history::clean_up_and_save ();
+      exec_args.resize (len + 1);
 
-      std::string msg;
+      exec_args[0] = exec_file;
 
-      int status = octave_syscalls::execvp (exec_file, exec_args, msg);
-
-      retval(1) = msg;
-      retval(0) = status;
+      for (int i = 0; i < len; i++)
+        exec_args[i+1] = tmp[i];
     }
   else
-    print_usage ();
+    {
+      exec_args.resize (1);
+
+      exec_args[0] = exec_file;
+    }
+
+  octave_history_write_timestamp ();
+
+  if (! command_history::ignoring_entries ())
+    command_history::clean_up_and_save ();
+
+  std::string msg;
+
+  int status = octave_syscalls::execvp (exec_file, exec_args, msg);
+
+  retval(1) = msg;
+  retval(0) = status;
 
   return retval;
 }
 
 DEFUNX ("popen2", Fpopen2, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{in}, @var{out}, @var{pid}] =} popen2 (@var{command}, @var{args})\n\
 Start a subprocess with two-way communication.\n\
@@ -276,76 +272,74 @@ exit status, it will linger until Octave
   octave_value_list retval;
 
   retval(2) = -1;
   retval(1) = Matrix ();
   retval(0) = Matrix ();
 
   int nargin = args.length ();
 
-  if (nargin >= 1 && nargin <= 3)
-    {
-      std::string exec_file = args(0).xstring_value ("popen2: COMMAND argument must be a string");
-
-      string_vector arg_list;
-
-      if (nargin >= 2)
-        {
-          string_vector tmp = args(1).xall_strings ("popen2: all arguments must be strings");
-
-          int len = tmp.numel ();
-
-          arg_list.resize (len + 1);
+  if (nargin < 1 || nargin > 3)
+    print_usage ();
 
-          arg_list[0] = exec_file;
+  std::string exec_file = args(0).xstring_value ("popen2: COMMAND argument must be a string");
 
-          for (int i = 0; i < len; i++)
-            arg_list[i+1] = tmp[i];
-        }
-      else
-        {
-          arg_list.resize (1);
-
-          arg_list[0] = exec_file;
-        }
-
-      bool sync_mode = (nargin == 3 ? args(2).bool_value () : false);
+  string_vector arg_list;
 
-      int fildes[2];
-      std::string msg;
-      pid_t pid;
+  if (nargin >= 2)
+    {
+      string_vector tmp = args(1).xall_strings ("popen2: all arguments must be strings");
 
-      pid = octave_syscalls::popen2 (exec_file, arg_list, sync_mode,
-                                     fildes, msg, interactive);
-      if (pid >= 0)
-        {
-          FILE *ifile = fdopen (fildes[1], "r");
-          FILE *ofile = fdopen (fildes[0], "w");
-
-          std::string nm;
+      int len = tmp.numel ();
 
-          octave_stream is = octave_stdiostream::create (exec_file + "-in",
-                                                         ifile,
-                                                         std::ios::in);
-
-          octave_stream os = octave_stdiostream::create (exec_file + "-out",
-                                                         ofile,
-                                                         std::ios::out);
+      arg_list.resize (len + 1);
 
-          Cell file_ids (1, 2);
+      arg_list[0] = exec_file;
 
-          retval(2) = pid;
-          retval(1) = octave_stream_list::insert (is);
-          retval(0) = octave_stream_list::insert (os);
-        }
-      else
-        error (msg.c_str ());
+      for (int i = 0; i < len; i++)
+        arg_list[i+1] = tmp[i];
     }
   else
-    print_usage ();
+    {
+      arg_list.resize (1);
+
+      arg_list[0] = exec_file;
+    }
+
+  bool sync_mode = (nargin == 3 ? args(2).bool_value () : false);
+
+  int fildes[2];
+  std::string msg;
+  pid_t pid;
+
+  pid = octave_syscalls::popen2 (exec_file, arg_list, sync_mode,
+                                 fildes, msg, interactive);
+  if (pid >= 0)
+    {
+      FILE *ifile = fdopen (fildes[1], "r");
+      FILE *ofile = fdopen (fildes[0], "w");
+
+      std::string nm;
+
+      octave_stream is = octave_stdiostream::create (exec_file + "-in",
+                                                     ifile,
+                                                     std::ios::in);
+
+      octave_stream os = octave_stdiostream::create (exec_file + "-out",
+                                                     ofile,
+                                                     std::ios::out);
+
+      Cell file_ids (1, 2);
+
+      retval(2) = pid;
+      retval(1) = octave_stream_list::insert (is);
+      retval(0) = octave_stream_list::insert (os);
+    }
+  else
+    error (msg.c_str ());
 
   return retval;
 }
 
 /*
 
 %!test  # UNIX-style test
 %! if (isunix () || ismac ())
@@ -474,40 +468,38 @@ message.\n\
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
-  if (nargin == 3)
-    {
-      octave_stream strm = octave_stream_list::lookup (args(0), "fcntl");
+  if (nargin != 3)
+    print_usage ();
+
+  octave_stream strm = octave_stream_list::lookup (args(0), "fcntl");
 
-      int fid = strm.file_number ();
+  int fid = strm.file_number ();
 
-      int req = args(1).int_value (true);
-      int arg = args(2).int_value (true);
+  int req = args(1).int_value (true);
+  int arg = args(2).int_value (true);
 
-      // FIXME: Need better checking here?
-      if (fid < 0)
-        error ("fcntl: invalid file id");
-      else
-        {
-          std::string msg;
+  // FIXME: Need better checking here?
+  if (fid < 0)
+    error ("fcntl: invalid file id");
+  else
+    {
+      std::string msg;
 
-          int status = octave_fcntl (fid, req, arg, msg);
+      int status = octave_fcntl (fid, req, arg, msg);
 
-          retval(1) = msg;
-          retval(0) = status;
-        }
+      retval(1) = msg;
+      retval(0) = status;
     }
-  else
-    print_usage ();
 
   return retval;
 }
 
 DEFUNX ("fork", Ffork, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{pid}, @var{msg}] =} fork ()\n\
 Create a copy of the current process.\n\
@@ -532,27 +524,25 @@ action.  A system dependent error messag
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
-  if (nargin == 0)
-    {
-      std::string msg;
+  if (nargin != 0)
+    print_usage ();
 
-      pid_t pid = octave_syscalls::fork (msg);
+  std::string msg;
 
-      retval(1) = msg;
-      retval(0) = pid;
-    }
-  else
-    print_usage ();
+  pid_t pid = octave_syscalls::fork (msg);
+
+  retval(1) = msg;
+  retval(0) = pid;
 
   return retval;
 }
 
 DEFUNX ("getpgrp", Fgetpgrp, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {pgid =} getpgrp ()\n\
 Return the process group id of the current process.\n\
@@ -560,103 +550,85 @@ Return the process group id of the curre
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1;
 
   int nargin = args.length ();
 
-  if (nargin == 0)
-    {
-      std::string msg;
+  if (nargin != 0)
+    print_usage ();
 
-      retval(1) = msg;
-      retval(0) = octave_syscalls::getpgrp (msg);
-    }
-  else
-    print_usage ();
+  std::string msg;
+
+  retval(1) = msg;
+  retval(0) = octave_syscalls::getpgrp (msg);
 
   return retval;
 }
 
 DEFUNX ("getpid", Fgetpid, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {pid =} getpid ()\n\
 Return the process id of the current process.\n\
 @seealso{getppid}\n\
 @end deftypefn")
 {
-  octave_value retval = -1;
-
   int nargin = args.length ();
 
-  if (nargin == 0)
-    retval = octave_syscalls::getpid ();
-  else
+  if (nargin != 0)
     print_usage ();
 
-  return retval;
+  return octave_value (octave_syscalls::getpid ());
 }
 
 DEFUNX ("getppid", Fgetppid, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {pid =} getppid ()\n\
 Return the process id of the parent process.\n\
 @seealso{getpid}\n\
 @end deftypefn")
 {
-  octave_value retval = -1;
-
   int nargin = args.length ();
 
-  if (nargin == 0)
-    retval = octave_syscalls::getppid ();
-  else
+  if (nargin != 0)
     print_usage ();
 
-  return retval;
+  return octave_value (octave_syscalls::getppid ());
 }
 
 DEFUNX ("getegid", Fgetegid, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {egid =} getegid ()\n\
 Return the effective group id of the current process.\n\
 @seealso{getgid}\n\
 @end deftypefn")
 {
-  octave_value retval = -1;
-
   int nargin = args.length ();
 
-  if (nargin == 0)
-    retval = octave_syscalls::getegid ();
-  else
+  if (nargin != 0)
     print_usage ();
 
-  return retval;
+  return octave_value (octave_syscalls::getegid ());
 }
 
 DEFUNX ("getgid", Fgetgid, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {gid =} getgid ()\n\
 Return the real group id of the current process.\n\
 @seealso{getegid}\n\
 @end deftypefn")
 {
-  octave_value retval = -1;
-
   int nargin = args.length ();
 
-  if (nargin == 0)
-    retval = octave_syscalls::getgid ();
-  else
+  if (nargin != 0)
     print_usage ();
 
-  return retval;
+  return octave_value (octave_syscalls::getgid ());
 }
 
 DEFUNX ("geteuid", Fgeteuid, args, ,
         "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {euid =} geteuid ()\n\
 Return the effective user id of the current process.\n\
 @seealso{getuid}\n\
 @end deftypefn")
diff --git a/libinterp/corefcn/time.cc b/libinterp/corefcn/time.cc
--- a/libinterp/corefcn/time.cc
+++ b/libinterp/corefcn/time.cc
@@ -109,24 +109,20 @@ DEFUN (time, args, ,
 Return the current time as the number of seconds since the epoch.\n\
 \n\
 The epoch is referenced to 00:00:00 CUT (Coordinated Universal Time) 1 Jan\n\
 1970.  For example, on Monday February 17, 1997 at 07:15:06 CUT, the value\n\
 returned by @code{time} was 856163706.\n\
 @seealso{strftime, strptime, localtime, gmtime, mktime, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 0)
-    retval = octave_time ();
-  else
+  if (args.length () != 0)
     print_usage ();
 
-  return retval;
+  return octave_value (octave_time ());
 }
 
 /*
 %!assert (time () > 0)
 
 %!error time (1)
 */
 
@@ -155,28 +151,22 @@ gmtime (time ())\n\
            gmtoff = 0\n\
            zone = GMT\n\
         @}\n\
 @end group\n\
 @end example\n\
 @seealso{strftime, strptime, localtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    {
-      double tmp = args(0).double_value ();
-
-      retval = octave_value (mk_tm_map (octave_gmtime (tmp)));
-    }
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  double tmp = args(0).double_value ();
+
+  return octave_value (mk_tm_map (octave_gmtime (tmp)));
 }
 
 /*
 %!test
 %! ts = gmtime (time ());
 %! assert (isstruct (ts));
 %! assert (isfield (ts, "usec"));
 %! assert (isfield (ts, "year"));
@@ -216,28 +206,22 @@ localtime (time ())\n\
            gmtoff = -21600\n\
            zone = CST\n\
         @}\n\
 @end group\n\
 @end example\n\
 @seealso{strftime, strptime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    {
-      double tmp = args(0).double_value ();
-
-      retval = octave_value (mk_tm_map (octave_localtime (tmp)));
-    }
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  double tmp = args(0).double_value ();
+
+  return octave_value (mk_tm_map (octave_localtime (tmp)));
 }
 
 /*
 %!test
 %! ts = localtime (time ());
 %! assert (isstruct (ts));
 %! assert (isfield (ts, "usec"));
 %! assert (isfield (ts, "year"));
@@ -266,30 +250,24 @@ For example:\n\
 @group\n\
 mktime (localtime (time ()))\n\
      @result{} 856163706\n\
 @end group\n\
 @end example\n\
 @seealso{strftime, strptime, localtime, gmtime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 1)
-    {
-      octave_scalar_map map = args(0).xscalar_map_value ("mktime: TM_STRUCT argument must be a structure");
-
-      octave_base_tm tm = extract_tm (map, "mktime");
-
-      retval = octave_time (tm);
-    }
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  octave_scalar_map map = args(0).xscalar_map_value ("mktime: TM_STRUCT argument must be a structure");
+
+  octave_base_tm tm = extract_tm (map, "mktime");
+
+  return octave_value (octave_time (tm));
 }
 
 /*
 %!test
 %! t = time ();
 %! assert (fix (mktime (localtime (t))) == fix (t));
 
 ## These tests fail on systems with mktime functions of limited
@@ -459,30 +437,26 @@ Last two digits of year (00-99).\n\
 @item %Y\n\
 Year (1970-).\n\
 @end table\n\
 @seealso{strptime, localtime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length () == 2)
-    {
-      std::string fmt = args(0).xstring_value ("strftime: FMT must be a string");
-
-      octave_scalar_map map = args(1).xscalar_map_value ("strftime: TM_STRUCT must be a structure");
-
-      octave_base_tm tm = extract_tm (map, "strftime");
-
-      retval = tm.strftime (fmt);
-    }
-  else
+  if (args.length () != 2)
     print_usage ();
 
-  return retval;
+  std::string fmt = args(0).xstring_value ("strftime: FMT must be a string");
+
+  octave_scalar_map map = args(1).xscalar_map_value ("strftime: TM_STRUCT must be a structure");
+
+  octave_base_tm tm = extract_tm (map, "strftime");
+
+  return octave_value (tm.strftime (fmt));
 }
 
 /*
 %!assert (ischar (strftime ("%%%n%t%H%I%k%l", localtime (time ()))));
 %!assert (ischar (strftime ("%M%p%r%R%s%S%T", localtime (time ()))));
 %!assert (ischar (strftime ("%X%Z%z%a%A%b%B", localtime (time ()))));
 %!assert (ischar (strftime ("%c%C%d%e%D%h%j", localtime (time ()))));
 %!assert (ischar (strftime ("%m%U%w%W%x%y%Y", localtime (time ()))));
@@ -502,29 +476,27 @@ the control of the format string @var{fm
 If @var{fmt} fails to match, @var{nchars} is 0; otherwise, it is set to the\n\
 position of last matched character plus 1. Always check for this unless\n\
 you're absolutely sure the date string will be parsed correctly.\n\
 @seealso{strftime, localtime, gmtime, mktime, time, now, date, clock, datenum, datestr, datevec, calendar, weekday}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  if (args.length () == 2)
-    {
-      std::string str = args(0).xstring_value ("strptime: argument STR must be a string");
+  if (args.length () != 2)
+    print_usage ();
 
-      std::string fmt = args(1).xstring_value ("strptime: FMT must be a string");
+  std::string str = args(0).xstring_value ("strptime: argument STR must be a string");
 
-      octave_strptime t (str, fmt);
+  std::string fmt = args(1).xstring_value ("strptime: FMT must be a string");
 
-      retval(1) = t.characters_converted ();
-      retval(0) = octave_value (mk_tm_map (t));
-    }
-  else
-    print_usage ();
+  octave_strptime t (str, fmt);
+
+  retval(1) = t.characters_converted ();
+  retval(0) = octave_value (mk_tm_map (t));
 
   return retval;
 }
 
 /*
 %!test
 %! fmt = "%Y-%m-%d %H:%M:%S";
 %! s = strftime (fmt, localtime (time ()));
diff --git a/libinterp/corefcn/tril.cc b/libinterp/corefcn/tril.cc
--- a/libinterp/corefcn/tril.cc
+++ b/libinterp/corefcn/tril.cc
@@ -201,138 +201,142 @@ do_trilu (const std::string& name,
       nargin--;
     }
 
   if (nargin == 2)
     k = args(1).int_value (true);
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
+
+  octave_value arg = args(0);
+
+  dim_vector dims = arg.dims ();
+  if (dims.length () != 2)
+    error ("%s: need a 2-D matrix", name.c_str ());
+  else if (k < -dims(0) || k > dims(1))
+    error ("%s: requested diagonal out of range", name.c_str ());
   else
     {
-      octave_value arg = args(0);
-
-      dim_vector dims = arg.dims ();
-      if (dims.length () != 2)
-        error ("%s: need a 2-D matrix", name.c_str ());
-      else if (k < -dims(0) || k > dims(1))
-        error ("%s: requested diagonal out of range", name.c_str ());
-      else
+      switch (arg.builtin_type ())
         {
-          switch (arg.builtin_type ())
-            {
-            case btyp_double:
-              if (arg.is_sparse_type ())
-                retval = do_trilu (arg.sparse_matrix_value (), k, lower, pack);
-              else
-                retval = do_trilu (arg.array_value (), k, lower, pack);
-              break;
-            case btyp_complex:
-              if (arg.is_sparse_type ())
-                retval = do_trilu (arg.sparse_complex_matrix_value (), k, lower,
-                                   pack);
-              else
-                retval = do_trilu (arg.complex_array_value (), k, lower, pack);
-              break;
-            case btyp_bool:
-              if (arg.is_sparse_type ())
-                retval = do_trilu (arg.sparse_bool_matrix_value (), k, lower,
-                                   pack);
-              else
-                retval = do_trilu (arg.bool_array_value (), k, lower, pack);
-              break;
-#define ARRAYCASE(TYP) \
-            case btyp_ ## TYP: \
-              retval = do_trilu (arg.TYP ## _array_value (), k, lower, pack); \
-              break
-            ARRAYCASE (float);
-            ARRAYCASE (float_complex);
-            ARRAYCASE (int8);
-            ARRAYCASE (int16);
-            ARRAYCASE (int32);
-            ARRAYCASE (int64);
-            ARRAYCASE (uint8);
-            ARRAYCASE (uint16);
-            ARRAYCASE (uint32);
-            ARRAYCASE (uint64);
-            ARRAYCASE (char);
+        case btyp_double:
+          if (arg.is_sparse_type ())
+            retval = do_trilu (arg.sparse_matrix_value (), k, lower, pack);
+          else
+            retval = do_trilu (arg.array_value (), k, lower, pack);
+          break;
+
+        case btyp_complex:
+          if (arg.is_sparse_type ())
+            retval = do_trilu (arg.sparse_complex_matrix_value (), k, lower,
+                               pack);
+          else
+            retval = do_trilu (arg.complex_array_value (), k, lower, pack);
+          break;
+
+        case btyp_bool:
+          if (arg.is_sparse_type ())
+            retval = do_trilu (arg.sparse_bool_matrix_value (), k, lower,
+                               pack);
+          else
+            retval = do_trilu (arg.bool_array_value (), k, lower, pack);
+          break;
+
+#define ARRAYCASE(TYP)       \
+          case btyp_ ## TYP: \
+            retval = do_trilu (arg.TYP ## _array_value (), k, lower, pack); \
+            break
+
+          ARRAYCASE (float);
+          ARRAYCASE (float_complex);
+          ARRAYCASE (int8);
+          ARRAYCASE (int16);
+          ARRAYCASE (int32);
+          ARRAYCASE (int64);
+          ARRAYCASE (uint8);
+          ARRAYCASE (uint16);
+          ARRAYCASE (uint32);
+          ARRAYCASE (uint64);
+          ARRAYCASE (char);
+
 #undef ARRAYCASE
-            default:
-              {
-                // Generic code that works on octave-values, that is slow
-                // but will also work on arbitrary user types
+
+        default:
+          {
+            // Generic code that works on octave-values, that is slow
+            // but will also work on arbitrary user types
 
-                if (pack) // FIXME
-                  {
-                    error ("%s: \"pack\" not implemented for class %s",
-                           name.c_str (), arg.class_name ().c_str ());
-                    return octave_value ();
-                  }
+            if (pack) // FIXME
+              {
+                error ("%s: \"pack\" not implemented for class %s",
+                       name.c_str (), arg.class_name ().c_str ());
+                return octave_value ();
+              }
 
-                octave_value tmp = arg;
-                if (arg.numel () == 0)
-                  return arg;
+            octave_value tmp = arg;
+            if (arg.numel () == 0)
+              return arg;
 
-                octave_idx_type nr = dims(0);
-                octave_idx_type nc = dims(1);
+            octave_idx_type nr = dims(0);
+            octave_idx_type nc = dims(1);
 
-                // The sole purpose of the below is to force the correct
-                // matrix size. This would not be necessary if the
-                // octave_value resize function allowed a fill_value.
-                // It also allows odd attributes in some user types
-                // to be handled. With a fill_value ot should be replaced
-                // with
-                //
-                // octave_value_list ov_idx;
-                // tmp = tmp.resize(dim_vector (0,0)).resize (dims, fill_value);
+            // The sole purpose of the below is to force the correct
+            // matrix size. This would not be necessary if the
+            // octave_value resize function allowed a fill_value.
+            // It also allows odd attributes in some user types
+            // to be handled. With a fill_value ot should be replaced
+            // with
+            //
+            // octave_value_list ov_idx;
+            // tmp = tmp.resize(dim_vector (0,0)).resize (dims, fill_value);
 
-                octave_value_list ov_idx;
-                std::list<octave_value_list> idx_tmp;
-                ov_idx(1) = static_cast<double> (nc+1);
-                ov_idx(0) = Range (1, nr);
-                idx_tmp.push_back (ov_idx);
-                ov_idx(1) = static_cast<double> (nc);
-                tmp = tmp.resize (dim_vector (0,0));
-                tmp = tmp.subsasgn ("(",idx_tmp, arg.do_index_op (ov_idx));
-                tmp = tmp.resize (dims);
-
-                if (lower)
-                  {
-                    octave_idx_type st = nc < nr + k ? nc : nr + k;
+            octave_value_list ov_idx;
+            std::list<octave_value_list> idx_tmp;
+            ov_idx(1) = static_cast<double> (nc+1);
+            ov_idx(0) = Range (1, nr);
+            idx_tmp.push_back (ov_idx);
+            ov_idx(1) = static_cast<double> (nc);
+            tmp = tmp.resize (dim_vector (0,0));
+            tmp = tmp.subsasgn ("(",idx_tmp, arg.do_index_op (ov_idx));
+            tmp = tmp.resize (dims);
 
-                    for (octave_idx_type j = 1; j <= st; j++)
-                      {
-                        octave_idx_type nr_limit = 1 > j - k ? 1 : j - k;
-                        ov_idx(1) = static_cast<double> (j);
-                        ov_idx(0) = Range (nr_limit, nr);
-                        std::list<octave_value_list> idx;
-                        idx.push_back (ov_idx);
+            if (lower)
+              {
+                octave_idx_type st = nc < nr + k ? nc : nr + k;
 
-                        tmp = tmp.subsasgn ("(", idx, arg.do_index_op (ov_idx));
-                      }
-                  }
-                else
+                for (octave_idx_type j = 1; j <= st; j++)
                   {
-                    octave_idx_type st = k + 1 > 1 ? k + 1 : 1;
+                    octave_idx_type nr_limit = 1 > j - k ? 1 : j - k;
+                    ov_idx(1) = static_cast<double> (j);
+                    ov_idx(0) = Range (nr_limit, nr);
+                    std::list<octave_value_list> idx;
+                    idx.push_back (ov_idx);
 
-                    for (octave_idx_type j = st; j <= nc; j++)
-                      {
-                        octave_idx_type nr_limit = nr < j - k ? nr : j - k;
-                        ov_idx(1) = static_cast<double> (j);
-                        ov_idx(0) = Range (1, nr_limit);
-                        std::list<octave_value_list> idx;
-                        idx.push_back (ov_idx);
+                    tmp = tmp.subsasgn ("(", idx, arg.do_index_op (ov_idx));
+                  }
+              }
+            else
+              {
+                octave_idx_type st = k + 1 > 1 ? k + 1 : 1;
 
-                        tmp = tmp.subsasgn ("(", idx, arg.do_index_op (ov_idx));
-                      }
-                  }
+                for (octave_idx_type j = st; j <= nc; j++)
+                  {
+                    octave_idx_type nr_limit = nr < j - k ? nr : j - k;
+                    ov_idx(1) = static_cast<double> (j);
+                    ov_idx(0) = Range (1, nr_limit);
+                    std::list<octave_value_list> idx;
+                    idx.push_back (ov_idx);
 
-                retval = tmp;
+                    tmp = tmp.subsasgn ("(", idx, arg.do_index_op (ov_idx));
+                  }
               }
-            }
+
+            retval = tmp;
+          }
         }
     }
 
   return retval;
 }
 
 DEFUN (tril, args, ,
        "-*- texinfo -*-\n\
diff --git a/libinterp/corefcn/typecast.cc b/libinterp/corefcn/typecast.cc
--- a/libinterp/corefcn/typecast.cc
+++ b/libinterp/corefcn/typecast.cc
@@ -140,129 +140,127 @@ typecast (@var{x}, \"uint8\")\n\
 @result{} [   1,   0, 255, 255]\n\
 @end group\n\
 @end example\n\
 @seealso{cast, bitpack, bitunpack, swapbytes}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length () == 2)
-    {
-      unwind_protect frame;
-      const void *data = 0;
-      octave_idx_type byte_size = 0;
-      dim_vector old_dims;
+  if (args.length () != 2)
+    print_usage ();
+
+  unwind_protect frame;
+  const void *data = 0;
+  octave_idx_type byte_size = 0;
+  dim_vector old_dims;
+
+  octave_value array = args(0);
 
-      octave_value array = args(0);
-
-      if (array.is_bool_type ())
-        get_data_and_bytesize (array.bool_array_value (), data, byte_size,
+  if (array.is_bool_type ())
+    get_data_and_bytesize (array.bool_array_value (), data, byte_size,
+                           old_dims, frame);
+  else if (array.is_string ())
+    get_data_and_bytesize (array.char_array_value (), data, byte_size,
+                           old_dims, frame);
+  else if (array.is_integer_type ())
+    {
+      if (array.is_int8_type ())
+        get_data_and_bytesize (array.int8_array_value (), data, byte_size,
+                               old_dims, frame);
+      else if (array.is_int16_type ())
+        get_data_and_bytesize (array.int16_array_value (), data, byte_size,
                                old_dims, frame);
-      else if (array.is_string ())
-        get_data_and_bytesize (array.char_array_value (), data, byte_size,
+      else if (array.is_int32_type ())
+        get_data_and_bytesize (array.int32_array_value (), data, byte_size,
+                               old_dims, frame);
+      else if (array.is_int64_type ())
+        get_data_and_bytesize (array.int64_array_value (), data, byte_size,
+                               old_dims, frame);
+      else if (array.is_uint8_type ())
+        get_data_and_bytesize (array.uint8_array_value (), data, byte_size,
+                               old_dims, frame);
+      else if (array.is_uint16_type ())
+        get_data_and_bytesize (array.uint16_array_value (), data, byte_size,
+                               old_dims, frame);
+      else if (array.is_uint32_type ())
+        get_data_and_bytesize (array.uint32_array_value (), data, byte_size,
+                               old_dims, frame);
+      else if (array.is_uint64_type ())
+        get_data_and_bytesize (array.uint64_array_value (), data, byte_size,
                                old_dims, frame);
-      else if (array.is_integer_type ())
-        {
-          if (array.is_int8_type ())
-            get_data_and_bytesize (array.int8_array_value (), data, byte_size,
-                                   old_dims, frame);
-          else if (array.is_int16_type ())
-            get_data_and_bytesize (array.int16_array_value (), data, byte_size,
-                                   old_dims, frame);
-          else if (array.is_int32_type ())
-            get_data_and_bytesize (array.int32_array_value (), data, byte_size,
-                                   old_dims, frame);
-          else if (array.is_int64_type ())
-            get_data_and_bytesize (array.int64_array_value (), data, byte_size,
-                                   old_dims, frame);
-          else if (array.is_uint8_type ())
-            get_data_and_bytesize (array.uint8_array_value (), data, byte_size,
-                                   old_dims, frame);
-          else if (array.is_uint16_type ())
-            get_data_and_bytesize (array.uint16_array_value (), data, byte_size,
-                                   old_dims, frame);
-          else if (array.is_uint32_type ())
-            get_data_and_bytesize (array.uint32_array_value (), data, byte_size,
-                                   old_dims, frame);
-          else if (array.is_uint64_type ())
-            get_data_and_bytesize (array.uint64_array_value (), data, byte_size,
-                                   old_dims, frame);
-          else
-            assert (0);
-        }
-      else if (array.is_complex_type ())
-        {
-          if (array.is_single_type ())
-            get_data_and_bytesize (array.float_complex_array_value (), data,
-                                   byte_size, old_dims, frame);
-          else
-            get_data_and_bytesize (array.complex_array_value (), data,
-                                   byte_size, old_dims, frame);
-        }
-      else if (array.is_real_type ())
-        {
-          if (array.is_single_type ())
-            get_data_and_bytesize (array.float_array_value (), data, byte_size,
-                                   old_dims, frame);
-          else
-            get_data_and_bytesize (array.array_value (), data, byte_size,
-                                   old_dims, frame); }
+      else
+        assert (0);
+    }
+  else if (array.is_complex_type ())
+    {
+      if (array.is_single_type ())
+        get_data_and_bytesize (array.float_complex_array_value (), data,
+                               byte_size, old_dims, frame);
+      else
+        get_data_and_bytesize (array.complex_array_value (), data,
+                               byte_size, old_dims, frame);
+    }
+  else if (array.is_real_type ())
+    {
+      if (array.is_single_type ())
+        get_data_and_bytesize (array.float_array_value (), data, byte_size,
+                               old_dims, frame);
       else
-        error ("typecast: invalid input class: %s",
-                                                array.class_name ().c_str ());
+        get_data_and_bytesize (array.array_value (), data, byte_size,
+                               old_dims, frame); }
+  else
+    error ("typecast: invalid input class: %s",
+           array.class_name ().c_str ());
 
-      std::string numclass = args(1).string_value ();
+  std::string numclass = args(1).string_value ();
 
-      if (numclass.size () == 0)
-        ;
-      else if (numclass == "char")
-        retval = octave_value (reinterpret_copy<charNDArray>
-                   (data, byte_size, old_dims), array.is_dq_string () ? '"'
-                                                                      : '\'');
-      else if (numclass[0] == 'i')
-        {
-          if (numclass == "int8")
-            retval = reinterpret_copy<int8NDArray> (data, byte_size, old_dims);
-          else if (numclass == "int16")
-            retval = reinterpret_copy<int16NDArray> (data, byte_size, old_dims);
-          else if (numclass == "int32")
-            retval = reinterpret_copy<int32NDArray> (data, byte_size, old_dims);
-          else if (numclass == "int64")
-            retval = reinterpret_copy<int64NDArray> (data, byte_size, old_dims);
-        }
-      else if (numclass[0] == 'u')
-        {
-          if (numclass == "uint8")
-            retval = reinterpret_copy<uint8NDArray> (data, byte_size, old_dims);
-          else if (numclass == "uint16")
-            retval = reinterpret_copy<uint16NDArray> (data, byte_size,
-                                                      old_dims);
-          else if (numclass == "uint32")
-            retval = reinterpret_copy<uint32NDArray> (data, byte_size,
-                                                      old_dims);
-          else if (numclass == "uint64")
-            retval = reinterpret_copy<uint64NDArray> (data, byte_size,
-                                                      old_dims);
-        }
-      else if (numclass == "single")
-        retval = reinterpret_copy<FloatNDArray> (data, byte_size, old_dims);
-      else if (numclass == "double")
-        retval = reinterpret_copy<NDArray> (data, byte_size, old_dims);
-      else if (numclass == "single complex")
-        retval = reinterpret_copy<FloatComplexNDArray> (data, byte_size,
-                                                        old_dims);
-      else if (numclass == "double complex")
-        retval = reinterpret_copy<ComplexNDArray> (data, byte_size, old_dims);
+  if (numclass.size () == 0)
+    ;
+  else if (numclass == "char")
+    retval = octave_value (reinterpret_copy<charNDArray>
+                           (data, byte_size, old_dims), array.is_dq_string () ? '"'
+                           : '\'');
+  else if (numclass[0] == 'i')
+    {
+      if (numclass == "int8")
+        retval = reinterpret_copy<int8NDArray> (data, byte_size, old_dims);
+      else if (numclass == "int16")
+        retval = reinterpret_copy<int16NDArray> (data, byte_size, old_dims);
+      else if (numclass == "int32")
+        retval = reinterpret_copy<int32NDArray> (data, byte_size, old_dims);
+      else if (numclass == "int64")
+        retval = reinterpret_copy<int64NDArray> (data, byte_size, old_dims);
+    }
+  else if (numclass[0] == 'u')
+    {
+      if (numclass == "uint8")
+        retval = reinterpret_copy<uint8NDArray> (data, byte_size, old_dims);
+      else if (numclass == "uint16")
+        retval = reinterpret_copy<uint16NDArray> (data, byte_size,
+                                                  old_dims);
+      else if (numclass == "uint32")
+        retval = reinterpret_copy<uint32NDArray> (data, byte_size,
+                                                  old_dims);
+      else if (numclass == "uint64")
+        retval = reinterpret_copy<uint64NDArray> (data, byte_size,
+                                                  old_dims);
+    }
+  else if (numclass == "single")
+    retval = reinterpret_copy<FloatNDArray> (data, byte_size, old_dims);
+  else if (numclass == "double")
+    retval = reinterpret_copy<NDArray> (data, byte_size, old_dims);
+  else if (numclass == "single complex")
+    retval = reinterpret_copy<FloatComplexNDArray> (data, byte_size,
+                                                    old_dims);
+  else if (numclass == "double complex")
+    retval = reinterpret_copy<ComplexNDArray> (data, byte_size, old_dims);
 
-      if (retval.is_undefined ())
-        error ("typecast: cannot convert to %s class", numclass.c_str ());
-    }
-  else
-    print_usage ();
+  if (retval.is_undefined ())
+    error ("typecast: cannot convert to %s class", numclass.c_str ());
 
   return retval;
 }
 
 template <class ArrayType>
 ArrayType
 do_bitpack (const boolNDArray& bitp)
 {
@@ -334,62 +332,61 @@ The result is a row vector if @var{x} is
 column vector.\n\
 @seealso{bitunpack, typecast}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () != 2)
     print_usage ();
-  else if (! args(0).is_bool_type ())
+
+  if (! args(0).is_bool_type ())
     error ("bitpack: X must be a logical array");
-  else
-    {
-      boolNDArray bitp = args(0).bool_array_value ();
 
-      std::string numclass = args(1).string_value ();
+  boolNDArray bitp = args(0).bool_array_value ();
+
+  std::string numclass = args(1).string_value ();
 
-      if (numclass.size () == 0)
-        ;
-      else if (numclass == "char")
-        retval = octave_value (do_bitpack<charNDArray> (bitp), '\'');
-      else if (numclass[0] == 'i')
-        {
-          if (numclass == "int8")
-            retval = do_bitpack<int8NDArray> (bitp);
-          else if (numclass == "int16")
-            retval = do_bitpack<int16NDArray> (bitp);
-          else if (numclass == "int32")
-            retval = do_bitpack<int32NDArray> (bitp);
-          else if (numclass == "int64")
-            retval = do_bitpack<int64NDArray> (bitp);
-        }
-      else if (numclass[0] == 'u')
-        {
-          if (numclass == "uint8")
-            retval = do_bitpack<uint8NDArray> (bitp);
-          else if (numclass == "uint16")
-            retval = do_bitpack<uint16NDArray> (bitp);
-          else if (numclass == "uint32")
-            retval = do_bitpack<uint32NDArray> (bitp);
-          else if (numclass == "uint64")
-            retval = do_bitpack<uint64NDArray> (bitp);
-        }
-      else if (numclass == "single")
-        retval = do_bitpack<FloatNDArray> (bitp);
-      else if (numclass == "double")
-        retval = do_bitpack<NDArray> (bitp);
-      else if (numclass == "single complex")
-        retval = do_bitpack<FloatComplexNDArray> (bitp);
-      else if (numclass == "double complex")
-        retval = do_bitpack<ComplexNDArray> (bitp);
+  if (numclass.size () == 0)
+    ;
+  else if (numclass == "char")
+    retval = octave_value (do_bitpack<charNDArray> (bitp), '\'');
+  else if (numclass[0] == 'i')
+    {
+      if (numclass == "int8")
+        retval = do_bitpack<int8NDArray> (bitp);
+      else if (numclass == "int16")
+        retval = do_bitpack<int16NDArray> (bitp);
+      else if (numclass == "int32")
+        retval = do_bitpack<int32NDArray> (bitp);
+      else if (numclass == "int64")
+        retval = do_bitpack<int64NDArray> (bitp);
+    }
+  else if (numclass[0] == 'u')
+    {
+      if (numclass == "uint8")
+        retval = do_bitpack<uint8NDArray> (bitp);
+      else if (numclass == "uint16")
+        retval = do_bitpack<uint16NDArray> (bitp);
+      else if (numclass == "uint32")
+        retval = do_bitpack<uint32NDArray> (bitp);
+      else if (numclass == "uint64")
+        retval = do_bitpack<uint64NDArray> (bitp);
+    }
+  else if (numclass == "single")
+    retval = do_bitpack<FloatNDArray> (bitp);
+  else if (numclass == "double")
+    retval = do_bitpack<NDArray> (bitp);
+  else if (numclass == "single complex")
+    retval = do_bitpack<FloatComplexNDArray> (bitp);
+  else if (numclass == "double complex")
+    retval = do_bitpack<ComplexNDArray> (bitp);
 
-      if (retval.is_undefined ())
-        error ("bitpack: cannot pack to %s class", numclass.c_str ());
-    }
+  if (retval.is_undefined ())
+    error ("bitpack: cannot pack to %s class", numclass.c_str ());
 
   return retval;
 }
 
 template <class ArrayType>
 boolNDArray
 do_bitunpack (const ArrayType& array)
 {
@@ -442,59 +439,59 @@ Return a logical array @var{y} correspon
 \n\
 The result is a row vector if @var{x} is a row vector; otherwise, it is a\n\
 column vector.\n\
 @seealso{bitpack, typecast}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  if (args.length () == 1
-      && (args(0).is_numeric_type () || args(0).is_string ()))
-    {
-      octave_value array = args(0);
+  if (args.length () != 1)
+    print_usage ();
+  
+  if (! (args(0).is_numeric_type () || args(0).is_string ()))
+    error ("bitunpack: argument must be a number or a string");
+
+  octave_value array = args(0);
 
-      if (array.is_string ())
-        retval = do_bitunpack (array.char_array_value ());
-      else if (array.is_integer_type ())
-        {
-          if (array.is_int8_type ())
-            retval = do_bitunpack (array.int8_array_value ());
-          else if (array.is_int16_type ())
-            retval = do_bitunpack (array.int16_array_value ());
-          else if (array.is_int32_type ())
-            retval = do_bitunpack (array.int32_array_value ());
-          else if (array.is_int64_type ())
-            retval = do_bitunpack (array.int64_array_value ());
-          else if (array.is_uint8_type ())
-            retval = do_bitunpack (array.uint8_array_value ());
-          else if (array.is_uint16_type ())
-            retval = do_bitunpack (array.uint16_array_value ());
-          else if (array.is_uint32_type ())
-            retval = do_bitunpack (array.uint32_array_value ());
-          else if (array.is_uint64_type ())
-            retval = do_bitunpack (array.uint64_array_value ());
-          else
-            assert (0);
-        }
-      else if (array.is_complex_type ())
-        {
-          if (array.is_single_type ())
-            retval = do_bitunpack (array.float_complex_array_value ());
-          else
-            retval = do_bitunpack (array.complex_array_value ());
-        }
-      else if (array.is_real_type ())
-        {
-          if (array.is_single_type ())
-            retval = do_bitunpack (array.float_array_value ());
-          else
-            retval = do_bitunpack (array.array_value ());
-        }
+  if (array.is_string ())
+    retval = do_bitunpack (array.char_array_value ());
+  else if (array.is_integer_type ())
+    {
+      if (array.is_int8_type ())
+        retval = do_bitunpack (array.int8_array_value ());
+      else if (array.is_int16_type ())
+        retval = do_bitunpack (array.int16_array_value ());
+      else if (array.is_int32_type ())
+        retval = do_bitunpack (array.int32_array_value ());
+      else if (array.is_int64_type ())
+        retval = do_bitunpack (array.int64_array_value ());
+      else if (array.is_uint8_type ())
+        retval = do_bitunpack (array.uint8_array_value ());
+      else if (array.is_uint16_type ())
+        retval = do_bitunpack (array.uint16_array_value ());
+      else if (array.is_uint32_type ())
+        retval = do_bitunpack (array.uint32_array_value ());
+      else if (array.is_uint64_type ())
+        retval = do_bitunpack (array.uint64_array_value ());
       else
-        error ("bitunpack: invalid input class: %s",
-                                                 array.class_name ().c_str ());
+        assert (0);
+    }
+  else if (array.is_complex_type ())
+    {
+      if (array.is_single_type ())
+        retval = do_bitunpack (array.float_complex_array_value ());
+      else
+        retval = do_bitunpack (array.complex_array_value ());
+    }
+  else if (array.is_real_type ())
+    {
+      if (array.is_single_type ())
+        retval = do_bitunpack (array.float_array_value ());
+      else
+        retval = do_bitunpack (array.array_value ());
     }
   else
-    print_usage ();
+    error ("bitunpack: invalid input class: %s",
+           array.class_name ().c_str ());
 
   return retval;
 }
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -100,19 +100,21 @@ Return true if @var{name} is a valid var
 @end deftypefn")
 {
   octave_value retval = false;
 
   int nargin = args.length ();
 
   if (nargin != 1)
     print_usage ();
-  else if (args(0).is_string ())
+
+  if (args(0).is_string ())
     {
       std::string varname = args(0).string_value ();
+
       retval = valid_identifier (varname) && ! is_keyword (varname);
     }
 
   return retval;
 }
 
 /*
 %!assert (isvarname ("foo"), true)
@@ -307,41 +309,39 @@ array containing the list of all files t
 If no files are found, return an empty cell array.\n\
 @seealso{file_in_path, dir_in_loadpath, path}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 1 || nargin == 2)
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+
+  string_vector names = args(0).xall_strings ("file_in_loadpath: FILE argument must be a string");
+
+  if (names.numel () > 0)
     {
-      string_vector names = args(0).xall_strings ("file_in_loadpath: FILE argument must be a string");
-
-      if (names.numel () > 0)
+      if (nargin == 1)
+        retval =
+          octave_env::make_absolute (load_path::find_first_of (names));
+      else if (nargin == 2)
         {
-          if (nargin == 1)
-            retval =
-              octave_env::make_absolute (load_path::find_first_of (names));
-          else if (nargin == 2)
-            {
-              std::string opt = args(1).xstring_value ("file_in_loadpath: optional second argument must be a string");
+          std::string opt = args(1).xstring_value ("file_in_loadpath: optional second argument must be a string");
 
-              if (opt == "all")
-                retval = Cell (make_absolute
-                               (load_path::find_all_first_of (names)));
-              else
-                error ("file_in_loadpath: \"all\" is only valid second argument");
-            }
+          if (opt == "all")
+            retval = Cell (make_absolute
+                           (load_path::find_all_first_of (names)));
+          else
+            error ("file_in_loadpath: \"all\" is only valid second argument");
         }
-      else
-        error ("file_in_loadpath: FILE argument must not be empty");
     }
   else
-    print_usage ();
+    error ("file_in_loadpath: FILE argument must not be empty");
 
   return retval;
 }
 
 /*
 %!test
 %! f = file_in_loadpath ("plot.m");
 %! assert (ischar (f));
@@ -386,42 +386,40 @@ array containing the list of all files t
 If no files are found, return an empty cell array.\n\
 @seealso{file_in_loadpath, dir_in_loadpath, path}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
-  if (nargin == 2 || nargin == 3)
-    {
-      std::string path = args(0).xstring_value ("file_in_path: PATH must be a string");
+  if (nargin < 2 || nargin > 3)
+    print_usage ();
+
+  std::string path = args(0).xstring_value ("file_in_path: PATH must be a string");
 
-      string_vector names = args(1).xall_strings ("file_in_path: FILE argument must be a string");
+  string_vector names = args(1).xall_strings ("file_in_path: FILE argument must be a string");
 
-      if (names.numel () > 0)
+  if (names.numel () > 0)
+    {
+      if (nargin == 2)
+        retval = search_path_for_file (path, names);
+      else if (nargin == 3)
         {
-          if (nargin == 2)
-            retval = search_path_for_file (path, names);
-          else if (nargin == 3)
-            {
-              std::string opt = args(2).xstring_value ("file_in_path: optional third argument must be a string");
+          std::string opt = args(2).xstring_value ("file_in_path: optional third argument must be a string");
 
-              if (opt == "all")
-                retval = Cell (make_absolute
-                               (search_path_for_all_files (path, names)));
-              else
-                error ("file_in_path: \"all\" is only valid third argument");
-            }
+          if (opt == "all")
+            retval = Cell (make_absolute
+                           (search_path_for_all_files (path, names)));
+          else
+            error ("file_in_path: \"all\" is only valid third argument");
         }
-      else
-        error ("file_in_path: FILE argument must not be empty");
     }
   else
-    print_usage ();
+    error ("file_in_path: FILE argument must not be empty");
 
   return retval;
 }
 
 /*
 %!test
 %! f = file_in_path (path (), "plot.m");
 %! assert (ischar (f));
@@ -745,30 +743,24 @@ DEFUN (do_string_escapes, args, ,
 Convert escape sequences in @var{string} to the characters they represent.\n\
 \n\
 Escape sequences begin with a leading backslash\n\
 (@qcode{'@xbackslashchar{}'}) followed by 1--3 characters\n\
 (.e.g., @qcode{\"@xbackslashchar{}n\"} => newline).\n\
 @seealso{undo_string_escapes}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
-  if (nargin == 1)
-    {
-      std::string str = args(0).xstring_value ("do_string_escapes: STRING argument must be of type string");
-
-      retval = do_string_escapes (str);
-    }
-  else
+  if (nargin != 1)
     print_usage ();
 
-  return retval;
+  std::string str = args(0).xstring_value ("do_string_escapes: STRING argument must be of type string");
+
+  return octave_value (do_string_escapes (str));
 }
 
 /*
 %!assert (do_string_escapes ('foo\nbar'), "foo\nbar")
 %!assert (do_string_escapes ("foo\\nbar"), "foo\nbar")
 %!assert (do_string_escapes ("foo\\nbar"), ["foo", char(10), "bar"])
 %!assert ("foo\nbar", ["foo", char(10), "bar"])
 
@@ -888,30 +880,24 @@ ans = \\a\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 replaces the unprintable alert character with its printable representation.\n\
 @seealso{do_string_escapes}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
   int nargin = args.length ();
 
-  if (nargin == 1)
-    {
-      std::string str = args(0).xstring_value ("undo_string_escapes: S argument must be a string");
-
-      retval = undo_string_escapes (str);
-    }
-  else
+  if (nargin != 1)
     print_usage ();
 
-  return retval;
+  std::string str = args(0).xstring_value ("undo_string_escapes: S argument must be a string");
+
+  return octave_value (undo_string_escapes (str));
 }
 
 /*
 %!assert (undo_string_escapes ("foo\nbar"), 'foo\nbar')
 %!assert (undo_string_escapes ("foo\nbar"), "foo\\nbar")
 %!assert (undo_string_escapes (["foo", char(10), "bar"]), "foo\\nbar")
 
 %!assert (undo_string_escapes ("\a\b\f\n\r\t\v"), '\a\b\f\n\r\t\v')
@@ -935,22 +921,22 @@ DEFUN (is_absolute_filename, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_absolute_filename (@var{file})\n\
 Return true if @var{file} is an absolute filename.\n\
 @seealso{is_rooted_relative_filename, make_absolute_filename, isdir}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
-  if (args.length () == 1)
-    retval = (args(0).is_string ()
-              && octave_env::absolute_pathname (args(0).string_value ()));
-  else
+  if (args.length () != 1)
     print_usage ();
 
+  retval = (args(0).is_string ()
+            && octave_env::absolute_pathname (args(0).string_value ()));
+
   return retval;
 }
 
 /*
 ## FIXME: We need system-dependent tests here.
 
 %!error is_absolute_filename ()
 %!error is_absolute_filename ("foo", "bar")
@@ -960,22 +946,22 @@ DEFUN (is_rooted_relative_filename, args
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} is_rooted_relative_filename (@var{file})\n\
 Return true if @var{file} is a rooted-relative filename.\n\
 @seealso{is_absolute_filename, make_absolute_filename, isdir}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
-  if (args.length () == 1)
-    retval = (args(0).is_string ()
-              && octave_env::rooted_relative_pathname (args(0).string_value ()));
-  else
+  if (args.length () != 1)
     print_usage ();
 
+  retval = (args(0).is_string ()
+            && octave_env::rooted_relative_pathname (args(0).string_value ()));
+
   return retval;
 }
 
 /*
 ## FIXME: We need system-dependent tests here.
 
 %!error is_rooted_relative_filename ()
 %!error is_rooted_relative_filename ("foo", "bar")
@@ -986,28 +972,22 @@ DEFUN (make_absolute_filename, args, ,
 @deftypefn {Built-in Function} {} make_absolute_filename (@var{file})\n\
 Return the full name of @var{file} beginning from the root of the file\n\
 system.\n\
 \n\
 No check is done for the existence of @var{file}.\n\
 @seealso{canonicalize_file_name, is_absolute_filename, is_rooted_relative_filename, isdir}\n\
 @end deftypefn")
 {
-  octave_value retval = std::string ();
-
-  if (args.length () == 1)
-    {
-      std::string nm = args(0).xstring_value ("make_absolute_filename: FILE argument must be a filename");
-
-      retval = octave_env::make_absolute (nm);
-    }
-  else
+  if (args.length () != 1)
     print_usage ();
 
-  return retval;
+  std::string nm = args(0).xstring_value ("make_absolute_filename: FILE argument must be a filename");
+
+  return octave_value (octave_env::make_absolute (nm));
 }
 
 /*
 ## FIXME: We need system-dependent tests here.
 
 %!error make_absolute_filename ()
 %!error make_absolute_filename ("foo", "bar")
 */
@@ -1030,27 +1010,25 @@ all name matches rather than just the fi
 @end deftypefn")
 {
   octave_value retval = std::string ();
 
   int nargin = args.length ();
 
   std::string dir;
 
-  if (nargin == 1 || nargin == 2)
-    {
-      dir = args(0).xstring_value ("dir_in_loadpath: DIR must be a directory name");
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
+
+  dir = args(0).xstring_value ("dir_in_loadpath: DIR must be a directory name");
 
-      if (nargin == 1)
-        retval = load_path::find_dir (dir);
-      else if (nargin == 2)
-        retval = Cell (load_path::find_matching_dirs (dir));
-    }
-  else
-    print_usage ();
+  if (nargin == 1)
+    retval = load_path::find_dir (dir);
+  else if (nargin == 2)
+    retval = Cell (load_path::find_matching_dirs (dir));
 
   return retval;
 }
 
 /*
 %!test
 %! f = dir_in_loadpath ("plot");
 %! assert (ischar (f));
@@ -1079,35 +1057,36 @@ the named error code given @var{name} as
 if @var{name} is not found.\n\
 @seealso{errno_list}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
+  if (nargin > 1)
+    print_usage ();
+
   if (nargin == 1)
     {
       if (args(0).is_string ())
         {
           std::string nm = args(0).string_value ();
 
           retval = octave_errno::lookup (nm);
         }
       else
         {
           int val = args(0).xint_value ("errno: argument must be string or integer");
 
           retval = octave_errno::set (val);
         }
     }
-  else if (nargin == 0)
+  else
     retval = octave_errno::get ();
-  else
-    print_usage ();
 
   return retval;
 }
 
 /*
 %!assert (isnumeric (errno ()))
 
 %!test
@@ -1124,24 +1103,20 @@ if @var{name} is not found.\n\
 
 DEFUN (errno_list, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} errno_list ()\n\
 Return a structure containing the system-dependent errno values.\n\
 @seealso{errno}\n\
 @end deftypefn")
 {
-  octave_value retval;
-
-  if (args.length () == 0)
-    retval = octave_errno::list ();
-  else
+  if (args.length () != 0)
     print_usage ();
 
-  return retval;
+  return octave_value (octave_errno::list ());
 }
 
 /*
 %!assert (isstruct (errno_list ()))
 
 %!error errno_list ("foo")
 */
 
@@ -1421,23 +1396,26 @@ indexed.  When possible the internal res
 indexing using @var{ind} will not perform the check again.\n\
 \n\
 Implementation Note: Strings are first converted to double values before the\n\
 checks for valid indices are made.  Unless a string contains the NULL\n\
 character @nospell{\"@xbackslashchar{}0\"}, it will always be a valid index.\n\
 @end deftypefn")
 {
   octave_value retval;
+
+  octave_idx_type n = 0;
+
   int nargin = args.length ();
-  octave_idx_type n = 0;
+
+  if (nargin < 1 || nargin > 2)
+    print_usage ();
 
   if (nargin == 2)
     n = args(1).idx_type_value ();
-  else if (nargin != 1)
-    print_usage ();
 
   unwind_protect frame;
 
   frame.protect_var (discard_error_messages);
   discard_error_messages = true;
 
   try
     {
