# HG changeset patch
# User Rik <rik@octave.org>
# Date 1546565136 28800
#      Thu Jan 03 17:25:36 2019 -0800
# Node ID 2d7615a07002e4d9938fad3645a6609616c50e55
# Parent  c3c9b9dc5cf693552455bfa1859d13f104818d3d
# Parent  7bdeaa38f2b8132ac3b0262f090b5df2551d4040
maint: merge stable to default.

diff --git a/bootstrap b/bootstrap
--- a/bootstrap
+++ b/bootstrap
@@ -1,15 +1,15 @@
 #! /bin/sh
 # Print a version string.
-scriptversion=2018-03-30.12; # UTC
+scriptversion=2018-10-13.05; # UTC
 
 # Bootstrap this package from checked-out sources.
 
-# Copyright (C) 2003-2016 Free Software Foundation, Inc.
+# Copyright (C) 2003-2018 Free Software Foundation, Inc.
 
 # This program is free software: you can redistribute it and/or modify
 # it under the terms of the GNU General Public License as published by
 # the Free Software Foundation, either version 3 of the License, or
 # (at your option) any later version.
 
 # This program is distributed in the hope that it will be useful,
 # but WITHOUT ANY WARRANTY; without even the implied warranty of
@@ -27,31 +27,33 @@ scriptversion=2018-03-30.12; # UTC
 # file also maintained in your version control; gnulib comes with a
 # template build-aux/bootstrap.conf to get you started.
 
 # Please report bugs or propose patches to bug-gnulib@gnu.org.
 
 nl='
 '
 
-# Ensure filenames are sorted consistently across platforms.
+# Ensure file names are sorted consistently across platforms.
 LC_ALL=C
 export LC_ALL
 
 # Ensure that CDPATH is not set.  Otherwise, the output from cd
 # would cause trouble in at least one use below.
 (unset CDPATH) >/dev/null 2>&1 && unset CDPATH
 
 local_gl_dir=gl
 
-# Honour $PERL, but work even if there is none
+# Honor $PERL, but work even if there is none.
 PERL="${PERL-perl}"
 
 me=$0
 
+default_gnulib_url=git://git.sv.gnu.org/gnulib
+
 usage() {
   cat <<EOF
 Usage: $me [OPTION]...
 Bootstrap this package from the checked-out sources.
 
 Options:
  --gnulib-srcdir=DIRNAME  specify the local directory where gnulib
                           sources reside.  Use this if you already
@@ -71,16 +73,47 @@ Options:
  --skip-po                do not download po files
 
 If the file $me.conf exists in the same directory as this script, its
 contents are read as shell variables to configure the bootstrap.
 
 For build prerequisites, environment variables like \$AUTOCONF and \$AMTAR
 are honored.
 
+Gnulib sources can be fetched in various ways:
+
+ * If this package is in a git repository with a 'gnulib' submodule
+   configured, then that submodule is initialized and updated and sources
+   are fetched from there.  If \$GNULIB_SRCDIR is set (directly or via
+   --gnulib-srcdir) and is a git repository, then it is used as a reference.
+
+ * Otherwise, if \$GNULIB_SRCDIR is set (directly or via --gnulib-srcdir),
+   then sources are fetched from that local directory.  If it is a git
+   repository and \$GNULIB_REVISION is set, then that revision is checked
+   out.
+
+ * Otherwise, if this package is in a git repository with a 'gnulib'
+   submodule configured, then that submodule is initialized and updated and
+   sources are fetched from there.
+
+ * Otherwise, if the 'gnulib' directory does not exist, Gnulib sources are
+   cloned into that directory using git from \$GNULIB_URL, defaulting to
+   $default_gnulib_url.
+   If \$GNULIB_REVISION is set, then that revision is checked out.
+
+ * Otherwise, the existing Gnulib sources in the 'gnulib' directory are
+   used.  If it is a git repository and \$GNULIB_REVISION is set, then that
+   revision is checked out.
+
+If you maintain a package and want to pin a particular revision of the
+Gnulib sources that has been tested with your package, then there are two
+possible approaches: either configure a 'gnulib' submodule with the
+appropriate revision, or set \$GNULIB_REVISION (and if necessary
+\$GNULIB_URL) in $me.conf.
+
 Running without arguments will suffice in most cases.
 EOF
 }
 
 # warnf_ FORMAT-STRING ARG1...
 warnf_ ()
 {
   warnf_format_=$1
@@ -124,29 +157,22 @@ gnulib_files=
 # A function to be called right after gnulib-tool is run.
 # Override it via your own definition in bootstrap.conf.
 bootstrap_post_import_hook() { :; }
 
 # A function to be called after everything else in this script.
 # Override it via your own definition in bootstrap.conf.
 bootstrap_epilogue() { :; }
 
-# The command to download all .po files for a specified domain into
-# a specified directory.  Fill in the first %s is the domain name, and
-# the second with the destination directory.  Use rsync's -L and -r
-# options because the latest/%s directory and the .po files within are
-# all symlinks.
+# The command to download all .po files for a specified domain into a
+# specified directory.  Fill in the first %s with the destination
+# directory and the second with the domain name.
 po_download_command_format=\
-"rsync --delete --exclude '*.s1' -Lrtvz \
- 'translationproject.org::tp/latest/%s/' '%s'"
-
-# Fallback for downloading .po files (if rsync fails).
-po_download_command_format2=\
-"wget --mirror -nd -q -np -A.po -P '%s' \
- http://translationproject.org/latest/%s/"
+"wget --mirror --level=1 -nd -q -A.po -P '%s' \
+ https://translationproject.org/latest/%s/"
 
 # Prefer a non-empty tarname (4th argument of AC_INIT if given), else
 # fall back to the package name (1st argument with munging)
 extract_package_name='
   /^AC_INIT(\[*/{
      s///
      /^[^,]*,[^,]*,[^,]*,[ []*\([^][ ,)]\)/{
        s//\1/
@@ -165,17 +191,25 @@ package=$(sed -n "$extract_package_name"
   || die 'cannot find package name in configure.ac'
 gnulib_name=lib$package
 
 build_aux=build-aux
 source_base=lib
 m4_base=m4
 doc_base=doc
 tests_base=tests
-gnulib_extra_files=''
+gnulib_extra_files="
+        build-aux/install-sh
+        build-aux/mdate-sh
+        build-aux/texinfo.tex
+        build-aux/depcomp
+        build-aux/config.guess
+        build-aux/config.sub
+        doc/INSTALL
+"
 
 # Additional gnulib-tool options to use.  Use "\newline" to break lines.
 gnulib_tool_option_extras=
 
 # Other locale categories that need message catalogs.
 EXTRA_LOCALE_CATEGORIES=
 
 # Additional xgettext options to use.  Use "\\\newline" to break lines.
@@ -259,34 +293,28 @@ find_tool ()
 # Override the default configuration, if necessary.
 # Make sure that bootstrap.conf is sourced from the current directory
 # if we were invoked as "sh bootstrap".
 case "$0" in
   */*) test -r "$0.conf" && . "$0.conf" ;;
   *) test -r "$0.conf" && . ./"$0.conf" ;;
 esac
 
-# Extra files from gnulib, which override files from other sources.
-test -z "${gnulib_extra_files}" && \
-  gnulib_extra_files="
-        build-aux/install-sh
-        build-aux/mdate-sh
-        build-aux/texinfo.tex
-        build-aux/depcomp
-        build-aux/config.guess
-        build-aux/config.sub
-        doc/INSTALL
-"
-
 if test "$vc_ignore" = auto; then
   vc_ignore=
   test -d .git && vc_ignore=.gitignore
   test -d CVS && vc_ignore="$vc_ignore .cvsignore"
 fi
 
+if test x"$gnulib_modules$gnulib_files$gnulib_extra_files" = x; then
+  use_gnulib=false
+else
+  use_gnulib=true
+fi
+
 # Translate configuration into internal form.
 
 # Parse options.
 
 for option
 do
   case $option in
   --help)
@@ -413,38 +441,40 @@ sort_ver() { # sort -V is not generally 
         fi
       fi
       break
     fi
     i=$(($i+1))
   done
 }
 
+get_version_sed='
+# Move version to start of line.
+s/.*[v ]\([0-9]\)/\1/
+
+# Skip lines that do not start with version.
+/^[0-9]/!d
+
+# Remove characters after the version.
+s/[^.a-z0-9-].*//
+
+# The first component must be digits only.
+s/^\([0-9]*\)[a-z-].*/\1/
+
+#the following essentially does s/5.005/5.5/
+s/\.0*\([1-9]\)/.\1/g
+p
+q'
+
 get_version() {
   app=$1
 
   $app --version >/dev/null 2>&1 || { $app --version; return 1; }
 
-  $app --version 2>&1 |
-  sed -n '# Move version to start of line.
-          s/.*[v ]\([0-9]\)/\1/
-
-          # Skip lines that do not start with version.
-          /^[0-9]/!d
-
-          # Remove characters after the version.
-          s/[^.a-z0-9-].*//
-
-          # The first component must be digits only.
-          s/^\([0-9]*\)[a-z-].*/\1/
-
-          #the following essentially does s/5.005/5.5/
-          s/\.0*\([1-9]\)/.\1/g
-          p
-          q'
+  $app --version 2>&1 | sed -n "$get_version_sed"
 }
 
 check_versions() {
   ret=0
 
   while read app req_ver; do
     # We only need libtoolize from the libtool package.
     if test "$app" = libtool; then
@@ -605,105 +635,111 @@ cleanup_gnulib() {
   rm -fr "$gnulib_path"
   exit $status
 }
 
 git_modules_config () {
   test -f .gitmodules && git config --file .gitmodules "$@"
 }
 
-if $use_git; then
-  gnulib_path=$(git_modules_config submodule.gnulib.path)
-  test -z "$gnulib_path" && gnulib_path=gnulib
-fi
-
-# Get gnulib files.  Populate $GNULIB_SRCDIR, possibly updating a
-# submodule, for use in the rest of the script.
+if $use_gnulib; then
+  if $use_git; then
+    gnulib_path=$(git_modules_config submodule.gnulib.path)
+    test -z "$gnulib_path" && gnulib_path=gnulib
+  fi
 
-case ${GNULIB_SRCDIR--} in
--)
-  # Note that $use_git is necessarily true in this case.
-  if git_modules_config submodule.gnulib.url >/dev/null; then
-    echo "$0: getting gnulib files..."
-    git submodule init -- "$gnulib_path" || exit $?
-    git submodule update -- "$gnulib_path" || exit $?
-
-  elif [ ! -d "$gnulib_path" ]; then
-    echo "$0: getting gnulib files..."
-
-    trap cleanup_gnulib 1 2 13 15
-
-    shallow=
-    git clone -h 2>&1 | grep -- --depth > /dev/null && shallow='--depth 2'
-    git clone $shallow git://git.sv.gnu.org/gnulib "$gnulib_path" ||
-      cleanup_gnulib
+  # Get gnulib files.  Populate $GNULIB_SRCDIR, possibly updating a
+  # submodule, for use in the rest of the script.
 
-    trap - 1 2 13 15
-  fi
-  GNULIB_SRCDIR=$gnulib_path
-  ;;
-*)
-  # Use GNULIB_SRCDIR directly or as a reference.
-  if $use_git && test -d "$GNULIB_SRCDIR"/.git && \
-        git_modules_config submodule.gnulib.url >/dev/null; then
-    echo "$0: getting gnulib files..."
-    if git submodule -h|grep -- --reference > /dev/null; then
-      # Prefer the one-liner available in git 1.6.4 or newer.
-      git submodule update --init --reference "$GNULIB_SRCDIR" \
-        "$gnulib_path" || exit $?
-    else
-      # This fallback allows at least git 1.5.5.
-      if test -f "$gnulib_path"/gnulib-tool; then
-        # Since file already exists, assume submodule init already complete.
-        git submodule update -- "$gnulib_path" || exit $?
-      else
-        # Older git can't clone into an empty directory.
-        rmdir "$gnulib_path" 2>/dev/null
-        git clone --reference "$GNULIB_SRCDIR" \
-          "$(git_modules_config submodule.gnulib.url)" "$gnulib_path" \
-          && git submodule init -- "$gnulib_path" \
-          && git submodule update -- "$gnulib_path" \
-          || exit $?
+  case ${GNULIB_SRCDIR--} in
+  -)
+    # Note that $use_git is necessarily true in this case.
+    if git_modules_config submodule.gnulib.url >/dev/null; then
+      echo "$0: getting gnulib files..."
+      git submodule init -- "$gnulib_path" || exit $?
+      git submodule update -- "$gnulib_path" || exit $?
+
+    elif [ ! -d "$gnulib_path" ]; then
+      echo "$0: getting gnulib files..."
+
+      trap cleanup_gnulib 1 2 13 15
+
+      shallow=
+      if test -z "$GNULIB_REVISION"; then
+        git clone -h 2>&1 | grep -- --depth > /dev/null && shallow='--depth 2'
       fi
+      git clone $shallow ${GNULIB_URL:-$default_gnulib_url} "$gnulib_path" \
+        || cleanup_gnulib
+
+      trap - 1 2 13 15
     fi
     GNULIB_SRCDIR=$gnulib_path
-  fi
-  ;;
-esac
-
-# $GNULIB_SRCDIR now points to the version of gnulib to use, and
-# we no longer need to use git or $gnulib_path below here.
+    ;;
+  *)
+    # Use GNULIB_SRCDIR directly or as a reference.
+    if $use_git && test -d "$GNULIB_SRCDIR"/.git && \
+          git_modules_config submodule.gnulib.url >/dev/null; then
+      echo "$0: getting gnulib files..."
+      if git submodule -h|grep -- --reference > /dev/null; then
+        # Prefer the one-liner available in git 1.6.4 or newer.
+        git submodule update --init --reference "$GNULIB_SRCDIR" \
+          "$gnulib_path" || exit $?
+      else
+        # This fallback allows at least git 1.5.5.
+        if test -f "$gnulib_path"/gnulib-tool; then
+          # Since file already exists, assume submodule init already complete.
+          git submodule update -- "$gnulib_path" || exit $?
+        else
+          # Older git can't clone into an empty directory.
+          rmdir "$gnulib_path" 2>/dev/null
+          git clone --reference "$GNULIB_SRCDIR" \
+            "$(git_modules_config submodule.gnulib.url)" "$gnulib_path" \
+            && git submodule init -- "$gnulib_path" \
+            && git submodule update -- "$gnulib_path" \
+            || exit $?
+        fi
+      fi
+      GNULIB_SRCDIR=$gnulib_path
+    fi
+    ;;
+  esac
 
-if $bootstrap_sync; then
-  cmp -s "$0" "$GNULIB_SRCDIR/build-aux/bootstrap" || {
-    echo "$0: updating bootstrap and restarting..."
-    case $(sh -c 'echo "$1"' -- a) in
-      a) ignored=--;;
-      *) ignored=ignored;;
-    esac
-    exec sh -c \
-      'cp "$1" "$2" && shift && exec "${CONFIG_SHELL-/bin/sh}" "$@"' \
-      $ignored "$GNULIB_SRCDIR/build-aux/bootstrap" \
-      "$0" "$@" --no-bootstrap-sync
-  }
+  if test -d "$GNULIB_SRCDIR"/.git && test -n "$GNULIB_REVISION" \
+     && ! git_modules_config submodule.gnulib.url >/dev/null; then
+    (cd "$GNULIB_SRCDIR" && git checkout "$GNULIB_REVISION") || cleanup_gnulib
+  fi
+
+  # $GNULIB_SRCDIR now points to the version of gnulib to use, and
+  # we no longer need to use git or $gnulib_path below here.
+
+  if $bootstrap_sync; then
+    cmp -s "$0" "$GNULIB_SRCDIR/build-aux/bootstrap" || {
+      echo "$0: updating bootstrap and restarting..."
+      case $(sh -c 'echo "$1"' -- a) in
+        a) ignored=--;;
+        *) ignored=ignored;;
+      esac
+      exec sh -c \
+        'cp "$1" "$2" && shift && exec "${CONFIG_SHELL-/bin/sh}" "$@"' \
+        $ignored "$GNULIB_SRCDIR/build-aux/bootstrap" \
+        "$0" "$@" --no-bootstrap-sync
+    }
+  fi
+
+  gnulib_tool=$GNULIB_SRCDIR/gnulib-tool
+  <$gnulib_tool || exit $?
 fi
 
-gnulib_tool=$GNULIB_SRCDIR/gnulib-tool
-<$gnulib_tool || exit $?
-
 # Get translations.
 
 download_po_files() {
   subdir=$1
   domain=$2
   echo "$me: getting translations into $subdir for $domain..."
-  cmd=$(printf "$po_download_command_format" "$domain" "$subdir")
-  eval "$cmd" && return
-  # Fallback to HTTP.
-  cmd=$(printf "$po_download_command_format2" "$subdir" "$domain")
+  cmd=$(printf "$po_download_command_format" "$subdir" "$domain")
   eval "$cmd"
 }
 
 # Mirror .po files to $po_dir/.reference and copy only the new
 # or modified ones into $po_dir.  Also update $po_dir/LINGUAS.
 # Note po files that exist locally only are left in $po_dir but will
 # not be included in LINGUAS and hence will not be distributed.
 update_po_files() {
@@ -783,19 +819,19 @@ symlink_to_dir()
       cmp -s "$src" "$dst" || {
         echo "$me: cp -fp $src $dst" &&
         cp -fp "$src" "$dst"
       }
     else
       # Leave any existing symlink alone, if it already points to the source,
       # so that broken build tools that care about symlink times
       # aren't confused into doing unnecessary builds.  Conversely, if the
-      # existing symlink's time stamp is older than the source, make it afresh,
+      # existing symlink's timestamp is older than the source, make it afresh,
       # so that broken tools aren't confused into skipping needed builds.  See
-      # <http://lists.gnu.org/archive/html/bug-gnulib/2011-05/msg00326.html>.
+      # <https://lists.gnu.org/r/bug-gnulib/2011-05/msg00326.html>.
       test -h "$dst" &&
       src_ls=$(ls -diL "$src" 2>/dev/null) && set $src_ls && src_i=$1 &&
       dst_ls=$(ls -diL "$dst" 2>/dev/null) && set $dst_ls && dst_i=$1 &&
       test "$src_i" = "$dst_i" &&
       both_ls=$(ls -dt "$src" "$dst") &&
       test "X$both_ls" = "X$dst$nl$src" || {
         dot_dots=
         case $src in
@@ -891,42 +927,43 @@ if test $with_gettext = yes || test $use
   IFS=$old_IFS
 
   rm -f $tempbase.0 $tempbase.1
   trap - 1 2 13 15
 fi
 
 # Import from gnulib.
 
-gnulib_tool_options="\
- --import\
- --no-changelog\
- --aux-dir $build_aux\
- --doc-base $doc_base\
- --lib $gnulib_name\
- --m4-base $m4_base/\
- --source-base $source_base/\
- --tests-base $tests_base\
- --local-dir $local_gl_dir\
- $gnulib_tool_option_extras\
-"
-if test $use_libtool = 1; then
-  case "$gnulib_tool_options " in
-    *' --libtool '*) ;;
-    *) gnulib_tool_options="$gnulib_tool_options --libtool" ;;
-  esac
+if $use_gnulib; then
+  gnulib_tool_options="\
+   --no-changelog\
+   --aux-dir=$build_aux\
+   --doc-base=$doc_base\
+   --lib=$gnulib_name\
+   --m4-base=$m4_base/\
+   --source-base=$source_base/\
+   --tests-base=$tests_base\
+   --local-dir=$local_gl_dir\
+   $gnulib_tool_option_extras\
+  "
+  if test $use_libtool = 1; then
+    case "$gnulib_tool_options " in
+      *' --libtool '*) ;;
+      *) gnulib_tool_options="$gnulib_tool_options --libtool" ;;
+    esac
+  fi
+  echo "$0: $gnulib_tool $gnulib_tool_options --import ..."
+  $gnulib_tool $gnulib_tool_options --import $gnulib_modules \
+    || die "gnulib-tool failed"
+
+  for file in $gnulib_files; do
+    symlink_to_dir "$GNULIB_SRCDIR" $file \
+      || die "failed to symlink $file"
+  done
 fi
-echo "$0: $gnulib_tool $gnulib_tool_options --import ..."
-$gnulib_tool $gnulib_tool_options --import $gnulib_modules \
-  || die "gnulib-tool failed"
-
-for file in $gnulib_files; do
-  symlink_to_dir "$GNULIB_SRCDIR" $file \
-    || die "failed to symlink $file"
-done
 
 bootstrap_post_import_hook \
   || die "bootstrap_post_import_hook failed"
 
 # Remove any dangling symlink matching "*.m4" or "*.[ch]" in some
 # gnulib-populated directories.  Such .m4 files would cause aclocal to fail.
 # The following requires GNU find 4.2.3 or newer.  Considering the usual
 # portability constraints of this script, that may seem a very demanding
@@ -939,19 +976,18 @@ find "$m4_base" "$source_base" \
   -type l -xtype l -delete > /dev/null 2>&1
 
 # Invoke autoreconf with --force --install to ensure upgrades of tools
 # such as ylwrap.
 AUTORECONFFLAGS="--verbose --install --force -I $m4_base $ACLOCAL_FLAGS"
 
 # Some systems (RHEL 5) are using ancient autotools, for which the
 # --no-recursive option had not been invented.  Detect that lack and
-# omit the option when it's not supported.
-# FIXME: in 2017, remove this hack when RHEL 5 autotools are updated,
-# or when they become irrelevant.
+# omit the option when it's not supported.  FIXME in 2017: remove this
+# hack when RHEL 5 autotools are updated, or when they become irrelevant.
 case $($AUTORECONF --help) in
   *--no-recursive*) AUTORECONFFLAGS="$AUTORECONFFLAGS --no-recursive";;
 esac
 
 # Tell autoreconf not to invoke autopoint or libtoolize; they were run above.
 echo "running: AUTOPOINT=true LIBTOOLIZE=true $AUTORECONF $AUTORECONFFLAGS"
 AUTOPOINT=true LIBTOOLIZE=true $AUTORECONF $AUTORECONFFLAGS \
   || die "autoreconf failed"
@@ -1014,14 +1050,14 @@ if test $with_gettext = yes; then
   fi
 fi
 
 bootstrap_epilogue
 
 echo "$0: done.  Now you can run './configure'."
 
 # Local variables:
-# eval: (add-hook 'write-file-hooks 'time-stamp)
+# eval: (add-hook 'before-save-hook 'time-stamp)
 # time-stamp-start: "scriptversion="
 # time-stamp-format: "%:y-%02m-%02d.%02H"
-# time-stamp-time-zone: "UTC"
+# time-stamp-time-zone: "UTC0"
 # time-stamp-end: "; # UTC"
 # End:
diff --git a/libgui/src/documentation.cc b/libgui/src/documentation.cc
--- a/libgui/src/documentation.cc
+++ b/libgui/src/documentation.cc
@@ -533,16 +533,21 @@ namespace octave
 
       // Apply selection and move back to the beginning
       m_doc_browser->setExtraSelections (selected);
       m_doc_browser->moveCursor (QTextCursor::Start);
   }
 
   void documentation::notice_settings (const QSettings *settings)
   {
+    // If m_help_engine is not defined, the object accessed by this method
+    // are not valid. Thus, just return in this case
+    if (! m_help_engine)
+      return;
+
     // Icon size in the toolbar.
     int size_idx = settings->value (global_icon_size.key,
                                     global_icon_size.def).toInt ();
     size_idx = (size_idx > 0) - (size_idx < 0) + 1;  // Make valid index from 0 to 2
 
     QStyle *st = style ();
     int icon_size = st->pixelMetric (global_icon_sizes[size_idx]);
     m_tool_bar->setIconSize (QSize (icon_size, icon_size));
diff --git a/libinterp/corefcn/find.cc b/libinterp/corefcn/find.cc
--- a/libinterp/corefcn/find.cc
+++ b/libinterp/corefcn/find.cc
@@ -393,17 +393,17 @@ b = sparse (i, j, v, sz(1), sz(2));
 
   // Setup the default options.
   octave_idx_type n_to_find = -1;
   if (nargin > 1)
     {
       double val = args(1).xscalar_value ("find: N must be an integer");
 
       if (val < 0 || (! octave::math::isinf (val)
-                      && val != octave::math::round (val)))
+                      && val != octave::math::fix (val)))
         error ("find: N must be a non-negative integer");
       else if (! octave::math::isinf (val))
         n_to_find = val;
     }
 
   // Direction to do the searching (1 == forward, -1 == reverse).
   int direction = 1;
   if (nargin > 2)
diff --git a/libinterp/corefcn/gl-render.cc b/libinterp/corefcn/gl-render.cc
--- a/libinterp/corefcn/gl-render.cc
+++ b/libinterp/corefcn/gl-render.cc
@@ -147,21 +147,24 @@ namespace octave
     ~opengl_texture (void)
     {
       if (--rep->count == 0)
         delete rep;
     }
 
     opengl_texture& operator = (const opengl_texture& tx)
     {
-      if (--rep->count == 0)
-        delete rep;
-
-      rep = tx.rep;
-      rep->count++;
+      if (&tx != this)
+        {
+          if (--rep->count == 0)
+            delete rep;
+
+          rep = tx.rep;
+          rep->count++;
+        }
 
       return *this;
     }
 
     static opengl_texture create (opengl_functions& glfcns,
                                   const octave_value& data);
 
     void bind (int mode = GL_TEXTURE_2D) const
@@ -424,21 +427,24 @@ namespace octave
     ~vertex_data (void)
     {
       if (--rep->count == 0)
         delete rep;
     }
 
     vertex_data& operator = (const vertex_data& v)
     {
-      if (--rep->count == 0)
-        delete rep;
-
-      rep = v.rep;
-      rep->count++;
+      if (&v != this)
+        {
+          if (--rep->count == 0)
+            delete rep;
+
+          rep = v.rep;
+          rep->count++;
+        }
 
       return *this;
     }
 
     vertex_data_rep * get_rep (void) const { return rep; }
   };
 
   class
@@ -4475,33 +4481,43 @@ namespace octave
     // This shouldn't happen because construction of opengl_renderer
     // objects is supposed to be impossible if OpenGL is not available.
 
     panic_impossible ();
 
 #endif
   }
 
+  std::string
+  opengl_renderer::get_string (unsigned int id) const
+  {
 #if defined (HAVE_OPENGL)
 
-  std::string
-  opengl_renderer::get_string (GLenum id) const
-  {
     // This is kind of ugly, but glGetString returns a pointer to GLubyte
     // and there is no std::string constructor that matches.  Is there a
     // better way?
 
     std::ostringstream buf;
 
-    buf << m_glfcns.glGetString (id);
+    buf << m_glfcns.glGetString (static_cast<GLenum> (id));
 
     return std::string (buf.str ());
-  }
+
+#else
+
+    octave_unused_parameter (id);
+
+    // This shouldn't happen because construction of opengl_renderer
+    // objects is supposed to be impossible if OpenGL is not available.
+
+    panic_impossible ();
+    return std::string ();
 
 #endif
+  }
 
   void
   opengl_renderer::set_normal (int bfl_mode, const NDArray& n, int j, int i)
   {
 #if defined (HAVE_OPENGL)
 
     double x = n(j,i,0);
     double y = n(j,i,1);
diff --git a/libinterp/corefcn/gl-render.h b/libinterp/corefcn/gl-render.h
--- a/libinterp/corefcn/gl-render.h
+++ b/libinterp/corefcn/gl-render.h
@@ -21,21 +21,22 @@ along with Octave; see the file COPYING.
 */
 
 #if ! defined (octave_gl_render_h)
 #define octave_gl_render_h 1
 
 #include "octave-config.h"
 
 #include "graphics.h"
-#include "oct-opengl.h"
 #include "text-renderer.h"
 
 namespace octave
 {
+  class opengl_functions;
+
   class
   OCTINTERP_API
   opengl_renderer
   {
   public:
 
     opengl_renderer (opengl_functions& glfcns);
 
@@ -163,19 +164,17 @@ namespace octave
                                    int& wmax, int& hmax);
 
     virtual void draw_zoom_rect (int x1, int y1, int x2, int y2);
 
   private:
 
     void init_maxlights (void);
 
-#if defined (HAVE_OPENGL)
-    std::string get_string (GLenum id) const;
-#endif
+    std::string get_string (unsigned int id) const;
 
     bool is_nan_or_inf (double x, double y, double z) const
     {
       return (math::isnan (x) || math::isnan (y)
               || math::isnan (z)
               || math::isinf (x) || math::isinf (y)
               || math::isinf (z));
     }
diff --git a/libinterp/corefcn/gl2ps-print.h b/libinterp/corefcn/gl2ps-print.h
--- a/libinterp/corefcn/gl2ps-print.h
+++ b/libinterp/corefcn/gl2ps-print.h
@@ -22,19 +22,20 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_gl2ps_renderer_h)
 #define octave_gl2ps_renderer_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
-#include "oct-opengl.h"
 #include "graphics.h"
 
 namespace octave
 {
+  class opengl_functions;
+
   extern OCTINTERP_API void
   gl2ps_print (opengl_functions& glfcns, const graphics_object& fig,
                const std::string& stream, const std::string& term);
 }
 
 #endif
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -112,17 +112,17 @@ validate_property_name (const std::strin
 
       sv.list_in_columns (os);
 
       std::string match_list = os.str ();
 
       error ("%s: ambiguous %s property name %s; possible matches:\n\n%s",
              who.c_str (), what.c_str (), pname.c_str (), match_list.c_str ());
     }
-  else if (num_matches == 1)
+  else  // num_matches == 1
     {
       // Exact match was handled above.
       std::string possible_match = *(matches.begin ());
 
       warning_with_id ("Octave:abbreviated-property-match",
                        "%s: allowing %s to match %s property %s",
                        who.c_str (), pname.c_str (), what.c_str (),
                        possible_match.c_str ());
@@ -2833,22 +2833,20 @@ xget (const graphics_handle& h, const ca
   return go.get (pname);
 }
 
 static graphics_handle
 reparent (const octave_value& ov, const std::string& who,
           const std::string& pname, const graphics_handle& new_parent,
           bool adopt = true)
 {
-  graphics_handle h = octave::numeric_limits<double>::NaN ();
-
   double hv = ov.xdouble_value ("%s: %s must be a graphics handle",
                                 who.c_str (), pname.c_str ());
 
-  h = gh_manager::lookup (hv);
+  graphics_handle h = gh_manager::lookup (hv);
 
   if (! h.ok ())
     error ("%s: invalid graphics handle (= %g) for %s",
            who.c_str (), hv, pname.c_str ());
 
   graphics_object go = gh_manager::get_object (h);
 
   graphics_handle parent_h = go.get_parent ();
@@ -3242,24 +3240,20 @@ base_properties::get_property_dynamic (c
 
   return it->second;
 }
 
 void
 base_properties::set_parent (const octave_value& val)
 {
   double hp = val.xdouble_value ("set: parent must be a graphics handle");
-
-  graphics_handle new_parent = octave::numeric_limits<double>::NaN ();
-
   if (hp == __myhandle__)
     error ("set: can not set object parent to be object itself");
 
-  new_parent = gh_manager::lookup (hp);
-
+  graphics_handle new_parent = gh_manager::lookup (hp);
   if (! new_parent.ok ())
     error ("set: invalid graphics handle (= %g) for parent", hp);
 
   // Remove child from current parent
   graphics_object old_parent_go;
   old_parent_go = gh_manager::get_object (get_parent ());
 
   if (old_parent_go.get_handle () != hp)
@@ -5812,17 +5806,17 @@ axes::properties::update_camera (void)
       cameraupvector = xform2cam (c_upv);
     }
   else
     c_upv = cam2xform (get_cameraupvector ().matrix_value ());
 
   Matrix x_view = xform_matrix ();
   Matrix x_projection = xform_matrix ();
   Matrix x_viewport = xform_matrix ();
-  Matrix x_normrender = xform_matrix ();
+  Matrix x_normrender;
   Matrix x_pre = xform_matrix ();
 
   x_render = xform_matrix ();
   x_render_inv = xform_matrix ();
 
   scale (x_pre, pb(0), pb(1), pb(2));
   translate (x_pre, -0.5, -0.5, -0.5);
   scale (x_pre, xd/(xlimits(1)-xlimits(0)), yd/(ylimits(1)-ylimits(0)),
@@ -11231,19 +11225,17 @@ graphics_handle
 gh_manager::do_make_graphics_handle (const std::string& go_name,
                                      const graphics_handle& p,
                                      bool integer_figure_handle,
                                      bool do_createfcn,
                                      bool do_notify_toolkit)
 {
   graphics_handle h = get_handle (integer_figure_handle);
 
-  base_graphics_object *bgo = nullptr;
-
-  bgo = make_graphics_object_from_type (go_name, h, p);
+  base_graphics_object *bgo = make_graphics_object_from_type (go_name, h, p);
 
   if (! bgo)
     error ("gh_manager::do_make_graphics_handle: invalid object type '%s'",
            go_name.c_str ());
 
   graphics_object go (bgo);
 
   handle_map[h] = go;
@@ -12222,17 +12214,16 @@ being @qcode{"portrait"}.
               std::string s = go.values_as_string ();
 
               octave_stdout << s;
             }
         }
       else
         {
           go.set (args.splice (0, 1));
-          request_drawnow = true;
         }
 
       request_drawnow = true;
     }
 
   if (request_drawnow)
     Vdrawnow_requested = true;
 
@@ -13414,27 +13405,24 @@ get_property_from_handle (double handle,
 }
 
 bool
 set_property_in_handle (double handle, const std::string& property,
                         const octave_value& arg, const std::string& func)
 {
   gh_manager::auto_lock guard;
 
-  int ret = false;
   graphics_object go = gh_manager::get_object (handle);
 
   if (! go)
     error ("%s: invalid handle (= %g)", func.c_str (), handle);
 
   go.set (caseless_str (property), arg);
 
-  ret = true;
-
-  return ret;
+  return true;
 }
 
 static bool
 compare_property_values (const octave_value& ov1, const octave_value& ov2)
 {
   octave_value_list args(2);
 
   args(0) = ov1;
diff --git a/libinterp/corefcn/ls-mat-ascii.cc b/libinterp/corefcn/ls-mat-ascii.cc
--- a/libinterp/corefcn/ls-mat-ascii.cc
+++ b/libinterp/corefcn/ls-mat-ascii.cc
@@ -91,17 +91,17 @@ get_mat_data_input_line (std::istream& i
             {
               if (! have_data && c != ' ' && c != '\t')
                 have_data = true;
 
               retval += c;
             }
         }
     }
-  while (! (have_data || is.eof ()));
+  while (! (have_data || is.eof () || is.fail ()));
 
   return retval;
 }
 
 static void
 get_lines_and_columns (std::istream& is,
                        octave_idx_type& nr, octave_idx_type& nc,
                        const std::string& filename = "",
diff --git a/libinterp/corefcn/ls-oct-text.cc b/libinterp/corefcn/ls-oct-text.cc
--- a/libinterp/corefcn/ls-oct-text.cc
+++ b/libinterp/corefcn/ls-oct-text.cc
@@ -303,35 +303,33 @@ read_text_data (std::istream& is, const 
 
 // FIXME: should probably write the help string here too.
 
 bool
 save_text_data (std::ostream& os, const octave_value& val_arg,
                 const std::string& name, bool mark_global,
                 int precision)
 {
-  bool success = true;
-
   if (! name.empty ())
     os << "# name: " << name << "\n";
 
   octave_value val = val_arg;
 
   if (mark_global)
     os << "# type: global " << val.type_name () << "\n";
   else
     os << "# type: " << val.type_name () << "\n";
 
   if (! precision)
     precision = Vsave_precision;
 
   long old_precision = os.precision ();
   os.precision (precision);
 
-  success = val.save_ascii (os);
+  bool success = val.save_ascii (os);
 
   // Insert an extra pair of newline characters after the data so that
   // multiple data elements may be handled separately by gnuplot (see
   // the description of the index qualifier for the plot command in the
   // gnuplot documentation).
   os << "\n\n";
 
   os.precision (old_precision);
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -4602,17 +4602,16 @@ namespace octave
         return Matrix (nr, nc, 0.0);
       }
 
     std::istream *isp = input_stream ();
 
     bool all_char_conv = fmt_list.all_character_conversions ();
 
     Matrix mval;
-    double *data = nullptr;
     octave_idx_type max_size = 0;
     octave_idx_type max_conv = 0;
 
     octave_idx_type final_nr = 0;
     octave_idx_type final_nc = 0;
 
     if (all_char_conv)
       {
@@ -4660,17 +4659,17 @@ namespace octave
       }
     else
       {
         // Maybe resize later.
         mval.resize (32, 1, 0.0);
         max_size = 32;
       }
 
-    data = mval.fortran_vec ();
+    double *data = mval.fortran_vec ();
 
     if (isp)
       {
         std::istream& is = *isp;
 
         const scanf_format_elt *elt = fmt_list.first ();
 
         std::ios::fmtflags flags = is.flags ();
@@ -5611,17 +5610,17 @@ namespace octave
           }
         else
           return true;
       }
     else
       {
         double dval = val.double_value (true);
 
-        if (dval == math::round (dval) && dval <= limit)
+        if (dval == math::fix (dval) && dval <= limit)
           return true;
       }
 
     return false;
   }
 
   static bool
   ok_for_unsigned_int_conv (const octave_value& val)
@@ -5638,17 +5637,17 @@ namespace octave
         return ov_is_ge_zero.is_true ();
       }
     else
       {
         double dval = val.double_value (true);
 
         uint64_t limit = std::numeric_limits<uint64_t>::max ();
 
-        if (dval == math::round (dval) && dval >= 0 && dval <= limit)
+        if (dval == math::fix (dval) && dval >= 0 && dval <= limit)
           return true;
       }
 
     return false;
   }
 
   static std::string
   switch_to_g_format (const printf_format_elt *elt)
diff --git a/libinterp/octave-value/ov-bool.cc b/libinterp/octave-value/ov-bool.cc
--- a/libinterp/octave-value/ov-bool.cc
+++ b/libinterp/octave-value/ov-bool.cc
@@ -189,17 +189,17 @@ octave_bool::save_ascii (std::ostream& o
   os << "\n";
 
   return true;
 }
 
 bool
 octave_bool::load_ascii (std::istream& is)
 {
-  scalar = (octave_read_value<double> (is) != 0.);
+  scalar = (octave_read_value<double> (is) != 0.0);
 
   if (! is)
     error ("load: failed to load scalar constant");
 
   return true;
 }
 
 bool
@@ -289,17 +289,17 @@ octave_bool::load_hdf5 (octave_hdf5_id l
   double dtmp;
   if (H5Dread (data_hid, H5T_NATIVE_DOUBLE, octave_H5S_ALL, octave_H5S_ALL,
                octave_H5P_DEFAULT, &dtmp) < 0)
     {
       H5Dclose (data_hid);
       return false;
     }
 
-  scalar = (dtmp != 0.);
+  scalar = (dtmp != 0.0);
 
   H5Dclose (data_hid);
 
 #else
   octave_unused_parameter (loc_id);
   octave_unused_parameter (name);
 
   warn_load ("hdf5");
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -2019,17 +2019,17 @@ A(1)
 
   int dim = 0;
 
   if (nargin == 3)
     {
       if (! args(2).is_real_scalar ())
         error ("cell2struct: DIM must be a real scalar");
 
-      dim = (nargin == 2 ? 0 : args(2).int_value () - 1);
+      dim = args(2).int_value () - 1;
     }
 
   if (dim < 0)
     error ("cell2struct: DIM must be a valid dimension");
 
   const Cell vals = args(0).cell_value ();
   const Array<std::string> fields = args(1).cellstr_value ();
 
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -819,17 +819,17 @@ static bool val_in_table (const Matrix& 
     return false;
 
   octave_idx_type i = table.lookup (val, ASCENDING);
   return (i > 0 && table(i-1) == val);
 }
 
 static bool isargout1 (int nargout, const Matrix& ignored, double k)
 {
-  if (k != octave::math::round (k) || k <= 0)
+  if (k != octave::math::fix (k) || k <= 0)
     error ("isargout: K must be a positive integer");
 
   return (k == 1 || k <= nargout) && ! val_in_table (ignored, k);
 }
 
 DEFMETHOD (isargout, interp, args, ,
            doc: /* -*- texinfo -*-
 @deftypefn {} {} isargout (@var{k})
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -2032,37 +2032,34 @@ template <typename T>
 sortmode
 Array<T>::issorted (sortmode mode) const
 {
   octave_sort<T> lsort;
 
   octave_idx_type n = numel ();
 
   if (n <= 1)
-    return mode ? mode : ASCENDING;
+    return (mode == UNSORTED) ? ASCENDING : mode;
 
   if (mode == UNSORTED)
     {
       // Auto-detect mode.
       compare_fcn_type compare
         = safe_comparator (ASCENDING, *this, false);
 
       if (compare (elem (n-1), elem (0)))
         mode = DESCENDING;
       else
         mode = ASCENDING;
     }
 
-  if (mode != UNSORTED)
-    {
-      lsort.set_compare (safe_comparator (mode, *this, false));
-
-      if (! lsort.issorted (data (), n))
-        mode = UNSORTED;
-    }
+  lsort.set_compare (safe_comparator (mode, *this, false));
+
+  if (! lsort.issorted (data (), n))
+    mode = UNSORTED;
 
   return mode;
 
 }
 
 template <typename T>
 Array<octave_idx_type>
 Array<T>::sort_rows_idx (sortmode mode) const
@@ -2086,17 +2083,17 @@ sortmode
 Array<T>::is_sorted_rows (sortmode mode) const
 {
   octave_sort<T> lsort;
 
   octave_idx_type r = rows ();
   octave_idx_type c = cols ();
 
   if (r <= 1 || c == 0)
-    return mode ? mode : ASCENDING;
+    return (mode == UNSORTED) ? ASCENDING : mode;
 
   if (mode == UNSORTED)
     {
       // Auto-detect mode.
       compare_fcn_type compare
         = safe_comparator (ASCENDING, *this, false);
 
       octave_idx_type i;
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -147,17 +147,17 @@ idx_vector::idx_range_rep::idx_range_rep
           if (step < 0 && start + (len - 1)*step < 0)
             octave::err_invalid_index (start + (len - 1)*step);
         }
       else
         {
           // find first non-integer, then gripe about it
           double b = r.base ();
           double inc = r.inc ();
-          octave::err_invalid_index (b != std::floor (b) ? b : b + inc);
+          octave::err_invalid_index (b != std::trunc (b) ? b : b + inc);
         }
     }
 }
 
 octave_idx_type
 idx_vector::idx_range_rep::checkelem (octave_idx_type i) const
 {
   if (i < 0 || i >= len)
diff --git a/liboctave/util/oct-inttypes.cc b/liboctave/util/oct-inttypes.cc
--- a/liboctave/util/oct-inttypes.cc
+++ b/liboctave/util/oct-inttypes.cc
@@ -574,17 +574,17 @@ dbleget (bool sign, uint32_t mtis, int e
   double x = ldexp (static_cast<double> (mtis), exp);
   return sign ? -x : x;
 }
 
 template <>
 OCTAVE_API octave_uint64
 operator * (const octave_uint64& x, const double& y)
 {
-  if (y >= 0 && y < octave_uint64::max () && y == octave::math::round (y))
+  if (y >= 0 && y < octave_uint64::max () && y == octave::math::fix (y))
     return x * octave_uint64 (static_cast<uint64_t> (y));
   else if (y == 0.5)
     return x / octave_uint64 (static_cast<uint64_t> (2));
   else if (y < 0 || octave::math::isnan (y) || octave::math::isinf (y))
     return octave_uint64 (x.value () * y);
   else
     {
       bool sign;
@@ -609,17 +609,17 @@ operator * (const double& x, const octav
 {
   return y * x;
 }
 
 template <>
 OCTAVE_API octave_int64
 operator * (const octave_int64& x, const double& y)
 {
-  if (fabs (y) < octave_int64::max () && y == octave::math::round (y))
+  if (fabs (y) < octave_int64::max () && y == octave::math::fix (y))
     return x * octave_int64 (static_cast<int64_t> (y));
   else if (fabs (y) == 0.5)
     return x / octave_int64 (static_cast<uint64_t> (4*y));
   else if (octave::math::isnan (y) || octave::math::isinf (y))
     return octave_int64 (x.value () * y);
   else
     {
       bool sign;
@@ -659,27 +659,27 @@ operator / (const double& x, const octav
 {
   return octave_int64 (x / static_cast<double> (y));
 }
 
 template <>
 OCTAVE_API octave_uint64
 operator / (const octave_uint64& x, const double& y)
 {
-  if (y >= 0 && y < octave_uint64::max () && y == octave::math::round (y))
+  if (y >= 0 && y < octave_uint64::max () && y == octave::math::fix (y))
     return x / octave_uint64 (y);
   else
     return x * (1.0/y);
 }
 
 template <>
 OCTAVE_API octave_int64
 operator / (const octave_int64& x, const double& y)
 {
-  if (fabs (y) < octave_int64::max () && y == octave::math::round (y))
+  if (fabs (y) < octave_int64::max () && y == octave::math::fix (y))
     return x / octave_int64 (y);
   else
     return x * (1.0/y);
 }
 
 #define INSTANTIATE_INT64_DOUBLE_CMP_OP0(OP, T1, T2)                    \
   template OCTAVE_API bool                                              \
   octave_int_cmp_op::emulate_mop<octave_int_cmp_op::OP> (T1 x, T2 y)
@@ -746,32 +746,32 @@ octave_int<T>
 pow (const double& a, const octave_int<T>& b)
 { return octave_int<T> (std::pow (a, b.double_value ())); }
 
 template <typename T>
 octave_int<T>
 pow (const octave_int<T>& a, const double& b)
 {
   return ((b >= 0 && b < std::numeric_limits<T>::digits
-           && b == octave::math::round (b))
+           && b == octave::math::fix (b))
           ? pow (a, octave_int<T> (static_cast<T> (b)))
           : octave_int<T> (std::pow (a.double_value (), b)));
 }
 
 template <typename T>
 octave_int<T>
 pow (const float& a, const octave_int<T>& b)
 { return octave_int<T> (std::pow (a, b.float_value ())); }
 
 template <typename T>
 octave_int<T>
 pow (const octave_int<T>& a, const float& b)
 {
   return ((b >= 0 && b < std::numeric_limits<T>::digits
-           && b == octave::math::round (b))
+           && b == octave::math::fix (b))
           ? pow (a, octave_int<T> (static_cast<T> (b)))
           : octave_int<T> (std::pow (a.double_value (),
                                      static_cast<double> (b))));
 }
 
 // FIXME: Do we really need a differently named single-precision function
 //        integer power function here instead of an overloaded one?
 template <typename T>
@@ -779,17 +779,17 @@ octave_int<T>
 powf (const float& a, const octave_int<T>& b)
 { return octave_int<T> (pow (a, b.float_value ())); }
 
 template <typename T>
 octave_int<T>
 powf (const octave_int<T>& a, const float& b)
 {
   return ((b >= 0 && b < std::numeric_limits<T>::digits
-           && b == octave::math::round (b))
+           && b == octave::math::fix (b))
           ? pow (a, octave_int<T> (static_cast<T> (b)))
           : octave_int<T> (std::pow (a.double_value (),
                                      static_cast<double> (b))));
 }
 
 #define INSTANTIATE_INTTYPE(T)                                          \
   template class OCTAVE_API octave_int<T>;                              \
                                                                         \
