# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1256028442 -7200
#      Tue Oct 20 10:47:22 2009 +0200
# Node ID 26abff55f6fe2f86f722bb2b9b3dcfc95b25e411
# Parent  9f8ff01abc657d0f12603b2e4cca0fe6c491d6c9
optimize bsxfun for common built-in operations

diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -38,16 +38,18 @@ along with Octave; see the file COPYING.
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "MArray-defs.h"
 #include "mx-base.h"
 #include "mx-op-defs.h"
 #include "oct-fftw.h"
 #include "oct-locbuf.h"
 
+#include "bsxfun-defs.cc"
+
 ComplexNDArray::ComplexNDArray (const charNDArray& a)
   : MArrayN<Complex> (a.dims ())
 {
   octave_idx_type n = a.numel ();
   for (octave_idx_type i = 0; i < n; i++)
     xelem (i) = static_cast<unsigned char> (a(i));
 }
 
@@ -1099,13 +1101,16 @@ ComplexNDArray& operator /= (ComplexNDAr
 {
   if (a.is_shared ())
     return a = a / s;
   else
     do_ms_inplace_op<ComplexNDArray, double> (a, s, mx_inline_div2);
   return a;
 }
 
+BSXFUN_STDOP_DEFS_MXLOOP (ComplexNDArray)
+BSXFUN_STDREL_DEFS_MXLOOP (ComplexNDArray)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -23,16 +23,17 @@ along with Octave; see the file COPYING.
 #if !defined (octave_ComplexNDArray_h)
 #define octave_ComplexNDArray_h 1
 
 #include "MArrayN.h"
 #include "CMatrix.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
+#include "bsxfun-decl.h"
 
 class
 OCTAVE_API
 ComplexNDArray : public MArrayN<Complex>
 {
 public:
 
   typedef ComplexMatrix matrix_type;
@@ -180,15 +181,18 @@ SND_BOOL_OP_DECLS (Complex, ComplexNDArr
 NDND_CMP_OP_DECLS (ComplexNDArray, ComplexNDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (ComplexNDArray, ComplexNDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, ComplexNDArray, Complex)
 
 extern OCTAVE_API ComplexNDArray& operator *= (ComplexNDArray& a, double s);
 extern OCTAVE_API ComplexNDArray& operator /= (ComplexNDArray& a, double s);
 
+BSXFUN_STDOP_DECLS (ComplexNDArray, OCTAVE_API)
+BSXFUN_STDREL_DECLS (ComplexNDArray, OCTAVE_API)
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,49 @@
+2009-10-20  Jaroslav Hajek  <highegg@gmail.com>
+
+	* bsxfun-decl.h, bsxfun-defs.cc: New sources.
+	* Makefile.in: Add them.
+	* dim-vector.h (dim_vector::compute_index,
+	dim_vector::increment_index): Fix.
+	* mx-inlines.cc (DEFMXMAPPER, DEFMXLOCALMAPPER): New macros.
+	(mx_inline_xmin, mx_inline_xmax): New loops.
+	(mx_inline_fun): Remove.
+	* oct-inttypes.h (xmin (const octave_int<T>&, const octave_int<T>&),
+	xmax (const octave_int<T>&, const octave_int<T>&)):
+	New inline functions.
+
+	* CNDArray.cc: Define bsxfun operations.
+	* boolNDArray.cc: Ditto.
+	* dNDArray.cc: Ditto.
+	* fCNDArray.cc: Ditto.
+	* fNDArray.cc: Ditto.
+	* int16NDArray.cc: Ditto.
+	* int32NDArray.cc: Ditto.
+	* int64NDArray.cc: Ditto.
+	* int8NDArray.cc: Ditto.
+	* uint16NDArray.cc: Ditto.
+	* uint32NDArray.cc: Ditto.
+	* uint64NDArray.cc: Ditto.
+	* uint8NDArray.cc: Ditto.
+
+	* CNDArray.h: Declare bsxfun operations.
+	* boolNDArray.h: Ditto.
+	* dNDArray.h: Ditto.
+	* fCNDArray.h: Ditto.
+	* fNDArray.h: Ditto.
+	* int16NDArray.h: Ditto.
+	* int32NDArray.h: Ditto.
+	* int64NDArray.h: Ditto.
+	* int8NDArray.h: Ditto.
+	* uint16NDArray.h: Ditto.
+	* uint32NDArray.h: Ditto.
+	* uint64NDArray.h: Ditto.
+	* uint8NDArray.h: Ditto.
+
 2009-10-19  Jaroslav Hajek  <highegg@gmail.com>
 
 	* dim-vector.h (dim_vector::compute_index,
 	dim_vector::increment_index, dim_vector::cumulative,
 	dim_vector::cum_compute_index): New methods.
 
 2009-10-18  Carsten Clark  <tantumquantum+gnuoctave@gmail.com>
 
diff --git a/liboctave/Makefile.in b/liboctave/Makefile.in
--- a/liboctave/Makefile.in
+++ b/liboctave/Makefile.in
@@ -45,17 +45,18 @@ LINK_DEPS = \
   $(READLINE_LIBS) $(TERM_LIBS) \
   $(LIBGLOB) $(REGEX_LIBS) $(DL_LIBS) \
   $(FLIBS) \
   $(PTHREAD_LIBS) $(LIBS)
 
 MATRIX_INC := Array.h Array2.h Array3.h ArrayN.h DiagArray2.h \
 	Array-util.h MArray-decl.h MArray-defs.h \
 	MArray.h MArray2.h MDiagArray2.h Matrix.h MArrayN.h \
-	base-lu.h base-qr.h base-aepbal.h dim-vector.h mx-base.h mx-op-decl.h \
+	base-lu.h base-qr.h base-aepbal.h bsxfun-decl.h dim-vector.h \
+	mx-base.h mx-op-decl.h \
 	mx-op-defs.h mx-defs.h mx-ext.h CColVector.h CDiagMatrix.h \
 	CMatrix.h CNDArray.h CRowVector.h CmplxAEPBAL.h CmplxCHOL.h \
 	CmplxGEPBAL.h CmplxHESS.h CmplxLU.h CmplxQR.h CmplxQRP.h \
 	CmplxSCHUR.h CmplxSVD.h EIG.h fEIG.h boolMatrix.h boolNDArray.h \
 	chMatrix.h chNDArray.h dColVector.h dDiagMatrix.h dMatrix.h \
 	dNDArray.h dRowVector.h dbleAEPBAL.h dbleCHOL.h DET.h \
 	dbleGEPBAL.h dbleHESS.h dbleLU.h dbleQR.h dbleQRP.h dbleSCHUR.h \
 	dbleSVD.h boolSparse.h CSparse.h dSparse.h MSparse-defs.h MSparse.h \
@@ -105,17 +106,17 @@ INCLUDES := CollocWt.h DAE.h DAEFunc.h D
 	$(MATRIX_INC)
 
 BUILT_INCLUDES := mx-ops.h \
 	$(OPT_INC) \
 	$(MX_OP_INC) \
 	$(VX_OP_INC) \
 	$(SPARSE_MX_OP_INC)
 
-TEMPLATE_SRC := Array.cc eigs-base.cc DiagArray2.cc \
+TEMPLATE_SRC := Array.cc bsxfun-defs.cc eigs-base.cc DiagArray2.cc \
 	MArray.cc MArray2.cc MArrayN.cc MDiagArray2.cc \
 	base-lu.cc base-qr.cc oct-sort.cc sparse-base-lu.cc \
 	sparse-base-chol.cc sparse-dmsolve.cc
 
 TI_SRC := Array-C.cc Array-b.cc Array-ch.cc Array-i.cc Array-d.cc \
 	Array-f.cc Array-fC.cc Array-s.cc Array-str.cc Array-voidp.cc \
 	Array-idx-vec.cc MArray-C.cc MArray-ch.cc MArray-i.cc MArray-d.cc \
 	MArray-f.cc MArray-fC.cc MArray-s.cc MSparse-C.cc MSparse-d.cc \
diff --git a/liboctave/boolNDArray.cc b/liboctave/boolNDArray.cc
--- a/liboctave/boolNDArray.cc
+++ b/liboctave/boolNDArray.cc
@@ -29,16 +29,18 @@ along with Octave; see the file COPYING.
 
 #include "Array-util.h"
 #include "CNDArray.h"
 #include "mx-base.h"
 #include "lo-ieee.h"
 #include "mx-op-defs.h"
 #include "MArray-defs.h"
 
+#include "bsxfun-defs.cc"
+
 // unary operations
 
 boolNDArray
 boolNDArray::operator ! (void) const
 {
   return do_mx_unary_op<boolNDArray> (*this, mx_inline_not);
 }
 
@@ -179,13 +181,16 @@ mx_el_or_assign (boolNDArray& a, const b
   if (a.is_shared ())
     a = mx_el_or (a, b);
   else
     do_mm_inplace_op<boolNDArray, boolNDArray> (a, b, mx_inline_or2, "operator |=");
 
   return a;
 }
 
+BSXFUN_OP_DEF_MXLOOP (and, boolNDArray, mx_inline_and)
+BSXFUN_OP_DEF_MXLOOP (or, boolNDArray, mx_inline_or)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/boolNDArray.h b/liboctave/boolNDArray.h
--- a/liboctave/boolNDArray.h
+++ b/liboctave/boolNDArray.h
@@ -22,19 +22,21 @@ along with Octave; see the file COPYING.
 
 #if !defined (octave_boolNDArray_h)
 #define octave_boolNDArray_h 1
 
 #include "Array.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
+#include "bsxfun-decl.h"
 
 #include "boolMatrix.h"
 
+
 class
 OCTAVE_API
 boolNDArray : public Array<bool>
 {
 public:
 
   typedef boolMatrix matrix_type;
 
@@ -132,15 +134,18 @@ NDS_CMP_OP_DECLS (boolNDArray, bool, OCT
 SND_BOOL_OP_DECLS (bool, boolNDArray, OCTAVE_API)
 SND_CMP_OP_DECLS (bool, boolNDArray, OCTAVE_API)
 
 extern OCTAVE_API boolNDArray& 
 mx_el_and_assign (boolNDArray& m, const boolNDArray& a);
 extern OCTAVE_API boolNDArray& 
 mx_el_or_assign (boolNDArray& m, const boolNDArray& a);
 
+BSXFUN_OP_DECL (and, boolNDArray, OCTAVE_API);
+BSXFUN_OP_DECL (or, boolNDArray, OCTAVE_API);
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -38,16 +38,18 @@ along with Octave; see the file COPYING.
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "mx-base.h"
 #include "mx-op-defs.h"
 #include "oct-fftw.h"
 #include "oct-locbuf.h"
 
+#include "bsxfun-defs.cc"
+
 NDArray::NDArray (const Array<octave_idx_type>& a, bool zero_based,
 		  bool negative_to_nan)
 {
   const octave_idx_type *pa = a.fortran_vec ();
   resize (a.dims ());
   double *ptmp = fortran_vec ();
   if (negative_to_nan)
     {
@@ -1127,13 +1129,16 @@ NDS_CMP_OPS (NDArray, double)
 NDS_BOOL_OPS (NDArray, double)
 
 SND_CMP_OPS (double, NDArray)
 SND_BOOL_OPS (double, NDArray)
 
 NDND_CMP_OPS (NDArray, NDArray)
 NDND_BOOL_OPS (NDArray, NDArray)
 
+BSXFUN_STDOP_DEFS_MXLOOP (NDArray)
+BSXFUN_STDREL_DEFS_MXLOOP (NDArray)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 #define octave_NDArray_h 1
 
 #include "MArrayN.h"
 #include "dMatrix.h"
 #include "intNDArray.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
+#include "bsxfun-decl.h"
 
 class
 OCTAVE_API
 NDArray : public MArrayN<double>
 {
 public:
 
   typedef Matrix matrix_type;
@@ -190,15 +191,18 @@ NDS_BOOL_OP_DECLS (NDArray, double, OCTA
 SND_CMP_OP_DECLS (double, NDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (double, NDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (NDArray, NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (NDArray, NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, NDArray, double)
 
+BSXFUN_STDOP_DECLS (NDArray, OCTAVE_API)
+BSXFUN_STDREL_DECLS (NDArray, OCTAVE_API)
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/dim-vector.h b/liboctave/dim-vector.h
--- a/liboctave/dim-vector.h
+++ b/liboctave/dim-vector.h
@@ -515,32 +515,32 @@ public:
 
       return def;      
     }
 
   // Computes a linear index from an index tuple.
   octave_idx_type compute_index (const octave_idx_type *idx)
     {
       octave_idx_type k = 0;
-      for (int i = length () - 1; i >= 0; i++)
+      for (int i = length () - 1; i >= 0; i--)
         k = k * rep[i] + idx[i];
 
       return k;
     }
 
   // Increments a multi-dimensional index tuple, optionally starting
   // from an offset position. Returns the index of the last index
   // position that was changed, or length () if just cycled over.
   int increment_index (octave_idx_type *idx, int start = 0)
     {
       int i;
       for (i = start; i < length (); i++)
         {
           if (++(*idx) == rep[i])
-            *idx = 0;
+            *idx++ = 0;
           else
             break;
         }
       return i;
     }
 
   // Returns cumulative dimensions.
   dim_vector cumulative (void) const
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -38,16 +38,18 @@ along with Octave; see the file COPYING.
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "MArray-defs.h"
 #include "mx-base.h"
 #include "mx-op-defs.h"
 #include "oct-fftw.h"
 #include "oct-locbuf.h"
 
+#include "bsxfun-defs.cc"
+
 FloatComplexNDArray::FloatComplexNDArray (const charNDArray& a)
   : MArrayN<FloatComplex> (a.dims ())
 {
   octave_idx_type n = a.numel ();
   for (octave_idx_type i = 0; i < n; i++)
     xelem (i) = static_cast<unsigned char> (a(i));
 }
 
@@ -1094,13 +1096,16 @@ FloatComplexNDArray& operator /= (FloatC
 {
   if (a.is_shared ())
     a = a / s;
   else
     do_ms_inplace_op<FloatComplexNDArray, float> (a, s, mx_inline_div2);
   return a;
 }
 
+BSXFUN_STDOP_DEFS_MXLOOP (FloatComplexNDArray)
+BSXFUN_STDREL_DEFS_MXLOOP (FloatComplexNDArray)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/fCNDArray.h b/liboctave/fCNDArray.h
--- a/liboctave/fCNDArray.h
+++ b/liboctave/fCNDArray.h
@@ -23,16 +23,17 @@ along with Octave; see the file COPYING.
 #if !defined (octave_FloatComplexNDArray_h)
 #define octave_FloatComplexNDArray_h 1
 
 #include "MArrayN.h"
 #include "fCMatrix.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
+#include "bsxfun-decl.h"
 
 class
 OCTAVE_API
 FloatComplexNDArray : public MArrayN<FloatComplex>
 {
 public:
 
   typedef FloatComplexMatrix matrix_type;
@@ -180,15 +181,18 @@ SND_BOOL_OP_DECLS (FloatComplex, FloatCo
 NDND_CMP_OP_DECLS (FloatComplexNDArray, FloatComplexNDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (FloatComplexNDArray, FloatComplexNDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, FloatComplexNDArray, FloatComplex)
 
 extern OCTAVE_API FloatComplexNDArray& operator *= (FloatComplexNDArray& a, float s);
 extern OCTAVE_API FloatComplexNDArray& operator /= (FloatComplexNDArray& a, float s);
 
+BSXFUN_STDOP_DECLS (FloatComplexNDArray, OCTAVE_API)
+BSXFUN_STDREL_DECLS (FloatComplexNDArray, OCTAVE_API)
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -38,16 +38,18 @@ along with Octave; see the file COPYING.
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "mx-base.h"
 #include "mx-op-defs.h"
 #include "oct-fftw.h"
 #include "oct-locbuf.h"
 
+#include "bsxfun-defs.cc"
+
 FloatNDArray::FloatNDArray (const charNDArray& a)
   : MArrayN<float> (a.dims ())
 {
   octave_idx_type n = a.numel ();
   for (octave_idx_type i = 0; i < n; i++)
     xelem (i) = static_cast<unsigned char> (a(i));
 }
 
@@ -1085,13 +1087,16 @@ NDS_CMP_OPS (FloatNDArray, float)
 NDS_BOOL_OPS (FloatNDArray, float)
 
 SND_CMP_OPS (float, FloatNDArray)
 SND_BOOL_OPS (float, FloatNDArray)
 
 NDND_CMP_OPS (FloatNDArray, FloatNDArray)
 NDND_BOOL_OPS (FloatNDArray, FloatNDArray)
 
+BSXFUN_STDOP_DEFS_MXLOOP (FloatNDArray)
+BSXFUN_STDREL_DEFS_MXLOOP (FloatNDArray)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/fNDArray.h b/liboctave/fNDArray.h
--- a/liboctave/fNDArray.h
+++ b/liboctave/fNDArray.h
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 #define octave_FloatNDArray_h 1
 
 #include "MArrayN.h"
 #include "fMatrix.h"
 #include "intNDArray.h"
 
 #include "mx-defs.h"
 #include "mx-op-decl.h"
+#include "bsxfun-decl.h"
 
 class
 OCTAVE_API
 FloatNDArray : public MArrayN<float>
 {
 public:
 
   typedef FloatMatrix matrix_type;
@@ -187,15 +188,18 @@ NDS_BOOL_OP_DECLS (FloatNDArray, float, 
 SND_CMP_OP_DECLS (float, FloatNDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (float, FloatNDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (FloatNDArray, FloatNDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (FloatNDArray, FloatNDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, FloatNDArray, float)
 
+BSXFUN_STDOP_DECLS (FloatNDArray, OCTAVE_API)
+BSXFUN_STDREL_DECLS (FloatNDArray, OCTAVE_API)
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/int16NDArray.cc b/liboctave/int16NDArray.cc
--- a/liboctave/int16NDArray.cc
+++ b/liboctave/int16NDArray.cc
@@ -24,16 +24,18 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "int16NDArray.h"
 #include "mx-op-defs.h"
 #include "intNDArray.cc"
 
+#include "bsxfun-defs.cc"
+
 template class OCTAVE_API intNDArray<octave_int16>;
 
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_int16>& a);
 
 template OCTAVE_API
 std::istream&
@@ -45,13 +47,16 @@ NDS_BOOL_OPS (int16NDArray, octave_int16
 SND_CMP_OPS (octave_int16, int16NDArray)
 SND_BOOL_OPS (octave_int16, int16NDArray)
 
 NDND_CMP_OPS (int16NDArray, int16NDArray)
 NDND_BOOL_OPS (int16NDArray, int16NDArray)
 
 MINMAX_FCNS (int16)
 
+BSXFUN_STDOP_DEFS_MXLOOP (int16NDArray)
+BSXFUN_STDREL_DEFS_MXLOOP (int16NDArray)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/int16NDArray.h b/liboctave/int16NDArray.h
--- a/liboctave/int16NDArray.h
+++ b/liboctave/int16NDArray.h
@@ -21,31 +21,35 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_int16NDArray_h)
 #define octave_int16NDArray_h 1
 
 #include "intNDArray.h"
 #include "mx-op-decl.h"
 #include "oct-inttypes.h"
+#include "bsxfun-decl.h"
 
 typedef intNDArray<octave_int16> int16NDArray;
 
 NDS_CMP_OP_DECLS (int16NDArray, octave_int16, OCTAVE_API)
 NDS_BOOL_OP_DECLS (int16NDArray, octave_int16, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_int16, int16NDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (octave_int16, int16NDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (int16NDArray, int16NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (int16NDArray, int16NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, int16NDArray, octave_int16)
 
 MINMAX_DECLS (int16)
 
+BSXFUN_STDOP_DECLS (int16NDArray, OCTAVE_API)
+BSXFUN_STDREL_DECLS (int16NDArray, OCTAVE_API)
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/int32NDArray.cc b/liboctave/int32NDArray.cc
--- a/liboctave/int32NDArray.cc
+++ b/liboctave/int32NDArray.cc
@@ -24,16 +24,18 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "int32NDArray.h"
 #include "mx-op-defs.h"
 #include "intNDArray.cc"
 
+#include "bsxfun-defs.cc"
+
 template class OCTAVE_API intNDArray<octave_int32>;
 
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_int32>& a);
 
 template OCTAVE_API
 std::istream&
@@ -45,13 +47,16 @@ NDS_BOOL_OPS (int32NDArray, octave_int32
 SND_CMP_OPS (octave_int32, int32NDArray)
 SND_BOOL_OPS (octave_int32, int32NDArray)
 
 NDND_CMP_OPS (int32NDArray, int32NDArray)
 NDND_BOOL_OPS (int32NDArray, int32NDArray)
 
 MINMAX_FCNS (int32)
 
+BSXFUN_STDOP_DEFS_MXLOOP (int32NDArray)
+BSXFUN_STDREL_DEFS_MXLOOP (int32NDArray)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/int32NDArray.h b/liboctave/int32NDArray.h
--- a/liboctave/int32NDArray.h
+++ b/liboctave/int32NDArray.h
@@ -21,31 +21,35 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_int32NDArray_h)
 #define octave_int32NDArray_h 1
 
 #include "intNDArray.h"
 #include "mx-op-decl.h"
 #include "oct-inttypes.h"
+#include "bsxfun-decl.h"
 
 typedef intNDArray<octave_int32> int32NDArray;
 
 NDS_CMP_OP_DECLS (int32NDArray, octave_int32, OCTAVE_API)
 NDS_BOOL_OP_DECLS (int32NDArray, octave_int32, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_int32, int32NDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (octave_int32, int32NDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (int32NDArray, int32NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (int32NDArray, int32NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, int32NDArray, octave_int32)
 
 MINMAX_DECLS (int32)
 
+BSXFUN_STDOP_DECLS (int32NDArray, OCTAVE_API)
+BSXFUN_STDREL_DECLS (int32NDArray, OCTAVE_API)
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/int64NDArray.cc b/liboctave/int64NDArray.cc
--- a/liboctave/int64NDArray.cc
+++ b/liboctave/int64NDArray.cc
@@ -24,16 +24,18 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "int64NDArray.h"
 #include "mx-op-defs.h"
 #include "intNDArray.cc"
 
+#include "bsxfun-defs.cc"
+
 template class OCTAVE_API intNDArray<octave_int64>;
 
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_int64>& a);
 
 template OCTAVE_API
 std::istream&
@@ -45,13 +47,16 @@ NDS_BOOL_OPS (int64NDArray, octave_int64
 SND_CMP_OPS (octave_int64, int64NDArray)
 SND_BOOL_OPS (octave_int64, int64NDArray)
 
 NDND_CMP_OPS (int64NDArray, int64NDArray)
 NDND_BOOL_OPS (int64NDArray, int64NDArray)
 
 MINMAX_FCNS (int64)
 
+BSXFUN_STDOP_DEFS_MXLOOP (int64NDArray)
+BSXFUN_STDREL_DEFS_MXLOOP (int64NDArray)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/int64NDArray.h b/liboctave/int64NDArray.h
--- a/liboctave/int64NDArray.h
+++ b/liboctave/int64NDArray.h
@@ -21,31 +21,35 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_int64NDArray_h)
 #define octave_int64NDArray_h 1
 
 #include "intNDArray.h"
 #include "mx-op-decl.h"
 #include "oct-inttypes.h"
+#include "bsxfun-decl.h"
 
 typedef intNDArray<octave_int64> int64NDArray;
 
 NDS_CMP_OP_DECLS (int64NDArray, octave_int64, OCTAVE_API)
 NDS_BOOL_OP_DECLS (int64NDArray, octave_int64, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_int64, int64NDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (octave_int64, int64NDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (int64NDArray, int64NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (int64NDArray, int64NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, int64NDArray, octave_int64)
 
 MINMAX_DECLS (int64)
 
+BSXFUN_STDOP_DECLS (int64NDArray, OCTAVE_API)
+BSXFUN_STDREL_DECLS (int64NDArray, OCTAVE_API)
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/int8NDArray.cc b/liboctave/int8NDArray.cc
--- a/liboctave/int8NDArray.cc
+++ b/liboctave/int8NDArray.cc
@@ -24,16 +24,18 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "int8NDArray.h"
 #include "mx-op-defs.h"
 #include "intNDArray.cc"
 
+#include "bsxfun-defs.cc"
+
 template class OCTAVE_API intNDArray<octave_int8>;
 
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_int8>& a);
 
 template OCTAVE_API
 std::istream&
@@ -45,13 +47,16 @@ NDS_BOOL_OPS (int8NDArray, octave_int8)
 SND_CMP_OPS (octave_int8, int8NDArray)
 SND_BOOL_OPS (octave_int8, int8NDArray)
 
 NDND_CMP_OPS (int8NDArray, int8NDArray)
 NDND_BOOL_OPS (int8NDArray, int8NDArray)
 
 MINMAX_FCNS (int8)
 
+BSXFUN_STDOP_DEFS_MXLOOP (int8NDArray)
+BSXFUN_STDREL_DEFS_MXLOOP (int8NDArray)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/int8NDArray.h b/liboctave/int8NDArray.h
--- a/liboctave/int8NDArray.h
+++ b/liboctave/int8NDArray.h
@@ -21,31 +21,35 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_int8NDArray_h)
 #define octave_int8NDArray_h 1
 
 #include "intNDArray.h"
 #include "mx-op-decl.h"
 #include "oct-inttypes.h"
+#include "bsxfun-decl.h"
 
 typedef intNDArray<octave_int8> int8NDArray;
 
 NDS_CMP_OP_DECLS (int8NDArray, octave_int8, OCTAVE_API)
 NDS_BOOL_OP_DECLS (int8NDArray, octave_int8, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_int8, int8NDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (octave_int8, int8NDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (int8NDArray, int8NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (int8NDArray, int8NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, int8NDArray, octave_int8)
 
 MINMAX_DECLS (int8)
 
+BSXFUN_STDOP_DECLS (int8NDArray, OCTAVE_API)
+BSXFUN_STDREL_DECLS (int8NDArray, OCTAVE_API)
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/mx-inlines.cc b/liboctave/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/mx-inlines.cc
@@ -192,49 +192,38 @@ mx_inline_any_nan (size_t n, const T* t)
   return false; \
 }
 
 DEFMXANYNAN(double)
 DEFMXANYNAN(float)
 DEFMXANYNAN(Complex)
 DEFMXANYNAN(FloatComplex)
 
-// Arbitrary unary/binary function mappers. Note the function reference is a
-// template parameter!
-template <class R, class X, R F(X)>
-void mx_inline_fun (size_t n, R *r, const X *x)
-{ for (size_t i = 0; i < n; i++) r[i] = F(x[i]); }
-
-template <class R, class X, R F(const X&)>
-void mx_inline_fun (size_t n, R *r, const X *x)
-{ for (size_t i = 0; i < n; i++) r[i] = F(x[i]); }
-
-template <class R, class X, class Y, R F(X, Y)>
-void mx_inline_fun (size_t n, R *r, const X *x, const Y *y)
-{ for (size_t i = 0; i < n; i++) r[i] = F(x[i], y[i]); }
+// Pairwise minimums/maximums
+#define DEFMXMAPPER(F, FUN) \
+template <class T> \
+inline void F (size_t n, T *r, const T *x, const T *y) \
+{ for (size_t i = 0; i < n; i++) r[i] = FUN (x[i], y[i]); } \
+template <class T> \
+inline void F (size_t n, T *r, const T *x, T y) \
+{ for (size_t i = 0; i < n; i++) r[i] = FUN (x[i], y); } \
+template <class T> \
+inline void F (size_t n, T *r, T x, const T *y) \
+{ for (size_t i = 0; i < n; i++) r[i] = FUN (x, y[i]); }
 
-template <class R, class X, class Y, R F(X, Y)>
-void mx_inline_fun (size_t n, R *r, X x, const Y *y)
-{ for (size_t i = 0; i < n; i++) r[i] = F(x, y[i]); }
-
-template <class R, class X, class Y, R F(X, Y)>
-void mx_inline_fun (size_t n, R *r, const X *x, Y y)
-{ for (size_t i = 0; i < n; i++) r[i] = F(x[i], y); }
+DEFMXMAPPER (mx_inline_xmin, xmin)
+DEFMXMAPPER (mx_inline_xmax, xmax)
 
-template <class R, class X, class Y, R F(const X&, const Y&)>
-void mx_inline_fun (size_t n, R *r, const X *x, const Y *y)
-{ for (size_t i = 0; i < n; i++) r[i] = F(x[i], y[i]); }
-
-template <class R, class X, class Y, R F(const X&, const Y&)>
-void mx_inline_fun (size_t n, R *r, X x, const Y *y)
-{ for (size_t i = 0; i < n; i++) r[i] = F(x, y[i]); }
-
-template <class R, class X, class Y, R F(const X&, const Y&)>
-void mx_inline_fun (size_t n, R *r, const X *x, Y y)
-{ for (size_t i = 0; i < n; i++) r[i] = F(x[i], y); }
+#define DEFMXLOCALMAPPER(F, FUN, T) \
+static void F (size_t n, T *r, const T *x, const T *y) \
+{ for (size_t i = 0; i < n; i++) r[i] = FUN (x[i], y[i]); } \
+static void F (size_t n, T *r, const T *x, T y) \
+{ for (size_t i = 0; i < n; i++) r[i] = FUN (x[i], y); } \
+static void F (size_t n, T *r, T x, const T *y) \
+{ for (size_t i = 0; i < n; i++) r[i] = FUN (x, y[i]); }
 
 // Appliers. Since these call the operation just once, we pass it as
 // a pointer, to allow the compiler reduce number of instances.
 
 template <class RNDA, class XNDA>
 inline RNDA 
 do_mx_unary_op (const XNDA& x,
                 void (*op) (size_t, typename RNDA::element_type *,
diff --git a/liboctave/oct-inttypes.h b/liboctave/oct-inttypes.h
--- a/liboctave/oct-inttypes.h
+++ b/liboctave/oct-inttypes.h
@@ -1085,15 +1085,31 @@ OCTAVE_INT_FLOAT_CMP_OP (<)
 OCTAVE_INT_FLOAT_CMP_OP (<=)
 OCTAVE_INT_FLOAT_CMP_OP (>=)
 OCTAVE_INT_FLOAT_CMP_OP (>)
 OCTAVE_INT_FLOAT_CMP_OP (==)
 OCTAVE_INT_FLOAT_CMP_OP (!=)
 
 #undef OCTAVE_INT_FLOAT_CMP_OP
 
+template <class T>
+octave_int<T>
+xmax (const octave_int<T>& x, const octave_int<T>& y)
+{
+  const T xv = x.value (), yv = y.value ();
+  return octave_int<T> (xv >= yv ? xv : yv); 
+}
+
+template <class T>
+octave_int<T>
+xmin (const octave_int<T>& x, const octave_int<T>& y)
+{
+  const T xv = x.value (), yv = y.value ();
+  return octave_int<T> (xv <= yv ? xv : yv); 
+}
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/uint16NDArray.cc b/liboctave/uint16NDArray.cc
--- a/liboctave/uint16NDArray.cc
+++ b/liboctave/uint16NDArray.cc
@@ -24,16 +24,18 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "uint16NDArray.h"
 #include "mx-op-defs.h"
 #include "intNDArray.cc"
 
+#include "bsxfun-defs.cc"
+
 template class OCTAVE_API intNDArray<octave_uint16>;
 
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_uint16>& a);
 
 template OCTAVE_API
 std::istream&
@@ -45,13 +47,16 @@ NDS_BOOL_OPS (uint16NDArray, octave_uint
 SND_CMP_OPS (octave_uint16, uint16NDArray)
 SND_BOOL_OPS (octave_uint16, uint16NDArray)
 
 NDND_CMP_OPS (uint16NDArray, uint16NDArray)
 NDND_BOOL_OPS (uint16NDArray, uint16NDArray)
 
 MINMAX_FCNS (uint16)
 
+BSXFUN_STDOP_DEFS_MXLOOP (uint16NDArray)
+BSXFUN_STDREL_DEFS_MXLOOP (uint16NDArray)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/uint16NDArray.h b/liboctave/uint16NDArray.h
--- a/liboctave/uint16NDArray.h
+++ b/liboctave/uint16NDArray.h
@@ -21,31 +21,35 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_uint16NDArray_h)
 #define octave_uint16NDArray_h 1
 
 #include "intNDArray.h"
 #include "mx-op-decl.h"
 #include "oct-inttypes.h"
+#include "bsxfun-decl.h"
 
 typedef intNDArray<octave_uint16> uint16NDArray;
 
 NDS_CMP_OP_DECLS (uint16NDArray, octave_uint16, OCTAVE_API)
 NDS_BOOL_OP_DECLS (uint16NDArray, octave_uint16, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_uint16, uint16NDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (octave_uint16, uint16NDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (uint16NDArray, uint16NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (uint16NDArray, uint16NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, uint16NDArray, octave_uint16)
 
 MINMAX_DECLS (uint16)
 
+BSXFUN_STDOP_DECLS (uint16NDArray, OCTAVE_API)
+BSXFUN_STDREL_DECLS (uint16NDArray, OCTAVE_API)
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/uint32NDArray.cc b/liboctave/uint32NDArray.cc
--- a/liboctave/uint32NDArray.cc
+++ b/liboctave/uint32NDArray.cc
@@ -24,16 +24,18 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "uint32NDArray.h"
 #include "mx-op-defs.h"
 #include "intNDArray.cc"
 
+#include "bsxfun-defs.cc"
+
 template class OCTAVE_API intNDArray<octave_uint32>;
 
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_uint32>& a);
 
 template OCTAVE_API
 std::istream&
@@ -45,13 +47,16 @@ NDS_BOOL_OPS (uint32NDArray, octave_uint
 SND_CMP_OPS (octave_uint32, uint32NDArray)
 SND_BOOL_OPS (octave_uint32, uint32NDArray)
 
 NDND_CMP_OPS (uint32NDArray, uint32NDArray)
 NDND_BOOL_OPS (uint32NDArray, uint32NDArray)
 
 MINMAX_FCNS (uint32)
 
+BSXFUN_STDOP_DEFS_MXLOOP (uint32NDArray)
+BSXFUN_STDREL_DEFS_MXLOOP (uint32NDArray)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/uint32NDArray.h b/liboctave/uint32NDArray.h
--- a/liboctave/uint32NDArray.h
+++ b/liboctave/uint32NDArray.h
@@ -21,31 +21,35 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_uint32NDArray_h)
 #define octave_uint32NDArray_h 1
 
 #include "intNDArray.h"
 #include "mx-op-decl.h"
 #include "oct-inttypes.h"
+#include "bsxfun-decl.h"
 
 typedef intNDArray<octave_uint32> uint32NDArray;
 
 NDS_CMP_OP_DECLS (uint32NDArray, octave_uint32, OCTAVE_API)
 NDS_BOOL_OP_DECLS (uint32NDArray, octave_uint32, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_uint32, uint32NDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (octave_uint32, uint32NDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (uint32NDArray, uint32NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (uint32NDArray, uint32NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, uint32NDArray, octave_uint32)
 
 MINMAX_DECLS (uint32)
 
+BSXFUN_STDOP_DECLS (uint32NDArray, OCTAVE_API)
+BSXFUN_STDREL_DECLS (uint32NDArray, OCTAVE_API)
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/uint64NDArray.cc b/liboctave/uint64NDArray.cc
--- a/liboctave/uint64NDArray.cc
+++ b/liboctave/uint64NDArray.cc
@@ -24,16 +24,18 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "uint64NDArray.h"
 #include "mx-op-defs.h"
 #include "intNDArray.cc"
 
+#include "bsxfun-defs.cc"
+
 template class OCTAVE_API intNDArray<octave_uint64>;
 
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_uint64>& a);
 
 template OCTAVE_API
 std::istream&
@@ -45,13 +47,16 @@ NDS_BOOL_OPS (uint64NDArray, octave_uint
 SND_CMP_OPS (octave_uint64, uint64NDArray)
 SND_BOOL_OPS (octave_uint64, uint64NDArray)
 
 NDND_CMP_OPS (uint64NDArray, uint64NDArray)
 NDND_BOOL_OPS (uint64NDArray, uint64NDArray)
 
 MINMAX_FCNS (uint64)
 
+BSXFUN_STDOP_DEFS_MXLOOP (uint64NDArray)
+BSXFUN_STDREL_DEFS_MXLOOP (uint64NDArray)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/uint64NDArray.h b/liboctave/uint64NDArray.h
--- a/liboctave/uint64NDArray.h
+++ b/liboctave/uint64NDArray.h
@@ -21,31 +21,35 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_uint64NDArray_h)
 #define octave_uint64NDArray_h 1
 
 #include "intNDArray.h"
 #include "mx-op-decl.h"
 #include "oct-inttypes.h"
+#include "bsxfun-decl.h"
 
 typedef intNDArray<octave_uint64> uint64NDArray;
 
 NDS_CMP_OP_DECLS (uint64NDArray, octave_uint64, OCTAVE_API)
 NDS_BOOL_OP_DECLS (uint64NDArray, octave_uint64, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_uint64, uint64NDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (octave_uint64, uint64NDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (uint64NDArray, uint64NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (uint64NDArray, uint64NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, uint64NDArray, octave_uint64)
 
 MINMAX_DECLS (uint64)
 
+BSXFUN_STDOP_DECLS (uint64NDArray, OCTAVE_API)
+BSXFUN_STDREL_DECLS (uint64NDArray, OCTAVE_API)
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/uint8NDArray.cc b/liboctave/uint8NDArray.cc
--- a/liboctave/uint8NDArray.cc
+++ b/liboctave/uint8NDArray.cc
@@ -24,16 +24,18 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "uint8NDArray.h"
 #include "mx-op-defs.h"
 #include "intNDArray.cc"
 
+#include "bsxfun-defs.cc"
+
 template class OCTAVE_API intNDArray<octave_uint8>;
 
 template OCTAVE_API
 std::ostream&
 operator << (std::ostream& os, const intNDArray<octave_uint8>& a);
 
 template OCTAVE_API
 std::istream&
@@ -45,13 +47,16 @@ NDS_BOOL_OPS (uint8NDArray, octave_uint8
 SND_CMP_OPS (octave_uint8, uint8NDArray)
 SND_BOOL_OPS (octave_uint8, uint8NDArray)
 
 NDND_CMP_OPS (uint8NDArray, uint8NDArray)
 NDND_BOOL_OPS (uint8NDArray, uint8NDArray)
 
 MINMAX_FCNS (uint8)
 
+BSXFUN_STDOP_DEFS_MXLOOP (uint8NDArray)
+BSXFUN_STDREL_DEFS_MXLOOP (uint8NDArray)
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/uint8NDArray.h b/liboctave/uint8NDArray.h
--- a/liboctave/uint8NDArray.h
+++ b/liboctave/uint8NDArray.h
@@ -21,31 +21,35 @@ along with Octave; see the file COPYING.
 */
 
 #if !defined (octave_uint8NDArray_h)
 #define octave_uint8NDArray_h 1
 
 #include "intNDArray.h"
 #include "mx-op-decl.h"
 #include "oct-inttypes.h"
+#include "bsxfun-decl.h"
 
 typedef intNDArray<octave_uint8> uint8NDArray;
 
 NDS_CMP_OP_DECLS (uint8NDArray, octave_uint8, OCTAVE_API)
 NDS_BOOL_OP_DECLS (uint8NDArray, octave_uint8, OCTAVE_API)
 
 SND_CMP_OP_DECLS (octave_uint8, uint8NDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (octave_uint8, uint8NDArray, OCTAVE_API)
 
 NDND_CMP_OP_DECLS (uint8NDArray, uint8NDArray, OCTAVE_API)
 NDND_BOOL_OP_DECLS (uint8NDArray, uint8NDArray, OCTAVE_API)
 
 MARRAY_FORWARD_DEFS (MArrayN, uint8NDArray, octave_uint8)
 
 MINMAX_DECLS (uint8)
 
+BSXFUN_STDOP_DECLS (uint8NDArray, OCTAVE_API)
+BSXFUN_STDREL_DECLS (uint8NDArray, OCTAVE_API)
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,19 @@
+2009-10-20  Jaroslav Hajek  <highegg@gmail.com>
+
+	* ov-base.h (builtin_type_t): Declare also btyp_num_types.
+	* DLD-FUNCTIONS/bsxfun.cc (bsxfun_builtin_op): New enum.
+	(bsxfun_handler): New typedef.
+	(bsxfun_builtin_names, bsxfun_handler_table): New variables.
+	(bsxfun_builtin_lookup, maybe_fill_table, maybe_optimized_builtin):
+	New static funcs.
+	(bsxfun_forward_op, bsxfun_forward_rel): New static template funcs.
+	(Fbsxfun): Try to optimize some built-in operations.
+
 2009-10-19  Jaroslav Hajek  <highegg@gmail.com>
 
 	* DLD-FUNCTIONS/cellfun.cc (Fcellslices): Allow non-positive indices
 	as bounds.
 
 2009-10-17  Jaroslav Hajek  <highegg@gmail.com>
 
 	* data.cc (Fnth_element): Clarify docstring.
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -31,16 +31,164 @@ along with Octave; see the file COPYING.
 #include "lo-mappers.h"
 
 #include "oct-map.h"
 #include "defun-dld.h"
 #include "parse.h"
 #include "variables.h"
 #include "ov-colon.h"
 #include "unwind-prot.h"
+#include "ov-fcn-handle.h"
+
+// Optimized bsxfun operations
+enum bsxfun_builtin_op
+{
+  bsxfun_builtin_plus = 0,
+  bsxfun_builtin_minus,
+  bsxfun_builtin_times,
+  bsxfun_builtin_divide,
+  bsxfun_builtin_max,
+  bsxfun_builtin_min,
+  bsxfun_builtin_eq,
+  bsxfun_builtin_ne,
+  bsxfun_builtin_lt,
+  bsxfun_builtin_le,
+  bsxfun_builtin_gt,
+  bsxfun_builtin_ge,
+  bsxfun_builtin_and,
+  bsxfun_builtin_or,
+  bsxfun_builtin_unknown,
+  bsxfun_num_builtin_ops = bsxfun_builtin_unknown
+};
+
+const char *bsxfun_builtin_names[] = 
+{
+  "plus",
+  "minus",
+  "times",
+  "rdivide",
+  "max",
+  "min",
+  "eq",
+  "ne",
+  "lt",
+  "le",
+  "gt",
+  "ge",
+  "and",
+  "or"
+};
+
+static bsxfun_builtin_op 
+bsxfun_builtin_lookup (const std::string& name)
+{
+  for (int i = 0; i < bsxfun_num_builtin_ops; i++)
+    if (name == bsxfun_builtin_names[i])
+      return static_cast<bsxfun_builtin_op> (i);
+  return bsxfun_builtin_unknown;
+}
+
+typedef octave_value (*bsxfun_handler) (const octave_value&, const octave_value&);
+
+// Static table of handlers.
+bsxfun_handler bsxfun_handler_table[bsxfun_num_builtin_ops][btyp_num_types];
+
+template <class NDA, NDA (bsxfun_op) (const NDA&, const NDA&)> 
+static octave_value 
+bsxfun_forward_op (const octave_value& x, const octave_value& y)
+{
+  NDA xa = octave_value_extract<NDA> (x);
+  NDA ya = octave_value_extract<NDA> (y);
+  return octave_value (bsxfun_op (xa, ya));
+}
+
+template <class NDA, boolNDArray (bsxfun_rel) (const NDA&, const NDA&)> 
+static octave_value 
+bsxfun_forward_rel (const octave_value& x, const octave_value& y)
+{
+  NDA xa = octave_value_extract<NDA> (x);
+  NDA ya = octave_value_extract<NDA> (y);
+  return octave_value (bsxfun_rel (xa, ya));
+}
+
+static void maybe_fill_table (void)
+{
+  static bool filled = false;
+  if (filled)
+    return;
+
+#define REGISTER_OP_HANDLER(OP, BTYP, NDA, FUNOP) \
+  bsxfun_handler_table[OP][BTYP] = bsxfun_forward_op<NDA, FUNOP>
+#define REGISTER_REL_HANDLER(REL, BTYP, NDA, FUNREL) \
+  bsxfun_handler_table[REL][BTYP] = bsxfun_forward_rel<NDA, FUNREL>
+#define REGISTER_STD_HANDLERS(BTYP, NDA) \
+  REGISTER_OP_HANDLER (bsxfun_builtin_plus, BTYP, NDA, bsxfun_add); \
+  REGISTER_OP_HANDLER (bsxfun_builtin_minus, BTYP, NDA, bsxfun_sub); \
+  REGISTER_OP_HANDLER (bsxfun_builtin_times, BTYP, NDA, bsxfun_mul); \
+  REGISTER_OP_HANDLER (bsxfun_builtin_divide, BTYP, NDA, bsxfun_div); \
+  REGISTER_OP_HANDLER (bsxfun_builtin_max, BTYP, NDA, bsxfun_max); \
+  REGISTER_OP_HANDLER (bsxfun_builtin_min, BTYP, NDA, bsxfun_min); \
+  REGISTER_REL_HANDLER (bsxfun_builtin_eq, BTYP, NDA, bsxfun_eq); \
+  REGISTER_REL_HANDLER (bsxfun_builtin_ne, BTYP, NDA, bsxfun_ne); \
+  REGISTER_REL_HANDLER (bsxfun_builtin_lt, BTYP, NDA, bsxfun_lt); \
+  REGISTER_REL_HANDLER (bsxfun_builtin_le, BTYP, NDA, bsxfun_le); \
+  REGISTER_REL_HANDLER (bsxfun_builtin_gt, BTYP, NDA, bsxfun_gt); \
+  REGISTER_REL_HANDLER (bsxfun_builtin_ge, BTYP, NDA, bsxfun_ge)
+
+  REGISTER_STD_HANDLERS (btyp_double, NDArray);
+  REGISTER_STD_HANDLERS (btyp_float, FloatNDArray);
+  REGISTER_STD_HANDLERS (btyp_complex, ComplexNDArray);
+  REGISTER_STD_HANDLERS (btyp_float_complex, FloatComplexNDArray);
+  REGISTER_STD_HANDLERS (btyp_int8,  int8NDArray);
+  REGISTER_STD_HANDLERS (btyp_int16, int16NDArray);
+  REGISTER_STD_HANDLERS (btyp_int32, int32NDArray);
+  REGISTER_STD_HANDLERS (btyp_int64, int64NDArray);
+  REGISTER_STD_HANDLERS (btyp_uint8,  uint8NDArray);
+  REGISTER_STD_HANDLERS (btyp_uint16, uint16NDArray);
+  REGISTER_STD_HANDLERS (btyp_uint32, uint32NDArray);
+  REGISTER_STD_HANDLERS (btyp_uint64, uint64NDArray);
+
+  // For bools, we register and/or.
+  REGISTER_OP_HANDLER (bsxfun_builtin_and, btyp_bool, boolNDArray, bsxfun_and);
+  REGISTER_OP_HANDLER (bsxfun_builtin_or, btyp_bool, boolNDArray, bsxfun_or);
+}
+
+static octave_value
+maybe_optimized_builtin (const std::string& name,
+                         const octave_value& a, const octave_value& b)
+{
+  octave_value retval;
+
+  maybe_fill_table ();
+
+  bsxfun_builtin_op op = bsxfun_builtin_lookup (name);
+  if (op != bsxfun_builtin_unknown)
+    {
+      builtin_type_t btyp_a = a.builtin_type (), btyp_b = b.builtin_type ();
+
+      // Simplify single/double combinations.
+      if (btyp_a == btyp_float && btyp_b == btyp_double)
+        btyp_b = btyp_float;
+      else if (btyp_a == btyp_double && btyp_b == btyp_float)
+        btyp_a = btyp_float;
+      else if (btyp_a == btyp_float_complex && btyp_b == btyp_complex)
+        btyp_b = btyp_float_complex;
+      else if (btyp_a == btyp_complex && btyp_b == btyp_float_complex)
+        btyp_a = btyp_float_complex;
+
+      if (btyp_a == btyp_b && btyp_a != btyp_unknown)
+        {
+          bsxfun_handler handler = bsxfun_handler_table[op][btyp_a];
+          if (handler)
+            retval = handler (a, b);
+        }
+    }
+
+  return retval;
+}
 
 static bool
 maybe_update_column (octave_value& Ac, const octave_value& A, 
 		     const dim_vector& dva, const dim_vector& dvc,
 		     octave_idx_type i, octave_value_list &idx)
 {
   octave_idx_type nd = dva.length ();
 
@@ -155,22 +303,37 @@ dimensionality as the other matrix.\n\
           std::string name = func.string_value ();
           func = symbol_table::find_function (name);
           if (func.is_undefined ())
             error ("bsxfun: invalid function name: %s", name.c_str ());
         }
       else if (! (args(0).is_function_handle () || args(0).is_inline_function ()))
         error ("bsxfun: first argument must be a string or function handle");
 
-      if (! error_state)
+      const octave_value A = args (1);
+      const octave_value B = args (2);
+
+      if (func.is_builtin_function () 
+          || (func.is_function_handle () 
+              && ! func.fcn_handle_value ()->is_overloaded () 
+              && ! A.is_object () && ! B.is_object ()))
+        {
+          octave_function *fcn_val = func.function_value ();
+          if (fcn_val)
+            {
+              octave_value tmp = maybe_optimized_builtin (fcn_val->name (), A, B);
+              if (tmp.is_defined ())
+                retval(0) = tmp;
+            }
+        }
+
+      if (! error_state && retval.empty ())
 	{
-	  const octave_value A = args (1);
 	  dim_vector dva = A.dims ();
 	  octave_idx_type nda = dva.length ();
-	  const octave_value B = args (2);
 	  dim_vector dvb = B.dims ();
 	  octave_idx_type ndb = dvb.length ();
 	  octave_idx_type nd = nda;
       
 	  if (nda > ndb)
 	      dvb.resize (nda, 1);
 	  else if (nda < ndb)
 	    {
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -66,17 +66,18 @@ enum builtin_type_t
   btyp_int32,
   btyp_int64,
   btyp_uint8,
   btyp_uint16,
   btyp_uint32,
   btyp_uint64,
   btyp_char,
   btyp_bool,
-  btyp_unknown
+  btyp_unknown,
+  btyp_num_types = btyp_unknown
 };
 
 template <class T>
 struct class_to_btyp
 {
   static const builtin_type_t btyp = btyp_unknown;
 };
 
