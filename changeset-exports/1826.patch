# HG changeset patch
# User jwe
# Date 823230447 0
#      Fri Feb 02 03:07:27 1996 +0000
# Node ID b14829582cc44e7e088b14b1b858c140678ee857
# Parent  8219d9b7cb736d0231364e238ca56bb654077b8e
[project @ 1996-02-02 03:05:07 by jwe]

diff --git a/src/lex.h b/src/lex.h
--- a/src/lex.h
+++ b/src/lex.h
@@ -45,19 +45,19 @@ Software Foundation, 59 Temple Place - S
       jump_to_top_level (); \
     } \
   while (0)
 
 #define TOK_RETURN(tok) \
   do \
     { \
       current_input_column += yyleng; \
-      quote_is_transpose = 0; \
-      cant_be_identifier = 0; \
-      convert_spaces_to_comma = 1; \
+      lexer_flags.quote_is_transpose = 0; \
+      lexer_flags.cant_be_identifier = 0; \
+      lexer_flags.convert_spaces_to_comma = 1; \
       return (tok); \
     } \
   while (0)
 
 #define TOK_PUSH_AND_RETURN(name,tok) \
   do \
     { \
       yylval.tok_val = new token (name, input_line_number, \
@@ -68,23 +68,26 @@ Software Foundation, 59 Temple Place - S
   while (0)
 
 #define BIN_OP_RETURN(tok,convert) \
   do \
     { \
       yylval.tok_val = new token (input_line_number, current_input_column); \
       token_stack.push (yylval.tok_val); \
       current_input_column += yyleng; \
-      quote_is_transpose = 0; \
-      cant_be_identifier = 0; \
-      convert_spaces_to_comma = convert; \
+      lexer_flags.quote_is_transpose = 0; \
+      lexer_flags.cant_be_identifier = 0; \
+      lexer_flags.convert_spaces_to_comma = convert; \
       return (tok); \
     } \
   while (0)
 
+// XXX FIXME XXX -- these input buffer things should be members of an
+// parser input stream class.
+
 typedef struct yy_buffer_state *YY_BUFFER_STATE;
 
 // Associate a buffer with a new file to read.
 extern YY_BUFFER_STATE create_buffer (FILE *f);
 
 // Report the current buffer.
 extern YY_BUFFER_STATE current_buffer (void);
 
@@ -96,24 +99,103 @@ extern void delete_buffer (YY_BUFFER_STA
 
 // Restore a buffer (for unwind-prot).
 extern void restore_input_buffer (void *buf);
 
 // Delete a buffer (for unwind-prot).
 extern void delete_input_buffer (void *buf);
 
 // See if a function file has extra garbage after the end statement.
+// This needs to be defined in lex.l so that it can use yyinput() but
+// it must be called from parse.y.
 extern void check_for_garbage_after_fcn_def (void);
 
-// Return transpose or start a string?
-extern int quote_is_transpose;
+// For communication between the lexer and parser.
+
+class lexical_feedback
+{
+public:
+
+  lexical_feedback (void) { init (); }
+
+  ~lexical_feedback (void) { }
+
+  void init (void);
+
+  // Nonzero means we thing we are looking at the beginning of a
+  // function definition.
+  int beginning_of_function;
+
+  // Brace level count.
+  int braceflag;
+
+  // Another context hack, this time for the plot command's `using',
+  // `title', and `with' keywords.
+  int cant_be_identifier;
+
+  // Nonzero means that we should convert spaces to a comma inside a
+  // matrix definition.
+  int convert_spaces_to_comma;
+
+  // Nonzero means we're in the middle of defining a function.
+  int defining_func;
+
+  // GAG.  Stupid kludge so that [[1,2][3,4]] will work.
+  int do_comma_insert;
+
+  // Nonzero means we think we are looking at a set command.
+  int doing_set;
+
+  // Nonzero means we're in the middle of defining a conditional
+  // expression.
+  int iffing;
 
-// Nonzero means we thing we are looking at the beginning of a
-// function definition.
-extern int beginning_of_function;
+  // Nonzero means we're looking at the range part of a plot command.
+  int in_plot_range;
+
+  // Nonzero means we're looking at the using part of a plot command.
+  int in_plot_using;
+
+  // Nonzero means we're looking at the style part of a plot command.
+  int in_plot_style;
+
+  // Nonzero means we're looking at an indirect reference to a
+  // structure element.
+  int looking_at_indirect_ref;
+
+  // Nonzero means we're in the middle of defining a loop.
+  int looping;
+
+  // Nonzero means we need to do some extra lookahead to avoid being
+  // screwed by bogus function syntax.
+  int maybe_screwed;
+
+  // Nonzero means we need to do some extra lookahead to avoid being
+  // screwed by bogus function syntax.
+  int maybe_screwed_again;
+
+  // Nonzero means we've seen something that means we must be past the
+  // range part of a plot command.
+  int past_plot_range;
+
+  // Nonzero means we're working on a plot command.
+  int plotting;
+
+  // Return transpose or start a string?
+  int quote_is_transpose;
+
+private:
+
+  lexical_feedback (const lexical_feedback&);
+
+  lexical_feedback& operator = (const lexical_feedback&);
+};
+
+// Flags that need to be shared between the lexer and parser.
+extern lexical_feedback lexer_flags;
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -19,18 +19,16 @@ along with GNU CC; see the file COPYING.
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 %s TEXT_FCN
 %s MATRIX
 
 %{
-#define SHORT_CIRCUIT_LOGICALS 1
-
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cctype>
 #include <cstring>
 
 #include <string>
@@ -59,61 +57,63 @@ Software Foundation, 59 Temple Place - S
 #include "pt-misc.h"
 #include "pt-plot.h"
 #include "user-prefs.h"
 #include "utils.h"
 #include "variables.h"
 #include "y.tab.h"
 #include "oct-gperf.h"
 
+// Flags that need to be shared between the lexer and parser.
+lexical_feedback lexer_flags;
+
 // Stack to hold tokens so that we can delete them when the parser is
 // reset and avoid growing forever just because we are stashing some
 // information.  This has to appear before lex.h is included, because
 // one of the macros defined there uses token_stack.
 static SLStack <token*> token_stack;
 
-// Nonzero means we think we are looking at a set command.
-static int doing_set = 0;
-
-// GAG.  Stupid kludge so that [[1,2][3,4]] will work.
-static do_comma_insert = 0;
+// Did eat_whitespace() eat a space or tab, or a newline, or both?
 
-// Brace level count.
-static int braceflag = 0;
-
-// Return transpose or start a string?
-int quote_is_transpose = 0;
+typedef int yum_yum;
 
-// Nonzero means we thing we are looking at the beginning of a
-// function definition.
-int beginning_of_function = 0;
-
-// Nonzero means that we should convert spaces to a comma inside a
-// matrix definition.
-static int convert_spaces_to_comma = 1;
-
-// Another context hack, this time for the plot command's `using',
-// `title', and `with' keywords.
-static int cant_be_identifier = 0;
-
-#define BRACE 1
-#define PAREN 2
-
-// Did eat_whitespace() eat a space or tab, or a newline, or both?
-#define ATE_SPACE_OR_TAB 1
-#define ATE_NEWLINE 2
+const yum_yum ATE_NOTHING = 0;
+const yum_yum ATE_SPACE_OR_TAB = 1;
+const yum_yum ATE_NEWLINE = 2;
 
 // Is the closest nesting level a square brace or a paren?
-//
-//  BRACE -> spaces are important (they can turn into commas)
-//           new lines are important (they can turn into semicolons)
-//
-//  PAREN -> spaces and new lines are not important
+
+class brace_paren_nesting_level : public SLStack <int>
+{
+public:
+
+  brace_paren_nesting_level (void) : SLStack<int> () { }
+
+  ~brace_paren_nesting_level (void) { }
+
+  void brace (void) { push (BRACE); }
+  bool is_brace (void) { return ! empty () && top () == BRACE; }
+
+  void paren (void) { push (PAREN); }
+  bool is_paren (void) { return ! empty () && top () == PAREN; }
 
-static SLStack <int> nesting_level;
+  bool none (void) { return empty (); }
+
+  void remove (void) { if (! empty ()) SLStack<int>::pop (); }
+
+private:
+
+  enum { BRACE = 1, PAREN = 2 };
+
+  brace_paren_nesting_level (const brace_paren_nesting_level&);
+
+  brace_paren_nesting_level& operator = (const brace_paren_nesting_level&);
+};
+
+static brace_paren_nesting_level nesting_level;
 
 // Forward declarations for functions defined at the bottom of this
 // file.
 
 static void do_string_escapes (char *s);
 static void fixup_column_count (char *s);
 static void do_comma_insert_check (void);
 static int is_plot_keyword (const string& s);
@@ -126,18 +126,18 @@ static int next_token_is_bin_op (int spc
 static int next_token_is_postfix_unary_op (int spc_prev, char *yytext);
 static string strip_trailing_whitespace (char *s);
 static void handle_number (char *yytext);
 static int handle_string (char delim, int text_style = 0);
 static int handle_close_brace (int spc_gobbled);
 static int handle_identifier (const string& tok, int spc_gobbled);
 static int have_continuation (int trailing_comments_ok = 1);
 static int have_ellipsis_continuation (int trailing_comments_ok = 1);
-static int eat_whitespace (void);
-static int eat_continuation (void);
+static yum_yum eat_whitespace (void);
+static yum_yum eat_continuation (void);
 
 %}
 
 D	[0-9]
 S	[ \t]
 NL	[\n]
 SNL	[ \t\n]
 EL	(\.\.\.)
@@ -160,24 +160,24 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 // Help and other text-style functions are a pain in the ass.  This
 // stuff needs to be simplified.  May require some changes in the
 // parser too.
 %}
 
 <TEXT_FCN>{NL} {
     BEGIN 0;
     current_input_column = 1;
-    quote_is_transpose = 0;
-    cant_be_identifier = 0;
-    convert_spaces_to_comma = 1;
+    lexer_flags.quote_is_transpose = 0;
+    lexer_flags.cant_be_identifier = 0;
+    lexer_flags.convert_spaces_to_comma = 1;
     return '\n';
   }
 
 <TEXT_FCN>[\;\,] {
-    if (doing_set && strcmp (yytext, ",") == 0)
+    if (lexer_flags.doing_set && strcmp (yytext, ",") == 0)
       {
 	TOK_PUSH_AND_RETURN (yytext, TEXT);
       }
     else
       {
 	BEGIN 0;
 	if (strcmp (yytext, ",") == 0)
 	  TOK_RETURN (',');
@@ -220,19 +220,19 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 // Commas are element separators in matrix constants.  If we don't
 // check for continuations here we can end up inserting too many
 // commas.
 %}
 
 <MATRIX>{S}*\,{S}* {
     current_input_column += yyleng;
     int tmp = eat_continuation ();
-    quote_is_transpose = 0;
-    cant_be_identifier = 0;
-    convert_spaces_to_comma = 1;
+    lexer_flags.quote_is_transpose = 0;
+    lexer_flags.cant_be_identifier = 0;
+    lexer_flags.convert_spaces_to_comma = 1;
     if (user_pref.whitespace_in_literal_matrix != 2
 	&& (tmp & ATE_NEWLINE) == ATE_NEWLINE)
       unput (';');
     return (',');
   }
 
 %{
 // In some cases, spaces in matrix constants can turn into commas.
@@ -244,106 +244,105 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 <MATRIX>{S}+ {
     current_input_column += yyleng;
     if (user_pref.whitespace_in_literal_matrix != 2)
       {
 	int tmp = eat_continuation ();
 	int bin_op = next_token_is_bin_op (1, yytext);
 	int postfix_un_op = next_token_is_postfix_unary_op (1, yytext);
 
-	if (! (postfix_un_op || bin_op || nesting_level.empty ())
-	    && nesting_level.top () == BRACE
-	    && convert_spaces_to_comma)
+	if (! (postfix_un_op || bin_op)
+	    && nesting_level.is_brace ()
+	    && lexer_flags.convert_spaces_to_comma)
 	  {
-	    quote_is_transpose = 0;
-	    cant_be_identifier = 0;
-	    convert_spaces_to_comma = 1;
+	    lexer_flags.quote_is_transpose = 0;
+	    lexer_flags.cant_be_identifier = 0;
+	    lexer_flags.convert_spaces_to_comma = 1;
 	    if ((tmp & ATE_NEWLINE) == ATE_NEWLINE)
 	      unput (';');
 	    return (',');
 	  }
       }
   }
 
 %{
 // Semicolons are handled as row seprators in matrix constants.  If we
 // don't eat whitespace here we can end up inserting too many
 // semicolons.
 %}
 
 <MATRIX>{SNLCMT}*;{SNLCMT}* {
     fixup_column_count (yytext);
     eat_whitespace ();
-    quote_is_transpose = 0;
-    cant_be_identifier = 0;
-    convert_spaces_to_comma = 1;
+    lexer_flags.quote_is_transpose = 0;
+    lexer_flags.cant_be_identifier = 0;
+    lexer_flags.convert_spaces_to_comma = 1;
     return ';';
   }
 
 %{
 // In some cases, new lines can also become row separators.  If we
 // don't eat whitespace here we can end up inserting too many
 // semicolons.
 %}
 
 <MATRIX>{SNLCMT}*\n{SNLCMT}* {
     fixup_column_count (yytext);
     eat_whitespace ();
     if (user_pref.whitespace_in_literal_matrix != 2)
       {
-	quote_is_transpose = 0;
-	cant_be_identifier = 0;
-	convert_spaces_to_comma = 1;
+	lexer_flags.quote_is_transpose = 0;
+	lexer_flags.cant_be_identifier = 0;
+	lexer_flags.convert_spaces_to_comma = 1;
 
-	if (nesting_level.empty ())
+	if (nesting_level.none ())
 	  return LEXICAL_ERROR;
 
-	if (nesting_level.top () == BRACE)
+	if (nesting_level.is_brace ())
 	  return ';';
       }
   }
 
 %{
 // Open and close brace are handled differently if we are in the range
 // part of a plot command.
 //
 %}
 
 \[{S}* {
-    nesting_level.push (BRACE);
+    nesting_level.brace ();
 
     current_input_column += yyleng;
-    quote_is_transpose = 0;
-    cant_be_identifier = 0;
-    convert_spaces_to_comma = 1;
+    lexer_flags.quote_is_transpose = 0;
+    lexer_flags.cant_be_identifier = 0;
+    lexer_flags.convert_spaces_to_comma = 1;
 
     promptflag--;
     eat_whitespace ();
 
-    if (plotting && ! past_plot_range)
+    if (lexer_flags.plotting && ! lexer_flags.past_plot_range)
       {
-	in_plot_range = 1;
+	lexer_flags.in_plot_range = 1;
 	return OPEN_BRACE;
       }
     else
       {
 	mlnm.push (1);
-	braceflag++;
+	lexer_flags.braceflag++;
 	BEGIN MATRIX;
 	return '[';
       }
   }
 
 \] {
-    if (! nesting_level.empty ())
-      nesting_level.pop ();
+    nesting_level.remove ();
 
-    if (plotting && ! past_plot_range)
+    if (lexer_flags.plotting && ! lexer_flags.past_plot_range)
       {
-	in_plot_range = 0;
+	lexer_flags.in_plot_range = 0;
 	TOK_RETURN (CLOSE_BRACE);
       }
     else
       TOK_RETURN (']');
   }
 
 %{
 // Imaginary numbers.
@@ -416,38 +415,38 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 
 %{
 // A new line character.  New line characters inside matrix constants
 // are handled by the <MATRIX> start state code above.  If closest
 // nesting is inside parentheses, don't return a row separator.
 %}
 
 {NL} {
-    quote_is_transpose = 0;
-    cant_be_identifier = 0;
     current_input_column = 1;
-    convert_spaces_to_comma = 1;
+    lexer_flags.quote_is_transpose = 0;
+    lexer_flags.cant_be_identifier = 0;
+    lexer_flags.convert_spaces_to_comma = 1;
 
-    if (nesting_level.empty ())
+    if (nesting_level.none ())
       return '\n';
 
-    if (nesting_level.top () == BRACE)
+    if (nesting_level.is_brace ())
       return LEXICAL_ERROR;
   }
 
 %{
 // Single quote can either be the beginning of a string or a transpose
 // operator. 
 %}
 
 "'" {
     current_input_column++;
-    convert_spaces_to_comma = 1;
+    lexer_flags.convert_spaces_to_comma = 1;
 
-    if (quote_is_transpose)
+    if (lexer_flags.quote_is_transpose)
       {
 	do_comma_insert_check ();
 	return QUOTE;
       }
     else
       return handle_string ('\'');
   }
 
@@ -461,48 +460,51 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 }
 
 %{
 // The colon operator is handled differently if we are in the range
 // part of a plot command.
 %}
 
 ":" {
-    if (plotting && (in_plot_range || in_plot_using))
+    if (lexer_flags.plotting
+	&& (lexer_flags.in_plot_range || lexer_flags.in_plot_using))
       BIN_OP_RETURN (COLON, 1);
     else
       BIN_OP_RETURN (':', 0);
   }
 
 %{
 // Gobble comments.  If closest nesting is inside parentheses, don't
 // return a new line.
 %} 
 
 {CCHAR} {
-    if (help_buf.empty () && beginning_of_function && nesting_level.empty ())
+    if (help_buf.empty ()
+	&& lexer_flags.beginning_of_function
+	&& nesting_level.none ())
       {
 	grab_help_text ();
-	beginning_of_function = 0;
+	lexer_flags.beginning_of_function = 0;
       }
     else
       {
 	int c;
 	while ((c = yyinput ()) != EOF && c != '\n')
 	  ; // Eat comment.
       }
 
-    quote_is_transpose = 0;
-    cant_be_identifier = 0;
     current_input_column = 1;
-    convert_spaces_to_comma = 1;
+    lexer_flags.quote_is_transpose = 0;
+    lexer_flags.cant_be_identifier = 0;
+    lexer_flags.convert_spaces_to_comma = 1;
 
-    if (nesting_level.empty ())
+    if (nesting_level.none ())
       return '\n';
-    else if (nesting_level.top () == BRACE)
+    else if (nesting_level.is_brace ())
       return ';';
   }
 
 %{
 // Other operators.
 %}
 
 ".+"		{ BIN_OP_RETURN (EPLUS, 0); }
@@ -524,68 +526,52 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 ">"		{ BIN_OP_RETURN (EXPR_GT, 0); }
 "*"		{ BIN_OP_RETURN ('*', 0); }
 "/"		{ BIN_OP_RETURN ('/', 0); }
 "\\"		{ BIN_OP_RETURN (LEFTDIV, 0); }
 ";"		{ BIN_OP_RETURN (';', 1); }
 ","		{ BIN_OP_RETURN (',', 1); }
 {POW}		{ BIN_OP_RETURN (POW, 0); }
 "="		{ BIN_OP_RETURN ('=', 1); }
-
-"||" {
-#ifdef SHORT_CIRCUIT_LOGICALS
-    BIN_OP_RETURN (EXPR_OR_OR, 0);
-#else
-    BIN_OP_RETURN (EXPR_OR, 0);
-#endif
-  }
-
-"&&" {
-#ifdef SHORT_CIRCUIT_LOGICALS
-    BIN_OP_RETURN (EXPR_AND_AND, 0);
-#else
-    BIN_OP_RETURN (EXPR_AND, 0);
-#endif
-  }
+"||"		{ BIN_OP_RETURN (EXPR_OR_OR, 0); }
+"&&"		{ BIN_OP_RETURN (EXPR_AND_AND, 0); }
 
 {NOT} {
-    if (plotting && ! in_plot_range)
-      past_plot_range = 1;
+    if (lexer_flags.plotting && ! lexer_flags.in_plot_range)
+      lexer_flags.past_plot_range = 1;
     BIN_OP_RETURN (EXPR_NOT, 0);
   }
 
 "+" { 
-    if (plotting && ! in_plot_range)
-      past_plot_range = 1;
+    if (lexer_flags.plotting && ! lexer_flags.in_plot_range)
+      lexer_flags.past_plot_range = 1;
     BIN_OP_RETURN ('+', 0);
   }
 
 "-" { 
-    if (plotting && ! in_plot_range)
-      past_plot_range = 1;
+    if (lexer_flags.plotting && ! lexer_flags.in_plot_range)
+      lexer_flags.past_plot_range = 1;
     BIN_OP_RETURN ('-', 0);
   }
 
 "(" {
-    if (plotting && ! in_plot_range)
-      past_plot_range = 1;
-    nesting_level.push (PAREN);
+    if (lexer_flags.plotting && ! lexer_flags.in_plot_range)
+      lexer_flags.past_plot_range = 1;
+    nesting_level.paren ();
     promptflag--;
     TOK_RETURN ('(');
   }
 
 ")" {
-    if (! nesting_level.empty ())
-      nesting_level.pop ();
+    nesting_level.remove ();
 
     current_input_column++;
-    cant_be_identifier = 1;
-    quote_is_transpose = 1;
-    convert_spaces_to_comma = (! nesting_level.empty ()
-			       && nesting_level.top () == BRACE);
+    lexer_flags.cant_be_identifier = 1;
+    lexer_flags.quote_is_transpose = 1;
+    lexer_flags.convert_spaces_to_comma = nesting_level.is_brace ();
     do_comma_insert_check ();
     return ')';
   }
 
 %{
 // We return everything else as single character tokens, which should
 // eventually result in a parse error.
 %}
@@ -602,95 +588,62 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 void
 do_comma_insert_check (void)
 {
   int spc_gobbled = eat_continuation ();
   int c = yyinput ();
   yyunput (c, yytext);
   if (spc_gobbled)
     yyunput (' ', yytext);
-  do_comma_insert = (braceflag && c == '[');
+  lexer_flags.do_comma_insert = (lexer_flags.braceflag && c == '[');
 }
 
 // Fix things up for errors or interrupts.  The parser is never called
 // recursively, so it is always safe to reinitialize its state before
 // doing any parsing.
 
 void
 reset_parser (void)
 {
-// Start off on the right foot.
+  // Start off on the right foot.
   BEGIN 0;
   error_state = 0;
 
-// We do want a prompt by default.
+  // We do want a prompt by default.
   promptflag = 1;
 
-// Not initially screwed by `function [...] = f (...)' syntax.
-  maybe_screwed = 0;
-  maybe_screwed_again = 0;
-
-// Not initially inside a loop or if statement.
-  looping = 0;
-  iffing = 0;
-
-// Quote marks strings intially.
-  quote_is_transpose = 0;
-
-// Next token can be identifier.
-  cant_be_identifier = 0;
-
-// No need to do comma insert or convert spaces to comma at beginning
-// of input. 
-  do_comma_insert = 0;
-  convert_spaces_to_comma = 1;
-
-// Not initially defining a function.
-  beginning_of_function = 0;
-  defining_func = 0;
-
-// Not initially doing any plotting or setting of plot attributes.
-  plotting = 0;
-  in_plot_range = 0;
-  past_plot_range = 0;
-  in_plot_using = 0;
-  in_plot_style = 0;
-  doing_set = 0;
-
-// Not initially looking at indirect references.
-  looking_at_indirect_ref = 0;
-
-// Error may have occurred inside some parentheses or braces.
+  // Error may have occurred inside some parentheses or braces.
   nesting_level.clear ();
 
-// Not initially defining a matrix list.
-  braceflag = 0;
+  // Not initially defining a matrix list.
   ml.clear ();
   mlnm.clear ();
 
-// Clear out the stack of token info used to track line and column
-// numbers.
+  // Clear out the stack of token info used to track line and column
+  // numbers.
   while (! token_stack.empty ())
     delete token_stack.pop ();
 
-// Can be reset by defining a function.
+  // Can be reset by defining a function.
   if (! (reading_script_file || reading_fcn_file))
     {
       current_input_column = 1;
       input_line_number = current_command_number - 1;
     }
 
-// Only ask for input from stdin if we are expecting interactive
-// input.
+  // Only ask for input from stdin if we are expecting interactive
+  // input.
   if (interactive && ! (reading_fcn_file || get_input_from_eval_string))
     yyrestart (stdin);
 
-// Clear the buffer for help text.
+  // Clear the buffer for help text.
+  help_buf.resize (0);
 
-  help_buf.resize (0);
+  // Reset other flags.
+  lexer_flags.init ();
 }
 
 // Replace backslash escapes in a string with the real values.
 
 static void
 do_string_escapes (char *s)
 {
   char *p1 = s;
@@ -782,39 +735,16 @@ fixup_column_count (char *s)
 #undef yywrap
 #endif
 static int
 yywrap (void)
 {
   return 1;
 }
 
-// These are not needed with flex-2.4.6, but may be needed with
-// earlier 2.4.x versions.
-
-#if 0
-static void *
-yy_flex_alloc (int size)
-{
-  return (void *) malloc ((unsigned) size);
-}
-
-static void *
-yy_flex_realloc (void *ptr, int size)
-{
-  return (void *) realloc (ptr, (unsigned) size);
-}
-
-static void
-yy_flex_free (void *ptr)
-{
-  free (ptr);
-}
-#endif
-
 // Tell us all what the current buffer is.
 
 YY_BUFFER_STATE
 current_buffer (void)
 {
   return YY_CURRENT_BUFFER;
 }
 
@@ -905,22 +835,22 @@ is_plot_keyword (const string& s)
 {
   const char *t = s.c_str ();
   if (almost_match ("title", t))
     {
       return TITLE;
     }
   else if (almost_match ("using", t))
     {
-      in_plot_using = 1;
+      lexer_flags.in_plot_using = 1;
       return USING;
     }
   else if (almost_match ("with", t))
     {
-      in_plot_style = 1;
+      lexer_flags.in_plot_style = 1;
       return WITH;
     }
   else if (strcmp ("clear", t) == 0)
     {
       return CLEAR;
     }
   else
     {
@@ -928,23 +858,23 @@ is_plot_keyword (const string& s)
     }
 }
 
 // Handle keywords.  Could probably be more efficient...
 
 static int
 is_keyword (const string& s)
 {
-  if (plotting && in_plot_style)
+  if (lexer_flags.plotting && lexer_flags.in_plot_style)
     {
       string sty = plot_style_token (s);
 
       if (! sty.empty ())
 	{
-	  in_plot_style = 0;
+	  lexer_flags.in_plot_style = 0;
 	  yylval.tok_val = new token (sty);
 	  token_stack.push (yylval.tok_val);
 	  return STYLE;
 	}
     }
 
   int l = input_line_number;
   int c = current_input_column;
@@ -996,46 +926,46 @@ is_keyword (const string& s)
 
 	case endwhile_kw:
 	  yylval.tok_val = new token (token::while_end, l, c);
 	  break;
 
 	case for_kw:
 	case while_kw:
 	  promptflag--;
-	  looping++;
+	  lexer_flags.looping++;
 	  break;
 
 	case if_kw:
-	  iffing++;
 	  promptflag--;
+	  lexer_flags.iffing++;
 	  break;
 
 	case try_kw:
 	case unwind_protect_kw:
 	  promptflag--;
 	  break;
 
 	case gplot_kw:
-	  plotting = 1;
+	  lexer_flags.plotting = 1;
 	  yylval.tok_val = new token (token::two_dee, l, c);
 	  break;
 
 	case gsplot_kw:
-	  plotting = 1;
+	  lexer_flags.plotting = 1;
 	  yylval.tok_val = new token (token::three_dee, l, c);
 	  break;
 
 	case replot_kw:
-	  plotting = 1;
+	  lexer_flags.plotting = 1;
 	  yylval.tok_val = new token (token::replot, l, c);
 	  break;
 
 	case function_kw:
-	  if (defining_func)
+	  if (lexer_flags.defining_func)
 	    {
 	      error ("function keyword invalid within a function body");
 
 	      if ((reading_fcn_file || reading_script_file)
 		  && ! curr_fcn_file_name.empty ())
 		error ("defining new function near line %d of file `%s.m'",
 		       input_line_number, curr_fcn_file_name.c_str ());
 	      else
@@ -1043,19 +973,19 @@ is_keyword (const string& s)
 		       input_line_number);
 
 	      return LEXICAL_ERROR;
 	    }
 	  else
 	    {
 	      tmp_local_sym_tab = new symbol_table ();
 	      curr_sym_tab = tmp_local_sym_tab;
-	      defining_func = 1;
+	      lexer_flags.defining_func = 1;
 	      promptflag--;
-	      beginning_of_function = 1;
+	      lexer_flags.beginning_of_function = 1;
 	      if (! (reading_fcn_file || reading_script_file))
 		input_line_number = 1;
 	    }
 	  break;
 
 	default:
 	  panic_impossible ();
 	}
@@ -1147,27 +1077,16 @@ match_any (char c, char *s)
 //   [ 1 + 2 ]  or  [ 1+ 2]  or  [ 1+2 ]  ==> binary
 
 static int
 looks_like_bin_op (int spc_prev, int spc_next)
 {
   return ((spc_prev && spc_next) || ! spc_prev);
 }
 
-// Duh.  This seems to no longer be needed.
-#if 0
-static int
-next_char_is_space (void)
-{
-  int c = yyinput ();
-  yyunput (c, yytext);
-  return (c == ' ' || c == '\t');
-}
-#endif
-
 // Try to determine if the next token should be treated as a postfix
 // unary operator.  This is ugly, but it seems to do the right thing.
 
 static int
 next_token_is_postfix_unary_op (int spc_prev, char *yytext)
 {
   int un_op = 0;
 
@@ -1271,23 +1190,24 @@ strip_trailing_whitespace (char *s)
 
   return retval;
 }
 
 // Discard whitespace, including comments and continuations.
 //
 // Return value is logical OR of the following values:
 //
+//  ATE_NOTHING      : no spaces to eat
 //  ATE_SPACE_OR_TAB : space or tab in input
 //  ATE_NEWLINE      : bare new line in input
 
-static int
+static yum_yum
 eat_whitespace (void)
 {
-  int retval = 0;
+  yum_yum retval = ATE_NOTHING;
   int in_comment = 0;
   int c;
   while ((c = yyinput ()) != EOF)
     {
       current_input_column++;
 
       switch (c)
 	{
@@ -1344,26 +1264,26 @@ eat_whitespace (void)
 }
 
 static void
 handle_number (char *yytext)
 {
   double value;
   int nread = sscanf (yytext, "%lf", &value);
 
-// If yytext doesn't contain a valid number, we are in deep doo doo.
+  // If yytext doesn't contain a valid number, we are in deep doo doo.
 
   assert (nread == 1);
 
-  quote_is_transpose = 1;
-  cant_be_identifier = 1;
-  convert_spaces_to_comma = 1;
+  lexer_flags.quote_is_transpose = 1;
+  lexer_flags.cant_be_identifier = 1;
+  lexer_flags.convert_spaces_to_comma = 1;
 
-  if (plotting && ! in_plot_range)
-    past_plot_range = 1;
+  if (lexer_flags.plotting && ! lexer_flags.in_plot_range)
+    lexer_flags.past_plot_range = 1;
 
   yylval.tok_val = new token (value, yytext, input_line_number,
 			      current_input_column);
 
   token_stack.push (yylval.tok_val);
 
   current_input_column += yyleng;
 
@@ -1457,20 +1377,20 @@ have_ellipsis_continuation (int trailing
   return 0;
 }
 
 // See if we have a continuation line.  If so, eat it and the leading
 // whitespace on the next line.
 //
 // Return value is the same as described for eat_whitespace().
 
-static int
+static yum_yum
 eat_continuation (void)
 {
-  int retval = 0;
+  int retval = ATE_NOTHING;
   int c = yyinput ();
   if ((c == '.' && have_ellipsis_continuation ())
       || (c == '\\' && have_continuation ()))
     retval = eat_whitespace ();
   else
     yyunput (c, yytext);
 
   return retval;
@@ -1528,35 +1448,35 @@ handle_string (char delim, int text_styl
 		buf << (char) c;
 	      else
 		{
 		  yyunput (c, yytext);
 		  buf << ends;
 		  char *tok = buf.str ();
 		  do_string_escapes (tok);
 
-		  if (text_style && doing_set)
+		  if (text_style && lexer_flags.doing_set)
 		    {
 		      if (tok)
 			{
 			  int len = strlen (tok) + 3;
 			  char *tmp = tok;
 			  tok = new char [len];
 			  tok[0] = delim;
 			  strcpy (tok+1, tmp);
 			  tok[len-2] = delim;
 			  tok[len-1] = '\0';
 			  delete [] tmp;
 			}
 		    }
 		  else
 		    {
-		      quote_is_transpose = 1;
-		      cant_be_identifier = 1;
-		      convert_spaces_to_comma = 1;
+		      lexer_flags.quote_is_transpose = 1;
+		      lexer_flags.cant_be_identifier = 1;
+		      lexer_flags.convert_spaces_to_comma = 1;
 		    }
 
 		  yylval.tok_val = new token (tok);
 		  delete [] tok;
 		  token_stack.push (yylval.tok_val);
 		  return TEXT;
 		}
 	    }
@@ -1570,76 +1490,74 @@ handle_string (char delim, int text_styl
     }
 
   return LEXICAL_ERROR;
 }
 
 static int
 handle_close_brace (int spc_gobbled)
 {
-  if (! nesting_level.empty ())
+  if (! nesting_level.none ())
     {
-      nesting_level.pop ();
-      braceflag--;
+      nesting_level.remove ();
+      lexer_flags.braceflag--;
     }
 
-  if (braceflag == 0)
+  if (lexer_flags.braceflag == 0)
     BEGIN 0;
 
   int c1 = yyinput ();
   if (c1 == '=')
     {
-      quote_is_transpose = 0;
-      cant_be_identifier = 0;
-      convert_spaces_to_comma = 1;
+      lexer_flags.quote_is_transpose = 0;
+      lexer_flags.cant_be_identifier = 0;
+      lexer_flags.convert_spaces_to_comma = 1;
 
       int c2 = yyinput ();
       unput (c2);
       unput (c1);
 
-      if (c2 != '=' && maybe_screwed_again)
+      if (c2 != '=' && lexer_flags.maybe_screwed_again)
 	return SCREW_TWO;
       else
 	return ']';
     }
   else
     {
       unput (c1);
 
-      if (braceflag && user_pref.whitespace_in_literal_matrix != 2)
+      if (lexer_flags.braceflag && user_pref.whitespace_in_literal_matrix != 2)
 	{
 	  int bin_op = next_token_is_bin_op (spc_gobbled, yytext);
 	  int postfix_un_op = next_token_is_postfix_unary_op
 	    (spc_gobbled, yytext);
 
 	  int other_op = match_any (c1, ",;\n]");
 
-	  if (! (postfix_un_op || bin_op || other_op
-		 || nesting_level.empty ())
-	      && nesting_level.top () == BRACE
-	      && convert_spaces_to_comma)
+	  if (! (postfix_un_op || bin_op || other_op)
+	      && nesting_level.is_brace ()
+	      && lexer_flags.convert_spaces_to_comma)
 	    {
 	      unput (',');
 	      return ']';
 	    }
 	}
     }
 
-  quote_is_transpose = 1;
-  cant_be_identifier = 0;
-  convert_spaces_to_comma = 1;
+  lexer_flags.quote_is_transpose = 1;
+  lexer_flags.cant_be_identifier = 0;
+  lexer_flags.convert_spaces_to_comma = 1;
   return ']';
 }
 
 static void
 maybe_unput_comma (int spc_gobbled)
 {
   if (user_pref.whitespace_in_literal_matrix != 2
-      && ! nesting_level.empty ()
-      && nesting_level.top () == BRACE) 
+      && nesting_level.is_brace ())
     {
       int bin_op = next_token_is_bin_op (spc_gobbled, yytext);
 
       int postfix_un_op = next_token_is_postfix_unary_op (spc_gobbled,
 							  yytext);
 
       int c1 = yyinput ();
       int c2 = yyinput ();
@@ -1658,148 +1576,151 @@ maybe_unput_comma (int spc_gobbled)
 }
 
 // Figure out exactly what kind of token to return when we have seen
 // an identifier.  Handles keywords.
 
 static int
 handle_identifier (const string& tok, int spc_gobbled)
 {
-// It is almost always an error for an identifier to be followed
-// directly by another identifier.  Special cases are handled below.
+  // It is almost always an error for an identifier to be followed
+  // directly by another identifier.  Special cases are handled
+  // below.
 
-  cant_be_identifier = 1;
+  lexer_flags.cant_be_identifier = 1;
 
-// If we are expecting a structure element, we just want to return
-// TEXT_ID, which is a string that is also a valid identifier.  But
-// first, we have to decide whether to insert a comma.
+  // If we are expecting a structure element, we just want to return
+  // TEXT_ID, which is a string that is also a valid identifier.  But
+  // first, we have to decide whether to insert a comma.
 
-  if (looking_at_indirect_ref)
+  if (lexer_flags.looking_at_indirect_ref)
     {
       maybe_unput_comma (spc_gobbled);
       TOK_PUSH_AND_RETURN (tok, TEXT_ID);
     }
 
-// If we have a regular keyword, or a plot STYLE, return it.  Keywords
-// can be followed by identifiers (TOK_RETURN handles that).
+  // If we have a regular keyword, or a plot STYLE, return it.
+  // Keywords can be followed by identifiers (TOK_RETURN handles
+  // that).
 
   int kw_token = is_keyword (tok);
   if (kw_token)
     {
       if (kw_token == STYLE)
 	{
 	  current_input_column += yyleng;
-	  quote_is_transpose = 0;
-	  convert_spaces_to_comma = 1;
+	  lexer_flags.quote_is_transpose = 0;
+	  lexer_flags.convert_spaces_to_comma = 1;
 	  return kw_token;
 	}
       else
 	TOK_RETURN (kw_token);
     }
 
-// See if we have a plot keyword (title, using, with, or clear).
+  // See if we have a plot keyword (title, using, with, or clear).
 
-  if (plotting)
+  if (lexer_flags.plotting)
     {
-// Yes, we really do need both of these plot_range variables.  One
-// is used to mark when we are past all possiblity of a plot range,
-// the other is used to mark when we are actually between the square
-// brackets that surround the range.
+      // Yes, we really do need both of these plot_range variables.
+      // One is used to mark when we are past all possiblity of a plot
+      // range, the other is used to mark when we are actually between
+      // the square brackets that surround the range.
 
-      if (! in_plot_range)
-	past_plot_range = 1;
+      if (! lexer_flags.in_plot_range)
+	lexer_flags.past_plot_range = 1;
 
       // Option keywords can't appear in parentheses or braces.
 
       int plot_option_kw = 0;
-      if (nesting_level.empty ())
+      if (nesting_level.none ())
 	plot_option_kw = is_plot_keyword (tok);
 
-      if (cant_be_identifier && plot_option_kw)
+      if (lexer_flags.cant_be_identifier && plot_option_kw)
 	TOK_RETURN (plot_option_kw);
     }
 
-// If we are looking at a text style function, set up to gobble its
-// arguments.  These are also reserved words, but only because it
-// would be very difficult to do anything intelligent with them if
-// they were not reserved.
+  // If we are looking at a text style function, set up to gobble its
+  // arguments.  These are also reserved words, but only because it
+  // would be very difficult to do anything intelligent with them if
+  // they were not reserved.
 
   if (is_text_function_name (tok))
     {
       BEGIN TEXT_FCN;
 
       if (tok == "set")
-	doing_set = 1;
+	lexer_flags.doing_set = 1;
     }
 
   int c = yyinput ();
   yyunput (c, yytext);
   int next_tok_is_eq = (c == '=');
 
-// Make sure we put the return values of a function in the symbol
-// table that is local to the function.
+  // Make sure we put the return values of a function in the symbol
+  // table that is local to the function.
 
-  if (next_tok_is_eq && defining_func && maybe_screwed)
+  if (next_tok_is_eq
+      && lexer_flags.defining_func && lexer_flags.maybe_screwed)
     curr_sym_tab = tmp_local_sym_tab;
 
-// Find the token in the symbol table.
+  // Find the token in the symbol table.
 
   yylval.tok_val = new token (lookup_identifier (tok),
 			      input_line_number,
 			      current_input_column);
 
   token_stack.push (yylval.tok_val);
 
-// After seeing an identifer, it is ok to convert spaces to a comma
-// (if needed).
+  // After seeing an identifer, it is ok to convert spaces to a comma
+  // (if needed).
 
-  convert_spaces_to_comma = 1;
+  lexer_flags.convert_spaces_to_comma = 1;
 
-// If we are defining a function and we have not seen the parameter
-// list yet and the next token is `=', return a token that represents
-// the only return value for the function.  For example,
-//
-//   function SCREW = f (args);
-//
-// The variable maybe_screwed is reset in parse.y.
+  // If we are defining a function and we have not seen the parameter
+  // list yet and the next token is `=', return a token that
+  // represents the only return value for the function.  For example,
+  //
+  //   function SCREW = f (args);
+  //
+  // The variable maybe_screwed is reset in parse.y.
 
   if (next_tok_is_eq)
     {
       current_input_column += yyleng;
-      if (defining_func && maybe_screwed)
+      if (lexer_flags.defining_func && lexer_flags.maybe_screwed)
 	return SCREW;
       else
 	return NAME;
     }
 
-// At this point, we are only dealing with identifiers that are not
-// followed by `=' (if the next token is `=', there is no need to
-// check to see if we should insert a comma (invalid syntax), or allow
-// a following `'' to be treated as a transpose (the next token is
-// `=', so it can't be `''.
+  // At this point, we are only dealing with identifiers that are not
+  // followed by `=' (if the next token is `=', there is no need to
+  // check to see if we should insert a comma (invalid syntax), or
+  // allow a following `'' to be treated as a transpose (the next
+  // token is `=', so it can't be `''.
 
-  quote_is_transpose = 1;
+  lexer_flags.quote_is_transpose = 1;
   do_comma_insert_check ();
 
   maybe_unput_comma (spc_gobbled);
 
   current_input_column += yyleng;
   return NAME;
 }
 
 // Print a warning if a function file that defines a function has
 // anything other than comments and whitespace following the END token
 // that matches the FUNCTION statement.
 
 void
 check_for_garbage_after_fcn_def (void)
 {
-// By making a newline be the next character to be read, we will force
-// the parser to return after reading the function.  Calling yyunput
-// with EOF seems not to work...
+  // By making a newline be the next character to be read, we will
+  // force the parser to return after reading the function.  Calling
+  // yyunput with EOF seems not to work...
 
   int in_comment = 0;
   int lineno = input_line_number;
   int c;
   while ((c = yyinput ()) != EOF)
     {
       switch (c)
 	{
@@ -1830,24 +1751,61 @@ check_for_garbage_after_fcn_def (void)
 	      yyunput ('\n', yytext);
 	      return;
 	    }
 	}
     }
   yyunput ('\n', yytext);
 }
 
-/*
+void
+lexical_feedback::init (void)
+{
+  // Not initially defining a function.
+  beginning_of_function = 0;
+  defining_func = 0;
+
+  // Not initially defining a matrix list.
+  braceflag = 0;
+
+  // Next token can be identifier.
+  cant_be_identifier = 0;
 
-Maybe someday...
+  // No need to do comma insert or convert spaces to comma at
+  // beginning of input. 
+  convert_spaces_to_comma = 1;
+  do_comma_insert = 0;
+
+  // Not initially doing any plotting or setting of plot attributes.
+  doing_set = 0;
+  in_plot_range = 0;
+  in_plot_style = 0;
+  in_plot_using = 0;
+  past_plot_range = 0;
+  plotting = 0;
 
-"+="		return ADD_EQ;
-"-="		return SUB_EQ;
-"*="		return MUL_EQ;
-"/="		return DIV_EQ;
-"\\="		return LEFTDIV_EQ;
-".+="		return ADD_EQ;
-".-="		return SUB_EQ;
-".*="		return EMUL_EQ;
-"./="		return EDIV_EQ;
-".\\="		return ELEFTDIV_EQ;
+  // Not initially inside a loop or if statement.
+  iffing = 0;
+  looping = 0;
+
+  // Not initially looking at indirect references.
+  looking_at_indirect_ref = 0;
+
+  // Not initially screwed by `function [...] = f (...)' syntax.
+  maybe_screwed = 0;
+  maybe_screwed_again = 0;
 
-*/
+  // Quote marks strings intially.
+  quote_is_transpose = 0;
+}
+
+// Maybe someday...
+//
+// "+="		return ADD_EQ;
+// "-="		return SUB_EQ;
+// "*="		return MUL_EQ;
+// "/="		return DIV_EQ;
+// "\\="	return LEFTDIV_EQ;
+// ".+="	return ADD_EQ;
+// ".-="	return SUB_EQ;
+// ".*="	return EMUL_EQ;
+// "./="	return EDIV_EQ;
+// ".\\="	return ELEFTDIV_EQ;
diff --git a/src/parse.h b/src/parse.h
--- a/src/parse.h
+++ b/src/parse.h
@@ -32,33 +32,16 @@ extern void reset_parser (void);
 extern int yylex (void);
 extern int yyparse (void);
 
 class tree;
 class tree_matrix;
 class tree_identifier;
 class symbol_table;
 
-// Nonzero means we're in the middle of defining a function.
-extern int defining_func;
-
-// Nonzero means we're in the middle of defining a loop.
-extern int looping;
-
-// Nonzero means we're in the middle of defining a conditional expression.
-extern int iffing;
-
-// Nonzero means we need to do some extra lookahead to avoid being
-// screwed by bogus function syntax.
-extern int maybe_screwed;
-
-// Nonzero means we need to do some extra lookahead to avoid being
-// screwed by bogus function syntax.
-extern int maybe_screwed_again;
-
 // Temporary symbol table pointer used to cope with bogus function syntax.
 extern symbol_table *tmp_local_sym_tab;
 
 // Stack to hold list of literal matrices.
 extern SLStack <tree_matrix *> ml;
 
 // A nonzero element corresponding to an element of ml means we just
 // started reading a new matrix.  This should probably be part of a
@@ -72,36 +55,16 @@ extern int yydebug;
 extern int input_line_number;
 
 // The column of the current token.
 extern int current_input_column;
 
 // Buffer for help text snagged from function files.
 extern string help_buf;
 
-// Nonzero means we're working on a plot command.
-extern int plotting;
-
-// Nonzero means we've seen something that means we must be past the
-// range part of a plot command.
-extern int past_plot_range;
-
-// Nonzero means we're looking at the range part of a plot command.
-extern int in_plot_range;
-
-// Nonzero means we're looking at the using part of a plot command.
-extern int in_plot_using;
-
-// Nonzero means we're looking at the style part of a plot command.
-extern int in_plot_style;
-
-// Nonzero means we're looking at an indirect reference to a structure
-// element.
-extern int looking_at_indirect_ref;
-
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -54,33 +54,16 @@ Software Foundation, 59 Temple Place - S
 #include "pt-misc.h"
 #include "pt-plot.h"
 #include "symtab.h"
 #include "token.h"
 #include "user-prefs.h"
 #include "utils.h"
 #include "variables.h"
 
-// Nonzero means we're in the middle of defining a function.
-int defining_func = 0;
-
-// Nonzero means we're in the middle of defining a loop.
-int looping = 0;
-
-// Nonzero means we're in the middle of defining a conditional expression.
-int iffing = 0;
-
-// Nonzero means we need to do some extra lookahead to avoid being
-// screwed by bogus function syntax.
-int maybe_screwed = 0;
-
-// Nonzero means we need to do some extra lookahead to avoid being
-// screwed by bogus function syntax.
-int maybe_screwed_again = 0;
-
 // Temporary symbol table pointer used to cope with bogus function syntax.
 symbol_table *tmp_local_sym_tab = 0;
 
 // Stack to hold list of literal matrices.
 SLStack <tree_matrix *> ml;
 
 // A nonzero element corresponding to an element of ml means we just
 // started reading a new matrix.  This should probably be part of a
@@ -91,36 +74,16 @@ SLStack <int> mlnm;
 int input_line_number = 0;
 
 // The column of the current token.
 int current_input_column = 1;
 
 // Buffer for help text snagged from function files.
 string help_buf;
 
-// Nonzero means we're working on a plot command.
-int plotting = 0;
-
-// Nonzero means we've seen something that means we must be past the
-// range part of a plot command.
-int past_plot_range = 0;
-
-// Nonzero means we're looking at the range part of a plot command.
-int in_plot_range = 0;
-
-// Nonzero means we're looking at the using part of a plot command.
-int in_plot_using = 0;
-
-// Nonzero means we're looking at the style part of a plot command.
-int in_plot_style = 0;
-
-// Nonzero means we're looking at an indirect reference to a structure
-// element.
-int looking_at_indirect_ref = 0;
-
 // Forward declarations for some functions defined at the bottom of
 // the file.
 
 // Generic error messages.
 static void yyerror (char *s);
 
 // Error mesages for mismatched end tokens.
 static void end_error (char *type, token::end_tok_type ettype, int l, int c);
@@ -486,17 +449,17 @@ list		: list1
 		  {
 		    tree_statement *tmp = $1->rear ();
 		    tmp->set_print_flag (0);
 		  }
 		;
 
 list1		: statement
 		  {
-		    beginning_of_function = 0;
+		    lexer_flags.beginning_of_function = 0;
 		    $$ = new tree_statement_list ($1);
 		  }
 		| list1 comma_nl_sep statement
 		  {
 		    maybe_warn_missing_semi ($1);
 		    $1->append ($3);
 		    $$ = $1;
 		  }
@@ -596,22 +559,22 @@ plot_options	: using
 		| style using title	 
 		  { $$ = new subplot ($2, $3, $1); }
 		| style title using	 
 		  { $$ = new subplot ($3, $2, $1); }
 		;
 
 using		: using1
 		  {
-		    in_plot_using = 0;
+		    lexer_flags.in_plot_using = 0;
 		    $$ = $1;
 		  }
 		| using1 expression
 		  {
-		    in_plot_using = 0;
+		    lexer_flags.in_plot_using = 0;
 		    $$ = $1->set_format ($2);
 		  }
 		;
 
 using1		: USING expression
 		  {
 		    subplot_using *tmp = new subplot_using ();
 		    $$ = tmp->add_qualifier ($2);
@@ -674,17 +637,17 @@ optcomma	: // empty
 command		: plot_command
 		  { $$ = $1; }
 		| func_def
 		  { $$ = $1; }
 		| global_decl
 		  { $$ = $1; }
 		| if_command
 		  {
-		    iffing--;
+		    lexer_flags.iffing--;
 		    $$ = $1;
 		  }
 		| UNWIND optsep opt_list CLEANUP optsep opt_list END
 		  {
 		    if (! ($$ = make_unwind_command ($1, $3, $6, $7)))
 		      ABORT_PARSE;
 		  }
 		| TRY optsep opt_list CATCH optsep opt_list END
@@ -760,17 +723,17 @@ sep		: ','
 		| ';'
 		| '\n'
 		| sep ','
 		| sep ';'
 		| sep '\n'
 		;
 
 screwed_again	: // empty
-		  { maybe_screwed_again++; }
+		  { lexer_flags.maybe_screwed_again++; }
 		;
 
 expression	: simple_expr
 		  { $$ = $1; }
 		| NUM '=' expression
 		  {
 		    yyerror ("invalid assignment to a number");
 		    $$ = 0;
@@ -925,33 +888,33 @@ g_symtab	: // empty
 		  { curr_sym_tab = global_sym_tab; }
 		;
 
 local_symtab	: // empty
 		  { curr_sym_tab = tmp_local_sym_tab; }
 		;
 
 safe		: // empty
-		  { maybe_screwed = 0; }
+		  { lexer_flags.maybe_screwed = 0; }
 		;
 
 are_we_screwed	: // empty
-		  { maybe_screwed = 1; }
+		  { lexer_flags.maybe_screwed = 1; }
 		;
 
 func_def	: FCN g_symtab are_we_screwed func_def1
 		  {
 		    curr_sym_tab = top_level_sym_tab;
-		    defining_func = 0;
+		    lexer_flags.defining_func = 0;
 		    $$ = 0;
 		  }
 		| FCN g_symtab are_we_screwed func_def2
 		  {
 		    curr_sym_tab = top_level_sym_tab;
-		    defining_func = 0;
+		    lexer_flags.defining_func = 0;
 		    $$ = 0;
 		  }
 		;
 
 func_def1	: SCREW safe g_symtab '=' func_def2
 		  { $$ = finish_function_def ($1, $5); }
 		| return_list g_symtab '=' func_def2
 		  { $$ = finish_function_def ($1, $4); }
@@ -1013,26 +976,27 @@ fcn_end_or_eof	: END
 		  {
 		    if (! (reading_fcn_file || reading_script_file))
 		      YYABORT;
 		  }
 		;
 
 indirect_ref	: indirect_ref1
 		  {
-		    looking_at_indirect_ref = 0;
+		    lexer_flags.looking_at_indirect_ref = 0;
 		    $$ = $1;
 		  }
 
 indirect_ref1	: identifier
 		  {
 		    $$ = new tree_indirect_ref ($1, $1->line (),
 						$1->column ());
 		  }
-		| indirect_ref1 '.' { looking_at_indirect_ref = 1; } TEXT_ID
+		| indirect_ref1 '.'
+		    { lexer_flags.looking_at_indirect_ref = 1; } TEXT_ID
 		  { $$ = $1->chain ($4->text ()); }
 		;
 
 variable	: indirect_ref
 		  { $$ = make_index_expression ($1, 0); }
 		| indirect_ref '(' ')'
 		  { $$ = make_index_expression ($1, 0); }
 		| indirect_ref '(' arg_list ')'
@@ -1043,34 +1007,34 @@ variable	: indirect_ref
  `[\' and `]\'"); 
 		    $$ = 0;
 		    ABORT_PARSE;
 		  }
 		;
 
 param_list	: '(' ')'
 		  {
-		    quote_is_transpose = 0;
+		    lexer_flags.quote_is_transpose = 0;
 		    $$ = 0;
 		  }
 		| '(' ELLIPSIS ')'
 		  {
-		    quote_is_transpose = 0;
+		    lexer_flags.quote_is_transpose = 0;
 		    tree_parameter_list *tmp = new tree_parameter_list ();
 		    tmp->mark_varargs_only ();
 		    $$ = tmp;
 		  }
 		| param_list1 ')'
 		  {
-		    quote_is_transpose = 0;
+		    lexer_flags.quote_is_transpose = 0;
 		    $1->mark_as_formal_parameters ();
 		  }
 		| param_list1 ',' ELLIPSIS ')'
 		  {
-		    quote_is_transpose = 0;
+		    lexer_flags.quote_is_transpose = 0;
 		    $1->mark_as_formal_parameters ();
 		    $1->mark_varargs ();
 		  }
 		;
 
 param_list1	: '(' identifier
 		  { $$ = new tree_parameter_list ($2); }
 		| param_list1 ',' identifier
@@ -1360,21 +1324,21 @@ make_plot_command (token *tok, plot_limi
 	}
     }
   else if (! list && tok->pttype () != token::replot)
     {
       yyerror ("must have something to plot");
       return 0;
     }
 
-  plotting = 0;
-  past_plot_range = 0;
-  in_plot_range = 0;
-  in_plot_using = 0;
-  in_plot_style = 0;
+  lexer_flags.plotting = 0;
+  lexer_flags.past_plot_range = 0;
+  lexer_flags.in_plot_range = 0;
+  lexer_flags.in_plot_using = 0;
+  lexer_flags.in_plot_style = 0;
   
   return new tree_plot_command (list, range, tok->pttype ());
 }
 
 // Finish building a range.
 
 static tree_expression *
 finish_colon_expression (tree_colon_expression *e)
@@ -1699,17 +1663,17 @@ make_while_command (token *while_tok, tr
 		    tree_statement_list *body, token *end_tok)
 {
   tree_command *retval = 0;
 
   maybe_warn_assign_as_truth_value (expr);
 
   if (! check_end (end_tok, token::while_end))
     {
-      looping--;
+      lexer_flags.looping--;
 
       int l = while_tok->line ();
       int c = while_tok->column ();
 
       retval = new tree_while_command (expr, body, l, c);
     }
 
   return retval;
@@ -1721,17 +1685,17 @@ static tree_command *
 make_for_command (token *for_tok, tree_index_expression *var,
 		  tree_expression *expr, tree_statement_list *body,
 		  token *end_tok)
 {
   tree_command *retval = 0;
 
   if (! check_end (end_tok, token::for_end))
     {
-      looping--;
+      lexer_flags.looping--;
 
       int l = for_tok->line ();
       int c = for_tok->column ();
 
       retval = new tree_for_command (var, expr, body, l, c);
     }
 
   return retval;
@@ -1742,17 +1706,17 @@ make_for_command (token *for_tok, tree_i
 static tree_command *
 make_for_command (token *for_tok, tree_expression *expr,
 		  tree_statement_list *body, token *end_tok)
 {
   tree_command *retval = 0;
 
   if (! check_end (end_tok, token::for_end))
     {
-      looping--;
+      lexer_flags.looping--;
 
       tree_matrix *tmp = ml.pop ();
       tmp = tmp->reverse ();
       tree_return_list *id_list = tmp->to_return_list ();
 
       int l = for_tok->line ();
       int c = for_tok->column ();
 
@@ -1764,17 +1728,17 @@ make_for_command (token *for_tok, tree_e
 
 // Build a break command.
 
 static tree_command *
 make_break_command (token *break_tok)
 {
   tree_command *retval = 0;
 
-  if (! (looping || defining_func))
+  if (! (lexer_flags.looping || lexer_flags.defining_func))
     yyerror ("break: only meaningful within a loop or function body");
   else
     {
       int l = break_tok->line ();
       int c = break_tok->column ();
 
       retval = new tree_break_command (l, c);
     }
@@ -1784,17 +1748,17 @@ make_break_command (token *break_tok)
 
 // Build a continue command.
 
 static tree_command *
 make_continue_command (token *continue_tok)
 {
   tree_command *retval = 0;
 
-  if (! looping)
+  if (! lexer_flags.looping)
     yyerror ("continue: only meaningful within a `for' or `while' loop");
   else
     {
       int l = continue_tok->line ();
       int c = continue_tok->column ();
 
       retval = new tree_continue_command (l, c);
     }
@@ -1804,17 +1768,17 @@ make_continue_command (token *continue_t
 
 // Build a return command.
 
 static tree_command *
 make_return_command (token *return_tok)
 {
   tree_command *retval = 0;
 
-  if (! defining_func)
+  if (! lexer_flags.defining_func)
     yyerror ("return: only meaningful within a function");
   else
     {
       int l = return_tok->line ();
       int c = return_tok->column ();
 
       retval = new tree_return_command (l, c);
     }
@@ -1882,17 +1846,17 @@ make_multi_val_ret (tree_expression *rhs
 {
 // Convert the matrix list to a list of identifiers.  If that fails,
 // we can abort here, without losing anything -- no other possible
 // syntax is valid if we've seen the equals sign as the next token
 // after the `]'. 
 
   tree_expression *retval = 0;
 
-  maybe_screwed_again--;
+  lexer_flags.maybe_screwed_again--;
 
   tree_matrix *tmp = ml.pop ();
 
   tmp = tmp->reverse ();
 
   tree_return_list *id_list = tmp->to_return_list ();
 
   if (id_list)
@@ -2073,17 +2037,17 @@ start_matrix (tree_expression *expr)
 
 static tree_expression *
 finish_matrix (void)
 {
   tree_expression *retval = 0;
 
   mlnm.pop ();
 
-  maybe_screwed_again--;
+  lexer_flags.maybe_screwed_again--;
 
   tree_matrix *list = ml.pop ();
 
   list = list->reverse ();
 
   if (list->is_matrix_constant ())
     {
       tree_constant tmp = list->eval (0);
@@ -2097,17 +2061,17 @@ finish_matrix (void)
     retval = list;
 
   return retval;
 }
 
 static void
 maybe_warn_missing_semi (tree_statement_list *t)
 {
-  if (defining_func && user_pref.warn_missing_semicolon)
+  if (lexer_flags.defining_func && user_pref.warn_missing_semicolon)
     {
       tree_statement *tmp = t->rear();
 
       if (tmp->is_expression ())
 	warning ("missing semicolon near line %d, column %d in file `%s'",
 		 tmp->line (), tmp->column (),
 		 curr_fcn_file_full_name.c_str ());
     }
