# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1449514441 18000
#      Mon Dec 07 13:54:01 2015 -0500
# Node ID f428cbe7576f916b0f6310d160d593df292d71fa
# Parent  cef0448a6ed21dcf17bf173bfa3668b63d85c8d5
eliminate unnecessary uses of nargin

* __dsearchn__.cc, betainc.cc, bsxfun.cc, data.cc, debug.cc, det.cc,
dot.cc, error.cc, file-io.cc, givens.cc, graphics.cc, hess.cc,
hex2num.cc, input.cc, inv.cc, mgorth.cc, ordschur.cc, pr-output.cc,
profiler.cc, rcond.cc, regexp.cc, sqrtm.cc, sub2ind.cc, sylvester.cc,
syscalls.cc, sysdep.cc, tsearch.cc, urlwrite.cc, utils.cc,
variables.cc:
Don't use nargin variable unless it is used more than once.

diff --git a/libinterp/corefcn/__dsearchn__.cc b/libinterp/corefcn/__dsearchn__.cc
--- a/libinterp/corefcn/__dsearchn__.cc
+++ b/libinterp/corefcn/__dsearchn__.cc
@@ -35,20 +35,19 @@ along with Octave; see the file COPYING.
 #include "oct-obj.h"
 
 DEFUN (__dsearchn__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{idx}, @var{d}] =} dsearch (@var{x}, @var{xi})\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
-  int nargin = args.length ();
   octave_value_list retval;
 
-  if (nargin != 2)
+  if (args.length () != 2)
     print_usage ();
 
   Matrix x = args(0).matrix_value ().transpose ();
   Matrix xi = args(1).matrix_value ().transpose ();
 
   if (x.rows () != xi.rows () || x.columns () < 1)
     error ("__dsearch__: number of rows of X and XI must match");
   else
diff --git a/libinterp/corefcn/betainc.cc b/libinterp/corefcn/betainc.cc
--- a/libinterp/corefcn/betainc.cc
+++ b/libinterp/corefcn/betainc.cc
@@ -62,19 +62,17 @@ betainc (x, a, b) = -----------   | t^(a
 If @var{x} has more than one component, both @var{a} and @var{b} must be\n\
 scalars.  If @var{x} is a scalar, @var{a} and @var{b} must be of\n\
 compatible dimensions.\n\
 @seealso{betaincinv, beta, betaln}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 3)
+  if (args.length () != 3)
     print_usage ();
 
   octave_value x_arg = args(0);
   octave_value a_arg = args(1);
   octave_value b_arg = args(2);
 
   // FIXME: Can we make a template version of the duplicated code below
   if (x_arg.is_single_type () || a_arg.is_single_type ()
@@ -297,19 +295,17 @@ The inverse is the value @var{x} such th
 @example\n\
 @var{y} == betainc (@var{x}, @var{a}, @var{b})\n\
 @end example\n\
 @seealso{betainc, beta, betaln}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 3)
+  if (args.length () != 3)
     print_usage ();
 
   octave_value x_arg = args(0);
   octave_value a_arg = args(1);
   octave_value b_arg = args(2);
 
   if (x_arg.is_scalar_type ())
     {
diff --git a/libinterp/corefcn/bsxfun.cc b/libinterp/corefcn/bsxfun.cc
--- a/libinterp/corefcn/bsxfun.cc
+++ b/libinterp/corefcn/bsxfun.cc
@@ -330,20 +330,19 @@ accepting two column-vector arguments of
 argument and a scalar.\n\
 \n\
 The dimensions of @var{A} and @var{B} must be equal or singleton.  The\n\
 singleton dimensions of the arrays will be expanded to the same\n\
 dimensionality as the other array.\n\
 @seealso{arrayfun, cellfun}\n\
 @end deftypefn")
 {
-  int nargin = args.length ();
   octave_value_list retval;
 
-  if (nargin != 3)
+  if (args.length () != 3)
     print_usage ();
 
   octave_value func = args(0);
 
   if (func.is_string ())
     {
       std::string name = func.string_value ();
       func = symbol_table::find_function (name);
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -4502,20 +4502,19 @@ next largest value.\n\
 \n\
 When called with more than one argument the first two arguments are taken as\n\
 the number of rows and columns and any further arguments specify additional\n\
 matrix dimensions.  The optional argument @var{class} specifies the return\n\
 type and may be either @qcode{\"double\"} or @qcode{\"single\"}.\n\
 @seealso{realmax, realmin, intmax, flintmax}\n\
 @end deftypefn")
 {
-  int nargin = args.length ();
   octave_value retval;
 
-  if (nargin == 1 && ! args(0).is_string ())
+  if (args.length () == 1 && ! args(0).is_string ())
     {
       if (args(0).is_single_type ())
         {
           Array<float> x = args(0).float_array_value ();
 
           Array<float> epsval (x.dims ());
 
           for (octave_idx_type i = 0; i < x.numel (); i++)
@@ -6245,19 +6244,17 @@ should use the @code{cputime} function i
 @code{toc} functions report the actual wall clock time that elapsed\n\
 between the calls.  This may include time spent processing other jobs or\n\
 doing nothing at all.\n\
 @seealso{toc, cputime}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 0)
+  if (args.length () != 0)
     warning ("tic: ignoring extra arguments");
 
   octave_time now;
 
   double tmp = now.double_value ();
 
   if (nargout > 0)
     {
@@ -6344,21 +6341,20 @@ returns 0 for each of its output values.
 \n\
 Note that because Octave used some CPU time to start, it is reasonable\n\
 to check to see if @code{cputime} works by checking to see if the total\n\
 CPU time used is nonzero.\n\
 @seealso{tic, toc}\n\
 @end deftypefn")
 {
   octave_value_list retval;
-  int nargin = args.length ();
   double usr = 0.0;
   double sys = 0.0;
 
-  if (nargin != 0)
+  if (args.length () != 0)
     warning ("tic: ignoring extra arguments");
 
 #if defined (HAVE_GETRUSAGE)
 
   struct rusage ru;
 
   getrusage (RUSAGE_SELF, &ru);
 
@@ -7812,19 +7808,18 @@ DEFUN (base64_encode, args, ,
 @deftypefn {Built-in Function} {@var{s} =} base64_encode (@var{x})\n\
 Encode a double matrix or array @var{x} into the base64 format string\n\
 @var{s}.\n\
 \n\
 @seealso{base64_decode}\n\
 @end deftypefn")
 {
   octave_value_list retval;
-  int nargin = args.length ();
-
-  if (nargin != 1)
+
+  if (args.length () != 1)
     print_usage ();
   else
     {
       if (! args(0).is_numeric_type ())
         error ("base64_encode: encoding is supported only for numeric arrays");
       else if (args(0).is_complex_type ()
                || args(0).is_sparse_type ())
         error ("base64_encode: encoding complex or sparse data is not supported");
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -191,17 +191,16 @@ get_user_code (const std::string& fname 
 
   return dbg_fcn;
 }
 
 static void
 parse_dbfunction_params (const char *who, const octave_value_list& args,
                          std::string& symbol_name, bp_table::intmap& lines)
 {
-  int nargin = args.length ();
   int idx = 0;
   int list_idx = 0;
   symbol_name = std::string ();
   lines = bp_table::intmap ();
 
   if (args.length () == 0)
     return;
 
@@ -236,17 +235,17 @@ parse_dbfunction_params (const char *who
       // This is a problem because parse_dbfunction_params()
       // can only pass out a single function.
       error ("%s: struct input not implemented", who);
       return;
     }
   else
     error ("%s: invalid parameter specified", who);
 
-  for (int i = idx; i < nargin; i++)
+  for (int i = idx; i < args.length (); i++)
     {
       if (args(i).is_string ())
         {
           int line = atoi (args(i).string_value ().c_str ());
 
           lines[list_idx++] = line;
         }
       else if (args(i).is_map ())
@@ -678,21 +677,19 @@ The special keyword @qcode{\"all\"} will
 files.\n\
 @seealso{dbstop, dbstatus, dbwhere}\n\
 @end deftypefn")
 {
   octave_value retval;
   std::string symbol_name = "";
   bp_table::intmap lines;
 
-  int nargin = args.length ();
-
   parse_dbfunction_params ("dbclear", args, symbol_name, lines);
 
-  if (nargin == 1 && symbol_name == "all")
+  if (args.length () == 1 && symbol_name == "all")
     bp_table::remove_all_breakpoints ();
   else
     bp_table::remove_breakpoint (symbol_name, lines);
 
   return retval;
 }
 
 DEFUN (dbstatus, args, nargout,
@@ -921,20 +918,19 @@ specification for the last line of the f
 When called with the name of a function, list that script file with line\n\
 numbers.\n\
 @seealso{dbwhere, dbstatus, dbstop}\n\
 @end deftypefn")
 {
   octave_value retval;
   octave_user_code *dbg_fcn;
 
-  int nargin = args.length ();
   string_vector argv = args.make_argv ("dbtype");
 
-  switch (nargin)
+  switch (args.length ())
     {
     case 0: // dbtype
       dbg_fcn = get_user_code ();
 
       if (dbg_fcn)
         do_dbtype (octave_stdout, dbg_fcn->fcn_file_name (),
                    0, std::numeric_limits<int>::max ());
       else
diff --git a/libinterp/corefcn/det.cc b/libinterp/corefcn/det.cc
--- a/libinterp/corefcn/det.cc
+++ b/libinterp/corefcn/det.cc
@@ -61,19 +61,17 @@ code from @sc{umfpack} is used for spars
 The determinant should not be used to check a matrix for singularity.\n\
 For that, use any of the condition number functions: @code{cond},\n\
 @code{condest}, @code{rcond}.\n\
 @seealso{cond, condest, rcond}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     print_usage ();
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (nr == 0 && nc == 0)
diff --git a/libinterp/corefcn/dot.cc b/libinterp/corefcn/dot.cc
--- a/libinterp/corefcn/dot.cc
+++ b/libinterp/corefcn/dot.cc
@@ -289,19 +289,18 @@ size of @var{B} must be @code{[k,n,@dots
 for i = 1:prod (size (@var{A})(3:end))\n\
   @var{C}(:,:,i) = @var{A}(:,:,i) * @var{B}(:,:,i)\n\
 endfor\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
-  int nargin = args.length ();
 
-  if (nargin != 2)
+  if (args.length () != 2)
     print_usage ();
 
   octave_value argx = args(0);
   octave_value argy = args(1);
 
   if (argx.is_numeric_type () && argy.is_numeric_type ())
     {
       const dim_vector dimx = argx.dims ();
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -818,19 +818,17 @@ extern octave_value_list Fsprintf (const
 static std::string
 handle_message (error_fun f, const char *id, const char *msg,
                 const octave_value_list& args, bool have_fmt)
 {
   std::string retval;
 
   std::string tstr;
 
-  int nargin = args.length ();
-
-  if (nargin > 0)
+  if (args.length () > 0)
     {
       octave_value arg;
 
       if (have_fmt)
         {
           octave_value_list tmp = Fsprintf (args, 1);
           arg = tmp(0);
         }
@@ -888,19 +886,17 @@ Reissue a previous error as defined by @
 and @qcode{\"identifier\"} fields.  @var{err} can also contain a field\n\
 @qcode{\"stack\"} that gives information on the assumed location of the\n\
 error.  Typically @var{err} is returned from @code{lasterror}.\n\
 @seealso{lasterror, lasterr, error}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     print_usage ();
 
   const octave_scalar_map err = args(0).scalar_map_value ();
 
   if (err.contains ("message") && err.contains ("identifier"))
     {
       std::string msg = err.contents ("message").string_value ();
       std::string id = err.contents ("identifier").string_value ();
@@ -1454,18 +1450,17 @@ with single quotes, as long as there are
 disable escape sequence expansion use a second backslash before the sequence\n\
 (e.g., @qcode{\"@xbackslashchar{}@xbackslashchar{}n\"}) or use the\n\
 @code{regexptranslate} function.\n\
 @seealso{warning_ids, lastwarn, error}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-  int argc = nargin + 1;
+  int argc = args.length () + 1;
 
   bool done = false;
 
   if (argc > 1 && args.all_strings_p ())
     {
       string_vector argv = args.make_argv ("warning");
 
       std::string arg1 = argv(1);
diff --git a/libinterp/corefcn/file-io.cc b/libinterp/corefcn/file-io.cc
--- a/libinterp/corefcn/file-io.cc
+++ b/libinterp/corefcn/file-io.cc
@@ -706,19 +706,17 @@ freport ()\n\
      @print{}     3     r    ieee-le    myfile\n\
 @end group\n\
 @end example\n\
 @seealso{fopen, fclose, is_valid_file_id}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int nargin = args.length ();
-
-  if (nargin > 0)
+  if (args.length () > 0)
     warning ("freport: ignoring extra arguments");
 
   octave_stdout << octave_stream_list::list_open_files ();
 
   return retval;
 }
 
 DEFUN (frewind, args, nargout,
diff --git a/libinterp/corefcn/givens.cc b/libinterp/corefcn/givens.cc
--- a/libinterp/corefcn/givens.cc
+++ b/libinterp/corefcn/givens.cc
@@ -71,19 +71,17 @@ givens (1, 1)\n\
        -0.70711   0.70711\n\
 @end group\n\
 @end example\n\
 @seealso{planerot}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 2 || nargout > 2)
+  if (args.length () != 2 || nargout > 2)
     print_usage ();
 
   if (args(0).is_single_type () || args(1).is_single_type ())
     {
       if (args(0).is_complex_type () || args(1).is_complex_type ())
         {
           FloatComplex cx = args(0).float_complex_value ();
           FloatComplex cy = args(1).float_complex_value ();
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -9650,19 +9650,17 @@ For figures, the properties @qcode{\"pos
 For axes, the properties @qcode{\"position\"} and @qcode{\"units\"} are\n\
 not affected.\n\
 \n\
 The input @var{h} may also be a vector of graphic handles in which case\n\
 each individual object will be reset.\n\
 @seealso{cla, clf, newplot}\n\
 @end deftypefn")
 {
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     print_usage ();
 
   // get vector of graphics handles
   ColumnVector hcv = args(0).xvector_value ("reset: H must be a graphics handle");
 
   // loop over graphics objects
   for (octave_idx_type n = 0; n < hcv.numel (); n++)
     gh_manager::get_object (hcv(n)).reset_default_properties ();
@@ -10134,19 +10132,17 @@ Undocumented internal function.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
   octave_value retval;
 
   Cell vals;
 
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     print_usage ();
 
   ColumnVector hcv = args(0).xvector_value ("get: H must be a graphics handle");
 
   octave_idx_type hcv_len = hcv.numel ();
 
   vals.resize (dim_vector (hcv_len, 1));
 
@@ -10376,19 +10372,17 @@ DEFUN (__calc_dimensions__, args, ,
 @deftypefn {Built-in Function} {} __calc_dimensions__ (@var{axes})\n\
 Internal function.\n\
 \n\
 Determine the number of dimensions in a graphics object, either 2 or 3.\n\
 @end deftypefn")
 {
   gh_manager::auto_lock guard;
 
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     print_usage ();
 
   double h = args(0).xdouble_value ("__calc_dimensions__: first argument must be a graphics handle");
 
   return octave_value (calc_dimensions (gh_manager::get_object (h)));
 }
 
 DEFUN (__go_axes__, args, ,
@@ -10663,19 +10657,17 @@ Undocumented internal function.\n\
 DEFUN (__image_pixel_size__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{px}, @var{py}} __image_pixel_size__ (@var{h})\n\
 Internal function: returns the pixel size of the image in normalized units.\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     print_usage ();
 
   double h = args(0).xdouble_value ("__image_pixel_size__: argument is not a handle");
 
   graphics_object go = gh_manager::get_object (h);
   if (go && go.isa ("image"))
     {
       image::properties& ip =
diff --git a/libinterp/corefcn/hess.cc b/libinterp/corefcn/hess.cc
--- a/libinterp/corefcn/hess.cc
+++ b/libinterp/corefcn/hess.cc
@@ -61,19 +61,17 @@ The Hessenberg decomposition is usually 
 eigenvalue computation, but has other applications as well\n\
 (see @nospell{Golub, Nash, and Van Loan},\n\
 IEEE Transactions on Automatic Control, 1979).\n\
 @seealso{eig, chol, lu, qr, qz, schur, svd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 1 || nargout > 2)
+  if (args.length () != 1 || nargout > 2)
     print_usage ();
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("hess", nr, nc);
diff --git a/libinterp/corefcn/hex2num.cc b/libinterp/corefcn/hex2num.cc
--- a/libinterp/corefcn/hex2num.cc
+++ b/libinterp/corefcn/hex2num.cc
@@ -61,16 +61,17 @@ hexadecimal string.  For example:\n\
 hex2num ([\"402df854\"; \"41200000\"], \"single\")\n\
    @result{} [2.7183; 10.000]\n\
 @end group\n\
 @end example\n\
 @seealso{num2hex, hex2dec, dec2hex}\n\
 @end deftypefn")
 {
   octave_value retval;
+
   int nargin = args.length ();
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
 
   if (nargin == 2 && ! args(1).is_string ())
     error ("hex2num: CLASS must be a string");
   else
@@ -215,19 +216,18 @@ num2hex (single ([-1, 1, e, Inf]))\n\
     402df854\n\
     7f800000\"\n\
 @end group\n\
 @end example\n\
 @seealso{hex2num, hex2dec, dec2hex}\n\
 @end deftypefn")
 {
   octave_value retval;
-  int nargin = args.length ();
 
-  if (nargin != 1)
+  if (args.length () != 1)
     print_usage ();
 
   if (args(0).is_single_type ())
     {
       const FloatColumnVector v (args(0).float_vector_value ());
 
       octave_idx_type nchars = 8;
       octave_idx_type nr = v.numel ();
diff --git a/libinterp/corefcn/input.cc b/libinterp/corefcn/input.cc
--- a/libinterp/corefcn/input.cc
+++ b/libinterp/corefcn/input.cc
@@ -704,21 +704,19 @@ octave_eval_string_reader::get_input (bo
 
 // If the user simply hits return, this will produce an empty matrix.
 
 static octave_value_list
 get_user_input (const octave_value_list& args, int nargout)
 {
   octave_value_list retval;
 
-  int nargin = args.length ();
-
   int read_as_string = 0;
 
-  if (nargin == 2)
+  if (args.length () == 2)
     read_as_string++;
 
   std::string prompt = args(0).xstring_value ("input: unrecognized argument");
 
   flush_octave_stdout ();
 
   octave_pager_stream::reset ();
   octave_diary_stream::reset ();
@@ -912,19 +910,17 @@ The @code{keyboard} function does not re
 \n\
 If @code{keyboard} is invoked without arguments, a default prompt of\n\
 @samp{debug> } is used.\n\
 @seealso{dbstop, dbcont, dbquit}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int nargin = args.length ();
-
-  if (nargin > 1)
+  if (args.length () > 1)
     print_usage ();
 
   unwind_protect frame;
 
   frame.add_fcn (octave_call_stack::restore_frame,
                  octave_call_stack::current_frame ());
 
   // Skip the frame assigned to the keyboard function.
@@ -968,21 +964,19 @@ functions.\n\
 @end table\n\
 \n\
 @noindent\n\
 With no arguments, @code{echo} toggles the current echo state.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int nargin = args.length ();
-
   string_vector argv = args.make_argv ("echo");
 
-  switch (nargin)
+  switch (args.length ())
     {
     case 0:
       {
         if ((Vecho_executing_commands & ECHO_SCRIPTS)
             || (Vecho_executing_commands & ECHO_FUNCTIONS))
           Vecho_executing_commands = ECHO_OFF;
         else
           Vecho_executing_commands = ECHO_SCRIPTS;
@@ -1090,19 +1084,17 @@ Generate possible completions given @var
 This function is provided for the benefit of programs like Emacs which\n\
 might be controlling Octave and handling user input.  The current\n\
 command number is not incremented when this function is called.  This is\n\
 a feature, not a bug.\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     print_usage ();
 
   std::string hint = args(0).string_value ();
 
   int n = 32;
 
   string_vector list (n);
 
diff --git a/libinterp/corefcn/inv.cc b/libinterp/corefcn/inv.cc
--- a/libinterp/corefcn/inv.cc
+++ b/libinterp/corefcn/inv.cc
@@ -55,19 +55,17 @@ equations (@var{A}*@math{x} = @math{b}) 
 If called with a sparse matrix, then in general @var{x} will be a full\n\
 matrix requiring significantly more storage.  Avoid forming the inverse of a\n\
 sparse matrix if possible.\n\
 @seealso{ldivide, rdivide}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     print_usage ();
 
   octave_value arg = args(0);
 
   octave_idx_type nr = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   int arg_is_empty = empty_arg ("inverse", nr, nc);
diff --git a/libinterp/corefcn/mgorth.cc b/libinterp/corefcn/mgorth.cc
--- a/libinterp/corefcn/mgorth.cc
+++ b/libinterp/corefcn/mgorth.cc
@@ -64,19 +64,17 @@ On exit, @var{y} is a unit vector such t
   @var{x} = [@var{v}, @var{y}]*@var{h}'\n\
 @end group\n\
 @end example\n\
 \n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 2 || nargout > 2)
+  if (args.length () != 2 || nargout > 2)
     print_usage ();
 
   octave_value arg_x = args(0);
   octave_value arg_v = args(1);
 
   if (arg_v.ndims () != 2 || arg_x.ndims () != 2 || arg_x.columns () != 1
       || arg_v.rows () != arg_x.rows ())
     {
diff --git a/libinterp/corefcn/ordschur.cc b/libinterp/corefcn/ordschur.cc
--- a/libinterp/corefcn/ordschur.cc
+++ b/libinterp/corefcn/ordschur.cc
@@ -102,20 +102,19 @@ is in the upper left corner, by doing:\n
 \n\
 @example\n\
 [@var{U}, @var{S}] = ordschur (@var{U}, @var{S}, [0,1])\n\
 @end example\n\
 \n\
 @seealso{schur}\n\
 @end deftypefn")
 {
-  int nargin = args.length ();
   octave_value_list retval;
 
-  if (nargin != 3)
+  if (args.length () != 3)
     print_usage ();
 
   const Array<octave_idx_type> sel = args(2).octave_idx_type_vector_value ("ordschur: SELECT must be an array of integers");
 
   const octave_idx_type n = sel.numel ();
 
   const dim_vector dimU = args(0).dims ();
   const dim_vector dimS = args(1).dims ();
diff --git a/libinterp/corefcn/pr-output.cc b/libinterp/corefcn/pr-output.cc
--- a/libinterp/corefcn/pr-output.cc
+++ b/libinterp/corefcn/pr-output.cc
@@ -3503,19 +3503,17 @@ Note that the output from @code{disp} al
 \n\
 If an output value is requested, @code{disp} prints nothing and returns the\n\
 formatted output in a string.\n\
 @seealso{fdisp}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 1 || nargout > 1)
+  if (args.length () != 1 || nargout > 1)
     print_usage ();
 
   octave_value arg = args(0);
 
   if (nargout == 0)
     arg.print (octave_stdout);
   else
     {
@@ -3545,19 +3543,17 @@ fdisp (stdout, \"The value of pi is:\"),
 \n\
 @noindent\n\
 Note that the output from @code{fdisp} always ends with a newline.\n\
 @seealso{disp}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 2)
+  if (args.length () != 2)
     print_usage ();
 
   int fid = octave_stream_list::get_file_number (args(0));
 
   octave_stream os = octave_stream_list::lookup (fid, "fdisp");
 
   std::ostream *osp = os.output_stream ();
 
diff --git a/libinterp/corefcn/profiler.cc b/libinterp/corefcn/profiler.cc
--- a/libinterp/corefcn/profiler.cc
+++ b/libinterp/corefcn/profiler.cc
@@ -415,37 +415,35 @@ Undocumented internal function.\n\
 // Clear all collected profiling data.
 DEFUN (__profiler_reset__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Function File} {} __profiler_reset__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
-  const int nargin = args.length ();
 
-  if (nargin > 0)
+  if (args.length () > 0)
     warning ("profiler_reset: ignoring extra arguments");
 
   profiler.reset ();
 
   return retval;
 }
 
 // Query the timings collected by the profiler.
 DEFUN (__profiler_data__, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {Function File} {} __profiler_data__ ()\n\
 Undocumented internal function.\n\
 @end deftypefn")
 {
   octave_value_list retval;
-  const int nargin = args.length ();
 
-  if (nargin > 0)
+  if (args.length () > 0)
     warning ("profiler_data: ignoring extra arguments");
 
   if (nargout > 1)
     retval(1) = profiler.get_hierarchical ();
   retval(0) = profiler.get_flat ();
 
   return retval;
 }
diff --git a/libinterp/corefcn/rcond.cc b/libinterp/corefcn/rcond.cc
--- a/libinterp/corefcn/rcond.cc
+++ b/libinterp/corefcn/rcond.cc
@@ -42,19 +42,17 @@ matrix is poorly conditioned it will be 
 The matrix @var{A} must not be sparse.  If the matrix is sparse then\n\
 @code{condest (@var{A})} or @code{rcond (full (@var{A}))} should be used\n\
 instead.\n\
 @seealso{cond, condest}\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     print_usage ();
 
   if (args(0).is_sparse_type ())
     error ("rcond: for sparse matrices use 'rcond (full (a))' or 'condest (a)' instead");
   else if (args(0).is_single_type ())
     {
       if (args(0).is_complex_type ())
         {
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -275,21 +275,19 @@ do_regexp_rep_string_escapes (const std:
 
   return retval;
 }
 
 static void
 parse_options (regexp::opts& options, const octave_value_list& args,
                const std::string& who, int skip, bool& extra_args)
 {
-  int nargin = args.length ();
-
   extra_args = false;
 
-  for (int i = skip; i < nargin; i++)
+  for (int i = skip; i < args.length (); i++)
     {
       std::string str;
 
       str = args(i).xstring_value ("%s: optional arguments must be strings", who.c_str ());
 
       std::transform (str.begin (), str.end (), str.begin (), tolower);
 
       if (str.find ("once", 0) == 0)
diff --git a/libinterp/corefcn/sqrtm.cc b/libinterp/corefcn/sqrtm.cc
--- a/libinterp/corefcn/sqrtm.cc
+++ b/libinterp/corefcn/sqrtm.cc
@@ -209,19 +209,17 @@ Compute the matrix square root of the sq
 Ref: @nospell{N.J. Higham}.  @cite{A New sqrtm for @sc{matlab}}.  Numerical\n\
 Analysis Report No. 336, Manchester @nospell{Centre} for Computational\n\
 Mathematics, Manchester, England, January 1999.\n\
 @seealso{expm, logm}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     print_usage ();
 
   octave_value arg = args(0);
 
   octave_idx_type n = arg.rows ();
   octave_idx_type nc = arg.columns ();
 
   if (n != nc || arg.ndims () > 2)
diff --git a/libinterp/corefcn/sub2ind.cc b/libinterp/corefcn/sub2ind.cc
--- a/libinterp/corefcn/sub2ind.cc
+++ b/libinterp/corefcn/sub2ind.cc
@@ -178,19 +178,17 @@ moving from one column to next, filling 
     @result{} c =  3\n\
 @end group\n\
 @end example\n\
 @seealso{sub2ind}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 2)
+  if (args.length () != 2)
     print_usage ();
 
   dim_vector dv = get_dim_vector (args(0), "ind2sub");
 
   try
     {
       idx_vector idx = args(1).index_vector ();
 
diff --git a/libinterp/corefcn/sylvester.cc b/libinterp/corefcn/sylvester.cc
--- a/libinterp/corefcn/sylvester.cc
+++ b/libinterp/corefcn/sylvester.cc
@@ -57,19 +57,17 @@ For example:\n\
 sylvester ([1, 2; 3, 4], [5, 6; 7, 8], [9, 10; 11, 12])\n\
    @result{} [ 0.50000, 0.66667; 0.66667, 0.50000 ]\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 3 || nargout > 1)
+  if (args.length () != 3 || nargout > 1)
     print_usage ();
 
   octave_value arg_a = args(0);
   octave_value arg_b = args(1);
   octave_value arg_c = args(2);
 
   octave_idx_type a_nr = arg_a.rows ();
   octave_idx_type a_nc = arg_a.columns ();
diff --git a/libinterp/corefcn/syscalls.cc b/libinterp/corefcn/syscalls.cc
--- a/libinterp/corefcn/syscalls.cc
+++ b/libinterp/corefcn/syscalls.cc
@@ -120,19 +120,17 @@ error message.\n\
 @seealso{fopen, fclose, fcntl}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   retval(1) = std::string ();
   retval(0) = -1;
 
-  int nargin = args.length ();
-
-  if (nargin != 2)
+  if (args.length () != 2)
     print_usage ();
 
   octave_stream old_stream
     = octave_stream_list::lookup (args(0), "dup2");
 
   octave_stream new_stream
     = octave_stream_list::lookup (args(1), "dup2");
 
diff --git a/libinterp/corefcn/sysdep.cc b/libinterp/corefcn/sysdep.cc
--- a/libinterp/corefcn/sysdep.cc
+++ b/libinterp/corefcn/sysdep.cc
@@ -607,19 +607,17 @@ For example,\n\
 getenv (\"PATH\")\n\
 @end example\n\
 \n\
 @noindent\n\
 returns a string containing the value of your path.\n\
 @seealso{setenv, unsetenv}\n\
 @end deftypefn")
 {
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     print_usage ();
 
   std::string name = args(0).string_value ();
 
   return octave_value (octave_env::getenv (name));
 }
 
 /*
@@ -671,19 +669,17 @@ DEFUN (unsetenv, args, ,
 @deftypefn {Built-in Function} {@var{status} =} unsetenv (@var{var})\n\
 Delete the environment variable @var{var}.\n\
 \n\
 Return 0 if the variable was deleted, or did not exist, and -1 if an error\n\
 occurred.\n\
 @seealso{setenv, getenv}\n\
 @end deftypefn")
 {
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     print_usage ();
 
   std::string tmp = args(0).string_value ();
 
   return octave_value (gnulib::unsetenv (tmp.c_str ()));
 }
 
 /*
@@ -945,19 +941,17 @@ tilde_expand (\"~joeuser/bin\")\n\
 tilde_expand (\"~/bin\")\n\
      @result{} \"/home/jwe/bin\"\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     print_usage ();
 
   octave_value arg = args(0);
 
   string_vector sv = arg.xall_strings ("tilde_expand: argument must be char or cellstr object");
 
   sv = file_ops::tilde_expand (sv);
 
diff --git a/libinterp/corefcn/tsearch.cc b/libinterp/corefcn/tsearch.cc
--- a/libinterp/corefcn/tsearch.cc
+++ b/libinterp/corefcn/tsearch.cc
@@ -69,19 +69,17 @@ containing the points @code{(@var{xi}, @
 convex hull, @var{idx} is NaN.\n\
 @seealso{delaunay, delaunayn}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   const double eps = 1.0e-12;
 
-  const int nargin = args.length ();
-
-  if (nargin != 5)
+  if (args.length () != 5)
     print_usage ();
 
   const ColumnVector x (args(0).vector_value ());
   const ColumnVector y (args(1).vector_value ());
   const Matrix elem (args(2).matrix_value ());
   const ColumnVector xi (args(3).vector_value ());
   const ColumnVector yi (args(4).vector_value ());
 
diff --git a/libinterp/corefcn/urlwrite.cc b/libinterp/corefcn/urlwrite.cc
--- a/libinterp/corefcn/urlwrite.cc
+++ b/libinterp/corefcn/urlwrite.cc
@@ -556,19 +556,17 @@ Undocumented internal function\n\
 DEFUN (__ftp_pwd__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_pwd__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     error ("__ftp_pwd__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         retval = curl.pwd ();
       else
@@ -613,19 +611,17 @@ Undocumented internal function\n\
 DEFUN (__ftp_dir__, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_dir__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     error ("__ftp_dir__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         {
           if (nargout == 0)
@@ -691,19 +687,17 @@ Undocumented internal function\n\
 DEFUN (__ftp_ascii__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_ascii__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     error ("__ftp_ascii__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         curl.ascii ();
       else
@@ -716,19 +710,17 @@ Undocumented internal function\n\
 DEFUN (__ftp_binary__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_binary__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     error ("__ftp_binary__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         curl.binary ();
       else
@@ -741,19 +733,17 @@ Undocumented internal function\n\
 DEFUN (__ftp_close__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_close__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     error ("__ftp_close__: incorrect number of arguments");
   else
     {
       curl_handle h = ch_manager::lookup (args(0));
 
       if (h.ok ())
         ch_manager::free (h);
       else
@@ -766,19 +756,17 @@ Undocumented internal function\n\
 DEFUN (__ftp_mode__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_mode__ (@var{handle})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     error ("__ftp_mode__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         retval = (curl.is_ascii () ? "ascii" : "binary");
       else
@@ -791,19 +779,17 @@ Undocumented internal function\n\
 DEFUN (__ftp_delete__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_delete__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 2)
+  if (args.length () != 2)
     error ("__ftp_delete__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         {
           std::string file = args(1).xstring_value ("__ftp_delete__: FILE must be a string");
@@ -820,19 +806,17 @@ Undocumented internal function\n\
 DEFUN (__ftp_rmdir__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_rmdir__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 2)
+  if (args.length () != 2)
     error ("__ftp_rmdir__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         {
           std::string dir = args(1).xstring_value ("__ftp_rmdir__: DIR must be a string");
@@ -849,19 +833,17 @@ Undocumented internal function\n\
 DEFUN (__ftp_mkdir__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_mkdir__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 2)
+  if (args.length () != 2)
     error ("__ftp_mkdir__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         {
           std::string dir = args(1).xstring_value ("__ftp_mkdir__: DIR must be a string");
@@ -878,19 +860,17 @@ Undocumented internal function\n\
 DEFUN (__ftp_rename__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_rename__ (@var{handle}, @var{path})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 3)
+  if (args.length () != 3)
     error ("__ftp_rename__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         {
           std::string oldname = args(1).xstring_value ("__ftp_rename__: OLDNAME must be a string");
@@ -908,19 +888,17 @@ Undocumented internal function\n\
 DEFUN (__ftp_mput__, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __ftp_mput__ (@var{handle}, @var{files})\n\
 Undocumented internal function\n\
 @end deftypefn")
 {
   octave_value retval;
 
-  int nargin = args.length ();
-
-  if (nargin != 2)
+  if (args.length () != 2)
     error ("__ftp_mput__: incorrect number of arguments");
   else
     {
       url_transfer curl = ch_manager::get_object (args(0));
 
       if (curl.is_valid ())
         {
           std::string pat = args(1).xstring_value ("__ftp_mput__: PATTERN must be a string");
diff --git a/libinterp/corefcn/utils.cc b/libinterp/corefcn/utils.cc
--- a/libinterp/corefcn/utils.cc
+++ b/libinterp/corefcn/utils.cc
@@ -96,19 +96,17 @@ DEFUN (isvarname, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isvarname (@var{name})\n\
 Return true if @var{name} is a valid variable name.\n\
 @seealso{iskeyword, exist, who}\n\
 @end deftypefn")
 {
   octave_value retval = false;
 
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     print_usage ();
 
   if (args(0).is_string ())
     {
       std::string varname = args(0).string_value ();
 
       retval = valid_identifier (varname) && ! is_keyword (varname);
     }
@@ -743,19 +741,17 @@ DEFUN (do_string_escapes, args, ,
 Convert escape sequences in @var{string} to the characters they represent.\n\
 \n\
 Escape sequences begin with a leading backslash\n\
 (@qcode{'@xbackslashchar{}'}) followed by 1--3 characters\n\
 (.e.g., @qcode{\"@xbackslashchar{}n\"} => newline).\n\
 @seealso{undo_string_escapes}\n\
 @end deftypefn")
 {
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     print_usage ();
 
   std::string str = args(0).xstring_value ("do_string_escapes: STRING argument must be of type string");
 
   return octave_value (do_string_escapes (str));
 }
 
 /*
@@ -880,19 +876,17 @@ ans = \\a\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 replaces the unprintable alert character with its printable representation.\n\
 @seealso{do_string_escapes}\n\
 @end deftypefn")
 {
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     print_usage ();
 
   std::string str = args(0).xstring_value ("undo_string_escapes: S argument must be a string");
 
   return octave_value (undo_string_escapes (str));
 }
 
 /*
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -323,19 +323,17 @@ looks_like_struct (const std::string& te
   return retval;
 }
 
 static octave_value
 do_isglobal (const octave_value_list& args)
 {
   octave_value retval = false;
 
-  int nargin = args.length ();
-
-  if (nargin != 1)
+  if (args.length () != 1)
     print_usage ();
 
   if (! args(0).is_string ())
     {
       error ("isglobal: NAME must be a string");
       return retval;
     }
 
