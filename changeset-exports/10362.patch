# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1267174074 -3600
#      Fri Feb 26 09:47:54 2010 +0100
# Node ID b47ab50a6aa852d994f19ce1df03c74fc683bf09
# Parent  b4f67ca318d825d8980ef320a6ed700d437e19df
simplify appliers in mx-inlines.cc

diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -3064,17 +3064,17 @@ ComplexMatrix::operator -= (const Matrix
   return *this;
 }
 
 // unary operations
 
 boolMatrix
 ComplexMatrix::operator ! (void) const
 {
-  return do_mx_unary_op<boolMatrix, ComplexMatrix> (*this, mx_inline_not);
+  return do_mx_unary_op<bool, Complex> (*this, mx_inline_not);
 }
 
 // other operations
 
 bool
 ComplexMatrix::any_element_is_nan (void) const
 {
   octave_idx_type nr = rows ();
@@ -3197,53 +3197,53 @@ ComplexMatrix::too_large_for_float (void
 }
 
 // FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
 boolMatrix
 ComplexMatrix::all (int dim) const
 {
-  return do_mx_red_op<boolMatrix, Complex> (*this, dim, mx_inline_all);
+  return do_mx_red_op<bool, Complex> (*this, dim, mx_inline_all);
 }
 
 boolMatrix
 ComplexMatrix::any (int dim) const
 {
-  return do_mx_red_op<boolMatrix, Complex> (*this, dim, mx_inline_any);
+  return do_mx_red_op<bool, Complex> (*this, dim, mx_inline_any);
 }
 
 ComplexMatrix
 ComplexMatrix::cumprod (int dim) const
 {
-  return do_mx_cum_op<ComplexMatrix, Complex> (*this, dim, mx_inline_cumprod);
+  return do_mx_cum_op<Complex, Complex> (*this, dim, mx_inline_cumprod);
 }
 
 ComplexMatrix
 ComplexMatrix::cumsum (int dim) const
 {
-  return do_mx_cum_op<ComplexMatrix, Complex> (*this, dim, mx_inline_cumsum);
+  return do_mx_cum_op<Complex, Complex> (*this, dim, mx_inline_cumsum);
 }
 
 ComplexMatrix
 ComplexMatrix::prod (int dim) const
 {
-  return do_mx_red_op<ComplexMatrix, Complex> (*this, dim, mx_inline_prod);
+  return do_mx_red_op<Complex, Complex> (*this, dim, mx_inline_prod);
 }
 
 ComplexMatrix
 ComplexMatrix::sum (int dim) const
 {
-  return do_mx_red_op<ComplexMatrix, Complex> (*this, dim, mx_inline_sum);
+  return do_mx_red_op<Complex, Complex> (*this, dim, mx_inline_sum);
 }
 
 ComplexMatrix
 ComplexMatrix::sumsq (int dim) const
 {
-  return do_mx_red_op<Matrix, Complex> (*this, dim, mx_inline_sumsq);
+  return do_mx_red_op<double, Complex> (*this, dim, mx_inline_sumsq);
 }
 
 Matrix ComplexMatrix::abs (void) const
 {
   return Matrix (mx_inline_cabs_dup (data (), length ()),
                  rows (), cols ());
 }
 
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -495,17 +495,17 @@ ComplexNDArray::ifourierNd (void) const
 
 #endif
 
 // unary operations
 
 boolNDArray
 ComplexNDArray::operator ! (void) const
 {
-  return do_mx_unary_op<boolNDArray, ComplexNDArray> (*this, mx_inline_not);
+  return do_mx_unary_op<bool, Complex> (*this, mx_inline_not);
 }
 
 // FIXME -- this is not quite the right thing.
 
 bool
 ComplexNDArray::any_element_is_nan (void) const
 {
   octave_idx_type nel = nelem ();
@@ -615,65 +615,65 @@ ComplexNDArray::too_large_for_float (voi
     }
 
   return false;
 }
 
 boolNDArray
 ComplexNDArray::all (int dim) const
 {
-  return do_mx_red_op<boolNDArray, Complex> (*this, dim, mx_inline_all);
+  return do_mx_red_op<bool, Complex> (*this, dim, mx_inline_all);
 }
 
 boolNDArray
 ComplexNDArray::any (int dim) const
 {
-  return do_mx_red_op<boolNDArray, Complex> (*this, dim, mx_inline_any);
+  return do_mx_red_op<bool, Complex> (*this, dim, mx_inline_any);
 }
 
 ComplexNDArray
 ComplexNDArray::cumprod (int dim) const
 {
-  return do_mx_cum_op<ComplexNDArray, Complex> (*this, dim, mx_inline_cumprod);
+  return do_mx_cum_op<Complex, Complex> (*this, dim, mx_inline_cumprod);
 }
 
 ComplexNDArray
 ComplexNDArray::cumsum (int dim) const
 {
-  return do_mx_cum_op<ComplexNDArray, Complex> (*this, dim, mx_inline_cumsum);
+  return do_mx_cum_op<Complex, Complex> (*this, dim, mx_inline_cumsum);
 }
 
 ComplexNDArray
 ComplexNDArray::prod (int dim) const
 {
-  return do_mx_red_op<ComplexNDArray, Complex> (*this, dim, mx_inline_prod);
+  return do_mx_red_op<Complex, Complex> (*this, dim, mx_inline_prod);
 }
 
 ComplexNDArray
 ComplexNDArray::sum (int dim) const
 {
-  return do_mx_red_op<ComplexNDArray, Complex> (*this, dim, mx_inline_sum);
+  return do_mx_red_op<Complex, Complex> (*this, dim, mx_inline_sum);
 }
 
 ComplexNDArray
 ComplexNDArray::xsum (int dim) const
 {
-  return do_mx_red_op<ComplexNDArray, Complex> (*this, dim, mx_inline_xsum);
+  return do_mx_red_op<Complex, Complex> (*this, dim, mx_inline_xsum);
 }
 
 ComplexNDArray
 ComplexNDArray::sumsq (int dim) const
 {
-  return do_mx_red_op<NDArray, Complex> (*this, dim, mx_inline_sumsq);
+  return do_mx_red_op<double, Complex> (*this, dim, mx_inline_sumsq);
 }
 
 ComplexNDArray
 ComplexNDArray::diff (octave_idx_type order, int dim) const
 {
-  return do_mx_diff_op<ComplexNDArray> (*this, dim, order, mx_inline_diff);
+  return do_mx_diff_op<Complex> (*this, dim, order, mx_inline_diff);
 }
 
 ComplexNDArray
 ComplexNDArray::concat (const ComplexNDArray& rb, const Array<octave_idx_type>& ra_idx)
 {
   if (rb.numel () > 0)
     insert (rb, ra_idx);
   return *this;
@@ -697,89 +697,89 @@ concat (NDArray& ra, ComplexNDArray& rb,
   return retval;
 }
 
 static const Complex Complex_NaN_result (octave_NaN, octave_NaN);
 
 ComplexNDArray
 ComplexNDArray::max (int dim) const
 {
-  return do_mx_minmax_op<ComplexNDArray> (*this, dim, mx_inline_max);
+  return do_mx_minmax_op<Complex> (*this, dim, mx_inline_max);
 }
 
 ComplexNDArray
 ComplexNDArray::max (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_minmax_op<ComplexNDArray> (*this, idx_arg, dim, mx_inline_max);
+  return do_mx_minmax_op<Complex> (*this, idx_arg, dim, mx_inline_max);
 }
 
 ComplexNDArray
 ComplexNDArray::min (int dim) const
 {
-  return do_mx_minmax_op<ComplexNDArray> (*this, dim, mx_inline_min);
+  return do_mx_minmax_op<Complex> (*this, dim, mx_inline_min);
 }
 
 ComplexNDArray
 ComplexNDArray::min (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_minmax_op<ComplexNDArray> (*this, idx_arg, dim, mx_inline_min);
+  return do_mx_minmax_op<Complex> (*this, idx_arg, dim, mx_inline_min);
 }
 
 ComplexNDArray
 ComplexNDArray::cummax (int dim) const
 {
-  return do_mx_cumminmax_op<ComplexNDArray> (*this, dim, mx_inline_cummax);
+  return do_mx_cumminmax_op<Complex> (*this, dim, mx_inline_cummax);
 }
 
 ComplexNDArray
 ComplexNDArray::cummax (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_cumminmax_op<ComplexNDArray> (*this, idx_arg, dim, mx_inline_cummax);
+  return do_mx_cumminmax_op<Complex> (*this, idx_arg, dim, mx_inline_cummax);
 }
 
 ComplexNDArray
 ComplexNDArray::cummin (int dim) const
 {
-  return do_mx_cumminmax_op<ComplexNDArray> (*this, dim, mx_inline_cummin);
+  return do_mx_cumminmax_op<Complex> (*this, dim, mx_inline_cummin);
 }
 
 ComplexNDArray
 ComplexNDArray::cummin (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_cumminmax_op<ComplexNDArray> (*this, idx_arg, dim, mx_inline_cummin);
+  return do_mx_cumminmax_op<Complex> (*this, idx_arg, dim, mx_inline_cummin);
 }
 
 NDArray
 ComplexNDArray::abs (void) const
 {
-  return do_mx_unary_map<NDArray, ComplexNDArray, std::abs> (*this);
+  return do_mx_unary_map<double, Complex, std::abs> (*this);
 }
 
 boolNDArray
 ComplexNDArray::isnan (void) const
 {
-  return do_mx_unary_map<boolNDArray, ComplexNDArray, xisnan> (*this);
+  return do_mx_unary_map<bool, Complex, xisnan> (*this);
 }
 
 boolNDArray
 ComplexNDArray::isinf (void) const
 {
-  return do_mx_unary_map<boolNDArray, ComplexNDArray, xisinf> (*this);
+  return do_mx_unary_map<bool, Complex, xisinf> (*this);
 }
 
 boolNDArray
 ComplexNDArray::isfinite (void) const
 {
-  return do_mx_unary_map<boolNDArray, ComplexNDArray, xfinite> (*this);
+  return do_mx_unary_map<bool, Complex, xfinite> (*this);
 }
 
 ComplexNDArray
 conj (const ComplexNDArray& a)
 {
-  return do_mx_unary_map<ComplexNDArray, ComplexNDArray, std::conj> (a);
+  return do_mx_unary_map<Complex, Complex, std::conj> (a);
 }
 
 ComplexNDArray&
 ComplexNDArray::insert (const NDArray& a, octave_idx_type r, octave_idx_type c)
 {
   dim_vector a_dv = a.dims ();
   
   int n = a_dv.length ();
@@ -925,25 +925,25 @@ SND_BOOL_OPS (Complex, ComplexNDArray)
 NDND_CMP_OPS (ComplexNDArray, ComplexNDArray)
 NDND_BOOL_OPS (ComplexNDArray, ComplexNDArray)
 
 ComplexNDArray& operator *= (ComplexNDArray& a, double s)
 {
   if (a.is_shared ())
     a = a * s;
   else
-    do_ms_inplace_op<ComplexNDArray, double> (a, s, mx_inline_mul2);
+    do_ms_inplace_op<Complex, double> (a, s, mx_inline_mul2);
   return a;
 }
 
 ComplexNDArray& operator /= (ComplexNDArray& a, double s)
 {
   if (a.is_shared ())
     return a = a / s;
   else
-    do_ms_inplace_op<ComplexNDArray, double> (a, s, mx_inline_div2);
+    do_ms_inplace_op<Complex, double> (a, s, mx_inline_div2);
   return a;
 }
 
 BSXFUN_STDOP_DEFS_MXLOOP (ComplexNDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (ComplexNDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, ComplexNDArray, mx_inline_pow)
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,35 @@
+2010-02-26  Jaroslav Hajek  <highegg@gmail.com>
+
+	* mx-inlines.cc: Parameterize all appliers by value types rather than
+	Array types. Return & accept Array instances.
+	* mx-op-defs.h: Update references.
+	* CMatrix.cc: Ditto.
+	* CNDArray.cc: Ditto.
+	* DiagArray2.h: Ditto.
+	* MArray.cc: Ditto.
+	* boolMatrix.cc: Ditto.
+	* boolNDArray.cc: Ditto.
+	* bsxfun-defs.cc: Ditto.
+	* chMatrix.cc: Ditto.
+	* chNDArray.cc: Ditto.
+	* dMatrix.cc: Ditto.
+	* dNDArray.cc: Ditto.
+	* fCMatrix.cc: Ditto.
+	* fCNDArray.cc: Ditto.
+	* fMatrix.cc: Ditto.
+	* fNDArray.cc: Ditto.
+	* intNDArray.cc: Ditto.
+	* MDiagArray2.cc: Remove computed assignment operators, adapt 
+	operators to new mechanism.
+	* MDiagArray2.h: Declare operators as friends.
+	* MArray-decl.h (MDIAGARRAY2_OPS_FRIEND_DECLS): Don't expand
+	MARRAY_OP_ASSIGN_FRIENDS here.
+
 2010-02-25  John W. Eaton  <jwe@octave.org>
 
 	* eigs-base.cc: Use octave_idx_type for Fortran LOGICAL values
 	in function prototypes.
 	(EigsRealSymmetricMatrix, EigsRealSymmetricMatrixShift,
 	EigsRealSymmetricFunc, EigsRealNonSymmetricMatrix,
 	EigsRealNonSymmetricMatrixShift, EigsRealNonSymmetricFunc,
 	EigsComplexNonSymmetricMatrix, EigsComplexNonSymmetricMatrixShift,
diff --git a/liboctave/DiagArray2.h b/liboctave/DiagArray2.h
--- a/liboctave/DiagArray2.h
+++ b/liboctave/DiagArray2.h
@@ -109,16 +109,19 @@ public:
     {
       if (dv.length () != 2)
         (*current_liboctave_error_handler) ("too many dimensions");
     }
 
   DiagArray2 (const Array<T>& a) 
     : Array<T> (a.as_column ()), d1 (a.numel ()), d2 (a.numel ()) { }
 
+  DiagArray2 (const Array<T>& a, octave_idx_type r, octave_idx_type c) 
+    : Array<T> (a.as_column ()), d1 (r), d2 (c) { }
+
   DiagArray2 (const DiagArray2<T>& a) 
     : Array<T> (a), d1 (a.d1), d2 (a.d2) { }
 
   template <class U>
   DiagArray2 (const DiagArray2<U>& a) 
   : Array<T> (a.diag ()), d1 (a.dim1 ()), d2 (a.dim2 ()) { }
 
   ~DiagArray2 (void) { }
diff --git a/liboctave/MArray-decl.h b/liboctave/MArray-decl.h
--- a/liboctave/MArray-decl.h
+++ b/liboctave/MArray-decl.h
@@ -223,17 +223,16 @@ along with Octave; see the file COPYING.
 // Friend declarations for the MArray operators.
 #define MARRAY_OPS_FRIEND_DECLS(A_T, API) \
   MARRAY_OP_ASSIGN_FRIENDS1 (A_T, T, API) \
   MARRAY_OP_ASSIGN_FRIENDS (A_T, A_T<T>, API) \
   MARRAY_UNOP_FRIENDS (A_T, API) \
   MARRAY_BINOP_FRIENDS (A_T, API)
 
 #define MDIAGARRAY2_OPS_FRIEND_DECLS(A_T, API) \
-  MARRAY_OP_ASSIGN_FRIENDS (A_T, A_T<T>, API) \
   MARRAY_UNOP_FRIENDS (A_T, API) \
   MDIAGARRAY2_BINOP_FRIENDS (A_T, API)
 
 // Define all the MArray forwarding functions for return type R and
 // MArray element type T
 #define MARRAY_FORWARD_DEFS(B, R, T) \
   MARRAY_OP_ASSIGN_FWD_DEFS1 \
     (R, T, dynamic_cast<B<T>&>, R, , T) \
diff --git a/liboctave/MArray.cc b/liboctave/MArray.cc
--- a/liboctave/MArray.cc
+++ b/liboctave/MArray.cc
@@ -138,150 +138,150 @@ MArray<T>::idx_max (const idx_vector& id
 // N-dimensional array with math ops.
 template <class T>
 void
 MArray<T>::changesign (void)
 {
   if (Array<T>::is_shared ())
     *this = - *this;
   else
-    do_mx_inplace_op<MArray<T> > (*this, mx_inline_uminus2);
+    do_mx_inplace_op<T> (*this, mx_inline_uminus2);
 }
 
 // Element by element MArray by scalar ops.
 
 template <class T>
 MArray<T>&
 operator += (MArray<T>& a, const T& s)
 {
   if (a.is_shared ())
     a = a + s;
   else
-    do_ms_inplace_op<MArray<T>, T> (a, s, mx_inline_add2);
+    do_ms_inplace_op<T, T> (a, s, mx_inline_add2);
   return a;
 }
 
 template <class T>
 MArray<T>&
 operator -= (MArray<T>& a, const T& s)
 {
   if (a.is_shared ())
     a = a - s;
   else
-    do_ms_inplace_op<MArray<T>, T> (a, s, mx_inline_sub2);
+    do_ms_inplace_op<T, T> (a, s, mx_inline_sub2);
   return a;
 }
 
 template <class T>
 MArray<T>&
 operator *= (MArray<T>& a, const T& s)
 {
   if (a.is_shared ())
     a = a * s;
   else
-    do_ms_inplace_op<MArray<T>, T> (a, s, mx_inline_mul2);
+    do_ms_inplace_op<T, T> (a, s, mx_inline_mul2);
   return a;
 }
 
 template <class T>
 MArray<T>&
 operator /= (MArray<T>& a, const T& s)
 {
   if (a.is_shared ())
     a = a / s;
   else
-    do_ms_inplace_op<MArray<T>, T> (a, s, mx_inline_div2);
+    do_ms_inplace_op<T, T> (a, s, mx_inline_div2);
   return a;
 }
 
 // Element by element MArray by MArray ops.
 
 template <class T>
 MArray<T>&
 operator += (MArray<T>& a, const MArray<T>& b)
 {
   if (a.is_shared ())
     a = a + b;
   else
-    do_mm_inplace_op<MArray<T>, MArray<T> > (a, b, mx_inline_add2, "+=");
+    do_mm_inplace_op<T, T> (a, b, mx_inline_add2, "+=");
   return a;
 }
 
 template <class T>
 MArray<T>&
 operator -= (MArray<T>& a, const MArray<T>& b)
 {
   if (a.is_shared ())
     a = a - b;
   else
-    do_mm_inplace_op<MArray<T>, MArray<T> > (a, b, mx_inline_sub2, "-=");
+    do_mm_inplace_op<T, T> (a, b, mx_inline_sub2, "-=");
   return a;
 }
 
 
 template <class T>
 MArray<T>&
 product_eq (MArray<T>& a, const MArray<T>& b)
 {
   if (a.is_shared ())
     return a = product (a, b);
   else
-    do_mm_inplace_op<MArray<T>, MArray<T> > (a, b, mx_inline_mul2, ".*=");
+    do_mm_inplace_op<T, T> (a, b, mx_inline_mul2, ".*=");
   return a;
 }
 
 template <class T>
 MArray<T>&
 quotient_eq (MArray<T>& a, const MArray<T>& b)
 {
   if (a.is_shared ())
     return a = quotient (a, b);
   else
-    do_mm_inplace_op<MArray<T>, MArray<T> > (a, b, mx_inline_div2, "./=");
+    do_mm_inplace_op<T, T> (a, b, mx_inline_div2, "./=");
   return a;
 }
 
 // Element by element MArray by scalar ops.
 
 #define MARRAY_NDS_OP(OP, FN) \
   template <class T> \
   MArray<T> \
   operator OP (const MArray<T>& a, const T& s) \
   { \
-    return do_ms_binary_op<MArray<T>, MArray<T>, T> (a, s, FN); \
+    return do_ms_binary_op<T, T, T> (a, s, FN); \
   }
 
 MARRAY_NDS_OP (+, mx_inline_add)
 MARRAY_NDS_OP (-, mx_inline_sub)
 MARRAY_NDS_OP (*, mx_inline_mul)
 MARRAY_NDS_OP (/, mx_inline_div)
 
 // Element by element scalar by MArray ops.
 
 #define MARRAY_SND_OP(OP, FN) \
   template <class T> \
   MArray<T> \
   operator OP (const T& s, const MArray<T>& a) \
   { \
-    return do_sm_binary_op<MArray<T>, T, MArray<T> > (s, a, FN); \
+    return do_sm_binary_op<T, T, T> (s, a, FN); \
   }
 
 MARRAY_SND_OP (+, mx_inline_add)
 MARRAY_SND_OP (-, mx_inline_sub)
 MARRAY_SND_OP (*, mx_inline_mul)
 MARRAY_SND_OP (/, mx_inline_div)
 
 // Element by element MArray by MArray ops.
 
 #define MARRAY_NDND_OP(FCN, OP, FN) \
   template <class T> \
   MArray<T> \
   FCN (const MArray<T>& a, const MArray<T>& b) \
   { \
-    return do_mm_binary_op<MArray<T>, MArray<T>, MArray<T> > (a, b, FN, #FCN); \
+    return do_mm_binary_op<T, T, T> (a, b, FN, #FCN); \
   }
 
 MARRAY_NDND_OP (operator +, +, mx_inline_add)
 MARRAY_NDND_OP (operator -, -, mx_inline_sub)
 MARRAY_NDND_OP (product,    *, mx_inline_mul)
 MARRAY_NDND_OP (quotient,   /, mx_inline_div)
 
 template <class T>
@@ -290,10 +290,10 @@ operator + (const MArray<T>& a)
 {
   return a;
 }
 
 template <class T>
 MArray<T>
 operator - (const MArray<T>& a)
 {
-  return do_mx_unary_op<MArray<T>, MArray<T> > (a, mx_inline_uminus); 
+  return do_mx_unary_op<T, T> (a, mx_inline_uminus); 
 }
diff --git a/liboctave/MDiagArray2.cc b/liboctave/MDiagArray2.cc
--- a/liboctave/MDiagArray2.cc
+++ b/liboctave/MDiagArray2.cc
@@ -46,69 +46,48 @@ MDiagArray2<T>::is_multiple_of_identity 
 
   return retval;
 }
 
 // Two dimensional diagonal array with math ops.
 
 // Element by element MDiagArray2 by MDiagArray2 ops.
 
-template <class T>
-MDiagArray2<T>&
-operator += (MDiagArray2<T>& a, const MDiagArray2<T>& b)
-{
-  if (a.is_shared ())
-    a = a + b;
-  else
-    do_mm_inplace_op<MDiagArray2<T>, MDiagArray2<T> > (a, b, mx_inline_add2, "+=");
-  return a;
-}
-
-template <class T>
-MDiagArray2<T>&
-operator -= (MDiagArray2<T>& a, const MDiagArray2<T>& b)
-{
-  if (a.is_shared ())
-    a = a - b;
-  else
-    do_mm_inplace_op<MDiagArray2<T>, MDiagArray2<T> > (a, b, mx_inline_sub2, "-=");
-  return a;
-}
-
-
 // Element by element MDiagArray2 by scalar ops.
 
 #define MARRAY_DAS_OP(OP, FN) \
   template <class T> \
   MDiagArray2<T> \
   operator OP (const MDiagArray2<T>& a, const T& s) \
   { \
-    return do_ms_binary_op<MDiagArray2<T>, MDiagArray2<T>, T> (a, s, FN); \
+    return MDiagArray2<T> (do_ms_binary_op<T, T, T> (a, s, FN), a.d1, a.d2); \
   }
 
 MARRAY_DAS_OP (*, mx_inline_mul)
 MARRAY_DAS_OP (/, mx_inline_div)
 
 // Element by element scalar by MDiagArray2 ops.
 
 template <class T>
 MDiagArray2<T>
 operator * (const T& s, const MDiagArray2<T>& a)
 {
-  return do_sm_binary_op<MDiagArray2<T>, T, MDiagArray2<T> > (s, a, mx_inline_mul);
+  return MDiagArray2<T> (do_sm_binary_op<T, T, T> (s, a, mx_inline_mul), a.d1, a.d2);
 }
 
 // Element by element MDiagArray2 by MDiagArray2 ops.
 
 #define MARRAY_DADA_OP(FCN, OP, FN) \
   template <class T> \
   MDiagArray2<T> \
   FCN (const MDiagArray2<T>& a, const MDiagArray2<T>& b) \
   { \
-    return do_mm_binary_op<MDiagArray2<T>, MDiagArray2<T>, MDiagArray2<T> > (a, b, FN, #FCN); \
+    if (a.d1 != b.d1 || a.d2 != b.d2) \
+      gripe_nonconformant (#FCN, a.d1, a.d2, b.d1, b.d2); \
+    return MDiagArray2<T> (do_mm_binary_op<T, T, T> (a, b, FN, #FCN), a.d1, a.d2); \
   }
 
 MARRAY_DADA_OP (operator +, +, mx_inline_add)
 MARRAY_DADA_OP (operator -, -, mx_inline_sub)
 MARRAY_DADA_OP (product,    *, mx_inline_mul)
 
 // Unary MDiagArray2 ops.
 
@@ -118,10 +97,10 @@ operator + (const MDiagArray2<T>& a)
 {
   return a;
 }
 
 template <class T>
 MDiagArray2<T>
 operator - (const MDiagArray2<T>& a)
 {
-  return do_mx_unary_op<MDiagArray2<T>, MDiagArray2<T> > (a, mx_inline_uminus); 
+  return MDiagArray2<T> (do_mx_unary_op<T, T> (a, mx_inline_uminus), a.d1, a.d2); 
 }
diff --git a/liboctave/MDiagArray2.h b/liboctave/MDiagArray2.h
--- a/liboctave/MDiagArray2.h
+++ b/liboctave/MDiagArray2.h
@@ -58,16 +58,19 @@ public:
 
   MDiagArray2 (const DiagArray2<T>& a) : DiagArray2<T> (a) { }
 
   template <class U>
   MDiagArray2 (const DiagArray2<U>& a) : DiagArray2<T> (a) { }
 
   explicit MDiagArray2 (const Array<T>& a) : DiagArray2<T> (a) { }
 
+  MDiagArray2 (const Array<T>& a, octave_idx_type r, octave_idx_type c) 
+    : DiagArray2<T> (a, r, c) { }
+
   ~MDiagArray2 (void) { }
 
   MDiagArray2<T>& operator = (const MDiagArray2<T>& a)
     {
       DiagArray2<T>::operator = (a);
       return *this;
     }
 
@@ -99,13 +102,13 @@ public:
   MDiagArray2<T> transpose (void) const { return DiagArray2<T>::transpose (); }
   MDiagArray2<T> hermitian (T (*fcn) (const T&) = 0) const { return DiagArray2<T>::hermitian (fcn); }
 
   bool is_multiple_of_identity (T val) const;
 
   // Currently, the OPS functions don't need to be friends, but that
   // may change.
 
-  // MDIAGARRAY2_OPS_FRIEND_DECLS (MDiagArray2)
+  MDIAGARRAY2_OPS_FRIEND_DECLS (MDiagArray2, )
 
 };
 
 #endif
diff --git a/liboctave/boolMatrix.cc b/liboctave/boolMatrix.cc
--- a/liboctave/boolMatrix.cc
+++ b/liboctave/boolMatrix.cc
@@ -86,21 +86,21 @@ boolMatrix::diag (octave_idx_type k) con
 }
 
 // FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
 boolMatrix
 boolMatrix::all (int dim) const
 {
-  return do_mx_red_op<boolMatrix, bool> (*this, dim, mx_inline_all);
+  return do_mx_red_op<bool, bool> (*this, dim, mx_inline_all);
 }
 
 boolMatrix
 boolMatrix::any (int dim) const
 {
-  return do_mx_red_op<boolMatrix, bool> (*this, dim, mx_inline_any);
+  return do_mx_red_op<bool, bool> (*this, dim, mx_inline_any);
 }
 
 MM_BOOL_OPS (boolMatrix, boolMatrix)
 MS_BOOL_OPS (boolMatrix, bool)
 SM_BOOL_OPS (bool, boolMatrix)
 MM_CMP_OPS (boolMatrix, boolMatrix)
diff --git a/liboctave/boolNDArray.cc b/liboctave/boolNDArray.cc
--- a/liboctave/boolNDArray.cc
+++ b/liboctave/boolNDArray.cc
@@ -36,57 +36,57 @@ along with Octave; see the file COPYING.
 
 #include "bsxfun-defs.cc"
 
 // unary operations
 
 boolNDArray
 boolNDArray::operator ! (void) const
 {
-  return do_mx_unary_op<boolNDArray> (*this, mx_inline_not);
+  return do_mx_unary_op<bool> (*this, mx_inline_not);
 }
 
 boolNDArray&
 boolNDArray::invert (void)
 {
   if (is_shared ())
     *this = ! *this;
   else
-    do_mx_inplace_op<boolNDArray> (*this, mx_inline_not2);
+    do_mx_inplace_op<bool> (*this, mx_inline_not2);
 
   return *this;
 }
 
 // FIXME -- this is not quite the right thing.
 
 boolNDArray
 boolNDArray::all (int dim) const
 {
-  return do_mx_red_op<boolNDArray, bool> (*this, dim, mx_inline_all);
+  return do_mx_red_op<bool, bool> (*this, dim, mx_inline_all);
 }
 
 boolNDArray
 boolNDArray::any (int dim) const
 {
-  return do_mx_red_op<boolNDArray, bool> (*this, dim, mx_inline_any);
+  return do_mx_red_op<bool, bool> (*this, dim, mx_inline_any);
 }
 
 NDArray 
 boolNDArray::sum (int dim) const
 {
   // NOTE: going via octave_idx_type is typically faster even though it
   // requires a conversion. 
-  return do_mx_red_op<Array<octave_idx_type> , bool> (*this, dim, mx_inline_count);
+  return do_mx_red_op<octave_idx_type, bool> (*this, dim, mx_inline_count);
 }
 
 NDArray 
 boolNDArray::cumsum (int dim) const
 {
   // In this case, it's better to sum directly to doubles.
-  return do_mx_cum_op<NDArray , bool> (*this, dim, mx_inline_cumcount);
+  return do_mx_cum_op<double , bool> (*this, dim, mx_inline_cumcount);
 }
 
 boolNDArray
 boolNDArray::concat (const boolNDArray& rb, const Array<octave_idx_type>& ra_idx)
 {
   if (rb.numel () > 0)
     insert (rb, ra_idx);
   return *this;
@@ -145,26 +145,26 @@ SND_BOOL_OPS (bool, boolNDArray)
 SND_CMP_OPS (bool, boolNDArray)
 
 boolNDArray& 
 mx_el_and_assign (boolNDArray& a, const boolNDArray& b)
 {
   if (a.is_shared ())
     a = mx_el_and (a, b);
   else
-    do_mm_inplace_op<boolNDArray, boolNDArray> (a, b, mx_inline_and2, "operator &=");
+    do_mm_inplace_op<bool, bool> (a, b, mx_inline_and2, "operator &=");
 
   return a;
 }
 
 boolNDArray& 
 mx_el_or_assign (boolNDArray& a, const boolNDArray& b)
 {
   if (a.is_shared ())
     a = mx_el_or (a, b);
   else
-    do_mm_inplace_op<boolNDArray, boolNDArray> (a, b, mx_inline_or2, "operator |=");
+    do_mm_inplace_op<bool, bool> (a, b, mx_inline_or2, "operator |=");
 
   return a;
 }
 
 BSXFUN_OP_DEF_MXLOOP (and, boolNDArray, mx_inline_and)
 BSXFUN_OP_DEF_MXLOOP (or, boolNDArray, mx_inline_or)
diff --git a/liboctave/bsxfun-defs.cc b/liboctave/bsxfun-defs.cc
--- a/liboctave/bsxfun-defs.cc
+++ b/liboctave/bsxfun-defs.cc
@@ -28,28 +28,22 @@ along with Octave; see the file COPYING.
 #include <iostream>
 
 #include "dim-vector.h"
 #include "oct-locbuf.h"
 #include "lo-error.h"
 
 #include "mx-inlines.cc"
 
-template <class RNDA, class XNDA, class YNDA>
-RNDA
-do_bsxfun_op (const XNDA& x, const YNDA& y,
-              void (*op_vv) (size_t, typename RNDA::element_type *,
-                             const typename XNDA::element_type *,
-                             const typename YNDA::element_type *),
-              void (*op_sv) (size_t, typename RNDA::element_type *,
-                             typename XNDA::element_type,
-                             const typename YNDA::element_type *),
-              void (*op_vs) (size_t, typename RNDA::element_type *,
-                             const typename XNDA::element_type *,
-                             typename YNDA::element_type))
+template <class R, class X, class Y>
+Array<R>
+do_bsxfun_op (const Array<X>& x, const Array<Y>& y,
+              void (*op_vv) (size_t, R *, const X *, const Y *),
+              void (*op_sv) (size_t, R *, X, const Y *),
+              void (*op_vs) (size_t, R *, const X *, Y))
 {
   int nd = std::max (x.ndims (), y.ndims ());
   dim_vector dvx = x.dims ().redim (nd), dvy = y.dims ().redim (nd);
 
   // Construct the result dimensions.
   dim_vector dvr;
   dvr.resize (nd);
   for (int i = 0; i < nd; i++)
@@ -63,21 +57,21 @@ do_bsxfun_op (const XNDA& x, const YNDA&
         {
           (*current_liboctave_error_handler)
             ("bsxfun: nonconformant dimensions: %s and %s",
              x.dims ().str ().c_str (), y.dims ().str ().c_str ());
           break;
         }
     }
 
-  RNDA retval (dvr);
+  Array<R> retval (dvr);
 
-  const typename XNDA::element_type *xvec = x.fortran_vec ();
-  const typename YNDA::element_type *yvec = y.fortran_vec ();
-  typename RNDA::element_type *rvec = retval.fortran_vec ();
+  const X *xvec = x.fortran_vec ();
+  const Y *yvec = y.fortran_vec ();
+  R *rvec = retval.fortran_vec ();
 
   // Fold the common leading dimensions.
   int start;
   octave_idx_type ldr = 1;
   for (start = 0; start < nd; start++)
     {
       if (dvx(start) != dvy(start))
         break;
@@ -146,25 +140,28 @@ ARRAY bsxfun_ ## OP (const ARRAY& x, con
 #define BSXFUN_OP2_DEF(OP, ARRAY, ARRAY1, ARRAY2) \
 ARRAY bsxfun_ ## OP (const ARRAY1& x, const ARRAY2& y)
 
 #define BSXFUN_REL_DEF(OP, ARRAY) \
 boolNDArray bsxfun_ ## OP (const ARRAY& x, const ARRAY& y)
 
 #define BSXFUN_OP_DEF_MXLOOP(OP, ARRAY, LOOP) \
   BSXFUN_OP_DEF(OP, ARRAY) \
-  { return do_bsxfun_op<ARRAY, ARRAY, ARRAY> (x, y, LOOP, LOOP, LOOP); }
+  { return do_bsxfun_op<ARRAY::element_type, ARRAY::element_type, ARRAY::element_type> \
+    (x, y, LOOP, LOOP, LOOP); }
 
 #define BSXFUN_OP2_DEF_MXLOOP(OP, ARRAY, ARRAY1, ARRAY2, LOOP) \
   BSXFUN_OP2_DEF(OP, ARRAY, ARRAY1, ARRAY2) \
-  { return do_bsxfun_op<ARRAY, ARRAY1, ARRAY2> (x, y, LOOP, LOOP, LOOP); }
+  { return do_bsxfun_op<ARRAY::element_type, ARRAY1::element_type, ARRAY2::element_type> \
+    (x, y, LOOP, LOOP, LOOP); }
 
 #define BSXFUN_REL_DEF_MXLOOP(OP, ARRAY, LOOP) \
   BSXFUN_REL_DEF(OP, ARRAY) \
-  { return do_bsxfun_op<boolNDArray, ARRAY, ARRAY> (x, y, LOOP, LOOP, LOOP); }
+  { return do_bsxfun_op<bool, ARRAY::element_type, ARRAY::element_type> \
+    (x, y, LOOP, LOOP, LOOP); }
 
 #define BSXFUN_STDOP_DEFS_MXLOOP(ARRAY) \
   BSXFUN_OP_DEF_MXLOOP (add, ARRAY, mx_inline_add) \
   BSXFUN_OP_DEF_MXLOOP (sub, ARRAY, mx_inline_sub) \
   BSXFUN_OP_DEF_MXLOOP (mul, ARRAY, mx_inline_mul) \
   BSXFUN_OP_DEF_MXLOOP (div, ARRAY, mx_inline_div) \
   BSXFUN_OP_DEF_MXLOOP (min, ARRAY, mx_inline_xmin) \
   BSXFUN_OP_DEF_MXLOOP (max, ARRAY, mx_inline_xmax) \
diff --git a/liboctave/chMatrix.cc b/liboctave/chMatrix.cc
--- a/liboctave/chMatrix.cc
+++ b/liboctave/chMatrix.cc
@@ -200,23 +200,23 @@ charMatrix::diag (octave_idx_type k) con
 }
 
 // FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
 boolMatrix
 charMatrix::all (int dim) const
 {
-  return do_mx_red_op<boolMatrix, char> (*this, dim, mx_inline_all);
+  return do_mx_red_op<bool, char> (*this, dim, mx_inline_all);
 }
 
 boolMatrix
 charMatrix::any (int dim) const
 {
-  return do_mx_red_op<boolMatrix, char> (*this, dim, mx_inline_any);
+  return do_mx_red_op<bool, char> (*this, dim, mx_inline_any);
 }
 
 MS_CMP_OPS (charMatrix, char)
 MS_BOOL_OPS (charMatrix, char)
 
 SM_CMP_OPS (char, charMatrix)
 SM_BOOL_OPS (char, charMatrix)
 
diff --git a/liboctave/chNDArray.cc b/liboctave/chNDArray.cc
--- a/liboctave/chNDArray.cc
+++ b/liboctave/chNDArray.cc
@@ -34,23 +34,23 @@ along with Octave; see the file COPYING.
 
 #include "bsxfun-defs.cc"
 
 // FIXME -- this is not quite the right thing.
 
 boolNDArray
 charNDArray::all (int dim) const
 {
-  return do_mx_red_op<boolMatrix, char> (*this, dim, mx_inline_all);
+  return do_mx_red_op<bool, char> (*this, dim, mx_inline_all);
 }
 
 boolNDArray
 charNDArray::any (int dim) const
 {
-  return do_mx_red_op<boolMatrix, char> (*this, dim, mx_inline_any);
+  return do_mx_red_op<bool, char> (*this, dim, mx_inline_any);
 }
 
 charNDArray
 charNDArray::concat (const charNDArray& rb, const Array<octave_idx_type>& ra_idx)
 {
   if (rb.numel () > 0)
     insert (rb, ra_idx);
   return *this;
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -2604,17 +2604,17 @@ Matrix::operator -= (const DiagMatrix& a
   return *this;
 }
 
 // unary operations
 
 boolMatrix
 Matrix::operator ! (void) const
 {
-  return do_mx_unary_op<boolMatrix, Matrix> (*this, mx_inline_not);
+  return do_mx_unary_op<bool, double> (*this, mx_inline_not);
 }
 
 // column vector by row vector -> matrix operations
 
 Matrix
 operator * (const ColumnVector& v, const RowVector& a)
 {
   Matrix retval;
@@ -2775,53 +2775,53 @@ Matrix::too_large_for_float (void) const
 }
 
 // FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
 boolMatrix
 Matrix::all (int dim) const
 {
-  return do_mx_red_op<boolMatrix, double> (*this, dim, mx_inline_all);
+  return do_mx_red_op<bool, double> (*this, dim, mx_inline_all);
 }
 
 boolMatrix
 Matrix::any (int dim) const
 {
-  return do_mx_red_op<boolMatrix, double> (*this, dim, mx_inline_any);
+  return do_mx_red_op<bool, double> (*this, dim, mx_inline_any);
 }
 
 Matrix
 Matrix::cumprod (int dim) const
 {
-  return do_mx_cum_op<Matrix, double> (*this, dim, mx_inline_cumprod);
+  return do_mx_cum_op<double, double> (*this, dim, mx_inline_cumprod);
 }
 
 Matrix
 Matrix::cumsum (int dim) const
 {
-  return do_mx_cum_op<Matrix, double> (*this, dim, mx_inline_cumsum);
+  return do_mx_cum_op<double, double> (*this, dim, mx_inline_cumsum);
 }
 
 Matrix
 Matrix::prod (int dim) const
 {
-  return do_mx_red_op<Matrix, double> (*this, dim, mx_inline_prod);
+  return do_mx_red_op<double, double> (*this, dim, mx_inline_prod);
 }
 
 Matrix
 Matrix::sum (int dim) const
 {
-  return do_mx_red_op<Matrix, double> (*this, dim, mx_inline_sum);
+  return do_mx_red_op<double, double> (*this, dim, mx_inline_sum);
 }
 
 Matrix
 Matrix::sumsq (int dim) const
 {
-  return do_mx_red_op<Matrix, double> (*this, dim, mx_inline_sumsq);
+  return do_mx_red_op<double, double> (*this, dim, mx_inline_sumsq);
 }
 
 Matrix
 Matrix::abs (void) const
 {
   return Matrix (mx_inline_fabs_dup (data (), length ()),
                  rows (), cols ());
 }
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -536,17 +536,17 @@ NDArray::ifourierNd (void) const
 
 #endif
 
 // unary operations
 
 boolNDArray
 NDArray::operator ! (void) const
 {
-  return do_mx_unary_op<boolNDArray, NDArray> (*this, mx_inline_not);
+  return do_mx_unary_op<bool, double> (*this, mx_inline_not);
 }
 
 bool
 NDArray::any_element_is_negative (bool neg_zero) const
 {
   octave_idx_type nel = nelem ();
 
   if (neg_zero)
@@ -701,113 +701,113 @@ NDArray::too_large_for_float (void) cons
   return false;
 }
 
 // FIXME -- this is not quite the right thing.
 
 boolNDArray
 NDArray::all (int dim) const
 {
-  return do_mx_red_op<boolNDArray, double> (*this, dim, mx_inline_all);
+  return do_mx_red_op<bool, double> (*this, dim, mx_inline_all);
 }
 
 boolNDArray
 NDArray::any (int dim) const
 {
-  return do_mx_red_op<boolNDArray, double> (*this, dim, mx_inline_any);
+  return do_mx_red_op<bool, double> (*this, dim, mx_inline_any);
 }
 
 NDArray
 NDArray::cumprod (int dim) const
 {
-  return do_mx_cum_op<NDArray, double> (*this, dim, mx_inline_cumprod);
+  return do_mx_cum_op<double, double> (*this, dim, mx_inline_cumprod);
 }
 
 NDArray
 NDArray::cumsum (int dim) const
 {
-  return do_mx_cum_op<NDArray, double> (*this, dim, mx_inline_cumsum);
+  return do_mx_cum_op<double, double> (*this, dim, mx_inline_cumsum);
 }
 
 NDArray
 NDArray::prod (int dim) const
 {
-  return do_mx_red_op<NDArray, double> (*this, dim, mx_inline_prod);
+  return do_mx_red_op<double, double> (*this, dim, mx_inline_prod);
 }
 
 NDArray
 NDArray::sum (int dim) const
 {
-  return do_mx_red_op<NDArray, double> (*this, dim, mx_inline_sum);
+  return do_mx_red_op<double, double> (*this, dim, mx_inline_sum);
 }
 
 NDArray
 NDArray::xsum (int dim) const
 {
-  return do_mx_red_op<NDArray, double> (*this, dim, mx_inline_xsum);
+  return do_mx_red_op<double, double> (*this, dim, mx_inline_xsum);
 }
 
 NDArray
 NDArray::sumsq (int dim) const
 {
-  return do_mx_red_op<NDArray, double> (*this, dim, mx_inline_sumsq);
+  return do_mx_red_op<double, double> (*this, dim, mx_inline_sumsq);
 }
 
 NDArray
 NDArray::max (int dim) const
 {
-  return do_mx_minmax_op<NDArray> (*this, dim, mx_inline_max);
+  return do_mx_minmax_op<double> (*this, dim, mx_inline_max);
 }
 
 NDArray
 NDArray::max (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_minmax_op<NDArray> (*this, idx_arg, dim, mx_inline_max);
+  return do_mx_minmax_op<double> (*this, idx_arg, dim, mx_inline_max);
 }
 
 NDArray
 NDArray::min (int dim) const
 {
-  return do_mx_minmax_op<NDArray> (*this, dim, mx_inline_min);
+  return do_mx_minmax_op<double> (*this, dim, mx_inline_min);
 }
 
 NDArray
 NDArray::min (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_minmax_op<NDArray> (*this, idx_arg, dim, mx_inline_min);
+  return do_mx_minmax_op<double> (*this, idx_arg, dim, mx_inline_min);
 }
 
 NDArray
 NDArray::cummax (int dim) const
 {
-  return do_mx_cumminmax_op<NDArray> (*this, dim, mx_inline_cummax);
+  return do_mx_cumminmax_op<double> (*this, dim, mx_inline_cummax);
 }
 
 NDArray
 NDArray::cummax (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_cumminmax_op<NDArray> (*this, idx_arg, dim, mx_inline_cummax);
+  return do_mx_cumminmax_op<double> (*this, idx_arg, dim, mx_inline_cummax);
 }
 
 NDArray
 NDArray::cummin (int dim) const
 {
-  return do_mx_cumminmax_op<NDArray> (*this, dim, mx_inline_cummin);
+  return do_mx_cumminmax_op<double> (*this, dim, mx_inline_cummin);
 }
 
 NDArray
 NDArray::cummin (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_cumminmax_op<NDArray> (*this, idx_arg, dim, mx_inline_cummin);
+  return do_mx_cumminmax_op<double> (*this, idx_arg, dim, mx_inline_cummin);
 }
 
 NDArray
 NDArray::diff (octave_idx_type order, int dim) const
 {
-  return do_mx_diff_op<NDArray> (*this, dim, order, mx_inline_diff);
+  return do_mx_diff_op<double> (*this, dim, order, mx_inline_diff);
 }
 
 NDArray
 NDArray::concat (const NDArray& rb, const Array<octave_idx_type>& ra_idx)
 {
   if (rb.numel () > 0)
     insert (rb, ra_idx);
   return *this;
@@ -856,23 +856,23 @@ NDArray::concat (const charNDArray& rb, 
 
   retval.insert (rb, ra_idx);
   return retval;
 }
 
 NDArray
 real (const ComplexNDArray& a)
 {
-  return do_mx_unary_op<NDArray, ComplexNDArray> (a, mx_inline_real);
+  return do_mx_unary_op<double, Complex> (a, mx_inline_real);
 }
 
 NDArray
 imag (const ComplexNDArray& a)
 {
-  return do_mx_unary_op<NDArray, ComplexNDArray> (a, mx_inline_imag);
+  return do_mx_unary_op<double, Complex> (a, mx_inline_imag);
 }
 
 NDArray&
 NDArray::insert (const NDArray& a, octave_idx_type r, octave_idx_type c)
 {
   Array<double>::insert (a, r, c);
   return *this;
 }
@@ -882,35 +882,35 @@ NDArray::insert (const NDArray& a, const
 {
   Array<double>::insert (a, ra_idx);
   return *this;
 }
 
 NDArray
 NDArray::abs (void) const
 {
-  return do_mx_unary_map<NDArray, NDArray, std::abs> (*this);
+  return do_mx_unary_map<double, double, std::abs> (*this);
 }
 
 boolNDArray
 NDArray::isnan (void) const
 {
-  return do_mx_unary_map<boolNDArray, NDArray, xisnan> (*this);
+  return do_mx_unary_map<bool, double, xisnan> (*this);
 }
 
 boolNDArray
 NDArray::isinf (void) const
 {
-  return do_mx_unary_map<boolNDArray, NDArray, xisinf> (*this);
+  return do_mx_unary_map<bool, double, xisinf> (*this);
 }
 
 boolNDArray
 NDArray::isfinite (void) const
 {
-  return do_mx_unary_map<boolNDArray, NDArray, xfinite> (*this);
+  return do_mx_unary_map<bool, double, xfinite> (*this);
 }
 
 Matrix
 NDArray::matrix_value (void) const
 {
   Matrix retval;
 
   if (ndims () == 2)
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -3057,17 +3057,17 @@ FloatComplexMatrix::operator -= (const F
   return *this;
 }
 
 // unary operations
 
 boolMatrix
 FloatComplexMatrix::operator ! (void) const
 {
-  return do_mx_unary_op<boolMatrix, FloatComplexMatrix> (*this, mx_inline_not);
+  return do_mx_unary_op<bool, FloatComplex> (*this, mx_inline_not);
 }
 
 // other operations
 
 bool
 FloatComplexMatrix::any_element_is_nan (void) const
 {
   octave_idx_type nr = rows ();
@@ -3190,53 +3190,53 @@ FloatComplexMatrix::too_large_for_float 
 }
 
 // FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
 boolMatrix
 FloatComplexMatrix::all (int dim) const
 {
-  return do_mx_red_op<boolMatrix, FloatComplex> (*this, dim, mx_inline_all);
+  return do_mx_red_op<bool, FloatComplex> (*this, dim, mx_inline_all);
 }
 
 boolMatrix
 FloatComplexMatrix::any (int dim) const
 {
-  return do_mx_red_op<boolMatrix, FloatComplex> (*this, dim, mx_inline_any);
+  return do_mx_red_op<bool, FloatComplex> (*this, dim, mx_inline_any);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::cumprod (int dim) const
 {
-  return do_mx_cum_op<FloatComplexMatrix, FloatComplex> (*this, dim, mx_inline_cumprod);
+  return do_mx_cum_op<FloatComplex, FloatComplex> (*this, dim, mx_inline_cumprod);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::cumsum (int dim) const
 {
-  return do_mx_cum_op<FloatComplexMatrix, FloatComplex> (*this, dim, mx_inline_cumsum);
+  return do_mx_cum_op<FloatComplex, FloatComplex> (*this, dim, mx_inline_cumsum);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::prod (int dim) const
 {
-  return do_mx_red_op<FloatComplexMatrix, FloatComplex> (*this, dim, mx_inline_prod);
+  return do_mx_red_op<FloatComplex, FloatComplex> (*this, dim, mx_inline_prod);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::sum (int dim) const
 {
-  return do_mx_red_op<FloatComplexMatrix, FloatComplex> (*this, dim, mx_inline_sum);
+  return do_mx_red_op<FloatComplex, FloatComplex> (*this, dim, mx_inline_sum);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::sumsq (int dim) const
 {
-  return do_mx_red_op<FloatMatrix, FloatComplex> (*this, dim, mx_inline_sumsq);
+  return do_mx_red_op<float, FloatComplex> (*this, dim, mx_inline_sumsq);
 }
 
 FloatMatrix FloatComplexMatrix::abs (void) const
 {
   return FloatMatrix (mx_inline_cabs_dup (data (), length ()),
                       rows (), cols ());
 }
 
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -490,17 +490,17 @@ FloatComplexNDArray::ifourierNd (void) c
 
 #endif
 
 // unary operations
 
 boolNDArray
 FloatComplexNDArray::operator ! (void) const
 {
-  return do_mx_unary_op<boolNDArray, FloatComplexNDArray> (*this, mx_inline_not);
+  return do_mx_unary_op<bool, FloatComplex> (*this, mx_inline_not);
 }
 
 // FIXME -- this is not quite the right thing.
 
 bool
 FloatComplexNDArray::any_element_is_nan (void) const
 {
   octave_idx_type nel = nelem ();
@@ -610,65 +610,65 @@ FloatComplexNDArray::too_large_for_float
     }
 
   return false;
 }
 
 boolNDArray
 FloatComplexNDArray::all (int dim) const
 {
-  return do_mx_red_op<boolNDArray, FloatComplex> (*this, dim, mx_inline_all);
+  return do_mx_red_op<bool, FloatComplex> (*this, dim, mx_inline_all);
 }
 
 boolNDArray
 FloatComplexNDArray::any (int dim) const
 {
-  return do_mx_red_op<boolNDArray, FloatComplex> (*this, dim, mx_inline_any);
+  return do_mx_red_op<bool, FloatComplex> (*this, dim, mx_inline_any);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::cumprod (int dim) const
 {
-  return do_mx_cum_op<FloatComplexNDArray, FloatComplex> (*this, dim, mx_inline_cumprod);
+  return do_mx_cum_op<FloatComplex, FloatComplex> (*this, dim, mx_inline_cumprod);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::cumsum (int dim) const
 {
-  return do_mx_cum_op<FloatComplexNDArray, FloatComplex> (*this, dim, mx_inline_cumsum);
+  return do_mx_cum_op<FloatComplex, FloatComplex> (*this, dim, mx_inline_cumsum);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::prod (int dim) const
 {
-  return do_mx_red_op<FloatComplexNDArray, FloatComplex> (*this, dim, mx_inline_prod);
+  return do_mx_red_op<FloatComplex, FloatComplex> (*this, dim, mx_inline_prod);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::sum (int dim) const
 {
-  return do_mx_red_op<FloatComplexNDArray, FloatComplex> (*this, dim, mx_inline_sum);
+  return do_mx_red_op<FloatComplex, FloatComplex> (*this, dim, mx_inline_sum);
 }
 
 ComplexNDArray
 FloatComplexNDArray::dsum (int dim) const
 {
-  return do_mx_red_op<ComplexNDArray, FloatComplex> (*this, dim, mx_inline_dsum);
+  return do_mx_red_op<Complex, FloatComplex> (*this, dim, mx_inline_dsum);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::sumsq (int dim) const
 {
-  return do_mx_red_op<FloatNDArray, FloatComplex> (*this, dim, mx_inline_sumsq);
+  return do_mx_red_op<float, FloatComplex> (*this, dim, mx_inline_sumsq);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::diff (octave_idx_type order, int dim) const
 {
-  return do_mx_diff_op<FloatComplexNDArray> (*this, dim, order, mx_inline_diff);
+  return do_mx_diff_op<FloatComplex> (*this, dim, order, mx_inline_diff);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::concat (const FloatComplexNDArray& rb, const Array<octave_idx_type>& ra_idx)
 {
   if (rb.numel () > 0)
     insert (rb, ra_idx);
   return *this;
@@ -692,89 +692,89 @@ concat (NDArray& ra, FloatComplexNDArray
   return retval;
 }
 
 static const FloatComplex FloatComplex_NaN_result (octave_Float_NaN, octave_Float_NaN);
 
 FloatComplexNDArray
 FloatComplexNDArray::max (int dim) const
 {
-  return do_mx_minmax_op<FloatComplexNDArray> (*this, dim, mx_inline_max);
+  return do_mx_minmax_op<FloatComplex> (*this, dim, mx_inline_max);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::max (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_minmax_op<FloatComplexNDArray> (*this, idx_arg, dim, mx_inline_max);
+  return do_mx_minmax_op<FloatComplex> (*this, idx_arg, dim, mx_inline_max);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::min (int dim) const
 {
-  return do_mx_minmax_op<FloatComplexNDArray> (*this, dim, mx_inline_min);
+  return do_mx_minmax_op<FloatComplex> (*this, dim, mx_inline_min);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::min (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_minmax_op<FloatComplexNDArray> (*this, idx_arg, dim, mx_inline_min);
+  return do_mx_minmax_op<FloatComplex> (*this, idx_arg, dim, mx_inline_min);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::cummax (int dim) const
 {
-  return do_mx_cumminmax_op<FloatComplexNDArray> (*this, dim, mx_inline_cummax);
+  return do_mx_cumminmax_op<FloatComplex> (*this, dim, mx_inline_cummax);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::cummax (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_cumminmax_op<FloatComplexNDArray> (*this, idx_arg, dim, mx_inline_cummax);
+  return do_mx_cumminmax_op<FloatComplex> (*this, idx_arg, dim, mx_inline_cummax);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::cummin (int dim) const
 {
-  return do_mx_cumminmax_op<FloatComplexNDArray> (*this, dim, mx_inline_cummin);
+  return do_mx_cumminmax_op<FloatComplex> (*this, dim, mx_inline_cummin);
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::cummin (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_cumminmax_op<FloatComplexNDArray> (*this, idx_arg, dim, mx_inline_cummin);
+  return do_mx_cumminmax_op<FloatComplex> (*this, idx_arg, dim, mx_inline_cummin);
 }
 
 FloatNDArray
 FloatComplexNDArray::abs (void) const
 {
-  return do_mx_unary_map<FloatNDArray, FloatComplexNDArray, std::abs> (*this);
+  return do_mx_unary_map<float, FloatComplex, std::abs> (*this);
 }
 
 boolNDArray
 FloatComplexNDArray::isnan (void) const
 {
-  return do_mx_unary_map<boolNDArray, FloatComplexNDArray, xisnan> (*this);
+  return do_mx_unary_map<bool, FloatComplex, xisnan> (*this);
 }
 
 boolNDArray
 FloatComplexNDArray::isinf (void) const
 {
-  return do_mx_unary_map<boolNDArray, FloatComplexNDArray, xisinf> (*this);
+  return do_mx_unary_map<bool, FloatComplex, xisinf> (*this);
 }
 
 boolNDArray
 FloatComplexNDArray::isfinite (void) const
 {
-  return do_mx_unary_map<boolNDArray, FloatComplexNDArray, xfinite> (*this);
+  return do_mx_unary_map<bool, FloatComplex, xfinite> (*this);
 }
 
 FloatComplexNDArray
 conj (const FloatComplexNDArray& a)
 {
-  return do_mx_unary_map<FloatComplexNDArray, FloatComplexNDArray, std::conj> (a);
+  return do_mx_unary_map<FloatComplex, FloatComplex, std::conj> (a);
 }
 
 FloatComplexNDArray&
 FloatComplexNDArray::insert (const NDArray& a, octave_idx_type r, octave_idx_type c)
 {
   dim_vector a_dv = a.dims ();
   
   int n = a_dv.length ();
@@ -920,25 +920,25 @@ SND_BOOL_OPS (FloatComplex, FloatComplex
 NDND_CMP_OPS (FloatComplexNDArray, FloatComplexNDArray)
 NDND_BOOL_OPS (FloatComplexNDArray, FloatComplexNDArray)
 
 FloatComplexNDArray& operator *= (FloatComplexNDArray& a, float s)
 {
   if (a.is_shared ())
     a = a * s;
   else
-    do_ms_inplace_op<FloatComplexNDArray, float> (a, s, mx_inline_mul2);
+    do_ms_inplace_op<FloatComplex, float> (a, s, mx_inline_mul2);
   return a;
 }
 
 FloatComplexNDArray& operator /= (FloatComplexNDArray& a, float s)
 {
   if (a.is_shared ())
     a = a / s;
   else
-    do_ms_inplace_op<FloatComplexNDArray, float> (a, s, mx_inline_div2);
+    do_ms_inplace_op<FloatComplex, float> (a, s, mx_inline_div2);
   return a;
 }
 
 BSXFUN_STDOP_DEFS_MXLOOP (FloatComplexNDArray)
 BSXFUN_STDREL_DEFS_MXLOOP (FloatComplexNDArray)
 
 BSXFUN_OP_DEF_MXLOOP (pow, FloatComplexNDArray, mx_inline_pow)
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -2603,17 +2603,17 @@ FloatMatrix::operator -= (const FloatDia
   return *this;
 }
 
 // unary operations
 
 boolMatrix
 FloatMatrix::operator ! (void) const
 {
-  return do_mx_unary_op<boolMatrix, FloatMatrix> (*this, mx_inline_not);
+  return do_mx_unary_op<bool, float> (*this, mx_inline_not);
 }
 
 // column vector by row vector -> matrix operations
 
 FloatMatrix
 operator * (const FloatColumnVector& v, const FloatRowVector& a)
 {
   FloatMatrix retval;
@@ -2774,53 +2774,53 @@ FloatMatrix::too_large_for_float (void) 
 }
 
 // FIXME Do these really belong here?  Maybe they should be
 // in a base class?
 
 boolMatrix
 FloatMatrix::all (int dim) const
 {
-  return do_mx_red_op<boolMatrix, float> (*this, dim, mx_inline_all);
+  return do_mx_red_op<bool, float> (*this, dim, mx_inline_all);
 }
 
 boolMatrix
 FloatMatrix::any (int dim) const
 {
-  return do_mx_red_op<boolMatrix, float> (*this, dim, mx_inline_any);
+  return do_mx_red_op<bool, float> (*this, dim, mx_inline_any);
 }
 
 FloatMatrix
 FloatMatrix::cumprod (int dim) const
 {
-  return do_mx_cum_op<FloatMatrix, float> (*this, dim, mx_inline_cumprod);
+  return do_mx_cum_op<float, float> (*this, dim, mx_inline_cumprod);
 }
 
 FloatMatrix
 FloatMatrix::cumsum (int dim) const
 {
-  return do_mx_cum_op<FloatMatrix, float> (*this, dim, mx_inline_cumsum);
+  return do_mx_cum_op<float, float> (*this, dim, mx_inline_cumsum);
 }
 
 FloatMatrix
 FloatMatrix::prod (int dim) const
 {
-  return do_mx_red_op<FloatMatrix, float> (*this, dim, mx_inline_prod);
+  return do_mx_red_op<float, float> (*this, dim, mx_inline_prod);
 }
 
 FloatMatrix
 FloatMatrix::sum (int dim) const
 {
-  return do_mx_red_op<FloatMatrix, float> (*this, dim, mx_inline_sum);
+  return do_mx_red_op<float, float> (*this, dim, mx_inline_sum);
 }
 
 FloatMatrix
 FloatMatrix::sumsq (int dim) const
 {
-  return do_mx_red_op<FloatMatrix, float> (*this, dim, mx_inline_sumsq);
+  return do_mx_red_op<float, float> (*this, dim, mx_inline_sumsq);
 }
 
 FloatMatrix
 FloatMatrix::abs (void) const
 {
   return FloatMatrix (mx_inline_fabs_dup (data (), length ()),
                       rows (), cols ());
 }
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -494,17 +494,17 @@ FloatNDArray::ifourierNd (void) const
 
 #endif
 
 // unary operations
 
 boolNDArray
 FloatNDArray::operator ! (void) const
 {
-  return do_mx_unary_op<boolNDArray, FloatNDArray> (*this, mx_inline_not);
+  return do_mx_unary_op<bool, float> (*this, mx_inline_not);
 }
 
 bool
 FloatNDArray::any_element_is_negative (bool neg_zero) const
 {
   octave_idx_type nel = nelem ();
 
   if (neg_zero)
@@ -659,113 +659,113 @@ FloatNDArray::too_large_for_float (void)
   return false;
 }
 
 // FIXME -- this is not quite the right thing.
 
 boolNDArray
 FloatNDArray::all (int dim) const
 {
-  return do_mx_red_op<boolNDArray, float> (*this, dim, mx_inline_all);
+  return do_mx_red_op<bool, float> (*this, dim, mx_inline_all);
 }
 
 boolNDArray
 FloatNDArray::any (int dim) const
 {
-  return do_mx_red_op<boolNDArray, float> (*this, dim, mx_inline_any);
+  return do_mx_red_op<bool, float> (*this, dim, mx_inline_any);
 }
 
 FloatNDArray
 FloatNDArray::cumprod (int dim) const
 {
-  return do_mx_cum_op<FloatNDArray, float> (*this, dim, mx_inline_cumprod);
+  return do_mx_cum_op<float, float> (*this, dim, mx_inline_cumprod);
 }
 
 FloatNDArray
 FloatNDArray::cumsum (int dim) const
 {
-  return do_mx_cum_op<FloatNDArray, float> (*this, dim, mx_inline_cumsum);
+  return do_mx_cum_op<float, float> (*this, dim, mx_inline_cumsum);
 }
 
 FloatNDArray
 FloatNDArray::prod (int dim) const
 {
-  return do_mx_red_op<FloatNDArray, float> (*this, dim, mx_inline_prod);
+  return do_mx_red_op<float, float> (*this, dim, mx_inline_prod);
 }
 
 FloatNDArray
 FloatNDArray::sum (int dim) const
 {
-  return do_mx_red_op<FloatNDArray, float> (*this, dim, mx_inline_sum);
+  return do_mx_red_op<float, float> (*this, dim, mx_inline_sum);
 }
 
 NDArray
 FloatNDArray::dsum (int dim) const
 {
-  return do_mx_red_op<NDArray, float> (*this, dim, mx_inline_dsum);
+  return do_mx_red_op<double, float> (*this, dim, mx_inline_dsum);
 }
 
 FloatNDArray
 FloatNDArray::sumsq (int dim) const
 {
-  return do_mx_red_op<FloatNDArray, float> (*this, dim, mx_inline_sumsq);
+  return do_mx_red_op<float, float> (*this, dim, mx_inline_sumsq);
 }
 
 FloatNDArray
 FloatNDArray::max (int dim) const
 {
-  return do_mx_minmax_op<FloatNDArray> (*this, dim, mx_inline_max);
+  return do_mx_minmax_op<float> (*this, dim, mx_inline_max);
 }
 
 FloatNDArray
 FloatNDArray::max (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_minmax_op<FloatNDArray> (*this, idx_arg, dim, mx_inline_max);
+  return do_mx_minmax_op<float> (*this, idx_arg, dim, mx_inline_max);
 }
 
 FloatNDArray
 FloatNDArray::min (int dim) const
 {
-  return do_mx_minmax_op<FloatNDArray> (*this, dim, mx_inline_min);
+  return do_mx_minmax_op<float> (*this, dim, mx_inline_min);
 }
 
 FloatNDArray
 FloatNDArray::min (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_minmax_op<FloatNDArray> (*this, idx_arg, dim, mx_inline_min);
+  return do_mx_minmax_op<float> (*this, idx_arg, dim, mx_inline_min);
 }
 
 FloatNDArray
 FloatNDArray::cummax (int dim) const
 {
-  return do_mx_cumminmax_op<FloatNDArray> (*this, dim, mx_inline_cummax);
+  return do_mx_cumminmax_op<float> (*this, dim, mx_inline_cummax);
 }
 
 FloatNDArray
 FloatNDArray::cummax (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_cumminmax_op<FloatNDArray> (*this, idx_arg, dim, mx_inline_cummax);
+  return do_mx_cumminmax_op<float> (*this, idx_arg, dim, mx_inline_cummax);
 }
 
 FloatNDArray
 FloatNDArray::cummin (int dim) const
 {
-  return do_mx_cumminmax_op<FloatNDArray> (*this, dim, mx_inline_cummin);
+  return do_mx_cumminmax_op<float> (*this, dim, mx_inline_cummin);
 }
 
 FloatNDArray
 FloatNDArray::cummin (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_cumminmax_op<FloatNDArray> (*this, idx_arg, dim, mx_inline_cummin);
+  return do_mx_cumminmax_op<float> (*this, idx_arg, dim, mx_inline_cummin);
 }
 
 FloatNDArray
 FloatNDArray::diff (octave_idx_type order, int dim) const
 {
-  return do_mx_diff_op<FloatNDArray> (*this, dim, order, mx_inline_diff);
+  return do_mx_diff_op<float> (*this, dim, order, mx_inline_diff);
 }
 
 FloatNDArray
 FloatNDArray::concat (const FloatNDArray& rb, const Array<octave_idx_type>& ra_idx)
 {
   if (rb.numel () > 0)
     insert (rb, ra_idx);
   return *this;
@@ -814,23 +814,23 @@ FloatNDArray::concat (const charNDArray&
 
   retval.insert (rb, ra_idx);
   return retval;
 }
 
 FloatNDArray
 real (const FloatComplexNDArray& a)
 {
-  return do_mx_unary_op<FloatNDArray, FloatComplexNDArray> (a, mx_inline_real);
+  return do_mx_unary_op<float, FloatComplex> (a, mx_inline_real);
 }
 
 FloatNDArray
 imag (const FloatComplexNDArray& a)
 {
-  return do_mx_unary_op<FloatNDArray, FloatComplexNDArray> (a, mx_inline_imag);
+  return do_mx_unary_op<float, FloatComplex> (a, mx_inline_imag);
 }
 
 FloatNDArray&
 FloatNDArray::insert (const FloatNDArray& a, octave_idx_type r, octave_idx_type c)
 {
   Array<float>::insert (a, r, c);
   return *this;
 }
@@ -840,35 +840,35 @@ FloatNDArray::insert (const FloatNDArray
 {
   Array<float>::insert (a, ra_idx);
   return *this;
 }
 
 FloatNDArray
 FloatNDArray::abs (void) const
 {
-  return do_mx_unary_map<FloatNDArray, FloatNDArray, std::abs> (*this);
+  return do_mx_unary_map<float, float, std::abs> (*this);
 }
 
 boolNDArray
 FloatNDArray::isnan (void) const
 {
-  return do_mx_unary_map<boolNDArray, FloatNDArray, xisnan> (*this);
+  return do_mx_unary_map<bool, float, xisnan> (*this);
 }
 
 boolNDArray
 FloatNDArray::isinf (void) const
 {
-  return do_mx_unary_map<boolNDArray, FloatNDArray, xisinf> (*this);
+  return do_mx_unary_map<bool, float, xisinf> (*this);
 }
 
 boolNDArray
 FloatNDArray::isfinite (void) const
 {
-  return do_mx_unary_map<boolNDArray, FloatNDArray, xfinite> (*this);
+  return do_mx_unary_map<bool, float, xfinite> (*this);
 }
 
 FloatMatrix
 FloatNDArray::matrix_value (void) const
 {
   FloatMatrix retval;
 
   if (ndims () == 2)
diff --git a/liboctave/intNDArray.cc b/liboctave/intNDArray.cc
--- a/liboctave/intNDArray.cc
+++ b/liboctave/intNDArray.cc
@@ -70,24 +70,24 @@ intNDArray<T>::diag (octave_idx_type k) 
 }
 
 // FIXME -- this is not quite the right thing.
 
 template <class T>
 boolNDArray
 intNDArray<T>::all (int dim) const
 {
-  return do_mx_red_op<boolNDArray, T > (*this, dim, mx_inline_all);
+  return do_mx_red_op<bool, T > (*this, dim, mx_inline_all);
 }
 
 template <class T>
 boolNDArray
 intNDArray<T>::any (int dim) const
 {
-  return do_mx_red_op<boolNDArray, T > (*this, dim, mx_inline_any);
+  return do_mx_red_op<bool, T > (*this, dim, mx_inline_any);
 }
 
 template <class T>
 void
 intNDArray<T>::increment_index (Array<octave_idx_type>& ra_idx,
                                const dim_vector& dimensions,
                                int start_dimension)
 {
@@ -200,87 +200,87 @@ intNDArray<T>::signum (void) const
 
   return ret;
 }
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::sum (int dim) const
 {
-  return do_mx_red_op<intNDArray<T> , T > (*this, dim, mx_inline_sum);
+  return do_mx_red_op<T, T> (*this, dim, mx_inline_sum);
 }
 
 template <class T>
 NDArray
 intNDArray<T>::dsum (int dim) const
 {
-  return do_mx_red_op<NDArray , T> (*this, dim, mx_inline_dsum);
+  return do_mx_red_op<double, T> (*this, dim, mx_inline_dsum);
 }
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::cumsum (int dim) const
 {
-  return do_mx_cum_op<intNDArray<T> , T > (*this, dim, mx_inline_cumsum);
+  return do_mx_cum_op<T, T> (*this, dim, mx_inline_cumsum);
 }
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::max (int dim) const
 {
-  return do_mx_minmax_op<intNDArray<T> > (*this, dim, mx_inline_max);
+  return do_mx_minmax_op<T> (*this, dim, mx_inline_max);
 }
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::max (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_minmax_op<intNDArray<T> > (*this, idx_arg, dim, mx_inline_max);
+  return do_mx_minmax_op<T> (*this, idx_arg, dim, mx_inline_max);
 }
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::min (int dim) const
 {
-  return do_mx_minmax_op<intNDArray<T> > (*this, dim, mx_inline_min);
+  return do_mx_minmax_op<T> (*this, dim, mx_inline_min);
 }
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::min (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_minmax_op<intNDArray<T> > (*this, idx_arg, dim, mx_inline_min);
+  return do_mx_minmax_op<T> (*this, idx_arg, dim, mx_inline_min);
 }
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::cummax (int dim) const
 {
-  return do_mx_cumminmax_op<intNDArray<T> > (*this, dim, mx_inline_cummax);
+  return do_mx_cumminmax_op<T> (*this, dim, mx_inline_cummax);
 }
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::cummax (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_cumminmax_op<intNDArray<T> > (*this, idx_arg, dim, mx_inline_cummax);
+  return do_mx_cumminmax_op<T> (*this, idx_arg, dim, mx_inline_cummax);
 }
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::cummin (int dim) const
 {
-  return do_mx_cumminmax_op<intNDArray<T> > (*this, dim, mx_inline_cummin);
+  return do_mx_cumminmax_op<T> (*this, dim, mx_inline_cummin);
 }
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::cummin (Array<octave_idx_type>& idx_arg, int dim) const
 {
-  return do_mx_cumminmax_op<intNDArray<T> > (*this, idx_arg, dim, mx_inline_cummin);
+  return do_mx_cumminmax_op<T> (*this, idx_arg, dim, mx_inline_cummin);
 }
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::diff (octave_idx_type order, int dim) const
 {
-  return do_mx_diff_op<intNDArray<T> > (*this, dim, order, mx_inline_diff);
+  return do_mx_diff_op<T> (*this, dim, order, mx_inline_diff);
 }
diff --git a/liboctave/mx-inlines.cc b/liboctave/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/mx-inlines.cc
@@ -30,17 +30,17 @@ along with Octave; see the file COPYING.
 #include <cmath>
 #include <memory>
 
 #include "quit.h"
 
 #include "oct-cmplx.h"
 #include "oct-locbuf.h"
 #include "oct-inttypes.h"
-#include "Array-util.h"
+#include "Array.h"
 #include "Array-util.h"
 
 // Provides some commonly repeated, basic loop templates.
 
 template <class R, class S>
 inline void mx_inline_fill (size_t n, R *r, S s)
 { for (size_t i = 0; i < n; i++) r[i] = s; }
 
@@ -293,117 +293,110 @@ inline void mx_inline_map (size_t n, R *
 
 template <class R, class X, R fun (const X& x)>
 inline void mx_inline_map (size_t n, R *r, const X *x)
 { for (size_t i = 0; i < n; i++) r[i] = fun (x[i]); }
 
 // Appliers. Since these call the operation just once, we pass it as
 // a pointer, to allow the compiler reduce number of instances.
 
-#define AELEMT(ARRAY) typename ARRAY::element_type
-template <class RNDA, class XNDA>
-inline RNDA 
-do_mx_unary_op (const XNDA& x,
-                void (*op) (size_t, AELEMT(RNDA) *,
-                            const AELEMT(XNDA) *))
+template <class R, class X>
+inline Array<R> 
+do_mx_unary_op (const Array<X>& x,
+                void (*op) (size_t, R *, const X *))
 {
-  RNDA r (x.dims ());
-  op (r.length (), r.fortran_vec (), x.data ());
+  Array<R> r (x.dims ());
+  op (r.numel (), r.fortran_vec (), x.data ());
   return r;
 }
 
 // Shortcuts for applying mx_inline_map.
 
-template <class RNDA, class XNDA, AELEMT(RNDA) fun (AELEMT(XNDA))>
-inline RNDA 
-do_mx_unary_map (const XNDA& x)
+template <class R, class X, R fun (X)>
+inline Array<R> 
+do_mx_unary_map (const Array<X>& x)
 {
-  return do_mx_unary_op<RNDA, XNDA> (x, mx_inline_map<AELEMT(RNDA), AELEMT(XNDA), fun>);
+  return do_mx_unary_op<R, X> (x, mx_inline_map<R, X, fun>);
 }
 
-template <class RNDA, class XNDA, AELEMT(RNDA) fun (const AELEMT(XNDA)&)>
-inline RNDA 
-do_mx_unary_map (const XNDA& x)
+template <class R, class X, R fun (const X&)>
+inline Array<R> 
+do_mx_unary_map (const Array<X>& x)
 {
-  return do_mx_unary_op<RNDA, XNDA> (x, mx_inline_map<AELEMT(RNDA), AELEMT(XNDA), fun>);
+  return do_mx_unary_op<R, X> (x, mx_inline_map<R, X, fun>);
 }
 
-template <class RNDA>
-inline RNDA&
-do_mx_inplace_op (RNDA& r,
-                  void (*op) (size_t, AELEMT(RNDA) *))
+template <class R>
+inline Array<R>&
+do_mx_inplace_op (Array<R>& r,
+                  void (*op) (size_t, R *))
 {
   op (r.numel (), r.fortran_vec ());
   return r;
 }
 
 
-template <class RNDA, class XNDA, class YNDA>
-inline RNDA 
-do_mm_binary_op (const XNDA& x, const YNDA& y,
-                 void (*op) (size_t, AELEMT(RNDA) *,
-                             const AELEMT(XNDA) *,
-                             const AELEMT(YNDA) *),
+template <class R, class X, class Y>
+inline Array<R> 
+do_mm_binary_op (const Array<X>& x, const Array<Y>& y,
+                 void (*op) (size_t, R *, const X *, const Y *),
                  const char *opname)
 {
   dim_vector dx = x.dims (), dy = y.dims ();
   if (dx == dy)
     {
-      RNDA r (dx);
+      Array<R> r (dx);
       op (r.length (), r.fortran_vec (), x.data (), y.data ());
       return r;
     }
   else
     {
       gripe_nonconformant (opname, dx, dy);
-      return RNDA ();
+      return Array<R> ();
     }
 }
 
-template <class RNDA, class XNDA, class YS>
-inline RNDA 
-do_ms_binary_op (const XNDA& x, const YS& y,
-                 void (*op) (size_t, AELEMT(RNDA) *,
-                             const AELEMT(XNDA) *, YS))
+template <class R, class X, class Y>
+inline Array<R> 
+do_ms_binary_op (const Array<X>& x, const Y& y,
+                 void (*op) (size_t, R *, const X *, Y))
 {
-  RNDA r (x.dims ());
+  Array<R> r (x.dims ());
   op (r.length (), r.fortran_vec (), x.data (), y);
   return r;
 }
 
-template <class RNDA, class XS, class YNDA>
-inline RNDA 
-do_sm_binary_op (const XS& x, const YNDA& y,
-                 void (*op) (size_t, AELEMT(RNDA) *, XS,
-                             const AELEMT(YNDA) *))
+template <class R, class X, class Y>
+inline Array<R> 
+do_sm_binary_op (const X& x, const Array<Y>& y,
+                 void (*op) (size_t, R *, X, const Y *))
 {
-  RNDA r (y.dims ());
+  Array<R> r (y.dims ());
   op (r.length (), r.fortran_vec (), x, y.data ());
   return r;
 }
 
-template <class RNDA, class XNDA>
-inline RNDA& 
-do_mm_inplace_op (RNDA& r, const XNDA& x,
-                  void (*op) (size_t, AELEMT(RNDA) *,
-                              const AELEMT(XNDA) *),
+template <class R, class X>
+inline Array<R>& 
+do_mm_inplace_op (Array<R>& r, const Array<X>& x,
+                  void (*op) (size_t, R *, const X *),
                   const char *opname)
 {
   dim_vector dr = r.dims (), dx = x.dims ();
   if (dr == dx)
     op (r.length (), r.fortran_vec (), x.data ());
   else
     gripe_nonconformant (opname, dr, dx);
   return r;
 }
 
-template <class RNDA, class XS>
-inline RNDA& 
-do_ms_inplace_op (RNDA& r, const XS& x,
-                  void (*op) (size_t, AELEMT(RNDA) *, XS))
+template <class R, class X>
+inline Array<R>& 
+do_ms_inplace_op (Array<R>& r, const X& x,
+                  void (*op) (size_t, R *, X))
 {
   op (r.length (), r.fortran_vec (), x);
   return r;
 }
 
 template <class T1, class T2>
 inline bool
 mx_inline_equal (size_t n, const T1 *x, const T2 *y)
@@ -1177,165 +1170,163 @@ get_extent_triplet (const dim_vector& di
         u *= dims (i);
     }
 }
 
 // Appliers.
 // FIXME: is this the best design? C++ gives a lot of options here...
 // maybe it can be done without an explicit parameter?
 
-template <class ArrayType, class T>
-inline ArrayType
+template <class R, class T>
+inline Array<R>
 do_mx_red_op (const Array<T>& src, int dim,
-              void (*mx_red_op) (const T *, AELEMT(ArrayType) *,
-                                 octave_idx_type, octave_idx_type, octave_idx_type))
+              void (*mx_red_op) (const T *, R *, octave_idx_type, 
+                                 octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
   // M*b inconsistency: sum([]) = 0 etc.
   if (dims.length () == 2 && dims(0) == 0 && dims(1) == 0)
     dims (1) = 1;
 
   get_extent_triplet (dims, dim, l, n, u);
 
   // Reduction operation reduces the array size.
   if (dim < dims.length ()) dims(dim) = 1;
   dims.chop_trailing_singletons ();
 
-  ArrayType ret (dims);
+  Array<R> ret (dims);
   mx_red_op (src.data (), ret.fortran_vec (), l, n, u);
 
   return ret;
 }
 
-template <class ArrayType, class T>
-inline ArrayType
+template <class R, class T>
+inline Array<R>
 do_mx_cum_op (const Array<T>& src, int dim,
-              void (*mx_cum_op) (const T *, AELEMT(ArrayType) *,
-                                 octave_idx_type, octave_idx_type, octave_idx_type))
+              void (*mx_cum_op) (const T *, R *, octave_idx_type, 
+                                 octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
   get_extent_triplet (dims, dim, l, n, u);
 
   // Cumulative operation doesn't reduce the array size.
-  ArrayType ret (dims);
+  Array<R> ret (dims);
   mx_cum_op (src.data (), ret.fortran_vec (), l, n, u);
 
   return ret;
 }
 
-template <class ArrayType>
-inline ArrayType
-do_mx_minmax_op (const ArrayType& src, int dim,
-                 void (*mx_minmax_op) (const AELEMT(ArrayType) *, AELEMT(ArrayType) *,
+template <class R>
+inline Array<R>
+do_mx_minmax_op (const Array<R>& src, int dim,
+                 void (*mx_minmax_op) (const R *, R *, octave_idx_type, 
+                                       octave_idx_type, octave_idx_type))
+{
+  octave_idx_type l, n, u;
+  dim_vector dims = src.dims ();
+  get_extent_triplet (dims, dim, l, n, u);
+
+  // If the dimension is zero, we don't do anything.
+  if (dim < dims.length () && dims(dim) != 0) dims(dim) = 1;
+  dims.chop_trailing_singletons ();
+
+  Array<R> ret (dims);
+  mx_minmax_op (src.data (), ret.fortran_vec (), l, n, u);
+
+  return ret;
+}
+
+template <class R>
+inline Array<R>
+do_mx_minmax_op (const Array<R>& src, Array<octave_idx_type>& idx, int dim,
+                 void (*mx_minmax_op) (const R *, R *, octave_idx_type *,
                                        octave_idx_type, octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
   get_extent_triplet (dims, dim, l, n, u);
 
   // If the dimension is zero, we don't do anything.
   if (dim < dims.length () && dims(dim) != 0) dims(dim) = 1;
   dims.chop_trailing_singletons ();
 
-  ArrayType ret (dims);
-  mx_minmax_op (src.data (), ret.fortran_vec (), l, n, u);
-
-  return ret;
-}
-
-template <class ArrayType>
-inline ArrayType
-do_mx_minmax_op (const ArrayType& src, Array<octave_idx_type>& idx, int dim,
-                 void (*mx_minmax_op) (const AELEMT(ArrayType) *, AELEMT(ArrayType) *,
-                                       octave_idx_type *,
-                                       octave_idx_type, octave_idx_type, octave_idx_type))
-{
-  octave_idx_type l, n, u;
-  dim_vector dims = src.dims ();
-  get_extent_triplet (dims, dim, l, n, u);
-
-  // If the dimension is zero, we don't do anything.
-  if (dim < dims.length () && dims(dim) != 0) dims(dim) = 1;
-  dims.chop_trailing_singletons ();
-
-  ArrayType ret (dims);
+  Array<R> ret (dims);
   if (idx.dims () != dims) idx = Array<octave_idx_type> (dims);
 
   mx_minmax_op (src.data (), ret.fortran_vec (), idx.fortran_vec (),
                 l, n, u);
 
   return ret;
 }
 
-template <class ArrayType>
-inline ArrayType
-do_mx_cumminmax_op (const ArrayType& src, int dim,
-                    void (*mx_cumminmax_op) (const AELEMT(ArrayType) *, AELEMT(ArrayType) *,
+template <class R>
+inline Array<R>
+do_mx_cumminmax_op (const Array<R>& src, int dim,
+                    void (*mx_cumminmax_op) (const R *, R *, octave_idx_type, 
+                                             octave_idx_type, octave_idx_type))
+{
+  octave_idx_type l, n, u;
+  dim_vector dims = src.dims ();
+  get_extent_triplet (dims, dim, l, n, u);
+
+  Array<R> ret (dims);
+  mx_cumminmax_op (src.data (), ret.fortran_vec (), l, n, u);
+
+  return ret;
+}
+
+template <class R>
+inline Array<R>
+do_mx_cumminmax_op (const Array<R>& src, Array<octave_idx_type>& idx, int dim,
+                    void (*mx_cumminmax_op) (const R *, R *, octave_idx_type *,
                                              octave_idx_type, octave_idx_type, octave_idx_type))
 {
   octave_idx_type l, n, u;
   dim_vector dims = src.dims ();
   get_extent_triplet (dims, dim, l, n, u);
 
-  ArrayType ret (dims);
-  mx_cumminmax_op (src.data (), ret.fortran_vec (), l, n, u);
-
-  return ret;
-}
-
-template <class ArrayType>
-inline ArrayType
-do_mx_cumminmax_op (const ArrayType& src, Array<octave_idx_type>& idx, int dim,
-                    void (*mx_cumminmax_op) (const AELEMT(ArrayType) *, AELEMT(ArrayType) *,
-                                             octave_idx_type *,
-                                             octave_idx_type, octave_idx_type, octave_idx_type))
-{
-  octave_idx_type l, n, u;
-  dim_vector dims = src.dims ();
-  get_extent_triplet (dims, dim, l, n, u);
-
-  ArrayType ret (dims);
+  Array<R> ret (dims);
   if (idx.dims () != dims) idx = Array<octave_idx_type> (dims);
 
   mx_cumminmax_op (src.data (), ret.fortran_vec (), idx.fortran_vec (),
                    l, n, u);
 
   return ret;
 }
 
-template <class ArrayType>
-inline ArrayType
-do_mx_diff_op (const ArrayType& src, int dim, octave_idx_type order,
-               void (*mx_diff_op) (const AELEMT(ArrayType) *, AELEMT(ArrayType) *,
+template <class R>
+inline Array<R>
+do_mx_diff_op (const Array<R>& src, int dim, octave_idx_type order,
+               void (*mx_diff_op) (const R *, R *,
                                    octave_idx_type, octave_idx_type, octave_idx_type,
                                    octave_idx_type))
 {
   octave_idx_type l, n, u;
   if (order <= 0)
     return src;
 
   dim_vector dims = src.dims ();
 
   get_extent_triplet (dims, dim, l, n, u);
   if (dim >= dims.length ())
     dims.resize (dim+1, 1);
 
   if (dims(dim) <= order)
     {
       dims (dim) = 0;
-      return ArrayType (dims);
+      return Array<R> (dims);
     }
   else
     {
       dims(dim) -= order;
     }
 
-  ArrayType ret (dims);
+  Array<R> ret (dims);
   mx_diff_op (src.data (), ret.fortran_vec (), l, n, u, order);
 
   return ret;
 }
 
 // Fast extra-precise summation. According to
 // T. Ogita, S. M. Rump, S. Oishi:
 // Accurate Sum And Dot Product,
diff --git a/liboctave/mx-op-defs.h b/liboctave/mx-op-defs.h
--- a/liboctave/mx-op-defs.h
+++ b/liboctave/mx-op-defs.h
@@ -30,303 +30,303 @@ along with Octave; see the file COPYING.
 #include "mx-inlines.cc"
 
 // vector by scalar operations.
 
 #define VS_BIN_OP(R, F, OP, V, S) \
   R \
   F (const V& v, const S& s) \
   { \
-    return do_ms_binary_op<R, V, S> (v, s, OP); \
+    return do_ms_binary_op<R::element_type, V::element_type, S> (v, s, OP); \
   }
 
 #define VS_BIN_OPS(R, V, S) \
   VS_BIN_OP (R, operator +, mx_inline_add, V, S) \
   VS_BIN_OP (R, operator -, mx_inline_sub, V, S) \
   VS_BIN_OP (R, operator *, mx_inline_mul, V, S) \
   VS_BIN_OP (R, operator /, mx_inline_div, V, S)
 
 // scalar by vector by operations.
 
 #define SV_BIN_OP(R, F, OP, S, V) \
   R \
   F (const S& s, const V& v) \
   { \
-    return do_sm_binary_op<R, S, V> (s, v, OP); \
+    return do_sm_binary_op<R::element_type, S, V::element_type> (s, v, OP); \
   }
 
 #define SV_BIN_OPS(R, S, V) \
   SV_BIN_OP (R, operator +, mx_inline_add, S, V) \
   SV_BIN_OP (R, operator -, mx_inline_sub, S, V) \
   SV_BIN_OP (R, operator *, mx_inline_mul, S, V) \
   SV_BIN_OP (R, operator /, mx_inline_div, S, V)
 
 // vector by vector operations.
 
 #define VV_BIN_OP(R, F, OP, V1, V2) \
   R \
   F (const V1& v1, const V2& v2) \
   { \
-    return do_mm_binary_op<R, V1, V2> (v1, v2, OP, #F); \
+    return do_mm_binary_op<R::element_type, V1::element_type, V2::element_type> (v1, v2, OP, #F); \
   }
 
 #define VV_BIN_OPS(R, V1, V2) \
   VV_BIN_OP (R, operator +, mx_inline_add, V1, V2) \
   VV_BIN_OP (R, operator -, mx_inline_sub, V1, V2) \
   VV_BIN_OP (R, product,    mx_inline_mul, V1, V2) \
   VV_BIN_OP (R, quotient,   mx_inline_div, V1, V2)
 
 // matrix by scalar operations.
 
 #define MS_BIN_OP(R, OP, M, S, F) \
   R \
   OP (const M& m, const S& s) \
   { \
-    return do_ms_binary_op<R, M, S> (m, s, F); \
+    return do_ms_binary_op<R::element_type, M::element_type, S> (m, s, F); \
   }
 
 #define MS_BIN_OPS(R, M, S) \
   MS_BIN_OP (R, operator +, M, S, mx_inline_add) \
   MS_BIN_OP (R, operator -, M, S, mx_inline_sub) \
   MS_BIN_OP (R, operator *, M, S, mx_inline_mul) \
   MS_BIN_OP (R, operator /, M, S, mx_inline_div)
 
 #define MS_CMP_OP(F, OP, M, S) \
   boolMatrix \
   F (const M& m, const S& s) \
   { \
-    return do_ms_binary_op<boolMatrix, M, S> (m, s, OP); \
+    return do_ms_binary_op<bool, M::element_type, S> (m, s, OP); \
   }
 
 #define MS_CMP_OPS(M, S) \
   MS_CMP_OP (mx_el_lt, mx_inline_lt, M, S) \
   MS_CMP_OP (mx_el_le, mx_inline_le, M, S) \
   MS_CMP_OP (mx_el_ge, mx_inline_ge, M, S) \
   MS_CMP_OP (mx_el_gt, mx_inline_gt, M, S) \
   MS_CMP_OP (mx_el_eq, mx_inline_eq, M, S) \
   MS_CMP_OP (mx_el_ne, mx_inline_ne, M, S)
 
 #define MS_BOOL_OP(F, OP, M, S) \
   boolMatrix \
   F (const M& m, const S& s) \
   { \
-    return do_ms_binary_op<boolMatrix, M, S> (m, s, OP); \
+    return do_ms_binary_op<bool, M::element_type, S> (m, s, OP); \
   }
 
 #define MS_BOOL_OPS(M, S) \
   MS_BOOL_OP (mx_el_and, mx_inline_and, M, S) \
   MS_BOOL_OP (mx_el_or,  mx_inline_or,  M, S)
 
 // scalar by matrix operations.
 
 #define SM_BIN_OP(R, OP, S, M, F) \
   R \
   OP (const S& s, const M& m) \
   { \
-    return do_sm_binary_op<R, S, M> (s, m, F); \
+    return do_sm_binary_op<R::element_type, S, M::element_type> (s, m, F); \
   }
 
 #define SM_BIN_OPS(R, S, M) \
   SM_BIN_OP (R, operator +, S, M, mx_inline_add) \
   SM_BIN_OP (R, operator -, S, M, mx_inline_sub) \
   SM_BIN_OP (R, operator *, S, M, mx_inline_mul) \
   SM_BIN_OP (R, operator /, S, M, mx_inline_div)
 
 #define SM_CMP_OP(F, OP, S, M) \
   boolMatrix \
   F (const S& s, const M& m) \
   { \
-    return do_sm_binary_op<boolMatrix, S, M> (s, m, OP); \
+    return do_sm_binary_op<bool, S, M::element_type> (s, m, OP); \
   }
 
 #define SM_CMP_OPS(S, M) \
   SM_CMP_OP (mx_el_lt, mx_inline_lt, S, M) \
   SM_CMP_OP (mx_el_le, mx_inline_le, S, M) \
   SM_CMP_OP (mx_el_ge, mx_inline_ge, S, M) \
   SM_CMP_OP (mx_el_gt, mx_inline_gt, S, M) \
   SM_CMP_OP (mx_el_eq, mx_inline_eq, S, M) \
   SM_CMP_OP (mx_el_ne, mx_inline_ne, S, M)
 
 #define SM_BOOL_OP(F, OP, S, M) \
   boolMatrix \
   F (const S& s, const M& m) \
   { \
-    return do_sm_binary_op<boolMatrix, S, M> (s, m, OP); \
+    return do_sm_binary_op<bool, S, M::element_type> (s, m, OP); \
   }
 
 #define SM_BOOL_OPS(S, M) \
   SM_BOOL_OP (mx_el_and, mx_inline_and, S, M) \
   SM_BOOL_OP (mx_el_or,  mx_inline_or,  S, M)
 
 // matrix by matrix operations.
 
 #define MM_BIN_OP(R, OP, M1, M2, F) \
   R \
   OP (const M1& m1, const M2& m2) \
   { \
-    return do_mm_binary_op<R, M1, M2> (m1, m2, F, #OP); \
+    return do_mm_binary_op<R::element_type, M1::element_type, M2::element_type> (m1, m2, F, #OP); \
   }
 
 #define MM_BIN_OPS(R, M1, M2) \
   MM_BIN_OP (R, operator +, M1, M2, mx_inline_add) \
   MM_BIN_OP (R, operator -, M1, M2, mx_inline_sub) \
   MM_BIN_OP (R, product,    M1, M2, mx_inline_mul) \
   MM_BIN_OP (R, quotient,   M1, M2, mx_inline_div)
 
 #define MM_CMP_OP(F, OP, M1, M2) \
   boolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
-    return do_mm_binary_op<boolMatrix, M1, M2> (m1, m2, OP, #F); \
+    return do_mm_binary_op<bool, M1::element_type, M2::element_type> (m1, m2, OP, #F); \
   }
 
 #define MM_CMP_OPS(M1, M2) \
   MM_CMP_OP (mx_el_lt, mx_inline_lt, M1, M2) \
   MM_CMP_OP (mx_el_le, mx_inline_le, M1, M2) \
   MM_CMP_OP (mx_el_ge, mx_inline_ge, M1, M2) \
   MM_CMP_OP (mx_el_gt, mx_inline_gt, M1, M2) \
   MM_CMP_OP (mx_el_eq, mx_inline_eq, M1, M2) \
   MM_CMP_OP (mx_el_ne, mx_inline_ne, M1, M2)
 
 #define MM_BOOL_OP(F, OP, M1, M2) \
   boolMatrix \
   F (const M1& m1, const M2& m2) \
   { \
-    return do_mm_binary_op<boolMatrix, M1, M2> (m1, m2, OP, #F); \
+    return do_mm_binary_op<bool, M1::element_type, M2::element_type> (m1, m2, OP, #F); \
   }
 
 #define MM_BOOL_OPS(M1, M2) \
   MM_BOOL_OP (mx_el_and, mx_inline_and, M1, M2) \
   MM_BOOL_OP (mx_el_or,  mx_inline_or,  M1, M2)
 
 // N-d matrix by scalar operations.
 
 #define NDS_BIN_OP(R, OP, ND, S, F) \
   R \
   OP (const ND& m, const S& s) \
   { \
-    return do_ms_binary_op<R, ND, S> (m, s, F); \
+    return do_ms_binary_op<R::element_type, ND::element_type, S> (m, s, F); \
   }
 
 #define NDS_BIN_OPS(R, ND, S) \
   NDS_BIN_OP (R, operator +, ND, S, mx_inline_add) \
   NDS_BIN_OP (R, operator -, ND, S, mx_inline_sub) \
   NDS_BIN_OP (R, operator *, ND, S, mx_inline_mul) \
   NDS_BIN_OP (R, operator /, ND, S, mx_inline_div)
 
 #define NDS_CMP_OP(F, OP, ND, S) \
   boolNDArray \
   F (const ND& m, const S& s) \
   { \
-    return do_ms_binary_op<boolNDArray, ND, S> (m, s, OP); \
+    return do_ms_binary_op<bool, ND::element_type, S> (m, s, OP); \
   }
 
 #define NDS_CMP_OPS(ND, S) \
   NDS_CMP_OP (mx_el_lt, mx_inline_lt, ND, S) \
   NDS_CMP_OP (mx_el_le, mx_inline_le, ND, S) \
   NDS_CMP_OP (mx_el_ge, mx_inline_ge, ND, S) \
   NDS_CMP_OP (mx_el_gt, mx_inline_gt, ND, S) \
   NDS_CMP_OP (mx_el_eq, mx_inline_eq, ND, S) \
   NDS_CMP_OP (mx_el_ne, mx_inline_ne, ND, S)
 
 #define NDS_BOOL_OP(F, OP, ND, S) \
   boolNDArray \
   F (const ND& m, const S& s) \
   { \
-    return do_ms_binary_op<boolNDArray, ND, S> (m, s, OP); \
+    return do_ms_binary_op<bool, ND::element_type, S> (m, s, OP); \
   }
 
 #define NDS_BOOL_OPS(ND, S) \
   NDS_BOOL_OP (mx_el_and,     mx_inline_and,     ND, S) \
   NDS_BOOL_OP (mx_el_or,      mx_inline_or,      ND, S) \
   NDS_BOOL_OP (mx_el_not_and, mx_inline_not_and, ND, S) \
   NDS_BOOL_OP (mx_el_not_or,  mx_inline_not_or,  ND, S) \
   NDS_BOOL_OP (mx_el_and_not, mx_inline_and_not, ND, S) \
   NDS_BOOL_OP (mx_el_or_not,  mx_inline_or_not,  ND, S)
 
 // scalar by N-d matrix operations.
 
 #define SND_BIN_OP(R, OP, S, ND, F) \
   R \
   OP (const S& s, const ND& m) \
   { \
-    return do_sm_binary_op<R, S, ND> (s, m, F); \
+    return do_sm_binary_op<R::element_type, S, ND::element_type> (s, m, F); \
   }
 
 #define SND_BIN_OPS(R, S, ND) \
   SND_BIN_OP (R, operator +, S, ND, mx_inline_add) \
   SND_BIN_OP (R, operator -, S, ND, mx_inline_sub) \
   SND_BIN_OP (R, operator *, S, ND, mx_inline_mul) \
   SND_BIN_OP (R, operator /, S, ND, mx_inline_div)
 
 #define SND_CMP_OP(F, OP, S, ND) \
   boolNDArray \
   F (const S& s, const ND& m) \
   { \
-    return do_sm_binary_op<boolNDArray, S, ND> (s, m, OP); \
+    return do_sm_binary_op<bool, S, ND::element_type> (s, m, OP); \
   }
 
 #define SND_CMP_OPS(S, ND) \
   SND_CMP_OP (mx_el_lt, mx_inline_lt, S, ND) \
   SND_CMP_OP (mx_el_le, mx_inline_le, S, ND) \
   SND_CMP_OP (mx_el_ge, mx_inline_ge, S, ND) \
   SND_CMP_OP (mx_el_gt, mx_inline_gt, S, ND) \
   SND_CMP_OP (mx_el_eq, mx_inline_eq, S, ND) \
   SND_CMP_OP (mx_el_ne, mx_inline_ne, S, ND)
 
 #define SND_BOOL_OP(F, OP, S, ND) \
   boolNDArray \
   F (const S& s, const ND& m) \
   { \
-    return do_sm_binary_op<boolNDArray, S, ND> (s, m, OP); \
+    return do_sm_binary_op<bool, S, ND::element_type> (s, m, OP); \
   }
 
 #define SND_BOOL_OPS(S, ND) \
   SND_BOOL_OP (mx_el_and,     mx_inline_and,     S, ND) \
   SND_BOOL_OP (mx_el_or,      mx_inline_or,      S, ND) \
   SND_BOOL_OP (mx_el_not_and, mx_inline_not_and, S, ND) \
   SND_BOOL_OP (mx_el_not_or,  mx_inline_not_or,  S, ND) \
   SND_BOOL_OP (mx_el_and_not, mx_inline_and_not, S, ND) \
   SND_BOOL_OP (mx_el_or_not,  mx_inline_or_not,  S, ND)
 
 // N-d matrix by N-d matrix operations.
 
 #define NDND_BIN_OP(R, OP, ND1, ND2, F) \
   R \
   OP (const ND1& m1, const ND2& m2) \
   { \
-    return do_mm_binary_op<R, ND1, ND2> (m1, m2, F, #OP); \
+    return do_mm_binary_op<R::element_type, ND1::element_type, ND2::element_type> (m1, m2, F, #OP); \
   }
 
 #define NDND_BIN_OPS(R, ND1, ND2) \
   NDND_BIN_OP (R, operator +, ND1, ND2, mx_inline_add) \
   NDND_BIN_OP (R, operator -, ND1, ND2, mx_inline_sub) \
   NDND_BIN_OP (R, product,    ND1, ND2, mx_inline_mul) \
   NDND_BIN_OP (R, quotient,   ND1, ND2, mx_inline_div)
 
 #define NDND_CMP_OP(F, OP, ND1, ND2) \
   boolNDArray \
   F (const ND1& m1, const ND2& m2) \
   { \
-    return do_mm_binary_op<boolNDArray, ND1, ND2> (m1, m2, OP, #F); \
+    return do_mm_binary_op<bool, ND1::element_type, ND2::element_type> (m1, m2, OP, #F); \
   }
 
 #define NDND_CMP_OPS(ND1, ND2) \
   NDND_CMP_OP (mx_el_lt, mx_inline_lt, ND1, ND2) \
   NDND_CMP_OP (mx_el_le, mx_inline_le, ND1, ND2) \
   NDND_CMP_OP (mx_el_ge, mx_inline_ge, ND1, ND2) \
   NDND_CMP_OP (mx_el_gt, mx_inline_gt, ND1, ND2) \
   NDND_CMP_OP (mx_el_eq, mx_inline_eq, ND1, ND2) \
   NDND_CMP_OP (mx_el_ne, mx_inline_ne, ND1, ND2)
 
 #define NDND_BOOL_OP(F, OP, ND1, ND2) \
   boolNDArray \
   F (const ND1& m1, const ND2& m2) \
   { \
-    return do_mm_binary_op<boolNDArray, ND1, ND2> (m1, m2, OP, #F); \
+    return do_mm_binary_op<bool, ND1::element_type, ND2::element_type> (m1, m2, OP, #F); \
   }
 
 #define NDND_BOOL_OPS(ND1, ND2) \
   NDND_BOOL_OP (mx_el_and,     mx_inline_and,     ND1, ND2) \
   NDND_BOOL_OP (mx_el_or,      mx_inline_or,      ND1, ND2) \
   NDND_BOOL_OP (mx_el_not_and, mx_inline_not_and, ND1, ND2) \
   NDND_BOOL_OP (mx_el_not_or,  mx_inline_not_or,  ND1, ND2) \
   NDND_BOOL_OP (mx_el_and_not, mx_inline_and_not, ND1, ND2) \
@@ -545,31 +545,31 @@ operator * (const DM& dm, const M& m) \
   DMDM_BIN_OP (R, product,    DM1, DM2, mx_inline_mul)
 
 // scalar by N-d array min/max ops
 
 #define SND_MINMAX_FCN(FCN, OP, T, S) \
 T \
 FCN (S d, const T& m) \
 { \
-  return do_sm_binary_op<T, S, T> (d, m, mx_inline_x##FCN); \
+  return do_sm_binary_op<T::element_type, S, T::element_type> (d, m, mx_inline_x##FCN); \
 }
 
 #define NDS_MINMAX_FCN(FCN, OP, T, S) \
 T \
 FCN (const T& m, S d) \
 { \
-  return do_ms_binary_op<T, T, S> (m, d, mx_inline_x##FCN); \
+  return do_ms_binary_op<T::element_type, T::element_type, S> (m, d, mx_inline_x##FCN); \
 }
 
 #define NDND_MINMAX_FCN(FCN, OP, T, S) \
 T \
 FCN (const T& a, const T& b) \
 { \
-  return do_mm_binary_op<T, T, T> (a, b, mx_inline_x##FCN, #FCN); \
+  return do_mm_binary_op<T::element_type, T::element_type, T::element_type> (a, b, mx_inline_x##FCN, #FCN); \
 }
 
 #define MINMAX_FCNS(T, S) \
   SND_MINMAX_FCN (min, <, T, S) \
   NDS_MINMAX_FCN (min, <, T, S) \
   NDND_MINMAX_FCN (min, <, T, S) \
   SND_MINMAX_FCN (max, >, T, S) \
   NDS_MINMAX_FCN (max, >, T, S) \
