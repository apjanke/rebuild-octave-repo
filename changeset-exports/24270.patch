# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1510886627 18000
#      Thu Nov 16 21:43:47 2017 -0500
# Node ID bc3819b7cca197d16e960aaa9c01df70cef67f23
# Parent  f494b87d2a93b7a0042ddcaa7320197622c66270
don't use symbol_table:: nesting for symbol_record, symbol_scope, or fcn_info

Change all uses of symbol_table::symbol_record to symbol_record.
Change all uses of symbol_table::scope to symbol_scope.
Change all uses of symbol_table::fcn_info to fcn_info.

diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -2532,27 +2532,27 @@ main_window::save_workspace_callback (co
   Fsave (ovl (file));
 }
 
 void
 main_window::load_workspace_callback (const std::string& file)
 {
   Fload (ovl (file));
 
-  octave::symbol_table::scope *scope
+  octave::symbol_scope *scope
    = octave::__get_current_scope__ ("main_window::load_workspace_callback");
 
   if (scope)
     octave_link::set_workspace (true, scope->workspace_info ());
 }
 
 void
 main_window::rename_variable_callback (const main_window::name_pair& names)
 {
-  octave::symbol_table::scope *scope
+  octave::symbol_scope *scope
     = octave::__get_current_scope__ ("main_window::rename_variable_callback");
 
   if (scope)
     {
       scope->rename (names.first, names.second);
 
       octave_link::set_workspace (true, scope->workspace_info ());
     }
@@ -2708,17 +2708,17 @@ main_window::configure_shortcuts (void)
                                   "main_news:release_notes");
   shortcut_manager::set_shortcut (m_current_news_action,
                                   "main_news:community_news");
 }
 
 void
 main_window::force_refresh_workspace (void)
 {
-  octave::symbol_table::scope *scope
+  octave::symbol_scope *scope
    = octave::__get_current_scope__ ("main_window::load_workspace_callback");
 
   if (scope)
     octave_link::set_workspace (true, scope->workspace_info (), false);
 }
 
 QList<octave_dock_widget *>
 main_window::dock_widget_list (void)
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -404,17 +404,17 @@ void
 workspace_view::handle_contextmenu_copy_value (void)
 {
   QModelIndex index = m_view->currentIndex ();
 
   if (index.isValid ())
     {
       QString var_name = get_var_name (index);
 
-      octave::symbol_table::scope *scope
+      octave::symbol_scope *scope
         = octave::__get_current_scope__ ("workspace_view::handle_contextmenu_copy_value");
 
       octave_value val = scope ? scope->varval (var_name.toStdString ()) : 0;
       std::ostringstream buf;
       val.print_raw (buf, true);
 
       QClipboard *clipboard = QApplication::clipboard ();
       clipboard->setText (QString::fromStdString (buf.str ()));
diff --git a/libinterp/corefcn/call-stack.cc b/libinterp/corefcn/call-stack.cc
--- a/libinterp/corefcn/call-stack.cc
+++ b/libinterp/corefcn/call-stack.cc
@@ -356,17 +356,17 @@ namespace octave
   call_stack::push (octave_function *fcn)
   {
     symbol_table& symtab = m_interpreter.get_symbol_table ();
 
     push (fcn, symtab.current_scope (), symtab.current_context ());
   }
 
   void
-  call_stack::push (octave_function *fcn, symbol_table::scope *scope,
+  call_stack::push (octave_function *fcn, symbol_scope *scope,
                     symbol_table::context_id context)
   {
     size_t prev_frame = curr_frame;
     curr_frame = cs.size ();
     cs.push_back (stack_frame (fcn, scope, context, prev_frame));
 
     symbol_table& symtab = m_interpreter.get_symbol_table ();
 
diff --git a/libinterp/corefcn/call-stack.h b/libinterp/corefcn/call-stack.h
--- a/libinterp/corefcn/call-stack.h
+++ b/libinterp/corefcn/call-stack.h
@@ -47,17 +47,17 @@ namespace octave
 
     class stack_frame
     {
     public:
 
       friend class call_stack;
 
       stack_frame (octave_function *fcn = nullptr,
-                   symbol_table::scope *scope = nullptr,
+                   symbol_scope *scope = nullptr,
                    symbol_table::context_id context = 0, size_t prev = 0)
         : m_fcn (fcn), m_line (-1), m_column (-1), m_scope (scope),
           m_context (context), m_prev (prev)
       { }
 
       stack_frame (const stack_frame& elt)
         : m_fcn (elt.m_fcn), m_line (elt.m_line), m_column (elt.m_column),
           m_scope (elt.m_scope), m_context (elt.m_context), m_prev (elt.m_prev)
@@ -73,17 +73,17 @@ namespace octave
 
       bool operator == (const stack_frame& rhs) const;
 
     private:
 
       octave_function *m_fcn;
       int m_line;
       int m_column;
-      symbol_table::scope *m_scope;
+      symbol_scope *m_scope;
       symbol_table::context_id m_context;
       size_t m_prev;
     };
 
     typedef std::deque<stack_frame>::iterator iterator;
     typedef std::deque<stack_frame>::const_iterator const_iterator;
 
     typedef std::deque<stack_frame>::reverse_iterator reverse_iterator;
@@ -119,17 +119,17 @@ namespace octave
     }
 
     size_t current_frame (void) const { return curr_frame; }
 
     size_t size (void) const { return cs.size (); }
 
     size_t num_user_code_frames (octave_idx_type& curr_user_frame) const;
 
-    symbol_table::scope *current_scope (void) const
+    symbol_scope *current_scope (void) const
     {
       return (curr_frame > 0 && curr_frame < cs.size ()
               ? cs[curr_frame].m_scope : nullptr);
     }
 
     symbol_table::context_id current_context (void) const
     {
       return (curr_frame > 0 && curr_frame < cs.size ()
@@ -168,25 +168,25 @@ namespace octave
 
     // Column number in current function that we are debugging.
     int debug_user_code_column (void) const;
 
     // Return TRUE if all elements on the call stack are scripts.
     bool all_scripts (void) const;
 
     void push (octave_function *fcn);
-    void push (octave_function *fcn, symbol_table::scope *scope,
+    void push (octave_function *fcn, symbol_scope *scope,
                symbol_table::context_id context);
 
     void push (void)
     {
       push (nullptr);
     }
 
-    void push (symbol_table::scope *scope, symbol_table::context_id context)
+    void push (symbol_scope *scope, symbol_table::context_id context)
     {
       push (nullptr, scope, context);
     }
 
     void set_location (int l, int c)
     {
       if (! cs.empty ())
         {
diff --git a/libinterp/corefcn/error.cc b/libinterp/corefcn/error.cc
--- a/libinterp/corefcn/error.cc
+++ b/libinterp/corefcn/error.cc
@@ -1563,17 +1563,17 @@ disable escape sequence expansion use a 
           else
             old_warning_options = octave_map (warning_query (arg2));
 
           octave::symbol_table& symtab = interp.get_symbol_table ();
 
           if (nargin == 3 && argv[3] == "local"
               && ! symtab.at_top_level ())
             {
-              octave::symbol_table::scope *scope
+              octave::symbol_scope *scope
                 = symtab.require_current_scope ("warning");
 
               octave_scalar_map val = warning_query (arg2);
 
               octave_value curr_state = val.contents ("state");
 
               // FIXME: this might be better with a dictionary object.
 
diff --git a/libinterp/corefcn/help.cc b/libinterp/corefcn/help.cc
--- a/libinterp/corefcn/help.cc
+++ b/libinterp/corefcn/help.cc
@@ -489,17 +489,17 @@ namespace octave
     octave_user_code *curr_fcn = cs.caller_user_code ();
 
     if (! curr_fcn)
       return retval;
 
     // All subfunctions are listed in the top-level function of this file.
     while (curr_fcn->is_subfunction ())
       {
-        symbol_table::scope *pscope = curr_fcn->parent_fcn_scope ();
+        symbol_scope *pscope = curr_fcn->parent_fcn_scope ();
         curr_fcn = pscope->function ();
       }
 
     // Get subfunctions.
     const std::list<std::string> names = curr_fcn->subfunction_names ();
 
     size_t sz = names.size ();
     retval.resize (sz);
diff --git a/libinterp/corefcn/interpreter-private.cc b/libinterp/corefcn/interpreter-private.cc
--- a/libinterp/corefcn/interpreter-private.cc
+++ b/libinterp/corefcn/interpreter-private.cc
@@ -74,26 +74,26 @@ namespace octave
 
   symbol_table& __get_symbol_table__ (const std::string& who)
   {
     interpreter& interp = __get_interpreter__ (who);
 
     return interp.get_symbol_table ();
   }
 
-  symbol_table::scope *__get_current_scope__ (const std::string& who)
+  symbol_scope *__get_current_scope__ (const std::string& who)
   {
     interpreter& interp = __get_interpreter__ (who);
 
     return interp.get_current_scope ();
   }
 
-  symbol_table::scope *__require_current_scope__ (const std::string& who)
+  symbol_scope *__require_current_scope__ (const std::string& who)
   {
-    symbol_table::scope *scope = __get_current_scope__ (who);
+    symbol_scope *scope = __get_current_scope__ (who);
 
     if (! scope)
       error ("%s: symbol table scope missing", who.c_str ());
 
     return scope;
   }
 
   tree_evaluator& __get_evaluator__ (const std::string& who)
diff --git a/libinterp/corefcn/interpreter-private.h b/libinterp/corefcn/interpreter-private.h
--- a/libinterp/corefcn/interpreter-private.h
+++ b/libinterp/corefcn/interpreter-private.h
@@ -46,19 +46,19 @@ namespace octave
   extern dynamic_loader& __get_dynamic_loader__ (const std::string& who);
 
   extern help_system& __get_help_system__ (const std::string& who);
 
   extern load_path& __get_load_path__ (const std::string& who);
 
   extern symbol_table& __get_symbol_table__ (const std::string& who);
 
-  extern symbol_table::scope *__get_current_scope__ (const std::string& who);
+  extern symbol_scope *__get_current_scope__ (const std::string& who);
 
-  extern symbol_table::scope *
+  extern symbol_scope *
   __require_current_scope__ (const std::string& who);
 
   extern tree_evaluator& __get_evaluator__ (const std::string& who);
 
   extern call_stack& __get_call_stack__ (const std::string& who);
 
   extern cdef_manager& __get_cdef_manager__ (const std::string& who);
 
diff --git a/libinterp/corefcn/interpreter.cc b/libinterp/corefcn/interpreter.cc
--- a/libinterp/corefcn/interpreter.cc
+++ b/libinterp/corefcn/interpreter.cc
@@ -534,17 +534,17 @@ namespace octave
   interpreter::~interpreter (void)
   {
     cleanup ();
   }
 
   void interpreter::intern_nargin (octave_idx_type nargs)
   {
     // FIXME: should this explicitly be top_scope?
-    symbol_table::scope *scope = m_symbol_table.current_scope ();
+    symbol_scope *scope = m_symbol_table.current_scope ();
 
     if (scope)
       {
         scope->assign (".nargin.", nargs);
         scope->mark_hidden (".nargin.");
       }
   }
 
@@ -1172,26 +1172,26 @@ namespace octave
     return m_stream_list;
   }
 
   url_handle_manager& interpreter::get_url_handle_manager (void)
   {
     return m_url_handle_manager;
   }
 
-  symbol_table::scope *
+  symbol_scope *
   interpreter::get_current_scope (void)
   {
     return m_symbol_table.current_scope ();
   }
 
-  symbol_table::scope *
+  symbol_scope *
   interpreter::require_current_scope (const std::string& who)
   {
-    symbol_table::scope *scope = get_current_scope ();
+    symbol_scope *scope = get_current_scope ();
 
     if (! scope)
       error ("%s: symbol table scope missing", who.c_str ());
 
     return scope;
   }
 
   call_stack& interpreter::get_call_stack (void)
diff --git a/libinterp/corefcn/interpreter.h b/libinterp/corefcn/interpreter.h
--- a/libinterp/corefcn/interpreter.h
+++ b/libinterp/corefcn/interpreter.h
@@ -162,18 +162,18 @@ namespace octave
       return m_load_path;
     }
 
     symbol_table& get_symbol_table (void)
     {
       return m_symbol_table;
     }
 
-    symbol_table::scope * get_current_scope (void);
-    symbol_table::scope * require_current_scope (const std::string& who);
+    symbol_scope * get_current_scope (void);
+    symbol_scope * require_current_scope (const std::string& who);
 
     call_stack& get_call_stack (void);
 
     profiler& get_profiler (void);
 
     tree_evaluator& get_evaluator (void);
 
     stream_list& get_stream_list (void);
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -116,17 +116,17 @@ strip_trailing_separators (const std::st
 static std::string
 find_private_file (const std::string& fname)
 {
   std::string retval;
 
   // Look in private directory corresponding to current function (if
   // any).
 
-  octave::symbol_table::scope *scope = octave::__get_current_scope__ ("find_private_file");
+  octave::symbol_scope *scope = octave::__get_current_scope__ ("find_private_file");
 
   octave_user_function *curr_fcn = scope ? scope->function () : nullptr;
 
   if (curr_fcn)
     {
       // Even for private functions, dir_name doesn't contain the
       // "private" directory component so we append it here in all
       // cases.
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -143,17 +143,17 @@ err_file_open (const std::string& fcn, c
 static void
 install_loaded_variable (const std::string& name,
                          const octave_value& val,
                          bool global, const std::string& /*doc*/)
 {
   octave::symbol_table& symtab
     = octave::__get_symbol_table__ ("install_loaded_varaible");
 
-  octave::symbol_table::scope *scope
+  octave::symbol_scope *scope
     = symtab.require_current_scope ("install_loaded_variable");
 
   if (global)
     {
       scope->clear_variable (name);
       scope->mark_global (name);
       symtab.global_assign (name, val);
     }
@@ -954,17 +954,17 @@ do_save (std::ostream& os, const octave_
       err_unrecognized_data_fmt ("save");
       break;
     }
 }
 
 // Save the info from SR on stream OS in the format specified by FMT.
 
 void
-do_save (std::ostream& os, const octave::symbol_table::symbol_record& sr,
+do_save (std::ostream& os, const octave::symbol_record& sr,
          load_save_format fmt, bool save_as_floats)
 {
   octave_value val = sr.varval ();
 
   if (val.is_defined ())
     {
       std::string name = sr.name ();
       std::string help;
@@ -1006,17 +1006,17 @@ save_fields (std::ostream& os, const oct
 // format specified by FMT.
 
 static size_t
 save_vars (std::ostream& os, const std::string& pattern,
            load_save_format fmt, bool save_as_floats)
 {
   octave::symbol_table& symtab = octave::__get_symbol_table__ ("save_vars");
 
-  std::list<octave::symbol_table::symbol_record> vars = symtab.glob (pattern);
+  std::list<octave::symbol_record> vars = symtab.glob (pattern);
 
   size_t saved = 0;
 
   for (const auto& var : vars)
     {
       do_save (os, var, fmt, save_as_floats);
 
       saved++;
@@ -1273,17 +1273,17 @@ save_vars (const string_vector& argv, in
     }
   else if (argv[argv_idx] == "-struct")
     {
       if (++argv_idx >= argc)
         error ("save: missing struct name");
 
       std::string struct_name = argv[argv_idx];
 
-      octave::symbol_table::scope *scope = octave::__get_current_scope__ ("save_vars");
+      octave::symbol_scope *scope = octave::__get_current_scope__ ("save_vars");
 
       octave_value struct_var;
 
       if (scope)
         {
           if (! scope->is_variable (struct_name))
             error ("save: no such variable: '%s'", struct_name.c_str ());
 
@@ -1327,19 +1327,19 @@ save_vars (const string_vector& argv, in
 static void
 dump_octave_core (std::ostream& os, const char *fname, load_save_format fmt,
                   bool save_as_floats)
 {
   write_header (os, fmt);
 
   octave::symbol_table& symtab = octave::__get_symbol_table__ ("dump_octave_core");
 
-  octave::symbol_table::scope *top_scope = symtab.top_scope ();
+  octave::symbol_scope *top_scope = symtab.top_scope ();
 
-  std::list<octave::symbol_table::symbol_record> vars = top_scope->all_variables ();
+  std::list<octave::symbol_record> vars = top_scope->all_variables ();
 
   double save_mem_size = 0;
 
   for (const auto& var : vars)
     {
       octave_value val = var.varval ();
 
       if (val.is_defined ())
diff --git a/libinterp/corefcn/load-save.h b/libinterp/corefcn/load-save.h
--- a/libinterp/corefcn/load-save.h
+++ b/libinterp/corefcn/load-save.h
@@ -81,17 +81,17 @@ extern octave_value
 do_load (std::istream& stream, const std::string& orig_fname,
          load_save_format format, octave::mach_info::float_format flt_fmt,
          bool list_only, bool swap, bool verbose,
          const string_vector& argv, int argv_idx, int argc, int nargout);
 
 extern OCTINTERP_API bool is_octave_data_file (const std::string& file);
 
 extern void
-do_save (std::ostream& os, const octave::symbol_table::symbol_record& sr,
+do_save (std::ostream& os, const octave::symbol_record& sr,
          load_save_format fmt, bool save_as_floats);
 
 extern void
 write_header (std::ostream& os, load_save_format format);
 
 extern void octave_prepare_hdf5 (void);
 
 extern void octave_finalize_hdf5 (void);
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -971,17 +971,17 @@ read_mat5_binary_element (std::istream& 
             octave::unwind_protect_safe frame;
 
             // Set up temporary scope to use for evaluating the text
             // that defines the anonymous function.
 
             octave::symbol_table& symtab
               = octave::__get_symbol_table__ ("read_mat5_binary_element");
 
-            octave::symbol_table::scope local_scope;
+            octave::symbol_scope local_scope;
 
             symtab.set_scope (&local_scope);
 
             octave::call_stack& cs
               = octave::__get_call_stack__ ("read_mat5_binary_element");
             cs.push (&local_scope, 0);
             frame.add_method (cs, &octave::call_stack::pop);
 
diff --git a/libinterp/corefcn/mex.cc b/libinterp/corefcn/mex.cc
--- a/libinterp/corefcn/mex.cc
+++ b/libinterp/corefcn/mex.cc
@@ -3471,17 +3471,17 @@ mexGetVariable (const char *space, const
               octave::call_stack& cs
                 = octave::__get_call_stack__ ("mexGetVariable");
 
               cs.goto_base_frame ();
 
               frame.add_method (cs, &octave::call_stack::pop);
             }
 
-          octave::symbol_table::scope *scope
+          octave::symbol_scope *scope
             = octave::__require_current_scope__ ("mexGetVariable");
 
           val = scope->varval (name);
         }
       else
         mexErrMsgTxt ("mexGetVariable: symbol table does not exist");
     }
 
@@ -3542,17 +3542,17 @@ mexPutVariable (const char *space, const
               octave::call_stack& cs
                 = octave::__get_call_stack__ ("mexPutVariable");
 
               cs.goto_base_frame ();
 
               frame.add_method (cs, &octave::call_stack::pop);
             }
 
-          octave::symbol_table::scope *scope
+          octave::symbol_scope *scope
             = octave::__require_current_scope__ ("mexPutVariable");
 
           scope->assign (name, mxArray::as_octave_value (ptr));
         }
       else
         mexErrMsgTxt ("mexPutVariable: symbol table does not exist");
     }
 
diff --git a/libinterp/corefcn/oct-lvalue.h b/libinterp/corefcn/oct-lvalue.h
--- a/libinterp/corefcn/oct-lvalue.h
+++ b/libinterp/corefcn/oct-lvalue.h
@@ -33,18 +33,18 @@ class octave_value_list;
 #include "ovl.h"
 #include "symtab.h"
 
 class
 octave_lvalue
 {
 public:
 
-  octave_lvalue (const octave::symbol_table::symbol_record& s
-                   = octave::symbol_table::symbol_record ())
+  octave_lvalue (const octave::symbol_record& s
+                   = octave::symbol_record ())
     : sym (s), black_hole (false), type (), idx (), nel (1)
   { }
 
   octave_lvalue (const octave_lvalue& vr)
     : sym (vr.sym), black_hole (vr.black_hole), type (vr.type), idx (vr.idx), nel (vr.nel)
   { }
 
   octave_lvalue& operator = (const octave_lvalue& vr)
@@ -96,17 +96,17 @@ public:
   bool index_is_empty (void) const;
 
   void do_unary_op (octave_value::unary_op op);
 
   octave_value value (void) const;
 
 private:
 
-  octave::symbol_table::symbol_record sym;
+  octave::symbol_record sym;
 
   bool black_hole;
 
   std::string type;
 
   std::list<octave_value_list> idx;
 
   octave_idx_type nel;
diff --git a/libinterp/corefcn/octave-link.cc b/libinterp/corefcn/octave-link.cc
--- a/libinterp/corefcn/octave-link.cc
+++ b/libinterp/corefcn/octave-link.cc
@@ -66,17 +66,17 @@ void
 octave_link::set_workspace (void)
 {
   if (enabled ())
     {
       octave::symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_link::set_workspace");
 
       std::list<workspace_element> workspace_info;
-      octave::symbol_table::scope *scope = symtab.current_scope ();
+      octave::symbol_scope *scope = symtab.current_scope ();
       if (scope)
         workspace_info = scope->workspace_info ();
 
       instance->do_set_workspace (symtab.at_top_level (),
                                   instance->debugging, workspace_info);
     }
 }
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -199,17 +199,17 @@ get_struct_elts (const std::string& text
 
 static inline bool
 is_variable (octave::symbol_table& symtab, const std::string& name)
 {
   bool retval = false;
 
   if (! name.empty ())
     {
-      octave::symbol_table::scope *scope = symtab.current_scope ();
+      octave::symbol_scope *scope = symtab.current_scope ();
 
       octave_value val = scope ? scope->varval (name) : octave_value ();
 
       retval = val.is_defined ();
     }
 
   return retval;
 }
@@ -323,17 +323,17 @@ static octave_value
 do_isglobal (octave::symbol_table& symtab, const octave_value_list& args)
 {
   if (args.length () != 1)
     print_usage ();
 
   if (! args(0).is_string ())
     error ("isglobal: NAME must be a string");
 
-  octave::symbol_table::scope *scope = symtab.current_scope ();
+  octave::symbol_scope *scope = symtab.current_scope ();
 
   std::string name = args(0).string_value ();
 
   return scope && scope->is_global (name);
 }
 
 DEFMETHOD (isglobal, interp, args, ,
            doc: /* -*- texinfo -*-
@@ -384,17 +384,17 @@ symbol_exist (octave::interpreter& inter
   if (! (search_any || search_var || search_dir || search_file ||
          search_builtin || search_class))
     error (R"(exist: unrecognized type argument "%s")", type.c_str ());
 
   octave::symbol_table& symtab = interp.get_symbol_table ();
 
   if (search_any || search_var)
     {
-      octave::symbol_table::scope *scope = symtab.current_scope ();
+      octave::symbol_scope *scope = symtab.current_scope ();
 
       octave_value val = scope ? scope->varval (name) : octave_value ();
 
       if (val.is_constant () || val.isobject ()
           || val.is_function_handle ()
           || val.is_anonymous_function ()
           || val.is_inline_function ())
         return 1;
@@ -1125,17 +1125,17 @@ get_dims_str (const octave_value& val)
 }
 
 class
 symbol_info_list
 {
 private:
   struct symbol_info
   {
-    symbol_info (const octave::symbol_table::symbol_record& sr,
+    symbol_info (const octave::symbol_record& sr,
                  const std::string& expr_str = "",
                  const octave_value& expr_val = octave_value ())
       : name (expr_str.empty () ? sr.name () : expr_str),
         varval (),
         is_automatic (sr.is_automatic ()),
         is_complex (varval.iscomplex ()),
         is_formal (sr.is_formal ()),
         is_global (sr.is_global ()),
@@ -1289,22 +1289,22 @@ public:
     if (this != &sil)
       lst = sil.lst;
 
     return *this;
   }
 
   ~symbol_info_list (void) = default;
 
-  void append (const octave::symbol_table::symbol_record& sr)
+  void append (const octave::symbol_record& sr)
   {
     lst.push_back (symbol_info (sr));
   }
 
-  void append (const octave::symbol_table::symbol_record& sr,
+  void append (const octave::symbol_record& sr,
                const std::string& expr_str,
                const octave_value& expr_val)
   {
     lst.push_back (symbol_info (sr, expr_str, expr_val));
   }
 
   size_t size (void) const { return lst.size (); }
 
@@ -1645,17 +1645,17 @@ do_who (octave::interpreter& interp, int
                    my_name.c_str ());
 
           std::string nm = argv[i + 1];
 
           octave::unwind_protect frame;
 
           // Set up temporary scope.
 
-          octave::symbol_table::scope tmp_scope;
+          octave::symbol_scope tmp_scope;
 
           symtab.set_scope (&tmp_scope);
 
           cs.push (&tmp_scope, 0);
           frame.add_method (cs, &octave::call_stack::pop);
 
           octave::feval ("load", octave_value (nm), 0);
 
@@ -1688,25 +1688,25 @@ do_who (octave::interpreter& interp, int
     {
       pats.resize (++npats);
       pats[0] = "*";
     }
 
   symbol_info_list symbol_stats;
   std::list<std::string> symbol_names;
 
-  octave::symbol_table::scope *scope = symtab.current_scope ();
+  octave::symbol_scope *scope = symtab.current_scope ();
 
   for (int j = 0; j < npats; j++)
     {
       std::string pat = pats[j];
 
       if (have_regexp)
         {
-          std::list<octave::symbol_table::symbol_record> tmp
+          std::list<octave::symbol_record> tmp
             = (global_only
                ? symtab.regexp_global_variables (pat)
                : symtab.regexp_variables (pat));
 
           for (const auto& symrec : tmp)
             {
               if (symrec.is_variable ())
                 {
@@ -1731,34 +1731,34 @@ do_who (octave::interpreter& interp, int
                   // no way of looking up the base value in the global
                   // scope and then evaluating the arguments in the
                   // current scope.
 
                   std::string base_name = pat.substr (0, pos);
 
                   if (scope && scope->is_variable (base_name))
                     {
-                      octave::symbol_table::symbol_record sr
+                      octave::symbol_record sr
                         = symtab.find_symbol (base_name);
 
                       if (! global_only || sr.is_global ())
                         {
                           int parse_status;
 
                           octave_value expr_val
                             = octave::eval_string (pat, true, parse_status);
 
                           symbol_stats.append (sr, pat, expr_val);
                         }
                     }
                 }
             }
           else
             {
-              std::list<octave::symbol_table::symbol_record> tmp
+              std::list<octave::symbol_record> tmp
                 = (global_only
                    ? symtab.glob_global_variables (pat)
                    : symtab.glob_variables (pat));
 
               for (const auto& symrec : tmp)
                 {
                   if (symrec.is_variable ())
                     {
@@ -2095,17 +2095,17 @@ do_clear_functions (octave::symbol_table
     }
 }
 
 static void
 do_clear_globals (octave::symbol_table& symtab,
                   const string_vector& argv, int argc, int idx,
                   bool exclusive = false)
 {
-  octave::symbol_table::scope *scope = symtab.current_scope ();
+  octave::symbol_scope *scope = symtab.current_scope ();
 
   if (! scope)
     return;
 
   if (idx == argc)
     {
       string_vector gvars = symtab.global_variable_names ();
 
@@ -2138,17 +2138,17 @@ do_clear_globals (octave::symbol_table& 
     }
 }
 
 static void
 do_clear_variables (octave::symbol_table& symtab,
                     const string_vector& argv, int argc, int idx,
                     bool exclusive = false, bool have_regexp = false)
 {
-  octave::symbol_table::scope *scope = symtab.current_scope ();
+  octave::symbol_scope *scope = symtab.current_scope ();
 
   if (! scope)
     return;
 
   if (idx == argc)
     scope->clear_variables ();
   else
     {
@@ -2180,17 +2180,17 @@ do_clear_variables (octave::symbol_table
 
 static void
 do_clear_symbols (octave::symbol_table& symtab,
                   const string_vector& argv, int argc, int idx,
                   bool exclusive = false)
 {
   if (idx == argc)
     {
-      octave::symbol_table::scope *scope = symtab.current_scope ();
+      octave::symbol_scope *scope = symtab.current_scope ();
 
       if (scope)
         scope->clear_variables ();
     }
   else
     {
       if (exclusive)
         {
@@ -2211,17 +2211,17 @@ do_clear_symbols (octave::symbol_table& 
 }
 
 static void
 do_matlab_compatible_clear (octave::symbol_table& symtab,
                             const string_vector& argv, int argc, int idx)
 {
   // This is supposed to be mostly Matlab compatible.
 
-  octave::symbol_table::scope *scope = symtab.current_scope ();
+  octave::symbol_scope *scope = symtab.current_scope ();
 
   if (! scope)
     return;
 
   for (; idx < argc; idx++)
     {
       if (argv[idx] == "all"
           && ! scope->is_local_variable ("all"))
@@ -2360,17 +2360,17 @@ without the dash as well.
       bool clear_functions = false;
       bool clear_globals = false;
       bool clear_variables = false;
       bool clear_objects = false;
       bool exclusive = false;
       bool have_regexp = false;
       bool have_dash_option = false;
 
-      octave::symbol_table::scope *scope = symtab.current_scope ();
+      octave::symbol_scope *scope = symtab.current_scope ();
 
       while (++idx < argc)
         {
           if (argv[idx] == "-all" || argv[idx] == "-a")
             {
               CLEAR_OPTION_ERROR (have_dash_option && ! exclusive);
 
               have_dash_option = true;
@@ -2600,17 +2600,17 @@ DEFMETHOD (__varval__, interp, args, ,
 Return the value of the variable @var{name} directly from the symbol table.
 @end deftypefn */)
 {
   if (args.length () != 1)
     print_usage ();
 
   std::string name = args(0).xstring_value ("__varval__: first argument must be a variable name");
 
-  octave::symbol_table::scope *scope = interp.get_current_scope ();
+  octave::symbol_scope *scope = interp.get_current_scope ();
 
   return scope ? scope->varval (args(0).string_value ()) : octave_value ();
 }
 
 static std::string Vmissing_component_hook;
 
 DEFUN (missing_component_hook, args, nargout,
        doc: /* -*- texinfo -*-
@@ -2691,17 +2691,17 @@ clear_function (const std::string& nm)
   octave::symbol_table& symtab = octave::__get_symbol_table__ ("clear_function");
 
   symtab.clear_function (nm);
 }
 
 void
 clear_variable (const std::string& nm)
 {
-  octave::symbol_table::scope *scope
+  octave::symbol_scope *scope
     = octave::__get_current_scope__ ("clear_variable");
 
   if (scope)
     scope->clear_variable (nm);
 }
 
 void
 clear_symbol (const std::string& nm)
@@ -2709,17 +2709,17 @@ clear_symbol (const std::string& nm)
   octave::symbol_table& symtab = octave::__get_symbol_table__ ("clear_symbol");
 
   symtab.clear_symbol (nm);
 }
 
 octave_value
 lookup_function_handle (const std::string& nm)
 {
-  octave::symbol_table::scope *scope
+  octave::symbol_scope *scope
     = octave::__get_current_scope__ ("lookup_function_handle");
 
   octave_value val = scope ? scope->varval (nm) : octave_value ();
 
   return val.is_function_handle () ? val : octave_value ();
 }
 
 octave_value
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -1108,17 +1108,17 @@ public:
         if (! is_direct_superclass (cls, ctx))
           error ("`%s' is not a direct superclass of `%s'",
                  cname.c_str (), ctx.get_name ().c_str ());
 
         if (! is_constructed_object (mname))
           error ("cannot call superclass constructor with variable `%s'",
                  mname.c_str ());
 
-        octave::symbol_table::scope *scope
+        octave::symbol_scope *scope
           = octave::__require_current_scope__ ("octave_classdef_superclass_ref::call");
 
         octave_value sym = scope->varval (mname);
 
         cls.run_constructor (to_cdef_ref (sym), idx);
 
         retval(0) = sym;
       }
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -81,17 +81,17 @@ const std::string octave_fcn_handle::ano
 octave_fcn_handle::octave_fcn_handle (const octave_value& f,
                                       const std::string& n)
   : fcn (f), nm (n), has_overloads (false)
 {
   octave_user_function *uf = fcn.user_function_value (true);
 
   if (uf && nm != anonymous)
     {
-      octave::symbol_table::scope *uf_scope = uf->scope ();
+      octave::symbol_scope *uf_scope = uf->scope ();
 
       if (uf_scope)
         uf_scope->cache_name (nm);
     }
 
   if (uf && uf->is_nested_function () && ! uf->is_subfunction ())
     error ("handles to nested functions are not yet supported");
 }
@@ -344,20 +344,20 @@ octave_fcn_handle::save_ascii (std::ostr
       os << nm << "\n";
 
       print_raw (os, true);
       os << "\n";
 
       if (fcn.is_undefined ())
         return false;
 
-      std::list<octave::symbol_table::symbol_record> vars;
+      std::list<octave::symbol_record> vars;
 
       octave_user_function *f = fcn.user_function_value ();
-      octave::symbol_table::scope *f_scope = f->scope ();
+      octave::symbol_scope *f_scope = f->scope ();
       if (f_scope)
         vars = f_scope->all_variables ();
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           os << "# length: " << varlen << "\n";
@@ -401,17 +401,17 @@ octave_fcn_handle::parse_anon_fcn_handle
       if (fh)
         {
           fcn = fh->fcn;
 
           octave_user_function *uf = fcn.user_function_value (true);
 
           if (uf)
             {
-              octave::symbol_table::scope *uf_scope = uf->scope ();
+              octave::symbol_scope *uf_scope = uf->scope ();
 
               if (uf_scope)
                 uf_scope->cache_name (nm);
             }
         }
       else
         success = false;
     }
@@ -463,17 +463,17 @@ octave_fcn_handle::load_ascii (std::istr
       octave::unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       octave::symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_fcn_handle::load_ascii");
 
-      octave::symbol_table::scope local_scope;
+      octave::symbol_scope local_scope;
 
       symtab.set_scope (&local_scope);
 
       octave::call_stack& cs
         = octave::__get_call_stack__ ("octave_fcn_handle::load_ascii");
 
       cs.push (&local_scope, 0);
       frame.add_method (cs, &octave::call_stack::pop);
@@ -521,20 +521,20 @@ octave_fcn_handle::save_binary (std::ost
 {
   if (nm == anonymous)
     {
       std::ostringstream nmbuf;
 
       if (fcn.is_undefined ())
         return false;
 
-      std::list<octave::symbol_table::symbol_record> vars;
+      std::list<octave::symbol_record> vars;
 
       octave_user_function *f = fcn.user_function_value ();
-      octave::symbol_table::scope *f_scope = f->scope ();
+      octave::symbol_scope *f_scope = f->scope ();
       if (f_scope)
         vars = f_scope->all_variables ();
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         nmbuf << nm << ' ' << varlen;
       else
@@ -629,17 +629,17 @@ octave_fcn_handle::load_binary (std::ist
       octave::unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       octave::symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_fcn_handle::load_binary");
 
-      octave::symbol_table::scope local_scope;
+      octave::symbol_scope local_scope;
 
       symtab.set_scope (&local_scope);
 
       octave::call_stack& cs
         = octave::__get_call_stack__ ("octave_fcn_handle::load_binary");
 
       cs.push (&local_scope, 0);
       frame.add_method (cs, &octave::call_stack::pop);
@@ -777,20 +777,20 @@ octave_fcn_handle::save_hdf5 (octave_hdf
           H5Sclose (space_hid);
           H5Tclose (type_hid);
           H5Gclose (group_hid);
           return false;
         }
 
       H5Dclose (data_hid);
 
-      std::list<octave::symbol_table::symbol_record> vars;
+      std::list<octave::symbol_record> vars;
 
       octave_user_function *f = fcn.user_function_value ();
-      octave::symbol_table::scope *f_scope = f->scope ();
+      octave::symbol_scope *f_scope = f->scope ();
       if (f_scope)
         vars = f_scope->all_variables ();
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           hid_t as_id = H5Screate (H5S_SCALAR);
@@ -1131,17 +1131,17 @@ octave_fcn_handle::load_hdf5 (octave_hdf
       octave::unwind_protect_safe frame;
 
       // Set up temporary scope to use for evaluating the text that
       // defines the anonymous function.
 
       octave::symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_fcn_handle::load_hdf5");
 
-      octave::symbol_table::scope local_scope;
+      octave::symbol_scope local_scope;
 
       symtab.set_scope (&local_scope);
 
       octave::call_stack& cs
         = octave::__get_call_stack__ ("octave_fcn_handle::load_hdf5");
 
       cs.push (&local_scope, 0);
       frame.add_method (cs, &octave::call_stack::pop);
@@ -1750,20 +1750,20 @@ particular output format.
     }
 
   std::string nm = fcn->fcn_file_name ();
 
   if (fh_nm == octave_fcn_handle::anonymous)
     {
       m.setfield ("file", nm);
 
-      std::list<octave::symbol_table::symbol_record> vars;
+      std::list<octave::symbol_record> vars;
 
       octave_user_function *fu = fh->user_function_value ();
-      octave::symbol_table::scope *fu_scope = fu->scope ();
+      octave::symbol_scope *fu_scope = fu->scope ();
       if (fu_scope)
         vars = fu_scope->all_variables ();
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           octave_scalar_map ws;
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -99,17 +99,17 @@ octave_fcn_inline::octave_fcn_inline (co
             {
               octave::call_stack& cs
                 = octave::__get_call_stack__ ("octave_fcn_inline");
 
               octave_function *curr_fcn = cs.current ();
 
               if (curr_fcn)
                 {
-                  octave::symbol_table::scope *parent_scope
+                  octave::symbol_scope *parent_scope
                     = curr_fcn->parent_fcn_scope ();
 
                   if (! parent_scope)
                     parent_scope = curr_fcn->scope ();
 
                   uf->stash_parent_fcn_scope (parent_scope);
                 }
             }
diff --git a/libinterp/octave-value/ov-fcn.h b/libinterp/octave-value/ov-fcn.h
--- a/libinterp/octave-value/ov-fcn.h
+++ b/libinterp/octave-value/ov-fcn.h
@@ -75,22 +75,22 @@ public:
 
   virtual std::string src_file_name (void) const { return ""; }
 
   // The name to show in the profiler (also used as map-key).
   virtual std::string profiler_name (void) const { return name (); }
 
   virtual std::string parent_fcn_name (void) const { return ""; }
 
-  virtual octave::symbol_table::scope * parent_fcn_scope (void) const
+  virtual octave::symbol_scope * parent_fcn_scope (void) const
   { return nullptr; }
 
   virtual void mark_fcn_file_up_to_date (const octave::sys::time&) { }
 
-  virtual octave::symbol_table::scope * scope (void) { return nullptr; }
+  virtual octave::symbol_scope * scope (void) { return nullptr; }
 
   virtual octave::sys::time time_parsed (void) const
   { return octave::sys::time (static_cast<time_t> (0)); }
 
   virtual octave::sys::time time_checked (void) const
   { return octave::sys::time (static_cast<time_t> (0)); }
 
   virtual bool is_subfunction (void) const { return false; }
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -129,30 +129,30 @@ octave_user_script::octave_user_script (
   : octave_user_code (), cmd_list (nullptr), file_name (),
     t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     call_depth (-1)
 { }
 
 octave_user_script::octave_user_script
   (const std::string& fnm, const std::string& nm,
-   octave::symbol_table::scope *scope, octave::tree_statement_list *cmds,
+   octave::symbol_scope *scope, octave::tree_statement_list *cmds,
    const std::string& ds)
   : octave_user_code (nm, scope, ds), cmd_list (cmds), file_name (fnm),
     t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     call_depth (-1)
 {
   if (cmd_list)
     cmd_list->mark_as_script_body ();
 }
 
 octave_user_script::octave_user_script
   (const std::string& fnm, const std::string& nm,
-   octave::symbol_table::scope *scope, const std::string& ds)
+   octave::symbol_scope *scope, const std::string& ds)
   : octave_user_code (nm, scope, ds), cmd_list (nullptr), file_name (fnm),
     t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     call_depth (-1)
 { }
 
 octave_user_script::~octave_user_script (void)
 {
@@ -201,17 +201,17 @@ octave_user_script::call (octave::tree_e
       frame.protect_var (octave::tree_evaluator::statement_context);
       octave::tree_evaluator::statement_context = octave::tree_evaluator::script;
 
       octave::profiler& profiler = tw.get_profiler ();
 
       octave::profiler::enter<octave_user_script> block (profiler, *this);
 
       frame.add_method (m_scope,
-                        &octave::symbol_table::scope::unbind_script_symbols);
+                        &octave::symbol_scope::unbind_script_symbols);
       m_scope->bind_script_symbols (tw.get_current_scope ());
 
       if (tw.echo ())
         tw.push_echo_state (frame, octave::tree_evaluator::ECHO_SCRIPTS,
                             file_name);
 
       cmd_list->accept (tw);
 
@@ -236,17 +236,17 @@ octave_user_script::accept (octave::tree
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_user_function,
                                      "user-defined function",
                                      "user-defined function");
 
 // Ugh.  This really needs to be simplified (code/data?
 // extrinsic/intrinsic state?).
 
 octave_user_function::octave_user_function
-  (octave::symbol_table::scope *scope, octave::tree_parameter_list *pl,
+  (octave::symbol_scope *scope, octave::tree_parameter_list *pl,
    octave::tree_parameter_list *rl, octave::tree_statement_list *cl)
   : octave_user_code ("", scope, ""),
     param_list (pl), ret_list (rl), cmd_list (cl),
     lead_comm (), trail_comm (), file_name (),
     location_line (0), location_column (0),
     parent_name (), t_parsed (static_cast<time_t> (0)),
     t_checked (static_cast<time_t> (0)),
     system_fcn_file (false), call_depth (-1),
@@ -356,17 +356,17 @@ octave_user_function::maybe_relocate_end
             f->maybe_relocate_end_internal ();
         }
     }
 
   maybe_relocate_end_internal ();
 }
 
 void
-octave_user_function::stash_parent_fcn_scope (octave::symbol_table::scope *ps)
+octave_user_function::stash_parent_fcn_scope (octave::symbol_scope *ps)
 {
   parent_scope = ps;
 }
 
 std::string
 octave_user_function::profiler_name (void) const
 {
   std::ostringstream result;
@@ -547,17 +547,17 @@ octave_user_function::call (octave::tree
       m_scope->push_context ();
 
 #if 0
       std::cerr << name () << " scope: " << m_scope
                 << " call depth: " << call_depth
                 << " context: " << m_scope->current_context () << std::endl;
 #endif
 
-      frame.add_method (m_scope, &octave::symbol_table::scope::pop_context);
+      frame.add_method (m_scope, &octave::symbol_scope::pop_context);
     }
 
   string_vector arg_names = _args.name_tags ();
 
   if (param_list && ! param_list->varargs_only ())
     {
 #if 0
       std::cerr << "defining param list, scope: " << m_scope
@@ -601,17 +601,17 @@ octave_user_function::call (octave::tree
       //
       // This cleanup function is added to the unwind_protect stack
       // after the calls to clear the parameter lists so that local
       // variables will be cleared before the parameter lists are
       // cleared.  That way, any function parameters that have been
       // declared global will be unmarked as global before they are
       // undefined by the clear_param_list cleanup function.
 
-      frame.add_method (m_scope, &octave::symbol_table::scope::clear_variables);
+      frame.add_method (m_scope, &octave::symbol_scope::clear_variables);
     }
 
   bind_automatic_vars (tw, arg_names, args.length (), nargout,
                        all_va_args (args));
 
   frame.add_method (this, &octave_user_function::restore_warning_states);
 
   // Evaluate the commands that make up the function.
@@ -922,17 +922,17 @@ Programming Note: @code{nargin} does not
       octave::tree_parameter_list *param_list = fcn->parameter_list ();
 
       retval = (param_list ? param_list->length () : 0);
       if (fcn->takes_varargs ())
         retval = -1 - retval;
     }
   else
     {
-      octave::symbol_table::scope *scope = symtab.require_current_scope ("nargin");
+      octave::symbol_scope *scope = symtab.require_current_scope ("nargin");
       retval = scope->varval (".nargin.");
 
       if (retval.is_undefined ())
         retval = 0;
     }
 
   return retval;
 }
@@ -1048,17 +1048,17 @@ returns -1 for all anonymous functions.
       if (fcn->takes_var_return ())
         retval = -1 - retval;
     }
   else
     {
       if (symtab.at_top_level ())
         error ("nargout: invalid call at top level");
 
-      octave::symbol_table::scope *scope = symtab.require_current_scope ("nargout");
+      octave::symbol_scope *scope = symtab.require_current_scope ("nargout");
       retval = scope->varval (".nargout.");
 
       if (retval.is_undefined ())
         retval = 0;
     }
 
   return retval;
 }
@@ -1121,17 +1121,17 @@ element-by-element and a logical array i
   if (args.length () != 1)
     print_usage ();
 
   octave::symbol_table& symtab = interp.get_symbol_table ();
 
   if (symtab.at_top_level ())
     error ("isargout: invalid call at top level");
 
-  octave::symbol_table::scope *scope = symtab.require_current_scope ("isargout");
+  octave::symbol_scope *scope = symtab.require_current_scope ("isargout");
 
   int nargout1 = scope->varval (".nargout.").int_value ();
 
   Matrix ignored;
   octave_value tmp = scope->varval (".ignored.");
   if (tmp.is_defined ())
     ignored = tmp.matrix_value ();
 
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -56,17 +56,17 @@ namespace octave
 }
 
 class
 octave_user_code : public octave_function
 {
 protected:
 
   octave_user_code (const std::string& nm,
-                    octave::symbol_table::scope *scope = nullptr,
+                    octave::symbol_scope *scope = nullptr,
                     const std::string& ds = "")
     : octave_function (nm, ds), m_scope (scope), m_file_info (nullptr),
       curr_unwind_protect_frame (nullptr)
   { }
 
 public:
 
   octave_user_code (void)
@@ -92,28 +92,28 @@ public:
 
   std::string get_code_line (size_t line);
 
   std::deque<std::string> get_code_lines (size_t line, size_t num_lines);
 
   void cache_function_text (const std::string& text,
                             const octave::sys::time& timestamp);
 
-  octave::symbol_table::scope *scope (void) { return m_scope; }
+  octave::symbol_scope *scope (void) { return m_scope; }
 
   virtual std::map<std::string, octave_value> subfunctions (void) const;
 
   virtual octave::tree_statement_list * body (void) = 0;
 
 protected:
 
   void get_file_info (void);
 
   // Our symbol table scope.
-  octave::symbol_table::scope *m_scope;
+  octave::symbol_scope *m_scope;
 
   // Cached text of function or script code with line offsets
   // calculated.
   octave::file_info *m_file_info;
 
   // pointer to the current unwind_protect frame of this function.
   octave::unwind_protect *curr_unwind_protect_frame;
 };
@@ -123,22 +123,22 @@ protected:
 class
 octave_user_script : public octave_user_code
 {
 public:
 
   octave_user_script (void);
 
   octave_user_script (const std::string& fnm, const std::string& nm,
-                      octave::symbol_table::scope *scope = nullptr,
+                      octave::symbol_scope *scope = nullptr,
                       octave::tree_statement_list *cmds = nullptr,
                       const std::string& ds = "");
 
   octave_user_script (const std::string& fnm, const std::string& nm,
-                      octave::symbol_table::scope *scope = nullptr,
+                      octave::symbol_scope *scope = nullptr,
                       const std::string& ds = "");
 
   // No copying!
 
   octave_user_script (const octave_user_script& f) = delete;
 
   octave_user_script& operator = (const octave_user_script& f) = delete;
 
@@ -202,17 +202,17 @@ private:
 
 // User-defined functions.
 
 class
 octave_user_function : public octave_user_code
 {
 public:
 
-  octave_user_function (octave::symbol_table::scope *scope = nullptr,
+  octave_user_function (octave::symbol_scope *scope = nullptr,
                         octave::tree_parameter_list *pl = nullptr,
                         octave::tree_parameter_list *rl = nullptr,
                         octave::tree_statement_list *cl = nullptr);
 
   // No copying!
 
   octave_user_function (const octave_user_function& fn) = delete;
 
@@ -255,17 +255,17 @@ public:
 
   int ending_line (void) const { return end_location_line; }
   int ending_column (void) const { return end_location_column; }
 
   void maybe_relocate_end (void);
 
   void stash_parent_fcn_name (const std::string& p) { parent_name = p; }
 
-  void stash_parent_fcn_scope (octave::symbol_table::scope *ps);
+  void stash_parent_fcn_scope (octave::symbol_scope *ps);
 
   void stash_leading_comment (octave::comment_list *lc) { lead_comm = lc; }
 
   void stash_trailing_comment (octave::comment_list *tc) { trail_comm = tc; }
 
   void mark_fcn_file_up_to_date (const octave::sys::time& t) { t_checked = t; }
 
   void stash_fcn_file_time (const octave::sys::time& t)
@@ -275,17 +275,17 @@ public:
   }
 
   std::string fcn_file_name (void) const { return file_name; }
 
   std::string profiler_name (void) const;
 
   std::string parent_fcn_name (void) const { return parent_name; }
 
-  octave::symbol_table::scope *
+  octave::symbol_scope *
   parent_fcn_scope (void) const { return parent_scope; }
 
   octave::sys::time time_parsed (void) const { return t_parsed; }
 
   octave::sys::time time_checked (void) const { return t_checked; }
 
   void mark_as_system_fcn_file (void);
 
@@ -483,17 +483,17 @@ private:
 
   // Enum describing whether this function is the constructor for class object.
   class_ctor_type class_constructor;
 
   // TRUE means this function is a method for a class.
   bool class_method;
 
   // The scope of the parent function, if any.
-  octave::symbol_table::scope *parent_scope;
+  octave::symbol_scope *parent_scope;
 
 #if defined (HAVE_LLVM)
   octave::jit_function_info *jit_info;
 #endif
 
   void maybe_relocate_end_internal (void);
 
   void print_code_function_header (const std::string& prefix);
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -64,27 +64,27 @@ namespace octave
       void clear (void);
 
       bool empty (void) const { return frame_stack.empty (); }
 
       size_t size (void) const { return frame_stack.size (); }
 
       void pop (void);
 
-      void push (symbol_table::scope *scope)
+      void push (symbol_scope *scope)
       {
         frame_stack.push_front (scope);
       }
 
-      symbol_table::scope *curr_scope (void) const;
-      symbol_table::scope *parent_scope (void) const;
+      symbol_scope *curr_scope (void) const;
+      symbol_scope *parent_scope (void) const;
 
     private:
 
-      std::deque<symbol_table::scope*> frame_stack;
+      std::deque<symbol_scope*> frame_stack;
     };
 
     // Track nesting of square brackets, curly braces, and parentheses.
 
     class bbp_nesting_level
     {
     private:
 
@@ -597,17 +597,17 @@ namespace octave
     void xunput (char c, char *buf);
 
     void xunput (char c);
 
     bool looking_at_space (void);
 
     bool inside_any_object_index (void);
 
-    bool is_variable (const std::string& name, symbol_table::scope *scope);
+    bool is_variable (const std::string& name, symbol_scope *scope);
 
     int is_keyword_token (const std::string& s);
 
     bool fq_identifier_contains_keyword (const std::string& s);
 
     bool whitespace_is_significant (void);
 
     void handle_number (void);
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -2075,48 +2075,48 @@ debug information as it processes an exp
 
 namespace octave
 {
   void
   lexical_feedback::symbol_table_context::clear (void)
   {
     while (! frame_stack.empty ())
       {
-        symbol_table::scope *scope = curr_scope ();
+        symbol_scope *scope = curr_scope ();
 
         delete scope;
 
         frame_stack.pop_front ();
       }
   }
 
   void
   lexical_feedback::symbol_table_context::pop (void)
   {
     if (empty ())
       panic_impossible ();
 
     frame_stack.pop_front ();
   }
 
-  symbol_table::scope *
+  symbol_scope *
   lexical_feedback::symbol_table_context::curr_scope (void) const
   {
     if (empty ())
       {
-        symbol_table::scope *scope
+        symbol_scope *scope
           = __get_current_scope__ ("lexical_feedback::symbol_table_context::curr_scope");
 
         return scope;
       }
     else
       return frame_stack.front ();
   }
 
-  symbol_table::scope *
+  symbol_scope *
   lexical_feedback::symbol_table_context::parent_scope (void) const
   {
     size_t sz = size ();
 
     return sz > 1 ? frame_stack[1] : (sz == 1 ? frame_stack[0] : nullptr);
   }
 
   lexical_feedback::~lexical_feedback (void)
@@ -2517,17 +2517,17 @@ namespace octave
           }
       }
 
     return retval;
   }
 
   bool
   base_lexer::is_variable (const std::string& name,
-                           symbol_table::scope *scope)
+                           symbol_scope *scope)
   {
     return ((scope && scope->is_variable (name))
             || (pending_local_variables.find (name)
                 != pending_local_variables.end ()));
   }
 
   // Handle keywords.  Return -1 if the keyword should be ignored.
 
@@ -3151,22 +3151,22 @@ namespace octave
 
         // The call to is_keyword_token set at_beginning_of_statement.
 
         return kw_token;
       }
 
     // Find the token in the symbol table.
 
-    symbol_table::scope *scope = symtab_context.curr_scope ();
-
-    symbol_table::symbol_record sr
+    symbol_scope *scope = symtab_context.curr_scope ();
+
+    symbol_record sr
       = (scope
          ? scope->insert (ident)
-         : symbol_table::symbol_record (scope, ident));
+         : symbol_record (scope, ident));
 
     token *tok = new token (NAME, sr, input_line_number, current_input_column);
 
     // The following symbols are handled specially so that things like
     //
     //   pi +1
     //
     // are parsed as an addition expression instead of as a command-style
@@ -3339,17 +3339,17 @@ namespace octave
           token *tok_val = current_token ();
           std::cerr << "STRUCT_ELT [" << tok_val->text () << "]\n";
         }
         break;
 
       case NAME:
         {
           token *tok_val = current_token ();
-          symbol_table::symbol_record sr = tok_val->sym_rec ();
+          symbol_record sr = tok_val->sym_rec ();
           std::cerr << "NAME [" << sr.name () << "]\n";
         }
         break;
 
       case END: std::cerr << "END\n"; break;
 
       case DQ_STRING:
       case SQ_STRING:
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -496,17 +496,17 @@ word_list       : string
                 ;
 
 // ===========
 // Expressions
 // ===========
 
 identifier      : NAME
                   {
-                    octave::symbol_table::symbol_record sr = $1->sym_rec ();
+                    octave::symbol_record sr = $1->sym_rec ();
                     $$ = new octave::tree_identifier (sr, $1->line (), $1->column ());
                   }
                 ;
 
 superclass_identifier
                 : SUPERCLASSREF
                   {
                     std::string method_nm = $1->superclass_method_name ();
@@ -1271,17 +1271,17 @@ push_fcn_symtab : // empty
                   {
                     $$ = 0;
 
                     parser.m_curr_fcn_depth++;
 
                     if (parser.m_max_fcn_depth < parser.m_curr_fcn_depth)
                       parser.m_max_fcn_depth = parser.m_curr_fcn_depth;
 
-                    lexer.symtab_context.push (new octave::symbol_table::scope ());
+                    lexer.symtab_context.push (new octave::symbol_scope ());
 
                     parser.m_function_scopes.push (lexer.symtab_context.curr_scope ());
 
                     if (! lexer.reading_script_file
                         && parser.m_curr_fcn_depth == 1
                         && ! parser.m_parsing_subfunctions)
                       parser.m_primary_fcn_scope
                         = lexer.symtab_context.curr_scope ();
@@ -1301,17 +1301,17 @@ push_fcn_symtab : // empty
 
 param_list_beg  : '('
                   {
                     $$ = 0;
                     lexer.looking_at_parameter_list = true;
 
                     if (lexer.looking_at_function_handle)
                       {
-                        lexer.symtab_context.push (new octave::symbol_table::scope ());
+                        lexer.symtab_context.push (new octave::symbol_scope ());
                         lexer.looking_at_function_handle--;
                         lexer.looking_at_anon_fcn_args = true;
                       }
                   }
                 ;
 
 param_list_end  : ')'
                   {
@@ -1438,17 +1438,17 @@ parsing_local_fcns
                 : // empty
                   { parser.m_parsing_local_functions = true; }
                 ;
 
 push_script_symtab : // empty
                   {
                     $$ = 0;
 
-                    lexer.symtab_context.push (new octave::symbol_table::scope ());
+                    lexer.symtab_context.push (new octave::symbol_scope ());
                   }
                 ;
 
 begin_file      : push_script_symtab INPUT_FILE
                   { $$ = 0; }
                 ;
 
 file            : begin_file opt_nl opt_list END_OF_INPUT
@@ -1525,17 +1525,17 @@ fcn_name        : identifier
                         parser.bison_error ("duplicate subfunction or nested function name",
                                             $1->line (), $1->column ());
 
                         delete $1;
 
                         YYABORT;
                       }
 
-                    octave::symbol_table::scope *curr_scope
+                    octave::symbol_scope *curr_scope
                       = lexer.symtab_context.curr_scope ();
                     curr_scope->cache_name (id);
 
                     lexer.parsed_function_name.top () = true;
                     lexer.maybe_classdef_get_set_method = false;
 
                     $$ = $1;
                   }
@@ -2087,17 +2087,17 @@ namespace octave
 
   void
   base_parser::parent_scope_info::push (const value_type& elt)
   {
     m_info.push_back (elt);
   }
 
   void
-  base_parser::parent_scope_info::push (symbol_table::scope *scope)
+  base_parser::parent_scope_info::push (symbol_scope *scope)
   {
     push (value_type (scope, ""));
   }
 
   void
   base_parser::parent_scope_info::pop (void)
   {
     m_info.pop_back ();
@@ -2140,17 +2140,17 @@ namespace octave
       return false;
 
     if (size () > 0)
       m_info.back().second = name;
 
     return true;
   }
 
-  symbol_table::scope *
+  symbol_scope *
   base_parser::parent_scope_info::parent_scope (void) const
   {
     return size () > 1 ? m_info[size()-2].first : nullptr;
   }
 
   std::string
   base_parser::parent_scope_info::parent_name (void) const
   {
@@ -2434,18 +2434,18 @@ namespace octave
   tree_anon_fcn_handle *
   base_parser::make_anon_fcn_handle (tree_parameter_list *param_list,
                                      tree_expression *expr)
   {
     // FIXME: need to get these from the location of the @ symbol.
     int l = m_lexer.input_line_number;
     int c = m_lexer.current_input_column;
 
-    symbol_table::scope *fcn_scope = m_lexer.symtab_context.curr_scope ();
-    symbol_table::scope *parent_scope = m_lexer.symtab_context.parent_scope ();
+    symbol_scope *fcn_scope = m_lexer.symtab_context.curr_scope ();
+    symbol_scope *parent_scope = m_lexer.symtab_context.parent_scope ();
 
     m_lexer.symtab_context.pop ();
 
     expr->set_print_flag (false);
 
     fcn_scope->mark_static ();
 
     tree_anon_fcn_handle *retval
@@ -3234,17 +3234,17 @@ namespace octave
   base_parser::make_script (tree_statement_list *cmds,
                             tree_statement *end_script)
   {
     if (! cmds)
       cmds = new tree_statement_list ();
 
     cmds->append (end_script);
 
-    symbol_table::scope *script_scope = m_lexer.symtab_context.curr_scope ();
+    symbol_scope *script_scope = m_lexer.symtab_context.curr_scope ();
 
     script_scope->cache_name (m_lexer.fcn_file_full_name);
 
     octave_user_script *script
       = new octave_user_script (m_lexer.fcn_file_full_name,
                                 m_lexer.fcn_file_name, script_scope,
                                 cmds, m_lexer.help_text);
 
@@ -3445,33 +3445,33 @@ namespace octave
       {
         std::string nm = fcn->name ();
         std::string file = fcn->fcn_file_name ();
 
         std::string tmp = nm;
         if (! file.empty ())
           tmp += ": " + file;
 
-        symbol_table::scope *fcn_scope = fcn->scope ();
+        symbol_scope *fcn_scope = fcn->scope ();
         fcn_scope->cache_name (tmp);
 
         if (lc)
           fcn->stash_leading_comment (lc);
 
         fcn->define_ret_list (ret_list);
 
         if (m_curr_fcn_depth > 1 || m_parsing_subfunctions)
           {
             fcn->stash_fcn_location (l, c);
 
             octave_value ov_fcn (fcn);
 
             if (m_endfunction_found && m_function_scopes.size () > 1)
               {
-                symbol_table::scope *pscope = m_function_scopes.parent_scope ();
+                symbol_scope *pscope = m_function_scopes.parent_scope ();
 
                 pscope->install_nestfunction (nm, ov_fcn);
               }
             else
               {
                 fcn->mark_as_subfunction ();
                 m_subfunction_names.push_back (nm);
 
@@ -3487,17 +3487,17 @@ namespace octave
             // We are either reading a script file or defining a function
             // at the command line, so this definition creates a
             // tree_function object that is placed in the parse tree.
             // Otherwise, it is just inserted in the symbol table,
             // either as a subfunction or nested function (see above),
             // or as the primary function for the file, via
             // m_primary_fcn_ptr (see also load_fcn_from_file,,
             // parse_fcn_file, and
-            // symbol_table::fcn_info::fcn_info_rep::find_user_function).
+            // fcn_info::fcn_info_rep::find_user_function).
 
             if (m_lexer.buffer_function_text)
               {
                 fcn->cache_function_text (m_lexer.function_text,
                                           fcn->time_parsed ());
                 m_lexer.buffer_function_text = false;
               }
 
@@ -5627,17 +5627,17 @@ may be either @qcode{"base"} or @qcode{"
     {
       // Put the check here so that we don't slow down assignments
       // generally.  Any that go through Octave's parser should have
       // already been checked.
 
       if (octave::is_keyword (nm))
         error ("assignin: invalid assignment to keyword '%s'", nm.c_str ());
 
-      octave::symbol_table::scope *scope = interp.get_current_scope ();
+      octave::symbol_scope *scope = interp.get_current_scope ();
 
       if (scope)
         scope->assign (nm, args(2));
     }
   else
     error ("assignin: invalid variable name in argument VARNAME");
 
   return retval;
diff --git a/libinterp/parse-tree/parse.h b/libinterp/parse-tree/parse.h
--- a/libinterp/parse-tree/parse.h
+++ b/libinterp/parse-tree/parse.h
@@ -96,17 +96,17 @@ namespace octave
   class base_parser
   {
   private:
 
     class parent_scope_info
     {
     public:
 
-      typedef std::pair<symbol_table::scope*, std::string> value_type;
+      typedef std::pair<symbol_scope*, std::string> value_type;
 
       typedef std::deque<value_type>::iterator iterator;
       typedef std::deque<value_type>::const_iterator const_iterator;
 
       typedef std::deque<value_type>::reverse_iterator reverse_iterator;
       typedef std::deque<value_type>::const_reverse_iterator const_reverse_iterator;
 
       parent_scope_info (void) = default;
@@ -116,25 +116,25 @@ namespace octave
       parent_scope_info& operator = (const parent_scope_info&) = default;
 
       ~parent_scope_info (void) = default;
 
       size_t size (void) const;
 
       void push (const value_type& elt);
 
-      void push (symbol_table::scope *id);
+      void push (symbol_scope *id);
 
       void pop (void);
 
       bool name_ok (const std::string& name);
 
       bool name_current_scope (const std::string& name);
 
-      symbol_table::scope *parent_scope (void) const;
+      symbol_scope *parent_scope (void) const;
 
       std::string parent_name (void) const;
 
       void clear (void);
 
     private:
 
       std::deque<value_type> m_info;
@@ -443,17 +443,17 @@ namespace octave
     // = 1 inside the primary function or a subfunction.
     // > 1 means we are looking at a function definition that seems to be
     //     inside a function.  Note that the function still might not be a
     //     nested function.
     int m_curr_fcn_depth;
 
     // Scope where we install all subfunctions and nested functions.  Only
     // used while reading function files.
-    symbol_table::scope *m_primary_fcn_scope;
+    symbol_scope *m_primary_fcn_scope;
 
     // Name of the current class when we are parsing class methods or
     // constructors.
     std::string m_curr_class_name;
 
     // Name of the current package when we are parsing an element contained
     // in a package directory (+-directory).
     std::string m_curr_package_name;
diff --git a/libinterp/parse-tree/pt-arg-list.cc b/libinterp/parse-tree/pt-arg-list.cc
--- a/libinterp/parse-tree/pt-arg-list.cc
+++ b/libinterp/parse-tree/pt-arg-list.cc
@@ -298,17 +298,17 @@ namespace octave
             retval.push_back (idx_expr->name ());
           }
       }
 
     return retval;
   }
 
   tree_argument_list *
-  tree_argument_list::dup (symbol_table::scope& scope) const
+  tree_argument_list::dup (symbol_scope& scope) const
   {
     tree_argument_list *new_list = new tree_argument_list ();
 
     new_list->list_includes_magic_end = list_includes_magic_end;
     new_list->simple_assign_lhs = simple_assign_lhs;
 
     for (const tree_expression *elt : *this)
       new_list->append (elt ? elt->dup (scope) : nullptr);
diff --git a/libinterp/parse-tree/pt-arg-list.h b/libinterp/parse-tree/pt-arg-list.h
--- a/libinterp/parse-tree/pt-arg-list.h
+++ b/libinterp/parse-tree/pt-arg-list.h
@@ -91,17 +91,17 @@ namespace octave
 
     octave_value_list convert_to_const_vector (tree_evaluator *tw,
                                                const octave_value *object = nullptr);
 
     string_vector get_arg_names (void) const;
 
     std::list<std::string> variable_names (void) const;
 
-    tree_argument_list * dup (symbol_table::scope& scope) const;
+    tree_argument_list * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_argument_list (*this);
     }
 
   private:
 
diff --git a/libinterp/parse-tree/pt-array-list.cc b/libinterp/parse-tree/pt-array-list.cc
--- a/libinterp/parse-tree/pt-array-list.cc
+++ b/libinterp/parse-tree/pt-array-list.cc
@@ -74,26 +74,26 @@ namespace octave
   void
   tree_array_list::copy_base (const tree_array_list& array_list)
   {
     tree_expression::copy_base (array_list);
   }
 
   void
   tree_array_list::copy_base (const tree_array_list& array_list,
-                              symbol_table::scope& scope)
+                              symbol_scope& scope)
   {
     for (const tree_argument_list *elt : array_list)
       append (elt ? elt->dup (scope) : nullptr);
 
     copy_base (*this);
   }
 
   tree_expression *
-  tree_array_list::dup (symbol_table::scope&) const
+  tree_array_list::dup (symbol_scope&) const
   {
     panic_impossible ();
     return nullptr;
   }
 
   void
   tree_array_list::accept (tree_walker&)
   {
diff --git a/libinterp/parse-tree/pt-array-list.h b/libinterp/parse-tree/pt-array-list.h
--- a/libinterp/parse-tree/pt-array-list.h
+++ b/libinterp/parse-tree/pt-array-list.h
@@ -72,19 +72,19 @@ namespace octave
     // have to do this?  Without the using declaration or a name change,
     // the base class functions will be hidden.  That may be OK, but it
     // can also cause some confusion.
     using tree_expression::copy_base;
 
     void copy_base (const tree_array_list& array_list);
 
     void copy_base (const tree_array_list& array_list,
-                    symbol_table::scope& scope);
+                    symbol_scope& scope);
 
-    tree_expression * dup (symbol_table::scope& scope) const;
+    tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw);
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
 OCTAVE_DEPRECATED (4.4, "use 'octave::tree_array_list' instead")
diff --git a/libinterp/parse-tree/pt-assign.cc b/libinterp/parse-tree/pt-assign.cc
--- a/libinterp/parse-tree/pt-assign.cc
+++ b/libinterp/parse-tree/pt-assign.cc
@@ -52,17 +52,17 @@ namespace octave
 
   std::string
   tree_simple_assignment::oper (void) const
   {
     return octave_value::assign_op_as_string (etype);
   }
 
   tree_expression *
-  tree_simple_assignment::dup (symbol_table::scope& scope) const
+  tree_simple_assignment::dup (symbol_scope& scope) const
   {
     tree_simple_assignment *new_sa
       = new tree_simple_assignment (lhs ? lhs->dup (scope) : nullptr,
                                     rhs ? rhs->dup (scope) : nullptr,
                                     preserve, etype);
 
     new_sa->copy_base (*this);
 
@@ -87,17 +87,17 @@ namespace octave
 
   std::string
   tree_multi_assignment::oper (void) const
   {
     return octave_value::assign_op_as_string (op_type ());
   }
 
   tree_expression *
-  tree_multi_assignment::dup (symbol_table::scope&) const
+  tree_multi_assignment::dup (symbol_scope&) const
   {
     panic_impossible ();
     return nullptr;
   }
 }
 
 /*
 %!function varargout = f ()
diff --git a/libinterp/parse-tree/pt-assign.h b/libinterp/parse-tree/pt-assign.h
--- a/libinterp/parse-tree/pt-assign.h
+++ b/libinterp/parse-tree/pt-assign.h
@@ -71,17 +71,17 @@ namespace octave
     bool is_assignment_expression (void) const { return true; }
 
     std::string oper (void) const;
 
     tree_expression * left_hand_side (void) { return lhs; }
 
     tree_expression * right_hand_side (void) { return rhs; }
 
-    tree_expression * dup (symbol_table::scope& scope) const;
+    tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_simple_assignment (*this);
     }
 
     octave_value::assign_op op_type (void) const { return etype; }
 
@@ -136,17 +136,17 @@ namespace octave
     bool rvalue_ok (void) const { return true; }
 
     std::string oper (void) const;
 
     tree_argument_list * left_hand_side (void) { return lhs; }
 
     tree_expression * right_hand_side (void) { return rhs; }
 
-    tree_expression * dup (symbol_table::scope& scope) const;
+    tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_multi_assignment (*this);
     }
 
     octave_value::assign_op op_type (void) const
     { return octave_value::op_asn_eq; }
diff --git a/libinterp/parse-tree/pt-binop.cc b/libinterp/parse-tree/pt-binop.cc
--- a/libinterp/parse-tree/pt-binop.cc
+++ b/libinterp/parse-tree/pt-binop.cc
@@ -45,17 +45,17 @@ namespace octave
 
   std::string
   tree_binary_expression::oper (void) const
   {
     return octave_value::binary_op_as_string (etype);
   }
 
   tree_expression *
-  tree_binary_expression::dup (symbol_table::scope& scope) const
+  tree_binary_expression::dup (symbol_scope& scope) const
   {
     tree_binary_expression *new_be
       = new tree_binary_expression (op_lhs ? op_lhs->dup (scope) : nullptr,
                                     op_rhs ? op_rhs->dup (scope) : nullptr,
                                     line (), column (), etype);
 
     new_be->copy_base (*this);
 
@@ -82,17 +82,17 @@ namespace octave
       default:
         break;
       }
 
     return retval;
   }
 
   tree_expression *
-  tree_boolean_expression::dup (symbol_table::scope& scope) const
+  tree_boolean_expression::dup (symbol_scope& scope) const
   {
     tree_boolean_expression *new_be
       = new tree_boolean_expression (op_lhs ? op_lhs->dup (scope) : nullptr,
                                      op_rhs ? op_rhs->dup (scope) : nullptr,
                                      line (), column (), etype);
 
     new_be->copy_base (*this);
 
diff --git a/libinterp/parse-tree/pt-binop.h b/libinterp/parse-tree/pt-binop.h
--- a/libinterp/parse-tree/pt-binop.h
+++ b/libinterp/parse-tree/pt-binop.h
@@ -98,17 +98,17 @@ namespace octave
     tree_expression * lhs (void) { return op_lhs; }
     tree_expression * rhs (void) { return op_rhs; }
 
     bool is_eligible_for_braindead_shortcircuit (void) const
     {
       return eligible_for_braindead_shortcircuit;
     }
 
-    tree_expression * dup (symbol_table::scope& scope) const;
+    tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_binary_expression (*this);
     }
 
     std::string profiler_name (void) const { return "binary " + oper (); }
 
@@ -165,17 +165,17 @@ namespace octave
     bool is_boolean_expression (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
     std::string oper (void) const;
 
     type op_type (void) const { return etype; }
 
-    tree_expression * dup (symbol_table::scope& scope) const;
+    tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_boolean_expression (*this);
     }
 
   private:
 
diff --git a/libinterp/parse-tree/pt-cell.cc b/libinterp/parse-tree/pt-cell.cc
--- a/libinterp/parse-tree/pt-cell.cc
+++ b/libinterp/parse-tree/pt-cell.cc
@@ -32,17 +32,17 @@ along with Octave; see the file COPYING.
 #include "pt-exp.h"
 #include "pt-cell.h"
 #include "pt-walk.h"
 #include "ov.h"
 
 namespace octave
 {
   tree_expression *
-  tree_cell::dup (symbol_table::scope& scope) const
+  tree_cell::dup (symbol_scope& scope) const
   {
     tree_cell *new_cell = new tree_cell (nullptr, line (), column ());
 
     new_cell->copy_base (*this, scope);
 
     return new_cell;
   }
 }
diff --git a/libinterp/parse-tree/pt-cell.h b/libinterp/parse-tree/pt-cell.h
--- a/libinterp/parse-tree/pt-cell.h
+++ b/libinterp/parse-tree/pt-cell.h
@@ -55,17 +55,17 @@ namespace octave
     tree_cell& operator = (const tree_cell&) = delete;
 
     ~tree_cell (void) = default;
 
     bool iscell (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
-    tree_expression * dup (symbol_table::scope& scope) const;
+    tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_cell (*this);
     }
   };
 }
 
diff --git a/libinterp/parse-tree/pt-colon.cc b/libinterp/parse-tree/pt-colon.cc
--- a/libinterp/parse-tree/pt-colon.cc
+++ b/libinterp/parse-tree/pt-colon.cc
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 
 #include "pt-colon.h"
 
 namespace octave
 {
   // Colon expressions.
 
   tree_expression *
-  tree_colon_expression::dup (symbol_table::scope& scope) const
+  tree_colon_expression::dup (symbol_scope& scope) const
   {
     tree_colon_expression *new_ce
       = new tree_colon_expression (op_base ? op_base->dup (scope) : nullptr,
                                    op_limit ? op_limit->dup (scope) : nullptr,
                                    op_increment ? op_increment->dup (scope) : nullptr,
                                    line (), column ());
 
     new_ce->copy_base (*new_ce);
diff --git a/libinterp/parse-tree/pt-colon.h b/libinterp/parse-tree/pt-colon.h
--- a/libinterp/parse-tree/pt-colon.h
+++ b/libinterp/parse-tree/pt-colon.h
@@ -85,17 +85,17 @@ namespace octave
     void eval_error (const std::string& s) const;
 
     tree_expression * base (void) { return op_base; }
 
     tree_expression * limit (void) { return op_limit; }
 
     tree_expression * increment (void) { return op_increment; }
 
-    tree_expression * dup (symbol_table::scope& scope) const;
+    tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_colon_expression (*this);
     }
 
   private:
 
diff --git a/libinterp/parse-tree/pt-const.cc b/libinterp/parse-tree/pt-const.cc
--- a/libinterp/parse-tree/pt-const.cc
+++ b/libinterp/parse-tree/pt-const.cc
@@ -53,17 +53,17 @@ namespace octave
   {
     if (pr_orig_text && ! orig_text.empty ())
       os << orig_text;
     else
       val.print_raw (os, pr_as_read_syntax);
   }
 
   tree_expression *
-  tree_constant::dup (symbol_table::scope&) const
+  tree_constant::dup (symbol_scope&) const
   {
     tree_constant *new_tc
       = new tree_constant (val, orig_text, line (), column ());
 
     new_tc->copy_base (*this);
 
     return new_tc;
   }
diff --git a/libinterp/parse-tree/pt-const.h b/libinterp/parse-tree/pt-const.h
--- a/libinterp/parse-tree/pt-const.h
+++ b/libinterp/parse-tree/pt-const.h
@@ -73,17 +73,17 @@ namespace octave
 
     void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
                     bool pr_orig_txt = true);
 
     bool rvalue_ok (void) const { return true; }
 
     octave_value value (void) { return val; }
 
-    tree_expression * dup (symbol_table::scope& scope) const;
+    tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_constant (*this);
     }
 
     // Store the original text corresponding to this constant for later
     // pretty printing.
diff --git a/libinterp/parse-tree/pt-decl.cc b/libinterp/parse-tree/pt-decl.cc
--- a/libinterp/parse-tree/pt-decl.cc
+++ b/libinterp/parse-tree/pt-decl.cc
@@ -43,17 +43,17 @@ namespace octave
 
   tree_decl_elt::~tree_decl_elt (void)
   {
     delete id;
     delete expr;
   }
 
   tree_decl_elt *
-  tree_decl_elt::dup (symbol_table::scope& scope) const
+  tree_decl_elt::dup (symbol_scope& scope) const
   {
     return new tree_decl_elt (id ? id->dup (scope) : nullptr,
                               expr ? expr->dup (scope) : nullptr);
   }
 
   // Initializer lists for declaration statements.
 
   // Declaration commands (global, static).
diff --git a/libinterp/parse-tree/pt-decl.h b/libinterp/parse-tree/pt-decl.h
--- a/libinterp/parse-tree/pt-decl.h
+++ b/libinterp/parse-tree/pt-decl.h
@@ -89,17 +89,17 @@ namespace octave
     bool is_persistent (void) const { return type == persistent; }
 
     tree_identifier * ident (void) { return id; }
 
     std::string name (void) const { return id ? id->name () : ""; }
 
     tree_expression * expression (void) { return expr; }
 
-    tree_decl_elt * dup (symbol_table::scope& scope) const;
+    tree_decl_elt * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_decl_elt (*this);
     }
 
   private:
 
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -87,24 +87,24 @@ namespace octave
   tree_evaluator::visit_anon_fcn_handle (tree_anon_fcn_handle& anon_fh)
   {
     // FIXME: should CMD_LIST be limited to a single expression?
     // I think that is what Matlab does.
 
     tree_parameter_list *param_list = anon_fh.parameter_list ();
     tree_expression *expr = anon_fh.expression ();
 
-    symbol_table::scope *af_scope = anon_fh.scope ();
+    symbol_scope *af_scope = anon_fh.scope ();
 
     symbol_table& symtab = m_interpreter.get_symbol_table ();
 
-    symbol_table::scope *af_parent_scope
+    symbol_scope *af_parent_scope
       = anon_fh.has_parent_scope () ? symtab.current_scope () : nullptr;
 
-    symbol_table::scope *new_scope = af_scope ? af_scope->dup () : nullptr;
+    symbol_scope *new_scope = af_scope ? af_scope->dup () : nullptr;
 
     if (new_scope && af_parent_scope)
       new_scope->inherit (af_parent_scope);
 
     tree_parameter_list *param_list_dup
       = param_list ? param_list->dup (*new_scope) : nullptr;
 
     tree_parameter_list *ret_list = nullptr;
@@ -613,17 +613,17 @@ namespace octave
           }
         else
           return val.is_equal (label_value);
       }
 
     return false;
   }
 
-  symbol_table::scope *
+  symbol_scope *
   tree_evaluator::get_current_scope (void)
   {
     symbol_table& symtab = m_interpreter.get_symbol_table ();
 
     return symtab.current_scope ();
   }
 
   void
@@ -963,29 +963,29 @@ namespace octave
 
         symbol_table& symtab = m_interpreter.get_symbol_table ();
 
         symtab.install_cmdline_function (nm, fcn);
 
         // Make sure that any variable with the same name as the new
         // function is cleared.
 
-        symbol_table::scope *scope = symtab.current_scope ();
+        symbol_scope *scope = symtab.current_scope ();
 
         if (scope)
           scope->assign (nm);
       }
   }
 
   void
   tree_evaluator::visit_identifier (tree_identifier& expr)
   {
     octave_value_list retval;
 
-    symbol_table::symbol_record sym = expr.symbol ();
+    symbol_record sym = expr.symbol ();
 
     octave_value val = sym.find ();
 
     if (val.is_defined ())
       {
         // GAGME -- this would be cleaner if we required
         // parens to indicate function calls.
         //
@@ -2653,17 +2653,17 @@ namespace octave
           {
             octave_value_list lst = val.list_value ();
 
             for (octave_idx_type i = 0; i < lst.length (); i++)
               bind_ans (lst(i), print);
           }
         else
           {
-            symbol_table::scope *scope
+            symbol_scope *scope
               = m_interpreter.require_current_scope ("tree_evaluator::bind_ans");
 
             scope->force_assign (ans, val);
 
             if (print)
               {
                 octave_value_list args = ovl (val);
                 args.stash_name_tags (string_vector (ans));
diff --git a/libinterp/parse-tree/pt-eval.h b/libinterp/parse-tree/pt-eval.h
--- a/libinterp/parse-tree/pt-eval.h
+++ b/libinterp/parse-tree/pt-eval.h
@@ -303,17 +303,17 @@ namespace octave
 
     bool switch_case_label_matches (tree_switch_case *expr,
                                     const octave_value& val);
 
     call_stack& get_call_stack (void) { return m_call_stack; }
 
     profiler& get_profiler (void) { return m_profiler; }
 
-    symbol_table::scope *get_current_scope (void);
+    symbol_scope *get_current_scope (void);
 
     int max_recursion_depth (void) const { return m_max_recursion_depth; }
 
     int max_recursion_depth (int n)
     {
       int val = m_max_recursion_depth;
       m_max_recursion_depth = n;
       return val;
diff --git a/libinterp/parse-tree/pt-exp.h b/libinterp/parse-tree/pt-exp.h
--- a/libinterp/parse-tree/pt-exp.h
+++ b/libinterp/parse-tree/pt-exp.h
@@ -53,17 +53,17 @@ namespace octave
     tree_expression (const tree_expression&) = delete;
 
     tree_expression& operator = (const tree_expression&) = delete;
 
     virtual ~tree_expression (void) = default;
 
     virtual bool has_magic_end (void) const = 0;
 
-    virtual tree_expression * dup (symbol_table::scope& scope) const = 0;
+    virtual tree_expression * dup (symbol_scope& scope) const = 0;
 
     virtual bool is_constant (void) const { return false; }
 
     virtual bool is_matrix (void) const { return false; }
 
     virtual bool iscell (void) const { return false; }
 
     virtual bool is_identifier (void) const { return false; }
diff --git a/libinterp/parse-tree/pt-fcn-handle.cc b/libinterp/parse-tree/pt-fcn-handle.cc
--- a/libinterp/parse-tree/pt-fcn-handle.cc
+++ b/libinterp/parse-tree/pt-fcn-handle.cc
@@ -41,45 +41,45 @@ namespace octave
   void
   tree_fcn_handle::print_raw (std::ostream& os, bool pr_as_read_syntax,
                               bool pr_orig_text)
   {
     os << ((pr_as_read_syntax || pr_orig_text) ? "@" : "") << nm;
   }
 
   tree_expression *
-  tree_fcn_handle::dup (symbol_table::scope&) const
+  tree_fcn_handle::dup (symbol_scope&) const
   {
     tree_fcn_handle *new_fh = new tree_fcn_handle (nm, line (), column ());
 
     new_fh->copy_base (*this);
 
     return new_fh;
   }
 
   tree_anon_fcn_handle::~tree_anon_fcn_handle (void)
   {
     delete m_parameter_list;
     delete m_expression;
     delete m_scope;
   }
 
   tree_expression *
-  tree_anon_fcn_handle::dup (symbol_table::scope&) const
+  tree_anon_fcn_handle::dup (symbol_scope&) const
   {
     tree_parameter_list *param_list = parameter_list ();
     tree_expression *expr = expression ();
 
-    symbol_table::scope *af_scope = m_scope;
-    symbol_table::scope *af_parent_scope = m_parent_scope;
+    symbol_scope *af_scope = m_scope;
+    symbol_scope *af_parent_scope = m_parent_scope;
 
     symbol_table& symtab
       = __get_symbol_table__ ("tree_anon_fcn_handle::dup");
 
-    symbol_table::scope *new_scope = af_scope ? af_scope->dup () : nullptr;
+    symbol_scope *new_scope = af_scope ? af_scope->dup () : nullptr;
 
     // FIXME: why should we inherit from the current scope here?  That
     // doesn't seem right, but with the way things work now it appears
     // to be required for bug-31371.tst to pass.
 
     if (new_scope)
       symtab.inherit (new_scope);
 
diff --git a/libinterp/parse-tree/pt-fcn-handle.h b/libinterp/parse-tree/pt-fcn-handle.h
--- a/libinterp/parse-tree/pt-fcn-handle.h
+++ b/libinterp/parse-tree/pt-fcn-handle.h
@@ -68,17 +68,17 @@ namespace octave
 
     void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
                     bool pr_orig_txt = true);
 
     std::string name (void) const { return nm; }
 
     bool rvalue_ok (void) const { return true; }
 
-    tree_expression * dup (symbol_table::scope& scope) const;
+    tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_fcn_handle (*this);
     }
 
   private:
 
@@ -92,18 +92,18 @@ namespace octave
 
     tree_anon_fcn_handle (int l = -1, int c = -1)
       : tree_expression (l, c), m_parameter_list (nullptr),
         m_expression (nullptr), m_scope (nullptr), m_parent_scope (nullptr),
         m_file_name ()
     { }
 
     tree_anon_fcn_handle (tree_parameter_list *pl, tree_expression *ex,
-                          symbol_table::scope *scope,
-                          symbol_table::scope *parent_scope,
+                          symbol_scope *scope,
+                          symbol_scope *parent_scope,
                           int l = -1, int c = -1)
       : tree_expression (l, c), m_parameter_list (pl), m_expression (ex),
         m_scope (scope), m_parent_scope (parent_scope), m_file_name ()
     { }
 
     // No copying!
 
     tree_anon_fcn_handle (const tree_anon_fcn_handle&) = delete;
@@ -118,43 +118,43 @@ namespace octave
 
     tree_parameter_list * parameter_list (void) const
     {
       return m_parameter_list;
     }
 
     tree_expression * expression (void) const { return m_expression; }
 
-    symbol_table::scope *scope (void) const { return m_scope; }
+    symbol_scope *scope (void) const { return m_scope; }
 
-    symbol_table::scope *parent_scope (void) const { return m_parent_scope; }
+    symbol_scope *parent_scope (void) const { return m_parent_scope; }
 
     bool has_parent_scope (void) const { return m_parent_scope; }
 
-    tree_expression * dup (symbol_table::scope& scope) const;
+    tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw) { tw.visit_anon_fcn_handle (*this); }
 
     void stash_file_name (const std::string& file) { m_file_name = file; }
 
     std::string file_name (void) const { return m_file_name; }
 
   private:
 
     // Inputs parameters.
     tree_parameter_list *m_parameter_list;
 
     // Function body, limited to a single expression.
     tree_expression *m_expression;
 
     // Function scope.
-    symbol_table::scope *m_scope;
+    symbol_scope *m_scope;
 
     // Parent scope, or 0 if none.
-    symbol_table::scope *m_parent_scope;
+    symbol_scope *m_parent_scope;
 
     // Filename where the handle was defined.
     std::string m_file_name;
   };
 }
 
 #if defined (OCTAVE_USE_DEPRECATED_FUNCTIONS)
 
diff --git a/libinterp/parse-tree/pt-funcall.cc b/libinterp/parse-tree/pt-funcall.cc
--- a/libinterp/parse-tree/pt-funcall.cc
+++ b/libinterp/parse-tree/pt-funcall.cc
@@ -63,17 +63,17 @@ namespace octave
               os << ", ";
           }
 
         os << ')';
       }
   }
 
   tree_funcall *
-  tree_funcall::dup (symbol_table::scope&) const
+  tree_funcall::dup (symbol_scope&) const
   {
     tree_funcall *new_fc = new tree_funcall (fcn, args, line (), column ());
 
     new_fc->copy_base (*new_fc);
 
     return new_fc;
   }
 }
diff --git a/libinterp/parse-tree/pt-funcall.h b/libinterp/parse-tree/pt-funcall.h
--- a/libinterp/parse-tree/pt-funcall.h
+++ b/libinterp/parse-tree/pt-funcall.h
@@ -61,17 +61,17 @@ namespace octave
     bool has_magic_end (void) const { return false; }
 
     void print (std::ostream& os, bool pr_as_read_syntax = false,
                 bool pr_orig_txt = true);
 
     void print_raw (std::ostream& os, bool pr_as_read_syntax = false,
                     bool pr_orig_txt = true);
 
-    tree_funcall * dup (symbol_table::scope& scope) const;
+    tree_funcall * dup (symbol_scope& scope) const;
 
     octave_value function (void) const { return fcn; }
 
     octave_value_list arguments (void) const { return args; }
 
     void accept (tree_walker& tw)
     {
       tw.visit_funcall (*this);
diff --git a/libinterp/parse-tree/pt-id.cc b/libinterp/parse-tree/pt-id.cc
--- a/libinterp/parse-tree/pt-id.cc
+++ b/libinterp/parse-tree/pt-id.cc
@@ -62,22 +62,22 @@ namespace octave
   {
     if (sym.is_added_static ())
       static_workspace_error ();
 
     return octave_lvalue (sym);
   }
 
   tree_identifier *
-  tree_identifier::dup (symbol_table::scope& scope) const
+  tree_identifier::dup (symbol_scope& scope) const
   {
     // The new tree_identifier object contains a symbol_record
     // entry from the duplicated scope.
 
-    symbol_table::symbol_record new_sym = scope.find_symbol (name ());
+    symbol_record new_sym = scope.find_symbol (name ());
 
     tree_identifier *new_id
       = new tree_identifier (new_sym, line (), column ());
 
     new_id->copy_base (*this);
 
     return new_id;
   }
diff --git a/libinterp/parse-tree/pt-id.h b/libinterp/parse-tree/pt-id.h
--- a/libinterp/parse-tree/pt-id.h
+++ b/libinterp/parse-tree/pt-id.h
@@ -48,17 +48,17 @@ namespace octave
   {
     friend class tree_index_expression;
 
   public:
 
     tree_identifier (int l = -1, int c = -1)
       : tree_expression (l, c) { }
 
-    tree_identifier (const symbol_table::symbol_record& s,
+    tree_identifier (const symbol_record& s,
                      int l = -1, int c = -1)
       : tree_expression (l, c), sym (s) { }
 
     // No copying!
 
     tree_identifier (const tree_identifier&) = delete;
 
     tree_identifier& operator = (const tree_identifier&) = delete;
@@ -116,48 +116,48 @@ namespace octave
     void eval_undefined_error (void);
 
     void static_workspace_error (void)
     {
       error (R"(can not add variable "%s" to a static workspace)",
              name ().c_str ());
     }
 
-    tree_identifier * dup (symbol_table::scope& scope) const;
+    tree_identifier * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_identifier (*this);
     }
 
-    symbol_table::symbol_record symbol (void) const
+    symbol_record symbol (void) const
     {
       return sym;
     }
 
   private:
 
     // The symbol record that this identifier references.
-    symbol_table::symbol_record sym;
+    symbol_record sym;
   };
 
   class tree_black_hole : public tree_identifier
   {
   public:
 
     tree_black_hole (int l = -1, int c = -1)
       : tree_identifier (l, c) { }
 
     std::string name (void) const { return "~"; }
 
     bool is_variable (void) const { return false; }
 
     bool is_black_hole (void) { return true; }
 
-    tree_black_hole * dup (symbol_table::scope&) const
+    tree_black_hole * dup (symbol_scope&) const
     {
       return new tree_black_hole;
     }
 
     octave_lvalue lvalue (tree_evaluator *)
     {
       octave_lvalue retval;
       retval.mark_black_hole ();
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -381,17 +381,17 @@ namespace octave
       }
 
     retval.set_index (type, idx);
 
     return retval;
   }
 
   tree_index_expression *
-  tree_index_expression::dup (symbol_table::scope& scope) const
+  tree_index_expression::dup (symbol_scope& scope) const
   {
     tree_index_expression *new_idx_expr
       = new tree_index_expression (line (), column ());
 
     new_idx_expr->expr = (expr ? expr->dup (scope) : nullptr);
 
     std::list<tree_argument_list *> new_args;
 
diff --git a/libinterp/parse-tree/pt-idx.h b/libinterp/parse-tree/pt-idx.h
--- a/libinterp/parse-tree/pt-idx.h
+++ b/libinterp/parse-tree/pt-idx.h
@@ -89,17 +89,17 @@ namespace octave
     std::list<tree_expression *> dyn_fields (void) { return dyn_field; }
 
     bool lvalue_ok (void) const { return expr->lvalue_ok (); }
 
     bool rvalue_ok (void) const { return true; }
 
     octave_lvalue lvalue (tree_evaluator *tw);
 
-    tree_index_expression * dup (symbol_table::scope& scope) const;
+    tree_index_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_index_expression (*this);
     }
 
     std::string
     get_struct_index
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -1083,17 +1083,17 @@ void
         block->append (factory.create<jit_cond_branch> (check, tail, body));
       }
 
     blocks.push_back (tail);
     block = tail;
   }
 
   void
-  jit_convert::initialize (symbol_table::scope *s)
+  jit_convert::initialize (symbol_scope *s)
   {
     scope = s;
     iterator_count = 0;
     for_bounds_count = 0;
     short_count = 0;
     jit_instruction::reset_ids ();
 
     entry_block = factory.create<jit_block> ("body");
@@ -1131,17 +1131,17 @@ void
   jit_convert::get_variable (const std::string& vname)
   {
     jit_variable *ret = find_variable (vname);
     if (ret)
       return ret;
 
     symbol_table& symtab = __get_symbol_table__ ("jit_convert::find_variable");
 
-    symbol_table::symbol_record record = symtab.find_symbol (vname, scope);
+    symbol_record record = symtab.find_symbol (vname, scope);
     if (record.is_persistent () || record.is_global ())
       throw jit_fail_exception ("Persistent and global not yet supported");
 
     if (converting_function)
       return create_variable (vname, jit_typeinfo::get_any (), false);
     else
       {
         octave_value val = record.varval ();
@@ -2798,17 +2798,17 @@ void
 
   octave_value
   jit_info::find (const vmap& extra_vars, const std::string& vname) const
   {
     vmap::const_iterator iter = extra_vars.find (vname);
 
     if (iter == extra_vars.end ())
       {
-        symbol_table::scope *scope = __require_current_scope__ ("jit_convert::find");
+        symbol_scope *scope = __require_current_scope__ ("jit_convert::find");
 
         return scope->varval (vname);
       }
     else
       return *iter->second;
   }
 }
 
diff --git a/libinterp/parse-tree/pt-jit.h b/libinterp/parse-tree/pt-jit.h
--- a/libinterp/parse-tree/pt-jit.h
+++ b/libinterp/parse-tree/pt-jit.h
@@ -174,17 +174,17 @@ namespace octave
     void visit_do_until_command (tree_do_until_command&);
   private:
     std::vector<std::pair<std::string, bool>> arguments;
     type_bound_vector bounds;
 
     bool converting_function;
 
     // the scope of the function we are converting, or the current scope
-    symbol_table::scope *scope;
+    symbol_scope *scope;
 
     jit_factory factory;
 
     // used instead of return values from visit_* functions
     jit_value *result;
 
     jit_block *entry_block;
 
@@ -199,17 +199,17 @@ namespace octave
     std::vector<jit_magic_end::context> end_context;
 
     size_t iterator_count;
     size_t for_bounds_count;
     size_t short_count;
 
     variable_map vmap;
 
-    void initialize (symbol_table::scope *s);
+    void initialize (symbol_scope *s);
 
     jit_call * create_checked_impl (jit_call *ret);
 
     // get an existing vairable.  If the variable does not exist, it will not be
     // created
     jit_variable * find_variable (const std::string& vname) const;
 
     // get a variable, create it if it does not exist.  The type will default to
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -117,17 +117,17 @@ namespace octave
   maybe_warn_string_concat (bool all_dq_strings_p, bool all_sq_strings_p)
   {
     if (! (all_dq_strings_p || all_sq_strings_p))
       warning_with_id ("Octave:mixed-string-concat",
                        "concatenation of different character string types may have unintended consequences");
   }
 
   tree_expression *
-  tree_matrix::dup (symbol_table::scope& scope) const
+  tree_matrix::dup (symbol_scope& scope) const
   {
     tree_matrix *new_matrix = new tree_matrix (nullptr, line (), column ());
 
     new_matrix->copy_base (*this, scope);
 
     return new_matrix;
   }
 }
diff --git a/libinterp/parse-tree/pt-mat.h b/libinterp/parse-tree/pt-mat.h
--- a/libinterp/parse-tree/pt-mat.h
+++ b/libinterp/parse-tree/pt-mat.h
@@ -58,17 +58,17 @@ namespace octave
     tree_matrix& operator = (const tree_matrix&) = delete;
 
     ~tree_matrix (void) = default;
 
     bool is_matrix (void) const { return true; }
 
     bool rvalue_ok (void) const { return true; }
 
-    tree_expression * dup (symbol_table::scope& scope) const;
+    tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_matrix (*this);
     }
   };
 
   extern std::string
diff --git a/libinterp/parse-tree/pt-misc.cc b/libinterp/parse-tree/pt-misc.cc
--- a/libinterp/parse-tree/pt-misc.cc
+++ b/libinterp/parse-tree/pt-misc.cc
@@ -72,17 +72,17 @@ namespace octave
             break;
           }
       }
 
     return status;
   }
 
   tree_parameter_list *
-  tree_parameter_list::dup (symbol_table::scope& scope) const
+  tree_parameter_list::dup (symbol_scope& scope) const
   {
     tree_parameter_list *new_list = new tree_parameter_list ();
 
     if (takes_varargs ())
       new_list->mark_varargs ();
 
     for (const tree_decl_elt *elt : *this)
       new_list->append (elt->dup (scope));
diff --git a/libinterp/parse-tree/pt-misc.h b/libinterp/parse-tree/pt-misc.h
--- a/libinterp/parse-tree/pt-misc.h
+++ b/libinterp/parse-tree/pt-misc.h
@@ -75,17 +75,17 @@ namespace octave
     bool takes_varargs (void) const { return marked_for_varargs != 0; }
 
     bool varargs_only (void) { return (marked_for_varargs < 0); }
 
     bool is_defined (void);
 
     std::list<std::string> variable_names (void) const;
 
-    tree_parameter_list * dup (symbol_table::scope& scope) const;
+    tree_parameter_list * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_parameter_list (*this);
     }
 
   private:
 
diff --git a/libinterp/parse-tree/pt-unop.cc b/libinterp/parse-tree/pt-unop.cc
--- a/libinterp/parse-tree/pt-unop.cc
+++ b/libinterp/parse-tree/pt-unop.cc
@@ -35,31 +35,31 @@ namespace octave
   tree_unary_expression::oper (void) const
   {
     return octave_value::unary_op_as_string (etype);
   }
 
   // Prefix expressions.
 
   tree_expression *
-  tree_prefix_expression::dup (symbol_table::scope& scope) const
+  tree_prefix_expression::dup (symbol_scope& scope) const
   {
     tree_prefix_expression *new_pe
       = new tree_prefix_expression (op ? op->dup (scope) : nullptr,
                                     line (), column (), etype);
 
     new_pe->copy_base (*this);
 
     return new_pe;
   }
 
   // Postfix expressions.
 
   tree_expression *
-  tree_postfix_expression::dup (symbol_table::scope& scope) const
+  tree_postfix_expression::dup (symbol_scope& scope) const
   {
     tree_postfix_expression *new_pe
       = new tree_postfix_expression (op ? op->dup (scope) : nullptr,
                                      line (), column (), etype);
 
     new_pe->copy_base (*this);
 
     return new_pe;
diff --git a/libinterp/parse-tree/pt-unop.h b/libinterp/parse-tree/pt-unop.h
--- a/libinterp/parse-tree/pt-unop.h
+++ b/libinterp/parse-tree/pt-unop.h
@@ -100,17 +100,17 @@ namespace octave
     tree_prefix_expression (const tree_prefix_expression&) = delete;
 
     tree_prefix_expression& operator = (const tree_prefix_expression&) = delete;
 
     ~tree_prefix_expression (void) = default;
 
     bool rvalue_ok (void) const { return true; }
 
-    tree_expression * dup (symbol_table::scope& scope) const;
+    tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_prefix_expression (*this);
     }
 
     std::string profiler_name (void) const { return "prefix " + oper (); }
   };
@@ -134,17 +134,17 @@ namespace octave
     tree_postfix_expression (const tree_postfix_expression&) = delete;
 
     tree_postfix_expression& operator = (const tree_postfix_expression&) = delete;
 
     ~tree_postfix_expression (void) = default;
 
     bool rvalue_ok (void) const { return true; }
 
-    tree_expression * dup (symbol_table::scope& scope) const;
+    tree_expression * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_postfix_expression (*this);
     }
 
     std::string profiler_name (void) const { return "postfix " + oper (); }
   };
diff --git a/libinterp/parse-tree/token.cc b/libinterp/parse-tree/token.cc
--- a/libinterp/parse-tree/token.cc
+++ b/libinterp/parse-tree/token.cc
@@ -62,17 +62,17 @@ namespace octave
   { }
 
   token::token (int tv, end_tok_type t, int l, int c)
     : m_maybe_cmd (false), m_tspc (false), m_line_num (l), m_column_num (c),
       m_tok_val (tv), m_type_tag (ettype_token), m_tok_info (t),
       m_orig_text ()
   { }
 
-  token::token (int tv, const symbol_table::symbol_record& sr, int l, int c)
+  token::token (int tv, const symbol_record& sr, int l, int c)
     : m_maybe_cmd (false), m_tspc (false), m_line_num (l), m_column_num (c),
       m_tok_val (tv), m_type_tag (sym_rec_token), m_tok_info (sr),
       m_orig_text ()
   { }
 
   token::token (int tv, const std::string& method_nm,
                 const std::string& class_nm, int l, int c)
     : m_maybe_cmd (false), m_tspc (false), m_line_num (l), m_column_num (c),
@@ -121,17 +121,17 @@ namespace octave
 
   token::end_tok_type
   token::ettype (void) const
   {
     assert (m_type_tag == ettype_token);
     return m_tok_info.m_et;
   }
 
-  symbol_table::symbol_record
+  symbol_record
   token::sym_rec (void) const
   {
     assert (m_type_tag == sym_rec_token);
     return *m_tok_info.m_sr;
   }
 
   std::string
   token::superclass_method_name (void) const
diff --git a/libinterp/parse-tree/token.h b/libinterp/parse-tree/token.h
--- a/libinterp/parse-tree/token.h
+++ b/libinterp/parse-tree/token.h
@@ -67,17 +67,17 @@ namespace octave
 
     token (int tv, int l = -1, int c = -1);
     token (int tv, bool is_keyword, int l = -1, int c = -1);
     token (int tv, const char *s, int l = -1, int c = -1);
     token (int tv, const std::string& s, int l = -1, int c = -1);
     token (int tv, double d, const std::string& s = "",
            int l = -1, int c = -1);
     token (int tv, end_tok_type t, int l = -1, int c = -1);
-    token (int tv, const symbol_table::symbol_record& s,
+    token (int tv, const symbol_record& s,
            int l = -1, int c = -1);
     token (int tv, const std::string& mth, const std::string& cls,
            int l = -1, int c = -1);
 
     // No copying!
 
     token (const token&) = delete;
 
@@ -107,17 +107,17 @@ namespace octave
       return m_type_tag == sym_rec_token;
     }
 
     std::string text (void) const;
     std::string symbol_name (void) const;
     double number (void) const;
     token_type ttype (void) const;
     end_tok_type ettype (void) const;
-    symbol_table::symbol_record sym_rec (void) const;
+    symbol_record sym_rec (void) const;
 
     std::string superclass_method_name (void) const;
     std::string superclass_class_name (void) const;
 
     std::string text_rep (void) const;
 
   private:
 
@@ -140,18 +140,18 @@ namespace octave
       tok_info (const char *s) : m_str (new std::string (s)) { }
 
       tok_info (const std::string& str) : m_str (new std::string (str)) { }
 
       tok_info (double num) : m_num (num) { }
 
       tok_info (end_tok_type et) : m_et (et) { }
 
-      tok_info (const symbol_table::symbol_record& sr)
-        : m_sr (new symbol_table::symbol_record (sr))
+      tok_info (const symbol_record& sr)
+        : m_sr (new symbol_record (sr))
       { }
 
       tok_info (const std::string& method_nm, const std::string& class_nm)
         : m_superclass_info (new superclass_info (method_nm, class_nm))
       { }
 
       tok_info (const tok_info&) = delete;
 
@@ -160,17 +160,17 @@ namespace octave
       ~tok_info (void) { }
 
       std::string *m_str;
 
       double m_num;
 
       end_tok_type m_et;
 
-      symbol_table::symbol_record *m_sr;
+      symbol_record *m_sr;
 
       struct superclass_info
       {
         superclass_info (void) = delete;
 
         superclass_info (const std::string& method_nm,
                          const std::string& class_nm)
           : m_method_nm (method_nm), m_class_nm (class_nm)
