# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1253692816 -7200
#      Wed Sep 23 10:00:16 2009 +0200
# Node ID afcf852256d2e69353a263f7a6854a4c0e76258d
# Parent  0256e187d13b1753a77f8a76d51aca3c67f166df
optimize / and '\ for triangular matrices

diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -1847,17 +1847,17 @@ ComplexMatrix::rcond (MatrixType &mattyp
 
   return rcon;
 }
 
 ComplexMatrix
 ComplexMatrix::utsolve (MatrixType &mattype, const ComplexMatrix& b, 
 			octave_idx_type& info, double& rcon, 
 			solve_singularity_handler sing_handler,
-			bool calc_cond) const
+			bool calc_cond, blas_trans_type transt) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
@@ -1923,17 +1923,17 @@ ComplexMatrix::utsolve (MatrixType &matt
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  Complex *result = retval.fortran_vec ();
 
 		  char uplo = 'U';
-		  char trans = 'N';
+		  char trans = get_blas_char (transt);
 		  char dia = 'N';
 
 		  F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&trans, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
 					     nr, b_nc, tmp_data, nr,
 					     result, nr, info
 					     F77_CHAR_ARG_LEN (1)
@@ -1948,17 +1948,17 @@ ComplexMatrix::utsolve (MatrixType &matt
 
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::ltsolve (MatrixType &mattype, const ComplexMatrix& b, 
 			octave_idx_type& info, double& rcon, 
 			solve_singularity_handler sing_handler,
-			bool calc_cond) const
+			bool calc_cond, blas_trans_type transt) const
 {
   ComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
@@ -2024,17 +2024,17 @@ ComplexMatrix::ltsolve (MatrixType &matt
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  Complex *result = retval.fortran_vec ();
 
 		  char uplo = 'L';
-		  char trans = 'N';
+		  char trans = get_blas_char (transt);
 		  char dia = 'N';
 
 		  F77_XFCN (ztrtrs, ZTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&trans, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
 					     nr, b_nc, tmp_data, nr,
 					     result, nr, info
 					     F77_CHAR_ARG_LEN (1)
@@ -2255,20 +2255,20 @@ ComplexMatrix::solve (MatrixType &typ, c
 		      double& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
 		      double& rcon, solve_singularity_handler sing_handler,
-		      bool singular_fallback) const
+		      bool singular_fallback, blas_trans_type transt) const
 {
   ComplexMatrix tmp (b);
-  return solve (typ, tmp, info, rcon, sing_handler, singular_fallback);
+  return solve (typ, tmp, info, rcon, sing_handler, singular_fallback, transt);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &typ, const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (typ, b, info, rcon, 0);
@@ -2288,29 +2288,33 @@ ComplexMatrix::solve (MatrixType &typ, c
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (MatrixType &mattype, const ComplexMatrix& b, 
 		      octave_idx_type& info, double& rcon,
 		      solve_singularity_handler sing_handler,
-		      bool singular_fallback) const
+		      bool singular_fallback, blas_trans_type transt) const
 {
   ComplexMatrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   // Only calculate the condition number for LU/Cholesky
   if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
-    retval = utsolve (mattype, b, info, rcon, sing_handler, false);
+    retval = utsolve (mattype, b, info, rcon, sing_handler, false, transt);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
-    retval = ltsolve (mattype, b, info, rcon, sing_handler, false);
+    retval = ltsolve (mattype, b, info, rcon, sing_handler, false, transt);
+  else if (transt == blas_trans)
+    return transpose ().solve (mattype, b, info, rcon, sing_handler, singular_fallback);
+  else if (transt == blas_conj_trans)
+    retval = hermitian ().solve (mattype, b, info, rcon, sing_handler, singular_fallback);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, info, rcon, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return ComplexMatrix ();
     }
 
@@ -2345,19 +2349,19 @@ ComplexMatrix::solve (MatrixType &typ, c
 		      octave_idx_type& info, double& rcon) const
 {
   return solve (typ, ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ColumnVector& b, 
 		      octave_idx_type& info, double& rcon,
-		      solve_singularity_handler sing_handler) const
+		      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
-  return solve (typ, ComplexColumnVector (b), info, rcon, sing_handler);
+  return solve (typ, ComplexColumnVector (b), info, rcon, sing_handler, transt);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (typ, b, info, rcon, 0);
@@ -2376,21 +2380,21 @@ ComplexMatrix::solve (MatrixType &typ, c
 		      octave_idx_type& info, double& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (MatrixType &typ, const ComplexColumnVector& b,
 		      octave_idx_type& info, double& rcon,
-		      solve_singularity_handler sing_handler) const
+		      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
 
   ComplexMatrix tmp (b);
-  return solve (typ, tmp, info, rcon, sing_handler).column(static_cast<octave_idx_type> (0));
+  return solve (typ, tmp, info, rcon, sing_handler, transt).column(static_cast<octave_idx_type> (0));
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const Matrix& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (b, info, rcon, 0);
@@ -2406,20 +2410,20 @@ ComplexMatrix::solve (const Matrix& b, o
 ComplexMatrix
 ComplexMatrix::solve (const Matrix& b, octave_idx_type& info, double& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const Matrix& b, octave_idx_type& info, double& rcon,
-		      solve_singularity_handler sing_handler) const
+		      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   ComplexMatrix tmp (b);
-  return solve (tmp, info, rcon, sing_handler);
+  return solve (tmp, info, rcon, sing_handler, transt);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const ComplexMatrix& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (b, info, rcon, 0);
@@ -2435,20 +2439,20 @@ ComplexMatrix::solve (const ComplexMatri
 ComplexMatrix
 ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon,
-		      solve_singularity_handler sing_handler) const
+		      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   MatrixType mattype (*this);
-  return solve (mattype, b, info, rcon, sing_handler);
+  return solve (mattype, b, info, rcon, sing_handler, true, transt);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (ComplexColumnVector (b), info, rcon, 0);
@@ -2466,19 +2470,19 @@ ComplexMatrix::solve (const ColumnVector
 		      double& rcon) const
 {
   return solve (ComplexColumnVector (b), info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ColumnVector& b, octave_idx_type& info, 
 		      double& rcon, 
-		      solve_singularity_handler sing_handler) const
+		      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
-  return solve (ComplexColumnVector (b), info, rcon, sing_handler);
+  return solve (ComplexColumnVector (b), info, rcon, sing_handler, transt);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (b, info, rcon, 0);
@@ -2496,20 +2500,20 @@ ComplexMatrix::solve (const ComplexColum
 		      double& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b, octave_idx_type& info,
 		      double& rcon,
-		      solve_singularity_handler sing_handler) const
+		      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   MatrixType mattype (*this);
-  return solve (mattype, b, info, rcon, sing_handler);
+  return solve (mattype, b, info, rcon, sing_handler, transt);
 }
 
 ComplexMatrix
 ComplexMatrix::lssolve (const Matrix& b) const
 {
   octave_idx_type info;
   octave_idx_type rank;
   double rcon;
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -185,97 +185,105 @@ public:
   double rcond (void) const;
   double rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
   ComplexMatrix utsolve (MatrixType &typ, const ComplexMatrix& b,
 		  octave_idx_type& info, double& rcon, 
 		  solve_singularity_handler sing_handler,
-		  bool calc_cond = false) const;
+		  bool calc_cond = false, 
+                  blas_trans_type transt = blas_no_trans) const;
 
   // Lower triangular matrix solvers
   ComplexMatrix ltsolve (MatrixType &typ, const ComplexMatrix& b,
 		  octave_idx_type& info, double& rcon, 
 		  solve_singularity_handler sing_handler,
-		  bool calc_cond = false) const;
+		  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
 
   // Full matrix solvers (umfpack/cholesky)
   ComplexMatrix fsolve (MatrixType &typ, const ComplexMatrix& b,
 		 octave_idx_type& info, double& rcon, 
 		 solve_singularity_handler sing_handler,
 		 bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   ComplexMatrix solve (MatrixType &typ, const Matrix& b) const;
   ComplexMatrix solve (MatrixType &typ, const Matrix& b, 
 		       octave_idx_type& info) const;
   ComplexMatrix solve (MatrixType &typ, const Matrix& b, 
 		       octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
 		       double& rcon, solve_singularity_handler sing_handler,
-		       bool singular_fallback = true) const;
+		       bool singular_fallback = true, 
+                       blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
 		       octave_idx_type& info) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
 		       octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
 		       octave_idx_type& info, double& rcon,
 		       solve_singularity_handler sing_handler,
-		       bool singular_fallback = true) const;
+		       bool singular_fallback = true, 
+                       blas_trans_type transt = blas_no_trans) const;
 
   ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
   ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
 			     octave_idx_type& info) const;
   ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
 			     octave_idx_type& info, double& rcon) const;
   ComplexColumnVector solve (MatrixType &typ, const ColumnVector& b, 
 			     octave_idx_type& info, double& rcon,
-			     solve_singularity_handler sing_handler) const;
+			     solve_singularity_handler sing_handler, 
+                             blas_trans_type transt = blas_no_trans) const;
 
   ComplexColumnVector solve (MatrixType &typ, 
 			     const ComplexColumnVector& b) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
 			     octave_idx_type& info) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
 			     octave_idx_type& info, double& rcon) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
 			     octave_idx_type& info, double& rcon,
-			     solve_singularity_handler sing_handler) const;
+			     solve_singularity_handler sing_handler, 
+                             blas_trans_type transt = blas_no_trans) const;
 
   // Generic interface to solver with probing of type
   ComplexMatrix solve (const Matrix& b) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (const Matrix& b, octave_idx_type& info, double& rcon,
-		       solve_singularity_handler sing_handler) const;
+		       solve_singularity_handler sing_handler, 
+                       blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon,
-		       solve_singularity_handler sing_handler) const;
+		       solve_singularity_handler sing_handler, 
+                       blas_trans_type transt = blas_no_trans) const;
 
   ComplexColumnVector solve (const ColumnVector& b) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info,
 			     double& rcon) const;
   ComplexColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcon,
-			     solve_singularity_handler sing_handler) const;
+			     solve_singularity_handler sing_handler, 
+                             blas_trans_type transt = blas_no_trans) const;
 
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
 			     double& rcon) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-			     double& rcon,
-			     solve_singularity_handler sing_handler) const;
+			     double& rcon, solve_singularity_handler sing_handler, 
+                             blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix lssolve (const Matrix& b) const;
   ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info) const;
   ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info, 
 			 octave_idx_type& rank) const;
   ComplexMatrix lssolve (const Matrix& b, octave_idx_type& info, 
 			 octave_idx_type& rank, double& rcon) const;
 
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,22 @@
+2009-09-23  Jaroslav Hajek  <highegg@gmail.com>
+
+	* mx-defs.h (blas_trans_type): New enum.
+	(get_blas_char): New inline func.
+	* dMatrix.cc (Matrix::utsolve, Matrix::ltsolve, Matrix::solve):
+	Support transt parameter.
+	* fMatrix.cc (FloatMatrix::utsolve, FloatMatrix::ltsolve,
+	FloatMatrix::solve): Ditto.
+	* CMatrix.cc (ComplexMatrix::utsolve, ComplexMatrix::ltsolve,
+	ComplexMatrix::solve): Ditto.
+	* fCMatrix.cc (FloatComplexMatrix::utsolve,
+	FloatComplexMatrix::ltsolve, FloatComplexMatrix::solve): Ditto.
+	* dMatrix.h, fMatrix.h, CMatrix.h, fCMatrix.h: Update.
+
 2009-09-21  Jaroslav Hajek  <highegg@gmail.com>
 
 	* mx-op-defs.h (VS_BIN_OP, SV_BIN_OP, VV_BIN_OP): Simplify.
 
 2009-09-19  Jaroslav Hajek  <highegg@gmail.com>
 
 	* dNDArray.h (NDArray::matrix_type): New typedef.
 	* fNDArray.h (FloatNDArray::matrix_type): New typedef.
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -1518,17 +1518,17 @@ Matrix::rcond (MatrixType &mattype) cons
     }
 
   return rcon;
 }
 
 Matrix
 Matrix::utsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
 		double& rcon, solve_singularity_handler sing_handler,
-		bool calc_cond) const
+		bool calc_cond, blas_trans_type transt) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
@@ -1594,17 +1594,17 @@ Matrix::utsolve (MatrixType &mattype, co
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  double *result = retval.fortran_vec ();
 
 		  char uplo = 'U';
-		  char trans = 'N';
+		  char trans = get_blas_char (transt);
 		  char dia = 'N';
 
 		  F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&trans, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
 					     nr, b_nc, tmp_data, nr,
 					     result, nr, info
 					     F77_CHAR_ARG_LEN (1)
@@ -1618,17 +1618,17 @@ Matrix::utsolve (MatrixType &mattype, co
     }
 
   return retval;
 }
 
 Matrix
 Matrix::ltsolve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
 		double& rcon, solve_singularity_handler sing_handler,
-		bool calc_cond) const
+		bool calc_cond, blas_trans_type transt) const
 {
   Matrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
@@ -1694,17 +1694,17 @@ Matrix::ltsolve (MatrixType &mattype, co
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  double *result = retval.fortran_vec ();
 
 		  char uplo = 'L';
-		  char trans = 'N';
+		  char trans = get_blas_char (transt);
 		  char dia = 'N';
 
 		  F77_XFCN (dtrtrs, DTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&trans, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
 					     nr, b_nc, tmp_data, nr,
 					     result, nr, info
 					     F77_CHAR_ARG_LEN (1)
@@ -1915,29 +1915,31 @@ Matrix::solve (MatrixType &typ, const Ma
 	       double& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 Matrix
 Matrix::solve (MatrixType &mattype, const Matrix& b, octave_idx_type& info,
 	       double& rcon, solve_singularity_handler sing_handler,
-	       bool singular_fallback) const
+	       bool singular_fallback, blas_trans_type transt) const
 {
   Matrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   // Only calculate the condition number for LU/Cholesky
   if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
-    retval = utsolve (mattype, b, info, rcon, sing_handler, false);
+    retval = utsolve (mattype, b, info, rcon, sing_handler, false, transt);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
-    retval = ltsolve (mattype, b, info, rcon, sing_handler, false);
+    retval = ltsolve (mattype, b, info, rcon, sing_handler, false, transt);
+  else if (transt == blas_trans || transt == blas_conj_trans)
+    return transpose ().solve (mattype, b, info, rcon, sing_handler, singular_fallback);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, info, rcon, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return Matrix ();
     }
 
@@ -1972,20 +1974,20 @@ Matrix::solve (MatrixType &typ, const Co
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info, rcon);
 }
 
 ComplexMatrix
 Matrix::solve (MatrixType &typ, const ComplexMatrix& b, octave_idx_type& info,
 	       double& rcon, solve_singularity_handler sing_handler,
-	       bool singular_fallback) const
+	       bool singular_fallback, blas_trans_type transt) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.solve (typ, b, info, rcon, sing_handler, singular_fallback);
+  return tmp.solve (typ, b, info, rcon, sing_handler, singular_fallback, transt);
 }
 
 ColumnVector
 Matrix::solve (MatrixType &typ, const ColumnVector& b) const
 {
   octave_idx_type info; double rcon;
   return solve (typ, b, info, rcon);
 }
@@ -2002,20 +2004,20 @@ ColumnVector
 Matrix::solve (MatrixType &typ, const ColumnVector& b, octave_idx_type& info,
 	       double& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 ColumnVector
 Matrix::solve (MatrixType &typ, const ColumnVector& b, octave_idx_type& info,
-	       double& rcon, solve_singularity_handler sing_handler) const
+	       double& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   Matrix tmp (b);
-  return solve (typ, tmp, info, rcon, sing_handler).column(static_cast<octave_idx_type> (0));
+  return solve (typ, tmp, info, rcon, sing_handler, transt).column(static_cast<octave_idx_type> (0));
 }
 
 ComplexColumnVector
 Matrix::solve (MatrixType &typ, const ComplexColumnVector& b) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (typ, b);
 }
@@ -2034,20 +2036,20 @@ Matrix::solve (MatrixType &typ, const Co
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info, rcon);
 }
 
 ComplexColumnVector
 Matrix::solve (MatrixType &typ, const ComplexColumnVector& b, 
 	       octave_idx_type& info, double& rcon,
-	       solve_singularity_handler sing_handler) const
+	       solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.solve(typ, b, info, rcon, sing_handler);
+  return tmp.solve(typ, b, info, rcon, sing_handler, transt);
 }
 
 Matrix
 Matrix::solve (const Matrix& b) const
 {
   octave_idx_type info;
   double rcon;
   return solve (b, info, rcon, 0);
@@ -2063,20 +2065,20 @@ Matrix::solve (const Matrix& b, octave_i
 Matrix
 Matrix::solve (const Matrix& b, octave_idx_type& info, double& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 Matrix
 Matrix::solve (const Matrix& b, octave_idx_type& info,
-	       double& rcon, solve_singularity_handler sing_handler) const
+	       double& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   MatrixType mattype (*this);
-  return solve (mattype, b, info, rcon, sing_handler);
+  return solve (mattype, b, info, rcon, sing_handler, true, transt);
 }
 
 ComplexMatrix
 Matrix::solve (const ComplexMatrix& b) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b);
 }
@@ -2092,20 +2094,20 @@ ComplexMatrix
 Matrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon);
 }
 
 ComplexMatrix
 Matrix::solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon,
-	       solve_singularity_handler sing_handler) const
+	       solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.solve (b, info, rcon, sing_handler);
+  return tmp.solve (b, info, rcon, sing_handler, transt);
 }
 
 ColumnVector
 Matrix::solve (const ColumnVector& b) const
 {
   octave_idx_type info; double rcon;
   return solve (b, info, rcon);
 }
@@ -2120,20 +2122,20 @@ Matrix::solve (const ColumnVector& b, oc
 ColumnVector
 Matrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 ColumnVector
 Matrix::solve (const ColumnVector& b, octave_idx_type& info, double& rcon,
-	       solve_singularity_handler sing_handler) const
+	       solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   MatrixType mattype (*this);
-  return solve (mattype, b, info, rcon, sing_handler);
+  return solve (mattype, b, info, rcon, sing_handler, transt);
 }
 
 ComplexColumnVector
 Matrix::solve (const ComplexColumnVector& b) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b);
 }
@@ -2149,20 +2151,20 @@ ComplexColumnVector
 Matrix::solve (const ComplexColumnVector& b, octave_idx_type& info, double& rcon) const
 {
   ComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon);
 }
 
 ComplexColumnVector
 Matrix::solve (const ComplexColumnVector& b, octave_idx_type& info, double& rcon,
-	       solve_singularity_handler sing_handler) const
+	       solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   ComplexMatrix tmp (*this);
-  return tmp.solve (b, info, rcon, sing_handler);
+  return tmp.solve (b, info, rcon, sing_handler, transt);
 }
 
 Matrix
 Matrix::lssolve (const Matrix& b) const
 {
   octave_idx_type info;
   octave_idx_type rank;
   double rcon;
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -157,93 +157,99 @@ public:
 
   double rcond (void) const;
   double rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
   Matrix utsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
 		  double& rcon, solve_singularity_handler sing_handler,
-		  bool calc_cond = false) const;
+		  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
 
   // Lower triangular matrix solvers
   Matrix ltsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
 		  double& rcon, solve_singularity_handler sing_handler,
-		  bool calc_cond = false) const;
+		  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
 
   // Full matrix solvers (lu/cholesky)
   Matrix fsolve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
 		 double& rcon, solve_singularity_handler sing_handler,
 		 bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   Matrix solve (MatrixType &typ, const Matrix& b) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info, 
 		double& rcon) const;
   Matrix solve (MatrixType &typ, const Matrix& b, octave_idx_type& info,
 		double& rcon, solve_singularity_handler sing_handler,
-		bool singular_fallback = true) const;
+		bool singular_fallback = true, blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
 		       octave_idx_type& info) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
 		       octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (MatrixType &typ, const ComplexMatrix& b, 
 		       octave_idx_type& info, double& rcon,
 		       solve_singularity_handler sing_handler,
-		       bool singular_fallback = true) const;
+		       bool singular_fallback = true, 
+                       blas_trans_type transt = blas_no_trans) const;
 
   ColumnVector solve (MatrixType &typ, const ColumnVector& b) const;
   ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
 		      octave_idx_type& info) const;
   ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
 		      octave_idx_type& info, double& rcon) const;
   ColumnVector solve (MatrixType &typ, const ColumnVector& b, 
 		      octave_idx_type& info, double& rcon,
-		      solve_singularity_handler sing_handler) const;
+		      solve_singularity_handler sing_handler, 
+                      blas_trans_type transt = blas_no_trans) const;
 
   ComplexColumnVector solve (MatrixType &typ, 
 			     const ComplexColumnVector& b) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
 			     octave_idx_type& info) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
 			     octave_idx_type& info, double& rcon) const;
   ComplexColumnVector solve (MatrixType &typ, const ComplexColumnVector& b, 
 			     octave_idx_type& info, double& rcon,
-			     solve_singularity_handler sing_handler) const;
+			     solve_singularity_handler sing_handler, 
+                             blas_trans_type transt = blas_no_trans) const;
 
   // Generic interface to solver with probing of type
   Matrix solve (const Matrix& b) const;
   Matrix solve (const Matrix& b, octave_idx_type& info) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcon) const;
   Matrix solve (const Matrix& b, octave_idx_type& info, double& rcon,
-		solve_singularity_handler sing_handler) const;
+		solve_singularity_handler sing_handler, 
+                blas_trans_type transt = blas_no_trans) const;
 
   ComplexMatrix solve (const ComplexMatrix& b) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon) const;
   ComplexMatrix solve (const ComplexMatrix& b, octave_idx_type& info, double& rcon,
-		       solve_singularity_handler sing_handler) const;
+		       solve_singularity_handler sing_handler, 
+                       blas_trans_type transt = blas_no_trans) const;
 
   ColumnVector solve (const ColumnVector& b) const;
   ColumnVector solve (const ColumnVector& b, octave_idx_type& info) const;
   ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcon) const;
   ColumnVector solve (const ColumnVector& b, octave_idx_type& info, double& rcon,
-		      solve_singularity_handler sing_handler) const;
+		      solve_singularity_handler sing_handler, 
+                      blas_trans_type transt = blas_no_trans) const;
 
   ComplexColumnVector solve (const ComplexColumnVector& b) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
 			     double& rcon) const;
   ComplexColumnVector solve (const ComplexColumnVector& b, octave_idx_type& info,
-			     double& rcon,
-			     solve_singularity_handler sing_handler) const;
+			     double& rcon, solve_singularity_handler sing_handler, 
+                             blas_trans_type transt = blas_no_trans) const;
 
   // Singular solvers
   Matrix lssolve (const Matrix& b) const;
   Matrix lssolve (const Matrix& b, octave_idx_type& info) const;
   Matrix lssolve (const Matrix& b, octave_idx_type& info, 
 		  octave_idx_type& rank) const;
   Matrix lssolve (const Matrix& b, octave_idx_type& info, 
 		  octave_idx_type& rank, double& rcon) const;
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -1840,17 +1840,17 @@ FloatComplexMatrix::rcond (MatrixType &m
 
   return rcon;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::utsolve (MatrixType &mattype, const FloatComplexMatrix& b, 
 			octave_idx_type& info, float& rcon, 
 			solve_singularity_handler sing_handler,
-			bool calc_cond) const
+			bool calc_cond, blas_trans_type transt) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
@@ -1916,17 +1916,17 @@ FloatComplexMatrix::utsolve (MatrixType 
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  FloatComplex *result = retval.fortran_vec ();
 
 		  char uplo = 'U';
-		  char trans = 'N';
+		  char trans = get_blas_char (transt);
 		  char dia = 'N';
 
 		  F77_XFCN (ctrtrs, CTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&trans, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
 					     nr, b_nc, tmp_data, nr,
 					     result, nr, info
 					     F77_CHAR_ARG_LEN (1)
@@ -1941,17 +1941,17 @@ FloatComplexMatrix::utsolve (MatrixType 
 
   return retval;
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::ltsolve (MatrixType &mattype, const FloatComplexMatrix& b, 
 			octave_idx_type& info, float& rcon, 
 			solve_singularity_handler sing_handler,
-			bool calc_cond) const
+			bool calc_cond, blas_trans_type transt) const
 {
   FloatComplexMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
@@ -2017,17 +2017,17 @@ FloatComplexMatrix::ltsolve (MatrixType 
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  FloatComplex *result = retval.fortran_vec ();
 
 		  char uplo = 'L';
-		  char trans = 'N';
+		  char trans = get_blas_char (transt);
 		  char dia = 'N';
 
 		  F77_XFCN (ctrtrs, CTRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&trans, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
 					     nr, b_nc, tmp_data, nr,
 					     result, nr, info
 					     F77_CHAR_ARG_LEN (1)
@@ -2248,20 +2248,20 @@ FloatComplexMatrix::solve (MatrixType &t
 		      float& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info, 
 		      float& rcon, solve_singularity_handler sing_handler,
-		      bool singular_fallback) const
+		      bool singular_fallback, blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (b);
-  return solve (typ, tmp, info, rcon, sing_handler, singular_fallback);
+  return solve (typ, tmp, info, rcon, sing_handler, singular_fallback, transt);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (typ, b, info, rcon, 0);
@@ -2281,29 +2281,33 @@ FloatComplexMatrix::solve (MatrixType &t
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (MatrixType &mattype, const FloatComplexMatrix& b, 
 		      octave_idx_type& info, float& rcon,
 		      solve_singularity_handler sing_handler,
-		      bool singular_fallback) const
+		      bool singular_fallback, blas_trans_type transt) const
 {
   FloatComplexMatrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   // Only calculate the condition number for LU/Cholesky
   if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
-    retval = utsolve (mattype, b, info, rcon, sing_handler, false);
+    retval = utsolve (mattype, b, info, rcon, sing_handler, false, transt);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
-    retval = ltsolve (mattype, b, info, rcon, sing_handler, false);
+    retval = ltsolve (mattype, b, info, rcon, sing_handler, false, transt);
+  else if (transt == blas_trans)
+    return transpose ().solve (mattype, b, info, rcon, sing_handler, singular_fallback);
+  else if (transt == blas_conj_trans)
+    retval = hermitian ().solve (mattype, b, info, rcon, sing_handler, singular_fallback);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, info, rcon, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return FloatComplexMatrix ();
     }
 
@@ -2338,19 +2342,19 @@ FloatComplexMatrix::solve (MatrixType &t
 		      octave_idx_type& info, float& rcon) const
 {
   return solve (typ, FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatColumnVector& b, 
 		      octave_idx_type& info, float& rcon,
-		      solve_singularity_handler sing_handler) const
+		      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
-  return solve (typ, FloatComplexColumnVector (b), info, rcon, sing_handler);
+  return solve (typ, FloatComplexColumnVector (b), info, rcon, sing_handler, transt);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (typ, b, info, rcon, 0);
@@ -2369,21 +2373,21 @@ FloatComplexMatrix::solve (MatrixType &t
 		      octave_idx_type& info, float& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b,
 		      octave_idx_type& info, float& rcon,
-		      solve_singularity_handler sing_handler) const
+		      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
 
   FloatComplexMatrix tmp (b);
-  return solve (typ, tmp, info, rcon, sing_handler).column(static_cast<octave_idx_type> (0));
+  return solve (typ, tmp, info, rcon, sing_handler, transt).column(static_cast<octave_idx_type> (0));
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (b, info, rcon, 0);
@@ -2399,20 +2403,20 @@ FloatComplexMatrix::solve (const FloatMa
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatMatrix& b, octave_idx_type& info, float& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatMatrix& b, octave_idx_type& info, float& rcon,
-		      solve_singularity_handler sing_handler) const
+		      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (b);
-  return solve (tmp, info, rcon, sing_handler);
+  return solve (tmp, info, rcon, sing_handler, transt);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatComplexMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (b, info, rcon, 0);
@@ -2428,20 +2432,20 @@ FloatComplexMatrix::solve (const FloatCo
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon,
-		      solve_singularity_handler sing_handler) const
+		      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   MatrixType mattype (*this);
-  return solve (mattype, b, info, rcon, sing_handler);
+  return solve (mattype, b, info, rcon, sing_handler, true, transt);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatColumnVector& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (FloatComplexColumnVector (b), info, rcon, 0);
@@ -2459,19 +2463,19 @@ FloatComplexMatrix::solve (const FloatCo
 		      float& rcon) const
 {
   return solve (FloatComplexColumnVector (b), info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatColumnVector& b, octave_idx_type& info, 
 		      float& rcon, 
-		      solve_singularity_handler sing_handler) const
+		      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
-  return solve (FloatComplexColumnVector (b), info, rcon, sing_handler);
+  return solve (FloatComplexColumnVector (b), info, rcon, sing_handler, transt);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatComplexColumnVector& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (b, info, rcon, 0);
@@ -2489,20 +2493,20 @@ FloatComplexMatrix::solve (const FloatCo
 		      float& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 FloatComplexColumnVector
 FloatComplexMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info,
 		      float& rcon,
-		      solve_singularity_handler sing_handler) const
+		      solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   MatrixType mattype (*this);
-  return solve (mattype, b, info, rcon, sing_handler);
+  return solve (mattype, b, info, rcon, sing_handler, transt);
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::lssolve (const FloatMatrix& b) const
 {
   octave_idx_type info;
   octave_idx_type rank;
   float rcon;
diff --git a/liboctave/fCMatrix.h b/liboctave/fCMatrix.h
--- a/liboctave/fCMatrix.h
+++ b/liboctave/fCMatrix.h
@@ -185,97 +185,105 @@ public:
   float rcond (void) const;
   float rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
   FloatComplexMatrix utsolve (MatrixType &typ, const FloatComplexMatrix& b,
 		  octave_idx_type& info, float& rcon, 
 		  solve_singularity_handler sing_handler,
-		  bool calc_cond = false) const;
+		  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
 
   // Lower triangular matrix solvers
   FloatComplexMatrix ltsolve (MatrixType &typ, const FloatComplexMatrix& b,
 		  octave_idx_type& info, float& rcon, 
 		  solve_singularity_handler sing_handler,
-		  bool calc_cond = false) const;
+		  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
 
   // Full matrix solvers (umfpack/cholesky)
   FloatComplexMatrix fsolve (MatrixType &typ, const FloatComplexMatrix& b,
 		 octave_idx_type& info, float& rcon, 
 		 solve_singularity_handler sing_handler,
 		 bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b, 
 		       octave_idx_type& info) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b, 
 		       octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
 		       float& rcon, solve_singularity_handler sing_handler,
-		       bool singular_fallback = true) const;
+		       bool singular_fallback = true, 
+                       blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
 		       octave_idx_type& info) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
 		       octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
 		       octave_idx_type& info, float& rcon,
 		       solve_singularity_handler sing_handler,
-		       bool singular_fallback = true) const;
+		       bool singular_fallback = true, 
+                       blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
 			     octave_idx_type& info) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
 			     octave_idx_type& info, float& rcon) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
 			     octave_idx_type& info, float& rcon,
-			     solve_singularity_handler sing_handler) const;
+			     solve_singularity_handler sing_handler, 
+                             blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (MatrixType &typ, 
 			     const FloatComplexColumnVector& b) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
 			     octave_idx_type& info) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
 			     octave_idx_type& info, float& rcon) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
 			     octave_idx_type& info, float& rcon,
-			     solve_singularity_handler sing_handler) const;
+			     solve_singularity_handler sing_handler, 
+                             blas_trans_type transt = blas_no_trans) const;
 
   // Generic interface to solver with probing of type
   FloatComplexMatrix solve (const FloatMatrix& b) const;
   FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info) const;
   FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon,
-		       solve_singularity_handler sing_handler) const;
+		       solve_singularity_handler sing_handler, 
+                       blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexMatrix solve (const FloatComplexMatrix& b) const;
   FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info) const;
   FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon,
-		       solve_singularity_handler sing_handler) const;
+		       solve_singularity_handler sing_handler, 
+                       blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (const FloatColumnVector& b) const;
   FloatComplexColumnVector solve (const FloatColumnVector& b, octave_idx_type& info) const;
   FloatComplexColumnVector solve (const FloatColumnVector& b, octave_idx_type& info,
 			     float& rcon) const;
   FloatComplexColumnVector solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon,
-			     solve_singularity_handler sing_handler) const;
+			     solve_singularity_handler sing_handler, 
+                             blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info,
 			     float& rcon) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info,
 			     float& rcon,
-			     solve_singularity_handler sing_handler) const;
+			     solve_singularity_handler sing_handler, 
+                             blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexMatrix lssolve (const FloatMatrix& b) const;
   FloatComplexMatrix lssolve (const FloatMatrix& b, octave_idx_type& info) const;
   FloatComplexMatrix lssolve (const FloatMatrix& b, octave_idx_type& info, 
 			 octave_idx_type& rank) const;
   FloatComplexMatrix lssolve (const FloatMatrix& b, octave_idx_type& info, 
 			 octave_idx_type& rank, float& rcon) const;
 
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -1517,17 +1517,17 @@ FloatMatrix::rcond (MatrixType &mattype)
     }
 
   return rcon;
 }
 
 FloatMatrix
 FloatMatrix::utsolve (MatrixType &mattype, const FloatMatrix& b, octave_idx_type& info,
 		float& rcon, solve_singularity_handler sing_handler,
-		bool calc_cond) const
+		bool calc_cond, blas_trans_type transt) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
@@ -1593,17 +1593,17 @@ FloatMatrix::utsolve (MatrixType &mattyp
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  float *result = retval.fortran_vec ();
 
 		  char uplo = 'U';
-		  char trans = 'N';
+		  char trans = get_blas_char (transt);
 		  char dia = 'N';
 
 		  F77_XFCN (strtrs, STRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&trans, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
 					     nr, b_nc, tmp_data, nr,
 					     result, nr, info
 					     F77_CHAR_ARG_LEN (1)
@@ -1617,17 +1617,17 @@ FloatMatrix::utsolve (MatrixType &mattyp
     }
 
   return retval;
 }
 
 FloatMatrix
 FloatMatrix::ltsolve (MatrixType &mattype, const FloatMatrix& b, octave_idx_type& info,
 		float& rcon, solve_singularity_handler sing_handler,
-		bool calc_cond) const
+		bool calc_cond, blas_trans_type transt) const
 {
   FloatMatrix retval;
 
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   if (nr != b.rows ())
     (*current_liboctave_error_handler)
@@ -1693,17 +1693,17 @@ FloatMatrix::ltsolve (MatrixType &mattyp
 		}
 
 	      if (info == 0)
 		{
 		  retval = b;
 		  float *result = retval.fortran_vec ();
 
 		  char uplo = 'L';
-		  char trans = 'N';
+		  char trans = get_blas_char (transt);
 		  char dia = 'N';
 
 		  F77_XFCN (strtrs, STRTRS, (F77_CONST_CHAR_ARG2 (&uplo, 1), 
 					     F77_CONST_CHAR_ARG2 (&trans, 1), 
 					     F77_CONST_CHAR_ARG2 (&dia, 1), 
 					     nr, b_nc, tmp_data, nr,
 					     result, nr, info
 					     F77_CHAR_ARG_LEN (1)
@@ -1914,29 +1914,31 @@ FloatMatrix::solve (MatrixType &typ, con
 	       float& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatMatrix
 FloatMatrix::solve (MatrixType &mattype, const FloatMatrix& b, octave_idx_type& info,
 	       float& rcon, solve_singularity_handler sing_handler,
-	       bool singular_fallback) const
+	       bool singular_fallback, blas_trans_type transt) const
 {
   FloatMatrix retval;
   int typ = mattype.type ();
 
   if (typ == MatrixType::Unknown)
     typ = mattype.type (*this);
 
   // Only calculate the condition number for LU/Cholesky
   if (typ == MatrixType::Upper || typ == MatrixType::Permuted_Upper)
-    retval = utsolve (mattype, b, info, rcon, sing_handler, false);
+    retval = utsolve (mattype, b, info, rcon, sing_handler, false, transt);
   else if (typ == MatrixType::Lower || typ == MatrixType::Permuted_Lower)
-    retval = ltsolve (mattype, b, info, rcon, sing_handler, false);
+    retval = ltsolve (mattype, b, info, rcon, sing_handler, false, transt);
+  else if (transt == blas_trans || transt == blas_conj_trans)
+    return transpose ().solve (mattype, b, info, rcon, sing_handler, singular_fallback);
   else if (typ == MatrixType::Full || typ == MatrixType::Hermitian)
     retval = fsolve (mattype, b, info, rcon, sing_handler, true);
   else if (typ != MatrixType::Rectangular)
     {
       (*current_liboctave_error_handler) ("unknown matrix type");
       return FloatMatrix ();
     }
 
@@ -1971,20 +1973,20 @@ FloatMatrix::solve (MatrixType &typ, con
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info, rcon);
 }
 
 FloatComplexMatrix
 FloatMatrix::solve (MatrixType &typ, const FloatComplexMatrix& b, octave_idx_type& info,
 	       float& rcon, solve_singularity_handler sing_handler,
-	       bool singular_fallback) const
+	       bool singular_fallback, blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.solve (typ, b, info, rcon, sing_handler, singular_fallback);
+  return tmp.solve (typ, b, info, rcon, sing_handler, singular_fallback, transt);
 }
 
 FloatColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b) const
 {
   octave_idx_type info; float rcon;
   return solve (typ, b, info, rcon);
 }
@@ -2001,20 +2003,20 @@ FloatColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b, octave_idx_type& info,
 	       float& rcon) const
 {
   return solve (typ, b, info, rcon, 0);
 }
 
 FloatColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatColumnVector& b, octave_idx_type& info,
-	       float& rcon, solve_singularity_handler sing_handler) const
+	       float& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   FloatMatrix tmp (b);
-  return solve (typ, tmp, info, rcon, sing_handler).column(static_cast<octave_idx_type> (0));
+  return solve (typ, tmp, info, rcon, sing_handler, transt).column(static_cast<octave_idx_type> (0));
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (typ, b);
 }
@@ -2033,20 +2035,20 @@ FloatMatrix::solve (MatrixType &typ, con
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (typ, b, info, rcon);
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (MatrixType &typ, const FloatComplexColumnVector& b, 
 	       octave_idx_type& info, float& rcon,
-	       solve_singularity_handler sing_handler) const
+	       solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.solve(typ, b, info, rcon, sing_handler);
+  return tmp.solve(typ, b, info, rcon, sing_handler, transt);
 }
 
 FloatMatrix
 FloatMatrix::solve (const FloatMatrix& b) const
 {
   octave_idx_type info;
   float rcon;
   return solve (b, info, rcon, 0);
@@ -2062,20 +2064,20 @@ FloatMatrix::solve (const FloatMatrix& b
 FloatMatrix
 FloatMatrix::solve (const FloatMatrix& b, octave_idx_type& info, float& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 FloatMatrix
 FloatMatrix::solve (const FloatMatrix& b, octave_idx_type& info,
-	       float& rcon, solve_singularity_handler sing_handler) const
+	       float& rcon, solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   MatrixType mattype (*this);
-  return solve (mattype, b, info, rcon, sing_handler);
+  return solve (mattype, b, info, rcon, sing_handler, true, transt);
 }
 
 FloatComplexMatrix
 FloatMatrix::solve (const FloatComplexMatrix& b) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (b);
 }
@@ -2091,20 +2093,20 @@ FloatComplexMatrix
 FloatMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon);
 }
 
 FloatComplexMatrix
 FloatMatrix::solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon,
-	       solve_singularity_handler sing_handler) const
+	       solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.solve (b, info, rcon, sing_handler);
+  return tmp.solve (b, info, rcon, sing_handler, transt);
 }
 
 FloatColumnVector
 FloatMatrix::solve (const FloatColumnVector& b) const
 {
   octave_idx_type info; float rcon;
   return solve (b, info, rcon);
 }
@@ -2119,20 +2121,20 @@ FloatMatrix::solve (const FloatColumnVec
 FloatColumnVector
 FloatMatrix::solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon) const
 {
   return solve (b, info, rcon, 0);
 }
 
 FloatColumnVector
 FloatMatrix::solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon,
-	       solve_singularity_handler sing_handler) const
+	       solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   MatrixType mattype (*this);
-  return solve (mattype, b, info, rcon, sing_handler);
+  return solve (mattype, b, info, rcon, sing_handler, transt);
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (const FloatComplexColumnVector& b) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (b);
 }
@@ -2148,20 +2150,20 @@ FloatComplexColumnVector
 FloatMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info, float& rcon) const
 {
   FloatComplexMatrix tmp (*this);
   return tmp.solve (b, info, rcon);
 }
 
 FloatComplexColumnVector
 FloatMatrix::solve (const FloatComplexColumnVector& b, octave_idx_type& info, float& rcon,
-	       solve_singularity_handler sing_handler) const
+	       solve_singularity_handler sing_handler, blas_trans_type transt) const
 {
   FloatComplexMatrix tmp (*this);
-  return tmp.solve (b, info, rcon, sing_handler);
+  return tmp.solve (b, info, rcon, sing_handler, transt);
 }
 
 FloatMatrix
 FloatMatrix::lssolve (const FloatMatrix& b) const
 {
   octave_idx_type info;
   octave_idx_type rank;
   float rcon;
diff --git a/liboctave/fMatrix.h b/liboctave/fMatrix.h
--- a/liboctave/fMatrix.h
+++ b/liboctave/fMatrix.h
@@ -158,93 +158,98 @@ public:
 
   float rcond (void) const;
   float rcond (MatrixType &mattype) const;
 
 private:
   // Upper triangular matrix solvers
   FloatMatrix utsolve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
 		  float& rcon, solve_singularity_handler sing_handler,
-		  bool calc_cond = false) const;
+		  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
 
   // Lower triangular matrix solvers
   FloatMatrix ltsolve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
 		  float& rcon, solve_singularity_handler sing_handler,
-		  bool calc_cond = false) const;
+		  bool calc_cond = false, blas_trans_type transt = blas_no_trans) const;
 
   // Full matrix solvers (lu/cholesky)
   FloatMatrix fsolve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
 		 float& rcon, solve_singularity_handler sing_handler,
 		 bool calc_cond = false) const;
 
 public:
   // Generic interface to solver with no probing of type
   FloatMatrix solve (MatrixType &typ, const FloatMatrix& b) const;
   FloatMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info) const;
   FloatMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info, 
 		float& rcon) const;
   FloatMatrix solve (MatrixType &typ, const FloatMatrix& b, octave_idx_type& info,
 		float& rcon, solve_singularity_handler sing_handler,
-		bool singular_fallback = true) const;
+		bool singular_fallback = true, blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
 		       octave_idx_type& info) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
 		       octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (MatrixType &typ, const FloatComplexMatrix& b, 
 		       octave_idx_type& info, float& rcon,
 		       solve_singularity_handler sing_handler,
-		       bool singular_fallback = true) const;
+		       bool singular_fallback = true, 
+                       blas_trans_type transt = blas_no_trans) const;
 
   FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b) const;
   FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
 		      octave_idx_type& info) const;
   FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
 		      octave_idx_type& info, float& rcon) const;
   FloatColumnVector solve (MatrixType &typ, const FloatColumnVector& b, 
 		      octave_idx_type& info, float& rcon,
-		      solve_singularity_handler sing_handler) const;
+		      solve_singularity_handler sing_handler, 
+                      blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (MatrixType &typ, 
 			     const FloatComplexColumnVector& b) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
 			     octave_idx_type& info) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
 			     octave_idx_type& info, float& rcon) const;
   FloatComplexColumnVector solve (MatrixType &typ, const FloatComplexColumnVector& b, 
 			     octave_idx_type& info, float& rcon,
-			     solve_singularity_handler sing_handler) const;
+			     solve_singularity_handler sing_handler, blas_trans_type transt = blas_no_trans) const;
 
   // Generic interface to solver with probing of type
   FloatMatrix solve (const FloatMatrix& b) const;
   FloatMatrix solve (const FloatMatrix& b, octave_idx_type& info) const;
   FloatMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon) const;
   FloatMatrix solve (const FloatMatrix& b, octave_idx_type& info, float& rcon,
-		solve_singularity_handler sing_handler) const;
+                     solve_singularity_handler sing_handler, 
+                     blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexMatrix solve (const FloatComplexMatrix& b) const;
   FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info) const;
   FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon) const;
   FloatComplexMatrix solve (const FloatComplexMatrix& b, octave_idx_type& info, float& rcon,
-		       solve_singularity_handler sing_handler) const;
+                            solve_singularity_handler sing_handler, 
+                            blas_trans_type transt = blas_no_trans) const;
 
   FloatColumnVector solve (const FloatColumnVector& b) const;
   FloatColumnVector solve (const FloatColumnVector& b, octave_idx_type& info) const;
   FloatColumnVector solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon) const;
   FloatColumnVector solve (const FloatColumnVector& b, octave_idx_type& info, float& rcon,
-		      solve_singularity_handler sing_handler) const;
+                           solve_singularity_handler sing_handler, 
+                           blas_trans_type transt = blas_no_trans) const;
 
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info,
-			     float& rcon) const;
+                                  float& rcon) const;
   FloatComplexColumnVector solve (const FloatComplexColumnVector& b, octave_idx_type& info,
-			     float& rcon,
-			     solve_singularity_handler sing_handler) const;
+                                  float& rcon, solve_singularity_handler sing_handler, 
+                                  blas_trans_type transt = blas_no_trans) const;
 
   // Singular solvers
   FloatMatrix lssolve (const FloatMatrix& b) const;
   FloatMatrix lssolve (const FloatMatrix& b, octave_idx_type& info) const;
   FloatMatrix lssolve (const FloatMatrix& b, octave_idx_type& info, 
 		  octave_idx_type& rank) const;
   FloatMatrix lssolve (const FloatMatrix& b, octave_idx_type& info, 
 		  octave_idx_type& rank, float& rcon) const;
diff --git a/liboctave/mx-defs.h b/liboctave/mx-defs.h
--- a/liboctave/mx-defs.h
+++ b/liboctave/mx-defs.h
@@ -121,16 +121,30 @@ typedef Complex (*c_c_Mapper)(const Comp
 
 typedef bool (*b_f_Mapper)(float);
 typedef bool (*b_fc_Mapper)(const FloatComplex&);
 
 typedef float (*f_f_Mapper)(float);
 typedef float (*f_fc_Mapper)(const FloatComplex&);
 typedef FloatComplex (*fc_fc_Mapper)(const FloatComplex&);
 
+enum blas_trans_type
+{
+  blas_no_trans = 'N',
+  blas_trans = 'T',
+  blas_conj_trans = 'C'
+};
+
+inline char 
+get_blas_char (blas_trans_type transt)
+{
+  return static_cast<char> (transt);
+}
+
+
 #endif
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,23 @@
+2009-09-23  Jaroslav Hajek  <highegg@gmail.com>
+
+	* ov.h (octave_value::op_trans_ldiv, op_herm_ldiv): New enum constants.
+	* ov.cc (decompose_binary_op, binary_op_fcn_name): Support them.
+	* xdiv.h: Include mx-defs.h, delete forward decls.
+	* xdiv.cc (xleftdiv): Support transt parameter.
+	(xdiv): Optimize.
+	* pt-cbinop.cc (simplify_ldiv_op): New static func.
+	(maybe_compound_binary_expression): Try it.
+	* OPERATORS/op-m-m.cc: Define and install trans_ldiv handler.
+	* OPERATORS/op-fm-fm.cc: Ditto.
+	* OPERATORS/op-cm-cm.cc: Define and install trans_ldiv and herm_ldiv
+	handlers.
+	* OPERATORS/op-fcm-fcm.cc: Ditto.
+
 2009-09-19  Jaroslav Hajek  <highegg@gmail.com>
 
 	* ov.h (octave_value_extract): New template function.
 	* data.cc (do_linspace): New static template function.
 	(Flinspace): Rewrite.
 
 2009-09-18  John W. Eaton  <jwe@octave.org>
 
diff --git a/src/OPERATORS/op-cm-cm.cc b/src/OPERATORS/op-cm-cm.cc
--- a/src/OPERATORS/op-cm-cm.cc
+++ b/src/OPERATORS/op-cm-cm.cc
@@ -132,16 +132,40 @@ DEFBINOP (herm_mul, complex_matrix, comp
 
 DEFBINOP (mul_herm, complex_matrix, complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
   return octave_value(xgemm (false, false, v1.complex_matrix_value (), 
                              true, true, v2.complex_matrix_value ()));
 }
 
+DEFBINOP (trans_ldiv, complex_matrix, complex_matrix)
+{
+  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
+  MatrixType typ = v1.matrix_type ();
+  
+  ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (), 
+				v2.complex_matrix_value (), typ, blas_trans);
+
+  v1.matrix_type (typ);
+  return ret;
+}
+
+DEFBINOP (herm_ldiv, complex_matrix, complex_matrix)
+{
+  CAST_BINOP_ARGS (const octave_complex_matrix&, const octave_complex_matrix&);
+  MatrixType typ = v1.matrix_type ();
+  
+  ComplexMatrix ret = xleftdiv (v1.complex_matrix_value (), 
+				v2.complex_matrix_value (), typ, blas_conj_trans);
+
+  v1.matrix_type (typ);
+  return ret;
+}
+
 DEFNDCMPLXCMPOP_FN (lt, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_ge)
 DEFNDCMPLXCMPOP_FN (gt, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_gt)
 DEFNDCMPLXCMPOP_FN (ne, complex_matrix, complex_matrix, complex_array, complex_array, mx_el_ne)
 
 DEFNDBINOP_FN (el_mul, complex_matrix, complex_matrix, complex_array, complex_array, product)
@@ -194,16 +218,19 @@ install_cm_cm_ops (void)
   INSTALL_BINOP (op_mul, octave_complex_matrix, octave_complex_matrix, mul);
   INSTALL_BINOP (op_div, octave_complex_matrix, octave_complex_matrix, div);
   INSTALL_BINOP (op_pow, octave_complex_matrix, octave_complex_matrix, pow);
   INSTALL_BINOP (op_ldiv, octave_complex_matrix, octave_complex_matrix, ldiv);
   INSTALL_BINOP (op_trans_mul, octave_complex_matrix, octave_complex_matrix, trans_mul);
   INSTALL_BINOP (op_mul_trans, octave_complex_matrix, octave_complex_matrix, mul_trans);
   INSTALL_BINOP (op_herm_mul, octave_complex_matrix, octave_complex_matrix, herm_mul);
   INSTALL_BINOP (op_mul_herm, octave_complex_matrix, octave_complex_matrix, mul_herm);
+  INSTALL_BINOP (op_trans_ldiv, octave_complex_matrix, octave_complex_matrix, trans_ldiv);
+  INSTALL_BINOP (op_herm_ldiv, octave_complex_matrix, octave_complex_matrix, herm_ldiv);
+
   INSTALL_BINOP (op_lt, octave_complex_matrix, octave_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_complex_matrix, octave_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_complex_matrix, octave_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_complex_matrix, octave_complex_matrix, ge);
   INSTALL_BINOP (op_gt, octave_complex_matrix, octave_complex_matrix, gt);
   INSTALL_BINOP (op_ne, octave_complex_matrix, octave_complex_matrix, ne);
   INSTALL_BINOP (op_el_mul, octave_complex_matrix, octave_complex_matrix, el_mul);
   INSTALL_BINOP (op_el_div, octave_complex_matrix, octave_complex_matrix, el_div);
diff --git a/src/OPERATORS/op-fcm-fcm.cc b/src/OPERATORS/op-fcm-fcm.cc
--- a/src/OPERATORS/op-fcm-fcm.cc
+++ b/src/OPERATORS/op-fcm-fcm.cc
@@ -136,16 +136,42 @@ DEFBINOP (herm_mul, float_complex_matrix
 
 DEFBINOP (mul_herm, float_complex_matrix, float_complex_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_complex_matrix&, const octave_float_complex_matrix&);
   return octave_value(xgemm (false, false, v1.float_complex_matrix_value (), 
                              true, true, v2.float_complex_matrix_value ()));
 }
 
+DEFBINOP (trans_ldiv, float_complex_matrix, float_complex_matrix)
+{
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
+		   const octave_float_complex_matrix&);
+  MatrixType typ = v1.matrix_type ();
+  
+  FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (), 
+				     v2.float_complex_matrix_value (), typ, blas_trans);
+
+  v1.matrix_type (typ);
+  return ret;
+}
+
+DEFBINOP (herm_ldiv, float_complex_matrix, float_complex_matrix)
+{
+  CAST_BINOP_ARGS (const octave_float_complex_matrix&, 
+		   const octave_float_complex_matrix&);
+  MatrixType typ = v1.matrix_type ();
+  
+  FloatComplexMatrix ret = xleftdiv (v1.float_complex_matrix_value (), 
+				     v2.float_complex_matrix_value (), typ, blas_conj_trans);
+
+  v1.matrix_type (typ);
+  return ret;
+}
+
 DEFNDCMPLXCMPOP_FN (lt, float_complex_matrix, float_complex_matrix, 
 	       float_complex_array, float_complex_array, mx_el_lt)
 DEFNDCMPLXCMPOP_FN (le, float_complex_matrix, float_complex_matrix, 
 	       float_complex_array, float_complex_array, mx_el_le)
 DEFNDCMPLXCMPOP_FN (eq, float_complex_matrix, float_complex_matrix, 
 	       float_complex_array, float_complex_array, mx_el_eq)
 DEFNDCMPLXCMPOP_FN (ge, float_complex_matrix, float_complex_matrix, 
 	       float_complex_array, float_complex_array, mx_el_ge)
@@ -234,16 +260,21 @@ install_fcm_fcm_ops (void)
   INSTALL_BINOP (op_trans_mul, octave_float_complex_matrix, 
                  octave_float_complex_matrix, trans_mul);
   INSTALL_BINOP (op_mul_trans, octave_float_complex_matrix, 
                  octave_float_complex_matrix, mul_trans);
   INSTALL_BINOP (op_herm_mul, octave_float_complex_matrix, 
                  octave_float_complex_matrix, herm_mul);
   INSTALL_BINOP (op_mul_herm, octave_float_complex_matrix, 
                  octave_float_complex_matrix, mul_herm);
+  INSTALL_BINOP (op_trans_ldiv, octave_float_complex_matrix, 
+                 octave_float_complex_matrix, trans_ldiv);
+  INSTALL_BINOP (op_herm_ldiv, octave_float_complex_matrix, 
+                 octave_float_complex_matrix, herm_ldiv);
+
   INSTALL_BINOP (op_lt, octave_float_complex_matrix, 
 		 octave_float_complex_matrix, lt);
   INSTALL_BINOP (op_le, octave_float_complex_matrix, 
 		 octave_float_complex_matrix, le);
   INSTALL_BINOP (op_eq, octave_float_complex_matrix, 
 		 octave_float_complex_matrix, eq);
   INSTALL_BINOP (op_ge, octave_float_complex_matrix, 
 		 octave_float_complex_matrix, ge);
diff --git a/src/OPERATORS/op-fm-fm.cc b/src/OPERATORS/op-fm-fm.cc
--- a/src/OPERATORS/op-fm-fm.cc
+++ b/src/OPERATORS/op-fm-fm.cc
@@ -105,16 +105,28 @@ DEFBINOP (trans_mul, float_matrix, float
 
 DEFBINOP (mul_trans, float_matrix, float_matrix)
 {
   CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
   return octave_value(xgemm (false, v1.float_matrix_value (), 
                              true, v2.float_matrix_value ()));
 }
 
+DEFBINOP (trans_ldiv, float_matrix, float_matrix)
+{
+  CAST_BINOP_ARGS (const octave_float_matrix&, const octave_float_matrix&);
+  MatrixType typ = v1.matrix_type ();
+  
+  FloatMatrix ret = xleftdiv (v1.float_matrix_value (), 
+			      v2.float_matrix_value (), typ, blas_trans);
+
+  v1.matrix_type (typ);
+  return ret;
+}
+
 DEFNDBINOP_FN (lt, float_matrix, float_matrix, float_array, 
 	       float_array, mx_el_lt)
 DEFNDBINOP_FN (le, float_matrix, float_matrix, float_array, 
 	       float_array, mx_el_le)
 DEFNDBINOP_FN (eq, float_matrix, float_matrix, float_array, 
 	       float_array, mx_el_eq)
 DEFNDBINOP_FN (ge, float_matrix, float_matrix, float_array, 
 	       float_array, mx_el_ge)
@@ -212,16 +224,18 @@ install_fm_fm_ops (void)
   INSTALL_BINOP (op_el_and_not, octave_float_matrix, octave_float_matrix, el_and_not);
   INSTALL_BINOP (op_el_or_not, octave_float_matrix, octave_float_matrix, el_or_not);
   INSTALL_BINOP (op_el_not_and, octave_float_matrix, octave_float_matrix, el_not_and);
   INSTALL_BINOP (op_el_not_or, octave_float_matrix, octave_float_matrix, el_not_or);
   INSTALL_BINOP (op_trans_mul, octave_float_matrix, octave_float_matrix, trans_mul);
   INSTALL_BINOP (op_mul_trans, octave_float_matrix, octave_float_matrix, mul_trans);
   INSTALL_BINOP (op_herm_mul, octave_float_matrix, octave_float_matrix, trans_mul);
   INSTALL_BINOP (op_mul_herm, octave_float_matrix, octave_float_matrix, mul_trans);
+  INSTALL_BINOP (op_trans_ldiv, octave_float_matrix, octave_float_matrix, trans_ldiv);
+  INSTALL_BINOP (op_herm_ldiv, octave_float_matrix, octave_float_matrix, trans_ldiv);
 
   INSTALL_CATOP (octave_float_matrix, octave_float_matrix, fm_fm);
   INSTALL_CATOP (octave_matrix, octave_float_matrix, m_fm);
   INSTALL_CATOP (octave_float_matrix, octave_matrix, fm_m);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, 
 		    octave_float_matrix, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, 
diff --git a/src/OPERATORS/op-m-m.cc b/src/OPERATORS/op-m-m.cc
--- a/src/OPERATORS/op-m-m.cc
+++ b/src/OPERATORS/op-m-m.cc
@@ -101,16 +101,27 @@ DEFBINOP (trans_mul, matrix, matrix)
 }
 
 DEFBINOP (mul_trans, matrix, matrix)
 {
   CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
   return octave_value(xgemm (false, v1.matrix_value (), true, v2.matrix_value ()));
 }
 
+DEFBINOP (trans_ldiv, matrix, matrix)
+{
+  CAST_BINOP_ARGS (const octave_matrix&, const octave_matrix&);
+  MatrixType typ = v1.matrix_type ();
+  
+  Matrix ret = xleftdiv (v1.matrix_value (), v2.matrix_value (), typ, blas_trans);
+
+  v1.matrix_type (typ);
+  return ret;
+}
+
 DEFNDBINOP_FN (lt, matrix, matrix, array, array, mx_el_lt)
 DEFNDBINOP_FN (le, matrix, matrix, array, array, mx_el_le)
 DEFNDBINOP_FN (eq, matrix, matrix, array, array, mx_el_eq)
 DEFNDBINOP_FN (ge, matrix, matrix, array, array, mx_el_ge)
 DEFNDBINOP_FN (gt, matrix, matrix, array, array, mx_el_gt)
 DEFNDBINOP_FN (ne, matrix, matrix, array, array, mx_el_ne)
 
 DEFNDBINOP_FN (el_mul, matrix, matrix, array, array, product)
@@ -185,16 +196,18 @@ install_m_m_ops (void)
   INSTALL_BINOP (op_el_and_not, octave_matrix, octave_matrix, el_and_not);
   INSTALL_BINOP (op_el_or_not, octave_matrix, octave_matrix, el_or_not);
   INSTALL_BINOP (op_el_not_and, octave_matrix, octave_matrix, el_not_and);
   INSTALL_BINOP (op_el_not_or, octave_matrix, octave_matrix, el_not_or);
   INSTALL_BINOP (op_trans_mul, octave_matrix, octave_matrix, trans_mul);
   INSTALL_BINOP (op_mul_trans, octave_matrix, octave_matrix, mul_trans);
   INSTALL_BINOP (op_herm_mul, octave_matrix, octave_matrix, trans_mul);
   INSTALL_BINOP (op_mul_herm, octave_matrix, octave_matrix, mul_trans);
+  INSTALL_BINOP (op_trans_ldiv, octave_matrix, octave_matrix, trans_ldiv);
+  INSTALL_BINOP (op_herm_ldiv, octave_matrix, octave_matrix, trans_ldiv);
 
   INSTALL_CATOP (octave_matrix, octave_matrix, m_m);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, octave_matrix, assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_float_matrix, octave_matrix, sgl_assign);
 
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, octave_null_matrix, null_assign);
   INSTALL_ASSIGNOP (op_asn_eq, octave_matrix, octave_null_str, null_assign);
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -372,16 +372,24 @@ octave_value::binary_op_fcn_name (compou
     case op_herm_mul:
       retval = "hermtimes";
       break;
 
     case op_mul_herm:
       retval = "timesherm";
       break;
 
+    case op_trans_ldiv:
+      retval = "transldiv";
+      break;
+
+    case op_herm_ldiv:
+      retval = "hermldiv";
+      break;
+
     case op_el_and_not:
       retval = "andnot";
       break;
 
     case op_el_or_not:
       retval = "ornot";
       break;
 
@@ -1991,16 +1999,26 @@ decompose_binary_op (octave_value::compo
                              do_unary_op (octave_value::op_hermitian, v1),
                              v2);
       break;
     case octave_value::op_mul_herm:
       retval = do_binary_op (octave_value::op_mul,
                              v1,
                              do_unary_op (octave_value::op_hermitian, v2));
       break;
+    case octave_value::op_trans_ldiv:
+      retval = do_binary_op (octave_value::op_ldiv,
+                             do_unary_op (octave_value::op_transpose, v1),
+                             v2);
+      break;
+    case octave_value::op_herm_ldiv:
+      retval = do_binary_op (octave_value::op_ldiv,
+                             do_unary_op (octave_value::op_hermitian, v1),
+                             v2);
+      break;
     case octave_value::op_el_not_and:
       retval = do_binary_op (octave_value::op_el_and,
                              do_unary_op (octave_value::op_not, v1),
                              v2);
       break;
     case octave_value::op_el_not_or:
       retval = do_binary_op (octave_value::op_el_or,
                              do_unary_op (octave_value::op_not, v1),
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -107,16 +107,18 @@ public:
 
   enum compound_binary_op
   {
     // ** compound operations **
     op_trans_mul,      
     op_mul_trans,
     op_herm_mul,      
     op_mul_herm,
+    op_trans_ldiv,
+    op_herm_ldiv,
     op_el_not_and,
     op_el_not_or,
     op_el_and_not,
     op_el_or_not,
     num_compound_binary_ops,
     unknown_compound_binary_op
   };
 
diff --git a/src/pt-cbinop.cc b/src/pt-cbinop.cc
--- a/src/pt-cbinop.cc
+++ b/src/pt-cbinop.cc
@@ -101,16 +101,34 @@ simplify_mul_op (tree_expression *&a, tr
         retop = octave_value::op_mul_trans;
       else
         retop = octave_value::unknown_compound_binary_op;
     }
 
   return retop;
 }
 
+// Possibly convert left division to trans_ldiv or herm_ldiv.
+
+static octave_value::compound_binary_op
+simplify_ldiv_op (tree_expression *&a, tree_expression *&b)
+{
+  octave_value::compound_binary_op retop;
+  octave_value::unary_op opa = strip_trans_herm (a);
+
+  if (opa == octave_value::op_hermitian)
+    retop = octave_value::op_herm_ldiv;
+  else if (opa == octave_value::op_transpose)
+    retop = octave_value::op_trans_ldiv;
+  else
+    retop = octave_value::unknown_compound_binary_op;
+
+  return retop;
+}
+
 // Possibly contract and/or with negation.
 
 static octave_value::compound_binary_op
 simplify_and_or_op (tree_expression *&a, tree_expression *&b, octave_value::binary_op op)
 {
   octave_value::compound_binary_op retop;
   octave_value::unary_op opa = strip_not (a);
 
@@ -147,16 +165,20 @@ maybe_compound_binary_expression (tree_e
   octave_value::compound_binary_op ct;
 
   switch (t)
     {
     case octave_value::op_mul:
       ct = simplify_mul_op (ca, cb);
       break;
 
+    case octave_value::op_ldiv:
+      ct = simplify_ldiv_op (ca, cb);
+      break;
+
     case octave_value::op_el_and:
     case octave_value::op_el_or:
       ct = simplify_and_or_op (ca, cb, t);
       break;
 
     default:
       ct = octave_value::unknown_compound_binary_op;
       break;
diff --git a/src/xdiv.cc b/src/xdiv.cc
--- a/src/xdiv.cc
+++ b/src/xdiv.cc
@@ -127,91 +127,75 @@ INSTANTIATE_MX_DIV_CONFORM (ComplexMatri
 
 // -*- 1 -*-
 Matrix
 xdiv (const Matrix& a, const Matrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return Matrix ();
 
-  Matrix atmp = a.transpose ();
-  Matrix btmp = b.transpose ();
-  MatrixType btyp = typ.transpose ();
-
   octave_idx_type info;
   double rcond = 0.0;
 
   Matrix result 
-    = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
+    = b.solve (typ, a.transpose (), info, rcond, 
+               solve_singularity_warning, true, blas_trans);
 
-  typ = btyp.transpose ();
   return result.transpose ();
 }
 
 // -*- 2 -*-
 ComplexMatrix
 xdiv (const Matrix& a, const ComplexMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
-  Matrix atmp = a.transpose ();
-  ComplexMatrix btmp = b.hermitian ();
-  MatrixType btyp = typ.transpose ();
-
   octave_idx_type info;
   double rcond = 0.0;
 
   ComplexMatrix result
-    = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
+    = b.solve (typ, a.transpose (), info, rcond, 
+               solve_singularity_warning, true, blas_trans);
 
-  typ = btyp.transpose ();
-  return result.hermitian ();
+  return result.transpose ();
 }
 
 // -*- 3 -*-
 ComplexMatrix
 xdiv (const ComplexMatrix& a, const Matrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
-  ComplexMatrix atmp = a.hermitian ();
-  Matrix btmp = b.transpose ();
-  MatrixType btyp = typ.transpose ();
-
   octave_idx_type info;
   double rcond = 0.0;
 
   ComplexMatrix result
-    = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
+    = b.solve (typ, a.transpose (), info, rcond, 
+               solve_singularity_warning, true, blas_trans);
 
-  typ = btyp.transpose ();
-  return result.hermitian ();
+  return result.transpose ();
 }
 
 // -*- 4 -*-
 ComplexMatrix
 xdiv (const ComplexMatrix& a, const ComplexMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return ComplexMatrix ();
 
-  ComplexMatrix atmp = a.hermitian ();
-  ComplexMatrix btmp = b.hermitian ();
-  MatrixType btyp = typ.transpose ();
-
   octave_idx_type info;
   double rcond = 0.0;
 
   ComplexMatrix result
-    = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
+    = b.solve (typ, a.transpose (), info, rcond, 
+               solve_singularity_warning, true, blas_trans);
 
-  typ = btyp.transpose ();
-  return result.hermitian ();
+  return result.transpose ();
 }
 
 // Funny element by element division operations.
 //
 //       op2 \ op1:   s   cs
 //            +--   +---+----+
 //   matrix         | 1 |  3 |
 //                  +---+----+
@@ -361,61 +345,61 @@ x_el_div (const Complex a, const Complex
 //            +--   +---+----+
 //   matrix         | 1 |  3 |
 //                  +---+----+
 //   complex_matrix | 2 |  4 |
 //                  +---+----+
 
 // -*- 1 -*-
 Matrix
-xleftdiv (const Matrix& a, const Matrix& b, MatrixType &typ)
+xleftdiv (const Matrix& a, const Matrix& b, MatrixType &typ, blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b))
     return Matrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
-  return a.solve (typ, b, info, rcond, solve_singularity_warning);
+  return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 2 -*-
 ComplexMatrix
-xleftdiv (const Matrix& a, const ComplexMatrix& b, MatrixType &typ)
+xleftdiv (const Matrix& a, const ComplexMatrix& b, MatrixType &typ, blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
 
-  return a.solve (typ, b, info, rcond, solve_singularity_warning);
+  return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 3 -*-
 ComplexMatrix
-xleftdiv (const ComplexMatrix& a, const Matrix& b, MatrixType &typ)
+xleftdiv (const ComplexMatrix& a, const Matrix& b, MatrixType &typ, blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
-  return a.solve (typ, b, info, rcond, solve_singularity_warning);
+  return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 4 -*-
 ComplexMatrix
-xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b, MatrixType &typ)
+xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b, MatrixType &typ, blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b))
     return ComplexMatrix ();
 
   octave_idx_type info;
   double rcond = 0.0;
-  return a.solve (typ, b, info, rcond, solve_singularity_warning);
+  return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 static void
 solve_singularity_warning (float rcond)
 {
   warning ("matrix singular to machine precision, rcond = %g", rcond);
   warning ("attempting to find minimum norm solution");
 }
@@ -441,91 +425,75 @@ INSTANTIATE_MX_DIV_CONFORM (FloatComplex
 
 // -*- 1 -*-
 FloatMatrix
 xdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return FloatMatrix ();
 
-  FloatMatrix atmp = a.transpose ();
-  FloatMatrix btmp = b.transpose ();
-  MatrixType btyp = typ.transpose ();
-
   octave_idx_type info;
   float rcond = 0.0;
 
   FloatMatrix result 
-    = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
+    = b.solve (typ, a.transpose (), info, rcond, 
+               solve_singularity_warning, true, blas_trans);
 
-  typ = btyp.transpose ();
   return result.transpose ();
 }
 
 // -*- 2 -*-
 FloatComplexMatrix
 xdiv (const FloatMatrix& a, const FloatComplexMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return FloatComplexMatrix ();
 
-  FloatMatrix atmp = a.transpose ();
-  FloatComplexMatrix btmp = b.hermitian ();
-  MatrixType btyp = typ.transpose ();
-
   octave_idx_type info;
   float rcond = 0.0;
 
-  FloatComplexMatrix result
-    = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
+  FloatComplexMatrix result 
+    = b.solve (typ, a.transpose (), info, rcond, 
+               solve_singularity_warning, true, blas_trans);
 
-  typ = btyp.transpose ();
-  return result.hermitian ();
+  return result.transpose ();
 }
 
 // -*- 3 -*-
 FloatComplexMatrix
 xdiv (const FloatComplexMatrix& a, const FloatMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return FloatComplexMatrix ();
 
-  FloatComplexMatrix atmp = a.hermitian ();
-  FloatMatrix btmp = b.transpose ();
-  MatrixType btyp = typ.transpose ();
-
   octave_idx_type info;
   float rcond = 0.0;
 
-  FloatComplexMatrix result
-    = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
+  FloatComplexMatrix result 
+    = b.solve (typ, a.transpose (), info, rcond, 
+               solve_singularity_warning, true, blas_trans);
 
-  typ = btyp.transpose ();
-  return result.hermitian ();
+  return result.transpose ();
 }
 
 // -*- 4 -*-
 FloatComplexMatrix
 xdiv (const FloatComplexMatrix& a, const FloatComplexMatrix& b, MatrixType &typ)
 {
   if (! mx_div_conform (a, b))
     return FloatComplexMatrix ();
 
-  FloatComplexMatrix atmp = a.hermitian ();
-  FloatComplexMatrix btmp = b.hermitian ();
-  MatrixType btyp = typ.transpose ();
-
   octave_idx_type info;
   float rcond = 0.0;
 
-  FloatComplexMatrix result
-    = btmp.solve (btyp, atmp, info, rcond, solve_singularity_warning);
+  FloatComplexMatrix result 
+    = b.solve (typ, a.transpose (), info, rcond, 
+               solve_singularity_warning, true, blas_trans);
 
-  typ = btyp.transpose ();
-  return result.hermitian ();
+  return result.transpose ();
 }
 
 // Funny element by element division operations.
 //
 //       op2 \ op1:   s   cs
 //            +--   +---+----+
 //   matrix         | 1 |  3 |
 //                  +---+----+
@@ -675,61 +643,61 @@ x_el_div (const FloatComplex a, const Fl
 //            +--   +---+----+
 //   matrix         | 1 |  3 |
 //                  +---+----+
 //   complex_matrix | 2 |  4 |
 //                  +---+----+
 
 // -*- 1 -*-
 FloatMatrix
-xleftdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType &typ)
+xleftdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType &typ, blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b))
     return FloatMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
-  return a.solve (typ, b, info, rcond, solve_singularity_warning);
+  return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 2 -*-
 FloatComplexMatrix
-xleftdiv (const FloatMatrix& a, const FloatComplexMatrix& b, MatrixType &typ)
+xleftdiv (const FloatMatrix& a, const FloatComplexMatrix& b, MatrixType &typ, blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b))
     return FloatComplexMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
 
-  return a.solve (typ, b, info, rcond, solve_singularity_warning);
+  return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 3 -*-
 FloatComplexMatrix
-xleftdiv (const FloatComplexMatrix& a, const FloatMatrix& b, MatrixType &typ)
+xleftdiv (const FloatComplexMatrix& a, const FloatMatrix& b, MatrixType &typ, blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b))
     return FloatComplexMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
-  return a.solve (typ, b, info, rcond, solve_singularity_warning);
+  return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // -*- 4 -*-
 FloatComplexMatrix
-xleftdiv (const FloatComplexMatrix& a, const FloatComplexMatrix& b, MatrixType &typ)
+xleftdiv (const FloatComplexMatrix& a, const FloatComplexMatrix& b, MatrixType &typ, blas_trans_type transt)
 {
   if (! mx_leftdiv_conform (a, b))
     return FloatComplexMatrix ();
 
   octave_idx_type info;
   float rcond = 0.0;
-  return a.solve (typ, b, info, rcond, solve_singularity_warning);
+  return a.solve (typ, b, info, rcond, solve_singularity_warning, true, transt);
 }
 
 // Diagonal matrix division.
 
 template <class MT, class DMT>
 MT
 mdm_div_impl (const MT& a, const DMT& d)
 {
diff --git a/src/xdiv.h b/src/xdiv.h
--- a/src/xdiv.h
+++ b/src/xdiv.h
@@ -20,25 +20,19 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if !defined (octave_xdiv_h)
 #define octave_xdiv_h 1
 
-#include "oct-cmplx.h"
+#include "mx-defs.h"
 #include "MatrixType.h"
 
-class Matrix;
-class ComplexMatrix;
-
-class NDArray;
-class ComplexNDArray;
-
 extern Matrix xdiv (const Matrix& a, const Matrix& b, MatrixType &typ);
 extern ComplexMatrix xdiv (const Matrix& a, const ComplexMatrix& b,
 			   MatrixType &typ);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const Matrix& b,
 			   MatrixType &typ);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const ComplexMatrix& b,
 			   MatrixType &typ);
 
@@ -47,29 +41,24 @@ extern ComplexMatrix x_el_div (double a,
 extern ComplexMatrix x_el_div (const Complex a, const Matrix& b);
 extern ComplexMatrix x_el_div (const Complex a, const ComplexMatrix& b);
 
 extern NDArray x_el_div (double a, const NDArray& b);
 extern ComplexNDArray x_el_div (double a, const ComplexNDArray& b);
 extern ComplexNDArray x_el_div (const Complex a, const NDArray& b);
 extern ComplexNDArray x_el_div (const Complex a, const ComplexNDArray& b);
 
-extern Matrix xleftdiv (const Matrix& a, const Matrix& b, MatrixType &typ);
+extern Matrix xleftdiv (const Matrix& a, const Matrix& b, MatrixType &typ,
+                        blas_trans_type transt = blas_no_trans);
 extern ComplexMatrix xleftdiv (const Matrix& a, const ComplexMatrix& b,
-			       MatrixType &typ);
+			       MatrixType &typ, blas_trans_type transt = blas_no_trans);
 extern ComplexMatrix xleftdiv (const ComplexMatrix& a, const Matrix& b,
-			       MatrixType &typ);
+			       MatrixType &typ, blas_trans_type transt = blas_no_trans);
 extern ComplexMatrix xleftdiv (const ComplexMatrix& a, const ComplexMatrix& b,
-			       MatrixType &typ);
-
-class FloatMatrix;
-class FloatComplexMatrix;
-
-class FloatNDArray;
-class FloatComplexNDArray;
+			       MatrixType &typ, blas_trans_type transt = blas_no_trans);
 
 extern FloatMatrix xdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType &typ);
 extern FloatComplexMatrix xdiv (const FloatMatrix& a, const FloatComplexMatrix& b,
 			   MatrixType &typ);
 extern FloatComplexMatrix xdiv (const FloatComplexMatrix& a, const FloatMatrix& b,
 			   MatrixType &typ);
 extern FloatComplexMatrix xdiv (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
 			   MatrixType &typ);
@@ -79,29 +68,25 @@ extern FloatComplexMatrix x_el_div (floa
 extern FloatComplexMatrix x_el_div (const FloatComplex a, const FloatMatrix& b);
 extern FloatComplexMatrix x_el_div (const FloatComplex a, const FloatComplexMatrix& b);
 
 extern FloatNDArray x_el_div (float a, const FloatNDArray& b);
 extern FloatComplexNDArray x_el_div (float a, const FloatComplexNDArray& b);
 extern FloatComplexNDArray x_el_div (const FloatComplex a, const FloatNDArray& b);
 extern FloatComplexNDArray x_el_div (const FloatComplex a, const FloatComplexNDArray& b);
 
-extern FloatMatrix xleftdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType &typ);
+extern FloatMatrix xleftdiv (const FloatMatrix& a, const FloatMatrix& b, MatrixType &typ, 
+                             blas_trans_type transt = blas_no_trans);
 extern FloatComplexMatrix xleftdiv (const FloatMatrix& a, const FloatComplexMatrix& b,
-			       MatrixType &typ);
+			       MatrixType &typ, blas_trans_type transt = blas_no_trans);
 extern FloatComplexMatrix xleftdiv (const FloatComplexMatrix& a, const FloatMatrix& b,
-			       MatrixType &typ);
+			       MatrixType &typ, blas_trans_type transt = blas_no_trans);
 extern FloatComplexMatrix xleftdiv (const FloatComplexMatrix& a, const FloatComplexMatrix& b,
-			       MatrixType &typ);
-
+			       MatrixType &typ, blas_trans_type transt = blas_no_trans);
 
-class DiagMatrix;
-class FloatDiagMatrix;
-class ComplexDiagMatrix;
-class FloatComplexDiagMatrix;
 
 extern Matrix xdiv (const Matrix& a, const DiagMatrix& b);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const DiagMatrix& b);
 extern ComplexMatrix xdiv (const ComplexMatrix& a, const ComplexDiagMatrix& b);
 
 extern DiagMatrix xdiv (const DiagMatrix& a, const DiagMatrix& b);
 extern ComplexDiagMatrix xdiv (const ComplexDiagMatrix& a, const DiagMatrix& b);
 extern ComplexDiagMatrix xdiv (const ComplexDiagMatrix& a, const ComplexDiagMatrix& b);
