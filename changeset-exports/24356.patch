# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1512408640 18000
#      Mon Dec 04 12:30:40 2017 -0500
# Node ID 8b14ba8296af9b503fe4524d508b09bf22fa6866
# Parent  cc3b3ceb155cc5d9e8a0fc7146c4a7887769b7b4
refactor symbol_record object

When referencing non-local variables, look in correct parent scope
context.  Cache pointer to parent scope for non-local access.  Don't
cache pointer to declaration scope.

* symrec.h, symrec.cc (symbol_record::symbol_record_rep::m_fwd_scope):
New data member.

(symbol_record::symbol_record_rep::symbol_record_rep):
Eliminate symbol_scope argument.  Change all uses.

(symbol_record::symbol_record_rep::assign,
symbol_record::symbol_record_rep::do_non_const_unary_op):
New argument, context  Change all uses.  Don't look to forward
reference here.

(symbol_record::symbol_record_rep::varref,
symbol_record::symbol_record_rep::varval): New argument, context.
Change all uses.  Use context from forward scope when forwarding to
non-local reference.

(symbol_record::symbol_record_rep::clear,
symbol_record::symbol_record_rep::is_defind,
symbol_record::symbol_record_rep::is_variable,
symbol_record::symbol_record_rep::dump): New argument, context.
Change all uses.

(symbol_record::symbol_record_rep::bind_fwd_rep): New argument,
fwd_scope.  Change all uses.

(symbol_record::symbol_record_rep::bind_fwd_rep,
symbol_record::symbol_record_rep::unbind_fwd_rep): Return after forwarding.

(symbol_record::symbol_record_rep::get_fwd_scope_context): New function.

(symbol_record::symbol_record_rep::get_decl_scope_context): Delete.

(symbol_record::symbol_record_rep::m_decl_scope): Delete data
member and all uses.

(symbol_record::symbol_record): Eliminate symbol_scope argument.
Change all uses.

(symbol_record::find, symbol_record::assign,
symbol_record::do_non_const_unary_opt, symbol_record::varval,
symbol_record::clear, symbol_record::is_defined,
symbol_record::is_undefined, symbol_record::is_valid,
symbol_record::is_variable, symbol_record::dump): New arg, context.
Change all uses.

(symbol_record::decl_scope): Delete.

(symbol_record::bind_fwd_rep): New arg, fwd_scope.  Change all uses.

* load-save.h, load-save.cc (do_save): New argument, context.  Change
all uses.
(save_vars): Work with scope instead of symbol table.

* variables.cc (symbol_info::symbol_info, symbol_info::append): New
arg, context.  Change all uses.

* oct-lvalue.h, oct-lvalue.cc (octave_lvalue::m_context):
New data member.
(octave_lvalue::octave_lvalue): New argument, context.
Change all uses.

* pt-decl.h (tree_decl_elt::is_defined, tree_decl_elt::is_variable):
New argument, context.  Change all uses.

* pt-id.h, pt-id.cc (tree_identifier::link_to_global):
New argument, global_scope.
(tree_identifier::is_defined, tree_identifier::is_variable,
tree_black_hole::is_variable): New argument, context.  Change all
uses.

* pt-misc.h, pt-misc.cc (tree_parameter_list::is_defined): New
argument, context.  Change all uses.

diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -955,19 +955,20 @@ do_save (std::ostream& os, const octave_
       break;
     }
 }
 
 // Save the info from SR on stream OS in the format specified by FMT.
 
 void
 do_save (std::ostream& os, const octave::symbol_record& sr,
+         octave::symbol_record::context_id context,
          load_save_format fmt, bool save_as_floats)
 {
-  octave_value val = sr.varval ();
+  octave_value val = sr.varval (context);
 
   if (val.is_defined ())
     {
       std::string name = sr.name ();
       std::string help;
       bool global = sr.is_global ();
 
       do_save (os, val, name, help, global, fmt, save_as_floats);
@@ -1004,25 +1005,27 @@ save_fields (std::ostream& os, const oct
 
 // Save variables with names matching PATTERN on stream OS in the
 // format specified by FMT.
 
 static size_t
 save_vars (std::ostream& os, const std::string& pattern,
            load_save_format fmt, bool save_as_floats)
 {
-  octave::symbol_table& symtab = octave::__get_symbol_table__ ("save_vars");
+  octave::symbol_scope *scope = octave::__require_current_scope__ ("save_vars");
 
-  std::list<octave::symbol_record> vars = symtab.glob (pattern);
+  octave::symbol_record::context_id context = scope->current_context ();
+
+  std::list<octave::symbol_record> vars = scope->glob (pattern);
 
   size_t saved = 0;
 
   for (const auto& var : vars)
     {
-      do_save (os, var, fmt, save_as_floats);
+      do_save (os, var, context, fmt, save_as_floats);
 
       saved++;
     }
 
   return saved;
 }
 
 static string_vector
@@ -1329,23 +1332,25 @@ dump_octave_core (std::ostream& os, cons
                   bool save_as_floats)
 {
   write_header (os, fmt);
 
   octave::symbol_table& symtab = octave::__get_symbol_table__ ("dump_octave_core");
 
   octave::symbol_scope *top_scope = symtab.top_scope ();
 
+  octave::symbol_record::context_id context = top_scope->current_context ();
+
   std::list<octave::symbol_record> vars = top_scope->all_variables ();
 
   double save_mem_size = 0;
 
   for (const auto& var : vars)
     {
-      octave_value val = var.varval ();
+      octave_value val = var.varval (context);
 
       if (val.is_defined ())
         {
           std::string name = var.name ();
           std::string help;
           bool global = var.is_global ();
 
           double val_size = val.byte_size () / 1024;
diff --git a/libinterp/corefcn/symrec.cc b/libinterp/corefcn/symrec.cc
--- a/libinterp/corefcn/symrec.cc
+++ b/libinterp/corefcn/symrec.cc
@@ -37,19 +37,19 @@ along with Octave; see the file COPYING.
 #include "interpreter.h"
 #include "symrec.h"
 #include "symscope.h"
 #include "symtab.h"
 
 namespace octave
 {
   symbol_record::context_id
-  symbol_record::symbol_record_rep::get_decl_scope_context (void) const
+  symbol_record::symbol_record_rep::get_fwd_scope_context (void) const
   {
-    return m_decl_scope ? m_decl_scope->current_context () : 0;
+    return m_fwd_scope ? m_fwd_scope->current_context () : 0;
   }
 
   void
   symbol_record::symbol_record_rep::init_persistent (void)
   {
     if (auto t_fwd_rep = m_fwd_rep.lock ())
       {
         t_fwd_rep->init_persistent ();
@@ -61,59 +61,56 @@ namespace octave
 
   symbol_record::symbol_record_rep *
   symbol_record::symbol_record_rep::dup (symbol_scope *new_scope) const
   {
     // FIXME: is this the right thing do to?
     if (auto t_fwd_rep = m_fwd_rep.lock ())
       return t_fwd_rep->dup (new_scope);
 
-    return new symbol_record_rep (new_scope, m_name, varval (),
+    static const context_id FIXME_CONTEXT = 0;
+
+    return new symbol_record_rep (m_name, varval (FIXME_CONTEXT),
                                   m_storage_class);
   }
 
   octave_value
-  symbol_record::symbol_record_rep::dump (void) const
+  symbol_record::symbol_record_rep::dump (context_id context) const
   {
     if (auto t_fwd_rep = m_fwd_rep.lock ())
-      return t_fwd_rep->dump ();
+      return t_fwd_rep->dump (context);
 
     std::map<std::string, octave_value> m
       = {{ "name", m_name },
          { "local", is_local () },
          { "automatic", is_automatic () },
          { "formal", is_formal () },
          { "hidden", is_hidden () },
          { "inherited", is_inherited () },
          { "global", is_global () },
          { "persistent", is_persistent () }};
 
-    octave_value val = varval ();
+    octave_value val = varval (context);
 
     if (val.is_defined ())
       m["value"] = val;
 
     return octave_value (m);
   }
 
-  symbol_record::symbol_record (void)
-    : m_rep (new symbol_record_rep (__get_current_scope__ ("symbol_record"),
-                                    "", octave_value (), local))
-
-  { }
-
   octave_value
-  symbol_record::find (const octave_value_list& args) const
+  symbol_record::find (context_id context,
+                       const octave_value_list& args) const
   {
     octave_value retval;
 
     symbol_table& symtab
       = __get_symbol_table__ ("symbol_record::find");
 
-    retval = varval ();
+    retval = varval (context);
 
     if (retval.is_undefined ())
       {
         // FIXME
         retval = symtab.find_function (name (), args);
 
         if (retval.is_defined ())
           return retval;
diff --git a/libinterp/corefcn/symrec.h b/libinterp/corefcn/symrec.h
--- a/libinterp/corefcn/symrec.h
+++ b/libinterp/corefcn/symrec.h
@@ -73,121 +73,89 @@ namespace octave
     static const unsigned int added_static = 128;
 
   private:
 
     class symbol_record_rep
     {
     public:
 
-      symbol_record_rep (symbol_scope *s, const std::string& nm,
+      symbol_record_rep (const std::string& nm,
                          const octave_value& v, unsigned int sc)
-        : m_decl_scope (s), m_name (nm),
-          m_fwd_rep (), m_value_stack (), m_storage_class (sc),
-          m_valid (true)
+        : m_storage_class (sc), m_name (nm), m_fwd_scope (nullptr),
+          m_fwd_rep (), m_value_stack (), m_valid (true)
       {
         m_value_stack.push_back (v);
       }
 
       // No copying!
 
       symbol_record_rep (const symbol_record_rep& ov) = delete;
 
       symbol_record_rep& operator = (const symbol_record_rep&) = delete;
 
       ~symbol_record_rep (void) = default;
 
-      void assign (const octave_value& value)
+      void assign (const octave_value& value, context_id context)
       {
-        if (auto t_fwd_rep = m_fwd_rep.lock ())
-          {
-            t_fwd_rep->assign (value);
-            return;
-          }
-
-        varref () = value;
+        varref(context) = value;
       }
 
       void assign (octave_value::assign_op op,
                    const std::string& type,
                    const std::list<octave_value_list>& idx,
-                   const octave_value& value)
+                   const octave_value& value, context_id context)
       {
-        if (auto t_fwd_rep = m_fwd_rep.lock ())
-          {
-            t_fwd_rep->assign (op, type, idx, value);
-            return;
-          }
-
-        varref().assign (op, type, idx, value);
+        varref(context).assign (op, type, idx, value);
       }
 
-      void assign (octave_value::assign_op op, const octave_value& value)
+      void assign (octave_value::assign_op op, const octave_value& value,
+                   context_id context)
       {
-        if (auto t_fwd_rep = m_fwd_rep.lock ())
-          {
-            t_fwd_rep->assign (op, value);
-            return;
-          }
-
-        varref().assign (op, value);
+        varref(context).assign (op, value);
       }
 
-      void do_non_const_unary_op (octave_value::unary_op op)
+      void do_non_const_unary_op (octave_value::unary_op op,
+                                  context_id context)
       {
-        if (auto t_fwd_rep = m_fwd_rep.lock ())
-          {
-            t_fwd_rep->do_non_const_unary_op (op);
-            return;
-          }
-
-        varref().do_non_const_unary_op (op);
+        varref(context).do_non_const_unary_op (op);
       }
 
       void do_non_const_unary_op (octave_value::unary_op op,
                                   const std::string& type,
-                                  const std::list<octave_value_list>& idx)
+                                  const std::list<octave_value_list>& idx,
+                                  context_id context)
       {
-        if (auto t_fwd_rep = m_fwd_rep.lock ())
-          {
-            t_fwd_rep->do_non_const_unary_op (op, type, idx);
-            return;
-          }
-
-        varref().do_non_const_unary_op (op, type, idx);
+        varref(context).do_non_const_unary_op (op, type, idx);
       }
 
-      context_id get_decl_scope_context (void) const;
+      context_id get_fwd_scope_context (void) const;
 
-      octave_value& varref (void)
+      octave_value& varref (context_id context)
       {
         if (auto t_fwd_rep = m_fwd_rep.lock ())
-          return t_fwd_rep->varref ();
+          return t_fwd_rep->varref (get_fwd_scope_context ());
 
-        context_id context = 0;
-
-        if (m_decl_scope && ! (is_persistent () || is_global ()))
-          context = get_decl_scope_context ();
+        if (is_persistent ())
+          context = 0;
 
         context_id n = m_value_stack.size ();
         while (n++ <= context)
           m_value_stack.push_back (octave_value ());
 
         return m_value_stack[context];
       }
 
-      octave_value varval (void) const
+      octave_value varval (context_id context) const
       {
         if (auto t_fwd_rep = m_fwd_rep.lock ())
-          return t_fwd_rep->varval ();
+          return t_fwd_rep->varval (get_fwd_scope_context ());
 
-        context_id context = 0;
-
-        if (m_decl_scope && ! (is_persistent () || is_global ()))
-          context = get_decl_scope_context ();
+        if (is_persistent ())
+          context = 0;
 
         if (context < m_value_stack.size ())
           return m_value_stack[context];
         else
           return octave_value ();
       }
 
       void push_context (void)
@@ -224,17 +192,17 @@ namespace octave
           {
             m_value_stack.pop_back ();
             retval = m_value_stack.size ();
           }
 
         return retval;
       }
 
-      void clear (void)
+      void clear (context_id context)
       {
         // There is no need to do anything with a fowarded
         // symbol_record_rep here.
         //
         // For scripts, we are never executing in the script "scope".
         //
         // For globals, we are only interested in breaking the link to
         // the global value and clearing the local value, not the
@@ -246,45 +214,42 @@ namespace octave
         if (auto t_fwd_rep = m_fwd_rep.lock ())
           return;
 
         if (! (is_hidden () || is_inherited ()))
           {
             if (is_global ())
               unbind_fwd_rep ();
 
-            assign (octave_value ());
+            assign (octave_value (), context);
 
             if (is_persistent ())
               unmark_persistent ();
           }
       }
 
-      bool is_defined (void) const
+      bool is_defined (context_id context) const
       {
-        if (auto t_fwd_rep = m_fwd_rep.lock ())
-          return t_fwd_rep->is_defined ();
-
-        return varval ().is_defined ();
+        return varval (context).is_defined ();
       }
 
       bool is_valid (void) const
       {
         if (auto t_fwd_rep = m_fwd_rep.lock ())
           return t_fwd_rep->is_valid ();
 
         return m_valid;
       }
 
-      bool is_variable (void) const
+      bool is_variable (context_id context) const
       {
         if (auto t_fwd_rep = m_fwd_rep.lock ())
-          return t_fwd_rep->is_variable ();
+          return t_fwd_rep->is_variable (context);
 
-        return (! is_local () || is_defined ());
+        return (! is_local () || is_defined (context));
       }
 
       bool is_local (void) const
       {
         if (auto t_fwd_rep = m_fwd_rep.lock ())
           return t_fwd_rep->is_local ();
 
         return m_storage_class & local;
@@ -522,71 +487,71 @@ namespace octave
           {
             t_fwd_rep->invalidate ();
             return;
           }
 
         m_valid = false;
       }
 
-      symbol_scope *decl_scope (void)
+      void bind_fwd_rep (symbol_scope *fwd_scope,
+                         const std::shared_ptr<symbol_record_rep>& fwd_rep)
       {
         if (auto t_fwd_rep = m_fwd_rep.lock ())
-          return t_fwd_rep->decl_scope ();
-
-        return m_decl_scope;
-      }
+          {
+            t_fwd_rep->bind_fwd_rep (fwd_scope, fwd_rep);
+            return;
+          }
 
-      void bind_fwd_rep (const std::shared_ptr<symbol_record_rep>& fwd_rep)
-      {
-        if (auto t_fwd_rep = m_fwd_rep.lock ())
-          t_fwd_rep->bind_fwd_rep (fwd_rep);
-
+        m_fwd_scope = fwd_scope;
         m_fwd_rep = fwd_rep;
       }
 
       void unbind_fwd_rep (void)
       {
         if (auto t_fwd_rep = m_fwd_rep.lock ())
-          t_fwd_rep->unbind_fwd_rep ();
+          {
+            t_fwd_rep->unbind_fwd_rep ();
+            return;
+          }
 
+        m_fwd_scope = nullptr;
         m_fwd_rep.reset ();
       }
 
       symbol_record_rep * dup (symbol_scope *new_scope) const;
 
-      octave_value dump (void) const;
+      octave_value dump (context_id context) const;
 
       std::string name (void) const { return m_name; }
 
       void rename (const std::string& new_name) { m_name = new_name; }
 
     private:
 
-      symbol_scope *m_decl_scope;
+      unsigned int m_storage_class;
 
       std::string m_name;
 
+      symbol_scope *m_fwd_scope;
+
       std::weak_ptr<symbol_record_rep> m_fwd_rep;
 
       std::deque<octave_value> m_value_stack;
 
-      unsigned int m_storage_class;
-
       bool m_valid;
     };
 
   public:
 
-    symbol_record (void);
-
-    symbol_record (symbol_scope *s, const std::string& nm = "",
+    symbol_record (const std::string& nm = "",
                    const octave_value& v = octave_value (),
                    unsigned int sc = local)
-      : m_rep (new symbol_record_rep (s, nm, v, sc)) { }
+      : m_rep (new symbol_record_rep (nm, v, sc))
+    { }
 
     symbol_record (const symbol_record& sr) = default;
 
     symbol_record& operator = (const symbol_record& sr) = default;
 
     ~symbol_record (void) = default;
 
     symbol_record dup (symbol_scope *sid) const
@@ -594,77 +559,80 @@ namespace octave
       return symbol_record (m_rep->dup (sid));
     }
 
     std::string name (void) const { return m_rep->name (); }
 
     void rename (const std::string& new_name) { m_rep->rename (new_name); }
 
     octave_value
-    find (const octave_value_list& args = octave_value_list ()) const;
+    find (context_id context,
+          const octave_value_list& args = octave_value_list ()) const;
 
-    void assign (const octave_value& value)
+    void assign (const octave_value& value, context_id context)
     {
-      m_rep->assign (value);
+      m_rep->assign (value, context);
     }
 
     void assign (octave_value::assign_op op,
                  const std::string& type,
                  const std::list<octave_value_list>& idx,
-                 const octave_value& value)
+                 const octave_value& value, context_id context)
     {
-      m_rep->assign (op, type, idx, value);
+      m_rep->assign (op, type, idx, value, context);
     }
 
-    void assign (octave_value::assign_op op, const octave_value& value)
+    void assign (octave_value::assign_op op, const octave_value& value,
+                 context_id context)
     {
-      m_rep->assign (op, value);
+      m_rep->assign (op, value, context);
     }
 
-    void do_non_const_unary_op (octave_value::unary_op op)
+    void do_non_const_unary_op (octave_value::unary_op op, context_id context)
     {
-      m_rep->do_non_const_unary_op (op);
+      m_rep->do_non_const_unary_op (op, context);
     }
 
     void do_non_const_unary_op (octave_value::unary_op op,
                                 const std::string& type,
-                                const std::list<octave_value_list>& idx)
+                                const std::list<octave_value_list>& idx,
+                                context_id context)
     {
-      m_rep->do_non_const_unary_op (op, type, idx);
+      m_rep->do_non_const_unary_op (op, type, idx, context);
     }
 
-    octave_value varval (void) const
+    octave_value varval (context_id context) const
     {
-      return m_rep->varval ();
+      return m_rep->varval (context);
     }
 
     void push_context (void) { m_rep->push_context (); }
 
     size_t pop_context (void) { return m_rep->pop_context (); }
 
-    void clear (void) { m_rep->clear (); }
+    void clear (context_id context) { m_rep->clear (context); }
 
-    bool is_defined (void) const
+    bool is_defined (context_id context) const
     {
-      return m_rep->is_defined ();
+      return m_rep->is_defined (context);
     }
 
-    bool is_undefined (void) const
+    bool is_undefined (context_id context) const
     {
-      return ! m_rep->is_defined ();
+      return ! m_rep->is_defined (context);
     }
 
     bool is_valid (void) const
     {
       return m_rep->is_valid ();
     }
 
-    bool is_variable (void) const
+    bool is_variable (context_id context) const
     {
-      return m_rep->is_variable ();
+      return m_rep->is_variable (context);
     }
 
     bool is_local (void) const { return m_rep->is_local (); }
     bool is_automatic (void) const { return m_rep->is_automatic (); }
     bool is_formal (void) const { return m_rep->is_formal (); }
     bool is_global (void) const { return m_rep->is_global (); }
     bool is_hidden (void) const { return m_rep->is_hidden (); }
     bool is_inherited (void) const { return m_rep->is_inherited (); }
@@ -687,28 +655,29 @@ namespace octave
     void unmark_inherited (void) { m_rep->unmark_inherited (); }
     void unmark_persistent (void) { m_rep->unmark_persistent (); }
     void unmark_added_static (void) { m_rep->unmark_added_static (); }
 
     void init_persistent (void) { m_rep->init_persistent (); }
 
     void invalidate (void) { m_rep->invalidate (); }
 
-    symbol_scope *decl_scope (void) { return m_rep->decl_scope (); }
-
     unsigned int storage_class (void) const { return m_rep->storage_class (); }
 
-    void bind_fwd_rep (const symbol_record& sr)
+    void bind_fwd_rep (symbol_scope *fwd_scope, const symbol_record& sr)
     {
-      m_rep->bind_fwd_rep (sr.m_rep);
+      m_rep->bind_fwd_rep (fwd_scope, sr.m_rep);
     }
 
     void unbind_fwd_rep (void) { m_rep->unbind_fwd_rep (); }
 
-    octave_value dump (void) const { return m_rep->dump (); }
+    octave_value dump (context_id context) const
+    {
+      return m_rep->dump (context);
+    }
 
   private:
 
     static octave_value dummy_octave_value;
 
     std::shared_ptr<symbol_record_rep> m_rep;
 
     // NEW_REP must be dynamically allocated or nullptr.
diff --git a/libinterp/corefcn/symscope.cc b/libinterp/corefcn/symscope.cc
--- a/libinterp/corefcn/symscope.cc
+++ b/libinterp/corefcn/symscope.cc
@@ -55,17 +55,17 @@ namespace octave
         if (p != m_symbols.end ())
           {
             symbol_record sr = p->second;
 
             if (sr.is_global ())
               return symtab.global_varval (name);
             else
               {
-                octave_value val = sr.varval ();
+                octave_value val = sr.varval (m_context);
 
                 if (val.is_defined ())
                   return val;
               }
           }
       }
 
     if (local_funcs)
@@ -85,17 +85,17 @@ namespace octave
 
   symbol_record&
   symbol_scope::insert (const std::string& name, bool force_add)
   {
     table_iterator p = m_symbols.find (name);
 
     if (p == m_symbols.end ())
       {
-        symbol_record ret (this, name);
+        symbol_record ret (name);
 
         if (m_is_nested && m_parent && m_parent->look_nonlocal (name, ret))
           return m_symbols[name] = ret;
         else
           {
             if (m_is_static && ! force_add)
               ret.mark_added_static ();
 
@@ -113,17 +113,17 @@ namespace octave
 
     for (const auto& nm_sr : m_symbols)
       {
         std::string nm = nm_sr.first;
         symbol_record sr = nm_sr.second;
 
         if (! sr.is_hidden ())
           {
-            octave_value val = sr.varval ();
+            octave_value val = sr.varval (m_context);
 
             if (val.is_defined ())
               {
                 // FIXME: fix size for objects, see kluge in variables.cc
                 //dim_vector dv = val.dims ();
                 octave_value tmp = val;
                 Matrix sz = tmp.size ();
                 dim_vector dv = dim_vector::alloc (sz.numel ());
@@ -175,17 +175,17 @@ namespace octave
   symbol_scope::dump_symbols_map (void) const
   {
     std::map<std::string, octave_value> info_map;
 
     for (const auto& nm_sr : m_symbols)
       {
         std::string nm = nm_sr.first;
         const symbol_record& sr = nm_sr.second;
-        info_map[nm] = sr.dump ();
+        info_map[nm] = sr.dump (m_context);
       }
 
     return octave_value (info_map);
   }
 
   void
   symbol_scope::install_subfunction (const std::string& name,
                                      const octave_value& fval, bool is_nested)
@@ -296,28 +296,29 @@ namespace octave
     table_iterator p = m_symbols.find (name);
     if (p == m_symbols.end ())
       {
         if (m_is_nested && m_parent)
           return m_parent->look_nonlocal (name, result);
       }
     else if (! p->second.is_automatic ())
       {
-        result.bind_fwd_rep (p->second);
+        result.bind_fwd_rep (this, p->second);
         return true;
       }
 
     return false;
   }
 
   void
   symbol_scope::bind_script_symbols (symbol_scope *curr_scope)
   {
     for (auto& nm_sr : m_symbols)
-      nm_sr.second.bind_fwd_rep (curr_scope->find_symbol (nm_sr.first));
+      nm_sr.second.bind_fwd_rep (curr_scope,
+                                 curr_scope->find_symbol (nm_sr.first));
   }
 
   void
   symbol_scope::unbind_script_symbols (void)
   {
     for (auto& nm_sr : m_symbols)
       nm_sr.second.unbind_fwd_rep ();
   }
diff --git a/libinterp/corefcn/symscope.h b/libinterp/corefcn/symscope.h
--- a/libinterp/corefcn/symscope.h
+++ b/libinterp/corefcn/symscope.h
@@ -132,17 +132,17 @@ namespace octave
               std::string nm = sr.name ();
 
               if (nm != "__retval__")
                 {
                   octave_value val = donor_scope.varval (nm);
 
                   if (val.is_defined ())
                     {
-                      sr.assign (val);
+                      sr.assign (val, m_context);
 
                       sr.mark_inherited ();
                     }
                 }
             }
         }
     }
 
@@ -187,61 +187,61 @@ namespace octave
                  bool force_add)
     {
       table_iterator p = m_symbols.find (name);
 
       if (p == m_symbols.end ())
         {
           symbol_record& sr = insert (name, force_add);
 
-          sr.assign (value);
+          sr.assign (value, m_context);
         }
       else
-        p->second.assign (value);
+        p->second.assign (value, m_context);
     }
 
     void assign (const std::string& name,
                  const octave_value& value = octave_value ())
     {
       assign (name, value, false);
     }
 
     void force_assign (const std::string& name, const octave_value& value)
     {
       table_iterator p = m_symbols.find (name);
 
       if (p == m_symbols.end ())
         {
           symbol_record& sr = insert (name, true);
 
-          sr.assign (value);
+          sr.assign (value, m_context);
         }
       else
-        p->second.assign (value);
+        p->second.assign (value, m_context);
     }
 
     octave_value varval (const std::string& name) const
     {
       table_const_iterator p = m_symbols.find (name);
 
       return (p != m_symbols.end ()
-              ? p->second.varval () : octave_value ());
+              ? p->second.varval (m_context) : octave_value ());
     }
 
     bool is_variable (const std::string& name) const
     {
       bool retval = false;
 
       table_const_iterator p = m_symbols.find (name);
 
       if (p != m_symbols.end ())
         {
           const symbol_record& sr = p->second;
 
-          retval = sr.is_variable ();
+          retval = sr.is_variable (m_context);
         }
 
       return retval;
     }
 
     void push_context (void)
     {
       for (auto& nm_sr : m_symbols)
@@ -263,73 +263,73 @@ namespace octave
 
     void refresh (void)
     {
       for (auto& nm_sr : m_symbols)
         {
           symbol_record& sr = nm_sr.second;
 
           if (! sr.is_persistent ())
-            sr.clear ();
+            sr.clear (m_context);
         }
     }
 
     void clear_variables (void)
     {
       for (auto& nm_sr : m_symbols)
-        nm_sr.second.clear ();
+        nm_sr.second.clear (m_context);
     }
 
     void clear_objects (void)
     {
       for (auto& nm_sr : m_symbols)
         {
           symbol_record& sr = nm_sr.second;
-          octave_value val = sr.varval ();
+          octave_value val = sr.varval (m_context);
           if (val.isobject ())
-            nm_sr.second.clear ();
+            nm_sr.second.clear (m_context);
         }
     }
 
     void clear_variable (const std::string& name)
     {
       table_iterator p = m_symbols.find (name);
 
       if (p != m_symbols.end ())
-        p->second.clear ();
+        p->second.clear (m_context);
     }
 
     void clear_variable_pattern (const std::string& pat)
     {
       glob_match pattern (pat);
 
       for (auto& nm_sr : m_symbols)
         {
           symbol_record& sr = nm_sr.second;
 
-          if (sr.is_defined () || sr.is_global ())
+          if (sr.is_defined (m_context) || sr.is_global ())
             {
               if (pattern.match (sr.name ()))
-                sr.clear ();
+                sr.clear (m_context);
             }
         }
     }
 
     void clear_variable_regexp (const std::string& pat)
     {
       octave::regexp pattern (pat);
 
       for (auto& nm_sr : m_symbols)
         {
           symbol_record& sr = nm_sr.second;
 
-          if (sr.is_defined () || sr.is_global ())
+          if (sr.is_defined (m_context) || sr.is_global ())
             {
               if (pattern.is_match (sr.name ()))
-                sr.clear ();
+                sr.clear (m_context);
             }
         }
     }
 
     void mark_automatic (const std::string& name)
     {
       insert (name).mark_automatic ();
     }
@@ -349,17 +349,17 @@ namespace octave
                    unsigned int exclude = symbol_record::hidden) const
     {
       std::list<symbol_record> retval;
 
       for (const auto& nm_sr : m_symbols)
         {
           const symbol_record& sr = nm_sr.second;
 
-          if ((defined_only && ! sr.is_defined ())
+          if ((defined_only && ! sr.is_defined (m_context))
               || (sr.storage_class () & exclude))
             continue;
 
           retval.push_back (sr);
         }
 
       return retval;
     }
@@ -372,17 +372,17 @@ namespace octave
       glob_match pat (pattern);
 
       for (const auto& nm_sr : m_symbols)
         {
           if (pat.match (nm_sr.first))
             {
               const symbol_record& sr = nm_sr.second;
 
-              if (vars_only && ! sr.is_variable ())
+              if (vars_only && ! sr.is_variable (m_context))
                 continue;
 
               retval.push_back (sr);
             }
         }
 
       return retval;
     }
@@ -395,48 +395,48 @@ namespace octave
       octave::regexp pat (pattern);
 
       for (const auto& nm_sr : m_symbols)
         {
           if (pat.is_match (nm_sr.first))
             {
               const symbol_record& sr = nm_sr.second;
 
-              if (vars_only && ! sr.is_variable ())
+              if (vars_only && ! sr.is_variable (m_context))
                 continue;
 
               retval.push_back (sr);
             }
         }
 
       return retval;
     }
 
     std::list<std::string> variable_names (void)
     {
       std::list<std::string> retval;
 
       for (const auto& nm_sr : m_symbols)
         {
-          if (nm_sr.second.is_variable ())
+          if (nm_sr.second.is_variable (m_context))
             retval.push_back (nm_sr.first);
         }
 
       retval.sort ();
 
       return retval;
     }
 
     bool is_local_variable (const std::string& name) const
     {
       table_const_iterator p = m_symbols.find (name);
 
       return (p != m_symbols.end ()
               && ! p->second.is_global ()
-              && p->second.is_defined ());
+              && p->second.is_defined (m_context));
     }
 
     bool is_global (const std::string& name) const
     {
       table_const_iterator p = m_symbols.find (name);
 
       return p != m_symbols.end () && p->second.is_global ();
     }
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -1126,27 +1126,29 @@ get_dims_str (const octave_value& val)
 
 class
 symbol_info_list
 {
 private:
   struct symbol_info
   {
     symbol_info (const octave::symbol_record& sr,
+                 octave::symbol_record::context_id context,
                  const std::string& expr_str = "",
                  const octave_value& expr_val = octave_value ())
       : name (expr_str.empty () ? sr.name () : expr_str),
         varval (),
         is_automatic (sr.is_automatic ()),
         is_complex (varval.iscomplex ()),
         is_formal (sr.is_formal ()),
         is_global (sr.is_global ()),
         is_persistent (sr.is_persistent ())
     {
-      varval = (expr_val.is_undefined () ? sr.varval () : expr_val);
+      varval = (expr_val.is_undefined ()
+                ? sr.varval (context) : expr_val);
 
       is_complex = varval.iscomplex ();
     }
 
     void display_line (std::ostream& os,
                        const std::list<whos_parameter>& params) const
     {
       std::string dims_str = get_dims_str (varval);
@@ -1289,26 +1291,28 @@ public:
     if (this != &sil)
       lst = sil.lst;
 
     return *this;
   }
 
   ~symbol_info_list (void) = default;
 
-  void append (const octave::symbol_record& sr)
+  void append (const octave::symbol_record& sr,
+               octave::symbol_record::context_id context)
   {
-    lst.push_back (symbol_info (sr));
+    lst.push_back (symbol_info (sr, context));
   }
 
   void append (const octave::symbol_record& sr,
+               octave::symbol_record::context_id context,
                const std::string& expr_str,
                const octave_value& expr_val)
   {
-    lst.push_back (symbol_info (sr, expr_str, expr_val));
+    lst.push_back (symbol_info (sr, context, expr_str, expr_val));
   }
 
   size_t size (void) const { return lst.size (); }
 
   bool empty (void) const { return lst.empty (); }
 
   octave_map
   map_value (const std::string& caller_function_name, int nesting_level) const
@@ -1690,33 +1694,35 @@ do_who (octave::interpreter& interp, int
       pats[0] = "*";
     }
 
   symbol_info_list symbol_stats;
   std::list<std::string> symbol_names;
 
   octave::symbol_scope *scope = symtab.current_scope ();
 
+  octave::symbol_record::context_id context = scope->current_context ();
+
   for (int j = 0; j < npats; j++)
     {
       std::string pat = pats[j];
 
       if (have_regexp)
         {
           std::list<octave::symbol_record> tmp
             = (global_only
                ? symtab.regexp_global_variables (pat)
                : symtab.regexp_variables (pat));
 
           for (const auto& symrec : tmp)
             {
-              if (symrec.is_variable ())
+              if (symrec.is_variable (context))
                 {
                   if (verbose)
-                    symbol_stats.append (symrec);
+                    symbol_stats.append (symrec, context);
                   else
                     symbol_names.push_back (symrec.name ());
                 }
             }
         }
       else
         {
           size_t pos = pat.find_first_of (".({");
@@ -1741,34 +1747,34 @@ do_who (octave::interpreter& interp, int
 
                       if (! global_only || sr.is_global ())
                         {
                           int parse_status;
 
                           octave_value expr_val
                             = octave::eval_string (pat, true, parse_status);
 
-                          symbol_stats.append (sr, pat, expr_val);
+                          symbol_stats.append (sr, context, pat, expr_val);
                         }
                     }
                 }
             }
           else
             {
               std::list<octave::symbol_record> tmp
                 = (global_only
                    ? symtab.glob_global_variables (pat)
                    : symtab.glob_variables (pat));
 
               for (const auto& symrec : tmp)
                 {
-                  if (symrec.is_variable ())
+                  if (symrec.is_variable (context))
                     {
                       if (verbose)
-                        symbol_stats.append (symrec);
+                        symbol_stats.append (symrec, context);
                       else
                         symbol_names.push_back (symrec.name ());
                     }
                 }
             }
         }
     }
 
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -56,16 +56,17 @@ along with Octave; see the file COPYING.
 #include "pt-assign.h"
 #include "pt-cmd.h"
 #include "pt-eval.h"
 #include "pt-exp.h"
 #include "pt-idx.h"
 #include "pt-misc.h"
 #include "pt-pr-code.h"
 #include "pt-stmt.h"
+#include "symscope.h"
 #include "unwind-prot.h"
 #include "variables.h"
 
 #include "byte-swap.h"
 #include "ls-ascii-helper.h"
 #include "ls-hdf5.h"
 #include "ls-oct-text.h"
 #include "ls-oct-binary.h"
@@ -348,29 +349,33 @@ octave_fcn_handle::save_ascii (std::ostr
 
       if (fcn.is_undefined ())
         return false;
 
       std::list<octave::symbol_record> vars;
 
       octave_user_function *f = fcn.user_function_value ();
       octave::symbol_scope *f_scope = f->scope ();
+      octave::symbol_record::context_id context = 0;
       if (f_scope)
-        vars = f_scope->all_variables ();
+        {
+          vars = f_scope->all_variables ();
+          context = f_scope->current_context ();
+        }
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           os << "# length: " << varlen << "\n";
 
           for (const auto& symrec : vars)
             {
-              if (! save_text_data (os, symrec.varval (), symrec.name (),
-                                    false, 0))
+              if (! save_text_data (os, symrec.varval (context),
+                                    symrec.name (), false, 0))
                 return ! os.fail ();
             }
         }
     }
   else
     {
       octave_function *f = function_value ();
       std::string fnm = (f ? f->fcn_file_name () : "");
@@ -525,18 +530,22 @@ octave_fcn_handle::save_binary (std::ost
 
       if (fcn.is_undefined ())
         return false;
 
       std::list<octave::symbol_record> vars;
 
       octave_user_function *f = fcn.user_function_value ();
       octave::symbol_scope *f_scope = f->scope ();
+      octave::symbol_record::context_id context = 0;
       if (f_scope)
-        vars = f_scope->all_variables ();
+        {
+          vars = f_scope->all_variables ();
+          context = f_scope->current_context ();
+        }
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         nmbuf << nm << ' ' << varlen;
       else
         nmbuf << nm;
 
@@ -551,18 +560,18 @@ octave_fcn_handle::save_binary (std::ost
       tmp = stmp.length ();
       os.write (reinterpret_cast<char *> (&tmp), 4);
       os.write (stmp.c_str (), stmp.length ());
 
       if (varlen > 0)
         {
           for (const auto& symrec : vars)
             {
-              if (! save_binary_data (os, symrec.varval (), symrec.name (),
-                                      "", 0, save_as_floats))
+              if (! save_binary_data (os, symrec.varval (context),
+                                      symrec.name (), "", 0, save_as_floats))
                 return ! os.fail ();
             }
         }
     }
   else
     {
       std::ostringstream nmbuf;
 
@@ -781,18 +790,22 @@ octave_fcn_handle::save_hdf5 (octave_hdf
         }
 
       H5Dclose (data_hid);
 
       std::list<octave::symbol_record> vars;
 
       octave_user_function *f = fcn.user_function_value ();
       octave::symbol_scope *f_scope = f->scope ();
+      octave::symbol_record::context_id context = 0;
       if (f_scope)
-        vars = f_scope->all_variables ();
+        {
+          vars = f_scope->all_variables ();
+          context = f_scope->current_context ();
+        }
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           hid_t as_id = H5Screate (H5S_SCALAR);
 
           if (as_id >= 0)
@@ -831,18 +844,18 @@ octave_fcn_handle::save_hdf5 (octave_hdf
               H5Sclose (space_hid);
               H5Tclose (type_hid);
               H5Gclose (group_hid);
               return false;
             }
 
           for (const auto& symrec : vars)
             {
-              if (! add_hdf5_data (data_hid, symrec.varval (), symrec.name (),
-                                   "", false, save_as_floats))
+              if (! add_hdf5_data (data_hid, symrec.varval (context),
+                                   symrec.name (), "", false, save_as_floats))
                 break;
             }
           H5Gclose (data_hid);
         }
     }
   else
     {
       std::string octaveroot = octave::config::octave_exec_home ();
@@ -1754,26 +1767,30 @@ particular output format.
   if (fh_nm == octave_fcn_handle::anonymous)
     {
       m.setfield ("file", nm);
 
       std::list<octave::symbol_record> vars;
 
       octave_user_function *fu = fh->user_function_value ();
       octave::symbol_scope *fu_scope = fu->scope ();
+      octave::symbol_record::context_id context = 0;
       if (fu_scope)
-        vars = fu_scope->all_variables ();
+        {
+          vars = fu_scope->all_variables ();
+          context = fu_scope->current_context ();
+        }
 
       size_t varlen = vars.size ();
 
       if (varlen > 0)
         {
           octave_scalar_map ws;
           for (const auto& symrec : vars)
-            ws.assign (symrec.name (), symrec.varval ());
+            ws.assign (symrec.name (), symrec.varval (context));
 
           m.setfield ("workspace", ws);
         }
     }
   else if (fcn->is_user_function () || fcn->is_user_script ())
     {
       octave_function *fu = fh->function_value ();
       m.setfield ("file", fu->fcn_file_name ());
@@ -1975,16 +1992,21 @@ octave_fcn_binder::maybe_binder (const o
                   octave::tree_identifier *id = (elt ? elt->ident () : nullptr);
                   if (id && ! id->is_black_hole ())
                     arginmap[id->name ()] = npar;
                 }
             }
 
           if (arg_list && arg_list->length () > 0)
             {
+              octave::symbol_scope *scope = tw->get_current_scope ();
+
+              octave::symbol_record::context_id context
+                = scope->current_context ();
+
               bool bad = false;
               int nargs = arg_list->length ();
               octave_value_list arg_template (nargs);
               std::vector<int> arg_mask (nargs);
 
               // Verify that each argument is either a named param, a constant,
               // or a defined identifier.
               int iarg = 0;
@@ -2000,17 +2022,17 @@ octave_fcn_binder::maybe_binder (const o
                   else if (elt && elt->is_identifier ())
                     {
                       octave::tree_identifier *elt_id =
                         dynamic_cast<octave::tree_identifier *> (elt);
                       if (arginmap.find (elt_id->name ()) != arginmap.end ())
                         {
                           arg_mask[iarg] = arginmap[elt_id->name ()];
                         }
-                      else if (elt_id->is_defined ())
+                      else if (elt_id->is_defined (context))
                         {
                           arg_template(iarg) = tw->evaluate (elt_id);
                           arg_mask[iarg] = -1;
                         }
                       else
                         {
                           bad = true;
                           break;
@@ -2023,17 +2045,17 @@ octave_fcn_binder::maybe_binder (const o
                     }
                 }
 
               octave_value root_val;
 
               if (! bad)
                 {
                   // If the head is a value, use it as root.
-                  if (head_id->is_defined ())
+                  if (head_id->is_defined (context))
                     root_val = tw->evaluate (head_id);
                   else
                     {
                       // It's a name.
                       std::string head_name = head_id->name ();
 
                       if (head_name == "eval" || head_name == "feval")
                         bad = true;
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -3153,20 +3153,17 @@ namespace octave
 
         return kw_token;
       }
 
     // Find the token in the symbol table.
 
     symbol_scope *scope = symtab_context.curr_scope ();
 
-    symbol_record sr
-      = (scope
-         ? scope->insert (ident)
-         : symbol_record (scope, ident));
+    symbol_record sr = (scope ? scope->insert (ident) : symbol_record (ident));
 
     token *tok = new token (NAME, sr, input_line_number, current_input_column);
 
     // The following symbols are handled specially so that things like
     //
     //   pi +1
     //
     // are parsed as an addition expression instead of as a command-style
diff --git a/libinterp/parse-tree/oct-lvalue.cc b/libinterp/parse-tree/oct-lvalue.cc
--- a/libinterp/parse-tree/oct-lvalue.cc
+++ b/libinterp/parse-tree/oct-lvalue.cc
@@ -32,19 +32,19 @@ along with Octave; see the file COPYING.
 namespace octave
 {
   void octave_lvalue::assign (octave_value::assign_op op,
                               const octave_value& rhs)
   {
     if (! is_black_hole ())
       {
         if (m_idx.empty ())
-          m_sym.assign (op, rhs);
+          m_sym.assign (op, rhs, m_context);
         else
-          m_sym.assign (op, m_type, m_idx, rhs);
+          m_sym.assign (op, m_type, m_idx, rhs, m_context);
       }
   }
 
   void octave_lvalue::set_index (const std::string& t,
                                  const std::list<octave_value_list>& i)
   {
     if (! m_idx.empty ())
       error ("invalid index expression in assignment");
@@ -67,29 +67,29 @@ namespace octave
     return retval;
   }
 
   void octave_lvalue::do_unary_op (octave_value::unary_op op)
   {
     if (! is_black_hole ())
       {
         if (m_idx.empty ())
-          m_sym.do_non_const_unary_op (op);
+          m_sym.do_non_const_unary_op (op, m_context);
         else
-          m_sym.do_non_const_unary_op (op, m_type, m_idx);
+          m_sym.do_non_const_unary_op (op, m_type, m_idx, m_context);
       }
   }
 
   octave_value octave_lvalue::value (void) const
   {
     octave_value retval;
 
     if (! is_black_hole ())
       {
-        octave_value val = m_sym.varval ();
+        octave_value val = m_sym.varval (m_context);
 
         if (m_idx.empty ())
           retval = val;
         else
           {
             if (val.is_constant ())
               retval = val.subsref (m_type, m_idx);
             else
diff --git a/libinterp/parse-tree/oct-lvalue.h b/libinterp/parse-tree/oct-lvalue.h
--- a/libinterp/parse-tree/oct-lvalue.h
+++ b/libinterp/parse-tree/oct-lvalue.h
@@ -31,43 +31,49 @@ along with Octave; see the file COPYING.
 #include "symtab.h"
 
 namespace octave
 {
   class octave_lvalue
   {
   public:
 
-    octave_lvalue (const symbol_record& sr = symbol_record ())
-      : m_sym (sr), m_black_hole (false), m_type (), m_idx (), m_nel (1)
+    octave_lvalue (void)
+      : m_sym (), m_context (0), m_black_hole (false), m_type (),
+        m_idx (), m_nel (1)
+    { }
+
+    octave_lvalue (const symbol_record& sr, symbol_record::context_id context)
+      : m_sym (sr), m_context (context), m_black_hole (false),
+        m_type (), m_idx (), m_nel (1)
     { }
 
     octave_lvalue (const octave_lvalue& vr) = default;
 
     octave_lvalue& operator = (const octave_lvalue& vr) = default;
 
     ~octave_lvalue (void) = default;
 
     bool is_black_hole (void) const { return m_black_hole; }
 
     void mark_black_hole (void) { m_black_hole = true; }
 
     bool is_defined (void) const
     {
-      return ! is_black_hole () && m_sym.is_defined ();
+      return ! is_black_hole () && m_sym.is_defined (m_context);
     }
 
     bool is_undefined (void) const
     {
-      return is_black_hole () || m_sym.is_undefined ();
+      return is_black_hole () || m_sym.is_undefined (m_context);
     }
 
     bool isstruct (void) const { return value().isstruct (); }
 
-    void define (const octave_value& v) { m_sym.assign (v); }
+    void define (const octave_value& v) { m_sym.assign (v, m_context); }
 
     void assign (octave_value::assign_op, const octave_value&);
 
     void numel (octave_idx_type n) { m_nel = n; }
 
     octave_idx_type numel (void) const { return m_nel; }
 
     void set_index (const std::string& t, const std::list<octave_value_list>& i);
@@ -81,16 +87,18 @@ namespace octave
     void do_unary_op (octave_value::unary_op op);
 
     octave_value value (void) const;
 
   private:
 
     symbol_record m_sym;
 
+    symbol_record::context_id m_context;
+
     bool m_black_hole;
 
     std::string m_type;
 
     std::list<octave_value_list> m_idx;
 
     octave_idx_type m_nel;
   };
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -5416,20 +5416,25 @@ namespace octave
 
                     if (silent)
                       expr->set_print_flag (false);
 
                     bool do_bind_ans = false;
 
                     if (expr->is_identifier ())
                       {
+                        octave::symbol_scope *scope = tw.get_current_scope ();
+
+                        octave::symbol_record::context_id context
+                          = scope->current_context ();
+
                         tree_identifier *id
                           = dynamic_cast<tree_identifier *> (expr);
 
-                        do_bind_ans = (! id->is_variable ());
+                        do_bind_ans = (! id->is_variable (context));
                       }
                     else
                       do_bind_ans = (! expr->is_assignment_expression ());
 
                     retval = tw.evaluate_n (expr, nargout);
 
                     if (do_bind_ans && ! retval.empty ())
                       tw.bind_ans (retval(0), expr->print_result ());
diff --git a/libinterp/parse-tree/pt-decl.h b/libinterp/parse-tree/pt-decl.h
--- a/libinterp/parse-tree/pt-decl.h
+++ b/libinterp/parse-tree/pt-decl.h
@@ -60,19 +60,25 @@ namespace octave
     // No copying!
 
     tree_decl_elt (const tree_decl_elt&) = delete;
 
     tree_decl_elt& operator = (const tree_decl_elt&) = delete;
 
     ~tree_decl_elt (void);
 
-    bool is_defined (void) { return id ? id->is_defined () : false; }
+    bool is_defined (symbol_record::context_id context)
+    {
+      return id ? id->is_defined (context) : false;
+    }
 
-    bool is_variable (void) { return id ? id->is_variable () : false; }
+    bool is_variable (symbol_record::context_id context)
+    {
+      return id ? id->is_variable (context) : false;
+    }
 
     void mark_as_formal_parameter (void)
     {
       if (id)
         id->mark_as_formal_parameter ();
     }
 
     bool lvalue_ok (void) { return id ? id->lvalue_ok () : false; }
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -577,23 +577,27 @@ namespace octave
     octave_idx_type vlen = varargout.numel ();
     int len = ret_list->length ();
 
     // Special case.  Will do a shallow copy.
     if (len == 0)
       return varargout;
     else if (nargout <= len)
       {
+        symbol_scope *scope = get_current_scope ();
+
+        symbol_record::context_id context = scope->current_context ();
+
         octave_value_list retval (nargout);
 
         int i = 0;
 
         for (tree_decl_elt *elt : *ret_list)
           {
-            if (elt->is_defined ())
+            if (elt->is_defined (context))
               {
                 octave_value tmp = evaluate (elt);
                 retval(i) = tmp;
               }
 
             i++;
           }
 
@@ -711,17 +715,17 @@ namespace octave
     if (id)
       {
         if (elt.is_global ())
           {
             symbol_table& symtab = m_interpreter.get_symbol_table ();
 
             symbol_record global_sym = symtab.find_global_symbol (id->name ());
 
-            id->link_to_global (global_sym);
+            id->link_to_global (symtab.global_scope (), global_sym);
           }
         else if (elt.is_persistent ())
           id->mark_persistent ();
         else
           error ("declaration list element not global or persistent");
 
         octave_lvalue ult = id->lvalue (this);
 
@@ -1032,19 +1036,23 @@ namespace octave
       }
   }
 
   void
   tree_evaluator::visit_identifier (tree_identifier& expr)
   {
     octave_value_list retval;
 
+    symbol_scope *scope = get_current_scope ();
+
+    symbol_record::context_id context = scope->current_context ();
+
     symbol_record sym = expr.symbol ();
 
-    octave_value val = sym.find ();
+    octave_value val = sym.find (context);
 
     if (val.is_defined ())
       {
         // GAGME -- this would be cleaner if we required
         // parens to indicate function calls.
         //
         // If this identifier refers to a function, we need to know
         // whether it is indexed so that we can do the same thing
@@ -1140,18 +1148,26 @@ namespace octave
 // be needed by pt-lvalue, which calls subsref?)
 
 static void
 final_index_error (octave::index_exception& e,
                    const octave::tree_expression *expr)
 {
   std::string extra_message;
 
+  // FIXME: make this a member function for direct access to symbol
+  // table and scope?
+
+  octave::symbol_scope *scope
+    = octave::__require_current_scope__ ("final_index_error");
+
+  octave::symbol_record::context_id context = scope->current_context ();
+
   if (expr->is_identifier ()
-      && dynamic_cast<const octave::tree_identifier *> (expr)->is_variable ())
+      && dynamic_cast<const octave::tree_identifier *> (expr)->is_variable (context))
     {
       std::string var = expr->name ();
 
       e.set_var (var);
 
       octave::symbol_table& symtab = octave::__get_symbol_table__ ("final_index_error");
 
       octave_value fcn = symtab.find_function (var);
@@ -1267,17 +1283,21 @@ namespace octave
     octave_value base_expr_val;
 
     tree_expression *expr = idx_expr.expression ();
 
     if (expr->is_identifier () && type[beg] == '(')
       {
         tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
 
-        if (! id->is_variable ())
+        symbol_scope *scope = get_current_scope ();
+
+        symbol_record::context_id context = scope->current_context ();
+
+        if (! id->is_variable (context))
           {
             octave_value_list first_args;
 
             tree_argument_list *al = *p_args;
 
             if (al && al->length () > 0)
               {
                 // Function calls inside an argument list can't have
@@ -1292,17 +1312,17 @@ namespace octave
 
                 string_vector anm = *p_arg_nm;
                 first_args = al->convert_to_const_vector (this);
                 first_args.stash_name_tags (anm);
               }
 
             octave_function *fcn = nullptr;
 
-            octave_value val = id->do_lookup (first_args);
+            octave_value val = id->do_lookup (context, first_args);
 
             if (val.is_function ())
               fcn = val.function_value (true);
 
             if (fcn)
               {
                 try
                   {
@@ -2253,19 +2273,23 @@ namespace octave
                 // FIXME: it seems that we should just have to
                 // evaluate the expression and that should take care of
                 // everything, binding ans as necessary?
 
                 bool do_bind_ans = false;
 
                 if (expr->is_identifier ())
                   {
+                    symbol_scope *scope = get_current_scope ();
+
+                    symbol_record::context_id context = scope->current_context ();
+
                     tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
 
-                    do_bind_ans = (! id->is_variable ());
+                    do_bind_ans = (! id->is_variable (context));
                   }
                 else
                   do_bind_ans = (! expr->is_assignment_expression ());
 
                 octave_value tmp_result = evaluate (expr, 0);
 
                 if (do_bind_ans && tmp_result.is_defined ())
                   bind_ans (tmp_result, expr->print_result ()
@@ -2442,21 +2466,20 @@ namespace octave
     }
 
     if (execution_error)
       {
         tree_statement_list *catch_code = cmd.cleanup ();
         if (catch_code)
           {
             tree_identifier *expr_id = cmd.identifier ();
-            octave_lvalue ult;
 
             if (expr_id)
               {
-                ult = expr_id->lvalue (this);
+                octave_lvalue ult = expr_id->lvalue (this);
 
                 octave_scalar_map err;
 
                 err.assign ("message", last_error_message ());
                 err.assign ("identifier", last_error_id ());
                 err.assign ("stack", last_error_stack ());
 
                 ult.assign (octave_value::op_asn_eq, err);
@@ -2710,18 +2733,17 @@ namespace octave
           {
             octave_value_list lst = val.list_value ();
 
             for (octave_idx_type i = 0; i < lst.length (); i++)
               bind_ans (lst(i), print);
           }
         else
           {
-            symbol_scope *scope
-              = m_interpreter.require_current_scope ("tree_evaluator::bind_ans");
+            symbol_scope *scope = get_current_scope ();
 
             scope->force_assign (ans, val);
 
             if (print)
               {
                 octave_value_list args = ovl (val);
                 args.stash_name_tags (string_vector (ans));
                 feval ("display", args);
diff --git a/libinterp/parse-tree/pt-id.cc b/libinterp/parse-tree/pt-id.cc
--- a/libinterp/parse-tree/pt-id.cc
+++ b/libinterp/parse-tree/pt-id.cc
@@ -35,20 +35,21 @@ along with Octave; see the file COPYING.
 #include "variables.h"
 
 namespace octave
 {
   // Symbols from the symbol table.
 
   class tree_evaluator;
 
-  void tree_identifier::link_to_global (const symbol_record& global_sym)
+  void tree_identifier::link_to_global (symbol_scope *global_scope,
+                                        const symbol_record& global_sym)
   {
     if (! sym.is_global ())
-      sym.bind_fwd_rep (global_sym);
+      sym.bind_fwd_rep (global_scope, global_sym);
   }
 
   void
   tree_identifier::eval_undefined_error (void)
   {
     int l = line ();
     int c = column ();
 
@@ -59,22 +60,24 @@ namespace octave
                      "'%s' undefined", name ().c_str ());
     else
       error_with_id ("Octave:undefined-function",
                      "'%s' undefined near line %d column %d",
                      name ().c_str (), l, c);
   }
 
   octave_lvalue
-  tree_identifier::lvalue (tree_evaluator *)
+  tree_identifier::lvalue (tree_evaluator *tw)
   {
     if (sym.is_added_static ())
       static_workspace_error ();
 
-    return octave_lvalue (sym);
+    symbol_scope *scope = tw->get_current_scope ();
+
+    return octave_lvalue (sym, scope->current_context ());
   }
 
   tree_identifier *
   tree_identifier::dup (symbol_scope& scope) const
   {
     // The new tree_identifier object contains a symbol_record
     // entry from the duplicated scope.
 
diff --git a/libinterp/parse-tree/pt-id.h b/libinterp/parse-tree/pt-id.h
--- a/libinterp/parse-tree/pt-id.h
+++ b/libinterp/parse-tree/pt-id.h
@@ -66,19 +66,25 @@ namespace octave
     ~tree_identifier (void) = default;
 
     bool has_magic_end (void) const { return (name () == "end"); }
 
     bool is_identifier (void) const { return true; }
 
     std::string name (void) const { return sym.name (); }
 
-    bool is_defined (void) { return sym.is_defined (); }
+    bool is_defined (symbol_record::context_id context)
+    {
+      return sym.is_defined (context);
+    }
 
-    virtual bool is_variable (void) const { return sym.is_variable (); }
+    virtual bool is_variable (symbol_record::context_id context) const
+    {
+      return sym.is_variable (context);
+    }
 
     virtual bool is_black_hole (void) { return false; }
 
     // Try to find a definition for an identifier.  Here's how:
     //
     //   * If the identifier is already defined and is a function defined
     //     in an function file that has been modified since the last time
     //     we parsed it, parse it again.
@@ -88,22 +94,24 @@ namespace octave
     //
     //   * If the identifier is still undefined, try looking for an
     //     function file to parse.
     //
     //   * On systems that support dynamic linking, we prefer .oct files,
     //     then .mex files, then .m files.
 
     octave_value
-    do_lookup (const octave_value_list& args = octave_value_list ())
+    do_lookup (symbol_record::context_id context,
+               const octave_value_list& args = octave_value_list ())
     {
-      return sym.find (args);
+      return sym.find (context, args);
     }
 
-    void link_to_global (const symbol_record& global_sym);
+    void link_to_global (symbol_scope *global_scope,
+                         const symbol_record& global_sym);
 
     void mark_persistent (void) { sym.init_persistent (); }
 
     void mark_as_formal_parameter (void) { sym.mark_formal (); }
 
     // We really need to know whether this symbol referst to a variable
     // or a function, but we may not know that yet.
 
@@ -141,17 +149,17 @@ namespace octave
   {
   public:
 
     tree_black_hole (int l = -1, int c = -1)
       : tree_identifier (l, c) { }
 
     std::string name (void) const { return "~"; }
 
-    bool is_variable (void) const { return false; }
+    bool is_variable (symbol_record::context_id) const { return false; }
 
     bool is_black_hole (void) { return true; }
 
     tree_black_hole * dup (symbol_scope&) const
     {
       return new tree_black_hole;
     }
 
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -201,25 +201,27 @@ namespace octave
 // be needed by pt-lvalue, which calls subsref?)
 
 static void
 final_index_error (octave::index_exception& e,
                    const octave::tree_expression *expr)
 {
   std::string extra_message;
 
+  octave::symbol_table& symtab = octave::__get_symbol_table__ ("final_index_error");
+
+  octave::symbol_record::context_id context = symtab.current_context ();
+
   if (expr->is_identifier ()
-      && dynamic_cast<const octave::tree_identifier *> (expr)->is_variable ())
+      && dynamic_cast<const octave::tree_identifier *> (expr)->is_variable (context))
     {
       std::string var = expr->name ();
 
       e.set_var (var);
 
-      octave::symbol_table& symtab = octave::__get_symbol_table__ ("final_index_error");
-
       octave_value fcn = symtab.find_function (var);
 
       if (fcn.is_function ())
         {
           octave_function *fp = fcn.function_value ();
 
           if (fp && fp->name () == var)
             extra_message = " (note: variable '" + var + "' shadows function)";
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -792,17 +792,17 @@ void
       {
         // stolen from octave::tree_evaluator::visit_statement
         bool do_bind_ans = false;
 
         if (expr->is_identifier ())
           {
             tree_identifier *id = dynamic_cast<tree_identifier *> (expr);
 
-            do_bind_ans = (! id->is_variable ());
+            do_bind_ans = (! id->is_variable (scope->current_context ()));
           }
         else
           do_bind_ans = (! expr->is_assignment_expression ());
 
         jit_value *expr_result = visit (expr);
 
         if (do_bind_ans)
           do_assign ("ans", expr_result, expr->print_result ());
@@ -1139,17 +1139,17 @@ void
     symbol_record record = symtab.find_symbol (vname, scope);
     if (record.is_persistent () || record.is_global ())
       throw jit_fail_exception ("Persistent and global not yet supported");
 
     if (converting_function)
       return create_variable (vname, jit_typeinfo::get_any (), false);
     else
       {
-        octave_value val = record.varval ();
+        octave_value val = record.varval (scope->current_context ());
         if (val.is_undefined ())
           val = symtab.find_function (vname);
 
         jit_type *type = jit_typeinfo::type_of (val);
         bounds.push_back (type_bound (type, vname));
 
         return create_variable (vname, type);
       }
diff --git a/libinterp/parse-tree/pt-misc.cc b/libinterp/parse-tree/pt-misc.cc
--- a/libinterp/parse-tree/pt-misc.cc
+++ b/libinterp/parse-tree/pt-misc.cc
@@ -55,23 +55,23 @@ namespace octave
 
     for (tree_decl_elt *elt : *this)
       retval.push_back (elt->name ());
 
     return retval;
   }
 
   bool
-  tree_parameter_list::is_defined (void)
+  tree_parameter_list::is_defined (symbol_record::context_id context)
   {
     bool status = true;
 
     for (tree_decl_elt *elt : *this)
       {
-        if (! elt->is_variable ())
+        if (! elt->is_variable (context))
           {
             status = false;
             break;
           }
       }
 
     return status;
   }
diff --git a/libinterp/parse-tree/pt-misc.h b/libinterp/parse-tree/pt-misc.h
--- a/libinterp/parse-tree/pt-misc.h
+++ b/libinterp/parse-tree/pt-misc.h
@@ -71,17 +71,17 @@ namespace octave
     void mark_varargs (void) { marked_for_varargs = 1; }
 
     void mark_varargs_only (void) { marked_for_varargs = -1; }
 
     bool takes_varargs (void) const { return marked_for_varargs != 0; }
 
     bool varargs_only (void) { return (marked_for_varargs < 0); }
 
-    bool is_defined (void);
+    bool is_defined (symbol_record::context_id context);
 
     std::list<std::string> variable_names (void) const;
 
     tree_parameter_list * dup (symbol_scope& scope) const;
 
     void accept (tree_walker& tw)
     {
       tw.visit_parameter_list (*this);
