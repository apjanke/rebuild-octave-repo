# HG changeset patch
# User Rik <rik@octave.org>
# Date 1494344767 25200
#      Tue May 09 08:46:07 2017 -0700
# Node ID d691ed3082379ee74181e2312664664c8fb8d2bc
# Parent  70edb5512c6e98a3645ec75001d57dd6f4ef1425
maint: Clean up #includes in liboctave/numeric directory.

* build-aux/mk-opts.pl: Change Perl to generate "" around local include
libraries rather than <>.  Include "lo-math.h" rather than <cmath>.

* CollocWt.cc, DAERTFunc.h, DASPK.cc, DASPK.h, DASRT.cc, DASRT.h, DASSL.cc,
DASSL.h, DET.h, EIG.cc, EIG.h, LSODE.cc, LSODE.h, ODE.h, ODES.cc, ODESFunc.h,
Quad.cc, aepbalance.cc, base-de.h, base-min.h, bsxfun-decl.h, bsxfun-defs.cc,
bsxfun.h, chol.cc, eigs-base.cc, fEIG.cc, fEIG.h, gepbalance.cc, gsvd.cc,
hess.cc, lo-blas-proto.h, lo-lapack-proto.h, lo-mappers.cc, lo-mappers.h,
lo-qrupdate-proto.h, lo-slatec-proto.h, lo-specfun.cc, lo-specfun.h, lu.cc,
lu.h, oct-convn.cc, oct-convn.h, oct-fftw.cc, oct-fftw.h, oct-norm.cc,
oct-rand.cc, oct-rand.h, oct-spparms.cc, oct-spparms.h, qr.cc, qr.h, qrp.cc,
randgamma.cc, randpoisson.cc, schur.cc, schur.h, sparse-chol.cc, sparse-chol.h,
sparse-dmsolve.cc, sparse-lu.cc, sparse-lu.h, sparse-qr.cc, sparse-qr.h,
svd.cc:
Rationalize #includes.  Use forward declarations of just classes where
possible.  Reformat some long lines < 80 characters.  Reformat some comments
for readabliity.

* mx-inlines.cc: Rationalize #includes for this file in liboctave/operators
used by many in liboctave/numeric.

diff --git a/build-aux/mk-opts.pl b/build-aux/mk-opts.pl
--- a/build-aux/mk-opts.pl
+++ b/build-aux/mk-opts.pl
@@ -105,17 +105,17 @@ sub parse_input
         }
       elsif (/^\s*FCN_NAME\s*=\s*"(\w+)"\s*$/)
         {
           die "duplicate FCN_NAME" if defined $FCN_NAME;
           $FCN_NAME = $1;
         }
       elsif (/^\s*INCLUDE\s*=\s*"(\S+)"\s*$/)
         {
-          $INCLUDE .= "#include <$1>\n";
+          $INCLUDE .= qq (#include "$1"\n);
         }
       elsif (/^\s*DOC_STRING\s*$/)
         {
           die "duplicate DOC_STRING" if defined $DOC_STRING;
           while (defined ($_ = <DEFN_FILE>) and not /^\s*END_DOC_STRING\s*$/)
           {
             $DOC_STRING .= $_;
           }
@@ -369,20 +369,19 @@ sub emit_opt_class_header
 
   print <<"_END_EMIT_OPT_CLASS_HEADER_";
 // DO NOT EDIT!
 // Generated automatically from $DEFN_FILE.
 
 #if ! defined (octave_${CLASS_NAME}_h)
 #define octave_${CLASS_NAME}_h 1
 
-#include <cmath>
-
 #include <limits>
 
+#include "lo-math.h"
 $INCLUDE
 
 class
 $CLASS_NAME
 {
 public:
 
   $CLASS_NAME (void)
diff --git a/liboctave/numeric/CollocWt.cc b/liboctave/numeric/CollocWt.cc
--- a/liboctave/numeric/CollocWt.cc
+++ b/liboctave/numeric/CollocWt.cc
@@ -19,22 +19,26 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
+#include <cassert>
+#include <cmath>
+
 #include <iostream>
 #include <limits>
 
+#include "Array.h"
 #include "CollocWt.h"
-#include "f77-fcn.h"
 #include "lo-error.h"
+#include "lo-mappers.h"
 
 // The following routines jcobi, dif, and dfopr are based on the code
 // found in Villadsen, J. and M. L. Michelsen, Solution of Differential
 // Equation Models by Polynomial Approximation, Prentice-Hall (1978)
 // pages 418-420.
 //
 // Translated to C++ by jwe.
 
diff --git a/liboctave/numeric/DAERTFunc.h b/liboctave/numeric/DAERTFunc.h
--- a/liboctave/numeric/DAERTFunc.h
+++ b/liboctave/numeric/DAERTFunc.h
@@ -21,17 +21,16 @@ along with Octave; see the file COPYING.
 */
 
 #if ! defined (octave_DAERTFunc_h)
 #define octave_DAERTFunc_h 1
 
 #include "octave-config.h"
 
 #include "DAEFunc.h"
-#include "dMatrix.h"
 
 class
 DAERTFunc : public DAEFunc
 {
 public:
 
   typedef ColumnVector (*DAERTConstrFunc) (const ColumnVector& x, double t);
 
diff --git a/liboctave/numeric/DASPK.cc b/liboctave/numeric/DASPK.cc
--- a/liboctave/numeric/DASPK.cc
+++ b/liboctave/numeric/DASPK.cc
@@ -22,19 +22,19 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <sstream>
 
 #include "DASPK.h"
+#include "dMatrix.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
-#include "lo-math.h"
 #include "quit.h"
 
 typedef F77_INT (*daspk_fcn_ptr) (const double&, const double*, const double*,
                                   const double&, double*, F77_INT&, double*,
                                   F77_INT*);
 
 typedef F77_INT (*daspk_jac_ptr) (const double&, const double*, const double*,
                                   double*, const double&, double*, F77_INT*);
@@ -143,18 +143,17 @@ ddaspk_j (const double& time, const doub
   END_INTERRUPT_WITH_EXCEPTIONS;
 
   return 0;
 }
 
 ColumnVector
 DASPK::do_integrate (double tout)
 {
-  // FIXME: should handle all this option stuff just once
-  // for each new problem.
+  // FIXME: should handle all this option stuff just once for each new problem.
 
   ColumnVector retval;
 
   if (! initialized || restart || DAEFunc::reset || DASPK_options::reset)
     {
       integration_error = false;
 
       initialized = true;
@@ -243,17 +242,16 @@ DASPK::do_integrate (double tout)
           info(1) = 0;
         }
       else if (abs_tol_len == n && rel_tol_len == n)
         {
           info(1) = 1;
         }
       else
         {
-
           // FIXME: Should this be a warning?
           (*current_liboctave_error_handler)
             ("daspk: inconsistent sizes for tolerance arrays");
 
           integration_error = true;
           return retval;
         }
 
diff --git a/liboctave/numeric/DASPK.h b/liboctave/numeric/DASPK.h
--- a/liboctave/numeric/DASPK.h
+++ b/liboctave/numeric/DASPK.h
@@ -22,18 +22,21 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_DASPK_h)
 #define octave_DASPK_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
+#include "Array.h"
 #include "DASPK-opts.h"
 
+class Matrix;
+
 class
 OCTAVE_API
 DASPK : public DAE, public DASPK_options
 {
 public:
 
   DASPK (void)
     : DAE (), DASPK_options (), initialized (false), liw (0), lrw (0),
diff --git a/liboctave/numeric/DASRT.cc b/liboctave/numeric/DASRT.cc
--- a/liboctave/numeric/DASRT.cc
+++ b/liboctave/numeric/DASRT.cc
@@ -24,17 +24,16 @@ along with Octave; see the file COPYING.
 #  include "config.h"
 #endif
 
 #include <sstream>
 
 #include "DASRT.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
-#include "lo-math.h"
 #include "quit.h"
 
 typedef F77_INT (*dasrt_fcn_ptr) (const double&, const double*, const double*,
                                   double*, F77_INT&, double*, F77_INT*);
 
 typedef F77_INT (*dasrt_jac_ptr) (const double&, const double*, const double*,
                                   double*, const double&, double*, F77_INT*);
 
diff --git a/liboctave/numeric/DASRT.h b/liboctave/numeric/DASRT.h
--- a/liboctave/numeric/DASRT.h
+++ b/liboctave/numeric/DASRT.h
@@ -22,17 +22,19 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_DASRT_h)
 #define octave_DASRT_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
+#include "Array.h"
 #include "DASRT-opts.h"
+#include "dMatrix.h"
 
 class
 DASRT_result
 {
 public:
 
   DASRT_result (void)
     : x (), xdot (), t () { }
diff --git a/liboctave/numeric/DASSL.cc b/liboctave/numeric/DASSL.cc
--- a/liboctave/numeric/DASSL.cc
+++ b/liboctave/numeric/DASSL.cc
@@ -22,19 +22,19 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <sstream>
 
 #include "DASSL.h"
+#include "dMatrix.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
-#include "lo-math.h"
 #include "quit.h"
 
 typedef F77_INT (*dassl_fcn_ptr) (const double&, const double*,
                                   const double*, double*, F77_INT&,
                                   double*, F77_INT*);
 
 typedef F77_INT (*dassl_jac_ptr) (const double&, const double*,
                                   const double*, double*, const double&,
diff --git a/liboctave/numeric/DASSL.h b/liboctave/numeric/DASSL.h
--- a/liboctave/numeric/DASSL.h
+++ b/liboctave/numeric/DASSL.h
@@ -22,18 +22,21 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_DASSL_h)
 #define octave_DASSL_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
+#include "Array.h"
 #include "DASSL-opts.h"
 
+class Matrix;
+
 class
 OCTAVE_API
 DASSL : public DAE, public DASSL_options
 {
 public:
 
   DASSL (void)
     : DAE (), DASSL_options (), initialized (false), liw (0), lrw (0),
diff --git a/liboctave/numeric/DET.h b/liboctave/numeric/DET.h
--- a/liboctave/numeric/DET.h
+++ b/liboctave/numeric/DET.h
@@ -20,19 +20,19 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_DET_h)
 #define octave_DET_h 1
 
 #include "octave-config.h"
 
-#include <cmath>
+#include "lo-mappers.h"
+#include "lo-math.h"
 #include "oct-cmplx.h"
-#include "lo-mappers.h"
 
 template <typename T>
 class
 base_det
 {
 public:
 
   base_det (T c = 1, int e = 0)
diff --git a/liboctave/numeric/EIG.cc b/liboctave/numeric/EIG.cc
--- a/liboctave/numeric/EIG.cc
+++ b/liboctave/numeric/EIG.cc
@@ -20,18 +20,20 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
+#include "Array.h"
 #include "EIG.h"
 #include "dColVector.h"
+#include "dMatrix.h"
 #include "lo-error.h"
 #include "lo-lapack-proto.h"
 
 octave_idx_type
 EIG::init (const Matrix& a, bool calc_rev, bool calc_lev, bool balance)
 {
   if (a.any_element_is_inf_or_nan ())
     (*current_liboctave_error_handler)
@@ -275,20 +277,21 @@ EIG::init (const ComplexMatrix& a, bool 
   Array<double> rcondv (dim_vector (n, 1));
   double *prcondv = rcondv.fortran_vec ();
 
   F77_XFCN (zgeevx, ZGEEVX, (F77_CONST_CHAR_ARG2 (balance ? "B" : "N", 1),
                              F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
                              F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              n, F77_DBLE_CMPLX_ARG (tmp_data), n,
-                             F77_DBLE_CMPLX_ARG (pw), F77_DBLE_CMPLX_ARG (pvl), n,
-                             F77_DBLE_CMPLX_ARG (pvr), n, ilo, ihi, pscale, abnrm,
-                             prconde, prcondv,
-                             F77_DBLE_CMPLX_ARG (&dummy_work), lwork, prwork, info
+                             F77_DBLE_CMPLX_ARG (pw), F77_DBLE_CMPLX_ARG (pvl),
+                             n, F77_DBLE_CMPLX_ARG (pvr), n, ilo, ihi,
+                             pscale, abnrm, prconde, prcondv,
+                             F77_DBLE_CMPLX_ARG (&dummy_work), lwork, prwork,
+                             info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("zgeevx workspace query failed");
 
@@ -296,19 +299,19 @@ EIG::init (const ComplexMatrix& a, bool 
   Array<Complex> work (dim_vector (lwork, 1));
   Complex *pwork = work.fortran_vec ();
 
   F77_XFCN (zgeevx, ZGEEVX, (F77_CONST_CHAR_ARG2 (balance ? "B" : "N", 1),
                              F77_CONST_CHAR_ARG2 (calc_lev ? "V" : "N", 1),
                              F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                              F77_CONST_CHAR_ARG2 ("N", 1),
                              n, F77_DBLE_CMPLX_ARG (tmp_data), n,
-                             F77_DBLE_CMPLX_ARG (pw), F77_DBLE_CMPLX_ARG (pvl), n,
-                             F77_DBLE_CMPLX_ARG (pvr), n, ilo, ihi, pscale, abnrm,
-                             prconde, prcondv,
+                             F77_DBLE_CMPLX_ARG (pw), F77_DBLE_CMPLX_ARG (pvl),
+                             n, F77_DBLE_CMPLX_ARG (pvr), n, ilo, ihi,
+                             pscale, abnrm, prconde, prcondv,
                              F77_DBLE_CMPLX_ARG (pwork), lwork, prwork, info
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)
                              F77_CHAR_ARG_LEN (1)));
 
   if (info < 0)
     (*current_liboctave_error_handler) ("unrecoverable error in zgeevx");
@@ -655,17 +658,18 @@ EIG::init (const ComplexMatrix& a, const
   F77_XFCN (zggev, ZGGEV, (F77_CONST_CHAR_ARG2 ("N", 1),
                            F77_CONST_CHAR_ARG2 (calc_rev ? "V" : "N", 1),
                            n, F77_DBLE_CMPLX_ARG (atmp_data), n,
                            F77_DBLE_CMPLX_ARG (btmp_data), n,
                            F77_DBLE_CMPLX_ARG (palpha),
                            F77_DBLE_CMPLX_ARG (pbeta),
                            F77_DBLE_CMPLX_ARG (pvl), n,
                            F77_DBLE_CMPLX_ARG (pvr), n,
-                           F77_DBLE_CMPLX_ARG (&dummy_work), lwork, prwork, info
+                           F77_DBLE_CMPLX_ARG (&dummy_work), lwork, prwork,
+                           info
                            F77_CHAR_ARG_LEN (1)
                            F77_CHAR_ARG_LEN (1)));
 
   if (info != 0)
     (*current_liboctave_error_handler) ("zggev workspace query failed");
 
   lwork = static_cast<F77_INT> (dummy_work.real ());
   Array<Complex> work (dim_vector (lwork, 1));
diff --git a/liboctave/numeric/EIG.h b/liboctave/numeric/EIG.h
--- a/liboctave/numeric/EIG.h
+++ b/liboctave/numeric/EIG.h
@@ -22,19 +22,20 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_EIG_h)
 #define octave_EIG_h 1
 
 #include "octave-config.h"
 
 #include <iosfwd>
 
-#include "dMatrix.h"
+#include "CColVector.h"
 #include "CMatrix.h"
-#include "CColVector.h"
+
+class Matrix;
 
 class
 OCTAVE_API
 EIG
 {
   friend class Matrix;
   friend class ComplexMatrix;
 
diff --git a/liboctave/numeric/LSODE.cc b/liboctave/numeric/LSODE.cc
--- a/liboctave/numeric/LSODE.cc
+++ b/liboctave/numeric/LSODE.cc
@@ -24,17 +24,16 @@ along with Octave; see the file COPYING.
 #  include "config.h"
 #endif
 
 #include <sstream>
 
 #include "LSODE.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
-#include "lo-math.h"
 #include "quit.h"
 
 typedef F77_INT (*lsode_fcn_ptr) (const F77_INT&, const double&, double*,
                                   double*, F77_INT&);
 
 typedef F77_INT (*lsode_jac_ptr) (const F77_INT&, const double&, double*,
                                   const F77_INT&, const F77_INT&, double*,
                                   const F77_INT&);
diff --git a/liboctave/numeric/LSODE.h b/liboctave/numeric/LSODE.h
--- a/liboctave/numeric/LSODE.h
+++ b/liboctave/numeric/LSODE.h
@@ -22,16 +22,17 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_LSODE_h)
 #define octave_LSODE_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
+#include "Array.h"
 #include "LSODE-opts.h"
 
 class
 OCTAVE_API
 LSODE : public ODE, public LSODE_options
 {
 public:
 
diff --git a/liboctave/numeric/ODE.h b/liboctave/numeric/ODE.h
--- a/liboctave/numeric/ODE.h
+++ b/liboctave/numeric/ODE.h
@@ -22,16 +22,17 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_ODE_h)
 #define octave_ODE_h 1
 
 #include "octave-config.h"
 
 #include "ODEFunc.h"
 #include "base-de.h"
+#include "dMatrix.h"
 
 class
 ODE : public base_diff_eqn, public ODEFunc
 {
 public:
 
   ODE (void)
     : base_diff_eqn (), ODEFunc () { }
diff --git a/liboctave/numeric/ODES.cc b/liboctave/numeric/ODES.cc
--- a/liboctave/numeric/ODES.cc
+++ b/liboctave/numeric/ODES.cc
@@ -20,17 +20,16 @@ along with Octave; see the file COPYING.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "ODES.h"
-#include "lo-error.h"
 
 void
 ODES::initialize (const ColumnVector& xx, double tt)
 {
   base_diff_eqn::initialize (xx, tt);
   xdot = ColumnVector (xx.numel (), 0.0);
 }
 
diff --git a/liboctave/numeric/ODESFunc.h b/liboctave/numeric/ODESFunc.h
--- a/liboctave/numeric/ODESFunc.h
+++ b/liboctave/numeric/ODESFunc.h
@@ -22,16 +22,18 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_ODESFunc_h)
 #define octave_ODESFunc_h 1
 
 #include "octave-config.h"
 
 #include "dMatrix.h"
 
+class ColumnVector;
+
 class
 ODESFunc
 {
 public:
 
   struct DAEJac
   {
     Matrix *dfdxdot;
diff --git a/liboctave/numeric/Quad.cc b/liboctave/numeric/Quad.cc
--- a/liboctave/numeric/Quad.cc
+++ b/liboctave/numeric/Quad.cc
@@ -19,16 +19,19 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
+#include <cassert>
+
+#include "Array.h"
 #include "Quad.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "quit.h"
 #include "sun-utils.h"
 
 static integrand_fcn user_fcn;
 static float_integrand_fcn float_user_fcn;
diff --git a/liboctave/numeric/aepbalance.cc b/liboctave/numeric/aepbalance.cc
--- a/liboctave/numeric/aepbalance.cc
+++ b/liboctave/numeric/aepbalance.cc
@@ -20,27 +20,24 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include <string>
-
-#include "CColVector.h"
 #include "CMatrix.h"
 #include "aepbalance.h"
 #include "dColVector.h"
 #include "dMatrix.h"
-#include "fCColVector.h"
 #include "fCMatrix.h"
 #include "fColVector.h"
 #include "fMatrix.h"
+#include "lo-error.h"
 #include "lo-lapack-proto.h"
 
 static inline char
 get_job (bool noperm, bool noscal)
 {
   return noperm ? (noscal ? 'N' : 'S') : (noscal ? 'P' : 'B');
 }
 
@@ -51,17 +48,18 @@ namespace octave
     template <>
     aepbalance<Matrix>::aepbalance (const Matrix& a, bool noperm, bool noscal)
       : balanced_mat (a), scale (), ilo (), ihi (),
         job (get_job (noperm, noscal))
     {
       F77_INT n = octave::to_f77_int (a.cols ());
 
       if (a.rows () != n)
-        (*current_liboctave_error_handler) ("aepbalance: requires square matrix");
+        (*current_liboctave_error_handler)
+          ("aepbalance: requires square matrix");
 
       scale = ColumnVector (n);
 
       F77_INT info, t_ilo, t_ihi;
 
       F77_XFCN (dgebal, DGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1), n,
                                  balanced_mat.fortran_vec (), n,
                                  t_ilo, t_ihi, scale.fortran_vec (), info
@@ -101,17 +99,18 @@ namespace octave
     aepbalance<FloatMatrix>::aepbalance (const FloatMatrix& a, bool noperm,
                                          bool noscal)
       : balanced_mat (a), scale (), ilo (), ihi (),
         job (get_job (noperm, noscal))
     {
       F77_INT n = octave::to_f77_int (a.cols ());
 
       if (a.rows () != n)
-        (*current_liboctave_error_handler) ("aepbalance: requires square matrix");
+        (*current_liboctave_error_handler)
+          ("aepbalance: requires square matrix");
 
       scale = FloatColumnVector (n);
 
       F77_INT info, t_ilo, t_ihi;
 
       F77_XFCN (sgebal, SGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1), n,
                                  balanced_mat.fortran_vec (), n, t_ilo,
                                  t_ihi, scale.fortran_vec (), info
@@ -151,17 +150,18 @@ namespace octave
     aepbalance<ComplexMatrix>::aepbalance (const ComplexMatrix& a, bool noperm,
                                            bool noscal)
       : balanced_mat (a), scale (), ilo (), ihi (),
         job (get_job (noperm, noscal))
     {
       F77_INT n = octave::to_f77_int (a.cols ());
 
       if (a.rows () != n)
-        (*current_liboctave_error_handler) ("aepbalance: requires square matrix");
+        (*current_liboctave_error_handler)
+          ("aepbalance: requires square matrix");
 
       scale = ColumnVector (n);
 
       F77_INT info, t_ilo, t_ihi;
 
       F77_XFCN (zgebal, ZGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1), n,
                                  F77_DBLE_CMPLX_ARG (balanced_mat.fortran_vec ()),
                                  n, t_ilo, t_ihi, scale.fortran_vec (), info
@@ -202,17 +202,18 @@ namespace octave
     aepbalance<FloatComplexMatrix>::aepbalance (const FloatComplexMatrix& a,
                                                 bool noperm, bool noscal)
       : balanced_mat (a), scale (), ilo (), ihi (),
         job (get_job (noperm, noscal))
     {
       F77_INT n = octave::to_f77_int (a.cols ());
 
       if (a.rows () != n)
-        (*current_liboctave_error_handler) ("aepbalance: requires square matrix");
+        (*current_liboctave_error_handler)
+          ("aepbalance: requires square matrix");
 
       scale = FloatColumnVector (n);
 
       F77_INT info, t_ilo, t_ihi;
 
       F77_XFCN (cgebal, CGEBAL, (F77_CONST_CHAR_ARG2 (&job, 1), n,
                                  F77_CMPLX_ARG (balanced_mat.fortran_vec ()),
                                  n, t_ilo, t_ihi, scale.fortran_vec (), info
diff --git a/liboctave/numeric/base-de.h b/liboctave/numeric/base-de.h
--- a/liboctave/numeric/base-de.h
+++ b/liboctave/numeric/base-de.h
@@ -23,17 +23,16 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_base_de_h)
 #define octave_base_de_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
 #include "dColVector.h"
-#include "dMatrix.h"
 
 class
 base_diff_eqn
 {
 public:
 
   base_diff_eqn (void)
     : x (), t (0.0), stop_time (0.0), stop_time_set (false),
diff --git a/liboctave/numeric/base-min.h b/liboctave/numeric/base-min.h
--- a/liboctave/numeric/base-min.h
+++ b/liboctave/numeric/base-min.h
@@ -43,24 +43,23 @@ public:
   base_minimizer& operator = (const base_minimizer& a)
   {
     if (this != &a)
       x = a.x;
 
     return *this;
   }
 
-  // Derived classes must provide a function to actually do the
-  // minimization.
+  // Derived classes must provide a function to actually do the minimization.
 
   virtual ColumnVector do_minimize (double& objf, octave_idx_type& inform,
                                     ColumnVector& lambda) = 0;
 
-  // Lots of ways to call the single function and optionally set and
-  // get additional information.
+  // Lots of ways to call the single function and optionally set and get
+  // additional information.
 
   virtual ColumnVector minimize (void)
   {
     double objf;
     octave_idx_type inform;
     ColumnVector lambda;
     return do_minimize (objf, inform, lambda);
   }
diff --git a/liboctave/numeric/bsxfun-decl.h b/liboctave/numeric/bsxfun-decl.h
--- a/liboctave/numeric/bsxfun-decl.h
+++ b/liboctave/numeric/bsxfun-decl.h
@@ -19,18 +19,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if ! defined (octave_bsxfun_decl_h)
 #define octave_bsxfun_decl_h 1
 
-#include "octave-config.h"
-
 #define BSXFUN_OP_DECL(OP, ARRAY, API)                          \
   extern API ARRAY bsxfun_ ## OP (const ARRAY&, const ARRAY&);
 
 #define BSXFUN_OP2_DECL(OP, ARRAY, ARRAY1, ARRAY2, API)                 \
   extern API ARRAY bsxfun_ ## OP (const ARRAY1&, const ARRAY2&);
 
 #define BSXFUN_REL_DECL(OP, ARRAY, API)                                 \
   extern API boolNDArray bsxfun_ ## OP (const ARRAY&, const ARRAY&);
diff --git a/liboctave/numeric/bsxfun-defs.cc b/liboctave/numeric/bsxfun-defs.cc
--- a/liboctave/numeric/bsxfun-defs.cc
+++ b/liboctave/numeric/bsxfun-defs.cc
@@ -19,28 +19,25 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if ! defined (octave_bsxfun_defs_h)
 #define octave_bsxfun_defs_h 1
 
-// This file should not include config.h.  It is only included in other
-// C++ source files that should have included config.h before including
-// this file.
+// This file should *not* include config.h.  It is only included in other C++
+// source files that should have included config.h before including this file.
 
 #include <algorithm>
-#include <iostream>
 
 #include "dim-vector.h"
+#include "lo-error.h"
+#include "mx-inlines.cc"
 #include "oct-locbuf.h"
-#include "lo-error.h"
-
-#include "mx-inlines.cc"
 
 template <typename R, typename X, typename Y>
 Array<R>
 do_bsxfun_op (const Array<X>& x, const Array<Y>& y,
               void (*op_vv) (size_t, R *, const X *, const Y *),
               void (*op_sv) (size_t, R *, X, const Y *),
               void (*op_vs) (size_t, R *, const X *, Y))
 {
diff --git a/liboctave/numeric/bsxfun.h b/liboctave/numeric/bsxfun.h
--- a/liboctave/numeric/bsxfun.h
+++ b/liboctave/numeric/bsxfun.h
@@ -23,20 +23,19 @@ along with Octave; see the file COPYING.
 // Author: Jordi Gutiérrez Hermoso <jordigh@octave.org>
 
 #if ! defined (octave_bsxfun_h)
 #define octave_bsxfun_h 1
 
 #include "octave-config.h"
 
 #include <algorithm>
+#include <string>
 
-#include "Array.h"
 #include "dim-vector.h"
-#include "lo-error.h"
 
 inline
 bool
 is_valid_bsxfun (const std::string& name, const dim_vector& dx,
                  const dim_vector& dy)
 {
   for (int i = 0; i < std::min (dx.ndims (), dy.ndims ()); i++)
     {
diff --git a/liboctave/numeric/chol.cc b/liboctave/numeric/chol.cc
--- a/liboctave/numeric/chol.cc
+++ b/liboctave/numeric/chol.cc
@@ -20,31 +20,26 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include <vector>
-
+#include "Array.h"
 #include "CColVector.h"
 #include "CMatrix.h"
-#include "CRowVector.h"
 #include "chol.h"
 #include "dColVector.h"
 #include "dMatrix.h"
-#include "dRowVector.h"
 #include "fCColVector.h"
 #include "fCMatrix.h"
-#include "fCRowVector.h"
 #include "fColVector.h"
 #include "fMatrix.h"
-#include "fRowVector.h"
 #include "lo-error.h"
 #include "lo-lapack-proto.h"
 #include "lo-qrupdate-proto.h"
 #include "oct-locbuf.h"
 #include "oct-norm.h"
 
 #if ! defined (HAVE_QRUPDATE)
 #  include "qr.h"
diff --git a/liboctave/numeric/eigs-base.cc b/liboctave/numeric/eigs-base.cc
--- a/liboctave/numeric/eigs-base.cc
+++ b/liboctave/numeric/eigs-base.cc
@@ -22,29 +22,31 @@ along with Octave; see the file COPYING.
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <cmath>
 #include <iostream>
 
+#include "Array.h"
 #include "CSparse.h"
 #include "MatrixType.h"
+#include "PermMatrix.h"
 #include "chol.h"
 #include "dSparse.h"
 #include "eigs-base.h"
-#include "f77-fcn.h"
 #include "lo-arpack-proto.h"
 #include "lo-blas-proto.h"
+#include "lo-error.h"
+#include "lo-ieee.h"
 #include "lu.h"
 #include "mx-ops.h"
 #include "oct-locbuf.h"
 #include "oct-rand.h"
-#include "quit.h"
 #include "sparse-chol.h"
 #include "sparse-lu.h"
 
 #if defined (HAVE_ARPACK)
 
 static void
 warn_convergence (void)
 {
diff --git a/liboctave/numeric/fEIG.cc b/liboctave/numeric/fEIG.cc
--- a/liboctave/numeric/fEIG.cc
+++ b/liboctave/numeric/fEIG.cc
@@ -20,18 +20,20 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
+#include "Array.h"
 #include "fEIG.h"
 #include "fColVector.h"
+#include "fMatrix.h"
 #include "lo-error.h"
 #include "lo-lapack-proto.h"
 
 octave_idx_type
 FloatEIG::init (const FloatMatrix& a, bool calc_rev, bool calc_lev,
                 bool balance)
 {
   if (a.any_element_is_inf_or_nan ())
diff --git a/liboctave/numeric/fEIG.h b/liboctave/numeric/fEIG.h
--- a/liboctave/numeric/fEIG.h
+++ b/liboctave/numeric/fEIG.h
@@ -22,19 +22,20 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_fEIG_h)
 #define octave_fEIG_h 1
 
 #include "octave-config.h"
 
 #include <iosfwd>
 
-#include "fMatrix.h"
+#include "fCColVector.h"
 #include "fCMatrix.h"
-#include "fCColVector.h"
+
+class FloatMatrix;
 
 class
 OCTAVE_API
 FloatEIG
 {
   friend class FloatMatrix;
   friend class FloatComplexMatrix;
 
diff --git a/liboctave/numeric/gepbalance.cc b/liboctave/numeric/gepbalance.cc
--- a/liboctave/numeric/gepbalance.cc
+++ b/liboctave/numeric/gepbalance.cc
@@ -19,41 +19,41 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include <string>
-#include <vector>
-
-#include "Array-util.h"
 #include "CMatrix.h"
 #include "dMatrix.h"
 #include "fCMatrix.h"
 #include "fMatrix.h"
 #include "gepbalance.h"
+#include "lo-array-errwarn.h"
+#include "lo-error.h"
 #include "lo-lapack-proto.h"
 #include "oct-locbuf.h"
+#include "quit.h"
 
 namespace octave
 {
   namespace math
   {
     template <>
     octave_idx_type
     gepbalance<Matrix>::init (const Matrix& a, const Matrix& b,
                               const std::string& balance_job)
     {
       F77_INT n = octave::to_f77_int (a.cols ());
 
       if (a.rows () != n)
-        (*current_liboctave_error_handler) ("GEPBALANCE requires square matrix");
+        (*current_liboctave_error_handler)
+          ("GEPBALANCE requires square matrix");
 
       if (a.dims () != b.dims ())
         octave::err_nonconformant ("GEPBALANCE", n, n, b.rows(), b.cols());
 
       F77_INT info;
       F77_INT ilo;
       F77_INT ihi;
 
@@ -111,17 +111,18 @@ namespace octave
     {
       F77_INT n = octave::to_f77_int (a.cols ());
 
       if (a.rows () != n)
         (*current_liboctave_error_handler)
           ("FloatGEPBALANCE requires square matrix");
 
       if (a.dims () != b.dims ())
-        octave::err_nonconformant ("FloatGEPBALANCE", n, n, b.rows(), b.cols());
+        octave::err_nonconformant ("FloatGEPBALANCE",
+                                   n, n, b.rows(), b.cols());
 
       F77_INT info;
       F77_INT ilo;
       F77_INT ihi;
 
       OCTAVE_LOCAL_BUFFER (float, plscale, n);
       OCTAVE_LOCAL_BUFFER (float, prscale, n);
       OCTAVE_LOCAL_BUFFER (float, pwork, 6 * n);
@@ -177,17 +178,18 @@ namespace octave
     {
       F77_INT n = octave::to_f77_int (a.cols ());
 
       if (a.rows () != n)
         (*current_liboctave_error_handler)
           ("ComplexGEPBALANCE requires square matrix");
 
       if (a.dims () != b.dims ())
-        octave::err_nonconformant ("ComplexGEPBALANCE", n, n, b.rows(), b.cols());
+        octave::err_nonconformant ("ComplexGEPBALANCE",
+                                   n, n, b.rows(), b.cols());
 
       F77_INT info;
       F77_INT ilo;
       F77_INT ihi;
 
       OCTAVE_LOCAL_BUFFER (double, plscale, n);
       OCTAVE_LOCAL_BUFFER (double, prscale,  n);
       OCTAVE_LOCAL_BUFFER (double, pwork, 6 * n);
@@ -195,17 +197,18 @@ namespace octave
       balanced_mat = a;
       Complex *p_balanced_mat = balanced_mat.fortran_vec ();
       balanced_mat2 = b;
       Complex *p_balanced_mat2 = balanced_mat2.fortran_vec ();
 
       char job = balance_job[0];
 
       F77_XFCN (zggbal, ZGGBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 n, F77_DBLE_CMPLX_ARG (p_balanced_mat), n, F77_DBLE_CMPLX_ARG (p_balanced_mat2),
+                                 n, F77_DBLE_CMPLX_ARG (p_balanced_mat),
+                                 n, F77_DBLE_CMPLX_ARG (p_balanced_mat2),
                                  n, ilo, ihi, plscale, prscale, pwork, info
                                  F77_CHAR_ARG_LEN (1)));
 
       balancing_mat = Matrix (n, n, 0.0);
       balancing_mat2 = Matrix (n, n, 0.0);
       for (F77_INT i = 0; i < n; i++)
         {
           octave_quit ();
@@ -246,17 +249,18 @@ namespace octave
       if (a.rows () != n)
         {
           (*current_liboctave_error_handler)
             ("FloatComplexGEPBALANCE requires square matrix");
           return -1;
         }
 
       if (a.dims () != b.dims ())
-        octave::err_nonconformant ("FloatComplexGEPBALANCE", n, n, b.rows(), b.cols());
+        octave::err_nonconformant ("FloatComplexGEPBALANCE",
+                                   n, n, b.rows(), b.cols());
 
       F77_INT info;
       F77_INT ilo;
       F77_INT ihi;
 
       OCTAVE_LOCAL_BUFFER (float, plscale, n);
       OCTAVE_LOCAL_BUFFER (float, prscale, n);
       OCTAVE_LOCAL_BUFFER (float, pwork, 6 * n);
@@ -264,17 +268,18 @@ namespace octave
       balanced_mat = a;
       FloatComplex *p_balanced_mat = balanced_mat.fortran_vec ();
       balanced_mat2 = b;
       FloatComplex *p_balanced_mat2 = balanced_mat2.fortran_vec ();
 
       char job = balance_job[0];
 
       F77_XFCN (cggbal, CGGBAL, (F77_CONST_CHAR_ARG2 (&job, 1),
-                                 n, F77_CMPLX_ARG (p_balanced_mat), n, F77_CMPLX_ARG (p_balanced_mat2),
+                                 n, F77_CMPLX_ARG (p_balanced_mat),
+                                 n, F77_CMPLX_ARG (p_balanced_mat2),
                                  n, ilo, ihi, plscale, prscale, pwork, info
                                  F77_CHAR_ARG_LEN (1)));
 
       balancing_mat = FloatMatrix (n, n, 0.0);
       balancing_mat2 = FloatMatrix (n, n, 0.0);
       for (F77_INT i = 0; i < n; i++)
         {
           octave_quit ();
diff --git a/liboctave/numeric/gsvd.cc b/liboctave/numeric/gsvd.cc
--- a/liboctave/numeric/gsvd.cc
+++ b/liboctave/numeric/gsvd.cc
@@ -23,26 +23,25 @@ along with Octave; see the file COPYING.
 */
 
 #ifdef HAVE_CONFIG_H
 #  include <config.h>
 #endif
 
 #include <vector>
 
+#include "CMatrix.h"
+#include "dDiagMatrix.h"
+#include "dMatrix.h"
+#include "fCMatrix.h"
+#include "fDiagMatrix.h"
+#include "fMatrix.h"
 #include "gsvd.h"
-
 #include "lo-error.h"
 #include "lo-lapack-proto.h"
-#include "dMatrix.h"
-#include "fMatrix.h"
-#include "CMatrix.h"
-#include "fCMatrix.h"
-#include "dDiagMatrix.h"
-#include "fDiagMatrix.h"
 
 namespace octave
 {
   namespace math
   {
     template <>
     void
     gsvd<Matrix>::ggsvd (char& jobu, char& jobv, char& jobq, F77_INT m,
diff --git a/liboctave/numeric/hess.cc b/liboctave/numeric/hess.cc
--- a/liboctave/numeric/hess.cc
+++ b/liboctave/numeric/hess.cc
@@ -19,32 +19,33 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
+#include "Array.h"
 #include "CMatrix.h"
 #include "dMatrix.h"
 #include "fCMatrix.h"
 #include "fMatrix.h"
 #include "hess.h"
 #include "lo-error.h"
 #include "lo-lapack-proto.h"
 
 namespace octave
 {
   namespace math
   {
     template <>
     octave_idx_type
     hess<Matrix>::init (const Matrix& a)
-    {
+   {
       F77_INT a_nr = octave::to_f77_int (a.rows ());
       F77_INT a_nc = octave::to_f77_int (a.cols ());
 
       if (a_nr != a_nc)
         (*current_liboctave_error_handler) ("hess: requires square matrix");
 
       char job = 'N';
       char side = 'R';
diff --git a/liboctave/numeric/lo-blas-proto.h b/liboctave/numeric/lo-blas-proto.h
--- a/liboctave/numeric/lo-blas-proto.h
+++ b/liboctave/numeric/lo-blas-proto.h
@@ -105,17 +105,18 @@ extern "C"
 
   F77_RET_T
   F77_FUNC (dgemm, DGEMM) (F77_CONST_CHAR_ARG_DECL,
                            F77_CONST_CHAR_ARG_DECL,
                            const F77_INT&, const F77_INT&,
                            const F77_INT&, const F77_DBLE&,
                            const F77_DBLE*, const F77_INT&,
                            const F77_DBLE*, const F77_INT&,
-                           const F77_DBLE&, F77_DBLE*, const F77_INT&
+                           const F77_DBLE&, F77_DBLE*,
+                           const F77_INT&
                            F77_CHAR_ARG_LEN_DECL
                            F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (sgemm, SGEMM) (F77_CONST_CHAR_ARG_DECL,
                            F77_CONST_CHAR_ARG_DECL,
                            const F77_INT&, const F77_INT&,
                            const F77_INT&, const F77_REAL&,
@@ -128,17 +129,18 @@ extern "C"
 
   F77_RET_T
   F77_FUNC (zgemm, ZGEMM) (F77_CONST_CHAR_ARG_DECL,
                            F77_CONST_CHAR_ARG_DECL,
                            const F77_INT&, const F77_INT&,
                            const F77_INT&, const F77_DBLE_CMPLX&,
                            const F77_DBLE_CMPLX*, const F77_INT&,
                            const F77_DBLE_CMPLX*, const F77_INT&,
-                           const F77_DBLE_CMPLX&, F77_DBLE_CMPLX*, const F77_INT&
+                           const F77_DBLE_CMPLX&, F77_DBLE_CMPLX*,
+                           const F77_INT&
                            F77_CHAR_ARG_LEN_DECL
                            F77_CHAR_ARG_LEN_DECL);
 
   // GEMV
 
   F77_RET_T
   F77_FUNC (cgemv, CGEMV) (F77_CONST_CHAR_ARG_DECL,
                            const F77_INT&, const F77_INT&,
diff --git a/liboctave/numeric/lo-lapack-proto.h b/liboctave/numeric/lo-lapack-proto.h
--- a/liboctave/numeric/lo-lapack-proto.h
+++ b/liboctave/numeric/lo-lapack-proto.h
@@ -41,18 +41,18 @@ extern "C"
                              F77_INT*, F77_INT&
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zgbcon, ZGBCON) (F77_CONST_CHAR_ARG_DECL,
                              const F77_INT&, const F77_INT&,
                              const F77_INT&, F77_DBLE_CMPLX*,
                              const F77_INT&, const F77_INT*,
-                             const F77_DBLE&, F77_DBLE&, F77_DBLE_CMPLX*, F77_DBLE*,
-                             F77_INT&
+                             const F77_DBLE&, F77_DBLE&, F77_DBLE_CMPLX*,
+                             F77_DBLE*, F77_INT&
                              F77_CHAR_ARG_LEN_DECL);
 
   // GBTRF
 
   F77_RET_T
   F77_FUNC (dgbtrf, DGBTRF) (const F77_INT&, const F77_INT&,
                              const F77_INT&, const F77_INT&,
                              F77_DBLE*, const F77_INT&,
@@ -186,19 +186,18 @@ extern "C"
                              F77_DBLE_CMPLX*, F77_DBLE*, F77_INT&
                              F77_CHAR_ARG_LEN_DECL);
 
   // GEHRD
 
   F77_RET_T
   F77_FUNC (cgehrd, CGEHRD) (const F77_INT&, const F77_INT&,
                              const F77_INT&, F77_CMPLX*,
-                             const F77_INT&, F77_CMPLX*,
-                             F77_CMPLX*, const F77_INT&,
-                             F77_INT&);
+                             const F77_INT&, F77_CMPLX*, F77_CMPLX*,
+                             const F77_INT&, F77_INT&);
 
   F77_RET_T
   F77_FUNC (dgehrd, DGEHRD) (const F77_INT&, const F77_INT&,
                              const F77_INT&, F77_DBLE*,
                              const F77_INT&, F77_DBLE*, F77_DBLE*,
                              const F77_INT&, F77_INT&);
 
   F77_RET_T
@@ -224,90 +223,90 @@ extern "C"
   F77_RET_T
   F77_FUNC (dgeqp3, DGEQP3) (const F77_INT&, const F77_INT&,
                              F77_DBLE*, const F77_INT&,
                              F77_INT*, F77_DBLE*, F77_DBLE*,
                              const F77_INT&, F77_INT&);
 
   F77_RET_T
   F77_FUNC (sgeqp3, SGEQP3) (const F77_INT&, const F77_INT&,
-                             F77_REAL*, const F77_INT&, F77_INT*,
-                             F77_REAL*, F77_REAL*, const F77_INT&,
-                             F77_INT&);
+                             F77_REAL*, const F77_INT&,
+                             F77_INT*, F77_REAL*, F77_REAL*,
+                             const F77_INT&, F77_INT&);
   F77_RET_T
   F77_FUNC (zgeqp3, ZGEQP3) (const F77_INT&, const F77_INT&,
                              F77_DBLE_CMPLX*, const F77_INT&,
                              F77_INT*, F77_DBLE_CMPLX*, F77_DBLE_CMPLX*,
-                             const F77_INT&, F77_DBLE*,
-                             F77_INT&);
+                             const F77_INT&, F77_DBLE*, F77_INT&);
 
   // GEQRF
 
   F77_RET_T
   F77_FUNC (cgeqrf, CGEQRF) (const F77_INT&, const F77_INT&,
                              F77_CMPLX*, const F77_INT&,
                              F77_CMPLX*, F77_CMPLX*,
                              const F77_INT&, F77_INT&);
 
   F77_RET_T
   F77_FUNC (dgeqrf, DGEQRF) (const F77_INT&, const F77_INT&,
-                             F77_DBLE*, const F77_INT&, F77_DBLE*,
                              F77_DBLE*, const F77_INT&,
-                             F77_INT&);
+                             F77_DBLE*, F77_DBLE*,
+                             const F77_INT&, F77_INT&);
 
   F77_RET_T
   F77_FUNC (sgeqrf, SGEQRF) (const F77_INT&, const F77_INT&,
-                             F77_REAL*, const F77_INT&, F77_REAL*, F77_REAL*,
+                             F77_REAL*, const F77_INT&,
+                             F77_REAL*, F77_REAL*,
                              const F77_INT&, F77_INT&);
 
   F77_RET_T
   F77_FUNC (zgeqrf, ZGEQRF) (const F77_INT&, const F77_INT&,
-                             F77_DBLE_CMPLX*, const F77_INT&, F77_DBLE_CMPLX*,
                              F77_DBLE_CMPLX*, const F77_INT&,
-                             F77_INT&);
+                             F77_DBLE_CMPLX*, F77_DBLE_CMPLX*,
+                             const F77_INT&, F77_INT&);
 
   // GESDD
 
   F77_RET_T
   F77_FUNC (cgesdd, CGESDD) (F77_CONST_CHAR_ARG_DECL,
                              const F77_INT&, const F77_INT&,
                              F77_CMPLX*, const F77_INT&, F77_REAL*,
                              F77_CMPLX*, const F77_INT&,
                              F77_CMPLX*, const F77_INT&,
-                             F77_CMPLX*, const F77_INT&,
-                             F77_REAL*, F77_INT *, F77_INT&
+                             F77_CMPLX*, const F77_INT&, F77_REAL*,
+                             F77_INT *, F77_INT&
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (dgesdd, DGESDD) (F77_CONST_CHAR_ARG_DECL,
                              const F77_INT&, const F77_INT&,
                              F77_DBLE*, const F77_INT&, F77_DBLE*,
-                             F77_DBLE*, const F77_INT&, F77_DBLE*,
-                             const F77_INT&, F77_DBLE*,
-                             const F77_INT&, F77_INT *,
-                             F77_INT&
+                             F77_DBLE*, const F77_INT&,
+                             F77_DBLE*, const F77_INT&,
+                             F77_DBLE*, const F77_INT&,
+                             F77_INT *, F77_INT&
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (sgesdd, SGESDD) (F77_CONST_CHAR_ARG_DECL,
                              const F77_INT&, const F77_INT&,
                              F77_REAL*, const F77_INT&, F77_REAL*,
-                             F77_REAL*, const F77_INT&, F77_REAL*,
-                             const F77_INT&, F77_REAL*,
-                             const F77_INT&, F77_INT *,
-                             F77_INT&
+                             F77_REAL*, const F77_INT&,
+                             F77_REAL*, const F77_INT&,
+                             F77_REAL*, const F77_INT&,
+                             F77_INT *, F77_INT&
                              F77_CHAR_ARG_LEN_DECL);
 
   F77_RET_T
   F77_FUNC (zgesdd, ZGESDD) (F77_CONST_CHAR_ARG_DECL,
                              const F77_INT&, const F77_INT&,
+                             F77_DBLE_CMPLX*, const F77_INT&, F77_DBLE*,
                              F77_DBLE_CMPLX*, const F77_INT&,
-                             F77_DBLE*, F77_DBLE_CMPLX*, const F77_INT&,
-                             F77_DBLE_CMPLX*, const F77_INT&, F77_DBLE_CMPLX*,
-                             const F77_INT&, F77_DBLE*,
+                             F77_DBLE_CMPLX*, const F77_INT&,
+                             F77_DBLE_CMPLX*, const F77_INT&, F77_DBLE*,
                              F77_INT *, F77_INT&
                              F77_CHAR_ARG_LEN_DECL);
   // GESVD
 
   F77_RET_T
   F77_FUNC (cgesvd, CGESVD) (F77_CONST_CHAR_ARG_DECL,
                              F77_CONST_CHAR_ARG_DECL,
                              const F77_INT&, const F77_INT&,
diff --git a/liboctave/numeric/lo-mappers.cc b/liboctave/numeric/lo-mappers.cc
--- a/liboctave/numeric/lo-mappers.cc
+++ b/liboctave/numeric/lo-mappers.cc
@@ -20,26 +20,19 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "lo-error.h"
-#include "lo-ieee.h"
 #include "lo-mappers.h"
-#include "lo-math.h"
 #include "lo-specfun.h"
-#include "lo-utils.h"
 #include "math-wrappers.h"
-#include "oct-cmplx.h"
-
-#include "f77-fcn.h"
 
 // FIXME: We used to have this situation:
 //
 //   Functions that forward to gnulib belong here so we can keep
 //   gnulib:: out of lo-mappers.h.
 //
 // but now we just use std:: and explicit wrappers in C++ code so maybe
 // some of the forwarding functions can be defined inline here.
diff --git a/liboctave/numeric/lo-mappers.h b/liboctave/numeric/lo-mappers.h
--- a/liboctave/numeric/lo-mappers.h
+++ b/liboctave/numeric/lo-mappers.h
@@ -70,23 +70,26 @@ namespace octave
 
     using std::asin;
 
     extern OCTAVE_API Complex atan (const Complex& x);
     extern OCTAVE_API FloatComplex atan (const FloatComplex& x);
 
     using std::atan;
 
-    // C++ now provides versions of the following funtions for
-    // arguments of type std::complex<T> and T.  But some compilers
-    // (I'm looking at you, clang) apparently don't get this right
-    // yet...  So we provide our own wrappers for real-valued arguments.
+    // C++ now provides versions of the following functions for arguments of
+    // type std::complex<T> and T.  But some compilers (I'm looking at you,
+    // clang) apparently don't get this right yet...  So we provide our own
+    // wrappers for real-valued arguments.
 
     inline double arg (double x) { return signbit (x) ? M_PI : 0; }
-    inline float arg (float x) { return signbit (x) ? static_cast<float> (M_PI) : 0; }
+    inline float arg (float x)
+    {
+      return signbit (x) ? static_cast<float> (M_PI) : 0;
+    }
 
     template <typename T>
     T
     arg (const std::complex<T>& x)
     {
       return std::arg (x);
     }
 
@@ -297,19 +300,26 @@ namespace octave
     template <typename T>
     T
     x_nint (T x)
     {
       return x;
     }
 
     template <>
-    inline double x_nint (double x) { return (finite (x) ? floor (x + 0.5) : x); }
+    inline double x_nint (double x)
+    {
+      return (finite (x) ? floor (x + 0.5) : x);
+    }
+
     template <>
-    inline float x_nint (float x) { return (finite (x) ? floor (x + 0.5f) : x); }
+    inline float x_nint (float x)
+    {
+      return (finite (x) ? floor (x + 0.5f) : x);
+    }
 
     extern OCTAVE_API octave_idx_type nint_big (double x);
     extern OCTAVE_API octave_idx_type nint_big (float x);
 
     extern OCTAVE_API int nint (double x);
     extern OCTAVE_API int nint (float x);
 
     template <typename T>
@@ -491,37 +501,55 @@ namespace octave
 
 OCTAVE_DEPRECATED ("use 'octave::math::is_NA' instead")
 inline bool octave_is_NA (double x) { return octave::math::is_NA (x); }
 OCTAVE_DEPRECATED ("use 'octave::math::is_NA' instead")
 inline bool octave_is_NA (float x) { return octave::math::is_NA (x); }
 OCTAVE_DEPRECATED ("use 'octave::math::is_NA' instead")
 inline bool octave_is_NA (const Complex& x) { return octave::math::is_NA (x); }
 OCTAVE_DEPRECATED ("use 'octave::math::is_NA' instead")
-inline bool octave_is_NA (const FloatComplex& x) { return octave::math::is_NA (x); }
+inline bool octave_is_NA (const FloatComplex& x)
+{
+  return octave::math::is_NA (x);
+}
 
 OCTAVE_DEPRECATED ("use 'octave::math::is_NaN_or_NA' instead")
-inline bool octave_is_NaN_or_NA (const Complex& x) { return octave::math::is_NaN_or_NA (x); }
+inline bool octave_is_NaN_or_NA (const Complex& x)
+{
+  return octave::math::is_NaN_or_NA (x);
+}
 OCTAVE_DEPRECATED ("use 'octave::math::is_NaN_or_NA' instead")
-inline bool octave_is_NaN_or_NA (const FloatComplex& x) { return octave::math::is_NaN_or_NA (x); }
+inline bool octave_is_NaN_or_NA (const FloatComplex& x)
+{
+  return octave::math::is_NaN_or_NA (x);
+}
 
 OCTAVE_DEPRECATED ("use 'octave::math::acos' instead")
 inline Complex acos (const Complex& x) { return octave::math::acos (x); }
 OCTAVE_DEPRECATED ("use 'octave::math::acos' instead")
-inline FloatComplex acos (const FloatComplex& x) { return octave::math::acos (x); }
+inline FloatComplex acos (const FloatComplex& x)
+{
+  return octave::math::acos (x);
+}
 
 OCTAVE_DEPRECATED ("use 'octave::math::asin' instead")
 inline Complex asin (const Complex& x) { return octave::math::asin (x); }
 OCTAVE_DEPRECATED ("use 'octave::math::asin' instead")
-inline FloatComplex asin (const FloatComplex& x) { return octave::math::asin (x); }
+inline FloatComplex asin (const FloatComplex& x)
+{
+  return octave::math::asin (x);
+}
 
 OCTAVE_DEPRECATED ("use 'octave::math::atan' instead")
 inline Complex atan (const Complex& x) { return octave::math::atan (x); }
 OCTAVE_DEPRECATED ("use 'octave::math::atan' instead")
-inline FloatComplex atan (const FloatComplex& x) { return octave::math::atan (x); }
+inline FloatComplex atan (const FloatComplex& x)
+{
+  return octave::math::atan (x);
+}
 
 OCTAVE_DEPRECATED ("use 'octave::math::arg' instead")
 inline double arg (double x) { return octave::math::arg (x); }
 OCTAVE_DEPRECATED ("use 'octave::math::arg' instead")
 inline float arg (float x) { return octave::math::arg (x); }
 
 OCTAVE_DEPRECATED ("use 'octave::math::conj' instead")
 inline double conj (double x) { return x; }
@@ -541,27 +569,39 @@ inline float real (float x) { return oct
 OCTAVE_DEPRECATED ("use 'octave::math::log2' instead")
 inline double xlog2 (double x) { return octave::math::log2 (x); }
 OCTAVE_DEPRECATED ("use 'octave::math::log2' instead")
 inline float xlog2 (float x) { return octave::math::log2 (x); }
 
 OCTAVE_DEPRECATED ("use 'octave::math::log2' instead")
 inline Complex xlog2 (const Complex& x) { return octave::math::log2 (x); }
 OCTAVE_DEPRECATED ("use 'octave::math::log2' instead")
-inline FloatComplex xlog2 (const FloatComplex& x) { return octave::math::log2 (x); }
+inline FloatComplex xlog2 (const FloatComplex& x)
+{ 
+  return octave::math::log2 (x);
+}
 
 OCTAVE_DEPRECATED ("use 'octave::math::log2' instead")
-inline double xlog2 (double x, int& exp) { return octave::math::log2 (x, exp); }
+inline double xlog2 (double x, int& exp)
+{ 
+  return octave::math::log2 (x, exp);
+}
 OCTAVE_DEPRECATED ("use 'octave::math::log2' instead")
 inline float xlog2 (float x, int& exp) { return octave::math::log2 (x, exp); }
 
 OCTAVE_DEPRECATED ("use 'octave::math::log2' instead")
-inline Complex xlog2 (const Complex& x, int& exp) { return octave::math::log2 (x, exp); }
+inline Complex xlog2 (const Complex& x, int& exp)
+{ 
+  return octave::math::log2 (x, exp);
+}
 OCTAVE_DEPRECATED ("use 'octave::math::log2' instead")
-inline FloatComplex xlog2 (const FloatComplex& x, int& exp) { return octave::math::log2 (x, exp); }
+inline FloatComplex xlog2 (const FloatComplex& x, int& exp)
+{ 
+  return octave::math::log2 (x, exp);
+}
 
 OCTAVE_DEPRECATED ("use 'octave::math::exp2' instead")
 inline double xexp2 (double x) { return octave::math::exp2 (x); }
 OCTAVE_DEPRECATED ("use 'octave::math::exp2' instead")
 inline float xexp2 (float x) { return octave::math::exp2 (x); }
 
 OCTAVE_DEPRECATED ("use 'octave::math::ceil' instead")
 inline double xceil (double x) { return octave::math::ceil (x); }
@@ -572,37 +612,55 @@ template <typename T>
 OCTAVE_DEPRECATED ("use 'octave::math::ceil' instead")
 std::complex<T>
 ceil (const std::complex<T>& x)
 {
   return octave::math::ceil (x);
 }
 
 OCTAVE_DEPRECATED ("use 'octave::math::copysign' instead")
-inline double xcopysign (double x, double y) { return octave::math::copysign (x, y); }
+inline double xcopysign (double x, double y)
+{ 
+  return octave::math::copysign (x, y);
+}
 OCTAVE_DEPRECATED ("use 'octave::math::copysign' instead")
-inline float xcopysign (float x, float y) { return octave::math::copysign (x, y); }
+inline float xcopysign (float x, float y)
+{ 
+  return octave::math::copysign (x, y);
+}
 
 template <typename T>
 OCTAVE_DEPRECATED ("use 'octave::math::signbit' instead")
 T
 xsignbit (T x)
 {
   return octave::math::signbit (x);
 }
 
 OCTAVE_DEPRECATED ("use 'octave::math::negative_sign' instead")
-inline bool xnegative_sign (double x) { return octave::math::negative_sign (x); }
+inline bool xnegative_sign (double x)
+{ 
+  return octave::math::negative_sign (x);
+}
 OCTAVE_DEPRECATED ("use 'octave::math::negative_sign' instead")
-inline bool xnegative_sign (float x) { return octave::math::negative_sign (x); }
+inline bool xnegative_sign (float x)
+{ 
+  return octave::math::negative_sign (x);
+}
 
 OCTAVE_DEPRECATED ("use 'octave::math::positive_sign' instead")
-inline bool xpositive_sign (double x) { return octave::math::positive_sign (x); }
+inline bool xpositive_sign (double x)
+{ 
+  return octave::math::positive_sign (x);
+}
 OCTAVE_DEPRECATED ("use 'octave::math::positive_sign' instead")
-inline bool xpositive_sign (float x) { return octave::math::positive_sign (x); }
+inline bool xpositive_sign (float x)
+{ 
+  return octave::math::positive_sign (x);
+}
 
 OCTAVE_DEPRECATED ("use 'octave::math::signum' instead")
 inline double signum (double x) { return octave::math::signum (x); }
 OCTAVE_DEPRECATED ("use 'octave::math::signum' instead")
 inline float signum (float x) { return octave::math::signum (x); }
 
 template <typename T>
 OCTAVE_DEPRECATED ("use 'octave::math::signum' instead")
diff --git a/liboctave/numeric/lo-qrupdate-proto.h b/liboctave/numeric/lo-qrupdate-proto.h
--- a/liboctave/numeric/lo-qrupdate-proto.h
+++ b/liboctave/numeric/lo-qrupdate-proto.h
@@ -36,28 +36,28 @@ extern "C"
 
   F77_RET_T
   F77_FUNC (cch1dn, CCH1DN) (const F77_INT&, F77_CMPLX*,
                              const F77_INT&, F77_CMPLX*,
                              F77_REAL*, F77_INT&);
 
   F77_RET_T
   F77_FUNC (dch1dn, DCH1DN) (const F77_INT&, F77_DBLE*,
-                             const F77_INT&, F77_DBLE*, F77_DBLE*,
-                             F77_INT&);
+                             const F77_INT&, F77_DBLE*,
+                             F77_DBLE*, F77_INT&);
 
   F77_RET_T
   F77_FUNC (sch1dn, SCH1DN) (const F77_INT&, F77_REAL*,
-                             const F77_INT&, F77_REAL*, F77_REAL*,
-                             F77_INT&);
+                             const F77_INT&, F77_REAL*,
+                             F77_REAL*, F77_INT&);
 
   F77_RET_T
   F77_FUNC (zch1dn, ZCH1DN) (const F77_INT&, F77_DBLE_CMPLX*,
-                             const F77_INT&, F77_DBLE_CMPLX*, F77_DBLE*,
-                             F77_INT&);
+                             const F77_INT&, F77_DBLE_CMPLX*,
+                             F77_DBLE*, F77_INT&);
 
   // CH1UP
 
   F77_RET_T
   F77_FUNC (cch1up, CCH1UP) (const F77_INT&, F77_CMPLX*,
                              const F77_INT&, F77_CMPLX*, F77_REAL*);
 
   F77_RET_T
@@ -181,18 +181,18 @@ extern "C"
                              const F77_INT&, F77_DBLE*,
                              const F77_INT&, const F77_INT&,
                              F77_DBLE*);
 
   F77_RET_T
   F77_FUNC (sqrdec, SQRDEC) (const F77_INT&, const F77_INT&,
                              const F77_INT&, F77_REAL*,
                              const F77_INT&, F77_REAL*,
-                             const F77_INT&,
-                             const F77_INT&, F77_REAL*);
+                             const F77_INT&, const F77_INT&,
+                             F77_REAL*);
 
   F77_RET_T
   F77_FUNC (zqrdec, ZQRDEC) (const F77_INT&, const F77_INT&,
                              const F77_INT&, F77_DBLE_CMPLX*,
                              const F77_INT&, F77_DBLE_CMPLX*,
                              const F77_INT&, const F77_INT&,
                              F77_DBLE*);
 
@@ -201,54 +201,54 @@ extern "C"
   F77_RET_T
   F77_FUNC (cqrder, CQRDER) (const F77_INT&, const F77_INT&,
                              F77_CMPLX*, const F77_INT&,
                              F77_CMPLX*, const F77_INT&,
                              const F77_INT&, F77_CMPLX*, F77_REAL*);
 
   F77_RET_T
   F77_FUNC (dqrder, DQRDER) (const F77_INT&, const F77_INT&,
-                             F77_DBLE*, const F77_INT&, F77_DBLE*,
-                             const F77_INT&, const F77_INT&,
-                             F77_DBLE*);
+                             F77_DBLE*, const F77_INT&,
+                             F77_DBLE*, const F77_INT&,
+                             const F77_INT&, F77_DBLE*);
 
   F77_RET_T
   F77_FUNC (sqrder, SQRDER) (const F77_INT&, const F77_INT&,
                              F77_REAL*, const F77_INT&,
                              F77_REAL*, const F77_INT&,
                              const F77_INT&, F77_REAL*);
 
   F77_RET_T
   F77_FUNC (zqrder, ZQRDER) (const F77_INT&, const F77_INT&,
-                             F77_DBLE_CMPLX*, const F77_INT&, F77_DBLE_CMPLX*,
-                             const F77_INT&, const F77_INT&,
-                             F77_DBLE_CMPLX*, F77_DBLE*);
+                             F77_DBLE_CMPLX*, const F77_INT&,
+                             F77_DBLE_CMPLX*, const F77_INT&,
+                             const F77_INT&, F77_DBLE_CMPLX*, F77_DBLE*);
 
   // QRINC
 
   F77_RET_T
   F77_FUNC (cqrinc, CQRINC) (const F77_INT&, const F77_INT&,
                              const F77_INT&, F77_CMPLX*,
                              const F77_INT&, F77_CMPLX*,
-                             const F77_INT&,const F77_INT&,
+                             const F77_INT&, const F77_INT&,
                              const F77_CMPLX*, F77_REAL*);
 
   F77_RET_T
   F77_FUNC (dqrinc, DQRINC) (const F77_INT&, const F77_INT&,
                              const F77_INT&, F77_DBLE*,
                              const F77_INT&, F77_DBLE*,
                              const F77_INT&, const F77_INT&,
                              const F77_DBLE*, F77_DBLE*);
 
   F77_RET_T
   F77_FUNC (sqrinc, SQRINC) (const F77_INT&, const F77_INT&,
                              const F77_INT&, F77_REAL*,
                              const F77_INT&, F77_REAL*,
-                             const F77_INT&,
-                             const F77_INT&, const F77_REAL*, F77_REAL*);
+                             const F77_INT&, const F77_INT&,
+                             const F77_REAL*, F77_REAL*);
 
   F77_RET_T
   F77_FUNC (zqrinc, ZQRINC) (const F77_INT&, const F77_INT&,
                              const F77_INT&, F77_DBLE_CMPLX*,
                              const F77_INT&, F77_DBLE_CMPLX*,
                              const F77_INT&, const F77_INT&,
                              const F77_DBLE_CMPLX*, F77_DBLE*);
 
@@ -258,62 +258,67 @@ extern "C"
   F77_FUNC (cqrinr, CQRINR) (const F77_INT&, const F77_INT&,
                              F77_CMPLX*, const F77_INT&,
                              F77_CMPLX*, const F77_INT&,
                              const F77_INT&, const F77_CMPLX*,
                              F77_REAL*);
 
   F77_RET_T
   F77_FUNC (dqrinr, DQRINR) (const F77_INT&, const F77_INT&,
-                             F77_DBLE*, const F77_INT&, F77_DBLE*,
-                             const F77_INT&, const F77_INT&,
-                             const F77_DBLE*, F77_DBLE*);
+                             F77_DBLE*, const F77_INT&,
+                             F77_DBLE*, const F77_INT&,
+                             const F77_INT&, const F77_DBLE*,
+                             F77_DBLE*);
 
   F77_RET_T
   F77_FUNC (sqrinr, SQRINR) (const F77_INT&, const F77_INT&,
                              F77_REAL*, const F77_INT&,
                              F77_REAL*, const F77_INT&,
-                             const F77_INT&, const F77_REAL*, F77_REAL*);
+                             const F77_INT&, const F77_REAL*,
+                             F77_REAL*);
 
   F77_RET_T
   F77_FUNC (zqrinr, ZQRINR) (const F77_INT&, const F77_INT&,
-                             F77_DBLE_CMPLX*, const F77_INT&, F77_DBLE_CMPLX*,
-                             const F77_INT&, const F77_INT&,
-                             const F77_DBLE_CMPLX*, F77_DBLE*);
+                             F77_DBLE_CMPLX*, const F77_INT&,
+                             F77_DBLE_CMPLX*, const F77_INT&,
+                             const F77_INT&, const F77_DBLE_CMPLX*,
+                             F77_DBLE*);
 
   // QRSHC
 
   F77_RET_T
   F77_FUNC (cqrshc, CQRSHC) (const F77_INT&, const F77_INT&,
                              const F77_INT&, F77_CMPLX*,
                              const F77_INT&, F77_CMPLX*,
                              const F77_INT&, const F77_INT&,
-                             const F77_INT&, F77_CMPLX*,
-                             F77_REAL*);
+                             const F77_INT&,
+                             F77_CMPLX*, F77_REAL*);
   F77_RET_T
   F77_FUNC (dqrshc, DQRSHC) (const F77_INT&, const F77_INT&,
                              const F77_INT&, F77_DBLE*,
                              const F77_INT&, F77_DBLE*,
                              const F77_INT&, const F77_INT&,
-                             const F77_INT&, F77_DBLE*);
+                             const F77_INT&,
+                             F77_DBLE*);
 
   F77_RET_T
   F77_FUNC (sqrshc, SQRSHC) (const F77_INT&, const F77_INT&,
                              const F77_INT&, F77_REAL*,
                              const F77_INT&, F77_REAL*,
+                             const F77_INT&, const F77_INT&,
                              const F77_INT&,
-                             const F77_INT&, const F77_INT&,
                              F77_REAL*);
 
   F77_RET_T
   F77_FUNC (zqrshc, ZQRSHC) (const F77_INT&, const F77_INT&,
                              const F77_INT&, F77_DBLE_CMPLX*,
                              const F77_INT&, F77_DBLE_CMPLX*,
                              const F77_INT&, const F77_INT&,
-                             const F77_INT&, F77_DBLE_CMPLX*, F77_DBLE*);
+                             const F77_INT&,
+                             F77_DBLE_CMPLX*, F77_DBLE*);
 
 #endif
 
 #if defined (HAVE_QRUPDATE_LUU)
 
   // LU1UP
 
   F77_RET_T
diff --git a/liboctave/numeric/lo-slatec-proto.h b/liboctave/numeric/lo-slatec-proto.h
--- a/liboctave/numeric/lo-slatec-proto.h
+++ b/liboctave/numeric/lo-slatec-proto.h
@@ -85,20 +85,22 @@ extern "C"
   F77_FUNC (xgamma, XGAMMA) (const F77_REAL&, F77_REAL&);
 
   F77_RET_T
   F77_FUNC (xdgamma, XDGAMMA) (const F77_DBLE&, F77_DBLE&);
 
   // GAMMAINC
 
   F77_RET_T
-  F77_FUNC (xgammainc, XGAMMAINC) (const F77_DBLE&, const F77_DBLE&, F77_DBLE&);
+  F77_FUNC (xgammainc, XGAMMAINC) (const F77_DBLE&, const F77_DBLE&,
+                                   F77_DBLE&);
 
   F77_RET_T
-  F77_FUNC (xsgammainc, XSGAMMAINC) (const F77_REAL&, const F77_REAL&, F77_REAL&);
+  F77_FUNC (xsgammainc, XSGAMMAINC) (const F77_REAL&, const F77_REAL&,
+                                     F77_REAL&);
 
   // LGAMS
 
   F77_RET_T
   F77_FUNC (algams, ALGAMS) (const F77_REAL&, F77_REAL&, F77_REAL&);
 
   F77_RET_T
   F77_FUNC (dlgams, DLGAMS) (const F77_DBLE&, F77_DBLE&, F77_DBLE&);
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -23,40 +23,42 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "Range.h"
+#include <algorithm>
+#include <limits>
+#include <string>
+
 #include "CColVector.h"
 #include "CMatrix.h"
-#include "dRowVector.h"
+#include "CNDArray.h"
+#include "Faddeeva.hh"
 #include "dMatrix.h"
 #include "dNDArray.h"
-#include "CNDArray.h"
+#include "dRowVector.h"
+#include "f77-fcn.h"
 #include "fCColVector.h"
 #include "fCMatrix.h"
-#include "fRowVector.h"
+#include "fCNDArray.h"
 #include "fMatrix.h"
 #include "fNDArray.h"
-#include "fCNDArray.h"
-#include "f77-fcn.h"
+#include "fRowVector.h"
 #include "lo-amos-proto.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
+#include "lo-mappers.h"
+#include "lo-math.h"
 #include "lo-slatec-proto.h"
 #include "lo-specfun.h"
 #include "mx-inlines.cc"
-#include "lo-mappers.h"
-#include "lo-math.h"
-
-#include "Faddeeva.hh"
 
 namespace octave
 {
   namespace math
   {
     double
     acosh (double x)
     {
diff --git a/liboctave/numeric/lo-specfun.h b/liboctave/numeric/lo-specfun.h
--- a/liboctave/numeric/lo-specfun.h
+++ b/liboctave/numeric/lo-specfun.h
@@ -21,32 +21,31 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_lo_specfun_h)
 #define octave_lo_specfun_h 1
 
 #include "octave-config.h"
 
+#include "Array.h"
 #include "oct-cmplx.h"
-#include "Array.h"
 
+class ComplexColumnVector;
+class ComplexMatrix;
+class ComplexNDArray;
+class FloatComplexColumnVector;
+class FloatComplexMatrix;
+class FloatComplexNDArray;
+class FloatMatrix;
+class FloatNDArray;
+class FloatRowVector;
 class Matrix;
-class ComplexMatrix;
 class NDArray;
-class ComplexNDArray;
 class RowVector;
-class ComplexColumnVector;
-class FloatMatrix;
-class FloatComplexMatrix;
-class FloatNDArray;
-class FloatComplexNDArray;
-class FloatRowVector;
-class FloatComplexColumnVector;
-class Range;
 
 namespace octave
 {
   namespace math
   {
     extern OCTAVE_API double acosh (double x);
     extern OCTAVE_API float acosh (float x);
     extern OCTAVE_API Complex acosh (const Complex& x);
diff --git a/liboctave/numeric/lu.cc b/liboctave/numeric/lu.cc
--- a/liboctave/numeric/lu.cc
+++ b/liboctave/numeric/lu.cc
@@ -20,18 +20,21 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
+#include <algorithm>
+
 #include "CColVector.h"
 #include "CMatrix.h"
+#include "PermMatrix.h"
 #include "dColVector.h"
 #include "dMatrix.h"
 #include "fCColVector.h"
 #include "fCMatrix.h"
 #include "fColVector.h"
 #include "fMatrix.h"
 #include "lo-error.h"
 #include "lo-lapack-proto.h"
@@ -289,18 +292,18 @@ namespace octave
       F77_INT u_nel = octave::to_f77_int (u.numel ());
       F77_INT v_nel = octave::to_f77_int (v.numel ());
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       ColumnVector utmp = u;
       ColumnVector vtmp = v;
-      F77_XFCN (dlu1up, DLU1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (), k,
-                                 utmp.fortran_vec (), vtmp.fortran_vec ()));
+      F77_XFCN (dlu1up, DLU1UP, (m, n, l.fortran_vec (), m, r.fortran_vec (),
+                                 k, utmp.fortran_vec (), vtmp.fortran_vec ()));
     }
 
     template <>
     void
     lu<Matrix>::update (const Matrix& u, const Matrix& v)
     {
       if (packed ())
         unpack ();
@@ -421,17 +424,18 @@ namespace octave
       for (F77_INT i = 0; i < mn; i++)
         pipvt[i] -= 1;
     }
 
 #if defined (HAVE_QRUPDATE_LUU)
 
     template <>
     void
-    lu<FloatMatrix>::update (const FloatColumnVector& u, const FloatColumnVector& v)
+    lu<FloatMatrix>::update (const FloatColumnVector& u,
+                             const FloatColumnVector& v)
     {
       if (packed ())
         unpack ();
 
       FloatMatrix& l = l_fact;
       FloatMatrix& r = a_fact;
 
       F77_INT m = octave::to_f77_int (l.rows ());
@@ -565,18 +569,18 @@ namespace octave
       ipvt.resize (dim_vector (mn, 1));
       F77_INT *pipvt = ipvt.fortran_vec ();
 
       a_fact = a;
       Complex *tmp_data = a_fact.fortran_vec ();
 
       F77_INT info = 0;
 
-      F77_XFCN (zgetrf, ZGETRF, (a_nr, a_nc, F77_DBLE_CMPLX_ARG (tmp_data), a_nr,
-                                 pipvt, info));
+      F77_XFCN (zgetrf, ZGETRF, (a_nr, a_nc, F77_DBLE_CMPLX_ARG (tmp_data),
+                                 a_nr, pipvt, info));
 
       for (F77_INT i = 0; i < mn; i++)
         pipvt[i] -= 1;
     }
 
 #if defined (HAVE_QRUPDATE_LUU)
 
     template <>
@@ -630,18 +634,20 @@ namespace octave
 
       if (u_nr != m || v_nr != n || u_nc != v_nc)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
           ComplexColumnVector utmp = u.column (i);
           ComplexColumnVector vtmp = v.column (i);
-          F77_XFCN (zlu1up, ZLU1UP, (m, n, F77_DBLE_CMPLX_ARG (l.fortran_vec ()),
-                                     m, F77_DBLE_CMPLX_ARG (r.fortran_vec ()), k,
+          F77_XFCN (zlu1up, ZLU1UP, (m, n,
+                                     F77_DBLE_CMPLX_ARG (l.fortran_vec ()),
+                                     m, F77_DBLE_CMPLX_ARG (r.fortran_vec ()),
+                                     k,
                                      F77_DBLE_CMPLX_ARG (utmp.fortran_vec ()),
                                      F77_DBLE_CMPLX_ARG (vtmp.fortran_vec ())));
         }
     }
 
     template <>
     void
     lu<ComplexMatrix>::update_piv (const ComplexColumnVector& u,
@@ -666,23 +672,25 @@ namespace octave
       ComplexColumnVector utmp = u;
       ComplexColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (Complex, w, m);
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
       F77_XFCN (zlup1up, ZLUP1UP, (m, n, F77_DBLE_CMPLX_ARG (l.fortran_vec ()),
                                    m, F77_DBLE_CMPLX_ARG (r.fortran_vec ()), k,
                                    ipvt.fortran_vec (),
                                    F77_CONST_DBLE_CMPLX_ARG (utmp.data ()),
-                                   F77_CONST_DBLE_CMPLX_ARG (vtmp.data ()), F77_DBLE_CMPLX_ARG (w)));
+                                   F77_CONST_DBLE_CMPLX_ARG (vtmp.data ()),
+                                   F77_DBLE_CMPLX_ARG (w)));
       for (F77_INT i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
 
     template <>
     void
-    lu<ComplexMatrix>::update_piv (const ComplexMatrix& u, const ComplexMatrix& v)
+    lu<ComplexMatrix>::update_piv (const ComplexMatrix& u,
+                                   const ComplexMatrix& v)
     {
       if (packed ())
         unpack ();
 
       ComplexMatrix& l = l_fact;
       ComplexMatrix& r = a_fact;
 
       F77_INT m = octave::to_f77_int (l.rows ());
@@ -699,21 +707,24 @@ namespace octave
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       OCTAVE_LOCAL_BUFFER (Complex, w, m);
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
           ComplexColumnVector utmp = u.column (i);
           ComplexColumnVector vtmp = v.column (i);
-          F77_XFCN (zlup1up, ZLUP1UP, (m, n, F77_DBLE_CMPLX_ARG (l.fortran_vec ()),
-                                       m, F77_DBLE_CMPLX_ARG (r.fortran_vec ()), k,
-                                       ipvt.fortran_vec (),
+          F77_XFCN (zlup1up, ZLUP1UP, (m, n,
+                                       F77_DBLE_CMPLX_ARG (l.fortran_vec ()),
+                                       m,
+                                       F77_DBLE_CMPLX_ARG (r.fortran_vec ()),
+                                       k, ipvt.fortran_vec (),
                                        F77_CONST_DBLE_CMPLX_ARG (utmp.data ()),
-                                       F77_CONST_DBLE_CMPLX_ARG (vtmp.data ()), F77_DBLE_CMPLX_ARG (w)));
+                                       F77_CONST_DBLE_CMPLX_ARG (vtmp.data ()),
+                                       F77_DBLE_CMPLX_ARG (w)));
         }
       for (F77_INT i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
 
 #endif
 
     template <>
     lu<FloatComplexMatrix>::lu (const FloatComplexMatrix& a)
@@ -725,18 +736,18 @@ namespace octave
       ipvt.resize (dim_vector (mn, 1));
       F77_INT *pipvt = ipvt.fortran_vec ();
 
       a_fact = a;
       FloatComplex *tmp_data = a_fact.fortran_vec ();
 
       F77_INT info = 0;
 
-      F77_XFCN (cgetrf, CGETRF, (a_nr, a_nc, F77_CMPLX_ARG (tmp_data), a_nr, pipvt,
-                                 info));
+      F77_XFCN (cgetrf, CGETRF, (a_nr, a_nc, F77_CMPLX_ARG (tmp_data), a_nr,
+                                 pipvt, info));
 
       for (F77_INT i = 0; i < mn; i++)
         pipvt[i] -= 1;
     }
 
 #if defined (HAVE_QRUPDATE_LUU)
 
     template <>
@@ -759,17 +770,18 @@ namespace octave
 
       if (u_nel != m || v_nel != n)
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       FloatComplexColumnVector utmp = u;
       FloatComplexColumnVector vtmp = v;
       F77_XFCN (clu1up, CLU1UP, (m, n, F77_CMPLX_ARG (l.fortran_vec ()), m,
                                  F77_CMPLX_ARG (r.fortran_vec ()), k,
-                                 F77_CMPLX_ARG (utmp.fortran_vec ()), F77_CMPLX_ARG (vtmp.fortran_vec ())));
+                                 F77_CMPLX_ARG (utmp.fortran_vec ()),
+                                 F77_CMPLX_ARG (vtmp.fortran_vec ())));
     }
 
     template <>
     void
     lu<FloatComplexMatrix>::update (const FloatComplexMatrix& u,
                                     const FloatComplexMatrix& v)
     {
       if (packed ())
@@ -792,17 +804,18 @@ namespace octave
         (*current_liboctave_error_handler) ("luupdate: dimensions mismatch");
 
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
           FloatComplexColumnVector utmp = u.column (i);
           FloatComplexColumnVector vtmp = v.column (i);
           F77_XFCN (clu1up, CLU1UP, (m, n, F77_CMPLX_ARG (l.fortran_vec ()),
                                      m, F77_CMPLX_ARG (r.fortran_vec ()), k,
-                                     F77_CMPLX_ARG (utmp.fortran_vec ()), F77_CMPLX_ARG (vtmp.fortran_vec ())));
+                                     F77_CMPLX_ARG (utmp.fortran_vec ()),
+                                     F77_CMPLX_ARG (vtmp.fortran_vec ())));
         }
     }
 
     template <>
     void
     lu<FloatComplexMatrix>::update_piv (const FloatComplexColumnVector& u,
                                         const FloatComplexColumnVector& v)
     {
@@ -824,17 +837,18 @@ namespace octave
 
       FloatComplexColumnVector utmp = u;
       FloatComplexColumnVector vtmp = v;
       OCTAVE_LOCAL_BUFFER (FloatComplex, w, m);
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
       F77_XFCN (clup1up, CLUP1UP, (m, n, F77_CMPLX_ARG (l.fortran_vec ()),
                                    m, F77_CMPLX_ARG (r.fortran_vec ()), k,
                                    ipvt.fortran_vec (),
-                                   F77_CONST_CMPLX_ARG (utmp.data ()), F77_CONST_CMPLX_ARG (vtmp.data ()),
+                                   F77_CONST_CMPLX_ARG (utmp.data ()),
+                                   F77_CONST_CMPLX_ARG (vtmp.data ()),
                                    F77_CMPLX_ARG (w)));
       for (F77_INT i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
 
     template <>
     void
     lu<FloatComplexMatrix>::update_piv (const FloatComplexMatrix& u,
                                         const FloatComplexMatrix& v)
@@ -862,17 +876,18 @@ namespace octave
       for (F77_INT i = 0; i < m; i++) ipvt(i) += 1; // increment
       for (volatile F77_INT i = 0; i < u_nc; i++)
         {
           FloatComplexColumnVector utmp = u.column (i);
           FloatComplexColumnVector vtmp = v.column (i);
           F77_XFCN (clup1up, CLUP1UP, (m, n, F77_CMPLX_ARG (l.fortran_vec ()),
                                        m, F77_CMPLX_ARG (r.fortran_vec ()), k,
                                        ipvt.fortran_vec (),
-                                       F77_CONST_CMPLX_ARG (utmp.data ()), F77_CONST_CMPLX_ARG (vtmp.data ()),
+                                       F77_CONST_CMPLX_ARG (utmp.data ()),
+                                       F77_CONST_CMPLX_ARG (vtmp.data ()),
                                        F77_CMPLX_ARG (w)));
         }
       for (F77_INT i = 0; i < m; i++) ipvt(i) -= 1; // decrement
     }
 
 #endif
 
     // Instantiations we need.
diff --git a/liboctave/numeric/lu.h b/liboctave/numeric/lu.h
--- a/liboctave/numeric/lu.h
+++ b/liboctave/numeric/lu.h
@@ -21,17 +21,20 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_lu_h)
 #define octave_lu_h 1
 
 #include "octave-config.h"
 
-#include "PermMatrix.h"
+#include "Array.h"
+
+class ColumnVector;
+class PermMatrix;
 
 namespace octave
 {
   namespace math
   {
     template <typename T>
     class
     lu
@@ -86,23 +89,23 @@ namespace octave
       void update (const T& u, const T& v);
 
       void update_piv (const VT& u, const VT& v);
 
       void update_piv (const T& u, const T& v);
 
     protected:
 
-      // The result of getp is passed to other Octave Matrix
-      // fucntions, so we use octave_idx_type.
+      // The result of getp is passed to other Octave Matrix functions,
+      // so we use octave_idx_type.
       Array<octave_idx_type> getp (void) const;
 
       T a_fact;
       T l_fact;
 
-      // This is internal storage that is passed to Fortran, so we
-      // need a Fortran INTEGER.
+      // This is internal storage that is passed to Fortran,
+      // so we need a Fortran INTEGER.
       Array<octave_f77_int_type> ipvt;
     };
   }
 }
 
 #endif
diff --git a/liboctave/numeric/oct-convn.cc b/liboctave/numeric/oct-convn.cc
--- a/liboctave/numeric/oct-convn.cc
+++ b/liboctave/numeric/oct-convn.cc
@@ -19,23 +19,22 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include <iostream>
 #include <algorithm>
 
+#include "Array.h"
+#include "MArray.h"
 #include "f77-fcn.h"
-
 #include "oct-convn.h"
-#include "oct-locbuf.h"
 
 // 2d convolution with a matrix kernel.
 template <typename T, typename R>
 static void
 convolve_2d (const T *a, F77_INT ma, F77_INT na,
              const R *b, F77_INT mb, F77_INT nb,
              T *c, bool inner);
 
diff --git a/liboctave/numeric/oct-convn.h b/liboctave/numeric/oct-convn.h
--- a/liboctave/numeric/oct-convn.h
+++ b/liboctave/numeric/oct-convn.h
@@ -21,35 +21,32 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_oct_convn_h)
 #define octave_oct_convn_h 1
 
 #include "octave-config.h"
 
+#include "CColVector.h"
+#include "CMatrix.h"
+#include "CNDArray.h"
+#include "CRowVector.h"
+#include "dColVector.h"
 #include "dMatrix.h"
-#include "fMatrix.h"
-#include "CMatrix.h"
+#include "dNDArray.h"
+#include "dRowVector.h"
+#include "fCColVector.h"
 #include "fCMatrix.h"
-
-#include "dNDArray.h"
-#include "fNDArray.h"
-#include "CNDArray.h"
 #include "fCNDArray.h"
-
-#include "dRowVector.h"
+#include "fCRowVector.h"
+#include "fColVector.h"
+#include "fMatrix.h"
+#include "fNDArray.h"
 #include "fRowVector.h"
-#include "CRowVector.h"
-#include "fCRowVector.h"
-
-#include "dColVector.h"
-#include "fColVector.h"
-#include "CColVector.h"
-#include "fCColVector.h"
 
 enum convn_type
 {
   convn_full,
   convn_same,
   convn_valid
 };
 
diff --git a/liboctave/numeric/oct-fftw.cc b/liboctave/numeric/oct-fftw.cc
--- a/liboctave/numeric/oct-fftw.cc
+++ b/liboctave/numeric/oct-fftw.cc
@@ -19,28 +19,24 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include <iostream>
-#include <string>
-#include <vector>
-
 #if defined (HAVE_FFTW3_H)
 #  include <fftw3.h>
 #endif
 
 #include "lo-error.h"
 #include "oct-fftw.h"
+#include "oct-locbuf.h"
 #include "quit.h"
-#include "oct-locbuf.h"
 #include "singleton-cleanup.h"
 
 #if defined (HAVE_FFTW3_THREADS) || defined (HAVE_FFTW3F_THREADS)
 #  include "nproc-wrapper.h"
 #endif
 
 namespace octave
 {
diff --git a/liboctave/numeric/oct-fftw.h b/liboctave/numeric/oct-fftw.h
--- a/liboctave/numeric/oct-fftw.h
+++ b/liboctave/numeric/oct-fftw.h
@@ -22,18 +22,20 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_oct_fftw_h)
 #define octave_oct_fftw_h 1
 
 #include "octave-config.h"
 
 #include <cstddef>
 
+#include <string>
+
+#include "dim-vector.h"
 #include "oct-cmplx.h"
-#include "dim-vector.h"
 
 namespace octave
 {
   class
   OCTAVE_API
   fftw_planner
   {
   protected:
diff --git a/liboctave/numeric/oct-norm.cc b/liboctave/numeric/oct-norm.cc
--- a/liboctave/numeric/oct-norm.cc
+++ b/liboctave/numeric/oct-norm.cc
@@ -23,44 +23,47 @@ along with Octave; see the file COPYING.
 // author: Jaroslav Hajek <highegg@gmail.com>
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <cmath>
 
+#include <algorithm>
 #include <limits>
 #include <vector>
 
-#include "Array-util.h"
 #include "Array.h"
 #include "CColVector.h"
 #include "CMatrix.h"
 #include "CRowVector.h"
 #include "CSparse.h"
+#include "MArray.h"
 #include "dColVector.h"
 #include "dDiagMatrix.h"
 #include "dMatrix.h"
 #include "dRowVector.h"
 #include "dSparse.h"
 #include "fCColVector.h"
 #include "fCMatrix.h"
 #include "fCRowVector.h"
 #include "fColVector.h"
 #include "fDiagMatrix.h"
 #include "fMatrix.h"
 #include "fRowVector.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
+#include "lo-mappers.h"
 #include "mx-cm-s.h"
 #include "mx-fcm-fs.h"
 #include "mx-fs-fcm.h"
 #include "mx-s-cm.h"
 #include "oct-cmplx.h"
+#include "quit.h"
 #include "svd.h"
 
 // Theory: norm accumulator is an object that has an accum method able
 // to handle both real and complex element, and a cast operator
 // returning the intermediate norm.  Reference: Higham, N. "Estimating
 // the Matrix p-Norm." Numer. Math. 62, 539-555, 1992.
 
 // norm accumulator for the p-norm
diff --git a/liboctave/numeric/oct-rand.cc b/liboctave/numeric/oct-rand.cc
--- a/liboctave/numeric/oct-rand.cc
+++ b/liboctave/numeric/oct-rand.cc
@@ -19,31 +19,30 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
+#include <cassert>
 #include <cstdint>
 
-#include <map>
-#include <vector>
+#include <limits>
 
-#include "data-conv.h"
-#include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-mappers.h"
 #include "lo-ranlib-proto.h"
 #include "mach-info.h"
 #include "oct-locbuf.h"
 #include "oct-rand.h"
 #include "oct-time.h"
+#include "quit.h"
 #include "randgamma.h"
 #include "randmtzig.h"
 #include "randpoisson.h"
 #include "singleton-cleanup.h"
 
 octave_rand *octave_rand::instance = nullptr;
 
 octave_rand::octave_rand (void)
diff --git a/liboctave/numeric/oct-rand.h b/liboctave/numeric/oct-rand.h
--- a/liboctave/numeric/oct-rand.h
+++ b/liboctave/numeric/oct-rand.h
@@ -23,21 +23,24 @@ along with Octave; see the file COPYING.
 #if ! defined (octave_oct_rand_h)
 #define octave_oct_rand_h 1
 
 #include "octave-config.h"
 
 #include <map>
 #include <string>
 
+#include "Array.h"
 #include "dColVector.h"
 #include "dNDArray.h"
 #include "fNDArray.h"
 #include "lo-ieee.h"
 
+//class dim_vector;
+
 class
 OCTAVE_API
 octave_rand
 {
 protected:
 
   octave_rand (void);
 
diff --git a/liboctave/numeric/oct-spparms.cc b/liboctave/numeric/oct-spparms.cc
--- a/liboctave/numeric/oct-spparms.cc
+++ b/liboctave/numeric/oct-spparms.cc
@@ -20,19 +20,21 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
+#include <ostream>
+
+#include "dNDArray.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
-
 #include "oct-spparms.h"
 #include "singleton-cleanup.h"
 
 octave_sparse_params *octave_sparse_params::instance = nullptr;
 
 bool
 octave_sparse_params::instance_ok (void)
 {
diff --git a/liboctave/numeric/oct-spparms.h b/liboctave/numeric/oct-spparms.h
--- a/liboctave/numeric/oct-spparms.h
+++ b/liboctave/numeric/oct-spparms.h
@@ -21,24 +21,23 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_oct_spparms_h)
 #define octave_oct_spparms_h 1
 
 #include "octave-config.h"
 
-#include <cassert>
-#include <cstddef>
-
 #include <iosfwd>
+#include <string>
 
 #include "str-vec.h"
 #include "dColVector.h"
-#include "dNDArray.h"
+
+class NDArray;
 
 #define OCTAVE_SPARSE_CONTROLS_SIZE 13
 
 class
 OCTAVE_API
 octave_sparse_params
 {
 protected:
diff --git a/liboctave/numeric/qr.cc b/liboctave/numeric/qr.cc
--- a/liboctave/numeric/qr.cc
+++ b/liboctave/numeric/qr.cc
@@ -21,34 +21,37 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
+#include <algorithm>
+
+#include "Array.h"
 #include "CColVector.h"
 #include "CMatrix.h"
 #include "CRowVector.h"
 #include "dColVector.h"
 #include "dMatrix.h"
 #include "dRowVector.h"
-#include "f77-fcn.h"
 #include "fCColVector.h"
 #include "fCMatrix.h"
 #include "fCRowVector.h"
 #include "fColVector.h"
 #include "fMatrix.h"
 #include "fRowVector.h"
-#include "idx-vector.h"
 #include "lo-error.h"
 #include "lo-lapack-proto.h"
 #include "lo-qrupdate-proto.h"
+#include "oct-cmplx.h"
 #include "oct-locbuf.h"
+#include "oct-sort.h"
 #include "qr.h"
 
 namespace octave
 {
   namespace math
   {
     template <typename T>
     qr<T>::qr (const T& q_arg, const T& r_arg)
diff --git a/liboctave/numeric/qr.h b/liboctave/numeric/qr.h
--- a/liboctave/numeric/qr.h
+++ b/liboctave/numeric/qr.h
@@ -22,17 +22,17 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_qr_h)
 #define octave_qr_h 1
 
 #include "octave-config.h"
 
-#include "Array.h"
+template <typename T> class Array;
 
 namespace octave
 {
   namespace math
   {
     template <typename T>
     class
     qr
diff --git a/liboctave/numeric/qrp.cc b/liboctave/numeric/qrp.cc
--- a/liboctave/numeric/qrp.cc
+++ b/liboctave/numeric/qrp.cc
@@ -22,23 +22,26 @@ along with Octave; see the file COPYING.
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include <cassert>
 
+#include <algorithm>
+
+#include "Array.h"
 #include "CMatrix.h"
+#include "MArray.h"
 #include "dMatrix.h"
 #include "dRowVector.h"
 #include "fCMatrix.h"
 #include "fMatrix.h"
 #include "fRowVector.h"
-#include "lo-error.h"
 #include "lo-lapack-proto.h"
 #include "oct-locbuf.h"
 #include "qrp.h"
 
 namespace octave
 {
   namespace math
   {
diff --git a/liboctave/numeric/randgamma.cc b/liboctave/numeric/randgamma.cc
--- a/liboctave/numeric/randgamma.cc
+++ b/liboctave/numeric/randgamma.cc
@@ -78,18 +78,18 @@ Dirichlet(a1,...,ak) for ai > 0
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "lo-ieee.h"
 #include "lo-math.h"
+#include "randgamma.h"
 #include "randmtzig.h"
-#include "randgamma.h"
 
 #define INFINITE lo_ieee_isinf
 #define RUNI oct_randu()
 #define RNOR oct_randn()
 #define REXP oct_rande()
 
 void
 oct_fill_randg (double a, octave_idx_type n, double *r)
diff --git a/liboctave/numeric/randpoisson.cc b/liboctave/numeric/randpoisson.cc
--- a/liboctave/numeric/randpoisson.cc
+++ b/liboctave/numeric/randpoisson.cc
@@ -30,21 +30,22 @@ along with Octave; see the file COPYING.
  * LGAMMA: log gamma function
  * INFINITE: function to test whether a value is infinite
  */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
+#include <cstddef>
+
 #include "f77-fcn.h"
 #include "lo-error.h"
 #include "lo-ieee.h"
 #include "lo-math.h"
-#include "lo-slatec-proto.h"
 #include "randmtzig.h"
 #include "randpoisson.h"
 
 #undef INFINITE
 #define INFINITE lo_ieee_isinf
 #define RUNI oct_randu()
 #define RNOR oct_randn()
 #define LGAMMA xlgamma
@@ -95,17 +96,18 @@ flogfak (double k)
   };
 
   double r, rr;
 
   if (k >= 30.0)
     {
       r  = 1.0 / k;
       rr = r * r;
-      return ((k + 0.5)*std::log (k) - k + C0 + r*(C1 + rr*(C3 + rr*(C5 + rr*C7))));
+      return ((k + 0.5)*std::log (k) - k + C0
+              + r*(C1 + rr*(C3 + rr*(C5 + rr*C7))));
     }
   else
     return (logfak[static_cast<int> (k)]);
 }
 
 /******************************************************************
  *                                                                *
  * Poisson Distribution - Patchwork Rejection/Inversion           *
diff --git a/liboctave/numeric/schur.cc b/liboctave/numeric/schur.cc
--- a/liboctave/numeric/schur.cc
+++ b/liboctave/numeric/schur.cc
@@ -19,22 +19,24 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
+#include "Array.h"
 #include "CMatrix.h"
 #include "dMatrix.h"
 #include "fCMatrix.h"
 #include "fMatrix.h"
 #include "lo-error.h"
 #include "lo-lapack-proto.h"
+#include "oct-locbuf.h"
 #include "schur.h"
 
 namespace octave
 {
   namespace math
   {
     // For real types.
 
diff --git a/liboctave/numeric/schur.h b/liboctave/numeric/schur.h
--- a/liboctave/numeric/schur.h
+++ b/liboctave/numeric/schur.h
@@ -22,27 +22,27 @@ along with Octave; see the file COPYING.
 
 #if ! defined (octave_schur_h)
 #define octave_schur_h 1
 
 #include "octave-config.h"
 
 #include <string>
 
-#include "dMatrix.h"
+// FIXME: Don't really need these for compiling schur.h, but it messes
+// up compilation in liboctave/array if these are not present.
 #include "CMatrix.h"
+#include "dMatrix.h"
+#include "fCMatrix.h"
 #include "fMatrix.h"
-#include "fCMatrix.h"
 
 namespace octave
 {
   namespace math
   {
-    template <typename T> class schur;
-
     template <typename T>
     class
     schur
     {
     public:
 
       schur (void) : schur_mat (), unitary_mat () { }
 
@@ -60,17 +60,16 @@ namespace octave
       }
 
       // This one should really be protected or private but we need it in
       // rsf2csf and I don't see how to make that function a friend of
       // this class.
       schur (const T& s, const T& u) : schur_mat (s), unitary_mat (u) { }
 
       schur (const schur& a)
-
         : schur_mat (a.schur_mat), unitary_mat (a.unitary_mat)
       { }
 
       schur& operator = (const schur& a)
       {
         if (this != &a)
           {
             schur_mat = a.schur_mat;
diff --git a/liboctave/numeric/sparse-chol.cc b/liboctave/numeric/sparse-chol.cc
--- a/liboctave/numeric/sparse-chol.cc
+++ b/liboctave/numeric/sparse-chol.cc
@@ -21,23 +21,30 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "sparse-chol.h"
-#include "sparse-util.h"
+#include <cstddef> 
+
+#include "CSparse.h"
+#include "MatrixType.h"
+#include "dRowVector.h"
+#include "dSparse.h"
 #include "lo-error.h"
+#include "oct-cmplx.h"
+#include "oct-refcount.h"
 #include "oct-sparse.h"
 #include "oct-spparms.h"
 #include "quit.h"
-#include "MatrixType.h"
+#include "sparse-chol.h"
+#include "sparse-util.h"
 
 namespace octave
 {
   namespace math
   {
     template <typename chol_type>
     class sparse_chol<chol_type>::sparse_chol_rep
     {
@@ -207,17 +214,18 @@ namespace octave
       volatile octave_idx_type info = 0;
 
 #if defined (HAVE_CHOLMOD)
 
       octave_idx_type a_nr = a.rows ();
       octave_idx_type a_nc = a.cols ();
 
       if (a_nr != a_nc)
-        (*current_liboctave_error_handler) ("sparse_chol requires square matrix");
+        (*current_liboctave_error_handler)
+          ("sparse_chol requires square matrix");
 
       cholmod_common *cm = &Common;
 
       // Setup initial parameters
 
       CHOLMOD_NAME(start) (cm);
       cm->prefer_zomplex = false;
 
@@ -226,22 +234,25 @@ namespace octave
       if (spu == 0.)
         {
           cm->print = -1;
           SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, 0);
         }
       else
         {
           cm->print = static_cast<int> (spu) + 2;
-          SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function, &SparseCholPrint);
+          SUITESPARSE_ASSIGN_FPTR (printf_func, cm->print_function,
+                                   &SparseCholPrint);
         }
 
       cm->error_handler = &SparseCholError;
 
-      SUITESPARSE_ASSIGN_FPTR2 (divcomplex_func, cm->complex_divide, divcomplex);
+      SUITESPARSE_ASSIGN_FPTR2 (divcomplex_func, cm->complex_divide,
+                                divcomplex);
+
       SUITESPARSE_ASSIGN_FPTR2 (hypot_func, cm->hypotenuse, hypot);
 
       cm->final_asis = false;
       cm->final_super = false;
       cm->final_ll = true;
       cm->final_pack = true;
       cm->final_monotonic = true;
       cm->final_resymbol = false;
@@ -305,17 +316,18 @@ namespace octave
           if (minor_p > 0 && minor_p < a_nr)
             {
               size_t n1 = a_nr + 1;
               Lsparse->p = CHOLMOD_NAME(realloc) (minor_p+1,
                                                   sizeof(octave_idx_type),
                                                   Lsparse->p, &n1, cm);
               BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
               CHOLMOD_NAME(reallocate_sparse)
-                (static_cast<octave_idx_type *>(Lsparse->p)[minor_p], Lsparse, cm);
+                (static_cast<octave_idx_type *>(Lsparse->p)[minor_p],
+                 Lsparse, cm);
               END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
               Lsparse->ncol = minor_p;
             }
 
           drop_zeros (Lsparse);
 
           if (! natural)
@@ -385,31 +397,34 @@ namespace octave
     template <typename chol_type>
     sparse_chol<chol_type>::sparse_chol (const chol_type& a, bool natural,
                                          bool force)
       : rep (new typename
              sparse_chol<chol_type>::sparse_chol_rep (a, natural, force))
     { }
 
     template <typename chol_type>
-    sparse_chol<chol_type>::sparse_chol (const chol_type& a, octave_idx_type& info,
+    sparse_chol<chol_type>::sparse_chol (const chol_type& a,
+                                         octave_idx_type& info,
                                          bool natural, bool force)
       : rep (new typename
              sparse_chol<chol_type>::sparse_chol_rep (a, info, natural, force))
     { }
 
     template <typename chol_type>
-    sparse_chol<chol_type>::sparse_chol (const chol_type& a, octave_idx_type& info,
+    sparse_chol<chol_type>::sparse_chol (const chol_type& a,
+                                         octave_idx_type& info,
                                          bool natural)
       : rep (new typename
              sparse_chol<chol_type>::sparse_chol_rep (a, info, natural, false))
     { }
 
     template <typename chol_type>
-    sparse_chol<chol_type>::sparse_chol (const chol_type& a, octave_idx_type& info)
+    sparse_chol<chol_type>::sparse_chol (const chol_type& a,
+                                         octave_idx_type& info)
       : rep (new typename
              sparse_chol<chol_type>::sparse_chol_rep (a, info, false, false))
     { }
 
     template <typename chol_type>
     sparse_chol<chol_type>::sparse_chol (const sparse_chol<chol_type>& a)
       : rep (a.rep)
     {
diff --git a/liboctave/numeric/sparse-chol.h b/liboctave/numeric/sparse-chol.h
--- a/liboctave/numeric/sparse-chol.h
+++ b/liboctave/numeric/sparse-chol.h
@@ -22,19 +22,19 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_sparse_chol_h)
 #define octave_sparse_chol_h 1
 
 #include "octave-config.h"
 
-#include "CSparse.h"
-#include "dRowVector.h"
-#include "dSparse.h"
+class RowVector;
+class SparseMatrix;
+class SparseComplexMatrix;
 
 namespace octave
 {
   namespace math
   {
     // If the sparse matrix classes become templated on the element type
     // (i.e., sparse_matrix<double>), then it might be best to make the
     // template parameter of this class also be the element type instead
diff --git a/liboctave/numeric/sparse-dmsolve.cc b/liboctave/numeric/sparse-dmsolve.cc
--- a/liboctave/numeric/sparse-dmsolve.cc
+++ b/liboctave/numeric/sparse-dmsolve.cc
@@ -20,25 +20,30 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include <vector>
+#include <algorithm>
 
+#include "CMatrix.h"
+#include "CSparse.h"
 #include "MArray.h"
 #include "MSparse.h"
 #include "MatrixType.h"
+#include "dSparse.h"
+#include "lo-error.h"
 #include "oct-inttypes.h"
 #include "oct-locbuf.h"
 #include "oct-sort.h"
 #include "oct-sparse.h"
+#include "quit.h"
 #include "sparse-dmsolve.h"
 #include "sparse-qr.h"
 
 template <typename T>
 static MSparse<T>
 dmsolve_extract (const MSparse<T> &A, const octave_idx_type *Pinv,
                  const octave_idx_type *Q, octave_idx_type rst,
                  octave_idx_type rend, octave_idx_type cst,
@@ -384,19 +389,21 @@ dmsolve (const ST& a, const T& b, octave
 
       csm.m = nr;
       csm.n = nc;
       csm.x = 0;
       csm.nz = -1;
       csm.nzmax = a.nnz ();
 
       // Cast away const on A, with full knowledge that CSparse won't touch it.
-      // Prevents the methods below making a copy of the data.
-      csm.p = const_cast<octave::suitesparse_integer *>(octave::to_suitesparse_intptr (a.cidx ()));
-      csm.i = const_cast<octave::suitesparse_integer *>(octave::to_suitesparse_intptr (a.ridx ()));
+      // Prevents the methods below from making a copy of the data.
+      csm.p = const_cast<octave::suitesparse_integer *>
+                (octave::to_suitesparse_intptr (a.cidx ()));
+      csm.i = const_cast<octave::suitesparse_integer *>
+                (octave::to_suitesparse_intptr (a.ridx ()));
 
       CXSPARSE_DNAME (d) *dm = CXSPARSE_DNAME(_dmperm) (&csm, 0);
       octave_idx_type *p = octave::to_octave_idx_type_ptr (dm->p);
       octave_idx_type *q = octave::to_octave_idx_type_ptr (dm->q);
 
       OCTAVE_LOCAL_BUFFER (octave_idx_type, pinv, nr);
 
       for (octave_idx_type i = 0; i < nr; i++)
@@ -409,18 +416,20 @@ dmsolve (const ST& a, const T& b, octave
       retval.resize (nc, b_nc);
 
       // Leading over-determined block
       if (dm->rr[2] < nr && dm->cc[3] < nc)
         {
           ST m = dmsolve_extract (a, pinv, q, dm->rr[2], nr, dm->cc[3], nc,
                                   nnz_remaining, true);
           nnz_remaining -= m.nnz ();
-          RT mtmp = octave::math::qrsolve (m, dmsolve_extract (btmp, 0, 0, dm->rr[2],
-                                           b_nr, 0, b_nc), info);
+          RT mtmp = octave::math::qrsolve (m, dmsolve_extract (btmp, 0, 0,
+                                                               dm->rr[2], b_nr,
+                                                               0, b_nc),
+                                           info);
           dmsolve_insert (retval, mtmp, q, dm->cc[3], 0);
 
           if (dm->rr[2] > 0 && ! info)
             {
               m = dmsolve_extract (a, pinv, q, 0, dm->rr[2],
                                    dm->cc[3], nc, nnz_remaining, true);
               nnz_remaining -= m.nnz ();
               RT ctmp = dmsolve_extract (btmp, 0, 0, 0, dm->rr[2], 0, b_nc);
@@ -458,18 +467,20 @@ dmsolve (const ST& a, const T& b, octave
             }
         }
 
       // Trailing under-determined block
       if (dm->rr[1] > 0 && dm->cc[2] > 0 && ! info)
         {
           ST m = dmsolve_extract (a, pinv, q, 0, dm->rr[1], 0,
                                   dm->cc[2], nnz_remaining, true);
-          RT mtmp = octave::math::qrsolve (m, dmsolve_extract (btmp, 0, 0, 0, dm->rr[1],
-                                           0, b_nc), info);
+          RT mtmp = octave::math::qrsolve (m, dmsolve_extract (btmp, 0, 0, 0,
+                                                               dm->rr[1], 0,
+                                                               b_nc),
+                                           info);
           dmsolve_insert (retval, mtmp, q, 0, 0);
         }
 
       CXSPARSE_DNAME (_dfree) (dm);
     }
 
 #else
 
diff --git a/liboctave/numeric/sparse-lu.cc b/liboctave/numeric/sparse-lu.cc
--- a/liboctave/numeric/sparse-lu.cc
+++ b/liboctave/numeric/sparse-lu.cc
@@ -25,16 +25,17 @@ along with Octave; see the file COPYING.
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
 #include "CSparse.h"
 #include "PermMatrix.h"
 #include "dSparse.h"
 #include "lo-error.h"
+#include "lo-mappers.h"
 #include "oct-locbuf.h"
 #include "oct-sparse.h"
 #include "oct-spparms.h"
 #include "sparse-lu.h"
 
 namespace octave
 {
   namespace math
diff --git a/liboctave/numeric/sparse-lu.h b/liboctave/numeric/sparse-lu.h
--- a/liboctave/numeric/sparse-lu.h
+++ b/liboctave/numeric/sparse-lu.h
@@ -23,18 +23,22 @@ along with Octave; see the file COPYING.
 */
 
 #if ! defined (octave_sparse_lu_h)
 #define octave_sparse_lu_h 1
 
 #include "octave-config.h"
 
 #include "MArray.h"
+#include "dMatrix.h"
 #include "dSparse.h"
 
+class ColumnVector;
+class PermMatrix;
+
 namespace octave
 {
   namespace math
   {
     // If the sparse matrix classes become templated on the element type
     // (i.e., sparse_matrix<double>), then it might be best to make the
     // template parameter of this class also be the element type instead
     // of the matrix type.
diff --git a/liboctave/numeric/sparse-qr.cc b/liboctave/numeric/sparse-qr.cc
--- a/liboctave/numeric/sparse-qr.cc
+++ b/liboctave/numeric/sparse-qr.cc
@@ -20,19 +20,27 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
+#include "CMatrix.h"
+#include "CSparse.h"
+#include "MArray.h"
+#include "dColVector.h"
+#include "dMatrix.h"
+#include "dSparse.h"
 #include "lo-error.h"
 #include "oct-locbuf.h"
+#include "oct-refcount.h"
 #include "oct-sparse.h"
+#include "quit.h"
 #include "sparse-qr.h"
 
 namespace octave
 {
   namespace math
   {
     template <typename SPARSE_T>
     class
@@ -179,19 +187,21 @@ namespace octave
 
       CXSPARSE_DNAME () A;
 
       A.nzmax = a.nnz ();
       A.m = nrows;
       A.n = ncols;
       // Cast away const on A, with full knowledge that CSparse won't touch it
       // Prevents the methods below making a copy of the data.
-      A.p = const_cast<suitesparse_integer *>(to_suitesparse_intptr (a.cidx ()));
-      A.i = const_cast<suitesparse_integer *>(to_suitesparse_intptr (a.ridx ()));
-      A.x = const_cast<double *>(a.data ());
+      A.p = const_cast<suitesparse_integer *>
+              (to_suitesparse_intptr (a.cidx ()));
+      A.i = const_cast<suitesparse_integer *>
+              (to_suitesparse_intptr (a.ridx ()));
+      A.x = const_cast<double *> (a.data ());
       A.nz = -1;
 
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       S = CXSPARSE_DNAME (_sqr) (order, &A, 1);
       N = CXSPARSE_DNAME (_qr) (&A, S);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
       if (! N)
@@ -321,17 +331,19 @@ namespace octave
         (*current_liboctave_error_handler) ("matrix dimension mismatch");
 
       if (nr == 0 || nc == 0 || b_nc == 0)
         ret = Matrix (nc, b_nc, 0.0);
       else
         {
           OCTAVE_LOCAL_BUFFER (double, buf, S->m2);
 
-          for (volatile octave_idx_type j = 0, idx = 0; j < b_nc; j++, idx+=b_nr)
+          for (volatile octave_idx_type j = 0, idx = 0;
+               j < b_nc;
+               j++, idx += b_nr)
             {
               octave_quit ();
 
               for (octave_idx_type i = nr; i < S->m2; i++)
                 buf[i] = 0.;
 
               volatile octave_idx_type nm = (nr < nc ? nr : nc);
 
@@ -945,20 +957,22 @@ namespace octave
 
       CXSPARSE_ZNAME () A;
 
       A.nzmax = a.nnz ();
       A.m = nrows;
       A.n = ncols;
       // Cast away const on A, with full knowledge that CSparse won't touch it
       // Prevents the methods below making a copy of the data.
-      A.p = const_cast<suitesparse_integer *>(to_suitesparse_intptr (a.cidx ()));
-      A.i = const_cast<suitesparse_integer *>(to_suitesparse_intptr (a.ridx ()));
-      A.x = const_cast<cs_complex_t *> (
-              reinterpret_cast<const cs_complex_t *> (a.data ()));
+      A.p = const_cast<suitesparse_integer *>
+              (to_suitesparse_intptr (a.cidx ()));
+      A.i = const_cast<suitesparse_integer *>
+              (to_suitesparse_intptr (a.ridx ()));
+      A.x = const_cast<cs_complex_t *>
+              (reinterpret_cast<const cs_complex_t *> (a.data ()));
       A.nz = -1;
 
       BEGIN_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
       S = CXSPARSE_ZNAME (_sqr) (order, &A, 1);
       N = CXSPARSE_ZNAME (_qr) (&A, S);
       END_INTERRUPT_IMMEDIATELY_IN_FOREIGN_CODE;
 
       if (! N)
@@ -1070,17 +1084,18 @@ namespace octave
     ComplexMatrix
     sparse_qr<SparseComplexMatrix>::sparse_qr_rep::C (const ComplexMatrix& b) const
     {
 #if defined (HAVE_CXSPARSE)
       octave_idx_type b_nr = b.rows ();
       octave_idx_type b_nc = b.cols ();
       octave_idx_type nc = N->L->n;
       octave_idx_type nr = nrows;
-      const cs_complex_t *bvec = reinterpret_cast<const cs_complex_t *> (b.fortran_vec ());
+      const cs_complex_t *bvec
+        = reinterpret_cast<const cs_complex_t *> (b.fortran_vec ());
       ComplexMatrix ret (b_nr, b_nc);
       Complex *vec = ret.fortran_vec ();
 
       if (nr < 0 || nc < 0 || nr != b_nr)
         (*current_liboctave_error_handler) ("matrix dimension mismatch");
 
       if (nr == 0 || nc == 0 || b_nc == 0)
         ret = ComplexMatrix (nc, b_nc, Complex (0.0, 0.0));
diff --git a/liboctave/numeric/sparse-qr.h b/liboctave/numeric/sparse-qr.h
--- a/liboctave/numeric/sparse-qr.h
+++ b/liboctave/numeric/sparse-qr.h
@@ -21,20 +21,22 @@ along with Octave; see the file COPYING.
 
 */
 
 #if ! defined (octave_sparse_qr_h)
 #define octave_sparse_qr_h 1
 
 #include "octave-config.h"
 
-#include "dMatrix.h"
-#include "CMatrix.h"
-#include "dSparse.h"
-#include "CSparse.h"
+class Matrix;
+class ComplexMatrix;
+class SparseComplexMatrix;
+class SparseMatrix;
+class ColumnVector;
+template <typename T> class MArray;
 
 namespace octave
 {
   namespace math
   {
     // If the sparse matrix classes become templated on the element type
     // (i.e., sparse_matrix<double>), then it might be best to make the
     // template parameter of this class also be the element type instead
diff --git a/liboctave/numeric/svd.cc b/liboctave/numeric/svd.cc
--- a/liboctave/numeric/svd.cc
+++ b/liboctave/numeric/svd.cc
@@ -20,30 +20,29 @@ along with Octave; see the file COPYING.
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if defined (HAVE_CONFIG_H)
 #  include "config.h"
 #endif
 
-#include "svd.h"
+#include <cassert>
 
-#include <cassert>
 #include <algorithm>
 
 #include "CMatrix.h"
 #include "dDiagMatrix.h"
-#include "fDiagMatrix.h"
 #include "dMatrix.h"
 #include "fCMatrix.h"
+#include "fDiagMatrix.h"
 #include "fMatrix.h"
 #include "lo-error.h"
 #include "lo-lapack-proto.h"
-#include "oct-locbuf.h"
+#include "svd.h"
 
 namespace octave
 {
   namespace math
   {
     template <typename T>
     T
     svd<T>::left_singular_matrix (void) const
@@ -61,17 +60,16 @@ namespace octave
     {
       if (m_type == svd::Type::sigma_only)
         (*current_liboctave_error_handler)
           ("svd: V not computed because type == svd::sigma_only");
 
       return right_sm;
     }
 
-
     // GESVD specializations
 
 #define GESVD_REAL_STEP(f, F)                                   \
     F77_XFCN (f, F, (F77_CONST_CHAR_ARG2 (&jobu, 1),            \
                      F77_CONST_CHAR_ARG2 (&jobv, 1),            \
                      m, n, tmp_data, m1, s_vec, u, m1, vt,      \
                      nrow_vt1, work.data (), lwork, info        \
                      F77_CHAR_ARG_LEN (1)                       \
@@ -159,17 +157,16 @@ namespace octave
       work.reserve (lwork);
 
       GESVD_COMPLEX_STEP (cgesvd, CGESVD, F77_CMPLX_ARG);
     }
 
 #undef GESVD_REAL_STEP
 #undef GESVD_COMPLEX_STEP
 
-
     // GESDD specializations
 
 #define GESDD_REAL_STEP(f, F)                                           \
     F77_XFCN (f, F, (F77_CONST_CHAR_ARG2 (&jobz, 1),                    \
                      m, n, tmp_data, m1, s_vec, u, m1, vt, nrow_vt1,    \
                      work.data (), lwork, iwork, info                   \
                      F77_CHAR_ARG_LEN (1)))
 
@@ -269,17 +266,16 @@ namespace octave
       work.reserve (lwork);
 
       GESDD_COMPLEX_STEP (cgesdd, CGESDD, F77_CMPLX_ARG);
     }
 
 #undef GESDD_REAL_STEP
 #undef GESDD_COMPLEX_STEP
 
-
     template<typename T>
     svd<T>::svd (const T& a, svd::Type type,
                  svd::Driver driver)
       : m_type (type), m_driver (driver), left_sm (), sigma (), right_sm ()
     {
       F77_INT info;
 
       F77_INT m = octave::to_f77_int (a.rows ());
@@ -330,21 +326,20 @@ namespace octave
         {
         case svd::Type::economy:
           jobu = jobv = 'S';
           ncol_u = nrow_vt = nrow_s = ncol_s = min_mn;
           break;
 
         case svd::Type::sigma_only:
 
-          // Note:  for this case, both jobu and jobv should be 'N', but
-          // there seems to be a bug in dgesvd from Lapack V2.0.  To
-          // demonstrate the bug, set both jobu and jobv to 'N' and find
-          // the singular values of [eye(3), eye(3)].  The result is
-          // [-sqrt(2), -sqrt(2), -sqrt(2)].
+          // Note:  for this case, both jobu and jobv should be 'N', but there
+          // seems to be a bug in dgesvd from Lapack V2.0.  To demonstrate the
+          // bug, set both jobu and jobv to 'N' and find the singular values of
+          // [eye(3), eye(3)].  The result is [-sqrt(2), -sqrt(2), -sqrt(2)].
           //
           // For Lapack 3.0, this problem seems to be fixed.
 
           jobu = jobv = 'N';
           ncol_u = nrow_vt = 1;
           break;
 
         default:
diff --git a/liboctave/operators/mx-inlines.cc b/liboctave/operators/mx-inlines.cc
--- a/liboctave/operators/mx-inlines.cc
+++ b/liboctave/operators/mx-inlines.cc
@@ -20,34 +20,30 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, see
 <http://www.gnu.org/licenses/>.
 
 */
 
 #if ! defined (octave_mx_inlines_h)
 #define octave_mx_inlines_h 1
 
-// This file should not include config.h.  It is only included in other
-// C++ source files that should have included config.h before including
-// this file.
+// This file should *not* include config.h.  It is only included in other C++
+// source files that should have included config.h before including this file.
 
 #include <cstddef>
 #include <cmath>
-#include <cstring>
-#include <memory>
+
+#include <algorithm>
 
-#include "quit.h"
-
+#include "Array-util.h"
+#include "Array.h"
+#include "bsxfun.h"
 #include "oct-cmplx.h"
+#include "oct-inttypes.h"
 #include "oct-locbuf.h"
-#include "oct-inttypes.h"
-#include "Array.h"
-#include "Array-util.h"
-
-#include "bsxfun.h"
 
 // Provides some commonly repeated, basic loop templates.
 
 template <typename R, typename S>
 inline void mx_inline_fill (size_t n, R *r, S s) throw ()
 {
   for (size_t i = 0; i < n; i++)
     r[i] = s;
