# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1341608425 25200
#      Fri Jul 06 14:00:25 2012 -0700
# Node ID 5bc9b9cb4362edf07722057481cbe0bd22928aa1
# Parent  7d4f87c75dbb195e29da26dec6c83f6058cb7373
maint: Use Octave coding conventions for cuddled parenthesis in retval assignments.

* hello.cc, Array-util.cc, CNDArray.cc, CSparse.cc, Sparse.cc, dNDArray.cc,
dSparse.cc, fCNDArray.cc, fNDArray.cc, lo-specfun.cc, list_primes.m,
rectangle_lw.m, sinetone.m, amd.cc, bsxfun.cc, ccolamd.cc, eigs.cc, lu.cc,
qz.cc, spparms.cc, oct-stream.cc: Use Octave coding conventions for cuddled
parenthesis in retval assignments.

diff --git a/examples/hello.cc b/examples/hello.cc
--- a/examples/hello.cc
+++ b/examples/hello.cc
@@ -84,15 +84,15 @@ Returns all arguments in reverse order."
 
   // The octave_value_list class is a zero-based array of octave_value
   // objects.  The declaration for the octave_value class is in the
   // file ov.h.  The print() method will send its output to
   // octave_stdout, so it will also end up going through the pager.
 
   for (int i = 0; i < nargin; i++)
     {
-      octave_value tmp = args (i);
+      octave_value tmp = args(i);
       tmp.print (octave_stdout);
-      retval (nargin-i-1) = tmp;
+      retval(nargin-i-1) = tmp;
     }
 
   return retval;
 }
diff --git a/liboctave/Array-util.cc b/liboctave/Array-util.cc
--- a/liboctave/Array-util.cc
+++ b/liboctave/Array-util.cc
@@ -231,28 +231,28 @@ compute_index (const Array<octave_idx_ty
 }
 
 Array<octave_idx_type>
 conv_to_int_array (const Array<idx_vector>& a)
 {
   Array<octave_idx_type> retval (a.dims ());
 
   for (octave_idx_type i = 0; i < a.length (); i++)
-    retval (i) = a(i).elem (0);
+    retval(i) = a(i).elem (0);
 
   return retval;
 }
 
 Array<idx_vector>
 conv_to_array (const idx_vector *tmp, const octave_idx_type len)
 {
   Array<idx_vector> retval (dim_vector (len, 1));
 
   for (octave_idx_type i = 0; i < len; i++)
-      retval (i) = tmp[i];
+      retval(i) = tmp[i];
 
   return retval;
 }
 
 dim_vector
 freeze (Array<idx_vector>& ra_idx, const dim_vector& dimensions, int resize_ok)
 {
   dim_vector retval;
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -240,17 +240,17 @@ ComplexNDArray::fourier (int dim) const
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem((i + k*npts)*stride + j*dist);
 
           F77_FUNC (zfftf, ZFFTF) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
-            retval ((i + k*npts)*stride + j*dist) = tmp[i];
+            retval((i + k*npts)*stride + j*dist) = tmp[i];
         }
     }
 
   return retval;
 }
 
 ComplexNDArray
 ComplexNDArray::ifourier (int dim) const
@@ -287,17 +287,17 @@ ComplexNDArray::ifourier (int dim) const
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem((i + k*npts)*stride + j*dist);
 
           F77_FUNC (zfftb, ZFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
-            retval ((i + k*npts)*stride + j*dist) = tmp[i] /
+            retval((i + k*npts)*stride + j*dist) = tmp[i] /
               static_cast<double> (npts);
         }
     }
 
   return retval;
 }
 
 ComplexNDArray
@@ -328,22 +328,22 @@ ComplexNDArray::fourier2d (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l];
+                retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
@@ -376,22 +376,22 @@ ComplexNDArray::ifourier2d (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                retval((l + k*npts)*stride + j*dist) = prow[l] /
                   static_cast<double> (npts);
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
@@ -424,22 +424,22 @@ ComplexNDArray::fourierNd (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l];
+                retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
 }
@@ -471,22 +471,22 @@ ComplexNDArray::ifourierNd (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                retval((l + k*npts)*stride + j*dist) = prow[l] /
                   static_cast<double> (npts);
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -1634,17 +1634,17 @@ SparseComplexMatrix::utsolve (MatrixType
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
-                    retval (perm[i], j) = work[i];
+                    retval(perm[i], j) = work[i];
                 }
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
 
@@ -2157,17 +2157,17 @@ SparseComplexMatrix::utsolve (MatrixType
                             {
                               octave_idx_type iidx = ridx(i);
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
-                    retval (perm[i], j) = work[i];
+                    retval(perm[i], j) = work[i];
                 }
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
 
@@ -2690,17 +2690,17 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                               octave_idx_type iidx = perm[ridx(i)];
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
-                    retval (i, j) = work[i];
+                    retval(i, j) = work[i];
                 }
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
 
@@ -3254,17 +3254,17 @@ SparseComplexMatrix::ltsolve (MatrixType
 
                               octave_idx_type iidx = perm[ridx(i)];
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
-                    retval (i, j) = work[i];
+                    retval(i, j) = work[i];
                 }
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
 
diff --git a/liboctave/Sparse.cc b/liboctave/Sparse.cc
--- a/liboctave/Sparse.cc
+++ b/liboctave/Sparse.cc
@@ -2598,17 +2598,17 @@ Sparse<T>::array_value () const
           if (cidx(j+1) > i)
             retval(j) = data (i++);
         }
     }
   else
     {
       for (octave_idx_type j = 0, nc = cols (); j < nc; j++)
         for (octave_idx_type i = cidx(j), iu = cidx(j+1); i < iu; i++)
-          retval (ridx(i), j) = data (i);
+          retval(ridx(i), j) = data (i);
     }
 
   return retval;
 }
 
 /*
  * Tests
  *
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -281,17 +281,17 @@ NDArray::fourier (int dim) const
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem((i + k*npts)*stride + j*dist);
 
           F77_FUNC (zfftf, ZFFTF) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
-            retval ((i + k*npts)*stride + j*dist) = tmp[i];
+            retval((i + k*npts)*stride + j*dist) = tmp[i];
         }
     }
 
   return retval;
 }
 
 ComplexNDArray
 NDArray::ifourier (int dim) const
@@ -328,17 +328,17 @@ NDArray::ifourier (int dim) const
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem((i + k*npts)*stride + j*dist);
 
           F77_FUNC (zfftb, ZFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
-            retval ((i + k*npts)*stride + j*dist) = tmp[i] /
+            retval((i + k*npts)*stride + j*dist) = tmp[i] /
               static_cast<double> (npts);
         }
     }
 
   return retval;
 }
 
 ComplexNDArray
@@ -369,22 +369,22 @@ NDArray::fourier2d (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l];
+                retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
@@ -417,22 +417,22 @@ NDArray::ifourier2d (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                retval((l + k*npts)*stride + j*dist) = prow[l] /
                   static_cast<double> (npts);
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
@@ -465,22 +465,22 @@ NDArray::fourierNd (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftf, ZFFTF) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l];
+                retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
 }
@@ -512,22 +512,22 @@ NDArray::ifourierNd (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (zfftb, ZFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                retval((l + k*npts)*stride + j*dist) = prow[l] /
                   static_cast<double> (npts);
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -2778,17 +2778,17 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                               octave_idx_type iidx = perm[ridx(i)];
                               work[iidx] = work[iidx] - tmp * data(i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
-                    retval (i, j) = work[i];
+                    retval(i, j) = work[i];
                 }
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
 
@@ -3344,17 +3344,17 @@ SparseMatrix::ltsolve (MatrixType &matty
 
                               octave_idx_type iidx = perm[ridx(i)];
                               cwork[iidx] = cwork[iidx] - tmp * data(i);
                             }
                         }
                     }
 
                   for (octave_idx_type i = 0; i < nc; i++)
-                    retval (i, j) = cwork[i];
+                    retval(i, j) = cwork[i];
                 }
 
               if (calc_cond)
                 {
                   // Calculation of 1-norm of inv(*this)
                   OCTAVE_LOCAL_BUFFER (double, work, nm);
                   for (octave_idx_type i = 0; i < nm; i++)
                     work[i] = 0.;
@@ -5171,17 +5171,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
                         {
                           (*current_liboctave_error_handler)
                             ("SparseMatrix::solve solve failed");
                           err = -1;
                           break;
                         }
 
                       for (octave_idx_type i = 0; i < b_nr; i++)
-                        retval (i, j) = Complex (Bx[i], Bz[i]);
+                        retval(i, j) = Complex (Bx[i], Bz[i]);
                     }
                 }
             }
         }
 
       if (typ == MatrixType::Banded)
         {
           // Create the storage for the banded form of the sparse matrix
@@ -5305,17 +5305,17 @@ SparseMatrix::bsolve (MatrixType &mattyp
 
                       F77_XFCN (dgbtrs, DGBTRS,
                                 (F77_CONST_CHAR_ARG2 (&job, 1),
                                  nr, n_lower, n_upper, 1, tmp_data,
                                  ldm, pipvt, Bz, b.rows (), err
                                  F77_CHAR_ARG_LEN (1)));
 
                       for (octave_idx_type i = 0; i < nr; i++)
-                        retval (i, j) = Complex (Bx[i], Bz[i]);
+                        retval(i, j) = Complex (Bx[i], Bz[i]);
                     }
                 }
             }
         }
       else if (typ != MatrixType::Banded_Hermitian)
         (*current_liboctave_error_handler) ("incorrect matrix type");
     }
 
@@ -6482,17 +6482,17 @@ SparseMatrix::fsolve (MatrixType &mattyp
                       UMFPACK_DNAME (report_status) (control, status);
 
                       err = -1;
 
                       break;
                     }
 
                   for (octave_idx_type i = 0; i < b_nr; i++)
-                    retval (i, j) = Complex (Xx[i], Xz[i]);
+                    retval(i, j) = Complex (Xx[i], Xz[i]);
                 }
 
               UMFPACK_DNAME (report_info) (control, info);
 
               UMFPACK_DNAME (free_numeric) (&Numeric);
             }
           else
             mattype.mark_as_rectangular ();
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -237,17 +237,17 @@ FloatComplexNDArray::fourier (int dim) c
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem((i + k*npts)*stride + j*dist);
 
           F77_FUNC (cfftf, CFFTF) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
-            retval ((i + k*npts)*stride + j*dist) = tmp[i];
+            retval((i + k*npts)*stride + j*dist) = tmp[i];
         }
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::ifourier (int dim) const
@@ -284,17 +284,17 @@ FloatComplexNDArray::ifourier (int dim) 
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem((i + k*npts)*stride + j*dist);
 
           F77_FUNC (cfftb, CFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
-            retval ((i + k*npts)*stride + j*dist) = tmp[i] /
+            retval((i + k*npts)*stride + j*dist) = tmp[i] /
               static_cast<float> (npts);
         }
     }
 
   return retval;
 }
 
 FloatComplexNDArray
@@ -325,22 +325,22 @@ FloatComplexNDArray::fourier2d (void) co
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l];
+                retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
@@ -373,22 +373,22 @@ FloatComplexNDArray::ifourier2d (void) c
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                retval((l + k*npts)*stride + j*dist) = prow[l] /
                   static_cast<float> (npts);
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
@@ -421,22 +421,22 @@ FloatComplexNDArray::fourierNd (void) co
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l];
+                retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
 }
@@ -468,22 +468,22 @@ FloatComplexNDArray::ifourierNd (void) c
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                retval((l + k*npts)*stride + j*dist) = prow[l] /
                   static_cast<float> (npts);
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -241,17 +241,17 @@ FloatNDArray::fourier (int dim) const
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem((i + k*npts)*stride + j*dist);
 
           F77_FUNC (cfftf, CFFTF) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
-            retval ((i + k*npts)*stride + j*dist) = tmp[i];
+            retval((i + k*npts)*stride + j*dist) = tmp[i];
         }
     }
 
   return retval;
 }
 
 FloatComplexNDArray
 FloatNDArray::ifourier (int dim) const
@@ -288,17 +288,17 @@ FloatNDArray::ifourier (int dim) const
           octave_quit ();
 
           for (octave_idx_type i = 0; i < npts; i++)
             tmp[i] = elem((i + k*npts)*stride + j*dist);
 
           F77_FUNC (cfftb, CFFTB) (npts, tmp, pwsave);
 
           for (octave_idx_type i = 0; i < npts; i++)
-            retval ((i + k*npts)*stride + j*dist) = tmp[i] /
+            retval((i + k*npts)*stride + j*dist) = tmp[i] /
               static_cast<float> (npts);
         }
     }
 
   return retval;
 }
 
 FloatComplexNDArray
@@ -329,22 +329,22 @@ FloatNDArray::fourier2d (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l];
+                retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
 }
@@ -377,22 +377,22 @@ FloatNDArray::ifourier2d (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                retval((l + k*npts)*stride + j*dist) = prow[l] /
                   static_cast<float> (npts);
             }
         }
 
       stride *= dv2(i);
     }
 
   return retval;
@@ -425,22 +425,22 @@ FloatNDArray::fourierNd (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftf, CFFTF) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l];
+                retval((l + k*npts)*stride + j*dist) = prow[l];
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
 }
@@ -472,22 +472,22 @@ FloatNDArray::ifourierNd (void) const
 
       for (octave_idx_type k = 0; k < nloop; k++)
         {
           for (octave_idx_type j = 0; j < howmany; j++)
             {
               octave_quit ();
 
               for (octave_idx_type l = 0; l < npts; l++)
-                prow[l] = retval ((l + k*npts)*stride + j*dist);
+                prow[l] = retval((l + k*npts)*stride + j*dist);
 
               F77_FUNC (cfftb, CFFTB) (npts, prow, pwsave);
 
               for (octave_idx_type l = 0; l < npts; l++)
-                retval ((l + k*npts)*stride + j*dist) = prow[l] /
+                retval((l + k*npts)*stride + j*dist) = prow[l] /
                   static_cast<float> (npts);
             }
         }
 
       stride *= dv(i);
     }
 
   return retval;
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -1981,32 +1981,32 @@ airy (const ComplexNDArray& z, bool deri
 {
   dim_vector dv = z.dims ();
   octave_idx_type nel = dv.numel ();
   ComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
-    retval (i) = airy (z(i), deriv, scaled, ierr(i));
+    retval(i) = airy (z(i), deriv, scaled, ierr(i));
 
   return retval;
 }
 
 ComplexNDArray
 biry (const ComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = z.dims ();
   octave_idx_type nel = dv.numel ();
   ComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
-    retval (i) = biry (z(i), deriv, scaled, ierr(i));
+    retval(i) = biry (z(i), deriv, scaled, ierr(i));
 
   return retval;
 }
 
 FloatComplex
 airy (const FloatComplex& z, bool deriv, bool scaled, octave_idx_type& ierr)
 {
   float ar = 0.0;
@@ -2111,32 +2111,32 @@ airy (const FloatComplexNDArray& z, bool
 {
   dim_vector dv = z.dims ();
   octave_idx_type nel = dv.numel ();
   FloatComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
-    retval (i) = airy (z(i), deriv, scaled, ierr(i));
+    retval(i) = airy (z(i), deriv, scaled, ierr(i));
 
   return retval;
 }
 
 FloatComplexNDArray
 biry (const FloatComplexNDArray& z, bool deriv, bool scaled, Array<octave_idx_type>& ierr)
 {
   dim_vector dv = z.dims ();
   octave_idx_type nel = dv.numel ();
   FloatComplexNDArray retval (dv);
 
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
-    retval (i) = biry (z(i), deriv, scaled, ierr(i));
+    retval(i) = biry (z(i), deriv, scaled, ierr(i));
 
   return retval;
 }
 
 static void
 gripe_betainc_nonconformant (octave_idx_type r1, octave_idx_type c1, octave_idx_type r2, octave_idx_type c2, octave_idx_type r3,
                              octave_idx_type c3)
 {
diff --git a/scripts/miscellaneous/list_primes.m b/scripts/miscellaneous/list_primes.m
--- a/scripts/miscellaneous/list_primes.m
+++ b/scripts/miscellaneous/list_primes.m
@@ -46,18 +46,18 @@ function retval = list_primes (n)
   endif
 
   if (n == 2)
     retval = [2; 3];
     return;
   endif
 
   retval = zeros (1, n);
-  retval (1) = 2;
-  retval (2) = 3;
+  retval(1) = 2;
+  retval(2) = 3;
 
   n = n - 2;
   i = 3;
   p = 5;
   while (n > 0)
 
     is_prime = 1;
     is_unknown = 1;
@@ -70,17 +70,17 @@ function retval = list_primes (n)
       if (a * d == p)
         is_prime = 0;
         is_unknown = 0;
       endif
       d = d + 2;
     endwhile
 
     if (is_prime)
-      retval (i++) = p;
+      retval(i++) = p;
       n--;
     endif
     p = p + 2;
 
   endwhile
 
 endfunction
 
diff --git a/scripts/signal/private/rectangle_lw.m b/scripts/signal/private/rectangle_lw.m
--- a/scripts/signal/private/rectangle_lw.m
+++ b/scripts/signal/private/rectangle_lw.m
@@ -29,11 +29,11 @@ function retval = rectangle_lw (n, b)
 
   if (nargin != 2)
     print_usage ();
   endif
 
   retval = zeros (n, 1);
   t = floor (1 / b);
 
-  retval (1:t, 1) = ones (t, 1);
+  retval(1:t, 1) = ones (t, 1);
 
 endfunction
diff --git a/scripts/signal/sinetone.m b/scripts/signal/sinetone.m
--- a/scripts/signal/sinetone.m
+++ b/scripts/signal/sinetone.m
@@ -53,16 +53,16 @@ function retval = sinetone (freq, rate, 
   endif
 
   n = length (freq);
   ns = round (rate * sec);
 
   retval = zeros (ns, n);
 
   for k = 1:n
-    retval (:, k) = ampl(k) * sin (2 * pi * (1:ns) / rate * freq(k))';
+    retval(:, k) = ampl(k) * sin (2 * pi * (1:ns) / rate * freq(k))';
   endfor
 
 endfunction
 
 
 %!assert (size (sinetone (18e6, 150e6, 19550/150e6, 1)), [19550, 1])
 
diff --git a/src/DLD-FUNCTIONS/amd.cc b/src/DLD-FUNCTIONS/amd.cc
--- a/src/DLD-FUNCTIONS/amd.cc
+++ b/src/DLD-FUNCTIONS/amd.cc
@@ -185,17 +185,17 @@ The author of the code itself is Timothy
                   {
                     if (nargout > 1)
                       retval(1) = xinfo;
 
                     Matrix Pout (1, n_col);
                     for (octave_idx_type i = 0; i < n_col; i++)
                       Pout.xelem (i) = P[i] + 1;
 
-                    retval (0) = Pout;
+                    retval(0) = Pout;
                   }
                 }
             }
         }
     }
 #else
 
   error ("amd: not available in this version of Octave");
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -625,17 +625,17 @@ dimensionality as the other array.\n\
                           else if BSXLOOP(uint64NDArray, "uint64", uint64)
                           else
                             C = do_cat_op (C, tmp(0), ra_idx);
                         }
                     }
 
 #define BSXEND(T) \
                   (have_ ## T) \
-                    retval (0) = result_ ## T;
+                    retval(0) = result_ ## T;
 
                   if BSXEND(NDArray)
                   else if BSXEND(ComplexNDArray)
                   else if BSXEND(FloatNDArray)
                   else if BSXEND(FloatComplexNDArray)
                   else if BSXEND(boolNDArray)
                   else if BSXEND(int8NDArray)
                   else if BSXEND(int16NDArray)
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -299,17 +299,17 @@ colamd, symamd, and other related orderi
             }
         }
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
         out_perm(i) = p [i] + 1;
 
-      retval (0) = out_perm;
+      retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
         CCOLAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
       if (nargout == 2)
         {
@@ -531,17 +531,17 @@ colamd, symamd, and other related orderi
             }
         }
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
         out_perm(i) = perm [i] + 1;
 
-      retval (0) = out_perm;
+      retval(0) = out_perm;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
           for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
             out_stats (i) = stats [i] ;
           retval(1) = out_stats;
diff --git a/src/DLD-FUNCTIONS/eigs.cc b/src/DLD-FUNCTIONS/eigs.cc
--- a/src/DLD-FUNCTIONS/eigs.cc
+++ b/src/DLD-FUNCTIONS/eigs.cc
@@ -608,17 +608,17 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
                    octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
               else
                 nconv = EigsComplexNonSymmetricMatrix
                   (acm, typ, k, p, info, eig_vec, eig_val, bcm, permB, cresid,
                    octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
             }
 
           if (nargout < 2)
-            retval (0) = eig_val;
+            retval(0) = eig_val;
           else
             {
               retval(2) = double (info);
               retval(1) = ComplexDiagMatrix (eig_val);
               retval(0) = eig_vec;
             }
         }
       else if (sigmai != 0.)
@@ -641,17 +641,17 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
               else
                 nconv = EigsComplexNonSymmetricMatrixShift
                   (ComplexMatrix (amm), sigma, k, p, info, eig_vec,
                    eig_val, ComplexMatrix (bmm), permB, cresid,
                    octave_stdout, tol, (nargout > 1), cholB, disp, maxit);
             }
 
           if (nargout < 2)
-            retval (0) = eig_val;
+            retval(0) = eig_val;
           else
             {
               retval(2) = double (info);
               retval(1) = ComplexDiagMatrix (eig_val);
               retval(0) = eig_vec;
             }
         }
       else
@@ -689,17 +689,17 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
                   else
                     nconv = EigsRealSymmetricMatrix
                       (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
                        resid, octave_stdout, tol, (nargout > 1), cholB, disp,
                        maxit);
                 }
 
               if (nargout < 2)
-                retval (0) = eig_val;
+                retval(0) = eig_val;
               else
                 {
                   retval(2) = double (info);
                   retval(1) = DiagMatrix (eig_val);
                   retval(0) = eig_vec;
                 }
             }
           else
@@ -735,17 +735,17 @@ K. Maschhoff, D. Sorensen, and C. Yang. 
                   else
                     nconv = EigsRealNonSymmetricMatrix
                       (amm, typ, k, p, info, eig_vec, eig_val, bmm, permB,
                        resid, octave_stdout, tol, (nargout > 1), cholB, disp,
                        maxit);
                 }
 
               if (nargout < 2)
-                retval (0) = eig_val;
+                retval(0) = eig_val;
               else
                 {
                   retval(2) = double (info);
                   retval(1) = ComplexDiagMatrix (eig_val);
                   retval(0) = eig_vec;
                 }
             }
         }
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -221,17 +221,17 @@ information.\n\
             {
             case 0:
             case 1:
             case 2:
               {
                 SparseLU fact (m, Qinit, thres, false, true);
 
                 if (nargout < 2)
-                  retval (0) = fact.Y ();
+                  retval(0) = fact.Y ();
                 else
                   {
                     PermMatrix P = fact.Pr_mat ();
                     SparseMatrix L = P.transpose () * fact.L ();
                     retval(1) = octave_value (fact.U (),
                                               MatrixType (MatrixType::Upper));
 
                     retval(0) = octave_value (L,
@@ -241,17 +241,17 @@ information.\n\
               }
               break;
 
             case 3:
               {
                 SparseLU fact (m, Qinit, thres, false, true);
 
                 if (vecout)
-                  retval (2) = fact.Pr_vec ();
+                  retval(2) = fact.Pr_vec ();
                 else
                   retval(2) = fact.Pr_mat ();
 
                 retval(1) = octave_value (fact.U (),
                                           MatrixType (MatrixType::Upper));
                 retval(0) = octave_value (fact.L (),
                                           MatrixType (MatrixType::Lower));
               }
@@ -291,17 +291,17 @@ information.\n\
             {
             case 0:
             case 1:
             case 2:
               {
                 SparseComplexLU fact (m, Qinit, thres, false, true);
 
                 if (nargout < 2)
-                  retval (0) = fact.Y ();
+                  retval(0) = fact.Y ();
                 else
                   {
                     PermMatrix P = fact.Pr_mat ();
                     SparseComplexMatrix L = P.transpose () * fact.L ();
                     retval(1) = octave_value (fact.U (),
                                               MatrixType (MatrixType::Upper));
 
                     retval(0) = octave_value (L,
@@ -311,17 +311,17 @@ information.\n\
               }
               break;
 
             case 3:
               {
                 SparseComplexLU fact (m, Qinit, thres, false, true);
 
                 if (vecout)
-                  retval (2) = fact.Pr_vec ();
+                  retval(2) = fact.Pr_vec ();
                 else
                   retval(2) = fact.Pr_mat ();
 
                 retval(1) = octave_value (fact.U (),
                                           MatrixType (MatrixType::Upper));
                 retval(0) = octave_value (fact.L (),
                                           MatrixType (MatrixType::Lower));
               }
diff --git a/src/DLD-FUNCTIONS/qz.cc b/src/DLD-FUNCTIONS/qz.cc
--- a/src/DLD-FUNCTIONS/qz.cc
+++ b/src/DLD-FUNCTIONS/qz.cc
@@ -1191,29 +1191,29 @@ compatibility with @sc{matlab}.\n\
             retval(2) = QQ.transpose ();
         }
 
     case 2:
       {
         if (complex_case)
           {
 #ifdef DEBUG
-            std::cout << "qz: retval (1) = cbb = " << std::endl;
+            std::cout << "qz: retval(1) = cbb = " << std::endl;
             octave_print_internal (std::cout, cbb, 0);
             std::cout << std::endl << "qz: retval(0) = caa = " <<std::endl;
             octave_print_internal (std::cout, caa, 0);
             std::cout << std::endl;
 #endif
             retval(1) = cbb;
             retval(0) = caa;
           }
       else
         {
 #ifdef DEBUG
-          std::cout << "qz: retval (1) = bb = " << std::endl;
+          std::cout << "qz: retval(1) = bb = " << std::endl;
           octave_print_internal (std::cout, bb, 0);
           std::cout << std::endl << "qz: retval(0) = aa = " <<std::endl;
           octave_print_internal (std::cout, aa, 0);
           std::cout << std::endl;
 #endif
           retval(1) = bb;
           retval(0) = aa;
         }
diff --git a/src/DLD-FUNCTIONS/spparms.cc b/src/DLD-FUNCTIONS/spparms.cc
--- a/src/DLD-FUNCTIONS/spparms.cc
+++ b/src/DLD-FUNCTIONS/spparms.cc
@@ -108,18 +108,18 @@ running time.\n\
   if (nargin == 0)
     {
       if (nargout == 0)
         octave_sparse_params::print_info (octave_stdout, "");
       else if (nargout == 1)
         retval(0) =  octave_sparse_params::get_vals ();
       else if (nargout == 2)
         {
-          retval (1) = octave_sparse_params::get_vals ();
-          retval (0) = octave_sparse_params::get_keys ();
+          retval(1) = octave_sparse_params::get_vals ();
+          retval(0) = octave_sparse_params::get_keys ();
         }
       else
         error ("spparms: too many output arguments");
     }
   else if (nargin == 1)
     {
       if (args(0).is_string ())
         {
@@ -133,17 +133,17 @@ running time.\n\
           else if (str == "tight")
             octave_sparse_params::tight ();
           else
             {
               double val = octave_sparse_params::get_key (str);
               if (xisnan (val))
                 error ("spparms: KEY not recognized");
               else
-                retval (0) = val;
+                retval(0) = val;
             }
         }
       else
         {
           NDArray vals = args(0).array_value ();
 
           if (error_state)
             error ("spparms: input must be a string or a vector");
diff --git a/src/oct-stream.cc b/src/oct-stream.cc
--- a/src/oct-stream.cc
+++ b/src/oct-stream.cc
@@ -2133,17 +2133,17 @@ octave_base_stream::oscanf (const std::s
 
               quit = do_oscanf (elt, tmp, who);
 
               if (quit)
                 break;
               else
                 {
                   if (tmp.is_defined ())
-                    retval (num_values++) = tmp;
+                    retval(num_values++) = tmp;
 
                   if (! ok ())
                     break;
 
                   elt = fmt_list.next (nconv > 0);
                 }
             }
 
