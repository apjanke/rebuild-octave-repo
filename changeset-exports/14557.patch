# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1334262459 14400
#      Thu Apr 12 16:27:39 2012 -0400
# Node ID e8e86ae3abbc5f875a112a1967f9affca727f7b8
# Parent  15e4ec503cfdc20fb29dff460525cdfe72c32003
make diag (x, m, n) return a proper diagonal matrix object (bug #36099)

* Array.h, Array.cc (Array<T>::diag (octave_idx_type, octave_idx_type)
const): New function.

* CMatrix.h, CMatrix.cc (ComplexMatrix::diag (octave_idx_type,
octave_idx_type) const): New function.
* dMatrix.h, dMatrix.cc (Matrix::diag (octave_idx_type,
octave_idx_type) const): New function.
* fCMatrix.h, fCMatrix.cc (FloatComplexMatrix::diag (octave_idx_type,
octave_idx_type) const): New function.
* fMatrix.h, fMatrix.cc (FloatMatrix::diag (octave_idx_type,
octave_idx_type) const): New function.

* CNDArray.cc, CNDArray.h (ComplexNDArray::diag (octave_idx_type,
octave_idx_type) const): New forwarding function.
* boolNDArray.cc, boolNDArray.h (boolNDArray::diag (octave_idx_type,
octave_idx_type) const): New forwarding function.
* chNDArray.cc, chNDArray.h (charNDArray::diag (octave_idx_type,
octave_idx_type) const): New forwarding function.
* dNDArray.cc, dNDArray.h (NDArray::diag (octave_idx_type,
octave_idx_type) const): New forwarding function.
* fCNDArray.cc, fCNDArray.h (FloatComplexNDArray::diag
(octave_idx_type, octave_idx_type) const): New forwarding function.
* fNDArray.cc, fNDArray.h (FloatNDArray::diag (octave_idx_type,
octave_idx_type) const): New forwarding function.
* intNDArray.cc, intNDArray.h (intNDArray<T>::diag (octave_idx_type,
octave_idx_type) const): New forwarding function.
* Cell.cc, Cell.h (Cell::diag (octave_idx_type, octave_idx_type)
const): New function.

* ov.h (octave_value::diag (octave_idx_type, octave_idx_type)):
New function.
* ov-base.h, ov-base.cc (octave_base_value::diag (octave_idx_type,
octave_idx_type) const): New virtual function and default implementation.
* ov-base-mat.h (octave_base_matrix<T>::diag (octave_idx_type,
octave_idx_type) const): New function.
* ov-base-scalar.cc, ov-base-scalar.h (octave_base_scalar<T>::diag
(octave_idx_type, octave_idx_type)): New function.
* ov-complex.cc, ov-complex.h (octave_complex::diag (octave_idx_type,
octave_idx_type) const): New function.
* ov-cx-mat.cc, ov-complex.h (octave_complex_matrix::diag
(octave_idx_type, octave_idx_type) const): New function.
* ov-float.cc, ov-float.h (octave_float_scalar::diag (octave_idx_type,
octave_idx_type) const): New function.
* ov-flt-complex.cc, ov-flt-complex.h (octave_float_complex::diag
(octave_idx_type, octave_idx_type) const): New function.
* ov-flt-cx-mat.cc, ov-flt-cx-mat.h (octave_float_complex_matrix::diag
(octave_idx_type, octave_idx_type) const): New function.
* ov-flt-re-mat.cc, ov-flt-re-mat.h (octave_float_matrix::diag
(octave_idx_type, octave_idx_type) const): New function.
* ov-range.cc, ov-range.h (octave_range::diag (octave_idx_type,
octave_idx_type) const): New function.
* ov-re-mat.cc, ov-re-mat.h (octave_matrix::diag (octave_idx_type,
octave_idx_type) const): New function.
* ov-scalar.cc, ov-scalar.h (octave_scalar::diag (octave_idx_type,
octave_idx_type) const): New function.

* data.cc (Fdiag): Use two-arg octave_value::diag method for
dispatching.  New tests.

diff --git a/liboctave/Array.cc b/liboctave/Array.cc
--- a/liboctave/Array.cc
+++ b/liboctave/Array.cc
@@ -2519,16 +2519,36 @@ Array<T>::diag (octave_idx_type k) const
         }
     }
 
   return d;
 }
 
 template <class T>
 Array<T>
+Array<T>::diag (octave_idx_type m, octave_idx_type n) const
+{
+  Array<T> retval;
+
+  if (ndims () == 2 && (rows () == 1 || cols () == 1))
+    {
+      retval.resize (m, n, resize_fill_value ());
+
+      for (octave_idx_type i = 0; i < numel (); i++)
+        retval.xelem (i, i) = xelem (i);
+    }
+  else
+    (*current_liboctave_error_handler)
+      ("cat: invalid dimension");
+
+  return retval;
+}
+
+template <class T>
+Array<T>
 Array<T>::cat (int dim, octave_idx_type n, const Array<T> *array_list)
 {
   // Default concatenation.
   bool (dim_vector::*concat_rule) (const dim_vector&, int) = &dim_vector::concat;
 
   if (dim == -1 || dim == -2)
     {
       concat_rule = &dim_vector::hvcat;
diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -557,16 +557,18 @@ public:
   Array<octave_idx_type> find (octave_idx_type n = -1, bool backward = false) const;
 
   // Returns the n-th element in increasing order, using the same ordering as
   // used for sort. n can either be a scalar index or a contiguous range.
   Array<T> nth_element (const idx_vector& n, int dim = 0) const;
 
   Array<T> diag (octave_idx_type k = 0) const;
 
+  Array<T> diag (octave_idx_type m, octave_idx_type n) const;
+
   // Concatenation along a specified (0-based) dimension, equivalent to cat().
   // dim = -1 corresponds to dim = 0 and dim = -2 corresponds to dim = 1,
   // but apply the looser matching rules of vertcat/horzcat.
   static Array<T>
   cat (int dim, octave_idx_type n, const Array<T> *array_list);
 
   template <class U, class F>
   Array<U>
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -3234,16 +3234,33 @@ Matrix ComplexMatrix::abs (void) const
 }
 
 ComplexMatrix
 ComplexMatrix::diag (octave_idx_type k) const
 {
   return MArray<Complex>::diag (k);
 }
 
+ComplexDiagMatrix
+ComplexMatrix::diag (octave_idx_type m, octave_idx_type n) const
+{
+  ComplexDiagMatrix retval;
+
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  if (nr == 1 || nc == 1)
+    retval = ComplexDiagMatrix (*this, m, n);
+  else
+    (*current_liboctave_error_handler)
+      ("diag: expecting vector argument");
+
+  return retval;
+}
+
 bool
 ComplexMatrix::row_is_real_only (octave_idx_type i) const
 {
   bool retval = true;
 
   octave_idx_type nc = columns ();
 
   for (octave_idx_type j = 0; j < nc; j++)
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -352,16 +352,18 @@ public:
   ComplexMatrix cumsum (int dim = -1) const;
   ComplexMatrix prod (int dim = -1) const;
   ComplexMatrix sum (int dim = -1) const;
   ComplexMatrix sumsq (int dim = -1) const;
   Matrix abs (void) const;
 
   ComplexMatrix diag (octave_idx_type k = 0) const;
 
+  ComplexDiagMatrix diag (octave_idx_type m, octave_idx_type n) const;
+
   bool row_is_real_only (octave_idx_type) const;
   bool column_is_real_only (octave_idx_type) const;
 
   ComplexColumnVector row_min (void) const;
   ComplexColumnVector row_max (void) const;
 
   ComplexColumnVector row_min (Array<octave_idx_type>& index) const;
   ComplexColumnVector row_max (Array<octave_idx_type>& index) const;
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -857,16 +857,22 @@ ComplexNDArray::compute_index (Array<oct
 }
 
 ComplexNDArray
 ComplexNDArray::diag (octave_idx_type k) const
 {
   return MArray<Complex>::diag (k);
 }
 
+ComplexNDArray
+ComplexNDArray::diag (octave_idx_type m, octave_idx_type n) const
+{
+  return MArray<Complex>::diag (m, n);
+}
+
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const ComplexNDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -137,16 +137,18 @@ public:
 
   static Complex resize_fill_value (void) { return Complex (0.0, 0.0); }
 
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (double& max_val, double& min_val) const;
 
   ComplexNDArray diag (octave_idx_type k = 0) const;
 
+  ComplexNDArray diag (octave_idx_type m, octave_idx_type n) const;
+
   ComplexNDArray& changesign (void)
     {
       MArray<Complex>::changesign ();
       return *this;
     }
 
 };
 
diff --git a/liboctave/boolNDArray.cc b/liboctave/boolNDArray.cc
--- a/liboctave/boolNDArray.cc
+++ b/liboctave/boolNDArray.cc
@@ -129,16 +129,22 @@ boolNDArray::compute_index (Array<octave
 }
 
 boolNDArray
 boolNDArray::diag (octave_idx_type k) const
 {
   return Array<bool>::diag (k);
 }
 
+boolNDArray
+boolNDArray::diag (octave_idx_type m, octave_idx_type n) const
+{
+  return Array<bool>::diag (m, n);
+}
+
 NDND_BOOL_OPS (boolNDArray, boolNDArray)
 NDND_CMP_OPS (boolNDArray, boolNDArray)
 
 NDS_BOOL_OPS (boolNDArray, bool)
 NDS_CMP_OPS (boolNDArray, bool)
 
 SND_BOOL_OPS (bool, boolNDArray)
 SND_CMP_OPS (bool, boolNDArray)
diff --git a/liboctave/boolNDArray.h b/liboctave/boolNDArray.h
--- a/liboctave/boolNDArray.h
+++ b/liboctave/boolNDArray.h
@@ -98,16 +98,17 @@ public:
 
   static bool resize_fill_value (void) { return false; }
 
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (double& max_val, double& min_val) const;
 
   boolNDArray diag (octave_idx_type k = 0) const;
 
+  boolNDArray diag (octave_idx_type m, octave_idx_type n) const;
 };
 
 NDND_BOOL_OP_DECLS (boolNDArray, boolNDArray, OCTAVE_API)
 NDND_CMP_OP_DECLS (boolNDArray, boolNDArray, OCTAVE_API)
 
 NDS_BOOL_OP_DECLS (boolNDArray, bool, OCTAVE_API)
 NDS_CMP_OP_DECLS (boolNDArray, bool, OCTAVE_API)
 
diff --git a/liboctave/chNDArray.cc b/liboctave/chNDArray.cc
--- a/liboctave/chNDArray.cc
+++ b/liboctave/chNDArray.cc
@@ -128,16 +128,22 @@ charNDArray::compute_index (Array<octave
 }
 
 charNDArray
 charNDArray::diag (octave_idx_type k) const
 {
   return Array<char>::diag (k);
 }
 
+charNDArray
+charNDArray::diag (octave_idx_type m, octave_idx_type n) const
+{
+  return Array<char>::diag (m, n);
+}
+
 NDS_CMP_OPS (charNDArray, char)
 NDS_BOOL_OPS (charNDArray, char)
 
 SND_CMP_OPS (char, charNDArray)
 SND_BOOL_OPS (char, charNDArray)
 
 NDND_CMP_OPS (charNDArray, charNDArray)
 NDND_BOOL_OPS (charNDArray, charNDArray)
diff --git a/liboctave/chNDArray.h b/liboctave/chNDArray.h
--- a/liboctave/chNDArray.h
+++ b/liboctave/chNDArray.h
@@ -91,16 +91,17 @@ public:
 
   // friend std::ostream& operator << (std::ostream& os, const charNDArray& a);
   // friend std::istream& operator >> (std::istream& is, charNDArray& a);
 
   static char resize_fill_value (void) { return '\0'; }
 
   charNDArray diag (octave_idx_type k = 0) const;
 
+  charNDArray diag (octave_idx_type m, octave_idx_type n) const;
 };
 
 NDS_CMP_OP_DECLS (charNDArray, char, OCTAVE_API)
 NDS_BOOL_OP_DECLS (charNDArray, char, OCTAVE_API)
 
 SND_CMP_OP_DECLS (char, charNDArray, OCTAVE_API)
 SND_BOOL_OP_DECLS (char, charNDArray, OCTAVE_API)
 
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -2778,16 +2778,33 @@ Matrix::abs (void) const
 }
 
 Matrix
 Matrix::diag (octave_idx_type k) const
 {
   return MArray<double>::diag (k);
 }
 
+DiagMatrix
+Matrix::diag (octave_idx_type m, octave_idx_type n) const
+{
+  DiagMatrix retval;
+
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  if (nr == 1 || nc == 1)
+    retval = DiagMatrix (*this, m, n);
+  else
+    (*current_liboctave_error_handler)
+      ("diag: expecting vector argument");
+
+  return retval;
+}
+
 ColumnVector
 Matrix::row_min (void) const
 {
   Array<octave_idx_type> dummy_idx;
   return row_min (dummy_idx);
 }
 
 ColumnVector
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -311,16 +311,18 @@ public:
   Matrix cumsum (int dim = -1) const;
   Matrix prod (int dim = -1) const;
   Matrix sum (int dim = -1) const;
   Matrix sumsq (int dim = -1) const;
   Matrix abs (void) const;
 
   Matrix diag (octave_idx_type k = 0) const;
 
+  DiagMatrix diag (octave_idx_type m, octave_idx_type n) const;
+
   ColumnVector row_min (void) const;
   ColumnVector row_max (void) const;
 
   ColumnVector row_min (Array<octave_idx_type>& index) const;
   ColumnVector row_max (Array<octave_idx_type>& index) const;
 
   RowVector column_min (void) const;
   RowVector column_max (void) const;
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -872,16 +872,22 @@ NDArray::compute_index (Array<octave_idx
 }
 
 NDArray
 NDArray::diag (octave_idx_type k) const
 {
   return MArray<double>::diag (k);
 }
 
+NDArray
+NDArray::diag (octave_idx_type m, octave_idx_type n) const
+{
+  return MArray<double>::diag (m, n);
+}
+
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const NDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -149,16 +149,18 @@ public:
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const NDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, NDArray& a);
 
   static double resize_fill_value (void) { return 0; }
 
   NDArray diag (octave_idx_type k = 0) const;
 
+  NDArray diag (octave_idx_type m, octave_idx_type n) const;
+
   NDArray& changesign (void)
     {
       MArray<double>::changesign ();
       return *this;
     }
 
 };
 
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -3230,16 +3230,33 @@ FloatMatrix FloatComplexMatrix::abs (voi
 }
 
 FloatComplexMatrix
 FloatComplexMatrix::diag (octave_idx_type k) const
 {
   return MArray<FloatComplex>::diag (k);
 }
 
+FloatComplexDiagMatrix
+FloatComplexMatrix::diag (octave_idx_type m, octave_idx_type n) const
+{
+  FloatComplexDiagMatrix retval;
+
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  if (nr == 1 || nc == 1)
+    retval = FloatComplexDiagMatrix (*this, m, n);
+  else
+    (*current_liboctave_error_handler)
+      ("diag: expecting vector argument");
+
+  return retval;
+}
+
 bool
 FloatComplexMatrix::row_is_real_only (octave_idx_type i) const
 {
   bool retval = true;
 
   octave_idx_type nc = columns ();
 
   for (octave_idx_type j = 0; j < nc; j++)
diff --git a/liboctave/fCMatrix.h b/liboctave/fCMatrix.h
--- a/liboctave/fCMatrix.h
+++ b/liboctave/fCMatrix.h
@@ -357,16 +357,18 @@ public:
   FloatComplexMatrix cumsum (int dim = -1) const;
   FloatComplexMatrix prod (int dim = -1) const;
   FloatComplexMatrix sum (int dim = -1) const;
   FloatComplexMatrix sumsq (int dim = -1) const;
   FloatMatrix abs (void) const;
 
   FloatComplexMatrix diag (octave_idx_type k = 0) const;
 
+  FloatComplexDiagMatrix diag (octave_idx_type m, octave_idx_type n) const;
+
   bool row_is_real_only (octave_idx_type) const;
   bool column_is_real_only (octave_idx_type) const;
 
   FloatComplexColumnVector row_min (void) const;
   FloatComplexColumnVector row_max (void) const;
 
   FloatComplexColumnVector row_min (Array<octave_idx_type>& index) const;
   FloatComplexColumnVector row_max (Array<octave_idx_type>& index) const;
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -854,16 +854,22 @@ FloatComplexNDArray::compute_index (Arra
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::diag (octave_idx_type k) const
 {
   return MArray<FloatComplex>::diag (k);
 }
 
+FloatComplexNDArray
+FloatComplexNDArray::diag (octave_idx_type m, octave_idx_type n) const
+{
+  return MArray<FloatComplex>::diag (m, n);
+}
+
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const FloatComplexNDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
diff --git a/liboctave/fCNDArray.h b/liboctave/fCNDArray.h
--- a/liboctave/fCNDArray.h
+++ b/liboctave/fCNDArray.h
@@ -137,16 +137,18 @@ public:
 
   static FloatComplex resize_fill_value (void) { return FloatComplex (0.0, 0.0); }
 
   //  bool all_elements_are_real (void) const;
   //  bool all_integers (float& max_val, float& min_val) const;
 
   FloatComplexNDArray diag (octave_idx_type k = 0) const;
 
+  FloatComplexNDArray diag (octave_idx_type m, octave_idx_type n) const;
+
   FloatComplexNDArray& changesign (void)
     {
       MArray<FloatComplex>::changesign ();
       return *this;
     }
 
 };
 
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -2778,16 +2778,33 @@ FloatMatrix::abs (void) const
 }
 
 FloatMatrix
 FloatMatrix::diag (octave_idx_type k) const
 {
   return MArray<float>::diag (k);
 }
 
+FloatDiagMatrix
+FloatMatrix::diag (octave_idx_type m, octave_idx_type n) const
+{
+  FloatDiagMatrix retval;
+
+  octave_idx_type nr = rows ();
+  octave_idx_type nc = cols ();
+
+  if (nr == 1 || nc == 1)
+    retval = FloatDiagMatrix (*this, m, n);
+  else
+    (*current_liboctave_error_handler)
+      ("diag: expecting vector argument");
+
+  return retval;
+}
+
 FloatColumnVector
 FloatMatrix::row_min (void) const
 {
   Array<octave_idx_type> dummy_idx;
   return row_min (dummy_idx);
 }
 
 FloatColumnVector
diff --git a/liboctave/fMatrix.h b/liboctave/fMatrix.h
--- a/liboctave/fMatrix.h
+++ b/liboctave/fMatrix.h
@@ -311,16 +311,18 @@ public:
   FloatMatrix cumsum (int dim = -1) const;
   FloatMatrix prod (int dim = -1) const;
   FloatMatrix sum (int dim = -1) const;
   FloatMatrix sumsq (int dim = -1) const;
   FloatMatrix abs (void) const;
 
   FloatMatrix diag (octave_idx_type k = 0) const;
 
+  FloatDiagMatrix diag (octave_idx_type m, octave_idx_type n) const;
+
   FloatColumnVector row_min (void) const;
   FloatColumnVector row_max (void) const;
 
   FloatColumnVector row_min (Array<octave_idx_type>& index) const;
   FloatColumnVector row_max (Array<octave_idx_type>& index) const;
 
   FloatRowVector column_min (void) const;
   FloatRowVector column_max (void) const;
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -832,16 +832,22 @@ FloatNDArray::compute_index (Array<octav
 }
 
 FloatNDArray
 FloatNDArray::diag (octave_idx_type k) const
 {
   return MArray<float>::diag (k);
 }
 
+FloatNDArray
+FloatNDArray::diag (octave_idx_type m, octave_idx_type n) const
+{
+  return MArray<float>::diag (m, n);
+}
+
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const FloatNDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
diff --git a/liboctave/fNDArray.h b/liboctave/fNDArray.h
--- a/liboctave/fNDArray.h
+++ b/liboctave/fNDArray.h
@@ -146,16 +146,18 @@ public:
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatNDArray& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatNDArray& a);
 
   static float resize_fill_value (void) { return 0; }
 
   FloatNDArray diag (octave_idx_type k = 0) const;
 
+  FloatNDArray diag (octave_idx_type m, octave_idx_type n) const;
+
   FloatNDArray& changesign (void)
     {
       MArray<float>::changesign ();
       return *this;
     }
 
 };
 
diff --git a/liboctave/intNDArray.cc b/liboctave/intNDArray.cc
--- a/liboctave/intNDArray.cc
+++ b/liboctave/intNDArray.cc
@@ -64,16 +64,23 @@ intNDArray<T>::any_element_not_one_or_ze
 
 template <class T>
 intNDArray<T>
 intNDArray<T>::diag (octave_idx_type k) const
 {
   return MArray<T>::diag (k);
 }
 
+template <class T>
+intNDArray<T>
+intNDArray<T>::diag (octave_idx_type m, octave_idx_type n) const
+{
+  return MArray<T>::diag (m, n);
+}
+
 // FIXME -- this is not quite the right thing.
 
 template <class T>
 boolNDArray
 intNDArray<T>::all (int dim) const
 {
   return do_mx_red_op<bool, T > (*this, dim, mx_inline_all);
 }
diff --git a/liboctave/intNDArray.h b/liboctave/intNDArray.h
--- a/liboctave/intNDArray.h
+++ b/liboctave/intNDArray.h
@@ -61,16 +61,18 @@ public:
 
   boolNDArray operator ! (void) const;
 
   bool any_element_is_nan (void) const { return false; }
   bool any_element_not_one_or_zero (void) const;
 
   intNDArray diag (octave_idx_type k = 0) const;
 
+  intNDArray diag (octave_idx_type m, octave_idx_type n) const;
+
   intNDArray& changesign (void)
     {
       MArray<T>::changesign ();
       return *this;
     }
 
   // FIXME -- this is not quite the right thing.
 
diff --git a/src/Cell.cc b/src/Cell.cc
--- a/src/Cell.cc
+++ b/src/Cell.cc
@@ -310,8 +310,14 @@ Cell::map (ctype_mapper fcn) const
   return retval;
 }
 
 Cell
 Cell::diag (octave_idx_type k) const
 {
   return Array<octave_value>::diag (k);
 }
+
+Cell
+Cell::diag (octave_idx_type m, octave_idx_type n) const
+{
+  return Array<octave_value>::diag (m, n);
+}
diff --git a/src/Cell.h b/src/Cell.h
--- a/src/Cell.h
+++ b/src/Cell.h
@@ -109,16 +109,18 @@ public:
   // FIXME
   bool any_element_is_nan (void) const { return false; }
   bool is_true (void) const { return false; }
 
   static octave_value resize_fill_value (void) { return Matrix (); }
 
   Cell diag (octave_idx_type k = 0) const;
 
+  Cell diag (octave_idx_type m, octave_idx_type n) const;
+
   Cell xisalnum (void) const { return map (&octave_value::xisalnum); }
   Cell xisalpha (void) const { return map (&octave_value::xisalpha); }
   Cell xisascii (void) const { return map (&octave_value::xisascii); }
   Cell xiscntrl (void) const { return map (&octave_value::xiscntrl); }
   Cell xisdigit (void) const { return map (&octave_value::xisdigit); }
   Cell xisgraph (void) const { return map (&octave_value::xisgraph); }
   Cell xislower (void) const { return map (&octave_value::xislower); }
   Cell xisprint (void) const { return map (&octave_value::xisprint); }
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -1276,21 +1276,24 @@ Given a matrix argument, instead of a ve
       if (error_state)
         error ("diag: invalid argument K");
       else
         retval = args(0).diag(k);
     }
   else if (nargin == 3)
     {
       octave_value arg0 = args(0);
-      if (arg0.ndims () == 2 && (args(0).rows () == 1 || args(0).columns () == 1))
+
+      if (arg0.ndims () == 2 && (arg0.rows () == 1 || arg0.columns () == 1))
         {
-          octave_idx_type m = args(1).int_value (), n = args(2).int_value ();
+          octave_idx_type m = args(1).int_value ();
+          octave_idx_type n = args(2).int_value ();
+
           if (! error_state)
-            retval = arg0.diag ().resize (dim_vector (m, n), true);
+            retval = arg0.diag (m, n);
           else
             error ("diag: invalid dimensions");
         }
       else
         error ("diag: V must be a vector");
     }
   else
     print_usage ();
@@ -1336,17 +1339,25 @@ Given a matrix argument, instead of a ve
 %!assert(diag ([1,2,3], 6, 3), [1 0 0; 0 2 0; 0 0 3; 0 0 0; 0 0 0; 0 0 0])
 
 %% Test input validation
 %!error <Invalid call to diag> diag ()
 %!error <Invalid call to diag> diag (1,2,3,4)
 %!error diag (ones (2), 3, 3)
 %!error diag (1:3, -4, 3)
 
- */
+%!assert (diag (1, 3, 3), diag ([1, 0, 0]))
+%!assert (diag (i, 3, 3), diag ([i, 0, 0]))
+%!assert (diag (single (1), 3, 3), diag ([single(1), 0, 0]))
+%!assert (diag (single (i), 3, 3), diag ([single(i), 0, 0]))
+%!assert (diag ([1, 2], 3, 3), diag ([1, 2, 0]))
+%!assert (diag ([1, 2]*i, 3, 3), diag ([1, 2, 0]*i))
+%!assert (diag (single ([1, 2]), 3, 3), diag (single ([1, 2, 0])))
+%!assert (diag (single ([1, 2]*i), 3, 3), diag (single ([1, 2, 0]*i)))
+*/
 
 DEFUN (prod, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} prod (@var{x})\n\
 @deftypefnx {Built-in Function} {} prod (@var{x}, @var{dim})\n\
 Product of elements along dimension @var{dim}.  If @var{dim} is\n\
 omitted, it defaults to the first non-singleton dimension.\n\
 @seealso{cumprod, sum}\n\
diff --git a/src/ov-base-mat.h b/src/ov-base-mat.h
--- a/src/ov-base-mat.h
+++ b/src/ov-base-mat.h
@@ -118,16 +118,19 @@ public:
   octave_value any (int dim = 0) const { return matrix.any (dim); }
 
   MatrixType matrix_type (void) const { return typ ? *typ : MatrixType (); }
   MatrixType matrix_type (const MatrixType& _typ) const;
 
   octave_value diag (octave_idx_type k = 0) const
     { return octave_value (matrix.diag (k)); }
 
+  octave_value diag (octave_idx_type m, octave_idx_type n) const
+    { return octave_value (matrix.diag (m, n)); }
+
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     { return octave_value (matrix.sort (dim, mode)); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
                      sortmode mode = ASCENDING) const
     { return octave_value (matrix.sort (sidx, dim, mode)); }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
     { return matrix.is_sorted (mode); }
diff --git a/src/ov-base-scalar.cc b/src/ov-base-scalar.cc
--- a/src/ov-base-scalar.cc
+++ b/src/ov-base-scalar.cc
@@ -116,16 +116,23 @@ octave_base_scalar<ST>::reshape (const d
 template <class ST>
 octave_value
 octave_base_scalar<ST>::diag (octave_idx_type k) const
 {
   return Array<ST> (dim_vector (1, 1), scalar).diag (k);
 }
 
 template <class ST>
+octave_value
+octave_base_scalar<ST>::diag (octave_idx_type m, octave_idx_type n) const
+{
+  return Array<ST> (dim_vector (1, 1), scalar).diag (m, n);
+}
+
+template <class ST>
 bool
 octave_base_scalar<ST>::is_true (void) const
 {
   bool retval = false;
 
   if (xisnan (scalar))
     gripe_nan_to_logical_conversion ();
   else
diff --git a/src/ov-base-scalar.h b/src/ov-base-scalar.h
--- a/src/ov-base-scalar.h
+++ b/src/ov-base-scalar.h
@@ -93,16 +93,18 @@ public:
   size_t byte_size (void) const { return sizeof (ST); }
 
   octave_value all (int = 0) const { return (scalar != ST ()); }
 
   octave_value any (int = 0) const { return (scalar != ST ()); }
 
   octave_value diag (octave_idx_type k = 0) const;
 
+  octave_value diag (octave_idx_type m, octave_idx_type n) const;
+
   octave_value sort (octave_idx_type, sortmode) const
     { return octave_value (scalar); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type,
                      sortmode) const
     {
       sidx.resize (dim_vector (1, 1));
       sidx(0) = 0;
       return octave_value (scalar);
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1116,16 +1116,24 @@ octave_value
 octave_base_value::diag (octave_idx_type) const
 {
   gripe_wrong_type_arg ("octave_base_value::diag ()", type_name ());
 
   return octave_value();
 }
 
 octave_value
+octave_base_value::diag (octave_idx_type, octave_idx_type) const
+{
+  gripe_wrong_type_arg ("octave_base_value::diag ()", type_name ());
+
+  return octave_value();
+}
+
+octave_value
 octave_base_value::sort (octave_idx_type, sortmode) const
 {
   gripe_wrong_type_arg ("octave_base_value::sort ()", type_name ());
 
   return octave_value();
 }
 
 octave_value
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -641,16 +641,18 @@ public:
   virtual octave_idx_type *mex_get_ir (void) const { return 0; }
 
   virtual octave_idx_type *mex_get_jc (void) const { return 0; }
 
   virtual mxArray *as_mxArray (void) const;
 
   virtual octave_value diag (octave_idx_type k = 0) const;
 
+  virtual octave_value diag (octave_idx_type m, octave_idx_type n) const;
+
   virtual octave_value sort (octave_idx_type dim = 0,
                              sortmode mode = ASCENDING) const;
   virtual octave_value sort (Array<octave_idx_type> &sidx,
                              octave_idx_type dim = 0,
                              sortmode mode = ASCENDING) const;
 
   virtual sortmode is_sorted (sortmode mode = UNSORTED) const;
 
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -238,16 +238,22 @@ octave_complex::resize (const dim_vector
 
       if (dv.numel ())
         retval(0) = scalar;
 
       return retval;
     }
 }
 
+octave_value
+octave_complex::diag (octave_idx_type m, octave_idx_type n) const
+{
+  return ComplexDiagMatrix (Array<Complex> (dim_vector (1, 1), scalar), m, n);
+}
+
 bool
 octave_complex::save_ascii (std::ostream& os)
 {
   Complex c = complex_value ();
 
   octave_write_complex (os, c);
 
   os << "\n";
diff --git a/src/ov-complex.h b/src/ov-complex.h
--- a/src/ov-complex.h
+++ b/src/ov-complex.h
@@ -158,16 +158,18 @@ public:
     if (xisnan (scalar))
       gripe_nan_to_logical_conversion ();
     else if (warn && scalar != 0.0 && scalar != 1.0)
       gripe_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar != 0.0);
   }
 
+  octave_value diag (octave_idx_type m, octave_idx_type n) const;
+
   void increment (void) { scalar += 1.0; }
 
   void decrement (void) { scalar -= 1.0; }
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -287,16 +287,34 @@ octave_complex_matrix::diag (octave_idx_
       && (matrix.rows () == 1 || matrix.columns () == 1))
     retval = ComplexDiagMatrix (DiagArray2<Complex> (matrix));
   else
     retval = octave_base_matrix<ComplexNDArray>::diag (k);
 
   return retval;
 }
 
+octave_value
+octave_complex_matrix::diag (octave_idx_type m, octave_idx_type n) const
+{
+  octave_value retval;
+
+  if (matrix.ndims () == 2
+      && (matrix.rows () == 1 || matrix.columns () == 1))
+    {
+      ComplexMatrix mat = matrix.matrix_value ();
+
+      retval = mat.diag (m, n);
+    }
+  else
+    error ("diag: expecting vector argument");
+
+  return retval;
+}
+
 bool
 octave_complex_matrix::save_ascii (std::ostream& os)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       ComplexNDArray tmp = complex_array_value ();
 
diff --git a/src/ov-cx-mat.h b/src/ov-cx-mat.h
--- a/src/ov-cx-mat.h
+++ b/src/ov-cx-mat.h
@@ -130,16 +130,18 @@ public:
   charNDArray char_array_value (bool frc_str_conv = false) const;
 
   SparseMatrix sparse_matrix_value (bool = false) const;
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
   octave_value diag (octave_idx_type k = 0) const;
 
+  octave_value diag (octave_idx_type m, octave_idx_type n) const;
+
   void increment (void) { matrix += Complex (1.0); }
 
   void decrement (void) { matrix -= Complex (1.0); }
 
   void changesign (void) { matrix.changesign (); }
 
   bool save_ascii (std::ostream& os);
 
diff --git a/src/ov-float.cc b/src/ov-float.cc
--- a/src/ov-float.cc
+++ b/src/ov-float.cc
@@ -93,16 +93,22 @@ octave_float_scalar::resize (const dim_v
       if (dv.numel ())
         retval(0) = scalar;
 
       return retval;
     }
 }
 
 octave_value
+octave_float_scalar::diag (octave_idx_type m, octave_idx_type n) const
+{
+  return FloatDiagMatrix (Array<float> (dim_vector (1, 1), scalar), m, n);
+}
+
+octave_value
 octave_float_scalar::convert_to_str_internal (bool, bool, char type) const
 {
   octave_value retval;
 
   if (xisnan (scalar))
     gripe_nan_to_character_conversion ();
   else
     {
diff --git a/src/ov-float.h b/src/ov-float.h
--- a/src/ov-float.h
+++ b/src/ov-float.h
@@ -206,16 +206,18 @@ public:
     if (xisnan (scalar))
       gripe_nan_to_logical_conversion ();
     else if (warn && scalar != 0 && scalar != 1)
       gripe_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar);
   }
 
+  octave_value diag (octave_idx_type m, octave_idx_type n) const;
+
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   void increment (void) { ++scalar; }
 
   void decrement (void) { --scalar; }
 
   bool save_ascii (std::ostream& os);
 
diff --git a/src/ov-flt-complex.cc b/src/ov-flt-complex.cc
--- a/src/ov-flt-complex.cc
+++ b/src/ov-flt-complex.cc
@@ -223,16 +223,22 @@ octave_float_complex::resize (const dim_
 
       if (dv.numel ())
         retval(0) = scalar;
 
       return retval;
     }
 }
 
+octave_value
+octave_float_complex::diag (octave_idx_type m, octave_idx_type n) const
+{
+  return FloatComplexDiagMatrix (Array<FloatComplex> (dim_vector (1, 1), scalar), m, n);
+}
+
 bool
 octave_float_complex::save_ascii (std::ostream& os)
 {
   FloatComplex c = float_complex_value ();
 
   octave_write_float_complex (os, c);
 
   os << "\n";
diff --git a/src/ov-flt-complex.h b/src/ov-flt-complex.h
--- a/src/ov-flt-complex.h
+++ b/src/ov-flt-complex.h
@@ -147,16 +147,18 @@ public:
     if (xisnan (scalar))
       gripe_nan_to_logical_conversion ();
     else if (warn && scalar != 0.0f && scalar != 1.0f)
       gripe_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar != 1.0f);
   }
 
+  octave_value diag (octave_idx_type m, octave_idx_type n) const;
+
   void increment (void) { scalar += 1.0; }
 
   void decrement (void) { scalar -= 1.0; }
 
   bool save_ascii (std::ostream& os);
 
   bool load_ascii (std::istream& is);
 
diff --git a/src/ov-flt-cx-mat.cc b/src/ov-flt-cx-mat.cc
--- a/src/ov-flt-cx-mat.cc
+++ b/src/ov-flt-cx-mat.cc
@@ -276,16 +276,34 @@ octave_float_complex_matrix::diag (octav
       && (matrix.rows () == 1 || matrix.columns () == 1))
     retval = FloatComplexDiagMatrix (DiagArray2<FloatComplex> (matrix));
   else
     retval = octave_base_matrix<FloatComplexNDArray>::diag (k);
 
   return retval;
 }
 
+octave_value
+octave_float_complex_matrix::diag (octave_idx_type m, octave_idx_type n) const
+{
+  octave_value retval;
+
+  if (matrix.ndims () == 2
+      && (matrix.rows () == 1 || matrix.columns () == 1))
+    {
+      FloatComplexMatrix mat = matrix.matrix_value ();
+
+      retval = mat.diag (m, n);
+    }
+  else
+    error ("diag: expecting vector argument");
+
+  return retval;
+}
+
 bool
 octave_float_complex_matrix::save_ascii (std::ostream& os)
 {
   dim_vector d = dims ();
   if (d.length () > 2)
     {
       FloatComplexNDArray tmp = complex_array_value ();
 
diff --git a/src/ov-flt-cx-mat.h b/src/ov-flt-cx-mat.h
--- a/src/ov-flt-cx-mat.h
+++ b/src/ov-flt-cx-mat.h
@@ -128,16 +128,18 @@ public:
   charNDArray char_array_value (bool frc_str_conv = false) const;
 
   SparseMatrix sparse_matrix_value (bool = false) const;
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
   octave_value diag (octave_idx_type k = 0) const;
 
+  octave_value diag (octave_idx_type m, octave_idx_type n) const;
+
   void increment (void) { matrix += FloatComplex (1.0); }
 
   void decrement (void) { matrix -= FloatComplex (1.0); }
 
   void changesign (void) { matrix.changesign (); }
 
   bool save_ascii (std::ostream& os);
 
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -259,16 +259,34 @@ octave_float_matrix::diag (octave_idx_ty
     retval = FloatDiagMatrix (DiagArray2<float> (matrix));
   else
     retval = octave_base_matrix<FloatNDArray>::diag (k);
 
   return retval;
 }
 
 octave_value
+octave_float_matrix::diag (octave_idx_type m, octave_idx_type n) const
+{
+  octave_value retval;
+
+  if (matrix.ndims () == 2
+      && (matrix.rows () == 1 || matrix.columns () == 1))
+    {
+      FloatMatrix mat = matrix.matrix_value ();
+
+      retval = mat.diag (m, n);
+    }
+  else
+    error ("diag: expecting vector argument");
+
+  return retval;
+}
+
+octave_value
 octave_float_matrix::convert_to_str_internal (bool, bool, char type) const
 {
   octave_value retval;
   dim_vector dv = dims ();
   octave_idx_type nel = dv.numel ();
 
   charNDArray chm (dv);
 
diff --git a/src/ov-flt-re-mat.h b/src/ov-flt-re-mat.h
--- a/src/ov-flt-re-mat.h
+++ b/src/ov-flt-re-mat.h
@@ -159,16 +159,18 @@ public:
   FloatNDArray float_array_value (bool = false) const { return matrix; }
 
   SparseMatrix sparse_matrix_value (bool = false) const;
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
   octave_value diag (octave_idx_type k = 0) const;
 
+  octave_value diag (octave_idx_type m, octave_idx_type n) const;
+
   // Use matrix_ref here to clear index cache.
   void increment (void) { matrix_ref () += 1.0; }
 
   void decrement (void) { matrix_ref () -= 1.0; }
 
   void changesign (void) { matrix_ref ().changesign (); }
 
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -243,16 +243,23 @@ octave_range::any (int dim) const
 octave_value
 octave_range::diag (octave_idx_type k) const
 {
   return (k == 0
           ? octave_value (DiagMatrix (DiagArray2<double> (range.matrix_value ())))
           : octave_value (range.diag (k)));
 }
 
+octave_value
+octave_range::diag (octave_idx_type m, octave_idx_type n) const
+{
+  Matrix mat = range.matrix_value ();
+
+  return mat.diag (m, n);
+}
 
 bool
 octave_range::is_true (void) const
 {
   bool retval = false;
 
   if (range.nelem () != 0)
     {
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -134,16 +134,18 @@ public:
   bool is_range (void) const { return true; }
 
   octave_value all (int dim = 0) const;
 
   octave_value any (int dim = 0) const;
 
   octave_value diag (octave_idx_type k = 0) const;
 
+  octave_value diag (octave_idx_type m, octave_idx_type n) const;
+
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     { return range.sort (dim, mode); }
 
   octave_value sort (Array<octave_idx_type>& sidx, octave_idx_type dim = 0,
                      sortmode mode = ASCENDING) const
     { return range.sort (sidx, dim, mode); }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -267,16 +267,34 @@ octave_matrix::diag (octave_idx_type k) 
       && (matrix.rows () == 1 || matrix.columns () == 1))
     retval = DiagMatrix (DiagArray2<double> (matrix));
   else
     retval = octave_base_matrix<NDArray>::diag (k);
 
   return retval;
 }
 
+octave_value
+octave_matrix::diag (octave_idx_type m, octave_idx_type n) const
+{
+  octave_value retval;
+
+  if (matrix.ndims () == 2
+      && (matrix.rows () == 1 || matrix.columns () == 1))
+    {
+      Matrix mat = matrix.matrix_value ();
+
+      retval = mat.diag (m, n);
+    }
+  else
+    error ("diag: expecting vector argument");
+
+  return retval;
+}
+
 // We override these two functions to allow reshaping both
 // the matrix and the index cache.
 octave_value
 octave_matrix::reshape (const dim_vector& new_dims) const
 {
   if (idx_cache)
     {
       return new octave_matrix (matrix.reshape (new_dims),
diff --git a/src/ov-re-mat.h b/src/ov-re-mat.h
--- a/src/ov-re-mat.h
+++ b/src/ov-re-mat.h
@@ -173,16 +173,18 @@ public:
   FloatNDArray float_array_value (bool = false) const { return matrix; }
 
   SparseMatrix sparse_matrix_value (bool = false) const;
 
   SparseComplexMatrix sparse_complex_matrix_value (bool = false) const;
 
   octave_value diag (octave_idx_type k = 0) const;
 
+  octave_value diag (octave_idx_type m, octave_idx_type n) const;
+
   octave_value reshape (const dim_vector& new_dims) const;
 
   octave_value squeeze (void) const;
 
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const;
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
                      sortmode mode = ASCENDING) const;
 
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -108,16 +108,22 @@ octave_scalar::resize (const dim_vector&
       if (dv.numel ())
         retval(0) = scalar;
 
       return retval;
     }
 }
 
 octave_value
+octave_scalar::diag (octave_idx_type m, octave_idx_type n) const
+{
+  return DiagMatrix (Array<double> (dim_vector (1, 1), scalar), m, n);
+}
+
+octave_value
 octave_scalar::convert_to_str_internal (bool, bool, char type) const
 {
   octave_value retval;
 
   if (xisnan (scalar))
     gripe_nan_to_character_conversion ();
   else
     {
diff --git a/src/ov-scalar.h b/src/ov-scalar.h
--- a/src/ov-scalar.h
+++ b/src/ov-scalar.h
@@ -207,16 +207,18 @@ public:
     if (xisnan (scalar))
       gripe_nan_to_logical_conversion ();
     else if (warn && scalar != 0 && scalar != 1)
       gripe_logical_conversion ();
 
     return boolNDArray (dim_vector (1, 1), scalar);
   }
 
+  octave_value diag (octave_idx_type m, octave_idx_type n) const;
+
   octave_value convert_to_str_internal (bool pad, bool force, char type) const;
 
   void increment (void) { ++scalar; }
 
   void decrement (void) { --scalar; }
 
   bool save_ascii (std::ostream& os);
 
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -1070,16 +1070,19 @@ public:
 
   octave_idx_type *mex_get_jc (void) const { return rep->mex_get_jc (); }
 
   mxArray *as_mxArray (void) const { return rep->as_mxArray (); }
 
   octave_value diag (octave_idx_type k = 0) const
     { return rep->diag (k); }
 
+  octave_value diag (octave_idx_type m, octave_idx_type n) const
+    { return rep->diag (m, n); }
+
   octave_value sort (octave_idx_type dim = 0, sortmode mode = ASCENDING) const
     { return rep->sort (dim, mode); }
   octave_value sort (Array<octave_idx_type> &sidx, octave_idx_type dim = 0,
                  sortmode mode = ASCENDING) const
     { return rep->sort (sidx, dim, mode); }
 
   sortmode is_sorted (sortmode mode = UNSORTED) const
     { return rep->is_sorted (mode); }
