# HG changeset patch
# User dbateman
# Date 1180904309 0
#      Sun Jun 03 20:58:29 2007 +0000
# Node ID 2aad75fcc93a0ddb39430425a23611c0a701a6a0
# Parent  8c8ef7e4821d765088866b07d7e8008f69854bc1
[project @ 2007-06-03 20:58:28 by dbateman]

diff --git a/ChangeLog b/ChangeLog
--- a/ChangeLog
+++ b/ChangeLog
@@ -1,8 +1,15 @@
+2007-06-03  David Bateman  <dbateman@free.fr>
+
+	* configure.in (AC_CONFIG_FILES): Add src/mxarray.h
+	* examples/mycell.c, examples/mypow2.c, examples/mysparse.c,
+	examples/mystring.c, examples/mystruct.c: Use mwSize and mwIndex,
+	rather than int for indexing to conform to new mex API.
+	
 2007-06-01  John W. Eaton  <jwe@octave.org>
 
 	* configure.in (*-*-darwin*): Fix quoting and construction of
 	MKOCTFILE_DL_LDFLAGS.
 	* mkoctfile.in (DEFAULT_BINDIR, EXEEXT): New substitutions.
 	* Makeconf.in (MKOCTFILE_DL_LDFLAGS): Delete.
 	(do-subst-config-vals): Do configure substitution of
 	MKOCTFILE_DL_LDFLAGS directly here instead of using intermediate
diff --git a/configure.in b/configure.in
--- a/configure.in
+++ b/configure.in
@@ -24,17 +24,17 @@ dnl Copyright (C) 1996, 1997 John W. Eat
 ### Preserve CFLAGS and CXXFLAGS from the environment before doing
 ### anything else because we don't know which macros might call
 ### AC_PROG_CC or AC_PROG_CXX.
 
 EXTERN_CFLAGS="$CFLAGS"
 EXTERN_CXXFLAGS="$CXXFLAGS"
 
 AC_INIT
-AC_REVISION($Revision: 1.562 $)
+AC_REVISION($Revision: 1.563 $)
 AC_PREREQ(2.57)
 AC_CONFIG_SRCDIR([src/octave.cc])
 AC_CONFIG_HEADER(config.h)
 
 OCTAVE_HOST_TYPE
 
 AC_DEFINE(OCTAVE_SOURCE, 1, [Define if this is Octave.])
   
@@ -1982,17 +1982,17 @@ typedef int sig_atomic_t;
 ])
 
 ### Do the substitutions in all the Makefiles.
 
 AC_CONFIG_FILES([Makefile octMakefile Makeconf test/Makefile \
   dlfcn/Makefile doc/Makefile doc/faq/Makefile doc/interpreter/Makefile 
   doc/liboctave/Makefile doc/refcard/Makefile emacs/Makefile \
   examples/Makefile liboctave/Makefile liboctave/oct-types.h \
-  src/Makefile libcruft/Makefile libcruft/Makerules \
+  src/Makefile src/mxarray.h libcruft/Makefile libcruft/Makerules \
   libcruft/amos/Makefile libcruft/blas/Makefile \
   libcruft/daspk/Makefile libcruft/dasrt/Makefile 
   libcruft/dassl/Makefile libcruft/fftpack/Makefile \
   libcruft/lapack/Makefile libcruft/minpack/Makefile \
   libcruft/misc/Makefile libcruft/odepack/Makefile \
   libcruft/ordered-qz/Makefile libcruft/quadpack/Makefile \
   libcruft/ranlib/Makefile libcruft/slatec-fn/Makefile \
   libcruft/slatec-err/Makefile libcruft/villad/Makefile \
diff --git a/doc/ChangeLog b/doc/ChangeLog
--- a/doc/ChangeLog
+++ b/doc/ChangeLog
@@ -1,8 +1,13 @@
+2007-06-03  David Bateman  <dbatemna@free.fr>
+
+	* interpreter/dynamic.txi: Use "mwSize" and "mwIndex" rather than
+	"int" for indexing in mex-files and document them.
+	
 2007-05-30  John W. Eaton  <jwe@octave.org>
 
 	* interpreter/Makefile.in (TEXI2DVICOMMAND, TEXI2PDFCOMMAND):
 	New macros.
 	(octave-a4.pdf, octave-smallbook.pdf): New targets.
 	(FORMATTED, all): Include octave-a4.pdf in list of dependencies.
 	Delete octave.dvi and octave.ps from list.
 	(FORMATTED, all): Use $(PDF_TARGETS).
diff --git a/doc/interpreter/dynamic.txi b/doc/interpreter/dynamic.txi
--- a/doc/interpreter/dynamic.txi
+++ b/doc/interpreter/dynamic.txi
@@ -1300,31 +1300,38 @@ parts of a complex array are stored sepe
 function @code{mxGetPi} that get the imaginary part.  Both of these
 functions are for use only with double precision matrices.  There also
 exists the generic function @code{mxGetData} and @code{mxGetImagData}
 that perform the same operation on all matrix types.  For example
 
 @example
 @group
 mxArray *m;
-int *dims;
+mwSize *dims;
 UINT32_T *pr;
 
-dims = (int *) mxMalloc (2 * sizeof(int));
+dims = (mwSize *) mxMalloc (2 * sizeof(mwSize));
 dims[0] = 2;
 dims[1] = 2;
 m = mxCreateNumericArray (2, dims, mxUINT32_CLASS, mxREAL);
 pr =  = (UINT32_T *) mxGetData (m);
 @end group
 @end example
 
 There are also the functions @code{mxSetPr}, etc, that perform the
 inverse, and set the data of an Array to use the block of memory pointed
 to by the argument of @code{mxSetPr}.
 
+Note the type @code{mwSize} used above, and @code{mwIndex} are defined
+as the native precision of the indexing in Octave on the platform on
+which the mex-file is built. This allows both 32- and 64-bit platforms
+to support mex-files. @code{mwSize} is used to define array dimension
+and maximum number or elements, while @code{mwIndex} is used to define
+indexing into arrays.
+
 An example that demonstration how to work with arbitrary real or complex
 double precision arrays is given by the file @file{mypow2.c} as given
 below.
 
 @examplefile{mypow2.c}
 
 @noindent
 with an example of its use
@@ -1435,22 +1442,22 @@ mxArray *mxCreateStructMatrix (int rows,
 @end example
 
 Accessing the fields of the structure can then be performed with the
 @code{mxGetField} and @code{mxSetField} or alternatively with the
 @code{mxGetFieldByNumber} and @code{mxSetFieldByNumber} functions.
 
 @example
 @group
-mxArray *mxGetField (const mxArray *ptr, int index, const char *key);
+mxArray *mxGetField (const mxArray *ptr, mwIndex index, const char *key);
 mxArray *mxGetFieldByNumber (const mxArray *ptr, 
-                             int index, int key_num);
-void mxSetField (mxArray *ptr, int index, 
+                             mwIndex index, int key_num);
+void mxSetField (mxArray *ptr, mwIndex index, 
                  const char *key, mxArray *val);
-void mxSetFieldByNumber (mxArray *ptr, int index, 
+void mxSetFieldByNumber (mxArray *ptr, mwIndex index, 
                          int key_num, mxArray *val);
 @end group
 @end example
 
 A difference between the oct-file interface to structures and the
 mex-file version is that the functions to operate on structures in
 mex-files directly include an @code{index} over the elements of the
 arrays of elements per @code{field}.  Whereas the oct-file structure
@@ -1505,39 +1512,39 @@ the real and imaginary parts of the matr
 
 The mex-file interface, as well as using @code{mxGetM}, @code{mxGetN},
 @code{mxSetM}, @code{mxSetN}, @code{mxGetPr}, @code{mxGetPi},
 @code{mxSetPr} and @code{mxSetPi}, the mex-file interface supplies the
 functions
 
 @example
 @group
-int *mxGetIr (const mxArray *ptr);
-int *mxGetJc (const mxArray *ptr);
-int mxGetNzmax (const mxArray *ptr);
+mwIndex *mxGetIr (const mxArray *ptr);
+mwIndex *mxGetJc (const mxArray *ptr);
+mwSize mxGetNzmax (const mxArray *ptr);
 
-void mxSetIr (mxArray *ptr, int *ir);
-void mxSetJc (mxArray *ptr, int *jc);
-void mxSetNzmax (mxArray *ptr, int nzmax);
+void mxSetIr (mxArray *ptr, mwIndex *ir);
+void mxSetJc (mxArray *ptr, mwIndex *jc);
+void mxSetNzmax (mxArray *ptr, mwSize nzmax);
 @end group
 @end example
 
 @noindent
 @code{mxGetNzmax} gets the maximum number of elements that can be stored
 in the sparse matrix.  This is not necessarily the number of non-zero
 elements in the sparse matrix.  @code{mxGetJc} returns an array with one
 additional value than the number of columns in the sparse matrix.  The
 difference between consecutive values of the array returned by
 @code{mxGetJc} define the number of non-zero elements in each column of
 the sparse matrix.  Therefore
 
 @example
 @group
-int nz, n;
-int *Jc;
+mwSize nz, n;
+mwIndex *Jc;
 mxArray *m;
 @dots{}
 n = mxGetN (m);
 Jc = mxGetJc (m);
 nz = Jc[n];
 @end group
 @end example
 
diff --git a/examples/mycell.c b/examples/mycell.c
--- a/examples/mycell.c
+++ b/examples/mycell.c
@@ -1,14 +1,15 @@
 #include "mex.h"
 
 void
 mexFunction (int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[])
 {
-  int n, i;
+  mwSize n;
+  mwIndex i;
 
   if (nrhs != 1 || ! mxIsCell (prhs[0]))
     mexErrMsgTxt ("expects cell");
 
   n = mxGetNumberOfElements (prhs[0]);
   n = (n > nlhs ? nlhs : n);
   
   for (i = 0; i < n; i++)
diff --git a/examples/mypow2.c b/examples/mypow2.c
--- a/examples/mypow2.c
+++ b/examples/mypow2.c
@@ -1,14 +1,15 @@
 #include "mex.h"
 
 void
 mexFunction (int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[])
 {
-  int i, n;
+  mwIndex i;
+  mwSize n;
   double *vri, *vro;
   
   if (nrhs != 1 || ! mxIsNumeric (prhs[0]))
     mexErrMsgTxt ("expects matrix");
 
   n = mxGetNumberOfElements (prhs[0]);
   plhs[0] = (mxArray *) mxCreateNumericArray 
     (mxGetNumberOfDimensions (prhs[0]),
diff --git a/examples/mysparse.c b/examples/mysparse.c
--- a/examples/mysparse.c
+++ b/examples/mysparse.c
@@ -1,20 +1,20 @@
 #include "mex.h"
 
 void
 mexFunction (int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
 {
-  int n, m, nz;
+  mwSize n, m, nz;
   mxArray *v;
-  int i;
+  mwIndex i;
   double *pr, *pi;
   double *pr2, *pi2;
-  int *ir, *jc;
-  int *ir2, *jc2;
+  mwIndex *ir, *jc;
+  mwIndex *ir2, *jc2;
   
   if (nrhs != 1 || ! mxIsSparse (prhs[0]))
     mexErrMsgTxt ("expects sparse matrix");
 
   m = mxGetM (prhs [0]);
   n = mxGetN (prhs [0]);
   nz = mxGetNzmax (prhs [0]);
   
diff --git a/examples/mystring.c b/examples/mystring.c
--- a/examples/mystring.c
+++ b/examples/mystring.c
@@ -1,15 +1,16 @@
 #include <string.h>
 #include "mex.h"
 
 void
 mexFunction (int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
 {
-  int i, j, m, n;
+  mwIndex i, j;
+  mwSize m, n;
   mxChar *pi, *po;
 
   if (nrhs != 1 || ! mxIsChar (prhs[0]) || 
       mxGetNumberOfDimensions (prhs[0]) > 2)
     mexErrMsgTxt ("expecting char matrix");
 
   m = mxGetM (prhs[0]);
   n = mxGetN (prhs[0]);
diff --git a/examples/mystruct.c b/examples/mystruct.c
--- a/examples/mystruct.c
+++ b/examples/mystruct.c
@@ -1,14 +1,15 @@
 #include "mex.h"
 
 void
 mexFunction (int nlhs, mxArray* plhs[], int nrhs, const mxArray* prhs[])
 {
-  int i, j;
+  int i;
+  mwIndex j;
   mxArray *v;
   const char *keys[] = { "this", "that" };
 
   if (nrhs != 1 || ! mxIsStruct (prhs[0]))
     mexErrMsgTxt ("expects struct");
 
   for (i = 0; i < mxGetNumberOfFields (prhs[0]); i++)
     for (j = 0; j < mxGetNumberOfElements (prhs[0]); j++)
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,12 @@
+2007-06-03  David Bateman  <dbateman@free.fr>
+
+	* polynomial/spline.m: Add a small tolerance to spline tests.
+
 2007-06-01  David Bateman  <dbateman@free.fr>
 
 	* pkg.m (pkg:is_superuser): Remove function used in one place and
 	incorporate into main pkg function.
 	(pkg:install): Check for existence of files to install before
 	globbing and warn the user if they don't exist.
 
 2007-05-31  David Bateman  <dbateman@free.fr>
diff --git a/scripts/polynomial/spline.m b/scripts/polynomial/spline.m
--- a/scripts/polynomial/spline.m
+++ b/scripts/polynomial/spline.m
@@ -213,27 +213,27 @@ endfunction
 %! xspline = 0:0.1:10; yspline = spline(x,y,xspline);
 %! title("spline fit to points from sin(x)");
 %! plot(xspline,sin(xspline),";original;",...
 %!      xspline,yspline,"-;interpolation;",...
 %!      x,y,"+;interpolation points;");
 %! %--------------------------------------------------------
 %! % confirm that interpolated function matches the original
 
-%!shared x,y
-%! x = [0:10]; y = sin(x);
-%!assert (spline(x,y,x), y);
-%!assert (spline(x,y,x'), y');
-%!assert (spline(x',y',x'), y');
-%!assert (spline(x',y',x), y);
+%!shared x,y,abserr
+%! x = [0:10]; y = sin(x); abserr = 1e-14;
+%!assert (spline(x,y,x), y, abserr);
+%!assert (spline(x,y,x'), y', abserr);
+%!assert (spline(x',y',x'), y', abserr);
+%!assert (spline(x',y',x), y, abserr);
 %!assert (isempty(spline(x',y',[])));
 %!assert (isempty(spline(x,y,[])));
-%!assert (spline(x,[y;y],x), [spline(x,y,x);spline(x,y,x)])
+%!assert (spline(x,[y;y],x), [spline(x,y,x);spline(x,y,x)],abserr)
 %! y = cos(x) + i*sin(x);
-%!assert ( spline(x,y,x), y )
-%!assert ( real(spline(x,y,x)), real(y) );
-%!assert ( real(spline(x,y,x.')), real(y).' );
-%!assert ( real(spline(x.',y.',x.')), real(y).' );
-%!assert ( real(spline(x.',y,x)), real(y) );
-%!assert ( imag(spline(x,y,x)), imag(y) );
-%!assert ( imag(spline(x,y,x.')), imag(y).' );
-%!assert ( imag(spline(x.',y.',x.')), imag(y).' );
-%!assert ( imag(spline(x.',y,x)), imag(y) );
+%!assert (spline(x,y,x), y, abserr)
+%!assert (real(spline(x,y,x)), real(y), abserr);
+%!assert (real(spline(x,y,x.')), real(y).', abserr);
+%!assert (real(spline(x.',y.',x.')), real(y).', abserr);
+%!assert (real(spline(x.',y,x)), real(y), abserr);
+%!assert (imag(spline(x,y,x)), imag(y), abserr);
+%!assert (imag(spline(x,y,x.')), imag(y).', abserr);
+%!assert (imag(spline(x.',y.',x.')), imag(y).', abserr);
+%!assert (imag(spline(x.',y,x)), imag(y), abserr);
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,33 @@
+2007-06-03  David Bateman  <dbateman@free.fr>
+
+	* Makefile.in (DISTFILES): Add mxarray.h.in
+	(install-inc): Modify target so that mxarray.h is installed
+	correctly.
+	(distclean): Remove mxarray.h on distclean.
+	* mex.cc: Use mwSize for dimensions and mwIndex for indexing
+	throughout, with the exception of struct key indexes.
+	* mexproto.h: ditto.
+	* mxarray.h: remove.
+	* mxarray.h.in: Copy here and define mwSize, mwIndex, and use
+	throughout. 
+	* ov-bool-mat.cc (octave_bool_matrix::as_mxArray): Use mwSize and
+	mwIndex.
+	* ov-bool-sparse (octave_sparse_bool_matrix::as_mxArray): ditto.
+	* ov-cell.cc (octave_cell:as_mxArray): ditto.
+	* ov-ch-mat.cc (octave_char_matrix:as_mxArray): ditto.
+	* ov-cx-mat.cc (octave_complex_matrix::as_mxArray): ditto.
+	* ov-cx-sparse.cc (octave_sparse_complex_matrix::as_mxArray): ditto.
+	* ov-int.h (as_mxArray): ditto.
+	* ov-range.cc (octave_range:as_mxArray): ditto.
+	* ov-re-mat.cc (octave_matrix:as_mxArray): ditto.
+	* ov-re-sparse.cc (octave_sparse_matrix::as_mxArray): ditto.
+	* ov-struct.cc (octave_struct::as_mxArray): ditto.
+
 2007-06-02  David Bateman  <dbateman@free.fr>
 
 	* graphics.cc (color_property class): g++ doesn't like anonymous
 	enums. Give type to color_type enum.
 
 2007-05-31  Shai Ayal  <shaiay@users.sourceforge.net>
 
 	* graphics.cc (radio_values, radio_property, color_values):
diff --git a/src/Makefile.in b/src/Makefile.in
--- a/src/Makefile.in
+++ b/src/Makefile.in
@@ -250,17 +250,17 @@ OCTINTERP_LINK_DEPS = \
 OCT_LINK_DEPS = \
   -L../libcruft $(LIBCRUFT) -L../liboctave $(LIBOCTAVE) \
   -L. $(LIBOCTINTERP) $(CHOLMOD_LIBS) $(UMFPACK_LIBS) $(AMD_LIBS) \
    $(CAMD_LIBS) $(COLAMD_LIBS) $(CCOLAMD_LIBS) $(CXSPARSE_LIBS) $(BLAS_LIBS) \
    $(FFTW_LIBS) $(LIBS) $(FLIBS)
 
 DISTFILES = Makefile.in ChangeLog mkdefs mkops mkgendoc \
 	DOCSTRINGS mkbuiltins mk-errno-list mk-pkg-add \
-	defaults.h.in oct-conf.h.in oct-errno.cc.in octave.gperf \
+	defaults.h.in mxarray.h.in oct-conf.h.in oct-errno.cc.in octave.gperf \
 	oct-gperf.h parse.cc lex.cc y.tab.h __gnuplot_raw__.cc \
 	$(INCLUDES) $(DIST_SRC) $(OPT_HANDLERS) $(EXTRAS)
 
 all: octave$(EXEEXT) $(OCT_FILES) PKG_ADD DOCSTRINGS
 .PHONY: all
 
 objects: $(OBJECTS)
 
@@ -433,17 +433,21 @@ install-lib:
 	  fi; \
 	fi
 .PHONY: install-lib
 
 install-inc:
 	$(top_srcdir)/mkinstalldirs $(DESTDIR)$(octincludedir)/octave
 	for f in $(INCLUDES_FOR_INSTALL); do \
 	  rm -f $(DESTDIR)$(octincludedir)/octave/$$f; \
-	  $(INSTALL_DATA) $(srcdir)/$$f $(DESTDIR)$(octincludedir)/octave/$$f; \
+	  if [ -f $$f ]; then \
+	    $(INSTALL_DATA) $$f $(DESTDIR)$(octincludedir)/octave/$$f; \
+	  else \
+	    $(INSTALL_DATA) $(srcdir)/$$f $(DESTDIR)$(octincludedir)/octave/$$f; \
+	  fi ; \
 	done
 	for f in defaults.h oct-conf.h oct-gperf.h; do \
 	  rm -f $(DESTDIR)$(octincludedir)/octave/$$f; \
 	  if [ -f $$f ]; then \
 	    $(INSTALL_DATA) $$f $(DESTDIR)$(octincludedir)/octave/$$f ; \
 	  else \
 	    $(INSTALL_DATA) $(srcdir)/$$f $(DESTDIR)$(octincludedir)/octave/$$f ; \
 	  fi ; \
@@ -493,17 +497,17 @@ clean:
 .PHONY: clean
 
 mostlyclean: clean
 .PHONY: mostlyclean
 
 distclean: clean
 	rm -f Makefile octave$(EXEEXT) .fname so_locations oct-errno.cc
 	rm -f stamp-prereq stamp-liboctave-prereq
-	rm -f doc-files gendoc.cc DOCSTRINGS
+	rm -f doc-files gendoc.cc mxarray.h DOCSTRINGS
 .PHONY: distclean
 
 maintainer-clean: distclean
 	rm -f tags TAGS y.tab.c y.tab.h y.output yy.lex.c lex.cc parse.cc
 	rm -f oct-gperf.h __gnuplot_raw__.cc $(OPT_HANDLERS)
 .PHONY: maintainer-clean
 
 dist: parse.cc lex.cc oct-gperf.h
diff --git a/src/mex.cc b/src/mex.cc
--- a/src/mex.cc
+++ b/src/mex.cc
@@ -146,91 +146,91 @@ public:
 
   int is_logical_scalar (void) const
   {
     return is_logical () && get_number_of_elements () == 1;
   }
 
   int is_logical_scalar_true (void) const = 0;
 
-  int get_m (void) const = 0;
-
-  int get_n (void) const = 0;
-
-  int *get_dimensions (void) const = 0;
-
-  int get_number_of_dimensions (void) const = 0;
-
-  void set_m (int m) = 0;
-
-  void set_n (int n) = 0;
-
-  void set_dimensions (int *dims_arg, int ndims_arg) = 0;
-
-  int get_number_of_elements (void) const = 0;
+  mwSize get_m (void) const = 0;
+
+  mwSize get_n (void) const = 0;
+
+  mwSize *get_dimensions (void) const = 0;
+
+  mwSize get_number_of_dimensions (void) const = 0;
+
+  void set_m (mwSize m) = 0;
+
+  void set_n (mwSize n) = 0;
+
+  void set_dimensions (mwSize *dims_arg, mwSize ndims_arg) = 0;
+
+  mwSize get_number_of_elements (void) const = 0;
 
   int is_empty (void) const = 0;
 
   mxClassID get_class_id (void) const = 0;
 
   const char *get_class_name (void) const = 0;
 
   void set_class_name (const char *name_arg) = 0;
 
-  mxArray *get_cell (int /*idx*/) const
+  mxArray *get_cell (mwIndex /*idx*/) const
   {
     invalid_type_error ();
     return 0;
   }
 
-  void set_cell (int idx, mxArray *val) = 0;
+  void set_cell (mwIndex idx, mxArray *val) = 0;
 
   double get_scalar (void) const = 0;
 
   void *get_data (void) const = 0;
 
   void *get_imag_data (void) const = 0;
 
   void set_data (void *pr) = 0;
 
   void set_imag_data (void *pi) = 0;
 
-  int *get_ir (void) const = 0;
-
-  int *get_jc (void) const = 0;
-
-  int get_nzmax (void) const = 0;
-
-  void set_ir (int *ir) = 0;
-
-  void set_jc (int *jc) = 0;
-
-  void set_nzmax (int nzmax) = 0;
+  mwIndex *get_ir (void) const = 0;
+
+  mwIndex *get_jc (void) const = 0;
+
+  mwSize get_nzmax (void) const = 0;
+
+  void set_ir (mwIndex *ir) = 0;
+
+  void set_jc (mwIndex *jc) = 0;
+
+  void set_nzmax (mwSize nzmax) = 0;
 
   int add_field (const char *key) = 0;
 
   void remove_field (int key_num) = 0;
 
-  mxArray *get_field_by_number (int index, int key_num) const = 0;
-
-  void set_field_by_number (int index, int key_num, mxArray *val) = 0;
+  mxArray *get_field_by_number (mwIndex index, int key_num) const = 0;
+
+  void set_field_by_number (mwIndex index, int key_num, mxArray *val) = 0;
 
   int get_number_of_fields (void) const = 0;
 
   const char *get_field_name_by_number (int key_num) const = 0;
 
   int get_field_number (const char *key) const = 0;
 
-  int get_string (char *buf, int buflen) const = 0;
+  int get_string (char *buf, mwSize buflen) const = 0;
 
   char *array_to_string (void) const = 0;
 
-  int calc_single_subscript (int nsubs, int *subs) const = 0;
-
-  int get_element_size (void) const = 0;
+  mwIndex calc_single_subscript (mwSize nsubs, mwIndex *subs) const = 0;
+
+  size_t get_element_size (void) const = 0;
 
   bool mutation_needed (void) const { return false; }
 
   mxArray *mutate (void) const { return 0; }
 
 protected:
 
   octave_value as_octave_value (void) const = 0;
@@ -316,66 +316,66 @@ public:
 
   int is_real_type (void) const { return val.is_real_type (); }
 
   int is_logical_scalar_true (void) const
   {
     return (is_logical_scalar () && val.is_true ());
   }
 
-  int get_m (void) const { return val.rows (); }
-
-  int get_n (void) const 
+  mwSize get_m (void) const { return val.rows (); }
+
+  mwSize get_n (void) const 
   {
-    int n = 1;
+    mwSize n = 1;
 
     // Force dims and ndims to be cached.
     get_dimensions();
 
-    for (int i = ndims - 1; i > 0; i--)
+    for (mwIndex i = ndims - 1; i > 0; i--)
       n *= dims[i];
 
     return n;
   }
 
-  int *get_dimensions (void) const
+  mwSize *get_dimensions (void) const
   {
     if (! dims)
       {
 	ndims = val.ndims ();
 
-	dims = static_cast<int *> (malloc (ndims * sizeof (int)));
+	dims = static_cast<mwSize *> (malloc (ndims * sizeof (mwSize)));
 
 	dim_vector dv = val.dims ();
 
-	for (int i = 0; i < ndims; i++)
+	for (mwIndex i = 0; i < ndims; i++)
 	  dims[i] = dv(i);
       }
 
     return dims;
   }
 
-  int get_number_of_dimensions (void) const
+  mwSize get_number_of_dimensions (void) const
   {
     // Force dims and ndims to be cached.
     get_dimensions ();
 
     return ndims;
   }
 
-  void set_m (int /*m*/) { request_mutation (); }
-
-  void set_n (int /*n*/) { request_mutation (); }
-
-  void set_dimensions (int */*dims_arg*/, int /*ndims_arg*/)
+  void set_m (mwSize /*m*/) { request_mutation (); }
+
+  void set_n (mwSize /*n*/) { request_mutation (); }
+
+  void set_dimensions (mwSize */*dims_arg*/, mwSize /*ndims_arg*/)
   {
     request_mutation ();
   }
 
-  int get_number_of_elements (void) const { return val.numel (); }
+  mwSize get_number_of_elements (void) const { return val.numel (); }
 
   int is_empty (void) const { return val.is_empty (); }
 
   mxClassID get_class_id (void) const
   {
     id = mxUNKNOWN_CLASS;
 
     std::string cn = val.class_name ();
@@ -430,24 +430,24 @@ public:
       }
 
     return class_name;
   }
 
   // Not allowed.
   void set_class_name (const char */*name_arg*/) { request_mutation (); }
 
-  mxArray *get_cell (int /*idx*/) const
+  mxArray *get_cell (mwIndex /*idx*/) const
   {
     request_mutation ();
     return 0;
   }
 
   // Not allowed.
-  void set_cell (int /*idx*/, mxArray */*val*/) { request_mutation (); }
+  void set_cell (mwIndex /*idx*/, mxArray */*val*/) { request_mutation (); }
 
   double get_scalar (void) const { return val.scalar_value (true); }
 
   void *get_data (void) const
   {
     void *retval = 0;
 
     if (is_char ()
@@ -472,65 +472,55 @@ public:
   }
 
   // Not allowed.
   void set_data (void */*pr*/) { request_mutation (); }
 
   // Not allowed.
   void set_imag_data (void */*pi*/) { request_mutation (); }
 
-  int *get_ir (void) const
+  mwIndex *get_ir (void) const
   {
-#if SIZEOF_OCTAVE_IDX_TYPE == SIZEOF_INT
     return val.mex_get_ir ();
-#else
-    request_mutation ();
-    return 0;
-#endif
   }
 
-  int *get_jc (void) const
+  mwIndex *get_jc (void) const
   {
-#if SIZEOF_OCTAVE_IDX_TYPE == SIZEOF_INT
     return val.mex_get_jc ();
-#else
-    request_mutation ();
-    return 0;
-#endif
   }
 
-  int get_nzmax (void) const { return val.nzmax (); }
+  mwSize get_nzmax (void) const { return val.nzmax (); }
 
   // Not allowed.
-  void set_ir (int */*ir*/) { request_mutation (); }
+  void set_ir (mwIndex */*ir*/) { request_mutation (); }
 
   // Not allowed.
-  void set_jc (int */*jc*/) { request_mutation (); }
+  void set_jc (mwIndex */*jc*/) { request_mutation (); }
 
   // Not allowed.
-  void set_nzmax (int /*nzmax*/) { request_mutation (); }
+  void set_nzmax (mwSize /*nzmax*/) { request_mutation (); }
 
   // Not allowed.
   int add_field (const char */*key*/)
   {
     request_mutation ();
     return 0;
   }
 
   // Not allowed.
   void remove_field (int /*key_num*/) { request_mutation (); }
 
-  mxArray *get_field_by_number (int /*index*/, int /*key_num*/) const
+  mxArray *get_field_by_number (mwIndex /*index*/, int /*key_num*/) const
   {
     request_mutation ();
     return 0;
   }
 
   // Not allowed.
-  void set_field_by_number (int /*index*/, int /*key_num*/, mxArray */*val*/)
+  void set_field_by_number (mwIndex /*index*/, int /*key_num*/, mxArray */*val*/)
   {
     request_mutation ();
   }
 
   int get_number_of_fields (void) const { return val.nfields (); }
 
   const char *get_field_name_by_number (int /*key_num*/) const
   {
@@ -539,29 +529,29 @@ public:
   }
 
   int get_field_number (const char */*key*/) const
   {
     request_mutation ();
     return 0;
   }
 
-  int get_string (char *buf, int buflen) const
+  int get_string (char *buf, mwSize buflen) const
   {
     int retval = 1;
 
-    int nel = get_number_of_elements ();
+    mwSize nel = get_number_of_elements ();
 
     if (val.is_string () && nel < buflen)
       {
 	charNDArray tmp = val.char_array_value ();
 
 	const char *p = tmp.data ();
 
-	for (int i = 0; i < nel; i++)
+	for (mwIndex i = 0; i < nel; i++)
 	  buf[i] = p[i];
 
 	buf[nel] = 0;
 
 	retval = 0;
       }
 
     return retval;
@@ -571,52 +561,52 @@ public:
   {
     // FIXME -- this is suposed to handle multi-byte character
     // strings.
 
     char *buf = 0;
 
     if (val.is_string ())
       {
-	int nel = get_number_of_elements ();
+	mwSize nel = get_number_of_elements ();
 
 	buf = static_cast<char *> (malloc (nel + 1));
 
 	if (buf)
 	  {
 	    charNDArray tmp = val.char_array_value ();
 
 	    const char *p = tmp.data ();
 
-	    for (int i = 0; i < nel; i++)
+	    for (mwIndex i = 0; i < nel; i++)
 	      buf[i] = p[i];
 
 	    buf[nel] = '\0';
 	  }
       }
 
     return buf;
   }
 
-  int calc_single_subscript (int nsubs, int *subs) const
+  mwIndex calc_single_subscript (mwSize nsubs, mwIndex *subs) const
   {
-    int retval = 0;
+    mwIndex retval = 0;
 
     // Force ndims, dims to be cached.
     get_dimensions ();
 
-    int n = nsubs <= ndims ? nsubs : ndims;
+    mwIndex n = nsubs <= ndims ? nsubs : ndims;
 
     while (--n > 0)
       retval = retval * dims[n] + subs[n];
 
     return retval;
   }
 
-  int get_element_size (void) const
+  size_t get_element_size (void) const
   {
     // Force id to be cached.
     get_class_id ();
 
     switch (id)
       {
       case mxCELL_CLASS: return sizeof (mxArray *);
       case mxSTRUCT_CLASS: return sizeof (mxArray *);
@@ -651,94 +641,94 @@ public:
 
 protected:
 
   octave_value as_octave_value (void) const { return val; }
 
   mxArray_octave_value (const mxArray_octave_value& arg)
     : mxArray_base (arg), val (arg.val), mutate_flag (arg.mutate_flag),
       id (arg.id), class_name (strsave (arg.class_name)), ndims (arg.ndims),
-      dims (ndims > 0 ? static_cast<int *> (malloc (ndims * sizeof (int))) : 0)
+      dims (ndims > 0 ? static_cast<mwSize *> (malloc (ndims * sizeof (mwSize))) : 0)
   {
     if (dims)
       {
-	for (int i = 0; i < ndims; i++)
+	for (mwIndex i = 0; i < ndims; i++)
 	  dims[i] = arg.dims[i];
       }
   }
 
 private:
 
   octave_value val;
 
   mutable bool mutate_flag;
 
   // Caching these does not cost much or lead to much duplicated
   // code.  For other things, we just request mutation to a
   // Matlab-style mxArray object.
 
   mutable mxClassID id;
   mutable char *class_name;
-  mutable int ndims;
-  mutable int *dims;
+  mutable mwSize ndims;
+  mutable mwSize *dims;
 };
 
 // The base class for the Matlab-style representation, used to handle
 // things that are common to all Matlab-style objects.
 
 class mxArray_matlab : public mxArray_base
 {
 protected:
 
   mxArray_matlab (mxClassID id_arg = mxUNKNOWN_CLASS)
     : mxArray_base (), class_name (0), id (id_arg), ndims (0), dims (0) { }
 
-  mxArray_matlab (mxClassID id_arg, int ndims_arg, const int *dims_arg)
+  mxArray_matlab (mxClassID id_arg, mwSize ndims_arg, const mwSize *dims_arg)
     : mxArray_base (), class_name (0), id (id_arg),
       ndims (ndims_arg < 2 ? 2 : ndims_arg),
-      dims (static_cast<int *> (malloc (ndims * sizeof (int))))
+      dims (static_cast<mwSize *> (malloc (ndims * sizeof (mwSize))))
   {
     if (ndims_arg < 2)
       {
 	dims[0] = 1;
 	dims[1] = 1;
       }
 
-    for (int i = 0; i < ndims_arg; i++)
+    for (mwIndex i = 0; i < ndims_arg; i++)
       dims[i] = dims_arg[i];
 
-    for (int i = ndims - 1; i > 1; i--)
+    for (mwIndex i = ndims - 1; i > 1; i--)
       {
 	if (dims[i] == 1)
 	  ndims--;
 	else
 	  break;
       }
   }
 
   mxArray_matlab (mxClassID id_arg, const dim_vector& dv)
     : mxArray_base (), class_name (0), id (id_arg),
       ndims (dv.length ()),
-      dims (static_cast<int *> (malloc (ndims * sizeof (int))))
+      dims (static_cast<mwSize *> (malloc (ndims * sizeof (mwSize))))
   {
-    for (int i = 0; i < ndims; i++)
+    for (mwIndex i = 0; i < ndims; i++)
       dims[i] = dv(i);
 
-    for (int i = ndims - 1; i > 1; i--)
+    for (mwIndex i = ndims - 1; i > 1; i--)
       {
 	if (dims[i] == 1)
 	  ndims--;
 	else
 	  break;
       }
   }
 
-  mxArray_matlab (mxClassID id_arg, int m, int n)
+  mxArray_matlab (mxClassID id_arg, mwSize m, mwSize n)
     : mxArray_base (), class_name (0), id (id_arg), ndims (2),
-      dims (static_cast<int *> (malloc (ndims * sizeof (int))))
+      dims (static_cast<mwSize *> (malloc (ndims * sizeof (mwSize))))
   {
     dims[0] = m;
     dims[1] = n;
   }
 
 public:
 
   ~mxArray_matlab (void)
@@ -789,47 +779,47 @@ public:
   int is_uint8 (void) const { return id == mxUINT8_CLASS; }
 
   int is_logical_scalar_true (void) const
   {
     return (is_logical_scalar ()
 	    && static_cast<mxLogical *> (get_data ())[0] != 0);
   }
 
-  int get_m (void) const { return dims[0]; }
-
-  int get_n (void) const
+  mwSize get_m (void) const { return dims[0]; }
+
+  mwSize get_n (void) const
   {
-    int n = 1;
-
-    for (int i = ndims - 1 ; i > 0 ; i--)
+    mwSize n = 1;
+
+    for (mwSize i = ndims - 1 ; i > 0 ; i--)
       n *= dims[i];
 
     return n;
   }
 
-  int *get_dimensions (void) const { return dims; }
-
-  int get_number_of_dimensions (void) const { return ndims; }
-
-  void set_m (int m) { dims[0] = m; }
-
-  void set_n (int n) { dims[1] = n; }
-
-  void set_dimensions (int *dims_arg, int ndims_arg)
+  mwSize *get_dimensions (void) const { return dims; }
+
+  mwSize get_number_of_dimensions (void) const { return ndims; }
+
+  void set_m (mwSize m) { dims[0] = m; }
+
+  void set_n (mwSize n) { dims[1] = n; }
+
+  void set_dimensions (mwSize *dims_arg, mwSize ndims_arg)
   {
     dims = dims_arg;
     ndims = ndims_arg;
   }
 
-  int get_number_of_elements (void) const
+  mwSize get_number_of_elements (void) const
   {
-    int retval = dims[0];
-
-    for (int i = 1; i < ndims; i++)
+    mwSize retval = dims[0];
+
+    for (mwIndex i = 1; i < ndims; i++)
       retval *= dims[i];
 
     return retval;
   }
 
   int is_empty (void) const { return get_number_of_elements () == 0; }
 
   mxClassID get_class_id (void) const { return id; }
@@ -859,23 +849,23 @@ public:
 
   void set_class_name (const char *name_arg)
   {
     mxFree (class_name);
     class_name = static_cast<char *> (malloc (strlen (name_arg) + 1));
     strcpy (class_name, name_arg);
   }
 
-  mxArray *get_cell (int /*idx*/) const
+  mxArray *get_cell (mwIndex /*idx*/) const
   {
     invalid_type_error ();
     return 0;
   }
 
-  void set_cell (int /*idx*/, mxArray */*val*/)
+  void set_cell (mwIndex /*idx*/, mxArray */*val*/)
   {
     invalid_type_error ();
   }
 
   double get_scalar (void) const
   {
     invalid_type_error ();
     return 0;
@@ -898,67 +888,67 @@ public:
     invalid_type_error ();
   }
 
   void set_imag_data (void */*pi*/)
   {
     invalid_type_error ();
   }
 
-  int *get_ir (void) const
+  mwIndex *get_ir (void) const
   {
     invalid_type_error ();
     return 0;
   }
 
-  int *get_jc (void) const
+  mwIndex *get_jc (void) const
   {
     invalid_type_error ();
     return 0;
   }
 
-  int get_nzmax (void) const
+  mwSize get_nzmax (void) const
   {
     invalid_type_error ();
     return 0;
   }
 
-  void set_ir (int */*ir*/)
+  void set_ir (mwIndex */*ir*/)
   {
     invalid_type_error ();
   }
 
-  void set_jc (int */*jc*/)
+  void set_jc (mwIndex */*jc*/)
   {
     invalid_type_error ();
   }
 
-  void set_nzmax (int /*nzmax*/)
+  void set_nzmax (mwSize /*nzmax*/)
   {
     invalid_type_error ();
   }
 
   int add_field (const char */*key*/)
   {
     invalid_type_error ();
     return -1;
   }
 
   void remove_field (int /*key_num*/)
   {
     invalid_type_error ();
   }
 
-  mxArray *get_field_by_number (int /*index*/, int /*key_num*/) const
+  mxArray *get_field_by_number (mwIndex /*index*/, int /*key_num*/) const
   {
     invalid_type_error ();
     return 0;
   }
 
-  void set_field_by_number (int /*index*/, int /*key_num*/, mxArray */*val*/)
+  void set_field_by_number (mwIndex /*index*/, int /*key_num*/, mxArray */*val*/)
   {
     invalid_type_error ();
   }
 
   int get_number_of_fields (void) const
   {
     invalid_type_error ();
     return 0;
@@ -970,41 +960,41 @@ public:
     return 0;
   }
 
   int get_field_number (const char */*key*/) const
   {
     return -1;
   }
 
-  int get_string (char */*buf*/, int /*buflen*/) const
+  int get_string (char */*buf*/, mwSize /*buflen*/) const
   {
     invalid_type_error ();
     return 0;
   }
 
   char *array_to_string (void) const
   {
     invalid_type_error ();
     return 0;
   }
 
-  int calc_single_subscript (int nsubs, int *subs) const
+  mwIndex calc_single_subscript (mwSize nsubs, mwIndex *subs) const
   {
-    int retval = 0;
-
-    int n = nsubs <= ndims ? nsubs : ndims;
+    mwIndex retval = 0;
+
+    mwSize n = nsubs <= ndims ? nsubs : ndims;
 
     while (--n > 0)
       retval = retval * dims[n] + subs[n];
 
     return retval;
   }
 
-  int get_element_size (void) const
+  size_t get_element_size (void) const
   {
     switch (id)
       {
       case mxCELL_CLASS: return sizeof (mxArray *);
       case mxSTRUCT_CLASS: return sizeof (mxArray *);
       case mxLOGICAL_CLASS: return sizeof (mxLogical);
       case mxCHAR_CLASS: return sizeof (mxChar);
       case mxDOUBLE_CLASS: return sizeof (double);
@@ -1022,72 +1012,72 @@ public:
       }    
   }
 
 protected:
 
   mxArray_matlab (const mxArray_matlab& val)
     : mxArray_base (val), class_name (strsave (val.class_name)),
       id (val.id), ndims (val.ndims),
-      dims (static_cast<int *> (malloc (ndims * sizeof (int))))
+      dims (static_cast<mwSize *> (malloc (ndims * sizeof (mwSize))))
   {
-    for (int i = 0; i < ndims; i++)
+    for (mwIndex i = 0; i < ndims; i++)
       dims[i] = val.dims[i];
   }
 
   dim_vector
   dims_to_dim_vector (void) const
   {
-    int nd = get_number_of_dimensions ();
-
-    int *d = get_dimensions ();
+    mwSize nd = get_number_of_dimensions ();
+
+    mwSize *d = get_dimensions ();
 
     dim_vector dv;
     dv.resize (nd);
 
-    for (int i = 0; i < nd; i++)
+    for (mwIndex i = 0; i < nd; i++)
       dv(i) = d[i];
 
     return dv;
   }
 
 private:
 
   char *class_name;
 
   mxClassID id;
 
-  int ndims;
-  int *dims;
+  mwSize ndims;
+  mwSize *dims;
 
   void invalid_type_error (void) const
   {
     error ("invalid type for operation");
   }
 };
 
 // Matlab-style numeric, character, and logical data.
 
 class mxArray_number : public mxArray_matlab
 {
 public:
 
-  mxArray_number (mxClassID id_arg, int ndims_arg, const int *dims_arg,
+  mxArray_number (mxClassID id_arg, mwSize ndims_arg, const mwSize *dims_arg,
 		  mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, ndims_arg, dims_arg),
       pr (calloc (get_number_of_elements (), get_element_size ())),
       pi (flag == mxCOMPLEX ? calloc (get_number_of_elements (), get_element_size ()) : 0) { }
 
   mxArray_number (mxClassID id_arg, const dim_vector& dv,
 		  mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, dv),
       pr (calloc (get_number_of_elements (), get_element_size ())),
       pi (flag == mxCOMPLEX ? calloc (get_number_of_elements (), get_element_size ()) : 0) { }
 
-  mxArray_number (mxClassID id_arg, int m, int n, mxComplexity flag = mxREAL)
+  mxArray_number (mxClassID id_arg, mwSize m, mwSize n, mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, m, n),
       pr (calloc (get_number_of_elements (), get_element_size ())),
       pi (flag == mxCOMPLEX ? calloc (get_number_of_elements (), get_element_size ()) : 0) { }
 
   mxArray_number (mxClassID id_arg, double val)
     : mxArray_matlab (id_arg, 1, 1),
       pr (calloc (get_number_of_elements (), get_element_size ())),
       pi (0)
@@ -1106,42 +1096,43 @@ public:
   }
 
   mxArray_number (const char *str)
     : mxArray_matlab (mxCHAR_CLASS, 1, strlen (str)),
       pr (calloc (get_number_of_elements (), get_element_size ())),
       pi (0)
   {
     mxChar *cpr = static_cast<mxChar *> (pr);
-    int nel = get_number_of_elements ();
-    for (int i = 0; i < nel; i++)
+    mwSize nel = get_number_of_elements ();
+    for (mwIndex i = 0; i < nel; i++)
       cpr[i] = str[i];
   }
 
+  // FIXME??
   mxArray_number (int m, const char **str)
     : mxArray_matlab (mxCHAR_CLASS, m, max_str_len (m, str)),
       pr (calloc (get_number_of_elements (), get_element_size ())),
       pi (0)
   {
     mxChar *cpr = static_cast<mxChar *> (pr);
     
-    int *dv = get_dimensions ();
-
-    int nc = dv[1];
-
-    for (int j = 0; j < m; j++)
+    mwSize *dv = get_dimensions ();
+
+    mwSize nc = dv[1];
+
+    for (mwIndex j = 0; j < m; j++)
       {
 	const char *ptr = str[j];
 
-	int tmp_len = strlen (ptr);
-
-	for (int i = 0; i < tmp_len; i++)
+	size_t tmp_len = strlen (ptr);
+
+	for (size_t i = 0; i < tmp_len; i++)
 	  cpr[m*i+j] = static_cast<mxChar> (ptr[i]);
 
-	for (int i = tmp_len; i < nc; i++)
+	for (size_t i = tmp_len; i < nc; i++)
 	  cpr[m*i+j] = static_cast<mxChar> (' ');
       }	
   }
 
   mxArray_number *clone (void) const { return new mxArray_number (*this); }
 
   ~mxArray_number (void)
   {
@@ -1215,78 +1206,78 @@ public:
   void *get_data (void) const { return pr; }
 
   void *get_imag_data (void) const { return pi; }
 
   void set_data (void *pr_arg) { pr = pr_arg; }
 
   void set_imag_data (void *pi_arg) { pi = pi_arg; }
 
-  int get_string (char *buf, int buflen) const
+  int get_string (char *buf, mwSize buflen) const
   {
     int retval = 1;
 
-    int nel = get_number_of_elements ();
+    mwSize nel = get_number_of_elements ();
 
     if (nel < buflen)
       {
 	mxChar *ptr = static_cast<mxChar *> (pr);
 
-	for (int i = 0; i < nel; i++)
+	for (mwIndex i = 0; i < nel; i++)
 	  buf[i] = static_cast<char> (ptr[i]);
 
 	buf[nel] = 0;
       }
 
     return retval;
   }
 
   char *array_to_string (void) const
   {
     // FIXME -- this is suposed to handle multi-byte character
     // strings.
 
-    int nel = get_number_of_elements ();
+    mwSize nel = get_number_of_elements ();
 
     char *buf = static_cast<char *> (malloc (nel + 1));
 
     if (buf)
       {
 	mxChar *ptr = static_cast<mxChar *> (pr);
 
-	for (int i = 0; i < nel; i++)
+	for (mwIndex i = 0; i < nel; i++)
 	  buf[i] = static_cast<char> (ptr[i]);
 
 	buf[nel] = '\0';
       }
 
     return buf;
   }
 
 protected:
 
   template <typename ELT_T, typename ARRAY_T, typename ARRAY_ELT_T>
   octave_value
   int_to_ov (const dim_vector& dv) const
   {
     octave_value retval;
 
-    int nel = get_number_of_elements ();
+    mwSize nel = get_number_of_elements ();
 
     ELT_T *ppr = static_cast<ELT_T *> (pr);
 
     if (pi)
       error ("complex integer types are not supported");
     else
       {
 	ARRAY_T val (dv);
 
 	ARRAY_ELT_T *ptr = val.fortran_vec ();
 
-	for (int i = 0; i < nel; i++)
+	for (mwIndex i = 0; i < nel; i++)
 	  ptr[i] = ppr[i];
 
 	retval = val;
       }
 
     return retval;
   }
 
@@ -1299,90 +1290,90 @@ protected:
     switch (get_class_id ())
       {
       case mxLOGICAL_CLASS:
 	retval = int_to_ov<bool, boolNDArray, bool> (dv);
 	break;
 
       case mxCHAR_CLASS:
 	{
-	  int nel = get_number_of_elements ();
+	  mwSize nel = get_number_of_elements ();
 
 	  mxChar *ppr = static_cast<mxChar *> (pr);
 
 	  charNDArray val (dv);
 
 	  char *ptr = val.fortran_vec ();
 
-	  for (int i = 0; i < nel; i++)
+	  for (mwIndex i = 0; i < nel; i++)
 	    ptr[i] = static_cast<char> (ppr[i]);
 
 	  retval = octave_value (val, true, '\'');
 	}
 	break;
 
       case mxSINGLE_CLASS:
 	{
-	  int nel = get_number_of_elements ();
+	  mwSize nel = get_number_of_elements ();
 
 	  float *ppr = static_cast<float *> (pr);
 
 	  if (pi)
 	    {
 	      ComplexNDArray val (dv);
 
 	      Complex *ptr = val.fortran_vec ();
 
 	      float *ppi = static_cast<float *> (pi);
 
-	      for (int i = 0; i < nel; i++)
+	      for (mwIndex i = 0; i < nel; i++)
 		ptr[i] = Complex (ppr[i], ppi[i]);
 
 	      retval = val;
 	    }
 	  else
 	    {
 	      NDArray val (dv);
 
 	      double *ptr = val.fortran_vec ();
 
-	      for (int i = 0; i < nel; i++)
+	      for (mwIndex i = 0; i < nel; i++)
 		ptr[i] = ppr[i];
 
 	      retval = val;
 	    }
 	}
 	break;
 
       case mxDOUBLE_CLASS:
 	{
-	  int nel = get_number_of_elements ();
+	  mwSize nel = get_number_of_elements ();
 
 	  double *ppr = static_cast<double *> (pr);
 
 	  if (pi)
 	    {
 	      ComplexNDArray val (dv);
 
 	      Complex *ptr = val.fortran_vec ();
 
 	      double *ppi = static_cast<double *> (pi);
 
-	      for (int i = 0; i < nel; i++)
+	      for (mwIndex i = 0; i < nel; i++)
 		ptr[i] = Complex (ppr[i], ppi[i]);
 
 	      retval = val;
 	    }
 	  else
 	    {
 	      NDArray val (dv);
 
 	      double *ptr = val.fortran_vec ();
 
-	      for (int i = 0; i < nel; i++)
+	      for (mwIndex i = 0; i < nel; i++)
 		ptr[i] = ppr[i];
 
 	      retval = val;
 	    }
 	}
 	break;
 
       case mxINT8_CLASS:
@@ -1451,18 +1442,18 @@ class mxArray_sparse : public mxArray_ma
 public:
 
   mxArray_sparse (mxClassID id_arg, int m, int n, int nzmax_arg,
 		  mxComplexity flag = mxREAL)
     : mxArray_matlab (id_arg, m, n), nzmax (nzmax_arg)
   {
     pr = (calloc (nzmax, get_element_size ()));
     pi = (flag == mxCOMPLEX ? calloc (nzmax, get_element_size ()) : 0);
-    ir = static_cast<int *> (calloc (nzmax, sizeof (int)));
-    jc = static_cast<int *> (calloc (n + 1, sizeof (int)));
+    ir = static_cast<mwIndex *> (calloc (nzmax, sizeof (mwIndex)));
+    jc = static_cast<mwIndex *> (calloc (n + 1, sizeof (mwIndex)));
   }
 
   mxArray_sparse *clone (void) const { return new mxArray_sparse (*this); }
 
   ~mxArray_sparse (void)
   {
     mxFree (pr);
     mxFree (pi);
@@ -1477,27 +1468,27 @@ public:
   void *get_data (void) const { return pr; }
 
   void *get_imag_data (void) const { return pi; }
 
   void set_data (void *pr_arg) { pr = pr_arg; }
 
   void set_imag_data (void *pi_arg) { pi = pi_arg; }
 
-  int *get_ir (void) const { return ir; }
-
-  int *get_jc (void) const { return jc; }
-
-  int get_nzmax (void) const { return nzmax; }
-
-  void set_ir (int *ir_arg) { ir = ir_arg; }
-
-  void set_jc (int *jc_arg) { jc = jc_arg; }
-
-  void set_nzmax (int nzmax_arg) { nzmax = nzmax_arg; }
+  mwIndex *get_ir (void) const { return ir; }
+
+  mwIndex *get_jc (void) const { return jc; }
+
+  mwSize get_nzmax (void) const { return nzmax; }
+
+  void set_ir (mwIndex *ir_arg) { ir = ir_arg; }
+
+  void set_jc (mwIndex *jc_arg) { jc = jc_arg; }
+
+  void set_nzmax (mwSize nzmax_arg) { nzmax = nzmax_arg; }
 
 protected:
 
   octave_value as_octave_value (void) const
   {
     octave_value retval;
 
     dim_vector dv = dims_to_dim_vector ();
@@ -1506,23 +1497,23 @@ protected:
       {
       case mxLOGICAL_CLASS:
 	{
 	  bool *ppr = static_cast<bool *> (pr);
 
 	  SparseBoolMatrix val (get_m (), get_n (),
 				static_cast<octave_idx_type> (nzmax));
 
-	  for (int i = 0; i < nzmax; i++)
+	  for (mwIndex i = 0; i < nzmax; i++)
 	    {
 	      val.xdata(i) = ppr[i];
 	      val.xridx(i) = ir[i];
 	    }
 
-	  for (int i = 0; i < get_n () + 1; i++)
+	  for (mwIndex i = 0; i < get_n () + 1; i++)
 	    val.xcidx(i) = jc[i];
 
 	  retval = val;
 	}
 	break;
 
       case mxSINGLE_CLASS:
 	error ("single precision sparse data type not supported");
@@ -1533,109 +1524,109 @@ protected:
 	  if (pi)
 	    {
 	      double *ppr = static_cast<double *> (pr);
 	      double *ppi = static_cast<double *> (pi);
 
 	      SparseComplexMatrix val (get_m (), get_n (),
 				       static_cast<octave_idx_type> (nzmax));
 
-	      for (int i = 0; i < nzmax; i++)
+	      for (mwIndex i = 0; i < nzmax; i++)
 		{
 		  val.xdata(i) = Complex (ppr[i], ppi[i]);
 		  val.xridx(i) = ir[i];
 		}
 
-	      for (int i = 0; i < get_n () + 1; i++)
+	      for (mwIndex i = 0; i < get_n () + 1; i++)
 		val.xcidx(i) = jc[i];
 
 	      retval = val;
 	    }
 	  else
 	    {
 	      double *ppr = static_cast<double *> (pr);
 
 	      SparseMatrix val (get_m (), get_n (),
 				static_cast<octave_idx_type> (nzmax));
 
-	      for (int i = 0; i < nzmax; i++)
+	      for (mwIndex i = 0; i < nzmax; i++)
 		{
 		  val.xdata(i) = ppr[i];
 		  val.xridx(i) = ir[i];
 		}
 
-	      for (int i = 0; i < get_n () + 1; i++)
+	      for (mwIndex i = 0; i < get_n () + 1; i++)
 		val.xcidx(i) = jc[i];
 
 	      retval = val;
 	    }
 	}
 	break;
 
       default:
 	panic_impossible ();
       }
 
     return retval;
   }
 
 private:
 
-  int nzmax;
+  mwSize nzmax;
 
   void *pr;
   void *pi;
-  int *ir;
-  int *jc;
+  mwIndex *ir;
+  mwIndex *jc;
 
   mxArray_sparse (const mxArray_sparse& val)
     : mxArray_matlab (val), nzmax (val.nzmax),
-      ir (static_cast<int *> (malloc (nzmax * sizeof (int)))),
-      jc (static_cast<int *> (malloc (nzmax * sizeof (int))))
+      ir (static_cast<mwIndex *> (malloc (nzmax * sizeof (mwIndex)))),
+      jc (static_cast<mwIndex *> (malloc (nzmax * sizeof (mwIndex))))
   {
     size_t nbytes = nzmax * get_element_size ();
 
     if (pr)
       memcpy (pr, val.pr, nbytes);
 
     if (pi)
       memcpy (pi, val.pi, nbytes);
 
     if (ir)
-      memcpy (ir, val.ir, nzmax * sizeof (int));
+      memcpy (ir, val.ir, nzmax * sizeof (mwIndex));
 
     if (jc)
-      memcpy (jc, val.jc, (val.get_n () + 1) * sizeof (int));
+      memcpy (jc, val.jc, (val.get_n () + 1) * sizeof (mwIndex));
   }
 };
 
 // Matlab-style struct arrays.
 
 class mxArray_struct : public mxArray_matlab
 {
 public:
 
-  mxArray_struct (int ndims_arg, const int *dims_arg, int num_keys_arg,
+  mxArray_struct (mwSize ndims_arg, const mwSize *dims_arg, int num_keys_arg,
 		  const char **keys)
     : mxArray_matlab (mxSTRUCT_CLASS, ndims_arg, dims_arg), nfields (num_keys_arg),
       fields (static_cast<char **> (calloc (nfields, sizeof (char *)))),
       data (static_cast<mxArray **> (calloc (nfields * get_number_of_elements (), sizeof (mxArray *))))
   {
     init (keys);
   }
 
   mxArray_struct (const dim_vector& dv, int num_keys_arg, const char **keys)
     : mxArray_matlab (mxSTRUCT_CLASS, dv), nfields (num_keys_arg),
       fields (static_cast<char **> (calloc (nfields, sizeof (char *)))),
       data (static_cast<mxArray **> (calloc (nfields * get_number_of_elements (), sizeof (mxArray *))))
   {
     init (keys);
   }
 
-  mxArray_struct (int m, int n, int num_keys_arg, const char **keys)
+  mxArray_struct (mwSize m, mwSize n, int num_keys_arg, const char **keys)
     : mxArray_matlab (mxSTRUCT_CLASS, m, n), nfields (num_keys_arg),
       fields (static_cast<char **> (calloc (nfields, sizeof (char *)))),
       data (static_cast<mxArray **> (calloc (nfields * get_number_of_elements (), sizeof (mxArray *))))
   {
     init (keys);
   }
 
   void init (const char **keys)
@@ -1648,19 +1639,19 @@ public:
 
   ~mxArray_struct (void)
   {
     for (int i = 0; i < nfields; i++)
       mxFree (fields[i]);
 
     mxFree (fields);
 
-    int ntot = nfields * get_number_of_elements ();
-
-    for  (int i = 0; i < ntot; i++)
+    mwSize ntot = nfields * get_number_of_elements ();
+
+    for  (mwIndex i = 0; i < ntot; i++)
       delete data[i];
 
     mxFree (data);
   }
 
   int add_field (const char *key)
   {
     int retval = -1;
@@ -1670,29 +1661,29 @@ public:
 	nfields++;
 
 	fields = static_cast<char **> (mxRealloc (fields, nfields * sizeof (char *)));
 
 	if (fields)
 	  {
 	    fields[nfields-1] = strsave (key);
 
-	    int nel = get_number_of_elements ();
-
-	    int ntot = nfields * nel;
+	    mwSize nel = get_number_of_elements ();
+
+	    mwSize ntot = nfields * nel;
 
 	    mxArray **new_data = static_cast<mxArray **> (malloc (ntot * sizeof (mxArray *)));
 
 	    if (new_data)
 	      {
-		int j = 0;
-		int k = 0;
-		int n = 0;
-
-		for (int i = 0; i < ntot; i++)
+		mwIndex j = 0;
+		mwIndex k = 0;
+		mwIndex n = 0;
+
+		for (mwIndex i = 0; i < ntot; i++)
 		  {
 		    if (++n == nfields)
 		      {
 			new_data[j++] = 0;
 			n = 0;
 		      }
 		    else
 		      new_data[j++] = data[k++];
@@ -1709,39 +1700,39 @@ public:
 
     return retval;
   }
 
   void remove_field (int key_num)
   {
     if (key_num >= 0 && key_num < nfields)
       {
-	int nel = get_number_of_elements ();
-
-	int ntot = nfields * nel;
+	mwSize nel = get_number_of_elements ();
+
+	mwSize ntot = nfields * nel;
 
 	int new_nfields = nfields - 1;
 
 	char **new_fields = static_cast<char **> (malloc (new_nfields * sizeof (char *)));
 
 	mxArray **new_data = static_cast<mxArray **> (malloc (new_nfields * nel * sizeof (mxArray *)));
 
 	for (int i = 0; i < key_num; i++)
 	  new_fields[i] = fields[i];
 
 	for (int i = key_num + 1; i < nfields; i++)
 	  new_fields[i-1] = fields[i];
 
 	if (new_nfields > 0)
 	  {
-	    int j = 0;
-	    int k = 0;
-	    int n = 0;
-
-	    for (int i = 0; i < ntot; i++)
+	    mwIndex j = 0;
+	    mwIndex k = 0;
+	    mwIndex n = 0;
+
+	    for (mwIndex i = 0; i < ntot; i++)
 	      {
 		if (n == key_num)
 		  k++;
 		else
 		  new_data[j++] = data[k++];
 
 		if (++n == nfields)
 		  n = 0;
@@ -1753,23 +1744,23 @@ public:
 	mxFree (fields);
 	mxFree (data);
 
 	fields = new_fields;
 	data = new_data;
       }
   }
 
-  mxArray *get_field_by_number (int index, int key_num) const
+  mxArray *get_field_by_number (mwIndex index, int key_num) const
   {
     return key_num >= 0 && key_num < nfields
       ? data[nfields * index + key_num] : 0;
   }
 
-  void set_field_by_number (int index, int key_num, mxArray *val);
+  void set_field_by_number (mwIndex index, int key_num, mxArray *val);
 
   int get_number_of_fields (void) const { return nfields; }
 
   const char *get_field_name_by_number (int key_num) const
   {
     return key_num >= 0 && key_num < nfields ? fields[key_num] : 0;
   }
 
@@ -1798,26 +1789,26 @@ protected:
   octave_value as_octave_value (void) const
   {
     dim_vector dv = dims_to_dim_vector ();
 
     string_vector keys (fields, nfields);
 
     Octave_map m;
 
-    int ntot = nfields * get_number_of_elements ();
+    mwSize ntot = nfields * get_number_of_elements ();
 
     for (int i = 0; i < nfields; i++)
       {
 	Cell c (dv);
 
 	octave_value *p = c.fortran_vec ();
 
-	int k = 0;
-	for (int j = i; j < ntot; j += nfields)
+	mwIndex k = 0;
+	for (mwIndex j = i; j < ntot; j += nfields)
 	  p[k++] = mxArray::as_octave_value (data[j]);
 
 	m.assign (keys[i], c);
       }
 
     return m;
   }
 
@@ -1832,148 +1823,148 @@ private:
   mxArray_struct (const mxArray_struct& val)
     : mxArray_matlab (val), nfields (val.nfields),
       fields (static_cast<char **> (malloc (nfields * sizeof (char *)))),
       data (static_cast<mxArray **> (malloc (nfields * get_number_of_elements () * sizeof (mxArray *))))
   {
     for (int i = 0; i < nfields; i++)
       fields[i] = strsave (val.fields[i]);
 
-    int nel = get_number_of_elements ();
-
-    for (int i = 0; i < nel * nfields; i++)
+    mwSize nel = get_number_of_elements ();
+
+    for (mwIndex i = 0; i < nel * nfields; i++)
       {
 	mxArray *ptr = val.data[i];
 	data[i] = ptr ? ptr->clone () : 0;
       }
   }
 };
 
 // Matlab-style cell arrays.
 
 class mxArray_cell : public mxArray_matlab
 {
 public:
 
-  mxArray_cell (int ndims_arg, const int *dims_arg)
+  mxArray_cell (mwSize ndims_arg, const mwSize *dims_arg)
     : mxArray_matlab (mxCELL_CLASS, ndims_arg, dims_arg),
       data (static_cast<mxArray **> (calloc (get_number_of_elements (), sizeof (mxArray *)))) { }
 
   mxArray_cell (const dim_vector& dv)
     : mxArray_matlab (mxCELL_CLASS, dv),
       data (static_cast<mxArray **> (calloc (get_number_of_elements (), sizeof (mxArray *)))) { }
 
-  mxArray_cell (int m, int n)
+  mxArray_cell (mwSize m, mwSize n)
     : mxArray_matlab (mxCELL_CLASS, m, n),
       data (static_cast<mxArray **> (calloc (get_number_of_elements (), sizeof (mxArray *)))) { }
 
   mxArray_cell *clone (void) const { return new mxArray_cell (*this); }
 
   ~mxArray_cell (void)
   {
-    int nel = get_number_of_elements ();
-
-    for  (int i = 0; i < nel; i++)
+    mwSize nel = get_number_of_elements ();
+
+    for  (mwIndex i = 0; i < nel; i++)
       delete data[i];
 
     mxFree (data);
   }
 
-  mxArray *get_cell (int idx) const
+  mxArray *get_cell (mwIndex idx) const
   {
     return idx >= 0 && idx < get_number_of_elements () ? data[idx] : 0;
   }
 
-  void set_cell (int idx, mxArray *val);
+  void set_cell (mwIndex idx, mxArray *val);
 
   void *get_data (void) const { return data; }
 
   void set_data (void *data_arg) { data = static_cast<mxArray **> (data_arg); }
 
 protected:
 
   octave_value as_octave_value (void) const
   {
     dim_vector dv = dims_to_dim_vector ();
 
     Cell c (dv);
 
-    int nel = get_number_of_elements ();
+    mwSize nel = get_number_of_elements ();
 
     octave_value *p = c.fortran_vec ();
 
-    for (int i = 0; i < nel; i++)
+    for (mwIndex i = 0; i < nel; i++)
       p[i] = mxArray::as_octave_value (data[i]);
 
     return c;
   }
 
 private:
 
   mxArray **data;
 
   mxArray_cell (const mxArray_cell& val)
     : mxArray_matlab (val),
       data (static_cast<mxArray **> (malloc (get_number_of_elements () * sizeof (mxArray *))))
   {
-    int nel = get_number_of_elements ();
-
-    for (int i = 0; i < nel; i++)
+    mwSize nel = get_number_of_elements ();
+
+    for (mwIndex i = 0; i < nel; i++)
       {
 	mxArray *ptr = val.data[i];
 	data[i] = ptr ? ptr->clone () : 0;
       }
   }
 };
 
 // ------------------------------------------------------------------
 
 mxArray::mxArray (const octave_value& ov)
   : rep (new mxArray_octave_value (ov)), name (0) { }
 
-mxArray::mxArray (mxClassID id, int ndims, const int *dims, mxComplexity flag)
+mxArray::mxArray (mxClassID id, mwSize ndims, const mwSize *dims, mxComplexity flag)
   : rep (new mxArray_number (id, ndims, dims, flag)), name (0) { }
 
 mxArray::mxArray (mxClassID id, const dim_vector& dv, mxComplexity flag)
   : rep (new mxArray_number (id, dv, flag)), name (0) { }
 
-mxArray::mxArray (mxClassID id, int m, int n, mxComplexity flag)
+mxArray::mxArray (mxClassID id, mwSize m, mwSize n, mxComplexity flag)
   : rep (new mxArray_number (id, m, n, flag)), name (0) { }
 
 mxArray::mxArray (mxClassID id, double val)
   : rep (new mxArray_number (id, val)), name (0) { }
 
 mxArray::mxArray (mxClassID id, mxLogical val)
   : rep (new mxArray_number (id, val)), name (0) { }
 
 mxArray::mxArray (const char *str)
   : rep (new mxArray_number (str)), name (0) { }
 
-mxArray::mxArray (int m, const char **str)
+mxArray::mxArray (mwSize m, const char **str)
   : rep (new mxArray_number (m, str)), name (0) { }
 
-mxArray::mxArray (mxClassID id, int m, int n, int nzmax, mxComplexity flag)
+mxArray::mxArray (mxClassID id, mwSize m, mwSize n, mwSize nzmax, mxComplexity flag)
   : rep (new mxArray_sparse (id, m, n, nzmax, flag)), name (0) { }
 
-mxArray::mxArray (int ndims, const int *dims, int num_keys, const char **keys)
+mxArray::mxArray (mwSize ndims, const mwSize *dims, int num_keys, const char **keys)
   : rep (new mxArray_struct (ndims, dims, num_keys, keys)), name (0) { }
 
 mxArray::mxArray (const dim_vector& dv, int num_keys, const char **keys)
   : rep (new mxArray_struct (dv, num_keys, keys)), name (0) { }
 
-mxArray::mxArray (int m, int n, int num_keys, const char **keys)
+mxArray::mxArray (mwSize m, mwSize n, int num_keys, const char **keys)
   : rep (new mxArray_struct (m, n, num_keys, keys)), name (0) { }
 
-mxArray::mxArray (int ndims, const int *dims)
+mxArray::mxArray (mwSize ndims, const mwSize *dims)
   : rep (new mxArray_cell (ndims, dims)), name (0) { }
 
 mxArray::mxArray (const dim_vector& dv)
   : rep (new mxArray_cell (dv)), name (0) { }
 
-mxArray::mxArray (int m, int n)
+mxArray::mxArray (mwSize m, mwSize n)
   : rep (new mxArray_cell (m, n)), name (0) { }
 
 mxArray::~mxArray (void)
 {
   mxFree (name);
 
   delete rep;
 }
@@ -2015,17 +2006,17 @@ mxArray::maybe_mutate (void) const
 	  new_val->rep = 0;
 	  delete new_val;
 	}
     }
 }
 
 // ------------------------------------------------------------------
 
-// A clas to manage calls to MEX functions.  Mostly deals with memory
+// A class to manage calls to MEX functions.  Mostly deals with memory
 // management.
 
 class mex
 {
 public:
 
   mex (octave_mex_function *f)
     : curr_mex_fcn (f), memlist (), arraylist (), fname (0) { }
@@ -2323,24 +2314,24 @@ maybe_unmark_array (mxArray *ptr)
 {
   if (mex_context)
     mex_context->unmark_array (ptr);
 
   return ptr;
 }
 
 void
-mxArray_struct::set_field_by_number (int index, int key_num, mxArray *val)
+mxArray_struct::set_field_by_number (mwIndex index, int key_num, mxArray *val)
 {
   if (key_num >= 0 && key_num < nfields)
     data[nfields * index + key_num] = maybe_unmark_array (val);
 }
 
 void
-mxArray_cell::set_cell (int idx, mxArray *val)
+mxArray_cell::set_cell (mwIndex idx, mxArray *val)
 {
   if (idx >= 0 && idx < get_number_of_elements ())
     data[idx] = maybe_unmark_array (val);
 }
 
 // ------------------------------------------------------------------
 
 // C interface to mxArray objects:
@@ -2414,108 +2405,108 @@ mxFree (void *ptr)
 static inline mxArray *
 maybe_mark_array (mxArray *ptr)
 {
   return mex_context ? mex_context->mark_array (ptr) : ptr;
 }
   
 // Constructors.
 mxArray *
-mxCreateCellArray (int ndims, const int *dims)
+mxCreateCellArray (mwSize ndims, const mwSize *dims)
 {
   return maybe_mark_array (new mxArray (ndims, dims));
 }
 
 mxArray *
-mxCreateCellMatrix (int m, int n)
+mxCreateCellMatrix (mwSize m, mwSize n)
 {
   return maybe_mark_array (new mxArray (m, n));
 }
 
 mxArray *
-mxCreateCharArray (int ndims, const int *dims)
+mxCreateCharArray (mwSize ndims, const mwSize *dims)
 {
   return maybe_mark_array (new mxArray (mxCHAR_CLASS, ndims, dims));
 }
 
 mxArray *
-mxCreateCharMatrixFromStrings (int m, const char **str)
+mxCreateCharMatrixFromStrings (mwSize m, const char **str)
 {
   return maybe_mark_array (new mxArray (m, str));
 }
 
 mxArray *
-mxCreateDoubleMatrix (int m, int n, mxComplexity flag)
+mxCreateDoubleMatrix (mwSize m, mwSize n, mxComplexity flag)
 {
   return maybe_mark_array (new mxArray (mxDOUBLE_CLASS, m, n, flag));
 }
 
 mxArray *
 mxCreateDoubleScalar (double val)
 {
   return maybe_mark_array (new mxArray (mxDOUBLE_CLASS, val));
 }
 
 mxArray *
-mxCreateLogicalArray (int ndims, const int *dims)
+mxCreateLogicalArray (mwSize ndims, const mwSize *dims)
 {
   return maybe_mark_array (new mxArray (mxLOGICAL_CLASS, ndims, dims));
 }
 
 mxArray *
-mxCreateLogicalMatrix (int m, int n)
+mxCreateLogicalMatrix (mwSize m, mwSize n)
 {
   return maybe_mark_array (new mxArray (mxLOGICAL_CLASS, m, n));
 }
 
 mxArray *
 mxCreateLogicalScalar (int val)
 {
   return maybe_mark_array (new mxArray (mxLOGICAL_CLASS, val));
 }
 
 mxArray *
-mxCreateNumericArray (int ndims, const int *dims, mxClassID class_id,
+mxCreateNumericArray (mwSize ndims, const mwSize *dims, mxClassID class_id,
 		      mxComplexity flag)
 {
   return maybe_mark_array (new mxArray (class_id, ndims, dims, flag));
 }
 
 mxArray *
-mxCreateNumericMatrix (int m, int n, mxClassID class_id, mxComplexity flag)
+mxCreateNumericMatrix (mwSize m, mwSize n, mxClassID class_id, mxComplexity flag)
 {
   return maybe_mark_array (new mxArray (class_id, m, n, flag));
 }
 
 mxArray *
-mxCreateSparse (int m, int n, int nzmax, mxComplexity flag)
+mxCreateSparse (mwSize m, mwSize n, mwSize nzmax, mxComplexity flag)
 {
   return maybe_mark_array (new mxArray (mxDOUBLE_CLASS, m, n, nzmax, flag));
 }
 
 mxArray *
-mxCreateSparseLogicalMatrix (int m, int n, int nzmax)
+mxCreateSparseLogicalMatrix (mwSize m, mwSize n, mwSize nzmax)
 {
   return maybe_mark_array (new mxArray (mxLOGICAL_CLASS, m, n, nzmax));
 }
 
 mxArray *
 mxCreateString (const char *str)
 {
   return maybe_mark_array (new mxArray (str));
 }
 
 mxArray *
-mxCreateStructArray (int ndims, int *dims, int num_keys, const char **keys)
+mxCreateStructArray (mwSize ndims, mwSize *dims, int num_keys, const char **keys)
 {
   return maybe_mark_array (new mxArray (ndims, dims, num_keys, keys));
 }
 
 mxArray *
-mxCreateStructMatrix (int m, int n, int num_keys, const char **keys)
+mxCreateStructMatrix (mwSize m, mwSize n, int num_keys, const char **keys)
 {
   return maybe_mark_array (new mxArray (m, n, num_keys, keys));
 }
 
 // Copy constructor.
 mxArray *
 mxDuplicateArray (const mxArray *ptr)
 {
@@ -2665,61 +2656,61 @@ int
 mxIsFromGlobalWS (const mxArray */*ptr*/)
 {
   // FIXME
   abort ();
   return 0;
 }
 
 // Dimension extractors.
-int
+size_t
 mxGetM (const mxArray *ptr)
 {
   return ptr->get_m ();
 }
 
-int
+size_t
 mxGetN (const mxArray *ptr)
 {
   return ptr->get_n ();
 }
 
-int *
+mwSize *
 mxGetDimensions (const mxArray *ptr)
 {
   return ptr->get_dimensions ();
 }
 
-int
+mwSize
 mxGetNumberOfDimensions (const mxArray *ptr)
 {
   return ptr->get_number_of_dimensions ();
 }
 
-int
+size_t
 mxGetNumberOfElements (const mxArray *ptr)
 {
   return ptr->get_number_of_elements ();
 }
 
 // Dimension setters.
 void
-mxSetM (mxArray *ptr, int m)
+mxSetM (mxArray *ptr, mwSize m)
 {
   ptr->set_m (m);
 }
 
 void
-mxSetN (mxArray *ptr, int n)
+mxSetN (mxArray *ptr, mwSize n)
 {
   ptr->set_n (n);
 }
 
 void
-mxSetDimensions (mxArray *ptr, int *dims, int ndims)
+mxSetDimensions (mxArray *ptr, mwSize *dims, mwSize ndims)
 {
   ptr->set_dimensions (dims, ndims);
 }
   
 // Data extractors.
 double *
 mxGetPr (const mxArray *ptr)
 {
@@ -2803,60 +2794,60 @@ mxGetClassName (const mxArray *ptr)
 void
 mxSetClassName (mxArray *ptr, const char *name)
 {
   ptr->set_class_name (name);
 }
 
 // Cell support.
 mxArray *
-mxGetCell (const mxArray *ptr, int idx)
+mxGetCell (const mxArray *ptr, mwIndex idx)
 {
   return ptr->get_cell (idx);
 }
 
 void
-mxSetCell (mxArray *ptr, int idx, mxArray *val)
+mxSetCell (mxArray *ptr, mwIndex idx, mxArray *val)
 {
   ptr->set_cell (idx, val);
 }
 
 // Sparse support.
-int *
+mwIndex *
 mxGetIr (const mxArray *ptr)
 {
   return ptr->get_ir ();
 }
 
-int *
+mwIndex *
 mxGetJc (const mxArray *ptr)
 {
   return ptr->get_jc ();
 }
 
-int
+mwSize
 mxGetNzmax (const mxArray *ptr)
 {
   return ptr->get_nzmax ();
 }
 
 void
-mxSetIr (mxArray *ptr, int *ir)
+mxSetIr (mxArray *ptr, mwIndex *ir)
 {
   ptr->set_ir (ir);
 }
 
 void
-mxSetJc (mxArray *ptr, int *jc)
+mxSetJc (mxArray *ptr, mwIndex *jc)
 {
   ptr->set_jc (jc);
 }
 
 void
-mxSetNzmax (mxArray *ptr, int nzmax)
+mxSetNzmax (mxArray *ptr, mwSize nzmax)
 {
   ptr->set_nzmax (nzmax);
 }
 
 // Structure support.
 int
 mxAddField (mxArray *ptr, const char *key)
 {
@@ -2865,37 +2856,37 @@ mxAddField (mxArray *ptr, const char *ke
 
 void
 mxRemoveField (mxArray *ptr, int key_num)
 {
   ptr->remove_field (key_num);
 }
 
 mxArray *
-mxGetField (const mxArray *ptr, int index, const char *key)
+mxGetField (const mxArray *ptr, mwIndex index, const char *key)
 {
   int key_num = mxGetFieldNumber (ptr, key);
   return mxGetFieldByNumber (ptr, index, key_num);
 }
 
 mxArray *
-mxGetFieldByNumber (const mxArray *ptr, int index, int key_num)
+mxGetFieldByNumber (const mxArray *ptr, mwIndex index, int key_num)
 {
   return ptr->get_field_by_number (index, key_num);
 }
 
 void
-mxSetField (mxArray *ptr, int index, const char *key, mxArray *val)
+mxSetField (mxArray *ptr, mwIndex index, const char *key, mxArray *val)
 {
   int key_num = mxGetFieldNumber (ptr, key);
   mxSetFieldByNumber (ptr, index, key_num, val);
 }
 
 void
-mxSetFieldByNumber (mxArray *ptr, int index, int key_num, mxArray *val)
+mxSetFieldByNumber (mxArray *ptr, mwIndex index, int key_num, mxArray *val)
 {
   ptr->set_field_by_number (index, key_num, val);
 }
 
 int
 mxGetNumberOfFields (const mxArray *ptr)
 {
   return ptr->get_number_of_fields ();
@@ -2909,34 +2900,34 @@ mxGetFieldNameByNumber (const mxArray *p
 
 int
 mxGetFieldNumber (const mxArray *ptr, const char *key)
 {
   return ptr->get_field_number (key);
 }
 
 int
-mxGetString (const mxArray *ptr, char *buf, int buflen)
+mxGetString (const mxArray *ptr, char *buf, mwSize buflen)
 {
   return ptr->get_string (buf, buflen);
 }
 
 char *
 mxArrayToString (const mxArray *ptr)
 {
   return ptr->array_to_string ();
 }
   
-int
-mxCalcSingleSubscript (const mxArray *ptr, int nsubs, int *subs)
+mwIndex
+mxCalcSingleSubscript (const mxArray *ptr, mwSize nsubs, mwIndex *subs)
 {
   return ptr->calc_single_subscript (nsubs, subs);
 }
 
-int
+size_t
 mxGetElementSize (const mxArray *ptr)
 {
   return ptr->get_element_size ();
 }
 
 // ------------------------------------------------------------------
 
 typedef void (*cmex_fptr) (int nlhs, mxArray **plhs, int nrhs, mxArray **prhs);
diff --git a/src/mexproto.h b/src/mexproto.h
--- a/src/mexproto.h
+++ b/src/mexproto.h
@@ -104,32 +104,32 @@ extern OCTINTERP_API double mxGetNaN (vo
   
 // Memory management.
 extern OCTINTERP_API void *mxCalloc (size_t n, size_t size);
 extern OCTINTERP_API void *mxMalloc (size_t n);
 extern OCTINTERP_API void *mxRealloc (void *ptr, size_t size);
 extern OCTINTERP_API void mxFree (void *ptr);
   
 // Constructors.
-extern OCTINTERP_API mxArray *mxCreateCellArray (int ndims, const int *dims);
-extern OCTINTERP_API mxArray *mxCreateCellMatrix (int m, int n);
-extern OCTINTERP_API mxArray *mxCreateCharArray (int ndims, const int *dims);
-extern OCTINTERP_API mxArray *mxCreateCharMatrixFromStrings (int m, const char **str);
-extern OCTINTERP_API mxArray *mxCreateDoubleMatrix (int nr, int nc, mxComplexity flag);
+extern OCTINTERP_API mxArray *mxCreateCellArray (mwSize ndims, const mwSize *dims);
+extern OCTINTERP_API mxArray *mxCreateCellMatrix (mwSize m, mwSize n);
+extern OCTINTERP_API mxArray *mxCreateCharArray (mwSize ndims, const mwSize *dims);
+extern OCTINTERP_API mxArray *mxCreateCharMatrixFromStrings (mwSize m, const char **str);
+extern OCTINTERP_API mxArray *mxCreateDoubleMatrix (mwSize nr, mwSize nc, mxComplexity flag);
 extern OCTINTERP_API mxArray *mxCreateDoubleScalar (double val);
-extern OCTINTERP_API mxArray *mxCreateLogicalArray (int ndims, const int *dims);
-extern OCTINTERP_API mxArray *mxCreateLogicalMatrix (int m, int n);
+extern OCTINTERP_API mxArray *mxCreateLogicalArray (mwSize ndims, const mwSize *dims);
+extern OCTINTERP_API mxArray *mxCreateLogicalMatrix (mwSize m, mwSize n);
 extern OCTINTERP_API mxArray *mxCreateLogicalScalar (int val);
-extern OCTINTERP_API mxArray *mxCreateNumericArray (int ndims, const int *dims, mxClassID class_id, mxComplexity flag);
-extern OCTINTERP_API mxArray *mxCreateNumericMatrix (int m, int n, mxClassID class_id, mxComplexity flag);
-extern OCTINTERP_API mxArray *mxCreateSparse (int m, int n, int nzmax, mxComplexity flag);
-extern OCTINTERP_API mxArray *mxCreateSparseLogicalMatrix (int m, int n, int nzmax);
+extern OCTINTERP_API mxArray *mxCreateNumericArray (mwSize ndims, const mwSize *dims, mxClassID class_id, mxComplexity flag);
+extern OCTINTERP_API mxArray *mxCreateNumericMatrix (mwSize m, mwSize n, mxClassID class_id, mxComplexity flag);
+extern OCTINTERP_API mxArray *mxCreateSparse (mwSize m, mwSize n, mwSize nzmax, mxComplexity flag);
+extern OCTINTERP_API mxArray *mxCreateSparseLogicalMatrix (mwSize m, mwSize n, mwSize nzmax);
 extern OCTINTERP_API mxArray *mxCreateString (const char *str);
-extern OCTINTERP_API mxArray *mxCreateStructArray (int ndims, int *dims, int num_keys, const char **keys);
-extern OCTINTERP_API mxArray *mxCreateStructMatrix (int rows, int cols, int num_keys, const char **keys);
+extern OCTINTERP_API mxArray *mxCreateStructArray (mwSize ndims, mwSize *dims, int num_keys, const char **keys);
+extern OCTINTERP_API mxArray *mxCreateStructMatrix (mwSize rows, mwSize cols, int num_keys, const char **keys);
 
 // Copy constructor.
 extern OCTINTERP_API mxArray *mxDuplicateArray (const mxArray *v);
 
 // Destructor.
 extern OCTINTERP_API void mxDestroyArray (mxArray *v);
 
 // Type Predicates.
@@ -160,79 +160,79 @@ extern OCTINTERP_API int mxIsLogicalScal
 
 // Size predicate.
 extern OCTINTERP_API int mxIsEmpty (const mxArray *ptr);
 
 // Just plain odd thing to ask of a value.
 extern OCTINTERP_API int mxIsFromGlobalWS (const mxArray *ptr);
 
 // Dimension extractors.
-extern OCTINTERP_API int mxGetM (const mxArray *ptr);
-extern OCTINTERP_API int mxGetN (const mxArray *ptr);
-extern OCTINTERP_API int *mxGetDimensions (const mxArray *ptr);
-extern OCTINTERP_API int mxGetNumberOfDimensions (const mxArray *ptr);
-extern OCTINTERP_API int mxGetNumberOfElements (const mxArray *ptr);
+extern OCTINTERP_API size_t mxGetM (const mxArray *ptr);
+extern OCTINTERP_API size_t mxGetN (const mxArray *ptr);
+extern OCTINTERP_API mwSize *mxGetDimensions (const mxArray *ptr);
+extern OCTINTERP_API mwSize mxGetNumberOfDimensions (const mxArray *ptr);
+extern OCTINTERP_API size_t mxGetNumberOfElements (const mxArray *ptr);
 
 // Dimension setters.
-extern OCTINTERP_API void mxSetM (mxArray *ptr, int M);
-extern OCTINTERP_API void mxSetN (mxArray *ptr, int N);
-extern OCTINTERP_API void mxSetDimensions (mxArray *ptr, int *dims, int ndims);
+extern OCTINTERP_API void mxSetM (mxArray *ptr, mwSize M);
+extern OCTINTERP_API void mxSetN (mxArray *ptr, mwSize N);
+extern OCTINTERP_API void mxSetDimensions (mxArray *ptr, mwSize *dims, mwSize ndims);
   
 // Data extractors.
 extern OCTINTERP_API double *mxGetPi (const mxArray *ptr);
 extern OCTINTERP_API double *mxGetPr (const mxArray *ptr);
 extern OCTINTERP_API double mxGetScalar (const mxArray *ptr);
 extern OCTINTERP_API mxChar *mxGetChars (const mxArray *ptr);
 extern OCTINTERP_API mxLogical *mxGetLogicals (const mxArray *ptr);
 extern OCTINTERP_API void *mxGetData (const mxArray *ptr);
 extern OCTINTERP_API void *mxGetImagData (const mxArray *ptr);
 
-// Data setters.
+// Data setters./
 extern OCTINTERP_API void mxSetPr (mxArray *ptr, double *pr);
 extern OCTINTERP_API void mxSetPi (mxArray *ptr, double *pi);
 extern OCTINTERP_API void mxSetData (mxArray *ptr, void *data);
 extern OCTINTERP_API void mxSetImagData (mxArray *ptr, void *pi);
 
 // Classes.
 extern OCTINTERP_API mxClassID mxGetClassID (const mxArray *ptr);
 extern OCTINTERP_API const char *mxGetClassName (const mxArray *ptr);
 
 extern OCTINTERP_API void mxSetClassName (mxArray *ptr, const char *name);
 
 // Cell support.
-extern OCTINTERP_API mxArray *mxGetCell (const mxArray *ptr, int idx);
+extern OCTINTERP_API mxArray *mxGetCell (const mxArray *ptr, mwIndex idx);
 
-extern OCTINTERP_API void mxSetCell (mxArray *ptr, int idx, mxArray *val);
+extern OCTINTERP_API void mxSetCell (mxArray *ptr, mwIndex idx, mxArray *val);
 
 // Sparse support.
-extern OCTINTERP_API int *mxGetIr (const mxArray *ptr);
-extern OCTINTERP_API int *mxGetJc (const mxArray *ptr);
-extern OCTINTERP_API int mxGetNzmax (const mxArray *ptr);
+extern OCTINTERP_API mwIndex *mxGetIr (const mxArray *ptr);
+extern OCTINTERP_API mwIndex *mxGetJc (const mxArray *ptr);
+extern OCTINTERP_API mwSize mxGetNzmax (const mxArray *ptr);
 
-extern OCTINTERP_API void mxSetIr (mxArray *ptr, int *ir);
-extern OCTINTERP_API void mxSetJc (mxArray *ptr, int *jc);
-extern OCTINTERP_API void mxSetNzmax (mxArray *ptr, int nzmax);
+extern OCTINTERP_API void mxSetIr (mxArray *ptr, mwIndex *ir);
+extern OCTINTERP_API void mxSetJc (mxArray *ptr, mwIndex *jc);
+extern OCTINTERP_API void mxSetNzmax (mxArray *ptr, mwSize nzmax);
 
 // Structure support.
 extern OCTINTERP_API int mxAddField (mxArray *ptr, const char *key);
 
 extern OCTINTERP_API void mxRemoveField (mxArray *ptr, int key_num);
 
-extern OCTINTERP_API mxArray *mxGetField (const mxArray *ptr, int index, const char *key);
-extern OCTINTERP_API mxArray *mxGetFieldByNumber (const mxArray *ptr, int index, int key_num);
+extern OCTINTERP_API mxArray *mxGetField (const mxArray *ptr, mwIndex index, const char *key);
+extern OCTINTERP_API mxArray *mxGetFieldByNumber (const mxArray *ptr, mwIndex index, int key_num);
 
-extern OCTINTERP_API void mxSetField (mxArray *ptr, int index, const char *key, mxArray *val);
-extern OCTINTERP_API void mxSetFieldByNumber (mxArray *ptr, int index, int key_num, mxArray *val);
+extern OCTINTERP_API void mxSetField (mxArray *ptr, mwIndex index, const char *key, mxArray *val);
+extern OCTINTERP_API void mxSetFieldByNumber (mxArray *ptr, mwIndex index, int key_num, mxArray *val);
 
 extern OCTINTERP_API int mxGetNumberOfFields (const mxArray *ptr);
 
 extern OCTINTERP_API const char *mxGetFieldNameByNumber (const mxArray *ptr, int key_num);
 extern OCTINTERP_API int mxGetFieldNumber (const mxArray *ptr, const char *key);
 
-extern OCTINTERP_API int mxGetString (const mxArray *ptr, char *buf, int buflen);
+extern OCTINTERP_API int mxGetString (const mxArray *ptr, char *buf, mwSize buflen);
 extern OCTINTERP_API char *mxArrayToString (const mxArray *ptr);
   
 // Miscellaneous.
 #ifdef NDEBUG
 #define mxAssert(expr, msg) \
   do \
     { \
       if (! expr) \
@@ -254,19 +254,19 @@ extern OCTINTERP_API char *mxArrayToStri
         } \
     } \
   while (0)
 #else
 #define mxAssert(expr, msg)
 #define mxAssertS(expr, msg)
 #endif
 
-extern OCTINTERP_API int mxCalcSingleSubscript (const mxArray *ptr, int nsubs, int *subs);
+extern OCTINTERP_API mwIndex mxCalcSingleSubscript (const mxArray *ptr, mwSize nsubs, mwIndex *subs);
 
-extern OCTINTERP_API int mxGetElementSize (const mxArray *ptr);
+extern OCTINTERP_API size_t mxGetElementSize (const mxArray *ptr);
 
 #if defined (__cplusplus)
 }
 #endif
 
 #endif
 
 /*
diff --git a/src/mxarray.h b/src/mxarray.h
deleted file mode 100644
--- a/src/mxarray.h
+++ /dev/null
@@ -1,335 +0,0 @@
-/*
-
-Copyright (C) 2001, 2006 Paul Kienzle
-
-This file is part of Octave.
-
-Octave is free software; you can redistribute it and/or modify it
-under the terms of the GNU General Public License as published by the
-Free Software Foundation; either version 2, or (at your option) any
-later version.
-
-Octave is distributed in the hope that it will be useful, but WITHOUT
-ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
-for more details.
-
-You should have received a copy of the GNU General Public License
-along with Octave; see the file COPYING.  If not, write to the Free
-Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
-02110-1301, USA.
-
-*/
-
-/*
-
-Part of this code was originally distributed as part of Octave Forge under
-the following terms:
-
-Author: Paul Kienzle
-I grant this code to the public domain.
-2001-03-22
-
-THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
-ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
-IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
-ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
-FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
-DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
-OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
-HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
-LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
-OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
-SUCH DAMAGE.
-
-*/
-
-#if ! defined (MXARRAY_H)
-#define MXARRAY_H
-
-typedef enum
-  {
-    mxREAL = 0,
-    mxCOMPLEX = 1
-  }
-  mxComplexity;
-
-typedef enum
-  {
-    mxUNKNOWN_CLASS = 0,
-    mxCELL_CLASS,
-    mxSTRUCT_CLASS,
-    mxLOGICAL_CLASS,
-    mxCHAR_CLASS,
-    mxUNUSED_CLASS,
-    mxDOUBLE_CLASS,
-    mxSINGLE_CLASS,
-    mxINT8_CLASS,
-    mxUINT8_CLASS,
-    mxINT16_CLASS,
-    mxUINT16_CLASS,
-    mxINT32_CLASS,
-    mxUINT32_CLASS,
-    mxINT64_CLASS,
-    mxUINT64_CLASS,
-    mxFUNCTION_CLASS,
-  }
-  mxClassID;
-
-typedef int mxLogical;
-
-/* typedef Uint16 mxChar; */
-typedef char mxChar;
-
-#if ! defined (MXARRAY_TYPEDEFS_ONLY)
-
-class octave_value;
-
-#define DO_MUTABLE_METHOD(RET_T, METHOD_CALL) \
-  RET_T retval = rep->METHOD_CALL; \
- \
-  if (rep->mutation_needed ()) \
-    { \
-      maybe_mutate (); \
-      retval = rep->METHOD_CALL; \
-    } \
- \
-  return retval
-
-#define DO_VOID_MUTABLE_METHOD(METHOD_CALL) \
-  rep->METHOD_CALL; \
- \
-  if (rep->mutation_needed ()) \
-    { \
-      maybe_mutate (); \
-      rep->METHOD_CALL; \
-    }
-
-// This just provides a way to avoid infinite recursion when building
-// mxArray objects.
-
-struct
-xmxArray
-{
-  xmxArray (void) { }
-};
-
-// The main interface class.  The representation can be based on an
-// octave_value object or a separate object that tries to reproduce
-// the semantics of mxArray objects in Matlab more directly.
-
-class mxArray
-{
-public:
-
-  mxArray (const octave_value& ov);
-
-  mxArray (mxClassID id, int ndims, const int *dims,
-	   mxComplexity flag = mxREAL);
-
-  mxArray (mxClassID id, const dim_vector& dv, mxComplexity flag = mxREAL);
-
-  mxArray (mxClassID id, int m, int n, mxComplexity flag = mxREAL);
-
-  mxArray (mxClassID id, double val);
-
-  mxArray (mxClassID id, mxLogical val);
-
-  mxArray (const char *str);
-
-  mxArray (int m, const char **str);
-
-  mxArray (mxClassID id, int m, int n, int nzmax, mxComplexity flag = mxREAL);
-
-  mxArray (int ndims, const int *dims, int num_keys, const char **keys);
-
-  mxArray (const dim_vector& dv, int num_keys, const char **keys);
-
-  mxArray (int m, int n, int num_keys, const char **keys);
-
-  mxArray (int ndims, const int *dims);
-
-  mxArray (const dim_vector& dv);
-
-  mxArray (int m, int n);
-
-  virtual mxArray *clone (void) const
-  {
-    mxArray *new_rep = rep->clone ();
-
-    return new mxArray (new_rep, name);
-  }
-
-  virtual ~mxArray (void);
-
-  virtual bool is_octave_value (void) const { return rep->is_octave_value (); }
-
-  virtual int is_cell (void) const { return rep->is_cell (); }
-
-  virtual int is_char (void) const { return rep->is_char (); }
-
-  virtual int is_class (const char *name_arg) const { return rep->is_class (name_arg); }
-
-  virtual int is_complex (void) const { return rep->is_complex (); }
-
-  virtual int is_double (void) const { return rep->is_double (); }
-
-  virtual int is_int16 (void) const { return rep->is_int16 (); }
-
-  virtual int is_int32 (void) const { return rep->is_int32 (); }
-
-  virtual int is_int64 (void) const { return rep->is_int64 (); }
-
-  virtual int is_int8 (void) const { return rep->is_int8 (); }
-
-  virtual int is_logical (void) const { return rep->is_logical (); }
-
-  virtual int is_numeric (void) const { return rep->is_numeric (); }
-
-  virtual int is_single (void) const { return rep->is_single (); }
-
-  virtual int is_sparse (void) const { return rep->is_sparse (); }
-
-  virtual int is_struct (void) const { return rep->is_struct (); }
-
-  virtual int is_uint16 (void) const { return rep->is_uint16 (); }
-
-  virtual int is_uint32 (void) const { return rep->is_uint32 (); }
-
-  virtual int is_uint64 (void) const { return rep->is_uint64 (); }
-
-  virtual int is_uint8 (void) const { return rep->is_uint8 (); }
-
-  virtual int is_logical_scalar (void) const { return rep->is_logical_scalar (); }
-
-  virtual int is_logical_scalar_true (void) const { return rep->is_logical_scalar_true (); }
-
-  virtual int get_m (void) const { return rep->get_m (); }
-
-  virtual int get_n (void) const { return rep->get_n (); }
-
-  virtual int *get_dimensions (void) const { return rep->get_dimensions (); }
-
-  virtual int get_number_of_dimensions (void) const { return rep->get_number_of_dimensions (); }
-
-  virtual void set_m (int m) { DO_VOID_MUTABLE_METHOD (set_m (m)); }
-
-  virtual void set_n (int n) { DO_VOID_MUTABLE_METHOD (set_n (n)); }
-
-  virtual void set_dimensions (int *dims_arg, int ndims_arg) { DO_VOID_MUTABLE_METHOD (set_dimensions (dims_arg, ndims_arg)); }
-
-  virtual int get_number_of_elements (void) const { return rep->get_number_of_elements (); }
-
-  virtual int is_empty (void) const { return get_number_of_elements () == 0; }
-
-  const char *get_name (void) const { return name; }
-
-  void set_name (const char *name_arg);
-
-  virtual mxClassID get_class_id (void) const { return rep->get_class_id (); }
-
-  virtual const char *get_class_name (void) const { return rep->get_class_name (); }
-
-  virtual void set_class_name (const char *name_arg) { DO_VOID_MUTABLE_METHOD (set_class_name (name_arg)); }
-
-  virtual mxArray *get_cell (int idx) const { DO_MUTABLE_METHOD (mxArray *, get_cell (idx)); }
-
-  virtual void set_cell (int idx, mxArray *val) { DO_VOID_MUTABLE_METHOD (set_cell (idx, val)); }
-
-  virtual double get_scalar (void) const { return rep->get_scalar (); }
-
-  virtual void *get_data (void) const { DO_MUTABLE_METHOD (void *, get_data ()); }
-
-  virtual void *get_imag_data (void) const { DO_MUTABLE_METHOD (void *, get_imag_data ()); }
-
-  virtual void set_data (void *pr) { DO_VOID_MUTABLE_METHOD (set_data (pr)); }
-
-  virtual void set_imag_data (void *pi) { DO_VOID_MUTABLE_METHOD (set_imag_data (pi)); }
-
-  virtual int *get_ir (void) const { DO_MUTABLE_METHOD (int *, get_ir ()); }
-
-  virtual int *get_jc (void) const { DO_MUTABLE_METHOD (int *, get_jc ()); }
-
-  virtual int get_nzmax (void) const { return rep->get_nzmax (); }
-
-  virtual void set_ir (int *ir) { DO_VOID_MUTABLE_METHOD (set_ir (ir)); }
-
-  virtual void set_jc (int *jc) { DO_VOID_MUTABLE_METHOD (set_jc (jc)); }
-
-  virtual void set_nzmax (int nzmax) { DO_VOID_MUTABLE_METHOD (set_nzmax (nzmax)); }
-
-  virtual int add_field (const char *key) { DO_MUTABLE_METHOD (int, add_field (key)); }
-
-  virtual void remove_field (int key_num) { DO_VOID_MUTABLE_METHOD (remove_field (key_num)); }
-
-  virtual mxArray *get_field_by_number (int index, int key_num) const { DO_MUTABLE_METHOD (mxArray *, get_field_by_number (index, key_num)); }
-
-  virtual void set_field_by_number (int index, int key_num, mxArray *val) { DO_VOID_MUTABLE_METHOD (set_field_by_number (index, key_num, val)); }
-
-  virtual int get_number_of_fields (void) const { return rep->get_number_of_fields (); }
-
-  virtual const char *get_field_name_by_number (int key_num) const { DO_MUTABLE_METHOD (const char*, get_field_name_by_number (key_num)); }
-
-  virtual int get_field_number (const char *key) const { DO_MUTABLE_METHOD (int, get_field_number (key)); }
-
-  virtual int get_string (char *buf, int buflen) const { return rep->get_string (buf, buflen); }
-
-  virtual char *array_to_string (void) const { return rep->array_to_string (); }
-
-  virtual int calc_single_subscript (int nsubs, int *subs) const { return rep->calc_single_subscript (nsubs, subs); }
-
-  virtual int get_element_size (void) const { return rep->get_element_size (); }
-
-  virtual bool mutation_needed (void) const { return rep->mutation_needed (); }
-
-  virtual mxArray *mutate (void) const { return rep->mutate (); }
-
-  static void *malloc (size_t n);
-
-  static void *calloc (size_t n, size_t t);
-
-  static char *strsave (const char *str)
-  {
-    char *retval = 0;
-
-    if (str)
-      {
-	int sz =  sizeof (mxChar) * (strlen (str) + 1);
-	retval = static_cast<char *> (mxArray::malloc (sz));
-	strcpy (retval, str);
-      }
-
-    return retval;
-  }
-
-  static octave_value as_octave_value (mxArray *ptr);
-
-protected:
-
-  virtual octave_value as_octave_value (void) const;
-
-  mxArray (const xmxArray&) : rep (0), name (0) { }
-
-private:
-
-  mutable mxArray *rep;
-
-  char *name;
-
-  mxArray (mxArray *r, const char *n)
-    : rep (r), name (strsave (n)) { }
-
-  void maybe_mutate (void) const;
-
-  // No copying!
-
-  mxArray (const mxArray&);
-
-  mxArray& operator = (const mxArray&);
-};
-
-#undef DO_MUTABLE_METHOD
-#undef DO_VOID_MUTABLE_METHOD
-
-#endif
-#endif
diff --git a/src/mxarray.h.in b/src/mxarray.h.in
new file mode 100644
--- /dev/null
+++ b/src/mxarray.h.in
@@ -0,0 +1,343 @@
+/*
+
+Copyright (C) 2001, 2006 Paul Kienzle
+
+This file is part of Octave.
+
+Octave is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+Octave is distributed in the hope that it will be useful, but WITHOUT
+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+for more details.
+
+You should have received a copy of the GNU General Public License
+along with Octave; see the file COPYING.  If not, write to the Free
+Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301, USA.
+
+*/
+
+/*
+
+Part of this code was originally distributed as part of Octave Forge under
+the following terms:
+
+Author: Paul Kienzle
+I grant this code to the public domain.
+2001-03-22
+
+THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
+ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+SUCH DAMAGE.
+
+*/
+
+#if ! defined (MXARRAY_H)
+#define MXARRAY_H
+
+typedef enum
+  {
+    mxREAL = 0,
+    mxCOMPLEX = 1
+  }
+  mxComplexity;
+
+typedef enum
+  {
+    mxUNKNOWN_CLASS = 0,
+    mxCELL_CLASS,
+    mxSTRUCT_CLASS,
+    mxLOGICAL_CLASS,
+    mxCHAR_CLASS,
+    mxUNUSED_CLASS,
+    mxDOUBLE_CLASS,
+    mxSINGLE_CLASS,
+    mxINT8_CLASS,
+    mxUINT8_CLASS,
+    mxINT16_CLASS,
+    mxUINT16_CLASS,
+    mxINT32_CLASS,
+    mxUINT32_CLASS,
+    mxINT64_CLASS,
+    mxUINT64_CLASS,
+    mxFUNCTION_CLASS,
+  }
+  mxClassID;
+
+typedef int mxLogical;
+
+/* typedef Uint16 mxChar; */
+typedef char mxChar;
+
+/* 
+ * FIXME? Mathworks says these should be size_t on 64-bit system and when
+ * mex is used with the -largearraydims flag, but why do that? Its better
+ * to conform to the same indexing as the rest of Octave
+ */
+typedef @OCTAVE_IDX_TYPE@ mwSize;
+typedef @OCTAVE_IDX_TYPE@ mwIndex;
+
+#if ! defined (MXARRAY_TYPEDEFS_ONLY)
+
+class octave_value;
+
+#define DO_MUTABLE_METHOD(RET_T, METHOD_CALL) \
+  RET_T retval = rep->METHOD_CALL; \
+ \
+  if (rep->mutation_needed ()) \
+    { \
+      maybe_mutate (); \
+      retval = rep->METHOD_CALL; \
+    } \
+ \
+  return retval
+
+#define DO_VOID_MUTABLE_METHOD(METHOD_CALL) \
+  rep->METHOD_CALL; \
+ \
+  if (rep->mutation_needed ()) \
+    { \
+      maybe_mutate (); \
+      rep->METHOD_CALL; \
+    }
+
+// This just provides a way to avoid infinite recursion when building
+// mxArray objects.
+
+struct
+xmxArray
+{
+  xmxArray (void) { }
+};
+
+// The main interface class.  The representation can be based on an
+// octave_value object or a separate object that tries to reproduce
+// the semantics of mxArray objects in Matlab more directly.
+
+class mxArray
+{
+public:
+
+  mxArray (const octave_value& ov);
+
+  mxArray (mxClassID id, mwSize ndims, const mwSize *dims,
+	   mxComplexity flag = mxREAL);
+
+  mxArray (mxClassID id, const dim_vector& dv, mxComplexity flag = mxREAL);
+
+  mxArray (mxClassID id, mwSize m, mwSize n, mxComplexity flag = mxREAL);
+
+  mxArray (mxClassID id, double val);
+
+  mxArray (mxClassID id, mxLogical val);
+
+  mxArray (const char *str);
+
+  mxArray (int m, const char **str);
+
+  mxArray (mxClassID id, mwSize m, mwSize n, int nzmax, mxComplexity flag = mxREAL);
+
+  mxArray (mwSize ndims, const mwSize *dims, int num_keys, const char **keys);
+
+  mxArray (const dim_vector& dv, int num_keys, const char **keys);
+
+  mxArray (mwSize m, mwSize n, int num_keys, const char **keys);
+
+  mxArray (mwSize ndims, const mwSize *dims);
+
+  mxArray (const dim_vector& dv);
+
+  mxArray (mwSize m, mwSize n);
+
+  virtual mxArray *clone (void) const
+  {
+    mxArray *new_rep = rep->clone ();
+
+    return new mxArray (new_rep, name);
+  }
+
+  virtual ~mxArray (void);
+
+  virtual bool is_octave_value (void) const { return rep->is_octave_value (); }
+
+  virtual int is_cell (void) const { return rep->is_cell (); }
+
+  virtual int is_char (void) const { return rep->is_char (); }
+
+  virtual int is_class (const char *name_arg) const { return rep->is_class (name_arg); }
+
+  virtual int is_complex (void) const { return rep->is_complex (); }
+
+  virtual int is_double (void) const { return rep->is_double (); }
+
+  virtual int is_int16 (void) const { return rep->is_int16 (); }
+
+  virtual int is_int32 (void) const { return rep->is_int32 (); }
+
+  virtual int is_int64 (void) const { return rep->is_int64 (); }
+
+  virtual int is_int8 (void) const { return rep->is_int8 (); }
+
+  virtual int is_logical (void) const { return rep->is_logical (); }
+
+  virtual int is_numeric (void) const { return rep->is_numeric (); }
+
+  virtual int is_single (void) const { return rep->is_single (); }
+
+  virtual int is_sparse (void) const { return rep->is_sparse (); }
+
+  virtual int is_struct (void) const { return rep->is_struct (); }
+
+  virtual int is_uint16 (void) const { return rep->is_uint16 (); }
+
+  virtual int is_uint32 (void) const { return rep->is_uint32 (); }
+
+  virtual int is_uint64 (void) const { return rep->is_uint64 (); }
+
+  virtual int is_uint8 (void) const { return rep->is_uint8 (); }
+
+  virtual int is_logical_scalar (void) const { return rep->is_logical_scalar (); }
+
+  virtual int is_logical_scalar_true (void) const { return rep->is_logical_scalar_true (); }
+
+  virtual mwSize get_m (void) const { return rep->get_m (); }
+
+  virtual mwSize get_n (void) const { return rep->get_n (); }
+
+  virtual mwSize *get_dimensions (void) const { return rep->get_dimensions (); }
+
+  virtual mwSize get_number_of_dimensions (void) const { return rep->get_number_of_dimensions (); }
+
+  virtual void set_m (mwSize m) { DO_VOID_MUTABLE_METHOD (set_m (m)); }
+
+  virtual void set_n (mwSize n) { DO_VOID_MUTABLE_METHOD (set_n (n)); }
+
+  virtual void set_dimensions (mwSize *dims_arg, mwSize ndims_arg) { DO_VOID_MUTABLE_METHOD (set_dimensions (dims_arg, ndims_arg)); }
+
+  virtual mwSize get_number_of_elements (void) const { return rep->get_number_of_elements (); }
+
+  virtual int is_empty (void) const { return get_number_of_elements () == 0; }
+
+  const char *get_name (void) const { return name; }
+
+  void set_name (const char *name_arg);
+
+  virtual mxClassID get_class_id (void) const { return rep->get_class_id (); }
+
+  virtual const char *get_class_name (void) const { return rep->get_class_name (); }
+
+  virtual void set_class_name (const char *name_arg) { DO_VOID_MUTABLE_METHOD (set_class_name (name_arg)); }
+
+  virtual mxArray *get_cell (mwIndex idx) const { DO_MUTABLE_METHOD (mxArray *, get_cell (idx)); }
+
+  virtual void set_cell (mwIndex idx, mxArray *val) { DO_VOID_MUTABLE_METHOD (set_cell (idx, val)); }
+
+  virtual double get_scalar (void) const { return rep->get_scalar (); }
+
+  virtual void *get_data (void) const { DO_MUTABLE_METHOD (void *, get_data ()); }
+
+  virtual void *get_imag_data (void) const { DO_MUTABLE_METHOD (void *, get_imag_data ()); }
+
+  virtual void set_data (void *pr) { DO_VOID_MUTABLE_METHOD (set_data (pr)); }
+
+  virtual void set_imag_data (void *pi) { DO_VOID_MUTABLE_METHOD (set_imag_data (pi)); }
+
+  virtual mwIndex *get_ir (void) const { DO_MUTABLE_METHOD (mwIndex *, get_ir ()); }
+
+  virtual mwIndex *get_jc (void) const { DO_MUTABLE_METHOD (mwIndex *, get_jc ()); }
+
+  virtual mwSize get_nzmax (void) const { return rep->get_nzmax (); }
+
+  virtual void set_ir (mwIndex *ir) { DO_VOID_MUTABLE_METHOD (set_ir (ir)); }
+
+  virtual void set_jc (mwIndex *jc) { DO_VOID_MUTABLE_METHOD (set_jc (jc)); }
+
+  virtual void set_nzmax (mwSize nzmax) { DO_VOID_MUTABLE_METHOD (set_nzmax (nzmax)); }
+
+  virtual int add_field (const char *key) { DO_MUTABLE_METHOD (int, add_field (key)); }
+
+  virtual void remove_field (int key_num) { DO_VOID_MUTABLE_METHOD (remove_field (key_num)); }
+
+  virtual mxArray *get_field_by_number (mwIndex index, int key_num) const { DO_MUTABLE_METHOD (mxArray *, get_field_by_number (index, key_num)); }
+
+  virtual void set_field_by_number (mwIndex index, int key_num, mxArray *val) { DO_VOID_MUTABLE_METHOD (set_field_by_number (index, key_num, val)); }
+
+  virtual int get_number_of_fields (void) const { return rep->get_number_of_fields (); }
+
+  virtual const char *get_field_name_by_number (int key_num) const { DO_MUTABLE_METHOD (const char*, get_field_name_by_number (key_num)); }
+
+  virtual int get_field_number (const char *key) const { DO_MUTABLE_METHOD (int, get_field_number (key)); }
+
+  virtual int get_string (char *buf, int buflen) const { return rep->get_string (buf, buflen); }
+
+  virtual char *array_to_string (void) const { return rep->array_to_string (); }
+
+  virtual mwIndex calc_single_subscript (mwSize nsubs, mwIndex *subs) const { return rep->calc_single_subscript (nsubs, subs); }
+
+  virtual size_t get_element_size (void) const { return rep->get_element_size (); }
+
+  virtual bool mutation_needed (void) const { return rep->mutation_needed (); }
+
+  virtual mxArray *mutate (void) const { return rep->mutate (); }
+
+  static void *malloc (size_t n);
+
+  static void *calloc (size_t n, size_t t);
+
+  static char *strsave (const char *str)
+  {
+    char *retval = 0;
+
+    if (str)
+      {
+	mwSize sz =  sizeof (mxChar) * (strlen (str) + 1);
+	retval = static_cast<char *> (mxArray::malloc (sz));
+	strcpy (retval, str);
+      }
+
+    return retval;
+  }
+
+  static octave_value as_octave_value (mxArray *ptr);
+
+protected:
+
+  virtual octave_value as_octave_value (void) const;
+
+  mxArray (const xmxArray&) : rep (0), name (0) { }
+
+private:
+
+  mutable mxArray *rep;
+
+  char *name;
+
+  mxArray (mxArray *r, const char *n)
+    : rep (r), name (strsave (n)) { }
+
+  void maybe_mutate (void) const;
+
+  // No copying!
+
+  mxArray (const mxArray&);
+
+  mxArray& operator = (const mxArray&);
+};
+
+#undef DO_MUTABLE_METHOD
+#undef DO_VOID_MUTABLE_METHOD
+
+#endif
+#endif
diff --git a/src/ov-bool-mat.cc b/src/ov-bool-mat.cc
--- a/src/ov-bool-mat.cc
+++ b/src/ov-bool-mat.cc
@@ -471,21 +471,21 @@ octave_bool_matrix::load_hdf5 (hid_t loc
 
 mxArray *
 octave_bool_matrix::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxLOGICAL_CLASS, dims (), mxREAL);
 
   bool *pr = static_cast<bool *> (retval->get_data ());
 
-  int nel = numel ();
+  mwSize nel = numel ();
 
   const bool *p = matrix.data ();
 
-  for (int i = 0; i < nel; i++)
+  for (mwIndex i = 0; i < nel; i++)
     pr[i] = p[i];
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/ov-bool-sparse.cc b/src/ov-bool-sparse.cc
--- a/src/ov-bool-sparse.cc
+++ b/src/ov-bool-sparse.cc
@@ -694,30 +694,30 @@ octave_sparse_bool_matrix::load_hdf5 (hi
   return retval;
 }
 
 #endif
 
 mxArray *
 octave_sparse_bool_matrix::as_mxArray (void) const
 {
-  int nz = nzmax ();
+  mwSize nz = nzmax ();
   mxArray *retval = new mxArray (mxLOGICAL_CLASS, rows (), columns (), 
 				 nz, mxREAL);
   bool *pr = static_cast<bool *> (retval->get_data ());
-  int *ir = retval->get_ir ();
-  int *jc = retval->get_jc ();
+  mwIndex *ir = retval->get_ir ();
+  mwIndex *jc = retval->get_jc ();
 
-  for (int i = 0; i < nz; i++)
+  for (mwIndex i = 0; i < nz; i++)
     {
       pr[i] = matrix.data(i);
       ir[i] = matrix.ridx(i);
     }
 
-  for (int i = 0; i < columns () + 1; i++)
+  for (mwIndex i = 0; i < columns () + 1; i++)
     jc[i] = matrix.cidx(i);
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -1142,21 +1142,21 @@ cell array will have a dimension vector 
 
 mxArray *
 octave_cell::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (dims ());
 
   mxArray **elts = static_cast<mxArray **> (retval->get_data ());
 
-  int nel = numel ();
+  mwSize nel = numel ();
 
   const octave_value *p = matrix.data ();
 
-  for (int i = 0; i < nel; i++)
+  for (mwIndex i = 0; i < nel; i++)
     elts[i] = new mxArray (p[i]);
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/ov-ch-mat.cc b/src/ov-ch-mat.cc
--- a/src/ov-ch-mat.cc
+++ b/src/ov-ch-mat.cc
@@ -100,21 +100,21 @@ octave_char_matrix::print_raw (std::ostr
 
 mxArray *
 octave_char_matrix::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxCHAR_CLASS, dims (), mxREAL);
 
   mxChar *pr = static_cast<mxChar *> (retval->get_data ());
 
-  int nel = numel ();
+  mwSize nel = numel ();
 
   const char *p = matrix.data ();
 
-  for (int i = 0; i < nel; i++)
+  for (mwIndex i = 0; i < nel; i++)
     pr[i] = p[i];
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -602,21 +602,21 @@ octave_complex_matrix::print_raw (std::o
 mxArray *
 octave_complex_matrix::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, dims (), mxCOMPLEX);
 
   double *pr = static_cast<double *> (retval->get_data ());
   double *pi = static_cast<double *> (retval->get_imag_data ());
 
-  int nel = numel ();
+  mwSize nel = numel ();
 
   const Complex *p = matrix.data ();
 
-  for (int i = 0; i < nel; i++)
+  for (mwIndex i = 0; i < nel; i++)
     {
       pr[i] = real (p[i]);
       pi[i] = imag (p[i]);
     }
 
   return retval;
 }
 
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -759,33 +759,33 @@ octave_sparse_complex_matrix::load_hdf5 
   return retval;
 }
 
 #endif
 
 mxArray *
 octave_sparse_complex_matrix::as_mxArray (void) const
 {
-  int nz = nzmax ();
+  mwSize nz = nzmax ();
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, rows (), columns (),
 				 nz, mxCOMPLEX);
   double *pr = static_cast<double *> (retval->get_data ());
   double *pi = static_cast<double *> (retval->get_imag_data ());
-  int *ir = retval->get_ir ();
-  int *jc = retval->get_jc ();
+  mwIndex *ir = retval->get_ir ();
+  mwIndex *jc = retval->get_jc ();
 
-  for (int i = 0; i < nz; i++)
+  for (mwIndex i = 0; i < nz; i++)
     {
       Complex val = matrix.data(i);
       pr[i] = real (val);
       pi[i] = imag (val);
       ir[i] = matrix.ridx(i);
     }
 
-  for (int i = 0; i < columns() + 1; i++)
+  for (mwIndex i = 0; i < columns() + 1; i++)
     jc[i] = matrix.cidx(i);
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/ov-intx.h b/src/ov-intx.h
--- a/src/ov-intx.h
+++ b/src/ov-intx.h
@@ -208,21 +208,21 @@ public:
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   mxArray *as_mxArray (void) const
   {
     mxArray *retval = new mxArray (OCTAVE_INT_MX_CLASS, dims (), mxREAL);
 
     OCTAVE_INT_T::val_type *pr = static_cast<OCTAVE_INT_T::val_type *> (retval->get_data ());
 
-    int nel = numel ();
+    mwSize nel = numel ();
 
     const OCTAVE_INT_T *p = matrix.data ();
 
-    for (int i = 0; i < nel; i++)
+    for (mwIndex i = 0; i < nel; i++)
       pr[i] = p[i].value ();
 
     return retval;
   }
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
diff --git a/src/ov-range.cc b/src/ov-range.cc
--- a/src/ov-range.cc
+++ b/src/ov-range.cc
@@ -472,23 +472,23 @@ octave_range::load_hdf5 (hid_t loc_id, c
 
 mxArray *
 octave_range::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, dims (), mxREAL);
 
   double *pr = static_cast<double *> (retval->get_data ());
 
-  int nel = numel ();
+  mwSize nel = numel ();
 
   Matrix m = matrix_value ();
 
   const double *p = m.data ();
 
-  for (int i = 0; i < nel; i++)
+  for (mwSize i = 0; i < nel; i++)
     pr[i] = p[i];
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -623,21 +623,21 @@ octave_matrix::print_raw (std::ostream& 
 
 mxArray *
 octave_matrix::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, dims (), mxREAL);
 
   double *pr = static_cast<double *> (retval->get_data ());
 
-  int nel = numel ();
+  mwSize nel = numel ();
 
   const double *p = matrix.data ();
 
-  for (int i = 0; i < nel; i++)
+  for (mwIndex i = 0; i < nel; i++)
     pr[i] = p[i];
 
   return retval;
 }
 
 DEFUN (double, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} double (@var{x})\n\
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -790,31 +790,31 @@ octave_sparse_matrix::load_hdf5 (hid_t l
   return true;
 }
 
 #endif
 
 mxArray *
 octave_sparse_matrix::as_mxArray (void) const
 {
-  int nz = nzmax();
-  int nr = rows();
-  int nc = columns();
+  mwSize nz = nzmax();
+  mwSize nr = rows();
+  mwSize nc = columns();
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, nr, nc, nz, mxREAL);
   double *pr = static_cast<double *> (retval->get_data ());
-  int *ir = retval->get_ir();
-  int *jc = retval->get_jc();
+  mwIndex *ir = retval->get_ir();
+  mwIndex *jc = retval->get_jc();
 
-  for (int i = 0; i < nz; i++)
+  for (mwIndex i = 0; i < nz; i++)
     {
       pr[i] = matrix.data(i);
       ir[i] = matrix.ridx(i);
     }
 
-  for (int i = 0; i < nc + 1; i++)
+  for (mwIndex i = 0; i < nc + 1; i++)
     jc[i] = matrix.cidx(i);
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -1266,28 +1266,28 @@ octave_struct::as_mxArray (void) const
 
   for (int i = 0; i < nf; i++)
     f[i] = kv[i].c_str ();
 
   mxArray *retval = new mxArray (dims (), nf, f);
 
   mxArray **elts = static_cast<mxArray **> (retval->get_data ());
 
-  int nel = numel ();
+  mwSize nel = numel ();
 
-  int ntot = nf * nel;
+  mwSize ntot = nf * nel;
 
   for (int i = 0; i < nf; i++)
     {
       Cell c = map.contents (kv[i]);
 
       const octave_value *p = c.data ();
 
-      int k = 0;
-      for (int j = i; j < ntot; j += nf)
+      mwIndex k = 0;
+      for (mwIndex j = i; j < ntot; j += nf)
 	elts[j] = new mxArray (p[k++]);
     }
 
   return retval;
 }
 
 /*
 ;;; Local Variables: ***
