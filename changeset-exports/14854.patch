# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1341864109 25200
#      Mon Jul 09 13:01:49 2012 -0700
# Node ID 5ae9f0f77635eead51579eb75926ebe9a35bc33b
# Parent  72b8b39e12be0fc67a5ae46cec21d4734bba1e3d
maint: Use Octave coding conventions for coddling parenthis is DLD-FUNCTIONS directory

* __fltk_uigetfile__.cc, __glpk__.cc, __init_fltk__.cc, __magick_read__.cc,
besselj.cc, bsxfun.cc, ccolamd.cc, cellfun.cc, chol.cc, colamd.cc, daspk.cc,
dasrt.cc, dassl.cc, dmperm.cc, fft.cc, filter.cc, find.cc, gcd.cc, kron.cc,
lsode.cc, lu.cc, luinc.cc, quad.cc, quadcc.cc, rand.cc, regexp.cc, schur.cc,
str2double.cc, symbfact.cc, symrcm.cc, tril.cc, urlwrite.cc: Use Octave coding
conventions for coddling parenthis is DLD-FUNCTIONS directory.

diff --git a/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc b/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
--- a/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
+++ b/src/DLD-FUNCTIONS/__fltk_uigetfile__.cc
@@ -104,17 +104,17 @@ Undocumented internal function.\n\
       if (file_count == 1 && multi_type != Fl_File_Chooser::DIRECTORY)
         {
           fname = fc.value ();
           idx = fname.find_last_of (sep);
           retval(0) = fname.substr (idx + 1);
         }
       else
         {
-          Cell file_cell = Cell(file_count, 1);
+          Cell file_cell = Cell (file_count, 1);
           for (octave_idx_type n = 1; n <= file_count; n++)
             {
               fname = fc.value (n);
               idx = fname.find_last_of (sep);
               file_cell(n - 1) = fname.substr (idx + 1);
             }
           retval(0) = file_cell;
         }
diff --git a/src/DLD-FUNCTIONS/__glpk__.cc b/src/DLD-FUNCTIONS/__glpk__.cc
--- a/src/DLD-FUNCTIONS/__glpk__.cc
+++ b/src/DLD-FUNCTIONS/__glpk__.cc
@@ -277,26 +277,26 @@ glpk (int sense, int n, int m, double *c
       if (lpx_write_cpxlp (lp, tmp) != 0)
         {
           error ("__glpk__: unable to write problem");
           longjmp (mark, -1);
         }
     }
 
   //-- scale the problem data (if required)
-  //-- if (scale && (!presol || method == 1)) lpx_scale_prob(lp);
+  //-- if (scale && (!presol || method == 1)) lpx_scale_prob (lp);
   //-- LPX_K_SCALE=IParam[1]  LPX_K_PRESOL=IParam[16]
   if (lpxIntParam[1] && (! lpxIntParam[16] || lpsolver != 1))
     lpx_scale_prob (lp);
 
   //-- build advanced initial basis (if required)
   if (lpsolver == 1 && ! lpxIntParam[16])
     lpx_adv_basis (lp);
 
-  for(int i = 0; i < NIntP; i++)
+  for (int i = 0; i < NIntP; i++)
     lpx_set_int_parm (lp, IParam[i], lpxIntParam[i]);
 
   for (int i = 0; i < NRealP; i++)
     lpx_set_real_parm (lp, RParam[i], lpxRealParam[i]);
 
   if (lpsolver == 1)
     method = 'S';
   else
@@ -308,22 +308,22 @@ glpk (int sense, int n, int m, double *c
       {
         if (isMIP)
           {
             method = 'I';
             errnum = lpx_simplex (lp);
             errnum = lpx_integer (lp);
           }
         else
-          errnum = lpx_simplex(lp);
+          errnum = lpx_simplex (lp);
       }
      break;
 
     case 'T':
-      errnum = lpx_interior(lp);
+      errnum = lpx_interior (lp);
       break;
 
     default:
       break;
 #if 0
 #ifdef GLPK_PRE_4_14
       insist (method != method);
 #else
@@ -526,20 +526,20 @@ Undocumented internal function.\n\
 
       if (Anc != mrowsc)
         {
           error ("__glpk__: invalid value of A");
           return retval;
         }
 
       for (octave_idx_type j = 0; j < Anc; j++)
-        for (octave_idx_type i = A.cidx(j); i < A.cidx(j+1); i++)
+        for (octave_idx_type i = A.cidx (j); i < A.cidx (j+1); i++)
           {
             nz++;
-            rn(nz) = A.ridx(i) + 1;
+            rn(nz) = A.ridx (i) + 1;
             cn(nz) = j + 1;
             a(nz) = A.data(i);
           }
     }
   else
     {
       Matrix A (args(1).matrix_value ()); // get the matrix
 
diff --git a/src/DLD-FUNCTIONS/__init_fltk__.cc b/src/DLD-FUNCTIONS/__init_fltk__.cc
--- a/src/DLD-FUNCTIONS/__init_fltk__.cc
+++ b/src/DLD-FUNCTIONS/__init_fltk__.cc
@@ -252,29 +252,29 @@ private:
   }
 };
 
 // Parameter controlling how fast we zoom when using the scrool wheel.
 static double wheel_zoom_speed = 0.05;
 // Parameter controlling the GUI mode.
 static enum { pan_zoom, rotate_zoom, none } gui_mode;
 
-void script_cb(Fl_Widget*, void* data)
+void script_cb (Fl_Widget*, void* data)
   {
     static_cast<uimenu::properties*> (data)->execute_callback ();
   }
 
 
 class fltk_uimenu
 {
 public:
   fltk_uimenu (int xx, int yy, int ww, int hh)
     {
       menubar = new
-        Fl_Menu_Bar(xx, yy, ww, hh);
+        Fl_Menu_Bar (xx, yy, ww, hh);
     }
 
   int items_to_show (void)
     {
       //returns the number of visible menu items
       int len = menubar->size ();
       int n = 0;
       for (int t = 0; t < len; t++ )
@@ -680,17 +680,17 @@ public:
     {
 
       canvas = new OpenGL_fltk (0, 0, ww, hh - status_h, number ());
 
       uimenu = new fltk_uimenu (0, 0, ww, menu_h);
       uimenu->hide ();
 
       bottom = new Fl_Box (0, hh - status_h, ww, status_h);
-      bottom->box(FL_FLAT_BOX);
+      bottom->box (FL_FLAT_BOX);
 
       ndim = calc_dimensions (gh_manager::get_object (fp.get___myhandle__ ()));
 
       autoscale = new Fl_Button (0, hh - status_h, status_h, status_h, "A");
       autoscale->callback (button_callback, static_cast<void*> (this));
       autoscale->tooltip ("Autoscale");
 
       togglegrid = new Fl_Button (status_h, hh - status_h, status_h,
@@ -1919,18 +1919,18 @@ public:
               }
           }
       }
     else if (go.isa ("uimenu"))
       {
         if (id == uimenu::properties::ID_LABEL)
           uimenu_set_fltk_label (go);
 
-        graphics_object fig = go.get_ancestor("figure");
-        figure_manager::uimenu_update(fig.get_handle (), go.get_handle (), id);
+        graphics_object fig = go.get_ancestor ("figure");
+        figure_manager::uimenu_update (fig.get_handle (), go.get_handle (), id);
       }
   }
 
   void redraw_figure (const graphics_object& go) const
   {
     figure_manager::mark_modified (go.get_handle ());
 
     __fltk_redraw__ ();
diff --git a/src/DLD-FUNCTIONS/__magick_read__.cc b/src/DLD-FUNCTIONS/__magick_read__.cc
--- a/src/DLD-FUNCTIONS/__magick_read__.cc
+++ b/src/DLD-FUNCTIONS/__magick_read__.cc
@@ -398,19 +398,19 @@ maybe_initialize_magick (void)
 
       initialized = true;
     }
 #endif
 }
 
 DEFUN_DLD (__magick_read__, args, nargout,
   "-*- texinfo -*-\n\
-@deftypefn  {Function File} {@var{m} =} __magick_read__(@var{fname}, @var{index})\n\
-@deftypefnx {Function File} {[@var{m}, @var{colormap}] =} __magick_read__(@var{fname}, @var{index})\n\
-@deftypefnx {Function File} {[@var{m}, @var{colormap}, @var{alpha}] =} __magick_read__(@var{fname}, @var{index})\n\
+@deftypefn  {Function File} {@var{m} =} __magick_read__ (@var{fname}, @var{index})\n\
+@deftypefnx {Function File} {[@var{m}, @var{colormap}] =} __magick_read__ (@var{fname}, @var{index})\n\
+@deftypefnx {Function File} {[@var{m}, @var{colormap}, @var{alpha}] =} __magick_read__ (@var{fname}, @var{index})\n\
 Read images with ImageMagick++.  In general you should not be using this\n\
 function.  Instead use @code{imread}.\n\
 @seealso{imread}\n\
 @end deftypefn")
 {
   octave_value_list output;
 
 #ifdef HAVE_MAGICK
@@ -599,17 +599,17 @@ encode_bool_image (std::vector<Magick::I
 
   Array<octave_idx_type> idx (dim_vector (dsizes.length (), 1));
 
   octave_idx_type rows = m.rows ();
   octave_idx_type columns = m.columns ();
 
   for (unsigned int ii = 0; ii < nframes; ii++)
     {
-      Magick::Image im(Magick::Geometry (columns, rows), "black");
+      Magick::Image im (Magick::Geometry (columns, rows), "black");
       im.classType (Magick::DirectClass);
       im.depth (1);
 
       for (int y = 0; y < columns; y++)
         {
           idx(1) = y;
 
           for (int x = 0; x < rows; x++)
@@ -866,18 +866,18 @@ write_image (const std::string& filename
       error ("Magick++ exception: %s", e.what ());
     }
 }
 
 #endif
 
 DEFUN_DLD (__magick_write__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn  {Function File} {} __magick_write__(@var{fname}, @var{fmt}, @var{img})\n\
-@deftypefnx {Function File} {} __magick_write__(@var{fname}, @var{fmt}, @var{img}, @var{map})\n\
+@deftypefn  {Function File} {} __magick_write__ (@var{fname}, @var{fmt}, @var{img})\n\
+@deftypefnx {Function File} {} __magick_write__ (@var{fname}, @var{fmt}, @var{img}, @var{map})\n\
 Write images with ImageMagick++.  In general you should not be using this\n\
 function.  Instead use @code{imwrite}.\n\
 @seealso{imread}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_MAGICK
@@ -1002,17 +1002,17 @@ magick_to_octave_value (const Magick::Im
   catch (Magick::Warning& w) \
     { \
     }
 
 #endif
 
 DEFUN_DLD (__magick_finfo__, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Loadable Function} {} __magick_finfo__(@var{fname})\n\
+@deftypefn {Loadable Function} {} __magick_finfo__ (@var{fname})\n\
 Read image information with GraphicsMagick++.  In general you should\n\
 not be using this function.  Instead use @code{imfinfo}.\n\
 @seealso{imfinfo, imread}\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_MAGICK
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -383,31 +383,31 @@ DEFUN_DLD (besselj, args, nargout,
 @deftypefnx {Loadable Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})\n\
 @deftypefnx {Loadable Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})\n\
 Compute Bessel or Hankel functions of various kinds:\n\
 \n\
 @table @code\n\
 @item besselj\n\
 Bessel functions of the first kind.  If the argument @var{opt} is supplied,\n\
-the result is multiplied by @code{exp(-abs(imag(@var{x})))}.\n\
+the result is multiplied by @code{exp (-abs (imag (@var{x})))}.\n\
 \n\
 @item bessely\n\
 Bessel functions of the second kind.  If the argument @var{opt} is supplied,\n\
-the result is multiplied by @code{exp(-abs(imag(@var{x})))}.\n\
+the result is multiplied by @code{exp (-abs (imag (@var{x})))}.\n\
 \n\
 @item besseli\n\
 \n\
 Modified Bessel functions of the first kind.  If the argument @var{opt} is\n\
-supplied, the result is multiplied by @code{exp(-abs(real(@var{x})))}.\n\
+supplied, the result is multiplied by @code{exp (-abs (real (@var{x})))}.\n\
 \n\
 @item besselk\n\
 \n\
 Modified Bessel functions of the second kind.  If the argument @var{opt} is\n\
-supplied, the result is multiplied by @code{exp(@var{x})}.\n\
+supplied, the result is multiplied by @code{exp (@var{x})}.\n\
 \n\
 @item besselh\n\
 Compute Hankel functions of the first (@var{k} = 1) or second (@var{k}\n\
 = 2) kind.  If the argument @var{opt} is supplied, the result is multiplied\n\
 by @code{exp (-I*@var{x})} for @var{k} = 1 or @code{exp (I*@var{x})} for\n\
 @var{k} = 2.\n\
 @end table\n\
 \n\
@@ -528,18 +528,18 @@ Compute Airy functions of the first and 
 derivatives.\n\
 \n\
 @example\n\
 @group\n\
  K   Function   Scale factor (if 'opt' is supplied)\n\
 ---  --------   ---------------------------------------\n\
  0   Ai (Z)     exp ((2/3) * Z * sqrt (Z))\n\
  1   dAi(Z)/dZ  exp ((2/3) * Z * sqrt (Z))\n\
- 2   Bi (Z)     exp (-abs (real ((2/3) * Z *sqrt (Z))))\n\
- 3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z *sqrt (Z))))\n\
+ 2   Bi (Z)     exp (-abs (real ((2/3) * Z * sqrt (Z))))\n\
+ 3   dBi(Z)/dZ  exp (-abs (real ((2/3) * Z * sqrt (Z))))\n\
 @end group\n\
 @end example\n\
 \n\
 The function call @code{airy (@var{z})} is equivalent to\n\
 @code{airy (0, @var{z})}.\n\
 \n\
 The result is the same size as @var{z}.\n\
 \n\
@@ -1068,18 +1068,18 @@ Table 9.8 - I and K for integer orders 0
 %!         [ 0.2700464416   0.2065846495   0.2042345837   0.7595486903   0.9001744239   0.759126289  ];
 %!         [ 0.1835408126   0.1639722669   0.7002245988   0.5478075643   0.6002738588   0.132723593  ];
 %!         [ 0.1483158301   0.1380412115   0.111504840    0.4505236991   0.4796689336   0.57843541   ];
 %!         [ 0.1278333372   0.1212626814   0.103580801    0.3916319344   0.4107665704   0.47378525   ];
 %!         [ 0.1038995314   0.1003741751   0.090516308    0.3210023535   0.3315348950   0.36520701   ];
 %!         [ 0.0897803119   0.0875062222   0.081029690    0.2785448768   0.2854254970   0.30708743   ]];
 %!
 %! tbl = [besseli(n,z1,1), besselk(n,z1,1)];
-%! tbl(:,3) = tbl(:,3) .* (exp(z1).*z1.^(-2));
-%! tbl(:,6) = tbl(:,6) .* (exp(-z1).*z1.^(2));
+%! tbl(:,3) = tbl(:,3) .* (exp (z1) .* z1.^(-2));
+%! tbl(:,6) = tbl(:,6) .* (exp (-z1) .* z1.^(2));
 %! tbl = [tbl;[besseli(n,z2,1),besselk(n,z2,1)]];
 %!
 %! assert (tbl, rtbl, -2e-8);
 
 Table 9.9 - I and K for orders 3-9.
 
 %!test
 %! It = [[  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00  0.0000e+00];
@@ -1106,17 +1106,17 @@ Table 9.9 - I and K for orders 3-9.
 %!      [  3.7411e-01  4.5162e-01  5.7483e-01  7.7097e-01  1.0888e+00  1.6178e+00  2.5269e+00];
 %!      [  3.4684e-01  4.1114e-01  5.1130e-01  6.6679e-01  9.1137e-01  1.3048e+00  1.9552e+00]];
 %!
 %! n = (3:9);
 %! z = (0:2:20).';
 %! I = besseli (n,z,1);
 %! K = besselk (n,z,1);
 %!
-%! assert (abs (I(1,:)), zeros (1, columns(I)));
+%! assert (abs (I(1,:)), zeros (1, columns (I)));
 %! assert (I(2:end,:), It(2:end,:), -5e-5);
 %! assert (Kt(1,:), K(1,:));
 %! assert (K(2:end,:), Kt(2:end,:), -5e-5);
 
 Table 9.11 - I and K for various integer orders and arguments.
 
 %!test
 %! It = [[   1.266065878e+00    2.279585302e+00    2.723987182e+01    2.815716628e+03     2.93255378e+20     1.07375171e+42 ];
@@ -1149,17 +1149,17 @@ Table 9.11 - I and K for various integer
 The next section checks that negative integer orders and positive
 integer orders are appropriately related.
 
 %!test
 %! n = (0:2:20);
 %! assert (besselj (n,1), besselj (-n,1), 1e-8);
 %! assert (-besselj (n+1,1), besselj (-n-1,1), 1e-8);
 
-besseli(n,z) = besseli(-n,z);
+besseli (n,z) = besseli (-n,z);
 
 %!test
 %! n = (0:2:20);
 %! assert (besseli (n,1), besseli (-n,1), 1e-8);
 
 Table 10.1 - j and y for integer orders 0, 1, 2.
 Compare against excerpts of Table 10.1, Abramowitz and Stegun.
 
@@ -1174,32 +1174,32 @@ Compare against excerpts of Table 10.1, 
 %!       [   -5.4402e-02      7.8467e-02     7.7942e-02 ]];
 %!
 %! yt = [[-9.9500417e+00  -1.0049875e+02 -3.0050125e+03 ];
 %!       [ 3.2045745e-01  -1.1120588e-01 -4.5390450e-01 ];
 %!       [-5.6732437e-02   1.8043837e-01  1.6499546e-01 ];
 %!       [   -4.6218e-02     -1.3123e-01    -6.2736e-03 ];
 %!       [    8.3907e-02      6.2793e-02    -6.5069e-02 ]];
 %!
-%! j = sqrt((pi/2)./z).*besselj(n+1/2,z);
-%! y = sqrt((pi/2)./z).*bessely(n+1/2,z);
-%! assert(jt, j, -5e-5);
-%! assert(yt, y, -5e-5);
+%! j = sqrt ((pi/2)./z) .* besselj (n+1/2,z);
+%! y = sqrt ((pi/2)./z) .* bessely (n+1/2,z);
+%! assert (jt, j, -5e-5);
+%! assert (yt, y, -5e-5);
 
 Table 10.2 - j and y for orders 3-8.
 Compare against excerpts of Table 10.2, Abramowitzh and Stegun.
 
  Important note: In A&S, y_4(0.1) = -1.0507e+7, but Octave returns
- y_4(0.1) = -1.0508e+07 (-10507503.75). If I compute the same term using
+ y_4(0.1) = -1.0508e+07 (-10507503.75).  If I compute the same term using
  a series, the difference is in the eighth significant digit so I left
  the Octave results in place.
 
 %!test
 %! n = (3:8);
-%! z = (0:2.5:10).';  z(1)=0.1;
+%! z = (0:2.5:10).';  z(1) = 0.1;
 %!
 %! jt = [[ 9.5185e-06  1.0577e-07  9.6163e-10  7.3975e-12  4.9319e-14  2.9012e-16];
 %!       [ 1.0392e-01  3.0911e-02  7.3576e-03  1.4630e-03  2.5009e-04  3.7516e-05];
 %!       [ 2.2982e-01  1.8702e-01  1.0681e-01  4.7967e-02  1.7903e-02  5.7414e-03];
 %!       [-6.1713e-02  7.9285e-02  1.5685e-01  1.5077e-01  1.0448e-01  5.8188e-02];
 %!       [-3.9496e-02 -1.0559e-01 -5.5535e-02  4.4501e-02  1.1339e-01  1.2558e-01]];
 %!
 %! yt = [[-1.5015e+05 -1.0508e+07 -9.4553e+08 -1.0400e+11 -1.3519e+13 -2.0277e+15];
diff --git a/src/DLD-FUNCTIONS/bsxfun.cc b/src/DLD-FUNCTIONS/bsxfun.cc
--- a/src/DLD-FUNCTIONS/bsxfun.cc
+++ b/src/DLD-FUNCTIONS/bsxfun.cc
@@ -228,19 +228,19 @@ maybe_update_column (octave_value& Ac, c
   octave_idx_type nd = dva.length ();
 
   if (i == 0)
     {
       idx(0) = octave_value (':');
       for (octave_idx_type j = 1; j < nd; j++)
         {
           if (dva (j) == 1)
-            idx (j) = octave_value (1);
+            idx(j) = octave_value (1);
           else
-            idx (j) = octave_value ((i % dvc(j)) + 1);
+            idx(j) = octave_value ((i % dvc(j)) + 1);
 
           i = i / dvc (j);
         }
 
       Ac = A;
       Ac = Ac.single_subsref ("(", idx);
       return true;
     }
@@ -780,18 +780,18 @@ dimensionality as the other array.\n\
 %! float_types = {@single, @double};
 %! int_types = {@int8, @int16, @int32, @int64, \
 %!              @uint8, @uint16, @uint32, @uint64};
 %!
 %! x = rand (3) * 10-5;
 %! y = rand (3,1) * 10-5;
 %!
 %! for i=1:length (funs)
-%!   for j = 1:length(float_types)
-%!     for k = 1:length(int_types)
+%!   for j = 1:length (float_types)
+%!     for k = 1:length (int_types)
 %!
 %!       fun = funs{i};
 %!       f_type = float_types{j};
 %!       i_type = int_types{k};
 %!
 %!         assert (bsxfun (fun, f_type (x), i_type (y)), \
 %!                 fun (f_type(x), i_type (y)));
 %!         assert (bsxfun (fun, f_type (y), i_type (x)), \
diff --git a/src/DLD-FUNCTIONS/ccolamd.cc b/src/DLD-FUNCTIONS/ccolamd.cc
--- a/src/DLD-FUNCTIONS/ccolamd.cc
+++ b/src/DLD-FUNCTIONS/ccolamd.cc
@@ -98,17 +98,17 @@ if nonzero, statistics and knobs are pri
 @end table\n\
 \n\
 @var{cmember} is an optional vector of length @math{n}.  It defines the\n\
 constraints on the column ordering.  If @code{@var{cmember}(j) = @var{c}},\n\
 then column @var{j} is in constraint set @var{c} (@var{c} must be in the\n\
 range 1 to\n\
 n).  In the output permutation @var{p}, all columns in set 1 appear\n\
 first, followed by all columns in set 2, and so on.  @code{@var{cmember} =\n\
-ones(1,n)} if not present or empty.\n\
+ones (1,n)} if not present or empty.\n\
 @code{ccolamd (@var{S}, [], 1 : n)} returns @code{1 : n}\n\
 \n\
 @code{@var{p} = ccolamd (@var{S})} is about the same as\n\
 @code{@var{p} = colamd (@var{S})}.  @var{knobs} and its default values\n\
 differ.  @code{colamd} always does aggressive absorption, and it finds an\n\
 ordering suitable for both @code{lu (@var{S}(:, @var{p}))} and @code{chol\n\
 (@var{S}(:, @var{p})' * @var{S}(:, @var{p}))}; it cannot optimize its\n\
 ordering for @code{lu (@var{S}(:, @var{p}))} to the extent that\n\
@@ -176,33 +176,33 @@ colamd, symamd, and other related orderi
 
           // print knob settings if spumoni is set
           if (spumoni)
             {
               octave_stdout << "\nccolamd version " << CCOLAMD_MAIN_VERSION << "."
                             <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE
                             << ":\nknobs(1): " << User_knobs (0) << ", order for ";
               if ( knobs [CCOLAMD_LU] != 0)
-                octave_stdout << "lu(A)\n";
+                octave_stdout << "lu (A)\n";
               else
-                octave_stdout << "chol(A'*A)\n";
+                octave_stdout << "chol (A'*A)\n";
 
               if (knobs [CCOLAMD_DENSE_ROW] >= 0)
                 octave_stdout << "knobs(2): " << User_knobs (1)
-                              << ", rows with > max(16,"
-                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
+                              << ", rows with > max (16,"
+                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(2): " << User_knobs (1)
                               << ", no dense rows removed\n";
 
               if (knobs [CCOLAMD_DENSE_COL] >= 0)
                 octave_stdout << "knobs(3): " << User_knobs (2)
-                              << ", cols with > max(16,"
-                              << knobs [CCOLAMD_DENSE_COL] << "*sqrt(size(A)))"
+                              << ", cols with > max (16,"
+                              << knobs [CCOLAMD_DENSE_COL] << "*sqrt (size(A)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(3): " << User_knobs (2)
                               << ", no dense columns removed\n";
 
               if (knobs [CCOLAMD_AGGRESSIVE] != 0)
                 octave_stdout << "knobs(4): " << User_knobs(3)
                               << ", aggressive absorption: yes";
@@ -297,17 +297,17 @@ colamd, symamd, and other related orderi
               error ("ccolamd: internal error!");
               return retval;
             }
         }
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = p [i] + 1;
+        out_perm(i) = p[i] + 1;
 
       retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
         CCOLAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
@@ -367,21 +367,21 @@ If nonzero, aggressive absorption is per
 If nonzero, statistics and knobs are printed.\n\
 \n\
 @end table\n\
 \n\
 @var{cmember} is an optional vector of length n. It defines the constraints\n\
 on the ordering.  If @code{@var{cmember}(j) = @var{S}}, then row/column j is\n\
 in constraint set @var{c} (@var{c} must be in the range 1 to n).  In the\n\
 output permutation @var{p}, rows/columns in set 1 appear first, followed\n\
-by all rows/columns in set 2, and so on.  @code{@var{cmember} = ones(1,n)}\n\
-if not present or empty.  @code{csymamd(@var{S},[],1:n)} returns @code{1:n}.\n\
+by all rows/columns in set 2, and so on.  @code{@var{cmember} = ones (1,n)}\n\
+if not present or empty.  @code{csymamd (@var{S},[],1:n)} returns @code{1:n}.\n\
 \n\
-@code{@var{p} = csymamd(@var{S})} is about the same as @code{@var{p} =\n\
-symamd(@var{S})}.  @var{knobs} and its default values differ.\n\
+@code{@var{p} = csymamd (@var{S})} is about the same as @code{@var{p} =\n\
+symamd (@var{S})}.  @var{knobs} and its default values differ.\n\
 \n\
 @code{@var{stats}(4:7)} provide information if CCOLAMD was able to\n\
 continue.  The matrix is OK if @code{@var{stats}(4)} is zero, or 1 if\n\
 invalid.  @code{@var{stats}(5)} is the rightmost column index that is\n\
 unsorted or contains duplicate entries, or zero if no such column exists.\n\
 @code{@var{stats}(6)} is the last seen duplicate or out-of-order row\n\
 index in the column index given by @code{@var{stats}(5)}, or zero if no\n\
 such row index exists.  @code{@var{stats}(7)} is the number of duplicate\n\
@@ -428,18 +428,18 @@ colamd, symamd, and other related orderi
           // print knob settings if spumoni is set
           if (spumoni)
             {
               octave_stdout << "\ncsymamd version " << CCOLAMD_MAIN_VERSION << "."
                             <<  CCOLAMD_SUB_VERSION << ", " << CCOLAMD_DATE << "\n";
 
               if (knobs [CCOLAMD_DENSE_ROW] >= 0)
                 octave_stdout << "knobs(1): " << User_knobs (0)
-                              << ", rows/cols with > max(16,"
-                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
+                              << ", rows/cols with > max (16,"
+                              << knobs [CCOLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(1): " << User_knobs (0)
                               << ", no dense rows/cols removed\n";
 
               if (knobs [CCOLAMD_AGGRESSIVE] != 0)
                 octave_stdout << "knobs(2): " << User_knobs(1)
                               << ", aggressive absorption: yes";
@@ -529,17 +529,17 @@ colamd, symamd, and other related orderi
               error ("csymamd: internal error!") ;
               return retval;
             }
         }
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = perm [i] + 1;
+        out_perm(i) = perm[i] + 1;
 
       retval(0) = out_perm;
 
       // Return the stats vector
       if (nargout == 2)
         {
           NDArray out_stats (dim_vector (1, CCOLAMD_STATS));
           for (octave_idx_type i = 0 ; i < CCOLAMD_STATS ; i++)
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -111,69 +111,69 @@ try_cellfun_internal_ops (const octave_v
   const Cell f_args = args(1).cell_value ();
 
   octave_idx_type k = f_args.numel ();
 
   if (name == "isempty")
     {
       boolNDArray result (f_args.dims ());
       for (octave_idx_type count = 0; count < k; count++)
-        result(count) = f_args.elem(count).is_empty ();
+        result(count) = f_args.elem (count).is_empty ();
       retval(0) = result;
     }
   else if (name == "islogical")
     {
       boolNDArray result (f_args.dims ());
       for (octave_idx_type  count= 0; count < k; count++)
-        result(count) = f_args.elem(count).is_bool_type ();
+        result(count) = f_args.elem (count).is_bool_type ();
       retval(0) = result;
     }
   else if (name == "isreal")
     {
       boolNDArray result (f_args.dims ());
       for (octave_idx_type  count= 0; count < k; count++)
-        result(count) = f_args.elem(count).is_real_type ();
+        result(count) = f_args.elem (count).is_real_type ();
       retval(0) = result;
     }
   else if (name == "length")
     {
       NDArray result (f_args.dims ());
       for (octave_idx_type  count= 0; count < k; count++)
-        result(count) = static_cast<double> (f_args.elem(count).length ());
+        result(count) = static_cast<double> (f_args.elem (count).length ());
       retval(0) = result;
     }
   else if (name == "ndims")
     {
       NDArray result (f_args.dims ());
       for (octave_idx_type count = 0; count < k; count++)
-        result(count) = static_cast<double> (f_args.elem(count).ndims ());
+        result(count) = static_cast<double> (f_args.elem (count).ndims ());
       retval(0) = result;
     }
   else if (name == "prodofsize" || name == "numel")
     {
       NDArray result (f_args.dims ());
       for (octave_idx_type count = 0; count < k; count++)
-        result(count) = static_cast<double> (f_args.elem(count).numel ());
+        result(count) = static_cast<double> (f_args.elem (count).numel ());
       retval(0) = result;
     }
   else if (name == "size")
     {
       if (nargin == 3)
         {
           int d = args(2).nint_value () - 1;
 
           if (d < 0)
             error ("cellfun: K must be a positive integer");
 
           if (! error_state)
             {
               NDArray result (f_args.dims ());
               for (octave_idx_type count = 0; count < k; count++)
                 {
-                  dim_vector dv = f_args.elem(count).dims ();
+                  dim_vector dv = f_args.elem (count).dims ();
                   if (d < dv.length ())
                     result(count) = static_cast<double> (dv(d));
                   else
                     result(count) = 1.0;
                 }
               retval(0) = result;
             }
         }
@@ -182,17 +182,17 @@ try_cellfun_internal_ops (const octave_v
     }
   else if (name == "isclass")
     {
       if (nargin == 3)
         {
           std::string class_name = args(2).string_value ();
           boolNDArray result (f_args.dims ());
           for (octave_idx_type count = 0; count < k; count++)
-            result(count) = (f_args.elem(count).class_name () == class_name);
+            result(count) = (f_args.elem (count).class_name () == class_name);
 
           retval(0) = result;
         }
       else
         error ("cellfun: not enough arguments for \"isclass\"");
     }
 
   return retval;
@@ -312,17 +312,17 @@ arguments of the function.  The outputs 
 into the output arguments of @code{cellfun} like this:\n\
 \n\
 @example\n\
 @group\n\
 function [a, b] = twoouts (x)\n\
   a = x;\n\
   b = x*x;\n\
 endfunction\n\
-[aa, bb] = cellfun(@@twoouts, @{1, 2, 3@})\n\
+[aa, bb] = cellfun (@@twoouts, @{1, 2, 3@})\n\
      @result{}\n\
         aa =\n\
            1 2 3\n\
         bb =\n\
            1 4 9\n\
 @end group\n\
 @end example\n\
 \n\
@@ -370,17 +370,17 @@ useful tool for avoiding loops.  It is o
 function handles; however, calling an anonymous function involves an\n\
 overhead quite comparable to the overhead of an m-file function.\n\
 Passing a handle to a built-in function is faster, because the\n\
 interpreter is not involved in the internal loop.  For example:\n\
 \n\
 @example\n\
 @group\n\
 a = @{@dots{}@}\n\
-v = cellfun (@@(x) det(x), a); # compute determinants\n\
+v = cellfun (@@(x) det (x), a); # compute determinants\n\
 v = cellfun (@@det, a); # faster\n\
 @end group\n\
 @end example\n\
 \n\
 @seealso{arrayfun, structfun, spfun}\n\
 @end deftypefn")
 {
   octave_value_list retval;
@@ -762,17 +762,17 @@ v = cellfun (@@det, a); # faster\n\
 %! assert (A, [true, false, true, false]);
 %!test
 %! A = cellfun (inline ("islogical (x)", "x"), {true, 0.1, false, i*2});
 %! assert (A, [true, false, true, false]);
 %!test
 %! A = cellfun (@islogical, {true, 0.1, false, i*2});
 %! assert (A, [true, false, true, false]);
 %!test
-%! A = cellfun (@(x) islogical(x), {true, 0.1, false, i*2});
+%! A = cellfun (@(x) islogical (x), {true, 0.1, false, i*2});
 %! assert (A, [true, false, true, false]);
 
 %% First input argument can be the special string "isreal",
 %% "isempty", "islogical", "length", "ndims" or "prodofsize"
 %!test
 %! A = cellfun ("isreal", {true, 0.1, {}, i*2, [], "abc"});
 %! assert (A, [true, true, false, false, true, true]);
 %!test
@@ -859,26 +859,26 @@ v = cellfun (@@det, a); # faster\n\
 %! assert (isequal (A{1}, [1.1, 2.1, 3.1]));
 %! assert (isequal (A{2}, [4, 5, 6]));
 %!test %% Three ouptut arguments of different type
 %! [A, B, C] = cellfun (@find, {10, 11; 0, 12}, "UniformOutput", false);
 %! assert (isequal (A, {true, true; [], true}));
 %! assert (isequal (B, {true, true; [], true}));
 %! assert (isequal (C, {10, 11; [], 12}));
 %!test
-%! A = cellfun (@(x,y) cell2str(x,y), {1.1, 4}, {3.1, 6}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {1.1, 4}, {3.1, 6}, \
 %!              "ErrorHandler", @__cellfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = cellfun (@(x,y) cell2str(x,y), {1.1, 4}, {3.1, 6}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {1.1, 4}, {3.1, 6}, \
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
@@ -887,25 +887,25 @@ v = cellfun (@@det, a); # faster\n\
 %! A = cellfun (@(x,y) x>y, {"ad", "c", "ghi"}, {"cc", "d", "fgh"});
 %!test
 %! A = cellfun (@(x,y) x>y, {"a"; "f"}, {"c"; "d"}, "UniformOutput", true);
 %! assert (A, [false; true]);
 %!test
 %! A = cellfun (@(x,y) x:y, {"a", "d"}, {"c", "f"}, "UniformOutput", false);
 %! assert (A, {"abc", "def"});
 %!test
-%! A = cellfun (@(x,y) cell2str(x,y), {"a", "d"}, {"c", "f"}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {"a", "d"}, {"c", "f"}, \
 %!              "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = cellfun (@(x,y) cell2str(x,y), {"a", "d"}, {"c", "f"}, \
+%! A = cellfun (@(x,y) cell2str (x,y), {"a", "d"}, {"c", "f"}, \
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Structures cannot be handled by cellfun
@@ -921,25 +921,25 @@ v = cellfun (@@det, a); # faster\n\
 %! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}; {4.2}}, {{3.1}; {2}}, \
 %!              "UniformOutput", true);
 %! assert (A, [1; 0], 1e-16);
 %!test
 %! A = cellfun (@(x,y) x{1} < y{1}, {{1.1}, {4.2}}, {{3.1}, {2}}, \
 %!              "UniformOutput", false);
 %! assert (A, {true, false});
 %!test
-%! A = cellfun (@(x,y) mat2str(x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
+%! A = cellfun (@(x,y) mat2str (x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
 %!              "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = cellfun (@(x,y) mat2str(x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
+%! A = cellfun (@(x,y) mat2str (x,y), {{1.1}, {4.2}}, {{3.1}, {2}}, \
 %!              "UniformOutput", true, "ErrorHandler", @__cellfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
 %% Input arguments can be of type cell array of structure arrays
@@ -1484,17 +1484,17 @@ arrayfun (@@str2num, [1234],\n\
 %! assert (A, [false, true]);
 %!test
 %! A = arrayfun (inline ("(x == y)", "x", "y"), [false, true], [true, true]);
 %! assert (A, [false, true]);
 %!test
 %! A = arrayfun (@isequal, [false, true], [true, true]);
 %! assert (A, [false, true]);
 %!test
-%! A = arrayfun (@(x,y) isequal(x,y), [false, true], [true, true]);
+%! A = arrayfun (@(x,y) isequal (x,y), [false, true], [true, true]);
 %! assert (A, [false, true]);
 
 %% Number of input and output arguments may be greater than one
 %#!test
 %! A = arrayfun (@(x) islogical (x), false);
 %! assert (A, true);
 %!test
 %! A = arrayfun (@(x,y,z) x + y + z, [1, 1, 1], [2, 2, 2], [3, 4, 5]);
@@ -1556,26 +1556,26 @@ arrayfun (@@str2num, [1234],\n\
 %! assert (isequal (A{1}, [1.1, 2.1, 3.1]));
 %! assert (isequal (A{2}, [4, 5, 6]));
 %!test %% Three ouptut arguments of different type
 %! [A, B, C] = arrayfun (@find, [10, 11; 0, 12], "UniformOutput", false);
 %! assert (isequal (A, {true, true; [], true}));
 %! assert (isequal (B, {true, true; [], true}));
 %! assert (isequal (C, {10, 11; [], 12}));
 %!test
-%! A = arrayfun (@(x,y) array2str(x,y), {1.1, 4}, {3.1, 6}, \
+%! A = arrayfun (@(x,y) array2str (x,y), {1.1, 4}, {3.1, 6}, \
 %!               "ErrorHandler", @__arrayfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test %% Overwriting setting of "UniformOutput" true
-%! A = arrayfun (@(x,y) array2str(x,y), {1.1, 4}, {3.1, 6}, \
+%! A = arrayfun (@(x,y) array2str (x,y), {1.1, 4}, {3.1, 6}, \
 %!               "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %! B = isfield (A(1), "message") && isfield (A(1), "index");
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 
@@ -1585,17 +1585,17 @@ arrayfun (@@str2num, [1234],\n\
 %! assert (A, [false, true, false, true, true, true]);
 %!test
 %! A = arrayfun (@(x,y) x>y, ["a"; "f"], ["c"; "d"], "UniformOutput", true);
 %! assert (A, [false; true]);
 %!test
 %! A = arrayfun (@(x,y) x:y, ["a", "d"], ["c", "f"], "UniformOutput", false);
 %! assert (A, {"abc", "def"});
 %!test
-%! A = arrayfun (@(x,y) cell2str(x,y), ["a", "d"], ["c", "f"], \
+%! A = arrayfun (@(x,y) cell2str (x,y), ["a", "d"], ["c", "f"], \
 %!               "ErrorHandler", @__arrayfunerror);
 %! B = isfield (A(1), "identifier") && isfield (A(1), "message") && isfield (A(1), "index");
 %! assert (B, true);
 
 %% Input arguments can be of type structure
 %!test
 %! a = struct ("a", 1.1, "b", 4.2);  b = struct ("a", 3.1, "b", 2);
 %! A = arrayfun (@(x,y) (x.a < y.a) && (x.b > y.b), a, b);
@@ -1637,17 +1637,17 @@ arrayfun (@@str2num, [1234],\n\
 %!test
 %! A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, "ErrorHandler", @__arrayfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 %!test
-%! A = arrayfun (@(x,y) num2str(x,y), {1.1, 4.2}, {3.1, 2}, \
+%! A = arrayfun (@(x,y) num2str (x,y), {1.1, 4.2}, {3.1, 2}, \
 %!               "UniformOutput", true, "ErrorHandler", @__arrayfunerror);
 %! assert ([(isfield (A(1), "identifier")), (isfield (A(2), "identifier"))], [true, true]);
 %! assert ([(isfield (A(1), "message")), (isfield (A(2), "message"))], [true, true]);
 %! assert ([(isfield (A(1), "index")), (isfield (A(2), "index"))], [true, true]);
 %! assert ([(isempty (A(1).message)), (isempty (A(2).message))], [false, false]);
 %! assert ([A(1).index, A(2).index], [1, 2]);
 */
 
@@ -1785,17 +1785,17 @@ do_object2cell (const octave_value& obj,
           octave_value_list idx (1);
 
           for (octave_idx_type i = 0; i < dv.numel (); i++)
             {
               octave_quit ();
 
               idx(0) = double (i+1);
 
-              retval.xelem(i) = array.single_subsref ("(", idx);
+              retval.xelem (i) = array.single_subsref ("(", idx);
 
               if (error_state)
                 break;
             }
         }
     }
   else
     {
diff --git a/src/DLD-FUNCTIONS/chol.cc b/src/DLD-FUNCTIONS/chol.cc
--- a/src/DLD-FUNCTIONS/chol.cc
+++ b/src/DLD-FUNCTIONS/chol.cc
@@ -367,21 +367,21 @@ sparse matrices.\n\
         }
     }
 
   return retval;
 }
 
 /*
 %!assert (chol ([2, 1; 1, 1]), [sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)], sqrt (eps))
-%!assert (chol (single([2, 1; 1, 1])), single([sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)]), sqrt (eps ("single")))
+%!assert (chol (single ([2, 1; 1, 1])), single ([sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)]), sqrt (eps ("single")))
 
+%!error chol ()
 %!error <matrix must be positive definite> chol ([1, 2; 3, 4])
 %!error <requires square matrix> chol ([1, 2; 3, 4; 5, 6])
-%!error chol ()
 %!error <unexpected second or third input> chol (1, 2)
 */
 
 DEFUN_DLD (cholinv, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} cholinv (@var{A})\n\
 Use the Cholesky@tie{}factorization to compute the inverse of the\n\
 symmetric positive definite matrix @var{A}.\n\
@@ -984,17 +984,17 @@ If @var{info} is not present, an error m
 
 %!test
 %! u2 = single ([  0.35080 ;
 %!                 0.63930 ;
 %!                 3.31057 ;
 %!                -0.13825 ;
 %!                 0.45266 ]);
 %!
-%! R = chol(single(A));
+%! R = chol (single (A));
 %!
 %! j = 3;  p = [1:j-1, j+1:5];
 %! R1 = cholinsert (R, j, u2);
 %! A1 = R1'*R1;
 %!
 %! assert (norm (triu (R1)-R1, Inf), single (0));
 %! assert (norm (A1(p,p) - A, Inf) < 1e1*eps ("single"));
 
@@ -1178,17 +1178,17 @@ triangular, return the Cholesky@tie{}fac
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
-%! R = chol(A);
+%! R = chol (A);
 %!
 %! j = 3;  p = [1:j-1,j+1:4];
 %! R1 = choldelete (R, j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), 0);
 %! assert (norm (R1'*R1 - A(p,p), Inf) < 1e1*eps);
 
 %!test
@@ -1205,20 +1205,20 @@ triangular, return the Cholesky@tie{}fac
 %!
 %! j = 3;  p = [1:j-1,j+1:4];
 %! R1 = choldelete (R, j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), single (0));
 %! assert (norm (R1'*R1 - single (A(p,p)), Inf) < 1e1*eps ("single"));
 
 %!test
-%! R = chol(single(Ac));
+%! R = chol (single (Ac));
 %!
 %! j = 3;  p = [1:j-1,j+1:4];
-%! R1 = choldelete(R,j);
+%! R1 = choldelete (R,j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), single (0));
 %! assert (norm (R1'*R1 - single (Ac(p,p)), Inf) < 1e1*eps ("single"));
 */
 
 DEFUN_DLD (cholshift, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{R1} =} cholshift (@var{R}, @var{i}, @var{j})\n\
@@ -1330,18 +1330,18 @@ triangular, return the Cholesky@tie{}fac
 %! R1 = cholshift (R, i, j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), 0);
 %! assert (norm (R1'*R1 - A(p,p), Inf) < 1e1*eps);
 %!
 %! j = 1;  i = 3;  p = [1:j-1, shift(j:i,+1), i+1:4];
 %! R1 = cholshift (R, i, j);
 %!
-%! assert (norm(triu(R1)-R1, Inf), 0);
-%! assert (norm(R1'*R1 - A(p,p), Inf) < 1e1*eps);
+%! assert (norm (triu (R1) - R1, Inf), 0);
+%! assert (norm (R1'*R1 - A(p,p), Inf) < 1e1*eps);
 
 %!test
 %! R = chol (Ac);
 %!
 %! i = 1;  j = 3;  p = [1:i-1, shift(i:j,-1), j+1:4];
 %! R1 = cholshift (R, i, j);
 %!
 %! assert (norm (triu (R1)-R1, Inf), 0);
diff --git a/src/DLD-FUNCTIONS/colamd.cc b/src/DLD-FUNCTIONS/colamd.cc
--- a/src/DLD-FUNCTIONS/colamd.cc
+++ b/src/DLD-FUNCTIONS/colamd.cc
@@ -221,17 +221,17 @@ degree permutation vector for the sparse
 non-symmetric matrix @var{S}, @code{@var{S}(:,@var{p})} tends to have\n\
 sparser LU@tie{}factors than @var{S}.  The Cholesky@tie{}factorization of\n\
 @code{@var{S}(:,@var{p})' * @var{S}(:,@var{p})} also tends to be sparser\n\
 than that of @code{@var{S}' * @var{S}}.\n\
 \n\
 @var{knobs} is an optional one- to three-element input vector.  If @var{S} is\n\
 m-by-n, then rows with more than @code{max(16,@var{knobs}(1)*sqrt(n))}\n\
 entries are ignored.  Columns with more than\n\
-@code{max(16,@var{knobs}(2)*sqrt(min(m,n)))} entries are removed prior to\n\
+@code{max (16,@var{knobs}(2)*sqrt(min(m,n)))} entries are removed prior to\n\
 ordering, and ordered last in the output permutation @var{p}.  Only\n\
 completely dense rows or columns are removed if @code{@var{knobs}(1)} and\n\
 @code{@var{knobs}(2)} are < 0, respectively.  If @code{@var{knobs}(3)} is\n\
 nonzero, @var{stats} and @var{knobs} are printed.  The default is\n\
 @code{@var{knobs} = [10 10 0]}.  Note that @var{knobs} differs from earlier\n\
 versions of colamd.\n\
 \n\
 @var{stats} is an optional 20-element output vector that provides data\n\
@@ -309,27 +309,27 @@ Ng, Oak Ridge National Laboratory.  (see
           if (spumoni)
             {
 
               octave_stdout << "\ncolamd version " << COLAMD_MAIN_VERSION << "."
                             <<  COLAMD_SUB_VERSION << ", " << COLAMD_DATE << ":\n";
 
               if (knobs [COLAMD_DENSE_ROW] >= 0)
                 octave_stdout << "knobs(1): " << User_knobs (0)
-                              << ", rows with > max(16,"
-                              << knobs [COLAMD_DENSE_ROW] << "*sqrt(size(A,2)))"
+                              << ", rows with > max (16,"
+                              << knobs [COLAMD_DENSE_ROW] << "*sqrt (size(A,2)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(1): " << User_knobs (0)
                               << ", only completely dense rows removed\n";
 
               if (knobs [COLAMD_DENSE_COL] >= 0)
                 octave_stdout << "knobs(2): " << User_knobs (1)
-                              << ", cols with > max(16,"
-                              << knobs [COLAMD_DENSE_COL] << "*sqrt(size(A)))"
+                              << ", cols with > max (16,"
+                              << knobs [COLAMD_DENSE_COL] << "*sqrt (size(A)))"
                               << " entries removed\n";
               else
                 octave_stdout << "knobs(2): " << User_knobs (1)
                               << ", only completely dense columns removed\n";
 
               octave_stdout << "knobs(3): " << User_knobs (2)
                             << ", statistics and knobs printed\n";
 
@@ -410,17 +410,17 @@ Ng, Oak Ridge National Laboratory.  (see
       coletree (ridx, colbeg, colend, etree, n_row, n_col);
 
       // Calculate the tree post-ordering
       tree_postorder (n_col, etree, colbeg);
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = p [colbeg [i]] + 1;
+        out_perm(i) = p[colbeg [i]] + 1;
 
       retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
         COLAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
@@ -459,17 +459,17 @@ For a symmetric positive definite matrix
 vector p such that @code{@var{S}(@var{p}, @var{p})} tends to have a\n\
 sparser Cholesky@tie{}factor than @var{S}.  Sometimes @code{symamd} works\n\
 well for symmetric indefinite matrices too.  The matrix @var{S} is assumed\n\
 to be symmetric; only the strictly lower triangular part is referenced.\n\
 @var{S} must be square.\n\
 \n\
 @var{knobs} is an optional one- to two-element input vector.  If @var{S} is\n\
 n-by-n, then rows and columns with more than\n\
-@code{max(16,@var{knobs}(1)*sqrt(n))} entries are removed prior to ordering,\n\
+@code{max (16,@var{knobs}(1)*sqrt(n))} entries are removed prior to ordering,\n\
 and ordered last in the output permutation @var{p}.  No rows/columns are\n\
 removed if @code{@var{knobs}(1) < 0}.  If @code{@var{knobs} (2)} is nonzero,\n\
 @code{stats} and @var{knobs} are printed.  The default is @code{@var{knobs}\n\
 = [10 0]}.  Note that @var{knobs} differs from earlier versions of symamd.\n\
 \n\
 @var{stats} is an optional 20-element output vector that provides data\n\
 about the ordering and the validity of the input matrix @var{S}.  Ordering\n\
 statistics are in @code{@var{stats}(1:3)}.  @code{@var{stats}(1) =\n\
@@ -603,17 +603,17 @@ Ng, Oak Ridge National Laboratory.  (see
 
       // Calculate the tree post-ordering
       OCTAVE_LOCAL_BUFFER (octave_idx_type, post, n_col + 1);
       tree_postorder (n_col, etree, post);
 
       // return the permutation vector
       NDArray out_perm (dim_vector (1, n_col));
       for (octave_idx_type i = 0; i < n_col; i++)
-        out_perm(i) = perm [post [i]] + 1;
+        out_perm(i) = perm[post [i]] + 1;
 
       retval(0) = out_perm;
 
       // print stats if spumoni > 0
       if (spumoni > 0)
         SYMAMD_NAME (_report) (stats) ;
 
       // Return the stats vector
diff --git a/src/DLD-FUNCTIONS/daspk.cc b/src/DLD-FUNCTIONS/daspk.cc
--- a/src/DLD-FUNCTIONS/daspk.cc
+++ b/src/DLD-FUNCTIONS/daspk.cc
@@ -316,17 +316,17 @@ parameters for @code{daspk}.\n\
               if (daspk_fcn)
                 {
                   if (c(1).is_function_handle () || c(1).is_inline_function ())
                     daspk_jac = c(1).function_value ();
                   else
                     {
                       jac_name = unique_symbol_name ("__daspk_jac__");
                       jname = "function jac = ";
-                      jname.append(jac_name);
+                      jname.append (jac_name);
                       jname.append (" (x, xdot, t, cj) jac = ");
                       daspk_jac = extract_function
                         (c(1), "daspk", jac_name, jname, "; endfunction");
 
                       if (!daspk_jac)
                         {
                           if (fcn_name.length ())
                             clear_function (fcn_name);
@@ -372,17 +372,17 @@ parameters for @code{daspk}.\n\
                         fname.append (" (x, xdot, t) y = ");
                         daspk_fcn = extract_function
                           (tmp(0), "daspk", fcn_name, fname, "; endfunction");
 
                         if (daspk_fcn)
                           {
                             jac_name = unique_symbol_name ("__daspk_jac__");
                             jname = "function jac = ";
-                            jname.append(jac_name);
+                            jname.append (jac_name);
                             jname.append (" (x, xdot, t, cj) jac = ");
                             daspk_jac = extract_function
                               (tmp(1), "daspk", jac_name, jname,
                                "; endfunction");
 
                             if (!daspk_jac)
                               {
                                 if (fcn_name.length ())
diff --git a/src/DLD-FUNCTIONS/dasrt.cc b/src/DLD-FUNCTIONS/dasrt.cc
--- a/src/DLD-FUNCTIONS/dasrt.cc
+++ b/src/DLD-FUNCTIONS/dasrt.cc
@@ -404,17 +404,17 @@ parameters for @code{dasrt}.\n\
           if (dasrt_f)
             {
               if (c(1).is_function_handle () || c(1).is_inline_function ())
                 dasrt_j = c(1).function_value ();
               else
                 {
                   jac_name = unique_symbol_name ("__dasrt_jac__");
                   jname = "function jac = ";
-                  jname.append(jac_name);
+                  jname.append (jac_name);
                   jname.append (" (x, xdot, t, cj) jac = ");
                   dasrt_j = extract_function
                     (c(1), "dasrt", jac_name, jname, "; endfunction");
 
                   if (!dasrt_j)
                     {
                       if (fcn_name.length ())
                         clear_function (fcn_name);
@@ -456,17 +456,17 @@ parameters for @code{dasrt}.\n\
                     fname.append (" (x, xdot, t) y = ");
                     dasrt_f = extract_function
                       (tmp(0), "dasrt", fcn_name, fname, "; endfunction");
 
                     if (dasrt_f)
                       {
                         jac_name = unique_symbol_name ("__dasrt_jac__");
                         jname = "function jac = ";
-                        jname.append(jac_name);
+                        jname.append (jac_name);
                         jname.append (" (x, xdot, t, cj) jac = ");
                         dasrt_j = extract_function
                           (tmp(1), "dasrt", jac_name, jname, "; endfunction");
 
                         if (! dasrt_j)
                           dasrt_f = 0;
                       }
                   }
diff --git a/src/DLD-FUNCTIONS/dassl.cc b/src/DLD-FUNCTIONS/dassl.cc
--- a/src/DLD-FUNCTIONS/dassl.cc
+++ b/src/DLD-FUNCTIONS/dassl.cc
@@ -317,17 +317,17 @@ parameters for @code{dassl}.\n\
               if (dassl_fcn)
                 {
                   if (c(1).is_function_handle () || c(1).is_inline_function ())
                     dassl_jac = c(1).function_value ();
                   else
                     {
                         jac_name = unique_symbol_name ("__dassl_jac__");
                         jname = "function jac = ";
-                        jname.append(jac_name);
+                        jname.append (jac_name);
                         jname.append (" (x, xdot, t, cj) jac = ");
                         dassl_jac = extract_function
                           (c(1), "dassl", jac_name, jname, "; endfunction");
 
                         if (!dassl_jac)
                           {
                             if (fcn_name.length ())
                               clear_function (fcn_name);
@@ -373,17 +373,17 @@ parameters for @code{dassl}.\n\
                         fname.append (" (x, xdot, t) y = ");
                         dassl_fcn = extract_function
                           (tmp(0), "dassl", fcn_name, fname, "; endfunction");
 
                         if (dassl_fcn)
                           {
                             jac_name = unique_symbol_name ("__dassl_jac__");
                             jname = "function jac = ";
-                            jname.append(jac_name);
+                            jname.append (jac_name);
                             jname.append (" (x, xdot, t, cj) jac = ");
                             dassl_jac = extract_function
                               (tmp(1), "dassl", jac_name, jname,
                                "; endfunction");
 
                             if (!dassl_jac)
                               {
                                 if (fcn_name.length ())
diff --git a/src/DLD-FUNCTIONS/dmperm.cc b/src/DLD-FUNCTIONS/dmperm.cc
--- a/src/DLD-FUNCTIONS/dmperm.cc
+++ b/src/DLD-FUNCTIONS/dmperm.cc
@@ -43,17 +43,17 @@ along with Octave; see the file COPYING.
 #define CXSPARSE_NAME(name) cs_di ## name
 #endif
 
 static RowVector
 put_int (octave_idx_type *p, octave_idx_type n)
 {
   RowVector ret (n);
   for (octave_idx_type i = 0; i < n; i++)
-    ret.xelem(i) = p[i] + 1;
+    ret.xelem (i) = p[i] + 1;
   return ret;
 }
 
 #if HAVE_CXSPARSE
 static octave_value_list
 dmperm_internal (bool rank, const octave_value arg, int nargout)
 {
   octave_value_list retval;
diff --git a/src/DLD-FUNCTIONS/fft.cc b/src/DLD-FUNCTIONS/fft.cc
--- a/src/DLD-FUNCTIONS/fft.cc
+++ b/src/DLD-FUNCTIONS/fft.cc
@@ -275,17 +275,17 @@ dimension of the matrix along which the 
 %%         Comalco Research and Technology
 %%         02 May 2000
 %!test
 %! N = 64;
 %! n = 7;
 %! t = 2*pi*(0:1:N-1)/N;
 %! s = cos (n*t);
 %!
-%! S = zeros (size(t));
+%! S = zeros (size (t));
 %! S(n+1) = N/2;
 %! S(N-n+1) = N/2;
 %!
 %! assert (ifft (S), s, 4*N*eps);
 
 %% Author: David Billinghurst (David.Billinghurst@riotinto.com.au)
 %%         Comalco Research and Technology
 %%         02 May 2000
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -711,19 +711,19 @@ filter (MArray<FloatComplex>&, MArray<Fl
 %!test
 %! a = [1,1];
 %! b=[1,1];
 %! x = zeros (4,4,2);  x(1,1:4,1) = +1;  x(1,1:4,2) = -1;
 %! y0 = zeros (4,4,2);  y0(1:2,1:4,1) = +1;  y0(1:2,1:4,2) = -1;
 %! y = filter (b, [1], x);
 %! assert (y, y0);
 
-%!assert (filter (1, ones(10,1)/10, []), [])
-%!assert (filter (1, ones(10,1)/10, zeros(0,10)), zeros(0,10))
-%!assert (filter (1, ones(10,1)/10, single (1:5)), repmat (single (10), 1, 5))
+%!assert (filter (1, ones (10,1) / 10, []), [])
+%!assert (filter (1, ones (10,1) / 10, zeros (0,10)), zeros (0,10))
+%!assert (filter (1, ones (10,1) / 10, single (1:5)), repmat (single (10), 1, 5))
 
 %% Test using initial conditions
 %!assert (filter ([1, 1, 1], [1, 1], [1 2], [1, 1]), [2 2])
 %!assert (filter ([1, 1, 1], [1, 1], [1 2], [1, 1]'), [2 2])
 %!assert (filter ([1, 3], [1], [1 2; 3 4; 5 6], [4, 5]), [5 7; 6 10; 14 18])
 %!error (filter ([1, 3], [1], [1 2; 3 4; 5 6], [4, 5]'))
 %!assert (filter ([1, 3, 2], [1], [1 2; 3 4; 5 6], [1 0 0; 1 0 0], 2), [2 6; 3 13; 5 21])
 
diff --git a/src/DLD-FUNCTIONS/find.cc b/src/DLD-FUNCTIONS/find.cc
--- a/src/DLD-FUNCTIONS/find.cc
+++ b/src/DLD-FUNCTIONS/find.cc
@@ -106,42 +106,42 @@ find_nonzero_elem_idx (const Sparse<T>& 
       n_to_find = nz;
       count = nz;
     }
   else if (direction > 0)
     {
       for (octave_idx_type j = 0; j < nc; j++)
         {
           OCTAVE_QUIT;
-          if (v.cidx(j) == 0 && v.cidx(j+1) != 0)
+          if (v.cidx (j) == 0 && v.cidx (j+1) != 0)
             start_nc = j;
-          if (v.cidx(j+1) >= n_to_find)
+          if (v.cidx (j+1) >= n_to_find)
             {
               end_nc = j + 1;
               break;
             }
         }
     }
   else
     {
       for (octave_idx_type j = nc; j > 0; j--)
         {
           OCTAVE_QUIT;
-          if (v.cidx(j) == nz && v.cidx(j-1) != nz)
+          if (v.cidx (j) == nz && v.cidx (j-1) != nz)
             end_nc = j;
-          if (nz - v.cidx(j-1) >= n_to_find)
+          if (nz - v.cidx (j-1) >= n_to_find)
             {
               start_nc = j - 1;
               break;
             }
         }
     }
 
-  count = (n_to_find > v.cidx(end_nc) - v.cidx(start_nc) ?
-           v.cidx(end_nc) - v.cidx(start_nc) : n_to_find);
+  count = (n_to_find > v.cidx (end_nc) - v.cidx (start_nc) ?
+           v.cidx (end_nc) - v.cidx (start_nc) : n_to_find);
 
   // If the original argument was a row vector, force a row vector of
   // the overall indices to be returned.  But see below for scalar
   // case...
 
   octave_idx_type result_nr = count;
   octave_idx_type result_nc = 1;
 
@@ -163,24 +163,24 @@ find_nonzero_elem_idx (const Sparse<T>& 
   Array<T> val (dim_vector (result_nr, result_nc));
 
   if (count > 0)
     {
       // Search for elements to return.  Only search the region where
       // there are elements to be found using the count that we want
       // to find.
       for (octave_idx_type j = start_nc, cx = 0; j < end_nc; j++)
-        for (octave_idx_type i = v.cidx(j); i < v.cidx(j+1); i++ )
+        for (octave_idx_type i = v.cidx (j); i < v.cidx (j+1); i++ )
           {
             OCTAVE_QUIT;
             if (direction < 0 && i < nz - count)
               continue;
-            i_idx(cx) = static_cast<double> (v.ridx(i) + 1);
+            i_idx(cx) = static_cast<double> (v.ridx (i) + 1);
             j_idx(cx) = static_cast<double> (j + 1);
-            idx(cx) = j * nr + v.ridx(i) + 1;
+            idx(cx) = j * nr + v.ridx (i) + 1;
             val(cx) = v.data(i);
             cx++;
             if (cx == count)
               break;
           }
     }
   else if (scalar_arg)
     {
diff --git a/src/DLD-FUNCTIONS/gcd.cc b/src/DLD-FUNCTIONS/gcd.cc
--- a/src/DLD-FUNCTIONS/gcd.cc
+++ b/src/DLD-FUNCTIONS/gcd.cc
@@ -71,18 +71,18 @@ divide (const std::complex<FP>& a, const
 
   r = a - q*b;
 }
 
 template <typename FP>
 static std::complex<FP>
 simple_gcd (const std::complex<FP>& a, const std::complex<FP>& b)
 {
-  if (! xisinteger (a.real ()) || ! xisinteger(a.imag ())
-      || ! xisinteger (b.real ()) || ! xisinteger(b.imag ()))
+  if (! xisinteger (a.real ()) || ! xisinteger (a.imag ())
+      || ! xisinteger (b.real ()) || ! xisinteger (b.imag ()))
     (*current_liboctave_error_handler)
       ("gcd: all complex parts must be integers");
 
   std::complex<FP> aa = a;
   std::complex<FP> bb = b;
 
   if (abs (aa) < abs (bb))
     std::swap (aa, bb);
@@ -151,18 +151,18 @@ extended_gcd (double a, double b, double
   return aa;
 }
 
 template <typename FP>
 static std::complex<FP>
 extended_gcd (const std::complex<FP>& a, const std::complex<FP>& b,
               std::complex<FP>& x, std::complex<FP>& y)
 {
-  if (! xisinteger (a.real ()) || ! xisinteger(a.imag ())
-      || ! xisinteger (b.real ()) || ! xisinteger(b.imag ()))
+  if (! xisinteger (a.real ()) || ! xisinteger (a.imag ())
+      || ! xisinteger (b.real ()) || ! xisinteger (b.imag ()))
     (*current_liboctave_error_handler)
       ("gcd: all complex parts must be integers");
 
   std::complex<FP> aa = a, bb = b;
   bool swapped = false;
   if (abs (aa) < abs (bb))
     {
       std::swap (aa, bb);
diff --git a/src/DLD-FUNCTIONS/kron.cc b/src/DLD-FUNCTIONS/kron.cc
--- a/src/DLD-FUNCTIONS/kron.cc
+++ b/src/DLD-FUNCTIONS/kron.cc
@@ -83,17 +83,17 @@ kron (const MDiagArray2<R>& a, const MAr
   octave_idx_type nca = a.cols (), ncb = b.cols ();
 
   MArray<T> c (dim_vector (nra*nrb, nca*ncb), T ());
 
   for (octave_idx_type ja = 0; ja < dla; ja++)
     for (octave_idx_type jb = 0; jb < ncb; jb++)
       {
         octave_quit ();
-        mx_inline_mul (nrb, &c.xelem(ja*nrb, ja*ncb + jb), a.dgelem (ja), b.data () + nrb*jb);
+        mx_inline_mul (nrb, &c.xelem (ja*nrb, ja*ncb + jb), a.dgelem (ja), b.data () + nrb*jb);
       }
 
   return c;
 }
 
 template <class T>
 static MSparse<T>
 kron (const MSparse<T>& A, const MSparse<T>& B)
@@ -105,17 +105,17 @@ kron (const MSparse<T>& A, const MSparse
   C.cidx (0) = 0;
 
   for (octave_idx_type Aj = 0; Aj < A.columns (); Aj++)
     for (octave_idx_type Bj = 0; Bj < B.columns (); Bj++)
       {
         octave_quit ();
         for (octave_idx_type Ai = A.cidx (Aj); Ai < A.cidx (Aj+1); Ai++)
           {
-            octave_idx_type Ci = A.ridx(Ai) * B.rows ();
+            octave_idx_type Ci = A.ridx (Ai) * B.rows ();
             const T v = A.data (Ai);
 
             for (octave_idx_type Bi = B.cidx (Bj); Bi < B.cidx (Bj+1); Bi++)
               {
                 C.data (idx) = v * B.data (Bi);
                 C.ridx (idx++) = Ci + B.ridx (Bi);
               }
           }
diff --git a/src/DLD-FUNCTIONS/lsode.cc b/src/DLD-FUNCTIONS/lsode.cc
--- a/src/DLD-FUNCTIONS/lsode.cc
+++ b/src/DLD-FUNCTIONS/lsode.cc
@@ -166,17 +166,17 @@ Solve the set of differential equations\
 with\n\
 $$ x(t_0) = x_0 $$\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @group\n\
 dx\n\
--- = f(x, t)\n\
+-- = f (x, t)\n\
 dt\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 with\n\
 \n\
 @example\n\
@@ -317,17 +317,17 @@ parameters for @code{lsode}.\n\
               if (lsode_fcn)
                 {
                   if (c(1).is_function_handle () || c(1).is_inline_function ())
                     lsode_jac = c(1).function_value ();
                   else
                     {
                         jac_name = unique_symbol_name ("__lsode_jac__");
                         jname = "function jac = ";
-                        jname.append(jac_name);
+                        jname.append (jac_name);
                         jname.append (" (x, t) jac = ");
                         lsode_jac = extract_function
                           (c(1), "lsode", jac_name, jname, "; endfunction");
 
                       if (!lsode_jac)
                         {
                           if (fcn_name.length ())
                             clear_function (fcn_name);
@@ -373,17 +373,17 @@ parameters for @code{lsode}.\n\
                         fname.append (" (x, t) y = ");
                         lsode_fcn = extract_function
                           (tmp(0), "lsode", fcn_name, fname, "; endfunction");
 
                         if (lsode_fcn)
                           {
                             jac_name = unique_symbol_name ("__lsode_jac__");
                             jname = "function jac = ";
-                            jname.append(jac_name);
+                            jname.append (jac_name);
                             jname.append (" (x, t) jac = ");
                             lsode_jac = extract_function
                               (tmp(1), "lsode", jac_name, jname,
                               "; endfunction");
 
                             if (!lsode_jac)
                               {
                                 if (fcn_name.length ())
diff --git a/src/DLD-FUNCTIONS/lu.cc b/src/DLD-FUNCTIONS/lu.cc
--- a/src/DLD-FUNCTIONS/lu.cc
+++ b/src/DLD-FUNCTIONS/lu.cc
@@ -174,17 +174,17 @@ information.\n\
           Matrix tmp = args(n++).matrix_value ();
 
           if (! error_state )
             {
               if (!issparse)
                 error ("lu: can not define pivoting threshold THRES for full matrices");
               else if (tmp.nelem () == 1)
                 {
-                  thres.resize(1,2);
+                  thres.resize (1,2);
                   thres(0) = tmp(0);
                   thres(1) = tmp(0);
                 }
               else if (tmp.nelem () == 2)
                 thres = tmp;
               else
                 error ("lu: expecting 2-element vector for THRES");
             }
diff --git a/src/DLD-FUNCTIONS/luinc.cc b/src/DLD-FUNCTIONS/luinc.cc
--- a/src/DLD-FUNCTIONS/luinc.cc
+++ b/src/DLD-FUNCTIONS/luinc.cc
@@ -149,17 +149,17 @@ Given the string argument \"vector\", @c
 
               tmp = map.getfield ("thresh");
               if (tmp.is_defined ())
                 {
                   thresh = tmp.matrix_value ();
 
                   if (thresh.nelem () == 1)
                     {
-                      thresh.resize(1,2);
+                      thresh.resize (1,2);
                       thresh(1) = thresh(0);
                     }
                   else if (thresh.nelem () != 2)
                     {
                       error ("luinc: expecting 2-element vector for thresh");
                       return retval;
                     }
                 }
diff --git a/src/DLD-FUNCTIONS/quad.cc b/src/DLD-FUNCTIONS/quad.cc
--- a/src/DLD-FUNCTIONS/quad.cc
+++ b/src/DLD-FUNCTIONS/quad.cc
@@ -187,17 +187,17 @@ evaluate.  The function must have the fo
 @var{a} and @var{b} are the lower and upper limits of integration.  Either\n\
 or both may be infinite.\n\
 \n\
 The optional argument @var{tol} is a vector that specifies the desired\n\
 accuracy of the result.  The first element of the vector is the desired\n\
 absolute tolerance, and the second element is the desired relative\n\
 tolerance.  To choose a relative test only, set the absolute\n\
 tolerance to zero.  To choose an absolute test only, set the relative\n\
-tolerance to zero.  Both tolerances default to @code{sqrt(eps)} or\n\
+tolerance to zero.  Both tolerances default to @code{sqrt (eps)} or\n\
 approximately @math{1.5e^{-8}}.\n\
 \n\
 The optional argument @var{sing} is a vector of values at which the\n\
 integrand is known to be singular.\n\
 \n\
 The result of the integration is returned in @var{q}.  @var{ier}\n\
 contains an integer error code (0 indicates a successful integration).\n\
 @var{nfun} indicates the number of function evaluations that were\n\
diff --git a/src/DLD-FUNCTIONS/quadcc.cc b/src/DLD-FUNCTIONS/quadcc.cc
--- a/src/DLD-FUNCTIONS/quadcc.cc
+++ b/src/DLD-FUNCTIONS/quadcc.cc
@@ -1488,17 +1488,17 @@ values if given a vector of input values
 f = @@(x) x .* sin (1./x) .* sqrt (abs (1 - x));\n\
 @end example\n\
 \n\
 @noindent\n\
 which uses the element-by-element `dot' form for all operators.\n\
 \n\
 @var{a} and @var{b} are the lower and upper limits of integration.  Either\n\
 or both limits may be infinite.  @code{quadcc} handles an inifinite limit\n\
-by substituting the variable of integration with @code{x=tan(pi/2*u)}.\n\
+by substituting the variable of integration with @code{x = tan (pi/2*u)}.\n\
 \n\
 The optional argument @var{tol} defines the relative tolerance used to stop\n\
 the integration procedure.  The default value is @math{1e^{-6}}.\n\
 \n\
 The optional argument @var{sing} contains a list of points where the\n\
 integrand has known singularities, or discontinuities\n\
 in any of its derivatives, inside the integration interval.\n\
 For the example above, which has a discontinuity at x=1, the call to\n\
diff --git a/src/DLD-FUNCTIONS/rand.cc b/src/DLD-FUNCTIONS/rand.cc
--- a/src/DLD-FUNCTIONS/rand.cc
+++ b/src/DLD-FUNCTIONS/rand.cc
@@ -686,17 +686,17 @@ DEFUN_DLD (randg, args, ,
 @deftypefnx {Loadable Function} {@var{v} =} randg (\"state\")\n\
 @deftypefnx {Loadable Function} {} randg (\"state\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randg (\"state\", \"reset\")\n\
 @deftypefnx {Loadable Function} {@var{v} =} randg (\"seed\")\n\
 @deftypefnx {Loadable Function} {} randg (\"seed\", @var{v})\n\
 @deftypefnx {Loadable Function} {} randg (\"seed\", \"reset\")\n\
 @deftypefnx {Loadable Function} {} randg (@dots{}, \"single\")\n\
 @deftypefnx {Loadable Function} {} randg (@dots{}, \"double\")\n\
-Return a matrix with @code{gamma(@var{a},1)} distributed random elements.\n\
+Return a matrix with @code{gamma (@var{a},1)} distributed random elements.\n\
 The arguments are handled the same as the arguments for @code{rand},\n\
 except for the argument @var{a}.\n\
 \n\
 This can be used to generate many distributions:\n\
 \n\
 @table @asis\n\
 @item @code{gamma (a, b)} for @code{a > -1}, @code{b > 0}\n\
 \n\
diff --git a/src/DLD-FUNCTIONS/regexp.cc b/src/DLD-FUNCTIONS/regexp.cc
--- a/src/DLD-FUNCTIONS/regexp.cc
+++ b/src/DLD-FUNCTIONS/regexp.cc
@@ -503,17 +503,17 @@ octcellregexp (const octave_value_list &
     }
   else if (args(1).is_cell ())
     {
       OCTAVE_LOCAL_BUFFER (Cell, newretval, nargout);
       octave_value_list new_args = args;
       Cell cellpat = args(1).cell_value ();
 
       for (int j = 0; j < nargout; j++)
-        newretval[j].resize(cellpat.dims ());
+        newretval[j].resize (cellpat.dims ());
 
       for (octave_idx_type i = 0; i < cellpat.numel (); i++)
         {
           new_args(1) = cellpat(i);
           octave_value_list tmp = octregexp (new_args, nargout, who,
                                              case_insensitive);
 
           if (error_state)
diff --git a/src/DLD-FUNCTIONS/schur.cc b/src/DLD-FUNCTIONS/schur.cc
--- a/src/DLD-FUNCTIONS/schur.cc
+++ b/src/DLD-FUNCTIONS/schur.cc
@@ -281,17 +281,17 @@ Riccati equations in control (see @code{
 %! assert (u' * a * u, s, sqrt (eps));
 
 %!test
 %! a = single ([1, 2, 3; 4, 5, 9; 7, 8, 6]);
 %! [u, s] = schur (a);
 %! assert (u' * a * u, s, sqrt (eps ("single")));
 
 %!test
-%! fail("schur ([1, 2; 3, 4], 2)", "warning");
+%! fail ("schur ([1, 2; 3, 4], 2)", "warning");
 
 %!error schur ()
 %!error <argument must be a square matrix> schur ([1, 2, 3; 4, 5, 6])
 */
 
 DEFUN_DLD (rsf2csf, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Function File} {[@var{U}, @var{T}] =} rsf2csf (@var{UR}, @var{TR})\n\
diff --git a/src/DLD-FUNCTIONS/str2double.cc b/src/DLD-FUNCTIONS/str2double.cc
--- a/src/DLD-FUNCTIONS/str2double.cc
+++ b/src/DLD-FUNCTIONS/str2double.cc
@@ -397,10 +397,10 @@ risk of using @code{eval} on unknown dat
 %!assert (str2double ("-Inf"), -Inf)
 %!assert (str2double ("Inf*i"), complex (0, Inf))
 %!assert (str2double ("iNF*i"), complex (0, Inf))
 %!assert (str2double ("NaN + Inf*i"), complex (NaN, Inf))
 %!assert (str2double ("Inf - Inf*i"), complex (Inf, -Inf))
 %!assert (str2double ("-i*NaN - Inf"), complex (-Inf, -NaN))
 %!assert (str2double ({"abc", "4i"}), [NaN + 0i, 4i])
 %!assert (str2double ({2, "4i"}), [NaN + 0i, 4i])
-%!assert (str2double (zeros(3,1,2)), NaN (3,1,2))
+%!assert (str2double (zeros (3,1,2)), NaN (3,1,2))
 */
diff --git a/src/DLD-FUNCTIONS/symbfact.cc b/src/DLD-FUNCTIONS/symbfact.cc
--- a/src/DLD-FUNCTIONS/symbfact.cc
+++ b/src/DLD-FUNCTIONS/symbfact.cc
@@ -218,32 +218,32 @@ factorization as determined by @var{typ}
           Aup = F ;
           Alo = A ;
         }
 
       CHOLMOD_NAME(etree) (Aup, Parent, cm);
 
       if (cm->status < CHOLMOD_OK)
         {
-          error("matrix corrupted");
+          error ("matrix corrupted");
           goto symbfact_error;
         }
 
       if (CHOLMOD_NAME(postorder) (Parent, n, 0, Post, cm) != n)
         {
-          error("postorder failed");
+          error ("postorder failed");
           goto symbfact_error;
         }
 
       CHOLMOD_NAME(rowcolcounts) (Alo, 0, 0, Parent, Post, 0,
                                   ColCount, First, Level, cm);
 
       if (cm->status < CHOLMOD_OK)
         {
-          error("matrix corrupted");
+          error ("matrix corrupted");
           goto symbfact_error;
         }
 
       if (nargout > 4)
         {
           cholmod_sparse *A1, *A2;
 
           if (A->stype == 1)
@@ -284,17 +284,17 @@ factorization as determined by @var{typ}
               lnz += ColCount [j];
             }
           L.xcidx(n) = lnz;
 
 
           /* create a copy of the column pointers */
           octave_idx_type *W = First;
           for (octave_idx_type j = 0 ; j < n ; j++)
-            W [j] = L.xcidx(j);
+            W[j] = L.xcidx (j);
 
           // get workspace for computing one row of L
           cholmod_sparse *R = cholmod_allocate_sparse (n, 1, n, false, true,
                                                        0, CHOLMOD_PATTERN, cm);
           octave_idx_type *Rp = static_cast<octave_idx_type *>(R->p);
           octave_idx_type *Ri = static_cast<octave_idx_type *>(R->i);
 
           // compute L one row at a time
diff --git a/src/DLD-FUNCTIONS/symrcm.cc b/src/DLD-FUNCTIONS/symrcm.cc
--- a/src/DLD-FUNCTIONS/symrcm.cc
+++ b/src/DLD-FUNCTIONS/symrcm.cc
@@ -177,17 +177,17 @@ H_insert (CMK_Node *H, octave_idx_type& 
 // reorganizes the heap optionally in O(log(n))
 
 inline static CMK_Node
 H_remove_min (CMK_Node *H, octave_idx_type& h, int reorg/*=1*/)
 {
   CMK_Node r = H[0];
   H[0] = H[--h];
   if (reorg)
-    H_heapify_min(H, 0, h);
+    H_heapify_min (H, 0, h);
   return r;
 }
 
 // Predicate (heap empty)
 #define H_empty(H, h)   ((h) == 0)
 
 // Helper function for the Cuthill-McKee algorithm. Tries to determine a
 // pseudo-peripheral node of the graph as starting node.
@@ -596,72 +596,72 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
                 {
                   octave_idx_type r2 = ridx2[j2++];
                   if (! visit[r2])
                     {
                       // the distance of node j is dist(i)+1
                       w.id = r2;
                       w.deg = D[r2];
                       w.dist = v.dist+1;
-                      H_insert(S, s, w);
+                      H_insert (S, s, w);
                       visit[r2] = true;
                     }
                 }
               else if (j2 == cidx2[i+1])
                 {
                   octave_idx_type r1 = ridx[j1++];
                   if (! visit[r1])
                     {
                       w.id = r1;
                       w.deg = D[r1];
                       w.dist = v.dist+1;
-                      H_insert(S, s, w);
+                      H_insert (S, s, w);
                       visit[r1] = true;
                     }
                 }
               else
                 {
                   octave_idx_type r1 = ridx[j1];
                   octave_idx_type r2 = ridx2[j2];
                   if (r1 <= r2)
                     {
                       if (! visit[r1])
                         {
                           w.id = r1;
                           w.deg = D[r1];
                           w.dist = v.dist+1;
-                          H_insert(S, s, w);
+                          H_insert (S, s, w);
                           visit[r1] = true;
                         }
                       j1++;
                       if (r1 == r2)
                         j2++;
                     }
                   else
                     {
                       if (! visit[r2])
                         {
                           w.id = r2;
                           w.deg = D[r2];
                           w.dist = v.dist+1;
-                          H_insert(S, s, w);
+                          H_insert (S, s, w);
                           visit[r2] = true;
                         }
                       j2++;
                     }
                 }
             }
 
           // add the neighbors to the queue (sorted by node degree)
           while (! H_empty (S, s))
             {
               OCTAVE_QUIT;
 
               // locate a neighbor of i with minimal degree in O(log(N))
-              v = H_remove_min(S, s, 1);
+              v = H_remove_min (S, s, 1);
 
               // entered the BFS a new level?
               if (v.dist > level)
                 {
                   // adjustment of bandwith:
                   // "[...] the minimum bandwidth that
                   // can be obtained [...] is the
                   //  maximum number of nodes per level"
@@ -695,16 +695,16 @@ Mathematics, ISBN 0-13-165274-5, 1981.\n
     }
   // are there any nodes left?
   while (c+1 < N);
 
   // compute the reverse-ordering
   s = N / 2 - 1;
   for (octave_idx_type i = 0, j = N - 1; i <= s; i++, j--)
     {
-      double tmp = P.elem(i);
-      P.elem(i) = P.elem(j);
-      P.elem(j) = tmp;
+      double tmp = P.elem (i);
+      P.elem (i) = P.elem (j);
+      P.elem (j) = tmp;
     }
 
   // increment all indices, since Octave is not C
   return octave_value (P+1);
 }
diff --git a/src/DLD-FUNCTIONS/tril.cc b/src/DLD-FUNCTIONS/tril.cc
--- a/src/DLD-FUNCTIONS/tril.cc
+++ b/src/DLD-FUNCTIONS/tril.cc
@@ -132,18 +132,18 @@ do_tril (const Sparse<T>& a, octave_idx_
       error ("tril: \"pack\" not implemented for sparse matrices");
       return Sparse<T> ();
     }
 
   Sparse<T> m = a;
   octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-      if (m.ridx(i) < j-k)
+    for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
+      if (m.ridx (i) < j-k)
         m.data(i) = 0.;
 
   m.maybe_compress (true);
   return m;
 }
 
 template <class T>
 static Sparse<T>
@@ -154,18 +154,18 @@ do_triu (const Sparse<T>& a, octave_idx_
       error ("triu: \"pack\" not implemented for sparse matrices");
       return Sparse<T> ();
     }
 
   Sparse<T> m = a;
   octave_idx_type nc = m.cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
-    for (octave_idx_type i = m.cidx(j); i < m.cidx(j+1); i++)
-      if (m.ridx(i) > j-k)
+    for (octave_idx_type i = m.cidx (j); i < m.cidx (j+1); i++)
+      if (m.ridx (i) > j-k)
         m.data(i) = 0.;
 
   m.maybe_compress (true);
   return m;
 }
 
 // Convenience dispatchers.
 template <class T>
@@ -285,32 +285,32 @@ do_trilu (const std::string& name,
 
                 octave_value_list ov_idx;
                 std::list<octave_value_list> idx_tmp;
                 ov_idx(1) = static_cast<double> (nc+1);
                 ov_idx(0) = Range (1, nr);
                 idx_tmp.push_back (ov_idx);
                 ov_idx(1) = static_cast<double> (nc);
                 tmp = tmp.resize (dim_vector (0,0));
-                tmp = tmp.subsasgn("(",idx_tmp, arg.do_index_op (ov_idx));
-                tmp = tmp.resize(dims);
+                tmp = tmp.subsasgn ("(",idx_tmp, arg.do_index_op (ov_idx));
+                tmp = tmp.resize (dims);
 
                 if (lower)
                   {
                     octave_idx_type st = nc < nr + k ? nc : nr + k;
 
                     for (octave_idx_type j = 1; j <= st; j++)
                       {
                         octave_idx_type nr_limit = 1 > j - k ? 1 : j - k;
                         ov_idx(1) = static_cast<double> (j);
                         ov_idx(0) = Range (nr_limit, nr);
                         std::list<octave_value_list> idx;
                         idx.push_back (ov_idx);
 
-                        tmp = tmp.subsasgn ("(", idx, arg.do_index_op(ov_idx));
+                        tmp = tmp.subsasgn ("(", idx, arg.do_index_op (ov_idx));
 
                         if (error_state)
                           return retval;
                       }
                   }
                 else
                   {
                     octave_idx_type st = k + 1 > 1 ? k + 1 : 1;
@@ -318,17 +318,17 @@ do_trilu (const std::string& name,
                     for (octave_idx_type j = st; j <= nc; j++)
                       {
                         octave_idx_type nr_limit = nr < j - k ? nr : j - k;
                         ov_idx(1) = static_cast<double> (j);
                         ov_idx(0) = Range (1, nr_limit);
                         std::list<octave_value_list> idx;
                         idx.push_back (ov_idx);
 
-                        tmp = tmp.subsasgn ("(", idx, arg.do_index_op(ov_idx));
+                        tmp = tmp.subsasgn ("(", idx, arg.do_index_op (ov_idx));
 
                         if (error_state)
                           return retval;
                       }
                   }
 
                 retval = tmp;
               }
diff --git a/src/DLD-FUNCTIONS/urlwrite.cc b/src/DLD-FUNCTIONS/urlwrite.cc
--- a/src/DLD-FUNCTIONS/urlwrite.cc
+++ b/src/DLD-FUNCTIONS/urlwrite.cc
@@ -415,27 +415,27 @@ public:
       setopt (CURLOPT_URL, url.c_str ());
 
       // Count number of directory entries
       std::string str = buf.str ();
       octave_idx_type n = 0;
       size_t pos = 0;
       while (true)
         {
-          pos = str.find_first_of('\n', pos);
+          pos = str.find_first_of ('\n', pos);
           if (pos == std::string::npos)
             break;
           pos++;
           n++;
         }
       string_vector retval (n);
       pos = 0;
       for (octave_idx_type i = 0; i < n; i++)
         {
-          size_t newpos = str.find_first_of('\n', pos);
+          size_t newpos = str.find_first_of ('\n', pos);
           if (newpos == std::string::npos)
             break;
 
           retval(i) = str.substr(pos, newpos - pos);
           pos = newpos + 1;
         }
       return retval;
     }
@@ -462,21 +462,21 @@ public:
               fileisdir = true;
               filetime = -1;
               filesize = 0;
             }
           else
             {
               fileisdir = false;
               time_t ft;
-              curl_easy_getinfo(rep->handle (), CURLINFO_FILETIME, &ft);
+              curl_easy_getinfo (rep->handle (), CURLINFO_FILETIME, &ft);
               filetime = ft;
               double fs;
-              curl_easy_getinfo(rep->handle (),
-                                CURLINFO_CONTENT_LENGTH_DOWNLOAD, &fs);
+              curl_easy_getinfo (rep->handle (),
+                                 CURLINFO_CONTENT_LENGTH_DOWNLOAD, &fs);
               filesize = fs;
             }
         }
 
       setopt (CURLOPT_WRITEFUNCTION, write_data);
       setopt (CURLOPT_HEADERFUNCTION, 0);
       setopt (CURLOPT_FILETIME, 0);
       url = "ftp://" + rep->host;
@@ -503,17 +503,17 @@ public:
       if (! error_state)
         {
           perform ();
           retval = buf.str ();
 
           // Can I assume that the path is alway in "" on the last line
           size_t pos2 = retval.rfind ('"');
           size_t pos1 = retval.rfind ('"', pos2 - 1);
-          retval = retval.substr(pos1 + 1, pos2 - pos1 - 1);
+          retval = retval.substr (pos1 + 1, pos2 - pos1 - 1);
         }
       setopt (CURLOPT_HEADERFUNCTION, 0);
       setopt (CURLOPT_WRITEHEADER, 0);
       setopt (CURLOPT_POSTQUOTE, 0);
       curl_slist_free_all (slist);
 
       return retval;
     }
@@ -603,17 +603,17 @@ curl_handles
 {
 public:
 
   typedef std::map<std::string, curl_handle>::iterator iterator;
   typedef std::map<std::string, curl_handle>::const_iterator const_iterator;
 
   curl_handles (void) : map ()
    {
-     curl_global_init(CURL_GLOBAL_DEFAULT);
+     curl_global_init (CURL_GLOBAL_DEFAULT);
    }
 
   ~curl_handles (void)
     {
       // Remove the elements of the map explicitly as they should
       // be deleted before the call to curl_global_cleanup
       map.erase (begin (), end ());
 
