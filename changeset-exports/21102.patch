# HG changeset patch
# User Rik <rik@octave.org>
# Date 1453179986 28800
#      Mon Jan 18 21:06:26 2016 -0800
# Node ID dfcb9d74b253e2637ac68a0382b05345c2076fd9
# Parent  2e8aea678f2a5548adde18c48bf26fbc82ed0133
Rename local gripe_XXX functions to err_XXX or warn_XXX.


* graphics.cc (err_set_invalid): Add OCTAVE_NORETURN attribute.
* graphisc.cc: Rename gripe_set_invalid to err_set_invalid.

* jit-typeinfo.cc (err_bad_result): Rename from gripe_bad_result.

* load-save.cc (err_file_open): Rename from gripe_file_open.

* ls-mat5.cc (warn_dim_too_large): Rename from gripe_dim_too_large.

* oct-stream.cc (err_invalid_file_id): Rename from gripe_invalid_file_id.

* txt-eng-ft.cc (warn_missing_glyph, warn_glyph_render): Rename from
gripe_missing_glyph, gripe_glyph_render.

* xpow.cc: Add FIXME about strange gripe_failed_diagonalization function.

* ov-base-int.cc, ov-bool-mat.cc, ov-bool-sparse.cc, ov-bool.cc, ov-cell.cc,
ov-class.cc, ov-complex.cc, ov-cx-mat.cc, ov-cx-sparse.cc, ov-fcn-handle.cc,
ov-fcn-inline.cc, ov-float.cc, ov-flt-complex.cc, ov-flt-cx-mat.cc,
ov-flt-re-mat.cc, ov-range.cc, ov-re-mat.cc, ov-re-sparse.cc, ov-scalar.cc,
ov-str-mat.cc, ov-struct.cc

(warn_load, warn_save):

ov-base.cc (warn_load, warn_save, err_indexed_assignment,
err_assign_conversion_failed, err_no_conversion): Rename from gripe_XXX
version.

* ov-base.h (warn_load, warn_save): Rename from gripe_load, gripe_save.

* ov-classdef.cc (err_method_access, err_property_access): Rename from
gripe_method_access, gripe_property_access.

* ov-classdef.h (err_invalid_object): Rename from gripe_invalid_object.

* ov-oncleanup.h (gripe_internal): Delete function.  Place single calling
instance directly in code.

* ov.cc (err_binary_op, err_binary_op_conv, err_unary_op, err_unary_op_conv,
err_unary_op_conversion_failed): Add OCTAVE_NORETURN attribute.  Rename from
gripe_XXX.
* ov.cc (err_cat_op, err_cat_op_conv,  ): Rename from gripe_XXX.

* lex.h (warn_single_quote_string, warn_language_extension,
maybe_warn_language_extension_comment, warn_language_extension_continuation,
warn_language_extension_operator): Rename from gripe_XXX.

* lex.ll (warn_single_quote_string, warn_language_extension,
maybe_warn_language_extension_comment, warn_language_extension_continuation,
warn_language_extension_operator): Rename from gripe_XXX.

* pt-check.cc (errmsg): Rename from gripe.

* pt-check.h (errmsg): Add OCTAVE_NORETURN attribute.  Rename from gripe.

* PermMatrix.cc (err_invalid_permutation): Add OCTAVE_NORETURN attribute.
Rename from gripe_invalid_permutation.

* idx-vector.cc (err_invalid_range): Add OCTAVE_NORETURN attribute.
Rename from gripe_invalid_range.

liboctave/numeric/lo-specfun.cc (err_betainc_nonconformant): Add
OCTAVE_NORETURN attribute.  Rename from gripe_betainc_nonconformant.

* oct-group.cc (err_invalid): New static function.

* oct-group.h (gripe_invalid): Delete private function.

* oct-passwd.cc (err_invalid): New static function.

* oct-passwd.h (gripe_invalid): Delete private function.

* data-conv.cc (err_unrecognized_float_fmt): Add OCTAVE_NORETURN attribute.
Rename from gripe_unrecognized_float_fmt.

* lo-cutils.c (warn_missing_wait_macro): Rename from gripe_missing_wait_macro.

* unwind-prot.cc (err_unhandled_exception): Rename from gripe_exception.

* unwind-prot.h (err_unhandled_exception): Rename from gripe_exception.

diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -58,18 +58,19 @@ along with Octave; see the file COPYING.
 #include "txt-eng-ft.h"
 #include "unwind-prot.h"
 #include "utils.h"
 #include "octave-default-image.h"
 
 // forward declarations
 static octave_value xget (const graphics_handle& h, const caseless_str& name);
 
-static void
-gripe_set_invalid (const std::string& pname)
+OCTAVE_NORETURN static
+void
+err_set_invalid (const std::string& pname)
 {
   error ("set: invalid value for %s property", pname.c_str ());
 }
 
 // Check to see that PNAME matches just one of PNAMES uniquely.
 // Return the full name of the match, or an empty caseless_str object
 // if there is no match, or the match is ambiguous.
 
@@ -3389,33 +3390,33 @@ root_figure::properties::set_callbackobj
   else if (is_handle (val))
     {
       if (get_callbackobject ().ok ())
         cbo_stack.push_front (get_callbackobject ());
 
       callbackobject = val;
     }
   else
-    gripe_set_invalid ("callbackobject");
+    err_set_invalid ("callbackobject");
 }
 
 void
 root_figure::properties::set_currentfigure (const octave_value& v)
 {
   graphics_handle val (v);
 
   if (xisnan (val.value ()) || is_handle (val))
     {
       currentfigure = val;
 
       if (val.ok ())
         gh_manager::push_figure (val);
     }
   else
-    gripe_set_invalid ("currentfigure");
+    err_set_invalid ("currentfigure");
 }
 
 void
 figure::properties::set_integerhandle (const octave_value& val)
 {
   if (integerhandle.set (val, true))
     {
       bool int_fig_handle = integerhandle.is_on ();
@@ -3560,17 +3561,17 @@ root_figure::reset_default_properties (v
 void
 figure::properties::set_currentaxes (const octave_value& val)
 {
   graphics_handle hax (val);
 
   if (xisnan (hax.value ()) || is_handle (hax))
     currentaxes = hax;
   else
-    gripe_set_invalid ("currentaxes");
+    err_set_invalid ("currentaxes");
 }
 
 void
 figure::properties::remove_child (const graphics_handle& h)
 {
   base_properties::remove_child (h);
 
   if (h == currentaxes.handle_value ())
diff --git a/libinterp/corefcn/jit-typeinfo.cc b/libinterp/corefcn/jit-typeinfo.cc
--- a/libinterp/corefcn/jit-typeinfo.cc
+++ b/libinterp/corefcn/jit-typeinfo.cc
@@ -436,17 +436,17 @@ octave_jit_pow_scalar_complex (double lh
 extern "C" void
 octave_jit_print_matrix (jit_matrix *m)
 {
   std::cout << *m << std::endl;
 }
 
 OCTAVE_NORETURN static
 void
-gripe_bad_result (void)
+err_bad_result (void)
 {
   error ("incorrect type information given to the JIT compiler");
 }
 
 // FIXME: Add support for multiple outputs
 extern "C" octave_base_value *
 octave_jit_call (octave_builtin::fcn fn, size_t nargin,
                  octave_base_value **argin, jit_type *result_type)
@@ -456,27 +456,27 @@ octave_jit_call (octave_builtin::fcn fn,
     ovl.xelem (i) = octave_value (argin[i]);
 
   ovl = fn (ovl, 1);
 
   // FIXME: Check result_type somehow
   if (result_type)
     {
       if (ovl.length () < 1)
-        gripe_bad_result ();
+        err_bad_result ();
 
       octave_value result = ovl.xelem(0);
       octave_base_value *ret = result.internal_rep ();
       ret->grab ();
       return ret;
     }
 
   if (! (ovl.length () == 0
          || (ovl.length () == 1 && ovl.xelem (0).is_undefined ())))
-    gripe_bad_result ();
+    err_bad_result ();
 
   return 0;
 }
 
 // -------------------- jit_range --------------------
 bool
 jit_range::all_elements_are_ints () const
 {
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -123,17 +123,17 @@ default_save_header_format (void)
 
 // The format string for the comment line at the top of text-format
 // save files.  Passed to strftime.  Should begin with '#' and contain
 // no newline characters.
 static std::string Vsave_header_format_string = default_save_header_format ();
 
 OCTAVE_NORETURN static
 void
-gripe_file_open (const std::string& fcn, const std::string& file)
+err_file_open (const std::string& fcn, const std::string& file)
 {
   if (fcn == "load")
     error ("%s: unable to open input file '%s'", fcn.c_str (), file.c_str ());
   else if (fcn == "save")
     error ("%s: unable to open output file '%s'", fcn.c_str (), file.c_str ());
   else
     error ("%s: unable to open file '%s'", fcn.c_str (), file.c_str ());
 }
@@ -316,29 +316,29 @@ get_file_format (const std::string& fnam
     {
       std::ifstream file (fname.c_str ());
       if (file)
         {
           retval = get_file_format (file, orig_fname);
           file.close ();
         }
       else if (! quiet)
-        gripe_file_open ("load", orig_fname);
+        err_file_open ("load", orig_fname);
     }
 #ifdef HAVE_ZLIB
   else
     {
       gzifstream gzfile (fname.c_str ());
       if (gzfile)
         {
           retval = get_file_format (gzfile, orig_fname);
           gzfile.close ();
         }
       else if (! quiet)
-        gripe_file_open ("load", orig_fname);
+        err_file_open ("load", orig_fname);
     }
 #endif
 
   return retval;
 }
 
 octave_value
 do_load (std::istream& stream, const std::string& orig_fname,
@@ -769,17 +769,17 @@ Force Octave to assume the file is in Oc
             {
               retval = do_load (hdf5_file, orig_fname, format,
                                 flt_fmt, list_only, swap, verbose,
                                 argv, i, argc, nargout);
 
               hdf5_file.close ();
             }
           else
-            gripe_file_open ("load", orig_fname);
+            err_file_open ("load", orig_fname);
         }
       else
 #endif
         // don't insert any statements here; the "else" above has to
         // go with the "if" below!!!!!
       if (format != LS_UNKNOWN)
         {
           i++;
@@ -816,17 +816,17 @@ Force Octave to assume the file is in Oc
 
                   retval = do_load (file, orig_fname, format,
                                     flt_fmt, list_only, swap, verbose,
                                     argv, i, argc, nargout);
 
                   file.close ();
                 }
               else
-                gripe_file_open ("load", orig_fname);
+                err_file_open ("load", orig_fname);
             }
           else
 #endif
             {
               std::ifstream file (fname.c_str (), mode);
 
               if (! file)
                 error ("load: unable to open input file '%s'",
@@ -1669,17 +1669,17 @@ the file @file{data} in Octave's binary 
           if (hdf5_file.file_id != -1)
             {
               save_vars (argv, i, argc, hdf5_file, format,
                          save_as_floats, write_header_info);
 
               hdf5_file.close ();
             }
           else
-            gripe_file_open ("save", fname);
+            err_file_open ("save", fname);
         }
       else
 #endif
         // don't insert any statements here!  The brace below must go
         // with the "else" above!
         {
 #ifdef HAVE_ZLIB
           if (use_zlib)
@@ -1691,34 +1691,34 @@ the file @file{data} in Octave's binary 
                   bool write_header_info = ! file.tellp ();
 
                   save_vars (argv, i, argc, file, format,
                              save_as_floats, write_header_info);
 
                   file.close ();
                 }
               else
-                gripe_file_open ("save", fname);
+                err_file_open ("save", fname);
             }
           else
 #endif
             {
               std::ofstream file (fname.c_str (), mode);
 
               if (file)
                 {
                   bool write_header_info = ! file.tellp ();
 
                   save_vars (argv, i, argc, file, format,
                              save_as_floats, write_header_info);
 
                   file.close ();
                 }
               else
-                gripe_file_open ("save", fname);
+                err_file_open ("save", fname);
             }
         }
     }
 
   return retval;
 }
 
 DEFUN (crash_dumps_octave_core, args, nargout,
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -2219,17 +2219,17 @@ write_mat5_sparse_index_vector (std::ost
 
   for (octave_idx_type i = 0; i < nel; i++)
     tmp_idx[i] = idx[i];
 
   write_mat5_integer_data (os, tmp_idx, -tmp, nel);
 }
 
 static void
-gripe_dim_too_large (const std::string& name)
+warn_dim_too_large (const std::string& name)
 {
   warning ("save: skipping %s: dimension too large for MAT format",
            name.c_str ());
 }
 
 // save the data from TC along with the corresponding NAME on stream
 // OS in the MatLab version 5 binary format.  Return true on success.
 
@@ -2249,17 +2249,17 @@ save_mat5_binary_element (std::ostream& 
   int dim_len = 4*nd;
 
   static octave_idx_type max_dim_val = std::numeric_limits<int32_t>::max ();
 
   for (int i = 0; i < nd; i++)
     {
       if (dv(i) > max_dim_val)
         {
-          gripe_dim_too_large (name);
+          warn_dim_too_large (name);
           goto skip_to_next;
         }
     }
 
   if (tc.is_sparse_type ())
     {
       octave_idx_type nnz;
       octave_idx_type nc;
@@ -2274,25 +2274,25 @@ save_mat5_binary_element (std::ostream& 
         {
           SparseMatrix sm = tc.sparse_matrix_value ();
           nnz = sm.nzmax ();
           nc = sm.cols ();
         }
 
       if (nnz > max_dim_val || nc + 1 > max_dim_val)
         {
-          gripe_dim_too_large (name);
+          warn_dim_too_large (name);
           goto skip_to_next;
         }
 
       nnz_32 = nnz;
     }
   else if (dv.numel () > max_dim_val)
     {
-      gripe_dim_too_large (name);
+      warn_dim_too_large (name);
       goto skip_to_next;
     }
 
 #ifdef HAVE_ZLIB
   if (mat7_format && ! compressing)
     {
       bool ret = false;
 
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -4152,40 +4152,40 @@ octave_stream_list::do_insert (octave_st
 
   list[stream_number] = os;
 
   return stream_number;
 }
 
 OCTAVE_NORETURN static
 void
-gripe_invalid_file_id (int fid, const std::string& who)
+err_invalid_file_id (int fid, const std::string& who)
 {
   if (who.empty ())
     ::error ("invalid stream number = %d", fid);
   else
     ::error ("%s: invalid stream number = %d", who.c_str (), fid);
 }
 
 octave_stream
 octave_stream_list::do_lookup (int fid, const std::string& who) const
 {
   octave_stream retval;
 
   if (fid < 0)
-    gripe_invalid_file_id (fid, who);
+    err_invalid_file_id (fid, who);
 
   if (lookup_cache != list.end () && lookup_cache->first == fid)
     retval = lookup_cache->second;
   else
     {
       ostrl_map::const_iterator iter = list.find (fid);
 
       if (iter == list.end ())
-        gripe_invalid_file_id (fid, who);
+        err_invalid_file_id (fid, who);
 
       retval = iter->second;
       lookup_cache = iter;
     }
 
   return retval;
 }
 
@@ -4198,30 +4198,30 @@ octave_stream_list::do_lookup (const oct
   return do_lookup (i, who);
 }
 
 int
 octave_stream_list::do_remove (int fid, const std::string& who)
 {
   // Can't remove stdin (std::cin), stdout (std::cout), or stderr (std::cerr).
   if (fid < 3)
-    gripe_invalid_file_id (fid, who);
+    err_invalid_file_id (fid, who);
 
   ostrl_map::iterator iter = list.find (fid);
 
   if (iter == list.end ())
-    gripe_invalid_file_id (fid, who);
+    err_invalid_file_id (fid, who);
 
   octave_stream os = iter->second;
   list.erase (iter);
   lookup_cache = list.end ();
 
   // FIXME: is this check redundant?
   if (! os.is_valid ())
-    gripe_invalid_file_id (fid, who);
+    err_invalid_file_id (fid, who);
 
   os.close ();
 
   return 0;
 }
 
 int
 octave_stream_list::do_remove (const octave_value& fid, const std::string& who)
diff --git a/libinterp/corefcn/txt-eng-ft.cc b/libinterp/corefcn/txt-eng-ft.cc
--- a/libinterp/corefcn/txt-eng-ft.cc
+++ b/libinterp/corefcn/txt-eng-ft.cc
@@ -41,29 +41,27 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "pr-output.h"
 #include "txt-eng-ft.h"
 
 // FIXME: maybe issue at most one warning per glyph/font/size/weight
 //        combination.
 
 static void
-gripe_missing_glyph (FT_ULong c)
+warn_missing_glyph (FT_ULong c)
 {
   warning_with_id ("Octave:missing-glyph",
-                   "ft_render: skipping missing glyph for character '%x'",
-                   c);
+                   "ft_render: skipping missing glyph for character '%x'", c);
 }
 
 static void
-gripe_glyph_render (FT_ULong c)
+warn_glyph_render (FT_ULong c)
 {
   warning_with_id ("Octave:glyph-render",
-                   "ft_render: unable to render glyph for character '%x'",
-                   c);
+                   "ft_render: unable to render glyph for character '%x'", c);
 }
 
 #ifdef _MSC_VER
 // This is just a trick to avoid multiple symbol definitions.
 // PermMatrix.h contains a dllexport'ed Array<octave_idx_type>
 // that will cause MSVC not to generate a new instantiation and
 // use the imported one instead.
 #include "PermMatrix.h"
@@ -503,39 +501,39 @@ ft_render::process_character (FT_ULong c
     {
       glyph_index = FT_Get_Char_Index (face, code);
 
       if (code != '\n'
           && (! glyph_index
               || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT)))
         {
           glyph_index = 0;
-          gripe_missing_glyph (code);
+          warn_missing_glyph (code);
         }
       else
         {
           switch (mode)
             {
             case MODE_RENDER:
               if (code == '\n')
                 {
                   glyph_index = FT_Get_Char_Index (face, ' ');
                   if (! glyph_index
                       || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT))
                     {
                       glyph_index = 0;
-                      gripe_missing_glyph (' ');
+                      warn_missing_glyph (' ');
                     }
                   else
                     push_new_line ();
                 }
               else if (FT_Render_Glyph (face->glyph, FT_RENDER_MODE_NORMAL))
                 {
                   glyph_index = 0;
-                  gripe_glyph_render (code);
+                  warn_glyph_render (code);
                 }
               else
                 {
                   FT_Bitmap& bitmap = face->glyph->bitmap;
                   int x0, y0;
 
                   if (previous)
                     {
@@ -582,17 +580,17 @@ ft_render::process_character (FT_ULong c
             case MODE_BBOX:
               if (code == '\n')
                 {
                   glyph_index = FT_Get_Char_Index (face, ' ');
                   if (! glyph_index
                       || FT_Load_Glyph (face, glyph_index, FT_LOAD_DEFAULT))
                     {
                       glyph_index = 0;
-                      gripe_missing_glyph (' ');
+                      warn_missing_glyph (' ');
                     }
                   else
                     push_new_line ();
                 }
               else
                 {
                   Matrix& bb = line_bbox.back ();
 
diff --git a/libinterp/corefcn/xpow.cc b/libinterp/corefcn/xpow.cc
--- a/libinterp/corefcn/xpow.cc
+++ b/libinterp/corefcn/xpow.cc
@@ -49,16 +49,17 @@ along with Octave; see the file COPYING.
 
 #include "error.h"
 #include "ovl.h"
 #include "utils.h"
 #include "xpow.h"
 
 #include "bsxfun.h"
 
+// FIXME: Why does this routine call itself?
 static void
 gripe_failed_diagonalization (void)
 {
   gripe_failed_diagonalization ();
 }
 
 static inline int
 xisint (double x)
diff --git a/libinterp/octave-value/ov-base-int.cc b/libinterp/octave-value/ov-base-int.cc
--- a/libinterp/octave-value/ov-base-int.cc
+++ b/libinterp/octave-value/ov-base-int.cc
@@ -365,17 +365,17 @@ octave_base_int_matrix<T>::save_hdf5 (oc
 
   retval = H5Dwrite (data_hid, save_type_hid, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, this->matrix.data ()) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
 #else
-  this->gripe_save ("hdf5");
+  this->warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 template <class T>
 bool
 octave_base_int_matrix<T>::load_hdf5 (octave_hdf5_id loc_id, const char *name)
@@ -434,17 +434,17 @@ octave_base_int_matrix<T>::load_hdf5 (oc
       retval = true;
       this->matrix = m;
     }
 
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
 #else
-  this->gripe_load ("hdf5");
+  this->warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 template <class T>
 void
 octave_base_int_matrix<T>::print_raw (std::ostream& os,
@@ -572,17 +572,17 @@ octave_base_int_scalar<T>::save_hdf5 (oc
 
   retval = H5Dwrite (data_hid, save_type_hid, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, &(this->scalar)) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
 #else
-  this->gripe_save ("hdf5");
+  this->warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 template <class T>
 bool
 octave_base_int_scalar<T>::load_hdf5 (octave_hdf5_id loc_id, const char *name)
@@ -615,13 +615,13 @@ octave_base_int_scalar<T>::load_hdf5 (oc
 
   this->scalar = tmp;
 
   H5Dclose (data_hid);
 
   return true;
 
 #else
-  this->gripe_load ("hdf5");
+  this->warn_load ("hdf5");
   return false;
 #endif
 }
 
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -1241,26 +1241,26 @@ octave_base_value::get_umap_name (unary_
 
   if (umap < 0 || umap >= num_unary_mappers)
     return "unknown";
   else
     return names[umap];
 }
 
 void
-octave_base_value::gripe_load (const char *type) const
+octave_base_value::warn_load (const char *type) const
 {
   warning_with_id
     ("Octave:load-save-unavailable",
      "%s: loading %s files not available in this version of Octave",
      t_name.c_str (), type);
 }
 
 void
-octave_base_value::gripe_save (const char *type) const
+octave_base_value::warn_save (const char *type) const
 {
   warning_with_id
     ("Octave:load-save-unavailable",
      "%s: saving %s files not available in this version of Octave",
      t_name.c_str (), type);
 }
 
 void
@@ -1294,34 +1294,34 @@ octave_base_value::dump (std::ostream& o
 
   os << "class: " << this->class_name ()
      << " type: " << this->type_name ()
      << " dims: " << dv.str ();
 }
 
 OCTAVE_NORETURN static
 void
-gripe_indexed_assignment (const std::string& tn1, const std::string& tn2)
+err_indexed_assignment (const std::string& tn1, const std::string& tn2)
 {
   error ("assignment of '%s' to indexed '%s' not implemented",
          tn2.c_str (), tn1.c_str ());
 }
 
 OCTAVE_NORETURN static
 void
-gripe_assign_conversion_failed (const std::string& tn1, const std::string& tn2)
+err_assign_conversion_failed (const std::string& tn1, const std::string& tn2)
 {
   error ("type conversion for assignment of '%s' to indexed '%s' failed",
          tn2.c_str (), tn1.c_str ());
 }
 
 OCTAVE_NORETURN static
 void
-gripe_no_conversion (const std::string& on, const std::string& tn1,
-                     const std::string& tn2)
+err_no_conversion (const std::string& on, const std::string& tn1,
+                   const std::string& tn2)
 {
   error ("operator %s: no conversion for assignment of '%s' to indexed '%s'",
          on.c_str (), tn2.c_str (), tn1.c_str ());
 }
 
 octave_value
 octave_base_value::numeric_assign (const std::string& type,
                                    const std::list<octave_value_list>& idx,
@@ -1371,21 +1371,21 @@ octave_base_value::numeric_assign (const
                 {
                   octave_value val (tmp);
 
                   retval = val.subsasgn (type, idx, rhs);
 
                   done = true;
                 }
               else
-                gripe_assign_conversion_failed (type_name (),
-                                                rhs.type_name ());
+                err_assign_conversion_failed (type_name (),
+                                              rhs.type_name ());
             }
           else
-            gripe_indexed_assignment (type_name (), rhs.type_name ());
+            err_indexed_assignment (type_name (), rhs.type_name ());
         }
 
       if (! done)
         {
           octave_value tmp_rhs;
 
           octave_base_value::type_conv_info cf_rhs
             = rhs.numeric_conversion_function ();
@@ -1410,51 +1410,50 @@ octave_base_value::numeric_assign (const
 
           if (cf_rhs)
             {
               octave_base_value *tmp = cf_rhs (rhs.get_rep ());
 
               if (tmp)
                 tmp_rhs = octave_value (tmp);
               else
-                gripe_assign_conversion_failed (type_name (),
-                                                rhs.type_name ());
+                err_assign_conversion_failed (type_name (),
+                                              rhs.type_name ());
             }
           else
             tmp_rhs = rhs;
 
           count++;
           octave_value tmp_lhs = octave_value (this);
 
           if (cf_this)
             {
               octave_base_value *tmp = cf_this (*this);
 
               if (tmp)
                 tmp_lhs = octave_value (tmp);
               else
-                gripe_assign_conversion_failed (type_name (),
-                                                rhs.type_name ());
+                err_assign_conversion_failed (type_name (),
+                                              rhs.type_name ());
             }
 
           if (cf_this || cf_rhs)
             {
               retval = tmp_lhs.subsasgn (type, idx, tmp_rhs);
 
               done = true;
             }
           else
-            gripe_no_conversion (octave_value::assign_op_as_string
-                                   (octave_value::op_asn_eq),
-                                 type_name (), rhs.type_name ());
+            err_no_conversion (octave_value::assign_op_as_string
+                               (octave_value::op_asn_eq),
+                               type_name (), rhs.type_name ());
         }
     }
 
-  // The assignment may have converted to a type that is wider than
-  // necessary.
+  // The assignment may have converted to a type that is wider than necessary.
 
   retval.maybe_mutate ();
 
   return retval;
 }
 
 // Current indentation.
 int octave_base_value::curr_print_indent_level = 0;
diff --git a/libinterp/octave-value/ov-base.h b/libinterp/octave-value/ov-base.h
--- a/libinterp/octave-value/ov-base.h
+++ b/libinterp/octave-value/ov-base.h
@@ -820,18 +820,18 @@ protected:
   // A reference count.
   // NOTE: the declaration is octave_idx_type because with 64-bit indexing,
   // it is well possible to have more than MAX_INT copies of a single value
   // (think of an empty cell array with >2G elements).
   octave_refcount<octave_idx_type> count;
 
   static const char *get_umap_name (unary_mapper_t);
 
-  void gripe_load (const char *type) const;
-  void gripe_save (const char *type) const;
+  void warn_load (const char *type) const;
+  void warn_save (const char *type) const;
 
 private:
 
   void wrong_type_arg_error (void) const;
 
   static int curr_print_indent_level;
   static bool beginning_of_line;
 
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -427,17 +427,17 @@ octave_bool_matrix::save_hdf5 (octave_hd
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_HBOOL, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, htmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_bool_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
@@ -498,17 +498,17 @@ octave_bool_matrix::load_hdf5 (octave_hd
         btmp.elem (i) = htmp[i];
 
       matrix = btmp;
     }
 
   H5Dclose (data_hid);
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_bool_matrix::as_mxArray (void) const
 {
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -541,17 +541,17 @@ octave_sparse_bool_matrix::save_hdf5 (oc
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_HBOOL, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, htmp) >= 0;
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_sparse_bool_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
@@ -780,17 +780,17 @@ octave_sparse_bool_matrix::load_hdf5 (oc
       matrix = m;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
   H5Gclose (group_hid);
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_sparse_bool_matrix::as_mxArray (void) const
 {
diff --git a/libinterp/octave-value/ov-bool.cc b/libinterp/octave-value/ov-bool.cc
--- a/libinterp/octave-value/ov-bool.cc
+++ b/libinterp/octave-value/ov-bool.cc
@@ -185,17 +185,17 @@ octave_bool::save_hdf5 (octave_hdf5_id l
   double tmp = double_value ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_bool::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
@@ -224,17 +224,17 @@ octave_bool::load_hdf5 (octave_hdf5_id l
       return false;
     }
 
   scalar = (dtmp != 0.);
 
   H5Dclose (data_hid);
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
 #endif
 
   return true;
 }
 
 mxArray *
 octave_bool::as_mxArray (void) const
 {
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -1052,17 +1052,17 @@ octave_cell::save_hdf5 (octave_hdf5_id l
         }
     }
 
   H5Gclose (data_hid);
 
   return true;
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
   return false;
 #endif
 }
 
 bool
 octave_cell::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
@@ -1162,17 +1162,17 @@ octave_cell::load_hdf5 (octave_hdf5_id l
 
   if (retval2 >= 0)
     {
       matrix = m;
       retval = true;
     }
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 DEFUN (iscell, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {} {} iscell (@var{x})\n\
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1472,17 +1472,17 @@ error_cleanup:
     H5Tclose (type_hid);
 
   if (group_hid > 0)
     H5Gclose (group_hid);
 
   return true;
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
   return false;
 #endif
 }
 
 bool
 octave_class::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
@@ -1607,17 +1607,17 @@ octave_class::load_hdf5 (octave_hdf5_id 
 error_cleanup:
   if (data_hid > 0)
     H5Dclose (data_hid);
 
   if (data_hid > 0)
     H5Gclose (group_hid);
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_class::as_mxArray (void) const
 {
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -45,33 +45,33 @@ along with Octave; see the file COPYING.
 
 #include "Array.cc"
 
 // Define to 1 to enable debugging statements.
 #define DEBUG_TRACE 0
 
 OCTAVE_NORETURN static
 void
-gripe_method_access (const std::string& from, const cdef_method& meth)
+err_method_access (const std::string& from, const cdef_method& meth)
 {
   octave_value acc = meth.get ("Access");
   std::string acc_s;
 
   if (acc.is_string ())
     acc_s = acc.string_value ();
   else
     acc_s = "class-restricted";
 
   error ("%s: method `%s' has %s access and cannot be run in this context",
          from.c_str (), meth.get_name ().c_str (), acc_s.c_str ());
 }
 
 OCTAVE_NORETURN static
 void
-gripe_property_access (const std::string& from, const cdef_property& prop,
+err_property_access (const std::string& from, const cdef_property& prop,
                        bool is_set = false)
 {
   octave_value acc = prop.get (is_set ? "SetAccess" : "GetAccess");
   std::string acc_s;
 
   if (acc.is_string ())
     acc_s = acc.string_value ();
   else
@@ -2906,17 +2906,17 @@ cdef_class::get_method_function (const s
 octave_value
 cdef_property::cdef_property_rep::get_value (const cdef_object& obj,
                                              bool do_check_access,
                                              const std::string& who)
 {
   octave_value retval;
 
   if (do_check_access && ! check_get_access ())
-    gripe_property_access (who, wrap (), false);
+    err_property_access (who, wrap (), false);
 
   if (! obj.is_constructed ())
     {
       cdef_class cls (to_cdef (get ("DefiningClass")));
 
       if (! obj.is_partially_constructed_for (cls))
         error ("cannot reference properties of class `%s' for non-constructed object",
                cls.get_name ().c_str ());
@@ -2942,17 +2942,17 @@ cdef_property::cdef_property_rep::get_va
   return retval;
 }
 
 octave_value
 cdef_property::cdef_property_rep::get_value (bool do_check_access,
                                              const std::string& who)
 {
   if (do_check_access && ! check_get_access ())
-    gripe_property_access (who, wrap (), false);
+    err_property_access (who, wrap (), false);
 
   return get ("DefaultValue");
 }
 
 bool
 cdef_property::cdef_property_rep::is_recursive_set (const cdef_object& /* obj */) const
 {
   // FIXME: implement
@@ -2961,17 +2961,17 @@ cdef_property::cdef_property_rep::is_rec
 
 void
 cdef_property::cdef_property_rep::set_value (cdef_object& obj,
                                              const octave_value& val,
                                              bool do_check_access,
                                              const std::string& who)
 {
   if (do_check_access && ! check_set_access ())
-    gripe_property_access (who, wrap (), true);
+    err_property_access (who, wrap (), true);
 
   if (! obj.is_constructed ())
     {
       cdef_class cls (to_cdef (get ("DefiningClass")));
 
       if (! obj.is_partially_constructed_for (cls))
         error ("cannot reference properties of class `%s' for non-constructed object",
                cls.get_name ().c_str ());
@@ -3078,17 +3078,17 @@ cdef_method::cdef_method_rep::check_meth
 octave_value_list
 cdef_method::cdef_method_rep::execute (const octave_value_list& args,
                                        int nargout, bool do_check_access,
                                        const std::string& who)
 {
   octave_value_list retval;
 
   if (do_check_access && ! check_access ())
-    gripe_method_access (who, wrap ());
+    err_method_access (who, wrap ());
 
   if (get ("Abstract").bool_value ())
     error ("%s: cannot execute abstract method",
            get ("Name").string_value ().c_str ());
 
   check_method ();
 
   if (function.is_defined ())
@@ -3101,17 +3101,17 @@ octave_value_list
 cdef_method::cdef_method_rep::execute (const cdef_object& obj,
                                        const octave_value_list& args,
                                        int nargout, bool do_check_access,
                                        const std::string& who)
 {
   octave_value_list retval;
 
   if (do_check_access && ! check_access ())
-    gripe_method_access (who, wrap ());
+    err_method_access (who, wrap ());
 
   if (get ("Abstract").bool_value ())
     error ("%s: cannot execute abstract method",
            get ("Name").string_value ().c_str ());
 
   check_method ();
 
   if (function.is_defined ())
diff --git a/libinterp/octave-value/ov-classdef.h b/libinterp/octave-value/ov-classdef.h
--- a/libinterp/octave-value/ov-classdef.h
+++ b/libinterp/octave-value/ov-classdef.h
@@ -52,107 +52,107 @@ public:
 public:
   cdef_object_rep (void) : refcount (1) { }
 
   virtual ~cdef_object_rep (void) { }
 
   virtual cdef_class get_class (void) const;
 
   virtual void set_class (const cdef_class&)
-  { gripe_invalid_object ("set_class"); }
+  { err_invalid_object ("set_class"); }
 
   virtual cdef_object_rep* clone (void) const
   {
-    gripe_invalid_object ("clone");
+    err_invalid_object ("clone");
   }
 
   virtual cdef_object_rep* empty_clone (void) const
   {
-    gripe_invalid_object ("empty_clone");
+    err_invalid_object ("empty_clone");
   }
 
   virtual cdef_object_rep* copy (void) const
   {
-    gripe_invalid_object ("copy");
+    err_invalid_object ("copy");
   }
 
   virtual cdef_object_rep* make_array (void) const
   {
-    gripe_invalid_object ("make_array");
+    err_invalid_object ("make_array");
   }
 
   virtual bool is_array (void) const { return false; }
 
   virtual bool is_value_object (void) const { return false; }
 
   virtual bool is_handle_object (void) const { return false; }
 
   virtual bool is_meta_object (void) const { return false; }
 
   virtual Array<cdef_object> array_value (void) const
   {
-    gripe_invalid_object ("array_value");
+    err_invalid_object ("array_value");
   }
 
   virtual void put (const std::string&, const octave_value&)
-  { gripe_invalid_object ("put"); }
+  { err_invalid_object ("put"); }
 
   virtual octave_value get (const std::string&) const
   {
-    gripe_invalid_object ("get");
+    err_invalid_object ("get");
   }
 
   virtual octave_value_list
   subsref (const std::string&, const std::list<octave_value_list>&,
            int, size_t&, const cdef_class&, bool)
   {
-    gripe_invalid_object ("subsref");
+    err_invalid_object ("subsref");
   }
 
   virtual octave_value
   subsasgn (const std::string&, const std::list<octave_value_list>&,
             const octave_value&)
   {
-    gripe_invalid_object ("subsasgn");
+    err_invalid_object ("subsasgn");
   }
 
   virtual string_vector map_keys (void) const;
 
   virtual bool is_valid (void) const { return false; }
 
   std::string class_name (void) const;
 
   virtual void mark_for_construction (const cdef_class&)
   {
-    gripe_invalid_object ("mark_for_construction");
+    err_invalid_object ("mark_for_construction");
   }
 
   virtual bool is_constructed_for (const cdef_class&) const
   {
-    gripe_invalid_object ("is_constructed_for");
+    err_invalid_object ("is_constructed_for");
   }
 
   virtual bool is_partially_constructed_for (const cdef_class&) const
   {
-    gripe_invalid_object ("is_partially_constructed_for");
+    err_invalid_object ("is_partially_constructed_for");
   }
 
   virtual void mark_as_constructed (void)
   {
-    gripe_invalid_object ("mark_as_constructed");
+    err_invalid_object ("mark_as_constructed");
   }
 
   virtual void mark_as_constructed (const cdef_class&)
   {
-    gripe_invalid_object ("mark_as_constructed");
+    err_invalid_object ("mark_as_constructed");
   }
 
   virtual bool is_constructed (void) const
   {
-    gripe_invalid_object ("is_constructed");
+    err_invalid_object ("is_constructed");
   }
 
   virtual octave_idx_type static_count (void) const { return 0; }
 
   virtual void destroy (void) { delete this; }
 
   void release (void)
   {
@@ -170,17 +170,17 @@ protected:
   // Restricted copying
   cdef_object_rep (const cdef_object_rep&)
     : refcount (1) { }
 
 private:
   // No assignment
   cdef_object_rep& operator = (const cdef_object_rep& );
 
-  OCTAVE_NORETURN void gripe_invalid_object (const char *who) const
+  OCTAVE_NORETURN void err_invalid_object (const char *who) const
   { error ("%s: invalid object", who); }
 };
 
 class
 cdef_object
 {
 public:
   // FIXME: use a null object
@@ -1158,17 +1158,17 @@ private:
 
   const cdef_method_rep* get_rep (void) const
   { return dynamic_cast<const cdef_method_rep *> (cdef_object::get_rep ()); }
 };
 
 inline cdef_class
 cdef_object_rep::get_class (void) const
 {
-  gripe_invalid_object ("get_class");
+  err_invalid_object ("get_class");
 }
 
 inline std::string
 cdef_object_rep::class_name (void) const
 { return get_class ().get_name (); }
 
 inline cdef_class
 cdef_object::get_class (void) const
diff --git a/libinterp/octave-value/ov-complex.cc b/libinterp/octave-value/ov-complex.cc
--- a/libinterp/octave-value/ov-complex.cc
+++ b/libinterp/octave-value/ov-complex.cc
@@ -387,17 +387,17 @@ octave_complex::save_hdf5 (octave_hdf5_i
   retval = H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
                      &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_complex::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
@@ -441,17 +441,17 @@ octave_complex::load_hdf5 (octave_hdf5_i
       scalar = ctmp;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_complex::as_mxArray (void) const
 {
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -621,17 +621,17 @@ octave_complex_matrix::save_hdf5 (octave
   H5Tclose (complex_type_hid);
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
   return retval;
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
   return false;
 #endif
 }
 
 bool
 octave_complex_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
@@ -701,17 +701,17 @@ octave_complex_matrix::load_hdf5 (octave
       matrix = m;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 void
 octave_complex_matrix::print_raw (std::ostream& os,
                                   bool pr_as_read_syntax) const
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -610,17 +610,17 @@ octave_sparse_complex_matrix::save_hdf5 
     }
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Tclose (type_hid);
   H5Gclose (group_hid);
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_sparse_complex_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
@@ -858,17 +858,17 @@ octave_sparse_complex_matrix::load_hdf5 
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_hid);
   H5Dclose (data_hid);
   H5Gclose (group_hid);
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_sparse_complex_matrix::as_mxArray (void) const
 {
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -906,17 +906,17 @@ octave_fcn_handle::save_hdf5 (octave_hdf
 
   H5Sclose (space_hid);
   H5Tclose (type_hid);
   H5Gclose (group_hid);
 
   return retval;
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
   return false;
 #endif
 }
 
 bool
 octave_fcn_handle::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
 #if defined (HAVE_HDF5)
@@ -1263,17 +1263,17 @@ octave_fcn_handle::load_hdf5 (octave_hdf
 
   H5Tclose (type_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
   return success;
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
   return false;
 #endif
 }
 
 /*
 %!test
 %! a = 2;
 %! f = @(x) a + x;
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -408,17 +408,17 @@ octave_fcn_inline::save_hdf5 (octave_hdf
     }
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Tclose (type_hid);
   H5Gclose (group_hid);
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_fcn_inline::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
@@ -600,17 +600,17 @@ octave_fcn_inline::load_hdf5 (octave_hdf
   iftext = iftext_tmp;
 
   octave_fcn_inline ftmp (iftext, ifargs, nm);
   fcn = ftmp.fcn;
 
   return true;
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
   return false;
 #endif
 }
 
 void
 octave_fcn_inline::print (std::ostream& os, bool pr_as_read_syntax)
 {
   print_raw (os, pr_as_read_syntax);
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -212,17 +212,17 @@ octave_float_scalar::save_hdf5 (octave_h
   float tmp = float_value ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_FLOAT, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_float_scalar::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
@@ -253,17 +253,17 @@ octave_float_scalar::load_hdf5 (octave_h
 
   scalar = dtmp;
 
   H5Dclose (data_hid);
 
   return true;
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
   return false;
 #endif
 }
 
 mxArray *
 octave_float_scalar::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxSINGLE_CLASS, 1, 1, mxREAL);
diff --git a/libinterp/octave-value/ov-flt-complex.cc b/libinterp/octave-value/ov-flt-complex.cc
--- a/libinterp/octave-value/ov-flt-complex.cc
+++ b/libinterp/octave-value/ov-flt-complex.cc
@@ -331,17 +331,17 @@ octave_float_complex::save_hdf5 (octave_
   retval = H5Dwrite (data_hid, type_hid, octave_H5S_ALL, octave_H5S_ALL, octave_H5P_DEFAULT,
                      &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_float_complex::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
@@ -385,17 +385,17 @@ octave_float_complex::load_hdf5 (octave_
       scalar = ctmp;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_float_complex::as_mxArray (void) const
 {
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -571,17 +571,17 @@ octave_float_complex_matrix::save_hdf5 (
     }
 
   H5Tclose (complex_type_hid);
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_float_complex_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
@@ -652,17 +652,17 @@ octave_float_complex_matrix::load_hdf5 (
       matrix = m;
     }
 
   H5Tclose (complex_type);
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 void
 octave_float_complex_matrix::print_raw (std::ostream& os,
                                         bool pr_as_read_syntax) const
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -577,17 +577,17 @@ octave_float_matrix::save_hdf5 (octave_h
   float *mtmp = m.fortran_vec ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_FLOAT, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, mtmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_float_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
@@ -645,17 +645,17 @@ octave_float_matrix::load_hdf5 (octave_h
       retval = true;
       matrix = m;
     }
 
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 void
 octave_float_matrix::print_raw (std::ostream& os,
                                 bool pr_as_read_syntax) const
diff --git a/libinterp/octave-value/ov-oncleanup.h b/libinterp/octave-value/ov-oncleanup.h
--- a/libinterp/octave-value/ov-oncleanup.h
+++ b/libinterp/octave-value/ov-oncleanup.h
@@ -21,33 +21,28 @@ along with Octave; see the file COPYING.
 */
 
 #include <iosfwd>
 
 #include "ov-base.h"
 #include "ov-struct.h"
 #include "ov.h"
 
-static void
-gripe_internal (void)
-{
-  error ("onCleanup: internal error: cloning nonempty object");
-}
 
 class octave_oncleanup : public octave_base_value
 {
 public:
   octave_oncleanup (void) : fcn () { }
 
   octave_oncleanup (const octave_value& fcn);
 
   octave_base_value *clone (void) const
   {
     if (fcn.is_defined ())
-      gripe_internal ();
+      error ("onCleanup: internal error: cloning nonempty object");
 
     return empty_clone ();
   }
 
   octave_base_value *empty_clone (void) const
   {
     return new octave_oncleanup ();
   }
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -602,17 +602,17 @@ octave_range::save_hdf5 (octave_hdf5_id 
   else
     retval = false;
 
   H5Dclose (data_hid);
   H5Tclose (type_hid);
   H5Sclose (space_hid);
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_range::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
@@ -666,17 +666,17 @@ octave_range::load_hdf5 (octave_hdf5_id 
         }
     }
 
   H5Tclose (range_type);
   H5Sclose (space_hid);
   H5Dclose (data_hid);
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_range::as_mxArray (void) const
 {
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -700,17 +700,17 @@ octave_matrix::save_hdf5 (octave_hdf5_id
   double *mtmp = m.fortran_vec ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, mtmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
@@ -768,17 +768,17 @@ octave_matrix::load_hdf5 (octave_hdf5_id
       retval = true;
       matrix = m;
     }
 
   H5Sclose (space_id);
   H5Dclose (data_hid);
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 void
 octave_matrix::print_raw (std::ostream& os,
                           bool pr_as_read_syntax) const
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -618,17 +618,17 @@ octave_sparse_matrix::save_hdf5 (octave_
   double * dtmp = m.xdata ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, dtmp) >= 0;
   H5Dclose (data_hid);
   H5Sclose (space_hid);
   H5Gclose (group_hid);
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_sparse_matrix::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
@@ -851,17 +851,17 @@ octave_sparse_matrix::load_hdf5 (octave_
       matrix = m;
     }
 
   H5Sclose (space_hid);
   H5Dclose (data_hid);
   H5Gclose (group_hid);
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_sparse_matrix::as_mxArray (void) const
 {
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -229,17 +229,17 @@ octave_scalar::save_hdf5 (octave_hdf5_id
   double tmp = double_value ();
   retval = H5Dwrite (data_hid, H5T_NATIVE_DOUBLE, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, &tmp) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_scalar::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
@@ -270,17 +270,17 @@ octave_scalar::load_hdf5 (octave_hdf5_id
 
   scalar = dtmp;
 
   H5Dclose (data_hid);
 
   return true;
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
   return false;
 #endif
 }
 
 mxArray *
 octave_scalar::as_mxArray (void) const
 {
   mxArray *retval = new mxArray (mxDOUBLE_CLASS, 1, 1, mxREAL);
diff --git a/libinterp/octave-value/ov-str-mat.cc b/libinterp/octave-value/ov-str-mat.cc
--- a/libinterp/octave-value/ov-str-mat.cc
+++ b/libinterp/octave-value/ov-str-mat.cc
@@ -580,17 +580,17 @@ octave_char_matrix_str::save_hdf5 (octav
 
   retval = H5Dwrite (data_hid, H5T_NATIVE_CHAR, octave_H5S_ALL, octave_H5S_ALL,
                      octave_H5P_DEFAULT, s) >= 0;
 
   H5Dclose (data_hid);
   H5Sclose (space_hid);
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
 #endif
 
   return retval;
 }
 
 bool
 octave_char_matrix_str::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
@@ -755,13 +755,13 @@ octave_char_matrix_str::load_hdf5 (octav
           H5Tclose (type_hid);
           H5Sclose (space_hid);
           H5Dclose (data_hid);
           return false;
         }
     }
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
 #endif
 
   return retval;
 }
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -908,17 +908,17 @@ octave_struct::save_hdf5 (octave_hdf5_id
         break;
     }
 
   H5Gclose (data_hid);
 
   return true;
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
   return false;
 #endif
 }
 
 bool
 octave_struct::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
@@ -956,17 +956,17 @@ octave_struct::load_hdf5 (octave_hdf5_id
 
   if (retval2 >= 0)
     {
       map = m;
       retval = true;
     }
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_struct::as_mxArray (void) const
 {
@@ -1508,17 +1508,17 @@ octave_scalar_struct::save_hdf5 (octave_
         break;
     }
 
   H5Gclose (data_hid);
 
   return true;
 
 #else
-  gripe_save ("hdf5");
+  warn_save ("hdf5");
   return false;
 #endif
 }
 
 bool
 octave_scalar_struct::load_hdf5 (octave_hdf5_id loc_id, const char *name)
 {
   bool retval = false;
@@ -1554,17 +1554,17 @@ octave_scalar_struct::load_hdf5 (octave_
 
   if (retval2 >= 0)
     {
       map = m;
       retval = true;
     }
 
 #else
-  gripe_load ("hdf5");
+  warn_load ("hdf5");
 #endif
 
   return retval;
 }
 
 mxArray *
 octave_scalar_struct::as_mxArray (void) const
 {
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2038,26 +2038,26 @@ octave_value::make_storable_value (void)
 int
 octave_value::write (octave_stream& os, int block_size,
                      oct_data_conv::data_type output_type, int skip,
                      oct_mach_info::float_format flt_fmt) const
 {
   return rep->write (os, block_size, output_type, skip, flt_fmt);
 }
 
-static void
-gripe_binary_op (const std::string& on, const std::string& tn1,
-                 const std::string& tn2)
+OCTAVE_NORETURN static void
+err_binary_op (const std::string& on, const std::string& tn1,
+               const std::string& tn2)
 {
   error ("binary operator '%s' not implemented for '%s' by '%s' operations",
          on.c_str (), tn1.c_str (), tn2.c_str ());
 }
 
-static void
-gripe_binary_op_conv (const std::string& on)
+OCTAVE_NORETURN static void
+err_binary_op_conv (const std::string& on)
 {
   error ("type conversion failed for binary operator '%s'", on.c_str ());
 }
 
 octave_value
 do_binary_op (octave_value::binary_op op,
               const octave_value& v1, const octave_value& v2)
 {
@@ -2074,18 +2074,18 @@ do_binary_op (octave_value::binary_op op
       octave_value_typeinfo::binary_class_op_fcn f
         = octave_value_typeinfo::lookup_binary_class_op (op);
 
       if (f)
         {
           retval = f (v1, v2);
         }
       else
-        gripe_binary_op (octave_value::binary_op_as_string (op),
-                         v1.class_name (), v2.class_name ());
+        err_binary_op (octave_value::binary_op_as_string (op),
+                       v1.class_name (), v2.class_name ());
     }
   else
     {
       // FIXME: we need to handle overloading operators for built-in
       // classes (double, char, int8, etc.)
 
       octave_value_typeinfo::binary_op_fcn f
         = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
@@ -2118,32 +2118,32 @@ do_binary_op (octave_value::binary_op op
               octave_base_value *tmp = cf1 (*v1.rep);
 
               if (tmp)
                 {
                   tv1 = octave_value (tmp);
                   t1 = tv1.type_id ();
                 }
               else
-                gripe_binary_op_conv (octave_value::binary_op_as_string (op));
+                err_binary_op_conv (octave_value::binary_op_as_string (op));
             }
           else
             tv1 = v1;
 
           if (cf2)
             {
               octave_base_value *tmp = cf2 (*v2.rep);
 
               if (tmp)
                 {
                   tv2 = octave_value (tmp);
                   t2 = tv2.type_id ();
                 }
               else
-                gripe_binary_op_conv (octave_value::binary_op_as_string (op));
+                err_binary_op_conv (octave_value::binary_op_as_string (op));
             }
           else
             tv2 = v2;
 
           if (cf1 || cf2)
             {
               retval = do_binary_op (op, tv1, tv2);
             }
@@ -2170,47 +2170,47 @@ do_binary_op (octave_value::binary_op op
                   octave_base_value *tmp = cf1 (*tv1.rep);
 
                   if (tmp)
                     {
                       tv1 = octave_value (tmp);
                       t1 = tv1.type_id ();
                     }
                   else
-                    gripe_binary_op_conv
+                    err_binary_op_conv
                       (octave_value::binary_op_as_string (op));
                 }
 
               if (cf2)
                 {
                   octave_base_value *tmp = cf2 (*tv2.rep);
 
                   if (tmp)
                     {
                       tv2 = octave_value (tmp);
                       t2 = tv2.type_id ();
                     }
                   else
-                    gripe_binary_op_conv
+                    err_binary_op_conv
                       (octave_value::binary_op_as_string (op));
                 }
 
               if (cf1 || cf2)
                 {
                   f = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
 
                   if (f)
                     retval = f (*tv1.rep, *tv2.rep);
                   else
-                    gripe_binary_op (octave_value::binary_op_as_string (op),
-                                     v1.type_name (), v2.type_name ());
+                    err_binary_op (octave_value::binary_op_as_string (op),
+                                   v1.type_name (), v2.type_name ());
                 }
               else
-                gripe_binary_op (octave_value::binary_op_as_string (op),
-                                 v1.type_name (), v2.type_name ());
+                err_binary_op (octave_value::binary_op_as_string (op),
+                               v1.type_name (), v2.type_name ());
             }
         }
     }
 
   return retval;
 }
 
 static octave_value
@@ -2310,27 +2310,25 @@ do_binary_op (octave_value::compound_bin
         retval = f (*v1.rep, *v2.rep);
       else
         retval = decompose_binary_op (op, v1, v2);
     }
 
   return retval;
 }
 
-OCTAVE_NORETURN static
-void
-gripe_cat_op (const std::string& tn1, const std::string& tn2)
+OCTAVE_NORETURN static void
+err_cat_op (const std::string& tn1, const std::string& tn2)
 {
   error ("concatenation operator not implemented for '%s' by '%s' operations",
          tn1.c_str (), tn2.c_str ());
 }
 
-OCTAVE_NORETURN static
-void
-gripe_cat_op_conv (void)
+OCTAVE_NORETURN static void
+err_cat_op_conv (void)
 {
   error ("type conversion failed for concatenation operator");
 }
 
 octave_value
 do_cat_op (const octave_value& v1, const octave_value& v2,
            const Array<octave_idx_type>& ra_idx)
 {
@@ -2368,42 +2366,42 @@ do_cat_op (const octave_value& v1, const
           octave_base_value *tmp = cf1 (*v1.rep);
 
           if (tmp)
             {
               tv1 = octave_value (tmp);
               t1 = tv1.type_id ();
             }
           else
-            gripe_cat_op_conv ();
+            err_cat_op_conv ();
         }
       else
         tv1 = v1;
 
       if (cf2)
         {
           octave_base_value *tmp = cf2 (*v2.rep);
 
           if (tmp)
             {
               tv2 = octave_value (tmp);
               t2 = tv2.type_id ();
             }
           else
-            gripe_cat_op_conv ();
+            err_cat_op_conv ();
         }
       else
         tv2 = v2;
 
       if (cf1 || cf2)
         {
           retval = do_cat_op (tv1, tv2, ra_idx);
         }
       else
-        gripe_cat_op (v1.type_name (), v2.type_name ());
+        err_cat_op (v1.type_name (), v2.type_name ());
     }
 
   return retval;
 }
 
 octave_value
 do_colon_op (const octave_value& base, const octave_value& increment,
              const octave_value& limit, bool is_for_cmd_expr)
@@ -2507,25 +2505,25 @@ octave_value::print_info (std::ostream& 
 {
   os << prefix << "type_name: " << type_name () << "\n"
      << prefix << "count:     " << get_count () << "\n"
      << prefix << "rep info:  ";
 
   rep->print_info (os, prefix + " ");
 }
 
-static void
-gripe_unary_op (const std::string& on, const std::string& tn)
+OCTAVE_NORETURN static void
+err_unary_op (const std::string& on, const std::string& tn)
 {
   error ("unary operator '%s' not implemented for '%s' operands",
          on.c_str (), tn.c_str ());
 }
 
-static void
-gripe_unary_op_conv (const std::string& on)
+OCTAVE_NORETURN static void
+err_unary_op_conv (const std::string& on)
 {
   error ("type conversion failed for unary operator '%s'", on.c_str ());
 }
 
 octave_value
 do_unary_op (octave_value::unary_op op, const octave_value& v)
 {
   octave_value retval;
@@ -2536,18 +2534,18 @@ do_unary_op (octave_value::unary_op op, 
       || t == octave_classdef::static_type_id ())
     {
       octave_value_typeinfo::unary_class_op_fcn f
         = octave_value_typeinfo::lookup_unary_class_op (op);
 
       if (f)
         retval = f (v);
       else
-        gripe_unary_op (octave_value::unary_op_as_string (op),
-                        v.class_name ());
+        err_unary_op (octave_value::unary_op_as_string (op),
+                      v.class_name ());
     }
   else
     {
       // FIXME: we need to handle overloading operators for built-in
       // classes (double, char, int8, etc.)
 
       octave_value_typeinfo::unary_op_fcn f
         = octave_value_typeinfo::lookup_unary_op (op, t);
@@ -2565,41 +2563,41 @@ do_unary_op (octave_value::unary_op op, 
               octave_base_value *tmp = cf (*v.rep);
 
               if (tmp)
                 {
                   tv = octave_value (tmp);
                   retval = do_unary_op (op, tv);
                 }
               else
-                gripe_unary_op_conv (octave_value::unary_op_as_string (op));
+                err_unary_op_conv (octave_value::unary_op_as_string (op));
             }
           else
-            gripe_unary_op (octave_value::unary_op_as_string (op),
-                            v.type_name ());
+            err_unary_op (octave_value::unary_op_as_string (op),
+                          v.type_name ());
         }
     }
 
   return retval;
 }
 
-static void
-gripe_unary_op_conversion_failed (const std::string& op,
-                                  const std::string& tn)
+OCTAVE_NORETURN static void
+err_unary_op_conversion_failed (const std::string& op,
+                                const std::string& tn)
 {
   error ("operator %s: type conversion for '%s' failed",
          op.c_str (), tn.c_str ());
 }
 
 octave_value&
 octave_value::do_non_const_unary_op (unary_op op)
 {
   if (op == op_incr || op == op_decr)
     {
-      // We want the gripe just here, because in the other branch this should
+      // We want the error just here, because in the other branch this should
       // not happen, and if it did anyway (internal error), the message would
       // be confusing.
       if (is_undefined ())
         {
           std::string op_str = unary_op_as_string (op);
           error ("in x%s or %sx, x must be defined first",
                  op_str.c_str (), op_str.c_str ());
           return *this;
@@ -2646,27 +2644,27 @@ octave_value::do_non_const_unary_op (una
                       if (old_rep)
                         {
                           if (--rep->count == 0)
                             delete rep;
 
                           rep = old_rep;
                         }
 
-                      gripe_unary_op (octave_value::unary_op_as_string (op),
-                                      type_name ());
+                      err_unary_op (octave_value::unary_op_as_string (op),
+                                    type_name ());
                     }
                 }
               else
-                gripe_unary_op_conversion_failed
+                err_unary_op_conversion_failed
                   (octave_value::unary_op_as_string (op), type_name ());
             }
           else
-            gripe_unary_op (octave_value::unary_op_as_string (op),
-                            type_name ());
+            err_unary_op (octave_value::unary_op_as_string (op),
+                          type_name ());
         }
     }
   else
     {
       // Non-genuine.
       int t = type_id ();
 
       octave_value_typeinfo::non_const_unary_op_fcn f = 0;
diff --git a/libinterp/parse-tree/lex.h b/libinterp/parse-tree/lex.h
--- a/libinterp/parse-tree/lex.h
+++ b/libinterp/parse-tree/lex.h
@@ -601,25 +601,25 @@ public:
   int handle_meta_identifier (void);
 
   int handle_fq_identifier (void);
 
   int handle_identifier (void);
 
   void maybe_warn_separator_insert (char sep);
 
-  void gripe_single_quote_string (void);
+  void warn_single_quote_string (void);
 
-  void gripe_language_extension (const std::string& msg);
+  void warn_language_extension (const std::string& msg);
 
-  void maybe_gripe_language_extension_comment (char c);
+  void maybe_warn_language_extension_comment (char c);
 
-  void gripe_language_extension_continuation (void);
+  void warn_language_extension_continuation (void);
 
-  void gripe_language_extension_operator (const std::string& op);
+  void warn_language_extension_operator (const std::string& op);
 
   void push_token (token *);
 
   token *current_token (void);
 
   void display_token (int tok);
 
   void fatal_error (const char *msg);
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -518,17 +518,17 @@ ANY_INCLUDING_NL (.|{NL})
 
 <MATRIX_START>{NL} {
     curr_lexer->lexer_debug ("<MATRIX_START>{NL}");
 
     curr_lexer->input_line_number++;
     curr_lexer->current_input_column = 1;
 
     if (curr_lexer->nesting_level.is_paren ())
-      curr_lexer->gripe_language_extension ("bare newline inside parentheses");
+      curr_lexer->warn_language_extension ("bare newline inside parentheses");
     else
       {
         int tok = curr_lexer->previous_token_value ();
 
         if (! (tok == ';' || tok == '[' || tok == '{'))
           {
             curr_lexer->xunput (';');
             // Adjust for semicolon that was not really in the input stream.
@@ -1351,17 +1351,17 @@ ANY_INCLUDING_NL (.|{NL})
     curr_lexer->lexer_debug ("{NL}");
 
     if (curr_lexer->nesting_level.is_paren ())
       {
         curr_lexer->input_line_number++;
         curr_lexer->current_input_column = 1;
 
         curr_lexer->at_beginning_of_statement = false;
-        curr_lexer->gripe_language_extension
+        curr_lexer->warn_language_extension
           ("bare newline inside parentheses");
       }
     else if (curr_lexer->nesting_level.none ()
         || curr_lexer->nesting_level.is_anon_fcn_body ())
       {
         curr_lexer->input_line_number++;
         curr_lexer->current_input_column = 1;
 
@@ -2822,17 +2822,17 @@ octave_base_lexer::handle_number (void)
 void
 octave_base_lexer::handle_continuation (void)
 {
   char *yytxt = flex_yytext ();
   int yylng = flex_yyleng ();
 
   int offset = 1;
   if (yytxt[0] == '\\')
-    gripe_language_extension_continuation ();
+    warn_language_extension_continuation ();
   else
     offset = 3;
 
   bool have_space = false;
   while (offset < yylng)
     {
       char c = yytxt[offset];
       if (c == ' ' || c == '\t')
@@ -3133,66 +3133,66 @@ octave_base_lexer::maybe_warn_separator_
                      sep, input_line_number);
   else
     warning_with_id ("Octave:separator-insert",
                      "potential auto-insertion of '%c' near line %d of file %s",
                      sep, input_line_number, nm.c_str ());
 }
 
 void
-octave_base_lexer::gripe_single_quote_string (void)
+octave_base_lexer::warn_single_quote_string (void)
 {
   std::string nm = fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:single-quote-string",
                      "single quote delimited string near line %d",
                      input_line_number);
   else
     warning_with_id ("Octave:single-quote-string",
                      "single quote delimited string near line %d of file %s",
                      input_line_number, nm.c_str ());
 }
 
 void
-octave_base_lexer::gripe_language_extension (const std::string& msg)
+octave_base_lexer::warn_language_extension (const std::string& msg)
 {
   std::string nm = fcn_file_full_name;
 
   if (nm.empty ())
     warning_with_id ("Octave:language-extension",
                      "Octave language extension used: %s",
                      msg.c_str ());
   else
     warning_with_id ("Octave:language-extension",
                      "Octave language extension used: %s near line %d offile %s",
                      msg.c_str (), input_line_number, nm.c_str ());
 }
 
 void
-octave_base_lexer::maybe_gripe_language_extension_comment (char c)
+octave_base_lexer::maybe_warn_language_extension_comment (char c)
 {
   if (c == '#')
-    gripe_language_extension ("# used as comment character");
+    warn_language_extension ("# used as comment character");
 }
 
 void
-octave_base_lexer::gripe_language_extension_continuation (void)
+octave_base_lexer::warn_language_extension_continuation (void)
 {
-  gripe_language_extension ("\\ used as line continuation marker");
+  warn_language_extension ("\\ used as line continuation marker");
 }
 
 void
-octave_base_lexer::gripe_language_extension_operator (const std::string& op)
+octave_base_lexer::warn_language_extension_operator (const std::string& op)
 {
   std::string t = op;
   int n = t.length ();
   if (t[n-1] == '\n')
     t.resize (n-1);
-  gripe_language_extension (t + " used as operator");
+  warn_language_extension (t + " used as operator");
 }
 
 void
 octave_base_lexer::push_token (token *tok)
 {
   YYSTYPE *lval = yyget_lval (scanner);
   lval->tok_val = tok;
   tokens.push (tok);
@@ -3488,17 +3488,17 @@ octave_base_lexer::handle_language_exten
   return maybe_unput_comma_before_unary_op (tok)
     ? -1 : handle_op_internal (tok, bos, false);
 }
 
 int
 octave_base_lexer::handle_op_internal (int tok, bool bos, bool compat)
 {
   if (! compat)
-    gripe_language_extension_operator (flex_yytext ());
+    warn_language_extension_operator (flex_yytext ());
 
   push_token (new token (tok, input_line_number, current_input_column));
 
   current_input_column += flex_yyleng ();
   looking_for_object_index = false;
   at_beginning_of_statement = bos;
 
   return count_token_internal (tok);
diff --git a/libinterp/parse-tree/pt-check.cc b/libinterp/parse-tree/pt-check.cc
--- a/libinterp/parse-tree/pt-check.cc
+++ b/libinterp/parse-tree/pt-check.cc
@@ -36,17 +36,17 @@ tree_checker::visit_argument_list (tree_
 
   while (p != lst.end ())
     {
       tree_expression *elt = *p++;
 
       if (elt)
         {
           if (do_lvalue_check && ! elt->lvalue_ok ())
-            gripe ("invalid lvalue in multiple assignment", elt->line ());
+            errmsg ("invalid lvalue in multiple assignment", elt->line ());
         }
     }
 }
 
 void
 tree_checker::visit_binary_expression (tree_binary_expression& expr)
 {
   tree_expression *op1 = expr.lhs ();
@@ -141,17 +141,17 @@ tree_checker::visit_decl_init_list (tree
 void
 tree_checker::visit_simple_for_command (tree_simple_for_command& cmd)
 {
   tree_expression *lhs = cmd.left_hand_side ();
 
   if (lhs)
     {
       if (! lhs->lvalue_ok ())
-        gripe ("invalid lvalue in for command", cmd.line ());
+        errmsg ("invalid lvalue in for command", cmd.line ());
     }
 
   tree_expression *expr = cmd.control_expr ();
 
   if (expr)
     expr->accept (*this);
 
   tree_expression *maxproc = cmd.maxproc_expr ();
@@ -170,17 +170,17 @@ tree_checker::visit_complex_for_command 
 {
   tree_argument_list *lhs = cmd.left_hand_side ();
 
   if (lhs)
     {
       int len = lhs->length ();
 
       if (len == 0 || len > 2)
-        gripe ("invalid number of output arguments in for command",
+        errmsg ("invalid number of output arguments in for command",
                cmd.line ());
 
       do_lvalue_check = true;
 
       lhs->accept (*this);
 
       do_lvalue_check = false;
     }
@@ -415,17 +415,17 @@ tree_checker::visit_return_list (tree_re
 void
 tree_checker::visit_simple_assignment (tree_simple_assignment& expr)
 {
   tree_expression *lhs = expr.left_hand_side ();
 
   if (lhs)
     {
       if (! lhs->lvalue_ok ())
-        gripe ("invalid lvalue in assignment", expr.line ());
+        errmsg ("invalid lvalue in assignment", expr.line ());
     }
 
   tree_expression *rhs = expr.right_hand_side ();
 
   if (rhs)
     rhs->accept (*this);
 }
 
@@ -504,17 +504,17 @@ tree_checker::visit_try_catch_command (t
 {
   tree_statement_list *try_code = cmd.body ();
 
   tree_identifier *expr_id = cmd.identifier ();
 
   if (expr_id)
     {
       if (! expr_id->lvalue_ok ())
-        gripe ("invalid lvalue used for identifier in try-catch command",
+        errmsg ("invalid lvalue used for identifier in try-catch command",
                cmd.line ());
     }
 
   if (try_code)
     try_code->accept (*this);
 
   tree_statement_list *catch_code = cmd.cleanup ();
 
@@ -560,15 +560,15 @@ tree_checker::visit_do_until_command (tr
 
   tree_expression *expr = cmd.condition ();
 
   if (expr)
     expr->accept (*this);
 }
 
 void
-tree_checker::gripe (const std::string& msg, int line)
+tree_checker::errmsg (const std::string& msg, int line)
 {
   if (file_name.empty ())
     error ("%s", msg.c_str ());
   else
     error ("%s: %d: %s", file_name.c_str (), line, msg.c_str ());
 }
diff --git a/libinterp/parse-tree/pt-check.h b/libinterp/parse-tree/pt-check.h
--- a/libinterp/parse-tree/pt-check.h
+++ b/libinterp/parse-tree/pt-check.h
@@ -126,17 +126,17 @@ public:
 private:
 
   bool do_lvalue_check;
 
   std::string file_name;
 
   void do_decl_command (tree_decl_command&);
 
-  void gripe (const std::string& msg, int line);
+  OCTAVE_NORETURN void errmsg (const std::string& msg, int line);
 
   // No copying!
 
   tree_checker (const tree_checker&);
 
   tree_checker& operator = (const tree_checker&);
 };
 
diff --git a/liboctave/array/PermMatrix.cc b/liboctave/array/PermMatrix.cc
--- a/liboctave/array/PermMatrix.cc
+++ b/liboctave/array/PermMatrix.cc
@@ -24,31 +24,32 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include "PermMatrix.h"
 #include "idx-vector.h"
 #include "Array-util.h"
 #include "oct-locbuf.h"
 
-static void
-gripe_invalid_permutation (void)
+OCTAVE_NORETURN static
+void
+err_invalid_permutation (void)
 {
   (*current_liboctave_error_handler)
     ("PermMatrix: invalid permutation vector");
 }
 
 void
 PermMatrix::setup (const Array<octave_idx_type>& p, bool colp, bool check)
 {
   if (check)
     {
       if (! idx_vector (p).is_permutation (p.numel ()))
         {
-          gripe_invalid_permutation ();
+          err_invalid_permutation ();
           Array<octave_idx_type>::operator = (Array<octave_idx_type> ());
         }
     }
 
   if (! colp)
     *this = this->transpose ();
 }
 
@@ -65,23 +66,21 @@ PermMatrix::PermMatrix (const Array<octa
 }
 
 void
 PermMatrix::setup (const idx_vector& idx, bool colp, octave_idx_type n)
 {
   octave_idx_type len = idx.length (n);
 
   if (! idx.is_permutation (len))
-    gripe_invalid_permutation ();
-  else
-    {
-      Array<octave_idx_type> idxa (dim_vector (len, 1));
-      for (octave_idx_type i = 0; i < len; i++) idxa(i) = idx(i);
-      Array<octave_idx_type>::operator = (idxa);
-    }
+    err_invalid_permutation ();
+
+  Array<octave_idx_type> idxa (dim_vector (len, 1));
+  for (octave_idx_type i = 0; i < len; i++) idxa(i) = idx(i);
+  Array<octave_idx_type>::operator = (idxa);
 
   if (! colp)
     *this = this->transpose ();
 }
 
 PermMatrix::PermMatrix (const idx_vector& idx)
   : Array<octave_idx_type> ()
 {
diff --git a/liboctave/array/idx-vector.cc b/liboctave/array/idx-vector.cc
--- a/liboctave/array/idx-vector.cc
+++ b/liboctave/array/idx-vector.cc
@@ -35,21 +35,21 @@ along with Octave; see the file COPYING.
 #include "Array-util.h"
 #include "Sparse.h"
 #include "Range.h"
 
 #include "oct-locbuf.h"
 #include "lo-error.h"
 #include "lo-mappers.h"
 
-static void
-gripe_invalid_range (void)
+OCTAVE_NORETURN static
+void
+err_invalid_range (void)
 {
-  (*current_liboctave_error_handler)
-    ("invalid range used as index");
+  (*current_liboctave_error_handler) ("invalid range used as index");
 }
 
 static void
 err_index_out_of_range (void)
 {
   (*current_liboctave_error_handler)
     ("internal error: idx_vector index out of range");
 }
@@ -105,17 +105,17 @@ idx_vector::idx_colon_rep::print (std::o
 
 idx_vector::idx_range_rep::idx_range_rep (octave_idx_type _start,
                                           octave_idx_type _limit,
                                           octave_idx_type _step)
   : start(_start), len (_step ? std::max ((_limit - _start) / _step, static_cast<octave_idx_type> (0)) : -1), step (_step)
 {
   if (len < 0)
     {
-      gripe_invalid_range ();
+      err_invalid_range ();
       err = true;
     }
   else if (start < 0)
     {
       err_invalid_index (start);
       err = true;
     }
   else if (step < 0 && start + (len-1)*step < 0)
@@ -124,21 +124,19 @@ idx_vector::idx_range_rep::idx_range_rep
       err = true;
     }
 }
 
 idx_vector::idx_range_rep::idx_range_rep (const Range& r)
   : start (0), len (r.numel ()), step (1)
 {
   if (len < 0)
-    {
-      gripe_invalid_range ();
-      err = true;
-    }
-  else if (len > 0)
+    err_invalid_range ();
+
+  if (len > 0)
     {
       if (r.all_elements_are_ints ())
         {
           start = static_cast<octave_idx_type> (r.base ()) - 1;
           step = static_cast<octave_idx_type> (r.inc ());
           if (start < 0)
             {
               err_invalid_index (start);
@@ -228,22 +226,18 @@ idx_vector::idx_range_rep::as_array (voi
 
   return retval;
 }
 
 inline octave_idx_type
 convert_index (octave_idx_type i, bool& conv_error,
                octave_idx_type& ext)
 {
-  if (i <= 0)
-    {
-      if (! conv_error)          // only gripe once, for things like A(-10000:0)
-        err_invalid_index (i-1);
-      conv_error = true;
-    }
+  if (i <= 0 && ! conv_error)
+    err_invalid_index (i-1);
 
   if (ext < i)
     ext = i;
 
   return i - 1;
 }
 
 inline octave_idx_type
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -2255,31 +2255,31 @@ biry (const FloatComplexNDArray& z, bool
   ierr.resize (dv);
 
   for (octave_idx_type i = 0; i < nel; i++)
     retval(i) = biry (z(i), deriv, scaled, ierr(i));
 
   return retval;
 }
 
-static void
-gripe_betainc_nonconformant (const dim_vector& d1, const dim_vector& d2,
+OCTAVE_NORETURN static void
+err_betainc_nonconformant (const dim_vector& d1, const dim_vector& d2,
                              const dim_vector& d3)
 {
   std::string d1_str = d1.str ();
   std::string d2_str = d2.str ();
   std::string d3_str = d3.str ();
 
   (*current_liboctave_error_handler)
     ("betainc: nonconformant arguments (x is %s, a is %s, b is %s)",
      d1_str.c_str (), d2_str.c_str (), d3_str.c_str ());
 }
 
-static void
-gripe_betaincinv_nonconformant (const dim_vector& d1, const dim_vector& d2,
+OCTAVE_NORETURN static void
+err_betaincinv_nonconformant (const dim_vector& d1, const dim_vector& d2,
                                 const dim_vector& d3)
 {
   std::string d1_str = d1.str ();
   std::string d2_str = d2.str ();
   std::string d3_str = d3.str ();
 
   (*current_liboctave_error_handler)
     ("betaincinv: nonconformant arguments (x is %s, a is %s, b is %s)",
@@ -2339,17 +2339,17 @@ betainc (double x, const Array<double>& 
       retval.resize (dv);
 
       double *pretval = retval.fortran_vec ();
 
       for (octave_idx_type i = 0; i < nel; i++)
         *pretval++ = betainc (x, a(i), b(i));
     }
   else
-    gripe_betainc_nonconformant (dim_vector (0, 0), dv, b.dims ());
+    err_betainc_nonconformant (dim_vector (0, 0), dv, b.dims ());
 
   return retval;
 }
 
 Array<double>
 betainc (const Array<double>& x, double a, double b)
 {
   dim_vector dv = x.dims ();
@@ -2378,17 +2378,17 @@ betainc (const Array<double>& x, double 
       retval.resize (dv);
 
       double *pretval = retval.fortran_vec ();
 
       for (octave_idx_type i = 0; i < nel; i++)
         *pretval++ = betainc (x(i), a, b(i));
     }
   else
-    gripe_betainc_nonconformant (dv, dim_vector (0, 0), b.dims ());
+    err_betainc_nonconformant (dv, dim_vector (0, 0), b.dims ());
 
   return retval;
 }
 
 Array<double>
 betainc (const Array<double>& x, const Array<double>& a, double b)
 {
   Array<double> retval;
@@ -2401,17 +2401,17 @@ betainc (const Array<double>& x, const A
       retval.resize (dv);
 
       double *pretval = retval.fortran_vec ();
 
       for (octave_idx_type i = 0; i < nel; i++)
         *pretval++ = betainc (x(i), a(i), b);
     }
   else
-    gripe_betainc_nonconformant (dv, a.dims (), dim_vector (0, 0));
+    err_betainc_nonconformant (dv, a.dims (), dim_vector (0, 0));
 
   return retval;
 }
 
 Array<double>
 betainc (const Array<double>& x, const Array<double>& a, const Array<double>& b)
 {
   Array<double> retval;
@@ -2424,17 +2424,17 @@ betainc (const Array<double>& x, const A
       retval.resize (dv);
 
       double *pretval = retval.fortran_vec ();
 
       for (octave_idx_type i = 0; i < nel; i++)
         *pretval++ = betainc (x(i), a(i), b(i));
     }
   else
-    gripe_betainc_nonconformant (dv, a.dims (), b.dims ());
+    err_betainc_nonconformant (dv, a.dims (), b.dims ());
 
   return retval;
 }
 
 float
 betainc (float x, float a, float b)
 {
   float retval;
@@ -2487,17 +2487,17 @@ betainc (float x, const Array<float>& a,
       retval.resize (dv);
 
       float *pretval = retval.fortran_vec ();
 
       for (octave_idx_type i = 0; i < nel; i++)
         *pretval++ = betainc (x, a(i), b(i));
     }
   else
-    gripe_betainc_nonconformant (dim_vector (0, 0), dv, b.dims ());
+    err_betainc_nonconformant (dim_vector (0, 0), dv, b.dims ());
 
   return retval;
 }
 
 Array<float>
 betainc (const Array<float>& x, float a, float b)
 {
   dim_vector dv = x.dims ();
@@ -2526,17 +2526,17 @@ betainc (const Array<float>& x, float a,
       retval.resize (dv);
 
       float *pretval = retval.fortran_vec ();
 
       for (octave_idx_type i = 0; i < nel; i++)
         *pretval++ = betainc (x(i), a, b(i));
     }
   else
-    gripe_betainc_nonconformant (dv, dim_vector (0, 0), b.dims ());
+    err_betainc_nonconformant (dv, dim_vector (0, 0), b.dims ());
 
   return retval;
 }
 
 Array<float>
 betainc (const Array<float>& x, const Array<float>& a, float b)
 {
   Array<float> retval;
@@ -2549,17 +2549,17 @@ betainc (const Array<float>& x, const Ar
       retval.resize (dv);
 
       float *pretval = retval.fortran_vec ();
 
       for (octave_idx_type i = 0; i < nel; i++)
         *pretval++ = betainc (x(i), a(i), b);
     }
   else
-    gripe_betainc_nonconformant (dv, a.dims (), dim_vector (0, 0));
+    err_betainc_nonconformant (dv, a.dims (), dim_vector (0, 0));
 
   return retval;
 }
 
 Array<float>
 betainc (const Array<float>& x, const Array<float>& a, const Array<float>& b)
 {
   Array<float> retval;
@@ -2572,17 +2572,17 @@ betainc (const Array<float>& x, const Ar
       retval.resize (dv);
 
       float *pretval = retval.fortran_vec ();
 
       for (octave_idx_type i = 0; i < nel; i++)
         *pretval++ = betainc (x(i), a(i), b(i));
     }
   else
-    gripe_betainc_nonconformant (dv, a.dims (), b.dims ());
+    err_betainc_nonconformant (dv, a.dims (), b.dims ());
 
   return retval;
 }
 
 // FIXME: there is still room for improvement here...
 
 double
 gammainc (double x, double a, bool& err)
@@ -3546,17 +3546,17 @@ betaincinv (double x, const Array<double
       retval.resize (dv);
 
       double *pretval = retval.fortran_vec ();
 
       for (octave_idx_type i = 0; i < nel; i++)
         *pretval++ = betaincinv (x, a(i), b(i));
     }
   else
-    gripe_betaincinv_nonconformant (dim_vector (0, 0), dv, b.dims ());
+    err_betaincinv_nonconformant (dim_vector (0, 0), dv, b.dims ());
 
   return retval;
 }
 
 Array<double>
 betaincinv (const Array<double>& x, double a, double b)
 {
   dim_vector dv = x.dims ();
@@ -3585,17 +3585,17 @@ betaincinv (const Array<double>& x, doub
       retval.resize (dv);
 
       double *pretval = retval.fortran_vec ();
 
       for (octave_idx_type i = 0; i < nel; i++)
         *pretval++ = betaincinv (x(i), a, b(i));
     }
   else
-    gripe_betaincinv_nonconformant (dv, dim_vector (0, 0), b.dims ());
+    err_betaincinv_nonconformant (dv, dim_vector (0, 0), b.dims ());
 
   return retval;
 }
 
 Array<double>
 betaincinv (const Array<double>& x, const Array<double>& a, double b)
 {
   Array<double> retval;
@@ -3608,17 +3608,17 @@ betaincinv (const Array<double>& x, cons
       retval.resize (dv);
 
       double *pretval = retval.fortran_vec ();
 
       for (octave_idx_type i = 0; i < nel; i++)
         *pretval++ = betaincinv (x(i), a(i), b);
     }
   else
-    gripe_betaincinv_nonconformant (dv, a.dims (), dim_vector (0, 0));
+    err_betaincinv_nonconformant (dv, a.dims (), dim_vector (0, 0));
 
   return retval;
 }
 
 Array<double>
 betaincinv (const Array<double>& x, const Array<double>& a,
             const Array<double>& b)
 {
@@ -3632,17 +3632,17 @@ betaincinv (const Array<double>& x, cons
       retval.resize (dv);
 
       double *pretval = retval.fortran_vec ();
 
       for (octave_idx_type i = 0; i < nel; i++)
         *pretval++ = betaincinv (x(i), a(i), b(i));
     }
   else
-    gripe_betaincinv_nonconformant (dv, a.dims (), b.dims ());
+    err_betaincinv_nonconformant (dv, a.dims (), b.dims ());
 
   return retval;
 }
 
 void
 ellipj (double u, double m, double& sn, double& cn, double& dn, double& err)
 {
   static const int Nmax = 16;
diff --git a/liboctave/system/oct-group.cc b/liboctave/system/oct-group.cc
--- a/liboctave/system/oct-group.cc
+++ b/liboctave/system/oct-group.cc
@@ -32,48 +32,55 @@ along with Octave; see the file COPYING.
 
 #include "lo-error.h"
 #include "oct-group.h"
 #include "str-vec.h"
 
 #define NOT_SUPPORTED(nm) \
   nm ": not supported on this system"
 
+OCTAVE_NORETURN static
+void
+err_invalid (void)
+{
+  (*current_liboctave_error_handler) ("invalid group object");
+}
+
 std::string
 octave_group::name (void) const
 {
   if (! ok ())
-    gripe_invalid ();
+    err_invalid ();
 
   return gr_name;
 }
 
 std::string
 octave_group::passwd (void) const
 {
   if (! ok ())
-    gripe_invalid ();
+    err_invalid ();
 
   return gr_passwd;
 }
 
 gid_t
 octave_group::gid (void) const
 {
   if (! ok ())
-    gripe_invalid ();
+    err_invalid ();
 
   return gr_gid;
 }
 
 string_vector
 octave_group::mem (void) const
 {
   if (! ok ())
-    gripe_invalid ();
+    err_invalid ();
 
   return gr_mem;
 }
 
 octave_group
 octave_group::getgrent (void)
 {
   std::string msg;
@@ -209,13 +216,8 @@ octave_group::octave_group (void *p, std
 
       valid = true;
     }
 #else
   msg = NOT_SUPPORTED ("group functions");
 #endif
 }
 
-void
-octave_group::gripe_invalid (void) const
-{
-  (*current_liboctave_error_handler) ("invalid group object");
-}
diff --git a/liboctave/system/oct-group.h b/liboctave/system/oct-group.h
--- a/liboctave/system/oct-group.h
+++ b/liboctave/system/oct-group.h
@@ -100,13 +100,11 @@ private:
   string_vector gr_mem;
 
   // Flag that says whether we have been properly initialized.
   bool valid;
 
   // This is how we will create an octave_group object from a pointer
   // to a struct group.
   octave_group (void *p, std::string& msg);
-
-  void gripe_invalid (void) const;
 };
 
 #endif
diff --git a/liboctave/system/oct-passwd.cc b/liboctave/system/oct-passwd.cc
--- a/liboctave/system/oct-passwd.cc
+++ b/liboctave/system/oct-passwd.cc
@@ -31,75 +31,82 @@ along with Octave; see the file COPYING.
 #endif
 
 #include "lo-error.h"
 #include "oct-passwd.h"
 
 #define NOT_SUPPORTED(nm) \
   nm ": not supported on this system"
 
+OCTAVE_NORETURN static
+void
+err_invalid (void)
+{
+  (*current_liboctave_error_handler) ("invalid password object");
+}
+
 std::string
 octave_passwd::name (void) const
 {
   if (! ok ())
-    gripe_invalid ();
+    err_invalid ();
 
   return pw_name;
 }
 
 std::string
 octave_passwd::passwd (void) const
 {
   if (! ok ())
-    gripe_invalid ();
+    err_invalid ();
 
   return pw_passwd;
 }
 
 uid_t
 octave_passwd::uid (void) const
 {
   if (! ok ())
-    gripe_invalid ();
+    err_invalid ();
 
   return pw_uid;
 }
 
 gid_t
 octave_passwd::gid (void) const
 {
   if (! ok ())
-    gripe_invalid ();
+    err_invalid ();
 
   return pw_gid;
 }
 
 std::string
 octave_passwd::gecos (void) const
 {
   if (! ok ())
-    gripe_invalid ();
+    err_invalid ();
 
   return pw_gecos;
 }
 
 std::string
 octave_passwd::dir (void) const
 {
   if (! ok ())
-    gripe_invalid ();
+    err_invalid ();
 
   return pw_dir;
 }
 
 std::string
 octave_passwd::shell (void) const
 {
   if (! ok ())
-    gripe_invalid ();
+    err_invalid ();
 
   return pw_shell;
 }
 
 octave_passwd
 octave_passwd::getpwent (void)
 {
   std::string msg;
@@ -217,13 +224,8 @@ octave_passwd::octave_passwd (void *p, s
 
       valid = true;
     }
 #else
   msg = NOT_SUPPORTED ("password functions");
 #endif
 }
 
-void
-octave_passwd::gripe_invalid (void) const
-{
-  (*current_liboctave_error_handler) ("invalid password object");
-}
diff --git a/liboctave/system/oct-passwd.h b/liboctave/system/oct-passwd.h
--- a/liboctave/system/oct-passwd.h
+++ b/liboctave/system/oct-passwd.h
@@ -120,13 +120,11 @@ private:
   std::string pw_shell;
 
   // Flag that says whether we have been properly initialized.
   bool valid;
 
   // This is how we will create an octave_passwd object from a pointer
   // to a struct passwd.
   octave_passwd (void *p, std::string& msg);
-
-  void gripe_invalid (void) const;
 };
 
 #endif
diff --git a/liboctave/util/data-conv.cc b/liboctave/util/data-conv.cc
--- a/liboctave/util/data-conv.cc
+++ b/liboctave/util/data-conv.cc
@@ -612,18 +612,19 @@ oct_data_conv::data_type_as_string (oct_
           std::streamsize n_bytes = size * static_cast<std::streamsize> (len); \
           stream.write (reinterpret_cast<char *> (ptr), n_bytes); \
         } \
     } \
   while (0)
 
 // Loading variables from files.
 
-static void
-gripe_unrecognized_float_fmt (void)
+OCTAVE_NORETURN static
+void
+err_unrecognized_float_fmt (void)
 {
   (*current_liboctave_error_handler)
     ("unrecognized floating point format requested");
 }
 
 // But first, some data conversion routines.
 
 // Currently, we only handle conversions for the IEEE types.  To fix
@@ -670,33 +671,33 @@ do_double_format_conversion (void *data,
         case oct_mach_info::flt_fmt_ieee_little_endian:
           break;
 
         case oct_mach_info::flt_fmt_ieee_big_endian:
           IEEE_big_double_to_IEEE_little_double (data, len);
           break;
 
         default:
-          gripe_unrecognized_float_fmt ();
+          err_unrecognized_float_fmt ();
           break;
         }
       break;
 
     case oct_mach_info::flt_fmt_ieee_big_endian:
       switch (from_fmt)
         {
         case oct_mach_info::flt_fmt_ieee_little_endian:
           IEEE_little_double_to_IEEE_big_double (data, len);
           break;
 
         case oct_mach_info::flt_fmt_ieee_big_endian:
           break;
 
         default:
-          gripe_unrecognized_float_fmt ();
+          err_unrecognized_float_fmt ();
           break;
         }
       break;
 
     default:
       (*current_liboctave_error_handler)
         ("impossible state reached in file '%s' at line %d",
          __FILE__, __LINE__);
@@ -717,33 +718,33 @@ do_float_format_conversion (void *data, 
         case oct_mach_info::flt_fmt_ieee_little_endian:
           break;
 
         case oct_mach_info::flt_fmt_ieee_big_endian:
           IEEE_big_float_to_IEEE_little_float (data, len);
           break;
 
         default:
-          gripe_unrecognized_float_fmt ();
+          err_unrecognized_float_fmt ();
           break;
         }
       break;
 
     case oct_mach_info::flt_fmt_ieee_big_endian:
       switch (from_fmt)
         {
         case oct_mach_info::flt_fmt_ieee_little_endian:
           IEEE_little_float_to_IEEE_big_float (data, len);
           break;
 
         case oct_mach_info::flt_fmt_ieee_big_endian:
           break;
 
         default:
-          gripe_unrecognized_float_fmt ();
+          err_unrecognized_float_fmt ();
           break;
         }
       break;
 
     default:
       (*current_liboctave_error_handler)
         ("impossible state reached in file '%s' at line %d",
          __FILE__, __LINE__);
diff --git a/liboctave/util/lo-cutils.c b/liboctave/util/lo-cutils.c
--- a/liboctave/util/lo-cutils.c
+++ b/liboctave/util/lo-cutils.c
@@ -75,126 +75,126 @@ octave_w32_library_search (HINSTANCE han
 
 OCTAVE_API pid_t
 octave_waitpid (pid_t pid, int *status, int options)
 {
   return WAITPID (pid, status, options);
 }
 
 static inline void
-gripe_missing_wait_macro (const char *id, int status)
+warn_missing_wait_macro (const char *id, int status)
 {
   (*current_liboctave_warning_handler)
     ("%s always returns false in this version of Octave; status = %d",
      id, status);
 }
 
 OCTAVE_API int
 octave_wifexited (int status)
 {
   int retval = 0;
 
 #if defined (WIFEXITED)
   retval = WIFEXITED (status);
 #else
-  gripe_missing_wait_macro ("WIFEXITED", status);
+  warn_missing_wait_macro ("WIFEXITED", status);
 #endif
 
   return retval;
 }
 
 OCTAVE_API int
 octave_wexitstatus (int status)
 {
   int retval = 0;
 
 #if defined (WEXITSTATUS)
   retval = WEXITSTATUS (status);
 #else
-  gripe_missing_wait_macro ("WEXITSTATUS", status);
+  warn_missing_wait_macro ("WEXITSTATUS", status);
 #endif
 
   return retval;
 }
 
 OCTAVE_API int
 octave_wifsignaled (int status)
 {
   int retval = 0;
 
 #if defined (WIFSIGNALED)
   retval = WIFSIGNALED (status);
 #else
-  gripe_missing_wait_macro ("WIFSIGNALED", status);
+  warn_missing_wait_macro ("WIFSIGNALED", status);
 #endif
 
   return retval;
 }
 
 OCTAVE_API int
 octave_wtermsig (int status)
 {
   int retval = 0;
 
 #if defined (WTERMSIG)
   retval = WTERMSIG (status);
 #else
-  gripe_missing_wait_macro ("WTERMSIG", status);
+  warn_missing_wait_macro ("WTERMSIG", status);
 #endif
 
   return retval;
 }
 
 OCTAVE_API int
 octave_wcoredump (int status)
 {
   int retval = 0;
 
 #if defined (WCOREDUMP)
   retval = WCOREDUMP (status);
 #else
-  gripe_missing_wait_macro ("WCOREDUMP", status);
+  warn_missing_wait_macro ("WCOREDUMP", status);
 #endif
 
   return retval;
 }
 
 OCTAVE_API int
 octave_wifstopped (int status)
 {
   int retval = 0;
 
 #if defined (WIFSTOPPED)
   retval = WIFSTOPPED (status);
 #else
-  gripe_missing_wait_macro ("WIFSTOPPED", status);
+  warn_missing_wait_macro ("WIFSTOPPED", status);
 #endif
 
   return retval;
 }
 
 OCTAVE_API int
 octave_wstopsig (int status)
 {
   int retval = 0;
 
 #if defined (WSTOPSIG)
   retval = WSTOPSIG (status);
 #else
-  gripe_missing_wait_macro ("WSTOPSIG", status);
+  warn_missing_wait_macro ("WSTOPSIG", status);
 #endif
 
   return retval;
 }
 
 OCTAVE_API int
 octave_wifcontinued (int status)
 {
   int retval = 0;
 
 #if defined (WIFCONTINUED)
   retval = WIFCONTINUED (status);
 #else
-  gripe_missing_wait_macro ("WIFCONTINUED", status);
+  warn_missing_wait_macro ("WIFCONTINUED", status);
 #endif
 
   return retval;
 }
diff --git a/liboctave/util/unwind-prot.cc b/liboctave/util/unwind-prot.cc
--- a/liboctave/util/unwind-prot.cc
+++ b/liboctave/util/unwind-prot.cc
@@ -24,15 +24,16 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "lo-error.h"
 #include "unwind-prot.h"
 
 void
-unwind_protect_safe::gripe_exception (void)
+unwind_protect_safe::err_unhandled_exception (void)
 {
   // FIXME: can this throw an exception?
+  //        Yes, it can now (1/18/16).  Maybe this needs to be re-done?
 
   (*current_liboctave_error_handler)
     ("internal: unhandled exception in unwind_protect handler");
 }
diff --git a/liboctave/util/unwind-prot.h b/liboctave/util/unwind-prot.h
--- a/liboctave/util/unwind-prot.h
+++ b/liboctave/util/unwind-prot.h
@@ -107,33 +107,33 @@ private:
 // crash.
 
 class
 OCTAVE_API
 unwind_protect_safe : public unwind_protect
 {
 private:
 
-  static void gripe_exception (void);
+  static void err_unhandled_exception (void);
 
 public:
 
   unwind_protect_safe (void) : unwind_protect () { }
 
   ~unwind_protect_safe (void)
   {
     while (! empty ())
       {
         try
           {
             run_first ();
           }
-        catch (...) // Yes, the black hole. Remember we're in a dtor.
+        catch (...) // Yes, the black hole.  Remember we're in a destructor.
           {
-            gripe_exception ();
+            err_unhandled_exception ();
           }
       }
   }
 
 private:
 
   // No copying!
 
