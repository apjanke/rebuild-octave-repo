# HG changeset patch
# User Rik <rik@octave.org>
# Date 1453334910 28800
#      Wed Jan 20 16:08:30 2016 -0800
# Node ID 3ac9f47fb04b06a080bb060427f7d6eb64a48cf3
# Parent  c1df363732725928e9ebb79d1571bb663678cf07
Invert pattern if/code/else/err_XXX to if !/err_XXX/code.

* daspk.cc, dasrt.cc, dassl.cc, data.cc, debug.cc, load-save.cc, lsode.cc,
quad.cc, xnorm.cc, xpow.cc, ov-base-diag.cc, ov-base-mat.cc, ov-base-scalar.cc,
ov-base.cc, ov-bool-mat.cc, ov-bool-sparse.cc, ov-cell.cc, ov-ch-mat.cc,
ov-class.cc, ov-cx-mat.cc, ov-cx-sparse.cc, ov-float.cc, ov-flt-cx-mat.cc,
ov-flt-re-mat.cc, ov-intx.h, ov-perm.cc, ov-range.cc, ov-re-mat.cc,
ov-re-sparse.cc, ov-scalar.cc, ov-struct.cc, ov.cc, pt-idx.cc, Array-util.cc,
Array.cc, Sparse.cc, lo-specfun.cc, mx-inlines.cc, oct-binmap.h:
Invert pattern if/code/else/err_XXX to if !/err_XXX/code.

diff --git a/libinterp/corefcn/daspk.cc b/libinterp/corefcn/daspk.cc
--- a/libinterp/corefcn/daspk.cc
+++ b/libinterp/corefcn/daspk.cc
@@ -80,33 +80,31 @@ daspk_user_function (const ColumnVector&
           tmp = daspk_fcn->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
           err_user_supplied_eval (e, "daspk");
         }
 
       int tlen = tmp.length ();
-      if (tlen > 0 && tmp(0).is_defined ())
-        {
-          if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
-            {
-              warning ("daspk: ignoring imaginary part returned from user-supplied function");
-              warned_fcn_imaginary = true;
-            }
+      if (tlen == 0 || ! tmp(0).is_defined ())
+        err_user_supplied_eval ("daspk");
 
-          retval = tmp(0).vector_value ();
-
-          if (tlen > 1)
-            ires = tmp(1).idx_type_value ();
+      if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
+        {
+          warning ("daspk: ignoring imaginary part returned from user-supplied function");
+          warned_fcn_imaginary = true;
+        }
 
-          if (retval.is_empty ())
-            err_user_supplied_eval ("daspk");
-        }
-      else
+      retval = tmp(0).vector_value ();
+
+      if (tlen > 1)
+        ires = tmp(1).idx_type_value ();
+
+      if (retval.is_empty ())
         err_user_supplied_eval ("daspk");
     }
 
   return retval;
 }
 
 Matrix
 daspk_user_jacobian (const ColumnVector& x, const ColumnVector& xdot,
@@ -132,30 +130,28 @@ daspk_user_jacobian (const ColumnVector&
           tmp = daspk_jac->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
           err_user_supplied_eval (e, "daspk");
         }
 
       int tlen = tmp.length ();
-      if (tlen > 0 && tmp(0).is_defined ())
+      if (tlen == 0 || ! tmp(0).is_defined ())
+        err_user_supplied_eval ("daspk");
+
+      if (! warned_jac_imaginary && tmp(0).is_complex_type ())
         {
-          if (! warned_jac_imaginary && tmp(0).is_complex_type ())
-            {
-              warning ("daspk: ignoring imaginary part returned from user-supplied jacobian function");
-              warned_jac_imaginary = true;
-            }
+          warning ("daspk: ignoring imaginary part returned from user-supplied jacobian function");
+          warned_jac_imaginary = true;
+        }
 
-          retval = tmp(0).matrix_value ();
+      retval = tmp(0).matrix_value ();
 
-          if (retval.is_empty ())
-            err_user_supplied_eval ("daspk");
-        }
-      else
+      if (retval.is_empty ())
         err_user_supplied_eval ("daspk");
     }
 
   return retval;
 }
 
 DEFUN (daspk, args, nargout,
        "-*- texinfo -*-\n\
diff --git a/libinterp/corefcn/dasrt.cc b/libinterp/corefcn/dasrt.cc
--- a/libinterp/corefcn/dasrt.cc
+++ b/libinterp/corefcn/dasrt.cc
@@ -79,30 +79,28 @@ dasrt_user_f (const ColumnVector& x, con
         {
           tmp = dasrt_f->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
           err_user_supplied_eval (e, "dasrt");
         }
 
-      if (tmp.length () > 0 && tmp(0).is_defined ())
+      if (tmp.length () < 1 || ! tmp(0).is_defined ())
+        err_user_supplied_eval ("dasrt");
+
+      if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
         {
-          if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
-            {
-              warning ("dasrt: ignoring imaginary part returned from user-supplied function");
-              warned_fcn_imaginary = true;
-            }
+          warning ("dasrt: ignoring imaginary part returned from user-supplied function");
+          warned_fcn_imaginary = true;
+        }
 
-          retval = tmp(0).vector_value ();
+      retval = tmp(0).vector_value ();
 
-          if (retval.is_empty ())
-            err_user_supplied_eval ("dasrt");
-        }
-      else
+      if (retval.is_empty ())
         err_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
 
 static ColumnVector
 dasrt_user_cf (const ColumnVector& x, double t)
@@ -122,30 +120,28 @@ dasrt_user_cf (const ColumnVector& x, do
         {
           tmp = dasrt_cf->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
           err_user_supplied_eval (e, "dasrt");
         }
 
-      if (tmp.length () > 0 && tmp(0).is_defined ())
+      if (tmp.length () == 0 || ! tmp(0).is_defined ())
+        err_user_supplied_eval ("dasrt");
+
+      if (! warned_cf_imaginary && tmp(0).is_complex_type ())
         {
-          if (! warned_cf_imaginary && tmp(0).is_complex_type ())
-            {
-              warning ("dasrt: ignoring imaginary part returned from user-supplied constraint function");
-              warned_cf_imaginary = true;
-            }
+          warning ("dasrt: ignoring imaginary part returned from user-supplied constraint function");
+          warned_cf_imaginary = true;
+        }
 
-          retval = tmp(0).vector_value ();
+      retval = tmp(0).vector_value ();
 
-          if (retval.is_empty ())
-            err_user_supplied_eval ("dasrt");
-        }
-      else
+      if (retval.is_empty ())
         err_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
 
 static Matrix
 dasrt_user_j (const ColumnVector& x, const ColumnVector& xdot,
@@ -171,30 +167,28 @@ dasrt_user_j (const ColumnVector& x, con
           tmp = dasrt_j->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
           err_user_supplied_eval (e, "dasrt");
         }
 
       int tlen = tmp.length ();
-      if (tlen > 0 && tmp(0).is_defined ())
+      if (tlen == 0 || ! tmp(0).is_defined ())
+        err_user_supplied_eval ("dasrt");
+
+      if (! warned_jac_imaginary && tmp(0).is_complex_type ())
         {
-          if (! warned_jac_imaginary && tmp(0).is_complex_type ())
-            {
-              warning ("dasrt: ignoring imaginary part returned from user-supplied jacobian function");
-              warned_jac_imaginary = true;
-            }
+          warning ("dasrt: ignoring imaginary part returned from user-supplied jacobian function");
+          warned_jac_imaginary = true;
+        }
 
-          retval = tmp(0).matrix_value ();
+      retval = tmp(0).matrix_value ();
 
-          if (retval.is_empty ())
-            err_user_supplied_eval ("dasrt");
-        }
-      else
+      if (retval.is_empty ())
         err_user_supplied_eval ("dasrt");
     }
 
   return retval;
 }
 
 DEFUN (dasrt, args, nargout,
        "-*- texinfo -*-\n\
diff --git a/libinterp/corefcn/dassl.cc b/libinterp/corefcn/dassl.cc
--- a/libinterp/corefcn/dassl.cc
+++ b/libinterp/corefcn/dassl.cc
@@ -80,33 +80,31 @@ dassl_user_function (const ColumnVector&
           tmp = dassl_fcn->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
           err_user_supplied_eval (e, "dassl");
         }
 
       int tlen = tmp.length ();
-      if (tlen > 0 && tmp(0).is_defined ())
-        {
-          if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
-            {
-              warning ("dassl: ignoring imaginary part returned from user-supplied function");
-              warned_fcn_imaginary = true;
-            }
+      if (tlen == 0 || ! tmp(0).is_defined ())
+        err_user_supplied_eval ("dassl");
 
-          retval = tmp(0).vector_value ();
-
-          if (tlen > 1)
-            ires = tmp(1).int_value ();
+      if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
+        {
+          warning ("dassl: ignoring imaginary part returned from user-supplied function");
+          warned_fcn_imaginary = true;
+        }
 
-          if (retval.is_empty ())
-            err_user_supplied_eval ("dassl");
-        }
-      else
+      retval = tmp(0).vector_value ();
+
+      if (tlen > 1)
+        ires = tmp(1).int_value ();
+
+      if (retval.is_empty ())
         err_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
 
 Matrix
 dassl_user_jacobian (const ColumnVector& x, const ColumnVector& xdot,
@@ -132,30 +130,28 @@ dassl_user_jacobian (const ColumnVector&
           tmp = dassl_jac->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
           err_user_supplied_eval (e, "dassl");
         }
 
       int tlen = tmp.length ();
-      if (tlen > 0 && tmp(0).is_defined ())
+      if (tlen == 0 || ! tmp(0).is_defined ())
+        err_user_supplied_eval ("dassl");
+
+      if (! warned_jac_imaginary && tmp(0).is_complex_type ())
         {
-          if (! warned_jac_imaginary && tmp(0).is_complex_type ())
-            {
-              warning ("dassl: ignoring imaginary part returned from user-supplied jacobian function");
-              warned_jac_imaginary = true;
-            }
+          warning ("dassl: ignoring imaginary part returned from user-supplied jacobian function");
+          warned_jac_imaginary = true;
+        }
 
-          retval = tmp(0).matrix_value ();
+      retval = tmp(0).matrix_value ();
 
-          if (retval.is_empty ())
-            err_user_supplied_eval ("dassl");
-        }
-      else
+      if (retval.is_empty ())
         err_user_supplied_eval ("dassl");
     }
 
   return retval;
 }
 
 DEFUN (dassl, args, nargout,
        "-*- texinfo -*-\n\
diff --git a/libinterp/corefcn/data.cc b/libinterp/corefcn/data.cc
--- a/libinterp/corefcn/data.cc
+++ b/libinterp/corefcn/data.cc
@@ -335,52 +335,50 @@ static octave_value
 do_hypot (const octave_value& x, const octave_value& y)
 {
   octave_value retval;
 
   octave_value arg0 = x;
   octave_value arg1 = y;
   if (! arg0.is_numeric_type ())
     err_wrong_type_arg ("hypot", arg0);
-  else if (! arg1.is_numeric_type ())
+  if (! arg1.is_numeric_type ())
     err_wrong_type_arg ("hypot", arg1);
+
+  if (arg0.is_complex_type ())
+    arg0 = arg0.abs ();
+  if (arg1.is_complex_type ())
+    arg1 = arg1.abs ();
+
+  if (arg0.is_single_type () || arg1.is_single_type ())
+    {
+      if (arg0.is_scalar_type () && arg1.is_scalar_type ())
+        retval = hypotf (arg0.float_value (), arg1.float_value ());
+      else
+        {
+          FloatNDArray a0 = arg0.float_array_value ();
+          FloatNDArray a1 = arg1.float_array_value ();
+          retval = binmap<float> (a0, a1, ::hypotf, "hypot");
+        }
+    }
   else
     {
-      if (arg0.is_complex_type ())
-        arg0 = arg0.abs ();
-      if (arg1.is_complex_type ())
-        arg1 = arg1.abs ();
-
-      if (arg0.is_single_type () || arg1.is_single_type ())
+      if (arg0.is_scalar_type () && arg1.is_scalar_type ())
+        retval = hypot (arg0.scalar_value (), arg1.scalar_value ());
+      else if (arg0.is_sparse_type () || arg1.is_sparse_type ())
         {
-          if (arg0.is_scalar_type () && arg1.is_scalar_type ())
-            retval = hypotf (arg0.float_value (), arg1.float_value ());
-          else
-            {
-              FloatNDArray a0 = arg0.float_array_value ();
-              FloatNDArray a1 = arg1.float_array_value ();
-              retval = binmap<float> (a0, a1, ::hypotf, "hypot");
-            }
+          SparseMatrix m0 = arg0.sparse_matrix_value ();
+          SparseMatrix m1 = arg1.sparse_matrix_value ();
+          retval = binmap<double> (m0, m1, ::hypot, "hypot");
         }
       else
         {
-          if (arg0.is_scalar_type () && arg1.is_scalar_type ())
-            retval = hypot (arg0.scalar_value (), arg1.scalar_value ());
-          else if (arg0.is_sparse_type () || arg1.is_sparse_type ())
-            {
-              SparseMatrix m0 = arg0.sparse_matrix_value ();
-              SparseMatrix m1 = arg1.sparse_matrix_value ();
-              retval = binmap<double> (m0, m1, ::hypot, "hypot");
-            }
-          else
-            {
-              NDArray a0 = arg0.array_value ();
-              NDArray a1 = arg1.array_value ();
-              retval = binmap<double> (a0, a1, ::hypot, "hypot");
-            }
+          NDArray a0 = arg0.array_value ();
+          NDArray a1 = arg1.array_value ();
+          retval = binmap<double> (a0, a1, ::hypot, "hypot");
         }
     }
 
   return retval;
 }
 
 DEFUN (hypot, args, ,
        "-*- texinfo -*-\n\
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -718,24 +718,22 @@ current function.\n\
     error ("dbstatus: only zero or one arguments accepted\n");
 
   octave_value_list fcn_list;
   bp_table::fname_line_map bp_list;
   std::string symbol_name;
 
   if (nargin == 1)
     {
-      if (args(0).is_string ())
-        {
-          symbol_name = args(0).string_value ();
-          fcn_list(0) = symbol_name;
-          bp_list = bp_table::get_breakpoint_list (fcn_list);
-        }
-      else
+      if (! args(0).is_string ())
         err_wrong_type_arg ("dbstatus", args(0));
+
+      symbol_name = args(0).string_value ();
+      fcn_list(0) = symbol_name;
+      bp_list = bp_table::get_breakpoint_list (fcn_list);
     }
   else
     {
       if (Vdebugging)
         {
           octave_user_code *dbg_fcn = get_user_code ();
           if (dbg_fcn)
             {
diff --git a/libinterp/corefcn/load-save.cc b/libinterp/corefcn/load-save.cc
--- a/libinterp/corefcn/load-save.cc
+++ b/libinterp/corefcn/load-save.cc
@@ -760,26 +760,24 @@ Force Octave to assume the file is in Oc
 
 #ifdef HAVE_HDF5
       if (format == LS_HDF5)
         {
           i++;
 
           hdf5_ifstream hdf5_file (fname.c_str ());
 
-          if (hdf5_file.file_id >= 0)
-            {
-              retval = do_load (hdf5_file, orig_fname, format,
-                                flt_fmt, list_only, swap, verbose,
-                                argv, i, argc, nargout);
+          if (hdf5_file.file_id < 0)
+            err_file_open ("load", orig_fname);
 
-              hdf5_file.close ();
-            }
-          else
-            err_file_open ("load", orig_fname);
+          retval = do_load (hdf5_file, orig_fname, format,
+                            flt_fmt, list_only, swap, verbose,
+                            argv, i, argc, nargout);
+
+          hdf5_file.close ();
         }
       else
 #endif
         // don't insert any statements here; the "else" above has to
         // go with the "if" below!!!!!
       if (format != LS_UNKNOWN)
         {
           i++;
@@ -788,45 +786,43 @@ Force Octave to assume the file is in Oc
           // line-endings explicitly.
           std::ios::openmode mode = std::ios::in | std::ios::binary;
 
 #ifdef HAVE_ZLIB
           if (use_zlib)
             {
               gzifstream file (fname.c_str (), mode);
 
-              if (file)
+              if (! file)
+                err_file_open ("load", orig_fname);
+
+              if (format == LS_BINARY)
                 {
-                  if (format == LS_BINARY)
-                    {
-                      if (read_binary_file_header (file, swap, flt_fmt) < 0)
-                        {
-                          if (file) file.close ();
-                          return retval;
-                        }
-                    }
-                  else if (format == LS_MAT5_BINARY
-                           || format == LS_MAT7_BINARY)
+                  if (read_binary_file_header (file, swap, flt_fmt) < 0)
                     {
-                      if (read_mat5_binary_file_header (file, swap, false,
-                                                        orig_fname) < 0)
-                        {
-                          if (file) file.close ();
-                          return retval;
-                        }
+                      if (file) file.close ();
+                      return retval;
                     }
+                }
+              else if (format == LS_MAT5_BINARY
+                       || format == LS_MAT7_BINARY)
+                {
+                  if (read_mat5_binary_file_header (file, swap, false,
+                                                    orig_fname) < 0)
+                    {
+                      if (file) file.close ();
+                      return retval;
+                    }
+                }
 
-                  retval = do_load (file, orig_fname, format,
-                                    flt_fmt, list_only, swap, verbose,
-                                    argv, i, argc, nargout);
+              retval = do_load (file, orig_fname, format,
+                                flt_fmt, list_only, swap, verbose,
+                                argv, i, argc, nargout);
 
-                  file.close ();
-                }
-              else
-                err_file_open ("load", orig_fname);
+              file.close ();
             }
           else
 #endif
             {
               std::ifstream file (fname.c_str (), mode);
 
               if (! file)
                 error ("load: unable to open input file '%s'",
@@ -1661,64 +1657,58 @@ the file @file{data} in Octave's binary 
           if (append)
             error ("save: appending to HDF5 files is not implemented");
 
           bool write_header_info
             = ! (append && H5Fis_hdf5 (fname.c_str ()) > 0);
 
           hdf5_ofstream hdf5_file (fname.c_str (), mode);
 
-          if (hdf5_file.file_id != -1)
-            {
-              save_vars (argv, i, argc, hdf5_file, format,
-                         save_as_floats, write_header_info);
+          if (hdf5_file.file_id == -1)
+            err_file_open ("save", fname);
 
-              hdf5_file.close ();
-            }
-          else
-            err_file_open ("save", fname);
+          save_vars (argv, i, argc, hdf5_file, format,
+                     save_as_floats, write_header_info);
+
+          hdf5_file.close ();
         }
       else
 #endif
         // don't insert any statements here!  The brace below must go
         // with the "else" above!
         {
 #ifdef HAVE_ZLIB
           if (use_zlib)
             {
               gzofstream file (fname.c_str (), mode);
 
-              if (file)
-                {
-                  bool write_header_info = ! file.tellp ();
+              if (! file)
+                err_file_open ("save", fname);
+
+              bool write_header_info = ! file.tellp ();
 
-                  save_vars (argv, i, argc, file, format,
-                             save_as_floats, write_header_info);
+              save_vars (argv, i, argc, file, format,
+                         save_as_floats, write_header_info);
 
-                  file.close ();
-                }
-              else
-                err_file_open ("save", fname);
+              file.close ();
             }
           else
 #endif
             {
               std::ofstream file (fname.c_str (), mode);
 
-              if (file)
-                {
-                  bool write_header_info = ! file.tellp ();
+              if (! file)
+                err_file_open ("save", fname);
+
+              bool write_header_info = ! file.tellp ();
 
-                  save_vars (argv, i, argc, file, format,
-                             save_as_floats, write_header_info);
+              save_vars (argv, i, argc, file, format,
+                         save_as_floats, write_header_info);
 
-                  file.close ();
-                }
-              else
-                err_file_open ("save", fname);
+              file.close ();
             }
         }
     }
 
   return retval;
 }
 
 DEFUN (crash_dumps_octave_core, args, nargout,
diff --git a/libinterp/corefcn/lsode.cc b/libinterp/corefcn/lsode.cc
--- a/libinterp/corefcn/lsode.cc
+++ b/libinterp/corefcn/lsode.cc
@@ -76,30 +76,28 @@ lsode_user_function (const ColumnVector&
         {
           tmp = lsode_fcn->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
           err_user_supplied_eval (e, "lsode");
         }
 
-      if (tmp.length () > 0 && tmp(0).is_defined ())
+      if (tmp.length () == 0 || ! tmp(0).is_defined ())
+        err_user_supplied_eval ("lsode");
+
+      if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
         {
-          if (! warned_fcn_imaginary && tmp(0).is_complex_type ())
-            {
-              warning ("lsode: ignoring imaginary part returned from user-supplied function");
-              warned_fcn_imaginary = true;
-            }
+          warning ("lsode: ignoring imaginary part returned from user-supplied function");
+          warned_fcn_imaginary = true;
+        }
 
-          retval = tmp(0).xvector_value ("lsode: expecting user supplied function to return numeric vector");
+      retval = tmp(0).xvector_value ("lsode: expecting user supplied function to return numeric vector");
 
-          if (retval.is_empty ())
-            err_user_supplied_eval ("lsode");
-        }
-      else
+      if (retval.is_empty ())
         err_user_supplied_eval ("lsode");
     }
 
   return retval;
 }
 
 Matrix
 lsode_user_jacobian (const ColumnVector& x, double t)
@@ -118,30 +116,28 @@ lsode_user_jacobian (const ColumnVector&
         {
           tmp = lsode_jac->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
           err_user_supplied_eval (e, "lsode");
         }
 
-      if (tmp.length () > 0 && tmp(0).is_defined ())
+      if (tmp.length () == 0 || ! tmp(0).is_defined ())
+        err_user_supplied_eval ("lsode");
+
+      if (! warned_jac_imaginary && tmp(0).is_complex_type ())
         {
-          if (! warned_jac_imaginary && tmp(0).is_complex_type ())
-            {
-              warning ("lsode: ignoring imaginary part returned from user-supplied jacobian function");
-              warned_jac_imaginary = true;
-            }
+          warning ("lsode: ignoring imaginary part returned from user-supplied jacobian function");
+          warned_jac_imaginary = true;
+        }
 
-          retval = tmp(0).xmatrix_value ("lsode: expecting user supplied jacobian function to return numeric array");
+      retval = tmp(0).xmatrix_value ("lsode: expecting user supplied jacobian function to return numeric array");
 
-          if (retval.is_empty ())
-            err_user_supplied_eval ("lsode");
-        }
-      else
+      if (retval.is_empty ())
         err_user_supplied_eval ("lsode");
     }
 
   return retval;
 }
 
 DEFUN (lsode, args, nargout,
        "-*- texinfo -*-\n\
diff --git a/libinterp/corefcn/quad.cc b/libinterp/corefcn/quad.cc
--- a/libinterp/corefcn/quad.cc
+++ b/libinterp/corefcn/quad.cc
@@ -73,28 +73,26 @@ quad_user_function (double x)
         {
           tmp = quad_fcn->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
           err_user_supplied_eval (e, "quad");
         }
 
-      if (tmp.length () && tmp(0).is_defined ())
+      if (! tmp.length () || ! tmp(0).is_defined ())
+        err_user_supplied_eval ("quad");
+
+      if (! warned_imaginary && tmp(0).is_complex_type ())
         {
-          if (! warned_imaginary && tmp(0).is_complex_type ())
-            {
-              warning ("quad: ignoring imaginary part returned from user-supplied function");
-              warned_imaginary = true;
-            }
+          warning ("quad: ignoring imaginary part returned from user-supplied function");
+          warned_imaginary = true;
+        }
 
-          retval = tmp(0).xdouble_value ("quad: expecting user supplied function to return numeric value");
-        }
-      else
-        err_user_supplied_eval ("quad");
+      retval = tmp(0).xdouble_value ("quad: expecting user supplied function to return numeric value");
     }
 
   return retval;
 }
 
 float
 quad_float_user_function (float x)
 {
@@ -111,29 +109,26 @@ quad_float_user_function (float x)
         {
           tmp = quad_fcn->do_multi_index_op (1, args);
         }
       catch (octave_execution_exception& e)
         {
           err_user_supplied_eval (e, "quad");
         }
 
-      if (tmp.length () && tmp(0).is_defined ())
+      if (! tmp.length () || ! tmp(0).is_defined ())
+        err_user_supplied_eval ("quad");
+
+      if (! warned_imaginary && tmp(0).is_complex_type ())
         {
-          if (! warned_imaginary && tmp(0).is_complex_type ())
-            {
-              warning ("quad: ignoring imaginary part returned from user-supplied function");
-              warned_imaginary = true;
-            }
+          warning ("quad: ignoring imaginary part returned from user-supplied function");
+          warned_imaginary = true;
+        }
 
-          retval = tmp(0).xfloat_value ("quad: expecting user supplied function to return numeric value");
-
-        }
-      else
-        err_user_supplied_eval ("quad");
+      retval = tmp(0).xfloat_value ("quad: expecting user supplied function to return numeric value");
     }
 
   return retval;
 }
 
 DEFUN (quad, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {} {@var{q} =} quad (@var{f}, @var{a}, @var{b})\n\
diff --git a/libinterp/corefcn/xnorm.cc b/libinterp/corefcn/xnorm.cc
--- a/libinterp/corefcn/xnorm.cc
+++ b/libinterp/corefcn/xnorm.cc
@@ -41,174 +41,166 @@ octave_value xnorm (const octave_value& 
 {
   octave_value retval;
 
   bool isvector = (x.columns () == 1 || x.rows () == 1);
   bool iscomplex = x.is_complex_type ();
   bool issparse = x.is_sparse_type ();
   bool isfloat = x.is_single_type ();
 
-  if (isfloat || x.is_double_type ())
+  if (! isfloat && ! x.is_double_type ())
+    err_wrong_type_arg ("xnorm", x);
+
+  if (x.is_empty ())
+    retval = octave_value (0);
+  else if (isvector)
     {
-      if (x.is_empty ())
-        retval = octave_value (0);
-      else if (isvector)
-        {
-          if (isfloat & iscomplex)
-            retval = xnorm (x.float_complex_column_vector_value (),
-                            p.float_value ());
-          else if (isfloat)
-            retval = xnorm (x.float_column_vector_value (),
-                            p.float_value ());
-          else if (iscomplex)
-            retval = xnorm (x.complex_column_vector_value (),
-                            p.double_value ());
-          else
-            retval = xnorm (x.column_vector_value (),
-                            p.double_value ());
-        }
-      else if (issparse)
-        {
-          if (iscomplex)
-            retval = xnorm (x.sparse_complex_matrix_value (),
-                            p.double_value ());
-          else
-            retval = xnorm (x.sparse_matrix_value (),
-                            p.double_value ());
-        }
+      if (isfloat & iscomplex)
+        retval = xnorm (x.float_complex_column_vector_value (),
+                        p.float_value ());
+      else if (isfloat)
+        retval = xnorm (x.float_column_vector_value (),
+                        p.float_value ());
+      else if (iscomplex)
+        retval = xnorm (x.complex_column_vector_value (),
+                        p.double_value ());
       else
-        {
-          if (isfloat & iscomplex)
-            retval = xnorm (x.float_complex_matrix_value (),
-                            p.float_value ());
-          else if (isfloat)
-            retval = xnorm (x.float_matrix_value (),
-                            p.float_value ());
-          else if (iscomplex)
-            retval = xnorm (x.complex_matrix_value (),
-                            p.double_value ());
-          else
-            retval = xnorm (x.matrix_value (),
-                            p.double_value ());
-        }
+        retval = xnorm (x.column_vector_value (),
+                        p.double_value ());
+    }
+  else if (issparse)
+    {
+      if (iscomplex)
+        retval = xnorm (x.sparse_complex_matrix_value (),
+                        p.double_value ());
+      else
+        retval = xnorm (x.sparse_matrix_value (),
+                        p.double_value ());
     }
   else
-    err_wrong_type_arg ("xnorm", x);
+    {
+      if (isfloat & iscomplex)
+        retval = xnorm (x.float_complex_matrix_value (),
+                        p.float_value ());
+      else if (isfloat)
+        retval = xnorm (x.float_matrix_value (),
+                        p.float_value ());
+      else if (iscomplex)
+        retval = xnorm (x.complex_matrix_value (),
+                        p.double_value ());
+      else
+        retval = xnorm (x.matrix_value (),
+                        p.double_value ());
+    }
 
   return retval;
 }
 
 octave_value xcolnorms (const octave_value& x, const octave_value& p)
 {
   octave_value retval;
 
   bool iscomplex = x.is_complex_type ();
   bool issparse = x.is_sparse_type ();
   bool isfloat = x.is_single_type ();
 
-  if (isfloat || x.is_double_type ())
+  if (! isfloat && ! x.is_double_type ())
+    err_wrong_type_arg ("xcolnorms", x);
+
+  if (issparse)
     {
-      if (issparse)
-        {
-          if (iscomplex)
-            retval = xcolnorms (x.sparse_complex_matrix_value (),
-                                p.double_value ());
-          else
-            retval = xcolnorms (x.sparse_matrix_value (),
-                                p.double_value ());
-        }
+      if (iscomplex)
+        retval = xcolnorms (x.sparse_complex_matrix_value (),
+                            p.double_value ());
       else
-        {
-          if (isfloat & iscomplex)
-            retval = xcolnorms (x.float_complex_matrix_value (),
-                                p.float_value ());
-          else if (isfloat)
-            retval = xcolnorms (x.float_matrix_value (),
-                                p.float_value ());
-          else if (iscomplex)
-            retval = xcolnorms (x.complex_matrix_value (),
-                                p.double_value ());
-          else
-            retval = xcolnorms (x.matrix_value (),
-                                p.double_value ());
-        }
+        retval = xcolnorms (x.sparse_matrix_value (),
+                            p.double_value ());
     }
   else
-    err_wrong_type_arg ("xcolnorms", x);
+    {
+      if (isfloat & iscomplex)
+        retval = xcolnorms (x.float_complex_matrix_value (),
+                            p.float_value ());
+      else if (isfloat)
+        retval = xcolnorms (x.float_matrix_value (),
+                            p.float_value ());
+      else if (iscomplex)
+        retval = xcolnorms (x.complex_matrix_value (),
+                            p.double_value ());
+      else
+        retval = xcolnorms (x.matrix_value (),
+                            p.double_value ());
+    }
 
   return retval;
 }
 
 octave_value xrownorms (const octave_value& x, const octave_value& p)
 {
   octave_value retval;
 
   bool iscomplex = x.is_complex_type ();
   bool issparse = x.is_sparse_type ();
   bool isfloat = x.is_single_type ();
 
-  if (isfloat || x.is_double_type ())
+  if (! isfloat && ! x.is_double_type ())
+    err_wrong_type_arg ("xrownorms", x);
+
+  if (issparse)
     {
-      if (issparse)
-        {
-          if (iscomplex)
-            retval = xrownorms (x.sparse_complex_matrix_value (),
-                                p.double_value ());
-          else
-            retval = xrownorms (x.sparse_matrix_value (),
-                                p.double_value ());
-        }
+      if (iscomplex)
+        retval = xrownorms (x.sparse_complex_matrix_value (),
+                            p.double_value ());
       else
-        {
-          if (isfloat & iscomplex)
-            retval = xrownorms (x.float_complex_matrix_value (),
-                                p.float_value ());
-          else if (isfloat)
-            retval = xrownorms (x.float_matrix_value (),
-                                p.float_value ());
-          else if (iscomplex)
-            retval = xrownorms (x.complex_matrix_value (),
-                                p.double_value ());
-          else
-            retval = xrownorms (x.matrix_value (),
-                                p.double_value ());
-        }
+        retval = xrownorms (x.sparse_matrix_value (),
+                            p.double_value ());
     }
   else
-    err_wrong_type_arg ("xrownorms", x);
+    {
+      if (isfloat & iscomplex)
+        retval = xrownorms (x.float_complex_matrix_value (),
+                            p.float_value ());
+      else if (isfloat)
+        retval = xrownorms (x.float_matrix_value (),
+                            p.float_value ());
+      else if (iscomplex)
+        retval = xrownorms (x.complex_matrix_value (),
+                            p.double_value ());
+      else
+        retval = xrownorms (x.matrix_value (),
+                            p.double_value ());
+    }
 
   return retval;
 }
 
 octave_value xfrobnorm (const octave_value& x)
 {
   octave_value retval;
 
   bool iscomplex = x.is_complex_type ();
   bool issparse = x.is_sparse_type ();
   bool isfloat = x.is_single_type ();
 
-  if (isfloat || x.is_double_type ())
+  if (! isfloat && ! x.is_double_type ())
+    err_wrong_type_arg ("xfrobnorm", x);
+
+  if (issparse)
     {
-      if (issparse)
-        {
-          if (iscomplex)
-            retval = xfrobnorm (x.sparse_complex_matrix_value ());
-          else
-            retval = xfrobnorm (x.sparse_matrix_value ());
-        }
+      if (iscomplex)
+        retval = xfrobnorm (x.sparse_complex_matrix_value ());
       else
-        {
-          if (isfloat & iscomplex)
-            retval = xfrobnorm (x.float_complex_matrix_value ());
-          else if (isfloat)
-            retval = xfrobnorm (x.float_matrix_value ());
-          else if (iscomplex)
-            retval = xfrobnorm (x.complex_matrix_value ());
-          else
-            retval = xfrobnorm (x.matrix_value ());
-        }
+        retval = xfrobnorm (x.sparse_matrix_value ());
     }
   else
-    err_wrong_type_arg ("xfrobnorm", x);
+    {
+      if (isfloat & iscomplex)
+        retval = xfrobnorm (x.float_complex_matrix_value ());
+      else if (isfloat)
+        retval = xfrobnorm (x.float_matrix_value ());
+      else if (iscomplex)
+        retval = xfrobnorm (x.complex_matrix_value ());
+      else
+        retval = xfrobnorm (x.matrix_value ());
+    }
 
   return retval;
 }
diff --git a/libinterp/corefcn/xpow.cc b/libinterp/corefcn/xpow.cc
--- a/libinterp/corefcn/xpow.cc
+++ b/libinterp/corefcn/xpow.cc
@@ -1226,28 +1226,26 @@ elem_xpow (const NDArray& a, const NDArr
 {
   octave_value retval;
 
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
-        {
-          //Potentially complex results
-          NDArray xa = octave_value_extract<NDArray> (a);
-          NDArray xb = octave_value_extract<NDArray> (b);
-          if (! xb.all_integers () && xa.any_element_is_negative ())
-            return octave_value (bsxfun_pow (ComplexNDArray (xa), xb));
-          else
-            return octave_value (bsxfun_pow (xa, xb));
-        }
+      if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))
+        err_nonconformant ("operator .^", a_dims, b_dims);
+
+      //Potentially complex results
+      NDArray xa = octave_value_extract<NDArray> (a);
+      NDArray xb = octave_value_extract<NDArray> (b);
+      if (! xb.all_integers () && xa.any_element_is_negative ())
+        return octave_value (bsxfun_pow (ComplexNDArray (xa), xb));
       else
-        err_nonconformant ("operator .^", a_dims, b_dims);
+        return octave_value (bsxfun_pow (xa, xb));
     }
 
   int len = a.numel ();
 
   bool convert_to_complex = false;
 
   for (octave_idx_type i = 0; i < len; i++)
     {
@@ -1311,22 +1309,20 @@ elem_xpow (const NDArray& a, const Compl
 octave_value
 elem_xpow (const NDArray& a, const ComplexNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
-        {
-          return bsxfun_pow (a, b);
-        }
-      else
+      if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))
         err_nonconformant ("operator .^", a_dims, b_dims);
+
+      return bsxfun_pow (a, b);
     }
 
   ComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
@@ -1407,22 +1403,20 @@ elem_xpow (const ComplexNDArray& a, doub
 octave_value
 elem_xpow (const ComplexNDArray& a, const NDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
-        {
-          return bsxfun_pow (a, b);
-        }
-      else
+      if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))
         err_nonconformant ("operator .^", a_dims, b_dims);
+
+      return bsxfun_pow (a, b);
     }
 
   ComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       double btmp = b(i);
@@ -1454,22 +1448,20 @@ elem_xpow (const ComplexNDArray& a, cons
 octave_value
 elem_xpow (const ComplexNDArray& a, const ComplexNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
-        {
-          return bsxfun_pow (a, b);
-        }
-      else
+      if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))
         err_nonconformant ("operator .^", a_dims, b_dims);
+
+      return bsxfun_pow (a, b);
     }
 
   ComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
@@ -2548,28 +2540,26 @@ elem_xpow (const FloatNDArray& a, const 
 {
   octave_value retval;
 
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
-        {
-          //Potentially complex results
-          FloatNDArray xa = octave_value_extract<FloatNDArray> (a);
-          FloatNDArray xb = octave_value_extract<FloatNDArray> (b);
-          if (! xb.all_integers () && xa.any_element_is_negative ())
-            return octave_value (bsxfun_pow (FloatComplexNDArray (xa), xb));
-          else
-            return octave_value (bsxfun_pow (xa, xb));
-        }
+      if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))
+        err_nonconformant ("operator .^", a_dims, b_dims);
+
+      //Potentially complex results
+      FloatNDArray xa = octave_value_extract<FloatNDArray> (a);
+      FloatNDArray xb = octave_value_extract<FloatNDArray> (b);
+      if (! xb.all_integers () && xa.any_element_is_negative ())
+        return octave_value (bsxfun_pow (FloatComplexNDArray (xa), xb));
       else
-        err_nonconformant ("operator .^", a_dims, b_dims);
+        return octave_value (bsxfun_pow (xa, xb));
     }
 
   int len = a.numel ();
 
   bool convert_to_complex = false;
 
   for (octave_idx_type i = 0; i < len; i++)
     {
@@ -2633,22 +2623,20 @@ elem_xpow (const FloatNDArray& a, const 
 octave_value
 elem_xpow (const FloatNDArray& a, const FloatComplexNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
-        {
-          return bsxfun_pow (a, b);
-        }
-      else
+      if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))
         err_nonconformant ("operator .^", a_dims, b_dims);
+
+      return bsxfun_pow (a, b);
     }
 
   FloatComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
@@ -2729,22 +2717,20 @@ elem_xpow (const FloatComplexNDArray& a,
 octave_value
 elem_xpow (const FloatComplexNDArray& a, const FloatNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
-        {
-          return bsxfun_pow (a, b);
-        }
-      else
+      if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))
         err_nonconformant ("operator .^", a_dims, b_dims);
+
+      return bsxfun_pow (a, b);
     }
 
   FloatComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       float btmp = b(i);
@@ -2776,22 +2762,20 @@ elem_xpow (const FloatComplexNDArray& a,
 octave_value
 elem_xpow (const FloatComplexNDArray& a, const FloatComplexNDArray& b)
 {
   dim_vector a_dims = a.dims ();
   dim_vector b_dims = b.dims ();
 
   if (a_dims != b_dims)
     {
-      if (is_valid_bsxfun ("operator .^", a_dims, b_dims))
-        {
-          return bsxfun_pow (a, b);
-        }
-      else
+      if (! is_valid_bsxfun ("operator .^", a_dims, b_dims))
         err_nonconformant ("operator .^", a_dims, b_dims);
+
+      return bsxfun_pow (a, b);
     }
 
   FloatComplexNDArray result (a_dims);
 
   for (octave_idx_type i = 0; i < a.numel (); i++)
     {
       octave_quit ();
       result(i) = std::pow (a(i), b(i));
diff --git a/libinterp/octave-value/ov-base-diag.cc b/libinterp/octave-value/ov-base-diag.cc
--- a/libinterp/octave-value/ov-base-diag.cc
+++ b/libinterp/octave-value/ov-base-diag.cc
@@ -295,25 +295,23 @@ octave_base_diag<DMT, MT>::double_value 
 {
   double retval = lo_ieee_nan_value ();
   typedef typename DMT::element_type el_type;
 
   if (helper_iscomplex (el_type ()) && ! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex matrix", "real scalar");
 
-  if (numel () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                type_name (), "real scalar");
+  if (numel () == 0)
+    err_invalid_conversion (type_name (), "real scalar");
 
-      retval = helper_getreal (el_type (matrix (0, 0)));
-    }
-  else
-    err_invalid_conversion (type_name (), "real scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            type_name (), "real scalar");
+
+  retval = helper_getreal (el_type (matrix (0, 0)));
 
   return retval;
 }
 
 template <class DMT, class MT>
 float
 octave_base_diag<DMT, MT>::float_value (bool force_conversion) const
 {
@@ -340,46 +338,42 @@ octave_base_diag<DMT, MT>::float_value (
 template <class DMT, class MT>
 Complex
 octave_base_diag<DMT, MT>::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                type_name (), "complex scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion (type_name (), "complex scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion (type_name (), "complex scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            type_name (), "complex scalar");
+
+  retval = matrix (0, 0);
 
   return retval;
 }
 
 template <class DMT, class MT>
 FloatComplex
 octave_base_diag<DMT, MT>::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                type_name (), "complex scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion (type_name (), "complex scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion (type_name (), "complex scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            type_name (), "complex scalar");
+
+  retval = matrix (0, 0);
 
   return retval;
 }
 
 template <class DMT, class MT>
 Matrix
 octave_base_diag<DMT, MT>::matrix_value (bool) const
 {
diff --git a/libinterp/octave-value/ov-base-mat.cc b/libinterp/octave-value/ov-base-mat.cc
--- a/libinterp/octave-value/ov-base-mat.cc
+++ b/libinterp/octave-value/ov-base-mat.cc
@@ -410,22 +410,20 @@ octave_base_matrix<MT>::is_true (void) c
   int nel = dv.numel ();
 
   if (nel > 0)
     {
       MT t1 (matrix.reshape (dim_vector (nel, 1)));
 
       if (t1.any_element_is_nan ())
         err_nan_to_logical_conversion ();
-      else
-        {
-          boolNDArray t2 = t1.all ();
 
-          retval = t2(0);
-        }
+      boolNDArray t2 = t1.all ();
+
+      retval = t2(0);
     }
 
   return retval;
 }
 
 template <class MT>
 bool
 octave_base_matrix<MT>::print_as_scalar (void) const
diff --git a/libinterp/octave-value/ov-base-scalar.cc b/libinterp/octave-value/ov-base-scalar.cc
--- a/libinterp/octave-value/ov-base-scalar.cc
+++ b/libinterp/octave-value/ov-base-scalar.cc
@@ -126,24 +126,20 @@ octave_base_scalar<ST>::diag (octave_idx
 {
   return Array<ST> (dim_vector (1, 1), scalar).diag (m, n);
 }
 
 template <class ST>
 bool
 octave_base_scalar<ST>::is_true (void) const
 {
-  bool retval = false;
-
   if (xisnan (scalar))
     err_nan_to_logical_conversion ();
-  else
-    retval = (scalar != ST ());
 
-  return retval;
+  return (scalar != ST ());
 }
 
 template <class ST>
 void
 octave_base_scalar<ST>::print (std::ostream& os, bool pr_as_read_syntax)
 {
   print_raw (os, pr_as_read_syntax);
   newline (os);
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -1358,34 +1358,29 @@ octave_base_value::numeric_assign (const
       int t_result
         = octave_value_typeinfo::lookup_pref_assign_conv (t_lhs, t_rhs);
 
       if (t_result >= 0)
         {
           octave_base_value::type_conv_fcn cf
             = octave_value_typeinfo::lookup_widening_op (t_lhs, t_result);
 
-          if (cf)
-            {
-              octave_base_value *tmp = cf (*this);
+          if (! cf)
+            err_indexed_assignment (type_name (), rhs.type_name ());
 
-              if (tmp)
-                {
-                  octave_value val (tmp);
+          octave_base_value *tmp = cf (*this);
 
-                  retval = val.subsasgn (type, idx, rhs);
+          if (! tmp)
+            err_assign_conversion_failed (type_name (), rhs.type_name ());
 
-                  done = true;
-                }
-              else
-                err_assign_conversion_failed (type_name (),
-                                              rhs.type_name ());
-            }
-          else
-            err_indexed_assignment (type_name (), rhs.type_name ());
+          octave_value val (tmp);
+
+          retval = val.subsasgn (type, idx, rhs);
+
+          done = true;
         }
 
       if (! done)
         {
           octave_value tmp_rhs;
 
           octave_base_value::type_conv_info cf_rhs
             = rhs.numeric_conversion_function ();
@@ -1407,49 +1402,45 @@ octave_base_value::numeric_assign (const
                        || octave_value_typeinfo::lookup_pref_assign_conv (cf_this.type_id (),
                                                                           t_rhs) >= 0))
             cf_rhs = 0;
 
           if (cf_rhs)
             {
               octave_base_value *tmp = cf_rhs (rhs.get_rep ());
 
-              if (tmp)
-                tmp_rhs = octave_value (tmp);
-              else
-                err_assign_conversion_failed (type_name (),
-                                              rhs.type_name ());
+              if (! tmp)
+                err_assign_conversion_failed (type_name (), rhs.type_name ());
+
+              tmp_rhs = octave_value (tmp);
             }
           else
             tmp_rhs = rhs;
 
           count++;
           octave_value tmp_lhs = octave_value (this);
 
           if (cf_this)
             {
               octave_base_value *tmp = cf_this (*this);
 
-              if (tmp)
-                tmp_lhs = octave_value (tmp);
-              else
-                err_assign_conversion_failed (type_name (),
-                                              rhs.type_name ());
+              if (! tmp)
+                err_assign_conversion_failed (type_name (), rhs.type_name ());
+
+              tmp_lhs = octave_value (tmp);
             }
 
-          if (cf_this || cf_rhs)
-            {
-              retval = tmp_lhs.subsasgn (type, idx, tmp_rhs);
-
-              done = true;
-            }
-          else
+          if (! cf_this && ! cf_rhs)
             err_no_conversion (octave_value::assign_op_as_string
                                (octave_value::op_asn_eq),
                                type_name (), rhs.type_name ());
+
+          retval = tmp_lhs.subsasgn (type, idx, tmp_rhs);
+
+          done = true;
         }
     }
 
   // The assignment may have converted to a type that is wider than necessary.
 
   retval.maybe_mutate ();
 
   return retval;
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -91,83 +91,75 @@ octave_bool_matrix::try_narrowing_conver
   return retval;
 }
 
 double
 octave_bool_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "bool matrix", "real scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("bool matrix", "real scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("bool matrix", "real scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "bool matrix", "real scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 float
 octave_bool_matrix::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "bool matrix", "real scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("bool matrix", "real scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("bool matrix", "real scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "bool matrix", "real scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 Complex
 octave_bool_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "bool matrix", "complex scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("bool matrix", "complex scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("bool matrix", "complex scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "bool matrix", "complex scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 FloatComplex
 octave_bool_matrix::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "bool matrix", "complex scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("bool matrix", "complex scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("bool matrix", "complex scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "bool matrix", "complex scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 octave_value
 octave_bool_matrix::convert_to_str_internal (bool pad, bool force,
                                              char type) const
 {
diff --git a/libinterp/octave-value/ov-bool-sparse.cc b/libinterp/octave-value/ov-bool-sparse.cc
--- a/libinterp/octave-value/ov-bool-sparse.cc
+++ b/libinterp/octave-value/ov-bool-sparse.cc
@@ -97,47 +97,43 @@ octave_sparse_bool_matrix::try_narrowing
   return retval;
 }
 
 double
 octave_sparse_bool_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
-  if (numel () > 0)
-    {
-      if (numel () > 1)
-        warn_implicit_conversion ("Octave:array-to-scalar",
-                                  "bool sparse matrix", "real scalar");
+  if (numel () == 0)
+    err_invalid_conversion ("bool sparse matrix", "real scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("bool sparse matrix", "real scalar");
+  if (numel () > 1)
+    warn_implicit_conversion ("Octave:array-to-scalar",
+                              "bool sparse matrix", "real scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 Complex
 octave_sparse_bool_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  if (rows () > 0 && columns () > 0)
-    {
-      if (numel () > 1)
-        warn_implicit_conversion ("Octave:array-to-scalar",
-                                  "bool sparse matrix", "complex scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("bool sparse matrix", "complex scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("bool sparse matrix", "complex scalar");
+  if (numel () > 1)
+    warn_implicit_conversion ("Octave:array-to-scalar",
+                              "bool sparse matrix", "complex scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 octave_value
 octave_sparse_bool_matrix::convert_to_str_internal (bool pad, bool force,
                                                     char type) const
 {
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -282,34 +282,32 @@ octave_cell::subsasgn (const std::string
             Cell tmpc = matrix.index (idx.front (), true);
 
             std::list<octave_value_list> next_idx (idx);
 
             next_idx.erase (next_idx.begin ());
 
             std::string next_type = type.substr (1);
 
-            if (tmpc.numel () == 1)
-              {
-                octave_value tmp = tmpc(0);
-                tmpc = Cell ();
+            if (tmpc.numel () != 1)
+              err_indexed_cs_list ();
 
-                if (! tmp.is_defined () || tmp.is_zero_by_zero ())
-                  {
-                    tmp = octave_value::empty_conv (type.substr (1), rhs);
-                    tmp.make_unique (); // probably a no-op.
-                  }
-                else
-                  // optimization: ignore copy still stored inside array.
-                  tmp.make_unique (1);
+            octave_value tmp = tmpc(0);
+            tmpc = Cell ();
 
-                t_rhs = tmp.subsasgn (next_type, next_idx, rhs);
+            if (! tmp.is_defined () || tmp.is_zero_by_zero ())
+              {
+                tmp = octave_value::empty_conv (type.substr (1), rhs);
+                tmp.make_unique (); // probably a no-op.
               }
             else
-              err_indexed_cs_list ();
+              // optimization: ignore copy still stored inside array.
+              tmp.make_unique (1);
+
+            t_rhs = tmp.subsasgn (next_type, next_idx, rhs);
           }
           break;
 
         case '.':
           {
             if (! is_empty ())
               {
                 std::string nm = type_name ();
diff --git a/libinterp/octave-value/ov-ch-mat.cc b/libinterp/octave-value/ov-ch-mat.cc
--- a/libinterp/octave-value/ov-ch-mat.cc
+++ b/libinterp/octave-value/ov-ch-mat.cc
@@ -51,119 +51,107 @@ octave_char_matrix::index_vector (bool /
     return idx_vector (array_value (true));
 }
 
 double
 octave_char_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "character matrix", "real scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("character matrix", "real scalar");
 
-      retval = static_cast<unsigned char> (matrix (0, 0));
-    }
-  else
-    err_invalid_conversion ("character matrix", "real scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "character matrix", "real scalar");
+
+  retval = static_cast<unsigned char> (matrix(0, 0));
 
   return retval;
 }
 
 float
 octave_char_matrix::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "character matrix", "real scalar");
+  if (rows () == 0 && columns () == 0)
+    err_invalid_conversion ("character matrix", "real scalar");
 
-      retval = static_cast<unsigned char> (matrix (0, 0));
-    }
-  else
-    err_invalid_conversion ("character matrix", "real scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "character matrix", "real scalar");
+
+  retval = static_cast<unsigned char> (matrix(0, 0));
 
   return retval;
 }
 
 octave_int64
 octave_char_matrix::int64_scalar_value () const
 {
   octave_int64 retval = 0;
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "character matrix", "int64 scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("character matrix", "int64 scalar");
 
-      retval = octave_int64 (matrix (0, 0));
-    }
-  else
-    err_invalid_conversion ("character matrix", "int64 scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "character matrix", "int64 scalar");
+
+  retval = octave_int64 (matrix(0, 0));
 
   return retval;
 }
 
 octave_uint64
 octave_char_matrix::uint64_scalar_value () const
 {
   octave_uint64 retval = 0;
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "character matrix", "uint64 scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("character matrix", "uint64 scalar");
 
-      retval = octave_uint64 (matrix (0, 0));
-    }
-  else
-    err_invalid_conversion ("character matrix", "uint64 scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "character matrix", "uint64 scalar");
+
+  retval = octave_uint64 (matrix(0, 0));
 
   return retval;
 }
 
 Complex
 octave_char_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "character matrix", "complex scalar");
+  if (rows () == 0 && columns () == 0)
+    err_invalid_conversion ("character matrix", "complex scalar");
 
-      retval = static_cast<unsigned char> (matrix (0, 0));
-    }
-  else
-    err_invalid_conversion ("character matrix", "complex scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "character matrix", "complex scalar");
+
+  retval = static_cast<unsigned char> (matrix(0, 0));
 
   return retval;
 }
 
 FloatComplex
 octave_char_matrix::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "character matrix", "complex scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("character matrix", "complex scalar");
 
-      retval = static_cast<unsigned char> (matrix (0, 0));
-    }
-  else
-    err_invalid_conversion ("character matrix", "complex scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "character matrix", "complex scalar");
+
+  retval = static_cast<unsigned char> (matrix(0, 0));
 
   return retval;
 }
 
 void
 octave_char_matrix::print_raw (std::ostream& os,
                                bool pr_as_read_syntax) const
 {
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -476,25 +476,23 @@ octave_class::subsref (const std::string
   return retval;
 }
 
 octave_value
 octave_class::numeric_conv (const Cell& val, const std::string& type)
 {
   octave_value retval;
 
-  if (val.numel () == 1)
-    {
-      retval = val(0);
+  if (val.numel () != 1)
+    err_invalid_index_for_assignment ();
 
-      if (type.length () > 0 && type[0] == '.' && ! retval.is_map ())
-        retval = octave_map ();
-    }
-  else
-    err_invalid_index_for_assignment ();
+  retval = val(0);
+
+  if (type.length () > 0 && type[0] == '.' && ! retval.is_map ())
+    retval = octave_map ();
 
   return retval;
 }
 
 octave_value
 octave_class::subsasgn (const std::string& type,
                         const std::list<octave_value_list>& idx,
                         const octave_value& rhs)
@@ -678,33 +676,31 @@ octave_class::subsasgn_common (const oct
             octave_map::iterator pkey = map.seek (key);
             if (pkey != map.end ())
               {
                 map.contents (pkey).make_unique ();
                 tmpc = map.contents (pkey);
               }
 
             // FIXME: better code reuse?
-            if (tmpc.numel () == 1)
-              {
-                octave_value& tmp = tmpc(0);
+            if (tmpc.numel () != 1)
+              err_indexed_cs_list ();
+
+            octave_value& tmp = tmpc(0);
 
-                if (! tmp.is_defined () || tmp.is_zero_by_zero ())
-                  {
-                    tmp = octave_value::empty_conv (next_type, rhs);
-                    tmp.make_unique (); // probably a no-op.
-                  }
-                else
-                  // optimization: ignore copy still stored inside our map.
-                  tmp.make_unique (1);
-
-                t_rhs = tmp.subsasgn (next_type, next_idx, rhs);
+            if (! tmp.is_defined () || tmp.is_zero_by_zero ())
+              {
+                tmp = octave_value::empty_conv (next_type, rhs);
+                tmp.make_unique (); // probably a no-op.
               }
             else
-              err_indexed_cs_list ();
+              // optimization: ignore copy still stored inside our map.
+              tmp.make_unique (1);
+
+            t_rhs = tmp.subsasgn (next_type, next_idx, rhs);
           }
           break;
 
         case '{':
           err_invalid_index_type (type_name (), type[0]);
           break;
 
         default:
diff --git a/libinterp/octave-value/ov-cx-mat.cc b/libinterp/octave-value/ov-cx-mat.cc
--- a/libinterp/octave-value/ov-cx-mat.cc
+++ b/libinterp/octave-value/ov-cx-mat.cc
@@ -103,47 +103,43 @@ double
 octave_complex_matrix::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                                "complex matrix", "real scalar");
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                 "complex matrix", "real scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("complex matrix", "real scalar");
 
-      retval = std::real (matrix (0, 0));
-    }
-  else
-    err_invalid_conversion ("complex matrix", "real scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                             "complex matrix", "real scalar");
+
+  retval = std::real (matrix(0, 0));
 
   return retval;
 }
 
 float
 octave_complex_matrix::float_value (bool force_conversion) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                                "complex matrix", "real scalar");
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                 "complex matrix", "real scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("complex matrix", "real scalar");
 
-      retval = std::real (matrix (0, 0));
-    }
-  else
-    err_invalid_conversion ("complex matrix", "real scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                             "complex matrix", "real scalar");
+
+  retval = std::real (matrix(0, 0));
 
   return retval;
 }
 
 NDArray
 octave_complex_matrix::array_value (bool force_conversion) const
 {
   NDArray retval;
@@ -187,45 +183,41 @@ octave_complex_matrix::float_matrix_valu
 
 Complex
 octave_complex_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                 "complex matrix", "complex scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("complex matrix", "complex scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("complex matrix", "complex scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                             "complex matrix", "complex scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 FloatComplex
 octave_complex_matrix::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                 "complex matrix", "complex scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("complex matrix", "complex scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("complex matrix", "complex scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                             "complex matrix", "complex scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 ComplexMatrix
 octave_complex_matrix::complex_matrix_value (bool) const
 {
   return ComplexMatrix (matrix);
diff --git a/libinterp/octave-value/ov-cx-sparse.cc b/libinterp/octave-value/ov-cx-sparse.cc
--- a/libinterp/octave-value/ov-cx-sparse.cc
+++ b/libinterp/octave-value/ov-cx-sparse.cc
@@ -108,26 +108,24 @@ octave_sparse_complex_matrix::double_val
 {
   double retval = lo_ieee_nan_value ();
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex sparse matrix", "real scalar");
 
   // FIXME: maybe this should be a function, valid_as_scalar()
-  if (numel () > 0)
-    {
-      if (numel () > 1)
-        warn_implicit_conversion ("Octave:array-to-scalar",
-                                  "complex sparse matrix", "real scalar");
+  if (numel () == 0)
+    err_invalid_conversion ("complex sparse matrix", "real scalar");
 
-      retval = std::real (matrix (0, 0));
-    }
-  else
-    err_invalid_conversion ("complex sparse matrix", "real scalar");
+  if (numel () > 1)
+    warn_implicit_conversion ("Octave:array-to-scalar",
+                              "complex sparse matrix", "real scalar");
+
+  retval = std::real (matrix(0, 0));
 
   return retval;
 }
 
 Matrix
 octave_sparse_complex_matrix::matrix_value (bool force_conversion) const
 {
   Matrix retval;
@@ -144,26 +142,24 @@ octave_sparse_complex_matrix::matrix_val
 Complex
 octave_sparse_complex_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   // FIXME: maybe this should be a function, valid_as_scalar()
-  if (numel () > 0)
-    {
-      if (numel () > 1)
-        warn_implicit_conversion ("Octave:array-to-scalar",
-                                  "complex sparse matrix", "real scalar");
+  if (numel () == 0)
+    err_invalid_conversion ("complex sparse matrix", "real scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("complex sparse matrix", "real scalar");
+  if (numel () > 1)
+    warn_implicit_conversion ("Octave:array-to-scalar",
+                              "complex sparse matrix", "real scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 ComplexMatrix
 octave_sparse_complex_matrix::complex_matrix_value (bool) const
 {
   return matrix.matrix_value ();
diff --git a/libinterp/octave-value/ov-float.cc b/libinterp/octave-value/ov-float.cc
--- a/libinterp/octave-value/ov-float.cc
+++ b/libinterp/octave-value/ov-float.cc
@@ -107,31 +107,29 @@ octave_float_scalar::diag (octave_idx_ty
 
 octave_value
 octave_float_scalar::convert_to_str_internal (bool, bool, char type) const
 {
   octave_value retval;
 
   if (xisnan (scalar))
     err_nan_to_character_conversion ();
-  else
-    {
-      int ival = NINT (scalar);
+
+  int ival = NINT (scalar);
 
-      if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
-        {
-          // FIXME: is there something better we could do?
+  if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
+    {
+      // FIXME: is there something better we could do?
 
-          ival = 0;
+      ival = 0;
 
-          ::warning ("range error for conversion to character value");
-        }
+      ::warning ("range error for conversion to character value");
+    }
 
-      retval = octave_value (std::string (1, static_cast<char> (ival)), type);
-    }
+  retval = octave_value (std::string (1, static_cast<char> (ival)), type);
 
   return retval;
 }
 
 bool
 octave_float_scalar::save_ascii (std::ostream& os)
 {
   float d = float_value ();
diff --git a/libinterp/octave-value/ov-flt-cx-mat.cc b/libinterp/octave-value/ov-flt-cx-mat.cc
--- a/libinterp/octave-value/ov-flt-cx-mat.cc
+++ b/libinterp/octave-value/ov-flt-cx-mat.cc
@@ -91,47 +91,43 @@ double
 octave_float_complex_matrix::double_value (bool force_conversion) const
 {
   double retval = lo_ieee_nan_value ();
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex matrix", "real scalar");
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "complex matrix", "real scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("complex matrix", "real scalar");
 
-      retval = std::real (matrix (0, 0));
-    }
-  else
-    err_invalid_conversion ("complex matrix", "real scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "complex matrix", "real scalar");
+
+  retval = std::real (matrix(0, 0));
 
   return retval;
 }
 
 float
 octave_float_complex_matrix::float_value (bool force_conversion) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   if (! force_conversion)
     warn_implicit_conversion ("Octave:imag-to-real",
                               "complex matrix", "real scalar");
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "complex matrix", "real scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("complex matrix", "real scalar");
 
-      retval = std::real (matrix (0, 0));
-    }
-  else
-    err_invalid_conversion ("complex matrix", "real scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "complex matrix", "real scalar");
+
+  retval = std::real (matrix(0, 0));
 
   return retval;
 }
 
 Matrix
 octave_float_complex_matrix::matrix_value (bool force_conversion) const
 {
   Matrix retval;
@@ -161,45 +157,41 @@ octave_float_complex_matrix::float_matri
 
 Complex
 octave_float_complex_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "complex matrix", "complex scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("complex matrix", "complex scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("complex matrix", "complex scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "complex matrix", "complex scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 FloatComplex
 octave_float_complex_matrix::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "complex matrix", "complex scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("complex matrix", "complex scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("complex matrix", "complex scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "complex matrix", "complex scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 ComplexMatrix
 octave_float_complex_matrix::complex_matrix_value (bool) const
 {
   return FloatComplexMatrix (matrix);
diff --git a/libinterp/octave-value/ov-flt-re-mat.cc b/libinterp/octave-value/ov-flt-re-mat.cc
--- a/libinterp/octave-value/ov-flt-re-mat.cc
+++ b/libinterp/octave-value/ov-flt-re-mat.cc
@@ -86,43 +86,39 @@ octave_float_matrix::try_narrowing_conve
   return retval;
 }
 
 double
 octave_float_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
-  if (numel () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "real matrix", "real scalar");
+  if (numel () == 0)
+    err_invalid_conversion ("real matrix", "real scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("real matrix", "real scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "real matrix", "real scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 float
 octave_float_matrix::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
 
-  if (numel () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "real matrix", "real scalar");
+  if (numel () == 0)
+    err_invalid_conversion ("real matrix", "real scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("real matrix", "real scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "real matrix", "real scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 // FIXME
 
 Matrix
 octave_float_matrix::matrix_value (bool) const
@@ -138,45 +134,41 @@ octave_float_matrix::float_matrix_value 
 
 Complex
 octave_float_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "real matrix", "complex scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("real matrix", "complex scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("real matrix", "complex scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "real matrix", "complex scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 FloatComplex
 octave_float_matrix::float_complex_value (bool) const
 {
   double tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "real matrix", "complex scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("real matrix", "complex scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("real matrix", "complex scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "real matrix", "complex scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 // FIXME
 
 ComplexMatrix
 octave_float_matrix::complex_matrix_value (bool) const
@@ -282,39 +274,37 @@ octave_float_matrix::convert_to_str_inte
   charNDArray chm (dv);
 
   bool warned = false;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       octave_quit ();
 
-      float d = matrix (i);
+      float d = matrix(i);
 
       if (xisnan (d))
         err_nan_to_character_conversion ();
-      else
-        {
-          int ival = NINT (d);
+
+      int ival = NINT (d);
 
-          if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
-            {
-              // FIXME: is there something better we could do?
+      if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
+        {
+          // FIXME: is there something better we could do?
 
-              ival = 0;
+          ival = 0;
 
-              if (! warned)
-                {
-                  ::warning ("range error for conversion to character value");
-                  warned = true;
-                }
+          if (! warned)
+            {
+              ::warning ("range error for conversion to character value");
+              warned = true;
             }
+        }
 
-          chm (i) = static_cast<char> (ival);
-        }
+      chm(i) = static_cast<char> (ival);
     }
 
   retval = octave_value (chm, type);
 
   return retval;
 }
 
 bool
diff --git a/libinterp/octave-value/ov-intx.h b/libinterp/octave-value/ov-intx.h
--- a/libinterp/octave-value/ov-intx.h
+++ b/libinterp/octave-value/ov-intx.h
@@ -97,47 +97,41 @@ public:
   uint64NDArray
   uint64_array_value (void) const { return uint64NDArray (matrix); }
 
   double
   double_value (bool = false) const
   {
     double retval = lo_ieee_nan_value ();
 
-    if (numel () > 0)
-      {
-        warn_implicit_conversion ("Octave:array-to-scalar",
-                                  type_name (), "real scalar");
-
-        retval = matrix(0).double_value ();
-      }
-    else
+    if (numel () == 0)
       err_invalid_conversion (type_name (), "real scalar");
 
+    warn_implicit_conversion ("Octave:array-to-scalar",
+                              type_name (), "real scalar");
+
+    retval = matrix(0).double_value ();
+
     return retval;
-
   }
 
   float
   float_value (bool = false) const
   {
     float retval = lo_ieee_float_nan_value ();
 
-    if (numel () > 0)
-      {
-        warn_implicit_conversion ("Octave:array-to-scalar",
-                                  type_name (), "real scalar");
-
-        retval = matrix(0).float_value ();
-      }
-    else
+    if (numel () == 0)
       err_invalid_conversion (type_name (), "real scalar");
 
+    warn_implicit_conversion ("Octave:array-to-scalar",
+                              type_name (), "real scalar");
+
+    retval = matrix(0).float_value ();
+
     return retval;
-
   }
 
   double scalar_value (bool = false) const { return double_value (); }
 
   float float_scalar_value (bool = false) const { return float_value (); }
 
   Matrix
   matrix_value (bool = false) const
diff --git a/libinterp/octave-value/ov-perm.cc b/libinterp/octave-value/ov-perm.cc
--- a/libinterp/octave-value/ov-perm.cc
+++ b/libinterp/octave-value/ov-perm.cc
@@ -137,83 +137,75 @@ octave_perm_matrix::is_true (void) const
   return to_dense ().is_true ();
 }
 
 double
 octave_perm_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
-  if (numel () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                type_name (), "real scalar");
+  if (numel () == 0)
+    err_invalid_conversion (type_name (), "real scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion (type_name (), "real scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            type_name (), "real scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 float
 octave_perm_matrix::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
 
-  if (numel () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                type_name (), "real scalar");
+  if (numel () == 0)
+    err_invalid_conversion (type_name (), "real scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion (type_name (), "real scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            type_name (), "real scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 Complex
 octave_perm_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                type_name (), "complex scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion (type_name (), "complex scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion (type_name (), "complex scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            type_name (), "complex scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 FloatComplex
 octave_perm_matrix::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                type_name (), "complex scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion (type_name (), "complex scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion (type_name (), "complex scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            type_name (), "complex scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 #define FORWARD_MATRIX_VALUE(TYPE, PREFIX) \
 TYPE \
 octave_perm_matrix::PREFIX ## _value (bool frc_str_conv) const \
 { \
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -179,45 +179,41 @@ octave_range::index_vector (bool require
 
 double
 octave_range::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
   octave_idx_type nel = range.numel ();
 
-  if (nel > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "range", "real scalar");
+  if (nel == 0)
+    err_invalid_conversion ("range", "real scalar");
 
-      retval = range.base ();
-    }
-  else
-    err_invalid_conversion ("range", "real scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "range", "real scalar");
+
+  retval = range.base ();
 
   return retval;
 }
 
 float
 octave_range::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
 
   octave_idx_type nel = range.numel ();
 
-  if (nel > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "range", "real scalar");
+  if (nel == 0)
+    err_invalid_conversion ("range", "real scalar");
 
-      retval = range.base ();
-    }
-  else
-    err_invalid_conversion ("range", "real scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "range", "real scalar");
+
+  retval = range.base ();
 
   return retval;
 }
 
 charNDArray
 octave_range::char_array_value (bool) const
 {
   const Matrix matrix = range.matrix_value ();
@@ -289,47 +285,43 @@ Complex
 octave_range::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   octave_idx_type nel = range.numel ();
 
-  if (nel > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "range", "complex scalar");
+  if (nel == 0)
+    err_invalid_conversion ("range", "complex scalar");
 
-      retval = range.base ();
-    }
-  else
-    err_invalid_conversion ("range", "complex scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "range", "complex scalar");
+
+  retval = range.base ();
 
   return retval;
 }
 
 FloatComplex
 octave_range::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
   octave_idx_type nel = range.numel ();
 
-  if (nel > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "range", "complex scalar");
+  if (nel == 0)
+    err_invalid_conversion ("range", "complex scalar");
 
-      retval = range.base ();
-    }
-  else
-    err_invalid_conversion ("range", "complex scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "range", "complex scalar");
+
+  retval = range.base ();
 
   return retval;
 }
 
 boolNDArray
 octave_range::bool_array_value (bool warn) const
 {
   Matrix m = range.matrix_value ();
diff --git a/libinterp/octave-value/ov-re-mat.cc b/libinterp/octave-value/ov-re-mat.cc
--- a/libinterp/octave-value/ov-re-mat.cc
+++ b/libinterp/octave-value/ov-re-mat.cc
@@ -101,43 +101,39 @@ octave_matrix::try_narrowing_conversion 
   return retval;
 }
 
 double
 octave_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
-  if (numel () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "real matrix", "real scalar");
+  if (numel () == 0)
+    err_invalid_conversion ("real matrix", "real scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("real matrix", "real scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "real matrix", "real scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 float
 octave_matrix::float_value (bool) const
 {
   float retval = lo_ieee_float_nan_value ();
 
-  if (numel () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "real matrix", "real scalar");
+  if (numel () == 0)
+    err_invalid_conversion ("real matrix", "real scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("real matrix", "real scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "real matrix", "real scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 // FIXME
 
 Matrix
 octave_matrix::matrix_value (bool) const
@@ -153,45 +149,41 @@ octave_matrix::float_matrix_value (bool)
 
 Complex
 octave_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "real matrix", "complex scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("real matrix", "complex scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("real matrix", "complex scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "real matrix", "complex scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 FloatComplex
 octave_matrix::float_complex_value (bool) const
 {
   float tmp = lo_ieee_float_nan_value ();
 
   FloatComplex retval (tmp, tmp);
 
-  if (rows () > 0 && columns () > 0)
-    {
-      warn_implicit_conversion ("Octave:array-to-scalar",
-                                "real matrix", "complex scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("real matrix", "complex scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("real matrix", "complex scalar");
+  warn_implicit_conversion ("Octave:array-to-scalar",
+                            "real matrix", "complex scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 // FIXME
 
 ComplexMatrix
 octave_matrix::complex_matrix_value (bool) const
@@ -384,39 +376,37 @@ octave_matrix::convert_to_str_internal (
   charNDArray chm (dv);
 
   bool warned = false;
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
       octave_quit ();
 
-      double d = matrix (i);
+      double d = matrix(i);
 
       if (xisnan (d))
         err_nan_to_character_conversion ();
-      else
-        {
-          int ival = NINT (d);
+
+      int ival = NINT (d);
 
-          if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
-            {
-              // FIXME: is there something better we could do?
+      if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
+        {
+          // FIXME: is there something better we could do?
 
-              ival = 0;
+          ival = 0;
 
-              if (! warned)
-                {
-                  ::warning ("range error for conversion to character value");
-                  warned = true;
-                }
+          if (! warned)
+            {
+              ::warning ("range error for conversion to character value");
+              warned = true;
             }
+        }
 
-          chm (i) = static_cast<char> (ival);
-        }
+      chm(i) = static_cast<char> (ival);
     }
 
   retval = octave_value (chm, type);
 
   return retval;
 }
 
 bool
diff --git a/libinterp/octave-value/ov-re-sparse.cc b/libinterp/octave-value/ov-re-sparse.cc
--- a/libinterp/octave-value/ov-re-sparse.cc
+++ b/libinterp/octave-value/ov-re-sparse.cc
@@ -92,48 +92,44 @@ octave_sparse_matrix::try_narrowing_conv
   return retval;
 }
 
 double
 octave_sparse_matrix::double_value (bool) const
 {
   double retval = lo_ieee_nan_value ();
 
-  if (numel () > 0)
-    {
-      if (numel () > 1)
-        warn_implicit_conversion ("Octave:array-to-scalar",
-                                  "real sparse matrix", "real scalar");
+  if (numel () == 0)
+    err_invalid_conversion ("real sparse matrix", "real scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("real sparse matrix", "real scalar");
+  if (numel () > 1)
+    warn_implicit_conversion ("Octave:array-to-scalar",
+                              "real sparse matrix", "real scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 Complex
 octave_sparse_matrix::complex_value (bool) const
 {
   double tmp = lo_ieee_nan_value ();
 
   Complex retval (tmp, tmp);
 
   // FIXME: maybe this should be a function, valid_as_scalar()
-  if (rows () > 0 && columns () > 0)
-    {
-      if (numel () > 1)
-        warn_implicit_conversion ("Octave:array-to-scalar",
-                                  "real sparse matrix", "complex scalar");
+  if (rows () == 0 || columns () == 0)
+    err_invalid_conversion ("real sparse matrix", "complex scalar");
 
-      retval = matrix (0, 0);
-    }
-  else
-    err_invalid_conversion ("real sparse matrix", "complex scalar");
+  if (numel () > 1)
+    warn_implicit_conversion ("Octave:array-to-scalar",
+                              "real sparse matrix", "complex scalar");
+
+  retval = matrix(0, 0);
 
   return retval;
 }
 
 Matrix
 octave_sparse_matrix::matrix_value (bool) const
 {
   return matrix.matrix_value ();
@@ -220,37 +216,33 @@ octave_sparse_matrix::convert_to_str_int
              i < matrix.cidx (j+1); i++)
           {
             octave_quit ();
 
             double d = matrix.data (i);
 
             if (xisnan (d))
               err_nan_to_character_conversion ();
-            else
-              {
-                int ival = NINT (d);
+
+            int ival = NINT (d);
 
-                if (ival < 0
-                    || ival > std::numeric_limits<unsigned char>::max ())
-                  {
-                    // FIXME: is there something better we could do?
+            if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
+              {
+                // FIXME: is there something better we could do?
 
-                    ival = 0;
+                ival = 0;
 
-                    if (! warned)
-                      {
-                        ::warning ("range error for conversion to character value");
-                        warned = true;
-                      }
+                if (! warned)
+                  {
+                    ::warning ("range error for conversion to character value");
+                    warned = true;
                   }
+              }
 
-                chm (matrix.ridx (i) + j * nr) =
-                  static_cast<char> (ival);
-              }
+            chm(matrix.ridx (i) + j * nr) = static_cast<char> (ival);
           }
 
       retval = octave_value (chm, type);
     }
 
   return retval;
 }
 
diff --git a/libinterp/octave-value/ov-scalar.cc b/libinterp/octave-value/ov-scalar.cc
--- a/libinterp/octave-value/ov-scalar.cc
+++ b/libinterp/octave-value/ov-scalar.cc
@@ -122,31 +122,29 @@ octave_scalar::diag (octave_idx_type m, 
 
 octave_value
 octave_scalar::convert_to_str_internal (bool, bool, char type) const
 {
   octave_value retval;
 
   if (xisnan (scalar))
     err_nan_to_character_conversion ();
-  else
-    {
-      int ival = NINT (scalar);
+
+  int ival = NINT (scalar);
 
-      if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
-        {
-          // FIXME: is there something better we could do?
+  if (ival < 0 || ival > std::numeric_limits<unsigned char>::max ())
+    {
+      // FIXME: is there something better we could do?
 
-          ival = 0;
+      ival = 0;
 
-          ::warning ("range error for conversion to character value");
-        }
+      ::warning ("range error for conversion to character value");
+    }
 
-      retval = octave_value (std::string (1, static_cast<char> (ival)), type);
-    }
+  retval = octave_value (std::string (1, static_cast<char> (ival)), type);
 
   return retval;
 }
 
 bool
 octave_scalar::save_ascii (std::ostream& os)
 {
   double d = double_value ();
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -316,38 +316,36 @@ octave_struct::subsasgn (const std::stri
                 if (pkey != map.end ())
                   {
                     map.contents (pkey).make_unique ();
                     tmpc = map.contents (pkey).index (idx.front (), true);
                   }
 
                 // FIXME: better code reuse?
                 //        cf. octave_cell::subsasgn and the case below.
-                if (tmpc.numel () == 1)
+                if (tmpc.numel () != 1)
+                  err_indexed_cs_list ();
+
+                octave_value& tmp = tmpc(0);
+
+                bool orig_undefined = tmp.is_undefined ();
+
+                if (orig_undefined || tmp.is_zero_by_zero ())
                   {
-                    octave_value& tmp = tmpc(0);
-
-                    bool orig_undefined = tmp.is_undefined ();
-
-                    if (orig_undefined || tmp.is_zero_by_zero ())
-                      {
-                        tmp = octave_value::empty_conv (next_type, rhs);
-                        tmp.make_unique (); // probably a no-op.
-                      }
-                    else
-                      // optimization: ignore the copy
-                      // still stored inside our map.
-                      tmp.make_unique (1);
-
-                      t_rhs =(orig_undefined
-                              ? tmp.undef_subsasgn (next_type, next_idx, rhs)
-                              : tmp.subsasgn (next_type, next_idx, rhs));
+                    tmp = octave_value::empty_conv (next_type, rhs);
+                    tmp.make_unique (); // probably a no-op.
                   }
                 else
-                  err_indexed_cs_list ();
+                  // optimization: ignore the copy
+                  // still stored inside our map.
+                  tmp.make_unique (1);
+
+                  t_rhs =(orig_undefined
+                          ? tmp.undef_subsasgn (next_type, next_idx, rhs)
+                          : tmp.subsasgn (next_type, next_idx, rhs));
               }
             else
               err_invalid_index_for_assignment ();
           }
           break;
 
         case '.':
           {
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -2069,23 +2069,21 @@ do_binary_op (octave_value::binary_op op
   if (t1 == octave_class::static_type_id ()
       || t2 == octave_class::static_type_id ()
       || t1 == octave_classdef::static_type_id ()
       || t2 == octave_classdef::static_type_id ())
     {
       octave_value_typeinfo::binary_class_op_fcn f
         = octave_value_typeinfo::lookup_binary_class_op (op);
 
-      if (f)
-        {
-          retval = f (v1, v2);
-        }
-      else
+      if (! f)
         err_binary_op (octave_value::binary_op_as_string (op),
                        v1.class_name (), v2.class_name ());
+
+      retval = f (v1, v2);
     }
   else
     {
       // FIXME: we need to handle overloading operators for built-in
       // classes (double, char, int8, etc.)
 
       octave_value_typeinfo::binary_op_fcn f
         = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
@@ -2112,38 +2110,34 @@ do_binary_op (octave_value::binary_op op
                                                                cf1.type_id (),
                                                                t2))
             cf2 = 0;
 
           if (cf1)
             {
               octave_base_value *tmp = cf1 (*v1.rep);
 
-              if (tmp)
-                {
-                  tv1 = octave_value (tmp);
-                  t1 = tv1.type_id ();
-                }
-              else
+              if (! tmp)
                 err_binary_op_conv (octave_value::binary_op_as_string (op));
+
+              tv1 = octave_value (tmp);
+              t1 = tv1.type_id ();
             }
           else
             tv1 = v1;
 
           if (cf2)
             {
               octave_base_value *tmp = cf2 (*v2.rep);
 
-              if (tmp)
-                {
-                  tv2 = octave_value (tmp);
-                  t2 = tv2.type_id ();
-                }
-              else
+              if (! tmp)
                 err_binary_op_conv (octave_value::binary_op_as_string (op));
+
+              tv2 = octave_value (tmp);
+              t2 = tv2.type_id ();
             }
           else
             tv2 = v2;
 
           if (cf1 || cf2)
             {
               retval = do_binary_op (op, tv1, tv2);
             }
@@ -2164,53 +2158,48 @@ do_binary_op (octave_value::binary_op op
                                                                    cf1.type_id (),
                                                                    t2))
                 cf2 = 0;
 
               if (cf1)
                 {
                   octave_base_value *tmp = cf1 (*tv1.rep);
 
-                  if (tmp)
-                    {
-                      tv1 = octave_value (tmp);
-                      t1 = tv1.type_id ();
-                    }
-                  else
-                    err_binary_op_conv
-                      (octave_value::binary_op_as_string (op));
+                  if (! tmp)
+                    err_binary_op_conv (octave_value::binary_op_as_string (op));
+
+                  tv1 = octave_value (tmp);
+                  t1 = tv1.type_id ();
                 }
 
               if (cf2)
                 {
                   octave_base_value *tmp = cf2 (*tv2.rep);
 
                   if (tmp)
                     {
                       tv2 = octave_value (tmp);
                       t2 = tv2.type_id ();
                     }
                   else
                     err_binary_op_conv
                       (octave_value::binary_op_as_string (op));
                 }
 
-              if (cf1 || cf2)
-                {
-                  f = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
-
-                  if (f)
-                    retval = f (*tv1.rep, *tv2.rep);
-                  else
-                    err_binary_op (octave_value::binary_op_as_string (op),
-                                   v1.type_name (), v2.type_name ());
-                }
-              else
+              if (! cf1 && ! cf2)
                 err_binary_op (octave_value::binary_op_as_string (op),
                                v1.type_name (), v2.type_name ());
+
+              f = octave_value_typeinfo::lookup_binary_op (op, t1, t2);
+
+              if (! f)
+                err_binary_op (octave_value::binary_op_as_string (op),
+                               v1.type_name (), v2.type_name ());
+
+              retval = f (*tv1.rep, *tv2.rep);
             }
         }
     }
 
   return retval;
 }
 
 static octave_value
@@ -2360,48 +2349,42 @@ do_cat_op (const octave_value& v1, const
       else if (cf1.type_id () >= 0
                && octave_value_typeinfo::lookup_cat_op (cf1.type_id (), t2))
         cf2 = 0;
 
       if (cf1)
         {
           octave_base_value *tmp = cf1 (*v1.rep);
 
-          if (tmp)
-            {
-              tv1 = octave_value (tmp);
-              t1 = tv1.type_id ();
-            }
-          else
+          if (! tmp)
             err_cat_op_conv ();
+
+          tv1 = octave_value (tmp);
+          t1 = tv1.type_id ();
         }
       else
         tv1 = v1;
 
       if (cf2)
         {
           octave_base_value *tmp = cf2 (*v2.rep);
 
-          if (tmp)
-            {
-              tv2 = octave_value (tmp);
-              t2 = tv2.type_id ();
-            }
-          else
+          if (! tmp)
             err_cat_op_conv ();
+
+          tv2 = octave_value (tmp);
+          t2 = tv2.type_id ();
         }
       else
         tv2 = v2;
 
-      if (cf1 || cf2)
-        {
-          retval = do_cat_op (tv1, tv2, ra_idx);
-        }
-      else
+      if (! cf1 && ! cf2)
         err_cat_op (v1.type_name (), v2.type_name ());
+
+      retval = do_cat_op (tv1, tv2, ra_idx);
     }
 
   return retval;
 }
 
 octave_value
 do_colon_op (const octave_value& base, const octave_value& increment,
              const octave_value& limit, bool is_for_cmd_expr)
@@ -2531,21 +2514,20 @@ do_unary_op (octave_value::unary_op op, 
   int t = v.type_id ();
 
   if (t == octave_class::static_type_id ()
       || t == octave_classdef::static_type_id ())
     {
       octave_value_typeinfo::unary_class_op_fcn f
         = octave_value_typeinfo::lookup_unary_class_op (op);
 
-      if (f)
-        retval = f (v);
-      else
-        err_unary_op (octave_value::unary_op_as_string (op),
-                      v.class_name ());
+      if (! f)
+        err_unary_op (octave_value::unary_op_as_string (op), v.class_name ());
+
+      retval = f (v);
     }
   else
     {
       // FIXME: we need to handle overloading operators for built-in
       // classes (double, char, int8, etc.)
 
       octave_value_typeinfo::unary_op_fcn f
         = octave_value_typeinfo::lookup_unary_op (op, t);
@@ -2553,31 +2535,27 @@ do_unary_op (octave_value::unary_op op, 
       if (f)
         retval = f (*v.rep);
       else
         {
           octave_value tv;
           octave_base_value::type_conv_fcn cf
             = v.numeric_conversion_function ();
 
-          if (cf)
-            {
-              octave_base_value *tmp = cf (*v.rep);
-
-              if (tmp)
-                {
-                  tv = octave_value (tmp);
-                  retval = do_unary_op (op, tv);
-                }
-              else
-                err_unary_op_conv (octave_value::unary_op_as_string (op));
-            }
-          else
+          if (! cf)
             err_unary_op (octave_value::unary_op_as_string (op),
                           v.type_name ());
+
+          octave_base_value *tmp = cf (*v.rep);
+
+          if (! tmp)
+            err_unary_op_conv (octave_value::unary_op_as_string (op));
+
+          tv = octave_value (tmp);
+          retval = do_unary_op (op, tv);
         }
     }
 
   return retval;
 }
 
 OCTAVE_NORETURN static void
 err_unary_op_conversion_failed (const std::string& op,
@@ -2614,57 +2592,52 @@ octave_value::do_non_const_unary_op (una
           make_unique ();
 
           f (*rep);
         }
       else
         {
           octave_base_value::type_conv_fcn cf = numeric_conversion_function ();
 
-          if (cf)
+          if (! cf)
+            err_unary_op (octave_value::unary_op_as_string (op), type_name ());
+
+          octave_base_value *tmp = cf (*rep);
+
+          if (! tmp)
+            err_unary_op_conversion_failed
+              (octave_value::unary_op_as_string (op), type_name ());
+
+          octave_base_value *old_rep = rep;
+          rep = tmp;
+
+          t = type_id ();
+
+          f = octave_value_typeinfo::lookup_non_const_unary_op (op, t);
+
+          if (f)
             {
-              octave_base_value *tmp = cf (*rep);
-
-              if (tmp)
-                {
-                  octave_base_value *old_rep = rep;
-                  rep = tmp;
-
-                  t = type_id ();
-
-                  f = octave_value_typeinfo::lookup_non_const_unary_op (op, t);
-
-                  if (f)
-                    {
-                      f (*rep);
-
-                      if (old_rep && --old_rep->count == 0)
-                        delete old_rep;
-                    }
-                  else
-                    {
-                      if (old_rep)
-                        {
-                          if (--rep->count == 0)
-                            delete rep;
-
-                          rep = old_rep;
-                        }
-
-                      err_unary_op (octave_value::unary_op_as_string (op),
-                                    type_name ());
-                    }
-                }
-              else
-                err_unary_op_conversion_failed
-                  (octave_value::unary_op_as_string (op), type_name ());
+              f (*rep);
+
+              if (old_rep && --old_rep->count == 0)
+                delete old_rep;
             }
           else
-            err_unary_op (octave_value::unary_op_as_string (op),
-                          type_name ());
+            {
+              if (old_rep)
+                {
+                  if (--rep->count == 0)
+                    delete rep;
+
+                  rep = old_rep;
+                }
+
+              err_unary_op (octave_value::unary_op_as_string (op),
+                            type_name ());
+            }
         }
     }
   else
     {
       // Non-genuine.
       int t = type_id ();
 
       octave_value_typeinfo::non_const_unary_op_fcn f = 0;
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -177,18 +177,18 @@ make_value_list (tree_argument_list *arg
                  const octave_value *object, bool rvalue = true)
 {
   octave_value_list retval;
 
   if (args)
     {
       if (rvalue && object && args->has_magic_end () && object->is_undefined ())
         err_invalid_inquiry_subscript ();
-      else
-        retval = args->convert_to_const_vector (object);
+
+      retval = args->convert_to_const_vector (object);
     }
 
   octave_idx_type n = retval.length ();
 
   if (n > 0)
     retval.stash_name_tags (arg_nm);
 
   return retval;
@@ -529,18 +529,18 @@ tree_index_expression::lvalue (void)
           {
             octave_value_list tidx
               = make_value_list (*p_args, *p_arg_nm, &tmp, false);
 
             if (tmp.is_undefined ())
               {
                 if (tidx.has_magic_colon ())
                   err_invalid_inquiry_subscript ();
-                else
-                  tmp = Cell ();
+
+                tmp = Cell ();
               }
             else if (tmp.is_zero_by_zero ()
                      && (tmp.is_matrix_type () || tmp.is_string ()))
               {
                 tmp = Cell ();
               }
 
             retval.numel (tmp.numel (tidx));
@@ -564,18 +564,18 @@ tree_index_expression::lvalue (void)
                 octave_value_list pidx = idx.back ();
 
                 // Use octave_map, not octave_scalar_map so that the
                 // dimensions are 0x0, not 1x1.
                 if (tmp.is_undefined ())
                   {
                     if (pidx.has_magic_colon ())
                       err_invalid_inquiry_subscript ();
-                    else
-                      tmp = octave_map ();
+
+                    tmp = octave_map ();
                   }
                 else if (autoconv)
                   tmp = octave_map ();
 
                 retval.numel (tmp.numel (pidx));
 
                 tmpi = i-1;
                 tmpidx.push_back (tidx);
diff --git a/liboctave/array/Array-util.cc b/liboctave/array/Array-util.cc
--- a/liboctave/array/Array-util.cc
+++ b/liboctave/array/Array-util.cc
@@ -185,35 +185,35 @@ compute_index (octave_idx_type n, const 
   return n;
 }
 
 octave_idx_type
 compute_index (octave_idx_type i, octave_idx_type j, const dim_vector& dims)
 {
   if (i < 0)
     err_invalid_index (i, 2, 1);
-  else if (j < 0)
+  if (j < 0)
     err_invalid_index (j, 2, 2);
   if (i >= dims(0))
     err_index_out_of_range (2, 1, i+1, dims(0), dims);
   if (j >= dims.numel (1))
     err_index_out_of_range (2, 2, j+1, dims.numel (1), dims);
 
   return j*dims(0) + i;
 }
 
 octave_idx_type
 compute_index (octave_idx_type i, octave_idx_type j, octave_idx_type k,
                const dim_vector& dims)
 {
   if (i < 0)
     err_invalid_index (i, 3, 1);
-  else if (j < 0)
+  if (j < 0)
     err_invalid_index (j, 3, 2);
-  else if (k < 0)
+  if (k < 0)
     err_invalid_index (k, 3, 3);
   if (i >= dims(0))
     err_index_out_of_range (3, 1, i+1, dims(0), dims);
   if (j >= dims(1))
     err_index_out_of_range (3, 2, j+1, dims(1), dims);
   if (k >= dims.numel (2))
     err_index_out_of_range (3, 3, k+1, dims.numel (2), dims);
 
diff --git a/liboctave/array/Array.cc b/liboctave/array/Array.cc
--- a/liboctave/array/Array.cc
+++ b/liboctave/array/Array.cc
@@ -907,153 +907,146 @@ Array<T>::resize_fill_value (void) const
 
 // Yes, we could do resize using index & assign.  However, that would
 // possibly involve a lot more memory traffic than we actually need.
 
 template <class T>
 void
 Array<T>::resize1 (octave_idx_type n, const T& rfv)
 {
-  if (n >= 0 && ndims () == 2)
+  if (n < 0 || ndims () != 2)
+    err_invalid_resize ();
+
+  dim_vector dv;
+  // This is driven by Matlab's behaviour of giving a *row* vector
+  // on some out-of-bounds assignments.  Specifically, Matlab
+  // allows a(i) with out-of-bouds i when a is either of 0x0, 1x0,
+  // 1x1, 0xN, and gives a row vector in all cases (yes, even the
+  // last one, search me why).  Giving a column vector would make
+  // much more sense (given the way trailing singleton dims are
+  // treated).
+  bool invalid = false;
+  if (rows () == 0 || rows () == 1)
+    dv = dim_vector (1, n);
+  else if (columns () == 1)
+    dv = dim_vector (n, 1);
+  else
+    invalid = true;
+
+  if (invalid)
+    err_invalid_resize ();
+  else
     {
-      dim_vector dv;
-      // This is driven by Matlab's behaviour of giving a *row* vector
-      // on some out-of-bounds assignments.  Specifically, Matlab
-      // allows a(i) with out-of-bouds i when a is either of 0x0, 1x0,
-      // 1x1, 0xN, and gives a row vector in all cases (yes, even the
-      // last one, search me why).  Giving a column vector would make
-      // much more sense (given the way trailing singleton dims are
-      // treated).
-      bool invalid = false;
-      if (rows () == 0 || rows () == 1)
-        dv = dim_vector (1, n);
-      else if (columns () == 1)
-        dv = dim_vector (n, 1);
-      else
-        invalid = true;
-
-      if (invalid)
-        err_invalid_resize ();
-      else
+      octave_idx_type nx = numel ();
+      if (n == nx - 1 && n > 0)
         {
-          octave_idx_type nx = numel ();
-          if (n == nx - 1 && n > 0)
+          // Stack "pop" operation.
+          if (rep->count == 1)
+            slice_data[slice_len-1] = T ();
+          slice_len--;
+          dimensions = dv;
+        }
+      else if (n == nx + 1 && nx > 0)
+        {
+          // Stack "push" operation.
+          if (rep->count == 1
+              && slice_data + slice_len < rep->data + rep->len)
             {
-              // Stack "pop" operation.
-              if (rep->count == 1)
-                slice_data[slice_len-1] = T ();
-              slice_len--;
+              slice_data[slice_len++] = rfv;
               dimensions = dv;
             }
-          else if (n == nx + 1 && nx > 0)
+          else
             {
-              // Stack "push" operation.
-              if (rep->count == 1
-                  && slice_data + slice_len < rep->data + rep->len)
-                {
-                  slice_data[slice_len++] = rfv;
-                  dimensions = dv;
-                }
-              else
-                {
-                  static const octave_idx_type max_stack_chunk = 1024;
-                  octave_idx_type nn = n + std::min (nx, max_stack_chunk);
-                  Array<T> tmp (Array<T> (dim_vector (nn, 1)), dv, 0, n);
-                  T *dest = tmp.fortran_vec ();
-
-                  std::copy (data (), data () + nx, dest);
-                  dest[nx] = rfv;
-
-                  *this = tmp;
-                }
-            }
-          else if (n != nx)
-            {
-              Array<T> tmp = Array<T> (dv);
+              static const octave_idx_type max_stack_chunk = 1024;
+              octave_idx_type nn = n + std::min (nx, max_stack_chunk);
+              Array<T> tmp (Array<T> (dim_vector (nn, 1)), dv, 0, n);
               T *dest = tmp.fortran_vec ();
 
-              octave_idx_type n0 = std::min (n, nx);
-              octave_idx_type n1 = n - n0;
-              std::copy (data (), data () + n0, dest);
-              std::fill_n (dest + n0, n1, rfv);
+              std::copy (data (), data () + nx, dest);
+              dest[nx] = rfv;
 
               *this = tmp;
             }
         }
+      else if (n != nx)
+        {
+          Array<T> tmp = Array<T> (dv);
+          T *dest = tmp.fortran_vec ();
+
+          octave_idx_type n0 = std::min (n, nx);
+          octave_idx_type n1 = n - n0;
+          std::copy (data (), data () + n0, dest);
+          std::fill_n (dest + n0, n1, rfv);
+
+          *this = tmp;
+        }
     }
-  else
-    err_invalid_resize ();
 }
 
 template <class T>
 void
 Array<T>::resize2 (octave_idx_type r, octave_idx_type c, const T& rfv)
 {
-  if (r >= 0 && c >= 0 && ndims () == 2)
+  if (r < 0 || c < 0 || ndims () != 2)
+    err_invalid_resize ();
+
+  octave_idx_type rx = rows ();
+  octave_idx_type cx = columns ();
+  if (r != rx || c != cx)
     {
-      octave_idx_type rx = rows ();
-      octave_idx_type cx = columns ();
-      if (r != rx || c != cx)
+      Array<T> tmp = Array<T> (dim_vector (r, c));
+      T *dest = tmp.fortran_vec ();
+
+      octave_idx_type r0 = std::min (r, rx);
+      octave_idx_type r1 = r - r0;
+      octave_idx_type c0 = std::min (c, cx);
+      octave_idx_type c1 = c - c0;
+      const T *src = data ();
+      if (r == rx)
         {
-          Array<T> tmp = Array<T> (dim_vector (r, c));
-          T *dest = tmp.fortran_vec ();
-
-          octave_idx_type r0 = std::min (r, rx);
-          octave_idx_type r1 = r - r0;
-          octave_idx_type c0 = std::min (c, cx);
-          octave_idx_type c1 = c - c0;
-          const T *src = data ();
-          if (r == rx)
+          std::copy (src, src + r * c0, dest);
+          dest += r * c0;
+        }
+      else
+        {
+          for (octave_idx_type k = 0; k < c0; k++)
             {
-              std::copy (src, src + r * c0, dest);
-              dest += r * c0;
+              std::copy (src, src + r0, dest);
+              src += rx;
+              dest += r0;
+              std::fill_n (dest, r1, rfv);
+              dest += r1;
             }
-          else
-            {
-              for (octave_idx_type k = 0; k < c0; k++)
-                {
-                  std::copy (src, src + r0, dest);
-                  src += rx;
-                  dest += r0;
-                  std::fill_n (dest, r1, rfv);
-                  dest += r1;
-                }
-            }
-
-          std::fill_n (dest, r * c1, rfv);
-
-          *this = tmp;
         }
+
+      std::fill_n (dest, r * c1, rfv);
+
+      *this = tmp;
     }
-  else
-    err_invalid_resize ();
-
 }
 
 template<class T>
 void
 Array<T>::resize (const dim_vector& dv, const T& rfv)
 {
   int dvl = dv.length ();
   if (dvl == 2)
     resize2 (dv(0), dv(1), rfv);
   else if (dimensions != dv)
     {
-      if (dimensions.length () <= dvl && ! dv.any_neg ())
-        {
-          Array<T> tmp (dv);
-          // Prepare for recursive resizing.
-          rec_resize_helper rh (dv, dimensions.redim (dvl));
-
-          // Do it.
-          rh.resize_fill (data (), tmp.fortran_vec (), rfv);
-          *this = tmp;
-        }
-      else
+      if (dimensions.length () > dvl || dv.any_neg ())
         err_invalid_resize ();
+
+      Array<T> tmp (dv);
+      // Prepare for recursive resizing.
+      rec_resize_helper rh (dv, dimensions.redim (dvl));
+
+      // Do it.
+      rh.resize_fill (data (), tmp.fortran_vec (), rfv);
+      *this = tmp;
     }
 }
 
 template <class T>
 Array<T>
 Array<T>::index (const idx_vector& i, bool resize_ok, const T& rfv) const
 {
   Array<T> tmp = *this;
@@ -1138,55 +1131,53 @@ Array<T>::index (const Array<idx_vector>
 
 template <class T>
 void
 Array<T>::assign (const idx_vector& i, const Array<T>& rhs, const T& rfv)
 {
   octave_idx_type n = numel ();
   octave_idx_type rhl = rhs.numel ();
 
-  if (rhl == 1 || i.length (n) == rhl)
+  if (rhl != 1 && i.length (n) != rhl)
+    err_nonconformant ("=", dim_vector(i.length(n),1), rhs.dims());
+
+  octave_idx_type nx = i.extent (n);
+  bool colon = i.is_colon_equiv (nx);
+  // Try to resize first if necessary.
+  if (nx != n)
     {
-      octave_idx_type nx = i.extent (n);
-      bool colon = i.is_colon_equiv (nx);
-      // Try to resize first if necessary.
-      if (nx != n)
-        {
-          // Optimize case A = []; A(1:n) = X with A empty.
-          if (dimensions.zero_by_zero () && colon)
-            {
-              if (rhl == 1)
-                *this = Array<T> (dim_vector (1, nx), rhs(0));
-              else
-                *this = Array<T> (rhs, dim_vector (1, nx));
-              return;
-            }
-
-          resize1 (nx, rfv);
-          n = numel ();
-        }
-
-      if (colon)
-        {
-          // A(:) = X makes a full fill or a shallow copy.
-          if (rhl == 1)
-            fill (rhs(0));
-          else
-            *this = rhs.reshape (dimensions);
-        }
-      else
+      // Optimize case A = []; A(1:n) = X with A empty.
+      if (dimensions.zero_by_zero () && colon)
         {
           if (rhl == 1)
-            i.fill (rhs(0), n, fortran_vec ());
+            *this = Array<T> (dim_vector (1, nx), rhs(0));
           else
-            i.assign (rhs.data (), n, fortran_vec ());
+            *this = Array<T> (rhs, dim_vector (1, nx));
+          return;
         }
+
+      resize1 (nx, rfv);
+      n = numel ();
+    }
+
+  if (colon)
+    {
+      // A(:) = X makes a full fill or a shallow copy.
+      if (rhl == 1)
+        fill (rhs(0));
+      else
+        *this = rhs.reshape (dimensions);
     }
   else
-    err_nonconformant ("=", dim_vector(i.length(n),1), rhs.dims());
+    {
+      if (rhl == 1)
+        i.fill (rhs(0), n, fortran_vec ());
+      else
+        i.assign (rhs.data (), n, fortran_vec ());
+    }
 }
 
 // Assignment to a 2-dimensional array
 template <class T>
 void
 Array<T>::assign (const idx_vector& i, const idx_vector& j,
                   const Array<T>& rhs, const T& rfv)
 {
diff --git a/liboctave/array/Sparse.cc b/liboctave/array/Sparse.cc
--- a/liboctave/array/Sparse.cc
+++ b/liboctave/array/Sparse.cc
@@ -1417,26 +1417,24 @@ Sparse<T>::index (const idx_vector& idx,
             }
 
           retval.xcidx (0) = 0;
           retval.xcidx (1) = nz;
         }
     }
   else if (idx.extent (nel) > nel)
     {
+      if (! resize_ok)
+        err_index_out_of_range (1, 1, idx.extent (nel), nel, dims ());
+
       // resize_ok is completely handled here.
-      if (resize_ok)
-        {
-          octave_idx_type ext = idx.extent (nel);
-          Sparse<T> tmp = *this;
-          tmp.resize1 (ext);
-          retval = tmp.index (idx);
-        }
-      else
-        err_index_out_of_range (1, 1, idx.extent (nel), nel, dims ());
+      octave_idx_type ext = idx.extent (nel);
+      Sparse<T> tmp = *this;
+      tmp.resize1 (ext);
+      retval = tmp.index (idx);
     }
   else if (nr == 1 && nc == 1)
     {
       // You have to be pretty sick to get to this bit of code,
       // since you have a scalar stored as a sparse matrix, and
       // then want to make a dense matrix with sparse
       // representation. Ok, we'll do it, but you deserve what
       // you get!!
diff --git a/liboctave/numeric/lo-specfun.cc b/liboctave/numeric/lo-specfun.cc
--- a/liboctave/numeric/lo-specfun.cc
+++ b/liboctave/numeric/lo-specfun.cc
@@ -2327,30 +2327,28 @@ betainc (double x, const Array<double>& 
 }
 
 Array<double>
 betainc (double x, const Array<double>& a, const Array<double>& b)
 {
   Array<double> retval;
   dim_vector dv = a.dims ();
 
-  if (dv == b.dims ())
-    {
-      octave_idx_type nel = dv.numel ();
-
-      retval.resize (dv);
-
-      double *pretval = retval.fortran_vec ();
-
-      for (octave_idx_type i = 0; i < nel; i++)
-        *pretval++ = betainc (x, a(i), b(i));
-    }
-  else
+  if (dv != b.dims ())
     err_betainc_nonconformant (dim_vector (0, 0), dv, b.dims ());
 
+  octave_idx_type nel = dv.numel ();
+
+  retval.resize (dv);
+
+  double *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betainc (x, a(i), b(i));
+
   return retval;
 }
 
 Array<double>
 betainc (const Array<double>& x, double a, double b)
 {
   dim_vector dv = x.dims ();
   octave_idx_type nel = dv.numel ();
@@ -2366,76 +2364,70 @@ betainc (const Array<double>& x, double 
 }
 
 Array<double>
 betainc (const Array<double>& x, double a, const Array<double>& b)
 {
   Array<double> retval;
   dim_vector dv = x.dims ();
 
-  if (dv == b.dims ())
-    {
-      octave_idx_type nel = dv.numel ();
-
-      retval.resize (dv);
-
-      double *pretval = retval.fortran_vec ();
-
-      for (octave_idx_type i = 0; i < nel; i++)
-        *pretval++ = betainc (x(i), a, b(i));
-    }
-  else
+  if (dv != b.dims ())
     err_betainc_nonconformant (dv, dim_vector (0, 0), b.dims ());
 
+  octave_idx_type nel = dv.numel ();
+
+  retval.resize (dv);
+
+  double *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betainc (x(i), a, b(i));
+
   return retval;
 }
 
 Array<double>
 betainc (const Array<double>& x, const Array<double>& a, double b)
 {
   Array<double> retval;
   dim_vector dv = x.dims ();
 
-  if (dv == a.dims ())
-    {
-      octave_idx_type nel = dv.numel ();
-
-      retval.resize (dv);
-
-      double *pretval = retval.fortran_vec ();
-
-      for (octave_idx_type i = 0; i < nel; i++)
-        *pretval++ = betainc (x(i), a(i), b);
-    }
-  else
+  if (dv != a.dims ())
     err_betainc_nonconformant (dv, a.dims (), dim_vector (0, 0));
 
+  octave_idx_type nel = dv.numel ();
+
+  retval.resize (dv);
+
+  double *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betainc (x(i), a(i), b);
+
   return retval;
 }
 
 Array<double>
 betainc (const Array<double>& x, const Array<double>& a, const Array<double>& b)
 {
   Array<double> retval;
   dim_vector dv = x.dims ();
 
-  if (dv == a.dims () && dv == b.dims ())
-    {
-      octave_idx_type nel = dv.numel ();
-
-      retval.resize (dv);
-
-      double *pretval = retval.fortran_vec ();
-
-      for (octave_idx_type i = 0; i < nel; i++)
-        *pretval++ = betainc (x(i), a(i), b(i));
-    }
-  else
+  if (dv != a.dims () || dv != b.dims ())
     err_betainc_nonconformant (dv, a.dims (), b.dims ());
 
+  octave_idx_type nel = dv.numel ();
+
+  retval.resize (dv);
+
+  double *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betainc (x(i), a(i), b(i));
+
   return retval;
 }
 
 float
 betainc (float x, float a, float b)
 {
   float retval;
   F77_XFCN (xbetai, XBETAI, (x, a, b, retval));
@@ -2475,30 +2467,28 @@ betainc (float x, const Array<float>& a,
 }
 
 Array<float>
 betainc (float x, const Array<float>& a, const Array<float>& b)
 {
   Array<float> retval;
   dim_vector dv = a.dims ();
 
-  if (dv == b.dims ())
-    {
-      octave_idx_type nel = dv.numel ();
-
-      retval.resize (dv);
-
-      float *pretval = retval.fortran_vec ();
-
-      for (octave_idx_type i = 0; i < nel; i++)
-        *pretval++ = betainc (x, a(i), b(i));
-    }
-  else
+  if (dv != b.dims ())
     err_betainc_nonconformant (dim_vector (0, 0), dv, b.dims ());
 
+  octave_idx_type nel = dv.numel ();
+
+  retval.resize (dv);
+
+  float *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betainc (x, a(i), b(i));
+
   return retval;
 }
 
 Array<float>
 betainc (const Array<float>& x, float a, float b)
 {
   dim_vector dv = x.dims ();
   octave_idx_type nel = dv.numel ();
@@ -2514,76 +2504,70 @@ betainc (const Array<float>& x, float a,
 }
 
 Array<float>
 betainc (const Array<float>& x, float a, const Array<float>& b)
 {
   Array<float> retval;
   dim_vector dv = x.dims ();
 
-  if (dv == b.dims ())
-    {
-      octave_idx_type nel = dv.numel ();
-
-      retval.resize (dv);
-
-      float *pretval = retval.fortran_vec ();
-
-      for (octave_idx_type i = 0; i < nel; i++)
-        *pretval++ = betainc (x(i), a, b(i));
-    }
-  else
+  if (dv != b.dims ())
     err_betainc_nonconformant (dv, dim_vector (0, 0), b.dims ());
 
+  octave_idx_type nel = dv.numel ();
+
+  retval.resize (dv);
+
+  float *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betainc (x(i), a, b(i));
+
   return retval;
 }
 
 Array<float>
 betainc (const Array<float>& x, const Array<float>& a, float b)
 {
   Array<float> retval;
   dim_vector dv = x.dims ();
 
-  if (dv == a.dims ())
-    {
-      octave_idx_type nel = dv.numel ();
-
-      retval.resize (dv);
-
-      float *pretval = retval.fortran_vec ();
-
-      for (octave_idx_type i = 0; i < nel; i++)
-        *pretval++ = betainc (x(i), a(i), b);
-    }
-  else
+  if (dv != a.dims ())
     err_betainc_nonconformant (dv, a.dims (), dim_vector (0, 0));
 
+  octave_idx_type nel = dv.numel ();
+
+  retval.resize (dv);
+
+  float *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betainc (x(i), a(i), b);
+
   return retval;
 }
 
 Array<float>
 betainc (const Array<float>& x, const Array<float>& a, const Array<float>& b)
 {
   Array<float> retval;
   dim_vector dv = x.dims ();
 
-  if (dv == a.dims () && dv == b.dims ())
-    {
-      octave_idx_type nel = dv.numel ();
-
-      retval.resize (dv);
-
-      float *pretval = retval.fortran_vec ();
-
-      for (octave_idx_type i = 0; i < nel; i++)
-        *pretval++ = betainc (x(i), a(i), b(i));
-    }
-  else
+  if (dv != a.dims () || dv != b.dims ())
     err_betainc_nonconformant (dv, a.dims (), b.dims ());
 
+  octave_idx_type nel = dv.numel ();
+
+  retval.resize (dv);
+
+  float *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betainc (x(i), a(i), b(i));
+
   return retval;
 }
 
 // FIXME: there is still room for improvement here...
 
 double
 gammainc (double x, double a, bool& err)
 {
@@ -3534,30 +3518,28 @@ betaincinv (double x, const Array<double
 }
 
 Array<double>
 betaincinv (double x, const Array<double>& a, const Array<double>& b)
 {
   Array<double> retval;
   dim_vector dv = a.dims ();
 
-  if (dv == b.dims ())
-    {
-      octave_idx_type nel = dv.numel ();
-
-      retval.resize (dv);
-
-      double *pretval = retval.fortran_vec ();
-
-      for (octave_idx_type i = 0; i < nel; i++)
-        *pretval++ = betaincinv (x, a(i), b(i));
-    }
-  else
+  if (dv != b.dims ())
     err_betaincinv_nonconformant (dim_vector (0, 0), dv, b.dims ());
 
+  octave_idx_type nel = dv.numel ();
+
+  retval.resize (dv);
+
+  double *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betaincinv (x, a(i), b(i));
+
   return retval;
 }
 
 Array<double>
 betaincinv (const Array<double>& x, double a, double b)
 {
   dim_vector dv = x.dims ();
   octave_idx_type nel = dv.numel ();
@@ -3573,77 +3555,71 @@ betaincinv (const Array<double>& x, doub
 }
 
 Array<double>
 betaincinv (const Array<double>& x, double a, const Array<double>& b)
 {
   Array<double> retval;
   dim_vector dv = x.dims ();
 
-  if (dv == b.dims ())
-    {
-      octave_idx_type nel = dv.numel ();
-
-      retval.resize (dv);
-
-      double *pretval = retval.fortran_vec ();
-
-      for (octave_idx_type i = 0; i < nel; i++)
-        *pretval++ = betaincinv (x(i), a, b(i));
-    }
-  else
+  if (dv != b.dims ())
     err_betaincinv_nonconformant (dv, dim_vector (0, 0), b.dims ());
 
+  octave_idx_type nel = dv.numel ();
+
+  retval.resize (dv);
+
+  double *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betaincinv (x(i), a, b(i));
+
   return retval;
 }
 
 Array<double>
 betaincinv (const Array<double>& x, const Array<double>& a, double b)
 {
   Array<double> retval;
   dim_vector dv = x.dims ();
 
-  if (dv == a.dims ())
-    {
-      octave_idx_type nel = dv.numel ();
-
-      retval.resize (dv);
-
-      double *pretval = retval.fortran_vec ();
-
-      for (octave_idx_type i = 0; i < nel; i++)
-        *pretval++ = betaincinv (x(i), a(i), b);
-    }
-  else
+  if (dv != a.dims ())
     err_betaincinv_nonconformant (dv, a.dims (), dim_vector (0, 0));
 
+  octave_idx_type nel = dv.numel ();
+
+  retval.resize (dv);
+
+  double *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betaincinv (x(i), a(i), b);
+
   return retval;
 }
 
 Array<double>
 betaincinv (const Array<double>& x, const Array<double>& a,
             const Array<double>& b)
 {
   Array<double> retval;
   dim_vector dv = x.dims ();
 
-  if (dv == a.dims () && dv == b.dims ())
-    {
-      octave_idx_type nel = dv.numel ();
-
-      retval.resize (dv);
-
-      double *pretval = retval.fortran_vec ();
-
-      for (octave_idx_type i = 0; i < nel; i++)
-        *pretval++ = betaincinv (x(i), a(i), b(i));
-    }
-  else
+  if (dv != a.dims () && dv != b.dims ())
     err_betaincinv_nonconformant (dv, a.dims (), b.dims ());
 
+  octave_idx_type nel = dv.numel ();
+
+  retval.resize (dv);
+
+  double *pretval = retval.fortran_vec ();
+
+  for (octave_idx_type i = 0; i < nel; i++)
+    *pretval++ = betaincinv (x(i), a(i), b(i));
+
   return retval;
 }
 
 void
 ellipj (double u, double m, double& sn, double& cn, double& dn, double& err)
 {
   static const int Nmax = 16;
   double m1, t=0, si_u, co_u, se_u, ta_u, b, c[Nmax], a[Nmax], phi;
diff --git a/liboctave/operators/mx-inlines.cc b/liboctave/operators/mx-inlines.cc
--- a/liboctave/operators/mx-inlines.cc
+++ b/liboctave/operators/mx-inlines.cc
@@ -410,25 +410,22 @@ inline Array<R>&
 do_mm_inplace_op (Array<R>& r, const Array<X>& x,
                   void (*op) (size_t, R *, const X *) throw (),
                   void (*op1) (size_t, R *, X) throw (),
                   const char *opname)
 {
   dim_vector dr = r.dims ();
   dim_vector dx = x.dims ();
   if (dr == dx)
-    {
-      op (r.numel (), r.fortran_vec (), x.data ());
-    }
+    op (r.numel (), r.fortran_vec (), x.data ());
   else if (is_valid_inplace_bsxfun (opname, dr, dx))
-    {
-      do_inplace_bsxfun_op (r, x, op, op1);
-    }
+    do_inplace_bsxfun_op (r, x, op, op1);
   else
     err_nonconformant (opname, dr, dx);
+
   return r;
 }
 
 template <class R, class X>
 inline Array<R>&
 do_ms_inplace_op (Array<R>& r, const X& x,
                   void (*op) (size_t, R *, X) throw ())
 {
diff --git a/liboctave/util/oct-binmap.h b/liboctave/util/oct-binmap.h
--- a/liboctave/util/oct-binmap.h
+++ b/liboctave/util/oct-binmap.h
@@ -170,26 +170,24 @@ binmap (const Array<T>& xa, const Array<
   dim_vector xad = xa.dims ();
   dim_vector yad = ya.dims ();
   if (xa.numel () == 1)
     return binmap<U, T, R, F> (xa(0), ya, fcn);
   else if (ya.numel () == 1)
     return binmap<U, T, R, F> (xa, ya(0), fcn);
   else if (xad != yad)
     {
-      if (is_valid_bsxfun (name, xad, yad))
-        {
-          bsxfun_wrapper<U, T, R, F>::set_f(fcn);
-          return do_bsxfun_op (xa, ya,
-                               bsxfun_wrapper<U, T, R, F>::op_mm,
-                               bsxfun_wrapper<U, T, R, F>::op_sm,
-                               bsxfun_wrapper<U, T, R, F>::op_ms);
-        }
-      else
+      if (! is_valid_bsxfun (name, xad, yad))
         err_nonconformant (name, xad, yad);
+
+      bsxfun_wrapper<U, T, R, F>::set_f(fcn);
+      return do_bsxfun_op (xa, ya,
+                           bsxfun_wrapper<U, T, R, F>::op_mm,
+                           bsxfun_wrapper<U, T, R, F>::op_sm,
+                           bsxfun_wrapper<U, T, R, F>::op_ms);
     }
 
   octave_idx_type len = xa.numel ();
 
   const T *x = xa.data ();
   const T *y = ya.data ();
 
   Array<U> result (xa.dims ());
