# HG changeset patch
# User Rik <rik@octave.org>
# Date 1430715162 25200
#      Sun May 03 21:52:42 2015 -0700
# Branch stable
# Node ID 075a5e2e1ba53478938254ff92cfb1aa7ec196cc
# Parent  2645f9ef8c88528cc0fec18a43670086f9517211
doc: Update more docstrings to have one sentence summary as first line.
Reviewed build-aux, libinterp/dldfcn, libinterp/octave-value,
libinterp/parse-tree directories.

* build-aux/mk-opts.pl, libinterp/dldfcn/__magick_read__.cc,
libinterp/dldfcn/amd.cc, libinterp/dldfcn/audiodevinfo.cc,
libinterp/dldfcn/audioread.cc, libinterp/dldfcn/ccolamd.cc,
libinterp/dldfcn/chol.cc, libinterp/dldfcn/colamd.cc,
libinterp/dldfcn/convhulln.cc, libinterp/dldfcn/dmperm.cc,
libinterp/dldfcn/fftw.cc, libinterp/dldfcn/qr.cc, libinterp/dldfcn/symbfact.cc,
libinterp/dldfcn/symrcm.cc, libinterp/octave-value/ov-base.cc,
libinterp/octave-value/ov-bool-mat.cc, libinterp/octave-value/ov-cell.cc,
libinterp/octave-value/ov-class.cc, libinterp/octave-value/ov-fcn-handle.cc,
libinterp/octave-value/ov-fcn-inline.cc, libinterp/octave-value/ov-java.cc,
libinterp/octave-value/ov-null-mat.cc, libinterp/octave-value/ov-oncleanup.cc,
libinterp/octave-value/ov-range.cc, libinterp/octave-value/ov-struct.cc,
libinterp/octave-value/ov-typeinfo.cc, libinterp/octave-value/ov-usr-fcn.cc,
libinterp/octave-value/ov.cc, libinterp/parse-tree/lex.ll,
libinterp/parse-tree/oct-parse.in.yy, libinterp/parse-tree/pt-binop.cc,
libinterp/parse-tree/pt-eval.cc, libinterp/parse-tree/pt-mat.cc:
doc: Update more docstrings to have one sentence summary as first line.

diff --git a/build-aux/mk-opts.pl b/build-aux/mk-opts.pl
--- a/build-aux/mk-opts.pl
+++ b/build-aux/mk-opts.pl
@@ -227,20 +227,23 @@ sub process_data
 
   $OPT_FCN_NAME = "${FCN_NAME}_options" if not defined $OPT_FCN_NAME;
 
   $STATIC_OBJECT_NAME = "${FCN_NAME}_opts";
 
   if (not defined $DOC_STRING)
     {
       $DOC_STRING = "Query or set options for the function \@code{$FCN_NAME}.\\n\\
+\\n\\
 When called with no arguments, the names of all available options and\\n\\
 their current values are displayed.\\n\\
-Given one argument, return the value of the corresponding option.\\n\\
-When called with two arguments, \@code{$OPT_FCN_NAME} set the option\\n\\
+\\n\\
+Given one argument, return the value of the option \@var{opt}.\\n\\
+\\n\\
+When called with two arguments, \@code{$OPT_FCN_NAME} sets the option\\n\\
 \@var{opt} to value \@var{val}.";
     }
 }
 
 ## FIXME: What does this routine do?  And can it be simpler to understand?
 sub get_min_match_len_info
 {
   my ($i, $j, $k);
diff --git a/libinterp/dldfcn/__magick_read__.cc b/libinterp/dldfcn/__magick_read__.cc
--- a/libinterp/dldfcn/__magick_read__.cc
+++ b/libinterp/dldfcn/__magick_read__.cc
@@ -719,18 +719,18 @@ maybe_initialize_magick (void)
 }
 #endif
 
 DEFUN_DLD (__magick_read__, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{img}, @var{map}, @var{alpha}] =} __magick_read__ (@var{fname}, @var{options})\n\
 Read image with GraphicsMagick or ImageMagick.\n\
 \n\
-This is a private internal function not intended for direct use.  Instead\n\
-use @code{imread}.\n\
+This is a private internal function not intended for direct use.\n\
+Use @code{imread} instead.\n\
 \n\
 @seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
 {
   octave_value_list output;
 
 #ifndef HAVE_MAGICK
   gripe_disabled_feature ("imread", "Image IO");
@@ -1383,18 +1383,18 @@ write_file (const std::string& filename,
 
 #endif
 
 DEFUN_DLD (__magick_write__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __magick_write__ (@var{fname}, @var{fmt}, @var{img}, @var{map}, @var{options})\n\
 Write image with GraphicsMagick or ImageMagick.\n\
 \n\
-This is a private internal function not intended for direct use.  Instead\n\
-use @code{imwrite}.\n\
+This is a private internal function not intended for direct use.\n\
+Use @code{imwrite} instead.\n\
 \n\
 @seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifndef HAVE_MAGICK
   gripe_disabled_feature ("imwrite", "Image IO");
@@ -1784,18 +1784,18 @@ fill_exif_floats (octave_scalar_map& map
 
 #endif
 
 DEFUN_DLD (__magick_finfo__, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} __magick_finfo__ (@var{fname})\n\
 Read image information with GraphicsMagick or ImageMagick.\n\
 \n\
-This is a private internal function not intended for direct use.  Instead\n\
-use @code{imfinfo}.\n\
+This is a private internal function not intended for direct use.\n\
+Use @code{imfinfo} instead.\n\
 \n\
 @seealso{imfinfo, imformats, imread, imwrite}\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifndef HAVE_MAGICK
   gripe_disabled_feature ("imfinfo", "Image IO");
diff --git a/libinterp/dldfcn/amd.cc b/libinterp/dldfcn/amd.cc
--- a/libinterp/dldfcn/amd.cc
+++ b/libinterp/dldfcn/amd.cc
@@ -50,41 +50,42 @@ along with Octave; see the file COPYING.
 #define AMD_NAME(name) amd ## name
 #endif
 
 DEFUN_DLD (amd, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} amd (@var{S})\n\
 @deftypefnx {Loadable Function} {@var{p} =} amd (@var{S}, @var{opts})\n\
 \n\
-Return the approximate minimum degree permutation of a matrix.  This\n\
-permutation such that the Cholesky@tie{}factorization of @code{@var{S}\n\
-(@var{p}, @var{p})} tends to be sparser than the Cholesky@tie{}factorization\n\
-of @var{S} itself.  @code{amd} is typically faster than @code{symamd} but\n\
-serves a similar purpose.\n\
+Return the approximate minimum degree permutation of a matrix.\n\
 \n\
-The optional parameter @var{opts} is a structure that controls the\n\
-behavior of @code{amd}.  The fields of the structure are\n\
+This is a permutation such that the Cholesky@tie{}factorization of\n\
+@code{@var{S} (@var{p}, @var{p})} tends to be sparser than the\n\
+Cholesky@tie{}factorization of @var{S} itself.  @code{amd} is typically\n\
+faster than @code{symamd} but serves a similar purpose.\n\
+\n\
+The optional parameter @var{opts} is a structure that controls the behavior\n\
+of @code{amd}.  The fields of the structure are\n\
 \n\
 @table @asis\n\
 @item @var{opts}.dense\n\
 Determines what @code{amd} considers to be a dense row or column of the\n\
 input matrix.  Rows or columns with more than @code{max (16, (dense *\n\
 sqrt (@var{n})))} entries, where @var{n} is the order of the matrix @var{S},\n\
-are ignored by @code{amd} during the calculation of the permutation\n\
-The value of dense must be a positive scalar and its default value is 10.0\n\
+are ignored by @code{amd} during the calculation of the permutation.\n\
+The value of dense must be a positive scalar and the default value is 10.0\n\
 \n\
 @item @var{opts}.aggressive\n\
 If this value is a nonzero scalar, then @code{amd} performs aggressive\n\
 absorption.  The default is not to perform aggressive absorption.\n\
 @end table\n\
 \n\
 The author of the code itself is Timothy A. Davis\n\
-@email{davis@@cise.ufl.edu}, University of Florida (see\n\
-@url{http://www.cise.ufl.edu/research/sparse/amd}).\n\
+@email{davis@@cise.ufl.edu}, University of Florida\n\
+(see @url{http://www.cise.ufl.edu/research/sparse/amd}).\n\
 @seealso{symamd, colamd}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_AMD
   int nargin = args.length ();
 
diff --git a/libinterp/dldfcn/audiodevinfo.cc b/libinterp/dldfcn/audiodevinfo.cc
--- a/libinterp/dldfcn/audiodevinfo.cc
+++ b/libinterp/dldfcn/audiodevinfo.cc
@@ -72,35 +72,38 @@ DEFUN_DLD (audiodevinfo, args, ,
 \n\
 @deftypefnx {Loadable Function} {@var{devs} =} audiodevinfo (@var{io})\n\
 @deftypefnx {Loadable Function} {@var{name} =} audiodevinfo (@var{io}, @var{id})\n\
 @deftypefnx {Loadable Function} {@var{id} =} audiodevinfo (@var{io}, @var{name})\n\
 @deftypefnx {Loadable Function} {@var{id} =} audiodevinfo (@var{io}, @var{rate}, @var{bits}, @var{chans})\n\
 \n\
 @deftypefnx {Loadable Function} {@var{supports} =} audiodevinfo (@var{io}, @var{id}, @var{rate}, @var{bits}, @var{chans})\n\
 \n\
-Return a structure with fields \"input\" and \"output\".\n\
-The value of each field is a structure array with fields\n\
-\"Name\", @nospell{\"DriverVersion\"} and \"ID\" describing an audio device.\n\
+Return a structure describing the available audio input and output devices.\n\
+\n\
+The @var{devinfo} structure has two fields @qcode{\"input\"} and\n\
+@qcode{\"output\"}.  The value of each field is a structure array with fields\n\
+@qcode{\"Name\"}, @nospell{\"DriverVersion\"} and @qcode{\"ID\"} describing\n\
+an audio device.\n\
 \n\
 If the optional argument @var{io} is 1, return information about input\n\
 devices only.  If it is 0, return information about output devices only.\n\
 \n\
 If the optional argument @var{id} is provided, return information about\n\
-corresponding device.\n\
+the corresponding device.\n\
 \n\
 If the optional argument @var{name} is provided, return the id of the\n\
 named device.\n\
 \n\
-Given a sampling rate, bits per sample, and number of channels for\n\
-an input or output device, return the ID of the first device that\n\
-supports playback or recording using the specified parameters.\n\
+Given a sampling rate, bits per sample, and number of channels for an input\n\
+or output device, return the ID of the first device that supports playback\n\
+or recording using the specified parameters.\n\
 \n\
-If also given a device ID, return true if the device supports playback\n\
-or recording using those parameters.\n\
+If also given a device ID, return true if the device supports playback or\n\
+recording using those parameters.\n\
 @end deftypefn")
 {
   octave_value retval;
 
 #ifdef HAVE_PORTAUDIO
 
   int nargin = args.length ();
 
diff --git a/libinterp/dldfcn/audioread.cc b/libinterp/dldfcn/audioread.cc
--- a/libinterp/dldfcn/audioread.cc
+++ b/libinterp/dldfcn/audioread.cc
@@ -51,30 +51,28 @@ safe_close (SNDFILE *file)
 
 DEFUN_DLD (audioread, args, ,
            "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {[@var{y}, @var{fs}] =} audioread (@var{filename})\n\
 @deftypefnx {Loadable Function} {[@var{y}, @var{fs}] =} audioread (@var{filename}, @var{samples})\n\
 \n\
 @deftypefnx {Loadable Function} {[@var{y}, @var{fs}] =} audioread (@var{filename}, @var{datatype})\n\
 @deftypefnx {Loadable Function} {[@var{y}, @var{fs}] =} audioread (@var{filename}, @var{samples}, @var{datatype})\n\
-Read the audio file @var{filename} and return the audio data and sampling\n\
-rate.  The audio data is stored as matrix with rows corresponding\n\
-to audio frames and columns corresponding to channels.\n\
+Read the audio file @var{filename} and return the audio data @var{y} and\n\
+sampling rate @var{fs}.\n\
+\n\
+The audio data is stored as matrix with rows corresponding to audio frames\n\
+and columns corresponding to channels.\n\
 \n\
 The optional two-element vector argument @var{samples} specifies starting\n\
 and ending frames.\n\
 \n\
 The optional argument @var{datatype} specifies the datatype to return.\n\
-If it is @qcode{\"native\"}, then the type of data depends on how the\n\
-data is stored in the audio file.\n\
-\n\
-Read a file and return a specified range of frames in an array of specified\n\
-type.\n\
-\n\
+If it is @qcode{\"native\"}, then the type of data depends on how the data\n\
+is stored in the audio file.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
 #ifdef HAVE_SNDFILE
 
   int nargin = args.length ();
 
@@ -253,20 +251,20 @@ extension_to_format (const std::string& 
 
 #endif
 
 DEFUN_DLD (audiowrite, args, ,
            "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {} audiowrite (@var{filename}, @var{y}, @var{fs})\n\
 @deftypefnx {Loadable Function} {} audiowrite (@var{filename}, @var{y}, @var{fs}, @var{name}, @var{value}, @dots{})\n\
 \n\
-Write audio data from the matrix @var{y} to @var{filename} with the file\n\
-format determined by the file extension.\n\
+Write audio data from the matrix @var{y} to @var{filename} at sampling rate\n\
+@var{fs} with the file format determined by the file extension.\n\
 \n\
-Additional name and value argument pairs may be used to specify the\n\
+Additional name/value argument pairs may be used to specify the\n\
 following options:\n\
 \n\
 @table @samp\n\
 @item BitsPerSample\n\
 Number of bits per sample, valid values are 8, 16, 24 and 32.  Default is 16.\n\
 \n\
 @item BitRate\n\
 Valid argument name, but ignored.  Left for compatibility with @sc{matlab}.\n\
diff --git a/libinterp/dldfcn/ccolamd.cc b/libinterp/dldfcn/ccolamd.cc
--- a/libinterp/dldfcn/ccolamd.cc
+++ b/libinterp/dldfcn/ccolamd.cc
@@ -54,44 +54,45 @@ along with Octave; see the file COPYING.
 DEFUN_DLD (ccolamd, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} ccolamd (@var{S})\n\
 @deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{S}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {@var{p} =} ccolamd (@var{S}, @var{knobs}, @var{cmember})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} ccolamd (@dots{})\n\
 \n\
 Constrained column approximate minimum degree permutation.\n\
+\n\
 @code{@var{p} = ccolamd (@var{S})} returns the column approximate minimum\n\
 degree permutation vector for the sparse matrix @var{S}.  For a non-symmetric\n\
-matrix\n\
-@var{S},\n\
-@code{@var{S}(:, @var{p})} tends to have sparser LU@tie{}factors than\n\
-@var{S}.  @code{chol (@var{S}(:, @var{p})' * @var{S}(:, @var{p}))} also\n\
-tends to be sparser than @code{chol (@var{S}' * @var{S})}.  @code{@var{p} =\n\
-ccolamd (@var{S}, 1)} optimizes the ordering for @code{lu (@var{S}(:,\n\
-@var{p}))}.  The ordering is followed by a column elimination tree\n\
-post-ordering.\n\
+matrix @var{S}, @code{@var{S}(:, @var{p})} tends to have sparser\n\
+LU@tie{}factors than @var{S}.\n\
+@code{chol (@var{S}(:, @var{p})' * @var{S}(:, @var{p}))} also tends to be\n\
+sparser than @code{chol (@var{S}' * @var{S})}.\n\
+@code{@var{p} = ccolamd (@var{S}, 1)} optimizes the ordering for\n\
+@code{lu (@var{S}(:, @var{p}))}.  The ordering is followed by a column\n\
+elimination tree post-ordering.\n\
 \n\
 @var{knobs} is an optional 1-element to 5-element input vector, with a\n\
 default value of @code{[0 10 10 1 0]} if not present or empty.  Entries not\n\
 present are set to their defaults.\n\
 \n\
 @table @code\n\
 @item @var{knobs}(1)\n\
 if nonzero, the ordering is optimized for @code{lu (S(:, p))}.  It will be a\n\
-poor ordering for @code{chol (@var{S}(:, @var{p})' * @var{S}(:,\n\
-@var{p}))}.  This is the most important knob for ccolamd.\n\
+poor ordering for @code{chol (@var{S}(:, @var{p})' * @var{S}(:, @var{p}))}.\n\
+This is the most important knob for ccolamd.\n\
 \n\
 @item @var{knobs}(2)\n\
-if @var{S} is m-by-n, rows with more than @code{max (16, @var{knobs}(2) *\n\
-sqrt (n))} entries are ignored.\n\
+if @var{S} is m-by-n, rows with more than\n\
+@code{max (16, @var{knobs}(2) * sqrt (n))} entries are ignored.\n\
 \n\
 @item @var{knobs}(3)\n\
-columns with more than @code{max (16, @var{knobs}(3) * sqrt (min (@var{m},\n\
-@var{n})))} entries are ignored and ordered last in the output permutation\n\
+columns with more than\n\
+@code{max (16, @var{knobs}(3) * sqrt (min (@var{m}, @var{n})))} entries are\n\
+ignored and ordered last in the output permutation\n\
 (subject to the cmember constraints).\n\
 \n\
 @item @var{knobs}(4)\n\
 if nonzero, aggressive absorption is performed.\n\
 \n\
 @item @var{knobs}(5)\n\
 if nonzero, statistics and knobs are printed.\n\
 \n\
@@ -339,27 +340,28 @@ ccolamd, csymamd, amd, colamd, symamd, a
 
 DEFUN_DLD (csymamd, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} csymamd (@var{S})\n\
 @deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{S}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {@var{p} =} csymamd (@var{S}, @var{knobs}, @var{cmember})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} csymamd (@dots{})\n\
 \n\
-For a symmetric positive definite matrix @var{S}, returns the permutation\n\
+For a symmetric positive definite matrix @var{S}, return the permutation\n\
 vector @var{p} such that @code{@var{S}(@var{p},@var{p})} tends to have a\n\
-sparser Cholesky@tie{}factor than @var{S}.  Sometimes @code{csymamd} works\n\
-well for symmetric indefinite matrices too.  The matrix @var{S} is assumed\n\
-to be symmetric; only the strictly lower triangular part is referenced.\n\
-@var{S} must be square.  The ordering is followed by an elimination tree\n\
-post-ordering.\n\
+sparser Cholesky@tie{}factor than @var{S}.\n\
+\n\
+Sometimes @code{csymamd} works well for symmetric indefinite matrices too.  \n\
+The matrix @var{S} is assumed to be symmetric; only the strictly lower\n\
+triangular part is referenced.  @var{S} must be square.  The ordering is\n\
+followed by an elimination tree post-ordering.\n\
 \n\
 @var{knobs} is an optional 1-element to 3-element input vector, with a\n\
-default value of @code{[10 1 0]} if present or empty.  Entries not\n\
-present are set to their defaults.\n\
+default value of @code{[10 1 0]}.  Entries not present are set to their\n\
+defaults.\n\
 \n\
 @table @code\n\
 @item @var{knobs}(1)\n\
 If @var{S} is n-by-n, then rows and columns with more than\n\
 @code{max(16,@var{knobs}(1)*sqrt(n))} entries are ignored, and ordered\n\
 last in the output permutation (subject to the cmember constraints).\n\
 \n\
 @item @var{knobs}(2)\n\
@@ -372,18 +374,19 @@ If nonzero, statistics and knobs are pri
 \n\
 @var{cmember} is an optional vector of length n. It defines the constraints\n\
 on the ordering.  If @code{@var{cmember}(j) = @var{S}}, then row/column j is\n\
 in constraint set @var{c} (@var{c} must be in the range 1 to n).  In the\n\
 output permutation @var{p}, rows/columns in set 1 appear first, followed\n\
 by all rows/columns in set 2, and so on.  @code{@var{cmember} = ones (1,n)}\n\
 if not present or empty.  @code{csymamd (@var{S},[],1:n)} returns @code{1:n}.\n\
 \n\
-@code{@var{p} = csymamd (@var{S})} is about the same as @code{@var{p} =\n\
-symamd (@var{S})}.  @var{knobs} and its default values differ.\n\
+@code{@var{p} = csymamd (@var{S})} is about the same as\n\
+@code{@var{p} = symamd (@var{S})}.  @var{knobs} and its default values\n\
+differ.\n\
 \n\
 @code{@var{stats}(4:7)} provide information if CCOLAMD was able to\n\
 continue.  The matrix is OK if @code{@var{stats}(4)} is zero, or 1 if\n\
 invalid.  @code{@var{stats}(5)} is the rightmost column index that is\n\
 unsorted or contains duplicate entries, or zero if no such column exists.\n\
 @code{@var{stats}(6)} is the last seen duplicate or out-of-order row\n\
 index in the column index given by @code{@var{stats}(5)}, or zero if no\n\
 such row index exists.  @code{@var{stats}(7)} is the number of duplicate\n\
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -65,17 +65,19 @@ DEFUN_DLD (chol, args, nargout,
 @deftypefn  {Loadable Function} {@var{R} =} chol (@var{A})\n\
 @deftypefnx {Loadable Function} {[@var{R}, @var{p}] =} chol (@var{A})\n\
 @deftypefnx {Loadable Function} {[@var{R}, @var{p}, @var{Q}] =} chol (@var{S})\n\
 @deftypefnx {Loadable Function} {[@var{R}, @var{p}, @var{Q}] =} chol (@var{S}, \"vector\")\n\
 @deftypefnx {Loadable Function} {[@var{L}, @dots{}] =} chol (@dots{}, \"lower\")\n\
 @deftypefnx {Loadable Function} {[@var{L}, @dots{}] =} chol (@dots{}, \"upper\")\n\
 @cindex Cholesky factorization\n\
 Compute the Cholesky@tie{}factor, @var{R}, of the symmetric positive definite\n\
-matrix @var{A}, where\n\
+matrix @var{A}.\n\
+\n\
+The Cholesky@tie{}factor is defined by\n\
 @tex\n\
 $ R^T R = A $.\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @var{R}' * @var{R} = @var{A}.\n\
 @end example\n\
@@ -84,18 +86,18 @@ matrix @var{A}, where\n\
 \n\
 Called with one output argument @code{chol} fails if @var{A} or @var{S} is\n\
 not positive definite.  With two or more output arguments @var{p} flags\n\
 whether the matrix was positive definite and @code{chol} does not fail.  A\n\
 zero value indicated that the matrix was positive definite and the @var{R}\n\
 gives the factorization, and @var{p} will have a positive value otherwise.\n\
 \n\
 If called with 3 outputs then a sparsity preserving row/column permutation\n\
-is applied to @var{A} prior to the factorization.  That is @var{R}\n\
-is the factorization of @code{@var{A}(@var{Q},@var{Q})} such that\n\
+is applied to @var{A} prior to the factorization.  That is @var{R} is the\n\
+factorization of @code{@var{A}(@var{Q},@var{Q})} such that\n\
 @tex\n\
 $ R^T R = Q^T A Q$.\n\
 @end tex\n\
 @ifnottex\n\
 \n\
 @example\n\
 @var{R}' * @var{R} = @var{Q}' * @var{A} * @var{Q}.\n\
 @end example\n\
@@ -385,18 +387,18 @@ sparse matrices.\n\
 %!error <matrix must be positive definite> chol ([1, 2; 3, 4])
 %!error <requires square matrix> chol ([1, 2; 3, 4; 5, 6])
 %!error <unexpected second or third input> chol (1, 2)
 */
 
 DEFUN_DLD (cholinv, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} cholinv (@var{A})\n\
-Use the Cholesky@tie{}factorization to compute the inverse of the\n\
-symmetric positive definite matrix @var{A}.\n\
+Compute the inverse of the symmetric positive definite matrix @var{A} using\n\
+the Cholesky@tie{}factorization.\n\
 @seealso{chol, chol2inv, inv}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
@@ -533,20 +535,21 @@ symmetric positive definite matrix @var{
 %! Ainv3 = cholinv (sparse (A));
 %! assert (norm (Ainv-Ainv3), 0, 1e-10);
 */
 
 DEFUN_DLD (chol2inv, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} chol2inv (@var{U})\n\
 Invert a symmetric, positive definite square matrix from its Cholesky\n\
-decomposition, @var{U}.  Note that @var{U} should be an upper-triangular\n\
-matrix with positive diagonal elements.  @code{chol2inv (@var{U})}\n\
-provides @code{inv (@var{U}'*@var{U})} but it is much faster than\n\
-using @code{inv}.\n\
+decomposition, @var{U}.\n\
+\n\
+Note that @var{U} should be an upper-triangular matrix with positive\n\
+diagonal elements.  @code{chol2inv (@var{U})} provides\n\
+@code{inv (@var{U}'*@var{U})} but it is much faster than using @code{inv}.\n\
 @seealso{chol, cholinv, inv}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
@@ -624,19 +627,20 @@ using @code{inv}.\n\
     print_usage ();
 
   return retval;
 }
 
 DEFUN_DLD (cholupdate, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{R1}, @var{info}] =} cholupdate (@var{R}, @var{u}, @var{op})\n\
-Update or downdate a Cholesky@tie{}factorization.  Given an upper triangular\n\
-matrix @var{R} and a column vector @var{u}, attempt to determine another\n\
-upper triangular matrix @var{R1} such that\n\
+Update or downdate a Cholesky@tie{}factorization.\n\
+\n\
+Given an upper triangular matrix @var{R} and a column vector @var{u},\n\
+attempt to determine another upper triangular matrix @var{R1} such that\n\
 \n\
 @itemize @bullet\n\
 @item\n\
 @var{R1}'*@var{R1} = @var{R}'*@var{R} + @var{u}*@var{u}'\n\
 if @var{op} is @qcode{\"+\"}\n\
 \n\
 @item\n\
 @var{R1}'*@var{R1} = @var{R}'*@var{R} - @var{u}*@var{u}'\n\
@@ -839,16 +843,17 @@ DEFUN_DLD (cholinsert, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{R1} =} cholinsert (@var{R}, @var{j}, @var{u})\n\
 @deftypefnx {Loadable Function} {[@var{R1}, @var{info}] =} cholinsert (@var{R}, @var{j}, @var{u})\n\
 Given a Cholesky@tie{}factorization of a real symmetric or complex Hermitian\n\
 positive definite matrix @w{@var{A} = @var{R}'*@var{R}}, @var{R}@tie{}upper\n\
 triangular, return the Cholesky@tie{}factorization of\n\
 @var{A1}, where @w{A1(p,p) = A}, @w{A1(:,j) = A1(j,:)' = u} and\n\
 @w{p = [1:j-1,j+1:n+1]}.  @w{u(j)} should be positive.\n\
+\n\
 On return, @var{info} is set to\n\
 \n\
 @itemize\n\
 @item 0 if the insertion was successful,\n\
 \n\
 @item 1 if @var{A1} is not positive definite,\n\
 \n\
 @item 2 if @var{R} is singular.\n\
diff --git a/libinterp/dldfcn/colamd.cc b/libinterp/dldfcn/colamd.cc
--- a/libinterp/dldfcn/colamd.cc
+++ b/libinterp/dldfcn/colamd.cc
@@ -211,17 +211,18 @@ coletree (const octave_idx_type *ridx, c
 
 DEFUN_DLD (colamd, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} colamd (@var{S})\n\
 @deftypefnx {Loadable Function} {@var{p} =} colamd (@var{S}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} colamd (@var{S})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} colamd (@var{S}, @var{knobs})\n\
 \n\
-Column approximate minimum degree permutation.\n\
+Compute the column approximate minimum degree permutation.\n\
+\n\
 @code{@var{p} = colamd (@var{S})} returns the column approximate minimum\n\
 degree permutation vector for the sparse matrix @var{S}.  For a\n\
 non-symmetric matrix @var{S}, @code{@var{S}(:,@var{p})} tends to have\n\
 sparser LU@tie{}factors than @var{S}.  The Cholesky@tie{}factorization of\n\
 @code{@var{S}(:,@var{p})' * @var{S}(:,@var{p})} also tends to be sparser\n\
 than that of @code{@var{S}' * @var{S}}.\n\
 \n\
 @var{knobs} is an optional one- to three-element input vector.  If @var{S} is\n\
@@ -253,17 +254,17 @@ more times in the same column) or if the
 of order, then @sc{colamd} can correct these errors by ignoring the duplicate\n\
 entries and sorting each column of its internal copy of the matrix\n\
 @var{S} (the input matrix @var{S} is not repaired, however).  If a matrix\n\
 is invalid in other ways then @sc{colamd} cannot continue, an error message\n\
 is printed, and no output arguments (@var{p} or @var{stats}) are returned.\n\
 @sc{colamd} is thus a simple way to check a sparse matrix to see if it's\n\
 valid.\n\
 \n\
-@code{@var{stats}(4:7)} provide information if COLAMD was able to\n\
+@code{@var{stats}(4:7)} provide information if @sc{colamd} was able to\n\
 continue.  The matrix is OK if @code{@var{stats}(4)} is zero, or 1 if\n\
 invalid.  @code{@var{stats}(5)} is the rightmost column index that is\n\
 unsorted or contains duplicate entries, or zero if no such column exists.\n\
 @code{@var{stats}(6)} is the last seen duplicate or out-of-order row\n\
 index in the column index given by @code{@var{stats}(5)}, or zero if no\n\
 such row index exists.  @code{@var{stats}(7)} is the number of duplicate\n\
 or out-of-order row indices.  @code{@var{stats}(8:20)} is always zero in\n\
 the current version of @sc{colamd} (reserved for future use).\n\
@@ -453,35 +454,37 @@ DEFUN_DLD (symamd, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} symamd (@var{S})\n\
 @deftypefnx {Loadable Function} {@var{p} =} symamd (@var{S}, @var{knobs})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} symamd (@var{S})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{stats}] =} symamd (@var{S}, @var{knobs})\n\
 \n\
 For a symmetric positive definite matrix @var{S}, returns the permutation\n\
 vector p such that @code{@var{S}(@var{p}, @var{p})} tends to have a\n\
-sparser Cholesky@tie{}factor than @var{S}.  Sometimes @code{symamd} works\n\
-well for symmetric indefinite matrices too.  The matrix @var{S} is assumed\n\
-to be symmetric; only the strictly lower triangular part is referenced.\n\
-@var{S} must be square.\n\
+sparser Cholesky@tie{}factor than @var{S}.\n\
+\n\
+Sometimes @code{symamd} works well for symmetric indefinite matrices too.  \n\
+The matrix @var{S} is assumed to be symmetric; only the strictly lower\n\
+triangular part is referenced.  @var{S} must be square.\n\
 \n\
 @var{knobs} is an optional one- to two-element input vector.  If @var{S} is\n\
 n-by-n, then rows and columns with more than\n\
 @code{max (16,@var{knobs}(1)*sqrt(n))} entries are removed prior to ordering,\n\
 and ordered last in the output permutation @var{p}.  No rows/columns are\n\
 removed if @code{@var{knobs}(1) < 0}.  If @code{@var{knobs} (2)} is nonzero,\n\
-@code{stats} and @var{knobs} are printed.  The default is @code{@var{knobs}\n\
-= [10 0]}.  Note that @var{knobs} differs from earlier versions of symamd.\n\
+@code{stats} and @var{knobs} are printed.  The default is\n\
+@code{@var{knobs} = [10 0]}.  Note that @var{knobs} differs from earlier\n\
+versions of @code{symamd}.\n\
 \n\
 @var{stats} is an optional 20-element output vector that provides data\n\
 about the ordering and the validity of the input matrix @var{S}.  Ordering\n\
-statistics are in @code{@var{stats}(1:3)}.  @code{@var{stats}(1) =\n\
-@var{stats}(2)} is the number of dense or empty rows and columns\n\
-ignored by SYMAMD and @code{@var{stats}(3)} is the number of garbage\n\
-collections performed on the internal data structure used by SYMAMD\n\
+statistics are in @code{@var{stats}(1:3)}.\n\
+@code{@var{stats}(1) = @var{stats}(2)} is the number of dense or empty rows\n\
+and columns ignored by SYMAMD and @code{@var{stats}(3)} is the number of\n\
+garbage collections performed on the internal data structure used by SYMAMD\n\
 (roughly of size @code{8.4 * nnz (tril (@var{S}, -1)) + 9 * @var{n}}\n\
 integers).\n\
 \n\
 Octave built-in functions are intended to generate valid sparse matrices,\n\
 with no duplicate entries, with ascending row indices of the nonzeros\n\
 in each column, with a non-negative number of entries in each column (!)\n\
 and so on.  If a matrix is invalid, then SYMAMD may or may not be able\n\
 to continue.  If there are duplicate entries (a row index appears two or\n\
@@ -643,19 +646,20 @@ Xerox PARC, and @nospell{Esmond Ng}, Oak
 }
 
 DEFUN_DLD (etree, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{p} =} etree (@var{S})\n\
 @deftypefnx {Loadable Function} {@var{p} =} etree (@var{S}, @var{typ})\n\
 @deftypefnx {Loadable Function} {[@var{p}, @var{q}] =} etree (@var{S}, @var{typ})\n\
 \n\
-Return the elimination tree for the matrix @var{S}.  By default @var{S}\n\
-is assumed to be symmetric and the symmetric elimination tree is\n\
-returned.  The argument @var{typ} controls whether a symmetric or\n\
+Return the elimination tree for the matrix @var{S}.\n\
+\n\
+By default @var{S} is assumed to be symmetric and the symmetric elimination\n\
+tree is returned.  The argument @var{typ} controls whether a symmetric or\n\
 column elimination tree is returned.  Valid values of @var{typ} are\n\
 @qcode{\"sym\"} or @qcode{\"col\"}, for symmetric or column elimination tree\n\
 respectively.\n\
 \n\
 Called with a second argument, @code{etree} also returns the postorder\n\
 permutations on the tree.\n\
 @end deftypefn")
 {
diff --git a/libinterp/dldfcn/convhulln.cc b/libinterp/dldfcn/convhulln.cc
--- a/libinterp/dldfcn/convhulln.cc
+++ b/libinterp/dldfcn/convhulln.cc
@@ -72,18 +72,21 @@ octave_qhull_dims_ok (octave_idx_type di
   return true;
 }
 
 DEFUN_DLD (convhulln, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{h} =} convhulln (@var{pts})\n\
 @deftypefnx {Loadable Function} {@var{h} =} convhulln (@var{pts}, @var{options})\n\
 @deftypefnx {Loadable Function} {[@var{h}, @var{v}] =} convhulln (@dots{})\n\
-Compute the convex hull of the set of points @var{pts} which is a matrix\n\
-of size [n, dim] containing n points in a space of dimension dim.\n\
+Compute the convex hull of the set of points @var{pts}.\n\
+\n\
+@var{pts} is a matrix of size [n, dim] containing n points in a space of\n\
+dimension dim.\n\
+\n\
 The hull @var{h} is an index vector into the set of points and specifies\n\
 which points form the enclosing hull.\n\
 \n\
 An optional second argument, which must be a string or cell array of strings,\n\
 contains options passed to the underlying qhull command.\n\
 See the documentation for the Qhull library for details\n\
 @url{http://www.qhull.org/html/qh-quick.htm#options}.\n\
 The default options depend on the dimension of the input:\n\
diff --git a/libinterp/dldfcn/dmperm.cc b/libinterp/dldfcn/dmperm.cc
--- a/libinterp/dldfcn/dmperm.cc
+++ b/libinterp/dldfcn/dmperm.cc
@@ -189,19 +189,20 @@ ACM Trans. Math. Software, 16(4):303-324
 %! assert (tril (a(p,q), -1), sparse (n, n));
 */
 
 DEFUN_DLD (sprank, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} sprank (@var{S})\n\
 @cindex structural rank\n\
 \n\
-Calculate the structural rank of the sparse matrix @var{S}.  Note that\n\
-only the structure of the matrix is used in this calculation based on\n\
-a @nospell{Dulmage-Mendelsohn} permutation to block triangular form.  As\n\
+Calculate the structural rank of the sparse matrix @var{S}.\n\
+\n\
+Note that only the structure of the matrix is used in this calculation based\n\
+on a @nospell{Dulmage-Mendelsohn} permutation to block triangular form.  As\n\
 such the numerical rank of the matrix @var{S} is bounded by\n\
 @code{sprank (@var{S}) >= rank (@var{S})}.  Ignoring floating point errors\n\
 @code{sprank (@var{S}) == rank (@var{S})}.\n\
 @seealso{dmperm}\n\
 @end deftypefn")
 {
   int nargin = args.length ();
   octave_value_list retval;
diff --git a/libinterp/dldfcn/fftw.cc b/libinterp/dldfcn/fftw.cc
--- a/libinterp/dldfcn/fftw.cc
+++ b/libinterp/dldfcn/fftw.cc
@@ -38,22 +38,24 @@ DEFUN_DLD (fftw, args, ,
            "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {@var{method} =} fftw (\"planner\")\n\
 @deftypefnx {Loadable Function} {} fftw (\"planner\", @var{method})\n\
 @deftypefnx {Loadable Function} {@var{wisdom} =} fftw (\"dwisdom\")\n\
 @deftypefnx {Loadable Function} {} fftw (\"dwisdom\", @var{wisdom})\n\
 @deftypefnx {Loadable Function} {} fftw (\"threads\", @var{nthreads})\n\
 @deftypefnx {Loadable Function} {@var{nthreads} =} fftw (\"threads\")\n\
 \n\
-Manage @sc{fftw} wisdom data.  Wisdom data can be used to significantly\n\
-accelerate the calculation of the FFTs, but implies an initial cost\n\
-in its calculation.  When the @sc{fftw} libraries are initialized, they read\n\
-a system wide wisdom file (typically in @file{/etc/fftw/wisdom}), allowing\n\
-wisdom to be shared between applications other than Octave.  Alternatively,\n\
-the @code{fftw} function can be used to import wisdom.  For example,\n\
+Manage @sc{fftw} wisdom data.\n\
+\n\
+Wisdom data can be used to significantly accelerate the calculation of the\n\
+FFTs, but implies an initial cost in its calculation.  When the @sc{fftw}\n\
+libraries are initialized, they read a system wide wisdom file (typically in\n\
+@file{/etc/fftw/wisdom}), allowing wisdom to be shared between applications\n\
+other than Octave.  Alternatively, the @code{fftw} function can be used to\n\
+import wisdom.  For example,\n\
 \n\
 @example\n\
 @var{wisdom} = fftw (\"dwisdom\")\n\
 @end example\n\
 \n\
 @noindent\n\
 will save the existing wisdom used by Octave to the string @var{wisdom}.\n\
 This string can then be saved to a file and restored using the @code{save}\n\
diff --git a/libinterp/dldfcn/qr.cc b/libinterp/dldfcn/qr.cc
--- a/libinterp/dldfcn/qr.cc
+++ b/libinterp/dldfcn/qr.cc
@@ -75,17 +75,19 @@ get_qr_r (const base_qr<MT>& fact)
 DEFUN_DLD (qr, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {[@var{Q}, @var{R}, @var{P}] =} qr (@var{A})\n\
 @deftypefnx {Loadable Function} {[@var{Q}, @var{R}, @var{P}] =} qr (@var{A}, '0')\n\
 @deftypefnx {Loadable Function} {[@var{C}, @var{R}] =} qr (@var{A}, @var{B})\n\
 @deftypefnx {Loadable Function} {[@var{C}, @var{R}] =} qr (@var{A}, @var{B}, '0')\n\
 @cindex QR factorization\n\
 Compute the QR@tie{}factorization of @var{A}, using standard @sc{lapack}\n\
-subroutines.  For example, given the matrix @code{@var{A} = [1, 2; 3, 4]},\n\
+subroutines.\n\
+\n\
+For example, given the matrix @code{@var{A} = [1, 2; 3, 4]},\n\
 \n\
 @example\n\
 [@var{Q}, @var{R}] = qr (@var{A})\n\
 @end example\n\
 \n\
 @noindent\n\
 returns\n\
 \n\
@@ -119,34 +121,34 @@ min norm(A x - b)\n\
 @end ifnottex\n\
 for overdetermined systems of equations (i.e.,\n\
 @tex\n\
 $A$\n\
 @end tex\n\
 @ifnottex\n\
 @var{A}\n\
 @end ifnottex\n\
- is a tall, thin matrix).  The QR@tie{}factorization is\n\
+is a tall, thin matrix).  The QR@tie{}factorization is\n\
 @tex\n\
 $QR = A$ where $Q$ is an orthogonal matrix and $R$ is upper triangular.\n\
 @end tex\n\
 @ifnottex\n\
 @code{@var{Q} * @var{R} = @var{A}} where @var{Q} is an orthogonal matrix and\n\
 @var{R} is upper triangular.\n\
 @end ifnottex\n\
 \n\
 If given a second argument of @qcode{'0'}, @code{qr} returns an economy-sized\n\
 QR@tie{}factorization, omitting zero rows of @var{R} and the corresponding\n\
 columns of @var{Q}.\n\
 \n\
 If the matrix @var{A} is full, the permuted QR@tie{}factorization\n\
 @code{[@var{Q}, @var{R}, @var{P}] = qr (@var{A})} forms the\n\
 QR@tie{}factorization such that the diagonal entries of @var{R} are\n\
-decreasing in magnitude order.  For example, given the matrix @code{a = [1,\n\
-2; 3, 4]},\n\
+decreasing in magnitude order.  For example, given the matrix\n\
+@code{a = [1, 2; 3, 4]},\n\
 \n\
 @example\n\
 [@var{Q}, @var{R}, @var{P}] = qr (@var{A})\n\
 @end example\n\
 \n\
 @noindent\n\
 returns\n\
 \n\
@@ -164,25 +166,25 @@ returns\n\
 \n\
 @var{P} =\n\
 \n\
    0  1\n\
    1  0\n\
 @end group\n\
 @end example\n\
 \n\
-The permuted @code{qr} factorization @code{[@var{Q}, @var{R}, @var{P}] = qr\n\
-(@var{A})} factorization allows the construction of an orthogonal basis of\n\
-@code{span (A)}.\n\
+The permuted @code{qr} factorization\n\
+@code{[@var{Q}, @var{R}, @var{P}] = qr (@var{A})} factorization allows the\n\
+construction of an orthogonal basis of @code{span (A)}.\n\
 \n\
 If the matrix @var{A} is sparse, then compute the sparse\n\
 QR@tie{}factorization of @var{A}, using @sc{CSparse}.  As the matrix @var{Q}\n\
 is in general a full matrix, this function returns the @var{Q}-less\n\
-factorization @var{R} of @var{A}, such that @code{@var{R} = chol (@var{A}' *\n\
-@var{A})}.\n\
+factorization @var{R} of @var{A}, such that\n\
+@code{@var{R} = chol (@var{A}' * @var{A})}.\n\
 \n\
 If the final argument is the scalar @code{0} and the number of rows is\n\
 larger than the number of columns, then an economy factorization is\n\
 returned.  That is @var{R} will have only @code{size (@var{A},1)} rows.\n\
 \n\
 If an additional matrix @var{B} is supplied, then @code{qr} returns\n\
 @var{C}, where @code{@var{C} = @var{Q}' * @var{B}}.  This allows the\n\
 least squares approximation of @code{@var{A} \\ @var{B}} to be calculated\n\
@@ -758,25 +760,25 @@ bool check_index (const octave_value& i,
           && (i.is_scalar_type () || vector_allowed));
 }
 
 DEFUN_DLD (qrupdate, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrupdate (@var{Q}, @var{R}, @var{u}, @var{v})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
-@var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization\n\
-of @w{@var{A} + @var{u}*@var{v}'}, where @var{u} and @var{v} are\n\
-column vectors (rank-1 update) or matrices with equal number of columns\n\
+@var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization of\n\
+@w{@var{A} + @var{u}*@var{v}'}, where @var{u} and @var{v} are column vectors\n\
+(rank-1 update) or matrices with equal number of columns\n\
 (rank-k update).  Notice that the latter case is done as a sequence of rank-1\n\
 updates; thus, for k large enough, it will be both faster and more accurate\n\
 to recompute the factorization from scratch.\n\
 \n\
-The QR@tie{}factorization supplied may be either full\n\
-(Q is square) or economized (R is square).\n\
+The QR@tie{}factorization supplied may be either full (Q is square) or\n\
+economized (R is square).\n\
 \n\
 @seealso{qr, qrinsert, qrdelete, qrshift}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
   octave_value_list retval;
 
   if (nargin != 4)
@@ -939,34 +941,31 @@ The QR@tie{}factorization supplied may b
 */
 
 DEFUN_DLD (qrinsert, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {[@var{Q1}, @var{R1}] =} qrinsert (@var{Q}, @var{R}, @var{j}, @var{x}, @var{orient})\n\
 Given a QR@tie{}factorization of a real or complex matrix\n\
 @w{@var{A} = @var{Q}*@var{R}}, @var{Q}@tie{}unitary and\n\
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization of\n\
-@w{[A(:,1:j-1) x A(:,j:n)]}, where @var{u} is a column vector to be\n\
-inserted into @var{A} (if @var{orient} is @qcode{\"col\"}), or the\n\
-QR@tie{}factorization of @w{[A(1:j-1,:);x;A(:,j:n)]}, where @var{x}\n\
-is a row vector to be inserted into @var{A} (if @var{orient} is\n\
-@qcode{\"row\"}).\n\
+@w{[A(:,1:j-1) x A(:,j:n)]}, where @var{u} is a column vector to be inserted\n\
+into @var{A} (if @var{orient} is @qcode{\"col\"}), or the\n\
+QR@tie{}factorization of @w{[A(1:j-1,:);x;A(:,j:n)]}, where @var{x} is a row\n\
+vector to be inserted into @var{A} (if @var{orient} is @qcode{\"row\"}).\n\
 \n\
-The default value of @var{orient} is @qcode{\"col\"}.\n\
-If @var{orient} is @qcode{\"col\"},\n\
-@var{u} may be a matrix and @var{j} an index vector\n\
+The default value of @var{orient} is @qcode{\"col\"}.  If @var{orient} is\n\
+@qcode{\"col\"}, @var{u} may be a matrix and @var{j} an index vector\n\
 resulting in the QR@tie{}factorization of a matrix @var{B} such that\n\
 @w{B(:,@var{j})} gives @var{u} and @w{B(:,@var{j}) = []} gives @var{A}.\n\
 Notice that the latter case is done as a sequence of k insertions;\n\
 thus, for k large enough, it will be both faster and more accurate to\n\
 recompute the factorization from scratch.\n\
 \n\
-If @var{orient} is @qcode{\"col\"},\n\
-the QR@tie{}factorization supplied may be either full\n\
-(Q is square) or economized (R is square).\n\
+If @var{orient} is @qcode{\"col\"}, the QR@tie{}factorization supplied may\n\
+be either full (Q is square) or economized (R is square).\n\
 \n\
 If @var{orient} is @qcode{\"row\"}, full factorization is needed.\n\
 @seealso{qr, qrupdate, qrdelete, qrshift}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
   octave_value_list retval;
 
@@ -1168,27 +1167,24 @@ Given a QR@tie{}factorization of a real 
 @var{R}@tie{}upper trapezoidal, return the QR@tie{}factorization of\n\
 @w{[A(:,1:j-1) A(:,j+1:n)]}, i.e., @var{A} with one column deleted\n\
 (if @var{orient} is @qcode{\"col\"}), or the QR@tie{}factorization of\n\
 @w{[A(1:j-1,:);A(j+1:n,:)]}, i.e., @var{A} with one row deleted (if\n\
 @var{orient} is @qcode{\"row\"}).\n\
 \n\
 The default value of @var{orient} is @qcode{\"col\"}.\n\
 \n\
-If @var{orient} is @qcode{\"col\"},\n\
-@var{j} may be an index vector\n\
+If @var{orient} is @qcode{\"col\"}, @var{j} may be an index vector\n\
 resulting in the QR@tie{}factorization of a matrix @var{B} such that\n\
-@w{A(:,@var{j}) = []} gives @var{B}.\n\
-Notice that the latter case is done as a sequence of k deletions;\n\
-thus, for k large enough, it will be both faster and more accurate to\n\
-recompute the factorization from scratch.\n\
+@w{A(:,@var{j}) = []} gives @var{B}.  Notice that the latter case is done as\n\
+a sequence of k deletions; thus, for k large enough, it will be both faster\n\
+and more accurate to recompute the factorization from scratch.\n\
 \n\
-If @var{orient} is @qcode{\"col\"},\n\
-the QR@tie{}factorization supplied may be either full\n\
-(Q is square) or economized (R is square).\n\
+If @var{orient} is @qcode{\"col\"}, the QR@tie{}factorization supplied may\n\
+be either full (Q is square) or economized (R is square).\n\
 \n\
 If @var{orient} is @qcode{\"row\"}, full factorization is needed.\n\
 @seealso{qr, qrupdate, qrinsert, qrshift}\n\
 @end deftypefn")
 {
   octave_idx_type nargin = args.length ();
   octave_value_list retval;
 
diff --git a/libinterp/dldfcn/symbfact.cc b/libinterp/dldfcn/symbfact.cc
--- a/libinterp/dldfcn/symbfact.cc
+++ b/libinterp/dldfcn/symbfact.cc
@@ -41,17 +41,18 @@ along with Octave; see the file COPYING.
 
 DEFUN_DLD (symbfact, args, nargout,
            "-*- texinfo -*-\n\
 @deftypefn  {Loadable Function} {[@var{count}, @var{h}, @var{parent}, @var{post}, @var{r}] =} symbfact (@var{S})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} symbfact (@var{S}, @var{typ})\n\
 @deftypefnx {Loadable Function} {[@dots{}] =} symbfact (@var{S}, @var{typ}, @var{mode})\n\
 \n\
 Perform a symbolic factorization analysis on the sparse matrix @var{S}.\n\
-Where\n\
+\n\
+The input variables are\n\
 \n\
 @table @var\n\
 @item S\n\
 @var{S} is a complex or real sparse matrix.\n\
 \n\
 @item typ\n\
 Is the type of the factorization and can be one of\n\
 \n\
diff --git a/libinterp/dldfcn/symrcm.cc b/libinterp/dldfcn/symrcm.cc
--- a/libinterp/dldfcn/symrcm.cc
+++ b/libinterp/dldfcn/symrcm.cc
@@ -410,25 +410,26 @@ transpose (octave_idx_type N, const octa
       }
 }
 
 // An implementation of the Cuthill-McKee algorithm.
 DEFUN_DLD (symrcm, args, ,
            "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {@var{p} =} symrcm (@var{S})\n\
 Return the symmetric reverse @nospell{Cuthill-McKee} permutation of @var{S}.\n\
+\n\
 @var{p} is a permutation vector such that\n\
-@code{@var{S}(@var{p}, @var{p})} tends to have its diagonal elements\n\
-closer to the diagonal than @var{S}.  This is a good preordering for LU\n\
-or Cholesky@tie{}factorization of matrices that come from ``long, skinny''\n\
+@code{@var{S}(@var{p}, @var{p})} tends to have its diagonal elements closer\n\
+to the diagonal than @var{S}.  This is a good preordering for LU or\n\
+Cholesky@tie{}factorization of matrices that come from ``long, skinny''\n\
 problems.  It works for both symmetric and asymmetric @var{S}.\n\
 \n\
-The algorithm represents a heuristic approach to the NP-complete\n\
-bandwidth minimization problem.  The implementation is based in the\n\
-descriptions found in\n\
+The algorithm represents a heuristic approach to the NP-complete bandwidth\n\
+minimization problem.  The implementation is based in the descriptions found\n\
+in\n\
 \n\
 @nospell{E. Cuthill, J. McKee}. @cite{Reducing the Bandwidth of Sparse\n\
 Symmetric Matrices}. Proceedings of the 24th ACM National Conference,\n\
 157--172 1969, Brandon Press, New Jersey.\n\
 \n\
 @nospell{A. George, J.W.H. Liu}. @cite{Computer Solution of Large Sparse\n\
 Positive Definite Systems}, Prentice Hall Series in Computational\n\
 Mathematics, ISBN 0-13-165274-5, 1981.\n\
diff --git a/libinterp/octave-value/ov-base.cc b/libinterp/octave-value/ov-base.cc
--- a/libinterp/octave-value/ov-base.cc
+++ b/libinterp/octave-value/ov-base.cc
@@ -1679,16 +1679,17 @@ install_base_type_conversions (void)
 
 DEFUN (sparse_auto_mutate, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} sparse_auto_mutate ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} sparse_auto_mutate (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} sparse_auto_mutate (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Octave will\n\
 automatically mutate sparse matrices to full matrices to save memory.\n\
+\n\
 For example:\n\
 \n\
 @example\n\
 @group\n\
 s = speye (3);\n\
 sparse_auto_mutate (false);\n\
 s(:, 1) = 1;\n\
 typeinfo (s)\n\
@@ -1696,17 +1697,17 @@ typeinfo (s)\n\
 sparse_auto_mutate (true);\n\
 s(1, :) = 1;\n\
 typeinfo (s)\n\
 @result{} matrix\n\
 @end group\n\
 @end example\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
-variable is changed locally for the function and any subroutines it calls.  \n\
+variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (sparse_auto_mutate);
 }
 
 /*
 %!test
diff --git a/libinterp/octave-value/ov-bool-mat.cc b/libinterp/octave-value/ov-bool-mat.cc
--- a/libinterp/octave-value/ov-bool-mat.cc
+++ b/libinterp/octave-value/ov-bool-mat.cc
@@ -556,19 +556,19 @@ octave_bool_matrix::as_mxArray (void) co
   return retval;
 }
 
 DEFUN (logical, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} logical (@var{x})\n\
 Convert the numeric object @var{x} to logical type.\n\
 \n\
-Any nonzero values will be converted to true (1) while zero values\n\
-will be converted to false (0).  The non-numeric value NaN cannot be\n\
-converted and will produce an error.\n\
+Any nonzero values will be converted to true (1) while zero values will be\n\
+converted to false (0).  The non-numeric value NaN cannot be converted and\n\
+will produce an error.\n\
 \n\
 Compatibility Note: Octave accepts complex values as input, whereas\n\
 @sc{matlab} issues an error.\n\
 @seealso{double, single, char}\n\
 @end deftypefn")
 {
   octave_value retval;
 
diff --git a/libinterp/octave-value/ov-cell.cc b/libinterp/octave-value/ov-cell.cc
--- a/libinterp/octave-value/ov-cell.cc
+++ b/libinterp/octave-value/ov-cell.cc
@@ -1296,19 +1296,19 @@ DEFUN (cell, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} cell (@var{n})\n\
 @deftypefnx {Built-in Function} {} cell (@var{m}, @var{n})\n\
 @deftypefnx {Built-in Function} {} cell (@var{m}, @var{n}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} cell ([@var{m} @var{n} @dots{}])\n\
 Create a new cell array object.\n\
 \n\
 If invoked with a single scalar integer argument, return a square\n\
-@nospell{NxN} cell array.  If invoked with two or more scalar\n\
-integer arguments, or a vector of integer values, return an array with\n\
-the given dimensions.\n\
+@nospell{NxN} cell array.  If invoked with two or more scalar integer\n\
+arguments, or a vector of integer values, return an array with the given\n\
+dimensions.\n\
 @seealso{cellstr, mat2cell, num2cell, struct2cell}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   dim_vector dims;
@@ -1352,18 +1352,18 @@ the given dimensions.\n\
     }
 
   return retval;
 }
 
 DEFUN (iscellstr, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} iscellstr (@var{cell})\n\
-Return true if every element of the cell array @var{cell} is a\n\
-character string.\n\
+Return true if every element of the cell array @var{cell} is a character\n\
+string.\n\
 @seealso{ischar}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     retval = args(0).is_cellstr ();
   else
@@ -1375,18 +1375,18 @@ character string.\n\
 // Note that since Fcellstr calls Fiscellstr, we need to have
 // Fiscellstr defined first (to provide a declaration) and also we
 // should keep it in the same file (so we don't have to provide a
 // declaration) and so we don't have to use feval to call it.
 
 DEFUN (cellstr, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{cstr} =} cellstr (@var{strmat})\n\
-Create a new cell array object from the elements of the string\n\
-array @var{strmat}.\n\
+Create a new cell array object from the elements of the string array\n\
+@var{strmat}.\n\
 \n\
 Each row of @var{strmat} becomes an element of @var{cstr}.  Any trailing\n\
 spaces in a row are deleted before conversion.\n\
 \n\
 To convert back from a cellstr to a character array use @code{char}.\n\
 @seealso{cell, char}\n\
 @end deftypefn")
 {
@@ -1415,18 +1415,19 @@ To convert back from a cellstr to a char
 
   return retval;
 }
 
 DEFUN (struct2cell, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{c} =} struct2cell (@var{s})\n\
 Create a new cell array from the objects stored in the struct object.\n\
-If @var{f} is the number of fields in the structure, the resulting\n\
-cell array will have a dimension vector corresponding to\n\
+\n\
+If @var{f} is the number of fields in the structure, the resulting cell\n\
+array will have a dimension vector corresponding to\n\
 @code{[@var{f} size(@var{s})]}.  For example:\n\
 \n\
 @example\n\
 @group\n\
 s = struct (\"name\", @{\"Peter\", \"Hannah\", \"Robert\"@},\n\
            \"age\", @{23, 16, 3@});\n\
 c = struct2cell (s)\n\
    @result{} c = @{2x1x3 Cell Array@}\n\
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -1858,20 +1858,21 @@ octave_class::exemplar_info::compare (co
   return retval;
 }
 
 DEFUN (class, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Function File} {@var{classname} =} class (@var{obj})\n\
 @deftypefnx {Function File} {} class (@var{s}, @var{id})\n\
 @deftypefnx {Function File} {} class (@var{s}, @var{id}, @var{p}, @dots{})\n\
-Return the class of the object @var{obj} or create a class with\n\
-fields from structure @var{s} and name (string) @var{id}.  Additional\n\
-arguments name a list of parent classes from which the new class is\n\
-derived.\n\
+Return the class of the object @var{obj}, or create a class with\n\
+fields from structure @var{s} and name (string) @var{id}.\n\
+\n\
+Additional arguments name a list of parent classes from which the new class\n\
+is derived.\n\
 @seealso{typeinfo, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 0)
@@ -2204,16 +2205,17 @@ is_built_in_class (const std::string& cn
   return built_in_class_names.find (cn) != built_in_class_names.end ();
 }
 
 DEFUN (superiorto, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} superiorto (@var{class_name}, @dots{})\n\
 When called from a class constructor, mark the object currently\n\
 constructed as having a higher precedence than @var{class_name}.\n\
+\n\
 More that one such class can be specified in a single call.\n\
 This function may only be called from a class constructor.\n\
 @seealso{inferiorto}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   octave_function *fcn = octave_call_stack::caller ();
@@ -2249,16 +2251,17 @@ This function may only be called from a 
   return retval;
 }
 
 DEFUN (inferiorto, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} inferiorto (@var{class_name}, @dots{})\n\
 When called from a class constructor, mark the object currently\n\
 constructed as having a lower precedence than @var{class_name}.\n\
+\n\
 More that one such class can be specified in a single call.\n\
 This function may only be called from a class constructor.\n\
 @seealso{superiorto}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   octave_function *fcn = octave_call_stack::caller ();
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -1671,17 +1671,17 @@ make_fcn_handle (const std::string& nm, 
 */
 
 DEFUN (functions, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{s} =} functions (@var{fcn_handle})\n\
 Return a structure containing information about the function handle\n\
 @var{fcn_handle}.\n\
 \n\
-The structure @var{s} always contains these 3 fields:\n\
+The structure @var{s} always contains these three fields:\n\
 \n\
 @table @asis\n\
 @item function\n\
 The function name.  For an anonymous function (no name) this will be the\n\
 actual function definition.\n\
 \n\
 @item type\n\
 Type of the function.\n\
@@ -1806,18 +1806,18 @@ particular output.\n\
     print_usage ();
 
   return retval;
 }
 
 DEFUN (func2str, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} func2str (@var{fcn_handle})\n\
-Return a string containing the name of the function referenced by\n\
-the function handle @var{fcn_handle}.\n\
+Return a string containing the name of the function referenced by the\n\
+function handle @var{fcn_handle}.\n\
 @seealso{str2func, functions}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 1)
     {
       octave_fcn_handle *fh = args(0).fcn_handle_value ();
@@ -1846,16 +1846,17 @@ the function handle @var{fcn_handle}.\n\
   return retval;
 }
 
 DEFUN (str2func, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} str2func (@var{fcn_name})\n\
 @deftypefnx {Built-in Function} {} str2func (@var{fcn_name}, \"global\")\n\
 Return a function handle constructed from the string @var{fcn_name}.\n\
+\n\
 If the optional @qcode{\"global\"} argument is passed, locally visible\n\
 functions are ignored in the lookup.\n\
 @seealso{func2str, inline}\n\
 @end deftypefn")
 {
   octave_value retval;
   int nargin = args.length ();
 
diff --git a/libinterp/octave-value/ov-fcn-inline.cc b/libinterp/octave-value/ov-fcn-inline.cc
--- a/libinterp/octave-value/ov-fcn-inline.cc
+++ b/libinterp/octave-value/ov-fcn-inline.cc
@@ -649,27 +649,26 @@ octave_fcn_inline::convert_to_str_intern
 
 DEFUNX ("inline", Finline, args, ,
         "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} inline (@var{str})\n\
 @deftypefnx {Built-in Function} {} inline (@var{str}, @var{arg1}, @dots{})\n\
 @deftypefnx {Built-in Function} {} inline (@var{str}, @var{n})\n\
 Create an inline function from the character string @var{str}.\n\
 \n\
-If called with a single argument, the arguments of the generated\n\
-function are extracted from the function itself.  The generated\n\
-function arguments will then be in alphabetical order.  It should\n\
-be noted that i, and j are ignored as arguments due to the\n\
-ambiguity between their use as a variable or their use as an inbuilt\n\
-constant.  All arguments followed by a parenthesis are considered\n\
-to be functions.  If no arguments are found, a function taking a single\n\
-argument named @code{x} will be created.\n\
+If called with a single argument, the arguments of the generated function\n\
+are extracted from the function itself.  The generated function arguments\n\
+will then be in alphabetical order.  It should be noted that i and j are\n\
+ignored as arguments due to the ambiguity between their use as a variable or\n\
+their use as an built-in constant.  All arguments followed by a parenthesis\n\
+are considered to be functions.  If no arguments are found, a function\n\
+taking a single argument named @code{x} will be created.\n\
 \n\
-If the second and subsequent arguments are character strings,\n\
-they are the names of the arguments of the function.\n\
+If the second and subsequent arguments are character strings, they are the\n\
+names of the arguments of the function.\n\
 \n\
 If the second argument is an integer @var{n}, the arguments are\n\
 @qcode{\"x\"}, @qcode{\"P1\"}, @dots{}, @qcode{\"P@var{N}\"}.\n\
 \n\
 Programming Note: The use of @code{inline} is discouraged and it may be\n\
 removed from a future version of Octave.  The preferred way to create\n\
 functions from strings is through the use of anonymous functions\n\
 (@pxref{Anonymous Functions}) or @code{str2func}.\n\
@@ -899,18 +898,18 @@ Note that @code{char (@var{fun})} is equ
 %!error formula ()
 %!error formula (1, 2)
 %!error <FUN must be an inline function> formula (1)
 */
 
 DEFUN (argnames, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} argnames (@var{fun})\n\
-Return a cell array of character strings containing the names of\n\
-the arguments of the inline function @var{fun}.\n\
+Return a cell array of character strings containing the names of the\n\
+arguments of the inline function @var{fun}.\n\
 @seealso{inline, formula, vectorize}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin == 1)
@@ -946,23 +945,21 @@ the arguments of the inline function @va
 %!error argnames ()
 %!error argnames (1, 2)
 %!error <FUN must be an inline function> argnames (1)
 */
 
 DEFUN (vectorize, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} vectorize (@var{fun})\n\
-Create a vectorized version of the inline function @var{fun}\n\
-by replacing all occurrences of @code{*}, @code{/}, etc., with\n\
-@code{.*}, @code{./}, etc.\n\
+Create a vectorized version of the inline function @var{fun} by replacing\n\
+all occurrences of @code{*}, @code{/}, etc., with @code{.*}, @code{./}, etc.\n\
 \n\
-This may be useful, for example, when using inline functions with\n\
-numerical integration or optimization where a vector-valued function\n\
-is expected.\n\
+This may be useful, for example, when using inline functions with numerical\n\
+integration or optimization where a vector-valued function is expected.\n\
 \n\
 @example\n\
 @group\n\
 fcn = vectorize (inline (\"x^2 - 1\"))\n\
    @result{} fcn = f(x) = x.^2 - 1\n\
 quadv (fcn, 0, 3)\n\
    @result{} 6\n\
 @end group\n\
diff --git a/libinterp/octave-value/ov-java.cc b/libinterp/octave-value/ov-java.cc
--- a/libinterp/octave-value/ov-java.cc
+++ b/libinterp/octave-value/ov-java.cc
@@ -2036,18 +2036,19 @@ octave_java::do_java_set (JNIEnv* jni_en
 
 #endif  // endif on HAVE_JAVA
 
 // DEFUN blocks below must be outside of HAVE_JAVA block so that
 // documentation strings are always available, even when functions are not.
 
 DEFUN (__java_init__, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} java_init ()\n\
+@deftypefn {Built-in Function} {} __java_init__ ()\n\
 Internal function used @strong{only} when debugging Java interface.\n\
+\n\
 Function will directly call initialize_java() to create an instance of a JVM.\n\
 @end deftypefn")
 {
 
 #ifdef HAVE_JAVA
   octave_value retval;
 
   retval = 0;
@@ -2061,18 +2062,19 @@ Function will directly call initialize_j
 #else
   error ("__java_init__: Octave was not compiled with Java interface");
   return octave_value ();
 #endif
 }
 
 DEFUN (__java_exit__, , ,
        "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} java_exit ()\n\
+@deftypefn {Built-in Function} {} __java_exit__ ()\n\
 Internal function used @strong{only} when debugging Java interface.\n\
+\n\
 Function will directly call terminate_jvm() to destroy the current JVM\n\
 instance.\n\
 @end deftypefn")
 {
 #ifdef HAVE_JAVA
   terminate_jvm ();
 #else
   error ("__java_init__: Octave was not compiled with Java interface");
@@ -2083,18 +2085,18 @@ instance.\n\
 
 DEFUN (javaObject, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{jobj} =} javaObject (@var{classname})\n\
 @deftypefnx {Built-in Function} {@var{jobj} =} javaObject (@var{classname}, @var{arg1}, @dots{})\n\
 Create a Java object of class @var{classsname}, by calling the class\n\
 constructor with the arguments @var{arg1}, @dots{}\n\
 \n\
-The first example below creates an uninitialized object,\n\
-while the second example supplies an initial argument to the constructor.\n\
+The first example below creates an uninitialized object, while the second\n\
+example supplies an initial argument to the constructor.\n\
 \n\
 @example\n\
 @group\n\
 x = javaObject (\"java.lang.StringBuffer\")\n\
 x = javaObject (\"java.lang.StringBuffer\", \"Initial string\")\n\
 @end group\n\
 @end example\n\
 \n\
@@ -2143,31 +2145,34 @@ x = javaObject (\"java.lang.StringBuffer
 %! assert (javaObject ("java.lang.Short", 40000).doubleValue < 0);
 */
 
 DEFUN (javaMethod, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{ret} =} javaMethod (@var{methodname}, @var{obj})\n\
 @deftypefnx {Built-in Function} {@var{ret} =} javaMethod (@var{methodname}, @var{obj}, @var{arg1}, @dots{})\n\
 Invoke the method @var{methodname} on the Java object @var{obj} with the\n\
-arguments @var{arg1}, @dots{}  For static methods, @var{obj} can be a string\n\
-representing the fully qualified name of the corresponding class.  The\n\
-function returns the result of the method invocation.\n\
+arguments @var{arg1}, @dots{}.\n\
+\n\
+For static methods, @var{obj} can be a string representing the fully\n\
+qualified name of the corresponding class.\n\
 \n\
 When @var{obj} is a regular Java object, structure-like indexing can be\n\
 used as a shortcut syntax.  For instance, the two following statements are\n\
 equivalent\n\
 \n\
 @example\n\
 @group\n\
   ret = javaMethod (\"method1\", x, 1.0, \"a string\")\n\
   ret = x.method1 (1.0, \"a string\")\n\
 @end group\n\
 @end example\n\
 \n\
+@code{javaMethod} returns the result of the method invocation.\n\
+\n\
 @seealso{methods, javaObject}\n\
 @end deftypefn")
 {
 #ifdef HAVE_JAVA
   octave_value retval;
 
   initialize_java ();
 
@@ -2217,22 +2222,23 @@ equivalent\n\
 %! ## Check for valid first two Java version numbers
 %! jver = strsplit (javaMethod ("getProperty", "java.lang.System", "java.version"), ".");
 %! assert (isfinite (str2double (jver{1})) && isfinite (str2double (jver{2})));
 */
 
 DEFUN (__java_get__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{val} =} __java_get__ (@var{obj}, @var{name})\n\
-Get the value of the field @var{name} of the Java object @var{obj}.  For\n\
-static fields, @var{obj} can be a string representing the fully qualified\n\
+Get the value of the field @var{name} of the Java object @var{obj}.\n\
+\n\
+For static fields, @var{obj} can be a string representing the fully qualified\n\
 name of the corresponding class.\n\
 \n\
-When @var{obj} is a regular Java object, structure-like indexing can be\n\
-used as a shortcut syntax.  For instance, the two following statements are\n\
+When @var{obj} is a regular Java object, structure-like indexing can be used\n\
+as a shortcut syntax.  For instance, the two following statements are\n\
 equivalent\n\
 \n\
 @example\n\
 @group\n\
   __java_get__ (x, \"field1\")\n\
   x.field1\n\
 @end group\n\
 @end example\n\
@@ -2281,18 +2287,20 @@ equivalent\n\
   return octave_value ();
 #endif
 }
 
 DEFUN (__java_set__, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{obj} =} __java_set__ (@var{obj}, @var{name}, @var{val})\n\
 Set the value of the field @var{name} of the Java object @var{obj} to\n\
-@var{val}.  For static fields, @var{obj} can be a string representing the\n\
-fully qualified named of the corresponding Java class.\n\
+@var{val}.\n\
+\n\
+For static fields, @var{obj} can be a string representing the fully\n\
+qualified named of the corresponding Java class.\n\
 \n\
 When @var{obj} is a regular Java object, structure-like indexing can be\n\
 used as a shortcut syntax.  For instance, the two following statements are\n\
 equivalent\n\
 \n\
 @example\n\
 @group\n\
   __java_set__ (x, \"field1\", val)\n\
@@ -2382,20 +2390,22 @@ Undocumented internal function.\n\
 }
 
 DEFUN (java_matrix_autoconversion, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} java_matrix_autoconversion ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} java_matrix_autoconversion (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} java_matrix_autoconversion (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether Java arrays are\n\
-automatically converted to Octave matrices.  The default value is false.\n\
+automatically converted to Octave matrices.\n\
+\n\
+The default value is false.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
-variable is changed locally for the function and any subroutines it calls.  \n\
+variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{java_unsigned_autoconversion, debug_java}\n\
 @end deftypefn")
 {
 #ifdef HAVE_JAVA
   return SET_INTERNAL_VARIABLE (java_matrix_autoconversion);
 #else
   error ("java_matrix_autoconversion: Octave was not compiled with Java interface");
@@ -2404,22 +2414,23 @@ The original variable value is restored 
 }
 
 DEFUN (java_unsigned_autoconversion, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} java_unsigned_autoconversion ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} java_unsigned_autoconversion (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} java_unsigned_autoconversion (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls how integer classes are\n\
-converted when @code{java_matrix_autoconversion} is enabled.  When enabled,\n\
-Java arrays of class Byte or Integer are converted to matrices of class\n\
-uint8 or uint32 respectively.  The default value is true.\n\
+converted when @code{java_matrix_autoconversion} is enabled.\n\
+\n\
+When enabled, Java arrays of class Byte or Integer are converted to matrices\n\
+of class uint8 or uint32 respectively.  The default value is true.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
-variable is changed locally for the function and any subroutines it calls.  \n\
+variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{java_matrix_autoconversion, debug_java}\n\
 @end deftypefn")
 {
 #ifdef HAVE_JAVA
   return SET_INTERNAL_VARIABLE (java_unsigned_autoconversion);
 #else
   error ("java_unsigned_autoconversion: Octave was not compiled with Java interface");
@@ -2432,17 +2443,17 @@ DEFUN (debug_java, args, nargout,
 @deftypefn  {Built-in Function} {@var{val} =} debug_java ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} debug_java (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} debug_java (@var{new_val}, \"local\")\n\
 Query or set the internal variable that determines whether extra debugging\n\
 information regarding the initialization of the JVM and any Java exceptions\n\
 is printed.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
-variable is changed locally for the function and any subroutines it calls.  \n\
+variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{java_matrix_autoconversion, java_unsigned_autoconversion}\n\
 @end deftypefn")
 {
 #ifdef HAVE_JAVA
   return SET_INTERNAL_VARIABLE (debug_java);
 #else
   error ("debug_java: Octave was not compiled with Java interface");
diff --git a/libinterp/octave-value/ov-null-mat.cc b/libinterp/octave-value/ov-null-mat.cc
--- a/libinterp/octave-value/ov-null-mat.cc
+++ b/libinterp/octave-value/ov-null-mat.cc
@@ -92,19 +92,21 @@ octave_null_sq_str::numeric_conversion_f
            (default_null_sq_str_numeric_conversion_function,
             octave_char_matrix_sq_str::static_type_id ());
 }
 
 DEFUN (isnull, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} isnull (@var{x})\n\
 Return true if @var{x} is a special null matrix, string, or single quoted\n\
-string.  Indexed assignment with such a value on the right-hand side should\n\
-delete array elements.  This function should be used when overloading\n\
-indexed assignment for user-defined classes instead of @code{isempty}, to\n\
+string.\n\
+\n\
+Indexed assignment with such a value on the right-hand side should delete\n\
+array elements.  This function should be used when overloading indexed\n\
+assignment for user-defined classes instead of @code{isempty}, to\n\
 distinguish the cases:\n\
 \n\
 @table @asis\n\
 @item @code{A(I) = []}\n\
 This should delete elements if @code{I} is nonempty.\n\
 \n\
 @item @code{X = []; A(I) = X}\n\
 This should give an error if @code{I} is nonempty.\n\
diff --git a/libinterp/octave-value/ov-oncleanup.cc b/libinterp/octave-value/ov-oncleanup.cc
--- a/libinterp/octave-value/ov-oncleanup.cc
+++ b/libinterp/octave-value/ov-oncleanup.cc
@@ -179,16 +179,17 @@ octave_oncleanup::print_raw (std::ostrea
     fcn.print_raw (os, pr_as_read_syntax);
   os << ")";
 }
 
 DEFUN (onCleanup, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{obj} =} onCleanup (@var{function})\n\
 Create a special object that executes a given function upon destruction.\n\
+\n\
 If the object is copied to multiple variables (or cell or struct array\n\
 elements) or returned from a function, @var{function} will be executed after\n\
 clearing the last copy of the object.  Note that if multiple local onCleanup\n\
 variables are created, the order in which they are called is unspecified.\n\
 For similar functionality @xref{The unwind_protect Statement}.\n\
 @end deftypefn")
 {
   octave_value retval;
diff --git a/libinterp/octave-value/ov-range.cc b/libinterp/octave-value/ov-range.cc
--- a/libinterp/octave-value/ov-range.cc
+++ b/libinterp/octave-value/ov-range.cc
@@ -698,22 +698,24 @@ octave_range::fast_elem_extract (octave_
 }
 
 DEFUN (allow_noninteger_range_as_index, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} allow_noninteger_range_as_index ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} allow_noninteger_range_as_index (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} allow_noninteger_range_as_index (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether non-integer\n\
-ranges are allowed as indices.  This might be useful for @sc{matlab}\n\
-compatibility; however, it is still not entirely compatible because\n\
-@sc{matlab} treats the range expression differently in different contexts.\n\
+ranges are allowed as indices.\n\
+\n\
+This might be useful for @sc{matlab} compatibility; however, it is still not\n\
+entirely compatible because @sc{matlab} treats the range expression\n\
+differently in different contexts.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
-variable is changed locally for the function and any subroutines it calls.  \n\
+variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   static bool warned = false;
   if (! warned)
     {
       warned = true;
       warning_with_id ("Octave:deprecated-function",
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -1779,26 +1779,27 @@ octave_scalar_struct::fast_elem_insert_s
 }
 
 DEFUN (struct, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{s} =} struct ()\n\
 @deftypefnx {Built-in Function} {@var{s} =} struct (@var{field1}, @var{value1}, @var{field2}, @var{value2}, @dots{})\n\
 @deftypefnx {Built-in Function} {@var{s} =} struct (@var{obj})\n\
 \n\
-Create a scalar or array structure and initialize its values.  The\n\
-@var{field1}, @var{field2}, @dots{} variables are strings specifying the\n\
-names of the fields and the @var{value1}, @var{value2}, @dots{}\n\
-variables can be of any type.\n\
+Create a scalar or array structure and initialize its values.\n\
+\n\
+The @var{field1}, @var{field2}, @dots{} variables are strings specifying the\n\
+names of the fields and the @var{value1}, @var{value2}, @dots{} variables\n\
+can be of any type.\n\
 \n\
-If the values are cell arrays, create a structure array and initialize\n\
-its values.  The dimensions of each cell array of values must match.\n\
-Singleton cells and non-cell values are repeated so that they fill\n\
-the entire array.  If the cells are empty, create an empty structure\n\
-array with the specified field names.\n\
+If the values are cell arrays, create a structure array and initialize its\n\
+values.  The dimensions of each cell array of values must match.  Singleton\n\
+cells and non-cell values are repeated so that they fill the entire array.  \n\
+If the cells are empty, create an empty structure array with the specified\n\
+field names.\n\
 \n\
 If the argument is an object, return the underlying struct.\n\
 \n\
 Observe that the syntax is optimized for struct @strong{arrays}.  Consider\n\
 the following examples:\n\
 \n\
 @example\n\
 @group\n\
@@ -1819,17 +1820,17 @@ struct (\"foo\", @{1, 2, 3@})\n\
     foo\n\
 \n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 The first case is an ordinary scalar struct---one field, one value.  The\n\
 second produces an empty struct array with one field and no values, since\n\
-s being passed an empty cell array of struct array values.  When the value is\n\
+being passed an empty cell array of struct array values.  When the value is\n\
 a cell array containing a single entry, this becomes a scalar struct with\n\
 that single entry as the value of the field.  That single entry happens\n\
 to be an empty cell array.\n\
 \n\
 Finally, if the value is a non-scalar cell array, then @code{struct}\n\
 produces a struct @strong{array}.\n\
 @seealso{cell2struct, fieldnames, getfield, setfield, rmfield, isfield, orderfields, isstruct, structfun}\n\
 @end deftypefn")
@@ -2117,20 +2118,22 @@ Return the number of fields of the struc
 %!assert (isfield (struct ("a", "b"), "a "), false)
 %!assert (isfield (struct ("a", 1, "b", 2), {"a", "c"}), [true, false])
 */
 
 DEFUN (cell2struct, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} cell2struct (@var{cell}, @var{fields})\n\
 @deftypefnx {Built-in Function} {} cell2struct (@var{cell}, @var{fields}, @var{dim})\n\
-Convert @var{cell} to a structure.  The number of fields in @var{fields}\n\
-must match the number of elements in @var{cell} along dimension @var{dim},\n\
-that is @code{numel (@var{fields}) == size (@var{cell}, @var{dim})}.\n\
-If @var{dim} is omitted, a value of 1 is assumed.\n\
+Convert @var{cell} to a structure.\n\
+\n\
+The number of fields in @var{fields} must match the number of elements in\n\
+@var{cell} along dimension @var{dim}, that is\n\
+@code{numel (@var{fields}) == size (@var{cell}, @var{dim})}.  If @var{dim}\n\
+is omitted, a value of 1 is assumed.\n\
 \n\
 @example\n\
 @group\n\
 A = cell2struct (@{\"Peter\", \"Hannah\", \"Robert\";\n\
                    185, 170, 168@},\n\
                  @{\"Name\",\"Height\"@}, 1);\n\
 A(1)\n\
    @result{}\n\
@@ -2324,38 +2327,38 @@ DEFUN (struct_levels_to_print, args, nar
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} struct_levels_to_print ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} struct_levels_to_print (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} struct_levels_to_print (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies the number of\n\
 structure levels to display.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
-variable is changed locally for the function and any subroutines it calls.  \n\
+variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{print_struct_array_contents}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE_WITH_LIMITS (struct_levels_to_print, -1,
                                             std::numeric_limits<int>::max ());
 }
 
 DEFUN (print_struct_array_contents, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} print_struct_array_contents ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} print_struct_array_contents (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} print_struct_array_contents (@var{new_val}, \"local\")\n\
 Query or set the internal variable that specifies whether to print struct\n\
 array contents.\n\
 \n\
-If true, values of struct array elements are printed.\n\
-This variable does not affect scalar structures whose elements are always\n\
-printed.  In both cases, however, printing will be limited to\n\
-the number of levels specified by @var{struct_levels_to_print}.\n\
+If true, values of struct array elements are printed.  This variable does\n\
+not affect scalar structures whose elements are always printed.  In both\n\
+cases, however, printing will be limited to the number of levels specified\n\
+by @var{struct_levels_to_print}.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
-variable is changed locally for the function and any subroutines it calls.  \n\
+variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{struct_levels_to_print}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (print_struct_array_contents);
 }
diff --git a/libinterp/octave-value/ov-typeinfo.cc b/libinterp/octave-value/ov-typeinfo.cc
--- a/libinterp/octave-value/ov-typeinfo.cc
+++ b/libinterp/octave-value/ov-typeinfo.cc
@@ -609,18 +609,19 @@ octave_value_typeinfo::do_installed_type
   return retval;
 }
 
 DEFUN (typeinfo, args, ,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} typeinfo ()\n\
 @deftypefnx {Built-in Function} {} typeinfo (@var{expr})\n\
 \n\
-Return the type of the expression @var{expr}, as a string.  If\n\
-@var{expr} is omitted, return a cell array of strings containing all the\n\
+Return the type of the expression @var{expr}, as a string.\n\
+\n\
+If @var{expr} is omitted, return a cell array of strings containing all the\n\
 currently installed data types.\n\
 @seealso{class, isa}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -1044,17 +1044,17 @@ DEFUN (optimize_subsasgn_calls, args, na
 @deftypefnx {Built-in Function} {@var{old_val} =} optimize_subsasgn_calls (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} optimize_subsasgn_calls (@var{new_val}, \"local\")\n\
 Query or set the internal flag for subsasgn method call optimizations.\n\
 \n\
 If true, Octave will attempt to eliminate the redundant copying when calling\n\
 the subsasgn method of a user-defined class.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
-variable is changed locally for the function and any subroutines it calls.  \n\
+variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (optimize_subsasgn_calls);
 }
 
 static bool val_in_table (const Matrix& table, double val)
 {
diff --git a/libinterp/octave-value/ov.cc b/libinterp/octave-value/ov.cc
--- a/libinterp/octave-value/ov.cc
+++ b/libinterp/octave-value/ov.cc
@@ -3019,27 +3019,25 @@ decode_subscripts (const char* name, con
   else
     error ("%s: second argument must be a structure with fields 'type' and 'subs'",
            name);
 }
 
 DEFUN (subsref, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} subsref (@var{val}, @var{idx})\n\
-Perform the subscripted element selection operation according to\n\
-the subscript specified by @var{idx}.\n\
+Perform the subscripted element selection operation according to the\n\
+subscript specified by @var{idx}.\n\
 \n\
-The subscript @var{idx} is expected to be a structure array with\n\
-fields @samp{type} and @samp{subs}.  Valid values for @samp{type}\n\
-are @samp{\"()\"}, @samp{\"@{@}\"}, and @samp{\".\"}.\n\
-The @samp{subs} field may be either @samp{\":\"} or a cell array\n\
-of index values.\n\
+The subscript @var{idx} is expected to be a structure array with fields\n\
+@samp{type} and @samp{subs}.  Valid values for @samp{type} are\n\
+@samp{\"()\"}, @samp{\"@{@}\"}, and @samp{\".\"}.  The @samp{subs} field may\n\
+be either @samp{\":\"} or a cell array of index values.\n\
 \n\
-The following example shows how to extract the first two columns of\n\
-a matrix\n\
+The following example shows how to extract the first two columns of a matrix\n\
 \n\
 @example\n\
 @group\n\
 val = magic (3)\n\
     @result{} val = [ 8   1   6\n\
                3   5   7\n\
                4   9   2 ]\n\
 idx.type = \"()\";\n\
@@ -3049,18 +3047,18 @@ subsref (val, idx)\n\
           3   5\n\
           4   9 ]\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 Note that this is the same as writing @code{val(:,1:2)}.\n\
 \n\
-If @var{idx} is an empty structure array with fields @samp{type}\n\
-and @samp{subs}, return @var{val}.\n\
+If @var{idx} is an empty structure array with fields @samp{type} and\n\
+@samp{subs}, return @var{val}.\n\
 @seealso{subsasgn, substruct}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   if (args.length () == 2)
     {
       std::string type;
@@ -3082,44 +3080,43 @@ and @samp{subs}, return @var{val}.\n\
     print_usage ();
 
   return retval;
 }
 
 DEFUN (subsasgn, args, ,
        "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} subsasgn (@var{val}, @var{idx}, @var{rhs})\n\
-Perform the subscripted assignment operation according to\n\
-the subscript specified by @var{idx}.\n\
+Perform the subscripted assignment operation according to the subscript\n\
+specified by @var{idx}.\n\
 \n\
-The subscript @var{idx} is expected to be a structure array with\n\
-fields @samp{type} and @samp{subs}.  Valid values for @samp{type}\n\
-are @samp{\"()\"}, @samp{\"@{@}\"}, and @samp{\".\"}.\n\
-The @samp{subs} field may be either @samp{\":\"} or a cell array\n\
-of index values.\n\
+The subscript @var{idx} is expected to be a structure array with fields\n\
+@samp{type} and @samp{subs}.  Valid values for @samp{type} are\n\
+@samp{\"()\"}, @samp{\"@{@}\"}, and @samp{\".\"}.  The @samp{subs} field may\n\
+be either @samp{\":\"} or a cell array of index values.\n\
 \n\
-The following example shows how to set the two first columns of a\n\
-3-by-3 matrix to zero.\n\
+The following example shows how to set the two first columns of a 3-by-3\n\
+matrix to zero.\n\
 \n\
 @example\n\
 @group\n\
 val = magic (3);\n\
 idx.type = \"()\";\n\
 idx.subs = @{\":\", 1:2@};\n\
 subsasgn (val, idx, 0)\n\
      @result{}  [ 0   0   6\n\
            0   0   7\n\
            0   0   2 ]\n\
 @end group\n\
 @end example\n\
 \n\
 Note that this is the same as writing @code{val(:,1:2) = 0}.\n\
 \n\
-If @var{idx} is an empty structure array with fields @samp{type}\n\
-and @samp{subs}, return @var{rhs}.\n\
+If @var{idx} is an empty structure array with fields @samp{type} and\n\
+@samp{subs}, return @var{rhs}.\n\
 @seealso{subsref, substruct}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 3)
     {
       std::string type;
@@ -3274,19 +3271,20 @@ Return true if @var{x} is a double-quote
 */
 
 DEFUN (disable_permutation_matrix, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} disable_permutation_matrix ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} disable_permutation_matrix (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} disable_permutation_matrix (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether permutation\n\
-matrices are stored in a special space-efficient format.  The default\n\
-value is true.  If this option is disabled Octave will store permutation\n\
-matrices as full matrices.\n\
+matrices are stored in a special space-efficient format.\n\
+\n\
+The default value is true.  If this option is disabled Octave will store\n\
+permutation matrices as full matrices.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{disable_range, disable_diagonal_matrix}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (disable_permutation_matrix);
@@ -3303,19 +3301,20 @@ The original variable value is restored 
 */
 
 DEFUN (disable_diagonal_matrix, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} disable_diagonal_matrix ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} disable_diagonal_matrix (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} disable_diagonal_matrix (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether diagonal\n\
-matrices are stored in a special space-efficient format.  The default\n\
-value is true.  If this option is disabled Octave will store diagonal\n\
-matrices as full matrices.\n\
+matrices are stored in a special space-efficient format.\n\
+\n\
+The default value is true.  If this option is disabled Octave will store\n\
+diagonal matrices as full matrices.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{disable_range, disable_permutation_matrix}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (disable_diagonal_matrix);
@@ -3346,18 +3345,20 @@ The original variable value is restored 
 */
 
 DEFUN (disable_range, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} disable_range ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} disable_range (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} disable_range (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether ranges are stored\n\
-in a special space-efficient format.  The default value is true.  If this\n\
-option is disabled Octave will store ranges as full matrices.\n\
+in a special space-efficient format.\n\
+\n\
+The default value is true.  If this option is disabled Octave will store\n\
+ranges as full matrices.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @seealso{disable_diagonal_matrix, disable_permutation_matrix}\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (disable_range);
diff --git a/libinterp/parse-tree/lex.ll b/libinterp/parse-tree/lex.ll
--- a/libinterp/parse-tree/lex.ll
+++ b/libinterp/parse-tree/lex.ll
@@ -1894,18 +1894,19 @@ is_keyword (const std::string& s)
   return (octave_kw_hash::in_word_set (s.c_str (), s.length ()) != 0
           && ! (s == "set" || s == "get"));
 }
 
 DEFUN (iskeyword, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} iskeyword ()\n\
 @deftypefnx {Built-in Function} {} iskeyword (@var{name})\n\
-Return true if @var{name} is an Octave keyword.  If @var{name}\n\
-is omitted, return a list of keywords.\n\
+Return true if @var{name} is an Octave keyword.\n\
+\n\
+If @var{name} is omitted, return a list of keywords.\n\
 @seealso{isvarname, exist}\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int argc = args.length () + 1;
 
   string_vector argv = args.make_argv ("iskeyword");
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -4311,25 +4311,25 @@ load_fcn_from_file (const std::string& f
 
 DEFUN (autoload, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{autoload_map} =} autoload ()\n\
 @deftypefnx {Built-in Function} {} autoload (@var{function}, @var{file})\n\
 @deftypefnx {Built-in Function} {} autoload (@dots{}, \"remove\")\n\
 Define @var{function} to autoload from @var{file}.\n\
 \n\
-The second argument, @var{file}, should be an absolute file name or\n\
-a file name in the same directory as the function or script from which\n\
-the autoload command was run.  @var{file} @emph{should not} depend on the\n\
-Octave load path.\n\
+The second argument, @var{file}, should be an absolute file name or a file\n\
+name in the same directory as the function or script from which the autoload\n\
+command was run.  @var{file} @emph{should not} depend on the Octave load\n\
+path.\n\
 \n\
-Normally, calls to @code{autoload} appear in PKG_ADD script files that\n\
-are evaluated when a directory is added to Octave's load path.  To\n\
-avoid having to hardcode directory names in @var{file}, if @var{file}\n\
-is in the same directory as the PKG_ADD script then\n\
+Normally, calls to @code{autoload} appear in PKG_ADD script files that are\n\
+evaluated when a directory is added to Octave's load path.  To avoid having\n\
+to hardcode directory names in @var{file}, if @var{file} is in the same\n\
+directory as the PKG_ADD script then\n\
 \n\
 @example\n\
 autoload (\"foo\", \"bar.oct\");\n\
 @end example\n\
 \n\
 @noindent\n\
 will load the function @code{foo} from the file @code{bar.oct}.  The above\n\
 usage when @code{bar.oct} is not in the same directory, or usages such as\n\
@@ -4538,20 +4538,23 @@ source_file (const std::string& file_nam
 
 DEFUN (mfilename, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} mfilename ()\n\
 @deftypefnx {Built-in Function} {} mfilename (\"fullpath\")\n\
 @deftypefnx {Built-in Function} {} mfilename (\"fullpathext\")\n\
 Return the name of the currently executing file.\n\
 \n\
-When called from outside an m-file return the empty string.  Given the\n\
-argument @qcode{\"fullpath\"}, include the directory part of the file name,\n\
-but not the extension.  Given the argument @qcode{\"fullpathext\"}, include\n\
-the directory part of the file name and the extension.\n\
+When called from outside an m-file return the empty string.\n\
+\n\
+Given the argument @qcode{\"fullpath\"}, include the directory part of the\n\
+file name, but not the extension.\n\
+\n\
+Given the argument @qcode{\"fullpathext\"}, include the directory part of\n\
+the file name and the extension.\n\
 @end deftypefn")
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   if (nargin > 1)
     {
@@ -4727,34 +4730,35 @@ feval (const octave_value_list& args, in
     }
 
   return retval;
 }
 
 DEFUN (feval, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} feval (@var{name}, @dots{})\n\
-Evaluate the function named @var{name}.  Any arguments after the first\n\
-are passed as inputs to the named function.  For example,\n\
+Evaluate the function named @var{name}.\n\
+\n\
+Any arguments after the first are passed as inputs to the named function.\n\
+For example,\n\
 \n\
 @example\n\
 @group\n\
 feval (\"acos\", -1)\n\
      @result{} 3.1416\n\
 @end group\n\
 @end example\n\
 \n\
 @noindent\n\
 calls the function @code{acos} with the argument @samp{-1}.\n\
 \n\
-The function @code{feval} can also be used with function handles of\n\
-any sort (@pxref{Function Handles}).  Historically, @code{feval} was\n\
-the only way to call user-supplied functions in strings, but\n\
-function handles are now preferred due to the cleaner syntax they\n\
-offer.  For example,\n\
+The function @code{feval} can also be used with function handles of any sort\n\
+(@pxref{Function Handles}).  Historically, @code{feval} was the only way to\n\
+call user-supplied functions in strings, but function handles are now\n\
+preferred due to the cleaner syntax they offer.  For example,\n\
 \n\
 @example\n\
 @group\n\
 @var{f} = @@exp;\n\
 feval (@var{f}, 1)\n\
     @result{} 2.7183\n\
 @var{f} (1)\n\
     @result{} 2.7183\n\
@@ -4778,22 +4782,22 @@ instead.\n\
     print_usage ();
 
   return retval;
 }
 
 DEFUN (builtin, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@dots{}] =} builtin (@var{f}, @dots{})\n\
-Call the base function @var{f} even if @var{f} is overloaded to\n\
-another function for the given type signature.\n\
+Call the base function @var{f} even if @var{f} is overloaded to another\n\
+function for the given type signature.\n\
 \n\
-This is normally useful when doing object-oriented programming and there\n\
-is a requirement to call one of Octave's base functions rather than\n\
-the overloaded one of a new class.\n\
+This is normally useful when doing object-oriented programming and there is\n\
+a requirement to call one of Octave's base functions rather than the\n\
+overloaded one of a new class.\n\
 \n\
 A trivial example which redefines the @code{sin} function to be the\n\
 @code{cos} function shows how @code{builtin} works.\n\
 \n\
 @example\n\
 @group\n\
 sin (0)\n\
   @result{} 0\n\
@@ -4940,19 +4944,22 @@ cleanup_statement_list (tree_statement_l
     }
 }
 
 DEFUN (eval, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} eval (@var{try})\n\
 @deftypefnx {Built-in Function} {} eval (@var{try}, @var{catch})\n\
 Parse the string @var{try} and evaluate it as if it were an Octave\n\
-program.  If that fails, evaluate the optional string @var{catch}.\n\
-The string @var{try} is evaluated in the current context,\n\
-so any results remain available after @code{eval} returns.\n\
+program.\n\
+\n\
+If execution fails, evaluate the optional string @var{catch}.\n\
+\n\
+The string @var{try} is evaluated in the current context, so any results\n\
+remain available after @code{eval} returns.\n\
 \n\
 The following example creates the variable @var{A} with the approximate\n\
 value of 3.1416 in the current workspace.\n\
 \n\
 @example\n\
 eval (\"A = acos(-1);\");\n\
 @end example\n\
 \n\
@@ -5108,19 +5115,18 @@ may be either @qcode{\"base\"} or @qcode
 
   return retval;
 }
 
 DEFUN (evalin, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} evalin (@var{context}, @var{try})\n\
 @deftypefnx {Built-in Function} {} evalin (@var{context}, @var{try}, @var{catch})\n\
-Like @code{eval}, except that the expressions are evaluated in the\n\
-context @var{context}, which may be either @qcode{\"caller\"} or\n\
-@qcode{\"base\"}.\n\
+Like @code{eval}, except that the expressions are evaluated in the context\n\
+@var{context}, which may be either @qcode{\"caller\"} or @qcode{\"base\"}.\n\
 @seealso{eval, assignin}\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
 
   if (nargin > 1)
diff --git a/libinterp/parse-tree/pt-binop.cc b/libinterp/parse-tree/pt-binop.cc
--- a/libinterp/parse-tree/pt-binop.cc
+++ b/libinterp/parse-tree/pt-binop.cc
@@ -303,17 +303,17 @@ conditions of if or while statements.\n\
 \n\
 This feature is only provided for compatibility with @sc{matlab} and should\n\
 not be used unless you are porting old code that relies on this feature.\n\
 \n\
 To obtain short-circuit behavior for logical expressions in new programs,\n\
 you should always use the @samp{&&} and @samp{||} operators.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
-variable is changed locally for the function and any subroutines it calls.  \n\
+variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   static bool warned = false;
   if (! warned)
     {
       warned = true;
       warning_with_id ("Octave:deprecated-function",
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -1254,18 +1254,20 @@ tree_evaluator::do_keyboard (const octav
 }
 
 DEFUN (max_recursion_depth, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} max_recursion_depth ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} max_recursion_depth (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} max_recursion_depth (@var{new_val}, \"local\")\n\
 Query or set the internal limit on the number of times a function may\n\
-be called recursively.  If the limit is exceeded, an error message is\n\
-printed and control returns to the top level.\n\
+be called recursively.\n\
+\n\
+If the limit is exceeded, an error message is printed and control returns to\n\
+the top level.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (max_recursion_depth);
 }
@@ -1283,19 +1285,21 @@ The original variable value is restored 
 */
 
 DEFUN (silent_functions, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} silent_functions ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} silent_functions (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} silent_functions (@var{new_val}, \"local\")\n\
 Query or set the internal variable that controls whether internal\n\
-output from a function is suppressed.  If this option is disabled,\n\
-Octave will display the results produced by evaluating expressions\n\
-within a function body that are not terminated with a semicolon.\n\
+output from a function is suppressed.\n\
+\n\
+If this option is disabled, Octave will display the results produced by\n\
+evaluating expressions within a function body that are not terminated with\n\
+a semicolon.\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
 variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (silent_functions);
 }
diff --git a/libinterp/parse-tree/pt-mat.cc b/libinterp/parse-tree/pt-mat.cc
--- a/libinterp/parse-tree/pt-mat.cc
+++ b/libinterp/parse-tree/pt-mat.cc
@@ -1386,31 +1386,33 @@ tree_matrix::accept (tree_walker& tw)
 */
 
 DEFUN (string_fill_char, args, nargout,
        "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} string_fill_char ()\n\
 @deftypefnx {Built-in Function} {@var{old_val} =} string_fill_char (@var{new_val})\n\
 @deftypefnx {Built-in Function} {} string_fill_char (@var{new_val}, \"local\")\n\
 Query or set the internal variable used to pad all rows of a character\n\
-matrix to the same length; It must be a single character.  The default\n\
-value is @qcode{\" \"} (a single space).  For example:\n\
+matrix to the same length.\n\
+\n\
+The value must be a single character and the default is @qcode{\" \"} (a\n\
+single space).  For example:\n\
 \n\
 @example\n\
 @group\n\
 string_fill_char (\"X\");\n\
 [ \"these\"; \"are\"; \"strings\" ]\n\
       @result{}  \"theseXX\"\n\
           \"areXXXX\"\n\
           \"strings\"\n\
 @end group\n\
 @end example\n\
 \n\
 When called from inside a function with the @qcode{\"local\"} option, the\n\
-variable is changed locally for the function and any subroutines it calls.  \n\
+variable is changed locally for the function and any subroutines it calls.\n\
 The original variable value is restored when exiting the function.\n\
 @end deftypefn")
 {
   return SET_INTERNAL_VARIABLE (string_fill_char);
 }
 
 /*
 ## string_fill_char() function call must be outside of %!test block
