# HG changeset patch
# User Jaroslav Hajek <highegg@gmail.com>
# Date 1258037278 -3600
#      Thu Nov 12 15:47:58 2009 +0100
# Node ID f80c566bc751d302eca2cf326a177e2399ef507e
# Parent  c657c056240d52cf22d58c1e6c5ece186eafd88b
improve unary mapper system

diff --git a/liboctave/Array.h b/liboctave/Array.h
--- a/liboctave/Array.h
+++ b/liboctave/Array.h
@@ -661,26 +661,46 @@ public:
   {
     octave_idx_type len = length ();
 
     const T *m = data ();
 
     Array<U> result (dims ());
     U *p = result.fortran_vec ();
 
-    for (octave_idx_type i = 0; i < len; i++)
+    octave_idx_type i;
+    for (i = 0; i < len - 3; i += 4)
       {
 	OCTAVE_QUIT;
 
-	p[i] = fcn (m[i]);
+        p[i] = fcn (m[i]);
+        p[i+1] = fcn (m[i+1]);
+        p[i+2] = fcn (m[i+2]);
+        p[i+3] = fcn (m[i+3]);
       }
 
+    OCTAVE_QUIT;
+
+    for (; i < len; i++)
+      p[i] = fcn (m[i]);
+
     return result;
   }
 
+  // Overloads for function references.
+  template <class U>
+  Array<U>
+  map (U (&fcn) (T)) const
+  { return map<U, U (&) (T)> (fcn); }
+
+  template <class U>
+  Array<U>
+  map (U (&fcn) (const T&)) const
+  { return map<U, U (&) (const T&)> (fcn); }
+
   template <class U> friend class Array;
 
 private:
   static void instantiation_guard ();
 };
 
 // This is a simple wrapper template that will subclass an Array<T> type or any
 // later type derived from it and override the default non-const operator() to
diff --git a/liboctave/Array2.h b/liboctave/Array2.h
--- a/liboctave/Array2.h
+++ b/liboctave/Array2.h
@@ -143,21 +143,26 @@ public:
       return Array2<T> (tmp, tmp.rows (), tmp.columns ());
     }
 
   Array2<T> diag (octave_idx_type k) const
   {
     return Array<T>::diag (k);
   }
 
-  template <class U, class F>
-  Array2<U> map (F fcn) const
-  {
-    return Array<T>::template map<U> (fcn);
-  }
+  // FIXME: should go away.
+  template <class U>
+  Array2<U>
+  map (U (&fcn) (T)) const
+  { return Array<T>::template map<U> (fcn); }
+
+  template <class U>
+  Array2<U>
+  map (U (&fcn) (const T&)) const
+  { return Array<T>::template map<U> (fcn); }
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/liboctave/CColVector.cc b/liboctave/CColVector.cc
--- a/liboctave/CColVector.cc
+++ b/liboctave/CColVector.cc
@@ -448,28 +448,16 @@ operator * (const ComplexDiagMatrix& m, 
   for (octave_idx_type i = a_len; i < nr; i++)
     result.elem (i) = 0.0;
 
   return result;
 }
 
 // other operations
 
-ColumnVector
-ComplexColumnVector::map (dmapper fcn) const
-{
-  return MArray<Complex>::map<double> (func_ptr (fcn));
-}
-
-ComplexColumnVector
-ComplexColumnVector::map (cmapper fcn) const
-{
-  return MArray<Complex>::map<Complex> (func_ptr (fcn));
-}
-
 Complex
 ComplexColumnVector::min (void) const
 {
   octave_idx_type len = length ();
   if (len == 0)
     return 0.0;
 
   Complex res = elem (0);
diff --git a/liboctave/CColVector.h b/liboctave/CColVector.h
--- a/liboctave/CColVector.h
+++ b/liboctave/CColVector.h
@@ -111,22 +111,16 @@ public:
   friend OCTAVE_API ComplexColumnVector operator * (const ComplexDiagMatrix& a,
 					 const ColumnVector& b);
 
   friend OCTAVE_API ComplexColumnVector operator * (const ComplexDiagMatrix& a,
 					 const ComplexColumnVector& b);
 
   // other operations
 
-  typedef double (*dmapper) (const Complex&);
-  typedef Complex (*cmapper) (const Complex&);
-
-  ColumnVector map (dmapper fcn) const;
-  ComplexColumnVector map (cmapper fcn) const;
-
   Complex min (void) const;
   Complex max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ComplexColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ComplexColumnVector& a);
 
diff --git a/liboctave/CDiagMatrix.cc b/liboctave/CDiagMatrix.cc
--- a/liboctave/CDiagMatrix.cc
+++ b/liboctave/CDiagMatrix.cc
@@ -559,17 +559,17 @@ ComplexDiagMatrix::determinant (void) co
     }
 
   return det;
 }
 
 double
 ComplexDiagMatrix::rcond (void) const
 {
-  ColumnVector av = diag (0).map (std::abs);
+  ColumnVector av = diag (0).map<double> (std::abs);
   double amx = av.max (), amn = av.min ();
   return amx == 0 ? 0.0 : amn / amx;
 }
 
 // i/o
 
 std::ostream&
 operator << (std::ostream& os, const ComplexDiagMatrix& a)
diff --git a/liboctave/CMatrix.cc b/liboctave/CMatrix.cc
--- a/liboctave/CMatrix.cc
+++ b/liboctave/CMatrix.cc
@@ -3074,34 +3074,16 @@ ComplexMatrix::operator -= (const Matrix
 boolMatrix
 ComplexMatrix::operator ! (void) const
 {
   return do_mx_unary_op<boolMatrix, ComplexMatrix> (*this, mx_inline_not);
 }
 
 // other operations
 
-Matrix
-ComplexMatrix::map (dmapper fcn) const
-{
-  return MArray2<Complex>::map<double> (func_ptr (fcn));
-}
-
-ComplexMatrix
-ComplexMatrix::map (cmapper fcn) const
-{
-  return MArray2<Complex>::map<Complex> (func_ptr (fcn));
-}
-
-boolMatrix
-ComplexMatrix::map (bmapper fcn) const
-{
-  return MArray2<Complex>::map<bool> (func_ptr (fcn));
-}
-
 bool
 ComplexMatrix::any_element_is_nan (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
diff --git a/liboctave/CMatrix.h b/liboctave/CMatrix.h
--- a/liboctave/CMatrix.h
+++ b/liboctave/CMatrix.h
@@ -328,24 +328,16 @@ public:
   ComplexMatrix& operator -= (const Matrix& a);
 
   // unary operations
 
   boolMatrix operator ! (void) const;
 
   // other operations
 
-  typedef double (*dmapper) (const Complex&);
-  typedef Complex (*cmapper) (const Complex&);
-  typedef bool (*bmapper) (const Complex&);
-
-  Matrix map (dmapper fcn) const;
-  ComplexMatrix map (cmapper fcn) const;
-  boolMatrix map (bmapper fcn) const;
-
   bool any_element_is_nan (void) const;
   bool any_element_is_inf_or_nan (void) const;
   bool all_elements_are_real (void) const;
   bool all_integers (double& max_val, double& min_val) const;
   bool too_large_for_float (void) const;
 
   boolMatrix all (int dim = -1) const;
   boolMatrix any (int dim = -1) const;
diff --git a/liboctave/CNDArray.cc b/liboctave/CNDArray.cc
--- a/liboctave/CNDArray.cc
+++ b/liboctave/CNDArray.cc
@@ -881,34 +881,16 @@ ComplexNDArray::compute_index (Array<oct
 }
 
 ComplexNDArray
 ComplexNDArray::diag (octave_idx_type k) const
 {
   return MArrayN<Complex>::diag (k);
 }
 
-NDArray
-ComplexNDArray::map (dmapper fcn) const
-{
-  return MArrayN<Complex>::map<double> (func_ptr (fcn));
-}
-
-ComplexNDArray
-ComplexNDArray::map (cmapper fcn) const
-{
-  return MArrayN<Complex>::map<Complex> (func_ptr (fcn));
-}
-
-boolNDArray
-ComplexNDArray::map (bmapper fcn) const
-{
-  return MArrayN<Complex>::map<bool> (func_ptr (fcn));
-}
-
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const ComplexNDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
diff --git a/liboctave/CNDArray.h b/liboctave/CNDArray.h
--- a/liboctave/CNDArray.h
+++ b/liboctave/CNDArray.h
@@ -143,24 +143,16 @@ public:
   ComplexNDArray diag (octave_idx_type k = 0) const;
 
   ComplexNDArray& changesign (void) 
     { 
       MArrayN<Complex>::changesign (); 
       return *this; 
     }
 
-  typedef double (*dmapper) (const Complex&);
-  typedef Complex (*cmapper) (const Complex&);
-  typedef bool (*bmapper) (const Complex&);
-
-  NDArray map (dmapper fcn) const;
-  ComplexNDArray map (cmapper fcn) const;
-  boolNDArray map (bmapper fcn) const;
-
 private:
 
   ComplexNDArray (Complex *d, const dim_vector& dv)
     : MArrayN<Complex> (d, dv) { }
 };
 
 extern OCTAVE_API ComplexNDArray conj (const ComplexNDArray& a);
 
diff --git a/liboctave/CRowVector.cc b/liboctave/CRowVector.cc
--- a/liboctave/CRowVector.cc
+++ b/liboctave/CRowVector.cc
@@ -361,28 +361,16 @@ ComplexRowVector
 operator * (const RowVector& v, const ComplexMatrix& a)
 {
   ComplexRowVector tmp (v);
   return tmp * a;
 }
 
 // other operations
 
-RowVector
-ComplexRowVector::map (dmapper fcn) const
-{
-  return MArray<Complex>::map<double> (func_ptr (fcn));
-}
-
-ComplexRowVector
-ComplexRowVector::map (cmapper fcn) const
-{
-  return MArray<Complex>::map<Complex> (func_ptr (fcn));
-}
-
 Complex
 ComplexRowVector::min (void) const
 {
   octave_idx_type len = length ();
   if (len == 0)
     return Complex (0.0);
 
   Complex res = elem (0);
diff --git a/liboctave/CRowVector.h b/liboctave/CRowVector.h
--- a/liboctave/CRowVector.h
+++ b/liboctave/CRowVector.h
@@ -93,22 +93,16 @@ public:
   friend ComplexRowVector operator * (const ComplexRowVector& a,
 				      const ComplexMatrix& b);
 
   friend ComplexRowVector operator * (const RowVector& a,
 				      const ComplexMatrix& b);
 
   // other operations
 
-  typedef double (*dmapper) (const Complex&);
-  typedef Complex (*cmapper) (const Complex&);
-
-  RowVector map (dmapper fcn) const;
-  ComplexRowVector map (cmapper fcn) const;
-
   Complex min (void) const;
   Complex max (void) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const ComplexRowVector& a);
   friend std::istream& operator >> (std::istream& is, ComplexRowVector& a);
 
diff --git a/liboctave/CSparse.cc b/liboctave/CSparse.cc
--- a/liboctave/CSparse.cc
+++ b/liboctave/CSparse.cc
@@ -7427,34 +7427,16 @@ SparseMatrix SparseComplexMatrix::abs (v
 }
 
 SparseComplexMatrix
 SparseComplexMatrix::diag (octave_idx_type k) const
 {
   return MSparse<Complex>::diag (k);
 }
 
-SparseMatrix
-SparseComplexMatrix::map (dmapper fcn) const
-{
-  return MSparse<Complex>::map<double> (func_ptr (fcn));
-}
-
-SparseComplexMatrix
-SparseComplexMatrix::map (cmapper fcn) const
-{
-  return MSparse<Complex>::map<Complex> (func_ptr (fcn));
-}
-
-SparseBoolMatrix
-SparseComplexMatrix::map (bmapper fcn) const
-{
-  return MSparse<Complex>::map<bool> (func_ptr (fcn));
-}
-
 std::ostream&
 operator << (std::ostream& os, const SparseComplexMatrix& a)
 {
   octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
    for (octave_idx_type j = 0; j < nc; j++)  {
diff --git a/liboctave/CSparse.h b/liboctave/CSparse.h
--- a/liboctave/CSparse.h
+++ b/liboctave/CSparse.h
@@ -433,23 +433,16 @@ public:
 
   SparseComplexMatrix diag (octave_idx_type k = 0) const;
 
   // i/o
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, 
 				    const SparseComplexMatrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, 
 				    SparseComplexMatrix& a);
-
-  typedef double (*dmapper) (const Complex&);
-  typedef Complex (*cmapper) (const Complex&);
-  typedef bool (*bmapper) (const Complex&);
-  SparseMatrix map (dmapper fcn) const;
-  SparseComplexMatrix map (cmapper fcn) const;
-  SparseBoolMatrix map (bmapper fcn) const;
 };
 
 extern OCTAVE_API SparseComplexMatrix operator * (const SparseMatrix&,        
 				       const SparseComplexMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&, 
 				       const SparseMatrix&);
 extern OCTAVE_API SparseComplexMatrix operator * (const SparseComplexMatrix&, 
 				       const SparseComplexMatrix&);
diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,8 +1,69 @@
+2009-11-12  Jaroslav Hajek  <highegg@gmail.com>
+
+	* lo-mappers.cc ( rc_acos, rc_acos, rc_acosh, rc_acosh, rc_asin,
+	rc_asin, rc_atanh, rc_atanh, rc_log, rc_log, rc_xlog2, rc_log2,
+	rc_log10, rc_log10, rc_sqrt, rc_sqrt): New mappers.
+	* lo-mappers.h: Declare them.
+
+	* lo-specfun.cc (rc_lgamma, rc_lgamma, rc_log1p, rc_log1p): New
+	mappers.
+	* lo-specfun.h: Declare them.
+	* Array.h (Array<T>::map): Unroll loop to reduce OCTAVE_QUIT checking.
+	Provide function-reference overloads.
+
+	* MArray.h (MArray<T>::map): Provide function-reference overloads.
+	* Array2.h (Array2<T>::map): Ditto.
+	* MArray2.h (MArray2<T>::map): Ditto.
+
+	* Sparse.h (Sparse<T>::map): Ditto.
+	* MSparse.h (MSparse<T>::map): Ditto.
+
+	* dNDArray.h (NDArray::map): Remove.
+	* dNDArray.cc (NDArray::map): Remove.
+	* fNDArray.h (FloatNDArray::map): Remove.
+	* fNDArray.cc (FloatNDArray::map): Remove.
+	* CNDArray.h (ComplexNDArray::map): Remove.
+	* CNDArray.cc (ComplexNDArray::map): Remove.
+	* fCNDArray.h (FloatComplexNDArray::map): Remove.
+	* fCNDArray.cc (FloatComplexNDArray::map): Remove.
+
+	* dMatrix.h (Matrix::map): Remove.
+	* dMatrix.cc (Matrix::map): Remove.
+	* fMatrix.h (FloatMatrix::map): Remove.
+	* fMatrix.cc (FloatMatrix::map): Remove.
+	* CMatrix.h (ComplexMatrix::map): Remove.
+	* CMatrix.cc (ComplexMatrix::map): Remove.
+	* fCMatrix.h (FloatComplexMatrix::map): Remove.
+	* fCMatrix.cc (FloatComplexMatrix::map): Remove.
+
+	* dRowVector.h (RowVector::map): Remove.
+	* dRowVector.cc (RowVector::map): Remove.
+	* fRowVector.h (FloatRowVector::map): Remove.
+	* fRowVector.cc (FloatRowVector::map): Remove.
+	* CRowVector.h (ComplexRowVector::map): Remove.
+	* CRowVector.cc (ComplexRowVector::map): Remove.
+	* fCRowVector.h (FloatComplexRowVector::map): Remove.
+	* fCRowVector.cc (FloatComplexRowVector::map): Remove.
+
+	* dColVector.h (ColumnVector::map): Remove.
+	* dColVector.cc (ColumnVector::map): Remove.
+	* fColVector.h (FloatColumnVector::map): Remove.
+	* fColVector.cc (FloatColumnVector::map): Remove.
+	* CColVector.h (ComplexColumnVector::map): Remove.
+	* CColVector.cc (ComplexColumnVector::map): Remove.
+	* fCColVector.h (FloatComplexColumnVector::map): Remove.
+	* fCColVector.cc (FloatComplexColumnVector::map): Remove.
+
+	* dSparse.h (SparseMatrix::map): Remove.
+	* dSparse.cc (SparseMatrix::map): Remove.
+	* CSparse.h (SparseComplexMatrix::map): Remove.
+	* CSparse.cc (SparseComplexMatrix::map): Remove.
+
 2009-11-11  John W. Eaton  <jwe@octave.org>
 
 	* lo-ieee.cc (octave_ieee_init): Improve comment about systems
 	without IEEE floating point format.
 
 2009-11-11  Jaroslav Hajek  <highegg@gmail.com>
 
 	* mx-inlines.cc (mx_inline_map): New template loop.
diff --git a/liboctave/MArray.h b/liboctave/MArray.h
--- a/liboctave/MArray.h
+++ b/liboctave/MArray.h
@@ -88,21 +88,26 @@ public:
 	}
 
       return retval;
     }
 
   double norm (double p) const;
   float norm (float p) const;
 
-  template <class U, class F>
-  MArray<U> map (F fcn) const
-  {
-    return Array<T>::template map<U> (fcn);
-  }
+  // FIXME: should go away.
+  template <class U>
+  MArray<U>
+  map (U (&fcn) (T)) const
+  { return Array<T>::template map<U> (fcn); }
+
+  template <class U>
+  MArray<U>
+  map (U (&fcn) (const T&)) const
+  { return Array<T>::template map<U> (fcn); }
 
   // Performs indexed accumulative addition.
 
   void idx_add (const idx_vector& idx, T val);
 
   void idx_add (const idx_vector& idx, const MArray<T>& vals);
 
   // Currently, the OPS functions don't need to be friends, but that
diff --git a/liboctave/MArray2.h b/liboctave/MArray2.h
--- a/liboctave/MArray2.h
+++ b/liboctave/MArray2.h
@@ -82,21 +82,26 @@ public:
   MArray2<T> transpose (void) const { return Array2<T>::transpose (); }
   MArray2<T> hermitian (T (*fcn) (const T&) = 0) const { return Array2<T>::hermitian (fcn); }
 
   MArray2<T> diag (octave_idx_type k) const
   {
     return Array2<T>::diag (k);
   }
 
-  template <class U, class F>
-  MArray2<U> map (F fcn) const
-  {
-    return Array2<T>::template map<U> (fcn);
-  }
+  // FIXME: should go away.
+  template <class U>
+  MArray2<U>
+  map (U (&fcn) (T)) const
+  { return Array2<T>::template map<U> (fcn); }
+
+  template <class U>
+  MArray2<U>
+  map (U (&fcn) (const T&)) const
+  { return Array2<T>::template map<U> (fcn); }
 
   // Currently, the OPS functions don't need to be friends, but that
   // may change.
 
   // MARRAY_OPS_FRIEND_DECLS (MArray2)
 };
 
 #endif
diff --git a/liboctave/MArrayN.h b/liboctave/MArrayN.h
--- a/liboctave/MArrayN.h
+++ b/liboctave/MArrayN.h
@@ -99,22 +99,16 @@ public:
 
   MArrayN squeeze (void) const { return Array<T>::squeeze (); }
 
   MArrayN<T> diag (octave_idx_type k) const
   {
     return Array<T>::diag (k);
   }
 
-  template <class U, class F>
-  MArrayN<U> map (F fcn) const
-  {
-    return Array<T>::template map<U> (fcn);
-  }
-
   void changesign (void);
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
diff --git a/liboctave/MSparse.h b/liboctave/MSparse.h
--- a/liboctave/MSparse.h
+++ b/liboctave/MSparse.h
@@ -112,21 +112,26 @@ public:
     { return Sparse<T>::ipermute (vec); }
 
 
   MSparse<T> diag (octave_idx_type k = 0) const
   {
     return Sparse<T>::diag (k);
   }
 
- template <class U, class F>
-  MSparse<U> map (F fcn) const
-  {
-    return Sparse<T>::template map<U> (fcn);
-  }
+  // FIXME: should go away.
+  template <class U>
+  MSparse<U>
+  map (U (&fcn) (T)) const
+  { return Sparse<T>::template map<U> (fcn); }
+
+  template <class U>
+  MSparse<U>
+  map (U (&fcn) (const T&)) const
+  { return Sparse<T>::template map<U> (fcn); }
 
   // Currently, the OPS functions don't need to be friends, but that
   // may change.
 
   // SPARSE_OPS_FRIEND_DECLS (MSparse, MArray2)
 };
 
 #endif
diff --git a/liboctave/Sparse.h b/liboctave/Sparse.h
--- a/liboctave/Sparse.h
+++ b/liboctave/Sparse.h
@@ -564,16 +564,27 @@ public:
 	  }
 
 	result.maybe_compress (false);
       }
 
     return result;
   }
 
+  // Overloads for function references.
+  template <class U>
+  Sparse<U>
+  map (U (&fcn) (T)) const
+  { return map<U, U (&) (T)> (fcn); }
+
+  template <class U>
+  Sparse<U>
+  map (U (&fcn) (const T&)) const
+  { return map<U, U (&) (const T&)> (fcn); }
+
   bool indices_ok (void) const { return rep->indices_ok (); }
 };
 
 // NOTE: these functions should be friends of the Sparse<T> class and
 // Sparse<T>::dimensions should be protected, not public, but we can't
 // do that because of bugs in gcc prior to 3.3.
 
 template <class LT, class RT>
diff --git a/liboctave/chNDArray.cc b/liboctave/chNDArray.cc
--- a/liboctave/chNDArray.cc
+++ b/liboctave/chNDArray.cc
@@ -147,70 +147,16 @@ charNDArray::compute_index (Array<octave
 }
 
 charNDArray
 charNDArray::diag (octave_idx_type k) const
 {
   return MArrayN<char>::diag (k);
 }
 
-boolNDArray
-charNDArray::bmap (mapper fcn) const
-{
-  octave_idx_type len = length ();
-  const char *m = fortran_vec();
-  boolNDArray result (dims ());
-  bool *p = result.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < len; i++)
-    {
-      OCTAVE_QUIT;
-
-      p[i] = bool (fcn (m[i]));
-    }
-
-  return result;
-}
-
-NDArray
-charNDArray::dmap (mapper fcn) const
-{
-  octave_idx_type len = length ();
-  const char *m = fortran_vec();
-  NDArray result (dims ());
-  double *p = result.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < len; i++)
-    {
-      OCTAVE_QUIT;
-
-      p[i] = fcn (m[i]);
-    }
-
-  return result;
-}
-
-charNDArray
-charNDArray::smap (mapper fcn) const
-{
-  octave_idx_type len = length ();
-  const char *m = fortran_vec();
-  charNDArray result (dims ());
-  char *p = result.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < len; i++)
-    {
-      OCTAVE_QUIT;
-
-      p[i] = fcn (m[i]);
-    }
-
-  return result;
-}
-
 NDS_CMP_OPS (charNDArray, char)
 NDS_BOOL_OPS (charNDArray, char)
 
 SND_CMP_OPS (char, charNDArray)
 SND_BOOL_OPS (char, charNDArray)
 
 NDND_CMP_OPS (charNDArray, charNDArray)
 NDND_BOOL_OPS (charNDArray, charNDArray)
diff --git a/liboctave/chNDArray.h b/liboctave/chNDArray.h
--- a/liboctave/chNDArray.h
+++ b/liboctave/chNDArray.h
@@ -90,21 +90,16 @@ public:
 
   // friend std::ostream& operator << (std::ostream& os, const charNDArray& a);
   // friend std::istream& operator >> (std::istream& is, charNDArray& a);
 
   static char resize_fill_value (void) { return '\0'; }
 
   charNDArray diag (octave_idx_type k = 0) const;
 
-  typedef int (*mapper) (int);
-  boolNDArray bmap (mapper fcn) const;
-  NDArray dmap (mapper fcn) const;
-  charNDArray smap (mapper fcn) const;
-
 private:
 
   charNDArray (char *d, dim_vector& dv) : MArrayN<char> (d, dv) { }
 };
 
 NDS_CMP_OP_DECLS (charNDArray, char, OCTAVE_API)
 NDS_BOOL_OP_DECLS (charNDArray, char, OCTAVE_API)
 
diff --git a/liboctave/dColVector.cc b/liboctave/dColVector.cc
--- a/liboctave/dColVector.cc
+++ b/liboctave/dColVector.cc
@@ -255,28 +255,16 @@ operator * (const DiagMatrix& m, const C
 	}
     }
 
   return retval;
 }
 
 // other operations
 
-ColumnVector
-ColumnVector::map (dmapper fcn) const
-{
-  return MArray<double>::map<double> (func_ptr (fcn));
-}
-
-ComplexColumnVector
-ColumnVector::map (cmapper fcn) const
-{
-  return MArray<double>::map<Complex> (func_ptr (fcn));
-}
-
 double
 ColumnVector::min (void) const
 {
   octave_idx_type len = length ();
   if (len == 0)
     return 0.0;
 
   double res = elem (0);
diff --git a/liboctave/dColVector.h b/liboctave/dColVector.h
--- a/liboctave/dColVector.h
+++ b/liboctave/dColVector.h
@@ -80,22 +80,16 @@ public:
   friend OCTAVE_API ColumnVector operator * (const Matrix& a, const ColumnVector& b);
 
   // diagonal matrix by column vector -> column vector operations
 
   friend OCTAVE_API ColumnVector operator * (const DiagMatrix& a, const ColumnVector& b);
 
   // other operations
 
-  typedef double (*dmapper) (double);
-  typedef Complex (*cmapper) (const Complex&);
-
-  ColumnVector map (dmapper fcn) const;
-  ComplexColumnVector map (cmapper fcn) const;
-
   double min (void) const;
   double max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const ColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, ColumnVector& a);
 
diff --git a/liboctave/dDiagMatrix.cc b/liboctave/dDiagMatrix.cc
--- a/liboctave/dDiagMatrix.cc
+++ b/liboctave/dDiagMatrix.cc
@@ -371,17 +371,17 @@ DiagMatrix::determinant (void) const
     }
 
   return det;
 }
 
 double
 DiagMatrix::rcond (void) const
 {
-  ColumnVector av  = diag (0).map (fabs);
+  ColumnVector av  = diag (0).map<double> (fabs);
   double amx = av.max (), amn = av.min ();
   return amx == 0 ? 0.0 : amn / amx;
 }
 
 std::ostream&
 operator << (std::ostream& os, const DiagMatrix& a)
 {
 //  int field_width = os.precision () + 7;
diff --git a/liboctave/dMatrix.cc b/liboctave/dMatrix.cc
--- a/liboctave/dMatrix.cc
+++ b/liboctave/dMatrix.cc
@@ -2632,34 +2632,16 @@ operator * (const ColumnVector& v, const
 			       F77_CHAR_ARG_LEN (1)));
     }
 
   return retval;
 }
 
 // other operations.
 
-Matrix
-Matrix::map (dmapper fcn) const
-{
-  return MArray2<double>::map<double> (func_ptr (fcn));
-}
-
-ComplexMatrix
-Matrix::map (cmapper fcn) const
-{
-  return MArray2<double>::map<Complex> (func_ptr (fcn));
-}
-
-boolMatrix
-Matrix::map (bmapper fcn) const
-{
-  return MArray2<double>::map<bool> (func_ptr (fcn));
-}
-
 bool
 Matrix::any_element_is_negative (bool neg_zero) const
 {
   octave_idx_type nel = nelem ();
 
   if (neg_zero)
     {
       for (octave_idx_type i = 0; i < nel; i++)
diff --git a/liboctave/dMatrix.h b/liboctave/dMatrix.h
--- a/liboctave/dMatrix.h
+++ b/liboctave/dMatrix.h
@@ -282,24 +282,16 @@ public:
   Matrix& operator -= (const DiagMatrix& a);
 
   // unary operations
 
   boolMatrix operator ! (void) const;
 
   // other operations
 
-  typedef double (*dmapper) (double);
-  typedef Complex (*cmapper) (const Complex&);
-  typedef bool (*bmapper) (double);
-
-  Matrix map (dmapper fcn) const;
-  ComplexMatrix map (cmapper fcn) const;
-  boolMatrix map (bmapper fcn) const;
-
   bool any_element_is_negative (bool = false) const;
   bool any_element_is_nan (void) const;
   bool any_element_is_inf_or_nan (void) const;
   bool any_element_not_one_or_zero (void) const;
   bool all_elements_are_int_or_inf_or_nan (void) const;
   bool all_integers (double& max_val, double& min_val) const;
   bool too_large_for_float (void) const;
  
diff --git a/liboctave/dNDArray.cc b/liboctave/dNDArray.cc
--- a/liboctave/dNDArray.cc
+++ b/liboctave/dNDArray.cc
@@ -926,34 +926,16 @@ NDArray::compute_index (Array<octave_idx
 }
 
 NDArray
 NDArray::diag (octave_idx_type k) const
 {
   return MArrayN<double>::diag (k);
 }
 
-NDArray
-NDArray::map (dmapper fcn) const
-{
-  return MArrayN<double>::map<double> (func_ptr (fcn));
-}
-
-ComplexNDArray
-NDArray::map (cmapper fcn) const
-{
-  return MArrayN<double>::map<Complex> (func_ptr (fcn));
-}
-
-boolNDArray
-NDArray::map (bmapper fcn) const
-{
-  return MArrayN<double>::map<bool> (func_ptr (fcn));
-}
-
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const NDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
diff --git a/liboctave/dNDArray.h b/liboctave/dNDArray.h
--- a/liboctave/dNDArray.h
+++ b/liboctave/dNDArray.h
@@ -154,24 +154,16 @@ public:
   NDArray diag (octave_idx_type k = 0) const;
 
   NDArray& changesign (void) 
     { 
       MArrayN<double>::changesign (); 
       return *this; 
     }
 
-  typedef double (*dmapper) (double);
-  typedef Complex (*cmapper) (const Complex&);
-  typedef bool (*bmapper) (double);
-
-  NDArray map (dmapper fcn) const;
-  ComplexNDArray map (cmapper fcn) const;
-  boolNDArray map (bmapper fcn) const;
-
 private:
 
   NDArray (double *d, const dim_vector& dv) : MArrayN<double> (d, dv) { }
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API NDArray real (const ComplexNDArray& a);
diff --git a/liboctave/dRowVector.cc b/liboctave/dRowVector.cc
--- a/liboctave/dRowVector.cc
+++ b/liboctave/dRowVector.cc
@@ -227,28 +227,16 @@ operator * (const RowVector& v, const Ma
 	}
     }
 
   return retval;
 }
 
 // other operations
 
-RowVector
-RowVector::map (dmapper fcn) const
-{
-  return MArray<double>::map<double> (func_ptr (fcn));
-}
-
-ComplexRowVector
-RowVector::map (cmapper fcn) const
-{
-  return MArray<double>::map<Complex> (func_ptr (fcn));
-}
-
 double
 RowVector::min (void) const
 {
   octave_idx_type len = length ();
   if (len == 0)
     return 0;
 
   double res = elem (0);
diff --git a/liboctave/dRowVector.h b/liboctave/dRowVector.h
--- a/liboctave/dRowVector.h
+++ b/liboctave/dRowVector.h
@@ -76,22 +76,16 @@ public:
   RowVector extract_n (octave_idx_type c1, octave_idx_type n) const;
 
   // row vector by matrix -> row vector
 
   friend OCTAVE_API RowVector operator * (const RowVector& a, const Matrix& b);
 
   // other operations
 
-  typedef double (*dmapper) (double);
-  typedef Complex (*cmapper) (const Complex&);
-
-  RowVector map (dmapper fcn) const;
-  ComplexRowVector map (cmapper fcn) const;
-
   double min (void) const;
   double max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const RowVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, RowVector& a);
 
diff --git a/liboctave/dSparse.cc b/liboctave/dSparse.cc
--- a/liboctave/dSparse.cc
+++ b/liboctave/dSparse.cc
@@ -7545,34 +7545,16 @@ SparseMatrix::matrix_value (void) const
   Matrix retval (nr, nc, 0.0);
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = cidx(j); i < cidx(j+1); i++)
       retval.elem (ridx(i), j) = data (i);
 
   return retval;
 }
 
-SparseMatrix
-SparseMatrix::map (dmapper fcn) const
-{
-  return MSparse<double>::map<double> (func_ptr (fcn));
-}
-
-SparseComplexMatrix
-SparseMatrix::map (cmapper fcn) const
-{
-  return MSparse<double>::map<Complex> (func_ptr (fcn));
-}
-
-SparseBoolMatrix
-SparseMatrix::map (bmapper fcn) const
-{
-  return MSparse<double>::map<bool> (func_ptr (fcn));
-}
-
 std::ostream&
 operator << (std::ostream& os, const SparseMatrix& a)
 {
   octave_idx_type nc = a.cols ();
 
    // add one to the printed indices to go from
    //  zero-based to one-based arrays
    for (octave_idx_type j = 0; j < nc; j++)  {
diff --git a/liboctave/dSparse.h b/liboctave/dSparse.h
--- a/liboctave/dSparse.h
+++ b/liboctave/dSparse.h
@@ -421,22 +421,16 @@ public:
 
   SparseMatrix ipermute (const Array<octave_idx_type>& vec) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const SparseMatrix& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, SparseMatrix& a);
 
-  typedef double (*dmapper) (double);
-  typedef Complex (*cmapper) (const Complex&);
-  typedef bool (*bmapper) (double);
-  SparseMatrix map (dmapper fcn) const;
-  SparseComplexMatrix map (cmapper fcn) const;
-  SparseBoolMatrix map (bmapper fcn) const;
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API SparseMatrix real (const SparseComplexMatrix& a);
 extern OCTAVE_API SparseMatrix imag (const SparseComplexMatrix& a);
 
 // Other operators.
diff --git a/liboctave/fCColVector.cc b/liboctave/fCColVector.cc
--- a/liboctave/fCColVector.cc
+++ b/liboctave/fCColVector.cc
@@ -448,28 +448,16 @@ operator * (const FloatComplexDiagMatrix
   for (octave_idx_type i = a_len; i < nr; i++)
     result.elem (i) = 0.0;
 
   return result;
 }
 
 // other operations
 
-FloatColumnVector
-FloatComplexColumnVector::map (dmapper fcn) const
-{
-  return MArray<FloatComplex>::map<float> (func_ptr (fcn));
-}
-
-FloatComplexColumnVector
-FloatComplexColumnVector::map (cmapper fcn) const
-{
-  return MArray<FloatComplex>::map<FloatComplex> (func_ptr (fcn));
-}
-
 FloatComplex
 FloatComplexColumnVector::min (void) const
 {
   octave_idx_type len = length ();
   if (len == 0)
     return 0.0;
 
   FloatComplex res = elem (0);
diff --git a/liboctave/fCColVector.h b/liboctave/fCColVector.h
--- a/liboctave/fCColVector.h
+++ b/liboctave/fCColVector.h
@@ -111,22 +111,16 @@ public:
   friend OCTAVE_API FloatComplexColumnVector operator * (const FloatComplexDiagMatrix& a,
 					 const ColumnVector& b);
 
   friend OCTAVE_API FloatComplexColumnVector operator * (const FloatComplexDiagMatrix& a,
 					 const FloatComplexColumnVector& b);
 
   // other operations
 
-  typedef float (*dmapper) (const FloatComplex&);
-  typedef FloatComplex (*cmapper) (const FloatComplex&);
-
-  FloatColumnVector map (dmapper fcn) const;
-  FloatComplexColumnVector map (cmapper fcn) const;
-
   FloatComplex min (void) const;
   FloatComplex max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatComplexColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatComplexColumnVector& a);
 
diff --git a/liboctave/fCDiagMatrix.cc b/liboctave/fCDiagMatrix.cc
--- a/liboctave/fCDiagMatrix.cc
+++ b/liboctave/fCDiagMatrix.cc
@@ -559,17 +559,17 @@ FloatComplexDiagMatrix::determinant (voi
     }
 
   return det;
 }
 
 float
 FloatComplexDiagMatrix::rcond (void) const
 {
-  FloatColumnVector av = diag (0).map (std::abs);
+  FloatColumnVector av = diag (0).map<float> (std::abs);
   float amx = av.max (), amn = av.min ();
   return amx == 0 ? 0.0f : amn / amx;
 }
 
 // i/o
 
 std::ostream&
 operator << (std::ostream& os, const FloatComplexDiagMatrix& a)
diff --git a/liboctave/fCMatrix.cc b/liboctave/fCMatrix.cc
--- a/liboctave/fCMatrix.cc
+++ b/liboctave/fCMatrix.cc
@@ -3067,34 +3067,16 @@ FloatComplexMatrix::operator -= (const F
 boolMatrix
 FloatComplexMatrix::operator ! (void) const
 {
   return do_mx_unary_op<boolMatrix, FloatComplexMatrix> (*this, mx_inline_not);
 }
 
 // other operations
 
-FloatMatrix
-FloatComplexMatrix::map (dmapper fcn) const
-{
-  return MArray2<FloatComplex>::map<float> (func_ptr (fcn));
-}
-
-FloatComplexMatrix
-FloatComplexMatrix::map (cmapper fcn) const
-{
-  return MArray2<FloatComplex>::map<FloatComplex> (func_ptr (fcn));
-}
-
-boolMatrix
-FloatComplexMatrix::map (bmapper fcn) const
-{
-  return MArray2<FloatComplex>::map<bool> (func_ptr (fcn));
-}
-
 bool
 FloatComplexMatrix::any_element_is_nan (void) const
 {
   octave_idx_type nr = rows ();
   octave_idx_type nc = cols ();
 
   for (octave_idx_type j = 0; j < nc; j++)
     for (octave_idx_type i = 0; i < nr; i++)
diff --git a/liboctave/fCMatrix.h b/liboctave/fCMatrix.h
--- a/liboctave/fCMatrix.h
+++ b/liboctave/fCMatrix.h
@@ -328,24 +328,16 @@ public:
   FloatComplexMatrix& operator -= (const FloatMatrix& a);
 
   // unary operations
 
   boolMatrix operator ! (void) const;
 
   // other operations
 
-  typedef float (*dmapper) (const FloatComplex&);
-  typedef FloatComplex (*cmapper) (const FloatComplex&);
-  typedef bool (*bmapper) (const FloatComplex&);
-
-  FloatMatrix map (dmapper fcn) const;
-  FloatComplexMatrix map (cmapper fcn) const;
-  boolMatrix map (bmapper fcn) const;
-
   bool any_element_is_nan (void) const;
   bool any_element_is_inf_or_nan (void) const;
   bool all_elements_are_real (void) const;
   bool all_integers (float& max_val, float& min_val) const;
   bool too_large_for_float (void) const;
 
   boolMatrix all (int dim = -1) const;
   boolMatrix any (int dim = -1) const;
diff --git a/liboctave/fCNDArray.cc b/liboctave/fCNDArray.cc
--- a/liboctave/fCNDArray.cc
+++ b/liboctave/fCNDArray.cc
@@ -876,34 +876,16 @@ FloatComplexNDArray::compute_index (Arra
 }
 
 FloatComplexNDArray
 FloatComplexNDArray::diag (octave_idx_type k) const
 {
   return MArrayN<FloatComplex>::diag (k);
 }
 
-FloatNDArray
-FloatComplexNDArray::map (dmapper fcn) const
-{
-  return MArrayN<FloatComplex>::map<float> (func_ptr (fcn));
-}
-
-FloatComplexNDArray
-FloatComplexNDArray::map (cmapper fcn) const
-{
-  return MArrayN<FloatComplex>::map<FloatComplex> (func_ptr (fcn));
-}
-
-boolNDArray
-FloatComplexNDArray::map (bmapper fcn) const
-{
-  return MArrayN<FloatComplex>::map<bool> (func_ptr (fcn));
-}
-
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const FloatComplexNDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
diff --git a/liboctave/fCNDArray.h b/liboctave/fCNDArray.h
--- a/liboctave/fCNDArray.h
+++ b/liboctave/fCNDArray.h
@@ -143,24 +143,16 @@ public:
   FloatComplexNDArray diag (octave_idx_type k = 0) const;
 
   FloatComplexNDArray& changesign (void) 
     { 
       MArrayN<FloatComplex>::changesign (); 
       return *this; 
     }
 
-  typedef float (*dmapper) (const FloatComplex&);
-  typedef FloatComplex (*cmapper) (const FloatComplex&);
-  typedef bool (*bmapper) (const FloatComplex&);
-
-  FloatNDArray map (dmapper fcn) const;
-  FloatComplexNDArray map (cmapper fcn) const;
-  boolNDArray map (bmapper fcn) const;
-
 private:
 
   FloatComplexNDArray (FloatComplex *d, const dim_vector& dv)
     : MArrayN<FloatComplex> (d, dv) { }
 };
 
 extern OCTAVE_API FloatComplexNDArray conj (const FloatComplexNDArray& a);
 
diff --git a/liboctave/fCRowVector.cc b/liboctave/fCRowVector.cc
--- a/liboctave/fCRowVector.cc
+++ b/liboctave/fCRowVector.cc
@@ -361,28 +361,16 @@ FloatComplexRowVector
 operator * (const FloatRowVector& v, const FloatComplexMatrix& a)
 {
   FloatComplexRowVector tmp (v);
   return tmp * a;
 }
 
 // other operations
 
-FloatRowVector
-FloatComplexRowVector::map (dmapper fcn) const
-{
-  return MArray<FloatComplex>::map<float> (func_ptr (fcn));
-}
-
-FloatComplexRowVector
-FloatComplexRowVector::map (cmapper fcn) const
-{
-  return MArray<FloatComplex>::map<FloatComplex> (func_ptr (fcn));
-}
-
 FloatComplex
 FloatComplexRowVector::min (void) const
 {
   octave_idx_type len = length ();
   if (len == 0)
     return FloatComplex (0.0);
 
   FloatComplex res = elem (0);
diff --git a/liboctave/fCRowVector.h b/liboctave/fCRowVector.h
--- a/liboctave/fCRowVector.h
+++ b/liboctave/fCRowVector.h
@@ -93,22 +93,16 @@ public:
   friend FloatComplexRowVector operator * (const FloatComplexRowVector& a,
 				      const FloatComplexMatrix& b);
 
   friend FloatComplexRowVector operator * (const FloatRowVector& a,
 				      const FloatComplexMatrix& b);
 
   // other operations
 
-  typedef float (*dmapper) (const FloatComplex&);
-  typedef FloatComplex (*cmapper) (const FloatComplex&);
-
-  FloatRowVector map (dmapper fcn) const;
-  FloatComplexRowVector map (cmapper fcn) const;
-
   FloatComplex min (void) const;
   FloatComplex max (void) const;
 
   // i/o
 
   friend std::ostream& operator << (std::ostream& os, const FloatComplexRowVector& a);
   friend std::istream& operator >> (std::istream& is, FloatComplexRowVector& a);
 
diff --git a/liboctave/fColVector.cc b/liboctave/fColVector.cc
--- a/liboctave/fColVector.cc
+++ b/liboctave/fColVector.cc
@@ -255,28 +255,16 @@ operator * (const FloatDiagMatrix& m, co
 	}
     }
 
   return retval;
 }
 
 // other operations
 
-FloatColumnVector
-FloatColumnVector::map (dmapper fcn) const
-{
-  return MArray<float>::map<float> (func_ptr (fcn));
-}
-
-FloatComplexColumnVector
-FloatColumnVector::map (cmapper fcn) const
-{
-  return MArray<float>::map<FloatComplex> (func_ptr (fcn));
-}
-
 float
 FloatColumnVector::min (void) const
 {
   octave_idx_type len = length ();
   if (len == 0)
     return 0.0;
 
   float res = elem (0);
diff --git a/liboctave/fColVector.h b/liboctave/fColVector.h
--- a/liboctave/fColVector.h
+++ b/liboctave/fColVector.h
@@ -80,22 +80,16 @@ public:
   friend OCTAVE_API FloatColumnVector operator * (const FloatMatrix& a, const FloatColumnVector& b);
 
   // diagonal matrix by column vector -> column vector operations
 
   friend OCTAVE_API FloatColumnVector operator * (const FloatDiagMatrix& a, const FloatColumnVector& b);
 
   // other operations
 
-  typedef float (*dmapper) (float);
-  typedef FloatComplex (*cmapper) (const FloatComplex&);
-
-  FloatColumnVector map (dmapper fcn) const;
-  FloatComplexColumnVector map (cmapper fcn) const;
-
   float min (void) const;
   float max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatColumnVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatColumnVector& a);
 
diff --git a/liboctave/fDiagMatrix.cc b/liboctave/fDiagMatrix.cc
--- a/liboctave/fDiagMatrix.cc
+++ b/liboctave/fDiagMatrix.cc
@@ -371,17 +371,17 @@ FloatDiagMatrix::determinant (void) cons
     }
 
   return det;
 }
 
 float
 FloatDiagMatrix::rcond (void) const
 {
-  FloatColumnVector av = diag (0).map (fabsf);
+  FloatColumnVector av = diag (0).map<float> (fabsf);
   float amx = av.max (), amn = av.min ();
   return amx == 0 ? 0.0f : amn / amx;
 }
 
 std::ostream&
 operator << (std::ostream& os, const FloatDiagMatrix& a)
 {
 //  int field_width = os.precision () + 7;
diff --git a/liboctave/fMatrix.cc b/liboctave/fMatrix.cc
--- a/liboctave/fMatrix.cc
+++ b/liboctave/fMatrix.cc
@@ -2631,34 +2631,16 @@ operator * (const FloatColumnVector& v, 
 			       F77_CHAR_ARG_LEN (1)));
     }
 
   return retval;
 }
 
 // other operations.
 
-FloatMatrix
-FloatMatrix::map (dmapper fcn) const
-{
-  return MArray2<float>::map<float> (func_ptr (fcn));
-}
-
-FloatComplexMatrix
-FloatMatrix::map (cmapper fcn) const
-{
-  return MArray2<float>::map<FloatComplex> (func_ptr (fcn));
-}
-
-boolMatrix
-FloatMatrix::map (bmapper fcn) const
-{
-  return MArray2<float>::map<bool> (func_ptr (fcn));
-}
-
 bool
 FloatMatrix::any_element_is_negative (bool neg_zero) const
 {
   octave_idx_type nel = nelem ();
 
   if (neg_zero)
     {
       for (octave_idx_type i = 0; i < nel; i++)
diff --git a/liboctave/fMatrix.h b/liboctave/fMatrix.h
--- a/liboctave/fMatrix.h
+++ b/liboctave/fMatrix.h
@@ -282,24 +282,16 @@ public:
   FloatMatrix& operator -= (const FloatDiagMatrix& a);
 
   // unary operations
 
   boolMatrix operator ! (void) const;
 
   // other operations
 
-  typedef float (*dmapper) (float);
-  typedef FloatComplex (*cmapper) (const FloatComplex&);
-  typedef bool (*bmapper) (float);
-
-  FloatMatrix map (dmapper fcn) const;
-  FloatComplexMatrix map (cmapper fcn) const;
-  boolMatrix map (bmapper fcn) const;
-
   bool any_element_is_negative (bool = false) const;
   bool any_element_is_nan (void) const;
   bool any_element_is_inf_or_nan (void) const;
   bool any_element_not_one_or_zero (void) const;
   bool all_elements_are_int_or_inf_or_nan (void) const;
   bool all_integers (float& max_val, float& min_val) const;
   bool too_large_for_float (void) const;
  
diff --git a/liboctave/fNDArray.cc b/liboctave/fNDArray.cc
--- a/liboctave/fNDArray.cc
+++ b/liboctave/fNDArray.cc
@@ -884,34 +884,16 @@ FloatNDArray::compute_index (Array<octav
 }
 
 FloatNDArray
 FloatNDArray::diag (octave_idx_type k) const
 {
   return MArrayN<float>::diag (k);
 }
 
-FloatNDArray
-FloatNDArray::map (dmapper fcn) const
-{
-  return MArrayN<float>::map<float> (func_ptr (fcn));
-}
-
-FloatComplexNDArray
-FloatNDArray::map (cmapper fcn) const
-{
-  return MArrayN<float>::map<FloatComplex> (func_ptr (fcn));
-}
-
-boolNDArray
-FloatNDArray::map (bmapper fcn) const
-{
-  return MArrayN<float>::map<bool> (func_ptr (fcn));
-}
-
 // This contains no information on the array structure !!!
 std::ostream&
 operator << (std::ostream& os, const FloatNDArray& a)
 {
   octave_idx_type nel = a.nelem ();
 
   for (octave_idx_type i = 0; i < nel; i++)
     {
diff --git a/liboctave/fNDArray.h b/liboctave/fNDArray.h
--- a/liboctave/fNDArray.h
+++ b/liboctave/fNDArray.h
@@ -151,24 +151,16 @@ public:
   FloatNDArray diag (octave_idx_type k = 0) const;
 
   FloatNDArray& changesign (void) 
     { 
       MArrayN<float>::changesign (); 
       return *this; 
     }
 
-  typedef float (*dmapper) (float);
-  typedef FloatComplex (*cmapper) (const FloatComplex&);
-  typedef bool (*bmapper) (float);
-
-  FloatNDArray map (dmapper fcn) const;
-  FloatComplexNDArray map (cmapper fcn) const;
-  boolNDArray map (bmapper fcn) const;
-
 private:
 
   FloatNDArray (float *d, const dim_vector& dv) : MArrayN<float> (d, dv) { }
 };
 
 // Publish externally used friend functions.
 
 extern OCTAVE_API FloatNDArray real (const FloatComplexNDArray& a);
diff --git a/liboctave/fRowVector.cc b/liboctave/fRowVector.cc
--- a/liboctave/fRowVector.cc
+++ b/liboctave/fRowVector.cc
@@ -227,28 +227,16 @@ operator * (const FloatRowVector& v, con
 	}
     }
 
   return retval;
 }
 
 // other operations
 
-FloatRowVector
-FloatRowVector::map (dmapper fcn) const
-{
-  return MArray<float>::map<float> (func_ptr (fcn));
-}
-
-FloatComplexRowVector
-FloatRowVector::map (cmapper fcn) const
-{
-  return MArray<float>::map<FloatComplex> (func_ptr (fcn));
-}
-
 float
 FloatRowVector::min (void) const
 {
   octave_idx_type len = length ();
   if (len == 0)
     return 0;
 
   float res = elem (0);
diff --git a/liboctave/fRowVector.h b/liboctave/fRowVector.h
--- a/liboctave/fRowVector.h
+++ b/liboctave/fRowVector.h
@@ -76,22 +76,16 @@ public:
   FloatRowVector extract_n (octave_idx_type c1, octave_idx_type n) const;
 
   // row vector by matrix -> row vector
 
   friend OCTAVE_API FloatRowVector operator * (const FloatRowVector& a, const FloatMatrix& b);
 
   // other operations
 
-  typedef float (*dmapper) (float);
-  typedef FloatComplex (*cmapper) (const FloatComplex&);
-
-  FloatRowVector map (dmapper fcn) const;
-  FloatComplexRowVector map (cmapper fcn) const;
-
   float min (void) const;
   float max (void) const;
 
   // i/o
 
   friend OCTAVE_API std::ostream& operator << (std::ostream& os, const FloatRowVector& a);
   friend OCTAVE_API std::istream& operator >> (std::istream& is, FloatRowVector& a);
 
diff --git a/liboctave/lo-mappers.cc b/liboctave/lo-mappers.cc
--- a/liboctave/lo-mappers.cc
+++ b/liboctave/lo-mappers.cc
@@ -667,13 +667,101 @@ xmin (const FloatComplex& x, const Float
 }
 
 FloatComplex
 xmax (const FloatComplex& x, const FloatComplex& y)
 {
   return abs (x) >= abs (y) ? x : (xisnan (x) ? x : y);
 }
 
+Complex
+rc_acos (double x)
+{
+  return fabs (x) > 1.0 ? acos (Complex (x)) : Complex (acos (x));
+}
+
+FloatComplex
+rc_acos (float x)
+{
+  return fabsf (x) > 1.0f ? acos (FloatComplex (x)) : FloatComplex (acosf (x));
+}
+
+Complex rc_acosh (double x)
+{
+  return x < 1.0 ? acosh (Complex (x)) : Complex (acosh (x));
+}
+
+FloatComplex rc_acosh (float x)
+{
+  return x < 1.0f ? acosh (FloatComplex (x)) : FloatComplex (acoshf (x));
+}
+
+Complex rc_asin (double x)
+{
+  return fabs (x) > 1.0 ? asin (Complex (x)) : Complex (asin (x));
+}
+
+FloatComplex rc_asin (float x)
+{
+  return fabsf (x) > 1.0f ? asin (FloatComplex (x)) : FloatComplex (asinf (x));
+}
+
+Complex rc_atanh (double x)
+{
+  return fabs (x) > 1.0 ? atanh (Complex (x)) : Complex (atanh (x));
+}
+
+FloatComplex rc_atanh (float x)
+{
+  return fabsf (x) > 1.0f ? atanh (FloatComplex (x)) : FloatComplex (atanhf (x));
+}
+
+Complex rc_log (double x)
+{
+  const double pi = 3.14159265358979323846;
+  return x < 0.0 ? Complex (log (-x), pi) : Complex (log (x));
+}
+
+FloatComplex rc_log (float x)
+{
+  const float pi = 3.14159265358979323846f;
+  return x < 0.0f ? FloatComplex (logf (-x), pi) : FloatComplex (logf (x));
+}
+
+Complex rc_log2 (double x)
+{
+  const double pil2 = 4.53236014182719380962; // = pi / log(2)
+  return x < 0.0 ? Complex (xlog2 (-x), pil2) : Complex (xlog2 (x));
+}
+
+FloatComplex rc_log2 (float x)
+{
+  const float pil2 = 4.53236014182719380962f; // = pi / log(2)
+  return x < 0.0f ? FloatComplex (xlog2 (-x), pil2) : FloatComplex (xlog2 (x));
+}
+
+Complex rc_log10 (double x)
+{
+  const double pil10 = 1.36437635384184134748; // = pi / log(10)
+  return x < 0.0 ? Complex (log10 (-x), pil10) : Complex (log10 (x));
+}
+
+FloatComplex rc_log10 (float x)
+{
+  const float pil10 = 1.36437635384184134748f; // = pi / log(10)
+  return x < 0.0f ? FloatComplex (log10 (-x), pil10) : FloatComplex (log10f (x));
+}
+
+Complex rc_sqrt (double x)
+{
+  return x < 0.0 ? Complex (0.0, sqrt (-x)) : Complex (sqrt (x));
+}
+
+FloatComplex rc_sqrt (float x)
+{
+  return x < 0.0f ? FloatComplex (0.0f, sqrtf (-x)) : FloatComplex (sqrtf (x));
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/lo-mappers.h b/liboctave/lo-mappers.h
--- a/liboctave/lo-mappers.h
+++ b/liboctave/lo-mappers.h
@@ -169,15 +169,34 @@ xisinf (const FloatComplex& x)
 { return (xisinf (real (x)) || xisinf (imag (x))); }
 
 extern OCTAVE_API bool octave_is_NA (const FloatComplex& x);
 extern OCTAVE_API bool octave_is_NaN_or_NA (const FloatComplex& x);
 
 extern OCTAVE_API FloatComplex xmin (const FloatComplex& x, const FloatComplex& y);
 extern OCTAVE_API FloatComplex xmax (const FloatComplex& x, const FloatComplex& y);
 
+// These map reals to Complex.
+
+extern OCTAVE_API Complex rc_acos (double);
+extern OCTAVE_API FloatComplex rc_acos (float);
+extern OCTAVE_API Complex rc_acosh (double);
+extern OCTAVE_API FloatComplex rc_acosh (float);
+extern OCTAVE_API Complex rc_asin (double);
+extern OCTAVE_API FloatComplex rc_asin (float);
+extern OCTAVE_API Complex rc_atanh (double);
+extern OCTAVE_API FloatComplex rc_atanh (float);
+extern OCTAVE_API Complex rc_log (double);
+extern OCTAVE_API FloatComplex rc_log (float);
+extern OCTAVE_API Complex rc_log2 (double);
+extern OCTAVE_API FloatComplex rc_log2 (float);
+extern OCTAVE_API Complex rc_log10 (double);
+extern OCTAVE_API FloatComplex rc_log10 (float);
+extern OCTAVE_API Complex rc_sqrt (double);
+extern OCTAVE_API FloatComplex rc_sqrt (float);
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/lo-specfun.cc b/liboctave/lo-specfun.cc
--- a/liboctave/lo-specfun.cc
+++ b/liboctave/lo-specfun.cc
@@ -311,20 +311,18 @@ xlgamma (double x)
   else
     F77_XFCN (dlgams, DLGAMS, (x, result, sgngam));
 
   return result;
 #endif
 }
 
 Complex
-xlgamma (const Complex& xc)
+rc_lgamma (double x)
 {
-  // Can only be called with a real value of x.
-  double x = xc.real ();
   double result;
 
 #if defined (HAVE_LGAMMA_R)
   int sgngam;
   result = lgamma_r (x, &sgngam);    
 #else
   double sgngam;
 
@@ -378,20 +376,18 @@ xlgamma (float x)
   else
     F77_XFCN (algams, ALGAMS, (x, result, sgngam));
 
   return result;
 #endif
 }
 
 FloatComplex
-xlgamma (const FloatComplex& xc)
+rc_lgamma (float x)
 {
-  // Can only be called with a real value of x.
-  float x = xc.real ();
   float result;
 
 #if defined (HAVE_LGAMMAF_R)
   int sgngam;
   result = lgammaf_r (x, &sgngam);    
 #else
   float sgngam;
 
@@ -497,17 +493,17 @@ expm1f (float x)
   else
     retval = exp (x) - 1;
 
   return retval;
 }
 #endif
 
 FloatComplex 
-expm1f(const FloatComplex& x)
+expm1(const FloatComplex& x)
 {
   FloatComplex retval;
 
   if (std:: abs (x) < 1)
     {
       float im = x.imag();
       float u = expm1 (x.real ());
       float v = sin (im/2);
@@ -583,17 +579,17 @@ log1pf (float x)
   else
     retval = log (1 + x);
 
   return retval;
 }
 #endif
 
 FloatComplex 
-log1pf (const FloatComplex& x)
+log1p (const FloatComplex& x)
 {
   FloatComplex retval;
 
   float r = x.real (), i = x.imag();
 
   if (fabs (r) < 0.5 && fabs (i) < 0.5)
     {
       float u = 2*r + r*r + i*i;
@@ -3087,13 +3083,26 @@ gammainc (const FloatNDArray& x, const F
 	 x_str.c_str (), a_str. c_str ());
     }
 
  done:
 
   return retval;
 }
 
+
+Complex rc_log1p (double x)
+{
+  const double pi = 3.14159265358979323846;
+  return x < -1.0 ? Complex (log (-(1.0 + x)), pi) : Complex (log1p (x));
+}
+
+FloatComplex rc_log1p (float x)
+{
+  const float pi = 3.14159265358979323846f;
+  return x < -1.0f ? FloatComplex (logf (-(1.0f + x)), pi) : FloatComplex (log1pf (x));
+}
+
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/liboctave/lo-specfun.h b/liboctave/lo-specfun.h
--- a/liboctave/lo-specfun.h
+++ b/liboctave/lo-specfun.h
@@ -85,35 +85,35 @@ extern OCTAVE_API float erfcf (float);
 #if !defined (HAVE_EXPM1)
 extern OCTAVE_API double expm1 (double x);
 #endif
 extern OCTAVE_API Complex expm1 (const Complex& x);
 
 #if !defined (HAVE_EXPM1F)
 extern OCTAVE_API float expm1f (float x);
 #endif
-extern OCTAVE_API FloatComplex expm1f (const FloatComplex& x);
+extern OCTAVE_API FloatComplex expm1 (const FloatComplex& x);
 
 #if !defined (HAVE_LOG1P)
 extern OCTAVE_API double log1p (double x);
 #endif
 extern OCTAVE_API Complex log1p (const Complex& x);
 
 #if !defined (HAVE_LOG1PF)
 extern OCTAVE_API float log1pf (float x);
 #endif
-extern OCTAVE_API FloatComplex log1pf (const FloatComplex& x);
+extern OCTAVE_API FloatComplex log1p (const FloatComplex& x);
 
 extern OCTAVE_API double xgamma (double x);
 extern OCTAVE_API double xlgamma (double x);
-extern OCTAVE_API Complex xlgamma (const Complex& x);
+extern OCTAVE_API Complex rc_lgamma (double x);
 
 extern OCTAVE_API float xgamma (float x);
 extern OCTAVE_API float xlgamma (float x);
-extern OCTAVE_API FloatComplex xlgamma (const FloatComplex& x);
+extern OCTAVE_API FloatComplex rc_lgamma (float x);
 
 extern OCTAVE_API Complex
 besselj (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API Complex
 bessely (double alpha, const Complex& x, bool scaled, octave_idx_type& ierr);
 
 extern OCTAVE_API Complex
@@ -575,16 +575,19 @@ extern OCTAVE_API FloatNDArray gammainc 
 extern OCTAVE_API FloatNDArray gammainc (const FloatNDArray& x, const FloatNDArray& a);
 
 inline float gammainc (float x, float a)
 {
   bool err;
   return gammainc (x, a, err);
 }
 
+extern OCTAVE_API Complex rc_log1p (double);
+extern OCTAVE_API FloatComplex rc_log1p (float);
+
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
diff --git a/src/Cell.cc b/src/Cell.cc
--- a/src/Cell.cc
+++ b/src/Cell.cc
@@ -261,25 +261,29 @@ Cell::insert (const Cell& a, octave_idx_
 Cell&
 Cell::insert (const Cell& a, const Array<octave_idx_type>& ra_idx)
 {
   Array<octave_value>::insert (a, ra_idx);
   return *this;
 }
 
 Cell
-Cell::map (ctype_mapper fcn) const
+Cell::map (unary_mapper_t umap) const
 {
   Cell retval (dims ());
   octave_value *r = retval.fortran_vec ();
 
   const octave_value *p = data ();
 
   for (octave_idx_type i = 0; i < numel (); i++)
-    r[i] = ((p++)->*fcn) ();
+    {
+      r[i] = p[i].map (umap);
+      if (error_state)
+        break;
+    }
 
   return retval;
 }
 
 Cell
 Cell::diag (octave_idx_type k) const
 {
   return Array<octave_value>::diag (k);
diff --git a/src/Cell.h b/src/Cell.h
--- a/src/Cell.h
+++ b/src/Cell.h
@@ -99,37 +99,17 @@ public:
   // FIXME
   bool any_element_is_nan (void) const { return false; }
   bool is_true (void) const { return false; }
 
   static octave_value resize_fill_value (void) { return Matrix (); }
 
   Cell diag (octave_idx_type k = 0) const;
 
-  Cell xisalnum (void) const { return map (&octave_value::xisalnum); }
-  Cell xisalpha (void) const { return map (&octave_value::xisalpha); }
-  Cell xisascii (void) const { return map (&octave_value::xisascii); }
-  Cell xiscntrl (void) const { return map (&octave_value::xiscntrl); }
-  Cell xisdigit (void) const { return map (&octave_value::xisdigit); }
-  Cell xisgraph (void) const { return map (&octave_value::xisgraph); }
-  Cell xislower (void) const { return map (&octave_value::xislower); }
-  Cell xisprint (void) const { return map (&octave_value::xisprint); }
-  Cell xispunct (void) const { return map (&octave_value::xispunct); }
-  Cell xisspace (void) const { return map (&octave_value::xisspace); }
-  Cell xisupper (void) const { return map (&octave_value::xisupper); }
-  Cell xisxdigit (void) const { return map (&octave_value::xisxdigit); }
-  Cell xtoascii (void) const { return map (&octave_value::xtoascii); }
-  Cell xtolower (void) const { return map (&octave_value::xtolower); }
-  Cell xtoupper (void) const { return map (&octave_value::xtoupper); }
-
-private:
-
-  typedef octave_value (octave_value::*ctype_mapper) (void) const;
-
-  Cell map (ctype_mapper) const;
+  Cell map (unary_mapper_t umap) const;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,130 @@
+2009-11-12  Jaroslav Hajek  <highegg@gmail.com>
+
+	* ov-base.h (unary_mapper_t): New enum.
+	(octave_base_value::map (unary_mapper_t)): New method.
+	(octave_base_value::abs): Remove.
+	(octave_base_value::acos): Remove.
+	(octave_base_value::acosh): Remove.
+	(octave_base_value::angle): Remove.
+	(octave_base_value::arg): Remove.
+	(octave_base_value::asin): Remove.
+	(octave_base_value::asinh): Remove.
+	(octave_base_value::atan): Remove.
+	(octave_base_value::atanh): Remove.
+	(octave_base_value::ceil): Remove.
+	(octave_base_value::conj): Remove.
+	(octave_base_value::cos): Remove.
+	(octave_base_value::cosh): Remove.
+	(octave_base_value::erf): Remove.
+	(octave_base_value::erfc): Remove.
+	(octave_base_value::exp): Remove.
+	(octave_base_value::expm1): Remove.
+	(octave_base_value::finite): Remove.
+	(octave_base_value::fix): Remove.
+	(octave_base_value::floor): Remove.
+	(octave_base_value::gamma): Remove.
+	(octave_base_value::imag): Remove.
+	(octave_base_value::isinf): Remove.
+	(octave_base_value::isna): Remove.
+	(octave_base_value::isnan): Remove.
+	(octave_base_value::lgamma): Remove.
+	(octave_base_value::log): Remove.
+	(octave_base_value::log2): Remove.
+	(octave_base_value::log10): Remove.
+	(octave_base_value::log1p): Remove.
+	(octave_base_value::real): Remove.
+	(octave_base_value::round): Remove.
+	(octave_base_value::roundb): Remove.
+	(octave_base_value::signum): Remove.
+	(octave_base_value::sin): Remove.
+	(octave_base_value::sinh): Remove.
+	(octave_base_value::sqrt): Remove.
+	(octave_base_value::tan): Remove.
+	(octave_base_value::tanh): Remove.
+
+	* ov.h 
+	(octave_value::map (unary_mapper_t)): New method.
+	(octave_value::abs): Remove.
+	(octave_value::acos): Remove.
+	(octave_value::acosh): Remove.
+	(octave_value::angle): Remove.
+	(octave_value::arg): Remove.
+	(octave_value::asin): Remove.
+	(octave_value::asinh): Remove.
+	(octave_value::atan): Remove.
+	(octave_value::atanh): Remove.
+	(octave_value::ceil): Remove.
+	(octave_value::conj): Remove.
+	(octave_value::cos): Remove.
+	(octave_value::cosh): Remove.
+	(octave_value::erf): Remove.
+	(octave_value::erfc): Remove.
+	(octave_value::exp): Remove.
+	(octave_value::expm1): Remove.
+	(octave_value::finite): Remove.
+	(octave_value::fix): Remove.
+	(octave_value::floor): Remove.
+	(octave_value::gamma): Remove.
+	(octave_value::imag): Remove.
+	(octave_value::isinf): Remove.
+	(octave_value::isna): Remove.
+	(octave_value::isnan): Remove.
+	(octave_value::lgamma): Remove.
+	(octave_value::log): Remove.
+	(octave_value::log2): Remove.
+	(octave_value::log10): Remove.
+	(octave_value::log1p): Remove.
+	(octave_value::real): Remove.
+	(octave_value::round): Remove.
+	(octave_value::roundb): Remove.
+	(octave_value::signum): Remove.
+	(octave_value::sin): Remove.
+	(octave_value::sinh): Remove.
+	(octave_value::sqrt): Remove.
+	(octave_value::tan): Remove.
+	(octave_value::tanh): Remove.
+
+	* ov-scalar.h, ov-scalar.cc (octave_scalar): Update.
+	* ov-float.h, ov-float.cc (octave_float): Update.
+
+	* ov-complex.h, ov-complex.cc (octave_complex): Update.
+	* ov-flt-complex.h, ov-flt-complex.cc (octave_float_complex): Update.
+
+	* ov-re-matrix.h ov-re-matrix.cc (octave_matrix): Update.
+	* ov-flt-re-matrix.h ov-flt-re-matrix.cc (octave_float_matrix): Update.
+	* ov-cx-matrix.h ov-cx-matrix.cc (octave_complex_matrix): Update.
+	* ov-flt-cx-matrix.h ov-flt-cx-matrix.cc (octave_float_complex_matrix): Update.
+
+	* ov-re-sparse.h ov-re-sparse.cc (octave_sparse_matrix): Update.
+	* ov-cx-sparse.h ov-cx-sparse.cc (octave_sparse_complex_matrix): Update.
+
+	* ov-re-diag.h ov-re-diag.cc (octave_diag_matrix): Update.
+	* ov-flt-re-diag.h ov-flt-re-diag.cc (octave_float_diag_matrix): Update.
+	* ov-cx-diag.h ov-cx-diag.cc (octave_complex_diag_matrix): Update.
+	* ov-flt-cx-diag.h ov-flt-cx-diag.cc (octave_float_complex_diag_matrix): Update.
+
+	* ov-range.h (octave_range): Update.
+	* ov-intx.h (OCTAVE_VALUE_INT_MATRIX_T): Update.
+	(OCTAVE_VALUE_INT_SCALAR_T): Update.
+
+	* ov-perm.h (octave_perm_matrix): Update.
+	* ov-bool.h (octave_bool): Update.
+	* ov-bool-mat.h (octave_bool_matrix): Update.
+	* ov-ch-mat.h (octave_char_matrix): Update.
+
+	* mappers.cc (Fabs, Facos, Facosh, Fangle, Farg, Fasin, Fasinh,
+	Fatan, Fatanh, Fceil, Fconj, Fcos, Fcosh, Ferf, Ferfc, Fexp, Fexpm1,
+	Ffinite, Ffix, Ffloor, Fgamma, Fimag, Fisinf, Fisna, Fisnan, Flgamma,
+	Flog, Flog2, Flog10, Flog1p, Freal, Fround, Froundb, Fsignum, Fsin,
+	Fsinh, Fsqrt, Ftan, Ftanh, Fisalnum, Fisalpha, Fisascii, Fiscntrl,
+	Fisdigit, Fisgraph, Fislower, Fisprint, Fispunct, Fisspace, Fisupper,
+	Fisxdigit, Ftoascii, Ftolower, Ftoupper): Update.
+
 2009-11-11  John W. Eaton  <jwe@octave.org>
 
 	* load-path.cc (load_path::do_find_all_first_of): Take advantage
 	of string_vector (std::list<std:string>) constructor.
 
 2009-11-11  John W. Eaton  <jwe@octave.org>
 
 	* help.cc (do_get_help_text_from_file, Fget_help_text_from_file):
diff --git a/src/DLD-FUNCTIONS/lookup.cc b/src/DLD-FUNCTIONS/lookup.cc
--- a/src/DLD-FUNCTIONS/lookup.cc
+++ b/src/DLD-FUNCTIONS/lookup.cc
@@ -222,20 +222,20 @@ For string lookup, 'i' indicates case-in
 
   if (num_case) 
     {
 
       // In the case of a complex array, absolute values will be used for compatibility
       // (though it's not too meaningful).
       
       if (table.is_complex_type ())
-        table = table.abs ();
+        table = table.map (umap_abs);
 
       if (y.is_complex_type ())
-        y = y.abs ();
+        y = y.map (umap_abs);
 
       Array<octave_idx_type> idx;
 
       // PS: I learned this from data.cc
       if INT_ARRAY_LOOKUP (int8)
       else if INT_ARRAY_LOOKUP (int16)
       else if INT_ARRAY_LOOKUP (int32)
       else if INT_ARRAY_LOOKUP (int64)
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -973,130 +973,16 @@ avoids overflows for large values of @va
 %!assert (size (hypot (rand (2, 3, 4), zeros (2, 3, 4))), [2, 3, 4])
 %!assert (size (hypot (rand (2, 3, 4), 1)), [2, 3, 4])
 %!assert (size (hypot (1, rand (2, 3, 4))), [2, 3, 4])
 %!assert (size (hypot (1, 2)), [1, 1])
 %!assert (hypot (1:10, 1:10), sqrt(2) * [1:10], 16*eps)
 %!assert (hypot (single(1:10), single(1:10)), single(sqrt(2) * [1:10]));
 */
 
-template<typename T, typename ET>
-void 
-map_2_xlog2 (const Array<T>& x, Array<T>& f, Array<ET>& e)
-{
-  f = Array<T>(x.dims ());
-  e = Array<ET>(x.dims ());
-  for (octave_idx_type i = 0; i < x.numel (); i++)
-    {
-      int exp;
-      f.xelem (i) = xlog2 (x(i), exp);
-      e.xelem (i) = exp;
-    }
-}
-
-DEFUN (log2, args, nargout,
-  "-*- texinfo -*-\n\
-@deftypefn {Mapping Function} {} log2 (@var{x})\n\
-@deftypefnx {Mapping Function} {[@var{f}, @var{e}] =} log2 (@var{x})\n\
-Compute the base-2 logarithm of each element of @var{x}.\n\
-\n\
-If called with two output arguments, split @var{x} into\n\
-binary mantissa and exponent so that\n\
-@tex\n\
-${1 \\over 2} \\le \\left| f \\right| < 1$\n\
-@end tex\n\
-@ifnottex\n\
-@code{1/2 <= abs(f) < 1}\n\
-@end ifnottex\n\
-and @var{e} is an integer.  If\n\
-@tex\n\
-$x = 0$, $f = e = 0$.\n\
-@end tex\n\
-@ifnottex\n\
-@code{x = 0}, @code{f = e = 0}.\n\
-@end ifnottex\n\
-@seealso{pow2, log, log10, exp}\n\
-@end deftypefn")
-{
-  octave_value_list retval;
-
-  if (args.length () == 1)
-    {
-      if (nargout < 2)
-        retval(0) = args(0).log2 ();
-      else if (args(0).is_single_type ())
-	{
-	  if (args(0).is_real_type ())
-	    {
-	      FloatNDArray f;
-	      FloatNDArray x = args(0).float_array_value ();
-	      // FIXME -- should E be an int value?
-	      FloatMatrix e;
-	      map_2_xlog2 (x, f, e);
-	      retval (1) = e;
-	      retval (0) = f;
-	    }
-	  else if (args(0).is_complex_type ())
-	    {
-	      FloatComplexNDArray f;
-	      FloatComplexNDArray x = args(0).float_complex_array_value ();
-	      // FIXME -- should E be an int value?
-	      FloatNDArray e;
-	      map_2_xlog2 (x, f, e);
-	      retval (1) = e;
-	      retval (0) = f;
-	    }
-	}
-      else if (args(0).is_real_type ())
-        {
-          NDArray f;
-          NDArray x = args(0).array_value ();
-          // FIXME -- should E be an int value?
-          Matrix e;
-          map_2_xlog2 (x, f, e);
-          retval (1) = e;
-          retval (0) = f;
-        }
-      else if (args(0).is_complex_type ())
-        {
-          ComplexNDArray f;
-          ComplexNDArray x = args(0).complex_array_value ();
-          // FIXME -- should E be an int value?
-          NDArray e;
-          map_2_xlog2 (x, f, e);
-          retval (1) = e;
-          retval (0) = f;
-        }
-      else
-        gripe_wrong_type_arg ("log2", args(0));
-    }
-  else
-    print_usage ();
-
-  return retval;
-}
-
-/*
-%!assert(log2 ([1/4, 1/2, 1, 2, 4]), [-2, -1, 0, 1, 2]);
-%!assert(log2(Inf), Inf);
-%!assert(isnan(log2(NaN)));
-%!assert(log2(4*i), 2 + log2(1*i));
-%!assert(log2(complex(0,Inf)), Inf + log2(i));
-
-%!test
-%! [f, e] = log2 ([0,-1; 2,-4; Inf,-Inf]);
-%! assert (f, [0,-0.5; 0.5,-0.5; Inf,-Inf]);
-%! assert (e(1:2,:), [0,1;2,3])
-
-%!test
-%! [f, e] = log2 (complex (zeros (3, 2), [0,-1; 2,-4; Inf,-Inf]));
-%! assert (f, complex (zeros (3, 2), [0,-0.5; 0.5,-0.5; Inf,-Inf]));
-%! assert (e(1:2,:), [0,1; 2,3]);
-*/
-
 DEFUN (fmod, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} fmod (@var{x}, @var{y})\n\
 Compute the floating point remainder of dividing @var{x} by @var{y}\n\
 using the C library function @code{fmod}.  The result has the same\n\
 sign as @var{x}.  If @var{y} is zero, the result is implementation-dependent.\n\
 @seealso{mod, rem}\n\
 @end deftypefn")
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -30,16 +30,17 @@ along with Octave; see the file COPYING.
 
 #include "lo-ieee.h"
 #include "lo-specfun.h"
 #include "lo-mappers.h"
 
 #include "defun.h"
 #include "error.h"
 #include "variables.h"
+#include "gripes.h"
 
 DEFUN (abs, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} abs (@var{z})\n\
 Compute the magnitude of @var{z}, defined as\n\
 @tex\n\
 $|z| = \\sqrt{x^2 + y^2}$.\n\
 @end tex\n\
@@ -54,17 +55,17 @@ For example,\n\
 abs (3 + 4i)\n\
      @result{} 5\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).abs ();
+    retval = args(0).map (umap_abs);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -89,17 +90,17 @@ DEFUN (acos, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} acos (@var{x})\n\
 Compute the inverse cosine in radians for each element of @var{x}.\n\
 @seealso{cos, acosd}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).acos ();
+    retval = args(0).map (umap_acos);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -126,17 +127,17 @@ DEFUN (acosh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} acosh (@var{x})\n\
 Compute the inverse hyperbolic cosine for each element of @var{x}.\n\
 @seealso{cosh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).acosh ();
+    retval = args(0).map (umap_acosh);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -158,17 +159,17 @@ Compute the inverse hyperbolic cosine fo
 DEFUN (angle, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} angle (@var{z})\n\
 See arg.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).arg ();
+    retval = args(0).map (umap_arg);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (arg, args, ,
     "-*- texinfo -*-\n\
@@ -190,17 +191,17 @@ For example,\n\
 arg (3 + 4i)\n\
      @result{} 0.92730\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).arg ();
+    retval = args(0).map (umap_arg);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -225,17 +226,17 @@ DEFUN (asin, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} asin (@var{x})\n\
 Compute the inverse sine in radians for each element of @var{x}.\n\
 @seealso{sin, asind}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).asin ();
+    retval = args(0).map (umap_asin);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 %!test
@@ -252,17 +253,17 @@ DEFUN (asinh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} asinh (@var{x})\n\
 Compute the inverse hyperbolic sine for each element of @var{x}.\n\
 @seealso{sinh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).asinh ();
+    retval = args(0).map (umap_asinh);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -285,17 +286,17 @@ DEFUN (atan, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atan (@var{x})\n\
 Compute the inverse tangent in radians for each element of @var{x}.\n\
 @seealso{tan, atand}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).atan ();
+    retval = args(0).map (umap_atan);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -322,17 +323,17 @@ DEFUN (atanh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} atanh (@var{x})\n\
 Compute the inverse hyperbolic tangent for each element of @var{x}.\n\
 @seealso{tanh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).atanh ();
+    retval = args(0).map (umap_atanh);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -363,17 +364,17 @@ ceil ([-2.7, 2.7])\n\
    @result{}  -2   3\n\
 @end group\n\
 @end example\n\
 @seealso{floor, round, fix}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).ceil ();
+    retval = args(0).map (umap_ceil);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -404,17 +405,17 @@ Return the complex conjugate of @var{z},
 @ifnottex\n\
 @code{conj (@var{z})} = @var{x} - @var{i}@var{y}.\n\
 @end ifnottex\n\
 @seealso{real, imag}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).conj ();
+    retval = args(0).map (umap_conj);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -439,17 +440,17 @@ DEFUN (cos, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cos (@var{x})\n\
 Compute the cosine for each element of @var{x} in radians.\n\
 @seealso{acos, cosd, cosh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).cos ();
+    retval = args(0).map (umap_cos);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -476,17 +477,17 @@ DEFUN (cosh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} cosh (@var{x})\n\
 Compute the hyperbolic cosine for each element of @var{x}.\n\
 @seealso{acosh, sinh, tanh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).cosh ();
+    retval = args(0).map (umap_cosh);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -526,17 +527,17 @@ erf (z) = (2/sqrt (pi)) | e^(-t^2) dt\n\
 @end group\n\
 @end example\n\
 @end ifnottex\n\
 @seealso{erfc, erfinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).erf ();
+    retval = args(0).map (umap_erf);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -578,17 +579,17 @@ Computes the complementary error functio
 @ifnottex\n\
 @code{1 - erf (@var{z})}.\n\
 @end ifnottex\n\
 @seealso{erf, erfinv}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).erfc ();
+    retval = args(0).map (umap_erfc);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -610,17 +611,17 @@ Compute\n\
 @end ifnottex\n\
 for each element of @var{x}.  To compute the matrix\n\
 exponential, see @ref{Linear Algebra}.\n\
 @seealso{log}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).exp ();
+    retval = args(0).map (umap_exp);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -648,17 +649,17 @@ Compute\n\
 @code{exp (@var{x}) - 1}\n\
 @end ifnottex\n\
 accurately in the neighborhood of zero.\n\
 @seealso{exp}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).expm1 ();
+    retval = args(0).map (umap_expm1);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (finite, args, ,
     "-*- texinfo -*-\n\
@@ -671,17 +672,17 @@ otherwise.  For example,\n\
 finite ([13, Inf, NA, NaN])\n\
      @result{} [ 1, 0, 0, 0 ]\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).finite ();
+    retval = args(0).map (umap_finite);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -707,17 +708,17 @@ fix ([-2.7, 2.7])\n\
    @result{} -2   2\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, floor, round}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).fix ();
+    retval = args(0).map (umap_fix);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -743,17 +744,17 @@ floor ([-2.7, 2.7])\n\
      @result{} -3   2\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, round, fix}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).floor ();
+    retval = args(0).map (umap_floor);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -788,17 +789,17 @@ gamma (z) = | t^(z-1) exp (-t) dt.\n\
 @end group\n\
 @end example\n\
 @end ifnottex\n\
 @seealso{gammainc, lgamma}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).gamma ();
+    retval = args(0).map (umap_gamma);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -829,17 +830,17 @@ DEFUN (imag, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} imag (@var{z})\n\
 Return the imaginary part of @var{z} as a real number.\n\
 @seealso{real, conj}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).imag ();
+    retval = args(0).map (umap_imag);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -862,79 +863,79 @@ DEFUNX ("isalnum", Fisalnum, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isalnum (@var{s})\n\
 Return 1 for characters that are letters or digits (@code{isalpha\n\
 (@var{s})} or @code{isdigit (@var{s})} is true).\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).xisalnum ();
+    retval = args(0).map (umap_isalnum);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("isalpha", Fisalpha, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isalpha (@var{s})\n\
 @deftypefnx {Mapping Function} {} isletter (@var{s})\n\
 Return true for characters that are letters (@code{isupper (@var{s})}\n\
 or @code{islower (@var{s})} is true).\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).xisalpha ();
+    retval = args(0).map (umap_isalpha);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("isascii", Fisascii, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isascii (@var{s})\n\
 Return 1 for characters that are ASCII (in the range 0 to 127 decimal).\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).xisascii ();
+    retval = args(0).map (umap_isascii);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("iscntrl", Fiscntrl, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} iscntrl (@var{s})\n\
 Return 1 for control characters.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).xiscntrl ();
+    retval = args(0).map (umap_iscntrl);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("isdigit", Fisdigit, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isdigit (@var{s})\n\
 Return 1 for characters that are decimal digits.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).xisdigit ();
+    retval = args(0).map (umap_isdigit);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (isinf, args, ,
     "-*- texinfo -*-\n\
@@ -947,17 +948,17 @@ otherwise.  For example,\n\
 isinf ([13, Inf, NA, NaN])\n\
      @result{} [ 0, 1, 0, 0 ]\n\
 @end group\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).isinf ();
+    retval = args(0).map (umap_isinf);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -978,32 +979,32 @@ isinf ([13, Inf, NA, NaN])\n\
 DEFUNX ("isgraph", Fisgraph, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isgraph (@var{s})\n\
 Return 1 for printable characters (but not the space character).\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).xisgraph ();
+    retval = args(0).map (umap_isgraph);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("islower", Fislower, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} islower (@var{s})\n\
 Return 1 for characters that are lower case letters.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).xislower ();
+    retval = args(0).map (umap_islower);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (isna, args, ,
     "-*- texinfo -*-\n\
@@ -1017,17 +1018,17 @@ isna ([13, Inf, NA, NaN])\n\
      @result{} [ 0, 0, 1, 0 ]\n\
 @end group\n\
 @end example\n\
 @seealso{isnan}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).isna ();
+    retval = args(0).map (umap_isna);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1057,17 +1058,17 @@ isnan ([13, Inf, NA, NaN])\n\
      @result{} [ 0, 0, 1, 1 ]\n\
 @end group\n\
 @end example\n\
 @seealso{isna}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).isnan ();
+    retval = args(0).map (umap_isnan);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1088,95 +1089,95 @@ isnan ([13, Inf, NA, NaN])\n\
 DEFUNX ("isprint", Fisprint, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isprint (@var{s})\n\
 Return 1 for printable characters (including the space character).\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).xisprint ();
+    retval = args(0).map (umap_isprint);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("ispunct", Fispunct, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} ispunct (@var{s})\n\
 Return 1 for punctuation characters.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).xispunct ();
+    retval = args(0).map (umap_ispunct);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("isspace", Fisspace, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isspace (@var{s})\n\
 Return 1 for whitespace characters (space, formfeed, newline,\n\
 carriage return, tab, and vertical tab).\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).xisspace ();
+    retval = args(0).map (umap_isspace);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("isupper", Fisupper, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isupper (@var{s})\n\
 Return 1 for upper case letters.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).xisupper ();
+    retval = args(0).map (umap_isupper);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("isxdigit", Fisxdigit, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} isxdigit (@var{s})\n\
 Return 1 for characters that are hexadecimal digits.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).xisxdigit ();
+    retval = args(0).map (umap_isxdigit);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (lgamma, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} lgamma (@var{x})\n\
 @deftypefnx {Mapping Function} {} gammaln (@var{x})\n\
 Return the natural logarithm of the gamma function of @var{x}.\n\
 @seealso{gamma, gammainc}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).lgamma ();
+    retval = args(0).map (umap_lgamma);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1215,17 +1216,17 @@ Compute the natural logarithm,\n\
 @end ifnottex\n\
 for each element of @var{x}.  To compute the\n\
 matrix logarithm, see @ref{Linear Algebra}.\n\
 @seealso{exp, log1p, log2, log10, logspace}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).log ();
+    retval = args(0).map (umap_log);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1235,26 +1236,140 @@ matrix logarithm, see @ref{Linear Algebr
 %!assert(log (single([1, e, e^2])), single([0, 1, 2]), sqrt (eps('single')));
 %!assert(log (single([-0.5, -1.5, -2.5])), single(log([0.5, 1.5, 2.5]) + pi*1i), 4*eps('single'));
 
 %!error log ();
 %!error log (1, 2);
 
  */
 
+template<typename T, typename ET>
+void 
+map_2_xlog2 (const Array<T>& x, Array<T>& f, Array<ET>& e)
+{
+  f = Array<T>(x.dims ());
+  e = Array<ET>(x.dims ());
+  for (octave_idx_type i = 0; i < x.numel (); i++)
+    {
+      int exp;
+      f.xelem (i) = xlog2 (x(i), exp);
+      e.xelem (i) = exp;
+    }
+}
+
+DEFUN (log2, args, nargout,
+  "-*- texinfo -*-\n\
+@deftypefn {Mapping Function} {} log2 (@var{x})\n\
+@deftypefnx {Mapping Function} {[@var{f}, @var{e}] =} log2 (@var{x})\n\
+Compute the base-2 logarithm of each element of @var{x}.\n\
+\n\
+If called with two output arguments, split @var{x} into\n\
+binary mantissa and exponent so that\n\
+@tex\n\
+${1 \\over 2} \\le \\left| f \\right| < 1$\n\
+@end tex\n\
+@ifnottex\n\
+@code{1/2 <= abs(f) < 1}\n\
+@end ifnottex\n\
+and @var{e} is an integer.  If\n\
+@tex\n\
+$x = 0$, $f = e = 0$.\n\
+@end tex\n\
+@ifnottex\n\
+@code{x = 0}, @code{f = e = 0}.\n\
+@end ifnottex\n\
+@seealso{pow2, log, log10, exp}\n\
+@end deftypefn")
+{
+  octave_value_list retval;
+
+  if (args.length () == 1)
+    {
+      if (nargout < 2)
+        retval(0) = args(0).map (umap_log2);
+      else if (args(0).is_single_type ())
+	{
+	  if (args(0).is_real_type ())
+	    {
+	      FloatNDArray f;
+	      FloatNDArray x = args(0).float_array_value ();
+	      // FIXME -- should E be an int value?
+	      FloatMatrix e;
+	      map_2_xlog2 (x, f, e);
+	      retval (1) = e;
+	      retval (0) = f;
+	    }
+	  else if (args(0).is_complex_type ())
+	    {
+	      FloatComplexNDArray f;
+	      FloatComplexNDArray x = args(0).float_complex_array_value ();
+	      // FIXME -- should E be an int value?
+	      FloatNDArray e;
+	      map_2_xlog2 (x, f, e);
+	      retval (1) = e;
+	      retval (0) = f;
+	    }
+	}
+      else if (args(0).is_real_type ())
+        {
+          NDArray f;
+          NDArray x = args(0).array_value ();
+          // FIXME -- should E be an int value?
+          Matrix e;
+          map_2_xlog2 (x, f, e);
+          retval (1) = e;
+          retval (0) = f;
+        }
+      else if (args(0).is_complex_type ())
+        {
+          ComplexNDArray f;
+          ComplexNDArray x = args(0).complex_array_value ();
+          // FIXME -- should E be an int value?
+          NDArray e;
+          map_2_xlog2 (x, f, e);
+          retval (1) = e;
+          retval (0) = f;
+        }
+      else
+        gripe_wrong_type_arg ("log2", args(0));
+    }
+  else
+    print_usage ();
+
+  return retval;
+}
+
+/*
+%!assert(log2 ([1/4, 1/2, 1, 2, 4]), [-2, -1, 0, 1, 2]);
+%!assert(log2(Inf), Inf);
+%!assert(isnan(log2(NaN)));
+%!assert(log2(4*i), 2 + log2(1*i));
+%!assert(log2(complex(0,Inf)), Inf + log2(i));
+
+%!test
+%! [f, e] = log2 ([0,-1; 2,-4; Inf,-Inf]);
+%! assert (f, [0,-0.5; 0.5,-0.5; Inf,-Inf]);
+%! assert (e(1:2,:), [0,1;2,3])
+
+%!test
+%! [f, e] = log2 (complex (zeros (3, 2), [0,-1; 2,-4; Inf,-Inf]));
+%! assert (f, complex (zeros (3, 2), [0,-0.5; 0.5,-0.5; Inf,-Inf]));
+%! assert (e(1:2,:), [0,1; 2,3]);
+*/
+
 DEFUN (log10, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} log10 (@var{x})\n\
 Compute the base-10 logarithm of each element of @var{x}.\n\
 @seealso{log, log2, logspace, exp}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).log10 ();
+    retval = args(0).map (umap_log10);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1277,33 +1392,33 @@ Compute\n\
 @code{log (1 + @var{x})}\n\
 @end ifnottex\n\
 accurately in the neighborhood of zero.\n\
 @seealso{log, exp, expm1}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).log1p ();
+    retval = args(0).map (umap_log1p);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (real, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} real (@var{z})\n\
 Return the real part of @var{z}.\n\
 @seealso{imag, conj}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).real ();
+    retval = args(0).map (umap_real);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1333,17 +1448,17 @@ round ([-2.7, 2.7])\n\
      @result{} -3   3\n\
 @end group\n\
 @end example\n\
 @seealso{ceil, floor, fix}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).round ();
+    retval = args(0).map (umap_round);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1374,17 +1489,17 @@ DEFUN (roundb, args, ,
 Return the integer nearest to @var{x}.  If there are two nearest\n\
 integers, return the even one (banker's rounding).  If @var{x} is complex,\n\
 return @code{roundb (real (@var{x})) + roundb (imag (@var{x})) * I}.\n\
 @seealso{round}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).roundb ();
+    retval = args(0).map (umap_roundb);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (sign, args, ,
     "-*- texinfo -*-\n\
@@ -1406,17 +1521,17 @@ sign (x) =  0, x = 0;\n\
 @end example\n\
 @end ifnottex\n\
 \n\
 For complex arguments, @code{sign} returns @code{x ./ abs (@var{x})}.\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).signum ();
+    retval = args(0).map (umap_signum);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1439,17 +1554,17 @@ DEFUN (sin, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sin (@var{x})\n\
 Compute the sine for each element of @var{x} in radians.\n\
 @seealso{asin, sind, sinh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).sin ();
+    retval = args(0).map (umap_sin);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1476,17 +1591,17 @@ DEFUN (sinh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} sinh (@var{x})\n\
 Compute the hyperbolic sine for each element of @var{x}.\n\
 @seealso{asinh, cosh, tanh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).sinh ();
+    retval = args(0).map (umap_sinh);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1511,17 +1626,17 @@ DEFUN (sqrt, args, ,
 Compute the square root of each element of @var{x}.  If @var{x} is negative,\n\
 a complex result is returned.  To compute the matrix square root, see\n\
 @ref{Linear Algebra}.\n\
 @seealso{realsqrt}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).sqrt ();
+    retval = args(0).map (umap_sqrt);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1544,17 +1659,17 @@ DEFUN (tan, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tan (@var{z})\n\
 Compute the tangent for each element of @var{x} in radians.\n\
 @seealso{atan, tand, tanh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).tan ();
+    retval = args(0).map (umap_tan);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1581,17 +1696,17 @@ DEFUN (tanh, args, ,
     "-*- texinfo -*-\n\
 @deftypefn {Mapping Function} {} tanh (@var{x})\n\
 Compute hyperbolic tangent for each element of @var{x}.\n\
 @seealso{atanh, sinh, cosh}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).tanh ();
+    retval = args(0).map (umap_tanh);
   else
     print_usage ();
 
   return retval;
 }
 
 /*
 
@@ -1622,17 +1737,17 @@ toascii (\"ASCII\")\n\
 @end group\n\
 \n\
 @end example\n\
 @seealso{char}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).xtoascii ();
+    retval = args(0).map (umap_toascii);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("tolower", Ftolower, args, ,
     "-*- texinfo -*-\n\
@@ -1648,17 +1763,17 @@ tolower (\"MiXeD cAsE 123\")\n\
      @result{} \"mixed case 123\"\n\
 @end group\n\
 @end example\n\
 @seealso{toupper}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).xtolower ();
+    retval = args(0).map (umap_tolower);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (lower, tolower);
 
@@ -1694,17 +1809,17 @@ toupper (\"MiXeD cAsE 123\")\n\
      @result{} \"MIXED CASE 123\"\n\
 @end group\n\
 @end example\n\
 @seealso{tolower}\n\
 @end deftypefn")
 {
   octave_value retval;
   if (args.length () == 1)
-    retval = args(0).xtoupper ();
+    retval = args(0).map (umap_toupper);
   else
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (upper, toupper);
 
diff --git a/src/ov-base-diag.cc b/src/ov-base-diag.cc
--- a/src/ov-base-diag.cc
+++ b/src/ov-base-diag.cc
@@ -500,51 +500,8 @@ octave_value
 octave_base_diag<DMT, MT>::to_dense (void) const
 {
   if (! dense_cache.is_defined ())
     dense_cache = MT (matrix);
 
   return dense_cache;
 }
 
-#define FORWARD_MAPPER(MAP) \
-  template <class DMT, class MT> \
-  octave_value \
-  octave_base_diag<DMT, MT>::MAP (void) const \
-  { \
-    return to_dense ().MAP (); \
-  }
-
-FORWARD_MAPPER (erf)
-FORWARD_MAPPER (erfc)
-FORWARD_MAPPER (gamma)
-FORWARD_MAPPER (lgamma)
-FORWARD_MAPPER (acos)
-FORWARD_MAPPER (acosh)
-FORWARD_MAPPER (angle)
-FORWARD_MAPPER (arg)
-FORWARD_MAPPER (asin)
-FORWARD_MAPPER (asinh)
-FORWARD_MAPPER (atan)
-FORWARD_MAPPER (atanh)
-FORWARD_MAPPER (ceil)
-FORWARD_MAPPER (cos)
-FORWARD_MAPPER (cosh)
-FORWARD_MAPPER (exp)
-FORWARD_MAPPER (expm1)
-FORWARD_MAPPER (fix)
-FORWARD_MAPPER (floor)
-FORWARD_MAPPER (log)
-FORWARD_MAPPER (log2)
-FORWARD_MAPPER (log10)
-FORWARD_MAPPER (log1p)
-FORWARD_MAPPER (round)
-FORWARD_MAPPER (roundb)
-FORWARD_MAPPER (signum)
-FORWARD_MAPPER (sin)
-FORWARD_MAPPER (sinh)
-FORWARD_MAPPER (tan)
-FORWARD_MAPPER (tanh)
-FORWARD_MAPPER (finite)
-FORWARD_MAPPER (isinf)
-FORWARD_MAPPER (isna)
-FORWARD_MAPPER (isnan)
-
diff --git a/src/ov-base-diag.h b/src/ov-base-diag.h
--- a/src/ov-base-diag.h
+++ b/src/ov-base-diag.h
@@ -203,52 +203,16 @@ public:
   mxArray *as_mxArray (void) const;
 
   bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_info (std::ostream& os, const std::string& prefix) const;
 
-  // We forward everything except abs, real, imag, conj, sqrt.
-  octave_value erf (void) const;
-  octave_value erfc (void) const;
-  octave_value gamma (void) const;
-  octave_value lgamma (void) const;
-  octave_value acos (void) const;
-  octave_value acosh (void) const;
-  octave_value angle (void) const;
-  octave_value arg (void) const;
-  octave_value asin (void) const;
-  octave_value asinh (void) const;
-  octave_value atan (void) const;
-  octave_value atanh (void) const;
-  octave_value ceil (void) const;
-  octave_value cos (void) const;
-  octave_value cosh (void) const;
-  octave_value exp (void) const;
-  octave_value expm1 (void) const;
-  octave_value fix (void) const;
-  octave_value floor (void) const;
-  octave_value log (void) const;
-  octave_value log2 (void) const;
-  octave_value log10 (void) const;
-  octave_value log1p (void) const;
-  octave_value round (void) const;
-  octave_value roundb (void) const;
-  octave_value signum (void) const;
-  octave_value sin (void) const;
-  octave_value sinh (void) const;
-  octave_value tan (void) const;
-  octave_value tanh (void) const;
-  octave_value finite (void) const;
-  octave_value isinf (void) const;
-  octave_value isna (void) const;
-  octave_value isnan (void) const;
-
 protected:
 
   DMT matrix;
 
   octave_value to_dense (void) const;
 
   virtual bool chk_valid_scalar (const octave_value&, 
                                  typename DMT::element_type&) const = 0;
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -1112,89 +1112,89 @@ octave_base_value::sort_rows_idx (sortmo
 sortmode
 octave_base_value::is_sorted_rows (sortmode) const
 {
   gripe_wrong_type_arg ("octave_base_value::is_sorted_rows ()", type_name ());
 
   return UNSORTED;
 }
 
-#define UNDEFINED_MAPPER(F) \
-  octave_value \
-  octave_base_value::F (void) const \
-  { \
-    gripe_wrong_type_arg ("octave_base_value::" #F " ()", type_name ()); \
-    return octave_value (); \
-  }
+extern OCTINTERP_API
+const char *get_umap_name (unary_mapper_t umap)
+{
+  static const char *names[num_unary_mappers] = 
+    {
+      "abs",
+      "acos",
+      "acosh",
+      "angle",
+      "arg",
+      "asin",
+      "asinh",
+      "atan",
+      "atanh",
+      "ceil",
+      "conj",
+      "cos",
+      "cosh",
+      "erf",
+      "erfc",
+      "exp",
+      "expm1",
+      "finite",
+      "fix",
+      "floor",
+      "gamma",
+      "imag",
+      "isinf",
+      "isna",
+      "isnan",
+      "lgamma",
+      "log",
+      "log2",
+      "log10",
+      "log1p",
+      "real",
+      "round",
+      "roundb",
+      "signum",
+      "sin",
+      "sinh",
+      "sqrt",
+      "tan",
+      "tanh",
+      "isalnum",
+      "isalpha",
+      "isascii",
+      "iscntrl",
+      "isdigit",
+      "isgraph",
+      "islower",
+      "isprint",
+      "ispunct",
+      "isspace",
+      "isupper",
+      "isxdigit",
+      "toascii",
+      "tolower",
+      "toupper"
+    };
 
-UNDEFINED_MAPPER (abs)
-UNDEFINED_MAPPER (acos)
-UNDEFINED_MAPPER (acosh)
-UNDEFINED_MAPPER (angle)
-UNDEFINED_MAPPER (arg)
-UNDEFINED_MAPPER (asin)
-UNDEFINED_MAPPER (asinh)
-UNDEFINED_MAPPER (atan)
-UNDEFINED_MAPPER (atanh)
-UNDEFINED_MAPPER (ceil)
-UNDEFINED_MAPPER (conj)
-UNDEFINED_MAPPER (cos)
-UNDEFINED_MAPPER (cosh)
-UNDEFINED_MAPPER (erf)
-UNDEFINED_MAPPER (erfc)
-UNDEFINED_MAPPER (exp)
-UNDEFINED_MAPPER (expm1)
-UNDEFINED_MAPPER (finite)
-UNDEFINED_MAPPER (fix)
-UNDEFINED_MAPPER (floor)
-UNDEFINED_MAPPER (gamma)
-UNDEFINED_MAPPER (imag)
-UNDEFINED_MAPPER (isinf)
-UNDEFINED_MAPPER (isna)
-UNDEFINED_MAPPER (isnan)
-UNDEFINED_MAPPER (lgamma)
-UNDEFINED_MAPPER (log)
-UNDEFINED_MAPPER (log2)
-UNDEFINED_MAPPER (log10)
-UNDEFINED_MAPPER (log1p)
-UNDEFINED_MAPPER (real)
-UNDEFINED_MAPPER (round)
-UNDEFINED_MAPPER (roundb)
-UNDEFINED_MAPPER (signum)
-UNDEFINED_MAPPER (sin)
-UNDEFINED_MAPPER (sinh)
-UNDEFINED_MAPPER (sqrt)
-UNDEFINED_MAPPER (tan)
-UNDEFINED_MAPPER (tanh)
+  if (umap < 0 || umap >= num_unary_mappers)
+    return "unknown";
+  else
+    return names[umap];
+}
 
-// String mapper functions, convert to a string
-
-#define STRING_MAPPER(F) \
-  octave_value \
-  octave_base_value::F (void) const \
-  { \
-    octave_value tmp = char_array_value (true); \
-    return error_state ? octave_value () : octave_value (tmp.F ()); \
-  }
-
-STRING_MAPPER (xisalnum)
-STRING_MAPPER (xisalpha)
-STRING_MAPPER (xisascii)
-STRING_MAPPER (xiscntrl)
-STRING_MAPPER (xisdigit)
-STRING_MAPPER (xisgraph)
-STRING_MAPPER (xislower)
-STRING_MAPPER (xisprint)
-STRING_MAPPER (xispunct)
-STRING_MAPPER (xisspace)
-STRING_MAPPER (xisupper)
-STRING_MAPPER (xisxdigit)
-STRING_MAPPER (xtoascii)
-STRING_MAPPER (xtolower)
-STRING_MAPPER (xtoupper)
+octave_value
+octave_base_value::map (unary_mapper_t umap) const
+{
+  error ("%s: not defined for %s", get_umap_name (umap), type_name ().c_str ());
+  return octave_value ();
+}
 
 void
 octave_base_value::lock (void)
 {
   gripe_wrong_type_arg ("octave_base_value::lock ()", type_name ());
 }
 
 void
diff --git a/src/ov-base.h b/src/ov-base.h
--- a/src/ov-base.h
+++ b/src/ov-base.h
@@ -112,16 +112,80 @@ DEF_CLASS_TO_BTYP (octave_int32, btyp_in
 DEF_CLASS_TO_BTYP (octave_int64, btyp_int64);
 DEF_CLASS_TO_BTYP (octave_uint8, btyp_uint8);
 DEF_CLASS_TO_BTYP (octave_uint16, btyp_uint16);
 DEF_CLASS_TO_BTYP (octave_uint32, btyp_uint32);
 DEF_CLASS_TO_BTYP (octave_uint64, btyp_uint64);
 DEF_CLASS_TO_BTYP (bool, btyp_bool);
 DEF_CLASS_TO_BTYP (char, btyp_char);
 
+// Standard mappers.
+enum unary_mapper_t
+{
+  umap_abs,
+  umap_acos,
+  umap_acosh,
+  umap_angle,
+  umap_arg,
+  umap_asin,
+  umap_asinh,
+  umap_atan,
+  umap_atanh,
+  umap_ceil,
+  umap_conj,
+  umap_cos,
+  umap_cosh,
+  umap_erf,
+  umap_erfc,
+  umap_exp,
+  umap_expm1,
+  umap_finite,
+  umap_fix,
+  umap_floor,
+  umap_gamma,
+  umap_imag,
+  umap_isinf,
+  umap_isna,
+  umap_isnan,
+  umap_lgamma,
+  umap_log,
+  umap_log2,
+  umap_log10,
+  umap_log1p,
+  umap_real,
+  umap_round,
+  umap_roundb,
+  umap_signum,
+  umap_sin,
+  umap_sinh,
+  umap_sqrt,
+  umap_tan,
+  umap_tanh,
+  umap_isalnum,
+  umap_isalpha,
+  umap_isascii,
+  umap_iscntrl,
+  umap_isdigit,
+  umap_isgraph,
+  umap_islower,
+  umap_isprint,
+  umap_ispunct,
+  umap_isspace,
+  umap_isupper,
+  umap_isxdigit,
+  umap_toascii,
+  umap_tolower,
+  umap_toupper,
+  umap_unknown,
+  num_unary_mappers = umap_unknown
+};
+
+extern OCTINTERP_API
+const char *get_umap_name (unary_mapper_t);
+
 // T_ID is the type id of struct objects, set by register_type().
 // T_NAME is the type name of struct objects.
 
 #define DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA \
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA2 (OCTAVE_EMPTY_CPP_ARG)
 
 #define DECLARE_OV_BASE_TYPEID_FUNCTIONS_AND_DATA \
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA2(virtual)
@@ -627,74 +691,17 @@ public:
   virtual void lock (void);
 
   virtual void unlock (void);
 
   virtual bool islocked (void) const { return false; }
 
   virtual void dump (std::ostream& os) const;
 
-  virtual octave_value abs (void) const;
-  virtual octave_value acos (void) const;
-  virtual octave_value acosh (void) const;
-  virtual octave_value angle (void) const;
-  virtual octave_value arg (void) const;
-  virtual octave_value asin (void) const;
-  virtual octave_value asinh (void) const;
-  virtual octave_value atan (void) const;
-  virtual octave_value atanh (void) const;
-  virtual octave_value ceil (void) const;
-  virtual octave_value conj (void) const;
-  virtual octave_value cos (void) const;
-  virtual octave_value cosh (void) const;
-  virtual octave_value erf (void) const;
-  virtual octave_value erfc (void) const;
-  virtual octave_value exp (void) const;
-  virtual octave_value expm1 (void) const;
-  virtual octave_value finite (void) const;
-  virtual octave_value fix (void) const;
-  virtual octave_value floor (void) const;
-  virtual octave_value gamma (void) const;
-  virtual octave_value imag (void) const;
-  virtual octave_value isinf (void) const;
-  virtual octave_value isna (void) const;
-  virtual octave_value isnan (void) const;
-  virtual octave_value lgamma (void) const;
-  virtual octave_value log (void) const;
-  virtual octave_value log2 (void) const;
-  virtual octave_value log10 (void) const;
-  virtual octave_value log1p (void) const;
-  virtual octave_value real (void) const;
-  virtual octave_value round (void) const;
-  virtual octave_value roundb (void) const;
-  virtual octave_value signum (void) const;
-  virtual octave_value sin (void) const;
-  virtual octave_value sinh (void) const;
-  virtual octave_value sqrt (void) const;
-  virtual octave_value tan (void) const;
-  virtual octave_value tanh (void) const;
-
-  // These functions are prefixed with X to avoid potential macro
-  // conflicts.
-
-  virtual octave_value xisalnum (void) const;
-  virtual octave_value xisalpha (void) const;
-  virtual octave_value xisascii (void) const;
-  virtual octave_value xiscntrl (void) const;
-  virtual octave_value xisdigit (void) const;
-  virtual octave_value xisgraph (void) const;
-  virtual octave_value xislower (void) const;
-  virtual octave_value xisprint (void) const;
-  virtual octave_value xispunct (void) const;
-  virtual octave_value xisspace (void) const;
-  virtual octave_value xisupper (void) const;
-  virtual octave_value xisxdigit (void) const;
-  virtual octave_value xtoascii (void) const;
-  virtual octave_value xtolower (void) const;
-  virtual octave_value xtoupper (void) const;
+  virtual octave_value map (unary_mapper_t) const;
 
 protected:
 
   // This should only be called for derived types.
 
   octave_value numeric_assign (const std::string& type,
 			       const std::list<octave_value_list>& idx,
 			       const octave_value& rhs);
diff --git a/src/ov-bool-mat.h b/src/ov-bool-mat.h
--- a/src/ov-bool-mat.h
+++ b/src/ov-bool-mat.h
@@ -204,65 +204,22 @@ public:
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
   mxArray *as_mxArray (void) const;
 
   // Mapper functions are converted to double for treatment
-#define BOOL_MAT_MAPPER(MAP) \
-  octave_value MAP (void) const \
-    { \
-      octave_matrix m (array_value ()); \
-      return m.MAP (); \
+  octave_value map (unary_mapper_t umap) const
+    {
+      octave_matrix m (array_value ());
+      return m.map (umap);
     }
 
-  BOOL_MAT_MAPPER (abs)
-  BOOL_MAT_MAPPER (acos)
-  BOOL_MAT_MAPPER (acosh)
-  BOOL_MAT_MAPPER (angle)
-  BOOL_MAT_MAPPER (arg)
-  BOOL_MAT_MAPPER (asin)
-  BOOL_MAT_MAPPER (asinh)
-  BOOL_MAT_MAPPER (atan)
-  BOOL_MAT_MAPPER (atanh)
-  BOOL_MAT_MAPPER (ceil)
-  BOOL_MAT_MAPPER (conj)
-  BOOL_MAT_MAPPER (cos)
-  BOOL_MAT_MAPPER (cosh)
-  BOOL_MAT_MAPPER (erf)
-  BOOL_MAT_MAPPER (erfc)
-  BOOL_MAT_MAPPER (exp)
-  BOOL_MAT_MAPPER (expm1)
-  BOOL_MAT_MAPPER (finite)
-  BOOL_MAT_MAPPER (fix)
-  BOOL_MAT_MAPPER (floor)
-  BOOL_MAT_MAPPER (gamma)
-  BOOL_MAT_MAPPER (imag)
-  BOOL_MAT_MAPPER (isinf)
-  BOOL_MAT_MAPPER (isna)
-  BOOL_MAT_MAPPER (isnan)
-  BOOL_MAT_MAPPER (lgamma)
-  BOOL_MAT_MAPPER (log)
-  BOOL_MAT_MAPPER (log2)
-  BOOL_MAT_MAPPER (log10)
-  BOOL_MAT_MAPPER (log1p)
-  BOOL_MAT_MAPPER (real)
-  BOOL_MAT_MAPPER (round)
-  BOOL_MAT_MAPPER (roundb)
-  BOOL_MAT_MAPPER (signum)
-  BOOL_MAT_MAPPER (sin)
-  BOOL_MAT_MAPPER (sinh)
-  BOOL_MAT_MAPPER (sqrt)
-  BOOL_MAT_MAPPER (tan)
-  BOOL_MAT_MAPPER (tanh)
-
-#undef BOOL_MAT_MAPPER
-
 protected:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/src/ov-bool-sparse.h b/src/ov-bool-sparse.h
--- a/src/ov-bool-sparse.h
+++ b/src/ov-bool-sparse.h
@@ -135,65 +135,22 @@ public:
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
 #endif
 
   mxArray *as_mxArray (void) const;
 
   // Mapper functions are converted to double for treatment
-#define BOOL_SPARSE_MAPPER(MAP) \
-  octave_value MAP (void) const \
-    { \
-      octave_sparse_matrix m (sparse_matrix_value ()); \
-      return m.MAP (); \
+  octave_value map (unary_mapper_t umap) const
+    {
+      octave_sparse_matrix m (sparse_matrix_value ());
+      return m.map (umap);
     }
 
-  BOOL_SPARSE_MAPPER (abs)
-  BOOL_SPARSE_MAPPER (acos)
-  BOOL_SPARSE_MAPPER (acosh)
-  BOOL_SPARSE_MAPPER (angle)
-  BOOL_SPARSE_MAPPER (arg)
-  BOOL_SPARSE_MAPPER (asin)
-  BOOL_SPARSE_MAPPER (asinh)
-  BOOL_SPARSE_MAPPER (atan)
-  BOOL_SPARSE_MAPPER (atanh)
-  BOOL_SPARSE_MAPPER (ceil)
-  BOOL_SPARSE_MAPPER (conj)
-  BOOL_SPARSE_MAPPER (cos)
-  BOOL_SPARSE_MAPPER (cosh)
-  BOOL_SPARSE_MAPPER (erf)
-  BOOL_SPARSE_MAPPER (erfc)
-  BOOL_SPARSE_MAPPER (exp)
-  BOOL_SPARSE_MAPPER (expm1)
-  BOOL_SPARSE_MAPPER (finite)
-  BOOL_SPARSE_MAPPER (fix)
-  BOOL_SPARSE_MAPPER (floor)
-  BOOL_SPARSE_MAPPER (gamma)
-  BOOL_SPARSE_MAPPER (imag)
-  BOOL_SPARSE_MAPPER (isinf)
-  BOOL_SPARSE_MAPPER (isna)
-  BOOL_SPARSE_MAPPER (isnan)
-  BOOL_SPARSE_MAPPER (lgamma)
-  BOOL_SPARSE_MAPPER (log)
-  BOOL_SPARSE_MAPPER (log2)
-  BOOL_SPARSE_MAPPER (log10)
-  BOOL_SPARSE_MAPPER (log1p)
-  BOOL_SPARSE_MAPPER (real)
-  BOOL_SPARSE_MAPPER (round)
-  BOOL_SPARSE_MAPPER (roundb)
-  BOOL_SPARSE_MAPPER (signum)
-  BOOL_SPARSE_MAPPER (sin)
-  BOOL_SPARSE_MAPPER (sinh)
-  BOOL_SPARSE_MAPPER (sqrt)
-  BOOL_SPARSE_MAPPER (tan)
-  BOOL_SPARSE_MAPPER (tanh)
-
-#undef BOOL_SPARSE_MAPPER
-
 protected:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/src/ov-bool.h b/src/ov-bool.h
--- a/src/ov-bool.h
+++ b/src/ov-bool.h
@@ -204,65 +204,22 @@ public:
     {
       return os.write (bool_array_value (), block_size, output_type,
 		       skip, flt_fmt);
     }
 
   mxArray *as_mxArray (void) const;
 
   // Mapper functions are converted to double for treatment
-#define BOOL_MAPPER(MAP) \
-  octave_value MAP (void) const \
-    { \
-      octave_scalar s (static_cast<double> (scalar)); \
-      return s.MAP (); \
+  octave_value map (unary_mapper_t umap) const
+    {
+      octave_scalar m (scalar_value ());
+      return m.map (umap);
     }
 
-  BOOL_MAPPER (abs)
-  BOOL_MAPPER (acos)
-  BOOL_MAPPER (acosh)
-  BOOL_MAPPER (angle)
-  BOOL_MAPPER (arg)
-  BOOL_MAPPER (asin)
-  BOOL_MAPPER (asinh)
-  BOOL_MAPPER (atan)
-  BOOL_MAPPER (atanh)
-  BOOL_MAPPER (ceil)
-  BOOL_MAPPER (conj)
-  BOOL_MAPPER (cos)
-  BOOL_MAPPER (cosh)
-  BOOL_MAPPER (erf)
-  BOOL_MAPPER (erfc)
-  BOOL_MAPPER (exp)
-  BOOL_MAPPER (expm1)
-  BOOL_MAPPER (finite)
-  BOOL_MAPPER (fix)
-  BOOL_MAPPER (floor)
-  BOOL_MAPPER (gamma)
-  BOOL_MAPPER (imag)
-  BOOL_MAPPER (isinf)
-  BOOL_MAPPER (isna)
-  BOOL_MAPPER (isnan)
-  BOOL_MAPPER (lgamma)
-  BOOL_MAPPER (log)
-  BOOL_MAPPER (log2)
-  BOOL_MAPPER (log10)
-  BOOL_MAPPER (log1p)
-  BOOL_MAPPER (real)
-  BOOL_MAPPER (round)
-  BOOL_MAPPER (roundb)
-  BOOL_MAPPER (signum)
-  BOOL_MAPPER (sin)
-  BOOL_MAPPER (sinh)
-  BOOL_MAPPER (sqrt)
-  BOOL_MAPPER (tan)
-  BOOL_MAPPER (tanh)
-
-#undef BOOL_MAPPER
-
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/src/ov-cell.h b/src/ov-cell.h
--- a/src/ov-cell.h
+++ b/src/ov-cell.h
@@ -150,31 +150,18 @@ public:
 		    oct_mach_info::float_format fmt);
 
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
 #endif
 
-  octave_value xisalnum (void) const { return matrix.xisalnum (); }
-  octave_value xisalpha (void) const { return matrix.xisalpha (); }
-  octave_value xisascii (void) const { return matrix.xisascii (); }
-  octave_value xiscntrl (void) const { return matrix.xiscntrl (); }
-  octave_value xisdigit (void) const { return matrix.xisdigit (); }
-  octave_value xisgraph (void) const { return matrix.xisgraph (); }
-  octave_value xislower (void) const { return matrix.xislower (); }
-  octave_value xisprint (void) const { return matrix.xisprint (); }
-  octave_value xispunct (void) const { return matrix.xispunct (); }
-  octave_value xisspace (void) const { return matrix.xisspace (); }
-  octave_value xisupper (void) const { return matrix.xisupper (); }
-  octave_value xisxdigit (void) const { return matrix.xisxdigit (); }
-  octave_value xtoascii (void) const { return matrix.xtoascii (); }
-  octave_value xtolower (void) const { return matrix.xtolower (); }
-  octave_value xtoupper (void) const { return matrix.xtoupper (); }
+  octave_value map (unary_mapper_t umap) const
+    { return matrix.map (umap); }
 
   mxArray *as_mxArray (void) const;
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const; 
 
 private:
diff --git a/src/ov-ch-mat.cc b/src/ov-ch-mat.cc
--- a/src/ov-ch-mat.cc
+++ b/src/ov-ch-mat.cc
@@ -145,52 +145,58 @@ octave_char_matrix::as_mxArray (void) co
   const char *p = matrix.data ();
 
   for (mwIndex i = 0; i < nel; i++)
     pr[i] = p[i];
 
   return retval;
 }
 
-#define MACRO_WRAPPER(FCN, CTYPE_FCN) \
-  static int x ## FCN (int c) { return CTYPE_FCN (c); }
+// The C++ standard guarantees cctype defines functions, not macros (and hence macros *CAN'T* 
+// be defined if only cctype is included)
+// so there's no need to f*ck around. The exceptions are isascii and toascii,
+// which are not C++.
+// Oddly enough, all those character functions are int (*) (int), even
+// in C++. Wicked!
+static inline int xisascii (int c)
+{ return isascii (c); }
 
-#define STRING_MAPPER(FCN, AMAP, CTYPE_FCN) \
-  MACRO_WRAPPER (FCN, CTYPE_FCN) \
- \
-  octave_value \
-  octave_char_matrix::FCN (void) const \
-  { \
-    static charNDArray::mapper smap = x ## FCN; \
-    return matrix.AMAP (smap);  \
-  }
+static inline int xtoascii (int c)
+{ return toascii (c); }
+
+octave_value
+octave_char_matrix::map (unary_mapper_t umap) const
+{
+  switch (umap)
+    {
+#define STRING_MAPPER(UMAP,FCN,TYPE) \
+    case UMAP: \
+      return octave_value (matrix.map<TYPE, int (&) (int)> (FCN))
 
-#define TOSTRING_MAPPER(FCN, AMAP, CTYPE_FCN) \
-  MACRO_WRAPPER (FCN, CTYPE_FCN) \
- \
-  octave_value \
-  octave_char_matrix::FCN (void) const \
-  { \
-    static charNDArray::mapper smap = x ## FCN; \
-    return octave_value (matrix.AMAP (smap), is_sq_string () ? '\'' : '"'); \
-  }
+    STRING_MAPPER (umap_isalnum, std::isalnum, bool);
+    STRING_MAPPER (umap_isalpha, std::isalpha, bool);
+    STRING_MAPPER (umap_isascii, xisascii, bool);
+    STRING_MAPPER (umap_iscntrl, std::iscntrl, bool);
+    STRING_MAPPER (umap_isdigit, std::isdigit, bool);
+    STRING_MAPPER (umap_isgraph, std::isgraph, bool);
+    STRING_MAPPER (umap_islower, std::islower, bool);
+    STRING_MAPPER (umap_isprint, std::isprint, bool);
+    STRING_MAPPER (umap_ispunct, std::ispunct, bool);
+    STRING_MAPPER (umap_isspace, std::isspace, bool);
+    STRING_MAPPER (umap_isupper, std::isupper, bool);
+    STRING_MAPPER (umap_isxdigit, std::isxdigit, bool);
+    STRING_MAPPER (umap_toascii, xtoascii, double);
+    STRING_MAPPER (umap_tolower, std::tolower, char);
+    STRING_MAPPER (umap_toupper, std::toupper, char);
 
-STRING_MAPPER (xisalnum, bmap, isalnum)
-STRING_MAPPER (xisalpha, bmap, isalpha)
-STRING_MAPPER (xisascii, bmap, isascii)
-STRING_MAPPER (xiscntrl, bmap, iscntrl)
-STRING_MAPPER (xisdigit, bmap, isdigit)
-STRING_MAPPER (xisgraph, bmap, isgraph)
-STRING_MAPPER (xislower, bmap, islower)
-STRING_MAPPER (xisprint, bmap, isprint)
-STRING_MAPPER (xispunct, bmap, ispunct)
-STRING_MAPPER (xisspace, bmap, isspace)
-STRING_MAPPER (xisupper, bmap, isupper)
-STRING_MAPPER (xisxdigit, bmap, isxdigit)
-STRING_MAPPER (xtoascii, dmap, toascii)
-TOSTRING_MAPPER (xtolower, smap, tolower)
-TOSTRING_MAPPER (xtoupper, smap, toupper)
+    default: 
+      {
+        octave_matrix m (array_value (true));
+        return m.map (umap);
+      }
+    }
+}
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-ch-mat.h b/src/ov-ch-mat.h
--- a/src/ov-ch-mat.h
+++ b/src/ov-ch-mat.h
@@ -138,66 +138,17 @@ public:
 
   octave_value convert_to_str_internal (bool, bool, char type) const
     { return octave_value (matrix, type); }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   mxArray *as_mxArray (void) const;
 
-  octave_value xisalnum (void) const;
-  octave_value xisalpha (void) const;
-  octave_value xisascii (void) const;
-  octave_value xiscntrl (void) const;
-  octave_value xisdigit (void) const;
-  octave_value xisgraph (void) const;
-  octave_value xislower (void) const;
-  octave_value xisprint (void) const;
-  octave_value xispunct (void) const;
-  octave_value xisspace (void) const;
-  octave_value xisupper (void) const;
-  octave_value xisxdigit (void) const;
-  octave_value xtoascii (void) const;
-  octave_value xtolower (void) const;
-  octave_value xtoupper (void) const;
-
-#define MAT_MAPPER(MAP) \
-  octave_value MAP (void) const \
-    { \
-      octave_matrix m (array_value (true)); \
-      return m.MAP (); \
-    }
-
-  MAT_MAPPER (abs)
-  MAT_MAPPER (angle)
-  MAT_MAPPER (arg)
-  MAT_MAPPER (ceil)
-  MAT_MAPPER (conj)
-  MAT_MAPPER (fix)
-  MAT_MAPPER (floor)
-  MAT_MAPPER (imag)
-  MAT_MAPPER (real)
-  MAT_MAPPER (round)
-  MAT_MAPPER (signum)
-
-#undef MAT_MAPPER
-
-#define BOOL_MAT_MAPPER(MAP, VAL)	\
-  octave_value MAP (void) const \
-    { \
-      return boolNDArray (matrix.dims (), VAL); \
-    }
-
-  BOOL_MAT_MAPPER (finite, true)
-  BOOL_MAT_MAPPER (isinf, false)
-  BOOL_MAT_MAPPER (isna, false)
-  BOOL_MAT_MAPPER (isnan, false)
-
-#undef BOOL_MAT_MAPPER
-
+  octave_value map (unary_mapper_t umap) const;
 };
 
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov-complex.cc b/src/ov-complex.cc
--- a/src/ov-complex.cc
+++ b/src/ov-complex.cc
@@ -395,110 +395,63 @@ octave_complex::as_mxArray (void) const
   double *pi = static_cast<double *> (retval->get_imag_data ());
 
   pr[0] = std::real (scalar);
   pi[0] = std::imag (scalar);
 
   return retval;
 }
 
-static double
-xabs (const Complex& x)
-{
-  return (xisinf (x.real ()) || xisinf (x.imag ())) ? octave_Inf : abs (x);
-}
-
-static double
-ximag (const Complex& x)
-{
-  return x.imag ();
-}
-
-static double
-xreal (const Complex& x)
+octave_value
+octave_complex::map (unary_mapper_t umap) const
 {
-  return x.real ();
-}
-
-#define COMPLEX_MAPPER(MAP, FCN)	\
-  octave_value \
-  octave_complex::MAP (void) const \
-  { \
-    return octave_value (FCN (scalar)); \
-  }
-
-#define SCALAR_MAPPER(MAP, FCN)	\
-  octave_value \
-  octave_complex::MAP (void) const \
-  { \
-    if (scalar.imag () == 0) \
-      return octave_value (FCN (scalar.real ())); \
-    else \
-      { \
-        error ("%s: not defined for complex arguments", #MAP); \
-        return octave_value (); \
-      } \
-  }
+  switch (umap)
+    {
+#define SCALAR_MAPPER(UMAP, FCN) \
+    case umap_ ## UMAP: \
+      return octave_value (FCN (scalar))
 
-#define CD_SCALAR_MAPPER(MAP, RFCN, CFCN, L1, L2) \
-  octave_value \
-  octave_complex::MAP (void) const \
-  { \
-    if (scalar.imag () == 0) \
-      { \
-	double re = scalar.real (); \
-	return (re < L1 || re > L2 \
-            ? octave_value (CFCN (scalar)) \
-	    : octave_value (RFCN (re))); \
-      } \
-    else \
-      { \
-        error ("%s: not defined for complex arguments", #MAP); \
-        return octave_value (); \
-      } \
-  }
-
-SCALAR_MAPPER (erf, ::erf)
-SCALAR_MAPPER (erfc, ::erfc)
-SCALAR_MAPPER (gamma, xgamma)
-CD_SCALAR_MAPPER (lgamma, xlgamma, xlgamma, 0.0, octave_Inf)
+      SCALAR_MAPPER (abs, std::abs);
+      SCALAR_MAPPER (acos, ::acos);
+      SCALAR_MAPPER (acosh, ::acosh);
+      SCALAR_MAPPER (angle, std::arg);
+      SCALAR_MAPPER (arg, std::arg);
+      SCALAR_MAPPER (asin, ::asin);
+      SCALAR_MAPPER (asinh, ::asinh);
+      SCALAR_MAPPER (atan, ::atan);
+      SCALAR_MAPPER (atanh, ::atanh);
+      SCALAR_MAPPER (ceil, ::ceil);
+      SCALAR_MAPPER (conj, std::conj);
+      SCALAR_MAPPER (cos, std::cos);
+      SCALAR_MAPPER (cosh, std::cosh);
+      SCALAR_MAPPER (exp, std::exp);
+      SCALAR_MAPPER (expm1, ::expm1);
+      SCALAR_MAPPER (fix, ::fix);
+      SCALAR_MAPPER (floor, ::floor);
+      SCALAR_MAPPER (imag, std::imag);
+      SCALAR_MAPPER (log, std::log);
+      SCALAR_MAPPER (log2, xlog2);
+      SCALAR_MAPPER (log10, std::log10);
+      SCALAR_MAPPER (log1p, ::log1p);
+      SCALAR_MAPPER (real, std::real);
+      SCALAR_MAPPER (round, xround);
+      SCALAR_MAPPER (roundb, xroundb);
+      SCALAR_MAPPER (signum, ::signum);
+      SCALAR_MAPPER (sin, std::sin);
+      SCALAR_MAPPER (sinh, std::sinh);
+      SCALAR_MAPPER (sqrt, std::sqrt);
+      SCALAR_MAPPER (tan, std::tan);
+      SCALAR_MAPPER (tanh, std::tanh);
+      SCALAR_MAPPER (finite, xfinite);
+      SCALAR_MAPPER (isinf, xisinf);
+      SCALAR_MAPPER (isna, octave_is_NA);
+      SCALAR_MAPPER (isnan, xisnan);
 
-COMPLEX_MAPPER (abs, xabs)
-COMPLEX_MAPPER (acos, ::acos)
-COMPLEX_MAPPER (acosh, ::acosh)
-COMPLEX_MAPPER (angle, std::arg)
-COMPLEX_MAPPER (arg, std::arg)
-COMPLEX_MAPPER (asin, ::asin)
-COMPLEX_MAPPER (asinh, ::asinh)
-COMPLEX_MAPPER (atan, ::atan)
-COMPLEX_MAPPER (atanh, ::atanh)
-COMPLEX_MAPPER (ceil, ::ceil)
-COMPLEX_MAPPER (conj, std::conj)
-COMPLEX_MAPPER (cos, std::cos)
-COMPLEX_MAPPER (cosh, std::cosh)
-COMPLEX_MAPPER (exp, std::exp)
-COMPLEX_MAPPER (expm1, ::expm1)
-COMPLEX_MAPPER (fix, ::fix)
-COMPLEX_MAPPER (floor, ::floor)
-COMPLEX_MAPPER (imag, ximag)
-COMPLEX_MAPPER (log, std::log)
-COMPLEX_MAPPER (log2, xlog2)
-COMPLEX_MAPPER (log10, std::log10)
-COMPLEX_MAPPER (log1p, ::log1p)
-COMPLEX_MAPPER (real, xreal)
-COMPLEX_MAPPER (round, xround)
-COMPLEX_MAPPER (roundb, xroundb)
-COMPLEX_MAPPER (signum, ::signum)
-COMPLEX_MAPPER (sin, std::sin)
-COMPLEX_MAPPER (sinh, std::sinh)
-COMPLEX_MAPPER (sqrt, std::sqrt)
-COMPLEX_MAPPER (tan, std::tan)
-COMPLEX_MAPPER (tanh, std::tanh)
-COMPLEX_MAPPER (finite, xfinite)
-COMPLEX_MAPPER (isinf, xisinf)
-COMPLEX_MAPPER (isna, octave_is_NA)
-COMPLEX_MAPPER (isnan, xisnan)
+    default:
+      return octave_base_value::map (umap);
+    }
+}
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-complex.h b/src/ov-complex.h
--- a/src/ov-complex.h
+++ b/src/ov-complex.h
@@ -160,55 +160,17 @@ public:
     {
       // Yes, for compatibility, we drop the imaginary part here.
       return os.write (array_value (true), block_size, output_type,
 		       skip, flt_fmt);
     }
 
   mxArray *as_mxArray (void) const;
 
-  octave_value erf (void) const;
-  octave_value erfc (void) const;
-  octave_value gamma (void) const;
-  octave_value lgamma (void) const;
-  octave_value abs (void) const;
-  octave_value acos (void) const;
-  octave_value acosh (void) const;
-  octave_value angle (void) const;
-  octave_value arg (void) const;
-  octave_value asin (void) const;
-  octave_value asinh (void) const;
-  octave_value atan (void) const;
-  octave_value atanh (void) const;
-  octave_value ceil (void) const;
-  octave_value conj (void) const;
-  octave_value cos (void) const;
-  octave_value cosh (void) const;
-  octave_value exp (void) const;
-  octave_value expm1 (void) const;
-  octave_value fix (void) const;
-  octave_value floor (void) const;
-  octave_value imag (void) const;
-  octave_value log (void) const;
-  octave_value log2 (void) const;
-  octave_value log10 (void) const;
-  octave_value log1p (void) const;
-  octave_value real (void) const;
-  octave_value round (void) const;
-  octave_value roundb (void) const;
-  octave_value signum (void) const;
-  octave_value sin (void) const;
-  octave_value sinh (void) const;
-  octave_value sqrt (void) const;
-  octave_value tan (void) const;
-  octave_value tanh (void) const;
-  octave_value finite (void) const;
-  octave_value isinf (void) const;
-  octave_value isna (void) const;
-  octave_value isnan (void) const;
+  octave_value map (unary_mapper_t umap) const;
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/src/ov-cx-diag.cc b/src/ov-cx-diag.cc
--- a/src/ov-cx-diag.cc
+++ b/src/ov-cx-diag.cc
@@ -131,52 +131,38 @@ octave_complex_diag_matrix::complex_diag
 
 FloatComplexDiagMatrix
 octave_complex_diag_matrix::float_complex_diag_matrix_value (bool) const
 {
   return FloatComplexDiagMatrix (matrix);
 }
 
 octave_value
-octave_complex_diag_matrix::abs (void) const
-{
-  return matrix.abs ();
-}
-
-octave_value
-octave_complex_diag_matrix::real (void) const
-{
-  return ::real (matrix);
-}
-
-octave_value
-octave_complex_diag_matrix::conj (void) const
+octave_complex_diag_matrix::map (unary_mapper_t umap) const
 {
-  return ::conj (matrix);
-}
-
-octave_value
-octave_complex_diag_matrix::imag (void) const
-{
-  return ::imag (matrix);
-}
-
-octave_value
-octave_complex_diag_matrix::sqrt (void) const
-{    
-  octave_value retval;
-
-  static ComplexNDArray::cmapper csqrt = std::sqrt;
-
-  ComplexColumnVector dvec = matrix.diag ();
-  retval = ComplexDiagMatrix (dvec.map (csqrt));
-
-  retval.resize (dims ());
-
-  return retval;
+  switch (umap)
+    {
+    case umap_abs:
+      return matrix.abs ();
+    case umap_real:
+      return ::real (matrix);
+    case umap_conj:
+      return ::conj (matrix);
+    case umap_imag:
+      return ::imag (matrix);
+    case umap_sqrt:
+      {
+        ComplexColumnVector tmp = matrix.diag ().map<Complex> (std::sqrt);
+        ComplexDiagMatrix retval (tmp);
+        retval.resize (matrix.rows (), matrix.columns ());
+        return retval;
+      }
+    default:
+      return to_dense ().map (umap);
+    }
 }
 
 bool 
 octave_complex_diag_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
 
   int32_t r = matrix.rows (), c = matrix.cols ();
   os.write (reinterpret_cast<char *> (&r), 4);
diff --git a/src/ov-cx-diag.h b/src/ov-cx-diag.h
--- a/src/ov-cx-diag.h
+++ b/src/ov-cx-diag.h
@@ -75,21 +75,17 @@ public:
 
   FloatComplexDiagMatrix float_complex_diag_matrix_value (bool = false) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
-  octave_value abs (void) const;
-  octave_value conj (void) const;
-  octave_value imag (void) const;
-  octave_value real (void) const;
-  octave_value sqrt (void) const;
+  octave_value map (unary_mapper_t umap) const;
 
 private:
 
   bool chk_valid_scalar (const octave_value&, 
                          Complex&) const;
 
   DECLARE_OCTAVE_ALLOCATOR
 
diff --git a/src/ov-cx-mat.cc b/src/ov-cx-mat.cc
--- a/src/ov-cx-mat.cc
+++ b/src/ov-cx-mat.cc
@@ -714,197 +714,73 @@ octave_complex_matrix::as_mxArray (void)
     {
       pr[i] = std::real (p[i]);
       pi[i] = std::imag (p[i]);
     }
 
   return retval;
 }
 
-#if 0
-static double
-xabs (const Complex& x)
-{
-  return (xisinf (x.real ()) || xisinf (x.imag ())) ? octave_Inf : abs (x);
-}
-#endif
-
-static double
-ximag (const Complex& x)
-{
-  return x.imag ();
-}
-
-static double
-xreal (const Complex& x)
-{
-  return x.real ();
-}
-
-static bool
-any_element_less_than (const NDArray& a, double val)
-{
-  octave_idx_type len = a.length ();
-  const double *m = a.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < len; i++)
-    {
-      OCTAVE_QUIT;
-
-      if (m[i] < val)
-	return true;
-    }
-
-  return false;
-}
-
-static bool
-any_element_greater_than (const NDArray& a, double val)
+octave_value
+octave_complex_matrix::map (unary_mapper_t umap) const
 {
-  octave_idx_type len = a.length ();
-  const double *m = a.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < len; i++)
+  switch (umap)
     {
-      OCTAVE_QUIT;
-
-      if (m[i] > val)
-	return true;
-    }
-
-  return false;
-}
+    // Mappers handled specially.
+    case umap_real:
+      return ::real (matrix);
+    case umap_imag:
+      return ::imag (matrix);
+    case umap_conj:
+      return ::conj (matrix);
 
-#define ARRAY_MAPPER(MAP, AMAP, FCN) \
-  octave_value \
-  octave_complex_matrix::MAP (void) const \
-  { \
-    static AMAP cmap = FCN; \
-    return matrix.map (cmap); \
-  }
+#define ARRAY_METHOD_MAPPER(UMAP, FCN) \
+    case umap_ ## UMAP: \
+      return octave_value (matrix.FCN ())
 
-#define DARRAY_MAPPER(MAP, AMAP, FCN) \
-  octave_value \
-  octave_complex_matrix::MAP (void) const \
-  { \
-    static ComplexNDArray::dmapper dmap = ximag; \
-    NDArray m = matrix.map (dmap); \
-    if (m.all_elements_are_zero ()) \
-      { \
-	dmap = xreal; \
-	m = matrix.map (dmap); \
-        static AMAP cmap = FCN; \
-        return m.map (cmap); \
-      } \
-    else \
-      { \
-        error ("%s: not defined for complex arguments", #MAP); \
-        return octave_value (); \
-      } \
-  }
+      ARRAY_METHOD_MAPPER (abs, abs);
+      ARRAY_METHOD_MAPPER (isnan, isnan);
+      ARRAY_METHOD_MAPPER (isinf, isinf);
+      ARRAY_METHOD_MAPPER (finite, isfinite);
+
+#define ARRAY_MAPPER(UMAP, TYPE, FCN) \
+    case umap_ ## UMAP: \
+      return octave_value (matrix.map<TYPE> (FCN))
 
-#define CD_ARRAY_MAPPER(MAP, RFCN, CFCN, L1, L2) \
-  octave_value \
-  octave_complex_matrix::MAP (void) const \
-  { \
-    static ComplexNDArray::dmapper idmap = ximag; \
-    NDArray m = matrix.map (idmap); \
-    if (m.all_elements_are_zero ()) \
-      { \
-	static ComplexNDArray::dmapper rdmap = xreal; \
-	m = matrix.map (rdmap); \
-        static NDArray::dmapper dmap = RFCN; \
-        static NDArray::cmapper cmap = CFCN; \
-        return (any_element_less_than (m, L1) \
-                ? octave_value (m.map (cmap)) \
-	        : (any_element_greater_than (m, L2) \
-	           ? octave_value (m.map (cmap)) \
-	           : octave_value (m.map (dmap)))); \
-      } \
-    else \
-      { \
-        /*error ("%s: not defined for complex arguments", #MAP); */	\
-        return octave_value (m); \
-      } \
-  }
-
-// The fast mappers.
-octave_value
-octave_complex_matrix::abs (void) const
-{
-  return matrix.abs ();
-}
-
-octave_value
-octave_complex_matrix::real (void) const
-{
-  return ::real (matrix);
-}
-
-octave_value
-octave_complex_matrix::conj (void) const
-{
-  return ::conj (matrix);
-}
-
-octave_value
-octave_complex_matrix::imag (void) const
-{
-  return ::imag (matrix);
-}
+      ARRAY_MAPPER (acos, Complex, ::acos);
+      ARRAY_MAPPER (acosh, Complex, ::acosh);
+      ARRAY_MAPPER (angle, double, std::arg);
+      ARRAY_MAPPER (arg, double, std::arg);
+      ARRAY_MAPPER (asin, Complex, ::asin);
+      ARRAY_MAPPER (asinh, Complex, ::asinh);
+      ARRAY_MAPPER (atan, Complex, ::atan);
+      ARRAY_MAPPER (atanh, Complex, ::atanh);
+      ARRAY_MAPPER (ceil, Complex, ::ceil);
+      ARRAY_MAPPER (cos, Complex, std::cos);
+      ARRAY_MAPPER (cosh, Complex, std::cosh);
+      ARRAY_MAPPER (exp, Complex, std::exp);
+      ARRAY_MAPPER (expm1, Complex, ::expm1);
+      ARRAY_MAPPER (fix, Complex, ::fix);
+      ARRAY_MAPPER (floor, Complex, ::floor);
+      ARRAY_MAPPER (log, Complex, std::log);
+      ARRAY_MAPPER (log2, Complex, xlog2);
+      ARRAY_MAPPER (log10, Complex, std::log10);
+      ARRAY_MAPPER (log1p, Complex, ::log1p);
+      ARRAY_MAPPER (round, Complex, xround);
+      ARRAY_MAPPER (roundb, Complex, xroundb);
+      ARRAY_MAPPER (signum, Complex, ::signum);
+      ARRAY_MAPPER (sin, Complex, std::sin);
+      ARRAY_MAPPER (sinh, Complex, std::sinh);
+      ARRAY_MAPPER (sqrt, Complex, std::sqrt);
+      ARRAY_MAPPER (tan, Complex, std::tan);
+      ARRAY_MAPPER (tanh, Complex, std::tanh);
+      ARRAY_MAPPER (isna, bool, octave_is_NA);
 
-octave_value
-octave_complex_matrix::isnan (void) const
-{
-  return matrix.isnan ();
-}
-
-octave_value
-octave_complex_matrix::isinf (void) const
-{
-  return matrix.isinf ();
-}
-
-octave_value
-octave_complex_matrix::finite (void) const
-{
-  return matrix.isfinite ();
+    default:
+      return octave_base_value::map (umap);
+    }
 }
 
-DARRAY_MAPPER (erf, NDArray::dmapper, ::erf)
-DARRAY_MAPPER (erfc, NDArray::dmapper, ::erfc)
-DARRAY_MAPPER (gamma, NDArray::dmapper, xgamma)
-CD_ARRAY_MAPPER (lgamma, xlgamma, xlgamma, 0.0, octave_Inf)
-
-ARRAY_MAPPER (acos, ComplexNDArray::cmapper, ::acos)
-ARRAY_MAPPER (acosh, ComplexNDArray::cmapper, ::acosh)
-ARRAY_MAPPER (angle, ComplexNDArray::dmapper, std::arg)
-ARRAY_MAPPER (arg, ComplexNDArray::dmapper, std::arg)
-ARRAY_MAPPER (asin, ComplexNDArray::cmapper, ::asin)
-ARRAY_MAPPER (asinh, ComplexNDArray::cmapper, ::asinh)
-ARRAY_MAPPER (atan, ComplexNDArray::cmapper, ::atan)
-ARRAY_MAPPER (atanh, ComplexNDArray::cmapper, ::atanh)
-ARRAY_MAPPER (ceil, ComplexNDArray::cmapper, ::ceil)
-ARRAY_MAPPER (cos, ComplexNDArray::cmapper, std::cos)
-ARRAY_MAPPER (cosh, ComplexNDArray::cmapper, std::cosh)
-ARRAY_MAPPER (exp, ComplexNDArray::cmapper, std::exp)
-ARRAY_MAPPER (expm1, ComplexNDArray::cmapper, ::expm1)
-ARRAY_MAPPER (fix, ComplexNDArray::cmapper, ::fix)
-ARRAY_MAPPER (floor, ComplexNDArray::cmapper, ::floor)
-ARRAY_MAPPER (log, ComplexNDArray::cmapper, std::log)
-ARRAY_MAPPER (log2, ComplexNDArray::cmapper, xlog2)
-ARRAY_MAPPER (log10, ComplexNDArray::cmapper, std::log10)
-ARRAY_MAPPER (log1p, ComplexNDArray::cmapper, ::log1p)
-ARRAY_MAPPER (round, ComplexNDArray::cmapper, xround)
-ARRAY_MAPPER (roundb, ComplexNDArray::cmapper, xroundb)
-ARRAY_MAPPER (signum, ComplexNDArray::cmapper, ::signum)
-ARRAY_MAPPER (sin, ComplexNDArray::cmapper, std::sin)
-ARRAY_MAPPER (sinh, ComplexNDArray::cmapper, std::sinh)
-ARRAY_MAPPER (sqrt, ComplexNDArray::cmapper, std::sqrt)
-ARRAY_MAPPER (tan, ComplexNDArray::cmapper, std::tan)
-ARRAY_MAPPER (tanh, ComplexNDArray::cmapper, std::tanh)
-ARRAY_MAPPER (isna, ComplexNDArray::bmapper, octave_is_NA)
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-cx-mat.h b/src/ov-cx-mat.h
--- a/src/ov-cx-mat.h
+++ b/src/ov-cx-mat.h
@@ -163,55 +163,17 @@ public:
       return os.write (matrix_value (true), block_size, output_type,
 		       skip, flt_fmt);
     }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   mxArray *as_mxArray (void) const;
 
-  octave_value erf (void) const;
-  octave_value erfc (void) const;
-  octave_value gamma (void) const;
-  octave_value lgamma (void) const;
-  octave_value abs (void) const;
-  octave_value acos (void) const;
-  octave_value acosh (void) const;
-  octave_value angle (void) const;
-  octave_value arg (void) const;
-  octave_value asin (void) const;
-  octave_value asinh (void) const;
-  octave_value atan (void) const;
-  octave_value atanh (void) const;
-  octave_value ceil (void) const;
-  octave_value conj (void) const;
-  octave_value cos (void) const;
-  octave_value cosh (void) const;
-  octave_value exp (void) const;
-  octave_value expm1 (void) const;
-  octave_value fix (void) const;
-  octave_value floor (void) const;
-  octave_value imag (void) const;
-  octave_value log (void) const;
-  octave_value log2 (void) const;
-  octave_value log10 (void) const;
-  octave_value log1p (void) const;
-  octave_value real (void) const;
-  octave_value round (void) const;
-  octave_value roundb (void) const;
-  octave_value signum (void) const;
-  octave_value sin (void) const;
-  octave_value sinh (void) const;
-  octave_value sqrt (void) const;
-  octave_value tan (void) const;
-  octave_value tanh (void) const;
-  octave_value finite (void) const;
-  octave_value isinf (void) const;
-  octave_value isna (void) const;
-  octave_value isnan (void) const;
+  octave_value map (unary_mapper_t umap) const;
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/src/ov-cx-sparse.cc b/src/ov-cx-sparse.cc
--- a/src/ov-cx-sparse.cc
+++ b/src/ov-cx-sparse.cc
@@ -816,163 +816,72 @@ octave_sparse_complex_matrix::as_mxArray
     }
 
   for (mwIndex i = 0; i < columns() + 1; i++)
     jc[i] = matrix.cidx(i);
 
   return retval;
 }
 
-static double
-xabs (const Complex& x)
-{
-  return (xisinf (x.real ()) || xisinf (x.imag ())) ? octave_Inf : abs (x);
-}
-
-static double
-ximag (const Complex& x)
-{
-  return x.imag ();
-}
-
-static double
-xreal (const Complex& x)
+octave_value
+octave_sparse_complex_matrix::map (unary_mapper_t umap) const
 {
-  return x.real ();
-}
-
-static bool
-any_element_less_than (const SparseMatrix& a, double val)
-{
-  octave_idx_type len = a.nnz ();
-
-  if (val > 0. && len != a.numel ())
-    return true;
-
-  for (octave_idx_type i = 0; i < len; i++)
+  switch (umap)
     {
-      OCTAVE_QUIT;
+    // Mappers handled specially.
+    case umap_real:
+      return ::real (matrix);
+    case umap_imag:
+      return ::imag (matrix);
 
-      if (a.data(i) < val)
-	return true;
-    }
-
-  return false;
-}
-
-static bool
-any_element_greater_than (const SparseMatrix& a, double val)
-{
-  octave_idx_type len = a.nnz ();
-
-  if (val < 0. && len != a.numel ())
-    return true;
+#define ARRAY_METHOD_MAPPER(UMAP, FCN) \
+    case umap_ ## UMAP: \
+      return octave_value (matrix.FCN ())
 
-  for (octave_idx_type i = 0; i < len; i++)
-    {
-      OCTAVE_QUIT;
-
-      if (a.data(i) > val)
-	return true;
-    }
+      ARRAY_METHOD_MAPPER (abs, abs);
 
-  return false;
-}
-
-#define SPARSE_MAPPER(MAP, AMAP, FCN) \
-  octave_value \
-  octave_sparse_complex_matrix::MAP (void) const \
-  { \
-    static AMAP cmap = FCN; \
-    return matrix.map (cmap); \
-  }
+#define ARRAY_MAPPER(UMAP, TYPE, FCN) \
+    case umap_ ## UMAP: \
+      return octave_value (matrix.map<TYPE> (FCN))
 
-#define DSPARSE_MAPPER(MAP, AMAP, FCN) \
-  octave_value \
-  octave_sparse_complex_matrix::MAP (void) const \
-  { \
-    static SparseComplexMatrix::dmapper dmap = ximag; \
-    SparseMatrix m = matrix.map (dmap); \
-    if (m.all_elements_are_zero ()) \
-      { \
-	dmap = xreal; \
-	m = matrix.map (dmap); \
-        static AMAP cmap = FCN; \
-        return m.map (cmap); \
-      } \
-    else \
-      { \
-        error ("%s: not defined for complex arguments", #MAP); \
-        return octave_value (); \
-      } \
-  }
+      ARRAY_MAPPER (acos, Complex, ::acos);
+      ARRAY_MAPPER (acosh, Complex, ::acosh);
+      ARRAY_MAPPER (angle, double, std::arg);
+      ARRAY_MAPPER (arg, double, std::arg);
+      ARRAY_MAPPER (asin, Complex, ::asin);
+      ARRAY_MAPPER (asinh, Complex, ::asinh);
+      ARRAY_MAPPER (atan, Complex, ::atan);
+      ARRAY_MAPPER (atanh, Complex, ::atanh);
+      ARRAY_MAPPER (ceil, Complex, ::ceil);
+      ARRAY_MAPPER (conj, Complex, std::conj);
+      ARRAY_MAPPER (cos, Complex, std::cos);
+      ARRAY_MAPPER (cosh, Complex, std::cosh);
+      ARRAY_MAPPER (exp, Complex, std::exp);
+      ARRAY_MAPPER (expm1, Complex, ::expm1);
+      ARRAY_MAPPER (fix, Complex, ::fix);
+      ARRAY_MAPPER (floor, Complex, ::floor);
+      ARRAY_MAPPER (log, Complex, std::log);
+      ARRAY_MAPPER (log2, Complex, xlog2);
+      ARRAY_MAPPER (log10, Complex, std::log10);
+      ARRAY_MAPPER (log1p, Complex, ::log1p);
+      ARRAY_MAPPER (round, Complex, xround);
+      ARRAY_MAPPER (roundb, Complex, xroundb);
+      ARRAY_MAPPER (signum, Complex, ::signum);
+      ARRAY_MAPPER (sin, Complex, std::sin);
+      ARRAY_MAPPER (sinh, Complex, std::sinh);
+      ARRAY_MAPPER (sqrt, Complex, std::sqrt);
+      ARRAY_MAPPER (tan, Complex, std::tan);
+      ARRAY_MAPPER (tanh, Complex, std::tanh);
+      ARRAY_MAPPER (isnan, bool, xisnan);
+      ARRAY_MAPPER (isna, bool, octave_is_NA);
+      ARRAY_MAPPER (isinf, bool, xisinf);
+      ARRAY_MAPPER (finite, bool, xfinite);
 
-#define CD_SPARSE_MAPPER(MAP, RFCN, CFCN, L1, L2) \
-  octave_value \
-  octave_sparse_complex_matrix::MAP (void) const \
-  { \
-    static SparseComplexMatrix::dmapper idmap = ximag; \
-    SparseMatrix m = matrix.map (idmap); \
-    if (m.all_elements_are_zero ()) \
-      { \
-        static SparseComplexMatrix::dmapper rdmap = xreal; \
-	m = matrix.map (rdmap); \
-        static SparseMatrix::dmapper dmap = RFCN; \
-        static SparseMatrix::cmapper cmap = CFCN; \
-        return (any_element_less_than (m, L1) \
-                ? octave_value (m.map (cmap)) \
-	        : (any_element_greater_than (m, L2) \
-	           ? octave_value (m.map (cmap)) \
-	           : octave_value (m.map (dmap)))); \
-      } \
-    else \
-      { \
-        error ("%s: not defined for complex arguments", #MAP); \
-        return octave_value (); \
-      } \
-  }
-
-DSPARSE_MAPPER (erf, SparseMatrix::dmapper, ::erf)
-DSPARSE_MAPPER (erfc, SparseMatrix::dmapper, ::erfc)
-DSPARSE_MAPPER (gamma, SparseMatrix::dmapper, xgamma)
-CD_SPARSE_MAPPER (lgamma, xlgamma, xlgamma, 0.0, octave_Inf)
-
-SPARSE_MAPPER (abs, SparseComplexMatrix::dmapper, xabs)
-SPARSE_MAPPER (acos, SparseComplexMatrix::cmapper, ::acos)
-SPARSE_MAPPER (acosh, SparseComplexMatrix::cmapper, ::acosh)
-SPARSE_MAPPER (angle, SparseComplexMatrix::dmapper, std::arg)
-SPARSE_MAPPER (arg, SparseComplexMatrix::dmapper, std::arg)
-SPARSE_MAPPER (asin, SparseComplexMatrix::cmapper, ::asin)
-SPARSE_MAPPER (asinh, SparseComplexMatrix::cmapper, ::asinh)
-SPARSE_MAPPER (atan, SparseComplexMatrix::cmapper, ::atan)
-SPARSE_MAPPER (atanh, SparseComplexMatrix::cmapper, ::atanh)
-SPARSE_MAPPER (ceil, SparseComplexMatrix::cmapper, ::ceil)
-SPARSE_MAPPER (conj, SparseComplexMatrix::cmapper, std::conj)
-SPARSE_MAPPER (cos, SparseComplexMatrix::cmapper, std::cos)
-SPARSE_MAPPER (cosh, SparseComplexMatrix::cmapper, std::cosh)
-SPARSE_MAPPER (exp, SparseComplexMatrix::cmapper, std::exp)
-SPARSE_MAPPER (expm1, SparseComplexMatrix::cmapper, ::expm1)
-SPARSE_MAPPER (fix, SparseComplexMatrix::cmapper, ::fix)
-SPARSE_MAPPER (floor, SparseComplexMatrix::cmapper, ::floor)
-SPARSE_MAPPER (imag, SparseComplexMatrix::dmapper, ximag)
-SPARSE_MAPPER (log, SparseComplexMatrix::cmapper, std::log)
-SPARSE_MAPPER (log2, SparseComplexMatrix::cmapper, xlog2)
-SPARSE_MAPPER (log10, SparseComplexMatrix::cmapper, std::log10)
-SPARSE_MAPPER (log1p, SparseComplexMatrix::cmapper, ::log1p)
-SPARSE_MAPPER (real, SparseComplexMatrix::dmapper, xreal)
-SPARSE_MAPPER (round, SparseComplexMatrix::cmapper, xround)
-SPARSE_MAPPER (roundb, SparseComplexMatrix::cmapper, xroundb)
-SPARSE_MAPPER (signum, SparseComplexMatrix::cmapper, ::signum)
-SPARSE_MAPPER (sin, SparseComplexMatrix::cmapper, std::sin)
-SPARSE_MAPPER (sinh, SparseComplexMatrix::cmapper, std::sinh)
-SPARSE_MAPPER (sqrt, SparseComplexMatrix::cmapper, std::sqrt)
-SPARSE_MAPPER (tan, SparseComplexMatrix::cmapper, std::tan)
-SPARSE_MAPPER (tanh, SparseComplexMatrix::cmapper, std::tanh)
-SPARSE_MAPPER (finite, SparseComplexMatrix::bmapper, xfinite)
-SPARSE_MAPPER (isinf, SparseComplexMatrix::bmapper, xisinf)
-SPARSE_MAPPER (isna, SparseComplexMatrix::bmapper, octave_is_NA)
-SPARSE_MAPPER (isnan, SparseComplexMatrix::bmapper, xisnan)
+    default: // Attempt to go via dense matrix.
+      return full_value ().map (umap).sparse_matrix_value ();
+    }
+}
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-cx-sparse.h b/src/ov-cx-sparse.h
--- a/src/ov-cx-sparse.h
+++ b/src/ov-cx-sparse.h
@@ -146,55 +146,17 @@ public:
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
 #endif
 
   mxArray *as_mxArray (void) const;
 
-  octave_value erf (void) const;
-  octave_value erfc (void) const;
-  octave_value gamma (void) const;
-  octave_value lgamma (void) const;
-  octave_value abs (void) const;
-  octave_value acos (void) const;
-  octave_value acosh (void) const;
-  octave_value angle (void) const;
-  octave_value arg (void) const;
-  octave_value asin (void) const;
-  octave_value asinh (void) const;
-  octave_value atan (void) const;
-  octave_value atanh (void) const;
-  octave_value ceil (void) const;
-  octave_value conj (void) const;
-  octave_value cos (void) const;
-  octave_value cosh (void) const;
-  octave_value exp (void) const;
-  octave_value expm1 (void) const;
-  octave_value fix (void) const;
-  octave_value floor (void) const;
-  octave_value imag (void) const;
-  octave_value log (void) const;
-  octave_value log2 (void) const;
-  octave_value log10 (void) const;
-  octave_value log1p (void) const;
-  octave_value real (void) const;
-  octave_value round (void) const;
-  octave_value roundb (void) const;
-  octave_value signum (void) const;
-  octave_value sin (void) const;
-  octave_value sinh (void) const;
-  octave_value sqrt (void) const;
-  octave_value tan (void) const;
-  octave_value tanh (void) const;
-  octave_value finite (void) const;
-  octave_value isinf (void) const;
-  octave_value isna (void) const;
-  octave_value isnan (void) const;
+  octave_value map (unary_mapper_t umap) const;
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/src/ov-float.cc b/src/ov-float.cc
--- a/src/ov-float.cc
+++ b/src/ov-float.cc
@@ -247,75 +247,71 @@ octave_float_scalar::as_mxArray (void) c
 
   float *pr = static_cast<float *> (retval->get_data ());
 
   pr[0] = scalar;
 
   return retval;
 }
 
-#define SCALAR_MAPPER(MAP, FCN) \
-  octave_value \
-  octave_float_scalar::MAP (void) const \
-  { \
-    return octave_value (FCN (scalar)); \
-  }
+octave_value
+octave_float_scalar::map (unary_mapper_t umap) const
+{
+  switch (umap)
+    {
+    case umap_imag:
+      return 0.0f;
 
-#define CD_SCALAR_MAPPER(MAP, RFCN, CFCN, L1, L2) \
-  octave_value \
-  octave_float_scalar::MAP (void) const \
-  { \
-    return (scalar < L1 || scalar > L2 \
-            ? octave_value (CFCN (FloatComplex (scalar))) \
-	    : octave_value (RFCN (scalar))); \
-  }
+    case umap_real:
+    case umap_conj:
+      return scalar;
 
-static float
-xconj (float x)
-{
-  return x;
-}
+#define SCALAR_MAPPER(UMAP, FCN) \
+    case umap_ ## UMAP: \
+      return octave_value (FCN (scalar))
 
-SCALAR_MAPPER (erf, ::erff)
-SCALAR_MAPPER (erfc, ::erfcf)
-SCALAR_MAPPER (gamma, xgamma)
-CD_SCALAR_MAPPER (lgamma, xlgamma, xlgamma, 0.0, octave_Float_Inf)
-SCALAR_MAPPER (abs, ::fabsf)
-CD_SCALAR_MAPPER (acos, ::acosf, ::acos, -1.0, 1.0)
-CD_SCALAR_MAPPER (acosh, ::acoshf, ::acosh, 1.0, octave_Float_Inf)
-SCALAR_MAPPER (angle, ::arg)
-SCALAR_MAPPER (arg, ::arg)
-CD_SCALAR_MAPPER (asin, ::asinf, ::asin, -1.0, 1.0)
-SCALAR_MAPPER (asinh, ::asinhf)
-SCALAR_MAPPER (atan, ::atanf)
-CD_SCALAR_MAPPER (atanh, ::atanhf, ::atanh, -1.0, 1.0)
-SCALAR_MAPPER (ceil, ::ceilf)
-SCALAR_MAPPER (conj, xconj)
-SCALAR_MAPPER (cos, ::cosf)
-SCALAR_MAPPER (cosh, ::coshf)
-SCALAR_MAPPER (exp, ::expf)
-SCALAR_MAPPER (expm1, ::expm1f)
-SCALAR_MAPPER (fix, ::fix)
-SCALAR_MAPPER (floor, ::floorf)
-SCALAR_MAPPER (imag, ::imag)
-CD_SCALAR_MAPPER (log, ::logf, std::log, 0.0, octave_Float_Inf)
-CD_SCALAR_MAPPER (log2, xlog2, xlog2, 0.0, octave_Float_Inf)
-CD_SCALAR_MAPPER (log10, ::log10f, std::log10, 0.0, octave_Float_Inf)
-CD_SCALAR_MAPPER (log1p, ::log1pf, ::log1p, -1.0, octave_Float_Inf)
-SCALAR_MAPPER (real, ::real)
-SCALAR_MAPPER (round, xround)
-SCALAR_MAPPER (roundb, xroundb)
-SCALAR_MAPPER (signum, ::signum)
-SCALAR_MAPPER (sin, ::sinf)
-SCALAR_MAPPER (sinh, ::sinhf)
-CD_SCALAR_MAPPER (sqrt, ::sqrtf, std::sqrt, 0.0, octave_Float_Inf)
-SCALAR_MAPPER (tan, ::tanf)
-SCALAR_MAPPER (tanh, ::tanhf)
-SCALAR_MAPPER (finite, xfinite)
-SCALAR_MAPPER (isinf, xisinf)
-SCALAR_MAPPER (isna, octave_is_NA)
-SCALAR_MAPPER (isnan, xisnan)
+      SCALAR_MAPPER (abs, ::fabsf);
+      SCALAR_MAPPER (acos, rc_acos);
+      SCALAR_MAPPER (acosh, rc_acosh);
+      SCALAR_MAPPER (angle, ::arg);
+      SCALAR_MAPPER (arg, ::arg);
+      SCALAR_MAPPER (asin, rc_asin);
+      SCALAR_MAPPER (asinh, ::asinhf);
+      SCALAR_MAPPER (atan, ::atanf);
+      SCALAR_MAPPER (atanh, rc_atanh);
+      SCALAR_MAPPER (erf, ::erff);
+      SCALAR_MAPPER (erfc, ::erfcf);
+      SCALAR_MAPPER (gamma, xgamma);
+      SCALAR_MAPPER (lgamma, rc_lgamma);
+      SCALAR_MAPPER (ceil, ::ceilf);
+      SCALAR_MAPPER (cos, ::cosf);
+      SCALAR_MAPPER (cosh, ::coshf);
+      SCALAR_MAPPER (exp, ::expf);
+      SCALAR_MAPPER (expm1, ::expm1f);
+      SCALAR_MAPPER (fix, ::fix);
+      SCALAR_MAPPER (floor, ::floorf);
+      SCALAR_MAPPER (log, rc_log);
+      SCALAR_MAPPER (log2, rc_log2);
+      SCALAR_MAPPER (log10, rc_log10);
+      SCALAR_MAPPER (log1p, rc_log1p);
+      SCALAR_MAPPER (round, xround);
+      SCALAR_MAPPER (roundb, xroundb);
+      SCALAR_MAPPER (signum, ::signum);
+      SCALAR_MAPPER (sin, ::sinf);
+      SCALAR_MAPPER (sinh, ::sinhf);
+      SCALAR_MAPPER (sqrt, rc_sqrt);
+      SCALAR_MAPPER (tan, ::tanf);
+      SCALAR_MAPPER (tanh, ::tanhf);
+      SCALAR_MAPPER (finite, xfinite);
+      SCALAR_MAPPER (isinf, xisinf);
+      SCALAR_MAPPER (isna, octave_is_NA);
+      SCALAR_MAPPER (isnan, xisnan);
+
+    default:
+      return octave_base_value::map (umap);
+    }
+}
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-float.h b/src/ov-float.h
--- a/src/ov-float.h
+++ b/src/ov-float.h
@@ -239,58 +239,19 @@ public:
 	     oct_mach_info::float_format flt_fmt) const
     {
       return os.write (array_value (), block_size, output_type,
 		       skip, flt_fmt);
     }
 
   mxArray *as_mxArray (void) const;
 
-  octave_value erf (void) const;
-  octave_value erfc (void) const;
-  octave_value gamma (void) const;
-  octave_value lgamma (void) const;
-  octave_value abs (void) const;
-  octave_value acos (void) const;
-  octave_value acosh (void) const;
-  octave_value angle (void) const;
-  octave_value arg (void) const;
-  octave_value asin (void) const;
-  octave_value asinh (void) const;
-  octave_value atan (void) const;
-  octave_value atanh (void) const;
-  octave_value ceil (void) const;
-  octave_value conj (void) const;
-  octave_value cos (void) const;
-  octave_value cosh (void) const;
-  octave_value exp (void) const;
-  octave_value expm1 (void) const;
-  octave_value fix (void) const;
-  octave_value floor (void) const;
-  octave_value imag (void) const;
-  octave_value log (void) const;
-  octave_value log2 (void) const;
-  octave_value log10 (void) const;
-  octave_value log1p (void) const;
-  octave_value real (void) const;
-  octave_value round (void) const;
-  octave_value roundb (void) const;
-  octave_value signum (void) const;
-  octave_value sin (void) const;
-  octave_value sinh (void) const;
-  octave_value sqrt (void) const;
-  octave_value tan (void) const;
-  octave_value tanh (void) const;
-  octave_value finite (void) const;
-  octave_value isinf (void) const;
-  octave_value isna (void) const;
-  octave_value isnan (void) const;
+  octave_value map (unary_mapper_t umap) const;
 
 private:
-  octave_value map (float (*fcn) (float)) const;
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
diff --git a/src/ov-flt-complex.cc b/src/ov-flt-complex.cc
--- a/src/ov-flt-complex.cc
+++ b/src/ov-flt-complex.cc
@@ -380,110 +380,63 @@ octave_float_complex::as_mxArray (void) 
   float *pi = static_cast<float *> (retval->get_imag_data ());
 
   pr[0] = std::real (scalar);
   pi[0] = std::imag (scalar);
 
   return retval;
 }
 
-static float
-xabs (const FloatComplex& x)
-{
-  return (xisinf (x.real ()) || xisinf (x.imag ())) ? octave_Inf : abs (x);
-}
-
-static float
-ximag (const FloatComplex& x)
-{
-  return x.imag ();
-}
-
-static float
-xreal (const FloatComplex& x)
+octave_value
+octave_float_complex::map (unary_mapper_t umap) const
 {
-  return x.real ();
-}
-
-#define COMPLEX_MAPPER(MAP, FCN)	\
-  octave_value \
-  octave_float_complex::MAP (void) const \
-  { \
-    return octave_value (FCN (scalar)); \
-  }
-
-#define SCALAR_MAPPER(MAP, FCN)	\
-  octave_value \
-  octave_float_complex::MAP (void) const \
-  { \
-    if (scalar.imag () == 0) \
-      return octave_value (FCN (scalar.real ())); \
-    else \
-      { \
-        error ("%s: not defined for complex arguments", #MAP); \
-        return octave_value (); \
-      } \
-  }
+  switch (umap)
+    {
+#define SCALAR_MAPPER(UMAP, FCN) \
+    case umap_ ## UMAP: \
+      return octave_value (FCN (scalar))
 
-#define CD_SCALAR_MAPPER(MAP, RFCN, CFCN, L1, L2) \
-  octave_value \
-  octave_float_complex::MAP (void) const \
-  { \
-    if (scalar.imag () == 0) \
-      { \
-	float re = scalar.real (); \
-	return (re < L1 || re > L2 \
-            ? octave_value (CFCN (scalar)) \
-	    : octave_value (RFCN (re))); \
-      } \
-    else \
-      { \
-        error ("%s: not defined for complex arguments", #MAP); \
-        return octave_value (); \
-      } \
-  }
-
-SCALAR_MAPPER (erf, ::erff)
-SCALAR_MAPPER (erfc, ::erfcf)
-SCALAR_MAPPER (gamma, xgamma)
-CD_SCALAR_MAPPER (lgamma, xlgamma, xlgamma, 0.0, octave_Inf)
+      SCALAR_MAPPER (abs, std::abs);
+      SCALAR_MAPPER (acos, ::acos);
+      SCALAR_MAPPER (acosh, ::acosh);
+      SCALAR_MAPPER (angle, std::arg);
+      SCALAR_MAPPER (arg, std::arg);
+      SCALAR_MAPPER (asin, ::asin);
+      SCALAR_MAPPER (asinh, ::asinh);
+      SCALAR_MAPPER (atan, ::atan);
+      SCALAR_MAPPER (atanh, ::atanh);
+      SCALAR_MAPPER (ceil, ::ceil);
+      SCALAR_MAPPER (conj, std::conj);
+      SCALAR_MAPPER (cos, std::cos);
+      SCALAR_MAPPER (cosh, std::cosh);
+      SCALAR_MAPPER (exp, std::exp);
+      SCALAR_MAPPER (expm1, ::expm1);
+      SCALAR_MAPPER (fix, ::fix);
+      SCALAR_MAPPER (floor, ::floor);
+      SCALAR_MAPPER (imag, std::imag);
+      SCALAR_MAPPER (log, std::log);
+      SCALAR_MAPPER (log2, xlog2);
+      SCALAR_MAPPER (log10, std::log10);
+      SCALAR_MAPPER (log1p, ::log1p);
+      SCALAR_MAPPER (real, std::real);
+      SCALAR_MAPPER (round, xround);
+      SCALAR_MAPPER (roundb, xroundb);
+      SCALAR_MAPPER (signum, ::signum);
+      SCALAR_MAPPER (sin, std::sin);
+      SCALAR_MAPPER (sinh, std::sinh);
+      SCALAR_MAPPER (sqrt, std::sqrt);
+      SCALAR_MAPPER (tan, std::tan);
+      SCALAR_MAPPER (tanh, std::tanh);
+      SCALAR_MAPPER (finite, xfinite);
+      SCALAR_MAPPER (isinf, xisinf);
+      SCALAR_MAPPER (isna, octave_is_NA);
+      SCALAR_MAPPER (isnan, xisnan);
 
-COMPLEX_MAPPER (abs, xabs)
-COMPLEX_MAPPER (acos, ::acos)
-COMPLEX_MAPPER (acosh, ::acosh)
-COMPLEX_MAPPER (angle, std::arg)
-COMPLEX_MAPPER (arg, std::arg)
-COMPLEX_MAPPER (asin, ::asin)
-COMPLEX_MAPPER (asinh, ::asinh)
-COMPLEX_MAPPER (atan, ::atan)
-COMPLEX_MAPPER (atanh, ::atanh)
-COMPLEX_MAPPER (ceil, ::ceil)
-COMPLEX_MAPPER (conj, std::conj)
-COMPLEX_MAPPER (cos, std::cos)
-COMPLEX_MAPPER (cosh, std::cosh)
-COMPLEX_MAPPER (exp, std::exp)
-COMPLEX_MAPPER (expm1, ::expm1f)
-COMPLEX_MAPPER (fix, ::fix)
-COMPLEX_MAPPER (floor, ::floor)
-COMPLEX_MAPPER (imag, ximag)
-COMPLEX_MAPPER (log, std::log)
-COMPLEX_MAPPER (log2, xlog2)
-COMPLEX_MAPPER (log10, std::log10)
-COMPLEX_MAPPER (log1p, ::log1pf)
-COMPLEX_MAPPER (real, xreal)
-COMPLEX_MAPPER (round, xround)
-COMPLEX_MAPPER (roundb, xroundb)
-COMPLEX_MAPPER (signum, ::signum)
-COMPLEX_MAPPER (sin, std::sin)
-COMPLEX_MAPPER (sinh, std::sinh)
-COMPLEX_MAPPER (sqrt, std::sqrt)
-COMPLEX_MAPPER (tan, std::tan)
-COMPLEX_MAPPER (tanh, std::tanh)
-COMPLEX_MAPPER (finite, xfinite)
-COMPLEX_MAPPER (isinf, xisinf)
-COMPLEX_MAPPER (isna, octave_is_NA)
-COMPLEX_MAPPER (isnan, xisnan)
+    default:
+      return octave_base_value::map (umap);
+    }
+}
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-flt-complex.h b/src/ov-flt-complex.h
--- a/src/ov-flt-complex.h
+++ b/src/ov-flt-complex.h
@@ -158,55 +158,17 @@ public:
     {
       // Yes, for compatibility, we drop the imaginary part here.
       return os.write (array_value (true), block_size, output_type,
 		       skip, flt_fmt);
     }
 
   mxArray *as_mxArray (void) const;
 
-  octave_value erf (void) const;
-  octave_value erfc (void) const;
-  octave_value gamma (void) const;
-  octave_value lgamma (void) const;
-  octave_value abs (void) const;
-  octave_value acos (void) const;
-  octave_value acosh (void) const;
-  octave_value angle (void) const;
-  octave_value arg (void) const;
-  octave_value asin (void) const;
-  octave_value asinh (void) const;
-  octave_value atan (void) const;
-  octave_value atanh (void) const;
-  octave_value ceil (void) const;
-  octave_value conj (void) const;
-  octave_value cos (void) const;
-  octave_value cosh (void) const;
-  octave_value exp (void) const;
-  octave_value expm1 (void) const;
-  octave_value fix (void) const;
-  octave_value floor (void) const;
-  octave_value imag (void) const;
-  octave_value log (void) const;
-  octave_value log2 (void) const;
-  octave_value log10 (void) const;
-  octave_value log1p (void) const;
-  octave_value real (void) const;
-  octave_value round (void) const;
-  octave_value roundb (void) const;
-  octave_value signum (void) const;
-  octave_value sin (void) const;
-  octave_value sinh (void) const;
-  octave_value sqrt (void) const;
-  octave_value tan (void) const;
-  octave_value tanh (void) const;
-  octave_value finite (void) const;
-  octave_value isinf (void) const;
-  octave_value isna (void) const;
-  octave_value isnan (void) const;
+  octave_value map (unary_mapper_t umap) const;
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/src/ov-flt-cx-diag.cc b/src/ov-flt-cx-diag.cc
--- a/src/ov-flt-cx-diag.cc
+++ b/src/ov-flt-cx-diag.cc
@@ -115,53 +115,40 @@ octave_float_complex_diag_matrix::comple
 
 FloatComplexDiagMatrix
 octave_float_complex_diag_matrix::float_complex_diag_matrix_value (bool) const
 {
   return matrix;
 }
 
 octave_value
-octave_float_complex_diag_matrix::abs (void) const
-{
-  return matrix.abs ();
-}
-
-octave_value
-octave_float_complex_diag_matrix::real (void) const
+octave_float_complex_diag_matrix::map (unary_mapper_t umap) const
 {
-  return ::real (matrix);
-}
-
-octave_value
-octave_float_complex_diag_matrix::conj (void) const
-{
-  return ::conj (matrix);
+  switch (umap)
+    {
+    case umap_abs:
+      return matrix.abs ();
+    case umap_real:
+      return ::real (matrix);
+    case umap_conj:
+      return ::conj (matrix);
+    case umap_imag:
+      return ::imag (matrix);
+    case umap_sqrt:
+      {
+        FloatComplexColumnVector tmp = matrix.diag ().map<FloatComplex> (std::sqrt);
+        FloatComplexDiagMatrix retval (tmp);
+        retval.resize (matrix.rows (), matrix.columns ());
+        return retval;
+      }
+    default:
+      return to_dense ().map (umap);
+    }
 }
 
-octave_value
-octave_float_complex_diag_matrix::imag (void) const
-{
-  return ::imag (matrix);
-}
-
-octave_value
-octave_float_complex_diag_matrix::sqrt (void) const
-{    
-  octave_value retval;
-
-  static FloatComplexNDArray::cmapper csqrt = std::sqrt;
-
-  FloatComplexColumnVector dvec = matrix.diag ();
-  retval = FloatComplexDiagMatrix (dvec.map (csqrt));
-
-  retval.resize (dims ());
-
-  return retval;
-}
 
 bool 
 octave_float_complex_diag_matrix::save_binary (std::ostream& os, 
                                                bool& /* save_as_floats */)
 {
 
   int32_t r = matrix.rows (), c = matrix.cols ();
   os.write (reinterpret_cast<char *> (&r), 4);
diff --git a/src/ov-flt-cx-diag.h b/src/ov-flt-cx-diag.h
--- a/src/ov-flt-cx-diag.h
+++ b/src/ov-flt-cx-diag.h
@@ -73,21 +73,17 @@ public:
 
   FloatComplexDiagMatrix float_complex_diag_matrix_value (bool = false) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
-  octave_value abs (void) const;
-  octave_value conj (void) const;
-  octave_value imag (void) const;
-  octave_value real (void) const;
-  octave_value sqrt (void) const;
+  octave_value map (unary_mapper_t umap) const;
 
 private:
 
   bool chk_valid_scalar (const octave_value&, 
                          FloatComplex&) const;
 
   DECLARE_OCTAVE_ALLOCATOR
 
diff --git a/src/ov-flt-cx-mat.cc b/src/ov-flt-cx-mat.cc
--- a/src/ov-flt-cx-mat.cc
+++ b/src/ov-flt-cx-mat.cc
@@ -681,197 +681,73 @@ octave_float_complex_matrix::as_mxArray 
     {
       pr[i] = std::real (p[i]);
       pi[i] = std::imag (p[i]);
     }
 
   return retval;
 }
 
-#if 0
-static float
-xabs (const FloatComplex& x)
-{
-  return (xisinf (x.real ()) || xisinf (x.imag ())) ? octave_Inf : abs (x);
-}
-#endif
-
-static float
-ximag (const FloatComplex& x)
-{
-  return x.imag ();
-}
-
-static float
-xreal (const FloatComplex& x)
-{
-  return x.real ();
-}
-
-static bool
-any_element_less_than (const FloatNDArray& a, float val)
-{
-  octave_idx_type len = a.length ();
-  const float *m = a.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < len; i++)
-    {
-      OCTAVE_QUIT;
-
-      if (m[i] < val)
-	return true;
-    }
-
-  return false;
-}
-
-static bool
-any_element_greater_than (const FloatNDArray& a, float val)
+octave_value
+octave_float_complex_matrix::map (unary_mapper_t umap) const
 {
-  octave_idx_type len = a.length ();
-  const float *m = a.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < len; i++)
+  switch (umap)
     {
-      OCTAVE_QUIT;
-
-      if (m[i] > val)
-	return true;
-    }
-
-  return false;
-}
+    // Mappers handled specially.
+    case umap_real:
+      return ::real (matrix);
+    case umap_imag:
+      return ::imag (matrix);
+    case umap_conj:
+      return ::conj (matrix);
 
-#define ARRAY_MAPPER(MAP, AMAP, FCN) \
-  octave_value \
-  octave_float_complex_matrix::MAP (void) const \
-  { \
-    static AMAP cmap = FCN; \
-    return matrix.map (cmap); \
-  }
+#define ARRAY_METHOD_MAPPER(UMAP, FCN) \
+    case umap_ ## UMAP: \
+      return octave_value (matrix.FCN ())
 
-#define DARRAY_MAPPER(MAP, AMAP, FCN) \
-  octave_value \
-  octave_float_complex_matrix::MAP (void) const \
-  { \
-    static FloatComplexNDArray::dmapper dmap = ximag; \
-    FloatNDArray m = matrix.map (dmap); \
-    if (m.all_elements_are_zero ()) \
-      { \
-	dmap = xreal; \
-	m = matrix.map (dmap); \
-        static AMAP cmap = FCN; \
-        return m.map (cmap); \
-      } \
-    else \
-      { \
-        error ("%s: not defined for complex arguments", #MAP); \
-        return octave_value (); \
-      } \
-  }
+      ARRAY_METHOD_MAPPER (abs, abs);
+      ARRAY_METHOD_MAPPER (isnan, isnan);
+      ARRAY_METHOD_MAPPER (isinf, isinf);
+      ARRAY_METHOD_MAPPER (finite, isfinite);
+
+#define ARRAY_MAPPER(UMAP, TYPE, FCN) \
+    case umap_ ## UMAP: \
+      return octave_value (matrix.map<TYPE> (FCN))
 
-#define CD_ARRAY_MAPPER(MAP, RFCN, CFCN, L1, L2) \
-  octave_value \
-  octave_float_complex_matrix::MAP (void) const \
-  { \
-    static FloatComplexNDArray::dmapper idmap = ximag; \
-    NDArray m = matrix.map (idmap); \
-    if (m.all_elements_are_zero ()) \
-      { \
-	static FloatComplexNDArray::dmapper rdmap = xreal; \
-	m = matrix.map (rdmap); \
-        static NDArray::dmapper dmap = RFCN; \
-        static NDArray::cmapper cmap = CFCN; \
-        return (any_element_less_than (m, L1) \
-                ? octave_value (m.map (cmap)) \
-	        : (any_element_greater_than (m, L2) \
-	           ? octave_value (m.map (cmap)) \
-	           : octave_value (m.map (dmap)))); \
-      } \
-    else \
-      { \
-        /*error ("%s: not defined for complex arguments", #MAP); */	\
-        return octave_value (m); \
-      } \
-  }
-
-// The fast mappers.
-octave_value
-octave_float_complex_matrix::abs (void) const
-{
-  return matrix.abs ();
-}
-
-octave_value
-octave_float_complex_matrix::real (void) const
-{
-  return ::real (matrix);
-}
-
-octave_value
-octave_float_complex_matrix::conj (void) const
-{
-  return ::conj (matrix);
-}
-
-octave_value
-octave_float_complex_matrix::imag (void) const
-{
-  return ::imag (matrix);
-}
+      ARRAY_MAPPER (acos, FloatComplex, ::acos);
+      ARRAY_MAPPER (acosh, FloatComplex, ::acosh);
+      ARRAY_MAPPER (angle, float, std::arg);
+      ARRAY_MAPPER (arg, float, std::arg);
+      ARRAY_MAPPER (asin, FloatComplex, ::asin);
+      ARRAY_MAPPER (asinh, FloatComplex, ::asinh);
+      ARRAY_MAPPER (atan, FloatComplex, ::atan);
+      ARRAY_MAPPER (atanh, FloatComplex, ::atanh);
+      ARRAY_MAPPER (ceil, FloatComplex, ::ceil);
+      ARRAY_MAPPER (cos, FloatComplex, std::cos);
+      ARRAY_MAPPER (cosh, FloatComplex, std::cosh);
+      ARRAY_MAPPER (exp, FloatComplex, std::exp);
+      ARRAY_MAPPER (expm1, FloatComplex, ::expm1);
+      ARRAY_MAPPER (fix, FloatComplex, ::fix);
+      ARRAY_MAPPER (floor, FloatComplex, ::floor);
+      ARRAY_MAPPER (log, FloatComplex, std::log);
+      ARRAY_MAPPER (log2, FloatComplex, xlog2);
+      ARRAY_MAPPER (log10, FloatComplex, std::log10);
+      ARRAY_MAPPER (log1p, FloatComplex, ::log1p);
+      ARRAY_MAPPER (round, FloatComplex, xround);
+      ARRAY_MAPPER (roundb, FloatComplex, xroundb);
+      ARRAY_MAPPER (signum, FloatComplex, ::signum);
+      ARRAY_MAPPER (sin, FloatComplex, std::sin);
+      ARRAY_MAPPER (sinh, FloatComplex, std::sinh);
+      ARRAY_MAPPER (sqrt, FloatComplex, std::sqrt);
+      ARRAY_MAPPER (tan, FloatComplex, std::tan);
+      ARRAY_MAPPER (tanh, FloatComplex, std::tanh);
+      ARRAY_MAPPER (isna, bool, octave_is_NA);
 
-octave_value
-octave_float_complex_matrix::isnan (void) const
-{
-  return matrix.isnan ();
-}
-
-octave_value
-octave_float_complex_matrix::isinf (void) const
-{
-  return matrix.isinf ();
-}
-
-octave_value
-octave_float_complex_matrix::finite (void) const
-{
-  return matrix.isfinite ();
+    default:
+      return octave_base_value::map (umap);
+    }
 }
 
-DARRAY_MAPPER (erf, FloatNDArray::dmapper, ::erff)
-DARRAY_MAPPER (erfc, FloatNDArray::dmapper, ::erfcf)
-DARRAY_MAPPER (gamma, FloatNDArray::dmapper, xgamma)
-CD_ARRAY_MAPPER (lgamma, xlgamma, xlgamma, 0.0, octave_Inf)
-
-ARRAY_MAPPER (acos, FloatComplexNDArray::cmapper, ::acos)
-ARRAY_MAPPER (acosh, FloatComplexNDArray::cmapper, ::acosh)
-ARRAY_MAPPER (angle, FloatComplexNDArray::dmapper, std::arg)
-ARRAY_MAPPER (arg, FloatComplexNDArray::dmapper, std::arg)
-ARRAY_MAPPER (asin, FloatComplexNDArray::cmapper, ::asin)
-ARRAY_MAPPER (asinh, FloatComplexNDArray::cmapper, ::asinh)
-ARRAY_MAPPER (atan, FloatComplexNDArray::cmapper, ::atan)
-ARRAY_MAPPER (atanh, FloatComplexNDArray::cmapper, ::atanh)
-ARRAY_MAPPER (ceil, FloatComplexNDArray::cmapper, ::ceil)
-ARRAY_MAPPER (cos, FloatComplexNDArray::cmapper, std::cos)
-ARRAY_MAPPER (cosh, FloatComplexNDArray::cmapper, std::cosh)
-ARRAY_MAPPER (exp, FloatComplexNDArray::cmapper, std::exp)
-ARRAY_MAPPER (expm1, FloatComplexNDArray::cmapper, ::expm1f)
-ARRAY_MAPPER (fix, FloatComplexNDArray::cmapper, ::fix)
-ARRAY_MAPPER (floor, FloatComplexNDArray::cmapper, ::floor)
-ARRAY_MAPPER (log, FloatComplexNDArray::cmapper, std::log)
-ARRAY_MAPPER (log2, FloatComplexNDArray::cmapper, xlog2)
-ARRAY_MAPPER (log10, FloatComplexNDArray::cmapper, std::log10)
-ARRAY_MAPPER (log1p, FloatComplexNDArray::cmapper, ::log1pf)
-ARRAY_MAPPER (round, FloatComplexNDArray::cmapper, xround)
-ARRAY_MAPPER (roundb, FloatComplexNDArray::cmapper, xroundb)
-ARRAY_MAPPER (signum, FloatComplexNDArray::cmapper, ::signum)
-ARRAY_MAPPER (sin, FloatComplexNDArray::cmapper, std::sin)
-ARRAY_MAPPER (sinh, FloatComplexNDArray::cmapper, std::sinh)
-ARRAY_MAPPER (sqrt, FloatComplexNDArray::cmapper, std::sqrt)
-ARRAY_MAPPER (tan, FloatComplexNDArray::cmapper, std::tan)
-ARRAY_MAPPER (tanh, FloatComplexNDArray::cmapper, std::tanh)
-ARRAY_MAPPER (isna, FloatComplexNDArray::bmapper, octave_is_NA)
-
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-flt-cx-mat.h b/src/ov-flt-cx-mat.h
--- a/src/ov-flt-cx-mat.h
+++ b/src/ov-flt-cx-mat.h
@@ -161,55 +161,17 @@ public:
       return os.write (matrix_value (true), block_size, output_type,
 		       skip, flt_fmt);
     }
 
   void print_raw (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   mxArray *as_mxArray (void) const;
 
-  octave_value erf (void) const;
-  octave_value erfc (void) const;
-  octave_value gamma (void) const;
-  octave_value lgamma (void) const;
-  octave_value abs (void) const;
-  octave_value acos (void) const;
-  octave_value acosh (void) const;
-  octave_value angle (void) const;
-  octave_value arg (void) const;
-  octave_value asin (void) const;
-  octave_value asinh (void) const;
-  octave_value atan (void) const;
-  octave_value atanh (void) const;
-  octave_value ceil (void) const;
-  octave_value conj (void) const;
-  octave_value cos (void) const;
-  octave_value cosh (void) const;
-  octave_value exp (void) const;
-  octave_value expm1 (void) const;
-  octave_value fix (void) const;
-  octave_value floor (void) const;
-  octave_value imag (void) const;
-  octave_value log (void) const;
-  octave_value log2 (void) const;
-  octave_value log10 (void) const;
-  octave_value log1p (void) const;
-  octave_value real (void) const;
-  octave_value round (void) const;
-  octave_value roundb (void) const;
-  octave_value signum (void) const;
-  octave_value sin (void) const;
-  octave_value sinh (void) const;
-  octave_value sqrt (void) const;
-  octave_value tan (void) const;
-  octave_value tanh (void) const;
-  octave_value finite (void) const;
-  octave_value isinf (void) const;
-  octave_value isna (void) const;
-  octave_value isnan (void) const;
+  octave_value map (unary_mapper_t umap) const;
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/src/ov-flt-re-diag.cc b/src/ov-flt-re-diag.cc
--- a/src/ov-flt-re-diag.cc
+++ b/src/ov-flt-re-diag.cc
@@ -86,56 +86,37 @@ octave_float_diag_matrix::complex_diag_m
 
 FloatComplexDiagMatrix
 octave_float_diag_matrix::float_complex_diag_matrix_value (bool) const
 {
   return FloatComplexDiagMatrix (matrix);
 }
 
 octave_value
-octave_float_diag_matrix::abs (void) const
-{
-  return matrix.abs ();
-}
-
-octave_value
-octave_float_diag_matrix::real (void) const
-{
-  return matrix;
-}
-
-octave_value
-octave_float_diag_matrix::conj (void) const
-{
-  return matrix;
-}
-
-octave_value
-octave_float_diag_matrix::imag (void) const
+octave_float_diag_matrix::map (unary_mapper_t umap) const
 {
-  return DiagMatrix (matrix.rows (), matrix.cols (), 0.0f);
-}
-
-octave_value
-octave_float_diag_matrix::sqrt (void) const
-{    
-  octave_value retval;
-
-  static FloatNDArray::dmapper dsqrt = ::sqrtf;
-  static FloatNDArray::cmapper csqrt = std::sqrt;
-
-  FloatColumnVector dvec = matrix.diag ();
-  if (FloatMatrix (dvec).any_element_is_negative ())
-    retval = FloatComplexDiagMatrix (dvec.map (csqrt));
-  else
-    retval = FloatDiagMatrix (dvec.map (dsqrt));
-
-  retval.resize (dims ());
-
-  return retval;
+  switch (umap)
+    {
+    case umap_abs:
+      return matrix.abs ();
+    case umap_real:
+    case umap_conj:
+      return matrix;
+    case umap_imag:
+      return DiagMatrix (matrix.rows (), matrix.cols (), 0.0);
+    case umap_sqrt:
+      {
+        FloatComplexColumnVector tmp = matrix.diag ().map<FloatComplex> (rc_sqrt);
+        FloatComplexDiagMatrix retval (tmp);
+        retval.resize (matrix.rows (), matrix.columns ());
+        return retval;
+      }
+    default:
+      return to_dense ().map (umap);
+    }
 }
 
 bool 
 octave_float_diag_matrix::save_binary (std::ostream& os,
 				       bool& /* save_as_floats*/)
 {
 
   int32_t r = matrix.rows (), c = matrix.cols ();
diff --git a/src/ov-flt-re-diag.h b/src/ov-flt-re-diag.h
--- a/src/ov-flt-re-diag.h
+++ b/src/ov-flt-re-diag.h
@@ -73,21 +73,17 @@ public:
 
   FloatComplexDiagMatrix float_complex_diag_matrix_value (bool = false) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
-  octave_value abs (void) const;
-  octave_value conj (void) const;
-  octave_value imag (void) const;
-  octave_value real (void) const;
-  octave_value sqrt (void) const;
+  octave_value map (unary_mapper_t umap) const;
 
 private:
 
   bool chk_valid_scalar (const octave_value&, 
                          float&) const;
 
   DECLARE_OCTAVE_ALLOCATOR
 
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -675,147 +675,79 @@ octave_float_matrix::as_mxArray (void) c
   const float *p = matrix.data ();
 
   for (mwIndex i = 0; i < nel; i++)
     pr[i] = p[i];
 
   return retval;
 }
 
-static bool
-any_element_less_than (const FloatNDArray& a, float val)
-{
-  octave_idx_type len = a.length ();
-  const float *m = a.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < len; i++)
-    {
-      OCTAVE_QUIT;
-
-      if (m[i] < val)
-	return true;
-    }
-
-  return false;
-}
-
-static bool
-any_element_greater_than (const FloatNDArray& a, float val)
-{
-  octave_idx_type len = a.length ();
-  const float *m = a.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < len; i++)
-    {
-      OCTAVE_QUIT;
-
-      if (m[i] > val)
-	return true;
-    }
-
-  return false;
-}
-
-#define ARRAY_MAPPER(MAP, AMAP, FCN) \
-  octave_value \
-  octave_float_matrix::MAP (void) const \
-  { \
-    static AMAP dmap = FCN; \
-    return matrix.map (dmap); \
-  }
-
-#define CD_ARRAY_MAPPER(MAP, RFCN, CFCN, L1, L2) \
-  octave_value \
-  octave_float_matrix::MAP (void) const \
-  { \
-    static FloatNDArray::dmapper dmap = RFCN; \
-    static FloatNDArray::cmapper cmap = CFCN; \
- \
-    return (any_element_less_than (matrix, L1) \
-            ? octave_value (matrix.map (cmap)) \
-	    : (any_element_greater_than (matrix, L2) \
-	       ? octave_value (matrix.map (cmap)) \
-	       : octave_value (matrix.map (dmap)))); \
-  }
-
-// The fast mappers.
 octave_value
-octave_float_matrix::abs (void) const
-{
-  return matrix.abs ();
-}
-
-octave_value
-octave_float_matrix::real (void) const
+octave_float_matrix::map (unary_mapper_t umap) const
 {
-  return matrix;
-}
+  switch (umap)
+    {
+    case umap_imag:
+      return FloatNDArray (matrix.dims (), 0.0);
 
-octave_value
-octave_float_matrix::conj (void) const
-{
-  return matrix;
-}
-
-octave_value
-octave_float_matrix::imag (void) const
-{
-  return FloatNDArray (matrix.dims (), 0.0);
-}
+    case umap_real:
+    case umap_conj:
+      return matrix;
 
-octave_value
-octave_float_matrix::isnan (void) const
-{
-  return matrix.isnan ();
-}
+    // Mappers handled specially.
+#define ARRAY_METHOD_MAPPER(UMAP, FCN) \
+    case umap_ ## UMAP: \
+      return octave_value (matrix.FCN ())
 
-octave_value
-octave_float_matrix::isinf (void) const
-{
-  return matrix.isinf ();
-}
+      ARRAY_METHOD_MAPPER (abs, abs);
+      ARRAY_METHOD_MAPPER (isnan, isnan);
+      ARRAY_METHOD_MAPPER (isinf, isinf);
+      ARRAY_METHOD_MAPPER (finite, isfinite);
 
-octave_value
-octave_float_matrix::finite (void) const
-{
-  return matrix.isfinite ();
-}
+#define ARRAY_MAPPER(UMAP, TYPE, FCN) \
+    case umap_ ## UMAP: \
+      return octave_value (matrix.map<TYPE> (FCN))
 
-ARRAY_MAPPER (erf, FloatNDArray::dmapper, ::erff)
-ARRAY_MAPPER (erfc, FloatNDArray::dmapper, ::erfcf)
-ARRAY_MAPPER (gamma, FloatNDArray::dmapper, xgamma)
-CD_ARRAY_MAPPER (lgamma, xlgamma, xlgamma, 0.0, octave_Float_Inf)
-CD_ARRAY_MAPPER (acos, ::acosf, ::acos, -1.0, 1.0)
-CD_ARRAY_MAPPER (acosh, ::acoshf, ::acosh, 1.0, octave_Float_Inf)
-ARRAY_MAPPER (angle, FloatNDArray::dmapper, ::arg)
-ARRAY_MAPPER (arg, FloatNDArray::dmapper, ::arg)
-CD_ARRAY_MAPPER (asin, ::asinf, ::asin, -1.0, 1.0)
-ARRAY_MAPPER (asinh, FloatNDArray::dmapper,::asinhf)
-ARRAY_MAPPER (atan, FloatNDArray::dmapper, ::atanf)
-CD_ARRAY_MAPPER (atanh, ::atanhf, ::atanh, -1.0, 1.0)
-ARRAY_MAPPER (ceil, FloatNDArray::dmapper, ::ceilf)
-ARRAY_MAPPER (cos, FloatNDArray::dmapper, ::cosf)
-ARRAY_MAPPER (cosh, FloatNDArray::dmapper, ::coshf)
-ARRAY_MAPPER (exp, FloatNDArray::dmapper, ::expf)
-ARRAY_MAPPER (expm1, FloatNDArray::dmapper, ::expm1f)
-ARRAY_MAPPER (fix, FloatNDArray::dmapper, ::fix)
-ARRAY_MAPPER (floor, FloatNDArray::dmapper, ::floorf)
-CD_ARRAY_MAPPER (log, ::logf, std::log, 0.0, octave_Float_Inf)
-CD_ARRAY_MAPPER (log2, xlog2, xlog2, 0.0, octave_Float_Inf)
-CD_ARRAY_MAPPER (log10, ::log10f, std::log10, 0.0, octave_Float_Inf)
-CD_ARRAY_MAPPER (log1p, ::log1pf, ::log1pf, -1.0, octave_Float_Inf)
-ARRAY_MAPPER (round, FloatNDArray::dmapper, xround)
-ARRAY_MAPPER (roundb, FloatNDArray::dmapper, xroundb)
-ARRAY_MAPPER (signum, FloatNDArray::dmapper, ::signum)
-ARRAY_MAPPER (sin, FloatNDArray::dmapper, ::sinf)
-ARRAY_MAPPER (sinh, FloatNDArray::dmapper, ::sinhf)
-CD_ARRAY_MAPPER (sqrt, ::sqrtf, std::sqrt, 0.0, octave_Float_Inf)
-ARRAY_MAPPER (tan, FloatNDArray::dmapper, ::tanf)
-ARRAY_MAPPER (tanh, FloatNDArray::dmapper, ::tanhf)
-ARRAY_MAPPER (isna, FloatNDArray::bmapper, octave_is_NA)
+      ARRAY_MAPPER (acos, FloatComplex, rc_acos);
+      ARRAY_MAPPER (acosh, FloatComplex, rc_acosh);
+      ARRAY_MAPPER (angle, float, ::arg);
+      ARRAY_MAPPER (arg, float, ::arg);
+      ARRAY_MAPPER (asin, FloatComplex, rc_asin);
+      ARRAY_MAPPER (asinh, float, ::asinhf);
+      ARRAY_MAPPER (atan, float, ::atanf);
+      ARRAY_MAPPER (atanh, FloatComplex, rc_atanh);
+      ARRAY_MAPPER (erf, float, ::erff);
+      ARRAY_MAPPER (erfc, float, ::erfcf);
+      ARRAY_MAPPER (gamma, float, xgamma);
+      ARRAY_MAPPER (lgamma, FloatComplex, rc_lgamma);
+      ARRAY_MAPPER (ceil, float, ::ceilf);
+      ARRAY_MAPPER (cos, float, ::cosf);
+      ARRAY_MAPPER (cosh, float, ::coshf);
+      ARRAY_MAPPER (exp, float, ::expf);
+      ARRAY_MAPPER (expm1, float, ::expm1f);
+      ARRAY_MAPPER (fix, float, ::fix);
+      ARRAY_MAPPER (floor, float, ::floorf);
+      ARRAY_MAPPER (log, FloatComplex, rc_log);
+      ARRAY_MAPPER (log2, FloatComplex, rc_log2);
+      ARRAY_MAPPER (log10, FloatComplex, rc_log10);
+      ARRAY_MAPPER (log1p, FloatComplex, rc_log1p);
+      ARRAY_MAPPER (round, float, xround);
+      ARRAY_MAPPER (roundb, float, xroundb);
+      ARRAY_MAPPER (signum, float, ::signum);
+      ARRAY_MAPPER (sin, float, ::sinf);
+      ARRAY_MAPPER (sinh, float, ::sinhf);
+      ARRAY_MAPPER (sqrt, FloatComplex, rc_sqrt);
+      ARRAY_MAPPER (tan, float, ::tanf);
+      ARRAY_MAPPER (tanh, float, ::tanhf);
+      ARRAY_MAPPER (isna, bool, octave_is_NA);
+
+    default:
+      return octave_base_value::map (umap);
+    }
+}
 
 DEFUN (single, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} single (@var{x})\n\
 Convert @var{x} to single precision type.\n\
 @seealso{double}\n\
 @end deftypefn")
 {
diff --git a/src/ov-flt-re-mat.h b/src/ov-flt-re-mat.h
--- a/src/ov-flt-re-mat.h
+++ b/src/ov-flt-re-mat.h
@@ -197,55 +197,17 @@ public:
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
   mxArray *as_mxArray (void) const;
 
-  octave_value erf (void) const;
-  octave_value erfc (void) const;
-  octave_value gamma (void) const;
-  octave_value lgamma (void) const;
-  octave_value abs (void) const;
-  octave_value acos (void) const;
-  octave_value acosh (void) const;
-  octave_value angle (void) const;
-  octave_value arg (void) const;
-  octave_value asin (void) const;
-  octave_value asinh (void) const;
-  octave_value atan (void) const;
-  octave_value atanh (void) const;
-  octave_value ceil (void) const;
-  octave_value conj (void) const;
-  octave_value cos (void) const;
-  octave_value cosh (void) const;
-  octave_value exp (void) const;
-  octave_value expm1 (void) const;
-  octave_value fix (void) const;
-  octave_value floor (void) const;
-  octave_value imag (void) const;
-  octave_value log (void) const;
-  octave_value log2 (void) const;
-  octave_value log10 (void) const;
-  octave_value log1p (void) const;
-  octave_value real (void) const;
-  octave_value round (void) const;
-  octave_value roundb (void) const;
-  octave_value signum (void) const;
-  octave_value sin (void) const;
-  octave_value sinh (void) const;
-  octave_value sqrt (void) const;
-  octave_value tan (void) const;
-  octave_value tanh (void) const;
-  octave_value finite (void) const;
-  octave_value isinf (void) const;
-  octave_value isna (void) const;
-  octave_value isnan (void) const;
+  octave_value map (unary_mapper_t umap) const;
 
 private:
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/src/ov-intx.h b/src/ov-intx.h
--- a/src/ov-intx.h
+++ b/src/ov-intx.h
@@ -350,52 +350,47 @@ public:
     const OCTAVE_INT_T *p = matrix.data ();
 
     for (mwIndex i = 0; i < nel; i++)
       pr[i] = p[i].value ();
 
     return retval;
   }
 
-#define MAT_MAPPER(FCN) \
-  octave_value FCN (void) const { return matrix.FCN (); }
-
-  MAT_MAPPER (abs)
-  MAT_MAPPER (signum)
-
-#undef MAT_MAPPER
-
-  octave_value imag (void) const
-  {
-    return intNDArray<OCTAVE_INT_T> (matrix.dims (),
-				     static_cast<OCTAVE_INT_T>(0));
-  }
-
-#define NO_OP_MAPPER(FCN) \
-  octave_value FCN (void) const { return octave_value (matrix); }
+  octave_value map (unary_mapper_t umap) const
+    {
+      switch (umap)
+        {
+        case umap_abs:
+          return matrix.abs ();
+        case umap_signum:
+          return matrix.signum ();
+        case umap_ceil:
+        case umap_conj:
+        case umap_fix:
+        case umap_floor:
+        case umap_real:
+        case umap_round:
+          return matrix;
+        case umap_imag:
+          return intNDArray<OCTAVE_INT_T> (matrix.dims (), OCTAVE_INT_T ());
+        case umap_isnan:
+        case umap_isna:
+        case umap_isinf:
+          return boolNDArray (matrix.dims (), false);
+        case umap_finite:
+          return boolNDArray (matrix.dims (), true);
 
-  NO_OP_MAPPER (ceil)
-  NO_OP_MAPPER (conj)
-  NO_OP_MAPPER (fix)
-  NO_OP_MAPPER (floor)
-  NO_OP_MAPPER (real)
-  NO_OP_MAPPER (round)
-  NO_OP_MAPPER (roundb)
-
-#undef NO_OP_MAPPER
-
-#define BOOL_MAPPER(FCN, VAL) \
-  octave_value FCN (void) const { return boolNDArray (matrix.dims (), VAL); }
-
-  BOOL_MAPPER (finite, true)
-  BOOL_MAPPER (isinf, false)
-  BOOL_MAPPER (isna, false)
-  BOOL_MAPPER (isnan, false)
-
-#undef BOOL_MAPPER
+        default: 
+          {
+            octave_matrix m (array_value ());
+            return m.map (umap);
+          }
+        }
+    }
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
@@ -668,47 +663,47 @@ public:
 
     OCTAVE_INT_T::val_type *pr = static_cast<OCTAVE_INT_T::val_type *> (retval->get_data ());
 
     pr[0] = scalar.value ();
 
     return retval;
   }
 
-#define SCALAR_MAPPER(FCN) \
-  octave_value FCN (void) const { return scalar.FCN (); }
-
-  SCALAR_MAPPER (abs)
-  SCALAR_MAPPER (signum)
-
-#undef SCALAR_MAPPER
-
-  octave_value imag (void) const { return static_cast<OCTAVE_INT_T>(0); }
-
-#define NO_OP_MAPPER(FCN) \
-  octave_value FCN (void) const { return octave_value (scalar); }
+  octave_value map (unary_mapper_t umap) const
+    {
+      switch (umap)
+        {
+        case umap_abs:
+          return scalar.abs ();
+        case umap_signum:
+          return scalar.signum ();
+        case umap_ceil:
+        case umap_conj:
+        case umap_fix:
+        case umap_floor:
+        case umap_real:
+        case umap_round:
+          return scalar;
+        case umap_imag:
+          return OCTAVE_INT_T ();
+        case umap_isnan:
+        case umap_isna:
+        case umap_isinf:
+          return false;
+        case umap_finite:
+          return true;
 
-  NO_OP_MAPPER (ceil)
-  NO_OP_MAPPER (conj)
-  NO_OP_MAPPER (fix)
-  NO_OP_MAPPER (floor)
-  NO_OP_MAPPER (real)
-  NO_OP_MAPPER (round)
-  NO_OP_MAPPER (roundb)
-
-#undef NO_OP_MAPPER
-
-#define BOOL_MAPPER(FCN, VAL) octave_value FCN (void) const { return VAL; }
-
-  BOOL_MAPPER (finite, true)
-  BOOL_MAPPER (isinf, false)
-  BOOL_MAPPER (isna, false)
-  BOOL_MAPPER (isnan, false)
-
-#undef BOOL_MAPPER
+        default: 
+          {
+            octave_scalar m (scalar_value ());
+            return m.map (umap);
+          }
+        }
+    }
 
 private:
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
diff --git a/src/ov-perm.cc b/src/ov-perm.cc
--- a/src/ov-perm.cc
+++ b/src/ov-perm.cc
@@ -406,63 +406,16 @@ octave_value
 octave_perm_matrix::to_dense (void) const
 {
   if (! dense_cache.is_defined ())
       dense_cache = Matrix (matrix);
 
   return dense_cache;
 }
 
-#define FORWARD_MAPPER(MAP) \
-  octave_value \
-  octave_perm_matrix::MAP (void) const \
-  { \
-    return to_dense ().MAP (); \
-  }
-
-FORWARD_MAPPER (erf)
-FORWARD_MAPPER (erfc)
-FORWARD_MAPPER (gamma)
-FORWARD_MAPPER (lgamma)
-FORWARD_MAPPER (abs)
-FORWARD_MAPPER (acos)
-FORWARD_MAPPER (acosh)
-FORWARD_MAPPER (angle)
-FORWARD_MAPPER (arg)
-FORWARD_MAPPER (asin)
-FORWARD_MAPPER (asinh)
-FORWARD_MAPPER (atan)
-FORWARD_MAPPER (atanh)
-FORWARD_MAPPER (ceil)
-FORWARD_MAPPER (conj)
-FORWARD_MAPPER (cos)
-FORWARD_MAPPER (cosh)
-FORWARD_MAPPER (exp)
-FORWARD_MAPPER (expm1)
-FORWARD_MAPPER (fix)
-FORWARD_MAPPER (floor)
-FORWARD_MAPPER (imag)
-FORWARD_MAPPER (log)
-FORWARD_MAPPER (log2)
-FORWARD_MAPPER (log10)
-FORWARD_MAPPER (log1p)
-FORWARD_MAPPER (real)
-FORWARD_MAPPER (round)
-FORWARD_MAPPER (roundb)
-FORWARD_MAPPER (signum)
-FORWARD_MAPPER (sin)
-FORWARD_MAPPER (sinh)
-FORWARD_MAPPER (sqrt)
-FORWARD_MAPPER (tan)
-FORWARD_MAPPER (tanh)
-FORWARD_MAPPER (finite)
-FORWARD_MAPPER (isinf)
-FORWARD_MAPPER (isna)
-FORWARD_MAPPER (isnan)
-
 DEFINE_OCTAVE_ALLOCATOR (octave_perm_matrix);
 
 DEFINE_OV_TYPEID_FUNCTIONS_AND_DATA (octave_perm_matrix, 
                                      "permutation matrix", "double");
 
 static octave_base_value *
 default_numeric_conversion_function (const octave_base_value& a)
 {
diff --git a/src/ov-perm.h b/src/ov-perm.h
--- a/src/ov-perm.h
+++ b/src/ov-perm.h
@@ -204,55 +204,18 @@ public:
   mxArray *as_mxArray (void) const;
 
   bool print_as_scalar (void) const;
 
   void print (std::ostream& os, bool pr_as_read_syntax = false) const;
 
   void print_info (std::ostream& os, const std::string& prefix) const;
 
-  octave_value erf (void) const;
-  octave_value erfc (void) const;
-  octave_value gamma (void) const;
-  octave_value lgamma (void) const;
-  octave_value abs (void) const;
-  octave_value acos (void) const;
-  octave_value acosh (void) const;
-  octave_value angle (void) const;
-  octave_value arg (void) const;
-  octave_value asin (void) const;
-  octave_value asinh (void) const;
-  octave_value atan (void) const;
-  octave_value atanh (void) const;
-  octave_value ceil (void) const;
-  octave_value conj (void) const;
-  octave_value cos (void) const;
-  octave_value cosh (void) const;
-  octave_value exp (void) const;
-  octave_value expm1 (void) const;
-  octave_value fix (void) const;
-  octave_value floor (void) const;
-  octave_value imag (void) const;
-  octave_value log (void) const;
-  octave_value log2 (void) const;
-  octave_value log10 (void) const;
-  octave_value log1p (void) const;
-  octave_value real (void) const;
-  octave_value round (void) const;
-  octave_value roundb (void) const;
-  octave_value signum (void) const;
-  octave_value sin (void) const;
-  octave_value sinh (void) const;
-  octave_value sqrt (void) const;
-  octave_value tan (void) const;
-  octave_value tanh (void) const;
-  octave_value finite (void) const;
-  octave_value isinf (void) const;
-  octave_value isna (void) const;
-  octave_value isnan (void) const;
+  octave_value map (unary_mapper_t umap) const
+    { return to_dense ().map (umap); }
 
 protected:
 
   PermMatrix matrix;  
 
   virtual octave_value to_dense (void) const;
 
   mutable octave_value dense_cache;
diff --git a/src/ov-range.h b/src/ov-range.h
--- a/src/ov-range.h
+++ b/src/ov-range.h
@@ -289,64 +289,22 @@ public:
       // special case of the octave_stream::write method for ranges.
 
       return os.write (matrix_value (), block_size, output_type, skip,
 		       flt_fmt);
     }
 
   mxArray *as_mxArray (void) const;
 
-  // Mapper functions are converted to double for treatment
-#define RANGE_MAPPER(MAP) \
-  octave_value MAP (void) const \
-    { \
-      octave_matrix m (array_value ()); \
-      return m.MAP (); \
+  octave_value map (unary_mapper_t umap) const
+    {
+      octave_matrix m (matrix_value ());
+      return m.map (umap);
     }
 
-  RANGE_MAPPER (abs)
-  RANGE_MAPPER (acos)
-  RANGE_MAPPER (acosh)
-  RANGE_MAPPER (angle)
-  RANGE_MAPPER (arg)
-  RANGE_MAPPER (asin)
-  RANGE_MAPPER (asinh)
-  RANGE_MAPPER (atan)
-  RANGE_MAPPER (atanh)
-  RANGE_MAPPER (ceil)
-  RANGE_MAPPER (conj)
-  RANGE_MAPPER (cos)
-  RANGE_MAPPER (cosh)
-  RANGE_MAPPER (erf)
-  RANGE_MAPPER (erfc)
-  RANGE_MAPPER (exp)
-  RANGE_MAPPER (expm1)
-  RANGE_MAPPER (finite)
-  RANGE_MAPPER (fix)
-  RANGE_MAPPER (floor)
-  RANGE_MAPPER (gamma)
-  RANGE_MAPPER (imag)
-  RANGE_MAPPER (isinf)
-  RANGE_MAPPER (isna)
-  RANGE_MAPPER (isnan)
-  RANGE_MAPPER (lgamma)
-  RANGE_MAPPER (log)
-  RANGE_MAPPER (log2)
-  RANGE_MAPPER (log10)
-  RANGE_MAPPER (log1p)
-  RANGE_MAPPER (real)
-  RANGE_MAPPER (round)
-  RANGE_MAPPER (roundb)
-  RANGE_MAPPER (signum)
-  RANGE_MAPPER (sin)
-  RANGE_MAPPER (sinh)
-  RANGE_MAPPER (sqrt)
-  RANGE_MAPPER (tan)
-  RANGE_MAPPER (tanh)
-
 private:
 
   Range range;
 
   idx_vector set_idx_cache (const idx_vector& idx) const
     {
       delete idx_cache;
       idx_cache = idx ? new idx_vector (idx) : 0;
diff --git a/src/ov-re-diag.cc b/src/ov-re-diag.cc
--- a/src/ov-re-diag.cc
+++ b/src/ov-re-diag.cc
@@ -146,56 +146,37 @@ octave_diag_matrix::complex_diag_matrix_
 
 FloatComplexDiagMatrix
 octave_diag_matrix::float_complex_diag_matrix_value (bool) const
 {
   return FloatComplexDiagMatrix (matrix);
 }
 
 octave_value
-octave_diag_matrix::abs (void) const
-{
-  return matrix.abs ();
-}
-
-octave_value
-octave_diag_matrix::real (void) const
-{
-  return matrix;
-}
-
-octave_value
-octave_diag_matrix::conj (void) const
-{
-  return matrix;
-}
-
-octave_value
-octave_diag_matrix::imag (void) const
+octave_diag_matrix::map (unary_mapper_t umap) const
 {
-  return DiagMatrix (matrix.rows (), matrix.cols (), 0.0);
-}
-
-octave_value
-octave_diag_matrix::sqrt (void) const
-{    
-  octave_value retval;
-
-  static NDArray::dmapper dsqrt = ::sqrt;
-  static NDArray::cmapper csqrt = std::sqrt;
-
-  ColumnVector dvec = matrix.diag ();
-  if (Matrix (dvec).any_element_is_negative ())
-    retval = ComplexDiagMatrix (dvec.map (csqrt));
-  else
-    retval = DiagMatrix (dvec.map (dsqrt));
-
-  retval.resize (dims ());
-
-  return retval;
+  switch (umap)
+    {
+    case umap_abs:
+      return matrix.abs ();
+    case umap_real:
+    case umap_conj:
+      return matrix;
+    case umap_imag:
+      return DiagMatrix (matrix.rows (), matrix.cols (), 0.0);
+    case umap_sqrt:
+      {
+        ComplexColumnVector tmp = matrix.diag ().map<Complex> (rc_sqrt);
+        ComplexDiagMatrix retval (tmp);
+        retval.resize (matrix.rows (), matrix.columns ());
+        return retval;
+      }
+    default:
+      return to_dense ().map (umap);
+    }
 }
 
 bool 
 octave_diag_matrix::save_binary (std::ostream& os, bool& save_as_floats)
 {
 
   int32_t r = matrix.rows (), c = matrix.cols ();
   os.write (reinterpret_cast<char *> (&r), 4);
diff --git a/src/ov-re-diag.h b/src/ov-re-diag.h
--- a/src/ov-re-diag.h
+++ b/src/ov-re-diag.h
@@ -78,21 +78,17 @@ public:
 
   FloatComplexDiagMatrix float_complex_diag_matrix_value (bool = false) const;
 
   bool save_binary (std::ostream& os, bool& save_as_floats);
 
   bool load_binary (std::istream& is, bool swap, 
 		    oct_mach_info::float_format fmt);
 
-  octave_value abs (void) const;
-  octave_value conj (void) const;
-  octave_value imag (void) const;
-  octave_value real (void) const;
-  octave_value sqrt (void) const;
+  octave_value map (unary_mapper_t umap) const;
 
 private:
 
   bool chk_valid_scalar (const octave_value&, 
                          double&) const;
 
   DECLARE_OCTAVE_ALLOCATOR
 
diff --git a/src/ov-re-mat.cc b/src/ov-re-mat.cc
--- a/src/ov-re-mat.cc
+++ b/src/ov-re-mat.cc
@@ -703,147 +703,79 @@ octave_matrix::as_mxArray (void) const
   const double *p = matrix.data ();
 
   for (mwIndex i = 0; i < nel; i++)
     pr[i] = p[i];
 
   return retval;
 }
 
-static bool
-any_element_less_than (const NDArray& a, double val)
-{
-  octave_idx_type len = a.length ();
-  const double *m = a.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < len; i++)
-    {
-      OCTAVE_QUIT;
-
-      if (m[i] < val)
-	return true;
-    }
-
-  return false;
-}
-
-static bool
-any_element_greater_than (const NDArray& a, double val)
-{
-  octave_idx_type len = a.length ();
-  const double *m = a.fortran_vec ();
-
-  for (octave_idx_type i = 0; i < len; i++)
-    {
-      OCTAVE_QUIT;
-
-      if (m[i] > val)
-	return true;
-    }
-
-  return false;
-}
-
-#define ARRAY_MAPPER(MAP, AMAP, FCN) \
-  octave_value \
-  octave_matrix::MAP (void) const \
-  { \
-    static AMAP dmap = FCN; \
-    return matrix.map (dmap); \
-  }
-
-#define CD_ARRAY_MAPPER(MAP, RFCN, CFCN, L1, L2) \
-  octave_value \
-  octave_matrix::MAP (void) const \
-  { \
-    static NDArray::dmapper dmap = RFCN; \
-    static NDArray::cmapper cmap = CFCN; \
- \
-    return (any_element_less_than (matrix, L1) \
-            ? octave_value (matrix.map (cmap)) \
-	    : (any_element_greater_than (matrix, L2) \
-	       ? octave_value (matrix.map (cmap)) \
-	       : octave_value (matrix.map (dmap)))); \
-  }
-
-// The fast mappers.
 octave_value
-octave_matrix::abs (void) const
-{
-  return matrix.abs ();
-}
-
-octave_value
-octave_matrix::real (void) const
+octave_matrix::map (unary_mapper_t umap) const
 {
-  return matrix;
-}
+  switch (umap)
+    {
+    case umap_imag:
+      return NDArray (matrix.dims (), 0.0);
 
-octave_value
-octave_matrix::conj (void) const
-{
-  return matrix;
-}
-
-octave_value
-octave_matrix::imag (void) const
-{
-  return NDArray (matrix.dims (), 0.0);
-}
+    case umap_real:
+    case umap_conj:
+      return matrix;
 
-octave_value
-octave_matrix::isnan (void) const
-{
-  return matrix.isnan ();
-}
+    // Mappers handled specially.
+#define ARRAY_METHOD_MAPPER(UMAP, FCN) \
+    case umap_ ## UMAP: \
+      return octave_value (matrix.FCN ())
 
-octave_value
-octave_matrix::isinf (void) const
-{
-  return matrix.isinf ();
-}
+      ARRAY_METHOD_MAPPER (abs, abs);
+      ARRAY_METHOD_MAPPER (isnan, isnan);
+      ARRAY_METHOD_MAPPER (isinf, isinf);
+      ARRAY_METHOD_MAPPER (finite, isfinite);
 
-octave_value
-octave_matrix::finite (void) const
-{
-  return matrix.isfinite ();
-}
+#define ARRAY_MAPPER(UMAP, TYPE, FCN) \
+    case umap_ ## UMAP: \
+      return octave_value (matrix.map<TYPE> (FCN))
 
-ARRAY_MAPPER (erf, NDArray::dmapper, ::erf)
-ARRAY_MAPPER (erfc, NDArray::dmapper, ::erfc)
-ARRAY_MAPPER (gamma, NDArray::dmapper, xgamma)
-CD_ARRAY_MAPPER (lgamma, xlgamma, xlgamma, 0.0, octave_Inf)
-CD_ARRAY_MAPPER (acos, ::acos, ::acos, -1.0, 1.0)
-CD_ARRAY_MAPPER (acosh, ::acosh, ::acosh, 1.0, octave_Inf)
-ARRAY_MAPPER (angle, NDArray::dmapper, ::arg)
-ARRAY_MAPPER (arg, NDArray::dmapper, ::arg)
-CD_ARRAY_MAPPER (asin, ::asin, ::asin, -1.0, 1.0)
-ARRAY_MAPPER (asinh, NDArray::dmapper,::asinh)
-ARRAY_MAPPER (atan, NDArray::dmapper, ::atan)
-CD_ARRAY_MAPPER (atanh, ::atanh, ::atanh, -1.0, 1.0)
-ARRAY_MAPPER (ceil, NDArray::dmapper, ::ceil)
-ARRAY_MAPPER (cos, NDArray::dmapper, ::cos)
-ARRAY_MAPPER (cosh, NDArray::dmapper, ::cosh)
-ARRAY_MAPPER (exp, NDArray::dmapper, ::exp)
-ARRAY_MAPPER (expm1, NDArray::dmapper, ::expm1)
-ARRAY_MAPPER (fix, NDArray::dmapper, ::fix)
-ARRAY_MAPPER (floor, NDArray::dmapper, ::floor)
-CD_ARRAY_MAPPER (log, ::log, std::log, 0.0, octave_Inf)
-CD_ARRAY_MAPPER (log2, xlog2, xlog2, 0.0, octave_Inf)
-CD_ARRAY_MAPPER (log10, ::log10, std::log10, 0.0, octave_Inf)
-CD_ARRAY_MAPPER (log1p, ::log1p, ::log1p, -1.0, octave_Inf)
-ARRAY_MAPPER (round, NDArray::dmapper, xround)
-ARRAY_MAPPER (roundb, NDArray::dmapper, xroundb)
-ARRAY_MAPPER (signum, NDArray::dmapper, ::signum)
-ARRAY_MAPPER (sin, NDArray::dmapper, ::sin)
-ARRAY_MAPPER (sinh, NDArray::dmapper, ::sinh)
-CD_ARRAY_MAPPER (sqrt, ::sqrt, std::sqrt, 0.0, octave_Inf)
-ARRAY_MAPPER (tan, NDArray::dmapper, ::tan)
-ARRAY_MAPPER (tanh, NDArray::dmapper, ::tanh)
-ARRAY_MAPPER (isna, NDArray::bmapper, octave_is_NA)
+      ARRAY_MAPPER (acos, Complex, rc_acos);
+      ARRAY_MAPPER (acosh, Complex, rc_acosh);
+      ARRAY_MAPPER (angle, double, ::arg);
+      ARRAY_MAPPER (arg, double, ::arg);
+      ARRAY_MAPPER (asin, Complex, rc_asin);
+      ARRAY_MAPPER (asinh, double, ::asinh);
+      ARRAY_MAPPER (atan, double, ::atan);
+      ARRAY_MAPPER (atanh, Complex, rc_atanh);
+      ARRAY_MAPPER (erf, double, ::erf);
+      ARRAY_MAPPER (erfc, double, ::erfc);
+      ARRAY_MAPPER (gamma, double, xgamma);
+      ARRAY_MAPPER (lgamma, Complex, rc_lgamma);
+      ARRAY_MAPPER (ceil, double, ::ceil);
+      ARRAY_MAPPER (cos, double, ::cos);
+      ARRAY_MAPPER (cosh, double, ::cosh);
+      ARRAY_MAPPER (exp, double, ::exp);
+      ARRAY_MAPPER (expm1, double, ::expm1);
+      ARRAY_MAPPER (fix, double, ::fix);
+      ARRAY_MAPPER (floor, double, ::floor);
+      ARRAY_MAPPER (log, Complex, rc_log);
+      ARRAY_MAPPER (log2, Complex, rc_log2);
+      ARRAY_MAPPER (log10, Complex, rc_log10);
+      ARRAY_MAPPER (log1p, Complex, rc_log1p);
+      ARRAY_MAPPER (round, double, xround);
+      ARRAY_MAPPER (roundb, double, xroundb);
+      ARRAY_MAPPER (signum, double, ::signum);
+      ARRAY_MAPPER (sin, double, ::sin);
+      ARRAY_MAPPER (sinh, double, ::sinh);
+      ARRAY_MAPPER (sqrt, Complex, rc_sqrt);
+      ARRAY_MAPPER (tan, double, ::tan);
+      ARRAY_MAPPER (tanh, double, ::tanh);
+      ARRAY_MAPPER (isna, bool, octave_is_NA);
+
+    default:
+      return octave_base_value::map (umap);
+    }
+}
 
 DEFUN (double, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} double (@var{x})\n\
 Convert @var{x} to double precision type.\n\
 @seealso{single}\n\
 @end deftypefn")
 {
diff --git a/src/ov-re-mat.h b/src/ov-re-mat.h
--- a/src/ov-re-mat.h
+++ b/src/ov-re-mat.h
@@ -211,55 +211,17 @@ public:
     { return os.write (matrix, block_size, output_type, skip, flt_fmt); }
 
   // Unsafe.  This function exists to support the MEX interface.
   // You should not use it anywhere else.
   void *mex_get_data (void) const { return matrix.mex_get_data (); }
 
   mxArray *as_mxArray (void) const;
 
-  octave_value erf (void) const;
-  octave_value erfc (void) const;
-  octave_value gamma (void) const;
-  octave_value lgamma (void) const;
-  octave_value abs (void) const;
-  octave_value acos (void) const;
-  octave_value acosh (void) const;
-  octave_value angle (void) const;
-  octave_value arg (void) const;
-  octave_value asin (void) const;
-  octave_value asinh (void) const;
-  octave_value atan (void) const;
-  octave_value atanh (void) const;
-  octave_value ceil (void) const;
-  octave_value conj (void) const;
-  octave_value cos (void) const;
-  octave_value cosh (void) const;
-  octave_value exp (void) const;
-  octave_value expm1 (void) const;
-  octave_value fix (void) const;
-  octave_value floor (void) const;
-  octave_value imag (void) const;
-  octave_value log (void) const;
-  octave_value log2 (void) const;
-  octave_value log10 (void) const;
-  octave_value log1p (void) const;
-  octave_value real (void) const;
-  octave_value round (void) const;
-  octave_value roundb (void) const;
-  octave_value signum (void) const;
-  octave_value sin (void) const;
-  octave_value sinh (void) const;
-  octave_value sqrt (void) const;
-  octave_value tan (void) const;
-  octave_value tanh (void) const;
-  octave_value finite (void) const;
-  octave_value isinf (void) const;
-  octave_value isna (void) const;
-  octave_value isnan (void) const;
+  octave_value map (unary_mapper_t umap) const;
 
 private:
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
diff --git a/src/ov-re-sparse.cc b/src/ov-re-sparse.cc
--- a/src/ov-re-sparse.cc
+++ b/src/ov-re-sparse.cc
@@ -803,119 +803,78 @@ octave_sparse_matrix::as_mxArray (void) 
     }
 
   for (mwIndex i = 0; i < nc + 1; i++)
     jc[i] = matrix.cidx(i);
 
   return retval;
 }
 
-static bool
-any_element_less_than (const SparseMatrix& a, double val)
+octave_value
+octave_sparse_matrix::map (unary_mapper_t umap) const
 {
-  octave_idx_type len = a.nnz ();
-
-  if (val > 0. && len != a.numel ())
-    return true;
+  switch (umap)
+    {
+    case umap_imag:
+      return SparseMatrix (matrix.rows (), matrix.cols (), 0.0);
 
-  for (octave_idx_type i = 0; i < len; i++)
-    {
-      OCTAVE_QUIT;
+    case umap_real:
+    case umap_conj:
+      return matrix;
 
-      if (a.data(i) < val)
-	return true;
-    }
+    // Mappers handled specially.
+#define ARRAY_METHOD_MAPPER(UMAP, FCN) \
+    case umap_ ## UMAP: \
+      return octave_value (matrix.FCN ())
+
+      ARRAY_METHOD_MAPPER (abs, abs);
+
+#define ARRAY_MAPPER(UMAP, TYPE, FCN) \
+    case umap_ ## UMAP: \
+      return octave_value (matrix.map<TYPE> (FCN))
 
-  return false;
-}
-
-static bool
-any_element_greater_than (const SparseMatrix& a, double val)
-{
-  octave_idx_type len = a.nnz ();
+      ARRAY_MAPPER (acos, Complex, rc_acos);
+      ARRAY_MAPPER (acosh, Complex, rc_acosh);
+      ARRAY_MAPPER (angle, double, ::arg);
+      ARRAY_MAPPER (arg, double, ::arg);
+      ARRAY_MAPPER (asin, Complex, rc_asin);
+      ARRAY_MAPPER (asinh, double, ::asinh);
+      ARRAY_MAPPER (atan, double, ::atan);
+      ARRAY_MAPPER (atanh, Complex, rc_atanh);
+      ARRAY_MAPPER (erf, double, ::erf);
+      ARRAY_MAPPER (erfc, double, ::erfc);
+      ARRAY_MAPPER (gamma, double, xgamma);
+      ARRAY_MAPPER (lgamma, Complex, rc_lgamma);
+      ARRAY_MAPPER (ceil, double, ::ceil);
+      ARRAY_MAPPER (cos, double, ::cos);
+      ARRAY_MAPPER (cosh, double, ::cosh);
+      ARRAY_MAPPER (exp, double, ::exp);
+      ARRAY_MAPPER (expm1, double, ::expm1);
+      ARRAY_MAPPER (fix, double, ::fix);
+      ARRAY_MAPPER (floor, double, ::floor);
+      ARRAY_MAPPER (log, Complex, rc_log);
+      ARRAY_MAPPER (log2, Complex, rc_log2);
+      ARRAY_MAPPER (log10, Complex, rc_log10);
+      ARRAY_MAPPER (log1p, Complex, rc_log1p);
+      ARRAY_MAPPER (round, double, xround);
+      ARRAY_MAPPER (roundb, double, xroundb);
+      ARRAY_MAPPER (signum, double, ::signum);
+      ARRAY_MAPPER (sin, double, ::sin);
+      ARRAY_MAPPER (sinh, double, ::sinh);
+      ARRAY_MAPPER (sqrt, Complex, rc_sqrt);
+      ARRAY_MAPPER (tan, double, ::tan);
+      ARRAY_MAPPER (tanh, double, ::tanh);
+      ARRAY_MAPPER (isnan, bool, xisnan);
+      ARRAY_MAPPER (isna, bool, octave_is_NA);
+      ARRAY_MAPPER (isinf, bool, xisinf);
+      ARRAY_MAPPER (finite, bool, xfinite);
 
-  if (val < 0. && len != a.numel ())
-    return true;
-
-  for (octave_idx_type i = 0; i < len; i++)
-    {
-      OCTAVE_QUIT;
-
-      if (a.data(i) > val)
-	return true;
+    default: // Attempt to go via dense matrix.
+      return full_value ().map (umap).sparse_matrix_value ();
     }
-
-  return false;
 }
 
-#define SPARSE_MAPPER(MAP, AMAP, FCN) \
-  octave_value \
-  octave_sparse_matrix::MAP (void) const \
-  { \
-    static AMAP dmap = FCN; \
-    return matrix.map (dmap); \
-  }
-
-#define CD_SPARSE_MAPPER(MAP, RFCN, CFCN, L1, L2) \
-  octave_value \
-  octave_sparse_matrix::MAP (void) const \
-  { \
-    static SparseMatrix::dmapper dmap = RFCN; \
-    static SparseMatrix::cmapper cmap = CFCN; \
- \
-    return (any_element_less_than (matrix, L1) \
-            ? octave_value (matrix.map (cmap)) \
-            : (any_element_greater_than (matrix, L2) \
-               ? octave_value (matrix.map (cmap)) \
-	       : octave_value (matrix.map (dmap)))); \
-  }
-
-static double
-xconj (double x)
-{
-  return x;
-}
-
-SPARSE_MAPPER (erf, SparseMatrix::dmapper, ::erf)
-SPARSE_MAPPER (erfc, SparseMatrix::dmapper, ::erfc)
-SPARSE_MAPPER (gamma, SparseMatrix::dmapper, xgamma)
-CD_SPARSE_MAPPER (lgamma, xlgamma, xlgamma, 0.0, octave_Inf)
-SPARSE_MAPPER (abs, SparseMatrix::dmapper, ::fabs)
-CD_SPARSE_MAPPER (acos, ::acos, ::acos, -1.0, 1.0)
-CD_SPARSE_MAPPER (acosh, ::acosh, ::acosh, 1.0, octave_Inf)
-SPARSE_MAPPER (angle, SparseMatrix::dmapper, ::arg)
-SPARSE_MAPPER (arg, SparseMatrix::dmapper, ::arg)
-CD_SPARSE_MAPPER (asin, ::asin, ::asin, -1.0, 1.0)
-SPARSE_MAPPER (asinh, SparseMatrix::dmapper, ::asinh)
-SPARSE_MAPPER (atan, SparseMatrix::dmapper, ::atan)
-CD_SPARSE_MAPPER (atanh, ::atanh, ::atanh, -1.0, 1.0)
-SPARSE_MAPPER (ceil, SparseMatrix::dmapper, ::ceil)
-SPARSE_MAPPER (conj, SparseMatrix::dmapper, xconj)
-SPARSE_MAPPER (cos, SparseMatrix::dmapper, ::cos)
-SPARSE_MAPPER (cosh, SparseMatrix::dmapper, ::cosh)
-SPARSE_MAPPER (exp, SparseMatrix::dmapper, ::exp)
-SPARSE_MAPPER (expm1, SparseMatrix::dmapper, ::expm1)
-SPARSE_MAPPER (fix, SparseMatrix::dmapper, ::fix)
-SPARSE_MAPPER (floor, SparseMatrix::dmapper, ::floor)
-SPARSE_MAPPER (imag, SparseMatrix::dmapper, ::imag)
-CD_SPARSE_MAPPER (log, ::log, std::log, 0.0, octave_Inf)
-CD_SPARSE_MAPPER (log2, xlog2, xlog2, 0.0, octave_Inf)
-CD_SPARSE_MAPPER (log10, ::log10, std::log10, 0.0, octave_Inf)
-CD_SPARSE_MAPPER (log1p, ::log1p, ::log1p, 0.0, octave_Inf)
-SPARSE_MAPPER (real, SparseMatrix::dmapper, ::real)
-SPARSE_MAPPER (round, SparseMatrix::dmapper, xround)
-SPARSE_MAPPER (roundb, SparseMatrix::dmapper, xroundb)
-SPARSE_MAPPER (signum, SparseMatrix::dmapper, ::signum)
-SPARSE_MAPPER (sin, SparseMatrix::dmapper, ::sin)
-SPARSE_MAPPER (sinh, SparseMatrix::dmapper, ::sinh)
-CD_SPARSE_MAPPER (sqrt, ::sqrt, std::sqrt, 0.0, octave_Inf)
-SPARSE_MAPPER (tan, SparseMatrix::dmapper, ::tan)
-SPARSE_MAPPER (tanh, SparseMatrix::dmapper, ::tanh)
-SPARSE_MAPPER (finite, SparseMatrix::bmapper, xfinite)
-SPARSE_MAPPER (isinf, SparseMatrix::bmapper, xisinf)
-SPARSE_MAPPER (isna, SparseMatrix::bmapper, octave_is_NA)
-SPARSE_MAPPER (isnan, SparseMatrix::bmapper, xisnan)
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-re-sparse.h b/src/ov-re-sparse.h
--- a/src/ov-re-sparse.h
+++ b/src/ov-re-sparse.h
@@ -145,55 +145,17 @@ public:
 #if defined (HAVE_HDF5)
   bool save_hdf5 (hid_t loc_id, const char *name, bool save_as_floats);
 
   bool load_hdf5 (hid_t loc_id, const char *name, bool have_h5giterate_bug);
 #endif
 
   mxArray *as_mxArray (void) const;
 
-  octave_value erf (void) const;
-  octave_value erfc (void) const;
-  octave_value gamma (void) const;
-  octave_value lgamma (void) const;
-  octave_value abs (void) const;
-  octave_value acos (void) const;
-  octave_value acosh (void) const;
-  octave_value angle (void) const;
-  octave_value arg (void) const;
-  octave_value asin (void) const;
-  octave_value asinh (void) const;
-  octave_value atan (void) const;
-  octave_value atanh (void) const;
-  octave_value ceil (void) const;
-  octave_value conj (void) const;
-  octave_value cos (void) const;
-  octave_value cosh (void) const;
-  octave_value exp (void) const;
-  octave_value expm1 (void) const;
-  octave_value fix (void) const;
-  octave_value floor (void) const;
-  octave_value imag (void) const;
-  octave_value log (void) const;
-  octave_value log2 (void) const;
-  octave_value log10 (void) const;
-  octave_value log1p (void) const;
-  octave_value real (void) const;
-  octave_value round (void) const;
-  octave_value roundb (void) const;
-  octave_value signum (void) const;
-  octave_value sin (void) const;
-  octave_value sinh (void) const;
-  octave_value sqrt (void) const;
-  octave_value tan (void) const;
-  octave_value tanh (void) const;
-  octave_value finite (void) const;
-  octave_value isinf (void) const;
-  octave_value isna (void) const;
-  octave_value isnan (void) const;
+  octave_value map (unary_mapper_t umap) const;
 
 private:
   octave_value map (double (*fcn) (double)) const;
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
diff --git a/src/ov-scalar.cc b/src/ov-scalar.cc
--- a/src/ov-scalar.cc
+++ b/src/ov-scalar.cc
@@ -262,75 +262,71 @@ octave_scalar::as_mxArray (void) const
 
   double *pr = static_cast<double *> (retval->get_data ());
 
   pr[0] = scalar;
 
   return retval;
 }
 
-#define SCALAR_MAPPER(MAP, FCN) \
-  octave_value \
-  octave_scalar::MAP (void) const \
-  { \
-    return octave_value (FCN (scalar)); \
-  }
+octave_value
+octave_scalar::map (unary_mapper_t umap) const
+{
+  switch (umap)
+    {
+    case umap_imag:
+      return 0.0;
 
-#define CD_SCALAR_MAPPER(MAP, RFCN, CFCN, L1, L2) \
-  octave_value \
-  octave_scalar::MAP (void) const \
-  { \
-    return (scalar < L1 || scalar > L2 \
-            ? octave_value (CFCN (Complex (scalar))) \
-	    : octave_value (RFCN (scalar))); \
-  }
+    case umap_real:
+    case umap_conj:
+      return scalar;
 
-static double
-xconj (double x)
-{
-  return x;
-}
+#define SCALAR_MAPPER(UMAP, FCN) \
+    case umap_ ## UMAP: \
+      return octave_value (FCN (scalar))
 
-SCALAR_MAPPER (erf, ::erf)
-SCALAR_MAPPER (erfc, ::erfc)
-SCALAR_MAPPER (gamma, xgamma)
-CD_SCALAR_MAPPER (lgamma, xlgamma, xlgamma, 0.0, octave_Inf)
-SCALAR_MAPPER (abs, ::fabs)
-CD_SCALAR_MAPPER (acos, ::acos, ::acos, -1.0, 1.0)
-CD_SCALAR_MAPPER (acosh, ::acosh, ::acosh, 1.0, octave_Inf)
-SCALAR_MAPPER (angle, ::arg)
-SCALAR_MAPPER (arg, ::arg)
-CD_SCALAR_MAPPER (asin, ::asin, ::asin, -1.0, 1.0)
-SCALAR_MAPPER (asinh, ::asinh)
-SCALAR_MAPPER (atan, ::atan)
-CD_SCALAR_MAPPER (atanh, ::atanh, ::atanh, -1.0, 1.0)
-SCALAR_MAPPER (ceil, ::ceil)
-SCALAR_MAPPER (conj, xconj)
-SCALAR_MAPPER (cos, ::cos)
-SCALAR_MAPPER (cosh, ::cosh)
-SCALAR_MAPPER (exp, ::exp)
-SCALAR_MAPPER (expm1, ::expm1)
-SCALAR_MAPPER (fix, ::fix)
-SCALAR_MAPPER (floor, ::floor)
-SCALAR_MAPPER (imag, ::imag)
-CD_SCALAR_MAPPER (log, ::log, std::log, 0.0, octave_Inf)
-CD_SCALAR_MAPPER (log2, xlog2, xlog2, 0.0, octave_Inf)
-CD_SCALAR_MAPPER (log10, ::log10, std::log10, 0.0, octave_Inf)
-CD_SCALAR_MAPPER (log1p, ::log1p, ::log1p, -1.0, octave_Inf)
-SCALAR_MAPPER (real, ::real)
-SCALAR_MAPPER (round, xround)
-SCALAR_MAPPER (roundb, xroundb)
-SCALAR_MAPPER (signum, ::signum)
-SCALAR_MAPPER (sin, ::sin)
-SCALAR_MAPPER (sinh, ::sinh)
-CD_SCALAR_MAPPER (sqrt, ::sqrt, std::sqrt, 0.0, octave_Inf)
-SCALAR_MAPPER (tan, ::tan)
-SCALAR_MAPPER (tanh, ::tanh)
-SCALAR_MAPPER (finite, xfinite)
-SCALAR_MAPPER (isinf, xisinf)
-SCALAR_MAPPER (isna, octave_is_NA)
-SCALAR_MAPPER (isnan, xisnan)
+      SCALAR_MAPPER (abs, ::fabs);
+      SCALAR_MAPPER (acos, rc_acos);
+      SCALAR_MAPPER (acosh, rc_acosh);
+      SCALAR_MAPPER (angle, ::arg);
+      SCALAR_MAPPER (arg, ::arg);
+      SCALAR_MAPPER (asin, rc_asin);
+      SCALAR_MAPPER (asinh, ::asinh);
+      SCALAR_MAPPER (atan, ::atan);
+      SCALAR_MAPPER (atanh, rc_atanh);
+      SCALAR_MAPPER (erf, ::erf);
+      SCALAR_MAPPER (erfc, ::erfc);
+      SCALAR_MAPPER (gamma, xgamma);
+      SCALAR_MAPPER (lgamma, rc_lgamma);
+      SCALAR_MAPPER (ceil, ::ceil);
+      SCALAR_MAPPER (cos, ::cos);
+      SCALAR_MAPPER (cosh, ::cosh);
+      SCALAR_MAPPER (exp, ::exp);
+      SCALAR_MAPPER (expm1, ::expm1);
+      SCALAR_MAPPER (fix, ::fix);
+      SCALAR_MAPPER (floor, ::floor);
+      SCALAR_MAPPER (log, rc_log);
+      SCALAR_MAPPER (log2, rc_log2);
+      SCALAR_MAPPER (log10, rc_log10);
+      SCALAR_MAPPER (log1p, rc_log1p);
+      SCALAR_MAPPER (round, xround);
+      SCALAR_MAPPER (roundb, xroundb);
+      SCALAR_MAPPER (signum, ::signum);
+      SCALAR_MAPPER (sin, ::sin);
+      SCALAR_MAPPER (sinh, ::sinh);
+      SCALAR_MAPPER (sqrt, rc_sqrt);
+      SCALAR_MAPPER (tan, ::tan);
+      SCALAR_MAPPER (tanh, ::tanh);
+      SCALAR_MAPPER (finite, xfinite);
+      SCALAR_MAPPER (isinf, xisinf);
+      SCALAR_MAPPER (isna, octave_is_NA);
+      SCALAR_MAPPER (isnan, xisnan);
+
+    default:
+      return octave_base_value::map (umap);
+    }
+}
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-scalar.h b/src/ov-scalar.h
--- a/src/ov-scalar.h
+++ b/src/ov-scalar.h
@@ -240,58 +240,19 @@ public:
 	     oct_mach_info::float_format flt_fmt) const
     {
       return os.write (array_value (), block_size, output_type,
 		       skip, flt_fmt);
     }
 
   mxArray *as_mxArray (void) const;
 
-  octave_value erf (void) const;
-  octave_value erfc (void) const;
-  octave_value gamma (void) const;
-  octave_value lgamma (void) const;
-  octave_value abs (void) const;
-  octave_value acos (void) const;
-  octave_value acosh (void) const;
-  octave_value angle (void) const;
-  octave_value arg (void) const;
-  octave_value asin (void) const;
-  octave_value asinh (void) const;
-  octave_value atan (void) const;
-  octave_value atanh (void) const;
-  octave_value ceil (void) const;
-  octave_value conj (void) const;
-  octave_value cos (void) const;
-  octave_value cosh (void) const;
-  octave_value exp (void) const;
-  octave_value expm1 (void) const;
-  octave_value fix (void) const;
-  octave_value floor (void) const;
-  octave_value imag (void) const;
-  octave_value log (void) const;
-  octave_value log2 (void) const;
-  octave_value log10 (void) const;
-  octave_value log1p (void) const;
-  octave_value real (void) const;
-  octave_value round (void) const;
-  octave_value roundb (void) const;
-  octave_value signum (void) const;
-  octave_value sin (void) const;
-  octave_value sinh (void) const;
-  octave_value sqrt (void) const;
-  octave_value tan (void) const;
-  octave_value tanh (void) const;
-  octave_value finite (void) const;
-  octave_value isinf (void) const;
-  octave_value isna (void) const;
-  octave_value isnan (void) const;
+  octave_value map (unary_mapper_t umap) const;
 
 private:
-  octave_value map (double (*fcn) (double)) const;
 
   DECLARE_OCTAVE_ALLOCATOR
 
   DECLARE_OV_TYPEID_FUNCTIONS_AND_DATA
 };
 
 #endif
 
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -1071,79 +1071,18 @@ public:
   void lock (void) { rep->lock (); }
 
   void unlock (void) { rep->unlock (); }
 
   bool islocked (void) const { return rep->islocked (); }
 
   void dump (std::ostream& os) const { rep->dump (os); }
 
-#define MAPPER_FORWARD(F) \
-  octave_value F (void) const { return rep->F (); }
-
-  MAPPER_FORWARD (abs)
-  MAPPER_FORWARD (acos)
-  MAPPER_FORWARD (acosh)
-  MAPPER_FORWARD (angle)
-  MAPPER_FORWARD (arg)
-  MAPPER_FORWARD (asin)
-  MAPPER_FORWARD (asinh)
-  MAPPER_FORWARD (atan)
-  MAPPER_FORWARD (atanh)
-  MAPPER_FORWARD (ceil)
-  MAPPER_FORWARD (conj)
-  MAPPER_FORWARD (cos)
-  MAPPER_FORWARD (cosh)
-  MAPPER_FORWARD (erf)
-  MAPPER_FORWARD (erfc)
-  MAPPER_FORWARD (exp)
-  MAPPER_FORWARD (expm1)
-  MAPPER_FORWARD (finite)
-  MAPPER_FORWARD (fix)
-  MAPPER_FORWARD (floor)
-  MAPPER_FORWARD (gamma)
-  MAPPER_FORWARD (imag)
-  MAPPER_FORWARD (isinf)
-  MAPPER_FORWARD (isna)
-  MAPPER_FORWARD (isnan)
-  MAPPER_FORWARD (lgamma)
-  MAPPER_FORWARD (log)
-  MAPPER_FORWARD (log2)
-  MAPPER_FORWARD (log10)
-  MAPPER_FORWARD (log1p)
-  MAPPER_FORWARD (real)
-  MAPPER_FORWARD (round)
-  MAPPER_FORWARD (roundb)
-  MAPPER_FORWARD (signum)
-  MAPPER_FORWARD (sin)
-  MAPPER_FORWARD (sinh)
-  MAPPER_FORWARD (sqrt)
-  MAPPER_FORWARD (tan)
-  MAPPER_FORWARD (tanh)
-
-  // These functions are prefixed with X to avoid potential macro
-  // conflicts.
-
-  MAPPER_FORWARD (xisalnum)
-  MAPPER_FORWARD (xisalpha)
-  MAPPER_FORWARD (xisascii)
-  MAPPER_FORWARD (xiscntrl)
-  MAPPER_FORWARD (xisdigit)
-  MAPPER_FORWARD (xisgraph)
-  MAPPER_FORWARD (xislower)
-  MAPPER_FORWARD (xisprint)
-  MAPPER_FORWARD (xispunct)
-  MAPPER_FORWARD (xisspace)
-  MAPPER_FORWARD (xisupper)
-  MAPPER_FORWARD (xisxdigit)
-  MAPPER_FORWARD (xtoascii)
-  MAPPER_FORWARD (xtolower)
-  MAPPER_FORWARD (xtoupper)
-
-#undef MAPPER_FORWARD
+  octave_value map (unary_mapper_t umap) const
+    { return rep->map (umap); } 
 
 protected:
 
   // The real representation.
   octave_base_value *rep;
 
 private:
 
