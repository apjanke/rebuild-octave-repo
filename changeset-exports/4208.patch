# HG changeset patch
# User jwe
# Date 1038944937 0
#      Tue Dec 03 19:48:57 2002 +0000
# Node ID e96f52432059025e49bee6e54df6dc9da1b908e2
# Parent  fa3482b345994060abde96246d3d1961b3fb0de5
[project @ 2002-12-03 19:48:57 by jwe]

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,38 @@
 2002-12-03  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* defun.h (DEFCMD): Rename from DEFUN_TEXT.  Provide DEFUN_TEXT as
+	an alias for DEFCMD.  Change all uses.
+
+	* variables.cc (at_top_level): New function.
+	(do_who, Fmark_as_command, Funmark_command): Use it.
+
+	* lex.l (COMMAND_START): Rename from TEXT_FCN.  Change all uses.
+	(MATRIX_START): Rename from MATRIX.  Change all uses.
+	* variables.cc (command_function_set): Rename from
+	text_function_set.
+	(mark_as_command): Rename from mark_as_text_function.
+	(is_marked_as_command): Rename from is_marked_as_text_function.
+	(Fmark_as_command): Rename from Fmark_as_text_function.
+	(Funmark_command): Rename from Funmark_text_function.
+	(is_command_name): Rename from is_text_function_name.
+	* symtab.h (symbol_record::COMMAND): Rename from TEXT_FUNCTION.
+	(symbol_record::mark_as_command): Rename from mark_as_text_function.
+	(symbol_record::unmark_command): Rename from
+	symbol_record::unmark_text_function.
+	(symbol_record::is_command): Rename from
+	symbol_record::is_text_function.
+	(symbol_record::symbol_def::mark_as_command): Rename from
+	symbol_record::symbol_def::mark_as_text_function.
+	(symbol_record::symbol_def::unmark_command): Rename from
+	symbol_record::symbol_def::unmark_text_function.
+	(symbol_record::symbol_def::is_command): Rename from
+	symbol_record::symbol_def::is_text_function.
+
 	* pt-jump.h, pt-jump.cc: Undo previous changes.
 	* parse.y: Undo previous changes for brea, continue, and return.
 
 2002-11-25  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* pt-stmt.cc (tree_statement::eval): Allow the lookup to execute
 	script files.  If script file has been executed, don't bother to
 	call expr->rvalue ().
diff --git a/src/debug.cc b/src/debug.cc
--- a/src/debug.cc
+++ b/src/debug.cc
@@ -75,17 +75,17 @@ get_user_function (std::string str = "")
     }
   else if (curr_function)
     dbg_fcn = curr_function;
 
   return dbg_fcn;
 }
 
 
-DEFUN_TEXT (dbstop, args, ,
+DEFCMD (dbstop, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {rline =} dbstop (func, line)\n\
 Set a breakpoint in a function\n\
 @table @code\n\
 @item func\n\
 String representing the function name.  When already in debug\n\
 mode this should be left out and only the line should be given.\n\
 @item line\n\
@@ -144,17 +144,17 @@ The rline returned is the real line that
   else
     error ("dbstop: one argument when in a function and two when not\n");
 
   retval = static_cast<double> (result);
 
   return retval;
 }
 
-DEFUN_TEXT (dbclear, args, ,
+DEFCMD (dbclear, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} dbclear (func, line)\n\
 Delete a breakpoint in a function\n\
 @table @code\n\
 @item func\n\
 String representing the function name.  When already in debug\n\
 mode this should be left out and only the line should be given.\n\
 @item line\n\
@@ -209,17 +209,17 @@ a breakpoint.   If you get the wrong lin
 	error ("dbclear: unable to find the function requested\n");
     }
   else
     error ("dbclear: expecting one or two arguements\n");
 
   return retval;
 }
 
-DEFUN_TEXT (dbstatus, args, ,
+DEFCMD (dbstatus, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {lst =} dbstatus ([func])\n\
 Return a vector containing the lines on which a function has \n\
 breakpoints set.\n\
 @table @code\n\
 @item func\n\
 String representing the function name.  When already in debug\n\
 mode this should be left out.\n\
@@ -268,17 +268,17 @@ mode this should be left out.\n\
       retval = octave_value (vec);
     }
   else
     error ("dbstatus: unable to find the function you requested\n");
 
   return retval;
 }
 
-DEFUN_TEXT (dbwhere, , ,
+DEFCMD (dbwhere, , ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} dbwhere ()\n\
 Show where we are in the code\n\
 @end deftypefn\n\
 @seealso{dbclear, dbstatus, dbstop}")
 {
   octave_value retval;
 
@@ -343,17 +343,17 @@ do_dbtype (std::ostream& os, const std::
       else
 	os << "dbtype: unable to open `" << ff << "' for reading!\n";
     }
   else
     os << "dbtype: unkown function";
 
 }
 
-DEFUN_TEXT (dbtype, args, ,
+DEFCMD (dbtype, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Loadable Function} {} dbtype ()\n\
 List script file with line numbers.\n\
 @end deftypefn\n\
 @seealso{dbclear, dbstatus, dbstop}")
 {
   octave_value retval;
   octave_user_function *dbg_fcn;
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -95,17 +95,17 @@ typedef bool (*octave_dld_fcn_installer)
 // MAKE_BUILTINS is defined to extract function names and related
 // information and create the *.df files that are eventually used to
 // create the builtins.cc file.
 
 #if defined (MAKE_BUILTINS)
 
 // Generate code to install name in the symbol table.  The script
 // mkdefs will create a .def file for every .cc file that uses DEFUN,
-// or DEFUN_TEXT.
+// or DEFCMD.
 
 #define DEFUN_INTERNAL(name, args_name, nargout_name, is_text_fcn, doc) \
   BEGIN_INSTALL_BUILTIN \
     XDEFUN_INTERNAL (name, args_name, nargout_name, is_text_fcn, doc) \
   END_INSTALL_BUILTIN
 
 #define DEFUNX_INTERNAL(name, fname, args_name, nargout_name, \
 			is_text_fcn, doc) \
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -99,17 +99,17 @@ void
 install_builtin_function (octave_builtin::fcn f, const std::string& name,
 			  const std::string& doc, bool is_text_fcn)
 {
   symbol_record *sym_rec = fbi_sym_tab->lookup (name, true);
 
   unsigned int t = symbol_record::BUILTIN_FUNCTION;
 
   if (is_text_fcn)
-    t |= symbol_record::TEXT_FUNCTION;
+    t |= symbol_record::COMMAND;
 
   sym_rec->unprotect ();
   sym_rec->define (new octave_builtin (f, name, doc), t);
   sym_rec->document (doc);
   sym_rec->make_eternal ();
   sym_rec->protect ();
 }
 
@@ -134,17 +134,17 @@ install_dld_function (octave_dld_functio
 		      const octave_shlib& shl,
 		      const std::string& doc, bool is_text_fcn)
 {
   symbol_record *sym_rec = fbi_sym_tab->lookup (name, true);
 
   unsigned int t = symbol_record::DLD_FUNCTION;
 
   if (is_text_fcn)
-    t |= symbol_record::TEXT_FUNCTION;
+    t |= symbol_record::COMMAND;
 
   sym_rec->unprotect ();
   sym_rec->define (new octave_dld_function (f, shl, name, doc), t);
   sym_rec->document (doc);
   sym_rec->make_eternal ();
   sym_rec->protect ();
 }
 
diff --git a/src/defun.h b/src/defun.h
--- a/src/defun.h
+++ b/src/defun.h
@@ -83,25 +83,29 @@ Software Foundation, 59 Temple Place - S
 // This one can be used when `name' cannot be used directly (if it is
 // already defined as a macro).  In that case, name is already a
 // quoted string, and the internal name of the function must be passed
 // too (the convetion is to use a prefix of "F", so "foo" becomes "Ffoo").
 
 #define DEFUNX(name, fname, args_name, nargout_name, doc) \
   DEFUNX_INTERNAL (name, fname, args_name, nargout_name, false, doc)
 
-// Define a builtin text-style function.
+// Define a builtin command-style function.
 //
 // This is like DEFUN, except that it defines a function that can be
 // called from the Octave language without using parenthesis to
 // surround the arguments). 
 
-#define DEFUN_TEXT(name, args_name, nargout_name, doc) \
+#define DEFCMD(name, args_name, nargout_name, doc) \
   DEFUN_INTERNAL (name, args_name, nargout_name, true, doc)
 
+// For backward compatibility.
+
+#define DEFUN_TEXT DEFCMD
+
 // Define a mapper function.
 //
 //   name is the name of the function, unquoqted.
 //
 //   ch_map is a pointer to a function that should be called for
 //     integer arguments that are expected to create integer results.
 //     (It's a kluge to handle character mappers like isalpha.)
 //
diff --git a/src/dirfns.cc b/src/dirfns.cc
--- a/src/dirfns.cc
+++ b/src/dirfns.cc
@@ -77,17 +77,17 @@ octave_change_to_directory (const std::s
       using namespace std;
 
       error ("%s: %s", newdir.c_str (), strerror (errno));
     }
 
   return cd_ok;
 }
 
-DEFUN_TEXT (cd, args, ,
+DEFCMD (cd, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} cd dir\n\
 @deffnx {Command} chdir dir\n\
 Change the current working directory to @var{dir}.  If @var{dir} is\n\
 omitted, the current directory is changed to the users home\n\
 directory.  For example,\n\
 \n\
 @example\n\
@@ -135,17 +135,17 @@ DEFALIAS (chdir, cd);
 // Get a directory listing.
 
 static void
 cleanup_iprocstream (void *p)
 {
   delete static_cast <iprocstream *> (p);
 }
 
-DEFUN_TEXT (ls, args, ,
+DEFCMD (ls, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} ls options\n\
 @deffnx {Command} dir options\n\
 List directory contents.  For example,\n\
 \n\
 @example\n\
 ls -l\n\
      @print{} total 12\n\
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -463,18 +463,17 @@ simple_help (void)
 				"reserved words");
 
   // XXX FIXME XXX -- is this distinction needed?
 
   LIST_SYMBOLS (symbol_record::BUILTIN_CONSTANT, "built-in constants");
 
   LIST_SYMBOLS (symbol_record::BUILTIN_VARIABLE, "built-in variables");
 
-  LIST_SYMBOLS (symbol_record::TEXT_FUNCTION,
-		"text functions (these names are also reserved)");
+  LIST_SYMBOLS (symbol_record::COMMAND, "commands");
 
   LIST_SYMBOLS (symbol_record::MAPPER_FUNCTION, "mapper functions");
 
   LIST_SYMBOLS (symbol_record::BUILTIN_FUNCTION, "general functions");
 
   // Also need to list variables and currently compiled functions from
   // the symbol table, if there are any.
 
@@ -765,17 +764,17 @@ builtin_help (int argc, const string_vec
 
       octave_stdout << "\nhelp: sorry, `" << argv[i]
 		    << "' is not documented\n"; 
     }
 
   additional_help_message (octave_stdout);
 }
 
-DEFUN_TEXT (help, args, ,
+DEFCMD (help, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} help\n\
 Octave's @code{help} command can be used to print brief usage-style\n\
 messages, or to display information directly from an on-line version of\n\
 the printed manual, using the GNU Info browser.  If invoked without any\n\
 arguments, @code{help} prints a list of all the available operators,\n\
 functions, and built-in variables.  If the first argument is @code{-i},\n\
 the @code{help} command searches the index of the on-line version of\n\
@@ -840,17 +839,17 @@ do_type (std::ostream& os, const std::st
 	  else
 	    os << "unable to open `" << ff << "' for reading!\n";
 	}
       else
 	error ("type: `%s' undefined", name.c_str ());
     }
 }
 
-DEFUN_TEXT (type, args, nargout,
+DEFCMD (type, args, nargout,
   "-*- texinfo -*-\n\
 \n\
 @deffn {Command} type options name @dots{}\n\
 Display the definition of each @var{name} that refers to a function.\n\
 \n\
 Normally also displays if each @var{name} is user-defined or builtin;\n\
 the @code{-q} option suppresses this behaviour.\n\
 \n\
@@ -964,17 +963,17 @@ do_which (std::ostream& os, const std::s
       if (! path.empty ())
 	os << "which: `" << name << "' is the script file\n"
 	   << path << "\n";
       else
 	os << "which: `" << name << "' is undefined\n";
     }
 }
 
-DEFUN_TEXT (which, args, nargout,
+DEFCMD (which, args, nargout,
   "-*- texinfo -*-\n\
 @deffn {Command} which name @dots{}\n\
 Display the type of each @var{name}.  If @var{name} is defined from a\n\
 function file, the full name of the file is also displayed.\n\
 @end deffn")
 {
   octave_value_list retval;
 
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -748,17 +748,17 @@ If @code{keyboard} is invoked without an
   if (nargin == 0 || nargin == 1)
     do_keyboard (args);
   else
     print_usage ("keyboard");
 
   return retval;
 }
 
-DEFUN_TEXT (echo, args, ,
+DEFCMD (echo, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} echo options\n\
 Control whether commands are displayed as they are executed.  Valid\n\
 options are:\n\
 \n\
 @table @code\n\
 @item on\n\
 Enable echoing of commands as they are executed in script files.\n\
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -15,18 +15,18 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with GNU CC; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
-%s TEXT_FCN
-%s MATRIX
+%s COMMAND_START
+%s MATRIX_START
 
 %{
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cctype>
 #include <cstring>
@@ -228,83 +228,83 @@ NOT	((\~)|(\!))
 POW     ((\*\*)|(\^))
 EPOW    (\.{POW})
 IDENT	([_a-zA-Z][_a-zA-Z0-9]*)
 EXPON	([DdEe][+-]?{D}+)
 NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EXPON}?)|(0[xX][0-9a-fA-F]+))
 %%
 
 %{
-// Help and other text-style functions are a pain in the ass.  This
+// Help and other command-style functions are a pain in the ass.  This
 // stuff needs to be simplified.  May require some changes in the
 // parser too.
 %}
 
-<TEXT_FCN>{NL} {
+<COMMAND_START>{NL} {
     BEGIN 0;
     current_input_column = 1;
     lexer_flags.quote_is_transpose = false;
     lexer_flags.cant_be_identifier = false;
     lexer_flags.convert_spaces_to_comma = true;
     return '\n';
   }
 
-<TEXT_FCN>[\;\,] {
+<COMMAND_START>[\;\,] {
     if (lexer_flags.doing_set && strcmp (yytext, ",") == 0)
       {
 	TOK_PUSH_AND_RETURN (yytext, STRING);
       }
     else
       {
 	BEGIN 0;
 	if (strcmp (yytext, ",") == 0)
 	  TOK_RETURN (',');
 	else
 	  TOK_RETURN (';');
       }
   }
 
-<TEXT_FCN>[\"\'] {
+<COMMAND_START>[\"\'] {
     current_input_column++;
     return handle_string (yytext[0], true);
   }
 
-<TEXT_FCN>[^#% \t\n\;\,\"\'][^ \t\n\;\,]*{S}* {
+<COMMAND_START>[^#% \t\n\;\,\"\'][^ \t\n\;\,]*{S}* {
     std::string tok = strip_trailing_whitespace (yytext);
     TOK_PUSH_AND_RETURN (tok, STRING);
   }
 
 %{
 // For this and the next two rules, we're looking at ']', and we
 // need to know if the next token is `=' or `=='.
 //
 // It would have been so much easier if the delimiters were simply
 // different for the expression on the left hand side of the equals
 // operator.
 //
 // It's also a pain in the ass to decide whether to insert a comma
 // after seeing a ']' character...
 %}
 
-<MATRIX>{SNLCMT}*\]{S}* {
+<MATRIX_START>{SNLCMT}*\]{S}* {
     scan_for_comments (yytext);
     fixup_column_count (yytext);
     int c = yytext[yyleng-1];
     int cont_is_spc = eat_continuation ();
     int spc_gobbled = (cont_is_spc || c == ' ' || c == '\t');
     return handle_close_bracket (spc_gobbled);
   }
 
 %{
 // Commas are element separators in matrix constants.  If we don't
 // check for continuations here we can end up inserting too many
 // commas.
 %}
 
-<MATRIX>{S}*\,{S}* {
+<MATRIX_START>{S}*\,{S}* {
     current_input_column += yyleng;
 
     int tmp = eat_continuation ();
 
     lexer_flags.quote_is_transpose = false;
     lexer_flags.cant_be_identifier = false;
     lexer_flags.convert_spaces_to_comma = true;
 
@@ -321,17 +321,17 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 
 %{
 // In some cases, spaces in matrix constants can turn into commas.
 // If commas are required, spaces are not important in matrix
 // constants so we just eat them.  If we don't check for continuations
 // here we can end up inserting too many commas.
 %}
 
-<MATRIX>{S}+ {
+<MATRIX_START>{S}+ {
     current_input_column += yyleng;
 
     int tmp = eat_continuation ();
     int bin_op = next_token_is_bin_op (true);
     int postfix_un_op = next_token_is_postfix_unary_op (true);
 
     if (! (postfix_un_op || bin_op)
 	&& nesting_level.is_bracket ()
@@ -359,34 +359,34 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
   }
 
 %{
 // Semicolons are handled as row seprators in matrix constants.  If we
 // don't eat whitespace here we can end up inserting too many
 // semicolons.
 %}
 
-<MATRIX>{SNLCMT}*;{SNLCMT}* {
+<MATRIX_START>{SNLCMT}*;{SNLCMT}* {
     scan_for_comments (yytext);
     fixup_column_count (yytext);
     eat_whitespace ();
     lexer_flags.quote_is_transpose = false;
     lexer_flags.cant_be_identifier = false;
     lexer_flags.convert_spaces_to_comma = true;
     return ';';
   }
 
 %{
 // In some cases, new lines can also become row separators.  If we
 // don't eat whitespace here we can end up inserting too many
 // semicolons.
 %}
 
-<MATRIX>{S}*{COMMENT}{SNLCMT}* |
-<MATRIX>{S}*{NL}{SNLCMT}* {
+<MATRIX_START>{S}*{COMMENT}{SNLCMT}* |
+<MATRIX_START>{S}*{NL}{SNLCMT}* {
     scan_for_comments (yytext);
     fixup_column_count (yytext);
     eat_whitespace ();
 
     if (Vwhitespace_in_literal_matrix != 2)
       {
 	lexer_flags.quote_is_transpose = false;
 	lexer_flags.cant_be_identifier = false;
@@ -425,17 +425,17 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
     if (lexer_flags.plotting && ! lexer_flags.past_plot_range)
       {
 	lexer_flags.in_plot_range = true;
 	return OPEN_BRACE;
       }
     else
       {
 	lexer_flags.bracketflag++;
-	BEGIN MATRIX;
+	BEGIN MATRIX_START;
 	return '[';
       }
   }
 
 \] {
     nesting_level.remove ();
 
     if (lexer_flags.plotting && ! lexer_flags.past_plot_range)
@@ -464,17 +464,17 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 {D}+/\.[\*/\\^'] |
 {NUMBER} {
     handle_number ();
     return NUM;
   }
 
 %{
 // Eat whitespace.  Whitespace inside matrix constants is handled by
-// the <MATRIX> start state code above.
+// the <MATRIX_START> start state code above.
 %}
 
 {S}* {
     current_input_column += yyleng;
   }
 
 %{
 // Continuation lines.  Allow comments after continuations.
@@ -523,17 +523,17 @@ NUMBER	(({D}+\.?{D}*{EXPON}?)|(\.{D}+{EX
 %}
 
 {IDENT}{S}* {
     return handle_identifier ();
   }
 
 %{
 // A new line character.  New line characters inside matrix constants
-// are handled by the <MATRIX> start state code above.  If closest
+// are handled by the <MATRIX_START> start state code above.  If closest
 // nesting is inside parentheses, don't return a row separator.
 %}
 
 {NL} {
     current_input_column = 1;
     lexer_flags.quote_is_transpose = false;
     lexer_flags.cant_be_identifier = false;
     lexer_flags.convert_spaces_to_comma = true;
@@ -2351,31 +2351,31 @@ handle_identifier (void)
   // If we are looking at a text style function, set up to gobble its
   // arguments.
   //
   // If the following token is `=', or if we are parsing a function
   // return list or function parameter list, or if we are looking at
   // something like [ab,cd] = foo (), force the symbol to be inserted
   // as a variable in the current symbol table.
 
-  if (is_text_function_name (tok) && ! is_variable (tok))
+  if (is_command_name (tok) && ! is_variable (tok))
     {
       if (next_tok_is_eq
 	  || lexer_flags.looking_at_return_list
 	  || lexer_flags.looking_at_parameter_list
 	  || lexer_flags.looking_at_matrix_or_assign_lhs)
 	{
 	  force_local_variable (tok);
 	}
       else if (! next_tok_is_paren)
 	{
 	  if (tok == "gset")
 	    lexer_flags.doing_set = true;
 
-	  BEGIN TEXT_FCN;
+	  BEGIN COMMAND_START;
 	}
     }
 
   // Find the token in the symbol table.
 
   yylval.tok_val = new token (lookup_identifier (tok),
 			      input_line_number,
 			      current_input_column);
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -3066,17 +3066,17 @@ do_load (std::istream& stream, const std
 #ifdef HAVE_HDF5
 #define HAVE_HDF5_HELP_STRING ""
 #else /* ! HAVE_HDF5 */
 #define HAVE_HDF5_HELP_STRING "\n\
 HDF5 load and save are not available, as this Octave executable was\n\
 not linked with the HDF5 library."
 #endif /* ! HAVE HDF5 */
 
-DEFUN_TEXT (load, args, nargout,
+DEFCMD (load, args, nargout,
   "-*- texinfo -*-\n\
 @deffn {Command} load options file v1 v2 @dots{}\n\
 Load the named variables from the file @var{file}.  As with @code{save},\n\
 you may specify a list of variables and @code{load} will only extract\n\
 those variables with names that match.  For example, to restore the\n\
 variables saved in the file @file{data}, use the command\n\
 \n\
 @example\n\
@@ -4876,17 +4876,17 @@ save_user_variables (void)
 	      file.close ();
 	    }
 	  else
 	    warning ("unable to open `%s' for writing...", fname);
 	}
     }
 }
 
-DEFUN_TEXT (save, args, ,
+DEFCMD (save, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} save options file v1 v2 @dots{}\n\
 Save the named variables @var{v1}, @var{v2}, @dots{} in the file\n\
 @var{file}.  The special filename @samp{-} can be used to write the\n\
 output to your terminal.  If no variable names are listed, Octave saves\n\
 all the variables in the current scope.  Valid options for the\n\
 @code{save} command are listed in the following table.  Options that\n\
 modify the output format override the format specified by the built-in\n\
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -527,17 +527,17 @@ do_run_history (int argc, const string_v
 
   // Delete the temporary file.
 
   // XXX FIXME XXX -- should probably be done using an unwind_protect.
 
   unlink (name.c_str ());
 }
 
-DEFUN_TEXT (edit_history, args, ,
+DEFCMD (edit_history, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} edit_history options\n\
 If invoked with no arguments, @code{edit_history} allows you to edit the\n\
 history list using the editor named by the variable @code{EDITOR}.  The\n\
 commands to be edited are first copied to a temporary file.  When you\n\
 exit the editor, Octave executes the commands that remain in the file.\n\
 It is often more convenient to use @code{edit_history} to define functions \n\
 rather than attempting to enter them directly on the command line.\n\
@@ -577,17 +577,17 @@ omitted, the previous command in the his
   if (error_state)
     return retval;
 
   do_edit_history (argc, argv);
 
   return retval;
 }
 
-DEFUN_TEXT (history, args, ,
+DEFCMD (history, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} history options\n\
 If invoked with no arguments, @code{history} displays a list of commands\n\
 that you have executed.  Valid options are:\n\
 \n\
 @table @code\n\
 @item -w @var{file}\n\
 Write the current history to the file @var{file}.  If the name is\n\
@@ -620,17 +620,17 @@ typed without displaying line numbers, u
   if (error_state)
     return retval;
 
   do_history (argc, argv);
 
   return retval;
 }
 
-DEFUN_TEXT (run_history, args, ,
+DEFCMD (run_history, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} run_history [first] [last]\n\
 Similar to @code{edit_history}, except that the editor is not invoked,\n\
 and the commands are simply executed as they appear in the history list.\n\
 @end deffn")
 {
   octave_value_list retval;
 
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -402,17 +402,17 @@ open_diary_file (void)
   octave_stdout.set_diary_skip ();
 
   external_diary_file.open (diary_file.c_str (), std::ios::app);
 
   if (! external_diary_file)
     error ("diary: can't open diary file `%s'", diary_file.c_str ());
 }
 
-DEFUN_TEXT (diary, args, ,
+DEFCMD (diary, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} diary options\n\
 Create a list of all commands @emph{and} the output they produce, mixed\n\
 together just as you see them on your terminal.  Valid options are:\n\
 \n\
 @table @code\n\
 @item on\n\
 Start recording your session in a file called @file{diary} in your\n\
@@ -473,17 +473,17 @@ Without any arguments, @code{diary} togg
     default:
       print_usage ("diary");
       break;
     }
 
   return retval;
 }
 
-DEFUN_TEXT (more, args, ,
+DEFCMD (more, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} more\n\
 @deffnx {Command} more on\n\
 @deffnx {Command} more off\n\
 Turn output pagination on or off.  Without an argument, @code{more}\n\
 toggles the current state.\n\
 @end deffn")
 {
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -2006,17 +2006,17 @@ set_format_style (int argc, const string
     }
   else
     {
       init_format_state ();
       set_output_prec_and_fw (5, 10);
     }
 }
 
-DEFUN_TEXT (format, args, ,
+DEFCMD (format, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} format options\n\
 Control the format of the output produced by @code{disp} and Octave's\n\
 normal echoing mechanism.  Valid options are listed in the following\n\
 table.\n\
 \n\
 @table @code\n\
 @item short\n\
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -977,17 +977,17 @@ Close stream to the @code{gnuplot} subpr
 this will close the plot window.\n\
 @end deftypefn")
 {
   octave_value_list retval;
   close_plot_stream ();
   return retval;
 }
 
-DEFUN_TEXT (hold, args, ,
+DEFCMD (hold, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} hold @var{args}\n\
 Tell Octave to `hold' the current data on the plot when executing\n\
 subsequent plotting commands.  This allows you to execute a series of\n\
 plot commands and have all the lines end up on the same figure.  The\n\
 default is for each new plot command to clear the plot device first.\n\
 For example, the command\n\
 \n\
@@ -1085,17 +1085,17 @@ Send @var{string} directly to gnuplot su
 	}
     }
   else
     print_usage ("graw");
 
   return retval;
 }
 
-DEFUN_TEXT (gset, args, ,
+DEFCMD (gset, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} gset options\n\
 Set plotting options for gnuplot\n\
 @end deffn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
@@ -1139,25 +1139,25 @@ Set plotting options for gnuplot\n\
 
   send_to_plot_stream (OSSTREAM_STR (plot_buf));
 
   OSSTREAM_FREEZE (plot_buf);
 
   return retval;
 }
 
-DEFUN_TEXT (set, args, nargout,
+DEFCMD (set, args, nargout,
   "-*- texinfo -*-\n\
 This command is has been replaced by @code{gset}.")
 {
   warning ("set is obsolete -- use gset instead");
   return Fgset (args, nargout);
 }
 
-DEFUN_TEXT (gshow, args, ,
+DEFCMD (gshow, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} gshow options\n\
 Show plotting options.\n\
 @end deffn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
@@ -1179,17 +1179,17 @@ Show plotting options.\n\
 
   send_to_plot_stream (OSSTREAM_STR (plot_buf));
 
   OSSTREAM_FREEZE (plot_buf);
 
   return retval;
 }
 
-DEFUN_TEXT (show, args, nargout,
+DEFCMD (show, args, nargout,
   "-*- texinfo -*-\n\
 This command is has been replaced by @code{gshow}.")
 {
   warning ("show is obsolete -- use gshow instead");
   return Fgshow (args, nargout);
 }
 
 static int
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -59,18 +59,18 @@ symbol_record::symbol_def::allocator (si
 
 std::string
 SYMBOL_DEF::type_as_string (void) const
 {
   std::string retval = "<unknown type>";
 
   if (is_user_variable ())
     retval = "user-defined variable";
-  else if (is_text_function ())
-    retval = "built-in text function";
+  else if (is_command ())
+    retval = "built-in command";
   else if (is_mapper_function ())
     retval = "built-in mapper function";
   else if (is_user_function ())
     retval = "user-defined function";
   else if (is_builtin_constant ())
     retval = "built-in constant";
   else if (is_builtin_variable ())
     retval = "built-in variable";
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -57,17 +57,17 @@ public:
 
   enum TYPE
     {
       UNKNOWN = 0,
       USER_FUNCTION = 1,
       USER_VARIABLE = 2,
       DLD_FUNCTION = 4,
       BUILTIN_FUNCTION = 8,
-      TEXT_FUNCTION = 16,
+      COMMAND = 16,
       MAPPER_FUNCTION = 32,
       BUILTIN_VARIABLE = 64,
       BUILTIN_CONSTANT = 128
     };
 
 private:
 
   // Variables or functions.
@@ -87,38 +87,38 @@ private:
       { return (symbol_type & symbol_record::BUILTIN_CONSTANT); }
 
     bool is_variable (void) const
       {
 	return (symbol_type & symbol_record::USER_VARIABLE
 		|| symbol_type & symbol_record::BUILTIN_VARIABLE);
       }
 
-    // It's not necessary to check for TEXT_FUNCTION and MAPPER_FUNCTION
+    // It's not necessary to check for COMMAND and MAPPER_FUNCTION
     // here.  Those tags are just used as additional qualifiers for
     // the other types of functions.
 
     bool is_function (void) const
       {
 	return (symbol_type & symbol_record::USER_FUNCTION
 		|| symbol_type & symbol_record::DLD_FUNCTION
 		|| symbol_type & symbol_record::BUILTIN_FUNCTION);
       }
 
     bool is_user_variable (void) const
       { return (symbol_type & symbol_record::USER_VARIABLE); }
 
-    void mark_as_text_function (void)
-      { symbol_type |= symbol_record::TEXT_FUNCTION; }
+    void mark_as_command (void)
+      { symbol_type |= symbol_record::COMMAND; }
 
-    void unmark_text_function (void)
-      { symbol_type &= ~symbol_record::TEXT_FUNCTION; }
+    void unmark_command (void)
+      { symbol_type &= ~symbol_record::COMMAND; }
 
-    bool is_text_function (void) const
-      { return (symbol_type & symbol_record::TEXT_FUNCTION); }
+    bool is_command (void) const
+      { return (symbol_type & symbol_record::COMMAND); }
 
     bool is_mapper_function (void) const
       { return (symbol_type & symbol_record::MAPPER_FUNCTION); }
 
     bool is_user_function (void) const
       { return (symbol_type & symbol_record::USER_FUNCTION); }
 
     bool is_builtin_constant (void) const
@@ -238,24 +238,24 @@ public:
 
   octave_value& def (void) { return definition->def (); }
 
   void rename (const std::string& new_name);
 
   bool is_function (void) const
     { return definition->is_function (); }
 
-  void mark_as_text_function (void)
-    { definition->mark_as_text_function (); }
+  void mark_as_command (void)
+    { definition->mark_as_command (); }
 
-  void unmark_text_function (void)
-    { definition->unmark_text_function (); }
+  void unmark_command (void)
+    { definition->unmark_command (); }
 
-  bool is_text_function (void) const
-    { return definition->is_text_function (); }
+  bool is_command (void) const
+    { return definition->is_command (); }
 
   bool is_mapper_function (void) const
     { return definition->is_mapper_function (); }
 
   bool is_user_function (void) const
     { return definition->is_user_function (); }
 
   bool is_builtin_function (void) const
@@ -385,17 +385,17 @@ private:
 #define SYMTAB_GLOBAL_SCOPE 2
 
 #define SYMTAB_ALL_SCOPES (SYMTAB_LOCAL_SCOPE | SYMTAB_GLOBAL_SCOPE)
 
 #define SYMTAB_ALL_TYPES (symbol_record::USER_FUNCTION \
 			  | symbol_record::USER_VARIABLE \
 			  | symbol_record::DLD_FUNCTION \
 			  | symbol_record::BUILTIN_FUNCTION \
-			  | symbol_record::TEXT_FUNCTION \
+			  | symbol_record::COMMAND \
 			  | symbol_record::MAPPER_FUNCTION \
 			  | symbol_record::BUILTIN_VARIABLE \
 			  | symbol_record::BUILTIN_CONSTANT)
 
 #define SYMTAB_VARIABLES (symbol_record::USER_VARIABLE \
 			  | symbol_record::BUILTIN_VARIABLE)
 
 class
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -642,17 +642,17 @@ tilde_expand (\"~/bin\")\n\
   else
     print_usage ("tilde_expand");
 
   return retval;
 }
 
 #if defined (__EMX__) && defined (OS2)
 
-DEFUN_TEXT (extproc, , ,
+DEFCMD (extproc, , ,
   "extproc: ignored by Octave")
 {
   return octave_value_list ();
 }
 
 DEFALIAS (EXTPROC, extproc);
 
 #endif
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -208,17 +208,17 @@ main_loop (void)
 void
 clean_up_and_exit (int retval)
 {
   do_octave_atexit ();
 
   exit (retval == EOF ? 0 : retval);
 }
 
-DEFUN_TEXT (casesen, args, ,
+DEFCMD (casesen, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} casesen arg\n\
 Provided for compatibility with Matlab, but does nothing.\n\
 @end deffn")
 {
   octave_value_list retval;
 
   int argc = args.length () + 1;
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -66,16 +66,22 @@ symbol_table *top_level_sym_tab = 0;
 symbol_table *curr_sym_tab = 0;
 
 // Symbol table for global symbols.
 symbol_table *global_sym_tab = 0;
 
 // Symbol table for functions and built-in symbols.
 symbol_table *fbi_sym_tab = 0;
 
+static inline bool
+at_top_level (void)
+{
+  return (curr_sym_tab == top_level_sym_tab);
+}
+
 // Initialization.
 
 // Create the initial symbol tables and set the current scope at the
 // top level.
 
 void
 initialize_symbol_tables (void)
 {
@@ -97,118 +103,128 @@ initialize_symbol_tables (void)
 
 bool
 is_builtin_variable (const std::string& name)
 {
   symbol_record *sr = fbi_sym_tab->lookup (name);
   return (sr && sr->is_builtin_variable ());
 }
 
-// Is this a text-style function?
+// Is this a command-style function?
 
-static std::set <std::string> text_function_set;
+static std::set <std::string> command_set;
 
 static inline bool
-is_marked_as_text_function (const std::string& s)
+is_marked_as_command (const std::string& s)
 {
-  return text_function_set.find (s) != text_function_set.end ();
+  return command_set.find (s) != command_set.end ();
 }
 
 static inline void
-mark_as_text_function (const std::string& s)
+mark_as_command (const std::string& s)
 {
-  text_function_set.insert (s);
+  command_set.insert (s);
 }
 
 static inline void
-unmark_text_function (const std::string& s)
+unmark_command (const std::string& s)
 {
-  text_function_set.erase (s);
+  command_set.erase (s);
 
   symbol_record *sr = fbi_sym_tab->lookup (s);
 
   if (sr)
-    sr->unmark_text_function ();
+    sr->unmark_command ();
 }
 
-DEFUN_TEXT (mark_as_text_function, args, ,
+DEFCMD (mark_as_command, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} mark_as_text_function (@var{name})\n\
-Enter @var{name} into the list of text functions\n\
+@deftypefn {Built-in Function} {} mark_as_command (@var{name})\n\
+Enter @var{name} into the list of commands.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int nargin = args.length ();
+  if (at_top_level ())
+    {
+      int nargin = args.length ();
 
-  if (nargin > 0)
-    {
-      int argc = nargin + 1;
+      if (nargin > 0)
+	{
+	  int argc = nargin + 1;
 
-      string_vector argv = args.make_argv ("mark_as_text_function");
+	  string_vector argv = args.make_argv ("mark_as_command");
 
-      if (! error_state)
-	{
-	  for (int i = 1; i < argc; i++)
-	    mark_as_text_function (argv[i]);
+	  if (! error_state)
+	    {
+	      for (int i = 1; i < argc; i++)
+		mark_as_command (argv[i]);
+	    }
 	}
+      else
+	print_usage ("mark_as_command");
     }
   else
-    print_usage ("mark_as_text_function");
+    warning ("mark_as_command: invalid use inside function body");
 
   return retval;
 }
 
-DEFUN_TEXT (unmark_text_function, args, ,
+DEFCMD (unmark_command, args, ,
   "-*- texinfo -*-\n\
-@deftypefn {Built-in Function} {} mark_as_text_function (@var{name})\n\
-Enter @var{name} into the list of text functions\n\
+@deftypefn {Built-in Function} {} mark_as_command (@var{name})\n\
+Remove @var{name} from the list of commands.\n\
 @end deftypefn")
 {
   octave_value_list retval;
 
-  int nargin = args.length ();
+  if (at_top_level ())
+    {
+      int nargin = args.length ();
 
-  if (nargin > 0)
-    {
-      int argc = nargin + 1;
+      if (nargin > 0)
+	{
+	  int argc = nargin + 1;
 
-      string_vector argv = args.make_argv ("unmark_text_function");
+	  string_vector argv = args.make_argv ("unmark_command");
 
-      if (! error_state)
-	{
-	  for (int i = 1; i < argc; i++)
-	    unmark_text_function (argv[i]);
+	  if (! error_state)
+	    {
+	      for (int i = 1; i < argc; i++)
+		unmark_command (argv[i]);
+	    }
 	}
+      else
+	print_usage ("unmark_command");
     }
   else
-    print_usage ("unmark_text_function");
+    warning ("mark_as_command: invalid use inside function body");
 
   return retval;
 }
 
 bool
-is_text_function_name (const std::string& s)
+is_command_name (const std::string& s)
 {
   bool retval = false;
 
   symbol_record *sr = fbi_sym_tab->lookup (s);
 
   if (sr)
     {
-      if (sr->is_text_function ())
+      if (sr->is_command ())
 	retval = true;
-      else if (is_marked_as_text_function (s))
+      else if (is_marked_as_command (s))
 	{
-	  sr->mark_as_text_function ();
+	  sr->mark_as_command ();
 	  retval = true;
 	}
     }
   else
-    retval = is_marked_as_text_function (s);
+    retval = is_marked_as_command (s);
 
   return retval;
 }
 
 // Is this a built-in function?
 
 bool
 is_builtin_function_name (const std::string& s)
@@ -953,17 +969,17 @@ Set the documentation string for @var{sy
 
       if (! error_state)
 	{
 	  std::string help = args(1).string_value ();
 
 	  if (! error_state)
 	    {
 	      if (is_builtin_variable (name)
-		  || is_text_function_name (name)
+		  || is_command_name (name)
 		  || is_mapper_function_name (name)
 		  || is_builtin_function_name (name))
 		error ("document: can't redefine help for built-in variables and functions");
 	      else
 		{
 		  symbol_record *sym_rec = curr_sym_tab->lookup (name);
 
 		  if (sym_rec)
@@ -1016,31 +1032,31 @@ do_who (int argc, const string_vector& a
 	break;
     }
 
   // If no options were specified to select the type of symbol to
   // display, then set defaults.
 
   if (! (show_builtins || show_functions || show_variables))
     {
-      show_functions = (curr_sym_tab == top_level_sym_tab);
+      show_functions = at_top_level ();
       show_variables = true;
     }
 
   int npats = argc - i;
   string_vector pats (npats);
   for (int j = 0; j < npats; j++)
     pats[j] = argv[i+j];
 
   // If the user specified -l and nothing else, show variables.  If
   // evaluating this at the top level, also show functions.
 
   if (show_verbose && ! (show_builtins || show_functions || show_variables))
     {
-      show_functions = (curr_sym_tab == top_level_sym_tab);
+      show_functions = at_top_level ();
       show_variables = 1;
     }
 
   int pad_after = 0;
 
   if (show_builtins)
     {
       pad_after += fbi_sym_tab->maybe_list
@@ -1082,17 +1098,17 @@ do_who (int argc, const string_vector& a
     }
 
   if (pad_after)
     octave_stdout << "\n";
 
   return retval;
 }
 
-DEFUN_TEXT (who, args, ,
+DEFCMD (who, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} who options pattern @dots{}\n\
 @deffnx {Command} whos options pattern @dots{}\n\
 List currently defined symbols matching the given patterns.  The\n\
 following are valid options.  They may be shortened to one character but\n\
 may not be combined.\n\
 \n\
 @table @code\n\
@@ -1134,17 +1150,17 @@ The command @kbd{whos} is equivalent to 
   if (error_state)
     return retval;
 
   retval = do_who (argc, argv);
 
   return retval;
 }
 
-DEFUN_TEXT (whos, args, ,
+DEFCMD (whos, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} whos options pattern @dots{}\n\
 See who.\n\
 @end deffn")
 {
   octave_value_list retval;
 
   int nargin = args.length ();
@@ -1572,17 +1588,17 @@ do_matlab_compatible_clear (const string
       if (cond) \
         { \
           print_usage ("clear"); \
           return retval; \
         } \
     } \
   while (0)
 
-DEFUN_TEXT (clear, args, ,
+DEFCMD (clear, args, ,
   "-*- texinfo -*-\n\
 @deffn {Command} clear [-x] pattern @dots{}\n\
 Delete the names matching the given patterns from the symbol table.  The\n\
 pattern may contain the following special characters:\n\
 \n\
 @table @code\n\
 @item ?\n\
 Match any single character.\n\
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -38,17 +38,17 @@ class string_vector;
 
 #include "ov.h"
 #include "ov-builtin.h"
 #include "symtab.h"
 
 extern void initialize_symbol_tables (void);
 
 extern bool is_builtin_variable (const std::string&);
-extern bool is_text_function_name (const std::string&);
+extern bool is_command_name (const std::string&);
 extern bool is_mapper_function_name (const std::string&);
 extern bool is_builtin_function_name (const std::string&);
 extern bool is_globally_visible (const std::string&);
 
 extern octave_function *
 is_valid_function (const octave_value&, const std::string& = std::string (),
 		   bool warn = false); 
 
