# HG changeset patch
# User Rik <octave@nomad.inbox5.com>
# Date 1298770091 28800
#      Sat Feb 26 17:28:11 2011 -0800
# Node ID 7a5aacf65f81af8dd7364ff50706d7ec8e51340c
# Parent  3244c6e0af4a237b002307c0b86b0abdddd1b221
Rewrite error strings in src/ to use variables named in documentation.

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,20 @@
+2010-02-26  Rik  <octave@nomad.inbox5.com>
+
+	* DLD-FUNCTIONS/besselj.cc, DLD-FUNCTIONS/cellfun.cc,
+	DLD-FUNCTIONS/filter.cc, DLD-FUNCTIONS/matrix_type.cc,
+	DLD-FUNCTIONS/strfind.cc, DLD-FUNCTIONS/sub2ind.cc, bitfcns.cc,
+	data.cc, error.cc, file-io.cc, graphics.cc, help.cc, input.cc,
+	load-path.cc, load-save.cc, oct-parse.yy, ov-base.cc, ov-cell.cc,
+	ov-class.cc, ov-fcn-handle.cc, ov-fcn-inline.cc, ov-flt-re-mat.cc,
+	ov-struct.cc, ov-usr-fcn.cc, pr-output.cc, pt-mat.cc, sparse.cc,
+	strfns.cc, syscalls.cc, sysdep.cc, toplev.cc, utils.cc, variables.cc:
+	Rewrite error strings to use variables named in documentation.
+
 2011-02-23  John W. Eaton  <jwe@octave.org>
 
 	* mex.cc (mxArray_base::dup): Return retval.
 
 2011-02-22  Konstantinos Poulios  <logari81@googlemail.com>
 
 	* graphics.h.in (class axes::properties): New hidden property
 	looseinset.
diff --git a/src/DLD-FUNCTIONS/besselj.cc b/src/DLD-FUNCTIONS/besselj.cc
--- a/src/DLD-FUNCTIONS/besselj.cc
+++ b/src/DLD-FUNCTIONS/besselj.cc
@@ -584,17 +584,17 @@ return @code{NaN}.\n\
           kind = args(0).int_value ();
 
           if (! error_state)
             {
               if (kind < 0 || kind > 3)
                 error ("airy: expecting K = 0, 1, 2, or 3");
             }
           else
-            error ("airy: expecting integer value for K");
+            error ("airy: K must be an integer value");
         }
 
       if (! error_state)
         {
           int idx = nargin == 1 ? 0 : 1;
 
           if (args (idx).is_single_type ())
             {
@@ -611,17 +611,17 @@ return @code{NaN}.\n\
                     result = airy (z, kind == 1, scale, ierr);
 
                   if (nargout > 1)
                     retval(1) = NDArray (ierr);
 
                   retval(0) = result;
                 }
               else
-                error ("airy: expecting complex matrix for Z");
+                error ("airy: Z must be a complex matrix");
             }
           else
             {
               ComplexNDArray z = args(idx).complex_array_value ();
 
               if (! error_state)
                 {
                   Array<octave_idx_type> ierr;
@@ -633,17 +633,17 @@ return @code{NaN}.\n\
                     result = airy (z, kind == 1, scale, ierr);
 
                   if (nargout > 1)
                     retval(1) = NDArray (ierr);
 
                   retval(0) = result;
                 }
               else
-                error ("airy: expecting complex matrix for Z");
+                error ("airy: Z must be a complex matrix");
             }
         }
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/src/DLD-FUNCTIONS/cellfun.cc b/src/DLD-FUNCTIONS/cellfun.cc
--- a/src/DLD-FUNCTIONS/cellfun.cc
+++ b/src/DLD-FUNCTIONS/cellfun.cc
@@ -209,17 +209,17 @@ cellfun (@@factorial, @{-1,2@},'ErrorHan
 @end deftypefn")
 {
   octave_value_list retval;
   int nargin = args.length ();
   int nargout1 = (nargout < 1 ? 1 : nargout);
 
   if (nargin < 2)
     {
-      error ("cellfun: you must supply at least 2 arguments");
+      error ("cellfun: function requires at least 2 arguments");
       print_usage ();
       return retval;
     }
 
   octave_value func = args(0);
 
   if (! args(1).is_cell ())
     {
diff --git a/src/DLD-FUNCTIONS/filter.cc b/src/DLD-FUNCTIONS/filter.cc
--- a/src/DLD-FUNCTIONS/filter.cc
+++ b/src/DLD-FUNCTIONS/filter.cc
@@ -74,17 +74,17 @@ filter (MArray<T>& b, MArray<T>& a, MArr
     {
       error ("filter: the first element of A must be non-zero");
       return y;
     }
 
   dim_vector x_dims = x.dims ();
   if (dim < 0 || dim > x_dims.length ())
     {
-      error ("filter: filtering over invalid dimension");
+      error ("filter: DIM must be a valid dimension");
       return y;
     }
 
   octave_idx_type x_len = x_dims(dim);
 
   dim_vector si_dims = si.dims ();
   octave_idx_type si_len = si_dims(0);
 
@@ -257,17 +257,17 @@ filter (MArray<T>& b, MArray<T>& a, MArr
 
       // All dimensions singleton, pick first dimension
       if (dim == x_dims.length ())
         dim = 0;
     }
   else
     if (dim < 0 || dim > x_dims.length ())
       {
-        error ("filter: filtering over invalid dimension");
+        error ("filter: DIM must be a valid dimension");
         return MArray<T> ();
       }
 
   octave_idx_type a_len = a.length ();
   octave_idx_type b_len = b.length ();
 
   octave_idx_type si_len = (a_len > b_len ? a_len : b_len) - 1;
   dim_vector si_dims = x.dims ();
@@ -394,17 +394,17 @@ H(z) = {\\displaystyle\\sum_{k=0}^M d_{k
   int dim;
   dim_vector x_dims = args(2).dims ();
 
   if (nargin == 5)
     {
       dim = args(4).nint_value() - 1;
       if (dim < 0 || dim >= x_dims.length ())
         {
-          error ("filter: filtering over invalid dimension");
+          error ("filter: DIM must be a valid dimension");
           return retval;
         }
     }
   else
     {
       // Find first non-singleton dimension
       dim = 0;
       while (dim < x_dims.length () && x_dims(dim) <= 1)
diff --git a/src/DLD-FUNCTIONS/matrix_type.cc b/src/DLD-FUNCTIONS/matrix_type.cc
--- a/src/DLD-FUNCTIONS/matrix_type.cc
+++ b/src/DLD-FUNCTIONS/matrix_type.cc
@@ -240,17 +240,17 @@ LU@tie{}factorization.  Once the matrix 
                       if (nargin != 4)
                         error ("matrix_type: banded matrix type requires 4 arguments");
                       else
                         {
                           nl = args(2).nint_value ();
                           nu = args(3).nint_value ();
 
                           if (error_state)
-                            error ("matrix_type: band size must be integer");
+                            error ("matrix_type: band size NL, NU must be integers");
                           else
                             {
                               if (nl == 1 && nu == 1)
                                 mattyp.mark_as_tridiagonal ();
                               else
                                 mattyp.mark_as_banded (nu, nl);
 
                               if (str_typ == "banded positive definite")
diff --git a/src/DLD-FUNCTIONS/strfind.cc b/src/DLD-FUNCTIONS/strfind.cc
--- a/src/DLD-FUNCTIONS/strfind.cc
+++ b/src/DLD-FUNCTIONS/strfind.cc
@@ -388,22 +388,22 @@ done for each element and a cell array i
                       error ("strrep: each element of S must be a string");
                       break;
                     }
                 }
 
               retval = retc;
             }
           else
-            error ("strrep: first argument must be a string or cell array of strings");
+            error ("strrep: S must be a string or cell array of strings");
         }
       else if (argpat.is_cell () || argrep.is_cell ())
         retval = do_simple_cellfun (Fstrrep, "strrep", args);
       else
-        error ("strrep: X and Y arguments must be strings or cell arrays of strings");
+        error ("strrep: PTN and REP arguments must be strings or cell arrays of strings");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/src/DLD-FUNCTIONS/sub2ind.cc b/src/DLD-FUNCTIONS/sub2ind.cc
--- a/src/DLD-FUNCTIONS/sub2ind.cc
+++ b/src/DLD-FUNCTIONS/sub2ind.cc
@@ -35,29 +35,29 @@ along with Octave; see the file COPYING.
 static dim_vector
 get_dim_vector (const octave_value& val, const char *name)
 {
   RowVector dimsv = val.row_vector_value (false, true);
   dim_vector dv;
   octave_idx_type n = dimsv.length ();
 
   if (n < 1)
-    error ("%s: dimension vector must not be empty", name);
+    error ("%s: dimension vector DIMS must not be empty", name);
   else
     {
       dv.resize (std::max (n, static_cast<octave_idx_type> (2)));
       dv(1) = 1;
       for (octave_idx_type i = 0; i < n; i++)
         {
           octave_idx_type ii = dimsv(i);
           if (ii == dimsv(i) && ii >= 0)
             dv(i) = ii;
           else
             {
-              error ("%s: dimension vector must contain integers", name);
+              error ("%s: dimension vector DIMS must contain integers", name);
               break;
             }
         }
     }
 
   return dv;
 }
 
diff --git a/src/bitfcns.cc b/src/bitfcns.cc
--- a/src/bitfcns.cc
+++ b/src/bitfcns.cc
@@ -71,17 +71,17 @@ along with Octave; see the file COPYING.
                 for (int k = 0; k < nely; k++) \
                   result(i+k) = x(i) OP y(k); \
               else \
                 result(i) = x(i) OP y(i); \
  \
               retval = result; \
           } \
         else \
-          error ("%s: size of x and y must match, or one operand must be a scalar", FNAME); \
+          error ("%s: size of X and Y must match, or one operand must be a scalar", FNAME); \
       }
 
 #define BITOP(OP, FNAME) \
  \
   octave_value retval; \
  \
   int nargin = args.length (); \
  \
@@ -368,17 +368,17 @@ bitshift (float a, int n, int64_t mask)
                     result(i) = bitshift (m(i), static_cast<int> (n(i)), mask); \
  \
               retval = result; \
             } \
           else \
             error ("bitshift: size of A and N must match, or one operand must be a scalar"); \
         } \
       else \
-        error ("bitshift: expecting second argument to be integer"); \
+        error ("bitshift: expecting integer as second argument"); \
     }
 
 #define DO_UBITSHIFT(T, N) \
   do \
     { \
       int bits_in_type = octave_ ## T :: nbits (); \
       T ## NDArray m = m_arg.T ## _array_value (); \
         octave_ ## T mask = octave_ ## T::max (); \
@@ -451,25 +451,25 @@ bitshift (10, [-2, -1, 0, 1, 2])\n\
         error ("bitshift: expecting integer as second argument");
       else
         {
           if (nargin == 3)
             {
               // FIXME -- for compatibility, we should accept an array
               // or a scalar as the third argument.
               if (args(2).numel () > 1)
-                error ("bitshift: expecting scalar integer as third argument");
+                error ("bitshift: N must be a scalar integer");
               else
                 {
                   nbits = args(2).int_value ();
 
                   if (error_state)
-                    error ("bitshift: expecting integer as third argument");
+                    error ("bitshift: N must be an integer");
                   else if (nbits < 0)
-                    error ("bitshift: number of bits to mask must be positive");
+                    error ("bitshift: N must be positive");
                 }
             }
         }
 
       if (error_state)
         return retval;
 
       octave_value m_arg = args(0);
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -1251,33 +1251,33 @@ Given a matrix argument, instead of a ve
 
   if (nargin == 1 && args(0).is_defined ())
     retval = args(0).diag();
   else if (nargin == 2 && args(0).is_defined () && args(1).is_defined ())
     {
       octave_idx_type k = args(1).int_value ();
 
       if (error_state)
-        error ("diag: invalid second argument");
+        error ("diag: invalid argument K");
       else
         retval = args(0).diag(k);
     }
   else if (nargin == 3)
     {
       octave_value arg0 = args(0);
       if (arg0.ndims () == 2 && (args(0).rows () == 1 || args(0).columns () == 1))
         {
           octave_idx_type m = args(1).int_value (), n = args(2).int_value ();
           if (! error_state)
             retval = arg0.diag ().resize (dim_vector (m, n));
           else
             error ("diag: invalid dimensions");
         }
       else
-        error ("diag: first argument must be a vector");
+        error ("diag: V must be a vector");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -1745,20 +1745,20 @@ cat (4, ones(2, 2), zeros (2, 2))\n\
     {
       int dim = args(0).int_value () - 1;
 
       if (! error_state)
         {
           if (dim >= 0)
             retval = do_cat (args.slice (1, args.length () - 1), dim, "cat");
           else
-            error ("cat: invalid dimension specified");
+            error ("cat: DIM must be a valid dimension");
         }
       else
-        error ("cat: expecting first argument to be a integer");
+        error ("cat: DIM must be an integer");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -2099,30 +2099,30 @@ returns the number of columns in the giv
           retval(0) = m;
         }
     }
   else if (nargin == 2 && nargout < 2)
     {
       octave_idx_type nd = args(1).int_value (true);
 
       if (error_state)
-        error ("size: expecting scalar as second argument");
+        error ("size: DIM must be a scalar");
       else
         {
           const dim_vector dv = args(0).dims ();
 
           if (nd > 0)
             {
               if (nd <= dv.length ())
                 retval(0) = dv(nd-1);
               else
                 retval(0) = 1;
             }
           else
-            error ("size: requested dimension (= %d) out of range", nd);
+            error ("size: requested dimension DIM (= %d) out of range", nd);
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
@@ -2298,17 +2298,17 @@ than straightforward summation is to be 
     {
       octave_value arg = args(0);
 
       int dim = -1;
       if (nargin == 2)
         {
           dim = args(1).int_value () - 1;
           if (dim < 0)
-            error ("sum: invalid dimension argument = %d", dim + 1);
+            error ("sum: invalid dimension DIM = %d", dim + 1);
         }
 
       if (! error_state)
         {
           switch (arg.builtin_type ())
             {
             case btyp_double:
               if (arg.is_sparse_type ())
@@ -4305,17 +4305,17 @@ fewer than two values are requested.\n\
         {
           if (arg_1.is_complex_type () || arg_2.is_complex_type ())
             retval = do_linspace<ComplexMatrix> (arg_1, arg_2, npoints);
           else
             retval = do_linspace<Matrix> (arg_1, arg_2, npoints);
         }
     }
   else
-    error ("linspace: expecting third argument to be an integer");
+    error ("linspace: N must be an integer");
 
   return retval;
 }
 
 
 /*
 
 %!test
@@ -4464,17 +4464,17 @@ by an empty argument.\n\
       Array<octave_idx_type> new_size = args(1).octave_idx_type_vector_value ();
 
       new_dims = dim_vector::alloc (new_size.length ());
 
       for (octave_idx_type i = 0; i < new_size.length (); i++)
         {
           if (new_size(i) < 0)
             {
-              error ("reshape: size must be nonnegative");
+              error ("reshape: SIZE must be non-negative");
               break;
             }
           else
             new_dims(i) = new_size(i);
         }
     }
   else if (nargin > 2)
     {
@@ -4499,17 +4499,17 @@ by an empty argument.\n\
           else
             {
               new_dims(i-1) = args(i).idx_type_value ();
 
               if (error_state)
                 break;
               else if (new_dims(i-1) < 0)
                 {
-                  error ("reshape: size must be nonnegative");
+                  error ("reshape: SIZE must be non-negative");
                   break;
                 }
             }
         }
 
       if (! error_state && (empty_dim > 0))
         {
           octave_idx_type nel = new_dims.numel ();
@@ -4517,17 +4517,17 @@ by an empty argument.\n\
           if (nel == 0)
             new_dims(empty_dim-1) = 0;
           else
             {
               octave_idx_type a_nel = args(0).numel ();
               octave_idx_type size_empty_dim = a_nel / nel;
 
               if (a_nel != size_empty_dim * nel)
-                error ("reshape: size is not divisible by the product of known dimensions (= %d)", nel);
+                error ("reshape: SIZE is not divisible by the product of known dimensions (= %d)", nel);
               else
                 new_dims(empty_dim-1) = size_empty_dim;
             }
         }
     }
   else
     {
       print_usage ();
@@ -4580,17 +4580,17 @@ This is equivalent to @code{shiftdim (@v
   if (nargin < 1 || nargin > 2)
     print_usage () ;
 
   if (! error_state && nargin == 2)
     {
       dim = args(1).idx_type_value ();
 
       if (dim < 1)
-        error ("vec: dim must greater than zero");
+        error ("vec: DIM must be greater than zero");
     }
 
   if (! error_state)
     {
       octave_value colon (octave_value::magic_colon_t);
       octave_value arg = args(0);
       retval = arg.single_subsref ("(", colon);
 
@@ -5477,17 +5477,17 @@ ordered lists.\n\
         {
           std::string mode = args(1).string_value();
           if (mode == "ascend")
             smode = ASCENDING;
           else if (mode == "descend")
             smode = DESCENDING;
           else
             {
-              error ("sort: mode must be either \"ascend\" or \"descend\"");
+              error ("sort: MODE must be either \"ascend\" or \"descend\"");
               return retval;
             }
         }
       else
         dim = args(1).nint_value () - 1;
     }
 
   if (nargin > 2)
@@ -5495,42 +5495,42 @@ ordered lists.\n\
       if (args(1).is_string ())
         {
           print_usage ();
           return retval;
         }
 
       if (! args(2).is_string ())
         {
-          error ("sort: mode must be a string");
+          error ("sort: MODE must be a string");
           return retval;
         }
       std::string mode = args(2).string_value();
       if (mode == "ascend")
         smode = ASCENDING;
       else if (mode == "descend")
         smode = DESCENDING;
       else
         {
-          error ("sort: mode must be either \"ascend\" or \"descend\"");
+          error ("sort: MODE must be either \"ascend\" or \"descend\"");
           return retval;
         }
     }
 
   const dim_vector dv = arg.dims ();
   if (nargin == 1 || args(1).is_string ())
     {
       // Find first non singleton dimension
       dim = dv.first_non_singleton ();
     }
   else
     {
       if (dim < 0)
         {
-          error ("sort: dim must be a valid dimension");
+          error ("sort: DIM must be a valid dimension");
           return retval;
         }
     }
 
   if (return_idx)
     {
       Array<octave_idx_type> sidx;
 
@@ -5747,17 +5747,17 @@ Undocumented internal function.\n\
     {
       std::string mode = args(1).string_value();
       if (mode == "ascend")
         smode = ASCENDING;
       else if (mode == "descend")
         smode = DESCENDING;
       else
         {
-          error ("__sort_rows_idx__: mode must be either \"ascend\" or \"descend\"");
+          error ("__sort_rows_idx__: MODE must be either \"ascend\" or \"descend\"");
           return retval;
         }
     }
 
   octave_value arg = args(0);
 
   if (arg.is_sparse_type ())
     error ("__sort_rows_idx__: sparse matrices not yet supported");
@@ -5787,17 +5787,17 @@ get_sort_mode_option (const octave_value
     error ("issorted: expecting %s argument to be a character string", argn);
   else if (mode == "ascending")
     smode = ASCENDING;
   else if (mode == "descending")
     smode = DESCENDING;
   else if (mode == "either")
     smode = UNSORTED;
   else
-    error ("issorted: expecting MODE to be \"ascending\", \"descending\", or \"either\"");
+    error ("issorted: MODE must be \"ascending\", \"descending\", or \"either\"");
 
   return smode;
 }
 
 DEFUN (issorted, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} issorted (@var{a}, @var{mode})\n\
 @deftypefnx {Built-in Function} {} issorted (@var{a}, @code{\"rows\"}, @var{mode})\n\
@@ -5855,17 +5855,17 @@ This function does not support sparse ma
 
   if (by_rows)
     {
       if (arg.is_sparse_type ())
         error ("issorted: sparse matrices not yet supported");
       if (arg.ndims () == 2)
         retval = arg.is_sorted_rows (smode) != UNSORTED;
       else
-        error ("issorted: needs a 2-dimensional object");
+        error ("issorted: A must be a 2-dimensional object");
     }
   else
     {
       if (arg.dims ().is_vector ())
         retval = args(0).is_sorted (smode) != UNSORTED;
       else
         error ("issorted: needs a vector");
     }
@@ -5935,17 +5935,17 @@ it may be better to use @code{sort}.\n\
     {
       octave_value argx = args(0);
 
       int dim = -1;
       if (nargin == 3)
         {
           dim = args(2).int_value (true) - 1;
           if (dim < 0)
-            error ("nth_element: dim must be a valid dimension");
+            error ("nth_element: DIM must be a valid dimension");
         }
       if (dim < 0)
         dim = argx.dims ().first_non_singleton ();
 
       idx_vector n = args(1).index_vector ();
 
       if (error_state)
         return retval;
@@ -6255,17 +6255,17 @@ do_merge (const Array<bool>& mask,
   typedef typename NDT::element_type T;
   dim_vector dv = mask.dims ();
   NDT retval (dv);
 
   bool tscl = tval.numel () == 1, fscl = fval.numel () == 1;
 
   if ((! tscl && tval.dims () != dv)
       || (! fscl && fval.dims () != dv))
-    error ("merge: dimensions mismatch");
+    error ("merge: MASK, TVAL, and FVAL dimensions must match");
   else
     {
       T *rv = retval.fortran_vec ();
       octave_idx_type n = retval.numel ();
 
       const T *tv = tval.data (), *fv = fval.data ();
       const bool *mv = mask.data ();
 
@@ -6575,26 +6575,26 @@ then an empty matrix is returned.\n\
     {
       int dim = -1;
       octave_idx_type order = 1;
       if (nargin > 1)
         {
           if (args(1).is_scalar_type ())
             order = args(1).idx_type_value (true, false);
           else if (! args(1).is_zero_by_zero ())
-            error ("order must be a scalar or []");
+            error ("order K must be a scalar or []");
           if (! error_state && order < 0)
-            error ("order must be non-negative");
+            error ("order K must be non-negative");
         }
 
       if (nargin > 2)
         {
           dim = args(2).int_value (true, false);
           if (! error_state && (dim < 1 || dim > args(0).ndims ()))
-            error ("needs a valid dimension");
+            error ("DIM must be a valid dimension");
           else
             dim -= 1;
         }
 
       if (! error_state)
         retval = do_diff (args(0), order, dim);
     }
 
@@ -6628,17 +6628,17 @@ do_repelems (const Array<T>& src, const 
   assert (rep.ndims () == 2 && rep.rows () == 2);
 
   octave_idx_type n = rep.columns (), l = 0;
   for (octave_idx_type i = 0; i < n; i++)
     {
       octave_idx_type k = rep(1, i);
       if (k < 0)
         {
-          error ("repelems: second row must contain nonnegative numbers");
+          error ("repelems: second row must contain non-negative numbers");
           return retval;
         }
 
       l += k;
     }
 
   retval.clear (1, l);
   T *dest = retval.fortran_vec ();
@@ -6685,29 +6685,29 @@ endfor\n\
     {
       octave_value x = args(0);
 
       const Matrix rm = args(1).matrix_value ();
       if (error_state)
         return retval;
       else if (rm.rows () != 2 || rm.ndims () != 2)
         {
-          error ("repelems: second argument must be a matrix with two rows");
+          error ("repelems: R must be a matrix with two rows");
           return retval;
         }
       else
         {
           NoAlias< Array<octave_idx_type> > r (rm.dims ());
 
           for (octave_idx_type i = 0; i < rm.numel (); i++)
             {
               octave_idx_type rx = rm(i);
               if (static_cast<double> (rx) != rm(i))
                 {
-                  error ("repelems: a matrix of integers is expected");
+                  error ("repelems: R must be a matrix of integers");
                   return retval;
                 }
 
               r(i) = rx;
             }
 
           switch (x.builtin_type ())
             {
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -961,17 +961,17 @@ location of the error.  Typically @var{e
                               else
                                 pr_where_1 ("error: called from `%d' in file %s near line %d", nm.c_str (), file.c_str (), l);
                             }
                         }
                     }
                 }
             }
           else
-            error ("rethrow: structure must contain the fields 'message and 'identifier'");
+            error ("rethrow: ERR structure must contain the fields 'message and 'identifier'");
         }
     }
   return retval;
 }
 
 DEFUN (error, args, ,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {} error (@var{template}, @dots{})\n\
diff --git a/src/file-io.cc b/src/file-io.cc
--- a/src/file-io.cc
+++ b/src/file-io.cc
@@ -888,17 +888,17 @@ If @var{fid} is omitted, the output is w
 
                   for (int i = fmt_n + 1; i < nargin; i++)
                     tmp_args(i-fmt_n-1) = args(i);
                 }
 
               result = os.printf (args(fmt_n), tmp_args, who);
             }
           else
-            ::error ("%s: format must be a string", who.c_str ());
+            ::error ("%s: format TEMPLATE must be a string", who.c_str ());
         }
     }
   else
     print_usage ();
 
   if (nargout > 0)
     retval = result;
 
@@ -939,17 +939,17 @@ complete description of the syntax of th
 
               for (int i = 1; i < nargin; i++)
                 tmp_args(i-1) = args(i);
             }
 
           result = stdout_stream.printf (args(0), tmp_args, who);
         }
       else
-        ::error ("%s: format must be a string", who.c_str ());
+        ::error ("%s: format TEMPLATE must be a string", who.c_str ());
     }
   else
     print_usage ();
 
   if (nargout > 0)
     retval = result;
 
   return retval;
@@ -1047,17 +1047,17 @@ converted.\n\
                 }
 
               retval(2) = os.printf (fmt_arg, tmp_args, who);
               retval(1) = os.error ();
               retval(0) = octave_value (ostr->str (),
                                         fmt_arg.is_sq_string () ? '\'' : '"');
             }
           else
-            ::error ("%s: format must be a string", who.c_str ());
+            ::error ("%s: format TEMPLATE must be a string", who.c_str ());
         }
       else
         ::error ("%s: unable to create output buffer", who.c_str ());
     }
   else
     print_usage ();
 
   return retval;
@@ -1122,17 +1122,17 @@ complete description of the syntax of th
     {
       octave_stream os = octave_stream_list::lookup (args(0), who);
 
       if (! error_state)
         {
           if (args(1).is_string ())
             retval = os.oscanf (args(1), who);
           else
-            ::error ("%s: format must be a string", who.c_str ());
+            ::error ("%s: format TEMPLATE must be a string", who.c_str ());
         }
     }
   else
     {
       retval (1) = 0.0;
       retval (0) = Matrix ();
 
       if (nargin == 2 || nargin == 3)
@@ -1195,24 +1195,24 @@ string is treated as an end-of-file cond
 
           octave_stream os = octave_istrstream::create (data);
 
           if (os.is_valid ())
             {
               if (args(1).is_string ())
                 retval = os.oscanf (args(1), who);
               else
-                ::error ("%s: format must be a string", who.c_str ());
+                ::error ("%s: format TEMPLATE must be a string", who.c_str ());
             }
           else
             ::error ("%s: unable to create temporary input buffer",
                      who.c_str ());
         }
       else
-        ::error ("%s: first argument must be a string", who.c_str ());
+        ::error ("%s: argument STRING must be a string", who.c_str ());
     }
   else
     {
       if (nargin == 2 || nargin == 3)
         {
           retval(3) = -1.0;
           retval(2) = "unknown error";
           retval(1) = 0.0;
@@ -1246,24 +1246,24 @@ string is treated as an end-of-file cond
 
                           retval(3) = os.tell () + 1;
                           retval(2) = errmsg;
                           retval(1) = count;
                           retval(0) = tmp;
                         }
                     }
                   else
-                    ::error ("%s: format must be a string", who.c_str ());
+                    ::error ("%s: format TEMPLATE must be a string", who.c_str ());
                 }
               else
                 ::error ("%s: unable to create temporary input buffer",
                          who.c_str  ());
             }
           else
-            ::error ("%s: first argument must be a string", who.c_str ());
+            ::error ("%s: argument STRING must be a string", who.c_str ());
         }
       else
         print_usage ();
     }
 
   return retval;
 }
 
@@ -1326,29 +1326,29 @@ do_fread (octave_stream& os, const octav
                       oct_mach_info::float_format flt_fmt
                         = oct_mach_info::string_to_float_format (arch);
 
                       if (! error_state)
                         retval = os.read (size, block_size, input_type,
                                           output_type, skip, flt_fmt, count);
                     }
                   else
-                    ::error ("fread: architecture type must be a string");
+                    ::error ("fread: ARCH architecture type must be a string");
                 }
               else
-                ::error ("fread: skip must be an integer");
+                ::error ("fread: SKIP must be an integer");
             }
           else
-            ::error ("fread: invalid data type specified");
+            ::error ("fread: invalid PRECISION specified");
         }
       else
-        ::error ("fread: precision must be a string");
+        ::error ("fread: PRECISION must be a string");
     }
   else
-    ::error ("fread: invalid size specified");
+    ::error ("fread: invalid SIZE specified");
 
   return retval;
 }
 
 DEFUN (fread, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {[@var{val}, @var{count}] =} fread (@var{fid}, @var{size}, @var{precision}, @var{skip}, @var{arch})\n\
 Read binary data of type @var{precision} from the specified file ID\n\
@@ -1603,26 +1603,26 @@ do_fwrite (octave_stream& os, const octa
                   oct_mach_info::float_format flt_fmt
                     = oct_mach_info::string_to_float_format (arch);
 
                   if (! error_state)
                     retval = os.write (data, block_size, output_type,
                                        skip, flt_fmt);
                 }
               else
-                ::error ("fwrite: architecture type must be a string");
+                ::error ("fwrite: ARCH architecture type must be a string");
             }
           else
-            ::error ("fwrite: skip must be an integer");
+            ::error ("fwrite: SKIP must be an integer");
         }
       else
-        ::error ("fwrite: invalid precision specified");
+        ::error ("fwrite: invalid PRECISION specified");
     }
   else
-    ::error ("fwrite: precision must be a string");
+    ::error ("fwrite: PRECISION must be a string");
 
   return retval;
 }
 
 DEFUN (fwrite, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {@var{count} =} fwrite (@var{fid}, @var{data}, @var{precision}, @var{skip}, @var{arch})\n\
 Write data in binary form of type @var{precision} to the specified file\n\
@@ -1813,23 +1813,23 @@ endwhile\n\
                 }
               else if (mode == "w")
                 {
                   octave_stream ops = octave_oprocstream::create (name);
 
                   retval = octave_stream_list::insert (ops);
                 }
               else
-                ::error ("popen: invalid mode specified");
+                ::error ("popen: invalid MODE specified");
             }
           else
-            ::error ("popen: mode must be a string");
+            ::error ("popen: MODE must be a string");
         }
       else
-        ::error ("popen: name must be a string");
+        ::error ("popen: COMMAND must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (pclose, args, ,
@@ -1878,20 +1878,20 @@ that it will not be available by the tim
       if (! error_state)
         {
           std::string pfx
             = len > 1 ? args(1).string_value () : std::string ("oct-");
 
           if (! error_state)
             retval = octave_tempnam (dir, pfx);
           else
-            ::error ("expecting second argument to be a string");
+            ::error ("PREFIX must be a string");
         }
       else
-        ::error ("expecting first argument to be a string");
+        ::error ("DIR argument must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (octave_tmp_file_name, tmpnam);
@@ -2021,17 +2021,17 @@ error message.\n\
               else
                 {
                   retval(2) = gnulib::strerror (errno);
                   retval(0) = -1;
                 }
             }
         }
       else
-        error ("mkstemp: expecting string as first argument");
+        error ("mkstemp: TEMPLATE argument must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 static int
@@ -2093,17 +2093,17 @@ interpreted as an octal number); otherwi
 
               if (! error_state)
                 status = convert (octave_umask (oct_mask), 10, 8);
             }
         }
       else
         {
           status = -1;
-          ::error ("umask: expecting integer argument");
+          ::error ("umask: MASK must be an integer");
         }
     }
   else
     print_usage ();
 
   if (status >= 0)
     retval(0) = status;
 
diff --git a/src/graphics.cc b/src/graphics.cc
--- a/src/graphics.cc
+++ b/src/graphics.cc
@@ -7679,26 +7679,26 @@ undocumented.\n\
                                 .print_figure (go, term, file, mono, debug_file);
 
                               gh_manager::lock ();
                             }
                           else
                             error ("drawnow: nothing to draw");
                         }
                       else
-                        error ("drawnow: invalid debug_file, expected a string value");
+                        error ("drawnow: invalid DEBUG_FILE, expected a string value");
                     }
                   else
-                    error ("drawnow: invalid colormode, expected a boolean value");
+                    error ("drawnow: invalid colormode MONO, expected a boolean value");
                 }
               else
-                error ("drawnow: invalid file, expected a string value");
+                error ("drawnow: invalid FILE, expected a string value");
             }
           else
-            error ("drawnow: invalid terminal, expected a string value");
+            error ("drawnow: invalid terminal TERM, expected a string value");
         }
       else
         print_usage ();
     }
 
   gh_manager::unlock ();
 
   return retval;
@@ -7945,26 +7945,26 @@ addproperty (\"my_style\", gcf, \"lineli
                           if (! error_state)
                             go.get_properties ().insert_property (name, p);
                         }
                       else
                         error ("addproperty: a `%s' property already exists in the graphics object",
                                name.c_str ());
                     }
                   else
-                    error ("addproperty: invalid property type, expected a string value");
+                    error ("addproperty: invalid property TYPE, expected a string value");
                 }
               else
                 error ("addproperty: invalid graphics object (= %g)", h);
             }
           else
             error ("addproperty: invalid handle value");
         }
       else
-        error ("addproperty: invalid property name, expected a string value");
+        error ("addproperty: invalid property NAME, expected a string value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 octave_value
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -1035,17 +1035,17 @@ Undocumented internal function.\n\
               // .m and .oct versions of the same function in a given
               // directory, for example).
               fl.sort (true);
 
               retval = Cell (fl);
             }
         }
       else
-        error ("__list_functions__: input must be a string");
+        error ("__list_functions__: DIRECTORY argument must be a string");
     }
 
   return retval;
 }
 
 DEFUN (doc_cache_file, args, nargout,
   "-*- texinfo -*-\n\
 @deftypefn  {Built-in Function} {@var{val} =} doc_cache_file ()\n\
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -927,17 +927,17 @@ RET and can edit it until it has been co
       std::string prompt;
 
       if (nargin == 1)
         {
           prompt = args(0).string_value ();
 
           if (error_state)
             {
-              error ("yes_or_no: expecting argument to be character string");
+              error ("yes_or_no: PROMPT must be a character string");
               return retval;
             }
         }
 
       retval = octave_yes_or_no (prompt);
     }
   else
     print_usage ();
diff --git a/src/load-path.cc b/src/load-path.cc
--- a/src/load-path.cc
+++ b/src/load-path.cc
@@ -1966,17 +1966,17 @@ exclude directories with those names.\n\
 
   if (nargin == 1)
     {
       std::string dirname = args(0).string_value ();
 
       if (! error_state)
         retval = genpath (dirname);
       else
-        error ("genpath: expecting argument to be a character string");
+        error ("genpath: DIR must be a character string");
     }
   else if (nargin > 1)
     {
       std::string dirname = args(0).string_value ();
 
       string_vector skip (nargin - 1);
 
       for (octave_idx_type i = 1; i < nargin; i++)
@@ -1985,17 +1985,17 @@ exclude directories with those names.\n\
 
           if (error_state)
             break;
         }
 
       if (! error_state)
         retval = genpath (dirname, skip);
       else
-        error ("genpath: expecting all arguments to be character strings");
+        error ("genpath: all arguments must be character strings");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 static void
@@ -2216,17 +2216,17 @@ addpath (\"dir1:/dir2:~/dir3\");\n\
                     load_path::append (dir, true);
                   else
                     load_path::prepend (dir, true);
 
                   need_to_update = true;
                 }
             }
           else
-            error ("addpath: expecting all args to be character strings");
+            error ("addpath: all arguments must be character strings");
         }
 
       if (need_to_update)
         rehash_internal ();
     }
   else
     print_usage ();
 
@@ -2280,17 +2280,17 @@ rmpath (\"dir1:/dir2:~/dir3\");\n\
 
                   if (! load_path::remove (dir))
                     warning ("rmpath: %s: not found", dir.c_str ());
                   else
                     need_to_update = true;
                 }
             }
           else
-            error ("addpath: expecting all args to be character strings");
+            error ("addpath: all arguments must be character strings");
         }
 
       if (need_to_update)
         rehash_internal ();
     }
   else
     print_usage ();
 
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -850,17 +850,17 @@ Force Octave to assume the file is in Oc
 
                   retval = do_load (file, orig_fname, format,
                                     flt_fmt, list_only, swap, verbose,
                                     argv, i, argc, nargout);
 
                   file.close ();
                 }
               else
-                error ("load: unable open input file `%s'",
+                error ("load: unable to open input file `%s'",
                        orig_fname.c_str ());
             }
         }
     }
 
   return retval;
 }
 
diff --git a/src/oct-parse.yy b/src/oct-parse.yy
--- a/src/oct-parse.yy
+++ b/src/oct-parse.yy
@@ -4264,17 +4264,17 @@ another function for the given type sign
 
           if (fcn.is_defined ())
             retval = feval (fcn.function_value (), args.splice (0, 1),
                             nargout);
           else
             error ("builtin: lookup for symbol `%s' failed", name.c_str ());
         }
       else
-        error ("builtin: expecting function name as first argument");
+        error ("builtin: function name (F) must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 octave_value_list
@@ -4604,37 +4604,37 @@ may be either @code{\"base\"} or @code{\
         {
           unwind_protect frame;
 
           if (context == "caller")
             octave_call_stack::goto_caller_frame ();
           else if (context == "base")
             octave_call_stack::goto_base_frame ();
           else
-            error ("assignin: context must be \"caller\" or \"base\"");
+            error ("assignin: CONTEXT must be \"caller\" or \"base\"");
 
           if (! error_state)
             {
               frame.add_fcn (octave_call_stack::pop);
 
               std::string nm = args(1).string_value ();
 
               if (! error_state)
                 {
                   if (valid_identifier (nm))
                     symbol_table::varref (nm) = args(2);
                   else
-                    error ("assignin: invalid variable name");
+                    error ("assignin: invalid variable name in argument VARNAME");
                 }
               else
-                error ("assignin: expecting variable name as second argument");
+                error ("assignin: VARNAME must be a string");
             }
         }
       else
-        error ("assignin: expecting string as first argument");
+        error ("assignin: CONTEXT must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (evalin, args, nargout,
@@ -4657,17 +4657,17 @@ context @var{context}, which may be eith
         {
           unwind_protect frame;
 
           if (context == "caller")
             octave_call_stack::goto_caller_frame ();
           else if (context == "base")
             octave_call_stack::goto_base_frame ();
           else
-            error ("evalin: context must be \"caller\" or \"base\"");
+            error ("evalin: CONTEXT must be \"caller\" or \"base\"");
 
           if (! error_state)
             {
               frame.add_fcn (octave_call_stack::pop);
 
               if (nargin > 2)
                 {
                   frame.protect_var (buffer_error_messages);
@@ -4694,17 +4694,17 @@ context @var{context}, which may be eith
                   tmp = eval_string (args(2), nargout > 0,
                                      parse_status, nargout);
 
                   retval = (nargout > 0) ? tmp : octave_value_list ();
                 }
             }
         }
       else
-        error ("evalin: expecting string as first argument");
+        error ("evalin: CONTEXT must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (__parser_debug_flag__, args, nargout,
diff --git a/src/ov-base.cc b/src/ov-base.cc
--- a/src/ov-base.cc
+++ b/src/ov-base.cc
@@ -926,17 +926,17 @@ octave_base_value::scalar_map_value (voi
 {
   octave_map tmp = map_value ();
 
   if (tmp.numel () == 1)
     return tmp.checkelem (0);
   else
     {
       if (! error_state)
-        error ("invalid conversion of multidimensional struct to scalar struct");
+        error ("invalid conversion of multi-dimensional struct to scalar struct");
 
       return octave_scalar_map ();
     }
 }
 
 string_vector
 octave_base_value::map_keys (void) const
 {
diff --git a/src/ov-cell.cc b/src/ov-cell.cc
--- a/src/ov-cell.cc
+++ b/src/ov-cell.cc
@@ -533,17 +533,17 @@ octave_cell::is_sorted (sortmode mode) c
 
   if (is_cellstr ())
     {
       Array<std::string> tmp = cellstr_value ();
 
       retval = tmp.is_sorted (mode);
     }
   else
-    error ("issorted: not a cell array of strings");
+    error ("issorted: A is not a cell array of strings");
 
   return retval;
 }
 
 
 Array<octave_idx_type>
 octave_cell::sort_rows_idx (sortmode mode) const
 {
@@ -568,17 +568,17 @@ octave_cell::is_sorted_rows (sortmode mo
 
   if (is_cellstr ())
     {
       Array<std::string> tmp = cellstr_value ();
 
       retval = tmp.is_sorted_rows (mode);
     }
   else
-    error ("issorted: not a cell array of strings");
+    error ("issorted: A is not a cell array of strings");
 
   return retval;
 }
 
 bool
 octave_cell::is_true (void) const
 {
   error ("invalid conversion from cell array to logical value");
@@ -1370,17 +1370,17 @@ array @var{string}.\n\
         {
           string_vector s = args(0).all_strings ();
 
           if (! error_state)
             retval = (s.is_empty ()
                       ? Cell (octave_value (std::string ()))
                       : Cell (s, true));
           else
-            error ("cellstr: expecting argument to be a 2-d character array");
+            error ("cellstr: argument STRING must be a 2-D character array");
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
@@ -1455,17 +1455,17 @@ cell array will have a dimension vector 
           // we don't need a key lookup at all.
           for (octave_idx_type j = 0; j < n_elts; j++)
             for (octave_idx_type i = 0; i < num_fields; i++)
               c(i,j) = m.contents(i)(j);
 
           retval = c;
         }
       else
-        error ("struct2cell: expecting argument to be a cell array");
+        error ("struct2cell: argument S must be a structure");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/src/ov-class.cc b/src/ov-class.cc
--- a/src/ov-class.cc
+++ b/src/ov-class.cc
@@ -1692,17 +1692,17 @@ octave_class::exemplar_info::exemplar_in
   if (obj.is_object ())
     {
       octave_map m = obj.map_value ();
       field_names = m.keys ();
 
       parent_class_names = obj.parent_class_name_list ();
     }
   else
-    error ("invalid call to exmplar_info constructor");
+    error ("invalid call to exemplar_info constructor");
 }
 
 
 // A map from class names to lists of fields.
 std::map<std::string, octave_class::exemplar_info> octave_class::exemplar_map;
 
 bool
 octave_class::exemplar_info::compare (const octave_value& obj) const
@@ -1821,27 +1821,27 @@ derived.\n\
                             octave_class::exemplar_map[id]
                               = octave_class::exemplar_info (retval);
                           else if (! it->second.compare (retval))
                             error ("class: object of class `%s' does not match previously constructed objects",
                                    id.c_str ());
                         }
                     }
                   else
-                    error ("class: expecting structure as first argument");
+                    error ("class: expecting structure S as first argument");
                 }
               else
                 error ("class: `%s' is invalid as a class name in this context",
                        id.c_str ());
             }
           else
             error ("class: invalid call from outside class constructor or method");
         }
       else
-        error ("class: expecting character string as second argument");
+        error ("class: ID (class name) must be a character string");
     }
 
   return retval;
 }
 
 DEFUN (__isa_parent__, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} __isa_parent__ (@var{class}, @var{name})\n\
diff --git a/src/ov-fcn-handle.cc b/src/ov-fcn-handle.cc
--- a/src/ov-fcn-handle.cc
+++ b/src/ov-fcn-handle.cc
@@ -1641,20 +1641,20 @@ Return a struct containing information a
                   m.setfield ("file", fu->fcn_file_name ());
                 }
               else
                 m.setfield ("file", "");
 
               retval = m;
             }
           else
-            error ("functions: invalid function handle object");
+            error ("functions: FCN_HANDLE is not a valid function handle object");
         }
       else
-        error ("functions: argument must be a function handle object");
+        error ("functions: FCN_HANDLE argument must be a function handle object");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (func2str, args, ,
@@ -1681,17 +1681,17 @@ the function handle @var{fcn_handle}.\n\
               fh->print_raw (buf);
 
               retval = buf.str ();
             }
           else
             retval = fh_nm;
         }
       else
-        error ("func2str: expecting valid function handle as first argument");
+        error ("func2str: FCN_HANDLE must be a valid function handle");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (str2func, args, ,
@@ -1708,17 +1708,17 @@ are ignored in the lookup.\n\
 
   if (nargin == 1 || nargin == 2)
     {
       std::string nm = args(0).string_value ();
 
       if (! error_state)
         retval = make_fcn_handle (nm, nargin != 2);
       else
-        error ("str2func: expecting string as first argument");
+        error ("str2func: FCN_NAME must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
diff --git a/src/ov-fcn-inline.cc b/src/ov-fcn-inline.cc
--- a/src/ov-fcn-inline.cc
+++ b/src/ov-fcn-inline.cc
@@ -758,23 +758,23 @@ If the second argument is an integer @va
                         {
                           std::ostringstream buf;
                           buf << "P" << i;
                           fargs(i) = buf.str ();
                         }
                     }
                   else
                     {
-                      error ("inline: numeric argument must be nonnegative");
+                      error ("inline: N must be positive or zero");
                       return retval;
                     }
                 }
               else
                 {
-                  error ("inline: expecting second argument to be an integer");
+                  error ("inline: N must be an integer");
                   return retval;
                 }
             }
           else
             {
               fargs.resize (nargin - 1);
 
               for (int i = 1; i < nargin; i++)
@@ -789,17 +789,17 @@ If the second argument is an integer @va
                       return retval;
                     }
                 }
             }
 
           retval = octave_value (new octave_fcn_inline (fun, fargs));
         }
       else
-        error ("inline: first argument must be a string");
+        error ("inline: STR argument must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -824,17 +824,17 @@ Note that @code{char (@var{fun})} is equ
 
   if (nargin == 1)
     {
       octave_fcn_inline* fn = args(0).fcn_inline_value (true);
 
       if (fn)
         retval = octave_value (fn->fcn_text ());
       else
-        error ("formula: must be an inline function");
+        error ("formula: FUN must be an inline function");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (argnames, args, ,
@@ -860,17 +860,17 @@ the arguments of the inline function @va
           Cell t2 (dim_vector (t1.length (), 1));
 
           for (int i = 0; i < t1.length (); i++)
             t2(i) = t1(i);
 
           retval = t2;
         }
       else
-        error ("argnames: argument must be an inline function");
+        error ("argnames: FUN must be an inline function");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (vectorize, args, ,
diff --git a/src/ov-flt-re-mat.cc b/src/ov-flt-re-mat.cc
--- a/src/ov-flt-re-mat.cc
+++ b/src/ov-flt-re-mat.cc
@@ -818,17 +818,17 @@ Convert @var{x} to single precision type
             }
           else
             {
               OCTAVE_TYPE_CONV_BODY3 (single, octave_float_diag_matrix, octave_float_scalar);
             }
         }
       else if (args(0).is_sparse_type ())
         {
-          error ("single: sparse type do not support single precision");
+          error ("single: sparse type does not support single precision");
         }
       else if (args(0).is_complex_type ())
         {
           OCTAVE_TYPE_CONV_BODY3 (single, octave_float_complex_matrix, octave_float_complex);
         }
       else
         {
           OCTAVE_TYPE_CONV_BODY3 (single, octave_float_matrix, octave_float_scalar);
diff --git a/src/ov-struct.cc b/src/ov-struct.cc
--- a/src/ov-struct.cc
+++ b/src/ov-struct.cc
@@ -702,18 +702,18 @@ scalar (const dim_vector& dims)
 %!assert(struct('a',{1,2},'b',{3}),x)
 %!assert(struct('b',3,'a',{1,2}),x)
 %!assert(struct('b',{3},'a',{1,2}),x)
 %!test x=struct([]);
 %!assert(size(x),[0,0]);
 %!assert(isstruct(x));
 %!assert(isempty(fieldnames(x)));
 %!fail("struct('a',{1,2},'b',{1,2,3})","dimensions of parameter 2 do not match those of parameter 4")
-%!fail("struct(1,2,3,4)","struct expects alternating \"field\", VALUE pairs");
-%!fail("struct('1',2,'3')","struct expects alternating \"field\", VALUE pairs");
+%!fail("struct(1,2,3,4)","struct: expecting alternating \"field\", VALUE pairs");
+%!fail("struct('1',2,'3')","struct: expecting alternating \"field\", VALUE pairs");
 */
 
 bool
 octave_struct::save_ascii (std::ostream& os)
 {
   octave_map m = map_value ();
 
   octave_idx_type nf = m.nfields ();
@@ -1720,18 +1720,18 @@ octave_scalar_struct::fast_elem_insert_s
 %!assert(struct('a',{1,2},'b',{3}),x)
 %!assert(struct('b',3,'a',{1,2}),x)
 %!assert(struct('b',{3},'a',{1,2}),x)
 %!test x=struct([]);
 %!assert(size(x),[0,0]);
 %!assert(isstruct(x));
 %!assert(isempty(fieldnames(x)));
 %!fail("struct('a',{1,2},'b',{1,2,3})","dimensions of parameter 2 do not match those of parameter 4")
-%!fail("struct(1,2,3,4)","struct expects alternating \"field\", VALUE pairs");
-%!fail("struct('1',2,'3')","struct expects alternating \"field\", VALUE pairs");
+%!fail("struct(1,2,3,4)","struct: expecting alternating \"field\", VALUE pairs");
+%!fail("struct('1',2,'3')","struct: expecting alternating \"field\", VALUE pairs");
 */
 
 DEFUN (struct, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} struct (\"field\", @var{value}, \"field\", @var{value}, @dots{})\n\
 \n\
 Create a structure and initialize its value.\n\
 \n\
@@ -1785,17 +1785,17 @@ If the argument is an object, return the
     }
 
   // Check for "field", VALUE pairs.
 
   for (int i = 0; i < nargin; i += 2)
     {
       if (! args(i).is_string () || i + 1 >= nargin)
         {
-          error ("struct expects alternating \"field\", VALUE pairs");
+          error ("struct: expecting alternating \"field\", VALUE pairs");
           return retval;
         }
     }
 
   // Check that the dimensions of the values correspond.
 
   dim_vector dims (1, 1);
 
@@ -2043,35 +2043,35 @@ A(1)\n\
 @end example\n\
 @end deftypefn")
 {
   octave_value retval;
 
   if (args.length () == 3)
     {
       if (! args(0).is_cell ())
-        error ("cell2struct: first argument must be a cell");
+        error ("cell2struct: argument CELL must be of type cell");
       else if (! (args(1).is_cellstr () || args(1).is_char_matrix ()))
-        error ("cell2struct: second argument must be a cell array of strings or a character matrix");
+        error ("cell2struct: FIELDS must be a cell array of strings or a character matrix");
       else if (! args(2).is_real_scalar ())
-        error ("cell2struct: third argument must be a real scalar");
+        error ("cell2struct: DIM must be a real scalar");
       else
         {
           const Cell vals = args(0).cell_value ();
           const Array<std::string> fields = args(1).cellstr_value ();
           int dim = args(2).int_value () - 1;
           octave_idx_type ext = 0;
 
           if (dim < 0)
-            error ("cell2struct: dim must be a valid dimension");
+            error ("cell2struct: DIM must be a valid dimension");
           else
             {
               ext = vals.ndims () > dim ? vals.dims ()(dim) : 1;
               if (ext != fields.numel ())
-                error ("cell2struct: number of fields doesn't match dimension");
+                error ("cell2struct: number of FIELDS does not match dimension");
             }
 
 
           if (! error_state)
             {
               int nd = std::max (dim+1, vals.ndims ());
               // result dimensions.
               dim_vector rdv = vals.dims ().redim (nd);
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -634,17 +634,17 @@ function accepts a variable number of ar
 
                   retval = param_list ? param_list->length () : 0;
                 }
             }
           else
             error ("nargin: invalid function");
         }
       else
-        error ("nargin: expecting string as first argument");
+        error ("nargin: FCN_NAME must be a string");
     }
   else if (nargin == 0)
     {
       retval = symbol_table::varval (".nargin.");
 
       if (retval.is_undefined ())
         retval = 0;
     }
@@ -708,17 +708,17 @@ At the top level, @code{nargout} is unde
 
                   retval = ret_list ? ret_list->length () : 0;
                 }
             }
           else
             error ("nargout: invalid function");
         }
       else
-        error ("nargout: expecting string as first argument");
+        error ("nargout: FCN_NAME must be a string");
     }
   else if (nargin == 0)
     {
       if (! symbol_table::at_top_level ())
         {
           retval = symbol_table::varval (".nargout.");
 
           if (retval.is_undefined ())
@@ -753,17 +753,17 @@ static bool val_in_table (const Matrix& 
   octave_idx_type i = table.lookup (val, ASCENDING);
   return (i > 0 && table(i-1) == val);
 }
 
 static bool isargout1 (int nargout, const Matrix& ignored, double k)
 {
   if (k != xround (k) || k <= 0)
     {
-      error ("isargout: argument must be a positive integer");
+      error ("isargout: K must be a positive integer");
       return false;
     }
   else
     return (k == 1 || k <= nargout) && ! val_in_table (ignored, k);
 }
 
 DEFUN (isargout, args, ,
   "-*- texinfo -*-\n\
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -3417,17 +3417,17 @@ representing the elements of @var{x}.  B
                       lst.push_back (s.substr (n, m - n));
                       n = m + 1;
                     }
                 }
 
               retval = string_vector (lst);
             }
           else
-            error ("rats: expecting numeric input");
+            error ("rats: X must be numeric");
         }
     }
 
   return retval;
 }
 
 DEFUN (disp, args, nargout,
   "-*- texinfo -*-\n\
@@ -3504,17 +3504,17 @@ Note that the output from @code{fdisp} a
 
       if (! error_state)
         {
           std::ostream *osp = os.output_stream ();
 
           if (osp)
             args(1).print (*osp);
           else
-            error ("fdisp: stream not open for writing");
+            error ("fdisp: stream FID not open for writing");
         }
     }
   else
     print_usage ();
 
   return retval;
 }
 
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -899,17 +899,17 @@ tree_matrix::rvalue1 (int)
 
                       if (error_state)
                         goto done;
 
                       tmp3 (j++) = tmp2 (0);
                     }
                   else
                     {
-                      ::error ("cat not find overloaded horzcat function");
+                      ::error ("cannot find overloaded horzcat function");
                       goto done;
                     }
                 }
             }
 
           if (tmp.length () == 1)
             retval = tmp3 (0);
           else
@@ -920,17 +920,17 @@ tree_matrix::rvalue1 (int)
               if (fcn.is_defined ())
                 {
                   tmp2 = fcn.do_multi_index_op (1, tmp3);
 
                   if (! error_state)
                     retval = tmp2 (0);
                 }
               else
-                ::error ("cat not find overloaded vertcat function");
+                ::error ("cannot find overloaded vertcat function");
             }
         }
       else if (result_type == "double")
         {
           if (any_sparse_p)
             {
               if (all_real_p)
                 retval = do_single_type_concat<SparseMatrix> (dv, tmp);
diff --git a/src/sparse.cc b/src/sparse.cc
--- a/src/sparse.cc
+++ b/src/sparse.cc
@@ -125,24 +125,24 @@ to have a common size.\n\
      {
        octave_idx_type m = 0, n = 0;
        if (args(0).is_scalar_type () && args(1).is_scalar_type ())
          {
            m = args(0).idx_type_value ();
            n = args(1).idx_type_value ();
          }
        else
-         error ("sparse: expecting scalar dimensions");
+         error ("sparse: dimensions M,N must be scalar");
 
        if (! error_state)
          {
            if (m >= 0 && n >= 0)
              retval = SparseMatrix (m, n);
            else
-             error ("sparse: dimensions must be nonnegative");
+             error ("sparse: dimensions M,N must be positive or zero");
          }
      }
    else if (nargin >= 3)
      {
        bool summation = true;
        if (nargin > 3 && args(nargin-1).is_string ())
          {
            std::string opt = args(nargin-1).string_value ();
@@ -253,15 +253,15 @@ the function @code{nzmax}.\n\
        octave_idx_type nz = 0;
        if (nargin == 3)
          nz = args(2).idx_type_value ();
        if (error_state)
          ;
        else if (m >= 0 && n >= 0 && nz >= 0)
          retval = SparseMatrix (dim_vector (m, n), nz);
        else
-         error ("spalloc: m,n,nz must be non-negative");
+         error ("spalloc: M,N,NZ must be non-negative");
      }
    else
      print_usage ();
 
    return retval;
 }
diff --git a/src/strfns.cc b/src/strfns.cc
--- a/src/strfns.cc
+++ b/src/strfns.cc
@@ -884,17 +884,17 @@ whos ans\n\
             s.list_in_columns (buf);
           else
             {
               int width = args(1).int_value ();
 
               if (! error_state)
                 s.list_in_columns (buf, width);
               else
-                error ("list_in_columns: expecting width to be an integer");
+                error ("list_in_columns: WIDTH must be an integer");
             }
 
           retval = buf.str ();
         }
       else
         error ("list_in_columns: expecting cellstr or char array");
     }
   else
diff --git a/src/syscalls.cc b/src/syscalls.cc
--- a/src/syscalls.cc
+++ b/src/syscalls.cc
@@ -224,17 +224,17 @@ error message.\n\
 
               int status = octave_syscalls::execvp (exec_file, exec_args, msg);
 
               retval(0) = status;
               retval(1) = msg;
             }
         }
       else
-        error ("exec: first argument must be a string");
+        error ("exec: FILE must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("popen2", Fpopen2, args, ,
@@ -354,17 +354,17 @@ exit status, it will linger until Octave
                                   else
                     error (msg.c_str ());
                 }
             }
           else
             error ("popen2: arguments must be character strings");
         }
       else
-        error ("popen2: first argument must be a string");
+        error ("popen2: COMMAND argument must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -497,17 +497,17 @@ system-dependent error message.\n\
                   int status = octave_fcntl (fid, req, arg, msg);
 
                   retval(0) = status;
                   retval(1) = msg;
                 }
             }
         }
       else
-        error ("fcntl: file id, request, and argument must be integers");
+        error ("fcntl: FID, REQUEST, and ARG must be integers");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("fork", Ffork, args, ,
@@ -809,17 +809,17 @@ system-dependent error message.\n\
                 }
               else
                 error ("mkfifo: invalid MODE");
             }
           else
             error ("mkfifo: MODE must be an integer");
         }
       else
-        error ("mkfifo: file name must be a string");
+        error ("mkfifo: FILE must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("pipe", Fpipe, args, ,
@@ -1017,17 +1017,17 @@ of @var{mode} is assumed to be returned 
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
 
       if (! error_state)
         retval = file_stat::is_reg (static_cast<mode_t> (mode));
       else
-        error ("S_ISREG: invalid mode value");
+        error ("S_ISREG: invalid MODE value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISDIR", FS_ISDIR, args, ,
@@ -1042,17 +1042,17 @@ of @var{mode} is assumed to be returned 
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
 
       if (! error_state)
         retval = file_stat::is_dir (static_cast<mode_t> (mode));
       else
-        error ("S_ISDIR: invalid mode value");
+        error ("S_ISDIR: invalid MODE value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISCHR", FS_ISCHR, args, ,
@@ -1067,17 +1067,17 @@ of @var{mode} is assumed to be returned 
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
 
       if (! error_state)
         retval = file_stat::is_chr (static_cast<mode_t> (mode));
       else
-        error ("S_ISCHR: invalid mode value");
+        error ("S_ISCHR: invalid MODE value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISBLK", FS_ISBLK, args, ,
@@ -1092,17 +1092,17 @@ of @var{mode} is assumed to be returned 
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
 
       if (! error_state)
         retval = file_stat::is_blk (static_cast<mode_t> (mode));
       else
-        error ("S_ISBLK: invalid mode value");
+        error ("S_ISBLK: invalid MODE value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISFIFO", FS_ISFIFO, args, ,
@@ -1117,17 +1117,17 @@ of @var{mode} is assumed to be returned 
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
 
       if (! error_state)
         retval = file_stat::is_fifo (static_cast<mode_t> (mode));
       else
-        error ("S_ISFIFO: invalid mode value");
+        error ("S_ISFIFO: invalid MODE value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISLNK", FS_ISLNK, args, ,
@@ -1142,17 +1142,17 @@ of @var{mode} is assumed to be returned 
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
 
       if (! error_state)
         retval = file_stat::is_lnk (static_cast<mode_t> (mode));
       else
-        error ("S_ISLNK: invalid mode value");
+        error ("S_ISLNK: invalid MODE value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("S_ISSOCK", FS_ISSOCK, args, ,
@@ -1167,17 +1167,17 @@ of @var{mode} is assumed to be returned 
 
   if (args.length () == 1)
     {
       double mode = args(0).double_value ();
 
       if (! error_state)
         retval = file_stat::is_sock (static_cast<mode_t> (mode));
       else
-        error ("S_ISSOCK: invalid mode value");
+        error ("S_ISSOCK: invalid MODE value");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (gethostname, args, ,
@@ -1269,17 +1269,17 @@ system-dependent error message.\n\
           std::string msg;
 
           int status = octave_unlink (name, msg);
 
           retval(0) = status;
           retval(1) = msg;
         }
       else
-        error ("unlink: file name must be a string");
+        error ("unlink: FILE must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("waitpid", Fwaitpid, args, ,
@@ -1383,17 +1383,17 @@ child terminated normally.\n\
 #if defined (WIFEXITED)
   if (args.length () == 1)
     {
       int status = args(0).int_value ();
 
       if (! error_state)
         retval = WIFEXITED (status);
       else
-        error ("WIFEXITED: expecting integer argument");
+        error ("WIFEXITED: STATUS must be an integer");
     }
 #else
   warning ("WIFEXITED always returns false in this version of Octave");
 #endif
 
   return retval;
 }
 
@@ -1411,17 +1411,17 @@ status of the child.  This function shou
 #if defined (WEXITSTATUS)
   if (args.length () == 1)
     {
       int status = args(0).int_value ();
 
       if (! error_state)
         retval = WEXITSTATUS (status);
       else
-        error ("WEXITSTATUS: expecting integer argument");
+        error ("WEXITSTATUS: STATUS must be an integer");
     }
 #else
   warning ("WEXITSTATUS always returns false in this version of Octave");
 #endif
 
   return retval;
 }
 
@@ -1438,17 +1438,17 @@ child process was terminated by a signal
 #if defined (WIFSIGNALED)
   if (args.length () == 1)
     {
       int status = args(0).int_value ();
 
       if (! error_state)
         retval = WIFSIGNALED (status);
       else
-        error ("WIFSIGNALED: expecting integer argument");
+        error ("WIFSIGNALED: STATUS must be an integer");
     }
 #else
   warning ("WIFSIGNALED always returns false in this version of Octave");
 #endif
 
   return retval;
 }
 
@@ -1466,17 +1466,17 @@ should only be employed if @code{WIFSIGN
 #if defined (WTERMSIG)
   if (args.length () == 1)
     {
       int status = args(0).int_value ();
 
       if (! error_state)
         retval = WTERMSIG (status);
       else
-        error ("WTERMSIG: expecting integer argument");
+        error ("WTERMSIG: STATUS must be an integer");
     }
 #else
   warning ("WTERMSIG always returns false in this version of Octave");
 #endif
 
   return retval;
 }
 
@@ -1496,17 +1496,17 @@ Unix implementations (e.g., AIX, SunOS).
 #if defined (WCOREDUMP)
   if (args.length () == 1)
     {
       int status = args(0).int_value ();
 
       if (! error_state)
         retval = WCOREDUMP (status);
       else
-        error ("WCOREDUMP: expecting integer argument");
+        error ("WCOREDUMP: STATUS must be an integer");
     }
 #else
   warning ("WCOREDUMP always returns false in this version of Octave");
 #endif
 
   return retval;
 }
 
@@ -1525,17 +1525,17 @@ is being traced (see ptrace(2)).\n\
 #if defined (WIFSTOPPED)
   if (args.length () == 1)
     {
       int status = args(0).int_value ();
 
       if (! error_state)
         retval = WIFSTOPPED (status);
       else
-        error ("WIFSTOPPED: expecting integer argument");
+        error ("WIFSTOPPED: STATUS must be an integer");
     }
 #else
   warning ("WIFSTOPPED always returns false in this version of Octave");
 #endif
 
   return retval;
 }
 
@@ -1553,17 +1553,17 @@ be employed if @code{WIFSTOPPED} returne
 #if defined (WSTOPSIG)
   if (args.length () == 1)
     {
       int status = args(0).int_value ();
 
       if (! error_state)
         retval = WSTOPSIG (status);
       else
-        error ("WSTOPSIG: expecting integer argument");
+        error ("WSTOPSIG: STATUS must be an integer");
     }
 #else
   warning ("WSTOPSIG always returns false in this version of Octave");
 #endif
 
   return retval;
 }
 
@@ -1580,17 +1580,17 @@ child process was resumed by delivery of
 #if defined (WIFCONTINUED)
   if (args.length () == 1)
     {
       int status = args(0).int_value ();
 
       if (! error_state)
         retval = WIFCONTINUED (status);
       else
-        error ("WIFCONTINUED: expecting integer argument");
+        error ("WIFCONTINUED: STATUS must be an integer");
     }
 #else
   warning ("WIFCONTINUED always returns false in this version of Octave");
 #endif
 
   return retval;
 }
 
@@ -1612,17 +1612,17 @@ Return the canonical name of file @var{n
 
           std::string result = octave_canonicalize_file_name (name, msg);
 
           retval(2) = msg;
           retval(1) = msg.empty () ? 0 : -1;
           retval(0) = result;
         }
       else
-        error ("canonicalize_file_name: argument must be a character string");
+        error ("canonicalize_file_name: NAME must be a character string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 static octave_value
diff --git a/src/sysdep.cc b/src/sysdep.cc
--- a/src/sysdep.cc
+++ b/src/sysdep.cc
@@ -571,20 +571,20 @@ Set the value of the environment variabl
       if (! error_state)
         {
           std::string val = (nargin == 2
                              ? args(1).string_value () : std::string ());
 
           if (! error_state)
             octave_env::putenv (var, val);
           else
-            error ("putenv: second argument should be a string");
+            error ("putenv: VALUE must be a string");
         }
       else
-        error ("putenv: first argument should be a string");
+        error ("putenv: VAR must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 DEFALIAS (setenv, putenv);
 
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -890,34 +890,34 @@ command shell that is started to run the
           if (! error_state)
             {
               if (type_str == "sync")
                 type = et_sync;
               else if (type_str == "async")
                 type = et_async;
               else
                 {
-                  error ("system: third arg must be \"sync\" or \"async\"");
+                  error ("system: TYPE must be \"sync\" or \"async\"");
                   return retval;
                 }
             }
           else
             {
-              error ("system: third argument must be a character string");
+              error ("system: TYPE must be a character string");
               return retval;
             }
         }
 
       if (nargin > 1)
         {
           return_output = args(1).is_true ();
 
           if (error_state)
             {
-              error ("system: expecting second argument to be true or false");
+              error ("system: RETURN_OUTPUT must be boolean value true or false");
               return retval;
             }
         }
 
       if (return_output && type == et_async)
         {
           error ("system: can't return output from commands run asynchronously");
           return retval;
@@ -986,17 +986,17 @@ command shell that is started to run the
 
               if (WIFEXITED (status))
                 status = WEXITSTATUS (status);
 
               retval(0) = status;
             }
         }
       else
-        error ("system: expecting std::string as first argument");
+        error ("system: expecting string as first argument");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFALIAS (shell_cmd, system);
@@ -1136,34 +1136,34 @@ multiple times.\n\
         {
           bool add_mode = true;
 
           if (nargin == 2)
             {
               add_mode = args(1).bool_value ();
 
               if (error_state)
-                error ("atexit: second argument must be a logical value");
+                error ("atexit: FLAG argument must be a logical value");
             }
 
           if (! error_state)
             {
               if (add_mode)
                 octave_add_atexit_function (arg);
               else
                 {
                   bool found = octave_remove_atexit_function (arg);
 
                   if (nargout > 0)
                     retval(0) = found;
                 }
             }
         }
       else
-        error ("atexit: argument must be a string");
+        error ("atexit: FCN argument must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (octave_config_info, args, ,
diff --git a/src/utils.cc b/src/utils.cc
--- a/src/utils.cc
+++ b/src/utils.cc
@@ -312,17 +312,17 @@ name in the path.  If no files are found
               if (! error_state && opt == "all")
                 retval = Cell (make_absolute
                                (load_path::find_all_first_of (names)));
               else
                 error ("file_in_loadpath: invalid option");
             }
         }
       else
-        error ("file_in_loadpath: expecting string as first argument");
+        error ("file_in_loadpath: FILE argument must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (file_in_path, args, ,
@@ -374,20 +374,20 @@ name in the path.  If no files are found
                   if (! error_state && opt == "all")
                     retval = Cell (make_absolute
                                    (search_path_for_all_files (path, names)));
                   else
                     error ("file_in_path: invalid option");
                 }
             }
           else
-            error ("file_in_path: expecting string as second argument");
+            error ("file_in_path: all arguments must be strings");
         }
       else
-        error ("file_in_path: expecting string as first argument");
+        error ("file_in_path: PATH must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 std::string
@@ -610,17 +610,17 @@ Convert special characters in @var{strin
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       if (args(0).is_string ())
         retval = do_string_escapes (args(0).string_value ());
       else
-        error ("do_string_escapes: argument must be a string");
+        error ("do_string_escapes: STRING argument must be of type string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 const char *
@@ -716,17 +716,17 @@ representation.\n\
 
   int nargin = args.length ();
 
   if (nargin == 1)
     {
       if (args(0).is_string ())
         retval = undo_string_escapes (args(0).string_value ());
       else
-        error ("undo_string_escapes: argument must be a string");
+        error ("undo_string_escapes: S argument must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (is_absolute_filename, args, ,
@@ -775,17 +775,17 @@ Return the full name of @var{file}, rela
 
   if (args.length () == 1)
     {
       std::string nm = args(0).string_value ();
 
       if (! error_state)
         retval = octave_env::make_absolute (nm);
       else
-        error ("make_absolute_filename: expecting argument to be a file name");
+        error ("make_absolute_filename: FILE argument must be a file name");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUN (find_dir_in_path, args, ,
@@ -814,17 +814,17 @@ containing all the directory names that 
       if (! error_state)
         {
           if (nargin == 1)
             retval = load_path::find_dir (dir);
           else if (nargin == 2)
             retval = Cell (load_path::find_matching_dirs (dir));
         }
       else
-        error ("find_dir_in_path: expecting argument to be a directory name");
+        error ("find_dir_in_path: DIR must be a directory name");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 DEFUNX ("errno", Ferrno, args, ,
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -339,17 +339,17 @@ do_isglobal (const octave_value_list& ar
       print_usage ();
       return retval;
     }
 
   std::string name = args(0).string_value ();
 
   if (error_state)
     {
-      error ("isglobal: expecting std::string argument");
+      error ("isglobal: NAME must be a string");
       return retval;
     }
 
   return symbol_table::is_global (name);
 }
 
 DEFUN (isglobal, args, ,
   "-*- texinfo -*-\n\
@@ -559,20 +559,20 @@ Check only for directories.\n\
       if (! error_state)
         {
           std::string type
             = (nargin == 2) ? args(1).string_value () : std::string ("any");
 
           if (! error_state)
             retval = symbol_exist (name, type);
           else
-            error ("exist: expecting second argument to be a string");
+            error ("exist: TYPE must be a string");
         }
       else
-        error ("exist: expecting first argument to be a string");
+        error ("exist: NAME must be a string");
     }
   else
     print_usage ();
 
   return retval;
 }
 
 /*
@@ -1964,17 +1964,17 @@ then unlock the current function.\n\
 
   if (args.length() == 1)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
         munlock (name);
       else
-        error ("munlock: expecting argument to be a function name");
+        error ("munlock: FCN must be a string");
     }
   else if (args.length () == 0)
     {
       octave_function *fcn = octave_call_stack::caller ();
 
       if (fcn)
         fcn->unlock ();
       else
@@ -1999,17 +1999,17 @@ then return true if the current function
 
   if (args.length() == 1)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
         retval = mislocked (name);
       else
-        error ("mislocked: expecting argument to be a function name");
+        error ("mislocked: FCN must be a string");
     }
   else if (args.length () == 0)
     {
       octave_function *fcn = octave_call_stack::caller ();
 
       if (fcn)
         retval = fcn->islocked ();
       else
