# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1295562929 18000
#      Thu Jan 20 17:35:29 2011 -0500
# Node ID c792872f8942baf00c812906f2103f256761fe17
# Parent  12df7854fa7ccc7457baea63f7263b6e22bf77d5
all script files: untabify and strip trailing whitespace

diff --git a/scripts/@ftp/dir.m b/scripts/@ftp/dir.m
--- a/scripts/@ftp/dir.m
+++ b/scripts/@ftp/dir.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{lst} =} dir (@var{f})
-## List the current directory in verbose form for the FTP connection 
+## List the current directory in verbose form for the FTP connection
 ## @var{f}.  @var{f} is an FTP object returned by the @code{ftp} function.
 ## @end deftypefn
 
 function lst = dir (f)
   if (nargout == 0)
     __ftp_dir__ (f.curlhandle);
   else
     lst = __ftp_dir__ (f.curlhandle);
diff --git a/scripts/@ftp/mget.m b/scripts/@ftp/mget.m
--- a/scripts/@ftp/mget.m
+++ b/scripts/@ftp/mget.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} mget (@var{f}, @var{file})
 ## @deftypefnx {Function File} {} mget (@var{f}, @var{dir})
 ## @deftypefnx {Function File} {} mget (@dots{}, @var{target})
 ## Downloads a remote file @var{file} or directory @var{dir} to the local
 ## directory on the FTP connection @var{f}.  @var{f} is an FTP object
-## returned by the @code{ftp} function. 
+## returned by the @code{ftp} function.
 ##
 ## The arguments @var{file} and @var{dir} can include wildcards and any
 ## files or directories on the remote server that match will be downloaded.
 ##
 ## If a third argument @var{target} is given, then a single file or
 ## directory will be downloaded with the name @var{target} to the local
 ## directory.
 ## @end deftypefn
diff --git a/scripts/@ftp/mput.m b/scripts/@ftp/mput.m
--- a/scripts/@ftp/mput.m
+++ b/scripts/@ftp/mput.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} mput (@var{f}, @var{file})
 ## Upload the local file @var{file} into the current remote directory on
 ## the FTP connection @var{f}.  @var{f} is an FTP object returned by the
-## ftp function. 
+## ftp function.
 ##
 ## The argument @var{file} is passed by the @dfn{glob} function and any
 ## files that match the wildcards in @var{file} will be uploaded.
 ## @end deftypefn
 
 function retval = mput (f, file)
   if (nargout == 0)
     __ftp_mput__ (f.curlhandle, file);
diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -1,8 +1,196 @@
+2011-01-20  John W. Eaton  <jwe@octave.org>
+
+	* @ftp/dir.m, @ftp/mget.m, @ftp/mput.m, ChangeLog,
+	audio/lin2mu.m, audio/setaudio.m, audio/wavread.m,
+	audio/wavwrite.m, deprecated/autocor.m, deprecated/autocov.m,
+	deprecated/betai.m, deprecated/create_set.m,
+	deprecated/dispatch.m, deprecated/gammai.m,
+	deprecated/intwarning.m, deprecated/replot.m, elfun/cosd.m,
+	elfun/sind.m, elfun/tand.m, general/accumarray.m,
+	general/accumdim.m, general/arrayfun.m, general/bicubic.m,
+	general/bitcmp.m, general/bitget.m, general/bitset.m,
+	general/cart2pol.m, general/cart2sph.m, general/cell2mat.m,
+	general/celldisp.m, general/circshift.m, general/cplxpair.m,
+	general/cumtrapz.m, general/curl.m, general/dblquad.m,
+	general/deal.m, general/del2.m, general/divergence.m,
+	general/flipud.m, general/gradient.m, general/idivide.m,
+	general/int2str.m, general/interp1.m, general/interp2.m,
+	general/interp3.m, general/interpft.m, general/interpn.m,
+	general/isdir.m, general/loadobj.m, general/logspace.m,
+	general/num2str.m, general/pol2cart.m, general/polyarea.m,
+	general/quadgk.m, general/quadl.m, general/quadv.m,
+	general/randi.m, general/rat.m, general/repmat.m,
+	general/rot90.m, general/rotdim.m, general/saveobj.m,
+	general/shift.m, general/sortrows.m, general/sph2cart.m,
+	general/structfun.m, general/subsindex.m, general/trapz.m,
+	general/triplequad.m, geometry/convhull.m, geometry/delaunay.m,
+	geometry/delaunay3.m, geometry/delaunayn.m, geometry/dsearch.m,
+	geometry/dsearchn.m, geometry/griddata3.m, geometry/griddatan.m,
+	geometry/inpolygon.m, geometry/rectint.m, geometry/trimesh.m,
+	geometry/trisurf.m, geometry/tsearchn.m, geometry/voronoi.m,
+	help/__makeinfo__.m, help/__strip_html_tags__.m, help/doc.m,
+	help/gen_doc_cache.m, help/get_first_help_sentence.m,
+	help/help.m, help/lookfor.m, help/print_usage.m, help/type.m,
+	image/autumn.m, image/bone.m, image/brighten.m, image/cool.m,
+	image/copper.m, image/flag.m, image/gmap40.m, image/gray.m,
+	image/hot.m, image/hsv.m, image/hsv2rgb.m, image/image.m,
+	image/imread.m, image/imshow.m, image/imwrite.m,
+	image/ind2rgb.m, image/jet.m, image/ntsc2rgb.m, image/ocean.m,
+	image/pink.m, image/prism.m, image/rainbow.m, image/rgb2hsv.m,
+	image/rgb2ind.m, image/rgb2ntsc.m, image/spring.m,
+	image/summer.m, image/winter.m, io/dlmwrite.m, io/fileread.m,
+	io/strread.m, io/textread.m, linear-algebra/cond.m,
+	linear-algebra/condest.m, linear-algebra/cross.m,
+	linear-algebra/expm.m, linear-algebra/isdefinite.m,
+	linear-algebra/krylov.m, linear-algebra/logm.m,
+	linear-algebra/normest.m, linear-algebra/onenormest.m,
+	linear-algebra/rref.m, linear-algebra/subspace.m,
+	miscellaneous/ans.m, miscellaneous/bincoeff.m,
+	miscellaneous/bunzip2.m, miscellaneous/bzip2.m,
+	miscellaneous/computer.m, miscellaneous/copyfile.m,
+	miscellaneous/debug.m, miscellaneous/edit.m,
+	miscellaneous/getappdata.m, miscellaneous/getfield.m,
+	miscellaneous/gunzip.m, miscellaneous/gzip.m,
+	miscellaneous/isappdata.m, miscellaneous/ls.m,
+	miscellaneous/mkoctfile.m, miscellaneous/movefile.m,
+	miscellaneous/namelengthmax.m, miscellaneous/orderfields.m,
+	miscellaneous/private/__xzip__.m, miscellaneous/rmappdata.m,
+	miscellaneous/setappdata.m, miscellaneous/substruct.m,
+	miscellaneous/swapbytes.m, miscellaneous/tar.m,
+	miscellaneous/unimplemented.m, miscellaneous/unpack.m,
+	miscellaneous/untar.m, miscellaneous/unzip.m,
+	miscellaneous/ver.m, miscellaneous/warning_ids.m,
+	miscellaneous/what.m, miscellaneous/zip.m,
+	optimization/__all_opts__.m, optimization/fminbnd.m,
+	optimization/fminunc.m, optimization/fsolve.m,
+	optimization/fzero.m, optimization/glpk.m,
+	optimization/lsqnonneg.m, optimization/optimget.m,
+	optimization/pqpnonneg.m, optimization/qp.m, optimization/sqp.m,
+	path/pathdef.m, path/savepath.m, pkg/pkg.m,
+	plot/__fltk_ginput__.m, plot/__gnuplot_ginput__.m,
+	plot/__gnuplot_has_feature__.m, plot/__gnuplot_open_stream__.m,
+	plot/__gnuplot_print__.m, plot/__go_draw_axes__.m,
+	plot/__go_draw_figure__.m, plot/__marching_cube__.m,
+	plot/__next_line_color__.m, plot/__next_line_style__.m,
+	plot/__plt_get_axis_arg__.m, plot/__print_parse_opts__.m,
+	plot/area.m, plot/axis.m, plot/bar.m, plot/barh.m, plot/caxis.m,
+	plot/cla.m, plot/clabel.m, plot/colorbar.m, plot/comet.m,
+	plot/comet3.m, plot/compass.m, plot/contour.m, plot/contour3.m,
+	plot/contourc.m, plot/cylinder.m, plot/daspect.m,
+	plot/diffuse.m, plot/ellipsoid.m, plot/errorbar.m,
+	plot/ezcontour.m, plot/ezcontourf.m, plot/ezmesh.m,
+	plot/ezmeshc.m, plot/ezplot.m, plot/ezplot3.m, plot/ezpolar.m,
+	plot/ezsurf.m, plot/ezsurfc.m, plot/feather.m, plot/findobj.m,
+	plot/fplot.m, plot/gnuplot_drawnow.m, plot/gtext.m, plot/hist.m,
+	plot/hold.m, plot/ishghandle.m, plot/isocolors.m,
+	plot/isonormals.m, plot/isosurface.m, plot/isprop.m,
+	plot/legend.m, plot/loglog.m, plot/loglogerr.m, plot/meshc.m,
+	plot/meshz.m, plot/ndgrid.m, plot/orient.m, plot/pareto.m,
+	plot/patch.m, plot/pbaspect.m, plot/pcolor.m, plot/peaks.m,
+	plot/pie.m, plot/pie3.m, plot/plot.m, plot/plot3.m,
+	plot/plotmatrix.m, plot/plotyy.m, plot/polar.m, plot/print.m,
+	plot/private/__actual_axis_position__.m,
+	plot/private/__axis_label__.m, plot/private/__bar__.m,
+	plot/private/__clabel__.m, plot/private/__contour__.m,
+	plot/private/__errplot__.m, plot/private/__ezplot__.m,
+	plot/private/__fltk_file_filter__.m,
+	plot/private/__ghostscript__.m,
+	plot/private/__gnuplot_has_terminal__.m,
+	plot/private/__patch__.m, plot/private/__pie__.m,
+	plot/private/__pltopt__.m, plot/private/__quiver__.m,
+	plot/private/__scatter__.m, plot/private/__stem__.m,
+	plot/private/__tight_eps_bbox__.m, plot/quiver.m,
+	plot/quiver3.m, plot/refreshdata.m, plot/rose.m, plot/saveas.m,
+	plot/scatter.m, plot/scatter3.m, plot/semilogx.m,
+	plot/semilogxerr.m, plot/semilogy.m, plot/semilogyerr.m,
+	plot/shading.m, plot/slice.m, plot/specular.m, plot/sphere.m,
+	plot/stairs.m, plot/stem.m, plot/stem3.m, plot/subplot.m,
+	plot/surface.m, plot/surfc.m, plot/surfl.m, plot/surfnorm.m,
+	plot/uigetdir.m, plot/uigetfile.m, plot/uimenu.m,
+	plot/uiputfile.m, plot/view.m, plot/waitforbuttonpress.m,
+	plot/whitebg.m, plot/xlim.m, plot/ylim.m, plot/zlim.m,
+	polynomial/mkpp.m, polynomial/mpoles.m, polynomial/pchip.m,
+	polynomial/poly.m, polynomial/polyaffine.m,
+	polynomial/polyderiv.m, polynomial/polyfit.m,
+	polynomial/polyreduce.m, polynomial/polyval.m,
+	polynomial/ppder.m, polynomial/ppint.m, polynomial/ppjumps.m,
+	polynomial/ppval.m, polynomial/residue.m, polynomial/roots.m,
+	polynomial/spline.m, polynomial/unmkpp.m, set/ismember.m,
+	set/private/validargs.m, set/setdiff.m, set/setxor.m,
+	set/union.m, set/unique.m, signal/arma_rnd.m, signal/fftconv.m,
+	signal/fftshift.m, signal/filter2.m, signal/freqz.m,
+	signal/ifftshift.m, signal/unwrap.m, sparse/bicgstab.m,
+	sparse/cgs.m, sparse/gplot.m, sparse/pcg.m, sparse/pcr.m,
+	sparse/spaugment.m, sparse/spdiags.m, sparse/speye.m,
+	sparse/spfun.m, sparse/sprand.m, sparse/sprandn.m,
+	sparse/sprandsym.m, sparse/spstats.m, sparse/spy.m,
+	sparse/svds.m, sparse/treelayout.m, sparse/treeplot.m,
+	specfun/bessel.m, specfun/betaln.m, specfun/factor.m,
+	specfun/legendre.m, specfun/nchoosek.m, specfun/nthroot.m,
+	specfun/primes.m, specfun/reallog.m, specfun/realpow.m,
+	specfun/realsqrt.m, special-matrix/hadamard.m,
+	special-matrix/invhilb.m, special-matrix/magic.m,
+	special-matrix/pascal.m, special-matrix/toeplitz.m,
+	startup/__finish__.m, statistics/base/cov.m,
+	statistics/base/histc.m, statistics/base/iqr.m,
+	statistics/base/kendall.m, statistics/base/kurtosis.m,
+	statistics/base/mean.m, statistics/base/meansq.m,
+	statistics/base/median.m, statistics/base/mode.m,
+	statistics/base/moment.m, statistics/base/ols.m,
+	statistics/base/prctile.m, statistics/base/qqplot.m,
+	statistics/base/quantile.m, statistics/base/ranks.m,
+	statistics/base/run_count.m, statistics/base/skewness.m,
+	statistics/base/statistics.m, statistics/base/std.m,
+	statistics/base/studentize.m, statistics/base/var.m,
+	statistics/distributions/betainv.m,
+	statistics/distributions/betapdf.m,
+	statistics/distributions/betarnd.m,
+	statistics/distributions/binoinv.m,
+	statistics/distributions/binornd.m,
+	statistics/distributions/cauchy_cdf.m,
+	statistics/distributions/cauchy_inv.m,
+	statistics/distributions/cauchy_pdf.m,
+	statistics/distributions/cauchy_rnd.m,
+	statistics/distributions/chi2rnd.m,
+	statistics/distributions/discrete_rnd.m,
+	statistics/distributions/exprnd.m,
+	statistics/distributions/fcdf.m,
+	statistics/distributions/frnd.m,
+	statistics/distributions/gamrnd.m,
+	statistics/distributions/lognrnd.m,
+	statistics/distributions/nbincdf.m,
+	statistics/distributions/nbininv.m,
+	statistics/distributions/nbinpdf.m,
+	statistics/distributions/nbinrnd.m,
+	statistics/distributions/normrnd.m,
+	statistics/distributions/poissrnd.m,
+	statistics/distributions/stdnormal_rnd.m,
+	statistics/distributions/tpdf.m,
+	statistics/distributions/trnd.m,
+	statistics/distributions/unifcdf.m,
+	statistics/distributions/unifrnd.m,
+	statistics/distributions/wblrnd.m,
+	statistics/tests/bartlett_test.m,
+	statistics/tests/kolmogorov_smirnov_test_2.m,
+	statistics/tests/kruskal_wallis_test.m,
+	statistics/tests/t_test_regression.m, strings/blanks.m,
+	strings/dec2base.m, strings/dec2hex.m, strings/findstr.m,
+	strings/index.m, strings/isstrprop.m, strings/mat2str.m,
+	strings/regexptranslate.m, strings/str2num.m, strings/strchr.m,
+	strings/strjust.m, strings/strmatch.m, strings/strsplit.m,
+	strings/strtok.m, strings/untabify.m, testfun/assert.m,
+	testfun/demo.m, testfun/example.m, testfun/fail.m,
+	testfun/speed.m, testfun/test.m, time/datenum.m, time/datestr.m,
+	time/datetick.m, time/datevec.m, time/etime.m:
+	Strip trailing whitespace.
+
+	* statistics/distributions/betapdf.m: Untabify.
+
 2010-01-20  Petr Mikulik  <mikulik@physics.muni.cz>
 
 	* plot/uigetdir.m: Use correct variable name for argument check.
 	Remove unneeded white spaces.
 	* plot/uigetfile.m, plot/uiputfile.m: Remove unneeded white spaces.
 	Bug #32190.
 
 2011-01-20  John W. Eaton  <jwe@octave.org>
diff --git a/scripts/audio/lin2mu.m b/scripts/audio/lin2mu.m
--- a/scripts/audio/lin2mu.m
+++ b/scripts/audio/lin2mu.m
@@ -15,20 +15,20 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} lin2mu (@var{x})
 ## @deftypefnx {Function File} {} lin2mu (@var{x}, @var{n})
 ## Convert audio data from linear to mu-law.  Mu-law values use 8-bit
-## unsigned integers.  Linear values use @var{n}-bit signed integers or 
+## unsigned integers.  Linear values use @var{n}-bit signed integers or
 ## floating point values in the range -1 @leq{} @var{x} @leq{} 1 if
-## @var{n} is 0.  
-## If @var{n} is not specified it defaults to 0, 8, or 16 depending on 
+## @var{n} is 0.
+## If @var{n} is not specified it defaults to 0, 8, or 16 depending on
 ## the range of values in @var{x}.
 ## @seealso{mu2lin, loadaudio, saveaudio}
 ## @end deftypefn
 
 
 ## Author: Andreas Weingessel <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 17 October 1994
 ## Adapted-By: jwe
diff --git a/scripts/audio/setaudio.m b/scripts/audio/setaudio.m
--- a/scripts/audio/setaudio.m
+++ b/scripts/audio/setaudio.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} setaudio ()
 ## @deftypefnx {Function File} {} setaudio (@var{w_type})
 ## @deftypefnx {Function File} {} setaudio (@var{w_type}, @var{value})
-## Execute the shell command @samp{mixer}, possibly with optional 
+## Execute the shell command @samp{mixer}, possibly with optional
 ## arguments @var{w_type} and @var{value}.
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 5 October 1994
 ## Adapted-By: jwe
 
 function setaudio (w_type, value)
diff --git a/scripts/audio/wavread.m b/scripts/audio/wavread.m
--- a/scripts/audio/wavread.m
+++ b/scripts/audio/wavread.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{y} =} wavread (@var{filename})
 ## Load the RIFF/WAVE sound file @var{filename}, and return the samples
 ## in vector @var{y}.  If the file contains multichannel data, then
 ## @var{y} is a matrix with the channels represented as columns.
 ##
 ## @deftypefnx {Function File} {[@var{y}, @var{Fs}, @var{bits}] =} wavread (@var{filename})
-## Additionally return the sample rate (@var{fs}) in Hz and the number of bits 
+## Additionally return the sample rate (@var{fs}) in Hz and the number of bits
 ## per sample (@var{bits}).
 ##
 ## @deftypefnx {Function File} {[@dots{}] =} wavread (@var{filename}, @var{n})
 ## Read only the first @var{n} samples from each channel.
 ##
 ## @deftypefnx {Function File} {[@dots{}] =} wavread (@var{filename}, @var{n1} @var{n2})
 ## Read only samples @var{n1} through @var{n2} from each channel.
 ##
@@ -75,40 +75,40 @@ function [y, samples_per_sec, bits_per_s
   endif
 
   riff_type = char (fread (fid, 4))';
   if(! strcmp (riff_type, "WAVE"))
     fclose (fid);
     error ("wavread: file contains no WAVE signature");
   endif
   riff_pos = riff_pos + 4;
-  riff_size = riff_size - 4; 
+  riff_size = riff_size - 4;
 
   ## Find format chunk inside the RIFF chunk.
   fseek (fid, riff_pos, "bof");
   fmt_size = find_chunk (fid, "fmt ", riff_size);
   fmt_pos = ftell(fid);
   if (fmt_size == -1)
     fclose (fid);
     error ("wavread: file contains no format chunk");
   endif
- 
+
   ## Find data chunk inside the RIFF chunk.
   ## We don't assume that it comes after the format chunk.
   fseek (fid, riff_pos, "bof");
   data_size = find_chunk (fid, "data", riff_size);
   data_pos = ftell (fid);
   if (data_size == -1)
     fclose (fid);
     error ("wavread: file contains no data chunk");
   endif
-  
+
   ### Read format chunk.
   fseek (fid, fmt_pos, "bof");
- 
+
   ## Sample format code.
   format_tag = fread (fid, 1, "uint16", 0, BYTEORDER);
   if (format_tag != FORMAT_PCM && format_tag != FORMAT_IEEE_FLOAT)
     fclose (fid);
     error ("wavread: sample format %#x is not supported", format_tag);
   endif
 
   ## Number of interleaved channels.
@@ -118,46 +118,46 @@ function [y, samples_per_sec, bits_per_s
   samples_per_sec = fread (fid, 1, "uint32", 0, BYTEORDER);
 
   ## Bits per sample.
   fseek (fid, 6, "cof");
   bits_per_sample = fread (fid, 1, "uint16", 0, BYTEORDER);
 
   ### Read data chunk.
   fseek (fid, data_pos, "bof");
-  
+
   ## Determine sample data type.
   if (format_tag == FORMAT_PCM)
     switch (bits_per_sample)
       case 8
         format = "uint8";
-      case 16 
+      case 16
         format = "int16";
       case 24
         format = "uint8";
-      case 32 
+      case 32
         format = "int32";
       otherwise
         fclose (fid);
         error ("wavread: %d bits sample resolution is not supported with PCM",
                bits_per_sample);
     endswitch
   else
     switch (bits_per_sample)
-      case 32 
+      case 32
         format = "float32";
-      case 64 
+      case 64
         format = "float64";
       otherwise
         fclose (fid);
         error ("wavread: %d bits sample resolution is not supported with IEEE float",
                bits_per_sample);
     endswitch
   endif
-  
+
   ## Parse arguments.
   if (nargin == 1)
     length = 8 * data_size / bits_per_sample;
   else
     nparams = size (param, 2);
     if (nparams == 1)
       ## Number of samples is given.
       length = param * channels;
@@ -205,21 +205,21 @@ function [y, samples_per_sec, bits_per_s
       case 16
         yi /= 32767;
       case 24
         yi /= 8388607;
       case 32
         yi /= 2147483647;
     endswitch
   endif
-  
+
   ## Deinterleave.
   nr = numel (yi) / channels;
   y = reshape (yi, channels, nr)';
-  
+
 endfunction
 
 ## Given a chunk_id, scan through chunks from the current file position
 ## though at most size bytes.  Return the size of the found chunk, with
 ## file position pointing to the start of the chunk data.  Return -1 for
 ## size if chunk is not found.
 
 function chunk_size = find_chunk (fid, chunk_id, size)
@@ -227,15 +227,15 @@ function chunk_size = find_chunk (fid, c
   offset = 8;
   chunk_size = 0;
 
   while (! strcmp (id, chunk_id) && (offset < size))
     fseek (fid, chunk_size, "cof");
     id = char (fread (fid, 4))';
     chunk_size = fread (fid, 1, "uint32", 0, "ieee-le");
     ## Chunk sizes must be word-aligned (2 byte)
-    chunk_size += rem (chunk_size, 2);  
+    chunk_size += rem (chunk_size, 2);
     offset = offset + 8 + chunk_size;
   endwhile
   if (! strcmp (id, chunk_id))
     chunk_size = -1;
   endif
 endfunction
diff --git a/scripts/audio/wavwrite.m b/scripts/audio/wavwrite.m
--- a/scripts/audio/wavwrite.m
+++ b/scripts/audio/wavwrite.m
@@ -73,43 +73,43 @@ function wavwrite (y, varargin)
     error ("wavwrite: Y must have at least one column");
   endif
   if (columns (y) > 2^15-1)
     error ("wavwrite: Y has more than 32767 columns (too many for a WAV-file)");
   endif
 
   ## determine sample format
   switch (bits_per_sample)
-    case 8  
+    case 8
       format = "uint8";
-    case 16 
+    case 16
       format = "int16";
-    case 32 
+    case 32
       format = "int32";
     otherwise
       error ("wavwrite: sample resolution not supported");
   endswitch
-  
+
   ## calculate filesize
   [n, channels] = size(y);
 
   ## size of data chunk
   ck_size = n*channels*(bits_per_sample/8);
-  
+
   ## open file for writing binary
 
   if (! ischar (filename))
     error ("wavwrite: expecting FILENAME to be a character string");
   endif
-    
+
   [fid, msg] = fopen (filename, "wb");
   if (fid < 0)
     error ("wavwrite: %s", msg);
   endif
-  
+
   ## write RIFF/WAVE header
   c = 0;
   c += fwrite (fid, "RIFF", "uchar");
 
   ## file size - 8
   c += fwrite (fid, ck_size + 36, "uint32", 0, BYTEORDER);
   c += fwrite (fid, "WAVEfmt ", "uchar");
 
@@ -127,43 +127,43 @@ function wavwrite (y, varargin)
 
   ## bytes per second
   bps = samples_per_sec*channels*bits_per_sample/8;
   c += fwrite (fid, bps, "uint32", 0, BYTEORDER);
 
   ## block align
   c += fwrite (fid, channels*bits_per_sample/8, "uint16", 0, BYTEORDER);
 
-  c += fwrite (fid, bits_per_sample, "uint16", 0, BYTEORDER);   
+  c += fwrite (fid, bits_per_sample, "uint16", 0, BYTEORDER);
   c += fwrite (fid, "data", "uchar");
   c += fwrite (fid, ck_size, "uint32", 0, BYTEORDER);
-  
+
   if (c < 25)
     fclose (fid);
     error ("wavwrite: writing to file failed");
   endif
-  
+
   ## interleave samples
   yi = reshape (y', n*channels, 1);
-  
+
   ## scale samples
   switch (bits_per_sample)
     case 8
       yi = round (yi*127 + 128);
     case 16
       yi = round (yi*32767);
     case 32
       yi = round (yi*2147483647);
   endswitch
-  
+
   ## write to file
   c = fwrite (fid, yi, format, 0, BYTEORDER);
-  
+
   fclose (fid);
-  
+
 endfunction
 
 %!test
 %! A = [1:10; 1:10]/10;
 %! wavwrite("a.wav", A);
 %! [B, samples_per_sec, bits_per_sample] = wavread("a.wav");
 %! assert(A,B, 10^(-4));
 %! assert(samples_per_sec, 8000);
diff --git a/scripts/deprecated/autocor.m b/scripts/deprecated/autocor.m
--- a/scripts/deprecated/autocor.m
+++ b/scripts/deprecated/autocor.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} autocor (@var{x}, @var{h})
 ## Return the autocorrelations from lag 0 to @var{h} of vector @var{x}.
 ## If @var{h} is omitted, all autocorrelations are computed.
 ## If @var{x} is a matrix, the autocorrelations of each column are
 ## computed.
-## The particular algorithm used is from the field of statistics and 
+## The particular algorithm used is from the field of statistics and
 ## differs from the definition used in signal processing.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Compute autocorrelations
 
 ## Deprecated in version 3.4
 
diff --git a/scripts/deprecated/autocov.m b/scripts/deprecated/autocov.m
--- a/scripts/deprecated/autocov.m
+++ b/scripts/deprecated/autocov.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} autocov (@var{x}, @var{h})
 ## Return the autocovariances from lag 0 to @var{h} of vector @var{x}.
 ## If @var{h} is omitted, all autocovariances are computed.
 ## If @var{x} is a matrix, the autocovariances of each column are
 ## computed.
-## The particular algorithm used is from the field of statistics and 
+## The particular algorithm used is from the field of statistics and
 ## differs from the definition used in signal processing.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Compute autocovariances
 
 ## Deprecated in version 3.4
 
diff --git a/scripts/deprecated/betai.m b/scripts/deprecated/betai.m
--- a/scripts/deprecated/betai.m
+++ b/scripts/deprecated/betai.m
@@ -16,18 +16,18 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} betai (@var{a}, @var{b}, @var{x})
 ## This function is provided for compatibility with older versions of
 ## Octave.  New programs should use betainc instead.
 ##
-## @code{betai (@var{a}, @var{b}, @var{x})} is the same as 
-## @code{betainc (@var{x}, @var{a}, @var{b})}. 
+## @code{betai (@var{a}, @var{b}, @var{x})} is the same as
+## @code{betainc (@var{x}, @var{a}, @var{b})}.
 ## @end deftypefn
 
 ## Author: jwe
 ## Created: 30 Jan 1998
 
 ## Deprecated in version 3.4
 
 function retval = betai (a, b, x)
diff --git a/scripts/deprecated/create_set.m b/scripts/deprecated/create_set.m
--- a/scripts/deprecated/create_set.m
+++ b/scripts/deprecated/create_set.m
@@ -55,17 +55,17 @@ function y = create_set (x, rows_opt)
     warned = true;
     warning ("Octave:deprecated-function",
              "create_set is obsolete and will be removed from a future version of Octave, please use unique instead");
   endif
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
-  
+
   if (nargin == 1)
     y = unique (x)(:)';
   elseif (strcmpi (rows_opt, "rows"))
     y = unique (x, "rows");
   else
     error ("create_set: expecting \"rows\" as second argument");
   endif
 
diff --git a/scripts/deprecated/dispatch.m b/scripts/deprecated/dispatch.m
--- a/scripts/deprecated/dispatch.m
+++ b/scripts/deprecated/dispatch.m
@@ -47,17 +47,17 @@ function varargout = dispatch (varargin)
   [ varargout{:} ] = __dispatch__ (varargin{:});
 
 endfunction
 
 
 %!test # builtin function replacement
 %! dispatch('sin','length','string')
 %! assert(sin("abc"),3)
-%! assert(sin(0),0,10*eps); 
+%! assert(sin(0),0,10*eps);
 
 %!test # 'any' function
 %! dispatch('sin','exp','any')
 %! assert(sin(0),1,eps);
 %! assert(sin("abc"),3);
 
 %!test # 'builtin' function
 %! assert(builtin('sin',0),0,eps);
diff --git a/scripts/deprecated/gammai.m b/scripts/deprecated/gammai.m
--- a/scripts/deprecated/gammai.m
+++ b/scripts/deprecated/gammai.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} gammai (@var{a}, @var{x})
 ## This function is provided for compatibility with older versions of
 ## Octave.  New programs should use @code{gammainc} instead.
 ##
-## @code{gammai (@var{a}, @var{x})} is the same as 
+## @code{gammai (@var{a}, @var{x})} is the same as
 ## @code{gammainc (@var{x}, @var{a})}.
 ## @end deftypefn
 
 ## Author: jwe
 ## Created: 30 Jan 1998
 
 ## Deprecated in version 3.4
 
diff --git a/scripts/deprecated/intwarning.m b/scripts/deprecated/intwarning.m
--- a/scripts/deprecated/intwarning.m
+++ b/scripts/deprecated/intwarning.m
@@ -33,17 +33,17 @@
 ## @smallexample
 ## @group
 ## intwarning ("query")
 ## The state of warning "Octave:int-convert-nan" is "off"
 ## The state of warning "Octave:int-convert-non-int-val" is "off"
 ## The state of warning "Octave:int-convert-overflow" is "off"
 ## The state of warning "Octave:int-math-overflow" is "off"
 ## @end group
-## @end smallexample 
+## @end smallexample
 ##
 ## @item "on"
 ## @itemx "off"
 ## Turn integer conversion and math warnings on (or off).  If there is
 ## no output argument, then nothing is printed.  Otherwise the original
 ## state of the state of the integer conversion and math warnings is
 ## returned in a structure array.
 ## @end table
@@ -96,18 +96,18 @@ function y = intwarning (x)
       elseif (strcmpi (x, "on"))
         warning ("on", "Octave:int-convert-nan");
         warning ("on", "Octave:int-convert-non-int-val");
         warning ("on", "Octave:int-convert-overflow");
         warning ("on", "Octave:int-math-overflow");
       elseif (strcmpi (x, "off"))
         warning ("off", "Octave:int-convert-nan");
         warning ("off", "Octave:int-convert-non-int-val");
-        warning ("off", "Octave:int-convert-overflow");    
-        warning ("off", "Octave:int-math-overflow");    
+        warning ("off", "Octave:int-convert-overflow");
+        warning ("off", "Octave:int-math-overflow");
       else
         error ("intwarning: unrecognized argument");
       endif
     elseif (isstruct(x))
       for fld = fieldnames (x)
         if (strcmp ("Octave:int-convert-nan")
             || strcmp ("Octave:int-convert-non-int-val")
             || strcmp ("Octave:int-convert-overflow")
@@ -123,11 +123,11 @@ function y = intwarning (x)
       endfor
     else
       error ("intwarning: unexpected input");
     endif
   endif
 endfunction
 
 function __print_int_warn_state__ (s)
-  fprintf ("The state of warning \"%s\" is \"%s\"\n", 
+  fprintf ("The state of warning \"%s\" is \"%s\"\n",
            s, warning ("query", s).state);
 endfunction
diff --git a/scripts/deprecated/replot.m b/scripts/deprecated/replot.m
--- a/scripts/deprecated/replot.m
+++ b/scripts/deprecated/replot.m
@@ -21,17 +21,17 @@
 ## Refresh the plot window.
 ## @end deftypefn
 
 ## Author: jwe
 
 ## Deprecated in version 3.4
 
 function replot ()
-  
+
   persistent warned = false;
   if (! warned)
     warned = true;
     warning ("Octave:deprecated-function",
              "replot is obsolete and will be removed from a future version of Octave; please use refresh instead");
   endif
 
   if (nargin == 0)
diff --git a/scripts/elfun/cosd.m b/scripts/elfun/cosd.m
--- a/scripts/elfun/cosd.m
+++ b/scripts/elfun/cosd.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cosd (@var{x})
-## Compute the cosine for each element of @var{x} in degrees.  Returns zero 
+## Compute the cosine for each element of @var{x} in degrees.  Returns zero
 ## for elements where @code{(@var{x}-90)/180} is an integer.
 ## @seealso{acosd, cos}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
 function y = cosd (x)
   if (nargin != 1)
diff --git a/scripts/elfun/sind.m b/scripts/elfun/sind.m
--- a/scripts/elfun/sind.m
+++ b/scripts/elfun/sind.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sind (@var{x})
-## Compute the sine for each element of @var{x} in degrees.  Returns zero 
+## Compute the sine for each element of @var{x} in degrees.  Returns zero
 ## for elements where @code{@var{x}/180} is an integer.
 ## @seealso{asind, sin}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
 function y = sind (x)
   if (nargin != 1)
diff --git a/scripts/elfun/tand.m b/scripts/elfun/tand.m
--- a/scripts/elfun/tand.m
+++ b/scripts/elfun/tand.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} tand (@var{x})
-## Compute the tangent for each element of @var{x} in degrees.  Returns zero 
+## Compute the tangent for each element of @var{x} in degrees.  Returns zero
 ## for elements where @code{@var{x}/180} is an integer and @code{Inf} for
 ## elements where @code{(@var{x}-90)/180} is an integer.
 ## @seealso{atand, tan}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
 function y = tand (x)
diff --git a/scripts/general/accumarray.m b/scripts/general/accumarray.m
--- a/scripts/general/accumarray.m
+++ b/scripts/general/accumarray.m
@@ -27,17 +27,17 @@
 ## of @var{subs} corresponds to one of the values in @var{vals}.
 ##
 ## The size of the matrix will be determined by the subscripts themselves.
 ## However, if @var{sz} is defined it determines the matrix size.  The length
 ## of @var{sz} must correspond to the number of columns in @var{subs}.
 ##
 ## The default action of @code{accumarray} is to sum the elements with the
 ## same subscripts.  This behavior can be modified by defining the @var{func}
-## function.  This should be a function or function handle that accepts a 
+## function.  This should be a function or function handle that accepts a
 ## column vector and returns a scalar.  The result of the function should not
 ## depend on the order of the subscripts.
 ##
 ## The elements of the returned array that have no subscripts associated with
 ## them are set to zero.  Defining @var{fillval} to some other value allows
 ## these values to be defined.
 ##
 ## By default @code{accumarray} returns a full matrix.  If @var{issparse} is
@@ -53,23 +53,23 @@
 ## @end group
 ## @end example
 ##
 ## The complexity in the non-sparse case is generally O(M+N), where N is the
 ## number of
 ## subscripts and M is the maximum subscript (linearized in multi-dimensional
 ## case).
 ## If @var{func} is one of @code{@@sum} (default), @code{@@max}, @code{@@min}
-## or @code{@@(x) @{x@}}, an optimized code path is used. 
+## or @code{@@(x) @{x@}}, an optimized code path is used.
 ## Note that for general reduction function the interpreter overhead can play a
 ## major part and it may be more efficient to do multiple accumarray calls and
 ## compute the results in a vectorized manner.
 ## @end deftypefn
 
-function A = accumarray (subs, vals, sz = [], func = [], fillval = [], issparse = [])  
+function A = accumarray (subs, vals, sz = [], func = [], fillval = [], issparse = [])
 
   if (nargin < 2 || nargin > 6)
     print_usage ();
   endif
 
   if (iscell (subs))
     subs = cellfun (@vec, subs, "uniformoutput", false);
     ndims = numel (subs);
@@ -113,17 +113,17 @@ function A = accumarray (subs, vals, sz 
     else
       error ("accumarray: in the sparse case, values must be numeric or logical");
     endif
 
     if (! (isempty (func) || func == @sum))
 
       ## Reduce values. This is not needed if we're about to sum them, because
       ## "sparse" can do that.
-      
+
       ## Sort indices.
       [subs, idx] = sortrows (subs);
       n = rows (subs);
       ## Identify runs.
       jdx = find (any (diff (subs, 1, 1), 2));
       jdx = [jdx; n];
 
       vals = cellfun (func, mat2cell (vals(:)(idx), diff ([0; jdx])));
@@ -232,24 +232,24 @@ function A = accumarray (subs, vals, sz 
 
       if (fillval != zero && ! (isnan (fillval) || isnan (zero)))
         mask = true (size (A));
         mask(subs) = false;
         A(mask) = fillval;
       endif
     else
 
-      ## The general case. Reduce values. 
+      ## The general case. Reduce values.
       n = rows (subs);
       if (numel (vals) == 1)
         vals = vals(ones (1, n), 1);
       else
         vals = vals(:);
       endif
-      
+
       ## Sort indices.
       [subs, idx] = sort (subs);
       ## Identify runs.
       jdx = find (subs(1:n-1) != subs(2:n));
       jdx = [jdx; n];
       vals = mat2cell (vals(idx), diff ([0; jdx]));
       ## Optimize the case when function is @(x) {x}, i.e. we just want to
       ## collect the values to cells.
diff --git a/scripts/general/accumdim.m b/scripts/general/accumdim.m
--- a/scripts/general/accumdim.m
+++ b/scripts/general/accumdim.m
@@ -14,28 +14,28 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} accumdim (@var{subs}, @var{vals}, @var{dim}, @var{n}, @var{func}, @var{fillval})
 ## Create an array by accumulating the slices of an array into the
-## positions defined by their subscripts along a specified dimension. 
+## positions defined by their subscripts along a specified dimension.
 ## The subscripts are defined by the index vector @var{subs}.
 ## The dimension is specified by @var{dim}.  If not given, it defaults
 ## to the first non-singleton dimension.
 ##
-## The extent of the result matrix in the working dimension will be determined 
+## The extent of the result matrix in the working dimension will be determined
 ## by the subscripts themselves.
 ## However, if @var{n} is defined it determines this extent.
 ##
 ## The default action of @code{accumdim} is to sum the subarrays with the
 ## same subscripts.  This behavior can be modified by defining the @var{func}
-## function.  This should be a function or function handle that accepts an 
+## function.  This should be a function or function handle that accepts an
 ## array and a dimension, and reduces the array along this dimension.
 ## As a special exception, the built-in @code{min} and @code{max} functions
 ## can be used directly, and @code{accumdim} accounts for the middle empty
 ## argument that is used in their calling.
 ##
 ## The slices of the returned array that have no subscripts associated with
 ## them are set to zero.  Defining @var{fillval} to some other value allows
 ## these values to be defined.
@@ -80,21 +80,21 @@ function A = accumdim (subs, vals, dim, 
   if (nargin < 3)
     [~, dim] = max (sz != 1); # first non-singleton dim
   elseif (! isindex (dim))
     error ("accumdim: DIM must be a valid dimension");
   elseif (dim > length (sz))
     sz(end+1:dim) = 1;
   endif
   sz(dim) = n;
- 
+
   if (isempty (func) || func == @sum)
     ## Fast summation case.
     A = __accumdim_sum__ (subs, vals, dim, n);
-    
+
     ## Fill in nonzero fill value
     if (fillval != 0)
       mask = true (n, 1);
       mask(subs) = false;
       subsc = {':'}(ones (1, length (sz)));
       subsc{dim} = mask;
       A(subsc{:}) = fillval;
     endif
diff --git a/scripts/general/arrayfun.m b/scripts/general/arrayfun.m
--- a/scripts/general/arrayfun.m
+++ b/scripts/general/arrayfun.m
@@ -30,17 +30,17 @@
 ## accept array arguments it is better to call the function directly.
 ##
 ## The first input argument @var{func} can be a string, a function
 ## handle, an inline function or an anonymous function.  The input
 ## argument @var{A} can be a logic array, a numeric array, a string
 ## array, a structure array or a cell array.  By a call of the function
 ## @command{arrayfun} all elements of @var{A} are passed on to the named
 ## function @var{func} individually.
-## 
+##
 ## The named function can also take more than two input arguments, with
 ## the input arguments given as third input argument @var{b}, fourth
 ## input argument @var{c}, @dots{}  If given more than one array input
 ## argument then all input arguments must have the same sizes, for
 ## example:
 ##
 ## @example
 ## @group
diff --git a/scripts/general/bicubic.m b/scripts/general/bicubic.m
--- a/scripts/general/bicubic.m
+++ b/scripts/general/bicubic.m
@@ -52,17 +52,17 @@ function zi = bicubic (x, y, z, xi, yi, 
       || isa (xi, "single") || isa (yi, "single"))
     myeps = eps("single");
   else
     myeps = eps;
   endif
 
   if (nargin <= 2)
     ## bicubic (z) or bicubic (z, 2)
-    if (nargin == 1) 
+    if (nargin == 1)
       n = 1;
     else
       n = y;
     endif
     z = x;
     x = [];
     [rz, cz] = size (z);
     s = linspace (1, cz, (cz-1)*pow2(n)+1);
@@ -71,77 +71,77 @@ function zi = bicubic (x, y, z, xi, yi, 
     if (! isvector (x) || ! isvector (y))
       error ("bicubic: XI and YI must be vector");
     endif
     s = y;
     t = z;
     z = x;
     [rz, cz] = size (z);
   elseif (nargin == 5 || nargin == 6)
-    [rz, cz] = size (z) ; 
+    [rz, cz] = size (z) ;
     if (isvector (x) && isvector (y))
       if (rz != length (y) || cz != length (x))
         error ("bicubic: length of X and Y must match the size of Z");
       endif
     elseif (size_equal (x, y) && size_equal (x, z))
       x = x(1,:);
       y = y(:,1);
     else
       error ("bicubic: X, Y and Z must be equal size matrices of same size");
     endif
-    
+
     ## Mark values outside the lookup table.
     xfirst_ind = find (xi < x(1));
-    xlast_ind  = find (xi > x(cz));    
+    xlast_ind  = find (xi > x(cz));
     yfirst_ind = find (yi < y(1));
     ylast_ind  = find (yi > y(rz));
     ## Set value outside the table preliminary to min max index.
     xi(xfirst_ind) = x(1);
     xi(xlast_ind) = x(cz);
     yi(yfirst_ind) = y(1);
     yi(ylast_ind) = y(rz);
 
 
     x = reshape (x, 1, cz);
     x(cz) *= 1 + sign (x(cz))*myeps;
-    if (x(cz) == 0) 
+    if (x(cz) == 0)
       x(cz) = myeps;
-    endif; 
+    endif;
     xi = reshape (xi, 1, length (xi));
     [m, i] = sort ([x, xi]);
     o = cumsum (i <= cz);
     xidx = o(find (i > cz));
-    
+
     y = reshape (y, rz, 1);
     y(rz) *= 1 + sign (y(rz))*myeps;
-    if (y(rz) == 0) 
+    if (y(rz) == 0)
       y(rz) = myeps;
-    endif; 
+    endif;
     yi = reshape (yi, length (yi), 1);
     [m, i] = sort ([y; yi]);
     o = cumsum (i <= rz);
     yidx = o([find(i > rz)]);
-    
+
     ## Set s and t used follow codes.
     s = xidx + ((xi .- x(xidx))./(x(xidx+1) .- x(xidx)));
     t = yidx + ((yi - y(yidx))./(y(yidx+1) - y(yidx)));
   else
     print_usage ();
   endif
-  
+
   if (rz < 3 || cz < 3)
     error ("bicubic: Z at least a 3 by 3 matrices");
   endif
 
   inds = floor (s);
   d = find (s == cz);
   s = s - floor (s);
   inds(d) = cz-1;
   s(d) = 1.0;
-  
+
   d = [];
   indt = floor (t);
   d = find (t == rz);
   t = t - floor (t);
   indt(d) = rz-1;
   t(d) = 1.0;
   d = [];
 
@@ -174,17 +174,17 @@ function zi = bicubic (x, y, z, xi, yi, 
   cs0 = cs0([1,1,1,1],:);
   cs1 = cs1([1,1,1,1],:);
   cs2 = cs2([1,1,1,1],:);
   cs3 = cs3([1,1,1,1],:);
 
   lent = length (ct0);
   lens = columns (cs0);
   zi = zeros (lent, lens);
-  
+
   for i = 1:lent
     it = indt(i);
     int = [it, it+1, it+2, it+3];
     zi(i,:) = ([ct0(i),ct1(i),ct2(i),ct3(i)]
               * (p(int,inds) .* cs0 + p(int,inds+1) .* cs1
                  + p(int,inds+2) .* cs2 + p(int,inds+3) .* cs3));
   endfor
 
diff --git a/scripts/general/bitcmp.m b/scripts/general/bitcmp.m
--- a/scripts/general/bitcmp.m
+++ b/scripts/general/bitcmp.m
@@ -32,17 +32,17 @@
 ## @end group
 ## @end example
 ## @seealso{bitand, bitor, bitxor, bitset, bitget, bitcmp, bitshift, bitmax}
 ## @end deftypefn
 
 ## Liberally based on the version by Kai Habel from octave-forge
 
 function C = bitcmp (A, k)
-  
+
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (nargin == 2 && (! isscalar (k) || (floor (k) != k)))
     error ("bitcmp: K must be a scalar integer");
   endif
 
diff --git a/scripts/general/bitget.m b/scripts/general/bitget.m
--- a/scripts/general/bitget.m
+++ b/scripts/general/bitget.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{c} =} bitget (@var{A}, @var{n})
 ## Return the status of bit(s) @var{n} of unsigned integers in @var{A}
 ## the lowest significant bit is @var{n} = 1.
 ##
 ## @example
 ## @group
 ## bitget (100, 8:-1:1)
-## @result{} 0  1  1  0  0  1  0  0 
+## @result{} 0  1  1  0  0  1  0  0
 ## @end group
 ## @end example
 ## @seealso{bitand, bitor, bitxor, bitset, bitcmp, bitshift, bitmax}
 ## @end deftypefn
 
 ## Liberally based of the version by Kai Habel from octave-forge
 
 function C = bitget (A, n)
diff --git a/scripts/general/bitset.m b/scripts/general/bitset.m
--- a/scripts/general/bitset.m
+++ b/scripts/general/bitset.m
@@ -38,17 +38,17 @@ function C = bitset (A, n, val)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (nargin == 2)
     val = 1;
   endif
-  
+
   if (isa (A, "double"))
     Bmax = bitmax;
     Amax = log2 (Bmax) + 1;
     _conv = @double;
   else
     if (isa (A, "uint8"))
       Amax = 8;
       _conv = @uint8;
diff --git a/scripts/general/cart2pol.m b/scripts/general/cart2pol.m
--- a/scripts/general/cart2pol.m
+++ b/scripts/general/cart2pol.m
@@ -23,20 +23,20 @@
 ## @deftypefnx {Function File} {[@var{theta}, @var{r}, @var{z}] =} cart2pol (@var{c})
 ## @deftypefnx {Function File} {@var{p} =} cart2pol (@dots{})
 ##
 ## Transform Cartesian to polar or cylindrical coordinates.
 ##
 ## @var{theta} describes the angle relative to the positive x-axis.
 ## @var{r} is the distance to the z-axis @w{(0, 0, z)}.
 ## @var{x}, @var{y} (and @var{z}) must be the same shape, or scalar.
-## If called with a single matrix argument then each row of @var{c} 
+## If called with a single matrix argument then each row of @var{c}
 ## represents the Cartesian coordinate (@var{x}, @var{y} (, @var{z})).
 ##
-## If only a single return argument is requested then return a matrix 
+## If only a single return argument is requested then return a matrix
 ## @var{p} where each row represents one polar/(cylindrical) coordinate
 ## (@var{theta}, @var{phi} (, @var{z})).
 ## @seealso{pol2cart, cart2sph, sph2cart}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
@@ -49,17 +49,17 @@ function [theta, r, z] = cart2pol (x, y,
   if (nargin == 1)
     if (ismatrix (x) && (columns (x) == 2 || columns (x) == 3))
       if (columns (x) == 3)
         z = x(:,3);
       else
         z = [];
       endif
       y = x(:,2);
-      x = x(:,1);    
+      x = x(:,1);
     else
       error ("cart2pol: matrix input must have 2 or 3 columns [X, Y (, Z)]");
     endif
   elseif (nargin == 2)
     if (! ((ismatrix (x) && ismatrix (y))
             && (size_equal (x, y) || isscalar (x) || isscalar (y))))
       error ("cart2pol: arguments must be matrices of same size, or scalar");
     endif
diff --git a/scripts/general/cart2sph.m b/scripts/general/cart2sph.m
--- a/scripts/general/cart2sph.m
+++ b/scripts/general/cart2sph.m
@@ -21,39 +21,39 @@
 ## @deftypefnx {Function File} {[@var{theta}, @var{phi}, @var{r}] =} cart2sph (@var{C})
 ## @deftypefnx {Function File} {@var{S} =} cart2sph (@dots{})
 ## Transform Cartesian to spherical coordinates.
 ##
 ## @var{theta} describes the angle relative to the positive x-axis.
 ## @var{phi} is the angle relative to the xy-plane.
 ## @var{r} is the distance to the origin @w{(0, 0, 0)}.
 ## @var{x}, @var{y}, and @var{z} must be the same shape, or scalar.
-## If called with a single matrix argument then each row of @var{c} 
+## If called with a single matrix argument then each row of @var{c}
 ## represents the Cartesian coordinate (@var{x}, @var{y}, @var{z}).
-## 
-## If only a single return argument is requested then return a matrix 
-## @var{s} where each row represents one spherical coordinate 
+##
+## If only a single return argument is requested then return a matrix
+## @var{s} where each row represents one spherical coordinate
 ## (@var{theta}, @var{phi}, @var{r}).
 ## @seealso{sph2cart, cart2pol, pol2cart}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function [theta, phi, r] = cart2sph (x, y, z)
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
   if (nargin == 1)
     if (ismatrix (x) && columns (x) == 3)
-      z = x(:,3);    
-      y = x(:,2);    
-      x = x(:,1);    
+      z = x(:,3);
+      y = x(:,2);
+      x = x(:,1);
     else
       error ("cart2sph: matrix input must have 3 columns [X, Y, Z]");
     endif
   elseif (nargin == 3)
     if (! ((ismatrix (x) && ismatrix (y) && ismatrix (z))
             && (size_equal (x, y) || isscalar (x) || isscalar (y))
             && (size_equal (x, z) || isscalar (x) || isscalar (z))
             && (size_equal (y, z) || isscalar (y) || isscalar (z))))
diff --git a/scripts/general/cell2mat.m b/scripts/general/cell2mat.m
--- a/scripts/general/cell2mat.m
+++ b/scripts/general/cell2mat.m
@@ -16,31 +16,31 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{m} =} cell2mat (@var{c})
 ## Convert the cell array @var{c} into a matrix by concatenating all
 ## elements of @var{c} into a hyperrectangle.  Elements of @var{c} must
-## be numeric, logical or char matrices, or cell arrays, and @code{cat} 
+## be numeric, logical or char matrices, or cell arrays, and @code{cat}
 ## must be able to concatenate them together.
 ## @seealso{mat2cell, num2cell}
 ## @end deftypefn
 
 function m = cell2mat (c)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   if (! iscell (c))
     error ("cell2mat: C is not a cell array");
   endif
-  
+
   nb = numel (c);
 
   if (nb == 0)
     m = [];
   else
 
     ## We only want numeric, logical, and char matrices.
     valid = cellfun (@isnumeric, c);
@@ -55,17 +55,17 @@ function m = cell2mat (c)
 
     ## The goal is to minimize the total number of cat() calls.
     ## The dimensions can be concatenated along in arbitrary order.
     ## The numbers of concatenations are:
     ## n / d1
     ## n / (d1 * d2)
     ## n / (d1 * d2 * d3)
     ## etc.
-    ## This is minimized if d1 >= d2 >= d3... 
+    ## This is minimized if d1 >= d2 >= d3...
 
     sc = size (c);
     nd = ndims (c);
     [~, isc] = sort (sc);
     for idim = isc
       if (sc(idim) == 1)
         continue;
       endif
diff --git a/scripts/general/celldisp.m b/scripts/general/celldisp.m
--- a/scripts/general/celldisp.m
+++ b/scripts/general/celldisp.m
@@ -16,29 +16,29 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} celldisp (@var{c}, @var{name})
 ## Recursively display the contents of a cell array.  By default the values
 ## are displayed with the name of the variable @var{c}.  However, this name
 ## can be replaced with the variable @var{name}.  For example:
-## 
+##
 ## @example
 ## @group
 ## c = @{1, 2, @{31, 32@}@};
 ## celldisp(c, "b")
 ##      @result{}
-##         b@{1@} = 
+##         b@{1@} =
 ##          1
-##         b@{2@} = 
+##         b@{2@} =
 ##          2
-##         b@{3@}@{1@} = 
+##         b@{3@}@{1@} =
 ##          31
-##         b@{3@}@{2@} = 
+##         b@{3@}@{2@} =
 ##          32
 ## @end group
 ## @end example
 ##
 ## @seealso{disp}
 ## @end deftypefn
 
 ## This is ugly, but seems to be what matlab does..
@@ -75,9 +75,9 @@ function s = indices (dv, i)
     s(end) = [];
   else
     s = sprintf("%i", i);
   endif
 endfunction
 
 %!demo
 %! c = {1, 2, {31, 32}};
-%! celldisp(c, "b") 
\ No newline at end of file
+%! celldisp(c, "b")
\ No newline at end of file
diff --git a/scripts/general/circshift.m b/scripts/general/circshift.m
--- a/scripts/general/circshift.m
+++ b/scripts/general/circshift.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{y} =} circshift (@var{x}, @var{n})
 ## Circularly shifts the values of the array @var{x}.  @var{n} must be
-## a vector of integers no longer than the number of dimensions in 
+## a vector of integers no longer than the number of dimensions in
 ## @var{x}.  The values of @var{n} can be either positive or negative,
 ## which determines the direction in which the values or @var{x} are
 ## shifted.  If an element of @var{n} is zero, then the corresponding
 ## dimension of @var{x} will not be shifted.  For example:
 ##
 ## @example
 ## @group
 ## x = [1, 2, 3; 4, 5, 6; 7, 8, 9];
@@ -52,17 +52,17 @@ function y = circshift (x, n)
       y = x;
     else
       nd = ndims (x);
       sz = size (x);
 
       if (! isvector (n) && length (n) > nd)
         error ("circshift: N must be a vector, no longer than the number of dimension in X");
       endif
-    
+
       if (any (n != floor (n)))
         error ("circshift: all values of N must be integers");
       endif
 
       idx = cell ();
       for i = 1:length (n);
         nn = n(i);
         if (nn < 0)
diff --git a/scripts/general/cplxpair.m b/scripts/general/cplxpair.m
--- a/scripts/general/cplxpair.m
+++ b/scripts/general/cplxpair.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} cplxpair (@var{z})
 ## @deftypefnx {Function File} {} cplxpair (@var{z}, @var{tol})
 ## @deftypefnx {Function File} {} cplxpair (@var{z}, @var{tol}, @var{dim})
-## Sort the numbers @var{z} into complex conjugate pairs ordered by 
+## Sort the numbers @var{z} into complex conjugate pairs ordered by
 ## increasing real part.  Place the negative imaginary complex number
 ## first within each pair.  Place all the real numbers (those with
 ## @code{abs (imag (@var{z}) / @var{z}) < @var{tol})}) after the
 ## complex pairs.
 ##
 ## If @var{tol} is unspecified the default value is 100*@code{eps}.
 ##
 ## By default the complex pairs are sorted along the first non-singleton
@@ -53,24 +53,24 @@
 function y = cplxpair (z, tol, dim)
 
   if nargin < 1 || nargin > 3
     print_usage ();
   endif
 
   if (length (z) == 0)
     y = zeros (size (z));
-    return; 
+    return;
   endif
 
   if (nargin < 2 || isempty (tol))
     if (isa (z, "single"))
       tol = 100 * eps("single");
     else
-      tol = 100*eps; 
+      tol = 100*eps;
     endif
   endif
 
   nd = ndims (z);
   orig_dims = size (z);
   if (nargin < 3)
     ## Find the first singleton dimension.
     dim = 0;
@@ -143,17 +143,17 @@ endfunction
 %! [ cplxpair(exp(2i*pi*[0:4]'/5)), exp(2i*pi*[3; 2; 4; 1; 0]/5) ]
 
 %!assert (isempty(cplxpair([])));
 %!assert (cplxpair(1), 1)
 %!assert (cplxpair([1+1i, 1-1i]), [1-1i, 1+1i])
 %!assert (cplxpair([1+1i, 1+1i, 1, 1-1i, 1-1i, 2]), \
 %!        [1-1i, 1+1i, 1-1i, 1+1i, 1, 2])
 %!assert (cplxpair([1+1i; 1+1i; 1; 1-1i; 1-1i; 2]), \
-%!        [1-1i; 1+1i; 1-1i; 1+1i; 1; 2]) 
+%!        [1-1i; 1+1i; 1-1i; 1+1i; 1; 2])
 %!assert (cplxpair([0, 1, 2]), [0, 1, 2]);
 
 %!shared z
 %! z=exp(2i*pi*[4; 3; 5; 2; 6; 1; 0]/7);
 %!assert (cplxpair(z(randperm(7))), z);
 %!assert (cplxpair(z(randperm(7))), z);
 %!assert (cplxpair(z(randperm(7))), z);
 %!assert (cplxpair([z(randperm(7)),z(randperm(7))]),[z,z])
diff --git a/scripts/general/cumtrapz.m b/scripts/general/cumtrapz.m
--- a/scripts/general/cumtrapz.m
+++ b/scripts/general/cumtrapz.m
@@ -15,33 +15,33 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{z} =} cumtrapz (@var{y})
 ## @deftypefnx {Function File} {@var{z} =} cumtrapz (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{z} =} cumtrapz (@dots{}, @var{dim})
-## 
+##
 ## Cumulative numerical integration using trapezoidal method.
-## @code{cumtrapz (@var{y})} computes the cumulative integral of the 
-## @var{y} along the first non-singleton dimension.  If the argument 
-## @var{x} is omitted an equally spaced vector is assumed.  @code{cumtrapz 
-## (@var{x}, @var{y})} evaluates the cumulative integral with respect 
+## @code{cumtrapz (@var{y})} computes the cumulative integral of the
+## @var{y} along the first non-singleton dimension.  If the argument
+## @var{x} is omitted an equally spaced vector is assumed.  @code{cumtrapz
+## (@var{x}, @var{y})} evaluates the cumulative integral with respect
 ## to @var{x}.
-##  
+##
 ## @seealso{trapz,cumsum}
 ## @end deftypefn
 
 ## Author:      Kai Habel <kai.habel@gmx.de>
 ##
-## also: June 2000 Paul Kienzle (fixes,suggestions) 
+## also: June 2000 Paul Kienzle (fixes,suggestions)
 ## 2006-05-12 David Bateman - Modified for NDArrays
 
-function z = cumtrapz (x, y, dim)       
+function z = cumtrapz (x, y, dim)
 
   if (nargin < 1) || (nargin > 3)
     print_usage ();
   endif
 
   nd = ndims (x);
   sz = size (x);
 
@@ -73,26 +73,26 @@ function z = cumtrapz (x, y, dim)
   endif
 
   n = sz(dim);
   idx1 = cell ();
   for i = 1:nd
     idx1{i} = 1:sz(i);
   endfor
   idx2 = idx1;
-  idx1{dim} = 2 : n;    
+  idx1{dim} = 2 : n;
   idx2{dim} = 1 : (n - 1);
 
   if (! have_x)
     z = 0.5 * cumsum (x(idx1{:}) + x(idx2{:}), dim);
   else
     if (! size_equal (x, y))
       error ("cumtrapz: X and Y must have the same shape");
     endif
-    z = 0.5 * cumsum ((x(idx1{:}) - x(idx2{:})) .* 
+    z = 0.5 * cumsum ((x(idx1{:}) - x(idx2{:})) .*
                       (y(idx1{:}) + y(idx2{:})), dim);
   endif
 
   sz(dim) = 1;
   z = cat (dim, zeros (sz), z);
 
 endfunction
 
diff --git a/scripts/general/curl.m b/scripts/general/curl.m
--- a/scripts/general/curl.m
+++ b/scripts/general/curl.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{cx}, @var{cy}, @var{cz}, @var{v}] =} curl (@var{x}, @var{y}, @var{z}, @var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {[@var{cz}, @var{v}] =} curl (@var{x}, @var{y}, @var{fx}, @var{fy})
 ## @deftypefnx {Function File} {[@dots{}] =} curl (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {[@dots{}] =} curl (@var{fx}, @var{fy})
 ## @deftypefnx {Function File} {@var{v} =} curl (@dots{})
 ## Calculate curl of vector field given by the arrays @var{fx}, @var{fy}, and
-## @var{fz} or @var{fx}, @var{fy} respectively. 
+## @var{fz} or @var{fx}, @var{fy} respectively.
 ## @tex
 ## $$ curl F(x,y,z) = \left( {\partial{d} \over \partial{y}} F_z - {\partial{d} \over \partial{z}} F_y, {\partial{d} \over \partial{z}} F_x - {\partial{d} \over \partial{x}} F_z, {\partial{d} \over \partial{x}} F_y - {\partial{d} \over \partial{y}} F_x \right)$$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ##                   / d         d       d         d       d         d     \
@@ -68,17 +68,17 @@ function varargout = curl (varargin)
   elseif (nargin == 6)
     fidx = 4;
     dx = varargin{1}(1,:,1)(:);
     dy = varargin{2}(:,1,1)(:);
     dz = varargin{3}(1,1,:)(:);
   else
     print_usage();
   endif
-    
+
   if ((nargin == 4) || (nargin == 2))
     if (!size_equal (varargin{fidx}, varargin{fidx + 1}))
       error ("curl: size of X and Y must match.");
     elseif (ndims (varargin{fidx}) != 2)
       error ("curl: expected two-dimensional matrices X and Y.");
     elseif ((length (dx) != columns (varargin{fidx}))
          || (length (dy) != rows (varargin{fidx})))
       error ("curl: size of dx and dy must match the respective dimension of X and Y");
diff --git a/scripts/general/dblquad.m b/scripts/general/dblquad.m
--- a/scripts/general/dblquad.m
+++ b/scripts/general/dblquad.m
@@ -17,35 +17,35 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dblquad (@var{f}, @var{xa}, @var{xb}, @var{ya}, @var{yb}, @var{tol}, @var{quadf}, @dots{})
 ## Numerically evaluate a double integral.  The function over with to
 ## integrate is defined by @code{@var{f}}, and the interval for the
 ## integration is defined by @code{[@var{xa}, @var{xb}, @var{ya},
 ## @var{yb}]}.  The function @var{f} must accept a vector @var{x} and a
-## scalar @var{y}, and return a vector of the same length as @var{x}. 
+## scalar @var{y}, and return a vector of the same length as @var{x}.
 ##
 ## If defined, @var{tol} defines the absolute tolerance to which to
 ## which to integrate each sub-integral.
 ##
 ## Additional arguments, are passed directly to @var{f}.  To use the default
 ## value for @var{tol} one may pass an empty matrix.
 ## @seealso{triplequad,quad,quadv,quadl,quadgk,quadcc,trapz}
 ## @end deftypefn
 
-function q = dblquad(f, xa, xb, ya, yb, tol, quadf, varargin) 
+function q = dblquad(f, xa, xb, ya, yb, tol, quadf, varargin)
   if (nargin < 5)
     print_usage ();
   endif
   if (nargin < 6 || isempty (tol))
-    tol = 1e-6; 
+    tol = 1e-6;
   endif
   if (nargin < 7 || isempty (quadf))
-    quadf = @quadgk; 
+    quadf = @quadgk;
   endif
 
   inner = @__dblquad_inner__;
   if (ischar (f))
     f = @(x,y) feval (f, x, y, varargin{:});
     varargin = {};
   endif
 
diff --git a/scripts/general/deal.m b/scripts/general/deal.m
--- a/scripts/general/deal.m
+++ b/scripts/general/deal.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 1998-2011 Ariel Tankus
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
diff --git a/scripts/general/del2.m b/scripts/general/del2.m
--- a/scripts/general/del2.m
+++ b/scripts/general/del2.m
@@ -33,43 +33,43 @@
 ## @tex
 ## $$d = {1 \over 4} \left( {d^2 \over dx^2} M(x,y) + {d^2 \over dy^2} M(x,y) \right)$$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ##       1    / d^2            d^2         \
-## D  = --- * | ---  M(x,y) +  ---  M(x,y) | 
+## D  = --- * | ---  M(x,y) +  ---  M(x,y) |
 ##       4    \ dx^2           dy^2        /
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## For N-dimensional arrays the sum in parentheses is expanded to include second
 ## derivatives over the additional higher dimensions.
 ##
 ## The spacing between evaluation points may be defined by @var{h}, which is a
-## scalar defining the equidistant spacing in all dimensions.  Alternatively, 
+## scalar defining the equidistant spacing in all dimensions.  Alternatively,
 ## the spacing in each dimension may be defined separately by @var{dx},
-## @var{dy}, etc.  A scalar spacing argument defines equidistant spacing, 
+## @var{dy}, etc.  A scalar spacing argument defines equidistant spacing,
 ## whereas a vector argument can be used to specify variable spacing.  The
 ## length of the spacing vectors must match the respective dimension of
 ## @var{M}.  The default spacing value is 1.
 ##
 ## At least 3 data points are needed for each dimension.  Boundary points are
 ## calculated from the linear extrapolation of interior points.
 ##
 ## @seealso{gradient, diff}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function D = del2 (M, varargin)
-  
+
   if (nargin < 1)
     print_usage ();
   endif
 
   nd = ndims (M);
   sz = size (M);
   dx = cell (1, nd);
   if (nargin == 2 || nargin == 1)
diff --git a/scripts/general/divergence.m b/scripts/general/divergence.m
--- a/scripts/general/divergence.m
+++ b/scripts/general/divergence.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{div} =} divergence (@var{x}, @var{y}, @var{z}, @var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {@var{div} =} divergence (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {@var{div} =} divergence (@var{x}, @var{y}, @var{fx}, @var{fy})
 ## @deftypefnx {Function File} {@var{div} =} divergence (@var{fx}, @var{fy})
 ## Calculate divergence of a vector field given by the arrays @var{fx},
-## @var{fy}, and @var{fz} or @var{fx}, @var{fy} respectively. 
+## @var{fy}, and @var{fz} or @var{fx}, @var{fy} respectively.
 ## @tex
 ## $$
 ## div F(x,y,z) = \partial_x{F} + \partial_y{F} + \partial_z{F}
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
@@ -35,17 +35,17 @@
 ##                   d               d               d
 ## div F(x,y,z)  =   -- F(x,y,z)  +  -- F(x,y,z)  +  -- F(x,y,z)
 ##                   dx              dy              dz
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## The coordinates of the vector field can be given by the arguments @var{x},
-## @var{y}, @var{z} or @var{x}, @var{y} respectively. 
+## @var{y}, @var{z} or @var{x}, @var{y} respectively.
 ##
 ## @seealso{curl, gradient, del2, cross, dot}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function retval = divergence (varargin)
 
@@ -66,29 +66,29 @@ function retval = divergence (varargin)
   elseif (nargin == 6)
     fidx = 4;
     dx = varargin{1}(1,:,1)(:);
     dy = varargin{2}(:,1,1)(:);
     dz = varargin{3}(1,1,:)(:);
   else
     print_usage();
   endif
-    
+
   if ((nargin == 4) || (nargin == 2))
     if (!size_equal (varargin{fidx},varargin{fidx + 1}))
       error ("divergence: size of X and Y must match.");
     elseif (ndims (varargin{fidx}) != 2)
       error ("divergence: expected two-dimensional matrices X and Y.");
     elseif ((length (dx) != columns (varargin{fidx})) || (length (dy) != rows (varargin{fidx})))
       error ("divergence: size of dx and dy must match the respective dimension of X and Y");
     endif
 
     retval = gradient(varargin{fidx}, dx, dy);
     retval += gradient(varargin{fidx + 1}.', dy, dx).';
-    
+
   elseif ((nargin == 6) || (nargin == 3))
     if (!size_equal (varargin{fidx},varargin{fidx + 1},varargin{fidx + 2}))
       error ("divergence: size of X, Y, and Z must match")
     elseif (ndims (varargin{fidx}) != 3)
       error ("divergence: expected two-dimensional matrices X, Y, and Z.");
     elseif ((length (dx) != size (varargin{fidx}, 2))
          || (length (dy) != size (varargin{fidx}, 1))
          || (length (dz) != size (varargin{fidx}, 3)))
diff --git a/scripts/general/flipud.m b/scripts/general/flipud.m
--- a/scripts/general/flipud.m
+++ b/scripts/general/flipud.m
@@ -24,17 +24,17 @@
 ## @example
 ## @group
 ## flipud ([1, 2; 3, 4])
 ##      @result{}  3  4
 ##          1  2
 ## @end group
 ## @end example
 ##
-## Due to the difficulty of defining which axis about which to flip the 
+## Due to the difficulty of defining which axis about which to flip the
 ## matrix @code{flipud} only work with 2-d arrays.  To flip N-d arrays
 ## use @code{flipdim} instead.
 ## @seealso{fliplr, flipdim, rot90, rotdim}
 ## @end deftypefn
 
 ## Author: jwe
 
 function y = flipud (x)
diff --git a/scripts/general/gradient.m b/scripts/general/gradient.m
--- a/scripts/general/gradient.m
+++ b/scripts/general/gradient.m
@@ -31,46 +31,46 @@
 ##
 ## @code{[@var{dx}, @var{dy}] = gradient (@var{m})} calculates the one
 ## dimensional gradient for @var{x} and @var{y} direction if @var{m} is a
 ## matrix.  Additional return arguments can be use for multi-dimensional
 ## matrices.
 ##
 ## A constant spacing between two points can be provided by the
 ## @var{s} parameter.  If @var{s} is a scalar, it is assumed to be the spacing
-## for all dimensions. 
+## for all dimensions.
 ## Otherwise, separate values of the spacing can be supplied by
 ## the @var{x}, @dots{} arguments.  Scalar values specify an equidistant
 ## spacing.
 ## Vector values for the @var{x}, @dots{} arguments specify the coordinate for
 ## that
 ## dimension.  The length must match their respective dimension of @var{m}.
-## 
+##
 ## At boundary points a linear extrapolation is applied.  Interior points
 ## are calculated with the first approximation of the numerical gradient
 ##
 ## @example
 ## y'(i) = 1/(x(i+1)-x(i-1)) * (y(i-1)-y(i+1)).
 ## @end example
-## 
+##
 ## If the first argument @var{f} is a function handle, the gradient of the
 ## function at the points in @var{x0} is approximated using central
 ## difference.  For example, @code{gradient (@@cos, 0)} approximates the
 ## gradient of the cosine function in the point @math{x0 = 0}.  As with
 ## sampled data, the spacing values between the points from which the
 ## gradient is estimated can be set via the @var{s} or @var{dx},
 ## @var{dy}, @dots{} arguments.  By default a spacing of 1 is used.
 ## @seealso{diff, del2}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 ## Modified: David Bateman <dbateman@free.fr> Added NDArray support
 
 function varargout = gradient (m, varargin)
-  
+
   if (nargin < 1)
     print_usage ()
   endif
 
   nargout_with_ans = max(1,nargout);
   if (ismatrix (m))
     [varargout{1:nargout_with_ans}] = matrix_gradient (m, varargin{:});
   elseif (isa (m, "function_handle"))
@@ -95,17 +95,17 @@ function varargout = matrix_gradient (m,
   sz = size (m);
   if (length(sz) > 1)
     tmp = sz(1); sz(1) = sz(2); sz(2) = tmp;
   endif
 
   if (nargin > 2 && nargin != nd + 1)
     print_usage ()
   endif
-  
+
   ## cell d stores a spacing vector for each dimension
   d = cell (1, nd);
   if (nargin == 1)
     ## no spacing given - assume 1.0 for all dimensions
     for i = 1:nd
       d{i} = ones (sz(i) - 1, 1);
     endfor
   elseif (nargin == 2)
@@ -132,17 +132,17 @@ function varargout = matrix_gradient (m,
     endfor
   endif
 
   m = shiftdim (m, 1);
   for i = 1:min (nd, nargout)
     mr = rows (m);
     mc = numel (m) / mr;
     Y = zeros (size (m), class (m));
-        
+
     if (mr > 1)
       ## Top and bottom boundary.
       Y(1,:) = diff (m(1:2, :)) / d{i}(1);
       Y(mr,:) = diff (m(mr-1:mr, :) / d{i}(mr - 1));
     endif
 
     if (mr > 2)
       ## Interior points.
@@ -181,35 +181,35 @@ function varargout = handle_gradient (f,
   if (any (p0_size == 1))
     p0 = p0 (:);
     dim = 1;
     num_points = numel (p0);
   else
     num_points = p0_size (1);
     dim = p0_size (2);
   endif
-  
+
   if (length (varargin) == 0)
     delta = 1;
   elseif (length (varargin) == 1 || length (varargin) == dim)
     try
       delta = [varargin{:}];
     catch
       error ("gradient: spacing parameters must be scalars or a vector");
     end_try_catch
   else
     error ("gradient: incorrect number of spacing parameters");
   endif
-  
+
   if (isscalar (delta))
     delta = repmat (delta, 1, dim);
   elseif (!isvector (delta))
     error ("gradient: spacing values must be scalars or a vector");
   endif
-  
+
   ## Calculate the gradient
   p0 = mat2cell (p0, num_points, ones (1, dim));
   varargout = cell (1, dim);
   for d = 1:dim
     s = delta (d);
     df_dx = (f (p0{1:d-1}, p0{d}+s, p0{d+1:end})
            - f (p0{1:d-1}, p0{d}-s, p0{d+1:end})) ./ (2*s);
     if (dim == 1)
diff --git a/scripts/general/idivide.m b/scripts/general/idivide.m
--- a/scripts/general/idivide.m
+++ b/scripts/general/idivide.m
@@ -13,24 +13,24 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} idivide (@var{x}, @var{y}, @var{op})
-## Integer division with different rounding rules.  
+## Integer division with different rounding rules.
 ##
 ## The standard behavior of integer division such as @code{@var{a} ./ @var{b}}
-## is to round the result to the nearest integer.  This is not always the 
+## is to round the result to the nearest integer.  This is not always the
 ## desired behavior and @code{idivide} permits integer element-by-element
 ## division to be performed with different treatment for the fractional
 ## part of the division as determined by the @var{op} flag.  @var{op} is
-## a string with one of the values: 
+## a string with one of the values:
 ##
 ## @table @asis
 ## @item "fix"
 ## Calculate @code{@var{a} ./ @var{b}} with the fractional part rounded
 ## towards zero.
 ##
 ## @item "round"
 ## Calculate @code{@var{a} ./ @var{b}} with the fractional part rounded
@@ -39,17 +39,17 @@
 ## @item "floor"
 ## Calculate @code{@var{a} ./ @var{b}} with the fractional part rounded
 ## towards negative infinity.
 ##
 ## @item "ceil"
 ## Calculate @code{@var{a} ./ @var{b}} with the fractional part rounded
 ## towards positive infinity.
 ## @end table
-## 
+##
 ## @noindent
 ## If @var{op} is not given it defaults to @code{"fix"}.
 ## An example demonstrating these rounding rules is
 ##
 ## @example
 ## @group
 ## idivide (int8 ([-3, 3]), int8 (4), "fix")
 ## @result{} int8 ([0, 0])
@@ -94,17 +94,17 @@ function z = idivide (x, y, op)
       z = cast (floor (double (x) ./ double (y)), typ);
     elseif (strcmp (op, "ceil"))
       z = cast (ceil (double (x) ./ double (y)), typ);
     else
       error ("idivide: unrecognized rounding type");
     endif
   endif
 endfunction
-  
+
 %!shared a, af, b, bf
 %! a = int8(3);
 %! af = 3;
 %! b = int8([-4, 4]);
 %! bf = [-4, 4];
 
 %!assert (idivide (a, b), int8 ([0, 0]))
 %!assert (idivide (a, b, "floor"), int8([-1, 0]))
diff --git a/scripts/general/int2str.m b/scripts/general/int2str.m
--- a/scripts/general/int2str.m
+++ b/scripts/general/int2str.m
@@ -23,30 +23,30 @@
 ##
 ## @example
 ## @group
 ##
 ## int2str (123)
 ##      @result{} "123"
 ##
 ## s = int2str ([1, 2, 3; 4, 5, 6])
-##      @result{} s = 
+##      @result{} s =
 ##         1  2  3
 ##         4  5  6
-## 
+##
 ## whos s
-##      @result{} s = 
+##      @result{} s =
 ##       Attr Name        Size                     Bytes  Class
-##       ==== ====        ====                     =====  ===== 
+##       ==== ====        ====                     =====  =====
 ##            s           2x7                         14  char
 ## @end group
 ## @end example
 ##
 ## This function is not very flexible.  For better control over the
-## results, use @code{sprintf} (@pxref{Formatted Output}). 
+## results, use @code{sprintf} (@pxref{Formatted Output}).
 ## @seealso{sprintf, num2str, mat2str}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = int2str (n)
 
   if (nargin == 1)
diff --git a/scripts/general/interp1.m b/scripts/general/interp1.m
--- a/scripts/general/interp1.m
+++ b/scripts/general/interp1.m
@@ -20,17 +20,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{yi} =} interp1 (@var{x}, @var{y}, @var{xi})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@var{y}, @var{xi})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{yi} =} interp1 (@dots{}, @var{extrap})
 ## @deftypefnx {Function File} {@var{pp} =} interp1 (@dots{}, 'pp')
 ##
 ## One-dimensional interpolation.  Interpolate @var{y}, defined at the
-## points @var{x}, at the points @var{xi}.  The sample points @var{x} 
+## points @var{x}, at the points @var{xi}.  The sample points @var{x}
 ## must be monotonic.  If not specified, @var{x} is taken to be the
 ## indices of @var{y}.  If @var{y} is an array, treat the columns
 ## of @var{y} separately.
 ##
 ## Method is one of:
 ##
 ## @table @asis
 ## @item 'nearest'
@@ -146,17 +146,17 @@ function yi = interp1 (x, y, varargin)
 
   ## reshape matrices for convenience
   x = x(:);
   nx = rows (x);
   szx = size (xi);
   if (isvector (y))
     y = y(:);
   elseif (isvector (xi))
-    szx = length (xi);    
+    szx = length (xi);
   endif
   szy = size (y);
   y = y(:,:);
   [ny, nc] = size (y);
   xi = xi(:);
 
   ## determine sizes
   if (nx < 2 || ny < 2)
@@ -244,17 +244,17 @@ function yi = interp1 (x, y, varargin)
       t = (xi - x(1))/dx + 1;
       idx = max (1, min (ny - 1, floor (t)));
 
       ## use the endpoints of the interval to define a line
       s = t - idx;
       yi = bsxfun (@times, s, dy(idx,:)) + y(idx,:);
     endif
   case {"pchip", "*pchip"}
-    if (nx == 2 || starmethod) 
+    if (nx == 2 || starmethod)
       x = linspace (x(1), x(nx), ny);
     endif
     ## Note that pchip's arguments are transposed relative to interp1
     if (pp)
       yi = pchip (x.', y.');
       yi.d = szy(2:end);
     else
       yi = pchip (x.', y.', xi.').';
@@ -262,34 +262,34 @@ function yi = interp1 (x, y, varargin)
 
   case {"cubic", "*cubic"}
     if (nx < 4 || ny < 4)
       error ("interp1: table too short");
     endif
 
     ## FIXME Is there a better way to treat pp return and *cubic
     if (starmethod && ! pp)
-      ## From: Miloje Makivic 
+      ## From: Miloje Makivic
       ## http://www.npac.syr.edu/projects/nasa/MILOJE/final/node36.html
       t = (xi - x(1))/dx + 1;
       idx = max (min (floor (t), ny-2), 2);
       t = t - idx;
       t2 = t.*t;
       tp = 1 - 0.5*t;
       a = (1 - t2).*tp;
       b = (t2 + t).*tp;
       c = (t2 - t).*tp/3;
       d = (t2 - 1).*t/6;
       J = ones (1, nc);
 
       yi = a(:,J) .* y(idx,:) + b(:,J) .* y(idx+1,:) ...
       + c(:,J) .* y(idx-1,:) + d(:,J) .* y(idx+2,:);
     else
       if (starmethod)
-        x = linspace (x(1), x(nx), ny).'; 
+        x = linspace (x(1), x(nx), ny).';
         nx = ny;
       endif
 
       idx = lookup (x(2:nx-1), xi, "lr");
 
       ## Construct cubic equations for each interval using divided
       ## differences (computation of c and d don't use divided differences
       ## but instead solve 2 equations for 2 unknowns). Perhaps
@@ -301,29 +301,29 @@ function yi = interp1 (x, y, varargin)
       dx3 = x(i+1).^3 - x(i).^3;
       a = diff (y, 3)./dx(i,J).^3/6;
       b = (diff (y(1:nx-1,:), 2)./dx(i,J).^2 - 6*a.*x(i+1,J))/2;
       c = (diff (y(1:nx-2,:), 1) - a.*dx3(:,J) - b.*dx2(:,J))./dx(i,J);
       d = y(i,:) - ((a.*x(i,J) + b).*x(i,J) + c).*x(i,J);
 
       if (pp)
         xs = [x(1);x(3:nx-2)];
-        yi = mkpp ([x(1);x(3:nx-2);x(nx)], 
-                   [a(:), (b(:) + 3.*xs(:,J).*a(:)), ... 
+        yi = mkpp ([x(1);x(3:nx-2);x(nx)],
+                   [a(:), (b(:) + 3.*xs(:,J).*a(:)), ...
                     (c(:) + 2.*xs(:,J).*b(:) + 3.*xs(:,J)(:).^2.*a(:)), ...
                     (d(:) + xs(:,J).*c(:) + xs(:,J).^2.*b(:) + ...
                      xs(:,J).^3.*a(:))], szy(2:end));
       else
         yi = ((a(idx,:).*xi(:,J) + b(idx,:)).*xi(:,J) ...
               + c(idx,:)).*xi(:,J) + d(idx,:);
       endif
     endif
   case {"spline", "*spline"}
-    if (nx == 2 || starmethod) 
-      x = linspace(x(1), x(nx), ny); 
+    if (nx == 2 || starmethod)
+      x = linspace(x(1), x(nx), ny);
     endif
     ## Note that spline's arguments are transposed relative to interp1
     if (pp)
       yi = spline (x.', y.');
       yi.d = szy(2:end);
     else
       yi = spline (x.', y.', xi.').';
     endif
@@ -396,26 +396,26 @@ endfunction
 
 
 ## For each type of interpolated test, confirm that the interpolated
 ## value at the knots match the values at the knots.  Points away
 ## from the knots are requested, but only 'nearest' and 'linear'
 ## confirm they are the correct values.
 
 %!shared xp, yp, xi, style
-%! xp=0:2:10;      yp = sin(2*pi*xp/5);  
+%! xp=0:2:10;      yp = sin(2*pi*xp/5);
 %! xi = [-1, 0, 2.2, 4, 6.6, 10, 11];
 
 
 ## The following BLOCK/ENDBLOCK section is repeated for each style
 ##    nearest, linear, cubic, spline, pchip
 ## The test for ppval of cubic has looser tolerance, but otherwise
 ## the tests are identical.
 ## Note that the block checks style and *style; if you add more tests
-## before to add them to both sections of each block.  One test, 
+## before to add them to both sections of each block.  One test,
 ## style vs. *style, occurs only in the first section.
 ## There is an ENDBLOCKTEST after the final block
 %!test style = "nearest";
 ## BLOCK
 %!assert (interp1(xp, yp, [min(xp)-1, max(xp)+1],style), [NA, NA]);
 %!assert (interp1(xp,yp,xp,style), yp, 100*eps);
 %!assert (interp1(xp,yp,xp',style), yp', 100*eps);
 %!assert (interp1(xp',yp',xp',style), yp', 100*eps);
diff --git a/scripts/general/interp2.m b/scripts/general/interp2.m
--- a/scripts/general/interp2.m
+++ b/scripts/general/interp2.m
@@ -22,39 +22,39 @@
 ## @deftypefnx {Function File} {@var{zi} =} interp2 (@var{Z}, @var{xi}, @var{yi})
 ## @deftypefnx {Function File} {@var{zi} =} interp2 (@var{Z}, @var{n})
 ## @deftypefnx {Function File} {@var{zi} =} interp2 (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{zi} =} interp2 (@dots{}, @var{method}, @var{extrapval})
 ##
 ## Two-dimensional interpolation.  @var{x}, @var{y} and @var{z} describe a
 ## surface function.  If @var{x} and @var{y} are vectors their length
 ## must correspondent to the size of @var{z}.  @var{x} and @var{y} must be
-## monotonic.  If they are matrices they must have the @code{meshgrid} 
-## format. 
+## monotonic.  If they are matrices they must have the @code{meshgrid}
+## format.
 ##
 ## @table @code
-## @item interp2 (@var{x}, @var{y}, @var{Z}, @var{xi}, @var{yi}, @dots{}) 
+## @item interp2 (@var{x}, @var{y}, @var{Z}, @var{xi}, @var{yi}, @dots{})
 ## Returns a matrix corresponding to the points described by the
-## matrices @var{xi}, @var{yi}.  
+## matrices @var{xi}, @var{yi}.
 ##
 ## If the last argument is a string, the interpolation method can
 ## be specified.  The method can be 'linear', 'nearest' or 'cubic'.
 ## If it is omitted 'linear' interpolation is assumed.
 ##
 ## @item interp2 (@var{z}, @var{xi}, @var{yi})
-## Assumes @code{@var{x} = 1:rows (@var{z})} and @code{@var{y} = 
+## Assumes @code{@var{x} = 1:rows (@var{z})} and @code{@var{y} =
 ## 1:columns (@var{z})}
-## 
-## @item interp2 (@var{z}, @var{n}) 
+##
+## @item interp2 (@var{z}, @var{n})
 ## Interleaves the matrix @var{z} n-times.  If @var{n} is omitted a value
 ## of @code{@var{n} = 1} is assumed.
 ## @end table
 ##
 ## The variable @var{method} defines the method to use for the
-## interpolation.  It can take one of the following values 
+## interpolation.  It can take one of the following values
 ##
 ## @table @asis
 ## @item 'nearest'
 ## Return the nearest neighbor.
 ##
 ## @item 'linear'
 ## Linear interpolation from nearest neighbors.
 ##
@@ -65,25 +65,25 @@
 ## Cubic interpolation from four nearest neighbors.
 ##
 ## @item 'spline'
 ## Cubic spline interpolation--smooth first and second derivatives
 ## throughout the curve.
 ## @end table
 ##
 ## If a scalar value @var{extrapval} is defined as the final value, then
-## values outside the mesh as set to this value.  Note that in this case 
+## values outside the mesh as set to this value.  Note that in this case
 ## @var{method} must be defined as well.  If @var{extrapval} is not
-## defined then NA is assumed. 
+## defined then NA is assumed.
 ##
 ## @seealso{interp1}
 ## @end deftypefn
 
 ## Author:      Kai Habel <kai.habel@gmx.de>
-## 2005-03-02 Thomas Weber <weber@num.uni-sb.de> 
+## 2005-03-02 Thomas Weber <weber@num.uni-sb.de>
 ##     * Add test cases
 ## 2005-03-02 Paul Kienzle <pkienzle@users.sf.net>
 ##     * Simplify
 ## 2005-04-23 Dmitri A. Sergatskov <dasergatskov@gmail.com>
 ##     * Modified demo and test for new gnuplot interface
 ## 2005-09-07 Hoxide <hoxide_dirac@yahoo.com.cn>
 ##     * Add bicubic interpolation method
 ##     * Fix the eat line bug when the last element of XI or YI is
@@ -120,56 +120,56 @@ function ZI = interp2 (varargin)
         [Z, n, method, extrapval] = deal (varargin{:});
       endif
     case 5
       if (ischar (varargin{4}))
         [Z, XI, YI, method, extrapval] = deal (varargin{:});
       else
         [X, Y, Z, XI, YI] = deal (varargin{:});
       endif
-    case 6 
+    case 6
         [X, Y, Z, XI, YI, method] = deal (varargin{:});
     case 7
         [X, Y, Z, XI, YI, method, extrapval] = deal (varargin{:});
     otherwise
       print_usage ();
   endswitch
 
   ## Type checking.
   if (!ismatrix (Z))
-    error ("interp2: Z must be a matrix"); 
+    error ("interp2: Z must be a matrix");
   endif
   if (!isempty (n) && !isscalar (n))
-    error ("interp2: N must be a scalar"); 
+    error ("interp2: N must be a scalar");
   endif
   if (!ischar (method))
-    error ("interp2: METHOD must be a string"); 
+    error ("interp2: METHOD must be a string");
   endif
   if (ischar (extrapval) || strcmp (extrapval, "extrap"))
     extrapval = [];
   elseif (!isscalar (extrapval))
     error ("interp2: EXTRAPVAL must be a scalar");
   endif
 
   ## Define X, Y, XI, YI if needed
   [zr, zc] = size (Z);
   if (isempty (X))
-    X = 1:zc; 
+    X = 1:zc;
     Y = 1:zr;
   endif
   if (! isnumeric (X) || ! isnumeric (Y))
-    error ("interp2: X, Y must be numeric matrices"); 
+    error ("interp2: X, Y must be numeric matrices");
   endif
   if (! isempty (n))
-    p = 2^n; 
-    XI = (p:p*zc)/p; 
-    YI = (p:p*zr)'/p; 
+    p = 2^n;
+    XI = (p:p*zc)/p;
+    YI = (p:p*zr)'/p;
   endif
   if (! isnumeric (XI) || ! isnumeric (YI))
-    error ("interp2: XI, YI must be numeric"); 
+    error ("interp2: XI, YI must be numeric");
   endif
 
 
   if (strcmp (method, "linear") || strcmp (method, "nearest") ...
       || strcmp (method, "pchip"))
 
     ## If X and Y vectors produce a grid from them
     if (isvector (X) && isvector (Y))
@@ -246,17 +246,17 @@ function ZI = interp2 (varargin)
         error ("interp2: pchip2 requires at least 2 points in each dimension")
       endif
 
       ## first order derivatives
       DX = __pchip_deriv__ (X, Z, 2);
       DY = __pchip_deriv__ (Y, Z, 1);
       ## Compute mixed derivatives row-wise and column-wise, use the average.
       DXY = (__pchip_deriv__ (X, DY, 2) + __pchip_deriv__ (Y, DX, 1))/2;
-      
+
       ## do the bicubic interpolation
       hx = diff (X); hx = hx(xidx);
       hy = diff (Y); hy = hy(yidx);
 
       tx = (XI - X(xidx)) ./ hx;
       ty = (YI - Y(yidx)) ./ hy;
 
       ## construct the cubic hermite base functions in x, y
@@ -347,24 +347,24 @@ function ZI = interp2 (varargin)
     ## FIXME bicubic/__splinen__ don't handle arbitrary XI, YI.
     if (strcmp (method, "cubic"))
       ## Please remove the dummy zero when bicubic is fixed.
       if (0 && isgriddata (XI) && isgriddata (YI'))
         ZI = bicubic (X, Y, Z, XI (1, :), YI (:, 1), extrapval);
       elseif (isgriddata (X) && isgriddata (Y'))
         ## Allocate output
         ZI = zeros (size (X));
-  
+
         ## Find inliers
         inside = !(XI < X (1) | XI > X (end) | YI < Y (1) | YI > Y (end));
-  
+
         ## Scale XI and YI to match indices of Z
         XI = (columns (Z) - 1) * (XI - X (1)) / (X (end) - X (1)) + 1;
         YI = (rows (Z) - 1) * (YI - Y (1)) / (Y (end) - Y (1)) + 1;
-  
+
         ## Start the real work
         K = floor (XI);
         L = floor (YI);
 
         ## Coefficients
         AY1  = bc ((YI - L + 1));
         AX1  = bc ((XI - K + 1));
         AY0  = bc ((YI - L + 0));
@@ -388,24 +388,24 @@ function ZI = interp2 (varargin)
            + AY0  .* AX_1 .* Z (sym_sub2ind (sz, L,   K+1)) ...
            + AY0  .* AX0  .* Z (sym_sub2ind (sz, L,   K))   ...
            + AY0  .* AX1  .* Z (sym_sub2ind (sz, L,   K-1)) ...
            + AY1  .* AX_2 .* Z (sym_sub2ind (sz, L-1, K+2)) ...
            + AY1  .* AX_1 .* Z (sym_sub2ind (sz, L-1, K+1)) ...
            + AY1  .* AX0  .* Z (sym_sub2ind (sz, L-1, K))   ...
            + AY1  .* AX1  .* Z (sym_sub2ind (sz, L-1, K-1));
         ZI (!inside) = extrapval;
-      
+
       else
         error ("interp2: input data must have `meshgrid' format");
       endif
 
     elseif (strcmp (method, "spline"))
       if (isgriddata (XI) && isgriddata (YI'))
-        ZI = __splinen__ ({Y(:,1).', X(1,:)}, Z, {YI(:,1), XI(1,:)}, extrapval, 
+        ZI = __splinen__ ({Y(:,1).', X(1,:)}, Z, {YI(:,1), XI(1,:)}, extrapval,
                         "spline");
       else
         error ("interp2: input data must have `meshgrid' format");
       endif
     else
       error ("interp2: interpolation METHOD not recognized");
     endif
 
@@ -444,98 +444,98 @@ endfunction
 
 
 %!demo
 %! A=[13,-1,12;5,4,3;1,6,2];
 %! x=[0,1,4]; y=[10,11,12];
 %! xi=linspace(min(x),max(x),17);
 %! yi=linspace(min(y),max(y),26)';
 %! mesh(xi,yi,interp2(x,y,A,xi,yi,'linear'));
-%! [x,y] = meshgrid(x,y); 
+%! [x,y] = meshgrid(x,y);
 %! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! [x,y,A] = peaks(10);
 %! x = x(1,:)'; y = y(:,1);
 %! xi=linspace(min(x),max(x),41);
 %! yi=linspace(min(y),max(y),41)';
 %! mesh(xi,yi,interp2(x,y,A,xi,yi,'linear'));
-%! [x,y] = meshgrid(x,y); 
+%! [x,y] = meshgrid(x,y);
 %! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! A=[13,-1,12;5,4,3;1,6,2];
 %! x=[0,1,4]; y=[10,11,12];
 %! xi=linspace(min(x),max(x),17);
 %! yi=linspace(min(y),max(y),26)';
 %! mesh(xi,yi,interp2(x,y,A,xi,yi,'nearest'));
-%! [x,y] = meshgrid(x,y); 
+%! [x,y] = meshgrid(x,y);
 %! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! [x,y,A] = peaks(10);
 %! x = x(1,:)'; y = y(:,1);
 %! xi=linspace(min(x),max(x),41);
 %! yi=linspace(min(y),max(y),41)';
 %! mesh(xi,yi,interp2(x,y,A,xi,yi,'nearest'));
-%! [x,y] = meshgrid(x,y); 
+%! [x,y] = meshgrid(x,y);
 %! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! A=[13,-1,12;5,4,3;1,6,2];
 %! x=[0,1,2]; y=[10,11,12];
 %! xi=linspace(min(x),max(x),17);
 %! yi=linspace(min(y),max(y),26)';
 %! mesh(xi,yi,interp2(x,y,A,xi,yi,'pchip'));
-%! [x,y] = meshgrid(x,y); 
+%! [x,y] = meshgrid(x,y);
 %! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! [x,y,A] = peaks(10);
 %! x = x(1,:)'; y = y(:,1);
 %! xi=linspace(min(x),max(x),41);
 %! yi=linspace(min(y),max(y),41)';
 %! mesh(xi,yi,interp2(x,y,A,xi,yi,'pchip'));
-%! [x,y] = meshgrid(x,y); 
+%! [x,y] = meshgrid(x,y);
 %! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! A=[13,-1,12;5,4,3;1,6,2];
 %! x=[0,1,2]; y=[10,11,12];
 %! xi=linspace(min(x),max(x),17);
 %! yi=linspace(min(y),max(y),26)';
 %! mesh(xi,yi,interp2(x,y,A,xi,yi,'cubic'));
-%! [x,y] = meshgrid(x,y); 
+%! [x,y] = meshgrid(x,y);
 %! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! [x,y,A] = peaks(10);
 %! x = x(1,:)'; y = y(:,1);
 %! xi=linspace(min(x),max(x),41);
 %! yi=linspace(min(y),max(y),41)';
 %! mesh(xi,yi,interp2(x,y,A,xi,yi,'cubic'));
-%! [x,y] = meshgrid(x,y); 
+%! [x,y] = meshgrid(x,y);
 %! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! A=[13,-1,12;5,4,3;1,6,2];
 %! x=[0,1,2]; y=[10,11,12];
 %! xi=linspace(min(x),max(x),17);
 %! yi=linspace(min(y),max(y),26)';
 %! mesh(xi,yi,interp2(x,y,A,xi,yi,'spline'));
-%! [x,y] = meshgrid(x,y); 
+%! [x,y] = meshgrid(x,y);
 %! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! [x,y,A] = peaks(10);
 %! x = x(1,:)'; y = y(:,1);
 %! xi=linspace(min(x),max(x),41);
 %! yi=linspace(min(y),max(y),41)';
 %! mesh(xi,yi,interp2(x,y,A,xi,yi,'spline'));
-%! [x,y] = meshgrid(x,y); 
+%! [x,y] = meshgrid(x,y);
 %! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
 
 %!test % simple test
 %!  x = [1,2,3];
 %!  y = [4,5,6,7];
 %!  [X, Y] = meshgrid(x,y);
 %!  Orig = X.^2 + Y.^3;
 %!  xi = [1.2,2, 1.5];
@@ -552,17 +552,17 @@ endfunction
 %!test % 2^n form
 %!  x = [1,2,3];
 %!  y = [4,5,6,7];
 %!  [X, Y] = meshgrid(x,y);
 %!  Orig = X.^2 + Y.^3;
 %!  xi = [1:0.25:3]; yi = [4:0.25:7]';
 %!  Expected = interp2(x,y,Orig, xi, yi);
 %!  Result = interp2(Orig,2);
-%!  
+%!
 %!  assert(Result, Expected, 10*eps);
 
 %!test % matrix slice
 %!  A = eye(4);
 %!  assert(interp2(A,[1:4],[1:4]),[1,1,1,1]);
 
 %!test % non-gridded XI,YI
 %!  A = eye(4);
@@ -575,17 +575,17 @@ endfunction
 %!  Orig = X.^2 + Y.^3;
 %!  xi = [0,4];
 %!  yi = [3,8]';
 %!  assert(interp2(x,y,Orig, xi, yi),[NA,NA;NA,NA]);
 %!  assert(interp2(x,y,Orig, xi, yi,'linear', 0),[0,0;0,0]);
 
 %!test % for values at boundaries
 %!  A=[1,2;3,4];
-%!  x=[0,1]; 
+%!  x=[0,1];
 %!  y=[2,3]';
 %!  assert(interp2(x,y,A,x,y,'linear'), A);
 %!  assert(interp2(x,y,A,x,y,'nearest'), A);
 
 %!test % for Matlab-compatible rounding for 'nearest'
 %! X = meshgrid (1:4);
 %! assert (interp2 (X, 2.5, 2.5, 'nearest'), 3);
 
diff --git a/scripts/general/interp3.m b/scripts/general/interp3.m
--- a/scripts/general/interp3.m
+++ b/scripts/general/interp3.m
@@ -19,29 +19,29 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{vi} =} interp3 (@var{x}, @var{y}, @var{z}, @var{v}, @var{xi}, @var{yi}, @var{zi})
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@var{v}, @var{xi}, @var{yi}, @var{zi})
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@var{v}, @var{m})
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@var{v})
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{vi} =} interp3 (@dots{}, @var{method}, @var{extrapval})
 ##
-## Perform 3-dimensional interpolation.  Each element of the 3-dimensional 
-## array @var{v} represents a value at a location given by the parameters 
-## @var{x}, @var{y}, and @var{z}.  The parameters @var{x}, @var{x}, and 
-## @var{z} are either 3-dimensional arrays of the same size as the array 
-## @var{v} in the 'meshgrid' format or vectors.  The parameters @var{xi}, etc. 
-## respect a similar format to @var{x}, etc., and they represent the points 
+## Perform 3-dimensional interpolation.  Each element of the 3-dimensional
+## array @var{v} represents a value at a location given by the parameters
+## @var{x}, @var{y}, and @var{z}.  The parameters @var{x}, @var{x}, and
+## @var{z} are either 3-dimensional arrays of the same size as the array
+## @var{v} in the 'meshgrid' format or vectors.  The parameters @var{xi}, etc.
+## respect a similar format to @var{x}, etc., and they represent the points
 ## at which the array @var{vi} is interpolated.
 ##
-## If @var{x}, @var{y}, @var{z} are omitted, they are assumed to be 
+## If @var{x}, @var{y}, @var{z} are omitted, they are assumed to be
 ## @code{x = 1 : size (@var{v}, 2)}, @code{y = 1 : size (@var{v}, 1)} and
 ## @code{z = 1 : size (@var{v}, 3)}.  If @var{m} is specified, then
-## the interpolation adds a point half way between each of the interpolation 
-## points.  This process is performed @var{m} times.  If only @var{v} is 
+## the interpolation adds a point half way between each of the interpolation
+## points.  This process is performed @var{m} times.  If only @var{v} is
 ## specified, then @var{m} is assumed to be @code{1}.
 ##
 ## Method is one of:
 ##
 ## @table @asis
 ## @item 'nearest'
 ## Return the nearest neighbor.
 ##
diff --git a/scripts/general/interpft.m b/scripts/general/interpft.m
--- a/scripts/general/interpft.m
+++ b/scripts/general/interpft.m
@@ -31,17 +31,17 @@
 ##
 ## @seealso{interp1}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
 ## 2001-02-11
 ##    * initial version
 ## 2002-03-17 aadler
-##    * added code to work on matrices as well 
+##    * added code to work on matrices as well
 ## 2006-05-25 dbateman
 ##    * Make it matlab compatiable, cutting out the 2-D interpolation
 
 function z = interpft (x, n, dim)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
diff --git a/scripts/general/interpn.m b/scripts/general/interpn.m
--- a/scripts/general/interpn.m
+++ b/scripts/general/interpn.m
@@ -19,29 +19,29 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{vi} =} interpn (@var{x1}, @var{x2}, @dots{}, @var{v}, @var{y1}, @var{y2}, @dots{})
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@var{v}, @var{y1}, @var{y2}, @dots{})
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@var{v}, @var{m})
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@var{v})
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@dots{}, @var{method})
 ## @deftypefnx {Function File} {@var{vi} =} interpn (@dots{}, @var{method}, @var{extrapval})
 ##
-## Perform @var{n}-dimensional interpolation, where @var{n} is at least two. 
-## Each element of the @var{n}-dimensional array @var{v} represents a value 
-## at a location given by the parameters @var{x1}, @var{x2}, @dots{}, @var{xn}. 
-## The parameters @var{x1}, @var{x2}, @dots{}, @var{xn} are either 
-## @var{n}-dimensional arrays of the same size as the array @var{v} in 
-## the 'ndgrid' format or vectors.  The parameters @var{y1}, etc. respect a 
+## Perform @var{n}-dimensional interpolation, where @var{n} is at least two.
+## Each element of the @var{n}-dimensional array @var{v} represents a value
+## at a location given by the parameters @var{x1}, @var{x2}, @dots{}, @var{xn}.
+## The parameters @var{x1}, @var{x2}, @dots{}, @var{xn} are either
+## @var{n}-dimensional arrays of the same size as the array @var{v} in
+## the 'ndgrid' format or vectors.  The parameters @var{y1}, etc. respect a
 ## similar format to @var{x1}, etc., and they represent the points at which
 ## the array @var{vi} is interpolated.
 ##
-## If @var{x1}, @dots{}, @var{xn} are omitted, they are assumed to be 
+## If @var{x1}, @dots{}, @var{xn} are omitted, they are assumed to be
 ## @code{x1 = 1 : size (@var{v}, 1)}, etc.  If @var{m} is specified, then
-## the interpolation adds a point half way between each of the interpolation 
-## points.  This process is performed @var{m} times.  If only @var{v} is 
+## the interpolation adds a point half way between each of the interpolation
+## points.  This process is performed @var{m} times.  If only @var{v} is
 ## specified, then @var{m} is assumed to be @code{1}.
 ##
 ## Method is one of:
 ##
 ## @table @asis
 ## @item 'nearest'
 ## Return the nearest neighbor.
 ##
@@ -107,17 +107,17 @@ function vi = interpn (varargin)
     v = varargin{1};
     sz = size (v);
     nd = ndims (v);
     x = cell (1, nd);
     y = varargin (2 : nargs);
     for i = 1 : nd;
       x{i} = 1 : sz(i);
     endfor
-  elseif (rem (nargs, 2) == 1 && nargs ==  
+  elseif (rem (nargs, 2) == 1 && nargs ==
           (2 * ndims (varargin{ceil (nargs / 2)})) + 1)
     nv = ceil (nargs / 2);
     v = varargin{nv};
     sz = size (v);
     nd = ndims (v);
     x = varargin (1 : (nv - 1));
     y = varargin ((nv + 1) : nargs);
   else
@@ -162,17 +162,17 @@ function vi = interpn (varargin)
       idx{i} = yidx{i} + (y{i} - x{i}(yidx{i})(:) >= x{i}(yidx{i} + 1)(:) - y{i});
     endfor
     vi = v (sub2ind (sz, idx{:}));
     idx = zeros (prod (yshape), 1);
     for i = 1 : nd
       idx |= y{i} < min (x{i}(:)) | y{i} > max (x{i}(:));
     endfor
     vi(idx) = extrapval;
-    vi = reshape (vi, yshape); 
+    vi = reshape (vi, yshape);
   elseif (strcmp (method, "spline"))
     if (any (! cellfun (@isvector, y)))
       for i = 2 : nd
         if (! size_equal (y{1}, y{i}))
           error ("interpn: dimensional mismatch");
         endif
         idx (1 : nd) = {1};
         idx (i) = ":";
@@ -191,58 +191,58 @@ function vi = interpn (varargin)
       q = cell (1, nd);
       for i = 1 : ly
         q(:) = i;
         idx {i} = q;
       endfor
       vi = vi (cellfun (@(x) sub2ind (size(vi), x{:}), idx));
       vi = reshape (vi, size(y{1}));
     endif
-  elseif (strcmp (method, "cubic")) 
+  elseif (strcmp (method, "cubic"))
     error ("interpn: cubic interpolation not yet implemented");
   else
     error ("interpn: unrecognized interpolation METHOD");
   endif
 
 endfunction
 
 %!demo
 %! A=[13,-1,12;5,4,3;1,6,2];
 %! x=[0,1,4]; y=[10,11,12];
 %! xi=linspace(min(x),max(x),17);
 %! yi=linspace(min(y),max(y),26)';
 %! mesh(xi,yi,interpn(x,y,A.',xi,yi,"linear").');
-%! [x,y] = meshgrid(x,y); 
+%! [x,y] = meshgrid(x,y);
 %! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! A=[13,-1,12;5,4,3;1,6,2];
 %! x=[0,1,4]; y=[10,11,12];
 %! xi=linspace(min(x),max(x),17);
 %! yi=linspace(min(y),max(y),26)';
 %! mesh(xi,yi,interpn(x,y,A.',xi,yi,"nearest").');
-%! [x,y] = meshgrid(x,y); 
+%! [x,y] = meshgrid(x,y);
 %! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
 
 %!#demo
 %! A=[13,-1,12;5,4,3;1,6,2];
 %! x=[0,1,2]; y=[10,11,12];
 %! xi=linspace(min(x),max(x),17);
 %! yi=linspace(min(y),max(y),26)';
 %! mesh(xi,yi,interpn(x,y,A.',xi,yi,"cubic").');
-%! [x,y] = meshgrid(x,y); 
+%! [x,y] = meshgrid(x,y);
 %! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
 
 %!demo
 %! A=[13,-1,12;5,4,3;1,6,2];
 %! x=[0,1,2]; y=[10,11,12];
 %! xi=linspace(min(x),max(x),17);
 %! yi=linspace(min(y),max(y),26)';
 %! mesh(xi,yi,interpn(x,y,A.',xi,yi,"spline").');
-%! [x,y] = meshgrid(x,y); 
+%! [x,y] = meshgrid(x,y);
 %! hold on; plot3(x(:),y(:),A(:),"b*"); hold off;
 
 
 %!demo
 %! x = y = z = -1:1;
 %! f = @(x,y,z) x.^2 - y - z.^2;
 %! [xx, yy, zz] = meshgrid (x, y, z);
 %! v = f (xx,yy,zz);
diff --git a/scripts/general/isdir.m b/scripts/general/isdir.m
--- a/scripts/general/isdir.m
+++ b/scripts/general/isdir.m
@@ -1,9 +1,9 @@
-## Copyright (C) 2004-2011 Alois Schloegl 
+## Copyright (C) 2004-2011 Alois Schloegl
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/general/loadobj.m b/scripts/general/loadobj.m
--- a/scripts/general/loadobj.m
+++ b/scripts/general/loadobj.m
@@ -13,18 +13,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{b} =} loadobj (@var{a})
-## Method of a class to manipulate an object after loading it from a file. 
-## The function @code{loadobj} is called when the object @var{a} is loaded 
+## Method of a class to manipulate an object after loading it from a file.
+## The function @code{loadobj} is called when the object @var{a} is loaded
 ## using the @code{load} function.  An example of the use of @code{saveobj}
 ## might be to add fields to an object that don't make sense to be saved.
 ## For example:
 ##
 ## @example
 ## @group
 ## function b = loadobj (a)
 ##   b = a;
diff --git a/scripts/general/logspace.m b/scripts/general/logspace.m
--- a/scripts/general/logspace.m
+++ b/scripts/general/logspace.m
@@ -48,17 +48,17 @@
 ## @end tex
 ## @ifnottex
 ## 10^base and 10^pi,
 ## @end ifnottex
 ## in order to be compatible with the corresponding @sc{matlab}
 ## function.
 ## If @var{n} is unspecified it defaults to 50.
 ##
-## Also for compatibility with @sc{matlab}, return the second argument if 
+## Also for compatibility with @sc{matlab}, return the second argument if
 ## fewer than two values are requested.
 ## @seealso{linspace}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = logspace (base, limit, n)
 
diff --git a/scripts/general/num2str.m b/scripts/general/num2str.m
--- a/scripts/general/num2str.m
+++ b/scripts/general/num2str.m
@@ -20,46 +20,46 @@
 ## @deftypefn  {Function File} {} num2str (@var{x})
 ## @deftypefnx {Function File} {} num2str (@var{x}, @var{precision})
 ## @deftypefnx {Function File} {} num2str (@var{x}, @var{format})
 ## Convert a number (or array) to a string (or a character array).  The
 ## optional second argument may either give the number of significant
 ## digits (@var{precision}) to be used in the output or a format
 ## template string (@var{format}) as in @code{sprintf} (@pxref{Formatted
 ## Output}).  @code{num2str} can also handle complex numbers.  For
-## example: 
+## example:
 ##
 ## @example
 ## @group
 ## num2str (123.456)
 ##      @result{} "123.46"
 ##
 ## num2str (123.456, 4)
 ##      @result{} "123.5"
 ##
 ## s = num2str ([1, 1.34; 3, 3.56], "%5.1f")
 ##      @result{} s =
 ##         1.0  1.3
 ##         3.0  3.6
 ## whos s
 ##      @result{}
 ##       Attr Name        Size                     Bytes  Class
-##       ==== ====        ====                     =====  ===== 
+##       ==== ====        ====                     =====  =====
 ##            s           2x8                         16  char
 ##
 ## num2str (1.234 + 27.3i)
 ##      @result{} "1.234+27.3i"
 ## @end group
 ## @end example
 ##
 ## The @code{num2str} function is not very flexible.  For better control
-## over the results, use @code{sprintf} (@pxref{Formatted Output}). 
+## over the results, use @code{sprintf} (@pxref{Formatted Output}).
 ## Note that for complex @var{x}, the format string may only contain one
 ## output conversion specification and nothing else.  Otherwise, you
-## will get unpredictable results.  
+## will get unpredictable results.
 ## @seealso{sprintf, int2str, mat2str}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = num2str (x, arg)
 
   if (nargin != 1 && nargin != 2)
@@ -86,17 +86,17 @@ function retval = num2str (x, arg)
       if (isnumeric (x) && round (x) == x && abs (x) < 1e10)
         if (max (abs (real (x(:)))) == 0)
           dgt1 = 2;
         else
           dgt1 = ceil (log10 (max (max (abs (real (x(:)))),
                                    max (abs (imag (x(:))))))) + 2;
         endif
         dgt2 = dgt1 - (min (real (x(:))) >= 0);
-        
+
         if (length (abs (x) == x) > 0)
           fmt = sprintf("%%%dg%%+-%dgi  ", dgt2, dgt1);
         else
           fmt = sprintf("%%%dd%%+-%ddi  ", dgt2, dgt1);
         endif
       elseif (isscalar (x))
         fmt = "%.6g%-+.6gi";
       else
diff --git a/scripts/general/pol2cart.m b/scripts/general/pol2cart.m
--- a/scripts/general/pol2cart.m
+++ b/scripts/general/pol2cart.m
@@ -22,20 +22,20 @@
 ## @deftypefnx {Function File} {[@var{x}, @var{y}] =} pol2cart (@var{p})
 ## @deftypefnx {Function File} {[@var{x}, @var{y}, @var{z}] =} pol2cart (@var{p})
 ## @deftypefnx {Function File} {@var{C} =} pol2cart (@dots{})
 ## Transform polar or cylindrical to Cartesian coordinates.
 ##
 ## @var{theta}, @var{r}, (and @var{z}) must be the same shape, or scalar.
 ## @var{theta} describes the angle relative to the positive x-axis.
 ## @var{r} is the distance to the z-axis (0, 0, z).
-## If called with a single matrix argument then each row of @var{p} 
+## If called with a single matrix argument then each row of @var{p}
 ## represents the polar/(cylindrical) coordinate (@var{x}, @var{y} (, @var{z})).
 ##
-## If only a single return argument is requested then return a matrix 
+## If only a single return argument is requested then return a matrix
 ## @var{C} where each row represents one Cartesian coordinate
 ## (@var{x}, @var{y} (, @var{z})).
 ## @seealso{cart2pol, sph2cart, cart2sph}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
@@ -48,17 +48,17 @@ function [x, y, z] = pol2cart (theta, r,
   if (nargin == 1)
     if (ismatrix (theta) && (columns (theta) == 2 || columns (theta) == 3))
       if (columns (theta) == 3)
         z = theta(:,3);
       else
         z = [];
       endif
       r = theta(:,2);
-      theta = theta(:,1);    
+      theta = theta(:,1);
     else
       error ("pol2car: matrix input must have 2 or 3 columns [THETA, R (, Z)]");
     endif
   elseif (nargin == 2)
     if (! ((ismatrix (theta) && ismatrix (r))
             && (size_equal (theta, r) || isscalar (theta) || isscalar (r))))
       error ("pol2cart: arguments must be matrices of same size, or scalar");
     endif
diff --git a/scripts/general/polyarea.m b/scripts/general/polyarea.m
--- a/scripts/general/polyarea.m
+++ b/scripts/general/polyarea.m
@@ -28,24 +28,24 @@
 ##
 ## If the optional @var{dim} argument is given, then @code{polyarea}
 ## works along this dimension of the arrays @var{x} and @var{y}.
 ##
 ## @end deftypefn
 
 ## todo:  Add moments for centroid, etc.
 ##
-## bugs and limitations:  
+## bugs and limitations:
 ##        Probably ought to be an optional check to make sure that
-##        traversing the vertices doesn't make any sides cross 
-##        (Is simple closed curve the technical definition of this?). 
+##        traversing the vertices doesn't make any sides cross
+##        (Is simple closed curve the technical definition of this?).
 
 ## Author: David M. Doolin <doolin@ce.berkeley.edu>
 ## Date: 1999-04-14
-## Modified-by: 
+## Modified-by:
 ##    2000-01-15 Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 ##    * use matlab compatible interface
 ##    * return absolute value of area so traversal order doesn't matter
 ##    2005-10-13 Torsten Finke
 ##    * optimization saving half the sums and multiplies
 
 function a = polyarea (x, y, dim)
   if (nargin != 2 && nargin != 3)
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -185,77 +185,77 @@ function [q, err] = quadgk (f, a, b, var
       ## contour integral, no transform
       subs = [a; waypoints; b];
       h = sum (abs (diff (subs)));
       h0 = h;
       trans = @(t) t;
     elseif (isinf (a) && isinf(b))
       ## Standard Infinite to finite integral transformation.
       ##   \int_{-\infinity_^\infinity f(x) dx = \int_-1^1 f (g(t)) g'(t) dt
-      ## where 
+      ## where
       ##   g(t)  = t / (1 - t^2)
       ##   g'(t) =  (1 + t^2) / (1 - t^2) ^ 2
       ## waypoint transform is then
       ##   t =  (2 * g(t)) ./ (1 + sqrt(1 + 4 * g(t) .^ 2))
       if (!isempty (waypoints))
         trans = @(x) (2 * x) ./ (1 + sqrt(1 + 4 * x .^ 2));
         subs = [-1; trans(waypoints); 1];
       else
-        subs = linspace (-1, 1, 11)'; 
+        subs = linspace (-1, 1, 11)';
       endif
       h = 2;
       h0 = b - a;
       trans = @(t) t ./ (1 - t.^2);
       f = @(t) f (t ./ (1 - t .^ 2)) .* (1 + t .^ 2) ./ ((1 - t .^ 2) .^ 2);
     elseif (isinf(a))
       ## Formula defined in Shampine paper as two separate steps. One to
       ## weaken singularity at finite end, then a second to transform to
       ## a finite interval. The singularity weakening transform is
-      ##   \int_{-\infinity}^b f(x) dx = 
+      ##   \int_{-\infinity}^b f(x) dx =
       ##               - \int_{-\infinity}^0 f (b - t^2) 2 t dt
       ## (note minus sign) and the finite interval transform is
-      ##   \int_{-\infinity}^0 f(b - t^2)  2 t dt = 
+      ##   \int_{-\infinity}^0 f(b - t^2)  2 t dt =
       ##                  \int_{-1}^0 f (b - g(s) ^ 2) 2 g(s) g'(s) ds
-      ## where 
+      ## where
       ##   g(s)  = s / (1 + s)
       ##   g'(s) = 1 / (1 + s) ^ 2
       ## waypoint transform is then
       ##   t = sqrt (b - x)
       ##   s =  - t / (t + 1)
       if (!isempty (waypoints))
         tmp = sqrt (b - waypoints);
         trans = @(x)  - x ./ (x + 1);
         subs = [0; trans(tmp); 1];
       else
-        subs = linspace (0, 1, 11)'; 
+        subs = linspace (0, 1, 11)';
       endif
       h = 1;
       h0 = b - a;
       trans = @(t) b - (t ./ (1 + t)).^2;
       f = @(s) - 2 * s .* f (b -  (s ./ (1 + s)) .^ 2) ./ ((1 + s) .^ 3);
     elseif (isinf(b))
       ## Formula defined in Shampine paper as two separate steps. One to
       ## weaken singularity at finite end, then a second to transform to
       ## a finite interval. The singularity weakening transform is
       ##   \int_a^\infinity f(x) dx = \int_0^\infinity f (a + t^2) 2 t dt
       ## and the finite interval transform is
-      ##  \int_0^\infinity f(a + t^2)  2 t dt = 
+      ##  \int_0^\infinity f(a + t^2)  2 t dt =
       ##           \int_0^1 f (a + g(s) ^ 2) 2 g(s) g'(s) ds
-      ## where 
+      ## where
       ##   g(s)  = s / (1 - s)
       ##   g'(s) = 1 / (1 - s) ^ 2
       ## waypoint transform is then
       ##   t = sqrt (x - a)
       ##   s = t / (t + 1)
       if (!isempty (waypoints))
         tmp = sqrt (waypoints - a);
         trans = @(x) x ./ (x + 1);
         subs = [0; trans(tmp); 1];
       else
-        subs = linspace (0, 1, 11)'; 
+        subs = linspace (0, 1, 11)';
       endif
       h = 1;
       h0 = b - a;
       trans = @(t) a + (t ./ (1 - t)).^2;
       f = @(s) 2 * s .* f (a +  (s ./ (1 - s)) .^ 2) ./ ((1 - s) .^ 3);
     else
       ## Davis, Rabinowitz, "Methods of Numerical Integration" p441 2ed.
       ## Presented in section 5 of the Shampine paper as
@@ -267,17 +267,17 @@ function [q, err] = quadgk (f, a, b, var
       ## ignored. The third is
       ##  c = (-4*x + 2*(b+a)) / (b-a);
       ##  k = ((sqrt(c^2 - 4) + c)/2)^(1/3);
       ##  t = (sqrt(3)* 1i * (1 - k^2) - (1 + k^2)) / 2 / k;
       if (! isempty (waypoints))
         trans = @__quadgk_finite_waypoint__;
         subs = [-1; trans(waypoints, a, b); 1];
       else
-        subs = linspace(-1, 1, 11)'; 
+        subs = linspace(-1, 1, 11)';
       endif
       h = 2;
       h0 = b - a;
       trans = @(t) ((b - a) ./ 4) * t .* (3 - t.^2) + (b + a) ./ 2;
       f = @(t) f((b - a) ./ 4 .* t .* (3 - t.^2) + (b + a) ./ 2) .* ...
            3 .* (b - a) ./ 4 .* (1 - t.^2);
     endif
 
@@ -293,17 +293,17 @@ function [q, err] = quadgk (f, a, b, var
     unwind_protect
       ## Singularity will cause divide by zero warnings
       warning ("off", "Octave:divide-by-zero");
 
       ## Initial evaluation of the integrand on the sub-intervals
       [q_subs, q_errs] = __quadgk_eval__ (f, subs);
       q0 = sum (q_subs);
       err0 = sum (q_errs);
-    
+
       if (isa (a, "single") || isa (b, "single") || isa (waypoints, "single"))
         myeps = eps ("single");
       else
         myeps = eps;
       endif
 
       first = true;
       while (true)
@@ -313,17 +313,17 @@ function [q, err] = quadgk (f, a, b, var
         if (any (abs (diff (trans (subs), [], 2) / h0) < 100 * myeps))
           q = q0;
           err = err0;
           break;
         endif
 
         ## Quit if any evaluations are not finite (Inf or NaN)
         if (any (! isfinite (q_subs)))
-          warning ("quadgk: non finite integrand encountered"); 
+          warning ("quadgk: non finite integrand encountered");
           q = q0;
           err = err0;
           break;
         endif
 
         tol = max (abstol, reltol .* abs (q0));
 
         ## If the global error estimate is meet exit
@@ -372,17 +372,17 @@ function [q, err] = quadgk (f, a, b, var
         ## Evaluation of the integrand on the remaining sub-intervals
         [q_subs, q_errs] = __quadgk_eval__ (f, subs);
       endwhile
 
       if (err > max (abstol, reltol * abs(q)))
         warning ("quadgk: Error tolerance not met. Estimated error %g", err);
       endif
     unwind_protect_cleanup
-      if (strcmp (warn_state.state, "on")) 
+      if (strcmp (warn_state.state, "on"))
         warning ("on", "Octave:divide-by-zero");
       endif
     end_unwind_protect
   endif
 endfunction
 
 function [q, err] = __quadgk_eval__ (f, subs)
   ## A (15,7) point pair of Gauss-Konrod quadrature rules. The abscissa
diff --git a/scripts/general/quadl.m b/scripts/general/quadl.m
--- a/scripts/general/quadl.m
+++ b/scripts/general/quadl.m
@@ -26,24 +26,24 @@
 ## @code{quadl (@var{f}, @var{a}, @var{b})} approximates the integral of
 ## @code{@var{f}(@var{x})} to machine precision.  @var{f} is either a
 ## function handle, inline function or string containing the name of
 ## the function to evaluate.  The function @var{f} must return a vector
 ## of output values if given a vector of input values.
 ##
 ## If defined, @var{tol} defines the relative tolerance to which to
 ## which to integrate @code{@var{f}(@var{x})}.  While if @var{trace} is
-## defined, displays the left end point of the current interval, the 
+## defined, displays the left end point of the current interval, the
 ## interval length, and the partial integral.
 ##
 ## Additional arguments @var{p1}, etc., are passed directly to @var{f}.
 ## To use default values for @var{tol} and @var{trace}, one may pass
 ## empty matrices.
 ##
-## Reference: W. Gander and W. Gautschi, @cite{Adaptive Quadrature - 
+## Reference: W. Gander and W. Gautschi, @cite{Adaptive Quadrature -
 ## Revisited}, BIT Vol. 40, No. 1, March 2000, pp. 84--101.
 ## @url{http://www.inf.ethz.ch/personal/gander/}
 ## @seealso{quad,quadv,quadgk,quadcc,trapz,dblquad,triplequad}
 ## @end deftypefn
 
 ##   Author: Walter Gautschi
 ##   Date: 08/03/98
 ##   Reference: Gander, Computermathematik, Birkhaeuser, 1992.
@@ -53,51 +53,51 @@
 ## 2004-02-10 Paul Kienzle
 ##   * renamed to quadl for compatibility
 ##   * replace global variable terminate2 with local function need_warning
 ##   * add paper ref to docs
 
 function Q = quadl (f, a, b, tol, trace, varargin)
   need_warning (1);
   if (nargin < 4)
-    tol = []; 
+    tol = [];
   endif
   if (nargin < 5)
-    trace = []; 
+    trace = [];
   endif
   if (isa (a, "single") || isa (b, "single"))
     myeps = eps ("single");
   else
     myeps = eps;
   endif
   if (isempty (tol))
-    tol = myeps; 
+    tol = myeps;
   endif
   if (isempty (trace))
-    trace = 0; 
+    trace = 0;
   endif
   if (tol < myeps)
     tol = myeps;
   endif
 
-  m = (a+b)/2; 
+  m = (a+b)/2;
   h = (b-a)/2;
-  alpha = sqrt(2/3); 
+  alpha = sqrt(2/3);
   beta = 1/sqrt(5);
 
-  x1 = .942882415695480; 
+  x1 = .942882415695480;
   x2 = .641853342345781;
   x3 = .236383199662150;
 
   x = [a, m-x1*h, m-alpha*h, m-x2*h, m-beta*h, m-x3*h, m, m+x3*h, ...
        m+beta*h, m+x2*h, m+alpha*h, m+x1*h, b];
 
   y = feval (f, x, varargin{:});
 
-  fa = y(1); 
+  fa = y(1);
   fb = y(13);
 
   i2 = (h/6)*(y(1) + y(13) + 5*(y(5)+y(9)));
 
   i1 = (h/1470)*(77*(y(1)+y(13))
                  + 432*(y(3)+y(11))
                  + 625*(y(5)+y(9))
                  + 672*y(7));
@@ -105,29 +105,29 @@ function Q = quadl (f, a, b, tol, trace,
   is = h*(.0158271919734802*(y(1)+y(13))
           +.0942738402188500*(y(2)+y(12))
           + .155071987336585*(y(3)+y(11))
           + .188821573960182*(y(4)+y(10))
           + .199773405226859*(y(5)+y(9))
           + .224926465333340*(y(6)+y(8))
           + .242611071901408*y(7));
 
-  s = sign(is); 
+  s = sign(is);
 
   if (s == 0)
     s = 1;
   endif
   erri1 = abs(i1-is);
   erri2 = abs(i2-is);
-  R = 1; 
+  R = 1;
   if (erri2 != 0)
-    R = erri1/erri2; 
+    R = erri1/erri2;
   endif
   if (R > 0 && R < 1)
-    tol = tol/R; 
+    tol = tol/R;
   endif
   is = s*abs(is)*tol/myeps;
   if (is == 0)
     is = b-a;
   endif
   Q = adaptlobstp (f, a, b, fa, fb, is, trace, varargin{:});
 endfunction
 
@@ -137,30 +137,30 @@ endfunction
 ##   approximate the integral of F(X) from A to B to
 ##   an appropriate relative error. The argument 'F' is
 ##   a string containing the name of f.  The remaining
 ##   arguments are generated by ADAPTLOB or by recursion.
 ##
 ##   Walter Gautschi, 08/03/98
 
 function Q = adaptlobstp (f, a, b, fa, fb, is, trace, varargin)
-  h = (b-a)/2; 
+  h = (b-a)/2;
   m = (a+b)/2;
-  alpha = sqrt(2/3); 
+  alpha = sqrt(2/3);
   beta = 1/sqrt(5);
-  mll = m-alpha*h; 
-  ml = m-beta*h; 
-  mr = m+beta*h; 
+  mll = m-alpha*h;
+  ml = m-beta*h;
+  mr = m+beta*h;
   mrr = m+alpha*h;
   x = [mll, ml, m, mr, mrr];
   y = feval(f, x, varargin{:});
-  fmll = y(1); 
-  fml = y(2); 
-  fm = y(3); 
-  fmr = y(4); 
+  fmll = y(1);
+  fml = y(2);
+  fm = y(3);
+  fmr = y(4);
   fmrr = y(5);
   i2 = (h/6)*(fa + fb + 5*(fml+fmr));
   i1 = (h/1470)*(77*(fa+fb) + 432*(fmll+fmrr) + 625*(fml+fmr) + 672*fm);
   if (is+(i1-i2) == is || mll <= a || b <= mrr)
     if ((m <= a || b <= m) && need_warning ())
       warning ("quadl: interval contains no more machine number");
       warning ("quadl: required tolerance may not be met");
       need_warning (0);
@@ -178,12 +178,12 @@ function Q = adaptlobstp (f, a, b, fa, f
          + adaptlobstp (f, mrr, b, fmrr, fb, is, trace, varargin{:}));
   endif
 endfunction
 
 function r = need_warning (v)
   persistent w = [];
   if (nargin == 0)
     r = w;
-  else 
-    w = v; 
+  else
+    w = v;
   endif
 endfunction
diff --git a/scripts/general/quadv.m b/scripts/general/quadv.m
--- a/scripts/general/quadv.m
+++ b/scripts/general/quadv.m
@@ -18,23 +18,23 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{q} =} quadv (@var{f}, @var{a}, @var{b})
 ## @deftypefnx {Function File} {@var{q} =} quadv (@var{f}, @var{a}, @var{b}, @var{tol})
 ## @deftypefnx {Function File} {@var{q} =} quadv (@var{f}, @var{a}, @var{b}, @var{tol}, @var{trace})
 ## @deftypefnx {Function File} {@var{q} =} quadv (@var{f}, @var{a}, @var{b}, @var{tol}, @var{trace}, @var{p1}, @var{p2}, @dots{})
 ## @deftypefnx {Function File} {[@var{q}, @var{fcnt}] =} quadv (@dots{})
 ##
-## Numerically evaluate the integral of @var{f} from @var{a} to @var{b} 
+## Numerically evaluate the integral of @var{f} from @var{a} to @var{b}
 ## using adaptive Simpson's rule.
 ## @var{f} is either a function handle, inline function or string
-## containing the name of the function to evaluate. 
+## containing the name of the function to evaluate.
 ## The function defined by @var{f} may be a scalar, vector or array-valued.
 ##
-## If a value for @var{tol} is given, it defines the tolerance used to stop 
+## If a value for @var{tol} is given, it defines the tolerance used to stop
 ## the adaptation procedure, otherwise the default value of 1e-6 is used.
 ##
 ## The algorithm used by @code{quadv}, involves recursively subdividing the
 ## integration interval and applying Simpson's rule on each sub-interval.
 ## If @var{trace} is @var{true}, after computing each of these partial
 ## integrals, display the total number of function evaluations, the left end
 ## of the sub-interval, the length of the sub-interval and the approximation
 ## of the integral over the sub-interval.
@@ -46,31 +46,31 @@
 ##@seealso{quad, quadl, quadgk, quadcc, trapz, dblquad, triplequad}
 ## @end deftypefn
 
 function [q, fcnt] = quadv (f, a, b, tol, trace, varargin)
   if (nargin < 3)
     print_usage ();
   endif
   if (nargin < 4)
-    tol = []; 
+    tol = [];
   endif
   if (nargin < 5)
-    trace = []; 
+    trace = [];
   endif
   if (isa (a, "single") || isa (b, "single"))
     myeps = eps ("single");
   else
     myeps = eps;
   endif
   if (isempty (tol))
-    tol = 1e-6; 
+    tol = 1e-6;
   endif
   if (isempty (trace))
-    trace = 0; 
+    trace = 0;
   endif
 
   ## Split the interval into 3 abscissa, and apply a 3 point Simpson's rule
   c = (a + b) / 2;
   fa = feval (f, a, varargin{:});
   fc = feval (f, c, varargin{:});
   fb = feval (f, b, varargin{:});
   fcnt = 3;
@@ -81,30 +81,30 @@ function [q, fcnt] = quadv (f, a, b, tol
     fa = feval (f, a + myeps * (b-a), varargin{:});
   endif
   if (isinf (fb))
     fb = feval (f, b - myeps * (b-a), varargin{:});
   endif
 
   h = (b - a);
   q = (b - a) / 6 * (fa + 4 * fc + fb);
- 
-  [q, fcnt, hmin] = simpsonstp (f, a, b, c, fa, fb, fc, q, fcnt, abs (h), 
+
+  [q, fcnt, hmin] = simpsonstp (f, a, b, c, fa, fb, fc, q, fcnt, abs (h),
                                 tol, trace, varargin{:});
 
   if (fcnt > 10000)
     warning ("maximum iteration count reached");
   elseif (isnan (q) || isinf (q))
     warning ("infinite or NaN function evaluations were returned");
   elseif (hmin < (b - a) * myeps)
     warning ("minimum step size reached -- possibly singular integral");
   endif
 endfunction
 
-function [q, fcnt, hmin] = simpsonstp (f, a, b, c, fa, fb, fc, q0, 
+function [q, fcnt, hmin] = simpsonstp (f, a, b, c, fa, fb, fc, q0,
                                        fcnt, hmin, tol, trace, varargin)
   if (fcnt > 10000)
     q = q0;
   else
     d = (a + c) / 2;
     e = (c + b) / 2;
     fd = feval (f, d, varargin{:});
     fe = feval (f, e, varargin{:});
diff --git a/scripts/general/randi.m b/scripts/general/randi.m
--- a/scripts/general/randi.m
+++ b/scripts/general/randi.m
@@ -17,22 +17,22 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} randi (@var{imax})
 ## @deftypefnx {Function File} {} randi (@var{imax}, @var{n})
 ## @deftypefnx {Function File} {} randi (@var{imax}, @var{m}, @var{n}, @dots{})
 ## @deftypefnx {Function File} {} randi ([@var{imin}, @var{imax}], @dots{})
 ## @deftypefnx {Function File} {} randi (@dots{}, "@var{class}")
-## Return random integers in the range 1:@var{imax}.  
+## Return random integers in the range 1:@var{imax}.
 ##
 ## Additional arguments determine the shape of the return matrix.  When no
 ## arguments are specified a single random integer is returned.  If one
 ## argument @var{n} is specified then a square matrix @w{(@var{n} x @var{n})} is
-## returned.  Two or more arguments will return a multi-dimensional 
+## returned.  Two or more arguments will return a multi-dimensional
 ## matrix @w{(@var{m} x @var{n} x @dots{})}.
 ##
 ## The integer range may optionally be described by a two element matrix
 ## with a lower and upper bound in which case the returned integers will be
 ## on the interval @w{[@var{imin}, @var{imax}]}.
 ##
 ## The optional argument "@var{class}" will return a matrix of the requested
 ## type.  The default is "double".
@@ -40,17 +40,17 @@
 ## The following example returns 150 integers in the range 1-10.
 ##
 ## @example
 ## ri = randi (10, 150, 1);
 ## @end example
 ##
 ## Implementation Note: @code{randi} relies internally on @code{rand} which
 ## uses class "double" to represent numbers.  This limits the maximum
-## integer (@var{imax}) and range (@var{imax} - @var{imin}) to the value 
+## integer (@var{imax}) and range (@var{imax} - @var{imin}) to the value
 ## returned by the @code{bitmax} function.  For IEEE floating point numbers
 ## this value is @w{@code{2^53 - 1}}.
 ##
 ## @seealso{rand}
 ## @end deftypefn
 
 ## Author: Rik Wehbring
 
@@ -64,25 +64,25 @@ function ri = randi (bounds, varargin)
     error ("randi: IMIN and IMAX must be real numeric bounds");
   endif
 
   if (isscalar (bounds))
     imin = 1;
     imax = fix (bounds);
     if (imax < 1)
       error ("randi: require IMAX >= 1");
-    endif  
+    endif
   else
     imin = fix (bounds(1));
     imax = fix (bounds(2));
     if (imax < imin)
       error ("randi: require IMIN <= IMAX");
-    endif 
+    endif
   endif
-  
+
   if (nargin > 1 && ischar (varargin{end}))
     rclass = varargin{end};
     varargin(end) = [];
   else
     rclass = "double";
   endif
 
   if (strfind (rclass, "int"))
@@ -90,17 +90,17 @@ function ri = randi (bounds, varargin)
       error ("randi: require IMAX < intmax (CLASS)");
     endif
   elseif (strcmp (rclass, "single"))
     if (imax > bitmax (rclass))
       error ("randi: require IMAX < bitmax (CLASS)");
     endif
   endif
   ## Limit set by use of class double in rand()
-  if (imax > bitmax) 
+  if (imax > bitmax)
     error ("randi: maximum integer IMAX must be smaller than bitmax ()");
   endif
   if ((imax - imin) > bitmax)
     error ("randi: maximum integer range must be smaller than bitmax ()");
   endif
 
 
   ri = imin + floor ( (imax-imin+1)*rand (varargin{:}) );
diff --git a/scripts/general/rat.m b/scripts/general/rat.m
--- a/scripts/general/rat.m
+++ b/scripts/general/rat.m
@@ -21,17 +21,17 @@
 ## @deftypefnx {Function File} {[@var{n}, @var{d}] =} rat (@var{x}, @var{tol})
 ##
 ## Find a rational approximation to @var{x} within the tolerance defined
 ## by @var{tol} using a continued fraction expansion.  For example:
 ##
 ## @example
 ## @group
 ## rat(pi) = 3 + 1/(7 + 1/16) = 355/113
-## rat(e) = 3 + 1/(-4 + 1/(2 + 1/(5 + 1/(-2 + 1/(-7))))) 
+## rat(e) = 3 + 1/(-4 + 1/(2 + 1/(5 + 1/(-2 + 1/(-7)))))
 ##        = 1457/536
 ## @end group
 ## @end example
 ##
 ## Called with two arguments returns the numerator and denominator separately
 ## as two matrices.
 ## @end deftypefn
 ## @seealso{rats}
diff --git a/scripts/general/repmat.m b/scripts/general/repmat.m
--- a/scripts/general/repmat.m
+++ b/scripts/general/repmat.m
@@ -17,17 +17,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} repmat (@var{A}, @var{m}, @var{n})
 ## @deftypefnx {Function File} {} repmat (@var{A}, [@var{m} @var{n}])
 ## @deftypefnx {Function File} {} repmat (@var{A}, [@var{m} @var{n} @var{p} @dots{}])
 ## Form a block matrix of size @var{m} by @var{n}, with a copy of matrix
-## @var{A} as each element.  If @var{n} is not specified, form an 
+## @var{A} as each element.  If @var{n} is not specified, form an
 ## @var{m} by @var{m} block matrix.
 ## @seealso{repelems}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@kienzle.powernet.co.uk>
 ## Created: July 2000
 
 function x = repmat (A, m, n)
@@ -36,28 +36,28 @@ function x = repmat (A, m, n)
     print_usage ();
   endif
 
   if (nargin == 3)
     if (! (isscalar (m) && isscalar (n)))
       error ("repmat: with 3 arguments M and N must be scalar");
     endif
     idx = [m, n];
-  else 
+  else
     if (isscalar (m))
       idx = [m, m];
       n = m;
     elseif (isvector (m) && length (m) > 1)
       ## Ensure that we have a row vector
       idx = m(:).';
     else
       error ("repmat: invalid dimensional argument");
     endif
   endif
-  
+
   if (all (idx < 0))
     error ("repmat: invalid dimensions");
   else
     idx = max (idx, 0);
   endif
 
   if (numel (A) == 1)
     ## optimize the scalar fill case.
diff --git a/scripts/general/rot90.m b/scripts/general/rot90.m
--- a/scripts/general/rot90.m
+++ b/scripts/general/rot90.m
@@ -39,17 +39,17 @@
 ## @example
 ## @group
 ## rot90 ([1, 2; 3, 4], -1)
 ## rot90 ([1, 2; 3, 4], 3)
 ## rot90 ([1, 2; 3, 4], 7)
 ## @end group
 ## @end example
 ##
-## Due to the difficulty of defining an axis about which to rotate the 
+## Due to the difficulty of defining an axis about which to rotate the
 ## matrix @code{rot90} only work with 2-D arrays.  To rotate N-d arrays
 ## use @code{rotdim} instead.
 ## @seealso{rotdim, flipud, fliplr, flipdim}
 ## @end deftypefn
 
 ## Author: jwe
 
 function B = rot90 (A, k)
@@ -90,17 +90,17 @@ function B = rot90 (A, k)
 
 endfunction
 
 %!test
 %! x1 = [1, 2; 3, 4];
 %! x2 = [2, 4; 1, 3];
 %! x3 = [4, 3; 2, 1];
 %! x4 = [3, 1; 4, 2];
-%! 
+%!
 %! assert(rot90 (x1) == x2);
 %! assert(rot90 (x1, 2) == x3);
 %! assert(rot90 (x1, 3) == x4);
 %! assert(rot90 (x1, 4) == x1);
 %! assert(rot90 (x1, 5) == x2);
 %! assert(rot90 (x1, -1) == x4);
 
 %% Test input validation
diff --git a/scripts/general/rotdim.m b/scripts/general/rotdim.m
--- a/scripts/general/rotdim.m
+++ b/scripts/general/rotdim.m
@@ -47,17 +47,17 @@
 ## rotdim ([1, 2; 3, 4], 3, [1, 2])
 ## rotdim ([1, 2; 3, 4], 7, [1, 2])
 ## @end group
 ## @end example
 ## @seealso{rot90, flipud, fliplr, flipdim}
 ## @end deftypefn
 
 function y = rotdim (x, n, plane)
-  
+
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
   if (nargin > 1 && ! isempty(n))
     if (!isscalar (n) || !isreal(n) || fix (n) != n)
       error ("rotdim: N must be a scalar integer");
     endif
diff --git a/scripts/general/saveobj.m b/scripts/general/saveobj.m
--- a/scripts/general/saveobj.m
+++ b/scripts/general/saveobj.m
@@ -13,18 +13,18 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{b} =} saveobj (@var{a})
-## Method of a class to manipulate an object prior to saving it to a file. 
-## The function @code{saveobj} is called when the object @var{a} is saved 
+## Method of a class to manipulate an object prior to saving it to a file.
+## The function @code{saveobj} is called when the object @var{a} is saved
 ## using the @code{save} function.  An example of the use of @code{saveobj}
 ## might be to remove fields of the object that don't make sense to be saved
 ## or it might be used to ensure that certain fields of the object are
 ## initialized before the object is saved.  For example:
 ##
 ## @example
 ## @group
 ## function b = saveobj (a)
diff --git a/scripts/general/shift.m b/scripts/general/shift.m
--- a/scripts/general/shift.m
+++ b/scripts/general/shift.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} shift (@var{x}, @var{b})
 ## @deftypefnx {Function File} {} shift (@var{x}, @var{b}, @var{dim})
 ## If @var{x} is a vector, perform a circular shift of length @var{b} of
 ## the elements of @var{x}.
 ##
 ## If @var{x} is a matrix, do the same for each column of @var{x}.
-## If the optional @var{dim} argument is given, operate along this 
+## If the optional @var{dim} argument is given, operate along this
 ## dimension.
 ## @end deftypefn
 
 ## Author: AW <Andreas.Weingessel@ci.tuwien.ac.at>
 ## Created: 14 September 1994
 ## Adapted-By: jwe
 
 function y = shift (x, b, dim)
@@ -77,20 +77,20 @@ function y = shift (x, b, dim)
   y = x(idx{:});
 
 endfunction
 
 %!test
 %! a = [1, 2, 3];
 %! b = [4, 5, 6];
 %! c = [7, 8, 9];
-%! 
+%!
 %! r = [a, b, c];
 %! m = [a; b; c];
-%! 
+%!
 %! assert((shift (r, 3) == [c, a, b]
 %! && shift (r, -6) == [c, a, b]
 %! && shift (r, -3) == [b, c, a]
 %! && shift (m, 1) == [c; a; b]
 %! && shift (m, -2) == [c; a; b]));
 
 %!error shift ();
 
diff --git a/scripts/general/sortrows.m b/scripts/general/sortrows.m
--- a/scripts/general/sortrows.m
+++ b/scripts/general/sortrows.m
@@ -16,18 +16,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} sortrows (@var{A}, @var{c})
 ## Sort the rows of the matrix @var{A} according to the order of the
 ## columns specified in @var{c}.  If @var{c} is omitted, a
-## lexicographical sort is used.  By default ascending order is used 
-## however if elements of @var{c} are negative then the corresponding  
+## lexicographical sort is used.  By default ascending order is used
+## however if elements of @var{c} are negative then the corresponding
 ## column is sorted in descending order.
 ## @end deftypefn
 
 ## Author: Daniel Calvelo, Paul Kienzle
 ## Adapted-by: jwe
 
 function [s, i] = sortrows (A, c)
 
diff --git a/scripts/general/sph2cart.m b/scripts/general/sph2cart.m
--- a/scripts/general/sph2cart.m
+++ b/scripts/general/sph2cart.m
@@ -21,19 +21,19 @@
 ## @deftypefnx {Function File} {[@var{x}, @var{y}, @var{z}] =} sph2cart (@var{S})
 ## @deftypefnx {Function File} {C =} sph2cart (@dots{})
 ## Transform spherical to Cartesian coordinates.
 ##
 ## @var{theta} describes the angle relative to the positive x-axis.
 ## @var{phi} is the angle relative to the xy-plane.
 ## @var{r} is the distance to the origin @w{(0, 0, 0)}.
 ## @var{theta}, @var{phi}, and @var{r} must be the same shape, or scalar.
-## If called with a single matrix argument then each row of @var{s} 
+## If called with a single matrix argument then each row of @var{s}
 ## represents the spherical coordinate (@var{theta}, @var{phi}, @var{r}).
-## 
+##
 ## If only a single return argument is requested then return a matrix
 ## @var{C} where each row represents one Cartesian coordinate
 ## (@var{x}, @var{y}, @var{z}).
 ## @seealso{cart2sph, pol2cart, cart2pol}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
@@ -41,19 +41,19 @@
 function [x, y, z] = sph2cart (theta, phi, r)
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
   if (nargin == 1)
     if (ismatrix (theta) && columns (theta) == 3)
-      r = theta(:,3);    
-      phi = theta(:,2);    
-      theta = theta(:,1);    
+      r = theta(:,3);
+      phi = theta(:,2);
+      theta = theta(:,1);
     else
       error ("sph2cart: matrix input must have 3 columns [THETA, PHI, R]");
     endif
   elseif (nargin == 3)
     if (! ((ismatrix (theta) && ismatrix (phi) && ismatrix (r))
             && (size_equal (theta, phi) || isscalar (theta) || isscalar (phi))
             && (size_equal (theta, r) || isscalar (theta) || isscalar (r))
             && (size_equal (phi, r) || isscalar (phi) || isscalar (r))))
diff --git a/scripts/general/structfun.m b/scripts/general/structfun.m
--- a/scripts/general/structfun.m
+++ b/scripts/general/structfun.m
@@ -17,63 +17,63 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} structfun (@var{func}, @var{S})
 ## @deftypefnx {Function File} {[@var{A}, @dots{}] =} structfun (@dots{})
 ## @deftypefnx {Function File} {} structfun (@dots{}, "ErrorHandler", @var{errfunc})
 ## @deftypefnx {Function File} {} structfun (@dots{}, "UniformOutput", @var{val})
-## 
+##
 ## Evaluate the function named @var{name} on the fields of the structure
 ## @var{S}.  The fields of @var{S} are passed to the function @var{func}
 ## individually.
 ##
-## @code{structfun} accepts an arbitrary function @var{func} in the form of 
-## an inline function, function handle, or the name of a function (in a 
-## character string).  In the case of a character string argument, the 
-## function must accept a single argument named @var{x}, and it must return 
+## @code{structfun} accepts an arbitrary function @var{func} in the form of
+## an inline function, function handle, or the name of a function (in a
+## character string).  In the case of a character string argument, the
+## function must accept a single argument named @var{x}, and it must return
 ## a string value.  If the function returns more than one argument, they are
 ## returned as separate output variables.
 ##
 ## If the parameter "UniformOutput" is set to true (the default), then the
 ## function
 ## must return a single element which will be concatenated into the
 ## return value.  If "UniformOutput" is false, the outputs are placed into a
 ## structure
 ## with the same fieldnames as the input structure.
-## 
+##
 ## @example
 ## @group
-## s.name1 = "John Smith"; 
-## s.name2 = "Jill Jones"; 
-## structfun (@@(x) regexp (x, '(\w+)$', "matches")@{1@}, s, 
+## s.name1 = "John Smith";
+## s.name2 = "Jill Jones";
+## structfun (@@(x) regexp (x, '(\w+)$', "matches")@{1@}, s,
 ##            "UniformOutput", false)
 ##     @result{}
 ##    @{
 ##      name1 = Smith
 ##      name2 = Jones
-##    @} 
+##    @}
 ## @end group
 ## @end example
-## 
+##
 ## Given the parameter "ErrorHandler", @var{errfunc} defines a function to
 ## call in case @var{func} generates an error.  The form of the function is
-## 
+##
 ## @example
 ## function [@dots{}] = errfunc (@var{se}, @dots{})
 ## @end example
-## 
+##
 ## @noindent
 ## where there is an additional input argument to @var{errfunc} relative to
 ## @var{func}, given by @var{se}.  This is a structure with the elements
 ## "identifier", "message" and "index", giving respectively the error
 ## identifier, the error message, and the index into the input arguments
 ## of the element that caused the error.  For an example on how to use
-## an error handler, @pxref{doc-cellfun, @code{cellfun}}. 
+## an error handler, @pxref{doc-cellfun, @code{cellfun}}.
 ##
 ## @seealso{cellfun, arrayfun, spfun}
 ## @end deftypefn
 
 function varargout = structfun (func, S, varargin);
 
   if (nargin < 2)
     print_usage ();
@@ -107,21 +107,21 @@ function varargout = structfun (func, S,
 
   if (! uniform_output)
     varargout = cellfun (@cell2struct, varargout, {fieldnames(S)}, {1}, uo_str, false);
   endif
 endfunction
 
 
 %!test
-%! s.name1 = "John Smith"; 
-%! s.name2 = "Jill Jones"; 
+%! s.name1 = "John Smith";
+%! s.name2 = "Jill Jones";
 %! l.name1 = "Smith";
 %! l.name2 = "Jones";
-%! o = structfun (@(x) regexp (x, '(\w+)$', "matches"){1}, s, 
+%! o = structfun (@(x) regexp (x, '(\w+)$', "matches"){1}, s,
 %!                "UniformOutput", false);
 %! assert (o, l);
 
 %!function [a, b] = twoouts (x)
 %! a = x + x;
 %! b = x * x;
 
 %!test
diff --git a/scripts/general/subsindex.m b/scripts/general/subsindex.m
--- a/scripts/general/subsindex.m
+++ b/scripts/general/subsindex.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{idx} =} subsindex (@var{a})
-## Convert an object to an index vector.  When @var{a} is a class object 
+## Convert an object to an index vector.  When @var{a} is a class object
 ## defined with a class constructor, then @code{subsindex} is the
 ## overloading method that allows the conversion of this class object to
 ## a valid indexing vector.  It is important to note that
 ## @code{subsindex} must return a zero-based real integer vector of the
 ## class "double".  For example, if the class constructor
 ##
 ## @example
 ## @group
diff --git a/scripts/general/trapz.m b/scripts/general/trapz.m
--- a/scripts/general/trapz.m
+++ b/scripts/general/trapz.m
@@ -15,33 +15,33 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{z} =} trapz (@var{y})
 ## @deftypefnx {Function File} {@var{z} =} trapz (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{z} =} trapz (@dots{}, @var{dim})
-## 
+##
 ## Numerical integration using trapezoidal method.  @code{trapz
 ## (@var{y})} computes the integral of the @var{y} along the first
-## non-singleton dimension.  If the argument @var{x} is omitted a 
-## equally spaced vector is assumed.  @code{trapz (@var{x}, @var{y})} 
+## non-singleton dimension.  If the argument @var{x} is omitted a
+## equally spaced vector is assumed.  @code{trapz (@var{x}, @var{y})}
 ## evaluates the integral with respect to @var{x}.
-##  
+##
 ## @seealso{cumtrapz}
 ## @end deftypefn
 
 ## Author:      Kai Habel <kai.habel@gmx.de>
 ##
-## also: June 2000 - Paul Kienzle (fixes,suggestions) 
+## also: June 2000 - Paul Kienzle (fixes,suggestions)
 ## 2006-05-12 David Bateman - Modified for NDArrays
 
 function z = trapz (x, y, dim)
-        
+
   if (nargin < 1) || (nargin > 3)
     print_usage ();
   endif
 
   nd = ndims (x);
   sz = size (x);
 
   have_x = false;
@@ -66,33 +66,33 @@ function z = trapz (x, y, dim)
       dim = 1;
     endif
   else
     dim = floor (dim);
     if (dim < 1 || dim > nd)
       error ("trapz: invalid dimension DIM along which to sort");
     endif
   endif
- 
+
   n = sz(dim);
   idx1 = cell ();
   for i = 1:nd
     idx1{i} = 1:sz(i);
   endfor
   idx2 = idx1;
-  idx1{dim} = 2 : n;    
+  idx1{dim} = 2 : n;
   idx2{dim} = 1 : (n - 1);
 
   if (! have_x)
     z = 0.5 * sum (x(idx1{:}) + x(idx2{:}), dim);
   else
     if (! size_equal (x, y))
       error ("trapz: X and Y must have same shape");
     endif
-    z = 0.5 * sum ((x(idx1{:}) - x(idx2{:})) .* 
+    z = 0.5 * sum ((x(idx1{:}) - x(idx2{:})) .*
                    (y(idx1{:}) + y(idx2{:})), dim);
   endif
 endfunction
 
 %!assert (trapz(1:5), 12)
 %!assert (trapz(0:0.5:2,1:5), 6)
 %!assert (trapz([1:5;1:5],2),[12;12])
 %!assert (trapz([1:5;1:5].',1),[12,12])
diff --git a/scripts/general/triplequad.m b/scripts/general/triplequad.m
--- a/scripts/general/triplequad.m
+++ b/scripts/general/triplequad.m
@@ -33,20 +33,20 @@
 ## @seealso{dblquad,quad,quadv,quadl,quadgk,quadcc,trapz}
 ## @end deftypefn
 
 function Q = triplequad(f, xa, xb, ya, yb, za, zb, tol, quadf, varargin)
   if (nargin < 7)
     print_usage ();
   endif
   if (nargin < 8 || isempty (tol))
-    tol = 1e-6; 
+    tol = 1e-6;
   endif
   if (nargin < 9 || isempty (quadf))
-    quadf = @quadgk; 
+    quadf = @quadgk;
   endif
 
   inner = @__triplequad_inner__;
   if (ischar (f))
     f = @(x,y,z) feval (f, x, y, z, varargin{:});
     varargin = {};
   endif
 
diff --git a/scripts/geometry/convhull.m b/scripts/geometry/convhull.m
--- a/scripts/geometry/convhull.m
+++ b/scripts/geometry/convhull.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{H} =} convhull (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{H} =} convhull (@var{x}, @var{y}, @var{opt})
 ## Returns the index vector to the points of the enclosing convex hull.  The
 ## data points are defined by the x and y vectors.
 ##
 ## A third optional argument, which must be a string, contains extra options
-## passed to the underlying qhull command.  See the documentation for the 
+## passed to the underlying qhull command.  See the documentation for the
 ## Qhull library for details.
 ##
 ## @seealso{delaunay, convhulln}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function H = convhull (x, y, opt)
diff --git a/scripts/geometry/delaunay.m b/scripts/geometry/delaunay.m
--- a/scripts/geometry/delaunay.m
+++ b/scripts/geometry/delaunay.m
@@ -20,17 +20,17 @@
 ## @deftypefn  {Function File} {@var{tri} =} delaunay (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{tri} =} delaunay (@var{x}, @var{y}, @var{opt})
 ## The return matrix of size [n, 3] contains a set triangles which are
 ## described by the indices to the data point x and y vector.
 ## The triangulation satisfies the Delaunay circum-circle criterion.
 ## No other data point is in the circum-circle of the defining triangle.
 ##
 ## A third optional argument, which must be a string, contains extra options
-## passed to the underlying qhull command.  See the documentation for the 
+## passed to the underlying qhull command.  See the documentation for the
 ## Qhull library for details.
 ##
 ## @example
 ## @group
 ## x = rand (1, 10);
 ## y = rand (size (x));
 ## T = delaunay (x, y);
 ## X = [x(T(:,1)); x(T(:,2)); x(T(:,3)); x(T(:,1))];
@@ -44,17 +44,17 @@
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function ret = delaunay (x, y, opt)
 
   if (nargin != 2 && nargin != 3)
     print_usage ();
   endif
-  
+
   if ((isvector (x) && isvector (y) && length (x) == length (y))
       || size_equal (x, y))
     if (nargin == 2)
       tri = delaunayn ([x(:), y(:)]);
     elseif (ischar (opt) || iscellstr (opt))
       tri = delaunayn ([x(:), y(:)], opt);
     else
       error ("delaunay: third argument must be a string");
diff --git a/scripts/geometry/delaunay3.m b/scripts/geometry/delaunay3.m
--- a/scripts/geometry/delaunay3.m
+++ b/scripts/geometry/delaunay3.m
@@ -14,22 +14,22 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{T} =} delaunay3 (@var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {@var{T} =} delaunay3 (@var{x}, @var{y}, @var{z}, @var{opt})
-## A matrix of size [n, 4] is returned.  Each row contains a 
+## A matrix of size [n, 4] is returned.  Each row contains a
 ## set of tetrahedron which are
 ## described by the indices to the data point vectors (x,y,z).
 ##
 ## A fourth optional argument, which must be a string or cell array of strings,
-## contains extra options passed to the underlying qhull command.  See the 
+## contains extra options passed to the underlying qhull command.  See the
 ## documentation for the Qhull library for details.
 ## @seealso{delaunay,delaunayn}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function tetr = delaunay3 (x, y, z, opt)
 
diff --git a/scripts/geometry/delaunayn.m b/scripts/geometry/delaunayn.m
--- a/scripts/geometry/delaunayn.m
+++ b/scripts/geometry/delaunayn.m
@@ -23,57 +23,57 @@
 ## The Delaunay triangulation is a tessellation of the convex hull of the
 ## points such that no n-sphere defined by the n-triangles contains
 ## any other points from the set.
 ## The input matrix @var{p} of size @code{[n, dim]} contains @math{n}
 ## points in a space of dimension dim.  The return matrix @var{t} has the
 ## size @code{[m, dim+1]}.  It contains for each row a set of indices to
 ## the points, which describes a simplex of dimension dim.  For example,
 ## a 2-D simplex is a triangle and 3-D simplex is a tetrahedron.
-## 
+##
 ## Extra options for the underlying Qhull command can be specified by the
 ## second argument.  This argument is a cell array of strings.  The default
-## options depend on the dimension of the input: 
-## 
-## @itemize 
+## options depend on the dimension of the input:
+##
+## @itemize
 ## @item 2D and 3D: @var{opt} = @code{@{"Qt", "Qbb", "Qc"@}}
 ##
-## @item 4D and higher: @var{opt} = @code{@{"Qt", "Qbb", "Qc", "Qz"@}} 
+## @item 4D and higher: @var{opt} = @code{@{"Qt", "Qbb", "Qc", "Qz"@}}
 ## @end itemize
-## 
+##
 ## If @var{opt} is [], then the default arguments are used.  If @var{opt}
-## is @code{@{"@w{}"@}}, then none of the default arguments are used by Qhull. 
-## See the Qhull documentation for the available options. 
-## 
+## is @code{@{"@w{}"@}}, then none of the default arguments are used by Qhull.
+## See the Qhull documentation for the available options.
+##
 ## All options can also be specified as single string, for example
 ## @code{"Qt Qbb Qc Qz"}.
-## 
+##
 ## @end deftypefn
 
 function t = delaunayn (p, varargin)
   if (nargin < 1)
     print_usage ();
   endif
 
   t = __delaunayn__ (p, varargin{:});
 
   if (isa (p, "single"))
     myeps = eps ("single");
   else
     myeps = eps;
   endif
 
   ## Try to remove the zero volume simplices. The volume of the i-th simplex is
-  ## given by abs(det(p(t(i,1:end-1),:)-p(t(i,2:end),:)))/prod(1:n) 
-  ## (reference http://en.wikipedia.org/wiki/Simplex). Any simplex with a 
-  ## relative volume less than some arbitrary criteria is rejected. The 
-  ## criteria we use is the volume of the simplex corresponding to an 
-  ## orthogonal simplex is equal edge length all equal to the edge length of 
+  ## given by abs(det(p(t(i,1:end-1),:)-p(t(i,2:end),:)))/prod(1:n)
+  ## (reference http://en.wikipedia.org/wiki/Simplex). Any simplex with a
+  ## relative volume less than some arbitrary criteria is rejected. The
+  ## criteria we use is the volume of the simplex corresponding to an
+  ## orthogonal simplex is equal edge length all equal to the edge length of
   ## the original simplex. If the relative volume is 1e3*eps then the simplex
-  ## is rejected. Note division of the two volumes means that the factor 
+  ## is rejected. Note division of the two volumes means that the factor
   ## prod(1:n) is dropped.
   idx = [];
   [nt, n] = size (t);
   for i = 1:nt
     X = p(t(i,1:end-1),:) - p(t(i,2:end),:);
     if (abs (det (X)) /  sqrt (sum (X .^ 2, 2)) < 1e3 * myeps)
      idx = [idx, i];
     endif
diff --git a/scripts/geometry/dsearch.m b/scripts/geometry/dsearch.m
--- a/scripts/geometry/dsearch.m
+++ b/scripts/geometry/dsearch.m
@@ -30,11 +30,11 @@ function idx = dsearch (x, y, tri, xi, y
     print_usage ();
   endif
   idx = __dsearchn__ ([x(:), y(:)], [xi(:), yi(:)]);
 endfunction
 
 %!shared x, y, tri
 %! x = [-1;-1;1];
 %! y = [-1;1;-1];
-%! tri = [1,2,3]; 
+%! tri = [1,2,3];
 %!assert (dsearch(x,y,tri,1,1/3), 3);
 %!assert (dsearch(x,y,tri,1/3,1), 2);
diff --git a/scripts/geometry/dsearchn.m b/scripts/geometry/dsearchn.m
--- a/scripts/geometry/dsearchn.m
+++ b/scripts/geometry/dsearchn.m
@@ -18,18 +18,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{idx} =} dsearchn (@var{x}, @var{tri}, @var{xi})
 ## @deftypefnx {Function File} {@var{idx} =} dsearchn (@var{x}, @var{tri}, @var{xi}, @var{outval})
 ## @deftypefnx {Function File} {@var{idx} =} dsearchn (@var{x}, @var{xi})
 ## @deftypefnx {Function File} {[@var{idx}, @var{d}] =} dsearchn (@dots{})
 ## Returns the index @var{idx} or the closest point in @var{x} to the elements
 ## @var{xi}.  If @var{outval} is supplied, then the values of @var{xi} that are
-## not contained within one of the simplices @var{tri} are set to 
-## @var{outval}.  Generally, @var{tri} is returned from @code{delaunayn 
+## not contained within one of the simplices @var{tri} are set to
+## @var{outval}.  Generally, @var{tri} is returned from @code{delaunayn
 ## (@var{x})}.
 ## @seealso{dsearch, tsearch}
 ## @end deftypefn
 
 function [idx, d] = dsearchn (x, tri, xi, outval)
   if (nargin < 2 || nargin > 4)
     print_usage ();
   endif
@@ -42,16 +42,16 @@ function [idx, d] = dsearchn (x, tri, xi
       idx2 = isnan (tsearchn (x, tri, xi));
       idx(idx2) = outval;
       d(idx2) = outval;
     endif
   endif
 endfunction
 
 %!shared x, tri
-%! x = [-1,-1;-1,1;1,-1]; 
-%! tri = [1,2,3]; 
+%! x = [-1,-1;-1,1;1,-1];
+%! tri = [1,2,3];
 %!assert (dsearchn(x,tri,[1,1/3]), 3);
 %!assert (dsearchn(x,tri,[1,1/3],NaN), NaN);
 %!assert (dsearchn(x,tri,[1,1/3],NA), NA);
 %!assert (dsearchn(x,tri,[1/3,1]), 2);
 %!assert (dsearchn(x,tri,[1/3,1],NaN), NaN);
 %!assert (dsearchn(x,tri,[1/3,1],NA), NA);
diff --git a/scripts/geometry/griddata3.m b/scripts/geometry/griddata3.m
--- a/scripts/geometry/griddata3.m
+++ b/scripts/geometry/griddata3.m
@@ -13,40 +13,40 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{vi} =} griddata3 (@var{x}, @var{y}, @var{z}, @var{v} @var{xi}, @var{yi}, @var{zi}, @var{method}, @var{options})
-## 
+##
 ## Generate a regular mesh from irregular data using interpolation.
 ## The function is defined by @code{@var{y} = f (@var{x},@var{y},@var{z})}.
-## The interpolation points are all @var{xi}.  
+## The interpolation points are all @var{xi}.
 ##
 ## The interpolation method can be @code{"nearest"} or @code{"linear"}.
 ## If method is omitted it defaults to @code{"linear"}.
 ## @seealso{griddata, delaunayn}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
 function vi = griddata3 (x, y, z, v, xi, yi, zi, method, varargin)
-        
+
   if (nargin < 7)
     print_usage ();
   endif
 
   if (!all (size (x) == size (y) & size (x) == size(z) & size(x) == size (v)))
     error ("griddata3: X, Y, Z, and V must be vectors of same length");
   endif
 
   ## meshgrid xi, yi and zi if they are vectors unless they
-  ## are vectors of the same length 
+  ## are vectors of the same length
   if (isvector (xi) && isvector (yi) && isvector (zi)
       && (numel (xi) != numel (yi) || numel (xi) != numel (zi)))
     [xi, yi, zi] = meshgrid (xi, yi, zi);
   endif
 
   if (any (size(xi) != size(yi)) || any (size(xi) != size(zi)))
     error ("griddata3: XI, YI and ZI must be vectors or matrices of same size");
   endif
diff --git a/scripts/geometry/griddatan.m b/scripts/geometry/griddatan.m
--- a/scripts/geometry/griddatan.m
+++ b/scripts/geometry/griddatan.m
@@ -13,54 +13,54 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{yi} =} griddatan (@var{x}, @var{y}, @var{xi}, @var{method}, @var{options})
-## 
+##
 ## Generate a regular mesh from irregular data using interpolation.
 ## The function is defined by @code{@var{y} = f (@var{x})}.
-## The interpolation points are all @var{xi}.  
+## The interpolation points are all @var{xi}.
 ##
 ## The interpolation method can be @code{"nearest"} or @code{"linear"}.
 ## If method is omitted it defaults to @code{"linear"}.
 ## @seealso{griddata, delaunayn}
 ## @end deftypefn
 
 ## Author: David Bateman <dbateman@free.fr>
 
 function yi = griddatan (x, y, xi, method, varargin)
 
   if (nargin == 3)
     method = "linear";
   endif
-  if (nargin < 3) 
+  if (nargin < 3)
     print_usage ();
   endif
 
   if (ischar (method))
     method = tolower (method);
   endif
 
   [m, n] = size (x);
   [mi, ni] = size (xi);
-  
+
   if (n != ni || size (y, 1) != m || size (y, 2) != 1)
     error ("griddatan: dimensional mismatch");
   endif
 
   ## triangulate data
   ## tri = delaunayn(x, varargin{:});
   tri = delaunayn (x);
 
   yi = NaN (mi, 1);
-  
+
   if (strcmp (method, "nearest"))
     ## search index of nearest point
     idx = dsearchn (x, tri, xi);
     valid = !isnan (idx);
     yi(valid) = y(idx(valid));
 
   elseif (strcmp (method, "linear"))
     ## search for every point the enclosing triangle
diff --git a/scripts/geometry/inpolygon.m b/scripts/geometry/inpolygon.m
--- a/scripts/geometry/inpolygon.m
+++ b/scripts/geometry/inpolygon.m
@@ -48,22 +48,22 @@ function [in, on] = inpolygon (x, y, xv,
     error ("inpolygon: first two arguments must be real matrices of same size");
   elseif (! (isreal (xv) && isreal (yv) && isvector (xv) && isvector (yv)
              && size_equal (xv, yv)))
     error ("inpolygon: last two arguments must be real vectors of same size");
   endif
 
   npol = length (xv);
   do_boundary = (nargout >= 2);
-  
+
   in = zeros (size(x), "logical");
-  if (do_boundary) 
-    on = zeros (size(x), "logical"); 
+  if (do_boundary)
+    on = zeros (size(x), "logical");
   endif
-  
+
   j = npol;
   for i = 1 : npol
     delta_xv = xv(j) - xv(i);
     delta_yv = yv(j) - yv(i);
     ## distance = [distance from (x,y) to edge] * length(edge)
     distance = delta_xv .* (y - yv(i)) - (x - xv(i)) .* delta_yv;
     ##
     ## is y between the y-values of edge i,j
@@ -90,17 +90,17 @@ endfunction
 %!       0.05840 ];
 %!  yv=[ 0.60628, 0.04728, 0.50000, 0.50000, 0.02015, \
 %!       0.18161, 0.78850, 1.13589, 1.33781, 1.04650, \
 %!       0.60628 ];
 %! xa=[0:0.1:2.3];
 %! ya=[0:0.1:1.4];
 %! [x,y]=meshgrid(xa,ya);
 %! [in,on]=inpolygon(x,y,xv,yv);
-%! 
+%!
 %! inside=in & !on;
 %! plot(xv,yv)
 %! hold on
 %! plot(x(inside),y(inside),"@g")
 %! plot(x(~in),y(~in),"@m")
 %! plot(x(on),y(on),"@b")
 %! hold off
 %! disp("Green points are inside polygon, magenta are outside,");
@@ -114,17 +114,17 @@ endfunction
 %!  yv=[ 0.60628, 0.04728, 0.50000, 0.50000, 0.02015, \
 %!       0.18161, 0.78850, 1.13589, 1.33781, 1.04650, \
 %!       0.60628, 0.82096, 0.67155, 0.96114, 1.14833, \
 %!       0.82096, 0.60628];
 %! xa=[0:0.1:2.3];
 %! ya=[0:0.1:1.4];
 %! [x,y]=meshgrid(xa,ya);
 %! [in,on]=inpolygon(x,y,xv,yv);
-%! 
+%!
 %! inside=in & ~ on;
 %! plot(xv,yv)
 %! hold on
 %! plot(x(inside),y(inside),"@g")
 %! plot(x(~in),y(~in),"@m")
 %! plot(x(on),y(on),"@b")
 %! hold off
 %! disp("Green points are inside polygon, magenta are outside,");
diff --git a/scripts/geometry/rectint.m b/scripts/geometry/rectint.m
--- a/scripts/geometry/rectint.m
+++ b/scripts/geometry/rectint.m
@@ -29,17 +29,17 @@
 ## column corresponds to the j-th row of b.
 ##
 ## @seealso{polyarea}
 ## @end deftypefn
 
 ## Author: Bill Denney <bill@denney.ws>
 
 function area = rectint (a, b)
-        
+
   if (nargin != 2)
     print_usage ();
   elseif (ndims (a) != 2 || ndims (b) != 2)
     error ("rectint: expecting arguments to be 2-d arrays");
   elseif (columns (a) != 4)
     error ("rectint: A must have 4 columns");
   elseif (columns (b) != 4)
     error ("rectint: B must have 4 columns");
diff --git a/scripts/geometry/trimesh.m b/scripts/geometry/trimesh.m
--- a/scripts/geometry/trimesh.m
+++ b/scripts/geometry/trimesh.m
@@ -15,19 +15,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} trimesh (@var{tri}, @var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {@var{h} =} trimesh (@dots{})
 ## Plot a triangular mesh in 3D@.  The variable @var{tri} is the triangular
-## meshing of the points @code{(@var{x}, @var{y})} which is returned 
-## from @code{delaunay}.  The variable @var{z} is value at the point 
-## @code{(@var{x}, @var{y})}.  The output argument @var{h} is the graphic 
+## meshing of the points @code{(@var{x}, @var{y})} which is returned
+## from @code{delaunay}.  The variable @var{z} is value at the point
+## @code{(@var{x}, @var{y})}.  The output argument @var{h} is the graphic
 ## handle to the plot.
 ## @seealso{triplot, delaunay3}
 ## @end deftypefn
 
 function h = trimesh (tri, x, y, z, varargin)
 
   if (nargin < 3)
     print_usage ();
@@ -35,22 +35,22 @@ function h = trimesh (tri, x, y, z, vara
 
   if (nargin == 3)
     triplot (tri, x, y);
   elseif (ischar (z))
     triplot (tri, x, y, z, varargin{:});
   else
     newplot ();
     if (nargout > 0)
-      h = patch ("Vertices", [x(:), y(:), z(:)], "Faces", tri, 
-                 "FaceColor", "none", "EdgeColor", __next_line_color__(), 
+      h = patch ("Vertices", [x(:), y(:), z(:)], "Faces", tri,
+                 "FaceColor", "none", "EdgeColor", __next_line_color__(),
                  varargin{:});
     else
-      patch ("Vertices", [x(:), y(:), z(:)], "Faces", tri, 
-             "FaceColor", "none", "EdgeColor", __next_line_color__(), 
+      patch ("Vertices", [x(:), y(:), z(:)], "Faces", tri,
+             "FaceColor", "none", "EdgeColor", __next_line_color__(),
              varargin{:});
     endif
 
     if (! ishold ())
       set (gca(), "view", [-37.5, 30],
            "xgrid", "on", "ygrid", "on", "zgrid", "on");
     endif
   endif
diff --git a/scripts/geometry/trisurf.m b/scripts/geometry/trisurf.m
--- a/scripts/geometry/trisurf.m
+++ b/scripts/geometry/trisurf.m
@@ -15,19 +15,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} trisurf (@var{tri}, @var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {@var{h} =} trisurf (@dots{})
 ## Plot a triangular surface in 3D@.  The variable @var{tri} is the triangular
-## meshing of the points @code{(@var{x}, @var{y})} which is returned 
-## from @code{delaunay}.  The variable @var{z} is value at the point 
-## @code{(@var{x}, @var{y})}.  The output argument @var{h} is the graphic 
+## meshing of the points @code{(@var{x}, @var{y})} which is returned
+## from @code{delaunay}.  The variable @var{z} is value at the point
+## @code{(@var{x}, @var{y})}.  The output argument @var{h} is the graphic
 ## handle to the plot.
 ## @seealso{triplot, delaunay3}
 ## @end deftypefn
 
 function h = trisurf (tri, x, y, z, varargin)
 
   if (nargin < 3)
     print_usage ();
@@ -42,23 +42,23 @@ function h = trisurf (tri, x, y, z, vara
       c = varargin{1};
       varargin(1) = [];
     else
       c = z;
     endif
 
     newplot ();
     if (nargout > 0)
-      h = patch ("Faces", tri, "Vertices", [x(:), y(:), z(:)],  
-             "FaceVertexCData", reshape (c, numel (c), 1), 
+      h = patch ("Faces", tri, "Vertices", [x(:), y(:), z(:)],
+             "FaceVertexCData", reshape (c, numel (c), 1),
              "FaceColor", "flat", "EdgeColor", "none",
              varargin{:});
     else
-      patch ("Faces", tri, "Vertices", [x(:), y(:), z(:)],  
-             "FaceVertexCData", reshape (c, numel (c), 1), 
+      patch ("Faces", tri, "Vertices", [x(:), y(:), z(:)],
+             "FaceVertexCData", reshape (c, numel (c), 1),
              "FaceColor", "flat", "EdgeColor", "none",
              varargin{:});
     endif
 
     if (! ishold ())
       set (gca(), "view", [-37.5, 30],
            "xgrid", "on", "ygrid", "on", "zgrid", "on");
     endif
diff --git a/scripts/geometry/tsearchn.m b/scripts/geometry/tsearchn.m
--- a/scripts/geometry/tsearchn.m
+++ b/scripts/geometry/tsearchn.m
@@ -39,17 +39,17 @@ function [idx, p] = tsearchn (x, t, xi)
 
   ni = [1:mi].';
   for i = 1 : nt
     ## Only calculate the Barycentric coordinates for points that have not
     ## already been found in a triangle.
     b = cart2bary (x (t (i, :), :), xi(ni,:));
 
     ## Our points xi are in the current triangle if
-    ## (all(b >= 0) && all (b <= 1)). However as we impose that 
+    ## (all(b >= 0) && all (b <= 1)). However as we impose that
     ## sum(b,2) == 1 we only need to test all(b>=0). Note need to add
     ## a small margin for rounding errors
     intri = all (b >= -1e-12, 2);
     idx(ni(intri)) = i;
     p(ni(intri),:) = b(intri, :);
     ni(intri) = [];
   endfor
 endfunction
diff --git a/scripts/geometry/voronoi.m b/scripts/geometry/voronoi.m
--- a/scripts/geometry/voronoi.m
+++ b/scripts/geometry/voronoi.m
@@ -66,40 +66,40 @@ function [vvx, vvy] = voronoi (varargin)
   narg = 1;
   if (isscalar (varargin{1}) && ishandle (varargin{1}))
     handl = varargin{1};
     narg++;
     if (! strcmp (get (handl, "type"), "axes"))
       error ("voronoi: expecting first argument to be an axes object");
     endif
   else
-    if (nargout < 2)    
+    if (nargout < 2)
       handl = gca ();
     endif
   endif
 
   if (nargin < 1 + narg || nargin > 3 + narg)
     print_usage ();
   endif
 
   x = varargin{narg++};
   y = varargin{narg++};
-  
+
   opts = {};
-  if (narg <= nargin) 
+  if (narg <= nargin)
     if (iscell (varargin{narg}))
       opts = varargin(narg++);
     elseif (ismatrix (varargin{narg}))
       ## Accept but ignore the triangulation
       narg++;
     endif
   endif
 
   linespec = {"b"};
-  if (narg <= nargin) 
+  if (narg <= nargin)
     if (ischar (varargin{narg}))
       linespec = varargin(narg);
     endif
   endif
 
   lx = length (x);
   ly = length (y);
 
@@ -125,17 +125,17 @@ function [vvx, vvy] = voronoi (varargin)
           xmax + scale * xdelta; xmin - scale * xdelta];
 
   [p, c, infi] = __voronoi__ ([[x(:) ; xbox(:)], [y(:); ybox(:)]], opts{:});
 
   idx = find (!infi);
   ll = length (idx);
   c = c(idx).';
   k = sum (cellfun ('length', c));
-  edges = cell2mat(cellfun (@(x) [x ; [x(end), x(1:end-1)]], c, 
+  edges = cell2mat(cellfun (@(x) [x ; [x(end), x(1:end-1)]], c,
                             "uniformoutput", false));
 
   ## Identify the unique edges of the Voronoi diagram
   edges = sortrows (sort (edges).').';
   edges = edges (:, [(edges(1, 1: end - 1) != edges(1, 2 : end) | ...
                       edges(2, 1 :end - 1) != edges(2, 2 : end)), true]);
 
   ## Eliminate the edges of the diagram representing the box
@@ -145,17 +145,17 @@ function [vvx, vvy] = voronoi (varargin)
   edgeoutside = ismember (edges (1, :), poutside) & ...
       ismember (edges (2, :), poutside);
   edges (:, edgeoutside) = [];
 
   ## Get points of the diagram
   vx = reshape (p (edges, 1), size(edges));
   vy = reshape (p (edges, 2), size(edges));
 
-  if (nargout < 2)    
+  if (nargout < 2)
     lim = [xmin, xmax, ymin, ymax];
     h = plot (handl, vx, vy, linespec{:}, x, y, '+');
     axis (lim + 0.1 * [[-1, 1] * (lim (2) - lim (1)), ...
                        [-1, 1] * (lim (4) - lim (3))]);
     if (nargout == 1)
       vxx = h;
     endif
   elseif (nargout == 2)
diff --git a/scripts/help/__makeinfo__.m b/scripts/help/__makeinfo__.m
--- a/scripts/help/__makeinfo__.m
+++ b/scripts/help/__makeinfo__.m
@@ -58,42 +58,42 @@
 ## @code{makeinfo} program as returned by @code{system}.
 
 function [retval, status] = __makeinfo__ (text, output_type = "plain text", see_also = [])
 
   ## Check input
   if (nargin == 0)
     print_usage ();
   endif
-  
+
   if (!ischar (text))
     error ("__makeinfo__: first input argument must be a string");
   endif
-  
+
   if (!ischar (output_type))
     error ("__makeinfo__: second input argument must be a string");
   endif
-  
+
   ## Define the function which expands @seealso macro
   if (isempty (see_also))
     if (strcmpi (output_type, "plain text"))
       see_also = @simple_see_also;
     else
       see_also = @simple_see_also_with_refs;
     endif
   endif
-  
+
   if (!isa (see_also, "function_handle"))
     error ("__makeinfo__: third input argument must be the empty matrix, or a function handle");
   endif
-  
-  ## It seems like makeinfo sometimes gets angry if the first character 
+
+  ## It seems like makeinfo sometimes gets angry if the first character
   ## on a line is a space, so we remove these.
   text = strrep (text, "\n ", "\n");
-  
+
   ## Handle @seealso macro
   SEE_ALSO = "@seealso";
   starts = strfind (text, SEE_ALSO);
   for start = fliplr (starts)
     if (start == 1 || (text (start-1) != "@"))
       bracket_start = find (text (start:end) == "{", 1);
       stop = find (text (start:end) == "}", 1);
       if (!isempty (stop) && !isempty (bracket_start))
@@ -139,20 +139,20 @@ function [retval, status] = __makeinfo__
     endif
   endfor
 
   if (strcmpi (output_type, "texinfo"))
     status = 0;
     retval = text;
     return;
   endif
-  
+
   ## Create the final TeXinfo input string
   text = sprintf ("\\input texinfo\n\n%s\n\n@bye\n", text);
-  
+
   unwind_protect
     ## Write Texinfo to tmp file
     template = "octave-help-XXXXXX";
     [fid, name, msg] = mkstemp (fullfile (P_tmpdir, template), true);
     if (fid < 0)
       error ("__makeinfo__: could not create temporary file");
     endif
     fwrite (fid, text);
@@ -164,17 +164,17 @@ function [retval, status] = __makeinfo__
          cmd = sprintf ("%s --no-headers --no-warn --force --no-validate %s",
                         makeinfo_program (), name);
       case "html"
          cmd = sprintf ("%s --no-headers --html --no-warn --no-validate --force %s",
                         makeinfo_program (), name);
       otherwise
         error ("__makeinfo__: unsupported output type: '%s'", output_type);
     endswitch
-  
+
     ## Call makeinfo
     [status, retval] = system (cmd);
 
   unwind_protect_cleanup
     if (exist (name, "file"))
       delete (name);
     endif
   end_unwind_protect
diff --git a/scripts/help/__strip_html_tags__.m b/scripts/help/__strip_html_tags__.m
--- a/scripts/help/__strip_html_tags__.m
+++ b/scripts/help/__strip_html_tags__.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{text}, @var{status}] =} __strip_html_tags__ (@var{html_text})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Remove HTML tags from text.  This is used as a simple HTML-to-text
-## function. 
+## function.
 
 function [text, status] = __strip_html_tags__ (html_text)
   start = find (html_text == "<");
   stop  = find (html_text == ">");
   if (length (start) == length (stop))
     text = html_text;
     for n = length(start):-1:1
       text (start (n):stop (n)) = [];
@@ -57,25 +57,25 @@ function text = strip_superfluous_endlin
   endfor
 
   keep = true (size (text));
 
   ## Remove end-lines in the beginning
   if (groups (1, 1) == 1)
     keep (1:groups (1, 2)) = false;
   endif
-  
+
   ## Remove end-lines from the end
   if (sum (groups (end, :)) - 1 == length (text))
     keep (groups (end, 1):end) = false;
   endif
-  
+
   ## Remove groups of end-lines with more than 3 end-lines next to each other
   idx = find (groups (:, 2) >= 3);
   for k = 1:length (idx)
     start = groups (idx (k), 1);
     stop = start + groups (idx (k), 2) - 1;
     keep (start+2:stop) = false;
   endfor
-  
+
   ## Actually remove the elements
   text = text (keep);
 endfunction
diff --git a/scripts/help/doc.m b/scripts/help/doc.m
--- a/scripts/help/doc.m
+++ b/scripts/help/doc.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2005-2011 Sren Hauberg
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -60,17 +60,17 @@ function retval = doc (fname)
     endif
 
     if (isempty (ffile))
       info_dir = octave_config_info ("infodir");
     else
       info_dir = fileparts (ffile);
     endif
 
-    ## Determine if a file called doc.info exist in the same 
+    ## Determine if a file called doc.info exist in the same
     ## directory as the function.
 
     info_file_name = fullfile (info_dir, "doc.info");
 
     [stat_info, err] = stat (info_file_name);
 
     if (err < 0)
       info_file_name = info_file ();
diff --git a/scripts/help/gen_doc_cache.m b/scripts/help/gen_doc_cache.m
--- a/scripts/help/gen_doc_cache.m
+++ b/scripts/help/gen_doc_cache.m
@@ -15,42 +15,42 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} gen_doc_cache (@var{out_file}, @var{directory})
 ## Generate documentation caches for all functions in a given directory.
 ##
-## A documentation cache is generated for all functions in @var{directory}. 
+## A documentation cache is generated for all functions in @var{directory}.
 ## The
 ## resulting cache is saved in the file @var{out_file}.
 ## The cache is used to speed up @code{lookfor}.
 ##
 ## If no directory is given (or it is the empty matrix), a cache for builtin
 ## operators, etc. is generated.
 ##
 ## @seealso{lookfor, path}
 ## @end deftypefn
 
 function gen_doc_cache (out_file = "doc-cache", directory = [])
   ## Check input
   if (!ischar (out_file))
     print_usage ();
   endif
-  
+
   ## Generate cache
   if (isempty (directory))
     cache = gen_builtin_cache ();
   elseif (ischar (directory))
     cache = gen_doc_cache_in_dir (directory);
   else
     error ("gen_doc_cache: second input argument must be a string");
   endif
-  
+
   ## Save cache
   if (! isempty (cache))
     save ("-text", out_file, "cache");
   endif
 endfunction
 
 function [text, first_sentence, status] = handle_function (f, text, format)
   first_sentence = "";
@@ -66,44 +66,44 @@ function [text, first_sentence, status] 
       status = 0;
     case "texinfo"
       [text, status] = __makeinfo__ (text, "plain text");
     case "html"
       [text, status] = strip_html_tags (text);
     otherwise
       status = 1;
   endswitch
-    
+
   ## Did we get the help text?
   if (status != 0 || isempty (text))
     warning ("gen_doc_cache: unusable help text in '%s'. Ignoring function.", f);
     return;
   endif
 
   ## Get first sentence of help text
   first_sentence = get_first_help_sentence (f);
 endfunction
 
 function cache = create_cache (list)
   cache = {};
-  
+
   ## For each function:
   for n = 1:length (list)
     f = list {n};
-    
+
     ## Get help text
     [text, format] = get_help_text (f);
-    
+
     [text, first_sentence, status] = handle_function (f, text, format);
 
     ## Did we get the help text?
     if (status != 0)
       continue;
     endif
-    
+
     ## Store the help text
     cache (1, end+1) = f;
     cache (2, end) = text;
     cache (3, end) = first_sentence;
   endfor
 endfunction
 
 function cache = gen_doc_cache_in_dir (directory)
@@ -115,25 +115,25 @@ function cache = gen_doc_cache_in_dir (d
   for n = 1:length (idx)
     f = p (prev_idx:idx (n)-1);
     if (strcmp (f, directory))
       dir_in_path = true;
       break;
     endif
     prev_idx = idx (n) + 1;
   endfor
-  
+
   if (!dir_in_path)
     addpath (directory);
   endif
 
   ## Get list of functions in directory and create cache
   list = __list_functions__ (directory);
   cache = create_cache (list);
-  
+
   if (!dir_in_path)
     rmpath (directory);
   endif
 endfunction
 
 function cache = gen_builtin_cache ()
   operators = __operators__ ();
   keywords = __keywords__ ();
diff --git a/scripts/help/get_first_help_sentence.m b/scripts/help/get_first_help_sentence.m
--- a/scripts/help/get_first_help_sentence.m
+++ b/scripts/help/get_first_help_sentence.m
@@ -41,28 +41,28 @@
 ## @end example
 ## @end deftypefn
 
 function [retval, status] = get_first_help_sentence (name, max_len = 80)
   ## Check input
   if (nargin == 0)
     error ("get_first_help_sentence: not enough input arguments");
   endif
-  
+
   if (!ischar (name))
     error ("get_first_help_sentence: first input must be a string");
   endif
-  
+
   if (!isnumeric (max_len) || max_len <= 0 || max_len != round (max_len))
     error ("get_first_help_sentence: second input must be positive integer");
   endif
 
   ## First, we get the raw help text
   [help_text, format] = get_help_text (name);
-  
+
   ## Then, we take action depending on the format
   switch (lower (format))
     case "plain text"
       [retval, status] = first_sentence_plain_text (help_text, max_len);
     case "texinfo"
       [retval, status] = first_sentence_texinfo (help_text, max_len);
     case "html"
       [retval, status] = first_sentence_html (help_text, max_len);
@@ -90,32 +90,32 @@ endfunction
 
 ## This function extracts the first sentence from a Texinfo help text.
 ## The function works by removing @def* from the texinfo text. After this, we
 ## render the text to plain text using makeinfo, and then extract the first line.
 function [retval, status] = first_sentence_texinfo (help_text, max_len)
   ## Lines ending with "@\n" are continuation lines, so they should be concatenated
   ## with the following line.
   help_text = strrep (help_text, "@\n", " ");
-  
+
   ## Find, and remove, lines that start with @def. This should remove things
   ## such as @deftypefn, @deftypefnx, @defvar, etc.
   keep = true (size (help_text));
   def_idx = strfind (help_text, "@def");
   if (!isempty (def_idx))
     endl_idx = find (help_text == "\n");
     for k = 1:length (def_idx)
       endl = endl_idx (find (endl_idx > def_idx (k), 1));
       if (isempty (endl))
         keep (def_idx (k):end) = false;
       else
         keep (def_idx (k):endl) = false;
       endif
     endfor
-  
+
     ## Remove the @end ... that corresponds to the @def we removed above
     def1 = def_idx (1);
     space_idx = find (help_text == " ");
     space_idx = space_idx (find (space_idx > def1, 1));
     bracket_idx = find (help_text == "{" | help_text == "}");
     bracket_idx = bracket_idx (find (bracket_idx > def1, 1));
     if (isempty (space_idx) && isempty (bracket_idx))
       error ("get_first_help_sentence: couldn't parse texinfo");
@@ -128,29 +128,29 @@ function [retval, status] = first_senten
       error ("get_first_help_sentence: couldn't parse texinfo");
     endif
     endl = endl_idx (find (endl_idx > end_idx, 1));
     if (isempty (endl))
       keep (end_idx:end) = false;
     else
       keep (end_idx:endl) = false;
     endif
-    
+
     help_text = help_text (keep);
   endif
-  
+
   ## Run makeinfo to generate plain text
   [help_text, status] = __makeinfo__ (help_text, "plain text");
-  
+
   ## Extract first line with plain text method.
   retval = first_sentence_plain_text (help_text, max_len);
 endfunction
 
 ## This function extracts the first sentence from a html help text.
 ## The function simply removes the tags and treats the text as plain text.
 function [retval, status] = first_sentence_html (help_text, max_len)
   ## Strip tags
   [help_text, status] = strip_html_tags (help_text);
-  
+
   ## Extract first line with plain text method.
   retval = first_sentence_plain_text (help_text, max_len);
 endfunction
 
diff --git a/scripts/help/help.m b/scripts/help/help.m
--- a/scripts/help/help.m
+++ b/scripts/help/help.m
@@ -65,34 +65,34 @@ function retval = help (name)
       else
         retval = tmp;
       endif
       return;
     endif
 
     ## Get help text
     [text, format] = get_help_text (name);
-    
+
     ## Take action depending on help text format
     switch (lower (format))
       case "plain text"
         status = 0;
       case "texinfo"
         [text, status] = __makeinfo__ (text, "plain text");
       case "html"
         [text, status] = strip_html_tags (text);
       case "not documented"
         error ("help: `%s' is not documented\n", name);
       case "not found"
         do_contents (name);
         return;
       otherwise
         error ("help: internal error: unsupported help text format: '%s'\n", format);
     endswitch
-    
+
     ## Print text
     if (status != 0)
       warning ("help: Texinfo formatting filter exited abnormally; raw Texinfo source of help text follows...\n");
     endif
 
     if (nargout == 0)
       which (name);
       printf ("\n%s\n%s", text, __additional_help_message__ ());
diff --git a/scripts/help/lookfor.m b/scripts/help/lookfor.m
--- a/scripts/help/lookfor.m
+++ b/scripts/help/lookfor.m
@@ -16,32 +16,32 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} lookfor @var{str}
 ## @deftypefnx {Command} {} lookfor -all @var{str}
 ## @deftypefnx {Function File} {[@var{func}, @var{helpstring}] =} lookfor (@var{str})
 ## @deftypefnx {Function File} {[@var{func}, @var{helpstring}] =} lookfor ('-all', @var{str})
-## Search for the string @var{str} in all functions found in the current 
+## Search for the string @var{str} in all functions found in the current
 ## function search path.  By default, @code{lookfor} searches for @var{str}
 ## in the first sentence of the help string of each function found.  The entire
-## help text of each function can be searched if the '-all' argument is 
+## help text of each function can be searched if the '-all' argument is
 ## supplied.  All searches are case insensitive.
-## 
-## Called with no output arguments, @code{lookfor} prints the list of 
-## matching functions to the terminal.  Otherwise, the output arguments 
-## @var{func} and @var{helpstring} define the matching functions and the 
+##
+## Called with no output arguments, @code{lookfor} prints the list of
+## matching functions to the terminal.  Otherwise, the output arguments
+## @var{func} and @var{helpstring} define the matching functions and the
 ## first sentence of each of their help strings.
-## 
+##
 ## The ability of @code{lookfor} to correctly identify the first
 ## sentence of the help text is dependent on the format of the
 ## function's help.  All Octave core functions are correctly
 ## formatted, but the same can not be guaranteed for external packages and
-## user-supplied functions.  Therefore, the use of the '-all' argument may 
+## user-supplied functions.  Therefore, the use of the '-all' argument may
 ## be necessary to find related functions that are not a part of Octave.
 ## @seealso{help, doc, which}
 ## @end deftypefn
 
 function [out_fun, out_help_text] = lookfor (str, arg2)
   if (strcmpi (str, "-all"))
     ## The difference between using '-all' and not, is which part of the caches
     ## we search. The cache is organised such that its first column contains
@@ -58,17 +58,17 @@ function [out_fun, out_help_text] = look
   cache_file = doc_cache_file ();
   if (exist (cache_file, "file"))
     [fun, help_text] = search_cache (str, cache_file, search_type);
     had_core_cache = true;
   else
     fun = help_text = {};
     had_core_cache = false;
   endif
-  
+
   ## Search functions in new path dirs.
   orig_path = strsplit (__pathorig__ (), pathsep ());
 
   ## ditto for path.
   new_path = strsplit (path (), pathsep ());
 
   ## scratch out directories already covered by orig_path.
   if (had_core_cache)
@@ -83,22 +83,22 @@ function [out_fun, out_help_text] = look
       [funs, hts] = search_cache (str, cache_file, search_type);
       fun (end+1:end+length (funs)) = funs;
       help_text (end+1:end+length (hts)) = hts;
     else
     ## We don't have a cache. Search files
       funs_in_f = __list_functions__ (elt);
       for m = 1:length (funs_in_f)
         fn = funs_in_f {m};
-      
+
         ## Skip files that start with __
         if (length (fn) > 2 && strcmp (fn (1:2), "__"))
           continue;
         endif
-      
+
         ## Extract first sentence
         try
           warn_state = warning ();
           unwind_protect
             warning ("off");
             first_sentence = get_first_help_sentence (fn);
             status = 0;
           unwind_protect_cleanup
@@ -116,42 +116,42 @@ function [out_fun, out_help_text] = look
               [text, fmt] = get_help_text (fn);
               status = 0;
             unwind_protect_cleanup
               warning (warn_state);
             end_unwind_protect
           catch
             status = 1;
           end_try_catch
-  
+
           ## Take action depending on help text fmt
           switch (lower (fmt))
             case "plain text"
               status = 0;
             case "texinfo"
               [text, status] = __makeinfo__ (text, "plain text");
             case "html"
               [text, status] = strip_html_tags (text);
             otherwise
               status = 1;
           endswitch
 
         elseif (status == 0) # only search the first sentence of the help text
           text = first_sentence;
         endif
-      
+
         ## Search the help text, if we can
         if (status == 0 && !isempty (strfind (text, str)))
           fun (end+1) = fn;
           help_text (end+1) = first_sentence;
         endif
       endfor
     endif
   endfor
-  
+
   if (nargout == 0)
     ## Print the results (FIXME: improve this to make it look better.
     indent = 20;
     term_width = terminal_size() (2);
     desc_width = term_width - indent - 2;
     indent_space = repmat (" ", 1, indent);
     for k = 1:length (fun)
       f = fun {k};
diff --git a/scripts/help/print_usage.m b/scripts/help/print_usage.m
--- a/scripts/help/print_usage.m
+++ b/scripts/help/print_usage.m
@@ -39,17 +39,17 @@ function print_usage (name)
     if (strcmp (fullpath(end-length(name)+1:end), name))
       fullname = [fullpath, ".m"];
     endif
   elseif (!ischar (name))
     error ("print_usage: input argument must be a string");
   else
     fullname = name;
   endif
-  
+
   ## Determine if we're called from top level.
   at_toplev = length (x) < 2 || (length (x) == 2 && strcmp (x(2).name, name));
 
   ## Do the actual work
   [text, format] = get_help_text (fullname);
   max_len = 80;
   switch (lower (format))
     case "plain text"
@@ -60,17 +60,17 @@ function print_usage (name)
       [usage_string, status] = get_usage_html (text, max_len);
     case "not documented"
       error ("print_usage: `%s' is not documented\n", name);
     case "not found"
       error ("print_usage: `%s' not found\n", name);
     otherwise
       error ("print_usage: internal error: unsupported help text format: '%s'\n", format);
   endswitch
-  
+
   ## Raise the final error
   if (status != 0)
     warning ("print_usage: Texinfo formatting filter exited abnormally");
     warning ("print_usage: raw Texinfo source of help text follows...\n");
   endif
 
   if (at_toplev)
     error ("Invalid call to %s.  Correct usage is:\n\n%s\n%s",
@@ -95,44 +95,44 @@ function [retval, status] = get_usage_pl
   retval = help_text (1:min ([line_end_idx , max_len, length(help_text)]));
   status = 0;
 endfunction
 
 function [retval, status] = get_usage_texinfo (help_text, max_len)
   ## Lines ending with "@\n" are continuation lines, so they should be
   ## concatenated with the following line.
   help_text = strrep (help_text, "@\n", " ");
-  
+
   ## Find, and keep, lines that start with @def or @end def. This should include things
   ## such as @deftypefn, @deftypefnx, @defvar, etc. and their corresponding @end's
   def_idx = strfind (help_text, "@def");
   if (!isempty (def_idx))
     buffer = "";
     endl_idx = find (help_text == "\n");
     for k = 1:length (def_idx)
       endl = endl_idx (find (endl_idx > def_idx (k), 1));
       if (isempty (endl))
         buffer = strcat (buffer, help_text (def_idx (k):end), "\n");
       else
         buffer = strcat (buffer, help_text (def_idx (k):endl));
       endif
     endfor
-    
+
     end_def_idx = strfind (help_text, "@end def");
     if (!isempty (end_def_idx))
       buffer = strcat (buffer, help_text (end_def_idx:end));
     endif
   else
     [retval, status] = get_usage_plain_text (help_text, max_len);
   endif
 
   ## Run makeinfo to generate plain text
   [retval, status] = __makeinfo__ (buffer, "plain text");
 endfunction
 
 function [retval, status] = get_usage_html (help_text, max_len)
   ## Strip tags
   [help_text, status] = strip_html_tags (help_text);
-  
+
   ## Extract first line with plain text method.
   retval = get_usage_plain_text (help_text, max_len);
 endfunction
 
diff --git a/scripts/help/type.m b/scripts/help/type.m
--- a/scripts/help/type.m
+++ b/scripts/help/type.m
@@ -16,49 +16,49 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} type @var{name} @dots{}
 ## @deftypefnx {Command} {} type -q @var{name} @dots{}
 ## @deftypefnx {Function File} {dfns =} type ("@var{name}", @dots{})
 ## Display the definition of each @var{name} that refers to a function.
-## 
+##
 ## Normally also displays whether each @var{name} is user-defined or built-in;
 ## the @option{-q} option suppresses this behavior.
 ##
-## If an output argument is requested nothing is displayed.  Instead, a cell 
-## array of strings is returned, where each element corresponds to the 
+## If an output argument is requested nothing is displayed.  Instead, a cell
+## array of strings is returned, where each element corresponds to the
 ## definition of each requested function.
 ## @end deftypefn
 
 function retval = type (varargin)
   ## Parse input
   if (nargin == 0)
     error ("type: not enough input arguments");
   endif
 
   if (!iscellstr (varargin))
     error ("type: input arguments must be strings");
   endif
-    
+
   quiet = false;
   idx = strcmpi (varargin, "-q") | strcmpi (varargin, "-quiet");
   if (any (idx))
     quiet = true;
     varargin (idx) = [];
   endif
 
   if (nargout > 0)
     retval = cell (size (varargin));
   endif
-  
+
   for n = 1:length (varargin)
     name = varargin {n};
-    
+
     ## Find function and get its code
     text = "";
     cmd = sprintf ("exist ('%s')", name);
     e = evalin ("caller", cmd);
     if (e == 1)
       ## Variable
       cmd = sprintf ("disp (%s);", name);
       desc = evalin ("caller", cmd);
@@ -70,31 +70,31 @@ function retval = type (varargin)
     elseif (e == 2)
       ## m-file or ordinary file
       file = which (name);
       if (isempty (file))
         ## 'name' is an ordinary file, and not a function name.
         ## FIXME: Should we just print it anyway?
         error ("type: `%s' undefined\n", name);
       endif
-    
+
       ## Read the file
       fid = fopen (file, "r");
       if (fid < 0)
         error ("type: couldn't open `%s' for reading", file);
       endif
       contents = char (fread (fid).');
       fclose (fid);
-    
+
       if (quiet)
         text = contents;
       else
         text = sprintf ("%s is the user-defined function defined from: %s\n\n%s",
                         name, file, contents);
-      endif    
+      endif
     elseif (e == 3)
       text = sprintf ("%s is a dynamically-linked function", name);
     elseif (e == 5)
       text = sprintf ("%s is a built-in function", name);
     elseif (any (strcmp (__operators__ (), name)))
       text = sprintf ("%s is an operator", name);
     elseif (any (strcmp (__keywords__ (), name)))
       text = sprintf ("%s is a keyword", name);
diff --git a/scripts/image/autumn.m b/scripts/image/autumn.m
--- a/scripts/image/autumn.m
+++ b/scripts/image/autumn.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} autumn ()
 ## @deftypefnx {Function File} {@var{map} =} autumn (@var{n})
 ## Create color colormap.  This colormap ranges from red through orange
 ## to yellow.
-## The argument @var{n} must be a scalar.  
+## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = autumn (n)
 
@@ -36,17 +36,17 @@ function map = autumn (n)
     if (! isscalar (n))
       error ("autumn: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
-    map = [1, 0, 0];  
+    map = [1, 0, 0];
   elseif (n > 1)
     r = ones (n, 1);
     g = (0:n - 1)' ./ (n - 1);
     b = zeros (n, 1);
     map = [r, g, b];
   else
     map = [];
   endif
diff --git a/scripts/image/bone.m b/scripts/image/bone.m
--- a/scripts/image/bone.m
+++ b/scripts/image/bone.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} bone ()
 ## @deftypefnx {Function File} {@var{map} =} bone (@var{n})
 ## Create color colormap.  This colormap varies from black to white with
 ## gray-blue shades.
-## The argument @var{n} must be a scalar.  
+## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = bone (n)
 
@@ -36,17 +36,17 @@ function map = bone (n)
     if (! isscalar (n))
       error ("bone: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
-    map = [0, 0, 0];  
+    map = [0, 0, 0];
   elseif (n > 1)
     x = linspace (0, 1, n)';
 
     r = (x < 3/4) .* (7/8 * x) + (x >= 3/4) .* (11/8 * x - 3/8);
     g = (x < 3/8) .* (7/8 * x)\
       + (x >= 3/8 & x < 3/4) .* (29/24 * x - 1/8)\
       + (x >= 3/4) .* (7/8 * x + 1/8);
     b = (x < 3/8) .* (29/24 * x) + (x >= 3/8) .* (7/8 * x + 1/8);
diff --git a/scripts/image/brighten.m b/scripts/image/brighten.m
--- a/scripts/image/brighten.m
+++ b/scripts/image/brighten.m
@@ -15,19 +15,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map_out} =} brighten (@var{map}, @var{beta})
 ## @deftypefnx {Function File} {@var{map_out} =} brighten (@var{h}, @var{beta})
 ## @deftypefnx {Function File} {@var{map_out} =} brighten (@var{beta})
-## Darkens or brightens the given colormap.  If the @var{map} argument 
+## Darkens or brightens the given colormap.  If the @var{map} argument
 ## is omitted, the function is applied to the current colormap.  The first
-## argument can also be a valid graphics handle @var{h}, in which case 
+## argument can also be a valid graphics handle @var{h}, in which case
 ## @code{brighten} is applied to the colormap associated with this handle.
 ##
 ## Should the resulting colormap @var{map_out} not be assigned, it will be
 ## written to the current colormap.
 ##
 ## The argument @var{beta} should be a scalar between -1 and 1,
 ## where a negative value darkens and a positive value brightens
 ## the colormap.
diff --git a/scripts/image/cool.m b/scripts/image/cool.m
--- a/scripts/image/cool.m
+++ b/scripts/image/cool.m
@@ -14,18 +14,18 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} cool ()
 ## @deftypefnx {Function File} {@var{map} =} cool (@var{n})
-## Create color colormap.  The colormap varies from cyan to magenta.  
-## The argument @var{n} must be a scalar.  
+## Create color colormap.  The colormap varies from cyan to magenta.
+## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = cool (n)
 
@@ -35,17 +35,17 @@ function map = cool (n)
     if (! isscalar (n))
       error ("cool: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
-    map = [0, 1, 1];  
+    map = [0, 1, 1];
   elseif (n > 1)
     r = (0:n - 1)' ./ (n - 1);
     g = 1 - r;
     b = ones (n, 1);
     map = [r, g, b];
   else
     map = [];
   endif
diff --git a/scripts/image/copper.m b/scripts/image/copper.m
--- a/scripts/image/copper.m
+++ b/scripts/image/copper.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} copper ()
 ## @deftypefnx {Function File} {@var{map} =} copper (@var{n})
 ## Create color colormap.  This colormap varies from black to
 ## a light copper tone.
-## The argument @var{n} must be a scalar.  
+## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = copper (n)
 
@@ -36,17 +36,17 @@ function map = copper (n)
     if (! isscalar (n))
       error ("copper: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
-    map = [0, 0, 0];  
+    map = [0, 0, 0];
   elseif (n > 1)
     x = linspace (0, 1, n)';
     r = (x < 4/5) .* (5/4 * x) + (x >= 4/5);
     g = 4/5 * x;
     b = 1/2 * x;
     map = [r, g, b];
   else
     map = [];
diff --git a/scripts/image/flag.m b/scripts/image/flag.m
--- a/scripts/image/flag.m
+++ b/scripts/image/flag.m
@@ -14,19 +14,19 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} flag ()
 ## @deftypefnx {Function File} {@var{map} =} flag (@var{n})
-## Create color colormap.  This colormap cycles through red, white, blue 
+## Create color colormap.  This colormap cycles through red, white, blue
 ## and black with each index change.
-## The argument @var{n} must be a scalar.  
+## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = flag (n)
 
diff --git a/scripts/image/gmap40.m b/scripts/image/gmap40.m
--- a/scripts/image/gmap40.m
+++ b/scripts/image/gmap40.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} gmap40 ()
 ## @deftypefnx {Function File} {@var{map} =} gmap40 (@var{n})
 ## Create color colormap.  The colormap consists of red, green, blue, yellow,
 ## magenta and cyan.  This colormap is specifically designed for users of
 ## gnuplot 4.0 where these 6 colors are the allowable ones for patch objects.
-## The argument @var{n} must be a scalar. 
+## The argument @var{n} must be a scalar.
 ## If unspecified, a length of 6 is assumed.  Larger values
 ## of @var{n} result in a repetition of the above colors.
 ## @seealso{colormap}
 ## @end deftypefn
 
 function map = gmap40 (n)
 
   if (nargin == 0)
diff --git a/scripts/image/gray.m b/scripts/image/gray.m
--- a/scripts/image/gray.m
+++ b/scripts/image/gray.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} gray ()
 ## @deftypefnx {Function File} {@var{map} =} gray (@var{n})
 ## Create gray colormap.  This colormap varies from black to white with
 ## shades of gray.
-## The argument @var{n} must be a scalar.  
+## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function map = gray (n)
diff --git a/scripts/image/hot.m b/scripts/image/hot.m
--- a/scripts/image/hot.m
+++ b/scripts/image/hot.m
@@ -14,39 +14,39 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} hot ()
 ## @deftypefnx {Function File} {@var{map} =} hot (@var{n})
-## Create color colormap.  This colormap ranges from black through dark red, 
-## red, orange, yellow, to white. 
-## The argument @var{n} must be a scalar.  
+## Create color colormap.  This colormap ranges from black through dark red,
+## red, orange, yellow, to white.
+## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = hot (n)
 
   if (nargin == 0)
     n = rows (colormap);
-  elseif (nargin == 1) 
+  elseif (nargin == 1)
     if (! isscalar (n))
       error ("hot: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
-    map = [0, 0, 0];  
+    map = [0, 0, 0];
   elseif (n > 1)
     x = linspace (0, 1, n)';
     r = (x < 2/5) .* (5/2 * x) + (x >= 2/5);
     g = (x >= 2/5 & x < 4/5) .* (5/2 * x - 1) + (x >= 4/5);
     b = (x >= 4/5) .* (5*x - 4);
     map = [r, g, b];
   else
     map = [];
diff --git a/scripts/image/hsv.m b/scripts/image/hsv.m
--- a/scripts/image/hsv.m
+++ b/scripts/image/hsv.m
@@ -13,24 +13,24 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hsv (@var{n})
-## Create color colormap.  This colormap begins with red, changes through 
-## yellow, green, cyan, blue, and magenta, before returning to red.  
+## Create color colormap.  This colormap begins with red, changes through
+## yellow, green, cyan, blue, and magenta, before returning to red.
 ## It is useful for displaying periodic functions.  It is obtained by linearly
 ## varying the hue through all possible values while keeping constant maximum
 ## saturation and value and is equivalent to
 ## @code{hsv2rgb ([linspace(0,1,N)', ones(N,2)])}.
 ##
-## The argument @var{n} must be a scalar.  
+## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = hsv (n)
 
@@ -40,17 +40,17 @@ function map = hsv (n)
     if (! isscalar (n))
       error ("hsv: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
-    map = [1, 0, 0];  
+    map = [1, 0, 0];
   elseif (n > 1)
     h = linspace (0, 1, n)';
     map = hsv2rgb ([h, ones(n, 1), ones(n, 1)]);
   else
     map = [];
   endif
 
 endfunction
diff --git a/scripts/image/hsv2rgb.m b/scripts/image/hsv2rgb.m
--- a/scripts/image/hsv2rgb.m
+++ b/scripts/image/hsv2rgb.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{rgb_map} =} hsv2rgb (@var{hsv_map})
-## Transform a colormap or image from the HSV space to the RGB space. 
+## Transform a colormap or image from the HSV space to the RGB space.
 ## @seealso{rgb2hsv}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function rgb_map = hsv2rgb (hsv_map)
 
@@ -59,17 +59,17 @@ function rgb_map = hsv2rgb (hsv_map)
   ## set values <0 to 0 and >1 to 1
   hsv_map = (hsv_map >= 0 & hsv_map <= 1) .* hsv_map \
       + (hsv_map < 0) .* 0 + (hsv_map > 1);
 
   ## fill rgb map with v*(1-s)
   rgb_map = kron ([1, 1, 1], hsv_map(:,3) .* (1 - hsv_map(:,2)));
 
   ## red(hue-2/3)=green(hue)=blue(hue-1/3)
-  ## apply modulo 1 for red and blue 
+  ## apply modulo 1 for red and blue
   t = hsv_map(:,1);
   tp = t';
   hue = [(tp - 2/3 - floor (t - 2/3)');
          tp;
          (tp - 1/3 - floor (t - 1/3)')]';
 
   ## factor s*v -> f
   f = kron ([1, 1, 1], hsv_map(:,2)) .* kron ([1, 1, 1], hsv_map(:,3));
diff --git a/scripts/image/image.m b/scripts/image/image.m
--- a/scripts/image/image.m
+++ b/scripts/image/image.m
@@ -22,17 +22,17 @@
 ## Display a matrix as a color image.  The elements of @var{x} are indices
 ## into the current colormap, and the colormap will be scaled so that the
 ## extremes of @var{x} are mapped to the extremes of the colormap.
 ##
 ## The axis values corresponding to the matrix elements are specified in
 ## @var{x} and @var{y}.  If you're not using gnuplot 4.2 or later, these
 ## variables are ignored.
 ##
-## Implementation Note: The origin (0, 0) for images is located in the 
+## Implementation Note: The origin (0, 0) for images is located in the
 ## upper left.  For ordinary plots, the origin is located in the lower
 ## left.  Octave handles this inversion by plotting the data normally,
 ## and then reversing the direction of the y-axis by setting the
 ## @code{ydir} property to @code{"reverse"}.  This has implications whenever
 ## an image and an ordinary plot need to be overlaid.  The recommended
 ## solution is to display the image and then plot the reversed ydata
 ## using, for example, @code{flipud (ydata,1)}.
 ## @seealso{imshow, imagesc, colormap}
diff --git a/scripts/image/imread.m b/scripts/image/imread.m
--- a/scripts/image/imread.m
+++ b/scripts/image/imread.m
@@ -84,17 +84,17 @@ function varargout = imread (filename, v
     else
       error ("imread: invalid Octave image file format");
     endif
 
   end_try_catch
 
 endfunction
 
-%!testif HAVE_MAGICK 
+%!testif HAVE_MAGICK
 %! vpng = [ ...
 %!  137,  80,  78,  71,  13,  10,  26,  10,   0,   0, ...
 %!    0,  13,  73,  72,  68,  82,   0,   0,   0,   3, ...
 %!    0,   0,   0,   3,   8,   2,   0,   0,   0, 217, ...
 %!   74,  34, 232,   0,   0,   0,   1, 115,  82,  71, ...
 %!   66,   0, 174, 206,  28, 233,   0,   0,   0,   4, ...
 %!  103,  65,  77,  65,   0,   0, 177, 143,  11, 252, ...
 %!   97,   5,   0,   0,   0,  32,  99,  72,  82,  77, ...
diff --git a/scripts/image/imshow.m b/scripts/image/imshow.m
--- a/scripts/image/imshow.m
+++ b/scripts/image/imshow.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 1994-2011 John W. Eaton
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -133,17 +133,17 @@ function h = imshow (im, varargin)
     endswitch
   endif
 
   ## Check for complex images.
   if (iscomplex (im))
     warning ("imshow: only showing real part of complex image");
     im = real (im);
   endif
-  
+
   nans = isnan (im(:));
   if (any (nans))
     warning ("Octave:imshow-NaN",
              "imshow: pixels with NaN or NA values are set to minimum pixel value");
     im(nans) = display_range(1);
   endif
 
   ## This is for compatibility.
diff --git a/scripts/image/imwrite.m b/scripts/image/imwrite.m
--- a/scripts/image/imwrite.m
+++ b/scripts/image/imwrite.m
@@ -21,61 +21,61 @@
 ## @deftypefnx {Function File} {} imwrite (@var{img}, @var{filename}, @var{fmt})
 ## @deftypefnx {Function File} {} imwrite (@var{img}, @var{filename}, @var{fmt}, @var{p1}, @var{v1}, @dots{})
 ## @deftypefnx {Function File} {} imwrite (@var{img}, @var{map}, @var{filename}, @dots{})
 ## Write images in various file formats.
 ##
 ## If @var{fmt} is not supplied, the file extension of @var{filename} is used
 ## to determine the format.
 ##
-## The parameter-value pairs (@var{p1}, @var{v1}, @dots{}) are optional. 
+## The parameter-value pairs (@var{p1}, @var{v1}, @dots{}) are optional.
 ## Currently the following options are supported for @t{JPEG} images:
 ##
 ## @table @samp
 ## @item Quality
 ## Set the quality of the compression.  The value should be an
-## integer between 0 and 100, with larger values indicating higher visual 
+## integer between 0 and 100, with larger values indicating higher visual
 ## quality and lower compression.
 ## @end table
 ##
-## @strong{Supported Formats} 
+## @strong{Supported Formats}
 ## @multitable @columnfractions .33 .66
-## @headitem Extension @tab Format 
-## @item bmp @tab Windows Bitmap 
-## @item gif @tab Graphics Interchange Format 
+## @headitem Extension @tab Format
+## @item bmp @tab Windows Bitmap
+## @item gif @tab Graphics Interchange Format
 ## @item jpg and jpeg @tab Joint Photographic Experts Group
 ## @item pbm @tab Portable Bitmap
-## @item pcx @tab 
+## @item pcx @tab
 ## @item pgm @tab Portable Graymap
 ## @item png @tab Portable Network Graphics
 ## @item pnm @tab Portable Anymap
 ## @item ppm @tab Portable Pixmap
 ## @item ras @tab Sun Raster
 ## @item tif and tiff @tab Tagged Image File Format
 ## @item xwd @tab X11 Dump
 ## @end multitable
 ##
-## @strong{Unsupported Formats} 
+## @strong{Unsupported Formats}
 ## @multitable @columnfractions .33 .66
-## @headitem Extension @tab Format 
+## @headitem Extension @tab Format
 ## @item hdf @tab Hierarchical Data Format V4
 ## @item jp2 and jpx @tab Joint Photographic Experts Group 2000
 ## @end multitable
 ##
 ## @seealso{imread, imfinfo}
 ## @end deftypefn
 
 function imwrite (img, varargin)
-  
+
   persistent imwrite_possible_formats = {
     "bmp"; "gif"; "jp2"; "jpg"; "jpx"; "jpeg"; "hdf"; "pbm"; "pcx";
     "pgm"; "png"; "pnm"; "ppm"; "ras"; "tif"; "tiff"; "xwd" };
 
   persistent accepted_formats = __magick_format_list__ (imwrite_possible_formats);
-  
+
   if (nargin < 2 || ! (isnumeric (img) || islogical (img)))
     print_usage ();
   endif
 
   map = [];
   fmt = "";
 
   offset = 1;
diff --git a/scripts/image/ind2rgb.m b/scripts/image/ind2rgb.m
--- a/scripts/image/ind2rgb.m
+++ b/scripts/image/ind2rgb.m
@@ -38,31 +38,31 @@ function [R, G, B] = ind2rgb (x, map)
   elseif (nargin == 1)
     map = colormap ();
   endif
 
   ## Check if X is an indexed image.
   if (ndims (x) != 2 || any (x(:) != round (x(:))) || min (x(:)) < 1)
     error ("ind2rgb: X must be an indexed image");
   endif
-  
+
   ## Check the color map.
   if (ndims (map) != 2 || columns (map) != 3)
     error ("ind2rgb: MAP must be a valid colormap");
   endif
 
   ## Do we have enough colors in the color map?
   maxidx = max (x(:));
   rm = rows (map);
   if (rm < maxidx)
     ## Pad with the last color in the map.
     pad = repmat (map(end,:), maxidx-rm, 1);
     map(end+1:maxidx, :) = pad;
   endif
-  
+
   ## Compute result
   [hi, wi] = size (x);
   R = reshape (map (x(:), 1), hi, wi);
   G = reshape (map (x(:), 2), hi, wi);
   B = reshape (map (x(:), 3), hi, wi);
 
   ## Use 3D array if only one output is requested.
   if (nargout <= 1)
diff --git a/scripts/image/jet.m b/scripts/image/jet.m
--- a/scripts/image/jet.m
+++ b/scripts/image/jet.m
@@ -15,18 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} jet ()
 ## @deftypefnx {Function File} {@var{map} =} jet (@var{n})
 ## Create color colormap.  This colormap ranges from dark blue through blue,
-## cyan, green, yellow, red, to dark red. 
-## The argument @var{n} must be a scalar.  
+## cyan, green, yellow, red, to dark red.
+## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = jet (n)
 
@@ -36,17 +36,17 @@ function map = jet (n)
     if (! isscalar (n))
       error ("jet: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
-    map = [0, 0, 0.5];  
+    map = [0, 0, 0.5];
   elseif (n > 1)
     x = linspace(0, 1, n)';
     r = (x >= 3/8 & x < 5/8) .* (4 * x - 3/2)\
       + (x >= 5/8 & x < 7/8) + (x >= 7/8) .* (-4 * x + 9/2);
     g = (x >= 1/8 & x < 3/8) .* (4 * x - 1/2)\
       + (x >= 3/8 & x < 5/8) + (x >= 5/8 & x < 7/8) .* (-4 * x + 7/2);
     b = (x < 1/8) .* (4 * x + 1/2) + (x >= 1/8 & x < 3/8)\
       + (x >= 3/8 & x < 5/8) .* (-4 * x + 5/2);
diff --git a/scripts/image/ntsc2rgb.m b/scripts/image/ntsc2rgb.m
--- a/scripts/image/ntsc2rgb.m
+++ b/scripts/image/ntsc2rgb.m
@@ -46,17 +46,17 @@ function rgb = ntsc2rgb (yiq)
     endif
   else
     is_image = false;
   endif
 
   if (! ismatrix (yiq) || columns (yiq) != 3)
     error ("ntsc2rgb: argument must be a matrix of size Nx3 or NxMx3");
   endif
-  
+
   ## Convert data
   trans = [ 1.0,      1.0,      1.0;
             0.95617, -0.27269, -1.10374;
             0.62143, -0.64681, 1.70062 ];
 
   rgb = yiq * trans;
 
   ## If input was an image, convert it back into one.
diff --git a/scripts/image/ocean.m b/scripts/image/ocean.m
--- a/scripts/image/ocean.m
+++ b/scripts/image/ocean.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} ocean ()
 ## @deftypefnx {Function File} {@var{map} =} ocean (@var{n})
 ## Create color colormap.  This colormap varies from black to white with shades
 ## of blue.
-## The argument @var{n} must be a scalar.  
+## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function map = ocean (n)
diff --git a/scripts/image/pink.m b/scripts/image/pink.m
--- a/scripts/image/pink.m
+++ b/scripts/image/pink.m
@@ -15,18 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} pink ()
 ## @deftypefnx {Function File} {@var{map} =} pink (@var{n})
 ## Create color colormap.  This colormap varies from black to white with
-## shades of gray-pink.  It gives a sepia tone when used on grayscale images. 
-## The argument @var{n} must be a scalar.  
+## shades of gray-pink.  It gives a sepia tone when used on grayscale images.
+## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = pink (n)
 
@@ -36,17 +36,17 @@ function map = pink (n)
     if (! isscalar (n))
       error ("pink: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
-    map = [0, 0, 0];  
+    map = [0, 0, 0];
   elseif (n > 1)
     x = linspace (0, 1, n)';
     r = (x < 3/8) .* (14/9 * x) + (x >= 3/8) .* (2/3 * x + 1/3);
     g = (x < 3/8) .* (2/3 * x)\
       + (x >= 3/8 & x < 3/4) .* (14/9 * x - 1/3)\
       + (x >= 3/4) .* (2/3 * x + 1/3);
     b = (x < 3/4) .* (2/3 * x) + (x >= 3/4) .* (2 * x - 1);
 
diff --git a/scripts/image/prism.m b/scripts/image/prism.m
--- a/scripts/image/prism.m
+++ b/scripts/image/prism.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} prism ()
 ## @deftypefnx {Function File} {@var{map} =} prism (@var{n})
 ## Create color colormap.  This colormap cycles through red, orange, yellow,
 ## green, blue and violet with each index change.
-## The argument @var{n} must be a scalar.  
+## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = prism (n)
 
diff --git a/scripts/image/rainbow.m b/scripts/image/rainbow.m
--- a/scripts/image/rainbow.m
+++ b/scripts/image/rainbow.m
@@ -14,19 +14,19 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} rainbow ()
 ## @deftypefnx {Function File} {@var{map} =} rainbow (@var{n})
-## Create color colormap.  This colormap ranges from red through orange, 
-## yellow, green, blue, to violet.  
-## The argument @var{n} must be a scalar.  
+## Create color colormap.  This colormap ranges from red through orange,
+## yellow, green, blue, to violet.
+## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 ## this colormap is not part of matlab, it is like the prism
 ## colormap map but with a continuous map
@@ -39,17 +39,17 @@ function map = rainbow (n)
     if (! isscalar (n))
       error ("rainbow: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
-    map = [1, 0, 0];  
+    map = [1, 0, 0];
   elseif (n > 1)
     x = linspace (0, 1, n)';
     r = (x < 2/5) + (x >= 2/5 & x < 3/5) .* (-5 * x + 3)\
       + (x >= 4/5) .* (10/3 * x - 8/3);
     g = (x < 2/5) .* (5/2 * x) + (x >= 2/5 & x < 3/5)\
       + (x >= 3/5 & x < 4/5) .* (-5 * x + 4);
     b = (x >= 3/5 & x < 4/5) .* (5 * x - 3) + (x >= 4/5);
     map = [r, g, b];
diff --git a/scripts/image/rgb2hsv.m b/scripts/image/rgb2hsv.m
--- a/scripts/image/rgb2hsv.m
+++ b/scripts/image/rgb2hsv.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{hsv_map} =} rgb2hsv (@var{rgb})
 ## Transform a colormap or image from the RGB space to the HSV space.
 ##
 ## A color in the RGB space consists of the red, green and blue intensities.
 ##
 ## In the HSV space each color is represented by their hue, saturation
 ## and value (brightness).  Value gives the amount of light in the color.
-## Hue describes the dominant wavelength. 
+## Hue describes the dominant wavelength.
 ## Saturation is the amount of hue mixed into the color.
 ## @seealso{hsv2rgb}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 ## Adapted-by: jwe
 
 function hsv_map = rgb2hsv (rgb)
@@ -60,17 +60,17 @@ function hsv_map = rgb2hsv (rgb)
 
   ## get the max and min
   s = min (rgb')';
   v = max (rgb')';
 
   ## set hue to zero for undefined values (gray has no hue)
   h = zeros (size (v));
   notgray = (s != v);
-    
+
   ## blue hue
   idx = (v == rgb(:,3) & notgray);
   if (any (idx))
     h(idx) = 2/3 + 1/6 * (rgb(idx,1) - rgb(idx,2)) ./ (v(idx) - s(idx));
   endif
 
   ## green hue
   idx = (v == rgb(:,2) & notgray);
@@ -88,15 +88,15 @@ function hsv_map = rgb2hsv (rgb)
   idx = (h < 0);
   h(idx) = 1+h(idx);
 
   ## set the saturation
   s(! notgray) = 0;
   s(notgray) = 1 - s(notgray) ./ v(notgray);
 
   hsv_map = [h, s, v];
-  
+
   ## If input was an image, convert it back into one.
   if (is_image)
     hsv_map = reshape (hsv_map, Sz);
   endif
 
 endfunction
diff --git a/scripts/image/rgb2ind.m b/scripts/image/rgb2ind.m
--- a/scripts/image/rgb2ind.m
+++ b/scripts/image/rgb2ind.m
@@ -29,17 +29,17 @@
 ## Created: July 1994
 ## Adapted-By: jwe
 
 function [x, map] = rgb2ind (R, G, B)
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
-  
+
   if (nargin == 1)
     rgb = R;
     if (length (size (rgb)) == 3 && size (rgb, 3) == 3)
       R = rgb(:,:,1);
       G = rgb(:,:,2);
       B = rgb(:,:,3);
     else
       error ("rgb2ind: argument is not an RGB image");
diff --git a/scripts/image/rgb2ntsc.m b/scripts/image/rgb2ntsc.m
--- a/scripts/image/rgb2ntsc.m
+++ b/scripts/image/rgb2ntsc.m
@@ -46,17 +46,17 @@ function yiq = rgb2ntsc (rgb)
     endif
   else
     is_image = false;
   endif
 
   if (! ismatrix (rgb) || columns (rgb) != 3)
     error ("rgb2ntsc: argument must be a matrix of size Nx3 or NxMx3");
   endif
-  
+
   ## Convert data
   trans = [ 0.299,  0.596,  0.211;
             0.587, -0.274, -0.523;
             0.114, -0.322,  0.312 ];
 
   yiq = rgb * trans;
 
   ## If input was an image, convert it back into one.
diff --git a/scripts/image/spring.m b/scripts/image/spring.m
--- a/scripts/image/spring.m
+++ b/scripts/image/spring.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} spring ()
 ## @deftypefnx {Function File} {@var{map} =} spring (@var{n})
 ## Create color colormap.  This colormap varies from magenta to yellow.
-## The argument @var{n} must be a scalar.  
+## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = spring (n)
 
@@ -35,17 +35,17 @@ function map = spring (n)
     if (! isscalar (n))
       error ("spring: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
-    map = [1, 0, 1];  
+    map = [1, 0, 1];
   elseif (n > 1)
     r = ones (n, 1);
     g = (0:n - 1)' ./ (n - 1);
     b = 1 - g;
     map = [r, g, b];
   else
     map = [];
   endif
diff --git a/scripts/image/summer.m b/scripts/image/summer.m
--- a/scripts/image/summer.m
+++ b/scripts/image/summer.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} summer ()
 ## @deftypefnx {Function File} {@var{map} =} summer (@var{n})
 ## Create color colormap.  This colormap varies from green to yellow.
-## The argument @var{n} must be a scalar.  
+## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 ## Date:  06/03/2000
 function map = summer (n)
 
@@ -35,17 +35,17 @@ function map = summer (n)
     if (! isscalar (n))
       error ("summer: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
-    map = [0, 0.5, 0.4];  
+    map = [0, 0.5, 0.4];
   elseif (n > 1)
     r = (0:n - 1)' ./ (n - 1);
     g = 0.5 + r ./ 2;
     b = 0.4 * ones (n, 1);
 
     map = [r, g, b];
   else
     map = [];
diff --git a/scripts/image/winter.m b/scripts/image/winter.m
--- a/scripts/image/winter.m
+++ b/scripts/image/winter.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{map} =} winter ()
 ## @deftypefnx {Function File} {@var{map} =} winter (@var{n})
 ## Create color colormap.  This colormap varies from blue to green.
-## The argument @var{n} must be a scalar.  
+## The argument @var{n} must be a scalar.
 ## If unspecified, the length of the current colormap, or 64, is used.
 ## @seealso{colormap}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
 
 function map = winter (n)
 
@@ -35,17 +35,17 @@ function map = winter (n)
     if (! isscalar (n))
       error ("winter: argument must be a scalar");
     endif
   else
     print_usage ();
   endif
 
   if (n == 1)
-    map = [0, 0, 1];  
+    map = [0, 0, 1];
   elseif (n > 1)
     r = zeros (n, 1);
     g = (0:n - 1)' ./ (n - 1);
     b = 1 - g ./ 2;
 
     map = [r, g, b];
   else
     map = [];
diff --git a/scripts/io/dlmwrite.m b/scripts/io/dlmwrite.m
--- a/scripts/io/dlmwrite.m
+++ b/scripts/io/dlmwrite.m
@@ -70,19 +70,19 @@
 ## @example
 ## dlmwrite ("file.tex", a, "delimiter", "&", "newline", "\\n")
 ## @end example
 ##
 ## @seealso{dlmread, csvread, csvwrite}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
-## 
+##
 ## This program was originally granted to the public domain
-## 
+##
 ## 2002-03-08 Paul Kienzle <pkienzle@users.sf.net>
 ## * Initial revision
 ## 2005-11-27 Bill Denney <bill@givebillmoney.com>
 ## * Significant modifications of the input arguements for additional
 ## functionality.
 
 function dlmwrite (file, M, varargin)
 
diff --git a/scripts/io/fileread.m b/scripts/io/fileread.m
--- a/scripts/io/fileread.m
+++ b/scripts/io/fileread.m
@@ -33,15 +33,15 @@ function str = fileread (filename)
   endif
 
   fid = fopen (filename, "r");
   if (fid < 0)
     error ("fileread: cannot open file");
   endif
 
   unwind_protect
-    str = fread (fid, "*char");    
+    str = fread (fid, "*char");
   unwind_protect_cleanup
     fclose (fid);
   end_unwind_protect
 
 endfunction
 
diff --git a/scripts/io/strread.m b/scripts/io/strread.m
--- a/scripts/io/strread.m
+++ b/scripts/io/strread.m
@@ -99,17 +99,17 @@
 ## @seealso{textread, load, dlmread, fscanf}
 ## @end deftypefn
 
 function varargout = strread (str, format = "%f", varargin)
   ## Check input
   if (nargin < 1)
     print_usage ();
   endif
- 
+
   if (!ischar (str) || !ischar (format))
     error ("strread: STR and FORMAT arguments must be strings");
   endif
 
   ## Parse options
   comment_flag = false;
   numeric_fill_value = 0;
   white_spaces = " \n\r\t\b";
@@ -133,17 +133,17 @@ function varargout = strread (str, forma
       case "delimiter"
         delimiter_str = varargin {n+1};
       case "emptyvalue"
         numeric_fill_value = varargin {n+1};
       case "bufsize"
         ## XXX: We could synthesize this, but that just seems weird...
         warning ("strread: property \"bufsize\" is not implemented");
       case "whitespace"
-        white_spaces = varargin {n+1}; 
+        white_spaces = varargin {n+1};
       case "expchars"
         warning ("strread: property \"expchars\" is not implemented");
       otherwise
         warning ("strread: unknown property \"%s\"", varargin {n});
     endswitch
   endfor
   if (isempty (delimiter_str))
     delimiter_str = white_spaces;
@@ -196,22 +196,22 @@ function varargout = strread (str, forma
     if (length (fmt_words{m}) > 2)
       if (strcmp (fmt_words{m}(1:2), "%*"))
         fmt_words{m} = "%*";
       elseif (fmt_words{m}(1) == "%")
         fmt_words{m} = fmt_words{m}([1, end]);
       endif
     endif
   endfor
- 
+
   ## Split 'str' into words
   words = split_by (str, delimiter_str);
   num_words = numel (words);
   num_lines = ceil (num_words / num_words_per_line);
- 
+
   ## For each specifier
   k = 1;
   for m = 1:num_words_per_line
     data = words (m:num_words_per_line:end);
     ## Map to format
     ## FIXME - add support for formats like "%4s" or "<%s>", "%[a-zA-Z]"
     ##         Someone with regexp experience is needed.
     switch fmt_words{m}
diff --git a/scripts/io/textread.m b/scripts/io/textread.m
--- a/scripts/io/textread.m
+++ b/scripts/io/textread.m
@@ -35,33 +35,33 @@
 ## @seealso{strread, load, dlmread, fscanf}
 ## @end deftypefn
 
 function varargout = textread (filename, format = "%f", varargin)
   ## Check input
   if (nargin < 1)
     print_usage ();
   endif
-  
+
   if (!ischar (filename) || !ischar (format))
     error ("textread: first and second input arguments must be strings");
   endif
 
   ## Read file
   fid = fopen (filename, "r");
   if (fid == -1)
     error ("textread: could not open '%s' for reading", filename);
   endif
 
   ## Maybe skip header lines
   headerlines = find (strcmpi (varargin, "headerlines"), 1);
   if (! isempty (headerlines))
     fskipl (fid, headerlines);
     varargin(headerlines:headerlines+1) = [];
   endif
-  
+
   str = fread (fid, "char=>char").';
   fclose (fid);
-  
+
   ## Call strread to make it do the real work
   [varargout{1:max (nargout, 1)}] = strread (str, format, varargin {:});
 
 endfunction
diff --git a/scripts/linear-algebra/cond.m b/scripts/linear-algebra/cond.m
--- a/scripts/linear-algebra/cond.m
+++ b/scripts/linear-algebra/cond.m
@@ -16,26 +16,26 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} cond (@var{A})
 ## @deftypefnx {Function File} {} cond (@var{A}, @var{p})
 ## Compute the @var{p}-norm condition number of a matrix.  @code{cond
 ## (@var{A})} is
-## defined as 
+## defined as
 ## @tex
 ## $ {\parallel A \parallel_p * \parallel A^{-1} \parallel_p .} $
 ## @end tex
 ## @ifnottex
 ## @code{norm (@var{A}, @var{p}) * norm (inv (@var{A}), @var{p})}.
 ## @end ifnottex
 ##
 ## By default @code{@var{p} = 2} is used which implies a (relatively slow)
-## singular value decomposition.  Other possible selections are 
+## singular value decomposition.  Other possible selections are
 ## @code{@var{p} = 1, Inf, "fro"} which are generally faster.  See
 ## @code{norm} for a full discussion of possible @var{p} values.
 ## @seealso{condest, rcond, norm, svd}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = cond (A, p)
@@ -61,17 +61,17 @@ function retval = cond (A, p)
         sigma_n = sigma(end);
         if (sigma_1 == 0 || sigma_n == 0)
           retval = Inf;
         else
           retval = sigma_1 / sigma_n;
         endif
       endif
     else
-      retval = norm (A, p) * norm (inv (A), p);  
+      retval = norm (A, p) * norm (inv (A), p);
     endif
   else
     print_usage ();
   endif
 
 endfunction
 
 %!test
diff --git a/scripts/linear-algebra/condest.m b/scripts/linear-algebra/condest.m
--- a/scripts/linear-algebra/condest.m
+++ b/scripts/linear-algebra/condest.m
@@ -12,28 +12,28 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {} condest (@var{A}) 
-## @deftypefnx {Function File} {} condest (@var{A}, @var{t}) 
-## @deftypefnx {Function File} {[@var{est}, @var{v}] =} condest (@dots{}) 
+## @deftypefn  {Function File} {} condest (@var{A})
+## @deftypefnx {Function File} {} condest (@var{A}, @var{t})
+## @deftypefnx {Function File} {[@var{est}, @var{v}] =} condest (@dots{})
 ## @deftypefnx {Function File} {[@var{est}, @var{v}] =} condest (@var{A}, @var{solve}, @var{solve_t}, @var{t})
 ## @deftypefnx {Function File} {[@var{est}, @var{v}] =} condest (@var{apply}, @var{apply_t}, @var{solve}, @var{solve_t}, @var{n}, @var{t})
 ##
 ## Estimate the 1-norm condition number of a matrix @var{A}
 ## using @var{t} test vectors using a randomized 1-norm estimator.
 ## If @var{t} exceeds 5, then only 5 test vectors are used.
 ##
-## If the matrix is not explicit, e.g., when estimating the condition 
-## number of @var{A} given an LU factorization, @code{condest} uses the 
+## If the matrix is not explicit, e.g., when estimating the condition
+## number of @var{A} given an LU factorization, @code{condest} uses the
 ## following functions:
 ##
 ## @table @var
 ## @item apply
 ## @code{A*x} for a matrix @code{x} of size @var{n} by @var{t}.
 ##
 ## @item apply_t
 ## @code{A'*x} for a matrix @code{x} of size @var{n} by @var{t}.
@@ -50,25 +50,25 @@
 ## @code{condest} uses a randomized algorithm to approximate
 ## the 1-norms.
 ##
 ## @code{condest} returns the 1-norm condition estimate @var{est} and
 ## a vector @var{v} satisfying @code{norm (A*v, 1) == norm (A, 1) * norm
 ## (@var{v}, 1) / @var{est}}.  When @var{est} is large, @var{v} is an
 ## approximate null vector.
 ##
-## References: 
+## References:
 ## @itemize
-## @item 
+## @item
 ## N.J. Higham and F. Tisseur, @cite{A Block Algorithm
 ## for Matrix 1-Norm Estimation, with an Application to 1-Norm
 ## Pseudospectra}. SIMAX vol 21, no 4, pp 1185-1201.
 ## @url{http://dx.doi.org/10.1137/S0895479899356080}
 ##
-## @item 
+## @item
 ## N.J. Higham and F. Tisseur, @cite{A Block Algorithm
 ## for Matrix 1-Norm Estimation, with an Application to 1-Norm
 ## Pseudospectra}. @url{http://citeseer.ist.psu.edu/223007.html}
 ## @end itemize
 ##
 ## @seealso{cond, norm, onenormest}
 ## @end deftypefn
 
diff --git a/scripts/linear-algebra/cross.m b/scripts/linear-algebra/cross.m
--- a/scripts/linear-algebra/cross.m
+++ b/scripts/linear-algebra/cross.m
@@ -24,29 +24,29 @@
 ##
 ## @example
 ## @group
 ## cross ([1,1,0], [0,1,1])
 ##      @result{} [ 1; -1; 1 ]
 ## @end group
 ## @end example
 ##
-## If @var{x} and @var{y} are matrices, the cross product is applied 
-## along the first dimension with 3 elements.  The optional argument 
+## If @var{x} and @var{y} are matrices, the cross product is applied
+## along the first dimension with 3 elements.  The optional argument
 ## @var{dim} forces the cross product to be calculated along
 ## the specified dimension.
 ## @seealso{dot}
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 15 October 1994
 ## Adapted-By: jwe
 
 function z = cross (x, y, dim)
-        
+
   if (nargin != 2 && nargin != 3)
     print_usage ();
   endif
 
   if (ndims (x) < 3 && ndims (y) < 3 && nargin < 3)
     ## COMPATIBILITY -- opposite behaviour for cross(row,col)
     ## Swap x and y in the assignments below to get the matlab behaviour.
     ## Better yet, fix the calling code so that it uses conformant vectors.
@@ -56,17 +56,17 @@ function z = cross (x, y, dim)
     elseif (rows (x) == 1 && columns (y) == 1)
       warning ("cross: taking cross product of row by column");
       x = x.';
     endif
   endif
 
   if (nargin == 2)
      dim = find (size (x) == 3, 1);
-     if (isempty (dim)) 
+     if (isempty (dim))
        error ("cross: must have at least one dimension with 3 elements");
      endif
    else
      if (size (x, dim) != 3)
        error ("cross: dimension DIM must have 3 elements");
      endif
   endif
 
diff --git a/scripts/linear-algebra/expm.m b/scripts/linear-algebra/expm.m
--- a/scripts/linear-algebra/expm.m
+++ b/scripts/linear-algebra/expm.m
@@ -21,40 +21,40 @@
 ## Return the exponential of a matrix, defined as the infinite Taylor
 ## series
 ## @tex
 ## $$
 ##  \exp (A) = I + A + {A^2 \over 2!} + {A^3 \over 3!} + \cdots
 ## $$
 ## @end tex
 ## @ifnottex
-## 
+##
 ## @example
 ## expm(A) = I + A + A^2/2! + A^3/3! + @dots{}
 ## @end example
-## 
+##
 ## @end ifnottex
 ## The Taylor series is @emph{not} the way to compute the matrix
 ## exponential; see Moler and Van Loan, @cite{Nineteen Dubious Ways to
 ## Compute the Exponential of a Matrix}, SIAM Review, 1978.  This routine
-## uses Ward's diagonal Pad@'e approximation method with three step 
+## uses Ward's diagonal Pad@'e approximation method with three step
 ## preconditioning (SIAM Journal on Numerical Analysis, 1977).  Diagonal
 ## Pad@'e approximations are rational polynomials of matrices
 ## @tex
 ## $D_q(A)^{-1}N_q(A)$
 ## @end tex
 ## @ifnottex
-## 
+##
 ## @example
 ## @group
 ##      -1
 ## D (A)   N (A)
 ## @end group
 ## @end example
-## 
+##
 ## @end ifnottex
 ## whose Taylor series matches the first
 ## @tex
 ## $2 q + 1 $
 ## @end tex
 ## @ifnottex
 ## @code{2q+1}
 ## @end ifnottex
diff --git a/scripts/linear-algebra/isdefinite.m b/scripts/linear-algebra/isdefinite.m
--- a/scripts/linear-algebra/isdefinite.m
+++ b/scripts/linear-algebra/isdefinite.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} isdefinite (@var{x})
 ## @deftypefnx {Function File} {} isdefinite (@var{x}, @var{tol})
 ## Return 1 if @var{x} is symmetric positive definite within the
 ## tolerance specified by @var{tol} or 0 if @var{x} is symmetric
 ## positive semidefinite.  Otherwise, return -1.  If @var{tol}
-## is omitted, use a tolerance of 
+## is omitted, use a tolerance of
 ## @code{100 * eps * norm (@var{x}, "fro")}
 ## @seealso{issymmetric, ishermitian}
 ## @end deftypefn
 
 ## Author: Gabriele Pannocchia <g.pannocchia@ing.unipi.it>
 ## Created: November 2003
 ## Adapted-By: jwe
 
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -45,17 +45,17 @@
 ##
 ## The optional parameter @var{eps1} is the threshold for zero.  The
 ## default value is 1e-12.
 ##
 ## If the optional parameter @var{pflg} is nonzero, row pivoting is used
 ## to improve numerical behavior.  The default value is 0.
 ##
 ## Reference: A. Hodel, P. Misra, @cite{Partial Pivoting in the Computation of
-## Krylov Subspaces of Large Sparse Systems}, Proceedings of the 42nd IEEE 
+## Krylov Subspaces of Large Sparse Systems}, Proceedings of the 42nd IEEE
 ## Conference on Decision and Control, December 2003.
 ## @end deftypefn
 
 ## Author: A. Scottedward Hodel <a.s.hodel@eng.auburn.edu>
 
 function [Uret, H, nu] = krylov (A, V, k, eps1, pflg);
 
   if (isa (A, "single") || isa (V, "single"))
diff --git a/scripts/linear-algebra/logm.m b/scripts/linear-algebra/logm.m
--- a/scripts/linear-algebra/logm.m
+++ b/scripts/linear-algebra/logm.m
@@ -30,22 +30,22 @@
 ## @end example
 ##
 ## The optional argument @var{opt_iters} is the maximum number of square roots
 ## to compute and defaults to 100.  The optional output @var{iters} is the
 ## number of square roots actually computed.
 ##
 ## @end deftypefn
 
-## Reference: N. J. Higham, Functions of Matrices: Theory and Computation 
+## Reference: N. J. Higham, Functions of Matrices: Theory and Computation
 ##            (SIAM, 2008.)
 ##
 
 function [s, iters] = logm (A, opt_iters = 100)
- 
+
   if (nargin == 0 || nargin > 2)
     print_usage ();
   endif
 
   if (! issquare (A))
     error ("logm: A must be a square matrix");
   endif
 
@@ -103,18 +103,18 @@ function [s, iters] = logm (A, opt_iters
   if (nargout == 2)
     iters = k;
   endif
 
 endfunction
 
 ################## ANCILLARY FUNCTIONS ################################
 ######  Taken from the mfttoolbox (GPL 3) by D. Higham.
-######  Reference: 
-######      D. Higham, Functions of Matrices: Theory and Computation 
+######  Reference:
+######      D. Higham, Functions of Matrices: Theory and Computation
 ######      (SIAM, 2008.).
 #######################################################################
 
 ##LOGM_PADE_PF   Evaluate Pade approximant to matrix log by partial fractions.
 ##   Y = LOGM_PADE_PF(A,M) evaluates the [M/M] Pade approximation to
 ##   LOG(EYE(SIZE(A))+A) using a partial fraction expansion.
 
 function s = logm_pade_pf (A, m)
diff --git a/scripts/linear-algebra/normest.m b/scripts/linear-algebra/normest.m
--- a/scripts/linear-algebra/normest.m
+++ b/scripts/linear-algebra/normest.m
@@ -34,21 +34,21 @@
 function [n, c] = normest (A, tol = 1e-6)
 
   if (nargin != 1 && nargin != 2)
     print_usage ();
   endif
 
   if (! (isnumeric (A) && ndims (A) == 2))
     error ("normest: A must be a numeric 2-D matrix");
-  endif 
+  endif
 
   if (! (isscalar (tol) && isreal (tol)))
     error ("normest: TOL must be a real scalar");
-  endif 
+  endif
 
   if (! isfloat (A))
     A = double (A);
   endif
 
   tol = max (tol, eps (class (A)));
   ## Set random number generator to depend on target matrix
   v = rand ("state");
diff --git a/scripts/linear-algebra/onenormest.m b/scripts/linear-algebra/onenormest.m
--- a/scripts/linear-algebra/onenormest.m
+++ b/scripts/linear-algebra/onenormest.m
@@ -12,37 +12,37 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {[@var{est}, @var{v}, @var{w}, @var{iter}] =} onenormest (@var{A}, @var{t}) 
+## @deftypefn  {Function File} {[@var{est}, @var{v}, @var{w}, @var{iter}] =} onenormest (@var{A}, @var{t})
 ## @deftypefnx {Function File} {[@var{est}, @var{v}, @var{w}, @var{iter}] =} onenormest (@var{apply}, @var{apply_t}, @var{n}, @var{t})
 ##
 ## Apply Higham and Tisseur's randomized block 1-norm estimator to
 ## matrix @var{A} using @var{t} test vectors.  If @var{t} exceeds 5, then
 ## only 5 test vectors are used.
 ##
-## If the matrix is not explicit, e.g., when estimating the norm of 
-## @code{inv (@var{A})} given an LU factorization, @code{onenormest} applies 
-## @var{A} and its conjugate transpose through a pair of functions 
-## @var{apply} and @var{apply_t}, respectively, to a dense matrix of size 
-## @var{n} by @var{t}.  The implicit version requires an explicit dimension 
+## If the matrix is not explicit, e.g., when estimating the norm of
+## @code{inv (@var{A})} given an LU factorization, @code{onenormest} applies
+## @var{A} and its conjugate transpose through a pair of functions
+## @var{apply} and @var{apply_t}, respectively, to a dense matrix of size
+## @var{n} by @var{t}.  The implicit version requires an explicit dimension
 ## @var{n}.
 ##
 ## Returns the norm estimate @var{est}, two vectors @var{v} and
 ## @var{w} related by norm
 ## @code{(@var{w}, 1) = @var{est} * norm (@var{v}, 1)},
 ## and the number of iterations @var{iter}.  The number of
 ## iterations is limited to 10 and is at least 2.
 ##
-## References: 
+## References:
 ## @itemize
 ## @item
 ## N.J. Higham and F. Tisseur, @cite{A Block Algorithm
 ## for Matrix 1-Norm Estimation, with an Application to 1-Norm
 ## Pseudospectra}. SIMAX vol 21, no 4, pp 1185-1201.
 ## @url{http://dx.doi.org/10.1137/S0895479899356080}
 ##
 ## @item
@@ -193,17 +193,17 @@ function [est, v, w, iter] = onenormest 
     endif
     ## Now test for parallel vectors within S.
     partest = any ((S' * S - eye (t)) == n);
     if (any (partest))
       numpar = sum (partest);
       replacements = 2*(rand (n,numpar) < 0.5) - 1;
       S(:,partest) = replacements;
     endif
-    
+
     Z = feval (apply_t, S);
 
     ## Now find the largest non-previously-visted index per
     ## vector.
     h = max (abs (Z),2);
     [mh, mhi] = max (h);
     if (iter >= 2 && mhi == ind_best)
       ## Hit a cycle, stop.
diff --git a/scripts/linear-algebra/rref.m b/scripts/linear-algebra/rref.m
--- a/scripts/linear-algebra/rref.m
+++ b/scripts/linear-algebra/rref.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{r}, @var{k}] =} rref (@var{A}, @var{tol})
 ##
 ## Returns the reduced row echelon form of @var{A}.  @var{tol} defaults
 ## to @code{eps * max (size (@var{A})) * norm (@var{A}, inf)}.
 ##
 ## Called with two return arguments, @var{k} returns the vector of
-## "bound variables", which are those columns on which elimination 
+## "bound variables", which are those columns on which elimination
 ## has been performed.
 ##
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 ##         (based on an anonymous source from the public domain)
 
 function [A, k] = rref (A, tol)
diff --git a/scripts/linear-algebra/subspace.m b/scripts/linear-algebra/subspace.m
--- a/scripts/linear-algebra/subspace.m
+++ b/scripts/linear-algebra/subspace.m
@@ -21,18 +21,18 @@
 ## Determine the largest principal angle between two subspaces
 ## spanned by the columns of matrices @var{A} and @var{B}.
 ## @end deftypefn
 
 ## Author: Jaroslav Hajek <highegg@gmail.com>
 
 ## reference:
 ## [1]  Andrew V. Knyazev, Merico E. Argentati:
-##   Principal Angles between Subspaces in an A-Based Scalar Product: 
-##  Algorithms and Perturbation Estimates.  
+##   Principal Angles between Subspaces in an A-Based Scalar Product:
+##  Algorithms and Perturbation Estimates.
 ##  SIAM Journal on Scientific Computing, Vol. 23 no. 6, pp. 2008-2040
 ##
 ## other texts are also around...
 
 function ang = subspace (A, B)
 
   if (nargin != 2)
     print_usage ();
diff --git a/scripts/miscellaneous/ans.m b/scripts/miscellaneous/ans.m
--- a/scripts/miscellaneous/ans.m
+++ b/scripts/miscellaneous/ans.m
@@ -15,16 +15,16 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @defvr {Automatic Variable} ans
 ## The most recently computed result that was not
 ## explicitly assigned to a variable.  For example, after the expression
-## 
+##
 ## @example
 ## 3^2 + 4^2
 ## @end example
-## 
+##
 ## @noindent
 ## is evaluated, the value returned by @code{ans} is 25.
 ## @end defvr
diff --git a/scripts/miscellaneous/bincoeff.m b/scripts/miscellaneous/bincoeff.m
--- a/scripts/miscellaneous/bincoeff.m
+++ b/scripts/miscellaneous/bincoeff.m
@@ -68,17 +68,17 @@ function b = bincoeff (n, k)
     error ("bincoeff: N and K must be of common size or scalars");
   endif
 
   sz = size (n);
   b   = zeros (sz);
 
   ind = (! (k >= 0) | (k != real (round (k))) | isnan (n));
   b(ind) = NaN;
-  
+
   ind = (k == 0);
   b(ind) = 1;
 
   ind = ((k > 0) & ((n == real (round (n))) & (n < 0)));
   b(ind) = (-1) .^ k(ind) .* exp (gammaln (abs (n(ind)) + k(ind))
                                   - gammaln (k(ind) + 1)
                                   - gammaln (abs (n(ind))));
 
diff --git a/scripts/miscellaneous/bunzip2.m b/scripts/miscellaneous/bunzip2.m
--- a/scripts/miscellaneous/bunzip2.m
+++ b/scripts/miscellaneous/bunzip2.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2006-2011 Bill Denney
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
diff --git a/scripts/miscellaneous/bzip2.m b/scripts/miscellaneous/bzip2.m
--- a/scripts/miscellaneous/bzip2.m
+++ b/scripts/miscellaneous/bzip2.m
@@ -17,30 +17,30 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{entries} =} bzip2 (@var{files})
 ## @deftypefnx {Function File} {@var{entries} =} bzip2 (@var{files}, @var{outdir})
 ## Compress the list of files specified in @var{files}.
 ## Each file is compressed separately and a new file with a '.bz2' extension
-## is created.  The original files are not touched.  Existing compressed files 
-## are silently overwritten.If @var{outdir} is defined the compressed versions 
+## is created.  The original files are not touched.  Existing compressed files
+## are silently overwritten.If @var{outdir} is defined the compressed versions
 ## of the files are placed in this directory.
 ## @seealso{bunzip2, gzip, zip, tar}
 ## @end deftypefn
 
 function entries = bzip2 (varargin)
 
   if (nargin == 1 || nargin == 2)
     if nargout == 0
       __xzip__ ("bzip2", "bz2", "bzip2 %s", varargin{:});
     else
       entries = __xzip__ ("bzip2", "bz2", "bzip2 %s", varargin{:});
-    endif      
+    endif
   else
     print_usage ();
   endif
 
 endfunction
 
 %!xtest
 %!  # test for correct cleanup of temporary files
diff --git a/scripts/miscellaneous/computer.m b/scripts/miscellaneous/computer.m
--- a/scripts/miscellaneous/computer.m
+++ b/scripts/miscellaneous/computer.m
@@ -63,17 +63,17 @@ function [c, maxsize, endian] = computer
       maxsize = 2^31-1;
     endif
     if (octave_config_info ("words_big_endian"))
       endian = "B";
     elseif (octave_config_info ("words_little_endian"))
       endian = "L";
     else
       endian = "?";
-    endif      
+    endif
   endif
 
 endfunction
 
 %!assert((ischar (computer ())
 %! && computer () == octave_config_info ("canonical_host_type")));
 
 %!warning a =computer(2);
diff --git a/scripts/miscellaneous/copyfile.m b/scripts/miscellaneous/copyfile.m
--- a/scripts/miscellaneous/copyfile.m
+++ b/scripts/miscellaneous/copyfile.m
@@ -69,35 +69,35 @@ function [status, msg, msgid] = copyfile
       f1 = cellstr (f1);
     endif
 
     ## If f1 has more than 1 element f2 must be a directory
     isdir = (exist (f2, "dir") != 0);
     if (length(f1) > 1 && ! isdir)
       error ("copyfile: when copying multiple files, second argument must be a directory");
     endif
-    
+
     ## Protect the file name(s).
     f1 = glob (f1);
     if (isempty (f1))
       error ("copyfile: no files to move");
     endif
     p1 = sprintf ("\"%s\" ", f1{:});
     p2 = tilde_expand (f2);
 
     if (isdir && length(p1) > max_cmd_line)
       l2 = length(p2) + length (cmd) + 6;
       while (! isempty(f1))
         p1 = sprintf ("\"%s\" ", f1{1});
         f1(1) = [];
-        while (!isempty (f1) && (length(p1) + length(f1{1}) + l2 < 
+        while (!isempty (f1) && (length(p1) + length(f1{1}) + l2 <
                                  max_cmd_line))
           p1 = sprintf ("%s\"%s\" ", p1, f1{1});
           f1(1) = [];
-        endwhile 
+        endwhile
 
         if (ispc () && ! isunix ()
             && ! isempty (file_in_path (getenv ("PATH"), "cp.exe")))
           p1 = strrep (p1, "\\", "/");
           p2 = strrep (p2, "\\", "/");
         endif
 
         ## Copy the files.
diff --git a/scripts/miscellaneous/debug.m b/scripts/miscellaneous/debug.m
--- a/scripts/miscellaneous/debug.m
+++ b/scripts/miscellaneous/debug.m
@@ -59,17 +59,17 @@
 ## @item debug_on_error
 ## Flag whether to enter debug mode in case Octave encounters an error.
 ##
 ## @item debug_on_warning
 ## Flag whether to enter debug mode in case Octave encounters a warning.
 ##
 ## @item debug_on_interrupt
 ## Flag whether to enter debug mode in case Octave encounters an interupt.
-## 
+##
 ## @end table
 ##
 ## @noindent
 ## when Octave encounters a breakpoint or other reason to enter debug
 ## mode, the prompt changes to @code{"debug>"}.  The workspace of the function
 ## where the breakpoint was encountered becomes available and any Octave
 ## command that works within that workspace may be executed.
 ##
diff --git a/scripts/miscellaneous/edit.m b/scripts/miscellaneous/edit.m
--- a/scripts/miscellaneous/edit.m
+++ b/scripts/miscellaneous/edit.m
@@ -19,32 +19,32 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} edit @var{name}
 ## @deftypefnx {Command} {} edit @var{field} @var{value}
 ## @deftypefnx {Command} {@var{value} =} edit get @var{field}
 ## Edit the named function, or change editor settings.
 ##
 ## If @code{edit} is called with the name of a file or function as
 ## its argument it will be opened in a text editor.
-## 
+##
 ## @itemize @bullet
 ## @item
 ## If the function @var{name} is available in a file on your path and
-## that file is modifiable, then it will be edited in place.  If it 
+## that file is modifiable, then it will be edited in place.  If it
 ## is a system function, then it will first be copied to the directory
-## @env{HOME} (see further down) and then edited.  
-## If no file is found, then the m-file 
+## @env{HOME} (see further down) and then edited.
+## If no file is found, then the m-file
 ## variant, ending with ".m", will be considered.  If still no file
 ## is found, then variants with a leading "@@" and then with both a
 ## leading "@@" and trailing ".m" will be considered.
 ##
 ## @item
-## If @var{name} is the name of a function defined in the interpreter but 
+## If @var{name} is the name of a function defined in the interpreter but
 ## not in an m-file, then an m-file will be created in @env{HOME}
-## to contain that function along with its current definition.  
+## to contain that function along with its current definition.
 ##
 ## @item
 ## If @code{name.cc} is specified, then it will search for @code{name.cc}
 ## in the path and try to modify it, otherwise it will create a new
 ## @file{.cc} file in @env{HOME}.  If @var{name} happens to be an
 ## m-file or interpreter defined function, then the text of that
 ## function will be inserted into the .cc file as a comment.
 ##
@@ -58,56 +58,56 @@
 ## is available.  If you are editing a .cc file, you will need
 ## to mkoctfile @file{name.cc} before the definition will be available.
 ## @end itemize
 ##
 ## If @code{edit} is called with @var{field} and @var{value} variables,
 ## the value of the control field @var{field} will be @var{value}.
 ## If an output argument is requested and the first argument is @code{get}
 ## then @code{edit} will return the value of the control field @var{field}.
-## If the control field does not exist, edit will return a structure 
+## If the control field does not exist, edit will return a structure
 ## containing all fields and values.  Thus, @code{edit get all} returns
 ## a complete control structure.
 ## The following control fields are used:
 ##
 ## @table @samp
 ## @item editor
 ## This is the editor to use to modify the functions.  By default it uses
-## Octave's @env{EDITOR} built-in function, which comes from 
+## Octave's @env{EDITOR} built-in function, which comes from
 ## @code{getenv("EDITOR")} and defaults to @code{emacs}.  Use @code{%s}
 ## In place of the function name.  For example,
 ## @table @samp
 ## @item [EDITOR, " %s"]
 ## Use the editor which Octave uses for @code{bug_report}.
 ##
-## @item "xedit %s &"           
+## @item "xedit %s &"
 ## pop up simple X11 editor in a separate window
 ##
-## @item "gnudoit -q \"(find-file \\\"%s\\\")\""   
+## @item "gnudoit -q \"(find-file \\\"%s\\\")\""
 ## Send it to current Emacs; must have @code{(gnuserv-start)} in @file{.emacs}.
 ## @end table
 ##
 ## See also field 'mode', which controls how the editor is run by Octave.
-## 
+##
 ## On Cygwin, you will need to convert the Cygwin path to a Windows
 ## path if you are using a native Windows editor.  For example:
 ## @c Set example in small font to prevent overfull line in TeX
 ##
 ## @smallexample
 ## @exdent '"C:/Program Files/Good Editor/Editor.exe" "$(cygpath -wa %s)"'
 ## @end smallexample
 ##
 ## @item home
 ## This is the location of user local m-files.  Be be sure it is in your
 ## path.  The default is @file{~/octave}.
 ##
 ## @item author
 ## This is the name to put after the "## Author:" field of new functions.
 ## By default it guesses from the @code{gecos} field of password database.
-## 
+##
 ## @item email
 ## This is the e-mail address to list after the name in the author field.
 ## By default it guesses @code{<$LOGNAME@@$HOSTNAME>}, and if @code{$HOSTNAME}
 ## is not defined it uses @code{uname -n}.  You probably want to override this.
 ## Be sure to use @code{<user@@host>} as your format.
 ##
 ## @item license
 ## @table @samp
@@ -118,28 +118,28 @@
 ## BSD-style license without advertising clause.
 ##
 ## @item pd
 ## Public domain.
 ##
 ## @item "text"
 ## Your own default copyright and license.
 ## @end table
-## 
-## Unless you specify @samp{pd}, edit will prepend the copyright statement 
+##
+## Unless you specify @samp{pd}, edit will prepend the copyright statement
 ## with "Copyright (C) yyyy Function Author".
-## 
+##
 ## @item mode
 ## This value determines whether the editor should be started in async mode
 ## (editor is started in the background and Octave continues) or sync mode
 ## (Octave waits until the editor exits).  Set it to "async" to start the editor
 ## in async mode.  The default is "sync" (see also "system").
 ##
 ## @item editinplace
-## Determines whether files should be edited in place, without regard to 
+## Determines whether files should be edited in place, without regard to
 ## whether they are modifiable or not.  The default is @code{false}.
 ## @end table
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
@@ -230,17 +230,17 @@ function ret = edit (file, state)
   ##   edit classname/foo
   ##   edit classname/foo.m
   ##   edit @classname/foo
   ##   edit @classname/foo.m
   ##
   ## This functionality is needed for other functions as well (at least
   ## help and type; there may be more).  So the place to fix that is in
   ## file_in_loadpath, possibly with some help from the load_path class.
-  
+
   ## The code below includes a portion that serves as a place-holder for
   ## the changes suggested above.
 
   ## Create list of explicit and implicit file names.
   filelist = {file};
   ## If file has no extension, add file.m and file.cc to the list.
   idx = rindex (file, ".");
   if (idx == 0)
diff --git a/scripts/miscellaneous/getappdata.m b/scripts/miscellaneous/getappdata.m
--- a/scripts/miscellaneous/getappdata.m
+++ b/scripts/miscellaneous/getappdata.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 2010-2011 Ben Abbott
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{value} =} getappdata (@var{h}, @var{name})
 ## Returns the @var{value} for named application data for the object(s) with
 ## handle(s) @var{h}.
diff --git a/scripts/miscellaneous/getfield.m b/scripts/miscellaneous/getfield.m
--- a/scripts/miscellaneous/getfield.m
+++ b/scripts/miscellaneous/getfield.m
@@ -13,17 +13,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{v1}, @dots{}] =} getfield (@var{s}, @var{key}, @dots{}) 
+## @deftypefn {Function File} {[@var{v1}, @dots{}] =} getfield (@var{s}, @var{key}, @dots{})
 ## Extract a field from a structure (or a nested structure).  For example:
 ##
 ## @example
 ## @group
 ## ss(1,2).fd(3).b = 5;
 ## getfield (ss, @{1,2@}, "fd", @{3@}, "b")
 ##      @result{} ans = 5
 ## @end group
@@ -32,17 +32,17 @@
 ## Note that the function call in the previous example is equivalent to
 ## the expression
 ##
 ## @example
 ## @group
 ## i1 = @{1,2@}; i2 = "fd"; i3 = @{3@}; i4= "b";
 ## ss(i1@{:@}).(i2)(i3@{:@}).(i4)
 ##      @result{} ans = 5
-## 
+##
 ## @end group
 ## @end example
 ## @seealso{setfield, rmfield, isfield, isstruct, fieldnames, struct}
 ## @end deftypefn
 
 ## Author: Etienne Grossmann <etienne@cs.uky.edu>
 
 function obj = getfield (s, varargin)
diff --git a/scripts/miscellaneous/gunzip.m b/scripts/miscellaneous/gunzip.m
--- a/scripts/miscellaneous/gunzip.m
+++ b/scripts/miscellaneous/gunzip.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2006-2011 Bill Denney
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
diff --git a/scripts/miscellaneous/gzip.m b/scripts/miscellaneous/gzip.m
--- a/scripts/miscellaneous/gzip.m
+++ b/scripts/miscellaneous/gzip.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{entries} =} gzip (@var{files})
 ## @deftypefnx {Function File} {@var{entries} =} gzip (@var{files}, @var{outdir})
 ## Compress the list of files and/or directories specified in @var{files}.
 ## Each file is compressed separately and a new file with a '.gz' extension
 ## is created.  The original files are not touched.  Existing compressed
-## files are silently overwritten.  If @var{outdir} is defined the compressed 
+## files are silently overwritten.  If @var{outdir} is defined the compressed
 ## versions of the files are placed in this directory.
 ## @seealso{gunzip, bzip2, zip, tar}
 ## @end deftypefn
 
 function entries = gzip (varargin)
   if (nargin == 1 || nargin == 2) && (nargout <= 1)
     if nargout == 0
       __xzip__ ("gzip", "gz", "gzip -r %s", varargin{:});
@@ -53,17 +53,17 @@ endfunction
 %!    mkdir(dirname);
 %!    entry = gzip(filename, dirname);
 %!    [path, basename, extension] = fileparts(filename);
 %!    if ! strcmp(entry, [dirname, filesep, basename, extension, ".gz"])
 %!      error("gzipped file does not match expected name!");
 %!    endif
 %!    if ! exist(entry, "file")
 %!      error("gzipped file cannot be found!");
-%!    endif 
+%!    endif
 %!    gunzip(entry);
 %!    if (system(sprintf("diff %s %s%c%s%s", filename, dirname, filesep,
 %!                                          basename, extension)))
 %!      error("unzipped file not equal to original file!");
 %!    end
 %!  unwind_protect_cleanup
 %!    delete(filename);
 %!    delete([dirname, filesep, basename, extension]);
diff --git a/scripts/miscellaneous/isappdata.m b/scripts/miscellaneous/isappdata.m
--- a/scripts/miscellaneous/isappdata.m
+++ b/scripts/miscellaneous/isappdata.m
@@ -1,28 +1,28 @@
 ## Copyright (C) 2010-2011 Ben Abbott
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{V} =} isappdata (@var{h}, @var{name})
 ## Return true if the named application data, @var{name}, exists for the
-## object with handle @var{h}.  
+## object with handle @var{h}.
 ## @seealso{getappdata, setappdata, rmappdata}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Created: 2010-07-15
 
 function res = isappdata (h, name)
 
diff --git a/scripts/miscellaneous/ls.m b/scripts/miscellaneous/ls.m
--- a/scripts/miscellaneous/ls.m
+++ b/scripts/miscellaneous/ls.m
@@ -14,26 +14,26 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Command} {} ls options
 ## List directory contents.  For example:
-## 
+##
 ## @example
 ## @group
 ## ls -l
 ##      @print{} total 12
 ##      @print{} -rw-r--r--   1 jwe  users  4488 Aug 19 04:02 foo.m
 ##      @print{} -rw-r--r--   1 jwe  users  1315 Aug 17 23:14 bar.m
 ## @end group
 ## @end example
-## 
+##
 ## The @code{dir} and @code{ls} commands are implemented by calling your
 ## system's directory listing command, so the available options may vary
 ## from system to system.
 ## @seealso{dir, stat, readdir, glob, filesep, ls_command}
 ## @end deftypefn
 
 ## Author: jwe
 
@@ -67,17 +67,17 @@ function retval = ls (varargin)
       endif
 
     else
       ## Just let the output flow if the pager is off.  That way the
       ## output from things like "ls -R /" will show up immediately and
       ## we won't have to buffer all the output.
       system (cmd);
     endif
-    
+
   else
     error ("ls: expecting all arguments to be character strings");
   endif
 
 endfunction
 
 %!error ls (1);
 
diff --git a/scripts/miscellaneous/mkoctfile.m b/scripts/miscellaneous/mkoctfile.m
--- a/scripts/miscellaneous/mkoctfile.m
+++ b/scripts/miscellaneous/mkoctfile.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Command} {} mkoctfile [-options] file @dots{}
-## 
+##
 ## The @code{mkoctfile} function compiles source code written in C,
 ## C++, or Fortran.  Depending on the options used with @code{mkoctfile}, the
 ## compiled code can be called within Octave or can be used as a stand-alone
 ## application.
 ##
 ## @code{mkoctfile} can be called from the shell prompt or from the Octave
 ## prompt.
 ##
@@ -34,22 +34,22 @@
 ## @item -I DIR
 ## Add the include directory DIR to compile commands.
 ##
 ## @item -D DEF
 ## Add the definition DEF to the compiler call.
 ##
 ## @item -l LIB
 ## Add the library LIB to the link command.
-##          
+##
 ## @item -L DIR
 ## Add the library directory DIR to the link command.
 ##
 ## @item -M
-## @itemx --depend 
+## @itemx --depend
 ## Generate dependency files (.d) for C and C++ source files.
 ##
 ## @item -R DIR
 ## Add the run-time path to the link command.
 ##
 ## @item -Wl,@dots{}
 ## Pass flags though the linker like "-Wl,-rpath=@dots{}".
 ## The quotes are needed since commas are interpreted as command
@@ -60,53 +60,53 @@
 ##
 ## @item -c
 ## Compile but do not link.
 ##
 ## @item -g
 ## Enable debugging options for compilers.
 ##
 ## @item -o FILE
-## @itemx --output FILE  
+## @itemx --output FILE
 ## Output file name.  Default extension is .oct
 ## (or .mex if --mex is specified) unless linking
 ## a stand-alone executable.
 ##
 ## @item -p VAR
 ## @itemx --print VAR
-## Print the configuration variable VAR@.  Recognized variables are: 
+## Print the configuration variable VAR@.  Recognized variables are:
 ##
-## @example             
-##    ALL_CFLAGS                FFTW_LIBS     
-##    ALL_CXXFLAGS              FLIBS       
-##    ALL_FFLAGS                FPICFLAG      
-##    ALL_LDFLAGS               INCFLAGS      
-##    BLAS_LIBS                 LDFLAGS             
-##    CC                        LD_CXX              
+## @example
+##    ALL_CFLAGS                FFTW_LIBS
+##    ALL_CXXFLAGS              FLIBS
+##    ALL_FFLAGS                FPICFLAG
+##    ALL_LDFLAGS               INCFLAGS
+##    BLAS_LIBS                 LDFLAGS
+##    CC                        LD_CXX
 ##    CFLAGS                    LD_STATIC_FLAG
-##    CPICFLAG                  LFLAGS              
-##    CPPFLAGS                  LIBCRUFT      
-##    CXX                       LIBOCTAVE     
-##    CXXFLAGS                  LIBOCTINTERP  
-##    CXXPICFLAG                LIBREADLINE   
-##    DEPEND_EXTRA_SED_PATTERN  LIBS        
-##    DEPEND_FLAGS              OCTAVE_LIBS   
-##    DL_LD                     RDYNAMIC_FLAG 
-##    DL_LDFLAGS                RLD_FLAG      
-##    F2C                       SED         
-##    F2CFLAGS                  XTRA_CFLAGS   
-##    F77                       XTRA_CXXFLAGS 
+##    CPICFLAG                  LFLAGS
+##    CPPFLAGS                  LIBCRUFT
+##    CXX                       LIBOCTAVE
+##    CXXFLAGS                  LIBOCTINTERP
+##    CXXPICFLAG                LIBREADLINE
+##    DEPEND_EXTRA_SED_PATTERN  LIBS
+##    DEPEND_FLAGS              OCTAVE_LIBS
+##    DL_LD                     RDYNAMIC_FLAG
+##    DL_LDFLAGS                RLD_FLAG
+##    F2C                       SED
+##    F2CFLAGS                  XTRA_CFLAGS
+##    F77                       XTRA_CXXFLAGS
 ##    FFLAGS
 ## @end example
 ##
 ## @item --link-stand-alone
 ## Link a stand-alone executable file.
 ##
 ## @item --mex
-## Assume we are creating a MEX file.  Set the default output extension 
+## Assume we are creating a MEX file.  Set the default output extension
 ## to ".mex".
 ##
 ## @item -s
 ## @itemx --strip
 ## Strip the output file.
 ##
 ## @item -v
 ## @itemx --verbose
@@ -138,17 +138,17 @@ function mkoctfile (varargin)
   bindir = octave_config_info ("bindir");
 
   shell_script = fullfile (bindir, sprintf ("mkoctfile-%s", OCTAVE_VERSION));
 
   cmd = cstrcat ("\"", shell_script, "\"");
   for i = 1:nargin
     cmd = cstrcat (cmd, " \"", varargin{i}, "\"");
   endfor
-  
+
   status = system (cmd);
 
   if (status == 127)
     warning ("unable to find mkoctfile in expected location: `%s'",
              shell_script);
 
     warning ("mkoctfile exited with failure status");
   endif
diff --git a/scripts/miscellaneous/movefile.m b/scripts/miscellaneous/movefile.m
--- a/scripts/miscellaneous/movefile.m
+++ b/scripts/miscellaneous/movefile.m
@@ -62,41 +62,41 @@ function [status, msg, msgid] = movefile
     if (nargin == 3 && strcmp (force, "f"))
       cmd = cstrcat (cmd, " ", cmd_force_flag);
     endif
 
     ## If f1 isn't a cellstr convert it to one.
     if (ischar (f1))
       f1 = cellstr (f1);
     endif
-    
+
     ## If f1 has more than 1 element f2 must be a directory
     isdir = (exist (f2, "dir") != 0);
     if (length(f1) > 1 && ! isdir)
       error ("movefile: when moving multiple files, second argument must be a directory");
     endif
-    
+
     ## Protect the file name(s).
     f1 = glob (f1);
     if (isempty (f1))
       error ("movefile: no files to move");
     endif
     p1 = sprintf ("\"%s\" ", f1{:});
     p2 = tilde_expand (f2);
 
     if (isdir && length(p1) > max_cmd_line)
       l2 = length(p2) + length (cmd) + 6;
       while (! isempty(f1))
         p1 = sprintf ("\"%s\" ", f1{1});
         f1(1) = [];
-        while (!isempty (f1) && (length(p1) + length(f1{1}) + l2 < 
+        while (!isempty (f1) && (length(p1) + length(f1{1}) + l2 <
                                  max_cmd_line))
           p1 = sprintf ("%s\"%s\" ", p1, f1{1});
           f1(1) = [];
-        endwhile 
+        endwhile
 
         if (ispc () && ! isunix ()
             && ! isempty (file_in_path (getenv ("PATH"), "cp.exe")))
           p1 = strrep (p1, "\\", "/");
           p2 = strrep (p2, "\\", "/");
         endif
 
         ## Move the file(s).
diff --git a/scripts/miscellaneous/namelengthmax.m b/scripts/miscellaneous/namelengthmax.m
--- a/scripts/miscellaneous/namelengthmax.m
+++ b/scripts/miscellaneous/namelengthmax.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} namelengthmax ()
 ## Returns the @sc{matlab} compatible maximum variable name length.  Octave is
-## capable of storing strings up to 
+## capable of storing strings up to
 ## @tex
 ## $2^{31} - 1$
 ## @end tex
 ## @ifnottex
 ## @code{2 ^ 31 - 1}
 ## @end ifnottex
 ## in length.  However for @sc{matlab} compatibility all variable, function
 ## and structure field names should be shorter than the length supplied by
diff --git a/scripts/miscellaneous/orderfields.m b/scripts/miscellaneous/orderfields.m
--- a/scripts/miscellaneous/orderfields.m
+++ b/scripts/miscellaneous/orderfields.m
@@ -34,17 +34,17 @@
 ## which converts the original name order into the new name order.
 ##
 ## Examples:
 ##
 ## @example
 ## @group
 ## s = struct("d", 4, "b", 2, "a", 1, "c", 3);
 ## t1 = orderfields(s)
-##      @result{} t1 = 
+##      @result{} t1 =
 ##         @{
 ##           a =  1
 ##           b =  2
 ##           c =  3
 ##           d =  4
 ##         @}
 ## @end group
 ## @group
diff --git a/scripts/miscellaneous/private/__xzip__.m b/scripts/miscellaneous/private/__xzip__.m
--- a/scripts/miscellaneous/private/__xzip__.m
+++ b/scripts/miscellaneous/private/__xzip__.m
@@ -17,32 +17,32 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{entries} =} __xzip__ (@var{commandname}, @var{extension}, @var{commandtemplate}, @var{files}, @var{outdir})
 ## Undocumented internal function.
 ## @end deftypefn
 
-## Compress the list of files and/or directories specified in @var{files} 
-## with the external compression command @var{commandname}. The template 
+## Compress the list of files and/or directories specified in @var{files}
+## with the external compression command @var{commandname}. The template
 ## @var{commandtemplate} is used to actually start the command. Each file
-## is compressed separately and a new file with the extension @var{extension} 
-## is created and placed into the directory @var{outdir}. The original files 
-## are not touched. Existing compressed files are silently overwritten. 
+## is compressed separately and a new file with the extension @var{extension}
+## is created and placed into the directory @var{outdir}. The original files
+## are not touched. Existing compressed files are silently overwritten.
 ## This is an internal function. Do not use directly.
 
-function entries = __xzip__ (commandname, extension, 
+function entries = __xzip__ (commandname, extension,
                              commandtemplate, files, outdir)
 
   if (nargin == 4 || nargin == 5)
     if (! ischar (extension) || length (extension) == 0)
       error ("__xzip__: EXTENSION has to be a string with finite length");
     endif
-    
+
     if (nargin == 5 && ! exist (outdir, "dir"))
       error ("__xzip__: output directory does not exist");
     endif
 
     if (ischar (files))
       files = cellstr (files);
     else
       error ("__xzip__: expecting FILES to be a character array");
@@ -53,41 +53,41 @@ function entries = __xzip__ (commandname
       mkdir (outdir);
     endif
 
     cwd = pwd();
     unwind_protect
       files = glob (files);
 
       ## Ignore any file with the compress extension
-      files (cellfun (@(x) length(x) > length(extension) 
-        && strcmp (x((end - length(extension) + 1):end), extension), 
+      files (cellfun (@(x) length(x) > length(extension)
+        && strcmp (x((end - length(extension) + 1):end), extension),
         files)) = [];
 
       copyfile (files, outdir);
 
       [d, f] = myfileparts(files);
 
       cd (outdir);
 
       cmd = sprintf (commandtemplate, sprintf (" %s", f{:}));
 
       [status, output] = system (cmd);
       if (status == 0)
 
         if (nargin == 5)
           compressed_files = cellfun(
-              @(x) fullfile (outdir, sprintf ("%s.%s", x, extension)), 
+              @(x) fullfile (outdir, sprintf ("%s.%s", x, extension)),
               f, "uniformoutput", false);
         else
-          movefile (cellfun(@(x) sprintf ("%s.%s", x, extension), f, 
+          movefile (cellfun(@(x) sprintf ("%s.%s", x, extension), f,
                             "uniformoutput", false), cwd);
           ## FIXME this does not work when you try to compress directories
 
-          compressed_files  = cellfun(@(x) sprintf ("%s.%s", x, extension), 
+          compressed_files  = cellfun(@(x) sprintf ("%s.%s", x, extension),
                                       files, "uniformoutput", false);
         endif
 
         if (nargout > 0)
           entries = compressed_files;
         endif
       else
         error ("__xzip__: %s command failed with exit status = %d",
@@ -109,35 +109,35 @@ function entries = __xzip__ (commandname
     print_usage ();
   endif
 
 endfunction
 
 function [d, f] = myfileparts (files)
   [d, f, ext] = cellfun (@(x) fileparts (x), files, "uniformoutput", false);
   f = cellfun (@(x, y) sprintf ("%s%s", x, y), f, ext,
-               "uniformoutput", false); 
+               "uniformoutput", false);
   idx = cellfun (@isdir, files);
   d(idx) = "";
   f(idx) = files(idx);
 endfunction
 
 ## FIXME -- reinstate these tests if we invent a way to test private
 ## functions directly.
 ##
-## %!error <extension has to be a string with finite length> 
+## %!error <extension has to be a string with finite length>
 ## %!  __xzip__("gzip", "", "gzip -r %s", "bla");
 ## %!error <no files to move>
 ## %!  __xzip__("gzip", ".gz", "gzip -r %s", tmpnam);
 ## %!error <command failed with exit status>
 ## %!  # test __xzip__ with invalid compression command
 ## %!  unwind_protect
 ## %!    filename = tmpnam;
 ## %!    dummy    = 1;
 ## %!    save(filename, "dummy");
 ## %!    dirname  = tmpnam;
 ## %!    mkdir(dirname);
-## %!    entry = __xzip__("gzip", ".gz", "xxxzipxxx -r %s 2>/dev/null", 
+## %!    entry = __xzip__("gzip", ".gz", "xxxzipxxx -r %s 2>/dev/null",
 ## %!                     filename, dirname);
 ## %!  unwind_protect_cleanup
 ## %!    delete(filename);
 ## %!    rmdir(dirname);
 ## %!  end_unwind_protect
diff --git a/scripts/miscellaneous/rmappdata.m b/scripts/miscellaneous/rmappdata.m
--- a/scripts/miscellaneous/rmappdata.m
+++ b/scripts/miscellaneous/rmappdata.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 2010-2011 Ben Abbott
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} rmappdata (@var{h}, @var{name})
 ## Deletes the named application data for the object(s) with
 ## handle(s) @var{h}.
diff --git a/scripts/miscellaneous/setappdata.m b/scripts/miscellaneous/setappdata.m
--- a/scripts/miscellaneous/setappdata.m
+++ b/scripts/miscellaneous/setappdata.m
@@ -1,20 +1,20 @@
 ## Copyright (C) 2010-2011 Ben Abbott
-## 
+##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 2 of the License, or
 ## (at your option) any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} setappdata (@var{h}, @var{name}, @var{value})
 ## Sets the named application data to @var{value} for the object(s) with
 ## handle(s) @var{h}.  If the application data with the specified name does
diff --git a/scripts/miscellaneous/substruct.m b/scripts/miscellaneous/substruct.m
--- a/scripts/miscellaneous/substruct.m
+++ b/scripts/miscellaneous/substruct.m
@@ -32,17 +32,17 @@
 ##          subs =
 ##          @{
 ##            [1,1] =  3
 ##            [1,2] = :
 ##          @}
 ##        @}
 ## x = [1, 2, 3; 4, 5, 6; 7, 8, 9];
 ## subsref(x, idx)
-##      @result{} ans = 
+##      @result{} ans =
 ##         7  8  9
 ## @end group
 ## @end example
 ## @seealso{subsref, subsasgn}
 ## @end deftypefn
 
 ## Author:  jwe
 
diff --git a/scripts/miscellaneous/swapbytes.m b/scripts/miscellaneous/swapbytes.m
--- a/scripts/miscellaneous/swapbytes.m
+++ b/scripts/miscellaneous/swapbytes.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} swapbytes (@var{x})
-## Swaps the byte order on values, converting from little endian to big 
+## Swaps the byte order on values, converting from little endian to big
 ## endian and vice versa.  For example:
 ##
 ## @example
 ## @group
 ## swapbytes (uint16 (1:4))
 ## @result{} [   256   512   768  1024]
 ## @end group
 ## @end example
diff --git a/scripts/miscellaneous/tar.m b/scripts/miscellaneous/tar.m
--- a/scripts/miscellaneous/tar.m
+++ b/scripts/miscellaneous/tar.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2005-2011 Sren Hauberg
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -57,17 +57,17 @@ function entries = tar (tarfile, files, 
             output(end) = [];
           endif
           entries = strsplit (output, "\n");
           entries = entries';
         endif
       else
         error ("tar: tar exited with status = %d", status);
       endif
-    
+
     else
       error ("tar: expecting all arguments to be character strings");
     endif
 
   else
     print_usage("tar");
   endif
 
diff --git a/scripts/miscellaneous/unimplemented.m b/scripts/miscellaneous/unimplemented.m
--- a/scripts/miscellaneous/unimplemented.m
+++ b/scripts/miscellaneous/unimplemented.m
@@ -28,30 +28,30 @@ function txt = unimplemented (fcn)
 
   ## Some smarter cases, add more as needed.
   switch (fcn)
 
   case "quad2d"
     txt = ["quad2d is not implemented.  Consider using dblquad."];
 
   case "gsvd"
-    txt = ["gsvd is not currently part of Octave.  See the linear-algebra",... 
+    txt = ["gsvd is not currently part of Octave.  See the linear-algebra",...
     "package at @url{http://octave.sf.net/linear-algebra/}."];
 
   case "linprog"
     txt = ["Octave does not currently provide linprog.  ",...
     "Linear programming problems may be solved using @code{glpk}.  ",...
     "Try @code{help glpk} for more info."];
 
   case {"ode113", "ode15i", "ode15s", "ode23", "ode23s", "ode23t", "ode45", "odeget", "odeset"}
     txt = ["Octave provides lsode for solving differential equations.  ",...
     "For more information try @code{help lsode}.  ",...
     "Matlab-compatible ODE functions are provided by the odepkg package.  ",...
     "See @url{http://octave.sf.net/odepkg/}."];
-  
+
   otherwise
     if (ismember (fcn, missing_functions ()))
       txt = sprintf ("the `%s' function is not yet implemented in Octave", fcn);
     else
       is_matlab_function = false;
       txt = "";
     endif
   endswitch
@@ -66,366 +66,366 @@ function txt = unimplemented (fcn)
   if (nargout == 0)
     warning ("Octave:missing-function", "%s", txt);
   endif
 
 endfunction
 
 function list = missing_functions ()
   persistent list = {
-  "DelaunayTri", 
-  "MException", 
-  "RandStream", 
-  "TriRep", 
-  "TriScatteredInterp", 
-  "addpref", 
-  "align", 
-  "alim", 
-  "alpha", 
-  "alphamap", 
-  "annotation", 
-  "audiodevinfo", 
-  "audioplayer", 
-  "audiorecorder", 
-  "aufinfo", 
-  "auread", 
-  "auwrite", 
-  "avifile", 
-  "aviinfo", 
-  "aviread", 
-  "bar3", 
-  "bar3h", 
-  "bench", 
-  "betaincinv", 
-  "bicg", 
-  "bicgstabl", 
-  "brush", 
-  "builddocsearchdb", 
-  "bvp4c", 
-  "bvp5c", 
-  "bvpget", 
-  "bvpinit", 
-  "bvpset", 
-  "bvpxtend", 
-  "callSoapService", 
-  "calllib", 
-  "camdolly", 
-  "cameratoolbar", 
-  "camlight", 
-  "camlookat", 
-  "camorbit", 
-  "campan", 
-  "campos", 
-  "camproj", 
-  "camroll", 
-  "camtarget", 
-  "camup", 
-  "camva", 
-  "camzoom", 
-  "cdf2rdf", 
-  "cdfepoch", 
-  "cdfinfo", 
-  "cdfread", 
-  "cdfwrite", 
-  "cellplot", 
-  "checkin", 
-  "checkout", 
-  "cholinc", 
-  "clearvars", 
-  "clipboard", 
-  "cmopts", 
-  "cmpermute", 
-  "cmunique", 
-  "colordef", 
-  "colormapeditor", 
-  "commandhistory", 
-  "commandwindow", 
-  "condeig", 
-  "coneplot", 
-  "contourslice", 
-  "copyobj", 
-  "createClassFromWsdl", 
-  "createSoapMessage", 
-  "customverctrl", 
-  "daqread", 
-  "datacursormode", 
-  "datatipinfo", 
-  "dbmex", 
-  "dde23", 
-  "ddeget", 
-  "ddesd", 
-  "ddeset", 
-  "decic", 
-  "depdir", 
-  "depfun", 
-  "deval", 
-  "dialog", 
-  "dither", 
-  "docopt", 
-  "docsearch", 
-  "dragrect", 
-  "dynamicprops", 
-  "echodemo", 
-  "ellipj", 
-  "ellipke", 
-  "erfcinv", 
-  "errordlg", 
-  "evalc", 
-  "exifread", 
-  "expint", 
-  "export2wsdlg", 
-  "figurepalette", 
-  "filebrowser", 
-  "fill3", 
-  "findfigs", 
-  "fitsinfo", 
-  "fitsread", 
-  "flow", 
-  "fminsearch", 
-  "frame2im", 
-  "freqspace", 
-  "funm", 
-  "gallery", 
-  "gammaincinv", 
-  "gco", 
-  "getframe", 
-  "getpixelposition", 
-  "getpref", 
-  "gmres", 
-  "grabcode", 
-  "graymon", 
-  "gsvd", 
-  "guidata", 
-  "guide", 
-  "guihandles", 
-  "handle", 
-  "hdf", 
-  "hdf5", 
-  "hdf5info", 
-  "hdf5read", 
-  "hdf5write", 
-  "hdfinfo", 
-  "hdfread", 
-  "hdftool", 
-  "helpbrowser", 
-  "helpdesk", 
-  "helpdlg", 
-  "helpwin", 
-  "hgexport", 
-  "hgload", 
-  "hgsave", 
-  "hgsetget", 
-  "hgtransform", 
-  "hostid", 
-  "ilu", 
-  "im2frame", 
-  "im2java", 
-  "imapprox", 
-  "imformats", 
-  "import", 
-  "importdata", 
-  "inmem", 
-  "inputParser", 
-  "inputdlg", 
-  "inspect", 
-  "instrfind", 
-  "instrfindall", 
-  "interpstreamspeed", 
-  "iscom", 
-  "isinterface", 
-  "isjava", 
-  "isocaps", 
-  "ispref", 
-  "isstudent", 
-  "javaArray", 
-  "javaMethod", 
-  "javaMethodEDT", 
-  "javaObject", 
-  "javaObjectEDT", 
-  "javaaddpath", 
-  "javachk", 
-  "javaclasspath", 
-  "javarmpath", 
-  "ldl", 
-  "libfunctions", 
-  "libfunctionsview", 
-  "libisloaded", 
-  "libpointer", 
-  "libstruct", 
-  "light", 
-  "lightangle", 
-  "lighting", 
-  "linkaxes", 
-  "linkdata", 
-  "linsolve", 
-  "listdlg", 
-  "listfonts", 
-  "loadlibrary", 
-  "lscov", 
-  "lsqr", 
-  "makehgtform", 
-  "material", 
-  "matlabrc", 
-  "maxNumCompThreads", 
-  "memmapfile", 
-  "memory", 
-  "metaclass", 
-  "methodsview", 
-  "minres", 
-  "mlint", 
-  "mlintrpt", 
-  "mmfileinfo", 
-  "mmreader", 
-  "movegui", 
-  "movie", 
-  "movie2avi", 
-  "msgbox", 
-  "multibandread", 
-  "multibandwrite", 
-  "native2unicode", 
-  "noanimate", 
-  "ode113", 
-  "ode15i", 
-  "ode15s", 
-  "ode23", 
-  "ode23s", 
-  "ode23t", 
-  "ode23tb", 
-  "ode45", 
-  "odefile", 
-  "odeget", 
-  "odeset", 
-  "odextend", 
-  "open", 
-  "openfig", 
-  "opengl", 
-  "openvar", 
-  "ordeig", 
-  "ordqz", 
-  "ordschur", 
-  "padecoef", 
-  "pagesetupdlg", 
-  "pan", 
-  "parseSoapResponse", 
-  "path2rc", 
-  "pathtool", 
-  "pcode", 
-  "pdepe", 
-  "pdeval", 
-  "playshow", 
-  "plotbrowser", 
-  "plotedit", 
-  "plottools", 
-  "polyeig", 
-  "prefdir", 
-  "preferences", 
-  "printdlg", 
-  "printopt", 
-  "printpreview", 
-  "profile", 
-  "profsave", 
-  "propedit", 
-  "propertyeditor", 
-  "publish", 
-  "qmr", 
-  "quad2d", 
-  "questdlg", 
-  "rbbox", 
-  "rectangle", 
-  "recycle", 
-  "reducepatch", 
-  "reducevolume", 
-  "resample", 
-  "reset", 
-  "rgbplot", 
-  "rmpref", 
-  "root", 
-  "rotate", 
-  "rotate3d", 
-  "rsf2csf", 
-  "selectmoveresize", 
-  "sendmail", 
-  "serial", 
-  "setpixelposition", 
-  "setpref", 
-  "showplottool", 
-  "shrinkfaces", 
-  "smooth3", 
-  "snapnow", 
-  "sound", 
-  "soundsc", 
-  "ss2tf", 
-  "stream2", 
-  "stream3", 
-  "streamline", 
-  "streamparticles", 
-  "streamribbon", 
-  "streamslice", 
-  "streamtube", 
-  "strings", 
-  "subvolume", 
-  "superclasses", 
-  "support", 
-  "surf2patch", 
-  "symmlq", 
-  "syntax", 
-  "tetramesh", 
-  "texlabel", 
-  "textwrap", 
-  "tfqmr", 
-  "timer", 
-  "timerfind", 
-  "timerfindall", 
-  "timeseries", 
-  "toolboxdir", 
-  "tscollection", 
-  "tstool", 
-  "uibuttongroup", 
-  "uicontextmenu", 
-  "uicontrol",  
-  "uigetpref", 
-  "uiimport", 
-  "uiopen", 
-  "uipanel", 
-  "uipushtool", 
-  "uiresume", 
-  "uisave", 
-  "uisetcolor", 
-  "uisetfont", 
-  "uisetpref", 
-  "uistack", 
-  "uitable", 
-  "uitoggletool", 
-  "uitoolbar", 
-  "uiwait", 
-  "undocheckout", 
-  "unicode2native", 
-  "unloadlibrary", 
-  "unmesh", 
-  "usejava", 
-  "userpath", 
-  "validateattributes", 
-  "verLessThan", 
-  "viewmtx", 
-  "visdiff", 
-  "volumebounds", 
-  "waitbar", 
-  "waitfor", 
-  "warndlg", 
-  "waterfall", 
-  "wavfinfo", 
-  "wavplay", 
-  "wavrecord", 
-  "web", 
-  "whatsnew", 
-  "wk1finfo", 
-  "wk1read", 
-  "wk1write", 
-  "workspace", 
-  "xlsfinfo", 
-  "xlsread", 
-  "xlswrite", 
-  "xmlread", 
-  "xmlwrite", 
-  "xslt", 
+  "DelaunayTri",
+  "MException",
+  "RandStream",
+  "TriRep",
+  "TriScatteredInterp",
+  "addpref",
+  "align",
+  "alim",
+  "alpha",
+  "alphamap",
+  "annotation",
+  "audiodevinfo",
+  "audioplayer",
+  "audiorecorder",
+  "aufinfo",
+  "auread",
+  "auwrite",
+  "avifile",
+  "aviinfo",
+  "aviread",
+  "bar3",
+  "bar3h",
+  "bench",
+  "betaincinv",
+  "bicg",
+  "bicgstabl",
+  "brush",
+  "builddocsearchdb",
+  "bvp4c",
+  "bvp5c",
+  "bvpget",
+  "bvpinit",
+  "bvpset",
+  "bvpxtend",
+  "callSoapService",
+  "calllib",
+  "camdolly",
+  "cameratoolbar",
+  "camlight",
+  "camlookat",
+  "camorbit",
+  "campan",
+  "campos",
+  "camproj",
+  "camroll",
+  "camtarget",
+  "camup",
+  "camva",
+  "camzoom",
+  "cdf2rdf",
+  "cdfepoch",
+  "cdfinfo",
+  "cdfread",
+  "cdfwrite",
+  "cellplot",
+  "checkin",
+  "checkout",
+  "cholinc",
+  "clearvars",
+  "clipboard",
+  "cmopts",
+  "cmpermute",
+  "cmunique",
+  "colordef",
+  "colormapeditor",
+  "commandhistory",
+  "commandwindow",
+  "condeig",
+  "coneplot",
+  "contourslice",
+  "copyobj",
+  "createClassFromWsdl",
+  "createSoapMessage",
+  "customverctrl",
+  "daqread",
+  "datacursormode",
+  "datatipinfo",
+  "dbmex",
+  "dde23",
+  "ddeget",
+  "ddesd",
+  "ddeset",
+  "decic",
+  "depdir",
+  "depfun",
+  "deval",
+  "dialog",
+  "dither",
+  "docopt",
+  "docsearch",
+  "dragrect",
+  "dynamicprops",
+  "echodemo",
+  "ellipj",
+  "ellipke",
+  "erfcinv",
+  "errordlg",
+  "evalc",
+  "exifread",
+  "expint",
+  "export2wsdlg",
+  "figurepalette",
+  "filebrowser",
+  "fill3",
+  "findfigs",
+  "fitsinfo",
+  "fitsread",
+  "flow",
+  "fminsearch",
+  "frame2im",
+  "freqspace",
+  "funm",
+  "gallery",
+  "gammaincinv",
+  "gco",
+  "getframe",
+  "getpixelposition",
+  "getpref",
+  "gmres",
+  "grabcode",
+  "graymon",
+  "gsvd",
+  "guidata",
+  "guide",
+  "guihandles",
+  "handle",
+  "hdf",
+  "hdf5",
+  "hdf5info",
+  "hdf5read",
+  "hdf5write",
+  "hdfinfo",
+  "hdfread",
+  "hdftool",
+  "helpbrowser",
+  "helpdesk",
+  "helpdlg",
+  "helpwin",
+  "hgexport",
+  "hgload",
+  "hgsave",
+  "hgsetget",
+  "hgtransform",
+  "hostid",
+  "ilu",
+  "im2frame",
+  "im2java",
+  "imapprox",
+  "imformats",
+  "import",
+  "importdata",
+  "inmem",
+  "inputParser",
+  "inputdlg",
+  "inspect",
+  "instrfind",
+  "instrfindall",
+  "interpstreamspeed",
+  "iscom",
+  "isinterface",
+  "isjava",
+  "isocaps",
+  "ispref",
+  "isstudent",
+  "javaArray",
+  "javaMethod",
+  "javaMethodEDT",
+  "javaObject",
+  "javaObjectEDT",
+  "javaaddpath",
+  "javachk",
+  "javaclasspath",
+  "javarmpath",
+  "ldl",
+  "libfunctions",
+  "libfunctionsview",
+  "libisloaded",
+  "libpointer",
+  "libstruct",
+  "light",
+  "lightangle",
+  "lighting",
+  "linkaxes",
+  "linkdata",
+  "linsolve",
+  "listdlg",
+  "listfonts",
+  "loadlibrary",
+  "lscov",
+  "lsqr",
+  "makehgtform",
+  "material",
+  "matlabrc",
+  "maxNumCompThreads",
+  "memmapfile",
+  "memory",
+  "metaclass",
+  "methodsview",
+  "minres",
+  "mlint",
+  "mlintrpt",
+  "mmfileinfo",
+  "mmreader",
+  "movegui",
+  "movie",
+  "movie2avi",
+  "msgbox",
+  "multibandread",
+  "multibandwrite",
+  "native2unicode",
+  "noanimate",
+  "ode113",
+  "ode15i",
+  "ode15s",
+  "ode23",
+  "ode23s",
+  "ode23t",
+  "ode23tb",
+  "ode45",
+  "odefile",
+  "odeget",
+  "odeset",
+  "odextend",
+  "open",
+  "openfig",
+  "opengl",
+  "openvar",
+  "ordeig",
+  "ordqz",
+  "ordschur",
+  "padecoef",
+  "pagesetupdlg",
+  "pan",
+  "parseSoapResponse",
+  "path2rc",
+  "pathtool",
+  "pcode",
+  "pdepe",
+  "pdeval",
+  "playshow",
+  "plotbrowser",
+  "plotedit",
+  "plottools",
+  "polyeig",
+  "prefdir",
+  "preferences",
+  "printdlg",
+  "printopt",
+  "printpreview",
+  "profile",
+  "profsave",
+  "propedit",
+  "propertyeditor",
+  "publish",
+  "qmr",
+  "quad2d",
+  "questdlg",
+  "rbbox",
+  "rectangle",
+  "recycle",
+  "reducepatch",
+  "reducevolume",
+  "resample",
+  "reset",
+  "rgbplot",
+  "rmpref",
+  "root",
+  "rotate",
+  "rotate3d",
+  "rsf2csf",
+  "selectmoveresize",
+  "sendmail",
+  "serial",
+  "setpixelposition",
+  "setpref",
+  "showplottool",
+  "shrinkfaces",
+  "smooth3",
+  "snapnow",
+  "sound",
+  "soundsc",
+  "ss2tf",
+  "stream2",
+  "stream3",
+  "streamline",
+  "streamparticles",
+  "streamribbon",
+  "streamslice",
+  "streamtube",
+  "strings",
+  "subvolume",
+  "superclasses",
+  "support",
+  "surf2patch",
+  "symmlq",
+  "syntax",
+  "tetramesh",
+  "texlabel",
+  "textwrap",
+  "tfqmr",
+  "timer",
+  "timerfind",
+  "timerfindall",
+  "timeseries",
+  "toolboxdir",
+  "tscollection",
+  "tstool",
+  "uibuttongroup",
+  "uicontextmenu",
+  "uicontrol",
+  "uigetpref",
+  "uiimport",
+  "uiopen",
+  "uipanel",
+  "uipushtool",
+  "uiresume",
+  "uisave",
+  "uisetcolor",
+  "uisetfont",
+  "uisetpref",
+  "uistack",
+  "uitable",
+  "uitoggletool",
+  "uitoolbar",
+  "uiwait",
+  "undocheckout",
+  "unicode2native",
+  "unloadlibrary",
+  "unmesh",
+  "usejava",
+  "userpath",
+  "validateattributes",
+  "verLessThan",
+  "viewmtx",
+  "visdiff",
+  "volumebounds",
+  "waitbar",
+  "waitfor",
+  "warndlg",
+  "waterfall",
+  "wavfinfo",
+  "wavplay",
+  "wavrecord",
+  "web",
+  "whatsnew",
+  "wk1finfo",
+  "wk1read",
+  "wk1write",
+  "workspace",
+  "xlsfinfo",
+  "xlsread",
+  "xlswrite",
+  "xmlread",
+  "xmlwrite",
+  "xslt",
   "zoom",
   };
 endfunction
diff --git a/scripts/miscellaneous/unpack.m b/scripts/miscellaneous/unpack.m
--- a/scripts/miscellaneous/unpack.m
+++ b/scripts/miscellaneous/unpack.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2006-2011 Bill Denney
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -135,17 +135,17 @@ function filelist = unpack (file, dir = 
     commandlist.tbz2 = commandlist.tarbz2;
     commandlist.tbz = commandlist.tarbz2;
     commandlist.zip = {"unzip \"%s\"", ...
                        "unzip -q \"%s\"", ...
                        @__parse_zip__, false};
   endif
 
   nodotext = ext(! ismember (ext, "."));
-  
+
   origdir = pwd ();
 
   if (isfield (commandlist, nodotext))
     [commandv, commandq, parser, move] = deal (commandlist.(nodotext){:});
     cstartdir = canonicalize_file_name (origdir);
     cenddir = canonicalize_file_name (dir);
     needmove = move && ! strcmp (cstartdir, cenddir);
     if (nargout > 0 || needmove)
diff --git a/scripts/miscellaneous/untar.m b/scripts/miscellaneous/untar.m
--- a/scripts/miscellaneous/untar.m
+++ b/scripts/miscellaneous/untar.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2005-2011 Sren Hauberg
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
diff --git a/scripts/miscellaneous/unzip.m b/scripts/miscellaneous/unzip.m
--- a/scripts/miscellaneous/unzip.m
+++ b/scripts/miscellaneous/unzip.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2005-2011 Sren Hauberg
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
diff --git a/scripts/miscellaneous/ver.m b/scripts/miscellaneous/ver.m
--- a/scripts/miscellaneous/ver.m
+++ b/scripts/miscellaneous/ver.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ver ()
 ## Display a header containing the current Octave version
-## number, license string and operating system, followed by 
+## number, license string and operating system, followed by
 ## the installed package names, versions, and installation
 ## directories.
 ## @deftypefnx {Function File} {v =} ver ()
 ## Return a vector of structures, respecting Octave and each installed package.
 ## The structure includes the following fields.
 ##
 ## @table @code
 ##   @item Name
diff --git a/scripts/miscellaneous/warning_ids.m b/scripts/miscellaneous/warning_ids.m
--- a/scripts/miscellaneous/warning_ids.m
+++ b/scripts/miscellaneous/warning_ids.m
@@ -18,237 +18,237 @@
 
 ## -*- texinfo -*-
 ## @table @code
 ## @item Octave:array-to-scalar
 ## If the @code{Octave:array-to-scalar} warning is enabled, Octave will
 ## warn when an implicit conversion from an array to a scalar value is
 ## attempted.  By default, the @code{Octave:array-to-scalar} warning is
 ## disabled.
-## 
+##
 ## @item Octave:array-to-vector
 ## If the @code{Octave:array-to-vector} warning is enabled, Octave will
 ## warn when an implicit conversion from an array to a vector value is
 ## attempted.  By default, the @code{Octave:array-to-vector} warning is
 ## disabled.
-## 
+##
 ## @item Octave:assign-as-truth-value
 ## If the @code{Octave:assign-as-truth-value} warning is
 ## enabled, a warning is issued for statements like
-## 
+##
 ## @example
 ## @group
 ## if (s = t)
 ##   @dots{}
 ## @end group
 ## @end example
-## 
+##
 ## @noindent
 ## since such statements are not common, and it is likely that the intent
 ## was to write
-## 
+##
 ## @example
 ## @group
 ## if (s == t)
 ##   @dots{}
 ## @end group
 ## @end example
-## 
+##
 ## @noindent
 ## instead.
-## 
+##
 ## There are times when it is useful to write code that contains
 ## assignments within the condition of a @code{while} or @code{if}
 ## statement.  For example, statements like
-## 
+##
 ## @example
 ## @group
 ## while (c = getc())
 ##   @dots{}
 ## @end group
 ## @end example
-## 
+##
 ## @noindent
 ## are common in C programming.
-## 
+##
 ## It is possible to avoid all warnings about such statements by
 ## disabling the @code{Octave:assign-as-truth-value} warning,
 ## but that may also let real errors like
-## 
+##
 ## @example
 ## @group
 ## if (x = 1)  # intended to test (x == 1)!
 ##   @dots{}
 ## @end group
 ## @end example
-## 
+##
 ## @noindent
 ## slip by.
-## 
+##
 ## In such cases, it is possible suppress errors for specific statements by
 ## writing them with an extra set of parentheses.  For example, writing the
 ## previous example as
-## 
+##
 ## @example
 ## @group
 ## while ((c = getc()))
 ##   @dots{}
 ## @end group
 ## @end example
-## 
+##
 ## @noindent
 ## will prevent the warning from being printed for this statement, while
 ## allowing Octave to warn about other assignments used in conditional
 ## contexts.
-## 
+##
 ## By default, the @code{Octave:assign-as-truth-value} warning is enabled.
-## 
+##
 ## @item Octave:associativity-change
 ## If the @code{Octave:associativity-change} warning is
 ## enabled, Octave will warn about possible changes in the meaning of
 ## some code due to changes in associativity for some operators.
 ## Associativity changes have typically been made for @sc{matlab}
 ## compatibility.  By default, the @code{Octave:associativity-change}
 ## warning is enabled.
-## 
+##
 ## @item Octave:divide-by-zero
 ## If the @code{Octave:divide-by-zero} warning is enabled, a
 ## warning is issued when Octave encounters a division by zero.  By
 ## default, the @code{Octave:divide-by-zero} warning is enabled.
-## 
+##
 ## @item Octave:empty-list-elements
 ## If the @code{Octave:empty-list-elements} warning is enabled, a
 ## warning is issued when an empty matrix is found in a matrix list.
 ## For example:
-## 
+##
 ## @example
 ## a = [1, [], 3, [], 5]
 ## @end example
-## 
+##
 ## @noindent
 ## By default, the @code{Octave:empty-list-elements} warning is enabled.
-## 
+##
 ## @item Octave:fortran-indexing
 ## If the @code{Octave:fortran-indexing} warning is enabled, a warning is
 ## printed for expressions which select elements of a two-dimensional matrix
 ## using a single index.  By default, the @code{Octave:fortran-indexing}
 ## warning is disabled.
-## 
+##
 ## @item Octave:function-name-clash
 ## If the @code{Octave:function-name-clash} warning is enabled, a
 ## warning is issued when Octave finds that the name of a function
 ## defined in a function file differs from the name of the file.  (If
 ## the names disagree, the name declared inside the file is ignored.)
 ## By default, the @code{Octave:function-name-clash} warning is enabled.
-## 
+##
 ## @item Octave:future-time-stamp
 ## If the @code{Octave:future-time-stamp} warning is enabled, Octave
 ## will print a warning if it finds a function file with a time stamp
 ## that is in the future.  By default, the
 ## @code{Octave:future-time-stamp} warning is enabled.
-## 
+##
 ## @item Octave:imag-to-real
 ## If the @code{Octave:imag-to-real} warning is enabled, a warning is
 ## printed for implicit conversions of complex numbers to real numbers.
 ## By default, the @code{Octave:imag-to-real} warning is disabled.
-## 
+##
 ## @item Octave:matlab-incompatible
 ## Print warnings for Octave language features that may cause
 ## compatibility problems with @sc{matlab}.
-## 
+##
 ## @item Octave:missing-semicolon
 ## If the @code{Octave:missing-semicolon} warning is enabled, Octave
 ## will warn when statements in function definitions don't end in
 ## semicolons.  By default the @code{Octave:missing-semicolon} warning
 ## is disabled.
-## 
+##
 ## @item Octave:neg-dim-as-zero
 ## If the @code{Octave:neg-dim-as-zero} warning is enabled, print a warning
 ## for expressions like
-## 
+##
 ## @example
 ## eye (-1)
 ## @end example
-## 
+##
 ## @noindent
 ## By default, the @code{Octave:neg-dim-as-zero} warning is disabled.
-## 
+##
 ## @item Octave:num-to-str
 ## If the @code{Octave:num-to-str} warning is enable, a warning is
 ## printed for implicit conversions of numbers to their ASCII character
 ## equivalents when strings are constructed using a mixture of strings and
 ## numbers in matrix notation.  For example,
-## 
+##
 ## @example
 ## @group
 ## [ "f", 111, 111 ]
 ##      @result{} "foo"
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## elicits a warning if the @code{Octave:num-to-str} warning is
 ## enabled.  By default, the @code{Octave:num-to-str} warning is enabled.
-## 
+##
 ## @item Octave:precedence-change
 ## If the @code{Octave:precedence-change} warning is enabled, Octave
 ## will warn about possible changes in the meaning of some code due to
 ## changes in precedence for some operators.  Precedence changes have
 ## typically been made for @sc{matlab} compatibility.  By default, the
 ## @code{Octave:precedence-change} warning is enabled.
-## 
+##
 ## @item Octave:reload-forces-clear
 ## If several functions have been loaded from the same file, Octave must
 ## clear all the functions before any one of them can be reloaded.  If
 ## the @code{Octave:reload-forces-clear} warning is enabled, Octave will
 ## warn you when this happens, and print a list of the additional
 ## functions that it is forced to clear.  By default, the
 ## @code{Octave:reload-forces-clear} warning is enabled.
-## 
+##
 ## @item Octave:resize-on-range-error
 ## If the @code{Octave:resize-on-range-error} warning is enabled, print a
 ## warning when a matrix is resized by an indexed assignment with
 ## indices outside the current bounds.  By default, the
 ## @code{Octave:resize-on-range-error} warning is disabled.
-## 
+##
 ## @item Octave:separator-insert
 ## Print warning if commas or semicolons might be inserted
 ## automatically in literal matrices.
-## 
+##
 ## @item Octave:single-quote-string
 ## Print warning if a single quote character is used to introduce a
 ## string constant.
-## 
+##
 ## @item Octave:str-to-num
 ## If the @code{Octave:str-to-num} warning is enabled, a warning is printed
 ## for implicit conversions of strings to their numeric ASCII equivalents.
 ## For example,
 ##
 ## @example
 ## @group
 ## "abc" + 0
 ##      @result{} 97 98 99
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## elicits a warning if the @code{Octave:str-to-num} warning is enabled.
 ## By default, the @code{Octave:str-to-num} warning is disabled.
-## 
+##
 ## @item Octave:string-concat
 ## If the @code{Octave:string-concat} warning is enabled, print a
 ## warning when concatenating a mixture of double and single quoted strings.
 ## By default, the @code{Octave:string-concat} warning is disabled.
-## 
+##
 ## @item Octave:undefined-return-values
 ## If the @code{Octave:undefined-return-values} warning is disabled,
 ## print a warning if a function does not define all the values in
 ## the return list which are expected.  By default, the
 ## @code{Octave:undefined-return-values} warning is enabled.
-## 
+##
 ## @item Octave:variable-switch-label
 ## If the @code{Octave:variable-switch-label} warning is enabled, Octave
 ## will print a warning if a switch label is not a constant or constant
 ## expression.  By default, the @code{Octave:variable-switch-label}
 ## warning is disabled.
 ## @end table
 
 function warning_ids ()
diff --git a/scripts/miscellaneous/what.m b/scripts/miscellaneous/what.m
--- a/scripts/miscellaneous/what.m
+++ b/scripts/miscellaneous/what.m
@@ -12,22 +12,22 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Command} {} what 
+## @deftypefn  {Command} {} what
 ## @deftypefnx {Command} {} what @var{dir}
 ## @deftypefnx {Function File} {w =} what (@var{dir})
 ## List the Octave specific files in a directory.  If the variable @var{dir}
 ## is given then check that directory rather than the current directory.  If
-## a return argument is requested, the files found are returned in the 
+## a return argument is requested, the files found are returned in the
 ## structure @var{w}.
 ## @seealso{which}
 ## @end deftypefn
 
 function ret = what (d)
 
   if (nargin == 0)
     d = pwd ();
@@ -58,23 +58,23 @@ function ret = what (d)
     n = files(i).name;
     ## Ignore . and ..
     if (strcmp (n, ".") || strcmp (n, ".."))
       continue;
     else
       ## Ignore mdl and p files
       [dummy, f, e] = fileparts (n);
       if (strcmp (e, ".m"))
-        w.m{end+1} = n; 
+        w.m{end+1} = n;
       elseif (strcmp (e, mexext ()))
-        w.mex{end+1} = n; 
+        w.mex{end+1} = n;
       elseif (strcmp (e, ".oct"))
         w.oct{end+1} = n;
       elseif (strcmp (e, ".mat"))
-        w.mat{end+1} = n; 
+        w.mat{end+1} = n;
       elseif(strcmp (n(1), "@"))
         w.classes{end+1} = n;
       endif
     endif
   endfor
 
   if (nargout == 0)
     __display_filenames__ ("M-files in directory", w.path, w.m);
@@ -85,26 +85,26 @@ function ret = what (d)
   else
     ret = w;
   endif
 endfunction
 
 function __display_filenames__ (msg, p, f)
   if (length (f) > 0)
     printf ("%s %s:\n\n", msg, p)
-  
+
     maxlen = max (cellfun (@length, f));
     ncols = max (1, floor (terminal_size()(2) / (maxlen + 3)));
     fmt = "";
     for i = 1: ncols
       fmt = sprintf ("%s   %%-%ds", fmt, maxlen);
     endfor
     fmt = [fmt, "\n"];
 
-    nrows = ceil (length (f) / ncols); 
+    nrows = ceil (length (f) / ncols);
     for i = 1 : nrows
       args  = f(i:nrows:end);
       if (length (args) < ncols)
         args(end + 1 : ncols) = {""};
       endif
       printf (fmt, args{:});
     endfor
   endif
diff --git a/scripts/miscellaneous/zip.m b/scripts/miscellaneous/zip.m
--- a/scripts/miscellaneous/zip.m
+++ b/scripts/miscellaneous/zip.m
@@ -14,19 +14,19 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{entries} =} zip (@var{zipfile}, @var{files})
 ## @deftypefnx {Function File} {@var{entries} =} zip (@var{zipfile}, @var{files}, @var{rootdir})
-## Compress the list of files and/or directories specified in @var{files} 
-## into the archive @var{zipfiles} in the same directory.  If @var{rootdir} 
-## is defined the @var{files} is located relative to @var{rootdir} rather 
+## Compress the list of files and/or directories specified in @var{files}
+## into the archive @var{zipfiles} in the same directory.  If @var{rootdir}
+## is defined the @var{files} is located relative to @var{rootdir} rather
 ## than the current directory
 ## @seealso{unzip,tar}
 ## @end deftypefn
 
 ## Author: Sylvain Pelissier <sylvain.pelissier@gmail.com>
 
 function entries = zip (zipfile, files, rootdir)
 
@@ -59,17 +59,17 @@ function entries = zip (zipfile, files, 
             entries = strsplit (entries, "\n");
           else
             error ("zip: zipinfo failed with exit status = %d", status);
           endif
         endif
       else
         error ("zip: zip failed with exit status = %d", status);
       endif
-    
+
     else
       error ("zip: expecting all arguments to be character strings");
     endif
 
   else
     print_usage ();
   endif
 
diff --git a/scripts/optimization/__all_opts__.m b/scripts/optimization/__all_opts__.m
--- a/scripts/optimization/__all_opts__.m
+++ b/scripts/optimization/__all_opts__.m
@@ -20,17 +20,17 @@
 ## @deftypefn {Function File} {@var{names} =} __all_opts__ (@dots{})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Query all options from all known optimization functions and return a
 ## list of possible values.
 
 function names = __all_opts__ (varargin)
-  
+
   persistent saved_names = {};
 
   ## do not clear this function
   mlock ();
 
   ## guard against recursive calls.
   persistent recursive = false;
 
diff --git a/scripts/optimization/fminbnd.m b/scripts/optimization/fminbnd.m
--- a/scripts/optimization/fminbnd.m
+++ b/scripts/optimization/fminbnd.m
@@ -21,34 +21,34 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{x}, @var{fval}, @var{info}, @var{output}] =} fminbnd (@var{fun}, @var{a}, @var{b}, @var{options})
 ## Find a minimum point of a univariate function.  @var{fun} should be a
 ## function
 ## handle or name.  @var{a}, @var{b} specify a starting interval.  @var{options}
 ## is a
 ## structure specifying additional options.  Currently, @code{fminbnd}
 ## recognizes these options: @code{"FunValCheck"}, @code{"OutputFcn"},
-## @code{"TolX"}, @code{"MaxIter"}, @code{"MaxFunEvals"}. 
+## @code{"TolX"}, @code{"MaxIter"}, @code{"MaxFunEvals"}.
 ## For description of these options, see @ref{doc-optimset,,optimset}.
-## 
+##
 ## On exit, the function returns @var{x}, the approximate minimum point
 ## and @var{fval}, the function value thereof.
 ## @var{info} is an exit flag that can have these values:
 ##
 ## @itemize
 ## @item 1
 ## The algorithm converged to a solution.
 ##
 ## @item 0
 ## Maximum number of iterations or function evaluations has been exhausted.
 ##
 ## @item -1
 ## The algorithm has been terminated from user output function.
 ## @end itemize
-## @seealso{optimset, fzero, fminunc} 
+## @seealso{optimset, fzero, fminunc}
 ## @end deftypefn
 
 ## This is patterned after opt/fmin.f from Netlib, which in turn is taken from
 ## Richard Brent: Algorithms For Minimization Without Derivatives, Prentice-Hall (1973)
 
 ## PKG_ADD: __all_opts__ ("fminbnd");
 
 function [x, fval, info, output] = fminbnd (fun, xmin, xmax, options = struct ())
@@ -136,17 +136,17 @@ function [x, fval, info, output] = fminb
     if (dogs)
       ## Default to golden section step.
       e = ifelse (x >= xm, a - x, b - x);
       d = c * e;
     endif
 
      ## f must not be evaluated too close to x.
      u = x + max (abs (d), tol) * (sign (d) + (d == 0));
-     
+
      fu = fun (u);
      nfev++;
      niter++;
 
      ## update  a, b, v, w, and x
 
      if (fu <= fval)
        if (u < x)
@@ -193,19 +193,19 @@ function [x, fval, info, output] = fminb
 endfunction
 
 ## An assistant function that evaluates a function handle and checks for
 ## bad results.
 function fx = guarded_eval (fun, x)
   fx = fun (x);
   fx = fx(1);
   if (! isreal (fx))
-    error ("fminbnd:notreal", "fminbnd: non-real value encountered"); 
+    error ("fminbnd:notreal", "fminbnd: non-real value encountered");
   elseif (isnan (fx))
-    error ("fminbnd:isnan", "fminbnd: NaN value encountered"); 
+    error ("fminbnd:isnan", "fminbnd: NaN value encountered");
   endif
 endfunction
 
 %!shared opt0
 %! opt0 = optimset ("tolx", 0);
 %!assert (fminbnd (@cos, pi/2, 3*pi/2, opt0), pi, 10*sqrt(eps))
 %!assert (fminbnd (@(x) (x - 1e-3)^4, -1, 1, opt0), 1e-3, 10e-3*sqrt(eps))
 %!assert (fminbnd (@(x) abs(x-1e7), 0, 1e10, opt0), 1e7, 10e7*sqrt(eps))
diff --git a/scripts/optimization/fminunc.m b/scripts/optimization/fminunc.m
--- a/scripts/optimization/fminunc.m
+++ b/scripts/optimization/fminunc.m
@@ -21,63 +21,63 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} fminunc (@var{fcn}, @var{x0})
 ## @deftypefnx {Function File} {} fminunc (@var{fcn}, @var{x0}, @var{options})
 ## @deftypefnx {Function File} {[@var{x}, @var{fvec}, @var{info}, @var{output}, @var{grad}, @var{hess}]} = fminunc (@var{fcn}, @dots{})
 ## Solve an unconstrained optimization problem defined by the function
 ## @var{fcn}.
 ## @var{fcn} should accepts a vector (array) defining the unknown variables,
 ## and return the objective function value, optionally with gradient.
-## In other words, this function attempts to determine a vector @var{x} such 
+## In other words, this function attempts to determine a vector @var{x} such
 ## that @code{@var{fcn} (@var{x})} is a local minimum.
 ## @var{x0} determines a starting guess.  The shape of @var{x0} is preserved
 ## in all calls to @var{fcn}, but otherwise is treated as a column vector.
 ## @var{options} is a structure specifying additional options.
 ## Currently, @code{fminunc} recognizes these options:
 ## @code{"FunValCheck"}, @code{"OutputFcn"}, @code{"TolX"},
-## @code{"TolFun"}, @code{"MaxIter"}, @code{"MaxFunEvals"}, 
+## @code{"TolFun"}, @code{"MaxIter"}, @code{"MaxFunEvals"},
 ## @code{"GradObj"}, @code{"FinDiffType"},
 ## @code{"TypicalX"}, @code{"AutoScaling"}.
 ##
 ## If @code{"GradObj"} is @code{"on"}, it specifies that @var{fcn},
 ## called with 2 output arguments, also returns the Jacobian matrix
 ## of right-hand sides at the requested point.  @code{"TolX"} specifies
-## the termination tolerance in the unknown variables, while 
+## the termination tolerance in the unknown variables, while
 ## @code{"TolFun"} is a tolerance for equations.  Default is @code{1e-7}
 ## for both @code{"TolX"} and @code{"TolFun"}.
-## 
+##
 ## For description of the other options, see @code{optimset}.
 ##
 ## On return, @var{fval} contains the value of the function @var{fcn}
 ## evaluated at @var{x}, and @var{info} may be one of the following values:
-## 
+##
 ## @table @asis
 ## @item 1
 ## Converged to a solution point.  Relative gradient error is less than
 ## specified
 ## by TolFun.
 ##
 ## @item 2
 ## Last relative step size was less that TolX.
 ##
 ## @item 3
-## Last relative decrease in func value was less than TolF. 
+## Last relative decrease in func value was less than TolF.
 ##
 ## @item 0
 ## Iteration limit exceeded.
 ##
 ## @item -3
-## The trust region radius became excessively small. 
+## The trust region radius became excessively small.
 ## @end table
 ##
 ## Optionally, fminunc can also yield a structure with convergence statistics
 ## (@var{output}), the output gradient (@var{grad}) and approximate Hessian
 ## (@var{hess}).
 ##
-## Note: If you only have a single nonlinear equation of one variable, using 
+## Note: If you only have a single nonlinear equation of one variable, using
 ## @code{fminbnd} is usually a much better idea.
 ## @seealso{fminbnd, optimset}
 ## @end deftypefn
 
 ## PKG_ADD: __all_opts__ ("fminunc");
 
 function [x, fval, info, output, grad, hess] = fminunc (fcn, x0, options = struct ())
 
@@ -88,17 +88,17 @@ function [x, fval, info, output, grad, h
     "OutputFcn", [], "FunValCheck", "off",
     "FinDiffType", "central",
     "TypicalX", [], "AutoScaling", "off");
     return;
   endif
 
   if (nargin < 2 || nargin > 3 || ! ismatrix (x0))
     print_usage ();
-  endif    
+  endif
 
   if (ischar (fcn))
     fcn = str2func (fcn, "global");
   endif
 
   xsiz = size (x0);
   n = numel (x0);
 
@@ -177,17 +177,17 @@ function [x, fval, info, output, grad, h
       grad = grad(:);
       nfev ++;
     else
       grad = __fdjac__ (fcn, reshape (x, xsiz), fval, typicalx, cdif)(:);
       nfev += (1 + cdif) * length (x);
     endif
 
     if (niter == 1)
-      ## Initialize by identity matrix. 
+      ## Initialize by identity matrix.
       hesr = eye (n);
     else
       ## Use the damped BFGS formula.
       y = grad - grad0;
       sBs = sumsq (w);
       Bs = hesr'*w;
       sy = y'*s;
       theta = 0.8 / max (1 - sy / sBs, 0.8);
@@ -299,17 +299,17 @@ function [x, fval, info, output, grad, h
         if (stop)
           info = -1;
           break;
         endif
       endif
 
       ## Tests for termination conditions. A mysterious place, anything
       ## can happen if you change something here...
-      
+
       ## The rule of thumb (which I'm not sure M*b is quite following)
       ## is that for a tolerance that depends on scaling, only 0 makes
       ## sense as a default value. But 0 usually means uselessly long
       ## iterations, so we need scaling-independent tolerances wherever
       ## possible.
 
       ## The following tests done only after successful step.
       if (ratio >= 1e-4)
@@ -345,21 +345,21 @@ function [fx, gx] = guarded_eval (fun, x
   if (nargout > 1)
     [fx, gx] = fun (x);
   else
     fx = fun (x);
     gx = [];
   endif
 
   if (! (isreal (fx) && isreal (jx)))
-    error ("fminunc:notreal", "fminunc: non-real value encountered"); 
+    error ("fminunc:notreal", "fminunc: non-real value encountered");
   elseif (complexeqn && ! (isnumeric (fx) && isnumeric(jx)))
     error ("fminunc:notnum", "fminunc: non-numeric value encountered");
   elseif (any (isnan (fx(:))))
-    error ("fminunc:isnan", "fminunc: NaN value encountered"); 
+    error ("fminunc:isnan", "fminunc: NaN value encountered");
   endif
 endfunction
 
 %!function f = rosenb (x)
 %!  n = length (x);
 %!  f = sumsq (1 - x(1:n-1)) + 100 * sumsq (x(2:n) - x(1:n-1).^2);
 %!test
 %! [x, fval, info, out] = fminunc (@rosenb, [5, -5]);
diff --git a/scripts/optimization/fsolve.m b/scripts/optimization/fsolve.m
--- a/scripts/optimization/fsolve.m
+++ b/scripts/optimization/fsolve.m
@@ -20,76 +20,76 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} fsolve (@var{fcn}, @var{x0}, @var{options})
 ## @deftypefnx {Function File} {[@var{x}, @var{fvec}, @var{info}, @var{output}, @var{fjac}] =} fsolve (@var{fcn}, @dots{})
 ## Solve a system of nonlinear equations defined by the function @var{fcn}.
 ## @var{fcn} should accept a vector (array) defining the unknown variables,
 ## and return a vector of left-hand sides of the equations.  Right-hand sides
 ## are defined to be zeros.
-## In other words, this function attempts to determine a vector @var{x} such 
+## In other words, this function attempts to determine a vector @var{x} such
 ## that @code{@var{fcn} (@var{x})} gives (approximately) all zeros.
 ## @var{x0} determines a starting guess.  The shape of @var{x0} is preserved
 ## in all calls to @var{fcn}, but otherwise it is treated as a column vector.
 ## @var{options} is a structure specifying additional options.
 ## Currently, @code{fsolve} recognizes these options:
 ## @code{"FunValCheck"}, @code{"OutputFcn"}, @code{"TolX"},
-## @code{"TolFun"}, @code{"MaxIter"}, @code{"MaxFunEvals"}, 
+## @code{"TolFun"}, @code{"MaxIter"}, @code{"MaxFunEvals"},
 ## @code{"Jacobian"}, @code{"Updating"}, @code{"ComplexEqn"}
 ## @code{"TypicalX"}, @code{"AutoScaling"} and @code{"FinDiffType"}.
 ##
 ## If @code{"Jacobian"} is @code{"on"}, it specifies that @var{fcn},
 ## called with 2 output arguments, also returns the Jacobian matrix
 ## of right-hand sides at the requested point.  @code{"TolX"} specifies
-## the termination tolerance in the unknown variables, while 
+## the termination tolerance in the unknown variables, while
 ## @code{"TolFun"} is a tolerance for equations.  Default is @code{1e-7}
 ## for both @code{"TolX"} and @code{"TolFun"}.
 ##
 ## If @code{"AutoScaling"} is on, the variables will be automatically scaled
 ## according to the column norms of the (estimated) Jacobian.  As a result,
 ## TolF becomes scaling-independent.  By default, this option is off, because
 ## it may sometimes deliver unexpected (though mathematically correct) results.
-## 
+##
 ## If @code{"Updating"} is "on", the function will attempt to use Broyden
 ## updates to update the Jacobian, in order to reduce the amount of Jacobian
 ## calculations.
 ## If your user function always calculates the Jacobian (regardless of number
 ## of output arguments), this option provides no advantage and should be set to
 ## false.
-## 
+##
 ## @code{"ComplexEqn"} is @code{"on"}, @code{fsolve} will attempt to solve
 ## complex equations in complex variables, assuming that the equations possess a
-## complex derivative (i.e., are holomorphic).  If this is not what you want, 
+## complex derivative (i.e., are holomorphic).  If this is not what you want,
 ## should unpack the real and imaginary parts of the system to get a real
 ## system.
 ##
 ## For description of the other options, see @code{optimset}.
 ##
 ## On return, @var{fval} contains the value of the function @var{fcn}
 ## evaluated at @var{x}, and @var{info} may be one of the following values:
-## 
+##
 ## @table @asis
 ## @item 1
 ## Converged to a solution point.  Relative residual error is less than
 ## specified by TolFun.
 ##
 ## @item 2
 ## Last relative step size was less that TolX.
 ##
 ## @item 3
-## Last relative decrease in residual was less than TolF. 
+## Last relative decrease in residual was less than TolF.
 ##
 ## @item 0
 ## Iteration limit exceeded.
 ##
 ## @item -3
-## The trust region radius became excessively small. 
+## The trust region radius became excessively small.
 ## @end table
-## 
-## Note: If you only have a single nonlinear equation of one variable, using 
+##
+## Note: If you only have a single nonlinear equation of one variable, using
 ## @code{fzero} is usually a much better idea.
 ## @seealso{fzero, optimset}
 ##
 ## Note about user-supplied Jacobians:
 ## As an inherent property of the algorithm, Jacobian is always requested for a
 ## solution vector whose residual vector is already known, and it is the last
 ## accepted successful step.  Often this will be one of the last two calls, but
 ## not always.  If the savings by reusing intermediate results from residual
@@ -117,17 +117,17 @@
 ##   if (all (x == sav0.x))
 ##     sav = sav0;
 ##   endif
 ##   ## maybe output iteration status, etc.
 ## endif
 ## endfunction
 ##
 ## ## @dots{}.
-## 
+##
 ## fsolve (@@user_func, x0, optimset ("OutputFcn", @@user_func, @dots{}))
 ## @end example
 ## @end deftypefn
 
 ## PKG_ADD: __all_opts__ ("fsolve");
 
 function [x, fvec, info, output, fjac] = fsolve (fcn, x0, options = struct ())
 
@@ -138,17 +138,17 @@ function [x, fvec, info, output, fjac] =
     "OutputFcn", [], "Updating", "on", "FunValCheck", "off",
     "ComplexEqn", "off", "FinDiffType", "central",
     "TypicalX", [], "AutoScaling", "off");
     return;
   endif
 
   if (nargin < 2 || nargin > 3 || ! ismatrix (x0))
     print_usage ();
-  endif    
+  endif
 
   if (ischar (fcn))
     fcn = str2func (fcn, "global");
   elseif (iscell (fcn))
     fcn = @(x) make_fcn_jac (x, fcn{1}, fcn{2});
   endif
 
   xsiz = size (x0);
@@ -370,17 +370,17 @@ function [x, fvec, info, output, fjac] =
         if (stop)
           info = -1;
           break;
         endif
       endif
 
       ## Tests for termination conditions. A mysterious place, anything
       ## can happen if you change something here...
-      
+
       ## The rule of thumb (which I'm not sure M*b is quite following)
       ## is that for a tolerance that depends on scaling, only 0 makes
       ## sense as a default value. But 0 usually means uselessly long
       ## iterations, so we need scaling-independent tolerances wherever
       ## possible.
 
       ## FIXME -- why tolf*n*xn? If abs (e) ~ abs(x) * eps is a vector
       ## of perturbations of x, then norm (fjac*e) <= eps*n*xn, i.e. by
@@ -403,17 +403,17 @@ function [x, fvec, info, output, fjac] =
 
       ## Criterion for recalculating Jacobian.
       if (! updating || nfail == 2 || nsuciter < 2)
         break;
       endif
 
       ## Compute the scaled Broyden update.
       if (useqr)
-        u = (fvec1 - q*w) / sn; 
+        u = (fvec1 - q*w) / sn;
         v = dg .* ((dg .* s) / sn);
 
         ## Update the QR factorization.
         [q, r] = qrupdate (q, r, u, v);
       else
         u = (fvec1 - w);
         v = dg .* ((dg .* s) / sn);
 
@@ -439,32 +439,32 @@ function [fx, jx] = guarded_eval (fun, x
   if (nargout > 1)
     [fx, jx] = fun (x);
   else
     fx = fun (x);
     jx = [];
   endif
 
   if (! complexeqn && ! (isreal (fx) && isreal (jx)))
-    error ("fsolve:notreal", "fsolve: non-real value encountered"); 
+    error ("fsolve:notreal", "fsolve: non-real value encountered");
   elseif (complexeqn && ! (isnumeric (fx) && isnumeric(jx)))
     error ("fsolve:notnum", "fsolve: non-numeric value encountered");
   elseif (any (isnan (fx(:))))
-    error ("fsolve:isnan", "fsolve: NaN value encountered"); 
+    error ("fsolve:isnan", "fsolve: NaN value encountered");
   endif
 endfunction
 
 function [fx, jx] = make_fcn_jac (x, fcn, fjac)
   fx = fcn (x);
   if (nargout == 2)
     jx = fjac (x);
   endif
 endfunction
 
-%!function retval = f (p) 
+%!function retval = f (p)
 %!  x = p(1);
 %!  y = p(2);
 %!  z = p(3);
 %!  retval = zeros (3, 1);
 %!  retval(1) = sin(x) + y**2 + log(z) - 7;
 %!  retval(2) = 3*x + 2**y -z**3 + 1;
 %!  retval(3) = x + y + z - 5;
 %!test
@@ -490,17 +490,17 @@ endfunction
 %!test
 %! x_opt = [ -0.767297326653401, 0.590671081117440, 1.47190018629642, -1.52719341133957 ];
 %! tol = 1.0e-5;
 %! [x, fval, info] = fsolve (@f, [-1, 1, 2, -1]);
 %! assert (info > 0);
 %! assert (norm (x - x_opt, Inf) < tol);
 %! assert (norm (fval) < tol);
 
-%!function retval = f (p) 
+%!function retval = f (p)
 %!  x = p(1);
 %!  y = p(2);
 %!  z = p(3);
 %!  retval = zeros (3, 1);
 %!  retval(1) = sin(x) + y**2 + log(z) - 7;
 %!  retval(2) = 3*x + 2**y -z**3 + 1;
 %!  retval(3) = x + y + z - 5;
 %!  retval(4) = x*x + y - z*log(z) - 1.36;
@@ -509,17 +509,17 @@ endfunction
 %! 2.395931;
 %! 2.005014 ];
 %! tol = 1.0e-5;
 %! [x, fval, info] = fsolve (@f, [ 0.5; 2.0; 2.5 ]);
 %! assert (info > 0);
 %! assert (norm (x - x_opt, Inf) < tol);
 %! assert (norm (fval) < tol);
 
-%!function retval = f (p) 
+%!function retval = f (p)
 %!  x = p(1);
 %!  y = p(2);
 %!  z = p(3);
 %!  retval = zeros (3, 1);
 %!  retval(1) = sin(x) + y**2 + log(z) - 7;
 %!  retval(2) = 3*x + 2**y -z**3 + 1;
 %!  retval(3) = x + y + z - 5;
 %!test
@@ -536,32 +536,32 @@ endfunction
 %!test
 %! b0 = 3;
 %! a0 = 0.2;
 %! x = 0:.5:5;
 %! noise = 1e-5 * sin (100*x);
 %! y = exp (-a0*x) + b0 + noise;
 %! c_opt = [a0, b0];
 %! tol = 1e-5;
-%! 
+%!
 %! [c, fval, info, output] =  fsolve (@(c) (exp(-c(1)*x) + c(2) - y), [0, 0]);
 %! assert (info > 0);
 %! assert (norm (c - c_opt, Inf) < tol);
 %! assert (norm (fval) < norm (noise));
 
 
 %!function y = cfun (x)
 %!  y(1) = (1+i)*x(1)^2 - (1-i)*x(2) - 2;
 %!  y(2) = sqrt (x(1)*x(2)) - (1-2i)*x(3) + (3-4i);
 %!  y(3) = x(1) * x(2) - x(3)^2 + (3+2i);
 
 %!test
 %! x_opt = [-1+i, 1-i, 2+i];
 %! x = [i, 1, 1+i];
-%! 
+%!
 %! [x, f, info] = fsolve (@cfun, x, optimset ("ComplexEqn", "on"));
 %! tol = 1e-5;
 %! assert (norm (f) < tol);
 %! assert (norm (x - x_opt, Inf) < tol);
 
 ## Solve the double dogleg trust-region least-squares problem:
 ## Minimize norm(r*x-b) subject to the constraint norm(d.*x) <= delta,
 ## x being a convex combination of the gauss-newton and scaled gradient.
diff --git a/scripts/optimization/fzero.m b/scripts/optimization/fzero.m
--- a/scripts/optimization/fzero.m
+++ b/scripts/optimization/fzero.m
@@ -17,36 +17,36 @@
 ## <http://www.gnu.org/licenses/>.
 ##
 ## Author: Jaroslav Hajek <highegg@gmail.com>
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} fzero (@var{fun}, @var{x0})
 ## @deftypefnx {Function File} {} fzero (@var{fun}, @var{x0}, @var{options})
 ## @deftypefnx {Function File} {[@var{x}, @var{fval}, @var{info}, @var{output}] =} fzero (@dots{})
-## Find a zero of a univariate function.  
+## Find a zero of a univariate function.
 ##
-## @var{fun} should be a function handle or name.  @var{x0} should be a 
+## @var{fun} should be a function handle or name.  @var{x0} should be a
 ## two-element vector specifying two points which bracket a zero.  In
 ## other words, there must be a change in sign of the function between
 ## @var{x0}(1) and @var{x0}(2).  More mathematically, the following must hold
 ##
 ## @example
 ## sign (@var{fun}(@var{x0}(1))) * sign (@var{fun}(@var{x0}(2))) <= 0
 ## @end example
 ##
 ## If @var{x0} is a single scalar then several nearby and distant
 ## values are probed in an attempt to obtain a valid bracketing.  If this
 ## is not successful, the function fails.
-## @var{options} is a structure specifying additional options. 
+## @var{options} is a structure specifying additional options.
 ## Currently, @code{fzero}
 ## recognizes these options: @code{"FunValCheck"}, @code{"OutputFcn"},
-## @code{"TolX"}, @code{"MaxIter"}, @code{"MaxFunEvals"}. 
+## @code{"TolX"}, @code{"MaxIter"}, @code{"MaxFunEvals"}.
 ## For a description of these options, see @ref{doc-optimset,,optimset}.
-## 
+##
 ## On exit, the function returns @var{x}, the approximate zero point
 ## and @var{fval}, the function value thereof.
 ## @var{info} is an exit flag that can have these values:
 ##
 ## @itemize
 ## @item 1
 ##  The algorithm converged to a solution.
 ##
@@ -54,34 +54,34 @@
 ##  Maximum number of iterations or function evaluations has been reached.
 ##
 ## @item -1
 ## The algorithm has been terminated from user output function.
 ##
 ## @item -5
 ## The algorithm may have converged to a singular point.
 ## @end itemize
-## 
+##
 ## @var{output} is a structure containing runtime information about the
 ## @code{fzero} algorithm.  Fields in the structure are:
 ##
 ## @itemize
 ## @item iterations
 ##  Number of iterations through loop.
 ##
 ## @item nfev
 ##  Number of function evaluations.
 ##
 ## @item bracketx
 ##  A two-element vector with the final bracketing of the zero along the x-axis.
 ##
 ## @item brackety
 ##  A two-element vector with the final bracketing of the zero along the y-axis.
 ## @end itemize
-## @seealso{optimset, fsolve} 
+## @seealso{optimset, fsolve}
 ## @end deftypefn
 
 ## This is essentially the ACM algorithm 748: Enclosing Zeros of
 ## Continuous Functions due to Alefeld, Potra and Shi, ACM Transactions
 ## on Mathematical Software, Vol. 21, No. 3, September 1995. Although
 ## the workflow should be the same, the structure of the algorithm has
 ## been transformed non-trivially; instead of the authors' approach of
 ## sequentially calling building blocks subprograms we implement here a
@@ -130,17 +130,17 @@ function [x, fval, info, output] = fzero
   niter = 0;
   nfev = 0;
 
   x = fval = a = fa = b = fb = NaN;
   eps = eps (class (x0));
 
   ## Prepare...
   a = x0(1);
-  fa = fun (a); 
+  fa = fun (a);
   nfev = 1;
   if (length (x0) > 1)
     b = x0(2);
     fb = fun (b);
     nfev += 1;
   else
     ## Try to get b.
     if (a == 0)
@@ -155,17 +155,17 @@ function [x, fval, info, output] = fzero
       endif
     endfor
   endif
 
   if (b < a)
     u = a;
     a = b;
     b = u;
- 
+
     fu = fa;
     fa = fb;
     fb = fu;
   endif
 
   if (! (sign (fa) * sign (fb) <= 0))
     error ("fzero:bracket", "fzero: not a valid initial bracketing");
   endif
@@ -239,17 +239,17 @@ function [x, fval, info, output] = fzero
             if (pdc == 0)
               c = a - a0/a1;
               break;
             endif
             c -= pc/pdc;
           endfor
         endif
       endif
-      itype += 1; 
+      itype += 1;
     case 4
       ## Double secant step.
       c = u - 2*(b - a)/(fb - fa)*fu;
       ## Bisect if too far.
       if (abs (c - u) > 0.5*(b - a))
         c = 0.5 * (b + a);
       endif
       itype = 5;
@@ -264,23 +264,23 @@ function [x, fval, info, output] = fzero
     if ((b - a) <= 2*delta)
       c = (a + b)/2;
     else
       c = max (a + delta, min (b - delta, c));
     endif
 
     ## Calculate new point.
     x = c;
-    fval = fc = fun (c); 
+    fval = fc = fun (c);
     niter ++; nfev ++;
 
     ## Modification 2: skip inverse cubic interpolation if
     ## nonmonotonicity is detected.
     if (sign (fc - fa) * sign (fc - fb) >= 0)
-      ## The new point broke monotonicity. 
+      ## The new point broke monotonicity.
       ## Disable inverse cubic.
       fe = fc;
     else
       e = d; fe = fd;
     endif
 
     ## Bracketing.
     if (sign (fa) * sign (fc) < 0)
@@ -343,18 +343,18 @@ function [x, fval, info, output] = fzero
 endfunction
 
 ## An assistant function that evaluates a function handle and checks for
 ## bad results.
 function fx = guarded_eval (fun, x)
   fx = fun (x);
   fx = fx(1);
   if (! isreal (fx))
-    error ("fzero:notreal", "fzero: non-real value encountered"); 
+    error ("fzero:notreal", "fzero: non-real value encountered");
   elseif (isnan (fx))
-    error ("fzero:isnan", "fzero: NaN value encountered"); 
+    error ("fzero:isnan", "fzero: NaN value encountered");
   endif
 endfunction
 
 %!shared opt0
 %! opt0 = optimset ("tolx", 0);
 %!assert(fzero(@cos, [0, 3], opt0), pi/2, 10*eps)
 %!assert(fzero(@(x) x^(1/3) - 1e-8, [0,1], opt0), 1e-24, 1e-22*eps)
diff --git a/scripts/optimization/glpk.m b/scripts/optimization/glpk.m
--- a/scripts/optimization/glpk.m
+++ b/scripts/optimization/glpk.m
@@ -73,40 +73,40 @@
 ## @group
 ## A*x [ "=" | "<=" | ">=" ] b
 ##   x >= LB
 ##   x <= UB
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
-## 
+##
 ## Input arguments:
-## 
+##
 ## @table @var
 ## @item c
 ## A column array containing the objective function coefficients.
-## 
+##
 ## @item A
 ## A matrix containing the constraints coefficients.
-## 
+##
 ## @item b
 ## A column array containing the right-hand side value for each constraint
 ## in the constraint matrix.
-## 
+##
 ## @item lb
 ## An array containing the lower bound on each of the variables.  If
 ## @var{lb} is not supplied, the default lower bound for the variables is
 ## zero.
-## 
+##
 ## @item ub
 ## An array containing the upper bound on each of the variables.  If
 ## @var{ub} is not supplied, the default upper bound is assumed to be
 ## infinite.
-## 
+##
 ## @item ctype
 ## An array of characters containing the sense of each constraint in the
 ## constraint matrix.  Each element of the array may be one of the
 ## following values
 ## @table @code
 ## @item "F"
 ## A free (unbounded) constraint (the constraint is ignored).
 ##
@@ -118,231 +118,231 @@
 ##
 ## @item "L"
 ## An inequality with a lower bound (@code{A(i,:)*x >= b(i)}).
 ##
 ## @item "D"
 ## An inequality constraint with both upper and lower bounds
 ## (@code{A(i,:)*x >= -b(i)} @emph{and} (@code{A(i,:)*x <= b(i)}).
 ## @end table
-## 
+##
 ## @item vartype
 ## A column array containing the types of the variables.
 ## @table @code
 ## @item "C"
 ## A continuous variable.
 ##
 ## @item "I"
 ## An integer variable.
 ## @end table
-## 
+##
 ## @item sense
 ## If @var{sense} is 1, the problem is a minimization.  If @var{sense} is
 ## -1, the problem is a maximization.  The default value is 1.
-## 
+##
 ## @item param
 ## A structure containing the following parameters used to define the
 ## behavior of solver.  Missing elements in the structure take on default
 ## values, so you only need to set the elements that you wish to change
 ## from the default.
-## 
+##
 ## Integer parameters:
-## 
+##
 ## @table @code
 ## @item msglev (@w{@code{LPX_K_MSGLEV}}, default: 1)
 ## Level of messages output by solver routines:
 ## @table @asis
 ## @item 0
 ## No output.
 ##
 ## @item 1
 ## Error messages only.
 ##
 ## @item 2
 ## Normal output.
 ##
 ## @item 3
 ## Full output (includes informational messages).
 ## @end table
-## 
+##
 ## @item scale (@w{@code{LPX_K_SCALE}}, default: 1)
-## Scaling option: 
+## Scaling option:
 ## @table @asis
 ## @item 0
 ## No scaling.
 ##
 ## @item 1
 ## Equilibration scaling.
 ##
 ## @item 2
 ## Geometric mean scaling, then equilibration scaling.
 ## @end table
-## 
+##
 ## @item dual    (@w{@code{LPX_K_DUAL}}, default: 0)
 ## Dual simplex option:
 ## @table @asis
 ## @item 0
 ## Do not use the dual simplex.
 ##
 ## @item 1
 ## If initial basic solution is dual feasible, use the dual simplex.
 ## @end table
-## 
+##
 ## @item price   (@w{@code{LPX_K_PRICE}}, default: 1)
 ## Pricing option (for both primal and dual simplex):
 ## @table @asis
 ## @item 0
 ## Textbook pricing.
 ##
 ## @item 1
 ## Steepest edge pricing.
 ## @end table
-##   
+##
 ## @item round   (@w{@code{LPX_K_ROUND}}, default: 0)
 ## Solution rounding option:
 ## @table @asis
 ## @item 0
 ## Report all primal and dual values "as is".
 ##
 ## @item 1
 ## Replace tiny primal and dual values by exact zero.
 ## @end table
-## 
+##
 ## @item itlim   (@w{@code{LPX_K_ITLIM}}, default: -1)
 ## Simplex iterations limit.  If this value is positive, it is decreased by
 ## one each time when one simplex iteration has been performed, and
 ## reaching zero value signals the solver to stop the search.  Negative
 ## value means no iterations limit.
-## 
+##
 ## @item itcnt (@w{@code{LPX_K_OUTFRQ}}, default: 200)
 ## Output frequency, in iterations.  This parameter specifies how
 ## frequently the solver sends information about the solution to the
 ## standard output.
-## 
+##
 ## @item branch (@w{@code{LPX_K_BRANCH}}, default: 2)
 ## Branching heuristic option (for MIP only):
 ## @table @asis
 ## @item 0
 ## Branch on the first variable.
 ##
 ## @item 1
 ## Branch on the last variable.
 ##
 ## @item 2
 ## Branch using a heuristic by Driebeck and Tomlin.
 ## @end table
-## 
+##
 ## @item btrack (@w{@code{LPX_K_BTRACK}}, default: 2)
 ## Backtracking heuristic option (for MIP only):
 ## @table @asis
 ## @item 0
 ## Depth first search.
 ##
 ## @item 1
 ## Breadth first search.
 ##
 ## @item 2
 ## Backtrack using the best projection heuristic.
-## @end table        
-## 
+## @end table
+##
 ## @item presol (@w{@code{LPX_K_PRESOL}}, default: 1)
 ## If this flag is set, the routine lpx_simplex solves the problem using
 ## the built-in LP presolver.  Otherwise the LP presolver is not used.
-## 
+##
 ## @item lpsolver (default: 1)
 ## Select which solver to use.  If the problem is a MIP problem this flag
 ## will be ignored.
 ## @table @asis
 ## @item 1
 ## Revised simplex method.
 ##
 ## @item 2
 ## Interior point method.
 ## @end table
 ##
 ## @item save (default: 0)
 ## If this parameter is nonzero, save a copy of the problem in
 ## CPLEX LP format to the file @file{"outpb.lp"}.  There is currently no
 ## way to change the name of the output file.
 ## @end table
-## 
+##
 ## Real parameters:
-## 
+##
 ## @table @code
 ## @item relax (@w{@code{LPX_K_RELAX}}, default: 0.07)
 ## Relaxation parameter used in the ratio test.  If it is zero, the textbook
 ## ratio test is used.  If it is non-zero (should be positive), Harris'
 ## two-pass ratio test is used.  In the latter case on the first pass of the
 ## ratio test basic variables (in the case of primal simplex) or reduced
 ## costs of non-basic variables (in the case of dual simplex) are allowed
 ## to slightly violate their bounds, but not more than
 ## @code{relax*tolbnd} or @code{relax*toldj (thus, @code{relax} is a
 ## percentage of @code{tolbnd} or @code{toldj}}.
-## 
+##
 ## @item tolbnd (@w{@code{LPX_K_TOLBND}}, default: 10e-7)
 ## Relative tolerance used to check if the current basic solution is primal
 ## feasible.  It is not recommended that you change this parameter unless you
 ## have a detailed understanding of its purpose.
-## 
+##
 ## @item toldj (@w{@code{LPX_K_TOLDJ}}, default: 10e-7)
 ## Absolute tolerance used to check if the current basic solution is dual
 ## feasible.  It is not recommended that you change this parameter unless you
 ## have a detailed understanding of its purpose.
-## 
+##
 ## @item tolpiv (@w{@code{LPX_K_TOLPIV}}, default: 10e-9)
 ## Relative tolerance used to choose eligible pivotal elements of the
 ## simplex table.  It is not recommended that you change this parameter unless
 ## you have a detailed understanding of its purpose.
-## 
+##
 ## @item objll (@w{@code{LPX_K_OBJLL}}, default: -DBL_MAX)
 ## Lower limit of the objective function.  If on the phase II the objective
 ## function reaches this limit and continues decreasing, the solver stops
 ## the search.  This parameter is used in the dual simplex method only.
-## 
+##
 ## @item objul (@w{@code{LPX_K_OBJUL}}, default: +DBL_MAX)
 ## Upper limit of the objective function.  If on the phase II the objective
 ## function reaches this limit and continues increasing, the solver stops
 ## the search.  This parameter is used in the dual simplex only.
-## 
+##
 ## @item tmlim (@w{@code{LPX_K_TMLIM}}, default: -1.0)
 ## Searching time limit, in seconds.  If this value is positive, it is
 ## decreased each time when one simplex iteration has been performed by the
 ## amount of time spent for the iteration, and reaching zero value signals
 ## the solver to stop the search.  Negative value means no time limit.
-## 
+##
 ## @item outdly (@w{@code{LPX_K_OUTDLY}}, default: 0.0)
 ## Output delay, in seconds.  This parameter specifies how long the solver
 ## should delay sending information about the solution to the standard
 ## output.  Non-positive value means no delay.
-## 
+##
 ## @item tolint (@w{@code{LPX_K_TOLINT}}, default: 10e-5)
 ## Relative tolerance used to check if the current basic solution is integer
 ## feasible.  It is not recommended that you change this parameter unless
 ## you have a detailed understanding of its purpose.
-## 
+##
 ## @item tolobj (@w{@code{LPX_K_TOLOBJ}}, default: 10e-7)
 ## Relative tolerance used to check if the value of the objective function
 ## is not better than in the best known integer feasible solution.  It is
 ## not recommended that you change this parameter unless you have a
 ## detailed understanding of its purpose.
 ## @end table
 ## @end table
-## 
+##
 ## Output values:
-## 
+##
 ## @table @var
 ## @item xopt
 ## The optimizer (the value of the decision variables at the optimum).
 ##
 ## @item fopt
 ## The optimum value of the objective function.
 ##
 ## @item status
 ## Status of the optimization.
-## 
+##
 ## Simplex Method:
 ## @table @asis
 ## @item 180 (@w{@code{LPX_OPT}})
 ## Solution is optimal.
 ## @item 181 (@w{@code{LPX_FEAS}})
 ## Solution is feasible.
 ## @item 182 (@w{@code{LPX_INFEAS}})
 ## Solution is infeasible.
@@ -408,39 +408,39 @@
 ##
 ## @item redcosts
 ## Reduced Costs.
 ##
 ## @item time
 ## Time (in seconds) used for solving LP/MIP problem.
 ##
 ## @item mem
-## Memory (in bytes) used for solving LP/MIP problem (this is not 
+## Memory (in bytes) used for solving LP/MIP problem (this is not
 ## available if the version of @sc{glpk} is 4.15 or later).
 ## @end table
 ## @end table
-## 
+##
 ## Example:
-## 
+##
 ## @example
 ## @group
 ## c = [10, 6, 4]';
 ## A = [ 1, 1, 1;
 ##      10, 4, 5;
 ##       2, 2, 6];
 ## b = [100, 600, 300]';
 ## lb = [0, 0, 0]';
 ## ub = [];
 ## ctype = "UUU";
 ## vartype = "CCC";
 ## s = -1;
-## 
+##
 ## param.msglev = 1;
 ## param.itlim = 100;
-## 
+##
 ## [xmin, fmin, status, extra] = ...
 ##    glpk (c, A, b, lb, ub, ctype, vartype, s, param);
 ## @end group
 ## @end example
 ## @end deftypefn
 
 ## Author: Nicolo' Giorgetti <giorgetti@dii.unisi.it>
 ## Adapted-by: jwe
diff --git a/scripts/optimization/lsqnonneg.m b/scripts/optimization/lsqnonneg.m
--- a/scripts/optimization/lsqnonneg.m
+++ b/scripts/optimization/lsqnonneg.m
@@ -21,17 +21,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{x} =} lsqnonneg (@var{c}, @var{d})
 ## @deftypefnx {Function File} {@var{x} =} lsqnonneg (@var{c}, @var{d}, @var{x0})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}, @var{output}] =} lsqnonneg (@dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{resnorm}, @var{residual}, @var{exitflag}, @var{output}, @var{lambda}] =} lsqnonneg (@dots{})
-## Minimize @code{norm (@var{c}*@var{x} - d)} subject to 
+## Minimize @code{norm (@var{c}*@var{x} - d)} subject to
 ## @code{@var{x} >= 0}.  @var{c} and @var{d} must be real.  @var{x0} is an
 ## optional initial guess for @var{x}.
 ##
 ## Outputs:
 ## @itemize @bullet
 ## @item resnorm
 ##
 ## The squared 2-norm of the residual: norm(@var{c}*@var{x}-@var{d})^2
@@ -111,17 +111,17 @@ function [x, resnorm, residual, exitflag
       ## of the positive problem.
       if (useqr)
         xtmp = r \ q'*d;
       else
         xtmp = c(:,p) \ d;
       endif
       idx = find (xtmp < 0);
 
-      if (isempty (idx)) 
+      if (isempty (idx))
         ## LH7: tmp solution found, iterate.
         x(:) = 0;
         x(p) = xtmp;
         break;
       else
         ## LH8, LH9: find the scaling factor.
         pidx = p(idx);
         sf = x(pidx)./(x(pidx) - xtmp(idx));
@@ -135,17 +135,17 @@ function [x, resnorm, residual, exitflag
         idx = idx (sf == alpha);
         p(idx) = [];
         if (useqr)
           ## update the QR factorization.
           [q, r] = qrdelete (q, r, idx);
         endif
       endif
     endwhile
-      
+
     ## compute the gradient.
     w = c'*(d - c*x);
     w(p) = [];
     if (! any (w > 0))
       if (useqr)
         ## verify the solution achieved using qr updating.
         ## in the best case, this should only take a single step.
         useqr = false;
diff --git a/scripts/optimization/optimget.m b/scripts/optimization/optimget.m
--- a/scripts/optimization/optimget.m
+++ b/scripts/optimization/optimget.m
@@ -15,19 +15,19 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} optimget (@var{options}, @var{parname})
 ## @deftypefnx {Function File} {} optimget (@var{options}, @var{parname}, @var{default})
-## Return a specific option from a structure created by 
+## Return a specific option from a structure created by
 ## @code{optimset}.  If @var{parname} is not a field of the @var{options}
-## structure, return @var{default} if supplied, otherwise return an 
+## structure, return @var{default} if supplied, otherwise return an
 ## empty matrix.
 ## @end deftypefn
 
 function retval = optimget (options, parname, default)
 
   if (nargin < 2 || nargin > 4 || ! isstruct (options) || ! ischar (parname))
     print_usage ();
   endif
diff --git a/scripts/optimization/pqpnonneg.m b/scripts/optimization/pqpnonneg.m
--- a/scripts/optimization/pqpnonneg.m
+++ b/scripts/optimization/pqpnonneg.m
@@ -55,17 +55,17 @@
 ##
 ## Not implemented.
 ## @end itemize
 ## @seealso{optimset, lsqnonneg, qp}
 ## @end deftypefn
 
 ## PKG_ADD: __all_opts__ ("pqpnonneg");
 
-## This is analogical to the lsqnonneg implementation, which is 
+## This is analogical to the lsqnonneg implementation, which is
 ## implemented from Lawson and Hanson's 1973 algorithm on page
 ## 161 of Solving Least Squares Problems.
 ## It shares the convergence guarantees.
 
 function [x, minval, exitflag, output, lambda] = pqpnonneg (c, d, x = [], options = struct ())
 
   if (nargin == 1 && ischar (c) && strcmp (c, 'defaults'))
     x = optimset ("MaxIter", 1e5);
@@ -110,17 +110,17 @@ function [x, minval, exitflag, output, l
       ## of the positive problem.
       if (usechol)
         xtmp = -(r \ (r' \ d(p)));
       else
         xtmp = -(c(p,p) \ d(p));
       endif
       idx = find (xtmp < 0);
 
-      if (isempty (idx)) 
+      if (isempty (idx))
         ## LH7: tmp solution found, iterate.
         x(:) = 0;
         x(p) = xtmp;
         break;
       else
         ## LH8, LH9: find the scaling factor.
         pidx = p(idx);
         sf = x(pidx)./(x(pidx) - xtmp(idx));
@@ -134,17 +134,17 @@ function [x, minval, exitflag, output, l
         idx = idx (sf == alpha);
         p(idx) = [];
         if (usechol)
           ## update the Cholesky factorization.
           r = choldelete (r, idx);
         endif
       endif
     endwhile
-      
+
     ## compute the gradient.
     w = -(d + c*x);
     w(p) = [];
     if (! any (w > 0))
       if (usechol)
         ## verify the solution achieved using qr updating.
         ## in the best case, this should only take a single step.
         usechol = false;
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -82,17 +82,17 @@
 ## following fields are defined:
 ##
 ## @table @code
 ## @item solveiter
 ## The number of iterations required to find the solution.
 ##
 ## @item info
 ## An integer indicating the status of the solution.
-## 
+##
 ## @table @asis
 ## @item 0
 ## The problem is feasible and convex.  Global solution found.
 ##
 ## @item 1
 ## The problem is not convex.  Local solution found.
 ##
 ## @item 2
@@ -218,17 +218,17 @@ function [x, obj, INFO, lambda] = qp (x0
       if (! isempty (ub))
         if (numel (ub) != n)
           error ("qp: upper bound has incorrect length");
         elseif (isempty (lb))
           Ain = [Ain; -eye(n)];
           bin = [bin; -ub];
         endif
       endif
-      
+
       if (! isempty (lb) && ! isempty (ub))
         rtol = sqrt (eps);
         for i = 1:n
           if (abs(lb (i) - ub(i)) < rtol*(1 + max (abs (lb(i) + ub(i)))))
             ## These are actually an equality constraint
             tmprow = zeros(1,n);
             tmprow(i) = 1;
             A = [A;tmprow];
@@ -262,17 +262,17 @@ function [x, obj, INFO, lambda] = qp (x0
         if (! isempty (A_ub))
           if (numel (A_ub) != dimA_in)
             error ("qp: inequality constraint matrix and upper bound vector inconsistent");
           elseif (isempty (A_lb))
             Ain = [Ain; -A_in];
             bin = [bin; -A_ub];
           endif
         endif
-        
+
         if (! isempty (A_lb) && ! isempty (A_ub))
           rtol = sqrt (eps);
           for i = 1:dimA_in
             if (abs (A_lb(i) - A_ub(i)) < rtol*(1 + max (abs (A_lb(i) + A_ub(i)))))
               ## These are actually an equality constraint
               tmprow = A_in(i,:);
               A = [A;tmprow];
               b = [b; 0.5*(A_lb(i) + A_ub(i))];
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -109,24 +109,24 @@
 ## of the form
 ##
 ## @example
 ## @var{r} = f (@var{x})
 ## @end example
 ##
 ## @noindent
 ## in which @var{x} is a vector and @var{r} is a vector.
-## 
+##
 ## The third and fourth arguments may also be 2-element cell arrays of
 ## function handles.  The first element should point to the constraint
 ## function and the second should point to a function that computes the
 ## gradient of the constraint function:
 ## @tex
 ## $$
-##  \Bigg( {\partial f(x) \over \partial x_1}, 
+##  \Bigg( {\partial f(x) \over \partial x_1},
 ##         {\partial f(x) \over \partial x_2}, \ldots,
 ##         {\partial f(x) \over \partial x_N} \Bigg)^T
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
@@ -137,77 +137,77 @@
 ## @end example
 ##
 ## @end ifnottex
 ## The fifth and sixth arguments contain lower and upper bounds
 ## on @var{x}.  These must be consistent with the equality and inequality
 ## constraints @var{g} and @var{h}.  If the arguments are vectors then
 ## @var{x}(i) is bound by @var{lb}(i) and @var{ub}(i).  A bound can also
 ## be a scalar in which case all elements of @var{x} will share the same
-## bound.  If only one bound (lb, ub) is specified then the other will 
+## bound.  If only one bound (lb, ub) is specified then the other will
 ## default to (-@var{realmax}, +@var{realmax}).
 ##
 ## The seventh argument specifies the maximum number of iterations.
 ## The default value is 100.
 ##
 ## The eighth argument specifies the tolerance for the stopping criteria.
 ## The default value is @code{sqrt(eps)}.
 ##
 ## The value returned in @var{info} may be one of the following:
 ##
 ## @table @asis
 ## @item 101
-## The algorithm terminated normally.  
+## The algorithm terminated normally.
 ## Either all constraints meet the requested tolerance, or the stepsize,
 ## @tex
 ## $\Delta x,$
 ## @end tex
 ## @ifnottex
 ## delta @var{x},
 ## @end ifnottex
 ## is less than @code{tol * norm (x)}.
-## 
+##
 ## @item 102
 ## The BFGS update failed.
-## 
+##
 ## @item 103
-## The maximum number of iterations was reached. 
+## The maximum number of iterations was reached.
 ## @end table
 ##
 ## An example of calling @code{sqp}:
 ##
 ## @example
 ## function r = g (x)
 ##   r = [ sumsq(x)-10;
-##         x(2)*x(3)-5*x(4)*x(5); 
+##         x(2)*x(3)-5*x(4)*x(5);
 ##         x(1)^3+x(2)^3+1 ];
 ## endfunction
 ##
 ## function obj = phi (x)
 ##   obj = exp(prod(x)) - 0.5*(x(1)^3+x(2)^3+1)^2;
 ## endfunction
 ##
 ## x0 = [-1.8; 1.7; 1.9; -0.8; -0.8];
 ##
 ## [x, obj, info, iter, nf, lambda] = sqp (x0, @@phi, @@g, [])
 ##
 ## x =
-##     
+##
 ##   -1.71714
 ##    1.59571
 ##    1.82725
 ##   -0.76364
 ##   -0.76364
-##      
+##
 ## obj = 0.053950
 ## info = 101
 ## iter = 8
 ## nf = 10
 ## lambda =
-##     
+##
 ##   -0.0401627
 ##    0.0379578
 ##   -0.0052227
 ## @end example
 ##
 ## @seealso{qp}
 ## @end deftypefn
 
@@ -373,17 +373,17 @@ function [x, obj, info, iter, nf, lambda
   ## Seed x with initial guess and evaluate objective function, constraints,
   ## and gradients at initial value x0.
   ##
   ## obj_fun   -- objective function
   ## obj_grad  -- objective gradient
   ## ce_fun    -- equality constraint functions
   ## ci_fun    -- inequality constraint functions
   ## A == [grad_{x_1} cx_fun, grad_{x_2} cx_fun, ..., grad_{x_n} cx_fun]^T
-  x = x0; 
+  x = x0;
 
   obj = feval (obj_fun, x0);
   __sqp_nfun__ = 1;
 
   c = feval (obj_grd, x0);
 
   ## Choose an initial NxN symmetric positive definite Hessian approximation B.
   n = length (x0);
@@ -723,17 +723,17 @@ function res = cigrad_ub_lb (x, bgrad)
 
   global __sqp_cif__
 
   cigradfcn = @fd_ci_jac;
 
   if (iscell (__sqp_cif__) && length (__sqp_cif__) > 1)
     cigradfcn = __sqp_cif__{2};
   endif
-        
+
   if (isempty (cigradfcn))
     res = bgrad;
   else
     res = [feval(cigradfcn,x); bgrad];
   endif
 
 endfunction
 
diff --git a/scripts/path/pathdef.m b/scripts/path/pathdef.m
--- a/scripts/path/pathdef.m
+++ b/scripts/path/pathdef.m
@@ -59,17 +59,17 @@ function val = pathdef ()
     val = site_path;
   else
     val = __pathorig__ ();
   endif
 
 endfunction
 
 ## Extact the path information from the script/function @var{file},
-## created by @file{savepath.m}.  If @var{file} is omitted, 
+## created by @file{savepath.m}.  If @var{file} is omitted,
 ## @file{~/.octaverc} is used.  If successful, @code{__extractpath__}
 ## returns the path specified in @var{file}.
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 
 function specifiedpath = __extractpath__ (savefile)
 
   ## The majority of this code was borrowed from savepath.m.
@@ -128,9 +128,9 @@ function specifiedpath = __extractpath__
     ## Undo doubling of single quote characters performed by savepath.
     specifiedpath = strrep (regexprep (cstrcat (filelines(startline:endline){:}),
                                        " *path *\\('(.*)'\\); *", "$1"),
                             "''", "'");
   else
     specifiedpath = "";
   endif
 
-endfunction  
+endfunction
diff --git a/scripts/path/savepath.m b/scripts/path/savepath.m
--- a/scripts/path/savepath.m
+++ b/scripts/path/savepath.m
@@ -199,16 +199,16 @@ function varargout = savepath (file)
     endif
   end_unwind_protect
 
   retval = 0;
 
   if (nargout == 1)
     varargout{1} = retval;
   endif
-  
-endfunction  
+
+endfunction
 
 function path_elements = parsepath (p)
   pat = sprintf ('([^%s]+[%s$])', pathsep, pathsep);
   [~, ~, ~, path_elements] = regexpi (strcat (p, pathsep), pat);
 endfunction
 
diff --git a/scripts/pkg/pkg.m b/scripts/pkg/pkg.m
--- a/scripts/pkg/pkg.m
+++ b/scripts/pkg/pkg.m
@@ -1,11 +1,11 @@
 ## Copyright (C) 2005-2011 Sren Hauberg
 ## Copyright (C) 2010 VZLU Prague, a.s.
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -35,37 +35,37 @@
 ## @noindent
 ## installs the package found in the file @file{image-1.0.0.tar.gz}.
 ##
 ## The @var{option} variable can contain options that affect the manner
 ## in which a package is installed.  These options can be one or more of
 ##
 ## @table @code
 ## @item -nodeps
-## The package manager will disable the dependency checking.  That way it 
-## is possible to install a package even if it depends on another package 
+## The package manager will disable the dependency checking.  That way it
+## is possible to install a package even if it depends on another package
 ## that's not installed on the system.  @strong{Use this option with care.}
 ##
 ## @item -noauto
-## The package manager will not automatically load the installed package 
+## The package manager will not automatically load the installed package
 ## when starting Octave, even if the package requests that it is.
 ##
 ## @item -auto
-## The package manager will automatically load the installed package when 
+## The package manager will automatically load the installed package when
 ## starting Octave, even if the package requests that it isn't.
 ##
 ## @item -local
 ## A local installation is forced, even if the user has system privileges.
 ##
 ## @item -global
 ## A global installation is forced, even if the user doesn't normally have
 ## system privileges
 ##
 ## @item -verbose
-## The package manager will print the output of all of the commands that are 
+## The package manager will print the output of all of the commands that are
 ## performed.
 ## @end table
 ##
 ## @item uninstall
 ## Uninstall named packages.  For example,
 ##
 ## @example
 ## pkg uninstall image
@@ -199,17 +199,17 @@
 ##
 ## It is possible to get the current value of global_list with the following
 ##
 ## @example
 ## pkg global_list
 ## @end example
 ##
 ## @item rebuild
-## Rebuilds the package database from the installed directories.  This can 
+## Rebuilds the package database from the installed directories.  This can
 ## be used in cases where for some reason the package database is corrupted.
 ## It can also take the @option{-auto} and @option{-noauto} options to allow the
 ## autoloading state of a package to be changed.  For example,
 ##
 ## @example
 ## pkg rebuild -noauto image
 ## @end example
 ##
@@ -223,17 +223,17 @@
 ##
 ## @example
 ## pkg build builddir image-1.0.0.tar.gz @dots{}
 ## @end example
 ##
 ## @noindent
 ## where @code{builddir} is the name of a directory where the temporary
 ## installation will be produced and the binary packages will be found.
-## The options @option{-verbose} and @option{-nodeps} are respected, while 
+## The options @option{-verbose} and @option{-nodeps} are respected, while
 ## the other options are ignored.
 ## @end table
 ## @end deftypefn
 
 function [local_packages, global_packages] = pkg (varargin)
   ## Installation prefix (FIXME: what should these be on windows?)
   persistent user_prefix = false;
   persistent prefix = -1;
@@ -255,17 +255,17 @@ function [local_packages, global_package
       archprefix = prefix;
     endif
     prefix = tilde_expand (prefix);
     archprefix = tilde_expand (archprefix);
   endif
 
   available_actions = {"list", "install", "uninstall", "load", ...
                        "unload", "prefix", "local_list", ...
-                       "global_list", "rebuild", "build","describe"}; 
+                       "global_list", "rebuild", "build","describe"};
   ## Handle input
   if (length (varargin) == 0 || ! iscellstr (varargin))
     print_usage ();
   endif
   files = {};
   deps = true;
   auto = 0;
   action = "none";
@@ -346,28 +346,28 @@ function [local_packages, global_package
           [files, succ] = cellfun (@urlwrite, urls, local_files, "uniformoutput", false);
           succ = [succ{:}];
           if (! all (succ))
             i = find (! succ, 1);
             error ("could not download file %s from url %s", local_files{i}, urls{i});
           endif
         endif
 
-        install (files, deps, auto, prefix, archprefix, verbose, local_list, 
+        install (files, deps, auto, prefix, archprefix, verbose, local_list,
                  global_list, global_install);
 
       unwind_protect_cleanup
         cellfun (@unlink, local_files);
       end_unwind_protect
 
     case "uninstall"
       if (length (files) == 0)
         error ("you must specify at least one package when calling 'pkg uninstall'");
       endif
-      uninstall (files, deps, verbose, local_list, 
+      uninstall (files, deps, verbose, local_list,
                  global_list, global_install);
 
     case "load"
       if (length (files) == 0)
         error ("you must specify at least one package, 'all' or 'auto' when calling 'pkg load'");
       endif
       load_packages (files, deps, local_list, global_list);
 
@@ -435,25 +435,25 @@ function [local_packages, global_package
           global_list = absolute_pathname (files{1});
         end_try_catch
       else
         error ("you must specify a global_list file, or request an output argument");
       endif
 
     case "rebuild"
       if (global_install)
-        global_packages = rebuild (prefix, archprefix, global_list, files, 
+        global_packages = rebuild (prefix, archprefix, global_list, files,
                                    auto, verbose);
         global_packages = save_order (global_packages);
         save (global_list, "global_packages");
         if (nargout > 0)
           local_packages = global_packages;
         endif
       else
-        local_packages = rebuild (prefix, archprefix, local_list, files, auto, 
+        local_packages = rebuild (prefix, archprefix, local_list, files, auto,
                                   verbose);
         local_packages = save_order (local_packages);
         save (local_list, "local_packages");
         if (nargout == 0)
           clear ("local_packages");
         endif
       endif
 
@@ -479,17 +479,17 @@ function [local_packages, global_package
         case 2
           [pkg_desc_list, flag] = describe (files, verbose, local_list, ...
                                             global_list);
           local_packages  = pkg_desc_list;
           global_packages = flag;
         otherwise
           error ("you can request at most two outputs when calling 'pkg describe'");
       endswitch
-                
+
     otherwise
       error ("you must specify a valid action for 'pkg'. See 'help pkg' for details");
   endswitch
 endfunction
 
 function descriptions = rebuild (prefix, archprefix, list, files, auto, verbose)
   if (isempty (files))
     [dirlist, err, msg] = readdir (prefix);
@@ -558,17 +558,17 @@ function descriptions = rebuild (prefix,
         endif
         if (strcmp (descriptions{i}.name, descriptions{j}.name))
           dup = [dup, j];
         endif
       endfor
     endfor
     if (! isempty (dup))
       descriptions (dup) = [];
-    endif  
+    endif
   endif
 endfunction
 
 function build (files, handle_deps, autoload, verbose)
   if (length (files) < 1)
     error ("insufficient number of files");
   endif
   builddir = files{1};
@@ -584,61 +584,61 @@ function build (files, handle_deps, auto
   if (! exist (installdir, "dir"))
     [status, msg] = mkdir (installdir);
     if (status != 1)
       error ("could not create installation directory: %s", msg);
     endif
   endif
   files(1) = [];
   buildlist = fullfile (builddir, "octave_packages");
-  install (files, handle_deps, autoload, installdir, installdir, verbose, 
+  install (files, handle_deps, autoload, installdir, installdir, verbose,
            buildlist, "", false);
   unwind_protect
     repackage (builddir, buildlist);
   unwind_protect_cleanup
     unload_packages ({"all"}, handle_deps, buildlist, "");
     if (exist (installdir, "dir"))
       rm_rf (installdir);
     endif
     if (exist (buildlist, "file"))
       unlink (buildlist);
     endif
   end_unwind_protect
 endfunction
 
-function install (files, handle_deps, autoload, prefix, archprefix, verbose, 
+function install (files, handle_deps, autoload, prefix, archprefix, verbose,
                   local_list, global_list, global_install)
 
   ## Check that the directory in prefix exist. If it doesn't: create it!
   if (! exist (prefix, "dir"))
     warning ("creating installation directory %s", prefix);
     [status, msg] = mkdir (prefix);
     if (status != 1)
       error ("could not create installation directory: %s", msg);
     endif
   endif
 
   ## Get the list of installed packages.
-  [local_packages, global_packages] = installed_packages (local_list, 
+  [local_packages, global_packages] = installed_packages (local_list,
                                                           global_list);
 
-  installed_pkgs_lst = {local_packages{:}, global_packages{:}};        
+  installed_pkgs_lst = {local_packages{:}, global_packages{:}};
 
   if (global_install)
     packages = global_packages;
   else
     packages = local_packages;
   endif
 
   ## Uncompress the packages and read the DESCRIPTION files.
   tmpdirs = packdirs = descriptions = {};
   try
     ## Warn about non existent files.
     for i = 1:length (files)
-      if (isempty (glob(files{i}))) 
+      if (isempty (glob(files{i})))
         warning ("file %s does not exist", files{i});
       endif
     endfor
 
     ## Unpack the package files and read the DESCRIPTION files.
     files = glob (files);
     packages_to_uninstall = [];
     for i = 1:length (files)
@@ -681,42 +681,42 @@ function install (files, handle_deps, au
       if (exist (tgz, "file") || exist (tgz, "dir"))
         ## The two first entries of dirlist are "." and "..".
         if (exist (tgz, "file"))
           packdir = fullfile (tmpdir, dirlist{3});
         else
           packdir = fullfile (pwd(), dirlist{3});
         endif
         packdirs{end+1} = packdir;
-        
+
         ## Make sure the package contains necessary files.
         verify_directory (packdir);
-        
+
         ## Read the DESCRIPTION file.
         filename = fullfile (packdir, "DESCRIPTION");
         desc = get_description (filename);
-        
+
         ## Verify that package name corresponds with filename.
-        [dummy, nm] = fileparts (tgz); 
+        [dummy, nm] = fileparts (tgz);
         if ((length (nm) >= length (desc.name))
             && ! strcmp (desc.name, nm(1:length(desc.name))))
-          error ("package name '%s' doesn't correspond to its filename '%s'", 
+          error ("package name '%s' doesn't correspond to its filename '%s'",
                  desc.name, nm);
         endif
-        
+
         ## Set default installation directory.
         desc.dir = fullfile (prefix, cstrcat (desc.name, "-", desc.version));
-        
+
         ## Set default architectire dependent installation directory.
         desc.archprefix = fullfile (archprefix, cstrcat (desc.name, "-",
                                                          desc.version));
-        
+
         ## Save desc.
         descriptions{end+1} = desc;
-        
+
         ## Are any of the new packages already installed?
         ## If so we'll remove the old version.
         for j = 1:length (packages)
           if (strcmp (packages{j}.name, desc.name))
             packages_to_uninstall(end+1) = j;
           endif
         endfor
       endif
@@ -739,17 +739,17 @@ function install (files, handle_deps, au
       if (global_install)
         ## Global installation is not allowed to have dependencies on locally
         ## installed packages.
         idx1 = setdiff (1:length(global_packages), packages_to_uninstall);
         pseudo_installed_packages = {global_packages{idx1}, ...
                                      descriptions{idx2}};
       else
         idx1 = setdiff (1:length(local_packages), packages_to_uninstall);
-        pseudo_installed_packages = {local_packages{idx1}, ... 
+        pseudo_installed_packages = {local_packages{idx1}, ...
                                      global_packages{:}, ...
                                      descriptions{idx2}};
       endif
       bad_deps = get_unsatisfied_deps (desc, pseudo_installed_packages);
       ## Are there any unsatisfied dependencies?
       if (! isempty (bad_deps))
         ok = false;
         for i = 1:length (bad_deps)
@@ -782,20 +782,20 @@ function install (files, handle_deps, au
     endfor
     rethrow (lasterror ());
   end_try_catch
 
   ## Uninstall the packages that will be replaced.
   try
     for i = packages_to_uninstall
       if (global_install)
-        uninstall ({global_packages{i}.name}, false, verbose, local_list, 
+        uninstall ({global_packages{i}.name}, false, verbose, local_list,
                    global_list, global_install);
       else
-        uninstall ({local_packages{i}.name}, false, verbose, local_list, 
+        uninstall ({local_packages{i}.name}, false, verbose, local_list,
                    global_list, global_install);
       endif
     endfor
   catch
     ## Something went wrong, delete tmpdirs.
     for i = 1:length (tmpdirs)
       rm_rf (tmpdirs{i});
     endfor
@@ -836,17 +836,17 @@ function install (files, handle_deps, au
       descriptions(i) = [];
     endif
   endfor
 
   ## If the package requested that it is autoloaded, or the installer
   ## requested that it is, then mark the package as autoloaded.
   for i = length (descriptions):-1:1
     if (autoload > 0 || (autoload == 0 && isautoload (descriptions(i))))
-      fclose (fopen (fullfile (descriptions{i}.dir, "packinfo", 
+      fclose (fopen (fullfile (descriptions{i}.dir, "packinfo",
                                ".autoload"), "wt"));
       descriptions{i}.autoload = 1;
     endif
   endfor
 
   ## Add the packages to the package list.
   try
     if (global_install)
@@ -899,20 +899,20 @@ function install (files, handle_deps, au
         endfor
       endif
     endfor
     load_packages_and_dependencies (idx, handle_deps, installed_pkgs_lst,
                                     global_install);
   endif
 endfunction
 
-function uninstall (pkgnames, handle_deps, verbose, local_list, 
+function uninstall (pkgnames, handle_deps, verbose, local_list,
                     global_list, global_install)
   ## Get the list of installed packages.
-  [local_packages, global_packages] = installed_packages(local_list, 
+  [local_packages, global_packages] = installed_packages(local_list,
                                                          global_list);
   if (global_install)
     installed_pkgs_lst = {local_packages{:}, global_packages{:}};
   else
     installed_pkgs_lst = local_packages;
   endif
 
   num_packages = length (installed_pkgs_lst);
@@ -1023,23 +1023,23 @@ function uninstall (pkgnames, handle_dep
     else
       local_packages = save_order (remaining_packages);
       save (local_list, "local_packages");
     endif
   endif
 
 endfunction
 
-function [pkg_desc_list, flag] = describe (pkgnames, verbose, 
+function [pkg_desc_list, flag] = describe (pkgnames, verbose,
                                            local_list, global_list)
 
   ## Get the list of installed packages.
   installed_pkgs_lst = installed_packages(local_list, global_list);
   num_packages = length (installed_pkgs_lst);
-  
+
 
   describe_all = false;
   if (any (strcmp ("all", pkgnames)))
     describe_all = true;
     flag(1:num_packages) = {"Not Loaded"};
     num_pkgnames = num_packages;
   else
     num_pkgnames = length (pkgnames);
@@ -1070,63 +1070,63 @@ function [pkg_desc_list, flag] = describ
   endfor
 
   non_inst = find (strcmp (flag, "Not installed"));
   if (! isempty (non_inst))
     if (nargout < 2)
       non_inst_str = sprintf (" %s ", pkgnames{non_inst});
       error ("some packages are not installed: %s", non_inst_str);
     else
-      pkg_desc_list{non_inst} = struct ("name", {}, "description",  
+      pkg_desc_list{non_inst} = struct ("name", {}, "description",
                                         {}, "provides", {});
     endif
   endif
 
   if (nargout == 0)
     for i = 1:num_pkgnames
       print_package_description (pkg_desc_list{i}.name,
                                  pkg_desc_list{i}.version,
-                                 pkg_desc_list{i}.provides,  
+                                 pkg_desc_list{i}.provides,
                                  pkg_desc_list{i}.description,
                                  flag{i}, verbose);
     endfor
   endif
 
 endfunction
 
 ## AUXILIARY FUNCTIONS
 
 ## Read an INDEX file.
 function [pkg_idx_struct] = parse_pkg_idx (packdir)
 
   index_file = fullfile (packdir, "packinfo", "INDEX");
 
   if (! exist (index_file, "file"))
     error ("could not find any INDEX file in directory %s, try 'pkg rebuild all' to generate missing INDEX files", packdir);
-  endif    
+  endif
 
-    
+
   [fid, msg] = fopen (index_file, "r");
   if (fid == -1)
-    error ("the INDEX file %s could not be read: %s", 
+    error ("the INDEX file %s could not be read: %s",
            index_file, msg);
   endif
 
   cat_num = 1;
   pkg_idx_struct{1}.category = "Uncategorized";
   pkg_idx_struct{1}.functions = {};
 
   line = fgetl (fid);
   while (isempty (strfind (line, ">>")) && ! feof (fid))
     line = fgetl (fid);
   endwhile
 
   while (! feof (fid) || line != -1)
     if (! any (! isspace (line)) || line(1) == "#" || any (line == "="))
-      ## Comments,  blank lines or comments about unimplemented 
+      ## Comments,  blank lines or comments about unimplemented
       ## functions: do nothing
       ## FIXME: probably comments and pointers to external functions
       ## could be treated better when printing to screen?
     elseif (! isempty (strfind (line, ">>")))
       ## Skip package name and description as they are in DESCRIPTION
       ## already.
     elseif (! isspace (line(1)))
       ## Category.
@@ -1141,25 +1141,25 @@ function [pkg_idx_struct] = parse_pkg_id
         pkg_idx_struct{cat_num}.functions{end+1} = deblank (fun_name);
       endwhile
     endif
     line = fgetl (fid);
   endwhile
   fclose (fid);
 endfunction
 
-function print_package_description (pkg_name, pkg_ver, pkg_idx_struct, 
+function print_package_description (pkg_name, pkg_ver, pkg_idx_struct,
                                     pkg_desc, status, verbose)
 
   printf ("---\nPackage name:\n\t%s\n", pkg_name);
   printf ("Version:\n\t%s\n", pkg_ver);
   printf ("Short description:\n\t%s\n", pkg_desc);
   printf ("Status:\n\t%s\n", status);
   if (verbose)
-    printf ("---\nProvides:\n");    
+    printf ("---\nProvides:\n");
     for i = 1:length(pkg_idx_struct)
       if (! isempty (pkg_idx_struct{i}.functions))
         printf ("%s\n", pkg_idx_struct{i}.category);
         for j = 1:length(pkg_idx_struct{i}.functions)
           printf ("\t%s\n", pkg_idx_struct{i}.functions{j});
         endfor
       endif
     endfor
@@ -1204,36 +1204,36 @@ function repackage (builddir, buildlist)
       if (exist (archdir, "dir"))
         if (exist (fullfile (pack.name, "inst", "PKG_ADD"), "file"))
           unlink (fullfile (pack.name, "inst", "PKG_ADD"));
         endif
         if (exist (fullfile (pack.name, "inst", "PKG_DEL"), "file"))
           unlink (fullfile (pack.name, "inst", "PKG_DEL"));
         endif
         if (exist (fullfile (archdir, "PKG_ADD"), "file"))
-          movefile (fullfile (archdir, "PKG_ADD"), 
+          movefile (fullfile (archdir, "PKG_ADD"),
                     fullfile (pack.name, "PKG_ADD"));
         endif
         if (exist (fullfile (archdir, "PKG_DEL"), "file"))
-          movefile (fullfile (archdir, "PKG_DEL"), 
-                    fullfile (pack.name, "PKG_DEL")); 
+          movefile (fullfile (archdir, "PKG_DEL"),
+                    fullfile (pack.name, "PKG_DEL"));
         endif
       else
         if (exist (fullfile (pack.name, "inst", "PKG_ADD"), "file"))
-          movefile (fullfile (pack.name, "inst", "PKG_ADD"), 
+          movefile (fullfile (pack.name, "inst", "PKG_ADD"),
                     fullfile (pack.name, "PKG_ADD"));
-        endif 
+        endif
         if (exist (fullfile (pack.name, "inst", "PKG_DEL"), "file"))
-          movefile (fullfile (pack.name, "inst", "PKG_DEL"), 
-                    fullfile (pack.name, "PKG_DEL")); 
-        endif   
-      endif     
+          movefile (fullfile (pack.name, "inst", "PKG_DEL"),
+                    fullfile (pack.name, "PKG_DEL"));
+        endif
+      endif
       tfile = cstrcat (pack.name, "-", pack.version, ".tar");
       tar (tfile, pack.name);
-      try 
+      try
         gzip (tfile);
         unlink (tfile);
       catch
         warning ("failed to compress %s", tfile);
       end_try_catch
     unwind_protect_cleanup
       if (exist (pack.name, "dir"))
         rm_rf (pack.name);
@@ -1258,37 +1258,37 @@ function auto = isautoload (desc)
 endfunction
 
 function prepare_installation (desc, packdir)
   ## Is there a pre_install to call?
   if (exist (fullfile (packdir, "pre_install.m"), "file"))
     wd = pwd ();
     try
       cd (packdir);
-      pre_install (desc); 
+      pre_install (desc);
       cd (wd);
     catch
       cd (wd);
       rethrow (lasterror ());
     end_try_catch
   endif
 
   ## If the directory "inst" doesn't exist, we create it.
   inst_dir = fullfile (packdir, "inst");
   if (! exist (inst_dir, "dir"))
     [status, msg] = mkdir (inst_dir);
     if (status != 1)
       rm_rf (desc.dir);
-      error ("the 'inst' directory did not exist and could not be created: %s", 
+      error ("the 'inst' directory did not exist and could not be created: %s",
              msg);
     endif
   endif
 endfunction
 
-function configure_make (desc, packdir, verbose)   
+function configure_make (desc, packdir, verbose)
   ## Perform ./configure, make, make install in "src".
   if (exist (fullfile (packdir, "src"), "dir"))
     src = fullfile (packdir, "src");
     ## Configure.
     if (exist (fullfile (src, "configure"), "file"))
       flags = "";
       if (isempty (getenv ("CC")))
         flags = cstrcat (flags, " CC=\"", octave_config_info ("CC"), "\"");
@@ -1368,17 +1368,17 @@ function configure_make (desc, packdir, 
     else
       idx = cellfun (@is_architecture_dependent, filenames);
     endif
     archdependent = filenames (idx);
     archindependent = filenames (!idx);
 
     ## Copy the files.
     if (! all (isspace ([filenames{:}])))
-        if (! exist (instdir, "dir")) 
+        if (! exist (instdir, "dir"))
           mkdir (instdir);
         endif
         if (! all (isspace ([archindependent{:}])))
           if (verbose)
             printf ("copyfile");
             printf (" %s", archindependent{:});
             printf ("%s\n", instdir);
           endif
@@ -1389,17 +1389,17 @@ function configure_make (desc, packdir, 
           endif
         endif
         if (! all (isspace ([archdependent{:}])))
           if (verbose)
             printf ("copyfile");
             printf (" %s", archdependent{:});
             printf (" %s\n", archdir);
           endif
-          if (! exist (archdir, "dir")) 
+          if (! exist (archdir, "dir"))
             mkdir (archdir);
           endif
           [status, output] = copyfile (archdependent, archdir);
           if (status != 1)
             rm_rf (desc.dir);
             error ("Couldn't copy files from 'src' to 'inst': %s", output);
           endif
         endif
@@ -1425,18 +1425,18 @@ function pkg = extract_pkg (nm, pat)
     endif
     fclose (fid);
   endif
 endfunction
 
 function create_pkgadddel (desc, packdir, nm, global_install)
   instpkg = fullfile (desc.dir, nm);
   instfid = fopen (instpkg, "wt");
-  ## If it is exists, most of the  PKG_* file should go into the 
-  ## architecture dependent directory so that the autoload/mfilename 
+  ## If it is exists, most of the  PKG_* file should go into the
+  ## architecture dependent directory so that the autoload/mfilename
   ## commands work as expected. The only part that doesn't is the
   ## part in the main directory.
   archdir = fullfile (getarchprefix (desc), cstrcat (desc.name, "-",
                       desc.version), getarch ());
   if (exist (getarchdir (desc, global_install), "dir"))
     archpkg = fullfile (getarchdir (desc, global_install), nm);
     archfid = fopen (archpkg, "at");
   else
@@ -1492,17 +1492,17 @@ function create_pkgadddel (desc, packdir
   endif
 endfunction
 
 function copy_files (desc, packdir, global_install)
   ## Create the installation directory.
   if (! exist (desc.dir, "dir"))
     [status, output] = mkdir (desc.dir);
     if (status != 1)
-      error ("couldn't create installation directory %s : %s", 
+      error ("couldn't create installation directory %s : %s",
       desc.dir, output);
     endif
   endif
 
   octfiledir = getarchdir (desc);
 
   ## Copy the files from "inst" to installdir.
   instdir = fullfile (packdir, "inst");
@@ -1520,42 +1520,42 @@ function copy_files (desc, packdir, glob
         if (! exist (octm1, "dir"))
           octm2 = fileparts (octm1);
           if (! exist (octm2, "dir"))
             octm3 = fileparts (octm2);
             if (! exist (octm3, "dir"))
               [status, output] = mkdir (octm3);
               if (status != 1)
                 rm_rf (desc.dir);
-                error ("couldn't create installation directory %s : %s", 
+                error ("couldn't create installation directory %s : %s",
                        octm3, output);
               endif
             endif
             [status, output] = mkdir (octm2);
             if (status != 1)
               rm_rf (desc.dir);
-              error ("couldn't create installation directory %s : %s", 
+              error ("couldn't create installation directory %s : %s",
                      octm2, output);
             endif
           endif
           [status, output] = mkdir (octm1);
           if (status != 1)
             rm_rf (desc.dir);
-            error ("couldn't create installation directory %s : %s", 
+            error ("couldn't create installation directory %s : %s",
                    octm1, output);
           endif
         endif
         [status, output] = mkdir (octfiledir);
         if (status != 1)
           rm_rf (desc.dir);
-          error ("couldn't create installation directory %s : %s", 
+          error ("couldn't create installation directory %s : %s",
           octfiledir, output);
         endif
       endif
-      [status, output] = movefile (fullfile (desc.dir, getarch (), "*"), 
+      [status, output] = movefile (fullfile (desc.dir, getarch (), "*"),
                                    octfiledir);
       rm_rf (fullfile (desc.dir, getarch ()));
 
       if (status != 1)
         rm_rf (desc.dir);
         rm_rf (octfiledir);
         error ("couldn't copy files to the installation directory");
       endif
@@ -1780,17 +1780,17 @@ function deps_cell = fix_depends (depend
       endif
       operator = parts{1};
       if (! any (strcmp (operator, {">", ">=", "<=", "<", "=="})))
         error ("unsupported operator: %s", operator);
       endif
       version  = fix_version (parts{2});
 
   ## If no version is specified for the dependency
-  ## we say that the version should be greater than 
+  ## we say that the version should be greater than
   ## or equal to "0.0.0".
   else
     package = tolower (strip (dep));
     operator = ">=";
     version  = "0.0.0";
   endif
   deps_cell{i} = struct ("package", package, "operator", operator,
                          "version", version);
@@ -1844,28 +1844,28 @@ function write_index (desc, dir, index_f
     class_name = files {class_idx (k)};
     class_dir = fullfile (dir, class_name);
     if (exist (class_dir, "dir"))
       [files2, err, msg] = readdir (class_dir);
       if (err)
         error ("couldn't read directory %s: %s", class_dir, msg);
       endif
       files2 = strcat (class_name, filesep (), files2);
-      files = [files; files2];    
+      files = [files; files2];
     endif
   endfor
 
   ## Check for architecture dependent files.
   tmpdir = getarchdir (desc);
   if (exist (tmpdir, "dir"))
     [files2, err, msg] = readdir (tmpdir);
     if (err)
       error ("couldn't read directory %s: %s", tmpdir, msg);
     endif
-    files = [files; files2];    
+    files = [files; files2];
   endif
 
   functions = {};
   for i = 1:length (files)
     file = files{i};
     lf = length (file);
     if (lf > 2 && strcmp (file(end-1:end), ".m"))
       functions{end+1} = file(1:end-2);
@@ -1952,17 +1952,17 @@ function [out1, out2] = installed_packag
       endif
       if (strcmp (installed_pkgs_lst{i}.name, installed_pkgs_lst{j}.name))
         dup = [dup, j];
       endif
     endfor
   endfor
   if (! isempty(dup))
     installed_pkgs_lst(dup) = [];
-  endif  
+  endif
 
   ## Now check if the package is loaded.
   tmppath = strrep (path(), "\\", "/");
   for i = 1:length (installed_pkgs_lst)
     if (findstr (tmppath, strrep (installed_pkgs_lst{i}.dir, "\\", "/")))
       installed_pkgs_lst{i}.loaded = true;
     else
       installed_pkgs_lst{i}.loaded = false;
@@ -1999,19 +1999,19 @@ function [out1, out2] = installed_packag
     printf ("no packages installed.\n");
     return;
   endif
 
   ## Compute the maximal lengths of name, version, and dir.
   h1 = "Package Name";
   h2 = "Version";
   h3 = "Installation directory";
-  max_name_length = length (h1); 
+  max_name_length = length (h1);
   max_version_length = length (h2);
-  names = cell (num_packages, 1); 
+  names = cell (num_packages, 1);
   for i = 1:num_packages
     max_name_length = max (max_name_length,
                            length (installed_pkgs_lst{i}.name));
     max_version_length = max (max_version_length,
                               length (installed_pkgs_lst{i}.version));
     names{i} = installed_pkgs_lst{i}.name;
   endfor
   max_dir_length = terminal_size()(2) - max_name_length - ...
@@ -2038,17 +2038,17 @@ function [out1, out2] = installed_packag
   for i = 1:num_packages
     cur_name = installed_pkgs_lst{idx(i)}.name;
     cur_version = installed_pkgs_lst{idx(i)}.version;
     cur_dir = installed_pkgs_lst{idx(i)}.dir;
     if (length (cur_dir) > max_dir_length)
       first_char = length (cur_dir) - max_dir_length + 4;
       first_filesep = strfind (cur_dir(first_char:end), filesep());
       if (! isempty (first_filesep))
-        cur_dir = cstrcat ("...", 
+        cur_dir = cstrcat ("...",
                           cur_dir((first_char + first_filesep(1) - 1):end));
       else
         cur_dir = cstrcat ("...", cur_dir(first_char:end));
       endif
     endif
     if (installed_pkgs_lst{idx(i)}.loaded)
       cur_loaded = "*";
     else
@@ -2068,17 +2068,17 @@ function load_packages (files, handle_de
     pnames{i} = installed_pkgs_lst{i}.name;
     pdirs{i} = installed_pkgs_lst{i}.dir;
   endfor
 
   ## Load all.
   if (length (files) == 1 && strcmp (files{1}, "all"))
     idx = [1:length(installed_pkgs_lst)];
   ## Load auto.
-  elseif (length (files) == 1 && strcmp (files{1}, "auto")) 
+  elseif (length (files) == 1 && strcmp (files{1}, "auto"))
     idx = [];
     for i = 1:length (installed_pkgs_lst)
       if (exist (fullfile (pdirs{i}, "packinfo", ".autoload"), "file"))
         idx (end + 1) = i;
       endif
     endfor
   ## Load package_name1 ...
   else
@@ -2204,17 +2204,17 @@ endfunction
 function arch = getarch ()
   persistent _arch = cstrcat (octave_config_info("canonical_host_type"), ...
                              "-", octave_config_info("api_version"));
   arch = _arch;
 endfunction
 
 function archprefix = getarchprefix (desc, global_install)
   if ((nargin == 2 && global_install) || (nargin < 2 && issuperuser ()))
-    archprefix = fullfile (octave_config_info ("libexecdir"), "octave", 
+    archprefix = fullfile (octave_config_info ("libexecdir"), "octave",
                            "packages", cstrcat(desc.name, "-", desc.version));
   else
     archprefix = desc.dir;
   endif
 endfunction
 
 function archdir = getarchdir (desc)
   archdir = fullfile (desc.archprefix, getarch());
@@ -2262,17 +2262,17 @@ function newdesc = save_order (desc)
       for k = 1 : length (deps)
         for j = 1 : length (desc)
           if (strcmp (desc{j}.name, deps{k}.package))
             tmpdesc{end+1} = desc{j};
             break;
           endif
         endfor
       endfor
-      if (! isempty (tmpdesc))                                       
+      if (! isempty (tmpdesc))
         newdesc = {newdesc{:}, save_order(tmpdesc){:}, desc{i}};
       else
         newdesc{end+1} = desc{i};
       endif
     endif
   endfor
   ## Eliminate the duplicates.
   idx = [];
@@ -2331,17 +2331,17 @@ function idx = load_package_dirs (lidx, 
           for k = 1 : length (deps)
             for j = 1 : length (installed_pkgs_lst)
               if (strcmp (installed_pkgs_lst{j}.name, deps{k}.package))
                 tmplidx (end + 1) = j;
                 break;
               endif
             endfor
           endfor
-          idx = load_package_dirs (tmplidx, idx, handle_deps, 
+          idx = load_package_dirs (tmplidx, idx, handle_deps,
                                  installed_pkgs_lst);
         endif
       endif
       if (isempty (find(idx == i)))
         idx (end + 1) = i;
       endif
     endif
   endfor
diff --git a/scripts/plot/__fltk_ginput__.m b/scripts/plot/__fltk_ginput__.m
--- a/scripts/plot/__fltk_ginput__.m
+++ b/scripts/plot/__fltk_ginput__.m
@@ -34,29 +34,29 @@ function [x, y, button] = __fltk_ginput_
 
   unwind_protect
 
     orig_windowbuttondownfcn = get (f, "windowbuttondownfcn");
     set (f, "windowbuttondownfcn", @ginput_windowbuttondownfcn);
 
     orig_ginput_keypressfcn = get (f, "keypressfcn");
     set (f, "keypressfcn", @ginput_keypressfcn);
-    
+
     while (true)
       __fltk_redraw__ ();
-      
+
       ## release CPU
       sleep (0.01);
 
       [x, y, n0] = ginput_aggregator (-1, 0, 0);
       if (n0 == n || n0 < 0)
         break;
       endif
     endwhile
-    
+
     ## FIXME -- got to get the buttons somehow
     button = ones (size (x));
   unwind_protect_cleanup
     set (f, "windowbuttondownfcn", orig_windowbuttondownfcn);
     set (f, "keypressfcn", orig_ginput_keypressfcn);
   end_unwind_protect
 
 endfunction
diff --git a/scripts/plot/__gnuplot_ginput__.m b/scripts/plot/__gnuplot_ginput__.m
--- a/scripts/plot/__gnuplot_ginput__.m
+++ b/scripts/plot/__gnuplot_ginput__.m
@@ -122,22 +122,22 @@ function [x, y, button] = __gnuplot_ginp
 
       if ([x(k), y(k), button(k)] == [0, 0, -1])
         ## Mousing not active (no plot yet).
         break;
       endif
 
       if (nargin > 1)
         ## Input argument n was given => stop when k == n.
-        if (k == n) 
-          break; 
+        if (k == n)
+          break;
         endif
       else
         ## Input argument n not given => stop when hitting a return key.
-        ## if (button(k) == 0x0D || button(k) == 0x0A) 
+        ## if (button(k) == 0x0D || button(k) == 0x0A)
         ##   ## hit Return or Enter
         if (button(k) == 0x0D)
           ## hit Return
           x(k:end) = [];
           y(k:end) = [];
           button(k:end) = [];
           break;
         endif
diff --git a/scripts/plot/__gnuplot_has_feature__.m b/scripts/plot/__gnuplot_has_feature__.m
--- a/scripts/plot/__gnuplot_has_feature__.m
+++ b/scripts/plot/__gnuplot_has_feature__.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2009-2011 Ben Abbott
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
diff --git a/scripts/plot/__gnuplot_open_stream__.m b/scripts/plot/__gnuplot_open_stream__.m
--- a/scripts/plot/__gnuplot_open_stream__.m
+++ b/scripts/plot/__gnuplot_open_stream__.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2009-2011 Ben Abbott
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
diff --git a/scripts/plot/__gnuplot_print__.m b/scripts/plot/__gnuplot_print__.m
--- a/scripts/plot/__gnuplot_print__.m
+++ b/scripts/plot/__gnuplot_print__.m
@@ -110,17 +110,17 @@ function opts = __gnuplot_print__ (opts)
     endif
   case {"canvas", "dxf", "hpgl", "mf", "gif", "pstricks", "texdraw"}
     local_drawnow (sprintf ("%s %s", opts.devopt, gp_opts), opts.name, opts)
   case opts.ghostscript.device
     gp_opts = font_spec (opts, "devopt", "eps");
     opts.ghostscript.output = opts.name;
     opts.ghostscript.source = strcat (tmpnam (), ".eps");
     eps_drawnow (opts, opts.ghostscript.source, gp_opts);
-    [cmd_gs, cmd_cleanup] = __ghostscript__ (opts.ghostscript); 
+    [cmd_gs, cmd_cleanup] = __ghostscript__ (opts.ghostscript);
     if (opts.send_to_printer || isempty (opts.name))
       cmd_lpr = opts.lpr_cmd (opts);
       cmd = sprintf ("%s | %s", cmd_gs, cmd_lpr);
     else
       cmd = sprintf ("%s", cmd_gs);
     endif
     if (dos_shell)
       cmd = sprintf ("%s & del %s", cmd, strrep (opts.ghostscript.source, '/', '\'));
@@ -146,17 +146,17 @@ function opts = __gnuplot_print__ (opts)
   opts.pipeline = pipeline;
 
   for n = 1:numel(pipeline)
     if (opts.debug)
       fprintf ("gnuplot-pipeline: '%s'\n", pipeline{n})
     endif
     [status, output] = system (pipeline{n});
     if (status)
-      fprintf ("%s\n%s\n%s\n", 
+      fprintf ("%s\n%s\n%s\n",
                "---------- output begin ----------",
                output,
                "----------- output end -----------");
       error ("gnuplot:failedpipe", "print: Failed to print.")
     endif
   endfor
 
 endfunction
@@ -199,17 +199,17 @@ function f = font_spec (opts, varargin)
     if (! isempty (opts.font) && ! isempty (opts.fontsize))
       f = sprintf ("font ""%s,%d""", opts.font, opts.fontsize);
     elseif (! isempty (opts.font))
       f = sprintf ("font ""%s""", opts.font);
     elseif (! isempty (opts.fontsize))
       f = sprintf ("%d", opts.fontsize);
     endif
   case {"eps", "eps2", "epsc", "epsc2"}
-    ## Gnuplot renders fonts as half their specification, which 
+    ## Gnuplot renders fonts as half their specification, which
     ## results in a tight spacing for the axes-labels and tick-labels.
     ## Compensate for the half scale. This will produce the proper
     ## spacing for the requested fontsize.
     if (! isempty (opts.font) && ! isempty (opts.fontsize))
       f = sprintf ("font ""%s,%d""", opts.font, 2 * opts.fontsize);
     elseif (! isempty (opts.font))
       f = sprintf ("font ""%s""", opts.font);
     elseif (! isempty (opts.fontsize))
diff --git a/scripts/plot/__go_draw_axes__.m b/scripts/plot/__go_draw_axes__.m
--- a/scripts/plot/__go_draw_axes__.m
+++ b/scripts/plot/__go_draw_axes__.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} __go_draw_axes__ (@var{h}, @var{plot_stream}, @var{enhanced}, @var{mono})
 ## Undocumented internal function.
 ## @end deftypefn
 
 ## Author: jwe
 
-function __go_draw_axes__ (h, plot_stream, enhanced, mono, 
+function __go_draw_axes__ (h, plot_stream, enhanced, mono,
                            bg_is_set, fg_is_set, hlgnd)
 
   if (nargin >= 4 && nargin <= 7)
 
     showhiddenhandles = get (0, "showhiddenhandles");
     unwind_protect
       set (0, "showhiddenhandles", "on");
       axis_obj = __get__ (h);
@@ -43,17 +43,17 @@ function __go_draw_axes__ (h, plot_strea
     if (strcmp (axis_obj.tag, "plotyy"))
       ymirror = false;
     else
       ymirror = true;
     endif
 
     nd = __calc_dimensions__ (h);
 
-    if (strcmp (axis_obj.dataaspectratiomode, "manual") 
+    if (strcmp (axis_obj.dataaspectratiomode, "manual")
         && strcmp (axis_obj.xlimmode, "manual")
         && strcmp (axis_obj.ylimmode, "manual"))
       ## All can't be "manual"
       axis_obj.plotboxaspectratiomode = "auto";
     endif
 
     if (strcmp (axis_obj.dataaspectratiomode, "manual")
         && strcmp (axis_obj.xlimmode, "manual")
@@ -101,19 +101,19 @@ function __go_draw_axes__ (h, plot_strea
         fprintf (plot_stream, "set lmargin 0;\n");
         fprintf (plot_stream, "set rmargin 0;\n");
 
         if (nd == 3 && all (axis_obj.view == [0, 90]))
           ## FIXME -- Kludge to allow colorbar to be added to a pcolor() plot
           pos(3:4) = pos(3:4) * 1.4;
           pos(1:2) = pos(1:2) - pos(3:4) * 0.125;
         endif
-  
+
         fprintf (plot_stream, "set origin %.15g, %.15g;\n", pos(1), pos(2));
-  
+
         if (strcmpi (axis_obj.dataaspectratiomode, "manual"))
           sz_str = sprintf ("set size ratio %.15g", -dr);
         else
           sz_str = "set size noratio";
         endif
         sz_str = sprintf ("%s %.15g, %.15g;\n", sz_str, pos(3), pos(4));
       endif
     else ## activepositionproperty == outerposition
@@ -520,37 +520,37 @@ function __go_draw_axes__ (h, plot_strea
           else
             xdat = obj.xdata(:);
             ydat = obj.ydata(:);
             data{data_idx} = [xdat, ydat]';
             usingclause{data_idx} = sprintf ("record=%d using ($1):($2) axes %s%s",
                                             rows(xdat), xaxisloc_using, yaxisloc_using);
           endif
 
-          style = do_linestyle_command (obj, obj.color, data_idx, mono, 
+          style = do_linestyle_command (obj, obj.color, data_idx, mono,
                                         plot_stream, errbars);
 
           withclause{data_idx} = sprintf ("with %s linestyle %d",
                                           style{1}, data_idx);
 
           if (length (style) > 1)
             data_idx++;
-            is_image_data(data_idx) = is_image_data(data_idx - 1); 
+            is_image_data(data_idx) = is_image_data(data_idx - 1);
             parametric(data_idx) = parametric(data_idx - 1);
             have_cdata(data_idx) = have_cdata(data_idx - 1);
             have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
             titlespec{data_idx} = "title \"\"";
             usingclause{data_idx} = usingclause{data_idx - 1};
             data{data_idx} = data{data_idx - 1};
             withclause{data_idx} = sprintf ("with %s linestyle %d",
                                           style{2}, data_idx);
           endif
           if (length (style) > 2)
             data_idx++;
-            is_image_data(data_idx) = is_image_data(data_idx - 1); 
+            is_image_data(data_idx) = is_image_data(data_idx - 1);
             parametric(data_idx) = parametric(data_idx - 1);
             have_cdata(data_idx) = have_cdata(data_idx - 1);
             have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
             titlespec{data_idx} = "title \"\"";
             usingclause{data_idx} = usingclause{data_idx - 1};
             data{data_idx} = data{data_idx - 1};
             withclause{data_idx} = sprintf ("with %s linestyle %d",
                                           style{3}, data_idx);
@@ -578,30 +578,30 @@ function __go_draw_axes__ (h, plot_strea
                zcol = obj.zdata(:,i);
              else
                zcol = zeros (size (xcol));
              endif
            endif
 
            if (! isnan (xcol) && ! isnan (ycol))
              ## Is the patch closed or not
-             if (strncmp (obj.facecolor, "none", 4)) 
+             if (strncmp (obj.facecolor, "none", 4))
                hidden_removal = false;
              else
 
                if (isnan (hidden_removal))
                  hidden_removal = true;
                endif
                if (nd == 3)
                  if (numel (xcol) > 3)
                    error ("__go_draw_axes__: gnuplot (as of v4.2) only supports 3D filled triangular patches");
                  else
                    if (isnan (data_3d_idx))
                      data_idx++;
-                     data_3d_idx = data_idx; 
+                     data_3d_idx = data_idx;
                      is_image_data(data_idx) = false;
                      parametric(data_idx) = false;
                      have_cdata(data_idx) = true;
                      have_3d_patch(data_idx) = true;
                      withclause{data_3d_idx} = sprintf ("with pm3d");
                      usingclause{data_3d_idx} =  "using 1:2:3:4";
                      data{data_3d_idx} = [];
                    endif
@@ -652,17 +652,17 @@ function __go_draw_axes__ (h, plot_strea
                                       * (ccol - clim(1))/(clim(2) - clim(1)));
                        r = max (1, min (r, size (cmap, 1)));
                        color = cmap(r, :);
                      endif
                    elseif (strncmp (obj.facecolor, "interp", 6))
                      if (nd == 3 && numel (xcol) == 3)
                        ccdat = ccol;
                        if (! isvector (ccdat))
-                         tmp = rows(cmap) + rows(addedcmap) + ... 
+                         tmp = rows(cmap) + rows(addedcmap) + ...
                               [1 : rows(ccdat)];
                          addedcmap = [addedcmap; ccdat];
                          ccdat = tmp(:);
                        else
                          ccdat = ccdat(:);
                        endif
                      else
                        warning ("\"interp\" not supported, using 1st entry of cdata");
@@ -706,17 +706,17 @@ function __go_draw_axes__ (h, plot_strea
                  usingclause{data_idx} = sprintf ("record=%d using ($1):($2)",
                                                   numel (xcol));
                endif
              endif
            endif
 
            ## patch outline
            if (!(strncmp (obj.edgecolor, "none", 4)
-                  && (strncmp (obj.marker, "none", 4) 
+                  && (strncmp (obj.marker, "none", 4)
                       || (strncmp (obj.markeredgecolor, "none", 4)
                           && strncmp (obj.markerfacecolor, "none", 4)))))
 
              data_idx++;
              is_image_data(data_idx) = false;
              parametric(data_idx) = false;
              have_cdata(data_idx) = false;
              have_3d_patch(data_idx) = false;
@@ -841,42 +841,42 @@ function __go_draw_axes__ (h, plot_strea
              if (isempty (lt))
                style = "";
              else
                style = "lines";
              endif
              tmpwith = {};
 
              facesame = true;
-             if (! isequal (pt, pt2) && isfield (obj, "markerfacecolor") 
+             if (! isequal (pt, pt2) && isfield (obj, "markerfacecolor")
                  && !strncmp (obj.markerfacecolor, "none", 4))
                if (strncmp (obj.markerfacecolor, "auto", 4)
-                   || ! isnumeric (obj.markerfacecolor) 
-                   || (isnumeric (obj.markerfacecolor) 
+                   || ! isnumeric (obj.markerfacecolor)
+                   || (isnumeric (obj.markerfacecolor)
                        && isequal (color, obj.markerfacecolor)))
                  style = strcat (style, "points");
                  if (isfield (obj, "markersize"))
                    if (length (mdat) == nc)
                      m = mdat(i);
                    else
                      m = mdat;
                    endif
                    ps = sprintf("pointsize %f", m / 3);
                  else
                    ps = "";
                  endif
 
                  tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
-                                          style, lw, pt2, lt, ps, 
+                                          style, lw, pt2, lt, ps,
                                           colorspec);
                else
                  facesame = false;
-                 if (! isempty (style)) 
+                 if (! isempty (style))
                    tmpwith{sidx} = sprintf ("with %s %s %s %s",
-                                            style, lw, lt, 
+                                            style, lw, lt,
                                             colorspec);
                    sidx ++;
                  endif
                  if (isnumeric (obj.markerfacecolor) && ! mono)
                    colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
                                         round (255*obj.markerfacecolor));
                  endif
                  style = "points";
@@ -886,57 +886,57 @@ function __go_draw_axes__ (h, plot_strea
                    else
                      m = mdat;
                    endif
                    ps = sprintf("pointsize %f", m / 3);
                  else
                    ps = "";
                  endif
                  tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
-                                          style, lw, pt2, lt, ps, 
+                                          style, lw, pt2, lt, ps,
                                           colorspec);
                endif
              endif
 
-             if (isfield (obj, "markeredgecolor") 
+             if (isfield (obj, "markeredgecolor")
                  && !strncmp (obj.markeredgecolor, "none", 4))
-               if (facesame && !isempty (pt) 
+               if (facesame && !isempty (pt)
                    && (strncmp (obj.markeredgecolor, "auto", 4)
-                       || ! isnumeric (obj.markeredgecolor) 
-                       || (isnumeric (obj.markeredgecolor) 
+                       || ! isnumeric (obj.markeredgecolor)
+                       || (isnumeric (obj.markeredgecolor)
                            && isequal (color, obj.markeredgecolor))))
-                 if (sidx == 1 && ((length (style) == 5 
-                          && strncmp (style, "lines", 5)) 
+                 if (sidx == 1 && ((length (style) == 5
+                          && strncmp (style, "lines", 5))
                          || isempty (style)))
                    style = strcat (style, "points");
                    if (isfield (obj, "markersize"))
                      if (length (mdat) == nc)
                        m = mdat(i);
                      else
                        m = mdat;
                      endif
                      ps = sprintf("pointsize %f", m / 3);
                    else
                      ps = "";
                    endif
                    tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
-                                            style, lw, pt, lt, ps, 
+                                            style, lw, pt, lt, ps,
                                             colorspec);
                  endif
                else
-                 if (!isempty (style))  
+                 if (!isempty (style))
                    if (length(tmpwith) < sidx || isempty (tmpwith{sidx}))
                      tmpwith{sidx} = sprintf ("with %s %s %s %s",
-                                              style, lw, lt, 
+                                              style, lw, lt,
                                               colorspec);
                    endif
                    sidx ++;
                  endif
 
-                 if (!isempty (pt)) 
+                 if (!isempty (pt))
                    if (! mono)
                      if (strncmp (obj.markeredgecolor, "auto", 4))
                        colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
                                             round (255*color));
                      elseif (isnumeric (obj.markeredgecolor) && ! mono)
                        colorspec = sprintf ("lc rgb \"#%02x%02x%02x\"",
                                             round (255*obj.markeredgecolor));
                      endif
@@ -948,25 +948,25 @@ function __go_draw_axes__ (h, plot_strea
                      else
                        m = mdat;
                      endif
                      ps = sprintf("pointsize %f", m / 3);
                    else
                      ps = "";
                    endif
                    tmpwith{sidx} = sprintf ("with %s %s %s %s %s %s",
-                                            style, lw, pt, lt, ps, 
+                                            style, lw, pt, lt, ps,
                                             colorspec);
                  endif
                endif
              endif
 
              if (isempty (tmpwith))
                withclause{data_idx} = sprintf ("with %s %s %s %s %s",
-                                               style, lw, pt, lt, 
+                                               style, lw, pt, lt,
                                                colorspec);
              else
                withclause{data_idx} = tmpwith{1};
              endif
              if (nd == 3)
                if (ischar (color))
                  if (! isnan (xcol) && ! isnan (ycol) && ! isnan (zcol))
                    data{data_idx} = [[xcol; xcol(1)], [ycol; ycol(1)], ...
@@ -1000,28 +1000,28 @@ function __go_draw_axes__ (h, plot_strea
                    data{data_idx} = [xcol, ycol]';
                  endif
                  usingclause{data_idx} = sprintf ("record=%d using ($1):($2)", columns (data{data_idx}));
                endif
              endif
 
              if (length (tmpwith) > 1)
                data_idx++;
-               is_image_data(data_idx) = is_image_data(data_idx - 1); 
+               is_image_data(data_idx) = is_image_data(data_idx - 1);
                parametric(data_idx) = parametric(data_idx - 1);
                have_cdata(data_idx) = have_cdata(data_idx - 1);
                have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
                titlespec{data_idx} = "title \"\"";
                usingclause{data_idx} = usingclause{data_idx - 1};
                data{data_idx} = data{data_idx - 1};
                withclause{data_idx} = tmpwith{2};
              endif
              if (length (tmpwith) > 2)
                data_idx++;
-               is_image_data(data_idx) = is_image_data(data_idx - 1); 
+               is_image_data(data_idx) = is_image_data(data_idx - 1);
                parametric(data_idx) = parametric(data_idx - 1);
                have_cdata(data_idx) = have_cdata(data_idx - 1);
                have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
                titlespec{data_idx} = "title \"\"";
                usingclause{data_idx} = usingclause{data_idx - 1};
                data{data_idx} = data{data_idx - 1};
                withclause{data_idx} = tmpwith{3};
              endif
@@ -1033,17 +1033,17 @@ function __go_draw_axes__ (h, plot_strea
           if (! (strncmp (obj.edgecolor, "none", 4)
                  && strncmp (obj.facecolor, "none", 4)))
             data_idx++;
             is_image_data(data_idx) = false;
             parametric(data_idx) = false;
             have_cdata(data_idx) = true;
             have_3d_patch(data_idx) = false;
             style = do_linestyle_command (obj, obj.edgecolor,
-                                          data_idx, mono, 
+                                          data_idx, mono,
                                           plot_stream);
 
             if (isempty (obj.displayname))
               titlespec{data_idx} = "title \"\"";
             else
               tmp = undo_string_escapes (__maybe_munge_text__ (enhanced, obj, "displayname"));
               titlespec{data_idx} = cstrcat ("title \"", tmp, "\"");
             endif
@@ -1122,82 +1122,82 @@ function __go_draw_axes__ (h, plot_strea
               endif
             elseif (facecolor_none_or_white)
               if (all (obj.facecolor == 1))
                 hidden_removal = true;
               endif
               fputs(plot_stream,"unset pm3d;\n");
               fputs(plot_stream,"set style increment user;\n");
               withpm3d = false;
-              withclause{data_idx} = sprintf("with %s linestyle %d", 
+              withclause{data_idx} = sprintf("with %s linestyle %d",
                                              style{1}, data_idx);
               fputs (plot_stream, "unset pm3d\n");
             endif
 
             if (doing_interp_color)
               ## "depthorder" interferes with interpolation of colors.
               dord = "scansautomatic";
             else
               dord = "depthorder";
             endif
 
             if (flat_interp_face && strncmp (obj.edgecolor, "flat", 4))
-              fprintf (plot_stream, "set pm3d explicit at s %s %s corners2color c3;\n", 
+              fprintf (plot_stream, "set pm3d explicit at s %s %s corners2color c3;\n",
                        interp_str, dord);
             elseif (!facecolor_none_or_white)
               if (strncmp (obj.edgecolor, "none", 4))
-                if (__gnuplot_has_feature__ ("transparent_surface") 
+                if (__gnuplot_has_feature__ ("transparent_surface")
                     && isscalar (obj.facealpha))
                   fprintf (plot_stream,
                            "set style fill transparent solid %f;\n",
                            obj.facealpha);
                 endif
-                fprintf (plot_stream, "set pm3d explicit at s %s corners2color c3;\n", 
+                fprintf (plot_stream, "set pm3d explicit at s %s corners2color c3;\n",
                          interp_str, dord);
               else
-                fprintf (plot_stream, "set pm3d explicit at s hidden3d %d %s %s corners2color c3;\n", 
+                fprintf (plot_stream, "set pm3d explicit at s hidden3d %d %s %s corners2color c3;\n",
                          data_idx, interp_str, dord);
 
-                if (__gnuplot_has_feature__ ("transparent_surface") 
+                if (__gnuplot_has_feature__ ("transparent_surface")
                     && isscalar (obj.facealpha))
                   fprintf (plot_stream,
                            "set style fill transparent solid %f;\n",
                            obj.facealpha);
                 endif
               endif
             endif
-            
+
             zz = [];
             if (length (style) > 1)
               len = 3 * xlen;
               zz = zeros (ylen, len);
               k = 1;
               for kk = 1:3:len
                 zz(:,kk)   = xdat(:,k);
                 zz(:,kk+1) = ydat(:,k);
                 zz(:,kk+2) = zdat(:,k);
                 k++;
               endfor
               zz = zz.';
 
               data_idx++;
-              is_image_data(data_idx) = is_image_data(data_idx - 1); 
+              is_image_data(data_idx) = is_image_data(data_idx - 1);
               parametric(data_idx) = parametric(data_idx - 1);
               have_cdata(data_idx) = false;
               have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
               titlespec{data_idx} = "title \"\"";
               usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
               data{data_idx} = zz;
               withclause{data_idx} = sprintf ("with %s linestyle %d",
                                               style{2}, data_idx);
 
             endif
             if (length (style) > 2)
               data_idx++;
-              is_image_data(data_idx) = is_image_data(data_idx - 1); 
+              is_image_data(data_idx) = is_image_data(data_idx - 1);
               parametric(data_idx) = parametric(data_idx - 1);
               have_cdata(data_idx) = false;
               have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
               titlespec{data_idx} = "title \"\"";
               usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
               data{data_idx} = zz;
               withclause{data_idx} = sprintf ("with %s linestyle %d",
                                               style{3}, data_idx);
@@ -1211,17 +1211,17 @@ function __go_draw_axes__ (h, plot_strea
                   zz(:,kk)   = xdat(:,k);
                   zz(:,kk+1) = ydat(:,k);
                   zz(:,kk+2) = zdat(:,k);
                   k++;
                 endfor
                 zz = zz.';
               endif
               data_idx++;
-              is_image_data(data_idx) = is_image_data(data_idx - 1); 
+              is_image_data(data_idx) = is_image_data(data_idx - 1);
               parametric(data_idx) = parametric(data_idx - 1);
               have_cdata(data_idx) = false;
               have_3d_patch(data_idx) = have_3d_patch(data_idx - 1);
               titlespec{data_idx} = "title \"\"";
               usingclause{data_idx} = sprintf ("record=%dx%d using ($1):($2):($3)", ylen, xlen);
               data{data_idx} = zz;
               withclause{data_idx} = sprintf ("with points linestyle %d",
                                               pm3didx);
@@ -1240,17 +1240,17 @@ function __go_draw_axes__ (h, plot_strea
           if (strcmpi (units, "normalized"))
             units = "graph";
           elseif (strcmp (axis_obj.yaxislocation, "right")
                   && strcmp (units, "data"))
             units = "second";
           else
             units = "";
           endif
-          
+
           if (isnumeric (color))
             colorspec = get_text_colorspec (color, mono);
           endif
 
           switch valign
             ## Text offset in characters. This relies on gnuplot for font metrics.
             case "top"
               dy = -0.5;
@@ -1349,33 +1349,33 @@ function __go_draw_axes__ (h, plot_strea
       if (strcmpi (axis_obj.zdir, "reverse"))
         zdir = "reverse";
       else
         zdir = "noreverse";
       endif
       fprintf (plot_stream, "set zrange [%.15e:%.15e] %s;\n", zlim, zdir);
     endif
 
-    cmap = parent_figure_obj.colormap;    
+    cmap = parent_figure_obj.colormap;
     cmap_sz = rows(cmap);
     if (! any (isinf (clim)))
       if (truecolor || ! cdatadirect)
         if (rows(addedcmap) > 0)
           for i = 1:data_idx
             if (have_3d_patch(i))
               data{i}(end,:) = clim(2) * (data{i}(end, :) - 0.5) / cmap_sz;
              endif
           endfor
-          fprintf (plot_stream, "set cbrange [%g:%g];\n", clim(1), clim(2) * 
+          fprintf (plot_stream, "set cbrange [%g:%g];\n", clim(1), clim(2) *
                    (cmap_sz + rows(addedcmap)) / cmap_sz);
         else
           fprintf (plot_stream, "set cbrange [%g:%g];\n", clim);
         endif
       else
-        fprintf (plot_stream, "set cbrange [1:%d];\n", cmap_sz + 
+        fprintf (plot_stream, "set cbrange [1:%d];\n", cmap_sz +
                  rows (addedcmap));
       endif
     endif
 
     if (strcmpi (axis_obj.box, "on"))
       if (nd == 3)
         fputs (plot_stream, "set border 4095;\n");
       else
@@ -1458,31 +1458,31 @@ function __go_draw_axes__ (h, plot_strea
         case "northeast"
           pos = "right top";
         case "northwest"
           pos = "left top";
         case "southeast"
           pos = "right bottom";
         case "southwest"
           pos = "left bottom";
-        case "best" 
+        case "best"
           pos = "";
           warning ("legend: 'Best' not yet implemented for location specifier.\n");
           ## Least conflict with data in plot.
           ## Least unused space outside plot.
         otherwise
           pos = "";
       endswitch
       if (__gnuplot_has_feature__ ("key_has_font_properties"))
         [fontname, fontsize] = get_fontname_and_size (obj);
         fontspec = create_fontspec (fontname, fontsize, gnuplot_term);
       else
         fontspec = "";
       endif
-      fprintf (plot_stream, "set key %s %s;\nset key %s %s %s %s;\n", 
+      fprintf (plot_stream, "set key %s %s;\nset key %s %s %s %s;\n",
                inout, pos, box, reverse, horzvert, fontspec);
     else
       fputs (plot_stream, "unset key;\n");
     endif
     fputs (plot_stream, "set style data lines;\n");
 
     cmap = [cmap; addedcmap];
     cmap_sz = cmap_sz + rows(addedcmap);
@@ -1529,29 +1529,29 @@ function __go_draw_axes__ (h, plot_strea
       endif
       for i = 2:data_idx
         if (have_3d_patch (i))
           fprintf (plot_stream, ", \"-\" %s %s %s \\\n",
                    usingclause{i}, titlespec{i}, withclause{i});
         elseif (is_image_data (i))
           if (! is_image_data (i-1))
             fputs (plot_stream, "; ");
-            if (bg_is_set)      
+            if (bg_is_set)
               fputs (plot_stream, "unset obj 1; \\\n");
               bg_is_set = false;
             endif
             if (fg_is_set)
               fputs (plot_stream, "unset obj 2; \\\n");
               fg_is_set = false;
             endif
           endif
           fprintf (plot_stream, "%s \"-\" %s %s %s \\\n", plot_cmd,
                    usingclause{i}, titlespec{i}, withclause{i});
         elseif (is_image_data (i-1))
-          if (bg_is_set)      
+          if (bg_is_set)
             fputs (plot_stream, "unset obj 1; \\\n");
             bg_is_set = false;
           endif
           if (fg_is_set)
             fputs (plot_stream, "unset obj 2; \\\n");
             fg_is_set = false;
           endif
           fprintf (plot_stream, "%s \"-\" binary format='%%float64' %s %s %s \\\n", plot_cmd,
@@ -1559,46 +1559,46 @@ function __go_draw_axes__ (h, plot_strea
         else
           fprintf (plot_stream, ", \"-\" binary format='%%float64' %s %s %s \\\n",
                    usingclause{i}, titlespec{i}, withclause{i});
         endif
       endfor
       fputs (plot_stream, ";\n");
       for i = 1:data_idx
         if (have_3d_patch (i))
-          ## Can't write 3d patch data as binary as can't plot more than 
+          ## Can't write 3d patch data as binary as can't plot more than
           ## a single patch at a time and have to plot all patches together
           ## so that the gnuplot depth ordering is done correctly
           for j = 1 : 4 : columns(data{i})
             if (j != 1)
               fputs (plot_stream, "\n\n");
             endif
             fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j).');
             fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n\n", data{i}(:,j+1).');
             fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j+2).');
             fprintf (plot_stream, "%.15g %.15g %.15g %.15g\n", data{i}(:,j+3).');
           endfor
           fputs (plot_stream, "e\n");
         elseif (is_image_data(i))
           fwrite (plot_stream, data{i}, "float32");
         else
-          __gnuplot_write_data__ (plot_stream, data{i}, nd, parametric(i), 
+          __gnuplot_write_data__ (plot_stream, data{i}, nd, parametric(i),
                                   have_cdata(i));
         endif
       endfor
     else
       fputs (plot_stream, "plot \"-\";\nInf Inf\ne\n");
     endif
 
     ## Needed to allow mouse rotation with pcolor.
     if (view_map)
       fputs (plot_stream, "unset view;\n");
     endif
-    
-    if (bg_is_set)      
+
+    if (bg_is_set)
       fputs (plot_stream, "unset obj 1;\n");
       bg_is_set = false;
     endif
 
     fflush (plot_stream);
 
   else
     print_usage ();
@@ -1674,36 +1674,36 @@ function style = do_linestyle_command (o
   if (isempty (errbars))
     if (isempty (lt))
       style {sidx} = "";
     else
       style {sidx} = "lines";
     endif
 
     facesame = true;
-    if (! isequal (pt, pt2) && isfield (obj, "markerfacecolor") 
+    if (! isequal (pt, pt2) && isfield (obj, "markerfacecolor")
         && !strncmp (obj.markerfacecolor, "none", 4))
       if (strncmp (obj.markerfacecolor, "auto", 4)
-          || ! isnumeric (obj.markerfacecolor) 
-          || (isnumeric (obj.markerfacecolor) 
+          || ! isnumeric (obj.markerfacecolor)
+          || (isnumeric (obj.markerfacecolor)
               && isequal (color, obj.markerfacecolor)))
         if (! isempty (pt2))
           fprintf (plot_stream, " pointtype %s", pt2);
           style {sidx} = strcat (style{sidx}, "points");
         endif
         if (isfield (obj, "markersize"))
           fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
         endif
       else
         facesame = false;
         if (! found_style)
           fputs (plot_stream, " default");
         endif
         fputs (plot_stream, ";\n");
-        if (! isempty (style {sidx}))   
+        if (! isempty (style {sidx}))
           sidx ++;
           idx ++;
         else
           fputs (plot_stream, ";\n");
         endif
         fprintf (plot_stream, "set style line %d default;\n", idx);
         fprintf (plot_stream, "set style line %d", idx);
         if (isnumeric (obj.markerfacecolor) && ! mono)
@@ -1714,39 +1714,39 @@ function style = do_linestyle_command (o
           style {sidx} = "points";
           fprintf (plot_stream, " pointtype %s", pt2);
         endif
         if (isfield (obj, "markersize"))
           fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
         endif
       endif
     endif
-    if (isfield (obj, "markeredgecolor") 
+    if (isfield (obj, "markeredgecolor")
         && !strncmp (obj.markeredgecolor, "none", 4))
       if (facesame && !isempty (pt)
           && (strncmp (obj.markeredgecolor, "auto", 4)
-              || ! isnumeric (obj.markeredgecolor) 
-              || (isnumeric (obj.markeredgecolor) 
+              || ! isnumeric (obj.markeredgecolor)
+              || (isnumeric (obj.markeredgecolor)
                   && isequal (color, obj.markeredgecolor))))
-        if (sidx == 1 && ((length (style {sidx}) == 5 
+        if (sidx == 1 && ((length (style {sidx}) == 5
             && strncmp (style {sidx}, "lines", 5)) || isempty (style {sidx})))
           if (! isempty (pt))
             style {sidx} = strcat (style{sidx}, "points");
             fprintf (plot_stream, " pointtype %s", pt);
           endif
           if (isfield (obj, "markersize"))
             fprintf (plot_stream, " pointsize %f", obj.markersize / 3);
           endif
         endif
       else
         if (! found_style)
           fputs (plot_stream, " default");
         endif
         fputs (plot_stream, ";\n");
-        if (!isempty (style {sidx}))    
+        if (!isempty (style {sidx}))
           sidx ++;
           idx ++;
         else
           fputs (plot_stream, ";\n");
         endif
         fprintf (plot_stream, "set style line %d default;\n", idx);
         fprintf (plot_stream, "set style line %d", idx);
         if (! mono)
@@ -1837,17 +1837,17 @@ function [pt, pt2, obj] = gnuplot_pointt
         pt = pt2 = "";
     endswitch
   else
     pt = pt2 = "";
   endif
 endfunction
 
 function __gnuplot_write_data__ (plot_stream, data, nd, parametric, cdata)
-  
+
   ## DATA is already transposed.
 
   ## FIXME -- this may need to be converted to C++ for speed.
 
   ## Convert NA elements to normal NaN values because fprintf writes
   ## "NA" and that confuses gnuplot.
   idx = find (isna (data));
   if (any (idx))
@@ -1989,23 +1989,23 @@ function do_tics_1 (ticmode, tics, mtics
         labels = permute (cellstr (labels), [2, 1]);
       endif
       if (iscellstr (labels))
         k = 1;
         ntics = numel (tics);
         nlabels = numel (labels);
         fprintf (plot_stream, "set format %s \"%%s\";\n", ax);
         if (mirror)
-          fprintf (plot_stream, "set %stics %s %s %s mirror (", ax, 
+          fprintf (plot_stream, "set %stics %s %s %s mirror (", ax,
                    tickdir, ticklength, axispos);
         else
           fprintf (plot_stream, "set %stics %s %s %s nomirror (", ax,
                    tickdir, ticklength, axispos);
         endif
- 
+
         labels = regexprep(labels, '%', "%%");
         for i = 1:ntics
           fprintf (plot_stream, " \"%s\" %.15g", labels{k++}, tics(i));
           if (i < ntics)
             fputs (plot_stream, ", ");
           endif
           if (k > nlabels)
             k = 1;
@@ -2035,20 +2035,20 @@ function do_tics_1 (ticmode, tics, mtics
         fprintf (plot_stream, "set m%stics %d;\n", ax, num_mtics);
       else
         fprintf (plot_stream, "unset m%stics;\n", ax);
       endif
     endif
   else
     fprintf (plot_stream, "set format %s \"%s\";\n", ax, fmt);
     if (mirror)
-      fprintf (plot_stream, "set %stics %s %s %s mirror %s %s;\n", ax, 
+      fprintf (plot_stream, "set %stics %s %s %s mirror %s %s;\n", ax,
                axispos, tickdir, ticklength, colorspec, fontspec);
     else
-      fprintf (plot_stream, "set %stics %s %s %s nomirror %s %s;\n", ax, 
+      fprintf (plot_stream, "set %stics %s %s %s nomirror %s %s;\n", ax,
                tickdir, ticklength, axispos, colorspec, fontspec);
     endif
     if (strcmp (mtics, "on"))
       fprintf (plot_stream, "set m%stics %d;\n", ax, num_mtics);
     else
       fprintf (plot_stream, "unset m%stics;\n", ax);
     endif
   endif
@@ -2169,56 +2169,56 @@ function str = __tex2enhanced__ (str, fn
         str = cstrcat (str(1:s(i) - 1), g, str(e(i) + 1:end));
       elseif (strncmp (f, "rm", 2))
         bld = false;
         it = false;
         str = cstrcat (str(1:s(i) - 1), '/', fnt, ' ', str(s(i) + 3:end));
       elseif (strncmp (f, "it", 2) || strncmp (f, "sl", 2))
         it = true;
         if (bld)
-          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bolditalic ', 
+          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bolditalic ',
                         str(s(i) + 3:end));
         else
-          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-italic ', 
+          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-italic ',
                         str(s(i) + 3:end));
         endif
       elseif (strncmp (f, "bf", 2))
         bld = true;
         if (it)
-          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bolditalic ', 
+          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bolditalic ',
                         str(2(i) + 3:end));
         else
-          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bold ', 
+          str = cstrcat (str(1:s(i) - 1), '/', fnt, '-bold ',
                         str(s(i) + 3:end));
         endif
       elseif (strcmpi (f, "color"))
         ## FIXME Ignore \color but remove trailing {} block as well
         d = strfind(str(e(i) + 1:end),'}');
         if (isempty (d))
           warning ('syntax error in \color argument');
         else
           str = cstrcat (str(1:s(i) - 1), str(e(i) + d + 1:end));
         endif
       elseif(strcmpi (f, "fontname"))
         b1 = strfind(str(e(i) + 1:end),'{');
         b2 = strfind(str(e(i) + 1:end),'}');
         if (isempty(b1) || isempty(b2))
           warning ('syntax error in \fontname argument');
         else
-          str = cstrcat (str(1:s(i) - 1), '/', 
+          str = cstrcat (str(1:s(i) - 1), '/',
                         str(e(i)+b1(1) + 1:e(i)+b2(1)-1), '{}',
                         str(e(i) + b2(1) + 1:end));
         endif
       elseif(strcmpi (f, "fontsize"))
         b1 = strfind(str(e(i) + 1:end),'{');
         b2 = strfind(str(e(i) + 1:end),'}');
         if (isempty(b1) || isempty(b2))
           warning ('syntax error in \fontname argument');
         else
-          str = cstrcat (str(1:s(i) - 1), '/=', 
+          str = cstrcat (str(1:s(i) - 1), '/=',
                         str(e(i)+b1(1) + 1:e(i)+b2(1)-1), '{}',
                         str(e(i) + b2(1) + 1:end));
         endif
       else
         ## Last desperate attempt to treat the symbol. Look for things
         ## like \pix, that should be translated to the symbol Pi and x
         for j = 1 : length (flds)
           if (strncmp (flds{j}, f, length (flds{j})))
@@ -2228,17 +2228,17 @@ function str = __tex2enhanced__ (str, fn
             ##  if (it)
             ##    g = regexprep (g, '/Symbol', '/Symbol-bolditalic');
             ##  else
             ##    g = regexprep (g, '/Symbol', '/Symbol-bold');
             ##  endif
             ##elseif (it)
             ##  g = regexprep (g, '/Symbol', '/Symbol-italic');
             ##endif
-            str = cstrcat (str(1:s(i) - 1), g, 
+            str = cstrcat (str(1:s(i) - 1), g,
                           str(s(i) + length (flds{j}) + 1:end));
             break;
           endif
         endfor
       endif
     endif
   endfor
 
diff --git a/scripts/plot/__go_draw_figure__.m b/scripts/plot/__go_draw_figure__.m
--- a/scripts/plot/__go_draw_figure__.m
+++ b/scripts/plot/__go_draw_figure__.m
@@ -55,48 +55,48 @@ function __go_draw_figure__ (h, plot_str
                 ## then we could get rid of this mess.
                 lh = getfield (get (kids(i), "userdata"), "handle");
                 if (isscalar (lh))
                   ## We have a legend with a single parent. It'll be handled
                   ## below as a gnuplot key to the axis it corresponds to
                   continue;
                 else
                   ca = lh(1);
-                  ## Rely upon listener to convert axes position 
+                  ## Rely upon listener to convert axes position
                   ## to "normalized" units.
                   legend_axes_units = get (kids(i), "units");
                   legend_axes_position = get (kids(i), "position");
                   legend_axes_outerposition = get (kids(i), "outerposition");
                   legend_axes_box = get (kids(i), "box");
                   legend_axes_ylim = get (kids(i), "ylim");
                   orig_axes_units = get (ca, "units");
                   hlgnd = get (kids(i));
 
                   unwind_protect
                     set (ca, "units", "normalized");
-                    set (kids(i), "units", "normalized", "box", "off", 
+                    set (kids(i), "units", "normalized", "box", "off",
                          "ylim", [-2, -1], "position", get (ca(1), "position"),
                          "outerposition", get (ca(1), "outerposition"));
 
-                    ## Create a new set of lines with the appropriate 
+                    ## Create a new set of lines with the appropriate
                     ## displaynames, etc
                     toberm = [];
                     hobj = get (kids(i), "children");
                     for j = numel (hobj) : -1 : 1
                       if (! strcmp (get (hobj(j), "type"), "text"))
                         continue;
                       endif
                       displayname = get (hobj(j), "string");
                       ll = [];
                       lm = [];
                       for k = numel (hobj) : -1 : 1
                         if (! strcmp (get (hobj(k), "type"), "line"))
                           continue;
                         endif
-                        if (get (hobj(j), "userdata") 
+                        if (get (hobj(j), "userdata")
                             != get (hobj(k), "userdata"))
                           continue;
                         endif
                         if (! strcmp (get (hobj(k), "linestyle"), "none"))
                           ll = hobj(k);
                         endif
                         if (! strcmp (get (hobj(k), "marker"), "none"))
                           lm = hobj(k);
@@ -117,27 +117,27 @@ function __go_draw_figure__ (h, plot_str
                       fprintf (plot_stream, "set border linecolor rgb \"#%02x%02x%02x\"\n", 255 * (1 - bg));
                     endif
                     __go_draw_axes__ (kids(i), plot_stream, enhanced, mono,
                                       bg_is_set, false, hlgnd);
                   unwind_protect_cleanup
                     ## Return axes "units" and "position" back to
                     ## their original values.
                     set (ca, "units", orig_axes_units);
-                    set (kids(i), "units", legend_axes_units, 
-                         "box", legend_axes_box, 
-                         "ylim", legend_axes_ylim, 
+                    set (kids(i), "units", legend_axes_units,
+                         "box", legend_axes_box,
+                         "ylim", legend_axes_ylim,
                          "position", legend_axes_position,
                          "outerposition", legend_axes_outerposition);
                     delete (toberm);
                     bg_is_set = false;
                   end_unwind_protect
                 endif
               else
-                ## Rely upon listener to convert axes position 
+                ## Rely upon listener to convert axes position
                 ## to "normalized" units.
                 orig_axes_units = get (kids(i), "units");
                 orig_axes_position = get (kids(i), "position");
                 unwind_protect
                   set (kids(i), "units", "normalized");
                   fg = get (kids(i), "color");
                   if (isnumeric (fg) && strcmp (get (kids(i), "visible"), "on"))
                     fprintf (plot_stream, "set obj 2 rectangle from graph 0,0 to graph 1,1 behind fc rgb \"#%02x%02x%02x\"\n", 255 * fg);
@@ -148,21 +148,21 @@ function __go_draw_figure__ (h, plot_str
                   if (bg_is_set)
                     fprintf (plot_stream, "set border linecolor rgb \"#%02x%02x%02x\"\n", 255 * (1 - bg));
                   endif
                   ## Find if this axes has an associated legend axes and pass it
                   ## to __go_draw_axes__
                   hlegend = [];
                   fkids = get (h, "children");
                   for j = 1 : numel(fkids)
-                    if (ishandle (fkids (j)) 
-                        && strcmp (get (fkids (j), "type"), "axes") 
+                    if (ishandle (fkids (j))
+                        && strcmp (get (fkids (j), "type"), "axes")
                         && (strcmp (get (fkids (j), "tag"), "legend")))
                       udata = get (fkids (j), "userdata");
-                      if (isscalar(udata.handle) 
+                      if (isscalar(udata.handle)
                           && ! isempty (intersect (udata.handle, kids (i))))
                         hlegend = get (fkids (j));
                         break;
                       endif
                     endif
                   endfor
                   __go_draw_axes__ (kids(i), plot_stream, enhanced, mono,
                                     bg_is_set, fg_is_set, hlegend);
@@ -187,12 +187,12 @@ function __go_draw_figure__ (h, plot_str
         fflush (plot_stream);
       endif
     else
       error ("__go_draw_figure__: expecting figure object, found `%s'",
              htype);
     endif
   else
     print_usage ();
-  endif    
+  endif
 
 endfunction
 
diff --git a/scripts/plot/__marching_cube__.m b/scripts/plot/__marching_cube__.m
--- a/scripts/plot/__marching_cube__.m
+++ b/scripts/plot/__marching_cube__.m
@@ -78,85 +78,85 @@
 ## @end group
 ## @end example
 ##
 ## @end deftypefn
 
 ## Author: Martin Helm <martin@mhelm.de>
 
 function [T, p, col] = __marching_cube__ (xx, yy, zz, c, iso, colors)
-  
+
   persistent edge_table=[];
   persistent tri_table=[];
 
   calc_cols = false;
   lindex = 4;
 
   if (isempty (tri_table) || isempty (edge_table))
     [edge_table, tri_table] = init_mc ();
   endif
-   
+
   if ((nargin != 5 && nargin != 6) || (nargout != 2 && nargout != 3))
     print_usage ();
   endif
-  
+
   if (!ismatrix (xx) || !ismatrix (yy) || !ismatrix (zz) || !ismatrix (c) || ...
     ndims (xx) != 3 || ndims (yy) != 3 || ndims (zz) != 3 || ndims (c) != 3)
     error ("__marching_cube__: XX, YY, ZZ, C must be matrices of dim 3");
   endif
-  
+
   if (!size_equal (xx, yy, zz, c))
     error ("__marching_cube__: XX, YY, ZZ, C must be of equal size");
   endif
-  
+
   if (any (size (xx) < [2 2 2]))
     error ("__marching_cube__: grid size must be at least 2x2x2");
   endif
-  
+
   if (!isscalar (iso))
     error ("__marching_cube__: ISO must be scalar value");
   endif
 
   if (nargin == 6)
     if ( !ismatrix (colors) || ndims (colors) != 3 || size (colors) != size (c) )
       error ( "COLORS must be a matrix of dim 3 and of same size as C" );
     endif
     calc_cols = true;
     lindex = 5;
   endif
-  
+
   n = size (c) - 1;
-  
+
   ## phase I: assign information to each voxel which edges are intersected by
   ## the isosurface
   cc = zeros (n(1), n(2), n(3), "uint16");
   cedge = zeros (size (cc), "uint16");
-  
+
   vertex_idx = {1:n(1), 1:n(2), 1:n(3); ...
     2:n(1)+1, 1:n(2), 1:n(3); ...
     2:n(1)+1, 2:n(2)+1, 1:n(3); ...
     1:n(1), 2:n(2)+1, 1:n(3); ...
     1:n(1), 1:n(2), 2:n(3)+1; ...
     2:n(1)+1, 1:n(2), 2:n(3)+1; ...
     2:n(1)+1, 2:n(2)+1, 2:n(3)+1; ...
     1:n(1), 2:n(2)+1, 2:n(3)+1 };
-  
+
   ## calculate which vertices have values higher than iso
   for ii=1:8
     idx = c(vertex_idx{ii, :}) > iso;
     cc(idx) = bitset (cc(idx), ii);
-  endfor 
-  
+  endfor
+
   cedge = edge_table(cc+1); # assign the info about intersected edges
   id =  find (cedge); # select only voxels which are intersected
   if (isempty (id))
     T = p = col = [];
     return
   endif
-  
+
   ## phase II: calculate the list of intersection points
   xyz_off = [1, 1, 1; 2, 1, 1; 2, 2, 1; 1, 2, 1; 1, 1, 2;  2, 1, 2; 2, 2, 2; 1, 2, 2];
   edges = [1 2; 2 3; 3 4; 4 1; 5 6; 6 7; 7 8; 8 5; 1 5; 2 6; 3 7; 4 8];
   offset = sub2ind (size (c), xyz_off(:, 1), xyz_off(:, 2), xyz_off(:, 3)) -1;
   pp = zeros (length (id), lindex, 12);
   ccedge = [vec(cedge(id)), id];
   ix_offset=0;
   for jj=1:12
@@ -172,52 +172,52 @@ function [T, p, col] = __marching_cube__
         (1:size (id_, 1))' + ix_offset ];
     else
       pp(id__, 1:4, jj) = [vertex_interp(iso, xx(id1), yy(id1), zz(id1), ...
         xx(id2), yy(id2), zz(id2), c(id1), c(id2)), ...
         (1:size (id_, 1))' + ix_offset ];
     endif
     ix_offset += size (id_, 1);
   endfor
-  
-  ## phase III: calculate the triangulation from the point list 
+
+  ## phase III: calculate the triangulation from the point list
   T = [];
   tri = tri_table(cc(id)+1, :);
   for jj=1:3:15
     id_ = find (tri(:, jj)>0);
     p = [id_, lindex*ones(size (id_, 1), 1),tri(id_, jj:jj+2)];
     if (!isempty (p))
       p1 = sub2ind (size (pp), p(:,1), p(:,2), p(:,3));
       p2 = sub2ind (size (pp), p(:,1), p(:,2), p(:,4));
       p3 = sub2ind (size (pp), p(:,1), p(:,2), p(:,5));
       T = [T; pp(p1), pp(p2), pp(p3)];
     endif
   endfor
-  
+
   p = [];
   col = [];
   for jj = 1:12
     idp = pp(:, lindex, jj) > 0;
     if (any (idp))
       p(pp(idp, lindex, jj), 1:3) = pp(idp, 1:3, jj);
       if (calc_cols)
         col(pp(idp, lindex, jj),1) = pp(idp, 4, jj);
       endif
     endif
   endfor
 endfunction
 
 function p = vertex_interp(isolevel,p1x, p1y, p1z,...
   p2x, p2y, p2z,valp1,valp2, col1, col2)
-  
+
   if (nargin == 9)
     p = zeros (length (p1x), 3);
   elseif (nargin == 11)
     p = zeros (length (p1x), 4);
-  else 
+  else
     error ("__marching_cube__: wrong number of arguments");
   endif
   mu = zeros (length (p1x), 1);
   id = abs (valp1-valp2) < (10*eps) .* (abs (valp1) .+ abs (valp2));
   if (any (id))
     p(id, 1:3) = [ p1x(id), p1y(id), p1z(id) ];
     if (nargin == 11)
       p(id, 4) = col1(id);
@@ -264,18 +264,18 @@ function [edge_table, tri_table] = init_
   0xca0, 0xda9, 0xea3, 0xfaa, 0x8a6, 0x9af, 0xaa5, 0xbac, ...
   0x4ac, 0x5a5, 0x6af, 0x7a6, 0xaa , 0x1a3, 0x2a9, 0x3a0, ...
   0xd30, 0xc39, 0xf33, 0xe3a, 0x936, 0x83f, 0xb35, 0xa3c, ...
   0x53c, 0x435, 0x73f, 0x636, 0x13a, 0x33 , 0x339, 0x230, ...
   0xe90, 0xf99, 0xc93, 0xd9a, 0xa96, 0xb9f, 0x895, 0x99c, ...
   0x69c, 0x795, 0x49f, 0x596, 0x29a, 0x393, 0x99 , 0x190, ...
   0xf00, 0xe09, 0xd03, 0xc0a, 0xb06, 0xa0f, 0x905, 0x80c, ...
   0x70c, 0x605, 0x50f, 0x406, 0x30a, 0x203, 0x109, 0x0   ];
-  
-  tri_table =[ 
+
+  tri_table =[
   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1;
   0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1;
   0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1;
   1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1;
   1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1;
   0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1;
   9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1;
   2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1;
diff --git a/scripts/plot/__next_line_color__.m b/scripts/plot/__next_line_color__.m
--- a/scripts/plot/__next_line_color__.m
+++ b/scripts/plot/__next_line_color__.m
@@ -27,17 +27,17 @@
 
 function rgb = __next_line_color__ (reset)
 
   persistent color_rotation;
   persistent num_colors;
   persistent color_index;
 
   if (nargin < 2)
-    if (nargin == 1) 
+    if (nargin == 1)
       if (reset || isempty (color_rotation))
         color_rotation = get (gca (), "colororder");
         num_colors = rows (color_rotation);
         color_index = 1;
       endif
     elseif (! isempty (color_rotation))
       rgb = color_rotation(color_index,:);
       if (++color_index > num_colors)
diff --git a/scripts/plot/__next_line_style__.m b/scripts/plot/__next_line_style__.m
--- a/scripts/plot/__next_line_style__.m
+++ b/scripts/plot/__next_line_style__.m
@@ -39,20 +39,20 @@ function [linestyle, marker] = __next_li
           style_index = 1;
         endif
       elseif (reset || isempty (style_rotation))
         style_rotation = strsplit (get (gca (), "linestyleorder"), "|");
         num_styles = length (style_rotation);
         style_index = 1;
       endif
     elseif (! isempty (style_rotation))
-      options = __pltopt__ ("__next_line_style__", 
+      options = __pltopt__ ("__next_line_style__",
                             style_rotation (style_index));
       linestyle = options.linestyle;
-      marker = options.marker;   
+      marker = options.marker;
     else
       error ("__next_line_style__: style_rotation not initialized");
     endif
   else
     print_usage ();
   endif
 
 endfunction
diff --git a/scripts/plot/__plt_get_axis_arg__.m b/scripts/plot/__plt_get_axis_arg__.m
--- a/scripts/plot/__plt_get_axis_arg__.m
+++ b/scripts/plot/__plt_get_axis_arg__.m
@@ -30,22 +30,22 @@ function [h, varargin, narg] = __plt_get
     caller = varargin{1};
     varargin(1) = [];
   else
     nogca = false;
   endif
 
   ## Figure handles are integers, but object handles are non integer,
   ## therefore ignore integer scalars.
-  if (nargin > 1 && length (varargin) > 0 && isnumeric (varargin{1}) 
-      && numel (varargin{1}) == 1 && ishandle (varargin{1}(1)) 
+  if (nargin > 1 && length (varargin) > 0 && isnumeric (varargin{1})
+      && numel (varargin{1}) == 1 && ishandle (varargin{1}(1))
       && varargin{1}(1) != 0 && ! isfigure (varargin{1}(1)))
     tmp = varargin{1};
     obj = get (tmp);
-    if ((strcmp (obj.type, "axes") && ! strcmp (obj.tag, "legend")) 
+    if ((strcmp (obj.type, "axes") && ! strcmp (obj.tag, "legend"))
         || strcmp (obj.type, "hggroup"))
       h = ancestor (tmp, "axes");
       varargin(1) = [];
       if (isempty (varargin))
         varargin = {};
       endif
     else
       error ("%s: expecting first argument to be axes handle", caller);
diff --git a/scripts/plot/__print_parse_opts__.m b/scripts/plot/__print_parse_opts__.m
--- a/scripts/plot/__print_parse_opts__.m
+++ b/scripts/plot/__print_parse_opts__.m
@@ -65,17 +65,17 @@ function arg_st = __print_parse_opts__ (
   if (isunix ())
     arg_st.lpr_options = "-l";
   elseif (ispc ())
     arg_st.lpr_options = "-o l";
   else
     arg_st.lpr_options = "";
   endif
   arg_st.unlink = {};
-  
+
   if (nargin > 0 && isfigure (varargin{1}))
     arg_st.figure = varargin{1};
     varargin(1) = [];
   endif
 
   for i = 1:numel(varargin)
     arg = strtrim (varargin{i});
     if (ischar (arg))
@@ -249,17 +249,17 @@ function arg_st = __print_parse_opts__ (
 
   if (arg_st.append_to_file)
     if (isempty (arg_st.name))
       arg_st.append_to_file = false;
     elseif (any (strcmpi (arg_st.devopt, {"eps", "eps2", "epsc", "epsc2", ...
                                           "ps", "ps2", "psc", "psc2", "pdf"})))
       have_ghostscript = ! isempty (__ghostscript_binary__ ());
       if (have_ghostscript)
-        file_exists = ((numel (dir (arg_st.name)) == 1) 
+        file_exists = ((numel (dir (arg_st.name)) == 1)
                        && (! isdir (arg_st.name)));
         if (! file_exists)
           arg_st.append_to_file = false;
         endif
       else
         arg_st.append_to_file = false;
         warning ("print.m: appended output requires ghostscript to be installed")
       endif
@@ -588,17 +588,17 @@ function device_list = gs_device_list ()
                  "tiffcrle"; "tiffg3"; "tiffg32d"; "tiffg4"; ...
                  "tiffgray"; "tifflzw"; "tiffpack"; "tiffsep"};
 endfunction
 
 function aliases = gs_aliases ();
   ## Aliases for other devices: "bmp", "png", "tiff", "tiffn", "pdf",
   ##                            "ps", "ps2", "psc", "psc2"
   ##
-  ## eps, epsc, eps2, epsc2 are not included here because those are 
+  ## eps, epsc, eps2, epsc2 are not included here because those are
   ## are generated by the graphics toolkit.
   aliases.bmp = "bmp32b";
   aliases.pdf = "pdfwrite";
   aliases.png = "png16m";
   aliases.ps = "pswrite";
   aliases.ps2 = "ps2write";
   aliases.psc = "pswrite";
   aliases.psc2 = "ps2write";
diff --git a/scripts/plot/area.m b/scripts/plot/area.m
--- a/scripts/plot/area.m
+++ b/scripts/plot/area.m
@@ -20,26 +20,26 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} area (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} area (@var{x}, @var{y}, @var{lvl})
 ## @deftypefnx {Function File} {} area (@dots{}, @var{prop}, @var{val}, @dots{})
 ## @deftypefnx {Function File} {} area (@var{y}, @dots{})
 ## @deftypefnx {Function File} {} area (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} area (@dots{})
 ## Area plot of cumulative sum of the columns of @var{y}.  This shows the
-## contributions of a value to a sum, and is functionally similar to 
-## @code{plot (@var{x}, cumsum (@var{y}, 2))}, except that the area under 
+## contributions of a value to a sum, and is functionally similar to
+## @code{plot (@var{x}, cumsum (@var{y}, 2))}, except that the area under
 ## the curve is shaded.
 ##
 ## If the @var{x} argument is omitted it is assumed to be given by
 ## @code{1 : rows (@var{y})}.  A value @var{lvl} can be defined that determines
 ## where the base level of the shading under the curve should be defined.
 ##
-## Additional arguments to the @code{area} function are passed to the 
-## @code{patch}.  The optional return value @var{h} provides a handle to 
+## Additional arguments to the @code{area} function are passed to the
+## @code{patch}.  The optional return value @var{h} provides a handle to
 ## area series object representing the patches of the areas.
 ## @seealso{plot, patch}
 ## @end deftypefn
 
 function h = area (varargin)
 
   [ax, varargin, nargin] = __plt_get_axis_arg__ ("area", varargin{:});
 
@@ -125,41 +125,41 @@ function retval = __area__ (ax, x, y, bv
       y1 = y0 + y1;
       h = patch (ax, [x1(1), x1, fliplr(x1)], [y0(1), y1, fliplr(y0)],
                  __next_line_color__ (), "parent", hg);
     endif
 
     y0 = y1;
 
     addproperty ("basevalue", hg, "data", bv);
-    addlistener (hg, "basevalue", @move_baseline); 
+    addlistener (hg, "basevalue", @move_baseline);
 
     addproperty ("edgecolor", hg, "patchedgecolor", get (h, "edgecolor"));
     addproperty ("linewidth", hg, "patchlinewidth", get (h, "linewidth"));
     addproperty ("linestyle", hg, "patchlinestyle", get (h, "linestyle"));
     addproperty ("facecolor", hg, "patchfacecolor", get (h, "facecolor"));
 
     addlistener (hg, "edgecolor", @update_props);
-    addlistener (hg, "linewidth", @update_props); 
-    addlistener (hg, "linestyle", @update_props); 
-    addlistener (hg, "facecolor", @update_props); 
+    addlistener (hg, "linewidth", @update_props);
+    addlistener (hg, "linestyle", @update_props);
+    addlistener (hg, "facecolor", @update_props);
 
     addproperty ("areagroup", hg, "data");
     set (retval, "areagroup", retval);
 
     if (! isempty (args))
       set (hg, args{:});
     endif
   endfor
 
 endfunction
 
 function update_props (h, d)
   kids = get (h, "children");
-  set (kids, "edgecolor", get (h, "edgecolor"), 
+  set (kids, "edgecolor", get (h, "edgecolor"),
        "linewidth", get (h, "linewidth"),
        "linestyle", get (h, "linestyle"),
        "facecolor", get (h, "facecolor"));
 endfunction
 
 function move_baseline (h, d)
   persistent recursion = false;
 
@@ -194,13 +194,13 @@ function update_data (h, d)
     y1 = get (hh, "ydata")(:);
 
     set (get (hh, "children"), "xdata", [x1(1); x1; flipud(x1)]);
     if (i == 1)
       set (get (hh, "children"), "ydata", [bv; y1; bv*ones(length(y1), 1)]);
     else
       y1 = y0 + y1;
       set (get (hh, "children"), "ydata", [y0(1); y1; flipud(y0)]);
-    endif      
+    endif
 
     y0 = y1;
   endfor
 endfunction
diff --git a/scripts/plot/axis.m b/scripts/plot/axis.m
--- a/scripts/plot/axis.m
+++ b/scripts/plot/axis.m
@@ -27,17 +27,17 @@
 ## @deftypefnx {Function File} {@var{limits} =} axis ()
 ## Set axis limits for plots.
 ##
 ## The argument @var{limits} should be a 2-, 4-, or 6-element vector.  The
 ## first and second elements specify the lower and upper limits for the
 ## x-axis.  The third and fourth specify the limits for the y-axis, and the
 ## fifth and sixth specify the limits for the z-axis.
 ##
-## Without any arguments, @code{axis} turns autoscaling on.  
+## Without any arguments, @code{axis} turns autoscaling on.
 ##
 ## With one output argument, @code{x = axis} returns the current axes.
 ##
 ## The vector argument specifying limits is optional, and additional
 ## string arguments may be used to specify various axis properties.  For
 ## example,
 ##
 ## @example
@@ -68,66 +68,66 @@
 ## @item "normal"
 ## Restore the balance.
 ## @end table
 ##
 ## @noindent
 ## The following options control the way axis limits are interpreted.
 ##
 ## @table @asis
-## @item "auto" 
+## @item "auto"
 ## Set the specified axes to have nice limits around the data
 ## or all if no axes are specified.
 ##
-## @item "manual" 
+## @item "manual"
 ## Fix the current axes limits.
 ##
 ## @item "tight"
 ## Fix axes to the limits of the data.
 ## @end table
 ##
 ## @noindent
 ## The option @code{"image"} is equivalent to @code{"tight"} and
 ## @code{"equal"}.
 ##
 ## @noindent
 ## The following options affect the appearance of tic marks.
 ##
 ## @table @asis
-## @item "on" 
+## @item "on"
 ## Turn tic marks and labels on for all axes.
 ##
 ## @item "off"
 ## Turn tic marks off for all axes.
 ##
 ## @item "tic[xyz]"
 ## Turn tic marks on for all axes, or turn them on for the
 ## specified axes and off for the remainder.
 ##
 ## @item "label[xyz]"
-## Turn tic labels on for all axes, or turn them on for the 
+## Turn tic labels on for all axes, or turn them on for the
 ## specified axes and off for the remainder.
 ##
 ## @item "nolabel"
 ## Turn tic labels off for all axes.
 ## @end table
 ## Note, if there are no tic marks for an axis, there can be no labels.
 ##
 ## @noindent
 ## The following options affect the direction of increasing values on
 ## the axes.
 ##
 ## @table @asis
 ## @item "ij"
 ## Reverse y-axis, so lower values are nearer the top.
 ##
-## @item "xy" 
-## Restore y-axis, so higher values are nearer the top. 
+## @item "xy"
+## Restore y-axis, so higher values are nearer the top.
 ## @end table
-## 
+##
 ## If an axes handle is passed as the first argument, then operate on
 ## this axes rather than the current axes.
 ## @end deftypefn
 
 ## Author: jwe
 
 function varargout = axis (varargin)
 
@@ -179,17 +179,17 @@ function curr_axis = __axis__ (ca, ax, v
       __axis__ (ca, "equal")
       __do_tight_option__ (ca);
     elseif (strcmpi (ax, "square"))
       set (ca, "plotboxaspectratio", [1, 1, 1]);
     elseif  (strcmp (ax, "equal"))
       if (strcmp (get (get (ca, "parent"), "__graphics_toolkit__"), "gnuplot"))
         ## FIXME - gnuplot applies the aspect ratio activepostionproperty.
         set (ca, "activepositionproperty", "position");
-        ## The following line is a trick used to trigger the recalculation of 
+        ## The following line is a trick used to trigger the recalculation of
         ## aspect related magnitudes even if the aspect ratio is the same
         ## (useful with the x11 gnuplot terminal after a window resize)
         set (ca, "dataaspectratiomode", "auto");
       endif
       set (ca, "dataaspectratio", [1, 1, 1])
     elseif (strcmpi (ax, "normal"))
       set (ca, "plotboxaspectratio", [1, 1, 1])
       set (ca, "plotboxaspectratiomode", "auto");
@@ -320,19 +320,19 @@ function lims = __get_tight_lims__ (ca, 
     data = get (kids, strcat (ax, "data"));
     scale = get (ca, strcat (ax, "scale"));
     if (strcmp (scale, "log"))
       data(data<=0) = NaN;
     end
     if (iscell (data))
       data = data (find (! cellfun (@isempty, data)));
       if (! isempty (data))
-        lims_min = min (cellfun (@min, cellfun (@min, data, 'uniformoutput', false)(:))); 
-        lims_max = max (cellfun (@max, cellfun (@max, data, 'uniformoutput', false)(:))); 
-        lims = [lims_min, lims_max]; 
+        lims_min = min (cellfun (@min, cellfun (@min, data, 'uniformoutput', false)(:)));
+        lims_max = max (cellfun (@max, cellfun (@max, data, 'uniformoutput', false)(:)));
+        lims = [lims_min, lims_max];
       else
         lims = [0, 1];
       endif
     else
       lims = [min(data(:)), max(data(:))];
     endif
   endif
 
@@ -360,17 +360,17 @@ endfunction
 %! plot(t, x);
 %! title("square plot");
 %! axis("square");
 %!
 %! subplot(223);
 %! plot(t, x);
 %! title("equal plot");
 %! axis("equal");
-%! 
+%!
 %! subplot(224);
 %! plot(t, x);
 %! title("normal plot again");
 %! axis("normal");
 
 %!demo
 %! t=0:0.01:2*pi; x=sin(t);
 %!
diff --git a/scripts/plot/bar.m b/scripts/plot/bar.m
--- a/scripts/plot/bar.m
+++ b/scripts/plot/bar.m
@@ -23,17 +23,17 @@
 ## @deftypefnx {Function File} {} bar (@var{x}, @var{y}, @var{w}, @var{style})
 ## @deftypefnx {Function File} {@var{h} =} bar (@dots{}, @var{prop}, @var{val})
 ## @deftypefnx {Function File} {} bar (@var{h}, @dots{})
 ## Produce a bar graph from two vectors of x-y data.
 ##
 ## If only one argument is given, @var{y}, it is taken as a vector of y-values
 ## and the x coordinates are taken to be the indices of the elements.
 ##
-## The default width of 0.8 for the bars can be changed using @var{w}. 
+## The default width of 0.8 for the bars can be changed using @var{w}.
 ##
 ## If @var{y} is a matrix, then each column of @var{y} is taken to be a
 ## separate bar graph plotted on the same graph.  By default the columns
 ## are plotted side-by-side.  This behavior can be changed by the @var{style}
 ## argument, which can take the values @code{"grouped"} (the default),
 ## or @code{"stacked"}.
 ##
 ## The optional return value @var{h} provides a handle to the "bar series"
@@ -79,17 +79,17 @@
 ## @group
 ## h = bar (rand(10,3))
 ## set (h(1), "facecolor", "r")
 ## set (h(2), "facecolor", "g")
 ## set (h(3), "facecolor", "b")
 ## @end group
 ## @end example
 ##
-## @seealso{barh, plot} 
+## @seealso{barh, plot}
 ## @end deftypefn
 
 ## Author: jwe
 
 function varargout = bar (varargin)
   varargout = cell (nargout, 1);
   [varargout{:}] = __bar__ (true, "bar", varargin{:});
 endfunction
diff --git a/scripts/plot/barh.m b/scripts/plot/barh.m
--- a/scripts/plot/barh.m
+++ b/scripts/plot/barh.m
@@ -23,17 +23,17 @@
 ## @deftypefnx {Function File} {} barh (@var{x}, @var{y}, @var{w}, @var{style})
 ## @deftypefnx {Function File} {@var{h} =} barh (@dots{}, @var{prop}, @var{val})
 ## @deftypefnx {Function File} {} barh (@var{h}, @dots{})
 ## Produce a horizontal bar graph from two vectors of x-y data.
 ##
 ## If only one argument is given, it is taken as a vector of y-values
 ## and the x coordinates are taken to be the indices of the elements.
 ##
-## The default width of 0.8 for the bars can be changed using @var{w}. 
+## The default width of 0.8 for the bars can be changed using @var{w}.
 ##
 ## If @var{y} is a matrix, then each column of @var{y} is taken to be a
 ## separate bar graph plotted on the same graph.  By default the columns
 ## are plotted side-by-side.  This behavior can be changed by the @var{style}
 ## argument, which can take the values @code{"grouped"} (the default),
 ## or @code{"stacked"}.
 ##
 ## The optional return value @var{h} provides a handle to the bar series
diff --git a/scripts/plot/caxis.m b/scripts/plot/caxis.m
--- a/scripts/plot/caxis.m
+++ b/scripts/plot/caxis.m
@@ -16,20 +16,20 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} caxis (@var{limits})
 ## @deftypefnx {Function File} {} caxis (@var{h}, @dots{})
 ## Set color axis limits for plots.
 ##
-## The argument @var{limits} should be a 2-element vector specifying the 
+## The argument @var{limits} should be a 2-element vector specifying the
 ## lower and upper limits to assign to the first and last value in the
 ## colormap.  Values outside this range are clamped to the first and last
-## colormap entries. 
+## colormap entries.
 ##
 ## If @var{limits} is 'auto', then automatic colormap scaling is applied,
 ## whereas if @var{limits} is 'manual' the colormap scaling is set to manual.
 ##
 ## Called without any arguments to current color axis limits are returned.
 ##
 ## If an axes handle is passed as the first argument, then operate on
 ## this axes rather than the current axes.
@@ -80,9 +80,9 @@ function [cmin, cmax] = __caxis__ (ca, a
     error ("caxis: expecting no args, a string or a 2 element vector");
   endif
 
   if (nargin > 2)
     __caxis__ (ca, varargin{:})'
   endif
 
 endfunction
-      
+
diff --git a/scripts/plot/cla.m b/scripts/plot/cla.m
--- a/scripts/plot/cla.m
+++ b/scripts/plot/cla.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2008-2011 Ben Abbott
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
diff --git a/scripts/plot/clabel.m b/scripts/plot/clabel.m
--- a/scripts/plot/clabel.m
+++ b/scripts/plot/clabel.m
@@ -102,17 +102,17 @@ function retval = clabel (c, varargin)
     if (strcmpi (arg, "manual"))
       error ("clabel: manual contouring mode not supported");
     endif
   endfor
 
   if (have_hg)
     if (! isempty (v))
       if (have_labelspacing)
-        set (hg, "textlistmode", "manual", "textlist", v, 
+        set (hg, "textlistmode", "manual", "textlist", v,
              "labelspacing", label_spacing, "showtext", "on");
       else
         set (hg, "textlistmode", "manual", "textlist", v, "showtext", "on");
       endif
     else
       if (have_labelspacing)
         set (hg,"showtext", "on", "labelspacing", label_spacing);
       else
diff --git a/scripts/plot/colorbar.m b/scripts/plot/colorbar.m
--- a/scripts/plot/colorbar.m
+++ b/scripts/plot/colorbar.m
@@ -118,19 +118,19 @@ function h = colorbar (varargin)
     cdiff = (cext(2) - cext(1)) / clen / 2;
     cmin = cext(1) + cdiff;
     cmax = cext(2) - cdiff;
 
     [pos, cpos, vertical, mirror] =  ...
         __position_colorbox__ (loc, obj, ancestor (ax, "figure"));
     set (ax, "position", pos);
 
-    cax = __go_axes__ (get (ax, "parent"), "tag", "colorbar", 
-                       "handlevisibility", "on", 
-                       "activepositionproperty", "position", 
+    cax = __go_axes__ (get (ax, "parent"), "tag", "colorbar",
+                       "handlevisibility", "on",
+                       "activepositionproperty", "position",
                        "position", cpos);
     addproperty ("location", cax, "radio",
                  "eastoutside|east|westoutside|west|northoutside|north|southoutside|south",
                  loc);
     addproperty ("axes", cax, "handle", ax);
 
     if (vertical)
       hi = image (cax, [0,1], [cmin, cmax], [1 : clen]');
@@ -151,18 +151,18 @@ function h = colorbar (varargin)
              "xaxislocation", "top", args{:});
       else
         set (cax, "ytick", [], "xdir", "normal", "ydir", "normal",
              "xlim", cext, "xlimmode", "manual",
              "xaxislocation", "bottom", args{:});
       endif
     endif
 
-    ctext = text (0, 0, "", "tag", "colorbar","visible", "off", 
-                  "handlevisibility", "off", "xliminclude", "off",  
+    ctext = text (0, 0, "", "tag", "colorbar","visible", "off",
+                  "handlevisibility", "off", "xliminclude", "off",
                   "yliminclude", "off", "zliminclude", "off",
                   "deletefcn", {@deletecolorbar, cax, obj});
 
     set (cax, "deletefcn", {@resetaxis, obj});
 
     addlistener (ax, "clim", {@update_colorbar_clim, hi, vertical})
     addlistener (ax, "plotboxaspectratio", {@update_colorbar_axis, cax, obj})
     addlistener (ax, "plotboxaspectratiomode", {@update_colorbar_axis, cax, obj})
@@ -358,35 +358,35 @@ function [pos, cpos, vertical, mirr] = _
       cpos(4) = actual_pos(4) - dy;
     endif
   endif
 
 endfunction
 
 %!demo
 %! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.'); 
+%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
 %! imagesc(x)
 %! colorbar();
 
 %!demo
 %! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.'); 
+%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
 %! imagesc(x)
 %! colorbar("westoutside");
 
 %!demo
 %! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.'); 
+%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
 %! imagesc(x)
 %! colorbar("peer", gca (), "northoutside");
 
 %!demo
 %! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.'); 
+%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
 %! imagesc(x)
 %! colorbar("southoutside");
 
 %!demo
 %! clf
 %! contour(peaks())
 %! colorbar("west");
 
@@ -402,145 +402,145 @@ endfunction
 %! contour(peaks())
 %! colorbar("north");
 %! subplot(2,2,4)
 %! contour(peaks())
 %! colorbar("south");
 
 %!demo
 %! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.'); 
+%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
 %! subplot(2,2,1)
 %! imagesc(x)
 %! colorbar();
 %! subplot(2,2,2)
 %! imagesc(x)
 %! colorbar("westoutside");
 %! subplot(2,2,3)
 %! imagesc(x)
 %! colorbar("northoutside");
 %! subplot(2,2,4)
 %! imagesc(x)
 %! colorbar("southoutside");
 
 %!demo
 %! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.'); 
+%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
 %! subplot(1,2,1)
 %! imagesc(x)
 %! axis square;
 %! colorbar();
 %! subplot(1,2,2)
 %! imagesc(x)
 %! axis square;
 %! colorbar("westoutside");
 
 %!demo
 %! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.'); 
+%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
 %! subplot(1,2,1)
 %! imagesc(x)
 %! axis square;
 %! colorbar("northoutside");
 %! subplot(1,2,2)
 %! imagesc(x)
 %! axis square;
 %! colorbar("southoutside");
 
 %!demo
 %! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.'); 
+%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
 %! subplot(2,1,1)
 %! imagesc(x)
 %! axis square;
 %! colorbar();
 %! subplot(2,1,2)
 %! imagesc(x)
 %! axis square;
 %! colorbar("westoutside");
 
 %!demo
 %! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.'); 
+%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
 %! subplot(2,1,1)
 %! imagesc(x)
 %! axis square;
 %! colorbar("northoutside");
 %! subplot(2,1,2)
 %! imagesc(x)
 %! axis square;
 %! colorbar("southoutside");
 
 %!demo
 %! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.'); 
+%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
 %! subplot(1,2,1)
 %! imagesc(x)
 %! colorbar();
 %! subplot(1,2,2)
 %! imagesc(x)
 %! colorbar("westoutside");
 
 %!demo
 %! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.'); 
+%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
 %! subplot(1,2,1)
 %! imagesc(x)
 %! colorbar("northoutside");
 %! subplot(1,2,2)
 %! imagesc(x)
 %! colorbar("southoutside");
 
 %!demo
 %! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.'); 
+%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
 %! subplot(2,1,1)
 %! imagesc(x)
 %! colorbar();
 %! subplot(2,1,2)
 %! imagesc(x)
 %! colorbar("westoutside");
 
 %!demo
 %! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.'); 
+%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
 %! subplot(2,1,1)
 %! imagesc(x)
 %! colorbar("northoutside");
 %! subplot(2,1,2)
 %! imagesc(x)
 %! colorbar("southoutside");
 
 %!demo
 %! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.'); 
+%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
 %! subplot(1,2,1)
 %! contour(x)
 %! axis square;
 %! colorbar("east");
 %! xlim ([1, 64])
 %! ylim ([1, 64])
 %! subplot(1,2,2)
 %! contour(x)
 %! colorbar("west");
 %! xlim ([1, 64])
 %! ylim ([1, 64])
 
 %!demo
 %! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.'); 
+%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
 %! contour (x)
 %! xlim ([1, 64])
 %! ylim ([1, 64])
 %! colorbar ();
 %! colorbar off
 
 %!demo
 %! clf
-%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.'); 
+%! n = 64; x = kron (1:n,ones(n,1)); x = abs(x - x.');
 %! contour (x)
 %! xlim ([1, 64])
 %! ylim ([1, 64])
 %! colorbar ();
 %! colorbar ();
 
 %!demo
 %! clf
@@ -552,27 +552,27 @@ endfunction
 %! clf
 %! imagesc (log10 (1 ./ hilb (99)));
 %! h = colorbar;
 %! ytick = get(h, "ytick");
 %! set (h, "yticklabel", sprintf ('10^{%g}|', ytick));
 
 %!demo
 %! clf
-%! n=5;x=linspace(0,5,n);y=linspace(0,1,n); 
-%! imagesc(1./hilb(n)); axis equal; colorbar 
+%! n=5;x=linspace(0,5,n);y=linspace(0,1,n);
+%! imagesc(1./hilb(n)); axis equal; colorbar
 
 %!demo
 %! clf
-%! n=5;x=linspace(0,5,n);y=linspace(0,1,n); 
-%! imagesc(x,y,1./hilb(n)); axis equal; colorbar 
+%! n=5;x=linspace(0,5,n);y=linspace(0,1,n);
+%! imagesc(x,y,1./hilb(n)); axis equal; colorbar
 
 %!demo
 %! clf
-%! n=5;x=linspace(0,5,n);y=linspace(0,1,n); 
+%! n=5;x=linspace(0,5,n);y=linspace(0,1,n);
 %! imagesc(y,x,1./hilb(n)); axis equal; colorbar
 ## This requires that the axes position be properly determined for "axes equal"
 
 %!demo
 %! clf
 %! axes
 %! colorbar
 %! hold on
diff --git a/scripts/plot/comet.m b/scripts/plot/comet.m
--- a/scripts/plot/comet.m
+++ b/scripts/plot/comet.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2008-2011 Ben Abbott
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} comet (@var{y})
 ## @deftypefnx {Function File} {} comet (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} comet (@var{x}, @var{y}, @var{p})
 ## @deftypefnx {Function File} {} comet (@var{ax}, @dots{})
-## Produce a simple comet style animation along the trajectory provided by 
+## Produce a simple comet style animation along the trajectory provided by
 ## the input coordinate vectors (@var{x}, @var{y}), where @var{x} will default
 ## to the indices of @var{y}.
 ##
 ## The speed of the comet may be controlled by @var{p}, which represents the
 ## time which passes as the animation passes from one point to the next.  The
 ## default for @var{p} is 0.1 seconds.
 ##
 ## If @var{ax} is specified the animation is produced in that axis rather than
@@ -50,17 +50,17 @@ function comet (varargin)
     x = varargin{1};
     y = varargin{2};
     p = 0.1;
   elseif (nargin == 3)
     x = varargin{1};
     y = varargin{2};
     p = varargin{3};
   endif
-  
+
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
     theaxis = [min(x), max(x), min(y), max(y)];
     num = numel (y);
     dn = round (num/10);
     for n = 1:(num+dn);
diff --git a/scripts/plot/comet3.m b/scripts/plot/comet3.m
--- a/scripts/plot/comet3.m
+++ b/scripts/plot/comet3.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2010-2011 Ben Abbott and John W. Eaton
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} comet3 (@var{z})
 ## @deftypefnx {Function File} {} comet3 (@var{x}, @var{y}, @var{z}, @var{p})
 ## @deftypefnx {Function File} {} comet3 (@var{ax}, @dots{})
-## Produce a simple comet style animation along the trajectory provided by 
+## Produce a simple comet style animation along the trajectory provided by
 ## the input coordinate vectors (@var{x}, @var{y}), where @var{x} will default
 ## to the indices of @var{y}.
 ##
 ## The speed of the comet may be controlled by @var{p}, which represents the
 ## time which passes as the animation passes from one point to the next.  The
 ## default for @var{p} is 0.1 seconds.
 ##
 ## If @var{ax} is specified the animation is produced in that axis rather than
@@ -51,17 +51,17 @@ function comet3 (varargin)
     z = varargin{3};
     p = 0.1;
   elseif (nargin == 4)
     x = varargin{1};
     y = varargin{2};
     z = varargin{3};
     p = varargin{4};
   endif
-  
+
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
     theaxis = [min(x), max(x), min(y), max(y), min(z), max(z)];
     num = numel (y);
     dn = round (num/10);
     for n = 1:(num+dn);
diff --git a/scripts/plot/compass.m b/scripts/plot/compass.m
--- a/scripts/plot/compass.m
+++ b/scripts/plot/compass.m
@@ -19,24 +19,24 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} compass (@var{u}, @var{v})
 ## @deftypefnx {Function File} {} compass (@var{z})
 ## @deftypefnx {Function File} {} compass (@dots{}, @var{style})
 ## @deftypefnx {Function File} {} compass (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} compass (@dots{})
 ##
 ## Plot the @code{(@var{u}, @var{v})} components of a vector field emanating
-## from the origin of a polar plot.  If a single complex argument @var{z} is 
-## given, then @code{@var{u} = real (@var{z})} and @code{@var{v} = imag 
+## from the origin of a polar plot.  If a single complex argument @var{z} is
+## given, then @code{@var{u} = real (@var{z})} and @code{@var{v} = imag
 ## (@var{z})}.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ##
-## The optional return value @var{h} provides a list of handles to the 
+## The optional return value @var{h} provides a list of handles to the
 ## the parts of the vector field (body, arrow and marker).
 ##
 ## @example
 ## @group
 ## a = toeplitz([1;randn(9,1)],[1,randn(1,9)]);
 ## compass (eig (a))
 ## @end group
 ## @end example
@@ -76,18 +76,18 @@ function retval = compass (varargin)
       else
         error ("compass: invalid linespec");
       endif
     else
       error ("compass: unrecognized argument");
     endif
   endwhile
 
-  ## Matlab draws compass plots, with the arrow head as one continous 
-  ## line, and each arrow separately. This is completely different than 
+  ## Matlab draws compass plots, with the arrow head as one continous
+  ## line, and each arrow separately. This is completely different than
   ## quiver and quite ugly.
   n = length (u);
   xend = u;
   xtmp = u .* (1 - arrowsize);
   yend = v;
   ytmp = v .* (1 - arrowsize);
   x = [zeros(1, n); xend; xtmp  - v * arrowsize / 3; xend; ...
        xtmp + v * arrowsize / 3];
diff --git a/scripts/plot/contour.m b/scripts/plot/contour.m
--- a/scripts/plot/contour.m
+++ b/scripts/plot/contour.m
@@ -37,17 +37,17 @@
 ## contour (x, y, z, 2:3)
 ## @end group
 ## @end example
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ## Any markers defined by @var{style} are ignored.
 ##
-## The optional input and output argument @var{h} allows an axis handle to 
+## The optional input and output argument @var{h} allows an axis handle to
 ## be passed to @code{contour} and the handles to the contour objects to be
 ## returned.
 ## @seealso{contourc, patch, plot}
 ## @end deftypefn
 
 ## Author: Shai Ayal <shaiay@users.sourceforge.net>
 
 function [c, h] = contour (varargin)
diff --git a/scripts/plot/contour3.m b/scripts/plot/contour3.m
--- a/scripts/plot/contour3.m
+++ b/scripts/plot/contour3.m
@@ -38,17 +38,17 @@
 ## colormap hot
 ## @end group
 ## @end example
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ## Any markers defined by @var{style} are ignored.
 ##
-## The optional input and output argument @var{h} allows an axis handle to 
+## The optional input and output argument @var{h} allows an axis handle to
 ## be passed to @code{contour} and the handles to the contour objects to be
 ## returned.
 ## @seealso{contourc, patch, plot}
 ## @end deftypefn
 
 function [c, h] = contour3 (varargin)
 
   [xh, varargin, nargin] = __plt_get_axis_arg__ ("contour3", varargin{:});
diff --git a/scripts/plot/contourc.m b/scripts/plot/contourc.m
--- a/scripts/plot/contourc.m
+++ b/scripts/plot/contourc.m
@@ -13,37 +13,37 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{c}, @var{lev}] =} contourc (@var{x}, @var{y}, @var{z}, @var{vn})
-## Compute isolines (contour lines) of the matrix @var{z}. 
+## Compute isolines (contour lines) of the matrix @var{z}.
 ## Parameters @var{x}, @var{y} and @var{vn} are optional.
 ##
 ## The return value @var{lev} is a vector of the contour levels.
 ## The return value @var{c} is a 2 by @var{n} matrix containing the
 ## contour lines in the following format
 ##
 ## @example
 ## @group
-## @var{c} = [lev1, x1, x2, @dots{}, levn, x1, x2, ... 
+## @var{c} = [lev1, x1, x2, @dots{}, levn, x1, x2, ...
 ##      len1, y1, y2, @dots{}, lenn, y1, y2, @dots{}]
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## in which contour line @var{n} has a level (height) of @var{levn} and
 ## length of @var{lenn}.
-## 
-## If @var{x} and @var{y} are omitted they are taken as the row/column 
-## index of @var{z}.  @var{vn} is either a scalar denoting the number of lines 
-## to compute or a vector containing the values of the lines.  If only one 
+##
+## If @var{x} and @var{y} are omitted they are taken as the row/column
+## index of @var{z}.  @var{vn} is either a scalar denoting the number of lines
+## to compute or a vector containing the values of the lines.  If only one
 ## value is wanted, set @code{@var{vn} = [val, val]};
 ## If @var{vn} is omitted it defaults to 10.
 ##
 ## For example:
 ##
 ## @example
 ## @group
 ## x = 0:2;
@@ -96,49 +96,49 @@ function [cout, lev] = contourc (varargi
     vv = linspace (min (z(:)), max (z(:)), vn+2)(2:end-1);
   else
     vv = unique (sort (vn));
   endif
 
   if (isvector (x) && isvector (y))
     c = __contourc__ (x(:)', y(:)', z, vv);
   else
-    ## Indexes x,y for the purpose of __contourc__.    
+    ## Indexes x,y for the purpose of __contourc__.
     ii = 1:size (z,2);
     jj = 1:size (z,1);
-  
+
     ## Now call __contourc__ for the real work...
     c = __contourc__ (ii, jj, z, vv);
-  
-    ## Map the contour lines from index space (i,j) back 
+
+    ## Map the contour lines from index space (i,j) back
     ## to the original grid (x,y)
     i = 1;
 
     while (i < size (c,2))
-      clen = c(2, i);      
+      clen = c(2, i);
       ind = i + [1 : clen];
 
       ci = c(1, ind);
       cj = c(2,ind);
 
       ## due to rounding errors some elements of ci and cj
       ## can fall out of the range of ii and jj and interp2 would
-      ## return NA for those values. 
-      ## The permitted range is enforced here: 
-        
+      ## return NA for those values.
+      ## The permitted range is enforced here:
+
       ci = max (ci, 1); ci = min (ci, size (z, 2));
       cj = max (cj, 1); cj = min (cj, size (z, 1));
-        
+
       c(1, ind) = interp2 (ii, jj, x, ci, cj);
       c(2, ind) = interp2 (ii, jj, y, ci, cj);
-      
+
       i = i + clen + 1;
     endwhile
   endif
-    
+
   if (nargout > 0)
     cout = c;
     lev = vv;
   endif
 
 endfunction
 
 %!test
diff --git a/scripts/plot/cylinder.m b/scripts/plot/cylinder.m
--- a/scripts/plot/cylinder.m
+++ b/scripts/plot/cylinder.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} cylinder
 ## @deftypefnx {Function File} {} cylinder (@var{r})
 ## @deftypefnx {Function File} {} cylinder (@var{r}, @var{n})
 ## @deftypefnx {Function File} {[@var{x}, @var{y}, @var{z}] =} cylinder (@dots{})
 ## @deftypefnx {Function File} {} cylinder (@var{ax}, @dots{})
 ## Generates three matrices in @code{meshgrid} format, such that
 ## @code{surf (@var{x}, @var{y}, @var{z})} generates a unit cylinder.
-## The matrices are of size @code{@var{n}+1}-by-@code{@var{n}+1}. 
+## The matrices are of size @code{@var{n}+1}-by-@code{@var{n}+1}.
 ## @var{r} is a vector containing the radius along the z-axis.
 ## If @var{n} or @var{r} are omitted then default values of 20 or [1 1]
 ## are assumed.
 ##
 ## Called with no return arguments, @code{cylinder} calls directly
 ## @code{surf (@var{x}, @var{y}, @var{z})}.  If an axes handle @var{ax}
 ## is passed as the first argument, the surface is plotted to this set
 ## of axes.
@@ -43,17 +43,17 @@
 ## surf (x, y, z);
 ## @end group
 ## @end example
 ## @seealso{sphere}
 ## @end deftypefn
 
 function [xx, yy, zz] = cylinder (varargin)
 
-  [ax, args, nargs] = __plt_get_axis_arg__ ((nargout > 0), "cylinder", 
+  [ax, args, nargs] = __plt_get_axis_arg__ ((nargout > 0), "cylinder",
                                             varargin{:});
 
   if (nargs == 0)
     n = 20;
     r = [1, 1];
   elseif (nargs == 1)
     n = 20;
     r = args{1};
diff --git a/scripts/plot/daspect.m b/scripts/plot/daspect.m
--- a/scripts/plot/daspect.m
+++ b/scripts/plot/daspect.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2010-2011 Ben Abbott
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} daspect (@var{data_aspect_ratio})
 ## Set the data aspect ratio of the current axes.  The aspect ratio is
-## a normalized 3-element vector representing the span of the x, y, and 
+## a normalized 3-element vector representing the span of the x, y, and
 ## z-axes limits.
 ## @deftypefnx {Function File} {@var{data_aspect_ratio} =} daspect ( )
 ## Return the data aspect ratio of the current axes.
 ## @deftypefnx {Function File} {} daspect (@var{mode})
 ## Set the data aspect ratio mode of the current axes.
 ## @deftypefnx {Function File} {@var{data_aspect_ratio_mode} =} daspect ("mode")
 ## Return the data aspect ratio mode of the current axes.
 ## @deftypefnx {Function File} {} daspect (@var{hax}, @dots{})
diff --git a/scripts/plot/diffuse.m b/scripts/plot/diffuse.m
--- a/scripts/plot/diffuse.m
+++ b/scripts/plot/diffuse.m
@@ -14,45 +14,45 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} diffuse (@var{sx}, @var{sy}, @var{sz}, @var{lv})
 ## Calculate diffuse reflection strength of a surface defined by the normal
-## vector elements @var{sx}, @var{sy}, @var{sz}. 
+## vector elements @var{sx}, @var{sy}, @var{sz}.
 ## The light vector can be specified using parameter @var{lv}.  It can be
 ## given as 2-element vector [azimuth, elevation] in degrees or as 3-element
-## vector [lx, ly, lz]. 
+## vector [lx, ly, lz].
 ## @seealso{specular, surfl}
 ## @end deftypefn
 
 ## Author: Kai Habel <kai.habel@gmx.de>
 
 function retval = diffuse (sx, sy, sz, lv)
 
   if (nargin != 4)
     print_usage ();
   endif
 
   ## check for normal vector
   if (!size_equal (sx, sy, sz))
     error ("diffuse: SX, SY, and SZ must have same size");
   endif
-  
+
   ## check for light vector (lv) argument
   if (length (lv) < 2 || length (lv) > 3)
     error ("diffuse: light vector LV must be a 2- or 3-element vector");
   elseif (length (lv) == 2)
     [lv(1), lv(2), lv(3)] = sph2cart (lv(1) * pi/180, lv(2) * pi/180, 1.0);
   endif
 
   ## Normalize view and light vector.
   if (sum (abs (lv)) > 0)
     lv  /= norm (lv);
   endif
 
   ns = sqrt (sx.^2 + sy.^2 + sz.^2);
   retval = (sx * lv(1) + sy * lv(2) + sz * lv(3)) ./ ns;
   retval(retval < 0) = 0;
-  
+
 endfunction
diff --git a/scripts/plot/ellipsoid.m b/scripts/plot/ellipsoid.m
--- a/scripts/plot/ellipsoid.m
+++ b/scripts/plot/ellipsoid.m
@@ -26,17 +26,17 @@
 ## set of axes.
 ## @seealso{sphere}
 ## @end deftypefn
 
 ## Author: Sylvain Pelissier <sylvain.pelissier@gmail.com>
 
 function [xx, yy, zz] = ellipsoid (varargin)
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout > 0), "ellipsoid", 
+  [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout > 0), "ellipsoid",
                                                 varargin{:});
 
   if (nargin != 6 && nargin != 7)
     print_usage ();
   endif
 
   xc = varargin{1};
   yc = varargin{2};
diff --git a/scripts/plot/errorbar.m b/scripts/plot/errorbar.m
--- a/scripts/plot/errorbar.m
+++ b/scripts/plot/errorbar.m
@@ -143,29 +143,29 @@ endfunction
 %! errorbar (0:10, rand_1x11_data1, 0.25*rand_1x11_data2);
 
 %!demo
 %! rand_1x11_data3 = [0.423650, 0.142331, 0.213195, 0.129301, 0.975891, 0.012872, 0.635327, 0.338829, 0.764997, 0.401798, 0.551850];
 %! rand_1x11_data4 = [0.682566, 0.456342, 0.132390, 0.341292, 0.108633, 0.601553, 0.040455, 0.146665, 0.309187, 0.586291, 0.540149];
 %! errorbar(0:10, rand_1x11_data3, rand_1x11_data4, ">");
 
 %!demo
-%! x = 0:0.5:2*pi; 
-%! err = x/100; 
-%! y1 = sin (x); 
-%! y2 = cos (x); 
+%! x = 0:0.5:2*pi;
+%! err = x/100;
+%! y1 = sin (x);
+%! y2 = cos (x);
 %! hg = errorbar (x, y1, err, "~", x, y2, err, ">");
 
 %!demo
-%! x = 0:0.5:2*pi; 
-%! err = x/100; 
-%! y1 = sin (x); 
-%! y2 = cos (x); 
+%! x = 0:0.5:2*pi;
+%! err = x/100;
+%! y1 = sin (x);
+%! y2 = cos (x);
 %! hg = errorbar (x, y1, err, err, "#r", x, y2, err, err, "#~");
 
 %!demo
-%! x = 0:0.5:2*pi; 
-%! err = x/100; 
-%! y1 = sin (x); 
-%! y2 = cos (x); 
+%! x = 0:0.5:2*pi;
+%! err = x/100;
+%! y1 = sin (x);
+%! y2 = cos (x);
 %! hg = errorbar (x, y1, err, err, err, err, "~>", ...
 %!                x, y2, err, err, err, err, "#~>-*");
 
diff --git a/scripts/plot/ezcontour.m b/scripts/plot/ezcontour.m
--- a/scripts/plot/ezcontour.m
+++ b/scripts/plot/ezcontour.m
@@ -20,27 +20,27 @@
 ## @deftypefn  {Function File} {} ezcontour (@var{f})
 ## @deftypefnx {Function File} {} ezcontour (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezcontour (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezcontour (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezcontour (@dots{})
 ##
 ## Plots the contour lines of a function.  @var{f} is a string, inline function
 ## or function handle with two arguments defining the function.  By default the
-## plot is over the domain @code{-2*pi < @var{x} < 2*pi} and @code{-2*pi < 
-## @var{y} < 2*pi} with 60 points in each dimension. 
+## plot is over the domain @code{-2*pi < @var{x} < 2*pi} and @code{-2*pi <
+## @var{y} < 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
-## The optional return value @var{h} provides a list of handles to the 
+## The optional return value @var{h} provides a list of handles to the
 ## the parts of the vector field (body, arrow and marker).
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezcontour (f, [-3, 3]);
 ## @end group
 ## @end example
diff --git a/scripts/plot/ezcontourf.m b/scripts/plot/ezcontourf.m
--- a/scripts/plot/ezcontourf.m
+++ b/scripts/plot/ezcontourf.m
@@ -18,29 +18,29 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezcontourf (@var{f})
 ## @deftypefnx {Function File} {} ezcontourf (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezcontourf (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezcontourf (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezcontourf (@dots{})
 ##
-## Plots the filled contour lines of a function.  @var{f} is a string, inline 
-## function or function handle with two arguments defining the function.  By 
-## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and 
-## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension. 
+## Plots the filled contour lines of a function.  @var{f} is a string, inline
+## function or function handle with two arguments defining the function.  By
+## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
+## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
-## The optional return value @var{h} provides a list of handles to the 
+## The optional return value @var{h} provides a list of handles to the
 ## the parts of the vector field (body, arrow and marker).
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezcontourf (f, [-3, 3]);
 ## @end group
 ## @end example
diff --git a/scripts/plot/ezmesh.m b/scripts/plot/ezmesh.m
--- a/scripts/plot/ezmesh.m
+++ b/scripts/plot/ezmesh.m
@@ -21,35 +21,35 @@
 ## @deftypefnx {Function File} {} ezmesh (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezmesh (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezmesh (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezmesh (@dots{}, 'circ')
 ## @deftypefnx {Function File} {} ezmesh (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezmesh (@dots{})
 ##
 ## Plots the mesh defined by a function.  @var{f} is a string, inline
-## function or function handle with two arguments defining the function.  By 
+## function or function handle with two arguments defining the function.  By
 ## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
-## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension. 
+## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
-## If three functions are passed, then plot the parametrically defined 
-## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}), 
-## @var{fz} (@var{s}, @var{t})]}. 
+## If three functions are passed, then plot the parametrically defined
+## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
+## @var{fz} (@var{s}, @var{t})]}.
 ##
 ## If the argument 'circ' is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
-## The optional return value @var{h} provides a list of handles to the 
+## The optional return value @var{h} provides a list of handles to the
 ## the parts of the vector field (body, arrow and marker).
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezmesh (f, [-3, 3]);
 ## @end group
 ## @end example
diff --git a/scripts/plot/ezmeshc.m b/scripts/plot/ezmeshc.m
--- a/scripts/plot/ezmeshc.m
+++ b/scripts/plot/ezmeshc.m
@@ -23,33 +23,33 @@
 ## @deftypefnx {Function File} {} ezmeshc (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezmeshc (@dots{}, 'circ')
 ## @deftypefnx {Function File} {} ezmeshc (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezmeshc (@dots{})
 ##
 ## Plots the mesh and contour lines defined by a function.  @var{f} is a string,
 ## inline function or function handle with two arguments defining the function.
 ## By default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
-## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension. 
+## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
-## If three functions are passed, then plot the parametrically defined 
-## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}), 
-## @var{fz} (@var{s}, @var{t})]}. 
+## If three functions are passed, then plot the parametrically defined
+## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
+## @var{fz} (@var{s}, @var{t})]}.
 ##
 ## If the argument 'circ' is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
-## The optional return value @var{h} provides a list of handles to the 
+## The optional return value @var{h} provides a list of handles to the
 ## the parts of the vector field (body, arrow and marker).
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezmeshc (f, [-3, 3]);
 ## @end group
 ## @end example
diff --git a/scripts/plot/ezplot.m b/scripts/plot/ezplot.m
--- a/scripts/plot/ezplot.m
+++ b/scripts/plot/ezplot.m
@@ -21,19 +21,19 @@
 ## @deftypefnx {Function File} {} ezplot (@var{fx}, @var{fy})
 ## @deftypefnx {Function File} {} ezplot (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezplot (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezplot (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezplot (@dots{})
 ##
 ## Plots in two-dimensions the curve defined by @var{f}.  The function
 ## @var{f} may be a string, inline function or function handle and can
-## have either one or two variables.  If @var{f} has one variable, then 
-## the function is plotted over the domain @code{-2*pi < @var{x} < 2*pi}  
-## with 500 points. 
+## have either one or two variables.  If @var{f} has one variable, then
+## the function is plotted over the domain @code{-2*pi < @var{x} < 2*pi}
+## with 500 points.
 ##
 ## If @var{f} has two variables then @code{@var{f}(@var{x},@var{y}) = 0}
 ## is calculated over the meshed domain @code{-2*pi < @var{x} | @var{y}
 ## < 2*pi} with 60 by 60 in the mesh.  For example:
 ##
 ## @example
 ## ezplot (@@(@var{x}, @var{y}) @var{x} .^ 2 - @var{y} .^ 2 - 1)
 ## @end example
@@ -45,28 +45,28 @@
 ## @group
 ## @var{x} = @var{fx} (@var{t})
 ## @var{y} = @var{fy} (@var{t})
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## is plotted over the domain @code{-2*pi < @var{t} < 2*pi} with 500
-## points. 
+## points.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of @var{x}, @var{y} and @var{t}.  If it is a four element
 ## vector, then the minimum and maximum values of @var{x} and @var{t}
 ## are determined by the first two elements and the minimum and maximum
 ## of @var{y} by the second pair of elements.
 ##
 ## @var{n} is a scalar defining the number of points to use in plotting
 ## the function.
 ##
-## The optional return value @var{h} provides a list of handles to the 
+## The optional return value @var{h} provides a list of handles to the
 ## the line objects plotted.
 ##
 ## @seealso{plot, ezplot3}
 ## @end deftypefn
 
 function retval = ezplot (varargin)
 
   [h, needusage] = __ezplot__ ("plot", varargin{:});
diff --git a/scripts/plot/ezplot3.m b/scripts/plot/ezplot3.m
--- a/scripts/plot/ezplot3.m
+++ b/scripts/plot/ezplot3.m
@@ -18,26 +18,26 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezplot3 (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezplot3 (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezplot3 (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezplot3 (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezplot3 (@dots{})
 ##
-## Plots in three-dimensions the curve defined parametrically. 
+## Plots in three-dimensions the curve defined parametrically.
 ## @var{fx}, @var{fy}, and @var{fz} are strings, inline functions
-## or function handles with one arguments defining the function.  By 
-## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi}  
-## with 60 points. 
+## or function handles with one arguments defining the function.  By
+## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi}
+## with 60 points.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of @var{t}.  @var{n} is a scalar defining the number of points to use.
 ##
-## The optional return value @var{h} provides a list of handles to the 
+## The optional return value @var{h} provides a list of handles to the
 ## the parts of the vector field (body, arrow and marker).
 ##
 ## @example
 ## @group
 ## fx = @@(t) cos (t);
 ## fy = @@(t) sin (t);
 ## fz = @@(t) t;
 ## ezplot3 (fx, fy, fz, [0, 10*pi], 100);
diff --git a/scripts/plot/ezpolar.m b/scripts/plot/ezpolar.m
--- a/scripts/plot/ezpolar.m
+++ b/scripts/plot/ezpolar.m
@@ -19,25 +19,25 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ezpolar (@var{f})
 ## @deftypefnx {Function File} {} ezpolar (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezpolar (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezpolar (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezpolar (@dots{})
 ##
 ## Plots in polar plot defined by a function.  The function @var{f} is either
-## a string, inline function or function handle with one arguments defining 
-## the function.  By default the plot is over the domain @code{0 < @var{x} < 
-## 2*pi} with 60 points. 
+## a string, inline function or function handle with one arguments defining
+## the function.  By default the plot is over the domain @code{0 < @var{x} <
+## 2*pi} with 60 points.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
-## value of both @var{t}.  @var{n} is a scalar defining the number of points to 
+## value of both @var{t}.  @var{n} is a scalar defining the number of points to
 ## use.
 ##
-## The optional return value @var{h} provides a list of handles to the 
+## The optional return value @var{h} provides a list of handles to the
 ## the parts of the vector field (body, arrow and marker).
 ##
 ## @example
 ## ezpolar (@@(t) 1 + sin (t));
 ## @end example
 ##
 ## @seealso{polar, ezplot, ezsurf, ezmesh}
 ## @end deftypefn
diff --git a/scripts/plot/ezsurf.m b/scripts/plot/ezsurf.m
--- a/scripts/plot/ezsurf.m
+++ b/scripts/plot/ezsurf.m
@@ -21,35 +21,35 @@
 ## @deftypefnx {Function File} {} ezsurf (@var{fx}, @var{fy}, @var{fz})
 ## @deftypefnx {Function File} {} ezsurf (@dots{}, @var{dom})
 ## @deftypefnx {Function File} {} ezsurf (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezsurf (@dots{}, 'circ')
 ## @deftypefnx {Function File} {} ezsurf (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezsurf (@dots{})
 ##
 ## Plots the surface defined by a function.  @var{f} is a string, inline
-## function or function handle with two arguments defining the function.  By 
+## function or function handle with two arguments defining the function.  By
 ## default the plot is over the domain @code{-2*pi < @var{x} < 2*pi} and
-## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension. 
+## @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
-## If three functions are passed, then plot the parametrically defined 
-## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}), 
-## @var{fz} (@var{s}, @var{t})]}. 
+## If three functions are passed, then plot the parametrically defined
+## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
+## @var{fz} (@var{s}, @var{t})]}.
 ##
 ## If the argument 'circ' is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
-## The optional return value @var{h} provides a list of handles to the 
+## The optional return value @var{h} provides a list of handles to the
 ## the parts of the vector field (body, arrow and marker).
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezsurf (f, [-3, 3]);
 ## @end group
 ## @end example
diff --git a/scripts/plot/ezsurfc.m b/scripts/plot/ezsurfc.m
--- a/scripts/plot/ezsurfc.m
+++ b/scripts/plot/ezsurfc.m
@@ -23,33 +23,33 @@
 ## @deftypefnx {Function File} {} ezsurfc (@dots{}, @var{n})
 ## @deftypefnx {Function File} {} ezsurfc (@dots{}, 'circ')
 ## @deftypefnx {Function File} {} ezsurfc (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} ezsurfc (@dots{})
 ##
 ## Plots the surface and contour lines defined by a function.  @var{f} is a
 ## string, inline function or function handle with two arguments defining the
 ## function.  By default the plot is over the domain @code{-2*pi < @var{x} <
-## 2*pi} and @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension. 
+## 2*pi} and @code{-2*pi < @var{y} < 2*pi} with 60 points in each dimension.
 ##
 ## If @var{dom} is a two element vector, it represents the minimum and maximum
 ## value of both @var{x} and @var{y}.  If @var{dom} is a four element vector,
 ## then the minimum and maximum value of @var{x} and @var{y} are specify
 ## separately.
 ##
 ## @var{n} is a scalar defining the number of points to use in each dimension.
 ##
-## If three functions are passed, then plot the parametrically defined 
-## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}), 
-## @var{fz} (@var{s}, @var{t})]}. 
+## If three functions are passed, then plot the parametrically defined
+## function @code{[@var{fx} (@var{s}, @var{t}), @var{fy} (@var{s}, @var{t}),
+## @var{fz} (@var{s}, @var{t})]}.
 ##
 ## If the argument 'circ' is given, then the function is plotted over a disk
 ## centered on the middle of the domain @var{dom}.
 ##
-## The optional return value @var{h} provides a list of handles to the 
+## The optional return value @var{h} provides a list of handles to the
 ## the parts of the vector field (body, arrow and marker).
 ##
 ## @example
 ## @group
 ## f = @@(x,y) sqrt(abs(x .* y)) ./ (1 + x.^2 + y.^2);
 ## ezsurfc (f, [-3, 3]);
 ## @end group
 ## @end example
diff --git a/scripts/plot/feather.m b/scripts/plot/feather.m
--- a/scripts/plot/feather.m
+++ b/scripts/plot/feather.m
@@ -26,17 +26,17 @@
 ## Plot the @code{(@var{u}, @var{v})} components of a vector field emanating
 ## from equidistant points on the x-axis.  If a single complex argument
 ## @var{z} is given, then @code{@var{u} = real (@var{z})} and
 ## @code{@var{v} = imag (@var{z})}.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ##
-## The optional return value @var{h} provides a list of handles to the 
+## The optional return value @var{h} provides a list of handles to the
 ## the parts of the vector field (body, arrow and marker).
 ##
 ## @example
 ## @group
 ## phi = [0 : 15 : 360] * pi / 180;
 ## feather (sin (phi), cos (phi))
 ## @end group
 ## @end example
@@ -76,18 +76,18 @@ function retval = feather (varargin)
       else
         error ("feather: invalid linespec");
       endif
     else
       error ("feather: unrecognized argument");
     endif
   endwhile
 
-  ## Matlab draws feather plots, with the arrow head as one continous 
-  ## line, and each arrow separately. This is completely different than 
+  ## Matlab draws feather plots, with the arrow head as one continous
+  ## line, and each arrow separately. This is completely different than
   ## quiver and quite ugly.
   n = length (u);
   xend = [1 : n] + u;
   xtmp = [1 : n] + u .* (1 - arrowsize);
   yend = v;
   ytmp = v .* (1 - arrowsize);
   x = [[1 : n]; xend; xtmp  - v * arrowsize; xend; ...
        xtmp + v * arrowsize];
diff --git a/scripts/plot/findobj.m b/scripts/plot/findobj.m
--- a/scripts/plot/findobj.m
+++ b/scripts/plot/findobj.m
@@ -26,41 +26,41 @@
 ## @deftypefnx {Function File} {@var{h} =} findobj (@var{h}, '-depth', @var{d}, @dots{})
 ## Find object with specified property values.  The simplest form is
 ##
 ## @example
 ## findobj (@var{prop_name}, @var{prop_Value})
 ## @end example
 ##
 ## @noindent
-## which returns all of the handles to the objects with the name 
+## which returns all of the handles to the objects with the name
 ## @var{prop_name} and the name @var{prop_Value}.  The search can be limited
-## to a particular object or set of objects and their descendants by 
-## passing a handle or set of handles @var{h} as the first argument to 
+## to a particular object or set of objects and their descendants by
+## passing a handle or set of handles @var{h} as the first argument to
 ## @code{findobj}.
 ##
 ## The depth of hierarchy of objects to which to search to can be limited
 ## with the '-depth' argument.  To limit the number depth of the hierarchy
 ## to search to @var{d} generations of children, and example is
 ##
 ## @example
 ## findobj (@var{h}, '-depth', @var{d}, @var{prop_Name}, @var{prop_Value})
 ## @end example
 ##
 ## Specifying a depth @var{d} of 0, limits the search to the set of object
 ## passed in @var{h}.  A depth @var{d} of 0 is equivalent to the '-flat'
-## argument. 
+## argument.
 ##
 ## A specified logical operator may be applied to the pairs of @var{prop_Name}
-## and @var{prop_Value}.  The supported logical operators are '-and', '-or', 
+## and @var{prop_Value}.  The supported logical operators are '-and', '-or',
 ## '-xor', '-not'.
 ##
-## The objects may also be matched by comparing a regular expression to the 
-## property values, where property values that match @code{regexp 
-## (@var{prop_Value}, @var{pattern})} are returned.  Finally, objects may be 
+## The objects may also be matched by comparing a regular expression to the
+## property values, where property values that match @code{regexp
+## (@var{prop_Value}, @var{pattern})} are returned.  Finally, objects may be
 ## matched by property name only, using the '-property' option.
 ## @seealso{get, set}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 
 function h = findobj (varargin)
 
@@ -180,25 +180,25 @@ function h = findobj (varargin)
         na = na + 1;
       endif
     else
       error ("findobj: properties and options must be strings");
     endif
   endwhile
 
   numpairs = np - 1;
-  
+
   ## Load all objects which qualify for being searched.
   idepth = 0;
   h = handles;
   while (numel (handles) && ! (idepth >= depth))
     children = [];
     for n = 1 : numel (handles)
       children = union (children, get(handles(n), "children"));
-    endfor 
+    endfor
     handles = children;
     h = union (h, children);
     idepth = idepth + 1;
   endwhile
 
   keepers = ones (size (h));
   if (numpairs > 0)
     for nh = 1 : numel(h)
diff --git a/scripts/plot/fplot.m b/scripts/plot/fplot.m
--- a/scripts/plot/fplot.m
+++ b/scripts/plot/fplot.m
@@ -21,17 +21,17 @@
 ## @deftypefnx {Function File} {} fplot (@var{fn}, @var{limits}, @var{tol})
 ## @deftypefnx {Function File} {} fplot (@var{fn}, @var{limits}, @var{n})
 ## @deftypefnx {Function File} {} fplot (@dots{}, @var{fmt})
 ## Plot a function @var{fn}, within the defined limits.  @var{fn}
 ## an be either a string, a function handle or an inline function.
 ## The limits of the plot are given by @var{limits} of the form
 ## @code{[@var{xlo}, @var{xhi}]} or @code{[@var{xlo}, @var{xhi},
 ## @var{ylo}, @var{yhi}]}.  @var{tol} is the default tolerance to use for the
-## plot, and if @var{tol} is an integer it is assumed that it defines the 
+## plot, and if @var{tol} is an integer it is assumed that it defines the
 ## number points to use in the plot.  The @var{fmt} argument is passed
 ## to the plot command.
 ##
 ## @example
 ## @group
 ##    fplot ("cos", [0, 2*pi])
 ##    fplot ("[cos(x), sin(x)]", [0, 2*pi])
 ## @end group
@@ -45,22 +45,22 @@ function fplot (fn, limits, n, fmt)
   if (nargin < 2 || nargin > 4)
     print_usage ();
   endif
 
   if (!isreal (limits) || (numel (limits) != 2 && numel (limits) != 4))
     error ("fplot: second input argument must be a real vector with 2 or 4 elements");
   endif
 
-  if (nargin < 3) 
-    n = 0.002; 
+  if (nargin < 3)
+    n = 0.002;
   endif
 
   have_linespec = true;
-  if (nargin < 4) 
+  if (nargin < 4)
     have_linespec = false;
   endif
 
   if (ischar (n))
     have_linespec = true;
     fmt = n;
     n = 0.002;
   endif
@@ -95,29 +95,29 @@ function fplot (fn, limits, n, fmt)
         break;
       endif
       x0 = x;
       y0 = y;
       err0 = err;
       n = 2 * (n - 1) + 1;
       x = linspace (limits(1), limits(2), n)';
       y = feval (fn, x);
-    endwhile 
+    endwhile
   else
     x = linspace (limits(1), limits(2), n)';
     y = feval (fn, x);
   endif
 
   if (have_linespec)
     plot (x, y, fmt);
   else
     plot (x, y);
   endif
 
-  if (length (limits) > 2) 
+  if (length (limits) > 2)
     axis (limits);
   endif
 
   if (isvector (y))
     legend (nam);
   else
     for i = 1:columns (y)
       nams{i} = sprintf ("%s(:,%i)", nam, i);
diff --git a/scripts/plot/gnuplot_drawnow.m b/scripts/plot/gnuplot_drawnow.m
--- a/scripts/plot/gnuplot_drawnow.m
+++ b/scripts/plot/gnuplot_drawnow.m
@@ -118,21 +118,21 @@ function enhanced = gnuplot_set_term (pl
   ## When "term" originates from print.m, it may include other options.
   if (nargin < 4)
     ## This supports the gnuplot graphics toolkit.
     term = gnuplot_default_term ();
     opts_str = "";
   else
     ## Get the one word terminal id and save the remaining as options to
     ## be passed on to gnuplot.  The terminal may respect the graphics
-    ## toolkit. 
+    ## toolkit.
     [term, opts_str] = gnuplot_trim_term (term);
     term = lower (term);
     if (strcmpi (term, "lua"))
-      ## Replace "lau tikz" with 
+      ## Replace "lau tikz" with
       term = "tikz";
       opts_str = strrep (opts_str, "tikz", "");
     endif
   endif
 
   if (strfind (opts_str, "noenhanced"))
     enhanced = false;
   else
@@ -164,25 +164,25 @@ function enhanced = gnuplot_set_term (pl
         elseif (! isempty (fig.name) && isempty (title_str))
           title_str = fig.name;
         endif
         if (! isempty (title_str))
           title_str = sprintf ("title \"%s\"", title_str);
         endif
         if (strcmp (term, "aqua"))
           ## Adjust axes-label and tick-label spacing.
-          opts_str = sprintf ("%s font \"%s,%d\"", opts_str, 
+          opts_str = sprintf ("%s font \"%s,%d\"", opts_str,
                               get (0, "defaultaxesfontname"),
                               get (0, "defaultaxesfontsize") / 1.5);
         endif
       else
         title_str = "";
       endif
 
-      if (! (any (strfind (opts_str, " size ") > 0) 
+      if (! (any (strfind (opts_str, " size ") > 0)
           || any (strfind (opts_str, "size ") == 1)))
         ## Get figure size in pixels.  Rely on listener to handle coversion.
         units = get (h, "units");
         unwind_protect
           set (h, "units", "pixels");
           position_in_pixels = get (h, "position");
         unwind_protect_cleanup
           set (h, "units", units);
@@ -240,17 +240,17 @@ function enhanced = gnuplot_set_term (pl
             unwind_protect_cleanup
               set (0, "units", units);
             end_unwind_protect
             if (all (screen_size > 0))
               ## For X11, set the figure positon as well as the size
               ## gnuplot position is UL, Octave's is LL (same for screen/window)
               gnuplot_pos(2) = screen_size(2) - gnuplot_pos(2) - gnuplot_size(2);
               gnuplot_pos = max (gnuplot_pos, 1);
-              size_str = sprintf ("%s position %d,%d", size_str, 
+              size_str = sprintf ("%s position %d,%d", size_str,
                                   gnuplot_pos(1), gnuplot_pos(2));
             endif
           endif
         else
           size_str = "";
           warning ("gnuplot_set_term: size is zero")
         endif
       else
diff --git a/scripts/plot/gtext.m b/scripts/plot/gtext.m
--- a/scripts/plot/gtext.m
+++ b/scripts/plot/gtext.m
@@ -39,15 +39,15 @@ function gtext (s, varargin)
     endif
     if (ischar (s))
       if (! isempty (s))
         [x, y] = ginput (1);
         text (x, y, s, varargin{:});
       endif
     else
       error ("gtext: expecting a string or cell array of strings");
-    endif 
+    endif
   else
     print_usage ();
   endif
 
 endfunction
 
diff --git a/scripts/plot/hist.m b/scripts/plot/hist.m
--- a/scripts/plot/hist.m
+++ b/scripts/plot/hist.m
@@ -21,37 +21,37 @@
 ## @deftypefnx {Function File} {} hist (@var{y}, @var{x})
 ## @deftypefnx {Function File} {} hist (@var{y}, @var{nbins})
 ## @deftypefnx {Function File} {} hist (@var{y}, @var{x}, @var{norm})
 ## @deftypefnx {Function File} {[@var{nn}, @var{xx}] =} hist (@dots{})
 ## @deftypefnx {Function File} {[@dots{}] =} hist (@dots{}, @var{prop}, @var{val})
 ##
 ## Produce histogram counts or plots.
 ##
-## With one vector input argument, @var{y}, plot a histogram of the values 
-## with 10 bins.  The range of the histogram bins is determined by the 
+## With one vector input argument, @var{y}, plot a histogram of the values
+## with 10 bins.  The range of the histogram bins is determined by the
 ## range of the data.  With one matrix input argument, @var{y}, plot a
 ## histogram where each bin contains a bar per input column.
 ##
 ## Given a second vector argument, @var{x}, use that as the centers of
-## the bins, with the width of the bins determined from the adjacent 
+## the bins, with the width of the bins determined from the adjacent
 ## values in the vector.
 ##
 ## If scalar, the second argument, @var{nbins}, defines the number of bins.
 ##
 ## If a third argument is provided, the histogram is normalized such that
 ## the sum of the bars is equal to @var{norm}.
 ##
 ## Extreme values are lumped in the first and last bins.
 ##
 ## With two output arguments, produce the values @var{nn} and @var{xx} such
 ## that @code{bar (@var{xx}, @var{nn})} will plot the histogram.
 ##
 ## The histogram's appearance may be modified by specifying property/value
-## pairs, @var{prop} and @var{val} pairs.  For example the face and edge 
+## pairs, @var{prop} and @var{val} pairs.  For example the face and edge
 ## color may be modified.
 ##
 ## @example
 ## @group
 ## hist (randn (1, 100), 25, "facecolor", "r", "edgecolor", "b")
 ## @end group
 ## @end example
 ##
diff --git a/scripts/plot/hold.m b/scripts/plot/hold.m
--- a/scripts/plot/hold.m
+++ b/scripts/plot/hold.m
@@ -17,18 +17,18 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Command} {} hold
 ## @deftypefnx {Command} {} hold @var{state}
 ## @deftypefnx {Function File} {} hold (@var{hax}, @dots{})
 ## Toggle or set the 'hold' state of the plotting engine which determines
 ## whether new graphic objects are added to the plot or replace the existing
-## objects.  
-## 
+## objects.
+##
 ## @table @code
 ## @item hold on
 ## Retain plot data and settings so that subsequent plot commands are displayed
 ## on a single graph.
 ##
 ## @item hold all
 ## Retain plot line color, line style, data and settings so that subsequent
 ## plot commands are displayed on a single graph with the next line color and
@@ -36,17 +36,17 @@
 ##
 ## @item hold off
 ## Clear plot and restore default graphics settings before each new plot
 ## command.  (default).
 ##
 ## @item hold
 ## Toggle the current 'hold' state.
 ## @end table
-## 
+##
 ## When given the additional argument @var{hax}, the hold state is modified
 ## only for the given axis handle.
 ##
 ## To query the current 'hold' state use the @code{ishold} function.
 ## @seealso{ishold, cla, newplot, clf}
 ## @end deftypefn
 
 function hold (varargin)
diff --git a/scripts/plot/ishghandle.m b/scripts/plot/ishghandle.m
--- a/scripts/plot/ishghandle.m
+++ b/scripts/plot/ishghandle.m
@@ -17,12 +17,12 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} ishghandle (@var{h})
 ## Return true if @var{h} is a graphics handle and false otherwise.
 ## @end deftypefn
 
 function retval = ishghandle (h)
-  ## This function is just included for compatibility as Octave has 
+  ## This function is just included for compatibility as Octave has
   ## no simulink equivalent.
   retval = ishandle (h);
 endfunction
diff --git a/scripts/plot/isocolors.m b/scripts/plot/isocolors.m
--- a/scripts/plot/isocolors.m
+++ b/scripts/plot/isocolors.m
@@ -23,17 +23,17 @@
 ## @deftypefnx {Function File} {[@var{cd}] =} isocolors (@var{r}, @var{g}, @var{b}, @var{v})
 ## @deftypefnx {Function File} {[@var{cd}] =} isocolors (@dots{}, @var{p})
 ## @deftypefnx {Function File} isocolors (@dots{})
 ##
 ## If called with one output argument and the first input argument
 ## @var{c} is a three--dimensional array that contains color values and
 ## the second input argument @var{v} keeps the vertices of a geometry
 ## then return a matrix @var{cd} with color data information for the
-## geometry at computed points 
+## geometry at computed points
 ## @command{[x, y, z] = meshgrid (1:l, 1:m, 1:n)}.  The output argument
 ## @var{cd} can be taken to manually set FaceVertexCData of a patch.
 ##
 ## If called with further input arguments @var{x}, @var{y} and @var{z}
 ## which are three--dimensional arrays of the same size than @var{c}
 ## then the color data is taken at those given points.  Instead of the
 ## color data @var{c} this function can also be called with RGB values
 ## @var{r}, @var{g}, @var{b}.  If input argumnets @var{x}, @var{y},
@@ -51,45 +51,45 @@
 ## @example
 ## function [] = isofinish (p)
 ##   set (gca, "PlotBoxAspectRatioMode", "manual", \
 ##        "PlotBoxAspectRatio", [1 1 1]);
 ##   set (p, "FaceColor", "interp");
 ##   ## set (p, "FaceLighting", "flat");
 ##   ## light ("Position", [1 1 5]); ## Available with JHandles
 ## endfunction
-## 
+##
 ## N = 15;    ## Increase number of vertices in each direction
 ## iso = .4;  ## Change isovalue to .1 to display a sphere
 ## lin = linspace (0, 2, N);
 ## [x, y, z] = meshgrid (lin, lin, lin);
-## c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2); 
+## c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
 ## figure (); ## Open another figure window
 ##
-## subplot (2, 2, 1); view (-38, 20); 
+## subplot (2, 2, 1); view (-38, 20);
 ## [f, v] = isosurface (x, y, z, c, iso);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
 ## cdat = rand (size (c));       ## Compute random patch color data
 ## isocolors (x, y, z, cdat, p); ## Directly set colors of patch
 ## isofinish (p);                ## Call user function isofinish
 ##
-## subplot (2, 2, 2); view (-38, 20); 
+## subplot (2, 2, 2); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
 ## [r, g, b] = meshgrid (lin, 2-lin, 2-lin);
 ## cdat = isocolors (x, y, z, c, v); ## Compute color data vertices
 ## set (p, "FaceVertexCData", cdat); ## Set color data manually
 ## isofinish (p);
 ##
-## subplot (2, 2, 3); view (-38, 20); 
+## subplot (2, 2, 3); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
 ## cdat = isocolors (r, g, b, c, p); ## Compute color data patch
 ## set (p, "FaceVertexCData", cdat); ## Set color data manually
 ## isofinish (p);
 ##
-## subplot (2, 2, 4); view (-38, 20); 
+## subplot (2, 2, 4); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
 ## r = g = b = repmat ([1:N] / N, [N, 1, N]); ## Black to white
 ## cdat = isocolors (x, y, z, r, g, b, v);
 ## set (p, "FaceVertexCData", cdat);
 ## isofinish (p);
 ## @end example
 ##
 ## @seealso{isosurface, isonormals, isocaps}
@@ -126,17 +126,17 @@ function varargout = isocolors(varargin)
       calc_rgb = true;
       x = varargin{1};
       y = varargin{2};
       z = varargin{3};
       R = varargin{4};
       G = varargin{5};
       B = varargin{6};
       vp = varargin{7};
-    otherwise 
+    otherwise
       print_usage ();
   endswitch
   if (ismatrix (vp) && size (vp,2) == 3)
     pa = [];
     v = vp;
   elseif ( ishandle (vp) )
     pa = vp;
     v = get (pa, "Vertices");
@@ -160,13 +160,13 @@ function varargout = isocolors(varargin)
       varargout = {new_col};
     otherwise
       print_usage ();
   endswitch
 endfunction
 
 %!test
 %!  [x, y, z] = meshgrid (0:.5:2, 0:.5:2, 0:.5:2);
-%!  c = (x-.5).^2 + (y-.5).^2 + (z-.5).^2; 
+%!  c = (x-.5).^2 + (y-.5).^2 + (z-.5).^2;
 %!  [f, v] = isosurface (x, y, z, c, .4);
 %!  cdat = isocolors (x, y, z, c, v);
 %!  assert (size (cdat, 1) == size (v, 1));
 ## Can't create a patch handle for tests without a figure
diff --git a/scripts/plot/isonormals.m b/scripts/plot/isonormals.m
--- a/scripts/plot/isonormals.m
+++ b/scripts/plot/isonormals.m
@@ -113,17 +113,17 @@ function varargout = isonormals(varargin
       y = 1:size (c, 1);
       z = 1:size (c, 3);
     case 5
       x = varargin{1};
       y = varargin{2};
       z = varargin{3};
       c = varargin{4};
       vp = varargin{5};
-    otherwise 
+    otherwise
       print_usage ();
   endswitch
   if (ismatrix (vp) && size (vp,2) == 3)
     pa = [];
     v = vp;
   elseif (ishandle (vp))
     pa = vp;
     v = get (pa, "Vertices");
@@ -144,19 +144,19 @@ function varargout = isonormals(varargin
       varargout = {normals};
     otherwise
       print_usage ();
   endswitch
 endfunction
 
 %!test
 %!  [x, y, z] = meshgrid (0:.5:2, 0:.5:2, 0:.5:2);
-%!  c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2); 
+%!  c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
 %!  [f, v, cdat] = isosurface (x, y, z, c, .4, y);
 %!  n = isonormals (x, y, z, c, v);
 %!  assert (size (v), size (n));
 %!test
 %!  [x, y, z] = meshgrid (0:.5:2, 0:.5:2, 0:.5:2);
-%!  c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2); 
+%!  c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
 %!  [f, v, cdat] = isosurface (x, y, z, c, .4, y);
 %!  np = isonormals (x, y, z, c, v);
 %!  nn = isonormals (x, y, z, c, v, "negate");
 %!  assert (all (np == -nn));
diff --git a/scripts/plot/isosurface.m b/scripts/plot/isosurface.m
--- a/scripts/plot/isosurface.m
+++ b/scripts/plot/isosurface.m
@@ -26,17 +26,17 @@
 ## @deftypefnx {Function File} {} isosurface (@var{x}, @var{y}, @var{z}, @var{val}, @var{iso}, @var{col}, @var{opt})
 ##
 ## If called with one output argument and the first input argument
 ## @var{val} is a three--dimensional array that contains the data of an
 ## isosurface geometry and the second input argument @var{iso} keeps the
 ## isovalue as a scalar value then return a structure array @var{fv}
 ## that contains the fields @var{Faces} and @var{Vertices} at computed
 ## points @command{[x, y, z] = meshgrid (1:l, 1:m, 1:n)}.  The output
-## argument @var{fv} can directly be taken as an input argument for the 
+## argument @var{fv} can directly be taken as an input argument for the
 ## @command{patch} function.
 ##
 ## If called with further input arguments @var{x}, @var{y} and @var{z}
 ## which are three--dimensional arrays with the same size than @var{val}
 ## then the volume data is taken at those given points.
 ##
 ## The string input argument "noshare" is only for compatibility and
 ## has no effect.  If given the string input argument
@@ -71,20 +71,20 @@
 ## Another example for an isosurface geometry with different additional
 ## coloring
 ##
 ## @example
 ## N = 15;    ## Increase number of vertices in each direction
 ## iso = .4;  ## Change isovalue to .1 to display a sphere
 ## lin = linspace (0, 2, N);
 ## [x, y, z] = meshgrid (lin, lin, lin);
-## c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2); 
+## c = abs ((x-.5).^2 + (y-.5).^2 + (z-.5).^2);
 ## figure (); ## Open another figure window
 ##
-## subplot (2, 2, 1); view (-38, 20); 
+## subplot (2, 2, 1); view (-38, 20);
 ## [f, v] = isosurface (x, y, z, c, iso);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "none");
 ## set (gca, "PlotBoxAspectRatioMode","manual", "PlotBoxAspectRatio", [1 1 1]);
 ## # set (p, "FaceColor", "green", "FaceLighting", "phong");
 ## # light ("Position", [1 1 5]); ## Available with the JHandles package
 ##
 ## subplot (2, 2, 2); view (-38, 20);
 ## p = patch ("Faces", f, "Vertices", v, "EdgeColor", "blue");
@@ -147,31 +147,31 @@ function varargout = isosurface(varargin
   if (calc_colors)
     if (nargout == 2)
       warning ( "Colors will be calculated, but you did not specify an output argument for it!" );
     endif
     [fvc.faces, fvc.vertices, fvc.facevertexcdata] = __marching_cube__ (x, y, z, val, iso, colors);
   else
     [fvc.faces, fvc.vertices] = __marching_cube__ (x, y, z, val, iso);
   endif
-  
+
   if (isempty (fvc.vertices) || isempty (fvc.faces))
     warning ( "The resulting triangulation is empty" );
   endif
 
   switch (nargout)
     case 0
       ## plot the calculated surface
       newplot ();
       if (calc_colors)
         pa = patch ("Faces", fvc.faces, "Vertices", fvc.vertices,
-                    "FaceVertexCData", fvc.facevertexcdata, 
+                    "FaceVertexCData", fvc.facevertexcdata,
                     "FaceColor", "flat", "EdgeColor", "none");
       else
-        pa = patch ("Faces", fvc.faces, "Vertices", fvc.vertices, 
+        pa = patch ("Faces", fvc.faces, "Vertices", fvc.vertices,
                     "FaceColor", "g", "EdgeColor", "k");
       endif
       if (! ishold ())
         set (gca(), "view", [-37.5, 30],
              "xgrid", "on", "ygrid", "on", "zgrid", "on");
       endif
     case 1
       varargout = {fvc};
@@ -213,9 +213,9 @@ endfunction
 %!  assert (size (f), [1 3]);
 %!  assert (size (v), [3 3]);
 %!  assert (size (c), [3 1]);
 
 %!demo
 %! clf
 %! [x,y,z] = meshgrid(-2:0.5:2, -2:0.5:2, -2:0.5:2);
 %! v = x.^2 + y.^2 + z.^2;
-%! isosurface (x, y, z, v, 1) 
+%! isosurface (x, y, z, v, 1)
diff --git a/scripts/plot/isprop.m b/scripts/plot/isprop.m
--- a/scripts/plot/isprop.m
+++ b/scripts/plot/isprop.m
@@ -24,17 +24,17 @@
 
 ## Author: Ben Abbott  <bpabbott@mac.com>
 
 function res = isprop (h, prop)
   ## Check input
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
- 
+
   if (! ishandle (h))
     error ("isprop: first input argument must be a handle");
   elseif (! ischar (prop))
     error ("isprop: second input argument must be string");
   endif
 
   res = true;
   try
diff --git a/scripts/plot/legend.m b/scripts/plot/legend.m
--- a/scripts/plot/legend.m
+++ b/scripts/plot/legend.m
@@ -23,17 +23,17 @@
 ## @deftypefnx {Function File} {} legend (@dots{}, "location", @var{pos})
 ## @deftypefnx {Function File} {} legend (@dots{}, "orientation", @var{orient})
 ## @deftypefnx {Function File} {} legend (@var{hax}, @dots{})
 ## @deftypefnx {Function File} {} legend (@var{hobjs}, @dots{})
 ## @deftypefnx {Function File} {} legend (@var{hax}, @var{hobjs}, @dots{})
 ## @deftypefnx {Function File} {} legend ("@var{option}")
 ##
 ## Display a legend for the axes with handle @var{hax}, or the current axes,
-## using the specified strings as labels.  Legend entries may be specified 
+## using the specified strings as labels.  Legend entries may be specified
 ## as individual character string arguments, a character array, or a cell
 ## array of character strings.  If the handles, @var{hobjs}, are not specified
 ## then the legend's strings will be associated with the axes' descendants.
 ## Legend works on line graphs, bar graphs, etc.
 ## A plot must exist before legend is called.
 ##
 ## The optional parameter @var{pos} specifies the location of the legend
 ## as follows:
@@ -59,17 +59,17 @@
 ##   left top
 ##
 ## @item @tab southeast @tab
 ##   right bottom
 ##
 ## @item @tab southwest @tab
 ##   left bottom
 ##
-## @item 
+## @item
 ##
 ## @item @tab outside @tab
 ##   can be appended to any location string
 ## @end multitable
 ##
 ## The optional parameter @var{orient} determines if the key elements
 ## are placed vertically or horizontally.  The allowed values are "vertical"
 ## or "horizontal" with the default being "vertical".
@@ -113,17 +113,17 @@ function [hlegend2, hobjects2, hplot2, t
     endif
     ca = gca ();
   endif
 
   if (strcmp (get (ca, "tag"), "plotyy"))
     plty = get(ca (strcmp (get (ca, "tag"), "plotyy")), "userdata");
     if (isscalar (plty))
       ca = [ca, plty];
-    else 
+    else
       ca = [ca, plty{:}];
     endif
   endif
 
   if (nargin > 0 && all (ishandle (varargin{1})))
     kids = flipud (varargin{1}(:));
     varargin(1) = [];
   else
@@ -151,32 +151,32 @@ function [hlegend2, hobjects2, hplot2, t
         position = [{"northeastoutside", "best", "northeast",
                      "northwest", "southwest", "southeast"}] {pos + 2};
         nargs--;
       else
         error ("legend: invalid position specified");
       endif
     endif
   endif
-  
+
   while (nargs > 1)
     pos = varargin{nargs-1};
     str = varargin{nargs};
     if (strcmpi (pos, "location")  && ischar (str))
       position = lower (str);
       nargs -= 2;
     elseif (strcmpi (pos, "orientation")  && ischar (str))
       orientation = lower (str);
       nargs -= 2;
     else
       break;
     endif
   endwhile
 
-  ## Validate the orientation 
+  ## Validate the orientation
   switch (orientation)
     case {"vertical", "horizontal","default"}
     otherwise
       error ("legend: unrecognized legend orientation");
   endswitch
 
   ## Validate the position type is valid
   outside = false;
@@ -196,17 +196,17 @@ function [hlegend2, hobjects2, hplot2, t
       position = "northeast";
     otherwise
       error ("legend: unrecognized legend position");
   endswitch
 
   hlegend = [];
   fkids = get (fig, "children");
   for i = 1 : numel(fkids)
-    if (ishandle (fkids (i)) && strcmp (get (fkids (i), "type"), "axes") 
+    if (ishandle (fkids (i)) && strcmp (get (fkids (i), "type"), "axes")
         && (strcmp (get (fkids (i), "tag"), "legend")))
       udata = get (fkids (i), "userdata");
       if (! isempty (intersect (udata.handle, ca)))
         hlegend = fkids (i);
         break;
       endif
     endif
   endfor
@@ -355,17 +355,17 @@ function [hlegend2, hobjects2, hplot2, t
                || strcmp (typ, "patch") || strcmp (typ, "hggroup")))
           break
         endif
         if (k > 0)
           if (strcmp (get (kids(k), "type"), "hggroup"))
             hgkids = get (kids(k), "children");
             for j = 1 : length (hgkids)
               hgobj = get (hgkids (j));
-              if (isfield (hgobj, "displayname") 
+              if (isfield (hgobj, "displayname")
                   && ! isempty (hgobj.displayname))
                 hplots = [hplots, hgkids(j)];
                 text_strings = {text_strings{:}, hbobj.displayname};
                 break;
               endif
             endfor
           else
             if (! isempty (get (kids (k), "displayname")))
@@ -417,18 +417,18 @@ function [hlegend2, hobjects2, hplot2, t
         if (strcmp (position, "default"))
           position = "northeast";
         endif
         if (strcmp (orientation, "default"))
           orientation = "vertical";
         endif
         box = "off";
       endif
-      
-      ## Get axis size and fontsize in points.  
+
+      ## Get axis size and fontsize in points.
       ## Rely on listener to handle coversion.
       units = get (ca(1), "units");
       fontunits = get (ca(1), "fontunits");
       unwind_protect
         set (ca(1), "units", "points");
         set (ca(1), "fontunits", "points");
         ca_pos = get (ca(1), "position");
         ca_outpos = get (ca(1), "outerposition");
@@ -453,33 +453,33 @@ function [hlegend2, hobjects2, hplot2, t
         if (!isscalar(ud))
           ud = unique ([ud{:}]);
         endif
         if (isempty (hlegend))
           addprops = true;
           hlegend = axes ("tag", "legend", "userdata", struct ("handle", ud),
                           "box", box, "outerposition", [0, 0, 0, 0],
                           "xtick", [], "ytick", [], "xticklabel", "",
-                          "yticklabel", "", "zticklabel", "", 
+                          "yticklabel", "", "zticklabel", "",
                           "xlim", [0, 1], "ylim", [0, 1], "visible", "off",
                           "activepositionproperty", "position");
         else
           addprops = false;
           axes (hlegend);
           delete (get (hlegend, "children"));
         endif
 
         ## Add text label to the axis first, checking their extents
         nentries = numel (hplots);
         texthandle = [];
         maxwidth = 0;
         maxheight = 0;
         for k = 1 : nentries
           if (strcmp (textpos, "right"))
-            texthandle = [texthandle, text(0, 0, text_strings {k}, 
+            texthandle = [texthandle, text(0, 0, text_strings {k},
                                            "horizontalalignment", "left",
                                            "userdata", hplots(k))];
           else
             texthandle = [texthandle, text(0, 0, text_strings {k},
                                            "horizontalalignment", "right",
                                            "userdata", hplots(k))];
           endif
           units = get (texthandle (end), "units");
@@ -607,17 +607,17 @@ function [hlegend2, hobjects2, hplot2, t
               new_outpos = [ca_outpos(1) + lpos(3), ca_outpos(2), ...
                             ca_outpos(3) - lpos(3), ca_outpos(4) - lpos(4)];
             else
               lpos = [ca_pos(1) + ypad, ...
                       ca_pos(2) + ca_pos(4) - lpos(4) - ypad, lpos(3), lpos(4)];
             endif
           case "southeast"
             if (outside)
-              lpos = [ca_outpos(1) + ca_outpos(3) - lpos(3), ca_outpos(2), 
+              lpos = [ca_outpos(1) + ca_outpos(3) - lpos(3), ca_outpos(2),
                       lpos(3), lpos(4)];
               new_pos = [ca_pos(1), ca_pos(2) + lpos(4), ...
                          ca_pos(3) - lpos(3), ca_pos(4) - lpos(4)];
               new_outpos = [ca_outpos(1), ca_outpos(2) + lpos(4), ...
                             ca_outpos(3) - lpos(3), ca_outpos(4) - lpos(4)];
             else
               lpos = [ca_pos(1) + ca_pos(3) - lpos(3) - ypad, ...
                       ca_pos(2) + ypad, lpos(3), lpos(4)];
@@ -648,25 +648,25 @@ function [hlegend2, hobjects2, hplot2, t
         for k = 1 : numel (hplots)
           hobjects = [hobjects, texthandle (k)];
           switch (get (hplots(k), "type"))
           case "line"
             color = get (hplots(k), "color");
             style = get (hplots(k), "linestyle");
             if (! strcmp (style, "none"))
               l1 = line ("xdata", ([xoffset, xoffset + linelength] + xk * xstep) / lpos(3),
-                         "ydata", [1, 1] .* (lpos(4) - yoffset - yk * ystep) / lpos(4), 
+                         "ydata", [1, 1] .* (lpos(4) - yoffset - yk * ystep) / lpos(4),
                          "color", color, "linestyle", style, "marker", "none",
                          "userdata", hplots (k));
               hobjects = [hobjects, l1];
             endif
             marker = get (hplots(k), "marker");
             if (! strcmp (marker, "none"))
               l1 = line ("xdata", (xoffset + 0.5 * linelength  + xk * xstep) / lpos(3),
-                         "ydata", (lpos(4) - yoffset - yk * ystep) / lpos(4), 
+                         "ydata", (lpos(4) - yoffset - yk * ystep) / lpos(4),
                          "color", color, "linestyle", "none", "marker", marker,
                          "markeredgecolor", get (hplots (k), "markeredgecolor"),
                          "markerfacecolor", get (hplots (k), "markerfacecolor"),
                          "markersize", get (hplots (k), "markersize"),
                          "userdata", hplots (k));
               hobjects = [hobjects, l1];
             endif
 
@@ -694,24 +694,24 @@ function [hlegend2, hobjects2, hplot2, t
               xk = 0;
               yk++;
             endif
           endif
         endfor
 
         ## Add an invisible text object to original axis
         ## that when it is destroyed will remove the legend
-        t1 = text (0, 0, "", "parent", ca(1), "tag", "legend", 
+        t1 = text (0, 0, "", "parent", ca(1), "tag", "legend",
                    "handlevisibility", "off", "visible", "off",
                    "xliminclude", "off", "yliminclude", "off");
         set (t1, "deletefcn", {@deletelegend1, hlegend});
 
         ## Resize the axis the legend is attached to if the
-        ## legend is "outside" the plot and create listener to 
-        ## resize axis to original size if the legend is deleted, 
+        ## legend is "outside" the plot and create listener to
+        ## resize axis to original size if the legend is deleted,
         ## hidden or shown
         if (outside)
           for i = 1 : numel (ca)
             units = get (ca(i), "units");
             unwind_protect
               set (ca(i), "units", "points");
               set (ca (i), "position", new_pos, "outerposition", new_outpos);
             unwind_protect_cleanup
@@ -727,26 +727,26 @@ function [hlegend2, hobjects2, hplot2, t
         else
           set (hlegend, "deletefcn", {@deletelegend2, ca, [], [], t1, hplots});
         endif
 
         if (addprops)
           addproperty ("edgecolor", hlegend, "color", [0, 0, 0]);
           addproperty ("textcolor", hlegend, "color", [0, 0, 0]);
           addproperty ("location", hlegend, "radio", "north|south|east|west|{northeast}|southeast|northwest|southwest|northoutside|southoutside|eastoutside|westoutside|northeastoutside|southeastoutside|northwestoutside|southwestoutside");
-          addproperty ("orientation", hlegend, "radio", 
+          addproperty ("orientation", hlegend, "radio",
                        "{vertical}|horizontal");
           addproperty ("string", hlegend, "any", text_strings);
           addproperty ("textposition", hlegend, "radio", "{left}|right");
         else
           set (hlegend, "string", text_strings);
         endif
 
         if (outside)
-          set (hlegend, "location", strcat (position, "outside"), 
+          set (hlegend, "location", strcat (position, "outside"),
                "orientation", orientation, "textposition", textpos);
         else
           set (hlegend, "location", position, "orientation", orientation,
                "textposition", textpos);
         endif
         if (addprops)
           addlistener (hlegend, "edgecolor", @updatelegendtext);
           addlistener (hlegend, "textcolor", @updatelegendtext);
@@ -871,45 +871,45 @@ function deletelegend2 (h, d, ca, pos, o
   endfor
 endfunction
 
 function updateline (h, d, hlegend, linelength)
   lm = [];
   ll = [];
   kids = get (hlegend, "children");
   for i = 1 : numel (kids)
-    if (get (kids (i), "userdata") == h 
+    if (get (kids (i), "userdata") == h
         && strcmp (get (kids(i), "type"), "line"))
       if (strcmp (get (kids (i), "marker"), "none"))
         ll = kids (i);
       else
         lm = kids (i);
       endif
     endif
   endfor
 
   linestyle = get (h, "linestyle");
   marker = get (h, "marker");
   displayname = get (h, "displayname");
 
-  if ((isempty (displayname) 
+  if ((isempty (displayname)
        || (strcmp (marker, "none") && strcmp (linestyle, "none")))
        && (! isempty (lm) || isempty (ll)))
     ## An element was removed from the legend. Need to recall the
     ## legend function to recreate a new legend
     [hplots, text_strings] = getlegenddata (hlegend);
     for i = 1 : numel (hplots)
       if (hplots (i) == h)
         hplots(i) = [];
         text_strings(i) = [];
         break;
       endif
     endfor
     legend (hplots, text_strings);
-  elseif ((!isempty (displayname) 
+  elseif ((!isempty (displayname)
            && (! strcmp (marker, "none") || ! strcmp (linestyle, "none")))
           && isempty (lm) && isempty (ll))
     ## An element was added to the legend. Need to recall the
     ## legend function to recreate a new legend
     [hplots, text_strings] = getlegenddata (hlegend);
     hplots = [hplots, h];
     text_strings = {text_strings{:}, displayname};
     legend (hplots, text_strings);
@@ -926,22 +926,22 @@ function updateline (h, d, hlegend, line
     else
       ypos2 = get (lm,"ydata");
       xpos2 = get (lm,"xdata");
       ypos1 = [ypos2, ypos2];
       xpos1 = xpos2 + [-0.5, 0.5] * linelength;
       delete (lm);
     endif
     if (! strcmp (linestyle, "none"))
-      line ("xdata", xpos1, "ydata", ypos1, "color", get (h, "color"), 
+      line ("xdata", xpos1, "ydata", ypos1, "color", get (h, "color"),
             "linestyle", get (h, "linestyle"), "marker", "none",
             "userdata", h, "parent", hlegend);
     endif
     if (! strcmp (marker, "none"))
-      line ("xdata", xpos2, "ydata", ypos2, "color", get (h, "color"), 
+      line ("xdata", xpos2, "ydata", ypos2, "color", get (h, "color"),
             "marker", marker, "markeredgecolor", get (h, "markeredgecolor"),
             "markerfacecolor", get (h, "markerfacecolor"),
             "markersize", get (h, "markersize"), "linestyle", "none",
             "userdata", h, "parent", hlegend);
     endif
   endif
 endfunction
 
@@ -961,17 +961,17 @@ function [hplots, text_strings] = getleg
                  || strcmp (typ, "patch") || strcmp (typ, "hggroup")))
       typ = get (kids(--k), "type");
     endwhile
     if (k > 0)
       if (strcmp (get (kids(k), "type"), "hggroup"))
         hgkids = get (kids(k), "children");
         for j = 1 : length (hgkids)
           hgobj = get (hgkids (j));
-          if (isfield (hgobj, "displayname") 
+          if (isfield (hgobj, "displayname")
               && ! isempty (hgobj.displayname))
             hplots = [hplots, hgkids(j)];
             text_strings = {text_strings{:}, hbobj.displayname};
             break;
           endif
         endfor
       else
         if (! isempty (get (kids (k), "displayname")))
diff --git a/scripts/plot/loglog.m b/scripts/plot/loglog.m
--- a/scripts/plot/loglog.m
+++ b/scripts/plot/loglog.m
@@ -31,17 +31,17 @@
 
 ## Author: jwe
 
 function retval = loglog (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("loglog", varargin{:});
 
   if (nargs < 1)
-    print_usage(); 
+    print_usage();
   endif
 
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
 
     set (h, "xscale", "log", "yscale", "log");
diff --git a/scripts/plot/loglogerr.m b/scripts/plot/loglogerr.m
--- a/scripts/plot/loglogerr.m
+++ b/scripts/plot/loglogerr.m
@@ -22,19 +22,19 @@
 ## errorbars.  Many different combinations of arguments are possible.
 ## The most used form is
 ##
 ## @example
 ## loglogerr (@var{x}, @var{y}, @var{ey}, @var{fmt})
 ## @end example
 ##
 ## @noindent
-## which produces a double logarithm plot of @var{y} versus @var{x} 
+## which produces a double logarithm plot of @var{y} versus @var{x}
 ## with errors in the @var{y}-scale defined by @var{ey} and the plot
-## format defined by @var{fmt}.  See errorbar for available formats and 
+## format defined by @var{fmt}.  See errorbar for available formats and
 ## additional information.
 ## @seealso{errorbar, semilogxerr, semilogyerr}
 ## @end deftypefn
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
diff --git a/scripts/plot/meshc.m b/scripts/plot/meshc.m
--- a/scripts/plot/meshc.m
+++ b/scripts/plot/meshc.m
@@ -13,21 +13,21 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} meshc (@var{x}, @var{y}, @var{z})
-## Plot a mesh and contour given matrices @var{x}, and @var{y} from 
-## @code{meshgrid} and a matrix @var{z} corresponding to the @var{x} and 
-## @var{y} coordinates of the mesh.  If @var{x} and @var{y} are vectors, 
-## then a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, 
-## columns of @var{z} correspond to different @var{x} values and rows of 
+## Plot a mesh and contour given matrices @var{x}, and @var{y} from
+## @code{meshgrid} and a matrix @var{z} corresponding to the @var{x} and
+## @var{y} coordinates of the mesh.  If @var{x} and @var{y} are vectors,
+## then a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus,
+## columns of @var{z} correspond to different @var{x} values and rows of
 ## @var{z} correspond to different @var{y} values.
 ## @seealso{meshgrid, mesh, contour}
 ## @end deftypefn
 
 function h = meshc (varargin)
 
   newplot ();
 
diff --git a/scripts/plot/meshz.m b/scripts/plot/meshz.m
--- a/scripts/plot/meshz.m
+++ b/scripts/plot/meshz.m
@@ -13,25 +13,25 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} meshz (@var{x}, @var{y}, @var{z})
-## Plot a curtain mesh given matrices @var{x}, and @var{y} from 
-## @code{meshgrid} and a matrix @var{z} corresponding to the @var{x} and 
-## @var{y} coordinates of the mesh.  If @var{x} and @var{y} are vectors, 
-## then a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, 
-## columns of @var{z} correspond to different @var{x} values and rows of 
+## Plot a curtain mesh given matrices @var{x}, and @var{y} from
+## @code{meshgrid} and a matrix @var{z} corresponding to the @var{x} and
+## @var{y} coordinates of the mesh.  If @var{x} and @var{y} are vectors,
+## then a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus,
+## columns of @var{z} correspond to different @var{x} values and rows of
 ## @var{z} correspond to different @var{y} values.
 ## @seealso{meshgrid, mesh, contour}
 ## @end deftypefn
- 
+
 function retval = meshz (varargin)
 
   [h, varargin, nargin] = __plt_get_axis_arg__ ("meshz", varargin{:});
 
   ioff = nargin + 1;
   for i = 1:nargin
     if (ischar (varargin{i}))
       ioff = i;
@@ -57,25 +57,25 @@ function retval = meshz (varargin)
 
 
   if (isvector (x) && isvector (y))
     x = [x(1), x(:).', x(end)];
     y = [y(1); y(:); y(end)];
   else
     x = [x(1, 1), x(1, :), x(1, end);
          x(:, 1), x, x(:, end);
-         x(end, 1), x(end, :), x(end, end)]; 
+         x(end, 1), x(end, :), x(end, end)];
     y = [y(1, 1), y(1, :), y(1, end);
          y(:, 1), y, y(:, end);
-         y(end, 1), y(end, :), y(end, end)]; 
+         y(end, 1), y(end, :), y(end, end)];
   endif
 
   zref = min(z(isfinite(z)));
   z = [zref .* ones(1, size(z, 2) + 2);
-       zref .* ones(size(z, 1), 1), z, zref .* ones(size(z, 1), 1); 
+       zref .* ones(size(z, 1), 1), z, zref .* ones(size(z, 1), 1);
        zref.* ones(1, size(z, 2) + 2)];
 
   oldh = gca ();
   unwind_protect
     axes (h);
     tmp = mesh (x, y, z, varargin{ioff:end});
   unwind_protect_cleanup
     axes (oldh);
diff --git a/scripts/plot/ndgrid.m b/scripts/plot/ndgrid.m
--- a/scripts/plot/ndgrid.m
+++ b/scripts/plot/ndgrid.m
@@ -30,27 +30,27 @@
 ## @seealso{meshgrid}
 ## @end deftypefn
 
 ## Author: Alexander Barth <abarth@marine.usf.edu>
 
 function varargout = ndgrid (varargin)
 
   if (nargin == 1)
-    n = max ([nargout, 2]);  
+    n = max ([nargout, 2]);
     ## If only one input argument is given, repeat it n-times
     varargin(1:n) = varargin(1);
   elseif (nargin >= nargout)
-    n = max ([nargin, 2]);  
+    n = max ([nargin, 2]);
   else
     error ("ndgrid: wrong number of input arguments");
   endif
 
   ## Determine the size of the output arguments
-  
+
   shape = zeros (1, n);
 
   for i = 1:n
     if (! isvector (varargin{i}))
       error ("ndgrid: arguments must be vectors");
     endif
 
     shape(i) = length (varargin{i});
diff --git a/scripts/plot/orient.m b/scripts/plot/orient.m
--- a/scripts/plot/orient.m
+++ b/scripts/plot/orient.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} orient (@var{orientation})
 ## Set the default print orientation.  Valid values for
-## @var{orientation} include @code{"landscape"}, @code{"portrait"}, 
+## @var{orientation} include @code{"landscape"}, @code{"portrait"},
 ## and @code{"tall"}.
 ##
 ## The @code{"tall"} option sets the orientation to portait and fills
 ## the page with the plot, while leaving a 0.25in border.
 ##
 ## If called with no arguments, return the default print orientation.
 ## @end deftypefn
 
diff --git a/scripts/plot/pareto.m b/scripts/plot/pareto.m
--- a/scripts/plot/pareto.m
+++ b/scripts/plot/pareto.m
@@ -17,28 +17,28 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} pareto (@var{x})
 ## @deftypefnx {Function File} {} pareto (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} pareto (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} pareto (@dots{})
-## Draw a Pareto chart, also called ABC chart.  A Pareto chart is a bar graph 
-## used to arrange information in such a way that priorities for process 
-## improvement can be established.  It organizes and displays information 
-## to show the relative importance of data.  The chart is similar to the 
-## histogram or bar chart, except that the bars are arranged in decreasing 
+## Draw a Pareto chart, also called ABC chart.  A Pareto chart is a bar graph
+## used to arrange information in such a way that priorities for process
+## improvement can be established.  It organizes and displays information
+## to show the relative importance of data.  The chart is similar to the
+## histogram or bar chart, except that the bars are arranged in decreasing
 ## order from left to right along the abscissa.
-## 
-## The fundamental idea (Pareto principle) behind the use of Pareto 
+##
+## The fundamental idea (Pareto principle) behind the use of Pareto
 ## diagrams is that the majority of an effect is due to a small subset of the
-## causes, so for quality improvement the first few (as presented on the 
-## diagram) contributing causes to a problem usually account for the majority 
-## of the result.  Thus, targeting these "major causes" for elimination 
+## causes, so for quality improvement the first few (as presented on the
+## diagram) contributing causes to a problem usually account for the majority
+## of the result.  Thus, targeting these "major causes" for elimination
 ## results in the most cost-effective improvement scheme.
 ##
 ## The data are passed as @var{x} and the abscissa as @var{y}.  If @var{y} is
 ## absent, then the abscissa are assumed to be @code{1 : length (@var{x})}.
 ## @var{y} can be a string array, a cell array of strings or a numerical
 ## vector.
 ##
 ## An example of the use of @code{pareto} is
@@ -65,43 +65,43 @@ function h = pareto (varargin)
     if (! iscell (y))
       if (ischar (y))
         y = cellstr (y);
       else
         y = cellfun (@num2str, num2cell (y), "uniformoutput", false);
       endif
     endif
   else
-    y = cellfun (@int2str, num2cell (1 : numel(x)), 
+    y = cellfun (@int2str, num2cell (1 : numel(x)),
                  "uniformoutput", false);
   endif
 
   [x, idx] = sort (x, "descend");
   y = y (idx);
   cdf = cumsum (x);
   maxcdf = max(cdf);
   cdf = cdf ./ maxcdf;
   cdf95 = cdf - 0.95;
   idx95 = find(sign(cdf95(1:end-1)) != sign(cdf95(2:end)))(1);
 
-  [ax, hbar, hline] = plotyy (1 : idx95, x (1 : idx95), 
-                              1 : length(cdf), 100 .* cdf, 
+  [ax, hbar, hline] = plotyy (1 : idx95, x (1 : idx95),
+                              1 : length(cdf), 100 .* cdf,
                               @bar, @plot);
 
   axis (ax(1), [1 - 0.6, idx95 + 0.6, 0, maxcdf]);
   axis (ax(2), [1 - 0.6, idx95 + 0.6, 0, 100]);
-  set (ax(2), "ytick", [0, 20, 40, 60, 80, 100], 
+  set (ax(2), "ytick", [0, 20, 40, 60, 80, 100],
        "yticklabel", {"0%", "20%", "40%", "60%", "80%", "100%"});
   set (ax(1), "xtick", 1 : idx95, "xticklabel", y (1: idx95));
   set (ax(2), "xtick", 1 : idx95, "xticklabel", y (1: idx95));
 
   if (nargout > 0)
     h = [hbar; hline];
   endif
-  
+
 endfunction
 
 %!demo
 %! clf
 %! colormap (jet (64))
 %! Cheese = {"Cheddar", "Swiss", "Camembert", "Munster", "Stilton", "Blue"};
 %! Sold = [105, 30, 70, 10, 15, 20];
 %! pareto(Sold, Cheese);
diff --git a/scripts/plot/patch.m b/scripts/plot/patch.m
--- a/scripts/plot/patch.m
+++ b/scripts/plot/patch.m
@@ -28,17 +28,17 @@
 ## Create patch object from @var{x} and @var{y} with color @var{c} and
 ## insert in the current axes object.  Return handle to patch object.
 ##
 ## For a uniform colored patch, @var{c} can be given as an RGB vector,
 ## scalar value referring to the current colormap, or string value (for
 ## example, "r" or "red").
 ##
 ## If passed a structure @var{fv} contain the fields "vertices", "faces"
-## and optionally "facevertexcdata", create the patch based on these 
+## and optionally "facevertexcdata", create the patch based on these
 ## properties.
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = patch (varargin)
 
   [h, varargin] = __plt_get_axis_arg__ ("patch", varargin{:});
diff --git a/scripts/plot/pbaspect.m b/scripts/plot/pbaspect.m
--- a/scripts/plot/pbaspect.m
+++ b/scripts/plot/pbaspect.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2010-2011 Ben Abbott
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
diff --git a/scripts/plot/pcolor.m b/scripts/plot/pcolor.m
--- a/scripts/plot/pcolor.m
+++ b/scripts/plot/pcolor.m
@@ -28,17 +28,17 @@
 ## to different @var{y} values.
 ##
 ## The @code{colormap} is scaled to the extents of @var{c}.
 ## Limits may be placed on the color axis by the
 ## command @code{caxis}, or by setting the @code{clim} property of the
 ## parent axis.
 ##
 ## The face color of each cell of the mesh is determined by interpolating
-## the values of @var{c} for the cell's vertices.  Contrast this with 
+## the values of @var{c} for the cell's vertices.  Contrast this with
 ## @code{imagesc} which renders one cell for each element of @var{c}.
 ##
 ## @code{shading} modifies an attribute determining the manner by which the
 ## face color of each cell is interpolated from the values of @var{c},
 ## and the visibility of the cells' edges.  By default the attribute is
 ## "faceted", which renders a single color for each cell's face with the edge
 ## visible.
 ##
@@ -65,17 +65,17 @@ function h = pcolor (x, y, c)
   endif
 
   tmp = surface (x, y, z, c);
 
   ax = get (tmp, "parent");
 
   set (tmp, "facecolor", "flat");
   set (ax, "box", "on");
-  
+
   if (! ishold ())
     set (ax, "view", [0, 90]);
   endif
 
   if (nargout > 0)
     h = tmp;
   endif
 
diff --git a/scripts/plot/peaks.m b/scripts/plot/peaks.m
--- a/scripts/plot/peaks.m
+++ b/scripts/plot/peaks.m
@@ -31,23 +31,23 @@
 ## @ifnottex
 ## @verbatim
 ## f(x,y) = 3*(1-x)^2*exp(-x^2 - (y+1)^2) ...
 ##          - 10*(x/5 - x^3 - y^5)*exp(-x^2-y^2) ...
 ##          - 1/3*exp(-(x+1)^2 - y^2)
 ## @end verbatim
 ## @end ifnottex
 ##
-## Called without a return argument, @code{peaks} plots the surface of the 
+## Called without a return argument, @code{peaks} plots the surface of the
 ## above function using @code{mesh}.  If @var{n} is a scalar, the @code{peaks}
 ## returns the values of the above function on a @var{n}-by-@var{n} mesh over
 ## the range @code{[-3,3]}.  The default value for @var{n} is 49.
 ##
 ## If @var{n} is a vector, then it represents the @var{x} and @var{y} values
-## of the grid on which to calculate the above function.  The @var{x} and 
+## of the grid on which to calculate the above function.  The @var{x} and
 ## @var{y} values can be specified separately.
 ## @seealso{surf, mesh, meshgrid}
 ## @end deftypefn
 
 ## Expression for the peaks function was taken from the following paper:
 ## http://www.control.hut.fi/Kurssit/AS-74.115/Material/GENALGgoga.pdf
 
 function [X_out, Y_out, Z_out] = peaks (x, y)
diff --git a/scripts/plot/pie.m b/scripts/plot/pie.m
--- a/scripts/plot/pie.m
+++ b/scripts/plot/pie.m
@@ -17,27 +17,27 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} pie (@var{x})
 ## @deftypefnx {Function File} {} pie (@var{x}, @var{explode})
 ## @deftypefnx {Function File} {} pie (@dots{}, @var{labels})
 ## @deftypefnx {Function File} {} pie (@var{h}, @dots{});
 ## @deftypefnx {Function File} {@var{h} =} pie (@dots{});
-## Produce a pie chart. 
+## Produce a pie chart.
 ##
 ## Called with a single vector argument, produces a pie chart of the
 ## elements in @var{x}, with the size of the slice determined by percentage
 ## size of the values of @var{x}.
 ##
 ## The variable @var{explode} is a vector of the same length as @var{x} that
 ## if non zero 'explodes' the slice from the pie chart.
 ##
 ## If given @var{labels} is a cell array of strings of the same length as
-## @var{x}, giving the labels of each of the slices of the pie chart. 
+## @var{x}, giving the labels of each of the slices of the pie chart.
 ##
 ## The optional return value @var{h} provides a handle to the patch object.
 ##
 ## @seealso{pie3, bar, stem}
 ## @end deftypefn
 
 ## Very roughly based on pie.m from octave-forge whose author was
 ## Daniel Heiserer <Daniel.heiserer@physik.tu-muenchen.de>
diff --git a/scripts/plot/pie3.m b/scripts/plot/pie3.m
--- a/scripts/plot/pie3.m
+++ b/scripts/plot/pie3.m
@@ -18,27 +18,27 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} pie3 (@var{x})
 ## @deftypefnx {Function File} {} pie3 (@var{x}, @var{explode})
 ## @deftypefnx {Function File} {} pie3 (@dots{}, @var{labels})
 ## @deftypefnx {Function File} {} pie3 (@var{h}, @dots{});
 ## @deftypefnx {Function File} {@var{h} =} pie3 (@dots{});
-## Draw a a 3-D pie chart. 
+## Draw a a 3-D pie chart.
 ##
 ## Called with a single vector argument, produces a 3-D pie chart of the
 ## elements in @var{x}, with the size of the slice determined by percentage
 ## size of the values of @var{x}.
 ##
 ## The variable @var{explode} is a vector of the same length as @var{x} that
 ## if non zero 'explodes' the slice from the pie chart.
 ##
 ## If given @var{labels} is a cell array of strings of the same length as
-## @var{x}, giving the labels of each of the slices of the pie chart. 
+## @var{x}, giving the labels of each of the slices of the pie chart.
 ##
 ## The optional return value @var{h} provides a handle list to patch, surface
 ## and text objects generating this plot.
 ##
 ## @seealso{pie, bar, stem}
 ## @end deftypefn
 
 ## Very roughly based on pie.m from octave-forge whose author was
diff --git a/scripts/plot/plot.m b/scripts/plot/plot.m
--- a/scripts/plot/plot.m
+++ b/scripts/plot/plot.m
@@ -18,18 +18,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} plot (@var{y})
 ## @deftypefnx {Function File} {} plot (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} plot (@var{x}, @var{y}, @var{property}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {} plot (@var{x}, @var{y}, @var{fmt})
 ## @deftypefnx {Function File} {} plot (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} plot (@dots{})
-## Produce two-dimensional plots. 
-## 
+## Produce two-dimensional plots.
+##
 ## Many different combinations of arguments are possible.  The simplest
 ## form is
 ##
 ## @example
 ## plot (@var{y})
 ## @end example
 ##
 ## @noindent
@@ -165,31 +165,31 @@
 ## t = 0:0.1:6.3;
 ## plot (t, cos(t), "-;cos(t);", t, sin(t), "+3;sin(t);");
 ## @end group
 ## @end example
 ##
 ## This will plot the cosine and sine functions and label them accordingly
 ## in the key.
 ##
-## If the first argument is an axis handle, then plot into these axes, 
-## rather than the current axis handle returned by @code{gca}. 
-## 
+## If the first argument is an axis handle, then plot into these axes,
+## rather than the current axis handle returned by @code{gca}.
+##
 ## @seealso{semilogx, semilogy, loglog, polar, mesh, contour, bar,
 ## stairs, errorbar, xlabel, ylabel, title, print}
 ## @end deftypefn
 
 ## Author: jwe
 
 function retval = plot (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("plot", varargin{:});
 
   if (nargs < 1)
-    print_usage(); 
+    print_usage();
   endif
 
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
     tmp = __plt__ ("plot", h, varargin{:});
   unwind_protect_cleanup
diff --git a/scripts/plot/plot3.m b/scripts/plot/plot3.m
--- a/scripts/plot/plot3.m
+++ b/scripts/plot/plot3.m
@@ -53,17 +53,17 @@
 ## the real and imaginary parts of the argument are used as the @var{y}
 ## and @var{z} values, and they are plotted versus their index.
 ##
 ## Arguments may also be given in groups of three as
 ##
 ## @example
 ## plot3 (@var{x1}, @var{y1}, @var{z1}, @var{x2}, @var{y2}, @var{z2}, @dots{})
 ## @end example
-## 
+##
 ## @noindent
 ## in which each set of three arguments is treated as a separate line or
 ## set of lines in three dimensions.
 ##
 ## To plot multiple one- or two-argument groups, separate each group
 ## with an empty format string, as
 ##
 ## @example
diff --git a/scripts/plot/plotmatrix.m b/scripts/plot/plotmatrix.m
--- a/scripts/plot/plotmatrix.m
+++ b/scripts/plot/plotmatrix.m
@@ -25,35 +25,35 @@
 ## Scatter plot of the columns of one matrix against another.  Given the
 ## arguments @var{x} and @var{y}, that have a matching number of rows,
 ## @code{plotmatrix} plots a set of axes corresponding to
 ##
 ## @example
 ## plot (@var{x} (:, i), @var{y} (:, j)
 ## @end example
 ##
-## Given a single argument @var{x}, then this is equivalent to 
+## Given a single argument @var{x}, then this is equivalent to
 ##
 ## @example
 ## plotmatrix (@var{x}, @var{x})
 ## @end example
 ##
 ## @noindent
 ## except that the diagonal of the set of axes will be replaced with the
 ## histogram @code{hist (@var{x} (:, i))}.
 ##
-## The marker to use can be changed with the @var{style} argument, that is a 
+## The marker to use can be changed with the @var{style} argument, that is a
 ## string defining a marker in the same manner as the @code{plot}
 ## command.  If a leading axes handle @var{h} is passed to
 ## @code{plotmatrix}, then this axis will be used for the plot.
 ##
 ## The optional return value @var{h} provides handles to the individual
 ## graphics objects in the scatter plots, whereas @var{ax} returns the
 ## handles to the scatter plot axis objects.  @var{bigax} is a hidden
-## axis object that surrounds the other axes, such that the commands 
+## axis object that surrounds the other axes, such that the commands
 ## @code{xlabel}, @code{title}, etc., will be associated with this hidden
 ## axis.  Finally @var{p} returns the graphics objects associated with
 ## the histogram and @var{pax} the corresponding axes objects.
 ##
 ## @example
 ## @group
 ## plotmatrix (randn (100, 3), 'g+')
 ## @end group
@@ -79,18 +79,18 @@ function [h, ax, bigax, p, pax] = plotma
       if (nargout > 0)
         h = h2;
         ax = ax2;
         bigax = bigax2;
         p = p2;
         pax = pax2;
       endif
       axes (bigax2);
-      ctext = text (0, 0, "", "visible", "off", 
-                    "handlevisibility", "off", "xliminclude", "off",  
+      ctext = text (0, 0, "", "visible", "off",
+                    "handlevisibility", "off", "xliminclude", "off",
                     "yliminclude", "off", "zliminclude", "off",
                     "deletefcn", {@plotmatrixdelete, [ax2; pax2]});
       set (bigax2, "visible", "off");
     unwind_protect_cleanup
       axes (oldh);
     end_unwind_protect
   endif
 endfunction
@@ -117,17 +117,17 @@ function [h, ax, p, pax, need_usage] = _
   have_line_spec = false;
   have_hist = false;
   parent = get (bigax, "parent");
   for i = 1 : nargin - 1
     arg = varargin{i};
     if (ischar (arg) || iscell (arg))
       [linespec, valid] = __pltopt__ ("plotmatrix", varargin{i}, false);
       if (valid)
-        have_line_spec = true;      
+        have_line_spec = true;
         linespec = varargin(i);
         varargin(i) = [];
         nargin = nargin - 1;
         break;
       else
         need_usage = true;
         returm;
       endif
diff --git a/scripts/plot/plotyy.m b/scripts/plot/plotyy.m
--- a/scripts/plot/plotyy.m
+++ b/scripts/plot/plotyy.m
@@ -19,49 +19,49 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} plotyy (@var{x1}, @var{y1}, @var{x2}, @var{y2})
 ## @deftypefnx {Function File} {} plotyy (@dots{}, @var{fun})
 ## @deftypefnx {Function File} {} plotyy (@dots{}, @var{fun1}, @var{fun2})
 ## @deftypefnx {Function File} {} plotyy (@var{h}, @dots{})
 ## @deftypefnx {Function File} {[@var{ax}, @var{h1}, @var{h2}] =} plotyy (@dots{})
 ## Plots two sets of data with independent y-axes.  The arguments @var{x1} and
 ## @var{y1} define the arguments for the first plot and @var{x1} and @var{y2}
-## for the second. 
+## for the second.
 ##
-## By default the arguments are evaluated with 
+## By default the arguments are evaluated with
 ## @code{feval (@@plot, @var{x}, @var{y})}.  However the type of plot can be
 ## modified with the @var{fun} argument, in which case the plots are
-## generated by @code{feval (@var{fun}, @var{x}, @var{y})}.  @var{fun} can be 
+## generated by @code{feval (@var{fun}, @var{x}, @var{y})}.  @var{fun} can be
 ## a function handle, an inline function or a string of a function name.
 ##
-## The function to use for each of the plots can be independently defined 
+## The function to use for each of the plots can be independently defined
 ## with @var{fun1} and @var{fun2}.
 ##
 ## If given, @var{h} defines the principal axis in which to plot the @var{x1}
 ## and @var{y1} data.  The return value @var{ax} is a two element vector with
 ## the axis handles of the two plots.  @var{h1} and @var{h2} are handles to
 ## the objects generated by the plot commands.
 ##
 ## @example
 ## @group
-## x = 0:0.1:2*pi; 
+## x = 0:0.1:2*pi;
 ## y1 = sin (x);
 ## y2 = exp (x - 1);
 ## ax = plotyy (x, y1, x - 1, y2, @@plot, @@semilogy);
 ## xlabel ("X");
 ## ylabel (ax(1), "Axis 1");
 ## ylabel (ax(2), "Axis 2");
 ## @end group
 ## @end example
 ## @end deftypefn
 
 function [Ax, H1, H2] = plotyy (varargin)
 
   ## Don't use __plt_get_axis_arg__ here as ax is a two vector for plotyy
-  if (nargin > 1 && length (varargin{1}) == 2 && ishandle(varargin{1}(1)) 
+  if (nargin > 1 && length (varargin{1}) == 2 && ishandle(varargin{1}(1))
       && ishandle(varargin{1}(2))
       && all (floor (varargin{1}) != varargin{1}))
     obj1 = get (varargin{1}(1));
     obj2 = get (varargin{1}(2));
     if (strcmp (obj1.type, "axes") || strcmp (obj2.type, "axes"))
       ax = [obj1, obj2];
       varargin(1) = [];
       if (isempty (varargin))
@@ -92,17 +92,17 @@ function [Ax, H1, H2] = plotyy (varargin
       ax(2) = axes ();
     elseif (isempty (ax))
       ax(1) = axes ();
       ax(2) = axes ();
     endif
     if (nargin < 2)
       varargin = {};
     endif
-  endif 
+  endif
 
   if (nargin < 4)
     print_usage ();
   endif
 
   oldh = gca ();
   unwind_protect
     [ax, h1, h2] = __plotyy__ (ax, varargin{:});
@@ -164,22 +164,22 @@ function [ax, h1, h2] = __plotyy__ (ax, 
 
   h2 = feval (fun2, x2, y2);
   set (ax(2), "yaxislocation", "right");
   set (ax(2), "ycolor", getcolor (h2(1)));
   set (ax(2), "position", get (ax(1), "position"));
   set (ax(2), "xlim", xlim);
   set (ax(2), "color", "none");
 
-  ## Add invisible text objects that when destroyed, 
+  ## Add invisible text objects that when destroyed,
   ## also remove the other axis
-  t1 = text (0, 0, "", "parent", ax(1), "tag", "plotyy", 
+  t1 = text (0, 0, "", "parent", ax(1), "tag", "plotyy",
              "handlevisibility", "off", "visible", "off",
              "xliminclude", "off", "yliminclude", "off");
-  t2 = text (0, 0, "", "parent", ax(2), "tag", "plotyy", 
+  t2 = text (0, 0, "", "parent", ax(2), "tag", "plotyy",
              "handlevisibility", "off", "visible", "off",
              "xliminclude", "off", "yliminclude", "off");
 
   set (t1, "deletefcn", {@deleteplotyy, ax(2), t2});
   set (t2, "deletefcn", {@deleteplotyy, ax(1), t1});
 
   addlistener (ax(1), "position", {@update_position, ax(2)});
   addlistener (ax(2), "position", {@update_position, ax(1)});
@@ -194,31 +194,31 @@ function [ax, h1, h2] = __plotyy__ (ax, 
   ## not to mirror the y axis tick marks
   set (ax, "tag", "plotyy")
 
   ## Cross-reference one axis to the other in the userdata
   set (ax(1), "userdata", ax(2));
   set (ax(2), "userdata", ax(1));
 
   ## Store the axes handles for the sister axes.
-  try 
+  try
     addproperty ("__plotyy_axes__", ax(1), "data", ax);
   catch
     set (ax(1), "__plotyy_axes__", ax);
   end_try_catch
-  try 
+  try
     addproperty ("__plotyy_axes__", ax(2), "data", ax);
   catch
     set (ax(2), "__plotyy_axes__", ax);
   end_try_catch
 endfunction
 
 %!demo
 %! clf
-%! x = 0:0.1:2*pi; 
+%! x = 0:0.1:2*pi;
 %! y1 = sin (x);
 %! y2 = exp (x - 1);
 %! ax = plotyy (x, y1, x - 1, y2, @plot, @semilogy);
 %! xlabel ("X");
 %! ylabel (ax(1), "Axis 1");
 %! ylabel (ax(2), "Axis 2");
 %! axes (ax(1))
 %! text (0.5, 0.5, "Left Axis",
@@ -262,25 +262,25 @@ function update_position (h, d, ax2)
       plotboxaspectratiomode = get (h, "plotboxaspectratiomode");
       oldposition = get (ax2, "position");
       oldview = get (ax2, "view");
       oldplotboxaspectratio = get (ax2, "plotboxaspectratio");
       oldplotboxaspectratiomode = get (ax2, "plotboxaspectratiomode");
       if (! (isequal (position, oldposition) && isequal (view, oldview)))
         set (ax2, "position", position, "view", view)
       endif
-      if (! (isequal (plotboxaspectratio, oldplotboxaspectratio) 
+      if (! (isequal (plotboxaspectratio, oldplotboxaspectratio)
              && isequal (plotboxaspectratiomode, oldplotboxaspectratiomode)))
         set (ax2, "plotboxaspectratio", plotboxaspectratio);
         set (ax2, "plotboxaspectratiomode", plotboxaspectratiomode);
       endif
     unwind_protect_cleanup
       recursion = false;
     end_unwind_protect
-  endif  
+  endif
 endfunction
 
 function color = getcolor (ax)
   obj = get (ax);
   if (isfield (obj, "color"))
     color = obj.color;
   elseif (isfield (obj, "facecolor") && ! ischar (obj.facecolor))
     color = obj.facecolor;
diff --git a/scripts/plot/polar.m b/scripts/plot/polar.m
--- a/scripts/plot/polar.m
+++ b/scripts/plot/polar.m
@@ -30,17 +30,17 @@
 
 ## Author: jwe
 
 function retval = polar (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("polar", varargin{:});
 
   if (nargs < 1)
-    print_usage(); 
+    print_usage();
   endif
 
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
 
     if (nargs == 3)
@@ -71,17 +71,17 @@ function retval = polar (varargin)
         maxr = max (varargin{1}(:));
       endif
     else
       print_usage ();
     endif
 
     set (h, "xlim", [-maxr, maxr], "ylim", [-maxr, maxr],
          "xaxislocation", "zero", "yaxislocation", "zero",
-         "plotboxaspectratio", [1, 1, 1]); 
+         "plotboxaspectratio", [1, 1, 1]);
 
     if (nargout > 0)
       retval = tmp;
     endif
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
diff --git a/scripts/plot/print.m b/scripts/plot/print.m
--- a/scripts/plot/print.m
+++ b/scripts/plot/print.m
@@ -110,17 +110,17 @@
 ##   @item emf
 ##   @itemx meta
 ##     Microsoft Enhanced Metafile
 ##
 ##   @item fig
 ##     XFig.  For the Gnuplot graphics toolkit, the additional options
 ##     @option{-textspecial} or @option{-textnormal} can be used to control
 ##     whether the special flag should be set for the text in
-##     the figure (default is @option{-textnormal}). 
+##     the figure (default is @option{-textnormal}).
 ##
 ##   @item hpgl
 ##     HP plotter language
 ##
 ##   @item mf
 ##     Metafont
 ##
 ##   @item png
@@ -146,20 +146,20 @@
 ##   If the device is omitted, it is inferred from the file extension,
 ## or if there is no filename it is sent to the printer as postscript.
 ##
 ## @item -d@var{ghostscript_device}
 ##   Additional devices are supported by Ghostscript.
 ## Some examples are;
 ##
 ##   @table @code
-##   @item ljet2p 
+##   @item ljet2p
 ##     HP LaserJet IIP
 ##
-##   @item ljet3 
+##   @item ljet3
 ##     HP LaserJet III
 ##
 ##   @item deskjet
 ##     HP DeskJet and DeskJet Plus
 ##
 ##   @item cdj550
 ##     HP DeskJet 550C
 ##
@@ -175,26 +175,26 @@
 ##   @item pdfwrite
 ##     Produces pdf output from eps
 ##   @end table
 ##
 ##   For a complete list, type `system ("gs -h")' to see what formats
 ## and devices are available.
 ##
 ##   When Ghostscript output is sent to a printer the size is determined
-## by the figure's "papersize" property.  When the output 
+## by the figure's "papersize" property.  When the output
 ## is sent to a file the size is determined by the plot box defined by
 ## the figure's "paperposition" property.
 ##
 ## @itemx -append
-##   Appends the PS, or PDF output to a pre-existing file of the 
+##   Appends the PS, or PDF output to a pre-existing file of the
 ## same type.
 ##
 ## @itemx -r@var{NUM}
-##   Resolution of bitmaps in pixels per inch.  For both metafiles and 
+##   Resolution of bitmaps in pixels per inch.  For both metafiles and
 ## SVG the default is the screen resolution, for other it is 150 dpi.
 ## To specify screen resolution, use "-r0".
 ##
 ## @item -tight
 ##   Forces a tight bounding box for eps-files.
 ##
 ## @item -@var{preview}
 ##   Adds a preview to eps-files.  Supported formats are;
diff --git a/scripts/plot/private/__actual_axis_position__.m b/scripts/plot/private/__actual_axis_position__.m
--- a/scripts/plot/private/__actual_axis_position__.m
+++ b/scripts/plot/private/__actual_axis_position__.m
@@ -45,17 +45,17 @@ function pos = __actual_axis_position__ 
   end_unwind_protect
   ## Get axes size in pixels
   if (strcmp (get (axis_obj.parent, "__graphics_toolkit__"), "gnuplot")
       && strcmp (axis_obj.activepositionproperty, "outerposition"))
     pos_in_pixels = axis_obj.outerposition .* fig_position([3, 4, 3, 4]);
   else
     pos_in_pixels = axis_obj.position .* fig_position([3, 4, 3, 4]);
   endif
-    
+
   nd = __calc_dimensions__ (h);
 
   if (strcmp (axis_obj.plotboxaspectratiomode, "manual")
       || strcmp (axis_obj.dataaspectratiomode, "manual"))
     ## When using {rltb}margin, Gnuplot does not handle the specified
     ## aspect ratio properly, so handle it here.
     if (nd == 2 || all (mod (axis_obj.view, 90) == 0))
       aspect_ratio_2d = axis_obj.plotboxaspectratio(1:2);
diff --git a/scripts/plot/private/__axis_label__.m b/scripts/plot/private/__axis_label__.m
--- a/scripts/plot/private/__axis_label__.m
+++ b/scripts/plot/private/__axis_label__.m
@@ -1,9 +1,9 @@
-## Copyright (C) 1996-2011 John W. Eaton 
+## Copyright (C) 1996-2011 John W. Eaton
 ##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
diff --git a/scripts/plot/private/__bar__.m b/scripts/plot/private/__bar__.m
--- a/scripts/plot/private/__bar__.m
+++ b/scripts/plot/private/__bar__.m
@@ -23,17 +23,17 @@
 
 ## Author: jwe
 
 function varargout = __bar__ (vertical, func, varargin)
 
   [h, varargin] = __plt_get_axis_arg__ ((nargout > 1), func, varargin{:});
 
   ## Slightly smaller than 0.8 to avoid clipping issue in gnuplot 4.0
-  width = 0.8 - 10 * eps; 
+  width = 0.8 - 10 * eps;
   group = true;
   bv = 0;
 
   if (nargin < 3)
     print_usage ();
   endif
 
   if (nargin > 3 && isnumeric (varargin{2}))
@@ -61,17 +61,17 @@ function varargout = __bar__ (vertical, 
   else
     y = varargin{1};
     if (isvector (y))
       y = y(:);
     endif
     x = [1:size(y,1)]';
     idx = 2;
   endif
-      
+
   newargs = {};
   have_line_spec = false;
   while (idx <= nargin - 2)
     if (ischar (varargin{idx}) && strcmpi (varargin{idx}, "grouped"))
       group = true;
       idx++;
     elseif (ischar (varargin{idx}) && strcmpi (varargin{idx}, "stacked"))
       group = false;
@@ -181,37 +181,37 @@ function tmp = bars (ax, vertical, x, y,
   ycols = columns (y);
   clim = get (ax, "clim");
   tmp = [];
 
   for i = 1:ycols
     hg = hggroup ();
     tmp = [tmp; hg];
     args = __add_datasource__ ("bar", hg, {"x", "y"}, varargin{:});
-    
+
     if (vertical)
       if (! have_color_spec)
         if (ycols == 1)
           lev = clim(1);
         else
           lev = (i - 1) * (clim(2) - clim(1)) / (ycols - 1) - clim(1);
         endif
-        h = patch(xb(:,:,i), yb(:,:,i), "FaceColor", "flat", 
+        h = patch(xb(:,:,i), yb(:,:,i), "FaceColor", "flat",
                   "cdata", lev, "parent", hg);
       else
         h = patch(xb(:,:,i), yb(:,:,i), "parent", hg);
       endif
     else
       if (! have_color_spec)
         if (ycols == 1)
           lev = clim(1)
         else
           lev = (i - 1) * (clim(2) - clim(1)) / (ycols - 1) - clim(1);
         endif
-        h = patch(yb(:,:,i), xb(:,:,i), "FaceColor", "flat", 
+        h = patch(yb(:,:,i), xb(:,:,i), "FaceColor", "flat",
                   "cdata", lev, "parent", hg);
       else
         h = patch(yb(:,:,i), xb(:,:,i), "parent", hg);
       endif
     endif
 
     if (i == 1)
       x_axis_range = get (ax, "xlim");
@@ -224,17 +224,17 @@ function tmp = bars (ax, vertical, x, y,
     endif
 
     ## Setup the hggroup and listeners
     addproperty ("showbaseline", hg, "radio", "{on}|off");
     addproperty ("basevalue", hg, "data", base_value);
     addproperty ("baseline", hg, "data", h_baseline);
 
     addlistener (hg, "showbaseline", @show_baseline);
-    addlistener (hg, "basevalue", @move_baseline); 
+    addlistener (hg, "basevalue", @move_baseline);
 
     addproperty ("barwidth", hg, "data", width);
     if (group)
       addproperty ("barlayout", hg, "radio", "stacked|{grouped}", "grouped");
     else
       addproperty ("barlayout", hg, "radio", "{stacked}|grouped", "stacked");
     endif
     if (vertical)
@@ -248,27 +248,27 @@ function tmp = bars (ax, vertical, x, y,
     addlistener (hg, "horizontal", @update_group);
 
     addproperty ("edgecolor", hg, "patchedgecolor", get (h, "edgecolor"));
     addproperty ("linewidth", hg, "patchlinewidth", get (h, "linewidth"));
     addproperty ("linestyle", hg, "patchlinestyle", get (h, "linestyle"));
     addproperty ("facecolor", hg, "patchfacecolor", get (h, "facecolor"));
 
     addlistener (hg, "edgecolor", @update_props);
-    addlistener (hg, "linewidth", @update_props); 
-    addlistener (hg, "linestyle", @update_props); 
-    addlistener (hg, "facecolor", @update_props); 
+    addlistener (hg, "linewidth", @update_props);
+    addlistener (hg, "linestyle", @update_props);
+    addlistener (hg, "facecolor", @update_props);
 
     if (isvector (x))
       addproperty ("xdata", hg, "data", x);
     else
       addproperty ("xdata", hg, "data", x(:, i));
     endif
     addproperty ("ydata", hg, "data", y(:, i));
- 
+
     addlistener (hg, "xdata", @update_data);
     addlistener (hg, "ydata", @update_data);
 
     addproperty ("bargroup", hg, "data");
     set (tmp, "bargroup", tmp);
     if (! isempty (args))
       set (hg, args{:});
     endif
@@ -296,17 +296,17 @@ endfunction
 
 function update_baseline (h, d)
   visible = get (h, "visible");
   ydata = get (h, "ydata")(1);
 
   kids = get (get (h, "parent"), "children");
   for i = 1 : length (kids)
     obj = get (kids (i));
-    if (strcmp (obj.type, "hggroup") && isfield (obj, "baseline") 
+    if (strcmp (obj.type, "hggroup") && isfield (obj, "baseline")
         && obj.baseline == h)
       ## Only alter if changed to avoid recursion of the listener functions
       if (! strcmpi (get (kids(i), "showbaseline"), visible))
         set (kids (i), "showbaseline", visible);
       endif
       if (! strcmpi (get (kids(i), "basevalue"), visible))
         set (kids (i), "basevalue", ydata);
       endif
@@ -345,17 +345,17 @@ function move_baseline (h, d)
 
   if (strcmpi (get (h, "barlayout"), "grouped"))
     update_data (h, d);
   endif
 endfunction
 
 function update_props (h, d)
   kids = get (h, "children");
-  set (kids, "edgecolor", get (h, "edgecolor"), 
+  set (kids, "edgecolor", get (h, "edgecolor"),
        "linewidth", get (h, "linewidth"),
        "linestyle", get (h, "linestyle"),
        "facecolor", get (h, "facecolor"));
 endfunction
 
 function update_data (h, d)
   persistent recursion = false;
 
diff --git a/scripts/plot/private/__clabel__.m b/scripts/plot/private/__clabel__.m
--- a/scripts/plot/private/__clabel__.m
+++ b/scripts/plot/private/__clabel__.m
@@ -36,17 +36,17 @@ function h = __clabel__ (c, v, hparent, 
     y = get (hparent, "ydata");
     ymin = min (y(:));
     ymax = max (y(:));
   else
     i1 = 1;
     while (i1 < length (c))
       clev = c(1,i1);
       clen = c(2,i1);
-      p = c(:, i1+1:i1+clen)      
+      p = c(:, i1+1:i1+clen)
 
       xmin = min (c(1,:));
       xmax = max (c(1,:));
       ymin = min (c(2,:));
       ymax = max (c(2,:));
 
       i1 += clen+1;
     endwhile
@@ -78,38 +78,38 @@ function h = __clabel__ (c, v, hparent, 
       pos(1) = (td - label_spacing * (ntag - 1)) ./ 2;
       pos(2:ntag) = pos(1) + [1:ntag-1] * label_spacing;
     endif
 
     j1 = 2;
     tlabel = sprintf ("%g", clev);
     for i = 1 : ntag
       tagpos = pos(i);
-      
+
       while (j1 < clen && cumd(j1) < tagpos)
         j1++;
       endwhile
       tpos = sum(c(:,i1+j1-1:i1+j1), 2) ./ 2;
 
       if (tpos(1) != xmin &&  tpos(1) != xmax
           && tpos(2) != ymin &&  tpos(2) != ymax)
         trot = 180 / pi * atan2 (diff (c(2,i1+j1-1:i1+j1)),
                                  diff (c(1,i1+j1-1:i1+j1)));
 
         if (ischar (z))
-          ht = text (tpos(1), tpos(2), clev, tlabel, "rotation", trot, 
+          ht = text (tpos(1), tpos(2), clev, tlabel, "rotation", trot,
                      "parent", hparent, "horizontalalignment", "center",
                      "userdata", clev, varargin{:});
         elseif (!isempty (z))
-          ht = text (tpos(1), tpos(2), z, tlabel, "rotation", trot, 
+          ht = text (tpos(1), tpos(2), z, tlabel, "rotation", trot,
                      "parent", hparent, "horizontalalignment", "center",
                      "userdata", clev, varargin{:});
         else
           ht = text (tpos(1), tpos(2), tlabel, "rotation", trot,
                      "parent", hparent, "horizontalalignment", "center",
                      "userdata", clev, varargin{:});
         endif
         h = [h; ht];
       endif
     endfor
     i1 += clen+1;
   endwhile
-endfunction 
\ No newline at end of file
+endfunction
\ No newline at end of file
diff --git a/scripts/plot/private/__contour__.m b/scripts/plot/private/__contour__.m
--- a/scripts/plot/private/__contour__.m
+++ b/scripts/plot/private/__contour__.m
@@ -91,21 +91,21 @@ function [c, hg] = __contour__ (varargin
   if (!ismatrix (z1) || isvector (z1) || isscalar (z1))
     error ("__contour__: z argument must be a matrix");
   endif
   if (length (varargin) == 4 || length (varargin) == 6)
     vn = varargin {end};
     vnauto = false;
   else
     vnauto = true;
-    vn = 10; 
+    vn = 10;
   endif
 
   if (isscalar (vn))
-    lvl = linspace (min (z1(!isinf(z1))), max (z1(!isinf(z1))), 
+    lvl = linspace (min (z1(!isinf(z1))), max (z1(!isinf(z1))),
                     vn + 2)(1:end-1);
   else
     lvl = vn;
   endif
 
   if (strcmpi (filled, "on"))
     if (isvector (x1) || isvector (y1))
       [x1, y1] = meshgrid (x1, y1);
@@ -135,18 +135,18 @@ function [c, hg] = __contour__ (varargin
   addlistener (hg, "xdata", @update_data);
   addlistener (hg, "ydata", @update_data);
   addlistener (hg, "zdata", @update_data);
   addlistener (hg, "contourmatrix", @update_data);
 
   addproperty ("fill", hg, "radio", "on|{off}", filled);
 
   ## The properties zlevel and zlevelmode don't exist in matlab, but
-  ## allow the use of contourgroups with the contour3, meshc and surfc 
-  ## functions. 
+  ## allow the use of contourgroups with the contour3, meshc and surfc
+  ## functions.
   if (isnumeric (zlevel))
     addproperty ("zlevelmode", hg, "radio", "{none}|auto|manual", "manual");
     addproperty ("zlevel", hg, "data", zlevel);
   else
     addproperty ("zlevelmode", hg, "radio", "{none}|auto|manual", zlevel);
     if (ischar (zlevel) && strcmpi (zlevel, "manual"))
       z = varargin{3};
       z = 2 * (min (z(:)) - max (z(:)));
@@ -314,21 +314,21 @@ function add_patch_children (hg)
     for n = len:(-1):1
       idx = svec(n);
       ctmp = c(:, cont_idx(idx):cont_idx(idx) + cont_len(idx) - 1);
       if (all (ctmp(:,1) == ctmp(:,end)))
         ctmp(:, end) = [];
       else
         ## Special case unclosed contours
       endif
-      h = [h; __go_patch__(ca, "xdata", ctmp(1, :)(:), "ydata", ctmp(2, :)(:), 
+      h = [h; __go_patch__(ca, "xdata", ctmp(1, :)(:), "ydata", ctmp(2, :)(:),
                            "vertices", ctmp.', "faces", 1:(cont_len(idx)-1),
                            "facevertexcdata", cont_lev(idx),
                            "facecolor", "flat", "cdata", cont_lev(idx),
-                           "edgecolor", lc, "linestyle", ls, 
+                           "edgecolor", lc, "linestyle", ls,
                            "linewidth", lw, "parent", hg)];
     endfor
 
     if (min (lev) == max (lev))
       set (ca, "clim", [min(lev)-1, max(lev)+1], "layer", "top");
     else
       set (ca, "clim", [min(lev), max(lev)], "layer", "top");
     endif
@@ -344,35 +344,35 @@ function add_patch_children (hg)
         p = c(:, i1+1:i1+clen-1).';
       else
         p = [c(:, i1+1:i1+clen), NaN(2, 1)].';
       endif
 
       switch (zmode)
         case "none"
           h = [h; __go_patch__(ca, "xdata", p(:,1), "ydata", p(:,2),
-                               "zdata", [], "facecolor", "none", 
+                               "zdata", [], "facecolor", "none",
                                "vertices", p, "faces", 1:rows(p),
                                "facevertexcdata", clev,
                                "edgecolor", lc, "linestyle", ls,
                                "linewidth", lw,
-                               "cdata", clev, "parent", hg)]; 
+                               "cdata", clev, "parent", hg)];
         case "auto"
           h = [h; __go_patch__(ca, "xdata", p(:,1), "ydata", p(:,2),
                                "zdata", clev * ones(rows(p),1),
-                               "vertices", [p, clev * ones(rows(p),1)], 
+                               "vertices", [p, clev * ones(rows(p),1)],
                                "faces", 1:rows(p),
                                "facevertexcdata", clev,
-                               "facecolor", "none", "edgecolor", lc, 
+                               "facecolor", "none", "edgecolor", lc,
                                "linestyle", ls, "linewidth", lw,
                                "cdata", clev, "parent", hg)];
         otherwise
           h = [h; __go_patch__(ca, "xdata", p(:,1), "ydata", p(:,2),
                                "zdata", zlev * ones (rows(p), 1),
-                               "vertices", [p, zlev * ones(rows(p),1)], 
+                               "vertices", [p, zlev * ones(rows(p),1)],
                                "faces", 1:rows(p),
                                "facevertexcdata", clev,
                                "facecolor", "none", "edgecolor", lc,
                                "linestyle", ls, "linewidth", lw,
                                "cdata", clev, "parent", hg)];
       endswitch
       i1 += clen + 1;
     endwhile
@@ -385,17 +385,17 @@ function update_zlevel (h, d)
   zmode = get (h, "zlevelmode");
   kids = get (h, "children");
 
   switch (zmode)
     case "none"
       set (kids, "zdata", []);
     case "auto"
       for i = 1 : length (kids)
-        set (kids(i), "zdata", get (kids (i), "cdata") .* 
+        set (kids(i), "zdata", get (kids (i), "cdata") .*
              ones (size (get (kids (i), "xdata"))));
       endfor
     otherwise
       for i = 1 : length (kids)
         set (kids(i), "zdata", z .* ones (size (get (kids (i), "xdata"))));
       endfor
   endswitch
 endfunction
@@ -455,18 +455,18 @@ function update_data (h, d)
       X0 = [X0(1, :); X0; X0(1, :)];
       Y0 = prepad(Y, nr+1, 2 * Y(1, 1) - Y(2, 1), 1);
       Y0 = postpad(Y0, nr+2, 2 * Y(nr, 1) - Y(nr - 1, 1));
       Y0 = [Y0(:, 1), Y0, Y0(:, 1)];
       Z0 = -Inf(nr+2, nc+2);
       Z0(2:nr+1, 2:nc+1) = Z;
       [c, lev] = contourc (X0, Y0, Z0, lvl);
     else
-      [c, lev] = contourc (get (h, "xdata"), get (h, "ydata"), 
-                           get (h, "zdata"), lvl); 
+      [c, lev] = contourc (get (h, "xdata"), get (h, "ydata"),
+                           get (h, "zdata"), lvl);
     endif
     set (h, "contourmatrix", c);
 
     if (strcmpi (get (h, "levellistmode"), "manual"))
       ## Do nothing
     elseif (strcmpi (get (h, "levelstepmode"), "manual"))
       set (h, "levellist", lev);
     else
@@ -505,17 +505,17 @@ function update_text (h, d)
     else
       lvl = get (h, "levellist");
       set (h, "textlist", lvl, "textstep", get (h, "levelstep"));
     endif
 
     if (strcmpi (get (h, "showtext"), "on"))
       switch (get (h, "zlevelmode"))
         case "manual"
-          __clabel__ (get (h, "contourmatrix"), lvl, h, 
+          __clabel__ (get (h, "contourmatrix"), lvl, h,
                       get (h, "labelspacing"), get (h, "zlevel"));
         case "auto"
           __clabel__ (get (h, "contourmatrix"), lvl, h,
                       get (h, "labelspacing"), "auto");
         otherwise
           __clabel__ (get (h, "contourmatrix"), lvl, h,
                       get (h, "labelspacing"), []);
       endswitch
@@ -528,15 +528,15 @@ endfunction
 function lvl_eps = get_lvl_eps (lev)
   ## FIXME -- is this the right thing to do for this tolerance?  Should
   ## it be an absolute or relative tolerance, or switch from one to the
   ## other depending on the value of lev?
   if (isscalar (lev))
     lvl_eps = abs (lev) * sqrt (eps);
   else
     tmp = min (abs (diff (lev)));
-    if (tmp < 10*eps) 
+    if (tmp < 10*eps)
       lvl_eps = sqrt (eps);
     else
       lvl_eps = tmp / 1000.0;
     endif
   endif
 endfunction
diff --git a/scripts/plot/private/__errplot__.m b/scripts/plot/private/__errplot__.m
--- a/scripts/plot/private/__errplot__.m
+++ b/scripts/plot/private/__errplot__.m
@@ -52,17 +52,17 @@ function h = __errplot__ (fstr, p, varar
     elseif (strcmp (fmt.errorstyle, "#~>"))
       ifmt = "boxxy";
     else
       ifmt = "yerr";
     endif
 
     hg = hggroup ("parent", p);
     h = [h; hg];
-    args = __add_datasource__ ("__errplot__", hg, 
+    args = __add_datasource__ ("__errplot__", hg,
                                {"x", "y", "l", "u", "xl", "xu"});
 
     if (isempty (fmt.color))
       fmt.color = __next_line_color__ ();
     endif
     if (isempty (fmt.marker) && isempty (fmt.linestyle))
       [fmt.linestyle, fmt.marker] = __next_line_style__ ();
     endif
@@ -139,46 +139,46 @@ function h = __errplot__ (fstr, p, varar
           xdata = varargin{1}(:,i);
           ydata = varargin{2}(:,i);
           xldata = varargin{3}(:,i);
           xudata = varargin{4}(:,i);
           ldata = varargin{5}(:,i);
           udata = varargin{6}(:,i);
         else
           error ("errorbar: error plot with 6 columns only valid for boxxy and xyerr");
-        endif        
+        endif
       otherwise
         error ("errorbar: error plot requires 2, 3, 4 or 6 arguments.");
     endswitch
 
     addproperty ("xdata", hg, "data", xdata(:))
     addproperty ("ydata", hg, "data", ydata(:))
     addproperty ("ldata", hg, "data", ldata(:))
     addproperty ("udata", hg, "data", udata(:))
     addproperty ("xldata", hg, "data", xldata(:))
     addproperty ("xudata", hg, "data", xudata(:))
     addproperty ("format", hg, "string", ifmt);
 
     addproperty ("color", hg, "linecolor", get (hl(1), "color"))
     addproperty ("linewidth", hg, "linelinewidth", get (hl(1), "linewidth"))
     addproperty ("linestyle", hg, "linelinestyle", get (hl(1), "linestyle"))
     addproperty ("marker", hg, "linemarker", get (hl(1), "marker"))
-    addproperty ("markerfacecolor", hg, "linemarkerfacecolor", 
+    addproperty ("markerfacecolor", hg, "linemarkerfacecolor",
                  get (hl(1), "markerfacecolor"))
-    addproperty ("markeredgecolor", hg, "linemarkerfacecolor", 
+    addproperty ("markeredgecolor", hg, "linemarkerfacecolor",
                  get (hl(1), "markeredgecolor"))
-    addproperty ("markersize", hg, "linemarkersize", 
+    addproperty ("markersize", hg, "linemarkersize",
                  get (hl(1), "markersize"))
 
     fcn = {@update_props, hl};
     addlistener (hg, "color", fcn);
-    addlistener (hg, "linewidth", fcn); 
-    addlistener (hg, "linestyle", fcn); 
-    addlistener (hg, "marker", fcn); 
-    addlistener (hg, "markerfacecolor", fcn); 
+    addlistener (hg, "linewidth", fcn);
+    addlistener (hg, "linestyle", fcn);
+    addlistener (hg, "marker", fcn);
+    addlistener (hg, "markerfacecolor", fcn);
     addlistener (hg, "markersize", fcn);
 
     fcn = {@update_data, hl};
     addlistener (hg, "xdata", fcn);
     addlistener (hg, "ydata", fcn);
     addlistener (hg, "ldata", fcn);
     addlistener (hg, "udata", fcn);
     addlistener (hg, "xldata", fcn);
@@ -190,17 +190,17 @@ function h = __errplot__ (fstr, p, varar
     addlistener (hax, "yscale", fcn);
 
     update_data (hg, [], hl)
 
   endfor
 
 endfunction
 
-function [xdata, ydata] = errorbar_data (xdata, ydata, ldata, udata, 
+function [xdata, ydata] = errorbar_data (xdata, ydata, ldata, udata,
                                          xldata, xudata, ifmt,
                                          xscale, yscale)
   if (strcmp (xscale, "linear"))
     dx = 0.01 * (max (xdata(:)) - min (xdata(:)));
     xlo = xdata - dx;
     xhi = xdata + dx;
   else
     n = xdata > 0;
@@ -244,34 +244,34 @@ function [xdata, ydata] = errorbar_data 
              xdata-xldata, nans];
     ydata = [ylo, ylo, yhi, yhi, ylo, nans];
   elseif (strcmp (ifmt, "boxxy"))
     xdata = [xdata-xldata, xdata+xudata, xdata+xudata, xdata-xldata, ...
              xdata-xldata, nans];
     ydata = [ydata-ldata, ydata-ldata, ydata+udata, ydata+udata, ...
              ydata-ldata, nans];
   elseif (strcmp (ifmt, "xyerr"))
-    [x1, y1] = errorbar_data (xdata, ydata, ldata, udata, 
+    [x1, y1] = errorbar_data (xdata, ydata, ldata, udata,
                               xldata, xudata, "xerr", xscale, yscale);
-    [x2, y2] = errorbar_data (xdata, ydata, ldata, udata, 
+    [x2, y2] = errorbar_data (xdata, ydata, ldata, udata,
                               xldata, xudata, "yerr", xscale, yscale);
     xdata = [x1; x2];
     ydata = [y1; y2];
     return
   else
       error ("errorbar: valid error bar types are xerr, yerr, boxxy, and xyerr.")
   endif
   xdata = xdata.'(:);
   ydata = ydata.'(:);
 endfunction
 
 function update_props (hg, dummy, hl)
-  set (hl, "color", get (hg, "color"), 
+  set (hl, "color", get (hg, "color"),
            "linewidth", get (hg, "linewidth"));,
-  set (hl(1), "linestyle", get (hg, "linestyle"), 
+  set (hl(1), "linestyle", get (hg, "linestyle"),
               "marker", get (hg, "marker"),
               "markersize", get (hg, "markersize"),
               "markerfacecolor", get (hg, "markerfacecolor"),
               "markeredgecolor", get (hg, "markeredgecolor"));
 endfunction
 
 function update_data (hg, dummy, hl)
 
diff --git a/scripts/plot/private/__ezplot__.m b/scripts/plot/private/__ezplot__.m
--- a/scripts/plot/private/__ezplot__.m
+++ b/scripts/plot/private/__ezplot__.m
@@ -113,17 +113,17 @@ function [h, needusage] = __ezplot__ (pf
       yarg = "";
     else
       xarg = argnames(fun)(1);
       yarg = argnames(fun)(2);
     endif
   elseif (isa (fun, "function_handle"))
     fstr = func2str (fun);
     if (length (findstr (fstr, ")")) != 0)
-      args = regexp (substr (fstr, 3, findstr (fstr, ")")(1) - 3), 
+      args = regexp (substr (fstr, 3, findstr (fstr, ")")(1) - 3),
                      '(\w+)', 'tokens');
     fstr = substr (fstr, findstr (fstr, ")")(1) + 1);
     else
       args = {{"x"}};
     endif
     if (isplot && length (args) == 2)
       nargs = 2;
     elseif (length (args) != nargs)
@@ -171,17 +171,17 @@ function [h, needusage] = __ezplot__ (pf
         error ("%s: excepting a function of %d arguments", func, nargs);
       endif
       funy = vectorize (funy);
       fstry = formula (funy);
     elseif (isa (funy, "function_handle"))
       parametric = true;
       fstry = func2str (funy);
       if (length (findstr (fstry, ")")) != 0)
-        args = regexp (substr (fstry, 3, findstr (fstry, ")")(1) - 3), 
+        args = regexp (substr (fstry, 3, findstr (fstry, ")")(1) - 3),
                        '(\w+)', 'tokens');
         fstry = substr (fstry, findstr (fstry, ")")(1) + 1);
       else
         args = {{"y"}};
       endif
       if (length (args) != nargs)
         error ("%s: excepting a function of %d arguments", func, nargs);
       endif
@@ -211,30 +211,30 @@ function [h, needusage] = __ezplot__ (pf
       elseif (strcmp (typeinfo (funz), "inline function"))
         if (length (argnames (funz)) != nargs)
           error ("%s: excepting a function of %d arguments", func, nargs);
         endif
         funz = vectorize (funz);
         fstrz = formula (funz);
       elseif (isa (funz, "function_handle"))
         fstrz = func2str (funz);
-        args = regexp (substr (fstrz, 3, findstr (fstrz, ")")(1) - 3), 
+        args = regexp (substr (fstrz, 3, findstr (fstrz, ")")(1) - 3),
                        '(\w+)', 'tokens');
         if (length (args) != nargs)
           error ("%s: excepting a function of %d arguments", func, nargs);
         endif
         fstrz = substr (fstrz, findstr (fstrz, ")")(1) + 1);
       else
         error ("%s: parametric plots expect 3 functions", func);
       endif
     endif
   endif
 
   if (isplot && nargs != 2)
-    n = 500; 
+    n = 500;
   else
     n = 60;
   endif
   domain = [];
   circ = false;
   animate = false;
   if (parametric)
     if (isplot)
@@ -271,17 +271,17 @@ function [h, needusage] = __ezplot__ (pf
   endif
 
   if (circ)
     if (iscontour || isplot3 || isplot)
       needusage = true;
       return;
     endif
     if (parametric)
-      error ("%s: can not have both circular domain and parametric function", 
+      error ("%s: can not have both circular domain and parametric function",
              func);
     endif
     cent = [domain(1) + domain(2), domain(3) + domain(4)] / 2;
     funx = @(r,t) r .* cos (t) + cent (1);
     funy = @(r,t) r .* sin (t) + cent (2);
     domain = [0, sqrt((domain(2) - cent(1))^2 + (domain(4) - cent(2))^2), ...
               -pi, pi];
     funz = fun;
@@ -325,62 +325,62 @@ function [h, needusage] = __ezplot__ (pf
       Y = YY;
 
       ## Eliminate the singularities
       X = __eliminate_sing__ (X);
       Y = __eliminate_sing__ (Y);
       Z = __eliminate_sing__ (Z);
     endif
 
-    fstrx = regexprep (regexprep (regexprep (fstrx,'\s*\.?\^\s*','^'), 
+    fstrx = regexprep (regexprep (regexprep (fstrx,'\s*\.?\^\s*','^'),
                       '\./', '/'), '\.?\*', '');
-    fstry = regexprep (regexprep (regexprep (fstry,'\s*\.?\^\s*','^'), 
+    fstry = regexprep (regexprep (regexprep (fstry,'\s*\.?\^\s*','^'),
                       '\./', '/'), '\.?\*', '');
     if (isplot)
       fstr = cstrcat ("x = ",fstrx,", y = ",fstry);
     else
-      fstrz = regexprep (regexprep (regexprep (fstrz,'\s*\.?\^\s*','^'), 
+      fstrz = regexprep (regexprep (regexprep (fstrz,'\s*\.?\^\s*','^'),
                                     '\./', '/'), '\.?\*', '');
       fstr = cstrcat ("x = ",fstrx,",y = ",fstry,", z = ",fstrz);
     endif
   else
     if (isplot3)
       needusage = true;
       return;
     endif
 
-    fstr = regexprep (regexprep (regexprep (fstr,'\s*\.?\^\s*','^'), '\./', '/'), 
+    fstr = regexprep (regexprep (regexprep (fstr,'\s*\.?\^\s*','^'), '\./', '/'),
                       '\.?\*', '');
     if (isplot && nargs == 2)
       if (strcmp (typeinfo (fun), "inline function")
           && !isempty (strfind (formula (fun) , "=")))
         fun = inline (cstrcat (strrep (formula (fun), "=", "- ("), ")"));
       else
         fstr = cstrcat (fstr, " = 0");
       endif
 
       Z = feval (fun, X, Y);
 
-      ## Matlab returns line objects for this case and so can't call 
+      ## Matlab returns line objects for this case and so can't call
       ## contour directly as it returns patch objects to allow colormaps
       ## to work with contours. Therefore recreate the lines from the
       ## output for contourc, and store in cell arrays.
       [c, lev] = contourc (X, Y, Z, [0, 0]);
 
       i1 = 1;
       XX = {};
       YY = {};
       while (i1 < length (c))
         clev = c(1,i1);
         clen = c(2,i1);
         XX = [XX, {c(1, i1+1:i1+clen)}];
         YY = [YY, {c(2, i1+1:i1+clen)}];
         i1 += clen+1;
       endwhile
-    else  
+    else
       if (ispolar)
         Z = feval (fun, X);
       elseif (isplot)
         Z = real (feval (fun, X));
 
         ## Eliminate the singularities. This seems to be what matlab
         ## does, but can't be sure.
         XX = sort (Z (isfinite (Z)));
@@ -391,28 +391,28 @@ function [h, needusage] = __ezplot__ (pf
         else
           yrange = [XX(1), XX(end)];
         endif
 
         idx = 2 : length(Z);
         idx = find (((Z(idx) > yrange(2) / 2) & (Z(idx-1) < yrange(1) / 2)) |
                  ((Z(idx) < yrange(1) / 2) & (Z(idx-1) > yrange (2) / 2)));
         if (any(idx))
-          Z(idx) = NaN; 
+          Z(idx) = NaN;
         endif
       else
         Z = feval (fun, X, Y);
 
         ## Eliminate the singularities
         Z = __eliminate_sing__ (Z);
       endif
     endif
   endif
 
-  oldax = gca (); 
+  oldax = gca ();
   unwind_protect
     axes (ax);
     if (iscontour)
       [clev, h] = feval (pfunc, X, Y, Z);
     elseif (isplot && nargs == 2)
       h = [];
       hold_state = get (ax, "nextplot");
       for i = 1 : length (XX)
diff --git a/scripts/plot/private/__fltk_file_filter__.m b/scripts/plot/private/__fltk_file_filter__.m
--- a/scripts/plot/private/__fltk_file_filter__.m
+++ b/scripts/plot/private/__fltk_file_filter__.m
@@ -29,17 +29,17 @@ function retval = __fltk_file_filter__ (
   if (iscell (file_filter))
     [r, c] = size (file_filter);
     if ((c == 0) || (c > 2))
       error ("expecting 1 or to 2 columns for file filter cell.");
     endif
     fltk_str = "";
     for idx = 1 : r
 
-      curr_ext = file_filter{idx, 1};                    
+      curr_ext = file_filter{idx, 1};
       curr_ext = strsplit (curr_ext, ";");
 
       if (length (curr_ext) > 1)
         curr_ext = regexprep (curr_ext, '\*\.', ',');
         curr_ext = strcat (curr_ext{:})(2 : end);
         curr_ext = strcat ("*.{", curr_ext, "}");
       else
         curr_ext = curr_ext{:};
@@ -63,10 +63,10 @@ function retval = __fltk_file_filter__ (
     retval = fltk_str;
   elseif (ischar (file_filter))
     if (!isdir (file_filter))
       [fdir, fname, fext] = fileparts (file_filter);
       if (length (fext) > 0)
         retval = strcat ("*", fext, "\t*");
       endif
     endif
-  endif  
+  endif
 endfunction
diff --git a/scripts/plot/private/__ghostscript__.m b/scripts/plot/private/__ghostscript__.m
--- a/scripts/plot/private/__ghostscript__.m
+++ b/scripts/plot/private/__ghostscript__.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2010-2011 Ben Abbott
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
diff --git a/scripts/plot/private/__gnuplot_has_terminal__.m b/scripts/plot/private/__gnuplot_has_terminal__.m
--- a/scripts/plot/private/__gnuplot_has_terminal__.m
+++ b/scripts/plot/private/__gnuplot_has_terminal__.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2010-2011 Ben Abbott
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
diff --git a/scripts/plot/private/__patch__.m b/scripts/plot/private/__patch__.m
--- a/scripts/plot/private/__patch__.m
+++ b/scripts/plot/private/__patch__.m
@@ -203,17 +203,17 @@ function args = setdata (args)
 
   nr = size (faces, 2);
   nc = size (faces, 1);
   idx = faces .';
   t1 = isnan (idx);
   if (any (t1(:)))
     t2 = find (t1 != t1([2:end,end],:));
     idx (t1) = idx (t2 (cell2mat (cellfun (@(x) x(1)*ones(1,x(2)),
-                mat2cell ([1 : nc; sum(t1)], 2, ones(1,nc)), 
+                mat2cell ([1 : nc; sum(t1)], 2, ones(1,nc)),
                                            "uniformoutput", false))));
   endif
   x = reshape (vert(:,1)(idx), size (idx));
   y = reshape (vert(:,2)(idx), size (idx));
   if (size(vert,2) > 2)
     z = reshape (vert(:,3)(idx), size (idx));
   else
     z = [];
@@ -283,17 +283,17 @@ function args = setvertexdata (args)
   faces = reshape (1:numel(x), rows (x), columns (x));
   faces = faces';
 
   if (ndims (c) == 3)
     fvc = reshape (c, size (c, 1) * size (c, 2), size(c, 3));
   else
     fvc = c(:).';
   endif
- 
+
   args = {"faces", faces, "vertices", vert, "facevertexcdata", fvc, args{:}};
 endfunction
 
 function update_data (h, d)
   update_handle (h, false);
 endfunction
 
 function update_fvc (h, d)
diff --git a/scripts/plot/private/__pie__.m b/scripts/plot/private/__pie__.m
--- a/scripts/plot/private/__pie__.m
+++ b/scripts/plot/private/__pie__.m
@@ -59,17 +59,17 @@ function hlist = __pie__ (caller, vararg
 
   if (! have_explode)
     explode = zeros (size (x));
   endif
 
   normalize = true;
   if (sum (x(:)) < 1)
     normalize = false;
-  endif 
+  endif
 
   if (! have_labels)
     if (normalize)
       xp = round (100 * x ./ sum (x));
     else
       xp = round (100 * x);
     endif
     for i = 1:len
@@ -81,17 +81,17 @@ function hlist = __pie__ (caller, vararg
   refinement = 90;
   phi = 0:refinement:360;
   if (normalize)
     xphi = cumsum (x / sum (x) * 360);
   else
     xphi = cumsum (x * 360);
   endif
 
-  for i = 1:len 
+  for i = 1:len
     if (i == 1)
       xn = 0 : 360 / refinement : xphi(i);
     else
       xn = xphi(i-1) : 360 / refinement : xphi(i);
     endif
 
     if (xn(end) != xphi(i))
       xn = [xn, xphi(i)];
@@ -102,33 +102,33 @@ function hlist = __pie__ (caller, vararg
       xoff = - 0.1 * sind (xn2);
       yoff = 0.1 * cosd (xn2);
     else
       xoff = 0;
       yoff = 0;
     endif
     xt = - 1.2 * sind (xn2);
     yt = 1.2 * cosd (xn2);
-  
+
     if (len == 1)
       set (h, "clim", [1, 2]);
     else
       set (h, "clim", [1, len]);
     endif
 
     if (strncmp (caller, "pie3", 4))
       ln = length (xn);
       zlvl = 0.35;
       sx = repmat (xoff + [0, - sind(xn), 0], [2 1]);
       sy = repmat (yoff + [0, cosd(xn), 0], [2 1]);
       sz = [zeros(1, ln + 2); zlvl * ones(1, ln + 2)];
       sc = i * ones (size (sz));
 
       hlist = [hlist;
-        patch(xoff + [0, - sind(xn)], yoff + [0, cosd(xn)], zeros (1, ln + 1), i);      
+        patch(xoff + [0, - sind(xn)], yoff + [0, cosd(xn)], zeros (1, ln + 1), i);
         surface(sx, sy, sz, sc);
         patch(xoff + [0, - sind(xn)], yoff + [0, cosd(xn)], zlvl * ones (1, ln + 1), i);
         text(xt, yt, zlvl, labels{i})];
 
     elseif (strncmp (caller, "pie", 3))
       if (xt > 0)
         align = "left";
       else
@@ -140,17 +140,17 @@ function hlist = __pie__ (caller, vararg
 
     else
       error ("__pie__: unknown caller `%s'", caller);
     endif
   endfor
 
   addlistener(gca, "view", {@update_text_pos, hlist});
 
-  if (strncmp (caller, "pie3", 4))    
+  if (strncmp (caller, "pie3", 4))
     axis ([-1.25, 1.25, -1.25, 1.25, -0.05, 0.4], "equal", "off")
     view (-37.5, 30);
   elseif (strncmp (caller, "pie", 3))
     axis ([-1.5, 1.5, -1.5, 1.5], "square", "off");
   endif
 endfunction
 
 function update_text_pos (all_handles)
diff --git a/scripts/plot/private/__pltopt__.m b/scripts/plot/private/__pltopt__.m
--- a/scripts/plot/private/__pltopt__.m
+++ b/scripts/plot/private/__pltopt__.m
@@ -145,17 +145,17 @@ function [options, valid] = __pltopt1__ 
   have_marker = false;
 
   ## If called by __errplot__, extract the linestyle before proceeding.
   if (strcmp (caller,"__errplot__"))
     if (strncmp (opt, "#~>", 3))
       n = 3;
     elseif (strncmp (opt, "#~", 2) || strncmp (opt, "~>", 2))
       n = 2;
-    elseif (strncmp (opt, "~", 1) || strncmp (opt, ">", 1) 
+    elseif (strncmp (opt, "~", 1) || strncmp (opt, ">", 1)
             || strncmp (opt, "#", 1))
       n = 1;
     else
       n = 0;
     endif
     options.errorstyle = opt(1:n);
     opt(1:n) = [];
   else
diff --git a/scripts/plot/private/__quiver__.m b/scripts/plot/private/__quiver__.m
--- a/scripts/plot/private/__quiver__.m
+++ b/scripts/plot/private/__quiver__.m
@@ -53,17 +53,17 @@ function hg = __quiver__ (varargin)
     endif
   else
     x = varargin{ioff++};
     y = varargin{ioff++};
     if (is3d)
       z = varargin{ioff++};
     endif
     u = varargin{ioff++};
-    v = varargin{ioff++}; 
+    v = varargin{ioff++};
     if (is3d)
       w = varargin{ioff++};
       if (isvector (x) && isvector (y) && isvector (z)
           && (! isvector (u) || ! isvector (v) || ! isvector(w)))
         [x, y, z] = meshgrid (x, y, z);
       endif
     else
       if (isvector (x) && isvector (y) && (! isvector (u) || ! isvector (v)))
@@ -113,17 +113,17 @@ function hg = __quiver__ (varargin)
       ## What should this be divided by? The below seems right
       dz = (max(z(:)) - min(z(:))) ./ max (size (z));
       len = max (sqrt (u(:).^2 + dy(:).^2) + dz(:).^2);
     else
       len = max (sqrt (u(:).^2 + dy(:).^2));
       dz = 0;
     endif
     if (len > 0)
-      s = 2 * autoscale / sqrt (2) * sqrt (dx.^2 + dy.^2 + dz.^2) / len; 
+      s = 2 * autoscale / sqrt (2) * sqrt (dx.^2 + dy.^2 + dz.^2) / len;
       uu = s * u;
       vv = s * v;
       if (is3d)
         ww = s*w;
       endif
     endif
   else
     uu = u;
@@ -132,20 +132,20 @@ function hg = __quiver__ (varargin)
       ww = w;
     endif
   endif
 
   hstate = get (h, "nextplot");
   unwind_protect
     hg = hggroup ();
     if (is3d)
-      args = __add_datasource__ ("quiver3", hg, 
+      args = __add_datasource__ ("quiver3", hg,
                                  {"x", "y", "z", "u", "v", "w"}, args{:});
     else
-      args = __add_datasource__ ("quiver", hg, 
+      args = __add_datasource__ ("quiver", hg,
                                  {"x", "y", "z", "u", "v", "w"}, args{:});
     endif
     hold on;
 
     addproperty ("xdata", hg, "data", x);
     addproperty ("ydata", hg, "data", y);
 
     addproperty ("udata", hg, "data", u);
@@ -174,22 +174,22 @@ function hg = __quiver__ (varargin)
       zend = z + ww(:);
     endif
 
     if (have_line_spec)
       if (is3d)
         h1 = plot3 ([x.'; xend.'; NaN(1, length (x))](:),
                     [y.'; yend.'; NaN(1, length (y))](:),
                     [z.'; zend.'; NaN(1, length (z))](:),
-                    "linestyle", linespec.linestyle, 
+                    "linestyle", linespec.linestyle,
                     "color", linespec.color, "parent", hg);
       else
         h1 = plot ([x.'; xend.'; NaN(1, length (x))](:),
                    [y.'; yend.'; NaN(1, length (y))](:),
-                   "linestyle", linespec.linestyle, 
+                   "linestyle", linespec.linestyle,
                     "color", linespec.color, "parent", hg);
       endif
     else
       if (is3d)
         h1 = plot3 ([x.'; xend.'; NaN(1, length (x))](:),
                     [y.'; yend.'; NaN(1, length (y))](:),
                     [z.'; zend.'; NaN(1, length (z))](:),
                     "color", "black", "parent", hg);
@@ -247,34 +247,34 @@ function hg = __quiver__ (varargin)
                  [yarrw1.'; yend.'; yarrw2.'; NaN(1, length (y))](:),
                  "parent", hg);
     endif
 
     if (! have_line_spec
         || (isfield (linespec, "marker")
             && strncmp (linespec.marker, "none", 4)))
       if (is3d)
-        h3 = plot3 (x, y, z, "linestyle", "none", "marker", "none", 
+        h3 = plot3 (x, y, z, "linestyle", "none", "marker", "none",
                     "parent", hg);
       else
         h3 = plot (x, y, "linestyle", "none", "marker", "none", "parent", hg);
       endif
     else
       if (is3d)
         h3 = plot3 (x, y, z, "linestyle", "none", "marker", linespec.marker,
                     "parent", hg);
       else
 
         h3 = plot (x, y, "linestyle", "none", "marker", linespec.marker,
                    "parent", hg);
       endif
     endif
     if (have_filled)
       ## FIXME gnuplot doesn't respect the markerfacecolor field
-      set (h3, "markerfacecolor", get (h1, "color")); 
+      set (h3, "markerfacecolor", get (h1, "color"));
     endif
 
     ## Set up the hggroup properties and listeners
     if (autoscale)
       addproperty ("autoscale", hg, "radio", "{on}|off", "on");
       addproperty ("autoscalefactor", hg, "data", autoscale)
     else
       addproperty ("autoscale", hg, "radio", "{on}|off", "off");
@@ -293,20 +293,20 @@ function hg = __quiver__ (varargin)
     addproperty ("linewidth", hg, "linelinewidth", get (h1, "linewidth"));
     addproperty ("linestyle", hg, "linelinestyle", get (h1, "linestyle"));
     addproperty ("marker", hg, "linemarker", get (h3, "marker"));
     addproperty ("markerfacecolor", hg, "linemarkerfacecolor",
                  get (h3, "markerfacecolor"));
     addproperty ("markersize", hg, "linemarkersize", get (h3, "markersize"));
 
     addlistener (hg, "color", @update_props);
-    addlistener (hg, "linewidth", @update_props); 
-    addlistener (hg, "linestyle", @update_props); 
-    addlistener (hg, "marker", @update_props); 
-    addlistener (hg, "markerfacecolor", @update_props); 
+    addlistener (hg, "linewidth", @update_props);
+    addlistener (hg, "linestyle", @update_props);
+    addlistener (hg, "marker", @update_props);
+    addlistener (hg, "markerfacecolor", @update_props);
     addlistener (hg, "markersize", @update_props);
 
     if (! isempty (args))
       set (hg, args{:});
     endif
   unwind_protect_cleanup
     set (h, "nextplot", hstate);
   end_unwind_protect
@@ -341,17 +341,17 @@ function update_data (h, d)
       ## What should this be divided by? The below seems right
       dz = (max(z(:)) - min(z(:))) ./ max (size (z));
       len = max (sqrt (u(:).^2 + dy(:).^2) + dz(:).^2);
     else
       len = max (sqrt (u(:).^2 + dy(:).^2));
       dz = 0;
     endif
     if (len > 0)
-      s = 2 * s / sqrt (2) * sqrt (dx.^2 + dy.^2 + dz.^2) / len; 
+      s = 2 * s / sqrt (2) * sqrt (dx.^2 + dy.^2 + dz.^2) / len;
       u = s * u;
       v = s * v;
       if (is3d)
         w = s*w;
       endif
     endif
   endif
 
@@ -398,24 +398,24 @@ function update_data (h, d)
     set (kids (1), "zdata", z);
   endif
 
 endfunction
 
 function update_props (h, d)
   kids = get (h, "children");
 
-  set (kids(3), "color", get (h, "color"), 
+  set (kids(3), "color", get (h, "color"),
        "linewidth", get (h, "linewidth"),
        "linestyle", get (h, "linestyle"));
-  set (kids(2), "color", get (h, "color"), 
+  set (kids(2), "color", get (h, "color"),
        "linewidth", get (h, "linewidth"),
        "linestyle", get (h, "linestyle"));
   if (strcmpi (get (h, "showarrowhead"), "on"))
     set (kids (2), "visible", "on");
   else
     set (kids (2), "visible", "off");
   endif
-  set (kids(1), "color", get (h, "color"), 
+  set (kids(1), "color", get (h, "color"),
        "marker", get (h, "marker"),
        "markerfacecolor", get (h, "markerfacecolor"),
        "markersize", get (h, "markersize"));
 endfunction
diff --git a/scripts/plot/private/__scatter__.m b/scripts/plot/private/__scatter__.m
--- a/scripts/plot/private/__scatter__.m
+++ b/scripts/plot/private/__scatter__.m
@@ -109,17 +109,17 @@ function hg = __scatter__ (varargin)
     endif
   endwhile
 
   if (isempty (c))
     c = __next_line_color__();
   endif
 
   hg = hggroup ();
-  newargs = __add_datasource__ (fcn, hg, {"x", "y", "z", "c", "size"}, 
+  newargs = __add_datasource__ (fcn, hg, {"x", "y", "z", "c", "size"},
                              newargs{:});
 
   addproperty ("xdata", hg, "data", x);
   addproperty ("ydata", hg, "data", y);
   addproperty ("zdata", hg, "data", z);
   if (ischar (c))
     addproperty ("cdata", hg, "data", __color_str_rgb__ (c));
   else
@@ -139,73 +139,73 @@ function hg = __scatter__ (varargin)
     if (numel (s) == 1)
       s = repmat (s, numel(x), 1);
     endif
 
     if (ischar (c) || rows(c) == 1)
       for i = 1 : numel (x)
         if (filled)
           h = __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
-                            "faces", 1, "vertices", [x(i), y(i), z(i,:)], 
-                            "facecolor", "none", "edgecolor", "none", 
-                            "marker", marker,  "markersize", s(i), 
+                            "faces", 1, "vertices", [x(i), y(i), z(i,:)],
+                            "facecolor", "none", "edgecolor", "none",
+                            "marker", marker,  "markersize", s(i),
                             "markeredgecolor", c, "markerfacecolor", c,
                             "linestyle", "none");
         else
           h = __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
-                            "faces", 1, "vertices", [x(i), y(i), z(i,:)], 
-                            "facecolor", "none", "edgecolor", "none", 
-                            "marker", marker,  "markersize", s(i), 
+                            "faces", 1, "vertices", [x(i), y(i), z(i,:)],
+                            "facecolor", "none", "edgecolor", "none",
+                            "marker", marker,  "markersize", s(i),
                             "markeredgecolor", c, "markerfacecolor", "none",
                             "linestyle", "none");
         endif
       endfor
     else
       for i = 1 : numel (x)
         if (filled)
           h = __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
-                            "faces", 1, "vertices", [x(i), y(i), z(i,:)], 
-                            "facecolor", "none", "edgecolor", "none", 
-                            "marker", marker, "markersize", s(i), 
-                            "markeredgecolor", "none", 
+                            "faces", 1, "vertices", [x(i), y(i), z(i,:)],
+                            "facecolor", "none", "edgecolor", "none",
+                            "marker", marker, "markersize", s(i),
+                            "markeredgecolor", "none",
                             "markerfacecolor", "flat",
                             "cdata", c(i,:), "linestyle", "none");
         else
           h = __go_patch__ (hg, "xdata", x(i), "ydata", y(i), "zdata", z(i,:),
-                            "faces", 1, "vertices", [x(i), y(i), z(i,:)], 
-                            "facecolor", "none", "edgecolor", "none", 
-                            "marker", marker, "markersize", s(i), 
-                            "markeredgecolor", "flat", 
+                            "faces", 1, "vertices", [x(i), y(i), z(i,:)],
+                            "facecolor", "none", "edgecolor", "none",
+                            "marker", marker, "markersize", s(i),
+                            "markeredgecolor", "flat",
                             "markerfacecolor", "none",
                             "cdata", c(i,:), "linestyle", "none");
 
         endif
       endfor
     endif
 
   else
 
     ## For larger numbers of points, we split the points by common color.
 
     vert = [x, y, z];
 
     if (ischar (c) || rows (c) == 1)
-      h = render_size_color (hg, vert, s, c, marker, filled, false); 
+      h = render_size_color (hg, vert, s, c, marker, filled, false);
     elseif (columns (c) == 1)
-      h = render_size_color (hg, vert, s, c, marker, filled, true); 
+      h = render_size_color (hg, vert, s, c, marker, filled, true);
     else
       [cc, idx] = unique_idx (c, "rows");
       if (isscalar (s))
         for i = 1:rows (x)
-          h = render_size_color (hg, vert(idx{i},:), s, cc(i,:), 
+          h = render_size_color (hg, vert(idx{i},:), s, cc(i,:),
                                  marker, filled, true);
         endfor
       else
         for i = 1:rows (x)
-          h = render_size_color (hg, vert(idx{i},:), s(idx{i}), cc(i,:), 
+          h = render_size_color (hg, vert(idx{i},:), s(idx{i}), cc(i,:),
                                  marker, filled, true);
         endfor
       endif
     endif
   endif
 
   if (! ischar (c) && rows (c) > 1)
     ax = get (hg, "parent");
@@ -231,19 +231,19 @@ function hg = __scatter__ (varargin)
   else
     addproperty ("markerfacecolor", hg, "patchmarkerfacecolor", "none");
     if (ischar (c) || rows (c) == 1)
       addproperty ("markeredgecolor", hg, "patchmarkeredgecolor", c);
     else
       addproperty ("markeredgecolor", hg, "patchmarkeredgecolor", "flat");
     endif
   endif
-  addlistener (hg, "linewidth", @update_props); 
-  addlistener (hg, "marker", @update_props); 
-  addlistener (hg, "markerfacecolor", @update_props); 
+  addlistener (hg, "linewidth", @update_props);
+  addlistener (hg, "marker", @update_props);
+  addlistener (hg, "markerfacecolor", @update_props);
   addlistener (hg, "markeredgecolor", @update_props);
 
   if (! isempty (newargs))
     set (hg, newargs{:})
   endif
 
 endfunction
 
@@ -272,69 +272,69 @@ endfunction
 function h = render_size_color(hg, vert, s, c, marker, filled, isflat)
   if (isscalar (s))
     x = vert(:,1);
     y = vert(:,2);
     z = vert(:,3:end);
     if (ischar (c) || !isflat)
       if (filled)
         h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
-                          "faces", 1, "vertices", vert, 
-                          "facecolor", "none", "edgecolor", "none", 
-                          "marker", marker, 
-                          "markeredgecolor", "none", 
+                          "faces", 1, "vertices", vert,
+                          "facecolor", "none", "edgecolor", "none",
+                          "marker", marker,
+                          "markeredgecolor", "none",
                           "markerfacecolor", c,
                           "markersize", s, "linestyle", "none");
       else
         h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
-                          "faces", 1, "vertices", vert, 
-                          "facecolor", "none", "edgecolor", "none", 
-                          "marker", marker, 
-                          "markeredgecolor", c, 
+                          "faces", 1, "vertices", vert,
+                          "facecolor", "none", "edgecolor", "none",
+                          "marker", marker,
+                          "markeredgecolor", c,
                           "markerfacecolor", "none",
                           "markersize", s, "linestyle", "none");
       endif
     else
       if (filled)
         h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
                           "faces", 1, "vertices", vert,
-                          "facecolor", "none", "edgecolor", "none", 
-                          "marker", marker, "markersize", s, 
-                          "markeredgecolor", "none", 
+                          "facecolor", "none", "edgecolor", "none",
+                          "marker", marker, "markersize", s,
+                          "markeredgecolor", "none",
                           "markerfacecolor", "flat",
                           "cdata", c, "linestyle", "none");
       else
         h = __go_patch__ (hg, "xdata", x, "ydata", y, "zdata", z,
                           "faces", 1, "vertices", vert,
-                          "facecolor", "none", "edgecolor", "none", 
-                          "marker", marker, "markersize", s, 
-                          "markeredgecolor", "flat", 
+                          "facecolor", "none", "edgecolor", "none",
+                          "marker", marker, "markersize", s,
+                          "markeredgecolor", "flat",
                           "markerfacecolor", "none",
                           "cdata", c, "linestyle", "none");
       endif
     endif
   else
     ## FIXME: round the size to one decimal place. It's not quite right, though.
     [ss, idx] = unique_idx (ceil (s*10) / 10);
     for i = 1:rows (ss)
-      h = render_size_color (hg, vert(idx{i},:), ss(i), c, 
+      h = render_size_color (hg, vert(idx{i},:), ss(i), c,
                              marker, filled, isflat);
     endfor
   endif
 endfunction
 
 function update_props (h, d)
   lw = get (h, "linewidth");
   m = get (h, "marker");
   fc = get (h, "markerfacecolor");
   ec = get (h, "markeredgecolor");
   kids = get (h, "children");
 
   for i = 1 : numel (kids)
-    set (kids (i), "linewidth", lw, "marker", m, "markerfacecolor", fc, 
+    set (kids (i), "linewidth", lw, "marker", m, "markerfacecolor", fc,
          "edgecolor", ec)
   endfor
 endfunction
 
 function update_data (h, d)
   x1 = get (h, "xdata");
   y1 = get (h, "ydata");
   z1 = get (h, "zdata");
@@ -357,19 +357,19 @@ function update_data (h, d)
       for i = 1 : length (hlist)
         set (hlist(i), "vertices", [x1(i), y1(i), z1(i)], "cdata", c1,
              "markersize", size1(i));
       endfor
     endif
   else
     if (isempty (z1))
       for i = 1 : length (hlist)
-        set (hlist(i), "vertices", [x1(i), y1(i)], "cdata", 
+        set (hlist(i), "vertices", [x1(i), y1(i)], "cdata",
              reshape(c1(i,:),[1, size(c1)(2:end)]), "markersize", size1(i));
       endfor
     else
       for i = 1 : length (hlist)
-        set (hlist(i), "vertices", [x1(i), y1(i), z1(i)], "cdata", 
+        set (hlist(i), "vertices", [x1(i), y1(i), z1(i)], "cdata",
              reshape(c1(i,:),[1, size(c1)(2:end)]), "markersize", size1(i));
       endfor
     endif
   endif
 endfunction
diff --git a/scripts/plot/private/__stem__.m b/scripts/plot/private/__stem__.m
--- a/scripts/plot/private/__stem__.m
+++ b/scripts/plot/private/__stem__.m
@@ -58,17 +58,17 @@ function h = __stem__ (have_z, varargin)
         xt = [xt; xt; NaN(1, nx)](:);
         yt = y(:, i)';
         yt = [zeros(1, nx); yt; NaN(1, nx)](:);
       endif
 
       hg  = hggroup ();
       h = [h; hg];
       args = __add_datasource__ (caller, hg, {"x", "y", "z"}, varargin{:});
-      
+
       if (i == 1)
         set (ax, "nextplot", "add");
       endif
 
       if (isempty (llc))
         lc = __next_line_color__ ();
       else
         lc = llc;
@@ -82,27 +82,27 @@ function h = __stem__ (have_z, varargin)
 
       if (dofill)
         fc = mc;
       else
         fc = "none";
       endif
 
       if (have_z)
-        h_stems = plot3 (xt, yt, zt, "color", lc, "linestyle", ls, 
+        h_stems = plot3 (xt, yt, zt, "color", lc, "linestyle", ls,
                          "parent", hg, x, y, z, "color", mc,
                          "marker",  ms, "linestyle", "none",
                          "markerfacecolor", fc, "parent", hg);
 
         h_baseline = [];
       else
         h_stems = plot (xt, yt, "color", lc, "linestyle", ls,
                         "parent", hg, x(:,i), y(:, i), "color", mc, "marker",
                         ms, "linestyle", "none", "markerfacecolor",
-                        fc, "parent", hg); 
+                        fc, "parent", hg);
 
         x_axis_range = get (ax, "xlim");
         h_baseline = line (x_axis_range, [0, 0], "color", [0, 0, 0]);
         set (h_baseline, "handlevisibility", "off");
         set (h_baseline, "xliminclude", "off");
         addlistener (ax, "xlim", @update_xlim);
         addlistener (h_baseline, "ydata", @update_baseline);
         addlistener (h_baseline, "visible", @update_baseline);
@@ -110,31 +110,31 @@ function h = __stem__ (have_z, varargin)
 
       ## Setup the hggroup and listeners.
       addproperty ("showbaseline", hg, "radio", "{on}|off");
       addproperty ("basevalue", hg, "data", 0);
       addproperty ("baseline", hg, "data", h_baseline);
 
       if (!have_z)
         addlistener (hg, "showbaseline", @show_baseline);
-        addlistener (hg, "basevalue", @move_baseline); 
+        addlistener (hg, "basevalue", @move_baseline);
       endif
 
       addproperty ("color", hg, "linecolor", lc);
       addproperty ("linewidth", hg, "linelinewidth", 0.5);
       addproperty ("linestyle", hg, "linelinestyle", ls);
       addproperty ("marker", hg, "linemarker", ms);
       addproperty ("markerfacecolor", hg, "linemarkerfacecolor", fc);
       addproperty ("markersize", hg, "linemarkersize", 6);
 
       addlistener (hg, "color", @update_props);
-      addlistener (hg, "linewidth", @update_props); 
-      addlistener (hg, "linestyle", @update_props); 
-      addlistener (hg, "marker", @update_props); 
-      addlistener (hg, "markerfacecolor", @update_props); 
+      addlistener (hg, "linewidth", @update_props);
+      addlistener (hg, "linestyle", @update_props);
+      addlistener (hg, "marker", @update_props);
+      addlistener (hg, "markerfacecolor", @update_props);
       addlistener (hg, "markersize", @update_props);
 
       addproperty ("xdata", hg, "data", x(:, i));
       addproperty ("ydata", hg, "data", y(:, i));
       if (have_z)
         addproperty ("zdata", hg, "data", z(:, i));
       else
         addproperty ("zdata", hg, "data", []);
@@ -200,17 +200,17 @@ function [x, y, z, dofill, lc, ls, mc, m
       x = 1:rows (z);
       y = 1:columns (z);
     else
       y = varargin{1};
       if (isvector (y))
         x = 1:length (y);
       elseif (ismatrix (y))
         x = 1:rows (y);
-      else 
+      else
         error ("stem: Y must be a matrix");
       endif # in each case, x & y will be defined
     endif
   elseif (nargin == 3)
     ## Several possibilities
     ##
     ## 1. the real y data
     ## 2. 'filled'
@@ -477,17 +477,17 @@ endfunction
 
 function update_baseline (h, d)
   visible = get (h, "visible");
   ydata = get (h, "ydata")(1);
 
   kids = get (get (h, "parent"), "children");
   for i = 1 : length (kids)
     obj = get (kids (i));
-    if (strcmp (obj.type, "hggroup") && isfield (obj, "baseline") 
+    if (strcmp (obj.type, "hggroup") && isfield (obj, "baseline")
         && obj.baseline == h)
       ## Only alter if changed to avoid recursion of the listener functions
       if (! strcmpi (get (kids(i), "showbaseline"), visible))
         set (kids (i), "showbaseline", visible);
       endif
       if (! strcmpi (get (kids(i), "basevalue"), visible))
         set (kids (i), "basevalue", ydata);
       endif
@@ -511,20 +511,20 @@ function move_baseline (h, d)
   yt = get(h, "ydata")(:)';
   ny = length (yt);
   yt = [b0 * ones(1, ny); yt; NaN(1, ny)](:);
   set (kids(2), "ydata", yt);
 endfunction
 
 function update_props (h, d)
   kids = get (h, "children");
-  set (kids(2), "color", get (h, "color"), 
+  set (kids(2), "color", get (h, "color"),
        "linewidth", get (h, "linewidth"),
        "linestyle", get (h, "linestyle"));
-  set (kids(1), "color", get (h, "color"), 
+  set (kids(1), "color", get (h, "color"),
        "marker", get (h, "marker"),
        "markerfacecolor", get (h, "markerfacecolor"),
        "markersize", get (h, "markersize"));
 endfunction
 
 function update_data (h, d)
   x = get (h, "xdata");
   y = get (h, "ydata");
diff --git a/scripts/plot/private/__tight_eps_bbox__.m b/scripts/plot/private/__tight_eps_bbox__.m
--- a/scripts/plot/private/__tight_eps_bbox__.m
+++ b/scripts/plot/private/__tight_eps_bbox__.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2010-2011 Ben Abbott
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
diff --git a/scripts/plot/quiver.m b/scripts/plot/quiver.m
--- a/scripts/plot/quiver.m
+++ b/scripts/plot/quiver.m
@@ -20,26 +20,26 @@
 ## @deftypefn  {Function File} {} quiver (@var{u}, @var{v})
 ## @deftypefnx {Function File} {} quiver (@var{x}, @var{y}, @var{u}, @var{v})
 ## @deftypefnx {Function File} {} quiver (@dots{}, @var{s})
 ## @deftypefnx {Function File} {} quiver (@dots{}, @var{style})
 ## @deftypefnx {Function File} {} quiver (@dots{}, 'filled')
 ## @deftypefnx {Function File} {} quiver (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} quiver (@dots{})
 ##
-## Plot the @code{(@var{u}, @var{v})} components of a vector field in 
-## an @code{(@var{x}, @var{y})} meshgrid.  If the grid is uniform, you can 
+## Plot the @code{(@var{u}, @var{v})} components of a vector field in
+## an @code{(@var{x}, @var{y})} meshgrid.  If the grid is uniform, you can
 ## specify @var{x} and @var{y} as vectors.
 ##
 ## If @var{x} and @var{y} are undefined they are assumed to be
-## @code{(1:@var{m}, 1:@var{n})} where @code{[@var{m}, @var{n}] = 
+## @code{(1:@var{m}, 1:@var{n})} where @code{[@var{m}, @var{n}] =
 ## size(@var{u})}.
 ##
 ## The variable @var{s} is a scalar defining a scaling factor to use for
-##  the arrows of the field relative to the mesh spacing.  A value of 0 
+##  the arrows of the field relative to the mesh spacing.  A value of 0
 ## disables all scaling.  The default value is 1.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ## If a marker is specified then markers at the grid points of the vectors are
 ## printed rather than arrows.  If the argument 'filled' is given then the
 ## markers as filled.
 ##
diff --git a/scripts/plot/quiver3.m b/scripts/plot/quiver3.m
--- a/scripts/plot/quiver3.m
+++ b/scripts/plot/quiver3.m
@@ -20,26 +20,26 @@
 ## @deftypefn  {Function File} {} quiver3 (@var{u}, @var{v}, @var{w})
 ## @deftypefnx {Function File} {} quiver3 (@var{x}, @var{y}, @var{z}, @var{u}, @var{v}, @var{w})
 ## @deftypefnx {Function File} {} quiver3 (@dots{}, @var{s})
 ## @deftypefnx {Function File} {} quiver3 (@dots{}, @var{style})
 ## @deftypefnx {Function File} {} quiver3 (@dots{}, 'filled')
 ## @deftypefnx {Function File} {} quiver3 (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} quiver3 (@dots{})
 ##
-## Plot the @code{(@var{u}, @var{v}, @var{w})} components of a vector field in 
-## an @code{(@var{x}, @var{y}), @var{z}} meshgrid.  If the grid is uniform, you 
+## Plot the @code{(@var{u}, @var{v}, @var{w})} components of a vector field in
+## an @code{(@var{x}, @var{y}), @var{z}} meshgrid.  If the grid is uniform, you
 ## can specify @var{x}, @var{y} @var{z} as vectors.
 ##
 ## If @var{x}, @var{y} and @var{z} are undefined they are assumed to be
-## @code{(1:@var{m}, 1:@var{n}, 1:@var{p})} where @code{[@var{m}, @var{n}] = 
+## @code{(1:@var{m}, 1:@var{n}, 1:@var{p})} where @code{[@var{m}, @var{n}] =
 ## size(@var{u})} and @code{@var{p} = max (size (@var{w}))}.
 ##
 ## The variable @var{s} is a scalar defining a scaling factor to use for
-##  the arrows of the field relative to the mesh spacing.  A value of 0 
+##  the arrows of the field relative to the mesh spacing.  A value of 0
 ## disables all scaling.  The default value is 1.
 ##
 ## The style to use for the plot can be defined with a line style @var{style}
 ## in a similar manner to the line styles used with the @code{plot} command.
 ## If a marker is specified then markers at the grid points of the vectors are
 ## printed rather than arrows.  If the argument 'filled' is given then the
 ## markers as filled.
 ##
@@ -82,22 +82,22 @@ function retval = quiver3 (varargin)
     retval = tmp;
   endif
 
 endfunction
 
 %!demo
 %! clf
 %! colormap (jet (64))
-%! [x,y]=meshgrid (-1:0.1:1); 
-%! z=sin(2*pi*sqrt(x.^2+y.^2)); 
+%! [x,y]=meshgrid (-1:0.1:1);
+%! z=sin(2*pi*sqrt(x.^2+y.^2));
 %! theta=2*pi*sqrt(x.^2+y.^2)+pi/2;
 %! quiver3(x,y,z,sin(theta),cos(theta),ones(size(z)));
-%! hold on; 
-%! mesh(x,y,z); 
+%! hold on;
+%! mesh(x,y,z);
 %! hold off;
 
 %!demo
 %! clf
 %! [x, y, z] = peaks (25);
 %! surf (x, y, z);
 %! hold on;
 %! [u, v, w] = surfnorm (x, y, z / 10);
diff --git a/scripts/plot/refreshdata.m b/scripts/plot/refreshdata.m
--- a/scripts/plot/refreshdata.m
+++ b/scripts/plot/refreshdata.m
@@ -60,17 +60,17 @@ function refreshdata (h, workspace)
       h = [h{:}];
     endif
     if (!all (ishandle (h)) || !all (strcmp (get (h, "type"), "figure")))
       error ("refreshdata: expecting a list of figure handles");
     endif
     if (nargin < 2)
       workspace = "base";
     else
-      if (   !ischar (workspace) 
+      if (   !ischar (workspace)
           || !(strcmpi (workspace, "base")
           || strcmpi (workspace, "caller")))
         error ("refreshdata: expecting WORKSPACE to be \"base\" or ""caller\"");
       else
         workspace = tolower (workspace);
       endif
     endif
   endif
diff --git a/scripts/plot/rose.m b/scripts/plot/rose.m
--- a/scripts/plot/rose.m
+++ b/scripts/plot/rose.m
@@ -22,54 +22,54 @@
 ## @deftypefnx {Function File} {@var{h} =} rose (@dots{})
 ## @deftypefnx {Function File} {[@var{r}, @var{th}] =} rose (@dots{})
 ##
 ## Plot an angular histogram.  With one vector argument @var{th}, plots the
 ## histogram with 20 angular bins.  If @var{th} is a matrix, then each column
 ## of @var{th} produces a separate histogram.
 ##
 ## If @var{r} is given and is a scalar, then the histogram is produced with
-## @var{r} bins.  If @var{r} is a vector, then the center of each bin are 
+## @var{r} bins.  If @var{r} is a vector, then the center of each bin are
 ## defined by the values of @var{r}.
 ##
-## The optional return value @var{h} provides a list of handles to the 
+## The optional return value @var{h} provides a list of handles to the
 ## the parts of the vector field (body, arrow and marker).
 ##
-## If two output arguments are requested, then rather than plotting the 
-## histogram, the polar vectors necessary to plot the histogram are 
+## If two output arguments are requested, then rather than plotting the
+## histogram, the polar vectors necessary to plot the histogram are
 ## returned.
 ##
 ## @example
 ## @group
 ## [r, t] = rose ([2*randn(1e5,1), pi + 2 * randn(1e5,1)]);
 ## polar (r, t);
 ## @end group
 ## @end example
 ##
 ##
 ## @seealso{plot, compass, polar, hist}
 ## @end deftypefn
 
 function [thout, rout] = rose (varargin)
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout > 1), "rose", 
+  [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout > 1), "rose",
                                                 varargin{:});
 
   if (nargin < 1)
     print_usage ();
   endif
 
   ## Force theta to [0,2*pi] range
   th = varargin {1};
   th = atan2  (sin (th), cos (th)) + pi;
 
   if (nargin > 1)
     x = varargin {2};
     if (isscalar (x))
-      x = [0.5/x : 1/x : 1] * 2 * pi; 
+      x = [0.5/x : 1/x : 1] * 2 * pi;
     else
       ## Force theta to [0,2*pi] range
       x = atan2  (sin (x), cos (x)) + pi;
     endif
   else
     x = [1/40 : 1/20 : 1] * 2 * pi;
   endif
 
diff --git a/scripts/plot/saveas.m b/scripts/plot/saveas.m
--- a/scripts/plot/saveas.m
+++ b/scripts/plot/saveas.m
@@ -15,18 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} saveas (@var{h}, @var{filename})
 ## @deftypefnx {Function File} {} saveas (@var{h}, @var{filename}, @var{fmt})
 ## Save graphic object @var{h} to the file @var{filename} in graphic
-## format @var{fmt}. 
-## 
+## format @var{fmt}.
+##
 ## @var{fmt} should be one of the following formats:
 ##
 ## @table @code
 ##   @item ps
 ##     Postscript
 ##
 ##   @item eps
 ##     Encapsulated Postscript
@@ -72,17 +72,17 @@ function  saveas (h, filename, fmt = "pd
     if (isfigure (h))
       fig = h;
     else
       fig = ancestor (h, "figure");
     endif
   else
     error ("saveas: first argument H must be a graphics handle");
   endif
-  
+
   if (!ischar (filename))
     error ("saveas: FILENAME must be a string");
   endif
 
   if (nargin == 2)
     [~, ~, ext] = fileparts (filename);
     if (!isempty (ext))
       fmt = ext(2:end);
@@ -97,12 +97,12 @@ function  saveas (h, filename, fmt = "pd
     [~, ~, ext] = fileparts (filename);
 
     if (isempty (ext))
       filename = strcat (filename, ".", fmt);
     endif
   endif
 
   prt_opt = strcat ("-d", tolower (fmt));
-  
+
   print (filename, prt_opt);
 
 endfunction
diff --git a/scripts/plot/scatter.m b/scripts/plot/scatter.m
--- a/scripts/plot/scatter.m
+++ b/scripts/plot/scatter.m
@@ -22,31 +22,31 @@
 ## @deftypefnx {Function File} {} scatter (@var{x}, @var{y}, @var{c})
 ## @deftypefnx {Function File} {} scatter (@var{x}, @var{y}, @var{s}, @var{c})
 ## @deftypefnx {Function File} {} scatter (@var{x}, @var{y}, @var{s}, @var{c}, 'filled')
 ## @deftypefnx {Function File} {} scatter (@var{x}, @var{y}, @var{s}, @var{c}, @var{style})
 ## @deftypefnx {Function File} {} scatter (@var{x}, @var{y}, @var{s}, @var{c}, @var{prop}, @var{val})
 ## @deftypefnx {Function File} {} scatter (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} scatter (@dots{})
 ##
-## Plot a scatter plot of the data.  A marker is plotted at each point 
+## Plot a scatter plot of the data.  A marker is plotted at each point
 ## defined by the points in the vectors @var{x} and @var{y}.  The size of
-## the markers used is determined by the @var{s}, which can be a scalar, 
-## a vector of the same length of @var{x} and @var{y}.  If @var{s} is not 
+## the markers used is determined by the @var{s}, which can be a scalar,
+## a vector of the same length of @var{x} and @var{y}.  If @var{s} is not
 ## given or is an empty matrix, then the default value of 8 points is used.
 ##
 ## The color of the markers is determined by @var{c}, which can be a string
-## defining a fixed color; a 3-element vector giving the red, green,and blue 
+## defining a fixed color; a 3-element vector giving the red, green,and blue
 ## components of the color; a vector of the same length as @var{x} that gives
 ## a scaled index into the current colormap; or a @var{n}-by-3 matrix defining
 ## the colors of each of the markers individually.
 ##
-## The marker to use can be changed with the @var{style} argument, that is a 
-## string defining a marker in the same manner as the @code{plot} command. 
-## If the argument 'filled' is given then the markers as filled.  All 
+## The marker to use can be changed with the @var{style} argument, that is a
+## string defining a marker in the same manner as the @code{plot} command.
+## If the argument 'filled' is given then the markers as filled.  All
 ## additional arguments are passed to the underlying patch command.
 ##
 ## The optional return value @var{h} provides a handle to the patch object
 ##
 ## @example
 ## @group
 ## x = randn (100, 1);
 ## y = randn (100, 1);
@@ -95,17 +95,17 @@ endfunction
 %! rand_10x1_data1 = [0.171577, 0.404796, 0.025469, 0.335309, 0.047814, 0.898480, 0.639599, 0.700247, 0.497798, 0.737940];
 %! rand_10x1_data2 = [0.75495, 0.83991, 0.80850, 0.73603, 0.19360, 0.72573, 0.69371, 0.74388, 0.13837, 0.54143];
 %! x = rand_10x1_data1;
 %! y = rand_10x1_data2;
 %! s = 10 - 10*log (x.^2 + y.^2);
 %! h = scatter (x, y, s, s, "s", "filled");
 
 %!demo
-%! rand_10x1_data3 = [0.42262, 0.51623, 0.65992, 0.14999, 0.68385, 0.55929, 0.52251, 0.92204, 0.19762, 0.93726]; 
+%! rand_10x1_data3 = [0.42262, 0.51623, 0.65992, 0.14999, 0.68385, 0.55929, 0.52251, 0.92204, 0.19762, 0.93726];
 %! rand_10x1_data4 = [0.020207, 0.527193, 0.443472, 0.061683, 0.370277, 0.947349, 0.249591, 0.666304, 0.134247, 0.920356];
 %! x = rand_10x1_data3;
 %! y = rand_10x1_data4;
 %! s = 10 - 10*log (x.^2 + y.^2);
 %! h = scatter (x, y, [], "r", "s", "filled");
 
 %!demo
 %! rand_10x1_data5 = [0.777753, 0.093848, 0.183162, 0.399499, 0.337997, 0.686724, 0.073906, 0.651808, 0.869273, 0.137949];
diff --git a/scripts/plot/scatter3.m b/scripts/plot/scatter3.m
--- a/scripts/plot/scatter3.m
+++ b/scripts/plot/scatter3.m
@@ -19,31 +19,31 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} scatter3 (@var{x}, @var{y}, @var{z}, @var{s}, @var{c})
 ## @deftypefnx {Function File} {} scatter3 (@dots{}, 'filled')
 ## @deftypefnx {Function File} {} scatter3 (@dots{}, @var{style})
 ## @deftypefnx {Function File} {} scatter3 (@dots{}, @var{prop}, @var{val})
 ## @deftypefnx {Function File} {} scatter3 (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} scatter3 (@dots{})
 ##
-## Plot a scatter plot of the data in 3D@.  A marker is plotted at each point 
+## Plot a scatter plot of the data in 3D@.  A marker is plotted at each point
 ## defined by the points in the vectors @var{x}, @var{y} and @var{z}.  The size
 ## of the markers used is determined by @var{s}, which can be a scalar or
 ## a vector of the same length of @var{x}, @var{y} and @var{z}.  If @var{s} is
 ## not given or is an empty matrix, then the default value of 8 points is used.
 ##
 ## The color of the markers is determined by @var{c}, which can be a string
-## defining a fixed color; a 3-element vector giving the red, green, and blue 
+## defining a fixed color; a 3-element vector giving the red, green, and blue
 ## components of the color; a vector of the same length as @var{x} that gives
 ## a scaled index into the current colormap; or a @var{n}-by-3 matrix defining
 ## the colors of each of the markers individually.
 ##
-## The marker to use can be changed with the @var{style} argument, that is a 
-## string defining a marker in the same manner as the @code{plot} command. 
-## If the argument 'filled' is given then the markers as filled.  All 
+## The marker to use can be changed with the @var{style} argument, that is a
+## string defining a marker in the same manner as the @code{plot} command.
+## If the argument 'filled' is given then the markers as filled.  All
 ## additional arguments are passed to the underlying patch command.
 ##
 ## The optional return value @var{h} provides a handle to the patch object
 ##
 ## @example
 ## @group
 ## [x, y, z] = peaks (20);
 ## scatter3 (x(:), y(:), z(:), [], z(:));
diff --git a/scripts/plot/semilogx.m b/scripts/plot/semilogx.m
--- a/scripts/plot/semilogx.m
+++ b/scripts/plot/semilogx.m
@@ -31,17 +31,17 @@
 
 ## Author: jwe
 
 function retval = semilogx (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("semilogx", varargin{:});
 
   if (nargs < 1)
-    print_usage(); 
+    print_usage();
   endif
 
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
 
     set (h, "xscale", "log");
diff --git a/scripts/plot/semilogxerr.m b/scripts/plot/semilogxerr.m
--- a/scripts/plot/semilogxerr.m
+++ b/scripts/plot/semilogxerr.m
@@ -14,27 +14,27 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} semilogxerr (@var{args})
 ## Produce two-dimensional plots using a logarithmic scale for the @var{x}
-## axis and errorbars at each data point.  Many different combinations of 
+## axis and errorbars at each data point.  Many different combinations of
 ## arguments are possible.  The most used form is
 ##
 ## @example
 ## semilogxerr (@var{x}, @var{y}, @var{ey}, @var{fmt})
 ## @end example
 ##
 ## @noindent
 ## which produces a semi-logarithmic plot of @var{y} versus @var{x}
 ## with errors in the @var{y}-scale defined by @var{ey} and the plot
-## format defined by @var{fmt}.  See @code{errorbar} for available formats and 
+## format defined by @var{fmt}.  See @code{errorbar} for available formats and
 ## additional information.
 ## @seealso{errorbar, loglogerr semilogyerr}
 ## @end deftypefn
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
diff --git a/scripts/plot/semilogy.m b/scripts/plot/semilogy.m
--- a/scripts/plot/semilogy.m
+++ b/scripts/plot/semilogy.m
@@ -31,17 +31,17 @@
 
 ## Author: jwe
 
 function retval = semilogy (varargin)
 
   [h, varargin, nargs] = __plt_get_axis_arg__ ("semilogy", varargin{:});
 
   if (nargs < 1)
-    print_usage(); 
+    print_usage();
   endif
 
   oldh = gca ();
   unwind_protect
     axes (h);
     newplot ();
 
     set (h, "yscale", "log");
diff --git a/scripts/plot/semilogyerr.m b/scripts/plot/semilogyerr.m
--- a/scripts/plot/semilogyerr.m
+++ b/scripts/plot/semilogyerr.m
@@ -14,27 +14,27 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} semilogyerr (@var{args})
 ## Produce two-dimensional plots using a logarithmic scale for the @var{y}
-## axis and errorbars at each data point.  Many different combinations of 
+## axis and errorbars at each data point.  Many different combinations of
 ## arguments are possible.  The most used form is
 ##
 ## @example
 ## semilogyerr (@var{x}, @var{y}, @var{ey}, @var{fmt})
 ## @end example
 ##
 ## @noindent
 ## which produces a semi-logarithmic plot of @var{y} versus @var{x}
 ## with errors in the @var{y}-scale defined by @var{ey} and the plot
-## format defined by @var{fmt}.  See @code{errorbar} for available formats and 
+## format defined by @var{fmt}.  See @code{errorbar} for available formats and
 ## additional information.
 ## @seealso{errorbar, loglogerr semilogxerr}
 ## @end deftypefn
 
 ## Created: 20.2.2001
 ## Author: Teemu Ikonen <tpikonen@pcu.helsinki.fi>
 ## Keywords: errorbar, plotting
 
diff --git a/scripts/plot/shading.m b/scripts/plot/shading.m
--- a/scripts/plot/shading.m
+++ b/scripts/plot/shading.m
@@ -51,17 +51,17 @@ function shading (varargin)
   mode = varargin{1};
 
   h1 = findobj (ax, "type", "patch");
   h2 = findobj (ax, "type", "surface");
 
   obj = [h1(:); h2(:)];
 
   for n = 1:numel(obj)
-    h = obj(n); 
+    h = obj(n);
     if (strcmpi (mode, "flat"))
       set (h, "facecolor", "flat");
       set (h, "edgecolor", "none");
     elseif (strcmpi (mode, "interp"))
       set (h, "facecolor", "interp");
       set (h, "edgecolor", "none");
     elseif (strcmpi (mode, "faceted"))
       set (h, "facecolor", "flat");
diff --git a/scripts/plot/slice.m b/scripts/plot/slice.m
--- a/scripts/plot/slice.m
+++ b/scripts/plot/slice.m
@@ -18,29 +18,29 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} slice (@var{x}, @var{y}, @var{z}, @var{v}, @var{sx}, @var{sy}, @var{sz})
 ## @deftypefnx {Function File} {} slice (@var{x}, @var{y}, @var{z}, @var{v}, @var{xi}, @var{yi}, @var{zi})
 ## @deftypefnx {Function File} {} slice (@var{v}, @var{sx}, @var{sy}, @var{sz})
 ## @deftypefnx {Function File} {} slice (@var{v}, @var{xi}, @var{yi}, @var{zi})
 ## @deftypefnx {Function File} {@var{h} =} slice (@dots{})
 ## @deftypefnx {Function File} {@var{h} =} slice (@dots{}, @var{method})
-## Plot slices of 3-D data/scalar fields.  Each element of the 3-dimensional 
+## Plot slices of 3-D data/scalar fields.  Each element of the 3-dimensional
 ## array @var{v} represents a scalar value at a location given by the
 ## parameters @var{x}, @var{y}, and @var{z}.  The parameters @var{x},
 ## @var{x}, and @var{z} are either 3-dimensional arrays of the same size
 ## as the array @var{v} in the "meshgrid" format or vectors.  The
 ## parameters @var{xi}, etc. respect a similar format to @var{x}, etc.,
 ## and they represent the points at which the array @var{vi} is
 ## interpolated using interp3.  The vectors @var{sx}, @var{sy}, and
 ## @var{sz} contain points of orthogonal slices of the respective axes.
 ##
-## If @var{x}, @var{y}, @var{z} are omitted, they are assumed to be 
+## If @var{x}, @var{y}, @var{z} are omitted, they are assumed to be
 ## @code{x = 1:size (@var{v}, 2)}, @code{y = 1:size (@var{v}, 1)} and
-## @code{z = 1:size (@var{v}, 3)}. 
+## @code{z = 1:size (@var{v}, 3)}.
 ##
 ## @var{Method} is one of:
 ##
 ## @table @code
 ## @item "nearest"
 ## Return the nearest neighbor.
 ##
 ## @item "linear"
diff --git a/scripts/plot/specular.m b/scripts/plot/specular.m
--- a/scripts/plot/specular.m
+++ b/scripts/plot/specular.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} specular (@var{sx}, @var{sy}, @var{sz}, @var{lv}, @var{vv})
 ## @deftypefnx {Function File} {} specular (@var{sx}, @var{sy}, @var{sz}, @var{lv}, @var{vv}, @var{se})
 ## Calculate specular reflection strength of a surface defined by the normal
-## vector elements @var{sx}, @var{sy}, @var{sz} using Phong's approximation. 
+## vector elements @var{sx}, @var{sy}, @var{sz} using Phong's approximation.
 ## The light and view vectors can be specified using parameter @var{lv} and
 ## @var{vv} respectively.
 ## Both can be given as 2-element vectors [azimuth, elevation] in degrees or as
 ## 3-element
 ## vector [x, y, z].  An optional 6th argument describes the specular exponent
 ## (spread) @var{se}.
 ## @seealso{surfl, diffuse}
 ## @end deftypefn
@@ -46,17 +46,17 @@ function retval = specular (sx, sy, sz, 
       error ("specular: exponent must be positive scalar");
     endif
   endif
 
   ## Checks for normal vector.
   if (!size_equal (sx, sy, sz))
     error ("specular: SX, SY, and SZ must have same size");
   endif
-  
+
   ## Check for light vector (lv) argument.
   if (length (lv) < 2 || length (lv) > 3)
     error ("specular: light vector LV must be a 2- or 3-element vector");
   elseif (length (lv) == 2)
     [lv(1), lv(2), lv(3)] = sph2cart (lv(1) * pi/180, lv(2) * pi/180, 1.0);
   endif
 
   ## Check for view vector (vv) argument.
@@ -76,17 +76,17 @@ function retval = specular (sx, sy, sz, 
 
   ## Calculate normal vector lengths and dot-products.
   ns = sqrt (sx.^2 + sy.^2 + sz.^2);
   l_dot_n = (sx * lv(1) + sy * lv(2) + sz * lv(3)) ./ ns;
   v_dot_n = (sx * vv(1) + sy * vv(2) + sz * vv(3)) ./ ns;
 
   ## Calculate specular reflection using Phong's approximation.
   retval = 2 * l_dot_n .* v_dot_n - dot (lv, vv);
-  
+
   ## Set zero if light is on the other side.
   retval(l_dot_n < 0) = 0;
 
   ## Allow postive values only.
   retval(retval < 0) = 0;
   retval = retval .^ se;
-  
+
 endfunction
diff --git a/scripts/plot/sphere.m b/scripts/plot/sphere.m
--- a/scripts/plot/sphere.m
+++ b/scripts/plot/sphere.m
@@ -14,30 +14,30 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{x}, @var{y}, @var{z}] =} sphere (@var{n})
 ## @deftypefnx {Function File} {} sphere (@var{h}, @dots{})
-## Generates three matrices in @code{meshgrid} format, such that 
-## @code{surf (@var{x}, @var{y}, @var{z})} generates a unit sphere. 
-## The matrices of @code{@var{n}+1}-by-@code{@var{n}+1}.  If @var{n} is 
+## Generates three matrices in @code{meshgrid} format, such that
+## @code{surf (@var{x}, @var{y}, @var{z})} generates a unit sphere.
+## The matrices of @code{@var{n}+1}-by-@code{@var{n}+1}.  If @var{n} is
 ## omitted then a default value of 20 is assumed.
 ##
-## Called with no return arguments, @code{sphere} call directly 
+## Called with no return arguments, @code{sphere} call directly
 ## @code{surf (@var{x}, @var{y}, @var{z})}.  If an axes handle is passed
 ## as the first argument, the surface is plotted to this set of axes.
 ## @seealso{peaks}
 ## @end deftypefn
 
 function [xx, yy, zz] = sphere (varargin)
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout > 0), "sphere", 
+  [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout > 0), "sphere",
                                                 varargin{:});
   if (nargin > 1)
     print_usage ();
   elseif (nargin == 1)
     n = varargin{1};
   else
     n = 20;
   endif
diff --git a/scripts/plot/stairs.m b/scripts/plot/stairs.m
--- a/scripts/plot/stairs.m
+++ b/scripts/plot/stairs.m
@@ -145,17 +145,17 @@ function [h, xs, ys] = __stairs__ (doplo
     if ((ischar (arg) || iscell (arg)) && ! have_line_spec)
       [linespec, valid] = __pltopt__ ("stairs", arg, false);
       if (valid)
         have_line_spec = true;
         varargin(i) = [];
         break;
       endif
     endif
-  endfor 
+  endfor
 
   if (doplot)
     h = [];
     unwind_protect
       hold_state = get (gca (), "nextplot");
       for i = 1 : size(y, 2)
         hg = hggroup ();
         h = [h; hg];
@@ -183,22 +183,22 @@ function [h, xs, ys] = __stairs__ (doplo
         addproperty ("markerfacecolor", hg, "linemarkerfacecolor",
                      get (tmp, "markerfacecolor"));
         addproperty ("markeredgecolor", hg, "linemarkeredgecolor",
                      get (tmp, "markeredgecolor"));
         addproperty ("markersize", hg, "linemarkersize",
                      get (tmp, "markersize"));
 
         addlistener (hg, "color", @update_props);
-        addlistener (hg, "linewidth", @update_props); 
-        addlistener (hg, "linestyle", @update_props); 
-        addlistener (hg, "marker", @update_props); 
-        addlistener (hg, "markerfacecolor", @update_props); 
-        addlistener (hg, "markeredgecolor", @update_props); 
-        addlistener (hg, "markersize", @update_props); 
+        addlistener (hg, "linewidth", @update_props);
+        addlistener (hg, "linestyle", @update_props);
+        addlistener (hg, "marker", @update_props);
+        addlistener (hg, "markerfacecolor", @update_props);
+        addlistener (hg, "markeredgecolor", @update_props);
+        addlistener (hg, "markersize", @update_props);
 
         if (! isempty (args))
           set (hg, args{:});
         endif
       endfor
     unwind_protect_cleanup
       set (gca (), "nextplot", hold_state);
     end_unwind_protect
@@ -226,17 +226,17 @@ endfunction
 %! stairs (1:9);
 
 %!demo
 %! [xs, ys] = stairs (9:-1:1);
 %! plot (xs, ys);
 
 
 function update_props (h, d)
-  set (get (h, "children"), "color", get (h, "color"), 
+  set (get (h, "children"), "color", get (h, "color"),
        "linewidth", get (h, "linewidth"),
        "linestyle", get (h, "linestyle"),
        "marker", get (h, "marker"),
        "markerfacecolor", get (h, "markerfacecolor"),
        "markeredgecolor", get (h, "markeredgecolor"),
        "markersize", get (h, "markersize"));
 endfunction
 
diff --git a/scripts/plot/stem.m b/scripts/plot/stem.m
--- a/scripts/plot/stem.m
+++ b/scripts/plot/stem.m
@@ -41,17 +41,17 @@
 ## x = 1:10;
 ## y = ones (1, length (x))*2.*x;
 ## stem (x, y, "r");
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## plots 10 stems with heights from 2 to 20 in red;
-## 
+##
 ## The return value of @code{stem} is a vector of "stem series" graphics
 ## handles, with one handle per column of the variable @var{y}.  This
 ## handle regroups the elements of the stem graph together as the
 ## children of the "stem series" handle, allowing them to be altered
 ## together.  For example,
 ##
 ## @example
 ## @group
diff --git a/scripts/plot/stem3.m b/scripts/plot/stem3.m
--- a/scripts/plot/stem3.m
+++ b/scripts/plot/stem3.m
@@ -22,23 +22,23 @@
 ## and marker objects used to draw the stems as "stem series" object.
 ## The default color is @code{"r"} (red).  The default line style is
 ## @code{"-"} and the default marker is @code{"o"}.
 ##
 ## For example,
 ##
 ## @example
 ## @group
-## theta = 0:0.2:6; 
-## stem3 (cos (theta), sin (theta), theta) 
+## theta = 0:0.2:6;
+## stem3 (cos (theta), sin (theta), theta)
 ## @end group
 ## @end example
 ##
 ## @noindent
-## plots 31 stems with heights from 0 to 6 lying on a circle.  Color 
+## plots 31 stems with heights from 0 to 6 lying on a circle.  Color
 ## definitions with RGB-triples are not valid!
 ## @seealso{bar, barh, stem, plot}
 ## @end deftypefn
 
 function h = stem3 (varargin)
 
   if (nargin < 1 || nargin > 4)
     print_usage ();
@@ -48,10 +48,10 @@ function h = stem3 (varargin)
 
   if (nargout > 0)
     h = tmp;
   endif
 
 endfunction
 
 %!demo
-%! theta = 0:0.2:6; 
-%! stem3 (cos (theta), sin (theta), theta) 
+%! theta = 0:0.2:6;
+%! stem3 (cos (theta), sin (theta), theta)
diff --git a/scripts/plot/subplot.m b/scripts/plot/subplot.m
--- a/scripts/plot/subplot.m
+++ b/scripts/plot/subplot.m
@@ -142,17 +142,17 @@ function h = subplot (rows, cols, index,
           found = true;
           tmp = child;
         else
           ## If the new axes overlap an old axes object, delete the old
           ## axes.
           x0 = pos(1);
           x1 = x0 + pos(3);
           y0 = pos(2);
-          y1 = y0 + pos(4);     
+          y1 = y0 + pos(4);
           objx0 = objpos(1);
           objx1 = objx0 + objpos(3);
           objy0 = objpos(2);
           objy1 = objy0 + objpos(4);
           if (! (x0 >= objx1 || x1 <= objx0 || y0 >= objy1 || y1 <= objy0))
             delete (child);
           endif
         endif
diff --git a/scripts/plot/surface.m b/scripts/plot/surface.m
--- a/scripts/plot/surface.m
+++ b/scripts/plot/surface.m
@@ -19,21 +19,21 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} surface (@var{x}, @var{y}, @var{z}, @var{c})
 ## @deftypefnx {Function File} {} surface (@var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {} surface (@var{z}, @var{c})
 ## @deftypefnx {Function File} {} surface (@var{z})
 ## @deftypefnx {Function File} {} surface (@dots{}, @var{prop}, @var{val})
 ## @deftypefnx {Function File} {} surface (@var{h}, @dots{})
 ## @deftypefnx {Function File} {@var{h} =} surface (@dots{})
-## Plot a surface graphic object given matrices @var{x}, and @var{y} from 
-## @code{meshgrid} and a matrix @var{z} corresponding to the @var{x} and 
+## Plot a surface graphic object given matrices @var{x}, and @var{y} from
+## @code{meshgrid} and a matrix @var{z} corresponding to the @var{x} and
 ## @var{y} coordinates of the surface.  If @var{x} and @var{y} are vectors,
-## then a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, 
-## columns of @var{z} correspond to different @var{x} values and rows of 
+## then a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus,
+## columns of @var{z} correspond to different @var{x} values and rows of
 ## @var{z} correspond to different @var{y} values.  If @var{x} and @var{y}
 ## are missing, they are constructed from size of the matrix @var{z}.
 ##
 ## Any additional properties passed are assigned to the surface.
 ## @seealso{surf, mesh, patch, line}
 ## @end deftypefn
 
 ## Author: jwe
@@ -111,27 +111,27 @@ function [h, bad_usage] = __surface__ (a
       endif
     elseif (ismatrix (x) && ismatrix (y) && ismatrix (z))
       if (! size_equal (x, y, z))
         error ("surface: X, Y, and Z must have the same dimensions");
       endif
     else
       error ("surface: X and Y must be vectors and Z must be a matrix");
     endif
-  elseif (firststring == 3)    
+  elseif (firststring == 3)
     z = varargin{1};
     c = varargin{2};
     if (ismatrix (z) && !isvector (z) && !isscalar (z))
       [nr, nc] = size (z);
       x = 1:nc;
       y = (1:nr)';
     else
       error ("surface: Z argument must be a matrix");
     endif
-  elseif (firststring == 2)    
+  elseif (firststring == 2)
     z = varargin{1};
     c = z;
     if (ismatrix (z) && !isvector (z) && !isscalar (z))
       [nr, nc] = size (z);
       x = 1:nc;
       y = (1:nr)';
     else
       error ("surface: Z argument must be a matrix");
diff --git a/scripts/plot/surfc.m b/scripts/plot/surfc.m
--- a/scripts/plot/surfc.m
+++ b/scripts/plot/surfc.m
@@ -13,21 +13,21 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} surfc (@var{x}, @var{y}, @var{z})
-## Plot a surface and contour given matrices @var{x}, and @var{y} from 
-## @code{meshgrid} and a matrix @var{z} corresponding to the @var{x} and 
-## @var{y} coordinates of the mesh.  If @var{x} and @var{y} are vectors, 
-## then a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus, 
-## columns of @var{z} correspond to different @var{x} values and rows of 
+## Plot a surface and contour given matrices @var{x}, and @var{y} from
+## @code{meshgrid} and a matrix @var{z} corresponding to the @var{x} and
+## @var{y} coordinates of the mesh.  If @var{x} and @var{y} are vectors,
+## then a typical vertex is (@var{x}(j), @var{y}(i), @var{z}(i,j)).  Thus,
+## columns of @var{z} correspond to different @var{x} values and rows of
 ## @var{z} correspond to different @var{y} values.
 ## @seealso{meshgrid, surf, contour}
 ## @end deftypefn
 
 function h = surfc (varargin)
 
   newplot ();
 
diff --git a/scripts/plot/surfl.m b/scripts/plot/surfl.m
--- a/scripts/plot/surfl.m
+++ b/scripts/plot/surfl.m
@@ -32,27 +32,27 @@
 ##
 ## The light direction can be specified using @var{L}.  It can be
 ## given as 2-element vector [azimuth, elevation] in degrees or as 3-element
 ## vector [lx, ly, lz].
 ## The default value is rotated 45 counter-clockwise from the current view.
 ##
 ## The material properties of the surface can specified using a 4-element vector
 ## @var{P} = [@var{AM} @var{D} @var{SP} @var{exp}] which defaults to
-## @var{p} = [0.55 0.6 0.4 10]. 
+## @var{p} = [0.55 0.6 0.4 10].
 ## @table @code
 ## @item "AM" strength of ambient light
 ##
 ## @item "D" strength of diffuse reflection
 ##
 ## @item "SP" strength of specular reflection
 ##
 ## @item "EXP" specular exponent
 ## @end table
-## 
+##
 ## The default lighting mode "cdata", changes the cdata property to give the
 ## impression
 ## of a lighted surface.  Please note: the alternative "light" mode, which
 ## creates a light
 ## object to illuminate the surface is not implemented (yet).
 ##
 ## Example:
 ##
@@ -93,17 +93,17 @@ function retval = surfl (varargin)
       varargin(end) = [];
     endif
 
     ## Check for reflection properties argument.
     ##
     ## r = [ambient light strength,
     ##      diffuse reflection strength,
     ##      specular reflection strength,
-    ##      specular shine] 
+    ##      specular shine]
     if (length (varargin{end}) == 4 && isnumeric (varargin{end}))
       r = varargin{end};
       varargin(end) = [];
     else
       ## Default values.
       r = [0.55, 0.6, 0.4, 10];
     endif
 
@@ -117,17 +117,17 @@ function retval = surfl (varargin)
         varargin(end) = [];
         have_lv = true;
       elseif (len == 2)
         [lv(1), lv(2), lv(3)] = sph2cart ((lastarg(1) - 90) * pi/180, lastarg(2) * pi/180, 1.0);
         varargin(end) = [];
         have_lv = true;
       endif
     endif
-    
+
     tmp = surface (varargin{:});
     if (! ishold ())
       set (h, "view", [-37.5, 30],
            "xgrid", "on", "ygrid", "on", "zgrid", "on", "clim", [0 1]);
     endif
 
     ## Get view vector (vv).
     a = axis;
@@ -155,17 +155,17 @@ function retval = surfl (varargin)
     [nr, nc] = size(get(tmp, "zdata"));
 
     ## Ambient, diffuse, and specular term.
     cdata = (r(1) * ones (nr, nc)
              + r(2) * diffuse  (vn(:,:,1), vn(:,:,2), vn(:,:,3), lv)
              + r(3) * specular (vn(:,:,1), vn(:,:,2), vn(:,:,3), lv, vv, r(4)));
 
     set (tmp, "cdata", cdata ./ sum (r(1:3)));
-    
+
   unwind_protect_cleanup
     axes (oldh);
   end_unwind_protect
 
   if (nargout > 0)
     retval = tmp;
   endif
 
diff --git a/scripts/plot/surfnorm.m b/scripts/plot/surfnorm.m
--- a/scripts/plot/surfnorm.m
+++ b/scripts/plot/surfnorm.m
@@ -16,49 +16,49 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} surfnorm (@var{x}, @var{y}, @var{z})
 ## @deftypefnx {Function File} {} surfnorm (@var{z})
 ## @deftypefnx {Function File} {[@var{nx}, @var{ny}, @var{nz}] =} surfnorm (@dots{})
 ## @deftypefnx {Function File} {} surfnorm (@var{h}, @dots{})
-## Find the vectors normal to a meshgridded surface.  The meshed gridded 
-## surface is defined by @var{x}, @var{y}, and @var{z}.  If @var{x} and 
+## Find the vectors normal to a meshgridded surface.  The meshed gridded
+## surface is defined by @var{x}, @var{y}, and @var{z}.  If @var{x} and
 ## @var{y} are not defined, then it is assumed that they are given by
 ##
 ## @example
 ## @group
-## [@var{x}, @var{y}] = meshgrid (1:size(@var{z}, 1), 
+## [@var{x}, @var{y}] = meshgrid (1:size(@var{z}, 1),
 ##                      1:size(@var{z}, 2));
 ## @end group
 ## @end example
 ##
-## If no return arguments are requested, a surface plot with the normal 
+## If no return arguments are requested, a surface plot with the normal
 ## vectors to the surface is plotted.  Otherwise the components of the normal
 ## vectors at the mesh gridded points are returned in @var{nx}, @var{ny},
 ## and @var{nz}.
 ##
-## The normal vectors are calculated by taking the cross product of the 
-## diagonals of each of the quadrilaterals in the meshgrid to find the 
+## The normal vectors are calculated by taking the cross product of the
+## diagonals of each of the quadrilaterals in the meshgrid to find the
 ## normal vectors of the centers of these quadrilaterals.  The four nearest
-## normal vectors to the meshgrid points are then averaged to obtain the 
+## normal vectors to the meshgrid points are then averaged to obtain the
 ## normal to the surface at the meshgridded points.
 ##
 ## An example of the use of @code{surfnorm} is
 ##
 ## @example
 ## surfnorm (peaks (25));
 ## @end example
 ## @seealso{surf, quiver3}
 ## @end deftypefn
 
 function [Nx, Ny, Nz] = surfnorm (varargin)
 
-  [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout != 0), "surfnorm", 
+  [h, varargin, nargin] = __plt_get_axis_arg__ ((nargout != 0), "surfnorm",
                                                 varargin{:});
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
   if (nargin == 1)
     z = varargin{1};
@@ -71,17 +71,17 @@ function [Nx, Ny, Nz] = surfnorm (vararg
     ioff = 4;
   endif
 
   if (!ismatrix (z) || isvector (z) || isscalar (z))
     error ("surfnorm: Z argument must be a matrix");
   endif
   if (! size_equal (x, y, z))
     error ("surfnorm: X, Y, and Z must have the same dimensions");
-  endif 
+  endif
 
   ## Make life easier, and avoid having to do the extrapolation later, do
   ## a simpler linear extrapolation here. This is approximative, and works
   ## badly for closed surfaces like spheres.
   xx = [2 .* x(:,1) - x(:,2), x, 2 .* x(:,end) - x(:,end-1)];
   xx = [2 .* xx(1,:) - xx(2,:); xx; 2 .* xx(end,:) - xx(end-1,:)];
   yy = [2 .* y(:,1) - y(:,2), y, 2 .* y(:,end) - y(:,end-1)];
   yy = [2 .* yy(1,:) - yy(2,:); yy; 2 .* yy(end,:) - yy(end-1,:)];
@@ -97,21 +97,21 @@ function [Nx, Ny, Nz] = surfnorm (vararg
 
   c = cross ([u.x(:), u.y(:), u.z(:)], [v.x(:), v.y(:), v.z(:)]);
   w.x = reshape (c(:,1), size(u.x));
   w.y = reshape (c(:,2), size(u.y));
   w.z = reshape (c(:,3), size(u.z));
 
   ## Create normal vectors as mesh vectices from normals at mesh centers
   nx = (w.x(1:end-1,1:end-1) + w.x(1:end-1,2:end) +
-        w.x(2:end,1:end-1) + w.x(2:end,2:end)) ./ 4; 
+        w.x(2:end,1:end-1) + w.x(2:end,2:end)) ./ 4;
   ny = (w.y(1:end-1,1:end-1) + w.y(1:end-1,2:end) +
-        w.y(2:end,1:end-1) + w.y(2:end,2:end)) ./ 4; 
+        w.y(2:end,1:end-1) + w.y(2:end,2:end)) ./ 4;
   nz = (w.z(1:end-1,1:end-1) + w.z(1:end-1,2:end) +
-        w.z(2:end,1:end-1) + w.z(2:end,2:end)) ./ 4; 
+        w.z(2:end,1:end-1) + w.z(2:end,2:end)) ./ 4;
 
   ## Normalize the normal vectors
   len = sqrt (nx.^2 + ny.^2 + nz.^2);
   nx = nx ./ len;
   ny = ny ./ len;
   nz = nz ./ len;
 
   if (nargout == 0)
@@ -120,17 +120,17 @@ function [Nx, Ny, Nz] = surfnorm (vararg
       axes (h);
       newplot ();
       surf (x, y, z, varargin{ioff:end});
       old_hold_state = get (h, "nextplot");
       unwind_protect
         set (h, "nextplot", "add");
         plot3 ([x(:)'; x(:).' + nx(:).' ; NaN(size(x(:).'))](:),
                [y(:)'; y(:).' + ny(:).' ; NaN(size(y(:).'))](:),
-               [z(:)'; z(:).' + nz(:).' ; NaN(size(z(:).'))](:), 
+               [z(:)'; z(:).' + nz(:).' ; NaN(size(z(:).'))](:),
                varargin{ioff:end});
       unwind_protect_cleanup
         set (h, "nextplot", old_hold_state);
       end_unwind_protect
     unwind_protect_cleanup
       axes (oldh);
     end_unwind_protect
   else
diff --git a/scripts/plot/uigetdir.m b/scripts/plot/uigetdir.m
--- a/scripts/plot/uigetdir.m
+++ b/scripts/plot/uigetdir.m
@@ -31,17 +31,17 @@ function dirname = uigetdir (init_path =
 
   if (nargin > 2)
     print_usage ();
   endif
 
   if (!ischar(init_path) || !ischar(dialog_name))
     error ("uigetdir: INIT_PATH and DIALOG_NAME must be string arguments");
   endif
-  
+
   if (any (strcmp (available_graphics_toolkits (), "fltk")))
       if (!isdir (init_path))
         init_path = fileparts (init_path);
       endif
       dirname = __fltk_uigetfile__ ("", dialog_name, init_path, [240, 120], "dir");
   else
     error ("uigetdir: fltk graphics toolkit required");
   endif
diff --git a/scripts/plot/uigetfile.m b/scripts/plot/uigetfile.m
--- a/scripts/plot/uigetfile.m
+++ b/scripts/plot/uigetfile.m
@@ -46,19 +46,19 @@
 ##
 ## The filter string can also contain a semicolon separated list of filter
 ## extensions.
 ## Example: @code{uigetfile (@{"*.gif;*.png;*.jpg", "Supported Picture
 ## Formats"@})}
 ## @end table
 ##
 ## @var{dialog_name} can be used to customize the dialog title.
-## If @var{default_file} is given it is selected in the GUI dialog. 
+## If @var{default_file} is given it is selected in the GUI dialog.
 ## If in addtion a path is given it is also used as current path.
-## 
+##
 ## The screen position of the GUI dialog can be set using the "Position" key
 ## and a 2-element vector containing the pixel coordinates.
 ## Two or more files can be selected when setting the "Multiselect" key to "on".
 ## In that case @var{fname} is a cell array containing the files.
 ## @end deftypefn
 
 ## Author: Kai Habel
 
@@ -104,17 +104,17 @@ function [retfile, retpath, retindex] = 
     len = length (args);
     if (len > 0)
       file_filter = args{1};
       outargs{1} = __fltk_file_filter__ (file_filter);
       if (ischar (file_filter))
         outargs{3} = file_filter;
       endif
     endif
-    
+
     if (len > 1)
       outargs{2} = args{2};
     endif
 
     if (len > 2)
       outargs{3} = args{3};
     endif
 
@@ -153,10 +153,10 @@ function [retfile, retpath, retindex] = 
   if (any (cellfun(@(x)strcmp (x, "fltk"), available_graphics_toolkits ())))
     [retfile, retpath, retindex] = __fltk_uigetfile__ (outargs{:});
   else
     error ("uigetfile: fltk graphics toolkit required.");
   endif
 
 endfunction
 
-%!demo 
+%!demo
 %! uigetfile({"*.gif;*.png;*.jpg", "Supported Picture Formats"})
diff --git a/scripts/plot/uimenu.m b/scripts/plot/uimenu.m
--- a/scripts/plot/uimenu.m
+++ b/scripts/plot/uimenu.m
@@ -17,37 +17,37 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} uimenu (@var{property}, @var{value}, @dots{})
 ## @deftypefnx {Function File} {} uimenu (@var{h}, @var{property}, @var{value}, @dots{})
 ## Create an uimenu object and return a handle to it.  If @var{h} is ommited
 ## then a top level menu entry for the current figure is created.  If @var{h}
 ## is given then a submenu relative to @var{h} is created.
-## 
+##
 ## Uimenu objects have the following specific properties:
 ##
 ## @table @code
 ## @item "accelerator"
 ## A string containg the key combination together with CTRL to execute this
 ## menu entry (e.g., "x" for CTRL+x).
 ##
 ## @item "callback"
-## Is the function called when this menu entry is executed.  It can be either a 
+## Is the function called when this menu entry is executed.  It can be either a
 ## function string (e.g., "myfun"), a function handle (e.g., @@myfun) or a cell
 ## array containing the function handle and arguments for the callback
 ## function (e.g., @{@@myfun, arg1, arg2@}).
 ##
 ## @item "checked"
 ## Can be set "on" or "off".  Sets a mark at this menu entry.
 ##
 ## @item "enable"
 ## Can be set "on" or "off".  If disabled the menu entry cannot be selected
 ## and it is grayed out.
-## 
+##
 ## @item "foregroundcolor"
 ## A color value setting the text color for this menu entry.
 ##
 ## @item "label"
 ## A string containing the label for this menu entry.  A "&"-symbol can be
 ## used to mark the "accelerator" character (e.g., "E&xit")
 ##
 ## @item "position"
diff --git a/scripts/plot/uiputfile.m b/scripts/plot/uiputfile.m
--- a/scripts/plot/uiputfile.m
+++ b/scripts/plot/uiputfile.m
@@ -21,38 +21,38 @@
 ## @deftypefnx {Function File} {[@var{fname}, @var{fpath}, @var{fltidx}] =} uiputfile (@var{flt}, @var{dialog_name})
 ## @deftypefnx {Function File} {[@var{fname}, @var{fpath}, @var{fltidx}] =} uiputfile (@var{flt})
 ## @deftypefnx {Function File} {[@var{fname}, @var{fpath}, @var{fltidx}] =} uiputfile ())
 ## Open a GUI dialog to select a file.  @var{flt} contains a (list of) file
 ## filter string(s) in one of the following formats:
 ##
 ## @table @code
 ## @item "/path/to/filename.ext"
-## If a filename is given the file extension is 
+## If a filename is given the file extension is
 ## extracted and used as filter.
 ## In addtion the path is selected as current path and the filname is selected
 ## as default file.
 ## Example: uiputfile("myfun.m");
 ##
 ## @item "*.ext"
-## A single file extension. 
+## A single file extension.
 ## Example: uiputfile("*.ext");
 ##
 ## @item @{"*.ext","My Description"@}
 ## A 2-column cell array containing the file extension in the 1st column and
 ## a brief description in the 2nd column.
 ## Example: uiputfile(@{"*.ext","My Description";"*.xyz","XYZ-Format"@});
 ## @end table
-## 
+##
 ## The filter string can also contain a semicolon separated list of filter
 ## extensions.
 ## Example: uiputfile(@{"*.gif;*.png;*.jpg", "Supported Picture Formats"@});
 ##
 ## @var{dialog_name} can be used to customize the dialog title.
-## If @var{default_file} is given it is preselected in the GUI dialog. 
+## If @var{default_file} is given it is preselected in the GUI dialog.
 ## If in addtion a path is given it is also used as current path.
 ## @end deftypefn
 
 ## Author: Kai Habel
 
 function [retfile, retpath, retindex] = uiputfile (varargin)
 
   if (nargin <= 3)
diff --git a/scripts/plot/view.m b/scripts/plot/view.m
--- a/scripts/plot/view.m
+++ b/scripts/plot/view.m
@@ -18,21 +18,21 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{azimuth}, @var{elevation}] =} view ()
 ## @deftypefnx  {Function File} {} view (@var{azimuth}, @var{elevation})
 ## @deftypefnx {Function File} {} view ([@var{azimuth}, @var{elevation}])
 ## @deftypefnx {Function File} {} view ([@var{x}, @var{y}, @var{z}])
 ## @deftypefnx {Function File} {} view (@var{dims})
 ## @deftypefnx {Function File} {} view (@var{ax}, @dots{})
-## Query or set set the viewpoint for the current axes.  The parameters 
+## Query or set set the viewpoint for the current axes.  The parameters
 ## @var{azimuth} and @var{elevation} can be given as two arguments or as
-## 2-element vector. 
-## The viewpoint can also be given with Cartesian coordinates @var{x}, 
-## @var{y}, and @var{z}. 
+## 2-element vector.
+## The viewpoint can also be given with Cartesian coordinates @var{x},
+## @var{y}, and @var{z}.
 ## The call @code{view (2)} sets the viewpoint to @var{azimuth} = 0
 ## and @var{elevation} = 90, which is the default for 2-D graphs.
 ## The call @code{view (3)} sets the viewpoint to @var{azimuth} = -37.5
 ## and @var{elevation} = 30, which is the default for 3-D graphs.
 ## If @var{ax} is given, the viewpoint is set for this axes, otherwise
 ## it is set for the current axes.
 ## @end deftypefn
 
diff --git a/scripts/plot/waitforbuttonpress.m b/scripts/plot/waitforbuttonpress.m
--- a/scripts/plot/waitforbuttonpress.m
+++ b/scripts/plot/waitforbuttonpress.m
@@ -32,16 +32,16 @@ function a = waitforbuttonpress ()
 
   if (nargin != 0 || nargout > 1)
     print_usage ();
   endif
 
   [x, y, k] = ginput (1);
 
   if (nargout == 1)
-    if (k <= 5) 
+    if (k <= 5)
       a = 0;
-    else 
+    else
       a = 1;
     endif
   endif
 
 endfunction
diff --git a/scripts/plot/whitebg.m b/scripts/plot/whitebg.m
--- a/scripts/plot/whitebg.m
+++ b/scripts/plot/whitebg.m
@@ -22,17 +22,17 @@
 ## @deftypefnx {Function File} {} whitebg (@var{fig})
 ## @deftypefnx {Function File} {} whitebg (@var{fig}, @var{color})
 ## Invert the colors in the current color scheme.  The root properties are
 ## also inverted such that all subsequent plot use the new color scheme.
 ##
 ## If defined, @var{fig} is the handle to the figure to be inverted.  In
 ## this case only this figure has its color properties changed
 ##
-## The background colors of the figure and its children can be set 
+## The background colors of the figure and its children can be set
 ## specifically if @var{color} is defined.  @var{color} must be a valid
 ## color set as a string or an RGB triplet, or the value "none".
 ##
 ## @seealso{reset, colordef}
 ## @end deftypefn
 
 function whitebg (varargin)
   h = 0;
@@ -89,17 +89,17 @@ function whitebg (varargin)
 
     ## Load all objects which qualify for being searched.
     handles = fig;
     h = fig;
     while (numel (handles))
       children = [];
       for n = 1 : numel (handles)
         children = union (children, get(handles(n), "children"));
-      endfor 
+      endfor
       handles = children;
       h = union (h, children);
     endwhile
 
     for nh = 1 : numel(h)
       p = get (h (nh));
       fields = fieldnames (p);
       fieldindex = find (!cellfun (@isempty, regexp(fields, '.*color.*')));
@@ -129,15 +129,15 @@ function whitebg (varargin)
       endif
     endfor
   else
     ## FIXME
     ## Is this the right thing to do in this case?
     set (findall (fig, "type", "axes"), "color", color);
     if (isroot)
       defs = get (0, "defaults");
-      if (isfield (defs, "defaultaxescolor") 
+      if (isfield (defs, "defaultaxescolor")
           && strcmp (defs.defaultaxescolor, "none"))
         set (0, "defaultaxescolor", color);
       endif
     endif
   endif
 endfunction
diff --git a/scripts/plot/xlim.m b/scripts/plot/xlim.m
--- a/scripts/plot/xlim.m
+++ b/scripts/plot/xlim.m
@@ -23,18 +23,18 @@
 ## @deftypefnx {Function File} {} xlim (@var{m})
 ## @deftypefnx {Function File} {} xlim (@var{h}, @dots{})
 ## Get or set the limits of the x-axis of the current plot.  Called without
 ## arguments @code{xlim} returns the x-axis limits of the current plot.
 ## If passed a two element vector @var{xl}, the limits of the x-axis are set
 ## to this value.
 ##
 ## The current mode for calculation of the x-axis can be returned with a
-## call @code{xlim ('mode')}, and can be either 'auto' or 'manual'.  The 
-## current plotting mode can be set by passing either 'auto' or 'manual' 
+## call @code{xlim ('mode')}, and can be either 'auto' or 'manual'.  The
+## current plotting mode can be set by passing either 'auto' or 'manual'
 ## as the argument.
 ##
 ## If passed a handle as the first argument, then operate on this handle
 ## rather than the current axes handle.
 ## @seealso{ylim, zlim, set, get, gca}
 ## @end deftypefn
 
 function retval = xlim (varargin)
diff --git a/scripts/plot/ylim.m b/scripts/plot/ylim.m
--- a/scripts/plot/ylim.m
+++ b/scripts/plot/ylim.m
@@ -23,18 +23,18 @@
 ## @deftypefnx {Function File} {} ylim (@var{m})
 ## @deftypefnx {Function File} {} ylim (@var{h}, @dots{})
 ## Get or set the limits of the y-axis of the current plot.  Called without
 ## arguments @code{ylim} returns the y-axis limits of the current plot.
 ## If passed a two element vector @var{yl}, the limits of the y-axis are set
 ## to this value.
 ##
 ## The current mode for calculation of the y-axis can be returned with a
-## call @code{ylim ('mode')}, and can be either 'auto' or 'manual'.  The 
-## current plotting mode can be set by passing either 'auto' or 'manual' 
+## call @code{ylim ('mode')}, and can be either 'auto' or 'manual'.  The
+## current plotting mode can be set by passing either 'auto' or 'manual'
 ## as the argument.
 ##
 ## If passed a handle as the first argument, then operate on this handle
 ## rather than the current axes handle.
 ## @seealso{xlim, zlim, set, get, gca}
 ## @end deftypefn
 
 function retval = ylim (varargin)
diff --git a/scripts/plot/zlim.m b/scripts/plot/zlim.m
--- a/scripts/plot/zlim.m
+++ b/scripts/plot/zlim.m
@@ -23,18 +23,18 @@
 ## @deftypefnx {Function File} {} zlim (@var{m})
 ## @deftypefnx {Function File} {} zlim (@var{h}, @dots{})
 ## Get or set the limits of the z-axis of the current plot.  Called without
 ## arguments @code{zlim} returns the z-axis limits of the current plot.
 ## If passed a two element vector @var{zl}, the limits of the z-axis are set
 ## to this value.
 ##
 ## The current mode for calculation of the z-axis can be returned with a
-## call @code{zlim ('mode')}, and can be either 'auto' or 'manual'.  The 
-## current plotting mode can be set by passing either 'auto' or 'manual' 
+## call @code{zlim ('mode')}, and can be either 'auto' or 'manual'.  The
+## current plotting mode can be set by passing either 'auto' or 'manual'
 ## as the argument.
 ##
 ## If passed a handle as the first argument, then operate on this handle
 ## rather than the current axes handle.
 ## @seealso{xlim, ylim, set, get, gca}
 ## @end deftypefn
 
 function retval = zlim (varargin)
diff --git a/scripts/polynomial/mkpp.m b/scripts/polynomial/mkpp.m
--- a/scripts/polynomial/mkpp.m
+++ b/scripts/polynomial/mkpp.m
@@ -14,23 +14,23 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{pp} =} mkpp (@var{x}, @var{p})
 ## @deftypefnx {Function File} {@var{pp} =} mkpp (@var{x}, @var{p}, @var{d})
-## 
+##
 ## Construct a piecewise polynomial structure from sample points
 ## @var{x} and coefficients @var{p}.  The i-th row of @var{p},
 ## @code{@var{p} (@var{i},:)}, contains the coefficients for the polynomial
-## over the @var{i}-th interval, ordered from highest to 
-## lowest.  There must be one row for each interval in @var{x}, so 
-## @code{rows (@var{p}) == length (@var{x}) - 1}.  
+## over the @var{i}-th interval, ordered from highest to
+## lowest.  There must be one row for each interval in @var{x}, so
+## @code{rows (@var{p}) == length (@var{x}) - 1}.
 ##
 ## @var{p} may also be a multi-dimensional array, specifying a vector-valued
 ## or array-valued polynomial.  The shape is determined by @var{d}.  If @var{d}
 ## is
 ## not given, the default is @code{size (p)(1:end-2)}.  If @var{d} is given, the
 ## leading dimensions of @var{p} are reshaped to conform to @var{d}.
 ##
 ## @seealso{unmkpp, ppval, spline}
@@ -59,16 +59,16 @@ function pp = mkpp (x, P, d)
   pp.orient = 0;
 
   if (size (P, 2) != n)
     error ("mkpp: num intervals in X doesn't match num polynomials in P");
   endif
 endfunction
 
 %!demo # linear interpolation
-%! x=linspace(0,pi,5)'; 
+%! x=linspace(0,pi,5)';
 %! t=[sin(x),cos(x)];
-%! m=diff(t)./(x(2)-x(1)); 
+%! m=diff(t)./(x(2)-x(1));
 %! b=t(1:4,:);
 %! pp = mkpp(x, [m(:),b(:)]);
 %! xi=linspace(0,pi,50);
 %! plot(x,t,"x",xi,ppval(pp,xi));
 %! legend("control","interp");
diff --git a/scripts/polynomial/mpoles.m b/scripts/polynomial/mpoles.m
--- a/scripts/polynomial/mpoles.m
+++ b/scripts/polynomial/mpoles.m
@@ -17,17 +17,17 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{multp}, @var{indx}] =} mpoles (@var{p})
 ## @deftypefnx {Function File} {[@var{multp}, @var{indx}] =} mpoles (@var{p}, @var{tol})
 ## @deftypefnx {Function File} {[@var{multp}, @var{indx}] =} mpoles (@var{p}, @var{tol}, @var{reorder})
 ## Identify unique poles in @var{p} and associates their multiplicity,
 ## ordering them from largest to smallest.
-## 
+##
 ## If the relative difference of the poles is less than @var{tol}, then
 ## they are considered to be multiples.  The default value for @var{tol}
 ## is 0.001.
 ##
 ## If the optional parameter @var{reorder} is zero, poles are not sorted.
 ##
 ## The value @var{multp} is a vector specifying the multiplicity of the
 ## poles.  @var{multp}(:) refers to multiplicity of @var{p}(@var{indx}(:)).
diff --git a/scripts/polynomial/pchip.m b/scripts/polynomial/pchip.m
--- a/scripts/polynomial/pchip.m
+++ b/scripts/polynomial/pchip.m
@@ -32,28 +32,28 @@
 ## have the form
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n]$$
 ## @end tex
 ## @ifnottex
 ## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n}]}
 ## @end ifnottex
 ## The array is then reshaped internally to a matrix where the leading
-## dimension is given by 
+## dimension is given by
 ## @tex
 ## $$s_1 s_2 \cdots s_k$$
 ## @end tex
 ## @ifnottex
 ## @code{@var{s1} * @var{s2} * @dots{} * @var{sk}}
 ## @end ifnottex
 ## and each row in this matrix is then treated separately.  Note that this
 ## is exactly the opposite treatment than @code{interp1} and is done
 ## for compatibility.
 ##
-## Called with a third input argument, @code{pchip} evaluates the 
+## Called with a third input argument, @code{pchip} evaluates the
 ## piecewise polynomial at the points @var{xi}.  There is an equivalence
 ## between @code{ppval (pchip (@var{x}, @var{y}), @var{xi})} and
 ## @code{pchip (@var{x}, @var{y}, @var{xi})}.
 ##
 ## @seealso{spline, ppval, mkpp, unmkpp}
 ## @end deftypefn
 
 ## Author:  Kai Habel <kai.habel@gmx.de>
@@ -100,17 +100,17 @@ function ret = pchip (x, y, xi)
 
   f1 = y(:,1:n-1);
 
   ## Compute derivatives.
   d = __pchip_deriv__ (x, y, 2);
   d1 = d(:,1:n-1);
   d2 = d(:,2:n);
 
-  ## This is taken from SLATEC. 
+  ## This is taken from SLATEC.
   h = diag (h);
 
   delta = diff (y, 1, 2) / h;
   del1 = (d1 - delta) / h;
   del2 = (d2 - delta) / h;
   c3 = del1 + del2;
   c2 = -c3 - del1;
   c3 = c3 / h;
@@ -122,29 +122,29 @@ function ret = pchip (x, y, xi)
     ret = pp;
   else
     ret = ppval (pp, xi);
   endif
 
 endfunction
 
 %!demo
-%! x = 0:8; 
+%! x = 0:8;
 %! y = [1, 1, 1, 1, 0.5, 0, 0, 0, 0];
-%! xi = 0:0.01:8; 
+%! xi = 0:0.01:8;
 %! yspline = spline(x,y,xi);
 %! ypchip = pchip(x,y,xi);
 %! title("pchip and spline fit to discontinuous function");
 %! plot(xi,yspline,xi,ypchip,"-",x,y,"+");
 %! legend ("spline","pchip","data");
 %! %-------------------------------------------------------------------
 %! % confirm that pchip agreed better to discontinuous data than spline
 
 %!shared x,y
-%! x = 0:8; 
+%! x = 0:8;
 %! y = [1, 1, 1, 1, 0.5, 0, 0, 0, 0];
 %!assert (pchip(x,y,x), y);
 %!assert (pchip(x,y,x'), y');
 %!assert (pchip(x',y',x'), y');
 %!assert (pchip(x',y',x), y);
 %!assert (isempty(pchip(x',y',[])));
 %!assert (isempty(pchip(x,y,[])));
 %!assert (pchip(x,[y;y],x), [pchip(x,y,x);pchip(x,y,x)])
diff --git a/scripts/polynomial/poly.m b/scripts/polynomial/poly.m
--- a/scripts/polynomial/poly.m
+++ b/scripts/polynomial/poly.m
@@ -16,36 +16,36 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} poly (@var{A})
 ## @deftypefnx {Function File} {} poly (@var{x})
 ## If @var{A} is a square @math{N}-by-@math{N} matrix, @code{poly (@var{A})}
 ## is the row vector of the coefficients of @code{det (z * eye (N) - A)},
-## the characteristic polynomial of @var{A}.  For example, 
-## the following code finds the eigenvalues of @var{A} which are the roots of 
+## the characteristic polynomial of @var{A}.  For example,
+## the following code finds the eigenvalues of @var{A} which are the roots of
 ## @code{poly (@var{A})}.
 ##
 ## @example
 ## @group
 ## roots(poly(eye(3)))
 ## @result{} 1.00001 + 0.00001i
 ## @result{} 1.00001 - 0.00001i
 ## @result{} 0.99999 + 0.00000i
 ## @end group
 ## @end example
 ##
-## In fact, all three eigenvalues are exactly 1 which emphasizes that for 
+## In fact, all three eigenvalues are exactly 1 which emphasizes that for
 ## numerical performance the @code{eig} function should be used to compute
 ## eigenvalues.
 ##
 ## If @var{x} is a vector, @code{poly (@var{x})} is a vector of the coefficients
 ## of the polynomial whose roots are the elements of @var{x}.  That is,
-## if @var{c} is a polynomial, then the elements of 
+## if @var{c} is a polynomial, then the elements of
 ## @code{@var{d} = roots (poly (@var{c}))} are contained in @var{c}.
 ## The vectors @var{c} and @var{d} are not identical, however, due to sorting
 ## and numerical errors.
 ## @seealso{eig, roots}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 24 December 1993
diff --git a/scripts/polynomial/polyaffine.m b/scripts/polynomial/polyaffine.m
--- a/scripts/polynomial/polyaffine.m
+++ b/scripts/polynomial/polyaffine.m
@@ -21,17 +21,17 @@
 ## Return the coefficients of the polynomial vector @var{f} after an affine
 ## transformation.  If @var{f} is the vector representing the polynomial f(x),
 ## then @code{@var{g} = polyaffine (@var{f}, @var{mu})} is the vector
 ## representing:
 ##
 ## @example
 ## g(x) = f((x-@var{mu}(1))/@var{mu}(2)).
 ## @end example
-## 
+##
 ## @seealso{polyval}
 ## @end deftypefn
 
 
 function g = polyaffine (f, mu)
 
    if (nargin != 2)
       print_usage ();
diff --git a/scripts/polynomial/polyderiv.m b/scripts/polynomial/polyderiv.m
--- a/scripts/polynomial/polyderiv.m
+++ b/scripts/polynomial/polyderiv.m
@@ -18,18 +18,18 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} polyderiv (@var{p})
 ## @deftypefnx {Function File} {[@var{k}] =} polyderiv (@var{a}, @var{b})
 ## @deftypefnx {Function File} {[@var{q}, @var{d}] =} polyderiv (@var{b}, @var{a})
 ## Return the coefficients of the derivative of the polynomial whose
 ## coefficients are given by the vector @var{p}.  If a pair of polynomials
 ## is given, return the derivative of the product @math{@var{a}*@var{b}}.
-## If two inputs and two outputs are given, return the derivative of the 
-## polynomial quotient @math{@var{b}/@var{a}}.  The quotient numerator is 
+## If two inputs and two outputs are given, return the derivative of the
+## polynomial quotient @math{@var{b}/@var{a}}.  The quotient numerator is
 ## in @var{q} and the denominator in @var{d}.
 ## @seealso{poly, polyint, polyreduce, roots, conv, deconv, residue,
 ## filter, polygcd, polyval, polyvalm}
 ## @end deftypefn
 
 ## Author: Tony Richardson <arichard@stark.cc.oh.us>
 ## Created: June 1994
 ## Adapted-By: jwe
@@ -39,17 +39,17 @@ function [q, d] = polyderiv (p, a)
   if (nargin == 1 || nargin == 2)
     if (! isvector (p))
       error ("polyderiv: argument must be a vector");
     endif
     if (nargin == 2)
       if (! isvector (a))
         error ("polyderiv: argument must be a vector");
       endif
-      if (nargout == 1) 
+      if (nargout == 1)
         ## derivative of p*a returns a single polynomial
         q = polyderiv (conv (p, a));
       else
         ## derivative of p/a returns numerator and denominator
         d = conv (a, a);
         if (numel (p) == 1)
           q = -p * polyderiv (a);
         elseif (numel (a) == 1)
diff --git a/scripts/polynomial/polyfit.m b/scripts/polynomial/polyfit.m
--- a/scripts/polynomial/polyfit.m
+++ b/scripts/polynomial/polyfit.m
@@ -39,20 +39,20 @@
 ##
 ## @item normr
 ## The norm of the residuals.
 ##
 ## @item yf
 ## The values of the polynomial for each value of @var{x}.
 ## @end table
 ##
-## The second output may be used by @code{polyval} to calculate the 
+## The second output may be used by @code{polyval} to calculate the
 ## statistical error limits of the predicted values.
 ##
-## When the third output, @var{mu}, is present the 
+## When the third output, @var{mu}, is present the
 ## coefficients, @var{p}, are associated with a polynomial in
 ## @var{xhat} = (@var{x}-@var{mu}(1))/@var{mu}(2).
 ## Where @var{mu}(1) = mean (@var{x}), and @var{mu}(2) = std (@var{x}).
 ## This linear transformation of @var{x} improves the numerical
 ## stability of the fit.
 ## @seealso{polyval, residue}
 ## @end deftypefn
 
diff --git a/scripts/polynomial/polyreduce.m b/scripts/polynomial/polyreduce.m
--- a/scripts/polynomial/polyreduce.m
+++ b/scripts/polynomial/polyreduce.m
@@ -38,19 +38,19 @@ function p = polyreduce (c)
     error ("polyreduce: C must be a non-empty vector");
   endif
 
   if (! isempty (c))
 
     index = find (c != 0);
 
     if (isempty (index))
-      
+
       p = 0;
-    
+
     else
 
       p = c(index (1):length (c));
 
     endif
 
   endif
 
diff --git a/scripts/polynomial/polyval.m b/scripts/polynomial/polyval.m
--- a/scripts/polynomial/polyval.m
+++ b/scripts/polynomial/polyval.m
@@ -14,24 +14,24 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{y} =} polyval (@var{p}, @var{x})
 ## @deftypefnx {Function File} {@var{y} =} polyval (@var{p}, @var{x}, [], @var{mu})
-## Evaluate the polynomial @var{p} at the specified values of @var{x}.  When 
-## @var{mu} is present evaluate the polynomial for 
+## Evaluate the polynomial @var{p} at the specified values of @var{x}.  When
+## @var{mu} is present evaluate the polynomial for
 ## (@var{x}-@var{mu}(1))/@var{mu}(2).
 ## If @var{x} is a vector or matrix, the polynomial is evaluated for each of
 ## the elements of @var{x}.
 ## @deftypefnx {Function File} {[@var{y}, @var{dy}] =} polyval (@var{p}, @var{x}, @var{s})
 ## @deftypefnx {Function File} {[@var{y}, @var{dy}] =} polyval (@var{p}, @var{x}, @var{s}, @var{mu})
-## In addition to evaluating the polynomial, the second output 
+## In addition to evaluating the polynomial, the second output
 ## represents the prediction interval, @var{y} +/- @var{dy}, which
 ## contains at least 50% of the future predictions.  To calculate the
 ## prediction interval, the structured variable @var{s}, originating
 ## form `polyfit', must be present.
 ## @seealso{polyfit, polyvalm, poly, roots, conv, deconv, residue, filter,
 ## polyderiv, polyint}
 ## @end deftypefn
 
diff --git a/scripts/polynomial/ppder.m b/scripts/polynomial/ppder.m
--- a/scripts/polynomial/ppder.m
+++ b/scripts/polynomial/ppder.m
@@ -1,22 +1,22 @@
 ## Copyright (C) 2008-2011 VZLU Prague, a.s., Czech Republic
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or
 ## (at your option) any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this software; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{ppd} =} ppder (@var{pp})
 ## Compute the piecewise derivative of the piecewise polynomial struct @var{pp}.
 ## @seealso{mkpp,ppval,ppint}
diff --git a/scripts/polynomial/ppint.m b/scripts/polynomial/ppint.m
--- a/scripts/polynomial/ppint.m
+++ b/scripts/polynomial/ppint.m
@@ -1,22 +1,22 @@
 ## Copyright (C) 2008-2011 VZLU Prague, a.s., Czech Republic
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or
 ## (at your option) any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this software; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{ppi} =} ppint (@var{pp})
 ## @deftypefnx {Function File} {@var{ppi} =} ppint (@var{pp}, @var{c})
 ## Compute the integral of the piecewise polynomial struct @var{pp}.
@@ -29,17 +29,17 @@ function ppi = ppint (pp, c)
     print_usage ();
   endif
   if (! isstruct (pp))
     error ("ppint: PP must be a structure");
   endif
 
   [x, p, n, k, d] = unmkpp (pp);
   p = reshape (p, [], k);
-  
+
   ## Get piecewise antiderivatives
   pi = p / diag (k:-1:1);
   k += 1;
   if (nargin == 1)
     pi(:,k) = 0;
   else
     pi(:,k) = repmat (c(:), n, 1);
   endif
diff --git a/scripts/polynomial/ppjumps.m b/scripts/polynomial/ppjumps.m
--- a/scripts/polynomial/ppjumps.m
+++ b/scripts/polynomial/ppjumps.m
@@ -1,22 +1,22 @@
 ## Copyright (C) 2008-2011 VZLU Prague, a.s., Czech Republic
-## 
+##
 ## This file is part of Octave.
-## 
+##
 ## Octave is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or
 ## (at your option) any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with this software; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{jumps} =} ppjumps (@var{pp})
 ## Evaluate the boundary jumps of a piecewise polynomial.
 ## If there are @math{n} intervals, and the dimensionality of @var{pp} is
diff --git a/scripts/polynomial/ppval.m b/scripts/polynomial/ppval.m
--- a/scripts/polynomial/ppval.m
+++ b/scripts/polynomial/ppval.m
@@ -13,27 +13,27 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{yi} =} ppval (@var{pp}, @var{xi})
-## Evaluate piecewise polynomial @var{pp} at the points @var{xi}.  
+## Evaluate piecewise polynomial @var{pp} at the points @var{xi}.
 ## If @var{pp} is scalar-valued, the result is an array of the same shape as
 ## @var{xi}.
 ## Otherwise, the size of the result is @code{[pp.d, length(@var{xi})]} if
 ## @var{xi} is a vector, or @code{[pp.d, size(@var{xi})]} if it is a
 ## multi-dimensional array.  If pp.orient is 1, the dimensions are permuted as
 ## in interp1, to
 ## @code{[pp.d, length(@var{xi})]} and @code{[pp.d, size(@var{xi})]}
 ## respectively.
 ## @seealso{mkpp, unmkpp, spline}
-## @end deftypefn 
+## @end deftypefn
 
 function yi = ppval (pp, xi)
 
   if (nargin != 2)
     print_usage ();
   endif
   if (! isstruct (pp))
     error ("ppval: PP must be a structure");
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -191,17 +191,17 @@ function [r, p, k, e] = residue (b, a, v
   lp = length (p);
 
   ## Sort poles so that multiplicity loop will work.
 
   [e, indx] = mpoles (p, toler, 1);
   p = p (indx);
 
   ## For each group of pole multiplicity, set the value of each
-  ## pole to the average of the group. This reduces the error in 
+  ## pole to the average of the group. This reduces the error in
   ## the resulting poles.
 
   p_group = cumsum (e == 1);
   for ng = 1:p_group(end)
     m = find (p_group == ng);
     p(m) = mean (p(m));
   endfor
 
@@ -279,17 +279,17 @@ function [pnum, pden, e] = rresidue (r, 
 
   if (nargin < 4)
     toler = [];
   endif
 
   if (nargin < 3)
     k = [];
   endif
- 
+
   if numel (e)
     indx = 1:numel(p);
   else
     [e, indx] = mpoles (p, toler, 0);
     p = p (indx);
     r = r (indx);
   endif
 
diff --git a/scripts/polynomial/roots.m b/scripts/polynomial/roots.m
--- a/scripts/polynomial/roots.m
+++ b/scripts/polynomial/roots.m
@@ -123,19 +123,19 @@ endfunction
 %! r = sort (roots (p));
 %! assert (r, [0; 0; 0; 0; 3; 3; 3; 3], 0.001)
 
 %!assert(all (all (abs (roots ([1, -6, 11, -6]) - [3; 2; 1]) < sqrt (eps))));
 
 %!assert(isempty (roots ([])));
 
 %!error roots ([1, 2; 3, 4]);
- 
+
 %!assert(isempty (roots (1)));
 
 %!error roots ([1, 2; 3, 4]);
- 
+
 %!error roots ([1 Inf 1]);
 
 %!error roots ([1 NaN 1]);
 
 %!assert(roots ([1e-200, -1e200, 1]), 1e-200)
 %!assert(roots ([1e-200, -1e200 * 1i, 1]), -1e-200 * 1i)
diff --git a/scripts/polynomial/spline.m b/scripts/polynomial/spline.m
--- a/scripts/polynomial/spline.m
+++ b/scripts/polynomial/spline.m
@@ -16,21 +16,21 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{pp} =} spline (@var{x}, @var{y})
 ## @deftypefnx {Function File} {@var{yi} =} spline (@var{x}, @var{y}, @var{xi})
 ##
-## Return the cubic spline interpolant of @var{y} at points @var{x}. 
+## Return the cubic spline interpolant of @var{y} at points @var{x}.
 ## If called with two arguments, @code{spline} returns the piecewise
 ## polynomial @var{pp} that may later be used with @code{ppval} to
 ## evaluate the polynomial at specific points.
-## If called with a third input argument, @code{spline} evaluates the 
+## If called with a third input argument, @code{spline} evaluates the
 ## spline at the points @var{xi}.  There is an equivalence
 ## between @code{ppval (spline (@var{x}, @var{y}), @var{xi})} and
 ## @code{spline (@var{x}, @var{y}, @var{xi})}.
 ##
 ## The variable @var{x} must be a vector of length @var{n}, and @var{y}
 ## can be either a vector or array.  In the case where @var{y} is a
 ## vector, it can have a length of either @var{n} or @code{@var{n} + 2}.
 ## If the length of @var{y} is @var{n}, then the 'not-a-knot' end
@@ -48,17 +48,17 @@
 ## or
 ## @tex
 ## $$[s_1, s_2, \cdots, s_k, n + 2].$$
 ## @end tex
 ## @ifnottex
 ## @code{[@var{s1}, @var{s2}, @dots{}, @var{sk}, @var{n} + 2]}.
 ## @end ifnottex
 ## The array is then reshaped internally to a matrix where the leading
-## dimension is given by 
+## dimension is given by
 ## @tex
 ## $$s_1 s_2 \cdots s_k$$
 ## @end tex
 ## @ifnottex
 ## @code{@var{s1} * @var{s2} * @dots{} * @var{sk}}
 ## @end ifnottex
 ## and each row of this matrix is then treated separately.  Note that this
 ## is exactly the opposite treatment than @code{interp1} and is done
@@ -72,38 +72,38 @@
 ## for the treatment of vectors y 2 elements longer than x as complete
 ## splines.
 
 function ret = spline (x, y, xi)
 
   x = x(:);
   n = length (x);
   if (n < 3)
-    error ("spline: requires at least 3 points"); 
+    error ("spline: requires at least 3 points");
   endif
 
   ## Check the size and shape of y
   ndy = ndims (y);
   szy = size (y);
   if (ndy == 2 && (szy(1) == 1 || szy(2) == 1))
     if (szy(1) == 1)
       a = y.';
     else
       a = y;
       szy = fliplr (szy);
     endif
   else
     a = reshape (y, [prod(szy(1:end-1)), szy(end)]).';
   endif
-  
-  for k = (1:columns (a))(any (isnan (a))) 
-    ok = ! isnan (a(:,k)); 
-    a(!ok,k) = spline (x(ok), a(ok,k), x(!ok)); 
-  endfor 
-  
+
+  for k = (1:columns (a))(any (isnan (a)))
+    ok = ! isnan (a(:,k));
+    a(!ok,k) = spline (x(ok), a(ok,k), x(!ok));
+  endfor
+
   complete = false;
   if (size (a, 1) == n + 2)
     complete = true;
     dfs = a(1,:);
     dfe = a(end,:);
     a = a(2:end-1,:);
   endif
 
diff --git a/scripts/polynomial/unmkpp.m b/scripts/polynomial/unmkpp.m
--- a/scripts/polynomial/unmkpp.m
+++ b/scripts/polynomial/unmkpp.m
@@ -25,17 +25,17 @@
 ## @table @asis
 ## @item @var{x}
 ## Sample points.
 ##
 ## @item @var{p}
 ## Polynomial coefficients for points in sample interval.  @code{@var{p}
 ## (@var{i}, :)} contains the coefficients for the polynomial over
 ## interval @var{i} ordered from highest to lowest.  If @code{@var{d} >
-## 1}, @code{@var{p} (@var{r}, @var{i}, :)} contains the coefficients for 
+## 1}, @code{@var{p} (@var{r}, @var{i}, :)} contains the coefficients for
 ## the r-th polynomial defined on interval @var{i}.
 ##
 ## @item @var{n}
 ## Number of polynomial pieces.
 ##
 ## @item @var{k}
 ## Order of the polynomial plus 1.
 ##
diff --git a/scripts/set/ismember.m b/scripts/set/ismember.m
--- a/scripts/set/ismember.m
+++ b/scripts/set/ismember.m
@@ -13,23 +13,23 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn  {Function File} {@var{tf} =} ismember (@var{A}, @var{s}) 
-## @deftypefnx {Function File} {[@var{tf}, @var{S_idx}] =} ismember (@var{A}, @var{s}) 
+## @deftypefn  {Function File} {@var{tf} =} ismember (@var{A}, @var{s})
+## @deftypefnx {Function File} {[@var{tf}, @var{S_idx}] =} ismember (@var{A}, @var{s})
 ## @deftypefnx {Function File} {[@var{tf}, @var{S_idx}] =} ismember (@var{A}, @var{s}, "rows")
-## Return a logical matrix @var{tf} with the same shape as @var{A} which is 
+## Return a logical matrix @var{tf} with the same shape as @var{A} which is
 ## true (1) if @code{A(i,j)} is in @var{s} and false (0) if it is not.  If a
 ## second output argument is requested, the index into @var{s} of each of the
-## matching elements is also returned. 
+## matching elements is also returned.
 ##
 ## @example
 ## @group
 ## a = [3, 10, 1];
 ## s = [0:9];
 ## [tf, s_idx] = ismember (a, s);
 ##      @result{} tf = [1, 0, 1]
 ##      @result{} s_idx = [4, 0, 2]
@@ -43,17 +43,17 @@
 ## a = @{'abc'@};
 ## s = @{'abc', 'def'@};
 ## [tf, s_idx] = ismember (a, s);
 ##      @result{} tf = [1, 0]
 ##      @result{} s_idx = [1, 0]
 ## @end group
 ## @end example
 ##
-## With the optional third argument @code{"rows"}, and matrices 
+## With the optional third argument @code{"rows"}, and matrices
 ## @var{A} and @var{s} with the same number of columns, compare rows in
 ## @var{A} with the rows in @var{s}.
 ##
 ## @example
 ## @group
 ## a = [1:3; 5:7; 4:6];
 ## s = [0:2; 1:3; 2:4; 3:5; 4:6];
 ## [tf, s_idx] = ismember(a, s, 'rows');
@@ -66,17 +66,17 @@
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 ## Author: Sren Hauberg <hauberg@gmail.com>
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Adapted-by: jwe
 ## Reimplemented using lookup & unique: Jaroslav Hajek <highegg@gmail.com>
 
-function [tf, a_idx] = ismember (A, s, varargin) 
+function [tf, a_idx] = ismember (A, s, varargin)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   [A, s] = validargs ("ismember", A, s, varargin{:});
 
   if (nargin == 2)
@@ -87,17 +87,17 @@ function [tf, a_idx] = ismember (A, s, v
     else
       [s, is] = sort (s);
     endif
 
     ## sort out NaNs in table
     if (isreal (s) && ! isempty (s) && isnan (s(end)))
         s = s(1:end - sum (isnan (s)));
     endif
-    
+
     if (nargout > 1)
       a_idx = lookup (s, A, "m");
       tf = logical (a_idx);
       if (! isempty (is))
         a_idx(tf) = is (a_idx(tf));
       endif
     else
       tf = lookup (s, A, "b");
diff --git a/scripts/set/private/validargs.m b/scripts/set/private/validargs.m
--- a/scripts/set/private/validargs.m
+++ b/scripts/set/private/validargs.m
@@ -27,24 +27,24 @@ function [x, y] = validargs (caller, x, 
       if (icx && ischar (y))
         y = cellstr (y);
       elseif (icy && ischar (x))
         x = cellstr (x);
       elseif (! (icx && icy))
         error ("%s: cell array of strings cannot be combined with a nonstring value", caller);
       endif
     elseif (! (ismatrix (x) && ismatrix (y)))
-      error ("%s: input arguments must be arrays or cell arrays of strings", caller); 
+      error ("%s: input arguments must be arrays or cell arrays of strings", caller);
     endif
   elseif (nargin == 4)
     if (strcmpi (byrows_arg, "rows"))
       if (iscell (x) || iscell (y))
         error ("%s: cells not supported with ""rows""");
       elseif (! (ismatrix (x) && ismatrix (y)))
-        error ("%s: input arguments must be arrays or cell arrays of strings", caller); 
+        error ("%s: input arguments must be arrays or cell arrays of strings", caller);
       else
         if (ndims (x) > 2 || ndims (y) > 2)
           error ("%s: need 2-dimensional matrices for ""rows""", caller);
         elseif (columns (x) != columns (y) && ! (isempty (x) || isempty (y)))
           error ("%s: number of columns must match", caller);
         endif
       endif
     else
diff --git a/scripts/set/setdiff.m b/scripts/set/setdiff.m
--- a/scripts/set/setdiff.m
+++ b/scripts/set/setdiff.m
@@ -82,19 +82,19 @@ function [c, i] = setdiff (a, b, varargi
         i(idx(dups)) = [];
       endif
       ## Reshape if necessary.
       if (size (c, 1) != 1 && size (b, 1) == 1)
         c = c.';
       endif
     endif
   endif
-  
+
 endfunction
-  
+
 %!assert(setdiff(["bb";"zz";"bb";"zz"],["bb";"cc";"bb"],"rows"), "zz")
 %!assert(setdiff(["b";"z";"b";"z"],["b";"c";"b"],"rows"), "z")
 %!assert(setdiff(["b";"z";"b";"z"],["b";"c";"b"]), "z")
 %!assert(setdiff([1, 1; 2, 2; 3, 3; 4, 4], [1, 1; 2, 2; 4, 4], "rows"), [3 3])
 %!assert(setdiff([1; 2; 3; 4], [1; 2; 4], "rows"), 3)
 %!assert(setdiff([1, 2; 3, 4], [1, 2; 3, 6], "rows"), [3, 4])
 %!assert(setdiff({"one","two";"three","four"},{"one","two";"three","six"}), {"four"})
 
diff --git a/scripts/set/setxor.m b/scripts/set/setxor.m
--- a/scripts/set/setxor.m
+++ b/scripts/set/setxor.m
@@ -26,17 +26,17 @@
 ## vector, otherwise return a row vector.
 ## @var{a}, @var{b} may be cell arrays of string(s).
 ##
 ## @deftypefnx {Function File} {[@var{c}, @var{ia}, @var{ib}] =} setxor (@var{a}, @var{b})
 ##
 ## Return index vectors @var{ia} and @var{ib} such that @code{a(ia)} and
 ## @code{b(ib)} are
 ## disjoint sets whose union is @var{c}.
-## 
+##
 ## @seealso{unique, union, intersect, setdiff, ismember}
 ## @end deftypefn
 
 function [c, ia, ib] = setxor (a, b, varargin)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
@@ -67,17 +67,17 @@ function [c, ia, ib] = setxor (a, b, var
         c([idx, idx+1],:) = [];
         i([idx, idx+1],:) = [];
       endif
     else
       na = numel (a); nb = numel (b);
       [c, i] = sort ([a(:); b(:)]);
       n = length (c);
       if (iscell (c))
-        idx = find (strcmp (c(1:n-1), c(2:n)));   
+        idx = find (strcmp (c(1:n-1), c(2:n)));
       else
         idx = find (c(1:n-1) == c(2:n));
       endif
       if (! isempty (idx))
         c([idx, idx+1]) = [];
         i([idx, idx+1]) = [];
       endif
       if (size (a, 1) == 1 || size (b, 1) == 1)
diff --git a/scripts/set/union.m b/scripts/set/union.m
--- a/scripts/set/union.m
+++ b/scripts/set/union.m
@@ -44,17 +44,17 @@
 ## @end group
 ## @end example
 ##
 ## @deftypefnx {Function File} {[@var{c}, @var{ia}, @var{ib}] =} union (@var{a}, @var{b})
 ##
 ## Return index vectors @var{ia} and @var{ib} such that @code{a(ia)} and
 ## @code{b(ib)} are
 ## disjoint sets whose union is @var{c}.
-## 
+##
 ## @seealso{intersect, setdiff, unique}
 ## @end deftypefn
 
 ## Author: jwe
 
 function [y, ia, ib] = union (a, b, varargin)
 
   if (nargin < 2 || nargin > 3)
diff --git a/scripts/set/unique.m b/scripts/set/unique.m
--- a/scripts/set/unique.m
+++ b/scripts/set/unique.m
@@ -20,28 +20,28 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} unique (@var{x})
 ## @deftypefnx {Function File} {} unique (@var{x}, "rows")
 ## @deftypefnx {Function File} {} unique (@dots{}, "first")
 ## @deftypefnx {Function File} {} unique (@dots{}, "last")
 ## @deftypefnx {Function File} {[@var{y}, @var{i}, @var{j}] =} unique (@dots{})
 ## Return the unique elements of @var{x}, sorted in ascending order.
 ## If the input @var{x} is a vector then the output is also a vector with the
-## same orientation (row or column) as the input.  For a matrix input the 
+## same orientation (row or column) as the input.  For a matrix input the
 ## output is always a column vector.  @var{x} may also be a cell array of
 ## strings.
 ##
 ## If the optional argument @code{"rows"} is supplied, return the unique
 ## rows of @var{x}, sorted in ascending order.
 ##
 ## If requested, return index vectors @var{i} and @var{j} such that
 ## @code{x(i)==y} and @code{y(j)==x}.
 ##
 ## Additionally, if @var{i} is a requested output then one of @code{"first"} or
-## @code{"last"} may be given as an input.  If @code{"last"} is specified, 
+## @code{"last"} may be given as an input.  If @code{"last"} is specified,
 ## return the highest possible indices in @var{i}, otherwise, if @code{"first"}
 ## is specified, return the lowest.  The default is @code{"last"}.
 ## @seealso{union, intersect, setdiff, setxor, ismember}
 ## @end deftypefn
 
 function [y, i, j] = unique (x, varargin)
 
   if (nargin < 1)
@@ -78,17 +78,17 @@ function [y, i, j] = unique (x, varargin
   ##   match = (y(1:n-1) == y(2:n));
   ##   y(idx) = [];
   ##
   ## are very slow on sparse matrices.  Until they are fixed to be as
   ## fast as for full matrices, operate on the nonzero elements of the
   ## sparse array as long as we are not operating on rows.
 
   if (issparse (x) && ! optrows && nargout <= 1)
-    if (nnz (x) < numel (x)) 
+    if (nnz (x) < numel (x))
       y = unique ([0; (full (nonzeros (x)))], varargin{:});
     else
       ## Corner case where sparse matrix is actually full
       y = unique (full (x), varargin{:});
     endif
     return;
   endif
 
diff --git a/scripts/signal/arma_rnd.m b/scripts/signal/arma_rnd.m
--- a/scripts/signal/arma_rnd.m
+++ b/scripts/signal/arma_rnd.m
@@ -30,17 +30,17 @@
 ## @noindent
 ## in which @var{k} is the length of vector @var{a}, @var{l} is the
 ## length of vector @var{b} and @var{e} is Gaussian white noise with
 ## variance @var{v}.  The function returns a vector of length @var{t}.
 ##
 ## The optional parameter @var{n} gives the number of dummy
 ## @var{x}(@var{i}) used for initialization, i.e., a sequence of length
 ## @var{t}+@var{n} is generated and @var{x}(@var{n}+1:@var{t}+@var{n})
-## is returned.  If @var{n} is omitted, @var{n} = 100 is used. 
+## is returned.  If @var{n} is omitted, @var{n} = 100 is used.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Simulate an ARMA process
 
 function x = arma_rnd (a, b, v, t, n)
 
   if (nargin == 4)
diff --git a/scripts/signal/fftconv.m b/scripts/signal/fftconv.m
--- a/scripts/signal/fftconv.m
+++ b/scripts/signal/fftconv.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} fftconv (@var{x}, @var{y})
 ## @deftypefnx {Function File} {} fftconv (@var{x}, @var{y}, @var{n})
 ## Convolve two vectors using the FFT for computation.
-## 
+##
 ## @code{c = fftconv (@var{x}, @var{y})} returns a vector of length equal to
 ## @code{length (@var{x}) + length (@var{y}) - 1}.
 ## If @var{x} and @var{y} are the coefficient vectors of two polynomials, the
 ## returned value is the coefficient vector of the product polynomial.
 ##
 ## The computation uses the FFT by calling the function @code{fftfilt}.  If
 ## the optional argument @var{n} is specified, an N-point FFT is used.
 ## @seealso{deconv, conv, conv2}
@@ -98,9 +98,9 @@ endfunction
 %!  assert (size(conv(a,b)), [1, numel(a)+numel(b)-1])
 %!  assert (size(conv(b,a)), [1, numel(a)+numel(b)-1])
 
 %% Test input validation
 %!error fftconv (1);
 %!error fftconv (1,2,3,4);
 %!error fftconv ([1, 2; 3, 4], 3);
 %!error fftconv (2, []);
-%!error fftconv ([1,1], [2,2] , [3, 4]); 
+%!error fftconv ([1,1], [2,2] , [3, 4]);
diff --git a/scripts/signal/fftshift.m b/scripts/signal/fftshift.m
--- a/scripts/signal/fftshift.m
+++ b/scripts/signal/fftshift.m
@@ -26,17 +26,17 @@
 ## If @var{x} is a vector of @math{N} elements corresponding to @math{N}
 ## time samples spaced of @math{Dt} each, then @code{fftshift (fft
 ## (@var{x}))} corresponds to frequencies
 ##
 ## @example
 ## f = ((1:N) - ceil(N/2)) / N / Dt
 ## @end example
 ##
-## If @var{x} is a matrix, the same holds for rows and columns.  If 
+## If @var{x} is a matrix, the same holds for rows and columns.  If
 ## @var{x} is an array, then the same holds along each dimension.
 ##
 ## The optional @var{dim} argument can be used to limit the dimension
 ## along which the permutation occurs.
 ## @end deftypefn
 
 ## Author: Vincent Cautaerts <vincent@comf5.comm.eng.osaka-u.ac.jp>
 ## Created: July 1997
diff --git a/scripts/signal/filter2.m b/scripts/signal/filter2.m
--- a/scripts/signal/filter2.m
+++ b/scripts/signal/filter2.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{y} =} filter2 (@var{b}, @var{x})
 ## @deftypefnx {Function File} {@var{y} =} filter2 (@var{b}, @var{x}, @var{shape})
 ## Apply the 2-D FIR filter @var{b} to @var{x}.  If the argument
 ## @var{shape} is specified, return an array of the desired shape.
-## Possible values are: 
+## Possible values are:
 ##
 ## @table @asis
 ## @item 'full'
 ## pad @var{x} with zeros on all sides before filtering.
 ##
 ## @item 'same'
 ## unpadded @var{x} (default)
 ##
@@ -35,17 +35,17 @@
 ## @end table
 ##
 ## Note this is just a variation on convolution, with the parameters
 ## reversed and @var{b} rotated 180 degrees.
 ## @seealso{conv2}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
-## 2001-02-08 
+## 2001-02-08
 ##    * initial release
 
 function y = filter2 (b, x, shape)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
   if (nargin < 3)
diff --git a/scripts/signal/freqz.m b/scripts/signal/freqz.m
--- a/scripts/signal/freqz.m
+++ b/scripts/signal/freqz.m
@@ -50,17 +50,17 @@
 ## small primes.
 ##
 ## @deftypefnx {Function File} {@var{h} =} freqz (@var{b}, @var{a}, @var{w})
 ## Evaluate the response at the specific frequencies in the vector @var{w}.
 ## The values for @var{w} are measured in radians.
 ##
 ## @deftypefnx {Function File} {[@dots{}] =} freqz (@dots{}, @var{Fs})
 ## Return frequencies in Hz instead of radians assuming a sampling rate
-## @var{Fs}.  If you are evaluating the response at specific frequencies 
+## @var{Fs}.  If you are evaluating the response at specific frequencies
 ## @var{w}, those frequencies should be requested in Hz rather than radians.
 ##
 ## @deftypefnx {Function File} {} freqz (@dots{})
 ## Plot the pass band, stop band and phase response of @var{h} rather
 ## than returning them.
 ## @end deftypefn
 
 ## Author: jwe ???
@@ -75,42 +75,42 @@ function [h_r, f_r] = freqz (b, a, n, re
   elseif (nargin == 2)
     ## Response of an IIR filter
     n = region = Fs = [];
   elseif (nargin == 3)
     region = Fs = [];
   elseif (nargin == 4)
     Fs = [];
     if (! ischar (region) && ! isempty (region))
-      Fs = region; 
+      Fs = region;
       region = [];
     endif
   endif
 
   if (isempty (b))
     b = 1;
   endif
-  if (isempty (a)) 
-    a = 1; 
+  if (isempty (a))
+    a = 1;
   endif
   if (isempty (n))
-    n = 512; 
+    n = 512;
   endif
   if (isempty (region))
     if (isreal (b) && isreal (a))
       region = "half";
     else
       region = "whole";
     endif
   endif
-  if (isempty (Fs)) 
-    if (nargout == 0) 
-      Fs = 2; 
-    else 
-      Fs = 2*pi; 
+  if (isempty (Fs))
+    if (nargout == 0)
+      Fs = 2;
+    else
+      Fs = 2*pi;
     endif
   endif
 
   a = a(:);
   b = b(:);
 
   if (! isscalar (n))
     ## Explicit frequency vector given
diff --git a/scripts/signal/ifftshift.m b/scripts/signal/ifftshift.m
--- a/scripts/signal/ifftshift.m
+++ b/scripts/signal/ifftshift.m
@@ -14,18 +14,18 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} ifftshift (@var{x})
 ## @deftypefnx {Function File} {} ifftshift (@var{x}, @var{dim})
-## Undo the action of the @code{fftshift} function.  For even length 
-## @var{x}, @code{fftshift} is its own inverse, but odd lengths differ 
+## Undo the action of the @code{fftshift} function.  For even length
+## @var{x}, @code{fftshift} is its own inverse, but odd lengths differ
 ## slightly.
 ## @end deftypefn
 
 ## Author: Vincent Cautaerts <vincent@comf5.comm.eng.osaka-u.ac.jp>
 ## Created: July 1997
 ## Adapted-By: jwe
 ## Modified-By: Paul Kienzle, converted from fftshift
 ## Modified-By: David Bateman, add NDArray capability and option dim arg
diff --git a/scripts/signal/unwrap.m b/scripts/signal/unwrap.m
--- a/scripts/signal/unwrap.m
+++ b/scripts/signal/unwrap.m
@@ -15,28 +15,28 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{b} =} unwrap (@var{x})
 ## @deftypefnx {Function File} {@var{b} =} unwrap (@var{x}, @var{tol})
 ## @deftypefnx {Function File} {@var{b} =} unwrap (@var{x}, @var{tol}, @var{dim})
-## 
+##
 ## Unwrap radian phases by adding multiples of 2*pi as appropriate to
 ## remove jumps greater than @var{tol}.  @var{tol} defaults to pi.
 ##
 ## Unwrap will work along the dimension @var{dim}.  If @var{dim}
 ## is unspecified it defaults to the first non-singleton dimension.
 ## @end deftypefn
 
 ## Author: Bill Lash <lash@tellabs.com>
 
 function retval = unwrap (x, tol, dim)
-        
+
   if (nargin < 1 || nargin > 3)
     print_usage ();
   endif
 
   if (!isnumeric(x))
     error ("unwrap: X must be a numeric matrix or vector");
   endif
 
@@ -62,19 +62,19 @@ function retval = unwrap (x, tol, dim)
     endif
   endif
 
   rng = 2*pi;
   m = sz(dim);
 
   ## Handle case where we are trying to unwrap a scalar, or only have
   ## one sample in the specified dimension.
-  if (m == 1)       
-    retval = x;     
-    return;         
+  if (m == 1)
+    retval = x;
+    return;
   endif
 
   ## Take first order difference to see so that wraps will show up
   ## as large values, and the sign will show direction.
   idx = cell ();
   for i = 1:nd
     idx{i} = 1:sz(i);
   endfor
@@ -107,31 +107,31 @@ endfunction
 %!    elseif (any (abs(a(:) - b(:)) > tol))
 %!      t = 0;
 %!    else
 %!      t = 1;
 %!    endif
 %!  endif
 %!
 %!test
-%! 
+%!
 %! i = 0;
 %! t = [];
-%! 
+%!
 %! r = [0:100];                        # original vector
 %! w = r - 2*pi*floor((r+pi)/(2*pi));  # wrapped into [-pi,pi]
 %! tol = 1e3*eps;                      # maximum expected deviation
-%! 
+%!
 %! t(++i) = xassert(r, unwrap(w), tol);               #unwrap single row
 %! t(++i) = xassert(r', unwrap(w'), tol);             #unwrap single column
 %! t(++i) = xassert([r',r'], unwrap([w',w']), tol);   #unwrap 2 columns
 %! t(++i) = xassert([r;r], unwrap([w;w],[],2), tol);  #verify that dim works
 %! t(++i) = xassert(r+10, unwrap(10+w), tol);         #verify that r(1)>pi works
-%! 
+%!
 %! t(++i) = xassert(w', unwrap(w',[],2));  #unwrap col by rows should not change it
 %! t(++i) = xassert(w, unwrap(w,[],1));    #unwrap row by cols should not change it
 %! t(++i) = xassert([w;w], unwrap([w;w])); #unwrap 2 rows by cols should not change them
-%! 
+%!
 %! ## verify that setting tolerance too low will cause bad results.
 %! t(++i) = xassert(any(abs(r - unwrap(w,0.8)) > 100));
-%! 
+%!
 %! assert(all(t));
 
diff --git a/scripts/sparse/bicgstab.m b/scripts/sparse/bicgstab.m
--- a/scripts/sparse/bicgstab.m
+++ b/scripts/sparse/bicgstab.m
@@ -126,38 +126,38 @@ function [x, flag, relres, iter, resvec]
     phat = precon (p);
 
     v = A * phat;
     alpha = rho_1 / (rr' * v);
     s = res - alpha * v;
 
     shat = precon (s);
 
-    t = A * shat; 
+    t = A * shat;
     omega = (t' * s) / (t' * t);
     x = x + alpha * phat + omega * shat;
     res = s - omega * t;
     rho_2 = rho_1;
 
     relres = norm (res) / norm_b;
     resvec = [resvec; relres];
 
     if (relres <= tol)
       ## We reach tolerance tol within maxit iterations.
       flag = 0;
       break;
-    elseif (resvec (end) == resvec (end - 1)) 
+    elseif (resvec (end) == resvec (end - 1))
       ## The method stagnates.
       flag = 3;
       break;
     endif
   endfor
 
   if (nargout < 2)
-    if (flag == 0) 
+    if (flag == 0)
       printf (["bicgstab converged at iteration %i ",
       "to a solution with relative residual %e\n"],iter,relres);
     elseif (flag == 3)
       printf (["bicgstab stopped at iteration %i ",
       "without converging to the desired tolerance %e\n",
       "because the method stagnated.\n",
       "The iterate returned (number %i) has relative residual %e\n"],iter,tol,iter,relres);
     else
diff --git a/scripts/sparse/cgs.m b/scripts/sparse/cgs.m
--- a/scripts/sparse/cgs.m
+++ b/scripts/sparse/cgs.m
@@ -126,17 +126,17 @@ function [x, flag, relres, iter, resvec]
     elseif (resvec (end) == resvec (end - 1))
       ## The method stagnates.
       flag = 3;
       break;
     endif
   endfor;
 
   if (nargout < 1)
-    if ( flag == 0 ) 
+    if ( flag == 0 )
       printf (["cgs converged at iteration %i ",
       "to a solution with relative residual %e\n"],iter,relres);
     elseif (flag == 3)
       printf (["cgs stopped at iteration %i ",
       "without converging to the desired tolerance %e\n",
       "because the method stagnated.\n",
       "The iterate returned (number %i) has relative residual %e\n"],iter,tol,iter,relres);
     else
diff --git a/scripts/sparse/gplot.m b/scripts/sparse/gplot.m
--- a/scripts/sparse/gplot.m
+++ b/scripts/sparse/gplot.m
@@ -42,15 +42,15 @@ function [x, y] = gplot (A, xy, line_sty
     line_style = "-";
   endif
 
   [i, j] = find (A);
   xcoord = [xy(i,1), xy(j,1), NaN(length(i),1) ]'(:);
   ycoord = [xy(i,2), xy(j,2), NaN(length(i),1) ]'(:);
 
   if (nargout == 0)
-    plot (xcoord, ycoord, line_style); 
+    plot (xcoord, ycoord, line_style);
   else
     x = xcoord;
     y = ycoord;
   endif
 
 endfunction
diff --git a/scripts/sparse/pcg.m b/scripts/sparse/pcg.m
--- a/scripts/sparse/pcg.m
+++ b/scripts/sparse/pcg.m
@@ -27,189 +27,189 @@
 ## @itemize
 ## @item
 ## @var{A} can be either a square (preferably sparse) matrix or a
 ## function handle, inline function or string containing the name
 ## of a function which computes @code{@var{A} * @var{x}}.  In principle
 ## @var{A} should be symmetric and positive definite; if @code{pcg}
 ## finds @var{A} to not be positive definite, you will get a warning
 ## message and the @var{flag} output parameter will be set.
-## 
+##
 ## @item
 ## @var{b} is the right hand side vector.
-## 
+##
 ## @item
 ## @var{tol} is the required relative tolerance for the residual error,
 ## @code{@var{b} - @var{A} * @var{x}}.  The iteration stops if
-## @code{norm (@var{b} - @var{A} * @var{x}) <= 
+## @code{norm (@var{b} - @var{A} * @var{x}) <=
 ##       @var{tol} * norm (@var{b} - @var{A} * @var{x0})}.
 ## If @var{tol} is empty or is omitted, the function sets
 ## @code{@var{tol} = 1e-6} by default.
-## 
+##
 ## @item
 ## @var{maxit} is the maximum allowable number of iterations; if
 ## @code{[]} is supplied for @code{maxit}, or @code{pcg} has less
 ## arguments, a default value equal to 20 is used.
-## 
+##
 ## @item
 ## @var{m} = @var{m1} * @var{m2} is the (left) preconditioning matrix, so that
 ## the iteration is (theoretically) equivalent to solving by @code{pcg}
 ## @code{@var{P} *
 ## @var{x} = @var{m} \ @var{b}}, with @code{@var{P} = @var{m} \ @var{A}}.
 ## Note that a proper choice of the preconditioner may dramatically
 ## improve the overall performance of the method.  Instead of matrices
-## @var{m1} and @var{m2}, the user may pass two functions which return 
-## the results of applying the inverse of @var{m1} and @var{m2} to 
-## a vector (usually this is the preferred way of using the preconditioner). 
-## If @code{[]} is supplied for @var{m1}, or @var{m1} is omitted, no 
+## @var{m1} and @var{m2}, the user may pass two functions which return
+## the results of applying the inverse of @var{m1} and @var{m2} to
+## a vector (usually this is the preferred way of using the preconditioner).
+## If @code{[]} is supplied for @var{m1}, or @var{m1} is omitted, no
 ## preconditioning is applied.  If @var{m2} is omitted, @var{m} = @var{m1}
 ## will be used as preconditioner.
-## 
+##
 ## @item
-## @var{x0} is the initial guess.  If @var{x0} is empty or omitted, the 
+## @var{x0} is the initial guess.  If @var{x0} is empty or omitted, the
 ## function sets @var{x0} to a zero vector by default.
 ## @end itemize
-## 
+##
 ## The arguments which follow @var{x0} are treated as parameters, and
 ## passed in a proper way to any of the functions (@var{A} or @var{m})
 ## which are passed to @code{pcg}.  See the examples below for further
 ## details.  The output arguments are
 ##
 ## @itemize
 ## @item
 ## @var{x} is the computed approximation to the solution of
 ## @code{@var{A} * @var{x} = @var{b}}.
-## 
+##
 ## @item
 ## @var{flag} reports on the convergence.  @code{@var{flag} = 0} means
 ## the solution converged and the tolerance criterion given by @var{tol}
 ## is satisfied.  @code{@var{flag} = 1} means that the @var{maxit} limit
 ## for the iteration count was reached.  @code{@var{flag} = 3} reports that
 ## the (preconditioned) matrix was found not positive definite.
-## 
+##
 ## @item
 ## @var{relres} is the ratio of the final residual to its initial value,
 ## measured in the Euclidean norm.
-## 
+##
 ## @item
 ## @var{iter} is the actual number of iterations performed.
 ##
-## @item 
+## @item
 ## @var{resvec} describes the convergence history of the method.
 ## @code{@var{resvec} (i,1)} is the Euclidean norm of the residual, and
 ## @code{@var{resvec} (i,2)} is the preconditioned residual norm,
 ## after the (@var{i}-1)-th iteration, @code{@var{i} =
 ## 1, 2, @dots{}, @var{iter}+1}.  The preconditioned residual norm
 ## is defined as
 ## @code{norm (@var{r}) ^ 2 = @var{r}' * (@var{m} \ @var{r})} where
 ## @code{@var{r} = @var{b} - @var{A} * @var{x}}, see also the
 ## description of @var{m}.  If @var{eigest} is not required, only
 ## @code{@var{resvec} (:,1)} is returned.
-## 
+##
 ## @item
 ## @var{eigest} returns the estimate for the smallest @code{@var{eigest}
 ## (1)} and largest @code{@var{eigest} (2)} eigenvalues of the
-## preconditioned matrix @code{@var{P} = @var{m} \ @var{A}}.  In 
+## preconditioned matrix @code{@var{P} = @var{m} \ @var{A}}.  In
 ## particular, if no preconditioning is used, the estimates for the
 ## extreme eigenvalues of @var{A} are returned.  @code{@var{eigest} (1)}
-## is an overestimate and @code{@var{eigest} (2)} is an underestimate, 
+## is an overestimate and @code{@var{eigest} (2)} is an underestimate,
 ## so that @code{@var{eigest} (2) / @var{eigest} (1)} is a lower bound
 ## for @code{cond (@var{P}, 2)}, which nevertheless in the limit should
-## theoretically be equal to the actual value of the condition number. 
+## theoretically be equal to the actual value of the condition number.
 ## The method which computes @var{eigest} works only for symmetric positive
 ## definite @var{A} and @var{m}, and the user is responsible for
-## verifying this assumption. 
+## verifying this assumption.
 ## @end itemize
-## 
+##
 ## Let us consider a trivial problem with a diagonal matrix (we exploit the
-## sparsity of A) 
-## 
+## sparsity of A)
+##
 ## @example
 ## @group
-##      n = 10; 
+##      n = 10;
 ##      A = diag (sparse (1:n));
 ##      b = rand (n, 1);
 ##      [l, u, p, q] = luinc (A, 1.e-3);
 ## @end group
 ## @end example
-## 
+##
 ## @sc{Example 1:} Simplest use of @code{pcg}
-## 
+##
 ## @example
 ##   x = pcg(A,b)
 ## @end example
-## 
+##
 ## @sc{Example 2:} @code{pcg} with a function which computes
 ## @code{@var{A} * @var{x}}
-## 
+##
 ## @example
 ## @group
 ##   function y = apply_a (x)
-##     y = [1:N]'.*x; 
+##     y = [1:N]'.*x;
 ##   endfunction
 ##
 ##   x = pcg ("apply_a", b)
 ## @end group
 ## @end example
 ##
 ## @sc{Example 3:} @code{pcg} with a preconditioner: @var{l} * @var{u}
 ##
 ## @example
 ## x = pcg (A, b, 1.e-6, 500, l*u);
 ## @end example
 ##
 ## @sc{Example 4:} @code{pcg} with a preconditioner: @var{l} * @var{u}.
-## Faster than @sc{Example 3} since lower and upper triangular matrices 
+## Faster than @sc{Example 3} since lower and upper triangular matrices
 ## are easier to invert
 ##
 ## @example
 ## x = pcg (A, b, 1.e-6, 500, l, u);
 ## @end example
 ##
 ## @sc{Example 5:} Preconditioned iteration, with full diagnostics.  The
 ## preconditioner (quite strange, because even the original matrix
 ## @var{A} is trivial) is defined as a function
-## 
+##
 ## @example
 ## @group
 ##   function y = apply_m (x)
 ##     k = floor (length (x) - 2);
 ##     y = x;
 ##     y(1:k) = x(1:k)./[1:k]';
 ##   endfunction
-## 
+##
 ##   [x, flag, relres, iter, resvec, eigest] = ...
 ##                      pcg (A, b, [], [], "apply_m");
 ##   semilogy (1:iter+1, resvec);
 ## @end group
 ## @end example
-## 
+##
 ## @sc{Example 6:} Finally, a preconditioner which depends on a
 ## parameter @var{k}.
-## 
+##
 ## @example
 ## @group
 ##   function y = apply_M (x, varargin)
-##   K = varargin@{1@}; 
+##   K = varargin@{1@};
 ##   y = x;
 ##   y(1:K) = x(1:K)./[1:K]';
 ##   endfunction
-## 
+##
 ##   [x, flag, relres, iter, resvec, eigest] = ...
 ##        pcg (A, b, [], [], "apply_m", [], [], 3)
 ## @end group
 ## @end example
-## 
+##
 ## References:
-## 
+##
 ## @enumerate
 ## @item
 ## C.T. Kelley, @cite{Iterative Methods for Linear and Nonlinear Equations},
 ## SIAM, 1995. (the base PCG algorithm)
-##      
+##
 ## @item
 ## Y. Saad, @cite{Iterative Methods for Sparse Linear Systems}, PWS 1996.
 ## (condition number estimate from PCG) Revised version of this book is
 ## available online at @url{http://www-users.cs.umn.edu/~saad/books.html}
 ## @end enumerate
 ##
 ## @seealso{sparse, pcr}
 ## @end deftypefn
@@ -256,20 +256,20 @@ function [x, flag, relres, iter, resvec,
     T = zeros (maxit, maxit);
     preconditioned_residual_out = true;
   endif
 
   ## Assume A is positive definite.
   matrix_positive_definite = true;
 
   p = zeros (size (b));
-  oldtau = 1; 
+  oldtau = 1;
   if (isnumeric (A))
     ## A is a matrix.
-    r = b - A*x; 
+    r = b - A*x;
   else
     ## A should be a function.
     r = b - feval (A, x, varargin{:});
   endif
 
   resvec(1,1) = norm (r);
   alpha = 1;
   iter = 2;
@@ -288,17 +288,17 @@ function [x, flag, relres, iter, resvec,
       if (isnumeric (m2))
         z = m2 \ y;
       else
         z = feval (m2, y, varargin{:});
       endif
     else
       z = y;
     endif
-    tau = z' * r; 
+    tau = z' * r;
     resvec (iter-1,2) = sqrt (tau);
     beta = tau / oldtau;
     oldtau = tau;
     p = z + beta * p;
     if (isnumeric (A))
       ## A is a matrix.
       w = A * p;
     else
@@ -388,59 +388,59 @@ function [x, flag, relres, iter, resvec,
     endif
   endif
 endfunction
 
 %!demo
 %!
 %!      # Simplest usage of pcg (see also 'help pcg')
 %!
-%!      N = 10; 
+%!      N = 10;
 %!      A = diag ([1:N]); b = rand (N, 1); y =  A \ b; #y is the true solution
 %!      x = pcg (A, b);
 %!      printf('The solution relative error is %g\n', norm (x - y) / norm (y));
 %!
 %!      # You shouldn't be afraid if pcg issues some warning messages in this
-%!      # example: watch out in the second example, why it takes N iterations 
+%!      # example: watch out in the second example, why it takes N iterations
 %!      # of pcg to converge to (a very accurate, by the way) solution
 %!demo
 %!
 %!      # Full output from pcg, except for the eigenvalue estimates
-%!      # We use this output to plot the convergence history  
+%!      # We use this output to plot the convergence history
 %!
-%!      N = 10; 
+%!      N = 10;
 %!      A = diag ([1:N]); b = rand (N, 1); X =  A \ b; #X is the true solution
 %!      [x, flag, relres, iter, resvec] = pcg (A, b);
 %!      printf('The solution relative error is %g\n', norm (x - X) / norm (X));
 %!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||/||b||)');
 %!      semilogy([0:iter], resvec / resvec(1),'o-g');
 %!      legend('relative residual');
 %!demo
 %!
 %!      # Full output from pcg, including the eigenvalue estimates
 %!      # Hilbert matrix is extremely ill conditioned, so pcg WILL have problems
 %!
-%!      N = 10; 
+%!      N = 10;
 %!      A = hilb (N); b = rand (N, 1); X = A \ b; #X is the true solution
 %!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], 200);
 %!      printf('The solution relative error is %g\n', norm (x - X) / norm (X));
 %!      printf('Condition number estimate is %g\n', eigest(2) / eigest (1));
 %!      printf('Actual condition number is   %g\n', cond (A));
 %!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||)');
 %!      semilogy([0:iter], resvec,['o-g';'+-r']);
 %!      legend('absolute residual','absolute preconditioned residual');
 %!demo
 %!
 %!      # Full output from pcg, including the eigenvalue estimates
 %!      # We use the 1-D Laplacian matrix for A, and cond(A) = O(N^2)
 %!      # and that's the reasone we need some preconditioner; here we take
-%!      # a very simple and not powerful Jacobi preconditioner, 
+%!      # a very simple and not powerful Jacobi preconditioner,
 %!      # which is the diagonal of A
 %!
-%!      N = 100; 
+%!      N = 100;
 %!      A = zeros (N, N);
 %!      for i=1 : N - 1 # form 1-D Laplacian matrix
 %!              A (i:i+1, i:i+1) = [2 -1; -1 2];
 %!      endfor
 %!      b = rand (N, 1); X = A \ b; #X is the true solution
 %!      maxit = 80;
 %!      printf('System condition number is %g\n', cond (A));
 %!      # No preconditioner: the convergence is very slow!
@@ -475,56 +475,56 @@ endfunction
 %!      legend('NO preconditioning: absolute residual', ...
 %!             'JACOBI preconditioner: absolute residual', ...
 %!             'BLOCK JACOBI preconditioner: absolute residual');
 %!      hold off;
 %!test
 %!
 %!      #solve small diagonal system
 %!
-%!      N = 10; 
+%!      N = 10;
 %!      A = diag ([1:N]); b = rand (N, 1); X = A \ b; #X is the true solution
 %!      [x, flag] = pcg (A, b, [], N+1);
 %!      assert(norm (x - X) / norm (X), 0, 1e-10);
 %!      assert(flag, 0);
 %!
 %!test
 %!
 %!      #solve small indefinite diagonal system
 %!      #despite A is indefinite, the iteration continues and converges
 %!      #indefiniteness of A is detected
 %!
-%!      N = 10; 
+%!      N = 10;
 %!      A = diag([1:N] .* (-ones(1, N) .^ 2)); b = rand (N, 1); X = A \ b; #X is the true solution
 %!      [x, flag] = pcg (A, b, [], N+1);
 %!      assert(norm (x - X) / norm (X), 0, 1e-10);
 %!      assert(flag, 3);
 %!
 %!test
 %!
 %!      #solve tridiagonal system, do not converge in default 20 iterations
 %!
-%!      N = 100; 
+%!      N = 100;
 %!      A = zeros (N, N);
 %!      for i = 1 : N - 1 # form 1-D Laplacian matrix
 %!              A (i:i+1, i:i+1) = [2 -1; -1 2];
 %!      endfor
 %!      b = ones (N, 1); X = A \ b; #X is the true solution
 %!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, 1e-12);
 %!      assert(flag);
 %!      assert(relres > 1.0);
 %!      assert(iter, 20); #should perform max allowable default number of iterations
 %!
 %!test
 %!
 %!      #solve tridiagonal system with 'prefect' preconditioner
 %!      #converges in one iteration, so the eigest does not work
 %!      #and issues a warning
 %!
-%!      N = 100; 
+%!      N = 100;
 %!      A = zeros (N, N);
 %!      for i = 1 : N - 1 # form 1-D Laplacian matrix
 %!              A (i:i+1, i:i+1) = [2 -1; -1 2];
 %!      endfor
 %!      b = ones (N, 1); X = A \ b; #X is the true solution
 %!      [x, flag, relres, iter, resvec, eigest] = pcg (A, b, [], [], A, [], b);
 %!      assert(norm (x - X) / norm (X), 0, 1e-6);
 %!      assert(flag, 0);
diff --git a/scripts/sparse/pcr.m b/scripts/sparse/pcr.m
--- a/scripts/sparse/pcr.m
+++ b/scripts/sparse/pcr.m
@@ -14,158 +14,158 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{x} =} pcr (@var{A}, @var{b}, @var{tol}, @var{maxit}, @var{m}, @var{x0}, @dots{})
 ## @deftypefnx {Function File} {[@var{x}, @var{flag}, @var{relres}, @var{iter}, @var{resvec}] =} pcr (@dots{})
-## 
+##
 ## Solves the linear system of equations @code{@var{A} * @var{x} = @var{b}}
 ## by means of the Preconditioned Conjugate Residuals iterative
 ## method.  The input arguments are
 ##
 ## @itemize
 ## @item
 ## @var{A} can be either a square (preferably sparse) matrix or a
 ## function handle, inline function or string containing the name
 ## of a function which computes @code{@var{A} * @var{x}}.  In principle
 ## @var{A} should be symmetric and non-singular; if @code{pcr}
 ## finds @var{A} to be numerically singular, you will get a warning
 ## message and the @var{flag} output parameter will be set.
-## 
+##
 ## @item
 ## @var{b} is the right hand side vector.
-## 
+##
 ## @item
 ## @var{tol} is the required relative tolerance for the residual error,
-## @code{@var{b} - @var{A} * @var{x}}.  The iteration stops if 
-## @code{norm (@var{b} - @var{A} * @var{x}) <= 
+## @code{@var{b} - @var{A} * @var{x}}.  The iteration stops if
+## @code{norm (@var{b} - @var{A} * @var{x}) <=
 ##       @var{tol} * norm (@var{b} - @var{A} * @var{x0})}.
 ## If @var{tol} is empty or is omitted, the function sets
 ## @code{@var{tol} = 1e-6} by default.
-## 
+##
 ## @item
 ## @var{maxit} is the maximum allowable number of iterations; if
 ## @code{[]} is supplied for @code{maxit}, or @code{pcr} has less
 ## arguments, a default value equal to 20 is used.
 ##
 ## @item
 ## @var{m} is the (left) preconditioning matrix, so that the iteration is
 ## (theoretically) equivalent to solving by @code{pcr} @code{@var{P} *
 ## @var{x} = @var{m} \ @var{b}}, with @code{@var{P} = @var{m} \ @var{A}}.
 ## Note that a proper choice of the preconditioner may dramatically
 ## improve the overall performance of the method.  Instead of matrix
-## @var{m}, the user may pass a function which returns the results of 
+## @var{m}, the user may pass a function which returns the results of
 ## applying the inverse of @var{m} to a vector (usually this is the
 ## preferred way of using the preconditioner).  If @code{[]} is supplied
 ## for @var{m}, or @var{m} is omitted, no preconditioning is applied.
-## 
+##
 ## @item
-## @var{x0} is the initial guess.  If @var{x0} is empty or omitted, the 
+## @var{x0} is the initial guess.  If @var{x0} is empty or omitted, the
 ## function sets @var{x0} to a zero vector by default.
 ## @end itemize
-## 
+##
 ## The arguments which follow @var{x0} are treated as parameters, and
 ## passed in a proper way to any of the functions (@var{A} or @var{m})
 ## which are passed to @code{pcr}.  See the examples below for further
 ## details.  The output arguments are
 ##
 ## @itemize
 ## @item
 ## @var{x} is the computed approximation to the solution of
 ## @code{@var{A} * @var{x} = @var{b}}.
-## 
+##
 ## @item
 ## @var{flag} reports on the convergence.  @code{@var{flag} = 0} means
 ## the solution converged and the tolerance criterion given by @var{tol}
 ## is satisfied.  @code{@var{flag} = 1} means that the @var{maxit} limit
 ## for the iteration count was reached.  @code{@var{flag} = 3} reports t
 ## @code{pcr} breakdown, see [1] for details.
-## 
+##
 ## @item
 ## @var{relres} is the ratio of the final residual to its initial value,
 ## measured in the Euclidean norm.
-## 
+##
 ## @item
 ## @var{iter} is the actual number of iterations performed.
 ##
-## @item 
+## @item
 ## @var{resvec} describes the convergence history of the method,
-## so that @code{@var{resvec} (i)} contains the Euclidean norms of the 
+## so that @code{@var{resvec} (i)} contains the Euclidean norms of the
 ## residual after the (@var{i}-1)-th iteration, @code{@var{i} =
 ## 1,2, @dots{}, @var{iter}+1}.
 ## @end itemize
-## 
+##
 ## Let us consider a trivial problem with a diagonal matrix (we exploit the
-## sparsity of A) 
-## 
+## sparsity of A)
+##
 ## @example
 ## @group
-##      n = 10; 
+##      n = 10;
 ##      A = sparse (diag (1:n));
 ##      b = rand (N, 1);
 ## @end group
 ## @end example
-## 
+##
 ## @sc{Example 1:} Simplest use of @code{pcr}
-## 
+##
 ## @example
 ##   x = pcr(A, b)
 ## @end example
-## 
+##
 ## @sc{Example 2:} @code{pcr} with a function which computes
 ## @code{@var{A} * @var{x}}.
 ##
 ## @example
 ## @group
-##   function y = apply_a (x) 
-##     y = [1:10]'.*x; 
+##   function y = apply_a (x)
+##     y = [1:10]'.*x;
 ##   endfunction
-## 
+##
 ##   x = pcr ("apply_a", b)
 ## @end group
 ## @end example
-## 
+##
 ## @sc{Example 3:}  Preconditioned iteration, with full diagnostics.  The
 ## preconditioner (quite strange, because even the original matrix
 ## @var{A} is trivial) is defined as a function
-## 
+##
 ## @example
 ## @group
-##   function y = apply_m (x)           
-##     k = floor (length(x)-2); 
-##     y = x; 
-##     y(1:k) = x(1:k)./[1:k]'; 
+##   function y = apply_m (x)
+##     k = floor (length(x)-2);
+##     y = x;
+##     y(1:k) = x(1:k)./[1:k]';
 ##   endfunction
-## 
+##
 ##   [x, flag, relres, iter, resvec] = ...
 ##                      pcr (A, b, [], [], "apply_m")
 ##   semilogy([1:iter+1], resvec);
 ## @end group
 ## @end example
 ##
 ## @sc{Example 4:} Finally, a preconditioner which depends on a
 ## parameter @var{k}.
-## 
+##
 ## @example
 ## @group
 ##   function y = apply_m (x, varargin)
-##     k = varargin@{1@}; 
-##     y = x; y(1:k) = x(1:k)./[1:k]';   
+##     k = varargin@{1@};
+##     y = x; y(1:k) = x(1:k)./[1:k]';
 ##   endfunction
-## 
+##
 ##   [x, flag, relres, iter, resvec] = ...
 ##                      pcr (A, b, [], [], "apply_m"', [], 3)
 ## @end group
 ## @end example
-## 
+##
 ## References:
-## 
+##
 ##      [1] W. Hackbusch, @cite{Iterative Solution of Large Sparse Systems of
 ##      Equations}, section 9.5.4; Springer, 1994
 ##
 ## @seealso{sparse, pcg}
 ## @end deftypefn
 
 ## Author: Piotr Krzyzanowski <piotr.krzyzanowski@mimuw.edu.pl>
 
@@ -219,63 +219,63 @@ function [x, flag, relres, iter, resvec]
   b_bot_old = 1;
   q_old = p_old = s_old = zeros (size (x));
 
   if (isnumeric (A))            # is A a matrix?
     q = A * p;
   else                          # then A should be a function!
     q = feval (A, p, varargin{:});
   endif
-        
-  resvec(1) = abs (norm (r)); 
+
+  resvec(1) = abs (norm (r));
 
   ## iteration
   while (resvec(iter-1) > tol*resvec(1) && iter < maxit)
 
     if (isnumeric (m))          # is M a matrix?
       if (isempty (m))          # if M is empty, use no precond
         s = q;
       else                      # otherwise, apply the precond
         s = m \ q;
       endif
     else                        # then M should be a function!
       s = feval (m, q, varargin{:});
     endif
     b_top = r' * s;
     b_bot = q' * s;
-        
+
     if (b_bot == 0.0)
       breakdown = true;
       break;
     endif
     lambda = b_top / b_bot;
-        
+
     x += lambda*p;
     r -= lambda*q;
-        
+
     if (isnumeric(A))           # is A a matrix?
       t = A*s;
     else                        # then A should be a function!
       t = feval (A, s, varargin{:});
     endif
-        
+
     alpha0 = (t'*s) / b_bot;
     alpha1 = (t'*s_old) / b_bot_old;
-        
+
     p_temp = p;
     q_temp = q;
 
     p = s - alpha0*p - alpha1*p_old;
     q = t - alpha0*q - alpha1*q_old;
-        
+
     s_old = s;
     p_old = p_temp;
     q_old = q_temp;
     b_bot_old = b_bot;
-        
+
     resvec(iter) = abs (norm (r));
     iter++;
   endwhile
 
   flag = 0;
   relres = resvec(iter-1) ./ resvec(1);
   iter -= 2;
   if (iter >= maxit-2)
@@ -299,64 +299,64 @@ function [x, flag, relres, iter, resvec]
   endif
 
 endfunction
 
 %!demo
 %!
 %!      # Simplest usage of PCR (see also 'help pcr')
 %!
-%!      N = 20; 
+%!      N = 20;
 %!      A = diag(linspace(-3.1,3,N)); b = rand(N,1); y = A\b; #y is the true solution
 %!      x = pcr(A,b);
 %!      printf('The solution relative error is %g\n', norm(x-y)/norm(y));
 %!
 %!      # You shouldn't be afraid if PCR issues some warning messages in this
-%!      # example: watch out in the second example, why it takes N iterations 
+%!      # example: watch out in the second example, why it takes N iterations
 %!      # of PCR to converge to (a very accurate, by the way) solution
 %!demo
 %!
 %!      # Full output from PCR
-%!      # We use this output to plot the convergence history  
+%!      # We use this output to plot the convergence history
 %!
-%!      N = 20; 
+%!      N = 20;
 %!      A = diag(linspace(-3.1,30,N)); b = rand(N,1); X = A\b; #X is the true solution
 %!      [x, flag, relres, iter, resvec] = pcr(A,b);
 %!      printf('The solution relative error is %g\n', norm(x-X)/norm(X));
 %!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||/||b||)');
 %!      semilogy([0:iter],resvec/resvec(1),'o-g;relative residual;');
 %!demo
 %!
 %!      # Full output from PCR
 %!      # We use indefinite matrix based on the Hilbert matrix, with one
 %!      # strongly negative eigenvalue
-%!      # Hilbert matrix is extremely ill conditioned, so is ours, 
+%!      # Hilbert matrix is extremely ill conditioned, so is ours,
 %!      # and that's why PCR WILL have problems
 %!
-%!      N = 10; 
+%!      N = 10;
 %!      A = hilb(N); A(1,1)=-A(1,1); b = rand(N,1); X = A\b; #X is the true solution
 %!      printf('Condition number of A is   %g\n', cond(A));
 %!      [x, flag, relres, iter, resvec] = pcr(A,b,[],200);
 %!      if (flag == 3)
 %!        printf('PCR breakdown. System matrix is [close to] singular\n');
 %!      end
 %!      title('Convergence history'); xlabel('Iteration'); ylabel('log(||b-Ax||)');
 %!      semilogy([0:iter],resvec,'o-g;absolute residual;');
 %!demo
 %!
 %!      # Full output from PCR
-%!      # We use an indefinite matrix based on the 1-D Laplacian matrix for A, 
+%!      # We use an indefinite matrix based on the 1-D Laplacian matrix for A,
 %!      # and here we have cond(A) = O(N^2)
 %!      # That's the reason we need some preconditioner; here we take
-%!      # a very simple and not powerful Jacobi preconditioner, 
+%!      # a very simple and not powerful Jacobi preconditioner,
 %!      # which is the diagonal of A
 %!
 %!      # Note that we use here indefinite preconditioners!
 %!
-%!      N = 100; 
+%!      N = 100;
 %!      A = zeros(N,N);
 %!      for i=1:N-1 # form 1-D Laplacian matrix
 %!              A(i:i+1,i:i+1) = [2 -1; -1 2];
 %!      endfor
 %!      A = [A, zeros(size(A)); zeros(size(A)), -A];
 %!      b = rand(2*N,1); X = A\b; #X is the true solution
 %!      maxit = 80;
 %!      printf('System condition number is %g\n',cond(A));
@@ -385,44 +385,44 @@ endfunction
 %!      M = [M, zeros(size(M)); zeros(size(M)), -M];
 %!      [x, flag, relres, iter, resvec] = pcr(A,b,[],maxit,M);
 %!      semilogy([0:iter],resvec,'o-b;BLOCK JACOBI preconditioner: absolute residual;');
 %!      hold off;
 %!test
 %!
 %!      #solve small indefinite diagonal system
 %!
-%!      N = 10; 
+%!      N = 10;
 %!      A = diag(linspace(-10.1,10,N)); b = ones(N,1); X = A\b; #X is the true solution
 %!      [x, flag] = pcr(A,b,[],N+1);
 %!      assert(norm(x-X)/norm(X)<1e-10);
 %!      assert(flag,0);
 %!
 %!test
 %!
 %!      #solve tridiagonal system, do not converge in default 20 iterations
 %!      #should perform max allowable default number of iterations
 %!
-%!      N = 100; 
+%!      N = 100;
 %!      A = zeros(N,N);
 %!      for i=1:N-1 # form 1-D Laplacian matrix
 %!              A(i:i+1,i:i+1) = [2 -1; -1 2];
 %!      endfor
 %!      b = ones(N,1); X = A\b; #X is the true solution
 %!      [x, flag, relres, iter, resvec] = pcr(A,b,1e-12);
 %!      assert(flag,1);
 %!      assert(relres>0.6);
 %!      assert(iter,20);
 %!
 %!test
 %!
 %!      #solve tridiagonal system with 'prefect' preconditioner
 %!      #converges in one iteration
 %!
-%!      N = 100; 
+%!      N = 100;
 %!      A = zeros(N,N);
 %!      for i=1:N-1 # form 1-D Laplacian matrix
 %!              A(i:i+1,i:i+1) = [2 -1; -1 2];
 %!      endfor
 %!      b = ones(N,1); X = A\b; #X is the true solution
 %!      [x, flag, relres, iter] = pcr(A,b,[],[],A,b);
 %!      assert(norm(x-X)/norm(X)<1e-6);
 %!      assert(relres<1e-6);
diff --git a/scripts/sparse/spaugment.m b/scripts/sparse/spaugment.m
--- a/scripts/sparse/spaugment.m
+++ b/scripts/sparse/spaugment.m
@@ -23,19 +23,19 @@
 ## @example
 ## @group
 ## [@var{c} * eye(@var{m}, @var{m}),@var{A}; @var{A}', zeros(@var{n},
 ## @var{n})]
 ## @end group
 ## @end example
 ##
 ## @noindent
-## This is related to the least squares solution of 
+## This is related to the least squares solution of
 ## @code{@var{A} \\ @var{b}}, by
-## 
+##
 ## @example
 ## @group
 ## @var{s} * [ @var{r} / @var{c}; x] = [@var{b}, zeros(@var{n},
 ## columns(@var{b})]
 ## @end group
 ## @end example
 ##
 ## @noindent
@@ -44,17 +44,17 @@
 ## @example
 ## @var{r} = @var{b} - @var{A} * @var{x}
 ## @end example
 ##
 ## As the matrix @var{s} is symmetric indefinite it can be factorized
 ## with @code{lu}, and the minimum norm solution can therefore be found
 ## without the need for a @code{qr} factorization.  As the residual
 ## error will be @code{zeros (@var{m}, @var{m})} for under determined
-## problems, and example can be 
+## problems, and example can be
 ##
 ## @example
 ## @group
 ## m = 11; n = 10; mn = max(m ,n);
 ## A = spdiags ([ones(mn,1), 10*ones(mn,1), -ones(mn,1)],
 ##              [-1, 0, 1], m, n);
 ## x0 = A \ ones (m,1);
 ## s = spaugment (A);
diff --git a/scripts/sparse/spdiags.m b/scripts/sparse/spdiags.m
--- a/scripts/sparse/spdiags.m
+++ b/scripts/sparse/spdiags.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{b}, @var{c}] =} spdiags (@var{A})
 ## @deftypefnx {Function File} {@var{b} =} spdiags (@var{A}, @var{c})
 ## @deftypefnx {Function File} {@var{b} =} spdiags (@var{v}, @var{c}, @var{A})
 ## @deftypefnx {Function File} {@var{b} =} spdiags (@var{v}, @var{c}, @var{m}, @var{n})
 ## A generalization of the function @code{diag}.  Called with a single
 ## input argument, the non-zero diagonals @var{c} of @var{A} are extracted.
-## With two arguments the diagonals to extract are given by the vector 
+## With two arguments the diagonals to extract are given by the vector
 ## @var{c}.
 ##
 ## The other two forms of @code{spdiags} modify the input matrix by
 ## replacing the diagonals.  They use the columns of @var{v} to replace
 ## the columns represented by the vector @var{c}.  If the sparse matrix
 ## @var{A} is defined then the diagonals of this matrix are replaced.
 ## Otherwise a matrix of @var{m} by @var{n} is created with the
 ## diagonals given by @var{v}.
diff --git a/scripts/sparse/speye.m b/scripts/sparse/speye.m
--- a/scripts/sparse/speye.m
+++ b/scripts/sparse/speye.m
@@ -21,17 +21,17 @@
 ## @deftypefnx {Function File} {@var{y} =} speye (@var{m}, @var{n})
 ## @deftypefnx {Function File} {@var{y} =} speye (@var{sz})
 ## Returns a sparse identity matrix.  This is significantly more
 ## efficient than @code{sparse (eye (@var{m}))} as the full matrix
 ## is not constructed.
 ##
 ## Called with a single argument a square matrix of size @var{m} by
 ## @var{m} is created.  Otherwise a matrix of @var{m} by @var{n} is
-## created.  If called with a single vector argument, this argument 
+## created.  If called with a single vector argument, this argument
 ## is taken to be the size of the matrix to create.
 ## @end deftypefn
 
 function s = speye (m, n)
   if (nargin == 1)
     if (isvector (m) && length(m) == 2)
       n = m(2);
       m = m(1);
diff --git a/scripts/sparse/spfun.m b/scripts/sparse/spfun.m
--- a/scripts/sparse/spfun.m
+++ b/scripts/sparse/spfun.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {@var{y} =} spfun (@var{f}, @var{S})
 ## Compute @code{f(@var{S})} for the non-zero values of @var{S}.
-## This results in a sparse matrix with the same structure as 
+## This results in a sparse matrix with the same structure as
 ## @var{S}.  The function @var{f} can be passed as a string, a
 ## function handle, or an inline function.
 ## @seealso{arrayfun, cellfun, structfun}
 ## @end deftypefn
 
 function y = spfun (f, S)
 
   if (nargin != 2)
diff --git a/scripts/sparse/sprand.m b/scripts/sparse/sprand.m
--- a/scripts/sparse/sprand.m
+++ b/scripts/sparse/sprand.m
@@ -22,33 +22,33 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} sprand (@var{m}, @var{n}, @var{d})
 ## @deftypefnx {Function File} {} sprand (@var{s})
 ## Generate a random sparse matrix.  The size of the matrix will be
 ## @var{m} by @var{n}, with a density of values given by @var{d}.
 ## @var{d} should be between 0 and 1.  Values will be uniformly
 ## distributed between 0 and 1.
 ##
-## Note: sometimes the actual density may be a bit smaller than @var{d}. 
+## Note: sometimes the actual density may be a bit smaller than @var{d}.
 ## This is unlikely to happen for large, truly sparse, matrices.
 ##
 ## If called with a single matrix argument, a random sparse matrix is
 ## generated wherever the matrix @var{S} is non-zero.
 ## @seealso{sprandn}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 ##
 ## Changelog:
 ##
 ## Piotr Krzyzanowski <przykry2004@users.sf.net>
 ##      2004-09-27      use Paul's hint to allow larger random matrices
 ##                      at the price of sometimes lower density than desired
-## David Bateman 
-##      2004-10-20      Texinfo help and copyright message 
+## David Bateman
+##      2004-10-20      Texinfo help and copyright message
 
 function S = sprand (m, n, d)
 
   if (nargin != 1 && nargin != 3)
     print_usage ();
   endif
 
   if (nargin == 1)
@@ -68,17 +68,17 @@ function S = sprand (m, n, d)
 
   if (d < 0 || d > 1)
     error ("sprand: density D must be between 0 and 1");
   endif
 
   mn = m*n;
   ## how many entries in S would be satisfactory?
   k = round (d*mn);
-  idx = unique (fix (rand (min (k*1.01, k+10), 1) * mn)) + 1; 
+  idx = unique (fix (rand (min (k*1.01, k+10), 1) * mn)) + 1;
   ## idx contains random numbers in [1,mn]
   ## generate 1% or 10 more random values than necessary in order to
   ## reduce the probability that there are less than k distinct
   ## values; maybe a better strategy could be used but I don't think
   ## it's worth the price
 
   ## actual number of entries in S
   k = min (length (idx), k);
diff --git a/scripts/sparse/sprandn.m b/scripts/sparse/sprandn.m
--- a/scripts/sparse/sprandn.m
+++ b/scripts/sparse/sprandn.m
@@ -22,17 +22,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} sprandn (@var{m}, @var{n}, @var{d})
 ## @deftypefnx {Function File} {} sprandn (@var{s})
 ## Generate a random sparse matrix.  The size of the matrix will be
 ## @var{m} by @var{n}, with a density of values given by @var{d}.
 ## @var{d} should be between 0 and 1. Values will be normally
 ## distributed with mean of zero and variance 1.
 ##
-## Note: sometimes the actual density may be a bit smaller than @var{d}. 
+## Note: sometimes the actual density may be a bit smaller than @var{d}.
 ## This is unlikely to happen for large really sparse matrices.
 ##
 ## If called with a single matrix argument, a random sparse matrix is
 ## generated wherever the matrix @var{S} is non-zero.
 ## @seealso{sprand}
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
@@ -40,17 +40,17 @@
 function S = sprandn (m, n, d)
   if (nargin == 1)
     [i, j, v] = find (m);
     [nr, nc] = size (m);
     S = sparse (i, j, randn (size (v)), nr, nc);
   elseif (nargin == 3)
     mn = m*n;
     k = round (d*mn);
-    idx = unique (fix (rand (min (k*1.01, k+10), 1) * mn)) + 1; 
+    idx = unique (fix (rand (min (k*1.01, k+10), 1) * mn)) + 1;
     ## idx contains random numbers in [1,mn]
     ## generate 1% or 10 more random values than necessary in order to
     ## reduce the probability that there are less than k distinct
     ## values; maybe a better strategy could be used but I don't think
     ## it's worth the price.
 
     ## actual number of entries in S
     k = min (length (idx), k);
diff --git a/scripts/sparse/sprandsym.m b/scripts/sparse/sprandsym.m
--- a/scripts/sparse/sprandsym.m
+++ b/scripts/sparse/sprandsym.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} sprandsym (@var{n}, @var{d})
 ## @deftypefnx {Function File} {} sprandsym (@var{s})
 ## Generate a symmetric random sparse matrix.  The size of the matrix will be
 ## @var{n} by @var{n}, with a density of values given by @var{d}.
 ## @var{d} should be between 0 and 1. Values will be normally
 ## distributed with mean of zero and variance 1.
 ##
-## Note: sometimes the actual density may be a bit smaller than @var{d}. 
+## Note: sometimes the actual density may be a bit smaller than @var{d}.
 ## This is unlikely to happen for large really sparse matrices.
 ##
 ## If called with a single matrix argument, a random sparse matrix is
 ## generated wherever the matrix @var{S} is non-zero in its lower
 ## triangular part.
 ## @seealso{sprand, sprandn}
 ## @end deftypefn
 
@@ -39,31 +39,31 @@ function S = sprandsym (n, d)
     [nr, nc] = size (n);
     S = sparse (i, j, randn (size (v)), nr, nc);
     S = S + tril (S, -1)';
   elseif (nargin == 2)
     m1 = floor (n/2);
     n1 = m1 + rem (n, 2);
     mn1 = m1*n1;
     k1 = round (d*mn1);
-    idx1 = unique (fix (rand (min (k1*1.01, k1+10), 1) * mn1)) + 1; 
+    idx1 = unique (fix (rand (min (k1*1.01, k1+10), 1) * mn1)) + 1;
     ## idx contains random numbers in [1,mn] generate 1% or 10 more
     ## random values than necessary in order to reduce the probability
     ## that there are less than k distinct values; maybe a better
     ## strategy could be used but I don't think it's worth the price.
 
     ## Actual number of entries in S.
     k1 = min (length (idx1), k1);
     j1 = floor ((idx1(1:k1)-1)/m1);
     i1 = idx1(1:k1) - j1*m1;
 
     n2 = ceil (n/2);
     nn2 = n2*n2;
     k2 = round (d*nn2);
-    idx2 = unique (fix (rand (min (k2*1.01, k1+10), 1) * nn2)) + 1; 
+    idx2 = unique (fix (rand (min (k2*1.01, k1+10), 1) * nn2)) + 1;
     k2 = min (length (idx2), k2);
     j2 = floor ((idx2(1:k2)-1)/n2);
     i2 = idx2(1:k2) - j2*n2;
 
     if (isempty (i1) && isempty (i2))
       S = sparse (n, n);
     else
       S1 = sparse (i1, j1+1, randn (k1, 1), m1, n1);
diff --git a/scripts/sparse/spstats.m b/scripts/sparse/spstats.m
--- a/scripts/sparse/spstats.m
+++ b/scripts/sparse/spstats.m
@@ -16,47 +16,47 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {[@var{count}, @var{mean}, @var{var}] =} spstats (@var{S})
 ## @deftypefnx {Function File} {[@var{count}, @var{mean}, @var{var}] =} spstats (@var{S}, @var{j})
 ## Return the stats for the non-zero elements of the sparse matrix @var{S}.
 ## @var{count} is the number of non-zeros in each column, @var{mean}
-## is the mean of the non-zeros in each column, and @var{var} is the  
+## is the mean of the non-zeros in each column, and @var{var} is the
 ## variance of the non-zeros in each column.
 ##
 ## Called with two input arguments, if @var{S} is the data and @var{j}
-## is the bin number for the data, compute the stats for each bin.  In 
-## this case, bins can contain data values of zero, whereas with 
+## is the bin number for the data, compute the stats for each bin.  In
+## this case, bins can contain data values of zero, whereas with
 ## @code{spstats (@var{S})} the zeros may disappear.
 ## @end deftypefn
 
 function [count, mean, var] = spstats (S, j)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (nargin == 1)
     [i, j, v] = find (S);
   else
-    v = S;    
+    v = S;
     i = 1:length (v);
     S = sparse (i, j, v);
-  endif 
+  endif
   [n, m] = size (S);
 
   count = sum (sparse (i, j, 1, n, m));
-  if (nargout > 1) 
-    mean = sum (S) ./ count; 
+  if (nargout > 1)
+    mean = sum (S) ./ count;
   endif
-  if (nargout > 2) 
+  if (nargout > 2)
     ## FIXME Variance with count = 0 or 1?
-    diff = S - sparse (i, j, mean(j), n, m); 
+    diff = S - sparse (i, j, mean(j), n, m);
     var = sum (diff .* diff) ./ (count - 1);
   endif
 
 endfunction
 
 
 %!test
 %! [n,m,v] = spstats([1 2 1 2 3 4],[2 2 1 1 1 1]);
diff --git a/scripts/sparse/spy.m b/scripts/sparse/spy.m
--- a/scripts/sparse/spy.m
+++ b/scripts/sparse/spy.m
@@ -22,17 +22,17 @@
 ## @deftypefnx {Function File} {} spy (@dots{}, @var{line_spec})
 ## Plot the sparsity pattern of the sparse matrix @var{x}.  If the argument
 ## @var{markersize} is given as an scalar value, it is used to determine the
 ## point size in the plot.  If the string @var{line_spec} is given it is
 ## passed to @code{plot} and determines the appearance of the plot.
 ## @seealso{plot}
 ## @end deftypefn
 
-function spy (x, varargin) 
+function spy (x, varargin)
 
   if (nargin < 1)
     print_usage ();
   endif
 
   markersize = NaN;
   if (numel (x) < 1000)
     line_spec = "*";
diff --git a/scripts/sparse/svds.m b/scripts/sparse/svds.m
--- a/scripts/sparse/svds.m
+++ b/scripts/sparse/svds.m
@@ -20,67 +20,67 @@
 ## @deftypefn  {Function File} {@var{s} =} svds (@var{A})
 ## @deftypefnx {Function File} {@var{s} =} svds (@var{A}, @var{k})
 ## @deftypefnx {Function File} {@var{s} =} svds (@var{A}, @var{k}, @var{sigma})
 ## @deftypefnx {Function File} {@var{s} =} svds (@var{A}, @var{k}, @var{sigma}, @var{opts})
 ## @deftypefnx {Function File} {[@var{u}, @var{s}, @var{v}] =} svds (@dots{})
 ## @deftypefnx {Function File} {[@var{u}, @var{s}, @var{v}, @var{flag}] =} svds (@dots{})
 ##
 ## Find a few singular values of the matrix @var{A}.  The singular values
-## are calculated using 
+## are calculated using
 ##
 ## @example
 ## @group
 ## [@var{m}, @var{n}] = size(@var{A})
 ## @var{s} = eigs([sparse(@var{m}, @var{m}), @var{A};
 ##                     @var{A}', sparse(@var{n}, @var{n})])
 ## @end group
 ## @end example
 ##
-## The eigenvalues returned by @code{eigs} correspond to the singular values 
+## The eigenvalues returned by @code{eigs} correspond to the singular values
 ## of @var{A}.  The number of singular values to calculate is given by @var{k}
 ## and defaults to 6.
-## 
-## The argument @var{sigma} specifies which singular values to find.  When 
-## @var{sigma} is the string 'L', the default, the largest singular values of 
-## @var{A} are found.  Otherwise, @var{sigma} must be a real scalar and the 
-## singular values closest to @var{sigma} are found.  As a corollary, 
-## @code{@var{sigma} = 0} finds the smallest singular values.  Note that for 
+##
+## The argument @var{sigma} specifies which singular values to find.  When
+## @var{sigma} is the string 'L', the default, the largest singular values of
+## @var{A} are found.  Otherwise, @var{sigma} must be a real scalar and the
+## singular values closest to @var{sigma} are found.  As a corollary,
+## @code{@var{sigma} = 0} finds the smallest singular values.  Note that for
 ## relatively small values of @var{sigma}, there is a chance that the requested
-## number of singular values will not be found.  In that case @var{sigma} 
+## number of singular values will not be found.  In that case @var{sigma}
 ## should be increased.
 ##
 ## @var{opts} is a structure defining options that @code{svds} will pass
-## to @code{eigs}.  The possible fields of this structure are documented in 
+## to @code{eigs}.  The possible fields of this structure are documented in
 ## @code{eigs}.  By default, @code{svds} sets the following three fields:
 ##
 ## @table @code
 ## @item tol
-## The required convergence tolerance for the singular values.  The default 
+## The required convergence tolerance for the singular values.  The default
 ## value is 1e-10.  @code{eigs} is passed @code{@var{tol} / sqrt(2)}.
 ##
 ## @item maxit
 ## The maximum number of iterations.  The default is 300.
 ##
 ## @item disp
-## The level of diagnostic printout (0|1|2).  If @code{disp} is 0 then 
+## The level of diagnostic printout (0|1|2).  If @code{disp} is 0 then
 ## diagnostics are disabled.  The default value is 0.
 ## @end table
 ##
 ## If more than one output is requested then @code{svds} will return an
 ## approximation of the singular value decomposition of @var{A}
 ##
 ## @example
 ## @var{A}_approx = @var{u}*@var{s}*@var{v}'
 ## @end example
 ##
 ## @noindent
 ## where @var{A}_approx is a matrix of size @var{A} but only rank @var{k}.
-## 
-## @var{flag} returns 0 if the algorithm has succesfully converged, and 1 
+##
+## @var{flag} returns 0 if the algorithm has succesfully converged, and 1
 ## otherwise.  The test for convergence is
 ##
 ## @example
 ## @group
 ## norm (@var{A}*@var{v} - @var{u}*@var{s}, 1) <= @var{tol} * norm (@var{A}, 1)
 ## @end group
 ## @end example
 ##
@@ -153,24 +153,24 @@ function [u, s, v, flag] = svds (A, k, s
     b_opts.tol = opts.tol / max_a;
     b_sigma = sigma;
     if (!ischar (b_sigma))
       b_sigma = b_sigma / max_a;
     endif
 
     if (b_sigma == 0)
       ## Find the smallest eigenvalues
-      ## The eigenvalues returns by eigs for sigma=0 are symmetric about 0. 
+      ## The eigenvalues returns by eigs for sigma=0 are symmetric about 0.
       ## As we are only interested in the positive eigenvalues, we have to
-      ## double k and then throw out the k negative eigenvalues. 
-      ## Separately, if sigma is non-zero, but smaller than the smallest 
-      ## singular value, ARPACK may not return k eigenvalues. However, as 
-      ## computation scales with k we'd like to avoid doubling k for all 
+      ## double k and then throw out the k negative eigenvalues.
+      ## Separately, if sigma is non-zero, but smaller than the smallest
+      ## singular value, ARPACK may not return k eigenvalues. However, as
+      ## computation scales with k we'd like to avoid doubling k for all
       ## scalar values of sigma.
-      b_k = 2 * k; 
+      b_k = 2 * k;
     else
       b_k = k;  # Normal case, find just the k largest eigenvalues
     endif
 
     if (nargout > 1)
       [V, s, flag] = eigs ([sparse(m,m), b; b', sparse(n,n)],
                            b_k, b_sigma, b_opts);
     else
@@ -179,27 +179,27 @@ function [u, s, v, flag] = svds (A, k, s
     s = diag (s);
 
     if (ischar (sigma))
       norma = max (s);
     else
       norma = normest (A);
     endif
     ## We wish to exclude all eigenvalues that are less than zero as these
-    ## are artifacts of the way the matrix passed to eigs is formed. There 
-    ## is also the possibility that the value of sigma chosen is exactly 
-    ## a singular value, and in that case we're dead!! So have to rely on 
+    ## are artifacts of the way the matrix passed to eigs is formed. There
+    ## is also the possibility that the value of sigma chosen is exactly
+    ## a singular value, and in that case we're dead!! So have to rely on
     ## the warning from eigs. We exclude the singular values which are
     ## less than or equal to zero to within some tolerance scaled by the
     ## norm since if we don't we might end up with too many singular
     ## values.
     tol = norma * opts.tol;
     ind = find(s > tol);
     if (length (ind) < k)
-      ## Too few eigenvalues returned.  Add in any zero eigenvalues of B, 
+      ## Too few eigenvalues returned.  Add in any zero eigenvalues of B,
       ## including the nominally negative ones.
       zind = find (abs (s) <= tol);
       p = min (length (zind), k - length (ind));
       ind = [ind; zind(1:p)];
     elseif (length (ind) > k)
       ## Too many eigenvalues returned.  Select according to criterium.
       if (b_sigma == 0)
         ind = ind(end+1-k:end); # smallest eigenvalues
@@ -246,31 +246,31 @@ endfunction
 %! [u,s,v] = svd(full(A));
 %! s = diag(s);
 %! [~, idx] = sort(abs(s));
 %! s = s(idx);
 %! u = u(:,idx);
 %! v = v(:,idx);
 %! randn('state',42);      % Initialize to make normest function reproducible
 %! rand('state',42)
-%! opts.v0 = rand (2*n,1); % Initialize eigs ARPACK starting vector 
+%! opts.v0 = rand (2*n,1); % Initialize eigs ARPACK starting vector
 %!                         % to guarantee reproducible results
 %!testif HAVE_ARPACK
 %! [u2,s2,v2,flag] = svds(A,k);
 %! s2 = diag(s2);
 %! assert(flag,!1);
-%! assert(s2, s(end:-1:end-k+1), 1e-10); 
+%! assert(s2, s(end:-1:end-k+1), 1e-10);
 %!testif HAVE_ARPACK
 %! [u2,s2,v2,flag] = svds(A,k,0,opts);
 %! s2 = diag(s2);
 %! assert(flag,!1);
-%! assert(s2, s(k:-1:1), 1e-10); 
+%! assert(s2, s(k:-1:1), 1e-10);
 %!testif HAVE_ARPACK
 %! idx = floor(n/2);
-%! % Don't put sigma right on a singular value or there are convergence issues 
-%! sigma = 0.99*s(idx) + 0.01*s(idx+1); 
+%! % Don't put sigma right on a singular value or there are convergence issues
+%! sigma = 0.99*s(idx) + 0.01*s(idx+1);
 %! [u2,s2,v2,flag] = svds(A,k,sigma,opts);
 %! s2 = diag(s2);
 %! assert(flag,!1);
-%! assert(s2, s((idx+floor(k/2)):-1:(idx-floor(k/2))), 1e-10); 
+%! assert(s2, s((idx+floor(k/2)):-1:(idx-floor(k/2))), 1e-10);
 %!testif HAVE_ARPACK
 %! [u2,s2,v2,flag] = svds(zeros (10), k);
 %! assert (isequal(u2, eye (10, k)) && isequal (s2, zeros(k)) && isequal (v2, eye(10, 7)))
diff --git a/scripts/sparse/treelayout.m b/scripts/sparse/treelayout.m
--- a/scripts/sparse/treelayout.m
+++ b/scripts/sparse/treelayout.m
@@ -26,17 +26,17 @@
 ## The complexity of the algorithm is O(n) in
 ## terms of time and memory requirements.
 ## @seealso{etreeplot, gplot,treeplot}
 ## @end deftypefn
 
 function [x_coordinate, y_coordinate, height, s] = treelayout (tree, permutation)
   if (nargin < 1 || nargin > 2 || nargout > 4)
     print_usage ();
-  elseif (! isvector (tree) || rows (tree) != 1 || ! isnumeric (tree) 
+  elseif (! isvector (tree) || rows (tree) != 1 || ! isnumeric (tree)
           ||  any (tree > length (tree)) || any (tree < 0))
     error ("treelayout: the first input argument must be a vector of predecessors");
   else
     ## Make it a row vector.
     tree = tree(:)';
 
     ## The count of nodes of the graph.
     num_nodes = length (tree);
@@ -93,17 +93,17 @@ function [x_coordinate, y_coordinate, he
       start(i) = pos;
       xhelp(i) = pos;
       pos += num_children(i);
       stop(i) = pos;
     endfor
 
     if (nargin == 1)
       for i = 1:num_nodes
-        vec_of_child(xhelp(tree(i)+1)) = i;  
+        vec_of_child(xhelp(tree(i)+1)) = i;
         xhelp(tree(i)+1) = xhelp(tree(i)+1) + 1;
       endfor
     else
       vec_of_child = permutation;
     endif
 
     ## The number of "parent" (actual) node (it's descendants will be
     ## browse in the next iteration).
@@ -145,17 +145,17 @@ function [x_coordinate, y_coordinate, he
         s++;
       else
         # We aren't in top level separator now.
         top_level = 0;
       endif
       ## If there is not any descendant of "parent node":
       if (stk(end,2) != par_number)
        left_most++;
-       x_coordinate_r(par_number) = left_most;           
+       x_coordinate_r(par_number) = left_most;
        max_ht = min (max_ht, level);
        if (length(stk) > 1 && find ((shift(stk,1)-stk) == 0) > 1
            && stk(end,2) != stk(end-1,2))
           ## Return to the nearest branching the position to return
           ## position is the position on the stack, where should be
           ## started further search (there are two nodes which has the
           ## same parent node).
 
@@ -166,46 +166,46 @@ function [x_coordinate, y_coordinate, he
           ## position to end).
 
           level += length (par_number_vec);
 
           ## The level have to be decreased.
 
           x_coordinate_r(par_number_vec) = left_most;
           stk(position:end,:) = [];
-        endif   
+        endif
 
         ## Remove the next node from "searched branch".
 
         stk(end,:) = [];
         ## Choose new "parent node".
         par_number = stk(end,1);
         ## If there is another branch start to search it.
         if (par_number != -1)
-          y_coordinate(par_number) = level;     
+          y_coordinate(par_number) = level;
           x_coordinate_l(par_number) = left_most + 1;
         endif
       else
 
         ## There were descendants of "parent nod" choose the last of
         ## them and go on through it.
         level--;
         par_number = stk(end,1);
-        y_coordinate(par_number) = level;     
+        y_coordinate(par_number) = level;
         x_coordinate_l(par_number) = left_most + 1;
       endif
     endwhile
 
     ## Calculate the x coordinates (the known values are the position
     ## of most left and most right descendants).
     x_coordinate = (x_coordinate_l + x_coordinate_r) / 2;
 
     height = num_nodes - max_ht - 1;
   endif
 endfunction
 
 %!demo
-%! % Compute a simple tree layout 
+%! % Compute a simple tree layout
 %! [x,y,h,s]=treelayout([0 1 2 2])
 
 %!demo
 %! % Compute a simple tree layout with defined postorder permutation
-%! [x,y,h,s]=treelayout([0 1 2 2],[1 2 3 4]) 
+%! [x,y,h,s]=treelayout([0 1 2 2],[1 2 3 4])
diff --git a/scripts/sparse/treeplot.m b/scripts/sparse/treeplot.m
--- a/scripts/sparse/treeplot.m
+++ b/scripts/sparse/treeplot.m
@@ -26,26 +26,26 @@
 ## @seealso{etreeplot, gplot}
 ## @end deftypefn
 
 function treeplot (tree, node_s, edge_s)
 
   if (nargin < 1 || nargin > 3 || nargout > 0)
     print_usage ();
   else
-    if (! ismatrix (tree) || rows (tree) != 1 || ! isnumeric (tree) 
+    if (! ismatrix (tree) || rows (tree) != 1 || ! isnumeric (tree)
         || ! isvector (tree) || any (tree > length (tree)))
       error ("treeplot: the first input argument must be a vector of predecessors");
     else
       ## The initialization of node end edge style.
       node_style = "k*";
-      edge_style = "r";      
+      edge_style = "r";
       if (nargin > 2)
         edge_style = edge_s;
-        if (nargin > 1) 
+        if (nargin > 1)
           if (length (findstr (node_s, "*")) == 0
               && length (findstr (node_s, "+")) == 0
               && length (findstr (node_s, "x")) == 0)
             node_style = [node_s, "o"];
           else
             node_style = node_s;
           endif
         endif
@@ -54,35 +54,35 @@ function treeplot (tree, node_s, edge_s)
       ## Make it a row vector.
       tree = tree(:)';
 
       ## The count of nodes of the graph.
       num_nodes = length (tree);
 
       ## The number of children.
       num_children = zeros (1, num_nodes+1);
-      
+
       for i = 1:num_nodes
         ## VEC_OF_CHILD is helping vector which is used to speed up the
         ## choose of descendant nodes.
 
         num_children(tree(i)+1) = num_children(tree(i)+1) + 1;
       endfor
       pos = 1;
       start = zeros (1, num_nodes+1);
       xhelp = zeros (1, num_nodes+1);
       stop = zeros (1, num_nodes+1);
       for i = 1:num_nodes+1
         start(i) = pos;
         xhelp(i) = pos;
         pos += num_children(i);
         stop(i) = pos;
       endfor
-      for i = 1:num_nodes        
-        vec_of_child(xhelp(tree(i)+1)) = i;  
+      for i = 1:num_nodes
+        vec_of_child(xhelp(tree(i)+1)) = i;
         xhelp(tree(i)+1) = xhelp(tree(i)+1)+1;
       endfor
 
       ## The number of "parent" (actual) node (it's descendants will be
       ## browse in the next iteration).
       par_number = 0;
 
       ## The x-coordinate of the left most descendant of "parent node"
@@ -116,50 +116,50 @@ function treeplot (tree, node_s, edge_s)
         ## Add to stack the records relevant to parent descandant s.
         if (par_number != 0)
           skelet = [skelet; ([ones(size(idx))*par_number; idx])(:)];
         endif
 
         ## If there is not any descendant of "parent node":
         if (stk(end,2) != par_number)
           left_most++;
-          x_coordinate_r(par_number) = left_most;           
+          x_coordinate_r(par_number) = left_most;
           max_ht = min (max_ht, level);
           if (length(stk) > 1 && find ((shift(stk,1)-stk) == 0) > 1
               && stk(end,2) != stk(end-1,2))
             ## Return to the nearest branching the position to return
             ## position is the position on the stack, where should be
             ## started further search (there are two nodes which has the
             ## same parent node).
             position = (find ((shift(stk(:,2),1)-stk(:,2)) == 0))(end) + 1;
             par_number_vec = stk(position:end,2);
             ## The vector of removed nodes (the content of stack form
             ## position to end).
             skelet = [skelet; flipud(par_number_vec)];
             level += length (par_number_vec);
             ## The level have to be decreased.
             x_coordinate_r(par_number_vec) = left_most;
             stk(position:end,:) = [];
-          endif 
+          endif
           ## Remove the next node from "searched branch".
           stk(end,:) = [];
           ## Choose new "parent node".
           par_number = stk(end,1);
           ## If there is another branch start to search it.
           if (par_number != -1)
             skelet = [skelet; stk(end,2); par_number];
-            y_coordinate(par_number) = level;   
+            y_coordinate(par_number) = level;
             x_coordinate_l(par_number) = left_most + 1;
           endif
         else
           ## There were descendants of "parent nod" choose the last of
           ## them and go on through it.
           level--;
           par_number = stk(end,1);
-          y_coordinate(par_number) = level;     
+          y_coordinate(par_number) = level;
           x_coordinate_l(par_number) = left_most + 1;
         endif
       endwhile
 
       ## Calculate the x coordinates (the known values are the position
       ## of most left and most right descendants).
       x_coordinate = (x_coordinate_l + x_coordinate_r) / 2;
 
@@ -181,35 +181,35 @@ function treeplot (tree, node_s, edge_s)
         idx = find (skelet == 0);
 
         ## Plot each tree component in one loop.
         for i = 2:length(idx)
           ## Tree component start.
           istart = idx(i-1) + 1;
           ## Tree component end.
           istop = idx(i) - 1;
-          if (istop - istart < 1)                          
+          if (istop - istart < 1)
             continue;
           endif
           plot (x_coordinate(skelet(istart:istop)),
                 y_coordinate(skelet(istart:istop)), edge_style)
         endfor
 
         ## Set axis and graph size.
         axis ([0.5, left_most+0.5, max_ht-0.5, num_nodes-0.5], "nolabel");
 
       unwind_protect_cleanup
         if (! hold_is_on)
           hold ("off");
         endif
       end_unwind_protect
-      
+
     endif
   endif
 endfunction
 
 %!demo
-%! % Plot a simple tree plot 
+%! % Plot a simple tree plot
 %! treeplot([2 4 2 0 6 4 6])
 
 %!demo
 %! % Plot a simple tree plot defining the edge and node styles
-%! treeplot([2 4 2 0 6 4 6], "b+", "g") 
+%! treeplot([2 4 2 0 6 4 6], "b+", "g")
diff --git a/scripts/specfun/bessel.m b/scripts/specfun/bessel.m
--- a/scripts/specfun/bessel.m
+++ b/scripts/specfun/bessel.m
@@ -18,20 +18,20 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Loadable Function} {[@var{j}, @var{ierr}] =} besselj (@var{alpha}, @var{x}, @var{opt})
 ## @deftypefnx {Loadable Function} {[@var{y}, @var{ierr}] =} bessely (@var{alpha}, @var{x}, @var{opt})
 ## @deftypefnx {Loadable Function} {[@var{i}, @var{ierr}] =} besseli (@var{alpha}, @var{x}, @var{opt})
 ## @deftypefnx {Loadable Function} {[@var{k}, @var{ierr}] =} besselk (@var{alpha}, @var{x}, @var{opt})
 ## @deftypefnx {Loadable Function} {[@var{h}, @var{ierr}] =} besselh (@var{alpha}, @var{k}, @var{x}, @var{opt})
 ## Compute Bessel or Hankel functions of various kinds:
-## 
+##
 ## @table @code
 ## @item besselj
-## Bessel functions of the first kind.  If the argument @var{opt} is supplied, 
+## Bessel functions of the first kind.  If the argument @var{opt} is supplied,
 ## the result is multiplied by @code{exp(-abs(imag(x)))}.
 ##
 ## @item bessely
 ## Bessel functions of the second kind.  If the argument @var{opt} is supplied,
 ## the result is multiplied by @code{exp(-abs(imag(x)))}.
 ##
 ## @item besseli
 ## Modified Bessel functions of the first kind.  If the argument @var{opt} is
@@ -45,30 +45,30 @@
 ##
 ## @item besselh
 ## Compute Hankel functions of the first (@var{k} = 1) or second (@var{k}
 ## = 2) kind.  If the argument @var{opt} is supplied, the result is multiplied
 ## by
 ## @code{exp (-I*@var{x})} for @var{k} = 1 or @code{exp (I*@var{x})} for
 ## @var{k} = 2.
 ## @end table
-## 
+##
 ## If @var{alpha} is a scalar, the result is the same size as @var{x}.
 ## If @var{x} is a scalar, the result is the same size as @var{alpha}.
 ## If @var{alpha} is a row vector and @var{x} is a column vector, the
 ## result is a matrix with @code{length (@var{x})} rows and
 ## @code{length (@var{alpha})} columns.  Otherwise, @var{alpha} and
 ## @var{x} must conform and the result will be the same size.
-## 
+##
 ## The value of @var{alpha} must be real.  The value of @var{x} may be
 ## complex.
-## 
+##
 ## If requested, @var{ierr} contains the following status information
 ## and is the same size as the result.
-## 
+##
 ## @enumerate 0
 ## @item
 ## Normal return.
 ##
 ## @item
 ## Input error, return @code{NaN}.
 ##
 ## @item
diff --git a/scripts/specfun/betaln.m b/scripts/specfun/betaln.m
--- a/scripts/specfun/betaln.m
+++ b/scripts/specfun/betaln.m
@@ -24,17 +24,17 @@
 ##  B (a, b) = \log {\Gamma (a) \Gamma (b) \over \Gamma (a + b)}.
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## betaln (a, b) = gammaln (a) + gammaln (b) - gammaln (a + b)
 ## @end example
-## 
+##
 ## @end ifnottex
 ## @seealso{beta, betainc, gammaln}
 ## @end deftypefn
 
 ## Author:   Nicol N. Schraudolph <nic@idsia.ch>
 ## Created:  06 Aug 1998
 ## Keywords: log beta special function
 
diff --git a/scripts/specfun/factor.m b/scripts/specfun/factor.m
--- a/scripts/specfun/factor.m
+++ b/scripts/specfun/factor.m
@@ -15,19 +15,19 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{p} =} factor (@var{q})
 ## @deftypefnx {Function File} {[@var{p}, @var{n}] =} factor (@var{q})
 ##
-## Return prime factorization of @var{q}.  That is, 
+## Return prime factorization of @var{q}.  That is,
 ## @code{prod (@var{p}) == @var{q}} and every element of @var{p} is a prime
-## number.  If @code{@var{q} == 1}, return 1. 
+## number.  If @code{@var{q} == 1}, return 1.
 ##
 ## With two output arguments, return the unique primes @var{p} and
 ## their multiplicities.  That is, @code{prod (@var{p} .^ @var{n}) ==
 ## @var{q}}.
 ## @seealso{gcd, lcm}
 ## @end deftypefn
 
 ## Author: Paul Kienzle
@@ -47,17 +47,17 @@ function [x, n] = factor (q)
     error ("factor: Q must be a scalar integer");
   endif
 
   ## Special case of no primes less than sqrt(q).
   if (q < 4)
     x = q;
     n = 1;
     return;
-  endif 
+  endif
 
   x = [];
   ## There is at most one prime greater than sqrt(q), and if it exists,
   ## it has multiplicity 1, so no need to consider any factors greater
   ## than sqrt(q) directly. [If there were two factors p1, p2 > sqrt(q),
   ## then q >= p1*p2 > sqrt(q)*sqrt(q) == q. Contradiction.]
   p = primes (sqrt (q));
   while (q > 1)
diff --git a/scripts/specfun/legendre.m b/scripts/specfun/legendre.m
--- a/scripts/specfun/legendre.m
+++ b/scripts/specfun/legendre.m
@@ -15,21 +15,21 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{l} =} legendre (@var{n}, @var{x})
 ## @deftypefnx {Function File} {@var{l} =} legendre (@var{n}, @var{x}, @var{normalization})
-## Compute the Legendre function of degree @var{n} and order 
-## @var{m} = 0 @dots{} N@.  The optional argument, @var{normalization}, 
+## Compute the Legendre function of degree @var{n} and order
+## @var{m} = 0 @dots{} N@.  The optional argument, @var{normalization},
 ## may be one of @code{"unnorm"}, @code{"sch"}, or @code{"norm"}.
-## The default is @code{"unnorm"}.  The value of @var{n} must be a 
-## non-negative scalar integer.  
+## The default is @code{"unnorm"}.  The value of @var{n} must be a
+## non-negative scalar integer.
 ##
 ## If the optional argument @var{normalization} is missing or is
 ## @code{"unnorm"}, compute the Legendre function of degree @var{n} and
 ## order @var{m} and return all values for @var{m} = 0 @dots{} @var{n}.
 ## The return value has one dimension more than @var{x}.
 ##
 ## The Legendre Function of degree @var{n} and order @var{m}:
 ##
@@ -75,21 +75,21 @@
 ##
 ## @example
 ## @group
 ##  x  |   -1.0   |   -0.9   |  -0.8
 ## ------------------------------------
 ## m=0 | -1.00000 | -0.47250 | -0.08000
 ## m=1 |  0.00000 | -1.99420 | -1.98000
 ## m=2 |  0.00000 | -2.56500 | -4.32000
-## m=3 |  0.00000 | -1.24229 | -3.24000 
+## m=3 |  0.00000 | -1.24229 | -3.24000
 ## @end group
 ## @end example
 ##
-## If the optional argument @code{normalization} is @code{"sch"}, 
+## If the optional argument @code{normalization} is @code{"sch"},
 ## compute the Schmidt semi-normalized associated Legendre function.
 ## The Schmidt semi-normalized associated Legendre function is related
 ## to the unnormalized Legendre functions by the following:
 ##
 ## For Legendre functions of degree n and order 0:
 ##
 ## @tex
 ## $$
@@ -122,17 +122,17 @@
 ##   m       m          m    2(n-m)! 0.5
 ## SP (x) = P (x) * (-1)  * [-------]
 ##   n       n               (n+m)!
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
-## If the optional argument @var{normalization} is @code{"norm"}, 
+## If the optional argument @var{normalization} is @code{"norm"},
 ## compute the fully normalized associated Legendre function.
 ## The fully normalized associated Legendre function is related
 ## to the unnormalized Legendre functions by the following:
 ##
 ## For Legendre functions of degree @var{n} and order @var{m}
 ##
 ## @tex
 ## $$
@@ -140,17 +140,17 @@
 ## $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
 ##   m       m          m    (n+0.5)(n-m)! 0.5
 ## NP (x) = P (x) * (-1)  * [-------------]
-##   n       n                   (n+m)!    
+##   n       n                   (n+m)!
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## @end deftypefn
 
 ## Author: Marco Caliari <marco.caliari@univr.it>
 
@@ -196,17 +196,17 @@ function retval = legendre (n, x, normal
   ##            m                 m              m
   ## (n-m+1) * P (x) = (2*n+1)*x*P (x)  - (n+1)*P (x)
   ##            n+1               n              n-1
   ## http://en.wikipedia.org/wiki/Associated_Legendre_function
 
   overflow = false;
   for m = 1:n
     lpm1 = scale;
-    lpm2 = (2*m-1) .* x .* scale;      
+    lpm2 = (2*m-1) .* x .* scale;
     lpm3 = lpm2;
     for k = m+1:n
       lpm3a = (2*k-1) .* x .* lpm2;
       lpm3b = (k+m-2) .* lpm1;
       lpm3 = (lpm3a - lpm3b)/(k-m+1);
       lpm1 = lpm2;
       lpm2 = lpm3;
       if (! warned_overflow)
diff --git a/scripts/specfun/nchoosek.m b/scripts/specfun/nchoosek.m
--- a/scripts/specfun/nchoosek.m
+++ b/scripts/specfun/nchoosek.m
@@ -39,18 +39,18 @@
 ##  | k |               k!                k! (n-k)!
 ##  \   /
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## If @var{n} is a vector generate all combinations of the elements
-## of @var{n}, taken @var{k} at a time, one row per combination.  The 
-## resulting @var{c} has size @code{[nchoosek (length (@var{n}), 
+## of @var{n}, taken @var{k} at a time, one row per combination.  The
+## resulting @var{c} has size @code{[nchoosek (length (@var{n}),
 ## @var{k}), @var{k}]}.
 ##
 ## @code{nchoosek} works only for non-negative integer arguments; use
 ## @code{bincoeff} for non-integer scalar arguments and for using vector
 ## arguments to compute many coefficients at once.
 ##
 ## @seealso{bincoeff}
 ## @end deftypefn
diff --git a/scripts/specfun/nthroot.m b/scripts/specfun/nthroot.m
--- a/scripts/specfun/nthroot.m
+++ b/scripts/specfun/nthroot.m
@@ -17,29 +17,29 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 ##
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} nthroot (@var{x}, @var{n})
-## 
-## Compute the n-th root of @var{x}, returning real results for real 
+##
+## Compute the n-th root of @var{x}, returning real results for real
 ## components of @var{x}.  For example:
 ##
 ## @example
 ## @group
 ## nthroot (-1, 3)
 ## @result{} -1
 ## (-1) ^ (1 / 3)
 ## @result{} 0.50000 - 0.86603i
 ## @end group
 ## @end example
-## 
+##
 ## @var{n} must be a scalar.  If @var{n} is not an even integer and @var{X} has
 ## negative entries, an error is produced.
 ## @seealso{realsqrt, sqrt, cbrt}
 ## @end deftypefn
 
 function y = nthroot (x, n)
 
   if (nargin != 2)
diff --git a/scripts/specfun/primes.m b/scripts/specfun/primes.m
--- a/scripts/specfun/primes.m
+++ b/scripts/specfun/primes.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} primes (@var{n})
 ##
-## Return all primes up to @var{n}.  
+## Return all primes up to @var{n}.
 ##
 ## The algorithm used is the Sieve of Eratosthenes.
 ##
 ## Note that if you need a specific number of primes you can use the
 ## fact that the distance from one prime to the next is, on average,
 ## proportional to the logarithm of the prime.  Integrating, one finds
 ## that there are about @math{k} primes less than
 ## @tex
diff --git a/scripts/specfun/reallog.m b/scripts/specfun/reallog.m
--- a/scripts/specfun/reallog.m
+++ b/scripts/specfun/reallog.m
@@ -13,27 +13,27 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} reallog (@var{x})
-## Return the real-valued natural logarithm of each element of @var{x}.  Report 
+## Return the real-valued natural logarithm of each element of @var{x}.  Report
 ## an error if any element results in a complex return value.
 ## @seealso{log, realpow, realsqrt}
 ## @end deftypefn
 
 function y = reallog (x)
   if (nargin != 1)
     print_usage ();
   elseif (iscomplex (x) || any (x(:) < 0))
     error ("reallog: produced complex result");
-  else    
+  else
     y = log (x);
   endif
 endfunction
 
 %!assert (log(1:5),reallog(1:5))
 %!test
 %! x = rand (10,10);
 %! assert (log(x),reallog(x))
diff --git a/scripts/specfun/realpow.m b/scripts/specfun/realpow.m
--- a/scripts/specfun/realpow.m
+++ b/scripts/specfun/realpow.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} realpow (@var{x}, @var{y})
-## Compute the real-valued, element-by-element power operator.  This is 
+## Compute the real-valued, element-by-element power operator.  This is
 ## equivalent to @w{@code{@var{x} .^ @var{y}}}, except that @code{realpow}
 ## reports an error if any return value is complex.
 ## @seealso{reallog, realsqrt}
 ## @end deftypefn
 
 function z = realpow (x, y)
   if (nargin != 2)
     print_usage ();
diff --git a/scripts/specfun/realsqrt.m b/scripts/specfun/realsqrt.m
--- a/scripts/specfun/realsqrt.m
+++ b/scripts/specfun/realsqrt.m
@@ -23,17 +23,17 @@
 ## @seealso{sqrt, realpow, reallog}
 ## @end deftypefn
 
 function y = realsqrt (x)
   if (nargin != 1)
     print_usage ();
   elseif (iscomplex (x) || any (x(:) < 0))
     error ("realsqrt: produced complex result");
-  else    
+  else
     y = sqrt (x);
   endif
 endfunction
 
 %!assert (sqrt(1:5),realsqrt(1:5))
 %!test
 %! x = rand (10,10);
 %! assert (sqrt(x),realsqrt(x))
diff --git a/scripts/special-matrix/hadamard.m b/scripts/special-matrix/hadamard.m
--- a/scripts/special-matrix/hadamard.m
+++ b/scripts/special-matrix/hadamard.m
@@ -16,26 +16,26 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 ##
 ## Original version by Paul Kienzle distributed as free software in the
 ## public domain.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} hadamard (@var{n})
-## Construct a Hadamard matrix @var{Hn} of size @var{n}-by-@var{n}.  The 
+## Construct a Hadamard matrix @var{Hn} of size @var{n}-by-@var{n}.  The
 ## size @var{n} must be of the form @code{2 ^ @var{k} * @var{p}} in which
 ## @var{p} is one of 1, 12, 20 or 28.  The returned matrix is normalized,
 ## meaning @code{Hn(:,1) == 1} and @code{Hn(1,:) == 1}.
 ##
 ## Some of the properties of Hadamard matrices are:
 ##
 ## @itemize @bullet
 ## @item
-## @code{kron (@var{Hm}, @var{Hn})} is a Hadamard matrix of size 
+## @code{kron (@var{Hm}, @var{Hn})} is a Hadamard matrix of size
 ## @var{m}-by-@var{n}.
 ##
 ## @item
 ## @code{Hn * Hn' == @var{n} * eye (@var{n})}.
 ##
 ## @item
 ## The rows of @var{Hn} are orthogonal.
 ##
@@ -44,42 +44,42 @@
 ## @code{abs (@var{A} (@var{i}, @var{j})) <= 1}.
 ##
 ## @item
 ## Multiply any row or column by -1 and still have a Hadamard matrix.
 ## @end itemize
 ##
 ## @end deftypefn
 
-   
+
 ## Reference [1] contains a list of Hadamard matrices up to n=256.
 ## See code for h28 in hadamard.m for an example of how to extend
 ## this function for additional p.
 ##
 ## References:
-## [1] A Library of Hadamard Matrices, N. J. A. Sloane 
+## [1] A Library of Hadamard Matrices, N. J. A. Sloane
 ##     http://www.research.att.com/~njas/hadamard/
 
 function h = hadamard (n)
-  
+
   if (nargin != 1)
     print_usage ();
   endif
 
   ## Find k if n = 2^k*p.
   k = 0;
   while (n > 1 && floor (n/2) == n/2)
-    k++; 
-    n = n/2; 
+    k++;
+    n = n/2;
   endwhile
-  
+
   ## Find base hadamard.
   ## Except for n=2^k, need a multiple of 4.
   if (n != 1)
-    k -= 2; 
+    k -= 2;
   endif
 
   ## Trigger error if not a multiple of 4.
   if (k < 0)
     n =- 1;
   endif
 
   switch (n)
@@ -94,21 +94,21 @@ function h = hadamard (n)
     otherwise
       error ("hadamard: N must be 2^k*p, for p = 1, 12, 20 or 28");
   endswitch
 
   ## Build H(2^k*n) from kron(H(2^k),H(n)).
   h2 = [1,1;1,-1];
   while (true)
     if (floor (k/2) != k/2)
-      h = kron (h2, h); 
+      h = kron (h2, h);
     endif
     k = floor (k/2);
-    if (k == 0) 
-      break; 
+    if (k == 0)
+      break;
     endif
     h2 = kron (h2, h2);
   endwhile
 endfunction
 
 function h = h12 ()
   tu = [-1,+1,-1,+1,+1,+1,-1,-1,-1,+1,-1];
   tl = [-1,-1,+1,-1,-1,-1,+1,+1,+1,-1,+1];
diff --git a/scripts/special-matrix/invhilb.m b/scripts/special-matrix/invhilb.m
--- a/scripts/special-matrix/invhilb.m
+++ b/scripts/special-matrix/invhilb.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} invhilb (@var{n})
-## Return the inverse of the Hilbert matrix of order @var{n}.  This can be 
+## Return the inverse of the Hilbert matrix of order @var{n}.  This can be
 ## computed exactly using
 ## @tex
 ## $$\eqalign{
 ##   A_{ij} &= -1^{i+j} (i+j-1)
 ##              \left( \matrix{n+i-1 \cr n-j } \right)
 ##              \left( \matrix{n+j-1 \cr n-i } \right)
 ##              \left( \matrix{i+j-2 \cr i-2 } \right)^2 \cr
 ##          &= { p(i)p(j) \over (i+j-1) }
@@ -55,19 +55,19 @@
 ## @group
 ##              k  /k+n-1\   /n\
 ##     p(k) = -1  (       ) (   )
 ##                 \ k-1 /   \k/
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
-## The validity of this formula can easily be checked by expanding 
-## the binomial coefficients in both formulas as factorials.  It can 
-## be derived more directly via the theory of Cauchy matrices. 
+## The validity of this formula can easily be checked by expanding
+## the binomial coefficients in both formulas as factorials.  It can
+## be derived more directly via the theory of Cauchy matrices.
 ## See J. W. Demmel, @cite{Applied Numerical Linear Algebra}, p. 92.
 ##
 ## Compare this with the numerical calculation of @code{inverse (hilb (n))},
 ## which suffers from the ill-conditioning of the Hilbert matrix, and the
 ## finite precision of your computer's floating point arithmetic.
 ## @seealso{hilb, hankel, vander, sylvester_matrix, toeplitz}
 ## @end deftypefn
 
@@ -78,31 +78,31 @@ function retval = invhilb (n)
   if (nargin != 1)
     print_usage ();
   endif
 
   nmax = length (n);
   if (nmax == 1)
 
     ## The point about the second formula above is that when vectorized,
-    ## p(k) is evaluated for k=1:n which involves O(n) calls to bincoeff 
+    ## p(k) is evaluated for k=1:n which involves O(n) calls to bincoeff
     ## instead of O(n^2).
     ##
     ## We evaluate the expression as (-1)^(i+j)*(p(i)*p(j))/(i+j-1) except
     ## when p(i)*p(j) would overflow.  In cases where p(i)*p(j) is an exact
     ## machine number, the result is also exact.  Otherwise we calculate
     ## (-1)^(i+j)*p(i)*(p(j)/(i+j-1)).
     ##
     ## The Octave bincoeff routine uses transcendental functions (gammaln
-    ## and exp) rather than multiplications, for the sake of speed.  
-    ## However, it rounds the answer to the nearest integer, which 
+    ## and exp) rather than multiplications, for the sake of speed.
+    ## However, it rounds the answer to the nearest integer, which
     ## justifies the claim about exactness made above.
 
-    retval = zeros (n); 
-    k = [1:n]; 
+    retval = zeros (n);
+    k = [1:n];
     p = k .* bincoeff (k+n-1, k-1) .* bincoeff (n, k);
     p(2:2:n) = -p(2:2:n);
     if (n < 203)
       for l = 1:n
         retval(l,:) = (p(l) * p) ./ [l:l+n-1];
       endfor
     else
       for l = 1:n
@@ -115,17 +115,17 @@ function retval = invhilb (n)
 
 endfunction
 
 %!test
 %! result4 = [16, -120, 240, -140;
 %! -120, 1200, -2700, 1680;
 %! 240, -2700, 6480, -4200;
 %! -140, 1680, -4200, 2800];
-%! 
+%!
 %! assert((invhilb (1) == 1 && invhilb (2) == [4, -6; -6, 12]
 %! && invhilb (4) == result4
 %! && abs (invhilb (7) * hilb (7) - eye (7)) < sqrt (eps)));
 
 %!error invhilb ([1, 2]);
 
 %!error invhilb ();
 
diff --git a/scripts/special-matrix/magic.m b/scripts/special-matrix/magic.m
--- a/scripts/special-matrix/magic.m
+++ b/scripts/special-matrix/magic.m
@@ -66,17 +66,17 @@ function A = magic(n)
       I = 1:m;
       J = [2:k, n-k+2:n];
       A([I,I+m],J) = A([I+m,I],J);
     endif
     I = [1:k, k+2:m];
     A([I,I+m],1) = A([I+m,I],1);
     I = k + 1;
     A([I,I+m],I) = A([I+m,I],I);
-  
+
   endif
 
 endfunction
 
 %!test
 %! for i=3:30
 %!   A=magic(i);
 %!   assert(norm(diff([sum(diag(A)),sum(diag(flipud(A))),sum(A),sum(A')])),0)
diff --git a/scripts/special-matrix/pascal.m b/scripts/special-matrix/pascal.m
--- a/scripts/special-matrix/pascal.m
+++ b/scripts/special-matrix/pascal.m
@@ -16,17 +16,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} pascal (@var{n})
 ## @deftypefnx {Function File} {} pascal (@var{n}, @var{t})
 ## Return the Pascal matrix of order @var{n} if @code{@var{t} = 0}.
-## @var{t} defaults to 0.  Return lower triangular Cholesky factor of 
+## @var{t} defaults to 0.  Return lower triangular Cholesky factor of
 ## the Pascal matrix if @code{@var{t} = 1}.  This matrix is its own
 ## inverse, that is @code{pascal (@var{n}, 1) ^ 2 == eye (@var{n})}.
 ## If @code{@var{t} = -1}, return its absolute value.  This is the
 ## standard Pascal triangle as a lower-triangular matrix.
 ## If @code{@var{t} = 2}, return a transposed and permuted version of
 ## @code{pascal (@var{n}, 1)}, which is the cube-root of the identity
 ## matrix.  That is @code{pascal (@var{n}, 2) ^ 3 == eye (@var{n})}.
 ##
diff --git a/scripts/special-matrix/toeplitz.m b/scripts/special-matrix/toeplitz.m
--- a/scripts/special-matrix/toeplitz.m
+++ b/scripts/special-matrix/toeplitz.m
@@ -97,17 +97,17 @@ function retval = toeplitz (c, r)
     ridx = find(r);
 
     ## Ignore the first element in r.
     ridx = ridx(ridx > 1);
 
     ## Form matrix.
     retval = spdiags(repmat(c(cidx),nr,1),1-cidx,nr,nc)+...
         spdiags(repmat(r(ridx),nr,1),ridx-1,nr,nc);
-  else  
+  else
     ## Concatenate data into a single column vector.
     data = [r(end:-1:2)(:); c(:)];
 
     ## Get slices.
     slices = cellslices (data, nc:-1:1, nc+nr-1:-1:nr);
 
     ## Form matrix.
     retval = horzcat (slices{:});
diff --git a/scripts/startup/__finish__.m b/scripts/startup/__finish__.m
--- a/scripts/startup/__finish__.m
+++ b/scripts/startup/__finish__.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} __finish__ ()
 ## Undocumented internal function.
 ## @end deftypefn
 
-## Check for the existence of the function/script, @file{finish}, in the 
+## Check for the existence of the function/script, @file{finish}, in the
 ## path or current working directory and execute it.  This function is
 ## intended to be excecuted upon a clean exit form Octave.  This is
 ## accomplished in the system script @file{startup/octaverc} by use of
 ## the built-in function @code{onexit}.
 
 function __finish__ ()
 
   if (exist ("finish", "file"))
diff --git a/scripts/statistics/base/cov.m b/scripts/statistics/base/cov.m
--- a/scripts/statistics/base/cov.m
+++ b/scripts/statistics/base/cov.m
@@ -39,17 +39,17 @@
 ## cov (x) = 1/N-1 * SUM_i (x(i) - mean(x)) * (y(i) - mean(y))
 ## @end example
 ##
 ## @end ifnottex
 ##
 ## If called with one argument, compute @code{cov (@var{x}, @var{x})}, the
 ## covariance between the columns of @var{x}.
 ##
-## The argument @var{opt} determines the type of normalization to use.  
+## The argument @var{opt} determines the type of normalization to use.
 ## Valid values are
 ##
 ## @table @asis
 ## @item 0:
 ##   normalize with @math{N-1}, provides the best unbiased estimator of the
 ## covariance [default]
 ##
 ## @item 1:
@@ -87,17 +87,17 @@ function c = cov (x, y = [], opt = 0)
     c = 0;
     return;
   endif
 
   if (rows (x) == 1)
     x = x';
   endif
   n = rows (x);
-  
+
   if (nargin == 1 || isscalar(y))
     x = center (x, 1);
     c = conj (x' * x / (n - 1 + opt));
   else
     if (rows (y) == 1)
       y = y';
     endif
     if (rows (y) != n)
diff --git a/scripts/statistics/base/histc.m b/scripts/statistics/base/histc.m
--- a/scripts/statistics/base/histc.m
+++ b/scripts/statistics/base/histc.m
@@ -80,41 +80,41 @@ function [n, idx] = histc (x, edges, dim
     if (!(isscalar (dim) && dim == fix (dim))
         || !(1 <= dim && dim <= nd))
       error ("histc: DIM must be an integer and a valid dimension");
     endif
   endif
 
   nsz = sz;
   nsz(dim) = num_edges;
-  
+
   ## the splitting point is 3 bins
 
   if (num_edges <= 3)
 
     ## This is the O(M*N) algorithm.
 
     ## Allocate the histogram
     n = zeros (nsz);
 
     ## Allocate 'idx'
     if (nargout > 1)
       idx = zeros (sz);
     endif
-    
+
     ## Prepare indices
     idx1 = cell (1, dim-1);
     for k = 1:length (idx1)
       idx1 {k} = 1:sz(k);
     endfor
     idx2 = cell (length (sz) - dim);
     for k = 1:length (idx2)
       idx2 {k} = 1:sz(k+dim);
     endfor
-    
+
     ## Compute the histograms
     for k = 1:num_edges-1
       b = (edges (k) <= x & x < edges (k+1));
       n (idx1 {:}, k, idx2 {:}) = sum (b, dim);
       if (nargout > 1)
         idx (b) = k;
       endif
     endfor
@@ -125,17 +125,17 @@ function [n, idx] = histc (x, edges, dim
     endif
 
   else
 
     ## This is the O(M*log(N) + N) algorithm.
 
     ## Look-up indices.
     idx = lookup (edges, x);
-    ## Zero invalid ones (including NaNs). x < edges(1) are already zero. 
+    ## Zero invalid ones (including NaNs). x < edges(1) are already zero.
     idx(! (x <= edges(end))) = 0;
 
     iidx = idx;
 
     ## In case of matrix input, we adjust the indices.
     if (! isvector (x))
       nl = prod (sz(1:dim-1));
       nn = sz(dim);
diff --git a/scripts/statistics/base/iqr.m b/scripts/statistics/base/iqr.m
--- a/scripts/statistics/base/iqr.m
+++ b/scripts/statistics/base/iqr.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} iqr (@var{x})
 ## @deftypefnx {Function File} {} iqr (@var{x}, @var{dim})
 ## Return the interquartile range, i.e., the difference between the upper
 ## and lower quartile of the input data.  If @var{x} is a matrix, do the
-## above for first non-singleton dimension of @var{x}.  
+## above for first non-singleton dimension of @var{x}.
 ##
 ## If the optional argument @var{dim} is given, operate along this dimension.
 ##
 ## As a measure of dispersion, the interquartile range is less affected by
 ## outliers than either @code{range} or @code{std}.
 ## @seealso{range, std}
 ## @end deftypefn
 
@@ -54,17 +54,17 @@ function y = iqr (x, dim)
     endif
   else
     if (!(isscalar (dim) && dim == fix (dim))
         || !(1 <= dim && dim <= nd))
       error ("iqr: DIM must be an integer and a valid dimension");
     endif
   endif
 
-  ## This code is a bit heavy, but is needed until empirical_inv 
+  ## This code is a bit heavy, but is needed until empirical_inv
   ## takes other than vector arguments.
   c = sz(dim);
   sz(dim) = 1;
   y = zeros (sz);
   stride = prod (sz(1:dim-1));
   for i = 1 : nel / c;
     offset = i;
     offset2 = 0;
diff --git a/scripts/statistics/base/kendall.m b/scripts/statistics/base/kendall.m
--- a/scripts/statistics/base/kendall.m
+++ b/scripts/statistics/base/kendall.m
@@ -29,17 +29,17 @@
 ##
 ## @tex
 ## $$ \tau = {1 \over n(n-1)} \sum_{i,j} {\rm sign}(q_i-q_j) {\rm sign}(r_i-r_j) $$
 ## @end tex
 ## @ifnottex
 ##
 ## @example
 ## @group
-##          1    
+##          1
 ## tau = -------   SUM sign (q(i) - q(j)) * sign (r(i) - r(j))
 ##       n (n-1)   i,j
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## @noindent
 ## in which the
@@ -54,17 +54,17 @@
 ## If @var{x} and @var{y} are drawn from independent distributions,
 ## Kendall's @var{tau} is asymptotically normal with mean 0 and variance
 ## @tex
 ## ${2 (2n+5) \over 9n(n-1)}$.
 ## @end tex
 ## @ifnottex
 ## @code{(2 * (2@var{n}+5)) / (9 * @var{n} * (@var{n}-1))}.
 ## @end ifnottex
-## 
+##
 ## @code{kendall (@var{x})} is equivalent to @code{kendall (@var{x},
 ## @var{x})}.
 ## @seealso{ranks, spearman}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Kendall's rank correlation tau
 
diff --git a/scripts/statistics/base/kurtosis.m b/scripts/statistics/base/kurtosis.m
--- a/scripts/statistics/base/kurtosis.m
+++ b/scripts/statistics/base/kurtosis.m
@@ -31,19 +31,19 @@
 ## @example
 ## kurtosis (x) = N^(-1) std(x)^(-4) sum ((x - mean(x)).^4) - 3
 ## @end example
 ##
 ## @end ifnottex
 ## If @var{x} is a matrix, return the kurtosis over the
 ## first non-singleton dimension of the matrix.  If the optional
 ## @var{dim} argument is given, operate along this dimension.
-## 
+##
 ## Note: The definition of kurtosis above yields a kurtosis of zero for the
-## stdnormal distribution and is sometimes referred to as "excess kurtosis".  
+## stdnormal distribution and is sometimes referred to as "excess kurtosis".
 ## To calculate kurtosis without the normalization factor of @math{-3} use
 ## @code{moment (@var{x}, 4, 'c') / std (@var{x})^4}.
 ## @seealso{var,skewness,moment}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Created: 29 July 1994
 ## Adapted-By: jwe
@@ -67,17 +67,17 @@ function retval = kurtosis (x, dim)
       dim = 1;
     endif
   else
     if (!(isscalar (dim) && dim == fix (dim))
         || !(1 <= dim && dim <= nd))
       error ("kurtosis: DIM must be an integer and a valid dimension");
     endif
   endif
-  
+
   c = sz(dim);
   sz(dim) = 1;
   idx = ones (1, nd);
   idx(dim) = c;
   x = x - repmat (mean (x, dim), idx);
   retval = zeros (sz, class (x));
   s = std (x, [], dim);
   x = sum (x.^4, dim);
diff --git a/scripts/statistics/base/mean.m b/scripts/statistics/base/mean.m
--- a/scripts/statistics/base/mean.m
+++ b/scripts/statistics/base/mean.m
@@ -108,17 +108,17 @@ function y = mean (x, opt1, opt2)
 
   if (!(isscalar (dim) && dim == fix (dim))
       || !(1 <= dim && dim <= nd))
     error ("mean: DIM must be an integer and a valid dimension");
   endif
 
   if (dim > nd)
     n = 1;
-  else 
+  else
     n = sz(dim);
   endif
 
   if (strcmp (opt, "a"))
     y = sum (x, dim) / n;
   elseif (strcmp (opt, "g"))
     y = prod (x, dim) .^ (1/n);
   elseif (strcmp (opt, "h"))
diff --git a/scripts/statistics/base/meansq.m b/scripts/statistics/base/meansq.m
--- a/scripts/statistics/base/meansq.m
+++ b/scripts/statistics/base/meansq.m
@@ -32,17 +32,17 @@
 ## @example
 ## @group
 ## std (x) = 1/N SUM_i x(i)^2
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## For matrix arguments, return a row vector containing the mean square
-## of each column. 
+## of each column.
 ##
 ## If the optional argument @var{dim} is given, operate along this dimension.
 ## @seealso{var,std,moment}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compute mean square
 
@@ -52,17 +52,17 @@ function y = meansq (x, dim)
     print_usage ();
   endif
 
   if (!isnumeric (x))
     error ("mean: X must be a numeric vector or matrix");
   endif
 
   nd = ndims (x);
-  sz = size (x); 
+  sz = size (x);
   if (nargin < 2)
     ## Find the first non-singleton dimension.
     dim = find (sz > 1, 1);
     if (isempty (dim))
       dim = 1;
     endif
   endif
 
diff --git a/scripts/statistics/base/median.m b/scripts/statistics/base/median.m
--- a/scripts/statistics/base/median.m
+++ b/scripts/statistics/base/median.m
@@ -90,17 +90,17 @@ function retval = median (x, dim)
 
 endfunction
 
 %!test
 %! x = [1, 2, 3, 4, 5, 6];
 %! x2 = x';
 %! y = [1, 2, 3, 4, 5, 6, 7];
 %! y2 = y';
-%! 
+%!
 %! assert(median (x) == median (x2) && median (x) == 3.5);
 %! assert(median (y) == median (y2) && median (y) == 4);
 %! assert(median ([x2, 2*x2]) == [3.5, 7]);
 %! assert(median ([y2, 3*y2]) == [4, 12]);
 
 %!assert(median ([1,2,NaN;4,5,6;NaN,8,9]), [NaN, 5, NaN]);
 
 %% Test input validation
diff --git a/scripts/statistics/base/mode.m b/scripts/statistics/base/mode.m
--- a/scripts/statistics/base/mode.m
+++ b/scripts/statistics/base/mode.m
@@ -15,21 +15,21 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} mode (@var{x})
 ## @deftypefnx {Function File} {} mode (@var{x}, @var{dim})
 ## @deftypefnx {Function File} {[@var{m}, @var{f}, @var{c}] =} mode (@dots{})
-## Compute the most frequently occurring value in a dataset (mode).  
+## Compute the most frequently occurring value in a dataset (mode).
 ## @code{mode} determines the frequency of values along the first non-singleton
-## dimension and returns the value with the highest frequency.  If two, or 
+## dimension and returns the value with the highest frequency.  If two, or
 ## more, values have the same frequency @code{mode} returns the smallest.
-## 
+##
 ## If the optional argument @var{dim} is given, operate along this dimension.
 ##
 ## The return variable @var{f} is the number of occurrences of the mode in
 ## in the dataset.  The cell array @var{c} contains all of the elements
 ## with the maximum frequency.
 ## @seealso{mean,median}
 ## @end deftypefn
 
diff --git a/scripts/statistics/base/moment.m b/scripts/statistics/base/moment.m
--- a/scripts/statistics/base/moment.m
+++ b/scripts/statistics/base/moment.m
@@ -151,17 +151,17 @@ function m = moment (x, p, opt1, opt2)
   sz = size (x);
   if (need_dim)
     ## Find the first non-singleton dimension.
     dim = find (sz > 1, 1);
     if (isempty (dim))
       dim = 1;
     endif
   else
-    if (!(isscalar (dim) && dim == fix (dim)) || 
+    if (!(isscalar (dim) && dim == fix (dim)) ||
         !(1 <= dim && dim <= nd))
       error ("moment: DIM must be an integer and a valid dimension");
     endif
   endif
 
   n = sz(dim);
 
   if any (type == "c")
diff --git a/scripts/statistics/base/ols.m b/scripts/statistics/base/ols.m
--- a/scripts/statistics/base/ols.m
+++ b/scripts/statistics/base/ols.m
@@ -51,17 +51,17 @@
 ## @tex
 ## $beta$ is calculated directly via $(x^Tx)^{-1} x^T y$ if the matrix $x^Tx$ is
 ## of full rank.
 ## @end tex
 ## @ifnottex
 ## @var{beta} is calculated directly via @code{inv (x'*x) * x' * y} if the
 ## matrix @code{x'*x} is of full rank.
 ## @end ifnottex
-## Otherwise, @code{@var{beta} = pinv (@var{x}) * @var{y}} where 
+## Otherwise, @code{@var{beta} = pinv (@var{x}) * @var{y}} where
 ## @code{pinv (@var{x})} denotes the pseudoinverse of @var{x}.
 ##
 ## @item sigma
 ## The OLS estimator for the matrix @var{s},
 ##
 ## @example
 ## @group
 ## @var{sigma} = (@var{y}-@var{x}*@var{beta})'
diff --git a/scripts/statistics/base/prctile.m b/scripts/statistics/base/prctile.m
--- a/scripts/statistics/base/prctile.m
+++ b/scripts/statistics/base/prctile.m
@@ -17,25 +17,25 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {@var{y} =} prctile (@var{x}, @var{p})
 ## @deftypefnx {Function File} {@var{q} =} prctile (@var{x}, @var{p}, @var{dim})
 ## For a sample @var{x}, compute the quantiles, @var{y}, corresponding
 ## to the cumulative probability values, @var{p}, in percent.  All non-numeric
 ## values (NaNs) of @var{x} are ignored.
-## 
+##
 ## If @var{x} is a matrix, compute the percentiles for each column and
-## return them in a matrix, such that the i-th row of @var{y} contains the 
+## return them in a matrix, such that the i-th row of @var{y} contains the
 ## @var{p}(i)th percentiles of each column of @var{x}.
-## 
+##
 ## The optional argument @var{dim} determines the dimension along which
 ## the percentiles are calculated.  If @var{dim} is omitted, and @var{x} is
 ## a vector or matrix, it defaults to 1 (column-wise quantiles).  When
-## @var{x} is an N-d array, @var{dim} defaults to the first non-singleton 
+## @var{x} is an N-d array, @var{dim} defaults to the first non-singleton
 ## dimension.
 ## @seealso{quantile}
 ## @end deftypefn
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Description: Matlab style prctile function.
 
 function q = prctile (x, p, dim)
@@ -55,25 +55,25 @@ function q = prctile (x, p, dim)
     p = [0, 25, 50, 75, 100];
   endif
 
   nd = ndims (x);
   if (nargin == 2)
     if (nd == 2)
       ## If a matrix or vector, use the 1st dimension.
       dim = 1;
-    else 
+    else
       ## If an N-d array, find the first non-singleton dimension.
       dim = find (size(v) > 1, 1);
       if (isempty (dim))
         dim = 1;
       endif
     endif
   else
-    if (!(isscalar (dim) && dim == fix (dim)) || 
+    if (!(isscalar (dim) && dim == fix (dim)) ||
         !(1 <= dim && dim <= nd))
       error ("prctile: DIM must be an integer and a valid dimension");
     endif
   endif
 
   ## Convert from percent to decimal.
   p = p / 100;
 
diff --git a/scripts/statistics/base/qqplot.m b/scripts/statistics/base/qqplot.m
--- a/scripts/statistics/base/qqplot.m
+++ b/scripts/statistics/base/qqplot.m
@@ -77,20 +77,20 @@ function [q, s] = qqplot (x, dist, varar
   t = ((1 : n)' - .5) / n;
   if (nargin <= 2)
     q = feval (f, t);
     q_label = func2str (f);
   else
     q = feval (f, t, varargin{:});
     if (nargin > 3)
       tmp = sprintf (", %g", varargin{2:end});
-    else 
+    else
       tmp = "";
     endif
-    q_label = sprintf ("%s with parameter(s) %g%s", 
+    q_label = sprintf ("%s with parameter(s) %g%s",
                         func2str (f),        varargin{1}, tmp);
   endif
 
   if (nargout == 0)
     plot (q, s);
     xlabel (q_label);
     ylabel ("sample points");
   endif
diff --git a/scripts/statistics/base/quantile.m b/scripts/statistics/base/quantile.m
--- a/scripts/statistics/base/quantile.m
+++ b/scripts/statistics/base/quantile.m
@@ -1,10 +1,10 @@
 ## Copyright (C) 2008-2011 Ben Abbott and Jaroslav Hajek
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
 ## the Free Software Foundation; either version 3 of the License, or (at
 ## your option) any later version.
 ##
 ## Octave is distributed in the hope that it will be useful, but
@@ -22,66 +22,66 @@
 ## @deftypefnx {Function File} {@var{q} =} quantile (@var{x}, @var{p}, @var{dim}, @var{method})
 ## For a sample, @var{x}, calculate the quantiles, @var{q}, corresponding to
 ## the cumulative probability values in @var{p}.  All non-numeric values (NaNs)
 ## of @var{x} are ignored.
 ##
 ## If @var{x} is a matrix, compute the quantiles for each column and
 ## return them in a matrix, such that the i-th row of @var{q} contains
 ## the @var{p}(i)th quantiles of each column of @var{x}.
-## 
-## The optional argument @var{dim} determines the dimension along which 
+##
+## The optional argument @var{dim} determines the dimension along which
 ## the quantiles are calculated.  If @var{dim} is omitted, and @var{x} is
-## a vector or matrix, it defaults to 1 (column-wise quantiles).  If 
-## @var{x} is an N-d array, @var{dim} defaults to the first non-singleton 
+## a vector or matrix, it defaults to 1 (column-wise quantiles).  If
+## @var{x} is an N-d array, @var{dim} defaults to the first non-singleton
 ## dimension.
-## 
+##
 ## The methods available to calculate sample quantiles are the nine methods
 ## used by R (http://www.r-project.org/).  The default value is METHOD = 5.
-## 
+##
 ## Discontinuous sample quantile methods 1, 2, and 3
-## 
+##
 ## @enumerate 1
 ## @item Method 1: Inverse of empirical distribution function.
 ##
 ## @item Method 2: Similar to method 1 but with averaging at discontinuities.
 ##
 ## @item Method 3: SAS definition: nearest even order statistic.
 ## @end enumerate
-## 
+##
 ## Continuous sample quantile methods 4 through 9, where p(k) is the linear
 ## interpolation function respecting each methods' representative cdf.
-## 
+##
 ## @enumerate 4
 ## @item Method 4: p(k) = k / n. That is, linear interpolation of the
 ## empirical cdf.
 ##
-## @item Method 5: p(k) = (k - 0.5) / n. That is a piecewise linear function 
-## where the knots are the values midway through the steps of the empirical 
-## cdf. 
+## @item Method 5: p(k) = (k - 0.5) / n. That is a piecewise linear function
+## where the knots are the values midway through the steps of the empirical
+## cdf.
 ##
 ## @item Method 6: p(k) = k / (n + 1).
 ##
 ## @item Method 7: p(k) = (k - 1) / (n - 1).
 ##
-## @item Method 8: p(k) = (k - 1/3) / (n + 1/3).  The resulting quantile 
-## estimates are approximately median-unbiased regardless of the distribution 
+## @item Method 8: p(k) = (k - 1/3) / (n + 1/3).  The resulting quantile
+## estimates are approximately median-unbiased regardless of the distribution
 ## of @var{x}.
 ##
-## @item Method 9: p(k) = (k - 3/8) / (n + 1/4).  The resulting quantile 
-## estimates are approximately unbiased for the expected order statistics if 
+## @item Method 9: p(k) = (k - 3/8) / (n + 1/4).  The resulting quantile
+## estimates are approximately unbiased for the expected order statistics if
 ## @var{x} is normally distributed.
 ## @end enumerate
-## 
+##
 ## Hyndman and Fan (1996) recommend method 8.  Maxima, S, and R
 ## (versions prior to 2.0.0) use 7 as their default.  Minitab and SPSS
 ## use method 6.  @sc{matlab} uses method 5.
-## 
+##
 ## References:
-## 
+##
 ## @itemize @bullet
 ## @item Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988) The New
 ## S Language.  Wadsworth & Brooks/Cole.
 ##
 ## @item Hyndman, R. J. and Fan, Y. (1996) Sample quantiles in
 ## statistical packages, American Statistician, 50, 361--365.
 ##
 ## @item R: A Language and Environment for Statistical Computing;
@@ -98,17 +98,17 @@ function q = quantile (x, p, dim = 1, me
   if (nargin < 1 || nargin > 4)
     print_usage ();
   endif
 
   if (nargin < 2)
     p = [0.00 0.25, 0.50, 0.75, 1.00];
   endif
 
-  if (!(isscalar (dim) && dim == fix (dim)) || 
+  if (!(isscalar (dim) && dim == fix (dim)) ||
       !(1 <= dim && dim <= ndims (x)))
     error ("quantile: DIM must be an integer and a valid dimension");
   endif
 
   ## Set the permutation vector.
   perm = 1:ndims(x);
   perm(1) = dim;
   perm(dim) = 1;
@@ -271,21 +271,21 @@ endfunction
 
 %% Test input validation
 %!error quantile ()
 %!error quantile (1, 2, 3, 4, 5)
 %!error quantile (1, 1, 1.5)
 %!error quantile (1, 1, 0)
 %!error quantile (1, 1, 3)
 
-## For the cumulative probability values in @var{p}, compute the 
+## For the cumulative probability values in @var{p}, compute the
 ## quantiles, @var{q} (the inverse of the cdf), for the sample, @var{x}.
 ##
 ## The optional input, @var{method}, refers to nine methods available in R
-## (http://www.r-project.org/). The default is @var{method} = 7. For more 
+## (http://www.r-project.org/). The default is @var{method} = 7. For more
 ## detail, see `help quantile'.
 ## @seealso{prctile, quantile, statistics}
 
 ## Author: Ben Abbott <bpabbott@mac.com>
 ## Vectorized version: Jaroslav Hajek <highegg@gmail.com>
 ## Description: Quantile function of empirical samples
 
 function inv = __quantile__ (x, p, method = 5)
diff --git a/scripts/statistics/base/ranks.m b/scripts/statistics/base/ranks.m
--- a/scripts/statistics/base/ranks.m
+++ b/scripts/statistics/base/ranks.m
@@ -72,20 +72,20 @@ function y = ranks (x, dim)
     eq_el = find (diff ([xs; infvec]) == 0);
     if (isempty (eq_el))
       [eq_el, y] = sort (xi);
     else
       runs = setdiff (eq_el, eq_el+1);
       len = diff (find (diff ([Inf; eq_el; -Inf]) != 1)) + 1;
       [eq_el, y] = sort (xi);
       for i = 1 : length(runs)
-        y (xi (runs (i) + [0:(len(i)-1)]) + floor (runs (i) ./ sz(1)) 
+        y (xi (runs (i) + [0:(len(i)-1)]) + floor (runs (i) ./ sz(1))
            * sz(1)) = eq_el(runs(i)) + (len(i) - 1) / 2;
       endfor
-    endif  
+    endif
     if (dim != 1)
       y = permute (y, perm);
     endif
   endif
 
 endfunction
 
 
diff --git a/scripts/statistics/base/run_count.m b/scripts/statistics/base/run_count.m
--- a/scripts/statistics/base/run_count.m
+++ b/scripts/statistics/base/run_count.m
@@ -15,18 +15,18 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} run_count (@var{x}, @var{n})
 ## @deftypefnx {Function File} {} run_count (@var{x}, @var{n}, @var{dim})
 ## Count the upward runs along the first non-singleton dimension of
-## @var{x} of length 1, 2, @dots{}, @var{n}-1 and greater than or equal 
-## to @var{n}.  
+## @var{x} of length 1, 2, @dots{}, @var{n}-1 and greater than or equal
+## to @var{n}.
 ##
 ## If the optional argument @var{dim} is given then operate
 ## along this dimension.
 ## @end deftypefn
 
 ## Author: FL <Friedrich.Leisch@ci.tuwien.ac.at>
 ## Description: Count upward runs
 
@@ -38,17 +38,17 @@ function retval = run_count (x, n, dim)
 
   if (!isnumeric(x))
     error ("run_count: X must be a numeric vector or matrix");
   endif
 
   if (!(isscalar (n) && n == fix (n) && n > 0))
     error ("run_count: N must be a positive integer");
   endif
-  
+
   nd = ndims (x);
   sz = size (x);
   if (nargin != 3)
     ## Find the first non-singleton dimension.
     dim = find (sz > 1, 1);
     if (isempty (dim))
       dim = 1;
     endif
@@ -66,17 +66,17 @@ function retval = run_count (x, n, dim)
     x = permute (x, perm);
   endif
 
   sz = size (x);
   idx = cell ();
   for i = 1 : nd
     idx{i} = 1 : sz(i);
   endfor
-  c = sz(1); 
+  c = sz(1);
   tmp = zeros ([c + 1, sz(2 : end)]);
   infvec = Inf ([1, sz(2 : end)]);
 
   ind = find (diff ([infvec; x; -infvec]) < 0);
   tmp(ind(2:end) - 1) = diff(ind);
   tmp = tmp(idx{:});
 
   sz(1) = n;
diff --git a/scripts/statistics/base/skewness.m b/scripts/statistics/base/skewness.m
--- a/scripts/statistics/base/skewness.m
+++ b/scripts/statistics/base/skewness.m
@@ -75,17 +75,17 @@ function retval = skewness (x, dim)
   idx(dim) = c;
   x = x - repmat (mean (x, dim), idx);
   sz(dim) = 1;
   retval = zeros (sz, class (x));
   s = std (x, [], dim);
   ind = find (s > 0);
   x = sum (x .^ 3, dim);
   retval(ind) = x(ind) ./ (c * s(ind) .^ 3);
-  
+
 endfunction
 
 %!assert(skewness ([-1,0,1]), 0);
 %!assert(skewness ([-2,0,1]) < 0);
 %!assert(skewness ([-1,0,2]) > 0);
 %!assert(skewness ([-3,0,1]) == -1*skewness([-1,0,3]));
 %!test
 %! x = [0; 0; 0; 1];
diff --git a/scripts/statistics/base/statistics.m b/scripts/statistics/base/statistics.m
--- a/scripts/statistics/base/statistics.m
+++ b/scripts/statistics/base/statistics.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} statistics (@var{x})
 ## @deftypefnx {Function File} {} statistics (@var{x}, @var{dim})
 ## Return a vector with the minimum, first quartile, median, third quartile,
 ## maximum, mean, standard deviation, skewness, and kurtosis of the elements of
 ## the vector @var{x}.
 ##
-## If @var{x} is a matrix, calculate statistics over the first 
+## If @var{x} is a matrix, calculate statistics over the first
 ## non-singleton dimension.
 ## If the optional argument @var{dim} is given, operate along this dimension.
 ## @seealso{min,max,median,mean,std,skewness,kurtosis}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Compute basic statistics
 
@@ -51,20 +51,20 @@ function stats = statistics (x, dim)
       dim = 1;
     endif
   else
     if (!(isscalar (dim) && dim == round (dim))
         || !(1 <= dim && dim <= nd))
       error ("statistics: DIM must be an integer and a valid dimension");
     endif
   endif
-  
+
   if (sz(dim) < 2)
     error ("statistics: dimension of X is too small (<2)");
-  endif    
+  endif
 
   emp_inv = quantile (x, [0.25; 0.5; 0.75], dim, 7);
 
   stats = cat (dim, min (x, [], dim), emp_inv, max (x, [], dim), mean (x, dim),
                std (x, [], dim), skewness (x, dim), kurtosis (x, dim));
 
 endfunction
 
diff --git a/scripts/statistics/base/std.m b/scripts/statistics/base/std.m
--- a/scripts/statistics/base/std.m
+++ b/scripts/statistics/base/std.m
@@ -33,30 +33,30 @@
 ## @group
 ## std (x) = sqrt ( 1/(N-1) SUM_i (x(i) - mean(x))^2 )
 ## @end group
 ## @end example
 ##
 ## @noindent
 ## where @math{N} is the number of elements.
 ## @end ifnottex
-## 
+##
 ## If @var{x} is a matrix, compute the standard deviation for
 ## each column and return them in a row vector.
 ##
-## The argument @var{opt} determines the type of normalization to use.  
+## The argument @var{opt} determines the type of normalization to use.
 ## Valid values are
 ##
 ## @table @asis
 ## @item 0:
-##   normalize with @math{N-1}, provides the square root of the best unbiased 
+##   normalize with @math{N-1}, provides the square root of the best unbiased
 ## estimator of the variance [default]
 ##
 ## @item 1:
-##   normalize with @math{N}, this provides the square root of the second 
+##   normalize with @math{N}, this provides the square root of the second
 ## moment around the mean
 ## @end table
 ##
 ## If the optional argument @var{dim} is given, operate along this dimension.
 ## @seealso{var, range, iqr, mean, median}
 ## @end deftypefn
 
 ## Author: jwe
diff --git a/scripts/statistics/base/studentize.m b/scripts/statistics/base/studentize.m
--- a/scripts/statistics/base/studentize.m
+++ b/scripts/statistics/base/studentize.m
@@ -18,17 +18,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} studentize (@var{x})
 ## @deftypefnx {Function File} {} studentize (@var{x}, @var{dim})
 ## If @var{x} is a vector, subtract its mean and divide by its standard
 ## deviation.
 ##
 ## If @var{x} is a matrix, do the above along the first non-singleton
-## dimension.  
+## dimension.
 ## If the optional argument @var{dim} is given, operate along this dimension.
 ## @seealso{center}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Subtract mean and divide by standard deviation
 
 function t = studentize (x, dim)
diff --git a/scripts/statistics/base/var.m b/scripts/statistics/base/var.m
--- a/scripts/statistics/base/var.m
+++ b/scripts/statistics/base/var.m
@@ -33,21 +33,21 @@
 ## @group
 ## std (x) = 1/(N-1) SUM_i (x(i) - mean(x))^2
 ## @end group
 ## @end example
 ##
 ## @end ifnottex
 ## If @var{x} is a matrix, compute the variance for each column
 ## and return them in a row vector.
-## 
+##
 ## The argument @var{opt} determines the type of normalization to use.
 ## Valid values are
 ##
-## @table @asis 
+## @table @asis
 ## @item 0:
 ##   normalize with @math{N-1}, provides the best unbiased estimator of the
 ## variance [default]
 ##
 ## @item 1:
 ##   normalizes with @math{N}, this provides the second moment around the mean
 ## @end table
 ##
diff --git a/scripts/statistics/distributions/betainv.m b/scripts/statistics/distributions/betainv.m
--- a/scripts/statistics/distributions/betainv.m
+++ b/scripts/statistics/distributions/betainv.m
@@ -33,17 +33,17 @@ function inv = betainv (x, a, b)
   endif
 
   if (!isscalar (a) || !isscalar(b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
       error ("betainv: X, A and B must be of common size or scalars");
     endif
   endif
-  
+
   sz = size (x);
   inv = zeros (sz);
 
   k = find ((x < 0) | (x > 1) | !(a > 0) | !(b > 0) | isnan (x));
   if (any (k))
     inv (k) = NaN;
   endif
 
diff --git a/scripts/statistics/distributions/betapdf.m b/scripts/statistics/distributions/betapdf.m
--- a/scripts/statistics/distributions/betapdf.m
+++ b/scripts/statistics/distributions/betapdf.m
@@ -26,17 +26,17 @@
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>, CD <christos.dimitrakakis@gmail.com>
 ## Description: PDF of the Beta distribution
 
 function pdf = betapdf (x, a, b)
 
   if (nargin != 3)
     print_usage ();
   endif
-  
+
   if (!isscalar (a) || !isscalar(b))
     [retval, x, a, b] = common_size (x, a, b);
     if (retval > 0)
       error ("betapdf: X, A and B must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
@@ -46,21 +46,21 @@ function pdf = betapdf (x, a, b)
   if (any (k))
     pdf (k) = NaN;
   endif
 
   k = find ((x > 0) & (x < 1) & (a > 0) & (b > 0) & ((a != 1) | (b != 1)));
   if (any (k))
     if (isscalar(a) && isscalar(b))
       pdf(k) = exp ((a - 1) .* log (x(k))
-		            + (b - 1) .* log (1 - x(k))
+                            + (b - 1) .* log (1 - x(k))
                     + lgamma(a + b) - lgamma(a) - lgamma(b));
     else
       pdf(k) = exp ((a(k) - 1) .* log (x(k))
-		            + (b(k) - 1) .* log (1 - x(k))
+                            + (b(k) - 1) .* log (1 - x(k))
                     + lgamma(a(k) + b(k)) - lgamma(a(k)) - lgamma(b(k)));
     endif
   endif
 
   ## Most important special cases when the density is finite.
   k = find ((x == 0) & (a == 1) & (b > 0) & (b != 1));
   if (any (k))
     if (isscalar(a) && isscalar(b))
diff --git a/scripts/statistics/distributions/betarnd.m b/scripts/statistics/distributions/betarnd.m
--- a/scripts/statistics/distributions/betarnd.m
+++ b/scripts/statistics/distributions/betarnd.m
@@ -14,32 +14,32 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} betarnd (@var{a}, @var{b}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} betarnd (@var{a}, @var{b}, @var{sz})
-## Return an @var{r} by @var{c} or @code{size (@var{sz})} matrix of 
+## Return an @var{r} by @var{c} or @code{size (@var{sz})} matrix of
 ## random samples from the Beta distribution with parameters @var{a} and
 ## @var{b}.  Both @var{a} and @var{b} must be scalar or of size @var{r}
 ##  by @var{c}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the common size of @var{a} and @var{b}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Beta distribution
 
 function rnd = betarnd (a, b, r, c)
 
   if (nargin > 1)
-    if (!isscalar(a) || !isscalar(b)) 
+    if (!isscalar(a) || !isscalar(b))
       [retval, a, b] = common_size (a, b);
       if (retval > 0)
         error ("betarnd: A and B must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
@@ -73,27 +73,27 @@ function rnd = betarnd (a, b, r, c)
   else
     print_usage ();
   endif
 
   if (isscalar(a) && isscalar(b))
     if (find (!(a > 0) | !(a < Inf) | !(b > 0) | !(b < Inf)))
       rnd = NaN (sz);
     else
-      r1 = randg(a,sz); 
+      r1 = randg(a,sz);
       rnd = r1 ./ (r1 + randg(b,sz));
     endif
   else
     rnd = zeros (sz);
 
     k = find (!(a > 0) | !(a < Inf) | !(b > 0) | !(b < Inf));
     if (any (k))
       rnd(k) = NaN (size (k));
     endif
 
     k = find ((a > 0) & (a < Inf) & (b > 0) & (b < Inf));
     if (any (k))
-      r1 = randg(a(k),size(k)); 
+      r1 = randg(a(k),size(k));
       rnd(k) = r1 ./ (r1 + randg(b(k),size(k)));
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/binoinv.m b/scripts/statistics/distributions/binoinv.m
--- a/scripts/statistics/distributions/binoinv.m
+++ b/scripts/statistics/distributions/binoinv.m
@@ -32,17 +32,17 @@ function inv = binoinv (x, n, p)
   endif
 
   if (!isscalar (n) || !isscalar (p))
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
       error ("binoinv: X, N and P must be of common size or scalars");
     endif
   endif
-  
+
   sz = size (x);
   inv = zeros (sz);
 
   k = find (!(x >= 0) | !(x <= 1) | !(n >= 0) | (n != round (n))
             | !(p >= 0) | !(p <= 1));
   if (any (k))
     inv(k) = NaN;
   endif
@@ -56,17 +56,17 @@ function inv = binoinv (x, n, p)
         m = find (cdf < x(k));
         if (any (m))
           inv(k(m)) = inv(k(m)) + 1;
           cdf(m) = cdf(m) + binopdf (inv(k(m)), n, p);
         else
           break;
         endif
       endwhile
-    else 
+    else
       cdf = binopdf (0, n(k), p(k));
       while (any (inv(k) < n(k)))
         m = find (cdf < x(k));
         if (any (m))
           inv(k(m)) = inv(k(m)) + 1;
           cdf(m) = cdf(m) + binopdf (inv(k(m)), n(k(m)), p(k(m)));
         else
           break;
diff --git a/scripts/statistics/distributions/binornd.m b/scripts/statistics/distributions/binornd.m
--- a/scripts/statistics/distributions/binornd.m
+++ b/scripts/statistics/distributions/binornd.m
@@ -14,32 +14,32 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} binornd (@var{n}, @var{p}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} binornd (@var{n}, @var{p}, @var{sz})
-## Return an @var{r} by @var{c}  or a @code{size (@var{sz})} matrix of 
+## Return an @var{r} by @var{c}  or a @code{size (@var{sz})} matrix of
 ## random samples from the binomial distribution with parameters @var{n}
 ## and @var{p}.  Both @var{n} and @var{p} must be scalar or of size
 ## @var{r} by @var{c}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the common size of @var{n} and @var{p}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the binomial distribution
 
 function rnd = binornd (n, p, r, c)
 
   if (nargin > 1)
-    if (!isscalar(n) || !isscalar(p)) 
+    if (!isscalar(n) || !isscalar(p))
       [retval, n, p] = common_size (n, p);
       if (retval > 0)
         error ("binornd: N and P must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
diff --git a/scripts/statistics/distributions/cauchy_cdf.m b/scripts/statistics/distributions/cauchy_cdf.m
--- a/scripts/statistics/distributions/cauchy_cdf.m
+++ b/scripts/statistics/distributions/cauchy_cdf.m
@@ -16,46 +16,46 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cauchy_cdf (@var{x}, @var{location}, @var{scale})
 ## For each element of @var{x}, compute the cumulative distribution
 ## function (CDF) at @var{x} of the Cauchy distribution with location
 ## parameter @var{location} and scale parameter @var{scale}.  Default
-## values are @var{location} = 0, @var{scale} = 1. 
+## values are @var{location} = 0, @var{scale} = 1.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the Cauchy distribution
 
 function cdf = cauchy_cdf (x, location, scale)
 
   if (! (nargin == 1 || nargin == 3))
     print_usage ();
   endif
 
   if (nargin == 1)
     location = 0;
     scale = 1;
   endif
 
-  if (!isscalar (location) || !isscalar (scale)) 
+  if (!isscalar (location) || !isscalar (scale))
     [retval, x, location, scale] = common_size (x, location, scale);
     if (retval > 0)
       error ("cauchy_cdf: X, LOCATION and SCALE must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
   cdf = NaN (sz);
 
   k = find ((x > -Inf) & (x < Inf) & (location > -Inf) &
             (location < Inf) & (scale > 0) & (scale < Inf));
   if (any (k))
-    if (isscalar (location) && isscalar (scale)) 
+    if (isscalar (location) && isscalar (scale))
       cdf(k) = 0.5 + atan ((x(k) - location) ./ scale) / pi;
     else
       cdf(k) = 0.5 + atan ((x(k) - location(k)) ./ scale(k)) / pi;
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/cauchy_inv.m b/scripts/statistics/distributions/cauchy_inv.m
--- a/scripts/statistics/distributions/cauchy_inv.m
+++ b/scripts/statistics/distributions/cauchy_inv.m
@@ -16,34 +16,34 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cauchy_inv (@var{x}, @var{location}, @var{scale})
 ## For each element of @var{x}, compute the quantile (the inverse of the
 ## CDF) at @var{x} of the Cauchy distribution with location parameter
 ## @var{location} and scale parameter @var{scale}.  Default values are
-## @var{location} = 0, @var{scale} = 1. 
+## @var{location} = 0, @var{scale} = 1.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Quantile function of the Cauchy distribution
 
 function inv = cauchy_inv (x, location, scale)
 
   if (! (nargin == 1 || nargin == 3))
     print_usage ();
   endif
 
   if (nargin == 1)
     location = 0;
     scale = 1;
   endif
 
-  if (!isscalar (location) || !isscalar (scale)) 
+  if (!isscalar (location) || !isscalar (scale))
     [retval, x, location, scale] = common_size (x, location, scale);
     if (retval > 0)
       error ("cauchy_inv: X, LOCATION and SCALE must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
   inv = NaN (sz);
@@ -53,17 +53,17 @@ function inv = cauchy_inv (x, location, 
 
   k = find ((x == 0) & ok);
   if (any (k))
     inv(k) = -Inf;
   endif
 
   k = find ((x > 0) & (x < 1) & ok);
   if (any (k))
-    if (isscalar (location) && isscalar (scale)) 
+    if (isscalar (location) && isscalar (scale))
       inv(k) = location - scale .* cot (pi * x(k));
     else
       inv(k) = location(k) - scale(k) .* cot (pi * x(k));
     endif
   endif
 
   k = find ((x == 1) & ok);
   if (any (k))
diff --git a/scripts/statistics/distributions/cauchy_pdf.m b/scripts/statistics/distributions/cauchy_pdf.m
--- a/scripts/statistics/distributions/cauchy_pdf.m
+++ b/scripts/statistics/distributions/cauchy_pdf.m
@@ -16,47 +16,47 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} cauchy_pdf (@var{x}, @var{location}, @var{scale})
 ## For each element of @var{x}, compute the probability density function
 ## (PDF) at @var{x} of the Cauchy distribution with location parameter
 ## @var{location} and scale parameter @var{scale} > 0.  Default values are
-## @var{location} = 0, @var{scale} = 1. 
+## @var{location} = 0, @var{scale} = 1.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the Cauchy distribution
 
 function pdf = cauchy_pdf (x, location, scale)
 
   if (! (nargin == 1 || nargin == 3))
     print_usage ();
   endif
 
   if (nargin == 1)
     location = 0;
     scale = 1;
   endif
 
-  if (!isscalar (location) || !isscalar (scale)) 
+  if (!isscalar (location) || !isscalar (scale))
     [retval, x, location, scale] = common_size (x, location, scale);
     if (retval > 0)
       error ("cauchy_pdf: X, LOCATION and SCALE must be of common size or scalar");
     endif
   endif
 
   sz = size (x);
   pdf = NaN (sz);
 
   k = find ((x > -Inf) & (x < Inf) & (location > -Inf) &
             (location < Inf) & (scale > 0) & (scale < Inf));
   if (any (k))
-    if (isscalar (location) && isscalar (scale)) 
+    if (isscalar (location) && isscalar (scale))
       pdf(k) = ((1 ./ (1 + ((x(k) - location) ./ scale) .^ 2))
                 / pi ./ scale);
     else
       pdf(k) = ((1 ./ (1 + ((x(k) - location(k)) ./ scale(k)) .^ 2))
                 / pi ./ scale(k));
     endif
   endif
 
diff --git a/scripts/statistics/distributions/cauchy_rnd.m b/scripts/statistics/distributions/cauchy_rnd.m
--- a/scripts/statistics/distributions/cauchy_rnd.m
+++ b/scripts/statistics/distributions/cauchy_rnd.m
@@ -14,31 +14,31 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} cauchy_rnd (@var{location}, @var{scale}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} cauchy_rnd (@var{location}, @var{scale}, @var{sz})
-## Return an @var{r} by @var{c} or a @code{size (@var{sz})} matrix of 
-## random samples from the Cauchy distribution with parameters @var{location} 
+## Return an @var{r} by @var{c} or a @code{size (@var{sz})} matrix of
+## random samples from the Cauchy distribution with parameters @var{location}
 ## and @var{scale} which must both be scalar or of size @var{r} by @var{c}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the common size of @var{location} and @var{scale}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Cauchy distribution
 
 function rnd = cauchy_rnd (location, scale, r, c)
 
   if (nargin > 1)
-    if (!isscalar (location) || !isscalar (scale)) 
+    if (!isscalar (location) || !isscalar (scale))
       [retval, location, scale] = common_size (location, scale);
       if (retval > 0)
         error ("cauchy_rnd: LOCATION and SCALE must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
@@ -70,25 +70,25 @@ function rnd = cauchy_rnd (location, sca
       error ("cauchy_rnd: LOCATION and SCALE must be scalar or of size SZ");
     endif
   elseif (nargin == 2)
     sz = size(location);
   else
     print_usage ();
   endif
 
-  if (isscalar (location) && isscalar (scale)) 
+  if (isscalar (location) && isscalar (scale))
     if (find (!(location > -Inf) | !(location < Inf)
                 | !(scale > 0) | !(scale < Inf)))
       rnd = NaN (sz);
     else
       rnd = location - cot (pi * rand (sz)) .* scale;
     endif
   else
     rnd = NaN (sz);
-    k = find ((location > -Inf) & (location < Inf) 
+    k = find ((location > -Inf) & (location < Inf)
               & (scale > 0) & (scale < Inf));
     if (any (k))
       rnd(k) = location(k)(:) - cot (pi * rand (size (k))) .* scale(k)(:);
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/chi2rnd.m b/scripts/statistics/distributions/chi2rnd.m
--- a/scripts/statistics/distributions/chi2rnd.m
+++ b/scripts/statistics/distributions/chi2rnd.m
@@ -14,18 +14,18 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} chi2rnd (@var{n}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} chi2rnd (@var{n}, @var{sz})
-## Return an @var{r} by @var{c}  or a @code{size (@var{sz})} matrix of 
-## random samples from the chisquare distribution with @var{n} degrees 
+## Return an @var{r} by @var{c}  or a @code{size (@var{sz})} matrix of
+## random samples from the chisquare distribution with @var{n} degrees
 ## of freedom.  @var{n} must be a scalar or of size @var{r} by @var{c}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the size of @var{n}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the chi-square distribution
diff --git a/scripts/statistics/distributions/discrete_rnd.m b/scripts/statistics/distributions/discrete_rnd.m
--- a/scripts/statistics/distributions/discrete_rnd.m
+++ b/scripts/statistics/distributions/discrete_rnd.m
@@ -68,10 +68,10 @@ function rnd = discrete_rnd (v, p, r, c)
   if (! isvector (v))
     error ("discrete_rnd: V must be a vector");
   elseif (! isvector (p) || (length (p) != length (v)))
     error ("discrete_rnd: P must be a vector with length (V) elements");
   elseif (! (all (p >= 0) && any (p)))
     error ("discrete_rnd: P must be a nonzero, nonnegative vector");
   endif
 
-  rnd = v (lookup (cumsum (p (1 : end-1)) / sum(p), rand (sz)) + 1); 
+  rnd = v (lookup (cumsum (p (1 : end-1)) / sum(p), rand (sz)) + 1);
 endfunction
diff --git a/scripts/statistics/distributions/exprnd.m b/scripts/statistics/distributions/exprnd.m
--- a/scripts/statistics/distributions/exprnd.m
+++ b/scripts/statistics/distributions/exprnd.m
@@ -16,17 +16,17 @@
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} exprnd (@var{lambda}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} exprnd (@var{lambda}, @var{sz})
 ## Return an @var{r} by @var{c} matrix of random samples from the
 ## exponential distribution with mean @var{lambda}, which must be a
-## scalar or of size @var{r} by @var{c}.  Or if @var{sz} is a vector, 
+## scalar or of size @var{r} by @var{c}.  Or if @var{sz} is a vector,
 ## create a matrix of size @var{sz}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the size of @var{lambda}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the exponential distribution
diff --git a/scripts/statistics/distributions/fcdf.m b/scripts/statistics/distributions/fcdf.m
--- a/scripts/statistics/distributions/fcdf.m
+++ b/scripts/statistics/distributions/fcdf.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} fcdf (@var{x}, @var{m}, @var{n})
 ## For each element of @var{x}, compute the CDF at @var{x} of the F
 ## distribution with @var{m} and @var{n} degrees of freedom, i.e.,
-## PROB (F (@var{m}, @var{n}) @leq{} @var{x}). 
+## PROB (F (@var{m}, @var{n}) @leq{} @var{x}).
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: CDF of the F distribution
 
 function cdf = fcdf (x, m, n)
 
   if (nargin != 3)
@@ -52,14 +52,14 @@ function cdf = fcdf (x, m, n)
     cdf(k) = 1;
   endif
 
   k = find ((x > 0) & (x < Inf) & (m > 0) & (n > 0));
   if (any (k))
     if (isscalar (m) && isscalar (n))
       cdf(k) = 1 - betainc (1 ./ (1 + m .* x(k) ./ n), n / 2, m / 2);
     else
-      cdf(k) = 1 - betainc (1 ./ (1 + m(k) .* x(k) ./ n(k)), n(k) / 2, 
+      cdf(k) = 1 - betainc (1 ./ (1 + m(k) .* x(k) ./ n(k)), n(k) / 2,
                             m(k) / 2);
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/frnd.m b/scripts/statistics/distributions/frnd.m
--- a/scripts/statistics/distributions/frnd.m
+++ b/scripts/statistics/distributions/frnd.m
@@ -17,30 +17,30 @@
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} frnd (@var{m}, @var{n}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} frnd (@var{m}, @var{n}, @var{sz})
 ## Return an @var{r} by @var{c} matrix of random samples from the F
 ## distribution with @var{m} and @var{n} degrees of freedom.  Both
 ## @var{m} and @var{n} must be scalar or of size @var{r} by @var{c}.
-## If @var{sz} is a vector the random samples are in a matrix of 
+## If @var{sz} is a vector the random samples are in a matrix of
 ## size @var{sz}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the common size of @var{m} and @var{n}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the F distribution
 
 function rnd = frnd (m, n, r, c)
 
   if (nargin > 1)
-    if (!isscalar(m) || !isscalar(n)) 
+    if (!isscalar(m) || !isscalar(n))
       [retval, m, n] = common_size (m, n);
       if (retval > 0)
         error ("frnd: M and N must be of common size or scalar");
       endif
     endif
   endif
 
 
@@ -80,17 +80,17 @@ function rnd = frnd (m, n, r, c)
   if (isscalar (m) && isscalar (n))
     if (isinf (m) || isinf (n))
       if (isinf (m))
         rnd = ones (sz);
       else
         rnd = 2 ./ m .* randg(m / 2, sz);
       endif
       if (! isinf (n))
-        rnd = 0.5 .* n .* rnd ./ randg (n / 2, sz); 
+        rnd = 0.5 .* n .* rnd ./ randg (n / 2, sz);
       endif
     elseif ((m > 0) && (m < Inf) && (n > 0) && (n < Inf))
       rnd = n ./ m .* randg (m / 2, sz) ./ randg (n / 2, sz);
     else
       rnd = NaN (sz);
     endif
   else
     rnd = zeros (sz);
diff --git a/scripts/statistics/distributions/gamrnd.m b/scripts/statistics/distributions/gamrnd.m
--- a/scripts/statistics/distributions/gamrnd.m
+++ b/scripts/statistics/distributions/gamrnd.m
@@ -14,33 +14,33 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} gamrnd (@var{a}, @var{b}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} gamrnd (@var{a}, @var{b}, @var{sz})
-## Return an @var{r} by @var{c} or a @code{size (@var{sz})} matrix of 
+## Return an @var{r} by @var{c} or a @code{size (@var{sz})} matrix of
 ## random samples from the Gamma distribution with parameters @var{a}
-## and @var{b}.  Both @var{a} and @var{b} must be scalar or of size 
+## and @var{b}.  Both @var{a} and @var{b} must be scalar or of size
 ## @var{r} by @var{c}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the common size of @var{a} and @var{b}.
 ## @seealso{gamma, gammaln, gammainc, gampdf, gamcdf, gaminv}
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Gamma distribution
 
 function rnd = gamrnd (a, b, r, c)
 
   if (nargin > 1)
-    if (!isscalar(a) || !isscalar(b)) 
+    if (!isscalar(a) || !isscalar(b))
       [retval, a, b] = common_size (a, b);
       if (retval > 0)
         error ("gamrnd: A and B must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
@@ -78,17 +78,17 @@ function rnd = gamrnd (a, b, r, c)
   rnd = zeros (sz);
 
   if (isscalar (a) && isscalar(b))
     if (find (!(a > 0) | !(a < Inf) | !(b > 0) | !(b < Inf)))
       rnd = NaN (sz);
     else
       rnd = b .* randg(a, sz);
     endif
-  else 
+  else
     k = find (!(a > 0) | !(a < Inf) | !(b > 0) | !(b < Inf));
     if (any (k))
       rnd(k) = NaN;
     endif
     k = find ((a > 0) & (a < Inf) & (b > 0) & (b < Inf));
     if (any (k))
       rnd(k) = b(k) .* randg(a(k), size(k));
     endif
diff --git a/scripts/statistics/distributions/lognrnd.m b/scripts/statistics/distributions/lognrnd.m
--- a/scripts/statistics/distributions/lognrnd.m
+++ b/scripts/statistics/distributions/lognrnd.m
@@ -29,17 +29,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the log normal distribution
 
 function rnd = lognrnd (mu, sigma, r, c)
 
   if (nargin > 1)
-    if (!isscalar(mu) || !isscalar(sigma)) 
+    if (!isscalar(mu) || !isscalar(sigma))
       [retval, mu, sigma] = common_size (mu, sigma);
       if (retval > 0)
         error ("lognrnd: MU and SIGMA must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
@@ -74,17 +74,17 @@ function rnd = lognrnd (mu, sigma, r, c)
   else
     print_usage ();
   endif
 
   if (isscalar (mu) && isscalar (sigma))
     if  (!(sigma > 0) || !(sigma < Inf))
       rnd = NaN (sz);
     else
-      rnd = exp(mu + sigma .* randn (sz)); 
+      rnd = exp(mu + sigma .* randn (sz));
     endif
   else
     rnd = exp (mu + sigma .* randn (sz));
     k = find ((sigma < 0) | (sigma == Inf));
     if (any (k))
       rnd(k) = NaN;
     endif
   endif
diff --git a/scripts/statistics/distributions/nbincdf.m b/scripts/statistics/distributions/nbincdf.m
--- a/scripts/statistics/distributions/nbincdf.m
+++ b/scripts/statistics/distributions/nbincdf.m
@@ -30,23 +30,23 @@
 ## Description: CDF of the Pascal (negative binomial) distribution
 
 function cdf = nbincdf (x, n, p)
 
   if (nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar(n) || !isscalar(p)) 
+  if (!isscalar(n) || !isscalar(p))
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
       error ("nbincdf: X, N and P must be of common size or scalar");
     endif
   endif
-  
+
   cdf = zeros (size (x));
 
   k = find (isnan (x) | (n < 1) | (n == Inf) | (n != round (n))
             | (p < 0) | (p > 1));
   if (any (k))
     cdf(k) = NaN;
   endif
 
diff --git a/scripts/statistics/distributions/nbininv.m b/scripts/statistics/distributions/nbininv.m
--- a/scripts/statistics/distributions/nbininv.m
+++ b/scripts/statistics/distributions/nbininv.m
@@ -31,17 +31,17 @@
 ## Description: Quantile function of the Pascal distribution
 
 function inv = nbininv (x, n, p)
 
   if (nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar(n) || !isscalar(p)) 
+  if (!isscalar(n) || !isscalar(p))
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
       error ("nbininv: X, N and P must be of common size or scalar");
     endif
   endif
 
   inv = zeros (size (x));
 
diff --git a/scripts/statistics/distributions/nbinpdf.m b/scripts/statistics/distributions/nbinpdf.m
--- a/scripts/statistics/distributions/nbinpdf.m
+++ b/scripts/statistics/distributions/nbinpdf.m
@@ -19,29 +19,29 @@
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} nbinpdf (@var{x}, @var{n}, @var{p})
 ## For each element of @var{x}, compute the probability density function
 ## (PDF) at @var{x} of the Pascal (negative binomial) distribution with
 ## parameters @var{n} and @var{p}.
 ##
 ## The number of failures in a Bernoulli experiment with success
 ## probability @var{p} before the @var{n}-th success follows this
-## distribution. 
+## distribution.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the Pascal (negative binomial) distribution
 
 function pdf = nbinpdf (x, n, p)
 
   if (nargin != 3)
     print_usage ();
   endif
 
-  if (!isscalar(n) || !isscalar(p)) 
+  if (!isscalar(n) || !isscalar(p))
     [retval, x, n, p] = common_size (x, n, p);
     if (retval > 0)
       error ("nbinpdf: X, N and P must be of common size or scalar");
     endif
   endif
 
   pdf = zeros (size (x));
 
diff --git a/scripts/statistics/distributions/nbinrnd.m b/scripts/statistics/distributions/nbinrnd.m
--- a/scripts/statistics/distributions/nbinrnd.m
+++ b/scripts/statistics/distributions/nbinrnd.m
@@ -19,27 +19,27 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} nbinrnd (@var{n}, @var{p}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} nbinrnd (@var{n}, @var{p}, @var{sz})
 ## Return an @var{r} by @var{c} matrix of random samples from the Pascal
 ## (negative binomial) distribution with parameters @var{n} and @var{p}.
 ## Both @var{n} and @var{p} must be scalar or of size @var{r} by @var{c}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
-## the common size of @var{n} and @var{p}.  Or if @var{sz} is a vector, 
+## the common size of @var{n} and @var{p}.  Or if @var{sz} is a vector,
 ## create a matrix of size @var{sz}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Pascal distribution
 
 function rnd = nbinrnd (n, p, r, c)
 
   if (nargin > 1)
-    if (!isscalar(n) || !isscalar(p)) 
+    if (!isscalar(n) || !isscalar(p))
       [retval, n, p] = common_size (n, p);
       if (retval > 0)
         error ("nbinrnd: N and P must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
diff --git a/scripts/statistics/distributions/normrnd.m b/scripts/statistics/distributions/normrnd.m
--- a/scripts/statistics/distributions/normrnd.m
+++ b/scripts/statistics/distributions/normrnd.m
@@ -15,31 +15,31 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} normrnd (@var{m}, @var{s}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} normrnd (@var{m}, @var{s}, @var{sz})
 ## Return an @var{r} by @var{c}  or @code{size (@var{sz})} matrix of
-## random samples from the normal distribution with parameters mean @var{m} 
-## and standard deviation @var{s}.  Both @var{m} and @var{s} must be scalar 
+## random samples from the normal distribution with parameters mean @var{m}
+## and standard deviation @var{s}.  Both @var{m} and @var{s} must be scalar
 ## or of size @var{r} by @var{c}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the common size of @var{m} and @var{s}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the normal distribution
 
 function rnd = normrnd (m, s, r, c)
 
   if (nargin > 1)
-    if (!isscalar (m) || !isscalar (s)) 
+    if (!isscalar (m) || !isscalar (s))
       [retval, m, s] = common_size (m, s);
       if (retval > 0)
         error ("normrnd: M and S must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
diff --git a/scripts/statistics/distributions/poissrnd.m b/scripts/statistics/distributions/poissrnd.m
--- a/scripts/statistics/distributions/poissrnd.m
+++ b/scripts/statistics/distributions/poissrnd.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} poissrnd (@var{lambda}, @var{r}, @var{c})
 ## Return an @var{r} by @var{c} matrix of random samples from the
-## Poisson distribution with parameter @var{lambda}, which must be a 
+## Poisson distribution with parameter @var{lambda}, which must be a
 ## scalar or of size @var{r} by @var{c}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the size of @var{lambda}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Poisson distribution
diff --git a/scripts/statistics/distributions/stdnormal_rnd.m b/scripts/statistics/distributions/stdnormal_rnd.m
--- a/scripts/statistics/distributions/stdnormal_rnd.m
+++ b/scripts/statistics/distributions/stdnormal_rnd.m
@@ -14,17 +14,17 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} stdnormal_rnd (@var{r}, @var{c})
 ## @deftypefnx {Function File} {} stdnormal_rnd (@var{sz})
-## Return an @var{r} by @var{c} or @code{size (@var{sz})} matrix of 
+## Return an @var{r} by @var{c} or @code{size (@var{sz})} matrix of
 ## random numbers from the standard normal distribution.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the standard normal distribution
 
 function rnd = stdnormal_rnd (r, c)
 
diff --git a/scripts/statistics/distributions/tpdf.m b/scripts/statistics/distributions/tpdf.m
--- a/scripts/statistics/distributions/tpdf.m
+++ b/scripts/statistics/distributions/tpdf.m
@@ -15,17 +15,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} tpdf (@var{x}, @var{n})
 ## For each element of @var{x}, compute the probability density function
 ## (PDF) at @var{x} of the @var{t} (Student) distribution with @var{n}
-## degrees of freedom. 
+## degrees of freedom.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: PDF of the t distribution
 
 function pdf = tpdf (x, n)
 
   if (nargin != 2)
diff --git a/scripts/statistics/distributions/trnd.m b/scripts/statistics/distributions/trnd.m
--- a/scripts/statistics/distributions/trnd.m
+++ b/scripts/statistics/distributions/trnd.m
@@ -64,27 +64,27 @@ function rnd = trnd (n, r, c)
   else
     print_usage ();
   endif
 
   if (isscalar (n))
     if (!(n > 0) || !(n < Inf))
       rnd = NaN (sz);
     elseif ((n > 0) && (n < Inf))
-      rnd = randn(sz) ./ sqrt(2*randg(n/2,sz)./n); 
+      rnd = randn(sz) ./ sqrt(2*randg(n/2,sz)./n);
     else
       rnd = zeros (size (n));
     endif
   else
     rnd = zeros (size (n));
 
     k = find (!(n > 0) | !(n < Inf));
     if (any (k))
       rnd(k) = NaN;
     endif
 
     k = find ((n > 0) & (n < Inf));
     if (any (k))
-      rnd(k) = randn(size(k)) ./ sqrt(2*randg(n(k)/2,size(k))./n(k)); 
+      rnd(k) = randn(size(k)) ./ sqrt(2*randg(n(k)/2,size(k))./n(k));
     endif
   endif
 
 endfunction
diff --git a/scripts/statistics/distributions/unifcdf.m b/scripts/statistics/distributions/unifcdf.m
--- a/scripts/statistics/distributions/unifcdf.m
+++ b/scripts/statistics/distributions/unifcdf.m
@@ -52,17 +52,17 @@ function cdf = unifcdf (x, a, b)
   if (any (k))
     cdf(k) = NaN;
   endif
 
   k = find ((x >= b) & (a < b));
   if (any (k))
     cdf(k) = 1;
   endif
-  
+
   k = find ((x > a) & (x < b));
   if (any (k))
     if (isscalar (a) && isscalar(b))
       cdf(k) = (x(k) < b) .* (x(k) - a) ./ (b - a);
     else
       cdf(k) = (x(k) < b(k)) .* (x(k) - a(k)) ./ (b(k) - a(k));
     endif
   endif
diff --git a/scripts/statistics/distributions/unifrnd.m b/scripts/statistics/distributions/unifrnd.m
--- a/scripts/statistics/distributions/unifrnd.m
+++ b/scripts/statistics/distributions/unifrnd.m
@@ -14,31 +14,31 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} unifrnd (@var{a}, @var{b}, @var{r}, @var{c})
 ## @deftypefnx {Function File} {} unifrnd (@var{a}, @var{b}, @var{sz})
-## Return an @var{r} by @var{c} or a @code{size (@var{sz})} matrix of 
-## random samples from the uniform distribution on [@var{a}, @var{b}]. 
+## Return an @var{r} by @var{c} or a @code{size (@var{sz})} matrix of
+## random samples from the uniform distribution on [@var{a}, @var{b}].
 ## Both @var{a} and @var{b} must be scalar or of size @var{r} by @var{c}.
 ##
 ## If @var{r} and @var{c} are omitted, the size of the result matrix is
 ## the common size of @var{a} and @var{b}.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the uniform distribution
 
 function rnd = unifrnd (a, b, r, c)
 
   if (nargin > 1)
-    if (!isscalar(a) || !isscalar(b)) 
+    if (!isscalar(a) || !isscalar(b))
       [retval, a, b] = common_size (a, b);
       if (retval > 0)
         error ("unifrnd: A and B must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
diff --git a/scripts/statistics/distributions/wblrnd.m b/scripts/statistics/distributions/wblrnd.m
--- a/scripts/statistics/distributions/wblrnd.m
+++ b/scripts/statistics/distributions/wblrnd.m
@@ -29,17 +29,17 @@
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Random deviates from the Weibull distribution
 
 function rnd = wblrnd (scale, shape, r, c)
 
   if (nargin > 1)
-    if (!isscalar(scale) || !isscalar(shape)) 
+    if (!isscalar(scale) || !isscalar(shape))
       [retval, scale, shape] = common_size (scale, shape);
       if (retval > 0)
         error ("wblrnd: SCALE and SHAPE must be of common size or scalar");
       endif
     endif
   endif
 
   if (nargin == 4)
diff --git a/scripts/statistics/tests/bartlett_test.m b/scripts/statistics/tests/bartlett_test.m
--- a/scripts/statistics/tests/bartlett_test.m
+++ b/scripts/statistics/tests/bartlett_test.m
@@ -12,17 +12,17 @@
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
-## @deftypefn {Function File} {[@var{pval}, @var{chisq}, @var{df}] =} bartlett_test (@var{x1}, @dots{}) 
+## @deftypefn {Function File} {[@var{pval}, @var{chisq}, @var{df}] =} bartlett_test (@var{x1}, @dots{})
 ## Perform a Bartlett test for the homogeneity of variances in the data
 ## vectors @var{x1}, @var{x2}, @dots{}, @var{xk}, where @var{k} > 1.
 ##
 ## Under the null of equal variances, the test statistic @var{chisq}
 ## approximately follows a chi-square distribution with @var{df} degrees of
 ## freedom.
 ##
 ## The p-value (1 minus the CDF of this distribution at @var{chisq}) is
diff --git a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
--- a/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
+++ b/scripts/statistics/tests/kolmogorov_smirnov_test_2.m
@@ -75,17 +75,17 @@ function [pval, ks, d] = kolmogorov_smir
   z = cumsum (count);
   ds = diff (s);
   if (any (ds == 0))
     ## There are some ties, so keep only those changes.
     warning ("cannot compute correct p-values with ties");
     elems = [find(ds); n_x+n_y];
     z = z(elems);
   endif
-  
+
   if (strcmp (alt, "!=") || strcmp (alt, "<>"))
     d    = max (abs (z));
     ks   = sqrt (n) * d;
     pval = 1 - kolmogorov_smirnov_cdf (ks);
   elseif (strcmp (alt, ">"))
     d    = max (z);
     ks   = sqrt (n) * d;
     pval = exp (-2 * ks^2);
diff --git a/scripts/statistics/tests/kruskal_wallis_test.m b/scripts/statistics/tests/kruskal_wallis_test.m
--- a/scripts/statistics/tests/kruskal_wallis_test.m
+++ b/scripts/statistics/tests/kruskal_wallis_test.m
@@ -25,17 +25,17 @@
 ##
 ## Under the null hypothesis that the ranks in the pooled sample are not
 ## affected by the group memberships, the test statistic @var{k} is
 ## approximately chi-square with @var{df} = @var{k} - 1 degrees of
 ## freedom.
 ##
 ## If the data contains ties (some value appears more than once)
 ## @var{k} is divided by
-## 
+##
 ## 1 - @var{sum_ties} / (@var{n}^3 - @var{n})
 ##
 ## where @var{sum_ties} is the sum of @var{t}^2 - @var{t} over each group
 ## of ties where @var{t} is the number of ties in the group and @var{n}
 ## is the total number of values in the input data.  For more info on
 ## this adjustment see "Use of Ranks in One-Criterion Variance Analysis"
 ## in Journal of the American Statistical Association, Vol. 47,
 ## No. 260 (Dec 1952) by William H. Kruskal and W. Allen Wallis.
diff --git a/scripts/statistics/tests/t_test_regression.m b/scripts/statistics/tests/t_test_regression.m
--- a/scripts/statistics/tests/t_test_regression.m
+++ b/scripts/statistics/tests/t_test_regression.m
@@ -26,17 +26,17 @@
 ## If @var{r} is omitted, a value of 0 is assumed.
 ##
 ## With the optional argument string @var{alt}, the alternative of
 ## interest can be selected.  If @var{alt} is @code{"!="} or
 ## @code{"<>"}, the null is tested against the two-sided alternative
 ## @code{@var{rr} * @var{b} != @var{r}}.  If @var{alt} is @code{">"}, the
 ## one-sided alternative @code{@var{rr} * @var{b} > @var{r}} is used.
 ## Similarly for @var{"<"}, the one-sided alternative @code{@var{rr} *
-## @var{b} < @var{r}} is used.  The default is the two-sided case. 
+## @var{b} < @var{r}} is used.  The default is the two-sided case.
 ##
 ## The p-value of the test is returned in @var{pval}.
 ##
 ## If no output argument is given, the p-value of the test is displayed.
 ## @end deftypefn
 
 ## Author: KH <Kurt.Hornik@wu-wien.ac.at>
 ## Description: Test one linear hypothesis in linear regression model
diff --git a/scripts/strings/blanks.m b/scripts/strings/blanks.m
--- a/scripts/strings/blanks.m
+++ b/scripts/strings/blanks.m
@@ -21,17 +21,17 @@
 ## Return a string of @var{n} blanks, for example:
 ##
 ## @example
 ## @group
 ## blanks(10);
 ## whos ans;
 ##      @result{}
 ##       Attr Name        Size                     Bytes  Class
-##       ==== ====        ====                     =====  ===== 
+##       ==== ====        ====                     =====  =====
 ##            ans         1x10                        10  char
 ## @end group
 ## @end example
 ## @seealso{repmat}
 ## @end deftypefn
 
 ## Author: Kurt Hornik <Kurt.Hornik@wu-wien.ac.at>
 ## Adapted-By: jwe
diff --git a/scripts/strings/dec2base.m b/scripts/strings/dec2base.m
--- a/scripts/strings/dec2base.m
+++ b/scripts/strings/dec2base.m
@@ -76,25 +76,25 @@ function retval = dec2base (d, base, len
     if (any (isspace (symbols)))
       error ("dec2base: whitespace characters are not valid symbols");
     endif
   elseif (! isscalar (base))
     error ("dec2base: cannot convert from several bases at once");
   elseif (base < 2 || base > length (symbols))
     error ("dec2base: BASE must be between 2 and 36, or a string of symbols");
   endif
-  
+
   ## determine number of digits required to handle all numbers, can overflow
   ## by 1 digit
   max_len = round (log (max (max (d), 1)) ./ log (base)) + 1;
 
   if (nargin == 3)
     max_len = max (max_len, len);
   endif
-  
+
   ## determine digits for each number
   digits = zeros (length (d), max_len);
   for k = max_len:-1:1
     digits(:,k) = mod(d, base);
     d = round ((d - digits(:,k)) / base);
   endfor
 
   ## convert digits to symbols
diff --git a/scripts/strings/dec2hex.m b/scripts/strings/dec2hex.m
--- a/scripts/strings/dec2hex.m
+++ b/scripts/strings/dec2hex.m
@@ -13,17 +13,17 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} dec2hex (@var{d}, @var{len})
-## Return the hexadecimal string corresponding to the non-negative 
+## Return the hexadecimal string corresponding to the non-negative
 ## integer @var{d}.  For example:
 ##
 ## @example
 ## @group
 ## dec2hex (2748)
 ##      @result{} "ABC"
 ## @end group
 ## @end example
diff --git a/scripts/strings/findstr.m b/scripts/strings/findstr.m
--- a/scripts/strings/findstr.m
+++ b/scripts/strings/findstr.m
@@ -55,32 +55,32 @@ function v = findstr (s, t, overlap)
   endif
 
   ## Make S be the longer string.
   if (length (s) < length (t))
     tmp = s;
     s = t;
     t = tmp;
   endif
-  
+
   l_s = length (s);
   l_t = length (t);
-  
+
   if (l_t == 0)
     ## zero length target: return empty set
     v = [];
-    
+
   elseif (l_t == 1)
     ## length one target: simple find
     v = find (s == t);
-    
+
   elseif (l_t == 2)
     ## length two target: find first at i and second at i+1
     v = find (s(1:l_s-1) == t(1) & s(2:l_s) == t(2));
-    
+
   else
     ## length three or more: match the first three by find then go through
     ## the much smaller list to determine which of them are real matches
     limit = l_s - l_t + 1;
     v = find (s(1:limit) == t(1)
               & s(2:limit+1) == t(2)
               & s (3:limit+2) == t(3));
   endif
@@ -91,17 +91,17 @@ function v = findstr (s, t, overlap)
   ## target is different from the remaining characters in the target,
   ## so a single character, two different characters, or first character
   ## different from the second two don't need to be searched.
   if (l_t >= 3 || (! overlap && l_t > 1 && any (t(1) == t(2:l_t))))
     ## force strings to be both row vectors or both column vectors
     if (all (size (s) != size (t)))
       t = t.';
     endif
-    
+
     ## determine which ones to keep
     keep = zeros (size (v));
     ind = 0:l_t-1;
     if (overlap)
       for idx = 1:length (v)
         keep(idx) = all (s(v(idx) + ind) == t);
       endfor
     else
@@ -122,17 +122,17 @@ function v = findstr (s, t, overlap)
     endif
   endif
 
   if (isempty (v))
     v = [];
   endif
 
   ## Always return a column vector, because that's what the old one did.
-  if (rows (v) > 1) 
+  if (rows (v) > 1)
     v = v.';
   endif
 
 endfunction
 
 %!assert ((findstr ("abababa", "a") == [1, 3, 5, 7]
 %! && findstr ("abababa", "aba") == [1, 3, 5]
 %! && findstr ("abababa", "aba", 0) == [1, 5]));
diff --git a/scripts/strings/index.m b/scripts/strings/index.m
--- a/scripts/strings/index.m
+++ b/scripts/strings/index.m
@@ -77,17 +77,17 @@ function n = index (s, t, direction)
   endif
 endfunction
 
 ## Test the function out
 %!assert(index("astringbstringcstring", "s"), 2)
 %!assert(index("astringbstringcstring", "st"), 2)
 %!assert(index("astringbstringcstring", "str"), 2)
 %!assert(index("astringbstringcstring", "string"), 2)
-%!assert(index("abc---", "abc+++"), 0) 
+%!assert(index("abc---", "abc+++"), 0)
 
 ## test everything out in reverse
 %!assert(index("astringbstringcstring", "s", "last"), 16)
 %!assert(index("astringbstringcstring", "st", "last"), 16)
 %!assert(index("astringbstringcstring", "str", "last"), 16)
 %!assert(index("astringbstringcstring", "string", "last"), 16)
 %!assert(index("abc---", "abc+++", "last"), 0)
 
diff --git a/scripts/strings/isstrprop.m b/scripts/strings/isstrprop.m
--- a/scripts/strings/isstrprop.m
+++ b/scripts/strings/isstrprop.m
@@ -21,17 +21,17 @@
 ## Test character string properties.  For example:
 ##
 ## @example
 ## @group
 ## isstrprop ("abc123", "alpha")
 ## @result{} [1, 1, 1, 0, 0, 0]
 ## @end group
 ## @end example
-## 
+##
 ## If @var{str} is a cell array, @code{isstrpop} is applied recursively
 ## to each element of the cell array.
 ##
 ## Numeric arrays are converted to character strings.
 ##
 ## The second argument @var{prop} must be one of
 ##
 ## @table @code
@@ -42,45 +42,45 @@
 ## @itemx "alphanum"
 ## True for characters that are alphabetic or digits.
 ##
 ## @item "lower"
 ## True for lower-case letters.
 ##
 ## @item "upper"
 ## True for upper-case letters.
-## 
+##
 ## @item "digit"
 ## True for decimal digits (0-9).
 ##
 ## @item "xdigit"
 ## True for hexadecimal digits (a-fA-F0-9).
 ##
 ## @item "space"
 ## @itemx "wspace"
 ## True for whitespace characters (space, formfeed, newline, carriage
 ## return, tab, vertical tab).
-## 
+##
 ## @item "punct"
 ## True for punctuation characters (printing characters except space
 ## or letter or digit).
 ##
 ## @item "cntrl"
 ## True for control characters.
 ##
 ## @item "graph"
 ## @itemx "graphic"
 ## True for printing characters except space.
 ##
 ## @item "print"
 ## True for printing characters including space.
 ##
 ## @item "ascii"
 ## True for characters that are in the range of ASCII encoding.
-## 
+##
 ## @end table
 ##
 ## @seealso{isalpha, isalnum, islower, isupper, isdigit, isxdigit,
 ## isspace, ispunct, iscntrl, isgraph, isprint, isascii}
 ## @end deftypefn
 
 function retval = isstrprop (str, prop)
 
diff --git a/scripts/strings/mat2str.m b/scripts/strings/mat2str.m
--- a/scripts/strings/mat2str.m
+++ b/scripts/strings/mat2str.m
@@ -66,17 +66,17 @@ function s = mat2str (x, n, cls)
     else
       cls = "";
     endif
   endif
 
   if (nargin < 1 || nargin > 3 || ! (isnumeric (x) || islogical (x)))
     print_usage ();
   endif
-  
+
   if (ndims (x) > 2)
     error ("mat2str: X must be two dimensional");
   endif
 
   x_islogical = islogical (x);
   x_iscomplex = iscomplex (x);
 
   if (x_iscomplex)
diff --git a/scripts/strings/regexptranslate.m b/scripts/strings/regexptranslate.m
--- a/scripts/strings/regexptranslate.m
+++ b/scripts/strings/regexptranslate.m
@@ -21,47 +21,47 @@
 ## Translate a string for use in a regular expression.  This might
 ## include either wildcard replacement or special character escaping.
 ## The behavior can be controlled by the @var{op} that can have the
 ## values
 ##
 ## @table @asis
 ## @item "wildcard"
 ## The wildcard characters @code{.}, @code{*} and @code{?} are replaced
-## with wildcards that are appropriate for a regular expression. 
+## with wildcards that are appropriate for a regular expression.
 ## For example:
 ##
 ## @example
 ## @group
 ## regexptranslate ("wildcard", "*.m")
 ##      @result{} ".*\.m"
 ## @end group
 ## @end example
-## 
+##
 ## @item "escape"
 ## The characters @code{$.?[]}, that have special meaning for regular
 ## expressions are escaped so that they are treated literally.  For example:
 ##
 ## @example
 ## @group
 ## regexptranslate ("escape", "12.5")
 ##      @result{} "12\.5"
 ## @end group
 ## @end example
 ##
 ## @end table
 ## @seealso{regexp, regexpi, regexprep}
 ## @end deftypefn
 
 function y = regexptranslate (op, s)
-  
+
   if nargin != 2
     print_usage ();
-  endif 
-  
+  endif
+
   if (ischar (op))
     op = tolower (op);
     if (strcmp ("wildcard", op))
       y = regexprep (regexprep (regexprep (s, "\\.", "\\."), "\\*",
                                 ".*"), "\\?", ".");
     elseif (strcmp ("escape", op))
       ch = {'\$', '\.', '\?', '\[', '\]'};
       y = s;
diff --git a/scripts/strings/str2num.m b/scripts/strings/str2num.m
--- a/scripts/strings/str2num.m
+++ b/scripts/strings/str2num.m
@@ -14,34 +14,34 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} str2num (@var{s})
 ## Convert the string (or character array) @var{s} to a number (or an
-## array).  Examples:  
+## array).  Examples:
 ##
 ## @example
 ## @group
 ## str2num("3.141596")
 ##      @result{} 3.141596
-## 
+##
 ## str2num(["1, 2, 3"; "4, 5, 6"]);
 ##      @result{} ans =
 ##         1  2  3
 ##         4  5  6
 ## @end group
 ## @end example
-## 
+##
 ## @strong{Caution:} As @code{str2num} uses the @code{eval} function
 ## to do the conversion, @code{str2num} will execute any code contained
 ## in the string @var{s}.  Use @code{str2double} instead if you want to
-## avoid the use of @code{eval}. 
+## avoid the use of @code{eval}.
 ## @seealso{str2double, eval}
 ## @end deftypefn
 
 ## Author: jwe
 
 function m = str2num (s)
 
   if (nargin == 1 && ischar (s))
diff --git a/scripts/strings/strchr.m b/scripts/strings/strchr.m
--- a/scripts/strings/strchr.m
+++ b/scripts/strings/strchr.m
@@ -51,14 +51,14 @@ function varargout = strchr (str, chars,
     si = uint32 (str);
     ## in-place
     ++si;
     mask = reshape (f(si), size (str));
   endif
   varargout = cell (1, nargout);
   varargout{1} = [];
   [varargout{:}] = find (mask, varargin{:});
-endfunction 
+endfunction
 
 %!assert(strchr("Octave is the best software",""),zeros(1,0))
 %!assert(strchr("Octave is the best software","best"),[3, 6, 9, 11, 13, 15, 16, 17, 18, 20, 23, 27])
 %!assert(strchr("Octave is the best software","software"),[3, 4, 6, 9, 11, 13, 16, 17, 18, 20, 21, 22, 23, 24, 25, 26, 27])
 
diff --git a/scripts/strings/strjust.m b/scripts/strings/strjust.m
--- a/scripts/strings/strjust.m
+++ b/scripts/strings/strjust.m
@@ -16,17 +16,17 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strjust (@var{s}, @var{pos})
 ## Return the text, @var{s}, justified according to @var{pos}, which may
 ## be @samp{"left"}, @samp{"center"}, or @samp{"right"}.  If @var{pos}
-## is omitted, @samp{"right"} is assumed. 
+## is omitted, @samp{"right"} is assumed.
 ##
 ## Null characters are replaced by spaces.  All other character
 ## data are treated as non-white space.
 ##
 ## Example:
 ##
 ## @example
 ## @group
@@ -83,17 +83,17 @@ function y = strjust (s, pos)
       mins(flipud (idx(:))) = flipud (jdx(:));
       shift = 1 - mins;
     else
       ## Use both of the above.
       mins = ones (nr, 1);
       mins(flipud (idx(:))) = flipud (jdx(:));
       maxs = nc * ones (nr, 1);
       maxs(idx) = jdx;
-      shift = floor ((nc + 1 - maxs - mins) / 2); 
+      shift = floor ((nc + 1 - maxs - mins) / 2);
     endif
 
     ## Adjust the column indices.
     jdx += shift (idx);
 
     ## Create a blank matrix and position the nonblank characters.
     y = " "(ones (1, nr), ones (1, nc));
     y(sub2ind ([nr, nc], idx, jdx)) = s(nonbl);
diff --git a/scripts/strings/strmatch.m b/scripts/strings/strmatch.m
--- a/scripts/strings/strmatch.m
+++ b/scripts/strings/strmatch.m
@@ -20,17 +20,17 @@
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} strmatch (@var{s}, @var{A}, "exact")
 ## Return indices of entries of @var{A} that match the string @var{s}.
 ## The second argument @var{A} may be a string matrix or a cell array of
 ## strings.  If the third argument @code{"exact"} is not given, then
 ## @var{s} only needs to match @var{A} up to the length of @var{s}.
 ## Trailing whitespace is ignored.
-## Results are returned as a column vector. 
+## Results are returned as a column vector.
 ## For example:
 ##
 ## @example
 ## @group
 ## strmatch ("apple", "apple juice")
 ##      @result{} 1
 ##
 ## strmatch ("apple", ["apple pie"; "apple juice"; "an apple"])
@@ -50,17 +50,17 @@ function idx = strmatch (s, A, exact)
 
   if (nargin < 2 || nargin > 3)
     print_usage ();
   endif
 
   if (! ischar (s))
     error ("strmatch: S must be a string");
   endif
-  
+
   ## Truncate trailing whitespace.
   s = strtrimr (s);
 
   len = length (s);
 
   exact = nargin == 3 && ischar (exact) && strcmp (exact, "exact");
 
   if (iscell (A))
@@ -84,18 +84,18 @@ function idx = strmatch (s, A, exact)
         AA = A(:,len+1:nc);
         match &= all (AA == "\0" | AA == " ", 2);
       endif
       idx = find (match);
     endif
   else
     error ("strmatch: A must be a string or cell array of strings");
   endif
-    
-endfunction 
+
+endfunction
 
 ## Removes nuls and blanks from the end of the array
 function s = strtrimr (s)
   blnks = s == "\0" | s == " ";
   i = find (blnks, 1, "last");
   if (i && all (blnks(i:end)))
     s = s(1:i-1);
   endif
diff --git a/scripts/strings/strsplit.m b/scripts/strings/strsplit.m
--- a/scripts/strings/strsplit.m
+++ b/scripts/strings/strsplit.m
@@ -46,20 +46,20 @@ function s = strsplit (p, sep, strip_emp
 
     ## Get substring sizes.
     if (isempty (idx))
       sizes = numel (p);
     else
       sizes = [idx(1)-1, diff(idx)-1, numel(p)-idx(end)];
     endif
     ## Remove separators.
-    p(idx) = []; 
+    p(idx) = [];
     if (strip_empty)
       ## Omit zero lengths.
-      sizes = sizes (sizes != 0); 
+      sizes = sizes (sizes != 0);
     endif
     ## Convert!
     s = mat2cell (p, 1, sizes);
   endif
 
 endfunction
 
 %!assert (all (strcmp (strsplit ("road to hell", " "), {"road", "to", "hell"})))
diff --git a/scripts/strings/strtok.m b/scripts/strings/strtok.m
--- a/scripts/strings/strtok.m
+++ b/scripts/strings/strtok.m
@@ -13,22 +13,22 @@
 ## General Public License for more details.
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {[@var{tok}, @var{rem}] =} strtok (@var{str}, @var{delim})
-## 
+##
 ## Find all characters up to but not including the first character which
 ## is in the string delim.  If @var{rem} is requested, it contains the
 ## remainder of the string, starting at the first delimiter.  Leading
 ## delimiters are ignored.  If @var{delim} is not specified, space is
-## assumed.  For example: 
+## assumed.  For example:
 ##
 ## @example
 ## @group
 ## strtok ("this is the life")
 ##      @result{} "this"
 ##
 ## [tok, rem] = strtok ("14*27+31", "+-*/")
 ##      @result{}
@@ -43,34 +43,34 @@
 
 function [tok, rem] = strtok (str, delim)
 
   if (nargin<1 || nargin > 2)
     print_usage ();
   endif
 
   if (nargin < 2 || isempty (delim))
-    delim = "\t\n\v\f\r "; 
+    delim = "\t\n\v\f\r ";
   endif
 
   if (isempty (str))
     tok = rem = "";
   elseif (length (delim) > 3)
     start = 1;
     len = length (str);
     while (start <= len)
       if (all (str(start) != delim))
-        break; 
+        break;
       endif
       start++;
     endwhile
     stop = start;
     while (stop <= len)
       if (any (str(stop) == delim))
-        break; 
+        break;
       endif
       stop++;
     endwhile
     tok = str(start:stop-1);
     rem = str(stop:len);
   else
     if (length (delim) == 1)
       idx = find (str == delim);
@@ -107,17 +107,17 @@ endfunction
 %!   [t,s] = strtok(s, "+-*/");
 %!   printf("<%s>", t);
 %!   if isempty(s), break; endif
 %!   printf("<%s>", s(1));
 %! endwhile
 %! printf("\n");
 %! % ----------------------------------------------------
 %! % Demonstrates processing of an entire string split on
-%! % a variety of delimiters. Tokens and delimiters are 
+%! % a variety of delimiters. Tokens and delimiters are
 %! % printed one after another in angle brackets.  The
 %! % string is:
 
 %!# test the tokens for all cases
 %!assert(strtok(""), "");             # no string
 %!assert(strtok("this"), "this");     # no delimiter in string
 %!assert(strtok("this "), "this");    # delimiter at end
 %!assert(strtok("this is"), "this");  # delimiter in middle
@@ -133,17 +133,17 @@ endfunction
 %!test [t,r] = strtok(" this"); assert(r, char (zeros (1, 0)));
 %!test [t,r] = strtok(" this "); assert(r, " ");
 %!test [t,r] = strtok(" "); assert(r, char (zeros (1, 0)));
 
 %!# simple check with 2 and 3 delimeters
 %!assert(strtok("this is", "i "), "th");
 %!assert(strtok("this is", "ij "), "th");
 
-%!# test all cases for 4 delimiters since a different 
+%!# test all cases for 4 delimiters since a different
 %!# algorithm is used when more than 3 delimiters
 %!assert(strtok("","jkl "), "");
 %!assert(strtok("this","jkl "), "this");
 %!assert(strtok("this ","jkl "), "this");
 %!assert(strtok("this is","jkl "), "this");
 %!assert(strtok(" this","jkl "), "this");
 %!assert(strtok(" this ","jkl "), "this");
 %!assert(strtok(" ","jkl "), ""(1:0));
diff --git a/scripts/strings/untabify.m b/scripts/strings/untabify.m
--- a/scripts/strings/untabify.m
+++ b/scripts/strings/untabify.m
@@ -1,22 +1,22 @@
 ## Copyright (C) 2010-2011 Ben Abbott
-## 
+##
 ## This file is part of Octave.
 ##
 ## Octave is free software; you can redistribute it and/or modify it
 ## under the terms of the GNU General Public License as published by
-## the Free Software Foundation; either version 2 of the License, or (at 
+## the Free Software Foundation; either version 2 of the License, or (at
 ## your option) any later version.
-## 
+##
 ## This program is distributed in the hope that it will be useful,
 ## but WITHOUT ANY WARRANTY; without even the implied warranty of
 ## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 ## GNU General Public License for more details.
-## 
+##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} untabify (@var{t})
 ## @deftypefnx {Function File} {} untabify (@var{t}, @var{tw})
 ## @deftypefnx {Function File} {} untabify (@var{t}, @var{tw}, @var{deblank})
diff --git a/scripts/testfun/assert.m b/scripts/testfun/assert.m
--- a/scripts/testfun/assert.m
+++ b/scripts/testfun/assert.m
@@ -31,22 +31,22 @@
 ## @itemx assert (@var{cond}, @var{errmsg}, @dots{})
 ## @itemx assert (@var{cond}, @var{msg_id}, @var{errmsg}, @dots{})
 ## Called with a single argument @var{cond}, @code{assert} produces an
 ## error if @var{cond} is zero.  If called with a single argument a
 ## generic error message.  With more than one argument, the additional
 ## arguments are passed to the @code{error} function.
 ##
 ## @item assert (@var{observed}, @var{expected})
-## Produce an error if observed is not the same as expected.  Note that 
-## observed and expected can be strings, scalars, vectors, matrices, 
+## Produce an error if observed is not the same as expected.  Note that
+## observed and expected can be strings, scalars, vectors, matrices,
 ## lists or structures.
 ##
 ## @item assert(@var{observed}, @var{expected}, @var{tol})
-## Accept a tolerance when comparing numbers. 
+## Accept a tolerance when comparing numbers.
 ## If @var{tol} is positive use it as an absolute tolerance, will produce an
 ## error if
 ## @code{abs(@var{observed} - @var{expected}) > abs(@var{tol})}.
 ## If @var{tol} is negative use it as a relative tolerance, will produce an
 ## error if
 ## @code{abs(@var{observed} - @var{expected}) > abs(@var{tol} *
 ## @var{expected})}.  If @var{expected} is zero @var{tol} will always be used as
 ## an absolute tolerance.
@@ -70,17 +70,17 @@ function assert (cond, varargin)
   if (nargin == 1 || (nargin > 1 && islogical (cond) && ischar (varargin{1})))
     if ((! isnumeric (cond) && ! islogical (cond)) || ! all (cond(:)))
       if (nargin == 1)
         ## Say which elements failed?
         error ("assert %s failed", in);
       else
         error (varargin{:});
       endif
-    endif  
+    endif
   else
     if (nargin < 2 || nargin > 3)
       print_usage ();
     endif
 
     expected = varargin {1};
     if (nargin < 3)
       tol = 0;
@@ -192,17 +192,17 @@ function assert (cond, varargin)
           A = A(finite (A));
           B = B(finite (B));
           if (tol == 0)
             err = any (A != B);
             errtype = "values do not match";
           elseif (tol >= 0)
             err = max (abs (A - B));
             errtype = "maximum absolute error %g exceeds tolerance %g";
-          else 
+          else
             abserr = max (abs (A(B == 0)));
             A = A(B != 0);
             B = B(B != 0);
             relerr = max (abs (A - B) ./ abs (B));
             err = max ([abserr; relerr]);
             errtype = "maximum relative error %g exceeds tolerance %g";
           endif
           if (err > abs (tol))
@@ -280,19 +280,19 @@ endfunction
 %!error assert([3,3; 3,3], 3)
 %!assert(3, 3);
 %!assert(3+eps, 3, eps);
 %!assert(3, 3+eps, eps);
 %!error assert(3+2*eps, 3, eps);
 %!error assert(3, 3+2*eps, eps);
 
 ## must give a little space for floating point errors on relative
-%!assert(100+100*eps, 100, -2*eps); 
+%!assert(100+100*eps, 100, -2*eps);
 %!assert(100, 100+100*eps, -2*eps);
-%!error assert(100+300*eps, 100, -2*eps); 
+%!error assert(100+300*eps, 100, -2*eps);
 %!error assert(100, 100+300*eps, -2*eps);
 %!error assert(3, [3,3]);
 %!error assert(3,4);
 
 ## test relative vs. absolute tolerances
 %!test  assert (0.1+eps, 0.1,  2*eps);  # accept absolute
 %!error assert (0.1+eps, 0.1, -2*eps);  # fail relative
 %!test  assert (100+100*eps, 100, -2*eps);  # accept relative
diff --git a/scripts/testfun/demo.m b/scripts/testfun/demo.m
--- a/scripts/testfun/demo.m
+++ b/scripts/testfun/demo.m
@@ -14,22 +14,22 @@
 ##
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn {Function File} {} demo ('@var{name}', @var{n})
 ##
-## Runs any examples associated with the function '@var{name}'.  
-## Examples are stored in the script file, or in a file with the same 
-## name but no extension somewhere on your path.  To keep them separate 
+## Runs any examples associated with the function '@var{name}'.
+## Examples are stored in the script file, or in a file with the same
+## name but no extension somewhere on your path.  To keep them separate
 ## from the usual script code, all lines are prefixed by @code{%!}.  Each
 ## example is introduced by the keyword 'demo' flush left to the prefix,
-## with no intervening spaces.  The remainder of the example can contain 
+## with no intervening spaces.  The remainder of the example can contain
 ## arbitrary Octave code.  For example:
 ##
 ## @example
 ## @group
 ##    %!demo
 ##    %! t=0:0.01:2*pi; x = sin(t);
 ##    %! plot(t,x)
 ##    %! %-------------------------------------------------
diff --git a/scripts/testfun/example.m b/scripts/testfun/example.m
--- a/scripts/testfun/example.m
+++ b/scripts/testfun/example.m
@@ -15,22 +15,22 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} example ('@var{name}', @var{n})
 ## @deftypefnx {Function File} {[@var{x}, @var{idx}] =} example ('@var{name}', @var{n})
 ##
-##  Display the code for example @var{n} associated with the function 
-## '@var{name}', but do not run it.  If @var{n} is not given, all examples 
+##  Display the code for example @var{n} associated with the function
+## '@var{name}', but do not run it.  If @var{n} is not given, all examples
 ## are displayed.
 ##
 ## Called with output arguments, the examples are returned in the form of
-## a string @var{x}, with @var{idx} indicating the ending position of the 
+## a string @var{x}, with @var{idx} indicating the ending position of the
 ## various examples.
 ##
 ## See @code{demo} for a complete explanation.
 ## @seealso{demo, test}
 ## @end deftypefn
 
 function [code_r, idx_r] = example (name, n)
 
@@ -81,14 +81,14 @@ endfunction
 %! example('example');
 %!demo
 %! t=0:0.01:2*pi; x=sin(t);
 %! plot(t,x)
 
 %!assert (example('example',1), "\n example('example');");
 %!test
 %! [code, idx] = example('example');
-%! assert (code, ... 
+%! assert (code, ...
 %!         "\n example('example');\n t=0:0.01:2*pi; x=sin(t);\n plot(t,x)")
 %! assert (idx, [1, 22, 59]);
 
 %!error example;
 %!error example('example',3,5)
diff --git a/scripts/testfun/fail.m b/scripts/testfun/fail.m
--- a/scripts/testfun/fail.m
+++ b/scripts/testfun/fail.m
@@ -23,32 +23,32 @@
 ## @deftypefn  {Function File} {} fail (@var{code}, @var{pattern})
 ## @deftypefnx {Function File} {} fail (@var{code}, 'warning', @var{pattern})
 ##
 ## Return true if @var{code} fails with an error message matching
 ## @var{pattern}, otherwise produce an error.  Note that @var{code}
 ## is a string and if @var{code} runs successfully, the error produced is:
 ##
 ## @example
-##           expected error but got none  
+##           expected error but got none
 ## @end example
 ##
 ## If the code fails with a different error, the message produced is:
 ##
 ## @example
 ## @group
 ##           expected <pattern>
 ##           but got <text of actual error>
 ## @end group
 ## @end example
 ##
 ## The angle brackets are not part of the output.
 ##
-## Called with three arguments, the behavior is similar to 
-## @code{fail(@var{code}, @var{pattern})}, but produces an error if no 
+## Called with three arguments, the behavior is similar to
+## @code{fail(@var{code}, @var{pattern})}, but produces an error if no
 ## warning is given during code execution or if the code fails.
 ##
 ## @end deftypefn
 
 ## Author: Paul Kienzle <pkienzle@users.sf.net>
 
 function ret = fail (code, pattern, warning_pattern)
 
@@ -67,50 +67,50 @@ function ret = fail (code, pattern, warn
   ## match any nonempty message
   if (isempty (pattern))
     pattern = ".";
   endif
 
   ## allow assert(fail())
   if (nargout)
     ret = 1;
-  endif  
+  endif
 
   if (test_warning)
     ## Perform the warning test.
     ## Clear old warnings.
     lastwarn ();
     ## Make sure warnings are turned on.
     state = warning ("query", "quiet");
     warning ("on", "quiet");
     try
       ## printf("lastwarn before %s: %s\n",code,lastwarn);
       evalin ("caller", sprintf ("%s;", code));
       ## printf("lastwarn after %s: %s\n",code,lastwarn);
       ## Retrieve new warnings.
       err = lastwarn ();
       warning (state.state, "quiet");
       if (isempty (err))
-        msg = sprintf ("expected warning <%s> but got none", pattern); 
+        msg = sprintf ("expected warning <%s> but got none", pattern);
       else
         ## Transform "warning: ...\n" to "...".
         err([1:9, end]) = [];
         if (! isempty (regexp (err, pattern, "once")))
           return;
         endif
         msg = sprintf ("expected warning <%s>\nbut got <%s>", pattern, err);
       endif
     catch
       warning (state.state, "quiet");
       err = lasterr;
       ## Transform "error: ...\n", to "...".
       err([1:7, end]) = [];
       msg = sprintf ("expected warning <%s> but got error <%s>", pattern, err);
     end_try_catch
-      
+
   else
     ## Perform the error test.
     try
       evalin ("caller", sprintf ("%s;", code));
       msg = sprintf ("expected error <%s> but got none", pattern);
     catch
       err = lasterr ();
       if (strcmp (err(1:7), "error:"))
diff --git a/scripts/testfun/speed.m b/scripts/testfun/speed.m
--- a/scripts/testfun/speed.m
+++ b/scripts/testfun/speed.m
@@ -15,38 +15,38 @@
 ## You should have received a copy of the GNU General Public License
 ## along with Octave; see the file COPYING.  If not, see
 ## <http://www.gnu.org/licenses/>.
 
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} speed (@var{f}, @var{init}, @var{max_n}, @var{f2}, @var{tol})
 ## @deftypefnx {Function File} {[@var{order}, @var{n}, @var{T_f}, @var{T_f2}] =} speed (@dots{})
 ##
-## Determine the execution time of an expression (@var{f}) for various input 
+## Determine the execution time of an expression (@var{f}) for various input
 ## values (@var{n}).  The @var{n} are log-spaced from 1 to @var{max_n}.  For
-## each @var{n}, an initialization expression (@var{init}) is computed to 
+## each @var{n}, an initialization expression (@var{init}) is computed to
 ## create any data needed for the test.  If a second expression (@var{f2}) is
 ## given then the execution times of the two expressions are compared.  When
 ## called without output arguments the results are displayed graphically.
 ##
 ## @table @code
 ## @item @var{f}
 ## The expression to evaluate.
 ##
 ## @item @var{max_n}
 ## The maximum test length to run.  Default value is 100.  Alternatively,
-## use @code{[min_n, max_n]} or specify the @var{n} exactly with 
+## use @code{[min_n, max_n]} or specify the @var{n} exactly with
 ## @code{[n1, n2, @dots{}, nk]}.
 ##
 ## @item @var{init}
-## Initialization expression for function argument values.  Use @var{k} 
+## Initialization expression for function argument values.  Use @var{k}
 ## for the test number and @var{n} for the size of the test.  This should
 ## compute values for all variables used by @var{f}.  Note that @var{init} will
 ## be evaluated first for @math{k = 0}, so things which are constant throughout
-## the test series can be computed once.  The default value is 
+## the test series can be computed once.  The default value is
 ## @code{@var{x} = randn (@var{n}, 1)}.
 ##
 ## @item @var{f2}
 ## An alternative expression to evaluate, so that the speed of two
 ## expressions can be directly compared.  The default is @code{[]}.
 ##
 ## @item @var{tol}
 ## Tolerance used to compare the results of expression @var{f} and expression
@@ -71,19 +71,19 @@
 ##
 ## @end table
 ##
 ## The slope of the execution time graph shows the approximate
 ## power of the asymptotic running time @math{O(n^p)}.  This
 ## power is plotted for the region over which it is approximated
 ## (the latter half of the graph).  The estimated power is not
 ## very accurate, but should be sufficient to determine the
-## general order of an algorithm.  It should indicate if, for 
-## example, the implementation is unexpectedly @math{O(n^2)} 
-## rather than @math{O(n)} because it extends a vector each 
+## general order of an algorithm.  It should indicate if, for
+## example, the implementation is unexpectedly @math{O(n^2)}
+## rather than @math{O(n)} because it extends a vector each
 ## time through the loop rather than pre-allocating storage.
 ## In the current version of Octave, the following is not the
 ## expected @math{O(n)}.
 ##
 ## @example
 ## speed ("for i = 1:n, y@{i@} = x(i); endfor", "", [1000, 10000])
 ## @end example
 ##
@@ -92,62 +92,62 @@
 ##
 ## @example
 ## @group
 ## speed ("for i = 1:n, y@{i@} = x(i); endfor", ...
 ##        "x = rand (n, 1); y = cell (size (x));", [1000, 10000])
 ## @end group
 ## @end example
 ##
-## An attempt is made to approximate the cost of individual 
+## An attempt is made to approximate the cost of individual
 ## operations, but it is wildly inaccurate.  You can improve the
 ## stability somewhat by doing more work for each @code{n}.  For
 ## example:
 ##
 ## @example
 ## speed ("airy(x)", "x = rand (n, 10)", [10000, 100000])
 ## @end example
 ##
 ## When comparing two different expressions (@var{f}, @var{f2}), the slope
 ## of the line on the speedup ratio graph should be larger than 1 if the new
-## expression is faster.  Better algorithms have a shallow slope.  Generally, 
-## vectorizing an algorithm will not change the slope of the execution 
+## expression is faster.  Better algorithms have a shallow slope.  Generally,
+## vectorizing an algorithm will not change the slope of the execution
 ## time graph, but will shift it relative to the original.  For
 ## example:
 ##
 ## @example
 ## @group
 ## speed ("v = sum (x)", "", [10000, 100000], ...
 ##        "v = 0; for i = 1:length (x), v += x(i); end")
 ## @end group
 ## @end example
-## 
+##
 ## The following is a more complex example.  If there was an original version
-## of @code{xcorr} using for loops and a second version using an FFT, then 
+## of @code{xcorr} using for loops and a second version using an FFT, then
 ## one could compare the run speed for various lags as follows, or for a fixed
 ## lag with varying vector lengths as follows:
 ##
 ## @example
 ## @group
 ## speed ("v = xcorr (x, n)", "x = rand (128, 1);", 100,
 ##        "v2 = xcorr_orig (x, n)", -100*eps)
 ## speed ("v = xcorr (x, 15)", "x = rand (20+n, 1);", 100,
 ##        "v2 = xcorr_orig (x, n)", -100*eps)
 ## @end group
 ## @end example
 ##
 ## Assuming one of the two versions is in xcorr_orig, this
 ## would compare their speed and their output values.  Note that the
 ## FFT version is not exact, so we specify an acceptable tolerance on
 ## the comparison @code{100*eps}, and that the errors should be computed
-## relatively, as @code{abs ((@var{x} - @var{y}) ./ @var{y})} rather than 
+## relatively, as @code{abs ((@var{x} - @var{y}) ./ @var{y})} rather than
 ## absolutely as @code{abs (@var{x} - @var{y})}.
 ##
-## Type @code{example('speed')} to see some real examples.  Note that for 
-## obscure reasons, examples 1 and 2 can not be run directly using 
+## Type @code{example('speed')} to see some real examples.  Note that for
+## obscure reasons, examples 1 and 2 can not be run directly using
 ## @code{demo('speed')}.  Instead use, @code{eval ( example('speed', 1) )}
 ## or @code{eval ( example('speed', 2) )}.
 ## @end deftypefn
 
 ## FIXME: consider two dimensional speedup surfaces for functions like kron.
 function [__order, __test_n, __tnew, __torig] = speed (__f1, __init, __max_n, __f2, __tol)
 
   if (nargin < 1 || nargin > 6)
@@ -202,17 +202,17 @@ function [__order, __test_n, __tnew, __t
     eval (cstrcat (__f2, ";"));
   endif
   eval (cstrcat (__f1, ";"));
 
   ## Run the tests.
   for k = 1:length (__test_n)
     n = __test_n(k);
     eval (cstrcat (__init, ";"));
-    
+
     printf ("n%i = %i  ",k, n);
     fflush (stdout);
     eval (cstrcat ("__t = time();", __f1, "; __v1=ans; __t = time()-__t;"));
     if (__t < 0.25)
       eval (cstrcat ("__t2 = time();", __f1, "; __t2 = time()-__t2;"));
       eval (cstrcat ("__t3 = time();", __f1, "; __t3 = time()-__t3;"));
       __t = min ([__t, __t2, __t3]);
     endif
@@ -225,62 +225,62 @@ function [__order, __test_n, __tnew, __t
         eval (cstrcat ("__t3 = time();", __f2, "; __t3 = time()-__t3;"));
       endif
       __torig(k) = __t;
       if (! isinf(__tol))
         assert (__v1, __v2, __tol);
       endif
     endif
   endfor
-  
+
   ## Drop times of zero.
   if (! isempty (__f2))
     zidx = (__tnew < 100*eps |  __torig < 100*eps);
     __test_n(zidx) = [];
     __tnew(zidx) = [];
     __torig(zidx) = [];
   else
     zidx = (__tnew < 100*eps);
     __test_n(zidx) = [];
     __tnew(zidx) = [];
   endif
 
   ## Approximate time complexity and return it if requested.
   tailidx = ceil(length(__test_n)/2):length(__test_n);
   p = polyfit (log (__test_n(tailidx)), log (__tnew(tailidx)), 1);
-  if (nargout > 0) 
+  if (nargout > 0)
     __order.p = p(1);
     __order.a = exp (p(2));
   endif
 
   ## Plot the data if no output is requested.
   doplot = (nargout == 0);
-  
+
   if (doplot)
     figure;
   endif
 
   if (doplot && ! isempty (__f2))
     subplot (1, 2, 1);
-    semilogx (__test_n, __torig./__tnew, 
+    semilogx (__test_n, __torig./__tnew,
               cstrcat ("-*r;", strrep (__f1, ";", "."), "/",
                       strrep (__f2, ";", "."), ";"),
                __test_n, __tnew./__torig,
               cstrcat ("-*g;", strrep (__f2, ";", "."), "/",
                       strrep (__f1, ";", "."), ";"));
     xlabel ("test length");
     title (__f1);
     ylabel ("speedup ratio");
 
     subplot (1, 2, 2);
     loglog (__test_n, __tnew*1000,
-            cstrcat ("*-g;", strrep (__f1, ";", "."), ";"), 
+            cstrcat ("*-g;", strrep (__f1, ";", "."), ";"),
             __test_n, __torig*1000,
             cstrcat ("*-r;", strrep (__f2,";","."), ";"));
-  
+
     xlabel ("test length");
     ylabel ("best execution time (ms)");
     title (cstrcat ("init: ", __init));
 
     ratio = mean (__torig ./ __tnew);
     printf ("\n\nMean runtime ratio = %.3g for '%s' vs '%s'\n",
             ratio, __f2, __f1);
 
@@ -294,17 +294,17 @@ function [__order, __test_n, __tnew, __t
   endif
 
   if (doplot)
 
     ## Plot time complexity approximation (using milliseconds).
     order = sprintf ("O(n^%g)", round (10*p(1))/10);
     v = polyval (p, log (__test_n(tailidx)));
 
-    loglog (__test_n(tailidx), exp(v)*1000, sprintf ("b;%s;", order)); 
+    loglog (__test_n(tailidx), exp(v)*1000, sprintf ("b;%s;", order));
 
     ## Get base time to 1 digit of accuracy.
     dt = exp (p(2));
     dt = floor (dt/10^floor(log10(dt)))*10^floor(log10(dt));
     if (log10 (dt) >= -0.5)
       time = sprintf ("%g s", dt);
     elseif (log10 (dt) >= -3.5)
       time = sprintf ("%g ms", dt*1e3);
@@ -312,17 +312,17 @@ function [__order, __test_n, __tnew, __t
       time = sprintf ("%g us", dt*1e6);
     else
       time = sprintf ("%g ns", dt*1e9);
     endif
 
     ## Display nicely formatted complexity.
     printf ("\nFor %s:\n", __f1);
     printf ("  asymptotic power: %s\n", order);
-    printf ("  approximate time per operation: %s\n", time); 
+    printf ("  approximate time per operation: %s\n", time);
 
   endif
 
 endfunction
 
 %!demo if 1
 %!  function x = build_orig(n)
 %!    ## extend the target vector on the fly
diff --git a/scripts/testfun/test.m b/scripts/testfun/test.m
--- a/scripts/testfun/test.m
+++ b/scripts/testfun/test.m
@@ -21,41 +21,41 @@
 ## @deftypefnx {Command} {} test @var{name} quiet|normal|verbose
 ## @deftypefnx {Function File} {} test ('@var{name}', 'quiet|normal|verbose', @var{fid})
 ## @deftypefnx {Function File} {} test ([], 'explain', @var{fid})
 ## @deftypefnx {Function File} {@var{success} =} test (@dots{})
 ## @deftypefnx {Function File} {[@var{n}, @var{max}] =} test (@dots{})
 ## @deftypefnx {Function File} {[@var{code}, @var{idx}] =} test ('@var{name}', 'grabdemo')
 ##
 ## Perform tests from the first file in the loadpath matching @var{name}.
-## @code{test} can be called as a command or as a function.  Called with 
+## @code{test} can be called as a command or as a function.  Called with
 ## a single argument @var{name}, the tests are run interactively and stop
 ## after the first error is encountered.
 ##
 ## With a second argument the tests which are performed and the amount of
 ## output is selected.
 ##
 ## @table @asis
 ## @item 'quiet'
 ##  Don't report all the tests as they happen, just the errors.
 ##
 ## @item 'normal'
-## Report all tests as they happen, but don't do tests which require 
+## Report all tests as they happen, but don't do tests which require
 ## user interaction.
 ##
 ## @item 'verbose'
 ## Do tests which require user interaction.
 ## @end table
 ##
 ## The argument @var{fid} can be used to allow batch processing.  Errors
-## can be written to the already open file defined by @var{fid}, and 
+## can be written to the already open file defined by @var{fid}, and
 ## hopefully when Octave crashes this file will tell you what was happening
 ## when it did.  You can use @code{stdout} if you want to see the results as
 ## they happen.  You can also give a file name rather than an @var{fid}, in
-## which case the contents of the file will be replaced with the log from 
+## which case the contents of the file will be replaced with the log from
 ## the current test.
 ##
 ## Called with a single output argument @var{success}, @code{test} returns
 ## true if all of the tests were successful.  Called with two output arguments
 ## @var{n} and @var{max}, the number of successful tests and the total number
 ## of tests in the file @var{name} are returned.
 ##
 ## If the second argument is the string 'grabdemo', the contents of the demo
@@ -83,17 +83,17 @@ function [__ret1, __ret2, __ret3, __ret4
 
   __xfail = 0;
   __xskip = 0;
 
   if (nargin < 2 || isempty (__flag))
     __flag = "quiet";
   endif
   if (nargin < 3)
-    __fid = []; 
+    __fid = [];
   endif
   if (nargin < 1 || nargin > 3
       || (! ischar (__name) && ! isempty (__name)) || ! ischar (__flag))
     print_usage ();
   endif
   if (isempty (__name) && (nargin != 3 || ! strcmp (__flag, "explain")))
     print_usage ();
   endif
@@ -201,19 +201,19 @@ function [__ret1, __ret2, __ret3, __ret4
     endif
     if (__close_fid)
       fclose(__fid);
     endif
     return;
   else
     ## Add a dummy comment block to the end for ease of indexing.
     if (__body (length(__body)) == "\n")
-      __body = sprintf ("\n%s#", __body); 
+      __body = sprintf ("\n%s#", __body);
     else
-      __body = sprintf ("\n%s\n#", __body); 
+      __body = sprintf ("\n%s\n#", __body);
     endif
   endif
 
   ## Chop it up into blocks for evaluation.
   __lineidx = find (__body == "\n");
   __blockidx = __lineidx(find (! isspace (__body(__lineidx+1))))+1;
 
   ## Ready to start tests ... if in batch mode, tell us what is happening.
@@ -284,38 +284,38 @@ function [__ret1, __ret2, __ret3, __ret4
           __success = 0;
           __msg = sprintf ("%sdemo failed\n%s",  __signal_fail, __error_text__);
         end_try_catch
         clear __test__;
 
       endif
       ## Code already processed.
       __code = "";
-      
+
 ### SHARED
 
     elseif (strcmp (__type, "shared"))
       __istest = 0;
 
       ## Separate initialization code from variables.
       __idx = find (__code == "\n");
       if (isempty (__idx))
         __vars = __code;
         __code = "";
       else
         __vars = __code (1:__idx(1)-1);
         __code = __code (__idx(1):length(__code));
       endif
-      
+
       ## Strip comments off the variables.
       __idx = find (__vars == "%" | __vars == "#");
       if (! isempty (__idx))
         __vars = __vars(1:__idx(1)-1);
       endif
-      
+
       ## Assign default values to variables.
       try
         __vars = deblank (__vars);
         if (! isempty (__vars))
           eval (cstrcat (strrep (__vars, ",", "=[];"), "=[];"));
           __shared = __vars;
           __shared_r = cstrcat ("[ ", __vars, "] = ");
         else
@@ -328,19 +328,19 @@ function [__ret1, __ret2, __ret3, __ret4
         __success = 0;
         __msg = sprintf ("%sshared variable initialization failed\n",
                          __signal_fail);
       end_try_catch
 
       ## Clear shared function definitions.
       eval (__clear, "");
       __clear = "";
-      
+
       ## Initialization code will be evaluated below.
-    
+
 ### FUNCTION
 
     elseif (strcmp (__type, "function"))
       __istest = 0;
       persistent __fn = 0;
       __name_position = function_name (__block);
       if (isempty (__name_position))
         __success = 0;
@@ -354,25 +354,25 @@ function [__ret1, __ret2, __ret3, __ret4
           __clear = sprintf ("%sclear %s;\n", __clear, __name);
         catch
           __success = 0;
           __msg = sprintf ("%stest failed: syntax error\n%s",
                            __signal_fail, __error_text__);
         end_try_catch
       endif
       __code = "";
-      
+
 ### ASSERT/FAIL
 
     elseif (strcmp (__type, "assert") || strcmp (__type, "fail"))
       __istest = 1;
       ## Put the keyword back on the code.
       __code = __block;
       ## The code will be evaluated below as a test block.
-      
+
 ### ERROR/WARNING
 
     elseif (strcmp (__type, "error") || strcmp(__type, "warning"))
       __istest = 1;
       __warning = strcmp (__type, "warning");
       [__pattern, __id, __code] = getpattern (__code);
       if (__id)
         __patstr = ["id=",__id];
@@ -382,17 +382,17 @@ function [__ret1, __ret2, __ret3, __ret4
       try
         eval (sprintf ("function __test__(%s)\n%s\nendfunction",
                        __shared, __code));
       catch
         __success = 0;
         __msg = sprintf ("%stest failed: syntax error\n%s",
                          __signal_fail, __error_text__);
       end_try_catch
-      
+
       if (__success)
         __success = 0;
         __warnstate = warning ("query", "quiet");
         warning ("on", "quiet");
         try
           eval (sprintf ("__test__(%s);", __shared));
           if (! __warning)
             __msg = sprintf ("%sexpected %s but got no error\n",
@@ -435,17 +435,17 @@ function [__ret1, __ret2, __ret3, __ret4
           else
             __success = 1;
           endif
         end_try_catch
         clear __test__;
       endif
       ## Code already processed.
       __code = "";
-      
+
 ### TESTIF
 
     elseif (strcmp (__type, "testif"))
       [__e, __feat] = regexp (__code, '^\s*(\S+)', 'end', 'tokens');
       if (isempty (findstr (octave_config_info ("DEFS"), __feat{1}{1})))
         __xskip++;
         __istest = 0;
         __code = ""; # Skip the code.
@@ -486,37 +486,37 @@ function [__ret1, __ret2, __ret3, __ret4
         if (strcmp (__type, "xtest"))
            __msg = sprintf ("%sknown failure\n%s", __signal_fail, __error_text__);
            __xfail++;
         else
            __msg = sprintf ("%stest failed\n%s", __signal_fail, __error_text__);
            __success = 0;
         endif
         if (isempty (__error_text__))
-          error ("empty error text, probably Ctrl-C --- aborting"); 
+          error ("empty error text, probably Ctrl-C --- aborting");
         endif
       end_try_catch
       clear __test__;
     endif
-    
+
     ## All done.  Remember if we were successful and print any messages.
     if (! isempty (__msg))
       ## Make sure the user knows what caused the error.
       if (! __verbose)
         fprintf (__fid, "%s%s\n", __signal_block, __block);
         fflush (__fid);
       endif
       fputs (__fid, __msg);
       fputs (__fid, "\n");
       fflush (__fid);
       ## Show the variable context.
       if (! strcmp (__type, "error") && ! strcmp (__type, "testif")
           && ! all (__shared == " "))
         fputs (__fid, "shared variables ");
-        eval (sprintf ("fdisp(__fid,bundle(%s));", __shared)); 
+        eval (sprintf ("fdisp(__fid,bundle(%s));", __shared));
         fflush (__fid);
       endif
     endif
     if (__success == 0)
       __all_success = 0;
       ## Stop after one error if not in batch mode.
       if (! __batch)
         if (nargout > 0)
@@ -546,17 +546,17 @@ function [__ret1, __ret2, __ret3, __ret4
       endif
     else
       printf ("%s%s has no tests available\n", __signal_empty, __file);
     endif
   elseif (__grabdemo)
     __ret1 = __demo_code;
     __ret2 = __demo_idx;
   elseif (nargout == 1)
-    __ret1 = __all_success; 
+    __ret1 = __all_success;
   else
     __ret1 = __successes;
     __ret2 = __tests;
     __ret3 = __xfail;
     __ret4 = __xskip;
   endif
 endfunction
 
@@ -590,17 +590,17 @@ function pos = function_name (def)
   pos = [left, right];
 endfunction
 
 ## Strip <pattern> from '<pattern> code'.
 ## Also handles 'id=ID code'
 function [pattern, id, rest] = getpattern (str)
   pattern = ".";
   id = [];
-  rest = str; 
+  rest = str;
   str = trimleft (str);
   if (! isempty (str) && str(1) == "<")
     close = index (str, ">");
     if (close)
       pattern = str(2:close-1);
       rest = str(close+1:end);
     endif
   elseif (strncmp (str, "id=", 3))
@@ -680,34 +680,34 @@ endfunction
 ### example from kron
 %!#error kron  # FIXME suppress these until we can handle output
 %!#error kron(1,2,3)
 %!test assert (isempty (kron ([], rand(3, 4))))
 %!test assert (isempty (kron (rand (3, 4), [])))
 %!test assert (isempty (kron ([], [])))
 %!shared A, B
 %!test
-%! A = [1, 2, 3; 4, 5, 6]; 
+%! A = [1, 2, 3; 4, 5, 6];
 %! B = [1, -1; 2, -2];
 %!assert (size (kron (zeros (3, 0), A)), [ 3*rows(A), 0 ])
 %!assert (size (kron (zeros (0, 3), A)), [ 0, 3*columns(A) ])
 %!assert (size (kron (A, zeros (3, 0))), [ 3*rows(A), 0 ])
 %!assert (size (kron (A, zeros (0, 3))), [ 0, 3*columns(A) ])
 %!assert (kron (pi, e), pi*e)
-%!assert (kron (pi, A), pi*A) 
+%!assert (kron (pi, A), pi*A)
 %!assert (kron (A, e), e*A)
 %!assert (kron ([1, 2, 3], A), [ A, 2*A, 3*A ])
 %!assert (kron ([1; 2; 3], A), [ A; 2*A; 3*A ])
 %!assert (kron ([1, 2; 3, 4], A), [ A, 2*A; 3*A, 4*A ])
 %!test
 %! res = [1,-1,2,-2,3,-3; 2,-2,4,-4,6,-6; 4,-4,5,-5,6,-6; 8,-8,10,-10,12,-12];
 %! assert (kron (A, B), res)
 
 ### an extended demo from specgram
-%!#demo 
+%!#demo
 %! ## Speech spectrogram
 %! [x, Fs] = auload(file_in_loadpath("sample.wav")); # audio file
 %! step = fix(5*Fs/1000);     # one spectral slice every 5 ms
 %! window = fix(40*Fs/1000);  # 40 ms data window
 %! fftn = 2^nextpow2(window); # next highest power of 2
 %! [S, f, t] = specgram(x, fftn, Fs, window, window-step);
 %! S = abs(S(2:fftn*4000/Fs,:)); # magnitude in range 0<f<=4000 Hz.
 %! S = S/max(max(S));         # normalize magnitude so that max is 0 dB.
@@ -735,17 +735,17 @@ endfunction
 %!test
 %! lastwarn();            # clear last warning just in case
 
 %!warning <warning message> warning('warning message');
 
 %!## test of shared variables
 %!shared a                # create a shared variable
 %!test   a=3;             # assign to a shared variable
-%!test   assert(a,3)      # variable should equal 3    
+%!test   assert(a,3)      # variable should equal 3
 %!shared b,c              # replace shared variables
 %!test assert (!exist("a"));   # a no longer exists
 %!test assert (isempty(b));    # variables start off empty
 %!shared a,b,c            # recreate a shared variable
 %!test assert (isempty(a));    # value is empty even if it had a previous value
 %!test a=1; b=2; c=3;   # give values to all variables
 %!test assert ([a,b,c],[1,2,3]); # test all of them together
 %!test c=6;             # update a value
@@ -764,17 +764,17 @@ endfunction
 %!test
 %! __test_a(2);                # Test a test function with no return value
 
 %!function [x,z] = __test_a (y)
 %! x = 2*y;
 %! z = 3*y;
 %!test                   # Test a test function with multiple returns
 %! [x,z] = __test_a(3);
-%! assert(x,6); 
+%! assert(x,6);
 %! assert(z,9);
 
 %!## test of assert block
 %!assert (isempty([]))      # support for test assert shorthand
 
 %!## demo blocks
 %!demo                   # multiline demo block
 %! t=[0:0.01:2*pi]; x=sin(t);
@@ -796,17 +796,17 @@ endfunction
 % !bogus                     # unknown block type
 % !error  toeplitz([1,2,3]); # correct usage
 % !test   syntax errors)     # syntax errors fail properly
 % !shared garbage in         # variables must be comma separated
 % !error  syntax++error      # error test fails on syntax errors
 % !error  "succeeds.";       # error test fails if code succeeds
 % !error <wrong pattern> error("message")  # error pattern must match
 % !demo   with syntax error  # syntax errors in demo fail properly
-% !shared a,b,c              
+% !shared a,b,c
 % !demo                      # shared variables not available in demo
 % ! assert(exist("a"))
-% !error  
+% !error
 % ! test('/etc/passwd');
 % ! test("nonexistent file");
-% ! ## These don't signal an error, so the test for an error fails. Note 
+% ! ## These don't signal an error, so the test for an error fails. Note
 % ! ## that the call doesn't reference the current fid (it is unavailable),
 % ! ## so of course the informational message is not printed in the log.
diff --git a/scripts/time/datenum.m b/scripts/time/datenum.m
--- a/scripts/time/datenum.m
+++ b/scripts/time/datenum.m
@@ -19,17 +19,17 @@
 ## -*- texinfo -*-
 ## @deftypefn  {Function File} {} datenum (@var{year}, @var{month}, @var{day})
 ## @deftypefnx {Function File} {} datenum (@var{year}, @var{month}, @var{day}, @var{hour})
 ## @deftypefnx {Function File} {} datenum (@var{year}, @var{month}, @var{day}, @var{hour}, @var{minute})
 ## @deftypefnx {Function File} {} datenum (@var{year}, @var{month}, @var{day}, @var{hour}, @var{minute}, @var{second})
 ## @deftypefnx {Function File} {} datenum (@code{"date"})
 ## @deftypefnx {Function File} {} datenum (@code{"date"}, @var{p})
 ## Returns the specified local time as a day number, with Jan 1, 0000
-## being day 1.  By this reckoning, Jan 1, 1970 is day number 719529.  
+## being day 1.  By this reckoning, Jan 1, 1970 is day number 719529.
 ## The fractional portion, @var{p}, corresponds to the portion of the
 ## specified day.
 ##
 ## Notes:
 ##
 ## @itemize
 ## @item
 ## Years can be negative and/or fractional.
@@ -48,18 +48,18 @@
 ##
 ## @item
 ## Days can be fractional.
 ## @end itemize
 ##
 ## @strong{Warning:} this function does not attempt to handle Julian
 ## calendars so dates before Octave 15, 1582 are wrong by as much
 ## as eleven days.  Also be aware that only Roman Catholic countries
-## adopted the calendar in 1582.  It took until 1924 for it to be 
-## adopted everywhere.  See the Wikipedia entry on the Gregorian 
+## adopted the calendar in 1582.  It took until 1924 for it to be
+## adopted everywhere.  See the Wikipedia entry on the Gregorian
 ## calendar for more details.
 ##
 ## @strong{Warning:} leap seconds are ignored.  A table of leap seconds
 ## is available on the Wikipedia entry for leap seconds.
 ## @seealso{date, clock, now, datestr, datevec, calendar, weekday}
 ## @end deftypefn
 
 ## Algorithm: Peter Baum (http://vsg.cape.com/~pbaum/date/date0.htm)
@@ -89,17 +89,17 @@ function [days, secs] = datenum (year, m
       endif
       second = minute = hour = 0;
       if (nc >= 6) second = year(:,6); endif
       if (nc >= 5) minute = year(:,5); endif
       if (nc >= 4) hour = year(:,4); endif
       day = year(:,3);
       month = year(:,2);
       year = year(:,1);
-    endif 
+    endif
   endif
 
   month(month<1) = 1; ## For compatibility.  Otherwise allow negative months.
 
   ## Set start of year to March by moving Jan. and Feb. to previous year.
   ## Correct for months > 12 by moving to subsequent years.
   year += fix ((month-14)/12);
 
diff --git a/scripts/time/datestr.m b/scripts/time/datestr.m
--- a/scripts/time/datestr.m
+++ b/scripts/time/datestr.m
@@ -231,17 +231,17 @@ function retval = datestr (date, f, p)
 
     df_orig = df;
     df = regexprep (df, '[AP]M', "%p");
     if (strcmp (df, df_orig))
       ## PM not set.
       df = strrep (df, "HH", "%H");
     else
       df = strrep (df, "HH", sprintf ("%2d", v(i,4)));
-    endif  
+    endif
 
     df = regexprep (df, '[Yy][Yy][Yy][Yy]', "%Y");
 
     df = regexprep (df, '[Yy][Yy]', "%y");
 
     df = regexprep (df, '[Dd][Dd][Dd][Dd]', "%A");
 
     df = regexprep (df, '[Dd][Dd][Dd]', "%a");
diff --git a/scripts/time/datetick.m b/scripts/time/datetick.m
--- a/scripts/time/datetick.m
+++ b/scripts/time/datetick.m
@@ -146,36 +146,36 @@ function __datetick__ (varargin)
       xmax = 1;
     elseif (xmin == xmax)
       xmax = xmin + 1;
     endif
 
     N = 3;
     if (xmax - xmin < N)
       ## Day scale or less
-      if (xmax - xmin < N / 24 / 60 / 60) 
+      if (xmax - xmin < N / 24 / 60 / 60)
         scl = 1 / 24 / 60 / 60;
       elseif (xmax - xmin < N / 24 / 6)
         scl = 1 / 24 / 60;
       else
         scl = 1 / 24;
       endif
       sep = __calc_tick_sep__ (xmin / scl , xmax / scl);
       xmin = sep * floor (xmin / scl / sep);
       xmax = sep * ceil (xmax / scl / sep);
       nticks = (xmax - xmin) / sep + 1;
       xmin *= scl;
       xmax *= scl;
     else
       [ymin, mmin, dmin] = datevec (xmin);
       [ymax, mmax, dmax] = datevec (xmax);
-      minyear = ymin + (mmin - 1) / 12 + (dmin - 1) / 12 / 30;    
-      maxyear = ymax + (mmax - 1) / 12 + (dmax - 1) / 12 / 30;    
-      minmonth = mmin + (dmin - 1) / 30;    
-      maxmonth = (ymax  - ymin) * 12 + mmax + (dmax - 1) / 30;    
+      minyear = ymin + (mmin - 1) / 12 + (dmin - 1) / 12 / 30;
+      maxyear = ymax + (mmax - 1) / 12 + (dmax - 1) / 12 / 30;
+      minmonth = mmin + (dmin - 1) / 30;
+      maxmonth = (ymax  - ymin) * 12 + mmax + (dmax - 1) / 30;
 
       if (maxmonth - minmonth < N)
         sep = __calc_tick_sep__ (xmin, xmax);
         xmin = sep * floor (xmin / sep);
         xmax = sep * ceil (xmax / sep);
         nticks = (xmax - xmin) / sep + 1;
       elseif (maxyear - minyear < N)
         sep = __calc_tick_sep__ (minmonth , maxmonth);
@@ -218,34 +218,34 @@ function __datetick__ (varargin)
   endif
 
   if (length (ticks) == 6)
     ## Careful that its not treated as a datevec
     if (! isempty (startdate))
       sticks = strvcat (datestr (ticks(1:end-1) - ticks(1) + startdate, form),
       datestr (ticks(end) - ticks(1) + startdate, form));
     else
-      sticks = strvcat (datestr (ticks(1:end-1), form), 
+      sticks = strvcat (datestr (ticks(1:end-1), form),
       datestr (ticks(end), form));
     endif
   else
     if (! isempty (startdate))
       sticks = datestr (ticks - ticks(1) + startdate, form);
     else
       sticks = datestr (ticks, form);
     endif
   endif
 
   sticks = mat2cell (sticks, ones (rows (sticks), 1), columns (sticks));
 
   if (keepticks)
     if (keeplimits)
       set (gca(), strcat (ax, "ticklabel"), sticks);
     else
-      set (gca(), strcat (ax, "ticklabel"), sticks, strcat (ax, "lim"), 
+      set (gca(), strcat (ax, "ticklabel"), sticks, strcat (ax, "lim"),
       [min(ticks), max(ticks)]);
     endif
   else
     if (keeplimits)
       set (gca(), strcat (ax, "tick"), ticks, strcat (ax, "ticklabel"), sticks);
     else
       set (gca(), strcat (ax, "tick"), ticks, strcat (ax, "ticklabel"), sticks,
       strcat (ax, "lim"), [min(ticks), max(ticks)]);
diff --git a/scripts/time/datevec.m b/scripts/time/datevec.m
--- a/scripts/time/datevec.m
+++ b/scripts/time/datevec.m
@@ -57,17 +57,17 @@ function [y, m, d, h, mi, s] = datevec (
     std_formats{++nfmt} = "dd-mmm-yyyy";            # 1
     std_formats{++nfmt} = "mm/dd/yy";               # 2
     std_formats{++nfmt} = "mm/dd";                  # 6
     std_formats{++nfmt} = "HH:MM:SS";               # 13
     std_formats{++nfmt} = "HH:MM:SS PM";            # 14
     std_formats{++nfmt} = "HH:MM";                  # 15
     std_formats{++nfmt} = "HH:MM PM";               # 16
     std_formats{++nfmt} = "mm/dd/yyyy";             # 23
-    std_formats{++nfmt} = "mmm-dd-yyyy HH:MM:SS"; 
+    std_formats{++nfmt} = "mmm-dd-yyyy HH:MM:SS";
     std_formats{++nfmt} = "mmm-dd-yyyy";
     std_formats{++nfmt} = "dd mmm yyyy HH:MM:SS";
     std_formats{++nfmt} = "dd mmm yyyy";
     std_formats{++nfmt} = "mmm dd yyyy HH:MM:SS";
     std_formats{++nfmt} = "mmm dd yyyy";
     std_formats{++nfmt} = "dd.mmm.yyyy HH:MM:SS";
     std_formats{++nfmt} = "dd.mmm.yyyy";
     std_formats{++nfmt} = "mmm.dd.yyyy HH:MM:SS";
diff --git a/scripts/time/etime.m b/scripts/time/etime.m
--- a/scripts/time/etime.m
+++ b/scripts/time/etime.m
@@ -60,16 +60,16 @@ endfunction
 %!  assert(etime(t2, t1), [1;1]);
 
 %!test
 %! t1 = [1993, 8, 20, 4, 56, 1];
 %! t2 = [1993, 8, 21, 4, 56, 1];
 %! t3 = [1993, 8, 20, 5, 56, 1];
 %! t4 = [1993, 8, 20, 4, 57, 1];
 %! t5 = [1993, 8, 20, 4, 56, 14];
-%! 
+%!
 %! assert((etime (t2, t1) == 86400 && etime (t3, t1) == 3600
 %! && etime (t4, t1) == 60 && etime (t5, t1) == 13));
 
 %!error etime ();
 
 %!error etime (1, 2, 3);
 
