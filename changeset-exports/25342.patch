# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1525322354 14400
#      Thu May 03 00:39:14 2018 -0400
# Node ID 416856765a558a08e4471a8cccd76c29406ce028
# Parent  224779b7c0947f8daaf1d96a4c6e29c071e13b76
be more careful with using auto in place of explicit const iterator decls

* dialog.cc, m-editor/file-editor.cc, octave-qt-link.cc,
call-stack.cc, debug.cc, genprops.awk, graphics.cc, gtk-manager.cc,
gtk-manager.h, load-path.cc, oct-map.cc, oct-stream.cc, regexp.cc,
symscope.h, symtab.h, variables.cc, ov-class.cc, ov-classdef.cc,
ov-fcn-handle.cc, ov-struct.cc, bp-table.cc, jit-ir.cc,
jit-typeinfo.cc, pt-jit.cc, lo-regexp.cc: Only replace explicit const
iterator decls with auto keyword if corresponding object is const.
Otherwise, tag with a fixme comment.

* lo-regexp.h (regexp::match_data::named_patterns): Now const.

diff --git a/libgui/src/dialog.cc b/libgui/src/dialog.cc
--- a/libgui/src/dialog.cc
+++ b/libgui/src/dialog.cc
@@ -225,18 +225,17 @@ namespace octave
       view->setSelectionMode (QAbstractItemView::SingleSelection);
     else if (mode == "multiple")
       view->setSelectionMode (QAbstractItemView::ExtendedSelection);
     else
       view->setSelectionMode (QAbstractItemView::NoSelection);
 
     selector = view->selectionModel ();
     int i = 0;
-    for (auto it = initial.begin ();
-         it != initial.end (); it++)
+    for (auto it = initial.begin (); it != initial.end (); it++)
       {
         QModelIndex idx = m_model->index (initial.value (i++) - 1, 0,
                                           QModelIndex ());
         selector->select (idx, QItemSelectionModel::Select);
       }
 
     bool fixed_layout = false;
     if (wd > 0 && ht > 0)
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -316,17 +316,17 @@ namespace octave
     if (fet)
       m_tab_widget->setCurrentWidget (fet);
   }
 
   // function enabling/disabling the menu accelerators depending on the
   // focus of the editor
   void file_editor::enable_menu_shortcuts (bool enable)
   {
-    auto i = m_hash_menu_text.constBegin ();
+    QHash<QMenu*, QStringList>::const_iterator i = m_hash_menu_text.constBegin ();
 
     while (i != m_hash_menu_text.constEnd ())
       {
         i.key ()->setTitle (i.value ().at (! enable));
         ++i;
       }
 
     // when editor loses focus, enable the actions, which are always active
@@ -372,17 +372,19 @@ namespace octave
 
     // save filenames (even if last session will not be restored next time)
     // together with encoding and the tab index
     QStringList fetFileNames;
     QStringList fet_encodings;
     QStringList fet_index;
 
     // save all open tabs before they are definitely closed
-    for (auto p = m_editor_tab_map.begin (); p != m_editor_tab_map.end (); p++)
+    // FIXME: use cbegin and auto decl here when available.
+    for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
+         p != m_editor_tab_map.end (); p++)
       {
         QString file_name = p->first;   // get file name of tab
         if (! file_name.isEmpty ())      // do not append unnamed files
           {
             fetFileNames.append (file_name);
             fet_encodings.append (m_editor_tab_map[file_name].encoding);
             QString index;
             fet_index.append (index.setNum
@@ -943,17 +945,18 @@ namespace octave
         m_tmp_closed_files << old_name;  // for reloading if error removing
 
         if (! new_name.isEmpty ())
           m_tmp_closed_files << new_name;  // store new name
         else
           m_tmp_closed_files << ""; // no new name, just removing this file
 
         // Get and store the related encoding
-        for (auto p = m_editor_tab_map.begin ();
+        // FIXME: use cbegin and auto decl here when available.
+        for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
              p != m_editor_tab_map.end (); p++)
           {
             if (editor_tab == p->second.fet_ID)
               {
                 m_tmp_closed_files << p->second.encoding;
                 break;
               }
           }
@@ -2310,17 +2313,18 @@ namespace octave
   {
     QDir old_dir (old_name);
 
     // Have all file editor tabs signal what their filenames are.
     m_editor_tab_map.clear ();
     emit fetab_file_name_query (nullptr);
 
     // Loop over all open files and pick those within old_dir
-    for (auto p = m_editor_tab_map.begin ();
+    // FIXME: use cbegin and auto decl here when available.
+    for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
          p != m_editor_tab_map.end (); p++)
       {
         QString rel_path_to_file = old_dir.relativeFilePath (p->first);
         if (rel_path_to_file.left (3) != QString ("../"))
           {
             // We directly go down from old_dir to reach our file: Our
             // file is included in the removed/renamed diectory.
             // Thus delete it.
@@ -2361,17 +2365,18 @@ namespace octave
   {
     // Have all file editor tabs signal what their filenames are.
     m_editor_tab_map.clear ();
     emit fetab_file_name_query (nullptr);
 
     // Check all tabs for the given file name
     QWidget *retval = nullptr;
 
-    for (auto p = m_editor_tab_map.begin ();
+    // FIXME: use cbegin and auto decl here when available.
+    for (editor_tab_map_const_iterator p = m_editor_tab_map.begin ();
          p != m_editor_tab_map.end (); p++)
       {
         QString tab_file = p->first;
         if (same_file (file.toStdString (), tab_file.toStdString ())
             || file == tab_file)     // needed as same_file ("","") is false.
           {
             retval = p->second.fet_ID;
             break;
diff --git a/libgui/src/octave-qt-link.cc b/libgui/src/octave-qt-link.cc
--- a/libgui/src/octave-qt-link.cc
+++ b/libgui/src/octave-qt-link.cc
@@ -327,17 +327,18 @@ namespace octave
 
     // Add all the file dialog results to a string list.
     const QStringList *inputLine = uiwidget_creator.get_string_list ();
 
     for (auto it = inputLine->begin (); it != inputLine->end (); it++)
       retval.push_back (it->toStdString ());
 
     retval.push_back (uiwidget_creator.get_dialog_path ()->toStdString ());
-    retval.push_back ((QString ("%1").arg (uiwidget_creator.get_dialog_result ())).toStdString ());
+    retval.push_back ((QString ("%1").arg (
+                                           uiwidget_creator.get_dialog_result ())).toStdString ());
 
     uiwidget_creator.unlock ();
 
     return retval;
   }
 
   // Prompt to allow file to be run by setting cwd (or if addpath_option==true,
   // alternatively setting the path).
diff --git a/libinterp/corefcn/call-stack.cc b/libinterp/corefcn/call-stack.cc
--- a/libinterp/corefcn/call-stack.cc
+++ b/libinterp/corefcn/call-stack.cc
@@ -132,17 +132,18 @@ namespace octave
 
     // Look for the caller of dbstack.
     size_t xframe = cs[curr_frame].m_prev;
 
     bool found = false;
 
     size_t k = cs.size ();
 
-    for (auto p = cs.rbegin (); p != cs.rend (); p++)
+    // FIXME: use crend and auto decl here when available.
+    for (const_reverse_iterator p = cs.rbegin (); p != cs.rend (); p++)
       {
         octave_function *f = (*p).m_fcn;
 
         if (--k == xframe)
           found = true;
 
         if (f && f->is_user_code ())
           {
@@ -160,17 +161,18 @@ namespace octave
     return retval;
   }
 
   octave_user_code *
   call_stack::caller_user_code (size_t nskip) const
   {
     octave_user_code *retval = nullptr;
 
-    auto p = cs.end ();
+    // FIXME: use cend and auto decl here when available.
+    const_iterator p = cs.end ();
 
     while (p != cs.begin ())
       {
         const stack_frame& elt = *(--p);
 
         octave_function *f = elt.m_fcn;
 
         if (f && f->is_user_code ())
@@ -188,17 +190,18 @@ namespace octave
     return retval;
   }
 
   int
   call_stack::caller_user_code_line (void) const
   {
     int retval = -1;
 
-    auto p = cs.end ();
+    // FIXME: use cend and auto decl here when available.
+    const_iterator p = cs.end ();
 
     while (p != cs.begin ())
       {
         const stack_frame& elt = *(--p);
 
         octave_function *f = elt.m_fcn;
 
         if (f && f->is_user_code ())
@@ -214,17 +217,18 @@ namespace octave
     return retval;
   }
 
   int
   call_stack::caller_user_code_column (void) const
   {
     int retval = -1;
 
-    auto p = cs.end ();
+    // FIXME: use cend and auto decl here when available.
+    const_iterator p = cs.end ();
 
     while (p != cs.begin ())
       {
         const stack_frame& elt = *(--p);
 
         octave_function *f = elt.m_fcn;
 
         if (f && f->is_user_code ())
@@ -330,17 +334,18 @@ namespace octave
     return retval;
   }
 
   bool
   call_stack::all_scripts (void) const
   {
     bool retval = true;
 
-    auto p = cs.end ();
+    // FIXME: use cend and auto decl here when available.
+    const_iterator p = cs.end ();
 
     while (p != cs.begin ())
       {
         const stack_frame& elt = *(--p);
 
         octave_function *f = elt.m_fcn;
 
         if (f && ! f->is_user_script ())
@@ -545,17 +550,18 @@ namespace octave
 
     size_t nframes = (nskip <= user_code_frames ? user_code_frames - nskip : 0);
 
     // Our list is reversed.
     curr_user_frame = nframes - curr_user_frame - 1;
 
     if (nframes > 0)
       {
-        for (auto p = cs.rbegin (); p != cs.rend (); p++)
+        // FIXME: use crbegin and auto decl here when available.
+        for (const_reverse_iterator p = cs.rbegin (); p != cs.rend (); p++)
           {
             const stack_frame& elt = *p;
 
             octave_function *f = elt.m_fcn;
 
             if (f && f->is_user_code ())
               {
                 if (nskip > 0)
diff --git a/libinterp/corefcn/debug.cc b/libinterp/corefcn/debug.cc
--- a/libinterp/corefcn/debug.cc
+++ b/libinterp/corefcn/debug.cc
@@ -61,17 +61,17 @@ static octave_value
 intmap_to_ov (const octave::bp_table::intmap& line)
 {
   int idx = 0;
 
   NDArray retval (dim_vector (1, line.size ()));
 
   for (size_t i = 0; i < line.size (); i++)
     {
-      auto p = line.find (i);
+      octave::bp_table::const_intmap_iterator p = line.find (i);
 
       if (p != line.end ())
         {
           int lineno = p->second;
           retval(idx++) = lineno;
         }
     }
 
@@ -490,17 +490,17 @@ The @qcode{"warn"} field is set similarl
             }
         }
 
       retmap.assign ("name", names);
       retmap.assign ("file", file);
       retmap.assign ("line", line);
       retmap.assign ("cond", cond);
 
-      octave_map ew = bptab.stop_on_err_warn_status (false);
+      const octave_map ew = bptab.stop_on_err_warn_status (false);
       if (ew.isempty ())
         {
           retval = octave_value (retmap);
         }
       else
         {
           octave_map outer (dim_vector (3,1));
           outer.assign ("bkpt", Cell (retmap));
diff --git a/libinterp/corefcn/genprops.awk b/libinterp/corefcn/genprops.awk
--- a/libinterp/corefcn/genprops.awk
+++ b/libinterp/corefcn/genprops.awk
@@ -672,17 +672,17 @@ function emit_source ()
     ## all_property_names
     printf ("std::set<std::string>\n");
     if (base)
         printf ("base_properties");
     else
       printf ("%s::properties", class_name);
     printf ("::all_property_names (void) const\n{\n  static std::set<std::string> all_pnames = core_property_names ();\n\n");
     if (base)
-      printf ("  std::set<std::string> retval = all_pnames;\n  std::set<std::string> dyn_props = dynamic_property_names ();\n  retval.insert (dyn_props.begin (), dyn_props.end ());\n  for (auto p = all_props.begin ();\n       p != all_props.end (); p++)\n    retval.insert (p->first);\n\n  return retval;\n}\n\n");
+      printf ("  std::set<std::string> retval = all_pnames;\n  std::set<std::string> dyn_props = dynamic_property_names ();\n  retval.insert (dyn_props.begin (), dyn_props.end ());\n  for (std::map<caseless_str, property, cmp_caseless_str>::const_iterator p = all_props.begin ();\n       p != all_props.end (); p++)\n    retval.insert (p->first);\n\n  return retval;\n}\n\n");
     else
       printf ("  std::set<std::string> retval = all_pnames;\n  std::set<std::string> base_props = base_properties::all_property_names ();\n  retval.insert (base_props.begin (), base_props.end ());\n\n  return retval;\n}\n\n");
 
     if (! base)
       printf ("bool\n%s::properties::has_property (const caseless_str& pname) const\n{\n  std::set<std::string> pnames = all_property_names ();\n\n  return pnames.find (pname) != pnames.end ();\n}\n\n", class_name);
   }
 }
 
diff --git a/libinterp/corefcn/graphics.cc b/libinterp/corefcn/graphics.cc
--- a/libinterp/corefcn/graphics.cc
+++ b/libinterp/corefcn/graphics.cc
@@ -1910,17 +1910,18 @@ property::create (const std::string& nam
       caseless_str go_name, go_rest;
 
       if (! lookup_object_name (type, go_name, go_rest))
         error ("addproperty: unsupported type for dynamic property (= %s)",
                type.c_str ());
 
       graphics_object go;
 
-      auto it = dprop_obj_map.find (go_name);
+      std::map<caseless_str, graphics_object>::const_iterator it =
+        dprop_obj_map.find (go_name);
 
       if (it == dprop_obj_map.end ())
         {
           base_graphics_object *bgo =
             make_graphics_object_from_type (go_name);
 
           if (bgo)
             {
@@ -2290,23 +2291,23 @@ property_list::lookup (const caseless_st
       if (offset > 0)
         {
           std::string pname = name.substr (offset);
 
           std::transform (pfx.begin (), pfx.end (), pfx.begin (), tolower);
           std::transform (pname.begin (), pname.end (), pname.begin (),
                           tolower);
 
-          auto p = find (pfx);
+          plist_map_const_iterator p = find (pfx);
 
           if (p != end ())
             {
               const pval_map_type& pval_map = p->second;
 
-              auto q = pval_map.find (pname);
+              pval_map_const_iterator q = pval_map.find (pname);
 
               if (q != pval_map.end ())
                 retval = q->second;
             }
         }
     }
 
   return retval;
@@ -3044,17 +3045,17 @@ xreset_default_properties (graphics_hand
 // ---------------------------------------------------------------------
 
 void
 base_properties::set_from_list (base_graphics_object& bgo,
                                 property_list& defaults)
 {
   std::string go_name = graphics_object_name ();
 
-  auto plist = defaults.find (go_name);
+  property_list::plist_map_const_iterator plist = defaults.find (go_name);
 
   if (plist != defaults.end ())
     {
       const property_list::pval_map_type pval_map = plist->second;
 
       for (const auto& prop_val : pval_map)
         {
           std::string pname = prop_val.first;
@@ -3085,30 +3086,32 @@ base_properties::set_from_list (base_gra
 %!   set(0, "defaultfigureunits", "remove");
 %!   set(0, "defaultfigureposition", "remove");
 %! end_unwind_protect
 */
 
 octave_value
 base_properties::get_dynamic (const caseless_str& pname) const
 {
-  auto it = all_props.find (pname);
+  std::map<caseless_str, property, cmp_caseless_str>::const_iterator it =
+    all_props.find (pname);
 
   if (it == all_props.end ())
     error (R"(get: unknown property "%s")", pname.c_str ());
 
   return it->second.get ();
 }
 
 octave_value
 base_properties::get_dynamic (bool all) const
 {
   octave_scalar_map m;
 
-  for (auto it = all_props.begin (); it != all_props.end (); ++it)
+  for (std::map<caseless_str, property, cmp_caseless_str>::const_iterator
+       it = all_props.begin (); it != all_props.end (); ++it)
     if (all || ! it->second.is_hidden ())
       m.assign (it->second.get_name (), it->second.get ());
 
   return m;
 }
 
 std::set<std::string>
 base_properties::dynamic_property_names (void) const
@@ -3141,17 +3144,18 @@ base_properties::set_dynamic (const case
   dynamic_properties.insert (pname);
 
   mark_modified ();
 }
 
 property
 base_properties::get_property_dynamic (const caseless_str& pname)
 {
-  auto it = all_props.find (pname);
+  std::map<caseless_str, property, cmp_caseless_str>::const_iterator it =
+    all_props.find (pname);
 
   if (it == all_props.end ())
     error (R"(get_property: unknown property "%s")", pname.c_str ());
 
   return it->second;
 }
 
 void
diff --git a/libinterp/corefcn/gtk-manager.cc b/libinterp/corefcn/gtk-manager.cc
--- a/libinterp/corefcn/gtk-manager.cc
+++ b/libinterp/corefcn/gtk-manager.cc
@@ -35,21 +35,21 @@ namespace octave
   graphics_toolkit
   gtk_manager::get_toolkit (void) const
   {
     graphics_toolkit retval;
 
     if (dtk.empty ())
       error ("no graphics toolkits are available!");
 
-    auto pl = loaded_toolkits.find (dtk);
+    const_loaded_toolkits_iterator pl = loaded_toolkits.find (dtk);
 
     if (pl == loaded_toolkits.end ())
       {
-        auto pa = available_toolkits.find (dtk);
+        const_available_toolkits_iterator pa = available_toolkits.find (dtk);
 
         if (pa == available_toolkits.end ())
           error ("default graphics toolkit '%s' is not available!",
                  dtk.c_str ());
 
         octave_value_list args;
         args(0) = dtk;
         feval ("graphics_toolkit", args);
@@ -84,17 +84,18 @@ namespace octave
     available_toolkits.erase (name);
 
     if (dtk == name)
       {
         if (available_toolkits.empty ())
           dtk.clear ();
         else
           {
-            auto pa = available_toolkits.begin ();
+            // FIXME: use cbegin and auto decl here when available.
+            const_available_toolkits_iterator pa = available_toolkits.begin ();
 
             dtk = *pa++;
 
             while (pa != available_toolkits.end ())
               {
                 std::string tk_name = *pa++;
 
                 if (tk_name == "qt"
diff --git a/libinterp/corefcn/gtk-manager.h b/libinterp/corefcn/gtk-manager.h
--- a/libinterp/corefcn/gtk-manager.h
+++ b/libinterp/corefcn/gtk-manager.h
@@ -58,17 +58,17 @@ namespace octave
 
     void unload_toolkit (const std::string& name)
     {
       loaded_toolkits.erase (name);
     }
 
     graphics_toolkit find_toolkit (const std::string& name) const
     {
-      auto p = loaded_toolkits.find (name);
+      const_loaded_toolkits_iterator p = loaded_toolkits.find (name);
 
       if (p != loaded_toolkits.end ())
         return p->second;
       else
         return graphics_toolkit ();
     }
 
     Cell available_toolkits_list (void) const
diff --git a/libinterp/corefcn/load-path.cc b/libinterp/corefcn/load-path.cc
--- a/libinterp/corefcn/load-path.cc
+++ b/libinterp/corefcn/load-path.cc
@@ -742,17 +742,17 @@ namespace octave
     return retval;
   }
 
   string_vector
   load_path::files (const std::string& dir, bool omit_exts) const
   {
     string_vector retval;
 
-    auto p = find_dir_info (dir);
+    const_dir_info_list_iterator p = find_dir_info (dir);
 
     if (p != dir_info_list.end ())
       retval = p->fcn_files;
 
     if (omit_exts)
       {
         octave_idx_type len = retval.numel ();
 
@@ -847,17 +847,18 @@ namespace octave
 
   // FIXME: maybe we should also maintain a map to speed up this method of access.
 
   load_path::const_dir_info_list_iterator
   load_path::find_dir_info (const std::string& dir_arg) const
   {
     std::string dir = sys::file_ops::tilde_expand (dir_arg);
 
-    auto retval = dir_info_list.begin ();
+    // FIXME: use cbegin and auto decl here when available.
+    const_dir_info_list_iterator retval = dir_info_list.begin ();
 
     while (retval != dir_info_list.end ())
       {
         if (retval->dir_name == dir)
           break;
 
         retval++;
       }
@@ -1126,17 +1127,17 @@ namespace octave
     else
       {
         if (is_relative)
           {
             try
               {
                 std::string abs_name = sys::env::make_absolute (dir_name);
 
-                auto p = abs_dir_cache.find (abs_name);
+                const_abs_dir_cache_iterator p = abs_dir_cache.find (abs_name);
 
                 if (p != abs_dir_cache.end ())
                   {
                     // The directory is in the cache of all directories we have
                     // visited (indexed by absolute name).  If it is out of date,
                     // initialize it.  Otherwise, copy the info from the cache.
                     // By doing that, we avoid unnecessary calls to stat that can
                     // slow things down tremendously for large directories.
@@ -1185,17 +1186,17 @@ namespace octave
 
     if (pos == std::string::npos)
       return package_dir_map.find (name) != package_dir_map.end ();
     else
       {
         std::string name_head = name.substr (0, pos);
         std::string name_tail = name.substr (pos + 1);
 
-        auto it = package_dir_map.find (name_head);
+        const_package_dir_map_iterator it = package_dir_map.find (name_head);
 
         if (it != package_dir_map.end ())
           return it->second.is_package (name_tail);
         else
           return false;
       }
   }
 
@@ -1466,17 +1467,17 @@ namespace octave
           }
         else
           retval = "";
       }
     else
       {
         dir_name = "";
 
-        auto p = fcn_map.find (fcn);
+        const_fcn_map_iterator p = fcn_map.find (fcn);
 
         if (p != fcn_map.end ())
           {
             const file_info_list_type& file_info_list = p->second;
 
             for (const auto& fi : file_info_list)
               {
                 retval = sys::file_ops::concat (fi.dir_name, fcn);
@@ -1500,23 +1501,23 @@ namespace octave
   load_path::package_info::find_private_fcn (const std::string& dir,
                                              const std::string& fcn,
                                              int type) const
   {
     std::string retval;
 
     //  update ();
 
-    auto q = private_fcn_map.find (dir);
+    const_private_fcn_map_iterator q = private_fcn_map.find (dir);
 
     if (q != private_fcn_map.end ())
       {
         const dir_info::fcn_file_map_type& m = q->second;
 
-        auto p = m.find (fcn);
+        dir_info::const_fcn_file_map_iterator p = m.find (fcn);
 
         if (p != m.end ())
           {
             std::string fname
               = sys::file_ops::concat (sys::file_ops::concat (dir, "private"), fcn);
 
             if (check_file_type (fname, type, p->second, fcn,
                                  "load_path::find_private_fcn"))
@@ -1534,23 +1535,23 @@ namespace octave
                                         int type) const
   {
     std::string retval;
 
     //  update ();
 
     dir_name = "";
 
-    auto q = method_map.find (class_name);
+    const_method_map_iterator q = method_map.find (class_name);
 
     if (q != method_map.end ())
       {
         const fcn_map_type& m = q->second;
 
-        auto p = m.find (meth);
+        const_fcn_map_iterator p = m.find (meth);
 
         if (p != m.end ())
           {
             const file_info_list_type& file_info_list = p->second;
 
             for (const auto& fi : file_info_list)
               {
                 retval = sys::file_ops::concat (fi.dir_name, meth);
@@ -1574,17 +1575,17 @@ namespace octave
 
   std::list<std::string>
   load_path::package_info::methods (const std::string& class_name) const
   {
     std::list<std::string> retval;
 
     //  update ();
 
-    auto mtd_map_it = method_map.find (class_name);
+    const_method_map_iterator mtd_map_it = method_map.find (class_name);
 
     if (mtd_map_it != method_map.end ())
       {
         for (const auto& nm_filst : mtd_map_it->second)
           retval.push_back (nm_filst.first);
       }
 
     if (! retval.empty ())
diff --git a/libinterp/corefcn/oct-map.cc b/libinterp/corefcn/oct-map.cc
--- a/libinterp/corefcn/oct-map.cc
+++ b/libinterp/corefcn/oct-map.cc
@@ -1317,19 +1317,21 @@ octave_map::delete_elements (const octav
 %! assert (fieldnames (x([1, 2], [2:5])), {"d"; "a"; "f"});
 */
 
 octave_map
 octave_map::concat (const octave_map& rb, const Array<octave_idx_type>& ra_idx)
 {
   if (nfields () == rb.nfields ())
     {
-      for (auto pa = begin (); pa != end (); pa++)
+      // FIXME: use cbegin and auto decl here when available.
+      for (const_iterator pa = begin (); pa != end (); pa++)
         {
-          auto pb = rb.seek (key (pa));
+          // FIXME: use cbegin and auto decl here when available.
+          const_iterator pb = rb.seek (key (pa));
 
           if (pb == rb.end ())
             error ("field name mismatch in structure concatenation");
 
           contents(pa).insert (rb.contents (pb), ra_idx);
         }
     }
   else
diff --git a/libinterp/corefcn/oct-stream.cc b/libinterp/corefcn/oct-stream.cc
--- a/libinterp/corefcn/oct-stream.cc
+++ b/libinterp/corefcn/oct-stream.cc
@@ -6307,17 +6307,19 @@ namespace octave
     typedef typename DST_T::element_type dst_elt_type;
 
     DST_T conv (dim_vector (nr, nc));
 
     dst_elt_type *conv_data = conv.fortran_vec ();
 
     octave_idx_type j = 0;
 
-    for (auto it = input_buf_list.begin (); it != input_buf_list.end (); it++)
+    // FIXME: use cbegin and auto decl here when available.
+    for (std::list<void *>::const_iterator it = input_buf_list.begin ();
+         it != input_buf_list.end (); it++)
       {
         SRC_T *data = static_cast<SRC_T *> (*it);
 
         if (swap || do_float_fmt_conv)
           {
             if (do_NA_conv)
               {
                 for (octave_idx_type i = 0; i < input_buf_elts && j < elts_read;
@@ -7352,17 +7354,17 @@ namespace octave
 
     if (fid < 0)
       err_invalid_file_id (fid, who);
 
     if (lookup_cache != list.end () && lookup_cache->first == fid)
       retval = lookup_cache->second;
     else
       {
-        auto iter = list.find (fid);
+        ostrl_map::const_iterator iter = list.find (fid);
 
         if (iter == list.end ())
           err_invalid_file_id (fid, who);
 
         retval = iter->second;
         lookup_cache = iter;
       }
 
@@ -7469,17 +7471,17 @@ namespace octave
     if (fid < 0)
       return retval;
 
     stream os;
     if (lookup_cache != list.end () && lookup_cache->first == fid)
       os = lookup_cache->second;
     else
       {
-        auto iter = list.find (fid);
+        ostrl_map::const_iterator iter = list.find (fid);
 
         if (iter == list.end ())
           return retval;
 
         os = iter->second;
         lookup_cache = iter;
       }
 
diff --git a/libinterp/corefcn/regexp.cc b/libinterp/corefcn/regexp.cc
--- a/libinterp/corefcn/regexp.cc
+++ b/libinterp/corefcn/regexp.cc
@@ -369,17 +369,17 @@ octregexp (const octave_value_list& args
   // Rewrite pattern for PCRE
   pattern = do_regexp_ptn_string_escapes (pattern, args(1).is_sq_string ());
 
   octave::regexp::opts options;
   options.case_insensitive (case_insensitive);
   bool extra_options = false;
   parse_options (options, args, who, 2, extra_options);
 
-  octave::regexp::match_data rx_lst
+  const octave::regexp::match_data rx_lst
     = octave::regexp::match (pattern, buffer, options, who);
 
   string_vector named_pats = rx_lst.named_patterns ();
 
   size_t sz = rx_lst.size ();
 
   // Converted the linked list in the correct form for the return values
 
diff --git a/libinterp/corefcn/symscope.h b/libinterp/corefcn/symscope.h
--- a/libinterp/corefcn/symscope.h
+++ b/libinterp/corefcn/symscope.h
@@ -225,27 +225,27 @@ namespace octave
           sr.assign (value, m_context);
         }
       else
         p->second.assign (value, m_context);
     }
 
     octave_value varval (const std::string& name) const
     {
-      auto p = m_symbols.find (name);
+      table_const_iterator p = m_symbols.find (name);
 
       return (p != m_symbols.end ()
               ? p->second.varval (m_context) : octave_value ());
     }
 
     bool is_variable (const std::string& name) const
     {
       bool retval = false;
 
-      auto p = m_symbols.find (name);
+      table_const_iterator p = m_symbols.find (name);
 
       if (p != m_symbols.end ())
         {
           const symbol_record& sr = p->second;
 
           retval = sr.is_variable (m_context);
         }
 
@@ -457,26 +457,26 @@ namespace octave
 
       retval.sort ();
 
       return retval;
     }
 
     bool is_local_variable (const std::string& name) const
     {
-      auto p = m_symbols.find (name);
+      table_const_iterator p = m_symbols.find (name);
 
       return (p != m_symbols.end ()
               && ! p->second.is_global ()
               && p->second.is_defined (m_context));
     }
 
     bool is_global (const std::string& name) const
     {
-      auto p = m_symbols.find (name);
+      table_const_iterator p = m_symbols.find (name);
 
       return p != m_symbols.end () && p->second.is_global ();
     }
 
     void install_subfunction (const std::string& name,
                               const octave_value& fval)
     {
       m_subfunctions[name] = fval;
diff --git a/libinterp/corefcn/symtab.h b/libinterp/corefcn/symtab.h
--- a/libinterp/corefcn/symtab.h
+++ b/libinterp/corefcn/symtab.h
@@ -194,17 +194,17 @@ namespace octave
       octave_value val = find_built_in_function (name);
 
       return val.is_defined ();
     }
 
     octave_value
     find_method (const std::string& name, const std::string& dispatch_type)
     {
-      auto p = m_fcn_table.find (name);
+      fcn_table_const_iterator p = m_fcn_table.find (name);
 
       if (p != m_fcn_table.end ())
         {
           octave_value fcn = p->second.find_method (dispatch_type);
 
           if (! fcn.is_defined ())
             fcn = find_submethod (name, dispatch_type);
 
@@ -227,17 +227,17 @@ namespace octave
     }
 
     octave_value
     find_submethod (const std::string& name, const std::string& dispatch_type);
 
     octave_value
     find_built_in_function (const std::string& name)
     {
-      auto p = m_fcn_table.find (name);
+      fcn_table_const_iterator p = m_fcn_table.find (name);
 
       return (p != m_fcn_table.end ()
               ? p->second.find_built_in_function () : octave_value ());
     }
 
     octave_value
     find_autoload (const std::string& name)
     {
@@ -635,17 +635,17 @@ namespace octave
       m_parent_map[classname] = parent_list;
     }
 
     std::list<std::string>
     parent_classes (const std::string& dispatch_type)
     {
       std::list<std::string> retval;
 
-      auto it = m_parent_map.find (dispatch_type);
+      const_parent_map_iterator it = m_parent_map.find (dispatch_type);
 
       if (it != m_parent_map.end ())
         retval = it->second;
 
       for (const auto& nm : retval)
         {
           // Search for parents of parents and append them to the list.
 
diff --git a/libinterp/corefcn/variables.cc b/libinterp/corefcn/variables.cc
--- a/libinterp/corefcn/variables.cc
+++ b/libinterp/corefcn/variables.cc
@@ -1325,17 +1325,18 @@ public:
     Cell bytes_info (len, 1);
     Cell class_info (len, 1);
     Cell global_info (len, 1);
     Cell sparse_info (len, 1);
     Cell complex_info (len, 1);
     Cell nesting_info (len, 1);
     Cell persistent_info (len, 1);
 
-    auto p = lst.begin ();
+    // FIXME: use cbegin and auto decl here when available.
+    std::list<symbol_info>::const_iterator p = lst.begin ();
 
     for (size_t j = 0; j < len; j++)
       {
         const symbol_info& si = *p++;
 
         octave_scalar_map ni;
 
         ni.assign ("function", caller_function_name);
diff --git a/libinterp/octave-value/ov-class.cc b/libinterp/octave-value/ov-class.cc
--- a/libinterp/octave-value/ov-class.cc
+++ b/libinterp/octave-value/ov-class.cc
@@ -277,17 +277,17 @@ octave_class::dotref (const octave_value
 
   if (obvp == nullptr)
     error ("malformed class");
 
   octave_map my_map = (obvp != this) ? obvp->map_value () : map;
 
   std::string nm = idx(0).xstring_value ("invalid index for class");
 
-  auto p = my_map.seek (nm);
+  octave_map::const_iterator p = my_map.seek (nm);
 
   if (p == my_map.end ())
     error ("class has no member '%s'", nm.c_str ());
 
   return my_map.contents (p);
 }
 
 Matrix
@@ -841,17 +841,18 @@ octave_class::index_vector (bool require
 
 size_t
 octave_class::byte_size (void) const
 {
   // Neglect the size of the fieldnames.
 
   size_t retval = 0;
 
-  for (auto it = map.begin (); it != map.end (); it++)
+  // FIXME: use cbegin and auto decl here when available.
+  for (octave_map::const_iterator it = map.begin (); it != map.end (); it++)
     {
       std::string key = map.key (it);
 
       octave_value val = octave_value (map.contents (it));
 
       retval += val.byte_size ();
     }
 
@@ -891,17 +892,17 @@ octave_class::find_parent_class (const s
   octave_base_value *retval = nullptr;
 
   if (parent_class_name == class_name ())
     retval = this;
   else
     {
       for (auto& par : parent_list)
         {
-          auto smap = map.seek (par);
+          octave_map::const_iterator smap = map.seek (par);
 
           const Cell& tmp = map.contents (smap);
 
           octave_value vtmp = tmp(0);
 
           octave_base_value *obvp = vtmp.internal_rep ();
 
           retval = obvp->find_parent_class (parent_class_name);
@@ -956,17 +957,17 @@ octave_class::is_instance_of (const std:
   bool retval = false;
 
   if (cls_name == class_name ())
     retval = true;
   else
     {
       for (auto& par : parent_list)
         {
-          auto smap = map.seek (par);
+          octave_map::const_iterator smap = map.seek (par);
 
           const Cell& tmp = map.contents (smap);
 
           const octave_value& vtmp = tmp(0);
 
           retval = vtmp.is_instance_of (cls_name);
 
           if (retval)
@@ -1038,17 +1039,18 @@ octave_class::print_with_name (std::ostr
 // Loading a class properly requires an exemplar map entry for success.
 // If we don't have one, we attempt to create one by calling the constructor
 // with no arguments.
 bool
 octave_class::reconstruct_exemplar (void)
 {
   bool retval = false;
 
-  auto it = octave_class::exemplar_map.find (c_name);
+  octave_class::exemplar_const_iterator it
+    = octave_class::exemplar_map.find (c_name);
 
   if (it != octave_class::exemplar_map.end ())
     retval = true;
   else
     {
       octave::symbol_table& symtab
         = octave::__get_symbol_table__ ("octave_class::reconstruct_exemplar");
 
@@ -1118,17 +1120,18 @@ octave_class::clear_exemplar_map (void)
 bool
 octave_class::reconstruct_parents (void)
 {
   bool retval = true;
   bool might_have_inheritance = false;
   std::string dbgstr = "dork";
 
   // First, check to see if there might be an issue with inheritance.
-  for (auto it = map.begin (); it != map.end (); it++)
+  // FIXME: use cbegin and auto decl here when available.
+  for (octave_map::const_iterator it = map.begin (); it != map.end (); it++)
     {
       std::string key = map.key (it);
       Cell        val = map.contents (it);
       if (val(0).isobject ())
         {
           dbgstr = "blork";
           if (key == val(0).class_name ())
             {
@@ -1136,17 +1139,18 @@ octave_class::reconstruct_parents (void)
               dbgstr = "cork";
               break;
             }
         }
     }
 
   if (might_have_inheritance)
     {
-      auto it = octave_class::exemplar_map.find (c_name);
+      octave_class::exemplar_const_iterator it
+        = octave_class::exemplar_map.find (c_name);
 
       if (it == octave_class::exemplar_map.end ())
         retval = false;
       else
         {
           octave_class::exemplar_info exmplr = it->second;
           parent_list = exmplr.parents ();
           for (auto& par : parent_list)
@@ -1698,19 +1702,19 @@ octave_class::exemplar_info::compare (co
     {
       if (obj_fnames[i] != fnames[i])
         error ("mismatch in field names");
     }
 
   if (nparents () != obj.nparents ())
     error ("mismatch in number of parent classes");
 
-  std::list<std::string> obj_parents
+  const std::list<std::string> obj_parents
     = obj.parent_class_name_list ();
-  std::list<std::string> pnames = parents ();
+  const std::list<std::string> pnames = parents ();
 
   auto p = obj_parents.begin ();
   auto q = pnames.begin ();
 
   while (p != obj_parents.end ())
     {
       if (*p++ != *q++)
         error ("mismatch in parent classes");
@@ -1765,17 +1769,18 @@ is derived.
           = octave_value (new octave_class (m, id, std::list<std::string> ()));
       else
         {
           octave_value_list parents = args.slice (2, nargin-2);
 
           retval = octave_value (new octave_class (m, id, parents));
         }
 
-      auto it = octave_class::exemplar_map.find (id);
+      octave_class::exemplar_const_iterator it
+        = octave_class::exemplar_map.find (id);
 
       if (it == octave_class::exemplar_map.end ())
         octave_class::exemplar_map[id] = octave_class::exemplar_info (retval);
       else if (! it->second.compare (retval))
         error ("class: object of class '%s' does not match previously constructed objects",
                id.c_str ());
     }
 
diff --git a/libinterp/octave-value/ov-classdef.cc b/libinterp/octave-value/ov-classdef.cc
--- a/libinterp/octave-value/ov-classdef.cc
+++ b/libinterp/octave-value/ov-classdef.cc
@@ -3334,19 +3334,17 @@ cdef_package::cdef_package_rep::install_
 template <typename T1, typename T2>
 Cell
 map2Cell (const std::map<T1, T2>& m)
 {
   Cell retval (1, m.size ());
   int i = 0;
 
   for (auto it = m.begin (); it != m.end (); ++it, ++i)
-    {
-      retval(i) = to_ov (it->second);
-    }
+    retval(i) = to_ov (it->second);
 
   return retval;
 }
 
 Cell
 cdef_package::cdef_package_rep::get_classes (void) const
 { return map2Cell (class_map); }
 
@@ -3836,17 +3834,18 @@ cdef_manager::find_method_symbol (const 
 }
 
 cdef_package
 cdef_manager::find_package (const std::string& name, bool error_if_not_found,
                             bool load_if_not_found)
 {
   cdef_package retval;
 
-  auto it = m_all_packages.find (name);
+  std::map<std::string, cdef_package>::const_iterator it
+    = m_all_packages.find (name);
 
   if (it != m_all_packages.end ())
     {
       retval = it->second;
 
       if (! retval.ok ())
         error ("invalid package `%s'", name.c_str ());
     }
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -164,17 +164,17 @@ octave_fcn_handle::call (int nargout, co
 
           if (it == overloads.end ())
             {
               // Try parent classes too.
 
               octave::symbol_table& symtab
                 = octave::__get_symbol_table__ ("octave_fcn_handle::call");
 
-              std::list<std::string> plist
+              const std::list<std::string> plist
                 = symtab.parent_classes (dispatch_type);
 
               auto pit = plist.begin ();
 
               while (pit != plist.end ())
                 {
                   std::string pname = *pit;
 
@@ -235,18 +235,19 @@ octave_fcn_handle::is_equal_to (const oc
   bool retval = fcn.is_copy_of (h.fcn) && (has_overloads == h.has_overloads);
   retval = retval && (overloads.size () == h.overloads.size ());
 
   if (retval && has_overloads)
     {
       for (int i = 0; i < btyp_num_types && retval; i++)
         retval = builtin_overloads[i].is_copy_of (h.builtin_overloads[i]);
 
-      auto iter = overloads.begin ();
-      auto hiter = h.overloads.begin ();
+      // FIXME: use cbegin and auto decl here when available.
+      str_ov_map::const_iterator iter = overloads.begin ();
+      str_ov_map::const_iterator hiter = h.overloads.begin ();
       for (; iter != overloads.end () && retval; iter++, hiter++)
         retval = (iter->first == hiter->first)
                  && (iter->second.is_copy_of (hiter->second));
     }
 
   return retval;
 }
 
diff --git a/libinterp/octave-value/ov-struct.cc b/libinterp/octave-value/ov-struct.cc
--- a/libinterp/octave-value/ov-struct.cc
+++ b/libinterp/octave-value/ov-struct.cc
@@ -74,17 +74,17 @@ Cell
 octave_struct::dotref (const octave_value_list& idx, bool auto_add)
 {
   Cell retval;
 
   assert (idx.length () == 1);
 
   std::string nm = idx(0).string_value ();
 
-  auto p = map.seek (nm);
+  octave_map::const_iterator p = map.seek (nm);
 
   if (p != map.end ())
     retval = map.contents (p);
   else if (auto_add)
     retval = (isempty ()) ? Cell (dim_vector (1, 1)) : Cell (dims ());
   else
     error_with_id ("Octave:invalid-indexing",
                    "structure has no member '%s'", nm.c_str ());
@@ -545,17 +545,18 @@ octave_struct::do_index_op (const octave
 
 size_t
 octave_struct::byte_size (void) const
 {
   // Neglect the size of the fieldnames.
 
   size_t retval = 0;
 
-  for (auto p = map.begin (); p != map.end (); p++)
+  // FIXME: use cbegin and auto decl here when available.
+  for (octave_map::const_iterator p = map.begin (); p != map.end (); p++)
     {
       std::string key = map.key (p);
 
       octave_value val = octave_value (map.contents (p));
 
       retval += val.byte_size ();
     }
 
@@ -1259,17 +1260,18 @@ octave_scalar_struct::do_index_op (const
 
 size_t
 octave_scalar_struct::byte_size (void) const
 {
   // Neglect the size of the fieldnames.
 
   size_t retval = 0;
 
-  for (auto p = map.begin (); p != map.end (); p++)
+  // FIXME: use cbegin and auto decl here when available.
+  for (octave_map::const_iterator p = map.begin (); p != map.end (); p++)
     {
       std::string key = map.key (p);
 
       octave_value val = octave_value (map.contents (p));
 
       retval += val.byte_size ();
     }
 
diff --git a/libinterp/parse-tree/bp-table.cc b/libinterp/parse-tree/bp-table.cc
--- a/libinterp/parse-tree/bp-table.cc
+++ b/libinterp/parse-tree/bp-table.cc
@@ -567,17 +567,17 @@ namespace octave
     condition_valid (condition);  // Throw error if condition not valid.
 
     intmap retval;
 
     octave_idx_type len = line.size ();
 
     for (int i = 0; i < len; i++)
       {
-        auto m = line.find (i);
+        const_intmap_iterator m = line.find (i);
 
         if (m != line.end ())
           {
             int lineno = m->second;
 
             octave_user_code *dbg_fcn = find_fcn_by_line (main_fcn, lineno);
 
             // We've found the right (sub)function.  Now insert the breakpoint.
@@ -612,17 +612,17 @@ namespace octave
         octave_value_list results = cmds->list_breakpoints ();
 
         if (results.length () > 0)
           {
             octave_idx_type len = line.size ();
 
             for (int i = 0; i < len; i++)
               {
-                auto p = line.find (i);
+                const_intmap_iterator p = line.find (i);
 
                 if (p != line.end ())
                   {
                     int lineno = p->second;
 
                     cmds->delete_breakpoint (lineno);
 
                     if (! file.empty ())
@@ -722,19 +722,22 @@ namespace octave
 
     tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
 
     return retval;
   }
 
   void bp_table::remove_all_breakpoints (void)
   {
-    // Odd loop structure required because delete will invalidate m_bp_set iterators
-    for (auto it = m_bp_set.begin (), it_next = it;
-         it != m_bp_set.end (); it = it_next)
+    // Odd loop structure required because delete will invalidate
+    // m_bp_set iterators.
+    // FIXME: use cbegin and auto decl here when available.
+    for (const_bp_set_iterator it = m_bp_set.begin (), it_next = it;
+         it != m_bp_set.end ();
+         it = it_next)
       {
         ++it_next;
         remove_all_breakpoints_in_file (*it);
       }
 
     tree_evaluator::debug_mode = bp_table::have_breakpoints () || Vdebugging;
   }
 
diff --git a/libinterp/parse-tree/jit-ir.cc b/libinterp/parse-tree/jit-ir.cc
--- a/libinterp/parse-tree/jit-ir.cc
+++ b/libinterp/parse-tree/jit-ir.cc
@@ -786,18 +786,18 @@ namespace octave
   { }
 
   jit_magic_end::jit_magic_end (const std::vector<context>& full_context)
     : m_contexts (full_context)
   {
     resize_arguments (m_contexts.size ());
 
     size_t i;
-    for (auto iter = m_contexts.begin (), i = 0;
-         iter != m_contexts.end (); ++iter, ++i)
+    std::vector<context>::const_iterator iter;
+    for (iter = m_contexts.begin (), i = 0; iter != m_contexts.end (); ++iter, ++i)
       stash_argument (i, iter->m_value);
   }
 
   jit_magic_end::context
   jit_magic_end::resolve_context (void) const
   {
     size_t idx;
     for (idx = 0; idx < m_contexts.size (); ++idx)
diff --git a/libinterp/parse-tree/jit-typeinfo.cc b/libinterp/parse-tree/jit-typeinfo.cc
--- a/libinterp/parse-tree/jit-typeinfo.cc
+++ b/libinterp/parse-tree/jit-typeinfo.cc
@@ -581,17 +581,19 @@ namespace octave
         rtype = m_result->packed_type (m_call_conv);
         if (sret ())
           {
             llvm_args.push_back (rtype->getPointerTo ());
             rtype = llvm::Type::getVoidTy (context);
           }
       }
 
-    for (auto iter = m_args.begin (); iter != m_args.end (); ++iter)
+    // FIXME: use cbegin and auto decl here when available.
+    for (std::vector<jit_type *>::const_iterator iter = m_args.begin ();
+         iter != m_args.end (); ++iter)
       {
         jit_type *ty = *iter;
         assert (ty);
         llvm::Type *argty = ty->packed_type (m_call_conv);
         if (ty->pointer_arg (m_call_conv))
           argty = argty->getPointerTo ();
 
         llvm_args.push_back (argty);
@@ -894,17 +896,17 @@ namespace octave
 
     return idx;
   }
 
   const jit_function&
   jit_operation::do_generate (const signature_vec& types) const
   {
     static jit_function null_overload;
-    auto find = m_generated.find (&types);
+    generated_map::const_iterator find = m_generated.find (&types);
     if (find != m_generated.end ())
       {
         if (find->second)
           return *find->second;
         else
           return null_overload;
       }
 
@@ -2028,17 +2030,17 @@ namespace octave
     m_identities.push_back (jit_function ());
 
     return ret;
   }
 
   jit_type*
   jit_typeinfo::do_get_intN (size_t nbits) const
   {
-    auto iter = m_ints.find (nbits);
+    std::map<size_t, jit_type *>::const_iterator iter = m_ints.find (nbits);
     if (iter != m_ints.end ())
       return iter->second;
 
     throw jit_fail_exception ("No such integer type");
   }
 
   const jit_function&
   jit_typeinfo::do_end (jit_value *value, jit_value *idx, jit_value *count)
diff --git a/libinterp/parse-tree/pt-jit.cc b/libinterp/parse-tree/pt-jit.cc
--- a/libinterp/parse-tree/pt-jit.cc
+++ b/libinterp/parse-tree/pt-jit.cc
@@ -1750,17 +1750,20 @@ namespace octave
   jit_infer::construct_ssa (void)
   {
     m_blocks.label ();
     final_block ().compute_idom (entry_block ());
     entry_block ().compute_df ();
     entry_block ().create_dom_tree ();
 
     // insert phi nodes where needed, this is done on a per variable basis
-    for (auto  iter = m_vmap.begin (); iter != m_vmap.end (); ++iter)
+    // FIXME: use cbegin and auto decl here when available.
+    for (variable_map::const_iterator iter = m_vmap.begin ();
+         iter != m_vmap.end ();
+         ++iter)
       {
         jit_block::df_set visited, added_phi;
         std::list<jit_block *> ssa_worklist;
         iter->second->use_blocks (visited);
         ssa_worklist.insert (ssa_worklist.begin (), visited.begin (),
                              visited.end ());
 
         while (ssa_worklist.size ())
@@ -1985,17 +1988,20 @@ namespace octave
     if (! temp.size () || ! isa<jit_error_check> (ablock.terminator ()))
       return;
 
     // FIXME: If we support try/catch or unwind_protect final_block
     //        may not be the destination
     jit_block *split = ablock.maybe_split (m_factory, m_blocks,
                                            final_block ());
     jit_terminator *term = split->terminator ();
-    for (auto iter = temp.begin (); iter != temp.end (); ++iter)
+    // FIXME: use cbegin and auto decl here when available.
+    for (std::set<jit_value *>::const_iterator iter = temp.begin ();
+         iter != temp.end ();
+         ++iter)
       {
         jit_value *value = *iter;
         jit_call *release
           = m_factory.create<jit_call> (&jit_typeinfo::release, value);
         split->insert_before (term, release);
         release->infer ();
       }
   }
@@ -2817,17 +2823,17 @@ namespace octave
             m_function = reinterpret_cast<jited_function> (void_fn);
           }
       }
   }
 
   octave_value
   jit_info::find (const vmap& extra_vars, const std::string& vname) const
   {
-    auto iter = extra_vars.find (vname);
+    vmap::const_iterator iter = extra_vars.find (vname);
 
     if (iter == extra_vars.end ())
       {
         symbol_scope scope = __require_current_scope__ ("jit_convert::find");
 
         return scope.varval (vname);
       }
     else
diff --git a/liboctave/util/lo-regexp.cc b/liboctave/util/lo-regexp.cc
--- a/liboctave/util/lo-regexp.cc
+++ b/liboctave/util/lo-regexp.cc
@@ -454,17 +454,17 @@ namespace octave
     int num;
   } rep_token_t;
 
   std::string
   regexp::replace (const std::string& buffer, const std::string& replacement)
   {
     std::string retval;
 
-    regexp::match_data rx_lst = match (buffer);
+    const regexp::match_data rx_lst = match (buffer);
 
     size_t num_matches = rx_lst.size ();
 
     if (num_matches == 0)
       {
         retval = buffer;
         return retval;
       }
diff --git a/liboctave/util/lo-regexp.h b/liboctave/util/lo-regexp.h
--- a/liboctave/util/lo-regexp.h
+++ b/liboctave/util/lo-regexp.h
@@ -253,17 +253,17 @@ namespace octave
             named_pats = rx_lst.named_pats;
           }
 
         return *this;
       }
 
       ~match_data (void) = default;
 
-      string_vector named_patterns (void) { return named_pats; }
+      string_vector named_patterns (void) const { return named_pats; }
 
     private:
 
       string_vector named_pats;
     };
 
   private:
 
