# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1365263483 14400
#      Sat Apr 06 11:51:23 2013 -0400
# Node ID 3021576143085edfc8d6e2a380c4c7a04c4fa3b3
# Parent  ee652dcc9eccf40fd2ac7719846c5a929bdd9297
deprecate symbol_table::varref functions

* ov-usr-fcn.h (octave_user_function::argn_varref,
octave_user_function::nargin_varref,
octave_user_function::nargout_varref,
octave_user_function::varargin_varref): Delete unused variables.

* symtab.h (symbol_table::symbol_record::symbol_record_ref::assign,
symbol_table::symbol_record::symbol_record_ref::do_non_const_unary_op,
symbol_table::symbol_record::do_non_const_unary_op,
(symbol_table::symbol_record::is_undefined,
symbol_table::symbol_record::assign, symbol_table::assign,
symbol_table::force_assign, symbol_table::global_assign,
symbol_table::persistent_assign, symbol_table::top_level_assign,
symbol_table::do_assign, symbol_table::do_persistent_assign):
New functions.
(symbol_table::symbol_record::symbol_record_ref::varref):
Avoid calls to deprecated functions.
(symbol_table::varref, symbol_table::force_varref,
symbol_table::global_varref, symbol_table::persistent_varref,
symbol_table::top_level_varref, symbol_table::do_varref,
symbol_table::do_persistent_varref): Deprecate.
(symbol_table::symbol_reference::is_black_hole): New function.

* oct-lvalue.h, oct-lvalue.cc: Store symbol_reference instead of
pointer to octave_value object.
(octave_lvalue::value): Now const.
(octave_lvalue::object): Delete.
* pt-id.cc (tree_identifier::lvalue): Construct octave_lvalue from
sym, not sym->varref.

* ls-mat5.cc, oct-lvalue.cc, oct-lvalue.h, pt-jit.cc, error.cc,
load-save.cc, symtab.cc, symtab.h, variables.cc, ov-fcn-handle.cc,
ov-usr-fcn.cc, ov-usr-fcn.h, oct-parse.in.yy, pt-eval.cc, pt-id.h,
pt-idx.cc, mex.cc: Change all uses of varref functions to use assign
instead.  Use varval instead of varref where appropriate.

* load-save.cc (install_loaded_variable): Don't manipulate
symbol_record directly.

diff --git a/libgui/src/workspace-model.cc b/libgui/src/workspace-model.cc
--- a/libgui/src/workspace-model.cc
+++ b/libgui/src/workspace-model.cc
@@ -51,17 +51,16 @@ workspace_model::workspace_model(QObject
 workspace_model::~workspace_model()
 {
   delete _rootItem;
 }
 
 void
 workspace_model::request_update_workspace ()
 {
-  octave_link::post_event (this, &workspace_model::update_workspace_callback);
 }
 
 QModelIndex
 workspace_model::index(int row, int column, const QModelIndex &p) const
 {
   if (!hasIndex(row, column, p))
     return QModelIndex();
 
@@ -163,16 +162,17 @@ workspace_model::data(const QModelIndex 
   if (role != Qt::DisplayRole)
     return QVariant();
 
   tree_item *item = static_cast<tree_item*>(idx.internalPointer());
 
   return item->data(idx.column());
 }
 
+#if 0
 void
 workspace_model::update_workspace_callback (void)
 {
   std::list < symbol_table::symbol_record > symbolTable = symbol_table::all_variables ();
 
   _symbol_information.clear ();
   for (std::list < symbol_table::symbol_record > ::iterator iterator = symbolTable.begin ();
        iterator != symbolTable.end (); iterator++)
@@ -208,8 +208,9 @@ workspace_model::update_workspace_callba
 
         default:
           break;
         }
     }
 
   endResetModel();
 }
+#endif
diff --git a/libgui/src/workspace-model.h b/libgui/src/workspace-model.h
--- a/libgui/src/workspace-model.h
+++ b/libgui/src/workspace-model.h
@@ -126,18 +126,16 @@ class workspace_model
                      const QModelIndex &parent = QModelIndex ()) const;
   QModelIndex parent (const QModelIndex &index) const;
   int rowCount (const QModelIndex &parent = QModelIndex ()) const;
   int columnCount (const QModelIndex &parent = QModelIndex ()) const;
 
   void insert_top_level_item (int at, tree_item *treeItem);
   tree_item *top_level_item (int at);
 
-  void update_workspace_callback (void);
-
 public slots:
   void request_update_workspace ();
 
 signals:
   void model_changed ();
 
 private:
 
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -109,18 +109,16 @@ workspace_view::handle_visibility_change
 {
   if (visible)
     emit active_changed (true);
 }
 
 void
 workspace_view::model_changed ()
 {
-  _workspace_model->update_workspace_callback ();
-
   // This code is very quirky and requires some explanation.
   // Usually, we should not deal with collapsing or expanding ourselves,
   // because the view itself determines (based on the model) whether it
   // is appropriate to collapse or expand items.
   //
   // Now, the logic requires that we update our model item by item, which
   // would make it work correctly, but this is extremely slow and scales
   // very bad (O(n^2)). That's why we throw away our model and rebuild it
diff --git a/libinterp/interp-core/ls-mat5.cc b/libinterp/interp-core/ls-mat5.cc
--- a/libinterp/interp-core/ls-mat5.cc
+++ b/libinterp/interp-core/ls-mat5.cc
@@ -1008,17 +1008,17 @@ read_mat5_binary_element (std::istream& 
                 octave_value tmp;
 
                 for (Octave_map::iterator p0 = m2.begin () ;
                      p0 != m2.end (); p0++)
                   {
                     std::string key = m2.key (p0);
                     octave_value val = m2.contents (p0)(0);
 
-                    symbol_table::varref (key, local_scope, 0) = val;
+                    symbol_table::assign (key, val, local_scope, 0);
                   }
               }
 
             int parse_status;
             octave_value anon_fcn_handle =
               eval_string (fname.substr (4), true, parse_status);
 
             if (parse_status == 0)
diff --git a/libinterp/interp-core/mex.cc b/libinterp/interp-core/mex.cc
--- a/libinterp/interp-core/mex.cc
+++ b/libinterp/interp-core/mex.cc
@@ -3245,17 +3245,17 @@ mexPutVariable (const char *space, const
           if (caller)
             octave_call_stack::goto_caller_frame ();
           else
             octave_call_stack::goto_base_frame ();
 
           if (! error_state)
             frame.add_fcn (octave_call_stack::pop);
 
-          symbol_table::varref (name) = mxArray::as_octave_value (ptr);
+          symbol_table::assign (name, mxArray::as_octave_value (ptr));
         }
       else
         mexErrMsgTxt ("mexPutVariable: symbol table does not exist");
     }
 
   return 0;
 }
 
diff --git a/libinterp/interp-core/oct-lvalue.cc b/libinterp/interp-core/oct-lvalue.cc
--- a/libinterp/interp-core/oct-lvalue.cc
+++ b/libinterp/interp-core/oct-lvalue.cc
@@ -27,22 +27,22 @@ along with Octave; see the file COPYING.
 #include "error.h"
 #include "oct-obj.h"
 #include "oct-lvalue.h"
 #include "ov.h"
 
 void
 octave_lvalue::assign (octave_value::assign_op op, const octave_value& rhs)
 {
-  if (val)
+  if (! is_black_hole ())
     {
       if (idx.empty ())
-        val->assign (op, rhs);
+        sym->assign (op, rhs);
       else
-        val->assign (op, type, idx, rhs);
+        sym->assign (op, type, idx, rhs);
     }
 }
 
 void
 octave_lvalue::set_index (const std::string& t,
                           const std::list<octave_value_list>& i)
 {
   if (idx.empty ())
@@ -52,43 +52,43 @@ octave_lvalue::set_index (const std::str
     }
   else
     error ("invalid index expression in assignment");
 }
 
 void
 octave_lvalue::do_unary_op (octave_value::unary_op op)
 {
-  if (val)
+  if (! is_black_hole ())
     {
       if (idx.empty ())
-        val->do_non_const_unary_op (op);
+        sym->do_non_const_unary_op (op);
       else
-        val->do_non_const_unary_op (op, type, idx);
+        sym->do_non_const_unary_op (op, type, idx);
     }
-  else
-    error ("internal: invalid operation on ~");
 }
 
 octave_value
-octave_lvalue::value (void)
+octave_lvalue::value (void) const
 {
   octave_value retval;
 
-  if (val)
+  if (! is_black_hole ())
     {
+      octave_value val = sym->varval ();
+
       if (idx.empty ())
-        retval = *val;
+        retval = val;
       else
         {
-          if (val->is_constant ())
-            retval = val->subsref (type, idx);
+          if (val.is_constant ())
+            retval = val.subsref (type, idx);
           else
             {
-              octave_value_list t = val->subsref (type, idx, 1);
+              octave_value_list t = val.subsref (type, idx, 1);
               if (t.length () > 0)
                 retval = t(0);
             }
         }
     }
 
   return retval;
 }
diff --git a/libinterp/interp-core/oct-lvalue.h b/libinterp/interp-core/oct-lvalue.h
--- a/libinterp/interp-core/oct-lvalue.h
+++ b/libinterp/interp-core/oct-lvalue.h
@@ -25,79 +25,83 @@ along with Octave; see the file COPYING.
 
 class octave_value;
 class octave_value_list;
 
 #include <string>
 
 #include "oct-obj.h"
 #include "pt-idx.h"
+#include "symtab.h"
 
 class
 octave_lvalue
 {
 public:
 
-  octave_lvalue (octave_value *v = 0)
-    : val (v), type (), idx (), nel (1)
-    { }
+  octave_lvalue (const symbol_table::symbol_reference& s
+                   = symbol_table::symbol_reference ())
+    : sym (s), type (), idx (), nel (1)
+  { }
 
   octave_lvalue (const octave_lvalue& vr)
-    : val (vr.val), type (vr.type), idx (vr.idx), nel (vr.nel)
-    {
-    }
+    : sym (vr.sym), type (vr.type), idx (vr.idx), nel (vr.nel)
+  { }
 
   octave_lvalue& operator = (const octave_lvalue& vr)
     {
       if (this != &vr)
         {
-          val = vr.val;
+          sym = vr.sym;
           type = vr.type;
           idx = vr.idx;
           nel = vr.nel;
         }
 
       return *this;
     }
 
   ~octave_lvalue (void) { }
 
-  bool is_black_hole (void) const { return val == 0; }
+  bool is_black_hole (void) const { return sym.is_black_hole (); }
 
-  bool is_defined (void) const { return val && val->is_defined (); }
-
-  bool is_undefined (void) const { return ! val || val->is_undefined (); }
+  bool is_defined (void) const
+  {
+    return ! is_black_hole () && sym->is_defined ();
+  }
 
-  bool is_map (void) const { return val && val->is_map (); }
+  bool is_undefined (void) const
+  {
+    return is_black_hole () || sym->is_undefined ();
+  }
 
-  void define (const octave_value& v)
-    {
-      if (val)
-        *val = v;
-    }
+  bool is_map (void) const
+  {
+    return value().is_map ();
+  }
+
+  void define (const octave_value& v) { sym->assign (v); }
 
   void assign (octave_value::assign_op, const octave_value&);
 
   void numel (octave_idx_type n) { nel = n; }
 
   octave_idx_type numel (void) const { return nel; }
 
   void set_index (const std::string& t, const std::list<octave_value_list>& i);
 
   void clear_index (void) { type = std::string (); idx.clear (); }
 
   void do_unary_op (octave_value::unary_op op);
 
-  octave_value value (void);
-
-  const octave_value *object (void) const { return val; }
+  octave_value value (void) const;
 
 private:
 
-  octave_value *val;
+  symbol_table::symbol_reference sym;
 
   std::string type;
 
   std::list<octave_value_list> idx;
 
   octave_idx_type nel;
 };
 
diff --git a/libinterp/interp-core/pt-jit.cc b/libinterp/interp-core/pt-jit.cc
--- a/libinterp/interp-core/pt-jit.cc
+++ b/libinterp/interp-core/pt-jit.cc
@@ -2177,17 +2177,17 @@ jit_info::execute (const vmap& extra_var
   function (&real_arguments[0]);
 
   for (size_t i = 0; i < arguments.size (); ++i)
     {
       const std::string& name = arguments[i].first;
 
       // do not store for loop bounds temporary
       if (name.size () && name[0] != '#')
-        symbol_table::varref (arguments[i].first) = real_arguments[i];
+        symbol_table::assign (arguments[i].first, real_arguments[i]);
     }
 
   octave_quit ();
 
   return true;
 }
 
 bool
diff --git a/libinterp/interpfcn/error.cc b/libinterp/interpfcn/error.cc
--- a/libinterp/interpfcn/error.cc
+++ b/libinterp/interpfcn/error.cc
@@ -1340,18 +1340,18 @@ Use a second backslash to stop interpola
 
                       ids(nel) = arg2;
                       states(nel) = curr_state;
                     }
 
                   m.contents ("identifier") = ids;
                   m.contents ("state") = states;
 
-                  symbol_table::varref
-                    (".saved_warning_states.", scope, context) = m;
+                  symbol_table::assign
+                    (".saved_warning_states.", m, scope, context);
 
                   // Now ignore the "local" argument and continue to
                   // handle the current setting.
                   argc--;
                 }
                   
               if (arg2 == "all")
                 {
diff --git a/libinterp/interpfcn/load-save.cc b/libinterp/interpfcn/load-save.cc
--- a/libinterp/interpfcn/load-save.cc
+++ b/libinterp/interpfcn/load-save.cc
@@ -141,23 +141,22 @@ gripe_file_open (const std::string& fcn,
 
 static void
 install_loaded_variable (const std::string& name,
                          const octave_value& val,
                          bool global, const std::string& /*doc*/)
 {
   if (global)
     {
-      symbol_table::symbol_record& sr = symbol_table::insert (name);
-      sr.clear ();
-      sr.mark_global ();
-      sr.varref () = val;
+      symbol_table::clear (name);
+      symbol_table::mark_global (name);
+      symbol_table::global_assign (name, val);
     }
   else
-    symbol_table::varref (name) = val;
+    symbol_table::assign (name, val);
 }
 
 // Return TRUE if NAME matches one of the given globbing PATTERNS.
 
 static bool
 matches_patterns (const string_vector& patterns, int pat_idx,
                   int num_pat, const std::string& name)
 {
@@ -1276,17 +1275,17 @@ save_vars (const string_vector& argv, in
       std::string struct_name = argv[argv_idx];
 
       if (! symbol_table::is_variable (struct_name))
         {
           error ("save: no such variable: '%s'", struct_name.c_str ());
           return;
         }
 
-      octave_value struct_var = symbol_table::varref (struct_name);
+      octave_value struct_var = symbol_table::varval (struct_name);
 
       if (! struct_var.is_map () || struct_var.numel () != 1)
         {
           error ("save: '%s' is not a scalar structure",
                  struct_name.c_str ());
           return;
         }
       octave_scalar_map struct_var_map = struct_var.scalar_map_value ();
diff --git a/libinterp/interpfcn/symtab.cc b/libinterp/interpfcn/symtab.cc
--- a/libinterp/interpfcn/symtab.cc
+++ b/libinterp/interpfcn/symtab.cc
@@ -118,17 +118,17 @@ symbol_table::symbol_record::symbol_reco
 }
 
 octave_value
 symbol_table::symbol_record::find (const octave_value_list& args) const
 {
   octave_value retval;
 
   if (is_global ())
-    retval = symbol_table::global_varref (name ());
+    retval = symbol_table::global_varval (name ());
   else
     {
       retval = varval ();
 
       if (retval.is_undefined ())
         {
           // Use cached fcn_info pointer if possible.
           if (rep->finfo)
@@ -1320,23 +1320,21 @@ symbol_table::do_find (const std::string
   if (! skip_variables)
     {
       table_iterator p = table.find (name);
 
       if (p != table.end ())
         {
           symbol_record sr = p->second;
 
-          // FIXME -- should we be using something other than varref here?
-
           if (sr.is_global ())
-            return symbol_table::global_varref (name);
+            return symbol_table::global_varval (name);
           else
             {
-              octave_value& val = sr.varref ();
+              octave_value val = sr.varval ();
 
               if (val.is_defined ())
                 return val;
             }
         }
     }
 
   fcn_table_iterator p = fcn_table.find (name);
@@ -1662,17 +1660,17 @@ DEFUN (set_variable, args, , "set_variab
 {
   octave_value retval;
 
   if (args.length () == 2)
     {
       std::string name = args(0).string_value ();
 
       if (! error_state)
-        symbol_table::varref (name) = args(1);
+        symbol_table::assign (name, args(1));
       else
         error ("set_variable: expecting variable name as first argument");
     }
   else
     print_usage ();
 
   return retval;
 }
diff --git a/libinterp/interpfcn/symtab.h b/libinterp/interpfcn/symtab.h
--- a/libinterp/interpfcn/symtab.h
+++ b/libinterp/interpfcn/symtab.h
@@ -210,22 +210,73 @@ public:
       symbol_record_rep (scope_id s, const std::string& nm,
                          const octave_value& v, unsigned int sc)
         : decl_scope (s), curr_fcn (0), name (nm), value_stack (),
           storage_class (sc), finfo (), valid (true), count (1)
       {
         value_stack.push_back (v);
       }
 
+      void assign (const octave_value& value,
+                   context_id context = xdefault_context)
+      {
+        varref (context) = value;
+      }
+
+      void assign (octave_value::assign_op op,
+                   const std::string& type,
+                   const std::list<octave_value_list>& idx,
+                   const octave_value& value,
+                   context_id context = xdefault_context)
+      {
+        varref(context).assign (op, type, idx, value);
+      }
+
+      void assign (octave_value::assign_op op, const octave_value& value,
+                   context_id context = xdefault_context)
+      {
+        varref(context).assign (op, value);
+      }
+
+      void do_non_const_unary_op (octave_value::unary_op op,
+                                  context_id context = xdefault_context)
+      {
+        varref(context).do_non_const_unary_op (op);
+      }
+
+      void do_non_const_unary_op (octave_value::unary_op op,
+                                  const std::string& type,
+                                  const std::list<octave_value_list>& idx,
+                                  context_id context = xdefault_context)
+      {
+        varref(context).do_non_const_unary_op (op, type, idx);
+      }
+
       octave_value& varref (context_id context = xdefault_context)
       {
+        // We duplicate global_varref and persistent_varref here to
+        // avoid calling deprecated functions.
+
         if (is_global ())
-          return symbol_table::global_varref (name);
+          {
+            symbol_table::global_table_iterator p
+              = symbol_table::global_table.find (name);
+
+            return (p == symbol_table::global_table.end ())
+              ? symbol_table::global_table[name] : p->second;
+          }
         else if (is_persistent ())
-          return symbol_table::persistent_varref (name);
+          {
+            static octave_value foobar;
+
+            symbol_table *inst
+              = symbol_table::get_instance (symbol_table::current_scope ());
+
+            return inst ? inst->do_persistent_varref (name) : foobar;
+          }
         else
           {
             if (context == xdefault_context)
               context = active_context ();
 
             context_id n = value_stack.size ();
             while (n++ <= context)
               value_stack.push_back (octave_value ());
@@ -294,23 +345,22 @@ public:
         if (! (is_hidden () || is_inherited ())
             && s == scope ())
           {
             if (is_global ())
               unmark_global ();
 
             if (is_persistent ())
               {
-                symbol_table::persistent_varref (name)
-                  = varval ();
+                symbol_table::persistent_assign (name, varval ());
 
                 unmark_persistent ();
               }
 
-            varref () = octave_value ();
+            assign (octave_value ());
           }
       }
 
       bool is_defined (context_id context = xdefault_context) const
       {
         if (context == xdefault_context)
           context = active_context ();
 
@@ -370,17 +420,17 @@ public:
       void unmark_added_static (void) { storage_class &= ~added_static; }
 
       void init_persistent (void)
       {
         if (! is_defined ())
           {
             mark_persistent ();
 
-            varref () = symbol_table::persistent_varval (name);
+            assign (symbol_table::persistent_varval (name));
           }
         // FIXME -- this causes trouble with recursive calls.
         // else
         //   error ("unable to declare existing variable persistent");
       }
 
       void invalidate (void)
       {
@@ -474,16 +524,50 @@ public:
       return symbol_record (rep->dup (new_scope));
     }
 
     const std::string& name (void) const { return rep->name; }
 
     octave_value
     find (const octave_value_list& args = octave_value_list ()) const;
 
+    void assign (const octave_value& value,
+                 context_id context = xdefault_context)
+    {
+      rep->assign (value, context);
+    }
+
+    void assign (octave_value::assign_op op,
+                 const std::string& type,
+                 const std::list<octave_value_list>& idx,
+                 const octave_value& value,
+                 context_id context = xdefault_context)
+    {
+      rep->assign (op, type, idx, value, context);
+    }
+
+    void assign (octave_value::assign_op op, const octave_value& value,
+                 context_id context = xdefault_context)
+    {
+      rep->assign (op, value, context);
+    }
+
+    void do_non_const_unary_op (octave_value::unary_op op)
+    {
+      rep->do_non_const_unary_op (op);
+    }
+
+    void do_non_const_unary_op (octave_value::unary_op op,
+                                const std::string& type,
+                                const std::list<octave_value_list>& idx)
+    {
+      rep->do_non_const_unary_op (op, type, idx);
+    }
+
+    // Delete when deprecated varref functions are removed.
     octave_value& varref (context_id context = xdefault_context)
     {
       return rep->varref (context);
     }
 
     octave_value varval (context_id context = xdefault_context) const
     {
       return rep->varval (context);
@@ -497,16 +581,21 @@ public:
 
     void clear (scope_id s) { rep->clear (s); }
 
     bool is_defined (context_id context = xdefault_context) const
     {
       return rep->is_defined (context);
     }
 
+    bool is_undefined (context_id context = xdefault_context) const
+    {
+      return ! rep->is_defined (context);
+    }
+
     bool is_valid (void) const
     {
       return rep->is_valid ();
     }
 
     bool is_variable (context_id context = xdefault_context) const
     {
       return rep->is_variable (context);
@@ -567,30 +656,40 @@ public:
   };
 
   // Always access a symbol from the current scope.
   // Useful for scripts, as they may be executed in more than one scope.
   class
   symbol_reference
   {
   public:
-    symbol_reference (void) : scope (-1) {}
-
-    symbol_reference (symbol_record record,
-                       scope_id curr_scope = symbol_table::current_scope ())
+
+    symbol_reference (void) : scope (-1) { }
+
+    symbol_reference (const symbol_record& record,
+                      scope_id curr_scope = symbol_table::current_scope ())
       : scope (curr_scope), sym (record)
-    {}
+    { }
+
+    symbol_reference (const symbol_reference& ref)
+      : scope (ref.scope), sym (ref.sym)
+    { }
 
     symbol_reference& operator = (const symbol_reference& ref)
     {
-      scope = ref.scope;
-      sym = ref.sym;
+      if (this != &ref)
+        {
+          scope = ref.scope;
+          sym = ref.sym;
+        }
       return *this;
     }
 
+    bool is_black_hole (void) const { return scope < 0; }
+
     // The name is the same regardless of scope.
     const std::string& name (void) const { return sym.name (); }
 
     symbol_record *operator-> (void)
     {
       update ();
       return &sym;
     }
@@ -607,19 +706,21 @@ public:
     {
       bool operator ()(const symbol_reference& lhs,
                        const symbol_reference& rhs) const
       {
         return lhs.name () < rhs.name ();
       }
     };
   private:
+
     void update (void) const
     {
       scope_id curr_scope = symbol_table::current_scope ();
+
       if (scope != curr_scope || ! sym.is_valid ())
         {
           scope = curr_scope;
           sym = symbol_table::insert (sym.name ());
         }
     }
 
     mutable scope_id scope;
@@ -1176,75 +1277,143 @@ public:
   {
     static symbol_record foobar;
 
     symbol_table *inst = get_instance (scope);
 
     return inst ? inst->do_insert (name) : foobar;
   }
 
-  static octave_value& varref (const std::string& name,
-                               scope_id scope = xcurrent_scope,
-                               context_id context = xdefault_context,
-                               bool force_add = false)
+  static void assign (const std::string& name,
+                      const octave_value& value = octave_value (),
+                      scope_id scope = xcurrent_scope,
+                      context_id context = xdefault_context,
+                      bool force_add = false)
+  {
+    static octave_value foobar;
+
+    symbol_table *inst = get_instance (scope);
+
+    if (inst)
+      inst->do_assign (name, value, context, force_add);
+  }
+
+  // Use assign (name, value, scope, context, force_add) instead.
+  static octave_value&
+  varref (const std::string& name, scope_id scope = xcurrent_scope,
+          context_id context = xdefault_context, bool force_add = false)
+          GCC_ATTR_DEPRECATED
   {
     static octave_value foobar;
 
     symbol_table *inst = get_instance (scope);
 
     return inst ? inst->do_varref (name, context, force_add) : foobar;
   }
 
-  // Convenience function to greatly simplify
+  // Convenience function to simplify
   // octave_user_function::bind_automatic_vars
-  static octave_value& force_varref (const std::string& name,
-                                     scope_id scope = xcurrent_scope,
-                                     context_id context = xdefault_context)
+
+  static void force_assign (const std::string& name,
+                            const octave_value& value = octave_value (),
+                            scope_id scope = xcurrent_scope,
+                            context_id context = xdefault_context)
   {
-    return varref (name, scope, context, true);
+    assign (name, value, scope, context, true);
+  }
+
+  // Use force_assign (name, value, scope, context) instead.
+  static octave_value&
+  force_varref (const std::string& name, scope_id scope = xcurrent_scope,
+                context_id context = xdefault_context) GCC_ATTR_DEPRECATED
+  {
+    static octave_value foobar;
+
+    symbol_table *inst = get_instance (scope);
+
+    return inst ? inst->do_varref (name, context, true) : foobar;
   }
 
   static octave_value varval (const std::string& name,
                               scope_id scope = xcurrent_scope,
                               context_id context = xdefault_context)
   {
     symbol_table *inst = get_instance (scope);
 
     return inst ? inst->do_varval (name, context) : octave_value ();
   }
 
+  static void
+  global_assign (const std::string& name,
+                 const octave_value& value = octave_value ())
+
+  {
+    global_table_iterator p = global_table.find (name);
+
+    if (p == global_table.end ())
+      global_table[name] = value;
+    else
+      p->second = value;
+  }
+
+  // Use global_assign (name, value) instead.
   static octave_value&
-  global_varref (const std::string& name)
+  global_varref (const std::string& name) GCC_ATTR_DEPRECATED
+
   {
     global_table_iterator p = global_table.find (name);
 
     return (p == global_table.end ()) ? global_table[name] : p->second;
   }
 
   static octave_value
   global_varval (const std::string& name)
   {
     global_table_const_iterator p = global_table.find (name);
 
     return (p != global_table.end ()) ? p->second : octave_value ();
   }
 
+  static void
+  top_level_assign (const std::string& name,
+                    const octave_value& value = octave_value ())
+  {
+    assign (name, value, top_scope (), 0);
+  }
+
+  // Use top_level_assign (name, value) instead.
   static octave_value&
-  top_level_varref (const std::string& name)
+  top_level_varref (const std::string& name) GCC_ATTR_DEPRECATED
   {
-    return varref (name, top_scope (), 0);
+    static octave_value foobar;
+
+    symbol_table *inst = get_instance (top_scope ());
+
+    return inst ? inst->do_varref (name, 0, true) : foobar;
   }
 
   static octave_value
   top_level_varval (const std::string& name)
   {
     return varval (name, top_scope (), 0);
   }
 
+  static void
+  persistent_assign (const std::string& name,
+                     const octave_value& value = octave_value ())
+  {
+    symbol_table *inst = get_instance (xcurrent_scope);
+
+    if (inst)
+      inst->do_persistent_assign (name, value);
+  }
+
+  // Use persistent_assign (name, value) instead.
   static octave_value& persistent_varref (const std::string& name)
+  GCC_ATTR_DEPRECATED
   {
     static octave_value foobar;
 
     symbol_table *inst = get_instance (xcurrent_scope);
 
     return inst ? inst->do_persistent_varref (name) : foobar;
   }
 
@@ -2236,17 +2405,17 @@ private:
             std::string nm = sr.name ();
 
             if (nm != "__retval__")
               {
                 octave_value val = donor_table.do_varval (nm, donor_context);
 
                 if (val.is_defined ())
                   {
-                    sr.varref (0) = val;
+                    sr.assign (val, 0);
 
                     sr.mark_inherited ();
                   }
               }
           }
       }
   }
 
@@ -2279,17 +2448,35 @@ private:
 
             return table[name] = ret;
           }
       }
     else
       return p->second;
   }
 
-  octave_value& do_varref (const std::string& name, context_id context, bool force_add)
+  void do_assign (const std::string& name, const octave_value& value,
+                  context_id context, bool force_add)
+  {
+    table_iterator p = table.find (name);
+
+    if (p == table.end ())
+      {
+        symbol_record& sr = do_insert (name, force_add);
+
+        sr.assign (value, context);
+      }
+    else
+      p->second.assign (value, context);
+  }
+
+  // Use do_assign (name, value, context, force_add) instead.
+  // Delete when deprecated varref functions are removed.
+  octave_value& do_varref (const std::string& name, context_id context,
+                           bool force_add)
   {
     table_iterator p = table.find (name);
 
     if (p == table.end ())
       {
         symbol_record& sr = do_insert (name, force_add);
 
         return sr.varref (context);
@@ -2300,16 +2487,29 @@ private:
 
   octave_value do_varval (const std::string& name, context_id context) const
   {
     table_const_iterator p = table.find (name);
 
     return (p != table.end ()) ? p->second.varval (context) : octave_value ();
   }
 
+  void do_persistent_assign (const std::string& name,
+                             const octave_value& value)
+  {
+    persistent_table_iterator p = persistent_table.find (name);
+
+    if (p == persistent_table.end ())
+      persistent_table[name] = value;
+    else
+      p->second = value;
+  }
+
+  // Use do_persistent_assign (name, value) instead.
+  // Delete when deprecated varref functions are removed.
   octave_value& do_persistent_varref (const std::string& name)
   {
     persistent_table_iterator p = persistent_table.find (name);
 
     return (p == persistent_table.end ())
       ? persistent_table[name] : p->second;
   }
 
@@ -2367,17 +2567,17 @@ private:
       p->second.clear (my_scope);
   }
 
   void do_clear_objects (void)
   {
     for (table_iterator p = table.begin (); p != table.end (); p++)
       {
         symbol_record& sr = p->second;
-        octave_value& val = sr.varref ();
+        octave_value val = sr.varval ();
         if (val.is_object ())
           p->second.clear (my_scope);
       }
   }
 
   void do_clear_global (const std::string& name)
   {
     table_iterator p = table.find (name);
diff --git a/libinterp/interpfcn/variables.cc b/libinterp/interpfcn/variables.cc
--- a/libinterp/interpfcn/variables.cc
+++ b/libinterp/interpfcn/variables.cc
@@ -611,34 +611,34 @@ get_global_value (const std::string& nm,
     error ("get_global_value: undefined symbol '%s'", nm.c_str ());
 
   return val;
 }
 
 void
 set_global_value (const std::string& nm, const octave_value& val)
 {
-  symbol_table::global_varref (nm) = val;
+  symbol_table::global_assign (nm, val);
 }
 
 octave_value
 get_top_level_value (const std::string& nm, bool silent)
 {
   octave_value val = symbol_table::top_level_varval (nm);
 
   if (val.is_undefined () && ! silent)
     error ("get_top_level_value: undefined symbol '%s'", nm.c_str ());
 
   return val;
 }
 
 void
 set_top_level_value (const std::string& nm, const octave_value& val)
 {
-  symbol_table::top_level_varref (nm) = val;
+  symbol_table::top_level_assign (nm, val);
 }
 
 // Variable values.
 
 static bool
 wants_local_change (const octave_value_list& args, int& nargin)
 {
   bool retval = false;
@@ -1876,17 +1876,17 @@ bind_ans (const octave_value& val, bool 
         {
           octave_value_list lst = val.list_value ();
 
           for (octave_idx_type i = 0; i < lst.length (); i++)
             bind_ans (lst(i), print);
         }
       else
         {
-          symbol_table::force_varref (ans) = val;
+          symbol_table::force_assign (ans, val);
 
           if (print)
             val.print_with_name (octave_stdout, ans);
         }
     }
 }
 
 void
diff --git a/libinterp/octave-value/ov-fcn-handle.cc b/libinterp/octave-value/ov-fcn-handle.cc
--- a/libinterp/octave-value/ov-fcn-handle.cc
+++ b/libinterp/octave-value/ov-fcn-handle.cc
@@ -461,17 +461,17 @@ octave_fcn_handle::load_ascii (std::istr
                     = read_ascii_data (is, std::string (), dummy, t2, i);
 
                   if (!is)
                     {
                       error ("load: failed to load anonymous function handle");
                       break;
                     }
 
-                  symbol_table::varref (name, local_scope, 0) = t2;
+                  symbol_table::assign (name, t2, local_scope, 0);
                 }
             }
         }
       else
         {
           is.seekg (pos);
           is.clear ();
         }
@@ -646,17 +646,17 @@ octave_fcn_handle::load_binary (std::ist
                                   dummy, t2, doc);
 
               if (!is)
                 {
                   error ("load: failed to load anonymous function handle");
                   break;
                 }
 
-              symbol_table::varref (name, local_scope) = t2;
+              symbol_table::assign (name, t2, local_scope);
             }
         }
 
       if (is && success)
         {
           int parse_status;
           octave_value anon_fcn_handle =
             eval_string (ctmp2, true, parse_status);
@@ -1154,17 +1154,17 @@ octave_fcn_handle::load_hdf5 (hid_t loc_
                   if (H5Giterate (group_hid, "symbol table", &current_item,
                                   hdf5_read_next_data, &dsub) <= 0)
                     {
                       error ("load: failed to load anonymous function handle");
                       success = false;
                       break;
                     }
 
-                  symbol_table::varref (dsub.name, local_scope) = dsub.tc;
+                  symbol_table::assign (dsub.name, dsub.tc, local_scope);
                 }
             }
         }
 
       if (success)
         {
           int parse_status;
           octave_value anon_fcn_handle =
diff --git a/libinterp/octave-value/ov-usr-fcn.cc b/libinterp/octave-value/ov-usr-fcn.cc
--- a/libinterp/octave-value/ov-usr-fcn.cc
+++ b/libinterp/octave-value/ov-usr-fcn.cc
@@ -596,44 +596,44 @@ octave_user_function::bind_automatic_var
 {
   if (! arg_names.empty ())
     {
       // It is better to save this in the hidden variable .argn. and
       // then use that in the inputname function instead of using argn,
       // which might be redefined in a function.  Keep the old argn name
       // for backward compatibility of functions that use it directly.
 
-      symbol_table::force_varref ("argn") = arg_names;
-      symbol_table::force_varref (".argn.") = Cell (arg_names);
+      symbol_table::force_assign ("argn", arg_names);
+      symbol_table::force_assign (".argn.", Cell (arg_names));
 
       symbol_table::mark_hidden (".argn.");
 
       symbol_table::mark_automatic ("argn");
       symbol_table::mark_automatic (".argn.");
     }
 
-  symbol_table::force_varref (".nargin.") = nargin;
-  symbol_table::force_varref (".nargout.") = nargout;
+  symbol_table::force_assign (".nargin.", nargin);
+  symbol_table::force_assign (".nargout.", nargout);
 
   symbol_table::mark_hidden (".nargin.");
   symbol_table::mark_hidden (".nargout.");
 
   symbol_table::mark_automatic (".nargin.");
   symbol_table::mark_automatic (".nargout.");
 
-  symbol_table::varref (".saved_warning_states.") = octave_value ();
+  symbol_table::assign (".saved_warning_states.");
 
   symbol_table::mark_automatic (".saved_warning_states.");
   symbol_table::mark_automatic (".saved_warning_states.");
 
   if (takes_varargs ())
-    symbol_table::varref ("varargin") = va_args.cell_value ();
+    symbol_table::assign ("varargin", va_args.cell_value ());
 
   // Force .ignored. variable to be undefined by default.
-  symbol_table::varref (".ignored.") = octave_value ();
+  symbol_table::assign (".ignored.");
 
   if (lvalue_list)
     {
       octave_idx_type nbh = 0;
       for (std::list<octave_lvalue>::const_iterator p = lvalue_list->begin ();
            p != lvalue_list->end (); p++)
         nbh += p->is_black_hole ();
 
@@ -645,17 +645,17 @@ octave_user_function::bind_automatic_var
           for (std::list<octave_lvalue>::const_iterator p = lvalue_list->begin ();
                p != lvalue_list->end (); p++)
             {
               if (p->is_black_hole ())
                 bh(l++) = k+1;
               k += p->numel ();
             }
 
-          symbol_table::varref (".ignored.") = bh;
+          symbol_table::assign (".ignored.", bh);
         }
     }
 
   symbol_table::mark_hidden (".ignored.");
   symbol_table::mark_automatic (".ignored.");
 }
 
 void
diff --git a/libinterp/octave-value/ov-usr-fcn.h b/libinterp/octave-value/ov-usr-fcn.h
--- a/libinterp/octave-value/ov-usr-fcn.h
+++ b/libinterp/octave-value/ov-usr-fcn.h
@@ -449,30 +449,16 @@ private:
 
   // pointer to the current unwind_protect frame of this function.
   unwind_protect *curr_unwind_protect_frame;
 
 #ifdef HAVE_LLVM
   jit_function_info *jit_info;
 #endif
 
-#if 0
-  // The symbol record for argn in the local symbol table.
-  octave_value& argn_varref;
-
-  // The symbol record for nargin in the local symbol table.
-  octave_value& nargin_varref;
-
-  // The symbol record for nargout in the local symbol table.
-  octave_value& nargout_varref;
-
-  // The symbol record for varargin in the local symbol table.
-  octave_value& varargin_varref;
-#endif
-
   void print_code_function_header (void);
 
   void print_code_function_trailer (void);
 
   void bind_automatic_vars (const string_vector& arg_names, int nargin,
                             int nargout, const octave_value_list& va_args,
                             const std::list<octave_lvalue> *lvalue_list);
 
diff --git a/libinterp/octave.cc b/libinterp/octave.cc
--- a/libinterp/octave.cc
+++ b/libinterp/octave.cc
@@ -238,17 +238,17 @@ struct option long_opts[] = {
 
 // Store the command-line options for later use.
 
 static void
 intern_argv (int argc, char **argv)
 {
   assert (symbol_table::at_top_level ());
 
-  symbol_table::varref (".nargin.") = argc - 1;
+  symbol_table::assign (".nargin.", argc - 1);
 
   symbol_table::mark_hidden (".nargin.");
 
   if (argc > 0)
     {
       octave_argv.resize (argc - 1);
 
       // Skip program name in argv.
diff --git a/libinterp/parse-tree/oct-parse.in.yy b/libinterp/parse-tree/oct-parse.in.yy
--- a/libinterp/parse-tree/oct-parse.in.yy
+++ b/libinterp/parse-tree/oct-parse.in.yy
@@ -4219,17 +4219,17 @@ may be either @code{\"base\"} or @code{\
             {
               frame.add_fcn (octave_call_stack::pop);
 
               std::string nm = args(1).string_value ();
 
               if (! error_state)
                 {
                   if (valid_identifier (nm))
-                    symbol_table::varref (nm) = args(2);
+                    symbol_table::assign (nm, args(2));
                   else
                     error ("assignin: invalid variable name in argument VARNAME");
                 }
               else
                 error ("assignin: VARNAME must be a string");
             }
         }
       else
diff --git a/libinterp/parse-tree/pt-eval.cc b/libinterp/parse-tree/pt-eval.cc
--- a/libinterp/parse-tree/pt-eval.cc
+++ b/libinterp/parse-tree/pt-eval.cc
@@ -533,17 +533,17 @@ tree_evaluator::visit_function_def (tree
     {
       std::string nm = f->name ();
 
       symbol_table::install_cmdline_function (nm, fcn);
 
       // Make sure that any variable with the same name as the new
       // function is cleared.
 
-      symbol_table::varref (nm) = octave_value ();
+      symbol_table::assign (nm);
     }
 }
 
 void
 tree_evaluator::visit_identifier (tree_identifier&)
 {
   panic_impossible ();
 }
diff --git a/libinterp/parse-tree/pt-id.cc b/libinterp/parse-tree/pt-id.cc
--- a/libinterp/parse-tree/pt-id.cc
+++ b/libinterp/parse-tree/pt-id.cc
@@ -121,17 +121,17 @@ tree_identifier::rvalue1 (int nargout)
 }
 
 octave_lvalue
 tree_identifier::lvalue (void)
 {
   if (sym->is_added_static ())
     static_workspace_error ();
 
-  return octave_lvalue (&(sym->varref ()));
+  return octave_lvalue (sym);
 }
 
 tree_identifier *
 tree_identifier::dup (symbol_table::scope_id sc,
                       symbol_table::context_id) const
 {
   // The new tree_identifier object contains a symbol_record
   // entry from the duplicated scope.
diff --git a/libinterp/parse-tree/pt-id.h b/libinterp/parse-tree/pt-id.h
--- a/libinterp/parse-tree/pt-id.h
+++ b/libinterp/parse-tree/pt-id.h
@@ -155,13 +155,13 @@ public:
 
   bool is_black_hole (void) { return true; }
 
   tree_black_hole *dup (void) const
     { return new tree_black_hole; }
 
   octave_lvalue lvalue (void)
     {
-      return octave_lvalue (0); // black hole lvalue
+      return octave_lvalue (); // black hole lvalue
     }
 };
 
 #endif
diff --git a/libinterp/parse-tree/pt-idx.cc b/libinterp/parse-tree/pt-idx.cc
--- a/libinterp/parse-tree/pt-idx.cc
+++ b/libinterp/parse-tree/pt-idx.cc
@@ -438,22 +438,17 @@ tree_index_expression::lvalue (void)
   std::list<tree_argument_list *>::iterator p_args = args.begin ();
   std::list<string_vector>::iterator p_arg_nm = arg_nm.begin ();
   std::list<tree_expression *>::iterator p_dyn_field = dyn_field.begin ();
 
   retval = expr->lvalue ();
 
   if (! error_state)
     {
-      const octave_value *tro = retval.object ();
-
-      octave_value tmp;
-
-      if (tro)
-        tmp = *tro;
+      octave_value tmp = retval.value ();
 
       octave_idx_type tmpi = 0;
       std::list<octave_value_list> tmpidx;
 
       for (int i = 0; i < n; i++)
         {
           if (retval.numel () != 1)
             gripe_indexed_cs_list ();
