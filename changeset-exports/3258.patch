# HG changeset patch
# User jwe
# Date 932593924 0
#      Wed Jul 21 21:52:04 1999 +0000
# Node ID 4964d5391acc9d2936ace965c0bf889bc35d9154
# Parent  5e61a7a62e2e51dfe634d68e9fb8ab2a23f0a8bd
[project @ 1999-07-21 21:51:33 by jwe]

diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,10 +1,53 @@
+Wed Jul 21 15:38:52 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* symtab.cc (symbol_record::define, symbol_record::variable_reference):
+	Handle constants the same as functions.
+	(symbol_record::link_to_builtin_variable): New function.
+	(symbol_record::define_builtin_const): New function.
+	(symbol_record::define_as_fcn): Delete unused function.
+	(symbol_record::read_only_error):
+	Handle constants the same as variables.
+	* symtab.h (symbol_record::BUILTIN_CONSTANT): New enum value.
+	(symbol_record::symbol_type): Increase width to 7 bits.
+	(symbol_record::symbol_def::is_constant): New function.
+	(symbol_record::symbol_def::is_builtin_constant): New function.
+	(symbol_record::is_constant): New function.
+	(symbol_record::is_builtin_constant): New function.
+	(SYMTAB_ALL_TYPES): Add symbol_record::BUILTIN_CONSTANT.
+	* variables.cc (link_to_builtin_variable): Delete unused function.
+	(link_to_builtin_or_function): Handle built-in constants here too.
+
+	* defun.cc (install_builtin_variable): Delete inst_as_fcn arg.
+	(install_builtin_constant): New function.
+	(install_builtin_variable_as_function): Delete unused function.
+	* defun.h (DEFVAR_INTERNAL): Delete inst_as_fcn arg.
+	(DEFCONST_INTERNAL): New macro.
+	* defun.h (DEFVAR): Delete inst_as_fcn arg.
+	(DEFCONST, DEFCONSTX): Define using DEFCONST_INTERNAL instead of
+	DEFVAR_INTERNAL.
+	* data.cc, defaults.cc, error.cc, help.cc, input.cc, lex.l,
+	load-save.cc, oct-hist.cc, oct-procbuf.cc, ov-fcn.h,
+	ov-usr-fcn.cc, ov.cc, pager.cc, parse.y, pr-output.cc,
+	pt-assign.cc, pt-decl.cc, pt-mat.cc, pt-plot.cc, pt-stmt.cc,
+	toplev.cc, variables.cc:
+	Change all invocations of DEFVAR to match new definition.
+
+	* data.cc (symbols_of_data): Add DEFCONSTs for true and false.
+
 Thu Jul 15 10:59:42 1999  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* data.cc (Fis_bool, Fis_complex, Fisempty, Fisnumeric, Fis_list,
+	Fis_map, Fis_struct): Return bool object.
+	(Fisreal): New function.
+
+	* ov-str-mat.h (octave_char_matrix_str): Only return true if
+	Vimplicit_str_to_num_ok is also true.
+
 	* DLD-FUNCTIONS/time.cc (Ftime): Print usage message if	any
 	arguments are supplied.
 
 	* variables.cc (symbol_out_of_date): Call octave_time for time stamps.
 
 	* fn-cache.h (octave_fcn_file_name_cache::timestamp):
 	Now octave_time object.
 
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -754,38 +754,51 @@ but it uses less memory and avoids calli
 }
 
 DEFUN (is_bool, args, ,
   "is_bool (x): return nonzero if x is a boolean object")
 {
   octave_value retval;
 
   if (args.length () == 1)
-    retval = args(0).is_bool_type () ? 1.0 : 0.0;
+    retval = args(0).is_bool_type ();
   else
     print_usage ("is_bool");
 
   return retval;
 }
 
 DEFALIAS (islogical, is_bool);
 
 DEFUN (is_complex, args, ,
-  "is_complex (x): return nonzero if x is a complex numeric object")
+  "is_complex (x): return nonzero if x is a complex-valued numeric object")
 {
   octave_value retval;
 
   if (args.length () == 1)
-    retval = args(0).is_complex_type () ? 1.0 : 0.0;
+    retval = args(0).is_complex_type ();
   else
     print_usage ("is_complex");
 
   return retval;
 }
 
+DEFUN (isreal, args, ,
+  "isreal (x): return nonzero if x is a real-valued numeric object")
+{
+  octave_value retval;
+
+  if (args.length () == 1)
+    retval = args(0).is_real_type ();
+  else
+    print_usage ("isreal");
+
+  return retval;
+}
+
 DEFUN (isempty, args, ,
   "isempty (x): return nonzero if x is an empty matrix, string, or list")
 {
   double retval = 0.0;
 
   if (args.length () == 1)
     {
       octave_value arg = args(0);
@@ -802,30 +815,30 @@ DEFUN (isempty, args, ,
 }
 
 DEFUN (isnumeric, args, ,
   "isnumeric (x): return nonzero if x is a numeric object")
 {
   octave_value retval;
 
   if (args.length () == 1)
-    retval = args(0).is_numeric_type () ? 1.0 : 0.0;
+    retval = args(0).is_numeric_type ();
   else
     print_usage ("isnumeric");
 
   return retval;
 }
 
 DEFUN (is_list, args, ,
   "is_list (x): return nonzero if x is a list")
 {
   octave_value retval;
 
   if (args.length () == 1)
-    retval = args(0).is_list () ? 1.0 : 0.0;
+    retval = args(0).is_list ();
   else
     print_usage ("is_list");
 
   return retval;
 }
 
 DEFUN (is_matrix, args, ,
   "is_matrix (x): return nonzero if x can be considered a matrix")
@@ -848,17 +861,17 @@ DEFUN (is_matrix, args, ,
 }
 
 DEFUN (is_struct, args, ,
   "is_struct (x): return nonzero if x is a structure")
 {
   octave_value retval;
 
   if (args.length () == 1)
-    retval = args(0).is_map () ? 1.0 : 0.0;
+    retval = args(0).is_map ();
   else
     print_usage ("is_struct");
 
   return retval;
 }
 
 DEFUN (struct_elements, args, ,
   "struct_elements (S)\n\
@@ -1236,16 +1249,19 @@ symbols_of_data (void)
 #endif
 
   DEFCONST (e, e_val,
     "exp (1)");
 
   DEFCONST (eps, DBL_EPSILON,
     "machine precision");
 
+  DEFCONST (false, false,
+    "logical false value");
+
   DEFCONST (i, Complex (0.0, 1.0),
     "sqrt (-1)");
 
   DEFCONST (inf, octave_Inf,
     "infinity");
 
   DEFCONST (j, Complex (0.0, 1.0),
     "sqrt (-1)");
@@ -1263,17 +1279,20 @@ symbols_of_data (void)
     "ratio of the circumference of a circle to its diameter");
 
   DEFCONST (realmax, DBL_MAX,
     "realmax (): return largest representable floating point number");
 
   DEFCONST (realmin, DBL_MIN,
     "realmin (): return smallest representable floating point number");
 
-  DEFVAR (treat_neg_dim_as_zero, 0.0, 0, treat_neg_dim_as_zero,
+  DEFVAR (treat_neg_dim_as_zero, 0.0, treat_neg_dim_as_zero,
     "convert negative dimensions to zero");
+
+  DEFCONST (true, true,
+    "logical true value");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/defaults.cc b/src/defaults.cc
--- a/src/defaults.cc
+++ b/src/defaults.cc
@@ -410,32 +410,32 @@ loadpath (void)
     }
 
   return status;
 }
 
 void
 symbols_of_defaults (void)
 {
-  DEFVAR (EDITOR, Veditor, 0, editor,
+  DEFVAR (EDITOR, Veditor, editor,
     "name of the editor to be invoked by the edit_history command");
 
-  DEFVAR (EXEC_PATH, Vexec_path, 0, exec_path,
+  DEFVAR (EXEC_PATH, Vexec_path, exec_path,
     "colon separated list of directories to search for programs to run");
 
-  DEFVAR (LOADPATH, Vload_path, 0, loadpath,
+  DEFVAR (LOADPATH, Vload_path, loadpath,
     "colon separated list of directories to search for scripts.\n\
 The default value is \":\", which means to search the default list\n\
 of directories.  The default list of directories may be found in\n\
 the built-in constant DEFAULT_LOADPATH");
 
   DEFCONST (DEFAULT_LOADPATH, Vdefault_load_path,
     "the default colon separated list of directories to search for scripts");
   
-  DEFVAR (IMAGEPATH, OCTAVE_IMAGEPATH, 0, imagepath,
+  DEFVAR (IMAGEPATH, OCTAVE_IMAGEPATH, imagepath,
     "colon separated list of directories to search for image files");
 
   DEFCONST (OCTAVE_HOME, Voctave_home,
     "top-level Octave installation directory");
 
   DEFCONSTX ("OCTAVE_VERSION", SBV_OCTAVE_VERSION, OCTAVE_VERSION,
     "Octave version");
 }
diff --git a/src/defun-int.h b/src/defun-int.h
--- a/src/defun-int.h
+++ b/src/defun-int.h
@@ -40,21 +40,25 @@ extern void
 install_builtin_mapper (octave_mapper *mf);
 
 extern void
 install_builtin_function (octave_builtin::fcn f, const string& name,
 			  const string& doc, bool is_text_fcn = false);
 
 extern void
 install_builtin_variable (const string& n, const octave_value& v,
-			  bool iaf, bool p, bool e,
+			  bool p, bool e,
 			  symbol_record::change_function chg_fcn,
 			  const string& h);
 
 extern void
+install_builtin_constant (const string& n, const octave_value& v,
+			  bool p, const string& h);
+
+extern void
 alias_builtin (const string& alias, const string& name);
 
 // MAKE_BUILTINS is defined to extract function names and related
 // information and create the *.def files that are eventually used to
 // create the buitlins.cc file.
 
 #ifdef MAKE_BUILTINS
 
@@ -107,20 +111,24 @@ alias_builtin (const string& alias, cons
   }
 
 #define DECLARE_FUN(name, args_name, nargout_name) \
   octave_value_list \
   F ## name (const octave_value_list& args_name, int nargout_name)
 
 // How builtin variables are actually installed.
 
-#define DEFVAR_INTERNAL(name, sname, defn, inst_as_fcn, protect, \
-			chg_fcn, doc) \
-  install_builtin_variable (name, octave_value (defn), inst_as_fcn, \
-			    protect, (chg_fcn != 0), chg_fcn, doc)
+#define DEFVAR_INTERNAL(name, sname, defn, protect, chg_fcn, doc) \
+  install_builtin_variable (name, octave_value (defn), protect, \
+			    (chg_fcn != 0), chg_fcn, doc)
+
+// How builtin variables are actually installed.
+
+#define DEFCONST_INTERNAL(name, sname, defn, protect, doc) \
+  install_builtin_constant (name, octave_value (defn), protect, doc)
 
 // How mapper functions are actually installed.
 
 #define DEFUN_MAPPER_INTERNAL(name, ch_map, d_b_map, c_b_map, d_d_map, \
 			      d_c_map, c_c_map, lo, hi, \
 			      can_ret_cmplx_for_real, doc) \
   install_builtin_mapper \
     (new octave_mapper (ch_map, d_b_map, c_b_map, d_d_map, d_c_map, \
diff --git a/src/defun.cc b/src/defun.cc
--- a/src/defun.cc
+++ b/src/defun.cc
@@ -96,51 +96,44 @@ install_builtin_function (octave_builtin
 
   sym_rec->unprotect ();
   sym_rec->define (new octave_builtin (f, name, doc), t);
   sym_rec->document (doc);
   sym_rec->make_eternal ();
   sym_rec->protect ();
 }
 
-static void
-install_builtin_variable_as_function (const string& name,
-				      const octave_value& val,
-				      bool protect, bool eternal,
-				      const string& help)
+void
+install_builtin_constant (const string& name, const octave_value& val,
+			  bool protect, const string& help)
 {
   symbol_record *sym_rec = global_sym_tab->lookup (name, true);
   sym_rec->unprotect ();
 
   string tmp_help = help.empty () ? sym_rec->help () : help;
 
-  sym_rec->define_as_fcn (val);
+  sym_rec->define_builtin_const (val);
 
   sym_rec->document (tmp_help);
 
   if (protect)
     sym_rec->protect ();
 
-  if (eternal)
-    sym_rec->make_eternal ();
+  // XXX FIXME XXX -- shouldn't constants be eternal?
+  //  if (eternal)
+  //    sym_rec->make_eternal ();
 }
 
 void
 install_builtin_variable (const string& name, const octave_value& value,
-			  bool install_as_function,
 			  bool protect, bool eternal,
 			  symbol_record::change_function chg_fcn,
-			  const string& help_string)
+			  const string& doc)
 {
-  if (install_as_function)
-    install_builtin_variable_as_function (name, value, protect,
-					  eternal, help_string);
-  else
-    bind_builtin_variable (name, value, protect, eternal,
-			   chg_fcn, help_string);
+  bind_builtin_variable (name, value, protect, eternal, chg_fcn, doc);
 }
 
 void
 alias_builtin (const string& alias, const string& name)
 {
   symbol_record *sr_name = global_sym_tab->lookup (name);
 
   if (! sr_name)
diff --git a/src/defun.h b/src/defun.h
--- a/src/defun.h
+++ b/src/defun.h
@@ -30,54 +30,47 @@ Software Foundation, 59 Temple Place - S
 #include "defun-int.h"
 
 // Define a builtin variable.
 //
 //   name is the name of the variable, unquoted.
 //
 //   defn is the initial value for the variable.
 //
-//   inst_as_fcn is a flag that says whether to install the variable as
-//     if it were a function (allowing the name to also be used as a
-//     variable by users, but recover its original definition if cleared).
-//
 //   protect is a flag that says whether it should be possible to give
 //     the variable a new value.
 //
 //   eternal is a flag that says whether it should be possible to
 //     clear the variable.  Most builtin variables are eternal, and
 //     cannot be cleared.
 //
 //   chg_fcn is a pointer to a function that should be called whenever
 //     this variable is given a new value.  It can be 0 if there is no
 //     function to call.  See also the code in user-prefs.cc.
 //
 //   doc is the simple help text for this variable.
 
-#define DEFVAR(name, defn, inst_as_fcn, chg_fcn, doc) \
-  DEFVAR_INTERNAL (#name, SBV_ ## name, defn, inst_as_fcn, false, chg_fcn, doc)
+#define DEFVAR(name, defn, chg_fcn, doc) \
+  DEFVAR_INTERNAL (#name, SBV_ ## name, defn, false, chg_fcn, doc)
 
-// Define a builtin-constant `__name__', and a corresponding variable
-// `name' that can be redefined.  (The variable is actually installed
-// in the symbol table as a function, so that it doesn't work like a
-// global variable when redefined.)
+// Define a builtin constant `name' (which may be redefined, but will
+// retain its original value when cleared) and also an alias to it
+// called `__name__' (which may not be redefined).
 
 #define DEFCONST(name, defn, doc) \
-  DEFVAR_INTERNAL (#name, SBV_ ## name, defn, true, false, 0, doc); \
-  DEFVAR_INTERNAL ("__" ## #name ## "__", XSBV_ ## name, defn, false, \
-		   true, 0, doc)
+  DEFCONST_INTERNAL (#name, SBV_ ## name, defn, false, doc); \
+  DEFCONST_INTERNAL ("__" ## #name ## "__", XSBV_ ## name, defn, true, doc)
 
 // This one can be used when `name' cannot be used directly (if it is
 // already defined as a macro).  In that case, name is already a
 // quoted string, and the name of the structure has to be passed too.
 
 #define DEFCONSTX(name, sname, defn, doc) \
-  DEFVAR_INTERNAL (name, sname, defn, true, false, 0, doc); \
-  DEFVAR_INTERNAL ("__" ## name ## "__", X ## sname, defn, false, true, \
-		   0, doc)
+  DEFCONST_INTERNAL (name, sname, defn, false, doc); \
+  DEFCONST_INTERNAL ("__" ## name ## "__", X ## sname, defn, true, doc)
 
 // Define a builtin function.
 //
 //   name is the name of the function, unqouted.
 //
 //   args_name is the name of the octave_value_list variable used to pass
 //     the argument list to this function.
 //
diff --git a/src/error.cc b/src/error.cc
--- a/src/error.cc
+++ b/src/error.cc
@@ -325,17 +325,17 @@ beep_on_error (void)
   Vbeep_on_error = check_preference ("beep_on_error");
 
   return 0;
 }
 
 void
 symbols_of_error (void)
 {
-  DEFVAR (beep_on_error, 0.0, 0, beep_on_error,
+  DEFVAR (beep_on_error, 0.0, beep_on_error,
     "if true, beep before printing error messages");
 
   DEFCONST (error_text, "",
     "the text of error messages that would have been printed in the\n\
 body of the most recent unwind_protect statement or the TRY part of\n\
 the most recent eval() command.  Outside of unwind_protect and\n\
 eval(), or if no error has ocurred within them, the value of\n\
 __error_text__ is guaranteed to be the empty string.");
diff --git a/src/fn-cache.h b/src/fn-cache.h
--- a/src/fn-cache.h
+++ b/src/fn-cache.h
@@ -18,18 +18,16 @@ You should have received a copy of the G
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
 #if !defined (octave_fn_cache_h)
 #define octave_fn_cache_h 1
 
-#include <ctime>
-
 #include <string>
 
 #include "Map.h"
 
 #include "oct-time.h"
 
 class string_vector;
 
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -1058,23 +1058,23 @@ suppress_verbose_help_message (void)
     = check_preference ("suppress_verbose_help_message");
 
   return 0;
 }
 
 void
 symbols_of_help (void)
 {
-  DEFVAR (INFO_FILE, Vinfo_file, 0, info_file,
+  DEFVAR (INFO_FILE, Vinfo_file, info_file,
     "name of the Octave info file");
 
-  DEFVAR (INFO_PROGRAM, Vinfo_prog, 0, info_prog,
+  DEFVAR (INFO_PROGRAM, Vinfo_prog, info_prog,
     "name of the Octave info reader");
 
-  DEFVAR (suppress_verbose_help_message, 0.0, 0, suppress_verbose_help_message,
+  DEFVAR (suppress_verbose_help_message, 0.0, suppress_verbose_help_message,
     "suppress printing of message pointing to additional help in the\n\
 help and usage functions");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/input.cc b/src/input.cc
--- a/src/input.cc
+++ b/src/input.cc
@@ -878,29 +878,29 @@ echo_executing_commands (void)
   Vecho_executing_commands = check_preference ("echo_executing_commands"); 
 
   return 0;
 }
 
 void
 symbols_of_input (void)
 {
-  DEFVAR (PS1, "\\s:\\#> ", 0, ps1,
+  DEFVAR (PS1, "\\s:\\#> ", ps1,
     "primary prompt string");
 
-  DEFVAR (PS2, "> ", 0, ps2,
+  DEFVAR (PS2, "> ", ps2,
     "secondary prompt string");
 
-  DEFVAR (PS4, "+ ", 0, ps4,
+  DEFVAR (PS4, "+ ", ps4,
     "string printed before echoed input (enabled by --echo-input)");
 
-  DEFVAR (completion_append_char, " ", 0, completion_append_char,
+  DEFVAR (completion_append_char, " ", completion_append_char,
     "the string to append after successful command-line completion attempts");
 
-  DEFVAR (echo_executing_commands, static_cast<double> (ECHO_OFF), 0,
+  DEFVAR (echo_executing_commands, static_cast<double> (ECHO_OFF),
 	  echo_executing_commands,
     "echo commands as they are executed");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -2102,17 +2102,17 @@ whitespace_in_literal_matrix (void)
   Vwhitespace_in_literal_matrix = pref;
 
   return 0;
 }
 
 void
 symbols_of_lex (void)
 {
-  DEFVAR (whitespace_in_literal_matrix, "", 0, whitespace_in_literal_matrix,
+  DEFVAR (whitespace_in_literal_matrix, "", whitespace_in_literal_matrix,
     "control auto-insertion of commas and semicolons in literal matrices");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -22,32 +22,32 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cfloat>
 #include <cstring>
 #include <cctype>
-#include <ctime>
 
 #include <string>
 
 #include <iomanip.h>
 #include <iostream.h>
 #include <fstream.h>
 #include <strstream.h>
 
 #include "byte-swap.h"
 #include "data-conv.h"
 #include "file-ops.h"
 #include "glob-match.h"
 #include "lo-mappers.h"
 #include "mach-info.h"
 #include "oct-env.h"
+#include "oct-time.h"
 #include "str-vec.h"
 
 #include "defun.h"
 #include "error.h"
 #include "gripes.h"
 #include "load-save.h"
 #include "oct-obj.h"
 #include "pager.h"
@@ -2445,19 +2445,18 @@ write_header (ostream& os, load_save_for
 	char tmp = (char) float_format_to_mopt_digit (flt_fmt);
 
 	os.write (&tmp, 1);
       }
     break;
 
     case LS_ASCII:
       {
-	time_t now = time (0);
-
-	string time_string = asctime (gmtime (&now));
+	octave_gmtime now;
+	string time_string = now.asctime ();
 	time_string = time_string.substr (0, time_string.length () - 1);
 
 	os << "# Created by Octave " OCTAVE_VERSION ", "
 	   << time_string
 	   << " <"
 	   << octave_env::get_user_name ()
 	   << "@"
 	   << octave_env::get_host_name ()
@@ -2746,24 +2745,24 @@ save_precision (void)
     }
   gripe_invalid_value_specified ("save_precision");
   return -1;
 }
 
 void
 symbols_of_load_save (void)
 {
-  DEFVAR (crash_dumps_octave_core, 1.0, 0, crash_dumps_octave_core,
+  DEFVAR (crash_dumps_octave_core, 1.0, crash_dumps_octave_core,
     "write octave-core file if Octave crashes or is killed by a signal");
 
-  DEFVAR (default_save_format, "ascii", 0, default_save_format,
+  DEFVAR (default_save_format, "ascii", default_save_format,
     "default format for files created with save, may be one of\n\
 \"binary\", \"text\", or \"mat-binary\"");
 
-  DEFVAR (save_precision, 15.0, 0, save_precision,
+  DEFVAR (save_precision, 15.0, save_precision,
     "number of significant figures kept by the ASCII save command");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -638,25 +638,25 @@ saving_history (void)
   command_history::ignore_entries (! Vsaving_history);
 
   return 0;
 }
 
 void
 symbols_of_oct_hist (void)
 {
-  DEFVAR (history_file, default_history_file (), 0, history_file,
+  DEFVAR (history_file, default_history_file (), history_file,
     "name of command history file");
 
   double tmp_hist_size = default_history_size ();
 
-  DEFVAR (history_size, tmp_hist_size, 0, history_size,
+  DEFVAR (history_size, tmp_hist_size, history_size,
     "number of commands to save in the history list");
 
-  DEFVAR (saving_history, 1.0, 0, saving_history,
+  DEFVAR (saving_history, 1.0, saving_history,
     "save command history");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/oct-procbuf.cc b/src/oct-procbuf.cc
--- a/src/oct-procbuf.cc
+++ b/src/oct-procbuf.cc
@@ -201,17 +201,17 @@ kluge_procbuf_delay (void)
   gripe_invalid_value_specified ("kluge_procbuf_delay");
   return -1;
 }
 
 void
 symbols_of_oct_procbuf (void)
 {
   DEFVAR (kluge_procbuf_delay, static_cast<double> (Vkluge_procbuf_delay),
-	  0, kluge_procbuf_delay,
+	  kluge_procbuf_delay,
     "number of microseconds to delay in the parent after forking");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/ov-fcn.h b/src/ov-fcn.h
--- a/src/ov-fcn.h
+++ b/src/ov-fcn.h
@@ -22,22 +22,21 @@ Software Foundation, 59 Temple Place - S
 
 #if !defined (octave_function_h)
 #define octave_function_h 1
 
 #if defined (__GNUG__)
 #pragma interface
 #endif
 
-#include <ctime>
-
 #include <string>
 
+#include "oct-time.h"
+
 #include "oct-alloc.h"
-#include "oct-time.h"
 #include "ov-base.h"
 #include "ov-typeinfo.h"
 
 class tree_walker;
 
 // Functions.
 
 class
diff --git a/src/ov-usr-fcn.cc b/src/ov-usr-fcn.cc
--- a/src/ov-usr-fcn.cc
+++ b/src/ov-usr-fcn.cc
@@ -587,31 +587,31 @@ return_last_computed_value (void)
     = check_preference ("return_last_computed_value");
 
   return 0;
 }
 
 void
 symbols_of_ov_usr_fcn (void)
 {
-  DEFVAR (default_return_value, Matrix (), 0, 0,
+  DEFVAR (default_return_value, Matrix (), 0,
     "the default for value for unitialized variables returned from\n\
 functions.  Only used if the variable initialize_return_values is\n\
 nonzero.");
 
-  DEFVAR (define_all_return_values, 0.0, 0, define_all_return_values,
+  DEFVAR (define_all_return_values, 0.0, define_all_return_values,
     "control whether values returned from functions should have a\n\
 value even if one has not been explicitly assigned.  See also\n\
 default_return_value");
 
-  DEFVAR (max_recursion_depth, 256.0, 0, max_recursion_depth,
+  DEFVAR (max_recursion_depth, 256.0, max_recursion_depth,
     "maximum nesting level for functions called recursively.\n\
 The default value is 256.");
 
-  DEFVAR (return_last_computed_value, 0.0, 0, return_last_computed_value,
+  DEFVAR (return_last_computed_value, 0.0, return_last_computed_value,
     "if a function does not return any values explicitly, return the\n\
   last computed value");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/ov.cc b/src/ov.cc
--- a/src/ov.cc
+++ b/src/ov.cc
@@ -1498,41 +1498,41 @@ warn_divide_by_zero (void)
   Vwarn_divide_by_zero = check_preference ("warn_divide_by_zero");
 
   return 0;
 }
 
 void
 symbols_of_ov (void)
 {
-  DEFVAR (do_fortran_indexing, 0.0, 0, do_fortran_indexing,
+  DEFVAR (do_fortran_indexing, 0.0, do_fortran_indexing,
     "allow single indices for matrices");
 
-  DEFVAR (implicit_str_to_num_ok, 0.0, 0, implicit_str_to_num_ok,
+  DEFVAR (implicit_str_to_num_ok, 0.0, implicit_str_to_num_ok,
     "allow implicit string to number conversion");
 
-  DEFVAR (ok_to_lose_imaginary_part, "warn", 0, ok_to_lose_imaginary_part,
+  DEFVAR (ok_to_lose_imaginary_part, "warn", ok_to_lose_imaginary_part,
     "silently convert from complex to real by dropping imaginary part");
 
-  DEFVAR (prefer_column_vectors, 1.0, 0, prefer_column_vectors,
+  DEFVAR (prefer_column_vectors, 1.0, prefer_column_vectors,
     "prefer column/row vectors");
 
-  DEFVAR (print_answer_id_name, 1.0, 0, print_answer_id_name,
+  DEFVAR (print_answer_id_name, 1.0, print_answer_id_name,
     "set output style to print `var_name = ...'");
 
-  DEFVAR (propagate_empty_matrices, 1.0, 0, propagate_empty_matrices,
+  DEFVAR (propagate_empty_matrices, 1.0, propagate_empty_matrices,
     "operations on empty matrices return an empty matrix, not an error");
 
-  DEFVAR (resize_on_range_error, 1.0, 0, resize_on_range_error,
+  DEFVAR (resize_on_range_error, 1.0, resize_on_range_error,
     "enlarge matrices on assignment");
 
-  DEFVAR (struct_levels_to_print, 2.0, 0, struct_levels_to_print,
+  DEFVAR (struct_levels_to_print, 2.0, struct_levels_to_print,
     "number of levels of structure elements to print");
 
-  DEFVAR (warn_divide_by_zero, 1.0, 0, warn_divide_by_zero,
+  DEFVAR (warn_divide_by_zero, 1.0, warn_divide_by_zero,
     "if TRUE, warn about division by zero");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pager.cc b/src/pager.cc
--- a/src/pager.cc
+++ b/src/pager.cc
@@ -502,23 +502,23 @@ page_screen_output (void)
   Vpage_screen_output = check_preference ("page_screen_output");
 
   return 0;
 }
 
 void
 symbols_of_pager (void)
 {
-  DEFVAR (PAGER, default_pager (), 0, pager_binary,
+  DEFVAR (PAGER, default_pager (), pager_binary,
     "path to pager binary");
 
-  DEFVAR (page_output_immediately, 0.0, 0, page_output_immediately,
+  DEFVAR (page_output_immediately, 0.0, page_output_immediately,
     "if paging output, start sending it as soon as it is available");
 
-  DEFVAR (page_screen_output, 1.0, 0, page_screen_output,
+  DEFVAR (page_screen_output, 1.0, page_screen_output,
     "if possible, send output intended for the screen through the pager");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/parse.y b/src/parse.y
--- a/src/parse.y
+++ b/src/parse.y
@@ -3248,34 +3248,34 @@ warn_variable_switch_label (void)
     = check_preference ("warn_variable_switch_label");
 
   return 0;
 }
 
 void
 symbols_of_parse (void)
 {
-  DEFVAR (default_eval_print_flag, 1.0, 0, default_eval_print_flag,
+  DEFVAR (default_eval_print_flag, 1.0, default_eval_print_flag,
     "If the value of this variable is nonzero, Octave will print the\n\
 results of commands executed by eval() that do not end with semicolons.");
 
-  DEFVAR (warn_assign_as_truth_value, 1.0, 0, warn_assign_as_truth_value,
+  DEFVAR (warn_assign_as_truth_value, 1.0, warn_assign_as_truth_value,
     "produce warning for assignments used as truth values");
 
-  DEFVAR (warn_function_name_clash, 1.0, 0, warn_function_name_clash,
+  DEFVAR (warn_function_name_clash, 1.0, warn_function_name_clash,
     "produce warning if function name conflicts with file name");
 
-  DEFVAR (warn_future_time_stamp, 1.0, 0, warn_future_time_stamp,
+  DEFVAR (warn_future_time_stamp, 1.0, warn_future_time_stamp,
     "warn if a function file has a time stamp that is in the future");
 
-  DEFVAR (warn_missing_semicolon, 0.0, 0, warn_missing_semicolon,
+  DEFVAR (warn_missing_semicolon, 0.0, warn_missing_semicolon,
     "produce a warning if a statement in a function file is not\n\
 terminated with a semicolon");
 
-  DEFVAR (warn_variable_switch_label, 0.0, 0, warn_variable_switch_label,
+  DEFVAR (warn_variable_switch_label, 0.0, warn_variable_switch_label,
     "produce warning for variables used as switch labels");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: text ***
 ;;; End: ***
 */
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -1884,29 +1884,29 @@ split_long_rows (void)
   Vsplit_long_rows = check_preference ("split_long_rows");
 
   return 0;
 }
 
 void
 symbols_of_pr_output (void)
 {
-  DEFVAR (fixed_point_format, 0.0, 0, fixed_point_format,
+  DEFVAR (fixed_point_format, 0.0, fixed_point_format,
     "use scaled fixed point format for `format short' and `format long'");
 
-  DEFVAR (output_max_field_width, 10.0, 0, output_max_field_width,
+  DEFVAR (output_max_field_width, 10.0, output_max_field_width,
     "maximum width of an output field for numeric output");
 
-  DEFVAR (output_precision, 5.0, 0, output_precision,
+  DEFVAR (output_precision, 5.0, output_precision,
     "number of significant figures to display for numeric output");
 
-  DEFVAR (print_empty_dimensions, 1.0, 0, print_empty_dimensions,
+  DEFVAR (print_empty_dimensions, 1.0, print_empty_dimensions,
     "also print dimensions of empty matrices");
 
-  DEFVAR (split_long_rows, 1.0, 0, split_long_rows,
+  DEFVAR (split_long_rows, 1.0, split_long_rows,
     "split long matrix rows instead of wrapping");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-assign.cc b/src/pt-assign.cc
--- a/src/pt-assign.cc
+++ b/src/pt-assign.cc
@@ -327,17 +327,17 @@ print_rhs_assign_val (void)
   Vprint_rhs_assign_val = check_preference ("print_rhs_assign_val");
 
   return 0;
 }
 
 void
 symbols_of_pt_assign (void)
 {
-  DEFVAR (print_rhs_assign_val, 0.0, 0, print_rhs_assign_val,
+  DEFVAR (print_rhs_assign_val, 0.0, print_rhs_assign_val,
     "if TRUE, print the right hand side of assignments instead of the left");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-decl.cc b/src/pt-decl.cc
--- a/src/pt-decl.cc
+++ b/src/pt-decl.cc
@@ -183,21 +183,21 @@ initialize_global_variables (void)
     = check_preference ("initialize_global_variables");
 
   return 0;
 }
 
 void
 symbols_of_pt_decl (void)
 {
-  DEFVAR (default_global_variable_value, , 0, 0,
+  DEFVAR (default_global_variable_value, , 0,
     "the default for value for otherwise uninitialized global variables.\n\
 Only used if the variable initialize_global_variables is nonzero.");
 
-  DEFVAR (initialize_global_variables, 0.0, 0, initialize_global_variables,
+  DEFVAR (initialize_global_variables, 0.0, initialize_global_variables,
     "control whether otherwise uninitialized global variables are\n\
 given a default value.  See also default_global_variable_value");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/pt-mat.cc b/src/pt-mat.cc
--- a/src/pt-mat.cc
+++ b/src/pt-mat.cc
@@ -604,23 +604,23 @@ string_fill_char (void)
     }
 
   return status;
 }
 
 void
 symbols_of_pt_mat (void)
 {
-  DEFVAR (empty_list_elements_ok, "warn", 0, empty_list_elements_ok,
+  DEFVAR (empty_list_elements_ok, "warn", empty_list_elements_ok,
     "ignore the empty element in expressions like `a = [[], 1]'");
 
-  DEFVAR (implicit_num_to_str_ok, 0.0, 0, implicit_num_to_str_ok,
+  DEFVAR (implicit_num_to_str_ok, 0.0, implicit_num_to_str_ok,
     "make the result of things like `[97, 98, 99, \"123\"]' be a string");
 
-  DEFVAR (string_fill_char, " ", 0, string_fill_char,
+  DEFVAR (string_fill_char, " ", string_fill_char,
     "the character to fill with when creating string arrays.");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-plot.cc b/src/pt-plot.cc
--- a/src/pt-plot.cc
+++ b/src/pt-plot.cc
@@ -1235,62 +1235,62 @@ gnuplot_has_multiplot (void)
   Vgnuplot_has_multiplot = check_preference ("gnuplot_has_multiplot");
 
   return 0;
 }
 
 void
 symbols_of_pt_plot (void)
 {
-  DEFVAR (automatic_replot, 0.0, 0, automatic_replot,
+  DEFVAR (automatic_replot, 0.0, automatic_replot,
     "if true, auto-insert a replot command when a plot changes");
 
-  DEFVAR (gnuplot_binary, "gnuplot", 0, gnuplot_binary,
+  DEFVAR (gnuplot_binary, "gnuplot", gnuplot_binary,
     "path to gnuplot binary");
 
-  DEFVAR (gnuplot_command_plot, "pl", 0, gnuplot_command_plot,
+  DEFVAR (gnuplot_command_plot, "pl", gnuplot_command_plot,
     "");
 
-  DEFVAR (gnuplot_command_replot, "rep", 0, gnuplot_command_replot,
+  DEFVAR (gnuplot_command_replot, "rep", gnuplot_command_replot,
     "");
 
-  DEFVAR (gnuplot_command_splot, "sp", 0, gnuplot_command_splot,
+  DEFVAR (gnuplot_command_splot, "sp", gnuplot_command_splot,
     "");
 
-  DEFVAR (gnuplot_command_using, "u", 0, gnuplot_command_using,
+  DEFVAR (gnuplot_command_using, "u", gnuplot_command_using,
     "");
 
-  DEFVAR (gnuplot_command_with, "w", 0, gnuplot_command_with,
+  DEFVAR (gnuplot_command_with, "w", gnuplot_command_with,
     "");
 
-  DEFVAR (gnuplot_command_axes, "ax", 0, gnuplot_command_axes,
+  DEFVAR (gnuplot_command_axes, "ax", gnuplot_command_axes,
     "");
 
-  DEFVAR (gnuplot_command_title, "t", 0, gnuplot_command_title,
+  DEFVAR (gnuplot_command_title, "t", gnuplot_command_title,
     "");
 
-  DEFVAR (gnuplot_command_end, "\n", 0, gnuplot_command_end,
+  DEFVAR (gnuplot_command_end, "\n", gnuplot_command_end,
     "");
 
 #ifdef GNUPLOT_HAS_FRAMES
   double with_frames = 1.0;
 #else
   double with_frames = 0.0;
 #endif
 
-  DEFVAR (gnuplot_has_frames, with_frames, 0, gnuplot_has_frames,
+  DEFVAR (gnuplot_has_frames, with_frames, gnuplot_has_frames,
     "true if gnuplot supports multiple plot windows on X11, false otherwise");
 
 #ifdef GNUPLOT_HAS_MULTIPLOT
   double with_multiplot = 1.0;
 #else
   double with_multiplot = 0.0;
 #endif
 
-  DEFVAR (gnuplot_has_multiplot, with_multiplot, 0, gnuplot_has_multiplot,
+  DEFVAR (gnuplot_has_multiplot, with_multiplot, gnuplot_has_multiplot,
     "true if gnuplot supports multiplot, false otherwise");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/pt-stmt.cc b/src/pt-stmt.cc
--- a/src/pt-stmt.cc
+++ b/src/pt-stmt.cc
@@ -184,17 +184,17 @@ silent_functions (void)
   Vsilent_functions = check_preference ("silent_functions");
 
   return 0;
 }
 
 void
 symbols_of_pt_stmt (void)
 {
-  DEFVAR (silent_functions, 0.0, 0, silent_functions,
+  DEFVAR (silent_functions, 0.0, silent_functions,
     "suppress printing results in called functions");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/symtab.cc b/src/symtab.cc
--- a/src/symtab.cc
+++ b/src/symtab.cc
@@ -68,17 +68,17 @@ symbol_record::rename (const string& new
     nm = new_name;
 }
 
 void
 symbol_record::define (const octave_value& v, unsigned int sym_type)
 {
   if (! (is_variable () && read_only_error ("redefine")))
     {
-      if (is_function ())
+      if (is_function () || is_constant ())
 	push_def (new symbol_def ());
 
       if (definition->type () == symbol_record::BUILTIN_VARIABLE)
 	sym_type = symbol_record::BUILTIN_VARIABLE;
 
       definition->define (v, sym_type);
     }
 }
@@ -88,23 +88,23 @@ symbol_record::define_builtin_var (const
 {
   define (v, symbol_record::BUILTIN_VARIABLE);
 
   if (chg_fcn)
     chg_fcn ();
 }
 
 bool
-symbol_record::define_as_fcn (const octave_value& v)
+symbol_record::define_builtin_const (const octave_value& v)
 {
   bool retval = false;
 
-  if (! (is_variable () || read_only_error ("redefine")))
+  if (! read_only_error ("redefine"))
     {
-      replace_all_defs (new symbol_def (v, symbol_record::BUILTIN_FUNCTION));
+      replace_all_defs (new symbol_def (v, symbol_record::BUILTIN_CONSTANT));
 
       retval = true;
     }
 
   return retval;
 }
 
 bool
@@ -225,26 +225,36 @@ symbol_record::hides_builtin (void) cons
 octave_value&
 symbol_record::variable_value (void)
 {
   static octave_value foo;
 
   return is_variable () ? def () : foo;
 }
 
+inline void
+symbol_record::link_to_builtin_variable (void)
+{
+  symbol_record *tmp_sym = global_sym_tab->lookup (name ());
+
+  if (tmp_sym && tmp_sym->is_builtin_variable ())
+    alias (tmp_sym);
+}
+
+
 octave_lvalue
 symbol_record::variable_reference (void)
 {
-  if (is_function ())
+  if (is_function () || is_constant ())
     clear ();
 
   if (! is_defined ())
     {
       if (! (is_formal_parameter () || is_linked_to_global ()))
-	link_to_builtin_variable (this);
+	link_to_builtin_variable ();
 
       if (! is_defined ())
 	{
 	  octave_value tmp;
 	  define (tmp);
 	}
     }
 
@@ -321,17 +331,17 @@ symbol_record::dump_symbol_info (void)
     octave_stdout << "symbol " << name () << " is undefined\n";
 }
 
 bool
 symbol_record::read_only_error (const char *action)
 {
   if (is_read_only ())
     {
-      if (is_variable ())
+      if (is_variable () || is_constant ())
 	::error ("can't %s read-only constant `%s'", action, nm.c_str ());
       else if (is_function ())
 	::error ("can't %s read-only function `%s'", action, nm.c_str ());
       else
 	::error ("can't %s read-only symbol `%s'", action, nm.c_str ());
 
       return true;
     }
diff --git a/src/symtab.h b/src/symtab.h
--- a/src/symtab.h
+++ b/src/symtab.h
@@ -47,25 +47,29 @@ class symbol_table;
 
 // Individual records in a symbol table.
 
 class
 symbol_record
 {
 public:
 
+  // If you add or delete an entry here, you'll also need to change
+  // the with parameter in the declaration for symbol_type below...
+
   enum TYPE
     {
       UNKNOWN = 0,
       USER_FUNCTION = 1,
       USER_VARIABLE = 2,
       BUILTIN_FUNCTION = 4,
       TEXT_FUNCTION = 8,
       MAPPER_FUNCTION = 16,
-      BUILTIN_VARIABLE = 32
+      BUILTIN_VARIABLE = 32,
+      BUILTIN_CONSTANT = 64
     };
 
 private:
 
   // Variables or functions.
 
   class symbol_def
   {
@@ -73,16 +77,19 @@ private:
 
     symbol_def (const octave_value& val = octave_value (),
 		unsigned int sym_type = 0)
       : symbol_type (sym_type), eternal (0), read_only (0), help_string (),
 	definition (val), next_elem (0), count (1) { }
 
     ~symbol_def (void) { }
 
+    bool is_constant (void) const
+      { return (symbol_type & symbol_record::BUILTIN_CONSTANT); }
+
     bool is_variable (void) const
       {
 	return (symbol_type & symbol_record::USER_VARIABLE
 		|| symbol_type & symbol_record::BUILTIN_VARIABLE);
       }
 
     bool is_function (void) const
       {
@@ -97,16 +104,19 @@ private:
       { return (symbol_type & symbol_record::TEXT_FUNCTION); }
 
     bool is_mapper_function (void) const
       { return (symbol_type & symbol_record::MAPPER_FUNCTION); }
 
     bool is_user_function (void) const
       { return (symbol_type & symbol_record::USER_FUNCTION); }
 
+    bool is_builtin_constant (void) const
+      { return (symbol_type & symbol_record::BUILTIN_CONSTANT); }
+
     bool is_builtin_variable (void) const
       { return (symbol_type & symbol_record::BUILTIN_VARIABLE); }
 
     bool is_builtin_function (void) const
       { return (symbol_type & symbol_record::BUILTIN_FUNCTION); }
 
     // XXX FIXME XXX
     bool is_map_element (const string& /* elts */) const
@@ -150,17 +160,17 @@ private:
       { return allocator.alloc (size); }
 
     void operator delete (void *p, size_t size)
       { allocator.free (p, size); }
 
     static octave_allocator allocator;
 
     // The type of this symbol (see the enum above).
-    unsigned int symbol_type : 6;
+    unsigned int symbol_type : 7;
 
     // Nonzero means this variable cannot be cleared.
     unsigned int eternal : 1;
 
     // Nonzero means this variable cannot be given a new value.
     unsigned int read_only : 1;
 
     // The doc string associated with this variable.
@@ -220,16 +230,22 @@ public:
     { return definition->is_mapper_function (); }
 
   bool is_user_function (void) const
     { return definition->is_user_function (); }
 
   bool is_builtin_function (void) const
     { return definition->is_builtin_function (); }
 
+  bool is_constant (void) const
+    { return definition->is_constant (); }
+
+  bool is_builtin_constant (void) const
+    { return definition->is_builtin_constant (); }
+
   bool is_variable (void) const
     { return definition->is_variable (); }
 
   bool is_user_variable (void) const
     { return definition->is_user_variable (); }
 
   bool is_builtin_variable (void) const
     { return definition->is_builtin_variable (); }
@@ -252,17 +268,17 @@ public:
   void make_eternal (void) { definition->make_eternal (); }
 
   void set_change_function (change_function f) { chg_fcn = f; }
 
   void define (const octave_value& v, unsigned int sym_type = USER_VARIABLE);
 
   void define_builtin_var (const octave_value& v);
 
-  bool define_as_fcn (const octave_value& v);
+  bool define_builtin_const (const octave_value& v);
 
   bool define (octave_function *f, unsigned int sym_type);
 
   void document (const string& h) { definition->document (h); }
 
   void clear (void);
 
   void alias (symbol_record *s, bool force = false);
@@ -318,16 +334,18 @@ private:
   bool read_only_error (const char *action);
 
   void push_def (symbol_def *sd);
 
   void remove_top_def (void);
 
   void replace_all_defs (symbol_def *sd);
 
+  void link_to_builtin_variable (void);
+
   // No copying!
 
   symbol_record (const symbol_record& s);
 
   symbol_record& operator = (const symbol_record& s);
 };
 
 // A symbol table.
@@ -337,17 +355,18 @@ private:
 
 #define SYMTAB_ALL_SCOPES (SYMTAB_LOCAL_SCOPE | SYMTAB_GLOBAL_SCOPE)
 
 #define SYMTAB_ALL_TYPES (symbol_record::USER_FUNCTION \
 			  | symbol_record::USER_VARIABLE \
 			  | symbol_record::BUILTIN_FUNCTION \
 			  | symbol_record::TEXT_FUNCTION \
 			  | symbol_record::MAPPER_FUNCTION \
-			  | symbol_record::BUILTIN_VARIABLE)
+			  | symbol_record::BUILTIN_VARIABLE \
+			  | symbol_record::BUILTIN_CONSTANT)
 
 #define SYMTAB_VARIABLES (symbol_record::USER_VARIABLE \
 			  | symbol_record::BUILTIN_VARIABLE)
 
 class
 symbol_table
 {
 public:
diff --git a/src/toplev.cc b/src/toplev.cc
--- a/src/toplev.cc
+++ b/src/toplev.cc
@@ -24,17 +24,16 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include <cassert>
 #include <csetjmp>
 #include <csignal>
 #include <cstdlib>
 #include <cstring>
-#include <ctime>
 
 #include <string>
 
 #include <fstream.h>
 #include <iostream.h>
 #include <strstream.h>
 
 #ifdef HAVE_UNISTD_H
diff --git a/src/variables.cc b/src/variables.cc
--- a/src/variables.cc
+++ b/src/variables.cc
@@ -21,17 +21,16 @@ Software Foundation, 59 Temple Place - S
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cstdio>
 #include <cstring>
-#include <ctime>
 
 #include <string>
 
 #include "file-stat.h"
 #include "oct-env.h"
 #include "glob-match.h"
 #include "str-vec.h"
 
@@ -709,37 +708,30 @@ link_to_global_variable (symbol_record *
 	  sr->alias (gsr, 1);
 	}
     }
 }
 
 // Make the definition of the symbol record sr be the same as the
 // definition of the builtin variable of the same name.
 
-void
-link_to_builtin_variable (symbol_record *sr)
-{
-  symbol_record *tmp_sym = global_sym_tab->lookup (sr->name ());
-
-  if (tmp_sym && tmp_sym->is_builtin_variable ())
-    sr->alias (tmp_sym);
-}
-
 // Make the definition of the symbol record sr be the same as the
-// definition of the builtin variable or function, or user function of
-// the same name, provided that the name has not been used as a formal
-// parameter.
+// definition of the builtin variable, constant, or function, or user
+// function of the same name, provided that the name has not been used
+// as a formal parameter.
 
 void
 link_to_builtin_or_function (symbol_record *sr)
 {
   symbol_record *tmp_sym = global_sym_tab->lookup (sr->name ());
 
   if (tmp_sym
-      && (tmp_sym->is_builtin_variable () || tmp_sym->is_function ())
+      && (tmp_sym->is_builtin_variable ()
+	  || tmp_sym->is_builtin_constant ()
+	  || tmp_sym->is_function ())
       && ! tmp_sym->is_formal_parameter ())
     sr->alias (tmp_sym);
 }
 
 // Force a link to a function in the current symbol table.  This is
 // used just after defining a function to avoid different behavior
 // depending on whether or not the function has been evaluated after
 // being defined.
@@ -1202,20 +1194,20 @@ ignore_function_time_stamp (void)
 }
 
 // XXX FIXME XXX -- there still may be better places for some of these
 // to be defined.
 
 void
 symbols_of_variables (void)
 {
-  DEFVAR (ans, , 0, 0,
+  DEFVAR (ans, , 0,
     "");
 
-  DEFVAR (ignore_function_time_stamp, "system", 0, ignore_function_time_stamp,
+  DEFVAR (ignore_function_time_stamp, "system", ignore_function_time_stamp,
     "don't check to see if function files have changed since they were\n\
 last compiled.  Possible values are \"system\" and \"all\"");
 }
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
diff --git a/src/variables.h b/src/variables.h
--- a/src/variables.h
+++ b/src/variables.h
@@ -79,17 +79,16 @@ extern octave_value get_global_value (co
 
 extern void set_global_value (const string& nm, const octave_value& val);
 
 extern string builtin_string_variable (const string&);
 extern int builtin_real_scalar_variable (const string&, double&);
 extern octave_value builtin_any_variable (const string&);
 
 extern void link_to_global_variable (symbol_record *sr);
-extern void link_to_builtin_variable (symbol_record *sr);
 extern void link_to_builtin_or_function (symbol_record *sr);
 
 extern void force_link_to_function (const string&);
 
 extern void bind_ans (const octave_value& val, bool print);
 
 extern void bind_global_error_variable (void);
 
