# HG changeset patch
# User David Bateman <dbateman@free.fr>
# Date 1210625831 -7200
#      Mon May 12 22:57:11 2008 +0200
# Node ID df9519e9990c2b04db5cdc32d0953e0d9f4970ce
# Parent  2b458dfe31ae7e645cbdd0167b7d5d7bb44bd30b
Handle single precision eps values

diff --git a/scripts/ChangeLog b/scripts/ChangeLog
--- a/scripts/ChangeLog
+++ b/scripts/ChangeLog
@@ -19,16 +19,36 @@ 2008-05-19  John W. Eaton  <jwe@octave.o
 
 2008-05-13  Bill Denney  <bill@denney.ws>
 
 	* general/isa.m: Use persistent cell arrays to hold class names
 	instead of multiple strcmp calls.
 
 2008-05-12  David Bateman  <dbateman@free.fr>
 
+	* control/base/__stepimp__.m, control/base/bode_bounds.m,
+	control/base/damp.m, control/base/dlqr.m, control/base/lsim.m,
+	control/base/tzero.m, control/hinf/hinfsyn.m,
+	control/hinf/is_dgkf.m, control/system/d2c.m,
+	control/system/is_controllable.m, control/system/is_detectable.m,
+	control/system/is_stabilizable.m, control/system/is_stable.m,
+	control/system/sysconnect.m, general/bicubic.m,
+	general/cplxpair.m, general/isdefinite.m, general/issymmetric.m,
+	general/quadgk.m, general/quadl.m, general/quadv.m,
+	geometry/delaunayn.m, linear-algebra/krylov.m,
+	linear-algebra/null.m, linear-algebra/onenormest.m,
+	linear-algebra/orth.m, linear-algebra/rank.m,
+	linear-algebra/rref.m, optimization/qp.m, optimization/sqp.m,
+	polynomial/polygcd.m, polynomial/residue.m, sparse/normest.m,
+	specfun/erfinv.m, statistics/distributions/betainv.m,
+	statistics/distributions/gaminv.m,
+	statistics/distributions/kolmogorov_smirnov_cdf.m,
+	statistics/tests/manova.m: Modify calls to eps to allow for single
+	precision types.
+
 	* general/isa.m: Also treat "float: and "numeric" as the class
 	argument.
 
 	* general/dblquad.m, general/quadgk.m, general/quadv.m,
 	general/triplequad.m: New functions.
 
 	* testfun/assert.m: Allow assert(cond, errmsg, ...) and
 	assert(cond, msgid, errmsg, ...) syntax for compatibility.
diff --git a/scripts/control/base/__stepimp__.m b/scripts/control/base/__stepimp__.m
--- a/scripts/control/base/__stepimp__.m
+++ b/scripts/control/base/__stepimp__.m
@@ -61,17 +61,18 @@ function [y, t] = __stepimp__ (sitype, s
     inp = 1;
   elseif (inp < 1 || inp > NIN)
     error ("__stepimp__: argument inp out of range");
   endif
 
   DIGITAL = is_digital (sys);
   if (DIGITAL)
     NSTATES = ndstates;
-    if (TSAMPLE < eps)
+    if (isa (TSAMPLE, "single") && TSAMPLE < eps ("single") ||
+	!isa (TSAMPLE, "single") && TSAMPLE < eps)
       error ("__stepimp__: sampling time of discrete system too small")
     endif
   else
     NSTATES = ncstates;
   endif
   if (NSTATES < 1)
     error ("__stepimp__: pure gain block (n_states < 1), step response is trivial");
   endif
diff --git a/scripts/control/base/bode_bounds.m b/scripts/control/base/bode_bounds.m
--- a/scripts/control/base/bode_bounds.m
+++ b/scripts/control/base/bode_bounds.m
@@ -43,38 +43,44 @@ function [wmin, wmax] = bode_bounds (zer
   ## make sure zer,pol are row vectors
   if (! isempty (pol))
     pol = reshape (pol, 1, length (pol));
   endif
   if (! isempty (zer))
     zer = reshape (zer, 1, length (zer));
   endif
 
+  if (isa (zer, "single") || isa (pol, "single"))
+    myeps = eps ("single");
+  else
+    myeps = eps;
+  endif
+
   ## check for natural frequencies away from omega = 0
   if (DIGITAL)
     ## The 2nd conditions prevents log(0) in the next log command
-    iiz = find (abs(zer-1) > norm(zer)*eps && abs(zer) > norm(zer)*eps);
-    iip = find (abs(pol-1) > norm(pol)*eps && abs(pol) > norm(pol)*eps);
+    iiz = find (abs(zer-1) > norm(zer)*myeps && abs(zer) > norm(zer)*myeps);
+    iip = find (abs(pol-1) > norm(pol)*myeps && abs(pol) > norm(pol)*myeps);
 
     ## avoid dividing empty matrices, it would work but looks nasty
     if (! isempty (iiz))
       czer = log (zer(iiz))/tsam;
     else
       czer = [];
     endif
 
     if (! isempty (iip))
       cpol = log (pol(iip))/tsam;
     else
       cpol = [];
     endif
   else
     ## continuous
-    iip = find (abs(pol) > norm(pol)*eps);
-    iiz = find (abs(zer) > norm(zer)*eps);
+    iip = find (abs(pol) > norm(pol)*myeps);
+    iiz = find (abs(zer) > norm(zer)*myeps);
 
     if (! isempty (zer))
       czer = zer(iiz);
     else
       czer = [];
     endif
     if (! isempty (pol))
       cpol = pol(iip);
diff --git a/scripts/control/base/damp.m b/scripts/control/base/damp.m
--- a/scripts/control/base/damp.m
+++ b/scripts/control/base/damp.m
@@ -71,17 +71,18 @@ function damp (p, tsam)
   for i = 1:n
     pole = e(i);
     cpole = pole;
     if (DIGITAL)
       cpole = log (pole) / t_samp;
     endif
     d0 = -cos (atan2 (imag (cpole), real (cpole)));
     f0 = 0.5 / pi * abs (cpole);
-    if (abs (imag (cpole)) < eps)
+    if (isa (cpole, "single") && abs(imag (cpole)) < eps ("single") || 
+	! isa (cpole, "single") && abs (imag (cpole)) < eps)
       printf ("%12f         ---  %12f  %10f  %12f\n",
              real (pole), abs (pole), d0, f0);
     else
       printf ("%12f %12f %12f  %10f  %12f\n",
              real (pole), imag (pole), abs (pole), d0, f0);
     endif
   endfor
 
diff --git a/scripts/control/base/dlqr.m b/scripts/control/base/dlqr.m
--- a/scripts/control/base/dlqr.m
+++ b/scripts/control/base/dlqr.m
@@ -125,17 +125,21 @@ function [k, p, e] = dlqr (a, b, q, r, s
   else
     s = zeros (n, m);
     ao = a;
     qo = q;
   endif
 
   ## Checking stabilizability and detectability (dimensions are checked
   ## inside these calls).
-  tol = 200*eps;
+  if (isa (a, "single") || isa (b, "single") || isa (q, "single") || isa (r, "single"))
+    tol = 200 * eps ("single");
+  else
+    tol = 200 * eps;
+  endif
   if (is_stabilizable (ao, b, tol, 1) == 0)
     error ("dlqr: (a,b) not stabilizable");
   endif
   dflag = is_detectable (ao, qo, tol, 1);
   if (dflag == 0)
     warning ("dlqr: (a,q) not detectable");
   elseif (dflag == -1)
     error ("dlqr: (a,q) has non minimal modes near unit circle");
diff --git a/scripts/control/base/lsim.m b/scripts/control/base/lsim.m
--- a/scripts/control/base/lsim.m
+++ b/scripts/control/base/lsim.m
@@ -69,23 +69,27 @@ function [y, x] = lsim (sys, u, t, x0)
   if (rows (x0) > rows (a))
     error ("lsim: Initial condition vector is too large");
   endif
 
   Ts = 0;
   t(2)-t(1);
   u=u';
   n = max (size (t));
-
+  
+  if (isa (t, "single"))
+    tol = 10 * eps ("single");
+  else
+    tol = 10 * eps;
+  endif
   for ii = 1:(n-1)
-
     ## check if step size changed
     ## FIXME -- this is probably not the best test, but it is
     ## better than a test for exact equality.
-    if (abs (t(ii+1) - t(ii) - Ts) > 10 * eps)
+    if (abs (t(ii+1) - t(ii) - Ts) > tol)
       Ts = t(ii+1) - t(ii);
       ## [F,G] = c2d(a,b,Ts);
       dsys = c2d (sys, Ts);
       [F, G] = sys2ss (dsys);
     endif
 
     x(:,ii) = x0;
     x0 = F*x0 + G*u(:,ii);
diff --git a/scripts/control/base/tzero.m b/scripts/control/base/tzero.m
--- a/scripts/control/base/tzero.m
+++ b/scripts/control/base/tzero.m
@@ -93,17 +93,21 @@ function [zer, gain] = tzero (A, B, C, D
   endif
 
   ## First, balance the system via the zero computation generalized eigenvalue
   ## problem balancing method (Hodel and Tiller, Linear Alg. Appl., 1992)
 
   ## balance coefficients
   Asys = __zgpbal__ (Asys);
   [A, B, C, D] = sys2ss (Asys);
-  meps = 2*eps*norm ([A, B; C, D], "fro");
+  if (isa ([A, B; C, D], "single"))
+    meps = 2*eps("single")*norm ([A, B; C, D], "fro");
+  else
+    meps = 2*eps*norm ([A, B; C, D], "fro");
+  endif
   ## ENVD algorithm
   Asys = zgreduce (Asys, meps);
   [A, B, C, D] = sys2ss (Asys);
   if (! isempty (A))
     ## repeat with dual system
     Asys = ss (A', C', B', D');
     Asys = zgreduce (Asys, meps);
 
diff --git a/scripts/control/hinf/hinfsyn.m b/scripts/control/hinf/hinfsyn.m
--- a/scripts/control/hinf/hinfsyn.m
+++ b/scripts/control/hinf/hinfsyn.m
@@ -131,17 +131,22 @@
 
 function [K, g, GW, Xinf, Yinf] = hinfsyn (Asys, nu, ny, gmin, gmax, gtol, ptol, tol)
 
   if (nargin < 1 || nargin > 8)
     print_usage ();
   endif
   ## set default arguments
   if (nargin < 8)
-    tol = 200*eps;
+    if (isa (Asys.a, "single") || isa (Asys.b, "single") || isa (Asys.c, "single") ||
+	isa (Asys.d, "single"))
+      tol = 200*eps("single");
+    else
+      tol = 200*eps;
+    endif
   elseif (! is_sample (tol))
     error ("tol must be a positive scalar.")
   endif
   if (nargin < 7)
     ptol = 1e-9;
   elseif (! is_sample (ptol))
     error ("hinfsyn: ptol must be a positive scalar");
   endif
diff --git a/scripts/control/hinf/is_dgkf.m b/scripts/control/hinf/is_dgkf.m
--- a/scripts/control/hinf/is_dgkf.m
+++ b/scripts/control/hinf/is_dgkf.m
@@ -134,18 +134,23 @@ function [retval, dgkf_struct] = is_dgkf
   if (nargin < 3) || (nargin > 4)
     print_usage ();
   elseif (! isscalar (nu) || ! isscalar (ny))
     error ("is_dgkf: arguments 2 and 3 must be scalars")
   elseif (! isstruct (Asys))
     error ("Argument 1 must be a system data structure");
   endif
   if (nargin < 4)
-    tol = 200*eps;
-  elseif (! is_sample (tol))
+    if (isa (Asys.a, "single") || isa (Asys.b, "single") || isa (Asys.c, "single") ||
+	isa (Asys.d, "single"))
+      tol = 200*eps("single");
+    else
+      tol = 200*eps;
+    endif
+      elseif (! is_sample (tol))
     error ("is_dgkf: tol must be a positive scalar")
   endif
 
   retval = 1;           # assume passes test
 
   dflg = is_digital (Asys);
   [Anc, Anz, nin, nout ] = sysdimensions (Asys);
 
diff --git a/scripts/control/system/d2c.m b/scripts/control/system/d2c.m
--- a/scripts/control/system/d2c.m
+++ b/scripts/control/system/d2c.m
@@ -84,26 +84,33 @@ function csys = d2c (sys, opt)
     warning ("d2c: ridiculous error tolerance passed=%g, intended c2d call?",
 	     opt);
   else
     tol = opt;
     opt = "log";
   endif
   T = sysgettsam (sys);
 
+  if (isa (sys.a, "single") || isa (sys.b, "single") || isa (sys.c, "single") ||
+      isa (sys.d, "single"))
+    myeps = eps ("single");
+  else
+    myeps = eps;
+  endif
+
   if (strcmp (opt, "bi"))
     ## bilinear transform
     ## convert with bilinear transform
     if (! is_digital (sys) )
        error ("d2c requires a discrete time system for input")
     endif
     [a, b, c, d, tsam, n, nz, stname, inname, outname, yd] = sys2ss (sys);
 
     poles = eig (a);
-    if (find (abs (poles-1) < 200*(n+nz)*eps))
+    if (find (abs (poles-1) < 200*(n+nz)*myeps))
       warning ("d2c: some poles very close to one.  May get bad results.");
     endif
 
     I = eye (size (a));
     tk = 2 / sqrt (T);
     A = (2/T)*(a-I)/(a+I);
     iab = (I+a)\b;
     B = tk*iab;
@@ -131,20 +138,20 @@ function csys = d2c (sys, opt)
     if (isempty (b))
       warning ("d2c: empty b matrix");
       Amat = a;
     else
       Amat = [a, b; zeros(nb,na), eye(nb)];
     endif
 
     poles = eig (a);
-    if (find (abs (poles) < 200*(n+nz)*eps))
+    if (find (abs (poles) < 200*(n+nz)*myeps))
       warning ("d2c: some poles very close to zero.  logm not performed");
       Mtop = zeros (ma, na+nb);
-    elseif (find (abs (poles-1) < 200*(n+nz)*eps))
+    elseif (find (abs (poles-1) < 200*(n+nz)*myeps))
       warning ("d2c: some poles very close to one.  May get bad results.");
       logmat = real (logm (Amat) / T);
       Mtop = logmat(1:na,:);
     else
       logmat = real (logm (Amat) / T);
       Mtop = logmat(1:na,:);
     endif
 
diff --git a/scripts/control/system/is_controllable.m b/scripts/control/system/is_controllable.m
--- a/scripts/control/system/is_controllable.m
+++ b/scripts/control/system/is_controllable.m
@@ -85,17 +85,21 @@ function [retval, U] = is_controllable (
       print_usage ();
     else
       deftol = 1;
     endif
   endif
 
   ## check for default tolerance
   if (deftol)
-    tol = 1000*eps;
+    if (isa (a, "single") || isa (b, "single"))
+      tol = 1000 * eps("single");
+    else
+      tol = 1000*eps;
+    endif
   endif
 
   ## check tol dimensions
   if (! isscalar (tol))
     error ("is_controllable: tol(%dx%d) must be a scalar", ...
            rows (tol), columns (tol));
   elseif (! is_sample (tol))
     error ("is_controllable: tol=%e must be positive",tol);
diff --git a/scripts/control/system/is_detectable.m b/scripts/control/system/is_detectable.m
--- a/scripts/control/system/is_detectable.m
+++ b/scripts/control/system/is_detectable.m
@@ -54,15 +54,19 @@ function [retval, U] = is_detectable (a,
       print_usage ();
     endif
     if (! exist ("dflg"))
       dflg = 0;
     endif
   endif
 
   if (! exist ("tol"))
-    tol = 200*eps;
+    if (isa (a, "single") || isa (c, "single"))
+      tol = 200 * eps("single");
+    else
+      tol = 200 * eps;
+    endif
   endif
 
   retval = is_stabilizable (a', c', tol, dflg);
 
 endfunction
 
diff --git a/scripts/control/system/is_stabilizable.m b/scripts/control/system/is_stabilizable.m
--- a/scripts/control/system/is_stabilizable.m
+++ b/scripts/control/system/is_stabilizable.m
@@ -65,20 +65,23 @@ function retval = is_stabilizable (a, b,
     if (exist ("dflg"))
       disc = dflg;
     else
       disc = 0;
     endif
   endif
 
   if (! exist ("tol"))
-    tol = 200*eps;
+    if (isa (a, "single") || isa (b, "single"))
+      tol = 200 * eps("single");
+    else
+      tol = 200 * eps;
+    endif
   endif
 
-
   ## Checking dimensions
   n = is_square (a);
   if (n == 0)
     error ("is_stabilizable: a must be square");
   endif
   [nr, m] = size (b);
   if (nr != n)
     error ("is_stabilizable:  (a,b) not conformal");
diff --git a/scripts/control/system/is_stable.m b/scripts/control/system/is_stable.m
--- a/scripts/control/system/is_stable.m
+++ b/scripts/control/system/is_stable.m
@@ -64,17 +64,21 @@ function retval = is_stable (a, tol, dis
       disc = 0;
     endif
     if (issquare (a) == 0)
       error ("A(%dx%d) must be square", rows (A), columns (A));
     endif
   endif
 
   if (nargin < 2)
-    tol = 200*eps;
+    if (isa (a, "single"))
+      tol = 200 * eps("single");
+    else
+      tol = 200 * eps;
+    endif
   elseif (! isscalar (tol))
     error ("is_stable: tol(%dx%d) must be a scalar", rows (tol),
 	   columns (tol));
   endif
 
   l = eig (a);
   if (disc)
     nbad = sum (abs(l)*(1+tol) > 1);
diff --git a/scripts/control/system/sysconnect.m b/scripts/control/system/sysconnect.m
--- a/scripts/control/system/sysconnect.m
+++ b/scripts/control/system/sysconnect.m
@@ -81,22 +81,29 @@ function sys = sysconnect (sys, output_l
 
   ## check order
   if (nargin < 4)
     order = 0;
   elseif (order != 0 && order != 1)
     error ("sysconnect: order must be either 0 or 1")
   endif
 
+  if (isa (sys.a, "single") || isa (sys.b, "single") || isa (sys.c, "single") ||
+      isa (sys.d, "single"))
+    myeps = eps ("single");
+  else
+    myeps = eps;
+  endif
+
   if (nargin < 5)
-    tol = 200*eps;
+    tol = 200*myeps;
   elseif (! is_sample (tol))
     error ("sysconnect: tol must be a positive scalar");
-  elseif (tol > 1e2*sqrt(eps))
-    warning ("sysconnect: tol set to large value=%g, eps=%g", tol, eps);
+  elseif (tol > 1e2*sqrt(myeps))
+    warning ("sysconnect: tol set to large value=%g, eps=%g", tol, myeps);
   endif
 
   ## convert signal names to indices
   if (is_signal_list (input_list) || ischar (input_list))
     input_list = sysidx (sys, "in", input_list);
   endif
   if (is_signal_list (output_list) || ischar (output_list))
     output_list = sysidx (sys, "out", output_list);
diff --git a/scripts/general/bicubic.m b/scripts/general/bicubic.m
--- a/scripts/general/bicubic.m
+++ b/scripts/general/bicubic.m
@@ -43,16 +43,23 @@ function F = bicubic (X, Y, Z, XI, YI, e
   else
     a = 0.5;
   endif
 
   if (nargin < 6)
     extrapval = NaN;
   endif
 
+  if (isa (X, "single") || isa (Y, "single") || isa (Z, "single") || 
+      isa (XI, "single") || isa (YI, "single"))
+    myeps = eps("single");
+  else
+    myeps = eps;
+  endif
+
   if (nargin <= 2)
     ## bicubic (Z) or bicubic (Z, 2)
     if (nargin == 1) 
       n = 1;
     else
       n = Y;
     endif
     Z = X;
@@ -89,29 +96,29 @@ function F = bicubic (X, Y, Z, XI, YI, e
     ## set value outside the table preliminary to min max index   
     XI(xfirst_ind) = X(1);
     XI(xlast_ind) = X(cz);
     YI(yfirst_ind) = Y(1);
     YI(ylast_ind) = Y(rz);
 
 
     X = reshape (X, 1, cz);
-    X(cz) *= 1 + sign (X(cz))*eps;
+    X(cz) *= 1 + sign (X(cz))*myeps;
     if (X(cz) == 0) 
-      X(cz) = eps;
+      X(cz) = myeps;
     endif; 
     XI = reshape (XI, 1, length (XI));
     [m, i] = sort ([X, XI]);
     o = cumsum (i <= cz);
     xidx = o(find (i > cz));
     
     Y = reshape (Y, rz, 1);
-    Y(rz) *= 1 + sign (Y(rz))*eps;
+    Y(rz) *= 1 + sign (Y(rz))*myeps;
     if (Y(rz) == 0) 
-      Y(rz) = eps;
+      Y(rz) = myeps;
     endif; 
     YI = reshape (YI, length (YI), 1);
     [m, i] = sort ([Y; YI]);
     o = cumsum (i <= rz);
     yidx = o([find( i> rz)]);
     
     ## set s and t used follow codes
     s = xidx + ((XI .- X(xidx))./(X(xidx+1) .- X(xidx)));
diff --git a/scripts/general/cplxpair.m b/scripts/general/cplxpair.m
--- a/scripts/general/cplxpair.m
+++ b/scripts/general/cplxpair.m
@@ -55,17 +55,21 @@ function y = cplxpair (z, tol, dim)
   endif
 
   if (length (z) == 0)
     y = zeros (size (z));
     return; 
   endif
 
   if (nargin < 2 || isempty (tol))
-    tol = 100*eps; 
+    if (isa (z, "single"))
+      tol = 100 * eps("single");
+    else
+      tol = 100*eps; 
+    endif
   endif
 
   nd = ndims (z);
   orig_dims = size (z);
   if (nargin < 3)
     ## Find the first singleton dimension.
     dim = 0;
     while (dim < nd && orig_dims(dim+1) == 1)
@@ -90,17 +94,21 @@ function y = cplxpair (z, tol, dim)
   m = prod (sz) / n;
   z = reshape (z, n, m);
 
   ## Sort the sequence in terms of increasing real values
   [q, idx] = sort (real (z), 1);
   z = z(idx + n * ones (n, 1) * [0:m-1]);
 
   ## Put the purely real values at the end of the returned list
-  [idxi, idxj] = find (abs (imag (z)) ./ (abs (z) + realmin) < tol );
+  cls = "double";
+  if (isa (z, "single"))
+    cls = "single";
+  endif
+  [idxi, idxj] = find (abs (imag (z)) ./ (abs (z) + realmin(cls)) < tol );
   q = sparse (idxi, idxj, 1, n, m);
   nr = sum (q, 1);
   [q, idx] = sort (q, 1);
   z = z(idx);
   y = z;
 
   ## For each remaining z, place the value and its conjugate at the
   ## start of the returned list, and remove them from further
diff --git a/scripts/general/isdefinite.m b/scripts/general/isdefinite.m
--- a/scripts/general/isdefinite.m
+++ b/scripts/general/isdefinite.m
@@ -28,17 +28,21 @@
 ## Author: Gabriele Pannocchia <g.pannocchia@ing.unipi.it>
 ## Created: November 2003
 ## Adapted-By: jwe
 
 function retval = isdefinite (x, tol)
 
   if (nargin == 1 || nargin == 2)
     if (nargin == 1)
-      tol = 100*eps;
+      if (isa (x, "single"))
+	tol = 100 * eps("single");
+      else
+	tol = 100*eps; 
+      endif
     endif
     sym = issymmetric (x, tol);
     if (sym > 0)
       ## Matrix is symmetric, check eigenvalues.
       mineig = min (eig (x));
       if (mineig > tol)
 	retval = 1;
       elseif (mineig > -tol)
diff --git a/scripts/general/issymmetric.m b/scripts/general/issymmetric.m
--- a/scripts/general/issymmetric.m
+++ b/scripts/general/issymmetric.m
@@ -33,17 +33,21 @@
 ## Adapted-By: jwe
 
 function retval = issymmetric (x, tol)
 
   if (nargin == 1 || nargin == 2)
     retval = issquare (x);
     if (retval != 0)
       if (nargin == 1)
-        tol = eps;
+	if (isa (x, "single"))
+	  tol = eps("single");
+	else
+	  tol = eps; 
+	endif
       endif
       norm_x = norm (x, inf);
       if (norm_x != 0 && norm (x - x', inf) / norm_x > tol)
         retval = 0;
       endif
     endif
   else
     print_usage ();
diff --git a/scripts/general/quadgk.m b/scripts/general/quadgk.m
--- a/scripts/general/quadgk.m
+++ b/scripts/general/quadgk.m
@@ -286,22 +286,28 @@ function [q, err] = quadgk (f, a, b, var
       ## Singularity will cause divide by zero warnings
       warning ("off", "Octave:divide-by-zero")
 
       ## Initial evaluation of the integrand on the sub-intervals
       [q_subs, q_errs] = __quadgk_eval__ (f, subs);
       q0 = sum (q_subs);
       err0 = sum (q_errs);
     
+      if (isa (a, "single") || isa (b, "single") || isa (waypoints, "single"))
+	myeps = eps ("single");
+      else
+	myeps = eps;
+      endif
+
       first = true;
       while (true)
 	## Check for sub-intervals that are too small. Test must be
 	## performed in untransformed sub-intervals. What is a good
 	## value for this test. Shampine suggests 100*eps
-	if (any (diff (trans (subs), [], 2) / (b - a) < 100 * eps))
+	if (any (diff (trans (subs), [], 2) / (b - a) < 100 * myeps))
 	  q = q0;
 	  err = err0;
 	  break;
 	endif
 
 	## Quit if any evaluations are not finite (Inf or NaN)
 	if (any (! isfinite (q_subs)))
 	  warning ("quadgk: non finite integrand encountered"); 
diff --git a/scripts/general/quadl.m b/scripts/general/quadl.m
--- a/scripts/general/quadl.m
+++ b/scripts/general/quadl.m
@@ -58,24 +58,29 @@
 function Q = quadl (f, a, b, tol, trace, varargin)
   need_warning (1);
   if (nargin < 4)
     tol = []; 
   endif
   if (nargin < 5)
     trace = []; 
   endif
+  if (isa (a, "single") || isa (b, "single"))
+    myeps = eps ("single");
+  else
+    myeps = eps;
+  endif
   if (isempty (tol))
-    tol = eps; 
+    tol = myeps; 
   endif
   if (isempty (trace))
     trace = 0; 
   endif
-  if (tol < eps)
-    tol = eps;
+  if (tol < myeps)
+    tol = myeps;
   endif
 
   m = (a+b)/2; 
   h = (b-a)/2;
   alpha = sqrt(2/3); 
   beta = 1/sqrt(5);
 
   x1 = .942882415695480; 
@@ -114,17 +119,17 @@ function Q = quadl (f, a, b, tol, trace,
   erri2 = abs(i2-is);
   R = 1; 
   if (erri2 != 0)
     R = erri1/erri2; 
   endif
   if (R > 0 && R < 1)
     tol = tol/R; 
   endif
-  is = s*abs(is)*tol/eps;
+  is = s*abs(is)*tol/myeps;
   if (is == 0)
     is = b-a;
   endif
   Q = adaptlobstp (f, a, b, fa, fb, is, trace, varargin{:});
 endfunction
 
 ## ADAPTLOBSTP  Recursive function used by QUADL.
 ##
diff --git a/scripts/general/quadv.m b/scripts/general/quadv.m
--- a/scripts/general/quadv.m
+++ b/scripts/general/quadv.m
@@ -47,16 +47,21 @@ function [Q, fcnt] = quadv (f, a, b, tol
     print_usage ();
   endif
   if (nargin < 4)
     tol = []; 
   endif
   if (nargin < 5)
     trace = []; 
   endif
+  if (isa (a, "single") || isa (b, "single"))
+    myeps = eps ("single");
+  else
+    myeps = eps;
+  endif
   if (isempty (tol))
     tol = 1e-6; 
   endif
   if (isempty (trace))
     trace = 0; 
   endif
 
   ## Split the interval into 3 abscissa, and apply a 3 point Simpson's rule
@@ -64,33 +69,33 @@ function [Q, fcnt] = quadv (f, a, b, tol
   fa = feval (f, a, varargin{:});
   fc = feval (f, c, varargin{:});
   fb = feval (f, b, varargin{:});
   fcnt = 3;
 
   ## If have edge singularities, move edge point by eps*(b-a) as
   ## discussed in Shampine paper used to implement quadgk
   if (isinf (fa))
-    fa = feval (f, a + eps * (b-a), varargin{:});
+    fa = feval (f, a + myeps * (b-a), varargin{:});
   endif
   if (isinf (fb))
-    fb = feval (f, b - eps * (b-a), varargin{:});
+    fb = feval (f, b - myeps * (b-a), varargin{:});
   endif
 
   h = (b - a) / 2;
   Q = (b - a) / 6 * (fa + 4 * fc + fb);
  
   [Q, fcnt, hmin] = simpsonstp (f, a, b, c, fa, fb, fc, Q, fcnt, abs (b - a), 
 				tol, trace, varargin{:});
 
   if (fcnt > 10000)
     warning("Maximum iteration count reached");
   elseif (isnan(Q) || isinf (Q))
     warning ("Infinite or NaN function evaluations were returned");
-  elseif (hmin < (b - a) * eps)
+  elseif (hmin < (b - a) * myeps)
     warning ("Minimum step size reached. Possibly singular integral");
   endif
 endfunction
 
 function [Q, fcnt, hmin] = simpsonstp (f, a, b, c, fa, fb, fc, Q0, 
 				       fcnt, hmin, tol, trace, varargin)
   if (fcnt > 10000)
     Q = Q0;
diff --git a/scripts/geometry/delaunayn.m b/scripts/geometry/delaunayn.m
--- a/scripts/geometry/delaunayn.m
+++ b/scripts/geometry/delaunayn.m
@@ -49,27 +49,33 @@
 
 function t = delaunayn (x, varargin)
   if (nargin < 1)
     print_usage ();
   endif
 
   t = __delaunayn__ (x, varargin{:});
 
+  if (isa (x, "single"))
+    myeps = eps ("single");
+  else
+    myeps = eps;
+  endif
+
   ## Try to remove the zero volume simplices. The volume of the i-th simplex is
   ## given by abs(det(x(t(i,1:end-1),:)-x(t(i,2:end),:)))/prod(1:n) 
   ## (reference http://en.wikipedia.org/wiki/Simplex). Any simplex with a 
   ## relative volume less than some arbitrary criteria is rejected. The 
   ## criteria we use is the volume of the simplex corresponding to an 
   ## orthogonal simplex is equal edge length all equal to the edge length of 
   ## the original simplex. If the relative volume is 1e3*eps then the simplex
   ## is rejected. Note division of the two volumes means that the factor 
   ## prod(1:n) is dropped.
   idx = [];
   [nt, n] = size (t);
   for i = 1:nt
     X = x(t(i,1:end-1),:) - x(t(i,2:end),:);
-    if (abs (det (X)) /  sqrt (sum (X .^ 2, 2)) < 1e3 * eps)
+    if (abs (det (X)) /  sqrt (sum (X .^ 2, 2)) < 1e3 * myeps)
      idx = [idx, i];
     endif
   endfor
   t(idx,:) = [];
 endfunction
diff --git a/scripts/linear-algebra/krylov.m b/scripts/linear-algebra/krylov.m
--- a/scripts/linear-algebra/krylov.m
+++ b/scripts/linear-algebra/krylov.m
@@ -54,17 +54,21 @@
 ## Krylov Subspaces", to be submitted to Linear Algebra and its
 ## Applications
 ## @end deftypefn
 
 ## Author: A. Scottedward Hodel <a.s.hodel@eng.auburn.edu>
 
 function [Uret, H, nu] = krylov (A, V, k, eps1, pflg);
 
-  defeps = 1e-12;
+  if (isa (A, "single") || isa (V, "single"))
+    defeps = 1e-6
+  else
+    defeps = 1e-12;
+  endif
 
   if (nargin < 3 || nargin > 5)
     print_usage ();
   elseif (nargin < 5)
     pflg = 0;        # default permutation flag
   endif
 
   if(nargin < 4)
diff --git a/scripts/linear-algebra/null.m b/scripts/linear-algebra/null.m
--- a/scripts/linear-algebra/null.m
+++ b/scripts/linear-algebra/null.m
@@ -47,24 +47,32 @@ function retval = null (A, tol)
 
     if (S_nr == 1 || S_nc == 1)
       s = S(1);
     else
       s = diag (S);
     endif
 
     if (nargin == 1)
-      tol = max (size (A)) * s (1) * eps;
+      if (isa (A, "single"))
+	tol = max (size (A)) * s (1) * eps ("single");
+      else
+	tol = max (size (A)) * s (1) * eps;
+      endif
     elseif (nargin != 2)
       print_usage ();
     endif
 
     rank = sum (s > tol);
 
     if (rank < cols)
       retval = V (:, rank+1:cols);
-      retval(abs (retval) < eps) = 0;
+      if (isa (A, "single"))
+	retval(abs (retval) < eps ("single")) = 0;
+      else
+	retval(abs (retval) < eps) = 0;
+      endif
     else
       retval = zeros (cols, 0);
     endif
   endif
 
 endfunction
diff --git a/scripts/linear-algebra/onenormest.m b/scripts/linear-algebra/onenormest.m
--- a/scripts/linear-algebra/onenormest.m
+++ b/scripts/linear-algebra/onenormest.m
@@ -106,38 +106,47 @@ function [est, v, w, iter] = onenormest 
     endif
     apply = @(x) varargin{1} * x;
     apply_t = @(x) varargin{1}' * x;
     if (size (varargin) > 1)
       t = varargin{2};
     else
       t = min (n, default_t);
     endif
+    issing = isa (varargin {1}, "single");
   else
     if (size (varargin, 2) < 3)
       print_usage();
     endif
     n = varargin{3};
     apply = varargin{1};
     apply_t = varargin{2};
     if (size (varargin) > 3)
       t = varargin{4};
     else
       t = default_t;
     endif
+    issing = isa (varargin {3}, "single");
   endif
 
   ## Initial test vectors X.
   X = rand (n, t);
   X = X ./ (ones (n,1) * sum (abs (X), 1));
 
   been_there = zeros (n, 1); # Track if a vertex has been visited.
   est_old = 0; # To check if the estimate has increased.
   S = zeros (n, t); # Normalized vector of signs.  The normalization is 
 
+  if (issing)
+    myeps = eps ("single");
+    X = single (X);
+  else
+    myeps = eps;
+  endif
+
   for iter = 1 : itmax + 1
     Y = feval (apply, X);
 
     ## Find the initial estimate as the largest A*x.
     [est, ind_best] = max (sum (abs (Y), 1));
     if (est > est_old || iter == 2)
       w = Y(:,ind_best);
     endif
diff --git a/scripts/linear-algebra/orth.m b/scripts/linear-algebra/orth.m
--- a/scripts/linear-algebra/orth.m
+++ b/scripts/linear-algebra/orth.m
@@ -46,17 +46,21 @@ function retval = orth (A, tol)
 
     if (S_nr == 1 || S_nc == 1)
       s = S(1);
     else
       s = diag (S);
     endif
 
     if (nargin == 1)
-      tol = max (size (A)) * s (1) * eps;
+      if (isa (A, "single"))
+	tol = max (size (A)) * s (1) * eps ("single");
+      else
+	tol = max (size (A)) * s (1) * eps;
+      endif
     endif
 
     rank = sum (s > tol);
 
     if (rank > 0)
       retval = -U (:, 1:rank);
     else
       retval = zeros (rows, 0);
diff --git a/scripts/linear-algebra/rank.m b/scripts/linear-algebra/rank.m
--- a/scripts/linear-algebra/rank.m
+++ b/scripts/linear-algebra/rank.m
@@ -37,17 +37,21 @@
 
 function retval = rank (A, tol)
 
   if (nargin == 1)
     sigma = svd (A);
     if (isempty (sigma))
       tolerance = 0;
     else
-      tolerance = max (size (A)) * sigma (1) * eps;
+      if (isa (A, "single"))
+	tolerance = max (size (A)) * sigma (1) * eps ("single");
+      else
+	tolerance = max (size (A)) * sigma (1) * eps;
+      endif
     endif
   elseif (nargin == 2)
     sigma = svd (A);
     tolerance = tol;
   else
     print_usage ();
   endif
 
diff --git a/scripts/linear-algebra/rref.m b/scripts/linear-algebra/rref.m
--- a/scripts/linear-algebra/rref.m
+++ b/scripts/linear-algebra/rref.m
@@ -39,17 +39,21 @@ function [A, k] = rref (A, tolerance)
 
   if (ndims (A) > 2)
     error ("rref: expecting matrix argument");
   endif
 
   [rows, cols] = size (A);
 
   if (nargin < 2)
-    tolerance = eps * max (rows, cols) * norm (A, inf);
+    if (isa (A, "single"))
+      tolerance = eps ("single") * max (rows, cols) * norm (A, inf ("single"));
+    else
+      tolerance = eps * max (rows, cols) * norm (A, inf);
+    endif
   endif
 
   used = zeros (1, cols);
   r = 1;
   for c = 1:cols
     ## Find the pivot row
     [m, pivot] = max (abs (A(r:rows,c)));
     pivot = r + pivot - 1;
diff --git a/scripts/optimization/qp.m b/scripts/optimization/qp.m
--- a/scripts/optimization/qp.m
+++ b/scripts/optimization/qp.m
@@ -183,17 +183,22 @@ function [x, obj, INFO, lambda] = qp (x0
     idx = isinf (bin) & bin < 0;
 
     bin(idx) = [];
     Ain(idx,:) = [];
 
     n_in = length (bin);
 
     ## Check if the initial guess is feasible.
-    rtol = sqrt (eps);
+    if (isa (x0, "single") || isa (H, "single") || isa (q, "single") || isa (A, "single")
+	|| isa (b, "single"))
+      rtol = sqrt (eps ("single"));
+    else
+      rtol = sqrt (eps);
+    endif
 
     eq_infeasible = (n_eq > 0 && norm (A*x0-b) > rtol*(1+norm (b)));
     in_infeasible = (n_in > 0 && any (Ain*x0-bin < -rtol*(1+norm (bin))));
 
     info = 0;
     if (eq_infeasible || in_infeasible)
       ## The initial guess is not feasible.
       ## First define xbar that is feasible with respect to the equality
diff --git a/scripts/optimization/sqp.m b/scripts/optimization/sqp.m
--- a/scripts/optimization/sqp.m
+++ b/scripts/optimization/sqp.m
@@ -276,26 +276,34 @@ function [x, obj, info, iter, nf, lambda
       	elseif (! isempty (cif))
 	  ci_fun = cif;
       	endif
       else
 	global __sqp_lb__;
 	if (isvector (lb))
 	  __sqp_lb__ = lb;
 	elseif (isempty (lb))
-	  __sqp_lb__ = -realmax;
+	  if (isa (x, "single"))
+	    __sqp_lb__ = -realmax ("single");
+	  else
+	    __sqp_lb__ = -realmax;
+	  endif
 	else
 	  error ("sqp: invalid lower bound");
 	endif
 
 	global __sqp_ub__;
 	if (isvector (ub))
 	  __sqp_ub__ = ub;
 	elseif (isempty (lb))
-	  __sqp_ub__ = realmax;
+	  if (isa (x, "single"))
+	    __sqp_ub__ = realmax ("single");
+	  else
+	    __sqp_ub__ = realmax;
+	  endif
 	else
 	  error ("sqp: invalid upper bound");
 	endif
 
 	if (lb > ub)
 	  error ("sqp: upper bound smaller than lower bound");
 	endif
        	__sqp_ci_fun__ = ci_fun = @cf_ub_lb;
diff --git a/scripts/polynomial/polygcd.m b/scripts/polynomial/polygcd.m
--- a/scripts/polynomial/polygcd.m
+++ b/scripts/polynomial/polygcd.m
@@ -40,17 +40,21 @@
 ## @seealso{poly, polyinteg, polyderiv, polyreduce, roots, conv, deconv,
 ## residue, filter, polyval, and polyvalm}
 ## @end deftypefn
 
 function x = polygcd (b, a, tol)
 
   if (nargin == 2 || nargin == 3)
     if (nargin == 2)
-      tol = sqrt (eps);
+      if (isa (a, "single") || isa (b, "single"))
+	tol = sqrt (eps ("single"));
+      else
+	tol = sqrt (eps);
+      endif
     endif
     if (length (a) == 1 || length (b) == 1)
       if (a == 0)
 	x = b;
       elseif (b == 0)
 	x = a;
       else
 	x = 1;
diff --git a/scripts/polynomial/residue.m b/scripts/polynomial/residue.m
--- a/scripts/polynomial/residue.m
+++ b/scripts/polynomial/residue.m
@@ -214,17 +214,21 @@ function [r, p, k, e] = residue (b, a, v
     lb = length (b);
   else
     k = [];
   endif
 
   ## Determine if the poles are (effectively) zero.
 
   small = max (abs (p));
-  small = max ([small, 1]) * eps*1e4 * (1 + numel (p))^2;
+  if (isa (a, "single") || isa (b, "single"))
+    small = max ([small, 1]) * eps ("single") * 1e4 * (1 + numel (p))^2;
+  else
+    small = max ([small, 1]) * eps * 1e4 * (1 + numel (p))^2;
+  endif
   p(abs (p) < small) = 0;
 
   ## Determine if the poles are (effectively) real, or imaginary.
 
   index = (abs (imag (p)) < small);
   p(index) = real (p(index));
   index = (abs (real (p)) < small);
   p(index) = 1i * imag (p(index));
@@ -329,18 +333,21 @@ function [pnum, pden, e] = rresidue (r, 
 
   ## Add the direct term.
 
   if (numel (k))
     pnum = pnum + conv (pden, k);
   endif
 
   ## Check for leading zeros and trim the polynomial coefficients.
-
-  small = max ([max(abs(pden)), max(abs(pnum)), 1]) * eps;
+  if (isa (r, "single") || isa (p, "single") || isa (k, "single"))
+    small = max ([max(abs(pden)), max(abs(pnum)), 1]) * eps ("single");
+  else
+    small = max ([max(abs(pden)), max(abs(pnum)), 1]) * eps;
+  endif
 
   pnum(abs (pnum) < small) = 0;
   pden(abs (pden) < small) = 0;
 
   pnum = polyreduce (pnum);
   pden = polyreduce (pden);
 
 endfunction
diff --git a/scripts/sparse/normest.m b/scripts/sparse/normest.m
--- a/scripts/sparse/normest.m
+++ b/scripts/sparse/normest.m
@@ -27,18 +27,24 @@
 ## @var{tol} is 1e-6. @var{c} returns the number of iterations needed for
 ## @code{normest} to converge.
 ## @end deftypefn
 
 function [e1, c] = normest (A, tol)
   if (nargin < 2)
     tol = 1e-6;
   endif
-  if (tol < eps)
-    tol = eps
+  if (isa (A, "single"))
+    if (tol < eps ("single"))
+      tol = eps ("single");
+    endif
+  else
+    if (tol < eps)
+      tol = eps
+    endif
   endif
   if (ndims(A) != 2)
     error ("normest: A must be a matrix");
   endif 
   maxA = max (max (abs (A)));
   c = 0;
   if (maxA == 0)
     e1 = 0
diff --git a/scripts/specfun/erfinv.m b/scripts/specfun/erfinv.m
--- a/scripts/specfun/erfinv.m
+++ b/scripts/specfun/erfinv.m
@@ -30,17 +30,21 @@
 
 function [y, iterations] = erfinv (x)
 
   if (nargin != 1)
     print_usage ();
   endif
 
   maxit = 100;
-  tol = eps;
+  if (isa (x, "single"))
+    tol = eps ("single");
+  else
+    tol = eps;
+  endif
 
   iterations = 0;
 
   sz = size (x);
   nel = numel (x);
 
   x = reshape (x, nel, 1);
   y = zeros (nel, 1);
diff --git a/scripts/statistics/distributions/betainv.m b/scripts/statistics/distributions/betainv.m
--- a/scripts/statistics/distributions/betainv.m
+++ b/scripts/statistics/distributions/betainv.m
@@ -57,39 +57,46 @@ function inv = betainv (x, a, b)
     if (!isscalar(a) || !isscalar(b))
       a = a (k);
       b = b (k);
       y = a ./ (a + b);
     else
       y = a / (a + b) * ones (size (k));
     endif
     x = x (k);
-    l = find (y < eps);
-    if (any (l))
-      y(l) = sqrt (eps) * ones (length (l), 1);
+
+    if (isa (y, "single"))
+      myeps = eps ("single");
+    else
+      myeps = eps;
     endif
-    l = find (y > 1 - eps);
+
+    l = find (y < myeps);
     if (any (l))
-      y(l) = 1 - sqrt (eps) * ones (length (l), 1);
+      y(l) = sqrt (myeps) * ones (length (l), 1);
+    endif
+    l = find (y > 1 - myeps);
+    if (any (l))
+      y(l) = 1 - sqrt (myeps) * ones (length (l), 1);
     endif
 
     y_old = y;
     for i = 1 : 10000
       h     = (betacdf (y_old, a, b) - x) ./ betapdf (y_old, a, b);
       y_new = y_old - h;
-      ind   = find (y_new <= eps);
+      ind   = find (y_new <= myeps);
       if (any (ind))
         y_new (ind) = y_old (ind) / 10;
       endif
-      ind = find (y_new >= 1 - eps);
+      ind = find (y_new >= 1 - myeps);
       if (any (ind))
         y_new (ind) = 1 - (1 - y_old (ind)) / 10;
       endif
       h = y_old - y_new;
-      if (max (abs (h)) < sqrt (eps))
+      if (max (abs (h)) < sqrt (myeps))
         break;
       endif
       y_old = y_new;
     endfor
 
     inv (k) = y_new;
   endif
 
diff --git a/scripts/statistics/distributions/gaminv.m b/scripts/statistics/distributions/gaminv.m
--- a/scripts/statistics/distributions/gaminv.m
+++ b/scripts/statistics/distributions/gaminv.m
@@ -58,31 +58,38 @@ function inv = gaminv (x, a, b)
     if (!isscalar(a) || !isscalar(b))
       a = a (k);
       b = b (k);
       y = a .* b;
     else
       y = a * b * ones (size (k));
     endif
     x = x (k);
-    l = find (x < eps);
+
+    if (isa (x, "single"))
+      myeps = eps ("single");
+    else
+      myeps = eps;
+    endif
+
+    l = find (x < myeps);
     if (any (l))
-      y(l) = sqrt (eps) * ones (length (l), 1);
+      y(l) = sqrt (myeps) * ones (length (l), 1);
     endif
 
     y_old = y;
     for i = 1 : 100
       h     = (gamcdf (y_old, a, b) - x) ./ gampdf (y_old, a, b);
       y_new = y_old - h;
-      ind   = find (y_new <= eps);
+      ind   = find (y_new <= myeps);
       if (any (ind))
         y_new (ind) = y_old (ind) / 10;
         h = y_old - y_new;
       endif
-      if (max (abs (h)) < sqrt (eps))
+      if (max (abs (h)) < sqrt (myeps))
         break;
       endif
       y_old = y_new;
     endfor
 
     inv (k) = y_new;
   endif
 
diff --git a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
--- a/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
+++ b/scripts/statistics/distributions/kolmogorov_smirnov_cdf.m
@@ -45,17 +45,21 @@
 
 function cdf = kolmogorov_smirnov_cdf (x, tol)
 
   if (nargin < 1 || nargin > 2)
     print_usage ();
   endif
 
   if (nargin == 1)
-    tol = eps;
+    if (isa (x, "single"))
+      tol = eps ("single");
+    else
+      tol = eps;
+    endif
   else
     if (! isscalar (tol) || ! (tol > 0))
       error ("kolmogorov_smirnov_cdf: tol has to be a positive scalar");
     endif
   endif
 
   n = numel (x);
   if (n == 0)
diff --git a/scripts/statistics/tests/manova.m b/scripts/statistics/tests/manova.m
--- a/scripts/statistics/tests/manova.m
+++ b/scripts/statistics/tests/manova.m
@@ -78,17 +78,22 @@ function manova (Y, g)
     SSB = SSB + s' * s / rows (v);
   endfor
   n_b = k - 1;
 
   SSW = SST - SSB;
   n_w = n - k;
 
   l = real (eig (SSB / SSW));
-  l (l < eps) = 0;
+
+  if (isa (l, "single"))
+    l (l < eps ("single")) = 0;
+  else
+    l (l < eps) = 0;
+  endif
 
   ## Wilks' Lambda
   ## =============
 
   Lambda = prod (1 ./ (1 + l));
 
   delta = n_w + n_b - (p + n_b + 1) / 2
   df_num = p * n_b
diff --git a/src/ChangeLog b/src/ChangeLog
--- a/src/ChangeLog
+++ b/src/ChangeLog
@@ -1,8 +1,20 @@
+2008-05-21  David Bateman  <dbateman@free.fr>
+
+	* DLD-FUNCTIONS/sqrt.m: Replace DBL_* with FLT_* for single
+	precision types.
+	* data.cc (static octave_value fill_matrix (const
+	octave_value_list&, double, float, const char *)): Add function
+	with additional argument to allow for different valid for double
+	and single precision.
+	(Finf, FNaN, FNA, Frealmax, Frealmin): Use it here.
+	(Feps): Modify behavior for a single numerical argument to give
+	difference to next largest value in the class of the type passed.
+
 2008-05-21  John W. Eaton  <jwe@octave.org>
 
 	* pt-idx.h (tree_index_expression::tree_index_expression (int, int)): 
 	Delete default argument values.
 
 2008-05-20  David Bateman  <dbateman@free.fr>
 
 	* data.cc (Flog2): Handle single precision.
diff --git a/src/DLD-FUNCTIONS/sqrtm.cc b/src/DLD-FUNCTIONS/sqrtm.cc
--- a/src/DLD-FUNCTIONS/sqrtm.cc
+++ b/src/DLD-FUNCTIONS/sqrtm.cc
@@ -265,17 +265,17 @@ Manchester, England, January 1999.\n\
 	      float imagX = 0.0;
 	      for (octave_idx_type i = 0; i < n; i++)
 		for (octave_idx_type j = 0; j < n; j++)
 		  {
 		    imagX = getmax (imagX, imag (X(i,j)));
 		    normX = getmax (normX, abs (X(i,j)));
 		  }
 
-	      if (imagX < normX * 100 * DBL_EPSILON)
+	      if (imagX < normX * 100 * FLT_EPSILON)
 		retval(0) = real (X);
 	      else
 		retval(0) = X;
 
 	      // Compute error
 	      // FIXME can we estimate the error without doing the
 	      // matrix multiply?
 
@@ -316,21 +316,21 @@ Manchester, England, January 1999.\n\
 	      for (octave_idx_type i = 0; i < n; i++)
 		minT = getmin (minT, abs (T(i,i)));
 	    }
 
 	  retval(1) = err;
 
 	  if (nargout < 2)
 	    {
-	      if (err > 100*(minT+DBL_EPSILON)*n)
+	      if (err > 100*(minT+FLT_EPSILON)*n)
 		{
 		  if (minT == 0.0)
 		    error ("sqrtm: A is singular, sqrt may not exist");
-		  else if (minT <= sqrt (DBL_MIN))
+		  else if (minT <= sqrt (FLT_MIN))
 		    error ("sqrtm: A is nearly singular, failed to find sqrt");
 		  else
 		    error ("sqrtm: failed to find sqrt");
 		}
 	    }
 	}
     }
   else
diff --git a/src/data.cc b/src/data.cc
--- a/src/data.cc
+++ b/src/data.cc
@@ -2657,16 +2657,97 @@ fill_matrix (const octave_value_list& ar
 	    }
 	}
     }
 
   return retval;
 }
 
 static octave_value
+fill_matrix (const octave_value_list& args, double val, float fval, 
+	     const char *fcn)
+{
+  octave_value retval;
+
+  int nargin = args.length ();
+
+  oct_data_conv::data_type dt = oct_data_conv::dt_double;
+
+  dim_vector dims (1, 1);
+  
+  if (nargin > 0 && args(nargin-1).is_string ())
+    {
+      std::string nm = args(nargin-1).string_value ();
+      nargin--;
+
+      dt = oct_data_conv::string_to_data_type (nm);
+
+      if (error_state)
+	return retval;
+    }
+
+  switch (nargin)
+    {
+    case 0:
+      break;
+
+    case 1:
+      get_dimensions (args(0), fcn, dims);
+      break;
+
+    default:
+      {
+	dims.resize (nargin);
+
+	for (int i = 0; i < nargin; i++)
+	  {
+	    dims(i) = args(i).is_empty () ? 0 : args(i).idx_type_value ();
+
+	    if (error_state)
+	      {
+		error ("%s: expecting scalar integer arguments", fcn);
+		break;
+	      }
+	  }
+      }
+      break;
+    }
+
+  if (! error_state)
+    {
+      dims.chop_trailing_singletons ();
+
+      check_dimensions (dims, fcn);
+
+      // Note that automatic narrowing will handle conversion from
+      // NDArray to scalar.
+
+      if (! error_state)
+	{
+	  switch (dt)
+	    {
+	    case oct_data_conv::dt_single:
+	      retval = FloatNDArray (dims, fval);
+	      break;
+
+	    case oct_data_conv::dt_double:
+	      retval = NDArray (dims, val);
+	      break;
+
+	    default:
+	      error ("%s: invalid class name", fcn);
+	      break;
+	    }
+	}
+    }
+
+  return retval;
+}
+
+static octave_value
 fill_matrix (const octave_value_list& args, double val, const char *fcn)
 {
   octave_value retval;
 
   int nargin = args.length ();
 
   oct_data_conv::data_type dt = oct_data_conv::dt_double;
 
@@ -2719,17 +2800,17 @@ fill_matrix (const octave_value_list& ar
       // Note that automatic narrowing will handle conversion from
       // NDArray to scalar.
 
       if (! error_state)
 	{
 	  switch (dt)
 	    {
 	    case oct_data_conv::dt_single:
-	      retval = FloatNDArray (dims, val);
+	      retval = FloatNDArray (dims, static_cast <float> (val));
 	      break;
 
 	    case oct_data_conv::dt_double:
 	      retval = NDArray (dims, val);
 	      break;
 
 	    default:
 	      error ("%s: invalid class name", fcn);
@@ -2800,17 +2881,17 @@ fill_matrix (const octave_value_list& ar
       // Note that automatic narrowing will handle conversion from
       // NDArray to scalar.
 
       if (! error_state)
 	{
 	  switch (dt)
 	    {
 	    case oct_data_conv::dt_single:
-	      retval = FloatComplexNDArray (dims, static_cast <FloatComplex> (val));
+	      retval = FloatComplexNDArray (dims, static_cast<FloatComplex> (val));
 	      break;
 
 	    case oct_data_conv::dt_double:
 	      retval = ComplexNDArray (dims, val);
 	      break;
 
 	    default:
 	      error ("%s: invalid class name", fcn);
@@ -2928,17 +3009,18 @@ DEFUN (Inf, args, ,
 @deftypefnx {Built-in Function} {} Inf (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} Inf (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all Infinity.\n\
 The arguments are handled the same as the arguments for @code{eye}.\n\
 The optional argument @var{class} may be either @samp{\"single\"} or\n\
 @samp{\"double\"}.  The default is @samp{\"double\"}.\n\
 @end deftypefn")
 {
-  return fill_matrix (args, lo_ieee_inf_value (), "Inf");
+  return fill_matrix (args, lo_ieee_inf_value (), 
+		      lo_ieee_float_inf_value (), "Inf");
 }
 
 DEFALIAS (inf, Inf);
 
 DEFUN (NaN, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} NaN (@var{x})\n\
 @deftypefnx {Built-in Function} {} NaN (@var{n}, @var{m})\n\
@@ -2960,17 +3042,18 @@ Note that NaN always compares not equal 
 specified by the IEEE standard for floating point arithmetic.  To\n\
 find NaN values, you must use the @code{isnan} function.\n\
 \n\
 The arguments are handled the same as the arguments for @code{eye}.\n\
 The optional argument @var{class} may be either @samp{\"single\"} or\n\
 @samp{\"double\"}.  The default is @samp{\"double\"}.\n\
 @end deftypefn")
 {
-  return fill_matrix (args, lo_ieee_nan_value (), "NaN");
+  return fill_matrix (args, lo_ieee_nan_value (), 
+		      lo_ieee_float_nan_value (), "NaN");
 }
 
 DEFALIAS (nan, NaN);
 
 DEFUN (e, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} e (@var{x})\n\
 @deftypefnx {Built-in Function} {} e (@var{n}, @var{m})\n\
@@ -3021,21 +3104,115 @@ is approximately\n\
 @ifinfo\n\
  2.2204e-16.\n\
 @end ifinfo\n\
 @iftex\n\
 @tex\n\
  $2.2204\\times10^{-16}$.\n\
 @end tex\n\
 @end iftex\n\
+for double precision and\n\
+@ifinfo\n\
+ 1.1921e-07.\n\
+@end ifinfo\n\
+@iftex\n\
+@tex\n\
+ $1.1921\\times10^{-7}$.\n\
+@end tex\n\
+@end iftex\n\
+for single precision. Given a single argument @var{x}, return the\n\
+distance between @var{x} and the next largest value.\n\
 @end deftypefn")
 {
-  return fill_matrix (args, DBL_EPSILON, "eps");
+  int nargin = args.length ();
+  octave_value retval;
+
+  if (nargin == 1 && ! args(0).is_string ())
+    {
+      if (args(0).is_single_type ())
+	{
+	  float val = args(0).float_value ();
+
+	  if (! error_state)
+	    {
+	      val  = ::fabsf(val);
+	      if (xisnan (val) || xisinf (val))
+		retval = fill_matrix (octave_value ("single"), 
+				      lo_ieee_nan_value (), 
+				      lo_ieee_float_nan_value (), "eps");
+	      else if (val < FLT_MIN)
+		retval = fill_matrix (octave_value ("single"), 0e0, 
+				      powf (2.0, -149e0), "eps");
+	      else
+		{
+		  int expon;
+		  frexpf (val, &expon);
+		  val = std::pow (static_cast <float> (2.0), 
+				  static_cast <float> (expon - 24));
+		  retval = fill_matrix (octave_value ("single"), DBL_EPSILON, 
+					val, "eps");
+		}
+	    }
+	}
+      else
+	{
+	  double val = args(0).double_value ();
+
+	  if (! error_state)
+	    {
+	      val  = ::fabs(val);
+	      if (xisnan (val) || xisinf (val))
+		retval = fill_matrix (octave_value_list (), 
+				      lo_ieee_nan_value (), 
+				      lo_ieee_float_nan_value (), "eps");
+	      else if (val < DBL_MIN)
+		retval = fill_matrix (octave_value_list (),
+				      pow (2.0, -1074e0), 0e0, "eps");
+	      else
+		{
+		  int expon;
+		  frexp (val, &expon);
+		  val = std::pow (static_cast <double> (2.0), 
+				  static_cast <double> (expon - 53));
+		  retval = fill_matrix (octave_value_list (), val, 
+					FLT_EPSILON, "eps");
+		}
+	    }
+	}
+    }
+  else
+    retval = fill_matrix (args, DBL_EPSILON, FLT_EPSILON, "eps");
+
+  return retval;
 }
 
+/*
+
+%!assert(eps(1/2),2^(-53))
+%!assert(eps(1),2^(-52))
+%!assert(eps(2),2^(-51))
+%!assert(eps(realmax),2^971)
+%!assert(eps(0),2^(-1074))
+%!assert(eps(realmin/2),2^(-1074))
+%!assert(eps(realmin/16),2^(-1074))
+%!assert(eps(Inf),NaN)
+%!assert(eps(NaN),NaN)
+%!assert(eps(single(1/2)),single(2^(-24)))
+%!assert(eps(single(1)),single(2^(-23)))
+%!assert(eps(single(2)),single(2^(-22)))
+%!assert(eps(realmax('single')),single(2^104))
+%!assert(eps(single(0)),single(2^(-149)))
+%!assert(eps(realmin('single')/2),single(2^(-149)))
+%!assert(eps(realmin('single')/16),single(2^(-149)))
+%!assert(eps(single(Inf)),single(NaN))
+%!assert(eps(single(NaN)),single(NaN))
+
+*/
+
+
 DEFUN (pi, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} pi (@var{x})\n\
 @deftypefnx {Built-in Function} {} pi (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} pi (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} pi (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all equal\n\
 to the ratio of the circumference of a circle to its diameter.\n\
@@ -3067,17 +3244,17 @@ floating point arithmetic, @code{realmax
 @iftex\n\
 @tex\n\
  $1.7977\\times10^{308}$.\n\
 @end tex\n\
 @end iftex\n\
 @seealso{realmin}\n\
 @end deftypefn")
 {
-  return fill_matrix (args, DBL_MAX, "realmax");
+  return fill_matrix (args, DBL_MAX, FLT_MAX, "realmax");
 }
 
 DEFUN (realmin, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} realmin (@var{x})\n\
 @deftypefnx {Built-in Function} {} realmin (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} realmin (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} realmin (@dots{}, @var{class})\n\
@@ -3091,17 +3268,17 @@ 64-bit IEEE floating point arithmetic, @
 @iftex\n\
 @tex\n\
  $2.2251\\times10^{-308}$.\n\
 @end tex\n\
 @end iftex\n\
 @seealso{realmax}\n\
 @end deftypefn")
 {
-  return fill_matrix (args, DBL_MIN, "realmin");
+  return fill_matrix (args, DBL_MIN, FLT_MIN, "realmin");
 }
 
 DEFUN (I, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} I (@var{x})\n\
 @deftypefnx {Built-in Function} {} I (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} I (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} I (@dots{}, @var{class})\n\
@@ -3131,17 +3308,18 @@ DEFUN (NA, args, ,
 @deftypefn {Built-in Function} {} NA (@var{x})\n\
 @deftypefnx {Built-in Function} {} NA (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} NA (@var{n}, @var{m}, @var{k}, @dots{})\n\
 @deftypefnx {Built-in Function} {} NA (@dots{}, @var{class})\n\
 Return a matrix or N-dimensional array whose elements are all equal\n\
 to the special constant used to designate missing values.\n\
 @end deftypefn")
 {
-  return fill_matrix (args, lo_ieee_na_value (), "NA");
+  return fill_matrix (args, lo_ieee_na_value (), 
+		      lo_ieee_float_na_value (), "NA");
 }
 
 DEFUN (false, args, ,
   "-*- texinfo -*-\n\
 @deftypefn {Built-in Function} {} false (@var{x})\n\
 @deftypefnx {Built-in Function} {} false (@var{n}, @var{m})\n\
 @deftypefnx {Built-in Function} {} false (@var{n}, @var{m}, @var{k}, @dots{})\n\
 Return a matrix or N-dimensional array whose elements are all logical 0.\n\
