# HG changeset patch
# User John W. Eaton <jwe@octave.org>
# Date 1403215680 14400
#      Thu Jun 19 18:08:00 2014 -0400
# Node ID 479d1d3cb5c33fb8713b35e497d141bb97a5f134
# Parent  aa9ca67f09fb95d401ef17b62c317a93d9cdc465
# Parent  b314efd58072a1eaef205f625ab336f4708b9634
maint: Periodic merge of gui-release to default.

diff --git a/bootstrap.conf b/bootstrap.conf
--- a/bootstrap.conf
+++ b/bootstrap.conf
@@ -45,16 +45,20 @@ gnulib_modules="
   getcwd
   gethostname
   getopt-gnu
   gettimeofday
   glob
   isatty
   largefile
   link
+  log2
+  log2-ieee
+  log2f
+  log2f-ieee
   lstat
   malloc-gnu
   mbrtowc
   mkdir
   mkfifo
   mkostemp
   mktime
   nanosleep
diff --git a/doc/interpreter/expr.txi b/doc/interpreter/expr.txi
--- a/doc/interpreter/expr.txi
+++ b/doc/interpreter/expr.txi
@@ -1232,18 +1232,29 @@ of the form
 @noindent
 is evaluated as
 
 @example
 @var{expr1} = (@var{expr1}) @var{op} (@var{expr2})
 @end example
 
 @noindent
-where @var{op} can be either @code{+}, @code{-}, @code{*}, or @code{/}.
-So, the expression
+where @var{op} can be either @code{+}, @code{-}, @code{*}, or @code{/},
+as long as @var{expr2} is a simple expression with no side effects.  If
+@var{expr2} also contains an assignment operator, then this expression
+is evaluated as
+
+@example
+@var{temp} = @var{expr2}
+@var{expr1} = (@var{expr1}) @var{op} @var{temp}
+@end example
+
+@noindent
+where @var{temp} is a placeholder temporary value storing the computed
+result of evaluating @var{expr2}.  So, the expression
 
 @example
 a *= b+1
 @end example
 
 @noindent
 is evaluated as
 
diff --git a/doc/interpreter/plot.txi b/doc/interpreter/plot.txi
--- a/doc/interpreter/plot.txi
+++ b/doc/interpreter/plot.txi
@@ -588,40 +588,40 @@ figure window, call the @code{close} fun
 
 @DOCSTRING(close)
 
 @DOCSTRING(closereq)
 
 @node Use of the @code{interpreter} Property
 @subsection Use of the @code{interpreter} Property
 
-All text objects, including titles, labels, legends, and text, include
-the property @qcode{"interpreter"}, this property determines the manner in which
-special control sequences in the text are rendered.  If the interpreter
-is set to @qcode{"none"}, then no rendering occurs.  At this point the
-@qcode{"latex"} option is not implemented and so the @qcode{"latex"}
-interpreter also does not interpret the text.
-
-The @qcode{"tex"} option implements a subset of @TeX{} functionality in the
-rendering of the text.  This allows the insertion of special characters
-such as Greek or mathematical symbols within the text.  The special
-characters are also inserted with a code starting with the backslash
-(\) character, as in the table @ref{tab:extended}.
+All text objects---such as titles, labels, legends, and text---include
+the property @qcode{"interpreter"}, this property determines the manner in
+which special control sequences in the text are rendered.  If the interpreter
+is set to @qcode{"none"}, then no rendering occurs.  Currently the
+@qcode{"latex"} interpreter is not implemented and is equivalent to
+@qcode{"none"}.
+
+The @qcode{"tex"} option implements a subset of @TeX{} functionality when
+rendering text.  This allows the insertion of special glyphs such as Greek
+characters or mathematical symbols.  The special characters are inserted with
+a code following a backslash (\) character, as in the table
+@ref{tab:extended}.
 
 In addition, the formatting of the text can be changed within the string
-with the codes
+by using the codes
 
 @multitable @columnfractions .2 .2 .6 .2
 @item @tab \bf @tab Bold font @tab
 @item @tab \it @tab Italic font @tab
 @item @tab \sl @tab Oblique Font @tab
 @item @tab \rm @tab Normal font @tab
 @end multitable
 
-These are be used in conjunction with the @{ and @} characters to limit
+These may be used in conjunction with the @{ and @} characters to limit
 the change in the font to part of the string.  For example,
 
 @example
 xlabel ('@{\bf H@} = a @{\bf V@}')
 @end example
 
 @noindent
 where the character @qcode{'a'} will not appear in a bold font.  Note that to
@@ -631,17 +631,17 @@ the strings should be in single quotes.
 It is also possible to change the fontname and size within the text
 
 @multitable @columnfractions .1 .4 .6 .1
 @item @tab \fontname@{@var{fontname}@} @tab Specify the font to use @tab
 @item @tab \fontsize@{@var{size}@} @tab Specify the size of the font to
 use @tab
 @end multitable
 
-Finally, the superscript and subscripting can be controlled with the @qcode{'^'}
+Finally, superscripting and subscripting can be controlled with the @qcode{'^'}
 and @qcode{'_'} characters.  If the @qcode{'^'} or @qcode{'_'} is followed by a
 @{ character, then all of the block surrounded by the @{ @} pair is super- or
 sub-scripted.  Without the @{ @} pair, only the character immediately following
 the @qcode{'^'} or @qcode{'_'} is super- or sub-scripted.
 
 @float Table,tab:extended
 @tex
 \vskip 6pt
diff --git a/libgui/qterminal-module.mk b/libgui/qterminal-module.mk
--- a/libgui/qterminal-module.mk
+++ b/libgui/qterminal-module.mk
@@ -5,16 +5,17 @@ noinst_HEADERS += \
   qterminal/libqterminal/QTerminal.h \
   qterminal/libqterminal/win32/QTerminalColors.h \
   qterminal/libqterminal/win32/QWinTerminalImpl.h \
   qterminal/libqterminal/unix/BlockArray.h \
   qterminal/libqterminal/unix/Character.h \
   qterminal/libqterminal/unix/CharacterColor.h \
   qterminal/libqterminal/unix/Emulation.h \
   qterminal/libqterminal/unix/ExtendedDefaultTranslator.h \
+  qterminal/libqterminal/unix/ExtendedDefaultTranslatorMac.h \
   qterminal/libqterminal/unix/Filter.h \
   qterminal/libqterminal/unix/History.h \
   qterminal/libqterminal/unix/KeyboardTranslator.h \
   qterminal/libqterminal/unix/konsole_wcwidth.h \
   qterminal/libqterminal/unix/kpty.h \
   qterminal/libqterminal/unix/kpty_p.h \
   qterminal/libqterminal/unix/LineFont.h \
   qterminal/libqterminal/unix/QUnixTerminalImpl.h \
diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -823,17 +823,17 @@ files_dock_widget::popdownmenu_home (boo
 }
 
 void
 files_dock_widget::popdownmenu_search_dir (bool)
 {
   QString dir = QFileDialog::getExistingDirectory
                   (this, tr ("Set directory of file browser"),
                    _file_system_model->rootPath (),
-                   QFileDialog::DontUseNativeDialog);
+                   QFileDialog::ShowDirsOnly | QFileDialog::DontUseNativeDialog);
   set_current_directory (dir);
 }
 
 void
 files_dock_widget::popdownmenu_findfiles (bool)
 {
   process_find_files (_file_system_model->rootPath ());
 }
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -43,35 +43,38 @@ along with Octave; see the file COPYING.
 #include "resource-manager.h"
 #include <QApplication>
 #include <QFileDialog>
 #include <QMessageBox>
 #include <QTextStream>
 #include <QVBoxLayout>
 #include <QInputDialog>
 #include <QPrintDialog>
+#include <QDateTime>
 
 #include "file-editor-tab.h"
 #include "file-editor.h"
 
 #include "file-ops.h"
 
 #include "debug.h"
 #include "octave-qt-link.h"
 #include "version.h"
 #include "utils.h"
+#include "defaults.h"
 
 // Make parent null for the file editor tab so that warning
 // WindowModal messages don't affect grandparents.
 file_editor_tab::file_editor_tab (const QString& directory_arg)
 {
   QString directory = directory_arg;
   _lexer_apis = 0;
   _app_closing = false;
   _is_octave_file = true;
+  _modal_dialog = false;
 
   // Make sure there is a slash at the end of the directory name
   // for identification when saved later.
   if (directory.count () && directory.at (directory.count () - 1) != '/')
     directory.append ("/");
 
   _file_name = directory;
   _file_system_watcher.setObjectName ("_qt_autotest_force_engine_poller");
@@ -325,69 +328,158 @@ file_editor_tab::update_lexer ()
         }
       else
         {
           // other or no extension
           lexer = new QsciLexerBash ();
         }
     }
 
+  QSettings *settings = resource_manager::get_settings ();
+
+  // build information for auto completion (APIs)
   _lexer_apis = new QsciAPIs(lexer);
+
   if (_lexer_apis)
     {
+      bool update_apis_file = false;  // flag, whether update of apis files
+
       // get path to prepared api info
       QDesktopServices desktopServices;
       QString prep_apis_path
         = desktopServices.storageLocation (QDesktopServices::HomeLocation)
           + "/.config/octave/"  + QString(OCTAVE_VERSION) + "/qsci/";
-      _prep_apis_file = prep_apis_path + lexer->lexer () + ".pap";
+
+      // get settings which infos are used for octave
+      bool octave_builtins = settings->value (
+                  "editor/codeCompletion_octave_builtins", true).toBool ();
+      bool octave_functions = settings->value (
+                  "editor/codeCompletion_octave_functions", true).toBool ();
+
+      if (_is_octave_file)
+        {
+          // octave file: keywords are always used
+          _prep_apis_file = prep_apis_path + lexer->lexer () + "_k";
+
+          if (octave_builtins)
+            _prep_apis_file = _prep_apis_file + "b";  // use builtins, too
+
+          if (octave_functions)
+            _prep_apis_file = _prep_apis_file + "f";  // use keywords, too
+
+          _prep_apis_file = _prep_apis_file + ".pap"; // final name of apis file
+
+          // check whether the APIs info needs to be prepared and saved
+          QFileInfo apis_file = QFileInfo (_prep_apis_file);
+          update_apis_file = ! apis_file.exists ();  // flag whether apis file needs update
 
-      if (!_lexer_apis->loadPrepared (_prep_apis_file))
+          // function list depends on installed packages: check mod. date
+          if (! update_apis_file & octave_functions)
+            {
+              // check whether package file is newer than apis_file
+              QDateTime apis_date = apis_file.lastModified ();
+
+              // compare to local package list
+              // FIXME: How to get user chosen location?
+              QFileInfo local_pkg_list = QFileInfo (
+                desktopServices.storageLocation (QDesktopServices::HomeLocation)
+                + "/.octave_packages");
+              if (local_pkg_list.exists ()
+                  & (apis_date < local_pkg_list.lastModified ()) )
+                update_apis_file = true;
+
+              // compare to global package list
+              // FIXME: How to get user chosen location?
+              QFileInfo global_pkg_list = QFileInfo (
+                                        QString::fromStdString (Voctave_home)
+                                        + "/share/octave/octave_packages");
+               if (global_pkg_list.exists ()
+                   & (apis_date < global_pkg_list.lastModified ()) )
+                update_apis_file = true;
+            }
+          }
+        else  // no octave file, just add extension
+          {
+            _prep_apis_file = prep_apis_path + lexer->lexer () + ".pap";
+          }
+
+      if (update_apis_file | !_lexer_apis->loadPrepared (_prep_apis_file))
         {
           // no prepared info loaded, prepare and save if possible
 
           // create raw apis info
           QString keyword;
           QStringList keyword_list;
           int i,j;
-          for (i=1; i<=3; i++) // test the first 5 keyword sets
+
+          if (_is_octave_file)
             {
-              keyword = QString(lexer->keywords (i));           // get list
-              keyword_list = keyword.split (QRegExp ("\\s+"));  // split
-              for (j = 0; j < keyword_list.size (); j++)        // add to API
-                _lexer_apis->add (keyword_list.at (j));
+              // octave: get keywords from internal informations depending on
+              //         user preferences
+
+              // keywords are always used
+              add_octave_apis (F__keywords__ ());       // add new entries
+
+              if (octave_builtins)
+                add_octave_apis (F__builtins__ ());       // add new entries
+
+              if (octave_functions)
+                add_octave_apis (F__list_functions__ ()); // add new entries
+
+            }
+          else
+            {
+
+              _prep_apis_file = prep_apis_path + lexer->lexer () + ".pap";
+
+              for (i=1; i<=3; i++) // test the first 5 keyword sets
+                {
+                  keyword = QString(lexer->keywords (i));           // get list
+                  keyword_list = keyword.split (QRegExp ("\\s+"));  // split
+                  for (j = 0; j < keyword_list.size (); j++)        // add to API
+                    _lexer_apis->add (keyword_list.at (j));
+                }
             }
 
           // dsiconnect slot for saving prepared info if already connected
           disconnect (_lexer_apis, SIGNAL (apiPreparationFinished ()), 0, 0);
           // check whether path for prepared info exists or can be created
           if (QDir("/").mkpath (prep_apis_path))
             {
               // path exists, apis info can be saved there
               connect (_lexer_apis, SIGNAL (apiPreparationFinished ()),
                        this, SLOT (save_apis_info ()));
             }
           _lexer_apis->prepare ();  // prepare apis info
         }
     }
 
-  QSettings *settings = resource_manager::get_settings ();
-  if (settings)
-    lexer->readSettings (*settings);
+  lexer->readSettings (*settings);
 
   _edit_area->setLexer (lexer);
 
   // fix line number width with respect to the font size of the lexer
   if (settings->value ("editor/showLineNumbers", true).toBool ())
     auto_margin_width ();
   else
     _edit_area->setMarginWidth (2,0);
 
 }
 
+// function for adding entries to the octave lexer's APIs
+void
+file_editor_tab::add_octave_apis (octave_value_list key_ovl)
+{
+  octave_value keys = key_ovl(0);
+  Cell key_list = keys.cell_value ();
+
+  for (int idx = 0; idx < key_list.numel (); idx++)
+    _lexer_apis->add (QString (key_list.elem (idx).string_value ().data ()));
+}
+
 void
 file_editor_tab::save_apis_info ()
 {
   _lexer_apis->savePrepared (_prep_apis_file);
 }
 
 QString
 file_editor_tab::comment_string (const QString& lexer)
@@ -476,18 +568,22 @@ file_editor_tab::print_file (const QWidg
 }
 
 void
 file_editor_tab::run_file (const QWidget *ID)
 {
   if (ID != this)
     return;
 
-  if (_edit_area->isModified ())
-    save_file (_file_name);
+  if (_edit_area->isModified () | ! valid_file_name ())
+    {
+      _modal_dialog = true;    // force modal dialog if the file is a new one
+      save_file (_file_name);  // save file dialog
+      _modal_dialog = false;   // back to non-modal dialogs
+    }
 
   QFileInfo info (_file_name);
   emit run_file_signal (info);
 }
 
 void
 file_editor_tab::context_run (const QWidget *ID)
 {
@@ -981,22 +1077,22 @@ void
 file_editor_tab::handle_copy_available (bool enableCopy)
 {
   _copy_available = enableCopy;
   emit editor_state_changed (_copy_available, QDir::cleanPath (_file_name),
                              _is_octave_file);
 }
 
 // show_dialog: shows a modal or non modal dialog depeding on the closing
-//              of the app
+//              of the app and the flag _modal_dialog
 void
 file_editor_tab::show_dialog (QDialog *dlg)
 {
   dlg->setAttribute (Qt::WA_DeleteOnClose);
-  if (_app_closing)
+  if (_app_closing | _modal_dialog)
     dlg->exec ();
   else
     {
       dlg->setWindowModality (Qt::WindowModal);
       dlg->show ();
     }
 }
 
@@ -1228,16 +1324,21 @@ file_editor_tab::save_file_as (bool remo
       if (_file_name.isEmpty ())
         fileDialog->setDirectory (QDir::currentPath ());
       else
         {
           // The file name is actually the directory name from the
           // constructor argument.
           fileDialog->setDirectory (_file_name);
         }
+
+      // propose a name corresponding to the function name
+      QString fname = get_function_name ();
+      if (! fname.isEmpty ())
+        fileDialog->selectFile (fname + ".m");
     }
 
   fileDialog->setNameFilter (tr ("Octave Files (*.m);;All Files (*)"));
   fileDialog->setDefaultSuffix ("m");
   fileDialog->setAcceptMode (QFileDialog::AcceptSave);
   fileDialog->setViewMode (QFileDialog::Detail);
 
   if (remove_on_success)
@@ -1643,9 +1744,31 @@ file_editor_tab::create_context_menu (QM
 }
 
 void
 file_editor_tab::edit_area_has_focus (bool focus)
 {
   emit set_global_edit_shortcuts_signal (! focus);
 }
 
+QString
+file_editor_tab::get_function_name ()
+{
+  QRegExp rxfun1 ("^([\t ]*)function([^=]+)=([^\\(]+)\\(([^\\)]*)\\)");
+  QRegExp rxfun2 ("^([\t ]*)function([^\\(]+)\\(([^\\)]*)\\)");
+  QRegExp rxfun3 ("^([\t ]*)function([\t ]*)([^\t ]+)");
+
+  QStringList lines = _edit_area->text ().split ("\n");
+
+  for (int i = 0; i < lines.count (); i++)
+    {
+      if (rxfun1.indexIn (lines.at (i)) != -1)
+        return rxfun1.cap (3).remove (QRegExp("[ \t]*"));
+      else if (rxfun2.indexIn (lines.at (i)) != -1)
+        return rxfun2.cap (2).remove (QRegExp("[ \t]*"));
+      else if (rxfun3.indexIn (lines.at (i)) != -1)
+        return rxfun3.cap (3).remove (QRegExp("[ \t]*"));
+    }
+
+  return QString ();
+}
+
 #endif
diff --git a/libgui/src/m-editor/file-editor-tab.h b/libgui/src/m-editor/file-editor-tab.h
--- a/libgui/src/m-editor/file-editor-tab.h
+++ b/libgui/src/m-editor/file-editor-tab.h
@@ -29,16 +29,17 @@ along with Octave; see the file COPYING.
 #include <QSettings>
 #include <QFileInfo>
 #include <Qsci/qsciapis.h>
 #include <QStatusBar>
 #include <QLabel>
 
 #include "find-dialog.h"
 #include "octave-qscintilla.h"
+#include "builtin-defun-decls.h"
 
 class file_editor;
 
 class file_editor_tab : public QWidget
 {
   Q_OBJECT
 
 public:
@@ -201,29 +202,33 @@ private:
   QString comment_string (const QString&);
   void do_indent_selected_text (bool indent);
 
   void add_breakpoint_callback (const bp_info& info);
   void remove_breakpoint_callback (const bp_info& info);
   void remove_all_breakpoints_callback (const bp_info& info);
   void center_current_line ();
 
+  void add_octave_apis (octave_value_list key_ovl);
+  QString get_function_name ();
+
   octave_qscintilla *_edit_area;
 
   QStatusBar *_status_bar;
   QLabel *_row_indicator;
   QLabel *_col_indicator;
 
   QString _file_name;
   QString _file_name_short;
 
   bool _long_title;
   bool _copy_available;
   bool _app_closing;
   bool _is_octave_file;
+  bool _modal_dialog;
 
   QFileSystemWatcher _file_system_watcher;
 
   find_dialog *_find_dialog;
   bool _find_dialog_is_visible;
   QRect _find_dialog_geometry;
 
   QsciAPIs *_lexer_apis;
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -364,24 +364,27 @@ main_window::display_release_notes (void
 
       QVBoxLayout *vlayout = new QVBoxLayout;
       vlayout->addWidget (browser);
 
       release_notes_window->setLayout (vlayout);
       release_notes_window->setWindowTitle (tr ("Octave Release Notes"));
 
       browser->document()->adjustSize ();
-      QSize doc_size = browser->document()->size().toSize ();
-      doc_size.rwidth () += 45;
-      int h = QApplication::desktop ()->height ();
-      if (h > 800)
-        h = 800;
-      doc_size.rheight () = h;
-
-      release_notes_window->resize (doc_size);
+
+      // center the window on the screen where octave is running
+      QDesktopWidget *m_desktop = QApplication::desktop ();
+      int screen = m_desktop->screenNumber (this);  // screen of the main window
+      QRect screen_geo = m_desktop->availableGeometry (screen);
+      int win_x = screen_geo.width ();        // width of the screen
+      int win_y = screen_geo.height ();       // height of the screen
+      int reln_x = std::min (480, win_x-80);  // desired width of release notes
+      int reln_y = std::min (640, win_y-80);  // desired height of release notes
+      release_notes_window->resize (reln_x, reln_y);  // set size
+      release_notes_window->move (20, 0);     // move to the top left corner
     }
 
   if (! release_notes_window->isVisible ())
     release_notes_window->show ();
   else if (release_notes_window->isMinimized ())
     release_notes_window->showNormal ();
 
   release_notes_window->setWindowIcon (QIcon (_release_notes_icon));
@@ -551,19 +554,26 @@ main_window::display_community_news (con
       browser->setOpenExternalLinks (true);
 
       QVBoxLayout *vlayout = new QVBoxLayout;
 
       vlayout->addWidget (browser);
 
       community_news_window->setLayout (vlayout);
       community_news_window->setWindowTitle (tr ("Octave Community News"));
-      community_news_window->resize (640, 480);
-      int win_x = QApplication::desktop ()->width ();
-      int win_y = QApplication::desktop ()->height ();
+
+      // center the window on the screen where octave is running
+      QDesktopWidget *m_desktop = QApplication::desktop ();
+      int screen = m_desktop->screenNumber (this);  // screen of the main window
+      QRect screen_geo = m_desktop->availableGeometry (screen);
+      int win_x = screen_geo.width ();        // width of the screen
+      int win_y = screen_geo.height ();       // height of the screen
+      int news_x = std::min (640, win_x-80);  // desired width of news window
+      int news_y = std::min (480, win_y-80);  // desired height of news window
+      community_news_window->resize (news_x, news_y);  // set size and center
       community_news_window->move ((win_x - community_news_window->width ())/2,
                                    (win_y - community_news_window->height ())/2);
     }
 
   if (! community_news_window->isVisible ())
     community_news_window->show ();
   else if (community_news_window->isMinimized ())
     community_news_window->showNormal ();
@@ -1009,21 +1019,16 @@ main_window::write_settings (void)
 
 // Connecting the signals emitted when the visibility of a widget changes.
 // This has to be done after the window is shown (see octave-gui.cc)
 void
 main_window::connect_visibility_changed (void)
 {
   foreach (octave_dock_widget *widget, dock_widget_list ())
     widget->connect_visibility_changed ();
-
-#ifdef HAVE_QSCINTILLA
-  // Main window completely shown, determine whether to create an empty script
-  editor_window->empty_script (true, false);
-#endif
 }
 
 void
 main_window::copyClipboard (void)
 {
   if (_current_directory_combo_box->hasFocus ())
     {
       QLineEdit * edit = _current_directory_combo_box->lineEdit ();
@@ -1318,16 +1323,24 @@ main_window::handle_octave_ready ()
 
   if (! startup_dir.exists ())
     {
       // the configured startup dir does not exist, take actual one
       startup_dir = QDir ();
     }
 
   set_current_working_directory (startup_dir.absolutePath ());
+
+#ifdef HAVE_QSCINTILLA
+  // Octave ready, determine whether to create an empty script.
+  // This can not be done when the editor is created because all functions
+  // must be known for the lexer's auto completion informations
+  editor_window->empty_script (true, false);
+#endif
+
 }
 
 
 void
 main_window::construct_octave_qt_link (void)
 {
   _octave_qt_link = new octave_qt_link (this);
 
@@ -2077,17 +2090,17 @@ main_window::execute_command_callback ()
         repost = true;          // not empty, repost at end
       _cmd_queue_mutex.unlock ();
 
       command_editor::replace_line (command);
 
       command_editor::redisplay ();
       // We are executing inside the command editor event loop.  Force
       // the current line to be returned for processing.
-      command_editor::interrupt ();
+      command_editor::accept_line ();
     }
 
   if (repost)  // queue not empty, so repost event for further processing
     octave_link::post_event (this, &main_window::execute_command_callback);
 
 }
 
 void
diff --git a/libgui/src/settings-dialog.cc b/libgui/src/settings-dialog.cc
--- a/libgui/src/settings-dialog.cc
+++ b/libgui/src/settings-dialog.cc
@@ -53,18 +53,16 @@ along with Octave; see the file COPYING.
 #include <Qsci/qscilexerdiff.h>
 #endif
 
 settings_dialog::settings_dialog (QWidget *p, const QString& desired_tab):
   QDialog (p), ui (new Ui::settings_dialog)
 {
   ui->setupUi (this);
 
-  shortcut_manager::fill_treewidget (ui->shortcuts_treewidget);
-
   QSettings *settings = resource_manager::get_settings ();
 
   // restore last geometry
   restoreGeometry (settings->value("settings/geometry").toByteArray ());
 
   // look for available language files and the actual settings
   QString qm_dir_name = resource_manager::get_gui_translation_dir ();
   QDir qm_dir (qm_dir_name);
@@ -163,16 +161,24 @@ settings_dialog::settings_dialog (QWidge
     settings->value ("editor/code_folding",true).toBool ());
 
   ui->editor_codeCompletion->setChecked (
     settings->value ("editor/codeCompletion", true).toBool ());
   ui->editor_spinbox_ac_threshold->setValue (
     settings->value ("editor/codeCompletion_threshold",2).toInt ());
   ui->editor_checkbox_ac_keywords->setChecked (
     settings->value ("editor/codeCompletion_keywords",true).toBool ());
+  ui->editor_checkbox_ac_builtins->setEnabled (
+    ui->editor_checkbox_ac_keywords->isChecked ());
+  ui->editor_checkbox_ac_functions->setEnabled (
+    ui->editor_checkbox_ac_keywords->isChecked ());
+  ui->editor_checkbox_ac_builtins->setChecked (
+    settings->value ("editor/codeCompletion_octave_builtins",true).toBool ());
+  ui->editor_checkbox_ac_functions->setChecked (
+    settings->value ("editor/codeCompletion_octave_functions",true).toBool ());
   ui->editor_checkbox_ac_document->setChecked (
     settings->value ("editor/codeCompletion_document",false).toBool ());
   ui->editor_checkbox_ac_case->setChecked (
     settings->value ("editor/codeCompletion_case",true).toBool ());
   ui->editor_checkbox_ac_replace->setChecked (
     settings->value ("editor/codeCompletion_replace",false).toBool ());
   ui->editor_ws_checkbox->setChecked (
     settings->value ("editor/show_white_space", false).toBool ());
@@ -275,22 +281,37 @@ settings_dialog::settings_dialog (QWidge
 
   // qorkspace colors
   read_workspace_colors (settings);
 
   // terminal colors
   read_terminal_colors (settings);
 
   // shortcuts
+
   ui->cb_prevent_readline_conflicts->setChecked (
     settings->value ("shortcuts/prevent_readline_conflicts", true).toBool ());
   int set = settings->value ("shortcuts/set",0).toInt ();
   ui->rb_sc_set1->setChecked (set == 0);
   ui->rb_sc_set2->setChecked (set == 1);
 
+  // initialize the tree view with all shortcut data
+  shortcut_manager::fill_treewidget (ui->shortcuts_treewidget);
+
+  // connect the buttons for import/export of the shortcut sets
+  connect (ui->btn_import_shortcut_set1, SIGNAL (clicked ()),
+           this, SLOT (import_shortcut_set1 ()));
+  connect (ui->btn_export_shortcut_set1, SIGNAL (clicked ()),
+           this, SLOT (export_shortcut_set1 ()));
+  connect (ui->btn_import_shortcut_set2, SIGNAL (clicked ()),
+           this, SLOT (import_shortcut_set2 ()));
+  connect (ui->btn_export_shortcut_set2, SIGNAL (clicked ()),
+           this, SLOT (export_shortcut_set2 ()));
+
+
 #ifdef HAVE_QSCINTILLA
   // editor styles: create lexer, read settings, and create dialog elements
   QsciLexer *lexer;
 #if defined (HAVE_LEXER_OCTAVE)
   lexer = new QsciLexerOctave ();
   read_lexer_settings (lexer,settings);
   delete lexer;
 #elif defined (HAVE_LEXER_MATLAB)
@@ -587,16 +608,20 @@ settings_dialog::write_changed_settings 
   settings->setValue ("editor/show_edit_status_bar",
                       ui->cb_edit_status_bar->isChecked ());
   settings->setValue ("editor/codeCompletion",
                       ui->editor_codeCompletion->isChecked ());
   settings->setValue ("editor/codeCompletion_threshold",
                       ui->editor_spinbox_ac_threshold->value ());
   settings->setValue ("editor/codeCompletion_keywords",
                       ui->editor_checkbox_ac_keywords->isChecked ());
+  settings->setValue ("editor/codeCompletion_octave_builtins",
+                      ui->editor_checkbox_ac_builtins->isChecked ());
+  settings->setValue ("editor/codeCompletion_octave_functions",
+                      ui->editor_checkbox_ac_functions->isChecked ());
   settings->setValue ("editor/codeCompletion_document",
                       ui->editor_checkbox_ac_document->isChecked ());
   settings->setValue ("editor/codeCompletion_case",
                       ui->editor_checkbox_ac_case->isChecked ());
   settings->setValue ("editor/codeCompletion_replace",
                       ui->editor_checkbox_ac_replace->isChecked ());
   settings->setValue ("editor/show_white_space",
                       ui->editor_ws_checkbox->isChecked ());
@@ -708,17 +733,17 @@ settings_dialog::write_changed_settings 
 
   // shortcuts
   settings->setValue ("shortcuts/prevent_readline_conflicts",
                       ui->cb_prevent_readline_conflicts->isChecked ());
   int set = 0;
   if (ui->rb_sc_set2->isChecked ())
     set = 1;
   settings->setValue ("shortcuts/set",set);
-  shortcut_manager::write_shortcuts ();
+  shortcut_manager::write_shortcuts (0, settings);  // 0: write both sets
 
   // settings dialog's geometry
   settings->setValue ("settings/last_tab",ui->tabWidget->currentIndex ());
   settings->setValue ("settings/geometry",saveGeometry ());
 
   settings->sync ();
 }
 
@@ -877,8 +902,33 @@ settings_dialog::set_disabled_pref_file_
       ui->pb_file_browser_dir->setDisabled (ui->cb_restore_file_browser_dir->isChecked ());
     }
   else
     {
       ui->le_file_browser_dir->setDisabled (disable);
       ui->pb_file_browser_dir->setDisabled (disable);
     }
 }
+
+// slots for import/export of shortcut sets
+void
+settings_dialog::import_shortcut_set1 ()
+{
+  shortcut_manager::import_export (true,1);
+}
+
+void
+settings_dialog::export_shortcut_set1 ()
+{
+  shortcut_manager::import_export (false,1);
+}
+
+void
+settings_dialog::import_shortcut_set2 ()
+{
+  shortcut_manager::import_export (true,2);
+}
+
+void
+settings_dialog::export_shortcut_set2 ()
+{
+  shortcut_manager::import_export (false,2);
+}
diff --git a/libgui/src/settings-dialog.h b/libgui/src/settings-dialog.h
--- a/libgui/src/settings-dialog.h
+++ b/libgui/src/settings-dialog.h
@@ -47,16 +47,22 @@ class settings_dialog:public QDialog
   void write_changed_settings ();
 
 private slots:
   void get_octave_dir ();
   void get_file_browser_dir ();
   void get_dir (QLineEdit*, const QString&);
   void set_disabled_pref_file_browser_dir (bool disable);
 
+  // slots for import/export-buttons of shortcut sets
+  void import_shortcut_set1 ();
+  void export_shortcut_set1 ();
+  void import_shortcut_set2 ();
+  void export_shortcut_set2 ();
+
 private:
   Ui::settings_dialog * ui;
 #ifdef HAVE_QSCINTILLA
   void read_lexer_settings (QsciLexer *lexer, QSettings *settings);
   void write_lexer_settings (QsciLexer *lexer, QSettings *settings);
   int  get_valid_lexer_styles (QsciLexer *lexer, int styles[]);
   enum { MaxLexerStyles = 64,
          MaxStyleNumber = 128 };
diff --git a/libgui/src/settings-dialog.ui b/libgui/src/settings-dialog.ui
--- a/libgui/src/settings-dialog.ui
+++ b/libgui/src/settings-dialog.ui
@@ -399,19 +399,19 @@
         <widget class="QScrollArea" name="scrollArea">
          <property name="widgetResizable">
           <bool>true</bool>
          </property>
          <widget class="QWidget" name="scrollAreaWidgetContents">
           <property name="geometry">
            <rect>
             <x>0</x>
-            <y>0</y>
+            <y>-146</y>
             <width>662</width>
-            <height>524</height>
+            <height>553</height>
            </rect>
           </property>
           <layout class="QVBoxLayout" name="verticalLayout_16">
            <item>
             <layout class="QVBoxLayout" name="verticalLayout_9">
              <item>
               <layout class="QGridLayout" name="editor_common_settings_grid">
                <property name="horizontalSpacing">
@@ -869,30 +869,40 @@
                    <property name="text">
                     <string>Match keywords</string>
                    </property>
                    <property name="checked">
                     <bool>true</bool>
                    </property>
                   </widget>
                  </item>
-                 <item row="1" column="0">
+                 <item row="2" column="0">
                   <widget class="QCheckBox" name="editor_checkbox_ac_case">
                    <property name="enabled">
                     <bool>true</bool>
                    </property>
                    <property name="text">
                     <string>Case sensitive</string>
                    </property>
                    <property name="checked">
                     <bool>true</bool>
                    </property>
                   </widget>
                  </item>
-                 <item row="1" column="2">
+                 <item row="1" column="0">
+                  <widget class="QCheckBox" name="editor_checkbox_ac_document">
+                   <property name="enabled">
+                    <bool>true</bool>
+                   </property>
+                   <property name="text">
+                    <string>Match words in document</string>
+                   </property>
+                  </widget>
+                 </item>
+                 <item row="2" column="2">
                   <widget class="QCheckBox" name="editor_checkbox_ac_replace">
                    <property name="enabled">
                     <bool>true</bool>
                    </property>
                    <property name="text">
                     <string>Replace word by suggested one</string>
                    </property>
                   </widget>
@@ -905,39 +915,53 @@
                    <property name="sizeHint" stdset="0">
                     <size>
                      <width>40</width>
                      <height>20</height>
                     </size>
                    </property>
                   </spacer>
                  </item>
-                 <item row="0" column="2">
-                  <widget class="QCheckBox" name="editor_checkbox_ac_document">
-                   <property name="enabled">
-                    <bool>true</bool>
-                   </property>
-                   <property name="text">
-                    <string>Match words in document</string>
-                   </property>
-                  </widget>
-                 </item>
-                 <item row="1" column="3">
+                 <item row="2" column="3">
                   <spacer name="horizontalSpacer_19">
                    <property name="orientation">
                     <enum>Qt::Horizontal</enum>
                    </property>
                    <property name="sizeHint" stdset="0">
                     <size>
                      <width>40</width>
                      <height>20</height>
                     </size>
                    </property>
                   </spacer>
                  </item>
+                 <item row="0" column="2">
+                  <layout class="QHBoxLayout" name="horizontalLayout_14">
+                   <item>
+                    <widget class="QCheckBox" name="editor_checkbox_ac_builtins">
+                     <property name="enabled">
+                      <bool>false</bool>
+                     </property>
+                     <property name="text">
+                      <string>With Octave builtins</string>
+                     </property>
+                    </widget>
+                   </item>
+                   <item>
+                    <widget class="QCheckBox" name="editor_checkbox_ac_functions">
+                     <property name="enabled">
+                      <bool>false</bool>
+                     </property>
+                     <property name="text">
+                      <string>With Octave functions</string>
+                     </property>
+                    </widget>
+                   </item>
+                  </layout>
+                 </item>
                 </layout>
                </item>
                <item row="3" column="1">
                 <layout class="QGridLayout" name="gridLayout_10">
                  <item row="0" column="2">
                   <widget class="QLabel" name="editor_label_ac_threshold">
                    <property name="enabled">
                     <bool>false</bool>
@@ -1733,54 +1757,115 @@
              <item>
               <widget class="Line" name="line_9">
                <property name="orientation">
                 <enum>Qt::Horizontal</enum>
                </property>
               </widget>
              </item>
              <item>
-              <layout class="QHBoxLayout" name="horizontalLayout_14">
-               <item>
-                <widget class="QLabel" name="label_22">
+              <layout class="QGridLayout" name="gridLayout_12">
+               <property name="topMargin">
+                <number>10</number>
+               </property>
+               <item row="3" column="0">
+                <layout class="QHBoxLayout" name="horizontalLayout_16">
+                 <property name="topMargin">
+                  <number>0</number>
+                 </property>
+                </layout>
+               </item>
+               <item row="1" column="2">
+                <widget class="QRadioButton" name="rb_sc_set2">
                  <property name="text">
-                  <string>Use Shortcut Set: </string>
+                  <string>Use this set</string>
                  </property>
                 </widget>
                </item>
-               <item>
+               <item row="0" column="0">
+                <widget class="QLabel" name="label_23">
+                 <property name="text">
+                  <string>Set 1:</string>
+                 </property>
+                </widget>
+               </item>
+               <item row="1" column="4">
+                <widget class="QPushButton" name="btn_export_shortcut_set2">
+                 <property name="text">
+                  <string>Export</string>
+                 </property>
+                </widget>
+               </item>
+               <item row="1" column="3">
+                <widget class="QPushButton" name="btn_import_shortcut_set2">
+                 <property name="text">
+                  <string>Import</string>
+                 </property>
+                </widget>
+               </item>
+               <item row="0" column="2">
                 <widget class="QRadioButton" name="rb_sc_set1">
                  <property name="text">
-                  <string>Set 1</string>
+                  <string>Use this set</string>
                  </property>
                  <property name="checked">
                   <bool>true</bool>
                  </property>
                 </widget>
                </item>
-               <item>
-                <widget class="QRadioButton" name="rb_sc_set2">
-                 <property name="text">
-                  <string>Set 2</string>
-                 </property>
-                </widget>
-               </item>
-               <item>
-                <spacer name="horizontalSpacer_17">
+               <item row="0" column="5">
+                <spacer name="horizontalSpacer_26">
                  <property name="orientation">
                   <enum>Qt::Horizontal</enum>
                  </property>
                  <property name="sizeHint" stdset="0">
                   <size>
                    <width>40</width>
                    <height>20</height>
                   </size>
                  </property>
                 </spacer>
                </item>
+               <item row="0" column="4">
+                <widget class="QPushButton" name="btn_export_shortcut_set1">
+                 <property name="text">
+                  <string>Export</string>
+                 </property>
+                </widget>
+               </item>
+               <item row="0" column="3">
+                <widget class="QPushButton" name="btn_import_shortcut_set1">
+                 <property name="text">
+                  <string>Import</string>
+                 </property>
+                </widget>
+               </item>
+               <item row="1" column="0">
+                <widget class="QLabel" name="label_24">
+                 <property name="text">
+                  <string>Set 2:</string>
+                 </property>
+                </widget>
+               </item>
+               <item row="0" column="1">
+                <spacer name="horizontalSpacer_33">
+                 <property name="orientation">
+                  <enum>Qt::Horizontal</enum>
+                 </property>
+                 <property name="sizeType">
+                  <enum>QSizePolicy::Fixed</enum>
+                 </property>
+                 <property name="sizeHint" stdset="0">
+                  <size>
+                   <width>20</width>
+                   <height>20</height>
+                  </size>
+                 </property>
+                </spacer>
+               </item>
               </layout>
              </item>
              <item>
               <widget class="QLabel" name="label_21">
                <property name="text">
                 <string>Edit an actual shortcut by double clicking into the related cell</string>
                </property>
               </widget>
@@ -2534,10 +2619,42 @@
      <y>187</y>
     </hint>
     <hint type="destinationlabel">
      <x>302</x>
      <y>187</y>
     </hint>
    </hints>
   </connection>
+  <connection>
+   <sender>editor_checkbox_ac_keywords</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>editor_checkbox_ac_builtins</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>118</x>
+     <y>231</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>296</x>
+     <y>231</y>
+    </hint>
+   </hints>
+  </connection>
+  <connection>
+   <sender>editor_checkbox_ac_keywords</sender>
+   <signal>toggled(bool)</signal>
+   <receiver>editor_checkbox_ac_functions</receiver>
+   <slot>setEnabled(bool)</slot>
+   <hints>
+    <hint type="sourcelabel">
+     <x>118</x>
+     <y>231</y>
+    </hint>
+    <hint type="destinationlabel">
+     <x>446</x>
+     <y>231</y>
+    </hint>
+   </hints>
+  </connection>
  </connections>
 </ui>
diff --git a/libgui/src/shortcut-manager.cc b/libgui/src/shortcut-manager.cc
--- a/libgui/src/shortcut-manager.cc
+++ b/libgui/src/shortcut-manager.cc
@@ -29,16 +29,17 @@ along with Octave; see the file COPYING.
 #include <QGridLayout>
 #include <QVBoxLayout>
 #include <QDialogButtonBox>
 #include <QPushButton>
 #include <QLineEdit>
 #include <QCheckBox>
 #include <QHeaderView>
 #include <QAction>
+#include <QFileDialog>
 
 #include "error.h"
 #include "resource-manager.h"
 #include "shortcut-manager.h"
 #include "singleton-cleanup.h"
 
 shortcut_manager *shortcut_manager::instance = 0;
 
@@ -327,43 +328,60 @@ shortcut_manager::do_fill_treewidget (QT
 
       QTreeWidgetItem* section = _level_hash[sc.settings_key.section(':',0,0)];
       QTreeWidgetItem* tree_item = new QTreeWidgetItem (section);
 
       // set a slightly transparent foreground for default columns
       QColor fg = QColor (tree_item->foreground (1).color ());
       fg.setAlpha (128);
       tree_item->setForeground (1, QBrush (fg));
-      tree_item->setForeground (3,QBrush (fg));
+      tree_item->setForeground (3, QBrush (fg));
 
       // write the shortcuts
       tree_item->setText (0, sc.description);
       tree_item->setText (1, sc.default_sc [0]);
       tree_item->setText (2, sc.actual_sc [0]);
       tree_item->setText (3, sc.default_sc [1]);
       tree_item->setText (4, sc.actual_sc [1]);
 
       _item_index_hash[tree_item] = i + 1; // index+1 to avoid 0
       _index_item_hash[i] = tree_item;
     }
 
 }
 
+// write one or all actual shortcut set(s) into a settings file
 void
-shortcut_manager::do_write_shortcuts ()
+shortcut_manager::do_write_shortcuts (int set, QSettings* settings)
 {
-  for (int i = 0; i < _sc.count (); i++)
+  if (set)
     {
-      _settings->setValue("shortcuts/"+_sc.at (i).settings_key, _sc.at (i).actual_sc[0].toString ());
-      _settings->setValue("shortcuts/"+_sc.at (i).settings_key+"_1", _sc.at (i).actual_sc[1].toString ());
+      // set is not zero, only write the desired set (index = set-1)
+      // into the settings file that the user has selected for this export
+      for (int i = 0; i < _sc.count (); i++)  // loop over all shortcuts
+        {
+          settings->setValue("shortcuts/"+_sc.at (i).settings_key,
+                             _sc.at (i).actual_sc[set-1].toString ());
+        }
+    }
+  else
+    {
+      // set is zero, write all sets into the normal octave settings file
+      // (this is only the case when called from the closing settings dialog)
+      for (int i = 0; i < _sc.count (); i++)  // loop over all shortcuts
+        {
+          settings->setValue("shortcuts/"+_sc.at (i).settings_key,
+                             _sc.at (i).actual_sc[0].toString ());
+          settings->setValue("shortcuts/"+_sc.at (i).settings_key+"_1",
+                            _sc.at (i).actual_sc[1].toString ());
+        }
+      delete _dialog;  // the dialog for key sequences can be removed now
     }
 
-  _settings->sync ();
-
-  delete _dialog;
+  settings->sync ();    // sync the settings file
 }
 
 void
 shortcut_manager::do_set_shortcut (QAction* action, const QString& key)
 {
   int set = _settings->value ("shortcuts/set",0).toInt ();
   int index;
 
@@ -525,36 +543,95 @@ shortcut_manager::shortcut_dialog_finish
 }
 
 void
 shortcut_manager::shortcut_dialog_set_default ()
 {
   _edit_actual->setText (_label_default->text ());
 }
 
+// import a shortcut set from a given settings file and refresh the tree view
+void
+shortcut_manager::import_shortcuts (int set, QSettings *settings)
+{
+  for (int i = 0; i < _sc.count (); i++)
+    {
+      // update the list of all shortcuts
+      shortcut_t sc = _sc.at (i);           // make a copy
+      sc.actual_sc[set-1] = QKeySequence (  // get new shortcut from settings
+        settings->value ("shortcuts/"+sc.settings_key,sc.actual_sc[set-1]).
+                        toString ());       // and use the old one as default
+      _sc.replace (i,sc);                   // replace the old with the new one
+
+      // update the tree view
+      QTreeWidgetItem* tree_item = _index_item_hash[i]; // get related tree item
+      tree_item->setText (2*set, sc.actual_sc [set-1]); // display new shortcut
+    }
+}
+
+// import or export of shortcut sets,
+// called from settings dialog when related buttons are clicked
+void
+shortcut_manager::do_import_export (bool import, int set)
+{
+  QString file;
+
+  // get the file name to read or write the shortcuts,
+  // the default extension is .osc (octave shortcuts)
+  if (import)
+    {
+      file = QFileDialog::getOpenFileName (this,
+              tr ("Import shortcut set %1 from file ...").arg (set), QString (),
+              tr ("Octave Shortcut Files (*.osc);;All Files (*)"));
+    }
+  else
+    {
+      file = QFileDialog::getSaveFileName (this,
+              tr ("Export shortcut set %1 into file ...").arg (set), QString (),
+              tr ("Octave Shortcut Files (*.osc);;All Files (*)"));
+    }
+
+  // create a settings object related to this file
+  QSettings *osc_settings = new QSettings (file, QSettings::IniFormat);
+  if (osc_settings)
+    {
+      // the settings object was successfully created: carry on
+      if (import)
+        import_shortcuts (set, osc_settings);   // import (special action)
+      else
+        do_write_shortcuts (set, osc_settings); // export, like saving settings
+    }
+  else
+    qWarning () << tr ("Failed to open %1 as octave shortcut file"). arg (file);
+
+}
 
 
+// enter_shortcut:
+// class derived from QLineEdit for directly entering key sequences which
 enter_shortcut::enter_shortcut (QWidget *p) : QLineEdit (p)
 {
-  _direct_shortcut = true;
+  _direct_shortcut = true;      // the shortcut is directly entered
 }
 
 enter_shortcut::~enter_shortcut ()
 {
 }
 
+// slot for checkbox whether the shortcut is directly entered or not
 void
 enter_shortcut::handle_direct_shortcut (int state)
 {
   if (state)
-    _direct_shortcut = true;
+    _direct_shortcut = true;  // the shortcut is directly entered
   else
-    _direct_shortcut = false;
+    _direct_shortcut = false; // the shortcut has to be written as text
 }
 
+// new keyPressEvent
 void
 enter_shortcut::keyPressEvent (QKeyEvent *e)
 {
   if (! _direct_shortcut)
     {
       QLineEdit::keyPressEvent (e);
       return;
     }
@@ -575,9 +652,8 @@ enter_shortcut::keyPressEvent (QKeyEvent
       if(modifiers & Qt::AltModifier)
         key += Qt::ALT;
       if(modifiers & Qt::MetaModifier)
         key += Qt::META;
 
       setText (QKeySequence(key));
     }
 }
-
diff --git a/libgui/src/shortcut-manager.h b/libgui/src/shortcut-manager.h
--- a/libgui/src/shortcut-manager.h
+++ b/libgui/src/shortcut-manager.h
@@ -58,34 +58,40 @@ public:
   ~shortcut_manager ();
 
   static void init_data ()
   {
     if (instance_ok ())
       instance->do_init_data ();
   }
 
-  static void write_shortcuts ()
+  static void write_shortcuts (int set, QSettings *settings)
   {
     if (instance_ok ())
-      instance->do_write_shortcuts ();
+      instance->do_write_shortcuts (set, settings);
   }
 
   static void set_shortcut (QAction *action, const QString& key)
   {
     if (instance_ok ())
       instance->do_set_shortcut (action, key);
   }
 
   static void fill_treewidget (QTreeWidget *tree_view)
   {
     if (instance_ok ())
       instance->do_fill_treewidget (tree_view);
   }
 
+  static void import_export (bool import, int set)
+  {
+    if (instance_ok ())
+      instance->do_import_export (import, set);
+  }
+
 public slots:
 
 signals:
 
 protected:
 
 protected slots:
 
@@ -102,20 +108,22 @@ private:
 
   shortcut_manager (const shortcut_manager&);
   shortcut_manager& operator = (const shortcut_manager&);
 
   static bool instance_ok (void);
 
   void init (QString, QString, QKeySequence);
   void do_init_data ();
-  void do_write_shortcuts ();
+  void do_write_shortcuts (int set, QSettings *settings);
   void do_set_shortcut (QAction *action, const QString& key);
   void do_fill_treewidget (QTreeWidget *tree_view);
+  void do_import_export (bool import, int set);
   void shortcut_dialog (int);
+  void import_shortcuts (int set, QSettings *settings);
 
   struct shortcut_t
   {
     QString description;
     QString settings_key;
     QKeySequence actual_sc[2];
     QKeySequence default_sc[2];
     QTreeWidgetItem *tree_item;
diff --git a/libinterp/corefcn/graphics.in.h b/libinterp/corefcn/graphics.in.h
--- a/libinterp/corefcn/graphics.in.h
+++ b/libinterp/corefcn/graphics.in.h
@@ -3757,17 +3757,17 @@ public:
       any_property linestyleorder S , "-"
       double_property linewidth , 0.5
       radio_property minorgridlinestyle , "-|--|{:}|-.|none"
       radio_property nextplot , "add|replacechildren|{replace}"
       array_property outerposition u , default_axes_outerposition ()
       array_property plotboxaspectratio mu , Matrix (1, 3, 1.0)
       radio_property plotboxaspectratiomode u , "{auto}|manual"
       array_property position u , default_axes_position ()
-      radio_property projection , "{orthographic}|perpective"
+      radio_property projection , "{orthographic}|perspective"
       radio_property tickdir mu , "{in}|out"
       radio_property tickdirmode u , "{auto}|manual"
       array_property ticklength u , default_axes_ticklength ()
       array_property tightinset r , Matrix (1, 4, 0.0)
       handle_property title SOf , gh_manager::make_graphics_handle ("text", __myhandle__, false, false, false)
       // FIXME: uicontextmenu should be moved here.
       radio_property units SU , "{normalized}|inches|centimeters|points|pixels|characters"
       array_property view u , default_axes_view ()
diff --git a/libinterp/corefcn/ls-mat5.cc b/libinterp/corefcn/ls-mat5.cc
--- a/libinterp/corefcn/ls-mat5.cc
+++ b/libinterp/corefcn/ls-mat5.cc
@@ -662,17 +662,25 @@ read_mat5_binary_element (std::istream& 
       if (read_mat5_tag (is, swap, type, dim_len, is_small_data_element) ||
           type != miINT32)
         {
           error ("load: invalid dimensions array subelement");
           goto early_read_error;
         }
 
       int ndims = dim_len / 4;
-      dims.resize (ndims);
+      if (ndims == 1)
+        {
+          // R and Python can create a 1-D object which is really an Nx1 object
+          dims.resize (2);
+          dims(1) = 1;
+        }
+      else
+        dims.resize (ndims);
+
       for (int i = 0; i < ndims; i++)
         {
           int32_t n;
           read_int (is, swap, n);
           dims(i) = n;
         }
 
       std::streampos tmp_pos = is.tellg ();
diff --git a/libinterp/corefcn/xnorm.cc b/libinterp/corefcn/xnorm.cc
--- a/libinterp/corefcn/xnorm.cc
+++ b/libinterp/corefcn/xnorm.cc
@@ -43,17 +43,19 @@ octave_value xnorm (const octave_value& 
 
   bool isvector = (x.columns () == 1 || x.rows () == 1);
   bool iscomplex = x.is_complex_type ();
   bool issparse = x.is_sparse_type ();
   bool isfloat = x.is_single_type ();
 
   if (isfloat || x.is_double_type ())
     {
-      if (isvector)
+      if (x.is_empty ())
+        retval = octave_value (0);
+      else if (isvector)
         {
           if (isfloat & iscomplex)
             retval = xnorm (x.float_complex_column_vector_value (),
                             p.float_value ());
           else if (isfloat)
             retval = xnorm (x.float_column_vector_value (),
                             p.float_value ());
           else if (iscomplex)
diff --git a/libinterp/dldfcn/chol.cc b/libinterp/dldfcn/chol.cc
--- a/libinterp/dldfcn/chol.cc
+++ b/libinterp/dldfcn/chol.cc
@@ -207,17 +207,17 @@ sparse matrices.\n\
                       if (vecout)
                         retval(2) = fact.perm ();
                       else
                         retval(2) = fact.Q ();
                     }
 
                   if (nargout > 1 || info == 0)
                     {
-                      retval(1) = fact.P ();
+                      retval(1) = info;
                       if (LLt)
                         retval(0) = fact.L ();
                       else
                         retval(0) = fact.R ();
                     }
                   else
                     error ("chol: input matrix must be positive definite");
                 }
@@ -235,17 +235,17 @@ sparse matrices.\n\
                       if (vecout)
                         retval(2) = fact.perm ();
                       else
                         retval(2) = fact.Q ();
                     }
 
                   if (nargout > 1 || info == 0)
                     {
-                      retval(1) = fact.P ();
+                      retval(1) = info;
                       if (LLt)
                         retval(0) = fact.L ();
                       else
                         retval(0) = fact.R ();
                     }
                   else
                     error ("chol: input matrix must be positive definite");
                 }
@@ -370,16 +370,21 @@ sparse matrices.\n\
     }
 
   return retval;
 }
 
 /*
 %!assert (chol ([2, 1; 1, 1]), [sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)], sqrt (eps))
 %!assert (chol (single ([2, 1; 1, 1])), single ([sqrt(2), 1/sqrt(2); 0, 1/sqrt(2)]), sqrt (eps ("single")))
+%!test   
+%! ## Bug #42587
+%! A = sparse ([1 0 8;0 1 8;8 8 1]);
+%! [Q, p] = chol (A);
+%! assert (p != 0);
 
 %!error chol ()
 %!error <matrix must be positive definite> chol ([1, 2; 3, 4])
 %!error <requires square matrix> chol ([1, 2; 3, 4; 5, 6])
 %!error <unexpected second or third input> chol (1, 2)
 */
 
 DEFUN_DLD (cholinv, args, ,
diff --git a/liboctave/array/CMatrix.cc b/liboctave/array/CMatrix.cc
--- a/liboctave/array/CMatrix.cc
+++ b/liboctave/array/CMatrix.cc
@@ -2678,21 +2678,18 @@ ComplexMatrix::lssolve (const ComplexMat
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of rwork and iwork because ZGELSD in
       // older versions of LAPACK does not return them on a query
       // call.
       double dminmn = static_cast<double> (minmn);
       double dsmlsizp1 = static_cast<double> (smlsiz+1);
-#if defined (HAVE_LOG2)
-      double tmp = log2 (dminmn / dsmlsizp1);
-#else
-      double tmp = log (dminmn / dsmlsizp1) / log (2.0);
-#endif
+      double tmp = xlog2 (dminmn / dsmlsizp1);
+
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
                                + 3*smlsiz*nrhs
                                + std::max ((smlsiz+1)*(smlsiz+1),
                                            n*(1+nrhs) + 2*nrhs);
@@ -2870,21 +2867,18 @@ ComplexMatrix::lssolve (const ComplexCol
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of rwork and iwork because ZGELSD in
       // older versions of LAPACK does not return them on a query
       // call.
       double dminmn = static_cast<double> (minmn);
       double dsmlsizp1 = static_cast<double> (smlsiz+1);
-#if defined (HAVE_LOG2)
-      double tmp = log2 (dminmn / dsmlsizp1);
-#else
-      double tmp = log (dminmn / dsmlsizp1) / log (2.0);
-#endif
+      double tmp = xlog2 (dminmn / dsmlsizp1);
+
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
                                + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
         lrwork = 1;
diff --git a/liboctave/array/dMatrix.cc b/liboctave/array/dMatrix.cc
--- a/liboctave/array/dMatrix.cc
+++ b/liboctave/array/dMatrix.cc
@@ -2315,21 +2315,18 @@ Matrix::lssolve (const Matrix& b, octave
                                    m, n, nrhs, -1, mnthr
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of iwork because DGELSD in older versions
       // of LAPACK does not return it on a query call.
       double dminmn = static_cast<double> (minmn);
       double dsmlsizp1 = static_cast<double> (smlsiz+1);
-#if defined (HAVE_LOG2)
-      double tmp = log2 (dminmn / dsmlsizp1);
-#else
-      double tmp = log (dminmn / dsmlsizp1) / log (2.0);
-#endif
+      double tmp = xlog2 (dminmn / dsmlsizp1);
+
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<octave_idx_type> iwork (dim_vector (liwork, 1));
@@ -2506,21 +2503,18 @@ Matrix::lssolve (const ColumnVector& b, 
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of iwork because DGELSD in older versions
       // of LAPACK does not return it on a query call.
       double dminmn = static_cast<double> (minmn);
       double dsmlsizp1 = static_cast<double> (smlsiz+1);
-#if defined (HAVE_LOG2)
-      double tmp = log2 (dminmn / dsmlsizp1);
-#else
-      double tmp = log (dminmn / dsmlsizp1) / log (2.0);
-#endif
+      double tmp = xlog2 (dminmn / dsmlsizp1);
+
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<octave_idx_type> iwork (dim_vector (liwork, 1));
diff --git a/liboctave/array/fCMatrix.cc b/liboctave/array/fCMatrix.cc
--- a/liboctave/array/fCMatrix.cc
+++ b/liboctave/array/fCMatrix.cc
@@ -2694,21 +2694,18 @@ FloatComplexMatrix::lssolve (const Float
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of rwork and iwork because ZGELSD in
       // older versions of LAPACK does not return them on a query
       // call.
       float dminmn = static_cast<float> (minmn);
       float dsmlsizp1 = static_cast<float> (smlsiz+1);
-#if defined (HAVE_LOG2)
-      float tmp = log2 (dminmn / dsmlsizp1);
-#else
-      float tmp = log (dminmn / dsmlsizp1) / log (2.0);
-#endif
+      float tmp = xlog2 (dminmn / dsmlsizp1);
+
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
                                + 3*smlsiz*nrhs
                                + std::max ((smlsiz+1)*(smlsiz+1),
                                            n*(1+nrhs) + 2*nrhs);
@@ -2889,21 +2886,18 @@ FloatComplexMatrix::lssolve (const Float
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of rwork and iwork because ZGELSD in
       // older versions of LAPACK does not return them on a query
       // call.
       float dminmn = static_cast<float> (minmn);
       float dsmlsizp1 = static_cast<float> (smlsiz+1);
-#if defined (HAVE_LOG2)
-      float tmp = log2 (dminmn / dsmlsizp1);
-#else
-      float tmp = log (dminmn / dsmlsizp1) / log (2.0);
-#endif
+      float tmp = xlog2 (dminmn / dsmlsizp1);
+
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type lrwork = minmn*(10 + 2*smlsiz + 8*nlvl)
                                + 3*smlsiz*nrhs + (smlsiz+1)*(smlsiz+1);
       if (lrwork < 1)
         lrwork = 1;
diff --git a/liboctave/array/fMatrix.cc b/liboctave/array/fMatrix.cc
--- a/liboctave/array/fMatrix.cc
+++ b/liboctave/array/fMatrix.cc
@@ -2335,21 +2335,18 @@ FloatMatrix::lssolve (const FloatMatrix&
                                    m, n, nrhs, -1, mnthr
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of iwork because DGELSD in older versions
       // of LAPACK does not return it on a query call.
       float dminmn = static_cast<float> (minmn);
       float dsmlsizp1 = static_cast<float> (smlsiz+1);
-#if defined (HAVE_LOG2)
-      float tmp = log2 (dminmn / dsmlsizp1);
-#else
-      float tmp = log (dminmn / dsmlsizp1) / log (2.0);
-#endif
+      float tmp = xlog2 (dminmn / dsmlsizp1);
+
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<octave_idx_type> iwork (dim_vector (liwork, 1));
@@ -2526,21 +2523,18 @@ FloatMatrix::lssolve (const FloatColumnV
                                    0, 0, 0, 0, smlsiz
                                    F77_CHAR_ARG_LEN (6)
                                    F77_CHAR_ARG_LEN (1));
 
       // We compute the size of iwork because DGELSD in older versions
       // of LAPACK does not return it on a query call.
       float dminmn = static_cast<float> (minmn);
       float dsmlsizp1 = static_cast<float> (smlsiz+1);
-#if defined (HAVE_LOG2)
-      float tmp = log2 (dminmn / dsmlsizp1);
-#else
-      float tmp = log (dminmn / dsmlsizp1) / log (2.0);
-#endif
+      float tmp = xlog2 (dminmn / dsmlsizp1);
+
       octave_idx_type nlvl = static_cast<octave_idx_type> (tmp) + 1;
       if (nlvl < 0)
         nlvl = 0;
 
       octave_idx_type liwork = 3 * minmn * nlvl + 11 * minmn;
       if (liwork < 1)
         liwork = 1;
       Array<octave_idx_type> iwork (dim_vector (liwork, 1));
diff --git a/liboctave/numeric/lo-mappers.cc b/liboctave/numeric/lo-mappers.cc
--- a/liboctave/numeric/lo-mappers.cc
+++ b/liboctave/numeric/lo-mappers.cc
@@ -87,27 +87,17 @@ signum (double x)
     tmp = 1.0;
 
   return xisnan (x) ? octave_NaN : tmp;
 }
 
 double
 xlog2 (double x)
 {
-#if defined (HAVE_LOG2)
-  return log2 (x);
-#else
-#if defined (M_LN2)
-  static double ln2 = M_LN2;
-#else
-  static double ln2 = log (2);
-#endif
-
-  return log (x) / ln2;
-#endif
+  return gnulib::log2 (x);
 }
 
 Complex
 xlog2 (const Complex& x)
 {
 #if defined (M_LN2)
   static double ln2 = M_LN2;
 #else
@@ -312,29 +302,17 @@ signum (float x)
     tmp = 1.0;
 
   return xisnan (x) ? octave_Float_NaN : tmp;
 }
 
 float
 xlog2 (float x)
 {
-#if defined (HAVE_LOG2F)
-  return log2f (x);
-#elif defined (HAVE_LOG2)
-  return log2 (x);
-#else
-#if defined (M_LN2)
-  static float ln2 = M_LN2;
-#else
-  static float ln2 = log2 (2);
-#endif
-
-  return log (x) / ln2;
-#endif
+  return gnulib::log2f (x);
 }
 
 FloatComplex
 xlog2 (const FloatComplex& x)
 {
 #if defined (M_LN2)
   static float ln2 = M_LN2;
 #else
diff --git a/scripts/plot/util/private/__gnuplot_ginput__.m b/scripts/plot/util/private/__gnuplot_ginput__.m
--- a/scripts/plot/util/private/__gnuplot_ginput__.m
+++ b/scripts/plot/util/private/__gnuplot_ginput__.m
@@ -96,17 +96,17 @@ function [x, y, button] = __gnuplot_ginp
 
         ## Now read from fifo.
         [x(k), y(k), button(k), count] = fscanf (gpin, "%f %f %d", "C");
         fclose (gpin);
       else
         fputs (ostream, "set print \"-\";\n");
         fflush (ostream);
         fputs (ostream, "pause mouse any;\n\n");
-        fputs (ostream, "\nif (exists(\"MOUSE_KEY\") && exists(\"MOUSE_X\")) print \"OCTAVE: \", MOUSE_X, MOUSE_Y, MOUSE_KEY; else print \"0 0 -1\"\n");
+        fputs (ostream, "\nif (exists(\"MOUSE_KEY\") && exists(\"MOUSE_X\")) key = (MOUSE_KEY==1063 ? 1 : MOUSE_KEY); print \"OCTAVE: \", MOUSE_X, MOUSE_Y, key; else print \"0 0 -1\"\n");
 
         ## Close output file, to force it to be flushed
         fputs (ostream, "set print;\n");
         fflush (ostream);
 
         str = {};
         while (isempty (str))
           str = fread (istream, "*char")';
