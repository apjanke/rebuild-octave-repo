# HG changeset patch
# User jwe
# Date 753358319 0
#      Mon Nov 15 10:11:59 1993 +0000
# Node ID 1a48a1b9148953315145c513a4aa56074f2cb929
# Parent  c4027b057786b7f80002cfe8e357c286d7f44604
[project @ 1993-11-15 10:10:35 by jwe]

diff --git a/libcruft/misc/lo-error.cc b/libcruft/misc/lo-error.cc
--- a/libcruft/misc/lo-error.cc
+++ b/libcruft/misc/lo-error.cc
@@ -24,22 +24,18 @@ Software Foundation, 675 Mass Ave, Cambr
 #ifdef __GNUG__
 #pragma implementation
 #endif
 
 #include <stdio.h>
 #include <stdlib.h>
 #include <stdarg.h>
 
-#include "liboctave-error.h"
+#include "lo-error.h"
 
-static
-liboctave_error_handler default_liboctave_error_handler = liboctave_fatal;
-
-static
 liboctave_error_handler current_liboctave_error_handler = liboctave_fatal;
 
 static void
 verror (const char *name, const char *fmt, va_list args)
 {
   if (name != (char *) NULL)
     fprintf (stderr, "%s: ", name);
 
@@ -49,17 +45,17 @@ verror (const char *name, const char *fm
 }
 
 void
 set_liboctave_error_handler (liboctave_error_handler f)
 {
   if (f)
     current_liboctave_error_handler = f;
   else
-    current_liboctave_error_handler = default_liboctave_error_handler;
+    current_liboctave_error_handler = liboctave_fatal;
 }
 
 void
 liboctave_fatal (const char *fmt, ...)
 {
   va_list args;
   va_start (args, fmt);
   verror ("fatal", fmt, args);
diff --git a/liboctave/Bounds.cc b/liboctave/Bounds.cc
--- a/liboctave/Bounds.cc
+++ b/liboctave/Bounds.cc
@@ -22,24 +22,24 @@ Software Foundation, 675 Mass Ave, Cambr
 */
 
 #ifdef __GNUG__
 #pragma implementation
 #endif
 
 #include <iostream.h>
 #include "Bounds.h"
+#include "lo-error.h"
 
 // error handling
 
 void
 Bounds::error (const char* msg)
 {
-  cerr << "Fatal bounds error. " << msg << "\n";
-  exit(1);
+  (*current_liboctave_error_handler) ("fatal bounds error: ", msg);
 }
 
 Bounds::Bounds (void)
 {
   nb = 0;
 }
 
 Bounds::Bounds (int n)
@@ -49,17 +49,20 @@ Bounds::Bounds (int n)
   ub.resize (nb);
   lb.fill (0.0);
   ub.fill (0.0);
 }
 
 Bounds::Bounds (const ColumnVector l, const ColumnVector u)
 {
   if (l.capacity () != u.capacity ())
-    error ("inconsistent sizes for lower and upper bounds");
+    {
+      error ("inconsistent sizes for lower and upper bounds");
+      return;
+    }
 
   nb = l.capacity ();
   lb = l;
   ub = u;
 }
 
 Bounds::Bounds (const Bounds& a)
 {
@@ -135,17 +138,20 @@ Bounds::set_bounds (double low, double h
 
   return *this;
 }
 
 Bounds&
 Bounds::set_bounds (const ColumnVector l, const ColumnVector u)
 {
   if (l.capacity () != u.capacity ())
-    error ("inconsistent sizes for lower and upper bounds");
+    {
+      error ("inconsistent sizes for lower and upper bounds");
+      return *this;
+    }
 
   nb = l.capacity ();
   lb = l;
   ub = u;
 
   return *this;
 }
 
@@ -180,28 +186,34 @@ Bounds::set_upper_bounds (double high)
 
   return *this;
 }
 
 Bounds&
 Bounds::set_lower_bounds (const ColumnVector l)
 {
   if (nb != l.capacity ())
-    error ("inconsistent size for lower bounds");
+    {
+      error ("inconsistent size for lower bounds");
+      return *this;
+    }
 
   lb = l;
 
   return *this;
 }
 
 Bounds&
 Bounds::set_upper_bounds (const ColumnVector u)
 {
   if (nb != u.capacity ())
-    error ("inconsistent size for upper bounds");
+    {
+      error ("inconsistent size for upper bounds");
+      return *this;
+    }
 
   ub = u;
 
   return *this;
 }
 
 ostream&
 operator << (ostream& os, const Bounds& b)
diff --git a/liboctave/ColVector.cc b/liboctave/ColVector.cc
--- a/liboctave/ColVector.cc
+++ b/liboctave/ColVector.cc
@@ -25,37 +25,50 @@ Software Foundation, 675 Mass Ave, Cambr
 // several classes, each of which is defined in a separate file...
 //
 // #ifdef __GNUG__
 // #pragma implementation "Matrix.h"
 // #endif
 
 #include "Matrix.h"
 #include "mx-inlines.cc"
+#include "lo-error.h"
 
 /*
  * Column Vector class.
  */
 
 ColumnVector::ColumnVector (int n)
 {
   if (n < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create column vector with negative dimension");
+      len = 0;
+      data = (double *) NULL;
+      return;
+    }
 
   len = n;
   if (n > 0)
     data = new double [len];
   else
     data = (double *) NULL;
 }
 
 ColumnVector::ColumnVector (int n, double val)
 {
   if (n < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create column vector with negative dimension");
+      len = 0;
+      data = (double *) NULL;
+      return;
+    }
 
   len = n;
   if (n > 0)
     {
       data = new double [len];
       copy (data, len, val);
     }
   else
@@ -94,21 +107,54 @@ ColumnVector::operator = (const ColumnVe
 	  copy (data, a.data, len);
 	}
       else
 	data = (double *) NULL;
     }
   return *this;
 }
 
+double&
+ColumnVector::checkelem (int n)
+{
+#ifndef NO_RANGE_CHECK
+  if (n < 0 || n >= len)
+    {
+      (*current_liboctave_error_handler) ("range error");
+      static double foo = 0.0;
+      return foo;
+    }
+#endif
+
+  return elem (n);
+}
+
+double
+ColumnVector::checkelem (int n) const
+{
+#ifndef NO_RANGE_CHECK
+  if (n < 0 || n >= len)
+    {
+      (*current_liboctave_error_handler) ("range error");
+      return 0.0;
+    }
+#endif
+
+  return elem (n);
+}
+
 ColumnVector&
 ColumnVector::resize (int n)
 {
   if (n < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't resize to negative dimension");
+      return *this;
+    }
 
   double *new_data = (double *) NULL;
   if (n > 0)
     {
       new_data = new double [n];
       int min_len = len < n ? len : n;
 
       for (int i = 0; i < min_len; i++)
@@ -148,17 +194,20 @@ ColumnVector::operator != (const ColumnV
     return 1;
   return !equal (data, a.data, len);
 }
 
 ColumnVector&
 ColumnVector::insert (const ColumnVector& a, int r)
 {
   if (r < 0 || r + a.len - 1 > len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for insert");
+      return *this;
+    }
 
   for (int i = 0; i < a.len; i++)
     data[r+i] = a.data[i];
 
   return *this;
 }
 
 ColumnVector&
@@ -168,17 +217,20 @@ ColumnVector::fill (double val)
     copy (data, len, val);
   return *this;
 }
 
 ColumnVector&
 ColumnVector::fill (double val, int r1, int r2)
 {
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
 
   for (int i = r1; i <= r2; i++)
     data[i] = val;
 
   return *this;
 }
@@ -293,17 +345,21 @@ ColumnVector::operator / (const Complex&
 }
 
 // column vector by row vector -> matrix operations
 
 Matrix
 ColumnVector::operator * (const RowVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector multiplication attempted");
+      return Matrix ();
+    }
 
   if (len == 0)
     return Matrix (len, len, 0.0);
 
   char transa = 'N';
   char transb = 'N';
   double alpha = 1.0;
   double beta  = 0.0;
@@ -326,126 +382,166 @@ ColumnVector::operator * (const ComplexR
 }
 
 // column vector by column vector -> column vector operations
 
 ColumnVector
 ColumnVector::operator + (const ColumnVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector addition attempted");
+      return ColumnVector ();
+    }
 
   if (len == 0)
     return ColumnVector (0);
 
   return ColumnVector (add (data, a.data, len), len);
 }
 
 ColumnVector
 ColumnVector::operator - (const ColumnVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector subtraction attempted");
+      return ColumnVector ();
+    }
 
   if (len == 0)
     return ColumnVector (0);
 
   return ColumnVector (subtract (data, a.data, len), len);
 }
 
 ComplexColumnVector
 ColumnVector::operator + (const ComplexColumnVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector addition attempted");
+      return ComplexColumnVector ();
+    }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (add (data, a.data, len), len);
 }
 
 ComplexColumnVector
 ColumnVector::operator - (const ComplexColumnVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector subtraction attempted");
+      return ComplexColumnVector ();
+    }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (subtract (data, a.data, len), len);
 }
 
 ColumnVector
 ColumnVector::product (const ColumnVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector product attempted");
+      return ColumnVector ();
+    }
 
   if (len == 0)
     return ColumnVector (0);
 
   return ColumnVector (multiply (data, a.data, len), len);
 }
 
 ColumnVector
 ColumnVector::quotient (const ColumnVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector quotient attempted");
+      return ColumnVector ();
+    }
 
   if (len == 0)
     return ColumnVector (0);
 
   return ColumnVector (divide (data, a.data, len), len);
 }
 
 ComplexColumnVector
 ColumnVector::product (const ComplexColumnVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector product attempted");
+      return ColumnVector ();
+    }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (multiply (data, a.data, len), len);
 }
 
 ComplexColumnVector
 ColumnVector::quotient (const ComplexColumnVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector quotient attempted");
+      return ColumnVector ();
+    }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (divide (data, a.data, len), len);
 }
 
 ColumnVector&
 ColumnVector::operator += (const ColumnVector& a)
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector += operation attempted");
+      return ColumnVector ();
+    }
 
   if (len == 0)
     return *this;
 
   add2 (data, a.data, len);
   return *this;
 }
 
 ColumnVector&
 ColumnVector::operator -= (const ColumnVector& a)
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector -= operation attempted");
+      return ColumnVector ();
+    }
 
   if (len == 0)
     return *this;
 
   subtract2 (data, a.data, len);
   return *this;
 }
 
@@ -516,44 +612,62 @@ operator << (ostream& os, const ColumnVe
 
 /*
  * Complex Column Vector class
  */
 
 ComplexColumnVector::ComplexColumnVector (int n)
 {
   if (n < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create column vector with negative dimension");
+      len = 0;
+      data = (Complex *) NULL;
+      return;
+    }
 
   len = n;
   if (n > 0)
     data = new Complex [len];
   else
     data = (Complex *) NULL;
 }
 
 ComplexColumnVector::ComplexColumnVector (int n, double val)
 {
   if (n < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create column vector with negative dimension");
+      len = 0;
+      data = (Complex *) NULL;
+      return;
+    }
 
   len = n;
   if (n > 0)
     {
       data = new Complex [len];
       copy (data, len, val);
     }
   else
     data = (Complex *) NULL;
 }
 
 ComplexColumnVector::ComplexColumnVector (int n, const Complex& val)
 {
   if (n < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create column vector with negative dimension");
+      len = 0;
+      data = (Complex *) NULL;
+      return;
+    }
 
   len = n;
   if (n > 0)
     {
       data = new Complex [len];
       copy (data, len, val);
     }
   else
@@ -627,21 +741,54 @@ ComplexColumnVector::operator = (const C
 	  copy (data, a.data, len);
 	}
       else
 	data = (Complex *) NULL;
     }
   return *this;
 }
 
+Complex&
+ComplexColumnVector::checkelem (int n)
+{
+#ifndef NO_RANGE_CHECK
+  if (n < 0 || n >= len)
+    {
+      (*current_liboctave_error_handler) ("range error");
+      static Complex foo (0.0);
+      return foo;
+    }
+#endif
+
+  return elem (n);
+}
+
+Complex
+ComplexColumnVector::checkelem (int n) const
+{
+#ifndef NO_RANGE_CHECK
+  if (n < 0 || n >= len)
+    {
+      (*current_liboctave_error_handler) ("range error");
+      return Complex (0.0);
+    }
+#endif
+
+  return elem (n);
+}
+
 ComplexColumnVector&
 ComplexColumnVector::resize (int n)
 {
   if (n < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't resize to negative dimension");
+      return *this;
+    }
 
   Complex *new_data = (Complex *) NULL;
   if (n > 0)
     {
       new_data = new Complex [n];
       int min_len = len < n ? len : n;
 
       for (int i = 0; i < min_len; i++)
@@ -694,29 +841,35 @@ ComplexColumnVector::operator != (const 
 }
 
 // destructive insert/delete/reorder operations
 
 ComplexColumnVector&
 ComplexColumnVector::insert (const ColumnVector& a, int r)
 {
   if (r < 0 || r + a.len - 1 > len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for insert");
+      return *this;
+    }
 
   for (int i = 0; i < a.len; i++)
     data[r+i] = a.data[i];
 
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::insert (const ComplexColumnVector& a, int r)
 {
   if (r < 0 || r + a.len - 1 > len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for insert");
+      return *this;
+    }
 
   for (int i = 0; i < a.len; i++)
     data[r+i] = a.data[i];
 
   return *this;
 }
 
 ComplexColumnVector&
@@ -734,31 +887,37 @@ ComplexColumnVector::fill (const Complex
     copy (data, len, val);
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::fill (double val, int r1, int r2)
 {
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
 
   for (int i = r1; i <= r2; i++)
     data[i] = val;
 
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::fill (const Complex& val, int r1, int r2)
 {
   if (r1 < 0 || r2 < 0 || r1 >= len || r2 >= len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
 
   for (int i = r1; i <= r2; i++)
     data[i] = val;
 
   return *this;
 }
@@ -947,17 +1106,21 @@ ComplexColumnVector::operator * (const R
   ComplexRowVector tmp (a);
   return *this * tmp;
 }
 
 ComplexMatrix
 ComplexColumnVector::operator * (const ComplexRowVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector multiplication attempted");
+      return ComplexMatrix ();
+    }
 
   if (len == 0)
     return ComplexMatrix (len, len, 0.0);
 
   char transa = 'N';
   char transb = 'N';
   Complex alpha (1.0);
   Complex beta (0.0);
@@ -973,152 +1136,200 @@ ComplexColumnVector::operator * (const C
 }
 
 // column vector by column vector -> column vector operations
 
 ComplexColumnVector
 ComplexColumnVector::operator + (const ColumnVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector addition attempted");
+      return ComplexColumnVector ();
+    }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (add (data, a.data, len), len);
 }
 
 ComplexColumnVector
 ComplexColumnVector::operator - (const ColumnVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector subtraction attempted");
+      return ComplexColumnVector ();
+    }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (subtract (data, a.data, len), len);
 }
 
 ComplexColumnVector
 ComplexColumnVector::operator + (const ComplexColumnVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector addition attempted");
+      return ComplexColumnVector ();
+    }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (add (data, a.data, len), len);
 }
 
 ComplexColumnVector
 ComplexColumnVector::operator - (const ComplexColumnVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector subtraction attempted");
+      return ComplexColumnVector ();
+    }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (subtract (data, a.data, len), len);
 }
 
 ComplexColumnVector
 ComplexColumnVector::product (const ColumnVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector product attempted");
+      return ComplexColumnVector ();
+    }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (multiply (data, a.data, len), len);
 }
 
 ComplexColumnVector
 ComplexColumnVector::quotient (const ColumnVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector quotient attempted");
+      return ComplexColumnVector ();
+    }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (divide (data, a.data, len), len);
 }
 
 ComplexColumnVector
 ComplexColumnVector::product (const ComplexColumnVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector product attempted");
+      return ComplexColumnVector ();
+    }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (multiply (data, a.data, len), len);
 }
 
 ComplexColumnVector
 ComplexColumnVector::quotient (const ComplexColumnVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector quotient attempted");
+      return ComplexColumnVector ();
+    }
 
   if (len == 0)
     return ComplexColumnVector (0);
 
   return ComplexColumnVector (divide (data, a.data, len), len);
 }
 
 ComplexColumnVector&
 ComplexColumnVector::operator += (const ColumnVector& a)
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector += operation attempted");
+      return *this;
+    }
 
   if (len == 0)
     return *this;
 
   add2 (data, a.data, len);
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::operator -= (const ColumnVector& a)
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector -= operation attempted");
+      return *this;
+    }
 
   if (len == 0)
     return *this;
 
   subtract2 (data, a.data, len);
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::operator += (const ComplexColumnVector& a)
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector += operation attempted");
+      return *this;
+    }
 
   if (len == 0)
     return *this;
 
   add2 (data, a.data, len);
   return *this;
 }
 
 ComplexColumnVector&
 ComplexColumnVector::operator -= (const ComplexColumnVector& a)
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector -= operation attempted");
+      return *this;
+    }
 
   if (len == 0)
     return *this;
 
   subtract2 (data, a.data, len);
   return *this;
 }
 
diff --git a/liboctave/CollocWt.cc b/liboctave/CollocWt.cc
--- a/liboctave/CollocWt.cc
+++ b/liboctave/CollocWt.cc
@@ -23,33 +23,33 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #ifdef __GNUG__
 #pragma implementation
 #endif
 
 #include <iostream.h>
 #include "CollocWt.h"
 #include "f77-uscore.h"
+#include "lo-error.h"
 
 extern "C"
 {
   int F77_FCN (jcobi) (int*, int*, int*, int*, double*, double*,
 		       double*, double*, double*, double*); 
 
   int F77_FCN (dfopr) (int*, int*, int*, int*, int*, int*,
 		       double*, double*, double*, double*, double*);
 }
 
 // Error handling.
 
 void
 CollocWt::error (const char* msg)
 {
-  cerr << "Fatal CollocWt error. " << msg << "\n";
-  exit(1);
+  (*current_liboctave_error_handler) ("fatal CollocWt error: %s", msg);
 }
 
 CollocWt::CollocWt (void)
 {
   n = 0;
   inc_left = 0;
   inc_right = 0;
   lb = 0.0;
@@ -178,17 +178,20 @@ CollocWt::delete_left (void)
   initialized = 0;
   return *this;
 }
 
 CollocWt&
 CollocWt::set_left (double val)
 {
   if (val >= rb)
-    error ("left bound greater than right bound");
+    {
+      error ("left bound greater than right bound");
+      return *this;
+    }
 
   lb = val;
   initialized = 0;
   return *this;
 }
 
 CollocWt&
 CollocWt::add_right (void)
@@ -205,17 +208,20 @@ CollocWt::delete_right (void)
   initialized = 0;
   return *this;
 }
 
 CollocWt&
 CollocWt::set_right (double val)
 {
   if (val <= lb)
-    error ("right bound less than left bound");
+    {
+      error ("right bound less than left bound");
+      return *this;
+    }
 
   rb = val;
   initialized = 0;
   return *this;
 }
 
 CollocWt&
 CollocWt::set_alpha (double val)
@@ -235,21 +241,27 @@ CollocWt::set_beta (double val)
 
 void
 CollocWt::init (void)
 {
 // Check for possible errors.
 
   double wid = rb - lb;
   if (wid <= 0.0)
-    error ("width less than or equal to zero");
+    {
+      error ("width less than or equal to zero");
+      return;
+    }
 
   nt = n + inc_left + inc_right;
   if (nt < 0)
-    error ("total number of collocation points less than zero");
+    {
+      error ("total number of collocation points less than zero");
+      return;
+    }
   else if (nt == 0)
     return;
 
   double *dif1 = new double [nt];
   double *dif2 = new double [nt];
   double *dif3 = new double [nt];
   double *vect = new double [nt];
 
diff --git a/liboctave/DASSL.cc b/liboctave/DASSL.cc
--- a/liboctave/DASSL.cc
+++ b/liboctave/DASSL.cc
@@ -22,16 +22,17 @@ Software Foundation, 675 Mass Ave, Cambr
 */
 
 #ifdef __GNUG__
 #pragma implementation
 #endif
 
 #include <iostream.h>
 #include "DAE.h"
+#include "lo-error.h"
 
 extern "C"
 {
   int F77_FCN (ddassl) (int (*)(), const int*, double*, double*,
 			double*, double*, const int*, const double*,
 			const double*, int*, double*, const int*, 
 			int*, const int*, const double*, const int*,
 			int (*)());
@@ -120,18 +121,21 @@ DAE::DAE (Vector& state, double time, DA
   for (int i = 0; i < 15; i++)
     info [i] = 0;
 }
 
 DAE::DAE (Vector& state, Vector& deriv, double time, DAEFunc& f)
 {
   if (deriv.capacity () != state.capacity ())
     {
-      cerr << "x, xdot size mismatch in DAE constructor";
-      exit (1);
+      (*current_liboctave_error_handler)
+	("x, xdot size mismatch in DAE constructor");
+      n = 0;
+      t = 0.0;
+      return;
     }
 
   n = state.capacity ();
   t = time;
   xdot = deriv;
   x = state;
 
   absolute_tolerance = 1.0e-6;
diff --git a/liboctave/DiagMatrix.cc b/liboctave/DiagMatrix.cc
--- a/liboctave/DiagMatrix.cc
+++ b/liboctave/DiagMatrix.cc
@@ -25,70 +25,103 @@ Software Foundation, 675 Mass Ave, Cambr
 // several classes, each of which is defined in a separate file...
 //
 // #ifdef __GNUG__
 // #pragma implementation "Matrix.h"
 // #endif
 
 #include "Matrix.h"
 #include "mx-inlines.cc"
+#include "lo-error.h"
 
 /*
  * Diagonal Matrix class.
  */
 
 DiagMatrix::DiagMatrix (int n)
 {
   if (n < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create matrix with negative dimensions");
+      nr = 0;
+      nc = 0;
+      len = 0;
+      data = (double *) NULL;
+      return;
+    }
 
   nr = n;
   nc = n;
   len = n;
   if (len > 0)
     data = new double [len];
   else
     data = (double *) NULL;
 }
 
 DiagMatrix::DiagMatrix (int n, double val)
 {
   if (n < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create matrix with negative dimensions");
+      nr = 0;
+      nc = 0;
+      len = 0;
+      data = (double *) NULL;
+      return;
+    }
 
   nr = n;
   nc = n;
   len = n;
   if (len > 0)
     {
       data = new double [len];
       copy (data, len, val);
     }
   else
     data = (double *) NULL;
 }
 
 DiagMatrix::DiagMatrix (int r, int c)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create matrix with negative dimensions");
+      nr = 0;
+      nc = 0;
+      len = 0;
+      data = (double *) NULL;
+      return;
+    }
 
   nr = r;
   nc = c;
   len = r < c ? r : c;
   if (len > 0)
     data = new double [len];
   else
     data = (double *) NULL;
 }
 
 DiagMatrix::DiagMatrix (int r, int c, double val)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create matrix with negative dimensions");
+      nr = 0;
+      nc = 0;
+      len = 0;
+      data = (double *) NULL;
+      return;
+    }
 
   nr = r;
   nc = c;
   len = r < c ? r : c;
   if (len > 0)
     {
       data = new double [len];
       copy (data, len, val);
@@ -163,21 +196,54 @@ DiagMatrix::operator = (const DiagMatrix
 	  copy (data, a.data, len);
 	}
       else
 	data = (double *) NULL;
     }
   return *this;
 }
 
+double&
+DiagMatrix::checkelem (int r, int c)
+{
+#ifndef NO_RANGE_CHECK
+  if (r < 0 || r >= nr || c < 0 || c >= nc)
+    {
+      (*current_liboctave_error_handler) ("range error");
+      static double foo = 0.0;
+      return foo;
+    }
+#endif
+
+  return elem (r, c);
+}
+
+double
+DiagMatrix::checkelem (int r, int c) const
+{
+#ifndef NO_RANGE_CHECK
+  if (r < 0 || r >= nr || c < 0 || c >= nc)
+    {
+      (*current_liboctave_error_handler) ("range error");
+      return 0.0;
+    }
+#endif
+
+  return elem (r, c);
+}
+
 DiagMatrix&
 DiagMatrix::resize (int r, int c)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't resize to negative dimensions");
+      return *this;
+    }
 
   int new_len = r < c ? r : c;
   double *new_data = (double *) NULL;
   if (new_len > 0)
     {
       new_data = new double [new_len];
 
       int min_len = new_len < len ? new_len : len;
@@ -194,17 +260,21 @@ DiagMatrix::resize (int r, int c)
 
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::resize (int r, int c, double val)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't resize to negative dimensions");
+      return *this;
+    }
 
   int new_len = r < c ? r : c;
   double *new_data = (double *) NULL;
   if (new_len > 0)
     {
       new_data = new double [new_len];
 
       int min_len = new_len < len ? new_len : len;
@@ -249,58 +319,73 @@ DiagMatrix::fill (double val)
   copy (data, len, val);
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (double val, int beg, int end)
 {
   if (beg < 0 || end >= len || end < beg)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   if (end > beg)
     copy (data+beg, beg-end, val);
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (const ColumnVector& a)
 {
   if (a.len != len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   copy (data, a.data, len);
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (const RowVector& a)
 {
   if (a.len != len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   copy (data, a.data, len);
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (const ColumnVector& a, int beg)
 {
   if (beg < 0 || beg + a.len >= len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   copy (data+beg, a.data, a.len);
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::fill (const RowVector& a, int beg)
 {
   if (beg < 0 || beg + a.len >= len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   copy (data+beg, a.data, a.len);
   return *this;
 }
 
 DiagMatrix
 DiagMatrix::transpose (void) const
 {
@@ -326,73 +411,94 @@ DiagMatrix::extract (int r1, int c1, int
 }
 
 // extract row or column i.
 
 RowVector
 DiagMatrix::row (int i) const
 {
   if (i < 0 || i >= nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid row selection");
+      return RowVector (); 
+    }
 
   RowVector retval (nc, 0.0);
   if (nr <= nc || (nr > nc && i < nc))
     retval.data [i] = data[i];
 
   return retval;
 }
 
 RowVector
 DiagMatrix::row (char *s) const
 {
   if (s == (char *) NULL)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid row selection");
+      return RowVector (); 
+    }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return row (0);
   else if (c == 'l' || c == 'L')
     return row (nr - 1);
   else
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid row selection");
+      return RowVector (); 
+    }
 }
 
 ColumnVector
 DiagMatrix::column (int i) const
 {
   if (i < 0 || i >= nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid column selection");
+      return ColumnVector (); 
+    }
 
   ColumnVector retval (nr, 0.0);
   if (nr >= nc || (nr < nc && i < nr))
     retval.data [i] = data[i];
 
   return retval;
 }
 
 ColumnVector
 DiagMatrix::column (char *s) const
 {
   if (s == (char *) NULL)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid column selection");
+      return ColumnVector (); 
+    }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return column (0);
   else if (c == 'l' || c == 'L')
     return column (nc - 1);
   else
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid column selection");
+      return ColumnVector (); 
+    }
 }
 
 DiagMatrix
 DiagMatrix::inverse (int &info) const
 {
   if (nr != nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("inverse requires square matrix");
+      return DiagMatrix ();
+    }
 
   info = 0;
   double *tmp_data = dup (data, len);
   for (int i = 0; i < len; i++)
     {
       if (data[i] == 0.0)
 	{
 	  info = -1;
@@ -500,17 +606,21 @@ operator / (double s, const DiagMatrix& 
 }
 
 // diagonal matrix by column vector -> column vector operations
 
 ColumnVector
 DiagMatrix::operator * (const ColumnVector& a) const
 {
   if (nc != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return ColumnVector ();
+    }
 
   if (nc == 0 || nr == 0)
     return ColumnVector (0);
 
   ColumnVector result (nr);
 
   for (int i = 0; i < a.len; i++)
     result.data[i] = a.data[i] * data[i];
@@ -520,17 +630,21 @@ DiagMatrix::operator * (const ColumnVect
 
   return result;
 }
 
 ComplexColumnVector
 DiagMatrix::operator * (const ComplexColumnVector& a) const
 {
   if (nc != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return ColumnVector ();
+    }
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
   for (int i = 0; i < a.len; i++)
     result.data[i] = a.data[i] * data[i];
@@ -542,196 +656,256 @@ DiagMatrix::operator * (const ComplexCol
 }
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 DiagMatrix
 DiagMatrix::operator + (const DiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return DiagMatrix ();
+    }
 
   if (nc == 0 || nr == 0)
     return DiagMatrix (nr, nc);
 
   return DiagMatrix (add (data, a.data, len), nr , nc);
 }
 
 DiagMatrix
 DiagMatrix::operator - (const DiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return DiagMatrix ();
+    }
 
   if (nc == 0 || nr == 0)
     return DiagMatrix (nr, nc);
 
   return DiagMatrix (subtract (data, a.data, len), nr, nc);
 }
 
 DiagMatrix
 DiagMatrix::operator * (const DiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return DiagMatrix ();
+    }
 
   if (nc == 0 || nr == 0)
     return DiagMatrix (nr, nc);
 
   return DiagMatrix (multiply (data, a.data, len), nr, nc);
 }
 
 ComplexDiagMatrix
 DiagMatrix::operator + (const ComplexDiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return ComplexDiagMatrix ();
+    }
 
   if (nc == 0 || nr == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (add (data, a.data, len), nr , nc);
 }
 
 ComplexDiagMatrix
 DiagMatrix::operator - (const ComplexDiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return ComplexDiagMatrix ();
+    }
 
   if (nc == 0 || nr == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (subtract (data, a.data, len), nr, nc);
 }
 
 ComplexDiagMatrix
 DiagMatrix::operator * (const ComplexDiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return ComplexDiagMatrix ();
+    }
 
   if (nc == 0 || nr == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (multiply (data, a.data, len), nr, nc);
 }
 
 DiagMatrix
 DiagMatrix::product (const DiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix product attempted");
+      return DiagMatrix ();
+    }
 
   if (nc == 0 || nr == 0)
     return DiagMatrix (nr, nc);
 
   return DiagMatrix (multiply (data, a.data, len), nr, nc);
 }
 
 DiagMatrix
 DiagMatrix::quotient (const DiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix quotient attempted");
+      return DiagMatrix ();
+    }
 
   if (nc == 0 || nr == 0)
     return DiagMatrix (nr, nc);
 
   return DiagMatrix (divide (data, a.data, len), nr, nc);
 }
 
 ComplexDiagMatrix
 DiagMatrix::product (const ComplexDiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix product attempted");
+      return ComplexDiagMatrix ();
+    }
 
   if (nc == 0 || nr == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (multiply (data, a.data, len), nr, nc);
 }
 
 ComplexDiagMatrix
 DiagMatrix::quotient (const ComplexDiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix quotient attempted");
+      return ComplexDiagMatrix ();
+    }
 
   if (nc == 0 || nr == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (divide (data, a.data, len), nr, nc);
 }
 
 DiagMatrix&
 DiagMatrix::operator += (const DiagMatrix& a)
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return *this;
+    }
 
   if (nc == 0 || nr == 0)
     return *this;
 
   add2 (data, a.data, len);
   return *this;
 }
 
 DiagMatrix&
 DiagMatrix::operator -= (const DiagMatrix& a)
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix -= operation attempted");
+      return *this;
+    }
 
   if (nr == 0 || nc == 0)
 
   subtract2 (data, a.data, len);
   return *this;
 }
 
 // diagonal matrix by matrix -> matrix operations
 
 Matrix
 DiagMatrix::operator + (const Matrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return Matrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return Matrix (nr, nc);
 
   Matrix result (a);
   for (int i = 0; i < len; i++)
     result.elem (i, i) += data[i];
 
   return result;
 }
 
 Matrix
 DiagMatrix::operator - (const Matrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return Matrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return Matrix (nr, nc);
 
   Matrix result (-a);
   for (int i = 0; i < len; i++)
     result.elem (i, i) += data[i];
 
   return result;
 }
 
 Matrix
 DiagMatrix::operator * (const Matrix& a) const
 {
   if (nc != a.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return Matrix ();
+    }
 
   if (nr == 0 || nc == 0 || a.nc == 0)
     return Matrix (nr, a.nc, 0.0);
 
   Matrix c (nr, a.nc);
 
   for (int i = 0; i < len; i++)
     {
@@ -761,49 +935,61 @@ DiagMatrix::operator * (const Matrix& a)
 
   return c;
 }
 
 ComplexMatrix
 DiagMatrix::operator + (const ComplexMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   ComplexMatrix result (a);
   for (int i = 0; i < len; i++)
     result.elem (i, i) += data[i];
 
   return result;
 }
 
 ComplexMatrix
 DiagMatrix::operator - (const ComplexMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   ComplexMatrix result (-a);
   for (int i = 0; i < len; i++)
     result.elem (i, i) += data[i];
 
   return result;
 }
 
 ComplexMatrix
 DiagMatrix::operator * (const ComplexMatrix& a) const
 {
   if (nc != a.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0 || a.nc == 0)
     return ComplexMatrix (nr, nc, 0.0);
 
   ComplexMatrix c (nr, a.nc);
 
   for (int i = 0; i < len; i++)
     {
@@ -911,96 +1097,144 @@ operator << (ostream& os, const DiagMatr
 
 /*
  * Complex Diagonal Matrix class
  */
 
 ComplexDiagMatrix::ComplexDiagMatrix (int n)
 {
   if (n < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create matrix with negative dimensions");
+      nr = 0;
+      nc = 0;
+      len = 0;
+      data = (Complex *) NULL;
+      return;
+    }
 
   nr = n;
   nc = n;
   len = n;
   if (len > 0)
     data = new Complex [len];
   else
     data = (Complex *) NULL;
 }
 
 ComplexDiagMatrix::ComplexDiagMatrix (int n, double val)
 {
   if (n < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create matrix with negative dimensions");
+      nr = 0;
+      nc = 0;
+      len = 0;
+      data = (Complex *) NULL;
+      return;
+    }
 
   nr = n;
   nc = n;
   len = n;
   if (len > 0)
     {
       data = new Complex [len];
       copy (data, len, val);
     }
   else
     data = (Complex *) NULL;
 }
 
 ComplexDiagMatrix::ComplexDiagMatrix (int n, const Complex& val)
 {
   if (n < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create matrix with negative dimensions");
+      nr = 0;
+      nc = 0;
+      len = 0;
+      data = (Complex *) NULL;
+      return;
+    }
 
   nr = n;
   nc = n;
   len = n;
   if (len > 0)
     {
       data = new Complex [len];
       copy (data, len, val);
     }
   else
     data = (Complex *) NULL;
 }
 
 ComplexDiagMatrix::ComplexDiagMatrix (int r, int c)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create matrix with negative dimensions");
+      nr = 0;
+      nc = 0;
+      len = 0;
+      data = (Complex *) NULL;
+      return;
+    }
 
   nr = r;
   nc = c;
   len = r < c ? r : c;
   if (len > 0)
     data = new Complex [len];
   else
     data = (Complex *) NULL;
 }
 
 ComplexDiagMatrix::ComplexDiagMatrix (int r, int c, double val)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create matrix with negative dimensions");
+      nr = 0;
+      nc = 0;
+      len = 0;
+      data = (Complex *) NULL;
+      return;
+    }
 
   nr = r;
   nc = c;
   len = r < c ? r : c;
   if (len > 0)
     {
       data = new Complex [len];
       copy (data, len, val);
     }
   else
     data = (Complex *) NULL;
 }
 
 ComplexDiagMatrix::ComplexDiagMatrix (int r, int c, const Complex& val)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create matrix with negative dimensions");
+      nr = 0;
+      nc = 0;
+      len = 0;
+      data = (Complex *) NULL;
+      return;
+    }
 
   nr = r;
   nc = c;
   len = r < c ? r : c;
   if (len > 0)
     {
       data = new Complex [len];
       copy (data, len, val);
@@ -1144,21 +1378,54 @@ ComplexDiagMatrix::operator = (const Com
 	  copy (data, a.data, len);
 	}
       else
 	data = (Complex *) NULL;
     }
   return *this;
 }
 
+Complex&
+ComplexDiagMatrix::checkelem (int r, int c)
+{
+#ifndef NO_RANGE_CHECK
+  if (r < 0 || r >= nr || c < 0 || c >= nc)
+    {
+      (*current_liboctave_error_handler) ("range error");
+      static Complex foo (0.0);
+      return foo;
+    }
+#endif
+
+  return elem (r, c);
+}
+
+Complex
+ComplexDiagMatrix::checkelem (int r, int c) const
+{
+#ifndef NO_RANGE_CHECK
+  if (r < 0 || r >= nr || c < 0 || c >= nc)
+    {
+      (*current_liboctave_error_handler) ("range error");
+      return Complex (0.0);
+    }
+#endif
+
+  return elem (r, c);
+}
+
 ComplexDiagMatrix&
 ComplexDiagMatrix::resize (int r, int c)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't resize to negative dimensions");
+      return *this;
+    }
 
   int new_len = r < c ? r : c;
   Complex *new_data = (Complex *) NULL;
   if (new_len > 0)
     {
       new_data = new Complex [new_len];
 
       int min_len = new_len < len ? new_len : len;
@@ -1175,17 +1442,21 @@ ComplexDiagMatrix::resize (int r, int c)
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::resize (int r, int c, double val)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't resize to negative dimensions");
+      return *this;
+    }
 
   int new_len = r < c ? r : c;
   Complex *new_data = (Complex *) NULL;
   if (new_len > 0)
     {
       new_data = new Complex [new_len];
 
       int min_len = new_len < len ? new_len : len;
@@ -1205,17 +1476,21 @@ ComplexDiagMatrix::resize (int r, int c,
 
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::resize (int r, int c, const Complex& val)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't resize to negative dimensions");
+      return *this;
+    }
 
   int new_len = r < c ? r : c;
   Complex *new_data = (Complex *) NULL;
   if (new_len > 0)
     {
       new_data = new Complex [new_len];
 
       int min_len = new_len < len ? new_len : len;
@@ -1273,109 +1548,139 @@ ComplexDiagMatrix::fill (const Complex& 
   copy (data, len, val);
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (double val, int beg, int end)
 {
   if (beg < 0 || end >= len || end < beg)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   if (end > beg)
     copy (data+beg, beg-end, val);
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const Complex& val, int beg, int end)
 {
   if (beg < 0 || end >= len || end < beg)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   if (end > beg)
     copy (data+beg, beg-end, val);
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ColumnVector& a)
 {
   if (a.len != len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   copy (data, a.data, len);
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ComplexColumnVector& a)
 {
   if (a.len != len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   copy (data, a.data, len);
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const RowVector& a)
 {
   if (a.len != len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   copy (data, a.data, len);
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ComplexRowVector& a)
 {
   if (a.len != len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   copy (data, a.data, len);
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ColumnVector& a, int beg)
 {
   if (beg < 0 || beg + a.len >= len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   copy (data+beg, a.data, a.len);
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ComplexColumnVector& a, int beg)
 {
   if (beg < 0 || beg + a.len >= len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   copy (data+beg, a.data, a.len);
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const RowVector& a, int beg)
 {
   if (beg < 0 || beg + a.len >= len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   copy (data+beg, a.data, a.len);
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::fill (const ComplexRowVector& a, int beg)
 {
   if (beg < 0 || beg + a.len >= len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   copy (data+beg, a.data, a.len);
   return *this;
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::transpose (void) const
 {
@@ -1430,73 +1735,94 @@ ComplexDiagMatrix::extract (int r1, int 
 }
 
 // extract row or column i.
 
 ComplexRowVector
 ComplexDiagMatrix::row (int i) const
 {
   if (i < 0 || i >= nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid row selection");
+      return RowVector (); 
+    }
 
   ComplexRowVector retval (nc, 0.0);
   if (nr <= nc || (nr > nc && i < nc))
     retval.data [i] = data[i];
 
   return retval;
 }
 
 ComplexRowVector
 ComplexDiagMatrix::row (char *s) const
 {
   if (s == (char *) NULL)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid row selection");
+      return ComplexRowVector (); 
+    }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return row (0);
   else if (c == 'l' || c == 'L')
     return row (nr - 1);
   else
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid row selection");
+      return ComplexRowVector ();
+    }
 }
 
 ComplexColumnVector
 ComplexDiagMatrix::column (int i) const
 {
   if (i < 0 || i >= nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid column selection");
+      return ColumnVector (); 
+    }
 
   ComplexColumnVector retval (nr, 0.0);
   if (nr >= nc || (nr < nc && i < nr))
     retval.data [i] = data[i];
 
   return retval;
 }
 
 ComplexColumnVector
 ComplexDiagMatrix::column (char *s) const
 {
   if (s == (char *) NULL)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid column selection");
+      return ColumnVector (); 
+    }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return column (0);
   else if (c == 'l' || c == 'L')
     return column (nc - 1);
   else
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid column selection");
+      return ColumnVector (); 
+    }
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::inverse (int& info) const
 {
   if (nr != nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("inverse requires square matrix");
+      return DiagMatrix ();
+    }
 
   info = 0;
   for (int i = 0; i < len; i++)
     {
       if (data[i] == 0.0)
 	{
 	  info = -1;
 	  return *this;
@@ -1624,17 +1950,21 @@ operator / (const Complex& s, const Comp
 }
 
 // diagonal matrix by column vector -> column vector operations
 
 ComplexColumnVector
 ComplexDiagMatrix::operator * (const ColumnVector& a) const
 {
   if (nc != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix muliplication attempted");
+      return ComplexColumnVector ();
+    }
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
   for (int i = 0; i < a.len; i++)
     result.data[i] = a.data[i] * data[i];
@@ -1644,17 +1974,21 @@ ComplexDiagMatrix::operator * (const Col
 
   return result;
 }
 
 ComplexColumnVector
 ComplexDiagMatrix::operator * (const ComplexColumnVector& a) const
 {
   if (nc != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix muliplication attempted");
+      return ComplexColumnVector ();
+    }
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   ComplexColumnVector result (nr);
 
   for (int i = 0; i < a.len; i++)
     result.data[i] = a.data[i] * data[i];
@@ -1666,223 +2000,291 @@ ComplexDiagMatrix::operator * (const Com
 }
 
 // diagonal matrix by diagonal matrix -> diagonal matrix operations
 
 ComplexDiagMatrix
 ComplexDiagMatrix::operator + (const DiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return ComplexDiagMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (add (data, a.data, len), nr , nc);
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::operator - (const DiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return ComplexDiagMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (subtract (data, a.data, len), nr, nc);
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::operator * (const DiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return ComplexDiagMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (multiply (data, a.data, len), nr, nc);
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::operator + (const ComplexDiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return ComplexDiagMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (add (data, a.data, len), nr , nc);
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::operator - (const ComplexDiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return ComplexDiagMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (subtract (data, a.data, len), nr, nc);
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::operator * (const ComplexDiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return ComplexDiagMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (multiply (data, a.data, len), nr, nc);
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::product (const DiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix product attempted");
+      return ComplexDiagMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (multiply (data, a.data, len), nr, nc);
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::quotient (const DiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix quotient attempted");
+      return ComplexDiagMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (divide (data, a.data, len), nr, nc);
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::product (const ComplexDiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix product attempted");
+      return ComplexDiagMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (multiply (data, a.data, len), nr, nc);
 }
 
 ComplexDiagMatrix
 ComplexDiagMatrix::quotient (const ComplexDiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix quotient attempted");
+      return ComplexDiagMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexDiagMatrix (nr, nc);
 
   return ComplexDiagMatrix (divide (data, a.data, len), nr, nc);
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::operator += (const DiagMatrix& a)
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return *this;
+    }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   add2 (data, a.data, len);
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::operator -= (const DiagMatrix& a)
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix -= operation attempted");
+      return *this;
+    }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   subtract2 (data, a.data, len);
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::operator += (const ComplexDiagMatrix& a)
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return *this;
+    }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   add2 (data, a.data, len);
   return *this;
 }
 
 ComplexDiagMatrix&
 ComplexDiagMatrix::operator -= (const ComplexDiagMatrix& a)
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix -= operation attempted");
+      return *this;
+    }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   subtract2 (data, a.data, len);
   return *this;
 }
 
 // diagonal matrix by matrix -> matrix operations
 
 ComplexMatrix
 ComplexDiagMatrix::operator + (const Matrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   ComplexMatrix result (a);
   for (int i = 0; i < len; i++)
     result.elem (i, i) += data[i];
 
   return result;
 }
 
 ComplexMatrix
 ComplexDiagMatrix::operator - (const Matrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   ComplexMatrix result (-a);
   for (int i = 0; i < len; i++)
     result.elem (i, i) += data[i];
 
   return result;
 }
 
 ComplexMatrix
 ComplexDiagMatrix::operator * (const Matrix& a) const
 {
   if (nc != a.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0 || a.nc == 0)
     return ComplexMatrix (nr, a.nc, 0.0);
 
   ComplexMatrix c (nr, a.nc);
 
   for (int i = 0; i < len; i++)
     {
@@ -1912,49 +2314,61 @@ ComplexDiagMatrix::operator * (const Mat
 
   return c;
 }
 
 ComplexMatrix
 ComplexDiagMatrix::operator + (const ComplexMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   ComplexMatrix result (a);
   for (int i = 0; i < len; i++)
     result.elem (i, i) += data[i];
 
   return result;
 }
 
 ComplexMatrix
 ComplexDiagMatrix::operator - (const ComplexMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   ComplexMatrix result (-a);
   for (int i = 0; i < len; i++)
     result.elem (i, i) += data[i];
 
   return result;
 }
 
 ComplexMatrix
 ComplexDiagMatrix::operator * (const ComplexMatrix& a) const
 {
   if (nc != a.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0 || a.nc == 0)
     return ComplexMatrix (nr, a.nc, 0.0);
 
   ComplexMatrix c (nr, a.nc);
 
   for (int i = 0; i < len; i++)
     {
diff --git a/liboctave/FEGrid.cc b/liboctave/FEGrid.cc
--- a/liboctave/FEGrid.cc
+++ b/liboctave/FEGrid.cc
@@ -21,90 +21,108 @@ Software Foundation, 675 Mass Ave, Cambr
 
 */
 
 #ifdef __GNUG__
 #pragma implementation
 #endif
 
 #include "FEGrid.h"
+#include "lo-error.h"
 
 // error handling
 
 void
 FEGrid::error (const char* msg) const
 {
-  cerr << "Fatal FEGrid error. " << msg << "\n";
-  exit(1);
+  (*current_liboctave_error_handler) ("fatal FEGrid error: %s", msg);
 }
 
 void
 FEGrid::nel_error (void) const
 {
   error ("number of elements less than 1");
 }
 
 // Constructors
 
 FEGrid::FEGrid (int nel, double width)
 {
   if (nel < 1)
-    nel_error ();
+    {
+      nel_error ();
+      return;
+    }
 
   elem.resize (nel+1);
 
   for (int i = 0; i <= nel; i++)
     elem.elem (i) = i * width;
 }
 
 FEGrid::FEGrid (int nel, double left, double right)
 {
   if (nel < 1)
-    nel_error ();
+    {
+      nel_error ();
+      return;
+    }
 
   elem.resize (nel+1);
 
   double width = (right - left) / (double) nel;
 
   for (int i = 0; i <= nel; i++)
     elem.elem (i) = i * width + left;
 
   check_grid ();
 }
 
 int
 FEGrid::element (double x) const
 {
   if (! in_bounds (x))
-    error ("value not within grid boundaries");
+    {
+      error ("value not within grid boundaries");
+      return -1;
+    }
 
   int nel = elem.capacity () - 1;
   for (int i = 1; i <= nel; i++)
     {
       if (x >= elem.elem (i-1) && x <= elem.elem (i))
 	return i;
     }
   return -1;
        
 }
 
 void
 FEGrid::check_grid (void) const
 {
   int nel = elem.capacity () - 1;
   if (nel < 1)
-    nel_error ();
+    {
+      nel_error ();
+      return;
+    }
 
   for (int i = 1; i <= nel; i++)
     {
       if (elem.elem (i-1) > elem.elem (i))
-	error ("element boundaries not in ascending order");
+	{
+	  error ("element boundaries not in ascending order");
+	  return;
+	}
 
       if (elem.elem (i-1) == elem.elem (i))
-	error ("zero width element");
+	{
+	  error ("zero width element");
+	  return;
+	}
     }
 }
 
 ostream&
 operator << (ostream& s, const FEGrid& g)
 {
   s << g.element_boundaries ();
   return s;
diff --git a/liboctave/LSODE.cc b/liboctave/LSODE.cc
--- a/liboctave/LSODE.cc
+++ b/liboctave/LSODE.cc
@@ -23,16 +23,17 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #ifdef __GNUG__
 #pragma implementation
 #endif
 
 #include <iostream.h>
 #include "ODE.h"
 #include "f77-uscore.h"
+#include "lo-error.h"
 
 extern "C"
 {
   int F77_FCN (lsode) (int (*)(), int *, double *, double *, double *,
 		       int *, double *, double *, int *, int *, int *,
 		       double *, int *, int *, int *, int (*)(), int *);
 }
 
@@ -247,18 +248,20 @@ ODE::integrate (double tout)
     case -3: // illegal input detected (see printed message).
       break;
     case -2: // excess accuracy requested (tolerances too small).
       break;
     case -1: // excess work done on this call (perhaps wrong mf).
       working_too_hard++;
       if (working_too_hard > 20)
 	{
-	  cerr << "Shut 'er down Slim!  She's a suckin' mud!\n";
-	  exit (1);
+	  (*current_liboctave_error_handler)
+	    ("giving up after more than %d steps attempted in lsode",
+	     iwork[5] * 20);
+	  return ColumnVector ();
 	}
       else
 	{
 	  istate = 2;
 	  goto again;
 	}
       break;
     case 2: // lsode was successful
diff --git a/liboctave/LinConst.cc b/liboctave/LinConst.cc
--- a/liboctave/LinConst.cc
+++ b/liboctave/LinConst.cc
@@ -22,24 +22,24 @@ Software Foundation, 675 Mass Ave, Cambr
 */
 
 #ifdef __GNUG__
 #pragma implementation
 #endif
 
 #include <iostream.h>
 #include "LinConst.h"
+#include "lo-error.h"
 
 // error handling
 
 void
 LinConst::error (const char* msg)
 {
-  cerr << "Fatal LinConst error. " << msg << "\n";
-  exit(1);
+  (*current_liboctave_error_handler) ("fatal LinConst error: %s", msg);
 }
 
 LinConst::LinConst (const Matrix& a_eq, const Vector& b_eq,
 		    const Matrix& a_ineq, const Vector& b_ineq)
 {
 // Need some checks here.
 
   int nc_eq = b_eq.capacity ();
diff --git a/liboctave/Matrix-ext.cc b/liboctave/Matrix-ext.cc
--- a/liboctave/Matrix-ext.cc
+++ b/liboctave/Matrix-ext.cc
@@ -22,26 +22,30 @@ Software Foundation, 675 Mass Ave, Cambr
 */
 
 #ifdef __GNUG__
 #pragma implementation
 #endif
 
 #include "Matrix.h"
 #include "mx-inlines.cc"
+#include "lo-error.h"
 
 /*
  * AEPBALANCE operations
  */
 
 int
 AEPBALANCE::init (const Matrix& a, const char *balance_job)
 {
   if (a.nr != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("AEPBALANCE requires square matrix");
+      return -1;
+    }
 
   int n = a.nc;
 
 // Parameters for balance call.
 
   int info;
   int ilo;
   int ihi;
@@ -105,17 +109,21 @@ ComplexAEPBALANCE::init (const ComplexMa
 /*
  * GEPBALANCE operations
  */
 
 int
 GEPBALANCE::init (const Matrix& a, const Matrix& b, const char *balance_job)
 {
   if (a.nr != a.nc || a.nr != b.nr || b.nr != b.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("GEPBALANCE requires square matrices of the same size");
+      return -1;
+    }
 
   int n = a.nc;
 
 // Parameters for balance call.
 
   int info;
   int ilo;
   int ihi;
@@ -231,17 +239,20 @@ GEPBALANCE::init (const Matrix& a, const
 /*
  * CHOL stuff
  */
 
 int
 CHOL::init (const Matrix& a)
 {
   if (a.nr != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("CHOL requires square matrix");
+      return -1;
+    }
 
   char uplo = 'U';
 
   int n = a.nc;
   int info;
 
   double *h = dup (a.data, a.len);
 
@@ -261,17 +272,21 @@ CHOL::init (const Matrix& a)
   return info;
 }
 
 
 int
 ComplexCHOL::init (const ComplexMatrix& a)
 {
    if (a.nr != a.nc)
-     FAIL;
+     {
+       (*current_liboctave_error_handler)
+	 ("ComplexCHOL requires square matrix");
+       return -1;
+     }
 
    char uplo = 'U';
 
    int n = a.nc;
    int info;
 
    Complex *h = dup (a.data, a.len);
 
@@ -294,17 +309,20 @@ ComplexCHOL::init (const ComplexMatrix& 
 /*
  * HESS stuff
  */
 
 int
 HESS::init (const Matrix& a)
 {
   if (a.nr != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("HESS requires square matrix");
+      return -1;
+    }
 
   char jobbal = 'N';
   char side = 'R';
 
   int n = a.nc;
   int lwork = 32 * n;
   int info;
   int ilo;
@@ -352,17 +370,21 @@ HESS::init (const Matrix& a)
   return info;
 }
 
 
 int
 ComplexHESS::init (const ComplexMatrix& a)
 {
    if (a.nr != a.nc)
-     FAIL;
+     {
+       (*current_liboctave_error_handler)
+	 ("ComplexHESS requires square matrix");
+       return -1;
+     }
 
    char job = 'N';
    char side = 'R';
 
    int n = a.nc;
    int lwork = 32 * n;
    int info;
    int ilo;
@@ -424,17 +446,20 @@ select_dig (double *a, double *b)
 
 // GAG.
 extern "C" { static int (*dummy_select)(); }
 
 int
 SCHUR::init (const Matrix& a, const char *ord)
 {
   if (a.nr != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("SCHUR requires square matrix");
+      return -1;
+    }
 
   char jobvs = 'V';
   char sort;
 
   if (*ord == 'A' || *ord == 'D' || *ord == 'a' || *ord == 'd')
     sort = 'S';
   else
     sort = 'N';
@@ -511,17 +536,21 @@ complex_select_dig (Complex *a)
 {
   return (abs (*a) < 1.0);
 }
 
 int
 ComplexSCHUR::init (const ComplexMatrix& a, const char *ord)
 {
   if (a.nr != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("ComplexSCHUR requires square matrix");
+      return -1;
+    }
 
   char jobvs = 'V';
   char sort;
   if (*ord == 'A' || *ord == 'D' || *ord == 'a' || *ord == 'd')
      sort = 'S';
    else
      sort = 'N';
 
@@ -683,17 +712,20 @@ ComplexSVD::init (const ComplexMatrix& a
 /*
  * EIG stuff.
  */
 
 int
 EIG::init (const Matrix& a)
 {
   if (a.nr != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("EIG requires square matrix");
+      return -1;
+    }
 
   int n = a.nr;
 
   int info;
 
   char jobvl = 'N';
   char jobvr = 'V';
 
@@ -720,17 +752,20 @@ EIG::init (const Matrix& a)
 	{
 	  lambda.elem (j) = Complex (wr[j]);
 	  for (int i = 0; i < n; i++)
 	    v.elem (i, j) = vr.elem (i, j);
 	}
       else
 	{
 	  if (j+1 >= n)
-	    FAIL;
+	    {
+	      (*current_liboctave_error_handler) ("EIG: internal error");
+	      return -1;
+	    }
 
 	  for (int i = 0; i < n; i++)
 	    {
 	      lambda.elem (j) = Complex (wr[j], wi[j]);
 	      lambda.elem (j+1) = Complex (wr[j+1], wi[j+1]);
 	      double real_part = vr.elem (i, j);
 	      double imag_part = vr.elem (i, j+1);
 	      v.elem (i, j) = Complex (real_part, imag_part);
@@ -748,17 +783,20 @@ EIG::init (const Matrix& a)
   return info;
 }
 
 int
 EIG::init (const ComplexMatrix& a)
 {
 
   if (a.nr != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("EIG requires square matrix");
+      return -1;
+    }
 
   int n = a.nr;
 
   int info;
 
   char jobvl = 'N';
   char jobvr = 'V';
 
@@ -790,17 +828,20 @@ EIG::init (const ComplexMatrix& a)
 
 /*
  * LU stuff.
  */
 
 LU::LU (const Matrix& a)
 {
   if (a.nr == 0 || a.nc == 0 || a.nr != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("LU requires square matrix");
+      return;
+    }
 
   int n = a.nr;
 
   int *ipvt = new int [n];
   int *pvt = new int [n];
   double *tmp_data = dup (a.data, a.len);
   int info = 0;
   int zero = 0;
@@ -849,17 +890,20 @@ LU::LU (const Matrix& a)
 
   delete [] ipvt;
   delete [] pvt;
 }
 
 ComplexLU::ComplexLU (const ComplexMatrix& a)
 {
   if (a.nr == 0 || a.nc == 0 || a.nr != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("ComplexLU requires square matrix");
+      return;
+    }
 
   int n = a.nr;
 
   int *ipvt = new int [n];
   int *pvt = new int [n];
   Complex *tmp_data = dup (a.data, a.len);
   int info = 0;
   int zero = 0;
@@ -915,17 +959,20 @@ ComplexLU::ComplexLU (const ComplexMatri
  */
 
 QR::QR (const Matrix& a)
 {
   int m = a.nr;
   int n = a.nc;
 
   if (m == 0 || n == 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("QR must have non-empty matrix");
+      return;
+    }
 
   double *tmp_data;
   int min_mn = m < n ? m : n;
   double *tau = new double[min_mn];
   int lwork = 32*n;
   double *work = new double[lwork];
   int info = 0;
 
@@ -961,17 +1008,21 @@ QR::QR (const Matrix& a)
 }
 
 ComplexQR::ComplexQR (const ComplexMatrix& a)
 {
   int m = a.nr;
   int n = a.nc;
 
   if (m == 0 || n == 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("ComplexQR must have non-empty matrix");
+      return;
+    }
 
   Complex *tmp_data;
   int min_mn = m < n ? m : n;
   Complex *tau = new Complex[min_mn];
   int lwork = 32*n;
   Complex *work = new Complex[lwork];
   int info = 0;
 
diff --git a/liboctave/Matrix.cc b/liboctave/Matrix.cc
--- a/liboctave/Matrix.cc
+++ b/liboctave/Matrix.cc
@@ -25,39 +25,56 @@ Software Foundation, 675 Mass Ave, Cambr
 // several classes, each of which is defined in a separate file...
 //
 // #ifdef __GNUG__
 // #pragma implementation
 // #endif
 
 #include "Matrix.h"
 #include "mx-inlines.cc"
+#include "lo-error.h"
 
 /*
  * Matrix class.
  */
 
 Matrix::Matrix (int r, int c)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't construct matrix with negative dimensions");
+      nr = 0;
+      nc = 0;
+      len = 0;
+      data = (double *) NULL;
+      return;
+    }
 
   nr = r;
   nc = c;
   len = nr * nc;
   if (len > 0)
     data = new double [len];
   else
     data = (double *) NULL;
 }
 
 Matrix::Matrix (int r, int c, double val)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't construct matrix with negative dimensions");
+      nr = 0;
+      nc = 0;
+      len = 0;
+      data = (double *) NULL;
+      return;
+    }
 
   nr = r;
   nc = c;
   len = nr * nc;
   if (len > 0)
     {
       data = new double [len];
       copy (data, len, val);
@@ -120,21 +137,54 @@ Matrix::operator = (const Matrix& a)
 	  copy (data, a.data, len);
 	}
       else
 	data = (double *) NULL;
     }
   return *this;
 }
 
+double&
+Matrix::checkelem (int r, int c)
+{
+#ifndef NO_RANGE_CHECK
+  if (r < 0 || r >= nr || c < 0 || c >= nc)
+    {
+      (*current_liboctave_error_handler) ("range error");
+      static double foo = 0.0;
+      return foo;
+    }
+#endif
+
+  return elem (r, c);
+}
+
+double
+Matrix::checkelem (int r, int c) const
+{
+#ifndef NO_RANGE_CHECK
+  if (r < 0 || r >= nr || c < 0 || c >= nc)
+    {
+      (*current_liboctave_error_handler) ("range error");
+      return 0.0;
+    }
+#endif
+
+  return elem (r, c);
+}
+
 Matrix&
 Matrix::resize (int r, int c)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't resize to negative dimensions");
+      return *this;
+    }
 
   int new_len = r * c;
   double* new_data = (double *) NULL;
   if (new_len > 0)
     {
       new_data = new double [new_len];
 
       int min_r = nr < r ? nr : r;
@@ -153,17 +203,21 @@ Matrix::resize (int r, int c)
 
   return *this;
 }
 
 Matrix&
 Matrix::resize (int r, int c, double val)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't resize to negative dimensions");
+      return *this;
+    }
 
   int new_len = r * c;
   double *new_data = (double *) NULL;
   if (new_len > 0)
     {
       new_data = new double [new_len];
 
 // There may be faster or cleaner ways to do this.
@@ -202,54 +256,66 @@ Matrix::operator != (const Matrix& a) co
 {
   return !(*this == a);
 }
 
 Matrix&
 Matrix::insert (const Matrix& a, int r, int c)
 {
   if (r < 0 || r + a.nr - 1 > nr || c < 0 || c + a.nc - 1 > nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for insert");
+      return *this;
+    }
 
   for (int j = 0; j < a.nc; j++)
     for (int i = 0; i < a.nr; i++)
       elem (r+i, c+j) = a.elem (i, j);
 
   return *this;
 }
 
 Matrix&
 Matrix::insert (const RowVector& a, int r, int c)
 {
   if (r < 0 || r >= nr || c < 0 || c + a.len - 1 > nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for insert");
+      return *this;
+    }
 
   for (int i = 0; i < a.len; i++)
     elem (r, c+i) = a.data[i];
 
   return *this;
 }
 
 Matrix&
 Matrix::insert (const ColumnVector& a, int r, int c)
 {
   if (r < 0 || r + a.len - 1 > nr || c < 0 || c >= nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for insert");
+      return *this;
+    }
 
   for (int i = 0; i < a.len; i++)
     elem (r+i, c) = a.data[i];
 
   return *this;
 }
 
 Matrix&
 Matrix::insert (const DiagMatrix& a, int r, int c)
 {
   if (r < 0 || r + a.nr - 1 > nr || c < 0 || c + a.nc - 1 > nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for insert");
+      return *this;
+    }
 
   for (int i = 0; i < a.len; i++)
     elem (r+i, c+i) = a.data[i];
 
   return *this;
 }
 
 Matrix&
@@ -260,124 +326,155 @@ Matrix::fill (double val)
   return *this;
 }
 
 Matrix&
 Matrix::fill (double val, int r1, int c1, int r2, int c2)
 {
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
 
   for (int j = c1; j <= c2; j++)
     for (int i = r1; i <= r2; i++)
       elem (i, j) = val;
 
   return *this;
 }
 
 Matrix
 Matrix::append (const Matrix& a) const
 {
   if (nr != a.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("row dimension mismatch for append");
+      return Matrix ();
+    }
 
   int nc_insert = nc;
   Matrix retval (nr, nc + a.nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
-  return retval;;
+  return retval;
 }
 
 Matrix
 Matrix::append (const RowVector& a) const
 {
   if (nr != 1)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("row dimension mismatch for append");
+      return Matrix ();
+    }
 
   int nc_insert = nc;
   Matrix retval (nr, nc + a.len);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 Matrix
 Matrix::append (const ColumnVector& a) const
 {
   if (nr != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("row dimension mismatch for append");
+      return Matrix ();
+    }
 
   int nc_insert = nc;
   Matrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 Matrix
 Matrix::append (const DiagMatrix& a) const
 {
   if (nr != a.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("row dimension mismatch for append");
+      return *this;
+    }
 
   int nc_insert = nc;
   Matrix retval (nr, nc + a.nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 Matrix
 Matrix::stack (const Matrix& a) const
 {
   if (nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("column dimension mismatch for stack");
+      return Matrix ();
+    }
 
   int nr_insert = nr;
   Matrix retval (nr + a.nr, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 Matrix
 Matrix::stack (const RowVector& a) const
 {
   if (nc != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("column dimension mismatch for stack");
+      return Matrix ();
+    }
 
   int nr_insert = nr;
   Matrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 Matrix
 Matrix::stack (const ColumnVector& a) const
 {
   if (nc != 1)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("column dimension mismatch for stack");
+      return Matrix ();
+    }
 
   int nr_insert = nr;
   Matrix retval (nr + a.len, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 Matrix
 Matrix::stack (const DiagMatrix& a) const
 {
   if (nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("column dimension mismatch for stack");
+      return Matrix ();
+    }
 
   int nr_insert = nr;
   Matrix retval (nr + a.nr, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
@@ -413,73 +510,94 @@ Matrix::extract (int r1, int c1, int r2,
 }
 
 // extract row or column i.
 
 RowVector
 Matrix::row (int i) const
 {
   if (i < 0 || i >= nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid row selection");
+      return RowVector ();
+    }
 
   RowVector retval (nc);
   for (int j = 0; j < nc; j++)
     retval.elem (j) = elem (i, j);
 
   return retval;
 }
 
 RowVector
 Matrix::row (char *s) const
 {
   if (s == (char *) NULL)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid row selection");
+      return RowVector ();
+    }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return row (0);
   else if (c == 'l' || c == 'L')
     return row (nr - 1);
   else
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid row selection");
+      return RowVector ();
+    }
 }
 
 ColumnVector
 Matrix::column (int i) const
 {
   if (i < 0 || i >= nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid column selection");
+      return ColumnVector ();
+    }
 
   ColumnVector retval (nr);
   for (int j = 0; j < nr; j++)
     retval.elem (j) = elem (j, i);
 
   return retval;
 }
 
 ColumnVector
 Matrix::column (char *s) const
 {
   if (s == (char *) NULL)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid column selection");
+      return ColumnVector ();
+    }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return column (0);
   else if (c == 'l' || c == 'L')
     return column (nc - 1);
   else
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid column selection");
+      return ColumnVector ();
+    }
 }
 
 Matrix
 Matrix::inverse (int& info, double& rcond) const
 {
-  if (nr != nc)
-    FAIL;
+  if (nr != nc || nr == 0 || nc == 0)
+    {
+      (*current_liboctave_error_handler) ("inverse requires square matrix");
+      return Matrix ();
+    }
 
   info = 0;
 
   int *ipvt = new int [nr];
   double *z = new double [nr];
   double *tmp_data = dup (data, len);
 
   F77_FCN (dgeco) (tmp_data, &nr, &nc, ipvt, &rcond, z);
@@ -650,17 +768,21 @@ Matrix::solve (const Matrix& b, int& inf
 }
 
 Matrix
 Matrix::solve (const Matrix& b, int& info, double& rcond) const
 {
   Matrix retval;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("matrix dimension mismatch solution of linear equations");
+      return Matrix ();
+    }
 
   info = 0;
   int *ipvt = new int [nr];
 
   double *z = new double [nr];
   double *tmp_data = dup (data, len);
 
   F77_FCN (dgeco) (tmp_data, &nr, &nr, ipvt, &rcond, z);
@@ -725,17 +847,21 @@ Matrix::solve (const ColumnVector& b, in
 }
 
 ColumnVector
 Matrix::solve (const ColumnVector& b, int& info, double& rcond) const
 {
   ColumnVector retval;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("matrix dimension mismatch solution of linear equations");
+      return ColumnVector ();
+    }
 
   info = 0;
   int *ipvt = new int [nr];
 
   double *z = new double [nr];
   double *tmp_data = dup (data, len);
 
   F77_FCN (dgeco) (tmp_data, &nr, &nr, ipvt, &rcond, z);
@@ -802,17 +928,21 @@ Matrix
 Matrix::lssolve (const Matrix& b, int& info, int& rank) const
 {
   int nrhs = b.nc;
 
   int m = nr;
   int n = nc;
 
   if (m == 0 || n == 0 || m != b.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("matrix dimension mismatch in solution of least squares problem");
+      return Matrix ();
+    }
 
   double *tmp_data = dup (data, len);
 
   int nrr = m > n ? m : n;
   Matrix result (nrr, nrhs);
 
   int i, j;
   for (j = 0; j < nrhs; j++)
@@ -887,17 +1017,21 @@ ColumnVector
 Matrix::lssolve (const ColumnVector& b, int& info, int& rank) const
 {
   int nrhs = 1;
 
   int m = nr;
   int n = nc;
 
   if (m == 0 || n == 0 || m != b.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("matrix dimension mismatch in solution of least squares problem");
+      return ColumnVector ();
+    }
 
   double *tmp_data = dup (data, len);
 
   int nrr = m > n ? m : n;
   ColumnVector result (nrr);
 
   int i;
   for (i = 0; i < m; i++)
@@ -1028,17 +1162,21 @@ operator / (double s, const Matrix& a)
 }
 
 // matrix by column vector -> column vector operations
 
 ColumnVector
 Matrix::operator * (const ColumnVector& a) const
 {
   if (nc != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return ColumnVector ();
+    }
 
   if (nr == 0 || nc == 0)
     return ColumnVector (0);
 
   char trans = 'N';
   int ld = nr;
   double alpha = 1.0;
   double beta  = 0.0;
@@ -1060,49 +1198,61 @@ Matrix::operator * (const ComplexColumnV
 }
 
 // matrix by diagonal matrix -> matrix operations
 
 Matrix
 Matrix::operator + (const DiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return Matrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return Matrix (nr, nc);
 
   Matrix result (*this);
   for (int i = 0; i < a.len; i++)
     result.elem (i, i) += a.data[i];
 
   return result;
 }
 
 Matrix
 Matrix::operator - (const DiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return Matrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return Matrix (nr, nc);
 
   Matrix result (*this);
   for (int i = 0; i < a.len; i++)
     result.elem (i, i) -= a.data[i];
 
   return result;
 }
 
 Matrix
 Matrix::operator * (const DiagMatrix& a) const
 {
   if (nc != a.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return Matrix ();
+    }
 
   if (nr == 0 || nc == 0 || a.nc == 0)
     return Matrix (nr, a.nc, 0.0);
 
   double *c = new double [nr*a.nc];
   double *ctmp = (double *) NULL;
 
   for (int j = 0; j < a.len; j++)
@@ -1134,49 +1284,61 @@ Matrix::operator * (const DiagMatrix& a)
 
   return Matrix (c, nr, a.nc);
 }
 
 ComplexMatrix
 Matrix::operator + (const ComplexDiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   ComplexMatrix result (*this);
   for (int i = 0; i < a.len; i++)
     result.elem (i, i) += a.data[i];
 
   return result;
 }
 
 ComplexMatrix
 Matrix::operator - (const ComplexDiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   ComplexMatrix result (*this);
   for (int i = 0; i < a.len; i++)
     result.elem (i, i) -= a.data[i];
 
   return result;
 }
 
 ComplexMatrix
 Matrix::operator * (const ComplexDiagMatrix& a) const
 {
   if (nc != a.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0 || a.nc == 0)
     return ComplexMatrix (nr, a.nc, 0.0);
 
   Complex *c = new Complex [nr*a.nc];
   Complex *ctmp = (Complex *) NULL;
 
   for (int j = 0; j < a.len; j++)
@@ -1208,67 +1370,87 @@ Matrix::operator * (const ComplexDiagMat
 
   return ComplexMatrix (c, nr, a.nc);
 }
 
 Matrix&
 Matrix::operator += (const DiagMatrix& a)
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return *this;
+    }
 
   for (int i = 0; i < a.len; i++)
     elem (i, i) += a.data[i];
 
   return *this;
 }
 
 Matrix&
 Matrix::operator -= (const DiagMatrix& a)
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return *this;
+    }
 
   for (int i = 0; i < a.len; i++)
     elem (i, i) -= a.data[i];
 
   return *this;
 }
 
 // matrix by matrix -> matrix operations
 
 Matrix
 Matrix::operator + (const Matrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return Matrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return Matrix (nr, nc);
 
   return Matrix (add (data, a.data, len), nr, nc);
 }
 
 Matrix
 Matrix::operator - (const Matrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return Matrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return Matrix (nr, nc);
 
   return Matrix (subtract (data, a.data, len), nr, nc);
 }
 
 Matrix
 Matrix::operator * (const Matrix& a) const
 {
   if (nc != a.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return Matrix ();
+    }
 
   if (nr == 0 || nc == 0 || a.nc == 0)
     return Matrix (nr, a.nc, 0.0);
 
   char trans  = 'N';
   char transa = 'N';
 
   int ld  = nr;
@@ -1285,26 +1467,34 @@ Matrix::operator * (const Matrix& a) con
 
   return Matrix (c, nr, a.nc);
 }
 
 ComplexMatrix
 Matrix::operator + (const ComplexMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return ComplexMatrix ();
+    }
 
   return ComplexMatrix (add (data, a.data, len), nr, nc);
 }
 
 ComplexMatrix
 Matrix::operator - (const ComplexMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   return ComplexMatrix (subtract (data, a.data, len), nr, nc);
 }
 
 ComplexMatrix
@@ -1313,78 +1503,102 @@ Matrix::operator * (const ComplexMatrix&
   ComplexMatrix tmp (*this);
   return tmp * a;
 }
 
 Matrix
 Matrix::product (const Matrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix product attempted");
+      return Matrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return Matrix (nr, nc);
 
   return Matrix (multiply (data, a.data, len), nr, nc);
 }
 
 Matrix
 Matrix::quotient (const Matrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix quotient attempted");
+      return Matrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return Matrix (nr, nc);
 
   return Matrix (divide (data, a.data, len), nr, nc);
 }
 
 ComplexMatrix
 Matrix::product (const ComplexMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix product attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   return ComplexMatrix (multiply (data, a.data, len), nr, nc);
 }
 
 ComplexMatrix
 Matrix::quotient (const ComplexMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix quotient attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   return ComplexMatrix (divide (data, a.data, len), nr, nc);
 }
 
 Matrix&
 Matrix::operator += (const Matrix& a)
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return *this;
+    }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   add2 (data, a.data, len);
   return *this;
 }
 
 Matrix&
 Matrix::operator -= (const Matrix& a)
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix -= operation attempted");
+      return *this;
+    }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   subtract2 (data, a.data, len);
   return *this;
 }
 
@@ -1914,17 +2128,17 @@ Matrix::column_min_loc (void) const
   RowVector result;
 
   if (nr > 0 && nc > 0)
     {
       result.resize (nc);
 
       for (int j = 0; j < nc; j++)
         {
-          int res = 0.0;
+          int res = 0;
           for (int i = 0; i < nr; i++)
             if (elem (i, j) < elem (res, j))
               res = i;
           result.elem (j) = (double) (res + 1);
         }
     }
 
   return result;
@@ -2015,48 +2229,72 @@ operator >> (istream& is, Matrix& a)
 
 /*
  * Complex Matrix class
  */
 
 ComplexMatrix::ComplexMatrix (int r, int c)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't construct matrix with negative dimensions");
+      nr = 0;
+      nc = 0;
+      len = 0;
+      data = (Complex *) NULL;
+      return;
+    }
 
   nr = r;
   nc = c;
   len = nr * nc;
   if (len > 0)
     data = new Complex [len];
   else
     data = (Complex *) NULL;
 }
 
 ComplexMatrix::ComplexMatrix (int r, int c, double val)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't construct matrix with negative dimensions");
+      nr = 0;
+      nc = 0;
+      len = 0;
+      data = (Complex *) NULL;
+      return;
+    }
 
   nr = r;
   nc = c;
   len = nr * nc;
   if (len > 0)
     {
       data = new Complex [len];
       copy (data, len, val);
     }
   else
     data = (Complex *) NULL;
 }
 
 ComplexMatrix::ComplexMatrix (int r, int c, const Complex& val)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't construct matrix with negative dimensions");
+      nr = 0;
+      nc = 0;
+      len = 0;
+      data = (Complex *) NULL;
+      return;
+    }
 
   nr = r;
   nc = c;
   len = nr * nc;
   if (len > 0)
     {
       data = new Complex [len];
       copy (data, len, val);
@@ -2175,21 +2413,54 @@ ComplexMatrix::operator = (const Complex
 	  copy (data, a.data, len);
 	}
       else
 	data = (Complex *) NULL;
     }
   return *this;
 }
 
+Complex&
+ComplexMatrix::checkelem (int r, int c)
+{
+#ifndef NO_RANGE_CHECK
+  if (r < 0 || r >= nr || c < 0 || c >= nc)
+    {
+      (*current_liboctave_error_handler) ("range error");
+      static Complex foo (0.0);
+      return foo;
+    }
+#endif
+
+  return elem (r, c);
+}
+
+Complex
+ComplexMatrix::checkelem (int r, int c) const
+{
+#ifndef NO_RANGE_CHECK
+  if (r < 0 || r >= nr || c < 0 || c >= nc)
+    {
+      (*current_liboctave_error_handler) ("range error");
+      return Complex (0.0);
+    }
+#endif
+
+  return elem (r, c);
+}
+
 ComplexMatrix&
 ComplexMatrix::resize (int r, int c)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't resize to negative dimensions");
+      return *this;
+    }
 
   int new_len = r * c;
   Complex* new_data = (Complex *) NULL;
   if (new_len > 0)
     {
       new_data = new Complex [new_len];
 
       int min_r = nr < r ? nr : r;
@@ -2208,17 +2479,21 @@ ComplexMatrix::resize (int r, int c)
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::resize (int r, int c, double val)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't resize to negative dimensions");
+      return *this;
+    }
 
   int new_len = r * c;
   Complex *new_data = (Complex *) NULL;
   if (new_len > 0)
     {
       new_data = new Complex [new_len];
 
 // There may be faster or cleaner ways to do this.
@@ -2242,17 +2517,21 @@ ComplexMatrix::resize (int r, int c, dou
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::resize (int r, int c, const Complex& val)
 {
   if (r < 0 || c < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't resize to negative dimensions");
+      return *this;
+    }
 
   int new_len = r * c;
   Complex *new_data = (Complex *) NULL;
   if (new_len > 0)
     {
       new_data = new Complex [new_len];
 
 // There may be faster or cleaner ways to do this.
@@ -2293,103 +2572,127 @@ ComplexMatrix::operator != (const Comple
 }
 
 // destructive insert/delete/reorder operations
 
 ComplexMatrix&
 ComplexMatrix::insert (const Matrix& a, int r, int c)
 {
   if (r < 0 || r + a.nr - 1 > nr || c < 0 || c + a.nc - 1 > nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for insert");
+      return *this;
+    }
 
   for (int j = 0; j < a.nc; j++)
     for (int i = 0; i < a.nr; i++)
       elem (r+i, c+j) = a.elem (i, j);
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const RowVector& a, int r, int c)
 {
   if (r < 0 || r >= nr || c < 0 || c + a.len - 1 > nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for insert");
+      return *this;
+    }
 
   for (int i = 0; i < a.len; i++)
     elem (r, c+i) = a.data[i];
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ColumnVector& a, int r, int c)
 {
   if (r < 0 || r + a.len - 1 > nr || c < 0 || c >= nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for insert");
+      return *this;
+    }
 
   for (int i = 0; i < a.len; i++)
     elem (r+i, c) = a.data[i];
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const DiagMatrix& a, int r, int c)
 {
   if (r < 0 || r + a.nr - 1 > nr || c < 0 || c + a.nc - 1 > nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for insert");
+      return *this;
+    }
 
   for (int i = 0; i < a.len; i++)
     elem (r+i, c+i) = a.data[i];
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ComplexMatrix& a, int r, int c)
 {
   if (r < 0 || r + a.nr - 1 > nr || c < 0 || c + a.nc - 1 > nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for insert");
+      return *this;
+    }
 
   for (int j = 0; j < a.nc; j++)
     for (int i = 0; i < a.nr; i++)
       elem (r+i, c+j) = a.elem (i, j);
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ComplexRowVector& a, int r, int c)
 {
   if (r < 0 || r >= nr || c < 0 || c + a.len - 1 > nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for insert");
+      return *this;
+    }
 
   for (int i = 0; i < a.len; i++)
     elem (r, c+i) = a.data[i];
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ComplexColumnVector& a, int r, int c)
 {
   if (r < 0 || r + a.len - 1 > nr || c < 0 || c >= nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for insert");
+      return *this;
+    }
 
   for (int i = 0; i < a.len; i++)
     elem (r+i, c) = a.data[i];
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::insert (const ComplexDiagMatrix& a, int r, int c)
 {
   if (r < 0 || r + a.nr - 1 > nr || c < 0 || c + a.nc - 1 > nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for insert");
+      return *this;
+    }
 
   for (int i = 0; i < a.len; i++)
     elem (r+i, c+i) = a.data[i];
 
   return *this;
 }
 
 ComplexMatrix&
@@ -2408,245 +2711,307 @@ ComplexMatrix::fill (const Complex& val)
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::fill (double val, int r1, int c1, int r2, int c2)
 {
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
 
   for (int j = c1; j <= c2; j++)
     for (int i = r1; i <= r2; i++)
       elem (i, j) = val;
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::fill (const Complex& val, int r1, int c1, int r2, int c2)
 {
   if (r1 < 0 || r2 < 0 || c1 < 0 || c2 < 0
       || r1 >= nr || r2 >= nr || c1 >= nc || c2 >= nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   if (r1 > r2) { int tmp = r1; r1 = r2; r2 = tmp; }
   if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
 
   for (int j = c1; j <= c2; j++)
     for (int i = r1; i <= r2; i++)
       elem (i, j) = val;
 
   return *this;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const Matrix& a) const
 {
   if (nr != a.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("row dimension mismatch for append");
+      return *this;
+    }
 
   int nc_insert = nc;
   ComplexMatrix retval (nr, nc + a.nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const RowVector& a) const
 {
   if (nr != 1)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("row dimension mismatch for append");
+      return *this;
+    }
 
   int nc_insert = nc;
   ComplexMatrix retval (nr, nc + a.len);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ColumnVector& a) const
 {
   if (nr != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("row dimension mismatch for append");
+      return *this;
+    }
 
   int nc_insert = nc;
   ComplexMatrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const DiagMatrix& a) const
 {
   if (nr != a.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("row dimension mismatch for append");
+      return *this;
+    }
 
   int nc_insert = nc;
   ComplexMatrix retval (nr, nc + a.nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ComplexMatrix& a) const
 {
   if (nr != a.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("row dimension mismatch for append");
+      return *this;
+    }
 
   int nc_insert = nc;
   ComplexMatrix retval (nr, nc + a.nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ComplexRowVector& a) const
 {
   if (nr != 1)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("row dimension mismatch for append");
+      return *this;
+    }
 
   int nc_insert = nc;
   ComplexMatrix retval (nr, nc + a.len);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ComplexColumnVector& a) const
 {
   if (nr != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("row dimension mismatch for append");
+      return *this;
+    }
 
   int nc_insert = nc;
   ComplexMatrix retval (nr, nc + 1);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::append (const ComplexDiagMatrix& a) const
 {
   if (nr != a.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("row dimension mismatch for append");
+      return *this;
+    }
 
   int nc_insert = nc;
   ComplexMatrix retval (nr, nc + a.nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, 0, nc_insert);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const Matrix& a) const
 {
   if (nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("column dimension mismatch for stack");
+      return *this;
+    }
 
   int nr_insert = nr;
   ComplexMatrix retval (nr + a.nr, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const RowVector& a) const
 {
   if (nc != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("column dimension mismatch for stack");
+      return *this;
+    }
 
   int nr_insert = nr;
   ComplexMatrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ColumnVector& a) const
 {
   if (nc != 1)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("column dimension mismatch for stack");
+      return *this;
+    }
 
   int nr_insert = nr;
   ComplexMatrix retval (nr + a.len, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const DiagMatrix& a) const
 {
   if (nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("column dimension mismatch for stack");
+      return *this;
+    }
 
   int nr_insert = nr;
   ComplexMatrix retval (nr + a.nr, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ComplexMatrix& a) const
 {
   if (nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("column dimension mismatch for stack");
+      return *this;
+    }
 
   int nr_insert = nr;
   ComplexMatrix retval (nr + a.nr, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ComplexRowVector& a) const
 {
   if (nc != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("column dimension mismatch for stack");
+      return *this;
+    }
 
   int nr_insert = nr;
   ComplexMatrix retval (nr + 1, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ComplexColumnVector& a) const
 {
   if (nc != 1)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("column dimension mismatch for stack");
+      return *this;
+    }
 
   int nr_insert = nr;
   ComplexMatrix retval (nr + a.len, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
 ComplexMatrix
 ComplexMatrix::stack (const ComplexDiagMatrix& a) const
 {
   if (nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("column dimension mismatch for stack");
+      return *this;
+    }
 
   int nr_insert = nr;
   ComplexMatrix retval (nr + a.nr, nc);
   retval.insert (*this, 0, 0);
   retval.insert (a, nr_insert, 0);
   return retval;
 }
 
@@ -2725,73 +3090,94 @@ ComplexMatrix::extract (int r1, int c1, 
 }
 
 // extract row or column i.
 
 ComplexRowVector
 ComplexMatrix::row (int i) const
 {
   if (i < 0 || i >= nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid row selection");
+      return ComplexRowVector ();
+    }
 
   ComplexRowVector retval (nc);
   for (int j = 0; j < nc; j++)
     retval.elem (j) = elem (i, j);
 
   return retval;
 }
 
 ComplexRowVector
 ComplexMatrix::row (char *s) const
 {
   if (s == (char *) NULL)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid row selection");
+      return ComplexRowVector ();
+    }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return row (0);
   else if (c == 'l' || c == 'L')
     return row (nr - 1);
   else
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid row selection");
+      return ComplexRowVector ();
+    }
 }
 
 ComplexColumnVector
 ComplexMatrix::column (int i) const
 {
   if (i < 0 || i >= nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid column selection");
+      return ComplexColumnVector ();
+    }
 
   ComplexColumnVector retval (nr);
   for (int j = 0; j < nr; j++)
     retval.elem (j) = elem (j, i);
 
   return retval;
 }
 
 ComplexColumnVector
 ComplexMatrix::column (char *s) const
 {
   if (s == (char *) NULL)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid column selection");
+      return ComplexColumnVector ();
+    }
 
   char c = *s;
   if (c == 'f' || c == 'F')
     return column (0);
   else if (c == 'l' || c == 'L')
     return column (nc - 1);
   else
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("invalid column selection");
+      return ComplexColumnVector ();
+    }
 }
 
 ComplexMatrix
 ComplexMatrix::inverse (int& info, double& rcond) const
 {
   if (nr != nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("inverse requires square matrix");
+      return ComplexMatrix ();
+    }
 
   info = 0;
 
   int *ipvt = new int [nr];
   Complex *z = new Complex [nr];
   Complex *tmp_data = dup (data, len);
 
   F77_FCN (zgeco) (tmp_data, &nr, &nc, ipvt, &rcond, z);
@@ -2984,17 +3370,21 @@ ComplexMatrix::solve (const ComplexMatri
 }
 
 ComplexMatrix
 ComplexMatrix::solve (const ComplexMatrix& b, int& info, double& rcond) const
 {
   ComplexMatrix retval;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("matrix dimension mismatch in solution of linear equations");
+      return ComplexMatrix ();
+    }
 
   info = 0;
   int *ipvt = new int [nr];
 
   Complex *z = new Complex [nr];
   Complex *tmp_data = dup (data, len);
 
   F77_FCN (zgeco) (tmp_data, &nr, &nr, ipvt, &rcond, z);
@@ -3061,17 +3451,21 @@ ComplexMatrix::solve (const ComplexColum
 
 ComplexColumnVector
 ComplexMatrix::solve (const ComplexColumnVector& b, int& info,
 		      double& rcond) const
 {
   ComplexColumnVector retval;
 
   if (nr == 0 || nc == 0 || nr != nc || nr != b.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("matrix dimension mismatch in solution of linear equations");
+      return ComplexColumnVector ();
+    }
 
   info = 0;
   int *ipvt = new int [nr];
 
   Complex *z = new Complex [nr];
   Complex *tmp_data = dup (data, len);
 
   F77_FCN (zgeco) (tmp_data, &nr, &nr, ipvt, &rcond, z);
@@ -3139,17 +3533,21 @@ ComplexMatrix
 ComplexMatrix::lssolve (const ComplexMatrix& b, int& info, int& rank) const
 {
   int nrhs = b.nc;
 
   int m = nr;
   int n = nc;
 
   if (m == 0 || n == 0 || m != b.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("matrix dimension mismatch solution of linear equations");
+      return Matrix ();
+    }
 
   Complex *tmp_data = dup (data, len);
 
   int nrr = m > n ? m : n;
   ComplexMatrix result (nrr, nrhs);
 
   int i, j;
   for (j = 0; j < nrhs; j++)
@@ -3231,17 +3629,21 @@ ComplexMatrix::lssolve (const ComplexCol
 			int& rank) const
 {
   int nrhs = 1;
 
   int m = nr;
   int n = nc;
 
   if (m == 0 || n == 0 || m != b.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("matrix dimension mismatch solution of least squares problem");
+      return ComplexColumnVector ();
+    }
 
   Complex *tmp_data = dup (data, len);
 
   int nrr = m > n ? m : n;
   ComplexColumnVector result (nrr);
 
   int i;
   for (i = 0; i < m; i++)
@@ -3387,17 +3789,21 @@ ComplexMatrix::operator * (const ColumnV
   ComplexColumnVector tmp (a);
   return *this * tmp;
 }
 
 ComplexColumnVector
 ComplexMatrix::operator * (const ComplexColumnVector& a) const
 {
   if (nc != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return ComplexColumnVector ();
+    }
 
   if (nc == 0 || nr == 0)
     return ComplexColumnVector (0);
 
   char trans = 'N';
   int ld = nr;
   Complex alpha (1.0);
   Complex beta (0.0);
@@ -3412,49 +3818,61 @@ ComplexMatrix::operator * (const Complex
 }
 
 // matrix by diagonal matrix -> matrix operations
 
 ComplexMatrix
 ComplexMatrix::operator + (const DiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   ComplexMatrix result (*this);
   for (int i = 0; i < a.len; i++)
     result.elem (i, i) += a.data[i];
 
   return result;
 }
 
 ComplexMatrix
 ComplexMatrix::operator - (const DiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   ComplexMatrix result (*this);
   for (int i = 0; i < a.len; i++)
     result.elem (i, i) -= a.data[i];
 
   return result;
 }
 
 ComplexMatrix
 ComplexMatrix::operator * (const DiagMatrix& a) const
 {
   if (nc != a.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0 || a.nc == 0)
     return ComplexMatrix (nr, nc, 0.0);
 
   Complex *c = new Complex [nr*a.nc];
   Complex *ctmp = (Complex *) NULL;
 
   for (int j = 0; j < a.len; j++)
@@ -3486,49 +3904,61 @@ ComplexMatrix::operator * (const DiagMat
 
   return ComplexMatrix (c, nr, a.nc);
 }
 
 ComplexMatrix
 ComplexMatrix::operator + (const ComplexDiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   ComplexMatrix result (*this);
   for (int i = 0; i < a.len; i++)
     result.elem (i, i) += a.data[i];
 
   return result;
 }
 
 ComplexMatrix
 ComplexMatrix::operator - (const ComplexDiagMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   ComplexMatrix result (*this);
   for (int i = 0; i < a.len; i++)
     result.elem (i, i) -= a.data[i];
 
   return result;
 }
 
 ComplexMatrix
 ComplexMatrix::operator * (const ComplexDiagMatrix& a) const
 {
   if (nc != a.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0 || a.nc == 0)
     return ComplexMatrix (nr, nc, 0.0);
 
   Complex *c = new Complex [nr*a.nc];
   Complex *ctmp = (Complex *) NULL;
 
   for (int j = 0; j < a.len; j++)
@@ -3560,79 +3990,103 @@ ComplexMatrix::operator * (const Complex
 
   return ComplexMatrix (c, nr, a.nc);
 }
 
 ComplexMatrix&
 ComplexMatrix::operator += (const DiagMatrix& a)
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return ComplexMatrix ();
+    }
 
   for (int i = 0; i < a.len; i++)
     elem (i, i) += a.data[i];
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::operator -= (const DiagMatrix& a)
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix -= operation attempted");
+      return ComplexMatrix ();
+    }
 
   for (int i = 0; i < a.len; i++)
     elem (i, i) -= a.data[i];
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::operator += (const ComplexDiagMatrix& a)
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return ComplexMatrix ();
+    }
 
   for (int i = 0; i < a.len; i++)
     elem (i, i) += a.data[i];
 
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::operator -= (const ComplexDiagMatrix& a)
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix -= operation attempted");
+      return ComplexMatrix ();
+    }
 
   for (int i = 0; i < a.len; i++)
     elem (i, i) -= a.data[i];
 
   return *this;
 }
 
 // matrix by matrix -> matrix operations
 
 ComplexMatrix
 ComplexMatrix::operator + (const Matrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   return ComplexMatrix (add (data, a.data, len), nr, nc);
 }
 
 ComplexMatrix
 ComplexMatrix::operator - (const Matrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   return ComplexMatrix (subtract (data, a.data, len), nr, nc);
 }
 
 ComplexMatrix
@@ -3641,41 +4095,53 @@ ComplexMatrix::operator * (const Matrix&
   ComplexMatrix tmp (a);
   return *this * tmp;
 }
 
 ComplexMatrix
 ComplexMatrix::operator + (const ComplexMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix addition attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   return ComplexMatrix (add (data, a.data, len), nr, nc);
 }
 
 ComplexMatrix
 ComplexMatrix::operator - (const ComplexMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix subtraction attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   return ComplexMatrix (subtract (data, a.data, len), nr, nc);
 }
 
 ComplexMatrix
 ComplexMatrix::operator * (const ComplexMatrix& a) const
 {
   if (nc != a.nr)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix multiplication attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0 || a.nc == 0)
     return ComplexMatrix (nr, nc, 0.0);
 
   char trans  = 'N';
   char transa = 'N';
 
   int ld  = nr;
@@ -3692,104 +4158,136 @@ ComplexMatrix::operator * (const Complex
 
   return ComplexMatrix (c, nr, a.nc);
 }
 
 ComplexMatrix
 ComplexMatrix::product (const Matrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix product attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   return ComplexMatrix (multiply (data, a.data, len), nr, nc);
 }
 
 ComplexMatrix
 ComplexMatrix::quotient (const Matrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix quotient attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   return ComplexMatrix (divide (data, a.data, len), nr, nc);
 }
 
 ComplexMatrix
 ComplexMatrix::product (const ComplexMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix product attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   return ComplexMatrix (multiply (data, a.data, len), nr, nc);
 }
 
 ComplexMatrix
 ComplexMatrix::quotient (const ComplexMatrix& a) const
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix quotient attempted");
+      return ComplexMatrix ();
+    }
 
   if (nr == 0 || nc == 0)
     return ComplexMatrix (nr, nc);
 
   return ComplexMatrix (divide (data, a.data, len), nr, nc);
 }
 
 ComplexMatrix&
 ComplexMatrix::operator += (const Matrix& a)
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return *this;
+    }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   add2 (data, a.data, len);
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::operator -= (const Matrix& a)
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix -= operation attempted");
+      return *this;
+    }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   subtract2 (data, a.data, len);
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::operator += (const ComplexMatrix& a)
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix += operation attempted");
+      return *this;
+    }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   add2 (data, a.data, len);
   return *this;
 }
 
 ComplexMatrix&
 ComplexMatrix::operator -= (const ComplexMatrix& a)
 {
   if (nr != a.nr || nc != a.nc)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant matrix -= operation attempted");
+      return *this;
+    }
 
   if (nr == 0 || nc == 0)
     return *this;
 
   subtract2 (data, a.data, len);
   return *this;
 }
 
diff --git a/liboctave/Matrix.h b/liboctave/Matrix.h
--- a/liboctave/Matrix.h
+++ b/liboctave/Matrix.h
@@ -42,18 +42,16 @@ represented by some sort of inheritance 
 #include <stddef.h>
 #include <math.h>
 #include <values.h>
 #include <assert.h>
 #include <iostream.h>
 // #include <iomanip.h>  // We don\'t use this yet.
 #include <Complex.h>
 
-#define FAIL assert(0) /* XXX FIXME XXX */
-
 #ifndef MAPPER_FCN_TYPEDEFS
 #define MAPPER_FCN_TYPEDEFS 1
 
 typedef double (*d_d_Mapper)(double);
 typedef double (*d_c_Mapper)(const Complex&);
 typedef Complex (*c_c_Mapper)(const Complex&);
 
 #endif
@@ -549,41 +547,21 @@ inline Matrix::Matrix (double *d, int r,
 inline Matrix::~Matrix (void) { delete [] data; data = 0; }
 
 inline int Matrix::rows (void) const { return nr; }
 inline int Matrix::cols (void) const { return nc; }
 inline int Matrix::columns (void) const { return nc; } 
 
 inline double& Matrix::elem (int r, int c) { return data[nr*c+r]; }
 
-inline double& Matrix::checkelem (int r, int c)
-{
-#ifndef NO_RANGE_CHECK
-  if (r < 0 || r >= nr || c < 0 || c >= nc)
-    FAIL;
-#endif
-
-  return elem (r, c);
-}
-
 inline double& Matrix::operator () (int r, int c)
   { return checkelem (r, c); }
 
 inline double Matrix::elem (int r, int c) const { return data[nr*c+r]; }
 
-inline double Matrix::checkelem (int r, int c) const
-{
-#ifndef NO_RANGE_CHECK
-  if (r < 0 || r >= nr || c < 0 || c >= nc)
-    FAIL;
-#endif
-
-  return elem (r, c);
-}
-
 inline double Matrix::operator () (int r, int c) const
   { return checkelem (r, c); }
 
 inline double *Matrix::fortran_vec (void) const { return data; }
 
 /*
  * Column Vector class
  */
@@ -710,42 +688,20 @@ inline ColumnVector::ColumnVector (void)
 inline ColumnVector::ColumnVector (double *d, int l) { len = l; data = d; }
 inline ColumnVector::~ColumnVector (void) { delete [] data; data = 0; }
 
 inline int ColumnVector::capacity (void) const { return len; }
 inline int ColumnVector::length (void) const { return len; }
 
 inline double& ColumnVector::elem (int n) { return data[n]; }
 
-inline double&
-ColumnVector::checkelem (int n)
-{
-#ifndef NO_RANGE_CHECK
-  if (n < 0 || n >= len)
-    FAIL;
-#endif
-
-  return elem (n);
-}
-
 inline double& ColumnVector::operator () (int n) { return checkelem (n); }
 
 inline double ColumnVector::elem (int n) const { return data[n]; }
 
-inline double
-ColumnVector::checkelem (int n) const
-{
-#ifndef NO_RANGE_CHECK
-  if (n < 0 || n >= len)
-    FAIL;
-#endif
-
-  return elem (n);
-}
-
 inline double ColumnVector::operator () (int n) const { return checkelem (n); }
 
 inline double *ColumnVector::fortran_vec (void) const { return data; }
 
 /*
  * Row Vector class
  */
 
@@ -877,42 +833,20 @@ inline RowVector::RowVector (void) { len
 inline RowVector::RowVector (double *d, int l) { len = l; data = d; }
 inline RowVector::~RowVector (void) { delete [] data; data = 0; }
 
 inline int RowVector::capacity (void) const { return len; }
 inline int RowVector::length (void) const { return len; }
 
 inline double& RowVector::elem (int n) { return data[n]; }
 
-inline double&
-RowVector::checkelem (int n)
-{
-#ifndef NO_RANGE_CHECK
-  if (n < 0 || n >= len)
-    FAIL;
-#endif
-
-  return elem (n);
-}
-
 inline double& RowVector::operator () (int n) { return checkelem (n); }
 
 inline double RowVector::elem (int n) const { return data[n]; }
 
-inline double
-RowVector::checkelem (int n) const
-{
-#ifndef NO_RANGE_CHECK
-  if (n < 0 || n >= len)
-    FAIL;
-#endif
-
-  return elem (n);
-}
-
 inline double RowVector::operator () (int n) const { return checkelem (n); }
 
 inline double *RowVector::fortran_vec (void) const { return data; }
 
 /*
  * Diagonal Matrix class
  */
 
@@ -1071,42 +1005,22 @@ inline int DiagMatrix::rows (void) const
 inline int DiagMatrix::cols (void) const { return nc; }
 inline int DiagMatrix::columns (void) const { return nc; } 
 
 // Would be nice to be able to avoid compiler warning and make this
 // fail on assignment.
 inline double& DiagMatrix::elem (int r, int c)
   { return (r == c) ? data[r] : 0; }
 
-inline double& DiagMatrix::checkelem (int r, int c)
-{
-#ifndef NO_RANGE_CHECK
-  if (r < 0 || r >= nr || c < 0 || c >= nc)
-    FAIL;
-#endif
-
-  return elem (r, c);
-}
-
 inline double& DiagMatrix::operator () (int r, int c)
   { return checkelem (r, c); }
 
 inline double DiagMatrix::elem (int r, int c) const
   { return (r == c) ? data[r] : 0; }
 
-inline double DiagMatrix::checkelem (int r, int c) const
-{
-#ifndef NO_RANGE_CHECK
-  if (r < 0 || r >= nr || c < 0 || c >= nc)
-    FAIL;
-#endif
-
-  return elem (r, c);
-}
-
 inline double DiagMatrix::operator () (int r, int c) const
   { return checkelem (r, c); }
 
 /*
  * Complex Matrix class
  */
 
 class ComplexMatrix
@@ -1393,42 +1307,22 @@ inline ComplexMatrix::ComplexMatrix (Com
 inline ComplexMatrix::~ComplexMatrix (void) { delete [] data; data = 0; }
 
 inline int ComplexMatrix::rows (void) const { return nr; }
 inline int ComplexMatrix::cols (void) const { return nc; }
 inline int ComplexMatrix::columns (void) const { return nc; } 
 
 inline Complex& ComplexMatrix::elem (int r, int c) { return data[nr*c+r]; }
 
-inline Complex& ComplexMatrix::checkelem (int r, int c)
-{
-#ifndef NO_RANGE_CHECK
-  if (r < 0 || r >= nr || c < 0 || c >= nc)
-    FAIL;
-#endif
-
-  return elem (r, c);
-}
-
 inline Complex& ComplexMatrix::operator () (int r, int c)
   { return checkelem (r, c); }
 
 inline Complex ComplexMatrix::elem (int r, int c) const
   { return data[nr*c+r]; }
 
-inline Complex ComplexMatrix::checkelem (int r, int c) const
-{
-#ifndef NO_RANGE_CHECK
-  if (r < 0 || r >= nr || c < 0 || c >= nc)
-    FAIL;
-#endif
-
-  return elem (r, c);
-}
-
 inline Complex ComplexMatrix::operator () (int r, int c) const
   { return checkelem (r, c); }
 
 inline Complex *ComplexMatrix::fortran_vec (void) const { return data; }
 
 /*
  * Complex Column Vector class
  */
@@ -1586,43 +1480,21 @@ inline ComplexColumnVector::ComplexColum
 inline ComplexColumnVector::~ComplexColumnVector (void)
   { delete [] data; data = 0; }
 
 inline int ComplexColumnVector::capacity (void) const { return len; }
 inline int ComplexColumnVector::length (void) const { return len; }
 
 inline Complex& ComplexColumnVector::elem (int n) { return data[n]; }
 
-inline Complex&
-ComplexColumnVector::checkelem (int n)
-{
-#ifndef NO_RANGE_CHECK
-  if (n < 0 || n >= len)
-    FAIL;
-#endif
-
-  return elem (n);
-}
-
 inline Complex& ComplexColumnVector::operator () (int n)
   { return checkelem (n); }
 
 inline Complex ComplexColumnVector::elem (int n) const { return data[n]; }
 
-inline Complex
-ComplexColumnVector::checkelem (int n) const
-{
-#ifndef NO_RANGE_CHECK
-  if (n < 0 || n >= len)
-    FAIL;
-#endif
-
-  return elem (n);
-}
-
 inline Complex ComplexColumnVector::operator () (int n) const
   { return checkelem (n); }
 
 inline Complex *ComplexColumnVector::fortran_vec (void) const { return data; }
 
 /*
  * Complex Row Vector class
  */
@@ -1781,42 +1653,20 @@ inline ComplexRowVector::ComplexRowVecto
   { len = l; data = d; }
 inline ComplexRowVector::~ComplexRowVector (void) { delete [] data; data = 0; }
 
 inline int ComplexRowVector::capacity (void) const { return len; }
 inline int ComplexRowVector::length (void) const { return len; }
 
 inline Complex& ComplexRowVector::elem (int n) { return data[n]; }
 
-inline Complex&
-ComplexRowVector::checkelem (int n)
-{
-#ifndef NO_RANGE_CHECK
-  if (n < 0 || n >= len)
-    FAIL;
-#endif
-
-  return elem (n);
-}
-
 inline Complex& ComplexRowVector::operator () (int n) { return checkelem (n); }
 
 inline Complex ComplexRowVector::elem (int n) const { return data[n]; }
 
-inline Complex
-ComplexRowVector::checkelem (int n) const
-{
-#ifndef NO_RANGE_CHECK
-  if (n < 0 || n >= len)
-    FAIL;
-#endif
-
-  return elem (n);
-}
-
 inline Complex ComplexRowVector::operator () (int n) const
   { return checkelem (n); }
 
 inline Complex *ComplexRowVector::fortran_vec (void) const { return data; }
 
 /*
  * Complex Diagonal Matrix class
  */
@@ -2009,42 +1859,22 @@ inline int ComplexDiagMatrix::rows (void
 inline int ComplexDiagMatrix::cols (void) const { return nc; }
 inline int ComplexDiagMatrix::columns (void) const { return nc; } 
 
 // Would be nice to be able to avoid compiler warning and make this
 // fail on assignment.
 inline Complex& ComplexDiagMatrix::elem (int r, int c)
   { Complex czero (0.0, 0.0); return (r == c) ? data[r] : czero; }
 
-inline Complex& ComplexDiagMatrix::checkelem (int r, int c)
-{
-#ifndef NO_RANGE_CHECK
-  if (r < 0 || r >= nr || c < 0 || c >= nc)
-    FAIL;
-#endif
-
-  return elem (r, c);
-}
-
 inline Complex& ComplexDiagMatrix::operator () (int r, int c)
   { return checkelem (r, c); }
 
 inline Complex ComplexDiagMatrix::elem (int r, int c) const
   { Complex czero (0.0, 0.0); return (r == c) ? data[r] : czero; }
 
-inline Complex ComplexDiagMatrix::checkelem (int r, int c) const
-{
-#ifndef NO_RANGE_CHECK
-  if (r < 0 || r >= nr || c < 0 || c >= nc)
-    FAIL;
-#endif
-
-  return elem (r, c);
-}
-
 inline Complex ComplexDiagMatrix::operator () (int r, int c) const
   { return checkelem (r, c); }
 
 /*
  * Result of a AEP Balance operation
  */
 
 class AEPBALANCE
@@ -2067,17 +1897,17 @@ private:
   int init (const Matrix& a, const char * balance_job);
 
   Matrix balanced_mat;
   Matrix balancing_mat;
 };
 
 inline AEPBALANCE::AEPBALANCE (const Matrix& a,const char * balance_job) 
 {
-  init (a,balance_job); 
+  init (a, balance_job); 
 }
 
 inline AEPBALANCE::AEPBALANCE (const AEPBALANCE& a)
 {
   balanced_mat = a.balanced_mat;
   balancing_mat = a.balancing_mat;
 }
 
@@ -2118,17 +1948,17 @@ private:
 
   ComplexMatrix balanced_mat;
   ComplexMatrix balancing_mat;
 };
 
 inline ComplexAEPBALANCE::ComplexAEPBALANCE (const ComplexMatrix& a,
 					     const char * balance_job)
 {
-  init(a,balance_job); 
+  init(a, balance_job); 
 }
 
 inline ComplexAEPBALANCE::ComplexAEPBALANCE (const ComplexAEPBALANCE& a)
 {
   balanced_mat = a.balanced_mat;
   balancing_mat = a.balancing_mat;
 }
 
@@ -2271,17 +2101,17 @@ private:
   Matrix balanced_b_mat;
   Matrix left_balancing_mat;
   Matrix right_balancing_mat;
 };
 
 inline GEPBALANCE::GEPBALANCE (const Matrix& a, const Matrix& b, 
   const char * balance_job) 
 {
-  init (a,b,balance_job); 
+  init (a, b, balance_job); 
 }
 
 inline GEPBALANCE::GEPBALANCE (const GEPBALANCE& a)
 {
   balanced_a_mat = a.balanced_a_mat;
   balanced_b_mat = a.balanced_b_mat;
   left_balancing_mat = a.left_balancing_mat;
   right_balancing_mat = a.right_balancing_mat;
diff --git a/liboctave/NLEqn.cc b/liboctave/NLEqn.cc
--- a/liboctave/NLEqn.cc
+++ b/liboctave/NLEqn.cc
@@ -24,16 +24,17 @@ Software Foundation, 675 Mass Ave, Cambr
 #ifdef __GNUG__
 #pragma implementation
 #endif
 
 #include <iostream.h>
 #include <float.h>
 #include "NLEqn.h"
 #include "f77-uscore.h"
+#include "lo-error.h"
 
 extern "C"
 {
   int F77_FCN (hybrd1) (int (*)(), const int*, double*, double*,
 			const double*, int*, double*, const int*);
 
   int F77_FCN (hybrj1) (int (*)(), const int*, double*, double*,
 			double*, const int*, const double*, int*,
@@ -43,18 +44,17 @@ extern "C"
 static nonlinear_fcn user_fun;
 static jacobian_fcn user_jac;
 
 // error handling
 
 void
 NLEqn::error (const char* msg)
 {
-  cerr << "Fatal NLEqn error. " << msg << "\n";
-  exit(1);
+  (*current_liboctave_error_handler) ("fatal NLEqn error: %s", msg);
 }
 
 // Constructors
 
 NLEqn::NLEqn (void) : NLFunc (), x (), n (0) {}
 
 NLEqn::NLEqn (const Vector& xvec, const NLFunc f) 
   : NLFunc (f), x (xvec), n (xvec.capacity ()) {}
@@ -94,17 +94,20 @@ NLEqn::states (void) const
 {
   return x;
 }
 
 void
 NLEqn::set_states (const Vector& xvec)
 {
   if (xvec.capacity () != n)
-    error ("dimension error");
+    {
+      error ("dimension error");
+      return;
+    }
 
   x = xvec;
 }
 
 // Other operations
 
 Vector
 NLEqn::solve (const Vector& xvec)
@@ -182,17 +185,20 @@ hybrj1_fcn (int *n, double *x, double *f
 }
 
 Vector
 NLEqn::solve (int& info)
 {
   int tmp_info = 0;
 
   if (n == 0)
-    error ("Equation set not initialized");
+    {
+      error ("equation set not initialized");
+      return Vector ();
+    }
 
   double tol = sqrt (DBL_EPSILON);
 
   double *fvec = new double [n];
   double *px = new double [n];
   for (int i = 0; i < n; i++)
     px[i] = x.elem (i);
 
diff --git a/liboctave/RowVector.cc b/liboctave/RowVector.cc
--- a/liboctave/RowVector.cc
+++ b/liboctave/RowVector.cc
@@ -25,37 +25,50 @@ Software Foundation, 675 Mass Ave, Cambr
 // several classes, each of which is defined in a separate file...
 //
 // #ifdef __GNUG__
 // #pragma implementation "Matrix.h"
 // #endif
 
 #include "Matrix.h"
 #include "mx-inlines.cc"
+#include "lo-error.h"
 
 /*
  * Row Vector class.
  */
 
 RowVector::RowVector (int n)
 {
   if (n < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create vector with negative dimension");
+      len = 0;
+      data = (double *) NULL;
+      return;
+    }
 
   len = n;
   if (len > 0)
     data = new double [len];
   else
     data = (double *) NULL;
 }
 
 RowVector::RowVector (int n, double val)
 {
   if (n < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create vector with negative dimension");
+      len = 0;
+      data = (double *) NULL;
+      return;
+    }
 
   len = n;
   if (len > 0)
     {
       data = new double [len];
       copy (data, len, val);
     }
   else
@@ -94,21 +107,54 @@ RowVector::operator = (const RowVector& 
 	  copy (data, a.data, len);
 	}
       else
 	data = (double *) NULL;
     }
   return *this;
 }
 
+double&
+RowVector::checkelem (int n)
+{
+#ifndef NO_RANGE_CHECK
+  if (n < 0 || n >= len)
+    {
+      (*current_liboctave_error_handler) ("range error");
+      static double foo = 0.0;
+      return foo;
+    }
+#endif
+
+  return elem (n);
+}
+
+double
+RowVector::checkelem (int n) const
+{
+#ifndef NO_RANGE_CHECK
+  if (n < 0 || n >= len)
+    {
+      (*current_liboctave_error_handler) ("range error");
+      return 0.0;
+    }
+#endif
+
+  return elem (n);
+}
+
 RowVector&
 RowVector::resize (int n)
 {
   if (n < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't resize to negative dimension");
+      return *this;
+    }
 
   double *new_data = (double *) NULL;
   if (n > 0)
     {
       new_data = new double [n];
       int min_len = len < n ? len : n;
 
       for (int i = 0; i < min_len; i++)
@@ -148,17 +194,20 @@ RowVector::operator != (const RowVector&
     return 1;
   return !equal (data, a.data, len);
 }
 
 RowVector&
 RowVector::insert (const RowVector& a, int c)
 {
   if (c < 0 || c + a.len - 1 > len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for insert");
+      return *this;
+    }
 
   for (int i = 0; i < a.len; i++)
     data[c+i] = a.data[i];
 
   return *this;
 }
 
 RowVector&
@@ -168,17 +217,20 @@ RowVector::fill (double val)
     copy (data, len, val);
   return *this;
 }
 
 RowVector&
 RowVector::fill (double val, int c1, int c2)
 {
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
 
   for (int i = c1; i <= c2; i++)
     data[i] = val;
 
   return *this;
 }
@@ -291,17 +343,21 @@ operator / (double s, const RowVector& a
 }
 
 // row vector by column vector -> scalar
 
 double
 RowVector::operator * (const ColumnVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector multiplication attempted");
+      return 0.0;
+    }
 
   int i_one = 1;
   return F77_FCN (ddot) (&len, data, &i_one, a.data, &i_one);
 }
 
 Complex
 RowVector::operator * (const ComplexColumnVector& a) const
 {
@@ -310,17 +366,21 @@ RowVector::operator * (const ComplexColu
 }
 
 // row vector by matrix -> row vector
 
 RowVector
 RowVector::operator * (const Matrix& a) const
 {
   if (a.nr != len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector multiplication attempted");
+      return RowVector ();
+    }
 
   if (len == 0 || a.nc == 0)
     return RowVector (0);
 
 // Transpose A to form A'*x == (x'*A)'
 
   int anr = a.nr;
   int anc = a.nc;
@@ -347,126 +407,166 @@ RowVector::operator * (const ComplexMatr
 }
 
 // row vector by row vector -> row vector operations
 
 RowVector
 RowVector::operator + (const RowVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector addition attempted");
+      return RowVector ();
+    }
 
   if (len == 0)
     return RowVector (0);
 
   return RowVector (add (data, a.data, len), len);
 }
 
 RowVector
 RowVector::operator - (const RowVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector subtraction attempted");
+      return RowVector ();
+    }
 
   if (len == 0)
     return RowVector (0);
 
   return RowVector (subtract (data, a.data, len), len);
 }
 
 ComplexRowVector
 RowVector::operator + (const ComplexRowVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector addition attempted");
+      return ComplexRowVector ();
+    }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (add (data, a.data, len), len);
 }
 
 ComplexRowVector
 RowVector::operator - (const ComplexRowVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector subtraction attempted");
+      return ComplexRowVector ();
+    }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (subtract (data, a.data, len), len);
 }
 
 RowVector
 RowVector::product (const RowVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector product attempted");
+      return RowVector ();
+    }
 
   if (len == 0)
     return RowVector (0);
 
   return RowVector (multiply (data, a.data, len), len);
 }
 
 RowVector
 RowVector::quotient (const RowVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector quotient attempted");
+      return RowVector ();
+    }
 
   if (len == 0)
     return RowVector (0);
 
   return RowVector (divide (data, a.data, len), len);
 }
 
 ComplexRowVector
 RowVector::product (const ComplexRowVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector product attempted");
+      return ComplexRowVector ();
+    }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (multiply (data, a.data, len), len);
 }
 
 ComplexRowVector
 RowVector::quotient (const ComplexRowVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector quotient attempted");
+      return ComplexRowVector ();
+    }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (divide (data, a.data, len), len);
 }
 
 RowVector&
 RowVector::operator += (const RowVector& a)
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector += operation attempted");
+      return *this;
+    }
 
   if (len == 0)
     return *this;
 
   add2 (data, a.data, len);
   return *this;
 }
 
 RowVector&
 RowVector::operator -= (const RowVector& a)
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector -= operation attempted");
+      return *this;
+    }
 
   if (len == 0)
     return *this;
 
   subtract2 (data, a.data, len);
   return *this;
 }
 
@@ -537,44 +637,62 @@ operator << (ostream& os, const RowVecto
 
 /*
  * Complex Row Vector class
  */
 
 ComplexRowVector::ComplexRowVector (int n)
 {
   if (n < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create vector with negative dimension");
+      len = 0;
+      data = (Complex *) NULL;
+      return;
+    }
 
   len = n;
   if (len > 0)
     data = new Complex [len];
   else
     data = (Complex *) NULL;
 }
 
 ComplexRowVector::ComplexRowVector (int n, double val)
 {
   if (n < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create vector with negative dimension");
+      len = 0;
+      data = (Complex *) NULL;
+      return;
+    }
 
   len = n;
   if (len > 0)
     {
       data = new Complex [len];
       copy (data, len, val);
     }
   else
     data = (Complex *) NULL;
 }
 
 ComplexRowVector::ComplexRowVector (int n, const Complex& val)
 {
   if (n < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't create vector with negative dimension");
+      len = 0;
+      data = (Complex *) NULL;
+      return;
+    }
 
   len = n;
   if (len > 0)
     {
       data = new Complex [len];
       copy (data, len, val);
     }
   else
@@ -648,21 +766,54 @@ ComplexRowVector::operator = (const Comp
 	  copy (data, a.data, len);
 	}
       else
 	data = (Complex *) NULL;
     }
   return *this;
 }
 
+Complex&
+ComplexRowVector::checkelem (int n)
+{
+#ifndef NO_RANGE_CHECK
+  if (n < 0 || n >= len)
+    {
+      (*current_liboctave_error_handler) ("range error");
+      static Complex foo (0.0);
+      return foo;
+    }
+#endif
+
+  return elem (n);
+}
+
+Complex
+ComplexRowVector::checkelem (int n) const
+{
+#ifndef NO_RANGE_CHECK
+  if (n < 0 || n >= len)
+    {
+      (*current_liboctave_error_handler) ("range error");
+      return Complex (0.0);
+    }
+#endif
+
+  return elem (n);
+}
+
 ComplexRowVector&
 ComplexRowVector::resize (int n)
 {
   if (n < 0)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("can't resize to negative dimension");
+      return *this;
+    }
 
   Complex *new_data = (Complex *) NULL;
   if (n > 0)
     {
       new_data = new Complex [n];
       int min_len = len < n ? len : n;
 
       for (int i = 0; i < min_len; i++)
@@ -715,29 +866,35 @@ ComplexRowVector::operator != (const Com
 }
 
 // destructive insert/delete/reorder operations
 
 ComplexRowVector&
 ComplexRowVector::insert (const RowVector& a, int c)
 {
   if (c < 0 || c + a.len - 1 > len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for insert");
+      return *this;
+    }
 
   for (int i = 0; i < a.len; i++)
     data[c+i] = a.data[i];
 
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::insert (const ComplexRowVector& a, int c)
 {
   if (c < 0 || c + a.len - 1 > len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for insert");
+      return *this;
+    }
 
   for (int i = 0; i < a.len; i++)
     data[c+i] = a.data[i];
 
   return *this;
 }
 
 ComplexRowVector&
@@ -755,31 +912,37 @@ ComplexRowVector::fill (const Complex& v
     copy (data, len, val);
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::fill (double val, int c1, int c2)
 {
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
 
   for (int i = c1; i <= c2; i++)
     data[i] = val;
 
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::fill (const Complex& val, int c1, int c2)
 {
   if (c1 < 0 || c2 < 0 || c1 >= len || c2 >= len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler) ("range error for fill");
+      return *this;
+    }
 
   if (c1 > c2) { int tmp = c1; c1 = c2; c2 = tmp; }
 
   for (int i = c1; i <= c2; i++)
     data[i] = val;
 
   return *this;
 }
@@ -985,17 +1148,21 @@ ComplexRowVector::operator * (const Matr
   ComplexMatrix tmp (a);
   return *this * tmp;
 }
 
 ComplexRowVector
 ComplexRowVector::operator * (const ComplexMatrix& a) const
 {
   if (a.nr != len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector multiplication attempted");
+      return ComplexRowVector ();
+    }
 
   if (len == 0 || a.nc == 0)
     return ComplexRowVector (0);
 
 // Transpose A to form A'*x == (x'*A)'
 
   int anr = a.nr;
   int anc = a.nc;
@@ -1015,152 +1182,200 @@ ComplexRowVector::operator * (const Comp
 }
 
 // row vector by row vector -> row vector operations
 
 ComplexRowVector
 ComplexRowVector::operator + (const RowVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector addition attempted");
+      return ComplexRowVector ();
+    }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (add (data, a.data, len), len);
 }
 
 ComplexRowVector
 ComplexRowVector::operator - (const RowVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector subtraction attempted");
+      return ComplexRowVector ();
+    }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (subtract (data, a.data, len), len);
 }
 
 ComplexRowVector
 ComplexRowVector::operator + (const ComplexRowVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector addition attempted");
+      return ComplexRowVector ();
+    }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (add (data, a.data, len), len);
 }
 
 ComplexRowVector
 ComplexRowVector::operator - (const ComplexRowVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector subtraction attempted");
+      return ComplexRowVector ();
+    }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (subtract (data, a.data, len), len);
 }
 
 ComplexRowVector
 ComplexRowVector::product (const RowVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector product attempted");
+      return ComplexRowVector ();
+    }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (multiply (data, a.data, len), len);
 }
 
 ComplexRowVector
 ComplexRowVector::quotient (const RowVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector quotient attempted");
+      return ComplexRowVector ();
+    }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (divide (data, a.data, len), len);
 }
 
 ComplexRowVector
 ComplexRowVector::product (const ComplexRowVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector product attempted");
+      return ComplexRowVector ();
+    }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (multiply (data, a.data, len), len);
 }
 
 ComplexRowVector
 ComplexRowVector::quotient (const ComplexRowVector& a) const
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector quotient attempted");
+      return ComplexRowVector ();
+    }
 
   if (len == 0)
     return ComplexRowVector (0);
 
   return ComplexRowVector (divide (data, a.data, len), len);
 }
 
 ComplexRowVector&
 ComplexRowVector::operator += (const RowVector& a)
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector += operation attempted");
+      return *this;
+    }
 
   if (len == 0)
     return *this;
 
   add2 (data, a.data, len);
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::operator -= (const RowVector& a)
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector -= operation attempted");
+      return *this;
+    }
 
   if (len == 0)
     return *this;
 
   subtract2 (data, a.data, len);
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::operator += (const ComplexRowVector& a)
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector += operation attempted");
+      return *this;
+    }
 
   if (len == 0)
     return *this;
 
   add2 (data, a.data, len);
   return *this;
 }
 
 ComplexRowVector&
 ComplexRowVector::operator -= (const ComplexRowVector& a)
 {
   if (len != a.len)
-    FAIL;
+    {
+      (*current_liboctave_error_handler)
+	("nonconformant vector -= operation attempted");
+      return *this;
+    }
 
   if (len == 0)
     return *this;
 
   subtract2 (data, a.data, len);
   return *this;
 }
 
diff --git a/liboctave/idx-vector.cc b/liboctave/idx-vector.cc
--- a/liboctave/idx-vector.cc
+++ b/liboctave/idx-vector.cc
@@ -265,16 +265,28 @@ idx_vector::convert_one_zero_to_idx (voi
 }
 
 static inline int
 intcmp (int *i, int *j)
 {
   return (*i - *j);
 }
 
+int
+idx_vector::checkelem (int n) const
+{
+  if (n < 0 || n >= len)
+    {
+      error ("idx-vector: index out of range");
+      return 0;
+    }
+
+  return elem (n);
+}
+
 void
 idx_vector::sort (void)
 {
   qsort ((void *) data, len, sizeof (int),
 	 (int (*)(void*, void*)) intcmp); 
 }
 
 ostream&
diff --git a/liboctave/idx-vector.h b/liboctave/idx-vector.h
--- a/liboctave/idx-vector.h
+++ b/liboctave/idx-vector.h
@@ -23,20 +23,16 @@ Software Foundation, 675 Mass Ave, Cambr
 
 #if !defined (_idx_vector_h)
 #define _idx_vector_h 1
 
 #ifdef __GNUG__
 #pragma interface
 #endif
 
-#include <assert.h>
-
-#define FAIL assert(0) /* XXX FIXME XXX */
-
 class ostream;
 class Matrix;
 class Range;
 
 class idx_vector
 {
 public:
   idx_vector (void);
@@ -116,25 +112,16 @@ inline idx_vector::operator void * () co
   return initialized ? (void *) 1 : (void *) 0;
 }
 
 inline int idx_vector::capacity (void) const { return len; }
 inline int idx_vector::length (void) const { return len; }
 
 inline int idx_vector::elem (int n) const { return data[n]; }
 
-inline int
-idx_vector::checkelem (int n) const
-{
-  if (n < 0 || n >= len)
-    FAIL;
-
-  return elem (n);
-}
-
 inline int idx_vector::operator () (int n) const { return checkelem (n); }
 
 inline int idx_vector::max (void) const { return max_val; }
 inline int idx_vector::min (void) const { return min_val; }
 
 inline int idx_vector::one_zero_only (void) const { return one_zero; }
 inline int idx_vector::zeros_count (void) const { return num_zeros; }
 inline int idx_vector::ones_count (void) const { return num_ones; }
diff --git a/liboctave/lo-error.h b/liboctave/lo-error.h
--- a/liboctave/lo-error.h
+++ b/liboctave/lo-error.h
@@ -16,36 +16,40 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.
 
 */
 
-#if !defined (_error_h)
-#define _error_h 1
+#if !defined (_liboctave_error_h)
+#define _liboctave_error_h 1
 
 #ifdef __GNUG__
 #pragma interface
 #endif
 
 // Tell g++ that fatal doesn't return;
 
 #ifdef __GNUG__
 typedef void v_fcn_cpc_x (const char *, ...);
 volatile v_fcn_cpc_x fatal;
 #endif
 
+extern void liboctave_fatal (const char *fmt, ...);
+
 typedef void (*liboctave_error_handler) (const char *, ...);
 
+// Would be nice to make this private, but we want to share it among
+// all the liboctave classes.
+extern liboctave_error_handler current_liboctave_error_handler;
+
 extern void set_liboctave_error_handler (liboctave_error_handler f);
 
-extern void liboctave_fatal (const char *fmt, ...);
-
 #endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; page-delimiter: "^/\\*" ***
 ;;; End: ***
 */
