# HG changeset patch
# User Rik <rik@octave.org>
# Date 1383065680 25200
#      Tue Oct 29 09:54:40 2013 -0700
# Node ID 86c6ae5f969ee6eaae7fd47b4964f5202c36d8b7
# Parent  f2b047f9b6054cdeb70b5ff497e184af99dc329c
Use GNU style coding conventions for code in libgui/

* libgui/qterminal/libqterminal/QTerminal.h, libgui/src/color-picker.cc,
libgui/src/color-picker.h, libgui/src/dialog.cc, libgui/src/dialog.h,
libgui/src/documentation-dock-widget.cc, libgui/src/files-dock-widget.cc,
libgui/src/files-dock-widget.h, libgui/src/find-files-dialog.cc,
libgui/src/find-files-dialog.h, libgui/src/find-files-model.cc,
libgui/src/find-files-model.h, libgui/src/history-dock-widget.cc,
libgui/src/history-dock-widget.h, libgui/src/m-editor/file-editor-interface.h,
libgui/src/m-editor/file-editor-tab.cc, libgui/src/m-editor/file-editor-tab.h,
libgui/src/m-editor/file-editor.cc, libgui/src/m-editor/find-dialog.cc,
libgui/src/m-editor/find-dialog.h, libgui/src/m-editor/octave-qscintilla.cc,
libgui/src/main-window.cc, libgui/src/main-window.h,
libgui/src/news-dock-widget.h, libgui/src/octave-dock-widget.cc,
libgui/src/octave-dock-widget.h, libgui/src/octave-gui.cc,
libgui/src/octave-qt-link.cc, libgui/src/octave-qt-link.h,
libgui/src/qtinfo/parser.cc, libgui/src/qtinfo/parser.h,
libgui/src/qtinfo/webinfo.cc, libgui/src/qtinfo/webinfo.h,
libgui/src/resource-manager.cc, libgui/src/settings-dialog.cc,
libgui/src/settings-dialog.h, libgui/src/terminal-dock-widget.cc,
libgui/src/welcome-wizard.cc, libgui/src/workspace-model.cc,
libgui/src/workspace-model.h, libgui/src/workspace-view.cc,
libgui/src/workspace-view.h:
Use GNU style coding conventions for code in libgui/

diff --git a/libgui/qterminal/libqterminal/QTerminal.h b/libgui/qterminal/libqterminal/QTerminal.h
--- a/libgui/qterminal/libqterminal/QTerminal.h
+++ b/libgui/qterminal/libqterminal/QTerminal.h
@@ -51,21 +51,21 @@ public:
 
   virtual void setSize (int h, int v) = 0;
 
   virtual void sendText (const QString& text) = 0;
 
   virtual QString selectedText () = 0;
 
   enum CursorType
-    {
-      UnderlineCursor,
-      BlockCursor,
-      IBeamCursor
-    };
+  {
+    UnderlineCursor,
+    BlockCursor,
+    IBeamCursor
+  };
 
   virtual void setCursorType (CursorType type, bool blinking)
   {
     // Provide empty default impl in order to avoid conflicts with the
     // win impl.
 
     Q_UNUSED (type);
     Q_UNUSED (blinking);
@@ -91,38 +91,38 @@ public slots:
   virtual void pasteClipboard (void) = 0;
 
   virtual void handleCustomContextMenuRequested (const QPoint& at)
   {
     QClipboard * cb = QApplication::clipboard ();
 
     _paste_action->setEnabled (cb->text().length() > 0);
     _copy_action->setEnabled (selectedText().length() > 0);
-    
+
     _contextMenu->move (mapToGlobal (at));
     _contextMenu->show ();
   }
 
   void notice_settings (const QSettings *settings);
 
 protected:
 
   QTerminal (QWidget *xparent = 0) : QWidget (xparent)
   {
     setContextMenuPolicy (Qt::CustomContextMenu);
 
     _contextMenu = new QMenu (this);
 
     _copy_action = _contextMenu->addAction (
-                             QIcon (":/actions/icons/editcopy.png"),
-                             tr ("Copy"), this, SLOT (copyClipboard ()));
+                     QIcon (":/actions/icons/editcopy.png"),
+                     tr ("Copy"), this, SLOT (copyClipboard ()));
 
     _paste_action = _contextMenu->addAction (
-                            QIcon (":/actions/icons/editpaste.png"),
-                            tr ("Paste"), this, SLOT (pasteClipboard ()));
+                      QIcon (":/actions/icons/editpaste.png"),
+                      tr ("Paste"), this, SLOT (pasteClipboard ()));
 
     _contextMenu->addSeparator ();
 
     _contextMenu->addAction (tr ("Clear All"), parent (),
                              SLOT (handle_clear_command_window_request ()));
 
     connect (this, SIGNAL (customContextMenuRequested (QPoint)),
              this, SLOT (handleCustomContextMenuRequested (QPoint)));
@@ -137,14 +137,14 @@ protected:
              this, SLOT (copyClipboard ()));
 
     connect (xparent, SIGNAL (pasteClipboard_signal ()),
              this, SLOT (pasteClipboard ()));
   }
 
 private:
 
-    QMenu *_contextMenu;
-    QAction * _copy_action;
-    QAction * _paste_action;
+  QMenu *_contextMenu;
+  QAction * _copy_action;
+  QAction * _paste_action;
 };
 
 #endif // QTERMINAL_H
diff --git a/libgui/src/color-picker.cc b/libgui/src/color-picker.cc
--- a/libgui/src/color-picker.cc
+++ b/libgui/src/color-picker.cc
@@ -26,19 +26,19 @@
 
 #include "color-picker.h"
 
 // constuctor with initial color as parameter
 color_picker::color_picker (QColor old_color, QWidget* p) : QPushButton (p)
 {
   _color = old_color;
   setFlat (true);
-  setFocusPolicy(Qt::NoFocus);  // no focus, would changes the color
+  setFocusPolicy (Qt::NoFocus);  // no focus, would changes the color
   update_button ();
-  connect(this, SIGNAL (clicked ()), SLOT (select_color ()));
+  connect (this, SIGNAL (clicked ()), SLOT (select_color ()));
 }
 
 // slot for bitton clicked: selct a new color using QColorDialog
 void
 color_picker::select_color ()
 {
   QColor new_color = QColorDialog::getColor (_color);
   if (new_color.isValid () && new_color != _color)
@@ -51,17 +51,17 @@ color_picker::select_color ()
 // draw the button with the actual color (using a stylesheet)
 void color_picker::update_button ()
 {
   // Is this the right place to look for a "foreground" color that would
   // provide a reasonable border for the color swatches?
   QWidget *p = parentWidget ();
 
   QString bordercolor
-    = p ? p->palette().text().color().name() : QString ("#000000");
+    = p ? p->palette ().text ().color ().name () : QString ("#000000");
 
-  QString css = QString("background-color: %1; border: 1px solid %2;")
-                        .arg(_color.name())
-                        .arg(bordercolor);
+  QString css = QString ("background-color: %1; border: 1px solid %2;")
+                .arg (_color.name ())
+                .arg (bordercolor);
 
-  setStyleSheet(css);
+  setStyleSheet (css);
   repaint ();
 }
diff --git a/libgui/src/color-picker.h b/libgui/src/color-picker.h
--- a/libgui/src/color-picker.h
+++ b/libgui/src/color-picker.h
@@ -30,17 +30,17 @@
 #include <QPushButton>
 #include <QColorDialog>
 
 class color_picker: public QPushButton
 {
   Q_OBJECT
 
 public:
-  color_picker (QColor color = QColor(0,0,0), QWidget *parent = 0);
+  color_picker (QColor color = QColor (0,0,0), QWidget *parent = 0);
   QColor color () const { return _color; }
 
 private slots:
   void select_color ();
 
 private:
   virtual void update_button ();
   QColor _color;
diff --git a/libgui/src/dialog.cc b/libgui/src/dialog.cc
--- a/libgui/src/dialog.cc
+++ b/libgui/src/dialog.cc
@@ -41,17 +41,18 @@ along with Octave; see the file COPYING.
 #include <QGridLayout>
 #include <QLabel>
 
 QUIWidgetCreator uiwidget_creator;
 
 
 QUIWidgetCreator::QUIWidgetCreator (void)
   : QObject (), dialog_result (-1), dialog_button (),
-    string_list (new QStringList ()), list_index (new QIntList ()), path_name (new QString ())
+    string_list (new QStringList ()), list_index (new QIntList ()),
+    path_name (new QString ())
 { }
 
 
 QUIWidgetCreator::~QUIWidgetCreator (void)
 {
   delete string_list;
   delete list_index;
   delete path_name;
@@ -259,17 +260,17 @@ ListDialog::ListDialog (const QStringLis
   buttonsLayout->addWidget (buttonCancel);
 
   QVBoxLayout *mainLayout = new QVBoxLayout;
   mainLayout->addLayout (listLayout);
   mainLayout->addSpacing (12);
   mainLayout->addLayout (buttonsLayout);
   setLayout (mainLayout);
   if (fixed_layout)
-    layout()->setSizeConstraint (QLayout::SetFixedSize);
+    layout ()->setSizeConstraint (QLayout::SetFixedSize);
 
   // If empty, make blank rather than use default OS behavior.
   setWindowTitle (title.isEmpty () ? " " : title);
 
   connect (select_all, SIGNAL (clicked ()),
            view, SLOT (selectAll ()));
 
   connect (buttonOk, SIGNAL (clicked ()),
@@ -325,74 +326,74 @@ InputDialog::InputDialog (const QStringL
                           const QFloatList& nr, const QFloatList& nc,
                           const QStringList& defaults)
   : QDialog ()
 {
 
 #define LINE_EDIT_FOLLOWS_PROMPT 0
 
 #if LINE_EDIT_FOLLOWS_PROMPT
-    // Prompt on left followed by input on right.
-    QGridLayout *promptInputLayout = new QGridLayout;
+  // Prompt on left followed by input on right.
+  QGridLayout *promptInputLayout = new QGridLayout;
 #else
-    // Prompt aligned above input.
-    QVBoxLayout *promptInputLayout = new QVBoxLayout;
+  // Prompt aligned above input.
+  QVBoxLayout *promptInputLayout = new QVBoxLayout;
 #endif
-    int N_gridrows = prompt.size ();
-    for (int i = 0; i < N_gridrows; i++)
-      {
-        QLabel *label = new QLabel (prompt.at (i));
-        QLineEdit *line_edit = new QLineEdit (defaults.at (i));
-        if (nr.at (i) > 0)
-          {
-            QSize qsize = line_edit->sizeHint ();
-            int intval = qsize.height () * nr.at (i);
-            line_edit->setFixedHeight (intval);
-            if (nc.at (i) > 0)
-              {
-                intval = qsize.height () * nc.at (i) / 2;
-                line_edit->setFixedWidth (intval);
-              }
-          }
-        input_line << line_edit;
+  int N_gridrows = prompt.size ();
+  for (int i = 0; i < N_gridrows; i++)
+    {
+      QLabel *label = new QLabel (prompt.at (i));
+      QLineEdit *line_edit = new QLineEdit (defaults.at (i));
+      if (nr.at (i) > 0)
+        {
+          QSize qsize = line_edit->sizeHint ();
+          int intval = qsize.height () * nr.at (i);
+          line_edit->setFixedHeight (intval);
+          if (nc.at (i) > 0)
+            {
+              intval = qsize.height () * nc.at (i) / 2;
+              line_edit->setFixedWidth (intval);
+            }
+        }
+      input_line << line_edit;
 #if LINE_EDIT_FOLLOWS_PROMPT
-        promptInputLayout->addWidget (label, i + 1, 0);
-        promptInputLayout->addWidget (line_edit, i + 1, 1);
+      promptInputLayout->addWidget (label, i + 1, 0);
+      promptInputLayout->addWidget (line_edit, i + 1, 1);
 #else
-        promptInputLayout->addWidget (label);
-        promptInputLayout->addWidget (line_edit);
+      promptInputLayout->addWidget (label);
+      promptInputLayout->addWidget (line_edit);
 #endif
-      }
+    }
 #undef LINE_EDIT_FOLLOWS_PROMPT
 
-    QPushButton *buttonOk = new QPushButton("OK");
-    QPushButton *buttonCancel = new QPushButton("Cancel");
-    QHBoxLayout *buttonsLayout = new QHBoxLayout;
-    buttonsLayout->addStretch (1);
-    buttonsLayout->addWidget (buttonOk);
-    buttonsLayout->addWidget (buttonCancel);
+  QPushButton *buttonOk = new QPushButton ("OK");
+  QPushButton *buttonCancel = new QPushButton ("Cancel");
+  QHBoxLayout *buttonsLayout = new QHBoxLayout;
+  buttonsLayout->addStretch (1);
+  buttonsLayout->addWidget (buttonOk);
+  buttonsLayout->addWidget (buttonCancel);
 
-    QVBoxLayout *mainLayout = new QVBoxLayout;
-    mainLayout->addLayout (promptInputLayout);
-    mainLayout->addSpacing (12);
-    mainLayout->addLayout (buttonsLayout);
-    setLayout (mainLayout);
+  QVBoxLayout *mainLayout = new QVBoxLayout;
+  mainLayout->addLayout (promptInputLayout);
+  mainLayout->addSpacing (12);
+  mainLayout->addLayout (buttonsLayout);
+  setLayout (mainLayout);
 
-    // If empty, make blank rather than use default OS behavior.
-    setWindowTitle (title.isEmpty () ? " " : title);
+  // If empty, make blank rather than use default OS behavior.
+  setWindowTitle (title.isEmpty () ? " " : title);
 
-    connect (buttonOk, SIGNAL (clicked ()),
-             this, SLOT (buttonOk_clicked ()));
+  connect (buttonOk, SIGNAL (clicked ()),
+           this, SLOT (buttonOk_clicked ()));
 
-    connect (buttonCancel, SIGNAL (clicked ()),
-             this, SLOT (buttonCancel_clicked ()));
+  connect (buttonCancel, SIGNAL (clicked ()),
+           this, SLOT (buttonCancel_clicked ()));
 
-    connect (this, SIGNAL (finish_input (const QStringList&, int)),
-             &uiwidget_creator,
-             SLOT (input_finished (const QStringList&, int)));
+  connect (this, SIGNAL (finish_input (const QStringList&, int)),
+           &uiwidget_creator,
+           SLOT (input_finished (const QStringList&, int)));
 }
 
 
 void
 InputDialog::buttonOk_clicked (void)
 {
   // Store information about what button was pressed so that builtin
   // functions can retrieve.
@@ -408,45 +409,45 @@ InputDialog::buttonCancel_clicked (void)
 {
   // Store information about what button was pressed so that builtin
   // functions can retrieve.
   QStringList empty;
   emit finish_input (empty, 0);
   done (QDialog::Rejected);
 }
 
-  
+
 void
 InputDialog::reject (void)
 {
   buttonCancel_clicked ();
 }
 
 FileDialog::FileDialog (const QStringList& name_filters, const QString& title,
                         const QString& filename, const QString& dirname,
                         const QString& multimode)
-  : QFileDialog()
+  : QFileDialog ()
 {
   // Create a NonModal message.
   setWindowModality (Qt::NonModal);
 
   setWindowTitle (title.isEmpty () ? " " : title);
   setDirectory (dirname);
 
   if (multimode == "on")         // uigetfile multiselect=on
     {
       setFileMode (QFileDialog::ExistingFiles);
       setAcceptMode (QFileDialog::AcceptOpen);
     }
   else if (multimode == "create") // uiputfile
     {
-      setFileMode (QFileDialog::AnyFile); 
+      setFileMode (QFileDialog::AnyFile);
       setAcceptMode (QFileDialog::AcceptSave);
       setOption (QFileDialog::DontConfirmOverwrite, false);
-      setConfirmOverwrite(true);
+      setConfirmOverwrite (true);
     }
   else if (multimode == "dir")    // uigetdir
     {
       setFileMode (QFileDialog::Directory);
       setOption (QFileDialog::ShowDirsOnly, true);
       setOption (QFileDialog::HideNameFilterDetails, true);
       setAcceptMode (QFileDialog::AcceptOpen);
     }
@@ -454,34 +455,34 @@ FileDialog::FileDialog (const QStringLis
     {
       setFileMode (QFileDialog::ExistingFile);
       setAcceptMode (QFileDialog::AcceptOpen);
     }
 
   setNameFilters (name_filters);
 
   selectFile (filename);
-  
+
   connect (this,
            SIGNAL (finish_input (const QStringList&, const QString&, int)),
            &uiwidget_creator,
            SLOT (filedialog_finished (const QStringList&, const QString&,
                                       int)));
 }
 
 void
 FileDialog::reject (void)
 {
   QStringList empty;
   emit finish_input (empty, "", 0);
   done (QDialog::Rejected);
 
 }
 
-void FileDialog::accept(void)
+void FileDialog::accept (void)
 {
   QStringList string_result;
   QString path;
   int idx = 1;
 
   string_result = selectedFiles ();
 
   // Matlab expects just the file name, whereas the file dialog gave us
@@ -490,14 +491,14 @@ void FileDialog::accept(void)
   for (int i = 0; i < string_result.size (); i++)
     string_result[i] = QFileInfo (string_result[i]).fileName ();
 
 
   path = directory ().absolutePath ();
 
   QStringList name_filters = nameFilters ();
   idx = name_filters.indexOf (selectedNameFilter ()) + 1;
-  
+
   // send the selected info
   emit finish_input (string_result, path, idx);
   done (QDialog::Accepted);
 }
 
diff --git a/libgui/src/dialog.h b/libgui/src/dialog.h
--- a/libgui/src/dialog.h
+++ b/libgui/src/dialog.h
@@ -99,18 +99,18 @@ public:
 
     emit create_inputlayout (prompt, title, nr, nc, defaults);
 
     return true;
   };
 
   const QStringList *get_string_list (void) { return string_list; }
 
-  bool signal_filedialog (const QStringList& filters, const QString& title, 
-                          const QString& filename, const QString& dirname, 
+  bool signal_filedialog (const QStringList& filters, const QString& title,
+                          const QString& filename, const QString& dirname,
                           const QString &multimode)
   {
     emit create_filedialog (filters, title, filename, dirname, multimode);
     return true;
   }
 
   const QString *get_dialog_path (void) { return path_name; }
 
@@ -247,17 +247,17 @@ public slots:
 
 class FileDialog : public QFileDialog
 {
   Q_OBJECT
 
 public:
 
   explicit FileDialog (const QStringList& filters,
-                       const QString& title, const QString& filename, 
+                       const QString& title, const QString& filename,
                        const QString& dirname, const QString& multimode);
 
 signals:
 
   void finish_input (const QStringList&, const QString&, int);
 
 private slots:
 
diff --git a/libgui/src/documentation-dock-widget.cc b/libgui/src/documentation-dock-widget.cc
--- a/libgui/src/documentation-dock-widget.cc
+++ b/libgui/src/documentation-dock-widget.cc
@@ -32,18 +32,18 @@ documentation_dock_widget::documentation
   setObjectName ("DocumentationDockWidget");
   setWindowIcon (QIcon (":/actions/icons/logo.png"));
   set_title (tr ("Documentation"));
   setStatusTip (tr ("See the documentation for help."));
 
   _webinfo = new webinfo (this);
   setWidget (_webinfo);
 
-  connect (p, SIGNAL(show_doc_signal(const QString &)),
-   this, SLOT(showDoc(const QString &)));
+  connect (p, SIGNAL (show_doc_signal (const QString &)),
+           this, SLOT (showDoc (const QString &)));
 }
 
 void
 documentation_dock_widget::copyClipboard ()
 {
   _webinfo->copyClipboard ();
 }
 void
diff --git a/libgui/src/files-dock-widget.cc b/libgui/src/files-dock-widget.cc
--- a/libgui/src/files-dock-widget.cc
+++ b/libgui/src/files-dock-widget.cc
@@ -58,17 +58,17 @@ public:
       QTreeView::mousePressEvent (e);
   }
 };
 
 files_dock_widget::files_dock_widget (QWidget *p)
   : octave_dock_widget (p)
 {
   setObjectName ("FilesDockWidget");
-  setWindowIcon (QIcon(":/actions/icons/logo.png"));
+  setWindowIcon (QIcon (":/actions/icons/logo.png"));
   set_title (tr ("File Browser"));
   setToolTip (tr ("Browse your files."));
 
   QWidget *container = new QWidget (this);
 
   setWidget (container);
 
   connect (this, SIGNAL (open_file (const QString&)),
@@ -79,63 +79,70 @@ files_dock_widget::files_dock_widget (QW
 
   // Create a toolbar
   _navigation_tool_bar = new QToolBar ("", container);
   _navigation_tool_bar->setAllowedAreas (Qt::TopToolBarArea);
   _navigation_tool_bar->setMovable (false);
 
   _current_directory = new QComboBox (_navigation_tool_bar);
   _current_directory->setToolTip (tr ("Enter the path or filename"));
-  _current_directory->setEditable(true);
-  _current_directory->setMaxCount(MaxMRUDirs);
-  _current_directory->setInsertPolicy(QComboBox::NoInsert);
-  _current_directory->setSizeAdjustPolicy (QComboBox::AdjustToMinimumContentsLengthWithIcon);
-  QSizePolicy sizePol(QSizePolicy::Expanding, QSizePolicy::Preferred);
-  _current_directory->setSizePolicy(sizePol);
+  _current_directory->setEditable (true);
+  _current_directory->setMaxCount (MaxMRUDirs);
+  _current_directory->setInsertPolicy (QComboBox::NoInsert);
+  _current_directory->setSizeAdjustPolicy (
+    QComboBox::AdjustToMinimumContentsLengthWithIcon);
+  QSizePolicy sizePol (QSizePolicy::Expanding, QSizePolicy::Preferred);
+  _current_directory->setSizePolicy (sizePol);
 
-  QAction *directory_up_action = new QAction (QIcon(":/actions/icons/up.png"),
+  QAction *directory_up_action = new QAction (QIcon (":/actions/icons/up.png"),
                                               "", _navigation_tool_bar);
   directory_up_action->setToolTip (tr ("Move up one directory"));
 
-  _sync_browser_directory_action = new QAction (QIcon(":/actions/icons/reload.png"),
-                                                tr("Show octave directory"), _navigation_tool_bar);
-  _sync_browser_directory_action->setToolTip (tr ("Goto current octave directory"));
+  _sync_browser_directory_action
+    = new QAction (QIcon (":/actions/icons/reload.png"),
+                   tr ("Show octave directory"), _navigation_tool_bar);
+  _sync_browser_directory_action->setToolTip (
+    tr ("Goto current octave directory"));
   _sync_browser_directory_action->setEnabled ("false");
 
-  _sync_octave_directory_action = new QAction (QIcon(":/actions/icons/ok.png"),
-                                               tr("Set octave directory"), _navigation_tool_bar);
-  _sync_octave_directory_action->setToolTip (tr ("Set octave directroy to current browser directory"));
+  _sync_octave_directory_action
+    = new QAction (QIcon (":/actions/icons/ok.png"),
+                   tr ("Set octave directory"), _navigation_tool_bar);
+  _sync_octave_directory_action->setToolTip (
+    tr ("Set octave directroy to current browser directory"));
   _sync_octave_directory_action->setEnabled ("false");
 
-  QToolButton * popdown_button = new QToolButton();
-  popdown_button->setToolTip(tr ("Actions on current directory"));
-  QMenu * popdown_menu = new QMenu();
+  QToolButton * popdown_button = new QToolButton ();
+  popdown_button->setToolTip (tr ("Actions on current directory"));
+  QMenu * popdown_menu = new QMenu ();
   popdown_menu->addAction (QIcon (":/actions/icons/home.png"),
                            tr ("Show Home directory"),
                            this, SLOT (popdownmenu_home (bool)));
-  popdown_menu->addAction(_sync_browser_directory_action);
-  popdown_menu->addAction(_sync_octave_directory_action);
-  popdown_button->setMenu(popdown_menu);
-  popdown_button->setPopupMode(QToolButton::InstantPopup);
-  popdown_button->setDefaultAction(new QAction(QIcon(":/actions/icons/gear.png"),"", _navigation_tool_bar));
+  popdown_menu->addAction (_sync_browser_directory_action);
+  popdown_menu->addAction (_sync_octave_directory_action);
+  popdown_button->setMenu (popdown_menu);
+  popdown_button->setPopupMode (QToolButton::InstantPopup);
+  popdown_button->setDefaultAction (new QAction (
+                                      QIcon (":/actions/icons/gear.png"), "",
+                                      _navigation_tool_bar));
 
-  popdown_menu->addSeparator();
+  popdown_menu->addSeparator ();
   popdown_menu->addAction (QIcon (":/actions/icons/search.png"),
                            tr ("Search directory"),
                            this, SLOT (popdownmenu_search_dir (bool)));
-  popdown_menu->addSeparator();
-  popdown_menu->addAction( tr ("Find Files ..."),
-                          this, SLOT(popdownmenu_findfiles(bool)));
-  popdown_menu->addSeparator();
-  popdown_menu->addAction(QIcon(":/actions/icons/filenew.png"),
-                          tr ("New File"),
-                          this, SLOT(popdownmenu_newfile(bool)));
-  popdown_menu->addAction(QIcon(":/actions/icons/folder_new.png"),
-                          tr ("New Directory"),
-                          this, SLOT(popdownmenu_newdir(bool)));
+  popdown_menu->addSeparator ();
+  popdown_menu->addAction ( tr ("Find Files ..."),
+                            this, SLOT (popdownmenu_findfiles (bool)));
+  popdown_menu->addSeparator ();
+  popdown_menu->addAction (QIcon (":/actions/icons/filenew.png"),
+                           tr ("New File"),
+                           this, SLOT (popdownmenu_newfile (bool)));
+  popdown_menu->addAction (QIcon (":/actions/icons/folder_new.png"),
+                           tr ("New Directory"),
+                           this, SLOT (popdownmenu_newdir (bool)));
 
   _navigation_tool_bar->addWidget (_current_directory);
   _navigation_tool_bar->addAction (directory_up_action);
   _navigation_tool_bar->addWidget (popdown_button);
 
   connect (directory_up_action, SIGNAL (triggered ()), this,
            SLOT (change_directory_up ()));
   connect (_sync_octave_directory_action, SIGNAL (triggered ()), this,
@@ -143,94 +150,101 @@ files_dock_widget::files_dock_widget (QW
   connect (_sync_browser_directory_action, SIGNAL (triggered ()), this,
            SLOT (do_sync_browser_directory ()));
 
   // Create the QFileSystemModel starting in the actual directory
   QDir curr_dir;
   _file_system_model = new QFileSystemModel (this);
   _file_system_model->setFilter (QDir::NoDotAndDotDot | QDir::AllEntries);
   QModelIndex rootPathIndex = _file_system_model->setRootPath (
-                                                  curr_dir.absolutePath ());
+                                curr_dir.absolutePath ());
 
   // Attach the model to the QTreeView and set the root index
   _file_tree_view = new FileTreeViewer (container);
   _file_tree_view->setSelectionMode (QAbstractItemView::ExtendedSelection);
   _file_tree_view->setModel (_file_system_model);
   _file_tree_view->setRootIndex (rootPathIndex);
   _file_tree_view->setSortingEnabled (true);
   _file_tree_view->setAlternatingRowColors (true);
   _file_tree_view->setAnimated (true);
   _file_tree_view->setToolTip (tr ("Doubleclick a file to open it"));
 
   // get sort column and order as well as cloumn state (order and width)
   QSettings *settings = resource_manager::get_settings ();
-  // FIXME -- what should happen if settings is 0?
+  // FIXME: what should happen if settings is 0?
   _file_tree_view->sortByColumn (
-              settings->value ("filesdockwidget/sort_files_by_column",0).toInt (),
-              static_cast<Qt::SortOrder>(settings->value ("filesdockwidget/sort_files_by_order",Qt::AscendingOrder).toUInt ())
+    settings->value ("filesdockwidget/sort_files_by_column",0).toInt (),
+    static_cast<Qt::SortOrder>
+    (settings->value ("filesdockwidget/sort_files_by_order",
+                      Qt::AscendingOrder).toUInt ())
   );
-  _file_tree_view->header ()->restoreState (settings->value ("filesdockwidget/column_state").toByteArray ());
-  
-  QStringList mru_dirs = settings->value ("filesdockwidget/mru_dir_list").toStringList ();
-  _current_directory->addItems(mru_dirs);
+  _file_tree_view->header ()->restoreState (
+    settings->value ("filesdockwidget/column_state").toByteArray ());
 
-  _current_directory->setEditText(_file_system_model->fileInfo (rootPathIndex).
-                              absoluteFilePath ());
+  QStringList mru_dirs =
+    settings->value ("filesdockwidget/mru_dir_list").toStringList ();
+  _current_directory->addItems (mru_dirs);
+
+  _current_directory->setEditText (
+    _file_system_model->fileInfo (rootPathIndex).  absoluteFilePath ());
 
   connect (_file_tree_view, SIGNAL (doubleClicked (const QModelIndex &)),
            this, SLOT (item_double_clicked (const QModelIndex &)));
 
   // add context menu to tree_view
-  _file_tree_view->setContextMenuPolicy(Qt::CustomContextMenu);
-  connect(_file_tree_view, SIGNAL(customContextMenuRequested(const QPoint &)), 
-           this, SLOT(contextmenu_requested(const QPoint &)));
+  _file_tree_view->setContextMenuPolicy (Qt::CustomContextMenu);
+  connect (_file_tree_view,
+           SIGNAL (customContextMenuRequested (const QPoint &)),
+           this, SLOT (contextmenu_requested (const QPoint &)));
 
   // Layout the widgets vertically with the toolbar on top
   QVBoxLayout *vbox_layout = new QVBoxLayout ();
   vbox_layout->setSpacing (0);
   vbox_layout->addWidget (_navigation_tool_bar);
   vbox_layout->addWidget (_file_tree_view);
   vbox_layout->setMargin (1);
 
   container->setLayout (vbox_layout);
 
-  // TODO: Add right-click contextual menus for copying, pasting, deleting files (and others)
+  // TODO: Add right-click contextual menus for copying, pasting,
+  //       deleting files (and others).
 
-  connect (_current_directory->lineEdit(), SIGNAL (returnPressed ()),
-            this, SLOT (accept_directory_line_edit ()));
+  connect (_current_directory->lineEdit (), SIGNAL (returnPressed ()),
+           this, SLOT (accept_directory_line_edit ()));
 
   connect (_current_directory, SIGNAL (activated (const QString &)),
            this, SLOT (set_current_directory (const QString &)));
 
   connect (this, SIGNAL (run_file_signal (const QFileInfo&)),
            main_win (), SLOT (run_file_in_terminal (const QFileInfo&)));
 
   QCompleter *completer = new QCompleter (_file_system_model, this);
   _current_directory->setCompleter (completer);
 
   setFocusProxy (_current_directory);
-  
+
   _sync_octave_dir = true;   // default, overwirtten with notice_settings ()
   _octave_dir = "";
 }
 
 files_dock_widget::~files_dock_widget ()
 {
   QSettings *settings = resource_manager::get_settings ();
   int sort_column = _file_tree_view->header ()->sortIndicatorSection ();
   Qt::SortOrder sort_order = _file_tree_view->header ()->sortIndicatorOrder ();
   settings->setValue ("filesdockwidget/sort_files_by_column", sort_column);
   settings->setValue ("filesdockwidget/sort_files_by_order", sort_order);
-  settings->setValue ("filesdockwidget/column_state", _file_tree_view->header ()->saveState ());
+  settings->setValue ("filesdockwidget/column_state",
+                      _file_tree_view->header ()->saveState ());
 
   QStringList dirs;
-  for(int i=0; i< _current_directory->count(); i++)
-  {
-    dirs.append(_current_directory->itemText(i));
-  }
+  for (int i=0; i< _current_directory->count (); i++)
+    {
+      dirs.append (_current_directory->itemText (i));
+    }
   settings->setValue ("filesdockwidget/mru_dir_list", dirs);
 
   settings->sync ();
 }
 
 void
 files_dock_widget::item_double_clicked (const QModelIndex& index)
 {
@@ -249,25 +263,29 @@ void
 files_dock_widget::accept_directory_line_edit (void)
 {
   display_directory (_current_directory->currentText ());
 }
 
 void
 files_dock_widget::change_directory_up (void)
 {
-  QDir dir = QDir (_file_system_model->filePath (_file_tree_view->rootIndex ()));
+  QDir dir
+    = QDir (_file_system_model->filePath (_file_tree_view->rootIndex ()));
+
   dir.cdUp ();
   display_directory (dir.absolutePath ());
 }
 
 void
 files_dock_widget::do_sync_octave_directory (void)
 {
-  QDir dir = QDir (_file_system_model->filePath (_file_tree_view->rootIndex ()));
+  QDir dir
+    = QDir (_file_system_model->filePath (_file_tree_view->rootIndex ()));
+
   emit displayed_directory_changed (dir.absolutePath ());
 }
 
 void
 files_dock_widget::do_sync_browser_directory (void)
 {
   display_directory (_octave_dir,false);  // false: no sync of octave dir
 }
@@ -288,26 +306,28 @@ files_dock_widget::display_directory (co
     {
       if (fileInfo.isDir ())
         {
           _file_tree_view->setRootIndex (_file_system_model->
                                          index (fileInfo.absoluteFilePath ()));
           _file_system_model->setRootPath (fileInfo.absoluteFilePath ());
           _file_system_model->sort (0, Qt::AscendingOrder);
           if (_sync_octave_dir && set_octave_dir)
-            process_set_current_dir(fileInfo.absoluteFilePath ());
+            process_set_current_dir (fileInfo.absoluteFilePath ());
 
-          // see if its in the list, and if it is, remove it and then, put at top of the list
-          int index = _current_directory->findText(fileInfo.absoluteFilePath ());
-          if(index != -1)
-          {
-             _current_directory->removeItem(index);
-          }
-          _current_directory->insertItem(0, fileInfo.absoluteFilePath ());
-          _current_directory->setCurrentIndex(0);
+          // see if its in the list, and if it is,
+          // remove it and then, put at top of the list
+          int index
+            = _current_directory->findText (fileInfo.absoluteFilePath ());
+          if (index != -1)
+            {
+              _current_directory->removeItem (index);
+            }
+          _current_directory->insertItem (0, fileInfo.absoluteFilePath ());
+          _current_directory->setCurrentIndex (0);
         }
       else
         {
           QString abs_fname = fileInfo.absoluteFilePath ();
 
           if (QFile::exists (abs_fname))
             {
               if (is_octave_data_file (abs_fname.toStdString ()))
@@ -325,86 +345,87 @@ files_dock_widget::open_item_in_app (con
   // Retrieve the file info associated with the model index.
   QFileInfo fileInfo = _file_system_model->fileInfo (index);
 
   QString file = fileInfo.absoluteFilePath ();
 
   QDesktopServices::openUrl (QUrl::fromLocalFile (file));
 }
 
-void 
+void
 files_dock_widget::contextmenu_requested (const QPoint& mpos)
 {
 
-  QMenu menu(this);
+  QMenu menu (this);
 
   QModelIndex index = _file_tree_view->indexAt (mpos);
   //QAbstractItemModel *m = _file_tree_view->model ();
 
-  if (index.isValid())
-    { 
-      QFileInfo info = _file_system_model->fileInfo(index);
+  if (index.isValid ())
+    {
+      QFileInfo info = _file_system_model->fileInfo (index);
 
-      menu.addAction (QIcon (":/actions/icons/fileopen.png"), tr("Open"),
-                     this, SLOT(contextmenu_open(bool)));
+      menu.addAction (QIcon (":/actions/icons/fileopen.png"), tr ("Open"),
+                      this, SLOT (contextmenu_open (bool)));
 
-      menu.addAction (tr("Open in Default Application"),
+      menu.addAction (tr ("Open in Default Application"),
                       this, SLOT (contextmenu_open_in_app (bool)));
 
-      menu.addAction (tr("Copy Selection to Clipboard"),
+      menu.addAction (tr ("Copy Selection to Clipboard"),
                       this, SLOT (contextmenu_copy_selection (bool)));
 
       if (info.isFile () && info.suffix () == "m")
         menu.addAction (QIcon (":/actions/icons/artsbuilderexecute.png"),
-                        tr("Run"), this, SLOT(contextmenu_run(bool)));
+                        tr ("Run"), this, SLOT (contextmenu_run (bool)));
 
       if (info.isFile ())
-        menu.addAction (tr("Load Data"), this, SLOT(contextmenu_load(bool)));
+        menu.addAction (tr ("Load Data"), this, SLOT (contextmenu_load (bool)));
 
       if (info.isDir ())
         {
           menu.addSeparator ();
           menu.addAction (QIcon (":/actions/icons/ok.png"),
                           tr ("Set Current Directory"),
                           this, SLOT (contextmenu_setcurrentdir (bool)));
           menu.addSeparator ();
-          menu.addAction (tr ("Find Files ..."), this, SLOT(contextmenu_findfiles(bool)));
+          menu.addAction (tr ("Find Files ..."), this,
+                          SLOT (contextmenu_findfiles (bool)));
         }
 
-      menu.addSeparator();
-      menu.addAction (tr ("Rename"), this, SLOT(contextmenu_rename(bool)));
-      menu.addAction (QIcon(":/actions/icons/editdelete.png"), tr("Delete"),
-                      this, SLOT(contextmenu_delete(bool)));
+      menu.addSeparator ();
+      menu.addAction (tr ("Rename"), this, SLOT (contextmenu_rename (bool)));
+      menu.addAction (QIcon (":/actions/icons/editdelete.png"), tr ("Delete"),
+                      this, SLOT (contextmenu_delete (bool)));
 
-      if (info.isDir())
+      if (info.isDir ())
         {
-          menu.addSeparator();
+          menu.addSeparator ();
           menu.addAction (QIcon (":/actions/icons/filenew.png"),
                           tr ("New File"),
-                          this, SLOT(contextmenu_newfile(bool)));
+                          this, SLOT (contextmenu_newfile (bool)));
           menu.addAction (QIcon (":/actions/icons/folder_new.png"),
-                          tr("New Directory"),
-                          this, SLOT(contextmenu_newdir(bool)));
+                          tr ("New Directory"),
+                          this, SLOT (contextmenu_newdir (bool)));
         }
 
-      menu.exec(_file_tree_view->mapToGlobal(mpos));
+      menu.exec (_file_tree_view->mapToGlobal (mpos));
 
     }
 }
 
 void
 files_dock_widget::contextmenu_open (bool)
 {
 
   QItemSelectionModel *m = _file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
-  for( QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
+  for ( QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
     {
-      item_double_clicked(*it);
+      item_double_clicked (*it);
     }
 }
 
 void
 files_dock_widget::contextmenu_open_in_app (bool)
 {
   QItemSelectionModel *m = _file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
@@ -438,283 +459,298 @@ files_dock_widget::contextmenu_load (boo
 {
   QItemSelectionModel *m = _file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
   if (rows.size () > 0)
     {
       QModelIndex index = rows[0];
 
-      QFileInfo info = _file_system_model->fileInfo(index);
+      QFileInfo info = _file_system_model->fileInfo (index);
 
       emit load_file_signal (info.fileName ());
     }
 }
 
 void
 files_dock_widget::contextmenu_run (bool)
 {
   QItemSelectionModel *m = _file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
   if (rows.size () > 0)
     {
       QModelIndex index = rows[0];
 
-      QFileInfo info = _file_system_model->fileInfo(index);
+      QFileInfo info = _file_system_model->fileInfo (index);
       emit run_file_signal (info);
     }
 }
 
-void 
+void
 files_dock_widget::contextmenu_rename (bool)
 {
   QItemSelectionModel *m = _file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
-  if(rows.size() > 0)
+  if (rows.size () > 0)
     {
       QModelIndex index = rows[0];
 
-      QFileInfo info = _file_system_model->fileInfo(index);
-      QDir path = info.absoluteDir();
-      QString old_name = info.fileName();
+      QFileInfo info = _file_system_model->fileInfo (index);
+      QDir path = info.absoluteDir ();
+      QString old_name = info.fileName ();
       bool ok;
 
-      QString new_name = QInputDialog::getText (this, tr("Rename file/directory"), 
-                                                tr("Rename file/directory:\n") + old_name + tr("\n to: "),
-                                                QLineEdit::Normal, old_name, &ok);
-      if(ok && new_name.length()>0)
+      QString new_name
+        = QInputDialog::getText (this, tr ("Rename file/directory"),
+                                 tr ("Rename file/directory:\n")
+                                 + old_name + tr ("\n to: "),
+                                 QLineEdit::Normal, old_name, &ok);
+      if (ok && new_name.length () > 0)
         {
-          new_name = path.absolutePath() + "/" + new_name;
-          old_name = path.absolutePath() + "/" + old_name;
-          path.rename(old_name, new_name);
-          _file_system_model->revert();
+          new_name = path.absolutePath () + "/" + new_name;
+          old_name = path.absolutePath () + "/" + old_name;
+          path.rename (old_name, new_name);
+          _file_system_model->revert ();
         }
     }
 
 }
 
-void 
+void
 files_dock_widget::contextmenu_delete (bool)
 {
   QItemSelectionModel *m = _file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
-  for( QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
+  for ( QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
     {
       QModelIndex index = *it;
 
-      QFileInfo info = _file_system_model->fileInfo(index);
-
-      if(QMessageBox::question(this, tr("Delete file/directory"), 
-                               tr("Are you sure you want to delete\n") + info.filePath(),
-                               QMessageBox::Yes|QMessageBox::No) == QMessageBox::Yes) 
-        {
-           if(info.isDir())
-             {
-               // see if direcory is empty
-               QDir path(info.absoluteFilePath());
-               QList<QFileInfo> fileLst = path.entryInfoList(QDir::AllEntries | QDir::NoDotAndDotDot);
+      QFileInfo info = _file_system_model->fileInfo (index);
 
-               if(fileLst.count() != 0)
-                 QMessageBox::warning(this, tr("Delete file/directory"),
-                                      tr("Can not delete a directory that is not empty"));
-               else
-                 _file_system_model->rmdir(index);
-             }
-           else
-             {
-               _file_system_model->remove(index);
-             }
+      if (QMessageBox::question (this, tr ("Delete file/directory"),
+                                 tr ("Are you sure you want to delete\n")
+                                 + info.filePath (),
+                                 QMessageBox::Yes|QMessageBox::No)
+          == QMessageBox::Yes)
+        {
+          if (info.isDir ())
+            {
+              // see if direcory is empty
+              QDir path (info.absoluteFilePath ());
+              QList<QFileInfo> fileLst = path.entryInfoList (QDir::AllEntries |
+                                         QDir::NoDotAndDotDot);
 
-           _file_system_model->revert();
+              if (fileLst.count () != 0)
+                QMessageBox::warning (this, tr ("Delete file/directory"),
+                                      tr ("Can not delete a directory that is not empty"));
+              else
+                _file_system_model->rmdir (index);
+            }
+          else
+            {
+              _file_system_model->remove (index);
+            }
+
+          _file_system_model->revert ();
 
         }
     }
 }
 
-void 
+void
 files_dock_widget::contextmenu_newfile (bool)
 {
   QItemSelectionModel *m = _file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
-  if(rows.size() > 0)
+  if (rows.size () > 0)
     {
       QModelIndex index = rows[0];
 
-      QFileInfo info = _file_system_model->fileInfo(index);
-      QString parent_dir = info.filePath();
+      QFileInfo info = _file_system_model->fileInfo (index);
+      QString parent_dir = info.filePath ();
 
-      process_new_file(parent_dir);
+      process_new_file (parent_dir);
     }
 }
 
-void 
+void
 files_dock_widget::contextmenu_newdir (bool)
 {
   QItemSelectionModel *m = _file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
-  if(rows.size() > 0)
+  if (rows.size () > 0)
     {
       QModelIndex index = rows[0];
 
-      QFileInfo info = _file_system_model->fileInfo(index);
-      QString parent_dir = info.filePath();
+      QFileInfo info = _file_system_model->fileInfo (index);
+      QString parent_dir = info.filePath ();
 
-      process_new_dir(parent_dir);
+      process_new_dir (parent_dir);
     }
 }
 
-void 
+void
 files_dock_widget::contextmenu_setcurrentdir (bool)
 {
   QItemSelectionModel *m = _file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
-  if(rows.size() > 0)
+  if (rows.size () > 0)
     {
       QModelIndex index = rows[0];
 
-      QFileInfo info = _file_system_model->fileInfo(index);
+      QFileInfo info = _file_system_model->fileInfo (index);
 
-      if(info.isDir())
+      if (info.isDir ())
         {
-          process_set_current_dir(info.absoluteFilePath ());
+          process_set_current_dir (info.absoluteFilePath ());
         }
     }
 }
 
-void 
+void
 files_dock_widget::contextmenu_findfiles (bool)
 {
   QItemSelectionModel *m = _file_tree_view->selectionModel ();
   QModelIndexList rows = m->selectedRows ();
 
-  if(rows.size() > 0)
+  if (rows.size () > 0)
     {
       QModelIndex index = rows[0];
 
-      QFileInfo info = _file_system_model->fileInfo(index);
+      QFileInfo info = _file_system_model->fileInfo (index);
 
-      if(info.isDir())
+      if (info.isDir ())
         {
-          process_find_files(info.absoluteFilePath ());
+          process_find_files (info.absoluteFilePath ());
         }
     }
 }
 
 void
 files_dock_widget::notice_settings (const QSettings *settings)
 {
   // Qsettings pointer is checked before emitting.
 
   int icon_size = settings->value ("toolbar_icon_size",24).toInt ();
   if (icon_size > 16)
     icon_size = icon_size - 4;
   _navigation_tool_bar->setIconSize (QSize (icon_size,icon_size));
 
   // file names are always shown, other columns can be hidden by settings
   _file_tree_view->setColumnHidden (0, false);
-  _file_tree_view->setColumnHidden (1, !settings->value ("filesdockwidget/showFileSize",false).toBool ());
-  _file_tree_view->setColumnHidden (2, !settings->value ("filesdockwidget/showFileType",false).toBool ());
-  _file_tree_view->setColumnHidden (3, !settings->value ("filesdockwidget/showLastModified",false).toBool ());
-  _file_tree_view->setAlternatingRowColors (settings->value ("filesdockwidget/useAlternatingRowColors",true).toBool ());
+  _file_tree_view->setColumnHidden (1,
+    !settings->value ("filesdockwidget/showFileSize",false).toBool ());
+  _file_tree_view->setColumnHidden (2,
+    !settings->value ("filesdockwidget/showFileType",false).toBool ());
+  _file_tree_view->setColumnHidden (3,
+    !settings->value ("filesdockwidget/showLastModified",false).toBool ());
+  _file_tree_view->setAlternatingRowColors (
+    settings->value ("filesdockwidget/useAlternatingRowColors",true).toBool ());
   if (settings->value ("filesdockwidget/showHiddenFiles",false).toBool ())
     {
       // TODO: React on option for hidden files.
     }
-  // enalbe the buttons to sync octave/browser dir only if this is not done by default
-  _sync_octave_dir = settings->value ("filesdockwidget/sync_octave_directory",false).toBool ();
+  // enable the buttons to sync octave/browser dir
+  // only if this is not done by default
+  _sync_octave_dir
+    = settings->value ("filesdockwidget/sync_octave_directory",false).toBool ();
   _sync_octave_directory_action->setEnabled (!_sync_octave_dir);
   _sync_browser_directory_action->setEnabled (!_sync_octave_dir);
 
   if (_sync_octave_dir)
     display_directory (_octave_dir);  // sync browser to octave dir
 
 }
 
 void
 files_dock_widget::popdownmenu_home (bool)
 {
   QString dir = qgetenv ("HOME");
-  if (dir.isEmpty())
+  if (dir.isEmpty ())
     dir = QDir::homePath ();
-  
+
   set_current_directory (dir);
 }
 
 void
 files_dock_widget::popdownmenu_search_dir (bool)
 {
   QString dir = QFileDialog::getExistingDirectory
-    (this, tr ("Set directory of file browser"),_file_system_model->rootPath(),
-     QFileDialog::DontUseNativeDialog);
+                  (this, tr ("Set directory of file browser"),
+                   _file_system_model->rootPath (),
+                   QFileDialog::DontUseNativeDialog);
   set_current_directory (dir);
 }
 
 void
 files_dock_widget::popdownmenu_findfiles (bool)
 {
-      process_find_files(_file_system_model->rootPath());
+  process_find_files (_file_system_model->rootPath ());
 }
 
 void
 files_dock_widget::popdownmenu_newdir (bool)
 {
-      process_new_dir(_file_system_model->rootPath());
+  process_new_dir (_file_system_model->rootPath ());
 }
 
 void
 files_dock_widget::popdownmenu_newfile (bool)
 {
-      process_new_file(_file_system_model->rootPath());
+  process_new_file (_file_system_model->rootPath ());
 }
 
 void
 files_dock_widget::process_new_file (const QString &parent_dir)
 {
   bool ok;
 
-  QString name = QInputDialog::getText (this, tr("Create File"), tr("Create file in\n") + parent_dir,
-                                       QLineEdit::Normal, "New File.txt", &ok);
-  if(ok && name.length()>0)
+  QString name = QInputDialog::getText (this, tr ("Create File"),
+                                        tr ("Create file in\n") + parent_dir,
+                                        QLineEdit::Normal, "New File.txt", &ok);
+  if (ok && name.length () > 0)
     {
       name = parent_dir + "/" + name;
 
-      QFile file(name);
-      file.open(QIODevice::WriteOnly);
-      _file_system_model->revert();
+      QFile file (name);
+      file.open (QIODevice::WriteOnly);
+      _file_system_model->revert ();
     }
 }
 
 void
 files_dock_widget::process_new_dir (const QString &parent_dir)
 {
   bool ok;
 
-  QString name = QInputDialog::getText (this, tr("Create Directory"), tr("Create folder in\n") + parent_dir,
-                                       QLineEdit::Normal, "New Directory", &ok);
-  if(ok && name.length()>0)
+  QString name = QInputDialog::getText (this, tr ("Create Directory"),
+                                        tr ("Create folder in\n") + parent_dir,
+                                        QLineEdit::Normal, "New Directory",
+                                        &ok);
+  if (ok && name.length () > 0)
     {
-     QDir dir(parent_dir);
-      dir.mkdir(name);
-      _file_system_model->revert();
+      QDir dir (parent_dir);
+      dir.mkdir (name);
+      _file_system_model->revert ();
     }
 }
 
-void files_dock_widget::process_set_current_dir(const QString & dir)
+void files_dock_widget::process_set_current_dir (const QString & dir)
 {
   emit displayed_directory_changed (dir);
 }
 
-void files_dock_widget::process_find_files(const QString & dir)
+void files_dock_widget::process_find_files (const QString & dir)
 {
-  emit find_files_signal(dir);
+  emit find_files_signal (dir);
 }
 
 void
 files_dock_widget::copyClipboard ()
 {
   if (_file_tree_view->hasFocus ())
     contextmenu_copy_selection (true);
   if (_current_directory->hasFocus ())
@@ -732,15 +768,15 @@ files_dock_widget::copyClipboard ()
 void
 files_dock_widget::pasteClipboard ()
 {
   if (_current_directory->hasFocus ())
     {
       QClipboard *clipboard = QApplication::clipboard ();
       QString str =  clipboard->text ();
       QLineEdit * edit = _current_directory->lineEdit ();
-      if (edit && str.length () > 0) 
+      if (edit && str.length () > 0)
         edit->insert (str);
     }
 }
 
 
 
diff --git a/libgui/src/files-dock-widget.h b/libgui/src/files-dock-widget.h
--- a/libgui/src/files-dock-widget.h
+++ b/libgui/src/files-dock-widget.h
@@ -92,18 +92,18 @@ private slots:
   void contextmenu_rename (bool);
   void contextmenu_delete (bool);
   void contextmenu_newfile (bool);
   void contextmenu_newdir (bool);
   void contextmenu_setcurrentdir (bool);
   void contextmenu_findfiles (bool);
 
   /* popdown menu options */
-  void popdownmenu_newfile(bool);
-  void popdownmenu_newdir(bool);
+  void popdownmenu_newfile (bool);
+  void popdownmenu_newdir (bool);
   void popdownmenu_search_dir (bool);
   void popdownmenu_findfiles (bool);
   void popdownmenu_home (bool);
 
   /* from octave_doc_widget */
   void copyClipboard ();
   void pasteClipboard ();
 
@@ -120,20 +120,20 @@ signals:
 
   /** Emitted, whenever the user requested to run a file. */
   void run_file_signal (const QFileInfo& info);
 
   /** Emitted, whenever wants to search for a file . */
   void find_files_signal (const QString &startdir);
 
 private:
-  void process_new_file(const QString &parent_name);
-  void process_new_dir(const QString &parent_name);
-  void process_set_current_dir(const QString &parent_name);
-  void process_find_files(const QString &dir_name);
+  void process_new_file (const QString &parent_name);
+  void process_new_dir (const QString &parent_name);
+  void process_set_current_dir (const QString &parent_name);
+  void process_find_files (const QString &dir_name);
 
   /** set a new directory or open a file **/
   void display_directory (const QString& dir, bool set_octave_dir = true);
 
   void open_item_in_app (const QModelIndex& index);
 
   /** Variables for the actions **/
   QToolBar *        _navigation_tool_bar;
diff --git a/libgui/src/find-files-dialog.cc b/libgui/src/find-files-dialog.cc
--- a/libgui/src/find-files-dialog.cc
+++ b/libgui/src/find-files-dialog.cc
@@ -37,135 +37,148 @@ along with Octave; see the file COPYING.
 #include <QIcon>
 #include <QFileInfo>
 #include <QTimer>
 #include <QDirIterator>
 #include <QTextStream>
 #include <QGroupBox>
 
 find_files_dialog::find_files_dialog (QWidget * p)
- : QDialog (p)
+  : QDialog (p)
 {
-  setWindowTitle (tr("Find Files"));
+  setWindowTitle (tr ("Find Files"));
   setWindowIcon (QIcon (":/actions/icons/search.png"));
 
   _dir_iterator = 0;
 
   _timer = new QTimer (this);
-  connect(_timer, SIGNAL(timeout()), this, SLOT(look_for_files()));
+  connect (_timer, SIGNAL (timeout ()), this, SLOT (look_for_files ()));
 
   QSettings *settings = resource_manager::get_settings ();
 
   QLabel * file_name_label = new QLabel (tr ("Named:"));
   _file_name_edit = new QLineEdit;
   _file_name_edit->setToolTip (tr ("Enter the filename expression"));
 
-  _file_name_edit->setText (settings->value ("findfiles/file_name","*").toString ());
+  _file_name_edit->setText (settings->value ("findfiles/file_name",
+                                             "*").toString ());
   file_name_label->setBuddy (_file_name_edit);
 
   QLabel * start_dir_label = new QLabel (tr ("Start in:"));
 
   _start_dir_edit = new QLineEdit;
-  _start_dir_edit->setText (settings->value ("findfiles/start_dir",QDir::currentPath()).toString());
+  _start_dir_edit->setText (settings->value ("findfiles/start_dir",
+                            QDir::currentPath ()).toString ());
   _start_dir_edit->setToolTip (tr ("Enter the start directory"));
   start_dir_label->setBuddy (_start_dir_edit);
 
   _browse_button = new QPushButton (tr ("Browse..."));
   _browse_button->setToolTip (tr ("Browse for start directory"));
-  connect(_browse_button, SIGNAL(clicked()), this, SLOT(browse_folders()));
+  connect (_browse_button, SIGNAL (clicked ()), this, SLOT (browse_folders ()));
 
   _recurse_dirs_check = new QCheckBox (tr ("Recurse directories"));
-  _recurse_dirs_check->setChecked (settings->value ("findfiles/recurse_dirs", false).toBool());
-  _recurse_dirs_check->setToolTip (tr ("Search recursively through directories for matching files"));
+  _recurse_dirs_check->setChecked (settings->value ("findfiles/recurse_dirs",
+                                                    false).toBool ());
+  _recurse_dirs_check->setToolTip (
+    tr ("Search recursively through directories for matching files"));
 
   _include_dirs_check = new QCheckBox (tr ("Include directories"));
-  _include_dirs_check->setChecked (settings->value ("findfiles/include_dirs", false).toBool());
-  _include_dirs_check->setToolTip (tr ("Include matching directories in search results"));
+  _include_dirs_check->setChecked (settings->value ("findfiles/include_dirs",
+                                                    false).toBool ());
+  _include_dirs_check->setToolTip (
+    tr ("Include matching directories in search results"));
 
   _name_case_check = new QCheckBox (tr ("Name case insensitive"));
-  _name_case_check->setChecked (settings->value ("findfiles/name_case", false).toBool());
+  _name_case_check->setChecked (settings->value ("findfiles/name_case",
+                                                 false).toBool ());
   _name_case_check->setToolTip (tr ("Set matching name is case insensitive"));
 
-  _contains_text_check = new QCheckBox (tr("Contains text:"));
+  _contains_text_check = new QCheckBox (tr ("Contains text:"));
   _contains_text_check->setToolTip (tr ("Search must match text"));
-  _contains_text_check->setChecked (settings->value ("findfiles/check_text", false).toBool());
+  _contains_text_check->setChecked (settings->value ("findfiles/check_text",
+                                                      false).toBool ());
 
   _contains_text_edit = new QLineEdit ();
   _contains_text_edit->setToolTip (tr ("Text to match"));
-  _contains_text_edit->setText (settings->value ("findfiles/contains_text", "").toString());
+  _contains_text_edit->setText (settings->value ("findfiles/contains_text",
+                                                 "").toString ());
 
-  _content_case_check = new QCheckBox (tr("Text case insensitive"));
-  _content_case_check->setChecked (settings->value ("findfiles/content_case", false).toBool());
+  _content_case_check = new QCheckBox (tr ("Text case insensitive"));
+  _content_case_check->setChecked (settings->value ("findfiles/content_case",
+                                                    false).toBool ());
   _content_case_check->setToolTip (tr ("Set text content is case insensitive"));
-  
+
   find_files_model * model = new find_files_model (this);
 
   _file_list = new QTableView;
   _file_list->setWordWrap (false);
   _file_list->setModel (model);
   _file_list->setShowGrid (false);
-  _file_list->setSelectionBehavior(QAbstractItemView::SelectRows);
-  _file_list->setSelectionMode(QAbstractItemView::SingleSelection);
-  _file_list->setAlternatingRowColors(true);
+  _file_list->setSelectionBehavior (QAbstractItemView::SelectRows);
+  _file_list->setSelectionMode (QAbstractItemView::SingleSelection);
+  _file_list->setAlternatingRowColors (true);
   _file_list->setToolTip (tr ("Search results"));
   _file_list->setSortingEnabled (true);
-  _file_list->horizontalHeader ()->restoreState (settings->value ("findfiles/column_state").toByteArray ());
+  _file_list->horizontalHeader ()->restoreState (
+    settings->value ("findfiles/column_state").toByteArray ());
   _file_list->horizontalHeader ()->setSortIndicatorShown (true);
   _file_list->horizontalHeader ()->setClickable (true);
   _file_list->horizontalHeader ()->setStretchLastSection (true);
   _file_list->sortByColumn (
-              settings->value ("findfiles/sort_files_by_column",0).toInt (),
-              static_cast<Qt::SortOrder>(settings->value ("findfiles/sort_files_by_order",Qt::AscendingOrder).toUInt ()));
+                settings->value ("findfiles/sort_files_by_column",0).toInt (),
+                static_cast<Qt::SortOrder>
+                  (settings->value ("findfiles/sort_files_by_order",
+                                    Qt::AscendingOrder).toUInt ()));
 
-  connect (_file_list, SIGNAL(doubleClicked(const QModelIndex&)),
-           this,       SLOT(item_double_clicked(const QModelIndex &)));
+  connect (_file_list, SIGNAL (doubleClicked (const QModelIndex&)),
+           this,       SLOT (item_double_clicked (const QModelIndex &)));
 
   _status_bar = new QStatusBar;
-  _status_bar->showMessage (tr("Idle."));
+  _status_bar->showMessage (tr ("Idle."));
 
-  _find_button =  new QPushButton (tr("Find"));
+  _find_button =  new QPushButton (tr ("Find"));
   _find_button->setToolTip (tr ("Start search for matching files"));
-  connect (_find_button, SIGNAL(clicked()), this, SLOT(start_find()));
+  connect (_find_button, SIGNAL (clicked ()), this, SLOT (start_find ()));
 
-  _stop_button =  new QPushButton (tr("Stop"));
+  _stop_button =  new QPushButton (tr ("Stop"));
   _stop_button->setToolTip (tr ("Stop searching"));
   _stop_button->setEnabled (false);
-  connect (_stop_button, SIGNAL(clicked()), this, SLOT(stop_find()));
+  connect (_stop_button, SIGNAL (clicked ()), this, SLOT (stop_find ()));
 
   // layout everything
   QDialogButtonBox * button_box = new QDialogButtonBox (Qt::Vertical);
   button_box->addButton (_find_button, QDialogButtonBox::ActionRole);
   button_box->addButton (_stop_button, QDialogButtonBox::ActionRole);
 
   // add dialog close button
   _close_button = button_box->addButton (QDialogButtonBox::Close);
   connect (button_box,    SIGNAL (rejected ()),
            this,          SLOT (close ()));
 
   // name options
-  QGroupBox * name_group = new QGroupBox(tr("File name/location"));
+  QGroupBox * name_group = new QGroupBox (tr ("File name/location"));
   QGridLayout * name_layout = new QGridLayout;
-  name_group->setLayout(name_layout);
+  name_group->setLayout (name_layout);
 
   name_layout->addWidget (file_name_label,1,1, 1,1);
   name_layout->addWidget (_file_name_edit,1,2, 1,-1);
 
   name_layout->addWidget (start_dir_label,2,1);
   name_layout->addWidget (_start_dir_edit,2,2,1,3);
   name_layout->addWidget (_browse_button,2,5);
   name_layout->setColumnStretch (2,1);
 
   name_layout->addWidget (_recurse_dirs_check,3,1);
   name_layout->addWidget (_include_dirs_check,3,2);
   name_layout->addWidget (_name_case_check,3,3);
 
   // content options
-  QGroupBox * content_group = new QGroupBox(tr("File contents"));
+  QGroupBox * content_group = new QGroupBox (tr ("File contents"));
   QGridLayout * content_layout = new QGridLayout;
-  content_group->setLayout(content_layout);
+  content_group->setLayout (content_layout);
   content_layout->addWidget (_contains_text_check,4,1);
   content_layout->addWidget (_contains_text_edit,4,2,1,3);
   content_layout->setColumnStretch (2,1);
   content_layout->addWidget (_content_case_check,5,1);
 
   QGridLayout *main_layout = new QGridLayout;
   main_layout->setSizeConstraint (QLayout::SetFixedSize);
   main_layout->addWidget (name_group, 0, 0);
@@ -173,100 +186,106 @@ find_files_dialog::find_files_dialog (QW
   main_layout->addWidget (button_box, 0, 1,3,1);
   main_layout->addWidget (_file_list,2,0);
   main_layout->setRowStretch (2,1);
   main_layout->addWidget (_status_bar,3,0,1,-1);
 
 
   setLayout (main_layout);
 
-  connect (this, SIGNAL(finished(int)), this, SLOT(handle_done(int)));
+  connect (this, SIGNAL (finished (int)), this, SLOT (handle_done (int)));
 }
 
 find_files_dialog::~find_files_dialog ()
 {
   QSettings *settings = resource_manager::get_settings ();
 
   int sort_column = _file_list->horizontalHeader ()->sortIndicatorSection ();
-  Qt::SortOrder sort_order = _file_list->horizontalHeader ()->sortIndicatorOrder ();
+  Qt::SortOrder sort_order
+    = _file_list->horizontalHeader ()->sortIndicatorOrder ();
   settings->setValue ("findfiles/sort_files_by_column", sort_column);
   settings->setValue ("findfiles/sort_files_by_order", sort_order);
-  settings->setValue ("findfiles/column_state", _file_list->horizontalHeader ()->saveState ());
+  settings->setValue ("findfiles/column_state",
+                      _file_list->horizontalHeader ()->saveState ());
 
-  settings->setValue ("findfiles/file_name", _file_name_edit->text());
+  settings->setValue ("findfiles/file_name", _file_name_edit->text ());
 
-  settings->setValue ("findfiles/start_dir", _start_dir_edit->text());
+  settings->setValue ("findfiles/start_dir", _start_dir_edit->text ());
 
-  settings->setValue ("findfiles/recurse_dirs", _recurse_dirs_check->text());
-  settings->setValue ("findfiles/include_dirs", _include_dirs_check->text());
-  settings->setValue ("findfiles/name_case", _name_case_check->text());
+  settings->setValue ("findfiles/recurse_dirs", _recurse_dirs_check->text ());
+  settings->setValue ("findfiles/include_dirs", _include_dirs_check->text ());
+  settings->setValue ("findfiles/name_case", _name_case_check->text ());
 
-  settings->setValue ("findfiles/contains_text", _contains_text_edit->text());
-  settings->setValue ("findfiles/check_text", _contains_text_check->isChecked ());
-  settings->setValue ("findfiles/content_case", _content_case_check->isChecked ());
+  settings->setValue ("findfiles/contains_text", _contains_text_edit->text ());
+  settings->setValue ("findfiles/check_text",
+                      _contains_text_check->isChecked ());
+  settings->setValue ("findfiles/content_case",
+                      _content_case_check->isChecked ());
 
   settings->sync ();
 
-  if(_dir_iterator)
+  if (_dir_iterator)
     delete _dir_iterator;
 }
 
 void find_files_dialog::handle_done (int)
 {
-  // make sure we stopped processing 
+  // make sure we stopped processing
   stop_find ();
 }
 
-void find_files_dialog::set_search_dir(const QString &dir)
+void find_files_dialog::set_search_dir (const QString &dir)
 {
-  stop_find();
-  _start_dir_edit->setText(dir);
+  stop_find ();
+  _start_dir_edit->setText (dir);
 }
 
-void 
+void
 find_files_dialog::start_find ()
 {
-  stop_find();
+  stop_find ();
 
-  find_files_model *m = static_cast<find_files_model *> (_file_list->model());
-  m->clear();
+  find_files_model *m = static_cast<find_files_model *> (_file_list->model ());
+  m->clear ();
 
   QDirIterator::IteratorFlags flags = QDirIterator::NoIteratorFlags;
-  if (_recurse_dirs_check->isChecked ())  flags |= QDirIterator::Subdirectories;
+  if (_recurse_dirs_check->isChecked ())
+    flags |= QDirIterator::Subdirectories;
 
   QDir::Filters filters = QDir::Dirs|QDir::NoDotAndDotDot|QDir::Files;
   if (!_name_case_check->isChecked ())
     filters |=  QDir::CaseSensitive;
 
   QStringList nameFilters;
-  nameFilters.append (_file_name_edit->text());
+  nameFilters.append (_file_name_edit->text ());
 
   if (_dir_iterator) delete _dir_iterator;
 
-  _dir_iterator = new QDirIterator (_start_dir_edit->text(), nameFilters, filters, flags);
-  
-  // enable/disable widgets 
+  _dir_iterator = new QDirIterator (_start_dir_edit->text (), nameFilters,
+                                    filters, flags);
+
+  // enable/disable widgets
   _find_button->setEnabled (false);
   _stop_button->setEnabled (true);
   _close_button->setEnabled (false);
   _browse_button->setEnabled (false);
   _start_dir_edit->setEnabled (false);
   _file_name_edit->setEnabled (false);
   _recurse_dirs_check->setEnabled (false);
   _include_dirs_check->setEnabled (false);
   _name_case_check->setEnabled (false);
   _contains_text_check->setEnabled (false);
   _content_case_check->setEnabled (false);
   _contains_text_edit->setEnabled (false);
 
-  _status_bar->showMessage (tr("Searching..."));
+  _status_bar->showMessage (tr ("Searching..."));
   _timer->start (0);
 }
 
-void 
+void
 find_files_dialog::stop_find ()
 {
   _timer->stop ();
 
   _find_button->setEnabled (true);
   _stop_button->setEnabled (false);
   _close_button->setEnabled (true);
   _browse_button->setEnabled (true);
@@ -274,107 +293,108 @@ find_files_dialog::stop_find ()
   _file_name_edit->setEnabled (true);
   _recurse_dirs_check->setEnabled (true);
   _include_dirs_check->setEnabled (true);
   _name_case_check->setEnabled (true);
   _contains_text_check->setEnabled (true);
   _content_case_check->setEnabled (true);
   _contains_text_edit->setEnabled (true);
 
-  find_files_model *m = static_cast<find_files_model *> (_file_list->model());
-  QString res_str = QString ("%1 matches").arg(m->rowCount());
+  find_files_model *m = static_cast<find_files_model *> (_file_list->model ());
+  QString res_str = QString ("%1 matches").arg (m->rowCount ());
 
   _status_bar->showMessage (res_str);
 }
 
-void 
+void
 find_files_dialog::browse_folders ()
 {
   QString dir =
-    QFileDialog::getExistingDirectory (this, tr ("Set search directory"), 
-      _start_dir_edit->text());
+    QFileDialog::getExistingDirectory (this, tr ("Set search directory"),
+                                       _start_dir_edit->text ());
 
   if (! dir.isEmpty ())
     {
       _start_dir_edit->setText (dir);
     }
 }
 
-void 
+void
 find_files_dialog::item_double_clicked (const QModelIndex &idx)
 {
   find_files_model *m = static_cast<find_files_model *> (_file_list->model ());
 
   QFileInfo info = m->fileInfo (idx);
 
-  if(idx.column () == 1)
+  if (idx.column () == 1)
     {
       // clicked in directory part
-      emit dir_selected (info.absolutePath());
+      emit dir_selected (info.absolutePath ());
     }
   else
     {
       // clicked in filename part
-      if(info.isDir ())
-        emit dir_selected (info.absoluteFilePath());
+      if (info.isDir ())
+        emit dir_selected (info.absoluteFilePath ());
       else
-        emit file_selected (info.absoluteFilePath());
+        emit file_selected (info.absoluteFilePath ());
     }
 }
 
 void
 find_files_dialog::look_for_files ()
 {
-  if(_dir_iterator && _dir_iterator->hasNext ())
+  if (_dir_iterator && _dir_iterator->hasNext ())
     {
       QFileInfo info (_dir_iterator->next ());
-    
-      find_files_model *m = static_cast<find_files_model *> (_file_list->model ());
+
+      find_files_model *m
+        = static_cast<find_files_model *> (_file_list->model ());
 
-      if(is_match (info))
+      if (is_match (info))
         m->addFile (info);
-    } 
+    }
   else
     {
-      stop_find (); 
+      stop_find ();
     }
 }
 
 bool find_files_dialog::is_match (const QFileInfo &info)
 {
   bool match = true;
   if (info.isDir ())
     {
-      if(!_include_dirs_check->isChecked ()) match = false;
-      if(_contains_text_check->isChecked ()) match = false;
+      if (!_include_dirs_check->isChecked ()) match = false;
+      if (_contains_text_check->isChecked ()) match = false;
     }
   else
     {
       // a file
       if (_contains_text_check->isChecked ())
         {
           match = false;
 
-          QFile file(info.absoluteFilePath ());
+          QFile file (info.absoluteFilePath ());
           if (file.open (QIODevice::ReadOnly))
             {
               QTextStream stream (&file);
 
               QString line;
               QString match_str = _contains_text_edit->text ();
 
               Qt::CaseSensitivity cs = _content_case_check->isChecked () ?
-                   Qt::CaseInsensitive : Qt::CaseSensitive;
+                                       Qt::CaseInsensitive : Qt::CaseSensitive;
 
               do
                 {
                   line = stream.readLine ();
                   match = line.contains (match_str, cs);
                 }
-              while(!line.isNull () && match == false);
+              while (!line.isNull () && match == false);
             }
 
         }
     }
 
-  return match; 
+  return match;
 }
 
diff --git a/libgui/src/find-files-dialog.h b/libgui/src/find-files-dialog.h
--- a/libgui/src/find-files-dialog.h
+++ b/libgui/src/find-files-dialog.h
@@ -41,27 +41,27 @@ public:
   find_files_dialog (QWidget * parent=0);
   virtual ~find_files_dialog ();
 
 signals:
   void file_selected (const QString &fileName);
   void dir_selected (const QString &fileName);
 
 public slots:
-  void set_search_dir(const QString &dir);
+  void set_search_dir (const QString &dir);
 
 private slots:
   void start_find ();
   void stop_find ();
   void browse_folders ();
   void look_for_files ();
   void item_double_clicked (const QModelIndex&);
-  void handle_done(int);
+  void handle_done (int);
 private:
-  bool is_match(const QFileInfo &info);
+  bool is_match (const QFileInfo &info);
   QLineEdit * _start_dir_edit;
   QLineEdit * _file_name_edit;
   QPushButton * _stop_button;
   QPushButton * _find_button;
   QPushButton * _close_button;
   QPushButton * _browse_button;
   QTableView   * _file_list;
   QTimer      * _timer;
diff --git a/libgui/src/find-files-model.cc b/libgui/src/find-files-model.cc
--- a/libgui/src/find-files-model.cc
+++ b/libgui/src/find-files-model.cc
@@ -28,156 +28,158 @@ class find_file_less_than
 {
 public:
   find_file_less_than (int ord)
   {
     _sortorder = ord;
   }
   QVariant getValue (const QFileInfo &f) const
   {
-     QVariant val;
-     int col = (_sortorder > 0) ? _sortorder : -_sortorder;
+    QVariant val;
+    int col = (_sortorder > 0) ? _sortorder : -_sortorder;
 
-     switch (col-1)
-       {
-         case 0:
-           val = QVariant (f.fileName());
-           break;
+    switch (col-1)
+      {
+      case 0:
+        val = QVariant (f.fileName ());
+        break;
 
-         case 1:
-           val = QVariant (f.absolutePath());
-           break;
+      case 1:
+        val = QVariant (f.absolutePath ());
+        break;
 
-         default:
-            break;
-        }
-     return val;
+      default:
+        break;
+      }
+    return val;
   }
   bool lessThan (const QVariant &left, const QVariant &right) const
   {
-    return left.toString ().compare (right.toString (), Qt::CaseInsensitive) < 0;
+    return
+      left.toString ().compare (right.toString (), Qt::CaseInsensitive) < 0;
   }
   bool operator () (const QFileInfo &left, const QFileInfo &right) const
   {
-     QVariant leftval = getValue(left);
-     QVariant rightval = getValue(right);
+    QVariant leftval = getValue (left);
+    QVariant rightval = getValue (right);
 
-     if (_sortorder > 0)
-        return lessThan(leftval, rightval);
-     else
-        return ! lessThan(leftval, rightval);
+    if (_sortorder > 0)
+      return lessThan (leftval, rightval);
+    else
+      return ! lessThan (leftval, rightval);
   }
 private:
   int _sortorder;
 };
 
 
 find_files_model::find_files_model (QObject *p)
-  : QAbstractListModel(p)
+  : QAbstractListModel (p)
 {
   _columnNames.append (tr ("Filename"));
   _columnNames.append (tr ("Directory"));
   _sortorder = 0;
 }
 
 find_files_model::~find_files_model ()
 {
 }
 
-void 
+void
 find_files_model::clear ()
 {
-  beginResetModel();
+  beginResetModel ();
 
-  _files.clear();
+  _files.clear ();
 
   endResetModel ();
 }
 
-void 
+void
 find_files_model::addFile (const QFileInfo &info)
 {
   beginInsertRows (QModelIndex (), _files.size (), _files.size () );
 
-  QList<QFileInfo>::Iterator it; 
-  find_file_less_than less_than(_sortorder);
+  QList<QFileInfo>::Iterator it;
+  find_file_less_than less_than (_sortorder);
 
-  for (it=_files.begin ();it!=_files.end ();it++)
+  for (it=_files.begin (); it!=_files.end (); it++)
     {
       if (less_than (info, *it)) break;
     }
 
   _files.insert (it, info);
 
-  endInsertRows (); 
+  endInsertRows ();
 }
 
-int 
+int
 find_files_model::rowCount (const QModelIndex &) const
 {
-  return _files.size();
+  return _files.size ();
 }
 
-int 
+int
 find_files_model::columnCount (const QModelIndex &) const
 {
   return _columnNames.size ();
 }
 
-QVariant 
+QVariant
 find_files_model::data (const QModelIndex& idx, int role) const
 {
   QVariant retval;
 
   if (idx.isValid ())
     {
-      if(role == Qt::DisplayRole)
-      {
-        switch (idx.column ())
-          {
-          case 0:
-            retval = QVariant (_files[idx.row()].fileName());
-            break;
+      if (role == Qt::DisplayRole)
+        {
+          switch (idx.column ())
+            {
+            case 0:
+              retval = QVariant (_files[idx.row ()].fileName ());
+              break;
 
-          case 1:
-            retval = QVariant (_files[idx.row()].absolutePath());
-            break;
+            case 1:
+              retval = QVariant (_files[idx.row ()].absolutePath ());
+              break;
 
-          default:
-            break;
-          }
-      }
-      else if(role == Qt:: DecorationRole)
-      {
-        switch (idx.column())
-          {
-          case 0:
-            retval = fileIcon(idx);
-          default:
-            break;
-          }
-      }
+            default:
+              break;
+            }
+        }
+      else if (role == Qt:: DecorationRole)
+        {
+          switch (idx.column ())
+            {
+            case 0:
+              retval = fileIcon (idx);
+            default:
+              break;
+            }
+        }
     }
 
   return retval;
 }
 
-QVariant 
-find_files_model::headerData (int section, Qt::Orientation orientation, int role) const
+QVariant
+find_files_model::headerData (int section, Qt::Orientation orientation,
+                              int role) const
 {
   if (orientation == Qt::Horizontal && role == Qt::DisplayRole)
     return _columnNames[section];
   else
     return QVariant ();
 }
 
 void
 find_files_model::sort (int column, Qt::SortOrder order)
 {
-  if(column >= 0)
+  if (column >= 0)
     {
       if (order == Qt::DescendingOrder)
         _sortorder = -(column+1);
       else
         _sortorder = column+1;
     }
   else
     _sortorder = 0;
@@ -185,28 +187,28 @@ find_files_model::sort (int column, Qt::
   if (_sortorder != 0)
     {
       beginResetModel ();
       qSort (_files.begin (), _files.end (), find_file_less_than (_sortorder));
       endResetModel ();
     }
 }
 
-QFileInfo 
+QFileInfo
 find_files_model::fileInfo (const QModelIndex & p) const
 {
-  if(p.isValid ())
-  {
-    return _files[p.row()];
-  }
+  if (p.isValid ())
+    {
+      return _files[p.row ()];
+    }
   return QFileInfo ();
 }
 
 QIcon
 find_files_model::fileIcon (const QModelIndex &p) const
 {
   QFileIconProvider icon_provider;
-  if(p.isValid ())
-  {
-    return icon_provider.icon (_files[p.row()]);
-  }
+  if (p.isValid ())
+    {
+      return icon_provider.icon (_files[p.row ()]);
+    }
   return QIcon ();
 }
diff --git a/libgui/src/find-files-model.h b/libgui/src/find-files-model.h
--- a/libgui/src/find-files-model.h
+++ b/libgui/src/find-files-model.h
@@ -29,26 +29,26 @@ along with Octave; see the file COPYING.
 #include <QIcon>
 
 
 class find_files_model : public QAbstractListModel
 {
   Q_OBJECT
 
 public:
-  find_files_model(QObject *p=0);
+  find_files_model (QObject *p=0);
   ~find_files_model ();
 
-  void clear();
+  void clear ();
 
-  void addFile(const QFileInfo &info);
+  void addFile (const QFileInfo &info);
 
-  int rowCount(const QModelIndex & p=QModelIndex()) const;
+  int rowCount (const QModelIndex & p=QModelIndex ()) const;
 
-  int columnCount(const QModelIndex & p=QModelIndex()) const;
+  int columnCount (const QModelIndex & p=QModelIndex ()) const;
 
   QVariant data (const QModelIndex& idx, int role) const;
 
   QVariant headerData (int section, Qt::Orientation orientation,
                        int role = Qt::DisplayRole) const;
 
   void sort (int column, Qt::SortOrder order=Qt::AscendingOrder);
 
diff --git a/libgui/src/history-dock-widget.cc b/libgui/src/history-dock-widget.cc
--- a/libgui/src/history-dock-widget.cc
+++ b/libgui/src/history-dock-widget.cc
@@ -58,26 +58,30 @@ void
 history_dock_widget::construct ()
 {
   _history_model = new QStringListModel ();
   _sort_filter_proxy_model.setSourceModel (_history_model);
   _history_list_view = new QListView (this);
   _history_list_view->setModel (&_sort_filter_proxy_model);
   _history_list_view->setAlternatingRowColors (true);
   _history_list_view->setEditTriggers (QAbstractItemView::NoEditTriggers);
-  _history_list_view->setStatusTip (tr ("Doubleclick a command to transfer it to the terminal."));
+  _history_list_view->setStatusTip (
+    tr ("Doubleclick a command to transfer it to the terminal."));
   _history_list_view->setSelectionMode (QAbstractItemView::ExtendedSelection);
-  _history_list_view->setContextMenuPolicy(Qt::CustomContextMenu);
-  connect(_history_list_view, SIGNAL(customContextMenuRequested(const QPoint &)), this, SLOT(ctxMenu(const QPoint &)));
+  _history_list_view->setContextMenuPolicy (Qt::CustomContextMenu);
+  connect (_history_list_view,
+           SIGNAL (customContextMenuRequested (const QPoint &)), this,
+           SLOT (ctxMenu (const QPoint &)));
 
   _filter_line_edit = new QLineEdit (this);
-  _filter_line_edit->setStatusTip (tr ("Enter text to filter the command history."));
+  _filter_line_edit->setStatusTip (
+    tr ("Enter text to filter the command history."));
   QVBoxLayout *vbox_layout = new QVBoxLayout ();
 
-  setWindowIcon (QIcon(":/actions/icons/logo.png"));
+  setWindowIcon (QIcon (":/actions/icons/logo.png"));
   set_title (tr ("Command History"));
   setWidget (new QWidget ());
 
   vbox_layout->addWidget (_history_list_view);
   vbox_layout->addWidget (_filter_line_edit);
   vbox_layout->setMargin (2);
 
   widget ()->setLayout (vbox_layout);
@@ -86,53 +90,56 @@ history_dock_widget::construct ()
            &_sort_filter_proxy_model, SLOT (setFilterWildcard (QString)));
 
   connect (_history_list_view, SIGNAL (doubleClicked (QModelIndex)),
            this, SLOT (handle_double_click (QModelIndex)));
 
   setFocusProxy (_filter_line_edit);
 }
 
-void history_dock_widget::ctxMenu(const QPoint &xpos) {
-    QMenu menu(this);
-    menu.addAction(tr("Copy"), this, SLOT(handle_contextmenu_copy(bool)));
-    menu.addAction(tr("Evaluate"), this, SLOT(handle_contextmenu_evaluate(bool)));
-    menu.addAction(tr("Create script"), this, SLOT(handle_contextmenu_create_script(bool)));
-    menu.exec(_history_list_view->mapToGlobal(xpos));
+void history_dock_widget::ctxMenu (const QPoint &xpos)
+{
+  QMenu menu (this);
+  menu.addAction (tr ("Copy"), this, SLOT (handle_contextmenu_copy (bool)));
+  menu.addAction (tr ("Evaluate"), this,
+                  SLOT (handle_contextmenu_evaluate (bool)));
+  menu.addAction (tr ("Create script"), this,
+                  SLOT (handle_contextmenu_create_script (bool)));
+  menu.exec (_history_list_view->mapToGlobal (xpos));
 }
 
-void history_dock_widget::handle_contextmenu_copy(bool)
+void history_dock_widget::handle_contextmenu_copy (bool)
 {
   QString text;
-  QItemSelectionModel *selectionModel = _history_list_view->selectionModel();
-  QModelIndexList rows = selectionModel->selectedRows();
+  QItemSelectionModel *selectionModel = _history_list_view->selectionModel ();
+  QModelIndexList rows = selectionModel->selectedRows ();
   QModelIndexList::iterator it;
   bool prev_valid_row = false;
-  for (it = rows.begin(); it != rows.end(); it++)
+  for (it = rows.begin (); it != rows.end (); it++)
     {
-      if ((*it).isValid())
+      if ((*it).isValid ())
         {
           if (prev_valid_row)
             text += "\n";
-          text += (*it).data().toString();
+          text += (*it).data ().toString ();
           prev_valid_row = true;
         }
     }
-  QApplication::clipboard()->setText(text);
+  QApplication::clipboard ()->setText (text);
 }
 
-void history_dock_widget::handle_contextmenu_evaluate(bool)
+void history_dock_widget::handle_contextmenu_evaluate (bool)
 {
-  QItemSelectionModel *selectionModel = _history_list_view->selectionModel();
-  QModelIndexList rows = selectionModel->selectedRows();
+  QItemSelectionModel *selectionModel = _history_list_view->selectionModel ();
+  QModelIndexList rows = selectionModel->selectedRows ();
   QModelIndexList::iterator it;
-  for (it = rows.begin() ; it != rows.end(); it++)
+  for (it = rows.begin () ; it != rows.end (); it++)
     {
-      if ((*it).isValid())
-        emit command_double_clicked ((*it).data().toString());
+      if ((*it).isValid ())
+        emit command_double_clicked ((*it).data ().toString ());
     }
 }
 
 void
 history_dock_widget::handle_contextmenu_create_script (bool)
 {
   QString text;
   QItemSelectionModel *selectionModel = _history_list_view->selectionModel ();
@@ -140,30 +147,30 @@ history_dock_widget::handle_contextmenu_
 
   bool prev_valid_row = false;
   for (QModelIndexList::iterator it = rows.begin (); it != rows.end (); it++)
     {
       if ((*it).isValid ())
         {
           if (prev_valid_row)
             text += "\n";
-          text += (*it).data().toString();
+          text += (*it).data ().toString ();
           prev_valid_row = true;
         }
     }
 
   if (text.length () > 0)
     emit command_create_script (text);
 }
 
 
 void
 history_dock_widget::handle_double_click (QModelIndex modelIndex)
 {
-  emit command_double_clicked (modelIndex.data().toString());
+  emit command_double_clicked (modelIndex.data ().toString ());
 }
 
 void
 history_dock_widget::set_history (const QStringList& hist)
 {
   _history_model->setStringList (hist);
   _history_list_view->scrollToBottom ();
 }
@@ -189,29 +196,29 @@ void
 history_dock_widget::clear_history (void)
 {
   _history_model->setStringList (QStringList ());
 }
 
 void
 history_dock_widget::copyClipboard ()
 {
-  if(_history_list_view->hasFocus())
-    handle_contextmenu_copy(true);
-  if(_filter_line_edit->hasFocus () && _filter_line_edit->hasSelectedText ())
+  if (_history_list_view->hasFocus ())
+    handle_contextmenu_copy (true);
+  if (_filter_line_edit->hasFocus () && _filter_line_edit->hasSelectedText ())
     {
       QClipboard *clipboard = QApplication::clipboard ();
       clipboard->setText ( _filter_line_edit->selectedText ());
     }
 }
 
 void
 history_dock_widget::pasteClipboard ()
 {
-  if(_filter_line_edit->hasFocus ())
+  if (_filter_line_edit->hasFocus ())
     {
       QClipboard *clipboard = QApplication::clipboard ();
       QString str =  clipboard->text ();
-      if (str.length() > 0)
+      if (str.length () > 0)
         _filter_line_edit->insert (str);
     }
 }
 
diff --git a/libgui/src/history-dock-widget.h b/libgui/src/history-dock-widget.h
--- a/libgui/src/history-dock-widget.h
+++ b/libgui/src/history-dock-widget.h
@@ -52,20 +52,20 @@ signals:
 
   /** Emitted whenever the user selects command and chooses Create
       script from popupmenu. */
   void command_create_script (const QString& commands);
 
 private slots:
 
   void handle_double_click (QModelIndex modelIndex);
-  void handle_contextmenu_copy(bool flag);
-  void handle_contextmenu_evaluate(bool flag);
-  void handle_contextmenu_create_script(bool flag);
-  void ctxMenu(const QPoint &pos);
+  void handle_contextmenu_copy (bool flag);
+  void handle_contextmenu_evaluate (bool flag);
+  void handle_contextmenu_create_script (bool flag);
+  void ctxMenu (const QPoint &pos);
 
   void copyClipboard ();
   void pasteClipboard ();
 
 private:
 
   void construct ();
   QListView *_history_list_view;
diff --git a/libgui/src/m-editor/file-editor-interface.h b/libgui/src/m-editor/file-editor-interface.h
--- a/libgui/src/m-editor/file-editor-interface.h
+++ b/libgui/src/m-editor/file-editor-interface.h
@@ -26,17 +26,17 @@ along with Octave; see the file COPYING.
 #include <QMenu>
 #include <QToolBar>
 #include "octave-dock-widget.h"
 
 class file_editor_interface : public octave_dock_widget
 {
   Q_OBJECT
 
-  public:
+public:
   file_editor_interface (QWidget *p)
     : octave_dock_widget (p)
   {
     setObjectName ("FileEditor");
   }
 
   virtual ~file_editor_interface () { }
 
diff --git a/libgui/src/m-editor/file-editor-tab.cc b/libgui/src/m-editor/file-editor-tab.cc
--- a/libgui/src/m-editor/file-editor-tab.cc
+++ b/libgui/src/m-editor/file-editor-tab.cc
@@ -193,17 +193,17 @@ file_editor_tab::set_file_name (const QS
   emit editor_state_changed (_copy_available, _file_name);
   // add the new file to the mru list
 
   emit mru_add_file (_file_name);
 }
 
 void
 file_editor_tab::handle_margin_clicked (int margin, int line,
-                                       Qt::KeyboardModifiers state)
+                                        Qt::KeyboardModifiers state)
 {
   if (margin == 1)
     {
       unsigned int markers_mask = _edit_area->markersAtLine (line);
 
       if (state & Qt::ControlModifier)
         {
           if (markers_mask && (1 << bookmark))
@@ -263,44 +263,47 @@ file_editor_tab::update_lexer ()
         {
           lexer = new QsciLexerBatch ();
         }
       else if (_file_name.endsWith (".diff"))
         {
           lexer = new QsciLexerDiff ();
         }
       else if (_file_name.isEmpty ()
-                || _file_name.at (_file_name.count () - 1) == '/')
-        { // new, no yet named file: let us assume it is octave
+               || _file_name.at (_file_name.count () - 1) == '/')
+        {
+          // new, no yet named file: let us assume it is octave
 #if defined (HAVE_LEXER_OCTAVE)
           lexer = new QsciLexerOctave ();
 #elif defined (HAVE_LEXER_MATLAB)
           lexer = new QsciLexerMatlab ();
 #else
           lexer = new QsciLexerBash ();
 #endif
         }
       else
-        { // other or no extension
+        {
+          // other or no extension
           lexer = new QsciLexerBash ();
         }
     }
 
   _lexer_apis = new QsciAPIs(lexer);
   if (_lexer_apis)
     {
       // get path to prepared api info
       QDesktopServices desktopServices;
       QString prep_apis_path
-          = desktopServices.storageLocation (QDesktopServices::HomeLocation)
-            + "/.config/octave/"  + QString(OCTAVE_VERSION) + "/qsci/";
+        = desktopServices.storageLocation (QDesktopServices::HomeLocation)
+          + "/.config/octave/"  + QString(OCTAVE_VERSION) + "/qsci/";
       _prep_apis_file = prep_apis_path + lexer->lexer () + ".pap";
 
       if (!_lexer_apis->loadPrepared (_prep_apis_file))
-        { // no prepared info loaded, prepare and save if possible
+        {
+          // no prepared info loaded, prepare and save if possible
 
           // create raw apis info
           QString keyword;
           QStringList keyword_list;
           int i,j;
           for (i=1; i<=3; i++) // test the first 5 keyword sets
             {
               keyword = QString(lexer->keywords (i));           // get list
@@ -308,17 +311,18 @@ file_editor_tab::update_lexer ()
               for (j = 0; j < keyword_list.size (); j++)        // add to API
                 _lexer_apis->add (keyword_list.at (j));
             }
 
           // dsiconnect slot for saving prepared info if already connected
           disconnect (_lexer_apis, SIGNAL (apiPreparationFinished ()), 0, 0);
           // check whether path for prepared info exists or can be created
           if (QDir("/").mkpath (prep_apis_path))
-            { // path exists, apis info can be saved there
+            {
+              // path exists, apis info can be saved there
               connect (_lexer_apis, SIGNAL (apiPreparationFinished ()),
                        this, SLOT (save_apis_info ()));
             }
           _lexer_apis->prepare ();  // prepare apis info
         }
     }
 
   QSettings *settings = resource_manager::get_settings ();
@@ -716,17 +720,17 @@ file_editor_tab::find (const QWidget *ID
   // Rather than Qt::DeleteOnClose, let the find feature hang about
   // in case it contains useful information like previous searches
   // and so on.  Perhaps one find dialog for the whole editor is
   // better, but individual find dialogs has the nice feature of
   // retaining position per file editor tabs, which can be undocked.
 
   if (!_find_dialog)
     {
-      _find_dialog = new find_dialog (_edit_area, 
+      _find_dialog = new find_dialog (_edit_area,
                                       qobject_cast<QWidget *> (sender ()));
       connect (_find_dialog, SIGNAL (finished (int)),
                this, SLOT (handle_find_dialog_finished (int)));
       _find_dialog->setWindowModality (Qt::NonModal);
       _find_dialog_geometry = _find_dialog->geometry ();
     }
 
   if (!_find_dialog->isVisible ())
@@ -790,17 +794,18 @@ file_editor_tab::do_comment_selected_tex
               if (line.startsWith (comment_str))
                 {
                   _edit_area->setSelection (i, 0, i, comment_str.length ());
                   _edit_area->removeSelectedText ();
                 }
             }
         }
       //set selection on (un)commented section
-      _edit_area->setSelection (lineFrom, 0, lineTo, _edit_area->text (lineTo).length ());
+      _edit_area->setSelection (lineFrom, 0, lineTo,
+                                _edit_area->text (lineTo).length ());
     }
   else
     {
       int cpline, col;
       _edit_area->getCursorPosition (&cpline, &col);
       if (comment)
         _edit_area->insertAt (comment_str, cpline, 0);
       else
@@ -858,17 +863,17 @@ file_editor_tab::check_file_modified ()
       // File is modified but not saved, ask user what to do.  The file
       // editor tab can't be made parent because it may be deleted depending
       // upon the response.  Instead, change the _edit_area to read only.
       QMessageBox::StandardButtons buttons = QMessageBox::Save |
                                              QMessageBox::Discard;
       QString available_actions;
 
       if (_app_closing)
-          available_actions = tr ("Do you want to save or discard the changes?");
+        available_actions = tr ("Do you want to save or discard the changes?");
       else
         {
           buttons = buttons | QMessageBox::Cancel;  // cancel is allowed
           available_actions
             = tr ("Do you want to cancel closing, save or discard the changes?");
         }
 
       QMessageBox* msgBox
@@ -895,17 +900,17 @@ file_editor_tab::check_file_modified ()
 
       return QMessageBox::Cancel;
     }
   else
     {
       // Nothing was modified, just remove from editor.
       emit tab_remove_request ();
     }
- 
+
   return decision;
 }
 
 void
 file_editor_tab::handle_file_modified_answer (int decision)
 {
   if (decision == QMessageBox::Save)
     {
@@ -967,17 +972,17 @@ file_editor_tab::new_file (const QString
 
 void
 file_editor_tab::save_file (const QString& saveFileName, bool remove_on_success)
 {
   // If it is a new file with no name, signal that saveFileAs
   // should be performed.
   if (saveFileName.isEmpty ()
       || saveFileName.at (saveFileName.count () - 1) == '/')
-     {
+    {
       save_file_as (remove_on_success);
       return;
     }
   // get the absolute path (if existing)
   QFileInfo file_info = QFileInfo (saveFileName);
   QString file_to_save;
   if (file_info.exists ())
     file_to_save = file_info.canonicalFilePath ();
@@ -1235,29 +1240,28 @@ file_editor_tab::notice_settings (const 
                                           default_var).value<QColor> ();
   _edit_area->setCaretLineBackgroundColor (setting_color);
   _edit_area->setCaretLineVisible
     (settings->value ("editor/highlightCurrentLine", true).toBool ());
 
   if (settings->value ("editor/codeCompletion", true).toBool ())  // auto compl.
     {
       bool match_keywords = settings->value
-        ("editor/codeCompletion_keywords",true).toBool ();
+                            ("editor/codeCompletion_keywords",true).toBool ();
       bool match_document = settings->value
-        ("editor/codeCompletion_document",true).toBool ();
+                            ("editor/codeCompletion_document",true).toBool ();
 
       QsciScintilla::AutoCompletionSource source = QsciScintilla::AcsNone;
       if (match_keywords)
         if (match_document)
           source = QsciScintilla::AcsAll;
         else
           source = QsciScintilla::AcsAPIs;
-      else
-        if (match_document)
-          source = QsciScintilla::AcsDocument;
+      else if (match_document)
+        source = QsciScintilla::AcsDocument;
       _edit_area->setAutoCompletionSource (source);
 
       _edit_area->setAutoCompletionReplaceWord
         (settings->value ("editor/codeCompletion_replace",false).toBool ());
       _edit_area->setAutoCompletionCaseSensitivity
         (settings->value ("editor/codeCompletion_case",true).toBool ());
       _edit_area->setAutoCompletionThreshold
         (settings->value ("editor/codeCompletion_threshold",2).toInt ());
diff --git a/libgui/src/m-editor/file-editor-tab.h b/libgui/src/m-editor/file-editor-tab.h
--- a/libgui/src/m-editor/file-editor-tab.h
+++ b/libgui/src/m-editor/file-editor-tab.h
@@ -148,21 +148,21 @@ private slots:
   void save_apis_info ();
 
   // When the numer of lines changes -> adapt width of margin
   void auto_margin_width ();
 
 private:
 
   enum editor_markers
-    {
-      bookmark,
-      breakpoint,
-      debugger_position
-    };
+  {
+    bookmark,
+    breakpoint,
+    debugger_position
+  };
 
   struct bp_info
   {
     bp_info (const QString& f, const QString& d, const QString& fn, int l)
       : file (f.toStdString ()), dir (d.toStdString ()),
         function_name (fn.toStdString ()), line (l)
     { }
 
diff --git a/libgui/src/m-editor/file-editor.cc b/libgui/src/m-editor/file-editor.cc
--- a/libgui/src/m-editor/file-editor.cc
+++ b/libgui/src/m-editor/file-editor.cc
@@ -70,17 +70,20 @@ file_editor::~file_editor (void)
       if (!file_name.isEmpty () && file_name.at (file_name.size () - 1) != '/')
         fetFileNames.append (p->first);  // do not append unnamed files
     }
 
   settings->setValue ("editor/savedSessionTabs", fetFileNames);
   settings->sync ();
 
   for (int index = _tab_widget->count ()-1; index >= 0; index--)
-    emit fetab_close_request (_tab_widget->widget (index),true); // true: app closing
+    {
+      // true: app closing
+      emit fetab_close_request (_tab_widget->widget (index), true);
+    }
 
   if (_mru_file_menu)
     delete _mru_file_menu;
 }
 
 void
 file_editor::focus (void)
 {
@@ -208,17 +211,17 @@ file_editor::find_tab_widget (const QStr
       if (same_file (file.toStdString (), tab_file.toStdString ()))
         {
           retval = p->second;
           break;
         }
     }
 
   return retval;
-}    
+}
 
 void
 file_editor::request_open_file (const QString& openFileName, int line,
                                 bool debug_pointer,
                                 bool breakpoint_marker, bool insert)
 {
   // Check if the user wants to use a custom file editor.
   QSettings *settings = resource_manager::get_settings ();
@@ -293,61 +296,64 @@ file_editor::request_open_file (const QS
                     }
                 }
               else
                 {
                   delete fileEditorTab;
 
                   if (QFile::exists (openFileName))
                     {
-                      // File not readable: create a NonModal message about error.
+                      // File not readable:
+                      // create a NonModal message about error.
                       QMessageBox *msgBox
                         = new QMessageBox (QMessageBox::Critical,
-                                   tr ("Octave Editor"),
-                                   tr ("Could not open file\n%1\nfor read: %2.").
-                                   arg (openFileName).arg (result),
-                                   QMessageBox::Ok, this);
+                                           tr ("Octave Editor"),
+                                           tr ("Could not open file\n%1\nfor read: %2.").
+                                           arg (openFileName).arg (result),
+                                           QMessageBox::Ok, this);
 
                       msgBox->setWindowModality (Qt::NonModal);
                       msgBox->setAttribute (Qt::WA_DeleteOnClose);
                       msgBox->show ();
                     }
                   else
                     {
                       // File does not exist, should it be crated?
                       QMessageBox *msgBox;
                       int answer;
-                      if (settings->value ("editor/create_new_file",false).toBool ())
+                      if (settings->value ("editor/create_new_file",
+                                           false).toBool ())
                         {
                           answer = QMessageBox::Yes;
                         }
                       else
                         {
-                           msgBox = new QMessageBox (QMessageBox::Question,
-                               tr ("Octave Editor"),
-                               tr ("File\n%1\ndoes not exist. "
-                                   "Do you want to create it?").arg (openFileName),
-                               QMessageBox::Yes | QMessageBox::No, this);
+                          msgBox = new QMessageBox (QMessageBox::Question,
+                                                    tr ("Octave Editor"),
+                                                    tr ("File\n%1\ndoes not exist. "
+                                                        "Do you want to create it?").arg (openFileName),
+                                                    QMessageBox::Yes
+                                                    | QMessageBox::No, this);
 
                           msgBox->setAttribute (Qt::WA_DeleteOnClose);
                           answer = msgBox->exec ();
                         }
 
                       if (answer == QMessageBox::Yes)
                         {
                           // create the file and call the editor again
                           QFile file (openFileName);
                           if (!file.open (QIODevice::WriteOnly))
                             {
                               // error opening the file
                               msgBox = new QMessageBox (QMessageBox::Critical,
-                                   tr ("Octave Editor"),
-                                   tr ("Could not open file\n%1\nfor write: %2.").
-                                   arg (openFileName).arg (file.errorString ()),
-                                   QMessageBox::Ok, this);
+                                                        tr ("Octave Editor"),
+                                                        tr ("Could not open file\n%1\nfor write: %2.").
+                                                        arg (openFileName).arg (file.errorString ()),
+                                                        QMessageBox::Ok, this);
 
                               msgBox->setWindowModality (Qt::NonModal);
                               msgBox->setAttribute (Qt::WA_DeleteOnClose);
                               msgBox->show ();
                             }
                           else
                             {
                               file.close ();
@@ -371,17 +377,18 @@ file_editor::request_mru_open_file (QAct
   if (action)
     {
       request_open_file (action->data ().toString ());
     }
 }
 
 
 void
-file_editor::check_conflict_save (const QString& saveFileName, bool remove_on_success)
+file_editor::check_conflict_save (const QString& saveFileName,
+                                  bool remove_on_success)
 {
   // Have all file editor tabs signal what their file names are.
   editor_tab_map.clear ();
   emit fetab_file_name_query (0);
 
   // Check whether this file is already open in the editor.
   QWidget *tab = find_tab_widget (saveFileName);
 
@@ -537,23 +544,23 @@ void
 file_editor::request_save_file (void)
 {
   emit fetab_save_file (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_save_file_as (void)
 {
-   emit fetab_save_file_as (_tab_widget->currentWidget ());
+  emit fetab_save_file_as (_tab_widget->currentWidget ());
 }
 
 void
 file_editor::request_print_file (void)
 {
-   emit fetab_print_file (_tab_widget->currentWidget ());
+  emit fetab_print_file (_tab_widget->currentWidget ());
 }
 
 
 void
 file_editor::request_run_file (void)
 {
   emit fetab_run_file (_tab_widget->currentWidget ());
 }
@@ -649,36 +656,36 @@ void
 file_editor::mru_menu_update (void)
 {
   int num_files = qMin (_mru_files.size (), int (MaxMRUFiles));
 
   // configure and show active actions of mru-menu
   for (int i = 0; i < num_files; ++i)
     {
       QString text = tr ("&%1 %2").
-          arg ((i+1) % int (MaxMRUFiles)).arg (_mru_files.at (i));
+                     arg ((i+1) % int (MaxMRUFiles)).arg (_mru_files.at (i));
       _mru_file_actions[i]->setText (text);
       _mru_file_actions[i]->setData (_mru_files.at (i));
       _mru_file_actions[i]->setVisible (true);
     }
 
-    // hide unused mru-menu entries
-    for (int j = num_files; j < MaxMRUFiles; ++j)
-      _mru_file_actions[j]->setVisible (false);
+  // hide unused mru-menu entries
+  for (int j = num_files; j < MaxMRUFiles; ++j)
+    _mru_file_actions[j]->setVisible (false);
 
-    // delete entries in string-list beyond MaxMRUFiles
-    while (_mru_files.size () > MaxMRUFiles)
-      _mru_files.removeLast ();
+  // delete entries in string-list beyond MaxMRUFiles
+  while (_mru_files.size () > MaxMRUFiles)
+    _mru_files.removeLast ();
 
-    // save actual mru-list in settings
-    QSettings *settings = resource_manager::get_settings ();
+  // save actual mru-list in settings
+  QSettings *settings = resource_manager::get_settings ();
 
-    // FIXME -- what should happen if settings is 0?
-    settings->setValue ("editor/mru_file_list", _mru_files);
-    settings->sync ();
+  // FIXME: what should happen if settings is 0?
+  settings->setValue ("editor/mru_file_list", _mru_files);
+  settings->sync ();
 }
 
 void
 file_editor::handle_file_name_changed (const QString& fname,
                                        const QString& tip)
 {
   QObject *fileEditorTab = sender ();
   if (fileEditorTab)
@@ -742,17 +749,17 @@ file_editor::handle_tab_remove_request (
         {
           if (_tab_widget->widget (i) == fileEditorTab)
             {
               _tab_widget->removeTab (i);
               delete fileEditorTab;
             }
         }
     }
-    check_actions ();
+  check_actions ();
 }
 
 void
 file_editor::handle_add_filename_to_list (const QString& fileName, QWidget *ID)
 {
   // Should we allow multiple tabs for a single file?
 
   editor_tab_map[fileName] = ID;
@@ -812,60 +819,61 @@ file_editor::request_styles_preferences 
   emit request_settings_dialog ("editor_styles");
 }
 
 void
 file_editor::construct (void)
 {
   QWidget *editor_widget = new QWidget (this);
 
-  // FIXME -- what was the intended purpose of this unused variable?
+  // FIXME: what was the intended purpose of this unused variable?
   // QStyle *editor_style = QApplication::style ();
 
   _menu_bar = new QMenuBar (editor_widget);
   _tool_bar = new QToolBar (editor_widget);
   _tab_widget = new QTabWidget (editor_widget);
   _tab_widget->setTabsClosable (true);
 
   QAction *new_action = new QAction (QIcon (":/actions/icons/filenew.png"),
                                      tr ("&New File"), _tool_bar);
 
   QAction *open_action = new QAction (QIcon (":/actions/icons/fileopen.png"),
                                       tr ("&Open File"), _tool_bar);
 
   _save_action = new QAction (QIcon (":/actions/icons/filesave.png"),
-                                      tr ("&Save File"), _tool_bar);
+                              tr ("&Save File"), _tool_bar);
 
   _save_as_action = new QAction (QIcon (":/actions/icons/filesaveas.png"),
-                                tr ("Save File &As"), _tool_bar);
+                                 tr ("Save File &As"), _tool_bar);
 
   _print_action = new QAction ( QIcon (":/actions/icons/fileprint.png"),
                                 tr ("Print"), _tool_bar);
 
   _undo_action = new QAction (QIcon (":/actions/icons/undo.png"),
-                                      tr ("&Undo"), _tool_bar);
+                              tr ("&Undo"), _tool_bar);
 
   _redo_action = new QAction (QIcon (":/actions/icons/redo.png"),
-                                      tr ("&Redo"), _tool_bar);
+                              tr ("&Redo"), _tool_bar);
 
   _copy_action = new QAction (QIcon (":/actions/icons/editcopy.png"),
                               tr ("&Copy"), _tool_bar);
   _copy_action->setEnabled (false);
 
   _cut_action = new QAction (QIcon (":/actions/icons/editcut.png"),
-                              tr ("Cu&t"), _tool_bar);
+                             tr ("Cu&t"), _tool_bar);
   _cut_action->setEnabled (false);
 
   _paste_action
     = new QAction (QIcon (":/actions/icons/editpaste.png"),
                    tr ("Paste"), _tool_bar);
 
   _next_bookmark_action = new QAction (tr ("&Next Bookmark"), _tool_bar);
 
-  _previous_bookmark_action = new QAction (tr ("Pre&vious Bookmark"), _tool_bar);
+  _previous_bookmark_action = new QAction (tr ("Pre&vious Bookmark"),
+                                           _tool_bar);
 
   _toggle_bookmark_action = new QAction (tr ("Toggle &Bookmark"), _tool_bar);
 
   _remove_bookmark_action
     = new QAction (tr ("&Remove All Bookmarks"), _tool_bar);
 
   QAction *next_breakpoint_action
     = new QAction (QIcon (":/actions/icons/bp_next.png"),
@@ -881,31 +889,31 @@ file_editor::construct (void)
                    tr ("&Remove All breakpoints"), _tool_bar);
 
   _comment_selection_action
     = new QAction (tr ("&Comment"), _tool_bar);
   _uncomment_selection_action
     = new QAction (tr ("&Uncomment"), _tool_bar);
 
   _find_action = new QAction (QIcon (":/actions/icons/search.png"),
-                                      tr ("&Find and Replace"), _tool_bar);
+                              tr ("&Find and Replace"), _tool_bar);
 
   _run_action = new QAction (QIcon (":/actions/icons/artsbuilderexecute.png"),
                              tr ("Save File And Run"), _tool_bar);
 
   _goto_line_action = new QAction (tr ("Go&to Line"), _tool_bar);
 
   // the mru-list and an empty array of actions
   QSettings *settings = resource_manager::get_settings ();
-  // FIXME -- what should happen if settings is 0?
+  // FIXME: what should happen if settings is 0?
   _mru_files = settings->value ("editor/mru_file_list").toStringList ();
   for (int i = 0; i < MaxMRUFiles; ++i)
     {
-       _mru_file_actions[i] = new QAction (this);
-       _mru_file_actions[i]->setVisible (false);
+      _mru_file_actions[i] = new QAction (this);
+      _mru_file_actions[i]->setVisible (false);
     }
 
   // some actions are disabled from the beginning
   _copy_action->setEnabled (false);
   _cut_action->setEnabled (false);
 
   _run_action->setShortcutContext (Qt::WindowShortcut);
   _save_action->setShortcutContext (Qt::WindowShortcut);
@@ -958,29 +966,29 @@ file_editor::construct (void)
     fileMenu->addAction (QIcon (), tr ("&Edit Function"),
                          this, SLOT (request_context_edit (bool)));
   fileMenu->addSeparator ();
   fileMenu->addAction (_save_action);
   fileMenu->addAction (_save_as_action);
 
   fileMenu->addSeparator ();
   _close_action =
-      fileMenu->addAction (QIcon::fromTheme("window-close",
-                                  QIcon (":/actions/icons/fileclose.png")),
-                       tr ("&Close"), this, SLOT (request_close_file (bool)));
+    fileMenu->addAction (QIcon::fromTheme("window-close",
+                                          QIcon (":/actions/icons/fileclose.png")),
+                         tr ("&Close"), this, SLOT (request_close_file (bool)));
   _close_all_action =
-      fileMenu->addAction (QIcon::fromTheme("window-close",
-                                      QIcon (":/actions/icons/fileclose.png")),
-                       tr ("Close All"),
-                       this, SLOT (request_close_all_files (bool)));
-  _close_others_action = 
-  fileMenu->addAction (QIcon::fromTheme("window-close",
-                                      QIcon (":/actions/icons/fileclose.png")),
-                       tr ("Close Other Files"),
-                       this, SLOT (request_close_other_files (bool)));
+    fileMenu->addAction (QIcon::fromTheme("window-close",
+                                          QIcon (":/actions/icons/fileclose.png")),
+                         tr ("Close All"),
+                         this, SLOT (request_close_all_files (bool)));
+  _close_others_action =
+    fileMenu->addAction (QIcon::fromTheme("window-close",
+                                          QIcon (":/actions/icons/fileclose.png")),
+                         tr ("Close Other Files"),
+                         this, SLOT (request_close_other_files (bool)));
 
   fileMenu->addSeparator ();
   fileMenu->addAction (_print_action);
 
   _menu_bar->addMenu (fileMenu);
 
 
   QMenu *editMenu = new QMenu (tr ("&Edit"), _menu_bar);
@@ -999,37 +1007,39 @@ file_editor::construct (void)
   editMenu->addAction (_toggle_bookmark_action);
   editMenu->addAction (_next_bookmark_action);
   editMenu->addAction (_previous_bookmark_action);
   editMenu->addAction (_remove_bookmark_action);
   editMenu->addSeparator ();
   editMenu->addAction (_goto_line_action);
   editMenu->addSeparator ();
   _preferences_action =
-     editMenu->addAction (QIcon (":/actions/icons/configure.png"),
-       tr ("&Preferences"), this, SLOT (request_preferences (bool)));
+    editMenu->addAction (QIcon (":/actions/icons/configure.png"),
+                         tr ("&Preferences"),
+                         this, SLOT (request_preferences (bool)));
   _styles_preferences_action =
     editMenu->addAction (QIcon (":/actions/icons/configure.png"),
-      tr ("&Styles Preferences"), this, SLOT (request_styles_preferences (bool)));
+                         tr ("&Styles Preferences"),
+                         this, SLOT (request_styles_preferences (bool)));
   _menu_bar->addMenu (editMenu);
 
   _debug_menu = new QMenu (tr ("&Debug"), _menu_bar);
   _debug_menu->addAction (toggle_breakpoint_action);
   _debug_menu->addAction (next_breakpoint_action);
   _debug_menu->addAction (previous_breakpoint_action);
   _debug_menu->addAction (remove_all_breakpoints_action);
   _debug_menu->addSeparator ();
   // The other debug actions will be added by the main window.
   _menu_bar->addMenu (_debug_menu);
 
   QMenu *_run_menu = new QMenu (tr ("&Run"), _menu_bar);
   _run_menu->addAction (_run_action);
   _context_run_action =
     _run_menu->addAction (QIcon (), tr ("Run &Selection"),
-                           this, SLOT (request_context_run (bool)));
+                          this, SLOT (request_context_run (bool)));
   _context_run_action->setEnabled (false);
   _menu_bar->addMenu (_run_menu);
 
   QMenu *_help_menu = new QMenu (tr ("&Help"), _menu_bar);
   _context_help_action =
     _help_menu->addAction (QIcon (), tr ("&Help on Keyword"),
                            this, SLOT (request_context_help (bool)));
   _context_doc_action =
@@ -1046,17 +1056,18 @@ file_editor::construct (void)
   vbox_layout->addWidget (_tool_bar);
   vbox_layout->addWidget (_tab_widget);
   vbox_layout->setMargin (0);
   editor_widget->setLayout (vbox_layout);
   setWidget (editor_widget);
 
   // signals
   connect (this, SIGNAL (request_settings_dialog (const QString&)),
-           main_win (), SLOT (process_settings_dialog_request (const QString&)));
+           main_win (),
+           SLOT (process_settings_dialog_request (const QString&)));
 
   connect (main_win (), SIGNAL (new_file_signal (const QString&)),
            this, SLOT (request_new_file (const QString&)));
 
   connect (main_win (), SIGNAL (open_file_signal (const QString&)),
            this, SLOT (request_open_file (const QString&)));
 
   connect (new_action, SIGNAL (triggered ()),
@@ -1142,23 +1153,24 @@ file_editor::construct (void)
   resize (500, 400);
   setWindowIcon (QIcon (":/actions/icons/logo.png"));
   set_title ("Editor");
 
   //restore previous session
   if (settings->value ("editor/restoreSession", true).toBool ())
     {
       QStringList sessionFileNames
-        = settings->value ("editor/savedSessionTabs", QStringList ()).toStringList ();
+        = settings->value ("editor/savedSessionTabs",
+                           QStringList ()).toStringList ();
 
       for (int n = 0; n < sessionFileNames.count (); ++n)
         request_open_file (sessionFileNames.at (n));
     }
 
-    check_actions ();
+  check_actions ();
 }
 
 void
 file_editor::add_file_editor_tab (file_editor_tab *f, const QString& fn)
 {
   _tab_widget->addTab (f, fn);
 
   // Signals from the file editor_tab
@@ -1178,17 +1190,17 @@ file_editor::add_file_editor_tab (file_e
   connect (f, SIGNAL (editor_check_conflict_save (const QString&, bool)),
            this, SLOT (check_conflict_save (const QString&, bool)));
 
   connect (f, SIGNAL (mru_add_file (const QString&)),
            this, SLOT (handle_mru_add_file (const QString&)));
 
   connect (f, SIGNAL (run_file_signal (const QFileInfo&)),
            main_win (), SLOT (run_file_in_terminal (const QFileInfo&)));
-  
+
   connect (f, SIGNAL (execute_command_in_terminal_signal (const QString&)),
            main_win (), SLOT (execute_command_in_terminal (const QString&)));
 
   // Signals from the file_editor non-trivial operations
   connect (this, SIGNAL (fetab_settings_changed (const QSettings *)),
            f, SLOT (notice_settings (const QSettings *)));
 
   connect (this, SIGNAL (fetab_close_request (const QWidget*,bool)),
@@ -1295,39 +1307,41 @@ file_editor::add_file_editor_tab (file_e
   check_actions ();
 }
 
 void
 file_editor::copyClipboard ()
 {
   QWidget * foc_w = focusWidget ();
 
-  if(foc_w && foc_w->inherits ("octave_qscintilla"))
-  {
-    request_copy ();
-  }
+  if (foc_w && foc_w->inherits ("octave_qscintilla"))
+    {
+      request_copy ();
+    }
 }
 void
 file_editor::pasteClipboard ()
 {
   QWidget * foc_w = focusWidget ();
 
-  if(foc_w && foc_w->inherits ("octave_qscintilla"))
-  {
-    request_paste ();
-  }
+  if (foc_w && foc_w->inherits ("octave_qscintilla"))
+    {
+      request_paste ();
+    }
 }
 
 void
 file_editor::set_shortcuts (bool set)
 {
   if (set)
     {
       _comment_selection_action->setShortcut (Qt::ControlModifier + Qt::Key_R);
-      _uncomment_selection_action->setShortcut (Qt::SHIFT + Qt::ControlModifier + Qt::Key_R);
+      _uncomment_selection_action->setShortcut (Qt::SHIFT
+                                                + Qt::ControlModifier
+                                                + Qt::Key_R);
 
       _copy_action->setShortcut (QKeySequence::Copy);
       _cut_action->setShortcut (QKeySequence::Cut);
       _paste_action->setShortcut (QKeySequence::Paste);
       _context_help_action->setShortcut (QKeySequence::HelpContents);
       _context_doc_action->setShortcut (Qt::SHIFT + Qt::Key_F1);
 
       _find_action->setShortcut (QKeySequence::Find);
diff --git a/libgui/src/m-editor/find-dialog.cc b/libgui/src/m-editor/find-dialog.cc
--- a/libgui/src/m-editor/find-dialog.cc
+++ b/libgui/src/m-editor/find-dialog.cc
@@ -153,17 +153,17 @@ find_dialog::find_dialog (QsciScintilla*
   main_layout->addWidget (_button_box, 0, 1);
   main_layout->addWidget (_extension, 1, 0);
   setLayout (main_layout);
 
   _extension->hide ();
   _find_next_button->setDefault (true);
   _find_result_available = false;
 
-  // move to dialog to side of the parent if there is room on the desktop to do so.
+  // move dialog to side of the parent if there is room on the desktop to do so.
   QWidget * desktop = QApplication::desktop ();
   int xp = p->x () + p->frameGeometry ().width ();
   int yp=  p->y ();
   if (desktop != 0 && sizeHint ().isValid ())
     {
       if (xp + sizeHint ().width () > desktop->width ())
         xp = desktop->width () - sizeHint ().width ();
     }
@@ -210,19 +210,21 @@ find_dialog::find_prev ()
 void
 find_dialog::find (bool forward)
 {
   int line = -1, col = -1;
   bool do_wrap = _wrap_check_box->isChecked ();
   bool do_forward = true;
 
   if (_find_result_available)
-    { // we found a match last time, cursor is at the end of the match
+    {
+      // we found a match last time, cursor is at the end of the match
       if (!forward)
-        {  // backward: go back one position or we will find the same again
+        {
+          // backward: go back one position or we will find the same again
           do_forward = false;
           _edit_area->getCursorPosition (&line,&col);
           if (col > 0)
             _edit_area->setCursorPosition (line,--col);
         }
     }
 
   _find_result_available = false;
@@ -232,28 +234,29 @@ find_dialog::find (bool forward)
       line = 0;
       col  = 0;
       if (_backward_check_box->isChecked ())
         do_wrap = true;
     }
 
   if (_edit_area)
     {
-      _find_result_available = _edit_area->findFirst (_search_line_edit->text (),
-                                                      _regex_check_box->isChecked (),
-                                                      _case_check_box->isChecked (),
-                                                      _whole_words_check_box->isChecked (),
-                                                      do_wrap,
-                                                      do_forward,
-                                                      line,col,
-                                                      true
+      _find_result_available
+        = _edit_area->findFirst (_search_line_edit->text (),
+                                _regex_check_box->isChecked (),
+                                _case_check_box->isChecked (),
+                                _whole_words_check_box->isChecked (),
+                                do_wrap,
+                                do_forward,
+                                line,col,
+                                true
 #ifdef HAVE_QSCI_VERSION_2_6_0
-                                                      , true
+                                , true
 #endif
-                                                      );
+                                );
     }
   if (_find_result_available)
     _from_start_check_box->setChecked (0);
   else
     no_matches_message ();
 }
 
 
@@ -279,17 +282,18 @@ find_dialog::replace_all ()
   if (_case_check_box->isChecked())
     {
       cs = Qt::CaseSensitive;
     }
   else
     {
       cs = Qt::CaseInsensitive;
     }
-  strDiff = QString::compare(_search_line_edit->text(),_replace_line_edit->text(),cs);
+  strDiff = QString::compare (_search_line_edit->text(),
+                              _replace_line_edit->text(), cs);
 
   // replace all if strings are different
   if (_edit_area && strDiff )
     {
       find (!_backward_check_box->isChecked ());  // find first occurence
       while (_find_result_available)   // while search string is found
         {
           _edit_area->replace (_replace_line_edit->text ());   // replace
@@ -302,15 +306,15 @@ find_dialog::replace_all ()
       msg_box.exec ();
     }
   // TODO: Show number of replaced strings
 }
 
 void
 find_dialog::no_matches_message ()
 {
- 	QMessageBox msg_box (QMessageBox::Information, tr ("Find Result"),
+  QMessageBox msg_box (QMessageBox::Information, tr ("Find Result"),
                        tr ("No more matches found"), QMessageBox::Ok, this);
   msg_box.exec ();
 }
 
 
 #endif
diff --git a/libgui/src/m-editor/find-dialog.h b/libgui/src/m-editor/find-dialog.h
--- a/libgui/src/m-editor/find-dialog.h
+++ b/libgui/src/m-editor/find-dialog.h
@@ -69,17 +69,17 @@ class QDialogButtonBox;
 class QGroupBox;
 class QLabel;
 class QLineEdit;
 class QPushButton;
 
 class find_dialog : public QDialog
 {
   Q_OBJECT
-  public:
+public:
   find_dialog (QsciScintilla* edit_area, QWidget *parent = 0);
   void init_search_text ();
 
 private slots:
   void handle_backward_search_changed (int);
   void find (bool forward = true);
   void find_next ();
   void find_prev ();
diff --git a/libgui/src/m-editor/octave-qscintilla.cc b/libgui/src/m-editor/octave-qscintilla.cc
--- a/libgui/src/m-editor/octave-qscintilla.cc
+++ b/libgui/src/m-editor/octave-qscintilla.cc
@@ -29,24 +29,25 @@ along with Octave; see the file COPYING.
 #ifdef HAVE_QSCINTILLA
 
 #include <Qsci/qscilexer.h>
 
 #include "octave-qscintilla.h"
 #include "file-editor-tab.h"
 
 octave_qscintilla::octave_qscintilla (QWidget *p)
-    : QsciScintilla (p)
+  : QsciScintilla (p)
 { }
 
 octave_qscintilla::~octave_qscintilla ()
 { }
 
 void
-octave_qscintilla::get_global_textcursor_pos (QPoint *global_pos, QPoint *local_pos)
+octave_qscintilla::get_global_textcursor_pos (QPoint *global_pos,
+                                              QPoint *local_pos)
 {
   long position = SendScintilla (QsciScintillaBase::SCI_GETCURRENTPOS);
   long point_x  = SendScintilla
                     (QsciScintillaBase::SCI_POINTXFROMPOSITION,0,position);
   long point_y  = SendScintilla
                     (QsciScintillaBase::SCI_POINTYFROMPOSITION,0,position);
   *local_pos = QPoint (point_x,point_y);  // local cursor position
   *global_pos = mapToGlobal (*local_pos); // global position of cursor
@@ -94,47 +95,50 @@ void
 octave_qscintilla::contextMenuEvent (QContextMenuEvent *e)
 {
   QMenu *context_menu = createStandardContextMenu ( );  // standard menu
 
   // the menu's position
   QPoint global_pos, local_pos;
 
   if (e->reason () == QContextMenuEvent::Mouse)
-    { // context menu by mouse
+    {
+      // context menu by mouse
       global_pos = e->globalPos ();            // global mouse position
       local_pos  = e->pos ();                  // local mouse position
     }
   else
-    { // context menu by keyboard or other: get point of text cursor
+    {
+      // context menu by keyboard or other: get point of text cursor
       get_global_textcursor_pos (&global_pos, &local_pos);
       QRect editor_rect = geometry ();      // editor rect mapped to global
       editor_rect.moveTopLeft
-              (parentWidget ()->mapToGlobal (editor_rect.topLeft ()));
+      (parentWidget ()->mapToGlobal (editor_rect.topLeft ()));
       if (!editor_rect.contains (global_pos))  // is cursor outside editor?
         global_pos = editor_rect.topLeft ();   // yes, take top left corner
     }
 
   // additional custom entries of the context menu
   context_menu->addSeparator ();   // separator before custom entries
 
   // help menu: get the position of the mouse or the text cursor
   // (only for octave files)
   QString lexer_name = lexer ()->lexer ();
   if (lexer_name == "octave" || lexer_name == "matlab")
     {
       _word_at_cursor = wordAtPoint (local_pos);
       if (!_word_at_cursor.isEmpty ())
         {
           context_menu->addAction (tr ("Help on") + " " + _word_at_cursor,
-                                  this, SLOT (contextmenu_help (bool)));
-          context_menu->addAction (tr ("Documentation on") + " " + _word_at_cursor,
-                                  this, SLOT (contextmenu_doc (bool)));
+                                   this, SLOT (contextmenu_help (bool)));
+          context_menu->addAction (tr ("Documentation on")
+                                   + " " + _word_at_cursor,
+                                   this, SLOT (contextmenu_doc (bool)));
           context_menu->addAction (tr ("Edit") + " " + _word_at_cursor,
-                                  this, SLOT (contextmenu_edit (bool)));
+                                   this, SLOT (contextmenu_edit (bool)));
         }
       context_menu->addSeparator ();   // separator before custom entries
       if (hasSelectedText ())
         context_menu->addAction (tr ("&Run Selection"),
                                  this, SLOT (contextmenu_run (bool)));
     }
 
   // finaly show the menu
@@ -171,14 +175,15 @@ void
 octave_qscintilla::contextmenu_edit (bool)
 {
   emit execute_command_in_terminal_signal (QString("edit ") + _word_at_cursor);
 }
 
 void
 octave_qscintilla::contextmenu_run (bool)
 {
-  QStringList commands = selectedText ().split (QRegExp("[\r\n]"),QString::SkipEmptyParts);
+  QStringList commands = selectedText ().split (QRegExp("[\r\n]"),
+                                                QString::SkipEmptyParts);
   for (int i = 0; i < commands.size (); i++ )
     emit execute_command_in_terminal_signal (commands.at (i));
 }
 
 #endif
diff --git a/libgui/src/main-window.cc b/libgui/src/main-window.cc
--- a/libgui/src/main-window.cc
+++ b/libgui/src/main-window.cc
@@ -98,17 +98,17 @@ main_window::~main_window (void)
   delete news_window;
   delete command_window;
   delete workspace_window;
   delete doc_browser_window;
   delete file_browser_window;
   delete history_window;
   delete status_bar;
   delete _workspace_model;
-  if (find_files_dlg) 
+  if (find_files_dlg)
     {
       delete find_files_dlg;
       find_files_dlg = 0;
     }
   delete _octave_main_thread;
   delete _octave_qt_link;
   delete _cmd_queue;
 }
@@ -142,30 +142,32 @@ main_window::report_status_message (cons
 {
   status_bar->showMessage (statusMessage, 1000);
 }
 
 void
 main_window::handle_save_workspace_request (void)
 {
   QString file =
-    QFileDialog::getSaveFileName (this, tr ("Save Workspace As"), ".", 0, 0, QFileDialog::DontUseNativeDialog);
+    QFileDialog::getSaveFileName (this, tr ("Save Workspace As"), ".", 0, 0,
+                                  QFileDialog::DontUseNativeDialog);
 
   if (! file.isEmpty ())
     octave_link::post_event (this, &main_window::save_workspace_callback,
                              file.toStdString ());
 }
 
 void
 main_window::handle_load_workspace_request (const QString& file_arg)
 {
   QString file = file_arg;
 
   if (file.isEmpty ())
-    file = QFileDialog::getOpenFileName (this, tr ("Load Workspace"), ".", 0, 0, QFileDialog::DontUseNativeDialog);
+    file = QFileDialog::getOpenFileName (this, tr ("Load Workspace"), ".", 0, 0,
+                                         QFileDialog::DontUseNativeDialog);
 
   if (! file.isEmpty ())
     octave_link::post_event (this, &main_window::load_workspace_callback,
                              file.toStdString ());
 }
 
 void
 main_window::handle_clear_workspace_request (void)
@@ -228,17 +230,17 @@ main_window::run_file_callback (const QF
 
 void
 main_window::queue_command (QString command)
 {
   _cmd_queue_mutex.lock ();
   _cmd_queue->append (command);   // queue command
   _cmd_queue_mutex.unlock ();
 
-  if (_cmd_processing.tryAcquire ())   // if callback is not processing, post event
+  if (_cmd_processing.tryAcquire ())  // if callback not processing, post event
     octave_link::post_event (this, &main_window::execute_command_callback);
 }
 
 void
 main_window::handle_new_figure_request (void)
 {
   octave_link::post_event (this, &main_window::new_figure_callback);
 }
@@ -342,37 +344,40 @@ main_window::notice_settings (const QSet
 {
   // QSettings pointer is checked before emitting.
 
   // the widget's icons (when floating)
   QString icon_set
     = settings->value ("DockWidgets/widget_icon_set", "NONE").toString ();
 
   static struct
-    {
-      QString name;
-      QString path;
-    }
+  {
+    QString name;
+    QString path;
+  }
 
   widget_icon_data[] =
-    { // array of possible icon sets (name, path (complete for NONE))
-      // the first entry here is the default!
-      {"NONE",    ":/actions/icons/logo.png"},
-      {"GRAPHIC", ":/actions/icons/graphic_logo_"},
-      {"LETTER",  ":/actions/icons/letter_logo_"},
-      {"", ""} // end marker has empty name
-    };
+  {
+    // array of possible icon sets (name, path (complete for NONE))
+    // the first entry here is the default!
+    {"NONE",    ":/actions/icons/logo.png"},
+    {"GRAPHIC", ":/actions/icons/graphic_logo_"},
+    {"LETTER",  ":/actions/icons/letter_logo_"},
+    {"", ""} // end marker has empty name
+  };
 
   int count = 0;
   int icon_set_found = 0; // default
 
   while (!widget_icon_data[count].name.isEmpty ())
-    { // while not end of data
+    {
+      // while not end of data
       if (widget_icon_data[count].name == icon_set)
-        { // data of desired icon set found
+        {
+          // data of desired icon set found
           icon_set_found = count;
           break;
         }
       count++;
     }
 
   QString icon;
   foreach (octave_dock_widget *widget, dock_widget_list ())
@@ -382,20 +387,20 @@ main_window::notice_settings (const QSet
         { // if children has a name
           icon = widget_icon_data[icon_set_found].path; // prefix or octave-logo
           if (widget_icon_data[icon_set_found].name != "NONE")
             icon = icon + name + ".png"; // add widget name and ext.
           widget->setWindowIcon (QIcon (icon));
         }
     }
   if (widget_icon_data[icon_set_found].name != "NONE")
-     _release_notes_icon = widget_icon_data[icon_set_found].path
-                           + "ReleaseWidget.png";
+    _release_notes_icon = widget_icon_data[icon_set_found].path
+                          + "ReleaseWidget.png";
   else
-     _release_notes_icon = ":/actions/icons/logo.png";
+    _release_notes_icon = ":/actions/icons/logo.png";
 
   int icon_size = settings->value ("toolbar_icon_size",24).toInt ();
   _main_tool_bar->setIconSize (QSize (icon_size,icon_size));
 
   resource_manager::update_network_settings ();
 }
 
 
@@ -436,33 +441,34 @@ main_window::change_directory (const QSt
 
   file_browser_window->update_octave_directory (dir);
 }
 
 void
 main_window::browse_for_directory (void)
 {
   QString dir
-    = QFileDialog::getExistingDirectory (this, tr ("Set working directory"), 0, QFileDialog::DontUseNativeDialog);
+    = QFileDialog::getExistingDirectory (this, tr ("Set working directory"), 0,
+                                         QFileDialog::DontUseNativeDialog);
 
   set_current_working_directory (dir);
 
-  // FIXME -- on Windows systems, the command window freezes after the
+  // FIXME: on Windows systems, the command window freezes after the
   // previous actions.  Forcing the focus appears to unstick it.
 
   focus_command_window ();
 }
 
 void
 main_window::set_current_working_directory (const QString& dir)
 {
   // Change to dir if it is an existing directory.
 
   QString xdir = dir.isEmpty () ? "." : dir;
-    
+
   QFileInfo fileInfo (xdir);
 
   if (fileInfo.exists () && fileInfo.isDir ())
     octave_link::post_event (this, &main_window::change_directory_callback,
                              xdir.toStdString ());
 }
 
 void
@@ -608,24 +614,25 @@ main_window::closeEvent (QCloseEvent *e)
 
 void
 main_window::read_settings (void)
 {
   QSettings *settings = resource_manager::get_settings ();
 
   if (!settings)
     {
-      qDebug("Error: QSettings pointer from resource manager is NULL.");
+      qDebug ("Error: QSettings pointer from resource manager is NULL.");
       return;
     }
 
   set_window_layout (settings);
 
   // restore the list of the last directories
-  QStringList curr_dirs = settings->value ("MainWindow/current_directory_list").toStringList ();
+  QStringList curr_dirs
+    = settings->value ("MainWindow/current_directory_list").toStringList ();
   for (int i=0; i < curr_dirs.size (); i++)
     {
       _current_directory_combo_box->addItem (curr_dirs.at (i));
     }
   emit settings_changed (settings);
 }
 
 void
@@ -666,27 +673,27 @@ main_window::set_window_layout (QSetting
     }
 
   restoreState (settings->value ("MainWindow/windowState").toByteArray ());
   restoreGeometry (settings->value ("MainWindow/geometry").toByteArray ());
   show ();  // main window is ready and can be shown (as first window)
 
   // show floating widgets after main win to ensure "Octave" in central menu
   foreach (octave_dock_widget *widget, float_and_visible)
-     widget->setVisible (true);
+    widget->setVisible (true);
 
 }
 
 void
 main_window::write_settings (void)
 {
   QSettings *settings = resource_manager::get_settings ();
   if (!settings)
     {
-      qDebug("Error: QSettings pointer from resource manager is NULL.");
+      qDebug ("Error: QSettings pointer from resource manager is NULL.");
       return;
     }
 
   settings->setValue ("MainWindow/geometry", saveGeometry ());
   settings->setValue ("MainWindow/windowState", saveState ());
   // write the list of recent used directories
   QStringList curr_dirs;
   for (int i=0; i<_current_directory_combo_box->count (); i++)
@@ -711,36 +718,36 @@ void
 main_window::copyClipboard (void)
 {
   if (_current_directory_combo_box->hasFocus ())
     {
       QLineEdit * edit = _current_directory_combo_box->lineEdit ();
       if (edit && edit->hasSelectedText ())
         {
           QClipboard *clipboard = QApplication::clipboard ();
-          clipboard->setText (edit->selectedText ()); 
+          clipboard->setText (edit->selectedText ());
         }
-    } 
+    }
   else
     emit copyClipboard_signal ();
 }
 
 void
 main_window::pasteClipboard (void)
 {
   if (_current_directory_combo_box->hasFocus ())
     {
       QLineEdit * edit = _current_directory_combo_box->lineEdit ();
       QClipboard *clipboard = QApplication::clipboard ();
       QString str =  clipboard->text ();
       if (edit && str.length () > 0)
         {
-          edit->insert (str); 
+          edit->insert (str);
         }
-    } 
+    }
   else
     emit pasteClipboard_signal ();
 }
 
 // Connect the signals emitted when the Octave thread wants to create
 // a dialog box of some sort.  Perhaps a better place for this would be
 // as part of the QUIWidgetCreator class.  However, mainWindow currently
 // is not a global variable and not accessible for connecting.
@@ -773,22 +780,24 @@ main_window::connect_uiwidget_links ()
   // Register QFloatList so that list of floats may be part of a signal.
   qRegisterMetaType<QFloatList> ("QFloatList");
   connect (&uiwidget_creator,
            SIGNAL (create_inputlayout (const QStringList&, const QString&,
                                        const QFloatList&, const QFloatList&,
                                        const QStringList&)),
            this,
            SLOT (handle_create_inputlayout (const QStringList&, const QString&,
-                                            const QFloatList&, const QFloatList&,
+                                            const QFloatList&,
+                                            const QFloatList&,
                                             const QStringList&)));
 
   connect (&uiwidget_creator,
            SIGNAL (create_filedialog (const QStringList &,const QString&,
-                                      const QString&, const QString&, const QString&)),
+                                      const QString&, const QString&,
+                                      const QString&)),
            this,
            SLOT (handle_create_filedialog (const QStringList &, const QString&,
                                            const QString&, const QString&,
                                            const QString&)));
 }
 
 // Create a message dialog with specified string, buttons and decorative
 // text.
@@ -841,18 +850,18 @@ main_window::handle_create_inputlayout (
                                                defaults);
 
   input_dialog->setAttribute (Qt::WA_DeleteOnClose);
   input_dialog->show ();
 }
 
 void
 main_window::handle_create_filedialog (const QStringList& filters,
-                                       const QString& title, 
-                                       const QString& filename, 
+                                       const QString& title,
+                                       const QString& filename,
                                        const QString& dirname,
                                        const QString& multimode)
 {
   FileDialog *file_dialog = new FileDialog (filters, title, filename,
                                             dirname, multimode);
 
   file_dialog->setAttribute (Qt::WA_DeleteOnClose);
   file_dialog->show ();
@@ -916,18 +925,18 @@ main_window::construct (void)
   addDockWidget (Qt::RightDockWidgetArea, editor_window);
   tabifyDockWidget (command_window, editor_window);
 #endif
 
   addDockWidget (Qt::LeftDockWidgetArea, file_browser_window);
   addDockWidget (Qt::LeftDockWidgetArea, workspace_window);
   addDockWidget (Qt::LeftDockWidgetArea, history_window);
 
-  int win_x = QApplication::desktop()->width();
-  int win_y = QApplication::desktop()->height();
+  int win_x = QApplication::desktop ()->width ();
+  int win_y = QApplication::desktop ()->height ();
 
   if (win_x > 960)
     win_x = 960;
 
   if (win_y > 720)
     win_y = 720;
 
   setGeometry (0, 0, win_x, win_y);
@@ -945,17 +954,19 @@ main_window::construct (void)
   connect (this,
            SIGNAL (delete_debugger_pointer_signal (const QString&, int)),
            editor_window,
            SLOT (handle_delete_debugger_pointer_request (const QString&, int)));
 
   connect (this,
            SIGNAL (update_breakpoint_marker_signal (bool, const QString&, int)),
            editor_window,
-           SLOT (handle_update_breakpoint_marker_request (bool, const QString&, int)));
+           SLOT (handle_update_breakpoint_marker_request (bool,
+                                                          const QString&,
+                                                          int)));
 #endif
 
   QDir curr_dir;
   set_current_working_directory (curr_dir.absolutePath ());
 
   octave_link::post_event (this, &main_window::resize_command_window_callback);
 
   set_global_shortcuts (true);
@@ -1030,17 +1041,18 @@ main_window::construct_octave_qt_link (v
   connect (_octave_qt_link,
            SIGNAL (delete_debugger_pointer_signal (const QString&, int)),
            this,
            SLOT (handle_delete_debugger_pointer_request (const QString&, int)));
 
   connect (_octave_qt_link,
            SIGNAL (update_breakpoint_marker_signal (bool, const QString&, int)),
            this,
-           SLOT (handle_update_breakpoint_marker_request (bool, const QString&, int)));
+           SLOT (handle_update_breakpoint_marker_request (bool, const QString&,
+                                                          int)));
 
   connect (_octave_qt_link,
            SIGNAL (show_doc_signal (const QString &)),
            this, SLOT (handle_show_doc (const QString &)));
 
   connect (_workspace_model,
            SIGNAL (rename_variable (const QString&, const QString&)),
            this,
@@ -1185,22 +1197,22 @@ main_window::construct_edit_menu (QMenuB
   _find_files_action = edit_menu->addAction (tr ("Find Files..."));
 
   edit_menu->addSeparator ();
 
   QAction *clear_command_window_action
     = edit_menu->addAction (tr ("Clear Command Window"));
 
   QAction *clear_command_history
-    = edit_menu->addAction(tr ("Clear Command History"));
+    = edit_menu->addAction (tr ("Clear Command History"));
 
   QAction *clear_workspace_action
     = edit_menu->addAction (tr ("Clear Workspace"));
 
-  connect (_find_files_action, SIGNAL (triggered()),
+  connect (_find_files_action, SIGNAL (triggered ()),
            this, SLOT (find_files ()));
 
   connect (clear_command_window_action, SIGNAL (triggered ()),
            this, SLOT (handle_clear_command_window_request ()));
 
   connect (clear_command_history, SIGNAL (triggered ()),
            this, SLOT (handle_clear_history_request ()));
 
@@ -1231,36 +1243,39 @@ main_window::construct_debug_menu_item (
 }
 
 void
 main_window::construct_debug_menu (QMenuBar *p)
 {
   _debug_menu = p->addMenu (tr ("De&bug"));
 
   _debug_step_over = construct_debug_menu_item
-    (":/actions/icons/db_step.png", tr ("Step"), Qt::Key_F10);
+                       (":/actions/icons/db_step.png", tr ("Step"),
+                        Qt::Key_F10);
 
   _debug_step_into = construct_debug_menu_item
-    (":/actions/icons/db_step_in.png", tr ("Step in"), Qt::Key_F11);
+                       (":/actions/icons/db_step_in.png", tr ("Step in"),
+                        Qt::Key_F11);
 
   _debug_step_out = construct_debug_menu_item
-    (":/actions/icons/db_step_out.png", tr ("Step out"),
-     Qt::ShiftModifier + Qt::Key_F11);
+                      (":/actions/icons/db_step_out.png", tr ("Step out"),
+                       Qt::ShiftModifier + Qt::Key_F11);
 
   _debug_continue = construct_debug_menu_item
-    (":/actions/icons/db_cont.png", tr ("Continue"), Qt::Key_F5);
+                      (":/actions/icons/db_cont.png", tr ("Continue"),
+                       Qt::Key_F5);
 
   _debug_menu->addSeparator ();
 #ifdef HAVE_QSCINTILLA
   editor_window->debug_menu ()->addSeparator ();
 #endif
 
   _debug_quit = construct_debug_menu_item
-    (":/actions/icons/db_stop.png", tr ("Exit Debug Mode"),
-     Qt::ShiftModifier + Qt::Key_F5);
+                (":/actions/icons/db_stop.png", tr ("Exit Debug Mode"),
+                 Qt::ShiftModifier + Qt::Key_F5);
 
   connect (_debug_step_over, SIGNAL (triggered ()),
            this, SLOT (debug_step_over ()));
 
   connect (_debug_step_into, SIGNAL (triggered ()),
            this, SLOT (debug_step_into ()));
 
   connect (_debug_step_out, SIGNAL (triggered ()),
@@ -1291,58 +1306,72 @@ void
 main_window::construct_window_menu (QMenuBar *p)
 {
   QMenu *window_menu = p->addMenu (tr ("&Window"));
 
   QKeySequence ctrl = Qt::ControlModifier;
   QKeySequence ctrl_shift = Qt::ControlModifier + Qt::ShiftModifier;
 
   QAction *show_command_window_action = construct_window_menu_item
-    (window_menu, tr ("Show Command Window"), true, ctrl_shift + Qt::Key_0);
+                                        (window_menu,
+                                         tr ("Show Command Window"), true,
+                                         ctrl_shift + Qt::Key_0);
 
   QAction *show_history_action = construct_window_menu_item
-    (window_menu, tr ("Show Command History"), true, ctrl_shift + Qt::Key_1);
+                                 (window_menu, tr ("Show Command History"),
+                                  true, ctrl_shift + Qt::Key_1);
 
   QAction *show_file_browser_action =  construct_window_menu_item
-    (window_menu, tr ("Show File Browser"), true, ctrl_shift + Qt::Key_2);
+                                       (window_menu, tr ("Show File Browser"),
+                                        true, ctrl_shift + Qt::Key_2);
 
   QAction *show_workspace_action = construct_window_menu_item
-    (window_menu, tr ("Show Workspace"), true, ctrl_shift + Qt::Key_3);
+                                   (window_menu, tr ("Show Workspace"), true,
+                                    ctrl_shift + Qt::Key_3);
 
   QAction *show_editor_action = construct_window_menu_item
-    (window_menu, tr ("Show Editor"), true, ctrl_shift + Qt::Key_4);
+                                (window_menu, tr ("Show Editor"), true,
+                                 ctrl_shift + Qt::Key_4);
 
   QAction *show_documentation_action = construct_window_menu_item
-    (window_menu, tr ("Show Documentation"), true, ctrl_shift + Qt::Key_5);
+                                       (window_menu, tr ("Show Documentation"),
+                                        true, ctrl_shift + Qt::Key_5);
 
   QAction *show_news_action = construct_window_menu_item
-    (window_menu, tr ("Show News Window"), true, ctrl_shift + Qt::Key_6);
+                              (window_menu, tr ("Show News Window"), true,
+                               ctrl_shift + Qt::Key_6);
 
   window_menu->addSeparator ();
 
   QAction *command_window_action = construct_window_menu_item
-    (window_menu, tr ("Command Window"), false, ctrl + Qt::Key_0);
+                                   (window_menu, tr ("Command Window"), false,
+                                    ctrl + Qt::Key_0);
 
   QAction *history_action = construct_window_menu_item
-    (window_menu, tr ("Command History"), false, ctrl + Qt::Key_1);
+                            (window_menu, tr ("Command History"), false,
+                             ctrl + Qt::Key_1);
 
   QAction *file_browser_action = construct_window_menu_item
-    (window_menu, tr ("File Browser"), false, ctrl + Qt::Key_2);
+                                 (window_menu, tr ("File Browser"), false,
+                                  ctrl + Qt::Key_2);
 
   QAction *workspace_action = construct_window_menu_item
-    (window_menu, tr ("Workspace"), false, ctrl + Qt::Key_3);
+                              (window_menu, tr ("Workspace"), false,
+                               ctrl + Qt::Key_3);
 
   QAction *editor_action = construct_window_menu_item
-    (window_menu, tr ("Editor"), false, ctrl + Qt::Key_4);
+                           (window_menu, tr ("Editor"), false,
+                            ctrl + Qt::Key_4);
 
   QAction *documentation_action = construct_window_menu_item
-    (window_menu, tr ("Documentation"), false, ctrl + Qt::Key_5);
+                                  (window_menu, tr ("Documentation"), false,
+                                   ctrl + Qt::Key_5);
 
   QAction *news_action = construct_window_menu_item
-    (window_menu, tr ("News"), false, ctrl + Qt::Key_6);
+                         (window_menu, tr ("News"), false, ctrl + Qt::Key_6);
 
   window_menu->addSeparator ();
 
   QAction *reset_windows_action
     = window_menu->addAction (tr ("Reset Default Window Layout"));
 
   connect (show_command_window_action, SIGNAL (toggled (bool)),
            command_window, SLOT (setVisible (bool)));
@@ -1514,39 +1543,40 @@ main_window::construct_tool_bar (void)
   _main_tool_bar->addAction (_paste_action);
   _main_tool_bar->addAction (_undo_action);
 
   _main_tool_bar->addSeparator ();
 
   _current_directory_combo_box = new QComboBox (this);
   _current_directory_combo_box->setFixedWidth (current_directory_width);
   _current_directory_combo_box->setEditable (true);
-  _current_directory_combo_box->setInsertPolicy(QComboBox::NoInsert);
+  _current_directory_combo_box->setInsertPolicy (QComboBox::NoInsert);
   _current_directory_combo_box->setToolTip (tr ("Enter directory name"));
-  _current_directory_combo_box->setMaxVisibleItems (current_directory_max_visible);
+  _current_directory_combo_box->setMaxVisibleItems (
+    current_directory_max_visible);
   _current_directory_combo_box->setMaxCount (current_directory_max_count);
-  QSizePolicy sizePol(QSizePolicy::Expanding, QSizePolicy::Preferred);
-  _current_directory_combo_box->setSizePolicy(sizePol);
+  QSizePolicy sizePol (QSizePolicy::Expanding, QSizePolicy::Preferred);
+  _current_directory_combo_box->setSizePolicy (sizePol);
 
   // addWidget takes ownership of the objects so there is no
   // need to delete these upon destroying this main_window.
   _main_tool_bar->addWidget (new QLabel (tr ("Current Directory: ")));
   _main_tool_bar->addWidget (_current_directory_combo_box);
   QAction *current_dir_up = _main_tool_bar->addAction (
-                                          QIcon (":/actions/icons/up.png"),
-                                          tr ("One directory up"));
+                              QIcon (":/actions/icons/up.png"),
+                              tr ("One directory up"));
   QAction *current_dir_search = _main_tool_bar->addAction (
-                                          QIcon (":/actions/icons/search.png"),
-                                          tr ("Browse directories"));
+                                  QIcon (":/actions/icons/search.png"),
+                                  tr ("Browse directories"));
 
   connect (_current_directory_combo_box, SIGNAL (activated (QString)),
            this, SLOT (set_current_working_directory (QString)));
 
-  connect (_current_directory_combo_box->lineEdit(), SIGNAL (returnPressed ()),
-            this, SLOT (accept_directory_line_edit ()));
+  connect (_current_directory_combo_box->lineEdit (), SIGNAL (returnPressed ()),
+           this, SLOT (accept_directory_line_edit ()));
 
   connect (current_dir_search, SIGNAL (triggered ()),
            this, SLOT (browse_for_directory ()));
 
   connect (current_dir_up, SIGNAL (triggered ()),
            this, SLOT (change_directory_up ()));
 
   connect (_undo_action, SIGNAL (triggered ()),
@@ -1574,17 +1604,17 @@ main_window::clear_workspace_callback (v
 }
 
 void
 main_window::rename_variable_callback (const main_window::name_pair& names)
 {
   /* bool status = */ symbol_table::rename (names.first, names.second);
 
   // if (status)
-    octave_link::set_workspace (true, symbol_table::workspace_info ());
+  octave_link::set_workspace (true, symbol_table::workspace_info ());
 
   //  else
   //    ; // we need an octave_link action that runs a GUI error option.
 }
 
 void
 main_window::command_window_undo_callback (void)
 {
@@ -1619,17 +1649,17 @@ main_window::execute_command_callback ()
   if (!_cmd_queue->isEmpty ())  // list can not be empty here, just to make sure
     {
       std::string pending_input = command_editor::get_current_line ();
       command_editor::set_initial_input (pending_input);
 
       _cmd_queue_mutex.lock (); // critical path
       std::string command = _cmd_queue->takeFirst ().toStdString ();
       if (_cmd_queue->isEmpty ())
-        _cmd_processing.release ();  // command queue empty, processing will stop
+        _cmd_processing.release ();  // cmd queue empty, processing will stop
       else
         repost = true;          // not empty, repost at end
       _cmd_queue_mutex.unlock ();
 
       command_editor::replace_line (command);
 
       command_editor::redisplay ();
       // We are executing inside the command editor event loop.  Force
@@ -1704,64 +1734,67 @@ main_window::debug_quit_callback (void)
 
 void
 main_window::exit_callback (void)
 {
   Fquit ();
 }
 
 void
-main_window::find_files(const QString &start_dir)
+main_window::find_files (const QString &start_dir)
 {
 
   if (! find_files_dlg)
     {
       find_files_dlg = new find_files_dialog (this);
 
       connect (find_files_dlg, SIGNAL (finished (int)),
                this, SLOT (find_files_finished (int)));
 
-      connect (find_files_dlg, SIGNAL (dir_selected(const QString &)),
-               file_browser_window, SLOT(set_current_directory(const QString&)));
+      connect (find_files_dlg, SIGNAL (dir_selected (const QString &)),
+               file_browser_window,
+               SLOT (set_current_directory (const QString&)));
 
-      connect (find_files_dlg, SIGNAL (file_selected(const QString &)),
-               this, SLOT(open_file(const QString &)));
+      connect (find_files_dlg, SIGNAL (file_selected (const QString &)),
+               this, SLOT (open_file (const QString &)));
 
       find_files_dlg->setWindowModality (Qt::NonModal);
     }
 
   if (! find_files_dlg->isVisible ())
     {
       find_files_dlg->show ();
     }
 
-  find_files_dlg->set_search_dir(start_dir);
+  find_files_dlg->set_search_dir (start_dir);
 
   find_files_dlg->activateWindow ();
 
 }
 
-void 
-main_window::find_files_finished(int)
+void
+main_window::find_files_finished (int)
 {
 
 }
 
 void
 main_window::set_global_shortcuts (bool set_shortcuts)
 {
   if (set_shortcuts)
     {
 
       _open_action->setShortcut (QKeySequence::Open);
       _new_script_action->setShortcut (QKeySequence::New);
 
       _exit_action->setShortcut (QKeySequence::Quit);
 
-      _find_files_action->setShortcut (Qt::ControlModifier + Qt::ShiftModifier + Qt::Key_F);
+      _find_files_action->setShortcut (Qt::ControlModifier
+                                       + Qt::ShiftModifier
+                                       + Qt::Key_F);
 
     }
   else
     {
 
       QKeySequence no_key = QKeySequence ();
 
       _open_action->setShortcut (no_key);
diff --git a/libgui/src/main-window.h b/libgui/src/main-window.h
--- a/libgui/src/main-window.h
+++ b/libgui/src/main-window.h
@@ -110,31 +110,32 @@ public slots:
   void open_file (const QString& file_name = QString ());
   void open_online_documentation_page (void);
   void display_release_notes (void);
   void open_bug_tracker_page (void);
   void open_octave_packages_page (void);
   void open_agora_page (void);
   void open_contribute_page (void);
   void open_developer_page (void);
-  void process_settings_dialog_request (const QString& desired_tab = QString ());
+  void process_settings_dialog_request (const QString& desired_tab
+                                                         = QString ());
   void show_about_octave (void);
   void notice_settings (const QSettings *settings);
   void prepare_to_exit (void);
   void exit (int status);
   void reset_windows (void);
 
   void change_directory (const QString& dir);
   void browse_for_directory (void);
   void set_current_working_directory (const QString& dir);
   void change_directory_up (void);
   void accept_directory_line_edit (void);
 
-  void execute_command_in_terminal(const QString& dir);
-  void run_file_in_terminal(const QFileInfo& info);
+  void execute_command_in_terminal (const QString& dir);
+  void run_file_in_terminal (const QFileInfo& info);
 
   void handle_new_figure_request (void);
 
   void handle_enter_debugger (void);
   void handle_exit_debugger (void);
   void debug_continue (void);
   void debug_step_into (void);
   void debug_step_over (void);
@@ -168,26 +169,26 @@ public slots:
                                const QStringList& prompt,
                                const QString& ok_string,
                                const QString& cancel_string);
 
   void handle_create_inputlayout (const QStringList&, const QString&,
                                   const QFloatList&, const QFloatList&,
                                   const QStringList&);
 
-  void handle_create_filedialog (const QStringList &filters, 
-                                 const QString& title, const QString& filename, 
+  void handle_create_filedialog (const QStringList &filters,
+                                 const QString& title, const QString& filename,
                                  const QString &dirname,
                                  const QString& multimode);
 
   void handle_show_doc (const QString &file);
 
-  // find files dialog 
-  void find_files(const QString &startdir=QDir::currentPath());
-  void find_files_finished(int);
+  // find files dialog
+  void find_files (const QString &startdir=QDir::currentPath ());
+  void find_files_finished (int);
 
   // setting global shortcuts
   void set_global_shortcuts (bool enable);
 
   // handling the clipboard
   void clipboard_has_changed (QClipboard::Mode);
   void clear_clipboard ();
 
diff --git a/libgui/src/news-dock-widget.h b/libgui/src/news-dock-widget.h
--- a/libgui/src/news-dock-widget.h
+++ b/libgui/src/news-dock-widget.h
@@ -47,31 +47,31 @@ protected slots:
 private:
 
   QTextBrowser *browser;
 };
 
 class news_reader : public QObject
 {
   Q_OBJECT
- 
+
 public:
 
   news_reader (const QString& xbase_url, const QString& xpage)
     : QObject (), base_url (xbase_url), page (xpage) { }
- 
+
 public slots:
 
-    void process (void);
- 
+  void process (void);
+
 signals:
 
   void display_news_signal (const QString& news);
 
   void finished (void);
- 
+
 private:
 
   QString base_url;
   QString page;
 };
 
 #endif // NEWSDOCKWIDGET_H
diff --git a/libgui/src/octave-dock-widget.cc b/libgui/src/octave-dock-widget.cc
--- a/libgui/src/octave-dock-widget.cc
+++ b/libgui/src/octave-dock-widget.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 #include <QLabel>
 #include <QSettings>
 
 #include "resource-manager.h"
 #include "octave-dock-widget.h"
 
 
 octave_dock_widget::octave_dock_widget (QWidget *p)
-    : QDockWidget (p)
+  : QDockWidget (p)
 {
 
   _parent = static_cast<QMainWindow *> (p);     // store main window
 
   connect (this, SIGNAL (visibilityChanged (bool)),
            this, SLOT (handle_visibility_changed (bool)));
 
   connect (p, SIGNAL (settings_changed (const QSettings*)),
@@ -53,28 +53,28 @@ octave_dock_widget::octave_dock_widget (
   // the custom (extra) title bar of the widget
   _dock_action = new QAction
                    (QIcon (":/actions/icons/widget-undock.png"), "", this);
   _dock_action-> setToolTip (tr ("Undock widget"));
   connect (_dock_action, SIGNAL (triggered (bool)),
            this, SLOT (change_floating (bool)));
   QToolButton *dock_button = new QToolButton (this);
   dock_button->setDefaultAction (_dock_action);
-  dock_button->setFocusPolicy(Qt::NoFocus);
-  dock_button->setIconSize(QSize(12,12));
+  dock_button->setFocusPolicy (Qt::NoFocus);
+  dock_button->setIconSize (QSize (12,12));
 
   QAction *close_action = new QAction
                    (QIcon (":/actions/icons/widget-close.png"), "", this );
   close_action-> setToolTip (tr ("Hide widget"));
   connect (close_action, SIGNAL (triggered (bool)),
            this, SLOT (change_visibility (bool)));
   QToolButton *close_button = new QToolButton (this);
   close_button->setDefaultAction (close_action);
-  close_button->setFocusPolicy(Qt::NoFocus);
-  close_button->setIconSize(QSize(12,12));
+  close_button->setFocusPolicy (Qt::NoFocus);
+  close_button->setIconSize (QSize (12,12));
 
   QHBoxLayout *h_layout = new QHBoxLayout ();
   h_layout->addStretch (100);
   h_layout->addWidget (dock_button);
   h_layout->addWidget (close_button);
   h_layout->setSpacing (0);
   h_layout->setContentsMargins (6,0,0,0);
 
@@ -90,32 +90,35 @@ octave_dock_widget::octave_dock_widget (
                QDockWidget::DockWidgetFloatable); // floatable and closeable
 
   connect (this, SIGNAL (topLevelChanged (bool)),
            this, SLOT (change_floating (bool)));
 
 #endif
 
   // copy & paste handling
-  connect (p, SIGNAL (copyClipboard_signal ()), this, SLOT (copyClipboard ()));
-  connect (p, SIGNAL (pasteClipboard_signal()), this, SLOT (pasteClipboard ()));
+  connect (p, SIGNAL (copyClipboard_signal ()),
+           this, SLOT (copyClipboard ()));
+  connect (p, SIGNAL (pasteClipboard_signal ()),
+           this, SLOT (pasteClipboard ()));
 }
 
 octave_dock_widget::~octave_dock_widget ()
 {
   // save state of this dock-widget
   bool floating = false;
   bool visible;
   QString name = objectName ();
   QSettings *settings = resource_manager::get_settings ();
 
   settings->beginGroup ("DockWidgets");
 
   if (!parent ())
-    { // widget is floating (windows), save actual floating geometry
+    {
+      // widget is floating (windows), save actual floating geometry
       floating = true;
       settings->setValue (name+"_floating_geometry", saveGeometry ());
     }
   else  // not floating save docked (normal) geometry
     settings->setValue (name, saveGeometry ());
 
   visible = isVisible ();
   settings->setValue (name+"Floating", floating);  // store floating state
@@ -136,17 +139,17 @@ octave_dock_widget::connect_visibility_c
 
 
 // set the title in the dockwidgets title bar
 void
 octave_dock_widget::set_title (const QString& title)
 {
 #if defined (Q_OS_WIN32)
   QHBoxLayout* h_layout =
-      static_cast<QHBoxLayout *> (titleBarWidget ()->layout ());
+    static_cast<QHBoxLayout *> (titleBarWidget ()->layout ());
   QLabel *label = new QLabel (title);
   h_layout->insertWidget (0,label);
 #endif
   setWindowTitle (title);
 }
 
 // make the widget floating
 void
@@ -165,18 +168,18 @@ octave_dock_widget::make_window ()
   settings->sync ();
 
   // remove parent and adjust the (un)dock icon
   setParent (0, Qt::Window);
   _dock_action->setIcon (QIcon (":/actions/icons/widget-dock.png"));
   _dock_action->setToolTip (tr ("Dock widget"));
 
   // restore the last geometry when floating
-  restoreGeometry (settings->value
-          ("DockWidgets/" + objectName ()+"_floating_geometry").toByteArray ());
+  restoreGeometry (settings->value ("DockWidgets/" + objectName ()
+                                    + "_floating_geometry").toByteArray ());
 
 #else
 
   // non windows: Just set the appripriate window flag
   setWindowFlags (Qt::Window);
 
 #endif
 
@@ -193,22 +196,24 @@ octave_dock_widget::make_widget (bool do
   QSettings *settings = resource_manager::get_settings ();
 
   // save last floating geometry
   settings->setValue ("DockWidgets/" + objectName () + "_floating_geometry",
                       saveGeometry ());
   settings->sync ();
 
   if (dock)
-    { // add widget to last saved docking area (dock=true is default)
+    {
+      // add widget to last saved docking area (dock=true is default)
       int area = settings->value ("DockWidgets/" + objectName () + "_dock_area",
-                                   Qt::TopDockWidgetArea).toInt ();
+                                  Qt::TopDockWidgetArea).toInt ();
       _parent->addDockWidget (static_cast<Qt::DockWidgetArea> (area), this);
 
-      // FIXME: restoreGeometry is ignored for docked widgets and its child widget
+      // FIXME: restoreGeometry is ignored for docked widgets
+      //        and its child widget
       // restoreGeometry (settings->value
       //        ("DockWidgets/" + objectName ()).toByteArray ());
     }
   else  // only reparent, no docking
     setParent (_parent);
 
   // adjust the (un)dock icon
   _dock_action->setIcon (QIcon (":/actions/icons/widget-undock.png"));
@@ -220,19 +225,19 @@ octave_dock_widget::make_widget (bool do
   setWindowFlags (Qt::Widget);
 
 #endif
 }
 
 // slot for (un)dock action
 void
 octave_dock_widget::change_floating (bool floating)
- {
+{
 #if defined (Q_OS_WIN32)
-   if (parent())
+  if (parent ())
 #else
   if (floating)
 #endif
     {
       make_window ();
       focus ();
     }
   else
@@ -246,12 +251,12 @@ octave_dock_widget::change_visibility (b
   setVisible (false);
   emit active_changed (false);
 }
 
 // get focus widget
 QWidget *
 octave_dock_widget::focusWidget ()
 {
-    QWidget * w = QApplication::focusWidget ();
-    if(w && w->focusProxy ()) w = w->focusProxy ();
-    return w;
+  QWidget * w = QApplication::focusWidget ();
+  if (w && w->focusProxy ()) w = w->focusProxy ();
+  return w;
 }
diff --git a/libgui/src/octave-dock-widget.h b/libgui/src/octave-dock-widget.h
--- a/libgui/src/octave-dock-widget.h
+++ b/libgui/src/octave-dock-widget.h
@@ -53,17 +53,17 @@ signals:
 protected:
 
   virtual void closeEvent (QCloseEvent *e)
   {
     emit active_changed (false);
     QDockWidget::closeEvent (e);
   }
 
-  QWidget * focusWidget();
+  QWidget * focusWidget ();
 
 public slots:
 
   virtual void focus (void)
   {
     if (! isVisible ())
       setVisible (true);
 
diff --git a/libgui/src/octave-gui.cc b/libgui/src/octave-gui.cc
--- a/libgui/src/octave-gui.cc
+++ b/libgui/src/octave-gui.cc
@@ -81,55 +81,55 @@ private:
   char** m_argv;
   int m_result;
 };
 
 
 // Custom message handler for filtering some messages from Qt.
 
 void message_handler (QtMsgType type, const char *msg)
- {
-   switch (type)
-     {
-     case QtDebugMsg:
-       if (strncmp (msg, "QFileSystemWatcher: skipping native engine",42) != 0)
-         std::cerr << "Debug: " << msg << std::endl;
-       break;
+{
+  switch (type)
+    {
+    case QtDebugMsg:
+      if (strncmp (msg, "QFileSystemWatcher: skipping native engine",42) != 0)
+        std::cerr << "Debug: " << msg << std::endl;
+      break;
 
-     case QtWarningMsg:
-       std::cerr << "Warning: " << msg << std::endl;
-       break;
+    case QtWarningMsg:
+      std::cerr << "Warning: " << msg << std::endl;
+      break;
 
-     case QtCriticalMsg:
-       std::cerr << "Critical: " << msg << std::endl;
-       break;
+    case QtCriticalMsg:
+      std::cerr << "Critical: " << msg << std::endl;
+      break;
 
-     case QtFatalMsg:
-       std::cerr << "Fatal: " << msg << std::endl;
-       abort ();
+    case QtFatalMsg:
+      std::cerr << "Fatal: " << msg << std::endl;
+      abort ();
 
-     default:
-       break;
-     }
- }
+    default:
+      break;
+    }
+}
 
 // If START_GUI is false, we still set up the QApplication so that we
 // can use Qt widgets for plot windows.
 
 int
 octave_start_gui (int argc, char *argv[], bool start_gui)
 {
   qInstallMsgHandler (message_handler);
 
   QApplication application (argc, argv);
 
   if (start_gui)
     {
       // Set the codec for all strings
-      QTextCodec::setCodecForCStrings(QTextCodec::codecForName("UTF-8"));
+      QTextCodec::setCodecForCStrings (QTextCodec::codecForName ("UTF-8"));
 
       // install translators for the gui and qt text
       QTranslator gui_tr, qt_tr, qsci_tr;
       resource_manager::config_translators (&qt_tr,&qsci_tr,&gui_tr);
       application.installTranslator (&qt_tr);
       application.installTranslator (&qsci_tr);
       application.installTranslator (&gui_tr);
 
@@ -161,18 +161,19 @@ octave_start_gui (int argc, char *argv[]
               if (term.empty ())
                 octave_env::putenv ("TERM", "cygwin");
 #endif
 
               // create main window, read settings, and show window
               main_window w;
               w.read_settings ();  // get widget settings and window layout
               w.focus_command_window ();
-              w.connect_visibility_changed (); // connect signals for changes in
-              // visibility not before w is shown
+              w.connect_visibility_changed (); // connect signals for changes
+                                               // in visibility not before w
+                                               // is shown
               return application.exec ();
             }
         }
     }
   else
     {
       octave_cli_thread main_thread (argc, argv);
 
diff --git a/libgui/src/octave-qt-link.cc b/libgui/src/octave-qt-link.cc
--- a/libgui/src/octave-qt-link.cc
+++ b/libgui/src/octave-qt-link.cc
@@ -109,17 +109,17 @@ octave_qt_link::do_question_dialog (cons
                                   btn,
                                   QString::fromStdString (btndef),
                                   role);
 
   // Wait while the user is responding to message box.
   uiwidget_creator.wait ();
 
   // The GUI has sent a signal and the process has been awakened.
-  return uiwidget_creator.get_dialog_button().toStdString ();
+  return uiwidget_creator.get_dialog_button ().toStdString ();
 }
 
 static QStringList
 make_qstring_list (const std::list<std::string>& lst)
 {
   QStringList retval;
 
   for (std::list<std::string>::const_iterator it = lst.begin ();
@@ -148,20 +148,20 @@ make_filter_list (const octave_link::fil
       QString name = QString::fromStdString (it->second);
 
       // Strip out extensions from name and replace ';' with spaces in
       // list.
 
       name.replace (QRegExp ("\\(.*\\)"), "");
       ext.replace (";", " ");
 
-      if (name.length() == 0)
+      if (name.length () == 0)
         {
           // No name field.  Build one from the extensions.
-          name = ext.toUpper() + " Files";
+          name = ext.toUpper () + " Files";
         }
 
       retval.append (name + " (" + ext + ")");
     }
 
   return retval;
 }
 
@@ -245,35 +245,36 @@ octave_qt_link::do_file_dialog (const fi
   // Add all the file dialog results to a string list.
   const QStringList *inputLine = uiwidget_creator.get_string_list ();
 
   for (QStringList::const_iterator it = inputLine->begin ();
        it != inputLine->end (); it++)
     retval.push_back (it->toStdString ());
 
   retval.push_back (uiwidget_creator.get_dialog_path ()->toStdString ());
-  retval.push_back ((QString ("%1").arg (uiwidget_creator.get_dialog_result ())).toStdString ());
+  retval.push_back ((QString ("%1").arg (
+                       uiwidget_creator.get_dialog_result ())).toStdString ());
 
   return retval;
 }
 
 int
 octave_qt_link::do_debug_cd_or_addpath_error (const std::string& file,
                                               const std::string& dir,
                                               bool addpath_option)
 {
   int retval = -1;
 
   QString qdir = QString::fromStdString (dir);
   QString qfile = QString::fromStdString (file);
 
   QString msg
     = (addpath_option
-       ? tr ("The file %1 does not exist in the load path.  To debug the function you are editing, you must either change to the directory %2 or add that directory to the load path.").arg(qfile).arg(qdir)
-       : tr ("The file %1 is shadowed by a file with the same name in the load path.  To debug the function you are editing, change to the directory %2.").arg(qfile).arg(qdir));
+       ? tr ("The file %1 does not exist in the load path.  To debug the function you are editing, you must either change to the directory %2 or add that directory to the load path.").arg (qfile).arg (qdir)
+       : tr ("The file %1 is shadowed by a file with the same name in the load path.  To debug the function you are editing, change to the directory %2.").arg (qfile).arg (qdir));
 
   QString title = tr ("Change Directory or Add Directory to Load Path");
 
   QString cd_txt = tr ("Change Directory");
   QString addpath_txt = tr ("Add Directory to Load Path");
   QString cancel_txt = tr ("Cancel");
 
   QStringList btn;
@@ -397,17 +398,18 @@ octave_qt_link::do_exit_debugger_event (
 {
   emit exit_debugger_signal ();
 }
 
 void
 octave_qt_link::do_update_breakpoint (bool insert,
                                       const std::string& file, int line)
 {
-  emit update_breakpoint_marker_signal (insert, QString::fromStdString (file), line);
+  emit update_breakpoint_marker_signal (insert, QString::fromStdString (file),
+                                        line);
 }
 
 void
 octave_qt_link::do_set_default_prompts (std::string& ps1, std::string& ps2,
                                         std::string& ps4)
 {
   ps1 = ">> ";
   ps2 = "";
diff --git a/libgui/src/octave-qt-link.h b/libgui/src/octave-qt-link.h
--- a/libgui/src/octave-qt-link.h
+++ b/libgui/src/octave-qt-link.h
@@ -80,17 +80,17 @@ public:
   std::list<std::string>
   do_input_dialog (const std::list<std::string>& prompt,
                    const std::string& title,
                    const std::list<float>& nr,
                    const std::list<float>& nc,
                    const std::list<std::string>& defaults);
 
   std::list<std::string>
-  do_file_dialog (const filter_list& filter, const std::string& title, 
+  do_file_dialog (const filter_list& filter, const std::string& title,
                   const std::string &filename, const std::string &pathname,
                   const std::string& multimode);
 
   int
   do_debug_cd_or_addpath_error (const std::string& file,
                                 const std::string& dir,
                                 bool addpath_option);
 
diff --git a/libgui/src/qtinfo/parser.cc b/libgui/src/qtinfo/parser.cc
--- a/libgui/src/qtinfo/parser.cc
+++ b/libgui/src/qtinfo/parser.cc
@@ -161,17 +161,17 @@ parser::search_node (const QString& node
 }
 
 QString
 parser::search_node (const QString& node, QIODevice *io)
 {
   while (!io->atEnd ())
     {
       QString text = get_next_node (io);
-      if(node == get_node_name (text))
+      if (node == get_node_name (text))
         {
           return text;
         }
     }
 
   return QString ();
 }
 
@@ -182,22 +182,24 @@ parser::get_next_node (QIODevice *io)
   QByteArray line, line_buffer;
   char c;
   int i;
 
   while (!io->atEnd ())
     {
       io->getChar (&c);
       if (c)
-        { // first char is not equal 0
+        {
+          // first char is not equal 0
           io->ungetChar (c);
           line = io->readLine ();
         }
       else
-        { // 0 was read -> image -> text length changes
+        {
+          // 0 was read -> image -> text length changes
           line_buffer = io->readLine ();  // image tag that is not needed
           line = io->readLine ();         // firsts line of text message
           for (i=1; i<line_buffer.size ()+6; i++)  // correct the size
             line.insert (line.size ()-1,QByteArray(" "));   // by adding blanks
         }
 
       if (line.at (0) == '"' && line.size () == 5)  // end of image construct
         line = " ";
@@ -228,17 +230,17 @@ get_first_line (const QString& text)
   return first_line;
 }
 
 static QString
 parser_node (const QString& text, const QString& node_name)
 {
   QString firstLine = get_first_line (text);
   QStringList nodes = firstLine.split (",");
-  for (int i = 0;i < nodes.size (); i++)
+  for (int i = 0; i < nodes.size (); i++)
     {
       QString node = nodes.at (i).trimmed ();
 
       if (node.startsWith (node_name))
         {
           return node.remove (0, node_name.size ()).trimmed ();
         }
     }
@@ -326,33 +328,36 @@ replace_links (QString& text)
 static void
 replace_colons (QString& text)
 {
   QRegExp re ("`([^']+)'");
   int i = 0, f;
   while ( (i = re.indexIn (text, i)) != -1)
     {
       QString t = re.cap (1);
-      QString bold = "<font style=\"color:SteelBlue;font-weight:bold\">" + t + "</font>";
+      QString bold = "<font style=\"color:SteelBlue;font-weight:bold\">" + t +
+                     "</font>";
 
       f = re.matchedLength ();
       text.replace (i,f,bold);
       i += bold.size ();
     }
 }
 
 static void
 info_to_html (QString& text)
 {
   text.replace ("&", "&amp;");
   text.replace ("<", "&lt;");
   text.replace (">", "&gt;");
 
-  text.replace ("\n* Menu:", "\n<font style=\"color:DarkRed;font-weight:bold\">Menu:</font>");
-  text.replace ("See also:", "<font style=\"color:DarkRed;font-style:italic;font-weight:bold\">See also:</font>");
+  text.replace ("\n* Menu:",
+                "\n<font style=\"color:DarkRed;font-weight:bold\">Menu:</font>");
+  text.replace ("See also:",
+                "<font style=\"color:DarkRed;font-style:italic;font-weight:bold\">See also:</font>");
   replace_links (text);
   replace_colons (text);
 }
 
 QString
 parser::node_text_to_html (const QString& text_arg, int anchorPos,
                            const QString& anchor)
 {
@@ -370,18 +375,18 @@ parser::node_text_to_html (const QString
 
       int n = text1.indexOf ("\n");
       text1.remove (0, n);
 
       info_to_html (text1);
       info_to_html (text2);
 
       text = text1 + "<a name='" + anchor
-                   + "'/><img src=':/actions/icons/arrow_down.png'><br>&nbsp;"
-                   + text2;
+             + "'/><img src=':/actions/icons/arrow_down.png'><br>&nbsp;"
+             + text2;
     }
   else
     {
       int n = text.indexOf ("\n");
       text.remove (0, n);
       info_to_html (text);
     }
 
@@ -412,17 +417,17 @@ parser::node_text_to_html (const QString
 
 void
 parser::parse_info_map ()
 {
   QRegExp re ("(Node|Ref): ([^\\0177]+)\\0177(\\d+)\n");
   QRegExp re_files ("([^:]+): (\\d+)\n");
   int foundCount = 0;
 
-  for(int i = 0; i < _info_files.size (); i++)
+  for (int i = 0; i < _info_files.size (); i++)
     {
       QFileInfo fileInfo = _info_files.at (i);
 
       QIODevice *io = open_file (fileInfo);
       if (io == NULL)
         {
           continue;
         }
@@ -432,17 +437,18 @@ parser::parse_info_map ()
         {
           QString first_line = get_first_line (nodeText);
           if (first_line.startsWith ("Tag") )
             {
               foundCount++;
               int pos = 0;
               QString last_node;
 
-              while ((pos = re.indexIn (nodeText, pos)) != -1) {
+              while ((pos = re.indexIn (nodeText, pos)) != -1)
+                {
                   QString type = re.cap (1);
                   QString node = re.cap (2);
                   int index = re.cap (3).toInt ();
 
                   if (type == "Node")
                     {
                       node_map_item item;
                       item.pos = index;
@@ -460,22 +466,23 @@ parser::parse_info_map ()
                 }
               break;
             }
           else if (first_line.startsWith ("Indirect:"))
             {
               foundCount++;
               int pos = 0;
 
-              while ( (pos = re_files.indexIn (nodeText, pos)) != -1) {
+              while ( (pos = re_files.indexIn (nodeText, pos)) != -1)
+                {
                   QString fileCap = re_files.cap (1).trimmed ();
                   int index = re_files.cap (2).toInt ();
 
                   info_file_item item;
-                  for (int j = 0;j < _info_files.size (); j++)
+                  for (int j = 0; j < _info_files.size (); j++)
                     {
                       QFileInfo info = _info_files.at (j);
                       if (info.fileName ().startsWith (fileCap))
                         {
                           item.file_info = info;
                           break;
                         }
                     }
@@ -581,39 +588,42 @@ parser::global_search (const QString& te
             }
 
           int n = node_text.indexOf ("\n");
           node_text.remove (0, n);
 
           int pos = 0;
           int founds = 0;
 
-          for (; founds < words.size () && node_text.indexOf (words.at (founds)) >= 0; founds++)
+          for (; founds < words.size ()
+                 && node_text.indexOf (words.at (founds)) >= 0; founds++)
             { }
 
           if (founds<words.size ())
             {
               continue;
             }
           founds = 0;
 
-          while ( (pos = re.indexIn (node_text, pos)) != -1 && founds < max_founds)
+          while ((pos = re.indexIn (node_text, pos)) != -1
+                 && founds < max_founds)
             {
               int line_start, line_end;
               line_start = node_text.lastIndexOf ("\n", pos);
               line_end = node_text.indexOf ("\n", pos);
-              QString line = node_text.mid (line_start, line_end - line_start).trimmed ();
+              QString line = node_text.mid (line_start,
+                                            line_end - line_start).trimmed ();
               pos += re.matchedLength ();
 
               if (founds == 0)
                 {
                   results.append(
-                        "<br>\n<img src=':/actions/icons/bookmark.png' width=10> <a href='"
-                        + QString(QUrl::toPercentEncoding(node,"","'")) +
-                        "'>");
+                    "<br>\n<img src=':/actions/icons/bookmark.png' width=10> <a href='"
+                    + QString(QUrl::toPercentEncoding(node,"","'")) +
+                    "'>");
                   results.append (node);
                   results.append ("</a><br>\n");
                 }
 
               replace (line, re, "<i>%1</i>");
               results.append (line);
               results.append ("<br>\n");
 
@@ -623,23 +633,23 @@ parser::global_search (const QString& te
       io->close ();
       delete io;
     }
 
   results.append ("</body></html>");
   return results;
 }
 
-QString 
+QString
 parser::find_ref (const QString &ref_name)
 {
   QString text = "";
 
   QHash<QString,node_position>::iterator it;
-  for (it=_ref_map.begin ();it!=_ref_map.end ();++it)
+  for (it=_ref_map.begin (); it!=_ref_map.end (); ++it)
     {
       QString k = it.key ();
       node_position p = it.value ();
 
       if (k == "XREF" + ref_name)
         {
           // found ref, so return its name
           text = "XREF" + ref_name;
diff --git a/libgui/src/qtinfo/parser.h b/libgui/src/qtinfo/parser.h
--- a/libgui/src/qtinfo/parser.h
+++ b/libgui/src/qtinfo/parser.h
@@ -34,43 +34,44 @@ along with Octave; see the file COPYING.
  * This class gets nodes and searchs inside of 'info files'.
  * <p>Each info file has nodes. Every node has the documentation.
  * Info files contains a map with position of each node.</p>
  * <p>What is position?
  * There is a simple answer:
  * If you make a queue with info files, position will be the number of bytes
  * from begining to node position.</p>
  * <p>
- * But is not so easy. There is headers, and qtinfo must not take these headers into account.
+ * But is not so easy. There is headers, and qtinfo must not take these
+ * headers into account.
  * </p>
  * <p>
  * This class also translates info files to html.
  * </p>
  */
 class parser
-    : public QObject
+  : public QObject
 {
   Q_OBJECT
 
 public:
   parser (QObject *parent = 0);
   void set_info_path (const QString& _info_path);
   QString get_info_path ();
   QString search_node (const QString& node);
   QString global_search (const QString& text, int maxFounds);
 
   QString find_ref (const QString &name);
 
-  /** Checks if this node is reference. If node is reference, it will be returned its position
-    * in text, else  it will be returned -1.
+  /** Checks if this node is reference. If node is reference, it will be
+   *  returned its position in text, else it will be returned -1.
     */
   int is_ref (const QString& node);
 
-  /**Translates text of node to Html. If anchorPos is not -1, then anchor is inserted in that
-    * position.
+  /** Translates text of node to Html. If anchorPos is not -1, then anchor is
+   *  inserted in that position.
     */
   QString node_text_to_html (const QString& text, int anchorPos = -1,
                              const QString& anchor = QString ());
 
 private:
   struct node_position
   {
     QString _node_name;
diff --git a/libgui/src/qtinfo/webinfo.cc b/libgui/src/qtinfo/webinfo.cc
--- a/libgui/src/qtinfo/webinfo.cc
+++ b/libgui/src/qtinfo/webinfo.cc
@@ -71,25 +71,28 @@ webinfo::webinfo (QWidget *p)
   _stacked_widget = new QStackedWidget (this);
   vbox_layout->addWidget (_stacked_widget);
 
   hbox_layout = new QHBoxLayout ();
   vbox_layout->addLayout (hbox_layout);
 
   _search_line_edit = new QLineEdit(this);
 #ifdef HAVE_SETPLACEHOLDERTEXT
-  _search_line_edit->setPlaceholderText (tr ("Type here and press \'Return\' to search"));
+  _search_line_edit->setPlaceholderText (
+    tr ("Type here and press \'Return\' to search"));
 #endif
   hbox_layout->addWidget (_search_line_edit);
 
   _search_check_box = new QCheckBox (tr ("Global search"));
   hbox_layout->addWidget (_search_check_box);
 
-  connect (_tab_bar, SIGNAL (tabCloseRequested (int)), this, SLOT (close_tab (int)));
-  connect (_tab_bar, SIGNAL (currentChanged (int)), this, SLOT (current_tab_changed (int)));
+  connect (_tab_bar, SIGNAL (tabCloseRequested (int)), this,
+           SLOT (close_tab (int)));
+  connect (_tab_bar, SIGNAL (currentChanged (int)), this,
+           SLOT (current_tab_changed (int)));
   connect (_zoom_in_button, SIGNAL (clicked ()), this, SLOT (zoom_in ()));
   connect (_zoom_out_button, SIGNAL (clicked ()), this, SLOT (zoom_out ()));
   connect (_search_line_edit, SIGNAL (returnPressed ()), this, SLOT (search ()));
 
   resize (500, 300);
 
   set_info_path (QString::fromStdString (Vinfo_file));
 
@@ -105,17 +108,17 @@ webinfo::set_info_path (const QString& i
 void
 webinfo::load_node (const QString& node_name)
 {
   // no XREF in the tabs
   QString tab_text = node_name;
   tab_text.replace("XREF","");
 
   //Check if node has been already opened.
-  for (int i = 0;i < _tab_bar->count (); i++)
+  for (int i = 0; i < _tab_bar->count (); i++)
     {
       if (tab_text == _tab_bar->tabText (i))
         {
           _tab_bar->setCurrentIndex (i);
           return;
         }
     }
 
@@ -156,29 +159,32 @@ webinfo::current_tab_changed (int index)
 
 QTextBrowser *
 webinfo::addNewTab (const QString& name)
 {
   _text_browser = new QTextBrowser (this);
   _text_browser->setOpenLinks (false);
   _text_browser->show ();
 
-  connect (_text_browser, SIGNAL (anchorClicked (const QUrl &)), this, SLOT (link_clicked (const QUrl &)) );
-  disconnect(_tab_bar, SIGNAL (currentChanged(int)), this, SLOT (current_tab_changed (int)));
+  connect (_text_browser, SIGNAL (anchorClicked (const QUrl &)), this,
+           SLOT (link_clicked (const QUrl &)) );
+  disconnect(_tab_bar, SIGNAL (currentChanged(int)), this,
+             SLOT (current_tab_changed (int)));
 
   int ns = _stacked_widget->addWidget (_text_browser);
   _stacked_widget->setCurrentIndex (ns);
 
   int nt = _tab_bar->addTab (name);
   _tab_bar->setCurrentIndex (nt);
   QVariant tab_data;
   tab_data.setValue (static_cast<void*> (_text_browser));
   _tab_bar->setTabData (nt, tab_data);
 
-  connect (_tab_bar, SIGNAL (currentChanged (int)), this, SLOT (current_tab_changed (int)));
+  connect (_tab_bar, SIGNAL (currentChanged (int)), this,
+           SLOT (current_tab_changed (int)));
 
   if (_text_browser->font () != _font_web)
     {
       _text_browser->setFont (_font_web);
     }
   return _text_browser;
 }
 
@@ -202,21 +208,21 @@ webinfo::load_ref (const QString &ref_na
   QString text = _parser.find_ref (ref_name);
   if (text.length () > 0)
     {
       load_node (text);
     }
   else
     {
       // not found
-     load_node("Top");
+      load_node("Top");
     }
 
-   if (_text_browser)
-     _text_browser->setFocus(); 
+  if (_text_browser)
+    _text_browser->setFocus();
 }
 
 void
 webinfo::search ()
 {
   if (_search_check_box->isChecked ())
     {
       // Global search
@@ -262,13 +268,13 @@ webinfo::copyClipboard ()
 
 void
 webinfo::pasteClipboard ()
 {
   if (_search_line_edit->hasFocus ())
     {
       QClipboard *clipboard = QApplication::clipboard ();
       QString str =  clipboard->text ();
-      if (str.length () > 0) 
+      if (str.length () > 0)
         _search_line_edit->insert (str);
     }
 }
 
diff --git a/libgui/src/qtinfo/webinfo.h b/libgui/src/qtinfo/webinfo.h
--- a/libgui/src/qtinfo/webinfo.h
+++ b/libgui/src/qtinfo/webinfo.h
@@ -35,18 +35,18 @@ along with Octave; see the file COPYING.
 
 class webinfo : public QWidget
 {
   Q_OBJECT
 public:
   webinfo (QWidget *parent = 0);
   void set_info_path (const QString& info_path);
   void load_node (const QString& node_name);
- 
-  void load_ref (const QString &ref_name); 
+
+  void load_ref (const QString &ref_name);
 
 public slots:
   void link_clicked (const QUrl& link);
   void current_tab_changed (int index);
   void close_tab (int index);
   void search ();
   void zoom_in ();
   void zoom_out ();
diff --git a/libgui/src/resource-manager.cc b/libgui/src/resource-manager.cc
--- a/libgui/src/resource-manager.cc
+++ b/libgui/src/resource-manager.cc
@@ -24,17 +24,17 @@ along with Octave; see the file COPYING.
 #include <config.h>
 #endif
 
 #include <string>
 
 #include <QFile>
 #include <QDir>
 #include <QNetworkProxy>
- #include <QLibraryInfo>
+#include <QLibraryInfo>
 
 #include "error.h"
 #include "file-ops.h"
 #include "help.h"
 #include "oct-env.h"
 #include "singleton-cleanup.h"
 
 #include "defaults.h"
@@ -84,34 +84,35 @@ resource_manager::get_gui_translation_di
 
 void
 resource_manager::config_translators (QTranslator *qt_tr,
                                       QTranslator *qsci_tr,
                                       QTranslator *gui_tr)
 {
   bool loaded;
 
-  QString qt_trans_dir = QLibraryInfo::location(QLibraryInfo::TranslationsPath);
+  QString qt_trans_dir
+    = QLibraryInfo::location (QLibraryInfo::TranslationsPath);
   QSettings *settings = resource_manager::get_settings ();
-  // FIXME -- what should happen if settings is 0?
+  // FIXME: what should happen if settings is 0?
 
   // get the locale from the settings
   QString language = settings->value ("language","SYSTEM").toString ();
   if (language == "SYSTEM")
-      language = QLocale::system().name();    // get system wide locale
+    language = QLocale::system ().name ();    // get system wide locale
 
   // load the translator file for qt strings
-  loaded = qt_tr->load("qt_" + language, qt_trans_dir);
+  loaded = qt_tr->load ("qt_" + language, qt_trans_dir);
   if (!loaded) // try lower case
-    qt_tr->load("qt_" + language.toLower (), qt_trans_dir);
+    qt_tr->load ("qt_" + language.toLower (), qt_trans_dir);
 
   // load the translator file for qscintilla settings
-  loaded = qsci_tr->load("qscintilla_" + language, qt_trans_dir);
+  loaded = qsci_tr->load ("qscintilla_" + language, qt_trans_dir);
   if (!loaded) // try lower case
-    qsci_tr->load("qscintilla_" + language.toLower (), qt_trans_dir);
+    qsci_tr->load ("qscintilla_" + language.toLower (), qt_trans_dir);
 
   // load the translator file for gui strings
   gui_tr->load (language, get_gui_translation_dir ());
 }
 
 bool
 resource_manager::instance_ok (void)
 {
@@ -173,17 +174,17 @@ resource_manager::do_reload_settings (vo
 {
   QDesktopServices desktopServices;
   home_path = desktopServices.storageLocation (QDesktopServices::HomeLocation);
   QString settings_path = do_get_settings_path ();
   QString settings_file = do_get_settings_file ();
 
   if (!QFile::exists (settings_file))
     {
-      QDir("/").mkpath (settings_path);
+      QDir ("/").mkpath (settings_path);
       QFile::copy (default_qt_settings_file (), settings_file);
       first_run = true;
     }
   else
     first_run = false;
 
   do_set_settings (settings_file);
 }
@@ -222,29 +223,29 @@ resource_manager::do_update_network_sett
   proxy.setHostName (settings->value ("proxyHostName").toString ());
   proxy.setPort (settings->value ("proxyPort",80).toInt ());
   proxy.setUser (settings->value ("proxyUserName").toString ());
   proxy.setPassword (settings->value ("proxyPassword").toString ());
 
   QNetworkProxy::setApplicationProxy (proxy);
 }
 
-QStringList 
+QStringList
 resource_manager::storage_class_names (void)
 {
   return workspace_model::storage_class_names ();
 }
 
 QList<QColor>
 resource_manager::storage_class_default_colors (void)
 {
   return workspace_model::storage_class_default_colors ();
 }
 
-QStringList 
+QStringList
 resource_manager::terminal_color_names (void)
 {
   return QTerminal::color_names ();
 }
 
 QList<QColor>
 resource_manager::terminal_default_colors (void)
 {
diff --git a/libgui/src/settings-dialog.cc b/libgui/src/settings-dialog.cc
--- a/libgui/src/settings-dialog.cc
+++ b/libgui/src/settings-dialog.cc
@@ -52,111 +52,147 @@ along with Octave; see the file COPYING.
 #endif
 
 settings_dialog::settings_dialog (QWidget *p, const QString& desired_tab):
   QDialog (p), ui (new Ui::settings_dialog)
 {
   ui->setupUi (this);
 
   QSettings *settings = resource_manager::get_settings ();
-  // FIXME -- what should happen if settings is 0?
+  // FIXME: what should happen if settings is 0?
 
   // look for available language files and the actual settings
   QString qm_dir_name = resource_manager::get_gui_translation_dir ();
   QDir qm_dir (qm_dir_name);
   QFileInfoList qm_files = qm_dir.entryInfoList (QStringList ("*.qm"),
                                                  QDir::Files | QDir::Readable,
                                                  QDir::Name);
-  for (int i = 0; i < qm_files.length (); i++)    // insert available languages
+  for (int i = 0; i < qm_files.length (); i++)   // insert available languages
     ui->comboBox_language->addItem (qm_files.at (i).baseName ());
-  ui->comboBox_language->insertItem (0,tr("System setting")); // System at beginning
-  ui->comboBox_language->insertSeparator (1);         // separator after System
+  // System at beginning
+  ui->comboBox_language->insertItem (0,tr ("System setting"));
+  ui->comboBox_language->insertSeparator (1);    // separator after System
   QString language = settings->value ("language","SYSTEM").toString ();
   if (language == "SYSTEM")
-    language = tr("System setting");
+    language = tr ("System setting");
   int selected = ui->comboBox_language->findText (language);
   if (selected >= 0)
     ui->comboBox_language->setCurrentIndex (selected);
   else
     ui->comboBox_language->setCurrentIndex (0);  // System is default
 
-  ui->toolbar_icon_size->setValue (settings->value ("toolbar_icon_size",24).toInt ());
+  ui->toolbar_icon_size->setValue (settings->value ("toolbar_icon_size",
+                                                    24).toInt ());
 
   // which icon has to be selected
   QString widget_icon_set =
-      settings->value ("DockWidgets/widget_icon_set","NONE").toString ();
+    settings->value ("DockWidgets/widget_icon_set","NONE").toString ();
   ui->general_icon_octave-> setChecked (true);  // the default (if invalid set)
   ui->general_icon_octave-> setChecked (widget_icon_set == "NONE");
   ui->general_icon_graphic-> setChecked (widget_icon_set == "GRAPHIC");
   ui->general_icon_letter-> setChecked (widget_icon_set == "LETTER");
 
-  ui->useCustomFileEditor->setChecked (settings->value ("useCustomFileEditor",false).toBool ());
-  ui->customFileEditor->setText (settings->value ("customFileEditor").toString ());
-  ui->editor_showLineNumbers->setChecked (settings->value ("editor/showLineNumbers",true).toBool () );
+  ui->useCustomFileEditor->setChecked (settings->value ("useCustomFileEditor",
+                                                        false).toBool ());
+  ui->customFileEditor->setText (
+    settings->value ("customFileEditor").toString ());
+  ui->editor_showLineNumbers->setChecked (
+    settings->value ("editor/showLineNumbers",true).toBool () );
 
   QVariant default_var = QColor (240, 240, 240);
   QColor setting_color = settings->value ("editor/highlight_current_line_color",
                                           default_var).value<QColor> ();
   _editor_current_line_color = new color_picker (setting_color);
   ui->editor_grid_current_line->addWidget (_editor_current_line_color,0,3);
   _editor_current_line_color->setMinimumSize (50,10);
   _editor_current_line_color->setEnabled (false);
   connect (ui->editor_highlightCurrentLine, SIGNAL (toggled (bool)),
            _editor_current_line_color, SLOT (setEnabled (bool)));
-  ui->editor_highlightCurrentLine->setChecked (settings->value ("editor/highlightCurrentLine",true).toBool () );
+  ui->editor_highlightCurrentLine->setChecked (
+    settings->value ("editor/highlightCurrentLine",true).toBool () );
 
-  ui->editor_codeCompletion->setChecked (settings->value ("editor/codeCompletion",true).toBool () );
-  ui->editor_spinbox_ac_threshold->setValue (settings->value ("editor/codeCompletion_threshold",2).toInt ());
-  ui->editor_checkbox_ac_keywords->setChecked (settings->value ("editor/codeCompletion_keywords",true).toBool ());
-  ui->editor_checkbox_ac_document->setChecked (settings->value ("editor/codeCompletion_document",false).toBool ());
-  ui->editor_checkbox_ac_case->setChecked (settings->value ("editor/codeCompletion_case",true).toBool ());
-  ui->editor_checkbox_ac_replace->setChecked (settings->value ("editor/codeCompletion_replace",false).toBool ());
-  ui->editor_ws_checkbox->setChecked (settings->value ("editor/show_white_space",false).toBool ());
-  ui->editor_ws_indent_checkbox->setChecked (settings->value ("editor/show_white_space_indent",false).toBool ());
-  ui->editor_auto_ind_checkbox->setChecked (settings->value ("editor/auto_indent",true).toBool ());
-  ui->editor_tab_ind_checkbox->setChecked (settings->value ("editor/tab_indents_line",false).toBool ());
-  ui->editor_bs_unind_checkbox->setChecked (settings->value ("editor/backspace_unindents_line",false).toBool ());
-  ui->editor_ind_guides_checkbox->setChecked (settings->value ("editor/show_indent_guides",false).toBool ());
-  ui->editor_ind_width_spinbox->setValue (settings->value ("editor/indent_width",2).toInt ());
-  ui->editor_tab_width_spinbox->setValue (settings->value ("editor/tab_width",2).toInt ());
-  ui->editor_longWindowTitle->setChecked (settings->value ("editor/longWindowTitle",false).toBool ());
-  ui->editor_restoreSession->setChecked (settings->value ("editor/restoreSession",true).toBool ());
-  ui->editor_create_new_file->setChecked (settings->value ("editor/create_new_file",false).toBool ());
-  ui->terminal_fontName->setCurrentFont (QFont (settings->value ("terminal/fontName","Courier New").toString()) );
-  ui->terminal_fontSize->setValue (settings->value ("terminal/fontSize",10).toInt ());
-  ui->showFileSize->setChecked (settings->value ("filesdockwidget/showFileSize",false).toBool());
-  ui->showFileType->setChecked (settings->value ("filesdockwidget/showFileType",false).toBool());
-  ui->showLastModified->setChecked (settings->value ("filesdockwidget/showLastModified",false).toBool());
-  ui->showHiddenFiles->setChecked (settings->value ("filesdockwidget/showHiddenFiles",false).toBool());
-  ui->useAlternatingRowColors->setChecked (settings->value ("filesdockwidget/useAlternatingRowColors",true).toBool());
-  ui->sync_octave_directory->setChecked (settings->value ("filesdockwidget/sync_octave_directory",true).toBool());
-  ui->useProxyServer->setChecked (settings->value ("useProxyServer",false).toBool ());
+  ui->editor_codeCompletion->setChecked (
+    settings->value ("editor/codeCompletion", true).toBool () );
+  ui->editor_spinbox_ac_threshold->setValue (
+    settings->value ("editor/codeCompletion_threshold",2).toInt ());
+  ui->editor_checkbox_ac_keywords->setChecked (
+    settings->value ("editor/codeCompletion_keywords",true).toBool ());
+  ui->editor_checkbox_ac_document->setChecked (
+    settings->value ("editor/codeCompletion_document",false).toBool ());
+  ui->editor_checkbox_ac_case->setChecked (
+    settings->value ("editor/codeCompletion_case",true).toBool ());
+  ui->editor_checkbox_ac_replace->setChecked (
+    settings->value ("editor/codeCompletion_replace",false).toBool ());
+  ui->editor_ws_checkbox->setChecked (
+    settings->value ("editor/show_white_space", false).toBool ());
+  ui->editor_ws_indent_checkbox->setChecked (
+    settings->value ("editor/show_white_space_indent",false).toBool ());
+  ui->editor_auto_ind_checkbox->setChecked (
+    settings->value ("editor/auto_indent", true).toBool ());
+  ui->editor_tab_ind_checkbox->setChecked (
+    settings->value ("editor/tab_indents_line",false).toBool ());
+  ui->editor_bs_unind_checkbox->setChecked (
+    settings->value ("editor/backspace_unindents_line",false).toBool ());
+  ui->editor_ind_guides_checkbox->setChecked (
+    settings->value ("editor/show_indent_guides",false).toBool ());
+  ui->editor_ind_width_spinbox->setValue (
+    settings->value ("editor/indent_width", 2).toInt ());
+  ui->editor_tab_width_spinbox->setValue (
+    settings->value ("editor/tab_width", 2).toInt ());
+  ui->editor_longWindowTitle->setChecked (
+    settings->value ("editor/longWindowTitle",false).toBool ());
+  ui->editor_restoreSession->setChecked (
+    settings->value ("editor/restoreSession", true).toBool ());
+  ui->editor_create_new_file->setChecked (
+    settings->value ("editor/create_new_file",false).toBool ());
+  ui->terminal_fontName->setCurrentFont (QFont (
+    settings->value ("terminal/fontName","Courier New").toString ()) );
+  ui->terminal_fontSize->setValue (
+    settings->value ("terminal/fontSize", 10).toInt ());
+  ui->showFileSize->setChecked (
+    settings->value ("filesdockwidget/showFileSize", false).toBool ());
+  ui->showFileType->setChecked (
+    settings->value ("filesdockwidget/showFileType", false).toBool ());
+  ui->showLastModified->setChecked (
+    settings->value ("filesdockwidget/showLastModified",false).toBool ());
+  ui->showHiddenFiles->setChecked (
+    settings->value ("filesdockwidget/showHiddenFiles",false).toBool ());
+  ui->useAlternatingRowColors->setChecked (
+    settings->value ("filesdockwidget/useAlternatingRowColors",true).toBool ());
+  ui->sync_octave_directory->setChecked (
+    settings->value ("filesdockwidget/sync_octave_directory",true).toBool ());
+  ui->useProxyServer->setChecked (
+    settings->value ("useProxyServer", false).toBool ());
   ui->proxyHostName->setText (settings->value ("proxyHostName").toString ());
-  ui->terminal_cursorBlinking->setChecked (settings->value ("terminal/cursorBlinking",true).toBool ());
-  ui->terminal_cursorUseForegroundColor->setChecked (settings->value ("terminal/cursorUseForegroundColor",true).toBool ());
+  ui->terminal_cursorBlinking->setChecked (
+    settings->value ("terminal/cursorBlinking",true).toBool ());
+  ui->terminal_cursorUseForegroundColor->setChecked (
+    settings->value ("terminal/cursorUseForegroundColor",true).toBool ());
 
-  QString cursorType = settings->value ("terminal/cursorType","ibeam").toString ();
+  QString cursorType
+    = settings->value ("terminal/cursorType", "ibeam").toString ();
 
   QStringList items;
-  items << QString("0") << QString("1") << QString("2");
-  ui->terminal_cursorType->addItems(items);
+  items << QString ("0") << QString ("1") << QString ("2");
+  ui->terminal_cursorType->addItems (items);
   ui->terminal_cursorType->setItemText (0, tr ("IBeam Cursor"));
   ui->terminal_cursorType->setItemText (1, tr ("Block Cursor"));
   ui->terminal_cursorType->setItemText (2, tr ("Underline Cursor"));
 
   if (cursorType == "ibeam")
     ui->terminal_cursorType->setCurrentIndex (0);
   else if (cursorType == "block")
     ui->terminal_cursorType->setCurrentIndex (1);
   else if (cursorType == "underline")
     ui->terminal_cursorType->setCurrentIndex (2);
 
   int currentIndex = 0;
   QString proxyTypeString = settings->value ("proxyType").toString ();
-  while ( (currentIndex < ui->proxyType->count ()) && (ui->proxyType->currentText () != proxyTypeString))
+  while ( (currentIndex < ui->proxyType->count ())
+          && (ui->proxyType->currentText () != proxyTypeString))
     {
       currentIndex++;
       ui->proxyType->setCurrentIndex (currentIndex);
     }
 
   ui->proxyPort->setText (settings->value ("proxyPort").toString ());
   ui->proxyUserName->setText (settings->value ("proxyUserName").toString ());
   ui->proxyPassword->setText (settings->value ("proxyPassword").toString ());
@@ -193,23 +229,25 @@ settings_dialog::settings_dialog (QWidge
   delete lexer;
   lexer = new QsciLexerBash ();
   read_lexer_settings (lexer,settings);
   delete lexer;
 #endif
 
   // which tab is the desired one?
   if (desired_tab.isEmpty ())
-    ui->tabWidget->setCurrentIndex (settings->value("settings/last_tab",0).toInt ());
+    ui->tabWidget->setCurrentIndex (settings->value ("settings/last_tab",
+                                    0).toInt ());
   else
     {
       QHash <QString, QWidget*> tab_hash;
       tab_hash["editor"] = ui->tab_editor;
       tab_hash["editor_styles"] = ui->tab_editor_styles;
-      ui->tabWidget->setCurrentIndex (ui->tabWidget->indexOf (tab_hash.value (desired_tab)));
+      ui->tabWidget->setCurrentIndex (
+        ui->tabWidget->indexOf (tab_hash.value (desired_tab)));
     }
 
 
 }
 
 settings_dialog::~settings_dialog ()
 {
   delete ui;
@@ -219,28 +257,29 @@ settings_dialog::~settings_dialog ()
 #ifdef HAVE_QSCINTILLA
 int
 settings_dialog::get_valid_lexer_styles (QsciLexer *lexer, int styles[])
 {
   int max_style = 0;
   int actual_style = 0;
   while (actual_style < MaxStyleNumber && max_style < MaxLexerStyles)
     {
-      if ((lexer->description(actual_style)) != "")  // valid style
+      if ((lexer->description (actual_style)) != "")  // valid style
         styles[max_style++] = actual_style;
       actual_style++;
     }
   return max_style;
 }
 
 void
 settings_dialog::read_lexer_settings (QsciLexer *lexer, QSettings *settings)
 {
   lexer->readSettings (*settings);
-  int styles[MaxLexerStyles];  // array for saving valid styles (enum is not continuous)
+  int styles[MaxLexerStyles];  // array for saving valid styles
+                               // (enum is not continuous)
   int max_style = get_valid_lexer_styles (lexer, styles);
   QGridLayout *style_grid = new QGridLayout ();
   QVector<QLabel*> description (max_style);
   QVector<QFontComboBox*> select_font (max_style);
   QVector<QSpinBox*> font_size (max_style);
   QVector<QCheckBox*> attrib_font (3 * max_style);
   QVector<color_picker*> color (max_style);
   QVector<color_picker*> bg_color (max_style);
@@ -280,27 +319,27 @@ settings_dialog::read_lexer_settings (Qs
             select_font[i]->setEditText (lexer->description (0));
           font_size[i]->setRange (-4,4);
           font_size[i]->setValue (actual_font.pointSize ()-default_size);
           font_size[i]->setToolTip (tr ("Difference to the default size"));
           if (lexer->paper (styles[i]) == default_color)
             bg_color[i] = new color_picker (dummy_color);
           else
             bg_color[i] = new color_picker (lexer->paper (styles[i]));
-            bg_color[i]->setToolTip
-                  (tr ("Background color, pink (255,0,255) means default"));
+          bg_color[i]->setToolTip
+          (tr ("Background color, pink (255,0,255) means default"));
         }
-      attrib_font[0+3*i] = new QCheckBox (tr("b"));
-      attrib_font[1+3*i] = new QCheckBox (tr("i"));
-      attrib_font[2+3*i] = new QCheckBox (tr("u"));
-      attrib_font[0+3*i]->setChecked(Qt::Checked && actual_font.bold ());
+      attrib_font[0+3*i] = new QCheckBox (tr ("b"));
+      attrib_font[1+3*i] = new QCheckBox (tr ("i"));
+      attrib_font[2+3*i] = new QCheckBox (tr ("u"));
+      attrib_font[0+3*i]->setChecked (Qt::Checked && actual_font.bold ());
       attrib_font[0+3*i]->setObjectName (actual_name+"_bold");
-      attrib_font[1+3*i]->setChecked(Qt::Checked && actual_font.italic ());
+      attrib_font[1+3*i]->setChecked (Qt::Checked && actual_font.italic ());
       attrib_font[1+3*i]->setObjectName (actual_name+"_italic");
-      attrib_font[2+3*i]->setChecked(Qt::Checked && actual_font.underline ());
+      attrib_font[2+3*i]->setChecked (Qt::Checked && actual_font.underline ());
       attrib_font[2+3*i]->setObjectName (actual_name+"_underline");
       color[i] = new color_picker (lexer->color (styles[i]));
       color[i]->setObjectName (actual_name+"_color");
       bg_color[i]->setObjectName (actual_name+"_bg_color");
       int column = 1;
       style_grid->addWidget (description[i],     i, column++);
       style_grid->addWidget (select_font[i],     i, column++);
       style_grid->addWidget (font_size[i],       i, column++);
@@ -314,41 +353,43 @@ settings_dialog::read_lexer_settings (Qs
   QScrollArea *scroll_area = new QScrollArea ();
   QWidget *scroll_area_contents = new QWidget ();
   scroll_area_contents->setObjectName (QString (lexer->language ())+"_styles");
   scroll_area_contents->setLayout (style_grid);
   scroll_area->setWidget (scroll_area_contents);
   ui->tabs_editor_lexers->addTab (scroll_area,lexer->language ());
 
   ui->tabs_editor_lexers->setCurrentIndex (
-          settings->value("settings/last_editor_styles_tab",0).toInt ());
+    settings->value ("settings/last_editor_styles_tab",0).toInt ());
 }
-#endif  
+#endif
 
 void
 settings_dialog::read_workspace_colors (QSettings *settings)
 {
 
-  QList<QColor> default_colors = resource_manager::storage_class_default_colors ();
+  QList<QColor> default_colors =
+    resource_manager::storage_class_default_colors ();
   QStringList class_names = resource_manager::storage_class_names ();
   QString class_chars = resource_manager::storage_class_chars ();
   int nr_of_classes = class_chars.length ();
 
   QGridLayout *style_grid = new QGridLayout ();
   QVector<QLabel*> description (nr_of_classes);
   QVector<color_picker*> color (nr_of_classes);
 
   int column = 0;
   int row = 0;
   for (int i = 0; i < nr_of_classes; i++)
     {
       description[i] = new QLabel ("    " + class_names.at (i));
       description[i]->setAlignment (Qt::AlignRight);
       QVariant default_var = default_colors.at (i);
-      QColor setting_color = settings->value ("workspaceview/color_"+class_chars.mid (i,1),
+      QColor setting_color = settings->value ("workspaceview/color_"
+                                              + class_chars.mid (i,1),
                                               default_var).value<QColor> ();
       color[i] = new color_picker (setting_color);
       color[i]->setObjectName ("color_"+class_chars.mid (i, 1));
       color[i]->setMinimumSize (30, 10);
       style_grid->addWidget (description[i], row, 3*column);
       style_grid->addWidget (color[i],       row, 3*column+1);
       if (++column == 3)
         {
@@ -377,17 +418,18 @@ settings_dialog::read_terminal_colors (Q
 
   int column = 0;
   int row = 0;
   for (int i = 0; i < nr_of_classes; i++)
     {
       description[i] = new QLabel ("    " + class_names.at (i));
       description[i]->setAlignment (Qt::AlignRight);
       QVariant default_var = default_colors.at (i);
-      QColor setting_color = settings->value ("terminal/color_"+class_chars.mid (i,1),
+      QColor setting_color = settings->value ("terminal/color_"
+                                              + class_chars.mid (i,1),
                                               default_var).value<QColor> ();
       color[i] = new color_picker (setting_color);
       color[i]->setObjectName ("terminal_color_"+class_chars.mid (i, 1));
       color[i]->setMinimumSize (30, 10);
       style_grid->addWidget (description[i], row, 2*column);
       style_grid->addWidget (color[i],       row, 2*column+1);
       if (++column == 2)
         {
@@ -400,72 +442,102 @@ settings_dialog::read_terminal_colors (Q
   // place grid with elements into the tab
   ui->terminal_colors_box->setLayout (style_grid);
 }
 
 void
 settings_dialog::write_changed_settings ()
 {
   QSettings *settings = resource_manager::get_settings ();
-  // FIXME -- what should happen if settings is 0?
+  // FIXME: what should happen if settings is 0?
 
   // the icon set
   QString widget_icon_set = "NONE";
   if (ui->general_icon_letter->isChecked ())
     widget_icon_set = "LETTER";
   else if (ui->general_icon_graphic->isChecked ())
     widget_icon_set = "GRAPHIC";
   settings->setValue ("DockWidgets/widget_icon_set",widget_icon_set);
 
   // language
   QString language = ui->comboBox_language->currentText ();
-  if (language == tr("System setting"))
+  if (language == tr ("System setting"))
     language = "SYSTEM";
   settings->setValue ("language", language);
 
   // other settings
   settings->setValue ("toolbar_icon_size", ui->toolbar_icon_size->value ());
-  settings->setValue ("useCustomFileEditor", ui->useCustomFileEditor->isChecked ());
+  settings->setValue ("useCustomFileEditor",
+                      ui->useCustomFileEditor->isChecked ());
   settings->setValue ("customFileEditor", ui->customFileEditor->text ());
-  settings->setValue ("editor/showLineNumbers", ui->editor_showLineNumbers->isChecked ());
-  settings->setValue ("editor/highlightCurrentLine", ui->editor_highlightCurrentLine->isChecked ());
-  settings->setValue ("editor/highlight_current_line_color",_editor_current_line_color->color ());
-  settings->setValue ("editor/codeCompletion", ui->editor_codeCompletion->isChecked ());
-  settings->setValue ("editor/codeCompletion_threshold", ui->editor_spinbox_ac_threshold->value ());
-  settings->setValue ("editor/codeCompletion_keywords", ui->editor_checkbox_ac_keywords->isChecked ());
-  settings->setValue ("editor/codeCompletion_document", ui->editor_checkbox_ac_document->isChecked ());
-  settings->setValue ("editor/codeCompletion_case", ui->editor_checkbox_ac_case->isChecked ());
-  settings->setValue ("editor/codeCompletion_replace", ui->editor_checkbox_ac_replace->isChecked ());
-  settings->setValue ("editor/show_white_space", ui->editor_ws_checkbox->isChecked ());
-  settings->setValue ("editor/show_white_space_indent", ui->editor_ws_indent_checkbox->isChecked ());
-  settings->setValue ("editor/auto_indent", ui->editor_auto_ind_checkbox->isChecked ());
-  settings->setValue ("editor/tab_indents_line", ui->editor_tab_ind_checkbox->isChecked ());
-  settings->setValue ("editor/backspace_unindents_line", ui->editor_bs_unind_checkbox->isChecked ());
-  settings->setValue ("editor/show_indent_guides", ui->editor_ind_guides_checkbox->isChecked ());
-  settings->setValue ("editor/indent_width", ui->editor_ind_width_spinbox->value ());
-  settings->setValue ("editor/tab_width", ui->editor_tab_width_spinbox->value ());
-  settings->setValue ("editor/longWindowTitle", ui->editor_longWindowTitle->isChecked());
-  settings->setValue ("editor/restoreSession", ui->editor_restoreSession->isChecked ());
-  settings->setValue ("editor/create_new_file", ui->editor_create_new_file->isChecked ());
-  settings->setValue ("terminal/fontSize", ui->terminal_fontSize->value());
-  settings->setValue ("terminal/fontName", ui->terminal_fontName->currentFont().family());
-  settings->setValue ("filesdockwidget/showFileSize", ui->showFileSize->isChecked ());
-  settings->setValue ("filesdockwidget/showFileType", ui->showFileType->isChecked ());
-  settings->setValue ("filesdockwidget/showLastModified", ui->showLastModified->isChecked ());
-  settings->setValue ("filesdockwidget/showHiddenFiles", ui->showHiddenFiles->isChecked ());
-  settings->setValue ("filesdockwidget/useAlternatingRowColors", ui->useAlternatingRowColors->isChecked ());
-  settings->setValue ("filesdockwidget/sync_octave_directory", ui->sync_octave_directory->isChecked ());
+  settings->setValue ("editor/showLineNumbers",
+                      ui->editor_showLineNumbers->isChecked ());
+  settings->setValue ("editor/highlightCurrentLine",
+                      ui->editor_highlightCurrentLine->isChecked ());
+  settings->setValue ("editor/highlight_current_line_color",
+                      _editor_current_line_color->color ());
+  settings->setValue ("editor/codeCompletion",
+                      ui->editor_codeCompletion->isChecked ());
+  settings->setValue ("editor/codeCompletion_threshold",
+                      ui->editor_spinbox_ac_threshold->value ());
+  settings->setValue ("editor/codeCompletion_keywords",
+                      ui->editor_checkbox_ac_keywords->isChecked ());
+  settings->setValue ("editor/codeCompletion_document",
+                      ui->editor_checkbox_ac_document->isChecked ());
+  settings->setValue ("editor/codeCompletion_case",
+                      ui->editor_checkbox_ac_case->isChecked ());
+  settings->setValue ("editor/codeCompletion_replace",
+                      ui->editor_checkbox_ac_replace->isChecked ());
+  settings->setValue ("editor/show_white_space",
+                      ui->editor_ws_checkbox->isChecked ());
+  settings->setValue ("editor/show_white_space_indent",
+                      ui->editor_ws_indent_checkbox->isChecked ());
+  settings->setValue ("editor/auto_indent",
+                      ui->editor_auto_ind_checkbox->isChecked ());
+  settings->setValue ("editor/tab_indents_line",
+                      ui->editor_tab_ind_checkbox->isChecked ());
+  settings->setValue ("editor/backspace_unindents_line",
+                      ui->editor_bs_unind_checkbox->isChecked ());
+  settings->setValue ("editor/show_indent_guides",
+                      ui->editor_ind_guides_checkbox->isChecked ());
+  settings->setValue ("editor/indent_width",
+                      ui->editor_ind_width_spinbox->value ());
+  settings->setValue ("editor/tab_width",
+                      ui->editor_tab_width_spinbox->value ());
+  settings->setValue ("editor/longWindowTitle",
+                      ui->editor_longWindowTitle->isChecked ());
+  settings->setValue ("editor/restoreSession",
+                      ui->editor_restoreSession->isChecked ());
+  settings->setValue ("editor/create_new_file",
+                      ui->editor_create_new_file->isChecked ());
+  settings->setValue ("terminal/fontSize", ui->terminal_fontSize->value ());
+  settings->setValue ("terminal/fontName",
+                      ui->terminal_fontName->currentFont ().family ());
+  settings->setValue ("filesdockwidget/showFileSize",
+                      ui->showFileSize->isChecked ());
+  settings->setValue ("filesdockwidget/showFileType",
+                      ui->showFileType->isChecked ());
+  settings->setValue ("filesdockwidget/showLastModified",
+                      ui->showLastModified->isChecked ());
+  settings->setValue ("filesdockwidget/showHiddenFiles",
+                      ui->showHiddenFiles->isChecked ());
+  settings->setValue ("filesdockwidget/useAlternatingRowColors",
+                      ui->useAlternatingRowColors->isChecked ());
+  settings->setValue ("filesdockwidget/sync_octave_directory",
+                      ui->sync_octave_directory->isChecked ());
   settings->setValue ("useProxyServer", ui->useProxyServer->isChecked ());
   settings->setValue ("proxyType", ui->proxyType->currentText ());
   settings->setValue ("proxyHostName", ui->proxyHostName->text ());
   settings->setValue ("proxyPort", ui->proxyPort->text ());
   settings->setValue ("proxyUserName", ui->proxyUserName->text ());
   settings->setValue ("proxyPassword", ui->proxyPassword->text ());
-  settings->setValue ("terminal/cursorBlinking", ui->terminal_cursorBlinking->isChecked ());
-  settings->setValue ("terminal/cursorUseForegroundColor", ui->terminal_cursorUseForegroundColor->isChecked ());
+  settings->setValue ("terminal/cursorBlinking",
+                      ui->terminal_cursorBlinking->isChecked ());
+  settings->setValue ("terminal/cursorUseForegroundColor",
+                      ui->terminal_cursorUseForegroundColor->isChecked ());
 
   // the cursor
   QString cursorType;
   switch (ui->terminal_cursorType->currentIndex ())
     {
     case 0: cursorType = "ibeam"; break;
     case 1: cursorType = "block"; break;
     case 2: cursorType = "underline";  break;
@@ -501,26 +573,27 @@ settings_dialog::write_changed_settings 
   write_lexer_settings (lexer,settings);
   delete lexer;
 #endif
 
   write_workspace_colors (settings);
 
   write_terminal_colors (settings);
 
-  settings->setValue("settings/last_tab",ui->tabWidget->currentIndex ());
+  settings->setValue ("settings/last_tab",ui->tabWidget->currentIndex ());
 }
 
 #ifdef HAVE_QSCINTILLA
 void
 settings_dialog::write_lexer_settings (QsciLexer *lexer, QSettings *settings)
 {
   QWidget *tab = ui->tabs_editor_lexers->
-            findChild <QWidget *>(QString (lexer->language ())+"_styles");
-  int styles[MaxLexerStyles];  // array for saving valid styles (enum is not continuous)
+                 findChild <QWidget *>(QString (lexer->language ())+"_styles");
+  int styles[MaxLexerStyles];  // array for saving valid styles
+                               // (enum is not continuous)
   int max_style = get_valid_lexer_styles (lexer, styles);
   QFontComboBox *select_font;
   QSpinBox *font_size;
   QCheckBox *attrib_font[3];
   color_picker *color;
   color_picker *bg_color;
   int default_size = 10;
   QFont default_font = QFont ("Courier New",10,-1,0);
@@ -538,19 +611,18 @@ settings_dialog::write_lexer_settings (Q
       color          = tab->findChild <color_picker *>(actual_name+"_color");
       bg_color       = tab->findChild <color_picker *>(actual_name+"_bg_color");
       QFont new_font = default_font;
       if (select_font)
         {
           new_font = select_font->currentFont ();
           if (styles[i] == 0)
             default_font = new_font;
-          else
-            if (select_font->currentText () == lexer->description (0))
-              new_font = default_font;
+          else if (select_font->currentText () == lexer->description (0))
+            new_font = default_font;
         }
       if (font_size)
         {
           if (styles[i] == 0)
             {
               default_size = font_size->value ();
               new_font.setPointSize (font_size->value ());
             }
@@ -598,32 +670,32 @@ settings_dialog::write_workspace_colors 
 {
 
   QString class_chars = resource_manager::storage_class_chars ();
   color_picker *color;
 
   for (int i = 0; i < class_chars.length (); i++)
     {
       color = ui->workspace_colors_box->findChild <color_picker *>(
-                            "color_"+class_chars.mid (i,1));
+                "color_"+class_chars.mid (i,1));
       if (color)
         settings->setValue ("workspaceview/color_"+class_chars.mid (i,1),
                             color->color ());
     }
   settings->sync ();
 }
 
 void
 settings_dialog::write_terminal_colors (QSettings *settings)
 {
   QString class_chars = resource_manager::terminal_color_chars ();
   color_picker *color;
 
   for (int i = 0; i < class_chars.length (); i++)
     {
       color = ui->terminal_colors_box->findChild <color_picker *>(
-                            "terminal_color_"+class_chars.mid (i,1));
+                "terminal_color_"+class_chars.mid (i,1));
       if (color)
         settings->setValue ("terminal/color_"+class_chars.mid (i,1),
                             color->color ());
     }
   settings->sync ();
 }
diff --git a/libgui/src/settings-dialog.h b/libgui/src/settings-dialog.h
--- a/libgui/src/settings-dialog.h
+++ b/libgui/src/settings-dialog.h
@@ -35,17 +35,18 @@ class QsciLexer;
 namespace Ui
 {
   class settings_dialog;
 }
 
 class settings_dialog:public QDialog
 {
   Q_OBJECT public:
-  explicit settings_dialog (QWidget * parent, const QString& desired_tab = QString ());
+  explicit settings_dialog (QWidget * parent,
+                            const QString& desired_tab = QString ());
   ~settings_dialog ();
   void write_changed_settings ();
 
 private:
   Ui::settings_dialog * ui;
 #ifdef HAVE_QSCINTILLA
   void read_lexer_settings (QsciLexer *lexer, QSettings *settings);
   void write_lexer_settings (QsciLexer *lexer, QSettings *settings);
@@ -54,13 +55,13 @@ private:
          MaxStyleNumber = 128 };
 #endif
 
   void read_workspace_colors (QSettings *settings);
   void write_workspace_colors (QSettings *settings);
 
   void read_terminal_colors (QSettings *settings);
   void write_terminal_colors (QSettings *settings);
-  
+
   color_picker *_editor_current_line_color;
 };
 
 #endif // SETTINGSDIALOG_H
diff --git a/libgui/src/terminal-dock-widget.cc b/libgui/src/terminal-dock-widget.cc
--- a/libgui/src/terminal-dock-widget.cc
+++ b/libgui/src/terminal-dock-widget.cc
@@ -29,17 +29,17 @@ along with Octave; see the file COPYING.
 
 terminal_dock_widget::terminal_dock_widget (QWidget *p)
   : octave_dock_widget (p), terminal (QTerminal::create (p))
 {
   terminal->setObjectName ("OctaveTerminal");
   terminal->setFocusPolicy (Qt::StrongFocus);
 
   setObjectName ("TerminalDockWidget");
-  setWindowIcon (QIcon(":/actions/icons/logo.png"));
+  setWindowIcon (QIcon (":/actions/icons/logo.png"));
   set_title (tr ("Command Window"));
 
   setWidget (terminal);
 }
 
 bool
 terminal_dock_widget::has_focus (void) const
 {
diff --git a/libgui/src/welcome-wizard.cc b/libgui/src/welcome-wizard.cc
--- a/libgui/src/welcome-wizard.cc
+++ b/libgui/src/welcome-wizard.cc
@@ -51,23 +51,24 @@ welcome_wizard::welcome_wizard (QWidget 
 
   QVBoxLayout *message = new QVBoxLayout;
 
   QLabel *title = new QLabel (tr ("Welcome to Octave!"));
   QFont ft;
   ft.setPointSize (20);
   title->setFont (ft);
 
-  QLabel *msg_1 = new QLabel (tr ("You seem to be using the Octave graphical interface for the first  time on this computer.  Click 'Finish' to write a configuration file  and launch Octave GUI."));
+  QLabel *msg_1 = new QLabel (
+    tr ("You seem to be using the Octave graphical interface for the first  time on this computer.  Click 'Finish' to write a configuration file  and launch Octave GUI."));
   msg_1->setWordWrap (true);
 
   QString msg_2_text = QString (tr ("The configuration file is stored in %1. "
                                     "If that file exists, you will not see this "
                                     "dialog when Octave starts again.").
-                                    arg (resource_manager::get_settings_file ()));
+                                arg (resource_manager::get_settings_file ()));
   QLabel *msg_2 = new QLabel (msg_2_text);
   msg_2->setWordWrap (true);
 
   message->addWidget (title);
   message->addWidget (msg_1);
   message->addWidget (msg_2);
 
   QSpacerItem *logo_filler = new QSpacerItem (40, 20, QSizePolicy::Expanding,
diff --git a/libgui/src/workspace-model.cc b/libgui/src/workspace-model.cc
--- a/libgui/src/workspace-model.cc
+++ b/libgui/src/workspace-model.cc
@@ -113,88 +113,92 @@ workspace_model::flags (const QModelInde
 
 QVariant
 workspace_model::headerData (int section, Qt::Orientation orientation,
                              int role) const
 {
   if (orientation == Qt::Horizontal && role == Qt::DisplayRole)
     return _columnNames[section];
   else
-    return QVariant();
+    return QVariant ();
 }
 
 QVariant
 workspace_model::data (const QModelIndex& idx, int role) const
 {
   QVariant retval;
 
   if (idx.isValid ())
     {
       if (role == Qt::BackgroundColorRole)
         {
           QString class_chars = resource_manager::storage_class_chars ();
-          int actual_class = class_chars.indexOf (_scopes[idx.row()].toAscii ());
+          int actual_class
+            = class_chars.indexOf (_scopes[idx.row ()].toAscii ());
           if (actual_class >= 0)
             return QVariant (_storage_class_colors.at (actual_class));
           else
             return retval;
         }
 
       if (role == Qt::DisplayRole
           || (idx.column () == 0 && role == Qt::EditRole)
           || (idx.column () == 0 && role == Qt::ToolTipRole) )
         {
           switch (idx.column ())
             {
             case 0:
               if (role == Qt::ToolTipRole)
-                retval = QVariant (tr ("Right click to copy, rename, or display"));
+                retval
+                  = QVariant (tr ("Right click to copy, rename, or display"));
               else
-                retval = QVariant (_symbols[idx.row()]);
+                retval = QVariant (_symbols[idx.row ()]);
               break;
 
             case 1:
-              retval = QVariant (_class_names[idx.row()]);
+              retval = QVariant (_class_names[idx.row ()]);
               break;
 
             case 2:
-              retval = QVariant (_dimensions[idx.row()]);
+              retval = QVariant (_dimensions[idx.row ()]);
               break;
 
             case 3:
-              retval = QVariant (_values[idx.row()]);
+              retval = QVariant (_values[idx.row ()]);
               break;
 
             case 4:
               retval = QVariant ();
               QString class_chars = resource_manager::storage_class_chars ();
-              int actual_class = class_chars.indexOf (_scopes[idx.row()].toAscii ());
+              int actual_class
+                = class_chars.indexOf (_scopes[idx.row ()].toAscii ());
               if (actual_class >= 0)
                 {
-                  QStringList class_names = resource_manager::storage_class_names ();
+                  QStringList class_names
+                    = resource_manager::storage_class_names ();
                   retval = QVariant (class_names.at (actual_class));
                 }
               break;
 
-          }
-      }
+            }
+        }
     }
 
   return retval;
 }
 
 bool
 workspace_model::setData (const QModelIndex& idx, const QVariant& value,
                           int role)
 {
   bool retval = false;
 
   if (idx.column () == 0 && role == Qt::EditRole)
     {
-      QString qold_name = _symbols[idx.row()];
+      QString qold_name = _symbols[idx.row ()];
 
       QString qnew_name = value.toString ();
 
       std::string new_name = qnew_name.toStdString ();
 
       if (valid_identifier (new_name))
         {
           emit rename_variable (qold_name, qnew_name);
@@ -245,31 +249,33 @@ workspace_model::clear_data (void)
   _class_names = QStringList ();
   _dimensions = QStringList ();
   _values = QStringList ();
 }
 
 void
 workspace_model::update_table (void)
 {
-  beginResetModel();
+  beginResetModel ();
 
   // Nothing to do except tell the world to recalc.
 
   endResetModel ();
 
   emit model_changed ();
 }
 
 void
 workspace_model::notice_settings (const QSettings *settings)
 {
-  QList<QColor> default_colors = resource_manager::storage_class_default_colors ();
+  QList<QColor> default_colors =
+    resource_manager::storage_class_default_colors ();
   QString class_chars = resource_manager::storage_class_chars ();
 
   for (int i = 0; i < class_chars.length (); i++)
     {
       QVariant default_var = default_colors.at (i);
-      QColor setting_color = settings->value ("workspaceview/color_"+class_chars.mid (i,1),
-                                             default_var).value<QColor> ();
+      QColor setting_color = settings->value ("workspaceview/color_"
+                                              + class_chars.mid (i,1),
+                                              default_var).value<QColor> ();
       _storage_class_colors.replace (i,setting_color);
     }
 }
diff --git a/libgui/src/workspace-model.h b/libgui/src/workspace-model.h
--- a/libgui/src/workspace-model.h
+++ b/libgui/src/workspace-model.h
@@ -59,17 +59,18 @@ public:
                        int role = Qt::DisplayRole) const;
 
   int rowCount (const QModelIndex& parent = QModelIndex ()) const;
 
   int columnCount (const QModelIndex& parent = QModelIndex ()) const;
 
   bool is_top_level (void) const { return _top_level; }
 
-  QColor storage_class_color (int s_class) { return _storage_class_colors.at (s_class); }
+  QColor storage_class_color (int s_class)
+  { return _storage_class_colors.at (s_class); }
 
 public slots:
 
   void set_workspace (bool top_level,
                       const QString& scopes,
                       const QStringList& symbols,
                       const QStringList& class_names,
                       const QStringList& dimensions,
diff --git a/libgui/src/workspace-view.cc b/libgui/src/workspace-view.cc
--- a/libgui/src/workspace-view.cc
+++ b/libgui/src/workspace-view.cc
@@ -62,35 +62,36 @@ workspace_view::workspace_view (QWidget 
   // Set the empty widget to have our layout.
   widget ()->setLayout (vbox_layout);
 
   // Initialize collapse/expand state of the workspace subcategories.
 
   QSettings *settings = resource_manager::get_settings ();
 
   // Initialize column order and width of the workspace
-  
-  view->horizontalHeader ()->restoreState (settings->value ("workspaceview/column_state").toByteArray ());
+
+  view->horizontalHeader ()->restoreState (
+    settings->value ("workspaceview/column_state").toByteArray ());
 
   // Connect signals and slots.
 
   connect (view, SIGNAL (customContextMenuRequested (const QPoint&)),
-           this, SLOT(contextmenu_requested (const QPoint&)));
+           this, SLOT (contextmenu_requested (const QPoint&)));
 
   connect (this, SIGNAL (command_requested (const QString&)),
            p, SLOT (execute_command_in_terminal (const QString&)));
 
 }
 
 workspace_view::~workspace_view (void)
 {
   QSettings *settings = resource_manager::get_settings ();
 
-  settings->setValue("workspaceview/column_state",
-                     view->horizontalHeader ()->saveState ());
+  settings->setValue ("workspaceview/column_state",
+                      view->horizontalHeader ()->saveState ());
 
   settings->sync ();
 }
 
 void workspace_view::setModel (workspace_model *model)
 {
   view->setModel (model);
   _model = model;
@@ -107,22 +108,22 @@ void
 workspace_view::contextmenu_requested (const QPoint& qpos)
 {
   QMenu menu (this);
 
   QModelIndex index = view->indexAt (qpos);
   QAbstractItemModel *m = view->model ();
 
   // if it isnt Local, Glocal etc, allow the ctx menu
-  if (index.isValid() && index.column () == 0)
+  if (index.isValid () && index.column () == 0)
     {
-      index = index.sibling (index.row(), 0);
+      index = index.sibling (index.row (), 0);
 
       QMap<int, QVariant> item_data = m->itemData (index);
-  
+
       QString var_name = item_data[0].toString ();
 
       menu.addAction (tr ("Copy"), this,
                       SLOT (handle_contextmenu_copy ()));
 
       QAction *rename = menu.addAction (tr ("Rename"), this,
                                         SLOT (handle_contextmenu_rename ()));
 
@@ -131,63 +132,63 @@ workspace_view::contextmenu_requested (c
       if (! wm->is_top_level ())
         {
           rename->setDisabled (true);
           rename->setToolTip (tr ("Only top-level symbols may be renamed."));
         }
 
       menu.addSeparator ();
 
-      menu.addAction ("disp(" + var_name + ")", this,
+      menu.addAction ("disp (" + var_name + ")", this,
                       SLOT (handle_contextmenu_disp ()));
 
-      menu.addAction ("plot(" + var_name + ")", this,
+      menu.addAction ("plot (" + var_name + ")", this,
                       SLOT (handle_contextmenu_plot ()));
 
-      menu.addAction ("stem(" + var_name + ")", this,
+      menu.addAction ("stem (" + var_name + ")", this,
                       SLOT (handle_contextmenu_stem ()));
 
       menu.exec (view->mapToGlobal (qpos));
     }
 }
 
 void
 workspace_view::handle_contextmenu_copy (void)
 {
   QModelIndex index = view->currentIndex ();
 
   if (index.isValid ())
     {
-      index = index.sibling(index.row(), 0);
+      index = index.sibling (index.row (), 0);
 
       QAbstractItemModel *m = view->model ();
 
       QMap<int, QVariant> item_data = m->itemData (index);
-  
+
       QString var_name = item_data[0].toString ();
 
       QClipboard *clipboard = QApplication::clipboard ();
 
       clipboard->setText (var_name);
     }
 }
 
 void
 workspace_view::handle_contextmenu_rename (void)
 {
   QModelIndex index = view->currentIndex ();
 
   if (index.isValid ())
     {
-      index = index.sibling(index.row(), 0);
+      index = index.sibling (index.row (), 0);
 
       QAbstractItemModel *m = view->model ();
 
       QMap<int, QVariant> item_data = m->itemData (index);
-  
+
       QString var_name = item_data[0].toString ();
 
       QInputDialog* inputDialog = new QInputDialog ();
 
       inputDialog->setOptions (QInputDialog::NoButtons);
 
       bool ok = false;
 
@@ -220,22 +221,22 @@ workspace_view::handle_contextmenu_stem 
 
 void
 workspace_view::relay_contextmenu_command (const QString& cmdname)
 {
   QModelIndex index = view->currentIndex ();
 
   if (index.isValid ())
     {
-      index = index.sibling(index.row(), 0);
+      index = index.sibling (index.row (), 0);
 
       QAbstractItemModel *m = view->model ();
 
       QMap<int, QVariant> item_data = m->itemData (index);
-  
+
       QString var_name = item_data[0].toString ();
 
       emit command_requested (cmdname + " (" + var_name + ");");
     }
 }
 
 void
 workspace_view::handle_model_changed (void)
@@ -251,23 +252,24 @@ workspace_view::handle_model_changed (vo
 }
 
 void
 workspace_view::notice_settings (const QSettings *settings)
 {
   _model->notice_settings (settings); // update colors of model first
 
   QString tool_tip;
-  tool_tip  =  QString (tr ("View the variables in the active workspace.<br>"));
-  tool_tip +=  QString (tr ("Colors for the storage class:"));
+  tool_tip  = QString (tr ("View the variables in the active workspace.<br>"));
+  tool_tip += QString (tr ("Colors for the storage class:"));
   for (int i = 0; i < resource_manager::storage_class_chars ().length (); i++)
     {
-      tool_tip +=  QString ("<div style=\"background-color:%1;color:#000000\">%2</div>")
-               .arg (_model->storage_class_color (i).name ())
-               .arg (resource_manager::storage_class_names ().at (i));
+      tool_tip +=
+        QString ("<div style=\"background-color:%1;color:#000000\">%2</div>")
+        .arg (_model->storage_class_color (i).name ())
+        .arg (resource_manager::storage_class_names ().at (i));
     }
   setToolTip (tool_tip);
 }
 
 void
 workspace_view::copyClipboard ()
 {
   if (view->hasFocus ())
diff --git a/libgui/src/workspace-view.h b/libgui/src/workspace-view.h
--- a/libgui/src/workspace-view.h
+++ b/libgui/src/workspace-view.h
@@ -64,17 +64,17 @@ protected slots:
   void handle_contextmenu_copy (void);
   void handle_contextmenu_rename (void);
   void handle_contextmenu_disp (void);
   void handle_contextmenu_plot (void);
   void handle_contextmenu_stem (void);
 
   void handle_model_changed (void);
 
-  void copyClipboard();
+  void copyClipboard ();
 
 private:
 
   void relay_contextmenu_command (const QString& cmdname);
 
   QTableView *view;
   int view_previous_row_count;
   workspace_model *_model;
