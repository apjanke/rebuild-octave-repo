# HG changeset patch
# User jwe
# Date 858055733 0
#      Tue Mar 11 04:48:53 1997 +0000
# Node ID eedc2f3f61f79961185372dc9dd1f637b6eb02b7
# Parent  f96fae33b877a0a5bf7d7e879dbd996b39a65b8d
[project @ 1997-03-11 04:34:50 by jwe]

diff --git a/liboctave/ChangeLog b/liboctave/ChangeLog
--- a/liboctave/ChangeLog
+++ b/liboctave/ChangeLog
@@ -1,10 +1,33 @@
+Mon Mar 10 22:34:22 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
+
+	* CmplxCHOL.cc, CmplxHESS.cc, CmplxLU.cc, CmplxQR.cc,
+	CmplxQRP.cc, CmplxSCHUR.cc, CmplxSVD.cc, EIG.cc, dbleCHOL.cc,
+	dbleHESS.cc, dbleLU.cc, dbleQR.cc, dbleQRP.cc, dbleSCHUR.cc,
+	dbleSVD.cc: Don't include mx-inlines.cc.
+
+	* mx-inlines.cc: Abuse the preprocessor to eliminate lots of
+	duplicate code.
+
 Sun Mar  9 03:44:52 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
+	* dbleQR.h (QR): Delete extra comma at end of list.
+
+	* prog-args.cc (prog_args::getopt): Add missing const in cast.
+
+	* dbleSVD.h (SVD::type): Delete extra comma at end of list.
+
+	* idx-vector.h (idx_vector): Delete unnecessary idx_vector:: and
+	idx_vecotr_rep:: qualifiers.
+
+	* Array.h (class Array): Delete unnecessary Array<T>:: qualifiers.
+
+	* data-conv.h (save_type): Delete extra comma at end of list.
+
 	* CMatrix.cc, FEGrid.cc, Range.cc, dMatrix.cc, data-conv.cc,
 	dir-ops.cc, file-ops.h, idx-vector.cc, idx-vector.h, lo-ieee.cc,
 	lo-mappers.cc, oct-alloc.cc: Use `static_cast<T> (val)' instead of
 	old C-style `(T) val' casts.
 
 Thu Mar  6 20:20:01 1997  John W. Eaton  <jwe@bevo.che.wisc.edu>
 
 	* dMatrix.cc (operator >>): Return if an error occurs instead of
diff --git a/liboctave/CmplxCHOL.cc b/liboctave/CmplxCHOL.cc
--- a/liboctave/CmplxCHOL.cc
+++ b/liboctave/CmplxCHOL.cc
@@ -26,17 +26,16 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "CmplxCHOL.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
-#include "mx-inlines.cc"
 
 extern "C"
 {
   int F77_FCN (zpotrf, ZPOTRF) (const char*, const int&, Complex*,
 				const int&, int&, long);
 }
 
 int
diff --git a/liboctave/CmplxHESS.cc b/liboctave/CmplxHESS.cc
--- a/liboctave/CmplxHESS.cc
+++ b/liboctave/CmplxHESS.cc
@@ -26,17 +26,16 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "CmplxHESS.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
-#include "mx-inlines.cc"
 
 extern "C"
 {
   int F77_FCN (zgebal, ZGEBAL) (const char*, const int&, Complex*,
 				const int&, int&, int&, double*, int&,
 				long, long);
  
   int F77_FCN (zgehrd, ZGEHRD) (const int&, const int&, const int&,
diff --git a/liboctave/CmplxLU.cc b/liboctave/CmplxLU.cc
--- a/liboctave/CmplxLU.cc
+++ b/liboctave/CmplxLU.cc
@@ -26,17 +26,16 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "CmplxLU.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
-#include "mx-inlines.cc"
 
 // Instantiate the base LU class for the types we need.
 
 #include <base-lu.h>
 #include <base-lu.cc>
 
 template class base_lu <ComplexMatrix, Complex, Matrix, double>;
 
diff --git a/liboctave/CmplxQR.cc b/liboctave/CmplxQR.cc
--- a/liboctave/CmplxQR.cc
+++ b/liboctave/CmplxQR.cc
@@ -26,17 +26,16 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "CmplxQR.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
-#include "mx-inlines.cc"
 
 extern "C"
 {
   int F77_FCN (zgeqrf, ZGEQRF) (const int&, const int&, Complex*,
 				const int&, Complex*, Complex*,
 				const int&, int&); 
 
   int F77_FCN (zungqr, ZUNGQR) (const int&, const int&, const int&,
diff --git a/liboctave/CmplxQRP.cc b/liboctave/CmplxQRP.cc
--- a/liboctave/CmplxQRP.cc
+++ b/liboctave/CmplxQRP.cc
@@ -28,17 +28,16 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include <cassert>
 
 #include "CmplxQRP.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
-#include "mx-inlines.cc"
 
 extern "C"
 {
   int F77_FCN (zgeqpf, ZGEQPF) (const int&, const int&, Complex*,
 				const int&, int*, Complex*, Complex*,
 				double*, int&);
 
   int F77_FCN (zungqr, ZUNGQR) (const int&, const int&, const int&,
diff --git a/liboctave/CmplxSCHUR.cc b/liboctave/CmplxSCHUR.cc
--- a/liboctave/CmplxSCHUR.cc
+++ b/liboctave/CmplxSCHUR.cc
@@ -26,17 +26,16 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "CmplxSCHUR.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
-#include "mx-inlines.cc"
 
 extern "C"
 {
   int F77_FCN (zgeesx, ZGEESX) (const char*, const char*,
 				ComplexSCHUR::select_function,
 				const char*, const int&, Complex*,
 				const int&, int&, Complex*, Complex*,
 				const int&, double&, double&,
diff --git a/liboctave/CmplxSVD.cc b/liboctave/CmplxSVD.cc
--- a/liboctave/CmplxSVD.cc
+++ b/liboctave/CmplxSVD.cc
@@ -26,17 +26,16 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "CmplxSVD.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
-#include "mx-inlines.cc"
 
 extern "C"
 {
   int F77_FCN (zgesvd, ZGESVD) (const char*, const char*, const int&,
 				const int&, Complex*, const int&,
 				double*, Complex*, const int&,
 				Complex*, const int&, Complex*,
 				const int&, double*, int&, long,
diff --git a/liboctave/EIG.cc b/liboctave/EIG.cc
--- a/liboctave/EIG.cc
+++ b/liboctave/EIG.cc
@@ -26,17 +26,16 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "EIG.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
-#include "mx-inlines.cc"
 
 extern "C"
 {
   int F77_FCN (dgeev, DGEEV) (const char*, const char*, const int&,
 			      double*, const int&, double*, double*,
 			      double*, const int&, double*,
 			      const int&, double*, const int&, int&,
 			      long, long);
diff --git a/liboctave/dbleCHOL.cc b/liboctave/dbleCHOL.cc
--- a/liboctave/dbleCHOL.cc
+++ b/liboctave/dbleCHOL.cc
@@ -26,17 +26,16 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "dbleCHOL.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
-#include "mx-inlines.cc"
 
 extern "C"
 {
   int F77_FCN (dpotrf, DPOTRF) (const char*, const int&, double*,
 				const int&, int&, long);
 }
 
 int
diff --git a/liboctave/dbleHESS.cc b/liboctave/dbleHESS.cc
--- a/liboctave/dbleHESS.cc
+++ b/liboctave/dbleHESS.cc
@@ -26,17 +26,16 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "dbleHESS.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
-#include "mx-inlines.cc"
 
 extern "C"
 {
   int F77_FCN (dgebal, DGEBAL) (const char*, const int&, double*,
 				const int&, int&, int&, double*,
 				int&, long, long);
 
   int F77_FCN (dgehrd, DGEHRD) (const int&, const int&, const int&,
diff --git a/liboctave/dbleLU.cc b/liboctave/dbleLU.cc
--- a/liboctave/dbleLU.cc
+++ b/liboctave/dbleLU.cc
@@ -26,17 +26,16 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "dbleLU.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
-#include "mx-inlines.cc"
 
 // Instantiate the base LU class for the types we need.
 
 #include <base-lu.h>
 #include <base-lu.cc>
 
 template class base_lu <Matrix, double, Matrix, double>;
 
diff --git a/liboctave/dbleQR.cc b/liboctave/dbleQR.cc
--- a/liboctave/dbleQR.cc
+++ b/liboctave/dbleQR.cc
@@ -26,17 +26,16 @@ Software Foundation, 59 Temple Place - S
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include "dbleQR.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
-#include "mx-inlines.cc"
 
 extern "C"
 {
   int F77_FCN (dgeqrf, DGEQRF) (const int&, const int&, double*,
 				const int&, double*, double*,
 				const int&, int&); 
 
   int F77_FCN (dorgqr, DORGQR) (const int&, const int&, const int&,
diff --git a/liboctave/dbleQRP.cc b/liboctave/dbleQRP.cc
--- a/liboctave/dbleQRP.cc
+++ b/liboctave/dbleQRP.cc
@@ -28,17 +28,16 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include <cassert>
 
 #include "dbleQRP.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
-#include "mx-inlines.cc"
 
 extern "C"
 {
   int F77_FCN (dgeqpf, DGEQPF) (const int&, const int&, double*,
 				const int&, int*, double*, double*,
 				int&);
 
   int F77_FCN (dorgqr, DORGQR) (const int&, const int&, const int&,
diff --git a/liboctave/dbleSCHUR.cc b/liboctave/dbleSCHUR.cc
--- a/liboctave/dbleSCHUR.cc
+++ b/liboctave/dbleSCHUR.cc
@@ -28,17 +28,16 @@ Software Foundation, 59 Temple Place - S
 #include <config.h>
 #endif
 
 #include <iostream.h>
 
 #include "dbleSCHUR.h"
 #include "f77-fcn.h"
 #include "lo-error.h"
-#include "mx-inlines.cc"
 
 extern "C"
 {
   int F77_FCN (dgeesx, DGEESX) (const char*, const char*,
 				SCHUR::select_function, const char*,
 				const int&, double*, const int&,
 				int&, double*, double*, double*,
 				const int&, double&, double&, double*,
diff --git a/liboctave/dbleSVD.cc b/liboctave/dbleSVD.cc
--- a/liboctave/dbleSVD.cc
+++ b/liboctave/dbleSVD.cc
@@ -27,17 +27,16 @@ Software Foundation, 59 Temple Place - S
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <iostream.h>
 
 #include "dbleSVD.h"
 #include "f77-fcn.h"
-#include "mx-inlines.cc"
 
 extern "C"
 {
   int F77_FCN (dgesvd, DGESVD) (const char*, const char*, const int&,
 				const int&, double*, const int&,
 				double*, double*, const int&, double*,
 				const int&, double*, const int&, int&,
 				long, long);
diff --git a/liboctave/mx-inlines.cc b/liboctave/mx-inlines.cc
--- a/liboctave/mx-inlines.cc
+++ b/liboctave/mx-inlines.cc
@@ -1,9 +1,8 @@
-// Helper functions for matrix classes.
 /*
 
 Copyright (C) 1996 John W. Eaton
 
 This file is part of Octave.
 
 Octave is free software; you can redistribute it and/or modify it
 under the terms of the GNU General Public License as published by the
@@ -16,830 +15,185 @@ FITNESS FOR A PARTICULAR PURPOSE.  See t
 for more details.
 
 You should have received a copy of the GNU General Public License
 along with Octave; see the file COPYING.  If not, write to the Free
 Software Foundation, 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
 
 */
 
+#if !defined (octave_mx_ops_h)
+#define octave_mx_ops 1
+
+#include <cstddef>
+
 #include "oct-cmplx.h"
 
-// But first, some helper functions...
-
-// XXX FIXME XXX -- these need to be done with templates...
-
-static inline bool
-equal (const char *x, const char *y, int len)
-{
-  for (int i = 0; i < len; i++)
-    if (x[i] != y[i])
-      return false;
-
-  return true;
-}
-
-static inline double *
-add (const double *d, int len, double s)
-{
-  double *result = 0;
-  if (len > 0)
-    {
-      result = new double [len];
-      for (int i = 0; i < len; i++)
-	result[i] = d[i] + s;
-    }
-  return result;
-}
-
-static inline double *
-subtract (const double *d, int len, double s)
-{
-  double *result = 0;
-  if (len > 0)
-    {
-      result = new double [len];
-      for (int i = 0; i < len; i++)
-	result[i] = d[i] - s;
-    }
-  return result;
-}
-
-static inline double *
-subtract (double s, const double *d, int len)
-{
-  double *result = 0;
-  if (len > 0)
-    {
-      result = new double [len];
-      for (int i = 0; i < len; i++)
-	result[i] = s - d[i];
-    }
-  return result;
-}
-
-static inline double *
-multiply (const double *d, int len, double s)
-{
-  double *result = 0;
-  if (len > 0)
-    {
-      result = new double [len];
-      for (int i = 0; i < len; i++)
-	result[i] = d[i] * s;
-    }
-  return result;
-}
-
-static inline double *
-divide (const double *d, int len, double s)
-{
-  double *result = 0;
-  if (len > 0)
-    {
-      result = new double [len];
-      for (int i = 0; i < len; i++)
-	result[i] = d[i] / s;
-    }
-  return result;
-}
-
-static inline double *
-divide (double s, const double *d, int len)
-{
-  double *result = 0;
-  if (len > 0)
-    {
-      result = new double [len];
-      for (int i = 0; i < len; i++)
-	result[i] = s / d[i];
-    }
-  return result;
-}
+// Before you suggest it:  I tried templates but they didn't work with
+// gcc 2.7.2.
 
-static inline double *
-add (const double *x, const double *y, int len)
-{
-  double *result = 0;
-  if (len > 0)
-    {
-      result = new double [len];
-      for (int i = 0; i < len; i++)
-	result[i] = x[i] + y[i];
-    }
-  return result;
-}
-
-static inline double *
-subtract (const double *x, const double *y, int len)
-{
-  double *result = 0;
-  if (len > 0)
-    {
-      result = new double [len];
-      for (int i = 0; i < len; i++)
-	result[i] = x[i] - y[i];
-    }
-  return result;
-}
-
-static inline double *
-multiply (const double *x, const double *y, int len)
-{
-  double *result = 0;
-  if (len > 0)
-    {
-      result = new double [len];
-      for (int i = 0; i < len; i++)
-	result[i] = x[i] * y[i];
-    }
-  return result;
-}
+#define VS_OP(F, OP, R, V, S) \
+  static inline R * \
+  F (const V *v, size_t n, S s) \
+  { \
+    R *r = 0; \
+    if (n > 0) \
+      { \
+	r = new R [n]; \
+	for (size_t i = 0; i < n; i++) \
+	  r[i] = v[i] OP s; \
+      } \
+    return r; \
+  }
 
-static inline double *
-divide (const double *x, const double *y, int len)
-{
-  double *result = 0;
-  if (len > 0)
-    {
-      result = new double [len];
-      for (int i = 0; i < len; i++)
-	result[i] = x[i] / y[i];
-    }
-  return result;
-}
-
-static inline double *
-add2 (double *x, const double *y, int len)
-{
-  for (int i = 0; i < len; i++)
-    x[i] += y[i];
-  return x;
-}
+#define VS_OPS(R, V, S) \
+  VS_OP (add, +, R, S, V) \
+  VS_OP (subtract, -, R, S, V) \
+  VS_OP (multiply, *, R, S, V) \
+  VS_OP (divide, /, R, S, V)
 
-static inline double *
-subtract2 (double *x, const double *y, int len)
-{
-  for (int i = 0; i < len; i++)
-    x[i] -= y[i];
-  return x;
-}
-
-static inline double *
-negate (const double *d, int len)
-{
-  double *result = 0;
-  if (len > 0)
-    {
-      result = new double [len];
-      for (int i = 0; i < len; i++)
-	result[i] = -d[i];
-    }
-  return result;
-}
-
-static inline void
-copy (double *d, int len, double s)
-{
-  for (int i = 0; i < len; i++)
-    d[i] = s;
-}
-
-static inline void
-copy (double *x, const double *y, int len)
-{
-  for (int i = 0; i < len; i++)
-    x[i] = y[i];
-}
+VS_OPS (double,  double,  double)
+VS_OPS (Complex, double,  Complex)
+VS_OPS (Complex, Complex, double)
+VS_OPS (Complex, Complex, Complex)
 
-static inline double *
-dup (const double *x, int len)
-{
-  double *retval = 0;
-  if (len > 0)
-    {
-      retval = new double [len];
-      for (int i = 0; i < len; i++)
-	retval[i] = x[i];
-    }
-  return retval;
-}
-
-static inline int
-equal (const double *x, const double *y, int len)
-{
-  for (int i = 0; i < len; i++)
-    if (x[i] != y[i])
-      return 0;
-  return 1;
-}
-
-// And some for Complex too...
-
-static inline Complex *
-add (const Complex *d, int len, Complex s)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = d[i] + s;
-    }
-  return result;
-}
-
-static inline Complex *
-add (Complex s, const Complex *d, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = s + d[i];
-    }
-  return result;
-}
+#define SV_OP(F, OP, R, S, V) \
+  static inline R * \
+  F (S s, const V *v, size_t n) \
+  { \
+    R *r = 0; \
+    if (n > 0) \
+      { \
+	r = new R [n]; \
+	for (size_t i = 0; i < n; i++) \
+	  r[i] = s OP v[i]; \
+      } \
+    return r; \
+  }
 
-static inline Complex *
-subtract (const Complex *d, int len, Complex s)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = d[i] - s;
-    }
-  return result;
-}
-
-static inline Complex *
-subtract (Complex s, const Complex *d, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = s - d[i];
-    }
-  return result;
-}
+#define SV_OPS(R, S, V) \
+  SV_OP (add,      +, R, V, S) \
+  SV_OP (subtract, -, R, V, S) \
+  SV_OP (multiply, *, R, V, S) \
+  SV_OP (divide,   /, R, V, S)
 
-static inline Complex *
-multiply (const Complex *d, int len, Complex s)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = d[i] * s;
-    }
-  return result;
-}
-
-static inline Complex *
-multiply (Complex s, const Complex *d, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = s * d[i];
-    }
-  return result;
-}
+SV_OPS (double,  double,  double)
+SV_OPS (Complex, double,  Complex)
+SV_OPS (Complex, Complex, double)
+SV_OPS (Complex, Complex, Complex)
 
-static inline Complex *
-divide (const Complex *d, int len, Complex s)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = d[i] / s;
-    }
-  return result;
-}
-
-static inline Complex *
-divide (Complex s, const Complex *d, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = s / d[i];
-    }
-  return result;
-}
-
-static inline Complex *
-add (const Complex *x, const Complex *y, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = x[i] + y[i];
-    }
-  return result;
-}
-
-static inline Complex *
-subtract (const Complex *x, const Complex *y, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = x[i] - y[i];
-    }
-  return result;
-}
+#define VV_OP(F, OP, R, T1, T2) \
+  static inline R * \
+  F (const T1 *v1, const T2 *v2, size_t n) \
+  { \
+    R *r = 0; \
+    if (n > 0) \
+      { \
+	r = new R [n]; \
+	for (size_t i = 0; i < n; i++) \
+	  r[i] = v1[i] OP v2[i]; \
+      } \
+    return r; \
+  }
 
-static inline Complex *
-multiply (const Complex *x, const Complex *y, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = x[i] * y[i];
-    }
-  return result;
-}
-
-static inline Complex *
-divide (const Complex *x, const Complex *y, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = x[i] / y[i];
-    }
-  return result;
-}
+#define VV_OPS(R, T1, T2) \
+  VV_OP (add,      +, R, T1, T2) \
+  VV_OP (subtract, -, R, T1, T2) \
+  VV_OP (multiply, *, R, T1, T2) \
+  VV_OP (divide,   /, R, T1, T2)
 
-static inline Complex *
-add2 (Complex *x, const Complex *y, int len)
-{
-  for (int i = 0; i < len; i++)
-    x[i] += y[i];
-  return x;
-}
-
-static inline Complex *
-subtract2 (Complex *x, const Complex *y, int len)
-{
-  for (int i = 0; i < len; i++)
-    x[i] -= y[i];
-  return x;
-}
-
-static inline Complex *
-negate (const Complex *d, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = -d[i];
-    }
-  return result;
-}
+VV_OPS (double,  double,  double)
+VV_OPS (Complex, double,  Complex)
+VV_OPS (Complex, Complex, double)
+VV_OPS (Complex, Complex, Complex)
 
-static inline double *
-not (const Complex *d, int len)
-{
-  double *result = 0;
-  if (len > 0)
-    {
-      result = new double [len];
-      for (int i = 0; i < len; i++)
-	result[i] = (d[i] == 0.0);
-    }
-  return result;
-}
-
-static inline void
-copy (Complex *d, int len, Complex s)
-{
-  for (int i = 0; i < len; i++)
-    d[i] = s;
-}
-
-static inline void
-copy (Complex *x, const Complex *y, int len)
-{
-  for (int i = 0; i < len; i++)
-    x[i] = y[i];
-}
-
-static inline Complex *
-dup (const Complex *x, int len)
-{
-  Complex *retval = 0;
-  if (len > 0)
-    {
-      retval = new Complex [len];
-      for (int i = 0; i < len; i++)
-	retval[i] = x[i];
-    }
-  return retval;
-}
+#define VS_OP2(F, OP, V, S) \
+  static inline V * \
+  F (V *v, size_t n, S s) \
+  { \
+    for (size_t i = 0; i < n; i++) \
+      v[i] OP s; \
+    return v; \
+  }
 
-static inline Complex *
-make_complex (const double *x, int len)
-{
-  Complex *retval = 0;
-  if (len > 0)
-    {
-      retval = new Complex [len];
-      for (int i = 0; i < len; i++)
-	retval[i] = x[i];
-    }
-  return retval;
-}
-
-static inline Complex *
-conj_dup (const Complex *x, int len)
-{
-  Complex *retval = 0;
-  if (len > 0)
-    {
-      retval = new Complex [len];
-      for (int i = 0; i < len; i++)
-	retval[i] = conj (x[i]);
-    }
-  return retval;
-}
+#define VS_OP2S(V, S) \
+  VS_OP2 (add2,      +=, V, S) \
+  VS_OP2 (subtract2, -=, V, S) \
+  VS_OP2 (multiply2, *=, V, S) \
+  VS_OP2 (divide2,   /=, V, S) \
+  VS_OP2 (copy,       =, V, S)
 
-static inline double *
-real_dup (const Complex *x, int len)
-{
-  double *retval = 0;
-  if (len > 0)
-    {
-      retval = new double [len];
-      for (int i = 0; i < len; i++)
-	retval[i] = real (x[i]);
-    }
-  return retval;
-}
-
-static inline double *
-imag_dup (const Complex *x, int len)
-{
-  double *retval = 0;
-  if (len > 0)
-    {
-      retval = new double [len];
-      for (int i = 0; i < len; i++)
-	retval[i] = imag (x[i]);
-    }
-  return retval;
-}
-
-static inline int
-equal (const Complex *x, const Complex *y, int len)
-{
-  for (int i = 0; i < len; i++)
-    if (x[i] != y[i])
-      return 0;
-  return 1;
-}
-
-// And still some more for mixed Complex/double operations...
+VS_OP2S (double,  double)
+VS_OP2S (Complex, double)
+VS_OP2S (Complex, Complex)
 
-static inline Complex *
-add (const Complex *d, int len, double s)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = d[i] + s;
-    }
-  return result;
-}
-
-static inline Complex *
-add (const double *d, int len, Complex s)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = d[i] + s;
-    }
-  return result;
-}
-
-static inline Complex *
-add (double s, const Complex *d, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = s + d[i];
-    }
-  return result;
-}
-
-static inline Complex *
-add (Complex s, const double *d, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = s + d[i];
-    }
-  return result;
-}
+#define VV_OP2(F, OP, T1, T2) \
+  static inline T1 * \
+  F (T1 *v1, const T2 *v2, size_t n) \
+  { \
+    for (size_t i = 0; i < n; i++) \
+      v1[i] OP v2[i]; \
+    return v1; \
+  }
 
-static inline Complex *
-subtract (const Complex *d, int len, double s)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = d[i] - s;
-    }
-  return result;
-}
-
-static inline Complex *
-subtract (const double *d, int len, Complex s)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = d[i] - s;
-    }
-  return result;
-}
+#define VV_OP2S(T1, T2) \
+  VV_OP2 (add2,      +=, T1, T2) \
+  VV_OP2 (subtract2, -=, T1, T2) \
+  VV_OP2 (multiply2, *=, T1, T2) \
+  VV_OP2 (divide2,   /=, T1, T2) \
+  VV_OP2 (copy,       =, T1, T2)
 
-static inline Complex *
-subtract (double s, const Complex *d, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = s - d[i];
-    }
-  return result;
-}
-
-static inline Complex *
-subtract (Complex s, const double *d, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = s - d[i];
-    }
-  return result;
-}
+VV_OP2S (double,  double)
+VV_OP2S (Complex, double)
+VV_OP2S (Complex, Complex)
 
-static inline Complex *
-multiply (const Complex *d, int len, double s)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = d[i] * s;
-    }
-  return result;
-}
-
-static inline Complex *
-multiply (const double *d, int len, Complex s)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = d[i] * s;
-    }
-  return result;
-}
-
-static inline Complex *
-divide (const Complex *d, int len, double s)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = d[i] / s;
-    }
-  return result;
-}
-
-static inline Complex *
-divide (const double *d, int len, Complex s)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = d[i] / s;
-    }
-  return result;
-}
+#define OP_EQ_FCN(T1, T2) \
+  static inline bool \
+  equal (const T1 *x, const T2 *y, size_t n) \
+  { \
+    for (size_t i = 0; i < n; i++) \
+      if (x[i] != y[i]) \
+	return false; \
+    return true; \
+  }
 
-static inline Complex *
-divide (double s, const Complex *d, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = s / d[i];
-    }
-  return result;
-}
-
-static inline Complex *
-divide (Complex s, const double *d, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = s / d[i];
-    }
-  return result;
-}
-
-static inline Complex *
-add (const Complex *x, const double *y, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = x[i] + y[i];
-    }
-  return result;
-}
-
-static inline Complex *
-add (const double *x, const Complex *y, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = x[i] + y[i];
-    }
-  return result;
-}
+OP_EQ_FCN (char,    char)
+OP_EQ_FCN (double,  double)
+OP_EQ_FCN (Complex, Complex)
 
-static inline Complex *
-subtract (const Complex *x, const double *y, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = x[i] - y[i];
-    }
-  return result;
-}
-
-static inline Complex *
-subtract (const double *x, const Complex *y, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = x[i] - y[i];
-    }
-  return result;
-}
-
-static inline Complex *
-multiply (const Complex *x, const double *y, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = x[i] * y[i];
-    }
-  return result;
-}
-
-static inline Complex *
-multiply (const double *x, const Complex *y, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = x[i] * y[i];
-    }
-  return result;
-}
+#define OP_DUP_FCN(OP, F, R, T) \
+  static inline R * \
+  F (const T *x, size_t n) \
+  { \
+    R *r = 0; \
+    if (n > 0) \
+      { \
+	r = new R [n]; \
+	for (size_t i = 0; i < n; i++) \
+	  r[i] = OP (x[i]); \
+      } \
+    return r; \
+  }
 
-static inline Complex *
-divide (const Complex *x, const double *y, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = x[i] / y[i];
-    }
-  return result;
-}
+OP_DUP_FCN (, dup, double,  double)
+OP_DUP_FCN (, dup, Complex, Complex)
 
-static inline Complex *
-divide (const double *x, const Complex *y, int len)
-{
-  Complex *result = 0;
-  if (len > 0)
-    {
-      result = new Complex [len];
-      for (int i = 0; i < len; i++)
-	result[i] = x[i] / y[i];
-    }
-  return result;
-}
+// These should really return a bool *.  Also, they should probably be
+// in with a collection of other element-by-element boolean ops.
+OP_DUP_FCN (0.0 ==, not, double, double)
+OP_DUP_FCN (0.0 ==, not, double, Complex)
 
-static inline Complex *
-add2 (Complex *x, const double *y, int len)
-{
-  for (int i = 0; i < len; i++)
-    x[i] += y[i];
-  return x;
-}
+OP_DUP_FCN (, make_complex, Complex, double)
+
+OP_DUP_FCN (-, negate, double,  double)
+OP_DUP_FCN (-, negate, Complex, Complex)
 
-static inline Complex *
-subtract2 (Complex *x, const double *y, int len)
-{
-  for (int i = 0; i < len; i++)
-    x[i] -= y[i];
-  return x;
-}
+OP_DUP_FCN (real, real_dup, double,  Complex)
+OP_DUP_FCN (imag, imag_dup, double,  Complex)
+OP_DUP_FCN (conj, conj_dup, Complex, Complex)
 
-static inline void
-copy (Complex *d, int len, double s)
-{
-  for (int i = 0; i < len; i++)
-    d[i] = s;
-}
-
-static inline void
-copy (Complex *x, const double *y, int len)
-{
-  for (int i = 0; i < len; i++)
-    x[i] = y[i];
-}
+#endif
 
 /*
 ;;; Local Variables: ***
 ;;; mode: C++ ***
 ;;; End: ***
 */
diff --git a/src/help.cc b/src/help.cc
--- a/src/help.cc
+++ b/src/help.cc
@@ -604,17 +604,17 @@ help_from_info (const string_vector&, in
   message (0, "sorry, help -i is not available in this version of Octave");
 }
 #endif
 
 int
 help_from_list (ostream& os, const help_list *list,
 		const string& nm, int usage)
 {
-  char *name;
+  const char *name;
   while ((name = list->name) != 0)
     {
       if (strcmp (name, nm.c_str ()) == 0)
 	{
 	  if (usage)
 	    os << "\nusage: ";
 	  else
 	    {
diff --git a/src/help.h b/src/help.h
--- a/src/help.h
+++ b/src/help.h
@@ -28,18 +28,18 @@ class ostrstream;
 #include <string>
 
 class string_vector;
 
 // XXX FIXME XXX -- should probably use string, not char*.
 
 struct help_list
 {
-  char *name;
-  char *help;
+  const char *name;
+  const char *help;
 };
 
 extern string_vector names (help_list *l, int& count);
 extern help_list *operator_help (void);
 extern help_list *keyword_help (void);
 
 extern void print_usage (const string& nm, int just_usage = 0);
 
diff --git a/src/lex.l b/src/lex.l
--- a/src/lex.l
+++ b/src/lex.l
@@ -169,17 +169,17 @@ static int Vwhitespace_in_literal_matrix
 static void do_string_escapes (char *s);
 static void fixup_column_count (char *s);
 static void do_comma_insert_check (void);
 static int is_plot_keyword (const string& s);
 static int is_keyword (const string& s);
 static string plot_style_token (const string& s);
 static symbol_record *lookup_identifier (const string& s);
 static void grab_help_text (void);
-static int match_any (char c, char *s);
+static int match_any (char c, const char *s);
 static int next_token_is_bin_op (int spc_prev, char *yytext);
 static int next_token_is_postfix_unary_op (int spc_prev, char *yytext);
 static string strip_trailing_whitespace (char *s);
 static void handle_number (char *yytext);
 static int handle_string (char delim, int text_style = 0);
 static int handle_close_brace (int spc_gobbled);
 static int handle_identifier (const string& tok, int spc_gobbled);
 static int have_continuation (int trailing_comments_ok = 1);
@@ -850,17 +850,17 @@ delete_input_buffer (void *buf)
 // Check to see if a character string matches any of the possible line
 // styles for plots.
 
 static string
 plot_style_token (const string& s)
 {
   string retval;
 
-  static char *plot_styles[] = 
+  static const char *plot_styles[] = 
     {
       "boxes",
       "boxerrorbars",
       "boxxyerrorbars",
       "candlesticks",
       "dots",
       "errorbars",
       "financebars",
@@ -873,17 +873,17 @@ plot_style_token (const string& s)
       "steps",
       "vector",
       "xerrorbars",
       "xyerrorbars",
       "yerrorbars",
       0,
     };
 
-  char **tmp = plot_styles;
+  const char * const *tmp = plot_styles;
   while (*tmp)
     {
       if (almost_match (*tmp, s.c_str ()))
 	{
 	  retval = *tmp;
 	  break;
 	}
 
@@ -1155,17 +1155,17 @@ grab_help_text (void)
   if (c)
     yyunput (c, yytext);
 }
 
 // Return 1 if the given character matches any character in the given
 // string.
 
 static int
-match_any (char c, char *s)
+match_any (char c, const char *s)
 {
   char tmp;
   while ((tmp = *s++) != '\0')
     {
       if (c == tmp)
 	return 1;
     }
   return 0;
diff --git a/src/load-save.cc b/src/load-save.cc
--- a/src/load-save.cc
+++ b/src/load-save.cc
@@ -246,17 +246,17 @@ skip_comments (istream& is)
 // Extract a KEYWORD and its value from stream IS, returning the
 // associated value in a new string.
 //
 // Input should look something like:
 //
 //  #[ \t]*keyword[ \t]*:[ \t]*string-value[ \t]*\n
 
 static char *
-extract_keyword (istream& is, char *keyword)
+extract_keyword (istream& is, const char *keyword)
 {
   char *retval = 0;
 
   char c;
   while (is.get (c))
     {
       if (c == '#')
 	{
@@ -313,17 +313,17 @@ extract_keyword (istream& is, char *keyw
 // Match KEYWORD on stream IS, placing the associated value in VALUE,
 // returning 1 if successful and 0 otherwise.
 //
 // Input should look something like:
 //
 //  [ \t]*keyword[ \t]*int-value.*\n
 
 static int
-extract_keyword (istream& is, char *keyword, int& value)
+extract_keyword (istream& is, const char *keyword, int& value)
 {
   int status = 0;
   value = 0;
 
   char c;
   while (is.get (c))
     {
       if (c == '#')
@@ -1988,17 +1988,17 @@ save_mat_binary_data (ostream& os, const
     }
   else
     gripe_wrong_type_arg ("save", tc, false);
 
   return os;
 }
 
 static void
-ascii_save_type (ostream& os, char *type, bool mark_as_global)
+ascii_save_type (ostream& os, const char *type, bool mark_as_global)
 {
   if (mark_as_global)
     os << "# type: global ";
   else
     os << "# type: ";
 
   os << type << "\n";
 }
diff --git a/src/mappers.cc b/src/mappers.cc
--- a/src/mappers.cc
+++ b/src/mappers.cc
@@ -20,315 +20,20 @@ Software Foundation, 59 Temple Place - S
 
 */
 
 #ifdef HAVE_CONFIG_H
 #include <config.h>
 #endif
 
 #include <cctype>
-#include <cfloat>
-
-#include "oct-cmplx.h"
-#include "oct-math.h"
-#include "lo-ieee.h"
 
 #include "defun.h"
 #include "error.h"
-#include "f77-fcn.h"
 #include "mappers.h"
-#include "sysdep.h"
-#include "utils.h"
-#include "variables.h"
-
-#if defined (_AIX) && defined (__GNUG__)
-#undef finite
-#define finite(x) ((x) < DBL_MAX && (x) > -DBL_MAX)
-#endif
-
-extern "C"
-{
-  double F77_FCN (dgamma, DGAMMA) (const double&);
-  int F77_FCN (dlgams, DLGAMS) (const double&, double&, double&);
-}
-
-#ifndef M_LOG10E
-#define M_LOG10E 0.43429448190325182765
-#endif
-
-#ifndef M_PI
-#define M_PI 3.14159265358979323846
-#endif
-
-#if defined (HAVE_LGAMMA) && ! defined (SIGNGAM_DECLARED)
-extern int signgam;
-#endif
-
-// Double -> double mappers.
-
-double
-arg (double x)
-{
-  if (x < 0.0)
-    return M_PI;
-  else
-#if defined (HAVE_ISNAN)
-    return xisnan (x) ? octave_NaN : 0.0;
-#else
-    return 0.0;
-#endif
-}
-
-double
-conj (double x)
-{
-  return x;
-}
-
-double
-fix (double x)
-{
-  return static_cast<int> (x);
-}
-
-double
-imag (double x)
-{
-#if defined (HAVE_ISNAN)
-  return xisnan (x) ? octave_NaN : 0.0;
-#else
-  return 0.0;
-#endif
-}
-
-double
-real (double x)
-{
-  return x;
-}
-
-double
-round (double x)
-{
-  return D_NINT (x);
-}
-
-double
-signum (double x)
-{
-  double tmp = 0.0;
-  if (x < 0.0)
-    tmp = -1.0;
-  else if (x > 0.0)
-    tmp = 1.0;
-
-#if defined (HAVE_ISNAN)
-  return xisnan (x) ? octave_NaN : tmp;
-#else
-  return tmp;
-#endif
-}
-
-double
-xerf (double x)
-{
-#if defined (HAVE_ERF)
-  return erf (x);
-#else
-  error ("erf(x) not available on this system");
-#endif
-}
-
-double
-xerfc (double x)
-{
-#if defined (HAVE_ERFC)
-  return erfc (x);
-#else
-  error ("erfc(x) not available on this system");
-#endif
-}
-
-double
-xisnan (double x)
-{
-#if defined (HAVE_ISNAN)
-  return isnan (x);
-#else
-  return 0;
-#endif
-}
-
-double
-xfinite (double x)
-{
-#if defined (HAVE_FINITE)
-  return finite (x);
-#elif defined (HAVE_ISINF) && defined (HAVE_ISNAN)
-  return (! isinf (x) && ! isnan (x));
-#else
-  return 1;
-#endif
-}
-
-double
-xgamma (double x)
-{
-  return F77_FCN (dgamma, DGAMMA) (x);
-}
-
-double
-xisinf (double x)
-{
-#if defined (HAVE_ISINF)
-  return isinf (x);
-#elif defined (HAVE_FINITE) && defined (HAVE_ISNAN)
-  return (! (finite (x) || isnan (x)));
-#else
-  return 0;
-#endif
-}
-
-double
-xlgamma (double x)
-{
-  double result;
-  double sgngam;
-
-  F77_FCN (dlgams, DLGAMS) (x, result, sgngam);
-
-  return result;
-}
-
-// Complex -> double mappers.
-
-double
-xisnan (const Complex& x)
-{
-#if defined (HAVE_ISNAN)
-  double rx = real (x);
-  double ix = imag (x);
-  return (isnan (rx) || isnan (ix));
-#else
-  return 0;
-#endif
-}
-
-double
-xfinite (const Complex& x)
-{
-  double rx = real (x);
-  double ix = imag (x);
-  return (! (xisinf (rx) || xisinf (ix)));
-}
-
-double
-xisinf (const Complex& x)
-{
-  return (! xfinite (x));
-}
-
-// Complex -> complex mappers.
-
-Complex
-acos (const Complex& x)
-{
-  static Complex i (0, 1);
-  Complex retval = -i * log (x + sqrt (x*x - 1.0));
-  return retval;
-}
-
-Complex
-acosh (const Complex& x)
-{
-  Complex retval = log (x + sqrt (x*x - 1.0));
-  return retval;
-}
-
-Complex
-asin (const Complex& x)
-{
-  static Complex i (0, 1);
-  Complex retval = -i * log (i*x + sqrt (1.0 - x*x));
-  return retval;
-}
-
-Complex
-asinh (const Complex& x)
-{
-  Complex retval = log (x + sqrt (x*x + 1.0));
-  return retval;
-}
-
-Complex
-atan (const Complex& x)
-{
-  static Complex i (0, 1);
-  Complex retval = i * log ((i + x) / (i - x)) / 2.0;
-  return retval;
-}
-
-Complex
-atanh (const Complex& x)
-{
-  static Complex i (0, 1);
-  Complex retval = log ((1 + x) / (1 - x)) / 2.0;
-  return retval;
-}
-
-Complex
-ceil (const Complex& x)
-{
-  return Complex (ceil (real (x)), ceil (imag (x)));
-}
-
-Complex
-fix (const Complex& x)
-{
-  return Complex (static_cast<int> (real (x)),
-		  static_cast<int> (imag (x)));
-}
-
-Complex
-floor (const Complex& x)
-{
-  return Complex (floor (real (x)), floor (imag (x)));
-}
-
-Complex
-log10 (const Complex& x)
-{
-  return M_LOG10E * log (x);
-}
-
-Complex
-round (const Complex& x)
-{
-  return Complex (D_NINT (real (x)), D_NINT (imag (x)));
-}
-
-Complex
-signum (const Complex& x)
-{
-  return x / abs (x);
-}
-
-Complex
-tan (const Complex& x)
-{
-  Complex retval = sin (x) / cos (x);
-  return retval;
-}
-
-Complex
-tanh (const Complex& x)
-{
-  Complex retval = sinh (x) / cosh (x);
-  return retval;
-}
 
 // XXX FIXME XXX -- perhaps this could be avoided by determining
 // whether the is* functions are actually functions or just macros.
 
 int
 xisalnum (int c)
 {
   return isalnum (c);
diff --git a/src/oct-hist.cc b/src/oct-hist.cc
--- a/src/oct-hist.cc
+++ b/src/oct-hist.cc
@@ -307,17 +307,17 @@ edit_history_add_hist (const string& lin
 
       if (! tmp.empty ())
 	octave_command_history.add (tmp);
     }
 }
 
 static string
 mk_tmp_hist_file (int argc, const string_vector& argv,
-		  int insert_curr, char *warn_for) 
+		  int insert_curr, const char *warn_for) 
 {
   string retval;
 
   string_vector hlist = octave_command_history.list ();
 
   int hist_count = hlist.length ();
 
   // The current command line is already part of the history list by
diff --git a/src/oct-strstrm.cc b/src/oct-strstrm.cc
--- a/src/oct-strstrm.cc
+++ b/src/oct-strstrm.cc
@@ -55,17 +55,17 @@ long
 octave_base_strstream::tell (void) const
 {
   long retval = -1;
 
   if (! bad ())
     {
       // XXX FIXME XXX -- shouldn't have to do this!
 
-      streambuf *sb = (static_cast<octave_base_strstream *>(this))->rdbuf ();
+      streambuf *sb = (const_cast<octave_base_strstream *>(this))->rdbuf ();
 
       if (sb)
 	{
 	  retval = static_cast<long> (sb->seekoff (0, ios::cur));
 
 	  if (bad ())
 	    retval = -1;
 	}
diff --git a/src/octave.cc b/src/octave.cc
--- a/src/octave.cc
+++ b/src/octave.cc
@@ -270,17 +270,17 @@ execute_startup_files (void)
   if (read_init_files)
     {
       // Try to execute commands from $HOME/$OCTAVE_INITFILE and
       // $OCTAVE_INITFILE.  If $OCTAVE_INITFILE is not set, .octaverc
       // is assumed.
 
       int home_rc_already_executed = 0;
 
-      char *initfile = getenv ("OCTAVE_INITFILE");
+      const char *initfile = getenv ("OCTAVE_INITFILE");
 
       if (! initfile)
 	initfile = ".octaverc";
 
       string home_rc = Vhome_directory + "/" + initfile;
       string local_rc = string ("./") + initfile;
 
       if (! Vhome_directory.empty ())
diff --git a/src/octave.gperf b/src/octave.gperf
--- a/src/octave.gperf
+++ b/src/octave.gperf
@@ -29,17 +29,17 @@ enum octave_kw_id
   switch_kw,
   try_kw,
   unwind_protect_kw,
   unwind_protect_cleanup_kw,
   while_kw
 };
 
 %}
-struct octave_kw { char *name; int tok; octave_kw_id kw_id; };
+struct octave_kw { const char *name; int tok; octave_kw_id kw_id; };
 %%
 all_va_args, ALL_VA_ARGS, all_va_args_kw
 break, BREAK, break_kw
 case, CASE, case_kw
 catch, CATCH, catch_kw
 continue, CONTINUE, continue_kw
 else, ELSE, else_kw
 elseif, ELSEIF, elseif_kw
diff --git a/src/ov.h b/src/ov.h
--- a/src/ov.h
+++ b/src/ov.h
@@ -392,17 +392,16 @@ protected:
   octave_value (const octave_xvalue&) : rep (0) { }
 
 private:
 
   static octave_allocator allocator;
 
   union
     {
-      octave_value *freeptr;  // For custom memory management.
       octave_value *rep;      // The real representation.
       int count;              // A reference count.
     };
 
   bool convert_and_assign (const octave_value_list& idx,
 			   const octave_value& rhs);
 
   bool try_assignment_with_conversion (const octave_value_list& idx,
diff --git a/src/pr-output.cc b/src/pr-output.cc
--- a/src/pr-output.cc
+++ b/src/pr-output.cc
@@ -977,17 +977,17 @@ pr_any_float (const char *fmt, ostream& 
 		{
 		  for (int i = sizeof (double) - 1; i >= 0; i--)
 		    PRINT_CHAR_BITS (os, tmp.i[i]);
 		}
 	    }
 	}
       else if (xisinf (d))
 	{
-	  char *s;
+	  const char *s;
 	  if (d < 0.0)
 	    s = "-Inf";
 	  else
 	    s = "Inf";
 
 	  if (fw > 0)
 	    os.form ("%*s", fw, s);
 	  else
diff --git a/src/time.cc b/src/time.cc
--- a/src/time.cc
+++ b/src/time.cc
@@ -67,25 +67,25 @@ mk_tm_map (struct tm *tm, double fractio
 }
 
 static struct tm*
 extract_tm (Octave_map &m, double& fraction)
 {
   static struct tm tm;
 
   fraction = (m ["usec"] . double_value ()) / 1e6;
-  tm.tm_sec = NINT (m ["sec"] . double_value ());
-  tm.tm_min = NINT (m ["min"] . double_value ());
-  tm.tm_hour = NINT (m ["hour"] . double_value ());
-  tm.tm_mday = NINT (m ["mday"] . double_value ());
-  tm.tm_mon = NINT (m ["mon"] . double_value ());
-  tm.tm_year = NINT (m ["year"] . double_value ());
-  tm.tm_wday = NINT (m ["wday"] . double_value ());
-  tm.tm_yday = NINT (m ["yday"] . double_value ());
-  tm.tm_isdst = NINT (m ["isdst"] . double_value ());
+  tm.tm_sec = static_cast<int> (m ["sec"] . double_value ());
+  tm.tm_min = static_cast<int> (m ["min"] . double_value ());
+  tm.tm_hour = static_cast<int> (m ["hour"] . double_value ());
+  tm.tm_mday = static_cast<int> (m ["mday"] . double_value ());
+  tm.tm_mon = static_cast<int> (m ["mon"] . double_value ());
+  tm.tm_year = static_cast<int> (m ["year"] . double_value ());
+  tm.tm_wday = static_cast<int> (m ["wday"] . double_value ());
+  tm.tm_yday = static_cast<int> (m ["yday"] . double_value ());
+  tm.tm_isdst = static_cast<int> (m ["isdst"] . double_value ());
 #ifdef HAVE_TMZONE
   string tstr = m ["zone"] . string_value ();
   tm.tm_zone = tstr.c_str ();
 #endif
 
   return &tm;
 }
 
@@ -113,17 +113,17 @@ seconds since the epoch.")
   fraction = tp.tv_usec / 1e6;
 
 #else
 
   now = time (0);
 
 #endif
  
-  return static_cast<double> (now + fraction);
+  return static_cast<double> (now) + fraction;
 }
 
 DEFUN_DLD (gmtime, args, ,
   "gmtime (TIME)\n\
 \n\
 Given a value returned from time(), return a structure like that\n\
 returned from localtime() but with values corresponding to\n\
 Coordinated Universal Time (UTC).")
@@ -131,17 +131,17 @@ Coordinated Universal Time (UTC).")
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       double tmp = args(0).double_value ();
 
       if (! error_state)
 	{
-	  time_t timeval = NINT (tmp);
+	  time_t timeval = static_cast<int> (tmp);
 	  double ip;
 	  double fraction = modf (tmp, &ip); 
 
 	  retval = octave_value (mk_tm_map (gmtime (&timeval), fraction));
 	}
     }
   else
     print_usage ("gmtime");
@@ -170,17 +170,17 @@ the following elements:\n\
   octave_value_list retval;
 
   if (args.length () == 1)
     {
       double tmp = args(0).double_value ();
 
       if (! error_state)
 	{
-	  time_t timeval = NINT (tmp);
+	  time_t timeval = static_cast<int> (tmp);
 	  double ip;
 	  double fraction = modf (tmp, &ip); 
 
 	  retval = octave_value (mk_tm_map (localtime (&timeval), fraction));
 	}
     }
   else
     print_usage ("localtime");
@@ -197,17 +197,17 @@ DEFUN_DLD (mktime, args, ,
     {
       Octave_map map = args(0).map_value ();
 
       double fraction;
 
       struct tm *tm = extract_tm (map, fraction);
 
       if (! error_state)
-	retval = static_cast<double> (mktime (tm) + fraction);
+	retval = static_cast<double> (mktime (tm)) + fraction;
     }
   else
     print_usage ("mktime");
 
   return retval;
 }
 
 DEFUN_DLD (strftime, args, ,
diff --git a/src/xpow.cc b/src/xpow.cc
--- a/src/xpow.cc
+++ b/src/xpow.cc
@@ -160,17 +160,17 @@ xpow (const Matrix& a, double b)
   int nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       if (static_cast<int> (b) == b)
 	{
-	  int btmp = b;
+	  int btmp = static_cast<int> (b);
 	  if (btmp == 0)
 	    {
 	      retval = DiagMatrix (nr, nr, 1.0);
 	    }
 	  else
 	    {
 	      // Too much copying?
 	      // XXX FIXME XXX -- we shouldn't do this if the exponent is
@@ -345,17 +345,17 @@ xpow (const ComplexMatrix& a, double b)
   int nc = a.cols ();
 
   if (nr == 0 || nc == 0 || nr != nc)
     error ("for A^b, A must be square");
   else
     {
       if (static_cast<int> (b) == b)
 	{
-	  int btmp = b;
+	  int btmp = static_cast<int> (b);
 	  if (btmp == 0)
 	    {
 	      retval = DiagMatrix (nr, nr, 1.0);
 	    }
 	  else
 	    {
 	      // Too much copying?
 	      // XXX FIXME XXX -- we shouldn't do this if the exponent is
